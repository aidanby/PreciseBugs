{"buggy_code": ["// Copyright (c) 2009 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n#include \"gasp.h\"\n\n// gasp - Grid-fitting And Scan-conversion Procedure\n// http://www.microsoft.com/typography/otspec/gasp.htm\n\n#define TABLE_NAME \"gasp\"\n\n#define DROP_THIS_TABLE(...) \\\n  do { \\\n    delete file->gasp; \\\n    file->gasp = 0; \\\n    OTS_FAILURE_MSG_(file, TABLE_NAME \": \" __VA_ARGS__); \\\n    OTS_FAILURE_MSG(\"Table discarded\"); \\\n  } while (0)\n\nnamespace ots {\n\nbool ots_gasp_parse(OpenTypeFile *file, const uint8_t *data, size_t length) {\n  Buffer table(data, length);\n\n  OpenTypeGASP *gasp = new OpenTypeGASP;\n  file->gasp = gasp;\n\n  uint16_t num_ranges = 0;\n  if (!table.ReadU16(&gasp->version) ||\n      !table.ReadU16(&num_ranges)) {\n    return OTS_FAILURE_MSG(\"Failed to read table header\");\n  }\n\n  if (gasp->version > 1) {\n    // Lots of Linux fonts have bad version numbers...\n    DROP_THIS_TABLE(\"bad version: %u\", gasp->version);\n    return true;\n  }\n\n  if (num_ranges == 0) {\n    DROP_THIS_TABLE(\"num_ranges is zero\");\n    return true;\n  }\n\n  gasp->gasp_ranges.reserve(num_ranges);\n  for (unsigned i = 0; i < num_ranges; ++i) {\n    uint16_t max_ppem = 0;\n    uint16_t behavior = 0;\n    if (!table.ReadU16(&max_ppem) ||\n        !table.ReadU16(&behavior)) {\n      return OTS_FAILURE_MSG(\"Failed to read subrange %d\", i);\n    }\n    if ((i > 0) && (gasp->gasp_ranges[i - 1].first >= max_ppem)) {\n      // The records in the gaspRange[] array must be sorted in order of\n      // increasing rangeMaxPPEM value.\n      DROP_THIS_TABLE(\"ranges are not sorted\");\n      return true;\n    }\n    if ((i == num_ranges - 1u) &&  // never underflow.\n        (max_ppem != 0xffffu)) {\n      DROP_THIS_TABLE(\"The last record should be 0xFFFF as a sentinel value \"\n                  \"for rangeMaxPPEM\");\n      return true;\n    }\n\n    if (behavior >> 8) {\n      OTS_WARNING(\"undefined bits are used: %x\", behavior);\n      // mask undefined bits.\n      behavior &= 0x000fu;\n    }\n\n    if (gasp->version == 0 && (behavior >> 2) != 0) {\n      OTS_WARNING(\"changed the version number to 1\");\n      gasp->version = 1;\n    }\n\n    gasp->gasp_ranges.push_back(std::make_pair(max_ppem, behavior));\n  }\n\n  return true;\n}\n\nbool ots_gasp_should_serialise(OpenTypeFile *file) {\n  return file->gasp != NULL;\n}\n\nbool ots_gasp_serialise(OTSStream *out, OpenTypeFile *file) {\n  const OpenTypeGASP *gasp = file->gasp;\n\n  const uint16_t num_ranges = static_cast<uint16_t>(gasp->gasp_ranges.size());\n  if (num_ranges != gasp->gasp_ranges.size() ||\n      !out->WriteU16(gasp->version) ||\n      !out->WriteU16(num_ranges)) {\n    return OTS_FAILURE_MSG(\"failed to write gasp header\");\n  }\n\n  for (uint16_t i = 0; i < num_ranges; ++i) {\n    if (!out->WriteU16(gasp->gasp_ranges[i].first) ||\n        !out->WriteU16(gasp->gasp_ranges[i].second)) {\n      return OTS_FAILURE_MSG(\"Failed to write gasp subtable %d\", i);\n    }\n  }\n\n  return true;\n}\n\nvoid ots_gasp_free(OpenTypeFile *file) {\n  delete file->gasp;\n}\n\n}  // namespace ots\n\n#undef TABLE_NAME\n#undef DROP_THIS_TABLE\n", "// Copyright (c) 2011 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n#include \"gdef.h\"\n\n#include <limits>\n#include <vector>\n\n#include \"gpos.h\"\n#include \"gsub.h\"\n#include \"layout.h\"\n#include \"maxp.h\"\n\n// GDEF - The Glyph Definition Table\n// http://www.microsoft.com/typography/otspec/gdef.htm\n\n#define TABLE_NAME \"GDEF\"\n\nnamespace {\n\n// The maximum class value in class definition tables.\nconst uint16_t kMaxClassDefValue = 0xFFFF;\n// The maximum class value in the glyph class definision table.\nconst uint16_t kMaxGlyphClassDefValue = 4;\n// The maximum format number of caret value tables.\n// We don't support format 3 for now. See the comment in\n// ParseLigCaretListTable() for the reason.\nconst uint16_t kMaxCaretValueFormat = 2;\n\nbool ParseGlyphClassDefTable(ots::OpenTypeFile *file, const uint8_t *data,\n                             size_t length, const uint16_t num_glyphs) {\n  return ots::ParseClassDefTable(file, data, length, num_glyphs,\n                                 kMaxGlyphClassDefValue);\n}\n\nbool ParseAttachListTable(ots::OpenTypeFile *file, const uint8_t *data,\n                          size_t length, const uint16_t num_glyphs) {\n  ots::Buffer subtable(data, length);\n\n  uint16_t offset_coverage = 0;\n  uint16_t glyph_count = 0;\n  if (!subtable.ReadU16(&offset_coverage) ||\n      !subtable.ReadU16(&glyph_count)) {\n    return OTS_FAILURE_MSG(\"Failed to read gdef header\");\n  }\n  const unsigned attach_points_end =\n      2 * static_cast<unsigned>(glyph_count) + 4;\n  if (attach_points_end > std::numeric_limits<uint16_t>::max()) {\n    return OTS_FAILURE_MSG(\"Bad glyph count in gdef\");\n  }\n  if (offset_coverage == 0 || offset_coverage >= length ||\n      offset_coverage < attach_points_end) {\n    return OTS_FAILURE_MSG(\"Bad coverage offset %d\", offset_coverage);\n  }\n  if (glyph_count > num_glyphs) {\n    return OTS_FAILURE_MSG(\"Bad glyph count %u\", glyph_count);\n  }\n\n  std::vector<uint16_t> attach_points;\n  attach_points.resize(glyph_count);\n  for (unsigned i = 0; i < glyph_count; ++i) {\n    if (!subtable.ReadU16(&attach_points[i])) {\n      return OTS_FAILURE_MSG(\"Can't read attachment point %d\", i);\n    }\n    if (attach_points[i] >= length ||\n        attach_points[i] < attach_points_end) {\n      return OTS_FAILURE_MSG(\"Bad attachment point %d of %d\", i, attach_points[i]);\n    }\n  }\n\n  // Parse coverage table\n  if (!ots::ParseCoverageTable(file, data + offset_coverage,\n                               length - offset_coverage, num_glyphs)) {\n    return OTS_FAILURE_MSG(\"Bad coverage table\");\n  }\n\n  // Parse attach point table\n  for (unsigned i = 0; i < attach_points.size(); ++i) {\n    subtable.set_offset(attach_points[i]);\n    uint16_t point_count = 0;\n    if (!subtable.ReadU16(&point_count)) {\n      return OTS_FAILURE_MSG(\"Can't read point count %d\", i);\n    }\n    if (point_count == 0) {\n      return OTS_FAILURE_MSG(\"zero point count %d\", i);\n    }\n    uint16_t last_point_index = 0;\n    uint16_t point_index = 0;\n    for (unsigned j = 0; j < point_count; ++j) {\n      if (!subtable.ReadU16(&point_index)) {\n        return OTS_FAILURE_MSG(\"Can't read point index %d in point %d\", j, i);\n      }\n      // Contour point indeces are in increasing numerical order\n      if (last_point_index != 0 && last_point_index >= point_index) {\n        return OTS_FAILURE_MSG(\"bad contour indeces: %u >= %u\",\n                    last_point_index, point_index);\n      }\n      last_point_index = point_index;\n    }\n  }\n  return true;\n}\n\nbool ParseLigCaretListTable(ots::OpenTypeFile *file, const uint8_t *data,\n                            size_t length, const uint16_t num_glyphs) {\n  ots::Buffer subtable(data, length);\n  uint16_t offset_coverage = 0;\n  uint16_t lig_glyph_count = 0;\n  if (!subtable.ReadU16(&offset_coverage) ||\n      !subtable.ReadU16(&lig_glyph_count)) {\n    return OTS_FAILURE_MSG(\"Can't read caret structure\");\n  }\n  const unsigned lig_glyphs_end =\n      2 * static_cast<unsigned>(lig_glyph_count) + 4;\n  if (lig_glyphs_end > std::numeric_limits<uint16_t>::max()) {\n    return OTS_FAILURE_MSG(\"Bad caret structure\");\n  }\n  if (offset_coverage == 0 || offset_coverage >= length ||\n      offset_coverage < lig_glyphs_end) {\n    return OTS_FAILURE_MSG(\"Bad caret coverate offset %d\", offset_coverage);\n  }\n  if (lig_glyph_count > num_glyphs) {\n    return OTS_FAILURE_MSG(\"bad ligature glyph count: %u\", lig_glyph_count);\n  }\n\n  std::vector<uint16_t> lig_glyphs;\n  lig_glyphs.resize(lig_glyph_count);\n  for (unsigned i = 0; i < lig_glyph_count; ++i) {\n    if (!subtable.ReadU16(&lig_glyphs[i])) {\n      return OTS_FAILURE_MSG(\"Can't read ligature glyph location %d\", i);\n    }\n    if (lig_glyphs[i] >= length || lig_glyphs[i] < lig_glyphs_end) {\n      return OTS_FAILURE_MSG(\"Bad ligature glyph location %d in glyph %d\", lig_glyphs[i], i);\n    }\n  }\n\n  // Parse coverage table\n  if (!ots::ParseCoverageTable(file, data + offset_coverage,\n                               length - offset_coverage, num_glyphs)) {\n    return OTS_FAILURE_MSG(\"Can't parse caret coverage table\");\n  }\n\n  // Parse ligature glyph table\n  for (unsigned i = 0; i < lig_glyphs.size(); ++i) {\n    subtable.set_offset(lig_glyphs[i]);\n    uint16_t caret_count = 0;\n    if (!subtable.ReadU16(&caret_count)) {\n      return OTS_FAILURE_MSG(\"Can't read caret count for glyph %d\", i);\n    }\n    if (caret_count == 0) {\n      return OTS_FAILURE_MSG(\"bad caret value count: %u\", caret_count);\n    }\n\n    std::vector<uint16_t> caret_value_offsets;\n    caret_value_offsets.resize(caret_count);\n    unsigned caret_value_offsets_end = 2 * static_cast<unsigned>(caret_count) + 2;\n    for (unsigned j = 0; j < caret_count; ++j) {\n      if (!subtable.ReadU16(&caret_value_offsets[j])) {\n        return OTS_FAILURE_MSG(\"Can't read caret offset %d for glyph %d\", j, i);\n      }\n      if (caret_value_offsets[j] >= length || caret_value_offsets[j] < caret_value_offsets_end) {\n        return OTS_FAILURE_MSG(\"Bad caret offset %d for caret %d glyph %d\", caret_value_offsets[j], j, i);\n      }\n    }\n\n    // Parse caret values table\n    for (unsigned j = 0; j < caret_count; ++j) {\n      subtable.set_offset(lig_glyphs[i] + caret_value_offsets[j]);\n      uint16_t caret_format = 0;\n      if (!subtable.ReadU16(&caret_format)) {\n        return OTS_FAILURE_MSG(\"Can't read caret values table %d in glyph %d\", j, i);\n      }\n      // TODO(bashi): We only support caret value format 1 and 2 for now\n      // because there are no fonts which contain caret value format 3\n      // as far as we investigated.\n      if (caret_format == 0 || caret_format > kMaxCaretValueFormat) {\n        return OTS_FAILURE_MSG(\"bad caret value format: %u\", caret_format);\n      }\n      // CaretValueFormats contain a 2-byte field which could be\n      // arbitrary value.\n      if (!subtable.Skip(2)) {\n        return OTS_FAILURE_MSG(\"Bad caret value table structure %d in glyph %d\", j, i);\n      }\n    }\n  }\n  return true;\n}\n\nbool ParseMarkAttachClassDefTable(ots::OpenTypeFile *file, const uint8_t *data,\n                                  size_t length, const uint16_t num_glyphs) {\n  return ots::ParseClassDefTable(file, data, length, num_glyphs, kMaxClassDefValue);\n}\n\nbool ParseMarkGlyphSetsDefTable(ots::OpenTypeFile *file, const uint8_t *data,\n                                size_t length, const uint16_t num_glyphs) {\n  ots::Buffer subtable(data, length);\n  uint16_t format = 0;\n  uint16_t mark_set_count = 0;\n  if (!subtable.ReadU16(&format) ||\n      !subtable.ReadU16(&mark_set_count)) {\n    return OTS_FAILURE_MSG(\"Can' read mark glyph table structure\");\n  }\n  if (format != 1) {\n    return OTS_FAILURE_MSG(\"bad mark glyph set table format: %u\", format);\n  }\n\n  const unsigned mark_sets_end = 2 * static_cast<unsigned>(mark_set_count) + 4;\n  if (mark_sets_end > std::numeric_limits<uint16_t>::max()) {\n    return OTS_FAILURE_MSG(\"Bad mark_set %d\", mark_sets_end);\n  }\n  for (unsigned i = 0; i < mark_set_count; ++i) {\n    uint32_t offset_coverage = 0;\n    if (!subtable.ReadU32(&offset_coverage)) {\n      return OTS_FAILURE_MSG(\"Can't read covrage location for mark set %d\", i);\n    }\n    if (offset_coverage >= length ||\n        offset_coverage < mark_sets_end) {\n      return OTS_FAILURE_MSG(\"Bad coverage location %d for mark set %d\", offset_coverage, i);\n    }\n    if (!ots::ParseCoverageTable(file, data + offset_coverage,\n                                 length - offset_coverage, num_glyphs)) {\n      return OTS_FAILURE_MSG(\"Failed to parse coverage table for mark set %d\", i);\n    }\n  }\n  file->gdef->num_mark_glyph_sets = mark_set_count;\n  return true;\n}\n\n}  // namespace\n\n#define DROP_THIS_TABLE(msg_) \\\n  do { \\\n    file->gdef->data = 0; \\\n    file->gdef->length = 0; \\\n    OTS_FAILURE_MSG(msg_ \", table discarded\"); \\\n  } while (0)\n\nnamespace ots {\n\nbool ots_gdef_parse(OpenTypeFile *file, const uint8_t *data, size_t length) {\n  // Grab the number of glyphs in the file from the maxp table to check\n  // GlyphIDs in GDEF table.\n  if (!file->maxp) {\n    return OTS_FAILURE_MSG(\"No maxp table in font, needed by GDEF\");\n  }\n  const uint16_t num_glyphs = file->maxp->num_glyphs;\n\n  Buffer table(data, length);\n\n  OpenTypeGDEF *gdef = new OpenTypeGDEF;\n  file->gdef = gdef;\n\n  uint32_t version = 0;\n  if (!table.ReadU32(&version)) {\n    DROP_THIS_TABLE(\"Incomplete table\");\n    return true;\n  }\n  if (version < 0x00010000 || version == 0x00010001) {\n    DROP_THIS_TABLE(\"Bad version\");\n    return true;\n  }\n\n  if (version >= 0x00010002) {\n    gdef->version_2 = true;\n  }\n\n  uint16_t offset_glyph_class_def = 0;\n  uint16_t offset_attach_list = 0;\n  uint16_t offset_lig_caret_list = 0;\n  uint16_t offset_mark_attach_class_def = 0;\n  if (!table.ReadU16(&offset_glyph_class_def) ||\n      !table.ReadU16(&offset_attach_list) ||\n      !table.ReadU16(&offset_lig_caret_list) ||\n      !table.ReadU16(&offset_mark_attach_class_def)) {\n    DROP_THIS_TABLE(\"Incomplete table\");\n    return true;\n  }\n  uint16_t offset_mark_glyph_sets_def = 0;\n  if (gdef->version_2) {\n    if (!table.ReadU16(&offset_mark_glyph_sets_def)) {\n      DROP_THIS_TABLE(\"Incomplete table\");\n      return true;\n    }\n  }\n\n  unsigned gdef_header_end = 4 + 4 * 2;\n  if (gdef->version_2)\n    gdef_header_end += 2;\n\n  // Parse subtables\n  if (offset_glyph_class_def) {\n    if (offset_glyph_class_def >= length ||\n        offset_glyph_class_def < gdef_header_end) {\n      DROP_THIS_TABLE(\"Invalid offset to glyph classes\");\n      return true;\n    }\n    if (!ParseGlyphClassDefTable(file, data + offset_glyph_class_def,\n                                 length - offset_glyph_class_def,\n                                 num_glyphs)) {\n      DROP_THIS_TABLE(\"Invalid glyph classes\");\n      return true;\n    }\n    gdef->has_glyph_class_def = true;\n  }\n\n  if (offset_attach_list) {\n    if (offset_attach_list >= length ||\n        offset_attach_list < gdef_header_end) {\n      DROP_THIS_TABLE(\"Invalid offset to attachment list\");\n      return true;\n    }\n    if (!ParseAttachListTable(file, data + offset_attach_list,\n                              length - offset_attach_list,\n                              num_glyphs)) {\n      DROP_THIS_TABLE(\"Invalid attachment list\");\n      return true;\n    }\n  }\n\n  if (offset_lig_caret_list) {\n    if (offset_lig_caret_list >= length ||\n        offset_lig_caret_list < gdef_header_end) {\n      DROP_THIS_TABLE(\"Invalid offset to ligature caret list\");\n      return true;\n    }\n    if (!ParseLigCaretListTable(file, data + offset_lig_caret_list,\n                              length - offset_lig_caret_list,\n                              num_glyphs)) {\n      DROP_THIS_TABLE(\"Invalid ligature caret list\");\n      return true;\n    }\n  }\n\n  if (offset_mark_attach_class_def) {\n    if (offset_mark_attach_class_def >= length ||\n        offset_mark_attach_class_def < gdef_header_end) {\n      return OTS_FAILURE_MSG(\"Invalid offset to mark attachment list\");\n    }\n    if (!ParseMarkAttachClassDefTable(file,\n                                      data + offset_mark_attach_class_def,\n                                      length - offset_mark_attach_class_def,\n                                      num_glyphs)) {\n      DROP_THIS_TABLE(\"Invalid mark attachment list\");\n      return true;\n    }\n    gdef->has_mark_attachment_class_def = true;\n  }\n\n  if (offset_mark_glyph_sets_def) {\n    if (offset_mark_glyph_sets_def >= length ||\n        offset_mark_glyph_sets_def < gdef_header_end) {\n      return OTS_FAILURE_MSG(\"invalid offset to mark glyph sets\");\n    }\n    if (!ParseMarkGlyphSetsDefTable(file,\n                                    data + offset_mark_glyph_sets_def,\n                                    length - offset_mark_glyph_sets_def,\n                                    num_glyphs)) {\n      DROP_THIS_TABLE(\"Invalid mark glyph sets\");\n      return true;\n    }\n    gdef->has_mark_glyph_sets_def = true;\n  }\n  gdef->data = data;\n  gdef->length = length;\n  return true;\n}\n\nbool ots_gdef_should_serialise(OpenTypeFile *file) {\n  return file->gdef != NULL && file->gdef->data != NULL;\n}\n\nbool ots_gdef_serialise(OTSStream *out, OpenTypeFile *file) {\n  if (!out->Write(file->gdef->data, file->gdef->length)) {\n    return OTS_FAILURE_MSG(\"Failed to write GDEF table\");\n  }\n\n  return true;\n}\n\nvoid ots_gdef_free(OpenTypeFile *file) {\n  delete file->gdef;\n}\n\n}  // namespace ots\n\n#undef TABLE_NAME\n#undef DROP_THIS_TABLE\n", "// Copyright (c) 2011 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n#include \"gpos.h\"\n\n#include <limits>\n#include <vector>\n\n#include \"layout.h\"\n#include \"maxp.h\"\n\n// GPOS - The Glyph Positioning Table\n// http://www.microsoft.com/typography/otspec/gpos.htm\n\n#define TABLE_NAME \"GPOS\"\n\nnamespace {\n\nenum GPOS_TYPE {\n  GPOS_TYPE_SINGLE_ADJUSTMENT = 1,\n  GPOS_TYPE_PAIR_ADJUSTMENT = 2,\n  GPOS_TYPE_CURSIVE_ATTACHMENT = 3,\n  GPOS_TYPE_MARK_TO_BASE_ATTACHMENT = 4,\n  GPOS_TYPE_MARK_TO_LIGATURE_ATTACHMENT = 5,\n  GPOS_TYPE_MARK_TO_MARK_ATTACHMENT = 6,\n  GPOS_TYPE_CONTEXT_POSITIONING = 7,\n  GPOS_TYPE_CHAINED_CONTEXT_POSITIONING = 8,\n  GPOS_TYPE_EXTENSION_POSITIONING = 9,\n  GPOS_TYPE_RESERVED = 10\n};\n\n// The size of gpos header.\nconst unsigned kGposHeaderSize = 10;\n// The maximum format number for anchor tables.\nconst uint16_t kMaxAnchorFormat = 3;\n// The maximum number of class value.\nconst uint16_t kMaxClassDefValue = 0xFFFF;\n\n// Lookup type parsers.\nbool ParseSingleAdjustment(const ots::OpenTypeFile *file,\n                           const uint8_t *data, const size_t length);\nbool ParsePairAdjustment(const ots::OpenTypeFile *file,\n                         const uint8_t *data, const size_t length);\nbool ParseCursiveAttachment(const ots::OpenTypeFile *file,\n                            const uint8_t *data, const size_t length);\nbool ParseMarkToBaseAttachment(const ots::OpenTypeFile *file,\n                               const uint8_t *data, const size_t length);\nbool ParseMarkToLigatureAttachment(const ots::OpenTypeFile *file,\n                                   const uint8_t *data, const size_t length);\nbool ParseMarkToMarkAttachment(const ots::OpenTypeFile *file,\n                               const uint8_t *data, const size_t length);\nbool ParseContextPositioning(const ots::OpenTypeFile *file,\n                             const uint8_t *data, const size_t length);\nbool ParseChainedContextPositioning(const ots::OpenTypeFile *file,\n                                    const uint8_t *data, const size_t length);\nbool ParseExtensionPositioning(const ots::OpenTypeFile *file,\n                               const uint8_t *data, const size_t length);\n\nconst ots::LookupSubtableParser::TypeParser kGposTypeParsers[] = {\n  {GPOS_TYPE_SINGLE_ADJUSTMENT, ParseSingleAdjustment},\n  {GPOS_TYPE_PAIR_ADJUSTMENT, ParsePairAdjustment},\n  {GPOS_TYPE_CURSIVE_ATTACHMENT, ParseCursiveAttachment},\n  {GPOS_TYPE_MARK_TO_BASE_ATTACHMENT, ParseMarkToBaseAttachment},\n  {GPOS_TYPE_MARK_TO_LIGATURE_ATTACHMENT, ParseMarkToLigatureAttachment},\n  {GPOS_TYPE_MARK_TO_MARK_ATTACHMENT, ParseMarkToMarkAttachment},\n  {GPOS_TYPE_CONTEXT_POSITIONING, ParseContextPositioning},\n  {GPOS_TYPE_CHAINED_CONTEXT_POSITIONING, ParseChainedContextPositioning},\n  {GPOS_TYPE_EXTENSION_POSITIONING, ParseExtensionPositioning}\n};\n\nconst ots::LookupSubtableParser kGposLookupSubtableParser = {\n  arraysize(kGposTypeParsers),\n  GPOS_TYPE_EXTENSION_POSITIONING, kGposTypeParsers\n};\n\n// Shared Tables: ValueRecord, Anchor Table, and MarkArray\n\nbool ParseValueRecord(const ots::OpenTypeFile *file,\n                      ots::Buffer* subtable, const uint8_t *data,\n                      const size_t length, const uint16_t value_format) {\n  // Check existence of adjustment fields.\n  for (unsigned i = 0; i < 4; ++i) {\n    if ((value_format >> i) & 0x1) {\n      // Just read the field since these fileds could take an arbitrary values.\n      if (!subtable->Skip(2)) {\n        return OTS_FAILURE_MSG(\"Failed to read value reacord component\");\n      }\n    }\n  }\n\n  // Check existence of offsets to device table.\n  for (unsigned i = 0; i < 4; ++i) {\n    if ((value_format >> (i + 4)) & 0x1) {\n      uint16_t offset = 0;\n      if (!subtable->ReadU16(&offset)) {\n        return OTS_FAILURE_MSG(\"Failed to read value record offset\");\n      }\n      if (offset) {\n        // TODO(bashi): Is it possible that device tables locate before\n        // this record? No fonts contain such offset AKAIF.\n        if (offset >= length) {\n          return OTS_FAILURE_MSG(\"Value record offset too high %d >= %ld\", offset, length);\n        }\n        if (!ots::ParseDeviceTable(file, data + offset, length - offset)) {\n          return OTS_FAILURE_MSG(\"Failed to parse device table in value record\");\n        }\n      }\n    }\n  }\n  return true;\n}\n\nbool ParseAnchorTable(const ots::OpenTypeFile *file,\n                      const uint8_t *data, const size_t length) {\n  ots::Buffer subtable(data, length);\n\n  uint16_t format = 0;\n  // Read format and skip 2 2-byte fields that could be arbitrary values.\n  if (!subtable.ReadU16(&format) ||\n      !subtable.Skip(4)) {\n    return OTS_FAILURE_MSG(\"Faled to read anchor table\");\n  }\n\n  if (format == 0 || format > kMaxAnchorFormat) {\n    return OTS_FAILURE_MSG(\"Bad Anchor table format %d\", format);\n  }\n\n  // Format 2 and 3 has additional fields.\n  if (format == 2) {\n    // Format 2 provides an index to a glyph contour point, which will take\n    // arbitrary value.\n    uint16_t anchor_point = 0;\n    if (!subtable.ReadU16(&anchor_point)) {\n      return OTS_FAILURE_MSG(\"Failed to read anchor point in format 2 Anchor Table\");\n    }\n  } else if (format == 3) {\n    uint16_t offset_x_device = 0;\n    uint16_t offset_y_device = 0;\n    if (!subtable.ReadU16(&offset_x_device) ||\n        !subtable.ReadU16(&offset_y_device)) {\n      return OTS_FAILURE_MSG(\"Failed to read device table offsets in format 3 anchor table\");\n    }\n    const unsigned format_end = static_cast<unsigned>(10);\n    if (offset_x_device) {\n      if (offset_x_device < format_end || offset_x_device >= length) {\n        return OTS_FAILURE_MSG(\"Bad x device table offset %d\", offset_x_device);\n      }\n      if (!ots::ParseDeviceTable(file, data + offset_x_device,\n                                 length - offset_x_device)) {\n        return OTS_FAILURE_MSG(\"Failed to parse device table in anchor table\");\n      }\n    }\n    if (offset_y_device) {\n      if (offset_y_device < format_end || offset_y_device >= length) {\n        return OTS_FAILURE_MSG(\"Bad y device table offset %d\", offset_y_device);\n      }\n      if (!ots::ParseDeviceTable(file, data + offset_y_device,\n                                 length - offset_y_device)) {\n        return OTS_FAILURE_MSG(\"Failed to parse device table in anchor table\");\n      }\n    }\n  }\n  return true;\n}\n\nbool ParseMarkArrayTable(const ots::OpenTypeFile *file,\n                         const uint8_t *data, const size_t length,\n                         const uint16_t class_count) {\n  ots::Buffer subtable(data, length);\n\n  uint16_t mark_count = 0;\n  if (!subtable.ReadU16(&mark_count)) {\n    return OTS_FAILURE_MSG(\"Can't read mark table length\");\n  }\n\n  // MarkRecord consists of 4-bytes.\n  const unsigned mark_records_end = 4 * static_cast<unsigned>(mark_count) + 2;\n  if (mark_records_end > std::numeric_limits<uint16_t>::max()) {\n    return OTS_FAILURE_MSG(\"Bad mark table length\");\n  }\n  for (unsigned i = 0; i < mark_count; ++i) {\n    uint16_t class_value = 0;\n    uint16_t offset_mark_anchor = 0;\n    if (!subtable.ReadU16(&class_value) ||\n        !subtable.ReadU16(&offset_mark_anchor)) {\n      return OTS_FAILURE_MSG(\"Can't read mark table %d\", i);\n    }\n    // |class_value| may take arbitrary values including 0 here so we don't\n    // check the value.\n    if (offset_mark_anchor < mark_records_end ||\n        offset_mark_anchor >= length) {\n      return OTS_FAILURE_MSG(\"Bad mark anchor offset %d for mark table %d\", offset_mark_anchor, i);\n    }\n    if (!ParseAnchorTable(file, data + offset_mark_anchor,\n                          length - offset_mark_anchor)) {\n      return OTS_FAILURE_MSG(\"Faled to parse anchor table for mark table %d\", i);\n    }\n  }\n\n  return true;\n}\n\n// Lookup Type 1:\n// Single Adjustment Positioning Subtable\nbool ParseSingleAdjustment(const ots::OpenTypeFile *file, const uint8_t *data,\n                           const size_t length) {\n  ots::Buffer subtable(data, length);\n\n  uint16_t format = 0;\n  uint16_t offset_coverage = 0;\n  uint16_t value_format = 0;\n  if (!subtable.ReadU16(&format) ||\n      !subtable.ReadU16(&offset_coverage) ||\n      !subtable.ReadU16(&value_format)) {\n    return OTS_FAILURE_MSG(\"Can't read single adjustment information\");\n  }\n\n  if (format == 1) {\n    // Format 1 exactly one value record.\n    if (!ParseValueRecord(file, &subtable, data, length, value_format)) {\n      return OTS_FAILURE_MSG(\"Failed to parse format 1 single adjustment table\");\n    }\n  } else if (format == 2) {\n    uint16_t value_count = 0;\n    if (!subtable.ReadU16(&value_count)) {\n      return OTS_FAILURE_MSG(\"Failed to parse format 2 single adjustment table\");\n    }\n    for (unsigned i = 0; i < value_count; ++i) {\n      if (!ParseValueRecord(file, &subtable, data, length, value_format)) {\n        return OTS_FAILURE_MSG(\"Failed to parse value record %d in format 2 single adjustment table\", i);\n      }\n    }\n  } else {\n    return OTS_FAILURE_MSG(\"Bad format %d in single adjustment table\", format);\n  }\n\n  if (offset_coverage < subtable.offset() || offset_coverage >= length) {\n    return OTS_FAILURE_MSG(\"Bad coverage offset %d in single adjustment table\", offset_coverage);\n  }\n\n  if (!ots::ParseCoverageTable(file, data + offset_coverage,\n                               length - offset_coverage,\n                               file->maxp->num_glyphs)) {\n    return OTS_FAILURE_MSG(\"Failed to parse coverage table in single adjustment table\");\n  }\n\n  return true;\n}\n\nbool ParsePairSetTable(const ots::OpenTypeFile *file,\n                       const uint8_t *data, const size_t length,\n                       const uint16_t value_format1,\n                       const uint16_t value_format2,\n                       const uint16_t num_glyphs) {\n  ots::Buffer subtable(data, length);\n\n  uint16_t value_count = 0;\n  if (!subtable.ReadU16(&value_count)) {\n    return OTS_FAILURE_MSG(\"Failed to read pair set table structure\");\n  }\n  for (unsigned i = 0; i < value_count; ++i) {\n    // Check pair value record.\n    uint16_t glyph_id = 0;\n    if (!subtable.ReadU16(&glyph_id)) {\n      return OTS_FAILURE_MSG(\"Failed to read glyph in pair value record %d\", i);\n    }\n    if (glyph_id >= num_glyphs) {\n      return OTS_FAILURE_MSG(\"glyph id %d too high >= %d\", glyph_id, num_glyphs);\n    }\n    if (!ParseValueRecord(file, &subtable, data, length, value_format1)) {\n      return OTS_FAILURE_MSG(\"Failed to parse value record in format 1 pair set table\");\n    }\n    if (!ParseValueRecord(file, &subtable, data, length, value_format2)) {\n      return OTS_FAILURE_MSG(\"Failed to parse value record in format 2 pair set table\");\n    }\n  }\n  return true;\n}\n\nbool ParsePairPosFormat1(const ots::OpenTypeFile *file,\n                         const uint8_t *data, const size_t length,\n                         const uint16_t value_format1,\n                         const uint16_t value_format2,\n                         const uint16_t num_glyphs) {\n  ots::Buffer subtable(data, length);\n\n  // Skip 8 bytes that are already read before.\n  if (!subtable.Skip(8)) {\n    return OTS_FAILURE_MSG(\"Failed to read pair pos table structure\");\n  }\n\n  uint16_t pair_set_count = 0;\n  if (!subtable.ReadU16(&pair_set_count)) {\n    return OTS_FAILURE_MSG(\"Failed to read pair pos set count\");\n  }\n\n  const unsigned pair_pos_end = 2 * static_cast<unsigned>(pair_set_count) + 10;\n  if (pair_pos_end > std::numeric_limits<uint16_t>::max()) {\n    return OTS_FAILURE_MSG(\"Bad pair set length %d\", pair_pos_end);\n  }\n  for (unsigned i = 0; i < pair_set_count; ++i) {\n    uint16_t pair_set_offset = 0;\n    if (!subtable.ReadU16(&pair_set_offset)) {\n      return OTS_FAILURE_MSG(\"Failed to read pair set offset for pair set %d\", i);\n    }\n    if (pair_set_offset < pair_pos_end || pair_set_offset >= length) {\n      return OTS_FAILURE_MSG(\"Bad pair set offset %d for pair set %d\", pair_set_offset, i);\n    }\n    // Check pair set tables\n    if (!ParsePairSetTable(file, data + pair_set_offset, length - pair_set_offset,\n                           value_format1, value_format2,\n                           num_glyphs)) {\n      return OTS_FAILURE_MSG(\"Failed to parse pair set table %d\", i);\n    }\n  }\n\n  return true;\n}\n\nbool ParsePairPosFormat2(const ots::OpenTypeFile *file,\n                         const uint8_t *data, const size_t length,\n                         const uint16_t value_format1,\n                         const uint16_t value_format2,\n                         const uint16_t num_glyphs) {\n  ots::Buffer subtable(data, length);\n\n  // Skip 8 bytes that are already read before.\n  if (!subtable.Skip(8)) {\n    return OTS_FAILURE_MSG(\"Failed to read pair pos format 2 structure\");\n  }\n\n  uint16_t offset_class_def1 = 0;\n  uint16_t offset_class_def2 = 0;\n  uint16_t class1_count = 0;\n  uint16_t class2_count = 0;\n  if (!subtable.ReadU16(&offset_class_def1) ||\n      !subtable.ReadU16(&offset_class_def2) ||\n      !subtable.ReadU16(&class1_count) ||\n      !subtable.ReadU16(&class2_count)) {\n    return OTS_FAILURE_MSG(\"Failed to read pair pos format 2 data\");\n  }\n\n  // Check class 1 records.\n  for (unsigned i = 0; i < class1_count; ++i) {\n    // Check class 2 records.\n    for (unsigned j = 0; j < class2_count; ++j) {\n      if (value_format1 && !ParseValueRecord(file, &subtable, data, length,\n                                             value_format1)) {\n        return OTS_FAILURE_MSG(\"Failed to parse value record 1 %d and %d\", j, i);\n      }\n      if (value_format2 && !ParseValueRecord(file, &subtable, data, length,\n                                             value_format2)) {\n        return OTS_FAILURE_MSG(\"Falied to parse value record 2 %d and %d\", j, i);\n      }\n    }\n  }\n\n  // Check class definition tables.\n  if (offset_class_def1 < subtable.offset() || offset_class_def1 >= length ||\n      offset_class_def2 < subtable.offset() || offset_class_def2 >= length) {\n    return OTS_FAILURE_MSG(\"Bad class definition table offsets %d or %d\", offset_class_def1, offset_class_def2);\n  }\n  if (!ots::ParseClassDefTable(file, data + offset_class_def1,\n                               length - offset_class_def1,\n                               num_glyphs, kMaxClassDefValue)) {\n    return OTS_FAILURE_MSG(\"Failed to parse class definition table 1\");\n  }\n  if (!ots::ParseClassDefTable(file, data + offset_class_def2,\n                               length - offset_class_def2,\n                               num_glyphs, kMaxClassDefValue)) {\n    return OTS_FAILURE_MSG(\"Failed to parse class definition table 2\");\n  }\n\n  return true;\n}\n\n// Lookup Type 2:\n// Pair Adjustment Positioning Subtable\nbool ParsePairAdjustment(const ots::OpenTypeFile *file, const uint8_t *data,\n                         const size_t length) {\n  ots::Buffer subtable(data, length);\n\n  uint16_t format = 0;\n  uint16_t offset_coverage = 0;\n  uint16_t value_format1 = 0;\n  uint16_t value_format2 = 0;\n  if (!subtable.ReadU16(&format) ||\n      !subtable.ReadU16(&offset_coverage) ||\n      !subtable.ReadU16(&value_format1) ||\n      !subtable.ReadU16(&value_format2)) {\n    return OTS_FAILURE_MSG(\"Failed to read pair adjustment structure\");\n  }\n\n  if (format == 1) {\n    if (!ParsePairPosFormat1(file, data, length, value_format1, value_format2,\n                             file->maxp->num_glyphs)) {\n      return OTS_FAILURE_MSG(\"Failed to parse pair pos format 1\");\n    }\n  } else if (format == 2) {\n    if (!ParsePairPosFormat2(file, data, length, value_format1, value_format2,\n                             file->maxp->num_glyphs)) {\n      return OTS_FAILURE_MSG(\"Failed to parse pair format 2\");\n    }\n  } else {\n    return OTS_FAILURE_MSG(\"Bad pos pair format %d\", format);\n  }\n\n  if (offset_coverage < subtable.offset() || offset_coverage >= length) {\n    return OTS_FAILURE_MSG(\"Bad pair pos offset coverage %d\", offset_coverage);\n  }\n  if (!ots::ParseCoverageTable(file, data + offset_coverage,\n                               length - offset_coverage,\n                               file->maxp->num_glyphs)) {\n    return OTS_FAILURE_MSG(\"Failed to parse coverage table\");\n  }\n\n  return true;\n}\n\n// Lookup Type 3\n// Cursive Attachment Positioning Subtable\nbool ParseCursiveAttachment(const ots::OpenTypeFile *file, const uint8_t *data,\n                            const size_t length) {\n  ots::Buffer subtable(data, length);\n\n  uint16_t format = 0;\n  uint16_t offset_coverage = 0;\n  uint16_t entry_exit_count = 0;\n  if (!subtable.ReadU16(&format) ||\n      !subtable.ReadU16(&offset_coverage) ||\n      !subtable.ReadU16(&entry_exit_count)) {\n    return OTS_FAILURE_MSG(\"Failed to read cursive attachment structure\");\n  }\n\n  if (format != 1) {\n    return OTS_FAILURE_MSG(\"Bad cursive attachment format %d\", format);\n  }\n\n  // Check entry exit records.\n  const unsigned entry_exit_records_end =\n      2 * static_cast<unsigned>(entry_exit_count) + 6;\n  if (entry_exit_records_end > std::numeric_limits<uint16_t>::max()) {\n    return OTS_FAILURE_MSG(\"Bad entry exit record end %d\", entry_exit_records_end);\n  }\n  for (unsigned i = 0; i < entry_exit_count; ++i) {\n    uint16_t offset_entry_anchor = 0;\n    uint16_t offset_exit_anchor = 0;\n    if (!subtable.ReadU16(&offset_entry_anchor) ||\n        !subtable.ReadU16(&offset_exit_anchor)) {\n      return OTS_FAILURE_MSG(\"Can't read entry exit record %d\", i);\n    }\n    // These offsets could be NULL.\n    if (offset_entry_anchor) {\n      if (offset_entry_anchor < entry_exit_records_end ||\n          offset_entry_anchor >= length) {\n        return OTS_FAILURE_MSG(\"Bad entry anchor offset %d in entry exit record %d\", offset_entry_anchor, i);\n      }\n      if (!ParseAnchorTable(file, data + offset_entry_anchor,\n                            length - offset_entry_anchor)) {\n        return OTS_FAILURE_MSG(\"Failed to parse entry anchor table in entry exit record %d\", i);\n      }\n    }\n    if (offset_exit_anchor) {\n      if (offset_exit_anchor < entry_exit_records_end ||\n         offset_exit_anchor >= length) {\n        return OTS_FAILURE_MSG(\"Bad exit anchor offset %d in entry exit record %d\", offset_exit_anchor, i);\n      }\n      if (!ParseAnchorTable(file, data + offset_exit_anchor,\n                            length - offset_exit_anchor)) {\n        return OTS_FAILURE_MSG(\"Failed to parse exit anchor table in entry exit record %d\", i);\n      }\n    }\n  }\n\n  if (offset_coverage < subtable.offset() || offset_coverage >= length) {\n    return OTS_FAILURE_MSG(\"Bad coverage offset in cursive attachment %d\", offset_coverage);\n  }\n  if (!ots::ParseCoverageTable(file, data + offset_coverage,\n                               length - offset_coverage,\n                               file->maxp->num_glyphs)) {\n    return OTS_FAILURE_MSG(\"Failed to parse coverage table in cursive attachment\");\n  }\n\n  return true;\n}\n\nbool ParseAnchorArrayTable(const ots::OpenTypeFile *file,\n                           const uint8_t *data, const size_t length,\n                           const uint16_t class_count) {\n  ots::Buffer subtable(data, length);\n\n  uint16_t record_count = 0;\n  if (!subtable.ReadU16(&record_count)) {\n    return OTS_FAILURE_MSG(\"Can't read anchor array length\");\n  }\n\n  const unsigned anchor_array_end = 2 * static_cast<unsigned>(record_count) *\n      static_cast<unsigned>(class_count) + 2;\n  if (anchor_array_end > std::numeric_limits<uint16_t>::max()) {\n    return OTS_FAILURE_MSG(\"Bad end of anchor array %d\", anchor_array_end);\n  }\n  for (unsigned i = 0; i < record_count; ++i) {\n    for (unsigned j = 0; j < class_count; ++j) {\n      uint16_t offset_record = 0;\n      if (!subtable.ReadU16(&offset_record)) {\n        return OTS_FAILURE_MSG(\"Can't read anchor array record offset for class %d and record %d\", j, i);\n      }\n      // |offset_record| could be NULL.\n      if (offset_record) {\n        if (offset_record < anchor_array_end || offset_record >= length) {\n          return OTS_FAILURE_MSG(\"Bad record offset %d in class %d, record %d\", offset_record, j, i);\n        }\n        if (!ParseAnchorTable(file, data + offset_record,\n                              length - offset_record)) {\n          return OTS_FAILURE_MSG(\"Failed to parse anchor table for class %d, record %d\", j, i);\n        }\n      }\n    }\n  }\n  return true;\n}\n\nbool ParseLigatureArrayTable(const ots::OpenTypeFile *file,\n                             const uint8_t *data, const size_t length,\n                             const uint16_t class_count) {\n  ots::Buffer subtable(data, length);\n\n  uint16_t ligature_count = 0;\n  if (!subtable.ReadU16(&ligature_count)) {\n    return OTS_FAILURE_MSG(\"Failed to read ligature count\");\n  }\n  for (unsigned i = 0; i < ligature_count; ++i) {\n    uint16_t offset_ligature_attach = 0;\n    if (!subtable.ReadU16(&offset_ligature_attach)) {\n      return OTS_FAILURE_MSG(\"Can't read ligature offset %d\", i);\n    }\n    if (offset_ligature_attach < 2 || offset_ligature_attach >= length) {\n      return OTS_FAILURE_MSG(\"Bad ligature attachment offset %d in ligature %d\", offset_ligature_attach, i);\n    }\n    if (!ParseAnchorArrayTable(file, data + offset_ligature_attach,\n                               length - offset_ligature_attach, class_count)) {\n      return OTS_FAILURE_MSG(\"Failed to parse anchor table for ligature %d\", i);\n    }\n  }\n  return true;\n}\n\n// Common parser for Lookup Type 4, 5 and 6.\nbool ParseMarkToAttachmentSubtables(const ots::OpenTypeFile *file,\n                                    const uint8_t *data, const size_t length,\n                                    const GPOS_TYPE type) {\n  ots::Buffer subtable(data, length);\n\n  uint16_t format = 0;\n  uint16_t offset_coverage1 = 0;\n  uint16_t offset_coverage2 = 0;\n  uint16_t class_count = 0;\n  uint16_t offset_mark_array = 0;\n  uint16_t offset_type_specific_array = 0;\n  if (!subtable.ReadU16(&format) ||\n      !subtable.ReadU16(&offset_coverage1) ||\n      !subtable.ReadU16(&offset_coverage2) ||\n      !subtable.ReadU16(&class_count) ||\n      !subtable.ReadU16(&offset_mark_array) ||\n      !subtable.ReadU16(&offset_type_specific_array)) {\n    return OTS_FAILURE_MSG(\"Failed to read mark attachment subtable header\");\n  }\n\n  if (format != 1) {\n    return OTS_FAILURE_MSG(\"bad mark attachment subtable format %d\", format);\n  }\n\n  const unsigned header_end = static_cast<unsigned>(subtable.offset());\n  if (header_end > std::numeric_limits<uint16_t>::max()) {\n    return OTS_FAILURE_MSG(\"Bad mark attachment subtable size ending at %d\", header_end);\n  }\n  if (offset_coverage1 < header_end || offset_coverage1 >= length) {\n    return OTS_FAILURE_MSG(\"Bad coverage 1 offset %d\", offset_coverage1);\n  }\n  if (!ots::ParseCoverageTable(file, data + offset_coverage1,\n                               length - offset_coverage1,\n                               file->maxp->num_glyphs)) {\n    return OTS_FAILURE_MSG(\"Failed to parse converge 1 table\");\n  }\n  if (offset_coverage2 < header_end || offset_coverage2 >= length) {\n    return OTS_FAILURE_MSG(\"Bad coverage 2 offset %d\", offset_coverage2);\n  }\n  if (!ots::ParseCoverageTable(file, data + offset_coverage2,\n                               length - offset_coverage2,\n                               file->maxp->num_glyphs)) {\n    return OTS_FAILURE_MSG(\"Failed to parse coverage table 2\");\n  }\n\n  if (offset_mark_array < header_end || offset_mark_array >= length) {\n    return OTS_FAILURE_MSG(\"Bad mark array offset %d\", offset_mark_array);\n  }\n  if (!ParseMarkArrayTable(file, data + offset_mark_array,\n                           length - offset_mark_array, class_count)) {\n    return OTS_FAILURE_MSG(\"Failed to parse mark array\");\n  }\n\n  if (offset_type_specific_array < header_end ||\n      offset_type_specific_array >= length) {\n    return OTS_FAILURE_MSG(\"Bad type specific array offset %d\", offset_type_specific_array);\n  }\n  if (type == GPOS_TYPE_MARK_TO_BASE_ATTACHMENT ||\n      type == GPOS_TYPE_MARK_TO_MARK_ATTACHMENT) {\n    if (!ParseAnchorArrayTable(file, data + offset_type_specific_array,\n                               length - offset_type_specific_array,\n                               class_count)) {\n      return OTS_FAILURE_MSG(\"Failed to parse anchor array\");\n    }\n  } else if (type == GPOS_TYPE_MARK_TO_LIGATURE_ATTACHMENT) {\n    if (!ParseLigatureArrayTable(file, data + offset_type_specific_array,\n                                 length - offset_type_specific_array,\n                                 class_count)) {\n      return OTS_FAILURE_MSG(\"Failed to parse ligature array\");\n    }\n  } else {\n    return OTS_FAILURE_MSG(\"Bad attachment type %d\", type);\n  }\n\n  return true;\n}\n\n// Lookup Type 4:\n// MarkToBase Attachment Positioning Subtable\nbool ParseMarkToBaseAttachment(const ots::OpenTypeFile *file,\n                               const uint8_t *data, const size_t length) {\n  return ParseMarkToAttachmentSubtables(file, data, length,\n                                        GPOS_TYPE_MARK_TO_BASE_ATTACHMENT);\n}\n\n// Lookup Type 5:\n// MarkToLigature Attachment Positioning Subtable\nbool ParseMarkToLigatureAttachment(const ots::OpenTypeFile *file,\n                                   const uint8_t *data, const size_t length) {\n  return ParseMarkToAttachmentSubtables(file, data, length,\n                                        GPOS_TYPE_MARK_TO_LIGATURE_ATTACHMENT);\n}\n\n// Lookup Type 6:\n// MarkToMark Attachment Positioning Subtable\nbool ParseMarkToMarkAttachment(const ots::OpenTypeFile *file,\n                               const uint8_t *data, const size_t length) {\n  return ParseMarkToAttachmentSubtables(file, data, length,\n                                        GPOS_TYPE_MARK_TO_MARK_ATTACHMENT);\n}\n\n// Lookup Type 7:\n// Contextual Positioning Subtables\nbool ParseContextPositioning(const ots::OpenTypeFile *file,\n                             const uint8_t *data, const size_t length) {\n  return ots::ParseContextSubtable(file, data, length, file->maxp->num_glyphs,\n                                   file->gpos->num_lookups);\n}\n\n// Lookup Type 8:\n// Chaining Contexual Positioning Subtable\nbool ParseChainedContextPositioning(const ots::OpenTypeFile *file,\n                                    const uint8_t *data, const size_t length) {\n  return ots::ParseChainingContextSubtable(file, data, length,\n                                           file->maxp->num_glyphs,\n                                           file->gpos->num_lookups);\n}\n\n// Lookup Type 9:\n// Extension Positioning\nbool ParseExtensionPositioning(const ots::OpenTypeFile *file,\n                               const uint8_t *data, const size_t length) {\n  return ots::ParseExtensionSubtable(file, data, length,\n                                     &kGposLookupSubtableParser);\n}\n\n}  // namespace\n\n#define DROP_THIS_TABLE(msg_) \\\n  do { \\\n    file->gpos->data = 0; \\\n    file->gpos->length = 0; \\\n    OTS_FAILURE_MSG(msg_ \", table discarded\"); \\\n  } while (0)\n\nnamespace ots {\n\n// As far as I checked, following fonts contain invalid GPOS table and\n// OTS will drop their GPOS table.\n//\n// # invalid delta format in device table\n// samanata.ttf\n//\n// # bad size range in device table\n// Sarai_07.ttf\n//\n// # bad offset to PairSetTable\n// chandas1-2.ttf\n//\n// # bad offset to FeatureTable\n// glrso12.ttf\n// gllr12.ttf\n// glbo12.ttf\n// glb12.ttf\n// glro12.ttf\n// glbso12.ttf\n// glrc12.ttf\n// glrsc12.ttf\n// glbs12.ttf\n// glrs12.ttf\n// glr12.ttf\n//\n// # ScriptRecords aren't sorted by tag\n// Garogier_unhinted.otf\n//\n// # bad start coverage index in CoverageFormat2\n// AndBasR.ttf\n// CharisSILB.ttf\n// CharisSILBI.ttf\n// CharisSILI.ttf\n// CharisSILR.ttf\n// DoulosSILR.ttf\n// GenBasBI.ttf\n// GenBasI.ttf\n// GenBkBasI.ttf\n// GenBkBasB.ttf\n// GenBkBasR.ttf\n// Padauk-Bold.ttf\n// Padauk.ttf\n//\n// # Contour point indexes aren't sorted\n// Arial Unicode.ttf\n\nbool ots_gpos_parse(OpenTypeFile *file, const uint8_t *data, size_t length) {\n  // Parsing GPOS table requires num_glyphs which is contained in maxp table.\n  if (!file->maxp) {\n    return OTS_FAILURE_MSG(\"missing maxp table needed in GPOS\");\n  }\n\n  Buffer table(data, length);\n\n  OpenTypeGPOS *gpos = new OpenTypeGPOS;\n  file->gpos = gpos;\n\n  uint32_t version = 0;\n  uint16_t offset_script_list = 0;\n  uint16_t offset_feature_list = 0;\n  uint16_t offset_lookup_list = 0;\n  if (!table.ReadU32(&version) ||\n      !table.ReadU16(&offset_script_list) ||\n      !table.ReadU16(&offset_feature_list) ||\n      !table.ReadU16(&offset_lookup_list)) {\n    DROP_THIS_TABLE(\"Incomplete table\");\n    return true;\n  }\n\n  if (version != 0x00010000) {\n    DROP_THIS_TABLE(\"Bad version\");\n    return true;\n  }\n\n  if (offset_lookup_list) {\n    if (offset_lookup_list < kGposHeaderSize || offset_lookup_list >= length) {\n      DROP_THIS_TABLE(\"Bad lookup list offset in table header\");\n      return true;\n    }\n\n    if (!ParseLookupListTable(file, data + offset_lookup_list,\n                              length - offset_lookup_list,\n                              &kGposLookupSubtableParser,\n                              &gpos->num_lookups)) {\n      DROP_THIS_TABLE(\"Failed to parse lookup list table\");\n      return true;\n    }\n  }\n\n  uint16_t num_features = 0;\n  if (offset_feature_list) {\n    if (offset_feature_list < kGposHeaderSize || offset_feature_list >= length) {\n      DROP_THIS_TABLE(\"Bad feature list offset in table header\");\n      return true;\n    }\n\n    if (!ParseFeatureListTable(file, data + offset_feature_list,\n                               length - offset_feature_list, gpos->num_lookups,\n                               &num_features)) {\n      DROP_THIS_TABLE(\"Failed to parse feature list table\");\n      return true;\n    }\n  }\n\n  if (offset_script_list) {\n    if (offset_script_list < kGposHeaderSize || offset_script_list >= length) {\n      DROP_THIS_TABLE(\"Bad script list offset in table header\");\n      return true;\n    }\n\n    if (!ParseScriptListTable(file, data + offset_script_list,\n                              length - offset_script_list, num_features)) {\n      DROP_THIS_TABLE(\"Failed to parse script list table\");\n      return true;\n    }\n  }\n\n  gpos->data = data;\n  gpos->length = length;\n  return true;\n}\n\nbool ots_gpos_should_serialise(OpenTypeFile *file) {\n  return file->gpos != NULL && file->gpos->data != NULL;\n}\n\nbool ots_gpos_serialise(OTSStream *out, OpenTypeFile *file) {\n  if (!out->Write(file->gpos->data, file->gpos->length)) {\n    return OTS_FAILURE_MSG(\"Failed to write GPOS table\");\n  }\n\n  return true;\n}\n\nvoid ots_gpos_free(OpenTypeFile *file) {\n  delete file->gpos;\n}\n\n}  // namespace ots\n\n#undef TABLE_NAME\n#undef DROP_THIS_TABLE\n", "// Copyright (c) 2011 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n#include \"gsub.h\"\n\n#include <limits>\n#include <vector>\n\n#include \"layout.h\"\n#include \"maxp.h\"\n\n// GSUB - The Glyph Substitution Table\n// http://www.microsoft.com/typography/otspec/gsub.htm\n\n#define TABLE_NAME \"GSUB\"\n\nnamespace {\n\n// The GSUB header size\nconst size_t kGsubHeaderSize = 4 + 3 * 2;\n\nenum GSUB_TYPE {\n  GSUB_TYPE_SINGLE = 1,\n  GSUB_TYPE_MULTIPLE = 2,\n  GSUB_TYPE_ALTERNATE = 3,\n  GSUB_TYPE_LIGATURE = 4,\n  GSUB_TYPE_CONTEXT = 5,\n  GSUB_TYPE_CHANGING_CONTEXT = 6,\n  GSUB_TYPE_EXTENSION_SUBSTITUTION = 7,\n  GSUB_TYPE_REVERSE_CHAINING_CONTEXT_SINGLE = 8,\n  GSUB_TYPE_RESERVED = 9\n};\n\n// Lookup type parsers.\nbool ParseSingleSubstitution(const ots::OpenTypeFile *file,\n                             const uint8_t *data, const size_t length);\nbool ParseMutipleSubstitution(const ots::OpenTypeFile *file,\n                              const uint8_t *data, const size_t length);\nbool ParseAlternateSubstitution(const ots::OpenTypeFile *file,\n                                const uint8_t *data, const size_t length);\nbool ParseLigatureSubstitution(const ots::OpenTypeFile *file,\n      const uint8_t *data, const size_t length);\nbool ParseContextSubstitution(const ots::OpenTypeFile *file,\n                              const uint8_t *data, const size_t length);\nbool ParseChainingContextSubstitution(const ots::OpenTypeFile *file,\n                                      const uint8_t *data,\n                                      const size_t length);\nbool ParseExtensionSubstitution(const ots::OpenTypeFile *file,\n                                const uint8_t *data, const size_t length);\nbool ParseReverseChainingContextSingleSubstitution(\n    const ots::OpenTypeFile *file, const uint8_t *data, const size_t length);\n\nconst ots::LookupSubtableParser::TypeParser kGsubTypeParsers[] = {\n  {GSUB_TYPE_SINGLE, ParseSingleSubstitution},\n  {GSUB_TYPE_MULTIPLE, ParseMutipleSubstitution},\n  {GSUB_TYPE_ALTERNATE, ParseAlternateSubstitution},\n  {GSUB_TYPE_LIGATURE, ParseLigatureSubstitution},\n  {GSUB_TYPE_CONTEXT, ParseContextSubstitution},\n  {GSUB_TYPE_CHANGING_CONTEXT, ParseChainingContextSubstitution},\n  {GSUB_TYPE_EXTENSION_SUBSTITUTION, ParseExtensionSubstitution},\n  {GSUB_TYPE_REVERSE_CHAINING_CONTEXT_SINGLE,\n    ParseReverseChainingContextSingleSubstitution}\n};\n\nconst ots::LookupSubtableParser kGsubLookupSubtableParser = {\n  arraysize(kGsubTypeParsers),\n  GSUB_TYPE_EXTENSION_SUBSTITUTION, kGsubTypeParsers\n};\n\n// Lookup Type 1:\n// Single Substitution Subtable\nbool ParseSingleSubstitution(const ots::OpenTypeFile *file,\n                             const uint8_t *data, const size_t length) {\n  ots::Buffer subtable(data, length);\n\n  uint16_t format = 0;\n  uint16_t offset_coverage = 0;\n\n  if (!subtable.ReadU16(&format) ||\n      !subtable.ReadU16(&offset_coverage)) {\n    return OTS_FAILURE_MSG(\"Failed to read single subst table header\");\n  }\n\n  const uint16_t num_glyphs = file->maxp->num_glyphs;\n  if (format == 1) {\n    // Parse SingleSubstFormat1\n    int16_t delta_glyph_id = 0;\n    if (!subtable.ReadS16(&delta_glyph_id)) {\n      return OTS_FAILURE_MSG(\"Failed to read glyph shift from format 1 single subst table\");\n    }\n    if (std::abs(delta_glyph_id) >= num_glyphs) {\n      return OTS_FAILURE_MSG(\"bad glyph shift of %d in format 1 single subst table\", delta_glyph_id);\n    }\n  } else if (format == 2) {\n    // Parse SingleSubstFormat2\n    uint16_t glyph_count = 0;\n    if (!subtable.ReadU16(&glyph_count)) {\n      return OTS_FAILURE_MSG(\"Failed to read glyph cound in format 2 single subst table\");\n    }\n    if (glyph_count > num_glyphs) {\n      return OTS_FAILURE_MSG(\"Bad glyph count %d > %d in format 2 single subst table\", glyph_count, num_glyphs);\n    }\n    for (unsigned i = 0; i < glyph_count; ++i) {\n      uint16_t substitute = 0;\n      if (!subtable.ReadU16(&substitute)) {\n        return OTS_FAILURE_MSG(\"Failed to read substitution %d in format 2 single subst table\", i);\n      }\n      if (substitute >= num_glyphs) {\n        return OTS_FAILURE_MSG(\"too large substitute: %u\", substitute);\n      }\n    }\n  } else {\n    return OTS_FAILURE_MSG(\"Bad single subst table format %d\", format);\n  }\n\n  if (offset_coverage < subtable.offset() || offset_coverage >= length) {\n    return OTS_FAILURE_MSG(\"Bad coverage offset %x\", offset_coverage);\n  }\n  if (!ots::ParseCoverageTable(file, data + offset_coverage,\n                               length - offset_coverage, num_glyphs)) {\n    return OTS_FAILURE_MSG(\"Failed to parse coverage table\");\n  }\n\n  return true;\n}\n\nbool ParseSequenceTable(const ots::OpenTypeFile *file,\n                        const uint8_t *data, const size_t length,\n                        const uint16_t num_glyphs) {\n  ots::Buffer subtable(data, length);\n\n  uint16_t glyph_count = 0;\n  if (!subtable.ReadU16(&glyph_count)) {\n    return OTS_FAILURE_MSG(\"Failed to read glyph count in sequence table\");\n  }\n  if (glyph_count > num_glyphs) {\n    return OTS_FAILURE_MSG(\"bad glyph count %d > %d\", glyph_count, num_glyphs);\n  }\n  for (unsigned i = 0; i < glyph_count; ++i) {\n    uint16_t substitute = 0;\n    if (!subtable.ReadU16(&substitute)) {\n      return OTS_FAILURE_MSG(\"Failedt o read substitution %d in sequence table\", i);\n    }\n    if (substitute >= num_glyphs) {\n      return OTS_FAILURE_MSG(\"Bad subsitution (%d) %d > %d\", i, substitute, num_glyphs);\n    }\n  }\n\n  return true;\n}\n\n// Lookup Type 2:\n// Multiple Substitution Subtable\nbool ParseMutipleSubstitution(const ots::OpenTypeFile *file,\n                              const uint8_t *data, const size_t length) {\n  ots::Buffer subtable(data, length);\n\n  uint16_t format = 0;\n  uint16_t offset_coverage = 0;\n  uint16_t sequence_count = 0;\n\n  if (!subtable.ReadU16(&format) ||\n      !subtable.ReadU16(&offset_coverage) ||\n      !subtable.ReadU16(&sequence_count)) {\n    return OTS_FAILURE_MSG(\"Can't read header of multiple subst table\");\n  }\n\n  if (format != 1) {\n    return OTS_FAILURE_MSG(\"Bad multiple subst table format %d\", format);\n  }\n\n  const uint16_t num_glyphs = file->maxp->num_glyphs;\n  const unsigned sequence_end = static_cast<unsigned>(6) +\n      sequence_count * 2;\n  if (sequence_end > std::numeric_limits<uint16_t>::max()) {\n    return OTS_FAILURE_MSG(\"Bad segence end %d, in multiple subst\", sequence_end);\n  }\n  for (unsigned i = 0; i < sequence_count; ++i) {\n    uint16_t offset_sequence = 0;\n    if (!subtable.ReadU16(&offset_sequence)) {\n      return OTS_FAILURE_MSG(\"Failed to read sequence offset for sequence %d\", i);\n    }\n    if (offset_sequence < sequence_end || offset_sequence >= length) {\n      return OTS_FAILURE_MSG(\"Bad sequence offset %d for sequence %d\", offset_sequence, i);\n    }\n    if (!ParseSequenceTable(file, data + offset_sequence, length - offset_sequence,\n                            num_glyphs)) {\n      return OTS_FAILURE_MSG(\"Failed to parse sequence table %d\", i);\n    }\n  }\n\n  if (offset_coverage < sequence_end || offset_coverage >= length) {\n    return OTS_FAILURE_MSG(\"Bad coverage offset %d\", offset_coverage);\n  }\n  if (!ots::ParseCoverageTable(file, data + offset_coverage,\n                               length - offset_coverage, num_glyphs)) {\n    return OTS_FAILURE_MSG(\"Failed to parse coverage table\");\n  }\n\n  return true;\n}\n\nbool ParseAlternateSetTable(const ots::OpenTypeFile *file,\n                            const uint8_t *data, const size_t length,\n                            const uint16_t num_glyphs) {\n  ots::Buffer subtable(data, length);\n\n  uint16_t glyph_count = 0;\n  if (!subtable.ReadU16(&glyph_count)) {\n    return OTS_FAILURE_MSG(\"Failed to read alternate set header\");\n  }\n  if (glyph_count > num_glyphs) {\n    return OTS_FAILURE_MSG(\"Bad glyph count %d > %d in alternate set table\", glyph_count, num_glyphs);\n  }\n  for (unsigned i = 0; i < glyph_count; ++i) {\n    uint16_t alternate = 0;\n    if (!subtable.ReadU16(&alternate)) {\n      return OTS_FAILURE_MSG(\"Can't read alternate %d\", i);\n    }\n    if (alternate >= num_glyphs) {\n      return OTS_FAILURE_MSG(\"Too large alternate: %u\", alternate);\n    }\n  }\n  return true;\n}\n\n// Lookup Type 3:\n// Alternate Substitution Subtable\nbool ParseAlternateSubstitution(const ots::OpenTypeFile *file,\n                                const uint8_t *data, const size_t length) {\n  ots::Buffer subtable(data, length);\n\n  uint16_t format = 0;\n  uint16_t offset_coverage = 0;\n  uint16_t alternate_set_count = 0;\n\n  if (!subtable.ReadU16(&format) ||\n      !subtable.ReadU16(&offset_coverage) ||\n      !subtable.ReadU16(&alternate_set_count)) {\n    return OTS_FAILURE_MSG(\"Can't read alternate subst header\");\n  }\n\n  if (format != 1) {\n    return OTS_FAILURE_MSG(\"Bad alternate subst table format %d\", format);\n  }\n\n  const uint16_t num_glyphs = file->maxp->num_glyphs;\n  const unsigned alternate_set_end = static_cast<unsigned>(6) +\n      alternate_set_count * 2;\n  if (alternate_set_end > std::numeric_limits<uint16_t>::max()) {\n    return OTS_FAILURE_MSG(\"Bad end of alternate set %d\", alternate_set_end);\n  }\n  for (unsigned i = 0; i < alternate_set_count; ++i) {\n    uint16_t offset_alternate_set = 0;\n    if (!subtable.ReadU16(&offset_alternate_set)) {\n      return OTS_FAILURE_MSG(\"Can't read alternate set offset for set %d\", i);\n    }\n    if (offset_alternate_set < alternate_set_end ||\n        offset_alternate_set >= length) {\n      return OTS_FAILURE_MSG(\"Bad alternate set offset %d for set %d\", offset_alternate_set, i);\n    }\n    if (!ParseAlternateSetTable(file, data + offset_alternate_set,\n                                length - offset_alternate_set,\n                                num_glyphs)) {\n      return OTS_FAILURE_MSG(\"Failed to parse alternate set\");\n    }\n  }\n\n  if (offset_coverage < alternate_set_end || offset_coverage >= length) {\n    return OTS_FAILURE_MSG(\"Bad coverage offset %d\", offset_coverage);\n  }\n  if (!ots::ParseCoverageTable(file, data + offset_coverage,\n                               length - offset_coverage, num_glyphs)) {\n    return OTS_FAILURE_MSG(\"Failed to parse coverage table\");\n  }\n\n  return true;\n}\n\nbool ParseLigatureTable(const ots::OpenTypeFile *file,\n                        const uint8_t *data, const size_t length,\n                        const uint16_t num_glyphs) {\n  ots::Buffer subtable(data, length);\n\n  uint16_t lig_glyph = 0;\n  uint16_t comp_count = 0;\n\n  if (!subtable.ReadU16(&lig_glyph) ||\n      !subtable.ReadU16(&comp_count)) {\n    return OTS_FAILURE_MSG(\"Failed to read ligatuer table header\");\n  }\n\n  if (lig_glyph >= num_glyphs) {\n    return OTS_FAILURE_MSG(\"too large lig_glyph: %u\", lig_glyph);\n  }\n  if (comp_count == 0 || comp_count > num_glyphs) {\n    return OTS_FAILURE_MSG(\"Bad component count of %d\", comp_count);\n  }\n  for (unsigned i = 0; i < comp_count - static_cast<unsigned>(1); ++i) {\n    uint16_t component = 0;\n    if (!subtable.ReadU16(&component)) {\n      return OTS_FAILURE_MSG(\"Can't read ligature component %d\", i);\n    }\n    if (component >= num_glyphs) {\n      return OTS_FAILURE_MSG(\"Bad ligature component %d of %d\", i, component);\n    }\n  }\n\n  return true;\n}\n\nbool ParseLigatureSetTable(const ots::OpenTypeFile *file,\n                           const uint8_t *data, const size_t length,\n                           const uint16_t num_glyphs) {\n  ots::Buffer subtable(data, length);\n\n  uint16_t ligature_count = 0;\n\n  if (!subtable.ReadU16(&ligature_count)) {\n    return OTS_FAILURE_MSG(\"Can't read ligature count in ligature set\");\n  }\n\n  const unsigned ligature_end = static_cast<unsigned>(2) + ligature_count * 2;\n  if (ligature_end > std::numeric_limits<uint16_t>::max()) {\n    return OTS_FAILURE_MSG(\"Bad end of ligature %d in ligature set\", ligature_end);\n  }\n  for (unsigned i = 0; i < ligature_count; ++i) {\n    uint16_t offset_ligature = 0;\n    if (!subtable.ReadU16(&offset_ligature)) {\n      return OTS_FAILURE_MSG(\"Failed to read ligature offset %d\", i);\n    }\n    if (offset_ligature < ligature_end || offset_ligature >= length) {\n      return OTS_FAILURE_MSG(\"Bad ligature offset %d for ligature %d\", offset_ligature, i);\n    }\n    if (!ParseLigatureTable(file, data + offset_ligature, length - offset_ligature,\n                            num_glyphs)) {\n      return OTS_FAILURE_MSG(\"Failed to parse ligature %d\", i);\n    }\n  }\n\n  return true;\n}\n\n// Lookup Type 4:\n// Ligature Substitution Subtable\nbool ParseLigatureSubstitution(const ots::OpenTypeFile *file,\n                               const uint8_t *data, const size_t length) {\n  ots::Buffer subtable(data, length);\n\n  uint16_t format = 0;\n  uint16_t offset_coverage = 0;\n  uint16_t lig_set_count = 0;\n\n  if (!subtable.ReadU16(&format) ||\n      !subtable.ReadU16(&offset_coverage) ||\n      !subtable.ReadU16(&lig_set_count)) {\n    return OTS_FAILURE_MSG(\"Failed to read ligature substitution header\");\n  }\n\n  if (format != 1) {\n    return OTS_FAILURE_MSG(\"Bad ligature substitution table format %d\", format);\n  }\n\n  const uint16_t num_glyphs = file->maxp->num_glyphs;\n  const unsigned ligature_set_end = static_cast<unsigned>(6) +\n      lig_set_count * 2;\n  if (ligature_set_end > std::numeric_limits<uint16_t>::max()) {\n    return OTS_FAILURE_MSG(\"Bad end of ligature set %d in ligature substitution table\", ligature_set_end);\n  }\n  for (unsigned i = 0; i < lig_set_count; ++i) {\n    uint16_t offset_ligature_set = 0;\n    if (!subtable.ReadU16(&offset_ligature_set)) {\n      return OTS_FAILURE_MSG(\"Can't read ligature set offset %d\", i);\n    }\n    if (offset_ligature_set < ligature_set_end ||\n        offset_ligature_set >= length) {\n      return OTS_FAILURE_MSG(\"Bad ligature set offset %d for set %d\", offset_ligature_set, i);\n    }\n    if (!ParseLigatureSetTable(file, data + offset_ligature_set,\n                               length - offset_ligature_set, num_glyphs)) {\n      return OTS_FAILURE_MSG(\"Failed to parse ligature set %d\", i);\n    }\n  }\n\n  if (offset_coverage < ligature_set_end || offset_coverage >= length) {\n    return OTS_FAILURE_MSG(\"Bad coverage offset %d\", offset_coverage);\n  }\n  if (!ots::ParseCoverageTable(file, data + offset_coverage,\n                               length - offset_coverage, num_glyphs)) {\n    return OTS_FAILURE_MSG(\"Failed to parse coverage table\");\n  }\n\n  return true;\n}\n\n// Lookup Type 5:\n// Contextual Substitution Subtable\nbool ParseContextSubstitution(const ots::OpenTypeFile *file,\n                              const uint8_t *data, const size_t length) {\n  return ots::ParseContextSubtable(file, data, length, file->maxp->num_glyphs,\n                                   file->gsub->num_lookups);\n}\n\n// Lookup Type 6:\n// Chaining Contextual Substitution Subtable\nbool ParseChainingContextSubstitution(const ots::OpenTypeFile *file,\n                                      const uint8_t *data,\n                                      const size_t length) {\n  return ots::ParseChainingContextSubtable(file, data, length,\n                                           file->maxp->num_glyphs,\n                                           file->gsub->num_lookups);\n}\n\n// Lookup Type 7:\n// Extension Substition\nbool ParseExtensionSubstitution(const ots::OpenTypeFile *file,\n                                const uint8_t *data, const size_t length) {\n  return ots::ParseExtensionSubtable(file, data, length,\n                                     &kGsubLookupSubtableParser);\n}\n\n// Lookup Type 8:\n// Reverse Chaining Contexual Single Substitution Subtable\nbool ParseReverseChainingContextSingleSubstitution(\n    const ots::OpenTypeFile *file, const uint8_t *data, const size_t length) {\n  ots::Buffer subtable(data, length);\n\n  uint16_t format = 0;\n  uint16_t offset_coverage = 0;\n\n  if (!subtable.ReadU16(&format) ||\n      !subtable.ReadU16(&offset_coverage)) {\n    return OTS_FAILURE_MSG(\"Failed to read reverse chaining header\");\n  }\n\n  const uint16_t num_glyphs = file->maxp->num_glyphs;\n\n  uint16_t backtrack_glyph_count = 0;\n  if (!subtable.ReadU16(&backtrack_glyph_count)) {\n    return OTS_FAILURE_MSG(\"Failed to read backtrack glyph count in reverse chaining table\");\n  }\n  if (backtrack_glyph_count > num_glyphs) {\n    return OTS_FAILURE_MSG(\"Bad backtrack glyph count of %d\", backtrack_glyph_count);\n  }\n  std::vector<uint16_t> offsets_backtrack;\n  offsets_backtrack.reserve(backtrack_glyph_count);\n  for (unsigned i = 0; i < backtrack_glyph_count; ++i) {\n    uint16_t offset = 0;\n    if (!subtable.ReadU16(&offset)) {\n      return OTS_FAILURE_MSG(\"Failed to read backtrack offset %d\", i);\n    }\n    offsets_backtrack.push_back(offset);\n  }\n\n  uint16_t lookahead_glyph_count = 0;\n  if (!subtable.ReadU16(&lookahead_glyph_count)) {\n    return OTS_FAILURE_MSG(\"Failed to read look ahead glyph count\");\n  }\n  if (lookahead_glyph_count > num_glyphs) {\n    return OTS_FAILURE_MSG(\"Bad look ahead glyph count %d\", lookahead_glyph_count);\n  }\n  std::vector<uint16_t> offsets_lookahead;\n  offsets_lookahead.reserve(lookahead_glyph_count);\n  for (unsigned i = 0; i < lookahead_glyph_count; ++i) {\n    uint16_t offset = 0;\n    if (!subtable.ReadU16(&offset)) {\n      return OTS_FAILURE_MSG(\"Can't read look ahead offset %d\", i);\n    }\n    offsets_lookahead.push_back(offset);\n  }\n\n  uint16_t glyph_count = 0;\n  if (!subtable.ReadU16(&glyph_count)) {\n    return OTS_FAILURE_MSG(\"Can't read glyph count in reverse chaining table\");\n  }\n  if (glyph_count > num_glyphs) {\n    return OTS_FAILURE_MSG(\"Bad glyph count of %d\", glyph_count);\n  }\n  for (unsigned i = 0; i < glyph_count; ++i) {\n    uint16_t substitute = 0;\n    if (!subtable.ReadU16(&substitute)) {\n      return OTS_FAILURE_MSG(\"Failed to read substitution %d reverse chaining table\", i);\n    }\n    if (substitute >= num_glyphs) {\n      return OTS_FAILURE_MSG(\"Bad substitute glyph %d in reverse chaining table substitution %d\", substitute, i);\n    }\n  }\n\n  const unsigned substitute_end = static_cast<unsigned>(10) +\n      (backtrack_glyph_count + lookahead_glyph_count + glyph_count) * 2;\n  if (substitute_end > std::numeric_limits<uint16_t>::max()) {\n    return OTS_FAILURE_MSG(\"Bad substitute end offset in reverse chaining table\");\n  }\n\n  if (offset_coverage < substitute_end || offset_coverage >= length) {\n    return OTS_FAILURE_MSG(\"Bad coverage offset %d in reverse chaining table\", offset_coverage);\n  }\n  if (!ots::ParseCoverageTable(file, data + offset_coverage,\n                               length - offset_coverage, num_glyphs)) {\n    return OTS_FAILURE_MSG(\"Failed to parse coverage table in reverse chaining table\");\n  }\n\n  for (unsigned i = 0; i < backtrack_glyph_count; ++i) {\n    if (offsets_backtrack[i] < substitute_end ||\n        offsets_backtrack[i] >= length) {\n      return OTS_FAILURE_MSG(\"Bad backtrack offset %d for backtrack %d in reverse chaining table\", offsets_backtrack[i], i);\n    }\n    if (!ots::ParseCoverageTable(file, data + offsets_backtrack[i],\n                                 length - offsets_backtrack[i], num_glyphs)) {\n      return OTS_FAILURE_MSG(\"Failed to parse coverage table for backtrack %d in reverse chaining table\", i);\n    }\n  }\n\n  for (unsigned i = 0; i < lookahead_glyph_count; ++i) {\n    if (offsets_lookahead[i] < substitute_end ||\n        offsets_lookahead[i] >= length) {\n      return OTS_FAILURE_MSG(\"Bad lookahead offset %d for lookahead %d in reverse chaining table\", offsets_lookahead[i], i);\n    }\n    if (!ots::ParseCoverageTable(file, data + offsets_lookahead[i],\n                                 length - offsets_lookahead[i], num_glyphs)) {\n      return OTS_FAILURE_MSG(\"Failed to parse lookahead coverage table %d in reverse chaining table\", i);\n    }\n  }\n\n  return true;\n}\n\n}  // namespace\n\n#define DROP_THIS_TABLE(msg_) \\\n  do { \\\n    file->gsub->data = 0; \\\n    file->gsub->length = 0; \\\n    OTS_FAILURE_MSG(msg_ \", table discarded\"); \\\n  } while (0)\n\nnamespace ots {\n\n// As far as I checked, following fonts contain invalid values in GSUB table.\n// OTS will drop their GSUB table.\n//\n// # too large substitute (value is 0xFFFF)\n// kaiu.ttf\n// mingliub2.ttf\n// mingliub1.ttf\n// mingliub0.ttf\n// GraublauWeb.otf\n// GraublauWebBold.otf\n//\n// # too large alternate (value is 0xFFFF)\n// ManchuFont.ttf\n//\n// # bad offset to lang sys table (NULL offset)\n// DejaVuMonoSansBold.ttf\n// DejaVuMonoSansBoldOblique.ttf\n// DejaVuMonoSansOblique.ttf\n// DejaVuSansMono-BoldOblique.ttf\n// DejaVuSansMono-Oblique.ttf\n// DejaVuSansMono-Bold.ttf\n//\n// # bad start coverage index\n// GenBasBI.ttf\n// GenBasI.ttf\n// AndBasR.ttf\n// GenBkBasI.ttf\n// CharisSILR.ttf\n// CharisSILBI.ttf\n// CharisSILI.ttf\n// CharisSILB.ttf\n// DoulosSILR.ttf\n// CharisSILBI.ttf\n// GenBkBasB.ttf\n// GenBkBasR.ttf\n// GenBkBasBI.ttf\n// GenBasB.ttf\n// GenBasR.ttf\n//\n// # glyph range is overlapping\n// KacstTitleL.ttf\n// KacstDecorative.ttf\n// KacstTitle.ttf\n// KacstArt.ttf\n// KacstPoster.ttf\n// KacstQurn.ttf\n// KacstDigital.ttf\n// KacstBook.ttf\n// KacstFarsi.ttf\n\nbool ots_gsub_parse(OpenTypeFile *file, const uint8_t *data, size_t length) {\n  // Parsing gsub table requires |file->maxp->num_glyphs|\n  if (!file->maxp) {\n    return OTS_FAILURE_MSG(\"Missing maxp table in font, needed by GSUB\");\n  }\n\n  Buffer table(data, length);\n\n  OpenTypeGSUB *gsub = new OpenTypeGSUB;\n  file->gsub = gsub;\n\n  uint32_t version = 0;\n  uint16_t offset_script_list = 0;\n  uint16_t offset_feature_list = 0;\n  uint16_t offset_lookup_list = 0;\n  if (!table.ReadU32(&version) ||\n      !table.ReadU16(&offset_script_list) ||\n      !table.ReadU16(&offset_feature_list) ||\n      !table.ReadU16(&offset_lookup_list)) {\n    DROP_THIS_TABLE(\"Incomplete table\");\n    return true;\n  }\n\n  if (version != 0x00010000) {\n    DROP_THIS_TABLE(\"Bad version\");\n    return true;\n  }\n\n  if (offset_lookup_list) {\n    if (offset_lookup_list < kGsubHeaderSize || offset_lookup_list >= length) {\n      DROP_THIS_TABLE(\"Bad lookup list offset in table header\");\n      return true;\n    }\n\n    if (!ParseLookupListTable(file, data + offset_lookup_list,\n                              length - offset_lookup_list,\n                              &kGsubLookupSubtableParser,\n                              &gsub->num_lookups)) {\n      DROP_THIS_TABLE(\"Failed to parse lookup list table\");\n      return true;\n    }\n  }\n\n  uint16_t num_features = 0;\n  if (offset_feature_list) {\n    if (offset_feature_list < kGsubHeaderSize || offset_feature_list >= length) {\n      DROP_THIS_TABLE(\"Bad feature list offset in table header\");\n      return true;\n    }\n\n    if (!ParseFeatureListTable(file, data + offset_feature_list,\n                               length - offset_feature_list, gsub->num_lookups,\n                               &num_features)) {\n      DROP_THIS_TABLE(\"Failed to parse feature list table\");\n      return true;\n    }\n  }\n\n  if (offset_script_list) {\n    if (offset_script_list < kGsubHeaderSize || offset_script_list >= length) {\n      DROP_THIS_TABLE(\"Bad script list offset in table header\");\n      return true;\n    }\n\n    if (!ParseScriptListTable(file, data + offset_script_list,\n                              length - offset_script_list, num_features)) {\n      DROP_THIS_TABLE(\"Failed to parse script list table\");\n      return true;\n    }\n  }\n\n  gsub->data = data;\n  gsub->length = length;\n  return true;\n}\n\nbool ots_gsub_should_serialise(OpenTypeFile *file) {\n  return file->gsub != NULL && file->gsub->data != NULL;\n}\n\nbool ots_gsub_serialise(OTSStream *out, OpenTypeFile *file) {\n  if (!out->Write(file->gsub->data, file->gsub->length)) {\n    return OTS_FAILURE_MSG(\"Failed to write GSUB table\");\n  }\n\n  return true;\n}\n\nvoid ots_gsub_free(OpenTypeFile *file) {\n  delete file->gsub;\n}\n\n}  // namespace ots\n\n#undef TABLE_NAME\n#undef DROP_THIS_TABLE\n", "// Copyright (c) 2009 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n#include \"hdmx.h\"\n#include \"head.h\"\n#include \"maxp.h\"\n\n// hdmx - Horizontal Device Metrics\n// http://www.microsoft.com/typography/otspec/hdmx.htm\n\n#define TABLE_NAME \"hdmx\"\n\n#define DROP_THIS_TABLE(...) \\\n  do { \\\n    delete file->hdmx; \\\n    file->hdmx = 0; \\\n    OTS_FAILURE_MSG_(file, TABLE_NAME \": \" __VA_ARGS__); \\\n    OTS_FAILURE_MSG(\"Table discarded\"); \\\n  } while (0)\n\nnamespace ots {\n\nbool ots_hdmx_parse(OpenTypeFile *file, const uint8_t *data, size_t length) {\n  Buffer table(data, length);\n  file->hdmx = new OpenTypeHDMX;\n  OpenTypeHDMX * const hdmx = file->hdmx;\n\n  if (!file->head || !file->maxp) {\n    return OTS_FAILURE_MSG(\"Missing maxp or head tables in font, needed by hdmx\");\n  }\n\n  if ((file->head->flags & 0x14) == 0) {\n    // http://www.microsoft.com/typography/otspec/recom.htm\n    DROP_THIS_TABLE(\"the table should not be present when bit 2 and 4 of the \"\n                    \"head->flags are not set\");\n    return true;\n  }\n\n  int16_t num_recs;\n  if (!table.ReadU16(&hdmx->version) ||\n      !table.ReadS16(&num_recs) ||\n      !table.ReadS32(&hdmx->size_device_record)) {\n    return OTS_FAILURE_MSG(\"Failed to read hdmx header\");\n  }\n  if (hdmx->version != 0) {\n    DROP_THIS_TABLE(\"bad version: %u\", hdmx->version);\n    return true;\n  }\n  if (num_recs <= 0) {\n    DROP_THIS_TABLE(\"bad num_recs: %d\", num_recs);\n    return true;\n  }\n  const int32_t actual_size_device_record = file->maxp->num_glyphs + 2;\n  if (hdmx->size_device_record < actual_size_device_record) {\n    DROP_THIS_TABLE(\"bad hdmx->size_device_record: %d\", hdmx->size_device_record);\n    return true;\n  }\n\n  hdmx->pad_len = hdmx->size_device_record - actual_size_device_record;\n  if (hdmx->pad_len > 3) {\n    return OTS_FAILURE_MSG(\"Bad padding %d\", hdmx->pad_len);\n  }\n\n  uint8_t last_pixel_size = 0;\n  hdmx->records.reserve(num_recs);\n  for (int i = 0; i < num_recs; ++i) {\n    OpenTypeHDMXDeviceRecord rec;\n\n    if (!table.ReadU8(&rec.pixel_size) ||\n        !table.ReadU8(&rec.max_width)) {\n      return OTS_FAILURE_MSG(\"Failed to read hdmx record %d\", i);\n    }\n    if ((i != 0) &&\n        (rec.pixel_size <= last_pixel_size)) {\n      DROP_THIS_TABLE(\"records are not sorted\");\n      return true;\n    }\n    last_pixel_size = rec.pixel_size;\n\n    rec.widths.reserve(file->maxp->num_glyphs);\n    for (unsigned j = 0; j < file->maxp->num_glyphs; ++j) {\n      uint8_t width;\n      if (!table.ReadU8(&width)) {\n        return OTS_FAILURE_MSG(\"Failed to read glyph width %d in record %d\", j, i);\n      }\n      rec.widths.push_back(width);\n    }\n\n    if ((hdmx->pad_len > 0) &&\n        !table.Skip(hdmx->pad_len)) {\n      return OTS_FAILURE_MSG(\"Failed to skip padding %d\", hdmx->pad_len);\n    }\n\n    hdmx->records.push_back(rec);\n  }\n\n  return true;\n}\n\nbool ots_hdmx_should_serialise(OpenTypeFile *file) {\n  if (!file->hdmx) return false;\n  if (!file->glyf) return false;  // this table is not for CFF fonts.\n  return true;\n}\n\nbool ots_hdmx_serialise(OTSStream *out, OpenTypeFile *file) {\n  OpenTypeHDMX * const hdmx = file->hdmx;\n\n  const int16_t num_recs = static_cast<int16_t>(hdmx->records.size());\n  if (hdmx->records.size() >\n          static_cast<size_t>(std::numeric_limits<int16_t>::max()) ||\n      !out->WriteU16(hdmx->version) ||\n      !out->WriteS16(num_recs) ||\n      !out->WriteS32(hdmx->size_device_record)) {\n    return OTS_FAILURE_MSG(\"Failed to write hdmx header\");\n  }\n\n  for (int16_t i = 0; i < num_recs; ++i) {\n    const OpenTypeHDMXDeviceRecord& rec = hdmx->records[i];\n    if (!out->Write(&rec.pixel_size, 1) ||\n        !out->Write(&rec.max_width, 1) ||\n        !out->Write(&rec.widths[0], rec.widths.size())) {\n      return OTS_FAILURE_MSG(\"Failed to write hdmx record %d\", i);\n    }\n    if ((hdmx->pad_len > 0) &&\n        !out->Write((const uint8_t *)\"\\x00\\x00\\x00\", hdmx->pad_len)) {\n      return OTS_FAILURE_MSG(\"Failed to write hdmx padding of length %d\", hdmx->pad_len);\n    }\n  }\n\n  return true;\n}\n\nvoid ots_hdmx_free(OpenTypeFile *file) {\n  delete file->hdmx;\n}\n\n}  // namespace ots\n\n#undef TABLE_NAME\n#undef DROP_THIS_TABLE\n", "// Copyright (c) 2009 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n#include \"kern.h\"\n\n// kern - Kerning\n// http://www.microsoft.com/typography/otspec/kern.htm\n\n#define TABLE_NAME \"kern\"\n\n#define DROP_THIS_TABLE(msg_) \\\n  do { \\\n    delete file->kern; \\\n    file->kern = 0; \\\n    OTS_FAILURE_MSG(msg_ \", table discarded\"); \\\n  } while (0)\n\nnamespace ots {\n\nbool ots_kern_parse(OpenTypeFile *file, const uint8_t *data, size_t length) {\n  Buffer table(data, length);\n\n  OpenTypeKERN *kern = new OpenTypeKERN;\n  file->kern = kern;\n\n  uint16_t num_tables = 0;\n  if (!table.ReadU16(&kern->version) ||\n      !table.ReadU16(&num_tables)) {\n    return OTS_FAILURE_MSG(\"Failed to read kern header\");\n  }\n\n  if (kern->version > 0) {\n    DROP_THIS_TABLE(\"bad table version\");\n    return true;\n  }\n\n  if (num_tables == 0) {\n    DROP_THIS_TABLE(\"num_tables is zero\");\n    return true;\n  }\n\n  kern->subtables.reserve(num_tables);\n  for (unsigned i = 0; i < num_tables; ++i) {\n    OpenTypeKERNFormat0 subtable;\n    uint16_t sub_length = 0;\n\n    if (!table.ReadU16(&subtable.version) ||\n        !table.ReadU16(&sub_length)) {\n      return OTS_FAILURE_MSG(\"Failed to read kern subtable %d header\", i);\n    }\n\n    if (subtable.version > 0) {\n      OTS_WARNING(\"Bad subtable version: %d\", subtable.version);\n      continue;\n    }\n\n    const size_t current_offset = table.offset();\n    if (current_offset - 4 + sub_length > length) {\n      return OTS_FAILURE_MSG(\"Bad kern subtable %d offset %ld\", i, current_offset);\n    }\n\n    if (!table.ReadU16(&subtable.coverage)) {\n      return OTS_FAILURE_MSG(\"Cailed to read kern subtable %d coverage\", i);\n    }\n\n    if (!(subtable.coverage & 0x1)) {\n      OTS_WARNING(\n          \"We don't support vertical data as the renderer doesn't support it.\");\n      continue;\n    }\n    if (subtable.coverage & 0xF0) {\n      DROP_THIS_TABLE(\"Reserved fields should zero-filled.\");\n      return true;\n    }\n    const uint32_t format = (subtable.coverage & 0xFF00) >> 8;\n    if (format != 0) {\n      OTS_WARNING(\"Format %d is not supported.\", format);\n      continue;\n    }\n\n    // Parse the format 0 field.\n    uint16_t num_pairs = 0;\n    if (!table.ReadU16(&num_pairs) ||\n        !table.ReadU16(&subtable.search_range) ||\n        !table.ReadU16(&subtable.entry_selector) ||\n        !table.ReadU16(&subtable.range_shift)) {\n      return OTS_FAILURE_MSG(\"Failed to read kern subtable %d format 0 fields\", i);\n    }\n\n    if (!num_pairs) {\n      DROP_THIS_TABLE(\"Zero length subtable is found.\");\n      return true;\n    }\n\n    // Sanity checks for search_range, entry_selector, and range_shift. See the\n    // comment in ots.cc for details.\n    const size_t kFormat0PairSize = 6;  // left, right, and value. 2 bytes each.\n    if (num_pairs > (65536 / kFormat0PairSize)) {\n      // Some fonts (e.g. calibri.ttf, pykes_peak_zero.ttf) have pairs >= 10923.\n      DROP_THIS_TABLE(\"Too large subtable.\");\n      return true;\n    }\n    unsigned max_pow2 = 0;\n    while (1u << (max_pow2 + 1) <= num_pairs) {\n      ++max_pow2;\n    }\n    const uint16_t expected_search_range = (1u << max_pow2) * kFormat0PairSize;\n    if (subtable.search_range != expected_search_range) {\n      OTS_WARNING(\"bad search range\");\n      subtable.search_range = expected_search_range;\n    }\n    if (subtable.entry_selector != max_pow2) {\n      return OTS_FAILURE_MSG(\"Bad subtable %d entry selector %d\", i, subtable.entry_selector);\n    }\n    const uint16_t expected_range_shift =\n        kFormat0PairSize * num_pairs - subtable.search_range;\n    if (subtable.range_shift != expected_range_shift) {\n      OTS_WARNING(\"bad range shift\");\n      subtable.range_shift = expected_range_shift;\n    }\n\n    // Read kerning pairs.\n    subtable.pairs.reserve(num_pairs);\n    uint32_t last_pair = 0;\n    for (unsigned j = 0; j < num_pairs; ++j) {\n      OpenTypeKERNFormat0Pair kerning_pair;\n      if (!table.ReadU16(&kerning_pair.left) ||\n          !table.ReadU16(&kerning_pair.right) ||\n          !table.ReadS16(&kerning_pair.value)) {\n        return OTS_FAILURE_MSG(\"Failed to read subtable %d kerning pair %d\", i, j);\n      }\n      const uint32_t current_pair\n          = (kerning_pair.left << 16) + kerning_pair.right;\n      if (j != 0 && current_pair <= last_pair) {\n        // Many free fonts don't follow this rule, so we don't call OTS_FAILURE\n        // in order to support these fonts.\n        DROP_THIS_TABLE(\"Kerning pairs are not sorted.\");\n        return true;\n      }\n      last_pair = current_pair;\n      subtable.pairs.push_back(kerning_pair);\n    }\n\n    kern->subtables.push_back(subtable);\n  }\n\n  if (!kern->subtables.size()) {\n    DROP_THIS_TABLE(\"All subtables are removed.\");\n    return true;\n  }\n\n  return true;\n}\n\nbool ots_kern_should_serialise(OpenTypeFile *file) {\n  if (!file->glyf) return false;  // this table is not for CFF fonts.\n  return file->kern != NULL;\n}\n\nbool ots_kern_serialise(OTSStream *out, OpenTypeFile *file) {\n  const OpenTypeKERN *kern = file->kern;\n\n  const uint16_t num_subtables = static_cast<uint16_t>(kern->subtables.size());\n  if (num_subtables != kern->subtables.size() ||\n      !out->WriteU16(kern->version) ||\n      !out->WriteU16(num_subtables)) {\n    return OTS_FAILURE_MSG(\"Can't write kern table header\");\n  }\n\n  for (uint16_t i = 0; i < num_subtables; ++i) {\n    const size_t length = 14 + (6 * kern->subtables[i].pairs.size());\n    if (length > std::numeric_limits<uint16_t>::max() ||\n        !out->WriteU16(kern->subtables[i].version) ||\n        !out->WriteU16(static_cast<uint16_t>(length)) ||\n        !out->WriteU16(kern->subtables[i].coverage) ||\n        !out->WriteU16(\n            static_cast<uint16_t>(kern->subtables[i].pairs.size())) ||\n        !out->WriteU16(kern->subtables[i].search_range) ||\n        !out->WriteU16(kern->subtables[i].entry_selector) ||\n        !out->WriteU16(kern->subtables[i].range_shift)) {\n      return OTS_FAILURE_MSG(\"Failed to write kern subtable %d\", i);\n    }\n    for (unsigned j = 0; j < kern->subtables[i].pairs.size(); ++j) {\n      if (!out->WriteU16(kern->subtables[i].pairs[j].left) ||\n          !out->WriteU16(kern->subtables[i].pairs[j].right) ||\n          !out->WriteS16(kern->subtables[i].pairs[j].value)) {\n        return OTS_FAILURE_MSG(\"Failed to write kern pair %d for subtable %d\", j, i);\n      }\n    }\n  }\n\n  return true;\n}\n\nvoid ots_kern_free(OpenTypeFile *file) {\n  delete file->kern;\n}\n\n}  // namespace ots\n\n#undef TABLE_NAME\n#undef DROP_THIS_TABLE\n", "// Copyright (c) 2009 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n#include \"ltsh.h\"\n\n#include \"maxp.h\"\n\n// LTSH - Linear Threshold\n// http://www.microsoft.com/typography/otspec/ltsh.htm\n\n#define TABLE_NAME \"LTSH\"\n\n#define DROP_THIS_TABLE(...) \\\n  do { \\\n    delete file->ltsh; \\\n    file->ltsh = 0; \\\n    OTS_FAILURE_MSG_(file, TABLE_NAME \": \" __VA_ARGS__); \\\n    OTS_FAILURE_MSG(\"Table discarded\"); \\\n  } while (0)\n\nnamespace ots {\n\nbool ots_ltsh_parse(OpenTypeFile *file, const uint8_t *data, size_t length) {\n  Buffer table(data, length);\n\n  if (!file->maxp) {\n    return OTS_FAILURE_MSG(\"Missing maxp table from font needed by ltsh\");\n  }\n\n  OpenTypeLTSH *ltsh = new OpenTypeLTSH;\n  file->ltsh = ltsh;\n\n  uint16_t num_glyphs = 0;\n  if (!table.ReadU16(&ltsh->version) ||\n      !table.ReadU16(&num_glyphs)) {\n    return OTS_FAILURE_MSG(\"Failed to read ltsh header\");\n  }\n\n  if (ltsh->version != 0) {\n    DROP_THIS_TABLE(\"bad version: %u\", ltsh->version);\n    return true;\n  }\n\n  if (num_glyphs != file->maxp->num_glyphs) {\n    DROP_THIS_TABLE(\"bad num_glyphs: %u\", num_glyphs);\n    return true;\n  }\n\n  ltsh->ypels.reserve(num_glyphs);\n  for (unsigned i = 0; i < num_glyphs; ++i) {\n    uint8_t pel = 0;\n    if (!table.ReadU8(&pel)) {\n      return OTS_FAILURE_MSG(\"Failed to read pixels for glyph %d\", i);\n    }\n    ltsh->ypels.push_back(pel);\n  }\n\n  return true;\n}\n\nbool ots_ltsh_should_serialise(OpenTypeFile *file) {\n  if (!file->glyf) return false;  // this table is not for CFF fonts.\n  return file->ltsh != NULL;\n}\n\nbool ots_ltsh_serialise(OTSStream *out, OpenTypeFile *file) {\n  const OpenTypeLTSH *ltsh = file->ltsh;\n\n  const uint16_t num_ypels = static_cast<uint16_t>(ltsh->ypels.size());\n  if (num_ypels != ltsh->ypels.size() ||\n      !out->WriteU16(ltsh->version) ||\n      !out->WriteU16(num_ypels)) {\n    return OTS_FAILURE_MSG(\"Failed to write pels size\");\n  }\n  for (uint16_t i = 0; i < num_ypels; ++i) {\n    if (!out->Write(&(ltsh->ypels[i]), 1)) {\n      return OTS_FAILURE_MSG(\"Failed to write pixel size for glyph %d\", i);\n    }\n  }\n\n  return true;\n}\n\nvoid ots_ltsh_free(OpenTypeFile *file) {\n  delete file->ltsh;\n}\n\n}  // namespace ots\n\n#undef TABLE_NAME\n#undef DROP_THIS_TABLE\n", "// Copyright (c) 2014 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n// We use an underscore to avoid confusion with the standard math.h library.\n#include \"math_.h\"\n\n#include <limits>\n#include <vector>\n\n#include \"layout.h\"\n#include \"maxp.h\"\n\n// MATH - The MATH Table\n// The specification is not yet public but has been submitted to the MPEG group\n// in response to the 'Call for Proposals for ISO/IEC 14496-22 \"Open Font\n// Format\" Color Font Technology and MATH layout support'. Meanwhile, you can\n// contact Microsoft's engineer Murray Sargent to obtain a copy.\n\n#define TABLE_NAME \"MATH\"\n\nnamespace {\n\n// The size of MATH header.\n// Version\n// MathConstants\n// MathGlyphInfo\n// MathVariants\nconst unsigned kMathHeaderSize = 4 + 3 * 2;\n\n// The size of the MathGlyphInfo header.\n// MathItalicsCorrectionInfo\n// MathTopAccentAttachment\n// ExtendedShapeCoverage\n// MathKernInfo\nconst unsigned kMathGlyphInfoHeaderSize = 4 * 2;\n\n// The size of the MathValueRecord.\n// Value\n// DeviceTable\nconst unsigned kMathValueRecordSize = 2 * 2;\n\n// The size of the GlyphPartRecord.\n// glyph\n// StartConnectorLength\n// EndConnectorLength\n// FullAdvance\n// PartFlags\nconst unsigned kGlyphPartRecordSize = 5 * 2;\n\n// Shared Table: MathValueRecord\n\nbool ParseMathValueRecord(const ots::OpenTypeFile *file,\n                          ots::Buffer* subtable, const uint8_t *data,\n                          const size_t length) {\n  // Check the Value field.\n  if (!subtable->Skip(2)) {\n    return OTS_FAILURE();\n  }\n\n  // Check the offset to device table.\n  uint16_t offset = 0;\n  if (!subtable->ReadU16(&offset)) {\n    return OTS_FAILURE();\n  }\n  if (offset) {\n    if (offset >= length) {\n      return OTS_FAILURE();\n    }\n    if (!ots::ParseDeviceTable(file, data + offset, length - offset)) {\n      return OTS_FAILURE();\n    }\n  }\n\n  return true;\n}\n\nbool ParseMathConstantsTable(const ots::OpenTypeFile *file,\n                             const uint8_t *data, size_t length) {\n  ots::Buffer subtable(data, length);\n\n  // Part 1: int16 or uint16 constants.\n  //  ScriptPercentScaleDown\n  //  ScriptScriptPercentScaleDown\n  //  DelimitedSubFormulaMinHeight\n  //  DisplayOperatorMinHeight\n  if (!subtable.Skip(4 * 2)) {\n    return OTS_FAILURE();\n  }\n\n  // Part 2: MathValueRecord constants.\n  // MathLeading\n  // AxisHeight\n  // AccentBaseHeight\n  // FlattenedAccentBaseHeight\n  // SubscriptShiftDown\n  // SubscriptTopMax\n  // SubscriptBaselineDropMin\n  // SuperscriptShiftUp\n  // SuperscriptShiftUpCramped\n  // SuperscriptBottomMin\n  //\n  // SuperscriptBaselineDropMax\n  // SubSuperscriptGapMin\n  // SuperscriptBottomMaxWithSubscript\n  // SpaceAfterScript\n  // UpperLimitGapMin\n  // UpperLimitBaselineRiseMin\n  // LowerLimitGapMin\n  // LowerLimitBaselineDropMin\n  // StackTopShiftUp\n  // StackTopDisplayStyleShiftUp\n  //\n  // StackBottomShiftDown\n  // StackBottomDisplayStyleShiftDown\n  // StackGapMin\n  // StackDisplayStyleGapMin\n  // StretchStackTopShiftUp\n  // StretchStackBottomShiftDown\n  // StretchStackGapAboveMin\n  // StretchStackGapBelowMin\n  // FractionNumeratorShiftUp\n  // FractionNumeratorDisplayStyleShiftUp\n  //\n  // FractionDenominatorShiftDown\n  // FractionDenominatorDisplayStyleShiftDown\n  // FractionNumeratorGapMin\n  // FractionNumDisplayStyleGapMin\n  // FractionRuleThickness\n  // FractionDenominatorGapMin\n  // FractionDenomDisplayStyleGapMin\n  // SkewedFractionHorizontalGap\n  // SkewedFractionVerticalGap\n  // OverbarVerticalGap\n  //\n  // OverbarRuleThickness\n  // OverbarExtraAscender\n  // UnderbarVerticalGap\n  // UnderbarRuleThickness\n  // UnderbarExtraDescender\n  // RadicalVerticalGap\n  // RadicalDisplayStyleVerticalGap\n  // RadicalRuleThickness\n  // RadicalExtraAscender\n  // RadicalKernBeforeDegree\n  //\n  // RadicalKernAfterDegree\n  for (unsigned i = 0; i < static_cast<unsigned>(51); ++i) {\n    if (!ParseMathValueRecord(file, &subtable, data, length)) {\n      return OTS_FAILURE();\n    }\n  }\n\n  // Part 3: uint16 constant\n  // RadicalDegreeBottomRaisePercent\n  if (!subtable.Skip(2)) {\n    return OTS_FAILURE();\n  }\n\n  return true;\n}\n\nbool ParseMathValueRecordSequenceForGlyphs(const ots::OpenTypeFile *file,\n                                           ots::Buffer* subtable,\n                                           const uint8_t *data,\n                                           const size_t length,\n                                           const uint16_t num_glyphs) {\n  // Check the header.\n  uint16_t offset_coverage = 0;\n  uint16_t sequence_count = 0;\n  if (!subtable->ReadU16(&offset_coverage) ||\n      !subtable->ReadU16(&sequence_count)) {\n    return OTS_FAILURE();\n  }\n\n  const unsigned sequence_end = static_cast<unsigned>(2 * 2) +\n      sequence_count * kMathValueRecordSize;\n  if (sequence_end > std::numeric_limits<uint16_t>::max()) {\n    return OTS_FAILURE();\n  }\n\n  // Check coverage table.\n  if (offset_coverage < sequence_end || offset_coverage >= length) {\n    return OTS_FAILURE();\n  }\n  if (!ots::ParseCoverageTable(file, data + offset_coverage,\n                               length - offset_coverage,\n                               num_glyphs, sequence_count)) {\n    return OTS_FAILURE();\n  }\n\n  // Check sequence.\n  for (unsigned i = 0; i < sequence_count; ++i) {\n    if (!ParseMathValueRecord(file, subtable, data, length)) {\n      return OTS_FAILURE();\n    }\n  }\n\n  return true;\n}\n\nbool ParseMathItalicsCorrectionInfoTable(const ots::OpenTypeFile *file,\n                                         const uint8_t *data,\n                                         size_t length,\n                                         const uint16_t num_glyphs) {\n  ots::Buffer subtable(data, length);\n  return ParseMathValueRecordSequenceForGlyphs(file, &subtable, data, length,\n                                               num_glyphs);\n}\n\nbool ParseMathTopAccentAttachmentTable(const ots::OpenTypeFile *file,\n                                       const uint8_t *data,\n                                       size_t length,\n                                       const uint16_t num_glyphs) {\n  ots::Buffer subtable(data, length);\n  return ParseMathValueRecordSequenceForGlyphs(file, &subtable, data, length,\n                                               num_glyphs);\n}\n\nbool ParseMathKernTable(const ots::OpenTypeFile *file,\n                        const uint8_t *data, size_t length) {\n  ots::Buffer subtable(data, length);\n\n  // Check the Height count.\n  uint16_t height_count = 0;\n  if (!subtable.ReadU16(&height_count)) {\n    return OTS_FAILURE();\n  }\n\n  // Check the Correction Heights.\n  for (unsigned i = 0; i < height_count; ++i) {\n    if (!ParseMathValueRecord(file, &subtable, data, length)) {\n      return OTS_FAILURE();\n    }\n  }\n\n  // Check the Kern Values.\n  for (unsigned i = 0; i <= height_count; ++i) {\n    if (!ParseMathValueRecord(file, &subtable, data, length)) {\n      return OTS_FAILURE();\n    }\n  }\n\n  return true;\n}\n\nbool ParseMathKernInfoTable(const ots::OpenTypeFile *file,\n                            const uint8_t *data, size_t length,\n                            const uint16_t num_glyphs) {\n  ots::Buffer subtable(data, length);\n\n  // Check the header.\n  uint16_t offset_coverage = 0;\n  uint16_t sequence_count = 0;\n  if (!subtable.ReadU16(&offset_coverage) ||\n      !subtable.ReadU16(&sequence_count)) {\n    return OTS_FAILURE();\n  }\n\n  const unsigned sequence_end = static_cast<unsigned>(2 * 2) +\n    sequence_count * 4 * 2;\n  if (sequence_end > std::numeric_limits<uint16_t>::max()) {\n    return OTS_FAILURE();\n  }\n\n  // Check coverage table.\n  if (offset_coverage < sequence_end || offset_coverage >= length) {\n    return OTS_FAILURE();\n  }\n  if (!ots::ParseCoverageTable(file, data + offset_coverage, length - offset_coverage,\n                               num_glyphs, sequence_count)) {\n    return OTS_FAILURE();\n  }\n\n  // Check sequence of MathKernInfoRecord\n  for (unsigned i = 0; i < sequence_count; ++i) {\n    // Check TopRight, TopLeft, BottomRight and BottomLeft Math Kern.\n    for (unsigned j = 0; j < 4; ++j) {\n      uint16_t offset_math_kern = 0;\n      if (!subtable.ReadU16(&offset_math_kern)) {\n        return OTS_FAILURE();\n      }\n      if (offset_math_kern) {\n        if (offset_math_kern < sequence_end || offset_math_kern >= length ||\n            !ParseMathKernTable(file, data + offset_math_kern,\n                                length - offset_math_kern)) {\n          return OTS_FAILURE();\n        }\n      }\n    }\n  }\n\n  return true;\n}\n\nbool ParseMathGlyphInfoTable(const ots::OpenTypeFile *file,\n                             const uint8_t *data, size_t length,\n                             const uint16_t num_glyphs) {\n  ots::Buffer subtable(data, length);\n\n  // Check Header.\n  uint16_t offset_math_italics_correction_info = 0;\n  uint16_t offset_math_top_accent_attachment = 0;\n  uint16_t offset_extended_shaped_coverage = 0;\n  uint16_t offset_math_kern_info = 0;\n  if (!subtable.ReadU16(&offset_math_italics_correction_info) ||\n      !subtable.ReadU16(&offset_math_top_accent_attachment) ||\n      !subtable.ReadU16(&offset_extended_shaped_coverage) ||\n      !subtable.ReadU16(&offset_math_kern_info)) {\n    return OTS_FAILURE();\n  }\n\n  // Check subtables.\n  // The specification does not say whether the offsets for\n  // MathItalicsCorrectionInfo, MathTopAccentAttachment and MathKernInfo may\n  // be NULL, but that's the case in some fonts (e.g STIX) so we accept that.\n  if (offset_math_italics_correction_info) {\n    if (offset_math_italics_correction_info >= length ||\n        offset_math_italics_correction_info < kMathGlyphInfoHeaderSize ||\n        !ParseMathItalicsCorrectionInfoTable(\n            file, data + offset_math_italics_correction_info,\n            length - offset_math_italics_correction_info,\n            num_glyphs)) {\n      return OTS_FAILURE();\n    }\n  }\n  if (offset_math_top_accent_attachment) {\n    if (offset_math_top_accent_attachment >= length ||\n        offset_math_top_accent_attachment < kMathGlyphInfoHeaderSize ||\n        !ParseMathTopAccentAttachmentTable(file, data +\n                                           offset_math_top_accent_attachment,\n                                           length -\n                                           offset_math_top_accent_attachment,\n                                           num_glyphs)) {\n      return OTS_FAILURE();\n    }\n  }\n  if (offset_extended_shaped_coverage) {\n    if (offset_extended_shaped_coverage >= length ||\n        offset_extended_shaped_coverage < kMathGlyphInfoHeaderSize ||\n        !ots::ParseCoverageTable(file, data + offset_extended_shaped_coverage,\n                                 length - offset_extended_shaped_coverage,\n                                 num_glyphs)) {\n      return OTS_FAILURE();\n    }\n  }\n  if (offset_math_kern_info) {\n    if (offset_math_kern_info >= length ||\n        offset_math_kern_info < kMathGlyphInfoHeaderSize ||\n        !ParseMathKernInfoTable(file, data + offset_math_kern_info,\n                                length - offset_math_kern_info, num_glyphs)) {\n      return OTS_FAILURE();\n    }\n  }\n\n  return true;\n}\n\nbool ParseGlyphAssemblyTable(const ots::OpenTypeFile *file,\n                             const uint8_t *data,\n                             size_t length, const uint16_t num_glyphs) {\n  ots::Buffer subtable(data, length);\n\n  // Check the header.\n  uint16_t part_count = 0;\n  if (!ParseMathValueRecord(file, &subtable, data, length) ||\n      !subtable.ReadU16(&part_count)) {\n    return OTS_FAILURE();\n  }\n\n  const unsigned sequence_end = kMathValueRecordSize +\n    static_cast<unsigned>(2) + part_count * kGlyphPartRecordSize;\n  if (sequence_end > std::numeric_limits<uint16_t>::max()) {\n    return OTS_FAILURE();\n  }\n\n  // Check the sequence of GlyphPartRecord.\n  for (unsigned i = 0; i < part_count; ++i) {\n    uint16_t glyph = 0;\n    uint16_t part_flags = 0;\n    if (!subtable.ReadU16(&glyph) ||\n        !subtable.Skip(2 * 3) ||\n        !subtable.ReadU16(&part_flags)) {\n      return OTS_FAILURE();\n    }\n    if (glyph >= num_glyphs) {\n      return OTS_FAILURE_MSG(\"bad glyph ID: %u\", glyph);\n    }\n    if (part_flags & ~0x00000001) {\n      return OTS_FAILURE_MSG(\"unknown part flag: %u\", part_flags);\n    }\n  }\n\n  return true;\n}\n\nbool ParseMathGlyphConstructionTable(const ots::OpenTypeFile *file,\n                                     const uint8_t *data,\n                                     size_t length, const uint16_t num_glyphs) {\n  ots::Buffer subtable(data, length);\n\n  // Check the header.\n  uint16_t offset_glyph_assembly = 0;\n  uint16_t variant_count = 0;\n  if (!subtable.ReadU16(&offset_glyph_assembly) ||\n      !subtable.ReadU16(&variant_count)) {\n    return OTS_FAILURE();\n  }\n\n  const unsigned sequence_end = static_cast<unsigned>(2 * 2) +\n    variant_count * 2 * 2;\n  if (sequence_end > std::numeric_limits<uint16_t>::max()) {\n    return OTS_FAILURE();\n  }\n\n  // Check the GlyphAssembly offset.\n  if (offset_glyph_assembly) {\n    if (offset_glyph_assembly >= length ||\n        offset_glyph_assembly < sequence_end) {\n      return OTS_FAILURE();\n    }\n    if (!ParseGlyphAssemblyTable(file, data + offset_glyph_assembly,\n                                 length - offset_glyph_assembly, num_glyphs)) {\n      return OTS_FAILURE();\n    }\n  }\n\n  // Check the sequence of MathGlyphVariantRecord.\n  for (unsigned i = 0; i < variant_count; ++i) {\n    uint16_t glyph = 0;\n    if (!subtable.ReadU16(&glyph) ||\n        !subtable.Skip(2)) {\n      return OTS_FAILURE();\n    }\n    if (glyph >= num_glyphs) {\n      return OTS_FAILURE_MSG(\"bad glyph ID: %u\", glyph);\n    }\n  }\n\n  return true;\n}\n\nbool ParseMathGlyphConstructionSequence(const ots::OpenTypeFile *file,\n                                        ots::Buffer* subtable,\n                                        const uint8_t *data,\n                                        size_t length,\n                                        const uint16_t num_glyphs,\n                                        uint16_t offset_coverage,\n                                        uint16_t glyph_count,\n                                        const unsigned sequence_end) {\n  // Check coverage table.\n  if (offset_coverage < sequence_end || offset_coverage >= length) {\n    return OTS_FAILURE();\n  }\n  if (!ots::ParseCoverageTable(file, data + offset_coverage,\n                               length - offset_coverage,\n                               num_glyphs, glyph_count)) {\n    return OTS_FAILURE();\n  }\n\n  // Check sequence of MathGlyphConstruction.\n  for (unsigned i = 0; i < glyph_count; ++i) {\n      uint16_t offset_glyph_construction = 0;\n      if (!subtable->ReadU16(&offset_glyph_construction)) {\n        return OTS_FAILURE();\n      }\n      if (offset_glyph_construction < sequence_end ||\n          offset_glyph_construction >= length ||\n          !ParseMathGlyphConstructionTable(file, data + offset_glyph_construction,\n                                           length - offset_glyph_construction,\n                                           num_glyphs)) {\n        return OTS_FAILURE();\n      }\n  }\n\n  return true;\n}\n\nbool ParseMathVariantsTable(const ots::OpenTypeFile *file,\n                            const uint8_t *data,\n                            size_t length, const uint16_t num_glyphs) {\n  ots::Buffer subtable(data, length);\n\n  // Check the header.\n  uint16_t offset_vert_glyph_coverage = 0;\n  uint16_t offset_horiz_glyph_coverage = 0;\n  uint16_t vert_glyph_count = 0;\n  uint16_t horiz_glyph_count = 0;\n  if (!subtable.Skip(2) ||  // MinConnectorOverlap\n      !subtable.ReadU16(&offset_vert_glyph_coverage) ||\n      !subtable.ReadU16(&offset_horiz_glyph_coverage) ||\n      !subtable.ReadU16(&vert_glyph_count) ||\n      !subtable.ReadU16(&horiz_glyph_count)) {\n    return OTS_FAILURE();\n  }\n\n  const unsigned sequence_end = 5 * 2 + vert_glyph_count * 2 +\n    horiz_glyph_count * 2;\n  if (sequence_end > std::numeric_limits<uint16_t>::max()) {\n    return OTS_FAILURE();\n  }\n\n  if (!ParseMathGlyphConstructionSequence(file, &subtable, data, length, num_glyphs,\n                                          offset_vert_glyph_coverage,\n                                          vert_glyph_count,\n                                          sequence_end) ||\n      !ParseMathGlyphConstructionSequence(file, &subtable, data, length, num_glyphs,\n                                          offset_horiz_glyph_coverage,\n                                          horiz_glyph_count,\n                                          sequence_end)) {\n    return OTS_FAILURE();\n  }\n\n  return true;\n}\n\n}  // namespace\n\n#define DROP_THIS_TABLE(msg_) \\\n  do { \\\n    file->math->data = 0; \\\n    file->math->length = 0; \\\n    OTS_FAILURE_MSG(msg_ \", table discarded\"); \\\n  } while (0)\n\nnamespace ots {\n\nbool ots_math_parse(OpenTypeFile *file, const uint8_t *data, size_t length) {\n  // Grab the number of glyphs in the file from the maxp table to check\n  // GlyphIDs in MATH table.\n  if (!file->maxp) {\n    return OTS_FAILURE();\n  }\n  const uint16_t num_glyphs = file->maxp->num_glyphs;\n\n  Buffer table(data, length);\n\n  OpenTypeMATH* math = new OpenTypeMATH;\n  file->math = math;\n\n  uint32_t version = 0;\n  if (!table.ReadU32(&version)) {\n    return OTS_FAILURE();\n  }\n  if (version != 0x00010000) {\n    DROP_THIS_TABLE(\"bad MATH version\");\n    return true;\n  }\n\n  uint16_t offset_math_constants = 0;\n  uint16_t offset_math_glyph_info = 0;\n  uint16_t offset_math_variants = 0;\n  if (!table.ReadU16(&offset_math_constants) ||\n      !table.ReadU16(&offset_math_glyph_info) ||\n      !table.ReadU16(&offset_math_variants)) {\n    return OTS_FAILURE();\n  }\n\n  if (offset_math_constants >= length ||\n      offset_math_constants < kMathHeaderSize ||\n      offset_math_glyph_info >= length ||\n      offset_math_glyph_info < kMathHeaderSize ||\n      offset_math_variants >= length ||\n      offset_math_variants < kMathHeaderSize) {\n    DROP_THIS_TABLE(\"bad offset in MATH header\");\n    return true;\n  }\n\n  if (!ParseMathConstantsTable(file, data + offset_math_constants,\n                               length - offset_math_constants)) {\n    DROP_THIS_TABLE(\"failed to parse MathConstants table\");\n    return true;\n  }\n  if (!ParseMathGlyphInfoTable(file, data + offset_math_glyph_info,\n                               length - offset_math_glyph_info, num_glyphs)) {\n    DROP_THIS_TABLE(\"failed to parse MathGlyphInfo table\");\n    return true;\n  }\n  if (!ParseMathVariantsTable(file, data + offset_math_variants,\n                              length - offset_math_variants, num_glyphs)) {\n    DROP_THIS_TABLE(\"failed to parse MathVariants table\");\n    return true;\n  }\n\n  math->data = data;\n  math->length = length;\n  return true;\n}\n\nbool ots_math_should_serialise(OpenTypeFile *file) {\n  return file->math != NULL && file->math->data != NULL;\n}\n\nbool ots_math_serialise(OTSStream *out, OpenTypeFile *file) {\n  if (!out->Write(file->math->data, file->math->length)) {\n    return OTS_FAILURE();\n  }\n\n  return true;\n}\n\nvoid ots_math_free(OpenTypeFile *file) {\n  delete file->math;\n}\n\n}  // namespace ots\n\n#undef TABLE_NAME\n#undef DROP_THIS_TABLE\n", "// Copyright (c) 2009 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n#include \"vdmx.h\"\n\n// VDMX - Vertical Device Metrics\n// http://www.microsoft.com/typography/otspec/vdmx.htm\n\n#define TABLE_NAME \"VDMX\"\n\n#define DROP_THIS_TABLE(...) \\\n  do { \\\n    delete file->vdmx; \\\n    file->vdmx = 0; \\\n    OTS_FAILURE_MSG_(file, TABLE_NAME \": \" __VA_ARGS__); \\\n    OTS_FAILURE_MSG(\"Table discarded\"); \\\n  } while (0)\n\nnamespace ots {\n\nbool ots_vdmx_parse(OpenTypeFile *file, const uint8_t *data, size_t length) {\n  Buffer table(data, length);\n  file->vdmx = new OpenTypeVDMX;\n  OpenTypeVDMX * const vdmx = file->vdmx;\n\n  if (!table.ReadU16(&vdmx->version) ||\n      !table.ReadU16(&vdmx->num_recs) ||\n      !table.ReadU16(&vdmx->num_ratios)) {\n    return OTS_FAILURE_MSG(\"Failed to read table header\");\n  }\n\n  if (vdmx->version > 1) {\n    DROP_THIS_TABLE(\"bad version: %u\", vdmx->version);\n    return true;  // continue transcoding\n  }\n\n  vdmx->rat_ranges.reserve(vdmx->num_ratios);\n  for (unsigned i = 0; i < vdmx->num_ratios; ++i) {\n    OpenTypeVDMXRatioRecord rec;\n\n    if (!table.ReadU8(&rec.charset) ||\n        !table.ReadU8(&rec.x_ratio) ||\n        !table.ReadU8(&rec.y_start_ratio) ||\n        !table.ReadU8(&rec.y_end_ratio)) {\n      return OTS_FAILURE_MSG(\"Failed to read ratio header %d\", i);\n    }\n\n    if (rec.charset > 1) {\n      DROP_THIS_TABLE(\"bad charset: %u\", rec.charset);\n      return true;\n    }\n\n    if (rec.y_start_ratio > rec.y_end_ratio) {\n      DROP_THIS_TABLE(\"bad y ratio\");\n      return true;\n    }\n\n    // All values set to zero signal the default grouping to use;\n    // if present, this must be the last Ratio group in the table.\n    if ((i < vdmx->num_ratios - 1u) &&\n        (rec.x_ratio == 0) &&\n        (rec.y_start_ratio == 0) &&\n        (rec.y_end_ratio == 0)) {\n      // workaround for fonts which have 2 or more {0, 0, 0} terminators.\n      DROP_THIS_TABLE(\"superfluous terminator found\");\n      return true;\n    }\n\n    vdmx->rat_ranges.push_back(rec);\n  }\n\n  vdmx->offsets.reserve(vdmx->num_ratios);\n  const size_t current_offset = table.offset();\n  // current_offset is less than (2 bytes * 3) + (4 bytes * USHRT_MAX) = 256k.\n  for (unsigned i = 0; i < vdmx->num_ratios; ++i) {\n    uint16_t offset;\n    if (!table.ReadU16(&offset)) {\n      return OTS_FAILURE_MSG(\"Failed to read ratio offset %d\", i);\n    }\n    if (current_offset + offset >= length) {  // thus doesn't overflow.\n      return OTS_FAILURE_MSG(\"Bad ratio offset %d for ration %d\", offset, i);\n    }\n\n    vdmx->offsets.push_back(offset);\n  }\n\n  vdmx->groups.reserve(vdmx->num_recs);\n  for (unsigned i = 0; i < vdmx->num_recs; ++i) {\n    OpenTypeVDMXGroup group;\n    if (!table.ReadU16(&group.recs) ||\n        !table.ReadU8(&group.startsz) ||\n        !table.ReadU8(&group.endsz)) {\n      return OTS_FAILURE_MSG(\"Failed to read record header %d\", i);\n    }\n    group.entries.reserve(group.recs);\n    for (unsigned j = 0; j < group.recs; ++j) {\n      OpenTypeVDMXVTable vt;\n      if (!table.ReadU16(&vt.y_pel_height) ||\n          !table.ReadS16(&vt.y_max) ||\n          !table.ReadS16(&vt.y_min)) {\n        return OTS_FAILURE_MSG(\"Failed to read reacord %d group %d\", i, j);\n      }\n      if (vt.y_max < vt.y_min) {\n        DROP_THIS_TABLE(\"bad y min/max\");\n        return true;\n      }\n\n      // This table must appear in sorted order (sorted by yPelHeight),\n      // but need not be continuous.\n      if ((j != 0) && (group.entries[j - 1].y_pel_height >= vt.y_pel_height)) {\n        DROP_THIS_TABLE(\"the table is not sorted\");\n        return true;\n      }\n\n      group.entries.push_back(vt);\n    }\n    vdmx->groups.push_back(group);\n  }\n\n  return true;\n}\n\nbool ots_vdmx_should_serialise(OpenTypeFile *file) {\n  if (!file->glyf) return false;  // this table is not for CFF fonts.\n  return file->vdmx != NULL;\n}\n\nbool ots_vdmx_serialise(OTSStream *out, OpenTypeFile *file) {\n  OpenTypeVDMX * const vdmx = file->vdmx;\n\n  if (!out->WriteU16(vdmx->version) ||\n      !out->WriteU16(vdmx->num_recs) ||\n      !out->WriteU16(vdmx->num_ratios)) {\n    return OTS_FAILURE_MSG(\"Failed to write table header\");\n  }\n\n  for (unsigned i = 0; i < vdmx->rat_ranges.size(); ++i) {\n    const OpenTypeVDMXRatioRecord& rec = vdmx->rat_ranges[i];\n    if (!out->Write(&rec.charset, 1) ||\n        !out->Write(&rec.x_ratio, 1) ||\n        !out->Write(&rec.y_start_ratio, 1) ||\n        !out->Write(&rec.y_end_ratio, 1)) {\n      return OTS_FAILURE_MSG(\"Failed to write ratio %d\", i);\n    }\n  }\n\n  for (unsigned i = 0; i < vdmx->offsets.size(); ++i) {\n    if (!out->WriteU16(vdmx->offsets[i])) {\n      return OTS_FAILURE_MSG(\"Failed to write ratio offset %d\", i);\n    }\n  }\n\n  for (unsigned i = 0; i < vdmx->groups.size(); ++i) {\n    const OpenTypeVDMXGroup& group = vdmx->groups[i];\n    if (!out->WriteU16(group.recs) ||\n        !out->Write(&group.startsz, 1) ||\n        !out->Write(&group.endsz, 1)) {\n      return OTS_FAILURE_MSG(\"Failed to write group %d\", i);\n    }\n    for (unsigned j = 0; j < group.entries.size(); ++j) {\n      const OpenTypeVDMXVTable& vt = group.entries[j];\n      if (!out->WriteU16(vt.y_pel_height) ||\n          !out->WriteS16(vt.y_max) ||\n          !out->WriteS16(vt.y_min)) {\n        return OTS_FAILURE_MSG(\"Failed to write group %d entry %d\", i, j);\n      }\n    }\n  }\n\n  return true;\n}\n\nvoid ots_vdmx_free(OpenTypeFile *file) {\n  delete file->vdmx;\n}\n\n}  // namespace ots\n\n#undef TABLE_NAME\n#undef DROP_THIS_TABLE\n", "// Copyright (c) 2009 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n#include \"vorg.h\"\n\n#include <vector>\n\n// VORG - Vertical Origin Table\n// http://www.microsoft.com/typography/otspec/vorg.htm\n\n#define TABLE_NAME \"VORG\"\n\n#define DROP_THIS_TABLE(...) \\\n  do { \\\n    delete file->vorg; \\\n    file->vorg = 0; \\\n    OTS_FAILURE_MSG_(file, TABLE_NAME \": \" __VA_ARGS__); \\\n    OTS_FAILURE_MSG(\"Table discarded\"); \\\n  } while (0)\n\nnamespace ots {\n\nbool ots_vorg_parse(OpenTypeFile *file, const uint8_t *data, size_t length) {\n  Buffer table(data, length);\n  file->vorg = new OpenTypeVORG;\n  OpenTypeVORG * const vorg = file->vorg;\n\n  uint16_t num_recs;\n  if (!table.ReadU16(&vorg->major_version) ||\n      !table.ReadU16(&vorg->minor_version) ||\n      !table.ReadS16(&vorg->default_vert_origin_y) ||\n      !table.ReadU16(&num_recs)) {\n    return OTS_FAILURE_MSG(\"Failed to read header\");\n  }\n  if (vorg->major_version != 1) {\n    DROP_THIS_TABLE(\"bad major version: %u\", vorg->major_version);\n    return true;\n  }\n  if (vorg->minor_version != 0) {\n    DROP_THIS_TABLE(\"bad minor version: %u\", vorg->minor_version);\n    return true;\n  }\n\n  // num_recs might be zero (e.g., DFHSMinchoPro5-W3-Demo.otf).\n  if (!num_recs) {\n    return true;\n  }\n\n  uint16_t last_glyph_index = 0;\n  vorg->metrics.reserve(num_recs);\n  for (unsigned i = 0; i < num_recs; ++i) {\n    OpenTypeVORGMetrics rec;\n\n    if (!table.ReadU16(&rec.glyph_index) ||\n        !table.ReadS16(&rec.vert_origin_y)) {\n      return OTS_FAILURE_MSG(\"Failed to read record %d\", i);\n    }\n    if ((i != 0) && (rec.glyph_index <= last_glyph_index)) {\n      DROP_THIS_TABLE(\"the table is not sorted\");\n      return true;\n    }\n    last_glyph_index = rec.glyph_index;\n\n    vorg->metrics.push_back(rec);\n  }\n\n  return true;\n}\n\nbool ots_vorg_should_serialise(OpenTypeFile *file) {\n  if (!file->cff) return false;  // this table is not for fonts with TT glyphs.\n  return file->vorg != NULL;\n}\n\nbool ots_vorg_serialise(OTSStream *out, OpenTypeFile *file) {\n  OpenTypeVORG * const vorg = file->vorg;\n  \n  const uint16_t num_metrics = static_cast<uint16_t>(vorg->metrics.size());\n  if (num_metrics != vorg->metrics.size() ||\n      !out->WriteU16(vorg->major_version) ||\n      !out->WriteU16(vorg->minor_version) ||\n      !out->WriteS16(vorg->default_vert_origin_y) ||\n      !out->WriteU16(num_metrics)) {\n    return OTS_FAILURE_MSG(\"Failed to write table header\");\n  }\n\n  for (uint16_t i = 0; i < num_metrics; ++i) {\n    const OpenTypeVORGMetrics& rec = vorg->metrics[i];\n    if (!out->WriteU16(rec.glyph_index) ||\n        !out->WriteS16(rec.vert_origin_y)) {\n      return OTS_FAILURE_MSG(\"Failed to write record %d\", i);\n    }\n  }\n\n  return true;\n}\n\nvoid ots_vorg_free(OpenTypeFile *file) {\n  delete file->vorg;\n}\n\n}  // namespace ots\n\n#undef TABLE_NAME\n#undef DROP_THIS_TABLE\n"], "fixing_code": ["// Copyright (c) 2009 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n#include \"gasp.h\"\n\n// gasp - Grid-fitting And Scan-conversion Procedure\n// http://www.microsoft.com/typography/otspec/gasp.htm\n\n#define TABLE_NAME \"gasp\"\n\n#define DROP_THIS_TABLE(...) \\\n  do { \\\n    OTS_FAILURE_MSG_(file, TABLE_NAME \": \" __VA_ARGS__); \\\n    OTS_FAILURE_MSG(\"Table discarded\"); \\\n    delete file->gasp; \\\n    file->gasp = 0; \\\n  } while (0)\n\nnamespace ots {\n\nbool ots_gasp_parse(OpenTypeFile *file, const uint8_t *data, size_t length) {\n  Buffer table(data, length);\n\n  OpenTypeGASP *gasp = new OpenTypeGASP;\n  file->gasp = gasp;\n\n  uint16_t num_ranges = 0;\n  if (!table.ReadU16(&gasp->version) ||\n      !table.ReadU16(&num_ranges)) {\n    return OTS_FAILURE_MSG(\"Failed to read table header\");\n  }\n\n  if (gasp->version > 1) {\n    // Lots of Linux fonts have bad version numbers...\n    DROP_THIS_TABLE(\"bad version: %u\", gasp->version);\n    return true;\n  }\n\n  if (num_ranges == 0) {\n    DROP_THIS_TABLE(\"num_ranges is zero\");\n    return true;\n  }\n\n  gasp->gasp_ranges.reserve(num_ranges);\n  for (unsigned i = 0; i < num_ranges; ++i) {\n    uint16_t max_ppem = 0;\n    uint16_t behavior = 0;\n    if (!table.ReadU16(&max_ppem) ||\n        !table.ReadU16(&behavior)) {\n      return OTS_FAILURE_MSG(\"Failed to read subrange %d\", i);\n    }\n    if ((i > 0) && (gasp->gasp_ranges[i - 1].first >= max_ppem)) {\n      // The records in the gaspRange[] array must be sorted in order of\n      // increasing rangeMaxPPEM value.\n      DROP_THIS_TABLE(\"ranges are not sorted\");\n      return true;\n    }\n    if ((i == num_ranges - 1u) &&  // never underflow.\n        (max_ppem != 0xffffu)) {\n      DROP_THIS_TABLE(\"The last record should be 0xFFFF as a sentinel value \"\n                  \"for rangeMaxPPEM\");\n      return true;\n    }\n\n    if (behavior >> 8) {\n      OTS_WARNING(\"undefined bits are used: %x\", behavior);\n      // mask undefined bits.\n      behavior &= 0x000fu;\n    }\n\n    if (gasp->version == 0 && (behavior >> 2) != 0) {\n      OTS_WARNING(\"changed the version number to 1\");\n      gasp->version = 1;\n    }\n\n    gasp->gasp_ranges.push_back(std::make_pair(max_ppem, behavior));\n  }\n\n  return true;\n}\n\nbool ots_gasp_should_serialise(OpenTypeFile *file) {\n  return file->gasp != NULL;\n}\n\nbool ots_gasp_serialise(OTSStream *out, OpenTypeFile *file) {\n  const OpenTypeGASP *gasp = file->gasp;\n\n  const uint16_t num_ranges = static_cast<uint16_t>(gasp->gasp_ranges.size());\n  if (num_ranges != gasp->gasp_ranges.size() ||\n      !out->WriteU16(gasp->version) ||\n      !out->WriteU16(num_ranges)) {\n    return OTS_FAILURE_MSG(\"failed to write gasp header\");\n  }\n\n  for (uint16_t i = 0; i < num_ranges; ++i) {\n    if (!out->WriteU16(gasp->gasp_ranges[i].first) ||\n        !out->WriteU16(gasp->gasp_ranges[i].second)) {\n      return OTS_FAILURE_MSG(\"Failed to write gasp subtable %d\", i);\n    }\n  }\n\n  return true;\n}\n\nvoid ots_gasp_free(OpenTypeFile *file) {\n  delete file->gasp;\n}\n\n}  // namespace ots\n\n#undef TABLE_NAME\n#undef DROP_THIS_TABLE\n", "// Copyright (c) 2011 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n#include \"gdef.h\"\n\n#include <limits>\n#include <vector>\n\n#include \"gpos.h\"\n#include \"gsub.h\"\n#include \"layout.h\"\n#include \"maxp.h\"\n\n// GDEF - The Glyph Definition Table\n// http://www.microsoft.com/typography/otspec/gdef.htm\n\n#define TABLE_NAME \"GDEF\"\n\nnamespace {\n\n// The maximum class value in class definition tables.\nconst uint16_t kMaxClassDefValue = 0xFFFF;\n// The maximum class value in the glyph class definision table.\nconst uint16_t kMaxGlyphClassDefValue = 4;\n// The maximum format number of caret value tables.\n// We don't support format 3 for now. See the comment in\n// ParseLigCaretListTable() for the reason.\nconst uint16_t kMaxCaretValueFormat = 2;\n\nbool ParseGlyphClassDefTable(ots::OpenTypeFile *file, const uint8_t *data,\n                             size_t length, const uint16_t num_glyphs) {\n  return ots::ParseClassDefTable(file, data, length, num_glyphs,\n                                 kMaxGlyphClassDefValue);\n}\n\nbool ParseAttachListTable(ots::OpenTypeFile *file, const uint8_t *data,\n                          size_t length, const uint16_t num_glyphs) {\n  ots::Buffer subtable(data, length);\n\n  uint16_t offset_coverage = 0;\n  uint16_t glyph_count = 0;\n  if (!subtable.ReadU16(&offset_coverage) ||\n      !subtable.ReadU16(&glyph_count)) {\n    return OTS_FAILURE_MSG(\"Failed to read gdef header\");\n  }\n  const unsigned attach_points_end =\n      2 * static_cast<unsigned>(glyph_count) + 4;\n  if (attach_points_end > std::numeric_limits<uint16_t>::max()) {\n    return OTS_FAILURE_MSG(\"Bad glyph count in gdef\");\n  }\n  if (offset_coverage == 0 || offset_coverage >= length ||\n      offset_coverage < attach_points_end) {\n    return OTS_FAILURE_MSG(\"Bad coverage offset %d\", offset_coverage);\n  }\n  if (glyph_count > num_glyphs) {\n    return OTS_FAILURE_MSG(\"Bad glyph count %u\", glyph_count);\n  }\n\n  std::vector<uint16_t> attach_points;\n  attach_points.resize(glyph_count);\n  for (unsigned i = 0; i < glyph_count; ++i) {\n    if (!subtable.ReadU16(&attach_points[i])) {\n      return OTS_FAILURE_MSG(\"Can't read attachment point %d\", i);\n    }\n    if (attach_points[i] >= length ||\n        attach_points[i] < attach_points_end) {\n      return OTS_FAILURE_MSG(\"Bad attachment point %d of %d\", i, attach_points[i]);\n    }\n  }\n\n  // Parse coverage table\n  if (!ots::ParseCoverageTable(file, data + offset_coverage,\n                               length - offset_coverage, num_glyphs)) {\n    return OTS_FAILURE_MSG(\"Bad coverage table\");\n  }\n\n  // Parse attach point table\n  for (unsigned i = 0; i < attach_points.size(); ++i) {\n    subtable.set_offset(attach_points[i]);\n    uint16_t point_count = 0;\n    if (!subtable.ReadU16(&point_count)) {\n      return OTS_FAILURE_MSG(\"Can't read point count %d\", i);\n    }\n    if (point_count == 0) {\n      return OTS_FAILURE_MSG(\"zero point count %d\", i);\n    }\n    uint16_t last_point_index = 0;\n    uint16_t point_index = 0;\n    for (unsigned j = 0; j < point_count; ++j) {\n      if (!subtable.ReadU16(&point_index)) {\n        return OTS_FAILURE_MSG(\"Can't read point index %d in point %d\", j, i);\n      }\n      // Contour point indeces are in increasing numerical order\n      if (last_point_index != 0 && last_point_index >= point_index) {\n        return OTS_FAILURE_MSG(\"bad contour indeces: %u >= %u\",\n                    last_point_index, point_index);\n      }\n      last_point_index = point_index;\n    }\n  }\n  return true;\n}\n\nbool ParseLigCaretListTable(ots::OpenTypeFile *file, const uint8_t *data,\n                            size_t length, const uint16_t num_glyphs) {\n  ots::Buffer subtable(data, length);\n  uint16_t offset_coverage = 0;\n  uint16_t lig_glyph_count = 0;\n  if (!subtable.ReadU16(&offset_coverage) ||\n      !subtable.ReadU16(&lig_glyph_count)) {\n    return OTS_FAILURE_MSG(\"Can't read caret structure\");\n  }\n  const unsigned lig_glyphs_end =\n      2 * static_cast<unsigned>(lig_glyph_count) + 4;\n  if (lig_glyphs_end > std::numeric_limits<uint16_t>::max()) {\n    return OTS_FAILURE_MSG(\"Bad caret structure\");\n  }\n  if (offset_coverage == 0 || offset_coverage >= length ||\n      offset_coverage < lig_glyphs_end) {\n    return OTS_FAILURE_MSG(\"Bad caret coverate offset %d\", offset_coverage);\n  }\n  if (lig_glyph_count > num_glyphs) {\n    return OTS_FAILURE_MSG(\"bad ligature glyph count: %u\", lig_glyph_count);\n  }\n\n  std::vector<uint16_t> lig_glyphs;\n  lig_glyphs.resize(lig_glyph_count);\n  for (unsigned i = 0; i < lig_glyph_count; ++i) {\n    if (!subtable.ReadU16(&lig_glyphs[i])) {\n      return OTS_FAILURE_MSG(\"Can't read ligature glyph location %d\", i);\n    }\n    if (lig_glyphs[i] >= length || lig_glyphs[i] < lig_glyphs_end) {\n      return OTS_FAILURE_MSG(\"Bad ligature glyph location %d in glyph %d\", lig_glyphs[i], i);\n    }\n  }\n\n  // Parse coverage table\n  if (!ots::ParseCoverageTable(file, data + offset_coverage,\n                               length - offset_coverage, num_glyphs)) {\n    return OTS_FAILURE_MSG(\"Can't parse caret coverage table\");\n  }\n\n  // Parse ligature glyph table\n  for (unsigned i = 0; i < lig_glyphs.size(); ++i) {\n    subtable.set_offset(lig_glyphs[i]);\n    uint16_t caret_count = 0;\n    if (!subtable.ReadU16(&caret_count)) {\n      return OTS_FAILURE_MSG(\"Can't read caret count for glyph %d\", i);\n    }\n    if (caret_count == 0) {\n      return OTS_FAILURE_MSG(\"bad caret value count: %u\", caret_count);\n    }\n\n    std::vector<uint16_t> caret_value_offsets;\n    caret_value_offsets.resize(caret_count);\n    unsigned caret_value_offsets_end = 2 * static_cast<unsigned>(caret_count) + 2;\n    for (unsigned j = 0; j < caret_count; ++j) {\n      if (!subtable.ReadU16(&caret_value_offsets[j])) {\n        return OTS_FAILURE_MSG(\"Can't read caret offset %d for glyph %d\", j, i);\n      }\n      if (caret_value_offsets[j] >= length || caret_value_offsets[j] < caret_value_offsets_end) {\n        return OTS_FAILURE_MSG(\"Bad caret offset %d for caret %d glyph %d\", caret_value_offsets[j], j, i);\n      }\n    }\n\n    // Parse caret values table\n    for (unsigned j = 0; j < caret_count; ++j) {\n      subtable.set_offset(lig_glyphs[i] + caret_value_offsets[j]);\n      uint16_t caret_format = 0;\n      if (!subtable.ReadU16(&caret_format)) {\n        return OTS_FAILURE_MSG(\"Can't read caret values table %d in glyph %d\", j, i);\n      }\n      // TODO(bashi): We only support caret value format 1 and 2 for now\n      // because there are no fonts which contain caret value format 3\n      // as far as we investigated.\n      if (caret_format == 0 || caret_format > kMaxCaretValueFormat) {\n        return OTS_FAILURE_MSG(\"bad caret value format: %u\", caret_format);\n      }\n      // CaretValueFormats contain a 2-byte field which could be\n      // arbitrary value.\n      if (!subtable.Skip(2)) {\n        return OTS_FAILURE_MSG(\"Bad caret value table structure %d in glyph %d\", j, i);\n      }\n    }\n  }\n  return true;\n}\n\nbool ParseMarkAttachClassDefTable(ots::OpenTypeFile *file, const uint8_t *data,\n                                  size_t length, const uint16_t num_glyphs) {\n  return ots::ParseClassDefTable(file, data, length, num_glyphs, kMaxClassDefValue);\n}\n\nbool ParseMarkGlyphSetsDefTable(ots::OpenTypeFile *file, const uint8_t *data,\n                                size_t length, const uint16_t num_glyphs) {\n  ots::Buffer subtable(data, length);\n  uint16_t format = 0;\n  uint16_t mark_set_count = 0;\n  if (!subtable.ReadU16(&format) ||\n      !subtable.ReadU16(&mark_set_count)) {\n    return OTS_FAILURE_MSG(\"Can' read mark glyph table structure\");\n  }\n  if (format != 1) {\n    return OTS_FAILURE_MSG(\"bad mark glyph set table format: %u\", format);\n  }\n\n  const unsigned mark_sets_end = 2 * static_cast<unsigned>(mark_set_count) + 4;\n  if (mark_sets_end > std::numeric_limits<uint16_t>::max()) {\n    return OTS_FAILURE_MSG(\"Bad mark_set %d\", mark_sets_end);\n  }\n  for (unsigned i = 0; i < mark_set_count; ++i) {\n    uint32_t offset_coverage = 0;\n    if (!subtable.ReadU32(&offset_coverage)) {\n      return OTS_FAILURE_MSG(\"Can't read covrage location for mark set %d\", i);\n    }\n    if (offset_coverage >= length ||\n        offset_coverage < mark_sets_end) {\n      return OTS_FAILURE_MSG(\"Bad coverage location %d for mark set %d\", offset_coverage, i);\n    }\n    if (!ots::ParseCoverageTable(file, data + offset_coverage,\n                                 length - offset_coverage, num_glyphs)) {\n      return OTS_FAILURE_MSG(\"Failed to parse coverage table for mark set %d\", i);\n    }\n  }\n  file->gdef->num_mark_glyph_sets = mark_set_count;\n  return true;\n}\n\n}  // namespace\n\n#define DROP_THIS_TABLE(msg_) \\\n  do { \\\n    OTS_FAILURE_MSG(msg_ \", table discarded\"); \\\n    file->gdef->data = 0; \\\n    file->gdef->length = 0; \\\n  } while (0)\n\nnamespace ots {\n\nbool ots_gdef_parse(OpenTypeFile *file, const uint8_t *data, size_t length) {\n  // Grab the number of glyphs in the file from the maxp table to check\n  // GlyphIDs in GDEF table.\n  if (!file->maxp) {\n    return OTS_FAILURE_MSG(\"No maxp table in font, needed by GDEF\");\n  }\n  const uint16_t num_glyphs = file->maxp->num_glyphs;\n\n  Buffer table(data, length);\n\n  OpenTypeGDEF *gdef = new OpenTypeGDEF;\n  file->gdef = gdef;\n\n  uint32_t version = 0;\n  if (!table.ReadU32(&version)) {\n    DROP_THIS_TABLE(\"Incomplete table\");\n    return true;\n  }\n  if (version < 0x00010000 || version == 0x00010001) {\n    DROP_THIS_TABLE(\"Bad version\");\n    return true;\n  }\n\n  if (version >= 0x00010002) {\n    gdef->version_2 = true;\n  }\n\n  uint16_t offset_glyph_class_def = 0;\n  uint16_t offset_attach_list = 0;\n  uint16_t offset_lig_caret_list = 0;\n  uint16_t offset_mark_attach_class_def = 0;\n  if (!table.ReadU16(&offset_glyph_class_def) ||\n      !table.ReadU16(&offset_attach_list) ||\n      !table.ReadU16(&offset_lig_caret_list) ||\n      !table.ReadU16(&offset_mark_attach_class_def)) {\n    DROP_THIS_TABLE(\"Incomplete table\");\n    return true;\n  }\n  uint16_t offset_mark_glyph_sets_def = 0;\n  if (gdef->version_2) {\n    if (!table.ReadU16(&offset_mark_glyph_sets_def)) {\n      DROP_THIS_TABLE(\"Incomplete table\");\n      return true;\n    }\n  }\n\n  unsigned gdef_header_end = 4 + 4 * 2;\n  if (gdef->version_2)\n    gdef_header_end += 2;\n\n  // Parse subtables\n  if (offset_glyph_class_def) {\n    if (offset_glyph_class_def >= length ||\n        offset_glyph_class_def < gdef_header_end) {\n      DROP_THIS_TABLE(\"Invalid offset to glyph classes\");\n      return true;\n    }\n    if (!ParseGlyphClassDefTable(file, data + offset_glyph_class_def,\n                                 length - offset_glyph_class_def,\n                                 num_glyphs)) {\n      DROP_THIS_TABLE(\"Invalid glyph classes\");\n      return true;\n    }\n    gdef->has_glyph_class_def = true;\n  }\n\n  if (offset_attach_list) {\n    if (offset_attach_list >= length ||\n        offset_attach_list < gdef_header_end) {\n      DROP_THIS_TABLE(\"Invalid offset to attachment list\");\n      return true;\n    }\n    if (!ParseAttachListTable(file, data + offset_attach_list,\n                              length - offset_attach_list,\n                              num_glyphs)) {\n      DROP_THIS_TABLE(\"Invalid attachment list\");\n      return true;\n    }\n  }\n\n  if (offset_lig_caret_list) {\n    if (offset_lig_caret_list >= length ||\n        offset_lig_caret_list < gdef_header_end) {\n      DROP_THIS_TABLE(\"Invalid offset to ligature caret list\");\n      return true;\n    }\n    if (!ParseLigCaretListTable(file, data + offset_lig_caret_list,\n                              length - offset_lig_caret_list,\n                              num_glyphs)) {\n      DROP_THIS_TABLE(\"Invalid ligature caret list\");\n      return true;\n    }\n  }\n\n  if (offset_mark_attach_class_def) {\n    if (offset_mark_attach_class_def >= length ||\n        offset_mark_attach_class_def < gdef_header_end) {\n      return OTS_FAILURE_MSG(\"Invalid offset to mark attachment list\");\n    }\n    if (!ParseMarkAttachClassDefTable(file,\n                                      data + offset_mark_attach_class_def,\n                                      length - offset_mark_attach_class_def,\n                                      num_glyphs)) {\n      DROP_THIS_TABLE(\"Invalid mark attachment list\");\n      return true;\n    }\n    gdef->has_mark_attachment_class_def = true;\n  }\n\n  if (offset_mark_glyph_sets_def) {\n    if (offset_mark_glyph_sets_def >= length ||\n        offset_mark_glyph_sets_def < gdef_header_end) {\n      return OTS_FAILURE_MSG(\"invalid offset to mark glyph sets\");\n    }\n    if (!ParseMarkGlyphSetsDefTable(file,\n                                    data + offset_mark_glyph_sets_def,\n                                    length - offset_mark_glyph_sets_def,\n                                    num_glyphs)) {\n      DROP_THIS_TABLE(\"Invalid mark glyph sets\");\n      return true;\n    }\n    gdef->has_mark_glyph_sets_def = true;\n  }\n  gdef->data = data;\n  gdef->length = length;\n  return true;\n}\n\nbool ots_gdef_should_serialise(OpenTypeFile *file) {\n  return file->gdef != NULL && file->gdef->data != NULL;\n}\n\nbool ots_gdef_serialise(OTSStream *out, OpenTypeFile *file) {\n  if (!out->Write(file->gdef->data, file->gdef->length)) {\n    return OTS_FAILURE_MSG(\"Failed to write GDEF table\");\n  }\n\n  return true;\n}\n\nvoid ots_gdef_free(OpenTypeFile *file) {\n  delete file->gdef;\n}\n\n}  // namespace ots\n\n#undef TABLE_NAME\n#undef DROP_THIS_TABLE\n", "// Copyright (c) 2011 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n#include \"gpos.h\"\n\n#include <limits>\n#include <vector>\n\n#include \"layout.h\"\n#include \"maxp.h\"\n\n// GPOS - The Glyph Positioning Table\n// http://www.microsoft.com/typography/otspec/gpos.htm\n\n#define TABLE_NAME \"GPOS\"\n\nnamespace {\n\nenum GPOS_TYPE {\n  GPOS_TYPE_SINGLE_ADJUSTMENT = 1,\n  GPOS_TYPE_PAIR_ADJUSTMENT = 2,\n  GPOS_TYPE_CURSIVE_ATTACHMENT = 3,\n  GPOS_TYPE_MARK_TO_BASE_ATTACHMENT = 4,\n  GPOS_TYPE_MARK_TO_LIGATURE_ATTACHMENT = 5,\n  GPOS_TYPE_MARK_TO_MARK_ATTACHMENT = 6,\n  GPOS_TYPE_CONTEXT_POSITIONING = 7,\n  GPOS_TYPE_CHAINED_CONTEXT_POSITIONING = 8,\n  GPOS_TYPE_EXTENSION_POSITIONING = 9,\n  GPOS_TYPE_RESERVED = 10\n};\n\n// The size of gpos header.\nconst unsigned kGposHeaderSize = 10;\n// The maximum format number for anchor tables.\nconst uint16_t kMaxAnchorFormat = 3;\n// The maximum number of class value.\nconst uint16_t kMaxClassDefValue = 0xFFFF;\n\n// Lookup type parsers.\nbool ParseSingleAdjustment(const ots::OpenTypeFile *file,\n                           const uint8_t *data, const size_t length);\nbool ParsePairAdjustment(const ots::OpenTypeFile *file,\n                         const uint8_t *data, const size_t length);\nbool ParseCursiveAttachment(const ots::OpenTypeFile *file,\n                            const uint8_t *data, const size_t length);\nbool ParseMarkToBaseAttachment(const ots::OpenTypeFile *file,\n                               const uint8_t *data, const size_t length);\nbool ParseMarkToLigatureAttachment(const ots::OpenTypeFile *file,\n                                   const uint8_t *data, const size_t length);\nbool ParseMarkToMarkAttachment(const ots::OpenTypeFile *file,\n                               const uint8_t *data, const size_t length);\nbool ParseContextPositioning(const ots::OpenTypeFile *file,\n                             const uint8_t *data, const size_t length);\nbool ParseChainedContextPositioning(const ots::OpenTypeFile *file,\n                                    const uint8_t *data, const size_t length);\nbool ParseExtensionPositioning(const ots::OpenTypeFile *file,\n                               const uint8_t *data, const size_t length);\n\nconst ots::LookupSubtableParser::TypeParser kGposTypeParsers[] = {\n  {GPOS_TYPE_SINGLE_ADJUSTMENT, ParseSingleAdjustment},\n  {GPOS_TYPE_PAIR_ADJUSTMENT, ParsePairAdjustment},\n  {GPOS_TYPE_CURSIVE_ATTACHMENT, ParseCursiveAttachment},\n  {GPOS_TYPE_MARK_TO_BASE_ATTACHMENT, ParseMarkToBaseAttachment},\n  {GPOS_TYPE_MARK_TO_LIGATURE_ATTACHMENT, ParseMarkToLigatureAttachment},\n  {GPOS_TYPE_MARK_TO_MARK_ATTACHMENT, ParseMarkToMarkAttachment},\n  {GPOS_TYPE_CONTEXT_POSITIONING, ParseContextPositioning},\n  {GPOS_TYPE_CHAINED_CONTEXT_POSITIONING, ParseChainedContextPositioning},\n  {GPOS_TYPE_EXTENSION_POSITIONING, ParseExtensionPositioning}\n};\n\nconst ots::LookupSubtableParser kGposLookupSubtableParser = {\n  arraysize(kGposTypeParsers),\n  GPOS_TYPE_EXTENSION_POSITIONING, kGposTypeParsers\n};\n\n// Shared Tables: ValueRecord, Anchor Table, and MarkArray\n\nbool ParseValueRecord(const ots::OpenTypeFile *file,\n                      ots::Buffer* subtable, const uint8_t *data,\n                      const size_t length, const uint16_t value_format) {\n  // Check existence of adjustment fields.\n  for (unsigned i = 0; i < 4; ++i) {\n    if ((value_format >> i) & 0x1) {\n      // Just read the field since these fileds could take an arbitrary values.\n      if (!subtable->Skip(2)) {\n        return OTS_FAILURE_MSG(\"Failed to read value reacord component\");\n      }\n    }\n  }\n\n  // Check existence of offsets to device table.\n  for (unsigned i = 0; i < 4; ++i) {\n    if ((value_format >> (i + 4)) & 0x1) {\n      uint16_t offset = 0;\n      if (!subtable->ReadU16(&offset)) {\n        return OTS_FAILURE_MSG(\"Failed to read value record offset\");\n      }\n      if (offset) {\n        // TODO(bashi): Is it possible that device tables locate before\n        // this record? No fonts contain such offset AKAIF.\n        if (offset >= length) {\n          return OTS_FAILURE_MSG(\"Value record offset too high %d >= %ld\", offset, length);\n        }\n        if (!ots::ParseDeviceTable(file, data + offset, length - offset)) {\n          return OTS_FAILURE_MSG(\"Failed to parse device table in value record\");\n        }\n      }\n    }\n  }\n  return true;\n}\n\nbool ParseAnchorTable(const ots::OpenTypeFile *file,\n                      const uint8_t *data, const size_t length) {\n  ots::Buffer subtable(data, length);\n\n  uint16_t format = 0;\n  // Read format and skip 2 2-byte fields that could be arbitrary values.\n  if (!subtable.ReadU16(&format) ||\n      !subtable.Skip(4)) {\n    return OTS_FAILURE_MSG(\"Faled to read anchor table\");\n  }\n\n  if (format == 0 || format > kMaxAnchorFormat) {\n    return OTS_FAILURE_MSG(\"Bad Anchor table format %d\", format);\n  }\n\n  // Format 2 and 3 has additional fields.\n  if (format == 2) {\n    // Format 2 provides an index to a glyph contour point, which will take\n    // arbitrary value.\n    uint16_t anchor_point = 0;\n    if (!subtable.ReadU16(&anchor_point)) {\n      return OTS_FAILURE_MSG(\"Failed to read anchor point in format 2 Anchor Table\");\n    }\n  } else if (format == 3) {\n    uint16_t offset_x_device = 0;\n    uint16_t offset_y_device = 0;\n    if (!subtable.ReadU16(&offset_x_device) ||\n        !subtable.ReadU16(&offset_y_device)) {\n      return OTS_FAILURE_MSG(\"Failed to read device table offsets in format 3 anchor table\");\n    }\n    const unsigned format_end = static_cast<unsigned>(10);\n    if (offset_x_device) {\n      if (offset_x_device < format_end || offset_x_device >= length) {\n        return OTS_FAILURE_MSG(\"Bad x device table offset %d\", offset_x_device);\n      }\n      if (!ots::ParseDeviceTable(file, data + offset_x_device,\n                                 length - offset_x_device)) {\n        return OTS_FAILURE_MSG(\"Failed to parse device table in anchor table\");\n      }\n    }\n    if (offset_y_device) {\n      if (offset_y_device < format_end || offset_y_device >= length) {\n        return OTS_FAILURE_MSG(\"Bad y device table offset %d\", offset_y_device);\n      }\n      if (!ots::ParseDeviceTable(file, data + offset_y_device,\n                                 length - offset_y_device)) {\n        return OTS_FAILURE_MSG(\"Failed to parse device table in anchor table\");\n      }\n    }\n  }\n  return true;\n}\n\nbool ParseMarkArrayTable(const ots::OpenTypeFile *file,\n                         const uint8_t *data, const size_t length,\n                         const uint16_t class_count) {\n  ots::Buffer subtable(data, length);\n\n  uint16_t mark_count = 0;\n  if (!subtable.ReadU16(&mark_count)) {\n    return OTS_FAILURE_MSG(\"Can't read mark table length\");\n  }\n\n  // MarkRecord consists of 4-bytes.\n  const unsigned mark_records_end = 4 * static_cast<unsigned>(mark_count) + 2;\n  if (mark_records_end > std::numeric_limits<uint16_t>::max()) {\n    return OTS_FAILURE_MSG(\"Bad mark table length\");\n  }\n  for (unsigned i = 0; i < mark_count; ++i) {\n    uint16_t class_value = 0;\n    uint16_t offset_mark_anchor = 0;\n    if (!subtable.ReadU16(&class_value) ||\n        !subtable.ReadU16(&offset_mark_anchor)) {\n      return OTS_FAILURE_MSG(\"Can't read mark table %d\", i);\n    }\n    // |class_value| may take arbitrary values including 0 here so we don't\n    // check the value.\n    if (offset_mark_anchor < mark_records_end ||\n        offset_mark_anchor >= length) {\n      return OTS_FAILURE_MSG(\"Bad mark anchor offset %d for mark table %d\", offset_mark_anchor, i);\n    }\n    if (!ParseAnchorTable(file, data + offset_mark_anchor,\n                          length - offset_mark_anchor)) {\n      return OTS_FAILURE_MSG(\"Faled to parse anchor table for mark table %d\", i);\n    }\n  }\n\n  return true;\n}\n\n// Lookup Type 1:\n// Single Adjustment Positioning Subtable\nbool ParseSingleAdjustment(const ots::OpenTypeFile *file, const uint8_t *data,\n                           const size_t length) {\n  ots::Buffer subtable(data, length);\n\n  uint16_t format = 0;\n  uint16_t offset_coverage = 0;\n  uint16_t value_format = 0;\n  if (!subtable.ReadU16(&format) ||\n      !subtable.ReadU16(&offset_coverage) ||\n      !subtable.ReadU16(&value_format)) {\n    return OTS_FAILURE_MSG(\"Can't read single adjustment information\");\n  }\n\n  if (format == 1) {\n    // Format 1 exactly one value record.\n    if (!ParseValueRecord(file, &subtable, data, length, value_format)) {\n      return OTS_FAILURE_MSG(\"Failed to parse format 1 single adjustment table\");\n    }\n  } else if (format == 2) {\n    uint16_t value_count = 0;\n    if (!subtable.ReadU16(&value_count)) {\n      return OTS_FAILURE_MSG(\"Failed to parse format 2 single adjustment table\");\n    }\n    for (unsigned i = 0; i < value_count; ++i) {\n      if (!ParseValueRecord(file, &subtable, data, length, value_format)) {\n        return OTS_FAILURE_MSG(\"Failed to parse value record %d in format 2 single adjustment table\", i);\n      }\n    }\n  } else {\n    return OTS_FAILURE_MSG(\"Bad format %d in single adjustment table\", format);\n  }\n\n  if (offset_coverage < subtable.offset() || offset_coverage >= length) {\n    return OTS_FAILURE_MSG(\"Bad coverage offset %d in single adjustment table\", offset_coverage);\n  }\n\n  if (!ots::ParseCoverageTable(file, data + offset_coverage,\n                               length - offset_coverage,\n                               file->maxp->num_glyphs)) {\n    return OTS_FAILURE_MSG(\"Failed to parse coverage table in single adjustment table\");\n  }\n\n  return true;\n}\n\nbool ParsePairSetTable(const ots::OpenTypeFile *file,\n                       const uint8_t *data, const size_t length,\n                       const uint16_t value_format1,\n                       const uint16_t value_format2,\n                       const uint16_t num_glyphs) {\n  ots::Buffer subtable(data, length);\n\n  uint16_t value_count = 0;\n  if (!subtable.ReadU16(&value_count)) {\n    return OTS_FAILURE_MSG(\"Failed to read pair set table structure\");\n  }\n  for (unsigned i = 0; i < value_count; ++i) {\n    // Check pair value record.\n    uint16_t glyph_id = 0;\n    if (!subtable.ReadU16(&glyph_id)) {\n      return OTS_FAILURE_MSG(\"Failed to read glyph in pair value record %d\", i);\n    }\n    if (glyph_id >= num_glyphs) {\n      return OTS_FAILURE_MSG(\"glyph id %d too high >= %d\", glyph_id, num_glyphs);\n    }\n    if (!ParseValueRecord(file, &subtable, data, length, value_format1)) {\n      return OTS_FAILURE_MSG(\"Failed to parse value record in format 1 pair set table\");\n    }\n    if (!ParseValueRecord(file, &subtable, data, length, value_format2)) {\n      return OTS_FAILURE_MSG(\"Failed to parse value record in format 2 pair set table\");\n    }\n  }\n  return true;\n}\n\nbool ParsePairPosFormat1(const ots::OpenTypeFile *file,\n                         const uint8_t *data, const size_t length,\n                         const uint16_t value_format1,\n                         const uint16_t value_format2,\n                         const uint16_t num_glyphs) {\n  ots::Buffer subtable(data, length);\n\n  // Skip 8 bytes that are already read before.\n  if (!subtable.Skip(8)) {\n    return OTS_FAILURE_MSG(\"Failed to read pair pos table structure\");\n  }\n\n  uint16_t pair_set_count = 0;\n  if (!subtable.ReadU16(&pair_set_count)) {\n    return OTS_FAILURE_MSG(\"Failed to read pair pos set count\");\n  }\n\n  const unsigned pair_pos_end = 2 * static_cast<unsigned>(pair_set_count) + 10;\n  if (pair_pos_end > std::numeric_limits<uint16_t>::max()) {\n    return OTS_FAILURE_MSG(\"Bad pair set length %d\", pair_pos_end);\n  }\n  for (unsigned i = 0; i < pair_set_count; ++i) {\n    uint16_t pair_set_offset = 0;\n    if (!subtable.ReadU16(&pair_set_offset)) {\n      return OTS_FAILURE_MSG(\"Failed to read pair set offset for pair set %d\", i);\n    }\n    if (pair_set_offset < pair_pos_end || pair_set_offset >= length) {\n      return OTS_FAILURE_MSG(\"Bad pair set offset %d for pair set %d\", pair_set_offset, i);\n    }\n    // Check pair set tables\n    if (!ParsePairSetTable(file, data + pair_set_offset, length - pair_set_offset,\n                           value_format1, value_format2,\n                           num_glyphs)) {\n      return OTS_FAILURE_MSG(\"Failed to parse pair set table %d\", i);\n    }\n  }\n\n  return true;\n}\n\nbool ParsePairPosFormat2(const ots::OpenTypeFile *file,\n                         const uint8_t *data, const size_t length,\n                         const uint16_t value_format1,\n                         const uint16_t value_format2,\n                         const uint16_t num_glyphs) {\n  ots::Buffer subtable(data, length);\n\n  // Skip 8 bytes that are already read before.\n  if (!subtable.Skip(8)) {\n    return OTS_FAILURE_MSG(\"Failed to read pair pos format 2 structure\");\n  }\n\n  uint16_t offset_class_def1 = 0;\n  uint16_t offset_class_def2 = 0;\n  uint16_t class1_count = 0;\n  uint16_t class2_count = 0;\n  if (!subtable.ReadU16(&offset_class_def1) ||\n      !subtable.ReadU16(&offset_class_def2) ||\n      !subtable.ReadU16(&class1_count) ||\n      !subtable.ReadU16(&class2_count)) {\n    return OTS_FAILURE_MSG(\"Failed to read pair pos format 2 data\");\n  }\n\n  // Check class 1 records.\n  for (unsigned i = 0; i < class1_count; ++i) {\n    // Check class 2 records.\n    for (unsigned j = 0; j < class2_count; ++j) {\n      if (value_format1 && !ParseValueRecord(file, &subtable, data, length,\n                                             value_format1)) {\n        return OTS_FAILURE_MSG(\"Failed to parse value record 1 %d and %d\", j, i);\n      }\n      if (value_format2 && !ParseValueRecord(file, &subtable, data, length,\n                                             value_format2)) {\n        return OTS_FAILURE_MSG(\"Falied to parse value record 2 %d and %d\", j, i);\n      }\n    }\n  }\n\n  // Check class definition tables.\n  if (offset_class_def1 < subtable.offset() || offset_class_def1 >= length ||\n      offset_class_def2 < subtable.offset() || offset_class_def2 >= length) {\n    return OTS_FAILURE_MSG(\"Bad class definition table offsets %d or %d\", offset_class_def1, offset_class_def2);\n  }\n  if (!ots::ParseClassDefTable(file, data + offset_class_def1,\n                               length - offset_class_def1,\n                               num_glyphs, kMaxClassDefValue)) {\n    return OTS_FAILURE_MSG(\"Failed to parse class definition table 1\");\n  }\n  if (!ots::ParseClassDefTable(file, data + offset_class_def2,\n                               length - offset_class_def2,\n                               num_glyphs, kMaxClassDefValue)) {\n    return OTS_FAILURE_MSG(\"Failed to parse class definition table 2\");\n  }\n\n  return true;\n}\n\n// Lookup Type 2:\n// Pair Adjustment Positioning Subtable\nbool ParsePairAdjustment(const ots::OpenTypeFile *file, const uint8_t *data,\n                         const size_t length) {\n  ots::Buffer subtable(data, length);\n\n  uint16_t format = 0;\n  uint16_t offset_coverage = 0;\n  uint16_t value_format1 = 0;\n  uint16_t value_format2 = 0;\n  if (!subtable.ReadU16(&format) ||\n      !subtable.ReadU16(&offset_coverage) ||\n      !subtable.ReadU16(&value_format1) ||\n      !subtable.ReadU16(&value_format2)) {\n    return OTS_FAILURE_MSG(\"Failed to read pair adjustment structure\");\n  }\n\n  if (format == 1) {\n    if (!ParsePairPosFormat1(file, data, length, value_format1, value_format2,\n                             file->maxp->num_glyphs)) {\n      return OTS_FAILURE_MSG(\"Failed to parse pair pos format 1\");\n    }\n  } else if (format == 2) {\n    if (!ParsePairPosFormat2(file, data, length, value_format1, value_format2,\n                             file->maxp->num_glyphs)) {\n      return OTS_FAILURE_MSG(\"Failed to parse pair format 2\");\n    }\n  } else {\n    return OTS_FAILURE_MSG(\"Bad pos pair format %d\", format);\n  }\n\n  if (offset_coverage < subtable.offset() || offset_coverage >= length) {\n    return OTS_FAILURE_MSG(\"Bad pair pos offset coverage %d\", offset_coverage);\n  }\n  if (!ots::ParseCoverageTable(file, data + offset_coverage,\n                               length - offset_coverage,\n                               file->maxp->num_glyphs)) {\n    return OTS_FAILURE_MSG(\"Failed to parse coverage table\");\n  }\n\n  return true;\n}\n\n// Lookup Type 3\n// Cursive Attachment Positioning Subtable\nbool ParseCursiveAttachment(const ots::OpenTypeFile *file, const uint8_t *data,\n                            const size_t length) {\n  ots::Buffer subtable(data, length);\n\n  uint16_t format = 0;\n  uint16_t offset_coverage = 0;\n  uint16_t entry_exit_count = 0;\n  if (!subtable.ReadU16(&format) ||\n      !subtable.ReadU16(&offset_coverage) ||\n      !subtable.ReadU16(&entry_exit_count)) {\n    return OTS_FAILURE_MSG(\"Failed to read cursive attachment structure\");\n  }\n\n  if (format != 1) {\n    return OTS_FAILURE_MSG(\"Bad cursive attachment format %d\", format);\n  }\n\n  // Check entry exit records.\n  const unsigned entry_exit_records_end =\n      2 * static_cast<unsigned>(entry_exit_count) + 6;\n  if (entry_exit_records_end > std::numeric_limits<uint16_t>::max()) {\n    return OTS_FAILURE_MSG(\"Bad entry exit record end %d\", entry_exit_records_end);\n  }\n  for (unsigned i = 0; i < entry_exit_count; ++i) {\n    uint16_t offset_entry_anchor = 0;\n    uint16_t offset_exit_anchor = 0;\n    if (!subtable.ReadU16(&offset_entry_anchor) ||\n        !subtable.ReadU16(&offset_exit_anchor)) {\n      return OTS_FAILURE_MSG(\"Can't read entry exit record %d\", i);\n    }\n    // These offsets could be NULL.\n    if (offset_entry_anchor) {\n      if (offset_entry_anchor < entry_exit_records_end ||\n          offset_entry_anchor >= length) {\n        return OTS_FAILURE_MSG(\"Bad entry anchor offset %d in entry exit record %d\", offset_entry_anchor, i);\n      }\n      if (!ParseAnchorTable(file, data + offset_entry_anchor,\n                            length - offset_entry_anchor)) {\n        return OTS_FAILURE_MSG(\"Failed to parse entry anchor table in entry exit record %d\", i);\n      }\n    }\n    if (offset_exit_anchor) {\n      if (offset_exit_anchor < entry_exit_records_end ||\n         offset_exit_anchor >= length) {\n        return OTS_FAILURE_MSG(\"Bad exit anchor offset %d in entry exit record %d\", offset_exit_anchor, i);\n      }\n      if (!ParseAnchorTable(file, data + offset_exit_anchor,\n                            length - offset_exit_anchor)) {\n        return OTS_FAILURE_MSG(\"Failed to parse exit anchor table in entry exit record %d\", i);\n      }\n    }\n  }\n\n  if (offset_coverage < subtable.offset() || offset_coverage >= length) {\n    return OTS_FAILURE_MSG(\"Bad coverage offset in cursive attachment %d\", offset_coverage);\n  }\n  if (!ots::ParseCoverageTable(file, data + offset_coverage,\n                               length - offset_coverage,\n                               file->maxp->num_glyphs)) {\n    return OTS_FAILURE_MSG(\"Failed to parse coverage table in cursive attachment\");\n  }\n\n  return true;\n}\n\nbool ParseAnchorArrayTable(const ots::OpenTypeFile *file,\n                           const uint8_t *data, const size_t length,\n                           const uint16_t class_count) {\n  ots::Buffer subtable(data, length);\n\n  uint16_t record_count = 0;\n  if (!subtable.ReadU16(&record_count)) {\n    return OTS_FAILURE_MSG(\"Can't read anchor array length\");\n  }\n\n  const unsigned anchor_array_end = 2 * static_cast<unsigned>(record_count) *\n      static_cast<unsigned>(class_count) + 2;\n  if (anchor_array_end > std::numeric_limits<uint16_t>::max()) {\n    return OTS_FAILURE_MSG(\"Bad end of anchor array %d\", anchor_array_end);\n  }\n  for (unsigned i = 0; i < record_count; ++i) {\n    for (unsigned j = 0; j < class_count; ++j) {\n      uint16_t offset_record = 0;\n      if (!subtable.ReadU16(&offset_record)) {\n        return OTS_FAILURE_MSG(\"Can't read anchor array record offset for class %d and record %d\", j, i);\n      }\n      // |offset_record| could be NULL.\n      if (offset_record) {\n        if (offset_record < anchor_array_end || offset_record >= length) {\n          return OTS_FAILURE_MSG(\"Bad record offset %d in class %d, record %d\", offset_record, j, i);\n        }\n        if (!ParseAnchorTable(file, data + offset_record,\n                              length - offset_record)) {\n          return OTS_FAILURE_MSG(\"Failed to parse anchor table for class %d, record %d\", j, i);\n        }\n      }\n    }\n  }\n  return true;\n}\n\nbool ParseLigatureArrayTable(const ots::OpenTypeFile *file,\n                             const uint8_t *data, const size_t length,\n                             const uint16_t class_count) {\n  ots::Buffer subtable(data, length);\n\n  uint16_t ligature_count = 0;\n  if (!subtable.ReadU16(&ligature_count)) {\n    return OTS_FAILURE_MSG(\"Failed to read ligature count\");\n  }\n  for (unsigned i = 0; i < ligature_count; ++i) {\n    uint16_t offset_ligature_attach = 0;\n    if (!subtable.ReadU16(&offset_ligature_attach)) {\n      return OTS_FAILURE_MSG(\"Can't read ligature offset %d\", i);\n    }\n    if (offset_ligature_attach < 2 || offset_ligature_attach >= length) {\n      return OTS_FAILURE_MSG(\"Bad ligature attachment offset %d in ligature %d\", offset_ligature_attach, i);\n    }\n    if (!ParseAnchorArrayTable(file, data + offset_ligature_attach,\n                               length - offset_ligature_attach, class_count)) {\n      return OTS_FAILURE_MSG(\"Failed to parse anchor table for ligature %d\", i);\n    }\n  }\n  return true;\n}\n\n// Common parser for Lookup Type 4, 5 and 6.\nbool ParseMarkToAttachmentSubtables(const ots::OpenTypeFile *file,\n                                    const uint8_t *data, const size_t length,\n                                    const GPOS_TYPE type) {\n  ots::Buffer subtable(data, length);\n\n  uint16_t format = 0;\n  uint16_t offset_coverage1 = 0;\n  uint16_t offset_coverage2 = 0;\n  uint16_t class_count = 0;\n  uint16_t offset_mark_array = 0;\n  uint16_t offset_type_specific_array = 0;\n  if (!subtable.ReadU16(&format) ||\n      !subtable.ReadU16(&offset_coverage1) ||\n      !subtable.ReadU16(&offset_coverage2) ||\n      !subtable.ReadU16(&class_count) ||\n      !subtable.ReadU16(&offset_mark_array) ||\n      !subtable.ReadU16(&offset_type_specific_array)) {\n    return OTS_FAILURE_MSG(\"Failed to read mark attachment subtable header\");\n  }\n\n  if (format != 1) {\n    return OTS_FAILURE_MSG(\"bad mark attachment subtable format %d\", format);\n  }\n\n  const unsigned header_end = static_cast<unsigned>(subtable.offset());\n  if (header_end > std::numeric_limits<uint16_t>::max()) {\n    return OTS_FAILURE_MSG(\"Bad mark attachment subtable size ending at %d\", header_end);\n  }\n  if (offset_coverage1 < header_end || offset_coverage1 >= length) {\n    return OTS_FAILURE_MSG(\"Bad coverage 1 offset %d\", offset_coverage1);\n  }\n  if (!ots::ParseCoverageTable(file, data + offset_coverage1,\n                               length - offset_coverage1,\n                               file->maxp->num_glyphs)) {\n    return OTS_FAILURE_MSG(\"Failed to parse converge 1 table\");\n  }\n  if (offset_coverage2 < header_end || offset_coverage2 >= length) {\n    return OTS_FAILURE_MSG(\"Bad coverage 2 offset %d\", offset_coverage2);\n  }\n  if (!ots::ParseCoverageTable(file, data + offset_coverage2,\n                               length - offset_coverage2,\n                               file->maxp->num_glyphs)) {\n    return OTS_FAILURE_MSG(\"Failed to parse coverage table 2\");\n  }\n\n  if (offset_mark_array < header_end || offset_mark_array >= length) {\n    return OTS_FAILURE_MSG(\"Bad mark array offset %d\", offset_mark_array);\n  }\n  if (!ParseMarkArrayTable(file, data + offset_mark_array,\n                           length - offset_mark_array, class_count)) {\n    return OTS_FAILURE_MSG(\"Failed to parse mark array\");\n  }\n\n  if (offset_type_specific_array < header_end ||\n      offset_type_specific_array >= length) {\n    return OTS_FAILURE_MSG(\"Bad type specific array offset %d\", offset_type_specific_array);\n  }\n  if (type == GPOS_TYPE_MARK_TO_BASE_ATTACHMENT ||\n      type == GPOS_TYPE_MARK_TO_MARK_ATTACHMENT) {\n    if (!ParseAnchorArrayTable(file, data + offset_type_specific_array,\n                               length - offset_type_specific_array,\n                               class_count)) {\n      return OTS_FAILURE_MSG(\"Failed to parse anchor array\");\n    }\n  } else if (type == GPOS_TYPE_MARK_TO_LIGATURE_ATTACHMENT) {\n    if (!ParseLigatureArrayTable(file, data + offset_type_specific_array,\n                                 length - offset_type_specific_array,\n                                 class_count)) {\n      return OTS_FAILURE_MSG(\"Failed to parse ligature array\");\n    }\n  } else {\n    return OTS_FAILURE_MSG(\"Bad attachment type %d\", type);\n  }\n\n  return true;\n}\n\n// Lookup Type 4:\n// MarkToBase Attachment Positioning Subtable\nbool ParseMarkToBaseAttachment(const ots::OpenTypeFile *file,\n                               const uint8_t *data, const size_t length) {\n  return ParseMarkToAttachmentSubtables(file, data, length,\n                                        GPOS_TYPE_MARK_TO_BASE_ATTACHMENT);\n}\n\n// Lookup Type 5:\n// MarkToLigature Attachment Positioning Subtable\nbool ParseMarkToLigatureAttachment(const ots::OpenTypeFile *file,\n                                   const uint8_t *data, const size_t length) {\n  return ParseMarkToAttachmentSubtables(file, data, length,\n                                        GPOS_TYPE_MARK_TO_LIGATURE_ATTACHMENT);\n}\n\n// Lookup Type 6:\n// MarkToMark Attachment Positioning Subtable\nbool ParseMarkToMarkAttachment(const ots::OpenTypeFile *file,\n                               const uint8_t *data, const size_t length) {\n  return ParseMarkToAttachmentSubtables(file, data, length,\n                                        GPOS_TYPE_MARK_TO_MARK_ATTACHMENT);\n}\n\n// Lookup Type 7:\n// Contextual Positioning Subtables\nbool ParseContextPositioning(const ots::OpenTypeFile *file,\n                             const uint8_t *data, const size_t length) {\n  return ots::ParseContextSubtable(file, data, length, file->maxp->num_glyphs,\n                                   file->gpos->num_lookups);\n}\n\n// Lookup Type 8:\n// Chaining Contexual Positioning Subtable\nbool ParseChainedContextPositioning(const ots::OpenTypeFile *file,\n                                    const uint8_t *data, const size_t length) {\n  return ots::ParseChainingContextSubtable(file, data, length,\n                                           file->maxp->num_glyphs,\n                                           file->gpos->num_lookups);\n}\n\n// Lookup Type 9:\n// Extension Positioning\nbool ParseExtensionPositioning(const ots::OpenTypeFile *file,\n                               const uint8_t *data, const size_t length) {\n  return ots::ParseExtensionSubtable(file, data, length,\n                                     &kGposLookupSubtableParser);\n}\n\n}  // namespace\n\n#define DROP_THIS_TABLE(msg_) \\\n  do { \\\n    OTS_FAILURE_MSG(msg_ \", table discarded\"); \\\n    file->gpos->data = 0; \\\n    file->gpos->length = 0; \\\n  } while (0)\n\nnamespace ots {\n\n// As far as I checked, following fonts contain invalid GPOS table and\n// OTS will drop their GPOS table.\n//\n// # invalid delta format in device table\n// samanata.ttf\n//\n// # bad size range in device table\n// Sarai_07.ttf\n//\n// # bad offset to PairSetTable\n// chandas1-2.ttf\n//\n// # bad offset to FeatureTable\n// glrso12.ttf\n// gllr12.ttf\n// glbo12.ttf\n// glb12.ttf\n// glro12.ttf\n// glbso12.ttf\n// glrc12.ttf\n// glrsc12.ttf\n// glbs12.ttf\n// glrs12.ttf\n// glr12.ttf\n//\n// # ScriptRecords aren't sorted by tag\n// Garogier_unhinted.otf\n//\n// # bad start coverage index in CoverageFormat2\n// AndBasR.ttf\n// CharisSILB.ttf\n// CharisSILBI.ttf\n// CharisSILI.ttf\n// CharisSILR.ttf\n// DoulosSILR.ttf\n// GenBasBI.ttf\n// GenBasI.ttf\n// GenBkBasI.ttf\n// GenBkBasB.ttf\n// GenBkBasR.ttf\n// Padauk-Bold.ttf\n// Padauk.ttf\n//\n// # Contour point indexes aren't sorted\n// Arial Unicode.ttf\n\nbool ots_gpos_parse(OpenTypeFile *file, const uint8_t *data, size_t length) {\n  // Parsing GPOS table requires num_glyphs which is contained in maxp table.\n  if (!file->maxp) {\n    return OTS_FAILURE_MSG(\"missing maxp table needed in GPOS\");\n  }\n\n  Buffer table(data, length);\n\n  OpenTypeGPOS *gpos = new OpenTypeGPOS;\n  file->gpos = gpos;\n\n  uint32_t version = 0;\n  uint16_t offset_script_list = 0;\n  uint16_t offset_feature_list = 0;\n  uint16_t offset_lookup_list = 0;\n  if (!table.ReadU32(&version) ||\n      !table.ReadU16(&offset_script_list) ||\n      !table.ReadU16(&offset_feature_list) ||\n      !table.ReadU16(&offset_lookup_list)) {\n    DROP_THIS_TABLE(\"Incomplete table\");\n    return true;\n  }\n\n  if (version != 0x00010000) {\n    DROP_THIS_TABLE(\"Bad version\");\n    return true;\n  }\n\n  if (offset_lookup_list) {\n    if (offset_lookup_list < kGposHeaderSize || offset_lookup_list >= length) {\n      DROP_THIS_TABLE(\"Bad lookup list offset in table header\");\n      return true;\n    }\n\n    if (!ParseLookupListTable(file, data + offset_lookup_list,\n                              length - offset_lookup_list,\n                              &kGposLookupSubtableParser,\n                              &gpos->num_lookups)) {\n      DROP_THIS_TABLE(\"Failed to parse lookup list table\");\n      return true;\n    }\n  }\n\n  uint16_t num_features = 0;\n  if (offset_feature_list) {\n    if (offset_feature_list < kGposHeaderSize || offset_feature_list >= length) {\n      DROP_THIS_TABLE(\"Bad feature list offset in table header\");\n      return true;\n    }\n\n    if (!ParseFeatureListTable(file, data + offset_feature_list,\n                               length - offset_feature_list, gpos->num_lookups,\n                               &num_features)) {\n      DROP_THIS_TABLE(\"Failed to parse feature list table\");\n      return true;\n    }\n  }\n\n  if (offset_script_list) {\n    if (offset_script_list < kGposHeaderSize || offset_script_list >= length) {\n      DROP_THIS_TABLE(\"Bad script list offset in table header\");\n      return true;\n    }\n\n    if (!ParseScriptListTable(file, data + offset_script_list,\n                              length - offset_script_list, num_features)) {\n      DROP_THIS_TABLE(\"Failed to parse script list table\");\n      return true;\n    }\n  }\n\n  gpos->data = data;\n  gpos->length = length;\n  return true;\n}\n\nbool ots_gpos_should_serialise(OpenTypeFile *file) {\n  return file->gpos != NULL && file->gpos->data != NULL;\n}\n\nbool ots_gpos_serialise(OTSStream *out, OpenTypeFile *file) {\n  if (!out->Write(file->gpos->data, file->gpos->length)) {\n    return OTS_FAILURE_MSG(\"Failed to write GPOS table\");\n  }\n\n  return true;\n}\n\nvoid ots_gpos_free(OpenTypeFile *file) {\n  delete file->gpos;\n}\n\n}  // namespace ots\n\n#undef TABLE_NAME\n#undef DROP_THIS_TABLE\n", "// Copyright (c) 2011 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n#include \"gsub.h\"\n\n#include <limits>\n#include <vector>\n\n#include \"layout.h\"\n#include \"maxp.h\"\n\n// GSUB - The Glyph Substitution Table\n// http://www.microsoft.com/typography/otspec/gsub.htm\n\n#define TABLE_NAME \"GSUB\"\n\nnamespace {\n\n// The GSUB header size\nconst size_t kGsubHeaderSize = 4 + 3 * 2;\n\nenum GSUB_TYPE {\n  GSUB_TYPE_SINGLE = 1,\n  GSUB_TYPE_MULTIPLE = 2,\n  GSUB_TYPE_ALTERNATE = 3,\n  GSUB_TYPE_LIGATURE = 4,\n  GSUB_TYPE_CONTEXT = 5,\n  GSUB_TYPE_CHANGING_CONTEXT = 6,\n  GSUB_TYPE_EXTENSION_SUBSTITUTION = 7,\n  GSUB_TYPE_REVERSE_CHAINING_CONTEXT_SINGLE = 8,\n  GSUB_TYPE_RESERVED = 9\n};\n\n// Lookup type parsers.\nbool ParseSingleSubstitution(const ots::OpenTypeFile *file,\n                             const uint8_t *data, const size_t length);\nbool ParseMutipleSubstitution(const ots::OpenTypeFile *file,\n                              const uint8_t *data, const size_t length);\nbool ParseAlternateSubstitution(const ots::OpenTypeFile *file,\n                                const uint8_t *data, const size_t length);\nbool ParseLigatureSubstitution(const ots::OpenTypeFile *file,\n      const uint8_t *data, const size_t length);\nbool ParseContextSubstitution(const ots::OpenTypeFile *file,\n                              const uint8_t *data, const size_t length);\nbool ParseChainingContextSubstitution(const ots::OpenTypeFile *file,\n                                      const uint8_t *data,\n                                      const size_t length);\nbool ParseExtensionSubstitution(const ots::OpenTypeFile *file,\n                                const uint8_t *data, const size_t length);\nbool ParseReverseChainingContextSingleSubstitution(\n    const ots::OpenTypeFile *file, const uint8_t *data, const size_t length);\n\nconst ots::LookupSubtableParser::TypeParser kGsubTypeParsers[] = {\n  {GSUB_TYPE_SINGLE, ParseSingleSubstitution},\n  {GSUB_TYPE_MULTIPLE, ParseMutipleSubstitution},\n  {GSUB_TYPE_ALTERNATE, ParseAlternateSubstitution},\n  {GSUB_TYPE_LIGATURE, ParseLigatureSubstitution},\n  {GSUB_TYPE_CONTEXT, ParseContextSubstitution},\n  {GSUB_TYPE_CHANGING_CONTEXT, ParseChainingContextSubstitution},\n  {GSUB_TYPE_EXTENSION_SUBSTITUTION, ParseExtensionSubstitution},\n  {GSUB_TYPE_REVERSE_CHAINING_CONTEXT_SINGLE,\n    ParseReverseChainingContextSingleSubstitution}\n};\n\nconst ots::LookupSubtableParser kGsubLookupSubtableParser = {\n  arraysize(kGsubTypeParsers),\n  GSUB_TYPE_EXTENSION_SUBSTITUTION, kGsubTypeParsers\n};\n\n// Lookup Type 1:\n// Single Substitution Subtable\nbool ParseSingleSubstitution(const ots::OpenTypeFile *file,\n                             const uint8_t *data, const size_t length) {\n  ots::Buffer subtable(data, length);\n\n  uint16_t format = 0;\n  uint16_t offset_coverage = 0;\n\n  if (!subtable.ReadU16(&format) ||\n      !subtable.ReadU16(&offset_coverage)) {\n    return OTS_FAILURE_MSG(\"Failed to read single subst table header\");\n  }\n\n  const uint16_t num_glyphs = file->maxp->num_glyphs;\n  if (format == 1) {\n    // Parse SingleSubstFormat1\n    int16_t delta_glyph_id = 0;\n    if (!subtable.ReadS16(&delta_glyph_id)) {\n      return OTS_FAILURE_MSG(\"Failed to read glyph shift from format 1 single subst table\");\n    }\n    if (std::abs(delta_glyph_id) >= num_glyphs) {\n      return OTS_FAILURE_MSG(\"bad glyph shift of %d in format 1 single subst table\", delta_glyph_id);\n    }\n  } else if (format == 2) {\n    // Parse SingleSubstFormat2\n    uint16_t glyph_count = 0;\n    if (!subtable.ReadU16(&glyph_count)) {\n      return OTS_FAILURE_MSG(\"Failed to read glyph cound in format 2 single subst table\");\n    }\n    if (glyph_count > num_glyphs) {\n      return OTS_FAILURE_MSG(\"Bad glyph count %d > %d in format 2 single subst table\", glyph_count, num_glyphs);\n    }\n    for (unsigned i = 0; i < glyph_count; ++i) {\n      uint16_t substitute = 0;\n      if (!subtable.ReadU16(&substitute)) {\n        return OTS_FAILURE_MSG(\"Failed to read substitution %d in format 2 single subst table\", i);\n      }\n      if (substitute >= num_glyphs) {\n        return OTS_FAILURE_MSG(\"too large substitute: %u\", substitute);\n      }\n    }\n  } else {\n    return OTS_FAILURE_MSG(\"Bad single subst table format %d\", format);\n  }\n\n  if (offset_coverage < subtable.offset() || offset_coverage >= length) {\n    return OTS_FAILURE_MSG(\"Bad coverage offset %x\", offset_coverage);\n  }\n  if (!ots::ParseCoverageTable(file, data + offset_coverage,\n                               length - offset_coverage, num_glyphs)) {\n    return OTS_FAILURE_MSG(\"Failed to parse coverage table\");\n  }\n\n  return true;\n}\n\nbool ParseSequenceTable(const ots::OpenTypeFile *file,\n                        const uint8_t *data, const size_t length,\n                        const uint16_t num_glyphs) {\n  ots::Buffer subtable(data, length);\n\n  uint16_t glyph_count = 0;\n  if (!subtable.ReadU16(&glyph_count)) {\n    return OTS_FAILURE_MSG(\"Failed to read glyph count in sequence table\");\n  }\n  if (glyph_count > num_glyphs) {\n    return OTS_FAILURE_MSG(\"bad glyph count %d > %d\", glyph_count, num_glyphs);\n  }\n  for (unsigned i = 0; i < glyph_count; ++i) {\n    uint16_t substitute = 0;\n    if (!subtable.ReadU16(&substitute)) {\n      return OTS_FAILURE_MSG(\"Failedt o read substitution %d in sequence table\", i);\n    }\n    if (substitute >= num_glyphs) {\n      return OTS_FAILURE_MSG(\"Bad subsitution (%d) %d > %d\", i, substitute, num_glyphs);\n    }\n  }\n\n  return true;\n}\n\n// Lookup Type 2:\n// Multiple Substitution Subtable\nbool ParseMutipleSubstitution(const ots::OpenTypeFile *file,\n                              const uint8_t *data, const size_t length) {\n  ots::Buffer subtable(data, length);\n\n  uint16_t format = 0;\n  uint16_t offset_coverage = 0;\n  uint16_t sequence_count = 0;\n\n  if (!subtable.ReadU16(&format) ||\n      !subtable.ReadU16(&offset_coverage) ||\n      !subtable.ReadU16(&sequence_count)) {\n    return OTS_FAILURE_MSG(\"Can't read header of multiple subst table\");\n  }\n\n  if (format != 1) {\n    return OTS_FAILURE_MSG(\"Bad multiple subst table format %d\", format);\n  }\n\n  const uint16_t num_glyphs = file->maxp->num_glyphs;\n  const unsigned sequence_end = static_cast<unsigned>(6) +\n      sequence_count * 2;\n  if (sequence_end > std::numeric_limits<uint16_t>::max()) {\n    return OTS_FAILURE_MSG(\"Bad segence end %d, in multiple subst\", sequence_end);\n  }\n  for (unsigned i = 0; i < sequence_count; ++i) {\n    uint16_t offset_sequence = 0;\n    if (!subtable.ReadU16(&offset_sequence)) {\n      return OTS_FAILURE_MSG(\"Failed to read sequence offset for sequence %d\", i);\n    }\n    if (offset_sequence < sequence_end || offset_sequence >= length) {\n      return OTS_FAILURE_MSG(\"Bad sequence offset %d for sequence %d\", offset_sequence, i);\n    }\n    if (!ParseSequenceTable(file, data + offset_sequence, length - offset_sequence,\n                            num_glyphs)) {\n      return OTS_FAILURE_MSG(\"Failed to parse sequence table %d\", i);\n    }\n  }\n\n  if (offset_coverage < sequence_end || offset_coverage >= length) {\n    return OTS_FAILURE_MSG(\"Bad coverage offset %d\", offset_coverage);\n  }\n  if (!ots::ParseCoverageTable(file, data + offset_coverage,\n                               length - offset_coverage, num_glyphs)) {\n    return OTS_FAILURE_MSG(\"Failed to parse coverage table\");\n  }\n\n  return true;\n}\n\nbool ParseAlternateSetTable(const ots::OpenTypeFile *file,\n                            const uint8_t *data, const size_t length,\n                            const uint16_t num_glyphs) {\n  ots::Buffer subtable(data, length);\n\n  uint16_t glyph_count = 0;\n  if (!subtable.ReadU16(&glyph_count)) {\n    return OTS_FAILURE_MSG(\"Failed to read alternate set header\");\n  }\n  if (glyph_count > num_glyphs) {\n    return OTS_FAILURE_MSG(\"Bad glyph count %d > %d in alternate set table\", glyph_count, num_glyphs);\n  }\n  for (unsigned i = 0; i < glyph_count; ++i) {\n    uint16_t alternate = 0;\n    if (!subtable.ReadU16(&alternate)) {\n      return OTS_FAILURE_MSG(\"Can't read alternate %d\", i);\n    }\n    if (alternate >= num_glyphs) {\n      return OTS_FAILURE_MSG(\"Too large alternate: %u\", alternate);\n    }\n  }\n  return true;\n}\n\n// Lookup Type 3:\n// Alternate Substitution Subtable\nbool ParseAlternateSubstitution(const ots::OpenTypeFile *file,\n                                const uint8_t *data, const size_t length) {\n  ots::Buffer subtable(data, length);\n\n  uint16_t format = 0;\n  uint16_t offset_coverage = 0;\n  uint16_t alternate_set_count = 0;\n\n  if (!subtable.ReadU16(&format) ||\n      !subtable.ReadU16(&offset_coverage) ||\n      !subtable.ReadU16(&alternate_set_count)) {\n    return OTS_FAILURE_MSG(\"Can't read alternate subst header\");\n  }\n\n  if (format != 1) {\n    return OTS_FAILURE_MSG(\"Bad alternate subst table format %d\", format);\n  }\n\n  const uint16_t num_glyphs = file->maxp->num_glyphs;\n  const unsigned alternate_set_end = static_cast<unsigned>(6) +\n      alternate_set_count * 2;\n  if (alternate_set_end > std::numeric_limits<uint16_t>::max()) {\n    return OTS_FAILURE_MSG(\"Bad end of alternate set %d\", alternate_set_end);\n  }\n  for (unsigned i = 0; i < alternate_set_count; ++i) {\n    uint16_t offset_alternate_set = 0;\n    if (!subtable.ReadU16(&offset_alternate_set)) {\n      return OTS_FAILURE_MSG(\"Can't read alternate set offset for set %d\", i);\n    }\n    if (offset_alternate_set < alternate_set_end ||\n        offset_alternate_set >= length) {\n      return OTS_FAILURE_MSG(\"Bad alternate set offset %d for set %d\", offset_alternate_set, i);\n    }\n    if (!ParseAlternateSetTable(file, data + offset_alternate_set,\n                                length - offset_alternate_set,\n                                num_glyphs)) {\n      return OTS_FAILURE_MSG(\"Failed to parse alternate set\");\n    }\n  }\n\n  if (offset_coverage < alternate_set_end || offset_coverage >= length) {\n    return OTS_FAILURE_MSG(\"Bad coverage offset %d\", offset_coverage);\n  }\n  if (!ots::ParseCoverageTable(file, data + offset_coverage,\n                               length - offset_coverage, num_glyphs)) {\n    return OTS_FAILURE_MSG(\"Failed to parse coverage table\");\n  }\n\n  return true;\n}\n\nbool ParseLigatureTable(const ots::OpenTypeFile *file,\n                        const uint8_t *data, const size_t length,\n                        const uint16_t num_glyphs) {\n  ots::Buffer subtable(data, length);\n\n  uint16_t lig_glyph = 0;\n  uint16_t comp_count = 0;\n\n  if (!subtable.ReadU16(&lig_glyph) ||\n      !subtable.ReadU16(&comp_count)) {\n    return OTS_FAILURE_MSG(\"Failed to read ligatuer table header\");\n  }\n\n  if (lig_glyph >= num_glyphs) {\n    return OTS_FAILURE_MSG(\"too large lig_glyph: %u\", lig_glyph);\n  }\n  if (comp_count == 0 || comp_count > num_glyphs) {\n    return OTS_FAILURE_MSG(\"Bad component count of %d\", comp_count);\n  }\n  for (unsigned i = 0; i < comp_count - static_cast<unsigned>(1); ++i) {\n    uint16_t component = 0;\n    if (!subtable.ReadU16(&component)) {\n      return OTS_FAILURE_MSG(\"Can't read ligature component %d\", i);\n    }\n    if (component >= num_glyphs) {\n      return OTS_FAILURE_MSG(\"Bad ligature component %d of %d\", i, component);\n    }\n  }\n\n  return true;\n}\n\nbool ParseLigatureSetTable(const ots::OpenTypeFile *file,\n                           const uint8_t *data, const size_t length,\n                           const uint16_t num_glyphs) {\n  ots::Buffer subtable(data, length);\n\n  uint16_t ligature_count = 0;\n\n  if (!subtable.ReadU16(&ligature_count)) {\n    return OTS_FAILURE_MSG(\"Can't read ligature count in ligature set\");\n  }\n\n  const unsigned ligature_end = static_cast<unsigned>(2) + ligature_count * 2;\n  if (ligature_end > std::numeric_limits<uint16_t>::max()) {\n    return OTS_FAILURE_MSG(\"Bad end of ligature %d in ligature set\", ligature_end);\n  }\n  for (unsigned i = 0; i < ligature_count; ++i) {\n    uint16_t offset_ligature = 0;\n    if (!subtable.ReadU16(&offset_ligature)) {\n      return OTS_FAILURE_MSG(\"Failed to read ligature offset %d\", i);\n    }\n    if (offset_ligature < ligature_end || offset_ligature >= length) {\n      return OTS_FAILURE_MSG(\"Bad ligature offset %d for ligature %d\", offset_ligature, i);\n    }\n    if (!ParseLigatureTable(file, data + offset_ligature, length - offset_ligature,\n                            num_glyphs)) {\n      return OTS_FAILURE_MSG(\"Failed to parse ligature %d\", i);\n    }\n  }\n\n  return true;\n}\n\n// Lookup Type 4:\n// Ligature Substitution Subtable\nbool ParseLigatureSubstitution(const ots::OpenTypeFile *file,\n                               const uint8_t *data, const size_t length) {\n  ots::Buffer subtable(data, length);\n\n  uint16_t format = 0;\n  uint16_t offset_coverage = 0;\n  uint16_t lig_set_count = 0;\n\n  if (!subtable.ReadU16(&format) ||\n      !subtable.ReadU16(&offset_coverage) ||\n      !subtable.ReadU16(&lig_set_count)) {\n    return OTS_FAILURE_MSG(\"Failed to read ligature substitution header\");\n  }\n\n  if (format != 1) {\n    return OTS_FAILURE_MSG(\"Bad ligature substitution table format %d\", format);\n  }\n\n  const uint16_t num_glyphs = file->maxp->num_glyphs;\n  const unsigned ligature_set_end = static_cast<unsigned>(6) +\n      lig_set_count * 2;\n  if (ligature_set_end > std::numeric_limits<uint16_t>::max()) {\n    return OTS_FAILURE_MSG(\"Bad end of ligature set %d in ligature substitution table\", ligature_set_end);\n  }\n  for (unsigned i = 0; i < lig_set_count; ++i) {\n    uint16_t offset_ligature_set = 0;\n    if (!subtable.ReadU16(&offset_ligature_set)) {\n      return OTS_FAILURE_MSG(\"Can't read ligature set offset %d\", i);\n    }\n    if (offset_ligature_set < ligature_set_end ||\n        offset_ligature_set >= length) {\n      return OTS_FAILURE_MSG(\"Bad ligature set offset %d for set %d\", offset_ligature_set, i);\n    }\n    if (!ParseLigatureSetTable(file, data + offset_ligature_set,\n                               length - offset_ligature_set, num_glyphs)) {\n      return OTS_FAILURE_MSG(\"Failed to parse ligature set %d\", i);\n    }\n  }\n\n  if (offset_coverage < ligature_set_end || offset_coverage >= length) {\n    return OTS_FAILURE_MSG(\"Bad coverage offset %d\", offset_coverage);\n  }\n  if (!ots::ParseCoverageTable(file, data + offset_coverage,\n                               length - offset_coverage, num_glyphs)) {\n    return OTS_FAILURE_MSG(\"Failed to parse coverage table\");\n  }\n\n  return true;\n}\n\n// Lookup Type 5:\n// Contextual Substitution Subtable\nbool ParseContextSubstitution(const ots::OpenTypeFile *file,\n                              const uint8_t *data, const size_t length) {\n  return ots::ParseContextSubtable(file, data, length, file->maxp->num_glyphs,\n                                   file->gsub->num_lookups);\n}\n\n// Lookup Type 6:\n// Chaining Contextual Substitution Subtable\nbool ParseChainingContextSubstitution(const ots::OpenTypeFile *file,\n                                      const uint8_t *data,\n                                      const size_t length) {\n  return ots::ParseChainingContextSubtable(file, data, length,\n                                           file->maxp->num_glyphs,\n                                           file->gsub->num_lookups);\n}\n\n// Lookup Type 7:\n// Extension Substition\nbool ParseExtensionSubstitution(const ots::OpenTypeFile *file,\n                                const uint8_t *data, const size_t length) {\n  return ots::ParseExtensionSubtable(file, data, length,\n                                     &kGsubLookupSubtableParser);\n}\n\n// Lookup Type 8:\n// Reverse Chaining Contexual Single Substitution Subtable\nbool ParseReverseChainingContextSingleSubstitution(\n    const ots::OpenTypeFile *file, const uint8_t *data, const size_t length) {\n  ots::Buffer subtable(data, length);\n\n  uint16_t format = 0;\n  uint16_t offset_coverage = 0;\n\n  if (!subtable.ReadU16(&format) ||\n      !subtable.ReadU16(&offset_coverage)) {\n    return OTS_FAILURE_MSG(\"Failed to read reverse chaining header\");\n  }\n\n  const uint16_t num_glyphs = file->maxp->num_glyphs;\n\n  uint16_t backtrack_glyph_count = 0;\n  if (!subtable.ReadU16(&backtrack_glyph_count)) {\n    return OTS_FAILURE_MSG(\"Failed to read backtrack glyph count in reverse chaining table\");\n  }\n  if (backtrack_glyph_count > num_glyphs) {\n    return OTS_FAILURE_MSG(\"Bad backtrack glyph count of %d\", backtrack_glyph_count);\n  }\n  std::vector<uint16_t> offsets_backtrack;\n  offsets_backtrack.reserve(backtrack_glyph_count);\n  for (unsigned i = 0; i < backtrack_glyph_count; ++i) {\n    uint16_t offset = 0;\n    if (!subtable.ReadU16(&offset)) {\n      return OTS_FAILURE_MSG(\"Failed to read backtrack offset %d\", i);\n    }\n    offsets_backtrack.push_back(offset);\n  }\n\n  uint16_t lookahead_glyph_count = 0;\n  if (!subtable.ReadU16(&lookahead_glyph_count)) {\n    return OTS_FAILURE_MSG(\"Failed to read look ahead glyph count\");\n  }\n  if (lookahead_glyph_count > num_glyphs) {\n    return OTS_FAILURE_MSG(\"Bad look ahead glyph count %d\", lookahead_glyph_count);\n  }\n  std::vector<uint16_t> offsets_lookahead;\n  offsets_lookahead.reserve(lookahead_glyph_count);\n  for (unsigned i = 0; i < lookahead_glyph_count; ++i) {\n    uint16_t offset = 0;\n    if (!subtable.ReadU16(&offset)) {\n      return OTS_FAILURE_MSG(\"Can't read look ahead offset %d\", i);\n    }\n    offsets_lookahead.push_back(offset);\n  }\n\n  uint16_t glyph_count = 0;\n  if (!subtable.ReadU16(&glyph_count)) {\n    return OTS_FAILURE_MSG(\"Can't read glyph count in reverse chaining table\");\n  }\n  if (glyph_count > num_glyphs) {\n    return OTS_FAILURE_MSG(\"Bad glyph count of %d\", glyph_count);\n  }\n  for (unsigned i = 0; i < glyph_count; ++i) {\n    uint16_t substitute = 0;\n    if (!subtable.ReadU16(&substitute)) {\n      return OTS_FAILURE_MSG(\"Failed to read substitution %d reverse chaining table\", i);\n    }\n    if (substitute >= num_glyphs) {\n      return OTS_FAILURE_MSG(\"Bad substitute glyph %d in reverse chaining table substitution %d\", substitute, i);\n    }\n  }\n\n  const unsigned substitute_end = static_cast<unsigned>(10) +\n      (backtrack_glyph_count + lookahead_glyph_count + glyph_count) * 2;\n  if (substitute_end > std::numeric_limits<uint16_t>::max()) {\n    return OTS_FAILURE_MSG(\"Bad substitute end offset in reverse chaining table\");\n  }\n\n  if (offset_coverage < substitute_end || offset_coverage >= length) {\n    return OTS_FAILURE_MSG(\"Bad coverage offset %d in reverse chaining table\", offset_coverage);\n  }\n  if (!ots::ParseCoverageTable(file, data + offset_coverage,\n                               length - offset_coverage, num_glyphs)) {\n    return OTS_FAILURE_MSG(\"Failed to parse coverage table in reverse chaining table\");\n  }\n\n  for (unsigned i = 0; i < backtrack_glyph_count; ++i) {\n    if (offsets_backtrack[i] < substitute_end ||\n        offsets_backtrack[i] >= length) {\n      return OTS_FAILURE_MSG(\"Bad backtrack offset %d for backtrack %d in reverse chaining table\", offsets_backtrack[i], i);\n    }\n    if (!ots::ParseCoverageTable(file, data + offsets_backtrack[i],\n                                 length - offsets_backtrack[i], num_glyphs)) {\n      return OTS_FAILURE_MSG(\"Failed to parse coverage table for backtrack %d in reverse chaining table\", i);\n    }\n  }\n\n  for (unsigned i = 0; i < lookahead_glyph_count; ++i) {\n    if (offsets_lookahead[i] < substitute_end ||\n        offsets_lookahead[i] >= length) {\n      return OTS_FAILURE_MSG(\"Bad lookahead offset %d for lookahead %d in reverse chaining table\", offsets_lookahead[i], i);\n    }\n    if (!ots::ParseCoverageTable(file, data + offsets_lookahead[i],\n                                 length - offsets_lookahead[i], num_glyphs)) {\n      return OTS_FAILURE_MSG(\"Failed to parse lookahead coverage table %d in reverse chaining table\", i);\n    }\n  }\n\n  return true;\n}\n\n}  // namespace\n\n#define DROP_THIS_TABLE(msg_) \\\n  do { \\\n    OTS_FAILURE_MSG(msg_ \", table discarded\"); \\\n    file->gsub->data = 0; \\\n    file->gsub->length = 0; \\\n  } while (0)\n\nnamespace ots {\n\n// As far as I checked, following fonts contain invalid values in GSUB table.\n// OTS will drop their GSUB table.\n//\n// # too large substitute (value is 0xFFFF)\n// kaiu.ttf\n// mingliub2.ttf\n// mingliub1.ttf\n// mingliub0.ttf\n// GraublauWeb.otf\n// GraublauWebBold.otf\n//\n// # too large alternate (value is 0xFFFF)\n// ManchuFont.ttf\n//\n// # bad offset to lang sys table (NULL offset)\n// DejaVuMonoSansBold.ttf\n// DejaVuMonoSansBoldOblique.ttf\n// DejaVuMonoSansOblique.ttf\n// DejaVuSansMono-BoldOblique.ttf\n// DejaVuSansMono-Oblique.ttf\n// DejaVuSansMono-Bold.ttf\n//\n// # bad start coverage index\n// GenBasBI.ttf\n// GenBasI.ttf\n// AndBasR.ttf\n// GenBkBasI.ttf\n// CharisSILR.ttf\n// CharisSILBI.ttf\n// CharisSILI.ttf\n// CharisSILB.ttf\n// DoulosSILR.ttf\n// CharisSILBI.ttf\n// GenBkBasB.ttf\n// GenBkBasR.ttf\n// GenBkBasBI.ttf\n// GenBasB.ttf\n// GenBasR.ttf\n//\n// # glyph range is overlapping\n// KacstTitleL.ttf\n// KacstDecorative.ttf\n// KacstTitle.ttf\n// KacstArt.ttf\n// KacstPoster.ttf\n// KacstQurn.ttf\n// KacstDigital.ttf\n// KacstBook.ttf\n// KacstFarsi.ttf\n\nbool ots_gsub_parse(OpenTypeFile *file, const uint8_t *data, size_t length) {\n  // Parsing gsub table requires |file->maxp->num_glyphs|\n  if (!file->maxp) {\n    return OTS_FAILURE_MSG(\"Missing maxp table in font, needed by GSUB\");\n  }\n\n  Buffer table(data, length);\n\n  OpenTypeGSUB *gsub = new OpenTypeGSUB;\n  file->gsub = gsub;\n\n  uint32_t version = 0;\n  uint16_t offset_script_list = 0;\n  uint16_t offset_feature_list = 0;\n  uint16_t offset_lookup_list = 0;\n  if (!table.ReadU32(&version) ||\n      !table.ReadU16(&offset_script_list) ||\n      !table.ReadU16(&offset_feature_list) ||\n      !table.ReadU16(&offset_lookup_list)) {\n    DROP_THIS_TABLE(\"Incomplete table\");\n    return true;\n  }\n\n  if (version != 0x00010000) {\n    DROP_THIS_TABLE(\"Bad version\");\n    return true;\n  }\n\n  if (offset_lookup_list) {\n    if (offset_lookup_list < kGsubHeaderSize || offset_lookup_list >= length) {\n      DROP_THIS_TABLE(\"Bad lookup list offset in table header\");\n      return true;\n    }\n\n    if (!ParseLookupListTable(file, data + offset_lookup_list,\n                              length - offset_lookup_list,\n                              &kGsubLookupSubtableParser,\n                              &gsub->num_lookups)) {\n      DROP_THIS_TABLE(\"Failed to parse lookup list table\");\n      return true;\n    }\n  }\n\n  uint16_t num_features = 0;\n  if (offset_feature_list) {\n    if (offset_feature_list < kGsubHeaderSize || offset_feature_list >= length) {\n      DROP_THIS_TABLE(\"Bad feature list offset in table header\");\n      return true;\n    }\n\n    if (!ParseFeatureListTable(file, data + offset_feature_list,\n                               length - offset_feature_list, gsub->num_lookups,\n                               &num_features)) {\n      DROP_THIS_TABLE(\"Failed to parse feature list table\");\n      return true;\n    }\n  }\n\n  if (offset_script_list) {\n    if (offset_script_list < kGsubHeaderSize || offset_script_list >= length) {\n      DROP_THIS_TABLE(\"Bad script list offset in table header\");\n      return true;\n    }\n\n    if (!ParseScriptListTable(file, data + offset_script_list,\n                              length - offset_script_list, num_features)) {\n      DROP_THIS_TABLE(\"Failed to parse script list table\");\n      return true;\n    }\n  }\n\n  gsub->data = data;\n  gsub->length = length;\n  return true;\n}\n\nbool ots_gsub_should_serialise(OpenTypeFile *file) {\n  return file->gsub != NULL && file->gsub->data != NULL;\n}\n\nbool ots_gsub_serialise(OTSStream *out, OpenTypeFile *file) {\n  if (!out->Write(file->gsub->data, file->gsub->length)) {\n    return OTS_FAILURE_MSG(\"Failed to write GSUB table\");\n  }\n\n  return true;\n}\n\nvoid ots_gsub_free(OpenTypeFile *file) {\n  delete file->gsub;\n}\n\n}  // namespace ots\n\n#undef TABLE_NAME\n#undef DROP_THIS_TABLE\n", "// Copyright (c) 2009 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n#include \"hdmx.h\"\n#include \"head.h\"\n#include \"maxp.h\"\n\n// hdmx - Horizontal Device Metrics\n// http://www.microsoft.com/typography/otspec/hdmx.htm\n\n#define TABLE_NAME \"hdmx\"\n\n#define DROP_THIS_TABLE(...) \\\n  do { \\\n    OTS_FAILURE_MSG_(file, TABLE_NAME \": \" __VA_ARGS__); \\\n    OTS_FAILURE_MSG(\"Table discarded\"); \\\n    delete file->hdmx; \\\n    file->hdmx = 0; \\\n  } while (0)\n\nnamespace ots {\n\nbool ots_hdmx_parse(OpenTypeFile *file, const uint8_t *data, size_t length) {\n  Buffer table(data, length);\n  file->hdmx = new OpenTypeHDMX;\n  OpenTypeHDMX * const hdmx = file->hdmx;\n\n  if (!file->head || !file->maxp) {\n    return OTS_FAILURE_MSG(\"Missing maxp or head tables in font, needed by hdmx\");\n  }\n\n  if ((file->head->flags & 0x14) == 0) {\n    // http://www.microsoft.com/typography/otspec/recom.htm\n    DROP_THIS_TABLE(\"the table should not be present when bit 2 and 4 of the \"\n                    \"head->flags are not set\");\n    return true;\n  }\n\n  int16_t num_recs;\n  if (!table.ReadU16(&hdmx->version) ||\n      !table.ReadS16(&num_recs) ||\n      !table.ReadS32(&hdmx->size_device_record)) {\n    return OTS_FAILURE_MSG(\"Failed to read hdmx header\");\n  }\n  if (hdmx->version != 0) {\n    DROP_THIS_TABLE(\"bad version: %u\", hdmx->version);\n    return true;\n  }\n  if (num_recs <= 0) {\n    DROP_THIS_TABLE(\"bad num_recs: %d\", num_recs);\n    return true;\n  }\n  const int32_t actual_size_device_record = file->maxp->num_glyphs + 2;\n  if (hdmx->size_device_record < actual_size_device_record) {\n    DROP_THIS_TABLE(\"bad hdmx->size_device_record: %d\", hdmx->size_device_record);\n    return true;\n  }\n\n  hdmx->pad_len = hdmx->size_device_record - actual_size_device_record;\n  if (hdmx->pad_len > 3) {\n    return OTS_FAILURE_MSG(\"Bad padding %d\", hdmx->pad_len);\n  }\n\n  uint8_t last_pixel_size = 0;\n  hdmx->records.reserve(num_recs);\n  for (int i = 0; i < num_recs; ++i) {\n    OpenTypeHDMXDeviceRecord rec;\n\n    if (!table.ReadU8(&rec.pixel_size) ||\n        !table.ReadU8(&rec.max_width)) {\n      return OTS_FAILURE_MSG(\"Failed to read hdmx record %d\", i);\n    }\n    if ((i != 0) &&\n        (rec.pixel_size <= last_pixel_size)) {\n      DROP_THIS_TABLE(\"records are not sorted\");\n      return true;\n    }\n    last_pixel_size = rec.pixel_size;\n\n    rec.widths.reserve(file->maxp->num_glyphs);\n    for (unsigned j = 0; j < file->maxp->num_glyphs; ++j) {\n      uint8_t width;\n      if (!table.ReadU8(&width)) {\n        return OTS_FAILURE_MSG(\"Failed to read glyph width %d in record %d\", j, i);\n      }\n      rec.widths.push_back(width);\n    }\n\n    if ((hdmx->pad_len > 0) &&\n        !table.Skip(hdmx->pad_len)) {\n      return OTS_FAILURE_MSG(\"Failed to skip padding %d\", hdmx->pad_len);\n    }\n\n    hdmx->records.push_back(rec);\n  }\n\n  return true;\n}\n\nbool ots_hdmx_should_serialise(OpenTypeFile *file) {\n  if (!file->hdmx) return false;\n  if (!file->glyf) return false;  // this table is not for CFF fonts.\n  return true;\n}\n\nbool ots_hdmx_serialise(OTSStream *out, OpenTypeFile *file) {\n  OpenTypeHDMX * const hdmx = file->hdmx;\n\n  const int16_t num_recs = static_cast<int16_t>(hdmx->records.size());\n  if (hdmx->records.size() >\n          static_cast<size_t>(std::numeric_limits<int16_t>::max()) ||\n      !out->WriteU16(hdmx->version) ||\n      !out->WriteS16(num_recs) ||\n      !out->WriteS32(hdmx->size_device_record)) {\n    return OTS_FAILURE_MSG(\"Failed to write hdmx header\");\n  }\n\n  for (int16_t i = 0; i < num_recs; ++i) {\n    const OpenTypeHDMXDeviceRecord& rec = hdmx->records[i];\n    if (!out->Write(&rec.pixel_size, 1) ||\n        !out->Write(&rec.max_width, 1) ||\n        !out->Write(&rec.widths[0], rec.widths.size())) {\n      return OTS_FAILURE_MSG(\"Failed to write hdmx record %d\", i);\n    }\n    if ((hdmx->pad_len > 0) &&\n        !out->Write((const uint8_t *)\"\\x00\\x00\\x00\", hdmx->pad_len)) {\n      return OTS_FAILURE_MSG(\"Failed to write hdmx padding of length %d\", hdmx->pad_len);\n    }\n  }\n\n  return true;\n}\n\nvoid ots_hdmx_free(OpenTypeFile *file) {\n  delete file->hdmx;\n}\n\n}  // namespace ots\n\n#undef TABLE_NAME\n#undef DROP_THIS_TABLE\n", "// Copyright (c) 2009 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n#include \"kern.h\"\n\n// kern - Kerning\n// http://www.microsoft.com/typography/otspec/kern.htm\n\n#define TABLE_NAME \"kern\"\n\n#define DROP_THIS_TABLE(msg_) \\\n  do { \\\n    OTS_FAILURE_MSG(msg_ \", table discarded\"); \\\n    delete file->kern; \\\n    file->kern = 0; \\\n  } while (0)\n\nnamespace ots {\n\nbool ots_kern_parse(OpenTypeFile *file, const uint8_t *data, size_t length) {\n  Buffer table(data, length);\n\n  OpenTypeKERN *kern = new OpenTypeKERN;\n  file->kern = kern;\n\n  uint16_t num_tables = 0;\n  if (!table.ReadU16(&kern->version) ||\n      !table.ReadU16(&num_tables)) {\n    return OTS_FAILURE_MSG(\"Failed to read kern header\");\n  }\n\n  if (kern->version > 0) {\n    DROP_THIS_TABLE(\"bad table version\");\n    return true;\n  }\n\n  if (num_tables == 0) {\n    DROP_THIS_TABLE(\"num_tables is zero\");\n    return true;\n  }\n\n  kern->subtables.reserve(num_tables);\n  for (unsigned i = 0; i < num_tables; ++i) {\n    OpenTypeKERNFormat0 subtable;\n    uint16_t sub_length = 0;\n\n    if (!table.ReadU16(&subtable.version) ||\n        !table.ReadU16(&sub_length)) {\n      return OTS_FAILURE_MSG(\"Failed to read kern subtable %d header\", i);\n    }\n\n    if (subtable.version > 0) {\n      OTS_WARNING(\"Bad subtable version: %d\", subtable.version);\n      continue;\n    }\n\n    const size_t current_offset = table.offset();\n    if (current_offset - 4 + sub_length > length) {\n      return OTS_FAILURE_MSG(\"Bad kern subtable %d offset %ld\", i, current_offset);\n    }\n\n    if (!table.ReadU16(&subtable.coverage)) {\n      return OTS_FAILURE_MSG(\"Cailed to read kern subtable %d coverage\", i);\n    }\n\n    if (!(subtable.coverage & 0x1)) {\n      OTS_WARNING(\n          \"We don't support vertical data as the renderer doesn't support it.\");\n      continue;\n    }\n    if (subtable.coverage & 0xF0) {\n      DROP_THIS_TABLE(\"Reserved fields should zero-filled.\");\n      return true;\n    }\n    const uint32_t format = (subtable.coverage & 0xFF00) >> 8;\n    if (format != 0) {\n      OTS_WARNING(\"Format %d is not supported.\", format);\n      continue;\n    }\n\n    // Parse the format 0 field.\n    uint16_t num_pairs = 0;\n    if (!table.ReadU16(&num_pairs) ||\n        !table.ReadU16(&subtable.search_range) ||\n        !table.ReadU16(&subtable.entry_selector) ||\n        !table.ReadU16(&subtable.range_shift)) {\n      return OTS_FAILURE_MSG(\"Failed to read kern subtable %d format 0 fields\", i);\n    }\n\n    if (!num_pairs) {\n      DROP_THIS_TABLE(\"Zero length subtable is found.\");\n      return true;\n    }\n\n    // Sanity checks for search_range, entry_selector, and range_shift. See the\n    // comment in ots.cc for details.\n    const size_t kFormat0PairSize = 6;  // left, right, and value. 2 bytes each.\n    if (num_pairs > (65536 / kFormat0PairSize)) {\n      // Some fonts (e.g. calibri.ttf, pykes_peak_zero.ttf) have pairs >= 10923.\n      DROP_THIS_TABLE(\"Too large subtable.\");\n      return true;\n    }\n    unsigned max_pow2 = 0;\n    while (1u << (max_pow2 + 1) <= num_pairs) {\n      ++max_pow2;\n    }\n    const uint16_t expected_search_range = (1u << max_pow2) * kFormat0PairSize;\n    if (subtable.search_range != expected_search_range) {\n      OTS_WARNING(\"bad search range\");\n      subtable.search_range = expected_search_range;\n    }\n    if (subtable.entry_selector != max_pow2) {\n      return OTS_FAILURE_MSG(\"Bad subtable %d entry selector %d\", i, subtable.entry_selector);\n    }\n    const uint16_t expected_range_shift =\n        kFormat0PairSize * num_pairs - subtable.search_range;\n    if (subtable.range_shift != expected_range_shift) {\n      OTS_WARNING(\"bad range shift\");\n      subtable.range_shift = expected_range_shift;\n    }\n\n    // Read kerning pairs.\n    subtable.pairs.reserve(num_pairs);\n    uint32_t last_pair = 0;\n    for (unsigned j = 0; j < num_pairs; ++j) {\n      OpenTypeKERNFormat0Pair kerning_pair;\n      if (!table.ReadU16(&kerning_pair.left) ||\n          !table.ReadU16(&kerning_pair.right) ||\n          !table.ReadS16(&kerning_pair.value)) {\n        return OTS_FAILURE_MSG(\"Failed to read subtable %d kerning pair %d\", i, j);\n      }\n      const uint32_t current_pair\n          = (kerning_pair.left << 16) + kerning_pair.right;\n      if (j != 0 && current_pair <= last_pair) {\n        // Many free fonts don't follow this rule, so we don't call OTS_FAILURE\n        // in order to support these fonts.\n        DROP_THIS_TABLE(\"Kerning pairs are not sorted.\");\n        return true;\n      }\n      last_pair = current_pair;\n      subtable.pairs.push_back(kerning_pair);\n    }\n\n    kern->subtables.push_back(subtable);\n  }\n\n  if (!kern->subtables.size()) {\n    DROP_THIS_TABLE(\"All subtables are removed.\");\n    return true;\n  }\n\n  return true;\n}\n\nbool ots_kern_should_serialise(OpenTypeFile *file) {\n  if (!file->glyf) return false;  // this table is not for CFF fonts.\n  return file->kern != NULL;\n}\n\nbool ots_kern_serialise(OTSStream *out, OpenTypeFile *file) {\n  const OpenTypeKERN *kern = file->kern;\n\n  const uint16_t num_subtables = static_cast<uint16_t>(kern->subtables.size());\n  if (num_subtables != kern->subtables.size() ||\n      !out->WriteU16(kern->version) ||\n      !out->WriteU16(num_subtables)) {\n    return OTS_FAILURE_MSG(\"Can't write kern table header\");\n  }\n\n  for (uint16_t i = 0; i < num_subtables; ++i) {\n    const size_t length = 14 + (6 * kern->subtables[i].pairs.size());\n    if (length > std::numeric_limits<uint16_t>::max() ||\n        !out->WriteU16(kern->subtables[i].version) ||\n        !out->WriteU16(static_cast<uint16_t>(length)) ||\n        !out->WriteU16(kern->subtables[i].coverage) ||\n        !out->WriteU16(\n            static_cast<uint16_t>(kern->subtables[i].pairs.size())) ||\n        !out->WriteU16(kern->subtables[i].search_range) ||\n        !out->WriteU16(kern->subtables[i].entry_selector) ||\n        !out->WriteU16(kern->subtables[i].range_shift)) {\n      return OTS_FAILURE_MSG(\"Failed to write kern subtable %d\", i);\n    }\n    for (unsigned j = 0; j < kern->subtables[i].pairs.size(); ++j) {\n      if (!out->WriteU16(kern->subtables[i].pairs[j].left) ||\n          !out->WriteU16(kern->subtables[i].pairs[j].right) ||\n          !out->WriteS16(kern->subtables[i].pairs[j].value)) {\n        return OTS_FAILURE_MSG(\"Failed to write kern pair %d for subtable %d\", j, i);\n      }\n    }\n  }\n\n  return true;\n}\n\nvoid ots_kern_free(OpenTypeFile *file) {\n  delete file->kern;\n}\n\n}  // namespace ots\n\n#undef TABLE_NAME\n#undef DROP_THIS_TABLE\n", "// Copyright (c) 2009 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n#include \"ltsh.h\"\n\n#include \"maxp.h\"\n\n// LTSH - Linear Threshold\n// http://www.microsoft.com/typography/otspec/ltsh.htm\n\n#define TABLE_NAME \"LTSH\"\n\n#define DROP_THIS_TABLE(...) \\\n  do { \\\n    OTS_FAILURE_MSG_(file, TABLE_NAME \": \" __VA_ARGS__); \\\n    OTS_FAILURE_MSG(\"Table discarded\"); \\\n    delete file->ltsh; \\\n    file->ltsh = 0; \\\n  } while (0)\n\nnamespace ots {\n\nbool ots_ltsh_parse(OpenTypeFile *file, const uint8_t *data, size_t length) {\n  Buffer table(data, length);\n\n  if (!file->maxp) {\n    return OTS_FAILURE_MSG(\"Missing maxp table from font needed by ltsh\");\n  }\n\n  OpenTypeLTSH *ltsh = new OpenTypeLTSH;\n  file->ltsh = ltsh;\n\n  uint16_t num_glyphs = 0;\n  if (!table.ReadU16(&ltsh->version) ||\n      !table.ReadU16(&num_glyphs)) {\n    return OTS_FAILURE_MSG(\"Failed to read ltsh header\");\n  }\n\n  if (ltsh->version != 0) {\n    DROP_THIS_TABLE(\"bad version: %u\", ltsh->version);\n    return true;\n  }\n\n  if (num_glyphs != file->maxp->num_glyphs) {\n    DROP_THIS_TABLE(\"bad num_glyphs: %u\", num_glyphs);\n    return true;\n  }\n\n  ltsh->ypels.reserve(num_glyphs);\n  for (unsigned i = 0; i < num_glyphs; ++i) {\n    uint8_t pel = 0;\n    if (!table.ReadU8(&pel)) {\n      return OTS_FAILURE_MSG(\"Failed to read pixels for glyph %d\", i);\n    }\n    ltsh->ypels.push_back(pel);\n  }\n\n  return true;\n}\n\nbool ots_ltsh_should_serialise(OpenTypeFile *file) {\n  if (!file->glyf) return false;  // this table is not for CFF fonts.\n  return file->ltsh != NULL;\n}\n\nbool ots_ltsh_serialise(OTSStream *out, OpenTypeFile *file) {\n  const OpenTypeLTSH *ltsh = file->ltsh;\n\n  const uint16_t num_ypels = static_cast<uint16_t>(ltsh->ypels.size());\n  if (num_ypels != ltsh->ypels.size() ||\n      !out->WriteU16(ltsh->version) ||\n      !out->WriteU16(num_ypels)) {\n    return OTS_FAILURE_MSG(\"Failed to write pels size\");\n  }\n  for (uint16_t i = 0; i < num_ypels; ++i) {\n    if (!out->Write(&(ltsh->ypels[i]), 1)) {\n      return OTS_FAILURE_MSG(\"Failed to write pixel size for glyph %d\", i);\n    }\n  }\n\n  return true;\n}\n\nvoid ots_ltsh_free(OpenTypeFile *file) {\n  delete file->ltsh;\n}\n\n}  // namespace ots\n\n#undef TABLE_NAME\n#undef DROP_THIS_TABLE\n", "// Copyright (c) 2014 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n// We use an underscore to avoid confusion with the standard math.h library.\n#include \"math_.h\"\n\n#include <limits>\n#include <vector>\n\n#include \"layout.h\"\n#include \"maxp.h\"\n\n// MATH - The MATH Table\n// The specification is not yet public but has been submitted to the MPEG group\n// in response to the 'Call for Proposals for ISO/IEC 14496-22 \"Open Font\n// Format\" Color Font Technology and MATH layout support'. Meanwhile, you can\n// contact Microsoft's engineer Murray Sargent to obtain a copy.\n\n#define TABLE_NAME \"MATH\"\n\nnamespace {\n\n// The size of MATH header.\n// Version\n// MathConstants\n// MathGlyphInfo\n// MathVariants\nconst unsigned kMathHeaderSize = 4 + 3 * 2;\n\n// The size of the MathGlyphInfo header.\n// MathItalicsCorrectionInfo\n// MathTopAccentAttachment\n// ExtendedShapeCoverage\n// MathKernInfo\nconst unsigned kMathGlyphInfoHeaderSize = 4 * 2;\n\n// The size of the MathValueRecord.\n// Value\n// DeviceTable\nconst unsigned kMathValueRecordSize = 2 * 2;\n\n// The size of the GlyphPartRecord.\n// glyph\n// StartConnectorLength\n// EndConnectorLength\n// FullAdvance\n// PartFlags\nconst unsigned kGlyphPartRecordSize = 5 * 2;\n\n// Shared Table: MathValueRecord\n\nbool ParseMathValueRecord(const ots::OpenTypeFile *file,\n                          ots::Buffer* subtable, const uint8_t *data,\n                          const size_t length) {\n  // Check the Value field.\n  if (!subtable->Skip(2)) {\n    return OTS_FAILURE();\n  }\n\n  // Check the offset to device table.\n  uint16_t offset = 0;\n  if (!subtable->ReadU16(&offset)) {\n    return OTS_FAILURE();\n  }\n  if (offset) {\n    if (offset >= length) {\n      return OTS_FAILURE();\n    }\n    if (!ots::ParseDeviceTable(file, data + offset, length - offset)) {\n      return OTS_FAILURE();\n    }\n  }\n\n  return true;\n}\n\nbool ParseMathConstantsTable(const ots::OpenTypeFile *file,\n                             const uint8_t *data, size_t length) {\n  ots::Buffer subtable(data, length);\n\n  // Part 1: int16 or uint16 constants.\n  //  ScriptPercentScaleDown\n  //  ScriptScriptPercentScaleDown\n  //  DelimitedSubFormulaMinHeight\n  //  DisplayOperatorMinHeight\n  if (!subtable.Skip(4 * 2)) {\n    return OTS_FAILURE();\n  }\n\n  // Part 2: MathValueRecord constants.\n  // MathLeading\n  // AxisHeight\n  // AccentBaseHeight\n  // FlattenedAccentBaseHeight\n  // SubscriptShiftDown\n  // SubscriptTopMax\n  // SubscriptBaselineDropMin\n  // SuperscriptShiftUp\n  // SuperscriptShiftUpCramped\n  // SuperscriptBottomMin\n  //\n  // SuperscriptBaselineDropMax\n  // SubSuperscriptGapMin\n  // SuperscriptBottomMaxWithSubscript\n  // SpaceAfterScript\n  // UpperLimitGapMin\n  // UpperLimitBaselineRiseMin\n  // LowerLimitGapMin\n  // LowerLimitBaselineDropMin\n  // StackTopShiftUp\n  // StackTopDisplayStyleShiftUp\n  //\n  // StackBottomShiftDown\n  // StackBottomDisplayStyleShiftDown\n  // StackGapMin\n  // StackDisplayStyleGapMin\n  // StretchStackTopShiftUp\n  // StretchStackBottomShiftDown\n  // StretchStackGapAboveMin\n  // StretchStackGapBelowMin\n  // FractionNumeratorShiftUp\n  // FractionNumeratorDisplayStyleShiftUp\n  //\n  // FractionDenominatorShiftDown\n  // FractionDenominatorDisplayStyleShiftDown\n  // FractionNumeratorGapMin\n  // FractionNumDisplayStyleGapMin\n  // FractionRuleThickness\n  // FractionDenominatorGapMin\n  // FractionDenomDisplayStyleGapMin\n  // SkewedFractionHorizontalGap\n  // SkewedFractionVerticalGap\n  // OverbarVerticalGap\n  //\n  // OverbarRuleThickness\n  // OverbarExtraAscender\n  // UnderbarVerticalGap\n  // UnderbarRuleThickness\n  // UnderbarExtraDescender\n  // RadicalVerticalGap\n  // RadicalDisplayStyleVerticalGap\n  // RadicalRuleThickness\n  // RadicalExtraAscender\n  // RadicalKernBeforeDegree\n  //\n  // RadicalKernAfterDegree\n  for (unsigned i = 0; i < static_cast<unsigned>(51); ++i) {\n    if (!ParseMathValueRecord(file, &subtable, data, length)) {\n      return OTS_FAILURE();\n    }\n  }\n\n  // Part 3: uint16 constant\n  // RadicalDegreeBottomRaisePercent\n  if (!subtable.Skip(2)) {\n    return OTS_FAILURE();\n  }\n\n  return true;\n}\n\nbool ParseMathValueRecordSequenceForGlyphs(const ots::OpenTypeFile *file,\n                                           ots::Buffer* subtable,\n                                           const uint8_t *data,\n                                           const size_t length,\n                                           const uint16_t num_glyphs) {\n  // Check the header.\n  uint16_t offset_coverage = 0;\n  uint16_t sequence_count = 0;\n  if (!subtable->ReadU16(&offset_coverage) ||\n      !subtable->ReadU16(&sequence_count)) {\n    return OTS_FAILURE();\n  }\n\n  const unsigned sequence_end = static_cast<unsigned>(2 * 2) +\n      sequence_count * kMathValueRecordSize;\n  if (sequence_end > std::numeric_limits<uint16_t>::max()) {\n    return OTS_FAILURE();\n  }\n\n  // Check coverage table.\n  if (offset_coverage < sequence_end || offset_coverage >= length) {\n    return OTS_FAILURE();\n  }\n  if (!ots::ParseCoverageTable(file, data + offset_coverage,\n                               length - offset_coverage,\n                               num_glyphs, sequence_count)) {\n    return OTS_FAILURE();\n  }\n\n  // Check sequence.\n  for (unsigned i = 0; i < sequence_count; ++i) {\n    if (!ParseMathValueRecord(file, subtable, data, length)) {\n      return OTS_FAILURE();\n    }\n  }\n\n  return true;\n}\n\nbool ParseMathItalicsCorrectionInfoTable(const ots::OpenTypeFile *file,\n                                         const uint8_t *data,\n                                         size_t length,\n                                         const uint16_t num_glyphs) {\n  ots::Buffer subtable(data, length);\n  return ParseMathValueRecordSequenceForGlyphs(file, &subtable, data, length,\n                                               num_glyphs);\n}\n\nbool ParseMathTopAccentAttachmentTable(const ots::OpenTypeFile *file,\n                                       const uint8_t *data,\n                                       size_t length,\n                                       const uint16_t num_glyphs) {\n  ots::Buffer subtable(data, length);\n  return ParseMathValueRecordSequenceForGlyphs(file, &subtable, data, length,\n                                               num_glyphs);\n}\n\nbool ParseMathKernTable(const ots::OpenTypeFile *file,\n                        const uint8_t *data, size_t length) {\n  ots::Buffer subtable(data, length);\n\n  // Check the Height count.\n  uint16_t height_count = 0;\n  if (!subtable.ReadU16(&height_count)) {\n    return OTS_FAILURE();\n  }\n\n  // Check the Correction Heights.\n  for (unsigned i = 0; i < height_count; ++i) {\n    if (!ParseMathValueRecord(file, &subtable, data, length)) {\n      return OTS_FAILURE();\n    }\n  }\n\n  // Check the Kern Values.\n  for (unsigned i = 0; i <= height_count; ++i) {\n    if (!ParseMathValueRecord(file, &subtable, data, length)) {\n      return OTS_FAILURE();\n    }\n  }\n\n  return true;\n}\n\nbool ParseMathKernInfoTable(const ots::OpenTypeFile *file,\n                            const uint8_t *data, size_t length,\n                            const uint16_t num_glyphs) {\n  ots::Buffer subtable(data, length);\n\n  // Check the header.\n  uint16_t offset_coverage = 0;\n  uint16_t sequence_count = 0;\n  if (!subtable.ReadU16(&offset_coverage) ||\n      !subtable.ReadU16(&sequence_count)) {\n    return OTS_FAILURE();\n  }\n\n  const unsigned sequence_end = static_cast<unsigned>(2 * 2) +\n    sequence_count * 4 * 2;\n  if (sequence_end > std::numeric_limits<uint16_t>::max()) {\n    return OTS_FAILURE();\n  }\n\n  // Check coverage table.\n  if (offset_coverage < sequence_end || offset_coverage >= length) {\n    return OTS_FAILURE();\n  }\n  if (!ots::ParseCoverageTable(file, data + offset_coverage, length - offset_coverage,\n                               num_glyphs, sequence_count)) {\n    return OTS_FAILURE();\n  }\n\n  // Check sequence of MathKernInfoRecord\n  for (unsigned i = 0; i < sequence_count; ++i) {\n    // Check TopRight, TopLeft, BottomRight and BottomLeft Math Kern.\n    for (unsigned j = 0; j < 4; ++j) {\n      uint16_t offset_math_kern = 0;\n      if (!subtable.ReadU16(&offset_math_kern)) {\n        return OTS_FAILURE();\n      }\n      if (offset_math_kern) {\n        if (offset_math_kern < sequence_end || offset_math_kern >= length ||\n            !ParseMathKernTable(file, data + offset_math_kern,\n                                length - offset_math_kern)) {\n          return OTS_FAILURE();\n        }\n      }\n    }\n  }\n\n  return true;\n}\n\nbool ParseMathGlyphInfoTable(const ots::OpenTypeFile *file,\n                             const uint8_t *data, size_t length,\n                             const uint16_t num_glyphs) {\n  ots::Buffer subtable(data, length);\n\n  // Check Header.\n  uint16_t offset_math_italics_correction_info = 0;\n  uint16_t offset_math_top_accent_attachment = 0;\n  uint16_t offset_extended_shaped_coverage = 0;\n  uint16_t offset_math_kern_info = 0;\n  if (!subtable.ReadU16(&offset_math_italics_correction_info) ||\n      !subtable.ReadU16(&offset_math_top_accent_attachment) ||\n      !subtable.ReadU16(&offset_extended_shaped_coverage) ||\n      !subtable.ReadU16(&offset_math_kern_info)) {\n    return OTS_FAILURE();\n  }\n\n  // Check subtables.\n  // The specification does not say whether the offsets for\n  // MathItalicsCorrectionInfo, MathTopAccentAttachment and MathKernInfo may\n  // be NULL, but that's the case in some fonts (e.g STIX) so we accept that.\n  if (offset_math_italics_correction_info) {\n    if (offset_math_italics_correction_info >= length ||\n        offset_math_italics_correction_info < kMathGlyphInfoHeaderSize ||\n        !ParseMathItalicsCorrectionInfoTable(\n            file, data + offset_math_italics_correction_info,\n            length - offset_math_italics_correction_info,\n            num_glyphs)) {\n      return OTS_FAILURE();\n    }\n  }\n  if (offset_math_top_accent_attachment) {\n    if (offset_math_top_accent_attachment >= length ||\n        offset_math_top_accent_attachment < kMathGlyphInfoHeaderSize ||\n        !ParseMathTopAccentAttachmentTable(file, data +\n                                           offset_math_top_accent_attachment,\n                                           length -\n                                           offset_math_top_accent_attachment,\n                                           num_glyphs)) {\n      return OTS_FAILURE();\n    }\n  }\n  if (offset_extended_shaped_coverage) {\n    if (offset_extended_shaped_coverage >= length ||\n        offset_extended_shaped_coverage < kMathGlyphInfoHeaderSize ||\n        !ots::ParseCoverageTable(file, data + offset_extended_shaped_coverage,\n                                 length - offset_extended_shaped_coverage,\n                                 num_glyphs)) {\n      return OTS_FAILURE();\n    }\n  }\n  if (offset_math_kern_info) {\n    if (offset_math_kern_info >= length ||\n        offset_math_kern_info < kMathGlyphInfoHeaderSize ||\n        !ParseMathKernInfoTable(file, data + offset_math_kern_info,\n                                length - offset_math_kern_info, num_glyphs)) {\n      return OTS_FAILURE();\n    }\n  }\n\n  return true;\n}\n\nbool ParseGlyphAssemblyTable(const ots::OpenTypeFile *file,\n                             const uint8_t *data,\n                             size_t length, const uint16_t num_glyphs) {\n  ots::Buffer subtable(data, length);\n\n  // Check the header.\n  uint16_t part_count = 0;\n  if (!ParseMathValueRecord(file, &subtable, data, length) ||\n      !subtable.ReadU16(&part_count)) {\n    return OTS_FAILURE();\n  }\n\n  const unsigned sequence_end = kMathValueRecordSize +\n    static_cast<unsigned>(2) + part_count * kGlyphPartRecordSize;\n  if (sequence_end > std::numeric_limits<uint16_t>::max()) {\n    return OTS_FAILURE();\n  }\n\n  // Check the sequence of GlyphPartRecord.\n  for (unsigned i = 0; i < part_count; ++i) {\n    uint16_t glyph = 0;\n    uint16_t part_flags = 0;\n    if (!subtable.ReadU16(&glyph) ||\n        !subtable.Skip(2 * 3) ||\n        !subtable.ReadU16(&part_flags)) {\n      return OTS_FAILURE();\n    }\n    if (glyph >= num_glyphs) {\n      return OTS_FAILURE_MSG(\"bad glyph ID: %u\", glyph);\n    }\n    if (part_flags & ~0x00000001) {\n      return OTS_FAILURE_MSG(\"unknown part flag: %u\", part_flags);\n    }\n  }\n\n  return true;\n}\n\nbool ParseMathGlyphConstructionTable(const ots::OpenTypeFile *file,\n                                     const uint8_t *data,\n                                     size_t length, const uint16_t num_glyphs) {\n  ots::Buffer subtable(data, length);\n\n  // Check the header.\n  uint16_t offset_glyph_assembly = 0;\n  uint16_t variant_count = 0;\n  if (!subtable.ReadU16(&offset_glyph_assembly) ||\n      !subtable.ReadU16(&variant_count)) {\n    return OTS_FAILURE();\n  }\n\n  const unsigned sequence_end = static_cast<unsigned>(2 * 2) +\n    variant_count * 2 * 2;\n  if (sequence_end > std::numeric_limits<uint16_t>::max()) {\n    return OTS_FAILURE();\n  }\n\n  // Check the GlyphAssembly offset.\n  if (offset_glyph_assembly) {\n    if (offset_glyph_assembly >= length ||\n        offset_glyph_assembly < sequence_end) {\n      return OTS_FAILURE();\n    }\n    if (!ParseGlyphAssemblyTable(file, data + offset_glyph_assembly,\n                                 length - offset_glyph_assembly, num_glyphs)) {\n      return OTS_FAILURE();\n    }\n  }\n\n  // Check the sequence of MathGlyphVariantRecord.\n  for (unsigned i = 0; i < variant_count; ++i) {\n    uint16_t glyph = 0;\n    if (!subtable.ReadU16(&glyph) ||\n        !subtable.Skip(2)) {\n      return OTS_FAILURE();\n    }\n    if (glyph >= num_glyphs) {\n      return OTS_FAILURE_MSG(\"bad glyph ID: %u\", glyph);\n    }\n  }\n\n  return true;\n}\n\nbool ParseMathGlyphConstructionSequence(const ots::OpenTypeFile *file,\n                                        ots::Buffer* subtable,\n                                        const uint8_t *data,\n                                        size_t length,\n                                        const uint16_t num_glyphs,\n                                        uint16_t offset_coverage,\n                                        uint16_t glyph_count,\n                                        const unsigned sequence_end) {\n  // Check coverage table.\n  if (offset_coverage < sequence_end || offset_coverage >= length) {\n    return OTS_FAILURE();\n  }\n  if (!ots::ParseCoverageTable(file, data + offset_coverage,\n                               length - offset_coverage,\n                               num_glyphs, glyph_count)) {\n    return OTS_FAILURE();\n  }\n\n  // Check sequence of MathGlyphConstruction.\n  for (unsigned i = 0; i < glyph_count; ++i) {\n      uint16_t offset_glyph_construction = 0;\n      if (!subtable->ReadU16(&offset_glyph_construction)) {\n        return OTS_FAILURE();\n      }\n      if (offset_glyph_construction < sequence_end ||\n          offset_glyph_construction >= length ||\n          !ParseMathGlyphConstructionTable(file, data + offset_glyph_construction,\n                                           length - offset_glyph_construction,\n                                           num_glyphs)) {\n        return OTS_FAILURE();\n      }\n  }\n\n  return true;\n}\n\nbool ParseMathVariantsTable(const ots::OpenTypeFile *file,\n                            const uint8_t *data,\n                            size_t length, const uint16_t num_glyphs) {\n  ots::Buffer subtable(data, length);\n\n  // Check the header.\n  uint16_t offset_vert_glyph_coverage = 0;\n  uint16_t offset_horiz_glyph_coverage = 0;\n  uint16_t vert_glyph_count = 0;\n  uint16_t horiz_glyph_count = 0;\n  if (!subtable.Skip(2) ||  // MinConnectorOverlap\n      !subtable.ReadU16(&offset_vert_glyph_coverage) ||\n      !subtable.ReadU16(&offset_horiz_glyph_coverage) ||\n      !subtable.ReadU16(&vert_glyph_count) ||\n      !subtable.ReadU16(&horiz_glyph_count)) {\n    return OTS_FAILURE();\n  }\n\n  const unsigned sequence_end = 5 * 2 + vert_glyph_count * 2 +\n    horiz_glyph_count * 2;\n  if (sequence_end > std::numeric_limits<uint16_t>::max()) {\n    return OTS_FAILURE();\n  }\n\n  if (!ParseMathGlyphConstructionSequence(file, &subtable, data, length, num_glyphs,\n                                          offset_vert_glyph_coverage,\n                                          vert_glyph_count,\n                                          sequence_end) ||\n      !ParseMathGlyphConstructionSequence(file, &subtable, data, length, num_glyphs,\n                                          offset_horiz_glyph_coverage,\n                                          horiz_glyph_count,\n                                          sequence_end)) {\n    return OTS_FAILURE();\n  }\n\n  return true;\n}\n\n}  // namespace\n\n#define DROP_THIS_TABLE(msg_) \\\n  do { \\\n    OTS_FAILURE_MSG(msg_ \", table discarded\"); \\\n    file->math->data = 0; \\\n    file->math->length = 0; \\\n  } while (0)\n\nnamespace ots {\n\nbool ots_math_parse(OpenTypeFile *file, const uint8_t *data, size_t length) {\n  // Grab the number of glyphs in the file from the maxp table to check\n  // GlyphIDs in MATH table.\n  if (!file->maxp) {\n    return OTS_FAILURE();\n  }\n  const uint16_t num_glyphs = file->maxp->num_glyphs;\n\n  Buffer table(data, length);\n\n  OpenTypeMATH* math = new OpenTypeMATH;\n  file->math = math;\n\n  uint32_t version = 0;\n  if (!table.ReadU32(&version)) {\n    return OTS_FAILURE();\n  }\n  if (version != 0x00010000) {\n    DROP_THIS_TABLE(\"bad MATH version\");\n    return true;\n  }\n\n  uint16_t offset_math_constants = 0;\n  uint16_t offset_math_glyph_info = 0;\n  uint16_t offset_math_variants = 0;\n  if (!table.ReadU16(&offset_math_constants) ||\n      !table.ReadU16(&offset_math_glyph_info) ||\n      !table.ReadU16(&offset_math_variants)) {\n    return OTS_FAILURE();\n  }\n\n  if (offset_math_constants >= length ||\n      offset_math_constants < kMathHeaderSize ||\n      offset_math_glyph_info >= length ||\n      offset_math_glyph_info < kMathHeaderSize ||\n      offset_math_variants >= length ||\n      offset_math_variants < kMathHeaderSize) {\n    DROP_THIS_TABLE(\"bad offset in MATH header\");\n    return true;\n  }\n\n  if (!ParseMathConstantsTable(file, data + offset_math_constants,\n                               length - offset_math_constants)) {\n    DROP_THIS_TABLE(\"failed to parse MathConstants table\");\n    return true;\n  }\n  if (!ParseMathGlyphInfoTable(file, data + offset_math_glyph_info,\n                               length - offset_math_glyph_info, num_glyphs)) {\n    DROP_THIS_TABLE(\"failed to parse MathGlyphInfo table\");\n    return true;\n  }\n  if (!ParseMathVariantsTable(file, data + offset_math_variants,\n                              length - offset_math_variants, num_glyphs)) {\n    DROP_THIS_TABLE(\"failed to parse MathVariants table\");\n    return true;\n  }\n\n  math->data = data;\n  math->length = length;\n  return true;\n}\n\nbool ots_math_should_serialise(OpenTypeFile *file) {\n  return file->math != NULL && file->math->data != NULL;\n}\n\nbool ots_math_serialise(OTSStream *out, OpenTypeFile *file) {\n  if (!out->Write(file->math->data, file->math->length)) {\n    return OTS_FAILURE();\n  }\n\n  return true;\n}\n\nvoid ots_math_free(OpenTypeFile *file) {\n  delete file->math;\n}\n\n}  // namespace ots\n\n#undef TABLE_NAME\n#undef DROP_THIS_TABLE\n", "// Copyright (c) 2009 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n#include \"vdmx.h\"\n\n// VDMX - Vertical Device Metrics\n// http://www.microsoft.com/typography/otspec/vdmx.htm\n\n#define TABLE_NAME \"VDMX\"\n\n#define DROP_THIS_TABLE(...) \\\n  do { \\\n    OTS_FAILURE_MSG_(file, TABLE_NAME \": \" __VA_ARGS__); \\\n    OTS_FAILURE_MSG(\"Table discarded\"); \\\n    delete file->vdmx; \\\n    file->vdmx = 0; \\\n  } while (0)\n\nnamespace ots {\n\nbool ots_vdmx_parse(OpenTypeFile *file, const uint8_t *data, size_t length) {\n  Buffer table(data, length);\n  file->vdmx = new OpenTypeVDMX;\n  OpenTypeVDMX * const vdmx = file->vdmx;\n\n  if (!table.ReadU16(&vdmx->version) ||\n      !table.ReadU16(&vdmx->num_recs) ||\n      !table.ReadU16(&vdmx->num_ratios)) {\n    return OTS_FAILURE_MSG(\"Failed to read table header\");\n  }\n\n  if (vdmx->version > 1) {\n    DROP_THIS_TABLE(\"bad version: %u\", vdmx->version);\n    return true;  // continue transcoding\n  }\n\n  vdmx->rat_ranges.reserve(vdmx->num_ratios);\n  for (unsigned i = 0; i < vdmx->num_ratios; ++i) {\n    OpenTypeVDMXRatioRecord rec;\n\n    if (!table.ReadU8(&rec.charset) ||\n        !table.ReadU8(&rec.x_ratio) ||\n        !table.ReadU8(&rec.y_start_ratio) ||\n        !table.ReadU8(&rec.y_end_ratio)) {\n      return OTS_FAILURE_MSG(\"Failed to read ratio header %d\", i);\n    }\n\n    if (rec.charset > 1) {\n      DROP_THIS_TABLE(\"bad charset: %u\", rec.charset);\n      return true;\n    }\n\n    if (rec.y_start_ratio > rec.y_end_ratio) {\n      DROP_THIS_TABLE(\"bad y ratio\");\n      return true;\n    }\n\n    // All values set to zero signal the default grouping to use;\n    // if present, this must be the last Ratio group in the table.\n    if ((i < vdmx->num_ratios - 1u) &&\n        (rec.x_ratio == 0) &&\n        (rec.y_start_ratio == 0) &&\n        (rec.y_end_ratio == 0)) {\n      // workaround for fonts which have 2 or more {0, 0, 0} terminators.\n      DROP_THIS_TABLE(\"superfluous terminator found\");\n      return true;\n    }\n\n    vdmx->rat_ranges.push_back(rec);\n  }\n\n  vdmx->offsets.reserve(vdmx->num_ratios);\n  const size_t current_offset = table.offset();\n  // current_offset is less than (2 bytes * 3) + (4 bytes * USHRT_MAX) = 256k.\n  for (unsigned i = 0; i < vdmx->num_ratios; ++i) {\n    uint16_t offset;\n    if (!table.ReadU16(&offset)) {\n      return OTS_FAILURE_MSG(\"Failed to read ratio offset %d\", i);\n    }\n    if (current_offset + offset >= length) {  // thus doesn't overflow.\n      return OTS_FAILURE_MSG(\"Bad ratio offset %d for ration %d\", offset, i);\n    }\n\n    vdmx->offsets.push_back(offset);\n  }\n\n  vdmx->groups.reserve(vdmx->num_recs);\n  for (unsigned i = 0; i < vdmx->num_recs; ++i) {\n    OpenTypeVDMXGroup group;\n    if (!table.ReadU16(&group.recs) ||\n        !table.ReadU8(&group.startsz) ||\n        !table.ReadU8(&group.endsz)) {\n      return OTS_FAILURE_MSG(\"Failed to read record header %d\", i);\n    }\n    group.entries.reserve(group.recs);\n    for (unsigned j = 0; j < group.recs; ++j) {\n      OpenTypeVDMXVTable vt;\n      if (!table.ReadU16(&vt.y_pel_height) ||\n          !table.ReadS16(&vt.y_max) ||\n          !table.ReadS16(&vt.y_min)) {\n        return OTS_FAILURE_MSG(\"Failed to read reacord %d group %d\", i, j);\n      }\n      if (vt.y_max < vt.y_min) {\n        DROP_THIS_TABLE(\"bad y min/max\");\n        return true;\n      }\n\n      // This table must appear in sorted order (sorted by yPelHeight),\n      // but need not be continuous.\n      if ((j != 0) && (group.entries[j - 1].y_pel_height >= vt.y_pel_height)) {\n        DROP_THIS_TABLE(\"the table is not sorted\");\n        return true;\n      }\n\n      group.entries.push_back(vt);\n    }\n    vdmx->groups.push_back(group);\n  }\n\n  return true;\n}\n\nbool ots_vdmx_should_serialise(OpenTypeFile *file) {\n  if (!file->glyf) return false;  // this table is not for CFF fonts.\n  return file->vdmx != NULL;\n}\n\nbool ots_vdmx_serialise(OTSStream *out, OpenTypeFile *file) {\n  OpenTypeVDMX * const vdmx = file->vdmx;\n\n  if (!out->WriteU16(vdmx->version) ||\n      !out->WriteU16(vdmx->num_recs) ||\n      !out->WriteU16(vdmx->num_ratios)) {\n    return OTS_FAILURE_MSG(\"Failed to write table header\");\n  }\n\n  for (unsigned i = 0; i < vdmx->rat_ranges.size(); ++i) {\n    const OpenTypeVDMXRatioRecord& rec = vdmx->rat_ranges[i];\n    if (!out->Write(&rec.charset, 1) ||\n        !out->Write(&rec.x_ratio, 1) ||\n        !out->Write(&rec.y_start_ratio, 1) ||\n        !out->Write(&rec.y_end_ratio, 1)) {\n      return OTS_FAILURE_MSG(\"Failed to write ratio %d\", i);\n    }\n  }\n\n  for (unsigned i = 0; i < vdmx->offsets.size(); ++i) {\n    if (!out->WriteU16(vdmx->offsets[i])) {\n      return OTS_FAILURE_MSG(\"Failed to write ratio offset %d\", i);\n    }\n  }\n\n  for (unsigned i = 0; i < vdmx->groups.size(); ++i) {\n    const OpenTypeVDMXGroup& group = vdmx->groups[i];\n    if (!out->WriteU16(group.recs) ||\n        !out->Write(&group.startsz, 1) ||\n        !out->Write(&group.endsz, 1)) {\n      return OTS_FAILURE_MSG(\"Failed to write group %d\", i);\n    }\n    for (unsigned j = 0; j < group.entries.size(); ++j) {\n      const OpenTypeVDMXVTable& vt = group.entries[j];\n      if (!out->WriteU16(vt.y_pel_height) ||\n          !out->WriteS16(vt.y_max) ||\n          !out->WriteS16(vt.y_min)) {\n        return OTS_FAILURE_MSG(\"Failed to write group %d entry %d\", i, j);\n      }\n    }\n  }\n\n  return true;\n}\n\nvoid ots_vdmx_free(OpenTypeFile *file) {\n  delete file->vdmx;\n}\n\n}  // namespace ots\n\n#undef TABLE_NAME\n#undef DROP_THIS_TABLE\n", "// Copyright (c) 2009 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n#include \"vorg.h\"\n\n#include <vector>\n\n// VORG - Vertical Origin Table\n// http://www.microsoft.com/typography/otspec/vorg.htm\n\n#define TABLE_NAME \"VORG\"\n\n#define DROP_THIS_TABLE(...) \\\n  do { \\\n    OTS_FAILURE_MSG_(file, TABLE_NAME \": \" __VA_ARGS__); \\\n    OTS_FAILURE_MSG(\"Table discarded\"); \\\n    delete file->vorg; \\\n    file->vorg = 0; \\\n  } while (0)\n\nnamespace ots {\n\nbool ots_vorg_parse(OpenTypeFile *file, const uint8_t *data, size_t length) {\n  Buffer table(data, length);\n  file->vorg = new OpenTypeVORG;\n  OpenTypeVORG * const vorg = file->vorg;\n\n  uint16_t num_recs;\n  if (!table.ReadU16(&vorg->major_version) ||\n      !table.ReadU16(&vorg->minor_version) ||\n      !table.ReadS16(&vorg->default_vert_origin_y) ||\n      !table.ReadU16(&num_recs)) {\n    return OTS_FAILURE_MSG(\"Failed to read header\");\n  }\n  if (vorg->major_version != 1) {\n    DROP_THIS_TABLE(\"bad major version: %u\", vorg->major_version);\n    return true;\n  }\n  if (vorg->minor_version != 0) {\n    DROP_THIS_TABLE(\"bad minor version: %u\", vorg->minor_version);\n    return true;\n  }\n\n  // num_recs might be zero (e.g., DFHSMinchoPro5-W3-Demo.otf).\n  if (!num_recs) {\n    return true;\n  }\n\n  uint16_t last_glyph_index = 0;\n  vorg->metrics.reserve(num_recs);\n  for (unsigned i = 0; i < num_recs; ++i) {\n    OpenTypeVORGMetrics rec;\n\n    if (!table.ReadU16(&rec.glyph_index) ||\n        !table.ReadS16(&rec.vert_origin_y)) {\n      return OTS_FAILURE_MSG(\"Failed to read record %d\", i);\n    }\n    if ((i != 0) && (rec.glyph_index <= last_glyph_index)) {\n      DROP_THIS_TABLE(\"the table is not sorted\");\n      return true;\n    }\n    last_glyph_index = rec.glyph_index;\n\n    vorg->metrics.push_back(rec);\n  }\n\n  return true;\n}\n\nbool ots_vorg_should_serialise(OpenTypeFile *file) {\n  if (!file->cff) return false;  // this table is not for fonts with TT glyphs.\n  return file->vorg != NULL;\n}\n\nbool ots_vorg_serialise(OTSStream *out, OpenTypeFile *file) {\n  OpenTypeVORG * const vorg = file->vorg;\n  \n  const uint16_t num_metrics = static_cast<uint16_t>(vorg->metrics.size());\n  if (num_metrics != vorg->metrics.size() ||\n      !out->WriteU16(vorg->major_version) ||\n      !out->WriteU16(vorg->minor_version) ||\n      !out->WriteS16(vorg->default_vert_origin_y) ||\n      !out->WriteU16(num_metrics)) {\n    return OTS_FAILURE_MSG(\"Failed to write table header\");\n  }\n\n  for (uint16_t i = 0; i < num_metrics; ++i) {\n    const OpenTypeVORGMetrics& rec = vorg->metrics[i];\n    if (!out->WriteU16(rec.glyph_index) ||\n        !out->WriteS16(rec.vert_origin_y)) {\n      return OTS_FAILURE_MSG(\"Failed to write record %d\", i);\n    }\n  }\n\n  return true;\n}\n\nvoid ots_vorg_free(OpenTypeFile *file) {\n  delete file->vorg;\n}\n\n}  // namespace ots\n\n#undef TABLE_NAME\n#undef DROP_THIS_TABLE\n"], "filenames": ["src/gasp.cc", "src/gdef.cc", "src/gpos.cc", "src/gsub.cc", "src/hdmx.cc", "src/kern.cc", "src/ltsh.cc", "src/math.cc", "src/vdmx.cc", "src/vorg.cc"], "buggy_code_start_loc": [13, 233, 679, 532, 15, 13, 15, 520, 13, 15], "buggy_code_end_loc": [18, 237, 683, 536, 20, 17, 20, 524, 18, 20], "fixing_code_start_loc": [14, 234, 680, 533, 16, 14, 16, 521, 14, 16], "fixing_code_end_loc": [17, 236, 682, 535, 19, 16, 19, 523, 17, 19], "type": "NVD-CWE-Other", "message": "Multiple use-after-free vulnerabilities in OpenType Sanitiser, as used in Mozilla Firefox before 36.0, might allow remote attackers to trigger problematic Developer Console information or possibly have unspecified other impact by leveraging incorrect macro expansion, related to the ots::ots_gasp_parse function.", "other": {"cve": {"id": "CVE-2015-0823", "sourceIdentifier": "security@mozilla.org", "published": "2015-02-25T11:59:04.377", "lastModified": "2018-10-30T16:27:35.843", "vulnStatus": "Modified", "evaluatorComment": "<a href=\"http://cwe.mitre.org/data/definitions/416.html\">CWE-416: Use After Free</a>", "descriptions": [{"lang": "en", "value": "Multiple use-after-free vulnerabilities in OpenType Sanitiser, as used in Mozilla Firefox before 36.0, might allow remote attackers to trigger problematic Developer Console information or possibly have unspecified other impact by leveraging incorrect macro expansion, related to the ots::ots_gasp_parse function."}, {"lang": "es", "value": "M\u00faltiples vulnerabilidades de uso despu\u00e9s de liberaci\u00f3n en OpenType Sanitiser, utilizado en Mozilla Firefox anterior a 36.0, podr\u00edan permitir a atacantes remotos provocar informaci\u00f3n problem\u00e1tica de la consola de desarrollo (Developer Console) o posiblemente tener otro impacto no especificado mediante el aprovechamiento de la expansi\u00f3n incorrecta de macros, relacionado con la funci\u00f3n ots::ots_gasp_parse."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B6B7CAD7-9D4E-4FDB-88E3-1E583210A01F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B5A6F2F3-4894-4392-8296-3B8DD2679084"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.10:*:*:*:*:*:*:*", "matchCriteriaId": "49A63F39-30BE-443F-AF10-6245587D3359"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:opentype_sanitiser_project:opentype_sanitiser:*:*:*:*:*:*:*:*", "matchCriteriaId": "328B66BC-9996-40C5-8B6A-6D2B7567F63C"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:*:*:*:*:*:*:*:*", "versionEndIncluding": "35.0.1", "matchCriteriaId": "40538FA3-BAE9-44D4-85B1-54E1D36BFB7F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:0.1:*:*:*:*:*:*:*", "matchCriteriaId": "7C7AA88B-638A-451A-B235-A1A1444BE417"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:0.2:*:*:*:*:*:*:*", "matchCriteriaId": "9C01AD7C-8470-47AB-B8AE-670E3A381E89"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:0.3:*:*:*:*:*:*:*", "matchCriteriaId": "7E43F2F1-9252-4B44-8A61-D05305915A5F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:0.4:*:*:*:*:*:*:*", "matchCriteriaId": "3BB9D48B-DC7B-4D92-BB26-B6DE629A2506"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:0.5:*:*:*:*:*:*:*", "matchCriteriaId": "A360D595-A829-4DDE-932E-9995626917E5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:0.6:*:*:*:*:*:*:*", "matchCriteriaId": "6E9B5349-FAA7-4CDA-9533-1AD1ACDFAC4E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:0.6.1:*:*:*:*:*:*:*", "matchCriteriaId": "07243837-C353-4C25-A5B1-4DA32807E97D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:0.7:*:*:*:*:*:*:*", "matchCriteriaId": "B832C034-F793-415F-BFC8-D97A18BA6BC7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:0.7.1:*:*:*:*:*:*:*", "matchCriteriaId": "83CD1A13-66CB-49CC-BD84-5D8334DB774A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:0.8:*:*:*:*:*:*:*", "matchCriteriaId": "93C142C5-3A85-432B-80D6-2E7B1B4694F4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:0.9:*:*:*:*:*:*:*", "matchCriteriaId": "2434FCE7-A50B-4527-9970-C7224B31141C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:0.9:rc:*:*:*:*:*:*", "matchCriteriaId": "5633FB6E-D623-49D4-9858-4E20E64DE458"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:0.9.1:*:*:*:*:*:*:*", "matchCriteriaId": "429ECA02-DBCD-45FB-942C-CA4BC1BC8A72"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:0.9.2:*:*:*:*:*:*:*", "matchCriteriaId": "B5F0DC80-5473-465C-9D7F-9589F1B78E12"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:0.9.3:*:*:*:*:*:*:*", "matchCriteriaId": "567FF916-7DE0-403C-8528-7931A43E0D18"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:0.10:*:*:*:*:*:*:*", "matchCriteriaId": "010B34F4-910E-4515-990B-8E72DF009578"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:0.10.1:*:*:*:*:*:*:*", "matchCriteriaId": "8FAA1A89-E8D9-46D0-8E2C-9259920ACBFE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:1.0:*:*:*:*:*:*:*", "matchCriteriaId": "5A545A77-2198-4685-A87F-E0F2DAECECF6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:1.0:preview_release:*:*:*:*:*:*", "matchCriteriaId": "438AACF8-006F-4522-853F-30DBBABD8C15"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:1.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "778FAE0C-A5CF-4B67-93A9-1A803E3E699F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:1.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "E7447185-7509-449D-8907-F30A42CF7EB5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:1.0.3:*:*:*:*:*:*:*", "matchCriteriaId": "0EDBAC37-9D08-44D1-B279-BC6ACF126CAF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:1.0.4:*:*:*:*:*:*:*", "matchCriteriaId": "3FFF89FA-2020-43CC-BACD-D66117B3DD26"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:1.0.5:*:*:*:*:*:*:*", "matchCriteriaId": "834BB391-5EB5-43A8-980A-D305EDAE6FA7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:1.0.6:*:*:*:*:*:*:*", "matchCriteriaId": "9A38AD88-BAA6-4FBE-885B-69E951BD1EFE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:1.0.7:*:*:*:*:*:*:*", "matchCriteriaId": "B500EE6C-99DB-49A3-A1F1-AFFD7FE28068"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:1.0.8:*:*:*:*:*:*:*", "matchCriteriaId": "4F2938F2-A801-45E5-8E06-BE03DE03C8A7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:1.4.1:*:*:*:*:*:*:*", "matchCriteriaId": "F18A45C0-419C-4723-AB7D-5880EF668CE9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:1.5:*:*:*:*:*:*:*", "matchCriteriaId": "ABB88E86-6E83-4A59-9266-8B98AA91774D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:1.5:beta1:*:*:*:*:*:*", "matchCriteriaId": "E19ED1CA-DEBD-4786-BA7B-C122C7D2E5B7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:1.5:beta2:*:*:*:*:*:*", "matchCriteriaId": "66BE50FE-EA21-4633-A181-CD35196DF06E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:1.5.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "7D6BF5B1-86D1-47FE-9D9C-735718F94874"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:1.5.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "84D15CE0-69DF-4EFD-801E-96A4D6AABEDB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:1.5.0.3:*:*:*:*:*:*:*", "matchCriteriaId": "CEE203DE-6C0E-4FDE-9C3A-0E73430F17DA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:1.5.0.4:*:*:*:*:*:*:*", "matchCriteriaId": "F2F38886-C25A-4C6B-93E7-36461405BA99"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:1.5.0.5:*:*:*:*:*:*:*", "matchCriteriaId": "C65D2670-F37F-48CB-804A-D35BB1C27D9F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:1.5.0.6:*:*:*:*:*:*:*", "matchCriteriaId": "DE8E5194-7B34-4802-BDA6-6A86EB5EDE05"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:1.5.0.7:*:*:*:*:*:*:*", "matchCriteriaId": "FABA5F56-99F7-4F8F-9CC1-5B0B2EB72922"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:1.5.0.8:*:*:*:*:*:*:*", "matchCriteriaId": "2917BD67-CE81-4B94-B241-D4A9DDA60319"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:1.5.0.9:*:*:*:*:*:*:*", "matchCriteriaId": "A524A94E-F19B-42B9-AA8E-171751C339AA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:1.5.0.10:*:*:*:*:*:*:*", "matchCriteriaId": "F71436CF-F756-44E0-8E69-6951F6B3E54A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:1.5.0.11:*:*:*:*:*:*:*", "matchCriteriaId": "582EE839-B83F-4908-9780-D0C92DC44FD0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:1.5.0.12:*:*:*:*:*:*:*", "matchCriteriaId": "824369CF-00A0-434E-94BC-71CA1317012C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:1.5.1:*:*:*:*:*:*:*", "matchCriteriaId": "BCB35099-B04E-4796-A25D-953329FE62F3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:1.5.2:*:*:*:*:*:*:*", "matchCriteriaId": "5DBEBCFD-80D6-466A-BAEF-C75E65A3B12E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:1.5.3:*:*:*:*:*:*:*", "matchCriteriaId": "C30ACBCA-4FA1-46DE-8F15-4830BC27E160"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:1.5.4:*:*:*:*:*:*:*", "matchCriteriaId": "9453EF65-7C69-449E-BF7C-4FECFB56713E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:1.5.5:*:*:*:*:*:*:*", "matchCriteriaId": "4AA75825-21CF-475B-8040-126A13FA2216"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:1.5.6:*:*:*:*:*:*:*", "matchCriteriaId": "CA97C80E-17FA-4866-86CE-29886145ED80"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:1.5.7:*:*:*:*:*:*:*", "matchCriteriaId": "7DE24BED-202E-416D-B5F2-8207D97B9939"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:1.5.8:*:*:*:*:*:*:*", "matchCriteriaId": "04198E04-CE1D-4A5A-A20C-D1E135B45F94"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:1.8:*:*:*:*:*:*:*", "matchCriteriaId": "717DB967-F658-4699-A224-5B261BFEC10A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:2.0:*:*:*:*:*:*:*", "matchCriteriaId": "3487FA64-BE04-42CA-861E-3DAC097D7D32"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:2.0.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "F3D956DC-C73B-439F-8D79-8239207CC76F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:2.0.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "57E2C7E7-56C0-466C-BB08-5EB43922C4F9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:2.0.0.3:*:*:*:*:*:*:*", "matchCriteriaId": "462E135A-5616-46CC-A9C0-5A7A0526ACC6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:2.0.0.4:*:*:*:*:*:*:*", "matchCriteriaId": "6121F9C1-F4DF-4AAB-9E51-AC1592AA5639"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:2.0.0.5:*:*:*:*:*:*:*", "matchCriteriaId": "58D44634-A0B5-4F05-8983-B08D392EC742"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:2.0.0.6:*:*:*:*:*:*:*", "matchCriteriaId": "EB3AC3D3-FDD7-489F-BDCF-BDB55DF33A8B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:2.0.0.7:*:*:*:*:*:*:*", "matchCriteriaId": "4105171B-9C90-4ABF-B220-A35E7BA9EE40"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:2.0.0.8:*:*:*:*:*:*:*", "matchCriteriaId": "20985549-DB24-4B69-9D40-208A47AE658E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:2.0.0.9:*:*:*:*:*:*:*", "matchCriteriaId": "43A13026-416F-4308-8A1B-E989BD769E12"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:2.0.0.10:*:*:*:*:*:*:*", "matchCriteriaId": "612B015E-9F96-4CE6-83E4-23848FD609E5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:2.0.0.11:*:*:*:*:*:*:*", "matchCriteriaId": "1E391619-0967-43E1-8CBC-4D54F72A85C2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:2.0.0.12:*:*:*:*:*:*:*", "matchCriteriaId": "0544D626-E269-4677-9B05-7DAB23BD103B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:2.0.0.13:*:*:*:*:*:*:*", "matchCriteriaId": "C95F7B2C-80FC-4DF2-9680-F74634DCE3E6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:2.0.0.14:*:*:*:*:*:*:*", "matchCriteriaId": "863C140E-DC15-4A88-AB8A-8AEF9F4B8164"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:2.0.0.15:*:*:*:*:*:*:*", "matchCriteriaId": "38CD049A-5333-4FF7-AD34-6B74E19BADCB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:2.0.0.16:*:*:*:*:*:*:*", "matchCriteriaId": "0066576D-D66A-4B59-B5C3-471EEBEE8B9A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:2.0.0.17:*:*:*:*:*:*:*", "matchCriteriaId": "60ED6DAA-9194-4829-BC1A-00F04BE7930A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:2.0.0.18:*:*:*:*:*:*:*", "matchCriteriaId": "13BEB9A6-EFD5-4793-9603-84DB84F1CF7D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:2.0.0.19:*:*:*:*:*:*:*", "matchCriteriaId": "461163C6-4CA8-4BA9-95A1-136E612CBA6B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:2.0.0.20:*:*:*:*:*:*:*", "matchCriteriaId": "275E9D96-1290-44AB-BF9B-E9E4A803F593"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:3.0:*:*:*:*:*:*:*", "matchCriteriaId": "412DF091-7604-4110-87A0-3488116A97E5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:3.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "11E07FED-ABDB-4B0A-AB2E-4CBF1EAC4301"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:3.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "9A6558F1-9E0D-4107-909A-8EF4BC8A9C2F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:3.0.3:*:*:*:*:*:*:*", "matchCriteriaId": "63DF3D65-C992-44CF-89B4-893526C6242E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:3.0.4:*:*:*:*:*:*:*", "matchCriteriaId": "A9024117-2E8B-4240-9E21-CC501F3879B5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:3.0.5:*:*:*:*:*:*:*", "matchCriteriaId": "FBC3CAD3-2F54-4E32-A0C9-0D826C45AC23"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:3.0.6:*:*:*:*:*:*:*", "matchCriteriaId": "52624B41-AB34-40AD-8709-D9646B618AB0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:3.0.7:*:*:*:*:*:*:*", "matchCriteriaId": "917E9856-9556-4FD6-A834-858F8837A6B4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:3.0.8:*:*:*:*:*:*:*", "matchCriteriaId": "98BBD74D-930C-4D80-A91B-0D61347BAA63"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:3.0.9:*:*:*:*:*:*:*", "matchCriteriaId": "FAF2E696-883D-4DE5-8B79-D8E5D9470253"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:3.0.10:*:*:*:*:*:*:*", "matchCriteriaId": "94E04FD9-38E8-462D-82C2-729F7F7F0465"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:3.0.11:*:*:*:*:*:*:*", "matchCriteriaId": "5888517E-3C57-4A0A-9895-EA4BCB0A0ED5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:3.0.12:*:*:*:*:*:*:*", "matchCriteriaId": "0BB21291-B9F3-445E-A9E9-EA1822083DD3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:3.0.13:*:*:*:*:*:*:*", "matchCriteriaId": "D595F649-ECBE-45E0-8AAD-BCBC65A654B9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:3.0.14:*:*:*:*:*:*:*", "matchCriteriaId": "4FE6E920-9A4C-431B-89EA-683A22F15ACD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:3.0.15:*:*:*:*:*:*:*", "matchCriteriaId": "18B6CC9F-6295-4598-B28B-0CA19D1D9F45"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:3.0.16:*:*:*:*:*:*:*", "matchCriteriaId": "C9F0434D-C84F-49FD-9F44-66D3ACD7B601"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:3.0.17:*:*:*:*:*:*:*", "matchCriteriaId": "F6AAB416-E865-4EEE-8FCB-A91253BEB52B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:3.0.18:*:*:*:*:*:*:*", "matchCriteriaId": "EF822823-4D49-4BA4-B918-B3CC9F27F62C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:3.0.19:*:*:*:*:*:*:*", "matchCriteriaId": "A19A7FD2-448D-4B50-9A25-6D64C7728EAC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:3.5:*:*:*:*:*:*:*", "matchCriteriaId": "76CD3BDF-A079-4EF3-ABDE-43CBDD08DB1F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:3.5.1:*:*:*:*:*:*:*", "matchCriteriaId": "031E8624-5161-43AF-AF19-6BAB5A94FDD8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:3.5.2:*:*:*:*:*:*:*", "matchCriteriaId": "54186D4A-C6F0-44AD-94FB-73B4346ABB6B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:3.5.3:*:*:*:*:*:*:*", "matchCriteriaId": "47E50AD9-BA35-4817-BD4D-5D678FC5A3C5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:3.5.4:*:*:*:*:*:*:*", "matchCriteriaId": "DD09DE40-8C9B-41EA-B372-9E4E4830E8F4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:3.5.5:*:*:*:*:*:*:*", "matchCriteriaId": "F223FB83-0EDB-4429-94B9-1AEEF314B73F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:3.5.6:*:*:*:*:*:*:*", "matchCriteriaId": "BC6B977F-292F-4981-95A0-6065A3C487D5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:3.5.7:*:*:*:*:*:*:*", "matchCriteriaId": "342226B9-2C0C-416C-81FE-19C49F03AA88"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:3.5.8:*:*:*:*:*:*:*", "matchCriteriaId": "2A6A28E0-F67A-4275-B0D9-A02822E9EF7E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:3.5.9:*:*:*:*:*:*:*", "matchCriteriaId": "ECAB4696-76F3-458C-B33B-D7F8690C60A0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:3.5.10:*:*:*:*:*:*:*", "matchCriteriaId": "BBB444FD-15F3-4447-9EA8-1669779A5749"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:3.5.11:*:*:*:*:*:*:*", "matchCriteriaId": "F92E2EF3-A612-476F-9D31-1EEC240C7EA7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:3.5.12:*:*:*:*:*:*:*", "matchCriteriaId": "0F175D30-2416-4172-BF11-DA78D252D608"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:3.5.13:*:*:*:*:*:*:*", "matchCriteriaId": "5DD3F168-3EF4-492E-BBAA-EACB1357C709"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:3.5.14:*:*:*:*:*:*:*", "matchCriteriaId": "4B46BA97-2860-45E4-9FD3-F418A202E4F0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:3.5.15:*:*:*:*:*:*:*", "matchCriteriaId": "B1C23289-38C3-4C62-8B27-249EAECC297E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:3.5.16:*:*:*:*:*:*:*", "matchCriteriaId": "96B0C0CB-6B81-45F0-B71F-A09164501414"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:3.5.17:*:*:*:*:*:*:*", "matchCriteriaId": "869D2763-D953-4532-9353-DC9045A7EF2A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:3.5.18:*:*:*:*:*:*:*", "matchCriteriaId": "80082DA0-7E48-4F5F-A005-915151226C2E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:3.5.19:*:*:*:*:*:*:*", "matchCriteriaId": "51925FD3-D730-4938-BE35-C5FDF57F8DD2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:3.6:*:*:*:*:*:*:*", "matchCriteriaId": "F3782354-7EB7-49D2-B240-1871F6CB84C7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:3.6.2:*:*:*:*:*:*:*", "matchCriteriaId": "30D47263-03AD-4060-91E3-90F997B3D174"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:3.6.3:*:*:*:*:*:*:*", "matchCriteriaId": "AFD775DF-277E-4D5B-B980-B8E6E782467D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:3.6.4:*:*:*:*:*:*:*", "matchCriteriaId": "C8587BFD-417D-42BE-A5F8-22FDC68FA9E6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:3.6.6:*:*:*:*:*:*:*", "matchCriteriaId": "D7364FAB-EEE9-4064-A8AD-6547239F9AB3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:3.6.7:*:*:*:*:*:*:*", "matchCriteriaId": "4C50485F-BC7B-4B70-A47B-1712E2DBAC5A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:3.6.8:*:*:*:*:*:*:*", "matchCriteriaId": "51EE386B-0833-484E-A2AB-86B4470D4D45"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:3.6.9:*:*:*:*:*:*:*", "matchCriteriaId": "C3EF1B4D-6556-4B3C-BDD0-6348A4D4A91D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:3.6.10:*:*:*:*:*:*:*", "matchCriteriaId": "68C5C7CF-005B-42FC-B950-90303F0CC115"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:3.6.11:*:*:*:*:*:*:*", "matchCriteriaId": "0B2FA2CF-7FE4-43B1-96A0-C14666EDBD7B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:3.6.12:*:*:*:*:*:*:*", "matchCriteriaId": "30290F6D-55CA-47EB-8F41-7BBB745C7A34"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:3.6.13:*:*:*:*:*:*:*", "matchCriteriaId": "F61F0607-14B0-49AD-B7E6-C4D75401C270"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:3.6.14:*:*:*:*:*:*:*", "matchCriteriaId": "7FED863D-2898-4148-A9FB-73BFF9DE4396"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:3.6.15:*:*:*:*:*:*:*", "matchCriteriaId": "779C1245-A6F9-41F5-B8D4-FAE506A23FD3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:3.6.16:*:*:*:*:*:*:*", "matchCriteriaId": "9E7CFEE9-70D4-465F-9FB9-397E6B200FA3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:3.6.17:*:*:*:*:*:*:*", "matchCriteriaId": "197E56BF-BE78-459F-A124-786DF39D1235"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:3.6.18:*:*:*:*:*:*:*", "matchCriteriaId": "07747612-3890-4271-94A4-4347E5ED073D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:3.6.19:*:*:*:*:*:*:*", "matchCriteriaId": "0855BA85-BC52-4EDF-915A-8B4E5FB48092"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:3.6.20:*:*:*:*:*:*:*", "matchCriteriaId": "BC273819-9DDE-4591-9376-1DD5782461F1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:3.6.21:*:*:*:*:*:*:*", "matchCriteriaId": "9B68D1E7-B2F7-4581-8173-8CCF55A0E1BC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:3.6.22:*:*:*:*:*:*:*", "matchCriteriaId": "CDFF6453-B707-4772-8CDF-2F8922FD4894"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:3.6.23:*:*:*:*:*:*:*", "matchCriteriaId": "C4D70DBF-1CF2-491D-BA0F-478D7732E01C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:3.6.24:*:*:*:*:*:*:*", "matchCriteriaId": "0B55ADF9-6525-4EFA-A431-CD69C8C2216C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:3.6.25:*:*:*:*:*:*:*", "matchCriteriaId": "B40A42AD-7097-47F8-9A3F-1806D8C174F6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:3.6.26:*:*:*:*:*:*:*", "matchCriteriaId": "0AC64894-D8FC-47D8-97C7-E2BCF07D1CE3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:3.6.27:*:*:*:*:*:*:*", "matchCriteriaId": "4A671946-3CBE-4B28-8C24-0E717532EED7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:3.6.28:*:*:*:*:*:*:*", "matchCriteriaId": "9A902CCA-7723-4177-9CFC-FD211F31A635"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:4.0:*:*:*:*:*:*:*", "matchCriteriaId": "C69962C4-FA56-47F2-82A4-DFF4C19DAF3A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:4.0:beta1:*:*:*:*:*:*", "matchCriteriaId": "B7BC1684-3634-4585-B7E6-8C8777E1DA0D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:4.0:beta10:*:*:*:*:*:*", "matchCriteriaId": "A490D040-EF74-45C2-89ED-D88ADD222712"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:4.0:beta11:*:*:*:*:*:*", "matchCriteriaId": "6CDA17D1-CD93-401E-860C-7C3291FEEB7E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:4.0:beta12:*:*:*:*:*:*", "matchCriteriaId": "6F72FDE3-54E0-48E4-9015-1B8A36DB1EC3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:4.0:beta2:*:*:*:*:*:*", "matchCriteriaId": "4062C901-3828-415B-A6C3-EDD0E7B20C0E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:4.0:beta3:*:*:*:*:*:*", "matchCriteriaId": "CC0D8730-7034-4AD6-9B05-F8BAFB0145EF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:4.0:beta4:*:*:*:*:*:*", "matchCriteriaId": "857AFB05-F0C1-4061-9680-9561D68C908F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:4.0:beta5:*:*:*:*:*:*", "matchCriteriaId": "EC37EBAF-C979-4ACC-ACA9-BDC2AECCB0D7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:4.0:beta6:*:*:*:*:*:*", "matchCriteriaId": "80801CD8-EEAF-4BC4-9085-DCCC6CF73076"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:4.0:beta7:*:*:*:*:*:*", "matchCriteriaId": "FAF4C78A-5093-4871-AF69-A8E8FD7E1AAE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:4.0:beta8:*:*:*:*:*:*", "matchCriteriaId": "560AD4C7-89D2-4323-BBCC-A89EEB6832CB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:4.0:beta9:*:*:*:*:*:*", "matchCriteriaId": "6B389CBC-4F6C-4C17-A87B-A6DD92703A10"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:4.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "DDFBA043-91BC-4FB5-A34D-FCE1A9C65A88"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:5.0:*:*:*:*:*:*:*", "matchCriteriaId": "8901A808-66F1-4501-AFF6-6FBB22852855"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:5.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "B88D1373-6E41-4EF4-86A0-CE85EA3BF23E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "1F42315C-35AF-4EDD-8B78-A9EDB9F85D59"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:6.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "62147F86-C2E6-4D55-9C72-F8BB430F2F7F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:6.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "CE4D1FFD-3AFE-4F52-BCBE-A56609B2D7EF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "5B2CD349-B9BF-4752-B7B9-665BF718EDB8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:7.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "11A8F675-A91F-4E41-AA2B-5214DF79C69C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "75B6A811-2B5A-484A-9878-C8E2C3E7633C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:8.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "456769EF-8961-4038-A7D5-B980147159E8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "7439C998-E396-4EEC-9C21-E82D27459EA6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:9.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "A1CD246C-1104-4DA1-9BFD-ED0B1FBA7EF5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "A1D4D8C9-5A00-46FE-9E42-CB8C2D66B120"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:10.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "E639BCCB-A6BF-4174-BFAF-9674E65BA404"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:10.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "FDFC5947-3C3D-4484-8803-D6629C63B315"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:10.0.3:*:*:*:*:*:*:*", "matchCriteriaId": "A04BF0E2-0A40-4396-A46A-005D103D9E3F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:10.0.4:*:*:*:*:*:*:*", "matchCriteriaId": "C0C4C930-6EC1-469D-811C-E85490AB38C3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:10.0.5:*:*:*:*:*:*:*", "matchCriteriaId": "D93271DA-A9E2-459B-832E-162A803DD2E9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:10.0.6:*:*:*:*:*:*:*", "matchCriteriaId": "60ADFF75-220C-4729-B3C6-2CBA23C24C3C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:10.0.7:*:*:*:*:*:*:*", "matchCriteriaId": "C6CB2B38-E9B1-4DBE-83DD-F31B2E5F8D1E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:10.0.8:*:*:*:*:*:*:*", "matchCriteriaId": "59FDB564-EBD6-40CF-86C1-3D07E1661AE2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:10.0.9:*:*:*:*:*:*:*", "matchCriteriaId": "8A82249A-FB28-43A1-8525-CC25F3E277E4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:10.0.10:*:*:*:*:*:*:*", "matchCriteriaId": "74EE5936-45A1-4690-84F6-FBA4C5ADD3CA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:10.0.11:*:*:*:*:*:*:*", "matchCriteriaId": "BDAA69C4-056E-465E-9BF2-EA54C8958AE4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:10.0.12:*:*:*:*:*:*:*", "matchCriteriaId": "E6B70EA8-7B3C-4BB4-9A20-95E25BB9F53F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:11.0:*:*:*:*:*:*:*", "matchCriteriaId": "9FEA6800-CBDB-497A-BBBE-1C40E8484A89"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:12.0:*:*:*:*:*:*:*", "matchCriteriaId": "DF604D56-5D81-4276-88A1-AE321929E22A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:12.0:beta6:*:*:*:*:*:*", "matchCriteriaId": "AB630A94-DA1F-4A7F-891D-E6F242C20271"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:13.0:*:*:*:*:*:*:*", "matchCriteriaId": "B038D136-BB5E-4252-B313-A13919195DB2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:13.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "10DC88D4-CEEF-4BD1-9D69-CC5EA0262932"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:14.0:*:*:*:*:*:*:*", "matchCriteriaId": "C2841735-0EA5-472C-A7FA-385A5677F106"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:14.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "5DB041C1-A5A3-4007-8633-FF018F88D5E3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:15.0:*:*:*:*:*:*:*", "matchCriteriaId": "37426FAE-A85D-4368-9E8E-186D98879BA8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:15.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "94187D6F-D4E0-4A9E-AD27-362923B6C8ED"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:16.0:*:*:*:*:*:*:*", "matchCriteriaId": "8E00FCD9-4EA1-4FFF-A15C-2AF9C509D220"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:16.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "F5F44346-11A1-4C8A-8C4C-1334F52C5DC1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:16.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "B409ACE9-B9A5-4AD2-B54A-705DB65B7996"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:17.0:*:*:*:*:*:*:*", "matchCriteriaId": "3283FBAC-B77A-4C62-9D51-70BB35FA3D13"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:17.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "886D8A1F-ECDD-4FE9-A4E5-2322EEC0B880"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:17.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "E10B8803-C319-4AAA-81CF-FA206A33BA55"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:17.0.3:*:*:*:*:*:*:*", "matchCriteriaId": "E2B5567C-8969-456D-B6DF-3562B99C41FE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:17.0.4:*:*:*:*:*:*:*", "matchCriteriaId": "5657779C-19F9-42B8-BBBD-292B898E8FD2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:17.0.5:*:*:*:*:*:*:*", "matchCriteriaId": "EEA3B9F4-BD8E-488B-A362-0B86BC6DA275"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:17.0.6:*:*:*:*:*:*:*", "matchCriteriaId": "6A91BD4A-76BD-40B9-9E12-22CACAAE42BF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:17.0.7:*:*:*:*:*:*:*", "matchCriteriaId": "84CEB297-BEE9-4BBC-BA91-6AF14DCCA87C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:17.0.8:*:*:*:*:*:*:*", "matchCriteriaId": "C1890BA0-0BCD-4B24-805A-7580884CE5B3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:17.0.9:*:*:*:*:*:*:*", "matchCriteriaId": "4154D7D4-DAD7-46DB-A2A7-5A3702939865"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:17.0.10:*:*:*:*:*:*:*", "matchCriteriaId": "D316A264-4651-4E8A-904F-447DBDB333D2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:17.0.11:*:*:*:*:*:*:*", "matchCriteriaId": "E5C5A3F2-7C6B-4251-82A3-5C3EF40BBEF2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:18.0:*:*:*:*:*:*:*", "matchCriteriaId": "680F3756-8A3C-45E3-ABFA-6C81D32EC9F2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:18.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "5E6814DC-B8D9-47E2-B598-61891EC89303"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:18.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "6AB00C64-ED40-4416-97C4-4EF5735EA728"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:19.0:*:*:*:*:*:*:*", "matchCriteriaId": "06FF9DFE-491D-4260-8A49-07FD342B9412"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:19.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "DE09D089-7F48-466B-B03A-C64152A12615"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:19.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "653D73DA-21C0-4C3F-9269-5A6D5C5B1E34"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:20.0:*:*:*:*:*:*:*", "matchCriteriaId": "804A0ACE-EB28-413D-93F4-E849FEA01390"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:20.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "3BA49C6F-9115-41A5-BBDE-743CB9DEDDA8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:21.0:*:*:*:*:*:*:*", "matchCriteriaId": "7CC8D9A8-D4DB-4BC9-89CE-F3AF742C399F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:22.0:*:*:*:*:*:*:*", "matchCriteriaId": "ADF6A02E-A85B-48BA-A60C-E92CDA3A8055"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:23.0:*:*:*:*:*:*:*", "matchCriteriaId": "50127B73-3517-4E82-94E9-FC5AA0DA3357"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:23.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "7CBE3FB1-F768-4EEE-A01A-12BB958CDB29"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:24.0:*:*:*:*:*:*:*", "matchCriteriaId": "18E772D1-DD0F-4F04-8BB4-9550F3C601E1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:24.1:*:*:*:*:*:*:*", "matchCriteriaId": "9DA45F56-831E-4115-8E9B-F582CE9563D3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:24.1.1:*:*:*:*:*:*:*", "matchCriteriaId": "732CC40B-BCBA-436B-956F-52BE28D9B79B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:25.0:*:*:*:*:*:*:*", "matchCriteriaId": "0A287B5E-BEE8-4252-B4B8-F5C10B055F25"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:25.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "A0602CE2-B9A0-4271-9E1E-2687AEC94C36"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:26.0:*:*:*:*:*:*:*", "matchCriteriaId": "641C1E96-65F0-464E-AD95-19D7BBA296DE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:27.0:*:*:*:*:*:*:*", "matchCriteriaId": "2F5C3297-4C45-461A-B17B-74C0133E79CF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:27.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "F1DE0CA9-CDC5-4243-9224-37EE1F16B274"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:28.0:*:*:*:*:*:*:*", "matchCriteriaId": "9DE18C00-F43A-4CE4-84E1-FECE9D893CFD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:29.0:*:*:*:*:*:*:*", "matchCriteriaId": "B3084083-87EF-449F-96D7-9D10AA75CF6E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:29.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "7070270A-A9B9-4702-A986-D9491B1925A8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:30.0:*:*:*:*:*:*:*", "matchCriteriaId": "38EBC9E7-46AD-4DCD-AA7B-5071F55E3755"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:31.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11F024A-A8B7-405B-8A13-4BF406FBDB22"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:31.1.0:*:*:*:*:*:*:*", "matchCriteriaId": "D81A3698-797C-4CD9-BB02-A9182E0A6E11"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:32.0:*:*:*:*:*:*:*", "matchCriteriaId": "BCF92765-4CBF-409C-ABF7-F8F5C08C900E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:33.0:*:*:*:*:*:*:*", "matchCriteriaId": "775DB6AF-FA47-488A-BCE2-EEB1D92EB2B6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:34.0.5:*:*:*:*:*:*:*", "matchCriteriaId": "43DAC5FD-E536-491F-8CAB-6B914EE77B49"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:opensuse:13.1:*:*:*:*:*:*:*", "matchCriteriaId": "A10BC294-9196-425F-9FB0-B1625465B47F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:opensuse:13.2:*:*:*:*:*:*:*", "matchCriteriaId": "03117DF1-3BEC-4B8D-AD63-DBBDB2126081"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2015-03/msg00000.html", "source": "security@mozilla.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-updates/2015-03/msg00067.html", "source": "security@mozilla.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.mozilla.org/security/announce/2015/mfsa2015-23.html", "source": "security@mozilla.org", "tags": ["Vendor Advisory"]}, {"url": "http://www.oracle.com/technetwork/topics/security/bulletinapr2016-2952098.html", "source": "security@mozilla.org"}, {"url": "http://www.securityfocus.com/bid/72754", "source": "security@mozilla.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.securitytracker.com/id/1031791", "source": "security@mozilla.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.ubuntu.com/usn/USN-2505-1", "source": "security@mozilla.org", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.mozilla.org/show_bug.cgi?id=1098497", "source": "security@mozilla.org", "tags": ["Issue Tracking"]}, {"url": "https://github.com/khaledhosny/ots/commit/003c62d28ae438aa8943cb31535563397f838a2c", "source": "security@mozilla.org", "tags": ["Patch", "Issue Tracking"]}, {"url": "https://security.gentoo.org/glsa/201504-01", "source": "security@mozilla.org"}]}, "github_commit_url": "https://github.com/khaledhosny/ots/commit/003c62d28ae438aa8943cb31535563397f838a2c"}}