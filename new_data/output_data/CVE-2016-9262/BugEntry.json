{"buggy_code": ["/*\n * Copyright (c) 2001-2002 Michael David Adams.\n * All rights reserved.\n */\n\n/* __START_OF_JASPER_LICENSE__\n * \n * JasPer License Version 2.0\n * \n * Copyright (c) 2001-2006 Michael David Adams\n * Copyright (c) 1999-2000 Image Power, Inc.\n * Copyright (c) 1999-2000 The University of British Columbia\n * \n * All rights reserved.\n * \n * Permission is hereby granted, free of charge, to any person (the\n * \"User\") obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n * \n * 1.  The above copyright notices and this permission notice (which\n * includes the disclaimer below) shall be included in all copies or\n * substantial portions of the Software.\n * \n * 2.  The name of a copyright holder shall not be used to endorse or\n * promote products derived from the Software without specific prior\n * written permission.\n * \n * THIS DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS\n * LICENSE.  NO USE OF THE SOFTWARE IS AUTHORIZED HEREUNDER EXCEPT UNDER\n * THIS DISCLAIMER.  THE SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS\n * \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.  IN NO\n * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL\n * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING\n * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\n * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION\n * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  NO ASSURANCES ARE\n * PROVIDED BY THE COPYRIGHT HOLDERS THAT THE SOFTWARE DOES NOT INFRINGE\n * THE PATENT OR OTHER INTELLECTUAL PROPERTY RIGHTS OF ANY OTHER ENTITY.\n * EACH COPYRIGHT HOLDER DISCLAIMS ANY LIABILITY TO THE USER FOR CLAIMS\n * BROUGHT BY ANY OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL\n * PROPERTY RIGHTS OR OTHERWISE.  AS A CONDITION TO EXERCISING THE RIGHTS\n * GRANTED HEREUNDER, EACH USER HEREBY ASSUMES SOLE RESPONSIBILITY TO SECURE\n * ANY OTHER INTELLECTUAL PROPERTY RIGHTS NEEDED, IF ANY.  THE SOFTWARE\n * IS NOT FAULT-TOLERANT AND IS NOT INTENDED FOR USE IN MISSION-CRITICAL\n * SYSTEMS, SUCH AS THOSE USED IN THE OPERATION OF NUCLEAR FACILITIES,\n * AIRCRAFT NAVIGATION OR COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL\n * SYSTEMS, DIRECT LIFE SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH\n * THE FAILURE OF THE SOFTWARE OR SYSTEM COULD LEAD DIRECTLY TO DEATH,\n * PERSONAL INJURY, OR SEVERE PHYSICAL OR ENVIRONMENTAL DAMAGE (\"HIGH\n * RISK ACTIVITIES\").  THE COPYRIGHT HOLDERS SPECIFICALLY DISCLAIM ANY\n * EXPRESS OR IMPLIED WARRANTY OF FITNESS FOR HIGH RISK ACTIVITIES.\n * \n * __END_OF_JASPER_LICENSE__\n */\n\n/******************************************************************************\\\n* Includes.\n\\******************************************************************************/\n\n#include <stdarg.h>\n#include <stdio.h>\n\n#include \"jasper/jas_types.h\"\n#include \"jasper/jas_debug.h\"\n\n/******************************************************************************\\\n* Local data.\n\\******************************************************************************/\n\nstatic int jas_dbglevel = 0;\n/* The debug level. */\n\n/******************************************************************************\\\n* Code for getting/setting the debug level.\n\\******************************************************************************/\n\n/* Set the library debug level. */\nint jas_setdbglevel(int dbglevel)\n{\n\tint olddbglevel;\n\n\t/* Save the old debug level. */\n\tolddbglevel = jas_dbglevel;\n\n\t/* Change the debug level. */\n\tjas_dbglevel = dbglevel;\n\n\t/* Return the old debug level. */\n\treturn olddbglevel;\n}\n\n/* Get the library debug level. */\nint jas_getdbglevel()\n{\n\treturn jas_dbglevel;\n}\n\n/******************************************************************************\\\n* Code.\n\\******************************************************************************/\n\n/* Perform formatted output to standard error. */\nint jas_eprintf(const char *fmt, ...)\n{\n\tint ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vfprintf(stderr, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}\n\n/* Dump memory to a stream. */\nint jas_memdump(FILE *out, void *data, size_t len)\n{\n\tsize_t i;\n\tsize_t j;\n\tuchar *dp;\n\tdp = data;\n\tfor (i = 0; i < len; i += 16) {\n\t\tfprintf(out, \"%04zx:\", i);\n\t\tfor (j = 0; j < 16; ++j) {\n\t\t\tif (i + j < len) {\n\t\t\t\tfprintf(out, \" %02x\", dp[i + j]);\n\t\t\t}\n\t\t}\n\t\tfprintf(out, \"\\n\");\n\t}\n\treturn 0;\n}\n", "/*\n * Copyright (c) 1999-2000 Image Power, Inc. and the University of\n *   British Columbia.\n * Copyright (c) 2001-2003 Michael David Adams.\n * All rights reserved.\n */\n\n/* __START_OF_JASPER_LICENSE__\n * \n * JasPer License Version 2.0\n * \n * Copyright (c) 2001-2006 Michael David Adams\n * Copyright (c) 1999-2000 Image Power, Inc.\n * Copyright (c) 1999-2000 The University of British Columbia\n * \n * All rights reserved.\n * \n * Permission is hereby granted, free of charge, to any person (the\n * \"User\") obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n * \n * 1.  The above copyright notices and this permission notice (which\n * includes the disclaimer below) shall be included in all copies or\n * substantial portions of the Software.\n * \n * 2.  The name of a copyright holder shall not be used to endorse or\n * promote products derived from the Software without specific prior\n * written permission.\n * \n * THIS DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS\n * LICENSE.  NO USE OF THE SOFTWARE IS AUTHORIZED HEREUNDER EXCEPT UNDER\n * THIS DISCLAIMER.  THE SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS\n * \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.  IN NO\n * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL\n * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING\n * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\n * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION\n * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  NO ASSURANCES ARE\n * PROVIDED BY THE COPYRIGHT HOLDERS THAT THE SOFTWARE DOES NOT INFRINGE\n * THE PATENT OR OTHER INTELLECTUAL PROPERTY RIGHTS OF ANY OTHER ENTITY.\n * EACH COPYRIGHT HOLDER DISCLAIMS ANY LIABILITY TO THE USER FOR CLAIMS\n * BROUGHT BY ANY OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL\n * PROPERTY RIGHTS OR OTHERWISE.  AS A CONDITION TO EXERCISING THE RIGHTS\n * GRANTED HEREUNDER, EACH USER HEREBY ASSUMES SOLE RESPONSIBILITY TO SECURE\n * ANY OTHER INTELLECTUAL PROPERTY RIGHTS NEEDED, IF ANY.  THE SOFTWARE\n * IS NOT FAULT-TOLERANT AND IS NOT INTENDED FOR USE IN MISSION-CRITICAL\n * SYSTEMS, SUCH AS THOSE USED IN THE OPERATION OF NUCLEAR FACILITIES,\n * AIRCRAFT NAVIGATION OR COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL\n * SYSTEMS, DIRECT LIFE SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH\n * THE FAILURE OF THE SOFTWARE OR SYSTEM COULD LEAD DIRECTLY TO DEATH,\n * PERSONAL INJURY, OR SEVERE PHYSICAL OR ENVIRONMENTAL DAMAGE (\"HIGH\n * RISK ACTIVITIES\").  THE COPYRIGHT HOLDERS SPECIFICALLY DISCLAIM ANY\n * EXPRESS OR IMPLIED WARRANTY OF FITNESS FOR HIGH RISK ACTIVITIES.\n * \n * __END_OF_JASPER_LICENSE__\n */\n\n/*\n * Image Library\n *\n * $Id$\n */\n\n/******************************************************************************\\\n* Includes.\n\\******************************************************************************/\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <assert.h>\n#include <ctype.h>\n#include <inttypes.h>\n#include <stdbool.h>\n\n#include \"jasper/jas_math.h\"\n#include \"jasper/jas_image.h\"\n#include \"jasper/jas_malloc.h\"\n#include \"jasper/jas_string.h\"\n#include \"jasper/jas_debug.h\"\n\n/******************************************************************************\\\n* Types.\n\\******************************************************************************/\n\n#define\tFLOORDIV(x, y) ((x) / (y))\n\n/******************************************************************************\\\n* Local prototypes.\n\\******************************************************************************/\n\nstatic jas_image_cmpt_t *jas_image_cmpt_create0(void);\nstatic void jas_image_cmpt_destroy(jas_image_cmpt_t *cmpt);\nstatic jas_image_cmpt_t *jas_image_cmpt_create(int_fast32_t tlx,\n  int_fast32_t tly, int_fast32_t hstep, int_fast32_t vstep,\n  int_fast32_t width, int_fast32_t height, uint_fast16_t depth, bool sgnd,\n  uint_fast32_t inmem);\nstatic void jas_image_setbbox(jas_image_t *image);\nstatic jas_image_cmpt_t *jas_image_cmpt_copy(jas_image_cmpt_t *cmpt);\nstatic int jas_image_growcmpts(jas_image_t *image, int maxcmpts);\nstatic uint_fast32_t inttobits(jas_seqent_t v, int prec, bool sgnd);\nstatic jas_seqent_t bitstoint(uint_fast32_t v, int prec, bool sgnd);\nstatic int putint(jas_stream_t *out, int sgnd, int prec, long val);\nstatic int getint(jas_stream_t *in, int sgnd, int prec, long *val);\nstatic void jas_image_calcbbox2(jas_image_t *image, jas_image_coord_t *tlx,\n  jas_image_coord_t *tly, jas_image_coord_t *brx, jas_image_coord_t *bry);\nstatic long uptomult(long x, long y);\nstatic long downtomult(long x, long y);\nstatic long convert(long val, int oldsgnd, int oldprec, int newsgnd,\n  int newprec);\nstatic void jas_image_calcbbox2(jas_image_t *image, jas_image_coord_t *tlx,\n  jas_image_coord_t *tly, jas_image_coord_t *brx, jas_image_coord_t *bry);\n\n/******************************************************************************\\\n* Global data.\n\\******************************************************************************/\n\nstatic int jas_image_numfmts = 0;\nstatic jas_image_fmtinfo_t jas_image_fmtinfos[JAS_IMAGE_MAXFMTS];\n\n/******************************************************************************\\\n* Create and destroy operations.\n\\******************************************************************************/\n\njas_image_t *jas_image_create(int numcmpts, jas_image_cmptparm_t *cmptparms,\n  int clrspc)\n{\n\tjas_image_t *image;\n\tuint_fast32_t rawsize;\n\tuint_fast32_t inmem;\n\tint cmptno;\n\tjas_image_cmptparm_t *cmptparm;\n\n\tif (!(image = jas_image_create0())) {\n\t\treturn 0;\n\t}\n\n\timage->clrspc_ = clrspc;\n\timage->maxcmpts_ = numcmpts;\n\timage->inmem_ = true;\n\n\t/* Allocate memory for the per-component information. */\n\tif (!(image->cmpts_ = jas_alloc2(image->maxcmpts_,\n\t  sizeof(jas_image_cmpt_t *)))) {\n\t\tjas_image_destroy(image);\n\t\treturn 0;\n\t}\n\t/* Initialize in case of failure. */\n\tfor (cmptno = 0; cmptno < image->maxcmpts_; ++cmptno) {\n\t\timage->cmpts_[cmptno] = 0;\n\t}\n\n\t/* Compute the approximate raw size of the image. */\n\trawsize = 0;\n\tfor (cmptno = 0, cmptparm = cmptparms; cmptno < numcmpts; ++cmptno,\n\t  ++cmptparm) {\n\t\trawsize += cmptparm->width * cmptparm->height *\n\t\t  (cmptparm->prec + 7) / 8;\n\t}\n\t/* Decide whether to buffer the image data in memory, based on the\n\t  raw size of the image. */\n\tinmem = (rawsize < JAS_IMAGE_INMEMTHRESH);\n\n\t/* Create the individual image components. */\n\tfor (cmptno = 0, cmptparm = cmptparms; cmptno < numcmpts; ++cmptno,\n\t  ++cmptparm) {\n\t\tif (!(image->cmpts_[cmptno] = jas_image_cmpt_create(cmptparm->tlx,\n\t\t  cmptparm->tly, cmptparm->hstep, cmptparm->vstep,\n\t\t  cmptparm->width, cmptparm->height, cmptparm->prec,\n\t\t  cmptparm->sgnd, inmem))) {\n\t\t\tjas_image_destroy(image);\n\t\t\treturn 0;\n\t\t}\n\t\t++image->numcmpts_;\n\t}\n\n\t/* Determine the bounding box for all of the components on the\n\t  reference grid (i.e., the image area) */\n\tjas_image_setbbox(image);\n\n\treturn image;\n}\n\njas_image_t *jas_image_create0()\n{\n\tjas_image_t *image;\n\n\tif (!(image = jas_malloc(sizeof(jas_image_t)))) {\n\t\treturn 0;\n\t}\n\n\timage->tlx_ = 0;\n\timage->tly_ = 0;\n\timage->brx_ = 0;\n\timage->bry_ = 0;\n\timage->clrspc_ = JAS_CLRSPC_UNKNOWN;\n\timage->numcmpts_ = 0;\n\timage->maxcmpts_ = 0;\n\timage->cmpts_ = 0;\n\timage->inmem_ = true;\n\timage->cmprof_ = 0;\n\n\treturn image;\n}\n\njas_image_t *jas_image_copy(jas_image_t *image)\n{\n\tjas_image_t *newimage;\n\tint cmptno;\n\n\tif (!(newimage = jas_image_create0())) {\n\t\tgoto error;\n\t}\n\n\tif (jas_image_growcmpts(newimage, image->numcmpts_)) {\n\t\tgoto error;\n\t}\n\tfor (cmptno = 0; cmptno < image->numcmpts_; ++cmptno) {\n\t\tif (!(newimage->cmpts_[cmptno] = jas_image_cmpt_copy(image->cmpts_[cmptno]))) {\n\t\t\tgoto error;\n\t\t}\n\t\t++newimage->numcmpts_;\n\t}\n\n\tjas_image_setbbox(newimage);\n\n\tif (image->cmprof_) {\n\t\tif (!(newimage->cmprof_ = jas_cmprof_copy(image->cmprof_)))\n\t\t\tgoto error;\n\t}\n\n\treturn newimage;\nerror:\n\tif (newimage) {\n\t\tjas_image_destroy(newimage);\n\t}\n\treturn 0;\n}\n\nstatic jas_image_cmpt_t *jas_image_cmpt_create0()\n{\n\tjas_image_cmpt_t *cmpt;\n\tif (!(cmpt = jas_malloc(sizeof(jas_image_cmpt_t)))) {\n\t\treturn 0;\n\t}\n\tmemset(cmpt, 0, sizeof(jas_image_cmpt_t));\n\tcmpt->type_ = JAS_IMAGE_CT_UNKNOWN;\n\treturn cmpt;\n}\n\nstatic jas_image_cmpt_t *jas_image_cmpt_copy(jas_image_cmpt_t *cmpt)\n{\n\tjas_image_cmpt_t *newcmpt;\n\n\tif (!(newcmpt = jas_image_cmpt_create0())) {\n\t\treturn 0;\n\t}\n\tnewcmpt->tlx_ = cmpt->tlx_;\n\tnewcmpt->tly_ = cmpt->tly_;\n\tnewcmpt->hstep_ = cmpt->hstep_;\n\tnewcmpt->vstep_ = cmpt->vstep_;\n\tnewcmpt->width_ = cmpt->width_;\n\tnewcmpt->height_ = cmpt->height_;\n\tnewcmpt->prec_ = cmpt->prec_;\n\tnewcmpt->sgnd_ = cmpt->sgnd_;\n\tnewcmpt->cps_ = cmpt->cps_;\n\tnewcmpt->type_ = cmpt->type_;\n\tif (!(newcmpt->stream_ = jas_stream_memopen(0, 0))) {\n\t\tgoto error;\n\t}\n\tif (jas_stream_seek(cmpt->stream_, 0, SEEK_SET)) {\n\t\tgoto error;\n\t}\n\tif (jas_stream_copy(newcmpt->stream_, cmpt->stream_, -1)) {\n\t\tgoto error;\n\t}\n\tif (jas_stream_seek(newcmpt->stream_, 0, SEEK_SET)) {\n\t\tgoto error;\n\t}\n\treturn newcmpt;\nerror:\n\tif (newcmpt) {\n\t\tjas_image_cmpt_destroy(newcmpt);\n\t}\n\treturn 0;\n}\n\nvoid jas_image_destroy(jas_image_t *image)\n{\n\tint i;\n\n\tif (image->cmpts_) {\n\t\tfor (i = 0; i < image->numcmpts_; ++i) {\n\t\t\tjas_image_cmpt_destroy(image->cmpts_[i]);\n\t\t\timage->cmpts_[i] = 0;\n\t\t}\n\t\tjas_free(image->cmpts_);\n\t}\n\tif (image->cmprof_)\n\t\tjas_cmprof_destroy(image->cmprof_);\n\tjas_free(image);\n}\n\nstatic jas_image_cmpt_t *jas_image_cmpt_create(int_fast32_t tlx,\n  int_fast32_t tly, int_fast32_t hstep, int_fast32_t vstep,\n  int_fast32_t width, int_fast32_t height, uint_fast16_t depth, bool sgnd,\n  uint_fast32_t inmem)\n{\n\tjas_image_cmpt_t *cmpt;\n\tsize_t size;\n\n\tcmpt = 0;\n\tif (width < 0 || height < 0 || hstep <= 0 || vstep <= 0) {\n\t\tgoto error;\n\t}\n\tif (!jas_safe_intfast32_add(tlx, width, 0) ||\n\t  !jas_safe_intfast32_add(tly, height, 0)) {\n\t\tgoto error;\n\t}\n\n\tif (!(cmpt = jas_malloc(sizeof(jas_image_cmpt_t)))) {\n\t\tgoto error;\n\t}\n\n\tcmpt->type_ = JAS_IMAGE_CT_UNKNOWN;\n\tcmpt->tlx_ = tlx;\n\tcmpt->tly_ = tly;\n\tcmpt->hstep_ = hstep;\n\tcmpt->vstep_ = vstep;\n\tcmpt->width_ = width;\n\tcmpt->height_ = height;\n\tcmpt->prec_ = depth;\n\tcmpt->sgnd_ = sgnd;\n\tcmpt->stream_ = 0;\n\tcmpt->cps_ = (depth + 7) / 8;\n\n\t// Compute the number of samples in the image component, while protecting\n\t// against overflow.\n\t// size = cmpt->width_ * cmpt->height_ * cmpt->cps_;\n\tif (!jas_safe_size_mul(cmpt->width_, cmpt->height_, &size) ||\n\t  !jas_safe_size_mul(size, cmpt->cps_, &size)) {\n\t\tgoto error;\n\t}\n\tcmpt->stream_ = (inmem) ? jas_stream_memopen(0, size) :\n\t  jas_stream_tmpfile();\n\tif (!cmpt->stream_) {\n\t\tgoto error;\n\t}\n\n\t/* Zero the component data.  This isn't necessary, but it is\n\tconvenient for debugging purposes. */\n\t/* Note: conversion of size - 1 to long can overflow */\n\tif (jas_stream_seek(cmpt->stream_, size - 1, SEEK_SET) < 0 ||\n\t  jas_stream_putc(cmpt->stream_, 0) == EOF ||\n\t  jas_stream_seek(cmpt->stream_, 0, SEEK_SET) < 0) {\n\t\tgoto error;\n\t}\n\n\treturn cmpt;\n\nerror:\n\tif (cmpt) {\n\t\tjas_image_cmpt_destroy(cmpt);\n\t}\n\treturn 0;\n}\n\nstatic void jas_image_cmpt_destroy(jas_image_cmpt_t *cmpt)\n{\n\tif (cmpt->stream_) {\n\t\tjas_stream_close(cmpt->stream_);\n\t}\n\tjas_free(cmpt);\n}\n\n/******************************************************************************\\\n* Load and save operations.\n\\******************************************************************************/\n\njas_image_t *jas_image_decode(jas_stream_t *in, int fmt, char *optstr)\n{\n\tjas_image_fmtinfo_t *fmtinfo;\n\tjas_image_t *image;\n\n\timage = 0;\n\n\t/* If possible, try to determine the format of the input data. */\n\tif (fmt < 0) {\n\t\tif ((fmt = jas_image_getfmt(in)) < 0)\n\t\t\tgoto error;\n\t}\n\n\t/* Is it possible to decode an image represented in this format? */\n\tif (!(fmtinfo = jas_image_lookupfmtbyid(fmt)))\n\t\tgoto error;\n\tif (!fmtinfo->ops.decode)\n\t\tgoto error;\n\n\t/* Decode the image. */\n\tif (!(image = (*fmtinfo->ops.decode)(in, optstr)))\n\t\tgoto error;\n\n\t/* Create a color profile if needed. */\n\tif (!jas_clrspc_isunknown(image->clrspc_) &&\n\t  !jas_clrspc_isgeneric(image->clrspc_) && !image->cmprof_) {\n\t\tif (!(image->cmprof_ =\n\t\t  jas_cmprof_createfromclrspc(jas_image_clrspc(image))))\n\t\t\tgoto error;\n\t}\n\n\treturn image;\nerror:\n\tif (image)\n\t\tjas_image_destroy(image);\n\treturn 0;\n}\n\nint jas_image_encode(jas_image_t *image, jas_stream_t *out, int fmt, char *optstr)\n{\n\tjas_image_fmtinfo_t *fmtinfo;\n\tif (!(fmtinfo = jas_image_lookupfmtbyid(fmt))) {\n\t\treturn -1;\n\t}\n\treturn (fmtinfo->ops.encode) ? (*fmtinfo->ops.encode)(image, out,\n\t  optstr) : (-1);\n}\n\n/******************************************************************************\\\n* Component read and write operations.\n\\******************************************************************************/\n\nint jas_image_readcmpt(jas_image_t *image, int cmptno, jas_image_coord_t x,\n  jas_image_coord_t y, jas_image_coord_t width, jas_image_coord_t height,\n  jas_matrix_t *data)\n{\n\tjas_image_cmpt_t *cmpt;\n\tjas_image_coord_t i;\n\tjas_image_coord_t j;\n\tint k;\n\tjas_seqent_t v;\n\tint c;\n\tjas_seqent_t *dr;\n\tjas_seqent_t *d;\n\tint drs;\n\n\tif (cmptno < 0 || cmptno >= image->numcmpts_) {\n\t\treturn -1;\n\t}\n\n\tcmpt = image->cmpts_[cmptno];\n\tif (x >= cmpt->width_ || y >= cmpt->height_ ||\n\t  x + width > cmpt->width_ ||\n\t  y + height > cmpt->height_) {\n\t\treturn -1;\n\t}\n\n\tif (!jas_matrix_numrows(data) || !jas_matrix_numcols(data)) {\n\t\treturn -1;\n\t}\n\n\tif (jas_matrix_numrows(data) != height || jas_matrix_numcols(data) != width) {\n\t\tif (jas_matrix_resize(data, height, width)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tdr = jas_matrix_getref(data, 0, 0);\n\tdrs = jas_matrix_rowstep(data);\n\tfor (i = 0; i < height; ++i, dr += drs) {\n\t\td = dr;\n\t\tif (jas_stream_seek(cmpt->stream_, (cmpt->width_ * (y + i) + x)\n\t\t  * cmpt->cps_, SEEK_SET) < 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tfor (j = width; j > 0; --j, ++d) {\n\t\t\tv = 0;\n\t\t\tfor (k = cmpt->cps_; k > 0; --k) {\n\t\t\t\tif ((c = jas_stream_getc(cmpt->stream_)) == EOF) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tv = (v << 8) | (c & 0xff);\n\t\t\t}\n\t\t\t*d = bitstoint(v, cmpt->prec_, cmpt->sgnd_);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint jas_image_writecmpt(jas_image_t *image, int cmptno, jas_image_coord_t x, jas_image_coord_t y, jas_image_coord_t width,\n  jas_image_coord_t height, jas_matrix_t *data)\n{\n\tjas_image_cmpt_t *cmpt;\n\tjas_image_coord_t i;\n\tjas_image_coord_t j;\n\tjas_seqent_t *d;\n\tjas_seqent_t *dr;\n\tint drs;\n\tjas_seqent_t v;\n\tint k;\n\tint c;\n\n\tif (cmptno < 0 || cmptno >= image->numcmpts_) {\n\t\treturn -1;\n\t}\n\n\tcmpt = image->cmpts_[cmptno];\n\tif (x >= cmpt->width_ || y >= cmpt->height_ ||\n\t  x + width > cmpt->width_ ||\n\t  y + height > cmpt->height_) {\n\t\treturn -1;\n\t}\n\n\tif (!jas_matrix_numrows(data) || !jas_matrix_numcols(data)) {\n\t\treturn -1;\n\t}\n\n\tif (jas_matrix_numrows(data) != height || jas_matrix_numcols(data) != width) {\n\t\treturn -1;\n\t}\n\n\tdr = jas_matrix_getref(data, 0, 0);\n\tdrs = jas_matrix_rowstep(data);\n\tfor (i = 0; i < height; ++i, dr += drs) {\n\t\td = dr;\n\t\tif (jas_stream_seek(cmpt->stream_, (cmpt->width_ * (y + i) + x)\n\t\t  * cmpt->cps_, SEEK_SET) < 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tfor (j = width; j > 0; --j, ++d) {\n\t\t\tv = inttobits(*d, cmpt->prec_, cmpt->sgnd_);\n\t\t\tfor (k = cmpt->cps_; k > 0; --k) {\n\t\t\t\tc = (v >> (8 * (cmpt->cps_ - 1))) & 0xff;\n\t\t\t\tif (jas_stream_putc(cmpt->stream_,\n\t\t\t\t  (unsigned char) c) == EOF) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tv <<= 8;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/******************************************************************************\\\n* File format operations.\n\\******************************************************************************/\n\nvoid jas_image_clearfmts()\n{\n\tint i;\n\tjas_image_fmtinfo_t *fmtinfo;\n\tfor (i = 0; i < jas_image_numfmts; ++i) {\n\t\tfmtinfo = &jas_image_fmtinfos[i];\n\t\tif (fmtinfo->name) {\n\t\t\tjas_free(fmtinfo->name);\n\t\t\tfmtinfo->name = 0;\n\t\t}\n\t\tif (fmtinfo->ext) {\n\t\t\tjas_free(fmtinfo->ext);\n\t\t\tfmtinfo->ext = 0;\n\t\t}\n\t\tif (fmtinfo->desc) {\n\t\t\tjas_free(fmtinfo->desc);\n\t\t\tfmtinfo->desc = 0;\n\t\t}\n\t}\n\tjas_image_numfmts = 0;\n}\n\nint jas_image_addfmt(int id, char *name, char *ext, char *desc,\n  jas_image_fmtops_t *ops)\n{\n\tjas_image_fmtinfo_t *fmtinfo;\n\tassert(id >= 0 && name && ext && ops);\n\tif (jas_image_numfmts >= JAS_IMAGE_MAXFMTS) {\n\t\treturn -1;\n\t}\n\tfmtinfo = &jas_image_fmtinfos[jas_image_numfmts];\n\tfmtinfo->id = id;\n\tif (!(fmtinfo->name = jas_strdup(name))) {\n\t\treturn -1;\n\t}\n\tif (!(fmtinfo->ext = jas_strdup(ext))) {\n\t\tjas_free(fmtinfo->name);\n\t\treturn -1;\n\t}\n\tif (!(fmtinfo->desc = jas_strdup(desc))) {\n\t\tjas_free(fmtinfo->name);\n\t\tjas_free(fmtinfo->ext);\n\t\treturn -1;\n\t}\n\tfmtinfo->ops = *ops;\n\t++jas_image_numfmts;\n\treturn 0;\n}\n\nint jas_image_strtofmt(char *name)\n{\n\tjas_image_fmtinfo_t *fmtinfo;\n\tif (!(fmtinfo = jas_image_lookupfmtbyname(name))) {\n\t\treturn -1;\n\t}\n\treturn fmtinfo->id;\n}\n\nchar *jas_image_fmttostr(int fmt)\n{\n\tjas_image_fmtinfo_t *fmtinfo;\n\tif (!(fmtinfo = jas_image_lookupfmtbyid(fmt))) {\n\t\treturn 0;\n\t}\n\treturn fmtinfo->name;\n}\n\nint jas_image_getfmt(jas_stream_t *in)\n{\n\tjas_image_fmtinfo_t *fmtinfo;\n\tint found;\n\tint i;\n\n\t/* Check for data in each of the supported formats. */\n\tfound = 0;\n\tfor (i = 0, fmtinfo = jas_image_fmtinfos; i < jas_image_numfmts; ++i,\n\t  ++fmtinfo) {\n\t\tif (fmtinfo->ops.validate) {\n\t\t\t/* Is the input data valid for this format? */\n\t\t\tJAS_DBGLOG(20, (\"testing for format %s ... \", fmtinfo->name));\n\t\t\tif (!(*fmtinfo->ops.validate)(in)) {\n\t\t\t\tJAS_DBGLOG(20, (\"test succeeded\\n\"));\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tJAS_DBGLOG(20, (\"test failed\\n\"));\n\t\t}\n\t}\n\treturn found ? fmtinfo->id : (-1);\n}\n\nint jas_image_fmtfromname(char *name)\n{\n\tint i;\n\tchar *ext;\n\tjas_image_fmtinfo_t *fmtinfo;\n\t/* Get the file name extension. */\n\tif (!(ext = strrchr(name, '.'))) {\n\t\treturn -1;\n\t}\n\t++ext;\n\t/* Try to find a format that uses this extension. */\t\n\tfor (i = 0, fmtinfo = jas_image_fmtinfos; i < jas_image_numfmts; ++i,\n\t  ++fmtinfo) {\n\t\t/* Do we have a match? */\n\t\tif (!strcmp(ext, fmtinfo->ext)) {\n\t\t\treturn fmtinfo->id;\n\t\t}\n\t}\n\treturn -1;\n}\n\n/******************************************************************************\\\n* Miscellaneous operations.\n\\******************************************************************************/\n\nbool jas_image_cmpt_domains_same(jas_image_t *image)\n{\n\tint cmptno;\n\tjas_image_cmpt_t *cmpt;\n\tjas_image_cmpt_t *cmpt0;\n\n\tcmpt0 = image->cmpts_[0];\n\tfor (cmptno = 1; cmptno < image->numcmpts_; ++cmptno) {\n\t\tcmpt = image->cmpts_[cmptno];\n\t\tif (cmpt->tlx_ != cmpt0->tlx_ || cmpt->tly_ != cmpt0->tly_ ||\n\t\t  cmpt->hstep_ != cmpt0->hstep_ || cmpt->vstep_ != cmpt0->vstep_ ||\n\t\t  cmpt->width_ != cmpt0->width_ || cmpt->height_ != cmpt0->height_) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nuint_fast32_t jas_image_rawsize(jas_image_t *image)\n{\n\tuint_fast32_t rawsize;\n\tint cmptno;\n\tjas_image_cmpt_t *cmpt;\n\n\trawsize = 0;\n\tfor (cmptno = 0; cmptno < image->numcmpts_; ++cmptno) {\n\t\tcmpt = image->cmpts_[cmptno];\n\t\trawsize += (cmpt->width_ * cmpt->height_ * cmpt->prec_ +\n\t\t  7) / 8;\n\t}\n\treturn rawsize;\n}\n\nvoid jas_image_delcmpt(jas_image_t *image, int cmptno)\n{\n\tif (cmptno >= image->numcmpts_) {\n\t\treturn;\n\t}\n\tjas_image_cmpt_destroy(image->cmpts_[cmptno]);\n\tif (cmptno < image->numcmpts_) {\n\t\tmemmove(&image->cmpts_[cmptno], &image->cmpts_[cmptno + 1],\n\t\t  (image->numcmpts_ - 1 - cmptno) * sizeof(jas_image_cmpt_t *));\n\t}\n\t--image->numcmpts_;\n\n\tjas_image_setbbox(image);\n}\n\nint jas_image_addcmpt(jas_image_t *image, int cmptno,\n  jas_image_cmptparm_t *cmptparm)\n{\n\tjas_image_cmpt_t *newcmpt;\n\tif (cmptno < 0) {\n\t\tcmptno = image->numcmpts_;\n\t}\n\tassert(cmptno >= 0 && cmptno <= image->numcmpts_);\n\tif (image->numcmpts_ >= image->maxcmpts_) {\n\t\tif (jas_image_growcmpts(image, image->maxcmpts_ + 128)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (!(newcmpt = jas_image_cmpt_create(cmptparm->tlx,\n\t  cmptparm->tly, cmptparm->hstep, cmptparm->vstep,\n\t  cmptparm->width, cmptparm->height, cmptparm->prec,\n\t  cmptparm->sgnd, 1))) {\n\t\treturn -1;\n\t}\n\tif (cmptno < image->numcmpts_) {\n\t\tmemmove(&image->cmpts_[cmptno + 1], &image->cmpts_[cmptno],\n\t\t  (image->numcmpts_ - cmptno) * sizeof(jas_image_cmpt_t *));\n\t}\n\timage->cmpts_[cmptno] = newcmpt;\n\t++image->numcmpts_;\n\n\tjas_image_setbbox(image);\n\n\treturn 0;\n}\n\njas_image_fmtinfo_t *jas_image_lookupfmtbyid(int id)\n{\n\tint i;\n\tjas_image_fmtinfo_t *fmtinfo;\n\n\tfor (i = 0, fmtinfo = jas_image_fmtinfos; i < jas_image_numfmts; ++i, ++fmtinfo) {\n\t\tif (fmtinfo->id == id) {\n\t\t\treturn fmtinfo;\n\t\t}\n\t}\n\treturn 0;\n}\n\njas_image_fmtinfo_t *jas_image_lookupfmtbyname(const char *name)\n{\n\tint i;\n\tjas_image_fmtinfo_t *fmtinfo;\n\n\tfor (i = 0, fmtinfo = jas_image_fmtinfos; i < jas_image_numfmts; ++i, ++fmtinfo) {\n\t\tif (!strcmp(fmtinfo->name, name)) {\n\t\t\treturn fmtinfo;\n\t\t}\n\t}\n\treturn 0;\n}\n\n\n\n\n\nstatic uint_fast32_t inttobits(jas_seqent_t v, int prec, bool sgnd)\n{\n\tuint_fast32_t ret;\n\tret = ((sgnd && v < 0) ? ((1 << prec) + v) : v) & JAS_ONES(prec);\n\treturn ret;\n}\n\nstatic jas_seqent_t bitstoint(uint_fast32_t v, int prec, bool sgnd)\n{\n\tjas_seqent_t ret;\n\tv &= JAS_ONES(prec);\n\tret = (sgnd && (v & (1 << (prec - 1)))) ? (v - (1 << prec)) : v;\n\treturn ret;\n}\n\nstatic void jas_image_setbbox(jas_image_t *image)\n{\n\tjas_image_cmpt_t *cmpt;\n\tint cmptno;\n\tint_fast32_t x;\n\tint_fast32_t y;\n\n\tif (image->numcmpts_ > 0) {\n\t\t/* Determine the bounding box for all of the components on the\n\t\t  reference grid (i.e., the image area) */\n\t\tcmpt = image->cmpts_[0];\n\t\timage->tlx_ = cmpt->tlx_;\n\t\timage->tly_ = cmpt->tly_;\n\t\timage->brx_ = cmpt->tlx_ + cmpt->hstep_ * (cmpt->width_ - 1) + 1;\n\t\timage->bry_ = cmpt->tly_ + cmpt->vstep_ * (cmpt->height_ - 1) + 1;\n\t\tfor (cmptno = 1; cmptno < image->numcmpts_; ++cmptno) {\n\t\t\tcmpt = image->cmpts_[cmptno];\n\t\t\tif (image->tlx_ > cmpt->tlx_) {\n\t\t\t\timage->tlx_ = cmpt->tlx_;\n\t\t\t}\n\t\t\tif (image->tly_ > cmpt->tly_) {\n\t\t\t\timage->tly_ = cmpt->tly_;\n\t\t\t}\n\t\t\tx = cmpt->tlx_ + cmpt->hstep_ * (cmpt->width_ - 1) + 1;\n\t\t\tif (image->brx_ < x) {\n\t\t\t\timage->brx_ = x;\n\t\t\t}\n\t\t\ty = cmpt->tly_ + cmpt->vstep_ * (cmpt->height_ - 1) + 1;\n\t\t\tif (image->bry_ < y) {\n\t\t\t\timage->bry_ = y;\n\t\t\t}\n\t\t}\n\t} else {\n\t\timage->tlx_ = 0;\n\t\timage->tly_ = 0;\n\t\timage->brx_ = 0;\n\t\timage->bry_ = 0;\n\t}\n}\n\nstatic int jas_image_growcmpts(jas_image_t *image, int maxcmpts)\n{\n\tjas_image_cmpt_t **newcmpts;\n\tint cmptno;\n\n\tnewcmpts = (!image->cmpts_) ? jas_alloc2(maxcmpts,\n\t  sizeof(jas_image_cmpt_t *)) :\n\t  jas_realloc2(image->cmpts_, maxcmpts, sizeof(jas_image_cmpt_t *));\n\tif (!newcmpts) {\n\t\treturn -1;\n\t}\n\timage->cmpts_ = newcmpts;\n\timage->maxcmpts_ = maxcmpts;\n\tfor (cmptno = image->numcmpts_; cmptno < image->maxcmpts_; ++cmptno) {\n\t\timage->cmpts_[cmptno] = 0;\n\t}\n\treturn 0;\n}\n\nint jas_image_copycmpt(jas_image_t *dstimage, int dstcmptno,\n  jas_image_t *srcimage, int srccmptno)\n{\n\tjas_image_cmpt_t *newcmpt;\n\tif (dstimage->numcmpts_ >= dstimage->maxcmpts_) {\n\t\tif (jas_image_growcmpts(dstimage, dstimage->maxcmpts_ + 128)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (!(newcmpt = jas_image_cmpt_copy(srcimage->cmpts_[srccmptno]))) {\n\t\treturn -1;\n\t}\n\tif (dstcmptno < dstimage->numcmpts_) {\n\t\tmemmove(&dstimage->cmpts_[dstcmptno + 1], &dstimage->cmpts_[dstcmptno],\n\t\t  (dstimage->numcmpts_ - dstcmptno) * sizeof(jas_image_cmpt_t *));\n\t}\n\tdstimage->cmpts_[dstcmptno] = newcmpt;\n\t++dstimage->numcmpts_;\n\n\tjas_image_setbbox(dstimage);\n\treturn 0;\n}\n\nvoid jas_image_dump(jas_image_t *image, FILE *out)\n{\n\tlong buf[1024];\n\tint cmptno;\n\tint n;\n\tint i;\n\tint width;\n\tint height;\n\tjas_image_cmpt_t *cmpt;\n\tfor (cmptno = 0; cmptno < image->numcmpts_; ++cmptno) {\n\t\tcmpt = image->cmpts_[cmptno];\n\t\tfprintf(out, \"prec=%d, sgnd=%d, cmpttype=%\"PRIiFAST32\"\\n\", cmpt->prec_,\n\t\t  cmpt->sgnd_, cmpt->type_);\n\t\twidth = jas_image_cmptwidth(image, cmptno);\n\t\theight = jas_image_cmptheight(image, cmptno);\n\t\tn = JAS_MIN(16, width);\n\t\tif (jas_image_readcmpt2(image, cmptno, 0, 0, n, 1, buf)) {\n\t\t\tabort();\n\t\t}\n\t\tfor (i = 0; i < n; ++i) {\n\t\t\tfprintf(out, \" f(%d,%d)=%ld\", i, 0, buf[i]);\n\t\t}\n\t\tfprintf(out, \"\\n\");\n\t\tif (jas_image_readcmpt2(image, cmptno, width - n, height - 1, n, 1, buf)) {\n\t\t\tabort();\n\t\t}\n\t\tfor (i = 0; i < n; ++i) {\n\t\t\tfprintf(out, \" f(%d,%d)=%ld\", width - n + i, height - 1, buf[i]);\n\t\t}\n\t\tfprintf(out, \"\\n\");\n\t}\n}\n\nint jas_image_depalettize(jas_image_t *image, int cmptno, int numlutents,\n  int_fast32_t *lutents, int dtype, int newcmptno)\n{\n\tjas_image_cmptparm_t cmptparms;\n\tint_fast32_t v;\n\tint i;\n\tint j;\n\tjas_image_cmpt_t *cmpt;\n\n\tcmpt = image->cmpts_[cmptno];\n\tcmptparms.tlx = cmpt->tlx_;\n\tcmptparms.tly = cmpt->tly_;\n\tcmptparms.hstep = cmpt->hstep_;\n\tcmptparms.vstep = cmpt->vstep_;\n\tcmptparms.width = cmpt->width_;\n\tcmptparms.height = cmpt->height_;\n\tcmptparms.prec = JAS_IMAGE_CDT_GETPREC(dtype);\n\tcmptparms.sgnd = JAS_IMAGE_CDT_GETSGND(dtype);\n\n\tif (jas_image_addcmpt(image, newcmptno, &cmptparms)) {\n\t\treturn -1;\n\t}\n\tif (newcmptno <= cmptno) {\n\t\t++cmptno;\n\t\tcmpt = image->cmpts_[cmptno];\n\t}\n\n\tfor (j = 0; j < cmpt->height_; ++j) {\n\t\tfor (i = 0; i < cmpt->width_; ++i) {\n\t\t\tv = jas_image_readcmptsample(image, cmptno, i, j);\n\t\t\tif (v < 0) {\n\t\t\t\tv = 0;\n\t\t\t} else if (v >= numlutents) {\n\t\t\t\tv = numlutents - 1;\n\t\t\t}\n\t\t\tjas_image_writecmptsample(image, newcmptno, i, j,\n\t\t\t  lutents[v]);\n\t\t}\n\t}\n\treturn 0;\n}\n\nint jas_image_readcmptsample(jas_image_t *image, int cmptno, int x, int y)\n{\n\tjas_image_cmpt_t *cmpt;\n\tuint_fast32_t v;\n\tint k;\n\tint c;\n\n\tcmpt = image->cmpts_[cmptno];\n\n\tif (jas_stream_seek(cmpt->stream_, (cmpt->width_ * y + x) * cmpt->cps_,\n\t  SEEK_SET) < 0) {\n\t\treturn -1;\n\t}\n\tv = 0;\n\tfor (k = cmpt->cps_; k > 0; --k) {\n\t\tif ((c = jas_stream_getc(cmpt->stream_)) == EOF) {\n\t\t\treturn -1;\n\t\t}\n\t\tv = (v << 8) | (c & 0xff);\n\t}\n\treturn bitstoint(v, cmpt->prec_, cmpt->sgnd_);\n}\n\nvoid jas_image_writecmptsample(jas_image_t *image, int cmptno, int x, int y,\n  int_fast32_t v)\n{\n\tjas_image_cmpt_t *cmpt;\n\tuint_fast32_t t;\n\tint k;\n\tint c;\n\n\tcmpt = image->cmpts_[cmptno];\n\n\tif (jas_stream_seek(cmpt->stream_, (cmpt->width_ * y + x) * cmpt->cps_,\n\t  SEEK_SET) < 0) {\n\t\treturn;\n\t}\n\tt = inttobits(v, cmpt->prec_, cmpt->sgnd_);\n\tfor (k = cmpt->cps_; k > 0; --k) {\n\t\tc = (t >> (8 * (cmpt->cps_ - 1))) & 0xff;\n\t\tif (jas_stream_putc(cmpt->stream_, (unsigned char) c) == EOF) {\n\t\t\treturn;\n\t\t}\n\t\tt <<= 8;\n\t}\n}\n\nint jas_image_getcmptbytype(jas_image_t *image, int ctype)\n{\n\tint cmptno;\n\n\tfor (cmptno = 0; cmptno < image->numcmpts_; ++cmptno) {\n\t\tif (image->cmpts_[cmptno]->type_ == ctype) {\n\t\t\treturn cmptno;\n\t\t}\n\t}\n\treturn -1;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/***********************************************/\n/***********************************************/\n/***********************************************/\n/***********************************************/\n\nint jas_image_readcmpt2(jas_image_t *image, int cmptno, jas_image_coord_t x,\n  jas_image_coord_t y, jas_image_coord_t width, jas_image_coord_t height,\n  long *buf)\n{\n\tjas_image_cmpt_t *cmpt;\n\tjas_image_coord_t i;\n\tjas_image_coord_t j;\n\tlong v;\n\tlong *bufptr;\n\n\tif (cmptno < 0 || cmptno >= image->numcmpts_)\n\t\tgoto error;\n\tcmpt = image->cmpts_[cmptno];\n\tif (x < 0 || x >= cmpt->width_ || y < 0 || y >= cmpt->height_ ||\n\t  width < 0 || height < 0 || x + width > cmpt->width_ ||\n\t  y + height > cmpt->height_)\n\t\tgoto error;\n\n\tbufptr = buf;\n\tfor (i = 0; i < height; ++i) {\n\t\tif (jas_stream_seek(cmpt->stream_, (cmpt->width_ * (y + i) + x)\n\t\t  * cmpt->cps_, SEEK_SET) < 0)\n\t\t\tgoto error;\n\t\tfor (j = 0; j < width; ++j) {\n\t\t\tif (getint(cmpt->stream_, cmpt->sgnd_, cmpt->prec_, &v))\n\t\t\t\tgoto error;\n\t\t\t*bufptr++ = v;\n\t\t}\n\t}\n\n\treturn 0;\nerror:\n\treturn -1;\n}\n\nint jas_image_writecmpt2(jas_image_t *image, int cmptno, jas_image_coord_t x,\n  jas_image_coord_t y, jas_image_coord_t width, jas_image_coord_t height,\n  long *buf)\n{\n\tjas_image_cmpt_t *cmpt;\n\tjas_image_coord_t i;\n\tjas_image_coord_t j;\n\tlong v;\n\tlong *bufptr;\n\n\tif (cmptno < 0 || cmptno >= image->numcmpts_)\n\t\tgoto error;\n\tcmpt = image->cmpts_[cmptno];\n\tif (x < 0 || x >= cmpt->width_ || y < 0 || y >= cmpt->height_ ||\n\t  width < 0 || height < 0 || x + width > cmpt->width_ ||\n\t  y + height > cmpt->height_)\n\t\tgoto error;\n\n\tbufptr = buf;\n\tfor (i = 0; i < height; ++i) {\n\t\tif (jas_stream_seek(cmpt->stream_, (cmpt->width_ * (y + i) + x)\n\t\t  * cmpt->cps_, SEEK_SET) < 0)\n\t\t\tgoto error;\n\t\tfor (j = 0; j < width; ++j) {\n\t\t\tv = *bufptr++;\n\t\t\tif (putint(cmpt->stream_, cmpt->sgnd_, cmpt->prec_, v))\n\t\t\t\tgoto error;\n\t\t}\n\t}\n\n\treturn 0;\nerror:\n\treturn -1;\n}\n\nint jas_image_sampcmpt(jas_image_t *image, int cmptno, int newcmptno,\n  jas_image_coord_t ho, jas_image_coord_t vo, jas_image_coord_t hs,\n  jas_image_coord_t vs, int sgnd, int prec)\n{\n\tjas_image_cmpt_t *oldcmpt;\n\tjas_image_cmpt_t *newcmpt;\n\tint width;\n\tint height;\n\tjas_image_coord_t tlx;\n\tjas_image_coord_t tly;\n\tjas_image_coord_t brx;\n\tjas_image_coord_t bry;\n\tint i;\n\tint j;\n\tjas_image_cmptparm_t cmptparm;\n\tjas_image_coord_t ax;\n\tjas_image_coord_t ay;\n\tjas_image_coord_t bx;\n\tjas_image_coord_t by;\n\tjas_image_coord_t d0;\n\tjas_image_coord_t d1;\n\tjas_image_coord_t d2;\n\tjas_image_coord_t d3;\n\tjas_image_coord_t oldx;\n\tjas_image_coord_t oldy;\n\tjas_image_coord_t x;\n\tjas_image_coord_t y;\n\tlong v;\n\tjas_image_coord_t cmptbrx;\n\tjas_image_coord_t cmptbry;\n\n\tassert(cmptno >= 0 && cmptno < image->numcmpts_);\n\toldcmpt = image->cmpts_[cmptno];\n\tassert(oldcmpt->tlx_ == 0 && oldcmpt->tly_ == 0);\n\tjas_image_calcbbox2(image, &tlx, &tly, &brx, &bry);\n\twidth = FLOORDIV(brx - ho + hs, hs);\n\theight = FLOORDIV(bry - vo + vs, vs);\n\tcmptparm.tlx = ho;\n\tcmptparm.tly = vo;\n\tcmptparm.hstep = hs;\n\tcmptparm.vstep = vs;\n\tcmptparm.width = width;\n\tcmptparm.height = height;\n\tcmptparm.prec = prec;\n\tcmptparm.sgnd = sgnd;\n\tif (jas_image_addcmpt(image, newcmptno, &cmptparm))\n\t\tgoto error;\ncmptbrx = oldcmpt->tlx_ + (oldcmpt->width_ - 1) * oldcmpt->hstep_;\ncmptbry = oldcmpt->tly_ + (oldcmpt->height_ - 1) * oldcmpt->vstep_;\n\tnewcmpt = image->cmpts_[newcmptno];\n\tjas_stream_rewind(newcmpt->stream_);\n\tfor (i = 0; i < height; ++i) {\n\t\ty = newcmpt->tly_ + newcmpt->vstep_ * i;\n\t\tfor (j = 0; j < width; ++j) {\n\t\t\tx = newcmpt->tlx_ + newcmpt->hstep_ * j;\n\t\t\tax = downtomult(x - oldcmpt->tlx_, oldcmpt->hstep_) + oldcmpt->tlx_;\n\t\t\tay = downtomult(y - oldcmpt->tly_, oldcmpt->vstep_) + oldcmpt->tly_;\n\t\t\tbx = uptomult(x - oldcmpt->tlx_, oldcmpt->hstep_) + oldcmpt->tlx_;\n\t\t\tif (bx > cmptbrx)\n\t\t\t\tbx = cmptbrx;\n\t\t\tby = uptomult(y - oldcmpt->tly_, oldcmpt->vstep_) + oldcmpt->tly_;\n\t\t\tif (by > cmptbry)\n\t\t\t\tby = cmptbry;\n\t\t\td0 = (ax - x) * (ax - x) + (ay - y) * (ay - y);\n\t\t\td1 = (bx - x) * (bx - x) + (ay - y) * (ay - y);\n\t\t\td2 = (bx - x) * (bx - x) + (by - y) * (by - y);\n\t\t\td3 = (ax - x) * (ax - x) + (by - y) * (by - y);\n\t\t\tif (d0 <= d1 && d0 <= d2 && d0 <= d3) {\n\t\t\t\toldx = (ax - oldcmpt->tlx_) / oldcmpt->hstep_;\n\t\t\t\toldy = (ay - oldcmpt->tly_) / oldcmpt->vstep_;\n\t\t\t} else if (d1 <= d0 && d1 <= d2 && d1 <= d3) {\n\t\t\t\toldx = (bx - oldcmpt->tlx_) / oldcmpt->hstep_;\n\t\t\t\toldy = (ay - oldcmpt->tly_) / oldcmpt->vstep_;\n\t\t\t} else if (d2 <= d0 && d2 <= d1 && d1 <= d3) {\n\t\t\t\toldx = (bx - oldcmpt->tlx_) / oldcmpt->hstep_;\n\t\t\t\toldy = (by - oldcmpt->tly_) / oldcmpt->vstep_;\n\t\t\t} else {\n\t\t\t\toldx = (ax - oldcmpt->tlx_) / oldcmpt->hstep_;\n\t\t\t\toldy = (by - oldcmpt->tly_) / oldcmpt->vstep_;\n\t\t\t}\n\t\t\tassert(oldx >= 0 && oldx < oldcmpt->width_ &&\n\t\t\t  oldy >= 0 && oldy < oldcmpt->height_);\n\t\t\tif (jas_stream_seek(oldcmpt->stream_, oldcmpt->cps_ *\n\t\t\t  (oldy * oldcmpt->width_ + oldx), SEEK_SET) < 0)\n\t\t\t\tgoto error;\n\t\t\tif (getint(oldcmpt->stream_, oldcmpt->sgnd_,\n\t\t\t  oldcmpt->prec_, &v))\n\t\t\t\tgoto error;\n\t\t\tif (newcmpt->prec_ != oldcmpt->prec_ ||\n\t\t\t  newcmpt->sgnd_ != oldcmpt->sgnd_) {\n\t\t\t\tv = convert(v, oldcmpt->sgnd_, oldcmpt->prec_,\n\t\t\t\t  newcmpt->sgnd_, newcmpt->prec_);\n\t\t\t}\n\t\t\tif (putint(newcmpt->stream_, newcmpt->sgnd_,\n\t\t\t  newcmpt->prec_, v))\n\t\t\t\tgoto error;\n\t\t}\n\t}\n\treturn 0;\nerror:\n\treturn -1;\n}\n\nint jas_image_ishomosamp(jas_image_t *image)\n{\n\tjas_image_coord_t hstep;\n\tjas_image_coord_t vstep;\n\tint result;\n\tint i;\n\thstep = jas_image_cmpthstep(image, 0);\n\tvstep = jas_image_cmptvstep(image, 0);\n\tresult = 1;\n\tfor (i = 0; i < image->numcmpts_; ++i) {\n\t\tif (jas_image_cmpthstep(image, i) != hstep ||\n\t\t  jas_image_cmptvstep(image, i) != vstep) {\n\t\t\tresult = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn result;\n}\n\n/* Note: This function defines a bounding box differently. */\nstatic void jas_image_calcbbox2(jas_image_t *image, jas_image_coord_t *tlx,\n  jas_image_coord_t *tly, jas_image_coord_t *brx, jas_image_coord_t *bry)\n{\n\tjas_image_cmpt_t *cmpt;\n\tjas_image_coord_t tmptlx;\n\tjas_image_coord_t tmptly;\n\tjas_image_coord_t tmpbrx;\n\tjas_image_coord_t tmpbry;\n\tjas_image_coord_t t;\n\tint i;\n\tif (image->numcmpts_ > 0) {\n\t\tcmpt = image->cmpts_[0];\n\t\ttmptlx = cmpt->tlx_;\n\t\ttmptly = cmpt->tly_;\n\t\ttmpbrx = cmpt->tlx_ + cmpt->hstep_ * (cmpt->width_ - 1);\n\t\ttmpbry = cmpt->tly_ + cmpt->vstep_ * (cmpt->height_ - 1);\n\t\tfor (i = 0; i < image->numcmpts_; ++i) {\n\t\t\tcmpt = image->cmpts_[i];\n\t\t\tif (cmpt->tlx_ < tmptlx)\n\t\t\t\ttmptlx = cmpt->tlx_;\n\t\t\tif (cmpt->tly_ < tmptly)\n\t\t\t\ttmptly = cmpt->tly_;\n\t\t\tt = cmpt->tlx_ + cmpt->hstep_ * (cmpt->width_ - 1);\n\t\t\tif (t > tmpbrx)\n\t\t\t\ttmpbrx = t;\n\t\t\tt = cmpt->tly_ + cmpt->vstep_ * (cmpt->height_ - 1);\n\t\t\tif (t > tmpbry)\n\t\t\t\ttmpbry = t;\n\t\t}\n\t} else {\n\t\ttmptlx = 0;\n\t\ttmptly = 0;\n\t\ttmpbrx = -1;\n\t\ttmpbry = -1;\n\t}\n\t*tlx = tmptlx;\n\t*tly = tmptly;\n\t*brx = tmpbrx;\n\t*bry = tmpbry;\n}\n\nstatic inline long decode_twos_comp(ulong c, int prec)\n{\n\tlong result;\n\tassert(prec >= 2);\n\tjas_eprintf(\"warning: support for signed data is untested\\n\");\n\t// NOTE: Is this correct?\n\tresult = (c & ((1 << (prec - 1)) - 1)) - (c & (1 << (prec - 1)));\n\treturn result;\n}\n\nstatic inline ulong encode_twos_comp(long n, int prec)\n{\n\tulong result;\n\tassert(prec >= 2);\n\tjas_eprintf(\"warning: support for signed data is untested\\n\");\n\t// NOTE: Is this correct?\n\tif (n < 0) {\n\t\tresult = -n;\n\t\tresult = (result ^ 0xffffffffUL) + 1;\n\t\tresult &= (1 << prec) - 1;\n\t} else {\n\t\tresult = n;\n\t}\n\treturn result;\n}\n\nstatic int getint(jas_stream_t *in, int sgnd, int prec, long *val)\n{\n\tlong v;\n\tint n;\n\tint c;\n\tassert((!sgnd && prec >= 1) || (sgnd && prec >= 2));\n\tn = (prec + 7) / 8;\n\tv = 0;\n\twhile (--n >= 0) {\n\t\tif ((c = jas_stream_getc(in)) == EOF)\n\t\t\treturn -1;\n\t\tv = (v << 8) | c;\n\t}\n\tv &= ((1 << prec) - 1);\n\tif (sgnd) {\n\t\t*val = decode_twos_comp(v, prec);\n\t} else {\n\t\t*val = v;\n\t}\n\treturn 0;\n}\n\nstatic int putint(jas_stream_t *out, int sgnd, int prec, long val)\n{\n\tint n;\n\tint c;\n\tbool s;\n\tulong tmp;\n\tassert((!sgnd && prec >= 1) || (sgnd && prec >= 2));\n\tif (sgnd) {\n\t\tval = encode_twos_comp(val, prec);\n\t}\n\tassert(val >= 0);\n\tval &= (1 << prec) - 1;\n\tn = (prec + 7) / 8;\n\twhile (--n >= 0) {\n\t\tc = (val >> (n * 8)) & 0xff;\n\t\tif (jas_stream_putc(out, c) != c)\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic long convert(long val, int oldsgnd, int oldprec, int newsgnd,\n  int newprec)\n{\n\tif (newsgnd != oldsgnd) {\n\t}\n\tif (newprec != oldprec) {\n\t\tif (newprec > oldprec) {\n\t\t\tval <<= newprec - oldprec;\n\t\t} else if (oldprec > newprec) {\n\t\t\tval >>= oldprec - newprec;\n\t\t}\n\t}\n\treturn val;\n}\n\nstatic long downtomult(long x, long y)\n{\n\tassert(x >= 0);\n\treturn (x / y) * y;\n}\n\nstatic long uptomult(long x, long y)\n{\n\tassert(x >= 0);\n\treturn ((x + y - 1) / y) * y;\n}\n\njas_image_t *jas_image_chclrspc(jas_image_t *image, jas_cmprof_t *outprof,\n  int intent)\n{\n\tjas_image_t *inimage;\n\tint minhstep;\n\tint minvstep;\n\tint i;\n\tint j;\n\tint k;\n\tint n;\n\tint hstep;\n\tint vstep;\n\tint numinauxchans;\n\tint numoutauxchans;\n\tint numinclrchans;\n\tint numoutclrchans;\n\tint prec;\n\tjas_image_t *outimage;\n\tint cmpttype;\n\tint numoutchans;\n\tjas_cmprof_t *inprof;\n\tjas_cmprof_t *tmpprof;\n\tjas_image_cmptparm_t cmptparm;\n\tint width;\n\tint height;\n\tjas_cmxform_t *xform;\n\tjas_cmpixmap_t inpixmap;\n\tjas_cmpixmap_t outpixmap;\n\tjas_cmcmptfmt_t *incmptfmts;\n\tjas_cmcmptfmt_t *outcmptfmts;\n\n#if 0\njas_eprintf(\"IMAGE\\n\");\njas_image_dump(image, stderr);\n#endif\n\n\toutimage = 0;\n\txform = 0;\n\tif (!(inimage = jas_image_copy(image)))\n\t\tgoto error;\n\timage = 0;\n\n\tif (!jas_image_ishomosamp(inimage)) {\n\t\tminhstep = jas_image_cmpthstep(inimage, 0);\n\t\tminvstep = jas_image_cmptvstep(inimage, 0);\n\t\tfor (i = 1; i < jas_image_numcmpts(inimage); ++i) {\n\t\t\thstep = jas_image_cmpthstep(inimage, i);\n\t\t\tvstep = jas_image_cmptvstep(inimage, i);\n\t\t\tif (hstep < minhstep) {\n\t\t\t\tminhstep = hstep;\n\t\t\t}\n\t\t\tif (vstep < minvstep) {\n\t\t\t\tminvstep = vstep;\n\t\t\t}\n\t\t}\n\t\tn = jas_image_numcmpts(inimage);\n\t\tfor (i = 0; i < n; ++i) {\n\t\t\tcmpttype = jas_image_cmpttype(inimage, i);\n\t\t\tif (jas_image_sampcmpt(inimage, i, i + 1, 0, 0, minhstep, minvstep,\n\t\t\t  jas_image_cmptsgnd(inimage, i), jas_image_cmptprec(inimage, i))) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tjas_image_setcmpttype(inimage, i + 1, cmpttype);\n\t\t\tjas_image_delcmpt(inimage, i);\n\t\t}\n\t}\n\n\twidth = jas_image_cmptwidth(inimage, 0);\n\theight = jas_image_cmptheight(inimage, 0);\n\thstep = jas_image_cmpthstep(inimage, 0);\n\tvstep = jas_image_cmptvstep(inimage, 0);\n\n\tif (!(inprof = jas_image_cmprof(inimage))) {\n\t\tabort();\n\t}\n\tnuminclrchans = jas_clrspc_numchans(jas_cmprof_clrspc(inprof));\n\tnuminauxchans = jas_image_numcmpts(inimage) - numinclrchans;\n\tnumoutclrchans = jas_clrspc_numchans(jas_cmprof_clrspc(outprof));\n\tnumoutauxchans = 0;\n\tnumoutchans = numoutclrchans + numoutauxchans;\n\tprec = 8;\n\n\tif (!(outimage = jas_image_create0())) {\n\t\tgoto error;\n\t}\n\n\t/* Create a component for each of the colorants. */\n\tfor (i = 0; i < numoutclrchans; ++i) {\n\t\tcmptparm.tlx = 0;\n\t\tcmptparm.tly = 0;\n\t\tcmptparm.hstep = hstep;\n\t\tcmptparm.vstep = vstep;\n\t\tcmptparm.width = width;\n\t\tcmptparm.height = height;\n\t\tcmptparm.prec = prec;\n\t\tcmptparm.sgnd = 0;\n\t\tif (jas_image_addcmpt(outimage, -1, &cmptparm))\n\t\t\tgoto error;\n\t\tjas_image_setcmpttype(outimage, i, JAS_IMAGE_CT_COLOR(i));\n\t}\n#if 0\n\t/* Copy the auxiliary components without modification. */\n\tfor (i = 0; i < jas_image_numcmpts(inimage); ++i) {\n\t\tif (!ISCOLOR(jas_image_cmpttype(inimage, i))) {\n\t\t\tjas_image_copycmpt(outimage, -1, inimage, i);\n/* XXX - need to specify laydown of component on ref. grid */\n\t\t}\n\t}\n#endif\n\n\tif (!(tmpprof = jas_cmprof_copy(outprof)))\n\t\tgoto error;\n\tassert(!jas_image_cmprof(outimage));\n\tjas_image_setcmprof(outimage, tmpprof);\n\ttmpprof = 0;\n\tjas_image_setclrspc(outimage, jas_cmprof_clrspc(outprof));\n\n\tif (!(xform = jas_cmxform_create(inprof, outprof, 0, JAS_CMXFORM_OP_FWD,\n\t  intent, 0))) {\n\t\tgoto error;\n\t}\n\n\tinpixmap.numcmpts = numinclrchans;\n\tif (!(incmptfmts = jas_alloc2(numinclrchans, sizeof(jas_cmcmptfmt_t)))) {\n\t\tabort();\n\t}\n\tinpixmap.cmptfmts = incmptfmts;\n\tfor (i = 0; i < numinclrchans; ++i) {\n\t\tj = jas_image_getcmptbytype(inimage, JAS_IMAGE_CT_COLOR(i));\n\t\tassert(j >= 0);\n\t\tif (!(incmptfmts[i].buf = jas_alloc2(width, sizeof(long)))) {\n\t\t\tgoto error;\n\t\t}\n\t\tincmptfmts[i].prec = jas_image_cmptprec(inimage, j);\n\t\tincmptfmts[i].sgnd = jas_image_cmptsgnd(inimage, j);\n\t\tincmptfmts[i].width = width;\n\t\tincmptfmts[i].height = 1;\n\t}\n\n\toutpixmap.numcmpts = numoutclrchans;\n\tif (!(outcmptfmts = jas_alloc2(numoutclrchans, sizeof(jas_cmcmptfmt_t)))) {\n\t\tabort();\n\t}\n\toutpixmap.cmptfmts = outcmptfmts;\n\n\tfor (i = 0; i < numoutclrchans; ++i) {\n\t\tj = jas_image_getcmptbytype(outimage, JAS_IMAGE_CT_COLOR(i));\n\t\tassert(j >= 0);\n\t\tif (!(outcmptfmts[i].buf = jas_alloc2(width, sizeof(long))))\n\t\t\tgoto error;\n\t\toutcmptfmts[i].prec = jas_image_cmptprec(outimage, j);\n\t\toutcmptfmts[i].sgnd = jas_image_cmptsgnd(outimage, j);\n\t\toutcmptfmts[i].width = width;\n\t\toutcmptfmts[i].height = 1;\n\t}\n\n\tfor (i = 0; i < height; ++i) {\n\t\tfor (j = 0; j < numinclrchans; ++j) {\n\t\t\tk = jas_image_getcmptbytype(inimage, JAS_IMAGE_CT_COLOR(j));\n\t\t\tif (jas_image_readcmpt2(inimage, k, 0, i, width, 1,\n\t\t\t  incmptfmts[j].buf))\n\t\t\t\tgoto error;\n\t\t}\n\t\tjas_cmxform_apply(xform, &inpixmap, &outpixmap);\n\t\tfor (j = 0; j < numoutclrchans; ++j) {\n\t\t\tk = jas_image_getcmptbytype(outimage, JAS_IMAGE_CT_COLOR(j));\n\t\t\tif (jas_image_writecmpt2(outimage, k, 0, i, width, 1,\n\t\t\t  outcmptfmts[j].buf))\n\t\t\t\tgoto error;\n\t\t}\n\t}\n\n\tfor (i = 0; i < numoutclrchans; ++i) {\n\t\tjas_free(outcmptfmts[i].buf);\n\t}\n\tjas_free(outcmptfmts);\n\tfor (i = 0; i < numinclrchans; ++i) {\n\t\tjas_free(incmptfmts[i].buf);\n\t}\n\tjas_free(incmptfmts);\n\tjas_cmxform_destroy(xform);\n\tjas_image_destroy(inimage);\n\n#if 0\njas_eprintf(\"INIMAGE\\n\");\njas_image_dump(inimage, stderr);\njas_eprintf(\"OUTIMAGE\\n\");\njas_image_dump(outimage, stderr);\n#endif\n\treturn outimage;\nerror:\n\tif (xform)\n\t\tjas_cmxform_destroy(xform);\n\tif (inimage)\n\t\tjas_image_destroy(inimage);\n\tif (outimage)\n\t\tjas_image_destroy(outimage);\n\treturn 0;\n}\n", "/*\n * Copyright (c) 1999-2000 Image Power, Inc. and the University of\n *   British Columbia.\n * Copyright (c) 2001-2003 Michael David Adams.\n * All rights reserved.\n */\n\n/* __START_OF_JASPER_LICENSE__\n * \n * JasPer License Version 2.0\n * \n * Copyright (c) 2001-2006 Michael David Adams\n * Copyright (c) 1999-2000 Image Power, Inc.\n * Copyright (c) 1999-2000 The University of British Columbia\n * \n * All rights reserved.\n * \n * Permission is hereby granted, free of charge, to any person (the\n * \"User\") obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n * \n * 1.  The above copyright notices and this permission notice (which\n * includes the disclaimer below) shall be included in all copies or\n * substantial portions of the Software.\n * \n * 2.  The name of a copyright holder shall not be used to endorse or\n * promote products derived from the Software without specific prior\n * written permission.\n * \n * THIS DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS\n * LICENSE.  NO USE OF THE SOFTWARE IS AUTHORIZED HEREUNDER EXCEPT UNDER\n * THIS DISCLAIMER.  THE SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS\n * \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.  IN NO\n * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL\n * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING\n * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\n * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION\n * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  NO ASSURANCES ARE\n * PROVIDED BY THE COPYRIGHT HOLDERS THAT THE SOFTWARE DOES NOT INFRINGE\n * THE PATENT OR OTHER INTELLECTUAL PROPERTY RIGHTS OF ANY OTHER ENTITY.\n * EACH COPYRIGHT HOLDER DISCLAIMS ANY LIABILITY TO THE USER FOR CLAIMS\n * BROUGHT BY ANY OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL\n * PROPERTY RIGHTS OR OTHERWISE.  AS A CONDITION TO EXERCISING THE RIGHTS\n * GRANTED HEREUNDER, EACH USER HEREBY ASSUMES SOLE RESPONSIBILITY TO SECURE\n * ANY OTHER INTELLECTUAL PROPERTY RIGHTS NEEDED, IF ANY.  THE SOFTWARE\n * IS NOT FAULT-TOLERANT AND IS NOT INTENDED FOR USE IN MISSION-CRITICAL\n * SYSTEMS, SUCH AS THOSE USED IN THE OPERATION OF NUCLEAR FACILITIES,\n * AIRCRAFT NAVIGATION OR COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL\n * SYSTEMS, DIRECT LIFE SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH\n * THE FAILURE OF THE SOFTWARE OR SYSTEM COULD LEAD DIRECTLY TO DEATH,\n * PERSONAL INJURY, OR SEVERE PHYSICAL OR ENVIRONMENTAL DAMAGE (\"HIGH\n * RISK ACTIVITIES\").  THE COPYRIGHT HOLDERS SPECIFICALLY DISCLAIM ANY\n * EXPRESS OR IMPLIED WARRANTY OF FITNESS FOR HIGH RISK ACTIVITIES.\n * \n * __END_OF_JASPER_LICENSE__\n */\n\n/*\n * I/O Stream Library\n *\n * $Id$\n */\n\n/******************************************************************************\\\n* Includes.\n\\******************************************************************************/\n\n#include <assert.h>\n#if defined(HAVE_FCNTL_H)\n#include <fcntl.h>\n#endif\n#include <stdlib.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <ctype.h>\n#if defined(HAVE_UNISTD_H)\n#include <unistd.h>\n#endif\n#if defined(WIN32) || defined(HAVE_IO_H)\n#include <io.h>\n#endif\n\n#include \"jasper/jas_debug.h\"\n#include \"jasper/jas_types.h\"\n#include \"jasper/jas_stream.h\"\n#include \"jasper/jas_malloc.h\"\n#include \"jasper/jas_math.h\"\n\n/******************************************************************************\\\n* Local function prototypes.\n\\******************************************************************************/\n\nstatic int jas_strtoopenmode(const char *s);\nstatic void jas_stream_destroy(jas_stream_t *stream);\nstatic jas_stream_t *jas_stream_create(void);\nstatic void jas_stream_initbuf(jas_stream_t *stream, int bufmode, char *buf,\n  int bufsize);\n\nstatic int mem_read(jas_stream_obj_t *obj, char *buf, int cnt);\nstatic int mem_write(jas_stream_obj_t *obj, char *buf, int cnt);\nstatic long mem_seek(jas_stream_obj_t *obj, long offset, int origin);\nstatic int mem_close(jas_stream_obj_t *obj);\n\nstatic int sfile_read(jas_stream_obj_t *obj, char *buf, int cnt);\nstatic int sfile_write(jas_stream_obj_t *obj, char *buf, int cnt);\nstatic long sfile_seek(jas_stream_obj_t *obj, long offset, int origin);\nstatic int sfile_close(jas_stream_obj_t *obj);\n\nstatic int file_read(jas_stream_obj_t *obj, char *buf, int cnt);\nstatic int file_write(jas_stream_obj_t *obj, char *buf, int cnt);\nstatic long file_seek(jas_stream_obj_t *obj, long offset, int origin);\nstatic int file_close(jas_stream_obj_t *obj);\n\n/******************************************************************************\\\n* Local data.\n\\******************************************************************************/\n\nstatic jas_stream_ops_t jas_stream_fileops = {\n\tfile_read,\n\tfile_write,\n\tfile_seek,\n\tfile_close\n};\n\nstatic jas_stream_ops_t jas_stream_sfileops = {\n\tsfile_read,\n\tsfile_write,\n\tsfile_seek,\n\tsfile_close\n};\n\nstatic jas_stream_ops_t jas_stream_memops = {\n\tmem_read,\n\tmem_write,\n\tmem_seek,\n\tmem_close\n};\n\n/******************************************************************************\\\n* Code for opening and closing streams.\n\\******************************************************************************/\n\nstatic jas_stream_t *jas_stream_create()\n{\n\tjas_stream_t *stream;\n\n\tif (!(stream = jas_malloc(sizeof(jas_stream_t)))) {\n\t\treturn 0;\n\t}\n\tstream->openmode_ = 0;\n\tstream->bufmode_ = 0;\n\tstream->flags_ = 0;\n\tstream->bufbase_ = 0;\n\tstream->bufstart_ = 0;\n\tstream->bufsize_ = 0;\n\tstream->ptr_ = 0;\n\tstream->cnt_ = 0;\n\tstream->ops_ = 0;\n\tstream->obj_ = 0;\n\tstream->rwcnt_ = 0;\n\tstream->rwlimit_ = -1;\n\n\treturn stream;\n}\n\njas_stream_t *jas_stream_memopen(char *buf, int bufsize)\n{\n\tjas_stream_t *stream;\n\tjas_stream_memobj_t *obj;\n\n\tJAS_DBGLOG(100, (\"jas_stream_memopen(%p, %d)\\n\", buf, bufsize));\n\n\tif (!(stream = jas_stream_create())) {\n\t\treturn 0;\n\t}\n\n\t/* A stream associated with a memory buffer is always opened\n\tfor both reading and writing in binary mode. */\n\tstream->openmode_ = JAS_STREAM_READ | JAS_STREAM_WRITE | JAS_STREAM_BINARY;\n\n\t/* Since the stream data is already resident in memory, buffering\n\tis not necessary. */\n\t/* But... It still may be faster to use buffering anyways. */\n\tjas_stream_initbuf(stream, JAS_STREAM_FULLBUF, 0, 0);\n\n\t/* Select the operations for a memory stream. */\n\tstream->ops_ = &jas_stream_memops;\n\n\t/* Allocate memory for the underlying memory stream object. */\n\tif (!(obj = jas_malloc(sizeof(jas_stream_memobj_t)))) {\n\t\tjas_stream_destroy(stream);\n\t\treturn 0;\n\t}\n\tstream->obj_ = (void *) obj;\n\n\t/* Initialize a few important members of the memory stream object. */\n\tobj->myalloc_ = 0;\n\tobj->buf_ = 0;\n\n\t/* If the buffer size specified is nonpositive, then the buffer\n\tis allocated internally and automatically grown as needed. */\n\tif (bufsize <= 0) {\n\t\tobj->bufsize_ = 1024;\n\t\tobj->growable_ = 1;\n\t} else {\n\t\tobj->bufsize_ = bufsize;\n\t\tobj->growable_ = 0;\n\t}\n\tif (buf) {\n\t\tobj->buf_ = (unsigned char *) buf;\n\t} else {\n\t\tobj->buf_ = jas_malloc(obj->bufsize_);\n\t\tobj->myalloc_ = 1;\n\t}\n\tif (!obj->buf_) {\n\t\tjas_stream_close(stream);\n\t\treturn 0;\n\t}\n\tJAS_DBGLOG(100, (\"jas_stream_memopen buffer buf=%p myalloc=%d\\n\",\n\t  obj->buf_, obj->myalloc_));\n\n\tif (bufsize > 0 && buf) {\n\t\t/* If a buffer was supplied by the caller and its length is positive,\n\t\t  make the associated buffer data appear in the stream initially. */\n\t\tobj->len_ = bufsize;\n\t} else {\n\t\t/* The stream is initially empty. */\n\t\tobj->len_ = 0;\n\t}\n\tobj->pos_ = 0;\n\t\n\treturn stream;\n}\n\njas_stream_t *jas_stream_fopen(const char *filename, const char *mode)\n{\n\tjas_stream_t *stream;\n\tjas_stream_fileobj_t *obj;\n\tint openflags;\n\n\t/* Allocate a stream object. */\n\tif (!(stream = jas_stream_create())) {\n\t\treturn 0;\n\t}\n\n\t/* Parse the mode string. */\n\tstream->openmode_ = jas_strtoopenmode(mode);\n\n\t/* Determine the correct flags to use for opening the file. */\n\tif ((stream->openmode_ & JAS_STREAM_READ) &&\n\t  (stream->openmode_ & JAS_STREAM_WRITE)) {\n\t\topenflags = O_RDWR;\n\t} else if (stream->openmode_ & JAS_STREAM_READ) {\n\t\topenflags = O_RDONLY;\n\t} else if (stream->openmode_ & JAS_STREAM_WRITE) {\n\t\topenflags = O_WRONLY;\n\t} else {\n\t\topenflags = 0;\n\t}\n\tif (stream->openmode_ & JAS_STREAM_APPEND) {\n\t\topenflags |= O_APPEND;\n\t}\n\tif (stream->openmode_ & JAS_STREAM_BINARY) {\n\t\topenflags |= O_BINARY;\n\t}\n\tif (stream->openmode_ & JAS_STREAM_CREATE) {\n\t\topenflags |= O_CREAT | O_TRUNC;\n\t}\n\n\t/* Allocate space for the underlying file stream object. */\n\tif (!(obj = jas_malloc(sizeof(jas_stream_fileobj_t)))) {\n\t\tjas_stream_destroy(stream);\n\t\treturn 0;\n\t}\n\tobj->fd = -1;\n\tobj->flags = 0;\n\tobj->pathname[0] = '\\0';\n\tstream->obj_ = (void *) obj;\n\n\t/* Select the operations for a file stream object. */\n\tstream->ops_ = &jas_stream_fileops;\n\n\t/* Open the underlying file. */\n\tif ((obj->fd = open(filename, openflags, JAS_STREAM_PERMS)) < 0) {\n\t\t// Free the underlying file object, since it will not otherwise\n\t\t// be freed.\n\t\tjas_free(obj);\n\t\tjas_stream_destroy(stream);\n\t\treturn 0;\n\t}\n\n\t/* By default, use full buffering for this type of stream. */\n\tjas_stream_initbuf(stream, JAS_STREAM_FULLBUF, 0, 0);\n\n\treturn stream;\n}\n\njas_stream_t *jas_stream_freopen(const char *path, const char *mode, FILE *fp)\n{\n\tjas_stream_t *stream;\n\tint openflags;\n\n\t/* Eliminate compiler warning about unused variable. */\n\tpath = 0;\n\n\t/* Allocate a stream object. */\n\tif (!(stream = jas_stream_create())) {\n\t\treturn 0;\n\t}\n\n\t/* Parse the mode string. */\n\tstream->openmode_ = jas_strtoopenmode(mode);\n\n\t/* Determine the correct flags to use for opening the file. */\n\tif ((stream->openmode_ & JAS_STREAM_READ) &&\n\t  (stream->openmode_ & JAS_STREAM_WRITE)) {\n\t\topenflags = O_RDWR;\n\t} else if (stream->openmode_ & JAS_STREAM_READ) {\n\t\topenflags = O_RDONLY;\n\t} else if (stream->openmode_ & JAS_STREAM_WRITE) {\n\t\topenflags = O_WRONLY;\n\t} else {\n\t\topenflags = 0;\n\t}\n\tif (stream->openmode_ & JAS_STREAM_APPEND) {\n\t\topenflags |= O_APPEND;\n\t}\n\tif (stream->openmode_ & JAS_STREAM_BINARY) {\n\t\topenflags |= O_BINARY;\n\t}\n\tif (stream->openmode_ & JAS_STREAM_CREATE) {\n\t\topenflags |= O_CREAT | O_TRUNC;\n\t}\n\n\tstream->obj_ = JAS_CAST(void *, fp);\n\n\t/* Select the operations for a file stream object. */\n\tstream->ops_ = &jas_stream_sfileops;\n\n\t/* By default, use full buffering for this type of stream. */\n\tjas_stream_initbuf(stream, JAS_STREAM_FULLBUF, 0, 0);\n\n\treturn stream;\n}\n\njas_stream_t *jas_stream_tmpfile()\n{\n\tjas_stream_t *stream;\n\tjas_stream_fileobj_t *obj;\n\n\tif (!(stream = jas_stream_create())) {\n\t\treturn 0;\n\t}\n\n\t/* A temporary file stream is always opened for both reading and\n\twriting in binary mode. */\n\tstream->openmode_ = JAS_STREAM_READ | JAS_STREAM_WRITE | JAS_STREAM_BINARY;\n\n\t/* Allocate memory for the underlying temporary file object. */\n\tif (!(obj = jas_malloc(sizeof(jas_stream_fileobj_t)))) {\n\t\tjas_stream_destroy(stream);\n\t\treturn 0;\n\t}\n\tobj->fd = -1;\n\tobj->flags = 0;\n\tobj->pathname[0] = '\\0';\n\tstream->obj_ = obj;\n\n\t/* Choose a file name. */\n\ttmpnam(obj->pathname);\n\n\t/* Open the underlying file. */\n\tif ((obj->fd = open(obj->pathname, O_CREAT | O_EXCL | O_RDWR | O_TRUNC | O_BINARY,\n\t  JAS_STREAM_PERMS)) < 0) {\n\t\tjas_stream_destroy(stream);\n\t\treturn 0;\n\t}\n\n\t/* Unlink the file so that it will disappear if the program\n\tterminates abnormally. */\n\t/* Under UNIX, one can unlink an open file and continue to do I/O\n\ton it.  Not all operating systems support this functionality, however.\n\tFor example, under Microsoft Windows the unlink operation will fail,\n\tsince the file is open. */\n\tif (unlink(obj->pathname)) {\n\t\t/* We will try unlinking the file again after it is closed. */\n\t\tobj->flags |= JAS_STREAM_FILEOBJ_DELONCLOSE;\n\t}\n\n\t/* Use full buffering. */\n\tjas_stream_initbuf(stream, JAS_STREAM_FULLBUF, 0, 0);\n\n\tstream->ops_ = &jas_stream_fileops;\n\n\treturn stream;\n}\n\njas_stream_t *jas_stream_fdopen(int fd, const char *mode)\n{\n\tjas_stream_t *stream;\n\tjas_stream_fileobj_t *obj;\n\n\t/* Allocate a stream object. */\n\tif (!(stream = jas_stream_create())) {\n\t\treturn 0;\n\t}\n\n\t/* Parse the mode string. */\n\tstream->openmode_ = jas_strtoopenmode(mode);\n\n#if defined(WIN32)\n\t/* Argh!!!  Someone ought to banish text mode (i.e., O_TEXT) to the\n\t  greatest depths of purgatory! */\n\t/* Ensure that the file descriptor is in binary mode, if the caller\n\t  has specified the binary mode flag.  Arguably, the caller ought to\n\t  take care of this, but text mode is a ugly wart anyways, so we save\n\t  the caller some grief by handling this within the stream library. */\n\t/* This ugliness is mainly for the benefit of those who run the\n\t  JasPer software under Windows from shells that insist on opening\n\t  files in text mode.  For example, in the Cygwin environment,\n\t  shells often open files in text mode when I/O redirection is\n\t  used.  Grr... */\n\tif (stream->openmode_ & JAS_STREAM_BINARY) {\n\t\tsetmode(fd, O_BINARY);\n\t}\n#endif\n\n\t/* Allocate space for the underlying file stream object. */\n\tif (!(obj = jas_malloc(sizeof(jas_stream_fileobj_t)))) {\n\t\tjas_stream_destroy(stream);\n\t\treturn 0;\n\t}\n\tobj->fd = fd;\n\tobj->flags = 0;\n\tobj->pathname[0] = '\\0';\n\tstream->obj_ = (void *) obj;\n\n\t/* Do not close the underlying file descriptor when the stream is\n\tclosed. */\n\tobj->flags |= JAS_STREAM_FILEOBJ_NOCLOSE;\n\n\t/* By default, use full buffering for this type of stream. */\n\tjas_stream_initbuf(stream, JAS_STREAM_FULLBUF, 0, 0);\n\n\t/* Select the operations for a file stream object. */\n\tstream->ops_ = &jas_stream_fileops;\n\n\treturn stream;\n}\n\nstatic void jas_stream_destroy(jas_stream_t *stream)\n{\n\t/* If the memory for the buffer was allocated with malloc, free\n\tthis memory. */\n\tif ((stream->bufmode_ & JAS_STREAM_FREEBUF) && stream->bufbase_) {\n\t\tJAS_DBGLOG(100, (\"jas_stream_destroy freeing buffer %p\\n\",\n\t\t  stream->bufbase_));\n\t\tjas_free(stream->bufbase_);\n\t\tstream->bufbase_ = 0;\n\t}\n\tjas_free(stream);\n}\n\nint jas_stream_close(jas_stream_t *stream)\n{\n\t/* Flush buffer if necessary. */\n\tjas_stream_flush(stream);\n\n\t/* Close the underlying stream object. */\n\t(*stream->ops_->close_)(stream->obj_);\n\n\tjas_stream_destroy(stream);\n\n\treturn 0;\n}\n\n/******************************************************************************\\\n* Code for reading and writing streams.\n\\******************************************************************************/\n\nint jas_stream_getc_func(jas_stream_t *stream)\n{\n\tassert(stream->ptr_ - stream->bufbase_ <= stream->bufsize_ +\n\t  JAS_STREAM_MAXPUTBACK);\n\treturn jas_stream_getc_macro(stream);\n}\n\nint jas_stream_putc_func(jas_stream_t *stream, int c)\n{\n\tassert(stream->ptr_ - stream->bufstart_ <= stream->bufsize_);\n\treturn jas_stream_putc_macro(stream, c);\n}\n\nint jas_stream_ungetc(jas_stream_t *stream, int c)\n{\n\tif (!stream->ptr_ || stream->ptr_ == stream->bufbase_) {\n\t\treturn -1;\n\t}\n\n\t/* Reset the EOF indicator (since we now have at least one character\n\t  to read). */\n\tstream->flags_ &= ~JAS_STREAM_EOF;\n\n\t--stream->rwcnt_;\n\t--stream->ptr_;\n\t++stream->cnt_;\n\t*stream->ptr_ = c;\n\treturn 0;\n}\n\nint jas_stream_read(jas_stream_t *stream, void *buf, int cnt)\n{\n\tint n;\n\tint c;\n\tchar *bufptr;\n\n\tbufptr = buf;\n\n\tn = 0;\n\twhile (n < cnt) {\n\t\tif ((c = jas_stream_getc(stream)) == EOF) {\n\t\t\treturn n;\n\t\t}\n\t\t*bufptr++ = c;\n\t\t++n;\n\t}\n\n\treturn n;\n}\n\nint jas_stream_write(jas_stream_t *stream, const void *buf, int cnt)\n{\n\tint n;\n\tconst char *bufptr;\n\n\tbufptr = buf;\n\n\tn = 0;\n\twhile (n < cnt) {\n\t\tif (jas_stream_putc(stream, *bufptr) == EOF) {\n\t\t\treturn n;\n\t\t}\n\t\t++bufptr;\n\t\t++n;\n\t}\n\n\treturn n;\n}\n\n/* Note: This function uses a fixed size buffer.  Therefore, it cannot\n  handle invocations that will produce more output than can be held\n  by the buffer. */\nint jas_stream_printf(jas_stream_t *stream, const char *fmt, ...)\n{\n\tva_list ap;\n\tchar buf[4096];\n\tint ret;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(buf, sizeof buf, fmt, ap);\n\tjas_stream_puts(stream, buf);\n\tva_end(ap);\n\treturn ret;\n}\n\nint jas_stream_puts(jas_stream_t *stream, const char *s)\n{\n\twhile (*s != '\\0') {\n\t\tif (jas_stream_putc_macro(stream, *s) == EOF) {\n\t\t\treturn -1;\n\t\t}\n\t\t++s;\n\t}\n\treturn 0;\n}\n\nchar *jas_stream_gets(jas_stream_t *stream, char *buf, int bufsize)\n{\n\tint c;\n\tchar *bufptr;\n\tassert(bufsize > 0);\n\n\tbufptr = buf;\n\twhile (bufsize > 1) {\n\t\tif ((c = jas_stream_getc(stream)) == EOF) {\n\t\t\tbreak;\n\t\t}\n\t\t*bufptr++ = c;\n\t\t--bufsize;\n\t\tif (c == '\\n') {\n\t\t\tbreak;\n\t\t}\n\t}\n\t*bufptr = '\\0';\n\treturn buf;\n}\n\nint jas_stream_gobble(jas_stream_t *stream, int n)\n{\n\tint m;\n\tm = n;\n\tfor (m = n; m > 0; --m) {\n\t\tif (jas_stream_getc(stream) == EOF) {\n\t\t\treturn n - m;\n\t\t}\n\t}\n\treturn n;\n}\n\nint jas_stream_pad(jas_stream_t *stream, int n, int c)\n{\n\tint m;\n\tm = n;\n\tfor (m = n; m > 0; --m) {\n\t\tif (jas_stream_putc(stream, c) == EOF)\n\t\t\treturn n - m;\n\t}\n\treturn n;\n}\n\n/******************************************************************************\\\n* Code for getting and setting the stream position.\n\\******************************************************************************/\n\nint jas_stream_isseekable(jas_stream_t *stream)\n{\n\tif (stream->ops_ == &jas_stream_memops) {\n\t\treturn 1;\n\t} else if (stream->ops_ == &jas_stream_fileops) {\n\t\tif ((*stream->ops_->seek_)(stream->obj_, 0, SEEK_CUR) < 0) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nint jas_stream_rewind(jas_stream_t *stream)\n{\n\treturn jas_stream_seek(stream, 0, SEEK_SET);\n}\n\nlong jas_stream_seek(jas_stream_t *stream, long offset, int origin)\n{\n\tlong newpos;\n\n\t/* The buffer cannot be in use for both reading and writing. */\n\tassert(!((stream->bufmode_ & JAS_STREAM_RDBUF) && (stream->bufmode_ &\n\t  JAS_STREAM_WRBUF)));\n\n\t/* Reset the EOF indicator (since we may not be at the EOF anymore). */\n\tstream->flags_ &= ~JAS_STREAM_EOF;\n\n\tif (stream->bufmode_ & JAS_STREAM_RDBUF) {\n\t\tif (origin == SEEK_CUR) {\n\t\t\toffset -= stream->cnt_;\n\t\t}\n\t} else if (stream->bufmode_ & JAS_STREAM_WRBUF) {\n\t\tif (jas_stream_flush(stream)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tstream->cnt_ = 0;\n\tstream->ptr_ = stream->bufstart_;\n\tstream->bufmode_ &= ~(JAS_STREAM_RDBUF | JAS_STREAM_WRBUF);\n\n\tif ((newpos = (*stream->ops_->seek_)(stream->obj_, offset, origin))\n\t  < 0) {\n\t\treturn -1;\n\t}\n\n\treturn newpos;\n}\n\nlong jas_stream_tell(jas_stream_t *stream)\n{\n\tint adjust;\n\tint offset;\n\n\tif (stream->bufmode_ & JAS_STREAM_RDBUF) {\n\t\tadjust = -stream->cnt_;\n\t} else if (stream->bufmode_ & JAS_STREAM_WRBUF) {\n\t\tadjust = stream->ptr_ - stream->bufstart_;\n\t} else {\n\t\tadjust = 0;\n\t}\n\n\tif ((offset = (*stream->ops_->seek_)(stream->obj_, 0, SEEK_CUR)) < 0) {\n\t\treturn -1;\n\t}\n\n\treturn offset + adjust;\n}\n\n/******************************************************************************\\\n* Buffer initialization code.\n\\******************************************************************************/\n\nstatic void jas_stream_initbuf(jas_stream_t *stream, int bufmode, char *buf,\n  int bufsize)\n{\n\t/* If this function is being called, the buffer should not have been\n\t  initialized yet. */\n\tassert(!stream->bufbase_);\n\n\tif (bufmode != JAS_STREAM_UNBUF) {\n\t\t/* The full- or line-buffered mode is being employed. */\n\t\tif (!buf) {\n\t\t\t/* The caller has not specified a buffer to employ, so allocate\n\t\t\t  one. */\n\t\t\tif ((stream->bufbase_ = jas_malloc(JAS_STREAM_BUFSIZE +\n\t\t\t  JAS_STREAM_MAXPUTBACK))) {\n\t\t\t\tstream->bufmode_ |= JAS_STREAM_FREEBUF;\n\t\t\t\tstream->bufsize_ = JAS_STREAM_BUFSIZE;\n\t\t\t} else {\n\t\t\t\t/* The buffer allocation has failed.  Resort to unbuffered\n\t\t\t\t  operation. */\n\t\t\t\tstream->bufbase_ = stream->tinybuf_;\n\t\t\t\tstream->bufsize_ = 1;\n\t\t\t}\n\t\t} else {\n\t\t\t/* The caller has specified a buffer to employ. */\n\t\t\t/* The buffer must be large enough to accommodate maximum\n\t\t\t  putback. */\n\t\t\tassert(bufsize > JAS_STREAM_MAXPUTBACK);\n\t\t\tstream->bufbase_ = JAS_CAST(uchar *, buf);\n\t\t\tstream->bufsize_ = bufsize - JAS_STREAM_MAXPUTBACK;\n\t\t}\n\t} else {\n\t\t/* The unbuffered mode is being employed. */\n\t\t/* A buffer should not have been supplied by the caller. */\n\t\tassert(!buf);\n\t\t/* Use a trivial one-character buffer. */\n\t\tstream->bufbase_ = stream->tinybuf_;\n\t\tstream->bufsize_ = 1;\n\t}\n\tstream->bufstart_ = &stream->bufbase_[JAS_STREAM_MAXPUTBACK];\n\tstream->ptr_ = stream->bufstart_;\n\tstream->cnt_ = 0;\n\tstream->bufmode_ |= bufmode & JAS_STREAM_BUFMODEMASK;\n}\n\n/******************************************************************************\\\n* Buffer filling and flushing code.\n\\******************************************************************************/\n\nint jas_stream_flush(jas_stream_t *stream)\n{\n\tif (stream->bufmode_ & JAS_STREAM_RDBUF) {\n\t\treturn 0;\n\t}\n\treturn jas_stream_flushbuf(stream, EOF);\n}\n\nint jas_stream_fillbuf(jas_stream_t *stream, int getflag)\n{\n\tint c;\n\n\t/* The stream must not be in an error or EOF state. */\n\tif ((stream->flags_ & (JAS_STREAM_ERRMASK)) != 0) {\n\t\treturn EOF;\n\t}\n\n\t/* The stream must be open for reading. */\n\tif ((stream->openmode_ & JAS_STREAM_READ) == 0) {\n\t\treturn EOF;\n\t}\n\n\t/* Make a half-hearted attempt to confirm that the buffer is not\n\tcurrently being used for writing.  This check is not intended\n\tto be foolproof! */\n\tassert((stream->bufmode_ & JAS_STREAM_WRBUF) == 0);\n\n\tassert(stream->ptr_ - stream->bufstart_ <= stream->bufsize_);\n\n\t/* Mark the buffer as being used for reading. */\n\tstream->bufmode_ |= JAS_STREAM_RDBUF;\n\n\t/* Read new data into the buffer. */\n\tstream->ptr_ = stream->bufstart_;\n\tif ((stream->cnt_ = (*stream->ops_->read_)(stream->obj_,\n\t  (char *) stream->bufstart_, stream->bufsize_)) <= 0) {\n\t\tif (stream->cnt_ < 0) {\n\t\t\tstream->flags_ |= JAS_STREAM_ERR;\n\t\t} else {\n\t\t\tstream->flags_ |= JAS_STREAM_EOF;\n\t\t}\n\t\tstream->cnt_ = 0;\n\t\treturn EOF;\n\t}\n\n\tassert(stream->cnt_ > 0);\n\t/* Get or peek at the first character in the buffer. */\n\tc = (getflag) ? jas_stream_getc2(stream) : (*stream->ptr_);\n\n\treturn c;\n}\n\nint jas_stream_flushbuf(jas_stream_t *stream, int c)\n{\n\tint len;\n\tint n;\n\n\t/* The stream should not be in an error or EOF state. */\n\tif ((stream->flags_ & (JAS_STREAM_ERRMASK)) != 0) {\n\t\treturn EOF;\n\t}\n\n\t/* The stream must be open for writing. */\n\tif ((stream->openmode_ & (JAS_STREAM_WRITE | JAS_STREAM_APPEND)) == 0) {\n\t\treturn EOF;\n\t}\n\n\t/* The buffer should not currently be in use for reading. */\n\tassert(!(stream->bufmode_ & JAS_STREAM_RDBUF));\n\n\t/* Note: Do not use the quantity stream->cnt to determine the number\n\tof characters in the buffer!  Depending on how this function was\n\tcalled, the stream->cnt value may be \"off-by-one\". */\n\tlen = stream->ptr_ - stream->bufstart_;\n\tif (len > 0) {\n\t\tn = (*stream->ops_->write_)(stream->obj_, (char *)\n\t\t  stream->bufstart_, len);\n\t\tif (n != len) {\n\t\t\tstream->flags_ |= JAS_STREAM_ERR;\n\t\t\treturn EOF;\n\t\t}\n\t}\n\tstream->cnt_ = stream->bufsize_;\n\tstream->ptr_ = stream->bufstart_;\n\n\tstream->bufmode_ |= JAS_STREAM_WRBUF;\n\n\tif (c != EOF) {\n\t\tassert(stream->cnt_ > 0);\n\t\treturn jas_stream_putc2(stream, c);\n\t}\n\n\treturn 0;\n}\n\n/******************************************************************************\\\n* Miscellaneous code.\n\\******************************************************************************/\n\nstatic int jas_strtoopenmode(const char *s)\n{\n\tint openmode = 0;\n\twhile (*s != '\\0') {\n\t\tswitch (*s) {\n\t\tcase 'r':\n\t\t\topenmode |= JAS_STREAM_READ;\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\topenmode |= JAS_STREAM_WRITE | JAS_STREAM_CREATE;\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\topenmode |= JAS_STREAM_BINARY;\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\topenmode |= JAS_STREAM_APPEND;\n\t\t\tbreak;\n\t\tcase '+':\n\t\t\topenmode |= JAS_STREAM_READ | JAS_STREAM_WRITE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\t++s;\n\t}\n\treturn openmode;\n}\n\nint jas_stream_copy(jas_stream_t *out, jas_stream_t *in, int n)\n{\n\tint all;\n\tint c;\n\tint m;\n\n\tall = (n < 0) ? 1 : 0;\n\n\tm = n;\n\twhile (all || m > 0) {\n\t\tif ((c = jas_stream_getc_macro(in)) == EOF) {\n\t\t\t/* The next character of input could not be read. */\n\t\t\t/* Return with an error if an I/O error occured\n\t\t\t  (not including EOF) or if an explicit copy count\n\t\t\t  was specified. */\n\t\t\treturn (!all || jas_stream_error(in)) ? (-1) : 0;\n\t\t}\n\t\tif (jas_stream_putc_macro(out, c) == EOF) {\n\t\t\treturn -1;\n\t\t}\n\t\t--m;\n\t}\n\treturn 0;\n}\n\nlong jas_stream_setrwcount(jas_stream_t *stream, long rwcnt)\n{\n\tint old;\n\n\told = stream->rwcnt_;\n\tstream->rwcnt_ = rwcnt;\n\treturn old;\n}\n\nint jas_stream_display(jas_stream_t *stream, FILE *fp, int n)\n{\n\tunsigned char buf[16];\n\tint i;\n\tint j;\n\tint m;\n\tint c;\n\tint display;\n\tint cnt;\n\n\tcnt = n - (n % 16);\n\tdisplay = 1;\n\n\tfor (i = 0; i < n; i += 16) {\n\t\tif (n > 16 && i > 0) {\n\t\t\tdisplay = (i >= cnt) ? 1 : 0;\n\t\t}\n\t\tif (display) {\n\t\t\tfprintf(fp, \"%08x:\", i);\n\t\t}\n\t\tm = JAS_MIN(n - i, 16);\n\t\tfor (j = 0; j < m; ++j) {\n\t\t\tif ((c = jas_stream_getc(stream)) == EOF) {\n\t\t\t\tabort();\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tbuf[j] = c;\n\t\t}\n\t\tif (display) {\n\t\t\tfor (j = 0; j < m; ++j) {\n\t\t\t\tfprintf(fp, \" %02x\", buf[j]);\n\t\t\t}\n\t\t\tfputc(' ', fp);\n\t\t\tfor (; j < 16; ++j) {\n\t\t\t\tfprintf(fp, \"   \");\n\t\t\t}\n\t\t\tfor (j = 0; j < m; ++j) {\n\t\t\t\tif (isprint(buf[j])) {\n\t\t\t\t\tfputc(buf[j], fp);\n\t\t\t\t} else {\n\t\t\t\t\tfputc(' ', fp);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfprintf(fp, \"\\n\");\n\t\t}\n\n\n\t}\n\treturn 0;\n}\n\nlong jas_stream_length(jas_stream_t *stream)\n{\n\tlong oldpos;\n\tlong pos;\n\tif ((oldpos = jas_stream_tell(stream)) < 0) {\n\t\treturn -1;\n\t}\n\tif (jas_stream_seek(stream, 0, SEEK_END) < 0) {\n\t\treturn -1;\n\t}\n\tif ((pos = jas_stream_tell(stream)) < 0) {\n\t\treturn -1;\n\t}\n\tif (jas_stream_seek(stream, oldpos, SEEK_SET) < 0) {\n\t\treturn -1;\n\t}\n\treturn pos;\n}\n\n/******************************************************************************\\\n* Memory stream object.\n\\******************************************************************************/\n\nstatic int mem_read(jas_stream_obj_t *obj, char *buf, int cnt)\n{\n\tint n;\n\tassert(cnt >= 0);\n\tassert(buf);\n\n\tJAS_DBGLOG(100, (\"mem_read(%p, %p, %d)\\n\", obj, buf, cnt));\n\tjas_stream_memobj_t *m = (jas_stream_memobj_t *)obj;\n\tn = m->len_ - m->pos_;\n\tcnt = JAS_MIN(n, cnt);\n\tmemcpy(buf, &m->buf_[m->pos_], cnt);\n\tm->pos_ += cnt;\n\treturn cnt;\n}\n\nstatic int mem_resize(jas_stream_memobj_t *m, int bufsize)\n{\n\tunsigned char *buf;\n\n\t//assert(m->buf_);\n\tassert(bufsize >= 0);\n\n\tJAS_DBGLOG(100, (\"mem_resize(%p, %d)\\n\", m, bufsize));\n\tif (!(buf = jas_realloc2(m->buf_, bufsize, sizeof(unsigned char))) &&\n\t  bufsize) {\n\t\tJAS_DBGLOG(100, (\"mem_resize realloc failed\\n\"));\n\t\treturn -1;\n\t}\n\tJAS_DBGLOG(100, (\"mem_resize realloc succeeded\\n\"));\n\tm->buf_ = buf;\n\tm->bufsize_ = bufsize;\n\treturn 0;\n}\n\nstatic int mem_write(jas_stream_obj_t *obj, char *buf, int cnt)\n{\n\tint n;\n\tint ret;\n\tjas_stream_memobj_t *m = (jas_stream_memobj_t *)obj;\n\tlong newbufsize;\n\tlong newpos;\n\n\tassert(buf);\n\tassert(cnt >= 0);\n\n\tJAS_DBGLOG(100, (\"mem_write(%p, %p, %d)\\n\", obj, buf, cnt));\n\tnewpos = m->pos_ + cnt;\n\tif (newpos > m->bufsize_ && m->growable_) {\n\t\tnewbufsize = m->bufsize_;\n\t\twhile (newbufsize < newpos) {\n\t\t\tnewbufsize <<= 1;\n\t\t\tassert(newbufsize >= 0);\n\t\t}\n\t\tJAS_DBGLOG(100, (\"mem_write resizing from %d to %z\\n\", m->bufsize_,\n\t\t  newbufsize));\n\t\tJAS_DBGLOG(100, (\"mem_write resizing from %d to %ul\\n\", m->bufsize_,\n\t\t  JAS_CAST(unsigned long, newbufsize)));\n\t\tif (mem_resize(m, newbufsize)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (m->pos_ > m->len_) {\n\t\t/* The current position is beyond the end of the file, so\n\t\t  pad the file to the current position with zeros. */\n\t\tn = JAS_MIN(m->pos_, m->bufsize_) - m->len_;\n\t\tif (n > 0) {\n\t\t\tmemset(&m->buf_[m->len_], 0, n);\n\t\t\tm->len_ += n;\n\t\t}\n\t\tif (m->pos_ != m->len_) {\n\t\t\t/* The buffer is not big enough. */\n\t\t\treturn 0;\n\t\t}\n\t}\n\tn = m->bufsize_ - m->pos_;\n\tret = JAS_MIN(n, cnt);\n\tif (ret > 0) {\n\t\tmemcpy(&m->buf_[m->pos_], buf, ret);\n\t\tm->pos_ += ret;\n\t}\n\tif (m->pos_ > m->len_) {\n\t\tm->len_ = m->pos_;\n\t}\n\tassert(ret == cnt);\n\treturn ret;\n}\n\nstatic long mem_seek(jas_stream_obj_t *obj, long offset, int origin)\n{\n\tjas_stream_memobj_t *m = (jas_stream_memobj_t *)obj;\n\tlong newpos;\n\n\tJAS_DBGLOG(100, (\"mem_seek(%p, %ld, %d)\\n\", obj, offset, origin));\n\tswitch (origin) {\n\tcase SEEK_SET:\n\t\tnewpos = offset;\n\t\tbreak;\n\tcase SEEK_END:\n\t\tnewpos = m->len_ - offset;\n\t\tbreak;\n\tcase SEEK_CUR:\n\t\tnewpos = m->pos_ + offset;\n\t\tbreak;\n\tdefault:\n\t\tabort();\n\t\tbreak;\n\t}\n\tif (newpos < 0) {\n\t\treturn -1;\n\t}\n\tm->pos_ = newpos;\n\n\treturn m->pos_;\n}\n\nstatic int mem_close(jas_stream_obj_t *obj)\n{\n\tJAS_DBGLOG(100, (\"mem_close(%p)\\n\", obj));\n\tjas_stream_memobj_t *m = (jas_stream_memobj_t *)obj;\n\tJAS_DBGLOG(100, (\"mem_close myalloc=%d\\n\", m->myalloc_));\n\tif (m->myalloc_ && m->buf_) {\n\t\tJAS_DBGLOG(100, (\"mem_close freeing buffer %p\\n\", m->buf_));\n\t\tjas_free(m->buf_);\n\t\tm->buf_ = 0;\n\t}\n\tjas_free(obj);\n\treturn 0;\n}\n\n/******************************************************************************\\\n* File stream object.\n\\******************************************************************************/\n\nstatic int file_read(jas_stream_obj_t *obj, char *buf, int cnt)\n{\n\tjas_stream_fileobj_t *fileobj;\n\tJAS_DBGLOG(100, (\"file_read(%p, %p, %d)\\n\", obj, buf, cnt));\n\tfileobj = JAS_CAST(jas_stream_fileobj_t *, obj);\n\treturn read(fileobj->fd, buf, cnt);\n}\n\nstatic int file_write(jas_stream_obj_t *obj, char *buf, int cnt)\n{\n\tjas_stream_fileobj_t *fileobj;\n\tJAS_DBGLOG(100, (\"file_write(%p, %p, %d)\\n\", obj, buf, cnt));\n\tfileobj = JAS_CAST(jas_stream_fileobj_t *, obj);\n\treturn write(fileobj->fd, buf, cnt);\n}\n\nstatic long file_seek(jas_stream_obj_t *obj, long offset, int origin)\n{\n\tjas_stream_fileobj_t *fileobj;\n\tJAS_DBGLOG(100, (\"file_seek(%p, %ld, %d)\\n\", obj, offset, origin));\n\tfileobj = JAS_CAST(jas_stream_fileobj_t *, obj);\n\treturn lseek(fileobj->fd, offset, origin);\n}\n\nstatic int file_close(jas_stream_obj_t *obj)\n{\n\tjas_stream_fileobj_t *fileobj;\n\tJAS_DBGLOG(100, (\"file_close(%p)\\n\", obj));\n\tfileobj = JAS_CAST(jas_stream_fileobj_t *, obj);\n\tint ret;\n\tret = close(fileobj->fd);\n\tif (fileobj->flags & JAS_STREAM_FILEOBJ_DELONCLOSE) {\n\t\tunlink(fileobj->pathname);\n\t}\n\tjas_free(fileobj);\n\treturn ret;\n}\n\n/******************************************************************************\\\n* Stdio file stream object.\n\\******************************************************************************/\n\nstatic int sfile_read(jas_stream_obj_t *obj, char *buf, int cnt)\n{\n\tFILE *fp;\n\tsize_t n;\n\tint result;\n\tJAS_DBGLOG(100, (\"sfile_read(%p, %p, %d)\\n\", obj, buf, cnt));\n\tfp = JAS_CAST(FILE *, obj);\n\tn = fread(buf, 1, cnt, fp);\n\tif (n != cnt) {\n\t\tresult = (!ferror(fp) && feof(fp)) ? 0 : -1;\n\t}\n\tresult = JAS_CAST(int, n);\n\treturn result;\n}\n\nstatic int sfile_write(jas_stream_obj_t *obj, char *buf, int cnt)\n{\n\tFILE *fp;\n\tsize_t n;\n\tJAS_DBGLOG(100, (\"sfile_write(%p, %p, %d)\\n\", obj, buf, cnt));\n\tfp = JAS_CAST(FILE *, obj);\n\tn = fwrite(buf, 1, cnt, fp);\n\treturn (n != JAS_CAST(size_t, cnt)) ? (-1) : cnt;\n}\n\nstatic long sfile_seek(jas_stream_obj_t *obj, long offset, int origin)\n{\n\tFILE *fp;\n\tJAS_DBGLOG(100, (\"sfile_seek(%p, %ld, %d)\\n\", obj, offset, origin));\n\tfp = JAS_CAST(FILE *, obj);\n\treturn fseek(fp, offset, origin);\n}\n\nstatic int sfile_close(jas_stream_obj_t *obj)\n{\n\tFILE *fp;\n\tJAS_DBGLOG(100, (\"sfile_close(%p)\\n\", obj));\n\tfp = JAS_CAST(FILE *, obj);\n\treturn fclose(fp);\n}\n", "/*\n * Copyright (c) 2001-2002 Michael David Adams.\n * All rights reserved.\n */\n\n/* __START_OF_JASPER_LICENSE__\n * \n * JasPer License Version 2.0\n * \n * Copyright (c) 2001-2006 Michael David Adams\n * Copyright (c) 1999-2000 Image Power, Inc.\n * Copyright (c) 1999-2000 The University of British Columbia\n * \n * All rights reserved.\n * \n * Permission is hereby granted, free of charge, to any person (the\n * \"User\") obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n * \n * 1.  The above copyright notices and this permission notice (which\n * includes the disclaimer below) shall be included in all copies or\n * substantial portions of the Software.\n * \n * 2.  The name of a copyright holder shall not be used to endorse or\n * promote products derived from the Software without specific prior\n * written permission.\n * \n * THIS DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS\n * LICENSE.  NO USE OF THE SOFTWARE IS AUTHORIZED HEREUNDER EXCEPT UNDER\n * THIS DISCLAIMER.  THE SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS\n * \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.  IN NO\n * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL\n * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING\n * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\n * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION\n * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  NO ASSURANCES ARE\n * PROVIDED BY THE COPYRIGHT HOLDERS THAT THE SOFTWARE DOES NOT INFRINGE\n * THE PATENT OR OTHER INTELLECTUAL PROPERTY RIGHTS OF ANY OTHER ENTITY.\n * EACH COPYRIGHT HOLDER DISCLAIMS ANY LIABILITY TO THE USER FOR CLAIMS\n * BROUGHT BY ANY OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL\n * PROPERTY RIGHTS OR OTHERWISE.  AS A CONDITION TO EXERCISING THE RIGHTS\n * GRANTED HEREUNDER, EACH USER HEREBY ASSUMES SOLE RESPONSIBILITY TO SECURE\n * ANY OTHER INTELLECTUAL PROPERTY RIGHTS NEEDED, IF ANY.  THE SOFTWARE\n * IS NOT FAULT-TOLERANT AND IS NOT INTENDED FOR USE IN MISSION-CRITICAL\n * SYSTEMS, SUCH AS THOSE USED IN THE OPERATION OF NUCLEAR FACILITIES,\n * AIRCRAFT NAVIGATION OR COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL\n * SYSTEMS, DIRECT LIFE SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH\n * THE FAILURE OF THE SOFTWARE OR SYSTEM COULD LEAD DIRECTLY TO DEATH,\n * PERSONAL INJURY, OR SEVERE PHYSICAL OR ENVIRONMENTAL DAMAGE (\"HIGH\n * RISK ACTIVITIES\").  THE COPYRIGHT HOLDERS SPECIFICALLY DISCLAIM ANY\n * EXPRESS OR IMPLIED WARRANTY OF FITNESS FOR HIGH RISK ACTIVITIES.\n * \n * __END_OF_JASPER_LICENSE__\n */\n\n/*\n * Debugging-Related Code\n *\n * $Id$\n */\n\n#ifndef JAS_DEBUG_H\n#define JAS_DEBUG_H\n\n/******************************************************************************\\\n* Includes.\n\\******************************************************************************/\n\n#include <stdio.h>\n\n#include <jasper/jas_config.h>\n#include <jasper/jas_types.h>\n#include <jasper/jas_debug.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/******************************************************************************\\\n* Macros and functions.\n\\******************************************************************************/\n\n/* Output debugging information to standard error provided that the debug\n  level is set sufficiently high. */\n#if !defined(NDEBUG)\n#define\tJAS_DBGLOG(n, x) \\\n\t((jas_getdbglevel() >= (n)) ? (jas_eprintf x) : 0)\n#else\n#define\tJAS_DBGLOG(n, x)\n#endif\n\n/* Get the library debug level. */\nint jas_getdbglevel(void);\n\n/* Set the library debug level. */\nint jas_setdbglevel(int dbglevel);\n\n/* Perform formatted output to standard error. */\nint jas_eprintf(const char *fmt, ...);\n\n/* Dump memory to a stream. */\nint jas_memdump(FILE *out, void *data, size_t len);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n", "/*\n * Copyright (c) 1999-2000 Image Power, Inc. and the University of\n *   British Columbia.\n * Copyright (c) 2001-2003 Michael David Adams.\n * All rights reserved.\n */\n\n/* __START_OF_JASPER_LICENSE__\n * \n * JasPer License Version 2.0\n * \n * Copyright (c) 2001-2006 Michael David Adams\n * Copyright (c) 1999-2000 Image Power, Inc.\n * Copyright (c) 1999-2000 The University of British Columbia\n * \n * All rights reserved.\n * \n * Permission is hereby granted, free of charge, to any person (the\n * \"User\") obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n * \n * 1.  The above copyright notices and this permission notice (which\n * includes the disclaimer below) shall be included in all copies or\n * substantial portions of the Software.\n * \n * 2.  The name of a copyright holder shall not be used to endorse or\n * promote products derived from the Software without specific prior\n * written permission.\n * \n * THIS DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS\n * LICENSE.  NO USE OF THE SOFTWARE IS AUTHORIZED HEREUNDER EXCEPT UNDER\n * THIS DISCLAIMER.  THE SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS\n * \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.  IN NO\n * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL\n * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING\n * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\n * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION\n * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  NO ASSURANCES ARE\n * PROVIDED BY THE COPYRIGHT HOLDERS THAT THE SOFTWARE DOES NOT INFRINGE\n * THE PATENT OR OTHER INTELLECTUAL PROPERTY RIGHTS OF ANY OTHER ENTITY.\n * EACH COPYRIGHT HOLDER DISCLAIMS ANY LIABILITY TO THE USER FOR CLAIMS\n * BROUGHT BY ANY OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL\n * PROPERTY RIGHTS OR OTHERWISE.  AS A CONDITION TO EXERCISING THE RIGHTS\n * GRANTED HEREUNDER, EACH USER HEREBY ASSUMES SOLE RESPONSIBILITY TO SECURE\n * ANY OTHER INTELLECTUAL PROPERTY RIGHTS NEEDED, IF ANY.  THE SOFTWARE\n * IS NOT FAULT-TOLERANT AND IS NOT INTENDED FOR USE IN MISSION-CRITICAL\n * SYSTEMS, SUCH AS THOSE USED IN THE OPERATION OF NUCLEAR FACILITIES,\n * AIRCRAFT NAVIGATION OR COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL\n * SYSTEMS, DIRECT LIFE SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH\n * THE FAILURE OF THE SOFTWARE OR SYSTEM COULD LEAD DIRECTLY TO DEATH,\n * PERSONAL INJURY, OR SEVERE PHYSICAL OR ENVIRONMENTAL DAMAGE (\"HIGH\n * RISK ACTIVITIES\").  THE COPYRIGHT HOLDERS SPECIFICALLY DISCLAIM ANY\n * EXPRESS OR IMPLIED WARRANTY OF FITNESS FOR HIGH RISK ACTIVITIES.\n * \n * __END_OF_JASPER_LICENSE__\n */\n\n/*\n * I/O Stream Class\n *\n * $Id$\n */\n\n#ifndef JAS_STREAM_H\n#define JAS_STREAM_H\n\n/******************************************************************************\\\n* Includes.\n\\******************************************************************************/\n\n#include <jasper/jas_config.h>\n\n#include <stdio.h>\n#if defined(HAVE_FCNTL_H)\n#include <fcntl.h>\n#endif\n#include <string.h>\n#if defined(HAVE_UNISTD_H)\n#include <unistd.h>\n#endif\n#include <jasper/jas_types.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/******************************************************************************\\\n* Constants.\n\\******************************************************************************/\n\n/* On most UNIX systems, we probably need to define O_BINARY ourselves. */\n#ifndef O_BINARY\n#define O_BINARY\t0\n#endif\n\n/*\n * Stream open flags.\n */\n\n/* The stream was opened for reading. */\n#define JAS_STREAM_READ\t0x0001\n/* The stream was opened for writing. */\n#define JAS_STREAM_WRITE\t0x0002\n/* The stream was opened for appending. */\n#define JAS_STREAM_APPEND\t0x0004\n/* The stream was opened in binary mode. */\n#define JAS_STREAM_BINARY\t0x0008\n/* The stream should be created/truncated. */\n#define JAS_STREAM_CREATE\t0x0010\n\n\n/*\n * Stream buffering flags.\n */\n\n/* The stream is unbuffered. */\n#define JAS_STREAM_UNBUF\t0x0000\n/* The stream is line buffered. */\n#define JAS_STREAM_LINEBUF\t0x0001\n/* The stream is fully buffered. */\n#define JAS_STREAM_FULLBUF\t0x0002\n/* The buffering mode mask. */\n#define\tJAS_STREAM_BUFMODEMASK\t0x000f\n\n/* The memory associated with the buffer needs to be deallocated when the\n  stream is destroyed. */\n#define JAS_STREAM_FREEBUF\t0x0008\n/* The buffer is currently being used for reading. */\n#define JAS_STREAM_RDBUF\t0x0010\n/* The buffer is currently being used for writing. */\n#define JAS_STREAM_WRBUF\t0x0020\n\n/*\n * Stream error flags.\n */\n\n/* The end-of-file has been encountered (on reading). */\n#define JAS_STREAM_EOF\t0x0001\n/* An I/O error has been encountered on the stream. */\n#define JAS_STREAM_ERR\t0x0002\n/* The read/write limit has been exceeded. */\n#define\tJAS_STREAM_RWLIMIT\t0x0004\n/* The error mask. */\n#define JAS_STREAM_ERRMASK \\\n\t(JAS_STREAM_EOF | JAS_STREAM_ERR | JAS_STREAM_RWLIMIT)\n\n/*\n * Other miscellaneous constants.\n */\n\n/* The default buffer size (for fully-buffered operation). */\n#define JAS_STREAM_BUFSIZE\t8192\n/* The default permission mask for file creation. */\n#define JAS_STREAM_PERMS\t0666\n\n/* The maximum number of characters that can always be put back on a stream. */\n#define\tJAS_STREAM_MAXPUTBACK\t16\n\n/******************************************************************************\\\n* Types.\n\\******************************************************************************/\n\n/*\n * Generic file object.\n */\n\ntypedef void jas_stream_obj_t;\n\n/*\n * Generic file object operations.\n */\n\ntypedef struct {\n\n\t/* Read characters from a file object. */\n\tint (*read_)(jas_stream_obj_t *obj, char *buf, int cnt);\n\n\t/* Write characters to a file object. */\n\tint (*write_)(jas_stream_obj_t *obj, char *buf, int cnt);\n\n\t/* Set the position for a file object. */\n\tlong (*seek_)(jas_stream_obj_t *obj, long offset, int origin);\n\n\t/* Close a file object. */\n\tint (*close_)(jas_stream_obj_t *obj);\n\n} jas_stream_ops_t;\n\n/*\n * Stream object.\n */\n\ntypedef struct {\n\n\t/* The mode in which the stream was opened. */\n\tint openmode_;\n\n\t/* The buffering mode. */\n\tint bufmode_;\n\n\t/* The stream status. */\n\tint flags_;\n\n\t/* The start of the buffer area to use for reading/writing. */\n\tuchar *bufbase_;\n\n\t/* The start of the buffer area excluding the extra initial space for\n\t  character putback. */\n\tuchar *bufstart_;\n\n\t/* The buffer size. */\n\tint bufsize_;\n\n\t/* The current position in the buffer. */\n\tuchar *ptr_;\n\n\t/* The number of characters that must be read/written before\n\tthe buffer needs to be filled/flushed. */\n\tint cnt_;\n\n\t/* A trivial buffer to be used for unbuffered operation. */\n\tuchar tinybuf_[JAS_STREAM_MAXPUTBACK + 1];\n\n\t/* The operations for the underlying stream file object. */\n\tjas_stream_ops_t *ops_;\n\n\t/* The underlying stream file object. */\n\tjas_stream_obj_t *obj_;\n\n\t/* The number of characters read/written. */\n\tlong rwcnt_;\n\n\t/* The maximum number of characters that may be read/written. */\n\tlong rwlimit_;\n\n} jas_stream_t;\n\n/*\n * Regular file object.\n */\n\n/*\n * File descriptor file object.\n */\ntypedef struct {\n\tint fd;\n\tint flags;\n\tchar pathname[L_tmpnam + 1];\n} jas_stream_fileobj_t;\n\n#define\tJAS_STREAM_FILEOBJ_DELONCLOSE\t0x01\n#define JAS_STREAM_FILEOBJ_NOCLOSE\t0x02\n\n/*\n * Memory file object.\n */\n\ntypedef struct {\n\n\t/* The data associated with this file. */\n\tuchar *buf_;\n\n\t/* The allocated size of the buffer for holding file data. */\n\tint bufsize_;\n\n\t/* The length of the file. */\n\tint_fast32_t len_;\n\n\t/* The seek position. */\n\tint_fast32_t pos_;\n\n\t/* Is the buffer growable? */\n\tint growable_;\n\n\t/* Was the buffer allocated internally? */\n\tint myalloc_;\n\n} jas_stream_memobj_t;\n\n/******************************************************************************\\\n* Macros/functions for opening and closing streams.\n\\******************************************************************************/\n\n/* Open a file as a stream. */\njas_stream_t *jas_stream_fopen(const char *filename, const char *mode);\n\n/* Open a memory buffer as a stream. */\njas_stream_t *jas_stream_memopen(char *buf, int bufsize);\n\n/* Open a file descriptor as a stream. */\njas_stream_t *jas_stream_fdopen(int fd, const char *mode);\n\n/* Open a stdio stream as a stream. */\njas_stream_t *jas_stream_freopen(const char *path, const char *mode, FILE *fp);\n\n/* Open a temporary file as a stream. */\njas_stream_t *jas_stream_tmpfile(void);\n\n/* Close a stream. */\nint jas_stream_close(jas_stream_t *stream);\n\n/******************************************************************************\\\n* Macros/functions for getting/setting the stream state.\n\\******************************************************************************/\n\n/* Get the EOF indicator for a stream. */\n#define jas_stream_eof(stream) \\\n\t(((stream)->flags_ & JAS_STREAM_EOF) != 0)\n\n/* Get the error indicator for a stream. */\n#define jas_stream_error(stream) \\\n\t(((stream)->flags_ & JAS_STREAM_ERR) != 0)\n\n/* Clear the error indicator for a stream. */\n#define jas_stream_clearerr(stream) \\\n\t((stream)->flags_ &= ~(JAS_STREAM_ERR | JAS_STREAM_EOF))\n\n/* Get the read/write limit for a stream. */\n#define\tjas_stream_getrwlimit(stream) \\\n\t(((const jas_stream_t *)(stream))->rwlimit_)\n\n/* Set the read/write limit for a stream. */\nint jas_stream_setrwlimit(jas_stream_t *stream, long rwlimit);\n\n/* Get the read/write count for a stream. */\n#define\tjas_stream_getrwcount(stream) \\\n\t(((const jas_stream_t *)(stream))->rwcnt_)\n\n/* Set the read/write count for a stream. */\nlong jas_stream_setrwcount(jas_stream_t *stream, long rwcnt);\n\n/******************************************************************************\\\n* Macros/functions for I/O.\n\\******************************************************************************/\n\n/* Read a character from a stream. */\n#if defined(DEBUG)\n#define\tjas_stream_getc(stream)\tjas_stream_getc_func(stream)\n#else\n#define jas_stream_getc(stream)\tjas_stream_getc_macro(stream)\n#endif\n\n/* Write a character to a stream. */\n#if defined(DEBUG)\n#define jas_stream_putc(stream, c)\tjas_stream_putc_func(stream, c)\n#else\n#define jas_stream_putc(stream, c)\tjas_stream_putc_macro(stream, c)\n#endif\n\n/* Read characters from a stream into a buffer. */\nint jas_stream_read(jas_stream_t *stream, void *buf, int cnt);\n\n/* Write characters from a buffer to a stream. */\nint jas_stream_write(jas_stream_t *stream, const void *buf, int cnt);\n\n/* Write formatted output to a stream. */\nint jas_stream_printf(jas_stream_t *stream, const char *fmt, ...);\n\n/* Write a string to a stream. */\nint jas_stream_puts(jas_stream_t *stream, const char *s);\n\n/* Read a line of input from a stream. */\nchar *jas_stream_gets(jas_stream_t *stream, char *buf, int bufsize);\n\n/* Look at the next character to be read from a stream without actually\n  removing it from the stream. */\n#define\tjas_stream_peekc(stream) \\\n\t(((stream)->cnt_ <= 0) ? jas_stream_fillbuf(stream, 0) : \\\n\t  ((int)(*(stream)->ptr_)))\n\n/* Put a character back on a stream. */\nint jas_stream_ungetc(jas_stream_t *stream, int c);\n\n/******************************************************************************\\\n* Macros/functions for getting/setting the stream position.\n\\******************************************************************************/\n\n/* Is it possible to seek on this stream? */\nint jas_stream_isseekable(jas_stream_t *stream);\n\n/* Set the current position within the stream. */\nlong jas_stream_seek(jas_stream_t *stream, long offset, int origin);\n\n/* Get the current position within the stream. */\nlong jas_stream_tell(jas_stream_t *stream);\n\n/* Seek to the beginning of a stream. */\nint jas_stream_rewind(jas_stream_t *stream);\n\n/******************************************************************************\\\n* Macros/functions for flushing.\n\\******************************************************************************/\n\n/* Flush any pending output to a stream. */\nint jas_stream_flush(jas_stream_t *stream);\n\n/******************************************************************************\\\n* Miscellaneous macros/functions.\n\\******************************************************************************/\n\n/* Copy data from one stream to another. */\nint jas_stream_copy(jas_stream_t *dst, jas_stream_t *src, int n);\n\n/* Display stream contents (for debugging purposes). */\nint jas_stream_display(jas_stream_t *stream, FILE *fp, int n);\n\n/* Consume (i.e., discard) characters from stream. */\nint jas_stream_gobble(jas_stream_t *stream, int n);\n\n/* Write a character multiple times to a stream. */\nint jas_stream_pad(jas_stream_t *stream, int n, int c);\n\n/* Get the size of the file associated with the specified stream.\n  The specified stream must be seekable. */\nlong jas_stream_length(jas_stream_t *stream);\n\n/******************************************************************************\\\n* Internal functions.\n\\******************************************************************************/\n\n/* The following functions are for internal use only!  If you call them\ndirectly, you will die a horrible, miserable, and painful death! */\n\n/* Read a character from a stream. */\n#define jas_stream_getc_macro(stream) \\\n\t((!((stream)->flags_ & (JAS_STREAM_ERR | JAS_STREAM_EOF | \\\n\t  JAS_STREAM_RWLIMIT))) ? \\\n\t  (((stream)->rwlimit_ >= 0 && (stream)->rwcnt_ >= (stream)->rwlimit_) ? \\\n\t  (stream->flags_ |= JAS_STREAM_RWLIMIT, EOF) : \\\n\t  jas_stream_getc2(stream)) : EOF)\n#define jas_stream_getc2(stream) \\\n\t((--(stream)->cnt_ < 0) ? jas_stream_fillbuf(stream, 1) : \\\n\t  (++(stream)->rwcnt_, (int)(*(stream)->ptr_++)))\n\n/* Write a character to a stream. */\n#define jas_stream_putc_macro(stream, c) \\\n\t((!((stream)->flags_ & (JAS_STREAM_ERR | JAS_STREAM_EOF | \\\n\t  JAS_STREAM_RWLIMIT))) ? \\\n\t  (((stream)->rwlimit_ >= 0 && (stream)->rwcnt_ >= (stream)->rwlimit_) ? \\\n\t  (stream->flags_ |= JAS_STREAM_RWLIMIT, EOF) : \\\n\t  jas_stream_putc2(stream, c)) : EOF)\n#define jas_stream_putc2(stream, c) \\\n\t(((stream)->bufmode_ |= JAS_STREAM_WRBUF, --(stream)->cnt_ < 0) ? \\\n\t  jas_stream_flushbuf((stream), (uchar)(c)) : \\\n\t  (++(stream)->rwcnt_, (int)(*(stream)->ptr_++ = (c))))\n\n/* These prototypes need to be here for the sake of the stream_getc and\nstream_putc macros. */\nint jas_stream_fillbuf(jas_stream_t *stream, int getflag);\nint jas_stream_flushbuf(jas_stream_t *stream, int c);\nint jas_stream_getc_func(jas_stream_t *stream);\nint jas_stream_putc_func(jas_stream_t *stream, int c);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"], "fixing_code": ["/*\n * Copyright (c) 2001-2002 Michael David Adams.\n * All rights reserved.\n */\n\n/* __START_OF_JASPER_LICENSE__\n * \n * JasPer License Version 2.0\n * \n * Copyright (c) 2001-2006 Michael David Adams\n * Copyright (c) 1999-2000 Image Power, Inc.\n * Copyright (c) 1999-2000 The University of British Columbia\n * \n * All rights reserved.\n * \n * Permission is hereby granted, free of charge, to any person (the\n * \"User\") obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n * \n * 1.  The above copyright notices and this permission notice (which\n * includes the disclaimer below) shall be included in all copies or\n * substantial portions of the Software.\n * \n * 2.  The name of a copyright holder shall not be used to endorse or\n * promote products derived from the Software without specific prior\n * written permission.\n * \n * THIS DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS\n * LICENSE.  NO USE OF THE SOFTWARE IS AUTHORIZED HEREUNDER EXCEPT UNDER\n * THIS DISCLAIMER.  THE SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS\n * \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.  IN NO\n * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL\n * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING\n * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\n * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION\n * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  NO ASSURANCES ARE\n * PROVIDED BY THE COPYRIGHT HOLDERS THAT THE SOFTWARE DOES NOT INFRINGE\n * THE PATENT OR OTHER INTELLECTUAL PROPERTY RIGHTS OF ANY OTHER ENTITY.\n * EACH COPYRIGHT HOLDER DISCLAIMS ANY LIABILITY TO THE USER FOR CLAIMS\n * BROUGHT BY ANY OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL\n * PROPERTY RIGHTS OR OTHERWISE.  AS A CONDITION TO EXERCISING THE RIGHTS\n * GRANTED HEREUNDER, EACH USER HEREBY ASSUMES SOLE RESPONSIBILITY TO SECURE\n * ANY OTHER INTELLECTUAL PROPERTY RIGHTS NEEDED, IF ANY.  THE SOFTWARE\n * IS NOT FAULT-TOLERANT AND IS NOT INTENDED FOR USE IN MISSION-CRITICAL\n * SYSTEMS, SUCH AS THOSE USED IN THE OPERATION OF NUCLEAR FACILITIES,\n * AIRCRAFT NAVIGATION OR COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL\n * SYSTEMS, DIRECT LIFE SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH\n * THE FAILURE OF THE SOFTWARE OR SYSTEM COULD LEAD DIRECTLY TO DEATH,\n * PERSONAL INJURY, OR SEVERE PHYSICAL OR ENVIRONMENTAL DAMAGE (\"HIGH\n * RISK ACTIVITIES\").  THE COPYRIGHT HOLDERS SPECIFICALLY DISCLAIM ANY\n * EXPRESS OR IMPLIED WARRANTY OF FITNESS FOR HIGH RISK ACTIVITIES.\n * \n * __END_OF_JASPER_LICENSE__\n */\n\n/******************************************************************************\\\n* Includes.\n\\******************************************************************************/\n\n#include <stdarg.h>\n#include <stdio.h>\n\n#include \"jasper/jas_types.h\"\n#include \"jasper/jas_debug.h\"\n\n/******************************************************************************\\\n* Local data.\n\\******************************************************************************/\n\nstatic int jas_dbglevel = 0;\n/* The debug level. */\n\n/******************************************************************************\\\n* Code for getting/setting the debug level.\n\\******************************************************************************/\n\n/* Set the library debug level. */\nint jas_setdbglevel(int dbglevel)\n{\n\tint olddbglevel;\n\n\t/* Save the old debug level. */\n\tolddbglevel = jas_dbglevel;\n\n\t/* Change the debug level. */\n\tjas_dbglevel = dbglevel;\n\n\t/* Return the old debug level. */\n\treturn olddbglevel;\n}\n\n/* Get the library debug level. */\nint jas_getdbglevel()\n{\n\treturn jas_dbglevel;\n}\n\n/******************************************************************************\\\n* Code.\n\\******************************************************************************/\n\n/* Perform formatted output to standard error. */\nint jas_eprintf(const char *fmt, ...)\n{\n\tint ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vfprintf(stderr, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}\n\n/* Dump memory to a stream. */\nint jas_memdump(FILE *out, void *data, size_t len)\n{\n\tsize_t i;\n\tsize_t j;\n\tuchar *dp;\n\tdp = data;\n\tfor (i = 0; i < len; i += 16) {\n\t\tfprintf(out, \"%04zx:\", i);\n\t\tfor (j = 0; j < 16; ++j) {\n\t\t\tif (i + j < len) {\n\t\t\t\tfprintf(out, \" %02x\", dp[i + j]);\n\t\t\t}\n\t\t}\n\t\tfprintf(out, \"\\n\");\n\t}\n\treturn 0;\n}\n\n/******************************************************************************\\\n* Code.\n\\******************************************************************************/\n\nvoid jas_deprecated(const char *s)\n{\n\tstatic char message[] =\n\t\"WARNING!!! WARNING!!! WARNING!!! WARNING!!! WARNING!!! WARNING!!!\\n\"\n\t\"WARNING!!! WARNING!!! WARNING!!! WARNING!!! WARNING!!! WARNING!!!\\n\"\n\t\"WARNING!!! WARNING!!! WARNING!!! WARNING!!! WARNING!!! WARNING!!!\\n\"\n\t\"YOUR CODE IS RELYING ON DEPRECATED FUNCTIONALTIY IN THE JASPER LIBRARY.\\n\"\n\t\"THIS FUNCTIONALITY WILL BE REMOVED IN THE NEAR FUTURE.\\n\"\n\t\"PLEASE FIX THIS PROBLEM BEFORE YOUR CODE STOPS WORKING!\\n\"\n\t;\n\tjas_eprintf(\"%s\", message);\n\tjas_eprintf(\"The specific problem is as follows:\\n%s\\n\", s);\n\t//abort();\n}\n", "/*\n * Copyright (c) 1999-2000 Image Power, Inc. and the University of\n *   British Columbia.\n * Copyright (c) 2001-2003 Michael David Adams.\n * All rights reserved.\n */\n\n/* __START_OF_JASPER_LICENSE__\n * \n * JasPer License Version 2.0\n * \n * Copyright (c) 2001-2006 Michael David Adams\n * Copyright (c) 1999-2000 Image Power, Inc.\n * Copyright (c) 1999-2000 The University of British Columbia\n * \n * All rights reserved.\n * \n * Permission is hereby granted, free of charge, to any person (the\n * \"User\") obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n * \n * 1.  The above copyright notices and this permission notice (which\n * includes the disclaimer below) shall be included in all copies or\n * substantial portions of the Software.\n * \n * 2.  The name of a copyright holder shall not be used to endorse or\n * promote products derived from the Software without specific prior\n * written permission.\n * \n * THIS DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS\n * LICENSE.  NO USE OF THE SOFTWARE IS AUTHORIZED HEREUNDER EXCEPT UNDER\n * THIS DISCLAIMER.  THE SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS\n * \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.  IN NO\n * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL\n * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING\n * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\n * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION\n * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  NO ASSURANCES ARE\n * PROVIDED BY THE COPYRIGHT HOLDERS THAT THE SOFTWARE DOES NOT INFRINGE\n * THE PATENT OR OTHER INTELLECTUAL PROPERTY RIGHTS OF ANY OTHER ENTITY.\n * EACH COPYRIGHT HOLDER DISCLAIMS ANY LIABILITY TO THE USER FOR CLAIMS\n * BROUGHT BY ANY OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL\n * PROPERTY RIGHTS OR OTHERWISE.  AS A CONDITION TO EXERCISING THE RIGHTS\n * GRANTED HEREUNDER, EACH USER HEREBY ASSUMES SOLE RESPONSIBILITY TO SECURE\n * ANY OTHER INTELLECTUAL PROPERTY RIGHTS NEEDED, IF ANY.  THE SOFTWARE\n * IS NOT FAULT-TOLERANT AND IS NOT INTENDED FOR USE IN MISSION-CRITICAL\n * SYSTEMS, SUCH AS THOSE USED IN THE OPERATION OF NUCLEAR FACILITIES,\n * AIRCRAFT NAVIGATION OR COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL\n * SYSTEMS, DIRECT LIFE SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH\n * THE FAILURE OF THE SOFTWARE OR SYSTEM COULD LEAD DIRECTLY TO DEATH,\n * PERSONAL INJURY, OR SEVERE PHYSICAL OR ENVIRONMENTAL DAMAGE (\"HIGH\n * RISK ACTIVITIES\").  THE COPYRIGHT HOLDERS SPECIFICALLY DISCLAIM ANY\n * EXPRESS OR IMPLIED WARRANTY OF FITNESS FOR HIGH RISK ACTIVITIES.\n * \n * __END_OF_JASPER_LICENSE__\n */\n\n/*\n * Image Library\n *\n * $Id$\n */\n\n/******************************************************************************\\\n* Includes.\n\\******************************************************************************/\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <assert.h>\n#include <ctype.h>\n#include <inttypes.h>\n#include <stdbool.h>\n\n#include \"jasper/jas_math.h\"\n#include \"jasper/jas_image.h\"\n#include \"jasper/jas_malloc.h\"\n#include \"jasper/jas_string.h\"\n#include \"jasper/jas_debug.h\"\n\n/******************************************************************************\\\n* Types.\n\\******************************************************************************/\n\n#define\tFLOORDIV(x, y) ((x) / (y))\n\n/******************************************************************************\\\n* Local prototypes.\n\\******************************************************************************/\n\nstatic jas_image_cmpt_t *jas_image_cmpt_create0(void);\nstatic void jas_image_cmpt_destroy(jas_image_cmpt_t *cmpt);\nstatic jas_image_cmpt_t *jas_image_cmpt_create(int_fast32_t tlx,\n  int_fast32_t tly, int_fast32_t hstep, int_fast32_t vstep,\n  int_fast32_t width, int_fast32_t height, uint_fast16_t depth, bool sgnd,\n  uint_fast32_t inmem);\nstatic void jas_image_setbbox(jas_image_t *image);\nstatic jas_image_cmpt_t *jas_image_cmpt_copy(jas_image_cmpt_t *cmpt);\nstatic int jas_image_growcmpts(jas_image_t *image, int maxcmpts);\nstatic uint_fast32_t inttobits(jas_seqent_t v, int prec, bool sgnd);\nstatic jas_seqent_t bitstoint(uint_fast32_t v, int prec, bool sgnd);\nstatic int putint(jas_stream_t *out, int sgnd, int prec, long val);\nstatic int getint(jas_stream_t *in, int sgnd, int prec, long *val);\nstatic void jas_image_calcbbox2(jas_image_t *image, jas_image_coord_t *tlx,\n  jas_image_coord_t *tly, jas_image_coord_t *brx, jas_image_coord_t *bry);\nstatic long uptomult(long x, long y);\nstatic long downtomult(long x, long y);\nstatic long convert(long val, int oldsgnd, int oldprec, int newsgnd,\n  int newprec);\nstatic void jas_image_calcbbox2(jas_image_t *image, jas_image_coord_t *tlx,\n  jas_image_coord_t *tly, jas_image_coord_t *brx, jas_image_coord_t *bry);\n\n/******************************************************************************\\\n* Global data.\n\\******************************************************************************/\n\nstatic int jas_image_numfmts = 0;\nstatic jas_image_fmtinfo_t jas_image_fmtinfos[JAS_IMAGE_MAXFMTS];\n\n/******************************************************************************\\\n* Create and destroy operations.\n\\******************************************************************************/\n\njas_image_t *jas_image_create(int numcmpts, jas_image_cmptparm_t *cmptparms,\n  int clrspc)\n{\n\tjas_image_t *image;\n\tuint_fast32_t rawsize;\n\tuint_fast32_t inmem;\n\tint cmptno;\n\tjas_image_cmptparm_t *cmptparm;\n\n\tif (!(image = jas_image_create0())) {\n\t\treturn 0;\n\t}\n\n\timage->clrspc_ = clrspc;\n\timage->maxcmpts_ = numcmpts;\n\timage->inmem_ = true;\n\n\t/* Allocate memory for the per-component information. */\n\tif (!(image->cmpts_ = jas_alloc2(image->maxcmpts_,\n\t  sizeof(jas_image_cmpt_t *)))) {\n\t\tjas_image_destroy(image);\n\t\treturn 0;\n\t}\n\t/* Initialize in case of failure. */\n\tfor (cmptno = 0; cmptno < image->maxcmpts_; ++cmptno) {\n\t\timage->cmpts_[cmptno] = 0;\n\t}\n\n\t/* Compute the approximate raw size of the image. */\n\trawsize = 0;\n\tfor (cmptno = 0, cmptparm = cmptparms; cmptno < numcmpts; ++cmptno,\n\t  ++cmptparm) {\n\t\trawsize += cmptparm->width * cmptparm->height *\n\t\t  (cmptparm->prec + 7) / 8;\n\t}\n\t/* Decide whether to buffer the image data in memory, based on the\n\t  raw size of the image. */\n\tinmem = (rawsize < JAS_IMAGE_INMEMTHRESH);\n\n\t/* Create the individual image components. */\n\tfor (cmptno = 0, cmptparm = cmptparms; cmptno < numcmpts; ++cmptno,\n\t  ++cmptparm) {\n\t\tif (!(image->cmpts_[cmptno] = jas_image_cmpt_create(cmptparm->tlx,\n\t\t  cmptparm->tly, cmptparm->hstep, cmptparm->vstep,\n\t\t  cmptparm->width, cmptparm->height, cmptparm->prec,\n\t\t  cmptparm->sgnd, inmem))) {\n\t\t\tjas_image_destroy(image);\n\t\t\treturn 0;\n\t\t}\n\t\t++image->numcmpts_;\n\t}\n\n\t/* Determine the bounding box for all of the components on the\n\t  reference grid (i.e., the image area) */\n\tjas_image_setbbox(image);\n\n\treturn image;\n}\n\njas_image_t *jas_image_create0()\n{\n\tjas_image_t *image;\n\n\tif (!(image = jas_malloc(sizeof(jas_image_t)))) {\n\t\treturn 0;\n\t}\n\n\timage->tlx_ = 0;\n\timage->tly_ = 0;\n\timage->brx_ = 0;\n\timage->bry_ = 0;\n\timage->clrspc_ = JAS_CLRSPC_UNKNOWN;\n\timage->numcmpts_ = 0;\n\timage->maxcmpts_ = 0;\n\timage->cmpts_ = 0;\n\timage->inmem_ = true;\n\timage->cmprof_ = 0;\n\n\treturn image;\n}\n\njas_image_t *jas_image_copy(jas_image_t *image)\n{\n\tjas_image_t *newimage;\n\tint cmptno;\n\n\tif (!(newimage = jas_image_create0())) {\n\t\tgoto error;\n\t}\n\n\tif (jas_image_growcmpts(newimage, image->numcmpts_)) {\n\t\tgoto error;\n\t}\n\tfor (cmptno = 0; cmptno < image->numcmpts_; ++cmptno) {\n\t\tif (!(newimage->cmpts_[cmptno] = jas_image_cmpt_copy(image->cmpts_[cmptno]))) {\n\t\t\tgoto error;\n\t\t}\n\t\t++newimage->numcmpts_;\n\t}\n\n\tjas_image_setbbox(newimage);\n\n\tif (image->cmprof_) {\n\t\tif (!(newimage->cmprof_ = jas_cmprof_copy(image->cmprof_)))\n\t\t\tgoto error;\n\t}\n\n\treturn newimage;\nerror:\n\tif (newimage) {\n\t\tjas_image_destroy(newimage);\n\t}\n\treturn 0;\n}\n\nstatic jas_image_cmpt_t *jas_image_cmpt_create0()\n{\n\tjas_image_cmpt_t *cmpt;\n\tif (!(cmpt = jas_malloc(sizeof(jas_image_cmpt_t)))) {\n\t\treturn 0;\n\t}\n\tmemset(cmpt, 0, sizeof(jas_image_cmpt_t));\n\tcmpt->type_ = JAS_IMAGE_CT_UNKNOWN;\n\treturn cmpt;\n}\n\nstatic jas_image_cmpt_t *jas_image_cmpt_copy(jas_image_cmpt_t *cmpt)\n{\n\tjas_image_cmpt_t *newcmpt;\n\n\tif (!(newcmpt = jas_image_cmpt_create0())) {\n\t\treturn 0;\n\t}\n\tnewcmpt->tlx_ = cmpt->tlx_;\n\tnewcmpt->tly_ = cmpt->tly_;\n\tnewcmpt->hstep_ = cmpt->hstep_;\n\tnewcmpt->vstep_ = cmpt->vstep_;\n\tnewcmpt->width_ = cmpt->width_;\n\tnewcmpt->height_ = cmpt->height_;\n\tnewcmpt->prec_ = cmpt->prec_;\n\tnewcmpt->sgnd_ = cmpt->sgnd_;\n\tnewcmpt->cps_ = cmpt->cps_;\n\tnewcmpt->type_ = cmpt->type_;\n\tif (!(newcmpt->stream_ = jas_stream_memopen(0, 0))) {\n\t\tgoto error;\n\t}\n\tif (jas_stream_seek(cmpt->stream_, 0, SEEK_SET)) {\n\t\tgoto error;\n\t}\n\tif (jas_stream_copy(newcmpt->stream_, cmpt->stream_, -1)) {\n\t\tgoto error;\n\t}\n\tif (jas_stream_seek(newcmpt->stream_, 0, SEEK_SET)) {\n\t\tgoto error;\n\t}\n\treturn newcmpt;\nerror:\n\tif (newcmpt) {\n\t\tjas_image_cmpt_destroy(newcmpt);\n\t}\n\treturn 0;\n}\n\nvoid jas_image_destroy(jas_image_t *image)\n{\n\tint i;\n\n\tif (image->cmpts_) {\n\t\tfor (i = 0; i < image->numcmpts_; ++i) {\n\t\t\tjas_image_cmpt_destroy(image->cmpts_[i]);\n\t\t\timage->cmpts_[i] = 0;\n\t\t}\n\t\tjas_free(image->cmpts_);\n\t}\n\tif (image->cmprof_)\n\t\tjas_cmprof_destroy(image->cmprof_);\n\tjas_free(image);\n}\n\nstatic jas_image_cmpt_t *jas_image_cmpt_create(int_fast32_t tlx,\n  int_fast32_t tly, int_fast32_t hstep, int_fast32_t vstep,\n  int_fast32_t width, int_fast32_t height, uint_fast16_t depth, bool sgnd,\n  uint_fast32_t inmem)\n{\n\tjas_image_cmpt_t *cmpt;\n\tsize_t size;\n\n\tcmpt = 0;\n\tif (width < 0 || height < 0 || hstep <= 0 || vstep <= 0) {\n\t\tgoto error;\n\t}\n\tif (!jas_safe_intfast32_add(tlx, width, 0) ||\n\t  !jas_safe_intfast32_add(tly, height, 0)) {\n\t\tgoto error;\n\t}\n\n\tif (!(cmpt = jas_malloc(sizeof(jas_image_cmpt_t)))) {\n\t\tgoto error;\n\t}\n\n\tcmpt->type_ = JAS_IMAGE_CT_UNKNOWN;\n\tcmpt->tlx_ = tlx;\n\tcmpt->tly_ = tly;\n\tcmpt->hstep_ = hstep;\n\tcmpt->vstep_ = vstep;\n\tcmpt->width_ = width;\n\tcmpt->height_ = height;\n\tcmpt->prec_ = depth;\n\tcmpt->sgnd_ = sgnd;\n\tcmpt->stream_ = 0;\n\tcmpt->cps_ = (depth + 7) / 8;\n\n\t// Compute the number of samples in the image component, while protecting\n\t// against overflow.\n\t// size = cmpt->width_ * cmpt->height_ * cmpt->cps_;\n\tif (!jas_safe_size_mul(cmpt->width_, cmpt->height_, &size) ||\n\t  !jas_safe_size_mul(size, cmpt->cps_, &size)) {\n\t\tgoto error;\n\t}\n\tcmpt->stream_ = (inmem) ? jas_stream_memopen2(0, size) :\n\t  jas_stream_tmpfile();\n\tif (!cmpt->stream_) {\n\t\tgoto error;\n\t}\n\n\t/* Zero the component data.  This isn't necessary, but it is\n\tconvenient for debugging purposes. */\n\t/* Note: conversion of size - 1 to long can overflow */\n\tif (jas_stream_seek(cmpt->stream_, size - 1, SEEK_SET) < 0 ||\n\t  jas_stream_putc(cmpt->stream_, 0) == EOF ||\n\t  jas_stream_seek(cmpt->stream_, 0, SEEK_SET) < 0) {\n\t\tgoto error;\n\t}\n\n\treturn cmpt;\n\nerror:\n\tif (cmpt) {\n\t\tjas_image_cmpt_destroy(cmpt);\n\t}\n\treturn 0;\n}\n\nstatic void jas_image_cmpt_destroy(jas_image_cmpt_t *cmpt)\n{\n\tif (cmpt->stream_) {\n\t\tjas_stream_close(cmpt->stream_);\n\t}\n\tjas_free(cmpt);\n}\n\n/******************************************************************************\\\n* Load and save operations.\n\\******************************************************************************/\n\njas_image_t *jas_image_decode(jas_stream_t *in, int fmt, char *optstr)\n{\n\tjas_image_fmtinfo_t *fmtinfo;\n\tjas_image_t *image;\n\n\timage = 0;\n\n\t/* If possible, try to determine the format of the input data. */\n\tif (fmt < 0) {\n\t\tif ((fmt = jas_image_getfmt(in)) < 0)\n\t\t\tgoto error;\n\t}\n\n\t/* Is it possible to decode an image represented in this format? */\n\tif (!(fmtinfo = jas_image_lookupfmtbyid(fmt)))\n\t\tgoto error;\n\tif (!fmtinfo->ops.decode)\n\t\tgoto error;\n\n\t/* Decode the image. */\n\tif (!(image = (*fmtinfo->ops.decode)(in, optstr)))\n\t\tgoto error;\n\n\t/* Create a color profile if needed. */\n\tif (!jas_clrspc_isunknown(image->clrspc_) &&\n\t  !jas_clrspc_isgeneric(image->clrspc_) && !image->cmprof_) {\n\t\tif (!(image->cmprof_ =\n\t\t  jas_cmprof_createfromclrspc(jas_image_clrspc(image))))\n\t\t\tgoto error;\n\t}\n\n\treturn image;\nerror:\n\tif (image)\n\t\tjas_image_destroy(image);\n\treturn 0;\n}\n\nint jas_image_encode(jas_image_t *image, jas_stream_t *out, int fmt, char *optstr)\n{\n\tjas_image_fmtinfo_t *fmtinfo;\n\tif (!(fmtinfo = jas_image_lookupfmtbyid(fmt))) {\n\t\treturn -1;\n\t}\n\treturn (fmtinfo->ops.encode) ? (*fmtinfo->ops.encode)(image, out,\n\t  optstr) : (-1);\n}\n\n/******************************************************************************\\\n* Component read and write operations.\n\\******************************************************************************/\n\nint jas_image_readcmpt(jas_image_t *image, int cmptno, jas_image_coord_t x,\n  jas_image_coord_t y, jas_image_coord_t width, jas_image_coord_t height,\n  jas_matrix_t *data)\n{\n\tjas_image_cmpt_t *cmpt;\n\tjas_image_coord_t i;\n\tjas_image_coord_t j;\n\tint k;\n\tjas_seqent_t v;\n\tint c;\n\tjas_seqent_t *dr;\n\tjas_seqent_t *d;\n\tint drs;\n\n\tif (cmptno < 0 || cmptno >= image->numcmpts_) {\n\t\treturn -1;\n\t}\n\n\tcmpt = image->cmpts_[cmptno];\n\tif (x >= cmpt->width_ || y >= cmpt->height_ ||\n\t  x + width > cmpt->width_ ||\n\t  y + height > cmpt->height_) {\n\t\treturn -1;\n\t}\n\n\tif (!jas_matrix_numrows(data) || !jas_matrix_numcols(data)) {\n\t\treturn -1;\n\t}\n\n\tif (jas_matrix_numrows(data) != height || jas_matrix_numcols(data) != width) {\n\t\tif (jas_matrix_resize(data, height, width)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tdr = jas_matrix_getref(data, 0, 0);\n\tdrs = jas_matrix_rowstep(data);\n\tfor (i = 0; i < height; ++i, dr += drs) {\n\t\td = dr;\n\t\tif (jas_stream_seek(cmpt->stream_, (cmpt->width_ * (y + i) + x)\n\t\t  * cmpt->cps_, SEEK_SET) < 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tfor (j = width; j > 0; --j, ++d) {\n\t\t\tv = 0;\n\t\t\tfor (k = cmpt->cps_; k > 0; --k) {\n\t\t\t\tif ((c = jas_stream_getc(cmpt->stream_)) == EOF) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tv = (v << 8) | (c & 0xff);\n\t\t\t}\n\t\t\t*d = bitstoint(v, cmpt->prec_, cmpt->sgnd_);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint jas_image_writecmpt(jas_image_t *image, int cmptno, jas_image_coord_t x, jas_image_coord_t y, jas_image_coord_t width,\n  jas_image_coord_t height, jas_matrix_t *data)\n{\n\tjas_image_cmpt_t *cmpt;\n\tjas_image_coord_t i;\n\tjas_image_coord_t j;\n\tjas_seqent_t *d;\n\tjas_seqent_t *dr;\n\tint drs;\n\tjas_seqent_t v;\n\tint k;\n\tint c;\n\n\tif (cmptno < 0 || cmptno >= image->numcmpts_) {\n\t\treturn -1;\n\t}\n\n\tcmpt = image->cmpts_[cmptno];\n\tif (x >= cmpt->width_ || y >= cmpt->height_ ||\n\t  x + width > cmpt->width_ ||\n\t  y + height > cmpt->height_) {\n\t\treturn -1;\n\t}\n\n\tif (!jas_matrix_numrows(data) || !jas_matrix_numcols(data)) {\n\t\treturn -1;\n\t}\n\n\tif (jas_matrix_numrows(data) != height || jas_matrix_numcols(data) != width) {\n\t\treturn -1;\n\t}\n\n\tdr = jas_matrix_getref(data, 0, 0);\n\tdrs = jas_matrix_rowstep(data);\n\tfor (i = 0; i < height; ++i, dr += drs) {\n\t\td = dr;\n\t\tif (jas_stream_seek(cmpt->stream_, (cmpt->width_ * (y + i) + x)\n\t\t  * cmpt->cps_, SEEK_SET) < 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tfor (j = width; j > 0; --j, ++d) {\n\t\t\tv = inttobits(*d, cmpt->prec_, cmpt->sgnd_);\n\t\t\tfor (k = cmpt->cps_; k > 0; --k) {\n\t\t\t\tc = (v >> (8 * (cmpt->cps_ - 1))) & 0xff;\n\t\t\t\tif (jas_stream_putc(cmpt->stream_,\n\t\t\t\t  (unsigned char) c) == EOF) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tv <<= 8;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/******************************************************************************\\\n* File format operations.\n\\******************************************************************************/\n\nvoid jas_image_clearfmts()\n{\n\tint i;\n\tjas_image_fmtinfo_t *fmtinfo;\n\tfor (i = 0; i < jas_image_numfmts; ++i) {\n\t\tfmtinfo = &jas_image_fmtinfos[i];\n\t\tif (fmtinfo->name) {\n\t\t\tjas_free(fmtinfo->name);\n\t\t\tfmtinfo->name = 0;\n\t\t}\n\t\tif (fmtinfo->ext) {\n\t\t\tjas_free(fmtinfo->ext);\n\t\t\tfmtinfo->ext = 0;\n\t\t}\n\t\tif (fmtinfo->desc) {\n\t\t\tjas_free(fmtinfo->desc);\n\t\t\tfmtinfo->desc = 0;\n\t\t}\n\t}\n\tjas_image_numfmts = 0;\n}\n\nint jas_image_addfmt(int id, char *name, char *ext, char *desc,\n  jas_image_fmtops_t *ops)\n{\n\tjas_image_fmtinfo_t *fmtinfo;\n\tassert(id >= 0 && name && ext && ops);\n\tif (jas_image_numfmts >= JAS_IMAGE_MAXFMTS) {\n\t\treturn -1;\n\t}\n\tfmtinfo = &jas_image_fmtinfos[jas_image_numfmts];\n\tfmtinfo->id = id;\n\tif (!(fmtinfo->name = jas_strdup(name))) {\n\t\treturn -1;\n\t}\n\tif (!(fmtinfo->ext = jas_strdup(ext))) {\n\t\tjas_free(fmtinfo->name);\n\t\treturn -1;\n\t}\n\tif (!(fmtinfo->desc = jas_strdup(desc))) {\n\t\tjas_free(fmtinfo->name);\n\t\tjas_free(fmtinfo->ext);\n\t\treturn -1;\n\t}\n\tfmtinfo->ops = *ops;\n\t++jas_image_numfmts;\n\treturn 0;\n}\n\nint jas_image_strtofmt(char *name)\n{\n\tjas_image_fmtinfo_t *fmtinfo;\n\tif (!(fmtinfo = jas_image_lookupfmtbyname(name))) {\n\t\treturn -1;\n\t}\n\treturn fmtinfo->id;\n}\n\nchar *jas_image_fmttostr(int fmt)\n{\n\tjas_image_fmtinfo_t *fmtinfo;\n\tif (!(fmtinfo = jas_image_lookupfmtbyid(fmt))) {\n\t\treturn 0;\n\t}\n\treturn fmtinfo->name;\n}\n\nint jas_image_getfmt(jas_stream_t *in)\n{\n\tjas_image_fmtinfo_t *fmtinfo;\n\tint found;\n\tint i;\n\n\t/* Check for data in each of the supported formats. */\n\tfound = 0;\n\tfor (i = 0, fmtinfo = jas_image_fmtinfos; i < jas_image_numfmts; ++i,\n\t  ++fmtinfo) {\n\t\tif (fmtinfo->ops.validate) {\n\t\t\t/* Is the input data valid for this format? */\n\t\t\tJAS_DBGLOG(20, (\"testing for format %s ... \", fmtinfo->name));\n\t\t\tif (!(*fmtinfo->ops.validate)(in)) {\n\t\t\t\tJAS_DBGLOG(20, (\"test succeeded\\n\"));\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tJAS_DBGLOG(20, (\"test failed\\n\"));\n\t\t}\n\t}\n\treturn found ? fmtinfo->id : (-1);\n}\n\nint jas_image_fmtfromname(char *name)\n{\n\tint i;\n\tchar *ext;\n\tjas_image_fmtinfo_t *fmtinfo;\n\t/* Get the file name extension. */\n\tif (!(ext = strrchr(name, '.'))) {\n\t\treturn -1;\n\t}\n\t++ext;\n\t/* Try to find a format that uses this extension. */\t\n\tfor (i = 0, fmtinfo = jas_image_fmtinfos; i < jas_image_numfmts; ++i,\n\t  ++fmtinfo) {\n\t\t/* Do we have a match? */\n\t\tif (!strcmp(ext, fmtinfo->ext)) {\n\t\t\treturn fmtinfo->id;\n\t\t}\n\t}\n\treturn -1;\n}\n\n/******************************************************************************\\\n* Miscellaneous operations.\n\\******************************************************************************/\n\nbool jas_image_cmpt_domains_same(jas_image_t *image)\n{\n\tint cmptno;\n\tjas_image_cmpt_t *cmpt;\n\tjas_image_cmpt_t *cmpt0;\n\n\tcmpt0 = image->cmpts_[0];\n\tfor (cmptno = 1; cmptno < image->numcmpts_; ++cmptno) {\n\t\tcmpt = image->cmpts_[cmptno];\n\t\tif (cmpt->tlx_ != cmpt0->tlx_ || cmpt->tly_ != cmpt0->tly_ ||\n\t\t  cmpt->hstep_ != cmpt0->hstep_ || cmpt->vstep_ != cmpt0->vstep_ ||\n\t\t  cmpt->width_ != cmpt0->width_ || cmpt->height_ != cmpt0->height_) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nuint_fast32_t jas_image_rawsize(jas_image_t *image)\n{\n\tuint_fast32_t rawsize;\n\tint cmptno;\n\tjas_image_cmpt_t *cmpt;\n\n\trawsize = 0;\n\tfor (cmptno = 0; cmptno < image->numcmpts_; ++cmptno) {\n\t\tcmpt = image->cmpts_[cmptno];\n\t\trawsize += (cmpt->width_ * cmpt->height_ * cmpt->prec_ +\n\t\t  7) / 8;\n\t}\n\treturn rawsize;\n}\n\nvoid jas_image_delcmpt(jas_image_t *image, int cmptno)\n{\n\tif (cmptno >= image->numcmpts_) {\n\t\treturn;\n\t}\n\tjas_image_cmpt_destroy(image->cmpts_[cmptno]);\n\tif (cmptno < image->numcmpts_) {\n\t\tmemmove(&image->cmpts_[cmptno], &image->cmpts_[cmptno + 1],\n\t\t  (image->numcmpts_ - 1 - cmptno) * sizeof(jas_image_cmpt_t *));\n\t}\n\t--image->numcmpts_;\n\n\tjas_image_setbbox(image);\n}\n\nint jas_image_addcmpt(jas_image_t *image, int cmptno,\n  jas_image_cmptparm_t *cmptparm)\n{\n\tjas_image_cmpt_t *newcmpt;\n\tif (cmptno < 0) {\n\t\tcmptno = image->numcmpts_;\n\t}\n\tassert(cmptno >= 0 && cmptno <= image->numcmpts_);\n\tif (image->numcmpts_ >= image->maxcmpts_) {\n\t\tif (jas_image_growcmpts(image, image->maxcmpts_ + 128)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (!(newcmpt = jas_image_cmpt_create(cmptparm->tlx,\n\t  cmptparm->tly, cmptparm->hstep, cmptparm->vstep,\n\t  cmptparm->width, cmptparm->height, cmptparm->prec,\n\t  cmptparm->sgnd, 1))) {\n\t\treturn -1;\n\t}\n\tif (cmptno < image->numcmpts_) {\n\t\tmemmove(&image->cmpts_[cmptno + 1], &image->cmpts_[cmptno],\n\t\t  (image->numcmpts_ - cmptno) * sizeof(jas_image_cmpt_t *));\n\t}\n\timage->cmpts_[cmptno] = newcmpt;\n\t++image->numcmpts_;\n\n\tjas_image_setbbox(image);\n\n\treturn 0;\n}\n\njas_image_fmtinfo_t *jas_image_lookupfmtbyid(int id)\n{\n\tint i;\n\tjas_image_fmtinfo_t *fmtinfo;\n\n\tfor (i = 0, fmtinfo = jas_image_fmtinfos; i < jas_image_numfmts; ++i, ++fmtinfo) {\n\t\tif (fmtinfo->id == id) {\n\t\t\treturn fmtinfo;\n\t\t}\n\t}\n\treturn 0;\n}\n\njas_image_fmtinfo_t *jas_image_lookupfmtbyname(const char *name)\n{\n\tint i;\n\tjas_image_fmtinfo_t *fmtinfo;\n\n\tfor (i = 0, fmtinfo = jas_image_fmtinfos; i < jas_image_numfmts; ++i, ++fmtinfo) {\n\t\tif (!strcmp(fmtinfo->name, name)) {\n\t\t\treturn fmtinfo;\n\t\t}\n\t}\n\treturn 0;\n}\n\n\n\n\n\nstatic uint_fast32_t inttobits(jas_seqent_t v, int prec, bool sgnd)\n{\n\tuint_fast32_t ret;\n\tret = ((sgnd && v < 0) ? ((1 << prec) + v) : v) & JAS_ONES(prec);\n\treturn ret;\n}\n\nstatic jas_seqent_t bitstoint(uint_fast32_t v, int prec, bool sgnd)\n{\n\tjas_seqent_t ret;\n\tv &= JAS_ONES(prec);\n\tret = (sgnd && (v & (1 << (prec - 1)))) ? (v - (1 << prec)) : v;\n\treturn ret;\n}\n\nstatic void jas_image_setbbox(jas_image_t *image)\n{\n\tjas_image_cmpt_t *cmpt;\n\tint cmptno;\n\tint_fast32_t x;\n\tint_fast32_t y;\n\n\tif (image->numcmpts_ > 0) {\n\t\t/* Determine the bounding box for all of the components on the\n\t\t  reference grid (i.e., the image area) */\n\t\tcmpt = image->cmpts_[0];\n\t\timage->tlx_ = cmpt->tlx_;\n\t\timage->tly_ = cmpt->tly_;\n\t\timage->brx_ = cmpt->tlx_ + cmpt->hstep_ * (cmpt->width_ - 1) + 1;\n\t\timage->bry_ = cmpt->tly_ + cmpt->vstep_ * (cmpt->height_ - 1) + 1;\n\t\tfor (cmptno = 1; cmptno < image->numcmpts_; ++cmptno) {\n\t\t\tcmpt = image->cmpts_[cmptno];\n\t\t\tif (image->tlx_ > cmpt->tlx_) {\n\t\t\t\timage->tlx_ = cmpt->tlx_;\n\t\t\t}\n\t\t\tif (image->tly_ > cmpt->tly_) {\n\t\t\t\timage->tly_ = cmpt->tly_;\n\t\t\t}\n\t\t\tx = cmpt->tlx_ + cmpt->hstep_ * (cmpt->width_ - 1) + 1;\n\t\t\tif (image->brx_ < x) {\n\t\t\t\timage->brx_ = x;\n\t\t\t}\n\t\t\ty = cmpt->tly_ + cmpt->vstep_ * (cmpt->height_ - 1) + 1;\n\t\t\tif (image->bry_ < y) {\n\t\t\t\timage->bry_ = y;\n\t\t\t}\n\t\t}\n\t} else {\n\t\timage->tlx_ = 0;\n\t\timage->tly_ = 0;\n\t\timage->brx_ = 0;\n\t\timage->bry_ = 0;\n\t}\n}\n\nstatic int jas_image_growcmpts(jas_image_t *image, int maxcmpts)\n{\n\tjas_image_cmpt_t **newcmpts;\n\tint cmptno;\n\n\tnewcmpts = (!image->cmpts_) ? jas_alloc2(maxcmpts,\n\t  sizeof(jas_image_cmpt_t *)) :\n\t  jas_realloc2(image->cmpts_, maxcmpts, sizeof(jas_image_cmpt_t *));\n\tif (!newcmpts) {\n\t\treturn -1;\n\t}\n\timage->cmpts_ = newcmpts;\n\timage->maxcmpts_ = maxcmpts;\n\tfor (cmptno = image->numcmpts_; cmptno < image->maxcmpts_; ++cmptno) {\n\t\timage->cmpts_[cmptno] = 0;\n\t}\n\treturn 0;\n}\n\nint jas_image_copycmpt(jas_image_t *dstimage, int dstcmptno,\n  jas_image_t *srcimage, int srccmptno)\n{\n\tjas_image_cmpt_t *newcmpt;\n\tif (dstimage->numcmpts_ >= dstimage->maxcmpts_) {\n\t\tif (jas_image_growcmpts(dstimage, dstimage->maxcmpts_ + 128)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (!(newcmpt = jas_image_cmpt_copy(srcimage->cmpts_[srccmptno]))) {\n\t\treturn -1;\n\t}\n\tif (dstcmptno < dstimage->numcmpts_) {\n\t\tmemmove(&dstimage->cmpts_[dstcmptno + 1], &dstimage->cmpts_[dstcmptno],\n\t\t  (dstimage->numcmpts_ - dstcmptno) * sizeof(jas_image_cmpt_t *));\n\t}\n\tdstimage->cmpts_[dstcmptno] = newcmpt;\n\t++dstimage->numcmpts_;\n\n\tjas_image_setbbox(dstimage);\n\treturn 0;\n}\n\nvoid jas_image_dump(jas_image_t *image, FILE *out)\n{\n\tlong buf[1024];\n\tint cmptno;\n\tint n;\n\tint i;\n\tint width;\n\tint height;\n\tjas_image_cmpt_t *cmpt;\n\tfor (cmptno = 0; cmptno < image->numcmpts_; ++cmptno) {\n\t\tcmpt = image->cmpts_[cmptno];\n\t\tfprintf(out, \"prec=%d, sgnd=%d, cmpttype=%\"PRIiFAST32\"\\n\", cmpt->prec_,\n\t\t  cmpt->sgnd_, cmpt->type_);\n\t\twidth = jas_image_cmptwidth(image, cmptno);\n\t\theight = jas_image_cmptheight(image, cmptno);\n\t\tn = JAS_MIN(16, width);\n\t\tif (jas_image_readcmpt2(image, cmptno, 0, 0, n, 1, buf)) {\n\t\t\tabort();\n\t\t}\n\t\tfor (i = 0; i < n; ++i) {\n\t\t\tfprintf(out, \" f(%d,%d)=%ld\", i, 0, buf[i]);\n\t\t}\n\t\tfprintf(out, \"\\n\");\n\t\tif (jas_image_readcmpt2(image, cmptno, width - n, height - 1, n, 1, buf)) {\n\t\t\tabort();\n\t\t}\n\t\tfor (i = 0; i < n; ++i) {\n\t\t\tfprintf(out, \" f(%d,%d)=%ld\", width - n + i, height - 1, buf[i]);\n\t\t}\n\t\tfprintf(out, \"\\n\");\n\t}\n}\n\nint jas_image_depalettize(jas_image_t *image, int cmptno, int numlutents,\n  int_fast32_t *lutents, int dtype, int newcmptno)\n{\n\tjas_image_cmptparm_t cmptparms;\n\tint_fast32_t v;\n\tint i;\n\tint j;\n\tjas_image_cmpt_t *cmpt;\n\n\tcmpt = image->cmpts_[cmptno];\n\tcmptparms.tlx = cmpt->tlx_;\n\tcmptparms.tly = cmpt->tly_;\n\tcmptparms.hstep = cmpt->hstep_;\n\tcmptparms.vstep = cmpt->vstep_;\n\tcmptparms.width = cmpt->width_;\n\tcmptparms.height = cmpt->height_;\n\tcmptparms.prec = JAS_IMAGE_CDT_GETPREC(dtype);\n\tcmptparms.sgnd = JAS_IMAGE_CDT_GETSGND(dtype);\n\n\tif (jas_image_addcmpt(image, newcmptno, &cmptparms)) {\n\t\treturn -1;\n\t}\n\tif (newcmptno <= cmptno) {\n\t\t++cmptno;\n\t\tcmpt = image->cmpts_[cmptno];\n\t}\n\n\tfor (j = 0; j < cmpt->height_; ++j) {\n\t\tfor (i = 0; i < cmpt->width_; ++i) {\n\t\t\tv = jas_image_readcmptsample(image, cmptno, i, j);\n\t\t\tif (v < 0) {\n\t\t\t\tv = 0;\n\t\t\t} else if (v >= numlutents) {\n\t\t\t\tv = numlutents - 1;\n\t\t\t}\n\t\t\tjas_image_writecmptsample(image, newcmptno, i, j,\n\t\t\t  lutents[v]);\n\t\t}\n\t}\n\treturn 0;\n}\n\nint jas_image_readcmptsample(jas_image_t *image, int cmptno, int x, int y)\n{\n\tjas_image_cmpt_t *cmpt;\n\tuint_fast32_t v;\n\tint k;\n\tint c;\n\n\tcmpt = image->cmpts_[cmptno];\n\n\tif (jas_stream_seek(cmpt->stream_, (cmpt->width_ * y + x) * cmpt->cps_,\n\t  SEEK_SET) < 0) {\n\t\treturn -1;\n\t}\n\tv = 0;\n\tfor (k = cmpt->cps_; k > 0; --k) {\n\t\tif ((c = jas_stream_getc(cmpt->stream_)) == EOF) {\n\t\t\treturn -1;\n\t\t}\n\t\tv = (v << 8) | (c & 0xff);\n\t}\n\treturn bitstoint(v, cmpt->prec_, cmpt->sgnd_);\n}\n\nvoid jas_image_writecmptsample(jas_image_t *image, int cmptno, int x, int y,\n  int_fast32_t v)\n{\n\tjas_image_cmpt_t *cmpt;\n\tuint_fast32_t t;\n\tint k;\n\tint c;\n\n\tcmpt = image->cmpts_[cmptno];\n\n\tif (jas_stream_seek(cmpt->stream_, (cmpt->width_ * y + x) * cmpt->cps_,\n\t  SEEK_SET) < 0) {\n\t\treturn;\n\t}\n\tt = inttobits(v, cmpt->prec_, cmpt->sgnd_);\n\tfor (k = cmpt->cps_; k > 0; --k) {\n\t\tc = (t >> (8 * (cmpt->cps_ - 1))) & 0xff;\n\t\tif (jas_stream_putc(cmpt->stream_, (unsigned char) c) == EOF) {\n\t\t\treturn;\n\t\t}\n\t\tt <<= 8;\n\t}\n}\n\nint jas_image_getcmptbytype(jas_image_t *image, int ctype)\n{\n\tint cmptno;\n\n\tfor (cmptno = 0; cmptno < image->numcmpts_; ++cmptno) {\n\t\tif (image->cmpts_[cmptno]->type_ == ctype) {\n\t\t\treturn cmptno;\n\t\t}\n\t}\n\treturn -1;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/***********************************************/\n/***********************************************/\n/***********************************************/\n/***********************************************/\n\nint jas_image_readcmpt2(jas_image_t *image, int cmptno, jas_image_coord_t x,\n  jas_image_coord_t y, jas_image_coord_t width, jas_image_coord_t height,\n  long *buf)\n{\n\tjas_image_cmpt_t *cmpt;\n\tjas_image_coord_t i;\n\tjas_image_coord_t j;\n\tlong v;\n\tlong *bufptr;\n\n\tif (cmptno < 0 || cmptno >= image->numcmpts_)\n\t\tgoto error;\n\tcmpt = image->cmpts_[cmptno];\n\tif (x < 0 || x >= cmpt->width_ || y < 0 || y >= cmpt->height_ ||\n\t  width < 0 || height < 0 || x + width > cmpt->width_ ||\n\t  y + height > cmpt->height_)\n\t\tgoto error;\n\n\tbufptr = buf;\n\tfor (i = 0; i < height; ++i) {\n\t\tif (jas_stream_seek(cmpt->stream_, (cmpt->width_ * (y + i) + x)\n\t\t  * cmpt->cps_, SEEK_SET) < 0)\n\t\t\tgoto error;\n\t\tfor (j = 0; j < width; ++j) {\n\t\t\tif (getint(cmpt->stream_, cmpt->sgnd_, cmpt->prec_, &v))\n\t\t\t\tgoto error;\n\t\t\t*bufptr++ = v;\n\t\t}\n\t}\n\n\treturn 0;\nerror:\n\treturn -1;\n}\n\nint jas_image_writecmpt2(jas_image_t *image, int cmptno, jas_image_coord_t x,\n  jas_image_coord_t y, jas_image_coord_t width, jas_image_coord_t height,\n  long *buf)\n{\n\tjas_image_cmpt_t *cmpt;\n\tjas_image_coord_t i;\n\tjas_image_coord_t j;\n\tlong v;\n\tlong *bufptr;\n\n\tif (cmptno < 0 || cmptno >= image->numcmpts_)\n\t\tgoto error;\n\tcmpt = image->cmpts_[cmptno];\n\tif (x < 0 || x >= cmpt->width_ || y < 0 || y >= cmpt->height_ ||\n\t  width < 0 || height < 0 || x + width > cmpt->width_ ||\n\t  y + height > cmpt->height_)\n\t\tgoto error;\n\n\tbufptr = buf;\n\tfor (i = 0; i < height; ++i) {\n\t\tif (jas_stream_seek(cmpt->stream_, (cmpt->width_ * (y + i) + x)\n\t\t  * cmpt->cps_, SEEK_SET) < 0)\n\t\t\tgoto error;\n\t\tfor (j = 0; j < width; ++j) {\n\t\t\tv = *bufptr++;\n\t\t\tif (putint(cmpt->stream_, cmpt->sgnd_, cmpt->prec_, v))\n\t\t\t\tgoto error;\n\t\t}\n\t}\n\n\treturn 0;\nerror:\n\treturn -1;\n}\n\nint jas_image_sampcmpt(jas_image_t *image, int cmptno, int newcmptno,\n  jas_image_coord_t ho, jas_image_coord_t vo, jas_image_coord_t hs,\n  jas_image_coord_t vs, int sgnd, int prec)\n{\n\tjas_image_cmpt_t *oldcmpt;\n\tjas_image_cmpt_t *newcmpt;\n\tint width;\n\tint height;\n\tjas_image_coord_t tlx;\n\tjas_image_coord_t tly;\n\tjas_image_coord_t brx;\n\tjas_image_coord_t bry;\n\tint i;\n\tint j;\n\tjas_image_cmptparm_t cmptparm;\n\tjas_image_coord_t ax;\n\tjas_image_coord_t ay;\n\tjas_image_coord_t bx;\n\tjas_image_coord_t by;\n\tjas_image_coord_t d0;\n\tjas_image_coord_t d1;\n\tjas_image_coord_t d2;\n\tjas_image_coord_t d3;\n\tjas_image_coord_t oldx;\n\tjas_image_coord_t oldy;\n\tjas_image_coord_t x;\n\tjas_image_coord_t y;\n\tlong v;\n\tjas_image_coord_t cmptbrx;\n\tjas_image_coord_t cmptbry;\n\n\tassert(cmptno >= 0 && cmptno < image->numcmpts_);\n\toldcmpt = image->cmpts_[cmptno];\n\tassert(oldcmpt->tlx_ == 0 && oldcmpt->tly_ == 0);\n\tjas_image_calcbbox2(image, &tlx, &tly, &brx, &bry);\n\twidth = FLOORDIV(brx - ho + hs, hs);\n\theight = FLOORDIV(bry - vo + vs, vs);\n\tcmptparm.tlx = ho;\n\tcmptparm.tly = vo;\n\tcmptparm.hstep = hs;\n\tcmptparm.vstep = vs;\n\tcmptparm.width = width;\n\tcmptparm.height = height;\n\tcmptparm.prec = prec;\n\tcmptparm.sgnd = sgnd;\n\tif (jas_image_addcmpt(image, newcmptno, &cmptparm))\n\t\tgoto error;\ncmptbrx = oldcmpt->tlx_ + (oldcmpt->width_ - 1) * oldcmpt->hstep_;\ncmptbry = oldcmpt->tly_ + (oldcmpt->height_ - 1) * oldcmpt->vstep_;\n\tnewcmpt = image->cmpts_[newcmptno];\n\tjas_stream_rewind(newcmpt->stream_);\n\tfor (i = 0; i < height; ++i) {\n\t\ty = newcmpt->tly_ + newcmpt->vstep_ * i;\n\t\tfor (j = 0; j < width; ++j) {\n\t\t\tx = newcmpt->tlx_ + newcmpt->hstep_ * j;\n\t\t\tax = downtomult(x - oldcmpt->tlx_, oldcmpt->hstep_) + oldcmpt->tlx_;\n\t\t\tay = downtomult(y - oldcmpt->tly_, oldcmpt->vstep_) + oldcmpt->tly_;\n\t\t\tbx = uptomult(x - oldcmpt->tlx_, oldcmpt->hstep_) + oldcmpt->tlx_;\n\t\t\tif (bx > cmptbrx)\n\t\t\t\tbx = cmptbrx;\n\t\t\tby = uptomult(y - oldcmpt->tly_, oldcmpt->vstep_) + oldcmpt->tly_;\n\t\t\tif (by > cmptbry)\n\t\t\t\tby = cmptbry;\n\t\t\td0 = (ax - x) * (ax - x) + (ay - y) * (ay - y);\n\t\t\td1 = (bx - x) * (bx - x) + (ay - y) * (ay - y);\n\t\t\td2 = (bx - x) * (bx - x) + (by - y) * (by - y);\n\t\t\td3 = (ax - x) * (ax - x) + (by - y) * (by - y);\n\t\t\tif (d0 <= d1 && d0 <= d2 && d0 <= d3) {\n\t\t\t\toldx = (ax - oldcmpt->tlx_) / oldcmpt->hstep_;\n\t\t\t\toldy = (ay - oldcmpt->tly_) / oldcmpt->vstep_;\n\t\t\t} else if (d1 <= d0 && d1 <= d2 && d1 <= d3) {\n\t\t\t\toldx = (bx - oldcmpt->tlx_) / oldcmpt->hstep_;\n\t\t\t\toldy = (ay - oldcmpt->tly_) / oldcmpt->vstep_;\n\t\t\t} else if (d2 <= d0 && d2 <= d1 && d1 <= d3) {\n\t\t\t\toldx = (bx - oldcmpt->tlx_) / oldcmpt->hstep_;\n\t\t\t\toldy = (by - oldcmpt->tly_) / oldcmpt->vstep_;\n\t\t\t} else {\n\t\t\t\toldx = (ax - oldcmpt->tlx_) / oldcmpt->hstep_;\n\t\t\t\toldy = (by - oldcmpt->tly_) / oldcmpt->vstep_;\n\t\t\t}\n\t\t\tassert(oldx >= 0 && oldx < oldcmpt->width_ &&\n\t\t\t  oldy >= 0 && oldy < oldcmpt->height_);\n\t\t\tif (jas_stream_seek(oldcmpt->stream_, oldcmpt->cps_ *\n\t\t\t  (oldy * oldcmpt->width_ + oldx), SEEK_SET) < 0)\n\t\t\t\tgoto error;\n\t\t\tif (getint(oldcmpt->stream_, oldcmpt->sgnd_,\n\t\t\t  oldcmpt->prec_, &v))\n\t\t\t\tgoto error;\n\t\t\tif (newcmpt->prec_ != oldcmpt->prec_ ||\n\t\t\t  newcmpt->sgnd_ != oldcmpt->sgnd_) {\n\t\t\t\tv = convert(v, oldcmpt->sgnd_, oldcmpt->prec_,\n\t\t\t\t  newcmpt->sgnd_, newcmpt->prec_);\n\t\t\t}\n\t\t\tif (putint(newcmpt->stream_, newcmpt->sgnd_,\n\t\t\t  newcmpt->prec_, v))\n\t\t\t\tgoto error;\n\t\t}\n\t}\n\treturn 0;\nerror:\n\treturn -1;\n}\n\nint jas_image_ishomosamp(jas_image_t *image)\n{\n\tjas_image_coord_t hstep;\n\tjas_image_coord_t vstep;\n\tint result;\n\tint i;\n\thstep = jas_image_cmpthstep(image, 0);\n\tvstep = jas_image_cmptvstep(image, 0);\n\tresult = 1;\n\tfor (i = 0; i < image->numcmpts_; ++i) {\n\t\tif (jas_image_cmpthstep(image, i) != hstep ||\n\t\t  jas_image_cmptvstep(image, i) != vstep) {\n\t\t\tresult = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn result;\n}\n\n/* Note: This function defines a bounding box differently. */\nstatic void jas_image_calcbbox2(jas_image_t *image, jas_image_coord_t *tlx,\n  jas_image_coord_t *tly, jas_image_coord_t *brx, jas_image_coord_t *bry)\n{\n\tjas_image_cmpt_t *cmpt;\n\tjas_image_coord_t tmptlx;\n\tjas_image_coord_t tmptly;\n\tjas_image_coord_t tmpbrx;\n\tjas_image_coord_t tmpbry;\n\tjas_image_coord_t t;\n\tint i;\n\tif (image->numcmpts_ > 0) {\n\t\tcmpt = image->cmpts_[0];\n\t\ttmptlx = cmpt->tlx_;\n\t\ttmptly = cmpt->tly_;\n\t\ttmpbrx = cmpt->tlx_ + cmpt->hstep_ * (cmpt->width_ - 1);\n\t\ttmpbry = cmpt->tly_ + cmpt->vstep_ * (cmpt->height_ - 1);\n\t\tfor (i = 0; i < image->numcmpts_; ++i) {\n\t\t\tcmpt = image->cmpts_[i];\n\t\t\tif (cmpt->tlx_ < tmptlx)\n\t\t\t\ttmptlx = cmpt->tlx_;\n\t\t\tif (cmpt->tly_ < tmptly)\n\t\t\t\ttmptly = cmpt->tly_;\n\t\t\tt = cmpt->tlx_ + cmpt->hstep_ * (cmpt->width_ - 1);\n\t\t\tif (t > tmpbrx)\n\t\t\t\ttmpbrx = t;\n\t\t\tt = cmpt->tly_ + cmpt->vstep_ * (cmpt->height_ - 1);\n\t\t\tif (t > tmpbry)\n\t\t\t\ttmpbry = t;\n\t\t}\n\t} else {\n\t\ttmptlx = 0;\n\t\ttmptly = 0;\n\t\ttmpbrx = -1;\n\t\ttmpbry = -1;\n\t}\n\t*tlx = tmptlx;\n\t*tly = tmptly;\n\t*brx = tmpbrx;\n\t*bry = tmpbry;\n}\n\nstatic inline long decode_twos_comp(ulong c, int prec)\n{\n\tlong result;\n\tassert(prec >= 2);\n\tjas_eprintf(\"warning: support for signed data is untested\\n\");\n\t// NOTE: Is this correct?\n\tresult = (c & ((1 << (prec - 1)) - 1)) - (c & (1 << (prec - 1)));\n\treturn result;\n}\n\nstatic inline ulong encode_twos_comp(long n, int prec)\n{\n\tulong result;\n\tassert(prec >= 2);\n\tjas_eprintf(\"warning: support for signed data is untested\\n\");\n\t// NOTE: Is this correct?\n\tif (n < 0) {\n\t\tresult = -n;\n\t\tresult = (result ^ 0xffffffffUL) + 1;\n\t\tresult &= (1 << prec) - 1;\n\t} else {\n\t\tresult = n;\n\t}\n\treturn result;\n}\n\nstatic int getint(jas_stream_t *in, int sgnd, int prec, long *val)\n{\n\tlong v;\n\tint n;\n\tint c;\n\tassert((!sgnd && prec >= 1) || (sgnd && prec >= 2));\n\tn = (prec + 7) / 8;\n\tv = 0;\n\twhile (--n >= 0) {\n\t\tif ((c = jas_stream_getc(in)) == EOF)\n\t\t\treturn -1;\n\t\tv = (v << 8) | c;\n\t}\n\tv &= ((1 << prec) - 1);\n\tif (sgnd) {\n\t\t*val = decode_twos_comp(v, prec);\n\t} else {\n\t\t*val = v;\n\t}\n\treturn 0;\n}\n\nstatic int putint(jas_stream_t *out, int sgnd, int prec, long val)\n{\n\tint n;\n\tint c;\n\tbool s;\n\tulong tmp;\n\tassert((!sgnd && prec >= 1) || (sgnd && prec >= 2));\n\tif (sgnd) {\n\t\tval = encode_twos_comp(val, prec);\n\t}\n\tassert(val >= 0);\n\tval &= (1 << prec) - 1;\n\tn = (prec + 7) / 8;\n\twhile (--n >= 0) {\n\t\tc = (val >> (n * 8)) & 0xff;\n\t\tif (jas_stream_putc(out, c) != c)\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic long convert(long val, int oldsgnd, int oldprec, int newsgnd,\n  int newprec)\n{\n\tif (newsgnd != oldsgnd) {\n\t}\n\tif (newprec != oldprec) {\n\t\tif (newprec > oldprec) {\n\t\t\tval <<= newprec - oldprec;\n\t\t} else if (oldprec > newprec) {\n\t\t\tval >>= oldprec - newprec;\n\t\t}\n\t}\n\treturn val;\n}\n\nstatic long downtomult(long x, long y)\n{\n\tassert(x >= 0);\n\treturn (x / y) * y;\n}\n\nstatic long uptomult(long x, long y)\n{\n\tassert(x >= 0);\n\treturn ((x + y - 1) / y) * y;\n}\n\njas_image_t *jas_image_chclrspc(jas_image_t *image, jas_cmprof_t *outprof,\n  int intent)\n{\n\tjas_image_t *inimage;\n\tint minhstep;\n\tint minvstep;\n\tint i;\n\tint j;\n\tint k;\n\tint n;\n\tint hstep;\n\tint vstep;\n\tint numinauxchans;\n\tint numoutauxchans;\n\tint numinclrchans;\n\tint numoutclrchans;\n\tint prec;\n\tjas_image_t *outimage;\n\tint cmpttype;\n\tint numoutchans;\n\tjas_cmprof_t *inprof;\n\tjas_cmprof_t *tmpprof;\n\tjas_image_cmptparm_t cmptparm;\n\tint width;\n\tint height;\n\tjas_cmxform_t *xform;\n\tjas_cmpixmap_t inpixmap;\n\tjas_cmpixmap_t outpixmap;\n\tjas_cmcmptfmt_t *incmptfmts;\n\tjas_cmcmptfmt_t *outcmptfmts;\n\n#if 0\njas_eprintf(\"IMAGE\\n\");\njas_image_dump(image, stderr);\n#endif\n\n\toutimage = 0;\n\txform = 0;\n\tif (!(inimage = jas_image_copy(image)))\n\t\tgoto error;\n\timage = 0;\n\n\tif (!jas_image_ishomosamp(inimage)) {\n\t\tminhstep = jas_image_cmpthstep(inimage, 0);\n\t\tminvstep = jas_image_cmptvstep(inimage, 0);\n\t\tfor (i = 1; i < jas_image_numcmpts(inimage); ++i) {\n\t\t\thstep = jas_image_cmpthstep(inimage, i);\n\t\t\tvstep = jas_image_cmptvstep(inimage, i);\n\t\t\tif (hstep < minhstep) {\n\t\t\t\tminhstep = hstep;\n\t\t\t}\n\t\t\tif (vstep < minvstep) {\n\t\t\t\tminvstep = vstep;\n\t\t\t}\n\t\t}\n\t\tn = jas_image_numcmpts(inimage);\n\t\tfor (i = 0; i < n; ++i) {\n\t\t\tcmpttype = jas_image_cmpttype(inimage, i);\n\t\t\tif (jas_image_sampcmpt(inimage, i, i + 1, 0, 0, minhstep, minvstep,\n\t\t\t  jas_image_cmptsgnd(inimage, i), jas_image_cmptprec(inimage, i))) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tjas_image_setcmpttype(inimage, i + 1, cmpttype);\n\t\t\tjas_image_delcmpt(inimage, i);\n\t\t}\n\t}\n\n\twidth = jas_image_cmptwidth(inimage, 0);\n\theight = jas_image_cmptheight(inimage, 0);\n\thstep = jas_image_cmpthstep(inimage, 0);\n\tvstep = jas_image_cmptvstep(inimage, 0);\n\n\tif (!(inprof = jas_image_cmprof(inimage))) {\n\t\tabort();\n\t}\n\tnuminclrchans = jas_clrspc_numchans(jas_cmprof_clrspc(inprof));\n\tnuminauxchans = jas_image_numcmpts(inimage) - numinclrchans;\n\tnumoutclrchans = jas_clrspc_numchans(jas_cmprof_clrspc(outprof));\n\tnumoutauxchans = 0;\n\tnumoutchans = numoutclrchans + numoutauxchans;\n\tprec = 8;\n\n\tif (!(outimage = jas_image_create0())) {\n\t\tgoto error;\n\t}\n\n\t/* Create a component for each of the colorants. */\n\tfor (i = 0; i < numoutclrchans; ++i) {\n\t\tcmptparm.tlx = 0;\n\t\tcmptparm.tly = 0;\n\t\tcmptparm.hstep = hstep;\n\t\tcmptparm.vstep = vstep;\n\t\tcmptparm.width = width;\n\t\tcmptparm.height = height;\n\t\tcmptparm.prec = prec;\n\t\tcmptparm.sgnd = 0;\n\t\tif (jas_image_addcmpt(outimage, -1, &cmptparm))\n\t\t\tgoto error;\n\t\tjas_image_setcmpttype(outimage, i, JAS_IMAGE_CT_COLOR(i));\n\t}\n#if 0\n\t/* Copy the auxiliary components without modification. */\n\tfor (i = 0; i < jas_image_numcmpts(inimage); ++i) {\n\t\tif (!ISCOLOR(jas_image_cmpttype(inimage, i))) {\n\t\t\tjas_image_copycmpt(outimage, -1, inimage, i);\n/* XXX - need to specify laydown of component on ref. grid */\n\t\t}\n\t}\n#endif\n\n\tif (!(tmpprof = jas_cmprof_copy(outprof)))\n\t\tgoto error;\n\tassert(!jas_image_cmprof(outimage));\n\tjas_image_setcmprof(outimage, tmpprof);\n\ttmpprof = 0;\n\tjas_image_setclrspc(outimage, jas_cmprof_clrspc(outprof));\n\n\tif (!(xform = jas_cmxform_create(inprof, outprof, 0, JAS_CMXFORM_OP_FWD,\n\t  intent, 0))) {\n\t\tgoto error;\n\t}\n\n\tinpixmap.numcmpts = numinclrchans;\n\tif (!(incmptfmts = jas_alloc2(numinclrchans, sizeof(jas_cmcmptfmt_t)))) {\n\t\tabort();\n\t}\n\tinpixmap.cmptfmts = incmptfmts;\n\tfor (i = 0; i < numinclrchans; ++i) {\n\t\tj = jas_image_getcmptbytype(inimage, JAS_IMAGE_CT_COLOR(i));\n\t\tassert(j >= 0);\n\t\tif (!(incmptfmts[i].buf = jas_alloc2(width, sizeof(long)))) {\n\t\t\tgoto error;\n\t\t}\n\t\tincmptfmts[i].prec = jas_image_cmptprec(inimage, j);\n\t\tincmptfmts[i].sgnd = jas_image_cmptsgnd(inimage, j);\n\t\tincmptfmts[i].width = width;\n\t\tincmptfmts[i].height = 1;\n\t}\n\n\toutpixmap.numcmpts = numoutclrchans;\n\tif (!(outcmptfmts = jas_alloc2(numoutclrchans, sizeof(jas_cmcmptfmt_t)))) {\n\t\tabort();\n\t}\n\toutpixmap.cmptfmts = outcmptfmts;\n\n\tfor (i = 0; i < numoutclrchans; ++i) {\n\t\tj = jas_image_getcmptbytype(outimage, JAS_IMAGE_CT_COLOR(i));\n\t\tassert(j >= 0);\n\t\tif (!(outcmptfmts[i].buf = jas_alloc2(width, sizeof(long))))\n\t\t\tgoto error;\n\t\toutcmptfmts[i].prec = jas_image_cmptprec(outimage, j);\n\t\toutcmptfmts[i].sgnd = jas_image_cmptsgnd(outimage, j);\n\t\toutcmptfmts[i].width = width;\n\t\toutcmptfmts[i].height = 1;\n\t}\n\n\tfor (i = 0; i < height; ++i) {\n\t\tfor (j = 0; j < numinclrchans; ++j) {\n\t\t\tk = jas_image_getcmptbytype(inimage, JAS_IMAGE_CT_COLOR(j));\n\t\t\tif (jas_image_readcmpt2(inimage, k, 0, i, width, 1,\n\t\t\t  incmptfmts[j].buf))\n\t\t\t\tgoto error;\n\t\t}\n\t\tjas_cmxform_apply(xform, &inpixmap, &outpixmap);\n\t\tfor (j = 0; j < numoutclrchans; ++j) {\n\t\t\tk = jas_image_getcmptbytype(outimage, JAS_IMAGE_CT_COLOR(j));\n\t\t\tif (jas_image_writecmpt2(outimage, k, 0, i, width, 1,\n\t\t\t  outcmptfmts[j].buf))\n\t\t\t\tgoto error;\n\t\t}\n\t}\n\n\tfor (i = 0; i < numoutclrchans; ++i) {\n\t\tjas_free(outcmptfmts[i].buf);\n\t}\n\tjas_free(outcmptfmts);\n\tfor (i = 0; i < numinclrchans; ++i) {\n\t\tjas_free(incmptfmts[i].buf);\n\t}\n\tjas_free(incmptfmts);\n\tjas_cmxform_destroy(xform);\n\tjas_image_destroy(inimage);\n\n#if 0\njas_eprintf(\"INIMAGE\\n\");\njas_image_dump(inimage, stderr);\njas_eprintf(\"OUTIMAGE\\n\");\njas_image_dump(outimage, stderr);\n#endif\n\treturn outimage;\nerror:\n\tif (xform)\n\t\tjas_cmxform_destroy(xform);\n\tif (inimage)\n\t\tjas_image_destroy(inimage);\n\tif (outimage)\n\t\tjas_image_destroy(outimage);\n\treturn 0;\n}\n", "/*\n * Copyright (c) 1999-2000 Image Power, Inc. and the University of\n *   British Columbia.\n * Copyright (c) 2001-2003 Michael David Adams.\n * All rights reserved.\n */\n\n/* __START_OF_JASPER_LICENSE__\n * \n * JasPer License Version 2.0\n * \n * Copyright (c) 2001-2006 Michael David Adams\n * Copyright (c) 1999-2000 Image Power, Inc.\n * Copyright (c) 1999-2000 The University of British Columbia\n * \n * All rights reserved.\n * \n * Permission is hereby granted, free of charge, to any person (the\n * \"User\") obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n * \n * 1.  The above copyright notices and this permission notice (which\n * includes the disclaimer below) shall be included in all copies or\n * substantial portions of the Software.\n * \n * 2.  The name of a copyright holder shall not be used to endorse or\n * promote products derived from the Software without specific prior\n * written permission.\n * \n * THIS DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS\n * LICENSE.  NO USE OF THE SOFTWARE IS AUTHORIZED HEREUNDER EXCEPT UNDER\n * THIS DISCLAIMER.  THE SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS\n * \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.  IN NO\n * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL\n * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING\n * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\n * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION\n * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  NO ASSURANCES ARE\n * PROVIDED BY THE COPYRIGHT HOLDERS THAT THE SOFTWARE DOES NOT INFRINGE\n * THE PATENT OR OTHER INTELLECTUAL PROPERTY RIGHTS OF ANY OTHER ENTITY.\n * EACH COPYRIGHT HOLDER DISCLAIMS ANY LIABILITY TO THE USER FOR CLAIMS\n * BROUGHT BY ANY OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL\n * PROPERTY RIGHTS OR OTHERWISE.  AS A CONDITION TO EXERCISING THE RIGHTS\n * GRANTED HEREUNDER, EACH USER HEREBY ASSUMES SOLE RESPONSIBILITY TO SECURE\n * ANY OTHER INTELLECTUAL PROPERTY RIGHTS NEEDED, IF ANY.  THE SOFTWARE\n * IS NOT FAULT-TOLERANT AND IS NOT INTENDED FOR USE IN MISSION-CRITICAL\n * SYSTEMS, SUCH AS THOSE USED IN THE OPERATION OF NUCLEAR FACILITIES,\n * AIRCRAFT NAVIGATION OR COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL\n * SYSTEMS, DIRECT LIFE SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH\n * THE FAILURE OF THE SOFTWARE OR SYSTEM COULD LEAD DIRECTLY TO DEATH,\n * PERSONAL INJURY, OR SEVERE PHYSICAL OR ENVIRONMENTAL DAMAGE (\"HIGH\n * RISK ACTIVITIES\").  THE COPYRIGHT HOLDERS SPECIFICALLY DISCLAIM ANY\n * EXPRESS OR IMPLIED WARRANTY OF FITNESS FOR HIGH RISK ACTIVITIES.\n * \n * __END_OF_JASPER_LICENSE__\n */\n\n/*\n * I/O Stream Library\n *\n * $Id$\n */\n\n/******************************************************************************\\\n* Includes.\n\\******************************************************************************/\n\n#include <assert.h>\n#if defined(HAVE_FCNTL_H)\n#include <fcntl.h>\n#endif\n#include <stdlib.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <ctype.h>\n#if defined(HAVE_UNISTD_H)\n#include <unistd.h>\n#endif\n#if defined(WIN32) || defined(HAVE_IO_H)\n#include <io.h>\n#endif\n\n#include \"jasper/jas_debug.h\"\n#include \"jasper/jas_types.h\"\n#include \"jasper/jas_stream.h\"\n#include \"jasper/jas_malloc.h\"\n#include \"jasper/jas_math.h\"\n\n/******************************************************************************\\\n* Local function prototypes.\n\\******************************************************************************/\n\nstatic int jas_strtoopenmode(const char *s);\nstatic void jas_stream_destroy(jas_stream_t *stream);\nstatic jas_stream_t *jas_stream_create(void);\nstatic void jas_stream_initbuf(jas_stream_t *stream, int bufmode, char *buf,\n  int bufsize);\n\nstatic int mem_read(jas_stream_obj_t *obj, char *buf, int cnt);\nstatic int mem_write(jas_stream_obj_t *obj, char *buf, int cnt);\nstatic long mem_seek(jas_stream_obj_t *obj, long offset, int origin);\nstatic int mem_close(jas_stream_obj_t *obj);\n\nstatic int sfile_read(jas_stream_obj_t *obj, char *buf, int cnt);\nstatic int sfile_write(jas_stream_obj_t *obj, char *buf, int cnt);\nstatic long sfile_seek(jas_stream_obj_t *obj, long offset, int origin);\nstatic int sfile_close(jas_stream_obj_t *obj);\n\nstatic int file_read(jas_stream_obj_t *obj, char *buf, int cnt);\nstatic int file_write(jas_stream_obj_t *obj, char *buf, int cnt);\nstatic long file_seek(jas_stream_obj_t *obj, long offset, int origin);\nstatic int file_close(jas_stream_obj_t *obj);\n\n/******************************************************************************\\\n* Local data.\n\\******************************************************************************/\n\nstatic jas_stream_ops_t jas_stream_fileops = {\n\tfile_read,\n\tfile_write,\n\tfile_seek,\n\tfile_close\n};\n\nstatic jas_stream_ops_t jas_stream_sfileops = {\n\tsfile_read,\n\tsfile_write,\n\tsfile_seek,\n\tsfile_close\n};\n\nstatic jas_stream_ops_t jas_stream_memops = {\n\tmem_read,\n\tmem_write,\n\tmem_seek,\n\tmem_close\n};\n\n/******************************************************************************\\\n* Code for opening and closing streams.\n\\******************************************************************************/\n\nstatic jas_stream_t *jas_stream_create()\n{\n\tjas_stream_t *stream;\n\n\tif (!(stream = jas_malloc(sizeof(jas_stream_t)))) {\n\t\treturn 0;\n\t}\n\tstream->openmode_ = 0;\n\tstream->bufmode_ = 0;\n\tstream->flags_ = 0;\n\tstream->bufbase_ = 0;\n\tstream->bufstart_ = 0;\n\tstream->bufsize_ = 0;\n\tstream->ptr_ = 0;\n\tstream->cnt_ = 0;\n\tstream->ops_ = 0;\n\tstream->obj_ = 0;\n\tstream->rwcnt_ = 0;\n\tstream->rwlimit_ = -1;\n\n\treturn stream;\n}\n\n#if 0\n\n/* Obsolete code. */\n\njas_stream_t *jas_stream_memopen(char *buf, int bufsize)\n{\n\tjas_stream_t *stream;\n\tjas_stream_memobj_t *obj;\n\n\tJAS_DBGLOG(100, (\"jas_stream_memopen(%p, %d)\\n\", buf, bufsize));\n\n\tif (!(stream = jas_stream_create())) {\n\t\treturn 0;\n\t}\n\n\t/* A stream associated with a memory buffer is always opened\n\tfor both reading and writing in binary mode. */\n\tstream->openmode_ = JAS_STREAM_READ | JAS_STREAM_WRITE | JAS_STREAM_BINARY;\n\n\t/* Since the stream data is already resident in memory, buffering\n\tis not necessary. */\n\t/* But... It still may be faster to use buffering anyways. */\n\tjas_stream_initbuf(stream, JAS_STREAM_FULLBUF, 0, 0);\n\n\t/* Select the operations for a memory stream. */\n\tstream->ops_ = &jas_stream_memops;\n\n\t/* Allocate memory for the underlying memory stream object. */\n\tif (!(obj = jas_malloc(sizeof(jas_stream_memobj_t)))) {\n\t\tjas_stream_destroy(stream);\n\t\treturn 0;\n\t}\n\tstream->obj_ = (void *) obj;\n\n\t/* Initialize a few important members of the memory stream object. */\n\tobj->myalloc_ = 0;\n\tobj->buf_ = 0;\n\n\t/* If the buffer size specified is nonpositive, then the buffer\n\tis allocated internally and automatically grown as needed. */\n\tif (bufsize <= 0) {\n\t\tobj->bufsize_ = 1024;\n\t\tobj->growable_ = 1;\n\t} else {\n\t\tobj->bufsize_ = bufsize;\n\t\tobj->growable_ = 0;\n\t}\n\tif (buf) {\n\t\tobj->buf_ = (unsigned char *) buf;\n\t} else {\n\t\tobj->buf_ = jas_malloc(obj->bufsize_);\n\t\tobj->myalloc_ = 1;\n\t}\n\tif (!obj->buf_) {\n\t\tjas_stream_close(stream);\n\t\treturn 0;\n\t}\n\tJAS_DBGLOG(100, (\"jas_stream_memopen buffer buf=%p myalloc=%d\\n\",\n\t  obj->buf_, obj->myalloc_));\n\n\tif (bufsize > 0 && buf) {\n\t\t/* If a buffer was supplied by the caller and its length is positive,\n\t\t  make the associated buffer data appear in the stream initially. */\n\t\tobj->len_ = bufsize;\n\t} else {\n\t\t/* The stream is initially empty. */\n\t\tobj->len_ = 0;\n\t}\n\tobj->pos_ = 0;\n\t\n\treturn stream;\n}\n\n#else\n\n/*\nThis function will eventually replace jas_stream_memopen.\nIf buf is 0 and bufsize > 0:\n\ta buffer is dynamically allocated with size bufsize and this buffer is\n\tnot growable.\nIf buf is 0 and bufsize is 0:\n\ta buffer is dynamically allocated whose size will automatically grow to\n\taccommodate the amount of data written.\nIf buf is not 0:\n\tbufsize (which, in this case, is not currently allowed to be zero) is\n\tthe size of the (nongrowable) buffer pointed to by buf.\n*/\n\njas_stream_t *jas_stream_memopen2(char *buf, size_t bufsize)\n{\n\tjas_stream_t *stream;\n\tjas_stream_memobj_t *obj;\n\n\tJAS_DBGLOG(100, (\"jas_stream_memopen2(%p, %zu)\\n\", buf, bufsize));\n\n\tassert((buf && bufsize > 0) || (!buf));\n\n\tif (!(stream = jas_stream_create())) {\n\t\treturn 0;\n\t}\n\n\t/* A stream associated with a memory buffer is always opened\n\tfor both reading and writing in binary mode. */\n\tstream->openmode_ = JAS_STREAM_READ | JAS_STREAM_WRITE | JAS_STREAM_BINARY;\n\n\t/* Since the stream data is already resident in memory, buffering\n\tis not necessary. */\n\t/* But... It still may be faster to use buffering anyways. */\n\tjas_stream_initbuf(stream, JAS_STREAM_FULLBUF, 0, 0);\n\n\t/* Select the operations for a memory stream. */\n\tstream->ops_ = &jas_stream_memops;\n\n\t/* Allocate memory for the underlying memory stream object. */\n\tif (!(obj = jas_malloc(sizeof(jas_stream_memobj_t)))) {\n\t\tjas_stream_destroy(stream);\n\t\treturn 0;\n\t}\n\tstream->obj_ = (void *) obj;\n\n\t/* Initialize a few important members of the memory stream object. */\n\tobj->myalloc_ = 0;\n\tobj->buf_ = 0;\n\n\t/* If the buffer size specified is nonpositive, then the buffer\n\tis allocated internally and automatically grown as needed. */\n\tif (!bufsize) {\n\t\tobj->bufsize_ = 1024;\n\t\tobj->growable_ = 1;\n\t} else {\n\t\tobj->bufsize_ = bufsize;\n\t\tobj->growable_ = 0;\n\t}\n\tif (buf) {\n\t\tobj->buf_ = JAS_CAST(unsigned char *, buf);\n\t} else {\n\t\tobj->buf_ = jas_malloc(obj->bufsize_);\n\t\tobj->myalloc_ = 1;\n\t}\n\tif (!obj->buf_) {\n\t\tjas_stream_close(stream);\n\t\treturn 0;\n\t}\n\tJAS_DBGLOG(100, (\"jas_stream_memopen2 buffer buf=%p myalloc=%d\\n\",\n\t  obj->buf_, obj->myalloc_));\n\n\tif (bufsize > 0 && buf) {\n\t\t/* If a buffer was supplied by the caller and its length is positive,\n\t\t  make the associated buffer data appear in the stream initially. */\n\t\tobj->len_ = bufsize;\n\t} else {\n\t\t/* The stream is initially empty. */\n\t\tobj->len_ = 0;\n\t}\n\tobj->pos_ = 0;\n\t\n\treturn stream;\n}\n\n/*\nNOTE:\nThe version of the function jas_stream_memopen only exists for backwards\ncompatibility.\nEventually, it should be replaced by jas_stream_memopen2.\nIn retrospect, it was a very poor choice to have specified the buffer\nsize parameter (bufsize) to have type int.  On some machines, int may only\nbe a 16-bit integer.  This precludes larger-sized buffer allocations, which\nare needed in practice.\n\nIf bufsize <= 0, the buffer is growable; otherwise, the buffer has a fixed\nsize of bufsize.\nIf buf is 0, the buffer is dynamically allocated with jas_malloc.\nIf buf is not 0 and bufsize <= 0 (which is not permitted in any\ncircumstances), bad things will happen (especially if the buf was not\nallocated with jas_malloc).\n*/\njas_stream_t *jas_stream_memopen(char *buf, int bufsize)\n{\n\tchar *new_buf;\n\tsize_t new_bufsize;\n\n\tJAS_DBGLOG(100, (\"jas_stream_memopen(%p, %d)\\n\", buf, bufsize));\n\tif (bufsize < 0) {\n\t\tjas_deprecated(\"negative buffer size for jas_stream_memopen\");\n\t}\n\tif (buf && bufsize <= 0) {\n\t\t// This was never a valid thing to do with the old API.\n\t\tjas_eprintf(\"Invalid use of jas_stream_memopen detected.\\n\");\n\t\tjas_deprecated(\"A user-provided buffer for \"\n\t\t  \"jas_stream_memopen cannot be growable.\\n\");\n\t}\n\tif (bufsize <= 0) {\n\t\tnew_bufsize = 0;\n\t\tnew_buf = 0;\n\t} else {\n\t\tnew_bufsize = bufsize;\n\t\tnew_buf = buf;\n\t}\n\treturn jas_stream_memopen2(new_buf, new_bufsize);\n}\n\n#endif\n\njas_stream_t *jas_stream_fopen(const char *filename, const char *mode)\n{\n\tjas_stream_t *stream;\n\tjas_stream_fileobj_t *obj;\n\tint openflags;\n\n\t/* Allocate a stream object. */\n\tif (!(stream = jas_stream_create())) {\n\t\treturn 0;\n\t}\n\n\t/* Parse the mode string. */\n\tstream->openmode_ = jas_strtoopenmode(mode);\n\n\t/* Determine the correct flags to use for opening the file. */\n\tif ((stream->openmode_ & JAS_STREAM_READ) &&\n\t  (stream->openmode_ & JAS_STREAM_WRITE)) {\n\t\topenflags = O_RDWR;\n\t} else if (stream->openmode_ & JAS_STREAM_READ) {\n\t\topenflags = O_RDONLY;\n\t} else if (stream->openmode_ & JAS_STREAM_WRITE) {\n\t\topenflags = O_WRONLY;\n\t} else {\n\t\topenflags = 0;\n\t}\n\tif (stream->openmode_ & JAS_STREAM_APPEND) {\n\t\topenflags |= O_APPEND;\n\t}\n\tif (stream->openmode_ & JAS_STREAM_BINARY) {\n\t\topenflags |= O_BINARY;\n\t}\n\tif (stream->openmode_ & JAS_STREAM_CREATE) {\n\t\topenflags |= O_CREAT | O_TRUNC;\n\t}\n\n\t/* Allocate space for the underlying file stream object. */\n\tif (!(obj = jas_malloc(sizeof(jas_stream_fileobj_t)))) {\n\t\tjas_stream_destroy(stream);\n\t\treturn 0;\n\t}\n\tobj->fd = -1;\n\tobj->flags = 0;\n\tobj->pathname[0] = '\\0';\n\tstream->obj_ = (void *) obj;\n\n\t/* Select the operations for a file stream object. */\n\tstream->ops_ = &jas_stream_fileops;\n\n\t/* Open the underlying file. */\n\tif ((obj->fd = open(filename, openflags, JAS_STREAM_PERMS)) < 0) {\n\t\t// Free the underlying file object, since it will not otherwise\n\t\t// be freed.\n\t\tjas_free(obj);\n\t\tjas_stream_destroy(stream);\n\t\treturn 0;\n\t}\n\n\t/* By default, use full buffering for this type of stream. */\n\tjas_stream_initbuf(stream, JAS_STREAM_FULLBUF, 0, 0);\n\n\treturn stream;\n}\n\njas_stream_t *jas_stream_freopen(const char *path, const char *mode, FILE *fp)\n{\n\tjas_stream_t *stream;\n\tint openflags;\n\n\t/* Eliminate compiler warning about unused variable. */\n\tpath = 0;\n\n\t/* Allocate a stream object. */\n\tif (!(stream = jas_stream_create())) {\n\t\treturn 0;\n\t}\n\n\t/* Parse the mode string. */\n\tstream->openmode_ = jas_strtoopenmode(mode);\n\n\t/* Determine the correct flags to use for opening the file. */\n\tif ((stream->openmode_ & JAS_STREAM_READ) &&\n\t  (stream->openmode_ & JAS_STREAM_WRITE)) {\n\t\topenflags = O_RDWR;\n\t} else if (stream->openmode_ & JAS_STREAM_READ) {\n\t\topenflags = O_RDONLY;\n\t} else if (stream->openmode_ & JAS_STREAM_WRITE) {\n\t\topenflags = O_WRONLY;\n\t} else {\n\t\topenflags = 0;\n\t}\n\tif (stream->openmode_ & JAS_STREAM_APPEND) {\n\t\topenflags |= O_APPEND;\n\t}\n\tif (stream->openmode_ & JAS_STREAM_BINARY) {\n\t\topenflags |= O_BINARY;\n\t}\n\tif (stream->openmode_ & JAS_STREAM_CREATE) {\n\t\topenflags |= O_CREAT | O_TRUNC;\n\t}\n\n\tstream->obj_ = JAS_CAST(void *, fp);\n\n\t/* Select the operations for a file stream object. */\n\tstream->ops_ = &jas_stream_sfileops;\n\n\t/* By default, use full buffering for this type of stream. */\n\tjas_stream_initbuf(stream, JAS_STREAM_FULLBUF, 0, 0);\n\n\treturn stream;\n}\n\njas_stream_t *jas_stream_tmpfile()\n{\n\tjas_stream_t *stream;\n\tjas_stream_fileobj_t *obj;\n\n\tif (!(stream = jas_stream_create())) {\n\t\treturn 0;\n\t}\n\n\t/* A temporary file stream is always opened for both reading and\n\twriting in binary mode. */\n\tstream->openmode_ = JAS_STREAM_READ | JAS_STREAM_WRITE | JAS_STREAM_BINARY;\n\n\t/* Allocate memory for the underlying temporary file object. */\n\tif (!(obj = jas_malloc(sizeof(jas_stream_fileobj_t)))) {\n\t\tjas_stream_destroy(stream);\n\t\treturn 0;\n\t}\n\tobj->fd = -1;\n\tobj->flags = 0;\n\tobj->pathname[0] = '\\0';\n\tstream->obj_ = obj;\n\n\t/* Choose a file name. */\n\ttmpnam(obj->pathname);\n\n\t/* Open the underlying file. */\n\tif ((obj->fd = open(obj->pathname, O_CREAT | O_EXCL | O_RDWR | O_TRUNC | O_BINARY,\n\t  JAS_STREAM_PERMS)) < 0) {\n\t\tjas_stream_destroy(stream);\n\t\treturn 0;\n\t}\n\n\t/* Unlink the file so that it will disappear if the program\n\tterminates abnormally. */\n\t/* Under UNIX, one can unlink an open file and continue to do I/O\n\ton it.  Not all operating systems support this functionality, however.\n\tFor example, under Microsoft Windows the unlink operation will fail,\n\tsince the file is open. */\n\tif (unlink(obj->pathname)) {\n\t\t/* We will try unlinking the file again after it is closed. */\n\t\tobj->flags |= JAS_STREAM_FILEOBJ_DELONCLOSE;\n\t}\n\n\t/* Use full buffering. */\n\tjas_stream_initbuf(stream, JAS_STREAM_FULLBUF, 0, 0);\n\n\tstream->ops_ = &jas_stream_fileops;\n\n\treturn stream;\n}\n\njas_stream_t *jas_stream_fdopen(int fd, const char *mode)\n{\n\tjas_stream_t *stream;\n\tjas_stream_fileobj_t *obj;\n\n\t/* Allocate a stream object. */\n\tif (!(stream = jas_stream_create())) {\n\t\treturn 0;\n\t}\n\n\t/* Parse the mode string. */\n\tstream->openmode_ = jas_strtoopenmode(mode);\n\n#if defined(WIN32)\n\t/* Argh!!!  Someone ought to banish text mode (i.e., O_TEXT) to the\n\t  greatest depths of purgatory! */\n\t/* Ensure that the file descriptor is in binary mode, if the caller\n\t  has specified the binary mode flag.  Arguably, the caller ought to\n\t  take care of this, but text mode is a ugly wart anyways, so we save\n\t  the caller some grief by handling this within the stream library. */\n\t/* This ugliness is mainly for the benefit of those who run the\n\t  JasPer software under Windows from shells that insist on opening\n\t  files in text mode.  For example, in the Cygwin environment,\n\t  shells often open files in text mode when I/O redirection is\n\t  used.  Grr... */\n\tif (stream->openmode_ & JAS_STREAM_BINARY) {\n\t\tsetmode(fd, O_BINARY);\n\t}\n#endif\n\n\t/* Allocate space for the underlying file stream object. */\n\tif (!(obj = jas_malloc(sizeof(jas_stream_fileobj_t)))) {\n\t\tjas_stream_destroy(stream);\n\t\treturn 0;\n\t}\n\tobj->fd = fd;\n\tobj->flags = 0;\n\tobj->pathname[0] = '\\0';\n\tstream->obj_ = (void *) obj;\n\n\t/* Do not close the underlying file descriptor when the stream is\n\tclosed. */\n\tobj->flags |= JAS_STREAM_FILEOBJ_NOCLOSE;\n\n\t/* By default, use full buffering for this type of stream. */\n\tjas_stream_initbuf(stream, JAS_STREAM_FULLBUF, 0, 0);\n\n\t/* Select the operations for a file stream object. */\n\tstream->ops_ = &jas_stream_fileops;\n\n\treturn stream;\n}\n\nstatic void jas_stream_destroy(jas_stream_t *stream)\n{\n\t/* If the memory for the buffer was allocated with malloc, free\n\tthis memory. */\n\tif ((stream->bufmode_ & JAS_STREAM_FREEBUF) && stream->bufbase_) {\n\t\tJAS_DBGLOG(100, (\"jas_stream_destroy freeing buffer %p\\n\",\n\t\t  stream->bufbase_));\n\t\tjas_free(stream->bufbase_);\n\t\tstream->bufbase_ = 0;\n\t}\n\tjas_free(stream);\n}\n\nint jas_stream_close(jas_stream_t *stream)\n{\n\t/* Flush buffer if necessary. */\n\tjas_stream_flush(stream);\n\n\t/* Close the underlying stream object. */\n\t(*stream->ops_->close_)(stream->obj_);\n\n\tjas_stream_destroy(stream);\n\n\treturn 0;\n}\n\n/******************************************************************************\\\n* Code for reading and writing streams.\n\\******************************************************************************/\n\nint jas_stream_getc_func(jas_stream_t *stream)\n{\n\tassert(stream->ptr_ - stream->bufbase_ <= stream->bufsize_ +\n\t  JAS_STREAM_MAXPUTBACK);\n\treturn jas_stream_getc_macro(stream);\n}\n\nint jas_stream_putc_func(jas_stream_t *stream, int c)\n{\n\tassert(stream->ptr_ - stream->bufstart_ <= stream->bufsize_);\n\treturn jas_stream_putc_macro(stream, c);\n}\n\nint jas_stream_ungetc(jas_stream_t *stream, int c)\n{\n\tif (!stream->ptr_ || stream->ptr_ == stream->bufbase_) {\n\t\treturn -1;\n\t}\n\n\t/* Reset the EOF indicator (since we now have at least one character\n\t  to read). */\n\tstream->flags_ &= ~JAS_STREAM_EOF;\n\n\t--stream->rwcnt_;\n\t--stream->ptr_;\n\t++stream->cnt_;\n\t*stream->ptr_ = c;\n\treturn 0;\n}\n\nint jas_stream_read(jas_stream_t *stream, void *buf, int cnt)\n{\n\tint n;\n\tint c;\n\tchar *bufptr;\n\n\tif (cnt < 0) {\n\t\tjas_deprecated(\"negative count for jas_stream_read\");\n\t}\n\n\tbufptr = buf;\n\n\tn = 0;\n\twhile (n < cnt) {\n\t\tif ((c = jas_stream_getc(stream)) == EOF) {\n\t\t\treturn n;\n\t\t}\n\t\t*bufptr++ = c;\n\t\t++n;\n\t}\n\n\treturn n;\n}\n\nint jas_stream_write(jas_stream_t *stream, const void *buf, int cnt)\n{\n\tint n;\n\tconst char *bufptr;\n\n\tif (cnt < 0) {\n\t\tjas_deprecated(\"negative count for jas_stream_write\");\n\t}\n\n\tbufptr = buf;\n\n\tn = 0;\n\twhile (n < cnt) {\n\t\tif (jas_stream_putc(stream, *bufptr) == EOF) {\n\t\t\treturn n;\n\t\t}\n\t\t++bufptr;\n\t\t++n;\n\t}\n\n\treturn n;\n}\n\n/* Note: This function uses a fixed size buffer.  Therefore, it cannot\n  handle invocations that will produce more output than can be held\n  by the buffer. */\nint jas_stream_printf(jas_stream_t *stream, const char *fmt, ...)\n{\n\tva_list ap;\n\tchar buf[4096];\n\tint ret;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(buf, sizeof buf, fmt, ap);\n\tjas_stream_puts(stream, buf);\n\tva_end(ap);\n\treturn ret;\n}\n\nint jas_stream_puts(jas_stream_t *stream, const char *s)\n{\n\twhile (*s != '\\0') {\n\t\tif (jas_stream_putc_macro(stream, *s) == EOF) {\n\t\t\treturn -1;\n\t\t}\n\t\t++s;\n\t}\n\treturn 0;\n}\n\nchar *jas_stream_gets(jas_stream_t *stream, char *buf, int bufsize)\n{\n\tint c;\n\tchar *bufptr;\n\tassert(bufsize > 0);\n\n\tbufptr = buf;\n\twhile (bufsize > 1) {\n\t\tif ((c = jas_stream_getc(stream)) == EOF) {\n\t\t\tbreak;\n\t\t}\n\t\t*bufptr++ = c;\n\t\t--bufsize;\n\t\tif (c == '\\n') {\n\t\t\tbreak;\n\t\t}\n\t}\n\t*bufptr = '\\0';\n\treturn buf;\n}\n\nint jas_stream_gobble(jas_stream_t *stream, int n)\n{\n\tint m;\n\tif (n < 0) {\n\t\tjas_deprecated(\"negative count for jas_stream_gobble\");\n\t}\n\tm = n;\n\tfor (m = n; m > 0; --m) {\n\t\tif (jas_stream_getc(stream) == EOF) {\n\t\t\treturn n - m;\n\t\t}\n\t}\n\treturn n;\n}\n\nint jas_stream_pad(jas_stream_t *stream, int n, int c)\n{\n\tint m;\n\tif (n < 0) {\n\t\tjas_deprecated(\"negative count for jas_stream_pad\");\n\t}\n\tm = n;\n\tfor (m = n; m > 0; --m) {\n\t\tif (jas_stream_putc(stream, c) == EOF)\n\t\t\treturn n - m;\n\t}\n\treturn n;\n}\n\n/******************************************************************************\\\n* Code for getting and setting the stream position.\n\\******************************************************************************/\n\nint jas_stream_isseekable(jas_stream_t *stream)\n{\n\tif (stream->ops_ == &jas_stream_memops) {\n\t\treturn 1;\n\t} else if (stream->ops_ == &jas_stream_fileops) {\n\t\tif ((*stream->ops_->seek_)(stream->obj_, 0, SEEK_CUR) < 0) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nint jas_stream_rewind(jas_stream_t *stream)\n{\n\treturn jas_stream_seek(stream, 0, SEEK_SET);\n}\n\nlong jas_stream_seek(jas_stream_t *stream, long offset, int origin)\n{\n\tlong newpos;\n\n\t/* The buffer cannot be in use for both reading and writing. */\n\tassert(!((stream->bufmode_ & JAS_STREAM_RDBUF) && (stream->bufmode_ &\n\t  JAS_STREAM_WRBUF)));\n\n\t/* Reset the EOF indicator (since we may not be at the EOF anymore). */\n\tstream->flags_ &= ~JAS_STREAM_EOF;\n\n\tif (stream->bufmode_ & JAS_STREAM_RDBUF) {\n\t\tif (origin == SEEK_CUR) {\n\t\t\toffset -= stream->cnt_;\n\t\t}\n\t} else if (stream->bufmode_ & JAS_STREAM_WRBUF) {\n\t\tif (jas_stream_flush(stream)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tstream->cnt_ = 0;\n\tstream->ptr_ = stream->bufstart_;\n\tstream->bufmode_ &= ~(JAS_STREAM_RDBUF | JAS_STREAM_WRBUF);\n\n\tif ((newpos = (*stream->ops_->seek_)(stream->obj_, offset, origin))\n\t  < 0) {\n\t\treturn -1;\n\t}\n\n\treturn newpos;\n}\n\nlong jas_stream_tell(jas_stream_t *stream)\n{\n\tint adjust;\n\tint offset;\n\n\tif (stream->bufmode_ & JAS_STREAM_RDBUF) {\n\t\tadjust = -stream->cnt_;\n\t} else if (stream->bufmode_ & JAS_STREAM_WRBUF) {\n\t\tadjust = stream->ptr_ - stream->bufstart_;\n\t} else {\n\t\tadjust = 0;\n\t}\n\n\tif ((offset = (*stream->ops_->seek_)(stream->obj_, 0, SEEK_CUR)) < 0) {\n\t\treturn -1;\n\t}\n\n\treturn offset + adjust;\n}\n\n/******************************************************************************\\\n* Buffer initialization code.\n\\******************************************************************************/\n\nstatic void jas_stream_initbuf(jas_stream_t *stream, int bufmode, char *buf,\n  int bufsize)\n{\n\t/* If this function is being called, the buffer should not have been\n\t  initialized yet. */\n\tassert(!stream->bufbase_);\n\n\tif (bufmode != JAS_STREAM_UNBUF) {\n\t\t/* The full- or line-buffered mode is being employed. */\n\t\tif (!buf) {\n\t\t\t/* The caller has not specified a buffer to employ, so allocate\n\t\t\t  one. */\n\t\t\tif ((stream->bufbase_ = jas_malloc(JAS_STREAM_BUFSIZE +\n\t\t\t  JAS_STREAM_MAXPUTBACK))) {\n\t\t\t\tstream->bufmode_ |= JAS_STREAM_FREEBUF;\n\t\t\t\tstream->bufsize_ = JAS_STREAM_BUFSIZE;\n\t\t\t} else {\n\t\t\t\t/* The buffer allocation has failed.  Resort to unbuffered\n\t\t\t\t  operation. */\n\t\t\t\tstream->bufbase_ = stream->tinybuf_;\n\t\t\t\tstream->bufsize_ = 1;\n\t\t\t}\n\t\t} else {\n\t\t\t/* The caller has specified a buffer to employ. */\n\t\t\t/* The buffer must be large enough to accommodate maximum\n\t\t\t  putback. */\n\t\t\tassert(bufsize > JAS_STREAM_MAXPUTBACK);\n\t\t\tstream->bufbase_ = JAS_CAST(uchar *, buf);\n\t\t\tstream->bufsize_ = bufsize - JAS_STREAM_MAXPUTBACK;\n\t\t}\n\t} else {\n\t\t/* The unbuffered mode is being employed. */\n\t\t/* A buffer should not have been supplied by the caller. */\n\t\tassert(!buf);\n\t\t/* Use a trivial one-character buffer. */\n\t\tstream->bufbase_ = stream->tinybuf_;\n\t\tstream->bufsize_ = 1;\n\t}\n\tstream->bufstart_ = &stream->bufbase_[JAS_STREAM_MAXPUTBACK];\n\tstream->ptr_ = stream->bufstart_;\n\tstream->cnt_ = 0;\n\tstream->bufmode_ |= bufmode & JAS_STREAM_BUFMODEMASK;\n}\n\n/******************************************************************************\\\n* Buffer filling and flushing code.\n\\******************************************************************************/\n\nint jas_stream_flush(jas_stream_t *stream)\n{\n\tif (stream->bufmode_ & JAS_STREAM_RDBUF) {\n\t\treturn 0;\n\t}\n\treturn jas_stream_flushbuf(stream, EOF);\n}\n\nint jas_stream_fillbuf(jas_stream_t *stream, int getflag)\n{\n\tint c;\n\n\t/* The stream must not be in an error or EOF state. */\n\tif ((stream->flags_ & (JAS_STREAM_ERRMASK)) != 0) {\n\t\treturn EOF;\n\t}\n\n\t/* The stream must be open for reading. */\n\tif ((stream->openmode_ & JAS_STREAM_READ) == 0) {\n\t\treturn EOF;\n\t}\n\n\t/* Make a half-hearted attempt to confirm that the buffer is not\n\tcurrently being used for writing.  This check is not intended\n\tto be foolproof! */\n\tassert((stream->bufmode_ & JAS_STREAM_WRBUF) == 0);\n\n\tassert(stream->ptr_ - stream->bufstart_ <= stream->bufsize_);\n\n\t/* Mark the buffer as being used for reading. */\n\tstream->bufmode_ |= JAS_STREAM_RDBUF;\n\n\t/* Read new data into the buffer. */\n\tstream->ptr_ = stream->bufstart_;\n\tif ((stream->cnt_ = (*stream->ops_->read_)(stream->obj_,\n\t  (char *) stream->bufstart_, stream->bufsize_)) <= 0) {\n\t\tif (stream->cnt_ < 0) {\n\t\t\tstream->flags_ |= JAS_STREAM_ERR;\n\t\t} else {\n\t\t\tstream->flags_ |= JAS_STREAM_EOF;\n\t\t}\n\t\tstream->cnt_ = 0;\n\t\treturn EOF;\n\t}\n\n\tassert(stream->cnt_ > 0);\n\t/* Get or peek at the first character in the buffer. */\n\tc = (getflag) ? jas_stream_getc2(stream) : (*stream->ptr_);\n\n\treturn c;\n}\n\nint jas_stream_flushbuf(jas_stream_t *stream, int c)\n{\n\tint len;\n\tint n;\n\n\t/* The stream should not be in an error or EOF state. */\n\tif ((stream->flags_ & (JAS_STREAM_ERRMASK)) != 0) {\n\t\treturn EOF;\n\t}\n\n\t/* The stream must be open for writing. */\n\tif ((stream->openmode_ & (JAS_STREAM_WRITE | JAS_STREAM_APPEND)) == 0) {\n\t\treturn EOF;\n\t}\n\n\t/* The buffer should not currently be in use for reading. */\n\tassert(!(stream->bufmode_ & JAS_STREAM_RDBUF));\n\n\t/* Note: Do not use the quantity stream->cnt to determine the number\n\tof characters in the buffer!  Depending on how this function was\n\tcalled, the stream->cnt value may be \"off-by-one\". */\n\tlen = stream->ptr_ - stream->bufstart_;\n\tif (len > 0) {\n\t\tn = (*stream->ops_->write_)(stream->obj_, (char *)\n\t\t  stream->bufstart_, len);\n\t\tif (n != len) {\n\t\t\tstream->flags_ |= JAS_STREAM_ERR;\n\t\t\treturn EOF;\n\t\t}\n\t}\n\tstream->cnt_ = stream->bufsize_;\n\tstream->ptr_ = stream->bufstart_;\n\n\tstream->bufmode_ |= JAS_STREAM_WRBUF;\n\n\tif (c != EOF) {\n\t\tassert(stream->cnt_ > 0);\n\t\treturn jas_stream_putc2(stream, c);\n\t}\n\n\treturn 0;\n}\n\n/******************************************************************************\\\n* Miscellaneous code.\n\\******************************************************************************/\n\nstatic int jas_strtoopenmode(const char *s)\n{\n\tint openmode = 0;\n\twhile (*s != '\\0') {\n\t\tswitch (*s) {\n\t\tcase 'r':\n\t\t\topenmode |= JAS_STREAM_READ;\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\topenmode |= JAS_STREAM_WRITE | JAS_STREAM_CREATE;\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\topenmode |= JAS_STREAM_BINARY;\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\topenmode |= JAS_STREAM_APPEND;\n\t\t\tbreak;\n\t\tcase '+':\n\t\t\topenmode |= JAS_STREAM_READ | JAS_STREAM_WRITE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\t++s;\n\t}\n\treturn openmode;\n}\n\nint jas_stream_copy(jas_stream_t *out, jas_stream_t *in, int n)\n{\n\tint all;\n\tint c;\n\tint m;\n\n\tall = (n < 0) ? 1 : 0;\n\n\tm = n;\n\twhile (all || m > 0) {\n\t\tif ((c = jas_stream_getc_macro(in)) == EOF) {\n\t\t\t/* The next character of input could not be read. */\n\t\t\t/* Return with an error if an I/O error occured\n\t\t\t  (not including EOF) or if an explicit copy count\n\t\t\t  was specified. */\n\t\t\treturn (!all || jas_stream_error(in)) ? (-1) : 0;\n\t\t}\n\t\tif (jas_stream_putc_macro(out, c) == EOF) {\n\t\t\treturn -1;\n\t\t}\n\t\t--m;\n\t}\n\treturn 0;\n}\n\nlong jas_stream_setrwcount(jas_stream_t *stream, long rwcnt)\n{\n\tint old;\n\n\told = stream->rwcnt_;\n\tstream->rwcnt_ = rwcnt;\n\treturn old;\n}\n\nint jas_stream_display(jas_stream_t *stream, FILE *fp, int n)\n{\n\tunsigned char buf[16];\n\tint i;\n\tint j;\n\tint m;\n\tint c;\n\tint display;\n\tint cnt;\n\n\tcnt = n - (n % 16);\n\tdisplay = 1;\n\n\tfor (i = 0; i < n; i += 16) {\n\t\tif (n > 16 && i > 0) {\n\t\t\tdisplay = (i >= cnt) ? 1 : 0;\n\t\t}\n\t\tif (display) {\n\t\t\tfprintf(fp, \"%08x:\", i);\n\t\t}\n\t\tm = JAS_MIN(n - i, 16);\n\t\tfor (j = 0; j < m; ++j) {\n\t\t\tif ((c = jas_stream_getc(stream)) == EOF) {\n\t\t\t\tabort();\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tbuf[j] = c;\n\t\t}\n\t\tif (display) {\n\t\t\tfor (j = 0; j < m; ++j) {\n\t\t\t\tfprintf(fp, \" %02x\", buf[j]);\n\t\t\t}\n\t\t\tfputc(' ', fp);\n\t\t\tfor (; j < 16; ++j) {\n\t\t\t\tfprintf(fp, \"   \");\n\t\t\t}\n\t\t\tfor (j = 0; j < m; ++j) {\n\t\t\t\tif (isprint(buf[j])) {\n\t\t\t\t\tfputc(buf[j], fp);\n\t\t\t\t} else {\n\t\t\t\t\tfputc(' ', fp);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfprintf(fp, \"\\n\");\n\t\t}\n\n\n\t}\n\treturn 0;\n}\n\nlong jas_stream_length(jas_stream_t *stream)\n{\n\tlong oldpos;\n\tlong pos;\n\tif ((oldpos = jas_stream_tell(stream)) < 0) {\n\t\treturn -1;\n\t}\n\tif (jas_stream_seek(stream, 0, SEEK_END) < 0) {\n\t\treturn -1;\n\t}\n\tif ((pos = jas_stream_tell(stream)) < 0) {\n\t\treturn -1;\n\t}\n\tif (jas_stream_seek(stream, oldpos, SEEK_SET) < 0) {\n\t\treturn -1;\n\t}\n\treturn pos;\n}\n\n/******************************************************************************\\\n* Memory stream object.\n\\******************************************************************************/\n\nstatic int mem_read(jas_stream_obj_t *obj, char *buf, int cnt)\n{\n\tssize_t n;\n\tassert(cnt >= 0);\n\tassert(buf);\n\n\tJAS_DBGLOG(100, (\"mem_read(%p, %p, %d)\\n\", obj, buf, cnt));\n\tjas_stream_memobj_t *m = (jas_stream_memobj_t *)obj;\n\tn = m->len_ - m->pos_;\n\tcnt = JAS_MIN(n, cnt);\n\tmemcpy(buf, &m->buf_[m->pos_], cnt);\n\tm->pos_ += cnt;\n\treturn cnt;\n}\n\nstatic int mem_resize(jas_stream_memobj_t *m, size_t bufsize)\n{\n\tunsigned char *buf;\n\n\t//assert(m->buf_);\n\t//assert(bufsize >= 0);\n\n\tJAS_DBGLOG(100, (\"mem_resize(%p, %zu)\\n\", m, bufsize));\n\tif (!bufsize) {\n\t\tjas_eprintf(\n\t\t  \"mem_resize was not really designed to handle a buffer of size 0\\n\"\n\t\t  \"This may not work.\\n\"\n\t\t);\n\t}\n\n\tif (!(buf = jas_realloc2(m->buf_, bufsize, sizeof(unsigned char))) &&\n\t  bufsize) {\n\t\tJAS_DBGLOG(100, (\"mem_resize realloc failed\\n\"));\n\t\treturn -1;\n\t}\n\tJAS_DBGLOG(100, (\"mem_resize realloc succeeded\\n\"));\n\tm->buf_ = buf;\n\tm->bufsize_ = bufsize;\n\treturn 0;\n}\n\nstatic int mem_write(jas_stream_obj_t *obj, char *buf, int cnt)\n{\n\tsize_t n;\n\tint ret;\n\tjas_stream_memobj_t *m = (jas_stream_memobj_t *)obj;\n\tsize_t newbufsize;\n\tsize_t newpos;\n\n\tassert(buf);\n\tassert(cnt >= 0);\n\n\tJAS_DBGLOG(100, (\"mem_write(%p, %p, %d)\\n\", obj, buf, cnt));\n\tnewpos = m->pos_ + cnt;\n\tif (newpos > m->bufsize_ && m->growable_) {\n\t\tnewbufsize = m->bufsize_;\n\t\twhile (newbufsize < newpos) {\n\t\t\t//newbufsize <<= 1;\n\t\t\tif (!jas_safe_size_mul(newbufsize, 2, &newbufsize)) {\n\t\t\t\tJAS_DBGLOG(100, (\"new buffer size would cause overflow\\n\"));\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tJAS_DBGLOG(100, (\"mem_write resizing from %d to %zu\\n\", m->bufsize_,\n\t\t  newbufsize));\n\t\tassert(newbufsize > 0);\n\t\tif (mem_resize(m, newbufsize)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (m->pos_ > m->len_) {\n\t\t/* The current position is beyond the end of the file, so\n\t\t  pad the file to the current position with zeros. */\n\t\tn = JAS_MIN(m->pos_, m->bufsize_) - m->len_;\n\t\tif (n > 0) {\n\t\t\tmemset(&m->buf_[m->len_], 0, n);\n\t\t\tm->len_ += n;\n\t\t}\n\t\tif (m->pos_ != m->len_) {\n\t\t\t/* The buffer is not big enough. */\n\t\t\treturn 0;\n\t\t}\n\t}\n\tn = m->bufsize_ - m->pos_;\n\tret = JAS_MIN(n, cnt);\n\tif (ret > 0) {\n\t\tmemcpy(&m->buf_[m->pos_], buf, ret);\n\t\tm->pos_ += ret;\n\t}\n\tif (m->pos_ > m->len_) {\n\t\tm->len_ = m->pos_;\n\t}\n\tassert(ret == cnt);\n\treturn ret;\n}\n\nstatic long mem_seek(jas_stream_obj_t *obj, long offset, int origin)\n{\n\tjas_stream_memobj_t *m = (jas_stream_memobj_t *)obj;\n\tsize_t newpos;\n\n\tJAS_DBGLOG(100, (\"mem_seek(%p, %ld, %d)\\n\", obj, offset, origin));\n\tswitch (origin) {\n\tcase SEEK_SET:\n\t\tnewpos = offset;\n\t\tbreak;\n\tcase SEEK_END:\n\t\tnewpos = m->len_ - offset;\n\t\tbreak;\n\tcase SEEK_CUR:\n\t\tnewpos = m->pos_ + offset;\n\t\tbreak;\n\tdefault:\n\t\tabort();\n\t\tbreak;\n\t}\n\tif (newpos < 0) {\n\t\treturn -1;\n\t}\n\tm->pos_ = newpos;\n\n\treturn m->pos_;\n}\n\nstatic int mem_close(jas_stream_obj_t *obj)\n{\n\tJAS_DBGLOG(100, (\"mem_close(%p)\\n\", obj));\n\tjas_stream_memobj_t *m = (jas_stream_memobj_t *)obj;\n\tJAS_DBGLOG(100, (\"mem_close myalloc=%d\\n\", m->myalloc_));\n\tif (m->myalloc_ && m->buf_) {\n\t\tJAS_DBGLOG(100, (\"mem_close freeing buffer %p\\n\", m->buf_));\n\t\tjas_free(m->buf_);\n\t\tm->buf_ = 0;\n\t}\n\tjas_free(obj);\n\treturn 0;\n}\n\n/******************************************************************************\\\n* File stream object.\n\\******************************************************************************/\n\nstatic int file_read(jas_stream_obj_t *obj, char *buf, int cnt)\n{\n\tjas_stream_fileobj_t *fileobj;\n\tJAS_DBGLOG(100, (\"file_read(%p, %p, %d)\\n\", obj, buf, cnt));\n\tfileobj = JAS_CAST(jas_stream_fileobj_t *, obj);\n\treturn read(fileobj->fd, buf, cnt);\n}\n\nstatic int file_write(jas_stream_obj_t *obj, char *buf, int cnt)\n{\n\tjas_stream_fileobj_t *fileobj;\n\tJAS_DBGLOG(100, (\"file_write(%p, %p, %d)\\n\", obj, buf, cnt));\n\tfileobj = JAS_CAST(jas_stream_fileobj_t *, obj);\n\treturn write(fileobj->fd, buf, cnt);\n}\n\nstatic long file_seek(jas_stream_obj_t *obj, long offset, int origin)\n{\n\tjas_stream_fileobj_t *fileobj;\n\tJAS_DBGLOG(100, (\"file_seek(%p, %ld, %d)\\n\", obj, offset, origin));\n\tfileobj = JAS_CAST(jas_stream_fileobj_t *, obj);\n\treturn lseek(fileobj->fd, offset, origin);\n}\n\nstatic int file_close(jas_stream_obj_t *obj)\n{\n\tjas_stream_fileobj_t *fileobj;\n\tJAS_DBGLOG(100, (\"file_close(%p)\\n\", obj));\n\tfileobj = JAS_CAST(jas_stream_fileobj_t *, obj);\n\tint ret;\n\tret = close(fileobj->fd);\n\tif (fileobj->flags & JAS_STREAM_FILEOBJ_DELONCLOSE) {\n\t\tunlink(fileobj->pathname);\n\t}\n\tjas_free(fileobj);\n\treturn ret;\n}\n\n/******************************************************************************\\\n* Stdio file stream object.\n\\******************************************************************************/\n\nstatic int sfile_read(jas_stream_obj_t *obj, char *buf, int cnt)\n{\n\tFILE *fp;\n\tsize_t n;\n\tint result;\n\tJAS_DBGLOG(100, (\"sfile_read(%p, %p, %d)\\n\", obj, buf, cnt));\n\tfp = JAS_CAST(FILE *, obj);\n\tn = fread(buf, 1, cnt, fp);\n\tif (n != cnt) {\n\t\tresult = (!ferror(fp) && feof(fp)) ? 0 : -1;\n\t}\n\tresult = JAS_CAST(int, n);\n\treturn result;\n}\n\nstatic int sfile_write(jas_stream_obj_t *obj, char *buf, int cnt)\n{\n\tFILE *fp;\n\tsize_t n;\n\tJAS_DBGLOG(100, (\"sfile_write(%p, %p, %d)\\n\", obj, buf, cnt));\n\tfp = JAS_CAST(FILE *, obj);\n\tn = fwrite(buf, 1, cnt, fp);\n\treturn (n != JAS_CAST(size_t, cnt)) ? (-1) : cnt;\n}\n\nstatic long sfile_seek(jas_stream_obj_t *obj, long offset, int origin)\n{\n\tFILE *fp;\n\tJAS_DBGLOG(100, (\"sfile_seek(%p, %ld, %d)\\n\", obj, offset, origin));\n\tfp = JAS_CAST(FILE *, obj);\n\treturn fseek(fp, offset, origin);\n}\n\nstatic int sfile_close(jas_stream_obj_t *obj)\n{\n\tFILE *fp;\n\tJAS_DBGLOG(100, (\"sfile_close(%p)\\n\", obj));\n\tfp = JAS_CAST(FILE *, obj);\n\treturn fclose(fp);\n}\n", "/*\n * Copyright (c) 2001-2002 Michael David Adams.\n * All rights reserved.\n */\n\n/* __START_OF_JASPER_LICENSE__\n * \n * JasPer License Version 2.0\n * \n * Copyright (c) 2001-2006 Michael David Adams\n * Copyright (c) 1999-2000 Image Power, Inc.\n * Copyright (c) 1999-2000 The University of British Columbia\n * \n * All rights reserved.\n * \n * Permission is hereby granted, free of charge, to any person (the\n * \"User\") obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n * \n * 1.  The above copyright notices and this permission notice (which\n * includes the disclaimer below) shall be included in all copies or\n * substantial portions of the Software.\n * \n * 2.  The name of a copyright holder shall not be used to endorse or\n * promote products derived from the Software without specific prior\n * written permission.\n * \n * THIS DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS\n * LICENSE.  NO USE OF THE SOFTWARE IS AUTHORIZED HEREUNDER EXCEPT UNDER\n * THIS DISCLAIMER.  THE SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS\n * \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.  IN NO\n * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL\n * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING\n * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\n * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION\n * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  NO ASSURANCES ARE\n * PROVIDED BY THE COPYRIGHT HOLDERS THAT THE SOFTWARE DOES NOT INFRINGE\n * THE PATENT OR OTHER INTELLECTUAL PROPERTY RIGHTS OF ANY OTHER ENTITY.\n * EACH COPYRIGHT HOLDER DISCLAIMS ANY LIABILITY TO THE USER FOR CLAIMS\n * BROUGHT BY ANY OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL\n * PROPERTY RIGHTS OR OTHERWISE.  AS A CONDITION TO EXERCISING THE RIGHTS\n * GRANTED HEREUNDER, EACH USER HEREBY ASSUMES SOLE RESPONSIBILITY TO SECURE\n * ANY OTHER INTELLECTUAL PROPERTY RIGHTS NEEDED, IF ANY.  THE SOFTWARE\n * IS NOT FAULT-TOLERANT AND IS NOT INTENDED FOR USE IN MISSION-CRITICAL\n * SYSTEMS, SUCH AS THOSE USED IN THE OPERATION OF NUCLEAR FACILITIES,\n * AIRCRAFT NAVIGATION OR COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL\n * SYSTEMS, DIRECT LIFE SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH\n * THE FAILURE OF THE SOFTWARE OR SYSTEM COULD LEAD DIRECTLY TO DEATH,\n * PERSONAL INJURY, OR SEVERE PHYSICAL OR ENVIRONMENTAL DAMAGE (\"HIGH\n * RISK ACTIVITIES\").  THE COPYRIGHT HOLDERS SPECIFICALLY DISCLAIM ANY\n * EXPRESS OR IMPLIED WARRANTY OF FITNESS FOR HIGH RISK ACTIVITIES.\n * \n * __END_OF_JASPER_LICENSE__\n */\n\n/*\n * Debugging-Related Code\n *\n * $Id$\n */\n\n#ifndef JAS_DEBUG_H\n#define JAS_DEBUG_H\n\n/******************************************************************************\\\n* Includes.\n\\******************************************************************************/\n\n#include <stdio.h>\n\n#include <jasper/jas_config.h>\n#include <jasper/jas_types.h>\n#include <jasper/jas_debug.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/******************************************************************************\\\n* Macros and functions.\n\\******************************************************************************/\n\n/* Output debugging information to standard error provided that the debug\n  level is set sufficiently high. */\n#if !defined(NDEBUG)\n#define\tJAS_DBGLOG(n, x) \\\n\t((jas_getdbglevel() >= (n)) ? (jas_eprintf x) : 0)\n#else\n#define\tJAS_DBGLOG(n, x)\n#endif\n\n/* Get the library debug level. */\nint jas_getdbglevel(void);\n\n/* Set the library debug level. */\nint jas_setdbglevel(int dbglevel);\n\n/* Perform formatted output to standard error. */\nint jas_eprintf(const char *fmt, ...);\n\n/* Dump memory to a stream. */\nint jas_memdump(FILE *out, void *data, size_t len);\n\n/* Warn about use of deprecated functionality. */\nvoid jas_deprecated(const char *s);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n", "/*\n * Copyright (c) 1999-2000 Image Power, Inc. and the University of\n *   British Columbia.\n * Copyright (c) 2001-2003 Michael David Adams.\n * All rights reserved.\n */\n\n/* __START_OF_JASPER_LICENSE__\n * \n * JasPer License Version 2.0\n * \n * Copyright (c) 2001-2006 Michael David Adams\n * Copyright (c) 1999-2000 Image Power, Inc.\n * Copyright (c) 1999-2000 The University of British Columbia\n * \n * All rights reserved.\n * \n * Permission is hereby granted, free of charge, to any person (the\n * \"User\") obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n * \n * 1.  The above copyright notices and this permission notice (which\n * includes the disclaimer below) shall be included in all copies or\n * substantial portions of the Software.\n * \n * 2.  The name of a copyright holder shall not be used to endorse or\n * promote products derived from the Software without specific prior\n * written permission.\n * \n * THIS DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS\n * LICENSE.  NO USE OF THE SOFTWARE IS AUTHORIZED HEREUNDER EXCEPT UNDER\n * THIS DISCLAIMER.  THE SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS\n * \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.  IN NO\n * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL\n * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING\n * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\n * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION\n * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  NO ASSURANCES ARE\n * PROVIDED BY THE COPYRIGHT HOLDERS THAT THE SOFTWARE DOES NOT INFRINGE\n * THE PATENT OR OTHER INTELLECTUAL PROPERTY RIGHTS OF ANY OTHER ENTITY.\n * EACH COPYRIGHT HOLDER DISCLAIMS ANY LIABILITY TO THE USER FOR CLAIMS\n * BROUGHT BY ANY OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL\n * PROPERTY RIGHTS OR OTHERWISE.  AS A CONDITION TO EXERCISING THE RIGHTS\n * GRANTED HEREUNDER, EACH USER HEREBY ASSUMES SOLE RESPONSIBILITY TO SECURE\n * ANY OTHER INTELLECTUAL PROPERTY RIGHTS NEEDED, IF ANY.  THE SOFTWARE\n * IS NOT FAULT-TOLERANT AND IS NOT INTENDED FOR USE IN MISSION-CRITICAL\n * SYSTEMS, SUCH AS THOSE USED IN THE OPERATION OF NUCLEAR FACILITIES,\n * AIRCRAFT NAVIGATION OR COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL\n * SYSTEMS, DIRECT LIFE SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH\n * THE FAILURE OF THE SOFTWARE OR SYSTEM COULD LEAD DIRECTLY TO DEATH,\n * PERSONAL INJURY, OR SEVERE PHYSICAL OR ENVIRONMENTAL DAMAGE (\"HIGH\n * RISK ACTIVITIES\").  THE COPYRIGHT HOLDERS SPECIFICALLY DISCLAIM ANY\n * EXPRESS OR IMPLIED WARRANTY OF FITNESS FOR HIGH RISK ACTIVITIES.\n * \n * __END_OF_JASPER_LICENSE__\n */\n\n/*\n * I/O Stream Class\n *\n * $Id$\n */\n\n#ifndef JAS_STREAM_H\n#define JAS_STREAM_H\n\n/******************************************************************************\\\n* Includes.\n\\******************************************************************************/\n\n#include <jasper/jas_config.h>\n\n#include <stdio.h>\n#if defined(HAVE_FCNTL_H)\n#include <fcntl.h>\n#endif\n#include <string.h>\n#if defined(HAVE_UNISTD_H)\n#include <unistd.h>\n#endif\n#include <jasper/jas_types.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/******************************************************************************\\\n* Constants.\n\\******************************************************************************/\n\n/* On most UNIX systems, we probably need to define O_BINARY ourselves. */\n#ifndef O_BINARY\n#define O_BINARY\t0\n#endif\n\n/*\n * Stream open flags.\n */\n\n/* The stream was opened for reading. */\n#define JAS_STREAM_READ\t0x0001\n/* The stream was opened for writing. */\n#define JAS_STREAM_WRITE\t0x0002\n/* The stream was opened for appending. */\n#define JAS_STREAM_APPEND\t0x0004\n/* The stream was opened in binary mode. */\n#define JAS_STREAM_BINARY\t0x0008\n/* The stream should be created/truncated. */\n#define JAS_STREAM_CREATE\t0x0010\n\n\n/*\n * Stream buffering flags.\n */\n\n/* The stream is unbuffered. */\n#define JAS_STREAM_UNBUF\t0x0000\n/* The stream is line buffered. */\n#define JAS_STREAM_LINEBUF\t0x0001\n/* The stream is fully buffered. */\n#define JAS_STREAM_FULLBUF\t0x0002\n/* The buffering mode mask. */\n#define\tJAS_STREAM_BUFMODEMASK\t0x000f\n\n/* The memory associated with the buffer needs to be deallocated when the\n  stream is destroyed. */\n#define JAS_STREAM_FREEBUF\t0x0008\n/* The buffer is currently being used for reading. */\n#define JAS_STREAM_RDBUF\t0x0010\n/* The buffer is currently being used for writing. */\n#define JAS_STREAM_WRBUF\t0x0020\n\n/*\n * Stream error flags.\n */\n\n/* The end-of-file has been encountered (on reading). */\n#define JAS_STREAM_EOF\t0x0001\n/* An I/O error has been encountered on the stream. */\n#define JAS_STREAM_ERR\t0x0002\n/* The read/write limit has been exceeded. */\n#define\tJAS_STREAM_RWLIMIT\t0x0004\n/* The error mask. */\n#define JAS_STREAM_ERRMASK \\\n\t(JAS_STREAM_EOF | JAS_STREAM_ERR | JAS_STREAM_RWLIMIT)\n\n/*\n * Other miscellaneous constants.\n */\n\n/* The default buffer size (for fully-buffered operation). */\n#define JAS_STREAM_BUFSIZE\t8192\n/* The default permission mask for file creation. */\n#define JAS_STREAM_PERMS\t0666\n\n/* The maximum number of characters that can always be put back on a stream. */\n#define\tJAS_STREAM_MAXPUTBACK\t16\n\n/******************************************************************************\\\n* Types.\n\\******************************************************************************/\n\n/*\n * Generic file object.\n */\n\ntypedef void jas_stream_obj_t;\n\n/*\n * Generic file object operations.\n */\n\ntypedef struct {\n\n\t/* Read characters from a file object. */\n\tint (*read_)(jas_stream_obj_t *obj, char *buf, int cnt);\n\n\t/* Write characters to a file object. */\n\tint (*write_)(jas_stream_obj_t *obj, char *buf, int cnt);\n\n\t/* Set the position for a file object. */\n\tlong (*seek_)(jas_stream_obj_t *obj, long offset, int origin);\n\n\t/* Close a file object. */\n\tint (*close_)(jas_stream_obj_t *obj);\n\n} jas_stream_ops_t;\n\n/*\n * Stream object.\n */\n\ntypedef struct {\n\n\t/* The mode in which the stream was opened. */\n\tint openmode_;\n\n\t/* The buffering mode. */\n\tint bufmode_;\n\n\t/* The stream status. */\n\tint flags_;\n\n\t/* The start of the buffer area to use for reading/writing. */\n\tuchar *bufbase_;\n\n\t/* The start of the buffer area excluding the extra initial space for\n\t  character putback. */\n\tuchar *bufstart_;\n\n\t/* The buffer size. */\n\tint bufsize_;\n\n\t/* The current position in the buffer. */\n\tuchar *ptr_;\n\n\t/* The number of characters that must be read/written before\n\tthe buffer needs to be filled/flushed. */\n\tint cnt_;\n\n\t/* A trivial buffer to be used for unbuffered operation. */\n\tuchar tinybuf_[JAS_STREAM_MAXPUTBACK + 1];\n\n\t/* The operations for the underlying stream file object. */\n\tjas_stream_ops_t *ops_;\n\n\t/* The underlying stream file object. */\n\tjas_stream_obj_t *obj_;\n\n\t/* The number of characters read/written. */\n\tlong rwcnt_;\n\n\t/* The maximum number of characters that may be read/written. */\n\tlong rwlimit_;\n\n} jas_stream_t;\n\n/*\n * Regular file object.\n */\n\n/*\n * File descriptor file object.\n */\ntypedef struct {\n\tint fd;\n\tint flags;\n\tchar pathname[L_tmpnam + 1];\n} jas_stream_fileobj_t;\n\n#define\tJAS_STREAM_FILEOBJ_DELONCLOSE\t0x01\n#define JAS_STREAM_FILEOBJ_NOCLOSE\t0x02\n\n/*\n * Memory file object.\n */\n\ntypedef struct {\n\n\t/* The data associated with this file. */\n\tuchar *buf_;\n\n\t/* The allocated size of the buffer for holding file data. */\n\tsize_t bufsize_;\n\n\t/* The length of the file. */\n\tint_fast32_t len_;\n\n\t/* The seek position. */\n\tint_fast32_t pos_;\n\n\t/* Is the buffer growable? */\n\tint growable_;\n\n\t/* Was the buffer allocated internally? */\n\tint myalloc_;\n\n} jas_stream_memobj_t;\n\n/******************************************************************************\\\n* Macros/functions for opening and closing streams.\n\\******************************************************************************/\n\n/* Open a file as a stream. */\njas_stream_t *jas_stream_fopen(const char *filename, const char *mode);\n\n/* Open a memory buffer as a stream. */\njas_stream_t *jas_stream_memopen(char *buf, int bufsize);\n\n/* Do not use this function.\nIt will eventually replace jas_stream_memopen. */\njas_stream_t *jas_stream_memopen2(char *buf, size_t bufsize);\n\n/* Open a file descriptor as a stream. */\njas_stream_t *jas_stream_fdopen(int fd, const char *mode);\n\n/* Open a stdio stream as a stream. */\njas_stream_t *jas_stream_freopen(const char *path, const char *mode, FILE *fp);\n\n/* Open a temporary file as a stream. */\njas_stream_t *jas_stream_tmpfile(void);\n\n/* Close a stream. */\nint jas_stream_close(jas_stream_t *stream);\n\n/******************************************************************************\\\n* Macros/functions for getting/setting the stream state.\n\\******************************************************************************/\n\n/* Get the EOF indicator for a stream. */\n#define jas_stream_eof(stream) \\\n\t(((stream)->flags_ & JAS_STREAM_EOF) != 0)\n\n/* Get the error indicator for a stream. */\n#define jas_stream_error(stream) \\\n\t(((stream)->flags_ & JAS_STREAM_ERR) != 0)\n\n/* Clear the error indicator for a stream. */\n#define jas_stream_clearerr(stream) \\\n\t((stream)->flags_ &= ~(JAS_STREAM_ERR | JAS_STREAM_EOF))\n\n/* Get the read/write limit for a stream. */\n#define\tjas_stream_getrwlimit(stream) \\\n\t(((const jas_stream_t *)(stream))->rwlimit_)\n\n/* Set the read/write limit for a stream. */\nint jas_stream_setrwlimit(jas_stream_t *stream, long rwlimit);\n\n/* Get the read/write count for a stream. */\n#define\tjas_stream_getrwcount(stream) \\\n\t(((const jas_stream_t *)(stream))->rwcnt_)\n\n/* Set the read/write count for a stream. */\nlong jas_stream_setrwcount(jas_stream_t *stream, long rwcnt);\n\n/******************************************************************************\\\n* Macros/functions for I/O.\n\\******************************************************************************/\n\n/* Read a character from a stream. */\n#if defined(DEBUG)\n#define\tjas_stream_getc(stream)\tjas_stream_getc_func(stream)\n#else\n#define jas_stream_getc(stream)\tjas_stream_getc_macro(stream)\n#endif\n\n/* Write a character to a stream. */\n#if defined(DEBUG)\n#define jas_stream_putc(stream, c)\tjas_stream_putc_func(stream, c)\n#else\n#define jas_stream_putc(stream, c)\tjas_stream_putc_macro(stream, c)\n#endif\n\n/* Read characters from a stream into a buffer. */\nint jas_stream_read(jas_stream_t *stream, void *buf, int cnt);\n\n/* Write characters from a buffer to a stream. */\nint jas_stream_write(jas_stream_t *stream, const void *buf, int cnt);\n\n/* Write formatted output to a stream. */\nint jas_stream_printf(jas_stream_t *stream, const char *fmt, ...);\n\n/* Write a string to a stream. */\nint jas_stream_puts(jas_stream_t *stream, const char *s);\n\n/* Read a line of input from a stream. */\nchar *jas_stream_gets(jas_stream_t *stream, char *buf, int bufsize);\n\n/* Look at the next character to be read from a stream without actually\n  removing it from the stream. */\n#define\tjas_stream_peekc(stream) \\\n\t(((stream)->cnt_ <= 0) ? jas_stream_fillbuf(stream, 0) : \\\n\t  ((int)(*(stream)->ptr_)))\n\n/* Put a character back on a stream. */\nint jas_stream_ungetc(jas_stream_t *stream, int c);\n\n/******************************************************************************\\\n* Macros/functions for getting/setting the stream position.\n\\******************************************************************************/\n\n/* Is it possible to seek on this stream? */\nint jas_stream_isseekable(jas_stream_t *stream);\n\n/* Set the current position within the stream. */\nlong jas_stream_seek(jas_stream_t *stream, long offset, int origin);\n\n/* Get the current position within the stream. */\nlong jas_stream_tell(jas_stream_t *stream);\n\n/* Seek to the beginning of a stream. */\nint jas_stream_rewind(jas_stream_t *stream);\n\n/******************************************************************************\\\n* Macros/functions for flushing.\n\\******************************************************************************/\n\n/* Flush any pending output to a stream. */\nint jas_stream_flush(jas_stream_t *stream);\n\n/******************************************************************************\\\n* Miscellaneous macros/functions.\n\\******************************************************************************/\n\n/* Copy data from one stream to another. */\nint jas_stream_copy(jas_stream_t *dst, jas_stream_t *src, int n);\n\n/* Display stream contents (for debugging purposes). */\nint jas_stream_display(jas_stream_t *stream, FILE *fp, int n);\n\n/* Consume (i.e., discard) characters from stream. */\nint jas_stream_gobble(jas_stream_t *stream, int n);\n\n/* Write a character multiple times to a stream. */\nint jas_stream_pad(jas_stream_t *stream, int n, int c);\n\n/* Get the size of the file associated with the specified stream.\n  The specified stream must be seekable. */\nlong jas_stream_length(jas_stream_t *stream);\n\n/******************************************************************************\\\n* Internal functions.\n\\******************************************************************************/\n\n/* The following functions are for internal use only!  If you call them\ndirectly, you will die a horrible, miserable, and painful death! */\n\n/* Read a character from a stream. */\n#define jas_stream_getc_macro(stream) \\\n\t((!((stream)->flags_ & (JAS_STREAM_ERR | JAS_STREAM_EOF | \\\n\t  JAS_STREAM_RWLIMIT))) ? \\\n\t  (((stream)->rwlimit_ >= 0 && (stream)->rwcnt_ >= (stream)->rwlimit_) ? \\\n\t  (stream->flags_ |= JAS_STREAM_RWLIMIT, EOF) : \\\n\t  jas_stream_getc2(stream)) : EOF)\n#define jas_stream_getc2(stream) \\\n\t((--(stream)->cnt_ < 0) ? jas_stream_fillbuf(stream, 1) : \\\n\t  (++(stream)->rwcnt_, (int)(*(stream)->ptr_++)))\n\n/* Write a character to a stream. */\n#define jas_stream_putc_macro(stream, c) \\\n\t((!((stream)->flags_ & (JAS_STREAM_ERR | JAS_STREAM_EOF | \\\n\t  JAS_STREAM_RWLIMIT))) ? \\\n\t  (((stream)->rwlimit_ >= 0 && (stream)->rwcnt_ >= (stream)->rwlimit_) ? \\\n\t  (stream->flags_ |= JAS_STREAM_RWLIMIT, EOF) : \\\n\t  jas_stream_putc2(stream, c)) : EOF)\n#define jas_stream_putc2(stream, c) \\\n\t(((stream)->bufmode_ |= JAS_STREAM_WRBUF, --(stream)->cnt_ < 0) ? \\\n\t  jas_stream_flushbuf((stream), (uchar)(c)) : \\\n\t  (++(stream)->rwcnt_, (int)(*(stream)->ptr_++ = (c))))\n\n/* These prototypes need to be here for the sake of the stream_getc and\nstream_putc macros. */\nint jas_stream_fillbuf(jas_stream_t *stream, int getflag);\nint jas_stream_flushbuf(jas_stream_t *stream, int c);\nint jas_stream_getc_func(jas_stream_t *stream);\nint jas_stream_putc_func(jas_stream_t *stream, int c);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"], "filenames": ["src/libjasper/base/jas_debug.c", "src/libjasper/base/jas_image.c", "src/libjasper/base/jas_stream.c", "src/libjasper/include/jasper/jas_debug.h", "src/libjasper/include/jasper/jas_stream.h"], "buggy_code_start_loc": [137, 350, 171, 109, 270], "buggy_code_end_loc": [137, 351, 1080, 109, 294], "fixing_code_start_loc": [138, 350, 172, 110, 270], "fixing_code_end_loc": [157, 351, 1237, 113, 299], "type": "CWE-190", "message": "Multiple integer overflows in the (1) jas_realloc function in base/jas_malloc.c and (2) mem_resize function in base/jas_stream.c in JasPer before 1.900.22 allow remote attackers to cause a denial of service via a crafted image, which triggers use after free vulnerabilities.", "other": {"cve": {"id": "CVE-2016-9262", "sourceIdentifier": "cve@mitre.org", "published": "2017-03-23T18:59:00.350", "lastModified": "2018-06-29T01:29:01.457", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Multiple integer overflows in the (1) jas_realloc function in base/jas_malloc.c and (2) mem_resize function in base/jas_stream.c in JasPer before 1.900.22 allow remote attackers to cause a denial of service via a crafted image, which triggers use after free vulnerabilities."}, {"lang": "es", "value": "M\u00faltiples desbordamientos de entero en la funci\u00f3n (1) jas_realloc en base/jas_malloc.c y funci\u00f3n (2) mem_resize en base/jas_stream.c en JasPer en versiones anteriores a 1.900.22 permiten a atacantes remotos provocar una denegaci\u00f3n de servicio a trav\u00e9s de una imagen manipulada, lo que desencadena vulnerabilidades de uso despu\u00e9s de liberaci\u00f3n."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:jasper_project:jasper:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.900.21", "matchCriteriaId": "192EB44A-E0C2-4F47-BBA0-42C51C3EFE33"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2016/11/10/4", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/94224", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:1208", "source": "cve@mitre.org"}, {"url": "https://blogs.gentoo.org/ago/2016/11/07/jasper-use-after-free-in-jas_realloc-jas_malloc-c", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1393882", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/mdadams/jasper/commit/634ce8e8a5accc0fa05dd2c20d42b4749d4b2735", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Vendor Advisory"]}, {"url": "https://security.gentoo.org/glsa/201707-07", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/3693-1/", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/mdadams/jasper/commit/634ce8e8a5accc0fa05dd2c20d42b4749d4b2735"}}