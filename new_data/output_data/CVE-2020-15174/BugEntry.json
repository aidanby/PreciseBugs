{"buggy_code": ["// Copyright (c) 2014 GitHub, Inc.\n// Use of this source code is governed by the MIT license that can be\n// found in the LICENSE file.\n\n#include \"shell/browser/api/electron_api_web_contents.h\"\n\n#include <limits>\n#include <memory>\n#include <set>\n#include <string>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\n#include \"base/message_loop/message_loop_current.h\"\n#include \"base/no_destructor.h\"\n#include \"base/optional.h\"\n#include \"base/strings/utf_string_conversions.h\"\n#include \"base/threading/thread_restrictions.h\"\n#include \"base/threading/thread_task_runner_handle.h\"\n#include \"base/values.h\"\n#include \"chrome/browser/browser_process.h\"\n#include \"chrome/browser/ssl/security_state_tab_helper.h\"\n#include \"content/browser/frame_host/frame_tree_node.h\"             // nogncheck\n#include \"content/browser/frame_host/render_frame_host_manager.h\"   // nogncheck\n#include \"content/browser/renderer_host/render_widget_host_impl.h\"  // nogncheck\n#include \"content/browser/renderer_host/render_widget_host_view_base.h\"  // nogncheck\n#include \"content/common/widget_messages.h\"\n#include \"content/public/browser/child_process_security_policy.h\"\n#include \"content/public/browser/context_menu_params.h\"\n#include \"content/public/browser/download_request_utils.h\"\n#include \"content/public/browser/favicon_status.h\"\n#include \"content/public/browser/native_web_keyboard_event.h\"\n#include \"content/public/browser/navigation_details.h\"\n#include \"content/public/browser/navigation_entry.h\"\n#include \"content/public/browser/navigation_handle.h\"\n#include \"content/public/browser/plugin_service.h\"\n#include \"content/public/browser/render_frame_host.h\"\n#include \"content/public/browser/render_process_host.h\"\n#include \"content/public/browser/render_view_host.h\"\n#include \"content/public/browser/render_widget_host.h\"\n#include \"content/public/browser/render_widget_host_view.h\"\n#include \"content/public/browser/service_worker_context.h\"\n#include \"content/public/browser/site_instance.h\"\n#include \"content/public/browser/storage_partition.h\"\n#include \"content/public/browser/web_contents.h\"\n#include \"content/public/common/referrer_type_converters.h\"\n#include \"electron/buildflags/buildflags.h\"\n#include \"electron/shell/common/api/api.mojom.h\"\n#include \"gin/data_object_builder.h\"\n#include \"gin/handle.h\"\n#include \"gin/object_template_builder.h\"\n#include \"gin/wrappable.h\"\n#include \"mojo/public/cpp/bindings/associated_remote.h\"\n#include \"mojo/public/cpp/bindings/pending_receiver.h\"\n#include \"mojo/public/cpp/bindings/remote.h\"\n#include \"mojo/public/cpp/system/platform_handle.h\"\n#include \"ppapi/buildflags/buildflags.h\"\n#include \"shell/browser/api/electron_api_browser_window.h\"\n#include \"shell/browser/api/electron_api_debugger.h\"\n#include \"shell/browser/api/electron_api_session.h\"\n#include \"shell/browser/api/message_port.h\"\n#include \"shell/browser/browser.h\"\n#include \"shell/browser/child_web_contents_tracker.h\"\n#include \"shell/browser/electron_autofill_driver_factory.h\"\n#include \"shell/browser/electron_browser_client.h\"\n#include \"shell/browser/electron_browser_context.h\"\n#include \"shell/browser/electron_browser_main_parts.h\"\n#include \"shell/browser/electron_javascript_dialog_manager.h\"\n#include \"shell/browser/electron_navigation_throttle.h\"\n#include \"shell/browser/lib/bluetooth_chooser.h\"\n#include \"shell/browser/native_window.h\"\n#include \"shell/browser/session_preferences.h\"\n#include \"shell/browser/ui/drag_util.h\"\n#include \"shell/browser/ui/inspectable_web_contents.h\"\n#include \"shell/browser/ui/inspectable_web_contents_view.h\"\n#include \"shell/browser/web_contents_permission_helper.h\"\n#include \"shell/browser/web_contents_preferences.h\"\n#include \"shell/browser/web_contents_zoom_controller.h\"\n#include \"shell/browser/web_view_guest_delegate.h\"\n#include \"shell/common/api/electron_api_native_image.h\"\n#include \"shell/common/color_util.h\"\n#include \"shell/common/gin_converters/blink_converter.h\"\n#include \"shell/common/gin_converters/callback_converter.h\"\n#include \"shell/common/gin_converters/content_converter.h\"\n#include \"shell/common/gin_converters/file_path_converter.h\"\n#include \"shell/common/gin_converters/gfx_converter.h\"\n#include \"shell/common/gin_converters/gurl_converter.h\"\n#include \"shell/common/gin_converters/image_converter.h\"\n#include \"shell/common/gin_converters/net_converter.h\"\n#include \"shell/common/gin_converters/value_converter.h\"\n#include \"shell/common/gin_helper/dictionary.h\"\n#include \"shell/common/gin_helper/object_template_builder.h\"\n#include \"shell/common/language_util.h\"\n#include \"shell/common/mouse_util.h\"\n#include \"shell/common/node_includes.h\"\n#include \"shell/common/options_switches.h\"\n#include \"shell/common/v8_value_serializer.h\"\n#include \"third_party/blink/public/common/associated_interfaces/associated_interface_provider.h\"\n#include \"third_party/blink/public/common/input/web_input_event.h\"\n#include \"third_party/blink/public/common/messaging/transferable_message_mojom_traits.h\"\n#include \"third_party/blink/public/common/page/page_zoom.h\"\n#include \"third_party/blink/public/mojom/frame/find_in_page.mojom.h\"\n#include \"third_party/blink/public/mojom/frame/fullscreen.mojom.h\"\n#include \"third_party/blink/public/mojom/messaging/transferable_message.mojom.h\"\n#include \"third_party/blink/public/mojom/renderer_preferences.mojom.h\"\n#include \"ui/base/cursor/cursor.h\"\n#include \"ui/base/cursor/mojom/cursor_type.mojom-shared.h\"\n#include \"ui/display/screen.h\"\n#include \"ui/events/base_event_utils.h\"\n\n#if BUILDFLAG(ENABLE_OSR)\n#include \"shell/browser/osr/osr_render_widget_host_view.h\"\n#include \"shell/browser/osr/osr_web_contents_view.h\"\n#endif\n\n#if !defined(OS_MACOSX)\n#include \"ui/aura/window.h\"\n#else\n#include \"ui/base/cocoa/defaults_utils.h\"\n#endif\n\n#if defined(OS_LINUX)\n#include \"ui/views/linux_ui/linux_ui.h\"\n#endif\n\n#if defined(OS_LINUX) || defined(OS_WIN)\n#include \"ui/gfx/font_render_params.h\"\n#endif\n\n#if BUILDFLAG(ENABLE_ELECTRON_EXTENSIONS)\n#include \"extensions/browser/script_executor.h\"\n#include \"shell/browser/extensions/electron_extension_web_contents_observer.h\"\n#endif\n\nnamespace gin {\n\n#if BUILDFLAG(ENABLE_PRINTING)\ntemplate <>\nstruct Converter<printing::PrinterBasicInfo> {\n  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,\n                                   const printing::PrinterBasicInfo& val) {\n    gin_helper::Dictionary dict = gin::Dictionary::CreateEmpty(isolate);\n    dict.Set(\"name\", val.printer_name);\n    dict.Set(\"displayName\", val.display_name);\n    dict.Set(\"description\", val.printer_description);\n    dict.Set(\"status\", val.printer_status);\n    dict.Set(\"isDefault\", val.is_default ? true : false);\n    dict.Set(\"options\", val.options);\n    return dict.GetHandle();\n  }\n};\n\ntemplate <>\nstruct Converter<printing::MarginType> {\n  static bool FromV8(v8::Isolate* isolate,\n                     v8::Local<v8::Value> val,\n                     printing::MarginType* out) {\n    std::string type;\n    if (ConvertFromV8(isolate, val, &type)) {\n      if (type == \"default\") {\n        *out = printing::DEFAULT_MARGINS;\n        return true;\n      }\n      if (type == \"none\") {\n        *out = printing::NO_MARGINS;\n        return true;\n      }\n      if (type == \"printableArea\") {\n        *out = printing::PRINTABLE_AREA_MARGINS;\n        return true;\n      }\n      if (type == \"custom\") {\n        *out = printing::CUSTOM_MARGINS;\n        return true;\n      }\n    }\n    return false;\n  }\n};\n\ntemplate <>\nstruct Converter<printing::mojom::DuplexMode> {\n  static bool FromV8(v8::Isolate* isolate,\n                     v8::Local<v8::Value> val,\n                     printing::mojom::DuplexMode* out) {\n    std::string mode;\n    if (ConvertFromV8(isolate, val, &mode)) {\n      if (mode == \"simplex\") {\n        *out = printing::mojom::DuplexMode::kSimplex;\n        return true;\n      }\n      if (mode == \"longEdge\") {\n        *out = printing::mojom::DuplexMode::kLongEdge;\n        return true;\n      }\n      if (mode == \"shortEdge\") {\n        *out = printing::mojom::DuplexMode::kShortEdge;\n        return true;\n      }\n    }\n    return false;\n  }\n};\n\n#endif\n\ntemplate <>\nstruct Converter<WindowOpenDisposition> {\n  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,\n                                   WindowOpenDisposition val) {\n    std::string disposition = \"other\";\n    switch (val) {\n      case WindowOpenDisposition::CURRENT_TAB:\n        disposition = \"default\";\n        break;\n      case WindowOpenDisposition::NEW_FOREGROUND_TAB:\n        disposition = \"foreground-tab\";\n        break;\n      case WindowOpenDisposition::NEW_BACKGROUND_TAB:\n        disposition = \"background-tab\";\n        break;\n      case WindowOpenDisposition::NEW_POPUP:\n      case WindowOpenDisposition::NEW_WINDOW:\n        disposition = \"new-window\";\n        break;\n      case WindowOpenDisposition::SAVE_TO_DISK:\n        disposition = \"save-to-disk\";\n        break;\n      default:\n        break;\n    }\n    return gin::ConvertToV8(isolate, disposition);\n  }\n};\n\ntemplate <>\nstruct Converter<content::SavePageType> {\n  static bool FromV8(v8::Isolate* isolate,\n                     v8::Local<v8::Value> val,\n                     content::SavePageType* out) {\n    std::string save_type;\n    if (!ConvertFromV8(isolate, val, &save_type))\n      return false;\n    save_type = base::ToLowerASCII(save_type);\n    if (save_type == \"htmlonly\") {\n      *out = content::SAVE_PAGE_TYPE_AS_ONLY_HTML;\n    } else if (save_type == \"htmlcomplete\") {\n      *out = content::SAVE_PAGE_TYPE_AS_COMPLETE_HTML;\n    } else if (save_type == \"mhtml\") {\n      *out = content::SAVE_PAGE_TYPE_AS_MHTML;\n    } else {\n      return false;\n    }\n    return true;\n  }\n};\n\ntemplate <>\nstruct Converter<electron::api::WebContents::Type> {\n  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,\n                                   electron::api::WebContents::Type val) {\n    using Type = electron::api::WebContents::Type;\n    std::string type;\n    switch (val) {\n      case Type::BACKGROUND_PAGE:\n        type = \"backgroundPage\";\n        break;\n      case Type::BROWSER_WINDOW:\n        type = \"window\";\n        break;\n      case Type::BROWSER_VIEW:\n        type = \"browserView\";\n        break;\n      case Type::REMOTE:\n        type = \"remote\";\n        break;\n      case Type::WEB_VIEW:\n        type = \"webview\";\n        break;\n      case Type::OFF_SCREEN:\n        type = \"offscreen\";\n        break;\n      default:\n        break;\n    }\n    return gin::ConvertToV8(isolate, type);\n  }\n\n  static bool FromV8(v8::Isolate* isolate,\n                     v8::Local<v8::Value> val,\n                     electron::api::WebContents::Type* out) {\n    using Type = electron::api::WebContents::Type;\n    std::string type;\n    if (!ConvertFromV8(isolate, val, &type))\n      return false;\n    if (type == \"backgroundPage\") {\n      *out = Type::BACKGROUND_PAGE;\n    } else if (type == \"browserView\") {\n      *out = Type::BROWSER_VIEW;\n    } else if (type == \"webview\") {\n      *out = Type::WEB_VIEW;\n#if BUILDFLAG(ENABLE_OSR)\n    } else if (type == \"offscreen\") {\n      *out = Type::OFF_SCREEN;\n#endif\n    } else {\n      return false;\n    }\n    return true;\n  }\n};\n\ntemplate <>\nstruct Converter<scoped_refptr<content::DevToolsAgentHost>> {\n  static v8::Local<v8::Value> ToV8(\n      v8::Isolate* isolate,\n      const scoped_refptr<content::DevToolsAgentHost>& val) {\n    gin_helper::Dictionary dict(isolate, v8::Object::New(isolate));\n    dict.Set(\"id\", val->GetId());\n    dict.Set(\"url\", val->GetURL().spec());\n    return dict.GetHandle();\n  }\n};\n\n}  // namespace gin\n\nnamespace electron {\n\nnamespace api {\n\nnamespace {\n\n// Called when CapturePage is done.\nvoid OnCapturePageDone(gin_helper::Promise<gfx::Image> promise,\n                       const SkBitmap& bitmap) {\n  // Hack to enable transparency in captured image\n  promise.Resolve(gfx::Image::CreateFrom1xBitmap(bitmap));\n}\n\nbase::Optional<base::TimeDelta> GetCursorBlinkInterval() {\n#if defined(OS_MACOSX)\n  base::TimeDelta interval;\n  if (ui::TextInsertionCaretBlinkPeriod(&interval))\n    return interval;\n#elif defined(OS_LINUX)\n  if (auto* linux_ui = views::LinuxUI::instance())\n    return linux_ui->GetCursorBlinkInterval();\n#elif defined(OS_WIN)\n  const auto system_msec = ::GetCaretBlinkTime();\n  if (system_msec != 0) {\n    return (system_msec == INFINITE)\n               ? base::TimeDelta()\n               : base::TimeDelta::FromMilliseconds(system_msec);\n  }\n#endif\n  return base::nullopt;\n}\n\n#if BUILDFLAG(ENABLE_PRINTING)\n// This will return false if no printer with the provided device_name can be\n// found on the network. We need to check this because Chromium does not do\n// sanity checking of device_name validity and so will crash on invalid names.\nbool IsDeviceNameValid(const base::string16& device_name) {\n#if defined(OS_MACOSX)\n  base::ScopedCFTypeRef<CFStringRef> new_printer_id(\n      base::SysUTF16ToCFStringRef(device_name));\n  PMPrinter new_printer = PMPrinterCreateFromPrinterID(new_printer_id.get());\n  bool printer_exists = new_printer != nullptr;\n  PMRelease(new_printer);\n  return printer_exists;\n#elif defined(OS_WIN)\n  printing::ScopedPrinterHandle printer;\n  return printer.OpenPrinterWithName(device_name.c_str());\n#endif\n  return true;\n}\n\nbase::string16 GetDefaultPrinterAsync() {\n  base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,\n                                                base::BlockingType::MAY_BLOCK);\n\n  scoped_refptr<printing::PrintBackend> backend =\n      printing::PrintBackend::CreateInstance(\n          nullptr, g_browser_process->GetApplicationLocale());\n  std::string printer_name = backend->GetDefaultPrinterName();\n  return base::UTF8ToUTF16(printer_name);\n}\n#endif\n\n}  // namespace\n\nWebContents::WebContents(v8::Isolate* isolate,\n                         content::WebContents* web_contents)\n    : content::WebContentsObserver(web_contents),\n      type_(Type::REMOTE),\n      weak_factory_(this) {\n  auto session = Session::CreateFrom(isolate, GetBrowserContext());\n  session_.Reset(isolate, session.ToV8());\n\n  web_contents->SetUserAgentOverride(blink::UserAgentOverride::UserAgentOnly(\n                                         GetBrowserContext()->GetUserAgent()),\n                                     false);\n  Init(isolate);\n  AttachAsUserData(web_contents);\n  InitZoomController(web_contents, gin::Dictionary::CreateEmpty(isolate));\n#if BUILDFLAG(ENABLE_ELECTRON_EXTENSIONS)\n  extensions::ElectronExtensionWebContentsObserver::CreateForWebContents(\n      web_contents);\n  script_executor_.reset(new extensions::ScriptExecutor(web_contents));\n#endif\n  registry_.AddInterface(base::BindRepeating(&WebContents::BindElectronBrowser,\n                                             base::Unretained(this)));\n  receivers_.set_disconnect_handler(base::BindRepeating(\n      &WebContents::OnElectronBrowserConnectionError, base::Unretained(this)));\n}\n\nWebContents::WebContents(v8::Isolate* isolate,\n                         std::unique_ptr<content::WebContents> web_contents,\n                         Type type)\n    : content::WebContentsObserver(web_contents.get()),\n      type_(type),\n      weak_factory_(this) {\n  DCHECK(type != Type::REMOTE)\n      << \"Can't take ownership of a remote WebContents\";\n  auto session = Session::CreateFrom(isolate, GetBrowserContext());\n  session_.Reset(isolate, session.ToV8());\n  InitWithSessionAndOptions(isolate, std::move(web_contents), session,\n                            gin::Dictionary::CreateEmpty(isolate));\n}\n\nWebContents::WebContents(v8::Isolate* isolate,\n                         const gin_helper::Dictionary& options)\n    : weak_factory_(this) {\n  // Read options.\n  options.Get(\"backgroundThrottling\", &background_throttling_);\n\n  // Get type\n  options.Get(\"type\", &type_);\n\n#if BUILDFLAG(ENABLE_OSR)\n  bool b = false;\n  if (options.Get(options::kOffscreen, &b) && b)\n    type_ = Type::OFF_SCREEN;\n#endif\n\n  // Init embedder earlier\n  options.Get(\"embedder\", &embedder_);\n\n  // Whether to enable DevTools.\n  options.Get(\"devTools\", &enable_devtools_);\n\n  // BrowserViews are not attached to a window initially so they should start\n  // off as hidden. This is also important for compositor recycling. See:\n  // https://github.com/electron/electron/pull/21372\n  bool initially_shown = type_ != Type::BROWSER_VIEW;\n  options.Get(options::kShow, &initially_shown);\n\n  // Obtain the session.\n  std::string partition;\n  gin::Handle<api::Session> session;\n  if (options.Get(\"session\", &session) && !session.IsEmpty()) {\n  } else if (options.Get(\"partition\", &partition)) {\n    session = Session::FromPartition(isolate, partition);\n  } else {\n    // Use the default session if not specified.\n    session = Session::FromPartition(isolate, \"\");\n  }\n  session_.Reset(isolate, session.ToV8());\n\n  std::unique_ptr<content::WebContents> web_contents;\n  if (IsGuest()) {\n    scoped_refptr<content::SiteInstance> site_instance =\n        content::SiteInstance::CreateForURL(session->browser_context(),\n                                            GURL(\"chrome-guest://fake-host\"));\n    content::WebContents::CreateParams params(session->browser_context(),\n                                              site_instance);\n    guest_delegate_ =\n        std::make_unique<WebViewGuestDelegate>(embedder_->web_contents(), this);\n    params.guest_delegate = guest_delegate_.get();\n\n#if BUILDFLAG(ENABLE_OSR)\n    if (embedder_ && embedder_->IsOffScreen()) {\n      auto* view = new OffScreenWebContentsView(\n          false,\n          base::BindRepeating(&WebContents::OnPaint, base::Unretained(this)));\n      params.view = view;\n      params.delegate_view = view;\n\n      web_contents = content::WebContents::Create(params);\n      view->SetWebContents(web_contents.get());\n    } else {\n#endif\n      web_contents = content::WebContents::Create(params);\n#if BUILDFLAG(ENABLE_OSR)\n    }\n  } else if (IsOffScreen()) {\n    bool transparent = false;\n    options.Get(\"transparent\", &transparent);\n\n    content::WebContents::CreateParams params(session->browser_context());\n    auto* view = new OffScreenWebContentsView(\n        transparent,\n        base::BindRepeating(&WebContents::OnPaint, base::Unretained(this)));\n    params.view = view;\n    params.delegate_view = view;\n\n    web_contents = content::WebContents::Create(params);\n    view->SetWebContents(web_contents.get());\n#endif\n  } else {\n    content::WebContents::CreateParams params(session->browser_context());\n    params.initially_hidden = !initially_shown;\n    web_contents = content::WebContents::Create(params);\n  }\n\n  InitWithSessionAndOptions(isolate, std::move(web_contents), session, options);\n}\n\nvoid WebContents::InitZoomController(content::WebContents* web_contents,\n                                     const gin_helper::Dictionary& options) {\n  WebContentsZoomController::CreateForWebContents(web_contents);\n  zoom_controller_ = WebContentsZoomController::FromWebContents(web_contents);\n  double zoom_factor;\n  if (options.Get(options::kZoomFactor, &zoom_factor))\n    zoom_controller_->SetDefaultZoomFactor(zoom_factor);\n}\n\nvoid WebContents::InitWithSessionAndOptions(\n    v8::Isolate* isolate,\n    std::unique_ptr<content::WebContents> owned_web_contents,\n    gin::Handle<api::Session> session,\n    const gin_helper::Dictionary& options) {\n  Observe(owned_web_contents.get());\n  // TODO(zcbenz): Make InitWithWebContents take unique_ptr.\n  // At the time of writing we are going through a refactoring and I don't want\n  // to make other people's work harder.\n  InitWithWebContents(owned_web_contents.release(), session->browser_context(),\n                      IsGuest());\n\n  managed_web_contents()->GetView()->SetDelegate(this);\n\n  auto* prefs = web_contents()->GetMutableRendererPrefs();\n\n  // Collect preferred languages from OS and browser process. accept_languages\n  // effects HTTP header, navigator.languages, and CJK fallback font selection.\n  //\n  // Note that an application locale set to the browser process might be\n  // different with the one set to the preference list.\n  // (e.g. overridden with --lang)\n  std::string accept_languages =\n      g_browser_process->GetApplicationLocale() + \",\";\n  for (auto const& language : electron::GetPreferredLanguages()) {\n    if (language == g_browser_process->GetApplicationLocale())\n      continue;\n    accept_languages += language + \",\";\n  }\n  accept_languages.pop_back();\n  prefs->accept_languages = accept_languages;\n\n#if defined(OS_LINUX) || defined(OS_WIN)\n  // Update font settings.\n  static const base::NoDestructor<gfx::FontRenderParams> params(\n      gfx::GetFontRenderParams(gfx::FontRenderParamsQuery(), nullptr));\n  prefs->should_antialias_text = params->antialiasing;\n  prefs->use_subpixel_positioning = params->subpixel_positioning;\n  prefs->hinting = params->hinting;\n  prefs->use_autohinter = params->autohinter;\n  prefs->use_bitmaps = params->use_bitmaps;\n  prefs->subpixel_rendering = params->subpixel_rendering;\n#endif\n\n  // Honor the system's cursor blink rate settings\n  if (auto interval = GetCursorBlinkInterval())\n    prefs->caret_blink_interval = *interval;\n\n  // Save the preferences in C++.\n  new WebContentsPreferences(web_contents(), options);\n\n  WebContentsPermissionHelper::CreateForWebContents(web_contents());\n  SecurityStateTabHelper::CreateForWebContents(web_contents());\n  InitZoomController(web_contents(), options);\n#if BUILDFLAG(ENABLE_ELECTRON_EXTENSIONS)\n  extensions::ElectronExtensionWebContentsObserver::CreateForWebContents(\n      web_contents());\n  script_executor_.reset(new extensions::ScriptExecutor(web_contents()));\n#endif\n\n  registry_.AddInterface(base::BindRepeating(&WebContents::BindElectronBrowser,\n                                             base::Unretained(this)));\n  receivers_.set_disconnect_handler(base::BindRepeating(\n      &WebContents::OnElectronBrowserConnectionError, base::Unretained(this)));\n  AutofillDriverFactory::CreateForWebContents(web_contents());\n\n  web_contents()->SetUserAgentOverride(blink::UserAgentOverride::UserAgentOnly(\n                                           GetBrowserContext()->GetUserAgent()),\n                                       false);\n\n  if (IsGuest()) {\n    NativeWindow* owner_window = nullptr;\n    if (embedder_) {\n      // New WebContents's owner_window is the embedder's owner_window.\n      auto* relay =\n          NativeWindowRelay::FromWebContents(embedder_->web_contents());\n      if (relay)\n        owner_window = relay->GetNativeWindow();\n    }\n    if (owner_window)\n      SetOwnerWindow(owner_window);\n  }\n\n  Init(isolate);\n  AttachAsUserData(web_contents());\n}\n\nWebContents::~WebContents() {\n  // The destroy() is called.\n  if (managed_web_contents()) {\n    managed_web_contents()->GetView()->SetDelegate(nullptr);\n\n    RenderViewDeleted(web_contents()->GetRenderViewHost());\n\n    if (type_ == Type::BROWSER_WINDOW && owner_window()) {\n      // For BrowserWindow we should close the window and clean up everything\n      // before WebContents is destroyed.\n      for (ExtendedWebContentsObserver& observer : observers_)\n        observer.OnCloseContents();\n      // BrowserWindow destroys WebContents asynchronously, manually emit the\n      // destroyed event here.\n      WebContentsDestroyed();\n    } else if (Browser::Get()->is_shutting_down()) {\n      // Destroy WebContents directly when app is shutting down.\n      DestroyWebContents(false /* async */);\n    } else {\n      // Destroy WebContents asynchronously unless app is shutting down,\n      // because destroy() might be called inside WebContents's event handler.\n      DestroyWebContents(!IsGuest() /* async */);\n      // The WebContentsDestroyed will not be called automatically because we\n      // destroy the webContents in the next tick. So we have to manually\n      // call it here to make sure \"destroyed\" event is emitted.\n      WebContentsDestroyed();\n    }\n  }\n}\n\nvoid WebContents::DestroyWebContents(bool async) {\n  // This event is only for internal use, which is emitted when WebContents is\n  // being destroyed.\n  Emit(\"will-destroy\");\n  ResetManagedWebContents(async);\n}\n\nbool WebContents::DidAddMessageToConsole(\n    content::WebContents* source,\n    blink::mojom::ConsoleMessageLevel level,\n    const base::string16& message,\n    int32_t line_no,\n    const base::string16& source_id) {\n  return Emit(\"console-message\", static_cast<int32_t>(level), message, line_no,\n              source_id);\n}\n\nvoid WebContents::OnCreateWindow(\n    const GURL& target_url,\n    const content::Referrer& referrer,\n    const std::string& frame_name,\n    WindowOpenDisposition disposition,\n    const std::string& features,\n    const scoped_refptr<network::ResourceRequestBody>& body) {\n  Emit(\"-new-window\", target_url, frame_name, disposition, features, referrer,\n       body);\n}\n\nvoid WebContents::WebContentsCreatedWithFullParams(\n    content::WebContents* source_contents,\n    int opener_render_process_id,\n    int opener_render_frame_id,\n    const content::mojom::CreateNewWindowParams& params,\n    content::WebContents* new_contents) {\n  ChildWebContentsTracker::CreateForWebContents(new_contents);\n  auto* tracker = ChildWebContentsTracker::FromWebContents(new_contents);\n  tracker->url = params.target_url;\n  tracker->frame_name = params.frame_name;\n  tracker->referrer = params.referrer.To<content::Referrer>();\n  tracker->raw_features = params.raw_features;\n  tracker->body = params.body;\n}\n\nbool WebContents::IsWebContentsCreationOverridden(\n    content::SiteInstance* source_site_instance,\n    content::mojom::WindowContainerType window_container_type,\n    const GURL& opener_url,\n    const std::string& frame_name,\n    const GURL& target_url) {\n  if (Emit(\"-will-add-new-contents\", target_url, frame_name)) {\n    return true;\n  }\n  return false;\n}\n\ncontent::WebContents* WebContents::CreateCustomWebContents(\n    content::RenderFrameHost* opener,\n    content::SiteInstance* source_site_instance,\n    bool is_new_browsing_instance,\n    const GURL& opener_url,\n    const std::string& frame_name,\n    const GURL& target_url,\n    const std::string& partition_id,\n    content::SessionStorageNamespace* session_storage_namespace) {\n  return nullptr;\n}\n\nvoid WebContents::AddNewContents(\n    content::WebContents* source,\n    std::unique_ptr<content::WebContents> new_contents,\n    const GURL& target_url,\n    WindowOpenDisposition disposition,\n    const gfx::Rect& initial_rect,\n    bool user_gesture,\n    bool* was_blocked) {\n  auto* tracker = ChildWebContentsTracker::FromWebContents(new_contents.get());\n  DCHECK(tracker);\n\n  v8::Locker locker(isolate());\n  v8::HandleScope handle_scope(isolate());\n  auto api_web_contents =\n      CreateAndTake(isolate(), std::move(new_contents), Type::BROWSER_WINDOW);\n  if (Emit(\"-add-new-contents\", api_web_contents, disposition, user_gesture,\n           initial_rect.x(), initial_rect.y(), initial_rect.width(),\n           initial_rect.height(), tracker->url, tracker->frame_name,\n           tracker->referrer, tracker->raw_features, tracker->body)) {\n    // TODO(zcbenz): Can we make this sync?\n    api_web_contents->DestroyWebContents(true /* async */);\n  }\n}\n\ncontent::WebContents* WebContents::OpenURLFromTab(\n    content::WebContents* source,\n    const content::OpenURLParams& params) {\n  if (params.disposition != WindowOpenDisposition::CURRENT_TAB) {\n    Emit(\"-new-window\", params.url, \"\", params.disposition, \"\", params.referrer,\n         params.post_data);\n    return nullptr;\n  }\n\n  // Give user a chance to cancel navigation.\n  if (Emit(\"will-navigate\", params.url))\n    return nullptr;\n\n  // Don't load the URL if the web contents was marked as destroyed from a\n  // will-navigate event listener\n  if (IsDestroyed())\n    return nullptr;\n\n  return CommonWebContentsDelegate::OpenURLFromTab(source, params);\n}\n\nvoid WebContents::BeforeUnloadFired(content::WebContents* tab,\n                                    bool proceed,\n                                    bool* proceed_to_fire_unload) {\n  if (type_ == Type::BROWSER_WINDOW || type_ == Type::OFF_SCREEN)\n    *proceed_to_fire_unload = proceed;\n  else\n    *proceed_to_fire_unload = true;\n  // Note that Chromium does not emit this for navigations.\n  Emit(\"before-unload-fired\", proceed);\n}\n\nvoid WebContents::SetContentsBounds(content::WebContents* source,\n                                    const gfx::Rect& rect) {\n  for (ExtendedWebContentsObserver& observer : observers_)\n    observer.OnSetContentBounds(rect);\n}\n\nvoid WebContents::CloseContents(content::WebContents* source) {\n  Emit(\"close\");\n\n  auto* autofill_driver_factory =\n      AutofillDriverFactory::FromWebContents(web_contents());\n  if (autofill_driver_factory) {\n    autofill_driver_factory->CloseAllPopups();\n  }\n\n  if (managed_web_contents())\n    managed_web_contents()->GetView()->SetDelegate(nullptr);\n  for (ExtendedWebContentsObserver& observer : observers_)\n    observer.OnCloseContents();\n}\n\nvoid WebContents::ActivateContents(content::WebContents* source) {\n  for (ExtendedWebContentsObserver& observer : observers_)\n    observer.OnActivateContents();\n}\n\nvoid WebContents::UpdateTargetURL(content::WebContents* source,\n                                  const GURL& url) {\n  Emit(\"update-target-url\", url);\n}\n\nbool WebContents::HandleKeyboardEvent(\n    content::WebContents* source,\n    const content::NativeWebKeyboardEvent& event) {\n  if (type_ == Type::WEB_VIEW && embedder_) {\n    // Send the unhandled keyboard events back to the embedder.\n    return embedder_->HandleKeyboardEvent(source, event);\n  } else {\n    // Go to the default keyboard handling.\n    return CommonWebContentsDelegate::HandleKeyboardEvent(source, event);\n  }\n}\n\ncontent::KeyboardEventProcessingResult WebContents::PreHandleKeyboardEvent(\n    content::WebContents* source,\n    const content::NativeWebKeyboardEvent& event) {\n  if (event.GetType() == blink::WebInputEvent::Type::kRawKeyDown ||\n      event.GetType() == blink::WebInputEvent::Type::kKeyUp) {\n    bool prevent_default = Emit(\"before-input-event\", event);\n    if (prevent_default) {\n      return content::KeyboardEventProcessingResult::HANDLED;\n    }\n  }\n\n  return content::KeyboardEventProcessingResult::NOT_HANDLED;\n}\n\nvoid WebContents::ContentsZoomChange(bool zoom_in) {\n  Emit(\"zoom-changed\", zoom_in ? \"in\" : \"out\");\n}\n\nvoid WebContents::EnterFullscreenModeForTab(\n    content::RenderFrameHost* requesting_frame,\n    const blink::mojom::FullscreenOptions& options) {\n  auto* source = content::WebContents::FromRenderFrameHost(requesting_frame);\n  auto* permission_helper =\n      WebContentsPermissionHelper::FromWebContents(source);\n  auto callback =\n      base::BindRepeating(&WebContents::OnEnterFullscreenModeForTab,\n                          base::Unretained(this), requesting_frame, options);\n  permission_helper->RequestFullscreenPermission(callback);\n}\n\nvoid WebContents::OnEnterFullscreenModeForTab(\n    content::RenderFrameHost* requesting_frame,\n    const blink::mojom::FullscreenOptions& options,\n    bool allowed) {\n  if (!allowed)\n    return;\n  CommonWebContentsDelegate::EnterFullscreenModeForTab(requesting_frame,\n                                                       options);\n  Emit(\"enter-html-full-screen\");\n}\n\nvoid WebContents::ExitFullscreenModeForTab(content::WebContents* source) {\n  CommonWebContentsDelegate::ExitFullscreenModeForTab(source);\n  Emit(\"leave-html-full-screen\");\n}\n\nvoid WebContents::RendererUnresponsive(\n    content::WebContents* source,\n    content::RenderWidgetHost* render_widget_host,\n    base::RepeatingClosure hang_monitor_restarter) {\n  Emit(\"unresponsive\");\n}\n\nvoid WebContents::RendererResponsive(\n    content::WebContents* source,\n    content::RenderWidgetHost* render_widget_host) {\n  Emit(\"responsive\");\n}\n\nbool WebContents::HandleContextMenu(content::RenderFrameHost* render_frame_host,\n                                    const content::ContextMenuParams& params) {\n  if (params.custom_context.is_pepper_menu) {\n    Emit(\"pepper-context-menu\", std::make_pair(params, web_contents()),\n         base::BindOnce(&content::WebContents::NotifyContextMenuClosed,\n                        base::Unretained(web_contents()),\n                        params.custom_context));\n  } else {\n    Emit(\"context-menu\", std::make_pair(params, web_contents()));\n  }\n\n  return true;\n}\n\nbool WebContents::OnGoToEntryOffset(int offset) {\n  GoToOffset(offset);\n  return false;\n}\n\nvoid WebContents::FindReply(content::WebContents* web_contents,\n                            int request_id,\n                            int number_of_matches,\n                            const gfx::Rect& selection_rect,\n                            int active_match_ordinal,\n                            bool final_update) {\n  if (!final_update)\n    return;\n\n  v8::Locker locker(isolate());\n  v8::HandleScope handle_scope(isolate());\n  gin_helper::Dictionary result = gin::Dictionary::CreateEmpty(isolate());\n  result.Set(\"requestId\", request_id);\n  result.Set(\"matches\", number_of_matches);\n  result.Set(\"selectionArea\", selection_rect);\n  result.Set(\"activeMatchOrdinal\", active_match_ordinal);\n  result.Set(\"finalUpdate\", final_update);  // Deprecate after 2.0\n  Emit(\"found-in-page\", result.GetHandle());\n}\n\nbool WebContents::CheckMediaAccessPermission(\n    content::RenderFrameHost* render_frame_host,\n    const GURL& security_origin,\n    blink::mojom::MediaStreamType type) {\n  auto* web_contents =\n      content::WebContents::FromRenderFrameHost(render_frame_host);\n  auto* permission_helper =\n      WebContentsPermissionHelper::FromWebContents(web_contents);\n  return permission_helper->CheckMediaAccessPermission(security_origin, type);\n}\n\nvoid WebContents::RequestMediaAccessPermission(\n    content::WebContents* web_contents,\n    const content::MediaStreamRequest& request,\n    content::MediaResponseCallback callback) {\n  auto* permission_helper =\n      WebContentsPermissionHelper::FromWebContents(web_contents);\n  permission_helper->RequestMediaAccessPermission(request, std::move(callback));\n}\n\nvoid WebContents::RequestToLockMouse(content::WebContents* web_contents,\n                                     bool user_gesture,\n                                     bool last_unlocked_by_target) {\n  auto* permission_helper =\n      WebContentsPermissionHelper::FromWebContents(web_contents);\n  permission_helper->RequestPointerLockPermission(user_gesture);\n}\n\nstd::unique_ptr<content::BluetoothChooser> WebContents::RunBluetoothChooser(\n    content::RenderFrameHost* frame,\n    const content::BluetoothChooser::EventHandler& event_handler) {\n  return std::make_unique<BluetoothChooser>(this, event_handler);\n}\n\ncontent::JavaScriptDialogManager* WebContents::GetJavaScriptDialogManager(\n    content::WebContents* source) {\n  if (!dialog_manager_)\n    dialog_manager_ = std::make_unique<ElectronJavaScriptDialogManager>(this);\n\n  return dialog_manager_.get();\n}\n\nvoid WebContents::OnAudioStateChanged(bool audible) {\n  Emit(\"-audio-state-changed\", audible);\n}\n\nvoid WebContents::BeforeUnloadFired(bool proceed,\n                                    const base::TimeTicks& proceed_time) {\n  // Do nothing, we override this method just to avoid compilation error since\n  // there are two virtual functions named BeforeUnloadFired.\n}\n\nvoid WebContents::RenderViewCreated(content::RenderViewHost* render_view_host) {\n  if (!background_throttling_)\n    render_view_host->SetSchedulerThrottling(false);\n}\n\nvoid WebContents::RenderFrameCreated(\n    content::RenderFrameHost* render_frame_host) {\n  auto* rwhv = render_frame_host->GetView();\n  if (!rwhv)\n    return;\n\n  auto* rwh_impl =\n      static_cast<content::RenderWidgetHostImpl*>(rwhv->GetRenderWidgetHost());\n  if (rwh_impl)\n    rwh_impl->disable_hidden_ = !background_throttling_;\n}\n\nvoid WebContents::RenderViewHostChanged(content::RenderViewHost* old_host,\n                                        content::RenderViewHost* new_host) {\n  currently_committed_process_id_ = new_host->GetProcess()->GetID();\n}\n\nvoid WebContents::RenderViewDeleted(content::RenderViewHost* render_view_host) {\n  // This event is necessary for tracking any states with respect to\n  // intermediate render view hosts aka speculative render view hosts. Currently\n  // used by object-registry.js to ref count remote objects.\n  Emit(\"render-view-deleted\", render_view_host->GetProcess()->GetID());\n\n  if (-1 == currently_committed_process_id_ ||\n      render_view_host->GetProcess()->GetID() ==\n          currently_committed_process_id_) {\n    currently_committed_process_id_ = -1;\n\n    // When the RVH that has been deleted is the current RVH it means that the\n    // the web contents are being closed. This is communicated by this event.\n    // Currently tracked by guest-window-manager.js to destroy the\n    // BrowserWindow.\n    Emit(\"current-render-view-deleted\",\n         render_view_host->GetProcess()->GetID());\n  }\n}\n\nvoid WebContents::RenderProcessGone(base::TerminationStatus status) {\n  Emit(\"crashed\", status == base::TERMINATION_STATUS_PROCESS_WAS_KILLED);\n  v8::HandleScope handle_scope(isolate());\n  gin_helper::Dictionary details =\n      gin_helper::Dictionary::CreateEmpty(isolate());\n  details.Set(\"reason\", status);\n  Emit(\"render-process-gone\", details);\n}\n\nvoid WebContents::PluginCrashed(const base::FilePath& plugin_path,\n                                base::ProcessId plugin_pid) {\n#if BUILDFLAG(ENABLE_PLUGINS)\n  content::WebPluginInfo info;\n  auto* plugin_service = content::PluginService::GetInstance();\n  plugin_service->GetPluginInfoByPath(plugin_path, &info);\n  Emit(\"plugin-crashed\", info.name, info.version);\n#endif  // BUILDFLAG(ENABLE_PLUIGNS)\n}\n\nvoid WebContents::MediaStartedPlaying(const MediaPlayerInfo& video_type,\n                                      const content::MediaPlayerId& id) {\n  Emit(\"media-started-playing\");\n}\n\nvoid WebContents::MediaStoppedPlaying(\n    const MediaPlayerInfo& video_type,\n    const content::MediaPlayerId& id,\n    content::WebContentsObserver::MediaStoppedReason reason) {\n  Emit(\"media-paused\");\n}\n\nvoid WebContents::DidChangeThemeColor() {\n  auto theme_color = web_contents()->GetThemeColor();\n  if (theme_color) {\n    Emit(\"did-change-theme-color\", electron::ToRGBHex(theme_color.value()));\n  } else {\n    Emit(\"did-change-theme-color\", nullptr);\n  }\n}\n\nvoid WebContents::OnInterfaceRequestFromFrame(\n    content::RenderFrameHost* render_frame_host,\n    const std::string& interface_name,\n    mojo::ScopedMessagePipeHandle* interface_pipe) {\n  registry_.TryBindInterface(interface_name, interface_pipe, render_frame_host);\n}\n\nvoid WebContents::DidAcquireFullscreen(content::RenderFrameHost* rfh) {\n  set_fullscreen_frame(rfh);\n}\n\nvoid WebContents::DOMContentLoaded(\n    content::RenderFrameHost* render_frame_host) {\n  if (!render_frame_host->GetParent())\n    Emit(\"dom-ready\");\n}\n\nvoid WebContents::DidFinishLoad(content::RenderFrameHost* render_frame_host,\n                                const GURL& validated_url) {\n  bool is_main_frame = !render_frame_host->GetParent();\n  int frame_process_id = render_frame_host->GetProcess()->GetID();\n  int frame_routing_id = render_frame_host->GetRoutingID();\n  auto weak_this = GetWeakPtr();\n  Emit(\"did-frame-finish-load\", is_main_frame, frame_process_id,\n       frame_routing_id);\n\n  // \u26a0\ufe0fWARNING!\u26a0\ufe0f\n  // Emit() triggers JS which can call destroy() on |this|. It's not safe to\n  // assume that |this| points to valid memory at this point.\n  if (is_main_frame && weak_this)\n    Emit(\"did-finish-load\");\n}\n\nvoid WebContents::DidFailLoad(content::RenderFrameHost* render_frame_host,\n                              const GURL& url,\n                              int error_code) {\n  bool is_main_frame = !render_frame_host->GetParent();\n  int frame_process_id = render_frame_host->GetProcess()->GetID();\n  int frame_routing_id = render_frame_host->GetRoutingID();\n  Emit(\"did-fail-load\", error_code, \"\", url, is_main_frame, frame_process_id,\n       frame_routing_id);\n}\n\nvoid WebContents::DidStartLoading() {\n  Emit(\"did-start-loading\");\n}\n\nvoid WebContents::DidStopLoading() {\n  Emit(\"did-stop-loading\");\n}\n\nbool WebContents::EmitNavigationEvent(\n    const std::string& event,\n    content::NavigationHandle* navigation_handle) {\n  bool is_main_frame = navigation_handle->IsInMainFrame();\n  int frame_tree_node_id = navigation_handle->GetFrameTreeNodeId();\n  content::FrameTreeNode* frame_tree_node =\n      content::FrameTreeNode::GloballyFindByID(frame_tree_node_id);\n  content::RenderFrameHostManager* render_manager =\n      frame_tree_node->render_manager();\n  content::RenderFrameHost* frame_host = nullptr;\n  if (render_manager) {\n    frame_host = render_manager->speculative_frame_host();\n    if (!frame_host)\n      frame_host = render_manager->current_frame_host();\n  }\n  int frame_process_id = -1, frame_routing_id = -1;\n  if (frame_host) {\n    frame_process_id = frame_host->GetProcess()->GetID();\n    frame_routing_id = frame_host->GetRoutingID();\n  }\n  bool is_same_document = navigation_handle->IsSameDocument();\n  auto url = navigation_handle->GetURL();\n  return Emit(event, url, is_same_document, is_main_frame, frame_process_id,\n              frame_routing_id);\n}\n\nvoid WebContents::BindElectronBrowser(\n    mojo::PendingReceiver<mojom::ElectronBrowser> receiver,\n    content::RenderFrameHost* render_frame_host) {\n  auto id = receivers_.Add(this, std::move(receiver), render_frame_host);\n  frame_to_receivers_map_[render_frame_host].push_back(id);\n}\n\nvoid WebContents::OnElectronBrowserConnectionError() {\n  auto receiver_id = receivers_.current_receiver();\n  auto* frame_host = receivers_.current_context();\n  base::Erase(frame_to_receivers_map_[frame_host], receiver_id);\n}\n\nvoid WebContents::Message(bool internal,\n                          const std::string& channel,\n                          blink::CloneableMessage arguments) {\n  TRACE_EVENT1(\"electron\", \"WebContents::Message\", \"channel\", channel);\n  // webContents.emit('-ipc-message', new Event(), internal, channel,\n  // arguments);\n  EmitWithSender(\"-ipc-message\", receivers_.current_context(), InvokeCallback(),\n                 internal, channel, std::move(arguments));\n}\n\nvoid WebContents::Invoke(bool internal,\n                         const std::string& channel,\n                         blink::CloneableMessage arguments,\n                         InvokeCallback callback) {\n  TRACE_EVENT1(\"electron\", \"WebContents::Invoke\", \"channel\", channel);\n  // webContents.emit('-ipc-invoke', new Event(), internal, channel, arguments);\n  EmitWithSender(\"-ipc-invoke\", receivers_.current_context(),\n                 std::move(callback), internal, channel, std::move(arguments));\n}\n\nvoid WebContents::ReceivePostMessage(const std::string& channel,\n                                     blink::TransferableMessage message) {\n  v8::HandleScope handle_scope(isolate());\n  auto wrapped_ports =\n      MessagePort::EntanglePorts(isolate(), std::move(message.ports));\n  v8::Local<v8::Value> message_value =\n      electron::DeserializeV8Value(isolate(), message);\n  EmitWithSender(\"-ipc-ports\", receivers_.current_context(), InvokeCallback(),\n                 false, channel, message_value, std::move(wrapped_ports));\n}\n\nvoid WebContents::PostMessage(const std::string& channel,\n                              v8::Local<v8::Value> message_value,\n                              base::Optional<v8::Local<v8::Value>> transfer) {\n  blink::TransferableMessage transferable_message;\n  if (!electron::SerializeV8Value(isolate(), message_value,\n                                  &transferable_message)) {\n    // SerializeV8Value sets an exception.\n    return;\n  }\n\n  std::vector<gin::Handle<MessagePort>> wrapped_ports;\n  if (transfer) {\n    if (!gin::ConvertFromV8(isolate(), *transfer, &wrapped_ports)) {\n      isolate()->ThrowException(v8::Exception::Error(\n          gin::StringToV8(isolate(), \"Invalid value for transfer\")));\n      return;\n    }\n  }\n\n  bool threw_exception = false;\n  transferable_message.ports =\n      MessagePort::DisentanglePorts(isolate(), wrapped_ports, &threw_exception);\n  if (threw_exception)\n    return;\n\n  content::RenderFrameHost* frame_host = web_contents()->GetMainFrame();\n  mojo::AssociatedRemote<mojom::ElectronRenderer> electron_renderer;\n  frame_host->GetRemoteAssociatedInterfaces()->GetInterface(&electron_renderer);\n  electron_renderer->ReceivePostMessage(channel,\n                                        std::move(transferable_message));\n}\n\nvoid WebContents::MessageSync(bool internal,\n                              const std::string& channel,\n                              blink::CloneableMessage arguments,\n                              MessageSyncCallback callback) {\n  TRACE_EVENT1(\"electron\", \"WebContents::MessageSync\", \"channel\", channel);\n  // webContents.emit('-ipc-message-sync', new Event(sender, message), internal,\n  // channel, arguments);\n  EmitWithSender(\"-ipc-message-sync\", receivers_.current_context(),\n                 std::move(callback), internal, channel, std::move(arguments));\n}\n\nvoid WebContents::MessageTo(bool internal,\n                            bool send_to_all,\n                            int32_t web_contents_id,\n                            const std::string& channel,\n                            blink::CloneableMessage arguments) {\n  TRACE_EVENT1(\"electron\", \"WebContents::MessageTo\", \"channel\", channel);\n  auto* web_contents = gin_helper::TrackableObject<WebContents>::FromWeakMapID(\n      isolate(), web_contents_id);\n\n  if (web_contents) {\n    web_contents->SendIPCMessageWithSender(internal, send_to_all, channel,\n                                           std::move(arguments), ID());\n  }\n}\n\nvoid WebContents::MessageHost(const std::string& channel,\n                              blink::CloneableMessage arguments) {\n  TRACE_EVENT1(\"electron\", \"WebContents::MessageHost\", \"channel\", channel);\n  // webContents.emit('ipc-message-host', new Event(), channel, args);\n  EmitWithSender(\"ipc-message-host\", receivers_.current_context(),\n                 InvokeCallback(), channel, std::move(arguments));\n}\n\n#if BUILDFLAG(ENABLE_REMOTE_MODULE)\nvoid WebContents::DereferenceRemoteJSObject(const std::string& context_id,\n                                            int object_id,\n                                            int ref_count) {\n  base::ListValue args;\n  args.Append(context_id);\n  args.Append(object_id);\n  args.Append(ref_count);\n  EmitWithSender(\"-ipc-message\", receivers_.current_context(), InvokeCallback(),\n                 /* internal */ true, \"ELECTRON_BROWSER_DEREFERENCE\",\n                 std::move(args));\n}\n#endif\n\nvoid WebContents::UpdateDraggableRegions(\n    std::vector<mojom::DraggableRegionPtr> regions) {\n  for (ExtendedWebContentsObserver& observer : observers_)\n    observer.OnDraggableRegionsUpdated(regions);\n}\n\nvoid WebContents::RenderFrameDeleted(\n    content::RenderFrameHost* render_frame_host) {\n  // A RenderFrameHost can be destroyed before the related Mojo binding is\n  // closed, which can result in Mojo calls being sent for RenderFrameHosts\n  // that no longer exist. To prevent this from happening, when a\n  // RenderFrameHost goes away, we close all the bindings related to that\n  // frame.\n  auto it = frame_to_receivers_map_.find(render_frame_host);\n  if (it == frame_to_receivers_map_.end())\n    return;\n  for (auto id : it->second)\n    receivers_.Remove(id);\n  frame_to_receivers_map_.erase(it);\n}\n\nvoid WebContents::DidStartNavigation(\n    content::NavigationHandle* navigation_handle) {\n  EmitNavigationEvent(\"did-start-navigation\", navigation_handle);\n}\n\nvoid WebContents::DidRedirectNavigation(\n    content::NavigationHandle* navigation_handle) {\n  EmitNavigationEvent(\"did-redirect-navigation\", navigation_handle);\n}\n\nvoid WebContents::DidFinishNavigation(\n    content::NavigationHandle* navigation_handle) {\n  if (!navigation_handle->HasCommitted())\n    return;\n  bool is_main_frame = navigation_handle->IsInMainFrame();\n  content::RenderFrameHost* frame_host =\n      navigation_handle->GetRenderFrameHost();\n  int frame_process_id = -1, frame_routing_id = -1;\n  if (frame_host) {\n    frame_process_id = frame_host->GetProcess()->GetID();\n    frame_routing_id = frame_host->GetRoutingID();\n  }\n  if (!navigation_handle->IsErrorPage()) {\n    // FIXME: All the Emit() calls below could potentially result in |this|\n    // being destroyed (by JS listening for the event and calling\n    // webContents.destroy()).\n    auto url = navigation_handle->GetURL();\n    bool is_same_document = navigation_handle->IsSameDocument();\n    if (is_same_document) {\n      Emit(\"did-navigate-in-page\", url, is_main_frame, frame_process_id,\n           frame_routing_id);\n    } else {\n      const net::HttpResponseHeaders* http_response =\n          navigation_handle->GetResponseHeaders();\n      std::string http_status_text;\n      int http_response_code = -1;\n      if (http_response) {\n        http_status_text = http_response->GetStatusText();\n        http_response_code = http_response->response_code();\n      }\n      Emit(\"did-frame-navigate\", url, http_response_code, http_status_text,\n           is_main_frame, frame_process_id, frame_routing_id);\n      if (is_main_frame) {\n        Emit(\"did-navigate\", url, http_response_code, http_status_text);\n      }\n    }\n    if (IsGuest())\n      Emit(\"load-commit\", url, is_main_frame);\n  } else {\n    auto url = navigation_handle->GetURL();\n    int code = navigation_handle->GetNetErrorCode();\n    auto description = net::ErrorToShortString(code);\n    Emit(\"did-fail-provisional-load\", code, description, url, is_main_frame,\n         frame_process_id, frame_routing_id);\n\n    // Do not emit \"did-fail-load\" for canceled requests.\n    if (code != net::ERR_ABORTED)\n      Emit(\"did-fail-load\", code, description, url, is_main_frame,\n           frame_process_id, frame_routing_id);\n  }\n}\n\nvoid WebContents::TitleWasSet(content::NavigationEntry* entry) {\n  base::string16 final_title;\n  bool explicit_set = true;\n  if (entry) {\n    auto title = entry->GetTitle();\n    auto url = entry->GetURL();\n    if (url.SchemeIsFile() && title.empty()) {\n      final_title = base::UTF8ToUTF16(url.ExtractFileName());\n      explicit_set = false;\n    } else {\n      final_title = title;\n    }\n  }\n  for (ExtendedWebContentsObserver& observer : observers_)\n    observer.OnPageTitleUpdated(final_title, explicit_set);\n  Emit(\"page-title-updated\", final_title, explicit_set);\n}\n\nvoid WebContents::DidUpdateFaviconURL(\n    content::RenderFrameHost* render_frame_host,\n    const std::vector<blink::mojom::FaviconURLPtr>& urls) {\n  std::set<GURL> unique_urls;\n  for (const auto& iter : urls) {\n    if (iter->icon_type != blink::mojom::FaviconIconType::kFavicon)\n      continue;\n    const GURL& url = iter->icon_url;\n    if (url.is_valid())\n      unique_urls.insert(url);\n  }\n  Emit(\"page-favicon-updated\", unique_urls);\n}\n\nvoid WebContents::DevToolsReloadPage() {\n  Emit(\"devtools-reload-page\");\n}\n\nvoid WebContents::DevToolsFocused() {\n  Emit(\"devtools-focused\");\n}\n\nvoid WebContents::DevToolsOpened() {\n  v8::Locker locker(isolate());\n  v8::HandleScope handle_scope(isolate());\n  auto handle =\n      FromOrCreate(isolate(), managed_web_contents()->GetDevToolsWebContents());\n  devtools_web_contents_.Reset(isolate(), handle.ToV8());\n\n  // Set inspected tabID.\n  base::Value tab_id(ID());\n  managed_web_contents()->CallClientFunction(\"DevToolsAPI.setInspectedTabId\",\n                                             &tab_id, nullptr, nullptr);\n\n  // Inherit owner window in devtools when it doesn't have one.\n  auto* devtools = managed_web_contents()->GetDevToolsWebContents();\n  bool has_window = devtools->GetUserData(NativeWindowRelay::UserDataKey());\n  if (owner_window() && !has_window)\n    handle->SetOwnerWindow(devtools, owner_window());\n\n  Emit(\"devtools-opened\");\n}\n\nvoid WebContents::DevToolsClosed() {\n  v8::Locker locker(isolate());\n  v8::HandleScope handle_scope(isolate());\n  devtools_web_contents_.Reset();\n\n  Emit(\"devtools-closed\");\n}\n\nbool WebContents::OnMessageReceived(const IPC::Message& message) {\n  bool handled = true;\n  IPC_BEGIN_MESSAGE_MAP(WebContents, message)\n    IPC_MESSAGE_UNHANDLED(handled = false)\n  IPC_END_MESSAGE_MAP()\n\n  return handled;\n}\n\n// There are three ways of destroying a webContents:\n// 1. call webContents.destroy();\n// 2. garbage collection;\n// 3. user closes the window of webContents;\n// 4. the embedder detaches the frame.\n// For webview only #4 will happen, for BrowserWindow both #1 and #3 may\n// happen. The #2 should never happen for webContents, because webview is\n// managed by GuestViewManager, and BrowserWindow's webContents is managed\n// by api::BrowserWindow.\n// For #1, the destructor will do the cleanup work and we only need to make\n// sure \"destroyed\" event is emitted. For #3, the content::WebContents will\n// be destroyed on close, and WebContentsDestroyed would be called for it, so\n// we need to make sure the api::WebContents is also deleted.\n// For #4, the WebContents will be destroyed by embedder.\nvoid WebContents::WebContentsDestroyed() {\n  // Give chance for guest delegate to cleanup its observers\n  // since the native class is only destroyed in the next tick.\n  if (guest_delegate_)\n    guest_delegate_->WillDestroy();\n\n  // Cleanup relationships with other parts.\n  RemoveFromWeakMap();\n\n  // We can not call Destroy here because we need to call Emit first, but we\n  // also do not want any method to be used, so just mark as destroyed here.\n  MarkDestroyed();\n\n  Emit(\"destroyed\");\n\n  // For guest view based on OOPIF, the WebContents is released by the embedder\n  // frame, and we need to clear the reference to the memory.\n  if (IsGuest() && managed_web_contents()) {\n    managed_web_contents()->ReleaseWebContents();\n    ResetManagedWebContents(false);\n  }\n\n  // Destroy the native class in next tick.\n  base::ThreadTaskRunnerHandle::Get()->PostTask(FROM_HERE, GetDestroyClosure());\n}\n\nvoid WebContents::NavigationEntryCommitted(\n    const content::LoadCommittedDetails& details) {\n  Emit(\"navigation-entry-committed\", details.entry->GetURL(),\n       details.is_same_document, details.did_replace_entry);\n}\n\nbool WebContents::GetBackgroundThrottling() const {\n  return background_throttling_;\n}\n\nvoid WebContents::SetBackgroundThrottling(bool allowed) {\n  background_throttling_ = allowed;\n\n  auto* rfh = web_contents()->GetMainFrame();\n  if (!rfh)\n    return;\n\n  auto* rwhv = rfh->GetView();\n  if (!rwhv)\n    return;\n\n  auto* rwh_impl =\n      static_cast<content::RenderWidgetHostImpl*>(rwhv->GetRenderWidgetHost());\n  if (!rwh_impl)\n    return;\n\n  rwh_impl->disable_hidden_ = !background_throttling_;\n  web_contents()->GetRenderViewHost()->SetSchedulerThrottling(allowed);\n\n  if (rwh_impl->is_hidden()) {\n    rwh_impl->WasShown(base::nullopt);\n  }\n}\n\nint WebContents::GetProcessID() const {\n  return web_contents()->GetMainFrame()->GetProcess()->GetID();\n}\n\nbase::ProcessId WebContents::GetOSProcessID() const {\n  base::ProcessHandle process_handle =\n      web_contents()->GetMainFrame()->GetProcess()->GetProcess().Handle();\n  return base::GetProcId(process_handle);\n}\n\nbase::ProcessId WebContents::GetOSProcessIdForFrame(\n    const std::string& name,\n    const std::string& document_url) const {\n  for (auto* frame : web_contents()->GetAllFrames()) {\n    if (frame->GetFrameName() == name &&\n        frame->GetLastCommittedURL().spec() == document_url) {\n      return base::GetProcId(frame->GetProcess()->GetProcess().Handle());\n    }\n  }\n  return base::kNullProcessId;\n}\n\nWebContents::Type WebContents::GetType() const {\n  return type_;\n}\n\nbool WebContents::Equal(const WebContents* web_contents) const {\n  return ID() == web_contents->ID();\n}\n\nvoid WebContents::LoadURL(const GURL& url,\n                          const gin_helper::Dictionary& options) {\n  if (!url.is_valid() || url.spec().size() > url::kMaxURLChars) {\n    Emit(\"did-fail-load\", static_cast<int>(net::ERR_INVALID_URL),\n         net::ErrorToShortString(net::ERR_INVALID_URL),\n         url.possibly_invalid_spec(), true);\n    return;\n  }\n\n  content::NavigationController::LoadURLParams params(url);\n\n  if (!options.Get(\"httpReferrer\", &params.referrer)) {\n    GURL http_referrer;\n    if (options.Get(\"httpReferrer\", &http_referrer))\n      params.referrer =\n          content::Referrer(http_referrer.GetAsReferrer(),\n                            network::mojom::ReferrerPolicy::kDefault);\n  }\n\n  std::string user_agent;\n  if (options.Get(\"userAgent\", &user_agent))\n    web_contents()->SetUserAgentOverride(\n        blink::UserAgentOverride::UserAgentOnly(user_agent), false);\n\n  std::string extra_headers;\n  if (options.Get(\"extraHeaders\", &extra_headers))\n    params.extra_headers = extra_headers;\n\n  scoped_refptr<network::ResourceRequestBody> body;\n  if (options.Get(\"postData\", &body)) {\n    params.post_data = body;\n    params.load_type = content::NavigationController::LOAD_TYPE_HTTP_POST;\n  }\n\n  GURL base_url_for_data_url;\n  if (options.Get(\"baseURLForDataURL\", &base_url_for_data_url)) {\n    params.base_url_for_data_url = base_url_for_data_url;\n    params.load_type = content::NavigationController::LOAD_TYPE_DATA;\n  }\n\n  bool reload_ignoring_cache = false;\n  if (options.Get(\"reloadIgnoringCache\", &reload_ignoring_cache) &&\n      reload_ignoring_cache) {\n    params.reload_type = content::ReloadType::BYPASSING_CACHE;\n  }\n\n  // Calling LoadURLWithParams() can trigger JS which destroys |this|.\n  auto weak_this = GetWeakPtr();\n\n  // Required to make beforeunload handler work.\n  NotifyUserActivation();\n\n  params.transition_type = ui::PAGE_TRANSITION_TYPED;\n  params.should_clear_history_list = true;\n  params.override_user_agent = content::NavigationController::UA_OVERRIDE_TRUE;\n  // Discord non-committed entries to ensure that we don't re-use a pending\n  // entry\n  web_contents()->GetController().DiscardNonCommittedEntries();\n  web_contents()->GetController().LoadURLWithParams(params);\n\n  // \u26a0\ufe0fWARNING!\u26a0\ufe0f\n  // LoadURLWithParams() triggers JS events which can call destroy() on |this|.\n  // It's not safe to assume that |this| points to valid memory at this point.\n  if (!weak_this)\n    return;\n\n  // Set the background color of RenderWidgetHostView.\n  // We have to call it right after LoadURL because the RenderViewHost is only\n  // created after loading a page.\n  auto* const view = weak_this->web_contents()->GetRenderWidgetHostView();\n  if (view) {\n    auto* web_preferences = WebContentsPreferences::From(web_contents());\n    std::string color_name;\n    if (web_preferences->GetPreference(options::kBackgroundColor,\n                                       &color_name)) {\n      view->SetBackgroundColor(ParseHexColor(color_name));\n    } else {\n      view->SetBackgroundColor(SK_ColorTRANSPARENT);\n    }\n  }\n}\n\nvoid WebContents::DownloadURL(const GURL& url) {\n  auto* browser_context = web_contents()->GetBrowserContext();\n  auto* download_manager =\n      content::BrowserContext::GetDownloadManager(browser_context);\n  std::unique_ptr<download::DownloadUrlParameters> download_params(\n      content::DownloadRequestUtils::CreateDownloadForWebContentsMainFrame(\n          web_contents(), url, MISSING_TRAFFIC_ANNOTATION));\n  download_manager->DownloadUrl(std::move(download_params));\n}\n\nGURL WebContents::GetURL() const {\n  return web_contents()->GetURL();\n}\n\nbase::string16 WebContents::GetTitle() const {\n  return web_contents()->GetTitle();\n}\n\nbool WebContents::IsLoading() const {\n  return web_contents()->IsLoading();\n}\n\nbool WebContents::IsLoadingMainFrame() const {\n  return web_contents()->IsLoadingToDifferentDocument();\n}\n\nbool WebContents::IsWaitingForResponse() const {\n  return web_contents()->IsWaitingForResponse();\n}\n\nvoid WebContents::Stop() {\n  web_contents()->Stop();\n}\n\nvoid WebContents::GoBack() {\n  if (!ElectronBrowserClient::Get()->CanUseCustomSiteInstance()) {\n    electron::ElectronBrowserClient::SuppressRendererProcessRestartForOnce();\n  }\n  web_contents()->GetController().GoBack();\n}\n\nvoid WebContents::GoForward() {\n  if (!ElectronBrowserClient::Get()->CanUseCustomSiteInstance()) {\n    electron::ElectronBrowserClient::SuppressRendererProcessRestartForOnce();\n  }\n  web_contents()->GetController().GoForward();\n}\n\nvoid WebContents::GoToOffset(int offset) {\n  if (!ElectronBrowserClient::Get()->CanUseCustomSiteInstance()) {\n    electron::ElectronBrowserClient::SuppressRendererProcessRestartForOnce();\n  }\n  web_contents()->GetController().GoToOffset(offset);\n}\n\nconst std::string WebContents::GetWebRTCIPHandlingPolicy() const {\n  return web_contents()->GetMutableRendererPrefs()->webrtc_ip_handling_policy;\n}\n\nvoid WebContents::SetWebRTCIPHandlingPolicy(\n    const std::string& webrtc_ip_handling_policy) {\n  if (GetWebRTCIPHandlingPolicy() == webrtc_ip_handling_policy)\n    return;\n  web_contents()->GetMutableRendererPrefs()->webrtc_ip_handling_policy =\n      webrtc_ip_handling_policy;\n\n  web_contents()->SyncRendererPrefs();\n}\n\nbool WebContents::IsCrashed() const {\n  return web_contents()->IsCrashed();\n}\n\nvoid WebContents::SetUserAgent(const std::string& user_agent,\n                               gin_helper::Arguments* args) {\n  web_contents()->SetUserAgentOverride(\n      blink::UserAgentOverride::UserAgentOnly(user_agent), false);\n}\n\nstd::string WebContents::GetUserAgent() {\n  return web_contents()->GetUserAgentOverride().ua_string_override;\n}\n\nv8::Local<v8::Promise> WebContents::SavePage(\n    const base::FilePath& full_file_path,\n    const content::SavePageType& save_type) {\n  gin_helper::Promise<void> promise(isolate());\n  v8::Local<v8::Promise> handle = promise.GetHandle();\n\n  auto* handler = new SavePageHandler(web_contents(), std::move(promise));\n  handler->Handle(full_file_path, save_type);\n\n  return handle;\n}\n\nvoid WebContents::OpenDevTools(gin_helper::Arguments* args) {\n  if (type_ == Type::REMOTE)\n    return;\n\n  if (!enable_devtools_)\n    return;\n\n  std::string state;\n  if (type_ == Type::WEB_VIEW || !owner_window()) {\n    state = \"detach\";\n  }\n  bool activate = true;\n  if (args && args->Length() == 1) {\n    gin_helper::Dictionary options;\n    if (args->GetNext(&options)) {\n      options.Get(\"mode\", &state);\n      options.Get(\"activate\", &activate);\n    }\n  }\n  managed_web_contents()->SetDockState(state);\n  managed_web_contents()->ShowDevTools(activate);\n}\n\nvoid WebContents::CloseDevTools() {\n  if (type_ == Type::REMOTE)\n    return;\n\n  managed_web_contents()->CloseDevTools();\n}\n\nbool WebContents::IsDevToolsOpened() {\n  if (type_ == Type::REMOTE)\n    return false;\n\n  return managed_web_contents()->IsDevToolsViewShowing();\n}\n\nbool WebContents::IsDevToolsFocused() {\n  if (type_ == Type::REMOTE)\n    return false;\n\n  return managed_web_contents()->GetView()->IsDevToolsViewFocused();\n}\n\nvoid WebContents::EnableDeviceEmulation(\n    const blink::WebDeviceEmulationParams& params) {\n  if (type_ == Type::REMOTE)\n    return;\n\n  auto* frame_host = web_contents()->GetMainFrame();\n  if (frame_host) {\n    auto* widget_host =\n        frame_host ? frame_host->GetView()->GetRenderWidgetHost() : nullptr;\n    if (!widget_host)\n      return;\n    widget_host->Send(new WidgetMsg_EnableDeviceEmulation(\n        widget_host->GetRoutingID(), params));\n  }\n}\n\nvoid WebContents::DisableDeviceEmulation() {\n  if (type_ == Type::REMOTE)\n    return;\n\n  auto* frame_host = web_contents()->GetMainFrame();\n  if (frame_host) {\n    auto* widget_host =\n        frame_host ? frame_host->GetView()->GetRenderWidgetHost() : nullptr;\n    if (!widget_host)\n      return;\n    widget_host->Send(\n        new WidgetMsg_DisableDeviceEmulation(widget_host->GetRoutingID()));\n  }\n}\n\nvoid WebContents::ToggleDevTools() {\n  if (IsDevToolsOpened())\n    CloseDevTools();\n  else\n    OpenDevTools(nullptr);\n}\n\nvoid WebContents::InspectElement(int x, int y) {\n  if (type_ == Type::REMOTE)\n    return;\n\n  if (!enable_devtools_)\n    return;\n\n  if (!managed_web_contents()->GetDevToolsWebContents())\n    OpenDevTools(nullptr);\n  managed_web_contents()->InspectElement(x, y);\n}\n\nvoid WebContents::InspectSharedWorkerById(const std::string& workerId) {\n  if (type_ == Type::REMOTE)\n    return;\n\n  if (!enable_devtools_)\n    return;\n\n  for (const auto& agent_host : content::DevToolsAgentHost::GetOrCreateAll()) {\n    if (agent_host->GetType() ==\n        content::DevToolsAgentHost::kTypeSharedWorker) {\n      if (agent_host->GetId() == workerId) {\n        OpenDevTools(nullptr);\n        managed_web_contents()->AttachTo(agent_host);\n        break;\n      }\n    }\n  }\n}\n\nstd::vector<scoped_refptr<content::DevToolsAgentHost>>\nWebContents::GetAllSharedWorkers() {\n  std::vector<scoped_refptr<content::DevToolsAgentHost>> shared_workers;\n\n  if (type_ == Type::REMOTE)\n    return shared_workers;\n\n  if (!enable_devtools_)\n    return shared_workers;\n\n  for (const auto& agent_host : content::DevToolsAgentHost::GetOrCreateAll()) {\n    if (agent_host->GetType() ==\n        content::DevToolsAgentHost::kTypeSharedWorker) {\n      shared_workers.push_back(agent_host);\n    }\n  }\n  return shared_workers;\n}\n\nvoid WebContents::InspectSharedWorker() {\n  if (type_ == Type::REMOTE)\n    return;\n\n  if (!enable_devtools_)\n    return;\n\n  for (const auto& agent_host : content::DevToolsAgentHost::GetOrCreateAll()) {\n    if (agent_host->GetType() ==\n        content::DevToolsAgentHost::kTypeSharedWorker) {\n      OpenDevTools(nullptr);\n      managed_web_contents()->AttachTo(agent_host);\n      break;\n    }\n  }\n}\n\nvoid WebContents::InspectServiceWorker() {\n  if (type_ == Type::REMOTE)\n    return;\n\n  if (!enable_devtools_)\n    return;\n\n  for (const auto& agent_host : content::DevToolsAgentHost::GetOrCreateAll()) {\n    if (agent_host->GetType() ==\n        content::DevToolsAgentHost::kTypeServiceWorker) {\n      OpenDevTools(nullptr);\n      managed_web_contents()->AttachTo(agent_host);\n      break;\n    }\n  }\n}\n\nvoid WebContents::SetIgnoreMenuShortcuts(bool ignore) {\n  auto* web_preferences = WebContentsPreferences::From(web_contents());\n  DCHECK(web_preferences);\n  web_preferences->preference()->SetKey(\"ignoreMenuShortcuts\",\n                                        base::Value(ignore));\n}\n\nvoid WebContents::SetAudioMuted(bool muted) {\n  web_contents()->SetAudioMuted(muted);\n}\n\nbool WebContents::IsAudioMuted() {\n  return web_contents()->IsAudioMuted();\n}\n\nbool WebContents::IsCurrentlyAudible() {\n  return web_contents()->IsCurrentlyAudible();\n}\n\n#if BUILDFLAG(ENABLE_PRINTING)\nvoid WebContents::OnGetDefaultPrinter(\n    base::Value print_settings,\n    printing::CompletionCallback print_callback,\n    base::string16 device_name,\n    bool silent,\n    base::string16 default_printer) {\n  // The content::WebContents might be already deleted at this point, and the\n  // PrintViewManagerBasic class does not do null check.\n  if (!web_contents()) {\n    if (print_callback)\n      std::move(print_callback).Run(false, \"failed\");\n    return;\n  }\n\n  base::string16 printer_name =\n      device_name.empty() ? default_printer : device_name;\n\n  // If there are no valid printers available on the network, we bail.\n  if (printer_name.empty() || !IsDeviceNameValid(printer_name)) {\n    if (print_callback)\n      std::move(print_callback).Run(false, \"no valid printers available\");\n    return;\n  }\n\n  print_settings.SetStringKey(printing::kSettingDeviceName, printer_name);\n\n  auto* print_view_manager =\n      printing::PrintViewManagerBasic::FromWebContents(web_contents());\n  auto* focused_frame = web_contents()->GetFocusedFrame();\n  auto* rfh = focused_frame && focused_frame->HasSelection()\n                  ? focused_frame\n                  : web_contents()->GetMainFrame();\n\n  print_view_manager->PrintNow(rfh, silent, std::move(print_settings),\n                               std::move(print_callback));\n}\n\nvoid WebContents::Print(gin_helper::Arguments* args) {\n  gin_helper::Dictionary options =\n      gin::Dictionary::CreateEmpty(args->isolate());\n  base::Value settings(base::Value::Type::DICTIONARY);\n\n  if (args->Length() >= 1 && !args->GetNext(&options)) {\n    args->ThrowError(\"webContents.print(): Invalid print settings specified.\");\n    return;\n  }\n\n  printing::CompletionCallback callback;\n  if (args->Length() == 2 && !args->GetNext(&callback)) {\n    args->ThrowError(\n        \"webContents.print(): Invalid optional callback provided.\");\n    return;\n  }\n\n  // Set optional silent printing\n  bool silent = false;\n  options.Get(\"silent\", &silent);\n\n  bool print_background = false;\n  options.Get(\"printBackground\", &print_background);\n  settings.SetBoolKey(printing::kSettingShouldPrintBackgrounds,\n                      print_background);\n\n  // Set custom margin settings\n  gin_helper::Dictionary margins =\n      gin::Dictionary::CreateEmpty(args->isolate());\n  if (options.Get(\"margins\", &margins)) {\n    printing::MarginType margin_type = printing::DEFAULT_MARGINS;\n    margins.Get(\"marginType\", &margin_type);\n    settings.SetIntKey(printing::kSettingMarginsType, margin_type);\n\n    if (margin_type == printing::CUSTOM_MARGINS) {\n      base::Value custom_margins(base::Value::Type::DICTIONARY);\n      int top = 0;\n      margins.Get(\"top\", &top);\n      custom_margins.SetIntKey(printing::kSettingMarginTop, top);\n      int bottom = 0;\n      margins.Get(\"bottom\", &bottom);\n      custom_margins.SetIntKey(printing::kSettingMarginBottom, bottom);\n      int left = 0;\n      margins.Get(\"left\", &left);\n      custom_margins.SetIntKey(printing::kSettingMarginLeft, left);\n      int right = 0;\n      margins.Get(\"right\", &right);\n      custom_margins.SetIntKey(printing::kSettingMarginRight, right);\n      settings.SetPath(printing::kSettingMarginsCustom,\n                       std::move(custom_margins));\n    }\n  } else {\n    settings.SetIntKey(printing::kSettingMarginsType,\n                       printing::DEFAULT_MARGINS);\n  }\n\n  // Set whether to print color or greyscale\n  bool print_color = true;\n  options.Get(\"color\", &print_color);\n  int color_setting = print_color ? printing::COLOR : printing::GRAY;\n  settings.SetIntKey(printing::kSettingColor, color_setting);\n\n  // Is the orientation landscape or portrait.\n  bool landscape = false;\n  options.Get(\"landscape\", &landscape);\n  settings.SetBoolKey(printing::kSettingLandscape, landscape);\n\n  // We set the default to the system's default printer and only update\n  // if at the Chromium level if the user overrides.\n  // Printer device name as opened by the OS.\n  base::string16 device_name;\n  options.Get(\"deviceName\", &device_name);\n  if (!device_name.empty() && !IsDeviceNameValid(device_name)) {\n    args->ThrowError(\"webContents.print(): Invalid deviceName provided.\");\n    return;\n  }\n\n  int scale_factor = 100;\n  options.Get(\"scaleFactor\", &scale_factor);\n  settings.SetIntKey(printing::kSettingScaleFactor, scale_factor);\n\n  int pages_per_sheet = 1;\n  options.Get(\"pagesPerSheet\", &pages_per_sheet);\n  settings.SetIntKey(printing::kSettingPagesPerSheet, pages_per_sheet);\n\n  // True if the user wants to print with collate.\n  bool collate = true;\n  options.Get(\"collate\", &collate);\n  settings.SetBoolKey(printing::kSettingCollate, collate);\n\n  // The number of individual copies to print\n  int copies = 1;\n  options.Get(\"copies\", &copies);\n  settings.SetIntKey(printing::kSettingCopies, copies);\n\n  // Strings to be printed as headers and footers if requested by the user.\n  std::string header;\n  options.Get(\"header\", &header);\n  std::string footer;\n  options.Get(\"footer\", &footer);\n\n  if (!(header.empty() && footer.empty())) {\n    settings.SetBoolKey(printing::kSettingHeaderFooterEnabled, true);\n\n    settings.SetStringKey(printing::kSettingHeaderFooterTitle, header);\n    settings.SetStringKey(printing::kSettingHeaderFooterURL, footer);\n  } else {\n    settings.SetBoolKey(printing::kSettingHeaderFooterEnabled, false);\n  }\n\n  // We don't want to allow the user to enable these settings\n  // but we need to set them or a CHECK is hit.\n  settings.SetIntKey(printing::kSettingPrinterType,\n                     static_cast<int>(printing::PrinterType::kLocal));\n  settings.SetBoolKey(printing::kSettingShouldPrintSelectionOnly, false);\n  settings.SetBoolKey(printing::kSettingRasterizePdf, false);\n\n  // Set custom page ranges to print\n  std::vector<gin_helper::Dictionary> page_ranges;\n  if (options.Get(\"pageRanges\", &page_ranges)) {\n    base::Value page_range_list(base::Value::Type::LIST);\n    for (auto& range : page_ranges) {\n      int from, to;\n      if (range.Get(\"from\", &from) && range.Get(\"to\", &to)) {\n        base::Value range(base::Value::Type::DICTIONARY);\n        range.SetIntKey(printing::kSettingPageRangeFrom, from);\n        range.SetIntKey(printing::kSettingPageRangeTo, to);\n        page_range_list.Append(std::move(range));\n      } else {\n        continue;\n      }\n    }\n    if (page_range_list.GetList().size() > 0)\n      settings.SetPath(printing::kSettingPageRange, std::move(page_range_list));\n  }\n\n  // Duplex type user wants to use.\n  printing::mojom::DuplexMode duplex_mode =\n      printing::mojom::DuplexMode::kSimplex;\n  options.Get(\"duplexMode\", &duplex_mode);\n  settings.SetIntKey(printing::kSettingDuplexMode,\n                     static_cast<int>(duplex_mode));\n\n  // We've already done necessary parameter sanitization at the\n  // JS level, so we can simply pass this through.\n  base::Value media_size(base::Value::Type::DICTIONARY);\n  if (options.Get(\"mediaSize\", &media_size))\n    settings.SetKey(printing::kSettingMediaSize, std::move(media_size));\n\n  // Set custom dots per inch (dpi)\n  gin_helper::Dictionary dpi_settings;\n  int dpi = 72;\n  if (options.Get(\"dpi\", &dpi_settings)) {\n    int horizontal = 72;\n    dpi_settings.Get(\"horizontal\", &horizontal);\n    settings.SetIntKey(printing::kSettingDpiHorizontal, horizontal);\n    int vertical = 72;\n    dpi_settings.Get(\"vertical\", &vertical);\n    settings.SetIntKey(printing::kSettingDpiVertical, vertical);\n  } else {\n    settings.SetIntKey(printing::kSettingDpiHorizontal, dpi);\n    settings.SetIntKey(printing::kSettingDpiVertical, dpi);\n  }\n\n  base::ThreadPool::PostTaskAndReplyWithResult(\n      FROM_HERE, {base::MayBlock(), base::TaskPriority::USER_BLOCKING},\n      base::BindOnce(&GetDefaultPrinterAsync),\n      base::BindOnce(&WebContents::OnGetDefaultPrinter,\n                     weak_factory_.GetWeakPtr(), std::move(settings),\n                     std::move(callback), device_name, silent));\n}\n\nstd::vector<printing::PrinterBasicInfo> WebContents::GetPrinterList() {\n  std::vector<printing::PrinterBasicInfo> printers;\n  auto print_backend = printing::PrintBackend::CreateInstance(\n      nullptr, g_browser_process->GetApplicationLocale());\n  {\n    // TODO(deepak1556): Deprecate this api in favor of an\n    // async version and post a non blocing task call.\n    base::ThreadRestrictions::ScopedAllowIO allow_io;\n    print_backend->EnumeratePrinters(&printers);\n  }\n  return printers;\n}\n\nv8::Local<v8::Promise> WebContents::PrintToPDF(base::DictionaryValue settings) {\n  gin_helper::Promise<v8::Local<v8::Value>> promise(isolate());\n  v8::Local<v8::Promise> handle = promise.GetHandle();\n  PrintPreviewMessageHandler::FromWebContents(web_contents())\n      ->PrintToPDF(std::move(settings), std::move(promise));\n  return handle;\n}\n#endif\n\nvoid WebContents::AddWorkSpace(gin_helper::Arguments* args,\n                               const base::FilePath& path) {\n  if (path.empty()) {\n    args->ThrowError(\"path cannot be empty\");\n    return;\n  }\n  DevToolsAddFileSystem(std::string(), path);\n}\n\nvoid WebContents::RemoveWorkSpace(gin_helper::Arguments* args,\n                                  const base::FilePath& path) {\n  if (path.empty()) {\n    args->ThrowError(\"path cannot be empty\");\n    return;\n  }\n  DevToolsRemoveFileSystem(path);\n}\n\nvoid WebContents::Undo() {\n  web_contents()->Undo();\n}\n\nvoid WebContents::Redo() {\n  web_contents()->Redo();\n}\n\nvoid WebContents::Cut() {\n  web_contents()->Cut();\n}\n\nvoid WebContents::Copy() {\n  web_contents()->Copy();\n}\n\nvoid WebContents::Paste() {\n  web_contents()->Paste();\n}\n\nvoid WebContents::PasteAndMatchStyle() {\n  web_contents()->PasteAndMatchStyle();\n}\n\nvoid WebContents::Delete() {\n  web_contents()->Delete();\n}\n\nvoid WebContents::SelectAll() {\n  web_contents()->SelectAll();\n}\n\nvoid WebContents::Unselect() {\n  web_contents()->CollapseSelection();\n}\n\nvoid WebContents::Replace(const base::string16& word) {\n  web_contents()->Replace(word);\n}\n\nvoid WebContents::ReplaceMisspelling(const base::string16& word) {\n  web_contents()->ReplaceMisspelling(word);\n}\n\nuint32_t WebContents::FindInPage(gin_helper::Arguments* args) {\n  base::string16 search_text;\n  if (!args->GetNext(&search_text) || search_text.empty()) {\n    args->ThrowError(\"Must provide a non-empty search content\");\n    return 0;\n  }\n\n  uint32_t request_id = GetNextRequestId();\n  gin_helper::Dictionary dict;\n  auto options = blink::mojom::FindOptions::New();\n  if (args->GetNext(&dict)) {\n    dict.Get(\"forward\", &options->forward);\n    dict.Get(\"matchCase\", &options->match_case);\n    dict.Get(\"findNext\", &options->new_session);\n  }\n\n  web_contents()->Find(request_id, search_text, std::move(options));\n  return request_id;\n}\n\nvoid WebContents::StopFindInPage(content::StopFindAction action) {\n  web_contents()->StopFinding(action);\n}\n\nvoid WebContents::ShowDefinitionForSelection() {\n#if defined(OS_MACOSX)\n  auto* const view = web_contents()->GetRenderWidgetHostView();\n  if (view)\n    view->ShowDefinitionForSelection();\n#endif\n}\n\nvoid WebContents::CopyImageAt(int x, int y) {\n  auto* const host = web_contents()->GetMainFrame();\n  if (host)\n    host->CopyImageAt(x, y);\n}\n\nvoid WebContents::Focus() {\n  // Focusing on WebContents does not automatically focus the window on macOS\n  // and Linux, do it manually to match the behavior on Windows.\n#if defined(OS_MACOSX) || defined(OS_LINUX)\n  if (owner_window())\n    owner_window()->Focus(true);\n#endif\n  web_contents()->Focus();\n}\n\n#if !defined(OS_MACOSX)\nbool WebContents::IsFocused() const {\n  auto* view = web_contents()->GetRenderWidgetHostView();\n  if (!view)\n    return false;\n\n  if (GetType() != Type::BACKGROUND_PAGE) {\n    auto* window = web_contents()->GetNativeView()->GetToplevelWindow();\n    if (window && !window->IsVisible())\n      return false;\n  }\n\n  return view->HasFocus();\n}\n#endif\n\nvoid WebContents::TabTraverse(bool reverse) {\n  web_contents()->FocusThroughTabTraversal(reverse);\n}\n\nbool WebContents::SendIPCMessage(bool internal,\n                                 bool send_to_all,\n                                 const std::string& channel,\n                                 v8::Local<v8::Value> args) {\n  blink::CloneableMessage message;\n  if (!gin::ConvertFromV8(isolate(), args, &message)) {\n    isolate()->ThrowException(v8::Exception::Error(\n        gin::StringToV8(isolate(), \"Failed to serialize arguments\")));\n    return false;\n  }\n  return SendIPCMessageWithSender(internal, send_to_all, channel,\n                                  std::move(message));\n}\n\nbool WebContents::SendIPCMessageWithSender(bool internal,\n                                           bool send_to_all,\n                                           const std::string& channel,\n                                           blink::CloneableMessage args,\n                                           int32_t sender_id) {\n  std::vector<content::RenderFrameHost*> target_hosts;\n  if (!send_to_all) {\n    auto* frame_host = web_contents()->GetMainFrame();\n    if (frame_host) {\n      target_hosts.push_back(frame_host);\n    }\n  } else {\n    target_hosts = web_contents()->GetAllFrames();\n  }\n\n  for (auto* frame_host : target_hosts) {\n    mojo::AssociatedRemote<mojom::ElectronRenderer> electron_renderer;\n    frame_host->GetRemoteAssociatedInterfaces()->GetInterface(\n        &electron_renderer);\n    electron_renderer->Message(internal, false, channel, args.ShallowClone(),\n                               sender_id);\n  }\n  return true;\n}\n\nbool WebContents::SendIPCMessageToFrame(bool internal,\n                                        bool send_to_all,\n                                        int32_t frame_id,\n                                        const std::string& channel,\n                                        v8::Local<v8::Value> args) {\n  blink::CloneableMessage message;\n  if (!gin::ConvertFromV8(isolate(), args, &message)) {\n    isolate()->ThrowException(v8::Exception::Error(\n        gin::StringToV8(isolate(), \"Failed to serialize arguments\")));\n    return false;\n  }\n  auto frames = web_contents()->GetAllFrames();\n  auto iter = std::find_if(frames.begin(), frames.end(), [frame_id](auto* f) {\n    return f->GetRoutingID() == frame_id;\n  });\n  if (iter == frames.end())\n    return false;\n  if (!(*iter)->IsRenderFrameLive())\n    return false;\n\n  mojo::AssociatedRemote<mojom::ElectronRenderer> electron_renderer;\n  (*iter)->GetRemoteAssociatedInterfaces()->GetInterface(&electron_renderer);\n  electron_renderer->Message(internal, send_to_all, channel, std::move(message),\n                             0 /* sender_id */);\n  return true;\n}\n\nvoid WebContents::SendInputEvent(v8::Isolate* isolate,\n                                 v8::Local<v8::Value> input_event) {\n  content::RenderWidgetHostView* view =\n      web_contents()->GetRenderWidgetHostView();\n  if (!view)\n    return;\n\n  content::RenderWidgetHost* rwh = view->GetRenderWidgetHost();\n  blink::WebInputEvent::Type type =\n      gin::GetWebInputEventType(isolate, input_event);\n  if (blink::WebInputEvent::IsMouseEventType(type)) {\n    blink::WebMouseEvent mouse_event;\n    if (gin::ConvertFromV8(isolate, input_event, &mouse_event)) {\n      if (IsOffScreen()) {\n#if BUILDFLAG(ENABLE_OSR)\n        GetOffScreenRenderWidgetHostView()->SendMouseEvent(mouse_event);\n#endif\n      } else {\n        rwh->ForwardMouseEvent(mouse_event);\n      }\n      return;\n    }\n  } else if (blink::WebInputEvent::IsKeyboardEventType(type)) {\n    content::NativeWebKeyboardEvent keyboard_event(\n        blink::WebKeyboardEvent::Type::kRawKeyDown,\n        blink::WebInputEvent::Modifiers::kNoModifiers, ui::EventTimeForNow());\n    if (gin::ConvertFromV8(isolate, input_event, &keyboard_event)) {\n      rwh->ForwardKeyboardEvent(keyboard_event);\n      return;\n    }\n  } else if (type == blink::WebInputEvent::Type::kMouseWheel) {\n    blink::WebMouseWheelEvent mouse_wheel_event;\n    if (gin::ConvertFromV8(isolate, input_event, &mouse_wheel_event)) {\n      if (IsOffScreen()) {\n#if BUILDFLAG(ENABLE_OSR)\n        GetOffScreenRenderWidgetHostView()->SendMouseWheelEvent(\n            mouse_wheel_event);\n#endif\n      } else {\n        // Chromium expects phase info in wheel events (and applies a\n        // DCHECK to verify it). See: https://crbug.com/756524.\n        mouse_wheel_event.phase = blink::WebMouseWheelEvent::kPhaseBegan;\n        mouse_wheel_event.dispatch_type =\n            blink::WebInputEvent::DispatchType::kBlocking;\n        rwh->ForwardWheelEvent(mouse_wheel_event);\n\n        // Send a synthetic wheel event with phaseEnded to finish scrolling.\n        mouse_wheel_event.has_synthetic_phase = true;\n        mouse_wheel_event.delta_x = 0;\n        mouse_wheel_event.delta_y = 0;\n        mouse_wheel_event.phase = blink::WebMouseWheelEvent::kPhaseEnded;\n        mouse_wheel_event.dispatch_type =\n            blink::WebInputEvent::DispatchType::kEventNonBlocking;\n        rwh->ForwardWheelEvent(mouse_wheel_event);\n      }\n      return;\n    }\n  }\n\n  isolate->ThrowException(\n      v8::Exception::Error(gin::StringToV8(isolate, \"Invalid event object\")));\n}\n\nvoid WebContents::BeginFrameSubscription(gin_helper::Arguments* args) {\n  bool only_dirty = false;\n  FrameSubscriber::FrameCaptureCallback callback;\n\n  args->GetNext(&only_dirty);\n  if (!args->GetNext(&callback)) {\n    args->ThrowError();\n    return;\n  }\n\n  frame_subscriber_ =\n      std::make_unique<FrameSubscriber>(web_contents(), callback, only_dirty);\n}\n\nvoid WebContents::EndFrameSubscription() {\n  frame_subscriber_.reset();\n}\n\nvoid WebContents::StartDrag(const gin_helper::Dictionary& item,\n                            gin_helper::Arguments* args) {\n  base::FilePath file;\n  std::vector<base::FilePath> files;\n  if (!item.Get(\"files\", &files) && item.Get(\"file\", &file)) {\n    files.push_back(file);\n  }\n\n  gin::Handle<NativeImage> icon;\n  if (!item.Get(\"icon\", &icon) || icon->image().IsEmpty()) {\n    args->ThrowError(\"Must specify non-empty 'icon' option\");\n    return;\n  }\n\n  // Start dragging.\n  if (!files.empty()) {\n    base::MessageLoopCurrent::ScopedNestableTaskAllower allow;\n    DragFileItems(files, icon->image(), web_contents()->GetNativeView());\n  } else {\n    args->ThrowError(\"Must specify either 'file' or 'files' option\");\n  }\n}\n\nv8::Local<v8::Promise> WebContents::CapturePage(gin_helper::Arguments* args) {\n  gfx::Rect rect;\n  gin_helper::Promise<gfx::Image> promise(isolate());\n  v8::Local<v8::Promise> handle = promise.GetHandle();\n\n  // get rect arguments if they exist\n  args->GetNext(&rect);\n\n  auto* const view = web_contents()->GetRenderWidgetHostView();\n  if (!view) {\n    promise.Resolve(gfx::Image());\n    return handle;\n  }\n\n  // Capture full page if user doesn't specify a |rect|.\n  const gfx::Size view_size =\n      rect.IsEmpty() ? view->GetViewBounds().size() : rect.size();\n\n  // By default, the requested bitmap size is the view size in screen\n  // coordinates.  However, if there's more pixel detail available on the\n  // current system, increase the requested bitmap size to capture it all.\n  gfx::Size bitmap_size = view_size;\n  const gfx::NativeView native_view = view->GetNativeView();\n  const float scale = display::Screen::GetScreen()\n                          ->GetDisplayNearestView(native_view)\n                          .device_scale_factor();\n  if (scale > 1.0f)\n    bitmap_size = gfx::ScaleToCeiledSize(view_size, scale);\n\n  view->CopyFromSurface(gfx::Rect(rect.origin(), view_size), bitmap_size,\n                        base::BindOnce(&OnCapturePageDone, std::move(promise)));\n  return handle;\n}\n\nvoid WebContents::IncrementCapturerCount(gin_helper::Arguments* args) {\n  gfx::Size size;\n  bool stay_hidden = false;\n\n  // get size arguments if they exist\n  args->GetNext(&size);\n  // get stayHidden arguments if they exist\n  args->GetNext(&stay_hidden);\n\n  web_contents()->IncrementCapturerCount(size, stay_hidden);\n}\n\nvoid WebContents::DecrementCapturerCount(gin_helper::Arguments* args) {\n  bool stay_hidden = false;\n\n  // get stayHidden arguments if they exist\n  args->GetNext(&stay_hidden);\n\n  web_contents()->DecrementCapturerCount(stay_hidden);\n}\n\nbool WebContents::IsBeingCaptured() {\n  return web_contents()->IsBeingCaptured();\n}\n\nvoid WebContents::OnCursorChanged(const content::WebCursor& webcursor) {\n  const ui::Cursor& cursor = webcursor.cursor();\n\n  if (cursor.type() == ui::mojom::CursorType::kCustom) {\n    Emit(\"cursor-changed\", CursorTypeToString(cursor),\n         gfx::Image::CreateFrom1xBitmap(cursor.custom_bitmap()),\n         cursor.image_scale_factor(),\n         gfx::Size(cursor.custom_bitmap().width(),\n                   cursor.custom_bitmap().height()),\n         cursor.custom_hotspot());\n  } else {\n    Emit(\"cursor-changed\", CursorTypeToString(cursor));\n  }\n}\n\nbool WebContents::IsGuest() const {\n  return type_ == Type::WEB_VIEW;\n}\n\nvoid WebContents::AttachToIframe(content::WebContents* embedder_web_contents,\n                                 int embedder_frame_id) {\n  if (guest_delegate_)\n    guest_delegate_->AttachToIframe(embedder_web_contents, embedder_frame_id);\n}\n\nbool WebContents::IsOffScreen() const {\n#if BUILDFLAG(ENABLE_OSR)\n  return type_ == Type::OFF_SCREEN;\n#else\n  return false;\n#endif\n}\n\n#if BUILDFLAG(ENABLE_OSR)\nvoid WebContents::OnPaint(const gfx::Rect& dirty_rect, const SkBitmap& bitmap) {\n  Emit(\"paint\", dirty_rect, gfx::Image::CreateFrom1xBitmap(bitmap));\n}\n\nvoid WebContents::StartPainting() {\n  auto* osr_wcv = GetOffScreenWebContentsView();\n  if (osr_wcv)\n    osr_wcv->SetPainting(true);\n}\n\nvoid WebContents::StopPainting() {\n  auto* osr_wcv = GetOffScreenWebContentsView();\n  if (osr_wcv)\n    osr_wcv->SetPainting(false);\n}\n\nbool WebContents::IsPainting() const {\n  auto* osr_wcv = GetOffScreenWebContentsView();\n  return osr_wcv && osr_wcv->IsPainting();\n}\n\nvoid WebContents::SetFrameRate(int frame_rate) {\n  auto* osr_wcv = GetOffScreenWebContentsView();\n  if (osr_wcv)\n    osr_wcv->SetFrameRate(frame_rate);\n}\n\nint WebContents::GetFrameRate() const {\n  auto* osr_wcv = GetOffScreenWebContentsView();\n  return osr_wcv ? osr_wcv->GetFrameRate() : 0;\n}\n#endif\n\nvoid WebContents::Invalidate() {\n  if (IsOffScreen()) {\n#if BUILDFLAG(ENABLE_OSR)\n    auto* osr_rwhv = GetOffScreenRenderWidgetHostView();\n    if (osr_rwhv)\n      osr_rwhv->Invalidate();\n#endif\n  } else {\n    auto* const window = owner_window();\n    if (window)\n      window->Invalidate();\n  }\n}\n\ngfx::Size WebContents::GetSizeForNewRenderView(content::WebContents* wc) {\n  if (IsOffScreen() && wc == web_contents()) {\n    auto* relay = NativeWindowRelay::FromWebContents(web_contents());\n    if (relay) {\n      auto* owner_window = relay->GetNativeWindow();\n      return owner_window ? owner_window->GetSize() : gfx::Size();\n    }\n  }\n\n  return gfx::Size();\n}\n\nvoid WebContents::SetZoomLevel(double level) {\n  zoom_controller_->SetZoomLevel(level);\n}\n\ndouble WebContents::GetZoomLevel() const {\n  return zoom_controller_->GetZoomLevel();\n}\n\nvoid WebContents::SetZoomFactor(gin_helper::ErrorThrower thrower,\n                                double factor) {\n  if (factor < std::numeric_limits<double>::epsilon()) {\n    thrower.ThrowError(\"'zoomFactor' must be a double greater than 0.0\");\n    return;\n  }\n\n  auto level = blink::PageZoomFactorToZoomLevel(factor);\n  SetZoomLevel(level);\n}\n\ndouble WebContents::GetZoomFactor() const {\n  auto level = GetZoomLevel();\n  return blink::PageZoomLevelToZoomFactor(level);\n}\n\nvoid WebContents::SetTemporaryZoomLevel(double level) {\n  zoom_controller_->SetTemporaryZoomLevel(level);\n}\n\nvoid WebContents::DoGetZoomLevel(DoGetZoomLevelCallback callback) {\n  std::move(callback).Run(GetZoomLevel());\n}\n\nstd::vector<base::FilePath::StringType> WebContents::GetPreloadPaths() const {\n  auto result = SessionPreferences::GetValidPreloads(GetBrowserContext());\n\n  if (auto* web_preferences = WebContentsPreferences::From(web_contents())) {\n    base::FilePath::StringType preload;\n    if (web_preferences->GetPreloadPath(&preload)) {\n      result.emplace_back(preload);\n    }\n  }\n\n  return result;\n}\n\nv8::Local<v8::Value> WebContents::GetWebPreferences(\n    v8::Isolate* isolate) const {\n  auto* web_preferences = WebContentsPreferences::From(web_contents());\n  if (!web_preferences)\n    return v8::Null(isolate);\n  return gin::ConvertToV8(isolate, *web_preferences->preference());\n}\n\nv8::Local<v8::Value> WebContents::GetLastWebPreferences(\n    v8::Isolate* isolate) const {\n  auto* web_preferences = WebContentsPreferences::From(web_contents());\n  if (!web_preferences)\n    return v8::Null(isolate);\n  return gin::ConvertToV8(isolate, *web_preferences->last_preference());\n}\n\nv8::Local<v8::Value> WebContents::GetOwnerBrowserWindow() const {\n  if (owner_window())\n    return BrowserWindow::From(isolate(), owner_window());\n  else\n    return v8::Null(isolate());\n}\n\nint32_t WebContents::ID() const {\n  return weak_map_id();\n}\n\nv8::Local<v8::Value> WebContents::Session(v8::Isolate* isolate) {\n  return v8::Local<v8::Value>::New(isolate, session_);\n}\n\ncontent::WebContents* WebContents::HostWebContents() const {\n  if (!embedder_)\n    return nullptr;\n  return embedder_->web_contents();\n}\n\nvoid WebContents::SetEmbedder(const WebContents* embedder) {\n  if (embedder) {\n    NativeWindow* owner_window = nullptr;\n    auto* relay = NativeWindowRelay::FromWebContents(embedder->web_contents());\n    if (relay) {\n      owner_window = relay->GetNativeWindow();\n    }\n    if (owner_window)\n      SetOwnerWindow(owner_window);\n\n    content::RenderWidgetHostView* rwhv =\n        web_contents()->GetRenderWidgetHostView();\n    if (rwhv) {\n      rwhv->Hide();\n      rwhv->Show();\n    }\n  }\n}\n\nvoid WebContents::SetDevToolsWebContents(const WebContents* devtools) {\n  if (managed_web_contents())\n    managed_web_contents()->SetDevToolsWebContents(devtools->web_contents());\n}\n\nv8::Local<v8::Value> WebContents::GetNativeView() const {\n  gfx::NativeView ptr = web_contents()->GetNativeView();\n  auto buffer = node::Buffer::Copy(isolate(), reinterpret_cast<char*>(&ptr),\n                                   sizeof(gfx::NativeView));\n  if (buffer.IsEmpty())\n    return v8::Null(isolate());\n  else\n    return buffer.ToLocalChecked();\n}\n\nv8::Local<v8::Value> WebContents::DevToolsWebContents(v8::Isolate* isolate) {\n  if (devtools_web_contents_.IsEmpty())\n    return v8::Null(isolate);\n  else\n    return v8::Local<v8::Value>::New(isolate, devtools_web_contents_);\n}\n\nv8::Local<v8::Value> WebContents::Debugger(v8::Isolate* isolate) {\n  if (debugger_.IsEmpty()) {\n    auto handle = electron::api::Debugger::Create(isolate, web_contents());\n    debugger_.Reset(isolate, handle.ToV8());\n  }\n  return v8::Local<v8::Value>::New(isolate, debugger_);\n}\n\nvoid WebContents::GrantOriginAccess(const GURL& url) {\n  content::ChildProcessSecurityPolicy::GetInstance()->GrantCommitOrigin(\n      web_contents()->GetMainFrame()->GetProcess()->GetID(),\n      url::Origin::Create(url));\n}\n\nvoid WebContents::NotifyUserActivation() {\n  auto* frame = web_contents()->GetMainFrame();\n  if (!frame)\n    return;\n  mojo::AssociatedRemote<mojom::ElectronRenderer> renderer;\n  frame->GetRemoteAssociatedInterfaces()->GetInterface(&renderer);\n  renderer->NotifyUserActivation();\n}\n\nv8::Local<v8::Promise> WebContents::TakeHeapSnapshot(\n    const base::FilePath& file_path) {\n  gin_helper::Promise<void> promise(isolate());\n  v8::Local<v8::Promise> handle = promise.GetHandle();\n\n  base::ThreadRestrictions::ScopedAllowIO allow_io;\n  base::File file(file_path,\n                  base::File::FLAG_CREATE_ALWAYS | base::File::FLAG_WRITE);\n  if (!file.IsValid()) {\n    promise.RejectWithErrorMessage(\"takeHeapSnapshot failed\");\n    return handle;\n  }\n\n  auto* frame_host = web_contents()->GetMainFrame();\n  if (!frame_host) {\n    promise.RejectWithErrorMessage(\"takeHeapSnapshot failed\");\n    return handle;\n  }\n\n  // This dance with `base::Owned` is to ensure that the interface stays alive\n  // until the callback is called. Otherwise it would be closed at the end of\n  // this function.\n  auto electron_renderer =\n      std::make_unique<mojo::AssociatedRemote<mojom::ElectronRenderer>>();\n  frame_host->GetRemoteAssociatedInterfaces()->GetInterface(\n      electron_renderer.get());\n  auto* raw_ptr = electron_renderer.get();\n  (*raw_ptr)->TakeHeapSnapshot(\n      mojo::WrapPlatformFile(file.TakePlatformFile()),\n      base::BindOnce(\n          [](mojo::AssociatedRemote<mojom::ElectronRenderer>* ep,\n             gin_helper::Promise<void> promise, bool success) {\n            if (success) {\n              promise.Resolve();\n            } else {\n              promise.RejectWithErrorMessage(\"takeHeapSnapshot failed\");\n            }\n          },\n          base::Owned(std::move(electron_renderer)), std::move(promise)));\n  return handle;\n}\n\n// static\nvoid WebContents::BuildPrototype(v8::Isolate* isolate,\n                                 v8::Local<v8::FunctionTemplate> prototype) {\n  prototype->SetClassName(gin::StringToV8(isolate, \"WebContents\"));\n  gin_helper::Destroyable::MakeDestroyable(isolate, prototype);\n  gin_helper::ObjectTemplateBuilder(isolate, prototype->PrototypeTemplate())\n      .SetMethod(\"getBackgroundThrottling\",\n                 &WebContents::GetBackgroundThrottling)\n      .SetMethod(\"setBackgroundThrottling\",\n                 &WebContents::SetBackgroundThrottling)\n      .SetMethod(\"getProcessId\", &WebContents::GetProcessID)\n      .SetMethod(\"getOSProcessId\", &WebContents::GetOSProcessID)\n      .SetMethod(\"_getOSProcessIdForFrame\",\n                 &WebContents::GetOSProcessIdForFrame)\n      .SetMethod(\"equal\", &WebContents::Equal)\n      .SetMethod(\"_loadURL\", &WebContents::LoadURL)\n      .SetMethod(\"downloadURL\", &WebContents::DownloadURL)\n      .SetMethod(\"_getURL\", &WebContents::GetURL)\n      .SetMethod(\"getTitle\", &WebContents::GetTitle)\n      .SetMethod(\"isLoading\", &WebContents::IsLoading)\n      .SetMethod(\"isLoadingMainFrame\", &WebContents::IsLoadingMainFrame)\n      .SetMethod(\"isWaitingForResponse\", &WebContents::IsWaitingForResponse)\n      .SetMethod(\"_stop\", &WebContents::Stop)\n      .SetMethod(\"_goBack\", &WebContents::GoBack)\n      .SetMethod(\"_goForward\", &WebContents::GoForward)\n      .SetMethod(\"_goToOffset\", &WebContents::GoToOffset)\n      .SetMethod(\"isCrashed\", &WebContents::IsCrashed)\n      .SetMethod(\"setUserAgent\", &WebContents::SetUserAgent)\n      .SetMethod(\"getUserAgent\", &WebContents::GetUserAgent)\n      .SetMethod(\"savePage\", &WebContents::SavePage)\n      .SetMethod(\"openDevTools\", &WebContents::OpenDevTools)\n      .SetMethod(\"closeDevTools\", &WebContents::CloseDevTools)\n      .SetMethod(\"isDevToolsOpened\", &WebContents::IsDevToolsOpened)\n      .SetMethod(\"isDevToolsFocused\", &WebContents::IsDevToolsFocused)\n      .SetMethod(\"enableDeviceEmulation\", &WebContents::EnableDeviceEmulation)\n      .SetMethod(\"disableDeviceEmulation\", &WebContents::DisableDeviceEmulation)\n      .SetMethod(\"toggleDevTools\", &WebContents::ToggleDevTools)\n      .SetMethod(\"inspectElement\", &WebContents::InspectElement)\n      .SetMethod(\"setIgnoreMenuShortcuts\", &WebContents::SetIgnoreMenuShortcuts)\n      .SetMethod(\"setAudioMuted\", &WebContents::SetAudioMuted)\n      .SetMethod(\"isAudioMuted\", &WebContents::IsAudioMuted)\n      .SetMethod(\"isCurrentlyAudible\", &WebContents::IsCurrentlyAudible)\n      .SetMethod(\"undo\", &WebContents::Undo)\n      .SetMethod(\"redo\", &WebContents::Redo)\n      .SetMethod(\"cut\", &WebContents::Cut)\n      .SetMethod(\"copy\", &WebContents::Copy)\n      .SetMethod(\"paste\", &WebContents::Paste)\n      .SetMethod(\"pasteAndMatchStyle\", &WebContents::PasteAndMatchStyle)\n      .SetMethod(\"delete\", &WebContents::Delete)\n      .SetMethod(\"selectAll\", &WebContents::SelectAll)\n      .SetMethod(\"unselect\", &WebContents::Unselect)\n      .SetMethod(\"replace\", &WebContents::Replace)\n      .SetMethod(\"replaceMisspelling\", &WebContents::ReplaceMisspelling)\n      .SetMethod(\"findInPage\", &WebContents::FindInPage)\n      .SetMethod(\"stopFindInPage\", &WebContents::StopFindInPage)\n      .SetMethod(\"focus\", &WebContents::Focus)\n      .SetMethod(\"isFocused\", &WebContents::IsFocused)\n      .SetMethod(\"tabTraverse\", &WebContents::TabTraverse)\n      .SetMethod(\"_send\", &WebContents::SendIPCMessage)\n      .SetMethod(\"_postMessage\", &WebContents::PostMessage)\n      .SetMethod(\"_sendToFrame\", &WebContents::SendIPCMessageToFrame)\n      .SetMethod(\"sendInputEvent\", &WebContents::SendInputEvent)\n      .SetMethod(\"beginFrameSubscription\", &WebContents::BeginFrameSubscription)\n      .SetMethod(\"endFrameSubscription\", &WebContents::EndFrameSubscription)\n      .SetMethod(\"startDrag\", &WebContents::StartDrag)\n      .SetMethod(\"attachToIframe\", &WebContents::AttachToIframe)\n      .SetMethod(\"detachFromOuterFrame\", &WebContents::DetachFromOuterFrame)\n      .SetMethod(\"isOffscreen\", &WebContents::IsOffScreen)\n#if BUILDFLAG(ENABLE_OSR)\n      .SetMethod(\"startPainting\", &WebContents::StartPainting)\n      .SetMethod(\"stopPainting\", &WebContents::StopPainting)\n      .SetMethod(\"isPainting\", &WebContents::IsPainting)\n      .SetMethod(\"setFrameRate\", &WebContents::SetFrameRate)\n      .SetMethod(\"getFrameRate\", &WebContents::GetFrameRate)\n#endif\n      .SetMethod(\"invalidate\", &WebContents::Invalidate)\n      .SetMethod(\"setZoomLevel\", &WebContents::SetZoomLevel)\n      .SetMethod(\"getZoomLevel\", &WebContents::GetZoomLevel)\n      .SetMethod(\"setZoomFactor\", &WebContents::SetZoomFactor)\n      .SetMethod(\"getZoomFactor\", &WebContents::GetZoomFactor)\n      .SetMethod(\"getType\", &WebContents::GetType)\n      .SetMethod(\"_getPreloadPaths\", &WebContents::GetPreloadPaths)\n      .SetMethod(\"getWebPreferences\", &WebContents::GetWebPreferences)\n      .SetMethod(\"getLastWebPreferences\", &WebContents::GetLastWebPreferences)\n      .SetMethod(\"getOwnerBrowserWindow\", &WebContents::GetOwnerBrowserWindow)\n      .SetMethod(\"inspectServiceWorker\", &WebContents::InspectServiceWorker)\n      .SetMethod(\"inspectSharedWorker\", &WebContents::InspectSharedWorker)\n      .SetMethod(\"inspectSharedWorkerById\",\n                 &WebContents::InspectSharedWorkerById)\n      .SetMethod(\"getAllSharedWorkers\", &WebContents::GetAllSharedWorkers)\n#if BUILDFLAG(ENABLE_PRINTING)\n      .SetMethod(\"_print\", &WebContents::Print)\n      .SetMethod(\"_getPrinters\", &WebContents::GetPrinterList)\n      .SetMethod(\"_printToPDF\", &WebContents::PrintToPDF)\n#endif\n      .SetMethod(\"addWorkSpace\", &WebContents::AddWorkSpace)\n      .SetMethod(\"removeWorkSpace\", &WebContents::RemoveWorkSpace)\n      .SetMethod(\"showDefinitionForSelection\",\n                 &WebContents::ShowDefinitionForSelection)\n      .SetMethod(\"copyImageAt\", &WebContents::CopyImageAt)\n      .SetMethod(\"capturePage\", &WebContents::CapturePage)\n      .SetMethod(\"setEmbedder\", &WebContents::SetEmbedder)\n      .SetMethod(\"setDevToolsWebContents\", &WebContents::SetDevToolsWebContents)\n      .SetMethod(\"getNativeView\", &WebContents::GetNativeView)\n      .SetMethod(\"incrementCapturerCount\", &WebContents::IncrementCapturerCount)\n      .SetMethod(\"decrementCapturerCount\", &WebContents::DecrementCapturerCount)\n      .SetMethod(\"isBeingCaptured\", &WebContents::IsBeingCaptured)\n      .SetMethod(\"setWebRTCIPHandlingPolicy\",\n                 &WebContents::SetWebRTCIPHandlingPolicy)\n      .SetMethod(\"getWebRTCIPHandlingPolicy\",\n                 &WebContents::GetWebRTCIPHandlingPolicy)\n      .SetMethod(\"_grantOriginAccess\", &WebContents::GrantOriginAccess)\n      .SetMethod(\"takeHeapSnapshot\", &WebContents::TakeHeapSnapshot)\n      .SetProperty(\"id\", &WebContents::ID)\n      .SetProperty(\"session\", &WebContents::Session)\n      .SetProperty(\"hostWebContents\", &WebContents::HostWebContents)\n      .SetProperty(\"devToolsWebContents\", &WebContents::DevToolsWebContents)\n      .SetProperty(\"debugger\", &WebContents::Debugger);\n}\n\nElectronBrowserContext* WebContents::GetBrowserContext() const {\n  return static_cast<ElectronBrowserContext*>(\n      web_contents()->GetBrowserContext());\n}\n\n// static\ngin::Handle<WebContents> WebContents::Create(\n    v8::Isolate* isolate,\n    const gin_helper::Dictionary& options) {\n  return gin::CreateHandle(isolate, new WebContents(isolate, options));\n}\n\n// static\ngin::Handle<WebContents> WebContents::CreateAndTake(\n    v8::Isolate* isolate,\n    std::unique_ptr<content::WebContents> web_contents,\n    Type type) {\n  return gin::CreateHandle(\n      isolate, new WebContents(isolate, std::move(web_contents), type));\n}\n\n// static\ngin::Handle<WebContents> WebContents::From(v8::Isolate* isolate,\n                                           content::WebContents* web_contents) {\n  auto* existing = TrackableObject::FromWrappedClass(isolate, web_contents);\n  if (existing)\n    return gin::CreateHandle(isolate, static_cast<WebContents*>(existing));\n  else\n    return gin::Handle<WebContents>();\n}\n\n// static\ngin::Handle<WebContents> WebContents::FromOrCreate(\n    v8::Isolate* isolate,\n    content::WebContents* web_contents) {\n  auto existing = From(isolate, web_contents);\n  if (!existing.IsEmpty())\n    return existing;\n  else\n    return gin::CreateHandle(isolate, new WebContents(isolate, web_contents));\n}\n\n}  // namespace api\n\n}  // namespace electron\n\nnamespace {\n\nusing electron::api::WebContents;\n\nvoid Initialize(v8::Local<v8::Object> exports,\n                v8::Local<v8::Value> unused,\n                v8::Local<v8::Context> context,\n                void* priv) {\n  v8::Isolate* isolate = context->GetIsolate();\n  gin_helper::Dictionary dict(isolate, exports);\n  dict.Set(\"WebContents\", WebContents::GetConstructor(isolate)\n                              ->GetFunction(context)\n                              .ToLocalChecked());\n  dict.SetMethod(\"create\", &WebContents::Create);\n  dict.SetMethod(\"fromId\", &WebContents::FromWeakMapID);\n  dict.SetMethod(\"getAllWebContents\", &WebContents::GetAll);\n}\n\n}  // namespace\n\nNODE_LINKED_MODULE_CONTEXT_AWARE(electron_browser_web_contents, Initialize)\n", "// Copyright (c) 2015 GitHub, Inc.\n// Use of this source code is governed by the MIT license that can be\n// found in the LICENSE file.\n\n#include \"shell/browser/electron_navigation_throttle.h\"\n\n#include \"content/public/browser/navigation_handle.h\"\n#include \"shell/browser/api/electron_api_web_contents.h\"\n\nnamespace electron {\n\nElectronNavigationThrottle::ElectronNavigationThrottle(\n    content::NavigationHandle* navigation_handle)\n    : content::NavigationThrottle(navigation_handle) {}\n\nElectronNavigationThrottle::~ElectronNavigationThrottle() = default;\n\nconst char* ElectronNavigationThrottle::GetNameForLogging() {\n  return \"ElectronNavigationThrottle\";\n}\n\ncontent::NavigationThrottle::ThrottleCheckResult\nElectronNavigationThrottle::WillRedirectRequest() {\n  auto* handle = navigation_handle();\n  auto* contents = handle->GetWebContents();\n  if (!contents) {\n    NOTREACHED();\n    return PROCEED;\n  }\n\n  v8::Isolate* isolate = v8::Isolate::GetCurrent();\n  v8::HandleScope scope(isolate);\n  auto api_contents = electron::api::WebContents::From(isolate, contents);\n  if (api_contents.IsEmpty()) {\n    // No need to emit any event if the WebContents is not available in JS.\n    return PROCEED;\n  }\n\n  if (api_contents->EmitNavigationEvent(\"will-redirect\", handle)) {\n    return CANCEL;\n  }\n  return PROCEED;\n}\n\n}  // namespace electron\n", "// Copyright (c) 2018 GitHub, Inc.\n// Use of this source code is governed by the MIT license that can be\n// found in the LICENSE file.\n\n#ifndef SHELL_BROWSER_ELECTRON_NAVIGATION_THROTTLE_H_\n#define SHELL_BROWSER_ELECTRON_NAVIGATION_THROTTLE_H_\n\n#include \"content/public/browser/navigation_throttle.h\"\n\nnamespace electron {\n\nclass ElectronNavigationThrottle : public content::NavigationThrottle {\n public:\n  explicit ElectronNavigationThrottle(content::NavigationHandle* handle);\n  ~ElectronNavigationThrottle() override;\n\n  ElectronNavigationThrottle::ThrottleCheckResult WillRedirectRequest()\n      override;\n\n  const char* GetNameForLogging() override;\n\n private:\n  DISALLOW_COPY_AND_ASSIGN(ElectronNavigationThrottle);\n};\n\n}  // namespace electron\n\n#endif  // SHELL_BROWSER_ELECTRON_NAVIGATION_THROTTLE_H_\n", "import { expect } from 'chai';\nimport * as path from 'path';\nimport * as fs from 'fs';\nimport * as os from 'os';\nimport * as qs from 'querystring';\nimport * as http from 'http';\nimport { AddressInfo } from 'net';\nimport { app, BrowserWindow, BrowserView, ipcMain, OnBeforeSendHeadersListenerDetails, protocol, screen, webContents, session, WebContents } from 'electron/main';\n\nimport { emittedOnce, emittedUntil } from './events-helpers';\nimport { ifit, ifdescribe, delay } from './spec-helpers';\nimport { closeWindow, closeAllWindows } from './window-helpers';\n\nconst features = process.electronBinding('features');\nconst fixtures = path.resolve(__dirname, '..', 'spec', 'fixtures');\n\n// Is the display's scale factor possibly causing rounding of pixel coordinate\n// values?\nconst isScaleFactorRounding = () => {\n  const { scaleFactor } = screen.getPrimaryDisplay();\n  // Return true if scale factor is non-integer value\n  if (Math.round(scaleFactor) !== scaleFactor) return true;\n  // Return true if scale factor is odd number above 2\n  return scaleFactor > 2 && scaleFactor % 2 === 1;\n};\n\nconst expectBoundsEqual = (actual: any, expected: any) => {\n  if (!isScaleFactorRounding()) {\n    expect(expected).to.deep.equal(actual);\n  } else if (Array.isArray(actual)) {\n    expect(actual[0]).to.be.closeTo(expected[0], 1);\n    expect(actual[1]).to.be.closeTo(expected[1], 1);\n  } else {\n    expect(actual.x).to.be.closeTo(expected.x, 1);\n    expect(actual.y).to.be.closeTo(expected.y, 1);\n    expect(actual.width).to.be.closeTo(expected.width, 1);\n    expect(actual.height).to.be.closeTo(expected.height, 1);\n  }\n};\n\nconst isBeforeUnload = (event: Event, level: number, message: string) => {\n  return (message === 'beforeunload');\n};\n\ndescribe('BrowserWindow module', () => {\n  describe('BrowserWindow constructor', () => {\n    it('allows passing void 0 as the webContents', async () => {\n      expect(() => {\n        const w = new BrowserWindow({\n          show: false,\n          // apparently void 0 had different behaviour from undefined in the\n          // issue that this test is supposed to catch.\n          webContents: void 0 // eslint-disable-line no-void\n        } as any);\n        w.destroy();\n      }).not.to.throw();\n    });\n  });\n\n  describe('garbage collection', () => {\n    const v8Util = process.electronBinding('v8_util');\n    afterEach(closeAllWindows);\n\n    it('window does not get garbage collected when opened', async () => {\n      const w = new BrowserWindow({ show: false });\n      // Keep a weak reference to the window.\n      // eslint-disable-next-line no-undef\n      const wr = new (globalThis as any).WeakRef(w);\n      await delay();\n      // Do garbage collection, since |w| is not referenced in this closure\n      // it would be gone after next call if there is no other reference.\n      v8Util.requestGarbageCollectionForTesting();\n\n      await delay();\n      expect(wr.deref()).to.not.be.undefined();\n    });\n  });\n\n  describe('BrowserWindow.close()', () => {\n    let w = null as unknown as BrowserWindow;\n    beforeEach(() => {\n      w = new BrowserWindow({ show: false, webPreferences: { nodeIntegration: true } });\n    });\n    afterEach(async () => {\n      await closeWindow(w);\n      w = null as unknown as BrowserWindow;\n    });\n\n    it('should emit unload handler', async () => {\n      await w.loadFile(path.join(fixtures, 'api', 'unload.html'));\n      const closed = emittedOnce(w, 'closed');\n      w.close();\n      await closed;\n      const test = path.join(fixtures, 'api', 'unload');\n      const content = fs.readFileSync(test);\n      fs.unlinkSync(test);\n      expect(String(content)).to.equal('unload');\n    });\n\n    it('should emit beforeunload handler', async () => {\n      await w.loadFile(path.join(__dirname, 'fixtures', 'api', 'beforeunload-false.html'));\n      w.close();\n      await emittedOnce(w.webContents, 'before-unload-fired');\n    });\n\n    describe('when invoked synchronously inside navigation observer', () => {\n      let server: http.Server = null as unknown as http.Server;\n      let url: string = null as unknown as string;\n\n      before((done) => {\n        server = http.createServer((request, response) => {\n          switch (request.url) {\n            case '/net-error':\n              response.destroy();\n              break;\n            case '/301':\n              response.statusCode = 301;\n              response.setHeader('Location', '/200');\n              response.end();\n              break;\n            case '/200':\n              response.statusCode = 200;\n              response.end('hello');\n              break;\n            case '/title':\n              response.statusCode = 200;\n              response.end('<title>Hello</title>');\n              break;\n            default:\n              throw new Error(`unsupported endpoint: ${request.url}`);\n          }\n        }).listen(0, '127.0.0.1', () => {\n          url = 'http://127.0.0.1:' + (server.address() as AddressInfo).port;\n          done();\n        });\n      });\n\n      after(() => {\n        server.close();\n      });\n\n      const events = [\n        { name: 'did-start-loading', path: '/200' },\n        { name: 'dom-ready', path: '/200' },\n        { name: 'page-title-updated', path: '/title' },\n        { name: 'did-stop-loading', path: '/200' },\n        { name: 'did-finish-load', path: '/200' },\n        { name: 'did-frame-finish-load', path: '/200' },\n        { name: 'did-fail-load', path: '/net-error' }\n      ];\n\n      for (const { name, path } of events) {\n        it(`should not crash when closed during ${name}`, async () => {\n          const w = new BrowserWindow({ show: false });\n          w.webContents.once((name as any), () => {\n            w.close();\n          });\n          const destroyed = emittedOnce(w.webContents, 'destroyed');\n          w.webContents.loadURL(url + path);\n          await destroyed;\n        });\n      }\n    });\n  });\n\n  describe('window.close()', () => {\n    let w = null as unknown as BrowserWindow;\n    beforeEach(() => {\n      w = new BrowserWindow({ show: false, webPreferences: { nodeIntegration: true } });\n    });\n    afterEach(async () => {\n      await closeWindow(w);\n      w = null as unknown as BrowserWindow;\n    });\n\n    it('should emit unload event', async () => {\n      w.loadFile(path.join(fixtures, 'api', 'close.html'));\n      await emittedOnce(w, 'closed');\n      const test = path.join(fixtures, 'api', 'close');\n      const content = fs.readFileSync(test).toString();\n      fs.unlinkSync(test);\n      expect(content).to.equal('close');\n    });\n\n    it('should emit beforeunload event', async function () {\n      await w.loadFile(path.join(__dirname, 'fixtures', 'api', 'beforeunload-false.html'));\n      w.webContents.executeJavaScript('window.close()', true);\n      await emittedOnce(w.webContents, 'before-unload-fired');\n    });\n  });\n\n  describe('BrowserWindow.destroy()', () => {\n    let w = null as unknown as BrowserWindow;\n    beforeEach(() => {\n      w = new BrowserWindow({ show: false, webPreferences: { nodeIntegration: true } });\n    });\n    afterEach(async () => {\n      await closeWindow(w);\n      w = null as unknown as BrowserWindow;\n    });\n\n    it('prevents users to access methods of webContents', async () => {\n      const contents = w.webContents;\n      w.destroy();\n      await new Promise(setImmediate);\n      expect(() => {\n        contents.getProcessId();\n      }).to.throw('Object has been destroyed');\n    });\n    it('should not crash when destroying windows with pending events', () => {\n      const focusListener = () => { };\n      app.on('browser-window-focus', focusListener);\n      const windowCount = 3;\n      const windowOptions = {\n        show: false,\n        width: 400,\n        height: 400,\n        webPreferences: {\n          backgroundThrottling: false\n        }\n      };\n      const windows = Array.from(Array(windowCount)).map(() => new BrowserWindow(windowOptions));\n      windows.forEach(win => win.show());\n      windows.forEach(win => win.focus());\n      windows.forEach(win => win.destroy());\n      app.removeListener('browser-window-focus', focusListener);\n    });\n  });\n\n  describe('BrowserWindow.loadURL(url)', () => {\n    let w = null as unknown as BrowserWindow;\n    const scheme = 'other';\n    const srcPath = path.join(fixtures, 'api', 'loaded-from-dataurl.js');\n    before(() => {\n      protocol.registerFileProtocol(scheme, (request, callback) => {\n        callback(srcPath);\n      });\n    });\n\n    after(() => {\n      protocol.unregisterProtocol(scheme);\n    });\n\n    beforeEach(() => {\n      w = new BrowserWindow({ show: false, webPreferences: { nodeIntegration: true } });\n    });\n    afterEach(async () => {\n      await closeWindow(w);\n      w = null as unknown as BrowserWindow;\n    });\n    let server = null as unknown as http.Server;\n    let url = null as unknown as string;\n    let postData = null as any;\n    before((done) => {\n      const filePath = path.join(fixtures, 'pages', 'a.html');\n      const fileStats = fs.statSync(filePath);\n      postData = [\n        {\n          type: 'rawData',\n          bytes: Buffer.from('username=test&file=')\n        },\n        {\n          type: 'file',\n          filePath: filePath,\n          offset: 0,\n          length: fileStats.size,\n          modificationTime: fileStats.mtime.getTime() / 1000\n        }\n      ];\n      server = http.createServer((req, res) => {\n        function respond () {\n          if (req.method === 'POST') {\n            let body = '';\n            req.on('data', (data) => {\n              if (data) body += data;\n            });\n            req.on('end', () => {\n              const parsedData = qs.parse(body);\n              fs.readFile(filePath, (err, data) => {\n                if (err) return;\n                if (parsedData.username === 'test' &&\n                  parsedData.file === data.toString()) {\n                  res.end();\n                }\n              });\n            });\n          } else if (req.url === '/302') {\n            res.setHeader('Location', '/200');\n            res.statusCode = 302;\n            res.end();\n          } else {\n            res.end();\n          }\n        }\n        setTimeout(respond, req.url && req.url.includes('slow') ? 200 : 0);\n      });\n      server.listen(0, '127.0.0.1', () => {\n        url = `http://127.0.0.1:${(server.address() as AddressInfo).port}`;\n        done();\n      });\n    });\n\n    after(() => {\n      server.close();\n    });\n\n    it('should emit did-start-loading event', (done) => {\n      w.webContents.on('did-start-loading', () => { done(); });\n      w.loadURL('about:blank');\n    });\n    it('should emit ready-to-show event', (done) => {\n      w.on('ready-to-show', () => { done(); });\n      w.loadURL('about:blank');\n    });\n    // TODO(deepak1556): The error code now seems to be `ERR_FAILED`, verify what\n    // changed and adjust the test.\n    it.skip('should emit did-fail-load event for files that do not exist', async () => {\n      const didFailLoad = emittedOnce(w.webContents, 'did-fail-load');\n      w.loadURL('file://a.txt');\n      const [, code, desc,, isMainFrame] = await didFailLoad;\n      expect(code).to.equal(-6);\n      expect(desc).to.equal('ERR_FILE_NOT_FOUND');\n      expect(isMainFrame).to.equal(true);\n    });\n    it('should emit did-fail-load event for invalid URL', async () => {\n      const didFailLoad = emittedOnce(w.webContents, 'did-fail-load');\n      w.loadURL('http://example:port');\n      const [, code, desc,, isMainFrame] = await didFailLoad;\n      expect(desc).to.equal('ERR_INVALID_URL');\n      expect(code).to.equal(-300);\n      expect(isMainFrame).to.equal(true);\n    });\n    it('should set `mainFrame = false` on did-fail-load events in iframes', async () => {\n      const didFailLoad = emittedOnce(w.webContents, 'did-fail-load');\n      w.loadFile(path.join(fixtures, 'api', 'did-fail-load-iframe.html'));\n      const [,,,, isMainFrame] = await didFailLoad;\n      expect(isMainFrame).to.equal(false);\n    });\n    it('does not crash in did-fail-provisional-load handler', (done) => {\n      w.webContents.once('did-fail-provisional-load', () => {\n        w.loadURL('http://127.0.0.1:11111');\n        done();\n      });\n      w.loadURL('http://127.0.0.1:11111');\n    });\n    it('should emit did-fail-load event for URL exceeding character limit', async () => {\n      const data = Buffer.alloc(2 * 1024 * 1024).toString('base64');\n      const didFailLoad = emittedOnce(w.webContents, 'did-fail-load');\n      w.loadURL(`data:image/png;base64,${data}`);\n      const [, code, desc,, isMainFrame] = await didFailLoad;\n      expect(desc).to.equal('ERR_INVALID_URL');\n      expect(code).to.equal(-300);\n      expect(isMainFrame).to.equal(true);\n    });\n\n    it('should return a promise', () => {\n      const p = w.loadURL('about:blank');\n      expect(p).to.have.property('then');\n    });\n\n    it('should return a promise that resolves', async () => {\n      await expect(w.loadURL('about:blank')).to.eventually.be.fulfilled();\n    });\n\n    it('should return a promise that rejects on a load failure', async () => {\n      const data = Buffer.alloc(2 * 1024 * 1024).toString('base64');\n      const p = w.loadURL(`data:image/png;base64,${data}`);\n      await expect(p).to.eventually.be.rejected;\n    });\n\n    it('should return a promise that resolves even if pushState occurs during navigation', async () => {\n      const p = w.loadURL('data:text/html,<script>window.history.pushState({}, \"/foo\")</script>');\n      await expect(p).to.eventually.be.fulfilled;\n    });\n\n    // FIXME(robo/nornagon): re-enable these once service workers work\n    describe.skip('POST navigations', () => {\n      afterEach(() => { w.webContents.session.webRequest.onBeforeSendHeaders(null); });\n\n      it('supports specifying POST data', async () => {\n        await w.loadURL(url, { postData });\n      });\n      it('sets the content type header on URL encoded forms', async () => {\n        await w.loadURL(url);\n        const requestDetails: Promise<OnBeforeSendHeadersListenerDetails> = new Promise(resolve => {\n          w.webContents.session.webRequest.onBeforeSendHeaders((details) => {\n            resolve(details);\n          });\n        });\n        w.webContents.executeJavaScript(`\n          form = document.createElement('form')\n          document.body.appendChild(form)\n          form.method = 'POST'\n          form.submit()\n        `);\n        const details = await requestDetails;\n        expect(details.requestHeaders['Content-Type']).to.equal('application/x-www-form-urlencoded');\n      });\n      it('sets the content type header on multi part forms', async () => {\n        await w.loadURL(url);\n        const requestDetails: Promise<OnBeforeSendHeadersListenerDetails> = new Promise(resolve => {\n          w.webContents.session.webRequest.onBeforeSendHeaders((details) => {\n            resolve(details);\n          });\n        });\n        w.webContents.executeJavaScript(`\n          form = document.createElement('form')\n          document.body.appendChild(form)\n          form.method = 'POST'\n          form.enctype = 'multipart/form-data'\n          file = document.createElement('input')\n          file.type = 'file'\n          file.name = 'file'\n          form.appendChild(file)\n          form.submit()\n        `);\n        const details = await requestDetails;\n        expect(details.requestHeaders['Content-Type'].startsWith('multipart/form-data; boundary=----WebKitFormBoundary')).to.equal(true);\n      });\n    });\n\n    it('should support support base url for data urls', async () => {\n      const answer = emittedOnce(ipcMain, 'answer');\n      w.loadURL('data:text/html,<script src=\"loaded-from-dataurl.js\"></script>', { baseURLForDataURL: `other://${path.join(fixtures, 'api')}${path.sep}` });\n      const [, test] = await answer;\n      expect(test).to.equal('test');\n    });\n  });\n\n  for (const sandbox of [false, true]) {\n    describe(`navigation events${sandbox ? ' with sandbox' : ''}`, () => {\n      let w = null as unknown as BrowserWindow;\n      beforeEach(() => {\n        w = new BrowserWindow({ show: false, webPreferences: { nodeIntegration: false, sandbox } });\n      });\n      afterEach(async () => {\n        await closeWindow(w);\n        w = null as unknown as BrowserWindow;\n      });\n\n      describe('will-navigate event', () => {\n        let server = null as unknown as http.Server;\n        let url = null as unknown as string;\n        before((done) => {\n          server = http.createServer((req, res) => { res.end(''); });\n          server.listen(0, '127.0.0.1', () => {\n            url = `http://127.0.0.1:${(server.address() as AddressInfo).port}/`;\n            done();\n          });\n        });\n\n        after(() => {\n          server.close();\n        });\n\n        it('allows the window to be closed from the event listener', (done) => {\n          w.webContents.once('will-navigate', () => {\n            w.close();\n            done();\n          });\n          w.loadFile(path.join(fixtures, 'pages', 'will-navigate.html'));\n        });\n\n        it('can be prevented', (done) => {\n          let willNavigate = false;\n          w.webContents.once('will-navigate', (e) => {\n            willNavigate = true;\n            e.preventDefault();\n          });\n          w.webContents.on('did-stop-loading', () => {\n            if (willNavigate) {\n              // i.e. it shouldn't have had '?navigated' appended to it.\n              try {\n                expect(w.webContents.getURL().endsWith('will-navigate.html')).to.be.true();\n                done();\n              } catch (e) {\n                done(e);\n              }\n            }\n          });\n          w.loadFile(path.join(fixtures, 'pages', 'will-navigate.html'));\n        });\n\n        it('is triggered when navigating from file: to http:', async () => {\n          await w.loadFile(path.join(fixtures, 'api', 'blank.html'));\n          w.webContents.executeJavaScript(`location.href = ${JSON.stringify(url)}`);\n          const navigatedTo = await new Promise(resolve => {\n            w.webContents.once('will-navigate', (e, url) => {\n              e.preventDefault();\n              resolve(url);\n            });\n          });\n          expect(navigatedTo).to.equal(url);\n          expect(w.webContents.getURL()).to.match(/^file:/);\n        });\n\n        it('is triggered when navigating from about:blank to http:', async () => {\n          await w.loadURL('about:blank');\n          w.webContents.executeJavaScript(`location.href = ${JSON.stringify(url)}`);\n          const navigatedTo = await new Promise(resolve => {\n            w.webContents.once('will-navigate', (e, url) => {\n              e.preventDefault();\n              resolve(url);\n            });\n          });\n          expect(navigatedTo).to.equal(url);\n          expect(w.webContents.getURL()).to.equal('about:blank');\n        });\n      });\n\n      describe('will-redirect event', () => {\n        let server = null as unknown as http.Server;\n        let url = null as unknown as string;\n        before((done) => {\n          server = http.createServer((req, res) => {\n            if (req.url === '/302') {\n              res.setHeader('Location', '/200');\n              res.statusCode = 302;\n              res.end();\n            } else if (req.url === '/navigate-302') {\n              res.end(`<html><body><script>window.location='${url}/302'</script></body></html>`);\n            } else {\n              res.end();\n            }\n          });\n          server.listen(0, '127.0.0.1', () => {\n            url = `http://127.0.0.1:${(server.address() as AddressInfo).port}`;\n            done();\n          });\n        });\n\n        after(() => {\n          server.close();\n        });\n        it('is emitted on redirects', (done) => {\n          w.webContents.on('will-redirect', () => {\n            done();\n          });\n          w.loadURL(`${url}/302`);\n        });\n\n        it('is emitted after will-navigate on redirects', async () => {\n          let navigateCalled = false;\n          w.webContents.on('will-navigate', () => {\n            navigateCalled = true;\n          });\n          const willRedirect = emittedOnce(w.webContents, 'will-redirect');\n          w.loadURL(`${url}/navigate-302`);\n          await willRedirect;\n          expect(navigateCalled).to.equal(true, 'should have called will-navigate first');\n        });\n\n        it('is emitted before did-stop-loading on redirects', async () => {\n          let stopCalled = false;\n          w.webContents.on('did-stop-loading', () => {\n            stopCalled = true;\n          });\n          const willRedirect = emittedOnce(w.webContents, 'will-redirect');\n          w.loadURL(`${url}/302`);\n          await willRedirect;\n          expect(stopCalled).to.equal(false, 'should not have called did-stop-loading first');\n        });\n\n        it('allows the window to be closed from the event listener', (done) => {\n          w.webContents.once('will-redirect', () => {\n            w.close();\n            done();\n          });\n          w.loadURL(`${url}/302`);\n        });\n\n        it('can be prevented', (done) => {\n          w.webContents.once('will-redirect', (event) => {\n            event.preventDefault();\n          });\n          w.webContents.on('will-navigate', (e, u) => {\n            expect(u).to.equal(`${url}/302`);\n          });\n          w.webContents.on('did-stop-loading', () => {\n            try {\n              expect(w.webContents.getURL()).to.equal(\n                `${url}/navigate-302`,\n                'url should not have changed after navigation event'\n              );\n              done();\n            } catch (e) {\n              done(e);\n            }\n          });\n          w.webContents.on('will-redirect', (e, u) => {\n            try {\n              expect(u).to.equal(`${url}/200`);\n            } catch (e) {\n              done(e);\n            }\n          });\n          w.loadURL(`${url}/navigate-302`);\n        });\n      });\n    });\n  }\n\n  describe('focus and visibility', () => {\n    let w = null as unknown as BrowserWindow;\n    beforeEach(() => {\n      w = new BrowserWindow({ show: false });\n    });\n    afterEach(async () => {\n      await closeWindow(w);\n      w = null as unknown as BrowserWindow;\n    });\n\n    describe('BrowserWindow.show()', () => {\n      it('should focus on window', () => {\n        w.show();\n        expect(w.isFocused()).to.equal(true);\n      });\n      it('should make the window visible', () => {\n        w.show();\n        expect(w.isVisible()).to.equal(true);\n      });\n      it('emits when window is shown', async () => {\n        const show = emittedOnce(w, 'show');\n        w.show();\n        await show;\n        expect(w.isVisible()).to.equal(true);\n      });\n    });\n\n    describe('BrowserWindow.hide()', () => {\n      it('should defocus on window', () => {\n        w.hide();\n        expect(w.isFocused()).to.equal(false);\n      });\n      it('should make the window not visible', () => {\n        w.show();\n        w.hide();\n        expect(w.isVisible()).to.equal(false);\n      });\n      it('emits when window is hidden', async () => {\n        const shown = emittedOnce(w, 'show');\n        w.show();\n        await shown;\n        const hidden = emittedOnce(w, 'hide');\n        w.hide();\n        await hidden;\n        expect(w.isVisible()).to.equal(false);\n      });\n    });\n\n    describe('BrowserWindow.showInactive()', () => {\n      it('should not focus on window', () => {\n        w.showInactive();\n        expect(w.isFocused()).to.equal(false);\n      });\n    });\n\n    describe('BrowserWindow.focus()', () => {\n      it('does not make the window become visible', () => {\n        expect(w.isVisible()).to.equal(false);\n        w.focus();\n        expect(w.isVisible()).to.equal(false);\n      });\n    });\n\n    describe('BrowserWindow.blur()', () => {\n      it('removes focus from window', () => {\n        w.blur();\n        expect(w.isFocused()).to.equal(false);\n      });\n    });\n\n    describe('BrowserWindow.getFocusedWindow()', () => {\n      it('returns the opener window when dev tools window is focused', async () => {\n        w.show();\n        w.webContents.openDevTools({ mode: 'undocked' });\n        await emittedOnce(w.webContents, 'devtools-focused');\n        expect(BrowserWindow.getFocusedWindow()).to.equal(w);\n      });\n    });\n\n    describe('BrowserWindow.moveTop()', () => {\n      it('should not steal focus', async () => {\n        const posDelta = 50;\n        const wShownInactive = emittedOnce(w, 'show');\n        w.showInactive();\n        await wShownInactive;\n        expect(w.isFocused()).to.equal(false);\n\n        const otherWindow = new BrowserWindow({ show: false, title: 'otherWindow' });\n        const otherWindowShown = emittedOnce(otherWindow, 'show');\n        const otherWindowFocused = emittedOnce(otherWindow, 'focus');\n        otherWindow.show();\n        await otherWindowShown;\n        await otherWindowFocused;\n        expect(otherWindow.isFocused()).to.equal(true);\n\n        w.moveTop();\n        const wPos = w.getPosition();\n        const wMoving = emittedOnce(w, 'move');\n        w.setPosition(wPos[0] + posDelta, wPos[1] + posDelta);\n        await wMoving;\n        expect(w.isFocused()).to.equal(false);\n        expect(otherWindow.isFocused()).to.equal(true);\n\n        const wFocused = emittedOnce(w, 'focus');\n        w.focus();\n        await wFocused;\n        expect(w.isFocused()).to.equal(true);\n\n        otherWindow.moveTop();\n        const otherWindowPos = otherWindow.getPosition();\n        const otherWindowMoving = emittedOnce(otherWindow, 'move');\n        otherWindow.setPosition(otherWindowPos[0] + posDelta, otherWindowPos[1] + posDelta);\n        await otherWindowMoving;\n        expect(otherWindow.isFocused()).to.equal(false);\n        expect(w.isFocused()).to.equal(true);\n\n        await closeWindow(otherWindow, { assertNotWindows: false });\n        expect(BrowserWindow.getAllWindows()).to.have.lengthOf(1);\n      });\n    });\n\n    ifdescribe(features.isDesktopCapturerEnabled())('BrowserWindow.moveAbove(mediaSourceId)', () => {\n      it('should throw an exception if wrong formatting', async () => {\n        const fakeSourceIds = [\n          'none', 'screen:0', 'window:fake', 'window:1234', 'foobar:1:2'\n        ];\n        fakeSourceIds.forEach((sourceId) => {\n          expect(() => {\n            w.moveAbove(sourceId);\n          }).to.throw(/Invalid media source id/);\n        });\n      });\n\n      it('should throw an exception if wrong type', async () => {\n        const fakeSourceIds = [null as any, 123 as any];\n        fakeSourceIds.forEach((sourceId) => {\n          expect(() => {\n            w.moveAbove(sourceId);\n          }).to.throw(/Error processing argument at index 0 */);\n        });\n      });\n\n      it('should throw an exception if invalid window', async () => {\n        // It is very unlikely that these window id exist.\n        const fakeSourceIds = ['window:99999999:0', 'window:123456:1',\n          'window:123456:9'];\n        fakeSourceIds.forEach((sourceId) => {\n          expect(() => {\n            w.moveAbove(sourceId);\n          }).to.throw(/Invalid media source id/);\n        });\n      });\n\n      it('should not throw an exception', async () => {\n        const w2 = new BrowserWindow({ show: false, title: 'window2' });\n        const w2Shown = emittedOnce(w2, 'show');\n        w2.show();\n        await w2Shown;\n\n        expect(() => {\n          w.moveAbove(w2.getMediaSourceId());\n        }).to.not.throw();\n\n        await closeWindow(w2, { assertNotWindows: false });\n      });\n    });\n\n    describe('BrowserWindow.setFocusable()', () => {\n      it('can set unfocusable window to focusable', async () => {\n        const w2 = new BrowserWindow({ focusable: false });\n        const w2Focused = emittedOnce(w2, 'focus');\n        w2.setFocusable(true);\n        w2.focus();\n        await w2Focused;\n        await closeWindow(w2, { assertNotWindows: false });\n      });\n    });\n  });\n\n  describe('sizing', () => {\n    let w = null as unknown as BrowserWindow;\n\n    beforeEach(() => {\n      w = new BrowserWindow({ show: false, width: 400, height: 400 });\n    });\n\n    afterEach(async () => {\n      await closeWindow(w);\n      w = null as unknown as BrowserWindow;\n    });\n\n    describe('BrowserWindow.setBounds(bounds[, animate])', () => {\n      it('sets the window bounds with full bounds', () => {\n        const fullBounds = { x: 440, y: 225, width: 500, height: 400 };\n        w.setBounds(fullBounds);\n\n        expectBoundsEqual(w.getBounds(), fullBounds);\n      });\n\n      it('sets the window bounds with partial bounds', () => {\n        const fullBounds = { x: 440, y: 225, width: 500, height: 400 };\n        w.setBounds(fullBounds);\n\n        const boundsUpdate = { width: 200 };\n        w.setBounds(boundsUpdate as any);\n\n        const expectedBounds = Object.assign(fullBounds, boundsUpdate);\n        expectBoundsEqual(w.getBounds(), expectedBounds);\n      });\n    });\n\n    describe('BrowserWindow.setSize(width, height)', () => {\n      it('sets the window size', async () => {\n        const size = [300, 400];\n\n        const resized = emittedOnce(w, 'resize');\n        w.setSize(size[0], size[1]);\n        await resized;\n\n        expectBoundsEqual(w.getSize(), size);\n      });\n    });\n\n    describe('BrowserWindow.setMinimum/MaximumSize(width, height)', () => {\n      it('sets the maximum and minimum size of the window', () => {\n        expect(w.getMinimumSize()).to.deep.equal([0, 0]);\n        expect(w.getMaximumSize()).to.deep.equal([0, 0]);\n\n        w.setMinimumSize(100, 100);\n        expectBoundsEqual(w.getMinimumSize(), [100, 100]);\n        expectBoundsEqual(w.getMaximumSize(), [0, 0]);\n\n        w.setMaximumSize(900, 600);\n        expectBoundsEqual(w.getMinimumSize(), [100, 100]);\n        expectBoundsEqual(w.getMaximumSize(), [900, 600]);\n      });\n    });\n\n    describe('BrowserWindow.setAspectRatio(ratio)', () => {\n      it('resets the behaviour when passing in 0', async () => {\n        const size = [300, 400];\n        w.setAspectRatio(1 / 2);\n        w.setAspectRatio(0);\n        const resize = emittedOnce(w, 'resize');\n        w.setSize(size[0], size[1]);\n        await resize;\n        expectBoundsEqual(w.getSize(), size);\n      });\n    });\n\n    describe('BrowserWindow.setPosition(x, y)', () => {\n      it('sets the window position', async () => {\n        const pos = [10, 10];\n        const move = emittedOnce(w, 'move');\n        w.setPosition(pos[0], pos[1]);\n        await move;\n        expect(w.getPosition()).to.deep.equal(pos);\n      });\n    });\n\n    describe('BrowserWindow.setContentSize(width, height)', () => {\n      it('sets the content size', async () => {\n        // NB. The CI server has a very small screen. Attempting to size the window\n        // larger than the screen will limit the window's size to the screen and\n        // cause the test to fail.\n        const size = [456, 567];\n        w.setContentSize(size[0], size[1]);\n        await new Promise(setImmediate);\n        const after = w.getContentSize();\n        expect(after).to.deep.equal(size);\n      });\n\n      it('works for a frameless window', async () => {\n        w.destroy();\n        w = new BrowserWindow({\n          show: false,\n          frame: false,\n          width: 400,\n          height: 400\n        });\n        const size = [456, 567];\n        w.setContentSize(size[0], size[1]);\n        await new Promise(setImmediate);\n        const after = w.getContentSize();\n        expect(after).to.deep.equal(size);\n      });\n    });\n\n    describe('BrowserWindow.setContentBounds(bounds)', () => {\n      it('sets the content size and position', async () => {\n        const bounds = { x: 10, y: 10, width: 250, height: 250 };\n        const resize = emittedOnce(w, 'resize');\n        w.setContentBounds(bounds);\n        await resize;\n        await delay();\n        expectBoundsEqual(w.getContentBounds(), bounds);\n      });\n      it('works for a frameless window', async () => {\n        w.destroy();\n        w = new BrowserWindow({\n          show: false,\n          frame: false,\n          width: 300,\n          height: 300\n        });\n        const bounds = { x: 10, y: 10, width: 250, height: 250 };\n        const resize = emittedOnce(w, 'resize');\n        w.setContentBounds(bounds);\n        await resize;\n        await delay();\n        expectBoundsEqual(w.getContentBounds(), bounds);\n      });\n    });\n\n    describe('BrowserWindow.getBackgroundColor()', () => {\n      it('returns default value if no backgroundColor is set', () => {\n        w.destroy();\n        w = new BrowserWindow({});\n        expect(w.getBackgroundColor()).to.equal('#FFFFFF');\n      });\n      it('returns correct value if backgroundColor is set', () => {\n        const backgroundColor = '#BBAAFF';\n        w.destroy();\n        w = new BrowserWindow({\n          backgroundColor: backgroundColor\n        });\n        expect(w.getBackgroundColor()).to.equal(backgroundColor);\n      });\n      it('returns correct value from setBackgroundColor()', () => {\n        const backgroundColor = '#AABBFF';\n        w.destroy();\n        w = new BrowserWindow({});\n        w.setBackgroundColor(backgroundColor);\n        expect(w.getBackgroundColor()).to.equal(backgroundColor);\n      });\n    });\n\n    describe('BrowserWindow.getNormalBounds()', () => {\n      describe('Normal state', () => {\n        it('checks normal bounds after resize', async () => {\n          const size = [300, 400];\n          const resize = emittedOnce(w, 'resize');\n          w.setSize(size[0], size[1]);\n          await resize;\n          expectBoundsEqual(w.getNormalBounds(), w.getBounds());\n        });\n        it('checks normal bounds after move', async () => {\n          const pos = [10, 10];\n          const move = emittedOnce(w, 'move');\n          w.setPosition(pos[0], pos[1]);\n          await move;\n          expectBoundsEqual(w.getNormalBounds(), w.getBounds());\n        });\n      });\n\n      ifdescribe(process.platform !== 'linux')('Maximized state', () => {\n        it('checks normal bounds when maximized', async () => {\n          const bounds = w.getBounds();\n          const maximize = emittedOnce(w, 'maximize');\n          w.show();\n          w.maximize();\n          await maximize;\n          expectBoundsEqual(w.getNormalBounds(), bounds);\n        });\n        it('checks normal bounds when unmaximized', async () => {\n          const bounds = w.getBounds();\n          w.once('maximize', () => {\n            w.unmaximize();\n          });\n          const unmaximize = emittedOnce(w, 'unmaximize');\n          w.show();\n          w.maximize();\n          await unmaximize;\n          expectBoundsEqual(w.getNormalBounds(), bounds);\n        });\n      });\n\n      ifdescribe(process.platform !== 'linux')('Minimized state', () => {\n        it('checks normal bounds when minimized', async () => {\n          const bounds = w.getBounds();\n          const minimize = emittedOnce(w, 'minimize');\n          w.show();\n          w.minimize();\n          await minimize;\n          expectBoundsEqual(w.getNormalBounds(), bounds);\n        });\n        it('checks normal bounds when restored', async () => {\n          const bounds = w.getBounds();\n          w.once('minimize', () => {\n            w.restore();\n          });\n          const restore = emittedOnce(w, 'restore');\n          w.show();\n          w.minimize();\n          await restore;\n          expectBoundsEqual(w.getNormalBounds(), bounds);\n        });\n        it('does not change size for a frameless window with min size', async () => {\n          w.destroy();\n          w = new BrowserWindow({\n            show: false,\n            frame: false,\n            width: 300,\n            height: 300,\n            minWidth: 300,\n            minHeight: 300\n          });\n          const bounds = w.getBounds();\n          w.once('minimize', () => {\n            w.restore();\n          });\n          const restore = emittedOnce(w, 'restore');\n          w.show();\n          w.minimize();\n          await restore;\n          expectBoundsEqual(w.getNormalBounds(), bounds);\n        });\n      });\n\n      ifdescribe(process.platform === 'win32')(`Fullscreen state`, () => {\n        it('with properties', () => {\n          it('can be set with the fullscreen constructor option', () => {\n            w = new BrowserWindow({ fullscreen: true });\n            expect(w.fullScreen).to.be.true();\n          });\n\n          it('can be changed', () => {\n            w.fullScreen = false;\n            expect(w.fullScreen).to.be.false();\n            w.fullScreen = true;\n            expect(w.fullScreen).to.be.true();\n          });\n\n          it(`checks normal bounds when fullscreen'ed`, async () => {\n            const bounds = w.getBounds();\n            const enterFullScreen = emittedOnce(w, 'enter-full-screen');\n            w.show();\n            w.fullScreen = true;\n            await enterFullScreen;\n            expectBoundsEqual(w.getNormalBounds(), bounds);\n          });\n\n          it(`checks normal bounds when unfullscreen'ed`, async () => {\n            const bounds = w.getBounds();\n            w.once('enter-full-screen', () => {\n              w.fullScreen = false;\n            });\n            const leaveFullScreen = emittedOnce(w, 'leave-full-screen');\n            w.show();\n            w.fullScreen = true;\n            await leaveFullScreen;\n            expectBoundsEqual(w.getNormalBounds(), bounds);\n          });\n        });\n\n        it('with functions', () => {\n          it('can be set with the fullscreen constructor option', () => {\n            w = new BrowserWindow({ fullscreen: true });\n            expect(w.isFullScreen()).to.be.true();\n          });\n\n          it('can be changed', () => {\n            w.setFullScreen(false);\n            expect(w.isFullScreen()).to.be.false();\n            w.setFullScreen(true);\n            expect(w.isFullScreen()).to.be.true();\n          });\n\n          it(`checks normal bounds when fullscreen'ed`, async () => {\n            const bounds = w.getBounds();\n            w.show();\n\n            const enterFullScreen = emittedOnce(w, 'enter-full-screen');\n            w.setFullScreen(true);\n            await enterFullScreen;\n\n            expectBoundsEqual(w.getNormalBounds(), bounds);\n          });\n\n          it(`checks normal bounds when unfullscreen'ed`, async () => {\n            const bounds = w.getBounds();\n            w.show();\n\n            const enterFullScreen = emittedOnce(w, 'enter-full-screen');\n            w.setFullScreen(true);\n            await enterFullScreen;\n\n            const leaveFullScreen = emittedOnce(w, 'leave-full-screen');\n            w.setFullScreen(false);\n            await leaveFullScreen;\n\n            expectBoundsEqual(w.getNormalBounds(), bounds);\n          });\n        });\n      });\n    });\n  });\n\n  ifdescribe(process.platform === 'darwin')('tabbed windows', () => {\n    let w = null as unknown as BrowserWindow;\n    beforeEach(() => {\n      w = new BrowserWindow({ show: false });\n    });\n    afterEach(async () => {\n      await closeWindow(w);\n      w = null as unknown as BrowserWindow;\n    });\n\n    describe('BrowserWindow.selectPreviousTab()', () => {\n      it('does not throw', () => {\n        expect(() => {\n          w.selectPreviousTab();\n        }).to.not.throw();\n      });\n    });\n\n    describe('BrowserWindow.selectNextTab()', () => {\n      it('does not throw', () => {\n        expect(() => {\n          w.selectNextTab();\n        }).to.not.throw();\n      });\n    });\n\n    describe('BrowserWindow.mergeAllWindows()', () => {\n      it('does not throw', () => {\n        expect(() => {\n          w.mergeAllWindows();\n        }).to.not.throw();\n      });\n    });\n\n    describe('BrowserWindow.moveTabToNewWindow()', () => {\n      it('does not throw', () => {\n        expect(() => {\n          w.moveTabToNewWindow();\n        }).to.not.throw();\n      });\n    });\n\n    describe('BrowserWindow.toggleTabBar()', () => {\n      it('does not throw', () => {\n        expect(() => {\n          w.toggleTabBar();\n        }).to.not.throw();\n      });\n    });\n\n    describe('BrowserWindow.addTabbedWindow()', () => {\n      it('does not throw', async () => {\n        const tabbedWindow = new BrowserWindow({});\n        expect(() => {\n          w.addTabbedWindow(tabbedWindow);\n        }).to.not.throw();\n\n        expect(BrowserWindow.getAllWindows()).to.have.lengthOf(2); // w + tabbedWindow\n\n        await closeWindow(tabbedWindow, { assertNotWindows: false });\n        expect(BrowserWindow.getAllWindows()).to.have.lengthOf(1); // w\n      });\n\n      it('throws when called on itself', () => {\n        expect(() => {\n          w.addTabbedWindow(w);\n        }).to.throw('AddTabbedWindow cannot be called by a window on itself.');\n      });\n    });\n  });\n\n  describe('autoHideMenuBar state', () => {\n    afterEach(closeAllWindows);\n\n    it('for properties', () => {\n      it('can be set with autoHideMenuBar constructor option', () => {\n        const w = new BrowserWindow({ show: false, autoHideMenuBar: true });\n        expect(w.autoHideMenuBar).to.be.true('autoHideMenuBar');\n      });\n\n      it('can be changed', () => {\n        const w = new BrowserWindow({ show: false });\n        expect(w.autoHideMenuBar).to.be.false('autoHideMenuBar');\n        w.autoHideMenuBar = true;\n        expect(w.autoHideMenuBar).to.be.true('autoHideMenuBar');\n        w.autoHideMenuBar = false;\n        expect(w.autoHideMenuBar).to.be.false('autoHideMenuBar');\n      });\n    });\n\n    it('for functions', () => {\n      it('can be set with autoHideMenuBar constructor option', () => {\n        const w = new BrowserWindow({ show: false, autoHideMenuBar: true });\n        expect(w.isMenuBarAutoHide()).to.be.true('autoHideMenuBar');\n      });\n\n      it('can be changed', () => {\n        const w = new BrowserWindow({ show: false });\n        expect(w.isMenuBarAutoHide()).to.be.false('autoHideMenuBar');\n        w.setAutoHideMenuBar(true);\n        expect(w.isMenuBarAutoHide()).to.be.true('autoHideMenuBar');\n        w.setAutoHideMenuBar(false);\n        expect(w.isMenuBarAutoHide()).to.be.false('autoHideMenuBar');\n      });\n    });\n  });\n\n  describe('BrowserWindow.capturePage(rect)', () => {\n    afterEach(closeAllWindows);\n\n    it('returns a Promise with a Buffer', async () => {\n      const w = new BrowserWindow({ show: false });\n      const image = await w.capturePage({\n        x: 0,\n        y: 0,\n        width: 100,\n        height: 100\n      });\n\n      expect(image.isEmpty()).to.equal(true);\n    });\n\n    it('preserves transparency', async () => {\n      const w = new BrowserWindow({ show: false, transparent: true });\n      w.loadURL('about:blank');\n      await emittedOnce(w, 'ready-to-show');\n      w.show();\n\n      const image = await w.capturePage();\n      const imgBuffer = image.toPNG();\n\n      // Check the 25th byte in the PNG.\n      // Values can be 0,2,3,4, or 6. We want 6, which is RGB + Alpha\n      expect(imgBuffer[25]).to.equal(6);\n    });\n  });\n\n  describe('BrowserWindow.setProgressBar(progress)', () => {\n    let w = null as unknown as BrowserWindow;\n    before(() => {\n      w = new BrowserWindow({ show: false });\n    });\n    after(async () => {\n      await closeWindow(w);\n      w = null as unknown as BrowserWindow;\n    });\n    it('sets the progress', () => {\n      expect(() => {\n        if (process.platform === 'darwin') {\n          app.dock.setIcon(path.join(fixtures, 'assets', 'logo.png'));\n        }\n        w.setProgressBar(0.5);\n\n        if (process.platform === 'darwin') {\n          app.dock.setIcon(null as any);\n        }\n        w.setProgressBar(-1);\n      }).to.not.throw();\n    });\n    it('sets the progress using \"paused\" mode', () => {\n      expect(() => {\n        w.setProgressBar(0.5, { mode: 'paused' });\n      }).to.not.throw();\n    });\n    it('sets the progress using \"error\" mode', () => {\n      expect(() => {\n        w.setProgressBar(0.5, { mode: 'error' });\n      }).to.not.throw();\n    });\n    it('sets the progress using \"normal\" mode', () => {\n      expect(() => {\n        w.setProgressBar(0.5, { mode: 'normal' });\n      }).to.not.throw();\n    });\n  });\n\n  describe('BrowserWindow.setAlwaysOnTop(flag, level)', () => {\n    let w = null as unknown as BrowserWindow;\n\n    beforeEach(() => {\n      w = new BrowserWindow({ show: false });\n    });\n\n    afterEach(async () => {\n      await closeWindow(w);\n      w = null as unknown as BrowserWindow;\n    });\n\n    it('sets the window as always on top', () => {\n      expect(w.isAlwaysOnTop()).to.be.false('is alwaysOnTop');\n      w.setAlwaysOnTop(true, 'screen-saver');\n      expect(w.isAlwaysOnTop()).to.be.true('is not alwaysOnTop');\n      w.setAlwaysOnTop(false);\n      expect(w.isAlwaysOnTop()).to.be.false('is alwaysOnTop');\n      w.setAlwaysOnTop(true);\n      expect(w.isAlwaysOnTop()).to.be.true('is not alwaysOnTop');\n    });\n\n    ifit(process.platform === 'darwin')('resets the windows level on minimize', () => {\n      expect(w.isAlwaysOnTop()).to.be.false('is alwaysOnTop');\n      w.setAlwaysOnTop(true, 'screen-saver');\n      expect(w.isAlwaysOnTop()).to.be.true('is not alwaysOnTop');\n      w.minimize();\n      expect(w.isAlwaysOnTop()).to.be.false('is alwaysOnTop');\n      w.restore();\n      expect(w.isAlwaysOnTop()).to.be.true('is not alwaysOnTop');\n    });\n\n    it('causes the right value to be emitted on `always-on-top-changed`', async () => {\n      const alwaysOnTopChanged = emittedOnce(w, 'always-on-top-changed');\n      expect(w.isAlwaysOnTop()).to.be.false('is alwaysOnTop');\n      w.setAlwaysOnTop(true);\n      const [, alwaysOnTop] = await alwaysOnTopChanged;\n      expect(alwaysOnTop).to.be.true('is not alwaysOnTop');\n    });\n  });\n\n  describe('preconnect feature', () => {\n    let w = null as unknown as BrowserWindow;\n\n    let server = null as unknown as http.Server;\n    let url = null as unknown as string;\n    let connections = 0;\n\n    beforeEach(async () => {\n      connections = 0;\n      server = http.createServer((req, res) => {\n        if (req.url === '/link') {\n          res.setHeader('Content-type', 'text/html');\n          res.end('<head><link rel=\"preconnect\" href=\"//example.com\" /></head><body>foo</body>');\n          return;\n        }\n        res.end();\n      });\n      server.on('connection', () => { connections++; });\n\n      await new Promise(resolve => server.listen(0, '127.0.0.1', () => resolve()));\n      url = `http://127.0.0.1:${(server.address() as AddressInfo).port}`;\n    });\n    afterEach(async () => {\n      server.close();\n      await closeWindow(w);\n      w = null as unknown as BrowserWindow;\n      server = null as unknown as http.Server;\n    });\n\n    it('calling preconnect() connects to the server', async () => {\n      w = new BrowserWindow({ show: false });\n      w.webContents.on('did-start-navigation', (event, url) => {\n        w.webContents.session.preconnect({ url, numSockets: 4 });\n      });\n      await w.loadURL(url);\n      expect(connections).to.equal(4);\n    });\n\n    it('does not preconnect unless requested', async () => {\n      w = new BrowserWindow({ show: false });\n      await w.loadURL(url);\n      expect(connections).to.equal(1);\n    });\n\n    it('parses <link rel=preconnect>', async () => {\n      w = new BrowserWindow({ show: true });\n      const p = emittedOnce(w.webContents.session, 'preconnect');\n      w.loadURL(url + '/link');\n      const [, preconnectUrl, allowCredentials] = await p;\n      expect(preconnectUrl).to.equal('http://example.com/');\n      expect(allowCredentials).to.be.true('allowCredentials');\n    });\n  });\n\n  describe('BrowserWindow.setAutoHideCursor(autoHide)', () => {\n    let w = null as unknown as BrowserWindow;\n    beforeEach(() => {\n      w = new BrowserWindow({ show: false });\n    });\n    afterEach(async () => {\n      await closeWindow(w);\n      w = null as unknown as BrowserWindow;\n    });\n\n    ifit(process.platform === 'darwin')('on macOS', () => {\n      it('allows changing cursor auto-hiding', () => {\n        expect(() => {\n          w.setAutoHideCursor(false);\n          w.setAutoHideCursor(true);\n        }).to.not.throw();\n      });\n    });\n\n    ifit(process.platform !== 'darwin')('on non-macOS platforms', () => {\n      it('is not available', () => {\n        expect(w.setAutoHideCursor).to.be.undefined('setAutoHideCursor function');\n      });\n    });\n  });\n\n  ifdescribe(process.platform === 'darwin')('BrowserWindow.setWindowButtonVisibility()', () => {\n    afterEach(closeAllWindows);\n\n    it('does not throw', () => {\n      const w = new BrowserWindow({ show: false });\n      expect(() => {\n        w.setWindowButtonVisibility(true);\n        w.setWindowButtonVisibility(false);\n      }).to.not.throw();\n    });\n\n    it('throws with custom title bar buttons', () => {\n      expect(() => {\n        const w = new BrowserWindow({\n          show: false,\n          titleBarStyle: 'customButtonsOnHover',\n          frame: false\n        });\n        w.setWindowButtonVisibility(true);\n      }).to.throw('Not supported for this window');\n    });\n  });\n\n  ifdescribe(process.platform === 'darwin')('BrowserWindow.setVibrancy(type)', () => {\n    afterEach(closeAllWindows);\n\n    it('allows setting, changing, and removing the vibrancy', () => {\n      const w = new BrowserWindow({ show: false });\n      expect(() => {\n        w.setVibrancy('light');\n        w.setVibrancy('dark');\n        w.setVibrancy(null);\n        w.setVibrancy('ultra-dark');\n        w.setVibrancy('' as any);\n      }).to.not.throw();\n    });\n  });\n\n  ifdescribe(process.platform === 'darwin')('BrowserWindow.getTrafficLightPosition(pos)', () => {\n    afterEach(closeAllWindows);\n\n    it('gets the set traffic light position property', () => {\n      const pos = { x: 10, y: 10 };\n      const w = new BrowserWindow({ show: false, titleBarStyle: 'hidden', trafficLightPosition: pos });\n      const currentPosition = w.getTrafficLightPosition();\n\n      expect(currentPosition).to.deep.equal(pos);\n    });\n  });\n\n  ifdescribe(process.platform === 'darwin')('BrowserWindow.setTrafficLightPosition(pos)', () => {\n    afterEach(closeAllWindows);\n\n    it('can set the traffic light position property', () => {\n      const pos = { x: 10, y: 10 };\n      const w = new BrowserWindow({ show: false, titleBarStyle: 'hidden', trafficLightPosition: pos });\n      w.setTrafficLightPosition(pos);\n      const currentPosition = w.getTrafficLightPosition();\n\n      expect(currentPosition).to.deep.equal(pos);\n    });\n  });\n\n  ifdescribe(process.platform === 'win32')('BrowserWindow.setAppDetails(options)', () => {\n    afterEach(closeAllWindows);\n\n    it('supports setting the app details', () => {\n      const w = new BrowserWindow({ show: false });\n      const iconPath = path.join(fixtures, 'assets', 'icon.ico');\n\n      expect(() => {\n        w.setAppDetails({ appId: 'my.app.id' });\n        w.setAppDetails({ appIconPath: iconPath, appIconIndex: 0 });\n        w.setAppDetails({ appIconPath: iconPath });\n        w.setAppDetails({ relaunchCommand: 'my-app.exe arg1 arg2', relaunchDisplayName: 'My app name' });\n        w.setAppDetails({ relaunchCommand: 'my-app.exe arg1 arg2' });\n        w.setAppDetails({ relaunchDisplayName: 'My app name' });\n        w.setAppDetails({\n          appId: 'my.app.id',\n          appIconPath: iconPath,\n          appIconIndex: 0,\n          relaunchCommand: 'my-app.exe arg1 arg2',\n          relaunchDisplayName: 'My app name'\n        });\n        w.setAppDetails({});\n      }).to.not.throw();\n\n      expect(() => {\n        (w.setAppDetails as any)();\n      }).to.throw('Insufficient number of arguments.');\n    });\n  });\n\n  describe('BrowserWindow.fromId(id)', () => {\n    afterEach(closeAllWindows);\n    it('returns the window with id', () => {\n      const w = new BrowserWindow({ show: false });\n      expect(BrowserWindow.fromId(w.id).id).to.equal(w.id);\n    });\n  });\n\n  describe('BrowserWindow.fromWebContents(webContents)', () => {\n    afterEach(closeAllWindows);\n\n    it('returns the window with the webContents', () => {\n      const w = new BrowserWindow({ show: false });\n      const found = BrowserWindow.fromWebContents(w.webContents);\n      expect(found!.id).to.equal(w.id);\n    });\n\n    it('returns null for webContents without a BrowserWindow', () => {\n      const contents = (webContents as any).create({});\n      try {\n        expect(BrowserWindow.fromWebContents(contents)).to.be.null('BrowserWindow.fromWebContents(contents)');\n      } finally {\n        contents.destroy();\n      }\n    });\n  });\n\n  describe('BrowserWindow.openDevTools()', () => {\n    afterEach(closeAllWindows);\n    it('does not crash for frameless window', () => {\n      const w = new BrowserWindow({ show: false, frame: false });\n      w.webContents.openDevTools();\n    });\n  });\n\n  describe('BrowserWindow.fromBrowserView(browserView)', () => {\n    afterEach(closeAllWindows);\n\n    it('returns the window with the browserView', () => {\n      const w = new BrowserWindow({ show: false });\n      const bv = new BrowserView();\n      w.setBrowserView(bv);\n      expect(BrowserWindow.fromBrowserView(bv)!.id).to.equal(w.id);\n      // if BrowserView isn't explicitly destroyed, it will crash in GC later\n      bv.destroy();\n    });\n\n    it('returns undefined if not attached', () => {\n      const bv = new BrowserView();\n      expect(BrowserWindow.fromBrowserView(bv)).to.be.null('BrowserWindow associated with bv');\n      // if BrowserView isn't explicitly destroyed, it will crash in GC later\n      bv.destroy();\n    });\n  });\n\n  describe('BrowserWindow.setOpacity(opacity)', () => {\n    afterEach(closeAllWindows);\n\n    ifdescribe(process.platform !== 'linux')(('Windows and Mac'), () => {\n      it('make window with initial opacity', () => {\n        const w = new BrowserWindow({ show: false, opacity: 0.5 });\n        expect(w.getOpacity()).to.equal(0.5);\n      });\n      it('allows setting the opacity', () => {\n        const w = new BrowserWindow({ show: false });\n        expect(() => {\n          w.setOpacity(0.0);\n          expect(w.getOpacity()).to.equal(0.0);\n          w.setOpacity(0.5);\n          expect(w.getOpacity()).to.equal(0.5);\n          w.setOpacity(1.0);\n          expect(w.getOpacity()).to.equal(1.0);\n        }).to.not.throw();\n      });\n\n      it('clamps opacity to [0.0...1.0]', () => {\n        const w = new BrowserWindow({ show: false, opacity: 0.5 });\n        w.setOpacity(100);\n        expect(w.getOpacity()).to.equal(1.0);\n        w.setOpacity(-100);\n        expect(w.getOpacity()).to.equal(0.0);\n      });\n    });\n\n    ifdescribe(process.platform === 'linux')(('Linux'), () => {\n      it('sets 1 regardless of parameter', () => {\n        const w = new BrowserWindow({ show: false });\n        w.setOpacity(0);\n        expect(w.getOpacity()).to.equal(1.0);\n        w.setOpacity(0.5);\n        expect(w.getOpacity()).to.equal(1.0);\n      });\n    });\n  });\n\n  describe('BrowserWindow.setShape(rects)', () => {\n    afterEach(closeAllWindows);\n    it('allows setting shape', () => {\n      const w = new BrowserWindow({ show: false });\n      expect(() => {\n        w.setShape([]);\n        w.setShape([{ x: 0, y: 0, width: 100, height: 100 }]);\n        w.setShape([{ x: 0, y: 0, width: 100, height: 100 }, { x: 0, y: 200, width: 1000, height: 100 }]);\n        w.setShape([]);\n      }).to.not.throw();\n    });\n  });\n\n  describe('\"useContentSize\" option', () => {\n    afterEach(closeAllWindows);\n    it('make window created with content size when used', () => {\n      const w = new BrowserWindow({\n        show: false,\n        width: 400,\n        height: 400,\n        useContentSize: true\n      });\n      const contentSize = w.getContentSize();\n      expect(contentSize).to.deep.equal([400, 400]);\n    });\n    it('make window created with window size when not used', () => {\n      const w = new BrowserWindow({\n        show: false,\n        width: 400,\n        height: 400\n      });\n      const size = w.getSize();\n      expect(size).to.deep.equal([400, 400]);\n    });\n    it('works for a frameless window', () => {\n      const w = new BrowserWindow({\n        show: false,\n        frame: false,\n        width: 400,\n        height: 400,\n        useContentSize: true\n      });\n      const contentSize = w.getContentSize();\n      expect(contentSize).to.deep.equal([400, 400]);\n      const size = w.getSize();\n      expect(size).to.deep.equal([400, 400]);\n    });\n  });\n\n  ifdescribe(process.platform === 'darwin' && parseInt(os.release().split('.')[0]) >= 14)('\"titleBarStyle\" option', () => {\n    afterEach(closeAllWindows);\n    it('creates browser window with hidden title bar', () => {\n      const w = new BrowserWindow({\n        show: false,\n        width: 400,\n        height: 400,\n        titleBarStyle: 'hidden'\n      });\n      const contentSize = w.getContentSize();\n      expect(contentSize).to.deep.equal([400, 400]);\n    });\n    it('creates browser window with hidden inset title bar', () => {\n      const w = new BrowserWindow({\n        show: false,\n        width: 400,\n        height: 400,\n        titleBarStyle: 'hiddenInset'\n      });\n      const contentSize = w.getContentSize();\n      expect(contentSize).to.deep.equal([400, 400]);\n    });\n  });\n\n  ifdescribe(process.platform === 'darwin')('\"enableLargerThanScreen\" option', () => {\n    afterEach(closeAllWindows);\n    it('can move the window out of screen', () => {\n      const w = new BrowserWindow({ show: true, enableLargerThanScreen: true });\n      w.setPosition(-10, 50);\n      const after = w.getPosition();\n      expect(after).to.deep.equal([-10, 50]);\n    });\n    it('cannot move the window behind menu bar', () => {\n      const w = new BrowserWindow({ show: true, enableLargerThanScreen: true });\n      w.setPosition(-10, -10);\n      const after = w.getPosition();\n      expect(after[1]).to.be.at.least(0);\n    });\n    it('can move the window behind menu bar if it has no frame', () => {\n      const w = new BrowserWindow({ show: true, enableLargerThanScreen: true, frame: false });\n      w.setPosition(-10, -10);\n      const after = w.getPosition();\n      expect(after[0]).to.be.equal(-10);\n      expect(after[1]).to.be.equal(-10);\n    });\n    it('without it, cannot move the window out of screen', () => {\n      const w = new BrowserWindow({ show: true, enableLargerThanScreen: false });\n      w.setPosition(-10, -10);\n      const after = w.getPosition();\n      expect(after[1]).to.be.at.least(0);\n    });\n    it('can set the window larger than screen', () => {\n      const w = new BrowserWindow({ show: true, enableLargerThanScreen: true });\n      const size = screen.getPrimaryDisplay().size;\n      size.width += 100;\n      size.height += 100;\n      w.setSize(size.width, size.height);\n      expectBoundsEqual(w.getSize(), [size.width, size.height]);\n    });\n    it('without it, cannot set the window larger than screen', () => {\n      const w = new BrowserWindow({ show: true, enableLargerThanScreen: false });\n      const size = screen.getPrimaryDisplay().size;\n      size.width += 100;\n      size.height += 100;\n      w.setSize(size.width, size.height);\n      expect(w.getSize()[1]).to.at.most(screen.getPrimaryDisplay().size.height);\n    });\n  });\n\n  ifdescribe(process.platform === 'darwin')('\"zoomToPageWidth\" option', () => {\n    afterEach(closeAllWindows);\n    it('sets the window width to the page width when used', () => {\n      const w = new BrowserWindow({\n        show: false,\n        width: 500,\n        height: 400,\n        zoomToPageWidth: true\n      });\n      w.maximize();\n      expect(w.getSize()[0]).to.equal(500);\n    });\n  });\n\n  describe('\"tabbingIdentifier\" option', () => {\n    afterEach(closeAllWindows);\n    it('can be set on a window', () => {\n      expect(() => {\n        /* eslint-disable no-new */\n        new BrowserWindow({\n          tabbingIdentifier: 'group1'\n        });\n        new BrowserWindow({\n          tabbingIdentifier: 'group2',\n          frame: false\n        });\n        /* eslint-enable no-new */\n      }).not.to.throw();\n    });\n  });\n\n  describe('\"webPreferences\" option', () => {\n    afterEach(() => { ipcMain.removeAllListeners('answer'); });\n    afterEach(closeAllWindows);\n\n    describe('\"preload\" option', () => {\n      const doesNotLeakSpec = (name: string, webPrefs: { nodeIntegration: boolean, sandbox: boolean, contextIsolation: boolean }) => {\n        it(name, async () => {\n          const w = new BrowserWindow({\n            webPreferences: {\n              ...webPrefs,\n              preload: path.resolve(fixtures, 'module', 'empty.js')\n            },\n            show: false\n          });\n          w.loadFile(path.join(fixtures, 'api', 'no-leak.html'));\n          const [, result] = await emittedOnce(ipcMain, 'leak-result');\n          expect(result).to.have.property('require', 'undefined');\n          expect(result).to.have.property('exports', 'undefined');\n          expect(result).to.have.property('windowExports', 'undefined');\n          expect(result).to.have.property('windowPreload', 'undefined');\n          expect(result).to.have.property('windowRequire', 'undefined');\n        });\n      };\n      doesNotLeakSpec('does not leak require', {\n        nodeIntegration: false,\n        sandbox: false,\n        contextIsolation: false\n      });\n      doesNotLeakSpec('does not leak require when sandbox is enabled', {\n        nodeIntegration: false,\n        sandbox: true,\n        contextIsolation: false\n      });\n      doesNotLeakSpec('does not leak require when context isolation is enabled', {\n        nodeIntegration: false,\n        sandbox: false,\n        contextIsolation: true\n      });\n      doesNotLeakSpec('does not leak require when context isolation and sandbox are enabled', {\n        nodeIntegration: false,\n        sandbox: true,\n        contextIsolation: true\n      });\n      it('does not leak any node globals on the window object with nodeIntegration is disabled', async () => {\n        let w = new BrowserWindow({\n          webPreferences: {\n            contextIsolation: false,\n            nodeIntegration: false,\n            preload: path.resolve(fixtures, 'module', 'empty.js')\n          },\n          show: false\n        });\n        w.loadFile(path.join(fixtures, 'api', 'globals.html'));\n        const [, notIsolated] = await emittedOnce(ipcMain, 'leak-result');\n        expect(notIsolated).to.have.property('globals');\n\n        w.destroy();\n        w = new BrowserWindow({\n          webPreferences: {\n            contextIsolation: true,\n            nodeIntegration: false,\n            preload: path.resolve(fixtures, 'module', 'empty.js')\n          },\n          show: false\n        });\n        w.loadFile(path.join(fixtures, 'api', 'globals.html'));\n        const [, isolated] = await emittedOnce(ipcMain, 'leak-result');\n        expect(isolated).to.have.property('globals');\n        const notIsolatedGlobals = new Set(notIsolated.globals);\n        for (const isolatedGlobal of isolated.globals) {\n          notIsolatedGlobals.delete(isolatedGlobal);\n        }\n        expect([...notIsolatedGlobals]).to.deep.equal([], 'non-isoalted renderer should have no additional globals');\n      });\n\n      it('loads the script before other scripts in window', async () => {\n        const preload = path.join(fixtures, 'module', 'set-global.js');\n        const w = new BrowserWindow({\n          show: false,\n          webPreferences: {\n            nodeIntegration: true,\n            preload\n          }\n        });\n        w.loadFile(path.join(fixtures, 'api', 'preload.html'));\n        const [, test] = await emittedOnce(ipcMain, 'answer');\n        expect(test).to.eql('preload');\n      });\n      it('can successfully delete the Buffer global', async () => {\n        const preload = path.join(__dirname, 'fixtures', 'module', 'delete-buffer.js');\n        const w = new BrowserWindow({\n          show: false,\n          webPreferences: {\n            nodeIntegration: true,\n            enableRemoteModule: true,\n            preload\n          }\n        });\n        w.loadFile(path.join(fixtures, 'api', 'preload.html'));\n        const [, test] = await emittedOnce(ipcMain, 'answer');\n        expect(test).to.eql(Buffer.from('buffer'));\n      });\n      it('has synchronous access to all eventual window APIs', async () => {\n        const preload = path.join(fixtures, 'module', 'access-blink-apis.js');\n        const w = new BrowserWindow({\n          show: false,\n          webPreferences: {\n            nodeIntegration: true,\n            preload\n          }\n        });\n        w.loadFile(path.join(fixtures, 'api', 'preload.html'));\n        const [, test] = await emittedOnce(ipcMain, 'answer');\n        expect(test).to.be.an('object');\n        expect(test.atPreload).to.be.an('array');\n        expect(test.atLoad).to.be.an('array');\n        expect(test.atPreload).to.deep.equal(test.atLoad, 'should have access to the same window APIs');\n      });\n    });\n\n    describe('session preload scripts', function () {\n      const preloads = [\n        path.join(fixtures, 'module', 'set-global-preload-1.js'),\n        path.join(fixtures, 'module', 'set-global-preload-2.js'),\n        path.relative(process.cwd(), path.join(fixtures, 'module', 'set-global-preload-3.js'))\n      ];\n      const defaultSession = session.defaultSession;\n\n      beforeEach(() => {\n        expect(defaultSession.getPreloads()).to.deep.equal([]);\n        defaultSession.setPreloads(preloads);\n      });\n      afterEach(() => {\n        defaultSession.setPreloads([]);\n      });\n\n      it('can set multiple session preload script', () => {\n        expect(defaultSession.getPreloads()).to.deep.equal(preloads);\n      });\n\n      const generateSpecs = (description: string, sandbox: boolean) => {\n        describe(description, () => {\n          it('loads the script before other scripts in window including normal preloads', async () => {\n            const w = new BrowserWindow({\n              show: false,\n              webPreferences: {\n                sandbox,\n                preload: path.join(fixtures, 'module', 'get-global-preload.js')\n              }\n            });\n            w.loadURL('about:blank');\n            const [, preload1, preload2, preload3] = await emittedOnce(ipcMain, 'vars');\n            expect(preload1).to.equal('preload-1');\n            expect(preload2).to.equal('preload-1-2');\n            expect(preload3).to.be.undefined('preload 3');\n          });\n        });\n      };\n\n      generateSpecs('without sandbox', false);\n      generateSpecs('with sandbox', true);\n    });\n\n    describe('\"additionalArguments\" option', () => {\n      it('adds extra args to process.argv in the renderer process', async () => {\n        const preload = path.join(fixtures, 'module', 'check-arguments.js');\n        const w = new BrowserWindow({\n          show: false,\n          webPreferences: {\n            nodeIntegration: true,\n            preload,\n            additionalArguments: ['--my-magic-arg']\n          }\n        });\n        w.loadFile(path.join(fixtures, 'api', 'blank.html'));\n        const [, argv] = await emittedOnce(ipcMain, 'answer');\n        expect(argv).to.include('--my-magic-arg');\n      });\n\n      it('adds extra value args to process.argv in the renderer process', async () => {\n        const preload = path.join(fixtures, 'module', 'check-arguments.js');\n        const w = new BrowserWindow({\n          show: false,\n          webPreferences: {\n            nodeIntegration: true,\n            preload,\n            additionalArguments: ['--my-magic-arg=foo']\n          }\n        });\n        w.loadFile(path.join(fixtures, 'api', 'blank.html'));\n        const [, argv] = await emittedOnce(ipcMain, 'answer');\n        expect(argv).to.include('--my-magic-arg=foo');\n      });\n    });\n\n    describe('\"node-integration\" option', () => {\n      it('disables node integration by default', async () => {\n        const preload = path.join(fixtures, 'module', 'send-later.js');\n        const w = new BrowserWindow({\n          show: false,\n          webPreferences: {\n            preload\n          }\n        });\n        w.loadFile(path.join(fixtures, 'api', 'blank.html'));\n        const [, typeofProcess, typeofBuffer] = await emittedOnce(ipcMain, 'answer');\n        expect(typeofProcess).to.equal('undefined');\n        expect(typeofBuffer).to.equal('undefined');\n      });\n    });\n\n    ifdescribe(features.isRemoteModuleEnabled())('\"enableRemoteModule\" option', () => {\n      const generateSpecs = (description: string, sandbox: boolean) => {\n        describe(description, () => {\n          const preload = path.join(__dirname, 'fixtures', 'module', 'preload-remote.js');\n\n          it('disables the remote module by default', async () => {\n            const w = new BrowserWindow({\n              show: false,\n              webPreferences: {\n                preload,\n                sandbox\n              }\n            });\n            const p = emittedOnce(ipcMain, 'remote');\n            w.loadFile(path.join(fixtures, 'api', 'blank.html'));\n            const [, remote] = await p;\n            expect(remote).to.equal('undefined');\n          });\n\n          it('disables the remote module when false', async () => {\n            const w = new BrowserWindow({\n              show: false,\n              webPreferences: {\n                preload,\n                sandbox,\n                enableRemoteModule: false\n              }\n            });\n            const p = emittedOnce(ipcMain, 'remote');\n            w.loadFile(path.join(fixtures, 'api', 'blank.html'));\n            const [, remote] = await p;\n            expect(remote).to.equal('undefined');\n          });\n\n          it('enables the remote module when true', async () => {\n            const w = new BrowserWindow({\n              show: false,\n              webPreferences: {\n                preload,\n                sandbox,\n                enableRemoteModule: true\n              }\n            });\n            const p = emittedOnce(ipcMain, 'remote');\n            w.loadFile(path.join(fixtures, 'api', 'blank.html'));\n            const [, remote] = await p;\n            expect(remote).to.equal('object');\n          });\n        });\n      };\n\n      generateSpecs('without sandbox', false);\n      generateSpecs('with sandbox', true);\n    });\n\n    describe('\"sandbox\" option', () => {\n      function waitForEvents<T> (emitter: { once: Function }, events: string[], callback: () => void) {\n        let count = events.length;\n        for (const event of events) {\n          emitter.once(event, () => {\n            if (!--count) callback();\n          });\n        }\n      }\n\n      const preload = path.join(path.resolve(__dirname, 'fixtures'), 'module', 'preload-sandbox.js');\n\n      let server: http.Server = null as unknown as http.Server;\n      let serverUrl: string = null as unknown as string;\n\n      before((done) => {\n        server = http.createServer((request, response) => {\n          switch (request.url) {\n            case '/cross-site':\n              response.end(`<html><body><h1>${request.url}</h1></body></html>`);\n              break;\n            default:\n              throw new Error(`unsupported endpoint: ${request.url}`);\n          }\n        }).listen(0, '127.0.0.1', () => {\n          serverUrl = 'http://127.0.0.1:' + (server.address() as AddressInfo).port;\n          done();\n        });\n      });\n\n      after(() => {\n        server.close();\n      });\n\n      it('exposes ipcRenderer to preload script', async () => {\n        const w = new BrowserWindow({\n          show: false,\n          webPreferences: {\n            sandbox: true,\n            preload\n          }\n        });\n        w.loadFile(path.join(fixtures, 'api', 'preload.html'));\n        const [, test] = await emittedOnce(ipcMain, 'answer');\n        expect(test).to.equal('preload');\n      });\n\n      it('exposes ipcRenderer to preload script (path has special chars)', async () => {\n        const preloadSpecialChars = path.join(fixtures, 'module', 'preload-sandbox\u00e6\u00f8 \u00e5\u00fc.js');\n        const w = new BrowserWindow({\n          show: false,\n          webPreferences: {\n            sandbox: true,\n            preload: preloadSpecialChars\n          }\n        });\n        w.loadFile(path.join(fixtures, 'api', 'preload.html'));\n        const [, test] = await emittedOnce(ipcMain, 'answer');\n        expect(test).to.equal('preload');\n      });\n\n      it('exposes \"loaded\" event to preload script', async () => {\n        const w = new BrowserWindow({\n          show: false,\n          webPreferences: {\n            sandbox: true,\n            preload\n          }\n        });\n        w.loadURL('about:blank');\n        await emittedOnce(ipcMain, 'process-loaded');\n      });\n\n      it('exposes \"exit\" event to preload script', async () => {\n        const w = new BrowserWindow({\n          show: false,\n          webPreferences: {\n            sandbox: true,\n            preload\n          }\n        });\n        const htmlPath = path.join(__dirname, 'fixtures', 'api', 'sandbox.html?exit-event');\n        const pageUrl = 'file://' + htmlPath;\n        w.loadURL(pageUrl);\n        const [, url] = await emittedOnce(ipcMain, 'answer');\n        const expectedUrl = process.platform === 'win32'\n          ? 'file:///' + htmlPath.replace(/\\\\/g, '/')\n          : pageUrl;\n        expect(url).to.equal(expectedUrl);\n      });\n\n      it('should open windows in same domain with cross-scripting enabled', async () => {\n        const w = new BrowserWindow({\n          show: false,\n          webPreferences: {\n            sandbox: true,\n            preload\n          }\n        });\n        w.webContents.once('new-window', (event, url, frameName, disposition, options) => {\n          options.webPreferences!.preload = preload;\n        });\n        const htmlPath = path.join(__dirname, 'fixtures', 'api', 'sandbox.html?window-open');\n        const pageUrl = 'file://' + htmlPath;\n        const answer = emittedOnce(ipcMain, 'answer');\n        w.loadURL(pageUrl);\n        const [, url, frameName, , options] = await emittedOnce(w.webContents, 'new-window');\n        const expectedUrl = process.platform === 'win32'\n          ? 'file:///' + htmlPath.replace(/\\\\/g, '/')\n          : pageUrl;\n        expect(url).to.equal(expectedUrl);\n        expect(frameName).to.equal('popup!');\n        expect(options.width).to.equal(500);\n        expect(options.height).to.equal(600);\n        const [, html] = await answer;\n        expect(html).to.equal('<h1>scripting from opener</h1>');\n      });\n\n      it('should open windows in another domain with cross-scripting disabled', async () => {\n        const w = new BrowserWindow({\n          show: false,\n          webPreferences: {\n            sandbox: true,\n            preload\n          }\n        });\n\n        w.webContents.once('new-window', (event, url, frameName, disposition, options) => {\n          options.webPreferences!.preload = preload;\n        });\n        w.loadFile(\n          path.join(__dirname, 'fixtures', 'api', 'sandbox.html'),\n          { search: 'window-open-external' }\n        );\n\n        // Wait for a message from the main window saying that it's ready.\n        await emittedOnce(ipcMain, 'opener-loaded');\n\n        // Ask the opener to open a popup with window.opener.\n        const expectedPopupUrl = `${serverUrl}/cross-site`; // Set in \"sandbox.html\".\n\n        w.webContents.send('open-the-popup', expectedPopupUrl);\n\n        // The page is going to open a popup that it won't be able to close.\n        // We have to close it from here later.\n        const [, popupWindow] = await emittedOnce(app, 'browser-window-created');\n\n        // Ask the popup window for details.\n        const detailsAnswer = emittedOnce(ipcMain, 'child-loaded');\n        popupWindow.webContents.send('provide-details');\n        const [, openerIsNull, , locationHref] = await detailsAnswer;\n        expect(openerIsNull).to.be.false('window.opener is null');\n        expect(locationHref).to.equal(expectedPopupUrl);\n\n        // Ask the page to access the popup.\n        const touchPopupResult = emittedOnce(ipcMain, 'answer');\n        w.webContents.send('touch-the-popup');\n        const [, popupAccessMessage] = await touchPopupResult;\n\n        // Ask the popup to access the opener.\n        const touchOpenerResult = emittedOnce(ipcMain, 'answer');\n        popupWindow.webContents.send('touch-the-opener');\n        const [, openerAccessMessage] = await touchOpenerResult;\n\n        // We don't need the popup anymore, and its parent page can't close it,\n        // so let's close it from here before we run any checks.\n        await closeWindow(popupWindow, { assertNotWindows: false });\n\n        expect(popupAccessMessage).to.be.a('string',\n          'child\\'s .document is accessible from its parent window');\n        expect(popupAccessMessage).to.match(/^Blocked a frame with origin/);\n        expect(openerAccessMessage).to.be.a('string',\n          'opener .document is accessible from a popup window');\n        expect(openerAccessMessage).to.match(/^Blocked a frame with origin/);\n      });\n\n      it('should inherit the sandbox setting in opened windows', async () => {\n        const w = new BrowserWindow({\n          show: false,\n          webPreferences: {\n            sandbox: true\n          }\n        });\n\n        const preloadPath = path.join(fixtures, 'api', 'new-window-preload.js');\n        w.webContents.once('new-window', (event, url, frameName, disposition, options) => {\n          options.webPreferences!.preload = preloadPath;\n        });\n        w.loadFile(path.join(fixtures, 'api', 'new-window.html'));\n        const [, args] = await emittedOnce(ipcMain, 'answer');\n        expect(args).to.include('--enable-sandbox');\n      });\n\n      it('should open windows with the options configured via new-window event listeners', async () => {\n        const w = new BrowserWindow({\n          show: false,\n          webPreferences: {\n            sandbox: true\n          }\n        });\n\n        const preloadPath = path.join(fixtures, 'api', 'new-window-preload.js');\n        w.webContents.once('new-window', (event, url, frameName, disposition, options) => {\n          options.webPreferences!.preload = preloadPath;\n          const prefs = options.webPreferences as any;\n          prefs.foo = 'bar';\n        });\n        w.loadFile(path.join(fixtures, 'api', 'new-window.html'));\n        const [[, childWebContents]] = await Promise.all([\n          emittedOnce(app, 'web-contents-created'),\n          emittedOnce(ipcMain, 'answer')\n        ]);\n        const webPreferences = (childWebContents as any).getLastWebPreferences();\n        expect(webPreferences.foo).to.equal('bar');\n      });\n\n      it('should set ipc event sender correctly', (done) => {\n        const w = new BrowserWindow({\n          show: false,\n          webPreferences: {\n            sandbox: true,\n            preload\n          }\n        });\n        let childWc: WebContents | null = null;\n        w.webContents.on('new-window', (event, url, frameName, disposition, options) => {\n          options.webPreferences!.preload = preload;\n          childWc = (options as any).webContents;\n          expect(w.webContents).to.not.equal(childWc);\n        });\n        ipcMain.once('parent-ready', function (event) {\n          expect(event.sender).to.equal(w.webContents, 'sender should be the parent');\n          event.sender.send('verified');\n        });\n        ipcMain.once('child-ready', function (event) {\n          expect(childWc).to.not.be.null('child webcontents should be available');\n          expect(event.sender).to.equal(childWc, 'sender should be the child');\n          event.sender.send('verified');\n        });\n        waitForEvents(ipcMain, [\n          'parent-answer',\n          'child-answer'\n        ], done);\n        w.loadFile(path.join(__dirname, 'fixtures', 'api', 'sandbox.html'), { search: 'verify-ipc-sender' });\n      });\n\n      describe('event handling', () => {\n        let w: BrowserWindow = null as unknown as BrowserWindow;\n        beforeEach(() => {\n          w = new BrowserWindow({ show: false, webPreferences: { sandbox: true } });\n        });\n        it('works for window events', (done) => {\n          waitForEvents(w, [\n            'page-title-updated'\n          ], done);\n          w.loadURL('data:text/html,<script>document.title = \\'changed\\'</script>');\n        });\n\n        it('works for stop events', (done) => {\n          waitForEvents(w.webContents, [\n            'did-navigate',\n            'did-fail-load',\n            'did-stop-loading'\n          ], done);\n          w.loadURL('data:text/html,<script>stop()</script>');\n        });\n\n        it('works for web contents events', (done) => {\n          waitForEvents(w.webContents, [\n            'did-finish-load',\n            'did-frame-finish-load',\n            'did-navigate-in-page',\n            'will-navigate',\n            'did-start-loading',\n            'did-stop-loading',\n            'did-frame-finish-load',\n            'dom-ready'\n          ], done);\n          w.loadFile(path.join(__dirname, 'fixtures', 'api', 'sandbox.html'), { search: 'webcontents-events' });\n        });\n      });\n\n      it('supports calling preventDefault on new-window events', (done) => {\n        const w = new BrowserWindow({\n          show: false,\n          webPreferences: {\n            sandbox: true\n          }\n        });\n        const initialWebContents = webContents.getAllWebContents().map((i) => i.id);\n        w.webContents.once('new-window', (e) => {\n          e.preventDefault();\n          // We need to give it some time so the windows get properly disposed (at least on OSX).\n          setTimeout(() => {\n            const currentWebContents = webContents.getAllWebContents().map((i) => i.id);\n            try {\n              expect(currentWebContents).to.deep.equal(initialWebContents);\n              done();\n            } catch (error) {\n              done(e);\n            }\n          }, 100);\n        });\n        w.loadFile(path.join(fixtures, 'pages', 'window-open.html'));\n      });\n\n      // see #9387\n      ifit(features.isRemoteModuleEnabled())('properly manages remote object references after page reload', (done) => {\n        const w = new BrowserWindow({\n          show: false,\n          webPreferences: {\n            preload,\n            sandbox: true,\n            enableRemoteModule: true\n          }\n        });\n        w.loadFile(path.join(__dirname, 'fixtures', 'api', 'sandbox.html'), { search: 'reload-remote' });\n\n        ipcMain.on('get-remote-module-path', (event) => {\n          event.returnValue = path.join(fixtures, 'module', 'hello.js');\n        });\n\n        let reload = false;\n        ipcMain.on('reloaded', (event) => {\n          event.returnValue = reload;\n          reload = !reload;\n        });\n\n        ipcMain.once('reload', (event) => {\n          event.sender.reload();\n        });\n\n        ipcMain.once('answer', (event, arg) => {\n          ipcMain.removeAllListeners('reloaded');\n          ipcMain.removeAllListeners('get-remote-module-path');\n          try {\n            expect(arg).to.equal('hi');\n            done();\n          } catch (e) {\n            done(e);\n          }\n        });\n      });\n\n      ifit(features.isRemoteModuleEnabled())('properly manages remote object references after page reload in child window', (done) => {\n        const w = new BrowserWindow({\n          show: false,\n          webPreferences: {\n            preload,\n            sandbox: true,\n            enableRemoteModule: true\n          }\n        });\n        w.webContents.once('new-window', (event, url, frameName, disposition, options) => {\n          options.webPreferences!.preload = preload;\n        });\n\n        w.loadFile(path.join(__dirname, 'fixtures', 'api', 'sandbox.html'), { search: 'reload-remote-child' });\n\n        ipcMain.on('get-remote-module-path', (event) => {\n          event.returnValue = path.join(fixtures, 'module', 'hello-child.js');\n        });\n\n        let reload = false;\n        ipcMain.on('reloaded', (event) => {\n          event.returnValue = reload;\n          reload = !reload;\n        });\n\n        ipcMain.once('reload', (event) => {\n          event.sender.reload();\n        });\n\n        ipcMain.once('answer', (event, arg) => {\n          ipcMain.removeAllListeners('reloaded');\n          ipcMain.removeAllListeners('get-remote-module-path');\n          try {\n            expect(arg).to.equal('hi child window');\n            done();\n          } catch (e) {\n            done(e);\n          }\n        });\n      });\n\n      it('validates process APIs access in sandboxed renderer', async () => {\n        const w = new BrowserWindow({\n          show: false,\n          webPreferences: {\n            sandbox: true,\n            preload\n          }\n        });\n        w.webContents.once('preload-error', (event, preloadPath, error) => {\n          throw error;\n        });\n        process.env.sandboxmain = 'foo';\n        w.loadFile(path.join(fixtures, 'api', 'preload.html'));\n        const [, test] = await emittedOnce(ipcMain, 'answer');\n        expect(test.hasCrash).to.be.true('has crash');\n        expect(test.hasHang).to.be.true('has hang');\n        expect(test.heapStatistics).to.be.an('object');\n        expect(test.blinkMemoryInfo).to.be.an('object');\n        expect(test.processMemoryInfo).to.be.an('object');\n        expect(test.systemVersion).to.be.a('string');\n        expect(test.cpuUsage).to.be.an('object');\n        expect(test.ioCounters).to.be.an('object');\n        expect(test.arch).to.equal(process.arch);\n        expect(test.platform).to.equal(process.platform);\n        expect(test.env).to.deep.equal(process.env);\n        expect(test.execPath).to.equal(process.helperExecPath);\n        expect(test.sandboxed).to.be.true('sandboxed');\n        expect(test.type).to.equal('renderer');\n        expect(test.version).to.equal(process.version);\n        expect(test.versions).to.deep.equal(process.versions);\n\n        if (process.platform === 'linux' && test.osSandbox) {\n          expect(test.creationTime).to.be.null('creation time');\n          expect(test.systemMemoryInfo).to.be.null('system memory info');\n        } else {\n          expect(test.creationTime).to.be.a('number');\n          expect(test.systemMemoryInfo).to.be.an('object');\n        }\n      });\n\n      it('webview in sandbox renderer', async () => {\n        const w = new BrowserWindow({\n          show: false,\n          webPreferences: {\n            sandbox: true,\n            preload,\n            webviewTag: true\n          }\n        });\n        const didAttachWebview = emittedOnce(w.webContents, 'did-attach-webview');\n        const webviewDomReady = emittedOnce(ipcMain, 'webview-dom-ready');\n        w.loadFile(path.join(fixtures, 'pages', 'webview-did-attach-event.html'));\n\n        const [, webContents] = await didAttachWebview;\n        const [, id] = await webviewDomReady;\n        expect(webContents.id).to.equal(id);\n      });\n    });\n\n    describe('nativeWindowOpen option', () => {\n      let w: BrowserWindow = null as unknown as BrowserWindow;\n\n      beforeEach(() => {\n        w = new BrowserWindow({\n          show: false,\n          webPreferences: {\n            nodeIntegration: true,\n            nativeWindowOpen: true,\n            // tests relies on preloads in opened windows\n            nodeIntegrationInSubFrames: true\n          }\n        });\n      });\n\n      it('opens window of about:blank with cross-scripting enabled', async () => {\n        const answer = emittedOnce(ipcMain, 'answer');\n        w.loadFile(path.join(fixtures, 'api', 'native-window-open-blank.html'));\n        const [, content] = await answer;\n        expect(content).to.equal('Hello');\n      });\n      it('opens window of same domain with cross-scripting enabled', async () => {\n        const answer = emittedOnce(ipcMain, 'answer');\n        w.loadFile(path.join(fixtures, 'api', 'native-window-open-file.html'));\n        const [, content] = await answer;\n        expect(content).to.equal('Hello');\n      });\n      it('blocks accessing cross-origin frames', async () => {\n        const answer = emittedOnce(ipcMain, 'answer');\n        w.loadFile(path.join(fixtures, 'api', 'native-window-open-cross-origin.html'));\n        const [, content] = await answer;\n        expect(content).to.equal('Blocked a frame with origin \"file://\" from accessing a cross-origin frame.');\n      });\n      it('opens window from <iframe> tags', async () => {\n        const answer = emittedOnce(ipcMain, 'answer');\n        w.loadFile(path.join(fixtures, 'api', 'native-window-open-iframe.html'));\n        const [, content] = await answer;\n        expect(content).to.equal('Hello');\n      });\n      ifit(!process.env.ELECTRON_SKIP_NATIVE_MODULE_TESTS)('loads native addons correctly after reload', async () => {\n        w.loadFile(path.join(__dirname, 'fixtures', 'api', 'native-window-open-native-addon.html'));\n        {\n          const [, content] = await emittedOnce(ipcMain, 'answer');\n          expect(content).to.equal('function');\n        }\n        w.reload();\n        {\n          const [, content] = await emittedOnce(ipcMain, 'answer');\n          expect(content).to.equal('function');\n        }\n      });\n      it('<webview> works in a scriptable popup', async () => {\n        const preload = path.join(fixtures, 'api', 'new-window-webview-preload.js');\n\n        const w = new BrowserWindow({\n          show: false,\n          webPreferences: {\n            nodeIntegrationInSubFrames: true,\n            nativeWindowOpen: true,\n            webviewTag: true,\n            preload\n          }\n        });\n        w.webContents.once('new-window', (event, url, frameName, disposition, options) => {\n          options.show = false;\n        });\n\n        const webviewLoaded = emittedOnce(ipcMain, 'webview-loaded');\n        w.loadFile(path.join(fixtures, 'api', 'new-window-webview.html'));\n        await webviewLoaded;\n      });\n      it('should inherit the nativeWindowOpen setting in opened windows', async () => {\n        const preloadPath = path.join(fixtures, 'api', 'new-window-preload.js');\n        w.webContents.once('new-window', (event, url, frameName, disposition, options) => {\n          options.webPreferences!.preload = preloadPath;\n        });\n        w.loadFile(path.join(fixtures, 'api', 'new-window.html'));\n        const [, args] = await emittedOnce(ipcMain, 'answer');\n        expect(args).to.include('--native-window-open');\n      });\n      it('should open windows with the options configured via new-window event listeners', async () => {\n        const preloadPath = path.join(fixtures, 'api', 'new-window-preload.js');\n        w.webContents.once('new-window', (event, url, frameName, disposition, options) => {\n          options.webPreferences!.preload = preloadPath;\n          const prefs = options.webPreferences! as any;\n          prefs.foo = 'bar';\n        });\n        w.loadFile(path.join(fixtures, 'api', 'new-window.html'));\n        const [[, childWebContents]] = await Promise.all([\n          emittedOnce(app, 'web-contents-created'),\n          emittedOnce(ipcMain, 'answer')\n        ]);\n        const webPreferences = (childWebContents as any).getLastWebPreferences();\n        expect(webPreferences.foo).to.equal('bar');\n      });\n\n      describe('window.location', () => {\n        const protocols = [\n          ['foo', path.join(fixtures, 'api', 'window-open-location-change.html')],\n          ['bar', path.join(fixtures, 'api', 'window-open-location-final.html')]\n        ];\n        beforeEach(() => {\n          for (const [scheme, path] of protocols) {\n            protocol.registerBufferProtocol(scheme, (request, callback) => {\n              callback({\n                mimeType: 'text/html',\n                data: fs.readFileSync(path)\n              });\n            });\n          }\n        });\n        afterEach(() => {\n          for (const [scheme] of protocols) {\n            protocol.unregisterProtocol(scheme);\n          }\n        });\n        it('retains the original web preferences when window.location is changed to a new origin', async () => {\n          const w = new BrowserWindow({\n            show: false,\n            webPreferences: {\n              nativeWindowOpen: true,\n              // test relies on preloads in opened window\n              nodeIntegrationInSubFrames: true\n            }\n          });\n\n          w.webContents.once('new-window', (event, url, frameName, disposition, options) => {\n            options.webPreferences!.preload = path.join(fixtures, 'api', 'window-open-preload.js');\n          });\n          w.loadFile(path.join(fixtures, 'api', 'window-open-location-open.html'));\n          const [, args, typeofProcess] = await emittedOnce(ipcMain, 'answer');\n          expect(args).not.to.include('--node-integration');\n          expect(args).to.include('--native-window-open');\n          expect(typeofProcess).to.eql('undefined');\n        });\n\n        it('window.opener is not null when window.location is changed to a new origin', async () => {\n          const w = new BrowserWindow({\n            show: false,\n            webPreferences: {\n              nativeWindowOpen: true,\n              // test relies on preloads in opened window\n              nodeIntegrationInSubFrames: true\n            }\n          });\n\n          w.webContents.once('new-window', (event, url, frameName, disposition, options) => {\n            options.webPreferences!.preload = path.join(fixtures, 'api', 'window-open-preload.js');\n          });\n          w.loadFile(path.join(fixtures, 'api', 'window-open-location-open.html'));\n          const [, , , windowOpenerIsNull] = await emittedOnce(ipcMain, 'answer');\n          expect(windowOpenerIsNull).to.be.false('window.opener is null');\n        });\n      });\n    });\n\n    describe('\"disableHtmlFullscreenWindowResize\" option', () => {\n      it('prevents window from resizing when set', async () => {\n        const w = new BrowserWindow({\n          show: false,\n          webPreferences: {\n            disableHtmlFullscreenWindowResize: true\n          }\n        });\n        await w.loadURL('about:blank');\n        const size = w.getSize();\n        const enterHtmlFullScreen = emittedOnce(w.webContents, 'enter-html-full-screen');\n        w.webContents.executeJavaScript('document.body.webkitRequestFullscreen()', true);\n        await enterHtmlFullScreen;\n        expect(w.getSize()).to.deep.equal(size);\n      });\n    });\n  });\n\n  describe('nativeWindowOpen + contextIsolation options', () => {\n    afterEach(closeAllWindows);\n    it('opens window with cross-scripting enabled from isolated context', async () => {\n      const w = new BrowserWindow({\n        show: false,\n        webPreferences: {\n          nativeWindowOpen: true,\n          contextIsolation: true,\n          preload: path.join(fixtures, 'api', 'native-window-open-isolated-preload.js')\n        }\n      });\n      w.loadFile(path.join(fixtures, 'api', 'native-window-open-isolated.html'));\n      const [, content] = await emittedOnce(ipcMain, 'answer');\n      expect(content).to.equal('Hello');\n    });\n  });\n\n  describe('beforeunload handler', function () {\n    let w: BrowserWindow = null as unknown as BrowserWindow;\n    beforeEach(() => {\n      w = new BrowserWindow({ show: false, webPreferences: { nodeIntegration: true } });\n    });\n    afterEach(closeAllWindows);\n\n    it('returning undefined would not prevent close', async () => {\n      await w.loadFile(path.join(__dirname, 'fixtures', 'api', 'beforeunload-undefined.html'));\n      const wait = emittedOnce(w, 'closed');\n      w.close();\n      await wait;\n    });\n\n    it('returning false would prevent close', async () => {\n      await w.loadFile(path.join(__dirname, 'fixtures', 'api', 'beforeunload-false.html'));\n      w.close();\n      const [, proceed] = await emittedOnce(w.webContents, 'before-unload-fired');\n      expect(proceed).to.equal(false);\n    });\n\n    it('returning empty string would prevent close', async () => {\n      await w.loadFile(path.join(__dirname, 'fixtures', 'api', 'beforeunload-empty-string.html'));\n      w.close();\n      const [, proceed] = await emittedOnce(w.webContents, 'before-unload-fired');\n      expect(proceed).to.equal(false);\n    });\n\n    it('emits for each close attempt', async () => {\n      await w.loadFile(path.join(__dirname, 'fixtures', 'api', 'beforeunload-false-prevent3.html'));\n\n      const destroyListener = () => { expect.fail('Close was not prevented'); };\n      w.webContents.once('destroyed', destroyListener);\n\n      w.webContents.executeJavaScript('installBeforeUnload(2)', true);\n      // The renderer needs to report the status of beforeunload handler\n      // back to main process, so wait for next console message, which means\n      // the SuddenTerminationStatus message have been flushed.\n      await emittedOnce(w.webContents, 'console-message');\n      w.close();\n      await emittedOnce(w.webContents, 'before-unload-fired');\n      w.close();\n      await emittedOnce(w.webContents, 'before-unload-fired');\n\n      w.webContents.removeListener('destroyed', destroyListener);\n      const wait = emittedOnce(w, 'closed');\n      w.close();\n      await wait;\n    });\n\n    it('emits for each reload attempt', async () => {\n      await w.loadFile(path.join(__dirname, 'fixtures', 'api', 'beforeunload-false-prevent3.html'));\n\n      const navigationListener = () => { expect.fail('Reload was not prevented'); };\n      w.webContents.once('did-start-navigation', navigationListener);\n\n      w.webContents.executeJavaScript('installBeforeUnload(2)', true);\n      // The renderer needs to report the status of beforeunload handler\n      // back to main process, so wait for next console message, which means\n      // the SuddenTerminationStatus message have been flushed.\n      await emittedOnce(w.webContents, 'console-message');\n      w.reload();\n      // Chromium does not emit 'before-unload-fired' on WebContents for\n      // navigations, so we have to use other ways to know if beforeunload\n      // is fired.\n      await emittedUntil(w.webContents, 'console-message', isBeforeUnload);\n      w.reload();\n      await emittedUntil(w.webContents, 'console-message', isBeforeUnload);\n\n      w.webContents.removeListener('did-start-navigation', navigationListener);\n      w.reload();\n      await emittedOnce(w.webContents, 'did-finish-load');\n    });\n\n    it('emits for each navigation attempt', async () => {\n      await w.loadFile(path.join(__dirname, 'fixtures', 'api', 'beforeunload-false-prevent3.html'));\n\n      const navigationListener = () => { expect.fail('Reload was not prevented'); };\n      w.webContents.once('did-start-navigation', navigationListener);\n\n      w.webContents.executeJavaScript('installBeforeUnload(2)', true);\n      // The renderer needs to report the status of beforeunload handler\n      // back to main process, so wait for next console message, which means\n      // the SuddenTerminationStatus message have been flushed.\n      await emittedOnce(w.webContents, 'console-message');\n      w.loadURL('about:blank');\n      // Chromium does not emit 'before-unload-fired' on WebContents for\n      // navigations, so we have to use other ways to know if beforeunload\n      // is fired.\n      await emittedUntil(w.webContents, 'console-message', isBeforeUnload);\n      w.loadURL('about:blank');\n      await emittedUntil(w.webContents, 'console-message', isBeforeUnload);\n\n      w.webContents.removeListener('did-start-navigation', navigationListener);\n      await w.loadURL('about:blank');\n    });\n  });\n\n  describe('document.visibilityState/hidden', () => {\n    afterEach(closeAllWindows);\n\n    it('visibilityState is initially visible despite window being hidden', async () => {\n      const w = new BrowserWindow({\n        show: false,\n        width: 100,\n        height: 100,\n        webPreferences: {\n          nodeIntegration: true\n        }\n      });\n\n      let readyToShow = false;\n      w.once('ready-to-show', () => {\n        readyToShow = true;\n      });\n\n      w.loadFile(path.join(fixtures, 'pages', 'visibilitychange.html'));\n\n      const [, visibilityState, hidden] = await emittedOnce(ipcMain, 'pong');\n\n      expect(readyToShow).to.be.false('ready to show');\n      expect(visibilityState).to.equal('visible');\n      expect(hidden).to.be.false('hidden');\n    });\n\n    // TODO(nornagon): figure out why this is failing on windows\n    ifit(process.platform !== 'win32')('visibilityState changes when window is hidden', async () => {\n      const w = new BrowserWindow({\n        width: 100,\n        height: 100,\n        webPreferences: {\n          nodeIntegration: true\n        }\n      });\n\n      w.loadFile(path.join(fixtures, 'pages', 'visibilitychange.html'));\n\n      {\n        const [, visibilityState, hidden] = await emittedOnce(ipcMain, 'pong');\n        expect(visibilityState).to.equal('visible');\n        expect(hidden).to.be.false('hidden');\n      }\n\n      w.hide();\n\n      {\n        const [, visibilityState, hidden] = await emittedOnce(ipcMain, 'pong');\n        expect(visibilityState).to.equal('hidden');\n        expect(hidden).to.be.true('hidden');\n      }\n    });\n\n    // TODO(nornagon): figure out why this is failing on windows\n    ifit(process.platform !== 'win32')('visibilityState changes when window is shown', async () => {\n      const w = new BrowserWindow({\n        width: 100,\n        height: 100,\n        webPreferences: {\n          nodeIntegration: true\n        }\n      });\n\n      w.loadFile(path.join(fixtures, 'pages', 'visibilitychange.html'));\n      if (process.platform === 'darwin') {\n        // See https://github.com/electron/electron/issues/8664\n        await emittedOnce(w, 'show');\n      }\n      w.hide();\n      w.show();\n      const [, visibilityState] = await emittedOnce(ipcMain, 'pong');\n      expect(visibilityState).to.equal('visible');\n    });\n\n    ifit(process.platform !== 'win32')('visibilityState changes when window is shown inactive', async () => {\n      const w = new BrowserWindow({\n        width: 100,\n        height: 100,\n        webPreferences: {\n          nodeIntegration: true\n        }\n      });\n      w.loadFile(path.join(fixtures, 'pages', 'visibilitychange.html'));\n      if (process.platform === 'darwin') {\n        // See https://github.com/electron/electron/issues/8664\n        await emittedOnce(w, 'show');\n      }\n      w.hide();\n      w.showInactive();\n      const [, visibilityState] = await emittedOnce(ipcMain, 'pong');\n      expect(visibilityState).to.equal('visible');\n    });\n\n    // TODO(nornagon): figure out why this is failing on windows\n    ifit(process.platform === 'darwin')('visibilityState changes when window is minimized', async () => {\n      const w = new BrowserWindow({\n        width: 100,\n        height: 100,\n        webPreferences: {\n          nodeIntegration: true\n        }\n      });\n      w.loadFile(path.join(fixtures, 'pages', 'visibilitychange.html'));\n\n      {\n        const [, visibilityState, hidden] = await emittedOnce(ipcMain, 'pong');\n        expect(visibilityState).to.equal('visible');\n        expect(hidden).to.be.false('hidden');\n      }\n\n      w.minimize();\n\n      {\n        const [, visibilityState, hidden] = await emittedOnce(ipcMain, 'pong');\n        expect(visibilityState).to.equal('hidden');\n        expect(hidden).to.be.true('hidden');\n      }\n    });\n\n    // FIXME(MarshallOfSound): This test fails locally 100% of the time, on CI it started failing\n    // when we introduced the compositor recycling patch.  Should figure out how to fix this\n    it.skip('visibilityState remains visible if backgroundThrottling is disabled', async () => {\n      const w = new BrowserWindow({\n        show: false,\n        width: 100,\n        height: 100,\n        webPreferences: {\n          backgroundThrottling: false,\n          nodeIntegration: true\n        }\n      });\n      w.loadFile(path.join(fixtures, 'pages', 'visibilitychange.html'));\n      {\n        const [, visibilityState, hidden] = await emittedOnce(ipcMain, 'pong');\n        expect(visibilityState).to.equal('visible');\n        expect(hidden).to.be.false('hidden');\n      }\n\n      ipcMain.once('pong', (event, visibilityState, hidden) => {\n        throw new Error(`Unexpected visibility change event. visibilityState: ${visibilityState} hidden: ${hidden}`);\n      });\n      try {\n        const shown1 = emittedOnce(w, 'show');\n        w.show();\n        await shown1;\n        const hidden = emittedOnce(w, 'hide');\n        w.hide();\n        await hidden;\n        const shown2 = emittedOnce(w, 'show');\n        w.show();\n        await shown2;\n      } finally {\n        ipcMain.removeAllListeners('pong');\n      }\n    });\n  });\n\n  describe('new-window event', () => {\n    afterEach(closeAllWindows);\n\n    it('emits when window.open is called', (done) => {\n      const w = new BrowserWindow({ show: false, webPreferences: { nodeIntegration: true } });\n      w.webContents.once('new-window', (e, url, frameName, disposition, options, additionalFeatures) => {\n        e.preventDefault();\n        try {\n          expect(url).to.equal('http://host/');\n          expect(frameName).to.equal('host');\n          expect(additionalFeatures[0]).to.equal('this-is-not-a-standard-feature');\n          done();\n        } catch (e) {\n          done(e);\n        }\n      });\n      w.loadFile(path.join(fixtures, 'pages', 'window-open.html'));\n    });\n\n    it('emits when window.open is called with no webPreferences', (done) => {\n      const w = new BrowserWindow({ show: false });\n      w.webContents.once('new-window', function (e, url, frameName, disposition, options, additionalFeatures) {\n        e.preventDefault();\n        try {\n          expect(url).to.equal('http://host/');\n          expect(frameName).to.equal('host');\n          expect(additionalFeatures[0]).to.equal('this-is-not-a-standard-feature');\n          done();\n        } catch (e) {\n          done(e);\n        }\n      });\n      w.loadFile(path.join(fixtures, 'pages', 'window-open.html'));\n    });\n\n    it('emits when link with target is called', (done) => {\n      const w = new BrowserWindow({ show: false, webPreferences: { nodeIntegration: true } });\n      w.webContents.once('new-window', (e, url, frameName) => {\n        e.preventDefault();\n        try {\n          expect(url).to.equal('http://host/');\n          expect(frameName).to.equal('target');\n          done();\n        } catch (e) {\n          done(e);\n        }\n      });\n      w.loadFile(path.join(fixtures, 'pages', 'target-name.html'));\n    });\n  });\n\n  ifdescribe(process.platform !== 'linux')('max/minimize events', () => {\n    afterEach(closeAllWindows);\n    it('emits an event when window is maximized', (done) => {\n      const w = new BrowserWindow({ show: false });\n      w.once('maximize', () => { done(); });\n      w.show();\n      w.maximize();\n    });\n\n    it('emits an event when window is unmaximized', (done) => {\n      const w = new BrowserWindow({ show: false });\n      w.once('unmaximize', () => { done(); });\n      w.show();\n      w.maximize();\n      w.unmaximize();\n    });\n\n    it('emits an event when window is minimized', (done) => {\n      const w = new BrowserWindow({ show: false });\n      w.once('minimize', () => { done(); });\n      w.show();\n      w.minimize();\n    });\n  });\n\n  describe('beginFrameSubscription method', () => {\n    it('does not crash when callback returns nothing', (done) => {\n      const w = new BrowserWindow({ show: false });\n      w.loadFile(path.join(fixtures, 'api', 'frame-subscriber.html'));\n      w.webContents.on('dom-ready', () => {\n        w.webContents.beginFrameSubscription(function () {\n          // Pending endFrameSubscription to next tick can reliably reproduce\n          // a crash which happens when nothing is returned in the callback.\n          setTimeout(() => {\n            w.webContents.endFrameSubscription();\n            done();\n          });\n        });\n      });\n    });\n\n    it('subscribes to frame updates', (done) => {\n      const w = new BrowserWindow({ show: false });\n      let called = false;\n      w.loadFile(path.join(fixtures, 'api', 'frame-subscriber.html'));\n      w.webContents.on('dom-ready', () => {\n        w.webContents.beginFrameSubscription(function (data) {\n          // This callback might be called twice.\n          if (called) return;\n          called = true;\n\n          try {\n            expect(data.constructor.name).to.equal('NativeImage');\n            expect(data.isEmpty()).to.be.false('data is empty');\n            done();\n          } catch (e) {\n            done(e);\n          } finally {\n            w.webContents.endFrameSubscription();\n          }\n        });\n      });\n    });\n\n    it('subscribes to frame updates (only dirty rectangle)', (done) => {\n      const w = new BrowserWindow({ show: false });\n      let called = false;\n      let gotInitialFullSizeFrame = false;\n      const [contentWidth, contentHeight] = w.getContentSize();\n      w.webContents.on('did-finish-load', () => {\n        w.webContents.beginFrameSubscription(true, (image, rect) => {\n          if (image.isEmpty()) {\n            // Chromium sometimes sends a 0x0 frame at the beginning of the\n            // page load.\n            return;\n          }\n          if (rect.height === contentHeight && rect.width === contentWidth &&\n            !gotInitialFullSizeFrame) {\n            // The initial frame is full-size, but we're looking for a call\n            // with just the dirty-rect. The next frame should be a smaller\n            // rect.\n            gotInitialFullSizeFrame = true;\n            return;\n          }\n          // This callback might be called twice.\n          if (called) return;\n          // We asked for just the dirty rectangle, so we expect to receive a\n          // rect smaller than the full size.\n          // TODO(jeremy): this is failing on windows currently; investigate.\n          // assert(rect.width < contentWidth || rect.height < contentHeight)\n          called = true;\n\n          try {\n            const expectedSize = rect.width * rect.height * 4;\n            expect(image.getBitmap()).to.be.an.instanceOf(Buffer).with.lengthOf(expectedSize);\n            done();\n          } catch (e) {\n            done(e);\n          } finally {\n            w.webContents.endFrameSubscription();\n          }\n        });\n      });\n      w.loadFile(path.join(fixtures, 'api', 'frame-subscriber.html'));\n    });\n\n    it('throws error when subscriber is not well defined', () => {\n      const w = new BrowserWindow({ show: false });\n      expect(() => {\n        w.webContents.beginFrameSubscription(true, true as any);\n        // TODO(zcbenz): gin is weak at guessing parameter types, we should\n        // upstream native_mate's implementation to gin.\n      }).to.throw('Error processing argument at index 1, conversion failure from ');\n    });\n  });\n\n  describe('savePage method', () => {\n    const savePageDir = path.join(fixtures, 'save_page');\n    const savePageHtmlPath = path.join(savePageDir, 'save_page.html');\n    const savePageJsPath = path.join(savePageDir, 'save_page_files', 'test.js');\n    const savePageCssPath = path.join(savePageDir, 'save_page_files', 'test.css');\n\n    after(() => {\n      try {\n        fs.unlinkSync(savePageCssPath);\n        fs.unlinkSync(savePageJsPath);\n        fs.unlinkSync(savePageHtmlPath);\n        fs.rmdirSync(path.join(savePageDir, 'save_page_files'));\n        fs.rmdirSync(savePageDir);\n      } catch (e) {\n        // Ignore error\n      }\n    });\n    afterEach(closeAllWindows);\n\n    it('should save page to disk', async () => {\n      const w = new BrowserWindow({ show: false });\n      await w.loadFile(path.join(fixtures, 'pages', 'save_page', 'index.html'));\n      await w.webContents.savePage(savePageHtmlPath, 'HTMLComplete');\n\n      expect(fs.existsSync(savePageHtmlPath)).to.be.true('html path');\n      expect(fs.existsSync(savePageJsPath)).to.be.true('js path');\n      expect(fs.existsSync(savePageCssPath)).to.be.true('css path');\n    });\n  });\n\n  describe('BrowserWindow options argument is optional', () => {\n    afterEach(closeAllWindows);\n    it('should create a window with default size (800x600)', () => {\n      const w = new BrowserWindow();\n      expect(w.getSize()).to.deep.equal([800, 600]);\n    });\n  });\n\n  describe('BrowserWindow.restore()', () => {\n    afterEach(closeAllWindows);\n    it('should restore the previous window size', () => {\n      const w = new BrowserWindow({\n        minWidth: 800,\n        width: 800\n      });\n\n      const initialSize = w.getSize();\n      w.minimize();\n      w.restore();\n      expectBoundsEqual(w.getSize(), initialSize);\n    });\n\n    it('does not crash when restoring hidden minimized window', () => {\n      const w = new BrowserWindow({});\n      w.minimize();\n      w.hide();\n      w.show();\n    });\n  });\n\n  describe('BrowserWindow.unmaximize()', () => {\n    afterEach(closeAllWindows);\n    it('should restore the previous window position', () => {\n      const w = new BrowserWindow();\n\n      const initialPosition = w.getPosition();\n      w.maximize();\n      w.unmaximize();\n      expectBoundsEqual(w.getPosition(), initialPosition);\n    });\n  });\n\n  describe('setFullScreen(false)', () => {\n    afterEach(closeAllWindows);\n\n    // only applicable to windows: https://github.com/electron/electron/issues/6036\n    ifdescribe(process.platform === 'win32')('on windows', () => {\n      it('should restore a normal visible window from a fullscreen startup state', async () => {\n        const w = new BrowserWindow({ show: false });\n        await w.loadURL('about:blank');\n        const shown = emittedOnce(w, 'show');\n        // start fullscreen and hidden\n        w.setFullScreen(true);\n        w.show();\n        await shown;\n        const leftFullScreen = emittedOnce(w, 'leave-full-screen');\n        w.setFullScreen(false);\n        await leftFullScreen;\n        expect(w.isVisible()).to.be.true('visible');\n        expect(w.isFullScreen()).to.be.false('fullscreen');\n      });\n      it('should keep window hidden if already in hidden state', async () => {\n        const w = new BrowserWindow({ show: false });\n        await w.loadURL('about:blank');\n        const leftFullScreen = emittedOnce(w, 'leave-full-screen');\n        w.setFullScreen(false);\n        await leftFullScreen;\n        expect(w.isVisible()).to.be.false('visible');\n        expect(w.isFullScreen()).to.be.false('fullscreen');\n      });\n    });\n\n    ifdescribe(process.platform === 'darwin')('BrowserWindow.setFullScreen(false) when HTML fullscreen', () => {\n      it('exits HTML fullscreen when window leaves fullscreen', async () => {\n        const w = new BrowserWindow();\n        await w.loadURL('about:blank');\n        await w.webContents.executeJavaScript('document.body.webkitRequestFullscreen()', true);\n        await emittedOnce(w, 'enter-full-screen');\n        // Wait a tick for the full-screen state to 'stick'\n        await delay();\n        w.setFullScreen(false);\n        await emittedOnce(w, 'leave-html-full-screen');\n      });\n    });\n  });\n\n  describe('parent window', () => {\n    afterEach(closeAllWindows);\n\n    ifit(process.platform === 'darwin')('sheet-begin event emits when window opens a sheet', (done) => {\n      const w = new BrowserWindow();\n      w.once('sheet-begin', () => {\n        done();\n      });\n      // eslint-disable-next-line no-new\n      new BrowserWindow({\n        modal: true,\n        parent: w\n      });\n    });\n\n    ifit(process.platform === 'darwin')('sheet-end event emits when window has closed a sheet', (done) => {\n      const w = new BrowserWindow();\n      const sheet = new BrowserWindow({\n        modal: true,\n        parent: w\n      });\n      w.once('sheet-end', () => { done(); });\n      sheet.close();\n    });\n\n    describe('parent option', () => {\n      it('sets parent window', () => {\n        const w = new BrowserWindow({ show: false });\n        const c = new BrowserWindow({ show: false, parent: w });\n        expect(c.getParentWindow()).to.equal(w);\n      });\n      it('adds window to child windows of parent', () => {\n        const w = new BrowserWindow({ show: false });\n        const c = new BrowserWindow({ show: false, parent: w });\n        expect(w.getChildWindows()).to.deep.equal([c]);\n      });\n      it('removes from child windows of parent when window is closed', async () => {\n        const w = new BrowserWindow({ show: false });\n        const c = new BrowserWindow({ show: false, parent: w });\n        const closed = emittedOnce(c, 'closed');\n        c.close();\n        await closed;\n        // The child window list is not immediately cleared, so wait a tick until it's ready.\n        await delay();\n        expect(w.getChildWindows().length).to.equal(0);\n      });\n\n      it('should not affect the show option', () => {\n        const w = new BrowserWindow({ show: false });\n        const c = new BrowserWindow({ show: false, parent: w });\n        expect(c.isVisible()).to.be.false('child is visible');\n        expect(c.getParentWindow().isVisible()).to.be.false('parent is visible');\n      });\n    });\n\n    describe('win.setParentWindow(parent)', () => {\n      it('sets parent window', () => {\n        const w = new BrowserWindow({ show: false });\n        const c = new BrowserWindow({ show: false });\n        expect(w.getParentWindow()).to.be.null('w.parent');\n        expect(c.getParentWindow()).to.be.null('c.parent');\n        c.setParentWindow(w);\n        expect(c.getParentWindow()).to.equal(w);\n        c.setParentWindow(null);\n        expect(c.getParentWindow()).to.be.null('c.parent');\n      });\n      it('adds window to child windows of parent', () => {\n        const w = new BrowserWindow({ show: false });\n        const c = new BrowserWindow({ show: false });\n        expect(w.getChildWindows()).to.deep.equal([]);\n        c.setParentWindow(w);\n        expect(w.getChildWindows()).to.deep.equal([c]);\n        c.setParentWindow(null);\n        expect(w.getChildWindows()).to.deep.equal([]);\n      });\n      it('removes from child windows of parent when window is closed', async () => {\n        const w = new BrowserWindow({ show: false });\n        const c = new BrowserWindow({ show: false });\n        const closed = emittedOnce(c, 'closed');\n        c.setParentWindow(w);\n        c.close();\n        await closed;\n        // The child window list is not immediately cleared, so wait a tick until it's ready.\n        await delay();\n        expect(w.getChildWindows().length).to.equal(0);\n      });\n    });\n\n    describe('modal option', () => {\n      it('does not freeze or crash', async () => {\n        const parentWindow = new BrowserWindow();\n\n        const createTwo = async () => {\n          const two = new BrowserWindow({\n            width: 300,\n            height: 200,\n            parent: parentWindow,\n            modal: true,\n            show: false\n          });\n\n          const twoShown = emittedOnce(two, 'show');\n          two.show();\n          await twoShown;\n          setTimeout(() => two.close(), 500);\n\n          await emittedOnce(two, 'closed');\n        };\n\n        const one = new BrowserWindow({\n          width: 600,\n          height: 400,\n          parent: parentWindow,\n          modal: true,\n          show: false\n        });\n\n        const oneShown = emittedOnce(one, 'show');\n        one.show();\n        await oneShown;\n        setTimeout(() => one.destroy(), 500);\n\n        await emittedOnce(one, 'closed');\n        await createTwo();\n      });\n\n      ifit(process.platform !== 'darwin')('disables parent window', () => {\n        const w = new BrowserWindow({ show: false });\n        const c = new BrowserWindow({ show: false, parent: w, modal: true });\n        expect(w.isEnabled()).to.be.true('w.isEnabled');\n        c.show();\n        expect(w.isEnabled()).to.be.false('w.isEnabled');\n      });\n\n      ifit(process.platform !== 'darwin')('re-enables an enabled parent window when closed', async () => {\n        const w = new BrowserWindow({ show: false });\n        const c = new BrowserWindow({ show: false, parent: w, modal: true });\n        const closed = emittedOnce(c, 'closed');\n        c.show();\n        c.close();\n        await closed;\n        expect(w.isEnabled()).to.be.true('w.isEnabled');\n      });\n\n      ifit(process.platform !== 'darwin')('does not re-enable a disabled parent window when closed', async () => {\n        const w = new BrowserWindow({ show: false });\n        const c = new BrowserWindow({ show: false, parent: w, modal: true });\n        const closed = emittedOnce(c, 'closed');\n        w.setEnabled(false);\n        c.show();\n        c.close();\n        await closed;\n        expect(w.isEnabled()).to.be.false('w.isEnabled');\n      });\n\n      ifit(process.platform !== 'darwin')('disables parent window recursively', () => {\n        const w = new BrowserWindow({ show: false });\n        const c = new BrowserWindow({ show: false, parent: w, modal: true });\n        const c2 = new BrowserWindow({ show: false, parent: w, modal: true });\n        c.show();\n        expect(w.isEnabled()).to.be.false('w.isEnabled');\n        c2.show();\n        expect(w.isEnabled()).to.be.false('w.isEnabled');\n        c.destroy();\n        expect(w.isEnabled()).to.be.false('w.isEnabled');\n        c2.destroy();\n        expect(w.isEnabled()).to.be.true('w.isEnabled');\n      });\n    });\n  });\n\n  describe('window states', () => {\n    afterEach(closeAllWindows);\n    it('does not resize frameless windows when states change', () => {\n      const w = new BrowserWindow({\n        frame: false,\n        width: 300,\n        height: 200,\n        show: false\n      });\n\n      w.minimizable = false;\n      w.minimizable = true;\n      expect(w.getSize()).to.deep.equal([300, 200]);\n\n      w.resizable = false;\n      w.resizable = true;\n      expect(w.getSize()).to.deep.equal([300, 200]);\n\n      w.maximizable = false;\n      w.maximizable = true;\n      expect(w.getSize()).to.deep.equal([300, 200]);\n\n      w.fullScreenable = false;\n      w.fullScreenable = true;\n      expect(w.getSize()).to.deep.equal([300, 200]);\n\n      w.closable = false;\n      w.closable = true;\n      expect(w.getSize()).to.deep.equal([300, 200]);\n    });\n\n    describe('resizable state', () => {\n      it('with properties', () => {\n        it('can be set with resizable constructor option', () => {\n          const w = new BrowserWindow({ show: false, resizable: false });\n          expect(w.resizable).to.be.false('resizable');\n\n          if (process.platform === 'darwin') {\n            expect(w.maximizable).to.to.true('maximizable');\n          }\n        });\n\n        it('can be changed', () => {\n          const w = new BrowserWindow({ show: false });\n          expect(w.resizable).to.be.true('resizable');\n          w.resizable = false;\n          expect(w.resizable).to.be.false('resizable');\n          w.resizable = true;\n          expect(w.resizable).to.be.true('resizable');\n        });\n      });\n\n      it('with functions', () => {\n        it('can be set with resizable constructor option', () => {\n          const w = new BrowserWindow({ show: false, resizable: false });\n          expect(w.isResizable()).to.be.false('resizable');\n\n          if (process.platform === 'darwin') {\n            expect(w.isMaximizable()).to.to.true('maximizable');\n          }\n        });\n\n        it('can be changed', () => {\n          const w = new BrowserWindow({ show: false });\n          expect(w.isResizable()).to.be.true('resizable');\n          w.setResizable(false);\n          expect(w.isResizable()).to.be.false('resizable');\n          w.setResizable(true);\n          expect(w.isResizable()).to.be.true('resizable');\n        });\n      });\n\n      it('works for a frameless window', () => {\n        const w = new BrowserWindow({ show: false, frame: false });\n        expect(w.resizable).to.be.true('resizable');\n\n        if (process.platform === 'win32') {\n          const w = new BrowserWindow({ show: false, thickFrame: false });\n          expect(w.resizable).to.be.false('resizable');\n        }\n      });\n\n      ifit(process.platform === 'win32')('works for a window smaller than 64x64', () => {\n        const w = new BrowserWindow({\n          show: false,\n          frame: false,\n          resizable: false,\n          transparent: true\n        });\n        w.setContentSize(60, 60);\n        expectBoundsEqual(w.getContentSize(), [60, 60]);\n        w.setContentSize(30, 30);\n        expectBoundsEqual(w.getContentSize(), [30, 30]);\n        w.setContentSize(10, 10);\n        expectBoundsEqual(w.getContentSize(), [10, 10]);\n      });\n    });\n\n    describe('loading main frame state', () => {\n      let server: http.Server = null as unknown as http.Server;\n      let serverUrl: string = null as unknown as string;\n\n      before((done) => {\n        server = http.createServer((request, response) => {\n          response.end();\n        }).listen(0, '127.0.0.1', () => {\n          serverUrl = 'http://127.0.0.1:' + (server.address() as AddressInfo).port;\n          done();\n        });\n      });\n\n      after(() => {\n        server.close();\n      });\n\n      it('is true when the main frame is loading', async () => {\n        const w = new BrowserWindow({ show: false });\n\n        const didStartLoading = emittedOnce(w.webContents, 'did-start-loading');\n        w.webContents.loadURL(serverUrl);\n        await didStartLoading;\n\n        expect(w.webContents.isLoadingMainFrame()).to.be.true('isLoadingMainFrame');\n      });\n\n      it('is false when only a subframe is loading', async () => {\n        const w = new BrowserWindow({ show: false });\n\n        const didStopLoading = emittedOnce(w.webContents, 'did-stop-loading');\n        w.webContents.loadURL(serverUrl);\n        await didStopLoading;\n\n        expect(w.webContents.isLoadingMainFrame()).to.be.false('isLoadingMainFrame');\n\n        const didStartLoading = emittedOnce(w.webContents, 'did-start-loading');\n        w.webContents.executeJavaScript(`\n          var iframe = document.createElement('iframe')\n          iframe.src = '${serverUrl}/page2'\n          document.body.appendChild(iframe)\n        `);\n        await didStartLoading;\n\n        expect(w.webContents.isLoadingMainFrame()).to.be.false('isLoadingMainFrame');\n      });\n\n      it('is true when navigating to pages from the same origin', async () => {\n        const w = new BrowserWindow({ show: false });\n\n        const didStopLoading = emittedOnce(w.webContents, 'did-stop-loading');\n        w.webContents.loadURL(serverUrl);\n        await didStopLoading;\n\n        expect(w.webContents.isLoadingMainFrame()).to.be.false('isLoadingMainFrame');\n\n        const didStartLoading = emittedOnce(w.webContents, 'did-start-loading');\n        w.webContents.loadURL(`${serverUrl}/page2`);\n        await didStartLoading;\n\n        expect(w.webContents.isLoadingMainFrame()).to.be.true('isLoadingMainFrame');\n      });\n    });\n  });\n\n  ifdescribe(process.platform !== 'linux')('window states (excluding Linux)', () => {\n    // Not implemented on Linux.\n    afterEach(closeAllWindows);\n\n    describe('movable state', () => {\n      it('with properties', () => {\n        it('can be set with movable constructor option', () => {\n          const w = new BrowserWindow({ show: false, movable: false });\n          expect(w.movable).to.be.false('movable');\n        });\n\n        it('can be changed', () => {\n          const w = new BrowserWindow({ show: false });\n          expect(w.movable).to.be.true('movable');\n          w.movable = false;\n          expect(w.movable).to.be.false('movable');\n          w.movable = true;\n          expect(w.movable).to.be.true('movable');\n        });\n      });\n\n      it('with functions', () => {\n        it('can be set with movable constructor option', () => {\n          const w = new BrowserWindow({ show: false, movable: false });\n          expect(w.isMovable()).to.be.false('movable');\n        });\n\n        it('can be changed', () => {\n          const w = new BrowserWindow({ show: false });\n          expect(w.isMovable()).to.be.true('movable');\n          w.setMovable(false);\n          expect(w.isMovable()).to.be.false('movable');\n          w.setMovable(true);\n          expect(w.isMovable()).to.be.true('movable');\n        });\n      });\n    });\n\n    describe('visibleOnAllWorkspaces state', () => {\n      it('with properties', () => {\n        it('can be changed', () => {\n          const w = new BrowserWindow({ show: false });\n          expect(w.visibleOnAllWorkspaces).to.be.false();\n          w.visibleOnAllWorkspaces = true;\n          expect(w.visibleOnAllWorkspaces).to.be.true();\n        });\n      });\n\n      it('with functions', () => {\n        it('can be changed', () => {\n          const w = new BrowserWindow({ show: false });\n          expect(w.isVisibleOnAllWorkspaces()).to.be.false();\n          w.setVisibleOnAllWorkspaces(true);\n          expect(w.isVisibleOnAllWorkspaces()).to.be.true();\n        });\n      });\n    });\n\n    ifdescribe(process.platform === 'darwin')('documentEdited state', () => {\n      it('with properties', () => {\n        it('can be changed', () => {\n          const w = new BrowserWindow({ show: false });\n          expect(w.documentEdited).to.be.false();\n          w.documentEdited = true;\n          expect(w.documentEdited).to.be.true();\n        });\n      });\n\n      it('with functions', () => {\n        it('can be changed', () => {\n          const w = new BrowserWindow({ show: false });\n          expect(w.isDocumentEdited()).to.be.false();\n          w.setDocumentEdited(true);\n          expect(w.isDocumentEdited()).to.be.true();\n        });\n      });\n    });\n\n    ifdescribe(process.platform === 'darwin')('representedFilename', () => {\n      it('with properties', () => {\n        it('can be changed', () => {\n          const w = new BrowserWindow({ show: false });\n          expect(w.representedFilename).to.eql('');\n          w.representedFilename = 'a name';\n          expect(w.representedFilename).to.eql('a name');\n        });\n      });\n\n      it('with functions', () => {\n        it('can be changed', () => {\n          const w = new BrowserWindow({ show: false });\n          expect(w.getRepresentedFilename()).to.eql('');\n          w.setRepresentedFilename('a name');\n          expect(w.getRepresentedFilename()).to.eql('a name');\n        });\n      });\n    });\n\n    describe('native window title', () => {\n      it('with properties', () => {\n        it('can be set with title constructor option', () => {\n          const w = new BrowserWindow({ show: false, title: 'mYtItLe' });\n          expect(w.title).to.eql('mYtItLe');\n        });\n\n        it('can be changed', () => {\n          const w = new BrowserWindow({ show: false });\n          expect(w.title).to.eql('Electron Test Main');\n          w.title = 'NEW TITLE';\n          expect(w.title).to.eql('NEW TITLE');\n        });\n      });\n\n      it('with functions', () => {\n        it('can be set with minimizable constructor option', () => {\n          const w = new BrowserWindow({ show: false, title: 'mYtItLe' });\n          expect(w.getTitle()).to.eql('mYtItLe');\n        });\n\n        it('can be changed', () => {\n          const w = new BrowserWindow({ show: false });\n          expect(w.getTitle()).to.eql('Electron Test Main');\n          w.setTitle('NEW TITLE');\n          expect(w.getTitle()).to.eql('NEW TITLE');\n        });\n      });\n    });\n\n    describe('minimizable state', () => {\n      it('with properties', () => {\n        it('can be set with minimizable constructor option', () => {\n          const w = new BrowserWindow({ show: false, minimizable: false });\n          expect(w.minimizable).to.be.false('minimizable');\n        });\n\n        it('can be changed', () => {\n          const w = new BrowserWindow({ show: false });\n          expect(w.minimizable).to.be.true('minimizable');\n          w.minimizable = false;\n          expect(w.minimizable).to.be.false('minimizable');\n          w.minimizable = true;\n          expect(w.minimizable).to.be.true('minimizable');\n        });\n      });\n\n      it('with functions', () => {\n        it('can be set with minimizable constructor option', () => {\n          const w = new BrowserWindow({ show: false, minimizable: false });\n          expect(w.isMinimizable()).to.be.false('movable');\n        });\n\n        it('can be changed', () => {\n          const w = new BrowserWindow({ show: false });\n          expect(w.isMinimizable()).to.be.true('isMinimizable');\n          w.setMinimizable(false);\n          expect(w.isMinimizable()).to.be.false('isMinimizable');\n          w.setMinimizable(true);\n          expect(w.isMinimizable()).to.be.true('isMinimizable');\n        });\n      });\n    });\n\n    describe('maximizable state (property)', () => {\n      it('with properties', () => {\n        it('can be set with maximizable constructor option', () => {\n          const w = new BrowserWindow({ show: false, maximizable: false });\n          expect(w.maximizable).to.be.false('maximizable');\n        });\n\n        it('can be changed', () => {\n          const w = new BrowserWindow({ show: false });\n          expect(w.maximizable).to.be.true('maximizable');\n          w.maximizable = false;\n          expect(w.maximizable).to.be.false('maximizable');\n          w.maximizable = true;\n          expect(w.maximizable).to.be.true('maximizable');\n        });\n\n        it('is not affected when changing other states', () => {\n          const w = new BrowserWindow({ show: false });\n          w.maximizable = false;\n          expect(w.maximizable).to.be.false('maximizable');\n          w.minimizable = false;\n          expect(w.maximizable).to.be.false('maximizable');\n          w.closable = false;\n          expect(w.maximizable).to.be.false('maximizable');\n\n          w.maximizable = true;\n          expect(w.maximizable).to.be.true('maximizable');\n          w.closable = true;\n          expect(w.maximizable).to.be.true('maximizable');\n          w.fullScreenable = false;\n          expect(w.maximizable).to.be.true('maximizable');\n        });\n      });\n\n      it('with functions', () => {\n        it('can be set with maximizable constructor option', () => {\n          const w = new BrowserWindow({ show: false, maximizable: false });\n          expect(w.isMaximizable()).to.be.false('isMaximizable');\n        });\n\n        it('can be changed', () => {\n          const w = new BrowserWindow({ show: false });\n          expect(w.isMaximizable()).to.be.true('isMaximizable');\n          w.setMaximizable(false);\n          expect(w.isMaximizable()).to.be.false('isMaximizable');\n          w.setMaximizable(true);\n          expect(w.isMaximizable()).to.be.true('isMaximizable');\n        });\n\n        it('is not affected when changing other states', () => {\n          const w = new BrowserWindow({ show: false });\n          w.setMaximizable(false);\n          expect(w.isMaximizable()).to.be.false('isMaximizable');\n          w.setMinimizable(false);\n          expect(w.isMaximizable()).to.be.false('isMaximizable');\n          w.setClosable(false);\n          expect(w.isMaximizable()).to.be.false('isMaximizable');\n\n          w.setMaximizable(true);\n          expect(w.isMaximizable()).to.be.true('isMaximizable');\n          w.setClosable(true);\n          expect(w.isMaximizable()).to.be.true('isMaximizable');\n          w.setFullScreenable(false);\n          expect(w.isMaximizable()).to.be.true('isMaximizable');\n        });\n      });\n    });\n\n    ifdescribe(process.platform === 'win32')('maximizable state', () => {\n      it('with properties', () => {\n        it('is reset to its former state', () => {\n          const w = new BrowserWindow({ show: false });\n          w.maximizable = false;\n          w.resizable = false;\n          w.resizable = true;\n          expect(w.maximizable).to.be.false('maximizable');\n          w.maximizable = true;\n          w.resizable = false;\n          w.resizable = true;\n          expect(w.maximizable).to.be.true('maximizable');\n        });\n      });\n\n      it('with functions', () => {\n        it('is reset to its former state', () => {\n          const w = new BrowserWindow({ show: false });\n          w.setMaximizable(false);\n          w.setResizable(false);\n          w.setResizable(true);\n          expect(w.isMaximizable()).to.be.false('isMaximizable');\n          w.setMaximizable(true);\n          w.setResizable(false);\n          w.setResizable(true);\n          expect(w.isMaximizable()).to.be.true('isMaximizable');\n        });\n      });\n    });\n\n    ifdescribe(process.platform !== 'darwin')('menuBarVisible state', () => {\n      describe('with properties', () => {\n        it('can be changed', () => {\n          const w = new BrowserWindow({ show: false });\n          expect(w.menuBarVisible).to.be.true();\n          w.menuBarVisible = false;\n          expect(w.menuBarVisible).to.be.false();\n          w.menuBarVisible = true;\n          expect(w.menuBarVisible).to.be.true();\n        });\n      });\n\n      describe('with functions', () => {\n        it('can be changed', () => {\n          const w = new BrowserWindow({ show: false });\n          expect(w.isMenuBarVisible()).to.be.true('isMenuBarVisible');\n          w.setMenuBarVisibility(false);\n          expect(w.isMenuBarVisible()).to.be.false('isMenuBarVisible');\n          w.setMenuBarVisibility(true);\n          expect(w.isMenuBarVisible()).to.be.true('isMenuBarVisible');\n        });\n      });\n    });\n\n    ifdescribe(process.platform === 'darwin')('fullscreenable state', () => {\n      it('with functions', () => {\n        it('can be set with fullscreenable constructor option', () => {\n          const w = new BrowserWindow({ show: false, fullscreenable: false });\n          expect(w.isFullScreenable()).to.be.false('isFullScreenable');\n        });\n\n        it('can be changed', () => {\n          const w = new BrowserWindow({ show: false });\n          expect(w.isFullScreenable()).to.be.true('isFullScreenable');\n          w.setFullScreenable(false);\n          expect(w.isFullScreenable()).to.be.false('isFullScreenable');\n          w.setFullScreenable(true);\n          expect(w.isFullScreenable()).to.be.true('isFullScreenable');\n        });\n      });\n    });\n\n    // fullscreen events are dispatched eagerly and twiddling things too fast can confuse poor Electron\n\n    ifdescribe(process.platform === 'darwin')('kiosk state', () => {\n      it('with properties', () => {\n        it('can be set with a constructor property', () => {\n          const w = new BrowserWindow({ kiosk: true });\n          expect(w.kiosk).to.be.true();\n        });\n\n        it('can be changed ', async () => {\n          const w = new BrowserWindow();\n          const enterFullScreen = emittedOnce(w, 'enter-full-screen');\n          w.kiosk = true;\n          expect(w.isKiosk()).to.be.true('isKiosk');\n          await enterFullScreen;\n\n          await delay();\n          const leaveFullScreen = emittedOnce(w, 'leave-full-screen');\n          w.kiosk = false;\n          expect(w.isKiosk()).to.be.false('isKiosk');\n          await leaveFullScreen;\n        });\n      });\n\n      it('with functions', () => {\n        it('can be set with a constructor property', () => {\n          const w = new BrowserWindow({ kiosk: true });\n          expect(w.isKiosk()).to.be.true();\n        });\n\n        it('can be changed ', async () => {\n          const w = new BrowserWindow();\n          const enterFullScreen = emittedOnce(w, 'enter-full-screen');\n          w.setKiosk(true);\n          expect(w.isKiosk()).to.be.true('isKiosk');\n          await enterFullScreen;\n\n          await delay();\n          const leaveFullScreen = emittedOnce(w, 'leave-full-screen');\n          w.setKiosk(false);\n          expect(w.isKiosk()).to.be.false('isKiosk');\n          await leaveFullScreen;\n        });\n      });\n    });\n\n    ifdescribe(process.platform === 'darwin')('fullscreen state with resizable set', () => {\n      it('resizable flag should be set to true and restored', async () => {\n        const w = new BrowserWindow({ resizable: false });\n        const enterFullScreen = emittedOnce(w, 'enter-full-screen');\n        w.setFullScreen(true);\n        await enterFullScreen;\n        expect(w.resizable).to.be.true('resizable');\n\n        await delay();\n        const leaveFullScreen = emittedOnce(w, 'leave-full-screen');\n        w.setFullScreen(false);\n        await leaveFullScreen;\n        expect(w.resizable).to.be.false('resizable');\n      });\n    });\n\n    ifdescribe(process.platform === 'darwin')('fullscreen state', () => {\n      it('can be changed with setFullScreen method', async () => {\n        const w = new BrowserWindow();\n        const enterFullScreen = emittedOnce(w, 'enter-full-screen');\n        w.setFullScreen(true);\n        await enterFullScreen;\n        expect(w.isFullScreen()).to.be.true('isFullScreen');\n\n        await delay();\n        const leaveFullScreen = emittedOnce(w, 'leave-full-screen');\n        w.setFullScreen(false);\n        await leaveFullScreen;\n        expect(w.isFullScreen()).to.be.false('isFullScreen');\n      });\n\n      it('does not crash when exiting simpleFullScreen (properties)', (done) => {\n        const w = new BrowserWindow();\n        w.setSimpleFullScreen(true);\n\n        setTimeout(() => {\n          w.setFullScreen(!w.isFullScreen());\n          done();\n        }, 1000);\n      });\n\n      it('does not crash when exiting simpleFullScreen (functions)', (done) => {\n        const w = new BrowserWindow();\n        w.simpleFullScreen = true;\n\n        setTimeout(() => {\n          w.setFullScreen(!w.isFullScreen());\n          done();\n        }, 1000);\n      });\n\n      it('should not be changed by setKiosk method', async () => {\n        const w = new BrowserWindow();\n        const enterFullScreen = emittedOnce(w, 'enter-full-screen');\n        w.setFullScreen(true);\n        await enterFullScreen;\n        expect(w.isFullScreen()).to.be.true('isFullScreen');\n        await delay();\n        w.setKiosk(true);\n        await delay();\n        w.setKiosk(false);\n        expect(w.isFullScreen()).to.be.true('isFullScreen');\n        const leaveFullScreen = emittedOnce(w, 'leave-full-screen');\n        w.setFullScreen(false);\n        await leaveFullScreen;\n        expect(w.isFullScreen()).to.be.false('isFullScreen');\n      });\n    });\n\n    describe('closable state', () => {\n      it('with properties', () => {\n        it('can be set with closable constructor option', () => {\n          const w = new BrowserWindow({ show: false, closable: false });\n          expect(w.closable).to.be.false('closable');\n        });\n\n        it('can be changed', () => {\n          const w = new BrowserWindow({ show: false });\n          expect(w.closable).to.be.true('closable');\n          w.closable = false;\n          expect(w.closable).to.be.false('closable');\n          w.closable = true;\n          expect(w.closable).to.be.true('closable');\n        });\n      });\n\n      it('with functions', () => {\n        it('can be set with closable constructor option', () => {\n          const w = new BrowserWindow({ show: false, closable: false });\n          expect(w.isClosable()).to.be.false('isClosable');\n        });\n\n        it('can be changed', () => {\n          const w = new BrowserWindow({ show: false });\n          expect(w.isClosable()).to.be.true('isClosable');\n          w.setClosable(false);\n          expect(w.isClosable()).to.be.false('isClosable');\n          w.setClosable(true);\n          expect(w.isClosable()).to.be.true('isClosable');\n        });\n      });\n    });\n\n    describe('hasShadow state', () => {\n      it('with properties', () => {\n        it('returns a boolean on all platforms', () => {\n          const w = new BrowserWindow({ show: false });\n          expect(w.shadow).to.be.a('boolean');\n        });\n\n        // On Windows there's no shadow by default & it can't be changed dynamically.\n        it('can be changed with hasShadow option', () => {\n          const hasShadow = process.platform !== 'darwin';\n          const w = new BrowserWindow({ show: false, hasShadow });\n          expect(w.shadow).to.equal(hasShadow);\n        });\n\n        it('can be changed with setHasShadow method', () => {\n          const w = new BrowserWindow({ show: false });\n          w.shadow = false;\n          expect(w.shadow).to.be.false('hasShadow');\n          w.shadow = true;\n          expect(w.shadow).to.be.true('hasShadow');\n          w.shadow = false;\n          expect(w.shadow).to.be.false('hasShadow');\n        });\n      });\n\n      describe('with functions', () => {\n        it('returns a boolean on all platforms', () => {\n          const w = new BrowserWindow({ show: false });\n          const hasShadow = w.hasShadow();\n          expect(hasShadow).to.be.a('boolean');\n        });\n\n        // On Windows there's no shadow by default & it can't be changed dynamically.\n        it('can be changed with hasShadow option', () => {\n          const hasShadow = process.platform !== 'darwin';\n          const w = new BrowserWindow({ show: false, hasShadow });\n          expect(w.hasShadow()).to.equal(hasShadow);\n        });\n\n        it('can be changed with setHasShadow method', () => {\n          const w = new BrowserWindow({ show: false });\n          w.setHasShadow(false);\n          expect(w.hasShadow()).to.be.false('hasShadow');\n          w.setHasShadow(true);\n          expect(w.hasShadow()).to.be.true('hasShadow');\n          w.setHasShadow(false);\n          expect(w.hasShadow()).to.be.false('hasShadow');\n        });\n      });\n    });\n  });\n\n  describe('window.getMediaSourceId()', () => {\n    afterEach(closeAllWindows);\n    it('returns valid source id', async () => {\n      const w = new BrowserWindow({ show: false });\n      const shown = emittedOnce(w, 'show');\n      w.show();\n      await shown;\n\n      // Check format 'window:1234:0'.\n      const sourceId = w.getMediaSourceId();\n      expect(sourceId).to.match(/^window:\\d+:\\d+$/);\n    });\n  });\n\n  ifdescribe(!process.env.ELECTRON_SKIP_NATIVE_MODULE_TESTS)('window.getNativeWindowHandle()', () => {\n    afterEach(closeAllWindows);\n    it('returns valid handle', () => {\n      const w = new BrowserWindow({ show: false });\n      // The module's source code is hosted at\n      // https://github.com/electron/node-is-valid-window\n      const isValidWindow = require('is-valid-window');\n      expect(isValidWindow(w.getNativeWindowHandle())).to.be.true('is valid window');\n    });\n  });\n\n  ifdescribe(process.platform === 'darwin')('previewFile', () => {\n    afterEach(closeAllWindows);\n    it('opens the path in Quick Look on macOS', () => {\n      const w = new BrowserWindow({ show: false });\n      expect(() => {\n        w.previewFile(__filename);\n        w.closeFilePreview();\n      }).to.not.throw();\n    });\n  });\n\n  describe('contextIsolation option with and without sandbox option', () => {\n    const expectedContextData = {\n      preloadContext: {\n        preloadProperty: 'number',\n        pageProperty: 'undefined',\n        typeofRequire: 'function',\n        typeofProcess: 'object',\n        typeofArrayPush: 'function',\n        typeofFunctionApply: 'function',\n        typeofPreloadExecuteJavaScriptProperty: 'undefined'\n      },\n      pageContext: {\n        preloadProperty: 'undefined',\n        pageProperty: 'string',\n        typeofRequire: 'undefined',\n        typeofProcess: 'undefined',\n        typeofArrayPush: 'number',\n        typeofFunctionApply: 'boolean',\n        typeofPreloadExecuteJavaScriptProperty: 'number',\n        typeofOpenedWindow: 'object'\n      }\n    };\n\n    afterEach(closeAllWindows);\n\n    it('separates the page context from the Electron/preload context', async () => {\n      const iw = new BrowserWindow({\n        show: false,\n        webPreferences: {\n          contextIsolation: true,\n          preload: path.join(fixtures, 'api', 'isolated-preload.js')\n        }\n      });\n      const p = emittedOnce(ipcMain, 'isolated-world');\n      iw.loadFile(path.join(fixtures, 'api', 'isolated.html'));\n      const [, data] = await p;\n      expect(data).to.deep.equal(expectedContextData);\n    });\n    it('recreates the contexts on reload', async () => {\n      const iw = new BrowserWindow({\n        show: false,\n        webPreferences: {\n          contextIsolation: true,\n          preload: path.join(fixtures, 'api', 'isolated-preload.js')\n        }\n      });\n      await iw.loadFile(path.join(fixtures, 'api', 'isolated.html'));\n      const isolatedWorld = emittedOnce(ipcMain, 'isolated-world');\n      iw.webContents.reload();\n      const [, data] = await isolatedWorld;\n      expect(data).to.deep.equal(expectedContextData);\n    });\n    it('enables context isolation on child windows', async () => {\n      const iw = new BrowserWindow({\n        show: false,\n        webPreferences: {\n          contextIsolation: true,\n          preload: path.join(fixtures, 'api', 'isolated-preload.js')\n        }\n      });\n      const browserWindowCreated = emittedOnce(app, 'browser-window-created');\n      iw.loadFile(path.join(fixtures, 'pages', 'window-open.html'));\n      const [, window] = await browserWindowCreated;\n      expect(window.webContents.getLastWebPreferences().contextIsolation).to.be.true('contextIsolation');\n    });\n    it('separates the page context from the Electron/preload context with sandbox on', async () => {\n      const ws = new BrowserWindow({\n        show: false,\n        webPreferences: {\n          sandbox: true,\n          contextIsolation: true,\n          preload: path.join(fixtures, 'api', 'isolated-preload.js')\n        }\n      });\n      const p = emittedOnce(ipcMain, 'isolated-world');\n      ws.loadFile(path.join(fixtures, 'api', 'isolated.html'));\n      const [, data] = await p;\n      expect(data).to.deep.equal(expectedContextData);\n    });\n    it('recreates the contexts on reload with sandbox on', async () => {\n      const ws = new BrowserWindow({\n        show: false,\n        webPreferences: {\n          sandbox: true,\n          contextIsolation: true,\n          preload: path.join(fixtures, 'api', 'isolated-preload.js')\n        }\n      });\n      await ws.loadFile(path.join(fixtures, 'api', 'isolated.html'));\n      const isolatedWorld = emittedOnce(ipcMain, 'isolated-world');\n      ws.webContents.reload();\n      const [, data] = await isolatedWorld;\n      expect(data).to.deep.equal(expectedContextData);\n    });\n    it('supports fetch api', async () => {\n      const fetchWindow = new BrowserWindow({\n        show: false,\n        webPreferences: {\n          contextIsolation: true,\n          preload: path.join(fixtures, 'api', 'isolated-fetch-preload.js')\n        }\n      });\n      const p = emittedOnce(ipcMain, 'isolated-fetch-error');\n      fetchWindow.loadURL('about:blank');\n      const [, error] = await p;\n      expect(error).to.equal('Failed to fetch');\n    });\n    it('doesn\\'t break ipc serialization', async () => {\n      const iw = new BrowserWindow({\n        show: false,\n        webPreferences: {\n          contextIsolation: true,\n          preload: path.join(fixtures, 'api', 'isolated-preload.js')\n        }\n      });\n      const p = emittedOnce(ipcMain, 'isolated-world');\n      iw.loadURL('about:blank');\n      iw.webContents.executeJavaScript(`\n        const opened = window.open()\n        openedLocation = opened.location.href\n        opened.close()\n        window.postMessage({openedLocation}, '*')\n      `);\n      const [, data] = await p;\n      expect(data.pageContext.openedLocation).to.equal('about:blank');\n    });\n  });\n\n  describe('window.webContents.focus()', () => {\n    afterEach(closeAllWindows);\n    it('focuses window', async () => {\n      const w1 = new BrowserWindow({ x: 100, y: 300, width: 300, height: 200 });\n      w1.loadURL('about:blank');\n      const w2 = new BrowserWindow({ x: 300, y: 300, width: 300, height: 200 });\n      w2.loadURL('about:blank');\n      w1.webContents.focus();\n      // Give focus some time to switch to w1\n      await delay();\n      expect(w1.webContents.isFocused()).to.be.true('focuses window');\n    });\n  });\n\n  ifdescribe(features.isOffscreenRenderingEnabled())('offscreen rendering', () => {\n    let w: BrowserWindow;\n    beforeEach(function () {\n      w = new BrowserWindow({\n        width: 100,\n        height: 100,\n        show: false,\n        webPreferences: {\n          backgroundThrottling: false,\n          offscreen: true\n        }\n      });\n    });\n    afterEach(closeAllWindows);\n\n    it('creates offscreen window with correct size', async () => {\n      const paint = emittedOnce(w.webContents, 'paint');\n      w.loadFile(path.join(fixtures, 'api', 'offscreen-rendering.html'));\n      const [,, data] = await paint;\n      expect(data.constructor.name).to.equal('NativeImage');\n      expect(data.isEmpty()).to.be.false('data is empty');\n      const size = data.getSize();\n      const { scaleFactor } = screen.getPrimaryDisplay();\n      expect(size.width).to.be.closeTo(100 * scaleFactor, 2);\n      expect(size.height).to.be.closeTo(100 * scaleFactor, 2);\n    });\n\n    it('does not crash after navigation', () => {\n      w.webContents.loadURL('about:blank');\n      w.loadFile(path.join(fixtures, 'api', 'offscreen-rendering.html'));\n    });\n\n    describe('window.webContents.isOffscreen()', () => {\n      it('is true for offscreen type', () => {\n        w.loadFile(path.join(fixtures, 'api', 'offscreen-rendering.html'));\n        expect(w.webContents.isOffscreen()).to.be.true('isOffscreen');\n      });\n\n      it('is false for regular window', () => {\n        const c = new BrowserWindow({ show: false });\n        expect(c.webContents.isOffscreen()).to.be.false('isOffscreen');\n        c.destroy();\n      });\n    });\n\n    describe('window.webContents.isPainting()', () => {\n      it('returns whether is currently painting', async () => {\n        const paint = emittedOnce(w.webContents, 'paint');\n        w.loadFile(path.join(fixtures, 'api', 'offscreen-rendering.html'));\n        await paint;\n        expect(w.webContents.isPainting()).to.be.true('isPainting');\n      });\n    });\n\n    describe('window.webContents.stopPainting()', () => {\n      it('stops painting', async () => {\n        const domReady = emittedOnce(w.webContents, 'dom-ready');\n        w.loadFile(path.join(fixtures, 'api', 'offscreen-rendering.html'));\n        await domReady;\n\n        w.webContents.stopPainting();\n        expect(w.webContents.isPainting()).to.be.false('isPainting');\n      });\n    });\n\n    describe('window.webContents.startPainting()', () => {\n      it('starts painting', async () => {\n        const domReady = emittedOnce(w.webContents, 'dom-ready');\n        w.loadFile(path.join(fixtures, 'api', 'offscreen-rendering.html'));\n        await domReady;\n\n        w.webContents.stopPainting();\n        w.webContents.startPainting();\n\n        await emittedOnce(w.webContents, 'paint');\n        expect(w.webContents.isPainting()).to.be.true('isPainting');\n      });\n    });\n\n    describe('frameRate APIs', () => {\n      it('has default frame rate (function)', async () => {\n        w.loadFile(path.join(fixtures, 'api', 'offscreen-rendering.html'));\n        await emittedOnce(w.webContents, 'paint');\n        expect(w.webContents.getFrameRate()).to.equal(60);\n      });\n\n      it('has default frame rate (property)', async () => {\n        w.loadFile(path.join(fixtures, 'api', 'offscreen-rendering.html'));\n        await emittedOnce(w.webContents, 'paint');\n        expect(w.webContents.frameRate).to.equal(60);\n      });\n\n      it('sets custom frame rate (function)', async () => {\n        const domReady = emittedOnce(w.webContents, 'dom-ready');\n        w.loadFile(path.join(fixtures, 'api', 'offscreen-rendering.html'));\n        await domReady;\n\n        w.webContents.setFrameRate(30);\n\n        await emittedOnce(w.webContents, 'paint');\n        expect(w.webContents.getFrameRate()).to.equal(30);\n      });\n\n      it('sets custom frame rate (property)', async () => {\n        const domReady = emittedOnce(w.webContents, 'dom-ready');\n        w.loadFile(path.join(fixtures, 'api', 'offscreen-rendering.html'));\n        await domReady;\n\n        w.webContents.frameRate = 30;\n\n        await emittedOnce(w.webContents, 'paint');\n        expect(w.webContents.frameRate).to.equal(30);\n      });\n    });\n  });\n});\n"], "fixing_code": ["// Copyright (c) 2014 GitHub, Inc.\n// Use of this source code is governed by the MIT license that can be\n// found in the LICENSE file.\n\n#include \"shell/browser/api/electron_api_web_contents.h\"\n\n#include <limits>\n#include <memory>\n#include <set>\n#include <string>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\n#include \"base/message_loop/message_loop_current.h\"\n#include \"base/no_destructor.h\"\n#include \"base/optional.h\"\n#include \"base/strings/utf_string_conversions.h\"\n#include \"base/threading/thread_restrictions.h\"\n#include \"base/threading/thread_task_runner_handle.h\"\n#include \"base/values.h\"\n#include \"chrome/browser/browser_process.h\"\n#include \"chrome/browser/ssl/security_state_tab_helper.h\"\n#include \"content/browser/frame_host/frame_tree_node.h\"             // nogncheck\n#include \"content/browser/frame_host/render_frame_host_manager.h\"   // nogncheck\n#include \"content/browser/renderer_host/render_widget_host_impl.h\"  // nogncheck\n#include \"content/browser/renderer_host/render_widget_host_view_base.h\"  // nogncheck\n#include \"content/common/widget_messages.h\"\n#include \"content/public/browser/child_process_security_policy.h\"\n#include \"content/public/browser/context_menu_params.h\"\n#include \"content/public/browser/download_request_utils.h\"\n#include \"content/public/browser/favicon_status.h\"\n#include \"content/public/browser/native_web_keyboard_event.h\"\n#include \"content/public/browser/navigation_details.h\"\n#include \"content/public/browser/navigation_entry.h\"\n#include \"content/public/browser/navigation_handle.h\"\n#include \"content/public/browser/plugin_service.h\"\n#include \"content/public/browser/render_frame_host.h\"\n#include \"content/public/browser/render_process_host.h\"\n#include \"content/public/browser/render_view_host.h\"\n#include \"content/public/browser/render_widget_host.h\"\n#include \"content/public/browser/render_widget_host_view.h\"\n#include \"content/public/browser/service_worker_context.h\"\n#include \"content/public/browser/site_instance.h\"\n#include \"content/public/browser/storage_partition.h\"\n#include \"content/public/browser/web_contents.h\"\n#include \"content/public/common/referrer_type_converters.h\"\n#include \"electron/buildflags/buildflags.h\"\n#include \"electron/shell/common/api/api.mojom.h\"\n#include \"gin/data_object_builder.h\"\n#include \"gin/handle.h\"\n#include \"gin/object_template_builder.h\"\n#include \"gin/wrappable.h\"\n#include \"mojo/public/cpp/bindings/associated_remote.h\"\n#include \"mojo/public/cpp/bindings/pending_receiver.h\"\n#include \"mojo/public/cpp/bindings/remote.h\"\n#include \"mojo/public/cpp/system/platform_handle.h\"\n#include \"ppapi/buildflags/buildflags.h\"\n#include \"shell/browser/api/electron_api_browser_window.h\"\n#include \"shell/browser/api/electron_api_debugger.h\"\n#include \"shell/browser/api/electron_api_session.h\"\n#include \"shell/browser/api/message_port.h\"\n#include \"shell/browser/browser.h\"\n#include \"shell/browser/child_web_contents_tracker.h\"\n#include \"shell/browser/electron_autofill_driver_factory.h\"\n#include \"shell/browser/electron_browser_client.h\"\n#include \"shell/browser/electron_browser_context.h\"\n#include \"shell/browser/electron_browser_main_parts.h\"\n#include \"shell/browser/electron_javascript_dialog_manager.h\"\n#include \"shell/browser/electron_navigation_throttle.h\"\n#include \"shell/browser/lib/bluetooth_chooser.h\"\n#include \"shell/browser/native_window.h\"\n#include \"shell/browser/session_preferences.h\"\n#include \"shell/browser/ui/drag_util.h\"\n#include \"shell/browser/ui/inspectable_web_contents.h\"\n#include \"shell/browser/ui/inspectable_web_contents_view.h\"\n#include \"shell/browser/web_contents_permission_helper.h\"\n#include \"shell/browser/web_contents_preferences.h\"\n#include \"shell/browser/web_contents_zoom_controller.h\"\n#include \"shell/browser/web_view_guest_delegate.h\"\n#include \"shell/common/api/electron_api_native_image.h\"\n#include \"shell/common/color_util.h\"\n#include \"shell/common/gin_converters/blink_converter.h\"\n#include \"shell/common/gin_converters/callback_converter.h\"\n#include \"shell/common/gin_converters/content_converter.h\"\n#include \"shell/common/gin_converters/file_path_converter.h\"\n#include \"shell/common/gin_converters/gfx_converter.h\"\n#include \"shell/common/gin_converters/gurl_converter.h\"\n#include \"shell/common/gin_converters/image_converter.h\"\n#include \"shell/common/gin_converters/net_converter.h\"\n#include \"shell/common/gin_converters/value_converter.h\"\n#include \"shell/common/gin_helper/dictionary.h\"\n#include \"shell/common/gin_helper/object_template_builder.h\"\n#include \"shell/common/language_util.h\"\n#include \"shell/common/mouse_util.h\"\n#include \"shell/common/node_includes.h\"\n#include \"shell/common/options_switches.h\"\n#include \"shell/common/v8_value_serializer.h\"\n#include \"third_party/blink/public/common/associated_interfaces/associated_interface_provider.h\"\n#include \"third_party/blink/public/common/input/web_input_event.h\"\n#include \"third_party/blink/public/common/messaging/transferable_message_mojom_traits.h\"\n#include \"third_party/blink/public/common/page/page_zoom.h\"\n#include \"third_party/blink/public/mojom/frame/find_in_page.mojom.h\"\n#include \"third_party/blink/public/mojom/frame/fullscreen.mojom.h\"\n#include \"third_party/blink/public/mojom/messaging/transferable_message.mojom.h\"\n#include \"third_party/blink/public/mojom/renderer_preferences.mojom.h\"\n#include \"ui/base/cursor/cursor.h\"\n#include \"ui/base/cursor/mojom/cursor_type.mojom-shared.h\"\n#include \"ui/display/screen.h\"\n#include \"ui/events/base_event_utils.h\"\n\n#if BUILDFLAG(ENABLE_OSR)\n#include \"shell/browser/osr/osr_render_widget_host_view.h\"\n#include \"shell/browser/osr/osr_web_contents_view.h\"\n#endif\n\n#if !defined(OS_MACOSX)\n#include \"ui/aura/window.h\"\n#else\n#include \"ui/base/cocoa/defaults_utils.h\"\n#endif\n\n#if defined(OS_LINUX)\n#include \"ui/views/linux_ui/linux_ui.h\"\n#endif\n\n#if defined(OS_LINUX) || defined(OS_WIN)\n#include \"ui/gfx/font_render_params.h\"\n#endif\n\n#if BUILDFLAG(ENABLE_ELECTRON_EXTENSIONS)\n#include \"extensions/browser/script_executor.h\"\n#include \"shell/browser/extensions/electron_extension_web_contents_observer.h\"\n#endif\n\nnamespace gin {\n\n#if BUILDFLAG(ENABLE_PRINTING)\ntemplate <>\nstruct Converter<printing::PrinterBasicInfo> {\n  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,\n                                   const printing::PrinterBasicInfo& val) {\n    gin_helper::Dictionary dict = gin::Dictionary::CreateEmpty(isolate);\n    dict.Set(\"name\", val.printer_name);\n    dict.Set(\"displayName\", val.display_name);\n    dict.Set(\"description\", val.printer_description);\n    dict.Set(\"status\", val.printer_status);\n    dict.Set(\"isDefault\", val.is_default ? true : false);\n    dict.Set(\"options\", val.options);\n    return dict.GetHandle();\n  }\n};\n\ntemplate <>\nstruct Converter<printing::MarginType> {\n  static bool FromV8(v8::Isolate* isolate,\n                     v8::Local<v8::Value> val,\n                     printing::MarginType* out) {\n    std::string type;\n    if (ConvertFromV8(isolate, val, &type)) {\n      if (type == \"default\") {\n        *out = printing::DEFAULT_MARGINS;\n        return true;\n      }\n      if (type == \"none\") {\n        *out = printing::NO_MARGINS;\n        return true;\n      }\n      if (type == \"printableArea\") {\n        *out = printing::PRINTABLE_AREA_MARGINS;\n        return true;\n      }\n      if (type == \"custom\") {\n        *out = printing::CUSTOM_MARGINS;\n        return true;\n      }\n    }\n    return false;\n  }\n};\n\ntemplate <>\nstruct Converter<printing::mojom::DuplexMode> {\n  static bool FromV8(v8::Isolate* isolate,\n                     v8::Local<v8::Value> val,\n                     printing::mojom::DuplexMode* out) {\n    std::string mode;\n    if (ConvertFromV8(isolate, val, &mode)) {\n      if (mode == \"simplex\") {\n        *out = printing::mojom::DuplexMode::kSimplex;\n        return true;\n      }\n      if (mode == \"longEdge\") {\n        *out = printing::mojom::DuplexMode::kLongEdge;\n        return true;\n      }\n      if (mode == \"shortEdge\") {\n        *out = printing::mojom::DuplexMode::kShortEdge;\n        return true;\n      }\n    }\n    return false;\n  }\n};\n\n#endif\n\ntemplate <>\nstruct Converter<WindowOpenDisposition> {\n  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,\n                                   WindowOpenDisposition val) {\n    std::string disposition = \"other\";\n    switch (val) {\n      case WindowOpenDisposition::CURRENT_TAB:\n        disposition = \"default\";\n        break;\n      case WindowOpenDisposition::NEW_FOREGROUND_TAB:\n        disposition = \"foreground-tab\";\n        break;\n      case WindowOpenDisposition::NEW_BACKGROUND_TAB:\n        disposition = \"background-tab\";\n        break;\n      case WindowOpenDisposition::NEW_POPUP:\n      case WindowOpenDisposition::NEW_WINDOW:\n        disposition = \"new-window\";\n        break;\n      case WindowOpenDisposition::SAVE_TO_DISK:\n        disposition = \"save-to-disk\";\n        break;\n      default:\n        break;\n    }\n    return gin::ConvertToV8(isolate, disposition);\n  }\n};\n\ntemplate <>\nstruct Converter<content::SavePageType> {\n  static bool FromV8(v8::Isolate* isolate,\n                     v8::Local<v8::Value> val,\n                     content::SavePageType* out) {\n    std::string save_type;\n    if (!ConvertFromV8(isolate, val, &save_type))\n      return false;\n    save_type = base::ToLowerASCII(save_type);\n    if (save_type == \"htmlonly\") {\n      *out = content::SAVE_PAGE_TYPE_AS_ONLY_HTML;\n    } else if (save_type == \"htmlcomplete\") {\n      *out = content::SAVE_PAGE_TYPE_AS_COMPLETE_HTML;\n    } else if (save_type == \"mhtml\") {\n      *out = content::SAVE_PAGE_TYPE_AS_MHTML;\n    } else {\n      return false;\n    }\n    return true;\n  }\n};\n\ntemplate <>\nstruct Converter<electron::api::WebContents::Type> {\n  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,\n                                   electron::api::WebContents::Type val) {\n    using Type = electron::api::WebContents::Type;\n    std::string type;\n    switch (val) {\n      case Type::BACKGROUND_PAGE:\n        type = \"backgroundPage\";\n        break;\n      case Type::BROWSER_WINDOW:\n        type = \"window\";\n        break;\n      case Type::BROWSER_VIEW:\n        type = \"browserView\";\n        break;\n      case Type::REMOTE:\n        type = \"remote\";\n        break;\n      case Type::WEB_VIEW:\n        type = \"webview\";\n        break;\n      case Type::OFF_SCREEN:\n        type = \"offscreen\";\n        break;\n      default:\n        break;\n    }\n    return gin::ConvertToV8(isolate, type);\n  }\n\n  static bool FromV8(v8::Isolate* isolate,\n                     v8::Local<v8::Value> val,\n                     electron::api::WebContents::Type* out) {\n    using Type = electron::api::WebContents::Type;\n    std::string type;\n    if (!ConvertFromV8(isolate, val, &type))\n      return false;\n    if (type == \"backgroundPage\") {\n      *out = Type::BACKGROUND_PAGE;\n    } else if (type == \"browserView\") {\n      *out = Type::BROWSER_VIEW;\n    } else if (type == \"webview\") {\n      *out = Type::WEB_VIEW;\n#if BUILDFLAG(ENABLE_OSR)\n    } else if (type == \"offscreen\") {\n      *out = Type::OFF_SCREEN;\n#endif\n    } else {\n      return false;\n    }\n    return true;\n  }\n};\n\ntemplate <>\nstruct Converter<scoped_refptr<content::DevToolsAgentHost>> {\n  static v8::Local<v8::Value> ToV8(\n      v8::Isolate* isolate,\n      const scoped_refptr<content::DevToolsAgentHost>& val) {\n    gin_helper::Dictionary dict(isolate, v8::Object::New(isolate));\n    dict.Set(\"id\", val->GetId());\n    dict.Set(\"url\", val->GetURL().spec());\n    return dict.GetHandle();\n  }\n};\n\n}  // namespace gin\n\nnamespace electron {\n\nnamespace api {\n\nnamespace {\n\n// Called when CapturePage is done.\nvoid OnCapturePageDone(gin_helper::Promise<gfx::Image> promise,\n                       const SkBitmap& bitmap) {\n  // Hack to enable transparency in captured image\n  promise.Resolve(gfx::Image::CreateFrom1xBitmap(bitmap));\n}\n\nbase::Optional<base::TimeDelta> GetCursorBlinkInterval() {\n#if defined(OS_MACOSX)\n  base::TimeDelta interval;\n  if (ui::TextInsertionCaretBlinkPeriod(&interval))\n    return interval;\n#elif defined(OS_LINUX)\n  if (auto* linux_ui = views::LinuxUI::instance())\n    return linux_ui->GetCursorBlinkInterval();\n#elif defined(OS_WIN)\n  const auto system_msec = ::GetCaretBlinkTime();\n  if (system_msec != 0) {\n    return (system_msec == INFINITE)\n               ? base::TimeDelta()\n               : base::TimeDelta::FromMilliseconds(system_msec);\n  }\n#endif\n  return base::nullopt;\n}\n\n#if BUILDFLAG(ENABLE_PRINTING)\n// This will return false if no printer with the provided device_name can be\n// found on the network. We need to check this because Chromium does not do\n// sanity checking of device_name validity and so will crash on invalid names.\nbool IsDeviceNameValid(const base::string16& device_name) {\n#if defined(OS_MACOSX)\n  base::ScopedCFTypeRef<CFStringRef> new_printer_id(\n      base::SysUTF16ToCFStringRef(device_name));\n  PMPrinter new_printer = PMPrinterCreateFromPrinterID(new_printer_id.get());\n  bool printer_exists = new_printer != nullptr;\n  PMRelease(new_printer);\n  return printer_exists;\n#elif defined(OS_WIN)\n  printing::ScopedPrinterHandle printer;\n  return printer.OpenPrinterWithName(device_name.c_str());\n#endif\n  return true;\n}\n\nbase::string16 GetDefaultPrinterAsync() {\n  base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,\n                                                base::BlockingType::MAY_BLOCK);\n\n  scoped_refptr<printing::PrintBackend> backend =\n      printing::PrintBackend::CreateInstance(\n          nullptr, g_browser_process->GetApplicationLocale());\n  std::string printer_name = backend->GetDefaultPrinterName();\n  return base::UTF8ToUTF16(printer_name);\n}\n#endif\n\n}  // namespace\n\nWebContents::WebContents(v8::Isolate* isolate,\n                         content::WebContents* web_contents)\n    : content::WebContentsObserver(web_contents),\n      type_(Type::REMOTE),\n      weak_factory_(this) {\n  auto session = Session::CreateFrom(isolate, GetBrowserContext());\n  session_.Reset(isolate, session.ToV8());\n\n  web_contents->SetUserAgentOverride(blink::UserAgentOverride::UserAgentOnly(\n                                         GetBrowserContext()->GetUserAgent()),\n                                     false);\n  Init(isolate);\n  AttachAsUserData(web_contents);\n  InitZoomController(web_contents, gin::Dictionary::CreateEmpty(isolate));\n#if BUILDFLAG(ENABLE_ELECTRON_EXTENSIONS)\n  extensions::ElectronExtensionWebContentsObserver::CreateForWebContents(\n      web_contents);\n  script_executor_.reset(new extensions::ScriptExecutor(web_contents));\n#endif\n  registry_.AddInterface(base::BindRepeating(&WebContents::BindElectronBrowser,\n                                             base::Unretained(this)));\n  receivers_.set_disconnect_handler(base::BindRepeating(\n      &WebContents::OnElectronBrowserConnectionError, base::Unretained(this)));\n}\n\nWebContents::WebContents(v8::Isolate* isolate,\n                         std::unique_ptr<content::WebContents> web_contents,\n                         Type type)\n    : content::WebContentsObserver(web_contents.get()),\n      type_(type),\n      weak_factory_(this) {\n  DCHECK(type != Type::REMOTE)\n      << \"Can't take ownership of a remote WebContents\";\n  auto session = Session::CreateFrom(isolate, GetBrowserContext());\n  session_.Reset(isolate, session.ToV8());\n  InitWithSessionAndOptions(isolate, std::move(web_contents), session,\n                            gin::Dictionary::CreateEmpty(isolate));\n}\n\nWebContents::WebContents(v8::Isolate* isolate,\n                         const gin_helper::Dictionary& options)\n    : weak_factory_(this) {\n  // Read options.\n  options.Get(\"backgroundThrottling\", &background_throttling_);\n\n  // Get type\n  options.Get(\"type\", &type_);\n\n#if BUILDFLAG(ENABLE_OSR)\n  bool b = false;\n  if (options.Get(options::kOffscreen, &b) && b)\n    type_ = Type::OFF_SCREEN;\n#endif\n\n  // Init embedder earlier\n  options.Get(\"embedder\", &embedder_);\n\n  // Whether to enable DevTools.\n  options.Get(\"devTools\", &enable_devtools_);\n\n  // BrowserViews are not attached to a window initially so they should start\n  // off as hidden. This is also important for compositor recycling. See:\n  // https://github.com/electron/electron/pull/21372\n  bool initially_shown = type_ != Type::BROWSER_VIEW;\n  options.Get(options::kShow, &initially_shown);\n\n  // Obtain the session.\n  std::string partition;\n  gin::Handle<api::Session> session;\n  if (options.Get(\"session\", &session) && !session.IsEmpty()) {\n  } else if (options.Get(\"partition\", &partition)) {\n    session = Session::FromPartition(isolate, partition);\n  } else {\n    // Use the default session if not specified.\n    session = Session::FromPartition(isolate, \"\");\n  }\n  session_.Reset(isolate, session.ToV8());\n\n  std::unique_ptr<content::WebContents> web_contents;\n  if (IsGuest()) {\n    scoped_refptr<content::SiteInstance> site_instance =\n        content::SiteInstance::CreateForURL(session->browser_context(),\n                                            GURL(\"chrome-guest://fake-host\"));\n    content::WebContents::CreateParams params(session->browser_context(),\n                                              site_instance);\n    guest_delegate_ =\n        std::make_unique<WebViewGuestDelegate>(embedder_->web_contents(), this);\n    params.guest_delegate = guest_delegate_.get();\n\n#if BUILDFLAG(ENABLE_OSR)\n    if (embedder_ && embedder_->IsOffScreen()) {\n      auto* view = new OffScreenWebContentsView(\n          false,\n          base::BindRepeating(&WebContents::OnPaint, base::Unretained(this)));\n      params.view = view;\n      params.delegate_view = view;\n\n      web_contents = content::WebContents::Create(params);\n      view->SetWebContents(web_contents.get());\n    } else {\n#endif\n      web_contents = content::WebContents::Create(params);\n#if BUILDFLAG(ENABLE_OSR)\n    }\n  } else if (IsOffScreen()) {\n    bool transparent = false;\n    options.Get(\"transparent\", &transparent);\n\n    content::WebContents::CreateParams params(session->browser_context());\n    auto* view = new OffScreenWebContentsView(\n        transparent,\n        base::BindRepeating(&WebContents::OnPaint, base::Unretained(this)));\n    params.view = view;\n    params.delegate_view = view;\n\n    web_contents = content::WebContents::Create(params);\n    view->SetWebContents(web_contents.get());\n#endif\n  } else {\n    content::WebContents::CreateParams params(session->browser_context());\n    params.initially_hidden = !initially_shown;\n    web_contents = content::WebContents::Create(params);\n  }\n\n  InitWithSessionAndOptions(isolate, std::move(web_contents), session, options);\n}\n\nvoid WebContents::InitZoomController(content::WebContents* web_contents,\n                                     const gin_helper::Dictionary& options) {\n  WebContentsZoomController::CreateForWebContents(web_contents);\n  zoom_controller_ = WebContentsZoomController::FromWebContents(web_contents);\n  double zoom_factor;\n  if (options.Get(options::kZoomFactor, &zoom_factor))\n    zoom_controller_->SetDefaultZoomFactor(zoom_factor);\n}\n\nvoid WebContents::InitWithSessionAndOptions(\n    v8::Isolate* isolate,\n    std::unique_ptr<content::WebContents> owned_web_contents,\n    gin::Handle<api::Session> session,\n    const gin_helper::Dictionary& options) {\n  Observe(owned_web_contents.get());\n  // TODO(zcbenz): Make InitWithWebContents take unique_ptr.\n  // At the time of writing we are going through a refactoring and I don't want\n  // to make other people's work harder.\n  InitWithWebContents(owned_web_contents.release(), session->browser_context(),\n                      IsGuest());\n\n  managed_web_contents()->GetView()->SetDelegate(this);\n\n  auto* prefs = web_contents()->GetMutableRendererPrefs();\n\n  // Collect preferred languages from OS and browser process. accept_languages\n  // effects HTTP header, navigator.languages, and CJK fallback font selection.\n  //\n  // Note that an application locale set to the browser process might be\n  // different with the one set to the preference list.\n  // (e.g. overridden with --lang)\n  std::string accept_languages =\n      g_browser_process->GetApplicationLocale() + \",\";\n  for (auto const& language : electron::GetPreferredLanguages()) {\n    if (language == g_browser_process->GetApplicationLocale())\n      continue;\n    accept_languages += language + \",\";\n  }\n  accept_languages.pop_back();\n  prefs->accept_languages = accept_languages;\n\n#if defined(OS_LINUX) || defined(OS_WIN)\n  // Update font settings.\n  static const base::NoDestructor<gfx::FontRenderParams> params(\n      gfx::GetFontRenderParams(gfx::FontRenderParamsQuery(), nullptr));\n  prefs->should_antialias_text = params->antialiasing;\n  prefs->use_subpixel_positioning = params->subpixel_positioning;\n  prefs->hinting = params->hinting;\n  prefs->use_autohinter = params->autohinter;\n  prefs->use_bitmaps = params->use_bitmaps;\n  prefs->subpixel_rendering = params->subpixel_rendering;\n#endif\n\n  // Honor the system's cursor blink rate settings\n  if (auto interval = GetCursorBlinkInterval())\n    prefs->caret_blink_interval = *interval;\n\n  // Save the preferences in C++.\n  new WebContentsPreferences(web_contents(), options);\n\n  WebContentsPermissionHelper::CreateForWebContents(web_contents());\n  SecurityStateTabHelper::CreateForWebContents(web_contents());\n  InitZoomController(web_contents(), options);\n#if BUILDFLAG(ENABLE_ELECTRON_EXTENSIONS)\n  extensions::ElectronExtensionWebContentsObserver::CreateForWebContents(\n      web_contents());\n  script_executor_.reset(new extensions::ScriptExecutor(web_contents()));\n#endif\n\n  registry_.AddInterface(base::BindRepeating(&WebContents::BindElectronBrowser,\n                                             base::Unretained(this)));\n  receivers_.set_disconnect_handler(base::BindRepeating(\n      &WebContents::OnElectronBrowserConnectionError, base::Unretained(this)));\n  AutofillDriverFactory::CreateForWebContents(web_contents());\n\n  web_contents()->SetUserAgentOverride(blink::UserAgentOverride::UserAgentOnly(\n                                           GetBrowserContext()->GetUserAgent()),\n                                       false);\n\n  if (IsGuest()) {\n    NativeWindow* owner_window = nullptr;\n    if (embedder_) {\n      // New WebContents's owner_window is the embedder's owner_window.\n      auto* relay =\n          NativeWindowRelay::FromWebContents(embedder_->web_contents());\n      if (relay)\n        owner_window = relay->GetNativeWindow();\n    }\n    if (owner_window)\n      SetOwnerWindow(owner_window);\n  }\n\n  Init(isolate);\n  AttachAsUserData(web_contents());\n}\n\nWebContents::~WebContents() {\n  // The destroy() is called.\n  if (managed_web_contents()) {\n    managed_web_contents()->GetView()->SetDelegate(nullptr);\n\n    RenderViewDeleted(web_contents()->GetRenderViewHost());\n\n    if (type_ == Type::BROWSER_WINDOW && owner_window()) {\n      // For BrowserWindow we should close the window and clean up everything\n      // before WebContents is destroyed.\n      for (ExtendedWebContentsObserver& observer : observers_)\n        observer.OnCloseContents();\n      // BrowserWindow destroys WebContents asynchronously, manually emit the\n      // destroyed event here.\n      WebContentsDestroyed();\n    } else if (Browser::Get()->is_shutting_down()) {\n      // Destroy WebContents directly when app is shutting down.\n      DestroyWebContents(false /* async */);\n    } else {\n      // Destroy WebContents asynchronously unless app is shutting down,\n      // because destroy() might be called inside WebContents's event handler.\n      DestroyWebContents(!IsGuest() /* async */);\n      // The WebContentsDestroyed will not be called automatically because we\n      // destroy the webContents in the next tick. So we have to manually\n      // call it here to make sure \"destroyed\" event is emitted.\n      WebContentsDestroyed();\n    }\n  }\n}\n\nvoid WebContents::DestroyWebContents(bool async) {\n  // This event is only for internal use, which is emitted when WebContents is\n  // being destroyed.\n  Emit(\"will-destroy\");\n  ResetManagedWebContents(async);\n}\n\nbool WebContents::DidAddMessageToConsole(\n    content::WebContents* source,\n    blink::mojom::ConsoleMessageLevel level,\n    const base::string16& message,\n    int32_t line_no,\n    const base::string16& source_id) {\n  return Emit(\"console-message\", static_cast<int32_t>(level), message, line_no,\n              source_id);\n}\n\nvoid WebContents::OnCreateWindow(\n    const GURL& target_url,\n    const content::Referrer& referrer,\n    const std::string& frame_name,\n    WindowOpenDisposition disposition,\n    const std::string& features,\n    const scoped_refptr<network::ResourceRequestBody>& body) {\n  Emit(\"-new-window\", target_url, frame_name, disposition, features, referrer,\n       body);\n}\n\nvoid WebContents::WebContentsCreatedWithFullParams(\n    content::WebContents* source_contents,\n    int opener_render_process_id,\n    int opener_render_frame_id,\n    const content::mojom::CreateNewWindowParams& params,\n    content::WebContents* new_contents) {\n  ChildWebContentsTracker::CreateForWebContents(new_contents);\n  auto* tracker = ChildWebContentsTracker::FromWebContents(new_contents);\n  tracker->url = params.target_url;\n  tracker->frame_name = params.frame_name;\n  tracker->referrer = params.referrer.To<content::Referrer>();\n  tracker->raw_features = params.raw_features;\n  tracker->body = params.body;\n}\n\nbool WebContents::IsWebContentsCreationOverridden(\n    content::SiteInstance* source_site_instance,\n    content::mojom::WindowContainerType window_container_type,\n    const GURL& opener_url,\n    const std::string& frame_name,\n    const GURL& target_url) {\n  if (Emit(\"-will-add-new-contents\", target_url, frame_name)) {\n    return true;\n  }\n  return false;\n}\n\ncontent::WebContents* WebContents::CreateCustomWebContents(\n    content::RenderFrameHost* opener,\n    content::SiteInstance* source_site_instance,\n    bool is_new_browsing_instance,\n    const GURL& opener_url,\n    const std::string& frame_name,\n    const GURL& target_url,\n    const std::string& partition_id,\n    content::SessionStorageNamespace* session_storage_namespace) {\n  return nullptr;\n}\n\nvoid WebContents::AddNewContents(\n    content::WebContents* source,\n    std::unique_ptr<content::WebContents> new_contents,\n    const GURL& target_url,\n    WindowOpenDisposition disposition,\n    const gfx::Rect& initial_rect,\n    bool user_gesture,\n    bool* was_blocked) {\n  auto* tracker = ChildWebContentsTracker::FromWebContents(new_contents.get());\n  DCHECK(tracker);\n\n  v8::Locker locker(isolate());\n  v8::HandleScope handle_scope(isolate());\n  auto api_web_contents =\n      CreateAndTake(isolate(), std::move(new_contents), Type::BROWSER_WINDOW);\n  if (Emit(\"-add-new-contents\", api_web_contents, disposition, user_gesture,\n           initial_rect.x(), initial_rect.y(), initial_rect.width(),\n           initial_rect.height(), tracker->url, tracker->frame_name,\n           tracker->referrer, tracker->raw_features, tracker->body)) {\n    // TODO(zcbenz): Can we make this sync?\n    api_web_contents->DestroyWebContents(true /* async */);\n  }\n}\n\ncontent::WebContents* WebContents::OpenURLFromTab(\n    content::WebContents* source,\n    const content::OpenURLParams& params) {\n  if (params.disposition != WindowOpenDisposition::CURRENT_TAB) {\n    Emit(\"-new-window\", params.url, \"\", params.disposition, \"\", params.referrer,\n         params.post_data);\n    return nullptr;\n  }\n\n  if (IsDestroyed())\n    return nullptr;\n\n  return CommonWebContentsDelegate::OpenURLFromTab(source, params);\n}\n\nvoid WebContents::BeforeUnloadFired(content::WebContents* tab,\n                                    bool proceed,\n                                    bool* proceed_to_fire_unload) {\n  if (type_ == Type::BROWSER_WINDOW || type_ == Type::OFF_SCREEN)\n    *proceed_to_fire_unload = proceed;\n  else\n    *proceed_to_fire_unload = true;\n  // Note that Chromium does not emit this for navigations.\n  Emit(\"before-unload-fired\", proceed);\n}\n\nvoid WebContents::SetContentsBounds(content::WebContents* source,\n                                    const gfx::Rect& rect) {\n  for (ExtendedWebContentsObserver& observer : observers_)\n    observer.OnSetContentBounds(rect);\n}\n\nvoid WebContents::CloseContents(content::WebContents* source) {\n  Emit(\"close\");\n\n  auto* autofill_driver_factory =\n      AutofillDriverFactory::FromWebContents(web_contents());\n  if (autofill_driver_factory) {\n    autofill_driver_factory->CloseAllPopups();\n  }\n\n  if (managed_web_contents())\n    managed_web_contents()->GetView()->SetDelegate(nullptr);\n  for (ExtendedWebContentsObserver& observer : observers_)\n    observer.OnCloseContents();\n}\n\nvoid WebContents::ActivateContents(content::WebContents* source) {\n  for (ExtendedWebContentsObserver& observer : observers_)\n    observer.OnActivateContents();\n}\n\nvoid WebContents::UpdateTargetURL(content::WebContents* source,\n                                  const GURL& url) {\n  Emit(\"update-target-url\", url);\n}\n\nbool WebContents::HandleKeyboardEvent(\n    content::WebContents* source,\n    const content::NativeWebKeyboardEvent& event) {\n  if (type_ == Type::WEB_VIEW && embedder_) {\n    // Send the unhandled keyboard events back to the embedder.\n    return embedder_->HandleKeyboardEvent(source, event);\n  } else {\n    // Go to the default keyboard handling.\n    return CommonWebContentsDelegate::HandleKeyboardEvent(source, event);\n  }\n}\n\ncontent::KeyboardEventProcessingResult WebContents::PreHandleKeyboardEvent(\n    content::WebContents* source,\n    const content::NativeWebKeyboardEvent& event) {\n  if (event.GetType() == blink::WebInputEvent::Type::kRawKeyDown ||\n      event.GetType() == blink::WebInputEvent::Type::kKeyUp) {\n    bool prevent_default = Emit(\"before-input-event\", event);\n    if (prevent_default) {\n      return content::KeyboardEventProcessingResult::HANDLED;\n    }\n  }\n\n  return content::KeyboardEventProcessingResult::NOT_HANDLED;\n}\n\nvoid WebContents::ContentsZoomChange(bool zoom_in) {\n  Emit(\"zoom-changed\", zoom_in ? \"in\" : \"out\");\n}\n\nvoid WebContents::EnterFullscreenModeForTab(\n    content::RenderFrameHost* requesting_frame,\n    const blink::mojom::FullscreenOptions& options) {\n  auto* source = content::WebContents::FromRenderFrameHost(requesting_frame);\n  auto* permission_helper =\n      WebContentsPermissionHelper::FromWebContents(source);\n  auto callback =\n      base::BindRepeating(&WebContents::OnEnterFullscreenModeForTab,\n                          base::Unretained(this), requesting_frame, options);\n  permission_helper->RequestFullscreenPermission(callback);\n}\n\nvoid WebContents::OnEnterFullscreenModeForTab(\n    content::RenderFrameHost* requesting_frame,\n    const blink::mojom::FullscreenOptions& options,\n    bool allowed) {\n  if (!allowed)\n    return;\n  CommonWebContentsDelegate::EnterFullscreenModeForTab(requesting_frame,\n                                                       options);\n  Emit(\"enter-html-full-screen\");\n}\n\nvoid WebContents::ExitFullscreenModeForTab(content::WebContents* source) {\n  CommonWebContentsDelegate::ExitFullscreenModeForTab(source);\n  Emit(\"leave-html-full-screen\");\n}\n\nvoid WebContents::RendererUnresponsive(\n    content::WebContents* source,\n    content::RenderWidgetHost* render_widget_host,\n    base::RepeatingClosure hang_monitor_restarter) {\n  Emit(\"unresponsive\");\n}\n\nvoid WebContents::RendererResponsive(\n    content::WebContents* source,\n    content::RenderWidgetHost* render_widget_host) {\n  Emit(\"responsive\");\n}\n\nbool WebContents::HandleContextMenu(content::RenderFrameHost* render_frame_host,\n                                    const content::ContextMenuParams& params) {\n  if (params.custom_context.is_pepper_menu) {\n    Emit(\"pepper-context-menu\", std::make_pair(params, web_contents()),\n         base::BindOnce(&content::WebContents::NotifyContextMenuClosed,\n                        base::Unretained(web_contents()),\n                        params.custom_context));\n  } else {\n    Emit(\"context-menu\", std::make_pair(params, web_contents()));\n  }\n\n  return true;\n}\n\nbool WebContents::OnGoToEntryOffset(int offset) {\n  GoToOffset(offset);\n  return false;\n}\n\nvoid WebContents::FindReply(content::WebContents* web_contents,\n                            int request_id,\n                            int number_of_matches,\n                            const gfx::Rect& selection_rect,\n                            int active_match_ordinal,\n                            bool final_update) {\n  if (!final_update)\n    return;\n\n  v8::Locker locker(isolate());\n  v8::HandleScope handle_scope(isolate());\n  gin_helper::Dictionary result = gin::Dictionary::CreateEmpty(isolate());\n  result.Set(\"requestId\", request_id);\n  result.Set(\"matches\", number_of_matches);\n  result.Set(\"selectionArea\", selection_rect);\n  result.Set(\"activeMatchOrdinal\", active_match_ordinal);\n  result.Set(\"finalUpdate\", final_update);  // Deprecate after 2.0\n  Emit(\"found-in-page\", result.GetHandle());\n}\n\nbool WebContents::CheckMediaAccessPermission(\n    content::RenderFrameHost* render_frame_host,\n    const GURL& security_origin,\n    blink::mojom::MediaStreamType type) {\n  auto* web_contents =\n      content::WebContents::FromRenderFrameHost(render_frame_host);\n  auto* permission_helper =\n      WebContentsPermissionHelper::FromWebContents(web_contents);\n  return permission_helper->CheckMediaAccessPermission(security_origin, type);\n}\n\nvoid WebContents::RequestMediaAccessPermission(\n    content::WebContents* web_contents,\n    const content::MediaStreamRequest& request,\n    content::MediaResponseCallback callback) {\n  auto* permission_helper =\n      WebContentsPermissionHelper::FromWebContents(web_contents);\n  permission_helper->RequestMediaAccessPermission(request, std::move(callback));\n}\n\nvoid WebContents::RequestToLockMouse(content::WebContents* web_contents,\n                                     bool user_gesture,\n                                     bool last_unlocked_by_target) {\n  auto* permission_helper =\n      WebContentsPermissionHelper::FromWebContents(web_contents);\n  permission_helper->RequestPointerLockPermission(user_gesture);\n}\n\nstd::unique_ptr<content::BluetoothChooser> WebContents::RunBluetoothChooser(\n    content::RenderFrameHost* frame,\n    const content::BluetoothChooser::EventHandler& event_handler) {\n  return std::make_unique<BluetoothChooser>(this, event_handler);\n}\n\ncontent::JavaScriptDialogManager* WebContents::GetJavaScriptDialogManager(\n    content::WebContents* source) {\n  if (!dialog_manager_)\n    dialog_manager_ = std::make_unique<ElectronJavaScriptDialogManager>(this);\n\n  return dialog_manager_.get();\n}\n\nvoid WebContents::OnAudioStateChanged(bool audible) {\n  Emit(\"-audio-state-changed\", audible);\n}\n\nvoid WebContents::BeforeUnloadFired(bool proceed,\n                                    const base::TimeTicks& proceed_time) {\n  // Do nothing, we override this method just to avoid compilation error since\n  // there are two virtual functions named BeforeUnloadFired.\n}\n\nvoid WebContents::RenderViewCreated(content::RenderViewHost* render_view_host) {\n  if (!background_throttling_)\n    render_view_host->SetSchedulerThrottling(false);\n}\n\nvoid WebContents::RenderFrameCreated(\n    content::RenderFrameHost* render_frame_host) {\n  auto* rwhv = render_frame_host->GetView();\n  if (!rwhv)\n    return;\n\n  auto* rwh_impl =\n      static_cast<content::RenderWidgetHostImpl*>(rwhv->GetRenderWidgetHost());\n  if (rwh_impl)\n    rwh_impl->disable_hidden_ = !background_throttling_;\n}\n\nvoid WebContents::RenderViewHostChanged(content::RenderViewHost* old_host,\n                                        content::RenderViewHost* new_host) {\n  currently_committed_process_id_ = new_host->GetProcess()->GetID();\n}\n\nvoid WebContents::RenderViewDeleted(content::RenderViewHost* render_view_host) {\n  // This event is necessary for tracking any states with respect to\n  // intermediate render view hosts aka speculative render view hosts. Currently\n  // used by object-registry.js to ref count remote objects.\n  Emit(\"render-view-deleted\", render_view_host->GetProcess()->GetID());\n\n  if (-1 == currently_committed_process_id_ ||\n      render_view_host->GetProcess()->GetID() ==\n          currently_committed_process_id_) {\n    currently_committed_process_id_ = -1;\n\n    // When the RVH that has been deleted is the current RVH it means that the\n    // the web contents are being closed. This is communicated by this event.\n    // Currently tracked by guest-window-manager.js to destroy the\n    // BrowserWindow.\n    Emit(\"current-render-view-deleted\",\n         render_view_host->GetProcess()->GetID());\n  }\n}\n\nvoid WebContents::RenderProcessGone(base::TerminationStatus status) {\n  Emit(\"crashed\", status == base::TERMINATION_STATUS_PROCESS_WAS_KILLED);\n  v8::HandleScope handle_scope(isolate());\n  gin_helper::Dictionary details =\n      gin_helper::Dictionary::CreateEmpty(isolate());\n  details.Set(\"reason\", status);\n  Emit(\"render-process-gone\", details);\n}\n\nvoid WebContents::PluginCrashed(const base::FilePath& plugin_path,\n                                base::ProcessId plugin_pid) {\n#if BUILDFLAG(ENABLE_PLUGINS)\n  content::WebPluginInfo info;\n  auto* plugin_service = content::PluginService::GetInstance();\n  plugin_service->GetPluginInfoByPath(plugin_path, &info);\n  Emit(\"plugin-crashed\", info.name, info.version);\n#endif  // BUILDFLAG(ENABLE_PLUIGNS)\n}\n\nvoid WebContents::MediaStartedPlaying(const MediaPlayerInfo& video_type,\n                                      const content::MediaPlayerId& id) {\n  Emit(\"media-started-playing\");\n}\n\nvoid WebContents::MediaStoppedPlaying(\n    const MediaPlayerInfo& video_type,\n    const content::MediaPlayerId& id,\n    content::WebContentsObserver::MediaStoppedReason reason) {\n  Emit(\"media-paused\");\n}\n\nvoid WebContents::DidChangeThemeColor() {\n  auto theme_color = web_contents()->GetThemeColor();\n  if (theme_color) {\n    Emit(\"did-change-theme-color\", electron::ToRGBHex(theme_color.value()));\n  } else {\n    Emit(\"did-change-theme-color\", nullptr);\n  }\n}\n\nvoid WebContents::OnInterfaceRequestFromFrame(\n    content::RenderFrameHost* render_frame_host,\n    const std::string& interface_name,\n    mojo::ScopedMessagePipeHandle* interface_pipe) {\n  registry_.TryBindInterface(interface_name, interface_pipe, render_frame_host);\n}\n\nvoid WebContents::DidAcquireFullscreen(content::RenderFrameHost* rfh) {\n  set_fullscreen_frame(rfh);\n}\n\nvoid WebContents::DOMContentLoaded(\n    content::RenderFrameHost* render_frame_host) {\n  if (!render_frame_host->GetParent())\n    Emit(\"dom-ready\");\n}\n\nvoid WebContents::DidFinishLoad(content::RenderFrameHost* render_frame_host,\n                                const GURL& validated_url) {\n  bool is_main_frame = !render_frame_host->GetParent();\n  int frame_process_id = render_frame_host->GetProcess()->GetID();\n  int frame_routing_id = render_frame_host->GetRoutingID();\n  auto weak_this = GetWeakPtr();\n  Emit(\"did-frame-finish-load\", is_main_frame, frame_process_id,\n       frame_routing_id);\n\n  // \u26a0\ufe0fWARNING!\u26a0\ufe0f\n  // Emit() triggers JS which can call destroy() on |this|. It's not safe to\n  // assume that |this| points to valid memory at this point.\n  if (is_main_frame && weak_this)\n    Emit(\"did-finish-load\");\n}\n\nvoid WebContents::DidFailLoad(content::RenderFrameHost* render_frame_host,\n                              const GURL& url,\n                              int error_code) {\n  bool is_main_frame = !render_frame_host->GetParent();\n  int frame_process_id = render_frame_host->GetProcess()->GetID();\n  int frame_routing_id = render_frame_host->GetRoutingID();\n  Emit(\"did-fail-load\", error_code, \"\", url, is_main_frame, frame_process_id,\n       frame_routing_id);\n}\n\nvoid WebContents::DidStartLoading() {\n  Emit(\"did-start-loading\");\n}\n\nvoid WebContents::DidStopLoading() {\n  Emit(\"did-stop-loading\");\n}\n\nbool WebContents::EmitNavigationEvent(\n    const std::string& event,\n    content::NavigationHandle* navigation_handle) {\n  bool is_main_frame = navigation_handle->IsInMainFrame();\n  int frame_tree_node_id = navigation_handle->GetFrameTreeNodeId();\n  content::FrameTreeNode* frame_tree_node =\n      content::FrameTreeNode::GloballyFindByID(frame_tree_node_id);\n  content::RenderFrameHostManager* render_manager =\n      frame_tree_node->render_manager();\n  content::RenderFrameHost* frame_host = nullptr;\n  if (render_manager) {\n    frame_host = render_manager->speculative_frame_host();\n    if (!frame_host)\n      frame_host = render_manager->current_frame_host();\n  }\n  int frame_process_id = -1, frame_routing_id = -1;\n  if (frame_host) {\n    frame_process_id = frame_host->GetProcess()->GetID();\n    frame_routing_id = frame_host->GetRoutingID();\n  }\n  bool is_same_document = navigation_handle->IsSameDocument();\n  auto url = navigation_handle->GetURL();\n  return Emit(event, url, is_same_document, is_main_frame, frame_process_id,\n              frame_routing_id);\n}\n\nvoid WebContents::BindElectronBrowser(\n    mojo::PendingReceiver<mojom::ElectronBrowser> receiver,\n    content::RenderFrameHost* render_frame_host) {\n  auto id = receivers_.Add(this, std::move(receiver), render_frame_host);\n  frame_to_receivers_map_[render_frame_host].push_back(id);\n}\n\nvoid WebContents::OnElectronBrowserConnectionError() {\n  auto receiver_id = receivers_.current_receiver();\n  auto* frame_host = receivers_.current_context();\n  base::Erase(frame_to_receivers_map_[frame_host], receiver_id);\n}\n\nvoid WebContents::Message(bool internal,\n                          const std::string& channel,\n                          blink::CloneableMessage arguments) {\n  TRACE_EVENT1(\"electron\", \"WebContents::Message\", \"channel\", channel);\n  // webContents.emit('-ipc-message', new Event(), internal, channel,\n  // arguments);\n  EmitWithSender(\"-ipc-message\", receivers_.current_context(), InvokeCallback(),\n                 internal, channel, std::move(arguments));\n}\n\nvoid WebContents::Invoke(bool internal,\n                         const std::string& channel,\n                         blink::CloneableMessage arguments,\n                         InvokeCallback callback) {\n  TRACE_EVENT1(\"electron\", \"WebContents::Invoke\", \"channel\", channel);\n  // webContents.emit('-ipc-invoke', new Event(), internal, channel, arguments);\n  EmitWithSender(\"-ipc-invoke\", receivers_.current_context(),\n                 std::move(callback), internal, channel, std::move(arguments));\n}\n\nvoid WebContents::ReceivePostMessage(const std::string& channel,\n                                     blink::TransferableMessage message) {\n  v8::HandleScope handle_scope(isolate());\n  auto wrapped_ports =\n      MessagePort::EntanglePorts(isolate(), std::move(message.ports));\n  v8::Local<v8::Value> message_value =\n      electron::DeserializeV8Value(isolate(), message);\n  EmitWithSender(\"-ipc-ports\", receivers_.current_context(), InvokeCallback(),\n                 false, channel, message_value, std::move(wrapped_ports));\n}\n\nvoid WebContents::PostMessage(const std::string& channel,\n                              v8::Local<v8::Value> message_value,\n                              base::Optional<v8::Local<v8::Value>> transfer) {\n  blink::TransferableMessage transferable_message;\n  if (!electron::SerializeV8Value(isolate(), message_value,\n                                  &transferable_message)) {\n    // SerializeV8Value sets an exception.\n    return;\n  }\n\n  std::vector<gin::Handle<MessagePort>> wrapped_ports;\n  if (transfer) {\n    if (!gin::ConvertFromV8(isolate(), *transfer, &wrapped_ports)) {\n      isolate()->ThrowException(v8::Exception::Error(\n          gin::StringToV8(isolate(), \"Invalid value for transfer\")));\n      return;\n    }\n  }\n\n  bool threw_exception = false;\n  transferable_message.ports =\n      MessagePort::DisentanglePorts(isolate(), wrapped_ports, &threw_exception);\n  if (threw_exception)\n    return;\n\n  content::RenderFrameHost* frame_host = web_contents()->GetMainFrame();\n  mojo::AssociatedRemote<mojom::ElectronRenderer> electron_renderer;\n  frame_host->GetRemoteAssociatedInterfaces()->GetInterface(&electron_renderer);\n  electron_renderer->ReceivePostMessage(channel,\n                                        std::move(transferable_message));\n}\n\nvoid WebContents::MessageSync(bool internal,\n                              const std::string& channel,\n                              blink::CloneableMessage arguments,\n                              MessageSyncCallback callback) {\n  TRACE_EVENT1(\"electron\", \"WebContents::MessageSync\", \"channel\", channel);\n  // webContents.emit('-ipc-message-sync', new Event(sender, message), internal,\n  // channel, arguments);\n  EmitWithSender(\"-ipc-message-sync\", receivers_.current_context(),\n                 std::move(callback), internal, channel, std::move(arguments));\n}\n\nvoid WebContents::MessageTo(bool internal,\n                            bool send_to_all,\n                            int32_t web_contents_id,\n                            const std::string& channel,\n                            blink::CloneableMessage arguments) {\n  TRACE_EVENT1(\"electron\", \"WebContents::MessageTo\", \"channel\", channel);\n  auto* web_contents = gin_helper::TrackableObject<WebContents>::FromWeakMapID(\n      isolate(), web_contents_id);\n\n  if (web_contents) {\n    web_contents->SendIPCMessageWithSender(internal, send_to_all, channel,\n                                           std::move(arguments), ID());\n  }\n}\n\nvoid WebContents::MessageHost(const std::string& channel,\n                              blink::CloneableMessage arguments) {\n  TRACE_EVENT1(\"electron\", \"WebContents::MessageHost\", \"channel\", channel);\n  // webContents.emit('ipc-message-host', new Event(), channel, args);\n  EmitWithSender(\"ipc-message-host\", receivers_.current_context(),\n                 InvokeCallback(), channel, std::move(arguments));\n}\n\n#if BUILDFLAG(ENABLE_REMOTE_MODULE)\nvoid WebContents::DereferenceRemoteJSObject(const std::string& context_id,\n                                            int object_id,\n                                            int ref_count) {\n  base::ListValue args;\n  args.Append(context_id);\n  args.Append(object_id);\n  args.Append(ref_count);\n  EmitWithSender(\"-ipc-message\", receivers_.current_context(), InvokeCallback(),\n                 /* internal */ true, \"ELECTRON_BROWSER_DEREFERENCE\",\n                 std::move(args));\n}\n#endif\n\nvoid WebContents::UpdateDraggableRegions(\n    std::vector<mojom::DraggableRegionPtr> regions) {\n  for (ExtendedWebContentsObserver& observer : observers_)\n    observer.OnDraggableRegionsUpdated(regions);\n}\n\nvoid WebContents::RenderFrameDeleted(\n    content::RenderFrameHost* render_frame_host) {\n  // A RenderFrameHost can be destroyed before the related Mojo binding is\n  // closed, which can result in Mojo calls being sent for RenderFrameHosts\n  // that no longer exist. To prevent this from happening, when a\n  // RenderFrameHost goes away, we close all the bindings related to that\n  // frame.\n  auto it = frame_to_receivers_map_.find(render_frame_host);\n  if (it == frame_to_receivers_map_.end())\n    return;\n  for (auto id : it->second)\n    receivers_.Remove(id);\n  frame_to_receivers_map_.erase(it);\n}\n\nvoid WebContents::DidStartNavigation(\n    content::NavigationHandle* navigation_handle) {\n  EmitNavigationEvent(\"did-start-navigation\", navigation_handle);\n}\n\nvoid WebContents::DidRedirectNavigation(\n    content::NavigationHandle* navigation_handle) {\n  EmitNavigationEvent(\"did-redirect-navigation\", navigation_handle);\n}\n\nvoid WebContents::DidFinishNavigation(\n    content::NavigationHandle* navigation_handle) {\n  if (!navigation_handle->HasCommitted())\n    return;\n  bool is_main_frame = navigation_handle->IsInMainFrame();\n  content::RenderFrameHost* frame_host =\n      navigation_handle->GetRenderFrameHost();\n  int frame_process_id = -1, frame_routing_id = -1;\n  if (frame_host) {\n    frame_process_id = frame_host->GetProcess()->GetID();\n    frame_routing_id = frame_host->GetRoutingID();\n  }\n  if (!navigation_handle->IsErrorPage()) {\n    // FIXME: All the Emit() calls below could potentially result in |this|\n    // being destroyed (by JS listening for the event and calling\n    // webContents.destroy()).\n    auto url = navigation_handle->GetURL();\n    bool is_same_document = navigation_handle->IsSameDocument();\n    if (is_same_document) {\n      Emit(\"did-navigate-in-page\", url, is_main_frame, frame_process_id,\n           frame_routing_id);\n    } else {\n      const net::HttpResponseHeaders* http_response =\n          navigation_handle->GetResponseHeaders();\n      std::string http_status_text;\n      int http_response_code = -1;\n      if (http_response) {\n        http_status_text = http_response->GetStatusText();\n        http_response_code = http_response->response_code();\n      }\n      Emit(\"did-frame-navigate\", url, http_response_code, http_status_text,\n           is_main_frame, frame_process_id, frame_routing_id);\n      if (is_main_frame) {\n        Emit(\"did-navigate\", url, http_response_code, http_status_text);\n      }\n    }\n    if (IsGuest())\n      Emit(\"load-commit\", url, is_main_frame);\n  } else {\n    auto url = navigation_handle->GetURL();\n    int code = navigation_handle->GetNetErrorCode();\n    auto description = net::ErrorToShortString(code);\n    Emit(\"did-fail-provisional-load\", code, description, url, is_main_frame,\n         frame_process_id, frame_routing_id);\n\n    // Do not emit \"did-fail-load\" for canceled requests.\n    if (code != net::ERR_ABORTED)\n      Emit(\"did-fail-load\", code, description, url, is_main_frame,\n           frame_process_id, frame_routing_id);\n  }\n}\n\nvoid WebContents::TitleWasSet(content::NavigationEntry* entry) {\n  base::string16 final_title;\n  bool explicit_set = true;\n  if (entry) {\n    auto title = entry->GetTitle();\n    auto url = entry->GetURL();\n    if (url.SchemeIsFile() && title.empty()) {\n      final_title = base::UTF8ToUTF16(url.ExtractFileName());\n      explicit_set = false;\n    } else {\n      final_title = title;\n    }\n  }\n  for (ExtendedWebContentsObserver& observer : observers_)\n    observer.OnPageTitleUpdated(final_title, explicit_set);\n  Emit(\"page-title-updated\", final_title, explicit_set);\n}\n\nvoid WebContents::DidUpdateFaviconURL(\n    content::RenderFrameHost* render_frame_host,\n    const std::vector<blink::mojom::FaviconURLPtr>& urls) {\n  std::set<GURL> unique_urls;\n  for (const auto& iter : urls) {\n    if (iter->icon_type != blink::mojom::FaviconIconType::kFavicon)\n      continue;\n    const GURL& url = iter->icon_url;\n    if (url.is_valid())\n      unique_urls.insert(url);\n  }\n  Emit(\"page-favicon-updated\", unique_urls);\n}\n\nvoid WebContents::DevToolsReloadPage() {\n  Emit(\"devtools-reload-page\");\n}\n\nvoid WebContents::DevToolsFocused() {\n  Emit(\"devtools-focused\");\n}\n\nvoid WebContents::DevToolsOpened() {\n  v8::Locker locker(isolate());\n  v8::HandleScope handle_scope(isolate());\n  auto handle =\n      FromOrCreate(isolate(), managed_web_contents()->GetDevToolsWebContents());\n  devtools_web_contents_.Reset(isolate(), handle.ToV8());\n\n  // Set inspected tabID.\n  base::Value tab_id(ID());\n  managed_web_contents()->CallClientFunction(\"DevToolsAPI.setInspectedTabId\",\n                                             &tab_id, nullptr, nullptr);\n\n  // Inherit owner window in devtools when it doesn't have one.\n  auto* devtools = managed_web_contents()->GetDevToolsWebContents();\n  bool has_window = devtools->GetUserData(NativeWindowRelay::UserDataKey());\n  if (owner_window() && !has_window)\n    handle->SetOwnerWindow(devtools, owner_window());\n\n  Emit(\"devtools-opened\");\n}\n\nvoid WebContents::DevToolsClosed() {\n  v8::Locker locker(isolate());\n  v8::HandleScope handle_scope(isolate());\n  devtools_web_contents_.Reset();\n\n  Emit(\"devtools-closed\");\n}\n\nbool WebContents::OnMessageReceived(const IPC::Message& message) {\n  bool handled = true;\n  IPC_BEGIN_MESSAGE_MAP(WebContents, message)\n    IPC_MESSAGE_UNHANDLED(handled = false)\n  IPC_END_MESSAGE_MAP()\n\n  return handled;\n}\n\n// There are three ways of destroying a webContents:\n// 1. call webContents.destroy();\n// 2. garbage collection;\n// 3. user closes the window of webContents;\n// 4. the embedder detaches the frame.\n// For webview only #4 will happen, for BrowserWindow both #1 and #3 may\n// happen. The #2 should never happen for webContents, because webview is\n// managed by GuestViewManager, and BrowserWindow's webContents is managed\n// by api::BrowserWindow.\n// For #1, the destructor will do the cleanup work and we only need to make\n// sure \"destroyed\" event is emitted. For #3, the content::WebContents will\n// be destroyed on close, and WebContentsDestroyed would be called for it, so\n// we need to make sure the api::WebContents is also deleted.\n// For #4, the WebContents will be destroyed by embedder.\nvoid WebContents::WebContentsDestroyed() {\n  // Give chance for guest delegate to cleanup its observers\n  // since the native class is only destroyed in the next tick.\n  if (guest_delegate_)\n    guest_delegate_->WillDestroy();\n\n  // Cleanup relationships with other parts.\n  RemoveFromWeakMap();\n\n  // We can not call Destroy here because we need to call Emit first, but we\n  // also do not want any method to be used, so just mark as destroyed here.\n  MarkDestroyed();\n\n  Emit(\"destroyed\");\n\n  // For guest view based on OOPIF, the WebContents is released by the embedder\n  // frame, and we need to clear the reference to the memory.\n  if (IsGuest() && managed_web_contents()) {\n    managed_web_contents()->ReleaseWebContents();\n    ResetManagedWebContents(false);\n  }\n\n  // Destroy the native class in next tick.\n  base::ThreadTaskRunnerHandle::Get()->PostTask(FROM_HERE, GetDestroyClosure());\n}\n\nvoid WebContents::NavigationEntryCommitted(\n    const content::LoadCommittedDetails& details) {\n  Emit(\"navigation-entry-committed\", details.entry->GetURL(),\n       details.is_same_document, details.did_replace_entry);\n}\n\nbool WebContents::GetBackgroundThrottling() const {\n  return background_throttling_;\n}\n\nvoid WebContents::SetBackgroundThrottling(bool allowed) {\n  background_throttling_ = allowed;\n\n  auto* rfh = web_contents()->GetMainFrame();\n  if (!rfh)\n    return;\n\n  auto* rwhv = rfh->GetView();\n  if (!rwhv)\n    return;\n\n  auto* rwh_impl =\n      static_cast<content::RenderWidgetHostImpl*>(rwhv->GetRenderWidgetHost());\n  if (!rwh_impl)\n    return;\n\n  rwh_impl->disable_hidden_ = !background_throttling_;\n  web_contents()->GetRenderViewHost()->SetSchedulerThrottling(allowed);\n\n  if (rwh_impl->is_hidden()) {\n    rwh_impl->WasShown(base::nullopt);\n  }\n}\n\nint WebContents::GetProcessID() const {\n  return web_contents()->GetMainFrame()->GetProcess()->GetID();\n}\n\nbase::ProcessId WebContents::GetOSProcessID() const {\n  base::ProcessHandle process_handle =\n      web_contents()->GetMainFrame()->GetProcess()->GetProcess().Handle();\n  return base::GetProcId(process_handle);\n}\n\nbase::ProcessId WebContents::GetOSProcessIdForFrame(\n    const std::string& name,\n    const std::string& document_url) const {\n  for (auto* frame : web_contents()->GetAllFrames()) {\n    if (frame->GetFrameName() == name &&\n        frame->GetLastCommittedURL().spec() == document_url) {\n      return base::GetProcId(frame->GetProcess()->GetProcess().Handle());\n    }\n  }\n  return base::kNullProcessId;\n}\n\nWebContents::Type WebContents::GetType() const {\n  return type_;\n}\n\nbool WebContents::Equal(const WebContents* web_contents) const {\n  return ID() == web_contents->ID();\n}\n\nvoid WebContents::LoadURL(const GURL& url,\n                          const gin_helper::Dictionary& options) {\n  if (!url.is_valid() || url.spec().size() > url::kMaxURLChars) {\n    Emit(\"did-fail-load\", static_cast<int>(net::ERR_INVALID_URL),\n         net::ErrorToShortString(net::ERR_INVALID_URL),\n         url.possibly_invalid_spec(), true);\n    return;\n  }\n\n  content::NavigationController::LoadURLParams params(url);\n\n  if (!options.Get(\"httpReferrer\", &params.referrer)) {\n    GURL http_referrer;\n    if (options.Get(\"httpReferrer\", &http_referrer))\n      params.referrer =\n          content::Referrer(http_referrer.GetAsReferrer(),\n                            network::mojom::ReferrerPolicy::kDefault);\n  }\n\n  std::string user_agent;\n  if (options.Get(\"userAgent\", &user_agent))\n    web_contents()->SetUserAgentOverride(\n        blink::UserAgentOverride::UserAgentOnly(user_agent), false);\n\n  std::string extra_headers;\n  if (options.Get(\"extraHeaders\", &extra_headers))\n    params.extra_headers = extra_headers;\n\n  scoped_refptr<network::ResourceRequestBody> body;\n  if (options.Get(\"postData\", &body)) {\n    params.post_data = body;\n    params.load_type = content::NavigationController::LOAD_TYPE_HTTP_POST;\n  }\n\n  GURL base_url_for_data_url;\n  if (options.Get(\"baseURLForDataURL\", &base_url_for_data_url)) {\n    params.base_url_for_data_url = base_url_for_data_url;\n    params.load_type = content::NavigationController::LOAD_TYPE_DATA;\n  }\n\n  bool reload_ignoring_cache = false;\n  if (options.Get(\"reloadIgnoringCache\", &reload_ignoring_cache) &&\n      reload_ignoring_cache) {\n    params.reload_type = content::ReloadType::BYPASSING_CACHE;\n  }\n\n  // Calling LoadURLWithParams() can trigger JS which destroys |this|.\n  auto weak_this = GetWeakPtr();\n\n  // Required to make beforeunload handler work.\n  NotifyUserActivation();\n\n  params.transition_type = ui::PAGE_TRANSITION_TYPED;\n  params.should_clear_history_list = true;\n  params.override_user_agent = content::NavigationController::UA_OVERRIDE_TRUE;\n  // Discord non-committed entries to ensure that we don't re-use a pending\n  // entry\n  web_contents()->GetController().DiscardNonCommittedEntries();\n  web_contents()->GetController().LoadURLWithParams(params);\n\n  // \u26a0\ufe0fWARNING!\u26a0\ufe0f\n  // LoadURLWithParams() triggers JS events which can call destroy() on |this|.\n  // It's not safe to assume that |this| points to valid memory at this point.\n  if (!weak_this)\n    return;\n\n  // Set the background color of RenderWidgetHostView.\n  // We have to call it right after LoadURL because the RenderViewHost is only\n  // created after loading a page.\n  auto* const view = weak_this->web_contents()->GetRenderWidgetHostView();\n  if (view) {\n    auto* web_preferences = WebContentsPreferences::From(web_contents());\n    std::string color_name;\n    if (web_preferences->GetPreference(options::kBackgroundColor,\n                                       &color_name)) {\n      view->SetBackgroundColor(ParseHexColor(color_name));\n    } else {\n      view->SetBackgroundColor(SK_ColorTRANSPARENT);\n    }\n  }\n}\n\nvoid WebContents::DownloadURL(const GURL& url) {\n  auto* browser_context = web_contents()->GetBrowserContext();\n  auto* download_manager =\n      content::BrowserContext::GetDownloadManager(browser_context);\n  std::unique_ptr<download::DownloadUrlParameters> download_params(\n      content::DownloadRequestUtils::CreateDownloadForWebContentsMainFrame(\n          web_contents(), url, MISSING_TRAFFIC_ANNOTATION));\n  download_manager->DownloadUrl(std::move(download_params));\n}\n\nGURL WebContents::GetURL() const {\n  return web_contents()->GetURL();\n}\n\nbase::string16 WebContents::GetTitle() const {\n  return web_contents()->GetTitle();\n}\n\nbool WebContents::IsLoading() const {\n  return web_contents()->IsLoading();\n}\n\nbool WebContents::IsLoadingMainFrame() const {\n  return web_contents()->IsLoadingToDifferentDocument();\n}\n\nbool WebContents::IsWaitingForResponse() const {\n  return web_contents()->IsWaitingForResponse();\n}\n\nvoid WebContents::Stop() {\n  web_contents()->Stop();\n}\n\nvoid WebContents::GoBack() {\n  if (!ElectronBrowserClient::Get()->CanUseCustomSiteInstance()) {\n    electron::ElectronBrowserClient::SuppressRendererProcessRestartForOnce();\n  }\n  web_contents()->GetController().GoBack();\n}\n\nvoid WebContents::GoForward() {\n  if (!ElectronBrowserClient::Get()->CanUseCustomSiteInstance()) {\n    electron::ElectronBrowserClient::SuppressRendererProcessRestartForOnce();\n  }\n  web_contents()->GetController().GoForward();\n}\n\nvoid WebContents::GoToOffset(int offset) {\n  if (!ElectronBrowserClient::Get()->CanUseCustomSiteInstance()) {\n    electron::ElectronBrowserClient::SuppressRendererProcessRestartForOnce();\n  }\n  web_contents()->GetController().GoToOffset(offset);\n}\n\nconst std::string WebContents::GetWebRTCIPHandlingPolicy() const {\n  return web_contents()->GetMutableRendererPrefs()->webrtc_ip_handling_policy;\n}\n\nvoid WebContents::SetWebRTCIPHandlingPolicy(\n    const std::string& webrtc_ip_handling_policy) {\n  if (GetWebRTCIPHandlingPolicy() == webrtc_ip_handling_policy)\n    return;\n  web_contents()->GetMutableRendererPrefs()->webrtc_ip_handling_policy =\n      webrtc_ip_handling_policy;\n\n  web_contents()->SyncRendererPrefs();\n}\n\nbool WebContents::IsCrashed() const {\n  return web_contents()->IsCrashed();\n}\n\nvoid WebContents::SetUserAgent(const std::string& user_agent,\n                               gin_helper::Arguments* args) {\n  web_contents()->SetUserAgentOverride(\n      blink::UserAgentOverride::UserAgentOnly(user_agent), false);\n}\n\nstd::string WebContents::GetUserAgent() {\n  return web_contents()->GetUserAgentOverride().ua_string_override;\n}\n\nv8::Local<v8::Promise> WebContents::SavePage(\n    const base::FilePath& full_file_path,\n    const content::SavePageType& save_type) {\n  gin_helper::Promise<void> promise(isolate());\n  v8::Local<v8::Promise> handle = promise.GetHandle();\n\n  auto* handler = new SavePageHandler(web_contents(), std::move(promise));\n  handler->Handle(full_file_path, save_type);\n\n  return handle;\n}\n\nvoid WebContents::OpenDevTools(gin_helper::Arguments* args) {\n  if (type_ == Type::REMOTE)\n    return;\n\n  if (!enable_devtools_)\n    return;\n\n  std::string state;\n  if (type_ == Type::WEB_VIEW || !owner_window()) {\n    state = \"detach\";\n  }\n  bool activate = true;\n  if (args && args->Length() == 1) {\n    gin_helper::Dictionary options;\n    if (args->GetNext(&options)) {\n      options.Get(\"mode\", &state);\n      options.Get(\"activate\", &activate);\n    }\n  }\n  managed_web_contents()->SetDockState(state);\n  managed_web_contents()->ShowDevTools(activate);\n}\n\nvoid WebContents::CloseDevTools() {\n  if (type_ == Type::REMOTE)\n    return;\n\n  managed_web_contents()->CloseDevTools();\n}\n\nbool WebContents::IsDevToolsOpened() {\n  if (type_ == Type::REMOTE)\n    return false;\n\n  return managed_web_contents()->IsDevToolsViewShowing();\n}\n\nbool WebContents::IsDevToolsFocused() {\n  if (type_ == Type::REMOTE)\n    return false;\n\n  return managed_web_contents()->GetView()->IsDevToolsViewFocused();\n}\n\nvoid WebContents::EnableDeviceEmulation(\n    const blink::WebDeviceEmulationParams& params) {\n  if (type_ == Type::REMOTE)\n    return;\n\n  auto* frame_host = web_contents()->GetMainFrame();\n  if (frame_host) {\n    auto* widget_host =\n        frame_host ? frame_host->GetView()->GetRenderWidgetHost() : nullptr;\n    if (!widget_host)\n      return;\n    widget_host->Send(new WidgetMsg_EnableDeviceEmulation(\n        widget_host->GetRoutingID(), params));\n  }\n}\n\nvoid WebContents::DisableDeviceEmulation() {\n  if (type_ == Type::REMOTE)\n    return;\n\n  auto* frame_host = web_contents()->GetMainFrame();\n  if (frame_host) {\n    auto* widget_host =\n        frame_host ? frame_host->GetView()->GetRenderWidgetHost() : nullptr;\n    if (!widget_host)\n      return;\n    widget_host->Send(\n        new WidgetMsg_DisableDeviceEmulation(widget_host->GetRoutingID()));\n  }\n}\n\nvoid WebContents::ToggleDevTools() {\n  if (IsDevToolsOpened())\n    CloseDevTools();\n  else\n    OpenDevTools(nullptr);\n}\n\nvoid WebContents::InspectElement(int x, int y) {\n  if (type_ == Type::REMOTE)\n    return;\n\n  if (!enable_devtools_)\n    return;\n\n  if (!managed_web_contents()->GetDevToolsWebContents())\n    OpenDevTools(nullptr);\n  managed_web_contents()->InspectElement(x, y);\n}\n\nvoid WebContents::InspectSharedWorkerById(const std::string& workerId) {\n  if (type_ == Type::REMOTE)\n    return;\n\n  if (!enable_devtools_)\n    return;\n\n  for (const auto& agent_host : content::DevToolsAgentHost::GetOrCreateAll()) {\n    if (agent_host->GetType() ==\n        content::DevToolsAgentHost::kTypeSharedWorker) {\n      if (agent_host->GetId() == workerId) {\n        OpenDevTools(nullptr);\n        managed_web_contents()->AttachTo(agent_host);\n        break;\n      }\n    }\n  }\n}\n\nstd::vector<scoped_refptr<content::DevToolsAgentHost>>\nWebContents::GetAllSharedWorkers() {\n  std::vector<scoped_refptr<content::DevToolsAgentHost>> shared_workers;\n\n  if (type_ == Type::REMOTE)\n    return shared_workers;\n\n  if (!enable_devtools_)\n    return shared_workers;\n\n  for (const auto& agent_host : content::DevToolsAgentHost::GetOrCreateAll()) {\n    if (agent_host->GetType() ==\n        content::DevToolsAgentHost::kTypeSharedWorker) {\n      shared_workers.push_back(agent_host);\n    }\n  }\n  return shared_workers;\n}\n\nvoid WebContents::InspectSharedWorker() {\n  if (type_ == Type::REMOTE)\n    return;\n\n  if (!enable_devtools_)\n    return;\n\n  for (const auto& agent_host : content::DevToolsAgentHost::GetOrCreateAll()) {\n    if (agent_host->GetType() ==\n        content::DevToolsAgentHost::kTypeSharedWorker) {\n      OpenDevTools(nullptr);\n      managed_web_contents()->AttachTo(agent_host);\n      break;\n    }\n  }\n}\n\nvoid WebContents::InspectServiceWorker() {\n  if (type_ == Type::REMOTE)\n    return;\n\n  if (!enable_devtools_)\n    return;\n\n  for (const auto& agent_host : content::DevToolsAgentHost::GetOrCreateAll()) {\n    if (agent_host->GetType() ==\n        content::DevToolsAgentHost::kTypeServiceWorker) {\n      OpenDevTools(nullptr);\n      managed_web_contents()->AttachTo(agent_host);\n      break;\n    }\n  }\n}\n\nvoid WebContents::SetIgnoreMenuShortcuts(bool ignore) {\n  auto* web_preferences = WebContentsPreferences::From(web_contents());\n  DCHECK(web_preferences);\n  web_preferences->preference()->SetKey(\"ignoreMenuShortcuts\",\n                                        base::Value(ignore));\n}\n\nvoid WebContents::SetAudioMuted(bool muted) {\n  web_contents()->SetAudioMuted(muted);\n}\n\nbool WebContents::IsAudioMuted() {\n  return web_contents()->IsAudioMuted();\n}\n\nbool WebContents::IsCurrentlyAudible() {\n  return web_contents()->IsCurrentlyAudible();\n}\n\n#if BUILDFLAG(ENABLE_PRINTING)\nvoid WebContents::OnGetDefaultPrinter(\n    base::Value print_settings,\n    printing::CompletionCallback print_callback,\n    base::string16 device_name,\n    bool silent,\n    base::string16 default_printer) {\n  // The content::WebContents might be already deleted at this point, and the\n  // PrintViewManagerBasic class does not do null check.\n  if (!web_contents()) {\n    if (print_callback)\n      std::move(print_callback).Run(false, \"failed\");\n    return;\n  }\n\n  base::string16 printer_name =\n      device_name.empty() ? default_printer : device_name;\n\n  // If there are no valid printers available on the network, we bail.\n  if (printer_name.empty() || !IsDeviceNameValid(printer_name)) {\n    if (print_callback)\n      std::move(print_callback).Run(false, \"no valid printers available\");\n    return;\n  }\n\n  print_settings.SetStringKey(printing::kSettingDeviceName, printer_name);\n\n  auto* print_view_manager =\n      printing::PrintViewManagerBasic::FromWebContents(web_contents());\n  auto* focused_frame = web_contents()->GetFocusedFrame();\n  auto* rfh = focused_frame && focused_frame->HasSelection()\n                  ? focused_frame\n                  : web_contents()->GetMainFrame();\n\n  print_view_manager->PrintNow(rfh, silent, std::move(print_settings),\n                               std::move(print_callback));\n}\n\nvoid WebContents::Print(gin_helper::Arguments* args) {\n  gin_helper::Dictionary options =\n      gin::Dictionary::CreateEmpty(args->isolate());\n  base::Value settings(base::Value::Type::DICTIONARY);\n\n  if (args->Length() >= 1 && !args->GetNext(&options)) {\n    args->ThrowError(\"webContents.print(): Invalid print settings specified.\");\n    return;\n  }\n\n  printing::CompletionCallback callback;\n  if (args->Length() == 2 && !args->GetNext(&callback)) {\n    args->ThrowError(\n        \"webContents.print(): Invalid optional callback provided.\");\n    return;\n  }\n\n  // Set optional silent printing\n  bool silent = false;\n  options.Get(\"silent\", &silent);\n\n  bool print_background = false;\n  options.Get(\"printBackground\", &print_background);\n  settings.SetBoolKey(printing::kSettingShouldPrintBackgrounds,\n                      print_background);\n\n  // Set custom margin settings\n  gin_helper::Dictionary margins =\n      gin::Dictionary::CreateEmpty(args->isolate());\n  if (options.Get(\"margins\", &margins)) {\n    printing::MarginType margin_type = printing::DEFAULT_MARGINS;\n    margins.Get(\"marginType\", &margin_type);\n    settings.SetIntKey(printing::kSettingMarginsType, margin_type);\n\n    if (margin_type == printing::CUSTOM_MARGINS) {\n      base::Value custom_margins(base::Value::Type::DICTIONARY);\n      int top = 0;\n      margins.Get(\"top\", &top);\n      custom_margins.SetIntKey(printing::kSettingMarginTop, top);\n      int bottom = 0;\n      margins.Get(\"bottom\", &bottom);\n      custom_margins.SetIntKey(printing::kSettingMarginBottom, bottom);\n      int left = 0;\n      margins.Get(\"left\", &left);\n      custom_margins.SetIntKey(printing::kSettingMarginLeft, left);\n      int right = 0;\n      margins.Get(\"right\", &right);\n      custom_margins.SetIntKey(printing::kSettingMarginRight, right);\n      settings.SetPath(printing::kSettingMarginsCustom,\n                       std::move(custom_margins));\n    }\n  } else {\n    settings.SetIntKey(printing::kSettingMarginsType,\n                       printing::DEFAULT_MARGINS);\n  }\n\n  // Set whether to print color or greyscale\n  bool print_color = true;\n  options.Get(\"color\", &print_color);\n  int color_setting = print_color ? printing::COLOR : printing::GRAY;\n  settings.SetIntKey(printing::kSettingColor, color_setting);\n\n  // Is the orientation landscape or portrait.\n  bool landscape = false;\n  options.Get(\"landscape\", &landscape);\n  settings.SetBoolKey(printing::kSettingLandscape, landscape);\n\n  // We set the default to the system's default printer and only update\n  // if at the Chromium level if the user overrides.\n  // Printer device name as opened by the OS.\n  base::string16 device_name;\n  options.Get(\"deviceName\", &device_name);\n  if (!device_name.empty() && !IsDeviceNameValid(device_name)) {\n    args->ThrowError(\"webContents.print(): Invalid deviceName provided.\");\n    return;\n  }\n\n  int scale_factor = 100;\n  options.Get(\"scaleFactor\", &scale_factor);\n  settings.SetIntKey(printing::kSettingScaleFactor, scale_factor);\n\n  int pages_per_sheet = 1;\n  options.Get(\"pagesPerSheet\", &pages_per_sheet);\n  settings.SetIntKey(printing::kSettingPagesPerSheet, pages_per_sheet);\n\n  // True if the user wants to print with collate.\n  bool collate = true;\n  options.Get(\"collate\", &collate);\n  settings.SetBoolKey(printing::kSettingCollate, collate);\n\n  // The number of individual copies to print\n  int copies = 1;\n  options.Get(\"copies\", &copies);\n  settings.SetIntKey(printing::kSettingCopies, copies);\n\n  // Strings to be printed as headers and footers if requested by the user.\n  std::string header;\n  options.Get(\"header\", &header);\n  std::string footer;\n  options.Get(\"footer\", &footer);\n\n  if (!(header.empty() && footer.empty())) {\n    settings.SetBoolKey(printing::kSettingHeaderFooterEnabled, true);\n\n    settings.SetStringKey(printing::kSettingHeaderFooterTitle, header);\n    settings.SetStringKey(printing::kSettingHeaderFooterURL, footer);\n  } else {\n    settings.SetBoolKey(printing::kSettingHeaderFooterEnabled, false);\n  }\n\n  // We don't want to allow the user to enable these settings\n  // but we need to set them or a CHECK is hit.\n  settings.SetIntKey(printing::kSettingPrinterType,\n                     static_cast<int>(printing::PrinterType::kLocal));\n  settings.SetBoolKey(printing::kSettingShouldPrintSelectionOnly, false);\n  settings.SetBoolKey(printing::kSettingRasterizePdf, false);\n\n  // Set custom page ranges to print\n  std::vector<gin_helper::Dictionary> page_ranges;\n  if (options.Get(\"pageRanges\", &page_ranges)) {\n    base::Value page_range_list(base::Value::Type::LIST);\n    for (auto& range : page_ranges) {\n      int from, to;\n      if (range.Get(\"from\", &from) && range.Get(\"to\", &to)) {\n        base::Value range(base::Value::Type::DICTIONARY);\n        range.SetIntKey(printing::kSettingPageRangeFrom, from);\n        range.SetIntKey(printing::kSettingPageRangeTo, to);\n        page_range_list.Append(std::move(range));\n      } else {\n        continue;\n      }\n    }\n    if (page_range_list.GetList().size() > 0)\n      settings.SetPath(printing::kSettingPageRange, std::move(page_range_list));\n  }\n\n  // Duplex type user wants to use.\n  printing::mojom::DuplexMode duplex_mode =\n      printing::mojom::DuplexMode::kSimplex;\n  options.Get(\"duplexMode\", &duplex_mode);\n  settings.SetIntKey(printing::kSettingDuplexMode,\n                     static_cast<int>(duplex_mode));\n\n  // We've already done necessary parameter sanitization at the\n  // JS level, so we can simply pass this through.\n  base::Value media_size(base::Value::Type::DICTIONARY);\n  if (options.Get(\"mediaSize\", &media_size))\n    settings.SetKey(printing::kSettingMediaSize, std::move(media_size));\n\n  // Set custom dots per inch (dpi)\n  gin_helper::Dictionary dpi_settings;\n  int dpi = 72;\n  if (options.Get(\"dpi\", &dpi_settings)) {\n    int horizontal = 72;\n    dpi_settings.Get(\"horizontal\", &horizontal);\n    settings.SetIntKey(printing::kSettingDpiHorizontal, horizontal);\n    int vertical = 72;\n    dpi_settings.Get(\"vertical\", &vertical);\n    settings.SetIntKey(printing::kSettingDpiVertical, vertical);\n  } else {\n    settings.SetIntKey(printing::kSettingDpiHorizontal, dpi);\n    settings.SetIntKey(printing::kSettingDpiVertical, dpi);\n  }\n\n  base::ThreadPool::PostTaskAndReplyWithResult(\n      FROM_HERE, {base::MayBlock(), base::TaskPriority::USER_BLOCKING},\n      base::BindOnce(&GetDefaultPrinterAsync),\n      base::BindOnce(&WebContents::OnGetDefaultPrinter,\n                     weak_factory_.GetWeakPtr(), std::move(settings),\n                     std::move(callback), device_name, silent));\n}\n\nstd::vector<printing::PrinterBasicInfo> WebContents::GetPrinterList() {\n  std::vector<printing::PrinterBasicInfo> printers;\n  auto print_backend = printing::PrintBackend::CreateInstance(\n      nullptr, g_browser_process->GetApplicationLocale());\n  {\n    // TODO(deepak1556): Deprecate this api in favor of an\n    // async version and post a non blocing task call.\n    base::ThreadRestrictions::ScopedAllowIO allow_io;\n    print_backend->EnumeratePrinters(&printers);\n  }\n  return printers;\n}\n\nv8::Local<v8::Promise> WebContents::PrintToPDF(base::DictionaryValue settings) {\n  gin_helper::Promise<v8::Local<v8::Value>> promise(isolate());\n  v8::Local<v8::Promise> handle = promise.GetHandle();\n  PrintPreviewMessageHandler::FromWebContents(web_contents())\n      ->PrintToPDF(std::move(settings), std::move(promise));\n  return handle;\n}\n#endif\n\nvoid WebContents::AddWorkSpace(gin_helper::Arguments* args,\n                               const base::FilePath& path) {\n  if (path.empty()) {\n    args->ThrowError(\"path cannot be empty\");\n    return;\n  }\n  DevToolsAddFileSystem(std::string(), path);\n}\n\nvoid WebContents::RemoveWorkSpace(gin_helper::Arguments* args,\n                                  const base::FilePath& path) {\n  if (path.empty()) {\n    args->ThrowError(\"path cannot be empty\");\n    return;\n  }\n  DevToolsRemoveFileSystem(path);\n}\n\nvoid WebContents::Undo() {\n  web_contents()->Undo();\n}\n\nvoid WebContents::Redo() {\n  web_contents()->Redo();\n}\n\nvoid WebContents::Cut() {\n  web_contents()->Cut();\n}\n\nvoid WebContents::Copy() {\n  web_contents()->Copy();\n}\n\nvoid WebContents::Paste() {\n  web_contents()->Paste();\n}\n\nvoid WebContents::PasteAndMatchStyle() {\n  web_contents()->PasteAndMatchStyle();\n}\n\nvoid WebContents::Delete() {\n  web_contents()->Delete();\n}\n\nvoid WebContents::SelectAll() {\n  web_contents()->SelectAll();\n}\n\nvoid WebContents::Unselect() {\n  web_contents()->CollapseSelection();\n}\n\nvoid WebContents::Replace(const base::string16& word) {\n  web_contents()->Replace(word);\n}\n\nvoid WebContents::ReplaceMisspelling(const base::string16& word) {\n  web_contents()->ReplaceMisspelling(word);\n}\n\nuint32_t WebContents::FindInPage(gin_helper::Arguments* args) {\n  base::string16 search_text;\n  if (!args->GetNext(&search_text) || search_text.empty()) {\n    args->ThrowError(\"Must provide a non-empty search content\");\n    return 0;\n  }\n\n  uint32_t request_id = GetNextRequestId();\n  gin_helper::Dictionary dict;\n  auto options = blink::mojom::FindOptions::New();\n  if (args->GetNext(&dict)) {\n    dict.Get(\"forward\", &options->forward);\n    dict.Get(\"matchCase\", &options->match_case);\n    dict.Get(\"findNext\", &options->new_session);\n  }\n\n  web_contents()->Find(request_id, search_text, std::move(options));\n  return request_id;\n}\n\nvoid WebContents::StopFindInPage(content::StopFindAction action) {\n  web_contents()->StopFinding(action);\n}\n\nvoid WebContents::ShowDefinitionForSelection() {\n#if defined(OS_MACOSX)\n  auto* const view = web_contents()->GetRenderWidgetHostView();\n  if (view)\n    view->ShowDefinitionForSelection();\n#endif\n}\n\nvoid WebContents::CopyImageAt(int x, int y) {\n  auto* const host = web_contents()->GetMainFrame();\n  if (host)\n    host->CopyImageAt(x, y);\n}\n\nvoid WebContents::Focus() {\n  // Focusing on WebContents does not automatically focus the window on macOS\n  // and Linux, do it manually to match the behavior on Windows.\n#if defined(OS_MACOSX) || defined(OS_LINUX)\n  if (owner_window())\n    owner_window()->Focus(true);\n#endif\n  web_contents()->Focus();\n}\n\n#if !defined(OS_MACOSX)\nbool WebContents::IsFocused() const {\n  auto* view = web_contents()->GetRenderWidgetHostView();\n  if (!view)\n    return false;\n\n  if (GetType() != Type::BACKGROUND_PAGE) {\n    auto* window = web_contents()->GetNativeView()->GetToplevelWindow();\n    if (window && !window->IsVisible())\n      return false;\n  }\n\n  return view->HasFocus();\n}\n#endif\n\nvoid WebContents::TabTraverse(bool reverse) {\n  web_contents()->FocusThroughTabTraversal(reverse);\n}\n\nbool WebContents::SendIPCMessage(bool internal,\n                                 bool send_to_all,\n                                 const std::string& channel,\n                                 v8::Local<v8::Value> args) {\n  blink::CloneableMessage message;\n  if (!gin::ConvertFromV8(isolate(), args, &message)) {\n    isolate()->ThrowException(v8::Exception::Error(\n        gin::StringToV8(isolate(), \"Failed to serialize arguments\")));\n    return false;\n  }\n  return SendIPCMessageWithSender(internal, send_to_all, channel,\n                                  std::move(message));\n}\n\nbool WebContents::SendIPCMessageWithSender(bool internal,\n                                           bool send_to_all,\n                                           const std::string& channel,\n                                           blink::CloneableMessage args,\n                                           int32_t sender_id) {\n  std::vector<content::RenderFrameHost*> target_hosts;\n  if (!send_to_all) {\n    auto* frame_host = web_contents()->GetMainFrame();\n    if (frame_host) {\n      target_hosts.push_back(frame_host);\n    }\n  } else {\n    target_hosts = web_contents()->GetAllFrames();\n  }\n\n  for (auto* frame_host : target_hosts) {\n    mojo::AssociatedRemote<mojom::ElectronRenderer> electron_renderer;\n    frame_host->GetRemoteAssociatedInterfaces()->GetInterface(\n        &electron_renderer);\n    electron_renderer->Message(internal, false, channel, args.ShallowClone(),\n                               sender_id);\n  }\n  return true;\n}\n\nbool WebContents::SendIPCMessageToFrame(bool internal,\n                                        bool send_to_all,\n                                        int32_t frame_id,\n                                        const std::string& channel,\n                                        v8::Local<v8::Value> args) {\n  blink::CloneableMessage message;\n  if (!gin::ConvertFromV8(isolate(), args, &message)) {\n    isolate()->ThrowException(v8::Exception::Error(\n        gin::StringToV8(isolate(), \"Failed to serialize arguments\")));\n    return false;\n  }\n  auto frames = web_contents()->GetAllFrames();\n  auto iter = std::find_if(frames.begin(), frames.end(), [frame_id](auto* f) {\n    return f->GetRoutingID() == frame_id;\n  });\n  if (iter == frames.end())\n    return false;\n  if (!(*iter)->IsRenderFrameLive())\n    return false;\n\n  mojo::AssociatedRemote<mojom::ElectronRenderer> electron_renderer;\n  (*iter)->GetRemoteAssociatedInterfaces()->GetInterface(&electron_renderer);\n  electron_renderer->Message(internal, send_to_all, channel, std::move(message),\n                             0 /* sender_id */);\n  return true;\n}\n\nvoid WebContents::SendInputEvent(v8::Isolate* isolate,\n                                 v8::Local<v8::Value> input_event) {\n  content::RenderWidgetHostView* view =\n      web_contents()->GetRenderWidgetHostView();\n  if (!view)\n    return;\n\n  content::RenderWidgetHost* rwh = view->GetRenderWidgetHost();\n  blink::WebInputEvent::Type type =\n      gin::GetWebInputEventType(isolate, input_event);\n  if (blink::WebInputEvent::IsMouseEventType(type)) {\n    blink::WebMouseEvent mouse_event;\n    if (gin::ConvertFromV8(isolate, input_event, &mouse_event)) {\n      if (IsOffScreen()) {\n#if BUILDFLAG(ENABLE_OSR)\n        GetOffScreenRenderWidgetHostView()->SendMouseEvent(mouse_event);\n#endif\n      } else {\n        rwh->ForwardMouseEvent(mouse_event);\n      }\n      return;\n    }\n  } else if (blink::WebInputEvent::IsKeyboardEventType(type)) {\n    content::NativeWebKeyboardEvent keyboard_event(\n        blink::WebKeyboardEvent::Type::kRawKeyDown,\n        blink::WebInputEvent::Modifiers::kNoModifiers, ui::EventTimeForNow());\n    if (gin::ConvertFromV8(isolate, input_event, &keyboard_event)) {\n      rwh->ForwardKeyboardEvent(keyboard_event);\n      return;\n    }\n  } else if (type == blink::WebInputEvent::Type::kMouseWheel) {\n    blink::WebMouseWheelEvent mouse_wheel_event;\n    if (gin::ConvertFromV8(isolate, input_event, &mouse_wheel_event)) {\n      if (IsOffScreen()) {\n#if BUILDFLAG(ENABLE_OSR)\n        GetOffScreenRenderWidgetHostView()->SendMouseWheelEvent(\n            mouse_wheel_event);\n#endif\n      } else {\n        // Chromium expects phase info in wheel events (and applies a\n        // DCHECK to verify it). See: https://crbug.com/756524.\n        mouse_wheel_event.phase = blink::WebMouseWheelEvent::kPhaseBegan;\n        mouse_wheel_event.dispatch_type =\n            blink::WebInputEvent::DispatchType::kBlocking;\n        rwh->ForwardWheelEvent(mouse_wheel_event);\n\n        // Send a synthetic wheel event with phaseEnded to finish scrolling.\n        mouse_wheel_event.has_synthetic_phase = true;\n        mouse_wheel_event.delta_x = 0;\n        mouse_wheel_event.delta_y = 0;\n        mouse_wheel_event.phase = blink::WebMouseWheelEvent::kPhaseEnded;\n        mouse_wheel_event.dispatch_type =\n            blink::WebInputEvent::DispatchType::kEventNonBlocking;\n        rwh->ForwardWheelEvent(mouse_wheel_event);\n      }\n      return;\n    }\n  }\n\n  isolate->ThrowException(\n      v8::Exception::Error(gin::StringToV8(isolate, \"Invalid event object\")));\n}\n\nvoid WebContents::BeginFrameSubscription(gin_helper::Arguments* args) {\n  bool only_dirty = false;\n  FrameSubscriber::FrameCaptureCallback callback;\n\n  args->GetNext(&only_dirty);\n  if (!args->GetNext(&callback)) {\n    args->ThrowError();\n    return;\n  }\n\n  frame_subscriber_ =\n      std::make_unique<FrameSubscriber>(web_contents(), callback, only_dirty);\n}\n\nvoid WebContents::EndFrameSubscription() {\n  frame_subscriber_.reset();\n}\n\nvoid WebContents::StartDrag(const gin_helper::Dictionary& item,\n                            gin_helper::Arguments* args) {\n  base::FilePath file;\n  std::vector<base::FilePath> files;\n  if (!item.Get(\"files\", &files) && item.Get(\"file\", &file)) {\n    files.push_back(file);\n  }\n\n  gin::Handle<NativeImage> icon;\n  if (!item.Get(\"icon\", &icon) || icon->image().IsEmpty()) {\n    args->ThrowError(\"Must specify non-empty 'icon' option\");\n    return;\n  }\n\n  // Start dragging.\n  if (!files.empty()) {\n    base::MessageLoopCurrent::ScopedNestableTaskAllower allow;\n    DragFileItems(files, icon->image(), web_contents()->GetNativeView());\n  } else {\n    args->ThrowError(\"Must specify either 'file' or 'files' option\");\n  }\n}\n\nv8::Local<v8::Promise> WebContents::CapturePage(gin_helper::Arguments* args) {\n  gfx::Rect rect;\n  gin_helper::Promise<gfx::Image> promise(isolate());\n  v8::Local<v8::Promise> handle = promise.GetHandle();\n\n  // get rect arguments if they exist\n  args->GetNext(&rect);\n\n  auto* const view = web_contents()->GetRenderWidgetHostView();\n  if (!view) {\n    promise.Resolve(gfx::Image());\n    return handle;\n  }\n\n  // Capture full page if user doesn't specify a |rect|.\n  const gfx::Size view_size =\n      rect.IsEmpty() ? view->GetViewBounds().size() : rect.size();\n\n  // By default, the requested bitmap size is the view size in screen\n  // coordinates.  However, if there's more pixel detail available on the\n  // current system, increase the requested bitmap size to capture it all.\n  gfx::Size bitmap_size = view_size;\n  const gfx::NativeView native_view = view->GetNativeView();\n  const float scale = display::Screen::GetScreen()\n                          ->GetDisplayNearestView(native_view)\n                          .device_scale_factor();\n  if (scale > 1.0f)\n    bitmap_size = gfx::ScaleToCeiledSize(view_size, scale);\n\n  view->CopyFromSurface(gfx::Rect(rect.origin(), view_size), bitmap_size,\n                        base::BindOnce(&OnCapturePageDone, std::move(promise)));\n  return handle;\n}\n\nvoid WebContents::IncrementCapturerCount(gin_helper::Arguments* args) {\n  gfx::Size size;\n  bool stay_hidden = false;\n\n  // get size arguments if they exist\n  args->GetNext(&size);\n  // get stayHidden arguments if they exist\n  args->GetNext(&stay_hidden);\n\n  web_contents()->IncrementCapturerCount(size, stay_hidden);\n}\n\nvoid WebContents::DecrementCapturerCount(gin_helper::Arguments* args) {\n  bool stay_hidden = false;\n\n  // get stayHidden arguments if they exist\n  args->GetNext(&stay_hidden);\n\n  web_contents()->DecrementCapturerCount(stay_hidden);\n}\n\nbool WebContents::IsBeingCaptured() {\n  return web_contents()->IsBeingCaptured();\n}\n\nvoid WebContents::OnCursorChanged(const content::WebCursor& webcursor) {\n  const ui::Cursor& cursor = webcursor.cursor();\n\n  if (cursor.type() == ui::mojom::CursorType::kCustom) {\n    Emit(\"cursor-changed\", CursorTypeToString(cursor),\n         gfx::Image::CreateFrom1xBitmap(cursor.custom_bitmap()),\n         cursor.image_scale_factor(),\n         gfx::Size(cursor.custom_bitmap().width(),\n                   cursor.custom_bitmap().height()),\n         cursor.custom_hotspot());\n  } else {\n    Emit(\"cursor-changed\", CursorTypeToString(cursor));\n  }\n}\n\nbool WebContents::IsGuest() const {\n  return type_ == Type::WEB_VIEW;\n}\n\nvoid WebContents::AttachToIframe(content::WebContents* embedder_web_contents,\n                                 int embedder_frame_id) {\n  if (guest_delegate_)\n    guest_delegate_->AttachToIframe(embedder_web_contents, embedder_frame_id);\n}\n\nbool WebContents::IsOffScreen() const {\n#if BUILDFLAG(ENABLE_OSR)\n  return type_ == Type::OFF_SCREEN;\n#else\n  return false;\n#endif\n}\n\n#if BUILDFLAG(ENABLE_OSR)\nvoid WebContents::OnPaint(const gfx::Rect& dirty_rect, const SkBitmap& bitmap) {\n  Emit(\"paint\", dirty_rect, gfx::Image::CreateFrom1xBitmap(bitmap));\n}\n\nvoid WebContents::StartPainting() {\n  auto* osr_wcv = GetOffScreenWebContentsView();\n  if (osr_wcv)\n    osr_wcv->SetPainting(true);\n}\n\nvoid WebContents::StopPainting() {\n  auto* osr_wcv = GetOffScreenWebContentsView();\n  if (osr_wcv)\n    osr_wcv->SetPainting(false);\n}\n\nbool WebContents::IsPainting() const {\n  auto* osr_wcv = GetOffScreenWebContentsView();\n  return osr_wcv && osr_wcv->IsPainting();\n}\n\nvoid WebContents::SetFrameRate(int frame_rate) {\n  auto* osr_wcv = GetOffScreenWebContentsView();\n  if (osr_wcv)\n    osr_wcv->SetFrameRate(frame_rate);\n}\n\nint WebContents::GetFrameRate() const {\n  auto* osr_wcv = GetOffScreenWebContentsView();\n  return osr_wcv ? osr_wcv->GetFrameRate() : 0;\n}\n#endif\n\nvoid WebContents::Invalidate() {\n  if (IsOffScreen()) {\n#if BUILDFLAG(ENABLE_OSR)\n    auto* osr_rwhv = GetOffScreenRenderWidgetHostView();\n    if (osr_rwhv)\n      osr_rwhv->Invalidate();\n#endif\n  } else {\n    auto* const window = owner_window();\n    if (window)\n      window->Invalidate();\n  }\n}\n\ngfx::Size WebContents::GetSizeForNewRenderView(content::WebContents* wc) {\n  if (IsOffScreen() && wc == web_contents()) {\n    auto* relay = NativeWindowRelay::FromWebContents(web_contents());\n    if (relay) {\n      auto* owner_window = relay->GetNativeWindow();\n      return owner_window ? owner_window->GetSize() : gfx::Size();\n    }\n  }\n\n  return gfx::Size();\n}\n\nvoid WebContents::SetZoomLevel(double level) {\n  zoom_controller_->SetZoomLevel(level);\n}\n\ndouble WebContents::GetZoomLevel() const {\n  return zoom_controller_->GetZoomLevel();\n}\n\nvoid WebContents::SetZoomFactor(gin_helper::ErrorThrower thrower,\n                                double factor) {\n  if (factor < std::numeric_limits<double>::epsilon()) {\n    thrower.ThrowError(\"'zoomFactor' must be a double greater than 0.0\");\n    return;\n  }\n\n  auto level = blink::PageZoomFactorToZoomLevel(factor);\n  SetZoomLevel(level);\n}\n\ndouble WebContents::GetZoomFactor() const {\n  auto level = GetZoomLevel();\n  return blink::PageZoomLevelToZoomFactor(level);\n}\n\nvoid WebContents::SetTemporaryZoomLevel(double level) {\n  zoom_controller_->SetTemporaryZoomLevel(level);\n}\n\nvoid WebContents::DoGetZoomLevel(DoGetZoomLevelCallback callback) {\n  std::move(callback).Run(GetZoomLevel());\n}\n\nstd::vector<base::FilePath::StringType> WebContents::GetPreloadPaths() const {\n  auto result = SessionPreferences::GetValidPreloads(GetBrowserContext());\n\n  if (auto* web_preferences = WebContentsPreferences::From(web_contents())) {\n    base::FilePath::StringType preload;\n    if (web_preferences->GetPreloadPath(&preload)) {\n      result.emplace_back(preload);\n    }\n  }\n\n  return result;\n}\n\nv8::Local<v8::Value> WebContents::GetWebPreferences(\n    v8::Isolate* isolate) const {\n  auto* web_preferences = WebContentsPreferences::From(web_contents());\n  if (!web_preferences)\n    return v8::Null(isolate);\n  return gin::ConvertToV8(isolate, *web_preferences->preference());\n}\n\nv8::Local<v8::Value> WebContents::GetLastWebPreferences(\n    v8::Isolate* isolate) const {\n  auto* web_preferences = WebContentsPreferences::From(web_contents());\n  if (!web_preferences)\n    return v8::Null(isolate);\n  return gin::ConvertToV8(isolate, *web_preferences->last_preference());\n}\n\nv8::Local<v8::Value> WebContents::GetOwnerBrowserWindow() const {\n  if (owner_window())\n    return BrowserWindow::From(isolate(), owner_window());\n  else\n    return v8::Null(isolate());\n}\n\nint32_t WebContents::ID() const {\n  return weak_map_id();\n}\n\nv8::Local<v8::Value> WebContents::Session(v8::Isolate* isolate) {\n  return v8::Local<v8::Value>::New(isolate, session_);\n}\n\ncontent::WebContents* WebContents::HostWebContents() const {\n  if (!embedder_)\n    return nullptr;\n  return embedder_->web_contents();\n}\n\nvoid WebContents::SetEmbedder(const WebContents* embedder) {\n  if (embedder) {\n    NativeWindow* owner_window = nullptr;\n    auto* relay = NativeWindowRelay::FromWebContents(embedder->web_contents());\n    if (relay) {\n      owner_window = relay->GetNativeWindow();\n    }\n    if (owner_window)\n      SetOwnerWindow(owner_window);\n\n    content::RenderWidgetHostView* rwhv =\n        web_contents()->GetRenderWidgetHostView();\n    if (rwhv) {\n      rwhv->Hide();\n      rwhv->Show();\n    }\n  }\n}\n\nvoid WebContents::SetDevToolsWebContents(const WebContents* devtools) {\n  if (managed_web_contents())\n    managed_web_contents()->SetDevToolsWebContents(devtools->web_contents());\n}\n\nv8::Local<v8::Value> WebContents::GetNativeView() const {\n  gfx::NativeView ptr = web_contents()->GetNativeView();\n  auto buffer = node::Buffer::Copy(isolate(), reinterpret_cast<char*>(&ptr),\n                                   sizeof(gfx::NativeView));\n  if (buffer.IsEmpty())\n    return v8::Null(isolate());\n  else\n    return buffer.ToLocalChecked();\n}\n\nv8::Local<v8::Value> WebContents::DevToolsWebContents(v8::Isolate* isolate) {\n  if (devtools_web_contents_.IsEmpty())\n    return v8::Null(isolate);\n  else\n    return v8::Local<v8::Value>::New(isolate, devtools_web_contents_);\n}\n\nv8::Local<v8::Value> WebContents::Debugger(v8::Isolate* isolate) {\n  if (debugger_.IsEmpty()) {\n    auto handle = electron::api::Debugger::Create(isolate, web_contents());\n    debugger_.Reset(isolate, handle.ToV8());\n  }\n  return v8::Local<v8::Value>::New(isolate, debugger_);\n}\n\nvoid WebContents::GrantOriginAccess(const GURL& url) {\n  content::ChildProcessSecurityPolicy::GetInstance()->GrantCommitOrigin(\n      web_contents()->GetMainFrame()->GetProcess()->GetID(),\n      url::Origin::Create(url));\n}\n\nvoid WebContents::NotifyUserActivation() {\n  auto* frame = web_contents()->GetMainFrame();\n  if (!frame)\n    return;\n  mojo::AssociatedRemote<mojom::ElectronRenderer> renderer;\n  frame->GetRemoteAssociatedInterfaces()->GetInterface(&renderer);\n  renderer->NotifyUserActivation();\n}\n\nv8::Local<v8::Promise> WebContents::TakeHeapSnapshot(\n    const base::FilePath& file_path) {\n  gin_helper::Promise<void> promise(isolate());\n  v8::Local<v8::Promise> handle = promise.GetHandle();\n\n  base::ThreadRestrictions::ScopedAllowIO allow_io;\n  base::File file(file_path,\n                  base::File::FLAG_CREATE_ALWAYS | base::File::FLAG_WRITE);\n  if (!file.IsValid()) {\n    promise.RejectWithErrorMessage(\"takeHeapSnapshot failed\");\n    return handle;\n  }\n\n  auto* frame_host = web_contents()->GetMainFrame();\n  if (!frame_host) {\n    promise.RejectWithErrorMessage(\"takeHeapSnapshot failed\");\n    return handle;\n  }\n\n  // This dance with `base::Owned` is to ensure that the interface stays alive\n  // until the callback is called. Otherwise it would be closed at the end of\n  // this function.\n  auto electron_renderer =\n      std::make_unique<mojo::AssociatedRemote<mojom::ElectronRenderer>>();\n  frame_host->GetRemoteAssociatedInterfaces()->GetInterface(\n      electron_renderer.get());\n  auto* raw_ptr = electron_renderer.get();\n  (*raw_ptr)->TakeHeapSnapshot(\n      mojo::WrapPlatformFile(file.TakePlatformFile()),\n      base::BindOnce(\n          [](mojo::AssociatedRemote<mojom::ElectronRenderer>* ep,\n             gin_helper::Promise<void> promise, bool success) {\n            if (success) {\n              promise.Resolve();\n            } else {\n              promise.RejectWithErrorMessage(\"takeHeapSnapshot failed\");\n            }\n          },\n          base::Owned(std::move(electron_renderer)), std::move(promise)));\n  return handle;\n}\n\n// static\nvoid WebContents::BuildPrototype(v8::Isolate* isolate,\n                                 v8::Local<v8::FunctionTemplate> prototype) {\n  prototype->SetClassName(gin::StringToV8(isolate, \"WebContents\"));\n  gin_helper::Destroyable::MakeDestroyable(isolate, prototype);\n  gin_helper::ObjectTemplateBuilder(isolate, prototype->PrototypeTemplate())\n      .SetMethod(\"getBackgroundThrottling\",\n                 &WebContents::GetBackgroundThrottling)\n      .SetMethod(\"setBackgroundThrottling\",\n                 &WebContents::SetBackgroundThrottling)\n      .SetMethod(\"getProcessId\", &WebContents::GetProcessID)\n      .SetMethod(\"getOSProcessId\", &WebContents::GetOSProcessID)\n      .SetMethod(\"_getOSProcessIdForFrame\",\n                 &WebContents::GetOSProcessIdForFrame)\n      .SetMethod(\"equal\", &WebContents::Equal)\n      .SetMethod(\"_loadURL\", &WebContents::LoadURL)\n      .SetMethod(\"downloadURL\", &WebContents::DownloadURL)\n      .SetMethod(\"_getURL\", &WebContents::GetURL)\n      .SetMethod(\"getTitle\", &WebContents::GetTitle)\n      .SetMethod(\"isLoading\", &WebContents::IsLoading)\n      .SetMethod(\"isLoadingMainFrame\", &WebContents::IsLoadingMainFrame)\n      .SetMethod(\"isWaitingForResponse\", &WebContents::IsWaitingForResponse)\n      .SetMethod(\"_stop\", &WebContents::Stop)\n      .SetMethod(\"_goBack\", &WebContents::GoBack)\n      .SetMethod(\"_goForward\", &WebContents::GoForward)\n      .SetMethod(\"_goToOffset\", &WebContents::GoToOffset)\n      .SetMethod(\"isCrashed\", &WebContents::IsCrashed)\n      .SetMethod(\"setUserAgent\", &WebContents::SetUserAgent)\n      .SetMethod(\"getUserAgent\", &WebContents::GetUserAgent)\n      .SetMethod(\"savePage\", &WebContents::SavePage)\n      .SetMethod(\"openDevTools\", &WebContents::OpenDevTools)\n      .SetMethod(\"closeDevTools\", &WebContents::CloseDevTools)\n      .SetMethod(\"isDevToolsOpened\", &WebContents::IsDevToolsOpened)\n      .SetMethod(\"isDevToolsFocused\", &WebContents::IsDevToolsFocused)\n      .SetMethod(\"enableDeviceEmulation\", &WebContents::EnableDeviceEmulation)\n      .SetMethod(\"disableDeviceEmulation\", &WebContents::DisableDeviceEmulation)\n      .SetMethod(\"toggleDevTools\", &WebContents::ToggleDevTools)\n      .SetMethod(\"inspectElement\", &WebContents::InspectElement)\n      .SetMethod(\"setIgnoreMenuShortcuts\", &WebContents::SetIgnoreMenuShortcuts)\n      .SetMethod(\"setAudioMuted\", &WebContents::SetAudioMuted)\n      .SetMethod(\"isAudioMuted\", &WebContents::IsAudioMuted)\n      .SetMethod(\"isCurrentlyAudible\", &WebContents::IsCurrentlyAudible)\n      .SetMethod(\"undo\", &WebContents::Undo)\n      .SetMethod(\"redo\", &WebContents::Redo)\n      .SetMethod(\"cut\", &WebContents::Cut)\n      .SetMethod(\"copy\", &WebContents::Copy)\n      .SetMethod(\"paste\", &WebContents::Paste)\n      .SetMethod(\"pasteAndMatchStyle\", &WebContents::PasteAndMatchStyle)\n      .SetMethod(\"delete\", &WebContents::Delete)\n      .SetMethod(\"selectAll\", &WebContents::SelectAll)\n      .SetMethod(\"unselect\", &WebContents::Unselect)\n      .SetMethod(\"replace\", &WebContents::Replace)\n      .SetMethod(\"replaceMisspelling\", &WebContents::ReplaceMisspelling)\n      .SetMethod(\"findInPage\", &WebContents::FindInPage)\n      .SetMethod(\"stopFindInPage\", &WebContents::StopFindInPage)\n      .SetMethod(\"focus\", &WebContents::Focus)\n      .SetMethod(\"isFocused\", &WebContents::IsFocused)\n      .SetMethod(\"tabTraverse\", &WebContents::TabTraverse)\n      .SetMethod(\"_send\", &WebContents::SendIPCMessage)\n      .SetMethod(\"_postMessage\", &WebContents::PostMessage)\n      .SetMethod(\"_sendToFrame\", &WebContents::SendIPCMessageToFrame)\n      .SetMethod(\"sendInputEvent\", &WebContents::SendInputEvent)\n      .SetMethod(\"beginFrameSubscription\", &WebContents::BeginFrameSubscription)\n      .SetMethod(\"endFrameSubscription\", &WebContents::EndFrameSubscription)\n      .SetMethod(\"startDrag\", &WebContents::StartDrag)\n      .SetMethod(\"attachToIframe\", &WebContents::AttachToIframe)\n      .SetMethod(\"detachFromOuterFrame\", &WebContents::DetachFromOuterFrame)\n      .SetMethod(\"isOffscreen\", &WebContents::IsOffScreen)\n#if BUILDFLAG(ENABLE_OSR)\n      .SetMethod(\"startPainting\", &WebContents::StartPainting)\n      .SetMethod(\"stopPainting\", &WebContents::StopPainting)\n      .SetMethod(\"isPainting\", &WebContents::IsPainting)\n      .SetMethod(\"setFrameRate\", &WebContents::SetFrameRate)\n      .SetMethod(\"getFrameRate\", &WebContents::GetFrameRate)\n#endif\n      .SetMethod(\"invalidate\", &WebContents::Invalidate)\n      .SetMethod(\"setZoomLevel\", &WebContents::SetZoomLevel)\n      .SetMethod(\"getZoomLevel\", &WebContents::GetZoomLevel)\n      .SetMethod(\"setZoomFactor\", &WebContents::SetZoomFactor)\n      .SetMethod(\"getZoomFactor\", &WebContents::GetZoomFactor)\n      .SetMethod(\"getType\", &WebContents::GetType)\n      .SetMethod(\"_getPreloadPaths\", &WebContents::GetPreloadPaths)\n      .SetMethod(\"getWebPreferences\", &WebContents::GetWebPreferences)\n      .SetMethod(\"getLastWebPreferences\", &WebContents::GetLastWebPreferences)\n      .SetMethod(\"getOwnerBrowserWindow\", &WebContents::GetOwnerBrowserWindow)\n      .SetMethod(\"inspectServiceWorker\", &WebContents::InspectServiceWorker)\n      .SetMethod(\"inspectSharedWorker\", &WebContents::InspectSharedWorker)\n      .SetMethod(\"inspectSharedWorkerById\",\n                 &WebContents::InspectSharedWorkerById)\n      .SetMethod(\"getAllSharedWorkers\", &WebContents::GetAllSharedWorkers)\n#if BUILDFLAG(ENABLE_PRINTING)\n      .SetMethod(\"_print\", &WebContents::Print)\n      .SetMethod(\"_getPrinters\", &WebContents::GetPrinterList)\n      .SetMethod(\"_printToPDF\", &WebContents::PrintToPDF)\n#endif\n      .SetMethod(\"addWorkSpace\", &WebContents::AddWorkSpace)\n      .SetMethod(\"removeWorkSpace\", &WebContents::RemoveWorkSpace)\n      .SetMethod(\"showDefinitionForSelection\",\n                 &WebContents::ShowDefinitionForSelection)\n      .SetMethod(\"copyImageAt\", &WebContents::CopyImageAt)\n      .SetMethod(\"capturePage\", &WebContents::CapturePage)\n      .SetMethod(\"setEmbedder\", &WebContents::SetEmbedder)\n      .SetMethod(\"setDevToolsWebContents\", &WebContents::SetDevToolsWebContents)\n      .SetMethod(\"getNativeView\", &WebContents::GetNativeView)\n      .SetMethod(\"incrementCapturerCount\", &WebContents::IncrementCapturerCount)\n      .SetMethod(\"decrementCapturerCount\", &WebContents::DecrementCapturerCount)\n      .SetMethod(\"isBeingCaptured\", &WebContents::IsBeingCaptured)\n      .SetMethod(\"setWebRTCIPHandlingPolicy\",\n                 &WebContents::SetWebRTCIPHandlingPolicy)\n      .SetMethod(\"getWebRTCIPHandlingPolicy\",\n                 &WebContents::GetWebRTCIPHandlingPolicy)\n      .SetMethod(\"_grantOriginAccess\", &WebContents::GrantOriginAccess)\n      .SetMethod(\"takeHeapSnapshot\", &WebContents::TakeHeapSnapshot)\n      .SetProperty(\"id\", &WebContents::ID)\n      .SetProperty(\"session\", &WebContents::Session)\n      .SetProperty(\"hostWebContents\", &WebContents::HostWebContents)\n      .SetProperty(\"devToolsWebContents\", &WebContents::DevToolsWebContents)\n      .SetProperty(\"debugger\", &WebContents::Debugger);\n}\n\nElectronBrowserContext* WebContents::GetBrowserContext() const {\n  return static_cast<ElectronBrowserContext*>(\n      web_contents()->GetBrowserContext());\n}\n\n// static\ngin::Handle<WebContents> WebContents::Create(\n    v8::Isolate* isolate,\n    const gin_helper::Dictionary& options) {\n  return gin::CreateHandle(isolate, new WebContents(isolate, options));\n}\n\n// static\ngin::Handle<WebContents> WebContents::CreateAndTake(\n    v8::Isolate* isolate,\n    std::unique_ptr<content::WebContents> web_contents,\n    Type type) {\n  return gin::CreateHandle(\n      isolate, new WebContents(isolate, std::move(web_contents), type));\n}\n\n// static\ngin::Handle<WebContents> WebContents::From(v8::Isolate* isolate,\n                                           content::WebContents* web_contents) {\n  auto* existing = TrackableObject::FromWrappedClass(isolate, web_contents);\n  if (existing)\n    return gin::CreateHandle(isolate, static_cast<WebContents*>(existing));\n  else\n    return gin::Handle<WebContents>();\n}\n\n// static\ngin::Handle<WebContents> WebContents::FromOrCreate(\n    v8::Isolate* isolate,\n    content::WebContents* web_contents) {\n  auto existing = From(isolate, web_contents);\n  if (!existing.IsEmpty())\n    return existing;\n  else\n    return gin::CreateHandle(isolate, new WebContents(isolate, web_contents));\n}\n\n}  // namespace api\n\n}  // namespace electron\n\nnamespace {\n\nusing electron::api::WebContents;\n\nvoid Initialize(v8::Local<v8::Object> exports,\n                v8::Local<v8::Value> unused,\n                v8::Local<v8::Context> context,\n                void* priv) {\n  v8::Isolate* isolate = context->GetIsolate();\n  gin_helper::Dictionary dict(isolate, exports);\n  dict.Set(\"WebContents\", WebContents::GetConstructor(isolate)\n                              ->GetFunction(context)\n                              .ToLocalChecked());\n  dict.SetMethod(\"create\", &WebContents::Create);\n  dict.SetMethod(\"fromId\", &WebContents::FromWeakMapID);\n  dict.SetMethod(\"getAllWebContents\", &WebContents::GetAll);\n}\n\n}  // namespace\n\nNODE_LINKED_MODULE_CONTEXT_AWARE(electron_browser_web_contents, Initialize)\n", "// Copyright (c) 2015 GitHub, Inc.\n// Use of this source code is governed by the MIT license that can be\n// found in the LICENSE file.\n\n#include \"shell/browser/electron_navigation_throttle.h\"\n\n#include \"content/public/browser/navigation_handle.h\"\n#include \"shell/browser/api/electron_api_web_contents.h\"\n\nnamespace electron {\n\nElectronNavigationThrottle::ElectronNavigationThrottle(\n    content::NavigationHandle* navigation_handle)\n    : content::NavigationThrottle(navigation_handle) {}\n\nElectronNavigationThrottle::~ElectronNavigationThrottle() = default;\n\nconst char* ElectronNavigationThrottle::GetNameForLogging() {\n  return \"ElectronNavigationThrottle\";\n}\n\ncontent::NavigationThrottle::ThrottleCheckResult\nElectronNavigationThrottle::WillStartRequest() {\n  auto* handle = navigation_handle();\n  auto* contents = handle->GetWebContents();\n  if (!contents) {\n    NOTREACHED();\n    return PROCEED;\n  }\n\n  v8::Isolate* isolate = v8::Isolate::GetCurrent();\n  v8::HandleScope scope(isolate);\n  auto api_contents = electron::api::WebContents::From(isolate, contents);\n  if (api_contents.IsEmpty()) {\n    // No need to emit any event if the WebContents is not available in JS.\n    return PROCEED;\n  }\n\n  if (handle->IsRendererInitiated() && handle->IsInMainFrame() &&\n      api_contents->EmitNavigationEvent(\"will-navigate\", handle)) {\n    return CANCEL;\n  }\n  return PROCEED;\n}\n\ncontent::NavigationThrottle::ThrottleCheckResult\nElectronNavigationThrottle::WillRedirectRequest() {\n  auto* handle = navigation_handle();\n  auto* contents = handle->GetWebContents();\n  if (!contents) {\n    NOTREACHED();\n    return PROCEED;\n  }\n\n  v8::Isolate* isolate = v8::Isolate::GetCurrent();\n  v8::HandleScope scope(isolate);\n  auto api_contents = electron::api::WebContents::From(isolate, contents);\n  if (api_contents.IsEmpty()) {\n    // No need to emit any event if the WebContents is not available in JS.\n    return PROCEED;\n  }\n\n  if (api_contents->EmitNavigationEvent(\"will-redirect\", handle)) {\n    return CANCEL;\n  }\n  return PROCEED;\n}\n\n}  // namespace electron\n", "// Copyright (c) 2018 GitHub, Inc.\n// Use of this source code is governed by the MIT license that can be\n// found in the LICENSE file.\n\n#ifndef SHELL_BROWSER_ELECTRON_NAVIGATION_THROTTLE_H_\n#define SHELL_BROWSER_ELECTRON_NAVIGATION_THROTTLE_H_\n\n#include \"content/public/browser/navigation_throttle.h\"\n\nnamespace electron {\n\nclass ElectronNavigationThrottle : public content::NavigationThrottle {\n public:\n  explicit ElectronNavigationThrottle(content::NavigationHandle* handle);\n  ~ElectronNavigationThrottle() override;\n\n  ElectronNavigationThrottle::ThrottleCheckResult WillStartRequest() override;\n\n  ElectronNavigationThrottle::ThrottleCheckResult WillRedirectRequest()\n      override;\n\n  const char* GetNameForLogging() override;\n\n private:\n  DISALLOW_COPY_AND_ASSIGN(ElectronNavigationThrottle);\n};\n\n}  // namespace electron\n\n#endif  // SHELL_BROWSER_ELECTRON_NAVIGATION_THROTTLE_H_\n", "import { expect } from 'chai';\nimport * as path from 'path';\nimport * as fs from 'fs';\nimport * as os from 'os';\nimport * as qs from 'querystring';\nimport * as http from 'http';\nimport { AddressInfo } from 'net';\nimport { app, BrowserWindow, BrowserView, ipcMain, OnBeforeSendHeadersListenerDetails, protocol, screen, webContents, session, WebContents } from 'electron/main';\n\nimport { emittedOnce, emittedUntil } from './events-helpers';\nimport { ifit, ifdescribe, delay } from './spec-helpers';\nimport { closeWindow, closeAllWindows } from './window-helpers';\n\nconst features = process.electronBinding('features');\nconst fixtures = path.resolve(__dirname, '..', 'spec', 'fixtures');\n\n// Is the display's scale factor possibly causing rounding of pixel coordinate\n// values?\nconst isScaleFactorRounding = () => {\n  const { scaleFactor } = screen.getPrimaryDisplay();\n  // Return true if scale factor is non-integer value\n  if (Math.round(scaleFactor) !== scaleFactor) return true;\n  // Return true if scale factor is odd number above 2\n  return scaleFactor > 2 && scaleFactor % 2 === 1;\n};\n\nconst expectBoundsEqual = (actual: any, expected: any) => {\n  if (!isScaleFactorRounding()) {\n    expect(expected).to.deep.equal(actual);\n  } else if (Array.isArray(actual)) {\n    expect(actual[0]).to.be.closeTo(expected[0], 1);\n    expect(actual[1]).to.be.closeTo(expected[1], 1);\n  } else {\n    expect(actual.x).to.be.closeTo(expected.x, 1);\n    expect(actual.y).to.be.closeTo(expected.y, 1);\n    expect(actual.width).to.be.closeTo(expected.width, 1);\n    expect(actual.height).to.be.closeTo(expected.height, 1);\n  }\n};\n\nconst isBeforeUnload = (event: Event, level: number, message: string) => {\n  return (message === 'beforeunload');\n};\n\ndescribe('BrowserWindow module', () => {\n  describe('BrowserWindow constructor', () => {\n    it('allows passing void 0 as the webContents', async () => {\n      expect(() => {\n        const w = new BrowserWindow({\n          show: false,\n          // apparently void 0 had different behaviour from undefined in the\n          // issue that this test is supposed to catch.\n          webContents: void 0 // eslint-disable-line no-void\n        } as any);\n        w.destroy();\n      }).not.to.throw();\n    });\n  });\n\n  describe('garbage collection', () => {\n    const v8Util = process.electronBinding('v8_util');\n    afterEach(closeAllWindows);\n\n    it('window does not get garbage collected when opened', async () => {\n      const w = new BrowserWindow({ show: false });\n      // Keep a weak reference to the window.\n      // eslint-disable-next-line no-undef\n      const wr = new (globalThis as any).WeakRef(w);\n      await delay();\n      // Do garbage collection, since |w| is not referenced in this closure\n      // it would be gone after next call if there is no other reference.\n      v8Util.requestGarbageCollectionForTesting();\n\n      await delay();\n      expect(wr.deref()).to.not.be.undefined();\n    });\n  });\n\n  describe('BrowserWindow.close()', () => {\n    let w = null as unknown as BrowserWindow;\n    beforeEach(() => {\n      w = new BrowserWindow({ show: false, webPreferences: { nodeIntegration: true } });\n    });\n    afterEach(async () => {\n      await closeWindow(w);\n      w = null as unknown as BrowserWindow;\n    });\n\n    it('should emit unload handler', async () => {\n      await w.loadFile(path.join(fixtures, 'api', 'unload.html'));\n      const closed = emittedOnce(w, 'closed');\n      w.close();\n      await closed;\n      const test = path.join(fixtures, 'api', 'unload');\n      const content = fs.readFileSync(test);\n      fs.unlinkSync(test);\n      expect(String(content)).to.equal('unload');\n    });\n\n    it('should emit beforeunload handler', async () => {\n      await w.loadFile(path.join(__dirname, 'fixtures', 'api', 'beforeunload-false.html'));\n      w.close();\n      await emittedOnce(w.webContents, 'before-unload-fired');\n    });\n\n    describe('when invoked synchronously inside navigation observer', () => {\n      let server: http.Server = null as unknown as http.Server;\n      let url: string = null as unknown as string;\n\n      before((done) => {\n        server = http.createServer((request, response) => {\n          switch (request.url) {\n            case '/net-error':\n              response.destroy();\n              break;\n            case '/301':\n              response.statusCode = 301;\n              response.setHeader('Location', '/200');\n              response.end();\n              break;\n            case '/200':\n              response.statusCode = 200;\n              response.end('hello');\n              break;\n            case '/title':\n              response.statusCode = 200;\n              response.end('<title>Hello</title>');\n              break;\n            default:\n              throw new Error(`unsupported endpoint: ${request.url}`);\n          }\n        }).listen(0, '127.0.0.1', () => {\n          url = 'http://127.0.0.1:' + (server.address() as AddressInfo).port;\n          done();\n        });\n      });\n\n      after(() => {\n        server.close();\n      });\n\n      const events = [\n        { name: 'did-start-loading', path: '/200' },\n        { name: 'dom-ready', path: '/200' },\n        { name: 'page-title-updated', path: '/title' },\n        { name: 'did-stop-loading', path: '/200' },\n        { name: 'did-finish-load', path: '/200' },\n        { name: 'did-frame-finish-load', path: '/200' },\n        { name: 'did-fail-load', path: '/net-error' }\n      ];\n\n      for (const { name, path } of events) {\n        it(`should not crash when closed during ${name}`, async () => {\n          const w = new BrowserWindow({ show: false });\n          w.webContents.once((name as any), () => {\n            w.close();\n          });\n          const destroyed = emittedOnce(w.webContents, 'destroyed');\n          w.webContents.loadURL(url + path);\n          await destroyed;\n        });\n      }\n    });\n  });\n\n  describe('window.close()', () => {\n    let w = null as unknown as BrowserWindow;\n    beforeEach(() => {\n      w = new BrowserWindow({ show: false, webPreferences: { nodeIntegration: true } });\n    });\n    afterEach(async () => {\n      await closeWindow(w);\n      w = null as unknown as BrowserWindow;\n    });\n\n    it('should emit unload event', async () => {\n      w.loadFile(path.join(fixtures, 'api', 'close.html'));\n      await emittedOnce(w, 'closed');\n      const test = path.join(fixtures, 'api', 'close');\n      const content = fs.readFileSync(test).toString();\n      fs.unlinkSync(test);\n      expect(content).to.equal('close');\n    });\n\n    it('should emit beforeunload event', async function () {\n      await w.loadFile(path.join(__dirname, 'fixtures', 'api', 'beforeunload-false.html'));\n      w.webContents.executeJavaScript('window.close()', true);\n      await emittedOnce(w.webContents, 'before-unload-fired');\n    });\n  });\n\n  describe('BrowserWindow.destroy()', () => {\n    let w = null as unknown as BrowserWindow;\n    beforeEach(() => {\n      w = new BrowserWindow({ show: false, webPreferences: { nodeIntegration: true } });\n    });\n    afterEach(async () => {\n      await closeWindow(w);\n      w = null as unknown as BrowserWindow;\n    });\n\n    it('prevents users to access methods of webContents', async () => {\n      const contents = w.webContents;\n      w.destroy();\n      await new Promise(setImmediate);\n      expect(() => {\n        contents.getProcessId();\n      }).to.throw('Object has been destroyed');\n    });\n    it('should not crash when destroying windows with pending events', () => {\n      const focusListener = () => { };\n      app.on('browser-window-focus', focusListener);\n      const windowCount = 3;\n      const windowOptions = {\n        show: false,\n        width: 400,\n        height: 400,\n        webPreferences: {\n          backgroundThrottling: false\n        }\n      };\n      const windows = Array.from(Array(windowCount)).map(() => new BrowserWindow(windowOptions));\n      windows.forEach(win => win.show());\n      windows.forEach(win => win.focus());\n      windows.forEach(win => win.destroy());\n      app.removeListener('browser-window-focus', focusListener);\n    });\n  });\n\n  describe('BrowserWindow.loadURL(url)', () => {\n    let w = null as unknown as BrowserWindow;\n    const scheme = 'other';\n    const srcPath = path.join(fixtures, 'api', 'loaded-from-dataurl.js');\n    before(() => {\n      protocol.registerFileProtocol(scheme, (request, callback) => {\n        callback(srcPath);\n      });\n    });\n\n    after(() => {\n      protocol.unregisterProtocol(scheme);\n    });\n\n    beforeEach(() => {\n      w = new BrowserWindow({ show: false, webPreferences: { nodeIntegration: true } });\n    });\n    afterEach(async () => {\n      await closeWindow(w);\n      w = null as unknown as BrowserWindow;\n    });\n    let server = null as unknown as http.Server;\n    let url = null as unknown as string;\n    let postData = null as any;\n    before((done) => {\n      const filePath = path.join(fixtures, 'pages', 'a.html');\n      const fileStats = fs.statSync(filePath);\n      postData = [\n        {\n          type: 'rawData',\n          bytes: Buffer.from('username=test&file=')\n        },\n        {\n          type: 'file',\n          filePath: filePath,\n          offset: 0,\n          length: fileStats.size,\n          modificationTime: fileStats.mtime.getTime() / 1000\n        }\n      ];\n      server = http.createServer((req, res) => {\n        function respond () {\n          if (req.method === 'POST') {\n            let body = '';\n            req.on('data', (data) => {\n              if (data) body += data;\n            });\n            req.on('end', () => {\n              const parsedData = qs.parse(body);\n              fs.readFile(filePath, (err, data) => {\n                if (err) return;\n                if (parsedData.username === 'test' &&\n                  parsedData.file === data.toString()) {\n                  res.end();\n                }\n              });\n            });\n          } else if (req.url === '/302') {\n            res.setHeader('Location', '/200');\n            res.statusCode = 302;\n            res.end();\n          } else {\n            res.end();\n          }\n        }\n        setTimeout(respond, req.url && req.url.includes('slow') ? 200 : 0);\n      });\n      server.listen(0, '127.0.0.1', () => {\n        url = `http://127.0.0.1:${(server.address() as AddressInfo).port}`;\n        done();\n      });\n    });\n\n    after(() => {\n      server.close();\n    });\n\n    it('should emit did-start-loading event', (done) => {\n      w.webContents.on('did-start-loading', () => { done(); });\n      w.loadURL('about:blank');\n    });\n    it('should emit ready-to-show event', (done) => {\n      w.on('ready-to-show', () => { done(); });\n      w.loadURL('about:blank');\n    });\n    // TODO(deepak1556): The error code now seems to be `ERR_FAILED`, verify what\n    // changed and adjust the test.\n    it.skip('should emit did-fail-load event for files that do not exist', async () => {\n      const didFailLoad = emittedOnce(w.webContents, 'did-fail-load');\n      w.loadURL('file://a.txt');\n      const [, code, desc,, isMainFrame] = await didFailLoad;\n      expect(code).to.equal(-6);\n      expect(desc).to.equal('ERR_FILE_NOT_FOUND');\n      expect(isMainFrame).to.equal(true);\n    });\n    it('should emit did-fail-load event for invalid URL', async () => {\n      const didFailLoad = emittedOnce(w.webContents, 'did-fail-load');\n      w.loadURL('http://example:port');\n      const [, code, desc,, isMainFrame] = await didFailLoad;\n      expect(desc).to.equal('ERR_INVALID_URL');\n      expect(code).to.equal(-300);\n      expect(isMainFrame).to.equal(true);\n    });\n    it('should set `mainFrame = false` on did-fail-load events in iframes', async () => {\n      const didFailLoad = emittedOnce(w.webContents, 'did-fail-load');\n      w.loadFile(path.join(fixtures, 'api', 'did-fail-load-iframe.html'));\n      const [,,,, isMainFrame] = await didFailLoad;\n      expect(isMainFrame).to.equal(false);\n    });\n    it('does not crash in did-fail-provisional-load handler', (done) => {\n      w.webContents.once('did-fail-provisional-load', () => {\n        w.loadURL('http://127.0.0.1:11111');\n        done();\n      });\n      w.loadURL('http://127.0.0.1:11111');\n    });\n    it('should emit did-fail-load event for URL exceeding character limit', async () => {\n      const data = Buffer.alloc(2 * 1024 * 1024).toString('base64');\n      const didFailLoad = emittedOnce(w.webContents, 'did-fail-load');\n      w.loadURL(`data:image/png;base64,${data}`);\n      const [, code, desc,, isMainFrame] = await didFailLoad;\n      expect(desc).to.equal('ERR_INVALID_URL');\n      expect(code).to.equal(-300);\n      expect(isMainFrame).to.equal(true);\n    });\n\n    it('should return a promise', () => {\n      const p = w.loadURL('about:blank');\n      expect(p).to.have.property('then');\n    });\n\n    it('should return a promise that resolves', async () => {\n      await expect(w.loadURL('about:blank')).to.eventually.be.fulfilled();\n    });\n\n    it('should return a promise that rejects on a load failure', async () => {\n      const data = Buffer.alloc(2 * 1024 * 1024).toString('base64');\n      const p = w.loadURL(`data:image/png;base64,${data}`);\n      await expect(p).to.eventually.be.rejected;\n    });\n\n    it('should return a promise that resolves even if pushState occurs during navigation', async () => {\n      const p = w.loadURL('data:text/html,<script>window.history.pushState({}, \"/foo\")</script>');\n      await expect(p).to.eventually.be.fulfilled;\n    });\n\n    // FIXME(robo/nornagon): re-enable these once service workers work\n    describe.skip('POST navigations', () => {\n      afterEach(() => { w.webContents.session.webRequest.onBeforeSendHeaders(null); });\n\n      it('supports specifying POST data', async () => {\n        await w.loadURL(url, { postData });\n      });\n      it('sets the content type header on URL encoded forms', async () => {\n        await w.loadURL(url);\n        const requestDetails: Promise<OnBeforeSendHeadersListenerDetails> = new Promise(resolve => {\n          w.webContents.session.webRequest.onBeforeSendHeaders((details) => {\n            resolve(details);\n          });\n        });\n        w.webContents.executeJavaScript(`\n          form = document.createElement('form')\n          document.body.appendChild(form)\n          form.method = 'POST'\n          form.submit()\n        `);\n        const details = await requestDetails;\n        expect(details.requestHeaders['Content-Type']).to.equal('application/x-www-form-urlencoded');\n      });\n      it('sets the content type header on multi part forms', async () => {\n        await w.loadURL(url);\n        const requestDetails: Promise<OnBeforeSendHeadersListenerDetails> = new Promise(resolve => {\n          w.webContents.session.webRequest.onBeforeSendHeaders((details) => {\n            resolve(details);\n          });\n        });\n        w.webContents.executeJavaScript(`\n          form = document.createElement('form')\n          document.body.appendChild(form)\n          form.method = 'POST'\n          form.enctype = 'multipart/form-data'\n          file = document.createElement('input')\n          file.type = 'file'\n          file.name = 'file'\n          form.appendChild(file)\n          form.submit()\n        `);\n        const details = await requestDetails;\n        expect(details.requestHeaders['Content-Type'].startsWith('multipart/form-data; boundary=----WebKitFormBoundary')).to.equal(true);\n      });\n    });\n\n    it('should support support base url for data urls', async () => {\n      const answer = emittedOnce(ipcMain, 'answer');\n      w.loadURL('data:text/html,<script src=\"loaded-from-dataurl.js\"></script>', { baseURLForDataURL: `other://${path.join(fixtures, 'api')}${path.sep}` });\n      const [, test] = await answer;\n      expect(test).to.equal('test');\n    });\n  });\n\n  for (const sandbox of [false, true]) {\n    describe(`navigation events${sandbox ? ' with sandbox' : ''}`, () => {\n      let w = null as unknown as BrowserWindow;\n      beforeEach(() => {\n        w = new BrowserWindow({ show: false, webPreferences: { nodeIntegration: false, sandbox } });\n      });\n      afterEach(async () => {\n        await closeWindow(w);\n        w = null as unknown as BrowserWindow;\n      });\n\n      describe('will-navigate event', () => {\n        let server = null as unknown as http.Server;\n        let url = null as unknown as string;\n        before((done) => {\n          server = http.createServer((req, res) => {\n            if (req.url === '/navigate-top') {\n              res.end('<a target=_top href=\"/\">navigate _top</a>');\n            } else {\n              res.end('');\n            }\n          });\n          server.listen(0, '127.0.0.1', () => {\n            url = `http://127.0.0.1:${(server.address() as AddressInfo).port}/`;\n            done();\n          });\n        });\n\n        after(() => {\n          server.close();\n        });\n\n        it('allows the window to be closed from the event listener', (done) => {\n          w.webContents.once('will-navigate', () => {\n            w.close();\n            done();\n          });\n          w.loadFile(path.join(fixtures, 'pages', 'will-navigate.html'));\n        });\n\n        it('can be prevented', (done) => {\n          let willNavigate = false;\n          w.webContents.once('will-navigate', (e) => {\n            willNavigate = true;\n            e.preventDefault();\n          });\n          w.webContents.on('did-stop-loading', () => {\n            if (willNavigate) {\n              // i.e. it shouldn't have had '?navigated' appended to it.\n              try {\n                expect(w.webContents.getURL().endsWith('will-navigate.html')).to.be.true();\n                done();\n              } catch (e) {\n                done(e);\n              }\n            }\n          });\n          w.loadFile(path.join(fixtures, 'pages', 'will-navigate.html'));\n        });\n\n        it('is triggered when navigating from file: to http:', async () => {\n          await w.loadFile(path.join(fixtures, 'api', 'blank.html'));\n          w.webContents.executeJavaScript(`location.href = ${JSON.stringify(url)}`);\n          const navigatedTo = await new Promise(resolve => {\n            w.webContents.once('will-navigate', (e, url) => {\n              e.preventDefault();\n              resolve(url);\n            });\n          });\n          expect(navigatedTo).to.equal(url);\n          expect(w.webContents.getURL()).to.match(/^file:/);\n        });\n\n        it('is triggered when navigating from about:blank to http:', async () => {\n          await w.loadURL('about:blank');\n          w.webContents.executeJavaScript(`location.href = ${JSON.stringify(url)}`);\n          const navigatedTo = await new Promise(resolve => {\n            w.webContents.once('will-navigate', (e, url) => {\n              e.preventDefault();\n              resolve(url);\n            });\n          });\n          expect(navigatedTo).to.equal(url);\n          expect(w.webContents.getURL()).to.equal('about:blank');\n        });\n\n        it('is triggered when a cross-origin iframe navigates _top', async () => {\n          await w.loadURL(`data:text/html,<iframe src=\"http://127.0.0.1:${(server.address() as AddressInfo).port}/navigate-top\"></iframe>`);\n          await delay(1000);\n          w.webContents.debugger.attach('1.1');\n          const targets = await w.webContents.debugger.sendCommand('Target.getTargets');\n          const iframeTarget = targets.targetInfos.find((t: any) => t.type === 'iframe');\n          const { sessionId } = await w.webContents.debugger.sendCommand('Target.attachToTarget', {\n            targetId: iframeTarget.targetId,\n            flatten: true\n          });\n          await w.webContents.debugger.sendCommand('Input.dispatchMouseEvent', {\n            type: 'mousePressed',\n            x: 10,\n            y: 10,\n            clickCount: 1,\n            button: 'left'\n          }, sessionId);\n          await w.webContents.debugger.sendCommand('Input.dispatchMouseEvent', {\n            type: 'mouseReleased',\n            x: 10,\n            y: 10,\n            clickCount: 1,\n            button: 'left'\n          }, sessionId);\n          let willNavigateEmitted = false;\n          w.webContents.on('will-navigate', () => {\n            willNavigateEmitted = true;\n          });\n          await emittedOnce(w.webContents, 'did-navigate');\n          expect(willNavigateEmitted).to.be.true();\n        });\n      });\n\n      describe('will-redirect event', () => {\n        let server = null as unknown as http.Server;\n        let url = null as unknown as string;\n        before((done) => {\n          server = http.createServer((req, res) => {\n            if (req.url === '/302') {\n              res.setHeader('Location', '/200');\n              res.statusCode = 302;\n              res.end();\n            } else if (req.url === '/navigate-302') {\n              res.end(`<html><body><script>window.location='${url}/302'</script></body></html>`);\n            } else {\n              res.end();\n            }\n          });\n          server.listen(0, '127.0.0.1', () => {\n            url = `http://127.0.0.1:${(server.address() as AddressInfo).port}`;\n            done();\n          });\n        });\n\n        after(() => {\n          server.close();\n        });\n        it('is emitted on redirects', (done) => {\n          w.webContents.on('will-redirect', () => {\n            done();\n          });\n          w.loadURL(`${url}/302`);\n        });\n\n        it('is emitted after will-navigate on redirects', async () => {\n          let navigateCalled = false;\n          w.webContents.on('will-navigate', () => {\n            navigateCalled = true;\n          });\n          const willRedirect = emittedOnce(w.webContents, 'will-redirect');\n          w.loadURL(`${url}/navigate-302`);\n          await willRedirect;\n          expect(navigateCalled).to.equal(true, 'should have called will-navigate first');\n        });\n\n        it('is emitted before did-stop-loading on redirects', async () => {\n          let stopCalled = false;\n          w.webContents.on('did-stop-loading', () => {\n            stopCalled = true;\n          });\n          const willRedirect = emittedOnce(w.webContents, 'will-redirect');\n          w.loadURL(`${url}/302`);\n          await willRedirect;\n          expect(stopCalled).to.equal(false, 'should not have called did-stop-loading first');\n        });\n\n        it('allows the window to be closed from the event listener', (done) => {\n          w.webContents.once('will-redirect', () => {\n            w.close();\n            done();\n          });\n          w.loadURL(`${url}/302`);\n        });\n\n        it('can be prevented', (done) => {\n          w.webContents.once('will-redirect', (event) => {\n            event.preventDefault();\n          });\n          w.webContents.on('will-navigate', (e, u) => {\n            expect(u).to.equal(`${url}/302`);\n          });\n          w.webContents.on('did-stop-loading', () => {\n            try {\n              expect(w.webContents.getURL()).to.equal(\n                `${url}/navigate-302`,\n                'url should not have changed after navigation event'\n              );\n              done();\n            } catch (e) {\n              done(e);\n            }\n          });\n          w.webContents.on('will-redirect', (e, u) => {\n            try {\n              expect(u).to.equal(`${url}/200`);\n            } catch (e) {\n              done(e);\n            }\n          });\n          w.loadURL(`${url}/navigate-302`);\n        });\n      });\n    });\n  }\n\n  describe('focus and visibility', () => {\n    let w = null as unknown as BrowserWindow;\n    beforeEach(() => {\n      w = new BrowserWindow({ show: false });\n    });\n    afterEach(async () => {\n      await closeWindow(w);\n      w = null as unknown as BrowserWindow;\n    });\n\n    describe('BrowserWindow.show()', () => {\n      it('should focus on window', () => {\n        w.show();\n        expect(w.isFocused()).to.equal(true);\n      });\n      it('should make the window visible', () => {\n        w.show();\n        expect(w.isVisible()).to.equal(true);\n      });\n      it('emits when window is shown', async () => {\n        const show = emittedOnce(w, 'show');\n        w.show();\n        await show;\n        expect(w.isVisible()).to.equal(true);\n      });\n    });\n\n    describe('BrowserWindow.hide()', () => {\n      it('should defocus on window', () => {\n        w.hide();\n        expect(w.isFocused()).to.equal(false);\n      });\n      it('should make the window not visible', () => {\n        w.show();\n        w.hide();\n        expect(w.isVisible()).to.equal(false);\n      });\n      it('emits when window is hidden', async () => {\n        const shown = emittedOnce(w, 'show');\n        w.show();\n        await shown;\n        const hidden = emittedOnce(w, 'hide');\n        w.hide();\n        await hidden;\n        expect(w.isVisible()).to.equal(false);\n      });\n    });\n\n    describe('BrowserWindow.showInactive()', () => {\n      it('should not focus on window', () => {\n        w.showInactive();\n        expect(w.isFocused()).to.equal(false);\n      });\n    });\n\n    describe('BrowserWindow.focus()', () => {\n      it('does not make the window become visible', () => {\n        expect(w.isVisible()).to.equal(false);\n        w.focus();\n        expect(w.isVisible()).to.equal(false);\n      });\n    });\n\n    describe('BrowserWindow.blur()', () => {\n      it('removes focus from window', () => {\n        w.blur();\n        expect(w.isFocused()).to.equal(false);\n      });\n    });\n\n    describe('BrowserWindow.getFocusedWindow()', () => {\n      it('returns the opener window when dev tools window is focused', async () => {\n        w.show();\n        w.webContents.openDevTools({ mode: 'undocked' });\n        await emittedOnce(w.webContents, 'devtools-focused');\n        expect(BrowserWindow.getFocusedWindow()).to.equal(w);\n      });\n    });\n\n    describe('BrowserWindow.moveTop()', () => {\n      it('should not steal focus', async () => {\n        const posDelta = 50;\n        const wShownInactive = emittedOnce(w, 'show');\n        w.showInactive();\n        await wShownInactive;\n        expect(w.isFocused()).to.equal(false);\n\n        const otherWindow = new BrowserWindow({ show: false, title: 'otherWindow' });\n        const otherWindowShown = emittedOnce(otherWindow, 'show');\n        const otherWindowFocused = emittedOnce(otherWindow, 'focus');\n        otherWindow.show();\n        await otherWindowShown;\n        await otherWindowFocused;\n        expect(otherWindow.isFocused()).to.equal(true);\n\n        w.moveTop();\n        const wPos = w.getPosition();\n        const wMoving = emittedOnce(w, 'move');\n        w.setPosition(wPos[0] + posDelta, wPos[1] + posDelta);\n        await wMoving;\n        expect(w.isFocused()).to.equal(false);\n        expect(otherWindow.isFocused()).to.equal(true);\n\n        const wFocused = emittedOnce(w, 'focus');\n        w.focus();\n        await wFocused;\n        expect(w.isFocused()).to.equal(true);\n\n        otherWindow.moveTop();\n        const otherWindowPos = otherWindow.getPosition();\n        const otherWindowMoving = emittedOnce(otherWindow, 'move');\n        otherWindow.setPosition(otherWindowPos[0] + posDelta, otherWindowPos[1] + posDelta);\n        await otherWindowMoving;\n        expect(otherWindow.isFocused()).to.equal(false);\n        expect(w.isFocused()).to.equal(true);\n\n        await closeWindow(otherWindow, { assertNotWindows: false });\n        expect(BrowserWindow.getAllWindows()).to.have.lengthOf(1);\n      });\n    });\n\n    ifdescribe(features.isDesktopCapturerEnabled())('BrowserWindow.moveAbove(mediaSourceId)', () => {\n      it('should throw an exception if wrong formatting', async () => {\n        const fakeSourceIds = [\n          'none', 'screen:0', 'window:fake', 'window:1234', 'foobar:1:2'\n        ];\n        fakeSourceIds.forEach((sourceId) => {\n          expect(() => {\n            w.moveAbove(sourceId);\n          }).to.throw(/Invalid media source id/);\n        });\n      });\n\n      it('should throw an exception if wrong type', async () => {\n        const fakeSourceIds = [null as any, 123 as any];\n        fakeSourceIds.forEach((sourceId) => {\n          expect(() => {\n            w.moveAbove(sourceId);\n          }).to.throw(/Error processing argument at index 0 */);\n        });\n      });\n\n      it('should throw an exception if invalid window', async () => {\n        // It is very unlikely that these window id exist.\n        const fakeSourceIds = ['window:99999999:0', 'window:123456:1',\n          'window:123456:9'];\n        fakeSourceIds.forEach((sourceId) => {\n          expect(() => {\n            w.moveAbove(sourceId);\n          }).to.throw(/Invalid media source id/);\n        });\n      });\n\n      it('should not throw an exception', async () => {\n        const w2 = new BrowserWindow({ show: false, title: 'window2' });\n        const w2Shown = emittedOnce(w2, 'show');\n        w2.show();\n        await w2Shown;\n\n        expect(() => {\n          w.moveAbove(w2.getMediaSourceId());\n        }).to.not.throw();\n\n        await closeWindow(w2, { assertNotWindows: false });\n      });\n    });\n\n    describe('BrowserWindow.setFocusable()', () => {\n      it('can set unfocusable window to focusable', async () => {\n        const w2 = new BrowserWindow({ focusable: false });\n        const w2Focused = emittedOnce(w2, 'focus');\n        w2.setFocusable(true);\n        w2.focus();\n        await w2Focused;\n        await closeWindow(w2, { assertNotWindows: false });\n      });\n    });\n  });\n\n  describe('sizing', () => {\n    let w = null as unknown as BrowserWindow;\n\n    beforeEach(() => {\n      w = new BrowserWindow({ show: false, width: 400, height: 400 });\n    });\n\n    afterEach(async () => {\n      await closeWindow(w);\n      w = null as unknown as BrowserWindow;\n    });\n\n    describe('BrowserWindow.setBounds(bounds[, animate])', () => {\n      it('sets the window bounds with full bounds', () => {\n        const fullBounds = { x: 440, y: 225, width: 500, height: 400 };\n        w.setBounds(fullBounds);\n\n        expectBoundsEqual(w.getBounds(), fullBounds);\n      });\n\n      it('sets the window bounds with partial bounds', () => {\n        const fullBounds = { x: 440, y: 225, width: 500, height: 400 };\n        w.setBounds(fullBounds);\n\n        const boundsUpdate = { width: 200 };\n        w.setBounds(boundsUpdate as any);\n\n        const expectedBounds = Object.assign(fullBounds, boundsUpdate);\n        expectBoundsEqual(w.getBounds(), expectedBounds);\n      });\n    });\n\n    describe('BrowserWindow.setSize(width, height)', () => {\n      it('sets the window size', async () => {\n        const size = [300, 400];\n\n        const resized = emittedOnce(w, 'resize');\n        w.setSize(size[0], size[1]);\n        await resized;\n\n        expectBoundsEqual(w.getSize(), size);\n      });\n    });\n\n    describe('BrowserWindow.setMinimum/MaximumSize(width, height)', () => {\n      it('sets the maximum and minimum size of the window', () => {\n        expect(w.getMinimumSize()).to.deep.equal([0, 0]);\n        expect(w.getMaximumSize()).to.deep.equal([0, 0]);\n\n        w.setMinimumSize(100, 100);\n        expectBoundsEqual(w.getMinimumSize(), [100, 100]);\n        expectBoundsEqual(w.getMaximumSize(), [0, 0]);\n\n        w.setMaximumSize(900, 600);\n        expectBoundsEqual(w.getMinimumSize(), [100, 100]);\n        expectBoundsEqual(w.getMaximumSize(), [900, 600]);\n      });\n    });\n\n    describe('BrowserWindow.setAspectRatio(ratio)', () => {\n      it('resets the behaviour when passing in 0', async () => {\n        const size = [300, 400];\n        w.setAspectRatio(1 / 2);\n        w.setAspectRatio(0);\n        const resize = emittedOnce(w, 'resize');\n        w.setSize(size[0], size[1]);\n        await resize;\n        expectBoundsEqual(w.getSize(), size);\n      });\n    });\n\n    describe('BrowserWindow.setPosition(x, y)', () => {\n      it('sets the window position', async () => {\n        const pos = [10, 10];\n        const move = emittedOnce(w, 'move');\n        w.setPosition(pos[0], pos[1]);\n        await move;\n        expect(w.getPosition()).to.deep.equal(pos);\n      });\n    });\n\n    describe('BrowserWindow.setContentSize(width, height)', () => {\n      it('sets the content size', async () => {\n        // NB. The CI server has a very small screen. Attempting to size the window\n        // larger than the screen will limit the window's size to the screen and\n        // cause the test to fail.\n        const size = [456, 567];\n        w.setContentSize(size[0], size[1]);\n        await new Promise(setImmediate);\n        const after = w.getContentSize();\n        expect(after).to.deep.equal(size);\n      });\n\n      it('works for a frameless window', async () => {\n        w.destroy();\n        w = new BrowserWindow({\n          show: false,\n          frame: false,\n          width: 400,\n          height: 400\n        });\n        const size = [456, 567];\n        w.setContentSize(size[0], size[1]);\n        await new Promise(setImmediate);\n        const after = w.getContentSize();\n        expect(after).to.deep.equal(size);\n      });\n    });\n\n    describe('BrowserWindow.setContentBounds(bounds)', () => {\n      it('sets the content size and position', async () => {\n        const bounds = { x: 10, y: 10, width: 250, height: 250 };\n        const resize = emittedOnce(w, 'resize');\n        w.setContentBounds(bounds);\n        await resize;\n        await delay();\n        expectBoundsEqual(w.getContentBounds(), bounds);\n      });\n      it('works for a frameless window', async () => {\n        w.destroy();\n        w = new BrowserWindow({\n          show: false,\n          frame: false,\n          width: 300,\n          height: 300\n        });\n        const bounds = { x: 10, y: 10, width: 250, height: 250 };\n        const resize = emittedOnce(w, 'resize');\n        w.setContentBounds(bounds);\n        await resize;\n        await delay();\n        expectBoundsEqual(w.getContentBounds(), bounds);\n      });\n    });\n\n    describe('BrowserWindow.getBackgroundColor()', () => {\n      it('returns default value if no backgroundColor is set', () => {\n        w.destroy();\n        w = new BrowserWindow({});\n        expect(w.getBackgroundColor()).to.equal('#FFFFFF');\n      });\n      it('returns correct value if backgroundColor is set', () => {\n        const backgroundColor = '#BBAAFF';\n        w.destroy();\n        w = new BrowserWindow({\n          backgroundColor: backgroundColor\n        });\n        expect(w.getBackgroundColor()).to.equal(backgroundColor);\n      });\n      it('returns correct value from setBackgroundColor()', () => {\n        const backgroundColor = '#AABBFF';\n        w.destroy();\n        w = new BrowserWindow({});\n        w.setBackgroundColor(backgroundColor);\n        expect(w.getBackgroundColor()).to.equal(backgroundColor);\n      });\n    });\n\n    describe('BrowserWindow.getNormalBounds()', () => {\n      describe('Normal state', () => {\n        it('checks normal bounds after resize', async () => {\n          const size = [300, 400];\n          const resize = emittedOnce(w, 'resize');\n          w.setSize(size[0], size[1]);\n          await resize;\n          expectBoundsEqual(w.getNormalBounds(), w.getBounds());\n        });\n        it('checks normal bounds after move', async () => {\n          const pos = [10, 10];\n          const move = emittedOnce(w, 'move');\n          w.setPosition(pos[0], pos[1]);\n          await move;\n          expectBoundsEqual(w.getNormalBounds(), w.getBounds());\n        });\n      });\n\n      ifdescribe(process.platform !== 'linux')('Maximized state', () => {\n        it('checks normal bounds when maximized', async () => {\n          const bounds = w.getBounds();\n          const maximize = emittedOnce(w, 'maximize');\n          w.show();\n          w.maximize();\n          await maximize;\n          expectBoundsEqual(w.getNormalBounds(), bounds);\n        });\n        it('checks normal bounds when unmaximized', async () => {\n          const bounds = w.getBounds();\n          w.once('maximize', () => {\n            w.unmaximize();\n          });\n          const unmaximize = emittedOnce(w, 'unmaximize');\n          w.show();\n          w.maximize();\n          await unmaximize;\n          expectBoundsEqual(w.getNormalBounds(), bounds);\n        });\n      });\n\n      ifdescribe(process.platform !== 'linux')('Minimized state', () => {\n        it('checks normal bounds when minimized', async () => {\n          const bounds = w.getBounds();\n          const minimize = emittedOnce(w, 'minimize');\n          w.show();\n          w.minimize();\n          await minimize;\n          expectBoundsEqual(w.getNormalBounds(), bounds);\n        });\n        it('checks normal bounds when restored', async () => {\n          const bounds = w.getBounds();\n          w.once('minimize', () => {\n            w.restore();\n          });\n          const restore = emittedOnce(w, 'restore');\n          w.show();\n          w.minimize();\n          await restore;\n          expectBoundsEqual(w.getNormalBounds(), bounds);\n        });\n        it('does not change size for a frameless window with min size', async () => {\n          w.destroy();\n          w = new BrowserWindow({\n            show: false,\n            frame: false,\n            width: 300,\n            height: 300,\n            minWidth: 300,\n            minHeight: 300\n          });\n          const bounds = w.getBounds();\n          w.once('minimize', () => {\n            w.restore();\n          });\n          const restore = emittedOnce(w, 'restore');\n          w.show();\n          w.minimize();\n          await restore;\n          expectBoundsEqual(w.getNormalBounds(), bounds);\n        });\n      });\n\n      ifdescribe(process.platform === 'win32')(`Fullscreen state`, () => {\n        it('with properties', () => {\n          it('can be set with the fullscreen constructor option', () => {\n            w = new BrowserWindow({ fullscreen: true });\n            expect(w.fullScreen).to.be.true();\n          });\n\n          it('can be changed', () => {\n            w.fullScreen = false;\n            expect(w.fullScreen).to.be.false();\n            w.fullScreen = true;\n            expect(w.fullScreen).to.be.true();\n          });\n\n          it(`checks normal bounds when fullscreen'ed`, async () => {\n            const bounds = w.getBounds();\n            const enterFullScreen = emittedOnce(w, 'enter-full-screen');\n            w.show();\n            w.fullScreen = true;\n            await enterFullScreen;\n            expectBoundsEqual(w.getNormalBounds(), bounds);\n          });\n\n          it(`checks normal bounds when unfullscreen'ed`, async () => {\n            const bounds = w.getBounds();\n            w.once('enter-full-screen', () => {\n              w.fullScreen = false;\n            });\n            const leaveFullScreen = emittedOnce(w, 'leave-full-screen');\n            w.show();\n            w.fullScreen = true;\n            await leaveFullScreen;\n            expectBoundsEqual(w.getNormalBounds(), bounds);\n          });\n        });\n\n        it('with functions', () => {\n          it('can be set with the fullscreen constructor option', () => {\n            w = new BrowserWindow({ fullscreen: true });\n            expect(w.isFullScreen()).to.be.true();\n          });\n\n          it('can be changed', () => {\n            w.setFullScreen(false);\n            expect(w.isFullScreen()).to.be.false();\n            w.setFullScreen(true);\n            expect(w.isFullScreen()).to.be.true();\n          });\n\n          it(`checks normal bounds when fullscreen'ed`, async () => {\n            const bounds = w.getBounds();\n            w.show();\n\n            const enterFullScreen = emittedOnce(w, 'enter-full-screen');\n            w.setFullScreen(true);\n            await enterFullScreen;\n\n            expectBoundsEqual(w.getNormalBounds(), bounds);\n          });\n\n          it(`checks normal bounds when unfullscreen'ed`, async () => {\n            const bounds = w.getBounds();\n            w.show();\n\n            const enterFullScreen = emittedOnce(w, 'enter-full-screen');\n            w.setFullScreen(true);\n            await enterFullScreen;\n\n            const leaveFullScreen = emittedOnce(w, 'leave-full-screen');\n            w.setFullScreen(false);\n            await leaveFullScreen;\n\n            expectBoundsEqual(w.getNormalBounds(), bounds);\n          });\n        });\n      });\n    });\n  });\n\n  ifdescribe(process.platform === 'darwin')('tabbed windows', () => {\n    let w = null as unknown as BrowserWindow;\n    beforeEach(() => {\n      w = new BrowserWindow({ show: false });\n    });\n    afterEach(async () => {\n      await closeWindow(w);\n      w = null as unknown as BrowserWindow;\n    });\n\n    describe('BrowserWindow.selectPreviousTab()', () => {\n      it('does not throw', () => {\n        expect(() => {\n          w.selectPreviousTab();\n        }).to.not.throw();\n      });\n    });\n\n    describe('BrowserWindow.selectNextTab()', () => {\n      it('does not throw', () => {\n        expect(() => {\n          w.selectNextTab();\n        }).to.not.throw();\n      });\n    });\n\n    describe('BrowserWindow.mergeAllWindows()', () => {\n      it('does not throw', () => {\n        expect(() => {\n          w.mergeAllWindows();\n        }).to.not.throw();\n      });\n    });\n\n    describe('BrowserWindow.moveTabToNewWindow()', () => {\n      it('does not throw', () => {\n        expect(() => {\n          w.moveTabToNewWindow();\n        }).to.not.throw();\n      });\n    });\n\n    describe('BrowserWindow.toggleTabBar()', () => {\n      it('does not throw', () => {\n        expect(() => {\n          w.toggleTabBar();\n        }).to.not.throw();\n      });\n    });\n\n    describe('BrowserWindow.addTabbedWindow()', () => {\n      it('does not throw', async () => {\n        const tabbedWindow = new BrowserWindow({});\n        expect(() => {\n          w.addTabbedWindow(tabbedWindow);\n        }).to.not.throw();\n\n        expect(BrowserWindow.getAllWindows()).to.have.lengthOf(2); // w + tabbedWindow\n\n        await closeWindow(tabbedWindow, { assertNotWindows: false });\n        expect(BrowserWindow.getAllWindows()).to.have.lengthOf(1); // w\n      });\n\n      it('throws when called on itself', () => {\n        expect(() => {\n          w.addTabbedWindow(w);\n        }).to.throw('AddTabbedWindow cannot be called by a window on itself.');\n      });\n    });\n  });\n\n  describe('autoHideMenuBar state', () => {\n    afterEach(closeAllWindows);\n\n    it('for properties', () => {\n      it('can be set with autoHideMenuBar constructor option', () => {\n        const w = new BrowserWindow({ show: false, autoHideMenuBar: true });\n        expect(w.autoHideMenuBar).to.be.true('autoHideMenuBar');\n      });\n\n      it('can be changed', () => {\n        const w = new BrowserWindow({ show: false });\n        expect(w.autoHideMenuBar).to.be.false('autoHideMenuBar');\n        w.autoHideMenuBar = true;\n        expect(w.autoHideMenuBar).to.be.true('autoHideMenuBar');\n        w.autoHideMenuBar = false;\n        expect(w.autoHideMenuBar).to.be.false('autoHideMenuBar');\n      });\n    });\n\n    it('for functions', () => {\n      it('can be set with autoHideMenuBar constructor option', () => {\n        const w = new BrowserWindow({ show: false, autoHideMenuBar: true });\n        expect(w.isMenuBarAutoHide()).to.be.true('autoHideMenuBar');\n      });\n\n      it('can be changed', () => {\n        const w = new BrowserWindow({ show: false });\n        expect(w.isMenuBarAutoHide()).to.be.false('autoHideMenuBar');\n        w.setAutoHideMenuBar(true);\n        expect(w.isMenuBarAutoHide()).to.be.true('autoHideMenuBar');\n        w.setAutoHideMenuBar(false);\n        expect(w.isMenuBarAutoHide()).to.be.false('autoHideMenuBar');\n      });\n    });\n  });\n\n  describe('BrowserWindow.capturePage(rect)', () => {\n    afterEach(closeAllWindows);\n\n    it('returns a Promise with a Buffer', async () => {\n      const w = new BrowserWindow({ show: false });\n      const image = await w.capturePage({\n        x: 0,\n        y: 0,\n        width: 100,\n        height: 100\n      });\n\n      expect(image.isEmpty()).to.equal(true);\n    });\n\n    it('preserves transparency', async () => {\n      const w = new BrowserWindow({ show: false, transparent: true });\n      w.loadURL('about:blank');\n      await emittedOnce(w, 'ready-to-show');\n      w.show();\n\n      const image = await w.capturePage();\n      const imgBuffer = image.toPNG();\n\n      // Check the 25th byte in the PNG.\n      // Values can be 0,2,3,4, or 6. We want 6, which is RGB + Alpha\n      expect(imgBuffer[25]).to.equal(6);\n    });\n  });\n\n  describe('BrowserWindow.setProgressBar(progress)', () => {\n    let w = null as unknown as BrowserWindow;\n    before(() => {\n      w = new BrowserWindow({ show: false });\n    });\n    after(async () => {\n      await closeWindow(w);\n      w = null as unknown as BrowserWindow;\n    });\n    it('sets the progress', () => {\n      expect(() => {\n        if (process.platform === 'darwin') {\n          app.dock.setIcon(path.join(fixtures, 'assets', 'logo.png'));\n        }\n        w.setProgressBar(0.5);\n\n        if (process.platform === 'darwin') {\n          app.dock.setIcon(null as any);\n        }\n        w.setProgressBar(-1);\n      }).to.not.throw();\n    });\n    it('sets the progress using \"paused\" mode', () => {\n      expect(() => {\n        w.setProgressBar(0.5, { mode: 'paused' });\n      }).to.not.throw();\n    });\n    it('sets the progress using \"error\" mode', () => {\n      expect(() => {\n        w.setProgressBar(0.5, { mode: 'error' });\n      }).to.not.throw();\n    });\n    it('sets the progress using \"normal\" mode', () => {\n      expect(() => {\n        w.setProgressBar(0.5, { mode: 'normal' });\n      }).to.not.throw();\n    });\n  });\n\n  describe('BrowserWindow.setAlwaysOnTop(flag, level)', () => {\n    let w = null as unknown as BrowserWindow;\n\n    beforeEach(() => {\n      w = new BrowserWindow({ show: false });\n    });\n\n    afterEach(async () => {\n      await closeWindow(w);\n      w = null as unknown as BrowserWindow;\n    });\n\n    it('sets the window as always on top', () => {\n      expect(w.isAlwaysOnTop()).to.be.false('is alwaysOnTop');\n      w.setAlwaysOnTop(true, 'screen-saver');\n      expect(w.isAlwaysOnTop()).to.be.true('is not alwaysOnTop');\n      w.setAlwaysOnTop(false);\n      expect(w.isAlwaysOnTop()).to.be.false('is alwaysOnTop');\n      w.setAlwaysOnTop(true);\n      expect(w.isAlwaysOnTop()).to.be.true('is not alwaysOnTop');\n    });\n\n    ifit(process.platform === 'darwin')('resets the windows level on minimize', () => {\n      expect(w.isAlwaysOnTop()).to.be.false('is alwaysOnTop');\n      w.setAlwaysOnTop(true, 'screen-saver');\n      expect(w.isAlwaysOnTop()).to.be.true('is not alwaysOnTop');\n      w.minimize();\n      expect(w.isAlwaysOnTop()).to.be.false('is alwaysOnTop');\n      w.restore();\n      expect(w.isAlwaysOnTop()).to.be.true('is not alwaysOnTop');\n    });\n\n    it('causes the right value to be emitted on `always-on-top-changed`', async () => {\n      const alwaysOnTopChanged = emittedOnce(w, 'always-on-top-changed');\n      expect(w.isAlwaysOnTop()).to.be.false('is alwaysOnTop');\n      w.setAlwaysOnTop(true);\n      const [, alwaysOnTop] = await alwaysOnTopChanged;\n      expect(alwaysOnTop).to.be.true('is not alwaysOnTop');\n    });\n  });\n\n  describe('preconnect feature', () => {\n    let w = null as unknown as BrowserWindow;\n\n    let server = null as unknown as http.Server;\n    let url = null as unknown as string;\n    let connections = 0;\n\n    beforeEach(async () => {\n      connections = 0;\n      server = http.createServer((req, res) => {\n        if (req.url === '/link') {\n          res.setHeader('Content-type', 'text/html');\n          res.end('<head><link rel=\"preconnect\" href=\"//example.com\" /></head><body>foo</body>');\n          return;\n        }\n        res.end();\n      });\n      server.on('connection', () => { connections++; });\n\n      await new Promise(resolve => server.listen(0, '127.0.0.1', () => resolve()));\n      url = `http://127.0.0.1:${(server.address() as AddressInfo).port}`;\n    });\n    afterEach(async () => {\n      server.close();\n      await closeWindow(w);\n      w = null as unknown as BrowserWindow;\n      server = null as unknown as http.Server;\n    });\n\n    it('calling preconnect() connects to the server', async () => {\n      w = new BrowserWindow({ show: false });\n      w.webContents.on('did-start-navigation', (event, url) => {\n        w.webContents.session.preconnect({ url, numSockets: 4 });\n      });\n      await w.loadURL(url);\n      expect(connections).to.equal(4);\n    });\n\n    it('does not preconnect unless requested', async () => {\n      w = new BrowserWindow({ show: false });\n      await w.loadURL(url);\n      expect(connections).to.equal(1);\n    });\n\n    it('parses <link rel=preconnect>', async () => {\n      w = new BrowserWindow({ show: true });\n      const p = emittedOnce(w.webContents.session, 'preconnect');\n      w.loadURL(url + '/link');\n      const [, preconnectUrl, allowCredentials] = await p;\n      expect(preconnectUrl).to.equal('http://example.com/');\n      expect(allowCredentials).to.be.true('allowCredentials');\n    });\n  });\n\n  describe('BrowserWindow.setAutoHideCursor(autoHide)', () => {\n    let w = null as unknown as BrowserWindow;\n    beforeEach(() => {\n      w = new BrowserWindow({ show: false });\n    });\n    afterEach(async () => {\n      await closeWindow(w);\n      w = null as unknown as BrowserWindow;\n    });\n\n    ifit(process.platform === 'darwin')('on macOS', () => {\n      it('allows changing cursor auto-hiding', () => {\n        expect(() => {\n          w.setAutoHideCursor(false);\n          w.setAutoHideCursor(true);\n        }).to.not.throw();\n      });\n    });\n\n    ifit(process.platform !== 'darwin')('on non-macOS platforms', () => {\n      it('is not available', () => {\n        expect(w.setAutoHideCursor).to.be.undefined('setAutoHideCursor function');\n      });\n    });\n  });\n\n  ifdescribe(process.platform === 'darwin')('BrowserWindow.setWindowButtonVisibility()', () => {\n    afterEach(closeAllWindows);\n\n    it('does not throw', () => {\n      const w = new BrowserWindow({ show: false });\n      expect(() => {\n        w.setWindowButtonVisibility(true);\n        w.setWindowButtonVisibility(false);\n      }).to.not.throw();\n    });\n\n    it('throws with custom title bar buttons', () => {\n      expect(() => {\n        const w = new BrowserWindow({\n          show: false,\n          titleBarStyle: 'customButtonsOnHover',\n          frame: false\n        });\n        w.setWindowButtonVisibility(true);\n      }).to.throw('Not supported for this window');\n    });\n  });\n\n  ifdescribe(process.platform === 'darwin')('BrowserWindow.setVibrancy(type)', () => {\n    afterEach(closeAllWindows);\n\n    it('allows setting, changing, and removing the vibrancy', () => {\n      const w = new BrowserWindow({ show: false });\n      expect(() => {\n        w.setVibrancy('light');\n        w.setVibrancy('dark');\n        w.setVibrancy(null);\n        w.setVibrancy('ultra-dark');\n        w.setVibrancy('' as any);\n      }).to.not.throw();\n    });\n  });\n\n  ifdescribe(process.platform === 'darwin')('BrowserWindow.getTrafficLightPosition(pos)', () => {\n    afterEach(closeAllWindows);\n\n    it('gets the set traffic light position property', () => {\n      const pos = { x: 10, y: 10 };\n      const w = new BrowserWindow({ show: false, titleBarStyle: 'hidden', trafficLightPosition: pos });\n      const currentPosition = w.getTrafficLightPosition();\n\n      expect(currentPosition).to.deep.equal(pos);\n    });\n  });\n\n  ifdescribe(process.platform === 'darwin')('BrowserWindow.setTrafficLightPosition(pos)', () => {\n    afterEach(closeAllWindows);\n\n    it('can set the traffic light position property', () => {\n      const pos = { x: 10, y: 10 };\n      const w = new BrowserWindow({ show: false, titleBarStyle: 'hidden', trafficLightPosition: pos });\n      w.setTrafficLightPosition(pos);\n      const currentPosition = w.getTrafficLightPosition();\n\n      expect(currentPosition).to.deep.equal(pos);\n    });\n  });\n\n  ifdescribe(process.platform === 'win32')('BrowserWindow.setAppDetails(options)', () => {\n    afterEach(closeAllWindows);\n\n    it('supports setting the app details', () => {\n      const w = new BrowserWindow({ show: false });\n      const iconPath = path.join(fixtures, 'assets', 'icon.ico');\n\n      expect(() => {\n        w.setAppDetails({ appId: 'my.app.id' });\n        w.setAppDetails({ appIconPath: iconPath, appIconIndex: 0 });\n        w.setAppDetails({ appIconPath: iconPath });\n        w.setAppDetails({ relaunchCommand: 'my-app.exe arg1 arg2', relaunchDisplayName: 'My app name' });\n        w.setAppDetails({ relaunchCommand: 'my-app.exe arg1 arg2' });\n        w.setAppDetails({ relaunchDisplayName: 'My app name' });\n        w.setAppDetails({\n          appId: 'my.app.id',\n          appIconPath: iconPath,\n          appIconIndex: 0,\n          relaunchCommand: 'my-app.exe arg1 arg2',\n          relaunchDisplayName: 'My app name'\n        });\n        w.setAppDetails({});\n      }).to.not.throw();\n\n      expect(() => {\n        (w.setAppDetails as any)();\n      }).to.throw('Insufficient number of arguments.');\n    });\n  });\n\n  describe('BrowserWindow.fromId(id)', () => {\n    afterEach(closeAllWindows);\n    it('returns the window with id', () => {\n      const w = new BrowserWindow({ show: false });\n      expect(BrowserWindow.fromId(w.id).id).to.equal(w.id);\n    });\n  });\n\n  describe('BrowserWindow.fromWebContents(webContents)', () => {\n    afterEach(closeAllWindows);\n\n    it('returns the window with the webContents', () => {\n      const w = new BrowserWindow({ show: false });\n      const found = BrowserWindow.fromWebContents(w.webContents);\n      expect(found!.id).to.equal(w.id);\n    });\n\n    it('returns null for webContents without a BrowserWindow', () => {\n      const contents = (webContents as any).create({});\n      try {\n        expect(BrowserWindow.fromWebContents(contents)).to.be.null('BrowserWindow.fromWebContents(contents)');\n      } finally {\n        contents.destroy();\n      }\n    });\n  });\n\n  describe('BrowserWindow.openDevTools()', () => {\n    afterEach(closeAllWindows);\n    it('does not crash for frameless window', () => {\n      const w = new BrowserWindow({ show: false, frame: false });\n      w.webContents.openDevTools();\n    });\n  });\n\n  describe('BrowserWindow.fromBrowserView(browserView)', () => {\n    afterEach(closeAllWindows);\n\n    it('returns the window with the browserView', () => {\n      const w = new BrowserWindow({ show: false });\n      const bv = new BrowserView();\n      w.setBrowserView(bv);\n      expect(BrowserWindow.fromBrowserView(bv)!.id).to.equal(w.id);\n      // if BrowserView isn't explicitly destroyed, it will crash in GC later\n      bv.destroy();\n    });\n\n    it('returns undefined if not attached', () => {\n      const bv = new BrowserView();\n      expect(BrowserWindow.fromBrowserView(bv)).to.be.null('BrowserWindow associated with bv');\n      // if BrowserView isn't explicitly destroyed, it will crash in GC later\n      bv.destroy();\n    });\n  });\n\n  describe('BrowserWindow.setOpacity(opacity)', () => {\n    afterEach(closeAllWindows);\n\n    ifdescribe(process.platform !== 'linux')(('Windows and Mac'), () => {\n      it('make window with initial opacity', () => {\n        const w = new BrowserWindow({ show: false, opacity: 0.5 });\n        expect(w.getOpacity()).to.equal(0.5);\n      });\n      it('allows setting the opacity', () => {\n        const w = new BrowserWindow({ show: false });\n        expect(() => {\n          w.setOpacity(0.0);\n          expect(w.getOpacity()).to.equal(0.0);\n          w.setOpacity(0.5);\n          expect(w.getOpacity()).to.equal(0.5);\n          w.setOpacity(1.0);\n          expect(w.getOpacity()).to.equal(1.0);\n        }).to.not.throw();\n      });\n\n      it('clamps opacity to [0.0...1.0]', () => {\n        const w = new BrowserWindow({ show: false, opacity: 0.5 });\n        w.setOpacity(100);\n        expect(w.getOpacity()).to.equal(1.0);\n        w.setOpacity(-100);\n        expect(w.getOpacity()).to.equal(0.0);\n      });\n    });\n\n    ifdescribe(process.platform === 'linux')(('Linux'), () => {\n      it('sets 1 regardless of parameter', () => {\n        const w = new BrowserWindow({ show: false });\n        w.setOpacity(0);\n        expect(w.getOpacity()).to.equal(1.0);\n        w.setOpacity(0.5);\n        expect(w.getOpacity()).to.equal(1.0);\n      });\n    });\n  });\n\n  describe('BrowserWindow.setShape(rects)', () => {\n    afterEach(closeAllWindows);\n    it('allows setting shape', () => {\n      const w = new BrowserWindow({ show: false });\n      expect(() => {\n        w.setShape([]);\n        w.setShape([{ x: 0, y: 0, width: 100, height: 100 }]);\n        w.setShape([{ x: 0, y: 0, width: 100, height: 100 }, { x: 0, y: 200, width: 1000, height: 100 }]);\n        w.setShape([]);\n      }).to.not.throw();\n    });\n  });\n\n  describe('\"useContentSize\" option', () => {\n    afterEach(closeAllWindows);\n    it('make window created with content size when used', () => {\n      const w = new BrowserWindow({\n        show: false,\n        width: 400,\n        height: 400,\n        useContentSize: true\n      });\n      const contentSize = w.getContentSize();\n      expect(contentSize).to.deep.equal([400, 400]);\n    });\n    it('make window created with window size when not used', () => {\n      const w = new BrowserWindow({\n        show: false,\n        width: 400,\n        height: 400\n      });\n      const size = w.getSize();\n      expect(size).to.deep.equal([400, 400]);\n    });\n    it('works for a frameless window', () => {\n      const w = new BrowserWindow({\n        show: false,\n        frame: false,\n        width: 400,\n        height: 400,\n        useContentSize: true\n      });\n      const contentSize = w.getContentSize();\n      expect(contentSize).to.deep.equal([400, 400]);\n      const size = w.getSize();\n      expect(size).to.deep.equal([400, 400]);\n    });\n  });\n\n  ifdescribe(process.platform === 'darwin' && parseInt(os.release().split('.')[0]) >= 14)('\"titleBarStyle\" option', () => {\n    afterEach(closeAllWindows);\n    it('creates browser window with hidden title bar', () => {\n      const w = new BrowserWindow({\n        show: false,\n        width: 400,\n        height: 400,\n        titleBarStyle: 'hidden'\n      });\n      const contentSize = w.getContentSize();\n      expect(contentSize).to.deep.equal([400, 400]);\n    });\n    it('creates browser window with hidden inset title bar', () => {\n      const w = new BrowserWindow({\n        show: false,\n        width: 400,\n        height: 400,\n        titleBarStyle: 'hiddenInset'\n      });\n      const contentSize = w.getContentSize();\n      expect(contentSize).to.deep.equal([400, 400]);\n    });\n  });\n\n  ifdescribe(process.platform === 'darwin')('\"enableLargerThanScreen\" option', () => {\n    afterEach(closeAllWindows);\n    it('can move the window out of screen', () => {\n      const w = new BrowserWindow({ show: true, enableLargerThanScreen: true });\n      w.setPosition(-10, 50);\n      const after = w.getPosition();\n      expect(after).to.deep.equal([-10, 50]);\n    });\n    it('cannot move the window behind menu bar', () => {\n      const w = new BrowserWindow({ show: true, enableLargerThanScreen: true });\n      w.setPosition(-10, -10);\n      const after = w.getPosition();\n      expect(after[1]).to.be.at.least(0);\n    });\n    it('can move the window behind menu bar if it has no frame', () => {\n      const w = new BrowserWindow({ show: true, enableLargerThanScreen: true, frame: false });\n      w.setPosition(-10, -10);\n      const after = w.getPosition();\n      expect(after[0]).to.be.equal(-10);\n      expect(after[1]).to.be.equal(-10);\n    });\n    it('without it, cannot move the window out of screen', () => {\n      const w = new BrowserWindow({ show: true, enableLargerThanScreen: false });\n      w.setPosition(-10, -10);\n      const after = w.getPosition();\n      expect(after[1]).to.be.at.least(0);\n    });\n    it('can set the window larger than screen', () => {\n      const w = new BrowserWindow({ show: true, enableLargerThanScreen: true });\n      const size = screen.getPrimaryDisplay().size;\n      size.width += 100;\n      size.height += 100;\n      w.setSize(size.width, size.height);\n      expectBoundsEqual(w.getSize(), [size.width, size.height]);\n    });\n    it('without it, cannot set the window larger than screen', () => {\n      const w = new BrowserWindow({ show: true, enableLargerThanScreen: false });\n      const size = screen.getPrimaryDisplay().size;\n      size.width += 100;\n      size.height += 100;\n      w.setSize(size.width, size.height);\n      expect(w.getSize()[1]).to.at.most(screen.getPrimaryDisplay().size.height);\n    });\n  });\n\n  ifdescribe(process.platform === 'darwin')('\"zoomToPageWidth\" option', () => {\n    afterEach(closeAllWindows);\n    it('sets the window width to the page width when used', () => {\n      const w = new BrowserWindow({\n        show: false,\n        width: 500,\n        height: 400,\n        zoomToPageWidth: true\n      });\n      w.maximize();\n      expect(w.getSize()[0]).to.equal(500);\n    });\n  });\n\n  describe('\"tabbingIdentifier\" option', () => {\n    afterEach(closeAllWindows);\n    it('can be set on a window', () => {\n      expect(() => {\n        /* eslint-disable no-new */\n        new BrowserWindow({\n          tabbingIdentifier: 'group1'\n        });\n        new BrowserWindow({\n          tabbingIdentifier: 'group2',\n          frame: false\n        });\n        /* eslint-enable no-new */\n      }).not.to.throw();\n    });\n  });\n\n  describe('\"webPreferences\" option', () => {\n    afterEach(() => { ipcMain.removeAllListeners('answer'); });\n    afterEach(closeAllWindows);\n\n    describe('\"preload\" option', () => {\n      const doesNotLeakSpec = (name: string, webPrefs: { nodeIntegration: boolean, sandbox: boolean, contextIsolation: boolean }) => {\n        it(name, async () => {\n          const w = new BrowserWindow({\n            webPreferences: {\n              ...webPrefs,\n              preload: path.resolve(fixtures, 'module', 'empty.js')\n            },\n            show: false\n          });\n          w.loadFile(path.join(fixtures, 'api', 'no-leak.html'));\n          const [, result] = await emittedOnce(ipcMain, 'leak-result');\n          expect(result).to.have.property('require', 'undefined');\n          expect(result).to.have.property('exports', 'undefined');\n          expect(result).to.have.property('windowExports', 'undefined');\n          expect(result).to.have.property('windowPreload', 'undefined');\n          expect(result).to.have.property('windowRequire', 'undefined');\n        });\n      };\n      doesNotLeakSpec('does not leak require', {\n        nodeIntegration: false,\n        sandbox: false,\n        contextIsolation: false\n      });\n      doesNotLeakSpec('does not leak require when sandbox is enabled', {\n        nodeIntegration: false,\n        sandbox: true,\n        contextIsolation: false\n      });\n      doesNotLeakSpec('does not leak require when context isolation is enabled', {\n        nodeIntegration: false,\n        sandbox: false,\n        contextIsolation: true\n      });\n      doesNotLeakSpec('does not leak require when context isolation and sandbox are enabled', {\n        nodeIntegration: false,\n        sandbox: true,\n        contextIsolation: true\n      });\n      it('does not leak any node globals on the window object with nodeIntegration is disabled', async () => {\n        let w = new BrowserWindow({\n          webPreferences: {\n            contextIsolation: false,\n            nodeIntegration: false,\n            preload: path.resolve(fixtures, 'module', 'empty.js')\n          },\n          show: false\n        });\n        w.loadFile(path.join(fixtures, 'api', 'globals.html'));\n        const [, notIsolated] = await emittedOnce(ipcMain, 'leak-result');\n        expect(notIsolated).to.have.property('globals');\n\n        w.destroy();\n        w = new BrowserWindow({\n          webPreferences: {\n            contextIsolation: true,\n            nodeIntegration: false,\n            preload: path.resolve(fixtures, 'module', 'empty.js')\n          },\n          show: false\n        });\n        w.loadFile(path.join(fixtures, 'api', 'globals.html'));\n        const [, isolated] = await emittedOnce(ipcMain, 'leak-result');\n        expect(isolated).to.have.property('globals');\n        const notIsolatedGlobals = new Set(notIsolated.globals);\n        for (const isolatedGlobal of isolated.globals) {\n          notIsolatedGlobals.delete(isolatedGlobal);\n        }\n        expect([...notIsolatedGlobals]).to.deep.equal([], 'non-isoalted renderer should have no additional globals');\n      });\n\n      it('loads the script before other scripts in window', async () => {\n        const preload = path.join(fixtures, 'module', 'set-global.js');\n        const w = new BrowserWindow({\n          show: false,\n          webPreferences: {\n            nodeIntegration: true,\n            preload\n          }\n        });\n        w.loadFile(path.join(fixtures, 'api', 'preload.html'));\n        const [, test] = await emittedOnce(ipcMain, 'answer');\n        expect(test).to.eql('preload');\n      });\n      it('can successfully delete the Buffer global', async () => {\n        const preload = path.join(__dirname, 'fixtures', 'module', 'delete-buffer.js');\n        const w = new BrowserWindow({\n          show: false,\n          webPreferences: {\n            nodeIntegration: true,\n            enableRemoteModule: true,\n            preload\n          }\n        });\n        w.loadFile(path.join(fixtures, 'api', 'preload.html'));\n        const [, test] = await emittedOnce(ipcMain, 'answer');\n        expect(test).to.eql(Buffer.from('buffer'));\n      });\n      it('has synchronous access to all eventual window APIs', async () => {\n        const preload = path.join(fixtures, 'module', 'access-blink-apis.js');\n        const w = new BrowserWindow({\n          show: false,\n          webPreferences: {\n            nodeIntegration: true,\n            preload\n          }\n        });\n        w.loadFile(path.join(fixtures, 'api', 'preload.html'));\n        const [, test] = await emittedOnce(ipcMain, 'answer');\n        expect(test).to.be.an('object');\n        expect(test.atPreload).to.be.an('array');\n        expect(test.atLoad).to.be.an('array');\n        expect(test.atPreload).to.deep.equal(test.atLoad, 'should have access to the same window APIs');\n      });\n    });\n\n    describe('session preload scripts', function () {\n      const preloads = [\n        path.join(fixtures, 'module', 'set-global-preload-1.js'),\n        path.join(fixtures, 'module', 'set-global-preload-2.js'),\n        path.relative(process.cwd(), path.join(fixtures, 'module', 'set-global-preload-3.js'))\n      ];\n      const defaultSession = session.defaultSession;\n\n      beforeEach(() => {\n        expect(defaultSession.getPreloads()).to.deep.equal([]);\n        defaultSession.setPreloads(preloads);\n      });\n      afterEach(() => {\n        defaultSession.setPreloads([]);\n      });\n\n      it('can set multiple session preload script', () => {\n        expect(defaultSession.getPreloads()).to.deep.equal(preloads);\n      });\n\n      const generateSpecs = (description: string, sandbox: boolean) => {\n        describe(description, () => {\n          it('loads the script before other scripts in window including normal preloads', async () => {\n            const w = new BrowserWindow({\n              show: false,\n              webPreferences: {\n                sandbox,\n                preload: path.join(fixtures, 'module', 'get-global-preload.js')\n              }\n            });\n            w.loadURL('about:blank');\n            const [, preload1, preload2, preload3] = await emittedOnce(ipcMain, 'vars');\n            expect(preload1).to.equal('preload-1');\n            expect(preload2).to.equal('preload-1-2');\n            expect(preload3).to.be.undefined('preload 3');\n          });\n        });\n      };\n\n      generateSpecs('without sandbox', false);\n      generateSpecs('with sandbox', true);\n    });\n\n    describe('\"additionalArguments\" option', () => {\n      it('adds extra args to process.argv in the renderer process', async () => {\n        const preload = path.join(fixtures, 'module', 'check-arguments.js');\n        const w = new BrowserWindow({\n          show: false,\n          webPreferences: {\n            nodeIntegration: true,\n            preload,\n            additionalArguments: ['--my-magic-arg']\n          }\n        });\n        w.loadFile(path.join(fixtures, 'api', 'blank.html'));\n        const [, argv] = await emittedOnce(ipcMain, 'answer');\n        expect(argv).to.include('--my-magic-arg');\n      });\n\n      it('adds extra value args to process.argv in the renderer process', async () => {\n        const preload = path.join(fixtures, 'module', 'check-arguments.js');\n        const w = new BrowserWindow({\n          show: false,\n          webPreferences: {\n            nodeIntegration: true,\n            preload,\n            additionalArguments: ['--my-magic-arg=foo']\n          }\n        });\n        w.loadFile(path.join(fixtures, 'api', 'blank.html'));\n        const [, argv] = await emittedOnce(ipcMain, 'answer');\n        expect(argv).to.include('--my-magic-arg=foo');\n      });\n    });\n\n    describe('\"node-integration\" option', () => {\n      it('disables node integration by default', async () => {\n        const preload = path.join(fixtures, 'module', 'send-later.js');\n        const w = new BrowserWindow({\n          show: false,\n          webPreferences: {\n            preload\n          }\n        });\n        w.loadFile(path.join(fixtures, 'api', 'blank.html'));\n        const [, typeofProcess, typeofBuffer] = await emittedOnce(ipcMain, 'answer');\n        expect(typeofProcess).to.equal('undefined');\n        expect(typeofBuffer).to.equal('undefined');\n      });\n    });\n\n    ifdescribe(features.isRemoteModuleEnabled())('\"enableRemoteModule\" option', () => {\n      const generateSpecs = (description: string, sandbox: boolean) => {\n        describe(description, () => {\n          const preload = path.join(__dirname, 'fixtures', 'module', 'preload-remote.js');\n\n          it('disables the remote module by default', async () => {\n            const w = new BrowserWindow({\n              show: false,\n              webPreferences: {\n                preload,\n                sandbox\n              }\n            });\n            const p = emittedOnce(ipcMain, 'remote');\n            w.loadFile(path.join(fixtures, 'api', 'blank.html'));\n            const [, remote] = await p;\n            expect(remote).to.equal('undefined');\n          });\n\n          it('disables the remote module when false', async () => {\n            const w = new BrowserWindow({\n              show: false,\n              webPreferences: {\n                preload,\n                sandbox,\n                enableRemoteModule: false\n              }\n            });\n            const p = emittedOnce(ipcMain, 'remote');\n            w.loadFile(path.join(fixtures, 'api', 'blank.html'));\n            const [, remote] = await p;\n            expect(remote).to.equal('undefined');\n          });\n\n          it('enables the remote module when true', async () => {\n            const w = new BrowserWindow({\n              show: false,\n              webPreferences: {\n                preload,\n                sandbox,\n                enableRemoteModule: true\n              }\n            });\n            const p = emittedOnce(ipcMain, 'remote');\n            w.loadFile(path.join(fixtures, 'api', 'blank.html'));\n            const [, remote] = await p;\n            expect(remote).to.equal('object');\n          });\n        });\n      };\n\n      generateSpecs('without sandbox', false);\n      generateSpecs('with sandbox', true);\n    });\n\n    describe('\"sandbox\" option', () => {\n      function waitForEvents<T> (emitter: { once: Function }, events: string[], callback: () => void) {\n        let count = events.length;\n        for (const event of events) {\n          emitter.once(event, () => {\n            if (!--count) callback();\n          });\n        }\n      }\n\n      const preload = path.join(path.resolve(__dirname, 'fixtures'), 'module', 'preload-sandbox.js');\n\n      let server: http.Server = null as unknown as http.Server;\n      let serverUrl: string = null as unknown as string;\n\n      before((done) => {\n        server = http.createServer((request, response) => {\n          switch (request.url) {\n            case '/cross-site':\n              response.end(`<html><body><h1>${request.url}</h1></body></html>`);\n              break;\n            default:\n              throw new Error(`unsupported endpoint: ${request.url}`);\n          }\n        }).listen(0, '127.0.0.1', () => {\n          serverUrl = 'http://127.0.0.1:' + (server.address() as AddressInfo).port;\n          done();\n        });\n      });\n\n      after(() => {\n        server.close();\n      });\n\n      it('exposes ipcRenderer to preload script', async () => {\n        const w = new BrowserWindow({\n          show: false,\n          webPreferences: {\n            sandbox: true,\n            preload\n          }\n        });\n        w.loadFile(path.join(fixtures, 'api', 'preload.html'));\n        const [, test] = await emittedOnce(ipcMain, 'answer');\n        expect(test).to.equal('preload');\n      });\n\n      it('exposes ipcRenderer to preload script (path has special chars)', async () => {\n        const preloadSpecialChars = path.join(fixtures, 'module', 'preload-sandbox\u00e6\u00f8 \u00e5\u00fc.js');\n        const w = new BrowserWindow({\n          show: false,\n          webPreferences: {\n            sandbox: true,\n            preload: preloadSpecialChars\n          }\n        });\n        w.loadFile(path.join(fixtures, 'api', 'preload.html'));\n        const [, test] = await emittedOnce(ipcMain, 'answer');\n        expect(test).to.equal('preload');\n      });\n\n      it('exposes \"loaded\" event to preload script', async () => {\n        const w = new BrowserWindow({\n          show: false,\n          webPreferences: {\n            sandbox: true,\n            preload\n          }\n        });\n        w.loadURL('about:blank');\n        await emittedOnce(ipcMain, 'process-loaded');\n      });\n\n      it('exposes \"exit\" event to preload script', async () => {\n        const w = new BrowserWindow({\n          show: false,\n          webPreferences: {\n            sandbox: true,\n            preload\n          }\n        });\n        const htmlPath = path.join(__dirname, 'fixtures', 'api', 'sandbox.html?exit-event');\n        const pageUrl = 'file://' + htmlPath;\n        w.loadURL(pageUrl);\n        const [, url] = await emittedOnce(ipcMain, 'answer');\n        const expectedUrl = process.platform === 'win32'\n          ? 'file:///' + htmlPath.replace(/\\\\/g, '/')\n          : pageUrl;\n        expect(url).to.equal(expectedUrl);\n      });\n\n      it('should open windows in same domain with cross-scripting enabled', async () => {\n        const w = new BrowserWindow({\n          show: false,\n          webPreferences: {\n            sandbox: true,\n            preload\n          }\n        });\n        w.webContents.once('new-window', (event, url, frameName, disposition, options) => {\n          options.webPreferences!.preload = preload;\n        });\n        const htmlPath = path.join(__dirname, 'fixtures', 'api', 'sandbox.html?window-open');\n        const pageUrl = 'file://' + htmlPath;\n        const answer = emittedOnce(ipcMain, 'answer');\n        w.loadURL(pageUrl);\n        const [, url, frameName, , options] = await emittedOnce(w.webContents, 'new-window');\n        const expectedUrl = process.platform === 'win32'\n          ? 'file:///' + htmlPath.replace(/\\\\/g, '/')\n          : pageUrl;\n        expect(url).to.equal(expectedUrl);\n        expect(frameName).to.equal('popup!');\n        expect(options.width).to.equal(500);\n        expect(options.height).to.equal(600);\n        const [, html] = await answer;\n        expect(html).to.equal('<h1>scripting from opener</h1>');\n      });\n\n      it('should open windows in another domain with cross-scripting disabled', async () => {\n        const w = new BrowserWindow({\n          show: false,\n          webPreferences: {\n            sandbox: true,\n            preload\n          }\n        });\n\n        w.webContents.once('new-window', (event, url, frameName, disposition, options) => {\n          options.webPreferences!.preload = preload;\n        });\n        w.loadFile(\n          path.join(__dirname, 'fixtures', 'api', 'sandbox.html'),\n          { search: 'window-open-external' }\n        );\n\n        // Wait for a message from the main window saying that it's ready.\n        await emittedOnce(ipcMain, 'opener-loaded');\n\n        // Ask the opener to open a popup with window.opener.\n        const expectedPopupUrl = `${serverUrl}/cross-site`; // Set in \"sandbox.html\".\n\n        w.webContents.send('open-the-popup', expectedPopupUrl);\n\n        // The page is going to open a popup that it won't be able to close.\n        // We have to close it from here later.\n        const [, popupWindow] = await emittedOnce(app, 'browser-window-created');\n\n        // Ask the popup window for details.\n        const detailsAnswer = emittedOnce(ipcMain, 'child-loaded');\n        popupWindow.webContents.send('provide-details');\n        const [, openerIsNull, , locationHref] = await detailsAnswer;\n        expect(openerIsNull).to.be.false('window.opener is null');\n        expect(locationHref).to.equal(expectedPopupUrl);\n\n        // Ask the page to access the popup.\n        const touchPopupResult = emittedOnce(ipcMain, 'answer');\n        w.webContents.send('touch-the-popup');\n        const [, popupAccessMessage] = await touchPopupResult;\n\n        // Ask the popup to access the opener.\n        const touchOpenerResult = emittedOnce(ipcMain, 'answer');\n        popupWindow.webContents.send('touch-the-opener');\n        const [, openerAccessMessage] = await touchOpenerResult;\n\n        // We don't need the popup anymore, and its parent page can't close it,\n        // so let's close it from here before we run any checks.\n        await closeWindow(popupWindow, { assertNotWindows: false });\n\n        expect(popupAccessMessage).to.be.a('string',\n          'child\\'s .document is accessible from its parent window');\n        expect(popupAccessMessage).to.match(/^Blocked a frame with origin/);\n        expect(openerAccessMessage).to.be.a('string',\n          'opener .document is accessible from a popup window');\n        expect(openerAccessMessage).to.match(/^Blocked a frame with origin/);\n      });\n\n      it('should inherit the sandbox setting in opened windows', async () => {\n        const w = new BrowserWindow({\n          show: false,\n          webPreferences: {\n            sandbox: true\n          }\n        });\n\n        const preloadPath = path.join(fixtures, 'api', 'new-window-preload.js');\n        w.webContents.once('new-window', (event, url, frameName, disposition, options) => {\n          options.webPreferences!.preload = preloadPath;\n        });\n        w.loadFile(path.join(fixtures, 'api', 'new-window.html'));\n        const [, args] = await emittedOnce(ipcMain, 'answer');\n        expect(args).to.include('--enable-sandbox');\n      });\n\n      it('should open windows with the options configured via new-window event listeners', async () => {\n        const w = new BrowserWindow({\n          show: false,\n          webPreferences: {\n            sandbox: true\n          }\n        });\n\n        const preloadPath = path.join(fixtures, 'api', 'new-window-preload.js');\n        w.webContents.once('new-window', (event, url, frameName, disposition, options) => {\n          options.webPreferences!.preload = preloadPath;\n          const prefs = options.webPreferences as any;\n          prefs.foo = 'bar';\n        });\n        w.loadFile(path.join(fixtures, 'api', 'new-window.html'));\n        const [[, childWebContents]] = await Promise.all([\n          emittedOnce(app, 'web-contents-created'),\n          emittedOnce(ipcMain, 'answer')\n        ]);\n        const webPreferences = (childWebContents as any).getLastWebPreferences();\n        expect(webPreferences.foo).to.equal('bar');\n      });\n\n      it('should set ipc event sender correctly', (done) => {\n        const w = new BrowserWindow({\n          show: false,\n          webPreferences: {\n            sandbox: true,\n            preload\n          }\n        });\n        let childWc: WebContents | null = null;\n        w.webContents.on('new-window', (event, url, frameName, disposition, options) => {\n          options.webPreferences!.preload = preload;\n          childWc = (options as any).webContents;\n          expect(w.webContents).to.not.equal(childWc);\n        });\n        ipcMain.once('parent-ready', function (event) {\n          expect(event.sender).to.equal(w.webContents, 'sender should be the parent');\n          event.sender.send('verified');\n        });\n        ipcMain.once('child-ready', function (event) {\n          expect(childWc).to.not.be.null('child webcontents should be available');\n          expect(event.sender).to.equal(childWc, 'sender should be the child');\n          event.sender.send('verified');\n        });\n        waitForEvents(ipcMain, [\n          'parent-answer',\n          'child-answer'\n        ], done);\n        w.loadFile(path.join(__dirname, 'fixtures', 'api', 'sandbox.html'), { search: 'verify-ipc-sender' });\n      });\n\n      describe('event handling', () => {\n        let w: BrowserWindow = null as unknown as BrowserWindow;\n        beforeEach(() => {\n          w = new BrowserWindow({ show: false, webPreferences: { sandbox: true } });\n        });\n        it('works for window events', (done) => {\n          waitForEvents(w, [\n            'page-title-updated'\n          ], done);\n          w.loadURL('data:text/html,<script>document.title = \\'changed\\'</script>');\n        });\n\n        it('works for stop events', (done) => {\n          waitForEvents(w.webContents, [\n            'did-navigate',\n            'did-fail-load',\n            'did-stop-loading'\n          ], done);\n          w.loadURL('data:text/html,<script>stop()</script>');\n        });\n\n        it('works for web contents events', (done) => {\n          waitForEvents(w.webContents, [\n            'did-finish-load',\n            'did-frame-finish-load',\n            'did-navigate-in-page',\n            'will-navigate',\n            'did-start-loading',\n            'did-stop-loading',\n            'did-frame-finish-load',\n            'dom-ready'\n          ], done);\n          w.loadFile(path.join(__dirname, 'fixtures', 'api', 'sandbox.html'), { search: 'webcontents-events' });\n        });\n      });\n\n      it('supports calling preventDefault on new-window events', (done) => {\n        const w = new BrowserWindow({\n          show: false,\n          webPreferences: {\n            sandbox: true\n          }\n        });\n        const initialWebContents = webContents.getAllWebContents().map((i) => i.id);\n        w.webContents.once('new-window', (e) => {\n          e.preventDefault();\n          // We need to give it some time so the windows get properly disposed (at least on OSX).\n          setTimeout(() => {\n            const currentWebContents = webContents.getAllWebContents().map((i) => i.id);\n            try {\n              expect(currentWebContents).to.deep.equal(initialWebContents);\n              done();\n            } catch (error) {\n              done(e);\n            }\n          }, 100);\n        });\n        w.loadFile(path.join(fixtures, 'pages', 'window-open.html'));\n      });\n\n      // see #9387\n      ifit(features.isRemoteModuleEnabled())('properly manages remote object references after page reload', (done) => {\n        const w = new BrowserWindow({\n          show: false,\n          webPreferences: {\n            preload,\n            sandbox: true,\n            enableRemoteModule: true\n          }\n        });\n        w.loadFile(path.join(__dirname, 'fixtures', 'api', 'sandbox.html'), { search: 'reload-remote' });\n\n        ipcMain.on('get-remote-module-path', (event) => {\n          event.returnValue = path.join(fixtures, 'module', 'hello.js');\n        });\n\n        let reload = false;\n        ipcMain.on('reloaded', (event) => {\n          event.returnValue = reload;\n          reload = !reload;\n        });\n\n        ipcMain.once('reload', (event) => {\n          event.sender.reload();\n        });\n\n        ipcMain.once('answer', (event, arg) => {\n          ipcMain.removeAllListeners('reloaded');\n          ipcMain.removeAllListeners('get-remote-module-path');\n          try {\n            expect(arg).to.equal('hi');\n            done();\n          } catch (e) {\n            done(e);\n          }\n        });\n      });\n\n      ifit(features.isRemoteModuleEnabled())('properly manages remote object references after page reload in child window', (done) => {\n        const w = new BrowserWindow({\n          show: false,\n          webPreferences: {\n            preload,\n            sandbox: true,\n            enableRemoteModule: true\n          }\n        });\n        w.webContents.once('new-window', (event, url, frameName, disposition, options) => {\n          options.webPreferences!.preload = preload;\n        });\n\n        w.loadFile(path.join(__dirname, 'fixtures', 'api', 'sandbox.html'), { search: 'reload-remote-child' });\n\n        ipcMain.on('get-remote-module-path', (event) => {\n          event.returnValue = path.join(fixtures, 'module', 'hello-child.js');\n        });\n\n        let reload = false;\n        ipcMain.on('reloaded', (event) => {\n          event.returnValue = reload;\n          reload = !reload;\n        });\n\n        ipcMain.once('reload', (event) => {\n          event.sender.reload();\n        });\n\n        ipcMain.once('answer', (event, arg) => {\n          ipcMain.removeAllListeners('reloaded');\n          ipcMain.removeAllListeners('get-remote-module-path');\n          try {\n            expect(arg).to.equal('hi child window');\n            done();\n          } catch (e) {\n            done(e);\n          }\n        });\n      });\n\n      it('validates process APIs access in sandboxed renderer', async () => {\n        const w = new BrowserWindow({\n          show: false,\n          webPreferences: {\n            sandbox: true,\n            preload\n          }\n        });\n        w.webContents.once('preload-error', (event, preloadPath, error) => {\n          throw error;\n        });\n        process.env.sandboxmain = 'foo';\n        w.loadFile(path.join(fixtures, 'api', 'preload.html'));\n        const [, test] = await emittedOnce(ipcMain, 'answer');\n        expect(test.hasCrash).to.be.true('has crash');\n        expect(test.hasHang).to.be.true('has hang');\n        expect(test.heapStatistics).to.be.an('object');\n        expect(test.blinkMemoryInfo).to.be.an('object');\n        expect(test.processMemoryInfo).to.be.an('object');\n        expect(test.systemVersion).to.be.a('string');\n        expect(test.cpuUsage).to.be.an('object');\n        expect(test.ioCounters).to.be.an('object');\n        expect(test.arch).to.equal(process.arch);\n        expect(test.platform).to.equal(process.platform);\n        expect(test.env).to.deep.equal(process.env);\n        expect(test.execPath).to.equal(process.helperExecPath);\n        expect(test.sandboxed).to.be.true('sandboxed');\n        expect(test.type).to.equal('renderer');\n        expect(test.version).to.equal(process.version);\n        expect(test.versions).to.deep.equal(process.versions);\n\n        if (process.platform === 'linux' && test.osSandbox) {\n          expect(test.creationTime).to.be.null('creation time');\n          expect(test.systemMemoryInfo).to.be.null('system memory info');\n        } else {\n          expect(test.creationTime).to.be.a('number');\n          expect(test.systemMemoryInfo).to.be.an('object');\n        }\n      });\n\n      it('webview in sandbox renderer', async () => {\n        const w = new BrowserWindow({\n          show: false,\n          webPreferences: {\n            sandbox: true,\n            preload,\n            webviewTag: true\n          }\n        });\n        const didAttachWebview = emittedOnce(w.webContents, 'did-attach-webview');\n        const webviewDomReady = emittedOnce(ipcMain, 'webview-dom-ready');\n        w.loadFile(path.join(fixtures, 'pages', 'webview-did-attach-event.html'));\n\n        const [, webContents] = await didAttachWebview;\n        const [, id] = await webviewDomReady;\n        expect(webContents.id).to.equal(id);\n      });\n    });\n\n    describe('nativeWindowOpen option', () => {\n      let w: BrowserWindow = null as unknown as BrowserWindow;\n\n      beforeEach(() => {\n        w = new BrowserWindow({\n          show: false,\n          webPreferences: {\n            nodeIntegration: true,\n            nativeWindowOpen: true,\n            // tests relies on preloads in opened windows\n            nodeIntegrationInSubFrames: true\n          }\n        });\n      });\n\n      it('opens window of about:blank with cross-scripting enabled', async () => {\n        const answer = emittedOnce(ipcMain, 'answer');\n        w.loadFile(path.join(fixtures, 'api', 'native-window-open-blank.html'));\n        const [, content] = await answer;\n        expect(content).to.equal('Hello');\n      });\n      it('opens window of same domain with cross-scripting enabled', async () => {\n        const answer = emittedOnce(ipcMain, 'answer');\n        w.loadFile(path.join(fixtures, 'api', 'native-window-open-file.html'));\n        const [, content] = await answer;\n        expect(content).to.equal('Hello');\n      });\n      it('blocks accessing cross-origin frames', async () => {\n        const answer = emittedOnce(ipcMain, 'answer');\n        w.loadFile(path.join(fixtures, 'api', 'native-window-open-cross-origin.html'));\n        const [, content] = await answer;\n        expect(content).to.equal('Blocked a frame with origin \"file://\" from accessing a cross-origin frame.');\n      });\n      it('opens window from <iframe> tags', async () => {\n        const answer = emittedOnce(ipcMain, 'answer');\n        w.loadFile(path.join(fixtures, 'api', 'native-window-open-iframe.html'));\n        const [, content] = await answer;\n        expect(content).to.equal('Hello');\n      });\n      ifit(!process.env.ELECTRON_SKIP_NATIVE_MODULE_TESTS)('loads native addons correctly after reload', async () => {\n        w.loadFile(path.join(__dirname, 'fixtures', 'api', 'native-window-open-native-addon.html'));\n        {\n          const [, content] = await emittedOnce(ipcMain, 'answer');\n          expect(content).to.equal('function');\n        }\n        w.reload();\n        {\n          const [, content] = await emittedOnce(ipcMain, 'answer');\n          expect(content).to.equal('function');\n        }\n      });\n      it('<webview> works in a scriptable popup', async () => {\n        const preload = path.join(fixtures, 'api', 'new-window-webview-preload.js');\n\n        const w = new BrowserWindow({\n          show: false,\n          webPreferences: {\n            nodeIntegrationInSubFrames: true,\n            nativeWindowOpen: true,\n            webviewTag: true,\n            preload\n          }\n        });\n        w.webContents.once('new-window', (event, url, frameName, disposition, options) => {\n          options.show = false;\n        });\n\n        const webviewLoaded = emittedOnce(ipcMain, 'webview-loaded');\n        w.loadFile(path.join(fixtures, 'api', 'new-window-webview.html'));\n        await webviewLoaded;\n      });\n      it('should inherit the nativeWindowOpen setting in opened windows', async () => {\n        const preloadPath = path.join(fixtures, 'api', 'new-window-preload.js');\n        w.webContents.once('new-window', (event, url, frameName, disposition, options) => {\n          options.webPreferences!.preload = preloadPath;\n        });\n        w.loadFile(path.join(fixtures, 'api', 'new-window.html'));\n        const [, args] = await emittedOnce(ipcMain, 'answer');\n        expect(args).to.include('--native-window-open');\n      });\n      it('should open windows with the options configured via new-window event listeners', async () => {\n        const preloadPath = path.join(fixtures, 'api', 'new-window-preload.js');\n        w.webContents.once('new-window', (event, url, frameName, disposition, options) => {\n          options.webPreferences!.preload = preloadPath;\n          const prefs = options.webPreferences! as any;\n          prefs.foo = 'bar';\n        });\n        w.loadFile(path.join(fixtures, 'api', 'new-window.html'));\n        const [[, childWebContents]] = await Promise.all([\n          emittedOnce(app, 'web-contents-created'),\n          emittedOnce(ipcMain, 'answer')\n        ]);\n        const webPreferences = (childWebContents as any).getLastWebPreferences();\n        expect(webPreferences.foo).to.equal('bar');\n      });\n\n      describe('window.location', () => {\n        const protocols = [\n          ['foo', path.join(fixtures, 'api', 'window-open-location-change.html')],\n          ['bar', path.join(fixtures, 'api', 'window-open-location-final.html')]\n        ];\n        beforeEach(() => {\n          for (const [scheme, path] of protocols) {\n            protocol.registerBufferProtocol(scheme, (request, callback) => {\n              callback({\n                mimeType: 'text/html',\n                data: fs.readFileSync(path)\n              });\n            });\n          }\n        });\n        afterEach(() => {\n          for (const [scheme] of protocols) {\n            protocol.unregisterProtocol(scheme);\n          }\n        });\n        it('retains the original web preferences when window.location is changed to a new origin', async () => {\n          const w = new BrowserWindow({\n            show: false,\n            webPreferences: {\n              nativeWindowOpen: true,\n              // test relies on preloads in opened window\n              nodeIntegrationInSubFrames: true\n            }\n          });\n\n          w.webContents.once('new-window', (event, url, frameName, disposition, options) => {\n            options.webPreferences!.preload = path.join(fixtures, 'api', 'window-open-preload.js');\n          });\n          w.loadFile(path.join(fixtures, 'api', 'window-open-location-open.html'));\n          const [, args, typeofProcess] = await emittedOnce(ipcMain, 'answer');\n          expect(args).not.to.include('--node-integration');\n          expect(args).to.include('--native-window-open');\n          expect(typeofProcess).to.eql('undefined');\n        });\n\n        it('window.opener is not null when window.location is changed to a new origin', async () => {\n          const w = new BrowserWindow({\n            show: false,\n            webPreferences: {\n              nativeWindowOpen: true,\n              // test relies on preloads in opened window\n              nodeIntegrationInSubFrames: true\n            }\n          });\n\n          w.webContents.once('new-window', (event, url, frameName, disposition, options) => {\n            options.webPreferences!.preload = path.join(fixtures, 'api', 'window-open-preload.js');\n          });\n          w.loadFile(path.join(fixtures, 'api', 'window-open-location-open.html'));\n          const [, , , windowOpenerIsNull] = await emittedOnce(ipcMain, 'answer');\n          expect(windowOpenerIsNull).to.be.false('window.opener is null');\n        });\n      });\n    });\n\n    describe('\"disableHtmlFullscreenWindowResize\" option', () => {\n      it('prevents window from resizing when set', async () => {\n        const w = new BrowserWindow({\n          show: false,\n          webPreferences: {\n            disableHtmlFullscreenWindowResize: true\n          }\n        });\n        await w.loadURL('about:blank');\n        const size = w.getSize();\n        const enterHtmlFullScreen = emittedOnce(w.webContents, 'enter-html-full-screen');\n        w.webContents.executeJavaScript('document.body.webkitRequestFullscreen()', true);\n        await enterHtmlFullScreen;\n        expect(w.getSize()).to.deep.equal(size);\n      });\n    });\n  });\n\n  describe('nativeWindowOpen + contextIsolation options', () => {\n    afterEach(closeAllWindows);\n    it('opens window with cross-scripting enabled from isolated context', async () => {\n      const w = new BrowserWindow({\n        show: false,\n        webPreferences: {\n          nativeWindowOpen: true,\n          contextIsolation: true,\n          preload: path.join(fixtures, 'api', 'native-window-open-isolated-preload.js')\n        }\n      });\n      w.loadFile(path.join(fixtures, 'api', 'native-window-open-isolated.html'));\n      const [, content] = await emittedOnce(ipcMain, 'answer');\n      expect(content).to.equal('Hello');\n    });\n  });\n\n  describe('beforeunload handler', function () {\n    let w: BrowserWindow = null as unknown as BrowserWindow;\n    beforeEach(() => {\n      w = new BrowserWindow({ show: false, webPreferences: { nodeIntegration: true } });\n    });\n    afterEach(closeAllWindows);\n\n    it('returning undefined would not prevent close', async () => {\n      await w.loadFile(path.join(__dirname, 'fixtures', 'api', 'beforeunload-undefined.html'));\n      const wait = emittedOnce(w, 'closed');\n      w.close();\n      await wait;\n    });\n\n    it('returning false would prevent close', async () => {\n      await w.loadFile(path.join(__dirname, 'fixtures', 'api', 'beforeunload-false.html'));\n      w.close();\n      const [, proceed] = await emittedOnce(w.webContents, 'before-unload-fired');\n      expect(proceed).to.equal(false);\n    });\n\n    it('returning empty string would prevent close', async () => {\n      await w.loadFile(path.join(__dirname, 'fixtures', 'api', 'beforeunload-empty-string.html'));\n      w.close();\n      const [, proceed] = await emittedOnce(w.webContents, 'before-unload-fired');\n      expect(proceed).to.equal(false);\n    });\n\n    it('emits for each close attempt', async () => {\n      await w.loadFile(path.join(__dirname, 'fixtures', 'api', 'beforeunload-false-prevent3.html'));\n\n      const destroyListener = () => { expect.fail('Close was not prevented'); };\n      w.webContents.once('destroyed', destroyListener);\n\n      w.webContents.executeJavaScript('installBeforeUnload(2)', true);\n      // The renderer needs to report the status of beforeunload handler\n      // back to main process, so wait for next console message, which means\n      // the SuddenTerminationStatus message have been flushed.\n      await emittedOnce(w.webContents, 'console-message');\n      w.close();\n      await emittedOnce(w.webContents, 'before-unload-fired');\n      w.close();\n      await emittedOnce(w.webContents, 'before-unload-fired');\n\n      w.webContents.removeListener('destroyed', destroyListener);\n      const wait = emittedOnce(w, 'closed');\n      w.close();\n      await wait;\n    });\n\n    it('emits for each reload attempt', async () => {\n      await w.loadFile(path.join(__dirname, 'fixtures', 'api', 'beforeunload-false-prevent3.html'));\n\n      const navigationListener = () => { expect.fail('Reload was not prevented'); };\n      w.webContents.once('did-start-navigation', navigationListener);\n\n      w.webContents.executeJavaScript('installBeforeUnload(2)', true);\n      // The renderer needs to report the status of beforeunload handler\n      // back to main process, so wait for next console message, which means\n      // the SuddenTerminationStatus message have been flushed.\n      await emittedOnce(w.webContents, 'console-message');\n      w.reload();\n      // Chromium does not emit 'before-unload-fired' on WebContents for\n      // navigations, so we have to use other ways to know if beforeunload\n      // is fired.\n      await emittedUntil(w.webContents, 'console-message', isBeforeUnload);\n      w.reload();\n      await emittedUntil(w.webContents, 'console-message', isBeforeUnload);\n\n      w.webContents.removeListener('did-start-navigation', navigationListener);\n      w.reload();\n      await emittedOnce(w.webContents, 'did-finish-load');\n    });\n\n    it('emits for each navigation attempt', async () => {\n      await w.loadFile(path.join(__dirname, 'fixtures', 'api', 'beforeunload-false-prevent3.html'));\n\n      const navigationListener = () => { expect.fail('Reload was not prevented'); };\n      w.webContents.once('did-start-navigation', navigationListener);\n\n      w.webContents.executeJavaScript('installBeforeUnload(2)', true);\n      // The renderer needs to report the status of beforeunload handler\n      // back to main process, so wait for next console message, which means\n      // the SuddenTerminationStatus message have been flushed.\n      await emittedOnce(w.webContents, 'console-message');\n      w.loadURL('about:blank');\n      // Chromium does not emit 'before-unload-fired' on WebContents for\n      // navigations, so we have to use other ways to know if beforeunload\n      // is fired.\n      await emittedUntil(w.webContents, 'console-message', isBeforeUnload);\n      w.loadURL('about:blank');\n      await emittedUntil(w.webContents, 'console-message', isBeforeUnload);\n\n      w.webContents.removeListener('did-start-navigation', navigationListener);\n      await w.loadURL('about:blank');\n    });\n  });\n\n  describe('document.visibilityState/hidden', () => {\n    afterEach(closeAllWindows);\n\n    it('visibilityState is initially visible despite window being hidden', async () => {\n      const w = new BrowserWindow({\n        show: false,\n        width: 100,\n        height: 100,\n        webPreferences: {\n          nodeIntegration: true\n        }\n      });\n\n      let readyToShow = false;\n      w.once('ready-to-show', () => {\n        readyToShow = true;\n      });\n\n      w.loadFile(path.join(fixtures, 'pages', 'visibilitychange.html'));\n\n      const [, visibilityState, hidden] = await emittedOnce(ipcMain, 'pong');\n\n      expect(readyToShow).to.be.false('ready to show');\n      expect(visibilityState).to.equal('visible');\n      expect(hidden).to.be.false('hidden');\n    });\n\n    // TODO(nornagon): figure out why this is failing on windows\n    ifit(process.platform !== 'win32')('visibilityState changes when window is hidden', async () => {\n      const w = new BrowserWindow({\n        width: 100,\n        height: 100,\n        webPreferences: {\n          nodeIntegration: true\n        }\n      });\n\n      w.loadFile(path.join(fixtures, 'pages', 'visibilitychange.html'));\n\n      {\n        const [, visibilityState, hidden] = await emittedOnce(ipcMain, 'pong');\n        expect(visibilityState).to.equal('visible');\n        expect(hidden).to.be.false('hidden');\n      }\n\n      w.hide();\n\n      {\n        const [, visibilityState, hidden] = await emittedOnce(ipcMain, 'pong');\n        expect(visibilityState).to.equal('hidden');\n        expect(hidden).to.be.true('hidden');\n      }\n    });\n\n    // TODO(nornagon): figure out why this is failing on windows\n    ifit(process.platform !== 'win32')('visibilityState changes when window is shown', async () => {\n      const w = new BrowserWindow({\n        width: 100,\n        height: 100,\n        webPreferences: {\n          nodeIntegration: true\n        }\n      });\n\n      w.loadFile(path.join(fixtures, 'pages', 'visibilitychange.html'));\n      if (process.platform === 'darwin') {\n        // See https://github.com/electron/electron/issues/8664\n        await emittedOnce(w, 'show');\n      }\n      w.hide();\n      w.show();\n      const [, visibilityState] = await emittedOnce(ipcMain, 'pong');\n      expect(visibilityState).to.equal('visible');\n    });\n\n    ifit(process.platform !== 'win32')('visibilityState changes when window is shown inactive', async () => {\n      const w = new BrowserWindow({\n        width: 100,\n        height: 100,\n        webPreferences: {\n          nodeIntegration: true\n        }\n      });\n      w.loadFile(path.join(fixtures, 'pages', 'visibilitychange.html'));\n      if (process.platform === 'darwin') {\n        // See https://github.com/electron/electron/issues/8664\n        await emittedOnce(w, 'show');\n      }\n      w.hide();\n      w.showInactive();\n      const [, visibilityState] = await emittedOnce(ipcMain, 'pong');\n      expect(visibilityState).to.equal('visible');\n    });\n\n    // TODO(nornagon): figure out why this is failing on windows\n    ifit(process.platform === 'darwin')('visibilityState changes when window is minimized', async () => {\n      const w = new BrowserWindow({\n        width: 100,\n        height: 100,\n        webPreferences: {\n          nodeIntegration: true\n        }\n      });\n      w.loadFile(path.join(fixtures, 'pages', 'visibilitychange.html'));\n\n      {\n        const [, visibilityState, hidden] = await emittedOnce(ipcMain, 'pong');\n        expect(visibilityState).to.equal('visible');\n        expect(hidden).to.be.false('hidden');\n      }\n\n      w.minimize();\n\n      {\n        const [, visibilityState, hidden] = await emittedOnce(ipcMain, 'pong');\n        expect(visibilityState).to.equal('hidden');\n        expect(hidden).to.be.true('hidden');\n      }\n    });\n\n    // FIXME(MarshallOfSound): This test fails locally 100% of the time, on CI it started failing\n    // when we introduced the compositor recycling patch.  Should figure out how to fix this\n    it.skip('visibilityState remains visible if backgroundThrottling is disabled', async () => {\n      const w = new BrowserWindow({\n        show: false,\n        width: 100,\n        height: 100,\n        webPreferences: {\n          backgroundThrottling: false,\n          nodeIntegration: true\n        }\n      });\n      w.loadFile(path.join(fixtures, 'pages', 'visibilitychange.html'));\n      {\n        const [, visibilityState, hidden] = await emittedOnce(ipcMain, 'pong');\n        expect(visibilityState).to.equal('visible');\n        expect(hidden).to.be.false('hidden');\n      }\n\n      ipcMain.once('pong', (event, visibilityState, hidden) => {\n        throw new Error(`Unexpected visibility change event. visibilityState: ${visibilityState} hidden: ${hidden}`);\n      });\n      try {\n        const shown1 = emittedOnce(w, 'show');\n        w.show();\n        await shown1;\n        const hidden = emittedOnce(w, 'hide');\n        w.hide();\n        await hidden;\n        const shown2 = emittedOnce(w, 'show');\n        w.show();\n        await shown2;\n      } finally {\n        ipcMain.removeAllListeners('pong');\n      }\n    });\n  });\n\n  describe('new-window event', () => {\n    afterEach(closeAllWindows);\n\n    it('emits when window.open is called', (done) => {\n      const w = new BrowserWindow({ show: false, webPreferences: { nodeIntegration: true } });\n      w.webContents.once('new-window', (e, url, frameName, disposition, options, additionalFeatures) => {\n        e.preventDefault();\n        try {\n          expect(url).to.equal('http://host/');\n          expect(frameName).to.equal('host');\n          expect(additionalFeatures[0]).to.equal('this-is-not-a-standard-feature');\n          done();\n        } catch (e) {\n          done(e);\n        }\n      });\n      w.loadFile(path.join(fixtures, 'pages', 'window-open.html'));\n    });\n\n    it('emits when window.open is called with no webPreferences', (done) => {\n      const w = new BrowserWindow({ show: false });\n      w.webContents.once('new-window', function (e, url, frameName, disposition, options, additionalFeatures) {\n        e.preventDefault();\n        try {\n          expect(url).to.equal('http://host/');\n          expect(frameName).to.equal('host');\n          expect(additionalFeatures[0]).to.equal('this-is-not-a-standard-feature');\n          done();\n        } catch (e) {\n          done(e);\n        }\n      });\n      w.loadFile(path.join(fixtures, 'pages', 'window-open.html'));\n    });\n\n    it('emits when link with target is called', (done) => {\n      const w = new BrowserWindow({ show: false, webPreferences: { nodeIntegration: true } });\n      w.webContents.once('new-window', (e, url, frameName) => {\n        e.preventDefault();\n        try {\n          expect(url).to.equal('http://host/');\n          expect(frameName).to.equal('target');\n          done();\n        } catch (e) {\n          done(e);\n        }\n      });\n      w.loadFile(path.join(fixtures, 'pages', 'target-name.html'));\n    });\n  });\n\n  ifdescribe(process.platform !== 'linux')('max/minimize events', () => {\n    afterEach(closeAllWindows);\n    it('emits an event when window is maximized', (done) => {\n      const w = new BrowserWindow({ show: false });\n      w.once('maximize', () => { done(); });\n      w.show();\n      w.maximize();\n    });\n\n    it('emits an event when window is unmaximized', (done) => {\n      const w = new BrowserWindow({ show: false });\n      w.once('unmaximize', () => { done(); });\n      w.show();\n      w.maximize();\n      w.unmaximize();\n    });\n\n    it('emits an event when window is minimized', (done) => {\n      const w = new BrowserWindow({ show: false });\n      w.once('minimize', () => { done(); });\n      w.show();\n      w.minimize();\n    });\n  });\n\n  describe('beginFrameSubscription method', () => {\n    it('does not crash when callback returns nothing', (done) => {\n      const w = new BrowserWindow({ show: false });\n      w.loadFile(path.join(fixtures, 'api', 'frame-subscriber.html'));\n      w.webContents.on('dom-ready', () => {\n        w.webContents.beginFrameSubscription(function () {\n          // Pending endFrameSubscription to next tick can reliably reproduce\n          // a crash which happens when nothing is returned in the callback.\n          setTimeout(() => {\n            w.webContents.endFrameSubscription();\n            done();\n          });\n        });\n      });\n    });\n\n    it('subscribes to frame updates', (done) => {\n      const w = new BrowserWindow({ show: false });\n      let called = false;\n      w.loadFile(path.join(fixtures, 'api', 'frame-subscriber.html'));\n      w.webContents.on('dom-ready', () => {\n        w.webContents.beginFrameSubscription(function (data) {\n          // This callback might be called twice.\n          if (called) return;\n          called = true;\n\n          try {\n            expect(data.constructor.name).to.equal('NativeImage');\n            expect(data.isEmpty()).to.be.false('data is empty');\n            done();\n          } catch (e) {\n            done(e);\n          } finally {\n            w.webContents.endFrameSubscription();\n          }\n        });\n      });\n    });\n\n    it('subscribes to frame updates (only dirty rectangle)', (done) => {\n      const w = new BrowserWindow({ show: false });\n      let called = false;\n      let gotInitialFullSizeFrame = false;\n      const [contentWidth, contentHeight] = w.getContentSize();\n      w.webContents.on('did-finish-load', () => {\n        w.webContents.beginFrameSubscription(true, (image, rect) => {\n          if (image.isEmpty()) {\n            // Chromium sometimes sends a 0x0 frame at the beginning of the\n            // page load.\n            return;\n          }\n          if (rect.height === contentHeight && rect.width === contentWidth &&\n            !gotInitialFullSizeFrame) {\n            // The initial frame is full-size, but we're looking for a call\n            // with just the dirty-rect. The next frame should be a smaller\n            // rect.\n            gotInitialFullSizeFrame = true;\n            return;\n          }\n          // This callback might be called twice.\n          if (called) return;\n          // We asked for just the dirty rectangle, so we expect to receive a\n          // rect smaller than the full size.\n          // TODO(jeremy): this is failing on windows currently; investigate.\n          // assert(rect.width < contentWidth || rect.height < contentHeight)\n          called = true;\n\n          try {\n            const expectedSize = rect.width * rect.height * 4;\n            expect(image.getBitmap()).to.be.an.instanceOf(Buffer).with.lengthOf(expectedSize);\n            done();\n          } catch (e) {\n            done(e);\n          } finally {\n            w.webContents.endFrameSubscription();\n          }\n        });\n      });\n      w.loadFile(path.join(fixtures, 'api', 'frame-subscriber.html'));\n    });\n\n    it('throws error when subscriber is not well defined', () => {\n      const w = new BrowserWindow({ show: false });\n      expect(() => {\n        w.webContents.beginFrameSubscription(true, true as any);\n        // TODO(zcbenz): gin is weak at guessing parameter types, we should\n        // upstream native_mate's implementation to gin.\n      }).to.throw('Error processing argument at index 1, conversion failure from ');\n    });\n  });\n\n  describe('savePage method', () => {\n    const savePageDir = path.join(fixtures, 'save_page');\n    const savePageHtmlPath = path.join(savePageDir, 'save_page.html');\n    const savePageJsPath = path.join(savePageDir, 'save_page_files', 'test.js');\n    const savePageCssPath = path.join(savePageDir, 'save_page_files', 'test.css');\n\n    after(() => {\n      try {\n        fs.unlinkSync(savePageCssPath);\n        fs.unlinkSync(savePageJsPath);\n        fs.unlinkSync(savePageHtmlPath);\n        fs.rmdirSync(path.join(savePageDir, 'save_page_files'));\n        fs.rmdirSync(savePageDir);\n      } catch (e) {\n        // Ignore error\n      }\n    });\n    afterEach(closeAllWindows);\n\n    it('should save page to disk', async () => {\n      const w = new BrowserWindow({ show: false });\n      await w.loadFile(path.join(fixtures, 'pages', 'save_page', 'index.html'));\n      await w.webContents.savePage(savePageHtmlPath, 'HTMLComplete');\n\n      expect(fs.existsSync(savePageHtmlPath)).to.be.true('html path');\n      expect(fs.existsSync(savePageJsPath)).to.be.true('js path');\n      expect(fs.existsSync(savePageCssPath)).to.be.true('css path');\n    });\n  });\n\n  describe('BrowserWindow options argument is optional', () => {\n    afterEach(closeAllWindows);\n    it('should create a window with default size (800x600)', () => {\n      const w = new BrowserWindow();\n      expect(w.getSize()).to.deep.equal([800, 600]);\n    });\n  });\n\n  describe('BrowserWindow.restore()', () => {\n    afterEach(closeAllWindows);\n    it('should restore the previous window size', () => {\n      const w = new BrowserWindow({\n        minWidth: 800,\n        width: 800\n      });\n\n      const initialSize = w.getSize();\n      w.minimize();\n      w.restore();\n      expectBoundsEqual(w.getSize(), initialSize);\n    });\n\n    it('does not crash when restoring hidden minimized window', () => {\n      const w = new BrowserWindow({});\n      w.minimize();\n      w.hide();\n      w.show();\n    });\n  });\n\n  describe('BrowserWindow.unmaximize()', () => {\n    afterEach(closeAllWindows);\n    it('should restore the previous window position', () => {\n      const w = new BrowserWindow();\n\n      const initialPosition = w.getPosition();\n      w.maximize();\n      w.unmaximize();\n      expectBoundsEqual(w.getPosition(), initialPosition);\n    });\n  });\n\n  describe('setFullScreen(false)', () => {\n    afterEach(closeAllWindows);\n\n    // only applicable to windows: https://github.com/electron/electron/issues/6036\n    ifdescribe(process.platform === 'win32')('on windows', () => {\n      it('should restore a normal visible window from a fullscreen startup state', async () => {\n        const w = new BrowserWindow({ show: false });\n        await w.loadURL('about:blank');\n        const shown = emittedOnce(w, 'show');\n        // start fullscreen and hidden\n        w.setFullScreen(true);\n        w.show();\n        await shown;\n        const leftFullScreen = emittedOnce(w, 'leave-full-screen');\n        w.setFullScreen(false);\n        await leftFullScreen;\n        expect(w.isVisible()).to.be.true('visible');\n        expect(w.isFullScreen()).to.be.false('fullscreen');\n      });\n      it('should keep window hidden if already in hidden state', async () => {\n        const w = new BrowserWindow({ show: false });\n        await w.loadURL('about:blank');\n        const leftFullScreen = emittedOnce(w, 'leave-full-screen');\n        w.setFullScreen(false);\n        await leftFullScreen;\n        expect(w.isVisible()).to.be.false('visible');\n        expect(w.isFullScreen()).to.be.false('fullscreen');\n      });\n    });\n\n    ifdescribe(process.platform === 'darwin')('BrowserWindow.setFullScreen(false) when HTML fullscreen', () => {\n      it('exits HTML fullscreen when window leaves fullscreen', async () => {\n        const w = new BrowserWindow();\n        await w.loadURL('about:blank');\n        await w.webContents.executeJavaScript('document.body.webkitRequestFullscreen()', true);\n        await emittedOnce(w, 'enter-full-screen');\n        // Wait a tick for the full-screen state to 'stick'\n        await delay();\n        w.setFullScreen(false);\n        await emittedOnce(w, 'leave-html-full-screen');\n      });\n    });\n  });\n\n  describe('parent window', () => {\n    afterEach(closeAllWindows);\n\n    ifit(process.platform === 'darwin')('sheet-begin event emits when window opens a sheet', (done) => {\n      const w = new BrowserWindow();\n      w.once('sheet-begin', () => {\n        done();\n      });\n      // eslint-disable-next-line no-new\n      new BrowserWindow({\n        modal: true,\n        parent: w\n      });\n    });\n\n    ifit(process.platform === 'darwin')('sheet-end event emits when window has closed a sheet', (done) => {\n      const w = new BrowserWindow();\n      const sheet = new BrowserWindow({\n        modal: true,\n        parent: w\n      });\n      w.once('sheet-end', () => { done(); });\n      sheet.close();\n    });\n\n    describe('parent option', () => {\n      it('sets parent window', () => {\n        const w = new BrowserWindow({ show: false });\n        const c = new BrowserWindow({ show: false, parent: w });\n        expect(c.getParentWindow()).to.equal(w);\n      });\n      it('adds window to child windows of parent', () => {\n        const w = new BrowserWindow({ show: false });\n        const c = new BrowserWindow({ show: false, parent: w });\n        expect(w.getChildWindows()).to.deep.equal([c]);\n      });\n      it('removes from child windows of parent when window is closed', async () => {\n        const w = new BrowserWindow({ show: false });\n        const c = new BrowserWindow({ show: false, parent: w });\n        const closed = emittedOnce(c, 'closed');\n        c.close();\n        await closed;\n        // The child window list is not immediately cleared, so wait a tick until it's ready.\n        await delay();\n        expect(w.getChildWindows().length).to.equal(0);\n      });\n\n      it('should not affect the show option', () => {\n        const w = new BrowserWindow({ show: false });\n        const c = new BrowserWindow({ show: false, parent: w });\n        expect(c.isVisible()).to.be.false('child is visible');\n        expect(c.getParentWindow().isVisible()).to.be.false('parent is visible');\n      });\n    });\n\n    describe('win.setParentWindow(parent)', () => {\n      it('sets parent window', () => {\n        const w = new BrowserWindow({ show: false });\n        const c = new BrowserWindow({ show: false });\n        expect(w.getParentWindow()).to.be.null('w.parent');\n        expect(c.getParentWindow()).to.be.null('c.parent');\n        c.setParentWindow(w);\n        expect(c.getParentWindow()).to.equal(w);\n        c.setParentWindow(null);\n        expect(c.getParentWindow()).to.be.null('c.parent');\n      });\n      it('adds window to child windows of parent', () => {\n        const w = new BrowserWindow({ show: false });\n        const c = new BrowserWindow({ show: false });\n        expect(w.getChildWindows()).to.deep.equal([]);\n        c.setParentWindow(w);\n        expect(w.getChildWindows()).to.deep.equal([c]);\n        c.setParentWindow(null);\n        expect(w.getChildWindows()).to.deep.equal([]);\n      });\n      it('removes from child windows of parent when window is closed', async () => {\n        const w = new BrowserWindow({ show: false });\n        const c = new BrowserWindow({ show: false });\n        const closed = emittedOnce(c, 'closed');\n        c.setParentWindow(w);\n        c.close();\n        await closed;\n        // The child window list is not immediately cleared, so wait a tick until it's ready.\n        await delay();\n        expect(w.getChildWindows().length).to.equal(0);\n      });\n    });\n\n    describe('modal option', () => {\n      it('does not freeze or crash', async () => {\n        const parentWindow = new BrowserWindow();\n\n        const createTwo = async () => {\n          const two = new BrowserWindow({\n            width: 300,\n            height: 200,\n            parent: parentWindow,\n            modal: true,\n            show: false\n          });\n\n          const twoShown = emittedOnce(two, 'show');\n          two.show();\n          await twoShown;\n          setTimeout(() => two.close(), 500);\n\n          await emittedOnce(two, 'closed');\n        };\n\n        const one = new BrowserWindow({\n          width: 600,\n          height: 400,\n          parent: parentWindow,\n          modal: true,\n          show: false\n        });\n\n        const oneShown = emittedOnce(one, 'show');\n        one.show();\n        await oneShown;\n        setTimeout(() => one.destroy(), 500);\n\n        await emittedOnce(one, 'closed');\n        await createTwo();\n      });\n\n      ifit(process.platform !== 'darwin')('disables parent window', () => {\n        const w = new BrowserWindow({ show: false });\n        const c = new BrowserWindow({ show: false, parent: w, modal: true });\n        expect(w.isEnabled()).to.be.true('w.isEnabled');\n        c.show();\n        expect(w.isEnabled()).to.be.false('w.isEnabled');\n      });\n\n      ifit(process.platform !== 'darwin')('re-enables an enabled parent window when closed', async () => {\n        const w = new BrowserWindow({ show: false });\n        const c = new BrowserWindow({ show: false, parent: w, modal: true });\n        const closed = emittedOnce(c, 'closed');\n        c.show();\n        c.close();\n        await closed;\n        expect(w.isEnabled()).to.be.true('w.isEnabled');\n      });\n\n      ifit(process.platform !== 'darwin')('does not re-enable a disabled parent window when closed', async () => {\n        const w = new BrowserWindow({ show: false });\n        const c = new BrowserWindow({ show: false, parent: w, modal: true });\n        const closed = emittedOnce(c, 'closed');\n        w.setEnabled(false);\n        c.show();\n        c.close();\n        await closed;\n        expect(w.isEnabled()).to.be.false('w.isEnabled');\n      });\n\n      ifit(process.platform !== 'darwin')('disables parent window recursively', () => {\n        const w = new BrowserWindow({ show: false });\n        const c = new BrowserWindow({ show: false, parent: w, modal: true });\n        const c2 = new BrowserWindow({ show: false, parent: w, modal: true });\n        c.show();\n        expect(w.isEnabled()).to.be.false('w.isEnabled');\n        c2.show();\n        expect(w.isEnabled()).to.be.false('w.isEnabled');\n        c.destroy();\n        expect(w.isEnabled()).to.be.false('w.isEnabled');\n        c2.destroy();\n        expect(w.isEnabled()).to.be.true('w.isEnabled');\n      });\n    });\n  });\n\n  describe('window states', () => {\n    afterEach(closeAllWindows);\n    it('does not resize frameless windows when states change', () => {\n      const w = new BrowserWindow({\n        frame: false,\n        width: 300,\n        height: 200,\n        show: false\n      });\n\n      w.minimizable = false;\n      w.minimizable = true;\n      expect(w.getSize()).to.deep.equal([300, 200]);\n\n      w.resizable = false;\n      w.resizable = true;\n      expect(w.getSize()).to.deep.equal([300, 200]);\n\n      w.maximizable = false;\n      w.maximizable = true;\n      expect(w.getSize()).to.deep.equal([300, 200]);\n\n      w.fullScreenable = false;\n      w.fullScreenable = true;\n      expect(w.getSize()).to.deep.equal([300, 200]);\n\n      w.closable = false;\n      w.closable = true;\n      expect(w.getSize()).to.deep.equal([300, 200]);\n    });\n\n    describe('resizable state', () => {\n      it('with properties', () => {\n        it('can be set with resizable constructor option', () => {\n          const w = new BrowserWindow({ show: false, resizable: false });\n          expect(w.resizable).to.be.false('resizable');\n\n          if (process.platform === 'darwin') {\n            expect(w.maximizable).to.to.true('maximizable');\n          }\n        });\n\n        it('can be changed', () => {\n          const w = new BrowserWindow({ show: false });\n          expect(w.resizable).to.be.true('resizable');\n          w.resizable = false;\n          expect(w.resizable).to.be.false('resizable');\n          w.resizable = true;\n          expect(w.resizable).to.be.true('resizable');\n        });\n      });\n\n      it('with functions', () => {\n        it('can be set with resizable constructor option', () => {\n          const w = new BrowserWindow({ show: false, resizable: false });\n          expect(w.isResizable()).to.be.false('resizable');\n\n          if (process.platform === 'darwin') {\n            expect(w.isMaximizable()).to.to.true('maximizable');\n          }\n        });\n\n        it('can be changed', () => {\n          const w = new BrowserWindow({ show: false });\n          expect(w.isResizable()).to.be.true('resizable');\n          w.setResizable(false);\n          expect(w.isResizable()).to.be.false('resizable');\n          w.setResizable(true);\n          expect(w.isResizable()).to.be.true('resizable');\n        });\n      });\n\n      it('works for a frameless window', () => {\n        const w = new BrowserWindow({ show: false, frame: false });\n        expect(w.resizable).to.be.true('resizable');\n\n        if (process.platform === 'win32') {\n          const w = new BrowserWindow({ show: false, thickFrame: false });\n          expect(w.resizable).to.be.false('resizable');\n        }\n      });\n\n      ifit(process.platform === 'win32')('works for a window smaller than 64x64', () => {\n        const w = new BrowserWindow({\n          show: false,\n          frame: false,\n          resizable: false,\n          transparent: true\n        });\n        w.setContentSize(60, 60);\n        expectBoundsEqual(w.getContentSize(), [60, 60]);\n        w.setContentSize(30, 30);\n        expectBoundsEqual(w.getContentSize(), [30, 30]);\n        w.setContentSize(10, 10);\n        expectBoundsEqual(w.getContentSize(), [10, 10]);\n      });\n    });\n\n    describe('loading main frame state', () => {\n      let server: http.Server = null as unknown as http.Server;\n      let serverUrl: string = null as unknown as string;\n\n      before((done) => {\n        server = http.createServer((request, response) => {\n          response.end();\n        }).listen(0, '127.0.0.1', () => {\n          serverUrl = 'http://127.0.0.1:' + (server.address() as AddressInfo).port;\n          done();\n        });\n      });\n\n      after(() => {\n        server.close();\n      });\n\n      it('is true when the main frame is loading', async () => {\n        const w = new BrowserWindow({ show: false });\n\n        const didStartLoading = emittedOnce(w.webContents, 'did-start-loading');\n        w.webContents.loadURL(serverUrl);\n        await didStartLoading;\n\n        expect(w.webContents.isLoadingMainFrame()).to.be.true('isLoadingMainFrame');\n      });\n\n      it('is false when only a subframe is loading', async () => {\n        const w = new BrowserWindow({ show: false });\n\n        const didStopLoading = emittedOnce(w.webContents, 'did-stop-loading');\n        w.webContents.loadURL(serverUrl);\n        await didStopLoading;\n\n        expect(w.webContents.isLoadingMainFrame()).to.be.false('isLoadingMainFrame');\n\n        const didStartLoading = emittedOnce(w.webContents, 'did-start-loading');\n        w.webContents.executeJavaScript(`\n          var iframe = document.createElement('iframe')\n          iframe.src = '${serverUrl}/page2'\n          document.body.appendChild(iframe)\n        `);\n        await didStartLoading;\n\n        expect(w.webContents.isLoadingMainFrame()).to.be.false('isLoadingMainFrame');\n      });\n\n      it('is true when navigating to pages from the same origin', async () => {\n        const w = new BrowserWindow({ show: false });\n\n        const didStopLoading = emittedOnce(w.webContents, 'did-stop-loading');\n        w.webContents.loadURL(serverUrl);\n        await didStopLoading;\n\n        expect(w.webContents.isLoadingMainFrame()).to.be.false('isLoadingMainFrame');\n\n        const didStartLoading = emittedOnce(w.webContents, 'did-start-loading');\n        w.webContents.loadURL(`${serverUrl}/page2`);\n        await didStartLoading;\n\n        expect(w.webContents.isLoadingMainFrame()).to.be.true('isLoadingMainFrame');\n      });\n    });\n  });\n\n  ifdescribe(process.platform !== 'linux')('window states (excluding Linux)', () => {\n    // Not implemented on Linux.\n    afterEach(closeAllWindows);\n\n    describe('movable state', () => {\n      it('with properties', () => {\n        it('can be set with movable constructor option', () => {\n          const w = new BrowserWindow({ show: false, movable: false });\n          expect(w.movable).to.be.false('movable');\n        });\n\n        it('can be changed', () => {\n          const w = new BrowserWindow({ show: false });\n          expect(w.movable).to.be.true('movable');\n          w.movable = false;\n          expect(w.movable).to.be.false('movable');\n          w.movable = true;\n          expect(w.movable).to.be.true('movable');\n        });\n      });\n\n      it('with functions', () => {\n        it('can be set with movable constructor option', () => {\n          const w = new BrowserWindow({ show: false, movable: false });\n          expect(w.isMovable()).to.be.false('movable');\n        });\n\n        it('can be changed', () => {\n          const w = new BrowserWindow({ show: false });\n          expect(w.isMovable()).to.be.true('movable');\n          w.setMovable(false);\n          expect(w.isMovable()).to.be.false('movable');\n          w.setMovable(true);\n          expect(w.isMovable()).to.be.true('movable');\n        });\n      });\n    });\n\n    describe('visibleOnAllWorkspaces state', () => {\n      it('with properties', () => {\n        it('can be changed', () => {\n          const w = new BrowserWindow({ show: false });\n          expect(w.visibleOnAllWorkspaces).to.be.false();\n          w.visibleOnAllWorkspaces = true;\n          expect(w.visibleOnAllWorkspaces).to.be.true();\n        });\n      });\n\n      it('with functions', () => {\n        it('can be changed', () => {\n          const w = new BrowserWindow({ show: false });\n          expect(w.isVisibleOnAllWorkspaces()).to.be.false();\n          w.setVisibleOnAllWorkspaces(true);\n          expect(w.isVisibleOnAllWorkspaces()).to.be.true();\n        });\n      });\n    });\n\n    ifdescribe(process.platform === 'darwin')('documentEdited state', () => {\n      it('with properties', () => {\n        it('can be changed', () => {\n          const w = new BrowserWindow({ show: false });\n          expect(w.documentEdited).to.be.false();\n          w.documentEdited = true;\n          expect(w.documentEdited).to.be.true();\n        });\n      });\n\n      it('with functions', () => {\n        it('can be changed', () => {\n          const w = new BrowserWindow({ show: false });\n          expect(w.isDocumentEdited()).to.be.false();\n          w.setDocumentEdited(true);\n          expect(w.isDocumentEdited()).to.be.true();\n        });\n      });\n    });\n\n    ifdescribe(process.platform === 'darwin')('representedFilename', () => {\n      it('with properties', () => {\n        it('can be changed', () => {\n          const w = new BrowserWindow({ show: false });\n          expect(w.representedFilename).to.eql('');\n          w.representedFilename = 'a name';\n          expect(w.representedFilename).to.eql('a name');\n        });\n      });\n\n      it('with functions', () => {\n        it('can be changed', () => {\n          const w = new BrowserWindow({ show: false });\n          expect(w.getRepresentedFilename()).to.eql('');\n          w.setRepresentedFilename('a name');\n          expect(w.getRepresentedFilename()).to.eql('a name');\n        });\n      });\n    });\n\n    describe('native window title', () => {\n      it('with properties', () => {\n        it('can be set with title constructor option', () => {\n          const w = new BrowserWindow({ show: false, title: 'mYtItLe' });\n          expect(w.title).to.eql('mYtItLe');\n        });\n\n        it('can be changed', () => {\n          const w = new BrowserWindow({ show: false });\n          expect(w.title).to.eql('Electron Test Main');\n          w.title = 'NEW TITLE';\n          expect(w.title).to.eql('NEW TITLE');\n        });\n      });\n\n      it('with functions', () => {\n        it('can be set with minimizable constructor option', () => {\n          const w = new BrowserWindow({ show: false, title: 'mYtItLe' });\n          expect(w.getTitle()).to.eql('mYtItLe');\n        });\n\n        it('can be changed', () => {\n          const w = new BrowserWindow({ show: false });\n          expect(w.getTitle()).to.eql('Electron Test Main');\n          w.setTitle('NEW TITLE');\n          expect(w.getTitle()).to.eql('NEW TITLE');\n        });\n      });\n    });\n\n    describe('minimizable state', () => {\n      it('with properties', () => {\n        it('can be set with minimizable constructor option', () => {\n          const w = new BrowserWindow({ show: false, minimizable: false });\n          expect(w.minimizable).to.be.false('minimizable');\n        });\n\n        it('can be changed', () => {\n          const w = new BrowserWindow({ show: false });\n          expect(w.minimizable).to.be.true('minimizable');\n          w.minimizable = false;\n          expect(w.minimizable).to.be.false('minimizable');\n          w.minimizable = true;\n          expect(w.minimizable).to.be.true('minimizable');\n        });\n      });\n\n      it('with functions', () => {\n        it('can be set with minimizable constructor option', () => {\n          const w = new BrowserWindow({ show: false, minimizable: false });\n          expect(w.isMinimizable()).to.be.false('movable');\n        });\n\n        it('can be changed', () => {\n          const w = new BrowserWindow({ show: false });\n          expect(w.isMinimizable()).to.be.true('isMinimizable');\n          w.setMinimizable(false);\n          expect(w.isMinimizable()).to.be.false('isMinimizable');\n          w.setMinimizable(true);\n          expect(w.isMinimizable()).to.be.true('isMinimizable');\n        });\n      });\n    });\n\n    describe('maximizable state (property)', () => {\n      it('with properties', () => {\n        it('can be set with maximizable constructor option', () => {\n          const w = new BrowserWindow({ show: false, maximizable: false });\n          expect(w.maximizable).to.be.false('maximizable');\n        });\n\n        it('can be changed', () => {\n          const w = new BrowserWindow({ show: false });\n          expect(w.maximizable).to.be.true('maximizable');\n          w.maximizable = false;\n          expect(w.maximizable).to.be.false('maximizable');\n          w.maximizable = true;\n          expect(w.maximizable).to.be.true('maximizable');\n        });\n\n        it('is not affected when changing other states', () => {\n          const w = new BrowserWindow({ show: false });\n          w.maximizable = false;\n          expect(w.maximizable).to.be.false('maximizable');\n          w.minimizable = false;\n          expect(w.maximizable).to.be.false('maximizable');\n          w.closable = false;\n          expect(w.maximizable).to.be.false('maximizable');\n\n          w.maximizable = true;\n          expect(w.maximizable).to.be.true('maximizable');\n          w.closable = true;\n          expect(w.maximizable).to.be.true('maximizable');\n          w.fullScreenable = false;\n          expect(w.maximizable).to.be.true('maximizable');\n        });\n      });\n\n      it('with functions', () => {\n        it('can be set with maximizable constructor option', () => {\n          const w = new BrowserWindow({ show: false, maximizable: false });\n          expect(w.isMaximizable()).to.be.false('isMaximizable');\n        });\n\n        it('can be changed', () => {\n          const w = new BrowserWindow({ show: false });\n          expect(w.isMaximizable()).to.be.true('isMaximizable');\n          w.setMaximizable(false);\n          expect(w.isMaximizable()).to.be.false('isMaximizable');\n          w.setMaximizable(true);\n          expect(w.isMaximizable()).to.be.true('isMaximizable');\n        });\n\n        it('is not affected when changing other states', () => {\n          const w = new BrowserWindow({ show: false });\n          w.setMaximizable(false);\n          expect(w.isMaximizable()).to.be.false('isMaximizable');\n          w.setMinimizable(false);\n          expect(w.isMaximizable()).to.be.false('isMaximizable');\n          w.setClosable(false);\n          expect(w.isMaximizable()).to.be.false('isMaximizable');\n\n          w.setMaximizable(true);\n          expect(w.isMaximizable()).to.be.true('isMaximizable');\n          w.setClosable(true);\n          expect(w.isMaximizable()).to.be.true('isMaximizable');\n          w.setFullScreenable(false);\n          expect(w.isMaximizable()).to.be.true('isMaximizable');\n        });\n      });\n    });\n\n    ifdescribe(process.platform === 'win32')('maximizable state', () => {\n      it('with properties', () => {\n        it('is reset to its former state', () => {\n          const w = new BrowserWindow({ show: false });\n          w.maximizable = false;\n          w.resizable = false;\n          w.resizable = true;\n          expect(w.maximizable).to.be.false('maximizable');\n          w.maximizable = true;\n          w.resizable = false;\n          w.resizable = true;\n          expect(w.maximizable).to.be.true('maximizable');\n        });\n      });\n\n      it('with functions', () => {\n        it('is reset to its former state', () => {\n          const w = new BrowserWindow({ show: false });\n          w.setMaximizable(false);\n          w.setResizable(false);\n          w.setResizable(true);\n          expect(w.isMaximizable()).to.be.false('isMaximizable');\n          w.setMaximizable(true);\n          w.setResizable(false);\n          w.setResizable(true);\n          expect(w.isMaximizable()).to.be.true('isMaximizable');\n        });\n      });\n    });\n\n    ifdescribe(process.platform !== 'darwin')('menuBarVisible state', () => {\n      describe('with properties', () => {\n        it('can be changed', () => {\n          const w = new BrowserWindow({ show: false });\n          expect(w.menuBarVisible).to.be.true();\n          w.menuBarVisible = false;\n          expect(w.menuBarVisible).to.be.false();\n          w.menuBarVisible = true;\n          expect(w.menuBarVisible).to.be.true();\n        });\n      });\n\n      describe('with functions', () => {\n        it('can be changed', () => {\n          const w = new BrowserWindow({ show: false });\n          expect(w.isMenuBarVisible()).to.be.true('isMenuBarVisible');\n          w.setMenuBarVisibility(false);\n          expect(w.isMenuBarVisible()).to.be.false('isMenuBarVisible');\n          w.setMenuBarVisibility(true);\n          expect(w.isMenuBarVisible()).to.be.true('isMenuBarVisible');\n        });\n      });\n    });\n\n    ifdescribe(process.platform === 'darwin')('fullscreenable state', () => {\n      it('with functions', () => {\n        it('can be set with fullscreenable constructor option', () => {\n          const w = new BrowserWindow({ show: false, fullscreenable: false });\n          expect(w.isFullScreenable()).to.be.false('isFullScreenable');\n        });\n\n        it('can be changed', () => {\n          const w = new BrowserWindow({ show: false });\n          expect(w.isFullScreenable()).to.be.true('isFullScreenable');\n          w.setFullScreenable(false);\n          expect(w.isFullScreenable()).to.be.false('isFullScreenable');\n          w.setFullScreenable(true);\n          expect(w.isFullScreenable()).to.be.true('isFullScreenable');\n        });\n      });\n    });\n\n    // fullscreen events are dispatched eagerly and twiddling things too fast can confuse poor Electron\n\n    ifdescribe(process.platform === 'darwin')('kiosk state', () => {\n      it('with properties', () => {\n        it('can be set with a constructor property', () => {\n          const w = new BrowserWindow({ kiosk: true });\n          expect(w.kiosk).to.be.true();\n        });\n\n        it('can be changed ', async () => {\n          const w = new BrowserWindow();\n          const enterFullScreen = emittedOnce(w, 'enter-full-screen');\n          w.kiosk = true;\n          expect(w.isKiosk()).to.be.true('isKiosk');\n          await enterFullScreen;\n\n          await delay();\n          const leaveFullScreen = emittedOnce(w, 'leave-full-screen');\n          w.kiosk = false;\n          expect(w.isKiosk()).to.be.false('isKiosk');\n          await leaveFullScreen;\n        });\n      });\n\n      it('with functions', () => {\n        it('can be set with a constructor property', () => {\n          const w = new BrowserWindow({ kiosk: true });\n          expect(w.isKiosk()).to.be.true();\n        });\n\n        it('can be changed ', async () => {\n          const w = new BrowserWindow();\n          const enterFullScreen = emittedOnce(w, 'enter-full-screen');\n          w.setKiosk(true);\n          expect(w.isKiosk()).to.be.true('isKiosk');\n          await enterFullScreen;\n\n          await delay();\n          const leaveFullScreen = emittedOnce(w, 'leave-full-screen');\n          w.setKiosk(false);\n          expect(w.isKiosk()).to.be.false('isKiosk');\n          await leaveFullScreen;\n        });\n      });\n    });\n\n    ifdescribe(process.platform === 'darwin')('fullscreen state with resizable set', () => {\n      it('resizable flag should be set to true and restored', async () => {\n        const w = new BrowserWindow({ resizable: false });\n        const enterFullScreen = emittedOnce(w, 'enter-full-screen');\n        w.setFullScreen(true);\n        await enterFullScreen;\n        expect(w.resizable).to.be.true('resizable');\n\n        await delay();\n        const leaveFullScreen = emittedOnce(w, 'leave-full-screen');\n        w.setFullScreen(false);\n        await leaveFullScreen;\n        expect(w.resizable).to.be.false('resizable');\n      });\n    });\n\n    ifdescribe(process.platform === 'darwin')('fullscreen state', () => {\n      it('can be changed with setFullScreen method', async () => {\n        const w = new BrowserWindow();\n        const enterFullScreen = emittedOnce(w, 'enter-full-screen');\n        w.setFullScreen(true);\n        await enterFullScreen;\n        expect(w.isFullScreen()).to.be.true('isFullScreen');\n\n        await delay();\n        const leaveFullScreen = emittedOnce(w, 'leave-full-screen');\n        w.setFullScreen(false);\n        await leaveFullScreen;\n        expect(w.isFullScreen()).to.be.false('isFullScreen');\n      });\n\n      it('does not crash when exiting simpleFullScreen (properties)', (done) => {\n        const w = new BrowserWindow();\n        w.setSimpleFullScreen(true);\n\n        setTimeout(() => {\n          w.setFullScreen(!w.isFullScreen());\n          done();\n        }, 1000);\n      });\n\n      it('does not crash when exiting simpleFullScreen (functions)', (done) => {\n        const w = new BrowserWindow();\n        w.simpleFullScreen = true;\n\n        setTimeout(() => {\n          w.setFullScreen(!w.isFullScreen());\n          done();\n        }, 1000);\n      });\n\n      it('should not be changed by setKiosk method', async () => {\n        const w = new BrowserWindow();\n        const enterFullScreen = emittedOnce(w, 'enter-full-screen');\n        w.setFullScreen(true);\n        await enterFullScreen;\n        expect(w.isFullScreen()).to.be.true('isFullScreen');\n        await delay();\n        w.setKiosk(true);\n        await delay();\n        w.setKiosk(false);\n        expect(w.isFullScreen()).to.be.true('isFullScreen');\n        const leaveFullScreen = emittedOnce(w, 'leave-full-screen');\n        w.setFullScreen(false);\n        await leaveFullScreen;\n        expect(w.isFullScreen()).to.be.false('isFullScreen');\n      });\n    });\n\n    describe('closable state', () => {\n      it('with properties', () => {\n        it('can be set with closable constructor option', () => {\n          const w = new BrowserWindow({ show: false, closable: false });\n          expect(w.closable).to.be.false('closable');\n        });\n\n        it('can be changed', () => {\n          const w = new BrowserWindow({ show: false });\n          expect(w.closable).to.be.true('closable');\n          w.closable = false;\n          expect(w.closable).to.be.false('closable');\n          w.closable = true;\n          expect(w.closable).to.be.true('closable');\n        });\n      });\n\n      it('with functions', () => {\n        it('can be set with closable constructor option', () => {\n          const w = new BrowserWindow({ show: false, closable: false });\n          expect(w.isClosable()).to.be.false('isClosable');\n        });\n\n        it('can be changed', () => {\n          const w = new BrowserWindow({ show: false });\n          expect(w.isClosable()).to.be.true('isClosable');\n          w.setClosable(false);\n          expect(w.isClosable()).to.be.false('isClosable');\n          w.setClosable(true);\n          expect(w.isClosable()).to.be.true('isClosable');\n        });\n      });\n    });\n\n    describe('hasShadow state', () => {\n      it('with properties', () => {\n        it('returns a boolean on all platforms', () => {\n          const w = new BrowserWindow({ show: false });\n          expect(w.shadow).to.be.a('boolean');\n        });\n\n        // On Windows there's no shadow by default & it can't be changed dynamically.\n        it('can be changed with hasShadow option', () => {\n          const hasShadow = process.platform !== 'darwin';\n          const w = new BrowserWindow({ show: false, hasShadow });\n          expect(w.shadow).to.equal(hasShadow);\n        });\n\n        it('can be changed with setHasShadow method', () => {\n          const w = new BrowserWindow({ show: false });\n          w.shadow = false;\n          expect(w.shadow).to.be.false('hasShadow');\n          w.shadow = true;\n          expect(w.shadow).to.be.true('hasShadow');\n          w.shadow = false;\n          expect(w.shadow).to.be.false('hasShadow');\n        });\n      });\n\n      describe('with functions', () => {\n        it('returns a boolean on all platforms', () => {\n          const w = new BrowserWindow({ show: false });\n          const hasShadow = w.hasShadow();\n          expect(hasShadow).to.be.a('boolean');\n        });\n\n        // On Windows there's no shadow by default & it can't be changed dynamically.\n        it('can be changed with hasShadow option', () => {\n          const hasShadow = process.platform !== 'darwin';\n          const w = new BrowserWindow({ show: false, hasShadow });\n          expect(w.hasShadow()).to.equal(hasShadow);\n        });\n\n        it('can be changed with setHasShadow method', () => {\n          const w = new BrowserWindow({ show: false });\n          w.setHasShadow(false);\n          expect(w.hasShadow()).to.be.false('hasShadow');\n          w.setHasShadow(true);\n          expect(w.hasShadow()).to.be.true('hasShadow');\n          w.setHasShadow(false);\n          expect(w.hasShadow()).to.be.false('hasShadow');\n        });\n      });\n    });\n  });\n\n  describe('window.getMediaSourceId()', () => {\n    afterEach(closeAllWindows);\n    it('returns valid source id', async () => {\n      const w = new BrowserWindow({ show: false });\n      const shown = emittedOnce(w, 'show');\n      w.show();\n      await shown;\n\n      // Check format 'window:1234:0'.\n      const sourceId = w.getMediaSourceId();\n      expect(sourceId).to.match(/^window:\\d+:\\d+$/);\n    });\n  });\n\n  ifdescribe(!process.env.ELECTRON_SKIP_NATIVE_MODULE_TESTS)('window.getNativeWindowHandle()', () => {\n    afterEach(closeAllWindows);\n    it('returns valid handle', () => {\n      const w = new BrowserWindow({ show: false });\n      // The module's source code is hosted at\n      // https://github.com/electron/node-is-valid-window\n      const isValidWindow = require('is-valid-window');\n      expect(isValidWindow(w.getNativeWindowHandle())).to.be.true('is valid window');\n    });\n  });\n\n  ifdescribe(process.platform === 'darwin')('previewFile', () => {\n    afterEach(closeAllWindows);\n    it('opens the path in Quick Look on macOS', () => {\n      const w = new BrowserWindow({ show: false });\n      expect(() => {\n        w.previewFile(__filename);\n        w.closeFilePreview();\n      }).to.not.throw();\n    });\n  });\n\n  describe('contextIsolation option with and without sandbox option', () => {\n    const expectedContextData = {\n      preloadContext: {\n        preloadProperty: 'number',\n        pageProperty: 'undefined',\n        typeofRequire: 'function',\n        typeofProcess: 'object',\n        typeofArrayPush: 'function',\n        typeofFunctionApply: 'function',\n        typeofPreloadExecuteJavaScriptProperty: 'undefined'\n      },\n      pageContext: {\n        preloadProperty: 'undefined',\n        pageProperty: 'string',\n        typeofRequire: 'undefined',\n        typeofProcess: 'undefined',\n        typeofArrayPush: 'number',\n        typeofFunctionApply: 'boolean',\n        typeofPreloadExecuteJavaScriptProperty: 'number',\n        typeofOpenedWindow: 'object'\n      }\n    };\n\n    afterEach(closeAllWindows);\n\n    it('separates the page context from the Electron/preload context', async () => {\n      const iw = new BrowserWindow({\n        show: false,\n        webPreferences: {\n          contextIsolation: true,\n          preload: path.join(fixtures, 'api', 'isolated-preload.js')\n        }\n      });\n      const p = emittedOnce(ipcMain, 'isolated-world');\n      iw.loadFile(path.join(fixtures, 'api', 'isolated.html'));\n      const [, data] = await p;\n      expect(data).to.deep.equal(expectedContextData);\n    });\n    it('recreates the contexts on reload', async () => {\n      const iw = new BrowserWindow({\n        show: false,\n        webPreferences: {\n          contextIsolation: true,\n          preload: path.join(fixtures, 'api', 'isolated-preload.js')\n        }\n      });\n      await iw.loadFile(path.join(fixtures, 'api', 'isolated.html'));\n      const isolatedWorld = emittedOnce(ipcMain, 'isolated-world');\n      iw.webContents.reload();\n      const [, data] = await isolatedWorld;\n      expect(data).to.deep.equal(expectedContextData);\n    });\n    it('enables context isolation on child windows', async () => {\n      const iw = new BrowserWindow({\n        show: false,\n        webPreferences: {\n          contextIsolation: true,\n          preload: path.join(fixtures, 'api', 'isolated-preload.js')\n        }\n      });\n      const browserWindowCreated = emittedOnce(app, 'browser-window-created');\n      iw.loadFile(path.join(fixtures, 'pages', 'window-open.html'));\n      const [, window] = await browserWindowCreated;\n      expect(window.webContents.getLastWebPreferences().contextIsolation).to.be.true('contextIsolation');\n    });\n    it('separates the page context from the Electron/preload context with sandbox on', async () => {\n      const ws = new BrowserWindow({\n        show: false,\n        webPreferences: {\n          sandbox: true,\n          contextIsolation: true,\n          preload: path.join(fixtures, 'api', 'isolated-preload.js')\n        }\n      });\n      const p = emittedOnce(ipcMain, 'isolated-world');\n      ws.loadFile(path.join(fixtures, 'api', 'isolated.html'));\n      const [, data] = await p;\n      expect(data).to.deep.equal(expectedContextData);\n    });\n    it('recreates the contexts on reload with sandbox on', async () => {\n      const ws = new BrowserWindow({\n        show: false,\n        webPreferences: {\n          sandbox: true,\n          contextIsolation: true,\n          preload: path.join(fixtures, 'api', 'isolated-preload.js')\n        }\n      });\n      await ws.loadFile(path.join(fixtures, 'api', 'isolated.html'));\n      const isolatedWorld = emittedOnce(ipcMain, 'isolated-world');\n      ws.webContents.reload();\n      const [, data] = await isolatedWorld;\n      expect(data).to.deep.equal(expectedContextData);\n    });\n    it('supports fetch api', async () => {\n      const fetchWindow = new BrowserWindow({\n        show: false,\n        webPreferences: {\n          contextIsolation: true,\n          preload: path.join(fixtures, 'api', 'isolated-fetch-preload.js')\n        }\n      });\n      const p = emittedOnce(ipcMain, 'isolated-fetch-error');\n      fetchWindow.loadURL('about:blank');\n      const [, error] = await p;\n      expect(error).to.equal('Failed to fetch');\n    });\n    it('doesn\\'t break ipc serialization', async () => {\n      const iw = new BrowserWindow({\n        show: false,\n        webPreferences: {\n          contextIsolation: true,\n          preload: path.join(fixtures, 'api', 'isolated-preload.js')\n        }\n      });\n      const p = emittedOnce(ipcMain, 'isolated-world');\n      iw.loadURL('about:blank');\n      iw.webContents.executeJavaScript(`\n        const opened = window.open()\n        openedLocation = opened.location.href\n        opened.close()\n        window.postMessage({openedLocation}, '*')\n      `);\n      const [, data] = await p;\n      expect(data.pageContext.openedLocation).to.equal('about:blank');\n    });\n  });\n\n  describe('window.webContents.focus()', () => {\n    afterEach(closeAllWindows);\n    it('focuses window', async () => {\n      const w1 = new BrowserWindow({ x: 100, y: 300, width: 300, height: 200 });\n      w1.loadURL('about:blank');\n      const w2 = new BrowserWindow({ x: 300, y: 300, width: 300, height: 200 });\n      w2.loadURL('about:blank');\n      w1.webContents.focus();\n      // Give focus some time to switch to w1\n      await delay();\n      expect(w1.webContents.isFocused()).to.be.true('focuses window');\n    });\n  });\n\n  ifdescribe(features.isOffscreenRenderingEnabled())('offscreen rendering', () => {\n    let w: BrowserWindow;\n    beforeEach(function () {\n      w = new BrowserWindow({\n        width: 100,\n        height: 100,\n        show: false,\n        webPreferences: {\n          backgroundThrottling: false,\n          offscreen: true\n        }\n      });\n    });\n    afterEach(closeAllWindows);\n\n    it('creates offscreen window with correct size', async () => {\n      const paint = emittedOnce(w.webContents, 'paint');\n      w.loadFile(path.join(fixtures, 'api', 'offscreen-rendering.html'));\n      const [,, data] = await paint;\n      expect(data.constructor.name).to.equal('NativeImage');\n      expect(data.isEmpty()).to.be.false('data is empty');\n      const size = data.getSize();\n      const { scaleFactor } = screen.getPrimaryDisplay();\n      expect(size.width).to.be.closeTo(100 * scaleFactor, 2);\n      expect(size.height).to.be.closeTo(100 * scaleFactor, 2);\n    });\n\n    it('does not crash after navigation', () => {\n      w.webContents.loadURL('about:blank');\n      w.loadFile(path.join(fixtures, 'api', 'offscreen-rendering.html'));\n    });\n\n    describe('window.webContents.isOffscreen()', () => {\n      it('is true for offscreen type', () => {\n        w.loadFile(path.join(fixtures, 'api', 'offscreen-rendering.html'));\n        expect(w.webContents.isOffscreen()).to.be.true('isOffscreen');\n      });\n\n      it('is false for regular window', () => {\n        const c = new BrowserWindow({ show: false });\n        expect(c.webContents.isOffscreen()).to.be.false('isOffscreen');\n        c.destroy();\n      });\n    });\n\n    describe('window.webContents.isPainting()', () => {\n      it('returns whether is currently painting', async () => {\n        const paint = emittedOnce(w.webContents, 'paint');\n        w.loadFile(path.join(fixtures, 'api', 'offscreen-rendering.html'));\n        await paint;\n        expect(w.webContents.isPainting()).to.be.true('isPainting');\n      });\n    });\n\n    describe('window.webContents.stopPainting()', () => {\n      it('stops painting', async () => {\n        const domReady = emittedOnce(w.webContents, 'dom-ready');\n        w.loadFile(path.join(fixtures, 'api', 'offscreen-rendering.html'));\n        await domReady;\n\n        w.webContents.stopPainting();\n        expect(w.webContents.isPainting()).to.be.false('isPainting');\n      });\n    });\n\n    describe('window.webContents.startPainting()', () => {\n      it('starts painting', async () => {\n        const domReady = emittedOnce(w.webContents, 'dom-ready');\n        w.loadFile(path.join(fixtures, 'api', 'offscreen-rendering.html'));\n        await domReady;\n\n        w.webContents.stopPainting();\n        w.webContents.startPainting();\n\n        await emittedOnce(w.webContents, 'paint');\n        expect(w.webContents.isPainting()).to.be.true('isPainting');\n      });\n    });\n\n    describe('frameRate APIs', () => {\n      it('has default frame rate (function)', async () => {\n        w.loadFile(path.join(fixtures, 'api', 'offscreen-rendering.html'));\n        await emittedOnce(w.webContents, 'paint');\n        expect(w.webContents.getFrameRate()).to.equal(60);\n      });\n\n      it('has default frame rate (property)', async () => {\n        w.loadFile(path.join(fixtures, 'api', 'offscreen-rendering.html'));\n        await emittedOnce(w.webContents, 'paint');\n        expect(w.webContents.frameRate).to.equal(60);\n      });\n\n      it('sets custom frame rate (function)', async () => {\n        const domReady = emittedOnce(w.webContents, 'dom-ready');\n        w.loadFile(path.join(fixtures, 'api', 'offscreen-rendering.html'));\n        await domReady;\n\n        w.webContents.setFrameRate(30);\n\n        await emittedOnce(w.webContents, 'paint');\n        expect(w.webContents.getFrameRate()).to.equal(30);\n      });\n\n      it('sets custom frame rate (property)', async () => {\n        const domReady = emittedOnce(w.webContents, 'dom-ready');\n        w.loadFile(path.join(fixtures, 'api', 'offscreen-rendering.html'));\n        await domReady;\n\n        w.webContents.frameRate = 30;\n\n        await emittedOnce(w.webContents, 'paint');\n        expect(w.webContents.frameRate).to.equal(30);\n      });\n    });\n  });\n});\n"], "filenames": ["shell/browser/api/electron_api_web_contents.cc", "shell/browser/electron_navigation_throttle.cc", "shell/browser/electron_navigation_throttle.h", "spec-main/api-browser-window-spec.ts"], "buggy_code_start_loc": [746, 19, 16, 445], "buggy_code_end_loc": [752, 19, 16, 507], "fixing_code_start_loc": [745, 20, 17, 445], "fixing_code_end_loc": [745, 44, 19, 546], "type": "NVD-CWE-Other", "message": "In Electron before versions 11.0.0-beta.1, 10.0.1, 9.3.0 or 8.5.1 the `will-navigate` event that apps use to prevent navigations to unexpected destinations as per our security recommendations can be bypassed when a sub-frame performs a top-frame navigation across sites. The issue is patched in versions 11.0.0-beta.1, 10.0.1, 9.3.0 or 8.5.1 As a workaround sandbox all your iframes using the sandbox attribute. This will prevent them creating top-frame navigations and is good practice anyway.", "other": {"cve": {"id": "CVE-2020-15174", "sourceIdentifier": "security-advisories@github.com", "published": "2020-10-06T18:15:14.283", "lastModified": "2021-11-18T16:55:32.517", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In Electron before versions 11.0.0-beta.1, 10.0.1, 9.3.0 or 8.5.1 the `will-navigate` event that apps use to prevent navigations to unexpected destinations as per our security recommendations can be bypassed when a sub-frame performs a top-frame navigation across sites. The issue is patched in versions 11.0.0-beta.1, 10.0.1, 9.3.0 or 8.5.1 As a workaround sandbox all your iframes using the sandbox attribute. This will prevent them creating top-frame navigations and is good practice anyway."}, {"lang": "es", "value": "En Electron anteriores a las versiones 11.0.0-beta.1, 10.0.1, 9.3.0 o 8.5.1, el evento \"will-navigate\" que usa las aplicaciones para evitar la navegaci\u00f3n a destinos inesperados seg\u00fan nuestras recomendaciones de seguridad se puede omitir cuando una sub-frame realiza una navegaci\u00f3n top-frame a trav\u00e9s de los sitios.&#xa0;El problema est\u00e1 parcheado en las versiones 11.0.0-beta.1, 10.0.1, 9.3.0 o 8.5.1. Como una soluci\u00f3n temporal, todos sus iframes utilizan el atributo sandbox.&#xa0;Esto impedir\u00e1 que creen navegaciones top-frame y es una buena pr\u00e1ctica de todos modos"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:C/C:N/I:H/A:L", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "LOW", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.2, "impactScore": 4.7}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:C/C:N/I:H/A:L", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "LOW", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.2, "impactScore": 4.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 5.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-20"}, {"lang": "en", "value": "CWE-693"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:electronjs:electron:*:*:*:*:*:*:*:*", "versionStartIncluding": "8.0.0", "versionEndExcluding": "8.5.1", "matchCriteriaId": "5DC7932C-69B7-49B9-820F-3B94EC01F885"}, {"vulnerable": true, "criteria": "cpe:2.3:a:electronjs:electron:*:*:*:*:*:*:*:*", "versionStartIncluding": "9.0.0", "versionEndExcluding": "9.3.0", "matchCriteriaId": "31009479-D311-46F3-80FB-66D67884BADC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:electronjs:electron:*:*:*:*:*:*:*:*", "versionStartIncluding": "10.0.0", "versionEndExcluding": "10.0.1", "matchCriteriaId": "999A166F-06ED-42E8-BA49-61F4120C6893"}]}]}], "references": [{"url": "https://github.com/electron/electron/commit/18613925610ba319da7f497b6deed85ad712c59b", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/electron/electron/security/advisories/GHSA-2q4g-w47c-4674", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/electron/electron/commit/18613925610ba319da7f497b6deed85ad712c59b"}}