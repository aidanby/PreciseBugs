{"buggy_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2023\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISO Media File Format sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n\n\n#ifndef _GF_ISOMEDIA_H_\n#define _GF_ISOMEDIA_H_\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/*!\n\\file <gpac/isomedia.h>\n\\brief ISOBMFF parsing and writing library.\n*/\n\n/*!\n\\addtogroup iso_grp ISO Base Media File\n\\brief ISOBMF, 3GPP, AVC and HEVC file format utilities.\n\nThis section documents the reading and writing of ISOBMF (MP4, 3GPP, AVC, HEVC HEIF ...)\nThe library supports:\n- regular movie read\n- regular movie write\n- fragmented movie and movie segments read\n- fragmented movie and movie segments write\n- QT support\n- Sample descriptions for most common media found in such files (audio, video, text and subtitles)\n- Meta and HEIF read\n- Meta and HEIF write\n- Common Encryption ISMA E&A and OMA DRM support\n- MPEG-4 Systems extensions\n\n\nAll the READ function in this API can be used in EDIT/WRITE mode.\nHowever, some unexpected errors or values may happen in that case, depending\non how much modifications you made (timing, track with 0 samples, ...).\nOn the other hand, none of the EDIT/WRITE functions will work in READ mode.\n\nThe output structure of a edited file will sometimes be different\nfrom the original file, but the media-data and meta-data will be identical.\nThe only change happens in the file media-data container(s) during edition\n\nWhen editing the file, you MUST set the final name of the modified file\nto something different. This API doesn't allow file overwriting.\n\n@{\n */\n\n#include <gpac/tools.h>\n\n\n/*! Track reference types\n\nSome track may depend on other tracks for several reasons. They reference these tracks through the following Reference Types\n*/\nenum\n{\n\t/*! ref type for the OD track dependencies*/\n\tGF_ISOM_REF_OD = GF_4CC( 'm', 'p', 'o', 'd' ),\n\t/*! ref type for stream dependencies*/\n\tGF_ISOM_REF_DECODE = GF_4CC( 'd', 'p', 'n', 'd' ),\n\t/*! ref type for OCR (Object Clock Reference) dependencies*/\n\tGF_ISOM_REF_OCR = GF_4CC( 's', 'y', 'n', 'c' ),\n\t/*! ref type for IPI (Intellectual Property Information) dependencies*/\n\tGF_ISOM_REF_IPI = GF_4CC( 'i', 'p', 'i', 'r' ),\n\t/*! this track describes the referenced tr*/\n\tGF_ISOM_REF_META = GF_4CC( 'c', 'd', 's', 'c' ),\n\t/*! ref type for Hint tracks*/\n\tGF_ISOM_REF_HINT = GF_4CC( 'h', 'i', 'n', 't' ),\n\t/*! ref type for QT Chapter tracks*/\n\tGF_ISOM_REF_CHAP = GF_4CC( 'c', 'h', 'a', 'p' ),\n\t/*! ref type for the SVC and SHVC base tracks*/\n\tGF_ISOM_REF_BASE = GF_4CC( 's', 'b', 'a', 's' ),\n\t/*! ref type for the SVC and SHVC extractor reference tracks*/\n\tGF_ISOM_REF_SCAL = GF_4CC( 's', 'c', 'a', 'l' ),\n\t/*! ref type for the SHVC tile base tracks*/\n\tGF_ISOM_REF_TBAS = GF_4CC( 't', 'b', 'a', 's' ),\n\t/*! ref type for the SHVC tile tracks*/\n\tGF_ISOM_REF_SABT = GF_4CC( 's', 'a', 'b', 't' ),\n\t/*! ref type for the SHVC oinf track*/\n\tGF_ISOM_REF_OREF = GF_4CC( 'o', 'r', 'e', 'f' ),\n\t/*! this track uses fonts carried/defined in the referenced track*/\n\tGF_ISOM_REF_FONT = GF_4CC( 'f', 'o', 'n', 't' ),\n\t/*! this track depends on the referenced hint track, i.e., it should only be used if the referenced hint track is used.*/\n\tGF_ISOM_REF_HIND = GF_4CC( 'h', 'i', 'n', 'd' ),\n\t/*! this track contains auxiliary depth video information for the referenced video track*/\n\tGF_ISOM_REF_VDEP = GF_4CC( 'v', 'd', 'e', 'p' ),\n\t/*! this track contains auxiliary parallax video information for the referenced video track*/\n\tGF_ISOM_REF_VPLX = GF_4CC( 'v', 'p', 'l', 'x' ),\n\t/*! this track contains subtitle, timed text or overlay graphical information for the referenced track or any track in the alternate group to which the track belongs, if any*/\n\tGF_ISOM_REF_SUBT = GF_4CC( 's', 'u', 'b', 't' ),\n\t/*! thumbnail track*/\n\tGF_ISOM_REF_THUMB = GF_4CC( 't', 'h', 'm', 'b' ),\n\t/*DRC*/\n\t/*! additional audio track*/\n\tGF_ISOM_REF_ADDA = GF_4CC( 'a', 'd', 'd', 'a' ),\n\t/*! DRC metadata*/\n\tGF_ISOM_REF_ADRC = GF_4CC( 'a', 'd', 'r', 'c' ),\n\t/*! item->track location*/\n\tGF_ISOM_REF_ILOC = GF_4CC( 'i', 'l', 'o', 'c' ),\n\t/*! AVC dep stream*/\n\tGF_ISOM_REF_AVCP = GF_4CC( 'a', 'v', 'c', 'p' ),\n\t/*! AVC switch to*/\n\tGF_ISOM_REF_SWTO = GF_4CC( 's', 'w', 't', 'o' ),\n\t/*! AVC switch from*/\n\tGF_ISOM_REF_SWFR = GF_4CC( 's', 'w', 'f', 'r' ),\n\n\t/*! Time code*/\n\tGF_ISOM_REF_TMCD = GF_4CC( 't', 'm', 'c', 'd' ),\n\t/*! Structural dependency*/\n\tGF_ISOM_REF_CDEP = GF_4CC( 'c', 'd', 'e', 'p' ),\n\t/*! transcript*/\n\tGF_ISOM_REF_SCPT = GF_4CC( 's', 'c', 'p', 't' ),\n\t/*! nonprimary source description*/\n\tGF_ISOM_REF_SSRC = GF_4CC( 's', 's', 'r', 'c' ),\n\t/*! layer audio track dependency*/\n\tGF_ISOM_REF_LYRA = GF_4CC( 'l', 'y', 'r', 'a' ),\n\t/*! File Delivery Item Information Extension */\n\tGF_ISOM_REF_FDEL = GF_4CC( 'f', 'd', 'e', 'l' ),\n#ifdef GF_ENABLE_CTRN\n\t/*! Track fragment inherit */\n\tGF_ISOM_REF_TRIN = GF_4CC( 't', 'r', 'i', 'n' ),\n#endif\n\n\t/*! Item auxiliary reference */\n\tGF_ISOM_REF_AUXR = GF_4CC( 'a', 'u', 'x', 'r' ),\n\n\t/*! ref type for the VVC subpicture tracks*/\n\tGF_ISOM_REF_SUBPIC = GF_4CC( 's', 'u', 'b', 'p' ),\n};\n\n/*! Track Edit list type*/\ntypedef enum {\n\t/*! empty segment in the track (no media for this segment)*/\n\tGF_ISOM_EDIT_EMPTY\t\t=\t0x00,\n\t/*! dwelled segment in the track (one media sample for this segment)*/\n\tGF_ISOM_EDIT_DWELL\t\t=\t0x01,\n\t/*! normal segment in the track*/\n\tGF_ISOM_EDIT_NORMAL\t\t=\t0x02\n} GF_ISOEditType;\n\n/*! Generic Media Types (YOU HAVE TO USE ONE OF THESE TYPES FOR COMPLIANT ISO MEDIA FILES)*/\nenum\n{\n\t/*base media types*/\n\tGF_ISOM_MEDIA_VISUAL\t= GF_4CC( 'v', 'i', 'd', 'e' ),\n    GF_ISOM_MEDIA_AUXV      = GF_4CC( 'a', 'u', 'x', 'v' ),\n    GF_ISOM_MEDIA_PICT      = GF_4CC( 'p', 'i', 'c', 't' ),\n\tGF_ISOM_MEDIA_AUDIO\t\t= GF_4CC( 's', 'o', 'u', 'n' ),\n\tGF_ISOM_MEDIA_HINT\t\t= GF_4CC( 'h', 'i', 'n', 't' ),\n\tGF_ISOM_MEDIA_META\t\t= GF_4CC( 'm', 'e', 't', 'a' ),\n\tGF_ISOM_MEDIA_TEXT\t\t= GF_4CC( 't', 'e', 'x', 't' ),\n\t/*subtitle code point used on ipod - same as text*/\n\tGF_ISOM_MEDIA_SUBT\t\t= GF_4CC( 's', 'b', 't', 'l' ),\n\tGF_ISOM_MEDIA_SUBPIC\t= GF_4CC( 's', 'u', 'b', 'p' ),\n\tGF_ISOM_MEDIA_MPEG_SUBT\t= GF_4CC( 's', 'u', 'b', 't' ),\n\t/*closed caption track types for QT/ProRes*/\n\tGF_ISOM_MEDIA_CLOSED_CAPTION\t\t= GF_4CC( 'c', 'l', 'c', 'p' ),\n\t/*timecode metadata for QT/ProRes*/\n\tGF_ISOM_MEDIA_TIMECODE\t\t= GF_4CC( 't', 'm', 'c', 'd' ),\n\t/*MPEG-4 media types*/\n\tGF_ISOM_MEDIA_OD\t\t= GF_4CC( 'o', 'd', 's', 'm' ),\n\tGF_ISOM_MEDIA_OCR\t\t= GF_4CC( 'c', 'r', 's', 'm' ),\n\tGF_ISOM_MEDIA_SCENE\t\t= GF_4CC( 's', 'd', 's', 'm' ),\n\tGF_ISOM_MEDIA_MPEG7\t\t= GF_4CC( 'm', '7', 's', 'm' ),\n\tGF_ISOM_MEDIA_OCI\t\t= GF_4CC( 'o', 'c', 's', 'm' ),\n\tGF_ISOM_MEDIA_IPMP\t\t= GF_4CC( 'i', 'p', 's', 'm' ),\n\tGF_ISOM_MEDIA_MPEGJ\t\t= GF_4CC( 'm', 'j', 's', 'm' ),\n\t/*GPAC-defined, for any track using MPEG-4 systems signaling but with undefined streaml types*/\n\tGF_ISOM_MEDIA_ESM\t\t= GF_4CC( 'g', 'e', 's', 'm' ),\n\t/*DIMS media type (same as scene but with a different mediaInfo)*/\n\tGF_ISOM_MEDIA_DIMS\t\t= GF_4CC( 'd', 'i', 'm', 's' ),\n\t/*SWF file embedded in media track*/\n\tGF_ISOM_MEDIA_FLASH\t\t= GF_4CC( 'f', 'l', 's', 'h' ),\n\t/*QTVR track*/\n\tGF_ISOM_MEDIA_QTVR\t\t= GF_4CC( 'q', 't', 'v', 'r' ),\n\tGF_ISOM_MEDIA_JPEG\t\t= GF_4CC( 'j', 'p', 'e', 'g' ),\n\tGF_ISOM_MEDIA_JP2\t\t= GF_4CC( 'j', 'p', '2', ' ' ),\n\tGF_ISOM_MEDIA_PNG\t\t= GF_4CC( 'p', 'n', 'g', ' ' ),\n};\n\n\n/*! specific media sub-types - you shall make sure the media sub type is what you expect*/\nenum\n{\n\t/*reserved, internal use in the lib. Indicates the track complies to MPEG-4 system\n\tspecification, and the usual OD framework tools may be used*/\n\tGF_ISOM_SUBTYPE_MPEG4\t\t= GF_4CC( 'M', 'P', 'E', 'G' ),\n\n\t/*reserved, internal use in the lib. Indicates the track is of GF_ISOM_SUBTYPE_MPEG4\n\tbut it is encrypted.*/\n\tGF_ISOM_SUBTYPE_MPEG4_CRYP\t= GF_4CC( 'E', 'N', 'C', 'M' ),\n\n\t/*restricted video subtype*/\n\tGF_ISOM_SUBTYPE_RESV\t= GF_4CC( 'r', 'e', 's', 'v' ),\n\n\n\t/*AVC/H264 media type - not listed as an MPEG-4 type, ALTHOUGH this library automatically remaps\n\tGF_AVCConfig to MPEG-4 ESD*/\n\tGF_ISOM_SUBTYPE_AVC_H264\t\t= GF_4CC( 'a', 'v', 'c', '1' ),\n\tGF_ISOM_SUBTYPE_AVC2_H264\t\t= GF_4CC( 'a', 'v', 'c', '2' ),\n\tGF_ISOM_SUBTYPE_AVC3_H264\t\t= GF_4CC( 'a', 'v', 'c', '3' ),\n\tGF_ISOM_SUBTYPE_AVC4_H264\t\t= GF_4CC( 'a', 'v', 'c', '4' ),\n\tGF_ISOM_SUBTYPE_SVC_H264\t\t= GF_4CC( 's', 'v', 'c', '1' ),\n\tGF_ISOM_SUBTYPE_MVC_H264\t\t= GF_4CC( 'm', 'v', 'c', '1' ),\n\n\t/*HEVC media type*/\n\tGF_ISOM_SUBTYPE_HVC1\t\t\t= GF_4CC( 'h', 'v', 'c', '1' ),\n\tGF_ISOM_SUBTYPE_HEV1\t\t\t= GF_4CC( 'h', 'e', 'v', '1' ),\n\tGF_ISOM_SUBTYPE_HVC2\t\t\t= GF_4CC( 'h', 'v', 'c', '2' ),\n\tGF_ISOM_SUBTYPE_HEV2\t\t\t= GF_4CC( 'h', 'e', 'v', '2' ),\n\tGF_ISOM_SUBTYPE_LHV1\t\t\t= GF_4CC( 'l', 'h', 'v', '1' ),\n\tGF_ISOM_SUBTYPE_LHE1\t\t\t= GF_4CC( 'l', 'h', 'e', '1' ),\n\tGF_ISOM_SUBTYPE_HVT1\t\t\t= GF_4CC( 'h', 'v', 't', '1' ),\n\n\t/*VVC media types*/\n\tGF_ISOM_SUBTYPE_VVC1\t\t\t= GF_4CC( 'v', 'v', 'c', '1' ),\n\tGF_ISOM_SUBTYPE_VVI1\t\t\t= GF_4CC( 'v', 'v', 'i', '1' ),\n\tGF_ISOM_SUBTYPE_VVS1\t\t\t= GF_4CC( 'v', 'v', 's', '1' ),\n\tGF_ISOM_SUBTYPE_VVCN\t\t\t= GF_4CC( 'v', 'v', 'c', 'N' ),\n\n\t/*AV1 media type*/\n\tGF_ISOM_SUBTYPE_AV01 = GF_4CC('a', 'v', '0', '1'),\n\n\t/*Opus media type*/\n\tGF_ISOM_SUBTYPE_OPUS = GF_4CC('O', 'p', 'u', 's'),\n\tGF_ISOM_SUBTYPE_FLAC = GF_4CC( 'f', 'L', 'a', 'C' ),\n\n\t/* VP */\n\tGF_ISOM_SUBTYPE_VP08 = GF_4CC('v', 'p', '0', '8'),\n\tGF_ISOM_SUBTYPE_VP09 = GF_4CC('v', 'p', '0', '9'),\n\tGF_ISOM_SUBTYPE_VP10 = GF_4CC('v', 'p', '1', '0'),\n\n\t/* Dolby Vision */\n\tGF_ISOM_SUBTYPE_DVHE = GF_4CC('d', 'v', 'h', 'e'),\n\tGF_ISOM_SUBTYPE_DVH1 = GF_4CC('d', 'v', 'h', '1'),\n\tGF_ISOM_SUBTYPE_DVA1 = GF_4CC('d', 'v', 'a', '1'),\n\tGF_ISOM_SUBTYPE_DVAV = GF_4CC('d', 'v', 'a', 'v'),\n\tGF_ISOM_SUBTYPE_DAV1 = GF_4CC('d', 'a', 'v', '1'),\n\n\t/*3GPP(2) extension subtypes*/\n\tGF_ISOM_SUBTYPE_3GP_H263\t= GF_4CC( 's', '2', '6', '3' ),\n\tGF_ISOM_SUBTYPE_3GP_AMR\t\t= GF_4CC( 's', 'a', 'm', 'r' ),\n\tGF_ISOM_SUBTYPE_3GP_AMR_WB\t= GF_4CC( 's', 'a', 'w', 'b' ),\n\tGF_ISOM_SUBTYPE_3GP_EVRC\t= GF_4CC( 's', 'e', 'v', 'c' ),\n\tGF_ISOM_SUBTYPE_3GP_QCELP\t= GF_4CC( 's', 'q', 'c', 'p' ),\n\tGF_ISOM_SUBTYPE_3GP_SMV\t\t= GF_4CC( 's', 's', 'm', 'v' ),\n\n\t/*3GPP DIMS*/\n\tGF_ISOM_SUBTYPE_3GP_DIMS\t= GF_4CC( 'd', 'i', 'm', 's' ),\n\n\tGF_ISOM_SUBTYPE_AC3\t\t\t= GF_4CC( 'a', 'c', '-', '3' ),\n\tGF_ISOM_SUBTYPE_EC3\t\t\t= GF_4CC( 'e', 'c', '-', '3' ),\n\tGF_ISOM_SUBTYPE_MP3\t\t\t= GF_4CC( '.', 'm', 'p', '3' ),\n\tGF_ISOM_SUBTYPE_MLPA\t\t= GF_4CC( 'm', 'l', 'p', 'a' ),\n\n\tGF_ISOM_SUBTYPE_MP4A\t\t= GF_4CC( 'm', 'p', '4', 'a' ),\n\tGF_ISOM_SUBTYPE_MP4S\t\t= GF_4CC( 'm', 'p', '4', 's' ),\n\n\tGF_ISOM_SUBTYPE_LSR1\t\t= GF_4CC( 'l', 's', 'r', '1' ),\n\tGF_ISOM_SUBTYPE_WVTT\t\t= GF_4CC( 'w', 'v', 't', 't' ),\n\tGF_ISOM_SUBTYPE_STXT\t\t= GF_4CC( 's', 't', 'x', 't' ),\n\tGF_ISOM_SUBTYPE_STPP\t\t= GF_4CC( 's', 't', 'p', 'p' ),\n\tGF_ISOM_SUBTYPE_SBTT\t\t= GF_4CC( 's', 'b', 't', 't' ),\n\tGF_ISOM_SUBTYPE_METT\t\t= GF_4CC( 'm', 'e', 't', 't' ),\n\tGF_ISOM_SUBTYPE_METX\t\t= GF_4CC( 'm', 'e', 't', 'x' ),\n\tGF_ISOM_SUBTYPE_TX3G\t\t= GF_4CC( 't', 'x', '3', 'g' ),\n\tGF_ISOM_SUBTYPE_TEXT\t\t= GF_4CC( 't', 'e', 'x', 't' ),\n\tGF_ISOM_SUBTYPE_SUBTITLE\t= GF_4CC( 's', 'b', 't', 'l' ),\n\n\n\tGF_ISOM_SUBTYPE_RTP\t\t\t= GF_4CC( 'r', 't', 'p', ' ' ),\n\tGF_ISOM_SUBTYPE_SRTP\t\t= GF_4CC( 's', 'r', 't', 'p' ),\n\tGF_ISOM_SUBTYPE_RRTP\t\t= GF_4CC( 'r', 'r', 't', 'p' ),\n\tGF_ISOM_SUBTYPE_RTCP\t\t= GF_4CC( 'r', 't', 'c', 'p' ),\n\tGF_ISOM_SUBTYPE_FLUTE\t\t= GF_4CC( 'f', 'd', 'p', ' ' ),\n\n\t/* Apple XDCAM */\n\tGF_ISOM_SUBTYPE_XDVB\t\t= GF_4CC( 'x', 'd', 'v', 'b' ),\n\n\tGF_ISOM_SUBTYPE_H263\t\t= GF_4CC( 'h', '2', '6', '3' ),\n\n\tGF_ISOM_SUBTYPE_JPEG\t\t= GF_4CC( 'j', 'p', 'e', 'g' ),\n\tGF_ISOM_SUBTYPE_PNG \t\t= GF_4CC( 'p', 'n', 'g', ' ' ),\n\tGF_ISOM_SUBTYPE_MJP2 \t\t= GF_4CC( 'm', 'j', 'p', '2' ),\n\tGF_ISOM_SUBTYPE_JP2K\t\t= GF_4CC('j','p','2','k'),\n\n\tGF_ISOM_SUBTYPE_MH3D_MHA1\t= GF_4CC( 'm', 'h', 'a', '1' ),\n\tGF_ISOM_SUBTYPE_MH3D_MHA2\t= GF_4CC( 'm', 'h', 'a', '2' ),\n\tGF_ISOM_SUBTYPE_MH3D_MHM1\t= GF_4CC( 'm', 'h', 'm', '1' ),\n\tGF_ISOM_SUBTYPE_MH3D_MHM2\t= GF_4CC( 'm', 'h', 'm', '2' ),\n\n\tGF_ISOM_SUBTYPE_IPCM\t\t= GF_4CC( 'i', 'p', 'c', 'm' ),\n\tGF_ISOM_SUBTYPE_FPCM\t\t= GF_4CC( 'f', 'p', 'c', 'm' ),\n\n\t/* on-screen colours */\n\tGF_ISOM_SUBTYPE_NCLX \t\t= GF_4CC( 'n', 'c', 'l', 'x' ),\n\tGF_ISOM_SUBTYPE_NCLC \t\t= GF_4CC( 'n', 'c', 'l', 'c' ),\n\tGF_ISOM_SUBTYPE_PROF \t\t= GF_4CC( 'p', 'r', 'o', 'f' ),\n\tGF_ISOM_SUBTYPE_RICC \t\t= GF_4CC( 'r', 'I', 'C', 'C' ),\n\n\t/* QT audio codecs */\n\t//this one is also used for 24bit RGB\n\tGF_QT_SUBTYPE_RAW\t= GF_4CC('r','a','w',' '),\n\tGF_QT_SUBTYPE_TWOS \t= GF_4CC('t','w','o','s'),\n\tGF_QT_SUBTYPE_SOWT \t= GF_4CC('s','o','w','t'),\n\tGF_QT_SUBTYPE_FL32 \t= GF_4CC('f','l','3','2'),\n\tGF_QT_SUBTYPE_FL64 \t= GF_4CC('f','l','6','4'),\n\tGF_QT_SUBTYPE_IN24 \t= GF_4CC('i','n','2','4'),\n\tGF_QT_SUBTYPE_IN32 \t= GF_4CC('i','n','3','2'),\n\tGF_QT_SUBTYPE_ULAW \t= GF_4CC('u','l','a','w'),\n\tGF_QT_SUBTYPE_ALAW \t= GF_4CC('a','l','a','w'),\n\tGF_QT_SUBTYPE_ADPCM \t= GF_4CC(0x6D,0x73,0x00,0x02),\n\tGF_QT_SUBTYPE_IMA_ADPCM \t= GF_4CC(0x6D,0x73,0x00,0x11),\n\tGF_QT_SUBTYPE_DVCA \t= GF_4CC('d','v','c','a'),\n\tGF_QT_SUBTYPE_QDMC \t= GF_4CC('Q','D','M','C'),\n\tGF_QT_SUBTYPE_QDMC2\t= GF_4CC('Q','D','M','2'),\n\tGF_QT_SUBTYPE_QCELP\t= GF_4CC('Q','c','l','p'),\n\tGF_QT_SUBTYPE_kMP3 \t= GF_4CC(0x6D,0x73,0x00,0x55),\n\n\t/* QT video codecs */\n\tGF_QT_SUBTYPE_C608\t= GF_4CC( 'c', '6', '0', '8' ),\n\tGF_QT_SUBTYPE_APCH\t= GF_4CC( 'a', 'p', 'c', 'h' ),\n\tGF_QT_SUBTYPE_APCO\t= GF_4CC( 'a', 'p', 'c', 'o' ),\n\tGF_QT_SUBTYPE_APCN\t= GF_4CC( 'a', 'p', 'c', 'n' ),\n\tGF_QT_SUBTYPE_APCS\t= GF_4CC( 'a', 'p', 'c', 's' ),\n\tGF_QT_SUBTYPE_AP4X\t= GF_4CC( 'a', 'p', '4', 'x' ),\n\tGF_QT_SUBTYPE_AP4H\t= GF_4CC( 'a', 'p', '4', 'h' ),\n\tGF_QT_SUBTYPE_YUYV = GF_4CC('y','u','v','2'),\n\tGF_QT_SUBTYPE_UYVY = GF_4CC('2','v','u','y'),\n\tGF_QT_SUBTYPE_YUV444 = GF_4CC('v','3','0','8'),\n\tGF_QT_SUBTYPE_YUVA444 = GF_4CC('v','4','0','8'),\n\tGF_QT_SUBTYPE_YUV422_10 = GF_4CC('v','2','1','0'),\n\tGF_QT_SUBTYPE_YUV444_10 = GF_4CC('v','4','1','0'),\n\tGF_QT_SUBTYPE_YUV422_16 = GF_4CC('v','2','1','6'),\n\tGF_QT_SUBTYPE_YUV420 = GF_4CC('j','4','2','0'),\n\tGF_QT_SUBTYPE_I420 = GF_4CC('I','4','2','0'),\n\tGF_QT_SUBTYPE_IYUV = GF_4CC('I','Y','U','V'),\n\tGF_QT_SUBTYPE_YV12 = GF_4CC('y','v','1','2'),\n\tGF_QT_SUBTYPE_YVYU = GF_4CC('Y','V','Y','U'),\n\tGF_QT_SUBTYPE_RGBA = GF_4CC('R','G','B','A'),\n\tGF_QT_SUBTYPE_ABGR = GF_4CC('A','B','G','R'),\n\tGF_QT_SUBTYPE_ALAC =  GF_4CC('a','l','a','c'),\n\tGF_QT_SUBTYPE_LPCM =  GF_4CC('l','p','c','m'),\n\tGF_ISOM_SUBTYPE_FFV1\t\t= GF_4CC( 'F', 'F', 'V', '1' ),\n\n\tGF_ISOM_ITEM_TYPE_AUXI \t= GF_4CC('a', 'u', 'x', 'i'),\n\n\tGF_QT_SUBTYPE_TMCD = GF_4CC( 't', 'm', 'c', 'd' ),\n\n\tGF_ISOM_SUBTYPE_VC1 = GF_4CC( 'v', 'c', '-', '1' ),\n\n\t/*GPAC extensions*/\n\tGF_ISOM_SUBTYPE_DVB_SUBS\t= GF_4CC( 'd', 'v', 'b', 's' ),\n\tGF_ISOM_SUBTYPE_DVB_TELETEXT\t= GF_4CC( 'd', 'v', 'b', 't' ),\n\n\n\tGF_ISOM_SUBTYPE_DTSC = GF_4CC('d','t','s','c'),\n\tGF_ISOM_SUBTYPE_DTSH = GF_4CC('d','t','s','h'),\n\tGF_ISOM_SUBTYPE_DTSL = GF_4CC('d','t','s','l'),\n\tGF_ISOM_SUBTYPE_DTSE = GF_4CC('d','t','s','e'),\n\tGF_ISOM_SUBTYPE_DTSX = GF_4CC('d','t','s','x'),\n\tGF_ISOM_SUBTYPE_DTSY = GF_4CC('d','t','s','y'),\n\n\tGF_ISOM_SUBTYPE_UNCV\t= GF_4CC( 'u', 'n', 'c', 'v' ),\n\tGF_ISOM_ITEM_TYPE_UNCI\t= GF_4CC( 'u', 'n', 'c', 'i' ),\n};\n\n\n\n\n/*! direction for sample search (including SyncSamples search)\nFunction using search allways specify the desired time in composition (presentation) time\n\t\t(Sample N-1)\tDesiredTime\t\t(Sample N)\n*/\ntypedef enum\n{\n\t/*! FORWARD: will give the next sample given the desired time (eg, N)*/\n\tGF_ISOM_SEARCH_FORWARD\t\t=\t1,\n\t/*! BACKWARD: will give the previous sample given the desired time (eg, N-1)*/\n\tGF_ISOM_SEARCH_BACKWARD\t\t=\t2,\n\t/*! SYNCFORWARD: will search from the desired point in time for a sync sample if any. If no sync info, behaves as FORWARD*/\n\tGF_ISOM_SEARCH_SYNC_FORWARD\t=\t3,\n\t/*! SYNCBACKWARD: will search till the desired point in time for a sync sample if any. If no sync info, behaves as BACKWARD*/\n\tGF_ISOM_SEARCH_SYNC_BACKWARD\t=\t4,\n\t/*! SYNCSHADOW: use the sync shadow information to retrieve the sample. If no SyncShadow info, behave as SYNCBACKWARD\n\t\\warning deprecated in ISOBMFF*/\n\tGF_ISOM_SEARCH_SYNC_SHADOW\t\t=\t5\n} GF_ISOSearchMode;\n\n/*! Predefined File Brand codes (MPEG-4 and JPEG2000)*/\nenum\n{\n\t/*file complying to the generic ISO Media File (base specification ISO/IEC 14496-12)\n\tthis is the default brand when creating a new movie*/\n\tGF_ISOM_BRAND_ISOM = GF_4CC( 'i', 's', 'o', 'm' ),\n\t/*file complying to the generic ISO Media File (base specification ISO/IEC 14496-12) + Meta extensions*/\n\tGF_ISOM_BRAND_ISO2 =  GF_4CC( 'i', 's', 'o', '2' ),\n\t/*file complying to ISO/IEC 14496-1 2001 edition. A .mp4 file without a brand\n\tis equivalent to a file compatible with this brand*/\n\tGF_ISOM_BRAND_MP41 = GF_4CC( 'm', 'p', '4', '1' ),\n\t/*file complying to ISO/IEC 14496-14 (MP4 spec)*/\n\tGF_ISOM_BRAND_MP42 = GF_4CC( 'm', 'p', '4', '2' ),\n\t/*file complying to ISO/IEC 15444-3 (JPEG2000) without profile restriction*/\n\tGF_ISOM_BRAND_MJP2 = GF_4CC( 'm', 'j', 'p', '2' ),\n\t/*file complying to ISO/IEC 15444-3 (JPEG2000) with simple profile restriction*/\n\tGF_ISOM_BRAND_MJ2S = GF_4CC( 'm', 'j', '2', 's' ),\n\t/*old versions of 3GPP spec (without timed text)*/\n\tGF_ISOM_BRAND_3GP4 = GF_4CC('3', 'g', 'p', '4'),\n\tGF_ISOM_BRAND_3GP5 = GF_4CC('3', 'g', 'p', '5'),\n\t/*final version of 3GPP file spec*/\n\tGF_ISOM_BRAND_3GP6 = GF_4CC('3', 'g', 'p', '6'),\n\t/*generci 3GPP file (several audio tracks, etc..)*/\n\tGF_ISOM_BRAND_3GG5 = GF_4CC('3', 'g', 'g', '5'),\n\tGF_ISOM_BRAND_3GG6 = GF_4CC('3', 'g', 'g', '6'),\n\t/*3GPP2 file spec*/\n\tGF_ISOM_BRAND_3G2A = GF_4CC('3', 'g', '2', 'a'),\n\t/*AVC file spec*/\n\tGF_ISOM_BRAND_AVC1 = GF_4CC('a', 'v', 'c', '1'),\n\t/* file complying to ISO/IEC 21000-9:2005 (MPEG-21 spec)*/\n\tGF_ISOM_BRAND_MP21 = GF_4CC('m', 'p', '2', '1'),\n\t/*file complying to the generic ISO Media File (base specification ISO/IEC 14496-12) + support for version 1*/\n\tGF_ISOM_BRAND_ISO4 =  GF_4CC( 'i', 's', 'o', '4' ),\n\t/* Image File Format */\n\tGF_ISOM_BRAND_HEIF = GF_4CC('h', 'e', 'i', 'f'),\n\tGF_ISOM_BRAND_MIF1 = GF_4CC('m', 'i', 'f', '1'),\n\tGF_ISOM_BRAND_HEIC = GF_4CC('h', 'e', 'i', 'c'),\n\tGF_ISOM_BRAND_HEIM = GF_4CC('h', 'e', 'i', 'm'),\n\tGF_ISOM_BRAND_AVIF = GF_4CC('a', 'v', 'i', 'f'),\n\tGF_ISOM_BRAND_AVCI = GF_4CC('a', 'v', 'c', 'i'),\n\tGF_ISOM_BRAND_VVIC = GF_4CC('v', 'v', 'i', 'c'),\n\n\t/*other iso media brands */\n\tGF_ISOM_BRAND_ISO1 = GF_4CC( 'i', 's', 'o', '1' ),\n\tGF_ISOM_BRAND_ISO3 = GF_4CC( 'i', 's', 'o', '3' ),\n\tGF_ISOM_BRAND_ISO5 = GF_4CC( 'i', 's', 'o', '5' ),\n\tGF_ISOM_BRAND_ISO6 = GF_4CC( 'i', 's', 'o', '6' ),\n\tGF_ISOM_BRAND_ISO7 = GF_4CC( 'i', 's', 'o', '7' ),\n\tGF_ISOM_BRAND_ISO8 = GF_4CC( 'i', 's', 'o', '8' ),\n\tGF_ISOM_BRAND_ISO9 = GF_4CC( 'i', 's', 'o', '9' ),\n\tGF_ISOM_BRAND_ISOA = GF_4CC( 'i', 's', 'o', 'a' ),\n\n\t/* QT brand*/\n\tGF_ISOM_BRAND_QT  = GF_4CC( 'q', 't', ' ', ' ' ),\n\n\t/* JPEG 2000 Image (.JP2) [ISO 15444-1] */\n\tGF_ISOM_BRAND_JP2  = GF_4CC( 'j', 'p', '2', ' ' ),\n\n\t/* MPEG-4 (.MP4) for SonyPSP */\n\tGF_ISOM_BRAND_MSNV = GF_4CC( 'M', 'S', 'N', 'V' ),\n\t/* Apple iTunes AAC-LC (.M4A) Audio */\n\tGF_ISOM_BRAND_M4A  = GF_4CC( 'M', '4', 'A', ' ' ),\n\t/* Apple iTunes Video (.M4V) Video */\n\tGF_ISOM_BRAND_M4V  = GF_4CC( 'M', '4', 'V', ' ' ),\n\n\tGF_ISOM_BRAND_HVCE = GF_4CC( 'h', 'v', 'c', 'e' ),\n\tGF_ISOM_BRAND_HVCI = GF_4CC( 'h', 'v', 'c', 'i' ),\n\tGF_ISOM_BRAND_HVTI = GF_4CC( 'h', 'v', 't', 'i' ),\n\n\n\tGF_ISOM_BRAND_AV01 = GF_4CC( 'a', 'v', '0', '1'),\n\n\tGF_ISOM_BRAND_OPUS = GF_4CC( 'O', 'p', 'u', 's'),\n\n\tGF_ISOM_BRAND_ISMA = GF_4CC( 'I', 'S', 'M', 'A' ),\n\n\t/* dash related brands (ISO/IEC 23009-1) */\n\tGF_ISOM_BRAND_DASH = GF_4CC('d','a','s','h'),\n\t/* Media Segment conforming to the DASH Self-Initializing Media Segment format type */\n\tGF_ISOM_BRAND_DSMS = GF_4CC('d','s','m','s'),\n\t/* Media Segment conforming to the general format type */\n\tGF_ISOM_BRAND_MSDH = GF_4CC('m','s','d','h'),\n\t/* Media Segment conforming to the Indexed Media Segment format type */\n\tGF_ISOM_BRAND_MSIX = GF_4CC('m','s','i','x'),\n\t/* Representation Index Segment used to index MPEG-2 TS based Media Segments */\n\tGF_ISOM_BRAND_RISX = GF_4CC('r','i','s','x'),\n\t/* last Media Segment indicator for ISO base media file format */\n\tGF_ISOM_BRAND_LMSG = GF_4CC('l','m','s','g'),\n\t/* Single Index Segment used to index MPEG-2 TS based Media Segments */\n\tGF_ISOM_BRAND_SISX = GF_4CC('s','i','s','x'),\n\t/* Subsegment Index Segment used to index MPEG-2 TS based Media Segments */\n\tGF_ISOM_BRAND_SSSS = GF_4CC('s','s','s','s'),\n\n\t/* CMAF brand */\n\tGF_ISOM_BRAND_CMFC = GF_4CC('c','m','f','c'),\n\t/* CMAF brand with neg ctts */\n\tGF_ISOM_BRAND_CMF2 = GF_4CC('c','m','f','2'),\n\n\t/* from ismacryp.c */\n\t/* OMA DCF DRM Format 2.0 (OMA-TS-DRM-DCF-V2_0-20060303-A) */\n\tGF_ISOM_BRAND_ODCF = GF_4CC('o','d','c','f'),\n\t/* OMA PDCF DRM Format 2.1 (OMA-TS-DRM-DCF-V2_1-20070724-C) */\n\tGF_ISOM_BRAND_OPF2 = GF_4CC('o','p','f','2'),\n\n\t/* compressed brand*/\n\tGF_ISOM_BRAND_COMP  = GF_4CC( 'c', 'o', 'm', 'p' ),\n\tGF_ISOM_BRAND_ISOC  = GF_4CC( 'i', 's', 'o', 'C' ),\n\n};\n\n/*! sample roll information type*/\ntypedef enum\n{\n\t/*! no roll info associated*/\n\tGF_ISOM_SAMPLE_ROLL_NONE=0,\n\t/*! roll info describes a roll operation*/\n\tGF_ISOM_SAMPLE_ROLL,\n\t/*! roll info describes an audio preroll*/\n\tGF_ISOM_SAMPLE_PREROLL,\n\t/*! roll info describes audio preroll but is not set for this sample*/\n\tGF_ISOM_SAMPLE_PREROLL_NONE\n} GF_ISOSampleRollType;\n\n#ifndef GPAC_DISABLE_ISOM\n\n#include <gpac/mpeg4_odf.h>\n\n/*! isomedia file*/\ntypedef struct __tag_isom GF_ISOFile;\n\n/*! a track ID value - just a 32 bit value but typedefed for API safety*/\ntypedef u32 GF_ISOTrackID;\n\n/*! @} */\n\n/*!\n\\addtogroup isosample_grp ISO Sample\n\\ingroup iso_grp\n\nMedia sample for ISOBMFF API.\n@{\n*/\n\n/*! Random Access Point flag*/\ntypedef enum {\n\t/*! redundant sync shadow - only set when reading sample*/\n\tRAP_REDUNDANT = -1,\n\t/*! not rap*/\n\tRAP_NO = 0,\n\t/*! sync point (IDR)*/\n\tRAP = 1,\n\t/*! sync point (IDR)*/\n\tSAP_TYPE_1 = 1,\n\t/*! sync point (IDR)*/\n\tSAP_TYPE_2 = 2,\n\t/*! RAP, OpenGOP*/\n\tSAP_TYPE_3 = 3,\n\t/*! RAP, roll info (GDR or audio preroll)*/\n\tSAP_TYPE_4 = 4,\n} GF_ISOSAPType;\n\n/*! media sample object*/\ntypedef struct\n{\n\t/*! data size*/\n\tu32 dataLength;\n\t/*! data with padding if requested*/\n\tu8 *data;\n\t/*! decoding time*/\n\tu64 DTS;\n\t/*! relative offset for composition if needed*/\n\ts32 CTS_Offset;\n\t/*! SAP type*/\n\tGF_ISOSAPType IsRAP;\n\t/*! allocated data size - used only when using static sample in \\ref gf_isom_get_sample_ex*/\n\tu32 alloc_size;\n\t\n\t/*! number of packed samples in this sample. If 0 or 1, only 1 sample is present\n\tonly used for constant size and constant duration samples*/\n\tu32 nb_pack;\n\n\t/*! read API only - sample duration (multiply by nb_pack to get full duration)*/\n\tu32 duration;\n} GF_ISOSample;\n\n\n/*! creates a new empty sample\n\\return the newly allocated ISO sample*/\nGF_ISOSample *gf_isom_sample_new();\n\n/*! delete a sample.\n\\note The buffer content will be destroyed by default. If you wish to keep the buffer, set dataLength to 0 in the sample before deleting it\nthe pointer is set to NULL after deletion\n\\param samp pointer to the target ISO sample\n*/\nvoid gf_isom_sample_del(GF_ISOSample **samp);\n\n\n/*! @} */\n\n/*!\n\\addtogroup isogen_grp Generic API\n\\ingroup iso_grp\n\nGeneric API functions\n@{\n*/\n\n/*! Movie file opening modes */\ntypedef enum\n{\n\t/*! Opens file for dumping: same as read-only but keeps all movie fragments info untouched*/\n\tGF_ISOM_OPEN_READ_DUMP = 0,\n\t/*! Opens a file in READ ONLY mode*/\n\tGF_ISOM_OPEN_READ,\n\t/*! Opens a file in WRITE ONLY mode. Media Data is captured on the fly and storage mode is always flat (moov at end).\n\tIn this mode, the editing functions are disabled.*/\n\tGF_ISOM_OPEN_WRITE,\n\t/*! Opens an existing file in EDIT mode*/\n\tGF_ISOM_OPEN_EDIT,\n\t/*! Creates a new file in EDIT mode*/\n\tGF_ISOM_WRITE_EDIT,\n\t/*! Opens an existing file and keep fragment information*/\n\tGF_ISOM_OPEN_KEEP_FRAGMENTS,\n\t/*! Opens an existing file in READ ONLY mode but enables most of the file edit functions except fragmentation\n\tSamples may be added to the file in this mode, they will be stored in memory\n\t*/\n\tGF_ISOM_OPEN_READ_EDIT,\n} GF_ISOOpenMode;\n\n/*! indicates if target file is an IsoMedia file\n\\param fileName the target local file name or path to probe, gmem:// or gfio:// resource\n\\return 1 if it is a non-special file, 2 if an init segment, 3 if a media segment, 0 otherwise\n*/\nu32 gf_isom_probe_file(const char *fileName);\n\n/*! indicates if target file is an IsoMedia file\n\\param fileName the target local file name or path to probe, gmem:// or gfio:// resource\n\\param start_range the offset in the file to start probing from\n\\param end_range the offset in the file at which probing shall stop\n\\return 1 if it is a non-special file, 2 if an init segment, 3 if a media segment, 4 if empty or no file, 0 otherwise\n*/\nu32 gf_isom_probe_file_range(const char *fileName, u64 start_range, u64 end_range);\n\n/*! indicates if target file is an IsoMedia file\n\\param inBuf the buffer to probe\n\\param inSize the sizeo of the buffer to probe\n\\returns 1 if it is a non-special file, 2 if an init segment, 3 if a media segment, 0 otherwise (non recognized or too short)\n*/\nu32 gf_isom_probe_data(const u8*inBuf, u32 inSize);\n\n/*! opens an isoMedia File.\nIf fileName is NULL data will be written in memory ; write with gf_isom_write() ; use gf_isom_get_bs() to get the data ; use gf_isom_delete() to delete the internal data.\n\\param fileName name of the file to open, , gmem:// or gfio:// resource. The special name \"_gpac_isobmff_redirect\" is used to indicate that segment shall be written to a memory buffer passed to callback function set through \\ref gf_isom_set_write_callback.\n\\param OpenMode file opening mode\n\\param tmp_dir for the 2 edit modes only, specifies a location for temp file. If NULL, the library will use the default libgpac temporary file management schemes.\n\\return the created ISO file if no error\n*/\nGF_ISOFile *gf_isom_open(const char *fileName, GF_ISOOpenMode OpenMode, const char *tmp_dir);\n\n/*! closes the file, write it if new/edited - equivalent to gf_isom_write()+gf_isom_delete()\n\\param isom_file the target ISO file\n\\return error if any\n*/\nGF_Err gf_isom_close(GF_ISOFile *isom_file);\n\n/*! deletes the movie without saving it\n\\param isom_file the target ISO file\n*/\nvoid gf_isom_delete(GF_ISOFile *isom_file);\n\n/*! gets the last fatal error that occured in the file\nANY FUNCTION OF THIS API WON'T BE PROCESSED IF THE FILE HAS AN ERROR\n\\note Some function may return an error while the movie has no error\nthe last error is a FatalError, and is not always set if a bad\nparam is specified...\n\\param isom_file the target ISO file\n\\return error if any\n*/\nGF_Err gf_isom_last_error(GF_ISOFile *isom_file);\n\n/*! gets the mode of an open file\n\\param isom_file the target ISO file\n\\return open mode of the file\n*/\nu8 gf_isom_get_mode(GF_ISOFile *isom_file);\n\n/*! checks if file is J2K image\n\\param isom_file the target ISO file\n\\return GF_TRUE if file is a j2k image, GF_FALSE otherwise\n*/\nBool gf_isom_is_JPEG2000(GF_ISOFile *isom_file);\n\n\n/*! checks if a given four character code matches a known video handler type (vide, auxv, pict, ...)\n\\param mtype the four character code to check\n\\return GF_TRUE if the type is a video media type*/\nBool gf_isom_is_video_handler_type(u32 mtype);\n\n/*! gets number of implemented boxes in  (including the internal unknown box wrapper).\n\\note There can be several times the same type returned due to variation of the box (versions or flags)\n\\return number of implemented boxes\n*/\nu32 gf_isom_get_num_supported_boxes();\n\n/*! gets four character code of box given its index. Index 0 is GPAC internal unknown box handler\n\\param idx 0-based index of the box\n\\return four character code of the box\n*/\nu32 gf_isom_get_supported_box_type(u32 idx);\n\n#ifndef GPAC_DISABLE_ISOM_DUMP\n\n/*! prints default box syntax of box given its index. Index 0 is GPAC internal unknown box handler\n\\param idx 0-based index of the box\n\\param trace the file object to dump to\n\\return error if any\n*/\nGF_Err gf_isom_dump_supported_box(u32 idx, FILE * trace);\n\n#endif\n\n/*! @} */\n\n/*!\n\\addtogroup isoread_grp ISOBMFF Reading\n\\ingroup iso_grp\n\nISOBMF file reading\n@{\n*/\n\n/*! checks if moov box is before any mdat box\n\\param isom_file the target ISO file\n\\return GF_TRUE if if moov box is before any mdat box, GF_FALSE otherwise\n*/\nBool gf_isom_moov_first(GF_ISOFile *isom_file);\n\n/*! when reading a file, indicates that file data is missing the indicated bytes\n\\param isom_file the target ISO file\n\\param byte_offset number of bytes not present at the beginning of the file\n\\return error if any\n*/\nGF_Err gf_isom_set_byte_offset(GF_ISOFile *isom_file, s64 byte_offset);\n\n\n/*! opens a movie that can be uncomplete in READ_ONLY mode\nto use for http streaming & co\n\nstart_range and end_range restricts the media byte range in the URL (used by DASH)\nif 0 or end_range<=start_range, the entire URL is used when parsing\n\nIf the url indicates a gfio or gmem resource, the file can be played from the associated underlying buffer. For gmem, you must call \\ref gf_isom_refresh_fragmented and gf_isom_set_removed_bytes whenever the underlying buffer is modified.\n\n\\param fileName the name of the local file or cache to open, gmem:// or gfio://\n\\param start_range only loads starting from indicated byte range\n\\param end_range loading stops at indicated byte range\n\\param enable_frag_templates loads fragment and segment boundaries in an internal table\n\\param isom_file pointer set to the opened file if success\n\\param BytesMissing is set to the predicted number of bytes missing for the file to be loaded\nNote that if the file is not optimized for streaming, this number is not accurate\nIf the movie is successfully loaded (isom_file non-NULL), BytesMissing is zero\n\\return error if any\n*/\nGF_Err gf_isom_open_progressive(const char *fileName, u64 start_range, u64 end_range, Bool enable_frag_templates, GF_ISOFile **isom_file, u64 *BytesMissing);\n\n\n/*! same as  \\ref gf_isom_open_progressive but allows fetching the incomplete box type\n\n\\param fileName the name of the local file or cache to open\n\\param start_range only loads starting from indicated byte range\n\\param end_range loading stops at indicated byte range\n\\param enable_frag_templates loads fragment and segment boundaries in an internal table\n\\param isom_file pointer set to the opened file if success\n\\param BytesMissing is set to the predicted number of bytes missing for the file to be loaded\n\\param topBoxType is set to the 4CC of the incomplete top-level box found - may be NULL\nNote that if the file is not optimized for streaming, this number is not accurate\nIf the movie is successfully loaded (isom_file non-NULL), BytesMissing is zero\n\\return error if any\n*/\nGF_Err gf_isom_open_progressive_ex(const char *fileName, u64 start_range, u64 end_range, Bool enable_frag_templates, GF_ISOFile **isom_file, u64 *BytesMissing, u32 *topBoxType);\n\n/*! retrieves number of bytes missing.\nif requesting a sample fails with error GF_ISOM_INCOMPLETE_FILE, use this function\nto get the number of bytes missing to retrieve the sample\n\\param isom_file the target ISO file\n\\param trackNumber the desired track to query\n\\return the number of bytes missing to fetch the sample\n*/\nu64 gf_isom_get_missing_bytes(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! checks if a file has movie info (moov box with tracks & dynamic media). Some files may just use\nthe base IsoMedia structure without \"moov\" container\n\\param isom_file the target ISO file\n\\return GF_TRUE if the file has a movie, GF_FALSE otherwise\n*/\nBool gf_isom_has_movie(GF_ISOFile *isom_file);\n\n/*! gets number of tracks\n\\param isom_file the target ISO file\n\\return the number of tracks in the movie, or -1 if error*/\nu32 gf_isom_get_track_count(GF_ISOFile *isom_file);\n\n/*! gets the movie timescale\n\\param isom_file the target ISO file\n\\return the timescale of the movie, 0 if error*/\nu32 gf_isom_get_timescale(GF_ISOFile *isom_file);\n\n/*! gets the movie duration computed based on media samples and edit lists\n\\param isom_file the target ISO file\n\\return the computed duration of the movie, 0 if error*/\nu64 gf_isom_get_duration(GF_ISOFile *isom_file);\n\n/*! gets the original movie duration as written in the file, regardless of the media data\n\\param isom_file the target ISO file\n\\return the duration of the movie*/\nu64 gf_isom_get_original_duration(GF_ISOFile *isom_file);\n\n/*! time offset since UNIX EPOC for MP4/QT/MJ2K files*/\n#define GF_ISOM_MAC_TIME_OFFSET 2082844800\n\n/*! gets the creation info of the movie\n\\param isom_file the target ISO file\n\\param creationTime set to the creation time of the movie\n\\param modificationTime set to the modification time of the movie\n\\return error if any\n*/\nGF_Err gf_isom_get_creation_time(GF_ISOFile *isom_file, u64 *creationTime, u64 *modificationTime);\n\n\n/*! gets the creation info of the movie\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param creationTime set to the creation time of the movie\n\\param modificationTime set to the modification time of the movie\n\\return error if any\n*/\nGF_Err gf_isom_get_track_creation_time(GF_ISOFile *isom_file, u32 trackNumber, u64 *creationTime, u64 *modificationTime);\n\n/*! gets the ID of a track\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return the trackID of the track, or 0 if error*/\nGF_ISOTrackID gf_isom_get_track_id(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! gets a track number by its ID\n\\param isom_file the target ISO file\n\\param trackID the target track ID\n\\return the track number of the track, or 0 if error*/\nu32 gf_isom_get_track_by_id(GF_ISOFile *isom_file, GF_ISOTrackID trackID);\n\n/*! gets the track original ID (before cloning from another file)\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return the original trackID of the track, or 0 if error*/\nGF_ISOTrackID gf_isom_get_track_original_id(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! gets the enable flag of a track\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return 0: not enabled, 1: enabled, 2: error\n*/\nu8 gf_isom_is_track_enabled(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! gets track flags\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return the track flags\n*/\nu32 gf_isom_get_track_flags(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! gets the track duration - this will try to fix any discrepencies between media duration+edit lists vs track duration\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return the track duration in movie timescale, or 0 if error*/\nu64 gf_isom_get_track_duration(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! gets the unmodified track duration - mus be called before any call to \\ref gf_isom_get_track_duration\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return the track duration in movie timescale, or 0 if error*/\nu64 gf_isom_get_track_duration_orig(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! gets the media type (audio, video, etc) of a track\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return the media type four character code of the media*/\nu32 gf_isom_get_media_type(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! gets media subtype of a sample description entry\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index (1-based)\n\\return the media type four character code of the given sample description*/\nu32 gf_isom_get_media_subtype(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex);\n\n/*! gets the composition time (media time) given the absolute time in the Movie\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param movieTime desired time in movie timescale\n\\param mediaTime is set to 0 if the media is not playing at that time (empty time segment)\n\\return error if any*/\nGF_Err gf_isom_get_media_time(GF_ISOFile *isom_file, u32 trackNumber, u32 movieTime, u64 *mediaTime);\n\n/*! gets the number of sample descriptions in the media - a media can have several stream descriptions (eg different codec configurations, different protetcions, different visual sizes).\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return the number of sample descriptions\n*/\nu32 gf_isom_get_sample_description_count(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! gets the stream description index for a given time in media time\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param for_time the desired time in media timescale\n\\return the sample description index, or 0 if error or if empty*/\nu32 gf_isom_get_sample_description_index(GF_ISOFile *isom_file, u32 trackNumber, u64 for_time);\n\n/*! checks if a sample stream description is self-contained (samples located in the file)\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index (1-based)\n\\return GF_TRUE if samples referring to the given stream description are present in the file, GF_FALSE otherwise*/\nBool gf_isom_is_self_contained(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex);\n\n/*! gets the media duration (without edit) based on sample table\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return the media duration, 0 if no samples\n*/\nu64 gf_isom_get_media_duration(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! gets the original media duration (without edit) as indicated in the file\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return the media duration\n*/\nu64 gf_isom_get_media_original_duration(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! gets the media timescale\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return the timeScale of the media\n*/\nu32 gf_isom_get_media_timescale(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! gets media chunking information for non-fragmented files\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param dur_min set to minimum chunk duration in media timescale (optional, can be NULL)\n\\param dur_avg set to average chunk duration in media timescale (optional, can be NULL)\n\\param dur_max set to maximum chunk duration in media timescale (optional, can be NULL)\n\\param size_min set to smallest chunk size in bytes (optional, can be NULL)\n\\param size_avg set to average chunk size in bytes (optional, can be NULL)\n\\param size_max set to largest chunk size in bytes (optional, can be NULL)\n\\return error if any\n*/\nGF_Err gf_isom_get_chunks_infos(GF_ISOFile *isom_file, u32 trackNumber, u32 *dur_min, u32 *dur_avg, u32 *dur_max, u32 *size_min, u32 *size_avg, u32 *size_max);\n\n/*! gets the handler name. The outName must be:\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param outName set to the handler name (must be non NULL)\n\\return error if any\n*/\nGF_Err gf_isom_get_handler_name(GF_ISOFile *isom_file, u32 trackNumber, const char **outName);\n\n/*! checks if the data reference for the given track and sample description is valid and supported\n(a data Reference allows to construct a file without integrating the media data, however this library only handles local storage external data references)\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index (1-based)\n\\return error if any\n*/\nGF_Err gf_isom_check_data_reference(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex);\n\n/*! gets the location of the data. If both outURL and outURN are set to NULL, the data is in this file\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index (1-based)\n\\param outURL set to URL value of the data reference\n\\param outURN set to URN value of the data reference\n\\return error if any\n*/\nGF_Err gf_isom_get_data_reference(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, const char **outURL, const char **outURN);\n\n/*! gets the number of samples in a track\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return the number of samples, or 0 if error*/\nu32 gf_isom_get_sample_count(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! gets the constant sample size for samples of a track\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return constant size of samples or 0 if size not constant\n*/\nu32 gf_isom_get_constant_sample_size(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! gets the constant sample duration for samples of a track\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return constant duration of samples, or 0 if duration not constant*/\nu32 gf_isom_get_constant_sample_duration(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! sets max audio sample packing in a single ISOSample.\nThis is mostly used when processing raw audio tracks, for which extracting samples per samples would be too time consuming\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param pack_num_samples the target number of samples to pack in one ISOSample\n\\return GF_TRUE if packing was successfull, GF_FALSE otherwise (non constant size and non constant duration)\n*/\nBool gf_isom_enable_raw_pack(GF_ISOFile *isom_file, u32 trackNumber, u32 pack_num_samples);\n\n/*! gets the total media data size of a track (whether in the file or not)\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return total amount of media bytes in track\n*/\nu64 gf_isom_get_media_data_size(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! sets sample padding bytes when reading a sample\nIt may be desired to fetch samples with a bigger allocated buffer than their real size, in case the decoder\nreads more data than available. This sets the amount of extra bytes to allocate when reading samples from this track\n\\note The dataLength of the sample does NOT include padding\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param padding_bytes the amount of bytes to add at the end of a sample data buffer\n\\return error if any\n*/\nGF_Err gf_isom_set_sample_padding(GF_ISOFile *isom_file, u32 trackNumber, u32 padding_bytes);\n\n/*! fetches a sample from a track. The sample must be destroyed using \\ref gf_isom_sample_del\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleNumber the desired sample number (1-based index)\n\\param sampleDescriptionIndex set to the sample description index corresponding to this sample\n\\return the ISO sample or NULL if not found or end of stream  or incomplete file. Use \\ref gf_isom_last_error to check the error code\n*/\nGF_ISOSample *gf_isom_get_sample(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleNumber, u32 *sampleDescriptionIndex);\n\n/*! fetches a sample from a track without allocating a new sample.\nThis function is the same as \\ref gf_isom_get_sample except that it fills in the static_sample passed as argument, potentially reallocating buffers\n\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleNumber the desired sample number (1-based index)\n\\param sampleDescriptionIndex set to the sample description index corresponding to this sample\n\\param static_sample a caller-allocated ISO sample to use as the returned sample\n\\param data_offset set to data offset in file / current bitstream - may be NULL\n\\return the ISO sample or NULL if not found or end of stream or incomplete file. Use \\ref gf_isom_last_error to check the error code\n\\note If the function returns NULL, the static_sample and its associated data are NOT destroyed\n*/\nGF_ISOSample *gf_isom_get_sample_ex(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleNumber, u32 *sampleDescriptionIndex, GF_ISOSample *static_sample, u64 *data_offset);\n\n/*! gets sample information. This is the same as \\ref gf_isom_get_sample but doesn't fetch media data\n\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleNumber the desired sample number (1-based index)\n\\param sampleDescriptionIndex set to the sample description index corresponding to this sample (optional, can be NULL)\n\\param data_offset set to the sample start offset in file (optional, can be NULL)\n\\note When both sampleDescriptionIndex and data_offset are NULL, only DTS, CTS_Offset and RAP indications are retrieved (faster)\n\\return the ISO sample without data or NULL if not found or end of stream  or incomplete file. Use \\ref gf_isom_last_error to check the error code\n*/\nGF_ISOSample *gf_isom_get_sample_info(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleNumber, u32 *sampleDescriptionIndex, u64 *data_offset);\n\n/*! gets sample information with a user-allocated sample. This is the same as \\ref gf_isom_get_sample_info but uses a static allocated sample as input\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleNumber the desired sample number (1-based index)\n\\param sampleDescriptionIndex set to the sample description index corresponding to this sample (optional, can be NULL)\n\\param data_offset set to the sample start offset in file (optional, can be NULL)\n\\note When both sampleDescriptionIndex and data_offset are NULL, only DTS, CTS_Offset and RAP indications are retrieved (faster)\n\\param static_sample a caller-allocated ISO sample to use as the returned sample\n\\return the ISO sample without data or NULL if not found or end of stream  or incomplete file. Use \\ref gf_isom_last_error to check the error code\n\\note If the function returns NULL, the static_sample and its associated data if any are NOT destroyed\n*/\nGF_ISOSample *gf_isom_get_sample_info_ex(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleNumber, u32 *sampleDescriptionIndex, u64 *data_offset, GF_ISOSample *static_sample);\n\n/*! get sample decoding time\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleNumber the desired sample number (1-based index)\n\\return decoding time in media timescale\n*/\nu64 gf_isom_get_sample_dts(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleNumber);\n\n/*! gets sample duration\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleNumber the desired sample number (1-based index)\n\\return sample duration in media timescale*/\nu32 gf_isom_get_sample_duration(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleNumber);\n\n/*! gets sample size\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleNumber the desired sample number (1-based index)\n\\return sample size in bytes*/\nu32 gf_isom_get_sample_size(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleNumber);\n\n/*! gets maximum sample size in track\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return max size of any sample in track*/\nu32 gf_isom_get_max_sample_size(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! gets average sample size in a track\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return average size of sample in track\n*/\nu32 gf_isom_get_avg_sample_size(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! gets maximum sample duration in track\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return max sample delta in media timescale\n*/\nu32 gf_isom_get_max_sample_delta(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! gets average sample duration in track, i.e. the sample delta occuring most often\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return average  sample delta in media timescale\n*/\nu32 gf_isom_get_avg_sample_delta(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! gets max sample CTS offset (CTS-DTS) in track\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return max sample cts offset in media timescale*/\nu32 gf_isom_get_max_sample_cts_offset(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! gets sample sync flag. This does not check other sample groups ('rap ' or 'sap ')\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleNumber the desired sample number (1-based index)\n\\return GF_TRUE if sample is sync, GF_FALSE otherwise*/\nBool gf_isom_get_sample_sync(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleNumber);\n\n/*! gets sample dependency flags - see ISO/IEC 14496-12 and \\ref gf_filter_pck_set_dependency_flags\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleNumber the desired sample number (1-based index)\n\\param is_leading set to 1 if sample is a leading picture\n\\param dependsOn set to the depends_on flag\n\\param dependedOn set to the depended_on flag\n\\param redundant set to the redundant flag\n\\return error if any\n*/\nGF_Err gf_isom_get_sample_flags(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleNumber, u32 *is_leading, u32 *dependsOn, u32 *dependedOn, u32 *redundant);\n\n/*! gets a sample given a desired decoding time and set the sampleDescriptionIndex of this sample\n\n\\warning The sample may not be sync even though the sync was requested (depends on the media and the editList)\nthe SampleNum is optional. If non-NULL, will contain the sampleNumber\n\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param desiredTime the desired time in media timescale\n\\param sampleDescriptionIndex set to the sample description index corresponding to this sample (optional, can be NULL)\n\\param SearchMode the search direction mode\n\\param sample set to the fetched sample if any. If NULL, sample is not fetched (optional, can be NULL)\n\\param sample_number set to the fetched sample number if any, set to 0 otherwise (optional, can be NULL)\n\\param data_offset set to the sample start offset in file (optional, can be NULL)\n\n\\return GF_EOS if the desired time exceeds the media duration or error if any\n*/\nGF_Err gf_isom_get_sample_for_media_time(GF_ISOFile *isom_file, u32 trackNumber, u64 desiredTime, u32 *sampleDescriptionIndex, GF_ISOSearchMode SearchMode, GF_ISOSample **sample, u32 *sample_number, u64 *data_offset);\n\n/*! gets sample number for a given decode time\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param dts the desired decode time in media timescale\n\\return the sample number or 0 if not found\n*/\nu32 gf_isom_get_sample_from_dts(GF_ISOFile *isom_file, u32 trackNumber, u64 dts);\n\n\n/*! enumerates the type and references IDs of a track\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param idx 0-based index of reference to query\n\\param referenceType set to the four character code of the reference entry\n\\param referenceCount set to the number of track ID references for  the reference entry\n\\return list of track IDs, NULL if no references - do NOT modify !*/\nconst GF_ISOTrackID *gf_isom_enum_track_references(GF_ISOFile *isom_file, u32 trackNumber, u32 idx, u32 *referenceType, u32 *referenceCount);\n\n/*! get the number of track references of a track for a given ReferenceType\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param referenceType the four character code of the reference to query\n\\return -1 if error or the number of references*/\ns32 gf_isom_get_reference_count(GF_ISOFile *isom_file, u32 trackNumber, u32 referenceType);\n\n/*! get the referenced track number for a track and a given ReferenceType and Index\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param referenceType the four character code of the reference to query\n\\param referenceIndex the 1-based index of the reference to query (see \\ref gf_isom_get_reference_count)\n\\param refTrack set to the track number of the referenced track\n\\return error if any\n*/\nGF_Err gf_isom_get_reference(GF_ISOFile *isom_file, u32 trackNumber, u32 referenceType, u32 referenceIndex, u32 *refTrack);\n\n/*! get the referenced track ID for a track and a given ReferenceType and Index\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param referenceType the four character code of the reference to query\n\\param referenceIndex the 1-based index of the reference to query (see \\ref gf_isom_get_reference_count)\n\\param refTrackID set to the track ID of the referenced track\n\\return error if any\n*/\nGF_Err gf_isom_get_reference_ID(GF_ISOFile *isom_file, u32 trackNumber, u32 referenceType, u32 referenceIndex, GF_ISOTrackID *refTrackID);\n\n/*! checks if a track has a reference of given type to another track\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param referenceType the four character code of the reference to query\n\\param refTrackID set to the track number of the referenced track\n\\return the reference index if the given track has a reference of type referenceType to refTreckID, 0 otherwise*/\nu32 gf_isom_has_track_reference(GF_ISOFile *isom_file, u32 trackNumber, u32 referenceType, GF_ISOTrackID refTrackID);\n\n/*! checks if a track is referenced by another track wuth the given reference type\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param referenceType the four character code of the reference to query\n\\return the track number of the first track  referencing the target track, 0 otherwise*/\nu32 gf_isom_is_track_referenced(GF_ISOFile *movie, u32 trackNumber, u32 referenceType);\n\n/*! fetches a sample for a given movie time, handling possible track edit lists.\n\nif no sample is playing, an empty sample is returned with no data and a DTS set to MovieTime when searching in sync modes\nif no sample is playing, the closest sample in the edit time-line is returned when searching in regular modes\n\n\\warning The sample may not be sync even though the sync was requested (depends on the media and the editList)\n\n\\note This function will handle re-timestamping the sample according to the mapping  of the media time-line\non the track time-line. The sample TSs (DTS / CTS offset) are expressed in MEDIA TIME SCALE\n(to match the media stream TS resolution as indicated in media header / SLConfig)\n\n\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param movieTime the desired movie time in media timescale\n\\param sampleDescriptionIndex set to the sample description index corresponding to this sample (optional, can be NULL)\n\\param SearchMode the search direction mode\n\\param sample set to the fetched sample if any. If NULL, sample is not fetched (optional, can be NULL)\n\\param sample_number set to the fetched sample number if any, set to 0 otherwise (optional, can be NULL)\n\\param data_offset set to the sample start offset in file (optional, can be NULL)\n\\return error if any\n*/\nGF_Err gf_isom_get_sample_for_movie_time(GF_ISOFile *isom_file, u32 trackNumber, u64 movieTime, u32 *sampleDescriptionIndex, GF_ISOSearchMode SearchMode, GF_ISOSample **sample, u32 *sample_number, u64 *data_offset);\n\n/*! gets edit list type\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param mediaOffset set to the media offset of the edit for time-shifting edits\n\\return GF_TRUE if complex edit list, GF_FALSE if no edit list or time-shifting only edit list, in which case mediaOffset is set to the CTS of the first sample to present at presentation time 0\nA negative value implies that the samples with CTS between 0 and mediaOffset should not be presented (skip)\nA positive value value implies that there is nothing to present between 0 and CTS (hold)\n*/\nBool gf_isom_get_edit_list_type(GF_ISOFile *isom_file, u32 trackNumber, s64 *mediaOffset);\n\n/*! gets the number of edits in an edit list\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return number of edits\n*/\nu32 gf_isom_get_edits_count(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! gets the desired edit information\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param EditIndex index of the edit to query (1-based index)\n\\param EditTime set to the edit time in movie timescale\n\\param SegmentDuration set to the edit duration in movie timescale\n\\param MediaTime set to the edit media start time in media timescale\n\\param EditMode set to the mode of the edit\n\\return error if any\n*/\nGF_Err gf_isom_get_edit(GF_ISOFile *isom_file, u32 trackNumber, u32 EditIndex, u64 *EditTime, u64 *SegmentDuration, u64 *MediaTime, GF_ISOEditType *EditMode);\n\n/*! gets the number of languages for the copyright\n\\param isom_file the target ISO file\n\\return number of languages, 0 if no copyright*/\nu32 gf_isom_get_copyright_count(GF_ISOFile *isom_file);\n\n/*! gets a copyright and its language code\n\\param isom_file the target ISO file\n\\param Index the 1-based index of the copyright notice to query\n\\param threeCharCodes set to the copyright language code\n\\param notice set to the copyright notice\n\\return error if any\n*/\nGF_Err gf_isom_get_copyright(GF_ISOFile *isom_file, u32 Index, const char **threeCharCodes, const char **notice);\n\n/*! gets the number of chapter for movie or track (chapters can be assigned to tracks or to movies)\n\\param isom_file the target ISO file\n\\param trackNumber the target track to queryy. If 0, looks for chapter at the movie level\n\\return number of chapters\n*/\nu32 gf_isom_get_chapter_count(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! gets the given chapter time and name for a movie or track\n\\param isom_file the target ISO file\n\\param trackNumber the target track to queryy. If 0, looks for chapter at the movie level\n\\param Index the index of the ckhapter to queryy\n\\param chapter_time set to chapter start time in milliseconds (optional, may be NULL)\n\\param name set to chapter name (optional, may be NULL)\n\\return error if any\n*/\nGF_Err gf_isom_get_chapter(GF_ISOFile *isom_file, u32 trackNumber, u32 Index, u64 *chapter_time, const char **name);\n\n/*! checks if a media has sync points\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return 0 if the media has no sync point info (eg, all samples are RAPs), 1 if the media has sync points (eg some samples are RAPs),  2 if the media has empty sync point info (no samples are RAPs - this will likely only happen\n\t\t\tin scalable context)\n*/\nu8 gf_isom_has_sync_points(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! gets the number of sync points in a media\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return number of sync points*/\nu32 gf_isom_get_sync_point_count(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! checks if a media track hhas composition time offset\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return 1 if the track uses unsigned compositionTime offsets (B-frames or similar), 2 if the track uses signed compositionTime offsets (B-frames or similar), 0 if the track does not use compositionTime offsets (CTS == DTS)\n*/\nu32 gf_isom_has_time_offset(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! gets cts to dts shift value if defined.\nThis shift is defined only in cases of negative CTS offset (ctts version 1) and not always present in files!\nAdding shift to CTS guarantees that the shifted CTS is always greater than the DTS for any sample\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return the shift from composition time to decode time for that track if indicated, or 0 if not found\n*/\ns64 gf_isom_get_cts_to_dts_shift(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! checks if a track has sync shadow samples (RAP samples replacing non RAP ones)\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return GF_TRUE if the track has sync shadow samples*/\nBool gf_isom_has_sync_shadows(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! checks if a track has sample dependencoes indicated\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return GF_TRUE if the track has sample dep indications*/\nBool gf_isom_has_sample_dependency(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! gets a rough estimation of file size. This only works for completely self-contained files and without fragmentation\nfor the current time\n\\param isom_file the target ISO file\n\\return estimated file size in bytes*/\nu64 gf_isom_estimate_size(GF_ISOFile *isom_file);\n\n/*! gets next alternate group ID available\n\\param isom_file the target ISO file\n\\return next available ID for alternate groups\n*/\nu32 gf_isom_get_next_alternate_group_id(GF_ISOFile *isom_file);\n\n\n/*! gets file name of an opened ISO file\n\\param isom_file the target ISO file\n\\return the file name*/\nconst char *gf_isom_get_filename(GF_ISOFile *isom_file);\n\n\n/*! gets file brand information\nThe brand is used to\n- differenciate MP4, MJPEG2000 and QT while indicating compatibilities\n- identify tools that shall be supported for correct parsing of the file\n\nThe function will set brand, minorVersion and AlternateBrandsCount to 0 if no brand indication is found in the file\n\n\\param isom_file the target ISO file\n\\param brand set to the four character code of the brand\n\\param minorVersion set to an informative integer for the minor version of the major brand (optional, can be NULL)\n\\param AlternateBrandsCount set to the number of compatible brands (optional, can be NULL).\n\\return error if any*/\nGF_Err gf_isom_get_brand_info(GF_ISOFile *isom_file, u32 *brand, u32 *minorVersion, u32 *AlternateBrandsCount);\n\n/*! gets an alternate brand indication\n\\note the Major brand should always be indicated in the alternate brands\n\\param isom_file the target ISO file\n\\param BrandIndex 1-based index of alternate brand to query (cf \\ref gf_isom_get_brand_info)\n\\param brand set to the four character code of the brand\n\\return error if any*/\nGF_Err gf_isom_get_alternate_brand(GF_ISOFile *isom_file, u32 BrandIndex, u32 *brand);\n\n/*! gets the internal list of brands\n\\param isom_file the target ISO file\n\\return the internal list of brands. DO NOT MODIFY the content\n*/\nconst u32 *gf_isom_get_brands(GF_ISOFile *isom_file);\n\n/*! gets the number of padding bits at the end of a given sample if any\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleNumber the desired sample number (1-based index)\n\\param NbBits set to the number of padded bits at the end of the sample\n\\return error if any*/\nGF_Err gf_isom_get_sample_padding_bits(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleNumber, u8 *NbBits);\n\n/*! checks if a track samples use padding bits or not\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return GF_TRUE if samples have padding bits information, GF_FALSE otherwise*/\nBool gf_isom_has_padding_bits(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! gets information of a visual track for a given sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index (1-based)\n\\param Width set to the width of the sample description in pixels\n\\param Height set to the height of the sample description in pixels\n\\return error if any*/\nGF_Err gf_isom_get_visual_info(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, u32 *Width, u32 *Height);\n\n/*! gets bit depth of a sample description of a visual track (for uncompressed media usually)\n\\param isom_file the target ISO file\n\\param trackNumber the target track number\n\\param sampleDescriptionIndex the target sample description index\n\\param bitDepth the bit depth of each pixel (eg 24 for RGB, 32 for RGBA)\n\\return error if any\n*/\nGF_Err gf_isom_get_visual_bit_depth(GF_ISOFile* isom_file, u32 trackNumber, u32 sampleDescriptionIndex, u16 *bitDepth);\n\n/*! gets information of an audio track for a given sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index (1-based)\n\\param SampleRate set to the audio sample rate of the sample description\n\\param Channels set to the audio channel count of the sample description\n\\param bitsPerSample set to the audio bits per sample for raw audio of the sample description\n\\return error if any*/\nGF_Err gf_isom_get_audio_info(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, u32 *SampleRate, u32 *Channels, u32 *bitsPerSample);\n\n/*! Audio channel layout description, ISOBMFF style*/\ntypedef struct\n{\n\t/*! stream structure flags, 1: has channel layout, 2: has objects*/\n\tu8 stream_structure;\n\n\t/*! defined CICP channel layout*/\n\tu8 definedLayout;\n\n\t/*! number of channels*/\n\tu32 channels_count;\n\tstruct {\n\t\t/*! speaker position*/\n\t\tu8 position;\n\t\t/*! speaker elevation if position==126*/\n\t\ts8 elevation;\n\t\t/*! speaker azimuth if position==126*/\n\t\ts16 azimuth;\n\t} layouts[64];\n\t/*! bit-map of omitted channels using bit positions defined in CICP - only valid if definedLayout is not 0*/\n\tu64 omittedChannelsMap;\n\t/*! number of objects in the stream*/\n\tu8 object_count;\n} GF_AudioChannelLayout;\n\n/*! get channel layout info for an audio track, ISOBMFF style\n \\param isom_file the target ISO file\n \\param trackNumber the target track\n \\param sampleDescriptionIndex the target sample description index (1-based)\n \\param layout set to the channel/object layout info for this track\n \\return GF_NOT_FOUND if not set in file, or other error if any*/\nGF_Err gf_isom_get_audio_layout(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, GF_AudioChannelLayout *layout);\n\n\n/*! gets visual track layout information\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param width set to the width of the track in pixels\n\\param height set to the height of the track in pixels\n\\param translation_x set to the horizontal translation of the track in pixels\n\\param translation_y set to the vertical translation of the track in pixels\n\\param layer set to the z-order of the track\n\\return error if any*/\nGF_Err gf_isom_get_track_layout_info(GF_ISOFile *isom_file, u32 trackNumber, u32 *width, u32 *height, s32 *translation_x, s32 *translation_y, s16 *layer);\n\n/*! gets matrix of a visual track\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param matrix set to the track matrix - all coord values are expressed as 16.16 fixed point floats\n\\return error if any*/\nGF_Err gf_isom_get_track_matrix(GF_ISOFile *isom_file, u32 trackNumber, u32 matrix[9]);\n\n/*! gets sample (pixel) aspect ratio information of a visual track for a given sample description\nThe aspect ratio is hSpacing divided by vSpacing\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index (1-based)\n\\param hSpacing horizontal spacing\n\\param vSpacing vertical spacing\n\\return error if any*/\nGF_Err gf_isom_get_pixel_aspect_ratio(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, u32 *hSpacing, u32 *vSpacing);\n\n/*! gets color information of a visual track for a given sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index (1-based)\n\\param colour_type set to the four character code of the colour type mode used (nclx, nclc, prof or ricc currently defined)\n\\param colour_primaries set to the colour primaries for nclc/nclx as defined in ISO/IEC 23001-8\n\\param transfer_characteristics set to the colour primaries for nclc/nclx as defined in ISO/IEC 23001-8\n\\param matrix_coefficients set to the colour primaries for nclc/nclx as defined in ISO/IEC 23001-8\n\\param full_range_flag set to the colour primaries for nclc as defined in ISO/IEC 23001-8\n\\return error if any*/\nGF_Err gf_isom_get_color_info(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, u32 *colour_type, u16 *colour_primaries, u16 *transfer_characteristics, u16 *matrix_coefficients, Bool *full_range_flag);\n\n\n/*! gets ICC profile\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index (1-based)\n\\param icc_restricted  set to GF_TRUE of restricted ICC profile, GF_FALSE otherwise\n\\param icc  set to profile data, NULL if none\n\\param icc_size  set to profile size, 0 if none\n\\return error if any*/\nGF_Err gf_isom_get_icc_profile(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, Bool *icc_restricted, const u8 **icc, u32 *icc_size);\n\n/*! gets clean aperture (crop window, see ISO/IEC 14496-12) for a sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track number\n\\param sampleDescriptionIndex the target sample description index\n\\param cleanApertureWidthN set to nominator of clean aperture horizontal size, may be NULL\n\\param cleanApertureWidthD set to denominator of clean aperture horizontal size, may be NULL\n\\param cleanApertureHeightN set to nominator of clean aperture vertical size, may be NULL\n\\param cleanApertureHeightD set to denominator of clean aperture vertical size, may be NULL\n\\param horizOffN set to nominator of horizontal offset of clean aperture center minus (width-1)/2 (eg 0 sets center to center of video), may be NULL\n\\param horizOffD set to denominator of horizontal offset of clean aperture center minus (width-1)/2 (eg 0 sets center to center of video), may be NULL\n\\param vertOffN set to nominator of vertical offset of clean aperture center minus (height-1)/2 (eg 0 sets center to center of video), may be NULL\n\\param vertOffD set to denominator of vertical offset of clean aperture center minus (height-1)/2 (eg 0 sets center to center of video), may be NULL\n\\return error if any\n*/\nGF_Err gf_isom_get_clean_aperture(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, u32 *cleanApertureWidthN, u32 *cleanApertureWidthD, u32 *cleanApertureHeightN, u32 *cleanApertureHeightD, s32 *horizOffN, u32 *horizOffD, s32 *vertOffN, u32 *vertOffD);\n\n/*! content light level info*/\ntypedef struct  {\n\t/*! max content ligth level*/\n\tu16 max_content_light_level;\n\t/*! max picture average ligth level*/\n\tu16 max_pic_average_light_level;\n} GF_ContentLightLevelInfo;\n\n/*! mastering display colour volume info*/\ntypedef struct  {\n\t/*! display primaries*/\n\tstruct {\n\t\tu16 x;\n\t\tu16 y;\n\t} display_primaries[3];\n\t/*! X white point*/\n\tu16 white_point_x;\n\t/*! Y white point*/\n\tu16 white_point_y;\n\tu32 max_display_mastering_luminance;\n\t/*! min display mastering luminance*/\n\tu32 min_display_mastering_luminance;\n} GF_MasteringDisplayColourVolumeInfo;\n\n/*! gets master display colour info if any\n\\param isom_file the target ISO file\n\\param trackNumber the target track number\n\\param sampleDescriptionIndex the target sample description index\n\\return the mdcv info, or NULL if none or not a valid video track\n*/\nconst GF_MasteringDisplayColourVolumeInfo *gf_isom_get_mastering_display_colour_info(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex);\n\n/*! gets content light level info if any\n\\param isom_file the target ISO file\n\\param trackNumber the target track number\n\\param sampleDescriptionIndex the target sample description index\n\\return the clli info, or NULL if none or not a valid video track\n*/\nconst GF_ContentLightLevelInfo *gf_isom_get_content_light_level_info(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex);\n\n\n/*! gets the media language code of a track\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param lang set to a newly allocated string containg 3 chars (if old files) or longer form (BCP-47) - shall be freed by caller\n\\return error if any*/\nGF_Err gf_isom_get_media_language(GF_ISOFile *isom_file, u32 trackNumber, char **lang);\n\n/*! gets the number of kind (media role) for a given track\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return number of kind defined\n*/\nu32 gf_isom_get_track_kind_count(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! gets a given kind (media role) information for a given track\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param index the 1-based index of the kind to retrieve\n\\param scheme set to the scheme of the kind information - shall be freed by caller\n\\param value set to the value of the kind information - shall be freed by caller\n\\return error if any*/\nGF_Err gf_isom_get_track_kind(GF_ISOFile *isom_file, u32 trackNumber, u32 index, char **scheme, char **value);\n\n/*! gets the magic number associated with a track. The magic number is usually set by a file muxer, and is not serialized to file\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return the magic number (0 by default)\n*/\nu64 gf_isom_get_track_magic(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! gets track group ID of a given track group type for this track\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param track_group_type the target track group type\n\\return the track group ID, 0 if not found\n*/\nu32 gf_isom_get_track_group(GF_ISOFile *isom_file, u32 trackNumber, u32 track_group_type);\n\n/*! gets track group ID of a given track group type for this track\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param idx 0-based index of enumeration, incremented by the function if success\n\\param track_group_type set to the track group type - may be NULL\n\\param track_group_id set to the track group ID - may be NULL\n\\return GF_TRUE if success, GF_FALSE otherwise\n*/\nBool gf_isom_enum_track_group(GF_ISOFile *isom_file, u32 trackNumber, u32 *idx, u32 *track_group_type, u32 *track_group_id);\n\n/*! checks if file is a single AV file with max one audio, one video, one text and basic od/bifs\n\\param isom_file the target ISO file\n\\return GF_TRUE if file is single AV, GF_FALSE otherwise\n*/\nBool gf_isom_is_single_av(GF_ISOFile *isom_file);\n\n/*! guesses which specification this file refers to.\n\\param isom_file the target ISO file\n\\return possible values are:\n\tGF_ISOM_BRAND_ISOM: unrecognized std\n\tGF_ISOM_BRAND_3GP5: 3GP file (max 1 audio, 1 video) without text track\n\tGF_ISOM_BRAND_3GP6: 3GP file (max 1 audio, 1 video) with text track\n\tGF_ISOM_BRAND_3GG6: 3GP file multitrack file\n\tGF_ISOM_BRAND_3G2A: 3GP2 file\n\tGF_ISOM_BRAND_AVC1: AVC file\n\tFCC(\"ISMA\"): ISMA file (may overlap with 3GP)\n\tGF_ISOM_BRAND_MP42: any generic MP4 file (eg with BIFS/OD/MPEG-4 systems stuff)\n\n  for files without movie, returns the file meta handler type\n*/\nu32 gf_isom_guess_specification(GF_ISOFile *isom_file);\n\n\n/*! gets the nalu_length_field size used for this sample description if NALU-based (AVC/HEVC/...)\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index (1-based)\n\\return number of bytes used to code the NALU size, or 0 if not NALU-based*/\nu32 gf_isom_get_nalu_length_field(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex);\n\n/*! gets max/average rate information as indicated in ESDS or BTRT boxes. If not found all values are set to 0\nif sampleDescriptionIndex is 0, gather for all sample descriptions\n\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index (1-based)\n\\param average_bitrate set to the average bitrate in bits per second of the media\n\\param max_bitrate set to the maximum bitrate in bits per second of the media\n\\param decode_buffer_size set to the decoder buffer size in bytes of the media\n\\return error if any*/\nGF_Err gf_isom_get_bitrate(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, u32 *average_bitrate, u32 *max_bitrate, u32 *decode_buffer_size);\n\n\n/*! gets the track template of a track. This serializes track box without serializing sample tables nor sample description info\n\\param isom_file the destination ISO file\n\\param trackNumber the destination track\n\\param output will be set to a newly allocated buffer containing the serialized box - caller shall free it\n\\param output_size will be set to the size of the allocated buffer\n\\return error if any\n*/\nGF_Err gf_isom_get_track_template(GF_ISOFile *isom_file, u32 trackNumber, u8 **output, u32 *output_size);\n\n/*! gets the trex template of a track. This serializes trex box\n\\param isom_file the destination ISO file\n\\param trackNumber the destination track\n\\param output will be set to a newly allocated buffer containing the serialized box - caller shall free it\n\\param output_size will be set to the size of the allocated buffer\n\\return error if any\n*/\nGF_Err gf_isom_get_trex_template(GF_ISOFile *isom_file, u32 trackNumber, u8 **output, u32 *output_size);\n\n/*! sets the number of removed bytes form the input bitstream when using gmem:// url\n The number of bytes shall be the total number since the opening of the movie\n\\param isom_file the target ISO file\n\\param bytes_removed number of bytes removed\n\\return error if any\n*/\nGF_Err gf_isom_set_removed_bytes(GF_ISOFile *isom_file, u64 bytes_removed);\n\n/*! gets the current file offset of the current incomplete top level box not parsed\n This shall be checked to avoid discarding bytes at or after the current top box header\n\\param isom_file the target ISO file\n\\param current_top_box_offset set to the offset from file first byte\n\\return error if any\n*/\nGF_Err gf_isom_get_current_top_box_offset(GF_ISOFile *isom_file, u64 *current_top_box_offset);\n\n/*! purges the given number of samples, starting from the first sample, from a track of a fragmented file.\n This avoids having sample tables growing in size when reading a fragmented file in pure streaming mode (no seek).\n You should always keep one sample in the track\n\\param isom_file the target ISO file\n\\param trackNumber the desired track to purge\n\\param nb_samples the number of samples to remove\n\\return error if any\n*/\nGF_Err gf_isom_purge_samples(GF_ISOFile *isom_file, u32 trackNumber, u32 nb_samples);\n\n#ifndef GPAC_DISABLE_ISOM_DUMP\n\n/*! dumps file structures into XML trace file\n\\param isom_file the target ISO file\n\\param trace the file object to dump to\n\\param skip_init does not dump init segment structure\n\\param skip_samples does not dump sample tables\n\\return error if any\n*/\nGF_Err gf_isom_dump(GF_ISOFile *isom_file, FILE *trace, Bool skip_init, Bool skip_samples);\n\n#endif /*GPAC_DISABLE_ISOM_DUMP*/\n\n\n/*! gets number of chunks in track\n\\param isom_file the target ISO file\n\\param trackNumber the desired track to purge\n\\return number of chunks in track\n*/\nu32 gf_isom_get_chunk_count(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! gets info for a given chunk in track\n\\param isom_file the target ISO file\n\\param trackNumber the desired track to purge\n\\param chunkNumber the 1-based index of the desired chunk\n\\param chunk_offset set to the chunk offset in bytes from start of file\n\\param first_sample_num set to the sample number of the first sample in the chunk\n\\param sample_per_chunk set to number of samples per chunk\n\\param sample_desc_idx set to sample desc index of samples of this chunk\n\\param cache_1 updated by function at each call. May be NULL (slower). Must be set to 0 if not querying consecutive chunks\n\\param cache_2 updated by function at each call. May be NULL (slower). Must be set to 0 if not querying consecutive chunks\n\\return error if any\n*/\nGF_Err gf_isom_get_chunk_info(GF_ISOFile *isom_file, u32 trackNumber, u32 chunkNumber, u64 *chunk_offset, u32 *first_sample_num, u32 *sample_per_chunk, u32 *sample_desc_idx, u32 *cache_1, u32 *cache_2);\n\n\n/*! gets the file offset of the first usable byte of the first mdat box in the file\n\\param isom_file the target ISO file\n\\return byte offset\n*/\nu64 gf_isom_get_first_mdat_start(GF_ISOFile *isom_file);\n\n/*! gets the size of all skip, free and wide boxes present in the file and bytes skipped during parsing (assumes a single file was opened)\n\\param isom_file the target ISO file\n\\return size\n*/\nu64 gf_isom_get_unused_box_bytes(GF_ISOFile *isom_file);\n\n/*! @} */\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n/*!\n\\addtogroup isowrite_grp ISOBMFF Writing\n\\ingroup iso_grp\n\nISOBMF file writing\n@{\n*/\n\n/*! Movie Storage modes*/\ntypedef enum\n{\n\t/*! FLAT: the MediaData is stored at the beginning of the file*/\n\tGF_ISOM_STORE_FLAT = 1,\n\t/*! STREAMABLE: the MetaData (File Info) is stored at the beginning of the file\n\tfor fast access during download*/\n\tGF_ISOM_STORE_STREAMABLE,\n\t/*! INTERLEAVED: Same as STREAMABLE, plus the media data is mixed by chunk  of fixed duration*/\n\tGF_ISOM_STORE_INTERLEAVED,\n\t/*! INTERLEAVED +DRIFT: Same as INTERLEAVED, and adds time drift control to avoid creating too long chunks*/\n\tGF_ISOM_STORE_DRIFT_INTERLEAVED,\n\t/*! tightly interleaves samples based on their DTS, therefore allowing better placement of samples in the file.\n\tThis is used for both http interleaving and Hinting optimizations*/\n\tGF_ISOM_STORE_TIGHT,\n\t/*! FASTSTART: same as FLAT but moves moov before mdat at the end*/\n\tGF_ISOM_STORE_FASTSTART,\n} GF_ISOStorageMode;\n\n/*! writes the file without deleting (see \\ref gf_isom_delete)\n\\param isom_file the target ISO file\n\\return error if any\n*/\nGF_Err gf_isom_write(GF_ISOFile *isom_file);\n\n/*! freezes order of the current box tree in the file.\nBy default the library always reorder boxes in the recommended order in the various specifications implemented.\nNew created tracks or meta items will not have a frozen order of boxes, but the function can be called several time\n\\param isom_file the target ISO file\n\\return error if any\n*/\nGF_Err gf_isom_freeze_order(GF_ISOFile *isom_file);\n\n/*! keeps UTC edit times when storing\n\\param isom_file the target ISO file\n\\param keep_utc if GF_TRUE, do not edit times\n*/\nvoid gf_isom_keep_utc_times(GF_ISOFile *isom_file, Bool keep_utc);\n\n#endif\n\n/*! Checks if UTC keeping is enabled\n\\param isom_file the target ISO file\n\\return GF_TRUE if UTC keeping is enabled\n*/\nBool gf_isom_has_keep_utc_times(GF_ISOFile *isom_file);\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n/*! sets the timescale of the movie. This rescales times expressed in movie timescale in edit lists and mvex boxes\n\\param isom_file the target ISO file\n\\param timeScale the target timescale\n\\return error if any\n*/\nGF_Err gf_isom_set_timescale(GF_ISOFile *isom_file, u32 timeScale);\n\n/*! loads a set of top-level boxes in moov udta and child boxes. UDTA will be replaced if already present\n\\param isom_file the target ISO file\n\\param moov_boxes a serialized array of boxes to add\n\\param moov_boxes_size the size of the serialized array of boxes\n\\param udta_only only replace/inject udta box and entries\n\\return error if any\n*/\nGF_Err gf_isom_load_extra_boxes(GF_ISOFile *isom_file, u8 *moov_boxes, u32 moov_boxes_size, Bool udta_only);\n\n/*! creates a new track\n\\param isom_file the target ISO file\n\\param trackID the ID of the track - if 0, the track ID is chosen by the API\n\\param MediaType the handler type (four character code) of the media\n\\param TimeScale the time scale of the media\n\\return the track number or 0 if error*/\nu32 gf_isom_new_track(GF_ISOFile *isom_file, GF_ISOTrackID trackID, u32 MediaType, u32 TimeScale);\n\n/*! creates a new track from an encoded trak box.\n\\param isom_file the target ISO file\n\\param trackID the ID of the track - if 0, the track ID is chosen by the API\n\\param MediaType the handler type (four character code) of the media\n\\param TimeScale the time scale of the media\n\\param tk_box a serialized trak box to use as template\n\\param tk_box_size the size of the serialized trak box\n\\param udta_only only replace/inject udta box and entries\n\\return the track number or 0 if error*/\nu32 gf_isom_new_track_from_template(GF_ISOFile *isom_file, GF_ISOTrackID trackID, u32 MediaType, u32 TimeScale, u8 *tk_box, u32 tk_box_size, Bool udta_only);\n\n/*! removes a track - internal cross dependencies will be updated.\n\\warning Any OD streams with references to this track through  ODUpdate, ESDUpdate, ESDRemove commands\nwill be rewritten\n\\param isom_file the target ISO file\n\\param trackNumber the target track to remove file\n\\return error if any\n*/\nGF_Err gf_isom_remove_track(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! sets the enable flag of a track\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param enableTrack if GF_TRUE, track is enabled, otherwise disabled\n\\return error if any\n*/\nGF_Err gf_isom_set_track_enabled(GF_ISOFile *isom_file, u32 trackNumber, Bool enableTrack);\n\n/*! Track header flags operation type*/\ntypedef enum\n{\n\t/*! set flags, erasing previous value*/\n\tGF_ISOM_TKFLAGS_SET = 1,\n\t/*! add flags*/\n\tGF_ISOM_TKFLAGS_REM,\n\t/*! remove flags*/\n\tGF_ISOM_TKFLAGS_ADD,\n} GF_ISOMTrackFlagOp;\n\n#endif //GPAC_DISABLE_ISOM_WRITE\n\n/*! Track header flags*/\nenum\n{\n\t/*! track is enabled */\n\tGF_ISOM_TK_ENABLED = 1,\n\t/*! track is in regular presentation*/\n\tGF_ISOM_TK_IN_MOVIE = 1<<1,\n\t/*! track is in preview*/\n\tGF_ISOM_TK_IN_PREVIEW = 1<<2,\n\t/*! track size is an aspect ratio indicator only*/\n\tGF_ISOM_TK_SIZE_IS_AR = 1<<3\n};\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n/*! toggles track flags on or off\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param flags flags to modify\n\\param op flag operation mode\n\\return error if any\n*/\nGF_Err gf_isom_set_track_flags(GF_ISOFile *isom_file, u32 trackNumber, u32 flags, GF_ISOMTrackFlagOp op);\n\n/*! sets creationTime and modificationTime of the movie to the specified dates (no validty check)\n\\param isom_file the target ISO file\n\\param create_time the new creation time\n\\param modif_time the new modification time\n\\return error if any\n*/\nGF_Err gf_isom_set_creation_time(GF_ISOFile *isom_file, u64 create_time, u64 modif_time);\n\n/*! sets creationTime and modificationTime of the track to the specified dates\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param create_time the new creation time\n\\param modif_time the new modification time\n\\return error if any\n*/\nGF_Err gf_isom_set_track_creation_time(GF_ISOFile *isom_file, u32 trackNumber, u64 create_time, u64 modif_time);\n\n/*! sets creationTime and modificationTime of the track media header to the specified dates\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param create_time the new creation time\n\\param modif_time the new modification time\n\\return error if any\n*/\nGF_Err gf_isom_set_media_creation_time(GF_ISOFile *isom_file, u32 trackNumber, u64 create_time, u64 modif_time);\n\n/*! changes the ID of a track - all track references present in the file are updated\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param trackID the new track ID\n\\return error if trackID is already in used in the file*/\nGF_Err gf_isom_set_track_id(GF_ISOFile *isom_file, u32 trackNumber, GF_ISOTrackID trackID);\n\n/*! forces to rewrite all dependencies when track ID changes. Used to check if track references are broken during import of a single track\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return error if any\n*/\nGF_Err gf_isom_rewrite_track_dependencies(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! adds a sample to a track\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index associated with the sample\n\\param sample the target sample to add\n\\return error if any\n*/\nGF_Err gf_isom_add_sample(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, const GF_ISOSample *sample);\n\n/*! copies all sample dependency, subSample and sample group information from the given sampleNumber in source file to the last added sample in dest file\n\\param dst the destination ISO file\n\\param dst_track the destination track\n\\param src the source ISO file\n\\param src_track the source track\n\\param sampleNumber the source sample number\n\\return error if any\n*/\nGF_Err gf_isom_copy_sample_info(GF_ISOFile *dst, u32 dst_track, GF_ISOFile *src, u32 src_track, u32 sampleNumber);\n\n/*! adds a sync shadow sample to a track.\n- There must be a regular sample with the same DTS.\n- Sync Shadow samples MUST be RAP and can only use the same sample description as the sample they shadow\n- Currently, adding sync shadow must be done in order (no sample insertion)\n\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sample the target shadow sample to add\n\\return error if any\n*/\nGF_Err gf_isom_add_sample_shadow(GF_ISOFile *isom_file, u32 trackNumber, GF_ISOSample *sample);\n\n/*! adds data to current sample in the track. This will update the data size.\nCANNOT be used with OD media type\nThere shall not be any other\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param data the data to append to the sample\n\\param data_size the size of the data to append\n\\return error if any\n*/\nGF_Err gf_isom_append_sample_data(GF_ISOFile *isom_file, u32 trackNumber, u8 *data, u32 data_size);\n\n/*! adds sample references to a track\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index associated with the sample\n\\param sample the target sample to add\n\\param dataOffset is the offset in bytes of the data in the referenced file.\n\\return error if any\n*/\nGF_Err gf_isom_add_sample_reference(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, GF_ISOSample *sample, u64 dataOffset);\n\n/*! sets the duration of the last media sample. If not set, the duration of the last sample is the\nduration of the previous one if any, or media TimeScale (default value). This does not modify the edit list if any,\nyou must modify this using \\ref gf_isom_set_edit\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param duration duration of last sample in media timescale\n\\return error if any\n*/\nGF_Err gf_isom_set_last_sample_duration(GF_ISOFile *isom_file, u32 trackNumber, u32 duration);\n\n/*! sets the duration of the last media sample. If not set, the duration of the last sample is the\nduration of the previous one if any, or media TimeScale (default value). This does not modify the edit list if any,\nyou must modify this using \\ref gf_isom_set_edit.\nIf both dur_num and dur_den are both zero, forces last sample duration to be the same as previous sample\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param dur_num duration num value\n\\param dur_den duration num value\n\\return error if any\n*/\nGF_Err gf_isom_set_last_sample_duration_ex(GF_ISOFile *isom_file, u32 trackNumber, u32 dur_num, u32 dur_den);\n\n/*! patches last stts entry to make sure the cumulated duration equals the given next_dts value - this will overrite timing of all previous samples using an average dur\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param next_dts target decode time of next sample\n\\return error if any\n*/\nGF_Err gf_isom_patch_last_sample_duration(GF_ISOFile *isom_file, u32 trackNumber, u64 next_dts);\n\n/*! adds a track reference to another track\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param referenceType the four character code of the reference\n\\param ReferencedTrackID the ID of the track referred to\n\\return error if any\n*/\nGF_Err gf_isom_set_track_reference(GF_ISOFile *isom_file, u32 trackNumber, u32 referenceType, GF_ISOTrackID ReferencedTrackID);\n\n/*! removes all track references\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return error if any\n*/\nGF_Err gf_isom_remove_track_references(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! removes any track reference poiting to a non-existing track\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return error if any\n*/\nGF_Err gf_isom_purge_track_reference(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! removes all track references of a given type\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param ref_type the reference type to remove\n\\return error if any\n*/\nGF_Err gf_isom_remove_track_reference(GF_ISOFile *isom_file, u32 trackNumber, u32 ref_type);\n\n/*! sets track handler name.\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param nameUTF8 the handler name; either NULL (reset), a UTF-8 formatted string or a UTF8 file resource in the form \"file://path/to/file_utf8\"\n\\return error if any\n*/\nGF_Err gf_isom_set_handler_name(GF_ISOFile *isom_file, u32 trackNumber, const char *nameUTF8);\n\n/*! updates the sample size table - this is needed when using \\ref gf_isom_append_sample_data in case the resulting samples\nare of same sizes (typically in 3GP speech tracks)\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return error if any\n*/\nGF_Err gf_isom_refresh_size_info(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! updates the duration of the movie.This is done automatically when storing the file or editing timesales/edit list, but it is not done when adding samples.\n\\param isom_file the target ISO file\n\\return error if any\n*/\nGF_Err gf_isom_update_duration(GF_ISOFile *isom_file);\n\n\n/*! updates a given sample of the media. This function updates both media data of sample and sample properties (DTS, CTS, SAP type)\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleNumber the number of the sample to update\n\\param sample the new sample\n\\param data_only if set to GF_TRUE, only the sample data is updated, not other info\n\\return error if any\n*/\nGF_Err gf_isom_update_sample(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleNumber, GF_ISOSample *sample, Bool data_only);\n\n/*! updates a sample reference in the media. Note that the sample MUST exists, and that sample->data MUST be NULL and sample->dataLength must be NON NULL.\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleNumber the number of the sample to update\n\\param sample the new sample\n\\param data_offset new offset of sample in referenced file\n\\return error if any\n*/\nGF_Err gf_isom_update_sample_reference(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleNumber, GF_ISOSample *sample, u64 data_offset);\n\n/*! removes a given sample\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleNumber the number of the sample to update\n\\return error if any\n*/\nGF_Err gf_isom_remove_sample(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleNumber);\n\n\n/*! changes media time scale\n\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param new_timescale the new timescale to set\n\\param new_tsinc if not 0, changes sample duration and composition offsets to new_tsinc/new_timescale. If non-constant sample dur is used, uses the samllest sample dur in the track. Otherwise, only changes the timescale\n\\param force_rescale_type type fo rescaling, Ignored if new_tsinc is not 0:\n - if set to 0, rescale timings.\n - if set to 1, only the media timescale is changed but media times are not updated.\n - if set to 2,  media timescale is updated if new_timescale is set, and all sample durations are set to new_tsinc\n\\return GF_EOS if no action taken (same config), or error if any\n*/\nGF_Err gf_isom_set_media_timescale(GF_ISOFile *isom_file, u32 trackNumber, u32 new_timescale, u32 new_tsinc, u32 force_rescale_type);\n\n\n\n/*! adds sample auxiliary data\n\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleNumber the sample number. Must be equal or larger to last auxiliary\n\\param aux_type auxiliary sample data type, shall not be 0\n\\param aux_info auxiliary sample data specific info type, may be 0\n\\param data data to add\n\\param size size of data to add\n\\return error if any\n*/\nGF_Err gf_isom_add_sample_aux_info(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleNumber, u32 aux_type, u32 aux_info, u8 *data, u32 size);\n\n/*! sets the save file name of the (edited) movie.\nIf the movie is edited, the default fileName is the open name suffixed with an internally defined extension \"%p_isotmp\")\"\n\\note you cannot save an edited file under the same name (overwrite not allowed)\nIf the movie is created (WRITE mode), the default filename is $OPEN_NAME\n\n\\param isom_file the target ISO file\n\\param filename the new final filename\n\\return error if any\n*/\nGF_Err gf_isom_set_final_name(GF_ISOFile *isom_file, char *filename);\n\n/*! sets the storage mode of a file (FLAT, STREAMABLE, INTERLEAVED)\n\\param isom_file the target ISO file\n\\param storage_mode the target storage mode\n\\return error if any\n*/\nGF_Err gf_isom_set_storage_mode(GF_ISOFile *isom_file, GF_ISOStorageMode storage_mode);\n\n/*! sets the interleaving time of media data (INTERLEAVED mode only)\n\\param isom_file the target ISO file\n\\param InterleaveTime the target interleaving time in movie timescale\n\\return error if any\n*/\nGF_Err gf_isom_set_interleave_time(GF_ISOFile *isom_file, u32 InterleaveTime);\n\n/*! forces usage of 64 bit chunk offsets\n\\param isom_file the target ISO file\n\\param set_on if GF_TRUE, 64 bit chunk offsets are always used; otherwise, they are used only for large files\n\\return error if any\n*/\nGF_Err gf_isom_force_64bit_chunk_offset(GF_ISOFile *isom_file, Bool set_on);\n\n/*! compression mode of top-level boxes*/\ntypedef enum\n{\n\t/*! no compression is used*/\n\tGF_ISOM_COMP_NONE=0,\n\t/*! only moov box is compressed*/\n\tGF_ISOM_COMP_MOOV,\n\t/*! only moof boxes are compressed*/\n\tGF_ISOM_COMP_MOOF,\n\t/*! only moof and sidx boxes are compressed*/\n\tGF_ISOM_COMP_MOOF_SIDX,\n\t/*! only moof,  sidx and ssix boxes are compressed*/\n\tGF_ISOM_COMP_MOOF_SSIX,\n\t/*! all (moov, moof,  sidx and ssix) boxes are compressed*/\n\tGF_ISOM_COMP_ALL,\n} GF_ISOCompressMode;\n\nenum\n{\n\t/*! forces compressed box even if compress size is larger than uncompressed size*/\n\tGF_ISOM_COMP_FORCE_ALL\t=\t0x01,\n\t/*! wraps ftyp in otyp*/\n\tGF_ISOM_COMP_WRAP_FTYPE\t=\t0x02,\n};\n\n\n/*! sets compression mode of file\n\\param isom_file the target ISO file\n\\param compress_mode the desired compress mode\n\\param compress_flags compress mode flags\n\\return error if any\n*/\nGF_Err gf_isom_enable_compression(GF_ISOFile *isom_file, GF_ISOCompressMode compress_mode, u32 compress_flags);\n\n/*! sets the copyright in one language\n\\param isom_file the target ISO file\n\\param threeCharCode the ISO three character language code for copyright\n\\param notice the copyright notice to add\n\\return error if any\n*/\nGF_Err gf_isom_set_copyright(GF_ISOFile *isom_file, const char *threeCharCode, char *notice);\n\n/*! adds a kind type to a track\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param schemeURI the scheme URI of the added kind\n\\param value the value of the added kind\n\\return error if any\n*/\nGF_Err gf_isom_add_track_kind(GF_ISOFile *isom_file, u32 trackNumber, const char *schemeURI, const char *value);\n\n/*! removes a kind type to the track, all if NULL params\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param schemeURI the scheme URI of the removed kind\n\\param value the value of the removed kind\n\\return error if any\n*/\nGF_Err gf_isom_remove_track_kind(GF_ISOFile *isom_file, u32 trackNumber, const char *schemeURI, const char *value);\n\n/*! changes the handler type of the media\n\\warning This may completely breaks the parsing of the media track\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param new_type the new handler four character type\n\\return error if any\n*/\nGF_Err gf_isom_set_media_type(GF_ISOFile *isom_file, u32 trackNumber, u32 new_type);\n\n/*! changes the type of the sampleDescriptionBox\n\\warning This may completely breaks the parsing of the media track\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\param new_type the new four character code type of the smaple description\n\\return error if any\n*/\nGF_Err gf_isom_set_media_subtype(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, u32 new_type);\n\n/*! sets a track in an alternate group\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param groupId the alternate group ID\n\\return error if any\n*/\nGF_Err gf_isom_set_alternate_group_id(GF_ISOFile *isom_file, u32 trackNumber, u32 groupId);\n\n/*! adds chapter info:\n\n\\param isom_file the target ISO file\n\\param trackNumber the target track. If 0, the chapter info is added to the movie, otherwise to the track\n\\param timestamp the chapter start time in milliseconds. Chapters are added in order to the file. If a chapter with same timestamp\n\tis found, its name is updated but no entry is created.\n\\param name the chapter name. If NULL, defaults to 'Chapter N'\n\\return error if any\n*/\nGF_Err gf_isom_add_chapter(GF_ISOFile *isom_file, u32 trackNumber, u64 timestamp, char *name);\n\n/*! deletes copyright\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param index the 1-based index of the copyright notice to remove, or 0 to remove all chapters\n\\return error if any\n*/\nGF_Err gf_isom_remove_chapter(GF_ISOFile *isom_file, u32 trackNumber, u32 index);\n\n/*! updates or inserts a new edit in the track time line. Edits are used to modify\nthe media normal timing. EditTime and EditDuration are expressed in movie timescale\n\\note If a segment with EditTime already exists, it is erase\n\\note If there is a segment before this new one, its duration is adjust to match EditTime of the new segment\n\\warning The first segment always have an EditTime of 0. You should insert an empty or dwelled segment first\n\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param EditTime the start of the edit in movie timescale\n\\param EditDuration the duration of the edit in movie timecale\n\\param MediaTime the corresponding media time of the start of the edit, in media timescale. -1 for empty edits\n\\param EditMode the edit mode\n\\return error if any, GF_EOS if empty edit was inserted \n*/\nGF_Err gf_isom_set_edit(GF_ISOFile *isom_file, u32 trackNumber, u64 EditTime, u64 EditDuration, u64 MediaTime, GF_ISOEditType EditMode);\n\n\n\n/*! updates or inserts a new edit in the track time line. Edits are used to modify\nthe media normal timing. EditTime and EditDuration are expressed in movie timescale\n\\note If a segment with EditTime already exists, it is erase\n\\note If there is a segment before this new one, its duration is adjust to match EditTime of the new segment\n\\warning The first segment always have an EditTime of 0. You should insert an empty or dwelled segment first\n\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param EditTime the start of the edit in movie timescale\n\\param EditDuration the duration of the edit in movie timecale\n\\param MediaTime the corresponding media time of the start of the edit, in media timescale. -1 for empty edits\n\\param MediaRate a 16.16 rate (0x10000 means normal playback)\n\\return error if any\n*/\nGF_Err gf_isom_set_edit_with_rate(GF_ISOFile *isom_file, u32 trackNumber, u64 EditTime, u64 EditDuration, u64 MediaTime, u32 MediaRate);\n\n\n/*! same as \\ref gf_isom_set_edit except only modifies duration type and mediaType\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param edit_index the 1-based index of the edit to update\n\\param EditDuration duration of the edit in movie timescale\n\\param MediaTime the corresponding media time of the start of the edit, in media timescale. -1 for empty edits\n\\param EditMode the edit mode\n\\return error if any\n*/\nGF_Err gf_isom_modify_edit(GF_ISOFile *isom_file, u32 trackNumber, u32 edit_index, u64 EditDuration, u64 MediaTime, GF_ISOEditType EditMode);\n\n/*! same as \\ref gf_isom_modify_edit except only appends new segment\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param EditDuration duration of the edit in movie timescale\n\\param MediaTime the corresponding media time of the start of the edit, in media timescale. -1 for empty edits\n\\param EditMode the edit mode\n\\return error if any\n*/\nGF_Err gf_isom_append_edit(GF_ISOFile *isom_file, u32 trackNumber, u64 EditDuration, u64 MediaTime, GF_ISOEditType EditMode);\n\n/*! removes all edits in the track\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return error if any\n*/\nGF_Err gf_isom_remove_edits(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! removes the given edit. If this is not the last segment, the next segment duration is updated to maintain a continous timeline\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param edit_index the 1-based index of the edit to update\n\\return error if any\n*/\nGF_Err gf_isom_remove_edit(GF_ISOFile *isom_file, u32 trackNumber, u32 edit_index);\n\n/*! updates edit list after track edition. All edit entries with a duration or media starttime larger than the media duration are clamped to media duration\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return error if any\n*/\nGF_Err gf_isom_update_edit_list_duration(GF_ISOFile *isom_file, u32 trackNumber);\n\n\n/*! remove track, moov or file-level UUID box of matching type\n\\param isom_file the target ISO file\n\\param trackNumber the target track for the UUID box; if 0, removes from movie; if 0xFFFFFFFF, removes from file\n\\param UUID the UUID of the box to remove\n\\return error if any\n*/\nGF_Err gf_isom_remove_uuid(GF_ISOFile *isom_file, u32 trackNumber, bin128 UUID);\n\n/*! adds track, moov or file-level UUID box\n\\param isom_file the target ISO file\n\\param trackNumber the target track for the UUID box; if 0, removes from movie; if 0xFFFFFFFF, removes from file\n\\param UUID the UUID of the box to remove\n\\param data the data to add, may be NULL\n\\param size the size of the data to add, shall be 0 when data is NULL\n\\return error if any\n*/\nGF_Err gf_isom_add_uuid(GF_ISOFile *isom_file, u32 trackNumber, bin128 UUID, const u8 *data, u32 size);\n\n/*! uses a compact track version for sample size. This is not usually recommended\nexcept for speech codecs where the track has a lot of small samples\ncompaction is done automatically while writing based on the track's sample sizes\n\\param isom_file the target ISO file\n\\param trackNumber the target track for the udta box; if 0, add the udta to the movie;\n\\param CompactionOn if set to GF_TRUE, compact size tables are used; otherwise regular size tables are used\n\\return error if any\n*/\nGF_Err gf_isom_use_compact_size(GF_ISOFile *isom_file, u32 trackNumber, Bool CompactionOn);\n\n/*! disabled brand rewrite for file, usually done for temporary import in an existing file\n\\param isom_file the target ISO file\n\\param do_disable if true, brand rewrite is disabled, otherwise enabled\n\\return error if any\n*/\nGF_Err gf_isom_disable_brand_rewrite(GF_ISOFile *isom_file, Bool do_disable);\n\n/*! sets the brand of the movie\n\\note this automatically adds the major brand to the set of alternate brands if not present\n\\param isom_file the target ISO file\n\\param MajorBrand four character code of the major brand to set\n\\param MinorVersion version of the brand\n\\return error if any\n*/\nGF_Err gf_isom_set_brand_info(GF_ISOFile *isom_file, u32 MajorBrand, u32 MinorVersion);\n\n/*! adds or removes an alternate brand for the movie.\n\\note When removing an alternate brand equal to the major brand, the major brand is updated with the first alternate brand remaining, or 'isom' otherwise\n\\param isom_file the target ISO file\n\\param Brand four character code of the brand to add or remove\n\\param AddIt if set to GF_TRUE, the brand is added, otherwise it is removed\n\\return error if any\n*/\nGF_Err gf_isom_modify_alternate_brand(GF_ISOFile *isom_file, u32 Brand, Bool AddIt);\n\n/*! removes all alternate brands except major brand\n\\param isom_file the target ISO file\n\\return error if any\n*/\nGF_Err gf_isom_reset_alt_brands(GF_ISOFile *isom_file);\n\n/*! removes all alternate brands except major brand\n\\param isom_file the target ISO file\n\\param leave_empty if GF_TRUE, does not create a default alternate brand matching the major brand\n\\return error if any\n*/\nGF_Err gf_isom_reset_alt_brands_ex(GF_ISOFile *isom_file, Bool leave_empty);\n\n/*! set sample dependency flags - see ISO/IEC 14496-12 and \\ref gf_filter_pck_set_dependency_flags\n\\param isom_file the target ISO file\n\\param trackNumber the target track number\n\\param sampleNumber the target sample number\n\\param isLeading indicates that the sample is a leading picture\n\\param dependsOn indicates the sample dependency towards other samples\n\\param dependedOn indicates the sample dependency from other samples\n\\param redundant indicates that the sample contains redundant coding\n\\return error if any\n*/\nGF_Err gf_isom_set_sample_flags(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleNumber, u32 isLeading, u32 dependsOn, u32 dependedOn, u32 redundant);\n\n/*! sets size information of a sample description of a visual track\n\\param isom_file the target ISO file\n\\param trackNumber the target track number\n\\param sampleDescriptionIndex the target sample description index\n\\param Width the width in pixels\n\\param Height the height in pixels\n\\return error if any\n*/\nGF_Err gf_isom_set_visual_info(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, u32 Width, u32 Height);\n\n/*! sets bit depth of a sample description of a visual track (for uncompressed media usually)\n\\param isom_file the target ISO file\n\\param trackNumber the target track number\n\\param sampleDescriptionIndex the target sample description index\n\\param bitDepth the bit depth of each pixel (eg 24 for RGB, 32 for RGBA)\n\\return error if any\n*/\nGF_Err gf_isom_set_visual_bit_depth(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, u16 bitDepth);\n\n/*! sets a visual track layout info\n\\param isom_file the target ISO file\n\\param trackNumber the target track number\n\\param width the track width in pixels\n\\param height the track height in pixels\n\\param translation_x the horizontal translation (from the left) of the track in the movie canvas, expressed as 16.16 fixed point float\n\\param translation_y the vertical translation (from the top) of the track in the movie canvas, expressed as 16.16 fixed point float\n\\param layer z order of the track on the canvas\n\\return error if any\n*/\nGF_Err gf_isom_set_track_layout_info(GF_ISOFile *isom_file, u32 trackNumber, u32 width, u32 height, s32 translation_x, s32 translation_y, s16 layer);\n\n/*! sets track matrix\n\\param isom_file the target ISO file\n\\param trackNumber the target track number\n\\param matrix the transformation matrix of the track on the movie canvas; all coeficients are expressed as 16.16 floating points\n\\return error if any\n */\nGF_Err gf_isom_set_track_matrix(GF_ISOFile *isom_file, u32 trackNumber, s32 matrix[9]);\n\n/*! sets the pixel aspect ratio for a sample description\n\\note the aspect ratio is expressed as hSpacing divided by vSpacing; 2:1 means pixel is twice as wide as it is high\n\\param isom_file the target ISO file\n\\param trackNumber the target track number\n\\param sampleDescriptionIndex the target sample description index\n\\param hSpacing horizontal spacing of the aspect ratio; a value of 0 removes PAR; negative value means 1\n\\param vSpacing vertical spacing of the aspect ratio; a value of 0 removes PAR; negative value means 1\n\\param force_par if set, forces PAR to 1:1 when hSpacing=vSpacing; otherwise removes PAR when hSpacing=vSpacing\n\\return error if any\n*/\nGF_Err gf_isom_set_pixel_aspect_ratio(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, s32 hSpacing, s32 vSpacing, Bool force_par);\n\n/*! sets clean aperture (crop window, see ISO/IEC 14496-12) for a sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track number\n\\param sampleDescriptionIndex the target sample description index\n\\param cleanApertureWidthN nominator of clean aperture horizontal size\n\\param cleanApertureWidthD denominator of clean aperture horizontal size\n\\param cleanApertureHeightN nominator of clean aperture vertical size\n\\param cleanApertureHeightD denominator of clean aperture vertical size\n\\param horizOffN nominator of horizontal offset of clean aperture center minus (width-1)/2 (eg 0 sets center to center of video)\n\\param horizOffD denominator of horizontal offset of clean aperture center minus (width-1)/2 (eg 0 sets center to center of video)\n\\param vertOffN nominator of vertical offset of clean aperture center minus (height-1)/2 (eg 0 sets center to center of video)\n\\param vertOffD denominator of vertical offset of clean aperture center minus (height-1)/2 (eg 0 sets center to center of video)\n\\return error if any\n*/\nGF_Err gf_isom_set_clean_aperture(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, u32 cleanApertureWidthN, u32 cleanApertureWidthD, u32 cleanApertureHeightN, u32 cleanApertureHeightD, s32 horizOffN, u32 horizOffD, s32 vertOffN, u32 vertOffD);\n\n/*! updates track aperture information for QT/ProRes\n\\param isom_file the target ISO file\n\\param trackNumber the target track number\n\\param remove if GF_TRUE, remove track aperture information, otherwise updates it\n\\return error if any\n*/\nGF_Err gf_isom_update_aperture_info(GF_ISOFile *isom_file, u32 trackNumber, Bool remove);\n\n\n/*! sets high dynamic range information for a sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track number\n\\param sampleDescriptionIndex the target sample description index\n\\param mdcv the mastering display colour volume to set, if NULL removes the info\n\\param clli the content light level to set, if NULL removes the info\n\\return error if any\n*/\nGF_Err gf_isom_set_high_dynamic_range_info(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, GF_MasteringDisplayColourVolumeInfo *mdcv, GF_ContentLightLevelInfo *clli);\n\n/*! force Dolby Vision profile: mainly used when the bitstream doesn't contain all the necessary information\n\\param isom_file the target ISO file\n\\param trackNumber the target track number\n\\param sampleDescriptionIndex the target sample description index\n\\param dvcc the Dolby Vision configuration\n\\return error if any\n*/\nGF_Err gf_isom_set_dolby_vision_profile(GF_ISOFile* isom_file, u32 trackNumber, u32 sampleDescriptionIndex, GF_DOVIDecoderConfigurationRecord *dvcc);\n\n\n/*! sets image sequence coding constraints (mostly used for HEIF image files)\n\\param isom_file the target ISO file\n\\param trackNumber the target track number\n\\param sampleDescriptionIndex the target sample description index\n\\param remove if set to GF_TRUE, removes coding constraints\n\\param all_ref_pics_intra indicates if all reference pictures are intra frames\n\\param intra_pred_used indicates if intra prediction is used\n\\param max_ref_per_pic indicates the max number of reference images per picture\n\\return error if any\n */\nGF_Err gf_isom_set_image_sequence_coding_constraints(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, Bool remove, Bool all_ref_pics_intra, Bool intra_pred_used, u32 max_ref_per_pic);\n\n/*! sets image sequence alpha flag (mostly used for HEIF image files). The alpha flag indicates the image sequence is an alpha plane\nor has an alpha channel\n\\param isom_file the target ISO file\n\\param trackNumber the target track number\n\\param sampleDescriptionIndex the target sample description index\n\\param remove if set to GF_TRUE, removes coding constraints\n\\return error if any\n*/\nGF_Err gf_isom_set_image_sequence_alpha(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, Bool remove);\n\n/*! sets colour information for a sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track number\n\\param sampleDescriptionIndex the target sample description index\n\\param colour_type the four character code of the colour type to set (nclc, nclx, prof, ricc); if 0, removes all color info\n\\param colour_primaries the colour primaries for nclc/nclx as defined in ISO/IEC 23001-8\n\\param transfer_characteristics the colour primaries for nclc/nclx as defined in ISO/IEC 23001-8\n\\param matrix_coefficients the colour primaries for nclc/nclx as defined in ISO/IEC 23001-8\n\\param full_range_flag the colour primaries for nclc as defined in ISO/IEC 23001-8\n\\param icc_data the icc data pto set for prof and ricc types\n\\param icc_size the size of the icc data\n\\return error if any\n*/\nGF_Err gf_isom_set_visual_color_info(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, u32 colour_type, u16 colour_primaries, u16 transfer_characteristics, u16 matrix_coefficients, Bool full_range_flag, u8 *icc_data, u32 icc_size);\n\n\n/*! Audio Sample Description signaling mode*/\ntypedef enum {\n\t/*! use ISOBMF sample entry v0*/\n\tGF_IMPORT_AUDIO_SAMPLE_ENTRY_NOT_SET = 0,\n\t/*! use ISOBMF sample entry v0*/\n\tGF_IMPORT_AUDIO_SAMPLE_ENTRY_v0_BS,\n\t/*! use ISOBMF sample entry v0 and forces channel count to 2*/\n\tGF_IMPORT_AUDIO_SAMPLE_ENTRY_v0_2,\n\t/*! use ISOBMF sample entry v1*/\n\tGF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_MPEG,\n\t/*! use QTFF sample entry v1*/\n\tGF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_QTFF\n} GF_AudioSampleEntryImportMode;\n\n\n/*! sets audio format  information for a sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track number\n\\param sampleDescriptionIndex the target sample description index\n\\param sampleRate the audio sample rate\n\\param nbChannels the number of audio channels\n\\param bitsPerSample the number of bits per sample, mostly used for raw audio\n\\param asemode type of audio entry signaling desired\n\\return error if any\n*/\nGF_Err gf_isom_set_audio_info(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, u32 sampleRate, u32 nbChannels, u8 bitsPerSample, GF_AudioSampleEntryImportMode asemode);\n\n\n/*! sets audio channel and object layout  information for a sample description, ISOBMFF style\n\\param isom_file the target ISO file\n\\param trackNumber the target track number\n\\param sampleDescriptionIndex the target sample description index\n\\param layout the layout information\n\\return error if any\n*/\nGF_Err gf_isom_set_audio_layout(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, GF_AudioChannelLayout *layout);\n\n/*! sets CTS unpack mode (used for B-frames & like): in unpack mode, each sample uses one entry in CTTS tables\n\n\\param isom_file the target ISO file\n\\param trackNumber the target track number\n\\param unpack if GF_TRUE, sets unpack on, creating a ctts table if none found; if GF_FALSE, sets unpack off and repacks all table info\n\\return error if any\n*/\nGF_Err gf_isom_set_cts_packing(GF_ISOFile *isom_file, u32 trackNumber, Bool unpack);\n\n/*! shifts all CTS with the given offset. This MUST be called in unpack mode only\n\\param isom_file the target ISO file\n\\param trackNumber the target track number\n\\param offset_shift CTS offset shift in media timescale\n\\return error if any\n*/\nGF_Err gf_isom_shift_cts_offset(GF_ISOFile *isom_file, u32 trackNumber, s32 offset_shift);\n\n/*! enables negative composition offset in track\n\\note this will compute the composition to decode time information\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param use_negative_offsets if GF_TRUE, negative offsets are used, otherwise they are disabled\n\\return error if any\n*/\nGF_Err gf_isom_set_composition_offset_mode(GF_ISOFile *isom_file, u32 trackNumber, Bool use_negative_offsets);\n\n/*! enables negative composition offset in track and shift offsets\n\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param ctts_shift shif CTS offsets by the given time in media timescale if positive offsets only are used\n\\return error if any\n*/\nGF_Err gf_isom_set_ctts_v1(GF_ISOFile *isom_file, u32 trackNumber, u32 ctts_shift);\n\n\n/*! sets language for a track\n\\param isom_file the target ISO file\n\\param trackNumber the target track number\n\\param code 3-character code or BCP-47 code media language\n\\return error if any\n*/\nGF_Err gf_isom_set_media_language(GF_ISOFile *isom_file, u32 trackNumber, char *code);\n\n/*! gets the ID of the last created track\n\\param isom_file the target ISO file\n\\return the last created track ID\n*/\nGF_ISOTrackID gf_isom_get_last_created_track_id(GF_ISOFile *isom_file);\n\n/*! applies a box patch to the file. See examples in gpac test suite, media/boxpatch/\n\\param isom_file the target ISO file\n\\param trackID the ID of the track to patch, in case one of the box patch applies to a track\n\\param box_patch_filename the name of the file containing the box patches\n\\param for_fragments indicates if the patch targets movie fragments or regular moov\n\\return error if any\n*/\nGF_Err gf_isom_apply_box_patch(GF_ISOFile *isom_file, GF_ISOTrackID trackID, const char *box_patch_filename, Bool for_fragments);\n\n/*! sets track magic number\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param magic the magic number to set; magic number is not written to file\n\\return error if any\n*/\nGF_Err gf_isom_set_track_magic(GF_ISOFile *isom_file, u32 trackNumber, u64 magic);\n\n/*! sets track index in moov\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param index the 1-based index to set. Tracks will be reordered after this!\n\\param track_num_changed callback function used to notify track changes during the call to this function\n\\param udta opaque user data for the callback function\n\\return error if any\n*/\nGF_Err gf_isom_set_track_index(GF_ISOFile *isom_file, u32 trackNumber, u32 index, void (*track_num_changed)(void *udta, u32 old_track_num, u32 new_track_num), void *udta);\n\n/*! removes a sample description with the given index\n\\warning This does not remove any added samples for that stream description, nor rewrite the sample to chunk and other boxes referencing the sample description index !\n\\param isom_file the target ISO file\n\\param trackNumber the target track number\n\\param sampleDescriptionIndex the target sample description to remove\n\\return error if any\n*/\nGF_Err gf_isom_remove_stream_description(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex);\n\n/*! updates average and max bitrate of a sample description\nif both average_bitrate and max_bitrate are 0, this removes any bitrate information\n\\param isom_file the target ISO file\n\\param trackNumber the target track number\n\\param sampleDescriptionIndex the target sample description\n\\param average_bitrate the average bitrate of the media for that sample description\n\\param max_bitrate the maximum bitrate of the media for that sample description\n\\param decode_buffer_size the decoder buffer size in bytes for that sample description\n\\return error if any\n*/\nGF_Err gf_isom_update_bitrate(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, u32 average_bitrate, u32 max_bitrate, u32 decode_buffer_size);\n\n\n/*! track clone flags*/\ntypedef enum\n{\n\t/*! set this flag to keep data reference entries while cloning track*/\n\tGF_ISOM_CLONE_TRACK_KEEP_DREF = 1,\n\t/*! set this flag to avoid cloning track as a QT track while cloning track*/\n\tGF_ISOM_CLONE_TRACK_NO_QT = 1<<1,\n\t/*! drop track ID while importing*/\n\tGF_ISOM_CLONE_TRACK_DROP_ID = 1<<2,\n\t/*! reset media duration when cloning */\n\tGF_ISOM_CLONE_RESET_DURATION = 1<<3\n} GF_ISOTrackCloneFlags;\n\n/*! clones a track. This clones everything except media data and sample info (DTS, CTS, RAPs, etc...), and also clones sample descriptions\n\\param orig_file the source ISO file\n\\param orig_track the source track\n\\param dest_file the destination ISO file\n\\param flags flags to use during clone\n\\param dest_track set to the track number of cloned track\n\\return error if any\n*/\nGF_Err gf_isom_clone_track(GF_ISOFile *orig_file, u32 orig_track, GF_ISOFile *dest_file, GF_ISOTrackCloneFlags flags, u32 *dest_track);\n\n\n/*! sets the GroupID of a track (only used for optimized interleaving). By setting GroupIDs\nyou can specify the storage order for media data of a group of streams. This is useful\nfor BIFS presentation so that static resources of the scene can be downloaded before BIFS\n\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param GroupID the desired group ID\n\\return error if any\n*/\nGF_Err gf_isom_set_track_interleaving_group(GF_ISOFile *isom_file, u32 trackNumber, u32 GroupID);\n\n/*! sets the priority of a track within a Group (used for optimized interleaving and hinting).\nThis allows tracks to be stored before other within a same group, for instance the\nhint track data can be stored just before the media data, reducing disk seeking\n\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param InversePriority the desired priority. For a same time, within a group of tracks, the track with the lowest InversePriority will\nbe written first\n\\return error if any\n*/\nGF_Err gf_isom_set_track_priority_in_group(GF_ISOFile *isom_file, u32 trackNumber, u32 InversePriority);\n\n/*! sets the maximum chunk size for a track\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param maxChunkSize the maximum chunk size in bytes\n\\return error if any\n*/\nGF_Err gf_isom_hint_max_chunk_size(GF_ISOFile *isom_file, u32 trackNumber, u32 maxChunkSize);\n\n/*! sets the maximum chunk duration for a track\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param maxChunkDur the maximum chunk duration in media timescale\n\\return error if any\n*/\nGF_Err gf_isom_hint_max_chunk_duration(GF_ISOFile *isom_file, u32 trackNumber, u32 maxChunkDur);\n\n/*! sets up interleaving for storage (shortcut for storeage mode + interleave_time)\n\\param isom_file the target ISO file\n\\param TimeInSec the desired interleaving time in seconds\n\\return error if any\n*/\nGF_Err gf_isom_make_interleave(GF_ISOFile *isom_file, Double TimeInSec);\n\n/*! sets up interleaving for storage (shortcut for storeage mode + interleave_time)\n\\param isom_file the target ISO file\n\\param fTimeInSec the desired interleaving time in seconds, as a fraction\n\\return error if any\n*/\nGF_Err gf_isom_make_interleave_ex(GF_ISOFile *isom_file, GF_Fraction *fTimeInSec);\n\n/*! sets progress callback when writing a file\n\\param isom_file the target ISO file\n\\param progress_cbk the progress callback function\n\\param progress_cbk_udta opaque data passed to the progress callback function\n*/\nvoid gf_isom_set_progress_callback(GF_ISOFile *isom_file, void (*progress_cbk)(void *udta, u64 nb_done, u64 nb_total), void *progress_cbk_udta);\n\n/*! sets write callback functions for in-memory file writing\n\\param isom_file the target ISO file\n\\param on_block_out the block write callback function\n\\param on_block_patch the block patch callback function\n\\param on_last_block_start called before writing the last block of a sequence of movie fragments\n\\param usr_data opaque user data passed to callback functions\n\\param block_size desired block size in bytes\n\\return error if any\n*/\nGF_Err gf_isom_set_write_callback(GF_ISOFile *isom_file,\n\t\t\tGF_Err (*on_block_out)(void *cbk, u8 *data, u32 block_size, void *cbk_data, u32 cbk_magic),\n\t\t\tGF_Err (*on_block_patch)(void *usr_data, u8 *block, u32 block_size, u64 block_offset, Bool is_insert),\n \t\t\tvoid (*on_last_block_start)(void *cbk),\n \t\t\tvoid *usr_data,\n \t\t\tu32 block_size);\n\n/*! checks if file will use in-place rewriting or not\n\\param isom_file the target ISO file\n\\return GF_TRUE if in-place rewrite is used, GF_FALSE otherwise\n*/\nBool gf_isom_is_inplace_rewrite(GF_ISOFile *isom_file);\n\n/*! Disables inplace rewrite. Once in-place rewrite  is disabled, the file can no longer be rewrittten in place.\n\n In-place rewriting allows editing the file structure (ftyp, moov and meta boxes) without modifying the media data size.\n\n In-place rewriting is disabled for any of the following:\n - specifying a storage mode using  \\ref gf_isom_set_storage_mode\n - removing or adding tracks or items\n - removing, adding or updating samples\n - using stdout, redirect file \"_gpac_isobmff_redirect\",  memory file \" gmem://\"\n\nIn-place rewriting is enabled by default on files open in edit mode.\n\n\\param isom_file the target ISO file\n*/\nvoid gf_isom_disable_inplace_rewrite(GF_ISOFile *isom_file);\n\n/*! sets amount of bytes to reserve after moov for future in-place editing. This may be ignored depending on the final write mode\n\\param isom_file the target ISO file\n\\param padding amount of bytes to reserve\n\\return error if any\n*/\nGF_Err gf_isom_set_inplace_padding(GF_ISOFile *isom_file, u32 padding);\n\n/*! @} */\n\n#endif // GPAC_DISABLE_ISOM_WRITE\n\n/*!\n\\addtogroup isomp4sys_grp ISOBMFF MPEG-4 Systems\n\\ingroup iso_grp\n\nMPEG-4 Systems extensions\n@{\n*/\n\n\n/*! MPEG-4 ProfileAndLevel codes*/\ntypedef enum\n{\n\t/*! Audio PL*/\n\tGF_ISOM_PL_AUDIO,\n\t/*! Visual PL*/\n\tGF_ISOM_PL_VISUAL,\n\t/*! Graphics PL*/\n\tGF_ISOM_PL_GRAPHICS,\n\t/*! Scene PL*/\n\tGF_ISOM_PL_SCENE,\n\t/*! OD PL*/\n\tGF_ISOM_PL_OD,\n\t/*! MPEG-J PL*/\n\tGF_ISOM_PL_MPEGJ,\n\t/*! not a profile, just set/unset inlineFlag*/\n\tGF_ISOM_PL_INLINE,\n} GF_ISOProfileLevelType;\n\n/*! gets MPEG-4 subtype of a sample description entry (eg, mp4a, mp4v, enca, encv, resv, etc...)\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index (1-based)\n\\return the media type FOUR CHAR code type of an MPEG4 media, or 0 if not MPEG-4 subtype\n */\nu32 gf_isom_get_mpeg4_subtype(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex);\n\n/*! fetches the root OD of a file  (can be NULL, OD or IOD, you have to check its tag)\n\\param isom_file the target ISO file\n\\return the OD/IOD if any. Caller must destroy the descriptor\n*/\nGF_Descriptor *gf_isom_get_root_od(GF_ISOFile *isom_file);\n\n/*! disable OD conversion from ISOM internal to regular OD tags\n\\param isom_file the target ISO file\n\\param disable if TRUE, ODs and ESDs will not be converted\n*/\nvoid gf_isom_disable_odf_conversion(GF_ISOFile *isom_file, Bool disable);\n\n/*! checks the presence of a track in rood OD/IOD\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return 0: NO, 1: YES, 2: ERROR*/\nu8 gf_isom_is_track_in_root_od(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! gets the GF_ESD given the sampleDescriptionIndex\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index (1-based)\n\\return the ESD associated to the sample description index, or NULL if error or not supported. Caller must destroy the ESD*/\nGF_ESD *gf_isom_get_esd(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex);\n\n/*! gets the decoderConfigDescriptor given the sampleDescriptionIndex\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index (1-based)\n\\return the decoder configuration descriptor associated to the sample description index, or NULL if error or not supported. Caller must destroy the descriptor\n*/\nGF_DecoderConfig *gf_isom_get_decoder_config(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex);\n\n/*! sets default TrackID (or ES_ID) for clock references.\n\\param isom_file the target ISO file\n\\param trackNumber the target track to set as a clock reference. If 0, default sync track ID is reseted and will be reassigned at next ESD fetch*/\nvoid gf_isom_set_default_sync_track(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! gets the profile and level value for MPEG-4 streams\n\\param isom_file the target ISO file\n\\param PL_Code the target profile to query file\n\\return the profile and level value, 0xFF if not defined\n*/\nu8 gf_isom_get_pl_indication(GF_ISOFile *isom_file, GF_ISOProfileLevelType PL_Code);\n\n/*! finds the first ObjectDescriptor using the given track by inspecting all OD tracks\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return the OD ID if dound, 0 otherwise*/\nu32 gf_isom_find_od_id_for_track(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! sets a profile and level indication for the movie iod (created if needed)\n\\note Use for MPEG-4 Systems only\nif the flag is ProfileLevel is 0 this means the movie doesn't require\nthe specific codec (equivalent to 0xFF value in MPEG profiles)\n\\param isom_file the target ISO file\n\\param PL_Code the profile and level code to set\n\\param ProfileLevel the profile and level value to set\n\\return error if any\n*/\nGF_Err gf_isom_set_pl_indication(GF_ISOFile *isom_file, GF_ISOProfileLevelType PL_Code, u8 ProfileLevel);\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n/*! sets the rootOD ID of the movie if you need it. By default, movies are created without root ODs\n\\note Use for MPEG-4 Systems only\n\\param isom_file the target ISO file\n\\param OD_ID ID to assign to the root OD/IOD\n\\return error if any\n*/\nGF_Err gf_isom_set_root_od_id(GF_ISOFile *isom_file, u32 OD_ID);\n\n/*! sets the rootOD URL of the movie if you need it (only needed to create an empty file pointing\nto external resource)\n\\note Use for MPEG-4 Systems only\n\\param isom_file the target ISO file\n\\param url_string the URL to assign to the root OD/IOD\n\\return error if any\n*/\nGF_Err gf_isom_set_root_od_url(GF_ISOFile *isom_file, const char *url_string);\n\n/*! removes the root OD\n\\note Use for MPEG-4 Systems only\n\\param isom_file the target ISO file\n\\return error if any\n*/\nGF_Err gf_isom_remove_root_od(GF_ISOFile *isom_file);\n\n/*! adds a system descriptor to the OD of the movie\n\\note Use for MPEG-4 Systems only\n\\param isom_file the target ISO file\n\\param theDesc the descriptor to add\n\\return error if any\n*/\nGF_Err gf_isom_add_desc_to_root_od(GF_ISOFile *isom_file, const GF_Descriptor *theDesc);\n\n/*! adds a track to the root OD\n\\note Use for MPEG-4 Systems only\n\\param isom_file the target ISO file\n\\param trackNumber the track to add to the root OD\n\\return error if any\n*/\nGF_Err gf_isom_add_track_to_root_od(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! removes a track to the root OD\n\\note Use for MPEG-4 Systems only\n\\param isom_file the target ISO file\n\\param trackNumber the track to remove from the root OD\n\\return error if any\n*/\nGF_Err gf_isom_remove_track_from_root_od(GF_ISOFile *isom_file, u32 trackNumber);\n\n\n/*! creates a new MPEG-4 sample description in a track\n\n\\note Used for MPEG-4 Systems, AAC and MPEG-4 Visual (part 2)\n\n\\param isom_file the target ISO file\n\\param trackNumber the target track number\n\\param esd the ESD to use for that sample description\n\\param URLname URL value of the data reference, NULL if no data reference (media in the file)\n\\param URNname URN value of the data reference, NULL if no data reference (media in the file)\n\\param outDescriptionIndex set to index of the new sample description\n\\return error if any\n*/\nGF_Err gf_isom_new_mpeg4_description(GF_ISOFile *isom_file, u32 trackNumber, const GF_ESD *esd, const char *URLname, const char *URNname, u32 *outDescriptionIndex);\n\n/*! changes an MPEG-4 sample description\n\\note Used for MPEG-4 Systems, AAC and MPEG-4 Visual (part 2)\n\\warning This will replace the whole ESD\n\\param isom_file the target ISO file\n\\param trackNumber the target track number\n\\param sampleDescriptionIndex the target sample description\n\\param newESD the new ESD to use for that sample description\n\\return error if any\n*/\nGF_Err gf_isom_change_mpeg4_description(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, const GF_ESD *newESD);\n\n/*! adds an MPEG-4 systems descriptor to the ESD of a sample description\n\\note Used for MPEG-4 Systems, AAC and MPEG-4 Visual (part 2)\n\\warning This will replace the whole ESD\n\\param isom_file the target ISO file\n\\param trackNumber the target track number\n\\param sampleDescriptionIndex the target sample description\n\\param theDesc the descriptor to add to the ESD of the sample description\n\\return error if any\n*/\nGF_Err gf_isom_add_desc_to_description(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, const GF_Descriptor *theDesc);\n\n/*! clones IOD PLs from orig to dest if any\n\\param orig_file the source ISO file\n\\param dest_file the destination ISO file\n\\return error if any\n*/\nGF_Err gf_isom_clone_pl_indications(GF_ISOFile *orig_file, GF_ISOFile *dest_file);\n\n/*deletes chapter (1-based index, index 0 for all)*/\nGF_Err gf_isom_remove_chapter(GF_ISOFile *the_file, u32 trackNumber, u32 index);\n\n/*! associates a given SL config with a given ESD while extracting the OD information\nThis is useful while reading the IOD / OD stream of an MP4 file. Note however that\nonly full AUs are extracted, therefore the calling application must SL-packetize the streams\n\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex set to the sample description index corresponding to this sample (optional, can be NULL)\n\\param slConfig the SL configuration descriptor to set. The descriptor is copied by the API for further use. A NULL pointer will result\nin using the default SLConfig (predefined = 2) remapped to predefined = 0\n\\return error if any\n*/\nGF_Err gf_isom_set_extraction_slc(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, const GF_SLConfig *slConfig);\n\n#endif //GPAC_DISABLE_ISOM_WRITE\n\n\n/*! @} */\n\n/*!\n\\addtogroup isostsd_grp ISOBMFF Sample Descriptions\n\\ingroup iso_grp\n\nSample Description functions are used to query and set codec parameters of a track\n\n@{\n*/\n\n/*! Unknown sample description*/\ntypedef struct\n{\n\t/*! codec tag is the containing box's tag, 0 if UUID is used*/\n\tu32 codec_tag;\n\t/*! entry UUID if no tag is used*/\n\tbin128 UUID;\n\t/*! codec version*/\n\tu16 version;\n\t/*! codec revision*/\n\tu16 revision;\n\t/*! vendor four character code*/\n\tu32 vendor_code;\n\n\t/*! temporal quality, video codecs only*/\n\tu32 temporal_quality;\n\t/*! spatial quality, video codecs only*/\n\tu32 spatial_quality;\n\t/*! width in pixels, video codecs only*/\n\tu16 width;\n\t/*! height in pixels, video codecs only*/\n\tu16 height;\n\t/*! horizontal resolution as 16.16 fixed point, video codecs only*/\n\tu32 h_res;\n\t/*! vertical resolution as 16.16 fixed point, video codecs only*/\n\tu32 v_res;\n\t/*! bit depth resolution in bits, video codecs only*/\n\tu16 depth;\n\t/*! color table, video codecs only*/\n\tu16 color_table_index;\n\t/*! compressor name, video codecs only*/\n\tchar compressor_name[33];\n\n\t/*! sample rate, audio codecs only*/\n\tu32 samplerate;\n\t/*! number of channels, audio codecs only*/\n\tu16 nb_channels;\n\t/*! bits per sample, audio codecs only*/\n\tu16 bits_per_sample;\n\t/*! indicates if QTFF signaling should be used, audio codecs only*/\n\tBool is_qtff;\n\t/*! for lpcm only, indicates format flags*/\n\tu32 lpcm_flags;\n\n\t/*optional, sample description specific configuration*/\n\tu8 *extension_buf;\n\t/*optional, sample description specific size*/\n\tu32 extension_buf_size;\n\t/*optional, wraps sample description specific data into a box if given type*/\n\tu32 ext_box_wrap;\n} GF_GenericSampleDescription;\n\n/*! gets an unknown sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index (1-based)\n\\return generic sample description information, or NULL if error\n*/\nGF_GenericSampleDescription *gf_isom_get_generic_sample_description(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex);\n\n/*! gets the decoder configuration of a JP2 file\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index (1-based)\n\\param out_dsi set to the decoder configuration - shall be freed by user\n\\param out_size set to the decoder configuration size\n\\return error if any\n*/\nGF_Err gf_isom_get_jp2_config(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, u8 **out_dsi, u32 *out_size);\n\n\n\n/*! gets RVC (Reconvigurable Video Coding) config of a track for a given sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index (1-based)\n\\param rvc_predefined set to a predefined value of RVC\n\\param data set to the RVC config buffer if not predefined, NULL otherwise\n\\param size set to the RVC config buffer size\n\\param mime set to the associated mime type of the stream\n\\return error if any*/\nGF_Err gf_isom_get_rvc_config(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, u16 *rvc_predefined, u8 **data, u32 *size, const char **mime);\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n/*! sets the RVC config for the given track sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track number\n\\param sampleDescriptionIndex the target sample description index\n\\param rvc_predefined the predefined RVC configuration code, 0 if not predefined\n\\param mime the associated mime type of the video\n\\param data the RVC configuration data; ignored if rvc_predefined is not 0\n\\param size the size of the RVC configuration data; ignored if rvc_predefined is not 0\n\\return error if any\n*/\nGF_Err gf_isom_set_rvc_config(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, u16 rvc_predefined, char *mime, u8 *data, u32 size);\n\n\n/*! updates fields of given visual sample description - these fields are reserved in ISOBMFF, this should only be used for QT, see QTFF\n\\param isom_file the target ISO file\n\\param trackNumber the target track number\n\\param sampleDescriptionIndex the target sample description\n\\param revision revision of the sample description format\n\\param vendor four character code of the vendor\n\\param temporalQ temporal quality\n\\param spatialQ spatial quality\n\\param horiz_res horizontal resolution as 16.16 fixed point number\n\\param vert_res vertical resolution as 16.16 fixed point number\n\\param frames_per_sample number of frames per media samples\n\\param compressor_name human readable name for the compressor\n\\param color_table_index color table index, use -1 if no color table (most common case)\n\\return error if any\n*/\nGF_Err gf_isom_update_video_sample_entry_fields(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, u16 revision, u32 vendor, u32 temporalQ, u32 spatialQ, u32 horiz_res, u32 vert_res, u16 frames_per_sample, const char *compressor_name, s16 color_table_index);\n\n/*! updates a sample description from a serialized sample description box. Only child boxes are removed in the process\n\\param isom_file the target ISO file\n\\param trackNumber the target track number\n\\param sampleDescriptionIndex the target sample description\n\\param data a serialized sample description box\n\\param size size of the serialized sample description\n\\return error if any\n*/\nGF_Err gf_isom_update_sample_description_from_template(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, u8 *data, u32 size);\n\n\n/*! creates a new unknown StreamDescription in the file.\n\\note use this to store media not currently supported by the ISO media format or media types not implemented in this library\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param URLname URL value of the data reference, NULL if no data reference (media in the file)\n\\param URNname URN value of the data reference, NULL if no data reference (media in the file)\n\\param udesc generic sample description information to use\n\\param outDescriptionIndex set to index of the new sample description\n\\return error if any\n*/\nGF_Err gf_isom_new_generic_sample_description(GF_ISOFile *isom_file, u32 trackNumber, const char *URLname, const char *URNname, GF_GenericSampleDescription *udesc, u32 *outDescriptionIndex);\n\n/*! clones a sample description without inspecting media types\n\\param isom_file the destination ISO file\n\\param trackNumber the destination track\n\\param orig_file the source ISO file\n\\param orig_track the source track\n\\param orig_desc_index the source sample description to clone\n\\param URLname URL value of the data reference, NULL if no data reference (media in the file)\n\\param URNname URN value of the data reference, NULL if no data reference (media in the file)\n\\param outDescriptionIndex set to index of the new sample description\n\\return error if any\n*/\nGF_Err gf_isom_clone_sample_description(GF_ISOFile *isom_file, u32 trackNumber, GF_ISOFile *orig_file, u32 orig_track, u32 orig_desc_index, const char *URLname, const char *URNname, u32 *outDescriptionIndex);\n\n/*! gets the sample description template of a track. This serializes sample description box\n\\param isom_file the destination ISO file\n\\param trackNumber the destination track\n\\param sampleDescriptionIndex the target sample description\n\\param output will be set to a newly allocated buffer containing the serialized box - caller shall free it\n\\param output_size will be set to the size of the allocated buffer\n\\return error if any\n*/\nGF_Err gf_isom_get_stsd_template(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, u8 **output, u32 *output_size);\n\n#endif // GPAC_DISABLE_ISOM_WRITE\n\n/*! checks if sample descriptions are the same. This does include self-contained checking and reserved flags. The specific media cfg (DSI & co) is not analysed, only a memory comparaison is done\n\\param f1 the first ISO file\n\\param tk1 the first track\n\\param sdesc_index1 the first sample description\n\\param f2 the second ISO file\n\\param tk2 the second track\n\\param sdesc_index2 the second sample description\n\\return GF_TRUE if sample descriptions match, GF_FALSE otherwise\n*/\nBool gf_isom_is_same_sample_description(GF_ISOFile *f1, u32 tk1, u32 sdesc_index1, GF_ISOFile *f2, u32 tk2, u32 sdesc_index2);\n\n\n/*! Generic 3GP/3GP2 config record*/\ntypedef struct\n{\n\t/*GF_4CC record type, one fo the above GF_ISOM_SUBTYPE_3GP_ * subtypes*/\n\tu32 type;\n\t/*4CC vendor name*/\n\tu32 vendor;\n\t/*codec version*/\n\tu8 decoder_version;\n\t/*number of sound frames per IsoMedia sample, >0 and <=15. The very last sample may contain less frames. */\n\tu8 frames_per_sample;\n\t/*H263 ONLY - Level*/\n\tu8 H263_level;\n\t/*H263 Profile*/\n\tu8 H263_profile;\n\t/*AMR(WB) ONLY - num of mode for the codec*/\n\tu16 AMR_mode_set;\n\t/*AMR(WB) ONLY - changes in codec mode per sample*/\n\tu8 AMR_mode_change_period;\n} GF_3GPConfig;\n\n\n/*! gets a 3GPP sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\return the 3GP config for this sample description, NULL if not a 3GPP track\n*/\nGF_3GPConfig *gf_isom_3gp_config_get(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex);\n#ifndef GPAC_DISABLE_ISOM_WRITE\n/*! creates a 3GPP sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param config the 3GP config for this sample description\n\\param URLname URL value of the data reference, NULL if no data reference (media in the file)\n\\param URNname URN value of the data reference, NULL if no data reference (media in the file)\n\\param outDescriptionIndex set to the index of the created sample description\n\\return error if any\n*/\nGF_Err gf_isom_3gp_config_new(GF_ISOFile *isom_file, u32 trackNumber, GF_3GPConfig *config, const char *URLname, const char *URNname, u32 *outDescriptionIndex);\n/*! updates the 3GPP config - subtypes shall NOT differ\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param config the 3GP config for this sample description\n\\param sampleDescriptionIndex the target sample description index\n\\return error if any\n*/\nGF_Err gf_isom_3gp_config_update(GF_ISOFile *isom_file, u32 trackNumber, GF_3GPConfig *config, u32 sampleDescriptionIndex);\n#endif\t/*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/*! gets AVC config for a sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\return the AVC config - user is responsible for deleting it\n*/\nGF_AVCConfig *gf_isom_avc_config_get(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex);\n/*! gets SVC config for a sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\return the SVC config - user is responsible for deleting it\n*/\nGF_AVCConfig *gf_isom_svc_config_get(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex);\n/*! gets MVC config for a sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\return the SVC config - user is responsible for deleting it\n*/\nGF_AVCConfig *gf_isom_mvc_config_get(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex);\n\n/*! AVC familiy type*/\ntypedef enum\n{\n\t/*! not an AVC codec*/\n\tGF_ISOM_AVCTYPE_NONE=0,\n\t/*! AVC only*/\n\tGF_ISOM_AVCTYPE_AVC_ONLY,\n\t/*! AVC+SVC in same track*/\n\tGF_ISOM_AVCTYPE_AVC_SVC,\n\t/*! SVC only*/\n\tGF_ISOM_AVCTYPE_SVC_ONLY,\n\t/*! AVC+MVC in same track*/\n\tGF_ISOM_AVCTYPE_AVC_MVC,\n\t/*! SVC only*/\n\tGF_ISOM_AVCTYPE_MVC_ONLY,\n} GF_ISOMAVCType;\n\n/*! gets the AVC family type for a sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target hint track\n\\param sampleDescriptionIndex the target sample description index\n\\return the type of AVC media\n*/\nGF_ISOMAVCType gf_isom_get_avc_svc_type(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex);\n\n/*! HEVC family type*/\ntypedef enum\n{\n\t/*! not an HEVC codec*/\n\tGF_ISOM_HEVCTYPE_NONE=0,\n\t/*! HEVC only*/\n\tGF_ISOM_HEVCTYPE_HEVC_ONLY,\n\t/*! HEVC+LHVC in same track*/\n\tGF_ISOM_HEVCTYPE_HEVC_LHVC,\n\t/*! LHVC only*/\n\tGF_ISOM_HEVCTYPE_LHVC_ONLY,\n} GF_ISOMHEVCType;\n\n/*! gets the HEVC family type for a sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\return the type of HEVC media\n*/\nGF_ISOMHEVCType gf_isom_get_hevc_lhvc_type(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex);\n\n/*! gets HEVC config for a sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\return the HEVC config - user is responsible for deleting it\n*/\nGF_HEVCConfig *gf_isom_hevc_config_get(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex);\n/*! gets LHVC config for a sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\return the LHVC config - user is responsible for deleting it\n*/\nGF_HEVCConfig *gf_isom_lhvc_config_get(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex);\n\n/*! VVC family type*/\ntypedef enum\n{\n\t/*! not an VVC codec*/\n\tGF_ISOM_VVCTYPE_NONE=0,\n\t/*! VVC only*/\n\tGF_ISOM_VVCTYPE_ONLY,\n\t/*! VVC subpicture track*/\n\tGF_ISOM_VVCTYPE_SUBPIC,\n\t/*! VVC non-VCL only*/\n\tGF_ISOM_VVCTYPE_NVCL,\n} GF_ISOMVVCType;\n\n/*! gets the VVC family type for a sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\return the type of VVC media\n*/\nGF_ISOMVVCType gf_isom_get_vvc_type(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex);\n\n/*! gets VVC config for a sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\return the VVC config - user is responsible for deleting it\n*/\nGF_VVCConfig *gf_isom_vvc_config_get(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex);\n\n/*! gets AV1 config for a sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\return the AV1 config - user is responsible for deleting it\n*/\nGF_AV1Config *gf_isom_av1_config_get(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex);\n\n/*! gets VP8/9 config for a sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\return the VP8/9 config - user is responsible for deleting it\n*/\nGF_VPConfig *gf_isom_vp_config_get(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex);\n\n/*! gets DOVI config for a sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\return the DOVI config - user is responsible for deleting it\n*/\nGF_DOVIDecoderConfigurationRecord* gf_isom_dovi_config_get(GF_ISOFile* isom_file, u32 trackNumber, u32 sampleDescriptionIndex);\n\n/*! checks if some tracks in file needs layer reconstruction\n\\param isom_file the target ISO file\n\\return GF_TRUE if track dependencies implying extractors or implicit reconstruction are found, GF_FALSE otherwise\n*/\nBool gf_isom_needs_layer_reconstruction(GF_ISOFile *isom_file);\n\n/*! NALU extract modes and flags*/\ntypedef enum\n{\n\t/*! all extractors are rewritten*/\n\tGF_ISOM_NALU_EXTRACT_DEFAULT = 0,\n\t/*! all extractors are skipped but NALU data from this track is kept*/\n\tGF_ISOM_NALU_EXTRACT_LAYER_ONLY,\n\t/*! all extractors are kept (untouched sample) - used for dumping modes*/\n\tGF_ISOM_NALU_EXTRACT_INSPECT,\n\t/*! above mode is applied and PPS/SPS/... are appended in the front of every IDR*/\n\tGF_ISOM_NALU_EXTRACT_INBAND_PS_FLAG = 1<<16,\n\t/*! above mode is applied and all start codes are rewritten (xPS inband as well)*/\n\tGF_ISOM_NALU_EXTRACT_ANNEXB_FLAG = 2<<17,\n\t/*! above mode is applied and VDRD NAL unit is inserted before SVC slice*/\n\tGF_ISOM_NALU_EXTRACT_VDRD_FLAG = 1<<18,\n\t/*! all extractors are skipped and only tile track data is kept*/\n\tGF_ISOM_NALU_EXTRACT_TILE_ONLY = 1<<19\n} GF_ISONaluExtractMode;\n\n/*! sets the NALU extraction mode for this track\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param nalu_extract_mode the NALU extraction mode to set\n\\return error if any\n*/\nGF_Err gf_isom_set_nalu_extract_mode(GF_ISOFile *isom_file, u32 trackNumber, GF_ISONaluExtractMode nalu_extract_mode);\n/*! gets the NALU extraction mode for this track\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return the NALU extraction mode used\n*/\nGF_ISONaluExtractMode gf_isom_get_nalu_extract_mode(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! gets the composition offset shift if any for track using negative ctts\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return the composition offset shift or 0\n*/\ns32 gf_isom_get_composition_offset_shift(GF_ISOFile *isom_file, u32 trackNumber);\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n/*! creates a new AVC sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param cfg the AVC config for this sample description\n\\param URLname URL value of the data reference, NULL if no data reference (media in the file)\n\\param URNname URN value of the data reference, NULL if no data reference (media in the file)\n\\param outDescriptionIndex set to the index of the created sample description\n\\return error if any\n*/\nGF_Err gf_isom_avc_config_new(GF_ISOFile *isom_file, u32 trackNumber, GF_AVCConfig *cfg, const char *URLname, const char *URNname, u32 *outDescriptionIndex);\n/*! updates an AVC sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index to update\n\\param cfg the AVC config for this sample description\n\\return error if any\n*/\nGF_Err gf_isom_avc_config_update(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, GF_AVCConfig *cfg);\n\n/*! creates a new SVC sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param cfg the SVC config for this sample description\n\\param URLname URL value of the data reference, NULL if no data reference (media in the file)\n\\param URNname URN value of the data reference, NULL if no data reference (media in the file)\n\\param outDescriptionIndex set to the index of the created sample description\n\\return error if any\n*/\nGF_Err gf_isom_svc_config_new(GF_ISOFile *isom_file, u32 trackNumber, GF_AVCConfig *cfg, const char *URLname, const char *URNname, u32 *outDescriptionIndex);\n/*! updates an SVC sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index to update\n\\param cfg the AVC config for this sample description\n\\param is_additional if set, the SVCConfig will be added to the AVC sample description, otherwise the sample description will be SVC-only\n\\return error if any\n*/\nGF_Err gf_isom_svc_config_update(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, GF_AVCConfig *cfg, Bool is_additional);\n/*! deletes an SVC sample description\n\\warning Associated samples if any are NOT deleted\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index to delete\n\\return error if any\n*/\nGF_Err gf_isom_svc_config_del(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex);\n\n/*! creates a new MVC sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param cfg the SVC config for this sample description\n\\param URLname URL value of the data reference, NULL if no data reference (media in the file)\n\\param URNname URN value of the data reference, NULL if no data reference (media in the file)\n\\param outDescriptionIndex set to the index of the created sample description\n\\return error if any\n*/\nGF_Err gf_isom_mvc_config_new(GF_ISOFile *isom_file, u32 trackNumber, GF_AVCConfig *cfg, const char *URLname, const char *URNname, u32 *outDescriptionIndex);\n\n/*! updates an MVC sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index to update\n\\param cfg the AVC config for this sample description\n\\param is_additional if set, the MVCConfig will be added to the AVC sample description, otherwise the sample description will be MVC-only\n\\return error if any\n*/\nGF_Err gf_isom_mvc_config_update(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, GF_AVCConfig *cfg, Bool is_additional);\n\n/*! deletes an MVC sample description\n\\warning Associated samples if any are NOT deleted\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index to delete\n\\return error if any\n*/\nGF_Err gf_isom_mvc_config_del(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex);\n\n/*! sets avc3 entry type (inband SPS/PPS) instead of avc1 (SPS/PPS in avcC box)\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\param keep_xps if set to GF_TRUE, keeps parameter set in the configuration record otherwise removes them\n\\return error if any\n*/\nGF_Err gf_isom_avc_set_inband_config(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, Bool keep_xps);\n\n/*! sets hev1 entry type (inband SPS/PPS) instead of hvc1 (SPS/PPS in hvcC box)\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\param keep_xps if set to GF_TRUE, keeps parameter set in the configuration record otherwise removes them\n\\return error if any\n*/\nGF_Err gf_isom_hevc_set_inband_config(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, Bool keep_xps);\n\n/*! sets lhe1 entry type instead of lhc1 but keep lhcC box intact\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\return error if any\n*/\nGF_Err gf_isom_lhvc_force_inband_config(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex);\n\n/*! sets hvt1 entry type (tile track) or hev2/hvc2 type if is_base_track is set. It is the use responsibility to set the tbas track reference to the base hevc track\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\param cfg may be set to the tile track configuration to indicate sub-profile of the tile, or NULL\n\\param is_base_track if set to GF_TRUE, indicates this is a tile base track, otherwise this is a tile track\n\\return error if any\n*/\nGF_Err gf_isom_hevc_set_tile_config(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, GF_HEVCConfig *cfg, Bool is_base_track);\n\n/*! creates a new HEVC sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param cfg the HEVC config for this sample description\n\\param URLname URL value of the data reference, NULL if no data reference (media in the file)\n\\param URNname URN value of the data reference, NULL if no data reference (media in the file)\n\\param outDescriptionIndex set to the index of the created sample description\n\\return error if any\n*/\nGF_Err gf_isom_hevc_config_new(GF_ISOFile *isom_file, u32 trackNumber, GF_HEVCConfig *cfg, const char *URLname, const char *URNname, u32 *outDescriptionIndex);\n\n/*! updates an HEVC sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index to update\n\\param cfg the HEVC config for this sample description\n\\return error if any\n*/\nGF_Err gf_isom_hevc_config_update(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, GF_HEVCConfig *cfg);\n\n/*! Updates L-HHVC config*/\ntypedef enum {\n\t//! changes track type to LHV1/LHE1: no base nor extractors in track, just enhancement layers\n\tGF_ISOM_LEHVC_ONLY = 0,\n\t//! changes track type to HVC2/HEV2: base and extractors/enh. in track\n\tGF_ISOM_LEHVC_WITH_BASE,\n\t//! changes track type to HVC1/HEV1 with additional cfg: base and enh. in track no extractors\n\tGF_ISOM_LEHVC_WITH_BASE_BACKWARD,\n\t//! changes track type to HVC2/HEV2 for tile base tracks\n\tGF_ISOM_HEVC_TILE_BASE,\n} GF_ISOMLHEVCTrackType;\n\n/*! updates an HEVC sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index to update\n\\param cfg the LHVC config for this sample description\n\\param track_type indicates the LHVC track type to set\n\\return error if any\n*/\nGF_Err gf_isom_lhvc_config_update(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, GF_HEVCConfig *cfg, GF_ISOMLHEVCTrackType track_type);\n\n/*! sets nalu size length\n\\warning Any previously added samples must be rewritten by the caller\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index to update\n\\param nalu_size_length the new NALU size length in bytes\n\\return error if any\n*/\nGF_Err gf_isom_set_nalu_length_field(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, u32 nalu_size_length);\n\n\n/*! creates a new VVC sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param cfg the VVC config for this sample description\n\\param URLname URL value of the data reference, NULL if no data reference (media in the file)\n\\param URNname URN value of the data reference, NULL if no data reference (media in the file)\n\\param outDescriptionIndex set to the index of the created sample description\n\\return error if any\n*/\nGF_Err gf_isom_vvc_config_new(GF_ISOFile *isom_file, u32 trackNumber, GF_VVCConfig *cfg, const char *URLname, const char *URNname, u32 *outDescriptionIndex);\n\n/*! sets vvi1 entry type (inband SPS/PPS) instead of vvc1 (SPS/PPS in hvcC box)\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\param keep_xps if set to GF_TRUE, keeps parameter set in the configuration record otherwise removes them\n\\return error if any\n*/\nGF_Err gf_isom_vvc_set_inband_config(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, Bool keep_xps);\n\n/*! updates vvcC configuration\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\param cfg new config to set\n\\return error if any\n*/\nGF_Err gf_isom_vvc_config_update(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, GF_VVCConfig *cfg);\n\n/*! creates new VPx config\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param cfg the VPx config for this sample description\n\\param URLname URL value of the data reference, NULL if no data reference (media in the file)\n\\param URNname URN value of the data reference, NULL if no data reference (media in the file)\n\\param outDescriptionIndex set to the index of the created sample description\n\\param vpx_type four character code of entry ('vp08', 'vp09' or 'vp10')\n\\return error if any\n*/\nGF_Err gf_isom_vp_config_new(GF_ISOFile *isom_file, u32 trackNumber, GF_VPConfig *cfg, const char *URLname, const char *URNname, u32 *outDescriptionIndex, u32 vpx_type);\n\n\n/*! creates new AV1 config\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param cfg the AV1 config for this sample description\n\\param URLname URL value of the data reference, NULL if no data reference (media in the file)\n\\param URNname URN value of the data reference, NULL if no data reference (media in the file)\n\\param outDescriptionIndex set to the index of the created sample description\n\\return error if any\n*/\nGF_Err gf_isom_av1_config_new(GF_ISOFile *isom_file, u32 trackNumber, GF_AV1Config *cfg, const char *URLname, const char *URNname, u32 *outDescriptionIndex);\n\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/*! Sample entry description for 3GPP DIMS*/\ntypedef struct\n{\n\t/*! profile*/\n\tu8 profile;\n\t/*! level*/\n\tu8 level;\n\t/*! number of components in path*/\n\tu8 pathComponents;\n\t/*! full request*/\n\tBool fullRequestHost;\n\t/*! stream type*/\n\tBool streamType;\n\t/*! has redundant sample (carousel)*/\n\tu8 containsRedundant;\n\t/*! text encoding string*/\n\tconst char *textEncoding;\n\t/*! content encoding string*/\n\tconst char *contentEncoding;\n\t/*! script string*/\n\tconst char *content_script_types;\n\t/*! mime type string*/\n\tconst char *mime_type;\n\t/*! xml schema location string*/\n\tconst char *xml_schema_loc;\n} GF_DIMSDescription;\n\n/*! gets a DIMS sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\param desc set to the DIMS description\n\\return error if any\n*/\nGF_Err gf_isom_get_dims_description(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, GF_DIMSDescription *desc);\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n/*! creates a DIMS sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param desc the DIMS config for this sample description\n\\param URLname URL value of the data reference, NULL if no data reference (media in the file)\n\\param URNname URN value of the data reference, NULL if no data reference (media in the file)\n\\param outDescriptionIndex set to the index of the created sample description\n\\return error if any\n*/\nGF_Err gf_isom_new_dims_description(GF_ISOFile *isom_file, u32 trackNumber, GF_DIMSDescription *desc, const char *URLname, const char *URNname, u32 *outDescriptionIndex);\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n/*! gets an AC3 sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\return AC-3 config\n*/\nGF_AC3Config *gf_isom_ac3_config_get(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex);\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n/*! creates an AC3 or EAC3 sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param cfg the AC3 config for this sample description\n\\param URLname URL value of the data reference, NULL if no data reference (media in the file)\n\\param URNname URN value of the data reference, NULL if no data reference (media in the file)\n\\param outDescriptionIndex set to the index of the created sample description\n\\return error if any\n*/\nGF_Err gf_isom_ac3_config_new(GF_ISOFile *isom_file, u32 trackNumber, GF_AC3Config *cfg, const char *URLname, const char *URNname, u32 *outDescriptionIndex);\n\n/*! updates an AC3 or EAC3 sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\param cfg the AC3 config for this sample description\n\\return error if any\n*/\nGF_Err gf_isom_ac3_config_update(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, GF_AC3Config *cfg);\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n/*! gets TrueHD  sample description info\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\param format_info set to the format info - may be NULL\n\\param peak_data_rate set to the peak data rate info - may be NULL\n\\return error if any\n*/\nGF_Err gf_isom_truehd_config_get(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, u32 *format_info, u32 *peak_data_rate);\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n/*! creates a FLAC sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param URLname URL value of the data reference, NULL if no data reference (media in the file)\n\\param URNname URN value of the data reference, NULL if no data reference (media in the file)\n\\param format_info TrueHD format info\n\\param peak_data_rate TrueHD peak data rate\n\\param outDescriptionIndex set to the index of the created sample description\n\\return error if any\n*/\nGF_Err gf_isom_truehd_config_new(GF_ISOFile *isom_file, u32 trackNumber, char *URLname, char *URNname, u32 format_info, u32 peak_data_rate, u32 *outDescriptionIndex);\n#endif\n\n/*! gets a FLAC sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\param dsi set to the flac decoder config - shall be freeed by caller\n\\param dsi_size set to the size of the flac decoder config\n\\return error if any\n*/\nGF_Err gf_isom_flac_config_get(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, u8 **dsi, u32 *dsi_size);\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n/*! creates a FLAC sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param metadata the flac decoder config buffer\n\\param metadata_size the size of flac decoder config\n\\param URLname URL value of the data reference, NULL if no data reference (media in the file)\n\\param URNname URN value of the data reference, NULL if no data reference (media in the file)\n\\param outDescriptionIndex set to the index of the created sample description\n\\return error if any\n*/\nGF_Err gf_isom_flac_config_new(GF_ISOFile *isom_file, u32 trackNumber, u8 *metadata, u32 metadata_size, const char *URLname, const char *URNname, u32 *outDescriptionIndex);\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n/*! gets a OPUS  sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\param dsi set to the OPUS decoder config (without OpusHead tag), may be NULL - shall be freeed by caller\n\\param dsi_size set to the size of the OPUS decoder config, may be NULL\n\\return error if any\n*/\nGF_Err gf_isom_opus_config_get(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, u8 **dsi, u32 *dsi_size);\n\n/*! gets a OPUS  sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\param opcfg opus config to get\n\\return error if any\n*/\nGF_Err gf_isom_opus_config_get_desc(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, GF_OpusConfig *opcfg);\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n/*! creates a new opus  sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param cfg the opus stream configuration\n\\param URLname URL value of the data reference, NULL if no data reference (media in the file)\n\\param URNname URN value of the data reference, NULL if no data reference (media in the file)\n\\param outDescriptionIndex set to the index of the created sample description\n\\return error if any\n*/\nGF_Err gf_isom_opus_config_new(GF_ISOFile *isom_file, u32 trackNumber, GF_OpusConfig *cfg, char *URLname, char *URNname, u32 *outDescriptionIndex);\n#endif\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n/*! creates a motion jpeg 2000 sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param URLname URL value of the data reference, NULL if no data reference (media in the file)\n\\param URNname URN value of the data reference, NULL if no data reference (media in the file)\n\\param outDescriptionIndex set to the index of the created sample description\n\\param dsi the jpeg2000 decoder config buffer\n\\param dsi_len the size of jpeg2000 decoder config\n\\return error if any\n*/\nGF_Err gf_isom_new_mj2k_description(GF_ISOFile *isom_file, u32 trackNumber, const char *URLname, const char *URNname, u32 *outDescriptionIndex, u8 *dsi, u32 dsi_len);\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n/*! creates a time code metadata sample description\n\\note frames_per_counter_tick<0 disables counter flag but signals frames_per_tick\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param fps_num the frame rate numerator\n\\param fps_den the frame rate denumerator (frame rate numerator will be track media timescale)\n\\param frames_per_counter_tick if not 0, enables counter mode (sample data is an counter) and use this value as number of frames per counter tick. Otherwise, disables counter mode (sample data write h,m,s,frames)\n\\param is_drop indicates that the time code in samples is a drop timecode\n\\param is_counter indicates that the counter flag should be set\n\\param outDescriptionIndex set to the index of the created sample description\n\\return error if any\n*/\nGF_Err gf_isom_tmcd_config_new(GF_ISOFile *isom_file, u32 trackNumber, u32 fps_num, u32 fps_den, s32 frames_per_counter_tick, Bool is_drop, Bool is_counter, u32 *outDescriptionIndex);\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n/*! gets information of a time code metadata sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\param tmcd_flags set to the timecode description flags\n\\param tmcd_fps_num set to fps numerator of timecode description\n\\param tmcd_fps_den set to fps denominator of timecode description\n\\param tmcd_fpt set to the ticks per second for counter mode (tmcd_flags & 0x1)\n\\return error if any\n*/\nGF_Err gf_isom_get_tmcd_config(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, u32 *tmcd_flags, u32 *tmcd_fps_num, u32 *tmcd_fps_den, u32 *tmcd_fpt);\n\n/*! gets information of a raw PCM  sample description, ISOBMFF style\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\param flags set to the pcm config flags (0: big endian, 1: little endian), may be NULL\n\\param pcm_size  set to PCM sample size (per channel, 16, 24, 32, 64, may be NULL\n\\return error if any\n*/\nGF_Err gf_isom_get_pcm_config(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, u32 *flags, u32 *pcm_size);\n\n/*! gets information of a raw PCM  sample description, QT style (lpcm codecid)\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\param sample_rate set to the pcm sample rate, may be NULL\n\\param nb_channels set to the pcm channel count, may be NULL\n\\param flags set to the pcm config flags (1: float, 2: big endian, 4: signed, other flags cf QTFF), may be NULL\n\\param pcm_size  set to PCM sample size (per channel, 16, 24, 32, 64, may be NULL\n\\return error if any\n*/\nGF_Err gf_isom_get_lpcm_config(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, Double *sample_rate, u32 *nb_channels, u32 *flags, u32 *pcm_size);\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n/*! creates a MPHA  sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param URLname URL value of the data reference, NULL if no data reference (media in the file)\n\\param URNname URN value of the data reference, NULL if no data reference (media in the file)\n\\param outDescriptionIndex set to the index of the created sample description\n\\param dsi the MPEGH audio config (payload of mhaC box):  byte[0]=1 (config version) ,byte[1]=ProfileLevel,  byte[2]=channel layout, byte[3],byte[4]: the size of what follows the rest being a mpegh3daConfig\n\\param dsi_size the size of the MPEGH audio config\n\\param mha_subtype mha1/mha2:/mhm1/mhm2 subtype to use\n\\return error if any\n*/\nGF_Err gf_isom_new_mpha_description(GF_ISOFile *isom_file, u32 trackNumber, const char *URLname, const char *URNname, u32 *outDescriptionIndex, u8 *dsi, u32 dsi_size, u32 mha_subtype);\n#endif\n\n/*! gets compatible profile list for mpegh entry\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\param nb_compatible_profiles set to the number of compatible profiles returned\n\\return array of compatible profiles, NULL if none found\n*/\nconst u8 *gf_isom_get_mpegh_compatible_profiles(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, u32 *nb_compatible_profiles);\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n/*! sets compatible profile list for mpegh entry\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\param profiles array of compatible profiles, NULL to remove compatible profiles\n\\param nb_compatible_profiles  number of compatible profiles in list, 0 to remove compatible profiles\n\\return error if any\n*/\nGF_Err gf_isom_set_mpegh_compatible_profiles(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, const u32 *profiles, u32 nb_compatible_profiles);\n#endif\n\n/*! structure holding youtube 360 video info\n- cf https://github.com/google/spatial-media/blob/master/docs/spherical-video-v2-rfc.md#stereoscopic-3d-video-box-st3d\n */\ntypedef struct\n{\n\t/*! stereo type  holding youtube 360 video info*/\n\tu32 stereo_type;\n\t/*! 0: unknown (not present), 1: cube map, 2: EQR, 3: mesh*/\n\tu32 projection_type;\n\t/*! metadata about 3D software creator*/\n\tconst char *meta_data;\n\t/*! indicate default pause is present*/\n\tBool pose_present;\n\t/*! default pause yaw as 16.16 fixed point*/\n\tu32 yaw;\n\t/*! default pause pitch as 16.16 fixed point*/\n\tu32 pitch;\n\t/*! default pause roll as 16.16 fixed point*/\n\tu32 roll;\n\n\t/*! cube map layout*/\n\tu32 layout;\n\t/*! cube map padding*/\n\tu32 padding;\n\n\t/*! EQR top crop pos in frame, in pixels*/\n\tu32 top;\n\t/*! EQR bottom crop pos in frame, in pixels*/\n\tu32 bottom;\n\t/*! EQR left crop pos in frame, in pixels*/\n\tu32 left;\n\t/*! EQR right crop pos in frame, in pixels*/\n\tu32 right;\n\n} GF_ISOM_Y3D_Info;\n\n\n/*! gets youtube 3D/360 info\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\param info filled with 3D info\n\\return error if any, GF_NOT_FOUND if no 3D/360 or setero info\n*/\nGF_Err gf_isom_get_y3d_info(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, GF_ISOM_Y3D_Info *info);\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n/*! sets youtube 3D/360 info\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\param info  3D info to set\n\\return error if any\n*/\nGF_Err gf_isom_set_y3d_info(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, GF_ISOM_Y3D_Info *info);\n#endif\n\n/*! @} */\n\n\n/*!\n\\addtogroup isofragred_grp Fragmented ISOBMFF Read\n\\ingroup iso_grp\n\nThis describes function specific to fragmented ISOBMF files\n\n@{\n*/\n\n/*! checks if a movie file is fragmented\n\\param isom_file the target ISO file\n\\return GF_FALSE if movie isn't fragmented, GF_TRUE otherwise\n*/\nBool gf_isom_is_fragmented(GF_ISOFile *isom_file);\n\n/*! checks if a movie file is fragmented\n\\param isom_file the target ISO file\n\\param TrackID the target track\n\\return GF_FALSE if track isn't fragmented, GF_TRUE otherwise*/\nBool gf_isom_is_track_fragmented(GF_ISOFile *isom_file, GF_ISOTrackID TrackID);\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\n/*! checks if a file has a top styp box\n\\param isom_file the target ISO file\n\\param brand set to the major brand of the styp box\n\\param version set to version of the styp box\n\\return GF_TRUE of the file has a styp box, GF_FALSE otherwise\n*/\nBool gf_isom_has_segment(GF_ISOFile *isom_file, u32 *brand, u32 *version);\n/*! gets number of movie fragments in the file\n\\param isom_file the target ISO file\n\\returns number of movie fragments in the file, 0 if none\n*/\nu32 gf_isom_segment_get_fragment_count(GF_ISOFile *isom_file);\n/*! gets number of track fragments in the indicated movie fragment\n\\param isom_file the target ISO file\n\\param moof_index the target movie fragment  (1-based index)\n\\return number of track fragments, 0 if none\n*/\nu32 gf_isom_segment_get_track_fragment_count(GF_ISOFile *isom_file, u32 moof_index);\n/*! get the track fragment decode time of a track fragment\n\\param isom_file the target ISO file\n\\param moof_index the target movie fragment (1-based index)\n\\param traf_index the target track fragment (1-based index)\n\\param decode_time set to the track fragment decode time if present, 0 otherwise\n\\return the track ID of the track fragment\n*/\nu32 gf_isom_segment_get_track_fragment_decode_time(GF_ISOFile *isom_file, u32 moof_index, u32 traf_index, u64 *decode_time);\n\n/*! get the movie fragment size, i.e. the size of moof, mdat and related boxes before moof/mdat\n\n\\param isom_file the target ISO file\n\\param moof_index the target movie fragment (1-based index)\n\\param moof_size set to moof box size, may be NULL\n\\return the movie fragemnt size\n*/\nu64 gf_isom_segment_get_fragment_size(GF_ISOFile *isom_file, u32 moof_index, u32 *moof_size);\n\n/*! enables single moof mode. In single moof mode, file is parsed only one moof/mdat at a time\n   in order to proceed to next moof, \\ref gf_isom_reset_data_offset must be called to parse the next moof\n\\param isom_file the target ISO file\n\\param mode if GF_TRUE, enables single moof mode; otherwise disables it\n*/\nvoid gf_isom_set_single_moof_mode(GF_ISOFile *isom_file, Bool mode);\n\n/*! gets closest file offset for the given time, when the file uses an segment index (sidx)\n\\param isom_file the target ISO file\n\\param start_time the start time in seconds\n\\param offset set to the file offset of the segment containing the desired time\n\\return error if any\n*/\nGF_Err gf_isom_get_file_offset_for_time(GF_ISOFile *isom_file, Double start_time, u64 *offset);\n\n/*! gets sidx duration, when the file uses an segment index (sidx)\n\\param isom_file the target ISO file\n\\param sidx_dur set to the total duration documented in the segment index\n\\param sidx_timescale set timescale used to represent the duration in the segment index\n\\return error if any\n*/\nGF_Err gf_isom_get_sidx_duration(GF_ISOFile *isom_file, u64 *sidx_dur, u32 *sidx_timescale);\n\n\n/*! refreshes a fragmented file\nA file being downloaded may be a fragmented file. In this case only partial info\nis available once the file is successfully open (gf_isom_open_progressive), and since there is\nno information wrt number fragments (which could actually be generated on the fly\nat the sender side), you must call this function on regular basis in order to\nload newly downloaded fragments. Note this may result in Track/Movie duration changes\nand SampleCount change too ...\n\nThis function should also be called when using memory read (gmem://) to refresh the underlying bitstream after appendin data to your blob.\nIn the case where the file is not fragmented, no further box parsing will be done.\n\n\\param isom_file the target ISO file\n\\param MissingBytes set to the number of missing bytes to parse the last incomplete top-level box found\n\\param new_location if set, the previous bitstream is changed to this new location, otherwise it is refreshed (disk flush)\n\\return error if any\n*/\nGF_Err gf_isom_refresh_fragmented(GF_ISOFile *isom_file, u64 *MissingBytes, const char *new_location);\n\n/*! gets the current track fragment decode time of the track (the one of the last fragment parsed).\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return the track fragment decode time in media timescale\n*/\nu64 gf_isom_get_current_tfdt(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! gets the estimated DTS of the first sample of the next segment for SmoothStreaming files (no tfdt, no tfxd)\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return the next track fragment decode time in media timescale\n*/\nu64 gf_isom_get_smooth_next_tfdt(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! checks if the movie is a smooth streaming recomputed initial movie\n\\param isom_file the target ISO file\n\\return GF_TRUE if the file init segment (moov) was generated from external meta-data (smooth streaming)\n*/\nBool gf_isom_is_smooth_streaming_moov(GF_ISOFile *isom_file);\n\n\n/*! gets default values of samples in a track to use for track fragments default. Each variable is optional and\nif set will contain the default value for this track samples\n\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param defaultDuration set to the default duration of samples, 0 if not computable\n\\param defaultSize set to the default size of samples, 0 if not computable\n\\param defaultDescriptionIndex set to the default sample description index of samples, 0 if not computable\n\\param defaultRandomAccess set to the default sync flag of samples, 0 if not computable\n\\param defaultPadding set to the default padding bits of samples, 0 if not computable\n\\param defaultDegradationPriority set to the default degradation priority of samples, 0 if not computable\n\\return error if any*/\nGF_Err gf_isom_get_fragment_defaults(GF_ISOFile *isom_file, u32 trackNumber,\n                                     u32 *defaultDuration, u32 *defaultSize, u32 *defaultDescriptionIndex,\n                                     u32 *defaultRandomAccess, u8 *defaultPadding, u16 *defaultDegradationPriority);\n\n\n\n/*! gets last UTC/timestamp values indicated for the reference track in the file if any (pfrt box)\n\\param isom_file the target ISO file\n\\param refTrackID set to the ID of the reference track used by the pfrt box\n\\param ntp set to the NTP timestamp found\n\\param timestamp set to the corresponding media timestamp in refTrackID timescale\n\\param reset_info if GF_TRUE, discards current NTP mapping info; this will trigger parsing of the next prft box found. If not set, subsequent pfrt boxes will not be parsed until the function is called with reset_info=GF_TRUE\n\\return GF_FALSE if no info found, GF_TRUE if OK\n*/\nBool gf_isom_get_last_producer_time_box(GF_ISOFile *isom_file, GF_ISOTrackID *refTrackID, u64 *ntp, u64 *timestamp, Bool reset_info);\n\n/*! enables storage of traf templates (serialized sidx/moof/traf without trun/senc) at segment boundaries\nThis is mostly used to recreate identical segment information when refragmenting a file\n\\param isom_file the target ISO file\n*/\nvoid gf_isom_enable_traf_map_templates(GF_ISOFile *isom_file);\n/*! get byte range of root sidx if any\n\\param isom_file the target ISO file\n\\param start set to start offset (0=first byte) of the root sidx\n\\param end set to end offset (0 if no sidx) of the root sidx\n\\return true if success\n*/\nBool gf_isom_get_root_sidx_offsets(GF_ISOFile *isom_file, u64 *start, u64 *end);\n\n/*! Segment boundary information*/\ntypedef struct\n{\n\t/*! fragment start offset*/\n\tu64 frag_start;\n\t/*! mdat end offset*/\n\tu64 mdat_end;\n\t/*segment start offset plus one:\n\t\t0 if regular fragment, 1 if dash segment, offset indicates start of segment (styp or sidx)\n\t\tif sidx, it is written in the moof_template\n\t*/\n\tu64 seg_start_plus_one;\n\n\t/*! serialized array of styp (if present) sidx (if present) and moof with only the current traf*/\n\tconst u8 *moof_template;\n\t/*! size of serialized buffer*/\n\tu32 moof_template_size;\n\t/*! sidx start, 0 if absent*/\n\tu64 sidx_start;\n\t/*! sidx end, 0 if absent*/\n\tu64 sidx_end;\n\t/*! DTS of first sample in this fragment fotr the queried track*/\n\tu64 first_dts;\n} GF_ISOFragmentBoundaryInfo;\n\n/*! checks if a sample is a fragment start\nOnly use this function if \\ref gf_isom_enable_traf_map_templates has been called\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleNum the target sample number\n\\param frag_info filled with information on fragment boundaries (optional - can be NULL)\n\\return GF_TRUE if this sample was the first sample of a traf in the fragmented source file, GF_FALSE otherwise*/\nBool gf_isom_sample_is_fragment_start(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleNum, GF_ISOFragmentBoundaryInfo *frag_info);\n\n/*! releases current movie segment. This closes the associated file IO object.\n\\note seeking in the file is no longer possible when tables are rested\n\\warning The sample count is not reseted after the release of tables. use \\ref gf_isom_reset_tables for this\n\n\\param isom_file the target ISO file\n\\param reset_tables if set, sample information for all tracks setup as segment are destroyed, along with all PSSH boxes. This allows keeping the memory footprint low when playing segments.\n\\return error if any\n*/\nGF_Err gf_isom_release_segment(GF_ISOFile *isom_file, Bool reset_tables);\n\n#endif //GPAC_DISABLE_ISOM_FRAGMENTS\n\n\n/*! resets sample information for all tracks setup. This allows keeping the memory footprint low when playing DASH/CMAF segments\n\\note seeking in the file is then no longer possible\n\\param isom_file the target ISO file\n\\param reset_sample_count if GF_TRUE, sets sample count of all tracks back to 0\n\\return error if any\n*/\nGF_Err gf_isom_reset_tables(GF_ISOFile *isom_file, Bool reset_sample_count);\n\n/*! sets the offset for parsing from the input buffer to 0 (used to reclaim input buffer)\n\\param isom_file the target ISO file\n\\param top_box_start set to the byte offset in the source buffer of the first top level box, may be NULL\n\\return error if any\n*/\nGF_Err gf_isom_reset_data_offset(GF_ISOFile *isom_file, u64 *top_box_start);\n\n/*! Flags for gf_isom_open_segment*/\ntypedef enum\n{\n\t/*! do not check for movie fragment sequence number*/\n\tGF_ISOM_SEGMENT_NO_ORDER_FLAG = 1,\n\t/*! the segment contains a scalable layer of the last opened segment*/\n\tGF_ISOM_SEGMENT_SCALABLE_FLAG = 1<<1,\n} GF_ISOSegOpenMode;\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\n/*! opens a new segment file. Access to samples in previous segments is no longer possible\nif end_range>start_range, restricts the URL to the given byterange when parsing\n\n\\param isom_file the target ISO file\n\\param fileName the file name of the new segment to open\n\\param start_range the start offset in bytes in the file of the segment data\n\\param end_range the end offset in bytes in the file of the segment data\n\\param flags flags to use when opening the segment\n\\return error if any\n*/\nGF_Err gf_isom_open_segment(GF_ISOFile *isom_file, const char *fileName, u64 start_range, u64 end_range, GF_ISOSegOpenMode flags);\n\n/*! returns the track ID of the track containing the highest enhancement layer for the given base track\n\\param isom_file the target ISO file\n\\param for_base_track the number of the base track\n\\return the track ID of the highest enahnacement track\n*/\nGF_ISOTrackID gf_isom_get_highest_track_in_scalable_segment(GF_ISOFile *isom_file, u32 for_base_track);\n\n/*! resets internal info (track fragement decode time, number of samples, next moof number)used with fragments and segment.\n\\note This should be called when seeking (with keep_sample_count=0) or when loading a media segments with the same timing as the previously loaded segment\n\\param isom_file the target ISO file\n\\param keep_sample_count if GF_TRUE, does not reset the sample count on tracks\n*/\nvoid gf_isom_reset_fragment_info(GF_ISOFile *isom_file, Bool keep_sample_count);\n\n/*! resets sample count to 0 and next moof number to 0. When doing scalable media, should be called before opening the segment containing\nthe base layer in order to make sure the sample count base number is always the same (ie 1) on all tracks\n\\param isom_file the target ISO file\n*/\nvoid gf_isom_reset_sample_count(GF_ISOFile *isom_file);\n/*! resets moof sequence number to 0\n\\param isom_file the target ISO file\n*/\nvoid gf_isom_reset_seq_num(GF_ISOFile *isom_file);\n\n/*! gets the duration of movie+fragments\n\\param isom_file the target ISO file\n\\return the duration in movie timescale, 0 if unknown or if error*/\nu64 gf_isom_get_fragmented_duration(GF_ISOFile *isom_file);\n\n/*! gets the number of fragments or segments when the file is opened in \\ref GF_ISOM_OPEN_READ_DUMP mode\n\\param isom_file the target ISO file\n\\param segments_only if set to GF_TRUE, counts segments (sidx), otherwise counts fragments\n\\return the number of segments or fragments\n*/\nu32 gf_isom_get_fragments_count(GF_ISOFile *isom_file, Bool segments_only);\n\n/*! gets total sample number and duration when the file is opened in \\ref GF_ISOM_OPEN_READ_DUMP mode\n\\param isom_file the target ISO file\n\\param trackID the ID of the target track\n\\param nb_samples set to the number of samples in the track\n\\param duration set to the total duration in media timescale\n\\return error if any\n*/\nGF_Err gf_isom_get_fragmented_samples_info(GF_ISOFile *isom_file, GF_ISOTrackID trackID, u32 *nb_samples, u64 *duration);\n\n/*! gets the number of the next moof to be produced\n\\param isom_file the target ISO file\n\\return number of the next moof\n*/\nu32 gf_isom_get_next_moof_number(GF_ISOFile *isom_file);\n\n/*! @} */\n#endif //GPAC_DISABLE_ISOM_FRAGMENTS\n\n\n/*!\n\\addtogroup isoudta_grp ISOBMFF UserData Manipulation\n\\ingroup iso_grp\n\n\t\t\t\tUser Data Manipulation\n\nYou can add specific typed data to either a track or the movie: the UserData\n\tThe type must be formatted as a FourCC if you have a registered 4CC type\n\tbut the usual is to set a UUID (128 bit ID for box type) which never conflict\n\twith existing structures in the format\n\t\tTo manipulate a UUID user data set the UserDataType to 0 and specify a valid UUID.\nOtherwise the UUID parameter is ignored\n\t\tSeveral items with the same ID or UUID can be added (this allows you to store any\n\tkind/number of private information under a unique ID / UUID)\n\n@{\n*/\n\n/*! gets number of udta (user data) entries of a movie or track\n\\param isom_file the target ISO file\n\\param trackNumber the target track if not 0; if 0, the movie udta is checked\n\\return the number of entries in UDTA*/\nu32 gf_isom_get_udta_count(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! checks type of a given udta entry\n\\param isom_file the target ISO file\n\\param trackNumber the target track if not 0; if 0, the movie udta is checked\n\\param udta_idx 1-based index of the user data to query\n\\param UserDataType set to the four character code of the user data entry (optional, can be NULL)\n\\param UUID set to the UUID of the user data entry (optional, can be NULL)\n\\return error if any*/\nGF_Err gf_isom_get_udta_type(GF_ISOFile *isom_file, u32 trackNumber, u32 udta_idx, u32 *UserDataType, bin128 *UUID);\n\n/*! gets the number of UserDataItems with the same ID / UUID in the desired track or movie\n\\param isom_file the target ISO file\n\\param trackNumber the target track if not 0; if 0, the movie udta is checked\n\\param UserDataType the four character code of the user data entry to query\n\\param UUID the UUID of the user data entry\n\\return number of UDTA entries with the given type*/\nu32 gf_isom_get_user_data_count(GF_ISOFile *isom_file, u32 trackNumber, u32 UserDataType, bin128 UUID);\n\n/*! gets the UserData for the specified item from the track or the movie\n\\param isom_file the target ISO file\n\\param trackNumber the target track if not 0; if 0, the movie udta is checked\n\\param UserDataType the four character code of the user data entry to query\n\\param UUID the UUID of the user data entry\n\\param UserDataIndex 1-based index of the user data of the given type to fetch. If 0, all boxes with type==UserDataType will be serialized (including box header and size) in the output buffer\n\\param userData set to a newly allocated buffer containing the serialized data - shall be freed by caller, you must pass (userData != NULL && *userData=NULL)\n\\param userDataSize set to the size of the allocated buffer\n\\return error if any*/\nGF_Err gf_isom_get_user_data(GF_ISOFile *isom_file, u32 trackNumber, u32 UserDataType, bin128 UUID, u32 UserDataIndex, u8 **userData, u32 *userDataSize);\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n/*! adds a user data item in the desired track or in the movie\n\\param isom_file the target ISO file\n\\param trackNumber the target track for the user data; if 0, adds user data to the movie\n\\param UserDataType the user data four character code type\n\\param UUID the user data UUID\n\\param data the data to add, may be NULL\n\\param size the size of the data to add, shall be 0 when data is NULL\n\\return error if any\n*/\nGF_Err gf_isom_add_user_data(GF_ISOFile *isom_file, u32 trackNumber, u32 UserDataType, bin128 UUID, u8 *data, u32 size);\n\n/*! removes all user data items from a track or movie\n\\param isom_file the target ISO file\n\\param trackNumber the target track for the user data; if 0, adds user data to the movie\n\\param UserDataType the user data four character code type\n\\param UUID the user data UUID\n\\return error if any\n*/\nGF_Err gf_isom_remove_user_data(GF_ISOFile *isom_file, u32 trackNumber, u32 UserDataType, bin128 UUID);\n\n/*! removes a user data item from a track or movie\nuse the UDAT read functions to get the item index\n\\param isom_file the target ISO file\n\\param trackNumber the target track for the user data; if 0, adds user data to the movie\n\\param UserDataType the user data four character code type\n\\param UUID the user data UUID\n\\param UserDataIndex the 1-based index of the user data item to remove - see \\ref gf_isom_get_user_data_count\n\\return error if any\n*/\nGF_Err gf_isom_remove_user_data_item(GF_ISOFile *isom_file, u32 trackNumber, u32 UserDataType, bin128 UUID, u32 UserDataIndex);\n\n/*! adds a user data item in a track or movie using a serialzed buffer of ISOBMFF boxes\n\\param isom_file the target ISO file\n\\param trackNumber the target track for the udta box; if 0, add the udta to the movie;\n\\param data the serialized udta box to add, shall not be NULL\n\\param size the size of the data to add\n\\return error if any\n*/\nGF_Err gf_isom_add_user_data_boxes(GF_ISOFile *isom_file, u32 trackNumber, u8 *data, u32 size);\n\n/*! gets serialized user data box of a movie\n\\param isom_file the destination ISO file\n\\param output will be set to a newly allocated buffer containing the serialized box - caller shall free it\n\\param output_size will be set to the size of the allocated buffer\n\\return error if any\n*/\nGF_Err gf_isom_get_raw_user_data(GF_ISOFile *isom_file, u8 **output, u32 *output_size);\n\n#endif //GPAC_DISABLE_ISOM_WRITE\n\n/*! @} */\n\n\n#if !defined(GPAC_DISABLE_ISOM_FRAGMENTS) && !defined(GPAC_DISABLE_ISOM_WRITE)\n\n/*!\n\\addtogroup isofragwrite_grp Fragmented ISOBMFF Writing\n\\ingroup iso_grp\n\n\t\t\tMovie Fragments Writing API\n\t\tMovie Fragments is a feature of ISO media files for fragmentation\n\tof a presentation meta-data and interleaving with its media data.\n\tThis enables faster http fast start for big movies, and also reduces the risk\n\tof data loss in case of a recording crash, because meta data and media data\n\tcan be written to disk at regular times\n\t\tThis API provides simple function calls to setup such a movie and write it\n\tThe process implies:\n\t\t1- creating a movie in the usual way (track, stream descriptions, (IOD setup\n\tcopyright, ...)\n\t\t2- possibly add some samples in the regular fashion\n\t\t3- setup track fragments for all track that will be written in a fragmented way\n\t(note that you can create/write a track that has no fragmentation at all)\n\t\t4- finalize the movie for fragmentation (this will flush all meta-data and\n\tany media-data added to disk, ensuring all vital information for the presentation\n\tis stored on file and not lost in case of crash/poweroff)\n\n\t  then 5-6 as often as desired\n\t\t5- start a new movie fragment\n\t\t6- add samples to each setup track\n\n\n  IMPORTANT NOTES:\n\t\t* Movie Fragments can only be used in GF_ISOM_OPEN_WRITE mode (capturing)\n  and no editing functionalities can be used\n\t\t* the fragmented movie API uses TrackID and not TrackNumber\n\n@{\n*/\n\n/*! flag indicating default samples are sync*/\n#define GF_ISOM_FRAG_DEF_IS_SYNC 1\n/*! flag indicating a sync sample table shall be added in the track - cf CMAF rules*/\n#define GF_ISOM_FRAG_USE_SYNC_TABLE (1<<1)\n\n/*! sets up a track for fragmentation by specifying some default values for storage efficiency\n\\note If all the defaults are 0, traf flags will always be used to signal them.\n\\param isom_file the target ISO file\n\\param TrackID ID of the target track\n\\param DefaultSampleDescriptionIndex the default description used by samples in this track\n\\param DefaultSampleDuration default duration of samples in this track\n\\param DefaultSampleSize default size of samples in this track (0 if unknown)\n\\param DefaultSampleSyncFlags combination of GF_ISOM_FRAG_* flags\n\\param DefaultSamplePadding default padding bits for samples in this track\n\\param DefaultDegradationPriority default degradation priority for samples in this track\n\\param force_traf_flags if GF_TRUE, will ignore these default in each traf but will still write them in moov\n\\return error if any\n*/\nGF_Err gf_isom_setup_track_fragment(GF_ISOFile *isom_file, GF_ISOTrackID TrackID,\n                                    u32 DefaultSampleDescriptionIndex,\n                                    u32 DefaultSampleDuration,\n                                    u32 DefaultSampleSize,\n                                    u8 DefaultSampleSyncFlags,\n                                    u8 DefaultSamplePadding,\n                                    u16 DefaultDegradationPriority,\n\t\t\t\t\t\t\t\t\tBool force_traf_flags);\n\n/*! changes the default parameters of an existing trak fragment\n\\warning This should not be used if samples have already been added\n\n\\param isom_file the target ISO file\n\\param TrackID ID of the target track\n\\param DefaultSampleDescriptionIndex the default description used by samples in this track\n\\param DefaultSampleDuration default duration of samples in this track\n\\param DefaultSampleSize default size of samples in this track (0 if unknown)\n\\param DefaultSampleIsSync default key-flag (RAP) of samples in this track\n\\param DefaultSamplePadding default padding bits for samples in this track\n\\param DefaultDegradationPriority default degradation priority for samples in this track\n\\param force_traf_flags if GF_TRUE, will ignore these default in each traf but will still write them in moov\n\\return error if any\n*/\nGF_Err gf_isom_change_track_fragment_defaults(GF_ISOFile *isom_file, GF_ISOTrackID TrackID,\n        u32 DefaultSampleDescriptionIndex,\n        u32 DefaultSampleDuration,\n        u32 DefaultSampleSize,\n        u8 DefaultSampleIsSync,\n        u8 DefaultSamplePadding,\n        u16 DefaultDegradationPriority,\n        u8 force_traf_flags);\n\n/*! flushes data to disk and prepare movie fragmentation\n\\param isom_file the target ISO file\n\\param media_segment_type 0 if no segments, 1 if regular segment, 2 if single segment\n\\param mvex_after_tracks forces writing mvex box after track boxes\n\\return error if any\n*/\nGF_Err gf_isom_finalize_for_fragment(GF_ISOFile *isom_file, u32 media_segment_type, Bool mvex_after_tracks);\n\n/*! sets the duration of the movie in case of movie fragments\n\\param isom_file the target ISO file\n\\param duration the complete duration (movie and all fragments) in movie timescale\n\\param remove_mehd force removal of mehd box, only setting mvhd.duration to 0\n\\return error if any\n*/\nGF_Err gf_isom_set_movie_duration(GF_ISOFile *isom_file, u64 duration, Bool remove_mehd);\n\n/*! fragment creatio option*/\ntypedef enum\n{\n\t/*! moof is stored before mdat - will require temporary storage of data in memory*/\n\tGF_ISOM_FRAG_MOOF_FIRST = 1,\n#ifdef GF_ENABLE_CTRN\n\t/*! use compact fragment syntax*/\n\tGF_ISOM_FRAG_USE_COMPACT = 1<<1,\n#endif\n} GF_ISOStartFragmentFlags;\n/*! starts a new movie fragment\n\\param isom_file the target ISO file\n\\param moof_first if GF_TRUE, the moof will be written before the mdat\n\\return error if any\n*/\nGF_Err gf_isom_start_fragment(GF_ISOFile *isom_file, GF_ISOStartFragmentFlags moof_first);\n\n/*! starts a new segment in the file\n\\param isom_file the target ISO file\n\\param SegName if not NULL, the output will be written in the SegName file. If NULL, segment will be created in same file as movie. The special name \"_gpac_isobmff_redirect\" is used to indicate that segment shall be written to a memory buffer passed to callback function set through \\ref gf_isom_set_write_callback\n\\param memory_mode if set, all samples writing is done in memory rather than on disk. Ignored in callback mode\n\\return error if any\n*/\nGF_Err gf_isom_start_segment(GF_ISOFile *isom_file, const char *SegName, Bool memory_mode);\n\n/*! sets the baseMediaDecodeTime of the first sample of the given track\n\\param isom_file the target ISO file\n\\param TrackID ID of the target track\n\\param decode_time the decode time in media timescale\n\\return error if any\n*/\nGF_Err gf_isom_set_traf_base_media_decode_time(GF_ISOFile *isom_file, GF_ISOTrackID TrackID, u64 decode_time);\n\n/*! enables mfra (movie fragment random access computing) when writing movie fragments\n\\note this should only be used when generating segments in a single file\n\\param isom_file the target ISO file\n\\return error if any\n*/\nGF_Err gf_isom_enable_mfra(GF_ISOFile *isom_file);\n\n/*! sets Microsoft Smooth Streaming traf 'tfxd' box info, written at the end of each traf\n\\param isom_file the target ISO file\n\\param reference_track_ID ID of the reference track giving the media timescale\n\\param decode_traf_time decode time of the first sample in the segment in media timescale (hardcoded to 10MHz in Smooth)\n\\param traf_duration duration of all samples in the traf in media timescale (hardcoded to 10MHz in Smooth)\n\\return error if any\n*/\nGF_Err gf_isom_set_traf_mss_timeext(GF_ISOFile *isom_file, GF_ISOTrackID reference_track_ID, u64 decode_traf_time, u64 traf_duration);\n\n/*! closes current segment, producing a segment index box if desired\n\\param isom_file the target ISO file\n\\param subsegs_per_sidx number of subsegments per sidx box; a negative value disables sidx, 0 forces a single sidx for the segment (or subsegment)\n\\param referenceTrackID the ID of the track used as a reference for the segment index box\n\\param ref_track_decode_time the decode time fo the first sample in the reference track for this segment\n\\param timestamp_shift the constant difference between media time and presentation time (derived from edit list)\n\\param ref_track_next_cts the CTS of the first sample in the reference track in the next segment\n\\param daisy_chain_sidx if GF_TRUE, indicates chained sidx shall be used. Otherwise, an array of indexes is used\n\\param use_ssix if GF_TRUE, produces an ssix box using I-frames as first level and all other frames as second level\n\\param last_segment indicates if this is the last segment of the session\n\\param close_segment_handle if set to GF_TRUE, the associated file if any will be closed\n\\param segment_marker_4cc a four character code used to insert an empty box at the end of the saegment with the given type. If 0, no such box is inserted\n\\param index_start_range set to the start offset in bytes of the segment in the media file\n\\param index_end_range set to the end offset in bytes of the segment in the media file\n\\param out_seg_size set to the segment size in bytes (optional, can be NULL)\n\\return error if any\n*/\nGF_Err gf_isom_close_segment(GF_ISOFile *isom_file, s32 subsegs_per_sidx, GF_ISOTrackID referenceTrackID, u64 ref_track_decode_time, s32 timestamp_shift, u64 ref_track_next_cts, Bool daisy_chain_sidx, Bool use_ssix, Bool last_segment, Bool close_segment_handle, u32 segment_marker_4cc, u64 *index_start_range, u64 *index_end_range, u64 *out_seg_size);\n\n/*! writes any pending fragment to file for low-latency output.\n\\warning This shall only be used if no SIDX is used: subsegs_per_sidx<0 or flushing all fragments before calling \\ref gf_isom_close_segment\n\n\\param isom_file the target ISO file\n\\param last_segment indicates if this is the last segment of the session\n\\return error if any\n*/\nGF_Err gf_isom_flush_fragments(GF_ISOFile *isom_file, Bool last_segment);\n\n/*! sets fragment prft box info, written just before the moof\n\\param isom_file the target ISO file\n\\param reference_track_ID the ID of the track used as a reference for media timestamps\n\\param ntp absolute NTP time\n\\param timestamp media time corresponding to the NTP time, in reference track media timescale\n\\return error if any\n*/\nGF_Err gf_isom_set_fragment_reference_time(GF_ISOFile *isom_file, GF_ISOTrackID reference_track_ID, u64 ntp, u64 timestamp);\n\n/*! writes an empty sidx in the current movie.\n\nThe SIDX will be forced to have nb_segs entries, and nb_segs shall match the number of calls to\n\\ref gf_isom_close_segment that will follow.\nThis avoids wasting time and disk space moving data around. Once \\ref gf_isom_close_segment has then been called nb_segs times,\nthe pre-allocated SIDX is destroyed and successive calls to \\ref gf_isom_close_segment will create their own sidx, unless gf_isom_allocate_sidx is called again.\n\n\\param isom_file the target ISO file\n\\param subsegs_per_sidx reserved to 0, currently ignored\n\\param daisy_chain_sidx reserved to 0, currently ignored\n\\param nb_segs number of entries in the segment index\n\\param frags_per_segment reserved, currently ignored\n\\param start_range set to the start offset in bytes of the segment index box\n\\param end_range set to the end offset in bytes of the segment index box\n\\param use_ssix if GF_TRUE, produces an ssix box using I-frames as first level and all other frames as second level\n\\return error if any\n*/\nGF_Err gf_isom_allocate_sidx(GF_ISOFile *isom_file, s32 subsegs_per_sidx, Bool daisy_chain_sidx, u32 nb_segs, u32 *frags_per_segment, u32 *start_range, u32 *end_range, Bool use_ssix);\n\n/*! sets up track fragment defaults using the given template. The template shall be a serialized array of one or more trex boxes\n\n\\param isom_file the target ISO file\n\\param TrackID ID of the target track\n\\param boxes serialized array of trex boxes\n\\param boxes_size size of the serialized array\n\\param force_traf_flags if GF_TRUE, will ignore these default in each traf but will still write them in moov\n\\return error if any\n*/\nGF_Err gf_isom_setup_track_fragment_template(GF_ISOFile *isom_file, GF_ISOTrackID TrackID, u8 *boxes, u32 boxes_size, u8 force_traf_flags);\n\n#ifdef GF_ENABLE_CTRN\n/*! enables track fragment inheriting from a given traf.\nThis shall only be set when the inherited traf shares exactly the same syntax except the sample sizes, this library does not compute which\nsample values can be inherited\n\n\\param isom_file the target ISO file\n\\param TrackID ID of the target track\n\\param BaseTrackID ID of the track from which sample values are inherited in track fragments\n\\return error if any\n*/\nGF_Err gf_isom_enable_traf_inherit(GF_ISOFile *isom_file, GF_ISOTrackID TrackID, GF_ISOTrackID BaseTrackID);\n#endif\n\n/*! Track fragment options*/\ntypedef enum\n{\n\t/*! indicates that the track fragment has no samples but still has a duration\n\t(silence-detection in audio codecs, ...).\n\tparam: indicates duration*/\n\tGF_ISOM_TRAF_EMPTY,\n\t/*! I-Frame detection: this can reduce file size by detecting I-frames and\n\toptimizing sample flags (padding, priority, ..)\n\tparam: on/off (0/1)*/\n\tGF_ISOM_TRAF_RANDOM_ACCESS,\n\t/*! activate data cache on track fragment. This is useful when writing interleaved\n\tmedia from a live source (typically audio-video), and greatly reduces file size\n\tparam: Number of samples (> 1) to cache before disk flushing. You shouldn't try\n\tto cache too many samples since this will load your memory. base that on FPS/SR*/\n\tGF_ISOM_TRAF_DATA_CACHE,\n\t/*! forces moof base offsets when traf based offsets would be chosen\n\tparam: on/off (0/1)*/\n\tGF_ISOM_TFHD_FORCE_MOOF_BASE_OFFSET,\n\t/*! use sdtp box in traf rather than storing sample deps in trun entry. param values are:\n\t\t0: disables sdtp\n\t\t1: enables sdtp and disables sample dependency flags in trun\n\t\t2: enables sdtp and also use sample dependency flags in trun\n\t*/\n\tGF_ISOM_TRAF_USE_SAMPLE_DEPS_BOX,\n\t/*! forces new trun at next sample add\n\tparam: ignored*/\n\tGF_ISOM_TRUN_FORCE,\n\t/*! sets interleave group ID of the  next sample add. Samples with lower interleave ID will be stored first, creating new trun whenever a new group is detected\n\tThis will enable data cache\n\tparam: interleave ID*/\n\tGF_ISOM_TRUN_SET_INTERLEAVE_ID,\n\t/*! store truns before sample encryption and sample groups info\n \tparam: 1 to store before and follow CMAF (recommended?) order, 0, to store after*/\n\tGF_ISOM_TRAF_TRUNS_FIRST,\n\t/*! forces trun v1\n\tparam: on/off (0/1)*/\n\tGF_ISOM_TRAF_TRUN_V1,\n\t/*force usage of 64 bits in tfdt and in per-segment sidx*/\n\tGF_ISOM_TRAF_USE_LARGE_TFDT\n} GF_ISOTrackFragmentOption;\n\n/*! sets a track fragment option. Options can be set at the beginning of each new fragment only, and for the\nlifetime of the fragment\n\\param isom_file the target ISO file\n\\param TrackID ID of the target track\n\\param Code the option type to set\n\\param param the option value\n\\return error if any\n*/\nGF_Err gf_isom_set_fragment_option(GF_ISOFile *isom_file, GF_ISOTrackID TrackID, GF_ISOTrackFragmentOption Code, u32 param);\n\n/*! adds a sample to a fragmented track\n\n\\param isom_file the target ISO file\n\\param TrackID destination track\n\\param sample sample to add\n\\param sampleDescriptionIndex sample description for this sample. If 0, the default one\nis used\n\\param Duration sample duration; the sample duration MUST be provided at least for the last sample (for intermediate samples, it is recomputed internally by the lib)\n\\param PaddingBits padding bits for the sample, or 0\n\\param DegradationPriority for the sample, or 0\n\\param redundantCoding indicates this is samples acts as a sync shadow point\n\\return error if any\n*/\nGF_Err gf_isom_fragment_add_sample(GF_ISOFile *isom_file, GF_ISOTrackID TrackID, const GF_ISOSample *sample,\n                                   u32 sampleDescriptionIndex,\n                                   u32 Duration, u8 PaddingBits, u16 DegradationPriority, Bool redundantCoding);\n\n/*! appends data into last sample of track for video fragments/other media\n\\warning This shall not be used with OD tracks\n\\param isom_file the target ISO file\n\\param TrackID destination track\n\\param data the data to append\n\\param data_size the size of the data to append\n\\param PaddingBits padding bits for the sample, or 0\n\\return error if any\n*/\nGF_Err gf_isom_fragment_append_data(GF_ISOFile *isom_file, GF_ISOTrackID TrackID, u8 *data, u32 data_size, u8 PaddingBits);\n\n\n/*! sets side information for common encryption for the last added sample\n\\param isom_file the target ISO file\n\\param trackID the ID of the target track\n\\param sai_b buffer containing the SAI information of the sample\n\\param sai_b_size size of the SAI buffer. If sai_b is NULL or sai_b_size is 0, add a clear SAI data\n\\param use_subsample indicates if the media uses CENC subsamples\n\\param use_saio_32bit indicates if 32-bit saio shall be used\n\\param use_multikey indicates if multikey is in use (required to tag saiz/saio boxes)\n\\return error if any\n*/\nGF_Err gf_isom_fragment_set_cenc_sai(GF_ISOFile *isom_file, GF_ISOTrackID trackID, u8 *sai_b, u32 sai_b_size, Bool use_subsample, Bool use_saio_32bit, Bool use_multikey);\n\n#endif // !defined(GPAC_DISABLE_ISOM_FRAGMENTS) && !defined(GPAC_DISABLE_ISOM_WRITE)\n\n#if !defined(GPAC_DISABLE_ISOM_WRITE)\n\n/*! clones PSSH data between two files\n\\param dst_file the target ISO file\n\\param src_file the source ISO file\n\\param in_moof if GF_TRUE, indicates the pssh should be cloned in current moof box\n\\return error if any\n*/\nGF_Err gf_isom_clone_pssh(GF_ISOFile *dst_file, GF_ISOFile *src_file, Bool in_moof);\n\n#endif\n\n\n#if !defined(GPAC_DISABLE_ISOM_FRAGMENTS) && !defined(GPAC_DISABLE_ISOM_WRITE)\n\n/*! sets roll information for a sample in a track fragment\n\\param isom_file the target ISO file\n\\param trackID the ID of the target track\n\\param sample_number the sample number of the last sample\n\\param roll_type indicate the sample roll type\n\\param roll_distance set to the roll distance for a roll sample\n\\return error if any\n*/\nGF_Err gf_isom_fragment_set_sample_roll_group(GF_ISOFile *isom_file, GF_ISOTrackID trackID, u32 sample_number, GF_ISOSampleRollType roll_type, s16 roll_distance);\n\n/*! sets rap information for a sample in a track fragment\n\\param isom_file the target ISO file\n\\param trackID the ID of the target track\n\\param sample_number_in_frag the sample number of the sample in the traf\n\\param is_rap set to GF_TRUE to indicate the sample is a RAP sample (open-GOP), GF_FALSE otherwise\n\\param num_leading_samples set to the number of leading pictures for a RAP sample\n\\return error if any\n*/\nGF_Err gf_isom_fragment_set_sample_rap_group(GF_ISOFile *isom_file, GF_ISOTrackID trackID, u32 sample_number_in_frag, Bool is_rap, u32 num_leading_samples);\n\n/*! sets sample dependency flags in a track fragment - see ISO/IEC 14496-12 and \\ref gf_filter_pck_set_dependency_flags\n\\param isom_file the target ISO file\n\\param trackID the ID of the target track\n\\param is_leading indicates that the sample is a leading picture\n\\param dependsOn indicates the sample dependency towards other samples\n\\param dependedOn indicates the sample dependency from other samples\n\\param redundant indicates that the sample contains redundant coding\n\\return error if any\n*/\nGF_Err gf_isom_fragment_set_sample_flags(GF_ISOFile *isom_file, GF_ISOTrackID trackID, u32 is_leading, u32 dependsOn, u32 dependedOn, u32 redundant);\n\n\n\n/*! adds sample auxiliary data\n\n\\param isom_file the target ISO file\n\\param trackID the ID of the target track\n\\param sample_number_in_frag the sample number in the current fragment. Must be equal or larger to last auxiliary added\n\\param aux_type auxiliary sample data type, shall not be 0\n\\param aux_info auxiliary sample data specific info type, may be 0\n\\param data data to add\n\\param size size of data to add\n\\return error if any\n*/\nGF_Err gf_isom_fragment_set_sample_aux_info(GF_ISOFile *isom_file, u32 trackID, u32 sample_number_in_frag, u32 aux_type, u32 aux_info, u8 *data, u32 size);\n\n\n/*! sets the number of the next moof to be produced\n\\param isom_file the target ISO file\n\\param value the number of the next moof\n*/\nvoid gf_isom_set_next_moof_number(GF_ISOFile *isom_file, u32 value);\n\n\n/*! @} */\n#endif// !defined(GPAC_DISABLE_ISOM_FRAGMENTS) && !defined(GPAC_DISABLE_ISOM_WRITE)\n\n\n/*!\n\\addtogroup isortp_grp ISOBMFF RTP Hinting\n\\ingroup iso_grp\n\n@{\n*/\n\n/*! supported hint formats - ONLY RTP now*/\ntypedef enum\n{\n\t/*! RTP hint type*/\n\tGF_ISOM_HINT_RTP = GF_4CC('r', 't', 'p', ' '),\n} GF_ISOHintFormat;\n\n#if !defined(GPAC_DISABLE_ISOM_WRITE) && !defined(GPAC_DISABLE_ISOM_HINTING)\n\n/*! sets up a hint track based on the hint format\n\\warning This function MUST be called after creating a new hint track and before any other calls on this track\n\\param isom_file the target ISO file\n\\param trackNumber the target hint track\n\\param HintType the desired hint type\n\\return error if any\n*/\nGF_Err gf_isom_setup_hint_track(GF_ISOFile *isom_file, u32 trackNumber, GF_ISOHintFormat HintType);\n\n/*! creates a HintDescription for the HintTrack\n\\param isom_file the target ISO file\n\\param trackNumber the target hint track\n\\param HintTrackVersion version of hint track\n\\param LastCompatibleVersion last compatible version of hint track\n\\param Rely flag indicating whether a reliable transport protocol is desired/required\nfor data transport\n\t0: not desired (UDP/IP). NB: most RTP streaming servers only support UDP/IP for data\n\t1: preferable (TCP/IP if possible or UDP/IP)\n\t2: required (TCP/IP only)\n\\param HintDescriptionIndex is set to the newly created hint sample description index\n\\return error if any\n*/\nGF_Err gf_isom_new_hint_description(GF_ISOFile *isom_file, u32 trackNumber, s32 HintTrackVersion, s32 LastCompatibleVersion, u8 Rely, u32 *HintDescriptionIndex);\n\n/*! starts a new sample for the hint track. A sample is just a collection of packets\nthe transmissionTime is indicated in the media timeScale of the hint track\n\\param isom_file the target ISO file\n\\param trackNumber the target hint track\n\\param HintDescriptionIndex the target hint sample description index\n\\param TransmissionTime the target transmission time in hint media timescale\n\\return error if any\n*/\nGF_Err gf_isom_begin_hint_sample(GF_ISOFile *isom_file, u32 trackNumber, u32 HintDescriptionIndex, u32 TransmissionTime);\n\n/*! ends an hint sample once all your packets for this sample are done\n\\param isom_file the target ISO file\n\\param trackNumber the target hint track\n\\param IsRandomAccessPoint set to GF_TRUE if you want to indicate that this is a random access point in the stream\n\\return error if any\n*/\nGF_Err gf_isom_end_hint_sample(GF_ISOFile *isom_file, u32 trackNumber, u8 IsRandomAccessPoint);\n\n\n/*!\n\t\tPacketHandling functions\n\t\tData can be added at the end or at the beginning of the current packet\n\t\tby setting AtBegin to 1 the data will be added at the beginning\n\t\tThis allows constructing the packet payload before any meta-data\n*/\n\n/*! adds a blank chunk of data in the sample that is skipped while streaming\n\\param isom_file the target ISO file\n\\param trackNumber the target hint track\n\\param AtBegin indicates if the blank chunk should be at the end or at the beginning of the hint packet\n\\return error if any\n*/\nGF_Err gf_isom_hint_blank_data(GF_ISOFile *isom_file, u32 trackNumber, u8 AtBegin);\n\n/*! adds a chunk of data in the packet that is directly copied while streaming\n\\note DataLength MUST BE <= 14 bytes, and you should only use this function\nto add small blocks of data (encrypted parts, specific headers, ...)\n\\param isom_file the target ISO file\n\\param trackNumber the target hint track\n\\param data buffer to add to the RTP packet\n\\param dataLength size of buffer to add to the RTP packet\n\\param AtBegin indicates if the blank chunk should be at the end or at the beginning of the hint packet\n\\return error if any\n*/\nGF_Err gf_isom_hint_direct_data(GF_ISOFile *isom_file, u32 trackNumber, u8 *data, u32 dataLength, u8 AtBegin);\n\n/*! adds a reference to some sample data in the packet\n\\note if you want to reference a previous HintSample in the hintTrack, you will have to parse the sample yourself ...\n\n\\param isom_file the target ISO file\n\\param trackNumber the target hint track\n\\param SourceTrackID the ID of the track where the referenced sample is\n\\param SampleNumber the sample number containing the data to be added\n\\param DataLength the length of bytes to copy in the packet\n\\param offsetInSample the offset in bytes in the sample at which to begin copying data\n\\param extra_data only used when the sample is actually the sample that will contain this packet\n(useful to store en encrypted version of a packet only available while streaming)\n\tIn this case, set SourceTrackID to the HintTrack ID and SampleNumber to 0\n\tIn this case, the DataOffset MUST BE NULL and length will indicate the extra_data size\n\\param AtBegin indicates if the blank chunk should be at the end or at the beginning of the hint packet\n\\return error if any\n*/\nGF_Err gf_isom_hint_sample_data(GF_ISOFile *isom_file, u32 trackNumber, GF_ISOTrackID SourceTrackID, u32 SampleNumber, u16 DataLength, u32 offsetInSample, u8 *extra_data, u8 AtBegin);\n\n\n/*! adds a reference to some stream description data in the packet (headers, ...)\n\n\\param isom_file the target ISO file\n\\param trackNumber the target hint track\n\\param SourceTrackID the ID of the track where the referenced sample is\n\\param sampleDescriptionIndex the index of the stream description in the desired track\n\\param DataLength the length of bytes to copy in the packet\n\\param offsetInDescription the offset in bytes in the description at which to begin copying data. Since it is far from being obvious / interoperable what this offset is, we recommend not using this function and injecting the data instead using \\ref gf_isom_hint_direct_data.\n\\param AtBegin indicates if the blank chunk should be at the end or at the beginning of the hint packet\n\\return error if any\n*/\nGF_Err gf_isom_hint_sample_description_data(GF_ISOFile *isom_file, u32 trackNumber, GF_ISOTrackID SourceTrackID, u32 sampleDescriptionIndex, u16 DataLength, u32 offsetInDescription, u8 AtBegin);\n\n\n/*! creates a new RTP packet in the HintSample. If a previous packet was created,\nit is stored in the hint sample and a new packet is created.\n\n\\param isom_file the target ISO file\n\\param trackNumber the target hint track\n\\param relativeTime RTP time offset of this packet in the HintSample if any - in hint track\ntime scale. Used for data smoothing by servers.\n\\param PackingBit the 'P' bit of the RTP packet header\n\\param eXtensionBit the'X' bit of the RTP packet header\n\\param MarkerBit the 'M' bit of the RTP packet header\n\\param PayloadType the payload type, on 7 bits, format 0x0XXXXXXX\n\\param disposable_packet indicates if this packet can be skipped by a server\n\\param IsRepeatedPacket indicates if this is a duplicate packet of a previous one and can be skipped by a server\n\\param SequenceNumber the RTP base sequence number of the packet. Because of support for repeated packets, you have to set the sequence number yourself.\n\\return error if any\n*/\nGF_Err gf_isom_rtp_packet_begin(GF_ISOFile *isom_file, u32 trackNumber, s32 relativeTime, u8 PackingBit, u8 eXtensionBit, u8 MarkerBit, u8 PayloadType, u8 disposable_packet, u8 IsRepeatedPacket, u16 SequenceNumber);\n\n/*! sets the flags of the RTP packet\n\\param isom_file the target ISO file\n\\param trackNumber the target hint track\n\\param PackingBit the 'P' bit of the RTP packet header\n\\param eXtensionBit the'X' bit of the RTP packet header\n\\param MarkerBit the 'M' bit of the RTP packet header\n\\param disposable_packet indicates if this packet can be skipped by a server\n\\param IsRepeatedPacket indicates if this is a duplicate packet of a previous one and can be skipped by a server\n\\return error if any*/\nGF_Err gf_isom_rtp_packet_set_flags(GF_ISOFile *isom_file, u32 trackNumber, u8 PackingBit, u8 eXtensionBit, u8 MarkerBit, u8 disposable_packet, u8 IsRepeatedPacket);\n\n/*! sets the time offset of this packet. This enables packets to be placed in the hint track\nin decoding order, but have their presentation time-stamp in the transmitted\npacket in a different order. Typically used for MPEG video with B-frames\n\\param isom_file the target ISO file\n\\param trackNumber the target hint track\n\\param timeOffset time offset in RTP media timescale\n\\return error if any\n*/\nGF_Err gf_isom_rtp_packet_set_offset(GF_ISOFile *isom_file, u32 trackNumber, s32 timeOffset);\n\n\n/*! sets the RTP TimeScale that the server use to send packets\nsome RTP payloads may need a specific timeScale that is not the timeScale in the file format\nthe default timeScale choosen by the API is the MediaTimeScale of the hint track\n\\param isom_file the target ISO file\n\\param trackNumber the target hint track\n\\param HintDescriptionIndex the target hint sample description index\n\\param TimeScale the RTP timescale to use\n\\return error if any\n*/\nGF_Err gf_isom_rtp_set_timescale(GF_ISOFile *isom_file, u32 trackNumber, u32 HintDescriptionIndex, u32 TimeScale);\n\n/*! sets the RTP TimeOffset that the server will add to the packets\nif not set, the server adds a random offset\n\\param isom_file the target ISO file\n\\param trackNumber the target hint track\n\\param HintDescriptionIndex the target hint sample description index\n\\param TimeOffset the time offset in RTP timescale\n\\return error if any\n*/\nGF_Err gf_isom_rtp_set_time_offset(GF_ISOFile *isom_file, u32 trackNumber, u32 HintDescriptionIndex, u32 TimeOffset);\n\n/*! sets the RTP SequenceNumber Offset that the server will add to the packets\nif not set, the server adds a random offset\n\\param isom_file the target ISO file\n\\param trackNumber the target hint track\n\\param HintDescriptionIndex the target hint sample description index\n\\param SequenceNumberOffset the sequence number offset\n\\return error if any\n*/\nGF_Err gf_isom_rtp_set_time_sequence_offset(GF_ISOFile *isom_file, u32 trackNumber, u32 HintDescriptionIndex, u32 SequenceNumberOffset);\n\n/*! adds an SDP line to the SDP container at the track level (media-specific SDP info)\n\\note the CRLF end of line for SDP is automatically inserted\n\\param isom_file the target ISO file\n\\param trackNumber the target hint track\n\\param text the SDP text to add the target hint track\n\\return error if any\n*/\nGF_Err gf_isom_sdp_add_track_line(GF_ISOFile *isom_file, u32 trackNumber, const char *text);\n/*! removes all SDP info at the track level\n\\param isom_file the target ISO file\n\\param trackNumber the target hint track\n\\return error if any\n*/\nGF_Err gf_isom_sdp_clean_track(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! adds an SDP line to the SDP container at the movie level (presentation SDP info)\n\\note The CRLF end of line for SDP is automatically inserted\n\\param isom_file the target ISO file\n\\param text the SDP text to add the target hint track\n\\return error if any\n*/\nGF_Err gf_isom_sdp_add_line(GF_ISOFile *isom_file, const char *text);\n/*! removes all SDP info at the movie level\n\\param isom_file the target ISO file\n\\return error if any\n*/\nGF_Err gf_isom_sdp_clean(GF_ISOFile *isom_file);\n\n#endif// !defined(GPAC_DISABLE_ISOM_WRITE) && !defined(GPAC_DISABLE_ISOM_HINTING)\n\n\n#ifndef GPAC_DISABLE_ISOM_HINTING\n\n#ifndef GPAC_DISABLE_ISOM_DUMP\n/*! dumps RTP hint samples structure into XML trace file\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param SampleNum the target sample number\n\\param trace the file object to dump to\n\\return error if any\n*/\nGF_Err gf_isom_dump_hint_sample(GF_ISOFile *isom_file, u32 trackNumber, u32 SampleNum, FILE * trace);\n#endif\n\n/*! gets SDP info at the movie level\n\\param isom_file the target ISO file\n\\param sdp set to the sdp text, including a null-terminating character - do not modify\n\\param length set to the sdp length, not including the null-terminating character\n\\return error if any\n*/\nGF_Err gf_isom_sdp_get(GF_ISOFile *isom_file, const char **sdp, u32 *length);\n/*! gets SDP info at the track level\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sdp set to the sdp text, including a null-terminating character - do not modify\n\\param length set to the sdp length, not including the null-terminating character\n\\return error if any\n*/\nGF_Err gf_isom_sdp_track_get(GF_ISOFile *isom_file, u32 trackNumber, const char **sdp, u32 *length);\n/*! gets number of payload type defines for an RTP hint track\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return the number of payload types defined\n*/\nu32 gf_isom_get_payt_count(GF_ISOFile *isom_file, u32 trackNumber);\n/*! gets payload type information for an RTP hint track\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param index the payload type 1_based index\n\\param payID set to the ID of the payload type\n\\return the sdp fmtp attribute describing the payload\n*/\nconst char *gf_isom_get_payt_info(GF_ISOFile *isom_file, u32 trackNumber, u32 index, u32 *payID);\n\n\n#endif /*GPAC_DISABLE_ISOM_HINTING*/\n\n\n/*! @} */\n\n/*!\n\\addtogroup isotxt_grp Subtitles and Timed Text\n\\ingroup iso_grp\n\n@{\n*/\n\n\n/*! sets streaming text reading mode (MPEG-4 text vs 3GPP)\n\\param isom_file the target ISO file\n\\param do_convert is set, all text samples will be retrieved as TTUs and ESD will be emulated for text tracks\n\\return error if any\n*/\nGF_Err gf_isom_text_set_streaming_mode(GF_ISOFile *isom_file, Bool do_convert);\n\n\n#ifndef GPAC_DISABLE_ISOM_DUMP\n/*! text track export type*/\ntypedef enum {\n\t/*! dump as TTXT XML*/\n\tGF_TEXTDUMPTYPE_TTXT = 0,\n\t/*! dump as TTXT XML with box */\n\tGF_TEXTDUMPTYPE_TTXT_BOXES,\n\t/*! dump as SRT*/\n\tGF_TEXTDUMPTYPE_SRT,\n\t/*! dump as SVG*/\n\tGF_TEXTDUMPTYPE_SVG,\n\t/*! dump as TTXT chapters (omits empty text samples)*/\n\tGF_TEXTDUMPTYPE_TTXT_CHAP,\n\t/*! dump as OGG chapters*/\n\tGF_TEXTDUMPTYPE_OGG_CHAP,\n\t/*! dump as Zoom chapters*/\n\tGF_TEXTDUMPTYPE_ZOOM_CHAP\n} GF_TextDumpType;\n/*! dumps a text track to a file\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param dump the file object to write to (binary open mode)\n\\param dump_type the dump type mode\n\\return error if any\n*/\nGF_Err gf_isom_text_dump(GF_ISOFile *isom_file, u32 trackNumber, FILE *dump, GF_TextDumpType dump_type);\n#endif\n\n/*! gets encoded TX3G box (text sample description for 3GPP text streams) as needed by RTP or other standards:\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the sample description index\n\\param sidx_offset if 0, the sidx will NOT be written before the encoded TX3G. If not 0, the sidx will be written before the encoded TX3G, with the given offset. Offset sshould be at least 128 for most common usage of TX3G (RTP, MPEG-4 timed text, etc)\n\\param tx3g set to a newly allocated buffer containing the encoded tx3g - to be freed by caller\n\\param tx3g_size set to the size of the encoded config\n\\return error if any\n*/\nGF_Err gf_isom_text_get_encoded_tx3g(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, u32 sidx_offset, u8 **tx3g, u32 *tx3g_size);\n\n/*! sets TX3G flags for forced samples\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the sample description index\n\\param force_type if 0, no forced subs are present. If 1, some forced subs are present; if 2, all samples are forced subs\n\\return error if any\n*/\nGF_Err gf_isom_set_forced_text(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, u32 force_type);\n\n/*! text sample formatting*/\ntypedef struct _3gpp_text_sample GF_TextSample;\n/*! creates text sample handle\n\\return a newly allocated text sample\n*/\nGF_TextSample *gf_isom_new_text_sample();\n/*! destroys text sample handle\n\\param tx_samp the target text sample\n*/\nvoid gf_isom_delete_text_sample(GF_TextSample *tx_samp);\n\n/*! generic subtitle sample formatting*/\ntypedef struct _generic_subtitle_sample GF_GenericSubtitleSample;\n/*! creates generic subtitle sample handle\n\\return a newly allocated generic subtitle sample\n*/\nGF_GenericSubtitleSample *gf_isom_new_generic_subtitle_sample();\n/*! destroys generic subtitle sample handle\n\\param generic_subtitle_samp the target generic subtitle sample\n*/\nvoid gf_isom_delete_generic_subtitle_sample(GF_GenericSubtitleSample *generic_subtitle_samp);\n\n#ifndef GPAC_DISABLE_VTT\n/*! creates new WebVTT config\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param URLname URL value of the data reference, NULL if no data reference (media in the file)\n\\param URNname URN value of the data reference, NULL if no data reference (media in the file)\n\\param outDescriptionIndex set to the index of the created sample description\n\\param config the WebVTT configuration string\n\\return error if any\n*/\nGF_Err gf_isom_new_webvtt_description(GF_ISOFile *isom_file, u32 trackNumber, const char *URLname, const char *URNname, u32 *outDescriptionIndex, const char *config);\n#endif\n\n/*! gets WebVTT config for a sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\return the WebVTT configuration string\n*/\nconst char *gf_isom_get_webvtt_config(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex);\n\n/*! gets simple streaming text config for a sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\param mime set to the mime type (optional, can be NULL)\n\\param encoding set to the text encoding type (optional, can be NULL)\n\\param config set to the WebVTT configuration string (optional, can be NULL)\n\\return error if any\n*/\nGF_Err gf_isom_stxt_get_description(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, const char **mime, const char **encoding, const char **config);\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n/*! creates new simple streaming text config\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param type the four character code of the simple text sample description (sbtt, stxt, mett)\n\\param mime the mime type\n\\param encoding the text encoding, if any\n\\param config the configuration string, if any\n\\param outDescriptionIndex set to the index of the created sample description\n\\return error if any\n*/\nGF_Err gf_isom_new_stxt_description(GF_ISOFile *isom_file, u32 trackNumber, u32 type, const char *mime, const char *encoding, const char *config, u32 *outDescriptionIndex);\n\n#endif // GPAC_DISABLE_ISOM_WRITE\n\n/*! gets XML streaming text config for a sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\param xmlnamespace set to the XML namespace (optional, can be NULL)\n\\param xml_schema_loc set to the XML schema location (optional, can be NULL)\n\\param mimes set to the associated mime(s) types (optional, can be NULL)\n\\return error if any\n*/\nGF_Err gf_isom_xml_subtitle_get_description(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex,\n        const char **xmlnamespace, const char **xml_schema_loc, const char **mimes);\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n/*! creates a new XML streaming text config\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param xmlnamespace the XML namespace\n\\param xml_schema_loc the XML schema location (optional, can be NULL)\n\\param auxiliary_mimes the associated mime(s) types (optional, can be NULL)\n\\param outDescriptionIndex set to the index of the created sample description\n\\return error if any\n*/\nGF_Err gf_isom_new_xml_subtitle_description(GF_ISOFile *isom_file, u32 trackNumber,\n        const char *xmlnamespace, const char *xml_schema_loc, const char *auxiliary_mimes,\n        u32 *outDescriptionIndex);\n#endif // GPAC_DISABLE_ISOM_WRITE\n\n\n/*! gets MIME parameters  (type/subtype + codecs and profiles) associated with a sample descritpion\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\return MIME param if present, NULL otherwise\n*/\nconst char *gf_isom_subtitle_get_mime(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex);\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n/*! gets MIME parameters associated with a sample descritpion\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\param full_mime MIME param (type/subtype + codecs and profiles) to set, if NULL removes MIME parameter info\n\\return error if any\n*/\nGF_Err gf_isom_subtitle_set_mime(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, const char *full_mime);\n#endif\n\n\n/*! gets XML metadata for a sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\param xmlnamespace set to the XML namespace (optional, can be NULL)\n\\param schema_loc set to the XML schema location (optional, can be NULL)\n\\param content_encoding set to the content encoding string (optional, can be NULL)\n\\return error if any\n*/\nGF_Err gf_isom_get_xml_metadata_description(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, const char **xmlnamespace, const char **schema_loc, const char **content_encoding);\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n/*! creates a new timed metadata sample description for this track\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param xmlnamespace the XML namespace\n\\param schema_loc the XML schema location (optional, can be NULL)\n\\param content_encoding the content encoding string (optional, can be NULL)\n\\param outDescriptionIndex set to the index of the created sample description\n\\return error if any\n*/\nGF_Err gf_isom_new_xml_metadata_description(GF_ISOFile *isom_file, u32 trackNumber, const char *xmlnamespace, const char *schema_loc, const char *content_encoding, u32 *outDescriptionIndex);\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n\n/*! text flags operation type*/\ntypedef enum\n{\n\tGF_ISOM_TEXT_FLAGS_OVERWRITE = 0,\n\tGF_ISOM_TEXT_FLAGS_TOGGLE,\n\tGF_ISOM_TEXT_FLAGS_UNTOGGLE,\n} GF_TextFlagsMode;\n/*! sets text display flags according to given mode.\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index. If 0, sets the flags for all text descriptions\n\\param flags the flag to set\n\\param op_type the flag toggle mode\n\\return error if any\n*/\nGF_Err gf_isom_text_set_display_flags(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, u32 flags, GF_TextFlagsMode op_type);\n\n/*! gets text description of a sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\param out_desc set to a newly allocated text sample descriptor - shall be freeed by user\n\\return error if any\n*/\nGF_Err gf_isom_get_text_description(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, GF_TextSampleDescriptor **out_desc);\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n/*! creates a new TextSampleDescription in the file.\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param desc the text sample description\n\\param URLname URL value of the data reference, NULL if no data reference (media in the file)\n\\param URNname URN value of the data reference, NULL if no data reference (media in the file)\n\\param outDescriptionIndex set to the index of the created sample description\n\\return error if any\n*/\nGF_Err gf_isom_new_text_description(GF_ISOFile *isom_file, u32 trackNumber, GF_TextSampleDescriptor *desc, const char *URLname, const char *URNname, u32 *outDescriptionIndex);\n\n/*! resets text sample content\n\\param tx_samp the target text sample\n\\return error if any\n*/\nGF_Err gf_isom_text_reset(GF_TextSample * tx_samp);\n/*! resets text sample styles but keep text\n\\param tx_samp the target text sample\n\\return error if any\n*/\nGF_Err gf_isom_text_reset_styles(GF_TextSample *tx_samp);\n\n/*! appends text to sample - text_len is the number of bytes to be written from text_data. This allows\nhandling UTF8 and UTF16 strings in a transparent manner\n\\param tx_samp the target text sample\n\\param text_data the text data to add\n\\param text_len the size of the data to add\n\\return error if any\n*/\nGF_Err gf_isom_text_add_text(GF_TextSample *tx_samp, char *text_data, u32 text_len);\n/*! appends style modifyer to sample\n\\param tx_samp the target text sample\n\\param rec the style record to add\n\\return error if any\n*/\nGF_Err gf_isom_text_add_style(GF_TextSample *tx_samp, GF_StyleRecord *rec);\n/*! appends highlight modifier for the sample\n\\param tx_samp the target text sample\n\\param start_char first char highlighted,\n\\param end_char first char not highlighted\n\\return error if any\n*/\nGF_Err gf_isom_text_add_highlight(GF_TextSample *tx_samp, u16 start_char, u16 end_char);\n\n/*! sets highlight color for the whole sample\n\\param tx_samp the target text sample\n\\param argb color value\n\\return error if any\n*/\nGF_Err gf_isom_text_set_highlight_color(GF_TextSample *tx_samp, u32 argb);\n/*! appends a new karaoke sequence in the sample\n\\param tx_samp the target text sample\n\\param start_time karaoke start time expressed in text stream timescale, but relative to the sample media time\n\\return error if any\n*/\nGF_Err gf_isom_text_add_karaoke(GF_TextSample *tx_samp, u32 start_time);\n/*! appends a new segment in the current karaoke sequence - you must build sequences in order to be compliant\n\\param tx_samp the target text sample\n\\param end_time segment end time expressed in text stream timescale, but relative to the sample media time\n\\param start_char first char highlighted,\n\\param end_char first char not highlighted\n\\return error if any\n*/\nGF_Err gf_isom_text_set_karaoke_segment(GF_TextSample *tx_samp, u32 end_time, u16 start_char, u16 end_char);\n/*! sets scroll delay for the whole sample (scrolling is enabled through GF_TextSampleDescriptor.DisplayFlags)\n\\param tx_samp the target text sample\n\\param scroll_delay delay for scrolling expressed in text stream timescale\n\\return error if any\n*/\nGF_Err gf_isom_text_set_scroll_delay(GF_TextSample *tx_samp, u32 scroll_delay);\n/*! appends hyperlinking for the sample\n\\param tx_samp the target text sample\n\\param URL UTF-8 url\n\\param altString UTF-8 hint (tooltip, ...) for end user\n\\param start_char first char hyperlinked,\n\\param end_char first char not hyperlinked\n\\return error if any\n*/\nGF_Err gf_isom_text_add_hyperlink(GF_TextSample *tx_samp, char *URL, char *altString, u16 start_char, u16 end_char);\n/*! sets current text box (display pos&size within the text track window) for the sample\n\\param tx_samp the target text sample\n\\param top top coordinate of box\n\\param left left coordinate of box\n\\param bottom bottom coordinate of box\n\\param right right coordinate of box\n\\return error if any\n*/\nGF_Err gf_isom_text_set_box(GF_TextSample *tx_samp, s16 top, s16 left, s16 bottom, s16 right);\n/*! appends blinking for the sample\n\\param tx_samp the target text sample\n\\param start_char first char blinking,\n\\param end_char first char not blinking\n\\return error if any\n*/\nGF_Err gf_isom_text_add_blink(GF_TextSample *tx_samp, u16 start_char, u16 end_char);\n/*! sets wrap flag for the sample\n\\param tx_samp the target text sample\n\\param wrap_flags text wrap flags - currently only 0 (no wrap) and 1 (\"soft wrap\") are allowed in 3GP\n\\return error if any\n*/\nGF_Err gf_isom_text_set_wrap(GF_TextSample *tx_samp, u8 wrap_flags);\n\n/*! sets force for the sample\n\\param tx_samp the target text sample\n\\param is_force for ce sample if TRUE\n\\return error if any\n*/\nGF_Err gf_isom_text_set_forced(GF_TextSample *tx_samp, Bool is_forced);\n\n/*! formats sample as a regular GF_ISOSample payload in a bitstream object.\n\\param tx_samp the target text sample\n\\param bs thetarget bitstream\n\\return error if any\n*/\nGF_Err gf_isom_text_sample_write_bs(const GF_TextSample *tx_samp, GF_BitStream *bs);\n\n\n/*! formats sample as a regular GF_ISOSample.\nThe resulting sample will always be marked as random access\n\\param tx_samp the target text sample\n\\return the corresponding serialized ISO sample\n*/\nGF_ISOSample *gf_isom_text_to_sample(const GF_TextSample *tx_samp);\n\n/*! gets the serialized size of the text sample\n\\param tx_samp the target text sample\n\\return the serialized size\n*/\nu32 gf_isom_text_sample_size(GF_TextSample *tx_samp);\n\n/*! creates a new XML subtitle sample\n\\return a new XML subtitle sample\n*/\nGF_GenericSubtitleSample *gf_isom_new_xml_subtitle_sample();\n/*! deletes an XML subtitle sample\n\\param subt_samp the target XML subtitle sample\n*/\nvoid gf_isom_delete_xml_subtitle_sample(GF_GenericSubtitleSample *subt_samp);\n/*! resets content of an XML subtitle sample\n\\param subt_samp the target XML subtitle sample\n\\return error if any\n*/\nGF_Err gf_isom_xml_subtitle_reset(GF_GenericSubtitleSample *subt_samp);\n/*! the corresponding serialized ISO sample\n\\param subt_samp the target XML subtitle sample\n\\return the corresponding serialized ISO sample\n*/\nGF_ISOSample *gf_isom_xml_subtitle_to_sample(GF_GenericSubtitleSample *subt_samp);\n/*! appends text to an XML subtitle sample\n\\param subt_samp the target XML subtitle sample\n\\param text_data the UTF-8 or UTF-16 data to add\n\\param text_len the size of the text to add in bytes\n\\return error if any\n*/\nGF_Err gf_isom_xml_subtitle_sample_add_text(GF_GenericSubtitleSample *subt_samp, char *text_data, u32 text_len);\n\n\n#endif\t/*GPAC_DISABLE_ISOM_WRITE*/\n\n/*! @} */\n\n\n/*!\n\\addtogroup isocrypt_grp Content Protection\n\\ingroup iso_grp\n\n@{\n*/\n\n#endif // GPAC_DISABLE_ISOM\n\n/*! DRM related code points*/\nenum\n{\n\t/*! Storage location of CENC sample auxiliary in PSEC UUID box*/\n\tGF_ISOM_BOX_UUID_PSEC = GF_4CC( 'P', 'S', 'E', 'C' ),\n\t/*! Storage location of CENC sample auxiliary in senc box*/\n\tGF_ISOM_BOX_TYPE_SENC = GF_4CC( 's', 'e', 'n', 'c'),\n\t/*! PSSH box type */\n\tGF_ISOM_BOX_TYPE_PSSH = GF_4CC( 'p', 's', 's', 'h'),\n\t/*! ISMA Encryption Scheme Type in the SchemeTypeInfoBox */\n\tGF_ISOM_ISMACRYP_SCHEME\t= GF_4CC( 'i', 'A', 'E', 'C' ),\n\t/*! OMA DRM Encryption Scheme Type in the SchemeTypeInfoBox */\n\tGF_ISOM_OMADRM_SCHEME = GF_4CC('o','d','k','m'),\n\t/*! CENC AES-CTR Encryption Scheme Type in the SchemeTypeInfoBox */\n\tGF_ISOM_CENC_SCHEME\t= GF_4CC('c','e','n','c'),\n\t/*! CENC AES-CBC Encryption Scheme Type in the SchemeTypeInfoBox */\n\tGF_ISOM_CBC_SCHEME = GF_4CC('c','b','c','1'),\n\t/*! Adobe Encryption Scheme Type in the SchemeTypeInfoBox */\n\tGF_ISOM_ADOBE_SCHEME = GF_4CC('a','d','k','m'),\n\t/*! CENC AES-CTR Pattern Encryption Scheme Type in the SchemeTypeInfoBox */\n\tGF_ISOM_CENS_SCHEME\t= GF_4CC('c','e','n','s'),\n\t/*! CENC AES-CBC Pattern Encryption Scheme Type in the SchemeTypeInfoBox */\n\tGF_ISOM_CBCS_SCHEME\t= GF_4CC('c','b','c','s'),\n\t/*! PIFF Scheme Type in the SchemeTypeInfoBox */\n\tGF_ISOM_PIFF_SCHEME\t= GF_4CC('p','i','f','f'),\n\t/*! CENC sensitive encryption */\n\tGF_ISOM_SVE1_SCHEME\t= GF_4CC('s','v','e','1'),\n};\n\n\n/*! flags for GF_ISMASample*/\ntypedef enum\n{\n\t/*! signals the stream the sample belongs to uses selective encryption*/\n\tGF_ISOM_ISMA_USE_SEL_ENC = 1,\n\t/*! signals the sample is encrypted*/\n\tGF_ISOM_ISMA_IS_ENCRYPTED = 2,\n} GF_ISOISMACrypFlags;\n\n\n#ifndef GPAC_DISABLE_ISOM\n\n/*! checks if a track is encrypted or protected\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return GF_TRUE if track is protected, GF_FALSE otherwise*/\nBool gf_isom_is_track_encrypted(GF_ISOFile *isom_file, u32 trackNumber);\n\n\n\n/*! ISMA sample*/\ntypedef struct\n{\n\t/*! IV in ISMACryp is Byte Stream Offset*/\n\tu64 IV;\n\t/*! IV size in bytes, repeated from sampleDesc for convenience*/\n\tu8 IV_length;\n\t/*! key indicator*/\n\tu8 *key_indicator;\n\t/*! key indicator size, repeated from sampleDesc for convenience*/\n\tu8 KI_length;\n\t/*! payload size*/\n\tu32 dataLength;\n\t/*! payload*/\n\tu8 *data;\n\t/*! flags*/\n\tu32 flags;\n} GF_ISMASample;\n/*! creates a new empty ISMA sample\n\\return a new empty ISMA sample\n*/\nGF_ISMASample *gf_isom_ismacryp_new_sample();\n\n/*! delete an ISMA sample.\n\\note the buffer content will be destroyed by default. If you wish to keep the buffer, set dataLength to 0 in the sample before deleting it\n\\param samp the target ISMA sample\n*/\nvoid gf_isom_ismacryp_delete_sample(GF_ISMASample *samp);\n\n/*! decodes ISMACryp sample based on all info in ISMACryp sample description\n\\param data sample data\n\\param dataLength sample data size in bytes\n\\param use_selective_encryption set to GF_TRUE if sample uses selective encryption\n\\param KI_length set to the size in bytes of the key indicator - 0 means no key roll\n\\param IV_length set to the size in bytes of the initialization vector\n\\return a newly allocated ISMA sample with the parsed data\n*/\nGF_ISMASample *gf_isom_ismacryp_sample_from_data(u8 *data, u32 dataLength, Bool use_selective_encryption, u8 KI_length, u8 IV_length);\n\n/*! decodes ISMACryp sample based on sample and its descrition index\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param samp the sample to decode\n\\param sampleDescriptionIndex the sample description index of the sample to decode\n\\return the ISMA sample or NULL if not an ISMA sample or error\n*/\nGF_ISMASample *gf_isom_get_ismacryp_sample(GF_ISOFile *isom_file, u32 trackNumber, const GF_ISOSample *samp, u32 sampleDescriptionIndex);\n\n/*! checks if sample description is protected or not\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the sample description index. If 0, checks all sample descriptions for protected ones\n\\return scheme protection 4CC or 0 if not protected*/\nu32 gf_isom_is_media_encrypted(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex);\n\n/*! checks if sample description is protected with ISMACryp\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the sample description index\n\\return GF_TRUE if ISMA protection is used*/\nBool gf_isom_is_ismacryp_media(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex);\n\n/*! checks if sample description is protected with OMA DRM\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the sample description index\n\\return GF_TRUE if OMA DRM protection is used*/\nBool gf_isom_is_omadrm_media(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex);\n\n/*! gets OMA DRM configuration - all output parameters are optional and may be NULL\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the sample description index\n\\param outOriginalFormat four character code of the unprotected sample description\n\\param outSchemeType set to four character code of the protection scheme type\n\\param outSchemeVersion set to scheme protection version\n\\param outContentID set to associated ID of content\n\\param outRightsIssuerURL set to the rights issuer (license server) URL\n\\param outTextualHeaders set to OMA textual headers\n\\param outTextualHeadersLen set to the size in bytes of OMA textual headers\n\\param outPlaintextLength set to the size in bytes of clear data in file\n\\param outEncryptionType set to the OMA encryption type used\n\\param outSelectiveEncryption set to GF_TRUE if sample description uses selective encryption\n\\param outIVLength set to the size of the initialization vector\n\\param outKeyIndicationLength set to the size of the key indicator\n\\return error if any\n*/\nGF_Err gf_isom_get_omadrm_info(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, u32 *outOriginalFormat,\n                               u32 *outSchemeType, u32 *outSchemeVersion,\n                               const char **outContentID, const char **outRightsIssuerURL, const char **outTextualHeaders, u32 *outTextualHeadersLen, u64 *outPlaintextLength, u32 *outEncryptionType, Bool *outSelectiveEncryption, u32 *outIVLength, u32 *outKeyIndicationLength);\n\n/*! retrieves ISMACryp info for the given track & SDI - all output parameters are optional - URIs SHALL NOT BE MODIFIED BY USER\n\n\\note outSelectiveEncryption, outIVLength and outKeyIndicationLength are usually not needed to decode an ISMA sample when using \\ref gf_isom_get_ismacryp_sample\n\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the sample description index\n\\param outOriginalFormat set to orginal unprotected media format\n\\param outSchemeType set to 4CC of protection scheme (GF_ISOM_ISMACRYP_SCHEME = iAEC in ISMACryp 1.0)\n\\param outSchemeVersion set to version of protection scheme (1 in ISMACryp 1.0)\n\\param outSchemeURI set to URI location of scheme\n\\param outKMS_URI set to URI location of key management system - only valid with ISMACryp 1.0\n\\param outSelectiveEncryption set to whether sample-based encryption is used in media - only valid with ISMACryp 1.0\n\\param outIVLength set to length of Initial Vector - only valid with ISMACryp 1.0\n\\param outKeyIndicationLength set to length of key indicator - only valid with ISMACryp 1.0\n\\return error if any\n*/\nGF_Err gf_isom_get_ismacryp_info(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, u32 *outOriginalFormat, u32 *outSchemeType, u32 *outSchemeVersion, const char **outSchemeURI, const char **outKMS_URI, Bool *outSelectiveEncryption, u32 *outIVLength, u32 *outKeyIndicationLength);\n\n/*! gets original format four character code type of a protected media sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the sample description index. If 0, checks all sample descriptions for a protected one\n\\param outOriginalFormat set to orginal unprotected media format\n\\return error if any\n*/\nGF_Err gf_isom_get_original_format_type(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, u32 *outOriginalFormat);\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n/*! creates ISMACryp protection info for a sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the sample description index\n\\param scheme_type 4CC of protection scheme (GF_ISOM_ISMACRYP_SCHEME = iAEC in ISMACryp 1.0)\n\\param scheme_version version of protection scheme (1 in ISMACryp 1.0)\n\\param scheme_uri URI location of scheme\n\\param kms_URI URI location of key management system - only valid with ISMACryp 1.0\n\\param selective_encryption whether sample-based encryption is used in media - only valid with ISMACryp 1.0\n\\param KI_length length of key indicator - only valid with ISMACryp 1.0\n\\param IV_length length of Initial Vector - only valid with ISMACryp 1.0\n\\return error if any\n*/\nGF_Err gf_isom_set_ismacryp_protection(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, u32 scheme_type,\n                                       u32 scheme_version, char *scheme_uri, char *kms_URI,\n                                       Bool selective_encryption, u32 KI_length, u32 IV_length);\n\n/*! changes scheme URI and/or KMS URI for crypted files. Other params cannot be changed once the media is crypted\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the sample description index\n\\param scheme_uri new scheme URI, or NULL to keep previous\n\\param kms_uri new KMS URI, or NULL to keep previous\n\\return error if any\n*/\nGF_Err gf_isom_change_ismacryp_protection(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, char *scheme_uri, char *kms_uri);\n\n\n/*! creates OMA DRM protection for a sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the sample description index\n\\param contentID associated ID of content\n\\param kms_URI the rights issuer (license server) URL\n\\param encryption_type the OMA encryption type used\n\\param plainTextLength the size in bytes of clear data in file\n\\param textual_headers OMA textual headers\n\\param textual_headers_len the size in bytes of OMA textual headers\n\\param selective_encryption GF_TRUE if sample description uses selective encryption\n\\param KI_length the size of the key indicator\n\\param IV_length the size of the initialization vector\n\\return error if any\n*/\nGF_Err gf_isom_set_oma_protection(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex,\n                                  char *contentID, char *kms_URI, u32 encryption_type, u64 plainTextLength, char *textual_headers, u32 textual_headers_len,\n                                  Bool selective_encryption, u32 KI_length, u32 IV_length);\n\n/*! creates a generic protection for a sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the sample description index\n\\param scheme_type 4CC of protection scheme (GF_ISOM_ISMACRYP_SCHEME = iAEC in ISMACryp 1.0)\n\\param scheme_version version of protection scheme (1 in ISMACryp 1.0)\n\\param scheme_uri URI location of scheme\n\\param kms_URI the rights issuer (license server) URL\n\\return error if any\n*/\nGF_Err gf_isom_set_generic_protection(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, u32 scheme_type, u32 scheme_version, char *scheme_uri, char *kms_URI);\n\n/*! allocates storage for CENC side data in a senc box\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return error if any\n*/\nGF_Err gf_isom_cenc_allocate_storage(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! allocates storage for CENC side data in a PIFF senc UUID box\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param AlgorithmID algorith ID, usually 0\n\\param IV_size the size of the init vector\n\\param KID the default Key ID\n\\return error if any\n*/\nGF_Err gf_isom_piff_allocate_storage(GF_ISOFile *isom_file, u32 trackNumber, u32 AlgorithmID, u8 IV_size, bin128 KID);\n\n\n/*! adds cenc SAI for the last sample added to a track\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param container_type the code of the container (currently 'senc' for CENC or 'PSEC' for smooth)\n\\param buf the SAI buffer\n\\param len the size of the SAI buffer. If buf is NULL or len is 0, this adds an unencrypted entry (not written to file)\n\\param use_subsamples if GF_TRUE, the media format uses CENC subsamples\n\\param use_saio_32bit forces usage of 32-bit saio boxes\n\\param is_multi_key indicates if multi key is in use (required to tag saio and saiz boxes)\n\\return error if any\n*/\nGF_Err gf_isom_track_cenc_add_sample_info(GF_ISOFile *isom_file, u32 trackNumber, u32 container_type, u8 *buf, u32 len, Bool use_subsamples, Bool use_saio_32bit, Bool is_multi_key);\n\n\n\n/*! creates CENC protection for a sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the sample description index\n\\param scheme_type 4CC of protection scheme (GF_ISOM_ISMACRYP_SCHEME = iAEC in ISMACryp 1.0)\n\\param scheme_version version of protection scheme (1 in ISMACryp 1.0)\n\\param default_IsEncrypted default isEncrypted flag\n\\param default_crypt_byte_block default crypt block size for pattern encryption\n\\param default_skip_byte_block default skip block size for pattern encryption\n\\param key_info key descriptor formatted as a multi-key info (cf GF_PROP_PID_CENC_KEY)\n\\param key_info_size key descriptor size\n\\return error if any\n*/\nGF_Err gf_isom_set_cenc_protection(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, u32 scheme_type,\n                                   u32 scheme_version, u32 default_IsEncrypted, u8 default_crypt_byte_block, u8 default_skip_byte_block,\n\t\t\t\t\t\t\t\t    u8 *key_info, u32 key_info_size);\n\n\n/*! creates CENC protection for a multi-key sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the sample description index\n\\param scheme_type 4CC of protection scheme (GF_ISOM_ISMACRYP_SCHEME = iAEC in ISMACryp 1.0)\n\\param scheme_version version of protection scheme (1 in ISMACryp 1.0)\n\\param default_IsEncrypted default isEncrypted flag\n\\param default_crypt_byte_block default crypt block size for pattern encryption\n\\param default_skip_byte_block default skip block size for pattern encryption\n\\param key_info key  info (cf CENC and GF_PROP_PID_CENC_KEY)\n\\param key_info_size key info size\n\\return error if any\n*/\nGF_Err gf_isom_set_cenc_protection_mkey(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, u32 scheme_type,\n                                   u32 scheme_version, u32 default_IsEncrypted, u8 default_crypt_byte_block, u8 default_skip_byte_block,\n\t\t\t\t\t\t\t\t    u8 *key_info, u32 key_info_size);\n\n\n/*! adds PSSH info for a file, can be called several time per system ID\n\\param isom_file the target ISO file\n\\param systemID the ID of the protection system\n\\param version the version of the protection system\n\\param KID_count the number of key IDs\n\\param KID the list of key IDs\n\\param data opaque data for the protection system\n\\param len size of the opaque data\n\\param pssh_mode 0: regular PSSH in moov, 1: PIFF PSSH in moov, 2: regular PSSH in meta\n\\return error if any\n*/\nGF_Err gf_cenc_set_pssh(GF_ISOFile *isom_file, bin128 systemID, u32 version, u32 KID_count, bin128 *KID, u8 *data, u32 len, u32 pssh_mode);\n\n/*! removes CENC senc box info\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return error if any\n*/\nGF_Err gf_isom_remove_samp_enc_box(GF_ISOFile *isom_file, u32 trackNumber);\n/*! removes all CENC sample groups\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return error if any\n*/\nGF_Err gf_isom_remove_samp_group_box(GF_ISOFile *isom_file, u32 trackNumber);\n\n#endif //GPAC_DISABLE_ISOM_WRITE\n\n/*! checks if sample description is protected with Adobe systems\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the sample description index\n\\return GF_TRUE if ADOBE protection is used\n*/\nBool gf_isom_is_adobe_protection_media(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex);\n\n/*! gets adobe protection information for a sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the sample description index\n\\param outOriginalFormat set to orginal unprotected media format\n\\param outSchemeType set to 4CC of protection scheme (GF_ISOM_ISMACRYP_SCHEME = iAEC in ISMACryp 1.0)\n\\param outSchemeVersion set to version of protection scheme (1 in ISMACryp 1.0)\n\\param outMetadata set to adobe metadata string\n\\return GF_TRUE if ADOBE protection is used\n*/\nGF_Err gf_isom_get_adobe_protection_info(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, u32 *outOriginalFormat, u32 *outSchemeType, u32 *outSchemeVersion, const char **outMetadata);\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n/*! creates an adobe protection for a sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the sample description index\n\\param scheme_type 4CC of protection scheme (GF_ISOM_ISMACRYP_SCHEME = iAEC in ISMACryp 1.0)\n\\param scheme_version version of protection scheme (1 in ISMACryp 1.0)\n\\param is_selective_enc indicates if selective encryption is used\n\\param metadata metadata information\n\\param len size of metadata information in bytes\n\\return error if any\n*/\nGF_Err gf_isom_set_adobe_protection(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, u32 scheme_type, u32 scheme_version, Bool is_selective_enc, char *metadata, u32 len);\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n/*! checks of sample description is protected with CENC\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the sample description index. If 0, checks all sample descriptions for protected ones\n\\return GF_TRUE if sample protection is CENC\n*/\nBool gf_isom_is_cenc_media(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex);\n/*! gets CENC information of a sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the sample description index\n\\param outOriginalFormat set to orginal unprotected media format\n\\param outSchemeType set to 4CC of protection scheme (GF_ISOM_ISMACRYP_SCHEME = iAEC in ISMACryp 1.0)\n\\param outSchemeVersion set to version of protection scheme (1 in ISMACryp 1.0)\n\\return error if any\n*/\nGF_Err gf_isom_get_cenc_info(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, u32 *outOriginalFormat, u32 *outSchemeType, u32 *outSchemeVersion);\n\n\n/*! gets CENC auxiliary info of a sample as a buffer\n\\note the serialized buffer format is exactly a CencSampleAuxiliaryDataFormat\n\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleNumber the target sample\n\\param sampleDescIndex the sample description index\n\\param container_type is type of box which contains the sample auxiliary information. Now we have two type: GF_ISOM_BOX_UUID_PSEC and GF_ISOM_BOX_TYPE_SENC\n\\param out_buffer set to a newly allocated buffer, or reallocated buffer if not NULL\n\\param outSize set to the size of the serialized buffer. If an existing buffer was passed, the passed value shall be the allocated buffer size (the returned value is still the buffer size)\n\\return error if any\n*/\nGF_Err gf_isom_cenc_get_sample_aux_info(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleNumber, u32 sampleDescIndex, u32 *container_type, u8 **out_buffer, u32 *outSize);\n\n/*! gets CENC default info for a sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the sample description index\n\\param container_type set to the container type of SAI data\n\\param default_IsEncrypted set to default isEncrypted flag\n\\param crypt_byte_block set to default crypt block size for pattern encryption\n\\param skip_byte_block set to default skip block size for pattern encryption\n\\param key_info set to multikey descriptor (cf CENC and GF_PROP_PID_CENC_KEY)\n\\param key_info_size set to multikey descriptor size\n\\return error if any\n*/\nGF_Err gf_isom_cenc_get_default_info(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, u32 *container_type, Bool *default_IsEncrypted, u8 *crypt_byte_block, u8 *skip_byte_block, const u8 **key_info, u32 *key_info_size);\n\n/*! gets the number of PSSH defined\n\\param isom_file the target ISO file\n\\return number of PSSH defined\n*/\nu32 gf_isom_get_pssh_count(GF_ISOFile *isom_file);\n\n/*! gets PSS info\n\\param isom_file the target ISO file\n\\param pssh_index 1-based index of PSSH to query, see \\ref gf_isom_get_pssh_count\n\\param SystemID set to the protection system ID\n\\param version set to the protection system version\n\\param KID_count set to the number of key IDs defined\n\\param KIDs array of defined key IDs\n\\param private_data set to a buffer containing system ID private data\n\\param private_data_size set to the size of the system ID private data\n\\return error if any\n*/\nGF_Err gf_isom_get_pssh_info(GF_ISOFile *isom_file, u32 pssh_index, bin128 SystemID, u32 *version, u32 *KID_count, const bin128 **KIDs, const u8 **private_data, u32 *private_data_size);\n\n#ifndef GPAC_DISABLE_ISOM_DUMP\n/*! dumps ismacrypt protection of sample descriptions to xml trace\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param trace the file object to dump to\n\\return error if any\n*/\nGF_Err gf_isom_dump_ismacryp_protection(GF_ISOFile *isom_file, u32 trackNumber, FILE * trace);\n/*! dumps ismacrypt sample to xml trace\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param SampleNum the target sample number\n\\param trace the file object to dump to\n\\return error if any\n*/\nGF_Err gf_isom_dump_ismacryp_sample(GF_ISOFile *isom_file, u32 trackNumber, u32 SampleNum, FILE *trace);\n#endif\n\n/*! gets CENC configuration for a given sample\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleNumber the target sample number\n\\param IsEncrypted set to GF_TRUE if the sample is encrypted, GF_FALSE otherwise (optional can be NULL)\n\\param crypt_byte_block set to crypt block count for pattern encryption (optional can be NULL)\n\\param skip_byte_block set to skip block count for pattern encryption (optional can be NULL)\n\\param key_info set to key descriptor (cf GF_PROP_PID_CENC_KEY)\n\\param key_info_size set to key descriptor size\n\\return error if any\n*/\nGF_Err gf_isom_get_sample_cenc_info(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleNumber, Bool *IsEncrypted, u8 *crypt_byte_block, u8 *skip_byte_block, const u8 **key_info, u32 *key_info_size);\n\n/*! @} */\n\n/*!\n\\addtogroup isometa_grp Meta and Image File Format\n\\ingroup iso_grp\n\n@{\n*/\n\n\n/*! gets meta type\n\\param isom_file the target ISO file\n\\param root_meta if GF_TRUE uses meta at the file, otherwise uses meta at the movie level if track number is 0\n\\param track_num if GF_TRUE and root_meta is GF_FALSE, uses meta at the track level\n\\return 0 if no meta found, or four char code of meta (eg, \"mp21\", \"smil\", ...)*/\nu32 gf_isom_get_meta_type(GF_ISOFile *isom_file, Bool root_meta, u32 track_num);\n\n/*! checks if the meta has an XML container (note that XML data can also be included as items).\n\\param isom_file the target ISO file\n\\param root_meta if GF_TRUE uses meta at the file, otherwise uses meta at the movie level if track number is 0\n\\param track_num if GF_TRUE and root_meta is GF_FALSE, uses meta at the track level\n\\return 0 (no XML or error), 1 (XML text), 2 (BinaryXML, eg BiM) */\nu32 gf_isom_has_meta_xml(GF_ISOFile *isom_file, Bool root_meta, u32 track_num);\n\n/*! extracts XML (if any) from given meta\n\\param isom_file the target ISO file\n\\param root_meta if GF_TRUE uses meta at the file, otherwise uses meta at the movie level if track number is 0\n\\param track_num if GF_TRUE and root_meta is GF_FALSE, uses meta at the track level\n\\param outName output file path and location for writing\n\\param is_binary indicates if XML is Bim or regular XML\n\\return error if any\n*/\nGF_Err gf_isom_extract_meta_xml(GF_ISOFile *isom_file, Bool root_meta, u32 track_num, char *outName, Bool *is_binary);\n\n/*! checks the number of items in a meta\n\\param isom_file the target ISO file\n\\param root_meta if GF_TRUE uses meta at the file, otherwise uses meta at the movie level if track number is 0\n\\param track_num if GF_TRUE and root_meta is GF_FALSE, uses meta at the track level\n\\return number of items*/\nu32 gf_isom_get_meta_item_count(GF_ISOFile *isom_file, Bool root_meta, u32 track_num);\n\n/*! gets item info for the given item\n\\note When an item is fully contained in file, both item_url and item_urn are set to NULL\n\n\\param isom_file the target ISO file\n\\param root_meta if GF_TRUE uses meta at the file, otherwise uses meta at the movie level if track number is 0\n\\param track_num if GF_TRUE and root_meta is GF_FALSE, uses meta at the track level\n\\param item_num 1-based index of item to query\n\\param itemID set to item ID in file (optional, can be NULL)\n\\param type set to item 4CC type\n\\param protection_scheme set to 0 if not protected, or scheme type used if item is protected. If protected but scheme type not present, set to 'unkw'\n\\param protection_scheme_version set to 0 if not protected, or scheme version used if item is protected\n\\param is_self_reference set to item is the file itself\n\\param item_name set to the item name (optional, can be NULL)\n\\param item_mime_type set to the item mime type (optional, can be NULL)\n\\param item_encoding set to the item content encoding type (optional, can be NULL)\n\\param item_url set to the URL of external resource containing this item data if any.\n\\param item_urn set to the URN of external resource containing this item data if any.\n\\return error if any\n*/\nGF_Err gf_isom_get_meta_item_info(GF_ISOFile *isom_file, Bool root_meta, u32 track_num, u32 item_num,\n                                  u32 *itemID, u32 *type, u32 *protection_scheme, u32 *protection_scheme_version, Bool *is_self_reference,\n                                  const char **item_name, const char **item_mime_type, const char **item_encoding,\n                                  const char **item_url, const char **item_urn);\n\n/*! gets item flags for the given item\n\n\\param isom_file the target ISO file\n\\param root_meta if GF_TRUE uses meta at the file, otherwise uses meta at the movie level if track number is 0\n\\param track_num if GF_TRUE and root_meta is GF_FALSE, uses meta at the track level\n\\param item_num 1-based index of item to query\n\\return item flags\n*/\nu32 gf_isom_get_meta_item_flags(GF_ISOFile *isom_file, Bool root_meta, u32 track_num, u32 item_num);\n\n/*! gets item index from item ID\n\\param isom_file the target ISO file\n\\param root_meta if GF_TRUE uses meta at the file, otherwise uses meta at the movie level if track number is 0\n\\param track_num if GF_TRUE and root_meta is GF_FALSE, uses meta at the track level\n\\param item_ID ID of the item to search\n\\return item index if found, 0 otherwise\n*/\nu32 gf_isom_get_meta_item_by_id(GF_ISOFile *isom_file, Bool root_meta, u32 track_num, u32 item_ID);\n\n/*! extracts an item from given meta\n\\param isom_file the target ISO file\n\\param root_meta if GF_TRUE uses meta at the file, otherwise uses meta at the movie level if track number is 0\n\\param track_num if GF_TRUE and root_meta is GF_FALSE, uses meta at the track level\n\\param item_num 1-based index of item to query\n\\param dump_file_name if NULL, uses item name for dumping, otherwise dumps in given file object (binary write mode)\n\\return error if any\n*/\nGF_Err gf_isom_extract_meta_item(GF_ISOFile *isom_file, Bool root_meta, u32 track_num, u32 item_num, const char *dump_file_name);\n\n/*! extracts item from given meta in memory\n\\param isom_file the target ISO file\n\\param root_meta if GF_TRUE uses meta at the file, otherwise uses meta at the movie level if track number is 0\n\\param track_num if GF_TRUE and root_meta is GF_FALSE, uses meta at the track level\n\\param item_id the ID of the item to dump\n\\param out_data set to allocated buffer containing the item, shall be freeed by user\n\\param out_size set to the size of the allocated buffer\n\\param out_alloc_size set to the allocated size of the buffer (this allows passing an existing buffer without always reallocating it)\n\\param mime_type set to the mime type of the item\n\\param use_annex_b for image items based on NALU formats (AVC, HEVC) indicates to extract the data as Annex B format (with start codes)\n\\return error if any\n*/\nGF_Err gf_isom_extract_meta_item_mem(GF_ISOFile *isom_file, Bool root_meta, u32 track_num, u32 item_id, u8 **out_data, u32 *out_size, u32 *out_alloc_size, const char **mime_type, Bool use_annex_b);\n\n\n/*! fetch CENC info for an item\n\\param isom_file the target ISO file\n\\param root_meta if GF_TRUE uses meta at the file, otherwise uses meta at the movie level if track number is 0\n\\param track_num if GF_TRUE and root_meta is GF_FALSE, uses meta at the track level\n\\param item_id the ID of the item to dump\n\\param is_protected set to GF_TRUE if item is protected\n\\param skip_byte_block set to skip_byte_block or 0 if no pattern\n\\param crypt_byte_block set to crypt_byte_block or 0 if no pattern\n\\param key_info set to key info\n\\param key_info_size set to key info size\n\\param aux_info_type_parameter set to the CENC auxiliary type param of SAI data\n\\param sai_out_data set to allocated buffer containing the item, shall be freeed by user - may be NULL to only retrieve the info\n\\param sai_out_size set to the size of the allocated buffer - may be NULL if  sai_out_data is NULL\n\\param sai_out_alloc_size set to the allocated size of the buffer (this allows passing an existing buffer without always reallocating it) - may be NULL if  sai_out_data is NULL\n\\return error if any\n*/\nGF_Err gf_isom_extract_meta_item_get_cenc_info(GF_ISOFile *isom_file, Bool root_meta, u32 track_num, u32 item_id, Bool *is_protected,\n\tu8 *skip_byte_block, u8 *crypt_byte_block, const u8 **key_info, u32 *key_info_size, u32 *aux_info_type_parameter,\n\tu8 **sai_out_data, u32 *sai_out_size, u32 *sai_out_alloc_size);\n\n/*! gets primary item ID\n\\param isom_file the target ISO file\n\\param root_meta if GF_TRUE uses meta at the file, otherwise uses meta at the movie level if track number is 0\n\\param track_num if GF_TRUE and root_meta is GF_FALSE, uses meta at the track level\n\\return primary item ID, 0 if none found (primary can also be stored through meta XML)*/\nu32 gf_isom_get_meta_primary_item_id(GF_ISOFile *isom_file, Bool root_meta, u32 track_num);\n\n/*! gets number of references of a given type from a given item ID\n\\param isom_file the target ISO file\n\\param root_meta if GF_TRUE uses meta at the file, otherwise uses meta at the movie level if track number is 0\n\\param track_num if GF_TRUE and root_meta is GF_FALSE, uses meta at the track level\n\\param from_id item ID to check\n\\param type reference type to check\n\\return number of referenced items*/\nu32 gf_isom_meta_get_item_ref_count(GF_ISOFile *isom_file, Bool root_meta, u32 track_num, u32 from_id, u32 type);\n\n/*! gets ID  of reference of a given type and index from a given item ID\n\\param isom_file the target ISO file\n\\param root_meta if GF_TRUE uses meta at the file, otherwise uses meta at the movie level if track number is 0\n\\param track_num if GF_TRUE and root_meta is GF_FALSE, uses meta at the track level\n\\param from_id item ID to check\n\\param type reference type to check\n\\param ref_idx 1-based index of reference to check\n\\return ID if the referred item*/\nu32 gf_isom_meta_get_item_ref_id(GF_ISOFile *isom_file, Bool root_meta, u32 track_num, u32 from_id, u32 type, u32 ref_idx);\n\n/*! gets number of references of a given type to a given item ID\n\\param isom_file the target ISO file\n\\param root_meta if GF_TRUE uses meta at the file, otherwise uses meta at the movie level if track number is 0\n\\param track_num if GF_TRUE and root_meta is GF_FALSE, uses meta at the track level\n\\param from_id item ID to check\n\\param type reference type to check\n\\return number of referenced items*/\nu32 gf_isom_meta_item_has_ref(GF_ISOFile *isom_file, Bool root_meta, u32 track_num, u32 to_id, u32 type);\n\n\n/*! item tile mode*/\ntypedef enum {\n\t/*! not a tile item*/\n\tTILE_ITEM_NONE = 0,\n\t/*! a tile item without base*/\n\tTILE_ITEM_ALL_NO_BASE,\n\t/*! a tile item with base*/\n\tTILE_ITEM_ALL_BASE,\n\t/*! a tile item grid*/\n\tTILE_ITEM_ALL_GRID,\n\t/*! a tile item single*/\n\tTILE_ITEM_SINGLE\n} GF_TileItemMode;\n\n/*! Image overlay offset properties*/\ntypedef struct {\n\tu32 horizontal;\n\tu32 vertical;\n} GF_ImageItemOverlayOffset;\n\n/*! Image protection item properties*/\ntypedef struct\n{\n\tu32 scheme_type;\n\tu32 scheme_version;\n\tu8 crypt_byte_block;\n\tu8 skip_byte_block;\n\tconst u8 *key_info;\n\tu32 key_info_size;\n\tconst u8 *sai_data;\n\tu32 sai_data_size;\n} GF_ImageItemProtection;\n\n/*! Image item properties*/\ntypedef struct\n{\n\t/*! width in pixels*/\n\tu32 width;\n\t/*! height in pixless*/\n\tu32 height;\n\t/*! pixel aspect ratio numerator*/\n\tu32 hSpacing;\n\t/*! pixel aspect ratio denominator*/\n\tu32 vSpacing;\n\t/*! horizontal offset in pixels*/\n\tu32 hOffset;\n\t/*! vertical offset in pixels*/\n\tu32 vOffset;\n\t/*! angle in radians*/\n\tu32 angle;\n\t/*! mirroring axis: 0 = not set, 1 = vertical, 2 = horizontal*/\n\tu32 mirror;\n\t/*! hidden flag*/\n\tBool hidden;\n\t/*! clean aperture */\n\tu32 clap_wnum, clap_wden, clap_hnum, clap_hden, clap_hoden, clap_voden;\n\ts32 clap_honum, clap_vonum;\n\t/*! pointer to configuration box*/\n\tvoid *config;\n\t/*! tile item mode*/\n\tGF_TileItemMode tile_mode;\n\t/*! tile number */\n\tu32 single_tile_number;\n\t/*! time for importing*/\n\tDouble time;\n\t/*! end time for importing*/\n\tDouble end_time;\n\t/*! step time between imports*/\n\tDouble step_time;\n\t/*! sample num for importing*/\n\tu32 sample_num;\n\t/*! file containg iCC data for importing*/\n\tchar iccPath[GF_MAX_PATH];\n\t/*! is alpha*/\n\tBool alpha;\n\t/*! is depth*/\n\tBool depth;\n\t/*! number of channels*/\n\tu8 num_channels;\n\t/*! bits per channels in bits*/\n\tu32 bits_per_channel[3];\n\t/*! number of columns in grid*/\n\tu32 num_grid_columns;\n\t/*! number of rows in grid*/\n\tu32 num_grid_rows;\n\t/*! number of overlayed images*/\n\tu32 overlay_count;\n\t/*! overlay offsets*/\n\tGF_ImageItemOverlayOffset *overlay_offsets;\n\t/*! canvas overlay color*/\n\tu32 overlay_canvas_fill_value_r;\n\tu32 overlay_canvas_fill_value_g;\n\tu32 overlay_canvas_fill_value_b;\n\tu32 overlay_canvas_fill_value_a;\n\t/*! protection info, NULL if item is not protected*/\n\tGF_ImageItemProtection *cenc_info;\n\t/*! If set, reference image from sample sample_num (same file data used for sample and item)*/\n\tBool use_reference;\n\t/*ID of item to use as source*/\n\tu32 item_ref_id;\n\t/*if set, copy all properties of source item*/\n\tBool copy_props;\n\t/*only set when importing non-ref from ISOBMF*/\n\tGF_ISOFile *src_file;\n\tBool auto_grid;\n\tDouble auto_grid_ratio;\n\t/*AV1 layer sizes except last layer - set during import*/\n\tu32 av1_layer_size[3];\n\t/*AV1 operation point index*/\n\tu8 av1_op_index;\n\n\t/*interlace type - uncv*/\n\tu8 interlace_type;\n\n\tconst char *aux_urn;\n\tconst u8 *aux_data;\n\tu32 aux_data_len;\n\n\t//serialized box array config, only used for creating item\n\tu8 *config_ba;\n\tu32 config_ba_size;\n\n} GF_ImageItemProperties;\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n/*! sets meta type (four char int, eg \"mp21\", ...), creating a meta box if not found\n\\param isom_file the target ISO file\n\\param root_meta if GF_TRUE uses meta at the file, otherwise uses meta at the movie level if track number is 0\n\\param track_num if GF_TRUE and root_meta is GF_FALSE, uses meta at the track level\n\\param metaType the type of meta to create. If 0, removes the meta box\n\\return error if any\n*/\nGF_Err gf_isom_set_meta_type(GF_ISOFile *isom_file, Bool root_meta, u32 track_num, u32 metaType);\n\n/*! removes meta XML info if any\n\\param isom_file the target ISO file\n\\param root_meta if GF_TRUE uses meta at the file, otherwise uses meta at the movie level if track number is 0\n\\param track_num if GF_TRUE and root_meta is GF_FALSE, uses meta at the track level\n\\return error if any\n*/\nGF_Err gf_isom_remove_meta_xml(GF_ISOFile *isom_file, Bool root_meta, u32 track_num);\n\n/*! sets meta XML data from file or memory - erase any previously (Binary)XML info\n\\param isom_file the target ISO file\n\\param root_meta if GF_TRUE uses meta at the file, otherwise uses meta at the movie level if track number is 0\n\\param track_num if GF_TRUE and root_meta is GF_FALSE, uses meta at the track level\n\\param XMLFileName the XML file to import as XML item, or NULL if data is specified\n\\param data buffer containing XML data, or NULL if file is specified\n\\param data_size size of buffer in bytes, ignored if file is specified\n\\param IsBinaryXML indicates if the content of the XML file is binary XML (BIM) or not\n\\return error if any\n*/\nGF_Err gf_isom_set_meta_xml(GF_ISOFile *isom_file, Bool root_meta, u32 track_num, char *XMLFileName, unsigned char *data, u32 data_size, Bool IsBinaryXML);\n\n/*! gets next available item ID in a meta\n\\param isom_file the target ISO file\n\\param root_meta if GF_TRUE uses meta at the file, otherwise uses meta at the movie level if track number is 0\n\\param track_num if GF_TRUE and root_meta is GF_FALSE, uses meta at the track level\n\\param item_id set to the next available item ID\n\\return error if any\n*/\nGF_Err gf_isom_meta_get_next_item_id(GF_ISOFile *isom_file, Bool root_meta, u32 track_num, u32 *item_id);\n\n/*! adds an item to a meta box from file\n\\param isom_file the target ISO file\n\\param root_meta if GF_TRUE uses meta at the file, otherwise uses meta at the movie level if track number is 0\n\\param track_num if GF_TRUE and root_meta is GF_FALSE, uses meta at the track level\n\\param self_reference if GF_TRUE, indicates that the item is in fact the entire container file\n\\param resource_path path to the file to add\n\\param item_name name of the item\n\\param item_id ID of the item, can be 0\n\\param item_type four character code of item type\n\\param mime_type mime type of the item, can be NULL\n\\param content_encoding content encoding of the item, can be NULL\n\\param URL URL of the item for external data reference (data is not contained in meta parent file)\n\\param URN URN of the item for external data reference (data is not contained in meta parent file)\n\\param image_props image properties information for image items\n\\return error if any\n*/\nGF_Err gf_isom_add_meta_item(GF_ISOFile *isom_file, Bool root_meta, u32 track_num, Bool self_reference, char *resource_path, const char *item_name, u32 item_id, u32 item_type, const char *mime_type, const char *content_encoding, const char *URL, const char *URN, GF_ImageItemProperties *image_props);\n\n#endif //GPAC_DISABLE_ISOM\n\n/*! item extend description*/\ntypedef struct\n{\n\t/*! offset of extent in file*/\n\tu64 extent_offset;\n\t/*! size of extent*/\n\tu64 extent_length;\n\t/*! index of extent*/\n\tu64 extent_index;\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\t/*! for storage only, original offset in source file*/\n\tu64 original_extent_offset;\n#endif\n} GF_ItemExtentEntry;\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n/*! adds an item to a meta box from memory\n\\param isom_file the target ISO file\n\\param root_meta if GF_TRUE uses meta at the file, otherwise uses meta at the movie level if track number is 0\n\\param track_num if GF_TRUE and root_meta is GF_FALSE, uses meta at the track level\n\\param item_name name of the item\n\\param item_id ID of the item, can be NULL, can be 0 in input, set to item ID after call\n\\param item_type four character code of item type\n\\param mime_type mime type of the item, can be NULL\n\\param content_encoding content encoding of the item, can be NULL\n\\param image_props image properties information for image items\n\\param data buffer containing the item data\n\\param data_len size of item data buffer in bytes\n\\param item_extent_refs list of item extend description, or NULL\n\\return error if any\n*/\nGF_Err gf_isom_add_meta_item_memory(GF_ISOFile *isom_file, Bool root_meta, u32 track_num, const char *item_name, u32 *item_id, u32 item_type, const char *mime_type, const char *content_encoding, GF_ImageItemProperties *image_props, char *data, u32 data_len, GF_List *item_extent_refs);\n\n/*! adds an item to a meta box as a reference to a sample\n\\param isom_file the target ISO file\n\\param root_meta if GF_TRUE uses meta at the file, otherwise uses meta at the movie level if track number is 0\n\\param track_num if GF_TRUE and root_meta is GF_FALSE, uses meta at the track level\n\\param item_name name of the item\n\\param item_id ID of the item, can be 0\n\\param item_type four character code of item type\n\\param mime_type mime type of the item, can be NULL\n\\param content_encoding content encoding of the item, can be NULL\n\\param image_props image properties information for image items\n\\param tk_id source track ID\n\\param sample_num number of sample to reference\n\\return error if any\n*/\nGF_Err gf_isom_add_meta_item_sample_ref(GF_ISOFile *isom_file, Bool root_meta, u32 track_num, const char *item_name, u32 *item_id, u32 item_type, const char *mime_type, const char *content_encoding, GF_ImageItemProperties *image_props, GF_ISOTrackID tk_id, u32 sample_num);\n\n/*! creates an image grid item\n\\param isom_file the target ISO file\n\\param root_meta if GF_TRUE uses meta at the file, otherwise uses meta at the movie level if meta_track_number is 0\n\\param meta_track_number if GF_TRUE and root_meta is GF_FALSE, uses meta at the track level\n\\param item_name name of the item\n\\param item_id ID of the item, can be 0\n\\param image_props image properties information for image items\n\\return error if any\n*/\nGF_Err gf_isom_iff_create_image_grid_item(GF_ISOFile *isom_file, Bool root_meta, u32 meta_track_number, const char *item_name, u32 item_id, GF_ImageItemProperties *image_props);\n\n/*! creates an image overlay item\n\\param isom_file the target ISO file\n\\param root_meta if GF_TRUE uses meta at the file, otherwise uses meta at the movie level if meta_track_number is 0\n\\param meta_track_number if GF_TRUE and root_meta is GF_FALSE, uses meta at the track level\n\\param item_name name of the item\n\\param item_id ID of the item, can be 0\n\\param image_props image properties information for image items\n\\return error if any\n*/\nGF_Err gf_isom_iff_create_image_overlay_item(GF_ISOFile *isom_file, Bool root_meta, u32 meta_track_number, const char *item_name, u32 item_id, GF_ImageItemProperties *image_props);\n\n/*! creates an image identity item\n\\param isom_file the target ISO file\n\\param root_meta if GF_TRUE uses meta at the file, otherwise uses meta at the movie level if meta_track_number is 0\n\\param meta_track_number if GF_TRUE and root_meta is GF_FALSE, uses meta at the track level\n\\param item_name name of the item\n\\param item_id ID of the item, can be 0\n\\param image_props image properties information for image items\n\\return error if any\n*/\nGF_Err gf_isom_iff_create_image_identity_item(GF_ISOFile *isom_file, Bool root_meta, u32 meta_track_number, const char *item_name, u32 item_id, GF_ImageItemProperties *image_props);\n\n/*! creates image item(s) from samples of a media track\n\\param isom_file the target ISO file\n\\param root_meta if GF_TRUE uses meta at the file, otherwise uses meta at the movie level if meta_track_number is 0\n\\param meta_track_number if GF_TRUE and root_meta is GF_FALSE, uses meta at the track level\n\\param media_track track number to import samples from\n\\param item_name name of the item\n\\param item_id ID of the item, can be 0\n\\param image_props image properties information for image items\n\\param item_extent_refs list of item extend description, or NULL\n\\return error if any\n*/\nGF_Err gf_isom_iff_create_image_item_from_track(GF_ISOFile *isom_file, Bool root_meta, u32 meta_track_number, u32 media_track, const char *item_name, u32 item_id, GF_ImageItemProperties *image_props, GF_List *item_extent_refs);\n\n/*! removes item from meta\n\\param isom_file the target ISO file\n\\param root_meta if GF_TRUE uses meta at the file, otherwise uses meta at the movie level if track number is 0\n\\param track_num if GF_TRUE and root_meta is GF_FALSE, uses meta at the track level\n\\param item_num 1-based index of the item to remove\n\\param keep_refs do not modify item reference, typically used when replacing an item\n\\param keep_props keep property association for properties with 4CC listed in keep_props (coma-seprated list)\n\\return error if any\n*/\nGF_Err gf_isom_remove_meta_item(GF_ISOFile *isom_file, Bool root_meta, u32 track_num, u32 item_num, Bool keep_refs, const char *keep_props);\n\n/*! sets the given item as the primary one\n\\warning This SHALL NOT be used if the meta has a valid XML data\n\\param isom_file the target ISO file\n\\param root_meta if GF_TRUE uses meta at the file, otherwise uses meta at the movie level if track number is 0\n\\param track_num if GF_TRUE and root_meta is GF_FALSE, uses meta at the track level\n\\param item_num 1-based index of the item to remove\n\\return error if any\n*/\nGF_Err gf_isom_set_meta_primary_item(GF_ISOFile *isom_file, Bool root_meta, u32 track_num, u32 item_num);\n\n/*! adds an item reference to another item\n\\param isom_file the target ISO file\n\\param root_meta if GF_TRUE uses meta at the file, otherwise uses meta at the movie level if track number is 0\n\\param track_num if GF_TRUE and root_meta is GF_FALSE, uses meta at the track level\n\\param from_id ID of item the reference is from\n\\param to_id ID of item the reference is to\n\\param type four character code of reference\n\\param ref_index set to the 1-based index of the reference\n\\return error if any\n*/\nGF_Err gf_isom_meta_add_item_ref(GF_ISOFile *isom_file, Bool root_meta, u32 track_num, u32 from_id, u32 to_id, u32 type, u64 *ref_index);\n\n/*! adds the item to the given group\n\\param isom_file the target ISO file\n\\param root_meta if GF_TRUE uses meta at the file, otherwise uses meta at the movie level if track number is 0\n\\param track_num if GF_TRUE and root_meta is GF_FALSE, uses meta at the track level\n\\param item_id ID of item to add\n\\param group_id ID of group, 0 if needs to be determined from the file\n\\param group_type four character code of group\n\\return error if any\n*/\nGF_Err gf_isom_meta_add_item_group(GF_ISOFile *isom_file, Bool root_meta, u32 track_num, u32 item_id, u32 group_id, u32 group_type);\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n/*! gets image item properties\n\\param isom_file the target ISO file\n\\param root_meta if GF_TRUE uses meta at the file, otherwise uses meta at the movie level if track number is 0\n\\param track_num if GF_TRUE and root_meta is GF_FALSE, uses meta at the track level\n\\param item_id ID of the item\n\\param out_image_props set to the image properties information of the item\n\\param unmapped_props will contain all properties (box) not mapped to image properties. May be NULL. DO NOT DESTROY the content of the list\n\n\\return error if any\n*/\nGF_Err gf_isom_get_meta_image_props(GF_ISOFile *isom_file, Bool root_meta, u32 track_num, u32 item_id, GF_ImageItemProperties *out_image_props, GF_List *unmapped_props);\n\n/*! @} */\n\n\n#endif //GPAC_DISABLE_ISOM\n\n/*!\n\\addtogroup isotags_grp iTunes tagging\n\\ingroup iso_grp\n\n@{\n*/\n\n/*! iTunes info tags */\ntypedef enum\n{\n\t/*probe is only used to check if iTunes info are present*/\n\tGF_ISOM_ITUNE_PROBE = 0,\n\t/*all is only used to remove all tags*/\n\tGF_ISOM_ITUNE_RESET = 1,\n\tGF_ISOM_ITUNE_NAME \t\t\t\t= GF_4CC( 0xA9, 'n', 'a', 'm' ),\n\tGF_ISOM_ITUNE_ARTIST \t\t\t= GF_4CC( 0xA9, 'A', 'R', 'T' ),\n\tGF_ISOM_ITUNE_ALBUM_ARTIST \t\t= GF_4CC( 'a', 'A', 'R', 'T' ),\n\tGF_ISOM_ITUNE_ALBUM\t\t\t\t= GF_4CC( 0xA9, 'a', 'l', 'b' ),\n\tGF_ISOM_ITUNE_GROUP \t\t\t= GF_4CC( 0xA9, 'g', 'r', 'p' ),\n\tGF_ISOM_ITUNE_WRITER \t\t\t= GF_4CC( 0xA9, 'w', 'r', 't' ),\n\tGF_ISOM_ITUNE_COMMENT \t\t\t= GF_4CC( 0xA9, 'c', 'm', 't' ),\n\tGF_ISOM_ITUNE_GENRE_USER\t\t= GF_4CC( 0xA9, 'g', 'e', 'n'),\n\tGF_ISOM_ITUNE_GENRE \t\t\t= GF_4CC( 'g', 'n', 'r', 'e' ),\n\tGF_ISOM_ITUNE_CREATED \t\t\t= GF_4CC( 0xA9, 'd', 'a', 'y' ),\n\tGF_ISOM_ITUNE_TRACKNUMBER \t\t= GF_4CC( 't', 'r', 'k', 'n' ),\n\tGF_ISOM_ITUNE_DISK \t\t\t\t= GF_4CC( 'd', 'i', 's', 'k' ),\n\tGF_ISOM_ITUNE_TEMPO \t\t\t= GF_4CC( 't', 'm', 'p', 'o' ),\n\tGF_ISOM_ITUNE_COMPILATION \t\t= GF_4CC( 'c', 'p', 'i', 'l' ),\n\tGF_ISOM_ITUNE_TV_SHOW \t\t\t= GF_4CC( 't', 'v', 's', 'h'),\n\tGF_ISOM_ITUNE_TV_EPISODE \t\t= GF_4CC( 't', 'v', 'e', 'n'),\n\tGF_ISOM_ITUNE_TV_SEASON \t\t= GF_4CC( 't', 'v', 's', 'n'),\n\tGF_ISOM_ITUNE_TV_EPISODE_NUM \t= GF_4CC( 't', 'v', 'e', 's'),\n\tGF_ISOM_ITUNE_TV_NETWORK \t\t= GF_4CC( 't', 'v', 'n', 'n'),\n\tGF_ISOM_ITUNE_DESCRIPTION\t \t= GF_4CC( 'd', 'e', 's', 'c' ),\n\tGF_ISOM_ITUNE_LONG_DESCRIPTION\t= GF_4CC( 'l', 'd', 'e', 's'),\n\tGF_ISOM_ITUNE_LYRICS \t\t\t= GF_4CC( 0xA9, 'l', 'y', 'r' ),\n\tGF_ISOM_ITUNE_SORT_NAME \t\t= GF_4CC( 's', 'o', 'n', 'm' ),\n\tGF_ISOM_ITUNE_SORT_ARTIST \t\t= GF_4CC( 's', 'o', 'a', 'r' ),\n\tGF_ISOM_ITUNE_SORT_ALB_ARTIST \t= GF_4CC( 's', 'o', 'a', 'a' ),\n\tGF_ISOM_ITUNE_SORT_ALBUM\t \t= GF_4CC( 's', 'o', 'a', 'l' ),\n\tGF_ISOM_ITUNE_SORT_COMPOSER\t \t= GF_4CC( 's', 'o', 'c', 'o' ),\n\tGF_ISOM_ITUNE_SORT_SHOW\t \t\t= GF_4CC( 's', 'o', 's', 'n' ),\n\tGF_ISOM_ITUNE_COVER_ART \t\t= GF_4CC( 'c', 'o', 'v', 'r' ),\n\tGF_ISOM_ITUNE_COPYRIGHT \t\t= GF_4CC( 'c', 'p', 'r', 't' ),\n\tGF_ISOM_ITUNE_TOOL \t\t\t\t= GF_4CC( 0xA9, 't', 'o', 'o' ),\n\tGF_ISOM_ITUNE_ENCODER \t\t\t= GF_4CC( 0xA9, 'e', 'n', 'c' ),\n\tGF_ISOM_ITUNE_PURCHASE_DATE \t= GF_4CC( 'p', 'u', 'r', 'd' ),\n\tGF_ISOM_ITUNE_PODCAST\t\t \t= GF_4CC( 'p', 'c', 's', 't' ),\n\tGF_ISOM_ITUNE_PODCAST_URL\t \t= GF_4CC( 'p', 'u', 'r', 'l' ),\n\tGF_ISOM_ITUNE_KEYWORDS \t\t\t= GF_4CC( 'k', 'y', 'y', 'w'),\n\tGF_ISOM_ITUNE_CATEGORY \t\t\t= GF_4CC( 'c', 'a', 't', 'g'),\n\tGF_ISOM_ITUNE_HD_VIDEO \t\t\t= GF_4CC( 'h', 'd', 'v', 'd'),\n\tGF_ISOM_ITUNE_MEDIA_TYPE \t\t= GF_4CC( 's', 't', 'i', 'k'),\n\tGF_ISOM_ITUNE_RATING\t \t\t= GF_4CC( 'r', 't', 'n', 'g'),\n\tGF_ISOM_ITUNE_GAPLESS \t\t\t= GF_4CC( 'p', 'g', 'a', 'p' ),\n\tGF_ISOM_ITUNE_COMPOSER \t\t= GF_4CC( 0xA9, 'c', 'o', 'm' ),\n\tGF_ISOM_ITUNE_TRACK \t\t= GF_4CC( 0xA9, 't', 'r', 'k' ),\n\tGF_ISOM_ITUNE_CONDUCTOR \t= GF_4CC( 0xA9, 'c', 'o', 'n' ),\n\n\tGF_ISOM_ITUNE_ART_DIRECTOR \t= GF_4CC( 0xA9, 'a', 'r', 'd' ),\n\tGF_ISOM_ITUNE_ARRANGER\t \t= GF_4CC( 0xA9, 'a', 'r', 'g' ),\n\tGF_ISOM_ITUNE_LYRICIST\t \t= GF_4CC( 0xA9, 'a', 'u', 't' ),\n\tGF_ISOM_ITUNE_COPY_ACK\t \t= GF_4CC( 0xA9, 'c', 'a', 'k' ),\n\tGF_ISOM_ITUNE_SONG_DESC\t \t= GF_4CC( 0xA9, 'd', 'e', 's' ),\n\tGF_ISOM_ITUNE_DIRECTOR\t \t= GF_4CC( 0xA9, 'd', 'i', 'r' ),\n\tGF_ISOM_ITUNE_EQ_PRESET\t \t= GF_4CC( 0xA9, 'e', 'q', 'u' ),\n\tGF_ISOM_ITUNE_LINER_NOTES \t= GF_4CC( 0xA9, 'l', 'n', 't' ),\n\tGF_ISOM_ITUNE_REC_COMPANY \t= GF_4CC( 0xA9, 'm', 'a', 'k' ),\n\tGF_ISOM_ITUNE_ORIG_ARTIST \t= GF_4CC( 0xA9, 'o', 'p', 'e' ),\n\tGF_ISOM_ITUNE_PHONO_RIGHTS \t= GF_4CC( 0xA9, 'p', 'h', 'g' ),\n\tGF_ISOM_ITUNE_PRODUCER\t \t= GF_4CC( 0xA9, 'p', 'r', 'd' ),\n\tGF_ISOM_ITUNE_PERFORMER\t \t= GF_4CC( 0xA9, 'p', 'r', 'f' ),\n\tGF_ISOM_ITUNE_PUBLISHER\t \t= GF_4CC( 0xA9, 'p', 'u', 'b' ),\n\tGF_ISOM_ITUNE_SOUND_ENG\t \t= GF_4CC( 0xA9, 's', 'n', 'e' ),\n\tGF_ISOM_ITUNE_SOLOIST\t \t= GF_4CC( 0xA9, 's', 'o', 'l' ),\n\tGF_ISOM_ITUNE_CREDITS\t \t= GF_4CC( 0xA9, 's', 'r', 'c' ),\n\tGF_ISOM_ITUNE_THANKS\t \t= GF_4CC( 0xA9, 't', 'h', 'x' ),\n\tGF_ISOM_ITUNE_ONLINE\t \t= GF_4CC( 0xA9, 'u', 'r', 'l' ),\n\tGF_ISOM_ITUNE_EXEC_PRODUCER\t= GF_4CC( 0xA9, 'x', 'p', 'd' ),\n\tGF_ISOM_ITUNE_LOCATION\t \t= GF_4CC( 0xA9, 'x', 'y', 'z' ),\n\n\n\tGF_ISOM_ITUNE_ITUNES_DATA \t= GF_4CC( '-', '-', '-', '-' ),\n\n\t/* not mapped:\nPurchase Account \tapID \tUTF-8 string \t\tiTunesAccount (read only)\nAccount Type \takID \t8-bit integer \tIdentifies the iTunes Store account type \tiTunesAccountType (read only)\n\tcnID \t32-bit integer \tiTunes Catalog ID, used for combing SD and HD encodes in iTunes \tcnID\nCountry Code \tsfID \t32-bit integer \tIdentifies in which iTunes Store a file was bought \tiTunesCountry (read only)\n\tatID \t32-bit integer \tUse? \tatID\n\tplID \t64-bit integer \tUse?\n\tgeID \t32-bit integer \tUse? \tgeID\n\t\u00a9st3 \tUTF-8 string \tUse?\n\t*/\n\n} GF_ISOiTunesTag;\n\n#ifndef GPAC_DISABLE_ISOM\n\n/*! gets the given itunes tag info.\n\\warning 'genre' may be coded by ID, the libisomedia doesn't translate the ID. In such a case, the result data is set to NULL and the data_len to the genre ID\n\n\\param isom_file the target ISO file\n\\param tag the tag to query\n\\param data set to the tag data pointer - do not modify\n\\param data_len set to the size of the tag data\n\\return error if any (GF_URL_ERROR if no tag is present in the file)\n*/\nGF_Err gf_isom_apple_get_tag(GF_ISOFile *isom_file, GF_ISOiTunesTag tag, const u8 **data, u32 *data_len);\n\n/*! enumerate itunes tags.\n\n\\param isom_file the target ISO file\n\\param idx 0-based index of the tag to get\n\\param out_tag set to the tag code\n\\param data set to the tag data pointer - do not modify\n\\param data_len set to the size of the tag data. Data is set to NULL and data_size to 1 if the associated tag has no data\n\\param out_int_val set to the int/bool/frac numerator type for known tags, in which case data is set to NULL\n\\param out_int_val2 set to the frac denominator for known tags, in which case data is set to NULL\n\\param out_flags set to the flags value of the data container box\n\\return error if any (GF_URL_ERROR if no more tags)\n*/\nGF_Err gf_isom_apple_enum_tag(GF_ISOFile *isom_file, u32 idx, GF_ISOiTunesTag *out_tag, const u8 **data, u32 *data_len, u64 *out_int_val, u32 *out_int_val2, u32 *out_flags);\n\n\n/*! enumerate WMA tags.\n\n\\param isom_file the target ISO file\n\\param idx 0-based index of the tag to get\n\\param out_tag set to the tag name\n\\param data set to the tag data pointer - do not modify\n\\param data_len set to the size of the tag data\n\\param version  set to the WMA tag version\n\\param data_type set to the WMA data type\n\\return error if any (GF_URL_ERROR if no more tags)\n*/\nGF_Err gf_isom_wma_enum_tag(GF_ISOFile *isom_file, u32 idx, char **out_tag, const u8 **data, u32 *data_len, u32 *version, u32 *data_type);\n\n/*! QT key types */\ntypedef enum\n{\n\tGF_QT_KEY_OPAQUE=0,\n\tGF_QT_KEY_UTF8=1,\n\tGF_QT_KEY_UTF16_BE=2,\n\tGF_QT_KEY_JIS=3,\n\tGF_QT_KEY_UTF8_SORT=4,\n\tGF_QT_KEY_UTF16_SORT=5,\n\tGF_QT_KEY_JPEG=13,\n\tGF_QT_KEY_PNG=14,\n\tGF_QT_KEY_SIGNED_VSIZE=21,\n\tGF_QT_KEY_UNSIGNED_VSIZE=22,\n\tGF_QT_KEY_FLOAT=23,\n\tGF_QT_KEY_DOUBLE=24,\n\tGF_QT_KEY_BMP=27,\n\tGF_QT_KEY_METABOX=28,\n\tGF_QT_KEY_SIGNED_8=65,\n\tGF_QT_KEY_SIGNED_16=66,\n\tGF_QT_KEY_SIGNED_32=67,\n\tGF_QT_KEY_POINTF=70,\n\tGF_QT_KEY_SIZEF=71,\n\tGF_QT_KEY_RECTF=72,\n\tGF_QT_KEY_SIGNED_64=74,\n\tGF_QT_KEY_UNSIGNED_8=75,\n\tGF_QT_KEY_UNSIGNED_16=76,\n\tGF_QT_KEY_UNSIGNED_32=77,\n\tGF_QT_KEY_UNSIGNED_64=78,\n\tGF_QT_KEY_MATRIXF=79,\n\n\t//used to remove a key\n\tGF_QT_KEY_REMOVE=0xFFFFFFFF\n} GF_QTKeyType;\n\n\n/*! QT userdata key*/\ntypedef struct\n{\n\t/*! key name*/\n\tconst char *name;\n\t/*! key namespace 4CC*/\n\tu32 ns;\n\n\t/*! key type*/\n\tGF_QTKeyType type;\n\tunion {\n\t\t/*! UTF-8 string, for GF_QT_KEY_UTF8 and GF_QT_KEY_UTF8_SORT */\n\t\tconst char *string;\n\t\t/*! data, for unsupported types, image types, UTF16 types and metabox */\n\t\tstruct _tag_data {\n\t\t\t/*! data */\n\t\t\tconst u8 *data;\n\t\t\t/*! size */\n\t\t\tu32 data_len;\n\t\t} data;\n\t\t/*! unsigned integer value*/\n\t\tu64 uint;\n\t\t/*! signed integer value*/\n\t\ts64 sint;\n\t\t/*! number value for GF_QT_KEY_FLOAT and GF_QT_KEY_DOUBLE*/\n\t\tDouble number;\n\t\t/*! 2D float value, for GF_QT_KEY_POINTF and GF_QT_KEY_SIZEFF*/\n\t\tstruct _tag_vec2 {\n\t\t\t/*! x-coord*/\n\t\t\tFloat x;\n\t\t\t/*! y-coord*/\n\t\t\tFloat y;\n\t\t} pos_size;\n\t\t/*! 4D value, for GF_QT_KEY_RECTF*/\n\t\tstruct _tag_rec {\n\t\t\t/*! x-coord*/\n\t\t\tFloat x;\n\t\t\t/*! y-coord*/\n\t\t\tFloat y;\n\t\t\t/*! width*/\n\t\t\tFloat w;\n\t\t\t/*! height*/\n\t\t\tFloat h;\n\t\t} rect;\n\t\t/*! 2x3 matrix */\n\t\tDouble matrix[9];\n\t} value;\n} GF_QT_UDTAKey;\n\n/*! enumerate QT keys tags.\n\n\\param isom_file the target ISO file\n\\param idx 0-based index of the tag to get\n\\param out_key key to be filled with key at given index\n\\return error if any (GF_URL_ERROR if no more tags)\n*/\nGF_Err gf_isom_enum_udta_keys(GF_ISOFile *isom_file, u32 idx, GF_QT_UDTAKey *out_key);\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n/*! sets the given tag info.\n\n\\param isom_file the target ISO file\n\\param tag the tag to set\n\\param data tag data buffer or string to parse\n\\param data_len size of the tag data buffer. If data is NULL and and data_len not  0, removes the given tag\n\\param int_val value for integer/boolean tags. If data and data_len are set, parse data as string  to get the value\n\\param int_val2 value for fractional  tags. If data and data_len are set, parse data as string to get the value\n\\return error if any\n*/\nGF_Err gf_isom_apple_set_tag(GF_ISOFile *isom_file, GF_ISOiTunesTag tag, const u8 *data, u32 data_len, u64 int_val, u32 int_val2);\n\n\n/*! sets the given WMA tag info (only string tags are supported).\n\n\\param isom_file the target ISO file\n\\param name name of the tag to set\n\\param value string value to set\n\\return error if any\n*/\nGF_Err gf_isom_wma_set_tag(GF_ISOFile *isom_file, char *name, char *value);\n\n/*! sets key (QT style metadata)\n\\param isom_file the target ISO file\n\\param key the key to use. if NULL, removes ALL keys\n\\return error if any\n*/\nGF_Err gf_isom_set_qt_key(GF_ISOFile *isom_file, GF_QT_UDTAKey *key);\n\n/*! sets compatibility tag on AVC tracks (needed by iPod to play files... hurray for standards)\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return error if any\n*/\nGF_Err gf_isom_set_ipod_compatible(GF_ISOFile *isom_file, u32 trackNumber);\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n/*! @} */\n\n/*!\n\\addtogroup isogrp_grp Track Groups\n\\ingroup iso_grp\n\n@{\n*/\n\n/*! gets the number of switching groups declared in this track if any\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param alternateGroupID alternate group id of track if speciifed, 0 otherwise\n\\param nb_groups set to number of switching groups defined for this track\n\\return error if any\n*/\nGF_Err gf_isom_get_track_switch_group_count(GF_ISOFile *isom_file, u32 trackNumber, u32 *alternateGroupID, u32 *nb_groups);\n\n/*! get the list of criteria (expressed as 4CC IDs, cf 3GPP TS 26.244)\n\\param isom_file the target ISO file\n\\param trackNumber the track number\n\\param group_index the 1-based index of the group to inspect\n\\param switchGroupID set to the ID of the switch group if any, 0 otherwise (alternate-only group)\n\\param criteriaListSize set to the number of criteria items in returned list\n\\return list of criteria (four character codes, cf 3GPP TS 26.244) for the switch group\n*/\nconst u32 *gf_isom_get_track_switch_parameter(GF_ISOFile *isom_file, u32 trackNumber, u32 group_index, u32 *switchGroupID, u32 *criteriaListSize);\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n/*! sets a new (switch) group for this track\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param trackRefGroup number of a track belonging to the same alternate group. If 0, a new alternate group will be created for this track\n\\param is_switch_group if set, indicates that a switch group identifier shall be assigned to the created group. Otherwise, the criteria list is associated with the entire alternate group\n\\param switchGroupID set to the ID of the switch group. On input, specifies the desired switchGroupID to use; if value is 0, next available switchGroupID in file is used. On output, is set to the switchGroupID used.\n\\param criteriaList list of four character codes used as criteria - cf 3GPP TS 26.244\n\\param criteriaListCount number of criterias in list\n\\return error if any\n*/\nGF_Err gf_isom_set_track_switch_parameter(GF_ISOFile *isom_file, u32 trackNumber, u32 trackRefGroup, Bool is_switch_group, u32 *switchGroupID, u32 *criteriaList, u32 criteriaListCount);\n\n/*! resets track switch group information\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param reset_all_group if GF_TRUE, resets the entire alternate group this track belongs to; otherwise, resets switch group for the track only\n\\return error if any\n*/\nGF_Err gf_isom_reset_track_switch_parameter(GF_ISOFile *isom_file, u32 trackNumber, Bool reset_all_group);\n\n/*! resets all track switch group information in the entire movie\n\\param isom_file the target ISO file\n\\return error if any\n*/\nGF_Err gf_isom_reset_switch_parameters(GF_ISOFile *isom_file);\n\n/*! sets track in group of a given type and ID\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param track_group_id ID of the track group\n\\param group_type four character code of the track group\n\\param do_add if GF_FALSE, track is removed from that group, otherwise it is added\n\\return error if any\n*/\nGF_Err gf_isom_set_track_group(GF_ISOFile *isom_file, u32 trackNumber, u32 track_group_id, u32 group_type, Bool do_add);\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n/*! @} */\n\n/*!\n\\addtogroup isosubs_grp Subsamples\n\\ingroup iso_grp\n\n@{\n*/\n\n/*! gets serialized subsample info for the sample\nThe buffer is formatted as N times [(u32)flags(u32)sub_size(u32)codec_param(u8)priority(u8) discardable]\nIf several subsample info are present, they are gathered by flags\n\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleNumber the target sample number\n\\param osize set to output buffer size\n\\return the serialized buffer, or NULL oif no associated subsample*/\nu8 *gf_isom_sample_get_subsamples_buffer(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleNumber, u32 *osize);\n\n/*! checks if a sample has subsample information\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleNumber the target sample number. Set to 0 to check for presence of subsample info (will return 1 or 0 in this case)\n\\param flags the subsample flags to query (may be 0)\n\\return the number of subsamples in the given sample for the given flags*/\nu32 gf_isom_sample_has_subsamples(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleNumber, u32 flags);\n\n/*! gets subsample information on a sample\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleNumber the target sample number\n\\param flags the subsample flags to query (may be 0)\n\\param subSampleNumber the 1-based index of the subsample (see \\ref gf_isom_sample_has_subsamples)\n\\param size set to the subsample size\n\\param priority set to the subsample priority\n\\param reserved set to the subsample reserved value (may be used by derived specifications)\n\\param discardable set to GF_TRUE if subsample is discardable\n\\return error if any*/\nGF_Err gf_isom_sample_get_subsample(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleNumber, u32 flags, u32 subSampleNumber, u32 *size, u8 *priority, u32 *reserved, Bool *discardable);\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n/*! adds subsample information to a given sample. Subsample information shall be added in increasing order of sampleNumbers, insertion of information is not supported\n\n\\note it is possible to  add subsample information for samples not yet added to the file\n\\note specifying 0 as subSampleSize will remove the last subsample information if any\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleNumber the target sample number\n\\param flags the subsample flags to query (may be 0)\n\\param subSampleSize size of the subsample. If 0, this will remove the last subsample information if any\n\\param priority the subsample priority\n\\param reserved the subsample reserved value (may be used by derived specifications)\n\\param discardable indicates if the subsample is discardable\n\\return error if any*/\nGF_Err gf_isom_add_subsample(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleNumber, u32 flags, u32 subSampleSize, u8 priority, u32 reserved, Bool discardable);\n\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n/*! adds subsample information for the latest sample added to the current track fragment\n\\param isom_file the target ISO file\n\\param TrackID the ID of the target track\n\\param flags the subsample flags to query (may be 0)\n\\param subSampleSize size of the subsample. If 0, this will remove the last subsample information if any\n\\param priority the subsample priority\n\\param reserved the subsample reserved value (may be used by derived specifications)\n\\param discardable indicates if the subsample is discardable\n\\return error if any*/\nGF_Err gf_isom_fragment_add_subsample(GF_ISOFile *isom_file, GF_ISOTrackID TrackID, u32 flags, u32 subSampleSize, u8 priority, u32 reserved, Bool discardable);\n#endif // GPAC_DISABLE_ISOM_FRAGMENTS\n\n#endif //GPAC_DISABLE_ISOM_WRITE\n\n/*! @} */\n\n/*!\n\\addtogroup isosgdp_grp Sample Groups\n\\ingroup iso_grp\n\n@{\n*/\n\n/*! defined sample groups in GPAC*/\nenum {\n\tGF_ISOM_SAMPLE_GROUP_ROLL = GF_4CC( 'r', 'o', 'l', 'l'),\n\tGF_ISOM_SAMPLE_GROUP_PROL = GF_4CC( 'p', 'r', 'o', 'l'),\n\tGF_ISOM_SAMPLE_GROUP_RAP = GF_4CC( 'r', 'a', 'p', ' ' ),\n\tGF_ISOM_SAMPLE_GROUP_SEIG = GF_4CC( 's', 'e', 'i', 'g' ),\n\tGF_ISOM_SAMPLE_GROUP_OINF = GF_4CC( 'o', 'i', 'n', 'f'),\n\tGF_ISOM_SAMPLE_GROUP_LINF = GF_4CC( 'l', 'i', 'n', 'f'),\n\tGF_ISOM_SAMPLE_GROUP_TRIF = GF_4CC( 't', 'r', 'i', 'f' ),\n\tGF_ISOM_SAMPLE_GROUP_NALM = GF_4CC( 'n', 'a', 'l', 'm'),\n\tGF_ISOM_SAMPLE_GROUP_TELE = GF_4CC( 't', 'e', 'l', 'e'),\n\tGF_ISOM_SAMPLE_GROUP_SAP = GF_4CC( 's', 'a', 'p', ' '),\n\tGF_ISOM_SAMPLE_GROUP_ALST = GF_4CC( 'a', 'l', 's', 't'),\n\tGF_ISOM_SAMPLE_GROUP_RASH = GF_4CC( 'r', 'a', 's', 'h'),\n\tGF_ISOM_SAMPLE_GROUP_AVLL = GF_4CC( 'a', 'v', 'l', 'l'), //p15\n\tGF_ISOM_SAMPLE_GROUP_AVSS = GF_4CC( 'a', 'v', 's', 's'), //p15\n\tGF_ISOM_SAMPLE_GROUP_DTRT = GF_4CC( 'd', 't', 'r', 't'), //p15\n\tGF_ISOM_SAMPLE_GROUP_MVIF = GF_4CC( 'm', 'v', 'i', 'f'), //p15\n\tGF_ISOM_SAMPLE_GROUP_SCIF = GF_4CC( 's', 'c', 'i', 'f'), //p15\n\tGF_ISOM_SAMPLE_GROUP_SCNM = GF_4CC( 's', 'c', 'n', 'm'), //p15\n\tGF_ISOM_SAMPLE_GROUP_STSA = GF_4CC( 's', 't', 's', 'a'), //p15\n\tGF_ISOM_SAMPLE_GROUP_TSAS = GF_4CC( 't', 's', 'a', 's'), //p15\n\tGF_ISOM_SAMPLE_GROUP_SYNC = GF_4CC( 's', 'y', 'n', 'c'), //p15\n\tGF_ISOM_SAMPLE_GROUP_TSCL = GF_4CC( 't', 's', 'c', 'l'), //p15\n\tGF_ISOM_SAMPLE_GROUP_VIPR = GF_4CC( 'v', 'i', 'p', 'r'), //p15\n\tGF_ISOM_SAMPLE_GROUP_LBLI = GF_4CC( 'l', 'b', 'l', 'i'), //p15\n\tGF_ISOM_SAMPLE_GROUP_3GAG = GF_4CC( '3', 'g', 'a', 'g'), //3gpp\n\tGF_ISOM_SAMPLE_GROUP_AVCB = GF_4CC( 'a', 'v', 'c', 'b'), //avif\n\tGF_ISOM_SAMPLE_GROUP_SPOR = GF_4CC( 's', 'p', 'o', 'r'), //p15\n\tGF_ISOM_SAMPLE_GROUP_SULM = GF_4CC( 's', 'u', 'l', 'm'), //p15\n\tGF_ISOM_SAMPLE_GROUP_ESGH = GF_4CC( 'e', 's', 'g', 'h'), //p12\n\tGF_ISOM_SAMPLE_GROUP_ILCE = GF_4CC( 'i', 'l', 'c', 'e'), //uncv\n};\n\n/*! gets 'rap ' and 'roll' group info for the given sample\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleNumber the target sample number\n\\param is_rap set to GF_TRUE if sample is a rap (open gop), GF_FALSE otherwise\n\\param roll_type set to GF_ISOM_SAMPLE_ROLL if sample has roll information, GF_ISOM_SAMPLE_PREROLL if sample has preroll information, GF_ISOM_SAMPLE_ROLL_NONE otherwise\n\\param roll_distance if sample has roll information, set to roll distance\n\\return error if any*/\nGF_Err gf_isom_get_sample_rap_roll_info(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleNumber, Bool *is_rap, GF_ISOSampleRollType *roll_type, s32 *roll_distance);\n\n/*! returns opaque data of sample group\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sample_group_description_index index of sample group description entry to query\n\\param grouping_type four character code of grouping type of sample group description to query\n\\param default_index set to the default index for this sample group description if any, 0 otherwise (no defaults)\n\\param data set to the internal sample group description data buffer\n\\param size set to size of the sample group description data buffer\n\\return GF_TRUE if found, GF_FALSE otherwise*/\nBool gf_isom_get_sample_group_info(GF_ISOFile *isom_file, u32 trackNumber, u32 sample_group_description_index, u32 grouping_type, u32 *default_index, const u8 **data, u32 *size);\n\n/*! gets sample group description index for a given sample and grouping type.\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sample_number sample number to query\n\\param grouping_type four character code of grouping type of sample group description to query\n\\param grouping_type_parameter  grouping type parameter of sample group description to query\n\\param sampleGroupDescIndex set to the 1-based sample group description index, or 0 if no sample group of this type is associated\n\\return error if any\n*/\nGF_Err gf_isom_get_sample_to_group_info(GF_ISOFile *isom_file, u32 trackNumber, u32 sample_number, u32 grouping_type, u32 grouping_type_parameter, u32 *sampleGroupDescIndex);\n\n/*! checks if a track as a CENC seig sample group used for key rolling\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param has_selective set to TRUE if some entries describe unprotected samples - may be NULL\n\\param has_roll set to TRUE if more than one key defined - may be NULL\n\\return GF_TRUE if found, GF_FALSE otherwise*/\nBool gf_isom_has_cenc_sample_group(GF_ISOFile *isom_file, u32 trackNumber, Bool *has_selective, Bool *has_roll);\n\n/*! gets HEVC tiling info\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sample_group_description_index index of sample group description entry to query\n\\param default_sample_group_index set to the default index for this sample group description if any, 0 otherwise (no defaults)\n\\param id set to the tile group ID\n\\param independent set to independent flag of the tile group (0: not constrained, 1: constrained in layer, 2: all intra slices)\n\\param full_frame set to GF_TRUE if the tile corresponds to the entire picture\n\\param x set to the horizontal position in pixels\n\\param y set to the vertical position in pixels\n\\param w set to the width in pixels\n\\param h set to the height in pixels\n\\return GF_TRUE if found, GF_FALSE otherwise*/\nBool gf_isom_get_tile_info(GF_ISOFile *isom_file, u32 trackNumber, u32 sample_group_description_index, u32 *default_sample_group_index, u32 *id, u32 *independent, Bool *full_frame, u32 *x, u32 *y, u32 *w, u32 *h);\n\n\n/*! enumerates custom sample groups (not natively supported by this library) for a given sample\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sample_number the target sample\n\\param sgrp_idx the current index. Must be set to 0 on first call, incremented by this call on each success, must not be NULL\n\\param sgrp_type set to the grouping type, or set to 0 if no more sample group descriptions, must not be NULL\n\\param sgrp_flags set to the grouping flags, (0x1: static_group_description, 0x2: static_mapping)\n\\param sgrp_parameter set to the grouping_type_parameter or 0 if not defined\n\\param sgrp_data set to the sample group description data, may be NULL - MUST be freed by caller\n\\param sgrp_size set to the sample group description size, may be NULL\n\\return error if any\n*/\nGF_Err gf_isom_enum_sample_group(GF_ISOFile *isom_file, u32 trackNumber, u32 sample_number, u32 *sgrp_idx, u32 *sgrp_type, u32 *sgrp_flags, u32 *sgrp_parameter, u8 **sgrp_data, u32 *sgrp_size);\n\n/*! enumerates custom sample auxiliary data (not natively supported by this library) for a given sample\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sample_number the target sample\n\\param sai_idx the current index. Must be et to 0 on first call, incremented by this call on each success, must not be NULL\n\\param sai_type set to the grouping type, or set to 0 if no more sample group descriptions, must not be NULL\n\\param sai_parameter set to the grouping_type_parameter or 0 if not defined\n\\param sai_data set (allocated) to the sample group description data, must not be NULL and must be freed by caller\n\\param sai_size set to the sample group description size, must not be NULL\n\\return error if any\n*/\nGF_Err gf_isom_enum_sample_aux_data(GF_ISOFile *isom_file, u32 trackNumber, u32 sample_number, u32 *sai_idx, u32 *sai_type, u32 *sai_parameter, u8 **sai_data, u32 *sai_size);\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n/*! sets rap flag for sample_number - this is used by non-IDR RAPs in AVC (also in USAC) were SYNC flag (stss table) cannot be used\n\\warning Sample group info MUST be added in order (no insertion in the tables)\n\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleNumber the target sample number\n\\param is_rap indicates if the sample is a RAP (open gop) sample\n\\param num_leading_samples indicates the number of leading samples (samples after this RAP that have dependences on samples before this RAP and hence should be discarded when tuning in)\n\\return error if any\n*/\nGF_Err gf_isom_set_sample_rap_group(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleNumber, Bool is_rap, u32 num_leading_samples);\n\n/*! sets roll_distance info for sample_number (number of frames before (<0) or after (>0) this sample to have a complete refresh of the decoded data (used by GDR in AVC)\n\n\\warning Sample group info MUST be added in order (no insertion in the tables)\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleNumber the target sample number. If 0, assumes last added sample. If 0xFFFFFFFF, marks all samples as belonging to the roll group\n\\param roll_type indicates  the sample roll recovery type\n\\param roll_distance indicates the roll distance before a correct decoding is produced\n\\return error if any\n*/\nGF_Err gf_isom_set_sample_roll_group(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleNumber, GF_ISOSampleRollType roll_type, s16 roll_distance);\n\n/*! sets encryption group for a sample number\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleNumber the target sample number\n\\param isEncrypted isEncrypted flag\n\\param crypt_byte_block crypt block size for pattern encryption, can be 0\n\\param skip_byte_block skip block size for pattern encryption, can be 0\n\\param key_info multikey descriptor (cf CENC and GF_PROP_PID_CENC_KEY)\n\\param key_info_size multikey descriptor size\n\\return error if any\n*/\nGF_Err gf_isom_set_sample_cenc_group(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleNumber, u8 isEncrypted, u8 crypt_byte_block, u8 skip_byte_block, u8 *key_info, u32 key_info_size);\n\n\n/*! sets a sample using the default CENC parameters in a CENC saig sample group SEIG, creating a sample group description if needed (when seig is already defined)\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleNumber the target sample number\n\\return error if any\n*/\nGF_Err gf_isom_set_sample_cenc_default_group(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleNumber);\n\n/*! adds the given blob as a sample group description entry of the given grouping type.\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param grouping_type the four character code of the grouping type\n\\param data the payload of the sample group description\n\\param data_size the size of the payload\n\\param is_default if GF_TRUE, thie created entry will be marked as the default entry for the sample group description\n\\param sampleGroupDescriptionIndex is set to the sample group description index (optional, can be NULL)\n\\return error if any\n*/\nGF_Err gf_isom_add_sample_group_info(GF_ISOFile *isom_file, u32 trackNumber, u32 grouping_type, void *data, u32 data_size, Bool is_default, u32 *sampleGroupDescriptionIndex);\n\n/*! removes a sample group description of the give grouping type, if found\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param grouping_type the four character code of the grouping type\n\\return error if any\n*/\nGF_Err gf_isom_remove_sample_group(GF_ISOFile *isom_file, u32 trackNumber, u32 grouping_type);\n\n/*! adds the given blob as a sample group description entry of the given grouping type for the given sample.\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleNumber the target sample number.Use 0 for setting sample group info to last sample in a track fragment\n\\param grouping_type the four character code of the grouping type\n\\param grouping_type_parameter associated grouping type parameter (usually 0)\n\\param data the payload of the sample group description\n\\param data_size the size of the payload\n\\param sgpd_flags flags for sgpd: 1: static description, 2, static mapping, 1<<30: essential sample group, 1<<31: default sample description\n\\return error if any\n*/\nGF_Err gf_isom_set_sample_group_description(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleNumber, u32 grouping_type, u32 grouping_type_parameter, void *data, u32 data_size, u32 sgpd_flags);\n\n\n/*! adds a sample to the given sample group\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleNumber the target sample number\n\\param grouping_type the four character code of the grouping type\n\\param sampleGroupDescriptionIndex the 1-based index of the sample group description entry\n\\param grouping_type_parameter the grouping type paramter (see ISO/IEC 14496-12)\n\\return error if any\n*/\nGF_Err gf_isom_add_sample_info(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleNumber, u32 grouping_type, u32 sampleGroupDescriptionIndex, u32 grouping_type_parameter);\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n/*! sets sample group descriptions storage in trafs and not in initial movie (Smooth compatibility)\n\\param isom_file the target ISO file\n\\return error if any*/\nGF_Err gf_isom_set_sample_group_in_traf(GF_ISOFile *isom_file);\n#endif\n\n#endif // GPAC_DISABLE_ISOM_WRITE\n\n\n/*! @} */\n\n#endif /*GPAC_DISABLE_ISOM*/\n\n#ifdef __cplusplus\n}\n#endif\n\n\n#endif\t/*_GF_ISOMEDIA_H_*/\n\n\n", "/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2023\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISO Media File Format sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/internal/isomedia_dev.h>\n\n\n\n#ifndef GPAC_DISABLE_ISOM\n\nvoid co64_box_del(GF_Box *s)\n{\n\tGF_ChunkLargeOffsetBox *ptr;\n\tptr = (GF_ChunkLargeOffsetBox *) s;\n\tif (ptr == NULL) return;\n\tif (ptr->offsets) gf_free(ptr->offsets);\n\tgf_free(ptr);\n}\n\nGF_Err co64_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tu32 entries;\n\tGF_ChunkLargeOffsetBox *ptr = (GF_ChunkLargeOffsetBox *) s;\n\tptr->nb_entries = gf_bs_read_u32(bs);\n\n\tISOM_DECREASE_SIZE(ptr, 4)\n\n\tif ((u64)ptr->nb_entries > ptr->size / 8 || (u64)ptr->nb_entries > (u64)SIZE_MAX/sizeof(u64)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in co64\\n\", ptr->nb_entries));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tptr->offsets = (u64 *) gf_malloc(ptr->nb_entries * sizeof(u64) );\n\tif (ptr->offsets == NULL) return GF_OUT_OF_MEM;\n\tptr->alloc_size = ptr->nb_entries;\n\tfor (entries = 0; entries < ptr->nb_entries; entries++) {\n\t\tptr->offsets[entries] = gf_bs_read_u64(bs);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *co64_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ChunkLargeOffsetBox, GF_ISOM_BOX_TYPE_CO64);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err co64_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_ChunkLargeOffsetBox *ptr = (GF_ChunkLargeOffsetBox *) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->nb_entries);\n\tfor (i = 0; i < ptr->nb_entries; i++ ) {\n\t\tgf_bs_write_u64(bs, ptr->offsets[i]);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err co64_box_size(GF_Box *s)\n{\n\tGF_ChunkLargeOffsetBox *ptr = (GF_ChunkLargeOffsetBox *) s;\n\n\tptr->size += 4 + (8 * ptr->nb_entries);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid cprt_box_del(GF_Box *s)\n{\n\tGF_CopyrightBox *ptr = (GF_CopyrightBox *) s;\n\tif (ptr == NULL) return;\n\tif (ptr->notice)\n\t\tgf_free(ptr->notice);\n\tgf_free(ptr);\n}\n\n\nGF_Box *chpl_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ChapterListBox, GF_ISOM_BOX_TYPE_CHPL);\n\ttmp->list = gf_list_new();\n\ttmp->version = 1;\n\treturn (GF_Box *)tmp;\n}\n\nvoid chpl_box_del(GF_Box *s)\n{\n\tGF_ChapterListBox *ptr = (GF_ChapterListBox *) s;\n\tif (ptr == NULL) return;\n\twhile (gf_list_count(ptr->list)) {\n\t\tGF_ChapterEntry *ce = (GF_ChapterEntry *)gf_list_get(ptr->list, 0);\n\t\tif (ce->name) gf_free(ce->name);\n\t\tgf_free(ce);\n\t\tgf_list_rem(ptr->list, 0);\n\t}\n\tgf_list_del(ptr->list);\n\tgf_free(ptr);\n}\n\n/*this is using chpl format according to some NeroRecode samples*/\nGF_Err chpl_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_ChapterEntry *ce;\n\tu32 nb_chaps, len, i, count;\n\tGF_ChapterListBox *ptr = (GF_ChapterListBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 5)\n\t/*reserved or ???*/\n\tgf_bs_read_u32(bs);\n\tnb_chaps = gf_bs_read_u8(bs);\n\n\tcount = 0;\n\twhile (nb_chaps) {\n\t\tGF_SAFEALLOC(ce, GF_ChapterEntry);\n\t\tif (!ce) return GF_OUT_OF_MEM;\n\t\tISOM_DECREASE_SIZE(ptr, 9)\n\t\tce->start_time = gf_bs_read_u64(bs);\n\t\tlen = gf_bs_read_u8(bs);\n\t\tif (ptr->size<len) return GF_ISOM_INVALID_FILE;\n\t\tif (len) {\n\t\t\tce->name = (char *)gf_malloc(sizeof(char)*(len+1));\n\t\t\tif (!ce->name) return GF_OUT_OF_MEM;\n\t\t\tISOM_DECREASE_SIZE(ptr, len)\n\t\t\tgf_bs_read_data(bs, ce->name, len);\n\t\t\tce->name[len] = 0;\n\t\t} else {\n\t\t\tce->name = gf_strdup(\"\");\n\t\t}\n\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_ChapterEntry *ace = (GF_ChapterEntry *) gf_list_get(ptr->list, i);\n\t\t\tif (ace->start_time >= ce->start_time) {\n\t\t\t\tgf_list_insert(ptr->list, ce, i);\n\t\t\t\tce = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ce) gf_list_add(ptr->list, ce);\n\t\tcount++;\n\t\tnb_chaps--;\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err chpl_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 count, i;\n\tGF_ChapterListBox *ptr = (GF_ChapterListBox *) s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tcount = gf_list_count(ptr->list);\n\tgf_bs_write_u32(bs, 0);\n\tgf_bs_write_u8(bs, count);\n\tfor (i=0; i<count; i++) {\n\t\tu32 len;\n\t\tGF_ChapterEntry *ce = (GF_ChapterEntry *)gf_list_get(ptr->list, i);\n\t\tgf_bs_write_u64(bs, ce->start_time);\n\t\tif (ce->name) {\n\t\t\tlen = (u32) strlen(ce->name);\n\t\t\tif (len>255) len = 255;\n\t\t\tgf_bs_write_u8(bs, len);\n\t\t\tgf_bs_write_data(bs, ce->name, len);\n\t\t} else {\n\t\t\tgf_bs_write_u8(bs, 0);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err chpl_box_size(GF_Box *s)\n{\n\tu32 count, i;\n\tGF_ChapterListBox *ptr = (GF_ChapterListBox *)s;\n\n\tptr->size += 5;\n\n\tcount = gf_list_count(ptr->list);\n\tfor (i=0; i<count; i++) {\n\t\tGF_ChapterEntry *ce = (GF_ChapterEntry *)gf_list_get(ptr->list, i);\n\t\tptr->size += 9; /*64bit time stamp + 8bit str len*/\n\t\tif (ce->name) ptr->size += strlen(ce->name);\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Err cprt_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_CopyrightBox *ptr = (GF_CopyrightBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 2);\n\tgf_bs_read_int(bs, 1);\n\t//the spec is unclear here, just says \"the value 0 is interpreted as undetermined\"\n\tptr->packedLanguageCode[0] = gf_bs_read_int(bs, 5);\n\tptr->packedLanguageCode[1] = gf_bs_read_int(bs, 5);\n\tptr->packedLanguageCode[2] = gf_bs_read_int(bs, 5);\n\n\t//but before or after compaction ?? We assume before\n\tif (ptr->packedLanguageCode[0] || ptr->packedLanguageCode[1] || ptr->packedLanguageCode[2]) {\n\t\tptr->packedLanguageCode[0] += 0x60;\n\t\tptr->packedLanguageCode[1] += 0x60;\n\t\tptr->packedLanguageCode[2] += 0x60;\n\t} else {\n\t\tptr->packedLanguageCode[0] = 'u';\n\t\tptr->packedLanguageCode[1] = 'n';\n\t\tptr->packedLanguageCode[2] = 'd';\n\t}\n\tif (ptr->size) {\n\t\tu32 bytesToRead = (u32) ptr->size;\n\t\tptr->notice = (char*)gf_malloc((bytesToRead+1) * sizeof(char));\n\t\tif (ptr->notice == NULL) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->notice, bytesToRead);\n\t\tptr->notice[bytesToRead] = 0;\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *cprt_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_CopyrightBox, GF_ISOM_BOX_TYPE_CPRT);\n\ttmp->packedLanguageCode[0] = 'u';\n\ttmp->packedLanguageCode[1] = 'n';\n\ttmp->packedLanguageCode[2] = 'd';\n\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err cprt_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_CopyrightBox *ptr = (GF_CopyrightBox *) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_int(bs, 0, 1);\n\tif (ptr->packedLanguageCode[0]) {\n\t\tgf_bs_write_int(bs, ptr->packedLanguageCode[0] - 0x60, 5);\n\t\tgf_bs_write_int(bs, ptr->packedLanguageCode[1] - 0x60, 5);\n\t\tgf_bs_write_int(bs, ptr->packedLanguageCode[2] - 0x60, 5);\n\t} else {\n\t\tgf_bs_write_int(bs, 0, 15);\n\t}\n\tif (ptr->notice) {\n\t\tgf_bs_write_data(bs, ptr->notice, (u32) (strlen(ptr->notice) + 1) );\n\t}\n\treturn GF_OK;\n}\n\nGF_Err cprt_box_size(GF_Box *s)\n{\n\tGF_CopyrightBox *ptr = (GF_CopyrightBox *)s;\n\n\tptr->size += 2;\n\tif (ptr->notice)\n\t\tptr->size += strlen(ptr->notice) + 1;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid kind_box_del(GF_Box *s)\n{\n\tGF_KindBox *ptr = (GF_KindBox *) s;\n\tif (ptr == NULL) return;\n\tif (ptr->schemeURI) gf_free(ptr->schemeURI);\n\tif (ptr->value) gf_free(ptr->value);\n\tgf_free(ptr);\n}\n\nGF_Err kind_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_KindBox *ptr = (GF_KindBox *)s;\n\n\tif (ptr->size) {\n\t\tu32 bytesToRead = (u32) ptr->size;\n\t\tchar *data;\n\t\tu32 schemeURIlen;\n\t\tdata = (char*)gf_malloc(bytesToRead * sizeof(char));\n\t\tif (!data) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, data, bytesToRead);\n\t\t/*safety check in case the string is not null-terminated*/\n\t\tif (data[bytesToRead-1]) {\n\t\t\tdata = (char*)gf_realloc(data, sizeof(char)*(bytesToRead + 1));\n\t\t\tif (!data) return GF_OUT_OF_MEM;\n\t\t\tdata[bytesToRead] = 0;\n\t\t\tbytesToRead++;\n\t\t}\n\t\tptr->schemeURI = gf_strdup(data);\n\t\tif (!ptr->schemeURI) return GF_OUT_OF_MEM;\n\t\tschemeURIlen = (u32) strlen(data);\n\t\tif (bytesToRead > schemeURIlen+1) {\n\t\t\t/* read the value */\n\t\t\tchar *data_value = data + schemeURIlen +1;\n\t\t\tptr->value = gf_strdup(data_value);\n\t\t\tif (!ptr->value) return GF_OUT_OF_MEM;\n\t\t}\n\t\tgf_free(data);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *kind_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_KindBox, GF_ISOM_BOX_TYPE_KIND);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err kind_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_KindBox *ptr = (GF_KindBox *) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n    if (ptr->schemeURI)\n        gf_bs_write_data(bs, ptr->schemeURI, (u32) (strlen(ptr->schemeURI) + 1 ));\n    else\n        gf_bs_write_u8(bs, 0);\n\n    if (ptr->value) {\n\t\tgf_bs_write_data(bs, ptr->value, (u32) (strlen(ptr->value) + 1) );\n\t}\n\treturn GF_OK;\n}\n\nGF_Err kind_box_size(GF_Box *s)\n{\n\tGF_KindBox *ptr = (GF_KindBox *)s;\n\n    ptr->size += (ptr->schemeURI ? strlen(ptr->schemeURI) : 0) + 1;\n\tif (ptr->value) {\n\t\tptr->size += strlen(ptr->value) + 1;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid ctts_box_del(GF_Box *s)\n{\n\tGF_CompositionOffsetBox *ptr = (GF_CompositionOffsetBox *)s;\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);\n}\n\n\n\nGF_Err ctts_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tu32 sampleCount;\n\tGF_CompositionOffsetBox *ptr = (GF_CompositionOffsetBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->nb_entries = gf_bs_read_u32(bs);\n\n\tif (ptr->nb_entries > ptr->size / 8 || (u64)ptr->nb_entries > (u64)SIZE_MAX/sizeof(GF_DttsEntry) ) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in ctts\\n\", ptr->nb_entries));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tptr->alloc_size = ptr->nb_entries;\n\tptr->entries = (GF_DttsEntry *)gf_malloc(sizeof(GF_DttsEntry)*ptr->alloc_size);\n\tif (!ptr->entries) return GF_OUT_OF_MEM;\n\tsampleCount = 0;\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\tptr->entries[i].sampleCount = gf_bs_read_u32(bs);\n\t\tif (ptr->version)\n\t\t\tptr->entries[i].decodingOffset = gf_bs_read_int(bs, 32);\n\t\telse\n\t\t\tptr->entries[i].decodingOffset = (s32) gf_bs_read_u32(bs);\n\n\t\tif (ptr->max_cts_delta <= ABS(ptr->entries[i].decodingOffset)) {\n\t\t\tptr->max_cts_delta = ABS(ptr->entries[i].decodingOffset);\n\t\t\t//ptr->sample_num_max_cts_delta = sampleCount;\n\t\t}\n\t\tsampleCount += ptr->entries[i].sampleCount;\n\t}\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tptr->w_LastSampleNumber = sampleCount;\n#endif\n\treturn GF_OK;\n}\n\nGF_Box *ctts_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_CompositionOffsetBox, GF_ISOM_BOX_TYPE_CTTS);\n\treturn (GF_Box *) tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err ctts_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_CompositionOffsetBox *ptr = (GF_CompositionOffsetBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->nb_entries);\n\tfor (i=0; i<ptr->nb_entries; i++ ) {\n\t\tgf_bs_write_u32(bs, ptr->entries[i].sampleCount);\n\t\tif (ptr->version) {\n\t\t\tgf_bs_write_int(bs, ptr->entries[i].decodingOffset, 32);\n\t\t} else {\n\t\t\tgf_bs_write_u32(bs, (u32) ptr->entries[i].decodingOffset);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err ctts_box_size(GF_Box *s)\n{\n\tGF_CompositionOffsetBox *ptr = (GF_CompositionOffsetBox *) s;\n\n\tptr->size += 4 + (8 * ptr->nb_entries);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid cslg_box_del(GF_Box *s)\n{\n\tGF_CompositionToDecodeBox *ptr = (GF_CompositionToDecodeBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n\treturn;\n}\n\nGF_Err cslg_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_CompositionToDecodeBox *ptr = (GF_CompositionToDecodeBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 20);\n\tptr->compositionToDTSShift = gf_bs_read_int(bs, 32);\n\tptr->leastDecodeToDisplayDelta = gf_bs_read_int(bs, 32);\n\tptr->greatestDecodeToDisplayDelta = gf_bs_read_int(bs, 32);\n\tptr->compositionStartTime = gf_bs_read_int(bs, 32);\n\tptr->compositionEndTime = gf_bs_read_int(bs, 32);\n\treturn GF_OK;\n}\n\nGF_Box *cslg_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_CompositionToDecodeBox, GF_ISOM_BOX_TYPE_CSLG);\n\treturn (GF_Box *) tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err cslg_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_CompositionToDecodeBox *ptr = (GF_CompositionToDecodeBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_int(bs, ptr->compositionToDTSShift, 32);\n\tgf_bs_write_int(bs, ptr->leastDecodeToDisplayDelta, 32);\n\tgf_bs_write_int(bs, ptr->greatestDecodeToDisplayDelta, 32);\n\tgf_bs_write_int(bs, ptr->compositionStartTime, 32);\n\tgf_bs_write_int(bs, ptr->compositionEndTime, 32);\n\treturn GF_OK;\n}\n\nGF_Err cslg_box_size(GF_Box *s)\n{\n\tGF_CompositionToDecodeBox *ptr = (GF_CompositionToDecodeBox *)s;\n\n\tptr->size += 20;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid ccst_box_del(GF_Box *s)\n{\n\tGF_CodingConstraintsBox *ptr = (GF_CodingConstraintsBox *)s;\n\tif (ptr) gf_free(ptr);\n\treturn;\n}\n\nGF_Err ccst_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_CodingConstraintsBox *ptr = (GF_CodingConstraintsBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->all_ref_pics_intra = gf_bs_read_int(bs, 1);\n\tptr->intra_pred_used = gf_bs_read_int(bs, 1);\n\tptr->max_ref_per_pic = gf_bs_read_int(bs, 4);\n\tptr->reserved = gf_bs_read_int(bs, 26);\n\treturn GF_OK;\n}\n\nGF_Box *ccst_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_CodingConstraintsBox, GF_ISOM_BOX_TYPE_CCST);\n\treturn (GF_Box *) tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err ccst_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_CodingConstraintsBox *ptr = (GF_CodingConstraintsBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_int(bs, ptr->all_ref_pics_intra, 1);\n\tgf_bs_write_int(bs, ptr->intra_pred_used, 1);\n\tgf_bs_write_int(bs, ptr->max_ref_per_pic, 4);\n\tgf_bs_write_int(bs, 0, 26);\n\treturn GF_OK;\n}\n\nGF_Err ccst_box_size(GF_Box *s)\n{\n\tGF_CodingConstraintsBox *ptr = (GF_CodingConstraintsBox *)s;\n\tptr->size += 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid url_box_del(GF_Box *s)\n{\n\tGF_DataEntryURLBox *ptr = (GF_DataEntryURLBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->location) gf_free(ptr->location);\n\tgf_free(ptr);\n\treturn;\n}\n\n\nGF_Err url_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_DataEntryURLBox *ptr = (GF_DataEntryURLBox *)s;\n\n\tif (ptr->size) {\n\t\tu32 location_size = (u32) ptr->size;\n\t\tif (location_size < 1) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid size %llu in svhd box\\n\", ptr->size));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t\tptr->location = (char*)gf_malloc(location_size);\n\t\tif (! ptr->location) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->location, location_size);\n\t\tif (ptr->location[location_size-1]) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] url box location is not 0-terminated\\n\" ));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *url_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DataEntryURLBox, GF_ISOM_BOX_TYPE_URL);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err url_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_DataEntryURLBox *ptr = (GF_DataEntryURLBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\t//the flag set indicates we have a string (WE HAVE TO for URLs)\n\tif ( !(ptr->flags & 1)) {\n\t\tif (ptr->location) {\n\t\t\tgf_bs_write_data(bs, ptr->location, (u32)strlen(ptr->location) + 1);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err url_box_size(GF_Box *s)\n{\n\tGF_DataEntryURLBox *ptr = (GF_DataEntryURLBox *)s;\n\n\tif ( !(ptr->flags & 1)) {\n\t\tif (ptr->location) ptr->size += 1 + strlen(ptr->location);\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid urn_box_del(GF_Box *s)\n{\n\tGF_DataEntryURNBox *ptr = (GF_DataEntryURNBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->location) gf_free(ptr->location);\n\tif (ptr->nameURN) gf_free(ptr->nameURN);\n\tgf_free(ptr);\n}\n\n\nGF_Err urn_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i, to_read;\n\tchar *tmpName;\n\tGF_DataEntryURNBox *ptr = (GF_DataEntryURNBox *)s;\n\tif (! ptr->size ) return GF_OK;\n\n\t//here we have to handle that in a clever way\n\tto_read = (u32) ptr->size;\n\ttmpName = (char*)gf_malloc(sizeof(char) * to_read);\n\tif (!tmpName) return GF_OUT_OF_MEM;\n\t//get the data\n\tgf_bs_read_data(bs, tmpName, to_read);\n\n\t//then get the break\n\ti = 0;\n\twhile ( (i < to_read) && (tmpName[i] != 0) ) {\n\t\ti++;\n\t}\n\t//check the data is consistent\n\tif (i == to_read) {\n\t\tgf_free(tmpName);\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\t//no NULL char, URL is not specified\n\tif (i == to_read - 1) {\n\t\tptr->nameURN = tmpName;\n\t\tptr->location = NULL;\n\t\treturn GF_OK;\n\t}\n\t//OK, this has both URN and URL\n\tptr->nameURN = (char*)gf_malloc(sizeof(char) * (i+1));\n\tif (!ptr->nameURN) {\n\t\tgf_free(tmpName);\n\t\treturn GF_OUT_OF_MEM;\n\t}\n\tmemcpy(ptr->nameURN, tmpName, i + 1);\n\n\tif (tmpName[to_read - 1] != 0) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] urn box contains invalid location field\\n\" ));\n\t}\n\telse {\n\t\tptr->location = (char*)gf_malloc(sizeof(char) * (to_read - i - 1));\n\t\tif (!ptr->location) {\n\t\t\tgf_free(tmpName);\n\t\t\tgf_free(ptr->nameURN);\n\t\t\tptr->nameURN = NULL;\n\t\t\treturn GF_OUT_OF_MEM;\n\t\t}\n\t\tmemcpy(ptr->location, tmpName + i + 1, (to_read - i - 1));\n\t}\n\n\tgf_free(tmpName);\n\treturn GF_OK;\n}\n\nGF_Box *urn_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DataEntryURNBox, GF_ISOM_BOX_TYPE_URN);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err urn_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_DataEntryURNBox *ptr = (GF_DataEntryURNBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\t//the flag set indicates we have a string (WE HAVE TO for URLs)\n\tif ( !(ptr->flags & 1)) {\n\t\t//to check, the spec says: First name, then location\n\t\tif (ptr->nameURN) {\n\t\t\tgf_bs_write_data(bs, ptr->nameURN, (u32)strlen(ptr->nameURN) + 1);\n\t\t}\n\t\tif (ptr->location) {\n\t\t\tgf_bs_write_data(bs, ptr->location, (u32)strlen(ptr->location) + 1);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err urn_box_size(GF_Box *s)\n{\n\tGF_DataEntryURNBox *ptr = (GF_DataEntryURNBox *)s;\n\n\tif ( !(ptr->flags & 1)) {\n\t\tif (ptr->nameURN) ptr->size += 1 + strlen(ptr->nameURN);\n\t\tif (ptr->location) ptr->size += 1 + strlen(ptr->location);\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid unkn_box_del(GF_Box *s)\n{\n\tGF_UnknownBox *ptr = (GF_UnknownBox *) s;\n\tif (!s) return;\n\tif (ptr->data) gf_free(ptr->data);\n\tgf_free(ptr);\n}\n\n\nGF_Err unkn_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 bytesToRead, sub_size, sub_a;\n\tGF_BitStream *sub_bs;\n\tGF_UnknownBox *ptr = (GF_UnknownBox *)s;\n\tif (ptr->size > 0xFFFFFFFF) return GF_ISOM_INVALID_FILE;\n\tbytesToRead = (u32) (ptr->size);\n\n\tif (!bytesToRead) return GF_OK;\n\tif (bytesToRead>1000000) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Unknown box %s (0x%08X) with payload larger than 1 MBytes, ignoring\\n\", gf_4cc_to_str(ptr->original_4cc), ptr->original_4cc ));\n\t\tgf_bs_skip_bytes(bs, ptr->dataSize);\n\t\treturn GF_OK;\n\t}\n\n\tptr->data = (char*)gf_malloc(bytesToRead);\n\tif (ptr->data == NULL ) return GF_OUT_OF_MEM;\n\tptr->dataSize = bytesToRead;\n\tgf_bs_read_data(bs, ptr->data, ptr->dataSize);\n\n\t//try to parse container boxes, check if next 8 bytes match a subbox\n\tsub_bs = gf_bs_new(ptr->data, ptr->dataSize, GF_BITSTREAM_READ);\n\tsub_size = gf_bs_read_u32(sub_bs);\n\tsub_a = gf_bs_read_u8(sub_bs);\n\te = (sub_size && (sub_size <= ptr->dataSize)) ? GF_OK : GF_NOT_SUPPORTED;\n\tif (! isalnum(sub_a)) e = GF_NOT_SUPPORTED;\n\tsub_a = gf_bs_read_u8(sub_bs);\n\tif (! isalnum(sub_a)) e = GF_NOT_SUPPORTED;\n\tsub_a = gf_bs_read_u8(sub_bs);\n\tif (! isalnum(sub_a)) e = GF_NOT_SUPPORTED;\n\tsub_a = gf_bs_read_u8(sub_bs);\n\tif (! isalnum(sub_a)) e = GF_NOT_SUPPORTED;\n\n\tif (e == GF_OK) {\n\t\tgf_bs_seek(sub_bs, 0);\n\t\tgf_bs_set_cookie(sub_bs, GF_ISOM_BS_COOKIE_NO_LOGS);\n\t\te = gf_isom_box_array_read(s, sub_bs);\n\t}\n\tgf_bs_del(sub_bs);\n\tif (e==GF_OK) {\n\t\tgf_free(ptr->data);\n\t\tptr->data = NULL;\n\t\tptr->dataSize = 0;\n\t} else if (s->child_boxes) {\n\t\tgf_isom_box_array_del(s->child_boxes);\n\t\ts->child_boxes=NULL;\n\t}\n\n\treturn GF_OK;\n}\n\nGF_Box *unkn_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_UnknownBox, GF_ISOM_BOX_TYPE_UNKNOWN);\n\treturn (GF_Box *) tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err unkn_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 type;\n\tGF_UnknownBox *ptr = (GF_UnknownBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\tif (ptr->original_4cc == GF_ISOM_BOX_TYPE_UUID) return GF_BAD_PARAM;\n\ttype = s->type;\n\tptr->type = ptr->original_4cc;\n\te = gf_isom_box_write_header(s, bs);\n\tptr->type = type;\n\tif (e) return e;\n\n\tif (ptr->sai_type) {\n\t\tif (ptr->saio_box) {\n\t\t\tu64 pos = gf_bs_get_position(bs);\n\t\t\tgf_bs_seek(bs, ptr->saio_box->offset_first_offset_field);\n\t\t\tif (ptr->saio_box->version)\n\t\t\t\tgf_bs_write_u64(bs, pos);\n\t\t\telse\n\t\t\t\tgf_bs_write_u32(bs, (u32) pos);\n\t\t\tgf_bs_seek(bs, pos);\n\t\t} else {\n\t\t\tptr->sai_offset = gf_bs_get_position(bs);\n\t\t}\n\t}\n\n\tif (ptr->dataSize && ptr->data) {\n\t\tgf_bs_write_data(bs, ptr->data, ptr->dataSize);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err unkn_box_size(GF_Box *s)\n{\n\tGF_UnknownBox *ptr = (GF_UnknownBox *)s;\n\n\tif (ptr->dataSize && ptr->data) {\n\t\tptr->size += ptr->dataSize;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid def_parent_box_del(GF_Box *s)\n{\n\tif (s) gf_free(s);\n}\n\n\nGF_Err def_parent_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *def_parent_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_Box, 0);\n\treturn (GF_Box *) tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err def_parent_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err def_parent_box_size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid def_parent_full_box_del(GF_Box *s)\n{\n\tif (s) gf_free(s);\n}\n\n\nGF_Err def_parent_full_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *def_parent_full_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_Box, 0);\n\treturn (GF_Box *) tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err def_parent_full_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_full_box_write(s, bs);\n}\n\nGF_Err def_parent_full_box_size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid uuid_box_del(GF_Box *s)\n{\n\tGF_UnknownUUIDBox *ptr = (GF_UnknownUUIDBox *) s;\n\tif (!s) return;\n\tif (ptr->data) gf_free(ptr->data);\n\tgf_free(ptr);\n}\n\n\nGF_Err uuid_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 bytesToRead;\n\tGF_UnknownUUIDBox *ptr = (GF_UnknownUUIDBox *)s;\n\tif (ptr->size > 0xFFFFFFFF) return GF_ISOM_INVALID_FILE;\n\tbytesToRead = (u32) (ptr->size);\n\n\tif (bytesToRead) {\n\t\tptr->data = (char*)gf_malloc(bytesToRead);\n\t\tif (ptr->data == NULL ) return GF_OUT_OF_MEM;\n\t\tptr->dataSize = bytesToRead;\n\t\tgf_bs_read_data(bs, ptr->data, ptr->dataSize);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *uuid_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_UnknownUUIDBox, GF_ISOM_BOX_TYPE_UUID);\n\treturn (GF_Box *) tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err uuid_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_UnknownUUIDBox *ptr = (GF_UnknownUUIDBox*)s;\n\tif (!s) return GF_BAD_PARAM;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tif (ptr->data) {\n\t\tgf_bs_write_data(bs, ptr->data, ptr->dataSize);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err uuid_box_size(GF_Box *s)\n{\n\tGF_UnknownUUIDBox*ptr = (GF_UnknownUUIDBox*)s;\n\tptr->size += ptr->dataSize;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid dinf_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\n\nGF_Err dinf_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_DataInformationBox *ptr = (GF_DataInformationBox *)s;\n\tswitch(a->type) {\n\tcase GF_ISOM_BOX_TYPE_DREF:\n\t\tBOX_FIELD_ASSIGN(dref, GF_DataReferenceBox)\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err dinf_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_DataInformationBox *dinf;\n\tGF_Err e = gf_isom_box_array_read(s, bs);\n\tif (e) {\n\t\treturn e;\n\t}\n\tdinf = (GF_DataInformationBox *)s;\n\tif (!dinf->dref) {\n\t\tif (! (gf_bs_get_cookie(bs) & GF_ISOM_BS_COOKIE_NO_LOGS) ) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing dref box in dinf\\n\"));\n\t\t}\n\t\tdinf->dref = (GF_DataReferenceBox *) gf_isom_box_new_parent(&dinf->child_boxes, GF_ISOM_BOX_TYPE_DREF);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *dinf_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DataInformationBox, GF_ISOM_BOX_TYPE_DINF);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err dinf_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err dinf_box_size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid dref_box_del(GF_Box *s)\n{\n\tGF_DataReferenceBox *ptr = (GF_DataReferenceBox *) s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err dref_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_DataReferenceBox *ptr = (GF_DataReferenceBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tgf_bs_read_u32(bs);\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *dref_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DataReferenceBox, GF_ISOM_BOX_TYPE_DREF);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err dref_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 count;\n\tGF_DataReferenceBox *ptr = (GF_DataReferenceBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tcount = ptr->child_boxes ? gf_list_count(ptr->child_boxes) : 0;\n\tgf_bs_write_u32(bs, count);\n\treturn GF_OK;\n}\n\nGF_Err dref_box_size(GF_Box *s)\n{\n\tGF_DataReferenceBox *ptr = (GF_DataReferenceBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\n\tptr->size += 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid edts_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\n\nGF_Err edts_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_EditBox *ptr = (GF_EditBox *)s;\n\tif (a->type == GF_ISOM_BOX_TYPE_ELST) {\n\t\tBOX_FIELD_ASSIGN(editList, GF_EditListBox)\n\t\treturn GF_OK;\n\t} else {\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err edts_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *edts_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_EditBox, GF_ISOM_BOX_TYPE_EDTS);\n\treturn (GF_Box *) tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err edts_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_EditBox *ptr = (GF_EditBox *)s;\n\n\t//here we have a trick: if editList is empty, skip the box\n\tif (ptr->editList && gf_list_count(ptr->editList->entryList)) {\n\t\treturn gf_isom_box_write_header(s, bs);\n\t} else {\n\t\ts->size = 0;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err edts_box_size(GF_Box *s)\n{\n\tGF_EditBox *ptr = (GF_EditBox *)s;\n\n\t//here we have a trick: if editList is empty, skip the box\n\tif (!ptr->editList || ! gf_list_count(ptr->editList->entryList)) {\n\t\tptr->size = 0;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid elst_box_del(GF_Box *s)\n{\n\tGF_EditListBox *ptr;\n\tu32 nb_entries;\n\tu32 i;\n\n\tptr = (GF_EditListBox *)s;\n\tif (ptr == NULL) return;\n\tnb_entries = gf_list_count(ptr->entryList);\n\tfor (i = 0; i < nb_entries; i++) {\n\t\tGF_EdtsEntry *p = (GF_EdtsEntry*)gf_list_get(ptr->entryList, i);\n\t\tif (p) gf_free(p);\n\t}\n\tgf_list_del(ptr->entryList);\n\tgf_free(ptr);\n}\n\nGF_Err elst_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 entries;\n\ts32 tr;\n\tu32 nb_entries;\n\tGF_EditListBox *ptr = (GF_EditListBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tnb_entries = gf_bs_read_u32(bs);\n\n\tif (ptr->version == 1) {\n\t\tif (nb_entries > ptr->size / 20) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in ctts\\n\", nb_entries));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t} else {\n\t\tif (nb_entries > ptr->size / 12) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in ctts\\n\", nb_entries));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t}\n\n\n\tfor (entries = 0; entries < nb_entries; entries++) {\n\t\tGF_EdtsEntry *p;\n\t\tGF_SAFEALLOC(p, GF_EdtsEntry);\n\t\tif (!p) return GF_OUT_OF_MEM;\n\t\tif (ptr->version == 1) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 16);\n\t\t\tp->segmentDuration = gf_bs_read_u64(bs);\n\t\t\tp->mediaTime = (s64) gf_bs_read_u64(bs);\n\t\t} else {\n\t\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\t\tp->segmentDuration = gf_bs_read_u32(bs);\n\t\t\ttr = gf_bs_read_u32(bs);\n\t\t\tp->mediaTime = (s64) tr;\n\t\t}\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tp->mediaRate = gf_bs_read_u32(bs);\n\t\tgf_list_add(ptr->entryList, p);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *elst_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_EditListBox, GF_ISOM_BOX_TYPE_ELST);\n\ttmp->entryList = gf_list_new();\n\tif (!tmp->entryList) {\n\t\tgf_free(tmp);\n\t\treturn NULL;\n\t}\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err elst_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tu32 nb_entries;\n\tGF_EditListBox *ptr = (GF_EditListBox *)s;\n\tif (!ptr) return GF_BAD_PARAM;\n\n\tnb_entries = gf_list_count(ptr->entryList);\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, nb_entries);\n\tfor (i = 0; i < nb_entries; i++ ) {\n\t\tGF_EdtsEntry *p = (GF_EdtsEntry*)gf_list_get(ptr->entryList, i);\n\t\tif (ptr->version == 1) {\n\t\t\tgf_bs_write_u64(bs, p->segmentDuration);\n\t\t\tgf_bs_write_u64(bs, p->mediaTime);\n\t\t} else {\n\t\t\tgf_bs_write_u32(bs, (u32) p->segmentDuration);\n\t\t\tgf_bs_write_u32(bs, (s32) p->mediaTime);\n\t\t}\n\t\tgf_bs_write_u32(bs, p->mediaRate);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err elst_box_size(GF_Box *s)\n{\n\tu32 durtimebytes;\n\tu32 i, nb_entries;\n\tGF_EditListBox *ptr = (GF_EditListBox *)s;\n\n\t//entry count\n\tptr->size += 4;\n\tnb_entries = gf_list_count(ptr->entryList);\n\tptr->version = 0;\n\tfor (i=0; i<nb_entries; i++) {\n\t\tGF_EdtsEntry *p = (GF_EdtsEntry*)gf_list_get(ptr->entryList, i);\n\t\tif ((p->segmentDuration>0xFFFFFFFF) || (p->mediaTime>0xFFFFFFFF)) {\n\t\t\tptr->version = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tdurtimebytes = (ptr->version == 1 ? 16 : 8) + 4;\n\tptr->size += (nb_entries * durtimebytes);\n\treturn GF_OK;\n}\n\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid esds_box_del(GF_Box *s)\n{\n\tGF_ESDBox *ptr = (GF_ESDBox *)s;\n\tif (ptr == NULL)\treturn;\n\tif (ptr->desc) gf_odf_desc_del((GF_Descriptor *)ptr->desc);\n\tgf_free(ptr);\n}\n\n\nGF_Err esds_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e=GF_OK;\n\tu32 descSize;\n\tGF_ESDBox *ptr = (GF_ESDBox *)s;\n\n\tdescSize = (u32) (ptr->size);\n\n\tif (descSize) {\n\t\tchar *enc_desc = (char*)gf_malloc(sizeof(char) * descSize);\n\t\tif (!enc_desc) return GF_OUT_OF_MEM;\n\t\t//get the payload\n\t\tgf_bs_read_data(bs, enc_desc, descSize);\n\t\t//send it to the OD Codec\n\t\te = gf_odf_desc_read(enc_desc, descSize, (GF_Descriptor **) &ptr->desc);\n\t\t//OK, free our desc\n\t\tgf_free(enc_desc);\n\n\t\tif (ptr->desc && (ptr->desc->tag!=GF_ODF_ESD_TAG) ) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid descriptor tag 0x%x in esds\\n\", ptr->desc->tag));\n\t\t\tgf_odf_desc_del((GF_Descriptor*)ptr->desc);\n\t\t\tptr->desc=NULL;\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\n\t\tif (e) {\n\t\t\tptr->desc = NULL;\n\t\t} else {\n\t\t\t/*fix broken files*/\n\t\t\tif (ptr->desc && !ptr->desc->URLString) {\n\t\t\t\tif (!ptr->desc->slConfig) {\n\t\t\t\t\tptr->desc->slConfig = (GF_SLConfig *) gf_odf_desc_new(GF_ODF_SLC_TAG);\n\t\t\t\t\tptr->desc->slConfig->predefined = SLPredef_MP4;\n\t\t\t\t} else if (ptr->desc->slConfig->predefined != SLPredef_MP4) {\n\t\t\t\t\tptr->desc->slConfig->predefined = SLPredef_MP4;\n\t\t\t\t\tgf_odf_slc_set_pref(ptr->desc->slConfig);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn e;\n}\n\nGF_Box *esds_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ESDBox, GF_ISOM_BOX_TYPE_ESDS);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err esds_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu8 *enc_desc;\n\tu32 descSize = 0;\n\tGF_ESDBox *ptr = (GF_ESDBox *)s;\n\t//make sure we write with no ESID and no OCRESID\n    if (ptr->desc) {\n        ptr->desc->ESID = 0;\n        ptr->desc->OCRESID = 0;\n    }\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\te = gf_odf_desc_write((GF_Descriptor *)ptr->desc, &enc_desc, &descSize);\n\tif (e) return e;\n\tgf_bs_write_data(bs, enc_desc, descSize);\n\t//free our buffer\n\tgf_free(enc_desc);\n\treturn GF_OK;\n}\n\nGF_Err esds_box_size(GF_Box *s)\n{\n\tu32 descSize = 0;\n\tGF_ESDBox *ptr = (GF_ESDBox *)s;\n\t//make sure we write with no ESID and no OCRESID\n    if (ptr->desc) {\n        ptr->desc->ESID = 0;\n        ptr->desc->OCRESID = 0;\n    }\n\tdescSize = gf_odf_desc_size((GF_Descriptor *)ptr->desc);\n\tptr->size += descSize;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid free_box_del(GF_Box *s)\n{\n\tGF_FreeSpaceBox *ptr = (GF_FreeSpaceBox *)s;\n\tif (ptr->data) gf_free(ptr->data);\n\tgf_free(ptr);\n}\n\n\nGF_Err free_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 bytesToRead;\n\tGF_FreeSpaceBox *ptr = (GF_FreeSpaceBox *)s;\n\n\tif (ptr->size > 0xFFFFFFFF) return GF_IO_ERR;\n\n\tbytesToRead = (u32) (ptr->size);\n\n\tif (bytesToRead) {\n\t\tptr->data = (char*)gf_malloc(bytesToRead * sizeof(char));\n\t\tif (!ptr->data) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->data, bytesToRead);\n\t\tptr->dataSize = bytesToRead;\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *free_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_FreeSpaceBox, GF_ISOM_BOX_TYPE_FREE);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err free_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_FreeSpaceBox *ptr = (GF_FreeSpaceBox *)s;\n\tif (ptr->original_4cc) {\n\t\tu32 t = s->type;\n\t\ts->type=ptr->original_4cc;\n\t\te = gf_isom_box_write_header(s, bs);\n\t\ts->type=t;\n\t} else {\n\t\te = gf_isom_box_write_header(s, bs);\n\t}\n\tif (e) return e;\n\tif (ptr->dataSize)\t{\n\t\tif (ptr->data) {\n\t\t\tgf_bs_write_data(bs, ptr->data, ptr->dataSize);\n\t\t} else {\n\t\t\tu32 i = 0;\n\t\t\twhile (i<ptr->dataSize) {\n\t\t\t\tgf_bs_write_u8(bs, 0);\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err free_box_size(GF_Box *s)\n{\n\tGF_FreeSpaceBox *ptr = (GF_FreeSpaceBox *)s;\n\tptr->size += ptr->dataSize;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid ftyp_box_del(GF_Box *s)\n{\n\tGF_FileTypeBox *ptr = (GF_FileTypeBox *) s;\n\tif (ptr->altBrand) gf_free(ptr->altBrand);\n\tgf_free(ptr);\n}\n\nGF_Box *ftyp_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_FileTypeBox, GF_ISOM_BOX_TYPE_FTYP);\n\treturn (GF_Box *)tmp;\n}\n\nGF_Err ftyp_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_FileTypeBox *ptr = (GF_FileTypeBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 8);\n\tptr->majorBrand = gf_bs_read_u32(bs);\n\tptr->minorVersion = gf_bs_read_u32(bs);\n\n\tif (ptr->size % 4) return GF_ISOM_INVALID_FILE;\n\tptr->altCount = ( (u32) (ptr->size)) / 4;\n\tif (!ptr->altCount) return GF_OK;\n\n\tptr->altBrand = (u32*)gf_malloc(sizeof(u32)*ptr->altCount);\n\tif (!ptr->altBrand) return GF_OUT_OF_MEM;\n\n\tfor (i = 0; i<ptr->altCount; i++) {\n\t\tptr->altBrand[i] = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err ftyp_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_FileTypeBox *ptr = (GF_FileTypeBox *) s;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->majorBrand);\n\tgf_bs_write_u32(bs, ptr->minorVersion);\n\tfor (i=0; i<ptr->altCount; i++) {\n\t\tgf_bs_write_u32(bs, ptr->altBrand[i]);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err ftyp_box_size(GF_Box *s)\n{\n\tGF_FileTypeBox *ptr = (GF_FileTypeBox *)s;\n\n\tptr->size += 8 + ptr->altCount * 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid gnrm_box_del(GF_Box *s)\n{\n\tGF_GenericSampleEntryBox *ptr = (GF_GenericSampleEntryBox *)s;\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)ptr);\n\tif (ptr->data) gf_free(ptr->data);\n\tgf_free(ptr);\n}\n\nGF_Box *gnrm_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_GenericSampleEntryBox, GF_ISOM_BOX_TYPE_GNRM);\n\n\tgf_isom_sample_entry_init((GF_SampleEntryBox*)tmp);\n\treturn (GF_Box *)tmp;\n}\n\n//dummy\nGF_Err gnrm_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err gnrm_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_GenericSampleEntryBox *ptr = (GF_GenericSampleEntryBox *)s;\n\n\t//careful we are not writing the box type but the entry type so switch for write\n\tif (ptr->EntryType == GF_ISOM_BOX_TYPE_UUID) return GF_BAD_PARAM;\n\tptr->type = ptr->EntryType;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tptr->type = GF_ISOM_BOX_TYPE_GNRM;\n\tgf_bs_write_data(bs, ptr->reserved, 6);\n\tgf_bs_write_u16(bs, ptr->dataReferenceIndex);\n\tgf_bs_write_data(bs,  ptr->data, ptr->data_size);\n\treturn GF_OK;\n}\n\nGF_Err gnrm_box_size(GF_Box *s)\n{\n\tGF_GenericSampleEntryBox *ptr = (GF_GenericSampleEntryBox *)s;\n\ts->type = GF_ISOM_BOX_TYPE_GNRM;\n\tptr->size += 8+ptr->data_size;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid gnrv_box_del(GF_Box *s)\n{\n\tGF_GenericVisualSampleEntryBox *ptr = (GF_GenericVisualSampleEntryBox *)s;\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)ptr);\n\tif (ptr->data) gf_free(ptr->data);\n\tgf_free(ptr);\n}\n\nGF_Box *gnrv_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_GenericVisualSampleEntryBox, GF_ISOM_BOX_TYPE_GNRV);\n\tgf_isom_video_sample_entry_init((GF_VisualSampleEntryBox*) tmp);\n\treturn (GF_Box *)tmp;\n}\n//dummy\nGF_Err gnrv_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err gnrv_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_GenericVisualSampleEntryBox *ptr = (GF_GenericVisualSampleEntryBox *)s;\n\n\t//careful we are not writing the box type but the entry type so switch for write\n\tif (ptr->EntryType == GF_ISOM_BOX_TYPE_UUID) return GF_BAD_PARAM;\n\tptr->type = ptr->EntryType;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tptr->type = GF_ISOM_BOX_TYPE_GNRV;\n\n\tgf_isom_video_sample_entry_write((GF_VisualSampleEntryBox *)ptr, bs);\n\tgf_bs_write_data(bs,  ptr->data, ptr->data_size);\n\treturn GF_OK;\n}\n\nGF_Err gnrv_box_size(GF_Box *s)\n{\n\tGF_GenericVisualSampleEntryBox *ptr = (GF_GenericVisualSampleEntryBox *)s;\n\ts->type = GF_ISOM_BOX_TYPE_GNRV;\n\tgf_isom_video_sample_entry_size((GF_VisualSampleEntryBox *)s);\n\tptr->size += ptr->data_size;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid gnra_box_del(GF_Box *s)\n{\n\tGF_GenericAudioSampleEntryBox *ptr = (GF_GenericAudioSampleEntryBox *)s;\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)ptr);\n\tif (ptr->data) gf_free(ptr->data);\n\tgf_free(ptr);\n}\n\nGF_Box *gnra_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_GenericAudioSampleEntryBox, GF_ISOM_BOX_TYPE_GNRA);\n\tgf_isom_audio_sample_entry_init((GF_AudioSampleEntryBox*) tmp);\n\treturn (GF_Box *)tmp;\n}\n//dummy\nGF_Err gnra_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn GF_OK;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err gnra_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_GenericAudioSampleEntryBox *ptr = (GF_GenericAudioSampleEntryBox *)s;\n\n\t//careful we are not writing the box type but the entry type so switch for write\n\tif (ptr->EntryType == GF_ISOM_BOX_TYPE_UUID) return GF_BAD_PARAM;\n\tptr->type = ptr->EntryType;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tptr->type = GF_ISOM_BOX_TYPE_GNRA;\n\n\tgf_isom_audio_sample_entry_write((GF_AudioSampleEntryBox *)ptr, bs);\n\tif (ptr->data) {\n\t\tgf_bs_write_data(bs,  ptr->data, ptr->data_size);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err gnra_box_size(GF_Box *s)\n{\n\tGF_GenericAudioSampleEntryBox *ptr = (GF_GenericAudioSampleEntryBox *)s;\n\ts->type = GF_ISOM_BOX_TYPE_GNRA;\n\tgf_isom_audio_sample_entry_size((GF_AudioSampleEntryBox *)s);\n\tptr->size += ptr->data_size;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid hdlr_box_del(GF_Box *s)\n{\n\tGF_HandlerBox *ptr = (GF_HandlerBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->nameUTF8) gf_free(ptr->nameUTF8);\n\tgf_free(ptr);\n}\n\n\nGF_Err hdlr_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu64 cookie;\n\tGF_HandlerBox *ptr = (GF_HandlerBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 20);\n\tptr->reserved1 = gf_bs_read_u32(bs);\n\tptr->handlerType = gf_bs_read_u32(bs);\n\tgf_bs_read_data(bs, (char*)ptr->reserved2, 12);\n\n\tcookie = gf_bs_get_cookie(bs);\n\tif (ptr->handlerType==GF_ISOM_MEDIA_VISUAL)\n\t\tcookie |= GF_ISOM_BS_COOKIE_VISUAL_TRACK;\n\telse\n\t\tcookie &= ~GF_ISOM_BS_COOKIE_VISUAL_TRACK;\n\tgf_bs_set_cookie(bs, cookie);\n\n\tif (ptr->size) {\n\t\tu32 name_size = (u32) ptr->size;\n\t\tif (name_size < 1) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid size %llu in hdlr\\n\", ptr->size));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t\tptr->nameUTF8 = (char*)gf_malloc(name_size);\n\t\tif (!ptr->nameUTF8) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->nameUTF8, name_size);\n\n\t\t//patch for old QT files - we cannot rely on checking if str[0]==len(str+1) since we may have\n\t\t//cases where the first character of the string decimal value is indeed the same as the string length!!\n\t\t//we had this issue with encryption_import test\n\t\t//we therefore only check if last char is null, and if not so assume old QT style\n\t\tif (ptr->nameUTF8[name_size-1]) {\n\t\t\tif (name_size > 1)\n\t\t\t\tmemmove(ptr->nameUTF8, ptr->nameUTF8+1, sizeof(char) * (u32) (name_size-1) );\n\t\t\tptr->nameUTF8[name_size-1] = 0;\n\t\t\tptr->store_counted_string = GF_TRUE;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *hdlr_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_HandlerBox, GF_ISOM_BOX_TYPE_HDLR);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err hdlr_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_HandlerBox *ptr = (GF_HandlerBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->reserved1);\n\tgf_bs_write_u32(bs, ptr->handlerType);\n\tgf_bs_write_data(bs, (char*)ptr->reserved2, 12);\n\n\tif (ptr->nameUTF8) {\n\t\tu32 len = (u32)strlen(ptr->nameUTF8);\n\t\tif (ptr->store_counted_string) {\n\t\t\tgf_bs_write_u8(bs, len);\n\t\t\tgf_bs_write_data(bs, ptr->nameUTF8, len);\n\t\t} else {\n\t\t\tgf_bs_write_data(bs, ptr->nameUTF8, len);\n\t\t\tgf_bs_write_u8(bs, 0);\n\t\t}\n\t} else {\n\t\tgf_bs_write_u8(bs, 0);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err hdlr_box_size(GF_Box *s)\n{\n\tGF_HandlerBox *ptr = (GF_HandlerBox *)s;\n\tptr->size += 20 + 1; //null term or counted string\n\tif (ptr->nameUTF8) {\n\t\tptr->size += strlen(ptr->nameUTF8);\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid hinf_box_del(GF_Box *s)\n{\n\tGF_HintInfoBox *hinf = (GF_HintInfoBox *)s;\n\tgf_free(hinf);\n}\n\nGF_Box *hinf_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_HintInfoBox, GF_ISOM_BOX_TYPE_HINF);\n\n\ttmp->child_boxes = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\nGF_Err hinf_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_HintInfoBox *hinf = (GF_HintInfoBox *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_MAXR:\n\t\tif (!is_rem) {\n\t\t\tu32 i=0;\n\t\t\tGF_MAXRBox *maxR;\n\t\t\twhile ((maxR = (GF_MAXRBox *)gf_list_enum(hinf->child_boxes, &i))) {\n\t\t\t\tif ((maxR->type==GF_ISOM_BOX_TYPE_MAXR) && (maxR->granularity == ((GF_MAXRBox *)a)->granularity))\n\t\t\t\t\tERROR_ON_DUPLICATED_BOX(a, s)\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err hinf_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err hinf_box_write(GF_Box *s, GF_BitStream *bs)\n{\n//\tGF_HintInfoBox *ptr = (GF_HintInfoBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err hinf_box_size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid hmhd_box_del(GF_Box *s)\n{\n\tGF_HintMediaHeaderBox *ptr = (GF_HintMediaHeaderBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err hmhd_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_HintMediaHeaderBox *ptr = (GF_HintMediaHeaderBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 16);\n\tptr->maxPDUSize = gf_bs_read_u16(bs);\n\tptr->avgPDUSize = gf_bs_read_u16(bs);\n\tptr->maxBitrate = gf_bs_read_u32(bs);\n\tptr->avgBitrate = gf_bs_read_u32(bs);\n\tptr->slidingAverageBitrate = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\nGF_Box *hmhd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_HintMediaHeaderBox, GF_ISOM_BOX_TYPE_HMHD);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err hmhd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_HintMediaHeaderBox *ptr = (GF_HintMediaHeaderBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u16(bs, ptr->maxPDUSize);\n\tgf_bs_write_u16(bs, ptr->avgPDUSize);\n\tgf_bs_write_u32(bs, ptr->maxBitrate);\n\tgf_bs_write_u32(bs, ptr->avgBitrate);\n\tgf_bs_write_u32(bs, ptr->slidingAverageBitrate);\n\treturn GF_OK;\n}\n\nGF_Err hmhd_box_size(GF_Box *s)\n{\n\tGF_HintMediaHeaderBox *ptr = (GF_HintMediaHeaderBox *)s;\n\tptr->size += 16;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *hnti_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_HintTrackInfoBox, GF_ISOM_BOX_TYPE_HNTI);\n\treturn (GF_Box *)tmp;\n}\n\nvoid hnti_box_del(GF_Box *a)\n{\n\tgf_free(a);\n}\n\nGF_Err hnti_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_HintTrackInfoBox *ptr = (GF_HintTrackInfoBox *)s;\n\tif (!ptr || !a) return GF_BAD_PARAM;\n\n\tswitch (a->type) {\n\t//this is the value for GF_RTPBox - same as HintSampleEntry for RTP !!!\n\tcase GF_ISOM_BOX_TYPE_RTP:\n\tcase GF_ISOM_BOX_TYPE_SDP:\n\t\tBOX_FIELD_ASSIGN(SDP, GF_Box)\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err hnti_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err hnti_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\n\nGF_Err hnti_box_size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n/**********************************************************\n\t\tGF_SDPBox\n**********************************************************/\n\nvoid sdp_box_del(GF_Box *s)\n{\n\tGF_SDPBox *ptr = (GF_SDPBox *)s;\n\tif (ptr->sdpText) gf_free(ptr->sdpText);\n\tgf_free(ptr);\n\n}\nGF_Err sdp_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 length;\n\tGF_SDPBox *ptr = (GF_SDPBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\n\tlength = (u32) (ptr->size);\n\n\tif (length >= (u32)0xFFFFFFFF) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid length %lu in sdp box\\n\", length));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\t//sdp text has no delimiter !!!\n\tptr->sdpText = (char*)gf_malloc(sizeof(char) * (length+1));\n\tif (!ptr->sdpText) return GF_OUT_OF_MEM;\n\n\tgf_bs_read_data(bs, ptr->sdpText, length);\n\tptr->sdpText[length] = 0;\n\treturn GF_OK;\n}\nGF_Box *sdp_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SDPBox, GF_ISOM_BOX_TYPE_SDP);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err sdp_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SDPBox *ptr = (GF_SDPBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\t//don't write the NULL char!!!\n\tif (ptr->sdpText)\n\t\tgf_bs_write_data(bs, ptr->sdpText, (u32) strlen(ptr->sdpText));\n\treturn GF_OK;\n}\nGF_Err sdp_box_size(GF_Box *s)\n{\n\tGF_SDPBox *ptr = (GF_SDPBox *)s;\n\t//don't count the NULL char!!!\n\tif (ptr->sdpText)\n\t\tptr->size += strlen(ptr->sdpText);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n\nvoid rtp_hnti_box_del(GF_Box *s)\n{\n\tGF_RTPBox *ptr = (GF_RTPBox *)s;\n\tif (ptr->sdpText) gf_free(ptr->sdpText);\n\tgf_free(ptr);\n\n}\nGF_Err rtp_hnti_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 length;\n\tGF_RTPBox *ptr = (GF_RTPBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\n\tISOM_DECREASE_SIZE(ptr, 4)\n\tptr->subType = gf_bs_read_u32(bs);\n\n\tlength = (u32) (ptr->size);\n\n\tif (length >= (u32)0xFFFFFFFF) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid length %lu in rtp_hnti box\\n\", length));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\t//sdp text has no delimiter !!!\n\tptr->sdpText = (char*)gf_malloc(sizeof(char) * (length+1));\n\tif (!ptr->sdpText) return GF_OUT_OF_MEM;\n\n\tgf_bs_read_data(bs, ptr->sdpText, length);\n\tptr->sdpText[length] = 0;\n\treturn GF_OK;\n}\n\nGF_Box *rtp_hnti_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_RTPBox, GF_ISOM_BOX_TYPE_RTP);\n\ttmp->subType = GF_ISOM_BOX_TYPE_SDP;\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err rtp_hnti_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_RTPBox *ptr = (GF_RTPBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->subType);\n\t//don't write the NULL char!!!\n\tgf_bs_write_data(bs, ptr->sdpText, (u32) strlen(ptr->sdpText));\n\treturn GF_OK;\n}\n\nGF_Err rtp_hnti_box_size(GF_Box *s)\n{\n\tGF_RTPBox *ptr = (GF_RTPBox *)s;\n\tptr->size += 4 + strlen(ptr->sdpText);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tTRPY GF_Box\n**********************************************************/\n\nvoid trpy_box_del(GF_Box *s)\n{\n\tgf_free((GF_TRPYBox *)s);\n}\nGF_Err trpy_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TRPYBox *ptr = (GF_TRPYBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 8);\n\tptr->nbBytes = gf_bs_read_u64(bs);\n\treturn GF_OK;\n}\nGF_Box *trpy_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TRPYBox, GF_ISOM_BOX_TYPE_TRPY);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err trpy_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TRPYBox *ptr = (GF_TRPYBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u64(bs, ptr->nbBytes);\n\treturn GF_OK;\n}\nGF_Err trpy_box_size(GF_Box *s)\n{\n\ts->size += 8;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n/**********************************************************\n\t\tTOTL GF_Box\n**********************************************************/\n\nvoid totl_box_del(GF_Box *s)\n{\n\tgf_free((GF_TRPYBox *)s);\n}\nGF_Err totl_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TOTLBox *ptr = (GF_TOTLBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->nbBytes = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\nGF_Box *totl_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TOTLBox, GF_ISOM_BOX_TYPE_TOTL);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err totl_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TOTLBox *ptr = (GF_TOTLBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->nbBytes);\n\treturn GF_OK;\n}\nGF_Err totl_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tNUMP GF_Box\n**********************************************************/\n\nvoid nump_box_del(GF_Box *s)\n{\n\tgf_free((GF_NUMPBox *)s);\n}\nGF_Err nump_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_NUMPBox *ptr = (GF_NUMPBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 8);\n\tptr->nbPackets = gf_bs_read_u64(bs);\n\treturn GF_OK;\n}\nGF_Box *nump_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_NUMPBox, GF_ISOM_BOX_TYPE_NUMP);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err nump_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_NUMPBox *ptr = (GF_NUMPBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u64(bs, ptr->nbPackets);\n\treturn GF_OK;\n}\nGF_Err nump_box_size(GF_Box *s)\n{\n\ts->size += 8;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tNPCK GF_Box\n**********************************************************/\n\nvoid npck_box_del(GF_Box *s)\n{\n\tgf_free((GF_NPCKBox *)s);\n}\nGF_Err npck_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_NPCKBox *ptr = (GF_NPCKBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->nbPackets = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\nGF_Box *npck_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_NPCKBox, GF_ISOM_BOX_TYPE_NPCK);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err npck_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_NPCKBox *ptr = (GF_NPCKBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->nbPackets);\n\treturn GF_OK;\n}\nGF_Err npck_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tTPYL GF_Box\n**********************************************************/\n\nvoid tpyl_box_del(GF_Box *s)\n{\n\tgf_free((GF_NTYLBox *)s);\n}\nGF_Err tpyl_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_NTYLBox *ptr = (GF_NTYLBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\tISOM_DECREASE_SIZE(ptr, 8);\n\tptr->nbBytes = gf_bs_read_u64(bs);\n\treturn GF_OK;\n}\nGF_Box *tpyl_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_NTYLBox, GF_ISOM_BOX_TYPE_TPYL);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err tpyl_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_NTYLBox *ptr = (GF_NTYLBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u64(bs, ptr->nbBytes);\n\treturn GF_OK;\n}\nGF_Err tpyl_box_size(GF_Box *s)\n{\n\ts->size += 8;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n/**********************************************************\n\t\tTPAY GF_Box\n**********************************************************/\n\nvoid tpay_box_del(GF_Box *s)\n{\n\tgf_free((GF_TPAYBox *)s);\n}\nGF_Err tpay_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TPAYBox *ptr = (GF_TPAYBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->nbBytes = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\nGF_Box *tpay_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TPAYBox, GF_ISOM_BOX_TYPE_TPAY);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err tpay_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TPAYBox *ptr = (GF_TPAYBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->nbBytes);\n\treturn GF_OK;\n}\nGF_Err tpay_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tMAXR GF_Box\n**********************************************************/\n\nvoid maxr_box_del(GF_Box *s)\n{\n\tgf_free((GF_MAXRBox *)s);\n}\nGF_Err maxr_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MAXRBox *ptr = (GF_MAXRBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\tISOM_DECREASE_SIZE(ptr, 8);\n\tptr->granularity = gf_bs_read_u32(bs);\n\tptr->maxDataRate = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\nGF_Box *maxr_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MAXRBox, GF_ISOM_BOX_TYPE_MAXR);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err maxr_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MAXRBox *ptr = (GF_MAXRBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->granularity);\n\tgf_bs_write_u32(bs, ptr->maxDataRate);\n\treturn GF_OK;\n}\nGF_Err maxr_box_size(GF_Box *s)\n{\n\ts->size += 8;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tDMED GF_Box\n**********************************************************/\n\nvoid dmed_box_del(GF_Box *s)\n{\n\tgf_free((GF_DMEDBox *)s);\n}\nGF_Err dmed_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_DMEDBox *ptr = (GF_DMEDBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 8);\n\tptr->nbBytes = gf_bs_read_u64(bs);\n\treturn GF_OK;\n}\nGF_Box *dmed_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DMEDBox, GF_ISOM_BOX_TYPE_DMED);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err dmed_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_DMEDBox *ptr = (GF_DMEDBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u64(bs, ptr->nbBytes);\n\treturn GF_OK;\n}\nGF_Err dmed_box_size(GF_Box *s)\n{\n\ts->size += 8;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n/**********************************************************\n\t\tDIMM GF_Box\n**********************************************************/\n\nvoid dimm_box_del(GF_Box *s)\n{\n\tgf_free((GF_DIMMBox *)s);\n}\nGF_Err dimm_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_DIMMBox *ptr = (GF_DIMMBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 8)\n\tptr->nbBytes = gf_bs_read_u64(bs);\n\treturn GF_OK;\n}\nGF_Box *dimm_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DIMMBox, GF_ISOM_BOX_TYPE_DIMM);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err dimm_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_DIMMBox *ptr = (GF_DIMMBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u64(bs, ptr->nbBytes);\n\treturn GF_OK;\n}\nGF_Err dimm_box_size(GF_Box *s)\n{\n\ts->size += 8;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n/**********************************************************\n\t\tDREP GF_Box\n**********************************************************/\n\nvoid drep_box_del(GF_Box *s)\n{\n\tgf_free((GF_DREPBox *)s);\n}\nGF_Err drep_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_DREPBox *ptr = (GF_DREPBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 8)\n\tptr->nbBytes = gf_bs_read_u64(bs);\n\treturn GF_OK;\n}\nGF_Box *drep_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DREPBox, GF_ISOM_BOX_TYPE_DREP);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err drep_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_DREPBox *ptr = (GF_DREPBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u64(bs, ptr->nbBytes);\n\treturn GF_OK;\n}\nGF_Err drep_box_size(GF_Box *s)\n{\n\ts->size += 8;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n/**********************************************************\n\t\tTMIN GF_Box\n**********************************************************/\n\nvoid tmin_box_del(GF_Box *s)\n{\n\tgf_free((GF_TMINBox *)s);\n}\nGF_Err tmin_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TMINBox *ptr = (GF_TMINBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4)\n\tptr->minTime = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\nGF_Box *tmin_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TMINBox, GF_ISOM_BOX_TYPE_TMIN);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err tmin_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TMINBox *ptr = (GF_TMINBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->minTime);\n\treturn GF_OK;\n}\nGF_Err tmin_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tTMAX GF_Box\n**********************************************************/\n\nvoid tmax_box_del(GF_Box *s)\n{\n\tgf_free((GF_TMAXBox *)s);\n}\nGF_Err tmax_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TMAXBox *ptr = (GF_TMAXBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4)\n\tptr->maxTime = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\nGF_Box *tmax_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TMAXBox, GF_ISOM_BOX_TYPE_TMAX);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err tmax_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TMAXBox *ptr = (GF_TMAXBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->maxTime);\n\treturn GF_OK;\n}\nGF_Err tmax_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tPMAX GF_Box\n**********************************************************/\n\nvoid pmax_box_del(GF_Box *s)\n{\n\tgf_free((GF_PMAXBox *)s);\n}\nGF_Err pmax_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_PMAXBox *ptr = (GF_PMAXBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4)\n\tptr->maxSize = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\nGF_Box *pmax_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_PMAXBox, GF_ISOM_BOX_TYPE_PMAX);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err pmax_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_PMAXBox *ptr = (GF_PMAXBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->maxSize);\n\treturn GF_OK;\n}\nGF_Err pmax_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tDMAX GF_Box\n**********************************************************/\n\nvoid dmax_box_del(GF_Box *s)\n{\n\tgf_free((GF_DMAXBox *)s);\n}\nGF_Err dmax_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_DMAXBox *ptr = (GF_DMAXBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4)\n\tptr->maxDur = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\nGF_Box *dmax_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DMAXBox, GF_ISOM_BOX_TYPE_DMAX);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err dmax_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_DMAXBox *ptr = (GF_DMAXBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->maxDur);\n\treturn GF_OK;\n}\nGF_Err dmax_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tPAYT GF_Box\n**********************************************************/\n\nvoid payt_box_del(GF_Box *s)\n{\n\tGF_PAYTBox *payt = (GF_PAYTBox *)s;\n\tif (payt->payloadString) gf_free(payt->payloadString);\n\tgf_free(payt);\n}\nGF_Err payt_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 length;\n\tGF_PAYTBox *ptr = (GF_PAYTBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 5 );\n\tptr->payloadCode = gf_bs_read_u32(bs);\n\tlength = gf_bs_read_u8(bs);\n\tISOM_DECREASE_SIZE(ptr, length);\n\tptr->payloadString = (char*)gf_malloc(sizeof(char) * (length+1) );\n\tif (! ptr->payloadString) return GF_OUT_OF_MEM;\n\tgf_bs_read_data(bs, ptr->payloadString, length);\n\tptr->payloadString[length] = 0;\n\n\treturn GF_OK;\n}\nGF_Box *payt_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_PAYTBox, GF_ISOM_BOX_TYPE_PAYT);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err payt_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 len;\n\tGF_Err e;\n\tGF_PAYTBox *ptr = (GF_PAYTBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->payloadCode);\n    len = ptr->payloadString ? (u32) strlen(ptr->payloadString) : 0;\n\tgf_bs_write_u8(bs, len);\n\tif (len) gf_bs_write_data(bs, ptr->payloadString, len);\n\treturn GF_OK;\n}\nGF_Err payt_box_size(GF_Box *s)\n{\n\tGF_PAYTBox *ptr = (GF_PAYTBox *)s;\n\ts->size += 4 + 1;\n\tif (ptr->payloadString) ptr->size += strlen(ptr->payloadString);\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tPAYT GF_Box\n**********************************************************/\n\nvoid name_box_del(GF_Box *s)\n{\n\tGF_NameBox *name = (GF_NameBox *)s;\n\tif (name->string) gf_free(name->string);\n\tgf_free(name);\n}\nGF_Err name_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 length;\n\tGF_NameBox *ptr = (GF_NameBox *)s;\n\n\tlength = (u32) (ptr->size);\n\n\tif (length >= (u32)0xFFFFFFFF) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid length %lu in name box\\n\", length));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tptr->string = (char*)gf_malloc(sizeof(char) * (length+1));\n\tif (! ptr->string) return GF_OUT_OF_MEM;\n\n\tgf_bs_read_data(bs, ptr->string, length);\n\tptr->string[length] = 0;\n\treturn GF_OK;\n}\nGF_Box *name_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_NameBox, GF_ISOM_BOX_TYPE_NAME);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err name_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_NameBox *ptr = (GF_NameBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tif (ptr->string) {\n\t\tgf_bs_write_data(bs, ptr->string, (u32) strlen(ptr->string) + 1);\n\t}\n\treturn GF_OK;\n}\nGF_Err name_box_size(GF_Box *s)\n{\n\tGF_NameBox *ptr = (GF_NameBox *)s;\n\tif (ptr->string) ptr->size += strlen(ptr->string) + 1;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid tssy_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\nGF_Err tssy_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TimeStampSynchronyBox *ptr = (GF_TimeStampSynchronyBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 1)\n\tgf_bs_read_int(bs, 6);\n\tptr->timestamp_sync = gf_bs_read_int(bs, 2);\n\treturn GF_OK;\n}\nGF_Box *tssy_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TimeStampSynchronyBox, GF_ISOM_BOX_TYPE_TSSY);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err tssy_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TimeStampSynchronyBox *ptr = (GF_TimeStampSynchronyBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_int(bs, 0, 6);\n\tgf_bs_write_int(bs, ptr->timestamp_sync, 2);\n\treturn GF_OK;\n}\nGF_Err tssy_box_size(GF_Box *s)\n{\n\ts->size += 1;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid srpp_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err srpp_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_SRTPProcessBox *ptr = (GF_SRTPProcessBox *)s;\n\tswitch(a->type) {\n\tcase GF_ISOM_BOX_TYPE_SCHI:\n\t\tBOX_FIELD_ASSIGN(info, GF_SchemeInformationBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_SCHM:\n\t\tBOX_FIELD_ASSIGN(scheme_type, GF_SchemeTypeBox)\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err srpp_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_SRTPProcessBox *ptr = (GF_SRTPProcessBox *)s;\n\n\tISOM_DECREASE_SIZE(s, 16)\n\tptr->encryption_algorithm_rtp = gf_bs_read_u32(bs);\n\tptr->encryption_algorithm_rtcp = gf_bs_read_u32(bs);\n\tptr->integrity_algorithm_rtp = gf_bs_read_u32(bs);\n\tptr->integrity_algorithm_rtcp = gf_bs_read_u32(bs);\n\treturn gf_isom_box_array_read(s, bs);\n}\nGF_Box *srpp_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SRTPProcessBox, GF_ISOM_BOX_TYPE_SRPP);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err srpp_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SRTPProcessBox *ptr = (GF_SRTPProcessBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->encryption_algorithm_rtp);\n\tgf_bs_write_u32(bs, ptr->encryption_algorithm_rtcp);\n\tgf_bs_write_u32(bs, ptr->integrity_algorithm_rtp);\n\tgf_bs_write_u32(bs, ptr->integrity_algorithm_rtcp);\n\n\treturn GF_OK;\n}\nGF_Err srpp_box_size(GF_Box *s)\n{\n\tu32 pos = 0;\n\tGF_SRTPProcessBox *ptr = (GF_SRTPProcessBox *)s;\n\ts->size += 16;\n\tgf_isom_check_position(s, (GF_Box*)ptr->info, &pos);\n\tgf_isom_check_position(s, (GF_Box*)ptr->scheme_type, &pos);\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid rssr_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\nGF_Err rssr_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_ReceivedSsrcBox *ptr = (GF_ReceivedSsrcBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4)\n\tptr->ssrc = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\nGF_Box *rssr_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ReceivedSsrcBox, GF_ISOM_BOX_TYPE_RSSR);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err rssr_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ReceivedSsrcBox *ptr = (GF_ReceivedSsrcBox *)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->ssrc);\n\treturn GF_OK;\n}\nGF_Err rssr_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n\nvoid iods_box_del(GF_Box *s)\n{\n\tGF_ObjectDescriptorBox *ptr = (GF_ObjectDescriptorBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->descriptor) gf_odf_desc_del(ptr->descriptor);\n\tgf_free(ptr);\n}\n\n\nGF_Err iods_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 descSize;\n\tchar *desc;\n\tGF_ObjectDescriptorBox *ptr = (GF_ObjectDescriptorBox *)s;\n\n\t//use the OD codec...\n\tdescSize = (u32) (ptr->size);\n\tdesc = (char*)gf_malloc(sizeof(char) * descSize);\n\tif (!desc) return GF_OUT_OF_MEM;\n\n\tgf_bs_read_data(bs, desc, descSize);\n\te = gf_odf_desc_read(desc, descSize, &ptr->descriptor);\n\t//OK, free our desc\n\tgf_free(desc);\n\n\tif (e) return e;\n\tswitch (ptr->descriptor->tag) {\n\tcase GF_ODF_ISOM_OD_TAG:\n\tcase GF_ODF_ISOM_IOD_TAG:\n\t\tbreak;\n\tdefault:\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid descriptor in iods, tag %u found but only %u or %u allowed\\n\", ptr->descriptor->tag, GF_ODF_ISOM_IOD_TAG, GF_ODF_ISOM_OD_TAG ));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *iods_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ObjectDescriptorBox, GF_ISOM_BOX_TYPE_IODS);\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err iods_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 descSize;\n\tu8 *desc;\n\tGF_ObjectDescriptorBox *ptr = (GF_ObjectDescriptorBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\t//call our OD codec\n\te = gf_odf_desc_write(ptr->descriptor, &desc, &descSize);\n\tif (e) return e;\n\tgf_bs_write_data(bs, desc, descSize);\n\t//and free our stuff maybe!!\n\tgf_free(desc);\n\treturn GF_OK;\n}\n\nGF_Err iods_box_size(GF_Box *s)\n{\n\tGF_ObjectDescriptorBox *ptr = (GF_ObjectDescriptorBox *)s;\n\n\tptr->size += gf_odf_desc_size(ptr->descriptor);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid mdat_box_del(GF_Box *s)\n{\n\tGF_MediaDataBox *ptr = (GF_MediaDataBox *)s;\n\tif (!s) return;\n\n\tif (ptr->data) gf_free(ptr->data);\n\tgf_free(ptr);\n}\n\n\nGF_Err mdat_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MediaDataBox *ptr = (GF_MediaDataBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\tif (ptr->type==GF_ISOM_BOX_TYPE_IMDA) {\n\t\tptr->type = GF_ISOM_BOX_TYPE_MDAT;\n\t\tptr->is_imda = 1;\n\t\tISOM_DECREASE_SIZE(s, 4)\n\t\tptr->imda_id = gf_bs_read_u32(bs);\n\t}\n\n\tptr->dataSize = s->size;\n\tptr->bsOffset = gf_bs_get_position(bs);\n\n\t//store idat for rewrite\n\tif (ptr->type==GF_ISOM_BOX_TYPE_IDAT) {\n\t\tptr->data = gf_malloc(sizeof(u8) * (size_t)ptr->dataSize);\n\t\tif (!ptr->data) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->data, (u32) ptr->dataSize);\n\t\tptr->size = 0;\n\t\treturn GF_OK;\n\t}\n\n\t//then skip these bytes\n\tgf_bs_skip_bytes(bs, ptr->dataSize);\n\treturn GF_OK;\n}\n\nGF_Box *mdat_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MediaDataBox, GF_ISOM_BOX_TYPE_MDAT);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err mdat_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MediaDataBox *ptr = (GF_MediaDataBox *)s;\n\tif (ptr->is_imda) {\n\t\ts->type = GF_ISOM_BOX_TYPE_IMDA;\n\t\te = gf_isom_box_write_header(s, bs);\n\t\ts->type = GF_ISOM_BOX_TYPE_MDAT;\n\t\tif (e) return e;\n\t\tgf_bs_write_u32(bs, ptr->imda_id);\n\t} else {\n\t\te = gf_isom_box_write_header(s, bs);\n\t\tif (e) return e;\n\t}\n\n\t//make sure we have some data ...\n\t//if not, we handle that independently (edit files)\n\tif (ptr->data) {\n\t\tgf_bs_write_data(bs, ptr->data, (u32) ptr->dataSize);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err mdat_box_size(GF_Box *s)\n{\n\tGF_MediaDataBox *ptr = (GF_MediaDataBox *)s;\n\tptr->size += ptr->dataSize;\n\tif (ptr->is_imda)\n\t\tptr->size += 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid mdhd_box_del(GF_Box *s)\n{\n\tGF_MediaHeaderBox *ptr = (GF_MediaHeaderBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n// Mapping of QuickTime old language codes\n// https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap4/qtff4.html#//apple_ref/doc/uid/TP40000939-CH206-34320\n// to 3-letter codes (per ISO/IEC 639-2/T, https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes)\n// NOTE that Media Info maps them to 2-letter codes, possibly with region codes https://github.com/MediaArea/MediaInfoLib/blob/72213574cbf2ca01c0fbb97d2239b53891ad7b9d/Source/MediaInfo/Multiple/File_Mpeg4.cpp#L754\n// NOTE that FFMPEG mostly maps to ISO/IEC 639-2/B and sometimes 2-letter code\n// (see https://ffmpeg.org/doxygen/trunk/isom_8c_source.html)\nstatic const char* qtLanguages[] = {\n\t\"eng\", //  0 English\n\t\"fra\", //  1 French\n\t\"deu\", //  2 German\n\t\"ita\", //  3 Italian\n\t\"nld\", //  4 Dutch\n\t\"swe\", //  5 Swedish\n\t\"spa\", //  6 Spanish\n\t\"dan\", //  7 Danish\n\t\"por\", //  8 Portuguese\n\t\"nor\", //  9 Norwegian\n\t\"heb\", // 10 Hebrew\n\t\"jpn\", // 11 Japanese\n\t\"ara\", // 12 Arabic\n\t\"fin\", // 13 Finnish\n\t\"ell\", // 14 Greek\n\t\"isl\", // 15 Icelandic\n\t\"mlt\", // 16 Maltese\n\t\"tur\", // 17 Turkish\n\t\"hrv\", // 18 Croatian\n\t\"zho\", // 19 Traditional Chinese - general 3-letter code, ignoring the \"Traditional\" part\n\t\"urd\", // 20 Urdu\n\t\"hin\", // 21 Hindi\n\t\"tha\", // 22 Thai\n\t\"kor\", // 23 Korean\n\t\"lit\", // 24 Lithuanian\n\t\"pol\", // 25 Polish\n\t\"hun\", // 26 Hungarian\n\t\"est\", // 27 Estonian\n\t\"lav\", // 28 Lettish or Latvian\n\t\"sme\", // 29 Saami or Sami\n\t\"fao\", // 30 Faroese\n\t\"fas\", // 31 Farsi\n\t\"rus\", // 32 Russian\n\t\"zho\", // 33 Simplified Chinese - general 3-letter code, ignoring the \"Simplified\" part\n\t\"nld\", // 34 Flemish - using same code as Dutch\n\t\"gle\", // 35 Irish\n\t\"sqi\", // 36 Albanian\n\t\"ron\", // 37 Romanian\n\t\"ces\", // 38 Czech\n\t\"slk\", // 39 Slovak\n\t\"slv\", // 40 Slovenian\n\t\"yid\", // 41 Yiddish\n\t\"srp\", // 42 Serbian\n\t\"mkd\", // 43 Macedonian\n\t\"bul\", // 44 Bulgarian\n\t\"ukr\", // 45 Ukrainian\n\t\"bel\", // 46 Belarusian\n\t\"uzb\", // 47 Uzbek\n\t\"kaz\", // 48 Kazakh\n\t\"aze\", // 49 Azerbaijani\n\t\"aze\", // 50 AzerbaijanAr (Armenian-Azerbaijani) - using same code as Azerbaijani\n\t\"hye\", // 51 Armenian\n\t\"kat\", // 52 Georgian\n\t\"ron\", // 53 Moldavian\n\t\"kir\", // 54 Kirghiz\n\t\"tgk\", // 55 Tajik\n\t\"tuk\", // 56 Turkmen\n\t\"mon\", // 57 Mongolian\n\t\"mon\", // 58 MongolianCyr - using same code as Mongolian\n\t\"pus\", // 59 Pashto\n\t\"kur\", // 60 Kurdish\n\t\"kas\", // 61 Kashmiri\n\t\"snd\", // 62 Sindhi\n\t\"bod\", // 63 Tibetan\n\t\"nep\", // 64 Nepali\n\t\"san\", // 65 Sanskrit\n\t\"mar\", // 66 Marathi\n\t\"ben\", // 67 Bengali\n\t\"asm\", // 68 Assamese\n\t\"guj\", // 69 Gujarati\n\t\"pan\", // 70 Punjabi\n\t\"ori\", // 71 Oriya\n\t\"mal\", // 72 Malayalam\n\t\"kan\", // 73 Kannada\n\t\"tam\", // 74 Tamil\n\t\"tel\", // 75 Telugu\n\t\"sin\", // 76 Sinhala\n\t\"mya\", // 77 Burmese\n\t\"khm\", // 78 Khmer\n\t\"lao\", // 79 Lao\n\t\"vie\", // 80 Vietnamese\n\t\"ind\", // 81 Indonesian\n\t\"tgl\", // 82 Tagalog\n\t\"msa\", // 83 MalayRoman\n\t\"msa\", // 84 MalayArabic\n\t\"amh\", // 85 Amharic\n\t\"   \", // 86 Empty\n\t\"orm\", // 87 Oromo\n\t\"som\", // 88 Somali\n\t\"swa\", // 89 Swahili\n\t\"kin\", // 90 Kinyarwanda\n\t\"run\", // 91 Rundi\n\t\"nya\", // 92 Nyanja\n\t\"mlg\", // 93 Malagasy\n\t\"epo\", // 94 Esperanto\n\t// Gap 95-127\n\t\"cym\", // 128 Welsh\n\t\"eus\", // 129 Basque\n\t\"cat\", // 130 Catalan\n\t\"lat\", // 131 Latin\n\t\"que\", // 132 Quechua\n\t\"grn\", // 133 Guarani\n\t\"aym\", // 134 Aymara\n\t\"tat\", // 135 Tatar\n\t\"uig\", // 136 Uighur\n\t\"dzo\", // 127 Dzongkha\n\t\"jav\"  // 138 Javanese\n};\n//static const u8 qtLanguagesSize = GF_ARRAY_LENGTH(qtLanguages);\n\nGF_Err set_quicktime_lang(char lang[4], u8 code) {\n\tif (code > 138 || (code > 94 && code < 128) || code == 86) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid QuickTime Language Code %d\\n\", code));\n\t\treturn GF_BAD_PARAM;\n\t}\n\tif (code > 94)\n\t\tcode -=(128-94); // Gap in the list\n\tlang[0] = qtLanguages[code][0];\n\tlang[1] = qtLanguages[code][1];\n\tlang[2] = qtLanguages[code][2];\n\tlang[3] = qtLanguages[code][3];\n\treturn GF_OK;\n}\n\nGF_Err mdhd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MediaHeaderBox *ptr = (GF_MediaHeaderBox *)s;\n\n\tif (ptr->version == 1) {\n\t\tISOM_DECREASE_SIZE(ptr, 28)\n\t\tptr->creationTime = gf_bs_read_u64(bs);\n\t\tptr->modificationTime = gf_bs_read_u64(bs);\n\t\tptr->timeScale = gf_bs_read_u32(bs);\n\t\tptr->duration = gf_bs_read_u64(bs);\n\t} else {\n\t\tISOM_DECREASE_SIZE(ptr, 16)\n\t\tptr->creationTime = gf_bs_read_u32(bs);\n\t\tptr->modificationTime = gf_bs_read_u32(bs);\n\t\tptr->timeScale = gf_bs_read_u32(bs);\n\t\tptr->duration = gf_bs_read_u32(bs);\n\t}\n\tif (!ptr->timeScale) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Media header timescale is 0 - defaulting to 90000\\n\" ));\n\t\tptr->timeScale = 90000;\n\t}\n\n\tptr->original_duration = ptr->duration;\n\n\tISOM_DECREASE_SIZE(ptr, 4)\n\t//our padding bit\n\tgf_bs_read_int(bs, 1);\n\t//the spec is unclear here, just says \"the value 0 is interpreted as undetermined\"\n\tptr->packedLanguage[0] = gf_bs_read_int(bs, 5);\n\tptr->packedLanguage[1] = gf_bs_read_int(bs, 5);\n\tptr->packedLanguage[2] = gf_bs_read_int(bs, 5);\n\t//but before or after compaction ?? We assume before\n\tif (ptr->packedLanguage[0] || ptr->packedLanguage[1] || ptr->packedLanguage[2]) {\n\t\tif (ptr->packedLanguage[0] < 0x04) {\n\t\t\t// QuickTime Language Codes\n\t\t\tu8 code = (ptr->packedLanguage[0] << 16) | (ptr->packedLanguage[1] << 8) | ptr->packedLanguage[2];\n\t\t\tset_quicktime_lang(ptr->packedLanguage, code);\n\t\t} else {\n\t\t\tptr->packedLanguage[0] += 0x60;\n\t\t\tptr->packedLanguage[1] += 0x60;\n\t\t\tptr->packedLanguage[2] += 0x60;\n\t\t}\n\t} else {\n\t\tptr->packedLanguage[0] = 'u';\n\t\tptr->packedLanguage[1] = 'n';\n\t\tptr->packedLanguage[2] = 'd';\n\t}\n\tptr->reserved = gf_bs_read_u16(bs);\n\treturn GF_OK;\n}\n\nGF_Box *mdhd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MediaHeaderBox, GF_ISOM_BOX_TYPE_MDHD);\n\n\ttmp->packedLanguage[0] = 'u';\n\ttmp->packedLanguage[1] = 'n';\n\ttmp->packedLanguage[2] = 'd';\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err mdhd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MediaHeaderBox *ptr = (GF_MediaHeaderBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tif (ptr->version == 1) {\n\t\tgf_bs_write_u64(bs, ptr->creationTime);\n\t\tgf_bs_write_u64(bs, ptr->modificationTime);\n\t\tgf_bs_write_u32(bs, ptr->timeScale);\n\t\tgf_bs_write_u64(bs, ptr->duration);\n\t} else {\n\t\tgf_bs_write_u32(bs, (u32) ptr->creationTime);\n\t\tgf_bs_write_u32(bs, (u32) ptr->modificationTime);\n\t\tgf_bs_write_u32(bs, ptr->timeScale);\n\t\tgf_bs_write_u32(bs, (u32) ptr->duration);\n\t}\n\t//SPECS: BIT(1) of padding\n\tgf_bs_write_int(bs, 0, 1);\n\tgf_bs_write_int(bs, ptr->packedLanguage[0] - 0x60, 5);\n\tgf_bs_write_int(bs, ptr->packedLanguage[1] - 0x60, 5);\n\tgf_bs_write_int(bs, ptr->packedLanguage[2] - 0x60, 5);\n\tgf_bs_write_u16(bs, ptr->reserved);\n\treturn GF_OK;\n}\n\nGF_Err mdhd_box_size(GF_Box *s)\n{\n\tGF_MediaHeaderBox *ptr = (GF_MediaHeaderBox *)s;\n\tptr->version = (ptr->duration>0xFFFFFFFF) ? 1 : 0;\n\n\tptr->size += 4;\n\tptr->size += (ptr->version == 1) ? 28 : 16;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid mdia_box_del(GF_Box *s)\n{\n\tGF_MediaBox *ptr = (GF_MediaBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->nalu_parser) gf_bs_del(ptr->nalu_parser);\n\tif (ptr->nalu_out_bs) gf_bs_del(ptr->nalu_out_bs);\n\tif (ptr->nalu_ps_bs) gf_bs_del(ptr->nalu_ps_bs);\n\tif (ptr->extracted_bs) gf_bs_del(ptr->extracted_bs);\n\tif (ptr->extracted_samp) gf_isom_sample_del(&ptr->extracted_samp);\n\tif (ptr->in_sample_buffer) gf_free(ptr->in_sample_buffer);\n\tif (ptr->tmp_nal_copy_buffer) gf_free(ptr->tmp_nal_copy_buffer);\n\tgf_free(ptr);\n}\n\n\nGF_Err mdia_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_MediaBox *ptr = (GF_MediaBox *)s;\n\tswitch(a->type) {\n\tcase GF_ISOM_BOX_TYPE_MDHD:\n\t\tBOX_FIELD_ASSIGN(mediaHeader, GF_MediaHeaderBox)\n\t\treturn GF_OK;\n\n\tcase GF_ISOM_BOX_TYPE_HDLR:\n\t\tBOX_FIELD_ASSIGN(handler, GF_HandlerBox)\n\t\treturn GF_OK;\n\n\tcase GF_ISOM_BOX_TYPE_MINF:\n\t\tBOX_FIELD_ASSIGN(information, GF_MediaInformationBox)\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err mdia_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu64 cookie = gf_bs_get_cookie(bs);\n\tcookie &= ~GF_ISOM_BS_COOKIE_VISUAL_TRACK;\n\tgf_bs_set_cookie(bs, cookie);\n\te = gf_isom_box_array_read(s, bs);\n\tgf_bs_set_cookie(bs, cookie);\n\n\tif (e) return e;\n\tif (!((GF_MediaBox *)s)->information) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing MediaInformationBox\\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tif (!((GF_MediaBox *)s)->handler) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing HandlerBox\\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tif (!((GF_MediaBox *)s)->mediaHeader) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing MediaHeaderBox\\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *mdia_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MediaBox, GF_ISOM_BOX_TYPE_MDIA);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err mdia_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err mdia_box_size(GF_Box *s)\n{\n\tu32 pos = 0;\n\tGF_MediaBox *ptr = (GF_MediaBox *)s;\n\t//Header first\n\tgf_isom_check_position(s, (GF_Box*)ptr->mediaHeader, &pos);\n\t//then handler\n\tgf_isom_check_position(s, (GF_Box*)ptr->handler, &pos);\n\n#if 0\n\t//elng before info for CMAF info - we deactiveate for now, no specific errors raised and CMAF should not impose any order\n\tGF_Box *elng = gf_isom_box_find_child(ptr->child_boxes, GF_ISOM_BOX_TYPE_ELNG);\n\tif (elng)\n\t\tgf_isom_check_position(s, elng, &pos);\n#endif\n\n\t//then info\n\tgf_isom_check_position(s, (GF_Box*)ptr->information, &pos);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid mfra_box_del(GF_Box *s)\n{\n\tGF_MovieFragmentRandomAccessBox *ptr = (GF_MovieFragmentRandomAccessBox *)s;\n\tif (ptr == NULL) return;\n\tgf_list_del(ptr->tfra_list);\n\tgf_free(ptr);\n}\n\nGF_Box *mfra_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MovieFragmentRandomAccessBox, GF_ISOM_BOX_TYPE_MFRA);\n\ttmp->tfra_list = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\nGF_Err mfra_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_MovieFragmentRandomAccessBox *ptr = (GF_MovieFragmentRandomAccessBox *)s;\n\tswitch(a->type) {\n\tcase GF_ISOM_BOX_TYPE_TFRA:\n\t\tBOX_FIELD_LIST_ASSIGN(tfra_list);\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_MFRO:\n\t\tBOX_FIELD_ASSIGN(mfro, GF_MovieFragmentRandomAccessOffsetBox)\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err mfra_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err mfra_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err mfra_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_MovieFragmentRandomAccessBox *ptr = (GF_MovieFragmentRandomAccessBox *)s;\n\tgf_isom_check_position_list(s, ptr->tfra_list, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->mfro, &pos);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid tfra_box_del(GF_Box *s)\n{\n\tGF_TrackFragmentRandomAccessBox *ptr = (GF_TrackFragmentRandomAccessBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);\n}\n\nGF_Box *tfra_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackFragmentRandomAccessBox, GF_ISOM_BOX_TYPE_TFRA);\n\treturn (GF_Box *)tmp;\n}\n\nGF_Err tfra_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_RandomAccessEntry *p = 0;\n\tGF_TrackFragmentRandomAccessBox *ptr = (GF_TrackFragmentRandomAccessBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 12);\n\n\tptr->track_id = gf_bs_read_u32(bs);\n\tif (gf_bs_read_int(bs, 26) != 0)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tptr->traf_bits = (gf_bs_read_int(bs, 2) + 1) * 8;\n\tptr->trun_bits = (gf_bs_read_int(bs, 2) + 1) * 8;\n\tptr->sample_bits = (gf_bs_read_int(bs, 2) + 1) * 8;\n\n\tptr->nb_entries = gf_bs_read_u32(bs);\n\n\tif (ptr->version == 1) {\n\t\tif (ptr->nb_entries > ptr->size / (16+(ptr->traf_bits+ptr->trun_bits+ptr->sample_bits)/8)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in traf\\n\", ptr->nb_entries));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t} else {\n\t\tif (ptr->nb_entries > ptr->size / (8+(ptr->traf_bits+ptr->trun_bits+ptr->sample_bits)/8)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in traf\\n\", ptr->nb_entries));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t}\n\n\tif (ptr->nb_entries) {\n\t\tif ((u64)ptr->nb_entries > (u64)SIZE_MAX/sizeof(GF_RandomAccessEntry)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in traf\\n\", ptr->nb_entries));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t\tp = (GF_RandomAccessEntry *) gf_malloc(sizeof(GF_RandomAccessEntry) * ptr->nb_entries);\n\t\tif (!p) return GF_OUT_OF_MEM;\n\t}\n\n\tptr->entries = p;\n\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tmemset(p, 0, sizeof(GF_RandomAccessEntry));\n\n\t\tif (ptr->version == 1) {\n\t\t\tp->time = gf_bs_read_u64(bs);\n\t\t\tp->moof_offset = gf_bs_read_u64(bs);\n\t\t} else {\n\t\t\tp->time = gf_bs_read_u32(bs);\n\t\t\tp->moof_offset = gf_bs_read_u32(bs);\n\t\t}\n\t\tp->traf_number = gf_bs_read_int(bs, ptr->traf_bits);\n\t\tp->trun_number = gf_bs_read_int(bs, ptr->trun_bits);\n\t\tp->sample_number = gf_bs_read_int(bs, ptr->sample_bits);\n\n\t\t++p;\n\t}\n\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err tfra_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i, sap_nb_entries;\n\tGF_TrackFragmentRandomAccessBox *ptr = (GF_TrackFragmentRandomAccessBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->track_id);\n\tgf_bs_write_int(bs, 0, 26);\n\n\tgf_bs_write_int(bs, ptr->traf_bits/8 - 1, 2);\n\tgf_bs_write_int(bs, ptr->trun_bits/8 - 1, 2);\n\tgf_bs_write_int(bs, ptr->sample_bits/8 - 1, 2);\n\n\tsap_nb_entries = 0;\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tGF_RandomAccessEntry *p = &ptr->entries[i];\n\t\t//no sap found, do not store\n\t\tif (p->trun_number) sap_nb_entries++;\n\t}\n\n\tgf_bs_write_u32(bs, sap_nb_entries);\n\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tGF_RandomAccessEntry *p = &ptr->entries[i];\n\t\t//no sap found, do not store\n\t\tif (!p->trun_number) continue;\n\t\tif (ptr->version==1) {\n\t\t\tgf_bs_write_u64(bs, p->time);\n\t\t\tgf_bs_write_u64(bs, p->moof_offset);\n\t\t} else {\n\t\t\tgf_bs_write_u32(bs, (u32) p->time);\n\t\t\tgf_bs_write_u32(bs, (u32) p->moof_offset);\n\t\t}\n\t\tgf_bs_write_int(bs, p->traf_number, ptr->traf_bits);\n\t\tgf_bs_write_int(bs, p->trun_number, ptr->trun_bits);\n\t\tgf_bs_write_int(bs, p->sample_number, ptr->sample_bits);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err tfra_box_size(GF_Box *s)\n{\n\tu32 i;\n\tGF_TrackFragmentRandomAccessBox *ptr = (GF_TrackFragmentRandomAccessBox *)s;\n\tptr->size += 12;\n\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tGF_RandomAccessEntry *p = &ptr->entries[i];\n\t\t//no sap found, do not store\n\t\tif (!p->trun_number) continue;\n\t\tptr->size +=  ((ptr->version==1) ? 16 : 8 ) + ptr->traf_bits/8 + ptr->trun_bits/8 + ptr->sample_bits/8;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid mfro_box_del(GF_Box *s)\n{\n\tGF_MovieFragmentRandomAccessOffsetBox *ptr = (GF_MovieFragmentRandomAccessOffsetBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\nGF_Box *mfro_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MovieFragmentRandomAccessOffsetBox, GF_ISOM_BOX_TYPE_MFRO);\n\treturn (GF_Box *)tmp;\n}\n\nGF_Err mfro_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MovieFragmentRandomAccessOffsetBox *ptr = (GF_MovieFragmentRandomAccessOffsetBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->container_size = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err mfro_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MovieFragmentRandomAccessOffsetBox *ptr = (GF_MovieFragmentRandomAccessOffsetBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->container_size);\n\treturn GF_OK;\n}\n\nGF_Err mfro_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid elng_box_del(GF_Box *s)\n{\n\tGF_ExtendedLanguageBox *ptr = (GF_ExtendedLanguageBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->extended_language) gf_free(ptr->extended_language);\n\tgf_free(ptr);\n}\n\nGF_Err elng_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_ExtendedLanguageBox *ptr = (GF_ExtendedLanguageBox *)s;\n\n\tif (ptr->size) {\n\t\tptr->extended_language = (char*)gf_malloc((u32) ptr->size);\n\t\tif (ptr->extended_language == NULL) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->extended_language, (u32) ptr->size);\n\t\t/*safety check in case the string is not null-terminated*/\n\t\tif (ptr->extended_language[ptr->size-1]) {\n\t\t\tchar *str = (char*)gf_malloc((u32) ptr->size + 1);\n\t\t\tif (!str) return GF_OUT_OF_MEM;\n\t\t\tmemcpy(str, ptr->extended_language, (u32) ptr->size);\n\t\t\tstr[ptr->size] = 0;\n\t\t\tgf_free(ptr->extended_language);\n\t\t\tptr->extended_language = str;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *elng_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MediaBox, GF_ISOM_BOX_TYPE_ELNG);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err elng_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ExtendedLanguageBox *ptr = (GF_ExtendedLanguageBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tif (ptr->extended_language) {\n\t\tgf_bs_write_data(bs, ptr->extended_language, (u32)(strlen(ptr->extended_language)+1));\n\t}\n\treturn GF_OK;\n}\n\nGF_Err elng_box_size(GF_Box *s)\n{\n\tGF_ExtendedLanguageBox *ptr = (GF_ExtendedLanguageBox *)s;\n\n\tif (ptr->extended_language) {\n\t\tptr->size += strlen(ptr->extended_language)+1;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\nvoid mfhd_box_del(GF_Box *s)\n{\n\tGF_MovieFragmentHeaderBox *ptr = (GF_MovieFragmentHeaderBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\nGF_Err mfhd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MovieFragmentHeaderBox *ptr = (GF_MovieFragmentHeaderBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->sequence_number = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\nGF_Box *mfhd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MovieFragmentHeaderBox, GF_ISOM_BOX_TYPE_MFHD);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err mfhd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MovieFragmentHeaderBox *ptr = (GF_MovieFragmentHeaderBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->sequence_number);\n\treturn GF_OK;\n}\n\nGF_Err mfhd_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n\n\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM_FRAGMENTS*/\n\n\nvoid minf_box_del(GF_Box *s)\n{\n\tGF_MediaInformationBox *ptr = (GF_MediaInformationBox *)s;\n\tif (ptr == NULL) return;\n\n\t//if we have a Handler not self-contained, delete it (the self-contained belongs to the movie)\n\tif (ptr->dataHandler) {\n\t\tgf_isom_datamap_close(ptr);\n\t}\n\tgf_free(ptr);\n}\n\nGF_Err minf_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_MediaInformationBox *ptr = (GF_MediaInformationBox *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_NMHD:\n\tcase GF_ISOM_BOX_TYPE_STHD:\n\tcase GF_ISOM_BOX_TYPE_VMHD:\n\tcase GF_ISOM_BOX_TYPE_SMHD:\n\tcase GF_ISOM_BOX_TYPE_HMHD:\n\tcase GF_ISOM_BOX_TYPE_GMHD:\n\t\tBOX_FIELD_ASSIGN(InfoHeader, GF_Box)\n\t\treturn GF_OK;\n\n\tcase GF_ISOM_BOX_TYPE_DINF:\n\t\tBOX_FIELD_ASSIGN(dataInformation, GF_DataInformationBox)\n\t\treturn GF_OK;\n\n\tcase GF_ISOM_BOX_TYPE_STBL:\n\t\tBOX_FIELD_ASSIGN(sampleTable, GF_SampleTableBox)\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err minf_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MediaInformationBox *ptr = (GF_MediaInformationBox *)s;\n\tGF_Err e;\n\n\te = gf_isom_box_array_read(s, bs);\n\n\tif (!e && ! ptr->dataInformation) {\n\t\tGF_Box *url;\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing DataInformationBox\\n\"));\n\t\t//commented on purpose, we are still able to handle the file, we only throw an error but keep processing\n//\t\te = GF_ISOM_INVALID_FILE;\n\n\t\t//add a dinf box to avoid any access to a null dinf\n\t\tptr->dataInformation = (GF_DataInformationBox *) gf_isom_box_new_parent(&ptr->child_boxes, GF_ISOM_BOX_TYPE_DINF);\n\t\tif (!ptr->dataInformation) return GF_OUT_OF_MEM;\n\n\t\tptr->dataInformation->dref = (GF_DataReferenceBox *) gf_isom_box_new_parent(&ptr->dataInformation->child_boxes, GF_ISOM_BOX_TYPE_DREF);\n\t\tif (!ptr->dataInformation->dref) return GF_OUT_OF_MEM;\n\n\t\turl = gf_isom_box_new_parent(&ptr->dataInformation->dref->child_boxes, GF_ISOM_BOX_TYPE_URL);\n\t\tif (!url) return GF_OUT_OF_MEM;\n\t\t((GF_FullBox*)url)->flags = 1;\n\t}\n\treturn e;\n}\n\nGF_Box *minf_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MediaInformationBox, GF_ISOM_BOX_TYPE_MINF);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err minf_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err minf_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_MediaInformationBox *ptr = (GF_MediaInformationBox *)s;\n\t//Header first\n\tgf_isom_check_position(s, (GF_Box *)ptr->InfoHeader, &pos);\n\t//then dataInfo\n\tgf_isom_check_position(s, (GF_Box *)ptr->dataInformation, &pos);\n\tgf_isom_check_position(s, gf_isom_box_find_child(s->child_boxes, GF_ISOM_BOX_TYPE_MVCI), &pos);\n\t//then sampleTable\n\tgf_isom_check_position(s, (GF_Box *)ptr->sampleTable, &pos);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\nvoid moof_box_del(GF_Box *s)\n{\n\tGF_MovieFragmentBox *ptr = (GF_MovieFragmentBox *)s;\n\tif (ptr == NULL) return;\n\n\tgf_list_del(ptr->TrackList);\n\tif (ptr->PSSHs) gf_list_del(ptr->PSSHs);\n\tif (ptr->mdat) gf_free(ptr->mdat);\n\t//happens if error while fragmenting, the emsg boxes are not part of the moof hierarchy !\n\tif (ptr->emsgs) {\n\t\twhile (1) {\n\t\t\tGF_Box *emsg = gf_list_pop_front(ptr->emsgs);\n\t\t\tif (!emsg) break;\n\t\t\tgf_isom_box_del(emsg);\n\t\t}\n\t\tgf_list_del(ptr->emsgs);\n\t}\n\tgf_list_del(ptr->trun_list);\n\tgf_free(ptr);\n}\n\nGF_Err moof_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_MovieFragmentBox *ptr = (GF_MovieFragmentBox *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_MFHD:\n\t\tBOX_FIELD_ASSIGN(mfhd, GF_MovieFragmentHeaderBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_TRAF:\n\t\tBOX_FIELD_LIST_ASSIGN(TrackList)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_PSSH:\n\t\tBOX_FIELD_LIST_ASSIGN(PSSHs)\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err moof_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *moof_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MovieFragmentBox, GF_ISOM_BOX_TYPE_MOOF);\n\ttmp->TrackList = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err moof_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err moof_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_MovieFragmentBox *ptr = (GF_MovieFragmentBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\t//Header First\n\tgf_isom_check_position(s, (GF_Box *)ptr->mfhd, &pos);\n\t//then PSSH\n\tgf_isom_check_position_list(s, ptr->PSSHs, &pos);\n\t//then the track list\n\tgf_isom_check_position_list(s, ptr->TrackList, &pos);\n\treturn GF_OK;\n}\n\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM_FRAGMENTS*/\n\nvoid moov_box_del(GF_Box *s)\n{\n\tGF_MovieBox *ptr = (GF_MovieBox *)s;\n\tif (ptr == NULL) return;\n\tgf_list_del(ptr->trackList);\n\tgf_free(ptr);\n}\n\nGF_Err moov_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_MovieBox *ptr = (GF_MovieBox *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_IODS:\n\t\tBOX_FIELD_ASSIGN(iods, GF_ObjectDescriptorBox)\n\t\t//if no IOD, delete the box\n\t\tif (ptr->iods && !ptr->iods->descriptor) {\n\t\t\tptr->iods = NULL;\n\t\t\tgf_isom_box_del_parent(&s->child_boxes, a);\n\t\t}\n\t\treturn GF_OK;\n\n\tcase GF_ISOM_BOX_TYPE_MVHD:\n\t\tBOX_FIELD_ASSIGN(mvhd, GF_MovieHeaderBox)\n\t\treturn GF_OK;\n\n\tcase GF_ISOM_BOX_TYPE_UDTA:\n\t\tBOX_FIELD_ASSIGN(udta, GF_UserDataBox)\n\t\treturn GF_OK;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tcase GF_ISOM_BOX_TYPE_MVEX:\n\t\tBOX_FIELD_ASSIGN(mvex, GF_MovieExtendsBox)\n\t\tif (ptr->mvex)\n\t\t\tptr->mvex->mov = ptr->mov;\n\t\treturn GF_OK;\n#endif\n\n\tcase GF_ISOM_BOX_TYPE_META:\n\t\tBOX_FIELD_ASSIGN(meta, GF_MetaBox)\n\t\treturn GF_OK;\n\n\tcase GF_ISOM_BOX_TYPE_TRAK:\n\t\tif (is_rem) {\n\t\t\tgf_list_del_item(ptr->trackList, a);\n\t\t\treturn GF_OK;\n\t\t}\n\t\t{\n\t\t\tGF_TrackBox *tk = (GF_TrackBox *)a;\n\t\t\t//set our pointer to this obj\n\t\t\ttk->moov = ptr;\n\t\t\ttk->index = 1+gf_list_count(ptr->trackList);\n\t\t\tif (tk->References) {\n\t\t\t\tGF_TrackReferenceTypeBox *dpnd=NULL;\n\t\t\t\tTrack_FindRef(tk, GF_ISOM_REF_BASE, &dpnd);\n\t\t\t\tif (dpnd)\n\t\t\t\t\ttk->nb_base_refs = dpnd->trackIDCount;\n\t\t\t}\n\t\t}\n\t\treturn gf_list_add(ptr->trackList, a);\n\tcase GF_QT_BOX_TYPE_CMVD:\n\t\tptr->has_cmvd = GF_TRUE;\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err moov_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *moov_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MovieBox, GF_ISOM_BOX_TYPE_MOOV);\n\ttmp->trackList = gf_list_new();\n\tif (!tmp->trackList) {\n\t\tgf_free(tmp);\n\t\treturn NULL;\n\t}\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err moov_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err moov_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_MovieBox *ptr = (GF_MovieBox *)s;\n\n\tgf_isom_check_position(s, (GF_Box *) ptr->mvhd, &pos);\n\tgf_isom_check_position(s, (GF_Box *) ptr->iods, &pos);\n\tgf_isom_check_position(s, (GF_Box *) ptr->meta, &pos);\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (ptr->mvex && !ptr->mvex_after_traks) {\n\t\tgf_isom_check_position(s, (GF_Box *) ptr->mvex, &pos);\n\t}\n#endif\n\tgf_isom_check_position_list(s, ptr->trackList, &pos);\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (ptr->mvex && ptr->mvex_after_traks) {\n\t\tgf_isom_check_position(s, (GF_Box *) ptr->mvex, &pos);\n\t}\n#endif\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid audio_sample_entry_box_del(GF_Box *s)\n{\n\tGF_MPEGAudioSampleEntryBox *ptr = (GF_MPEGAudioSampleEntryBox *)s;\n\tif (ptr == NULL) return;\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)s);\n\tif (ptr->slc) gf_odf_desc_del((GF_Descriptor *)ptr->slc);\n\tgf_free(ptr);\n}\n\nGF_Err audio_sample_entry_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_UnknownBox *wave = NULL;\n\tBool drop_wave=GF_FALSE;\n\tGF_MPEGAudioSampleEntryBox *ptr = (GF_MPEGAudioSampleEntryBox *)s;\n\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_ESDS:\n\t\tBOX_FIELD_ASSIGN(esd, GF_ESDBox)\n\t\tptr->qtff_mode = GF_ISOM_AUDIO_QTFF_NONE;\n\t\tbreak;\n\n\tcase GF_ISOM_BOX_TYPE_DAMR:\n\tcase GF_ISOM_BOX_TYPE_DEVC:\n\tcase GF_ISOM_BOX_TYPE_DQCP:\n\tcase GF_ISOM_BOX_TYPE_DSMV:\n\t\tBOX_FIELD_ASSIGN(cfg_3gpp, GF_3GPPConfigBox)\n\t\t/*for 3GP config, remember sample entry type in config*/\n\t\tptr->cfg_3gpp->cfg.type = ptr->type;\n\t\tptr->qtff_mode = GF_ISOM_AUDIO_QTFF_NONE;\n\t\tbreak;\n\n\tcase GF_ISOM_BOX_TYPE_DOPS:\n\t\tBOX_FIELD_ASSIGN(cfg_opus, GF_OpusSpecificBox)\n\t\tptr->qtff_mode = GF_ISOM_AUDIO_QTFF_NONE;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_DAC3:\n\t\tBOX_FIELD_ASSIGN(cfg_ac3, GF_AC3ConfigBox)\n\t\tptr->qtff_mode = GF_ISOM_AUDIO_QTFF_NONE;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_DEC3:\n\t\tBOX_FIELD_ASSIGN(cfg_ac3, GF_AC3ConfigBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_DMLP:\n\t\tBOX_FIELD_ASSIGN(cfg_mlp, GF_TrueHDConfigBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MHAC:\n\t\tBOX_FIELD_ASSIGN(cfg_mha, GF_MHAConfigBox)\n\t\tptr->qtff_mode = GF_ISOM_AUDIO_QTFF_NONE;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_DFLA:\n\t\tBOX_FIELD_ASSIGN(cfg_flac, GF_FLACConfigBox)\n\t\tptr->qtff_mode = GF_ISOM_AUDIO_QTFF_NONE;\n\t\tbreak;\n\n\tcase GF_ISOM_BOX_TYPE_UNKNOWN:\n\t\twave = (GF_UnknownBox *)a;\n\t\t/*HACK for QT files: get the esds box from the track*/\n\t\tif (s->type == GF_ISOM_BOX_TYPE_MP4A) {\n\t\t\tif (is_rem) {\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\tif (ptr->esd) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\t//wave subboxes may have been properly parsed\n \t\t\tif ((wave->original_4cc == GF_QT_BOX_TYPE_WAVE) && gf_list_count(wave->child_boxes)) {\n \t\t\t\tu32 i;\n                for (i =0; i<gf_list_count(wave->child_boxes); i++) {\n                    GF_Box *inner_box = (GF_Box *)gf_list_get(wave->child_boxes, i);\n                    if (inner_box->type == GF_ISOM_BOX_TYPE_ESDS) {\n                        ptr->esd = (GF_ESDBox *)inner_box;\n \t\t\t\t\t\tif (ptr->qtff_mode & GF_ISOM_AUDIO_QTFF_CONVERT_FLAG) {\n                        \tgf_list_rem(a->child_boxes, i);\n                        \tdrop_wave=GF_TRUE;\n                        \tptr->compression_id = 0;\n                        \tgf_list_add(ptr->child_boxes, inner_box);\n\t\t\t\t\t\t}\n                    }\n                }\n\t\t\t\tif (drop_wave) {\n\t\t\t\t\tgf_isom_box_del_parent(&ptr->child_boxes, a);\n                \tptr->qtff_mode = GF_ISOM_AUDIO_QTFF_NONE;\n\t\t\t\t\tptr->version = 0;\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t}\n                ptr->qtff_mode = GF_ISOM_AUDIO_QTFF_ON_EXT_VALID;\n                return GF_OK;\n            }\n            gf_isom_box_del_parent(&ptr->child_boxes, a);\n            return GF_ISOM_INVALID_MEDIA;\n\n\t\t}\n \t\tptr->qtff_mode &= ~GF_ISOM_AUDIO_QTFF_CONVERT_FLAG;\n\n \t\tif ((wave->original_4cc == GF_QT_BOX_TYPE_WAVE) && gf_list_count(wave->child_boxes)) {\n\t\t\tptr->qtff_mode = GF_ISOM_AUDIO_QTFF_ON_NOEXT;\n\t\t}\n\t\treturn GF_OK;\n\tcase GF_QT_BOX_TYPE_WAVE:\n\t{\n\t\tu32 subtype = 0;\n\t\tGF_Box **cfg_ptr = NULL;\n\t\tif (s->type == GF_ISOM_BOX_TYPE_MP4A) {\n\t\t\tcfg_ptr = (GF_Box **) &ptr->esd;\n\t\t\tsubtype = GF_ISOM_BOX_TYPE_ESDS;\n\t\t}\n\t\telse if (s->type == GF_ISOM_BOX_TYPE_AC3) {\n\t\t\tcfg_ptr = (GF_Box **) &ptr->cfg_ac3;\n\t\t\tsubtype = GF_ISOM_BOX_TYPE_DAC3;\n\t\t}\n\t\telse if (s->type == GF_ISOM_BOX_TYPE_EC3) {\n\t\t\tcfg_ptr = (GF_Box **) &ptr->cfg_ac3;\n\t\t\tsubtype = GF_ISOM_BOX_TYPE_DEC3;\n\t\t}\n\t\telse if (s->type == GF_ISOM_BOX_TYPE_OPUS) {\n\t\t\tcfg_ptr = (GF_Box **) &ptr->cfg_opus;\n\t\t\tsubtype = GF_ISOM_BOX_TYPE_DOPS;\n\t\t}\n\t\telse if ((s->type == GF_ISOM_BOX_TYPE_MHA1)\n\t\t\t|| (s->type == GF_ISOM_BOX_TYPE_MHA2)\n\t\t\t|| (s->type == GF_ISOM_BOX_TYPE_MHM1)\n\t\t\t|| (s->type == GF_ISOM_BOX_TYPE_MHM2)\n\t\t) {\n\t\t\tcfg_ptr = (GF_Box **) &ptr->cfg_mha;\n\t\t\tsubtype = GF_ISOM_BOX_TYPE_MHAC;\n\t\t}\n\t\telse if (s->type == GF_ISOM_BOX_TYPE_MLPA) {\n\t\t\tcfg_ptr = (GF_Box **) &ptr->cfg_mlp;\n\t\t\tsubtype = GF_ISOM_BOX_TYPE_DMLP;\n\t\t}\n\n\t\tif (cfg_ptr) {\n\t\t\tif (is_rem) {\n\t\t\t\t*cfg_ptr = NULL;\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\tif (*cfg_ptr) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\n\t\t\t//wave subboxes may have been properly parsed\n \t\t\tif (gf_list_count(a->child_boxes)) {\n \t\t\t\tu32 i;\n                for (i =0; i<gf_list_count(a->child_boxes); i++) {\n                    GF_Box *inner_box = (GF_Box *)gf_list_get(a->child_boxes, i);\n                    if (inner_box->type == subtype) {\n                        *cfg_ptr = inner_box;\n \t\t\t\t\t\tif (ptr->qtff_mode & GF_ISOM_AUDIO_QTFF_CONVERT_FLAG) {\n                        \tgf_list_rem(a->child_boxes, i);\n                        \tdrop_wave=GF_TRUE;\n                        \tgf_list_add(ptr->child_boxes, inner_box);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n                    }\n                }\n\t\t\t\tif (drop_wave) {\n\t\t\t\t\tgf_isom_box_del_parent(&ptr->child_boxes, a);\n                \tptr->qtff_mode = GF_ISOM_AUDIO_QTFF_NONE;\n\t\t\t\t\tptr->compression_id = 0;\n\t\t\t\t\tptr->version = 0;\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t}\n                ptr->qtff_mode = GF_ISOM_AUDIO_QTFF_ON_EXT_VALID;\n                return GF_OK;\n            }\n\t\t}\n\t}\n \t\tptr->qtff_mode = GF_ISOM_AUDIO_QTFF_ON_EXT_VALID;\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\nGF_Err audio_sample_entry_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MPEGAudioSampleEntryBox *ptr;\n\tchar *data;\n\tu8 a, b, c, d;\n\tu32 i, size, v, nb_alnum;\n\tGF_Err e;\n\tu64 pos, start;\n\n\tptr = (GF_MPEGAudioSampleEntryBox *)s;\n\n\tstart = gf_bs_get_position(bs);\n\tv = gf_bs_peek_bits(bs, 16, 8);\n\tif (v)\n\t\tptr->qtff_mode = GF_ISOM_AUDIO_QTFF_ON_NOEXT;\n\n\t//try to disambiguate QTFF v1 and MP4 v1 audio sample entries ...\n\tif (v==1) {\n\t\t//go to end of ISOM audio sample entry, skip 4 byte (box size field), read 4 bytes (box type) and check if this looks like a box\n\t\tgf_bs_skip_bytes(bs, 8 + 20 + 4);\n\t\ta = gf_bs_read_u8(bs);\n\t\tb = gf_bs_read_u8(bs);\n\t\tc = gf_bs_read_u8(bs);\n\t\td = gf_bs_read_u8(bs);\n\t\tnb_alnum = 0;\n\t\tif (isalnum(a)) nb_alnum++;\n\t\tif (isalnum(b)) nb_alnum++;\n\t\tif (isalnum(c)) nb_alnum++;\n\t\tif (isalnum(d)) nb_alnum++;\n\t\tif (nb_alnum>2) ptr->qtff_mode = GF_ISOM_AUDIO_QTFF_NONE;\n\t\tgf_bs_seek(bs, start);\n\t}\n\n\te = gf_isom_audio_sample_entry_read((GF_AudioSampleEntryBox*)s, bs);\n\tif (e) return e;\n\tpos = gf_bs_get_position(bs);\n\tsize = (u32) s->size;\n\n\t//when cookie is set on bs, always convert qtff-style mp4a to isobmff-style\n\t//since the conversion is done in addBox and we don't have the bitstream there (arg...), flag the box\n \tif (gf_bs_get_cookie(bs) & GF_ISOM_BS_COOKIE_QT_CONV) {\n \t\tptr->qtff_mode |= GF_ISOM_AUDIO_QTFF_CONVERT_FLAG;\n \t}\n\n\te = gf_isom_box_array_read(s, bs);\n\tif (!e) {\n\t\tif (s->type==GF_ISOM_BOX_TYPE_ENCA) {\n\t\t\tGF_ProtectionSchemeInfoBox *sinf = (GF_ProtectionSchemeInfoBox *) gf_isom_box_find_child(s->child_boxes, GF_ISOM_BOX_TYPE_SINF);\n\n\t\t\tif (sinf && sinf->original_format) {\n\t\t\t\tu32 type = sinf->original_format->data_format;\n\t\t\t\tswitch (type) {\n\t\t\t\tcase GF_ISOM_SUBTYPE_3GP_AMR:\n\t\t\t\tcase GF_ISOM_SUBTYPE_3GP_AMR_WB:\n\t\t\t\tcase GF_ISOM_SUBTYPE_3GP_EVRC:\n\t\t\t\tcase GF_ISOM_SUBTYPE_3GP_QCELP:\n\t\t\t\tcase GF_ISOM_SUBTYPE_3GP_SMV:\n\t\t\t\t\tif (ptr->cfg_3gpp) ptr->cfg_3gpp->cfg.type = type;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn GF_OK;\n\t}\n\tif (size<8) return GF_ISOM_INVALID_FILE;\n\n\n\t/*hack for some weird files (possibly recorded with live.com tools, needs further investigations)*/\n\tgf_bs_seek(bs, pos);\n\tdata = (char*)gf_malloc(sizeof(char) * size);\n\tif (!data) return GF_OUT_OF_MEM;\n\n\tgf_bs_read_data(bs, data, size);\n\tfor (i=0; i<size-8; i++) {\n\t\tif (GF_4CC((u32)data[i+4], (u8)data[i+5], (u8)data[i+6], (u8)data[i+7]) == GF_ISOM_BOX_TYPE_ESDS) {\n\t\t\tGF_BitStream *mybs = gf_bs_new(data + i, size - i, GF_BITSTREAM_READ);\n\t\t\tgf_bs_set_cookie(mybs, GF_ISOM_BS_COOKIE_NO_LOGS);\n\t\t\tif (ptr->esd) gf_isom_box_del_parent(&ptr->child_boxes, (GF_Box *)ptr->esd);\n\t\t\tptr->esd = NULL;\n\t\t\te = gf_isom_box_parse((GF_Box **)&ptr->esd, mybs);\n\t\t\tgf_bs_del(mybs);\n\n\t\t\tif ((e==GF_OK) && ptr->esd && (ptr->esd->type == GF_ISOM_BOX_TYPE_ESDS)) {\n\t\t\t\tif (!ptr->child_boxes) ptr->child_boxes = gf_list_new();\n\t\t\t\tgf_list_add(ptr->child_boxes, ptr->esd);\n\t\t\t} else if (ptr->esd) {\n\t\t\t\tgf_isom_box_del((GF_Box *)ptr->esd);\n\t\t\t\tptr->esd = NULL;\n\t\t\t}\n\t\t\te = GF_OK;\n\t\t\tbreak;\n\t\t}\n\t}\n\tgf_free(data);\n\treturn e;\n}\n\nGF_Box *audio_sample_entry_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MPEGAudioSampleEntryBox, GF_ISOM_BOX_TYPE_MP4A);\n\tgf_isom_audio_sample_entry_init((GF_AudioSampleEntryBox*)tmp);\n\treturn (GF_Box *)tmp;\n}\n\nGF_Box *enca_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MPEGAudioSampleEntryBox, GF_ISOM_BOX_TYPE_ENCA);\n\tgf_isom_audio_sample_entry_init((GF_AudioSampleEntryBox*)tmp);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err audio_sample_entry_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_isom_audio_sample_entry_write((GF_AudioSampleEntryBox*)s, bs);\n\treturn GF_OK;\n}\n\nGF_Err audio_sample_entry_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_MPEGAudioSampleEntryBox *ptr = (GF_MPEGAudioSampleEntryBox *)s;\n\tgf_isom_audio_sample_entry_size((GF_AudioSampleEntryBox*)s);\n\tif (ptr->qtff_mode)\n\t\treturn GF_OK;\n\n\tgf_isom_check_position(s, (GF_Box *)ptr->esd, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->cfg_mha, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->cfg_3gpp, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->cfg_opus, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->cfg_ac3, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->cfg_flac, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->cfg_mlp, &pos);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid gen_sample_entry_box_del(GF_Box *s)\n{\n\tGF_SampleEntryBox *ptr = (GF_SampleEntryBox *)s;\n\tif (ptr == NULL) return;\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)s);\n\tgf_free(ptr);\n}\n\n\nGF_Err gen_sample_entry_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)s, bs);\n\tif (e) return e;\n\tISOM_DECREASE_SIZE(s, 8);\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *gen_sample_entry_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleEntryBox, GF_QT_SUBTYPE_C608);//type will be overriten\n\tgf_isom_sample_entry_init((GF_SampleEntryBox*)tmp);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err gen_sample_entry_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SampleEntryBox *ptr = (GF_SampleEntryBox *)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_data(bs, ptr->reserved, 6);\n\tgf_bs_write_u16(bs, ptr->dataReferenceIndex);\n\treturn GF_OK;\n}\n\nGF_Err gen_sample_entry_box_size(GF_Box *s)\n{\n\tGF_SampleEntryBox *ptr = (GF_SampleEntryBox *)s;\n\tptr->size += 8;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid mp4s_box_del(GF_Box *s)\n{\n\tGF_MPEGSampleEntryBox *ptr = (GF_MPEGSampleEntryBox *)s;\n\tif (ptr == NULL) return;\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)s);\n\tif (ptr->slc) gf_odf_desc_del((GF_Descriptor *)ptr->slc);\n\tgf_free(ptr);\n}\n\nGF_Err mp4s_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_MPEGSampleEntryBox *ptr = (GF_MPEGSampleEntryBox *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_ESDS:\n\t\tBOX_FIELD_ASSIGN(esd, GF_ESDBox)\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err mp4s_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MPEGSampleEntryBox *ptr = (GF_MPEGSampleEntryBox *)s;\n\n\te = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)ptr, bs);\n\tif (e) return e;\n\n\tISOM_DECREASE_SIZE(ptr, 8);\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *mp4s_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MPEGSampleEntryBox, GF_ISOM_BOX_TYPE_MP4S);\n\tgf_isom_sample_entry_init((GF_SampleEntryBox*)tmp);\n\ttmp->internal_type = GF_ISOM_SAMPLE_ENTRY_MP4S;\n\treturn (GF_Box *)tmp;\n}\n\nGF_Box *encs_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MPEGSampleEntryBox, GF_ISOM_BOX_TYPE_ENCS);\n\tgf_isom_sample_entry_init((GF_SampleEntryBox*)tmp);\n\ttmp->internal_type = GF_ISOM_SAMPLE_ENTRY_MP4S;\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err mp4s_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MPEGSampleEntryBox *ptr = (GF_MPEGSampleEntryBox *)s;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_data(bs, ptr->reserved, 6);\n\tgf_bs_write_u16(bs, ptr->dataReferenceIndex);\n    return GF_OK;\n}\n\nGF_Err mp4s_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_MPEGSampleEntryBox *ptr = (GF_MPEGSampleEntryBox *)s;\n\ts->size += 8;\n\tgf_isom_check_position(s, (GF_Box *)ptr->esd, &pos);\n    return GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid video_sample_entry_box_del(GF_Box *s)\n{\n\tGF_MPEGVisualSampleEntryBox *ptr = (GF_MPEGVisualSampleEntryBox *)s;\n\tif (ptr == NULL) return;\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)s);\n\n\tif (ptr->slc) gf_odf_desc_del((GF_Descriptor *)ptr->slc);\n\t/*for publishing*/\n\tif (ptr->emul_esd) gf_odf_desc_del((GF_Descriptor *)ptr->emul_esd);\n\tgf_free(ptr);\n}\n\nGF_Err video_sample_entry_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_MPEGVisualSampleEntryBox *ptr = (GF_MPEGVisualSampleEntryBox *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_ESDS:\n\t\tBOX_FIELD_ASSIGN(esd, GF_ESDBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_RINF:\n\t\tBOX_FIELD_ASSIGN(rinf, GF_RestrictedSchemeInfoBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_AVCC:\n\t\tBOX_FIELD_ASSIGN(avc_config, GF_AVCConfigurationBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_HVCC:\n\t\tBOX_FIELD_ASSIGN(hevc_config, GF_HEVCConfigurationBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_VVCC:\n\t\tBOX_FIELD_ASSIGN(vvc_config, GF_VVCConfigurationBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_SVCC:\n\t\tBOX_FIELD_ASSIGN(svc_config, GF_AVCConfigurationBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MVCC:\n\t\tBOX_FIELD_ASSIGN(mvc_config, GF_AVCConfigurationBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_LHVC:\n\t\tBOX_FIELD_ASSIGN(lhvc_config, GF_HEVCConfigurationBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_AV1C:\n\t\tBOX_FIELD_ASSIGN(av1_config, GF_AV1ConfigurationBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_VPCC:\n\t\tBOX_FIELD_ASSIGN(vp_config, GF_VPConfigurationBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_DVCC:\n\tcase GF_ISOM_BOX_TYPE_DVVC:\n\t\tBOX_FIELD_ASSIGN(dovi_config, GF_DOVIConfigurationBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_UUID:\n\t\tif (! memcmp(((GF_UnknownUUIDBox*)a)->uuid, GF_ISOM_IPOD_EXT, 16)) {\n\t\t\tBOX_FIELD_ASSIGN(ipod_ext, GF_UnknownUUIDBox)\n\t\t} else {\n\t\t\treturn GF_OK;\n\t\t}\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_D263:\n\t\tBOX_FIELD_ASSIGN(cfg_3gpp, GF_3GPPConfigBox)\n\t\t/*for 3GP config, remember sample entry type in config*/\n\t\tif (ptr->cfg_3gpp)\n\t\t\tptr->cfg_3gpp->cfg.type = ptr->type;\n\t\tbreak;\n\n\tcase GF_ISOM_BOX_TYPE_JP2H:\n\t\tBOX_FIELD_ASSIGN(jp2h, GF_J2KHeaderBox)\n\t\treturn GF_OK;\n\n\tcase GF_ISOM_BOX_TYPE_PASP:\n\tcase GF_ISOM_BOX_TYPE_CLAP:\n\tcase GF_ISOM_BOX_TYPE_COLR:\n\tcase GF_ISOM_BOX_TYPE_MDCV:\n\tcase GF_ISOM_BOX_TYPE_CLLI:\n\tcase GF_ISOM_BOX_TYPE_CCST:\n\tcase GF_ISOM_BOX_TYPE_AUXI:\n\tcase GF_ISOM_BOX_TYPE_RVCC:\n\tcase GF_ISOM_BOX_TYPE_M4DS:\n\t\tif (!is_rem && !gf_isom_box_check_unique(s->child_boxes, a)) {\n\t\t\tERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t}\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err video_sample_entry_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MPEGVisualSampleEntryBox *mp4v = (GF_MPEGVisualSampleEntryBox*)s;\n\tGF_Err e;\n\te = gf_isom_video_sample_entry_read((GF_VisualSampleEntryBox *)s, bs);\n\tif (e) return e;\n\te = gf_isom_box_array_read(s, bs);\n\tif (e) return e;\n\t/*this is an AVC sample desc*/\n\tif (mp4v->avc_config || mp4v->svc_config || mp4v->mvc_config)\n\t\tAVC_RewriteESDescriptor(mp4v);\n\t/*this is an HEVC sample desc*/\n\tif (mp4v->hevc_config || mp4v->lhvc_config || (mp4v->type==GF_ISOM_BOX_TYPE_HVT1))\n\t\tHEVC_RewriteESDescriptor(mp4v);\n\t/*this is an AV1 sample desc*/\n\tif (mp4v->av1_config)\n\t\tAV1_RewriteESDescriptor(mp4v);\n\t/*this is a VP8-9 sample desc*/\n\tif (mp4v->vp_config)\n\t\tVP9_RewriteESDescriptor(mp4v);\n\n\tif (s->type==GF_ISOM_BOX_TYPE_ENCV) {\n\t\tGF_ProtectionSchemeInfoBox *sinf = (GF_ProtectionSchemeInfoBox *) gf_isom_box_find_child(s->child_boxes, GF_ISOM_BOX_TYPE_SINF);\n\n\t\tif (sinf && sinf->original_format) {\n\t\t\tu32 type = sinf->original_format->data_format;\n\t\t\tswitch (type) {\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_H263:\n\t\t\t\tif (mp4v->cfg_3gpp) mp4v->cfg_3gpp->cfg.type = type;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *video_sample_entry_box_new()\n{\n\tGF_MPEGVisualSampleEntryBox *tmp;\n\tGF_SAFEALLOC(tmp, GF_MPEGVisualSampleEntryBox);\n\tif (tmp == NULL) return NULL;\n\n\tgf_isom_video_sample_entry_init((GF_VisualSampleEntryBox *)tmp);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err video_sample_entry_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_isom_video_sample_entry_write((GF_VisualSampleEntryBox *)s, bs);\n\treturn GF_OK;\n}\n\nGF_Err video_sample_entry_box_size(GF_Box *s)\n{\n\tGF_Box *b;\n\tu32 pos=0;\n\tGF_MPEGVisualSampleEntryBox *ptr = (GF_MPEGVisualSampleEntryBox *)s;\n\tgf_isom_video_sample_entry_size((GF_VisualSampleEntryBox *)s);\n\n\t/*make sure we write the config box first, we don't care about the rest*/\n\n\t/*mp4v*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->esd, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->cfg_3gpp, &pos);\n\t/*avc / SVC + MVC*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->avc_config, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->svc_config, &pos);\n\tif (ptr->mvc_config) {\n\t\tgf_isom_check_position(s, gf_isom_box_find_child(s->child_boxes, GF_ISOM_BOX_TYPE_VWID), &pos);\n\t\tgf_isom_check_position(s, (GF_Box *)ptr->mvc_config, &pos);\n\t}\n\n\t/*HEVC*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->hevc_config, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->lhvc_config, &pos);\n\n\t/*VVC*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->vvc_config, &pos);\n\n\t/*AV1*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->av1_config, &pos);\n\n\t/*VPx*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->vp_config, &pos);\n\n\t/*JP2H*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->jp2h, &pos);\n\n\t/*DolbyVision*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->dovi_config, &pos);\n\n\tb = gf_isom_box_find_child(ptr->child_boxes, GF_ISOM_BOX_TYPE_ST3D);\n\tif (b) gf_isom_check_position(s, b, &pos);\n\n\tb = gf_isom_box_find_child(ptr->child_boxes, GF_ISOM_BOX_TYPE_SV3D);\n\tif (b) gf_isom_check_position(s, b, &pos);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\nvoid mvex_box_del(GF_Box *s)\n{\n\tGF_MovieExtendsBox *ptr = (GF_MovieExtendsBox *)s;\n\tif (ptr == NULL) return;\n\tgf_list_del(ptr->TrackExList);\n\tgf_list_del(ptr->TrackExPropList);\n\tgf_free(ptr);\n}\n\n\nGF_Err mvex_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_MovieExtendsBox *ptr = (GF_MovieExtendsBox *)s;\n\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_TREX:\n\t\tBOX_FIELD_LIST_ASSIGN(TrackExList)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_TREP:\n\t\tBOX_FIELD_LIST_ASSIGN(TrackExPropList)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_MEHD:\n\t\tBOX_FIELD_ASSIGN(mehd, GF_MovieExtendsHeaderBox)\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\n\n\nGF_Err mvex_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *mvex_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MovieExtendsBox, GF_ISOM_BOX_TYPE_MVEX);\n\ttmp->TrackExList = gf_list_new();\n\tif (!tmp->TrackExList) {\n\t\tgf_free(tmp);\n\t\treturn NULL;\n\t}\n\ttmp->TrackExPropList = gf_list_new();\n\tif (!tmp->TrackExPropList) {\n\t\tgf_list_del(tmp->TrackExList);\n\t\tgf_free(tmp);\n\t\treturn NULL;\n\t}\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err mvex_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err mvex_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_MovieExtendsBox *ptr = (GF_MovieExtendsBox *) s;\n\tgf_isom_check_position(s, (GF_Box *)ptr->mehd, &pos);\n\tgf_isom_check_position_list(s, ptr->TrackExList, &pos);\n\tgf_isom_check_position_list(s, ptr->TrackExPropList, &pos);\n\treturn GF_OK;\n}\n\n\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *mehd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MovieExtendsHeaderBox, GF_ISOM_BOX_TYPE_MEHD);\n\treturn (GF_Box *)tmp;\n}\nvoid mehd_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\nGF_Err mehd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MovieExtendsHeaderBox *ptr = (GF_MovieExtendsHeaderBox *)s;\n\n\tif (ptr->version==1) {\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\tptr->fragment_duration = gf_bs_read_u64(bs);\n\t} else {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->fragment_duration = (u64) gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err mehd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MovieExtendsHeaderBox *ptr = (GF_MovieExtendsHeaderBox *)s;\n\tGF_Err e = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tif (ptr->version == 1) {\n\t\tgf_bs_write_u64(bs, ptr->fragment_duration);\n\t} else {\n\t\tgf_bs_write_u32(bs, (u32) ptr->fragment_duration);\n\t}\n\treturn GF_OK;\n}\nGF_Err mehd_box_size(GF_Box *s)\n{\n\tGF_MovieExtendsHeaderBox *ptr = (GF_MovieExtendsHeaderBox *)s;\n\tptr->version = (ptr->fragment_duration>0xFFFFFFFF) ? 1 : 0;\n\ts->size += (ptr->version == 1) ? 8 : 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM_FRAGMENTS*/\n\n\nvoid mvhd_box_del(GF_Box *s)\n{\n\tGF_MovieHeaderBox *ptr = (GF_MovieHeaderBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err mvhd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MovieHeaderBox *ptr = (GF_MovieHeaderBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\tif (ptr->version == 1) {\n\t\tISOM_DECREASE_SIZE(ptr, 28);\n\t\tptr->creationTime = gf_bs_read_u64(bs);\n\t\tptr->modificationTime = gf_bs_read_u64(bs);\n\t\tptr->timeScale = gf_bs_read_u32(bs);\n\t\tptr->duration = gf_bs_read_u64(bs);\n\t} else {\n\t\tISOM_DECREASE_SIZE(ptr, 16);\n\t\tptr->creationTime = gf_bs_read_u32(bs);\n\t\tptr->modificationTime = gf_bs_read_u32(bs);\n\t\tptr->timeScale = gf_bs_read_u32(bs);\n\t\tptr->duration = gf_bs_read_u32(bs);\n\t}\n\tif (!ptr->timeScale) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Movie header timescale is invalid (0) - defaulting to 600\\n\" ));\n\t\tptr->timeScale = 600;\n\t}\n\tISOM_DECREASE_SIZE(ptr, 80);\n\tptr->preferredRate = gf_bs_read_u32(bs);\n\tptr->preferredVolume = gf_bs_read_u16(bs);\n\tgf_bs_read_data(bs, ptr->reserved, 10);\n\tptr->matrixA = gf_bs_read_u32(bs);\n\tptr->matrixB = gf_bs_read_u32(bs);\n\tptr->matrixU = gf_bs_read_u32(bs);\n\tptr->matrixC = gf_bs_read_u32(bs);\n\tptr->matrixD = gf_bs_read_u32(bs);\n\tptr->matrixV = gf_bs_read_u32(bs);\n\tptr->matrixX = gf_bs_read_u32(bs);\n\tptr->matrixY = gf_bs_read_u32(bs);\n\tptr->matrixW = gf_bs_read_u32(bs);\n\tptr->previewTime = gf_bs_read_u32(bs);\n\tptr->previewDuration = gf_bs_read_u32(bs);\n\tptr->posterTime = gf_bs_read_u32(bs);\n\tptr->selectionTime = gf_bs_read_u32(bs);\n\tptr->selectionDuration = gf_bs_read_u32(bs);\n\tptr->currentTime = gf_bs_read_u32(bs);\n\tptr->nextTrackID = gf_bs_read_u32(bs);\n\tptr->original_duration = ptr->duration;\n\treturn GF_OK;\n}\n\nGF_Box *mvhd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MovieHeaderBox, GF_ISOM_BOX_TYPE_MVHD);\n\n\ttmp->preferredRate = (1<<16);\n\ttmp->preferredVolume = (1<<8);\n\n\ttmp->matrixA = (1<<16);\n\ttmp->matrixD = (1<<16);\n\ttmp->matrixW = (1<<30);\n\n\ttmp->nextTrackID = 1;\n\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err mvhd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MovieHeaderBox *ptr = (GF_MovieHeaderBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tif (ptr->version == 1) {\n\t\tgf_bs_write_u64(bs, ptr->creationTime);\n\t\tgf_bs_write_u64(bs, ptr->modificationTime);\n\t\tgf_bs_write_u32(bs, ptr->timeScale);\n\t\tgf_bs_write_u64(bs, ptr->duration);\n\t} else {\n\t\tgf_bs_write_u32(bs, (u32) ptr->creationTime);\n\t\tgf_bs_write_u32(bs, (u32) ptr->modificationTime);\n\t\tgf_bs_write_u32(bs, ptr->timeScale);\n\t\tgf_bs_write_u32(bs, (u32) ptr->duration);\n\t}\n\tgf_bs_write_u32(bs, ptr->preferredRate);\n\tgf_bs_write_u16(bs, ptr->preferredVolume);\n\tgf_bs_write_data(bs, ptr->reserved, 10);\n\tgf_bs_write_u32(bs, ptr->matrixA);\n\tgf_bs_write_u32(bs, ptr->matrixB);\n\tgf_bs_write_u32(bs, ptr->matrixU);\n\tgf_bs_write_u32(bs, ptr->matrixC);\n\tgf_bs_write_u32(bs, ptr->matrixD);\n\tgf_bs_write_u32(bs, ptr->matrixV);\n\tgf_bs_write_u32(bs, ptr->matrixX);\n\tgf_bs_write_u32(bs, ptr->matrixY);\n\tgf_bs_write_u32(bs, ptr->matrixW);\n\tgf_bs_write_u32(bs, ptr->previewTime);\n\tgf_bs_write_u32(bs, ptr->previewDuration);\n\tgf_bs_write_u32(bs, ptr->posterTime);\n\tgf_bs_write_u32(bs, ptr->selectionTime);\n\tgf_bs_write_u32(bs, ptr->selectionDuration);\n\tgf_bs_write_u32(bs, ptr->currentTime);\n\tgf_bs_write_u32(bs, ptr->nextTrackID);\n\treturn GF_OK;\n}\n\nGF_Err mvhd_box_size(GF_Box *s)\n{\n\tGF_MovieHeaderBox *ptr = (GF_MovieHeaderBox *)s;\n\tif (ptr->duration==(u64) -1) ptr->version = 0;\n\telse ptr->version = (ptr->duration>0xFFFFFFFF) ? 1 : 0;\n\n\tptr->size += (ptr->version == 1) ? 28 : 16;\n\tptr->size += 80;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid nmhd_box_del(GF_Box *s)\n{\n\tGF_MPEGMediaHeaderBox *ptr = (GF_MPEGMediaHeaderBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\n\nGF_Err nmhd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn GF_OK;\n}\n\nGF_Box *nmhd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MPEGMediaHeaderBox, GF_ISOM_BOX_TYPE_NMHD);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err nmhd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_full_box_write(s, bs);\n}\n\nGF_Err nmhd_box_size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid padb_box_del(GF_Box *s)\n{\n\tGF_PaddingBitsBox *ptr = (GF_PaddingBitsBox *) s;\n\tif (ptr == NULL) return;\n\tif (ptr->padbits) gf_free(ptr->padbits);\n\tgf_free(ptr);\n}\n\n\nGF_Err padb_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_PaddingBitsBox *ptr = (GF_PaddingBitsBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->SampleCount = gf_bs_read_u32(bs);\n\tif (ptr->size < ptr->SampleCount/2) //half byte per sample\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tptr->padbits = (u8 *)gf_malloc(sizeof(u8)*ptr->SampleCount);\n\tif (!ptr->padbits) return GF_OUT_OF_MEM;\n\n\tfor (i=0; i<ptr->SampleCount; i += 2) {\n\t\tgf_bs_read_int(bs, 1);\n\t\tif (i+1 < ptr->SampleCount) {\n\t\t\tptr->padbits[i+1] = gf_bs_read_int(bs, 3);\n\t\t} else {\n\t\t\tgf_bs_read_int(bs, 3);\n\t\t}\n\t\tgf_bs_read_int(bs, 1);\n\t\tptr->padbits[i] = gf_bs_read_int(bs, 3);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *padb_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_PaddingBitsBox, GF_ISOM_BOX_TYPE_PADB);\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err padb_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_Err e;\n\tGF_PaddingBitsBox *ptr = (GF_PaddingBitsBox *) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_int(bs, ptr->SampleCount, 32);\n\n\tfor (i=0 ; i<ptr->SampleCount; i += 2) {\n\t\tgf_bs_write_int(bs, 0, 1);\n\t\tif (i+1 < ptr->SampleCount) {\n\t\t\tgf_bs_write_int(bs, ptr->padbits[i+1], 3);\n\t\t} else {\n\t\t\tgf_bs_write_int(bs, 0, 3);\n\t\t}\n\t\tgf_bs_write_int(bs, 0, 1);\n\t\tgf_bs_write_int(bs, ptr->padbits[i], 3);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err padb_box_size(GF_Box *s)\n{\n\tGF_PaddingBitsBox *ptr = (GF_PaddingBitsBox *)s;\n\tptr->size += 4;\n\tif (ptr->SampleCount) ptr->size += (ptr->SampleCount + 1) / 2;\n\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid rely_box_del(GF_Box *s)\n{\n\tGF_RelyHintBox *rely = (GF_RelyHintBox *)s;\n\tgf_free(rely);\n}\n\nGF_Err rely_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_RelyHintBox *ptr = (GF_RelyHintBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 1);\n\tptr->reserved = gf_bs_read_int(bs, 6);\n\tptr->preferred = gf_bs_read_int(bs, 1);\n\tptr->required = gf_bs_read_int(bs, 1);\n\treturn GF_OK;\n}\n\nGF_Box *rely_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_RelyHintBox, GF_ISOM_BOX_TYPE_RELY);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err rely_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_RelyHintBox *ptr = (GF_RelyHintBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_int(bs, ptr->reserved, 6);\n\tgf_bs_write_int(bs, ptr->preferred, 1);\n\tgf_bs_write_int(bs, ptr->required, 1);\n\treturn GF_OK;\n}\n\nGF_Err rely_box_size(GF_Box *s)\n{\n\ts->size += 1;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid rtpo_box_del(GF_Box *s)\n{\n\tGF_RTPOBox *rtpo = (GF_RTPOBox *)s;\n\tgf_free(rtpo);\n}\n\nGF_Err rtpo_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_RTPOBox *ptr = (GF_RTPOBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->timeOffset = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\nGF_Box *rtpo_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_RTPOBox, GF_ISOM_BOX_TYPE_RTPO);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err rtpo_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_RTPOBox *ptr = (GF_RTPOBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\n\t//here we have no pb, just remembed that some entries will have to\n\t//be 4-bytes aligned ...\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->timeOffset);\n\treturn GF_OK;\n}\n\nGF_Err rtpo_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid smhd_box_del(GF_Box *s)\n{\n\tGF_SoundMediaHeaderBox *ptr = (GF_SoundMediaHeaderBox *)s;\n\tif (ptr == NULL ) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err smhd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_SoundMediaHeaderBox *ptr = (GF_SoundMediaHeaderBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->balance = gf_bs_read_u16(bs);\n\tptr->reserved = gf_bs_read_u16(bs);\n\treturn GF_OK;\n}\n\nGF_Box *smhd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SoundMediaHeaderBox, GF_ISOM_BOX_TYPE_SMHD);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err smhd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SoundMediaHeaderBox *ptr = (GF_SoundMediaHeaderBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u16(bs, ptr->balance);\n\tgf_bs_write_u16(bs, ptr->reserved);\n\treturn GF_OK;\n}\n\nGF_Err smhd_box_size(GF_Box *s)\n{\n\tGF_SoundMediaHeaderBox *ptr = (GF_SoundMediaHeaderBox *)s;\n\n\tptr->reserved = 0;\n\tptr->size += 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid snro_box_del(GF_Box *s)\n{\n\tGF_SeqOffHintEntryBox *snro = (GF_SeqOffHintEntryBox *)s;\n\tgf_free(snro);\n}\n\nGF_Err snro_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_SeqOffHintEntryBox *ptr = (GF_SeqOffHintEntryBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->SeqOffset = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\nGF_Box *snro_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SeqOffHintEntryBox, GF_ISOM_BOX_TYPE_SNRO);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err snro_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SeqOffHintEntryBox *ptr = (GF_SeqOffHintEntryBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->SeqOffset);\n\treturn GF_OK;\n}\n\nGF_Err snro_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid stbl_box_del(GF_Box *s)\n{\n\tGF_SampleTableBox *ptr = (GF_SampleTableBox *)s;\n\tif (ptr == NULL) return;\n\n\tif (ptr->sub_samples) gf_list_del(ptr->sub_samples);\n\tif (ptr->sampleGroups) gf_list_del(ptr->sampleGroups);\n\tif (ptr->sampleGroupsDescription) gf_list_del(ptr->sampleGroupsDescription);\n\tif (ptr->sai_sizes) gf_list_del(ptr->sai_sizes);\n\tif (ptr->sai_offsets) gf_list_del(ptr->sai_offsets);\n\tif (ptr->traf_map) {\n\t\tif (ptr->traf_map->frag_starts) {\n\t\t\tu32 i;\n\t\t\tfor (i=0; i<ptr->traf_map->nb_entries; i++) {\n\t\t\t\tif (ptr->traf_map->frag_starts[i].moof_template)\n\t\t\t\t\tgf_free(ptr->traf_map->frag_starts[i].moof_template);\n\t\t\t}\n\t\t\tgf_free(ptr->traf_map->frag_starts);\n\t\t}\n\t\tgf_free(ptr->traf_map);\n\t}\n\tgf_free(ptr);\n}\n\nGF_Err stbl_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_SampleTableBox *ptr = (GF_SampleTableBox *)s;\n\tif (!a) return GF_OK;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_STTS:\n\t\tBOX_FIELD_ASSIGN(TimeToSample, GF_TimeToSampleBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_CTTS:\n\t\tBOX_FIELD_ASSIGN(CompositionOffset, GF_CompositionOffsetBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_CSLG:\n\t\tBOX_FIELD_ASSIGN(CompositionToDecode, GF_CompositionToDecodeBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_STSS:\n\t\tBOX_FIELD_ASSIGN(SyncSample, GF_SyncSampleBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_STSD:\n\t\tBOX_FIELD_ASSIGN(SampleDescription, GF_SampleDescriptionBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_STZ2:\n\tcase GF_ISOM_BOX_TYPE_STSZ:\n\t\tBOX_FIELD_ASSIGN(SampleSize, GF_SampleSizeBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_STSC:\n\t\tBOX_FIELD_ASSIGN(SampleToChunk, GF_SampleToChunkBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_PADB:\n\t\tBOX_FIELD_ASSIGN(PaddingBits, GF_PaddingBitsBox)\n\t\tbreak;\n\n\t//WARNING: AS THIS MAY CHANGE DYNAMICALLY DURING EDIT,\n\tcase GF_ISOM_BOX_TYPE_CO64:\n\tcase GF_ISOM_BOX_TYPE_STCO:\n\t\tBOX_FIELD_ASSIGN(ChunkOffset, GF_Box)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_STSH:\n\t\tBOX_FIELD_ASSIGN(ShadowSync, GF_ShadowSyncBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_STDP:\n\t\tBOX_FIELD_ASSIGN(DegradationPriority, GF_DegradationPriorityBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_SDTP:\n\t\tBOX_FIELD_ASSIGN(SampleDep, GF_SampleDependencyTypeBox)\n\t\tbreak;\n\n\tcase GF_ISOM_BOX_TYPE_SUBS:\n\t\tBOX_FIELD_LIST_ASSIGN(sub_samples)\n\t\t//check subsample box\n\t\tif (!is_rem) {\n\t\t\tGF_SubSampleInformationBox *subs = (GF_SubSampleInformationBox *)a;\n\t\t\tGF_SubSampleInfoEntry *ent = gf_list_get(subs->Samples, 0);\n\t\t\tif (!ent) {\n\t\t\t\tgf_list_rem(subs->Samples, 0);\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] first entry in SubSample in track SampleTable is invalid\\n\"));\n\t\t\t}\n\t\t\telse if (ent->sample_delta==0) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] first entry in SubSample in track SampleTable has sample_delta of 0, should be one. Fixing\\n\"));\n\t\t\t\tent->sample_delta = 1;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase GF_ISOM_BOX_TYPE_SBGP:\n\tcase GF_ISOM_BOX_TYPE_CSGP:\n\t\tBOX_FIELD_LIST_ASSIGN(sampleGroups)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_SGPD:\n\t\tBOX_FIELD_LIST_ASSIGN(sampleGroupsDescription)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_SAIZ:\n\t\tBOX_FIELD_LIST_ASSIGN(sai_sizes)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_SAIO:\n\t\tBOX_FIELD_LIST_ASSIGN(sai_offsets)\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\n\n\n\nGF_Err stbl_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\t//we need to parse DegPrior in a special way\n\tGF_SampleTableBox *ptr = (GF_SampleTableBox *)s;\n\n\te = gf_isom_box_array_read(s, bs);\n\tif (e) return e;\n\n\tif (!ptr->SyncSample)\n\t\tptr->no_sync_found = 1;\n\n\tptr->nb_sgpd_in_stbl = gf_list_count(ptr->sampleGroupsDescription);\n\tptr->nb_stbl_boxes = gf_list_count(ptr->child_boxes);\n\n\tif (gf_bs_get_cookie(bs) & GF_ISOM_BS_COOKIE_CLONE_TRACK)\n\t\treturn GF_OK;\n//\treturn GF_OK;\n\n#define CHECK_BOX(_name) \\\n\tif (!ptr->_name) {\\\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Mandatory box %s is missing\\n\", #_name)); \\\n\t\treturn GF_ISOM_INVALID_FILE; \\\n\t}\n\n\tCHECK_BOX(SampleToChunk)\n\tCHECK_BOX(SampleSize)\n\tCHECK_BOX(ChunkOffset)\n\tCHECK_BOX(TimeToSample)\n\n\t//sanity check\n\tif (ptr->SampleSize->sampleCount) {\n\t\tif (!ptr->TimeToSample->nb_entries || !ptr->SampleToChunk->nb_entries)\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tu32 i, max_chunks=0;\n\tif (ptr->ChunkOffset->type == GF_ISOM_BOX_TYPE_STCO) {\n\t\tmax_chunks = ((GF_ChunkOffsetBox *)ptr->ChunkOffset)->nb_entries;\n\t}\n\telse if (ptr->ChunkOffset->type == GF_ISOM_BOX_TYPE_CO64) {\n\t\tmax_chunks = ((GF_ChunkOffsetBox *)ptr->ChunkOffset)->nb_entries;\n\t}\n\n\t//sanity check on stsc vs chunk offset tables\n\tfor (i=0; i<ptr->SampleToChunk->nb_entries; i++) {\n\t\tGF_StscEntry *ent = &ptr->SampleToChunk->entries[i];\n\t\tif (!i && (ent->firstChunk!=1)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] first_chunk of first entry shall be 1 but is %u\\n\", ent->firstChunk));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t\tif (ptr->SampleToChunk->entries[i].firstChunk > max_chunks) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] first_chunk is %u but number of chunks defined %u\\n\", ptr->SampleToChunk->entries[i].firstChunk, max_chunks));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t\tif (i+1 == ptr->SampleToChunk->nb_entries) break;\n\t\tGF_StscEntry *next_ent = &ptr->SampleToChunk->entries[i+1];\n\t\tif (next_ent->firstChunk < ent->firstChunk) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] first_chunk (%u) for entry %u is greater than first_chunk (%u) for entry %u\\n\", i+1, ent->firstChunk, i+2, next_ent->firstChunk));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *stbl_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleTableBox, GF_ISOM_BOX_TYPE_STBL);\n\t//maxSamplePer chunk is 10 by default\n\ttmp->MaxSamplePerChunk = 10;\n\ttmp->groupID = 1;\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stbl_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err stbl_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_SampleTableBox *ptr = (GF_SampleTableBox *)s;\n\n\tgf_isom_check_position(s, (GF_Box *)ptr->SampleDescription, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->TimeToSample, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->CompositionOffset, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->CompositionToDecode, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->SyncSample, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->ShadowSync, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->SampleToChunk, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->SampleSize, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->ChunkOffset, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->DegradationPriority, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->SampleDep, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->PaddingBits, &pos);\n\n\tif (ptr->sub_samples) {\n\t\tgf_isom_check_position_list(s, ptr->sub_samples, &pos);\n\t}\n\tif (ptr->sampleGroupsDescription) {\n\t\tgf_isom_check_position_list(s, ptr->sampleGroupsDescription, &pos);\n\t}\n\tif (ptr->sampleGroups) {\n\t\tgf_isom_check_position_list(s, ptr->sampleGroups, &pos);\n\t}\n\tif (ptr->sai_sizes) {\n\t\tgf_isom_check_position_list(s, ptr->sai_sizes, &pos);\n\t}\n\tif (ptr->sai_offsets) {\n\t\tgf_isom_check_position_list(s, ptr->sai_offsets, &pos);\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid stco_box_del(GF_Box *s)\n{\n\tGF_ChunkOffsetBox *ptr = (GF_ChunkOffsetBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->offsets) gf_free(ptr->offsets);\n\tgf_free(ptr);\n}\n\n\nGF_Err stco_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 entries;\n\tGF_ChunkOffsetBox *ptr = (GF_ChunkOffsetBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->nb_entries = gf_bs_read_u32(bs);\n\tif (ptr->nb_entries > ptr->size / 4 || (u64)ptr->nb_entries > (u64)SIZE_MAX/sizeof(u32)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in stco\\n\", ptr->nb_entries));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tif (ptr->nb_entries) {\n\t\tptr->offsets = (u32 *) gf_malloc(ptr->nb_entries * sizeof(u32) );\n\t\tif (ptr->offsets == NULL) return GF_OUT_OF_MEM;\n\t\tptr->alloc_size = ptr->nb_entries;\n\n\t\tfor (entries = 0; entries < ptr->nb_entries; entries++) {\n\t\t\tptr->offsets[entries] = gf_bs_read_u32(bs);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *stco_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ChunkOffsetBox, GF_ISOM_BOX_TYPE_STCO);\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stco_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_ChunkOffsetBox *ptr = (GF_ChunkOffsetBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->nb_entries);\n\tfor (i = 0; i < ptr->nb_entries; i++) {\n\t\tgf_bs_write_u32(bs, ptr->offsets[i]);\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err stco_box_size(GF_Box *s)\n{\n\tGF_ChunkOffsetBox *ptr = (GF_ChunkOffsetBox *)s;\n\n\tptr->size += 4 + (4 * ptr->nb_entries);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid stdp_box_del(GF_Box *s)\n{\n\tGF_DegradationPriorityBox *ptr = (GF_DegradationPriorityBox *)s;\n\tif (ptr == NULL ) return;\n\tif (ptr->priorities) gf_free(ptr->priorities);\n\tgf_free(ptr);\n}\n\n//this is called through stbl_read...\nGF_Err stdp_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 entry;\n\tGF_DegradationPriorityBox *ptr = (GF_DegradationPriorityBox *)s;\n\n\t/*out-of-order stdp, assume no padding at the end and take the entire remaining data for entries*/\n\tif (!ptr->nb_entries) ptr->nb_entries = (u32) ptr->size / 2;\n\telse if (ptr->nb_entries > ptr->size / 2) return GF_ISOM_INVALID_FILE;\n\n\tptr->priorities = (u16 *) gf_malloc(ptr->nb_entries * sizeof(u16));\n\tif (ptr->priorities == NULL) return GF_OUT_OF_MEM;\n\tfor (entry = 0; entry < ptr->nb_entries; entry++) {\n\t\tptr->priorities[entry] = gf_bs_read_u16(bs);\n\t}\n\tISOM_DECREASE_SIZE(ptr, (2*ptr->nb_entries) );\n\treturn GF_OK;\n}\n\nGF_Box *stdp_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DegradationPriorityBox, GF_ISOM_BOX_TYPE_STDP);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stdp_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_DegradationPriorityBox *ptr = (GF_DegradationPriorityBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tfor (i = 0; i < ptr->nb_entries; i++) {\n\t\tgf_bs_write_u16(bs, ptr->priorities[i]);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err stdp_box_size(GF_Box *s)\n{\n\tGF_DegradationPriorityBox *ptr = (GF_DegradationPriorityBox *)s;\n\n\tptr->size += (2 * ptr->nb_entries);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid stsc_box_del(GF_Box *s)\n{\n\tGF_SampleToChunkBox *ptr = (GF_SampleToChunkBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);\n}\n\n\nGF_Err stsc_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_SampleToChunkBox *ptr = (GF_SampleToChunkBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->nb_entries = gf_bs_read_u32(bs);\n\n\tif (ptr->nb_entries > ptr->size / 12 || (u64)ptr->nb_entries > (u64)SIZE_MAX/sizeof(GF_StscEntry)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in stsc\\n\", ptr->nb_entries));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tptr->alloc_size = ptr->nb_entries;\n\tptr->entries = NULL;\n\tif (ptr->nb_entries) {\n\t\tptr->entries = gf_malloc(sizeof(GF_StscEntry)*ptr->alloc_size);\n\t\tif (!ptr->entries) return GF_OUT_OF_MEM;\n\t}\n\n\tfor (i = 0; i < ptr->nb_entries; i++) {\n\t\tptr->entries[i].firstChunk = gf_bs_read_u32(bs);\n\t\tptr->entries[i].samplesPerChunk = gf_bs_read_u32(bs);\n\t\tptr->entries[i].sampleDescriptionIndex = gf_bs_read_u32(bs);\n\t\tptr->entries[i].isEdited = 0;\n\t\tptr->entries[i].nextChunk = 0;\n\t\tif (!ptr->entries[i].firstChunk) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] invalid first chunk 0 in stsc entry\\n\", ptr->nb_entries));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\n\t\t//update the next chunk in the previous entry\n\t\tif (i) ptr->entries[i-1].nextChunk = ptr->entries[i].firstChunk;\n\t}\n\tptr->currentIndex = 0;\n\tptr->firstSampleInCurrentChunk = 0;\n\tptr->currentChunk = 0;\n\tptr->ghostNumber = 0;\n\treturn GF_OK;\n}\n\nGF_Box *stsc_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleToChunkBox, GF_ISOM_BOX_TYPE_STSC);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stsc_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_SampleToChunkBox *ptr = (GF_SampleToChunkBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->nb_entries);\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tgf_bs_write_u32(bs, ptr->entries[i].firstChunk);\n\t\tgf_bs_write_u32(bs, ptr->entries[i].samplesPerChunk);\n\t\tgf_bs_write_u32(bs, ptr->entries[i].sampleDescriptionIndex);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err stsc_box_size(GF_Box *s)\n{\n\tGF_SampleToChunkBox *ptr = (GF_SampleToChunkBox *)s;\n\n\tptr->size += 4 + (12 * ptr->nb_entries);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid stsd_box_del(GF_Box *s)\n{\n\tGF_SampleDescriptionBox *ptr = (GF_SampleDescriptionBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\nGF_Err stsd_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_UnknownBox *def;\n\tif (!a) return GF_OK;\n\n\tif (is_rem || gf_box_valid_in_parent(a, \"stsd\")) {\n\t\treturn GF_OK;\n\t}\n\tswitch (a->type) {\n\t//unknown sample description: we need a specific box to handle the data ref index\n\t//rather than a default box ...\n\tcase GF_ISOM_BOX_TYPE_UNKNOWN:\n\t\tdef = (GF_UnknownBox *)a;\n\t\t/*we need at least 8 bytes for unknown sample entries*/\n\t\tif (def->dataSize < 8) {\n\t\t\tgf_isom_box_del_parent(&s->child_boxes, a);\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\t}\n\t\treturn GF_OK;\n\n\tdefault:\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Cannot process box of type %s\\n\", gf_4cc_to_str(a->type)));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n}\n\n\nGF_Err stsd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tISOM_DECREASE_SIZE(s, 4)\n\tgf_bs_read_u32(bs);\n\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *stsd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleDescriptionBox, GF_ISOM_BOX_TYPE_STSD);\n\ttmp->child_boxes = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stsd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 nb_entries;\n\tGF_SampleDescriptionBox *ptr = (GF_SampleDescriptionBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tnb_entries = gf_list_count(ptr->child_boxes);\n\tgf_bs_write_u32(bs, nb_entries);\n\treturn GF_OK;\n}\n\nGF_Err stsd_box_size(GF_Box *s)\n{\n\tGF_SampleDescriptionBox *ptr = (GF_SampleDescriptionBox *)s;\n\tptr->size += 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid stsh_box_del(GF_Box *s)\n{\n\tu32 i = 0;\n\tGF_StshEntry *ent;\n\tGF_ShadowSyncBox *ptr = (GF_ShadowSyncBox *)s;\n\tif (ptr == NULL) return;\n\twhile ( (ent = (GF_StshEntry *)gf_list_enum(ptr->entries, &i)) ) {\n\t\tgf_free(ent);\n\t}\n\tgf_list_del(ptr->entries);\n\tgf_free(ptr);\n}\n\n\n\nGF_Err stsh_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 count, i;\n\tGF_ShadowSyncBox *ptr = (GF_ShadowSyncBox *)s;\n\n\tISOM_DECREASE_SIZE(s, 4)\n\tcount = gf_bs_read_u32(bs);\n\tif (ptr->size / 8 < count)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tfor (i = 0; i < count; i++) {\n\t\tGF_StshEntry *ent = (GF_StshEntry *) gf_malloc(sizeof(GF_StshEntry));\n\t\tif (!ent) return GF_OUT_OF_MEM;\n\t\tent->shadowedSampleNumber = gf_bs_read_u32(bs);\n\t\tent->syncSampleNumber = gf_bs_read_u32(bs);\n\t\te = gf_list_add(ptr->entries, ent);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *stsh_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ShadowSyncBox, GF_ISOM_BOX_TYPE_STSH);\n\n\ttmp->entries = gf_list_new();\n\tif (!tmp->entries) {\n\t\tgf_free(tmp);\n\t\treturn NULL;\n\t}\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stsh_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_StshEntry *ent;\n\tGF_ShadowSyncBox *ptr = (GF_ShadowSyncBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, gf_list_count(ptr->entries));\n\ti=0;\n\twhile ((ent = (GF_StshEntry *)gf_list_enum(ptr->entries, &i))) {\n\t\tgf_bs_write_u32(bs, ent->shadowedSampleNumber);\n\t\tgf_bs_write_u32(bs, ent->syncSampleNumber);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err stsh_box_size(GF_Box *s)\n{\n\tGF_ShadowSyncBox *ptr = (GF_ShadowSyncBox *)s;\n\tptr->size += 4 + (8 * gf_list_count(ptr->entries));\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid stss_box_del(GF_Box *s)\n{\n\tGF_SyncSampleBox *ptr = (GF_SyncSampleBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->sampleNumbers) gf_free(ptr->sampleNumbers);\n\tgf_free(ptr);\n}\n\nGF_Err stss_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_SyncSampleBox *ptr = (GF_SyncSampleBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->nb_entries = gf_bs_read_u32(bs);\n\tif (ptr->size / 4 <  ptr->nb_entries || (u64)ptr->nb_entries > (u64)SIZE_MAX/sizeof(u32)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in stss\\n\", ptr->nb_entries));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tptr->alloc_size = ptr->nb_entries;\n\tptr->sampleNumbers = (u32 *) gf_malloc( ptr->alloc_size * sizeof(u32));\n\tif (ptr->sampleNumbers == NULL) return GF_OUT_OF_MEM;\n\n\tfor (i = 0; i < ptr->nb_entries; i++) {\n\t\tptr->sampleNumbers[i] = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *stss_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SyncSampleBox, GF_ISOM_BOX_TYPE_STSS);\n\treturn (GF_Box*)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stss_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_SyncSampleBox *ptr = (GF_SyncSampleBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->nb_entries);\n\tfor (i = 0; i < ptr->nb_entries; i++) {\n\t\tgf_bs_write_u32(bs, ptr->sampleNumbers[i]);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err stss_box_size(GF_Box *s)\n{\n\tGF_SyncSampleBox *ptr = (GF_SyncSampleBox *)s;\n\tptr->size += 4 + (4 * ptr->nb_entries);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid stsz_box_del(GF_Box *s)\n{\n\tGF_SampleSizeBox *ptr = (GF_SampleSizeBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->sizes) gf_free(ptr->sizes);\n\tgf_free(ptr);\n}\n\n\nGF_Err stsz_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i, estSize;\n\tGF_SampleSizeBox *ptr = (GF_SampleSizeBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\n\t//support for CompactSizes\n\tif (s->type == GF_ISOM_BOX_TYPE_STSZ) {\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\tptr->sampleSize = gf_bs_read_u32(bs);\n\t\tptr->sampleCount = gf_bs_read_u32(bs);\n\t} else {\n\t\t//24-reserved\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\tgf_bs_read_int(bs, 24);\n\t\ti = gf_bs_read_u8(bs);\n\t\tptr->sampleCount = gf_bs_read_u32(bs);\n\t\tswitch (i) {\n\t\tcase 4:\n\t\tcase 8:\n\t\tcase 16:\n\t\t\tptr->sampleSize = i;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t//try to fix the file\n\t\t\t//no samples, no parsing pb\n\t\t\tif (!ptr->sampleCount) {\n\t\t\t\tptr->sampleSize = 16;\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\testSize = (u32) (ptr->size) / ptr->sampleCount;\n\t\t\tif (!estSize && ((ptr->sampleCount+1)/2 == (ptr->size)) ) {\n\t\t\t\tptr->sampleSize = 4;\n\t\t\t\tbreak;\n\t\t\t} else if (estSize == 1 || estSize == 2) {\n\t\t\t\tptr->sampleSize = 8 * estSize;\n\t\t\t} else {\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t}\n\t}\n\tif (ptr->sampleCount && (u64)ptr->sampleCount > (u64)SIZE_MAX/sizeof(u32)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in stsz\\n\", ptr->sampleCount));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tif (s->type == GF_ISOM_BOX_TYPE_STSZ) {\n\t\tif (! ptr->sampleSize && ptr->sampleCount) {\n\t\t\tif (ptr->sampleCount > ptr->size / 4) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in stsz\\n\", ptr->sampleCount));\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t\tptr->sizes = (u32 *) gf_malloc(ptr->sampleCount * sizeof(u32));\n\t\t\tif (! ptr->sizes) return GF_OUT_OF_MEM;\n\t\t\tptr->alloc_size = ptr->sampleCount;\n\t\t\tfor (i = 0; i < ptr->sampleCount; i++) {\n\t\t\t\tptr->sizes[i] = gf_bs_read_u32(bs);\n\t\t\t\tif (ptr->max_size < ptr->sizes[i])\n\t\t\t\t\tptr->max_size = ptr->sizes[i];\n\t\t\t\tptr->total_size += ptr->sizes[i];\n\t\t\t\tptr->total_samples++;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (ptr->sampleSize==4) {\n\t\t\tif (ptr->sampleCount / 2 > ptr->size) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in stsz\\n\", ptr->sampleCount));\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t} else {\n\t\t\tif (ptr->sampleCount > ptr->size / (ptr->sampleSize/8)) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in stsz\\n\", ptr->sampleCount));\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t}\n\t\t//note we could optimize the mem usage by keeping the table compact\n\t\t//in memory. But that would complicate both caching and editing\n\t\t//we therefore keep all sizes as u32 and uncompress the table\n\t\tptr->sizes = (u32 *) gf_malloc(ptr->sampleCount * sizeof(u32));\n\t\tif (! ptr->sizes) return GF_OUT_OF_MEM;\n\t\tptr->alloc_size = ptr->sampleCount;\n\n\t\tfor (i = 0; i < ptr->sampleCount; ) {\n\t\t\tu32 s_size;\n\t\t\tswitch (ptr->sampleSize) {\n\t\t\tcase 4:\n\t\t\t\ts_size = ptr->sizes[i] = gf_bs_read_int(bs, 4);\n\t\t\t\tif (ptr->max_size < s_size)\n\t\t\t\t\tptr->max_size = s_size;\n\t\t\t\tptr->total_size += s_size;\n\t\t\t\tptr->total_samples++;\n\t\t\t\tif (i+1 < ptr->sampleCount) {\n\t\t\t\t\ts_size = ptr->sizes[i+1] = gf_bs_read_int(bs, 4);\n\t\t\t\t\tif (ptr->max_size < s_size)\n\t\t\t\t\t\tptr->max_size = s_size;\n\t\t\t\t\tptr->total_size += s_size;\n\t\t\t\t\tptr->total_samples++;\n\t\t\t\t} else {\n\t\t\t\t\t//0 padding in odd sample count\n\t\t\t\t\tgf_bs_read_int(bs, 4);\n\t\t\t\t}\n\t\t\t\ti += 2;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\ts_size = ptr->sizes[i] = gf_bs_read_int(bs, ptr->sampleSize);\n\t\t\t\tif (ptr->max_size < s_size)\n\t\t\t\t\tptr->max_size = s_size;\n\t\t\t\tptr->total_size += s_size;\n\t\t\t\tptr->total_samples++;\n\t\t\t\ti += 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *stsz_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleSizeBox, 0);\n\n\t//type is unknown here, can be regular or compact table\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stsz_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_SampleSizeBox *ptr = (GF_SampleSizeBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\t//in both versions this is still valid\n\tif (ptr->type == GF_ISOM_BOX_TYPE_STSZ) {\n\t\tgf_bs_write_u32(bs, ptr->sampleSize);\n\t} else {\n\t\tgf_bs_write_u24(bs, 0);\n\t\tgf_bs_write_u8(bs, ptr->sampleSize);\n\t}\n\tgf_bs_write_u32(bs, ptr->sampleCount);\n\n\tif (ptr->type == GF_ISOM_BOX_TYPE_STSZ) {\n\t\tif (ptr->sampleSize) return GF_OK;\n\t\tfor (i = 0; i < ptr->sampleCount; i++) {\n\t\t\tgf_bs_write_u32(bs, ptr->sizes ? ptr->sizes[i] : 0);\n\t\t}\n\t} else {\n\t\tif (!ptr->sizes) return GF_ISOM_INVALID_FILE;\n\t\tfor (i = 0; i < ptr->sampleCount; ) {\n\t\t\tswitch (ptr->sampleSize) {\n\t\t\tcase 4:\n\t\t\t\tgf_bs_write_int(bs, ptr->sizes[i], 4);\n\t\t\t\tif (i+1 < ptr->sampleCount) {\n\t\t\t\t\tgf_bs_write_int(bs, ptr->sizes[i+1], 4);\n\t\t\t\t} else {\n\t\t\t\t\t//0 padding in odd sample count\n\t\t\t\t\tgf_bs_write_int(bs, 0, 4);\n\t\t\t\t}\n\t\t\t\ti += 2;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgf_bs_write_int(bs, ptr->sizes[i], ptr->sampleSize);\n\t\t\t\ti += 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err stsz_box_size(GF_Box *s)\n{\n\tu32 i, fieldSize, size;\n\tGF_SampleSizeBox *ptr = (GF_SampleSizeBox *)s;\n\n\tptr->size += 8;\n\tif (!ptr->sampleCount) return GF_OK;\n\n\t//regular table\n\tif (ptr->type == GF_ISOM_BOX_TYPE_STSZ) {\n\t\tif (ptr->sampleSize) return GF_OK;\n\t\tptr->size += (4 * ptr->sampleCount);\n\t\treturn GF_OK;\n\t}\n\tif (!ptr->sizes) return GF_ISOM_INVALID_FILE;\n\n\t//compact size table\n\tfieldSize = 4;\n\tsize = ptr->sizes[0];\n\n\tfor (i=0; i < ptr->sampleCount; i++) {\n\t\tif (ptr->sizes[i] <= 0xF) {\n\t\t}\n\t\t//switch to 8-bit table\n\t\telse if (ptr->sizes[i] <= 0xFF) {\n\t\t\tfieldSize = 8;\n\t\t}\n\t\t//switch to 16-bit table\n\t\telse if (ptr->sizes[i] <= 0xFFFF) {\n\t\t\tfieldSize = 16;\n\t\t}\n\t\t//switch to 32-bit table\n\t\telse {\n\t\t\tfieldSize = 32;\n\t\t}\n\n\t\t//check the size\n\t\tif (size != ptr->sizes[i]) size = 0;\n\t}\n\t//if all samples are of the same size, switch to regular (more compact)\n\tif (size) {\n\t\tptr->type = GF_ISOM_BOX_TYPE_STSZ;\n\t\tptr->sampleSize = size;\n\t\tgf_free(ptr->sizes);\n\t\tptr->sizes = NULL;\n\t\treturn GF_OK;\n\t}\n\n\tif (fieldSize == 32) {\n\t\t//oops, doesn't fit in a compact table\n\t\tptr->type = GF_ISOM_BOX_TYPE_STSZ;\n\t\tptr->size += (4 * ptr->sampleCount);\n\t\treturn GF_OK;\n\t}\n\n\t//make sure we are a compact table (no need to change the mem representation)\n\tptr->type = GF_ISOM_BOX_TYPE_STZ2;\n\tptr->sampleSize = fieldSize;\n\tif (fieldSize == 4) {\n\t\t//do not forget the 0 padding field for odd count\n\t\tptr->size += (ptr->sampleCount + 1) / 2;\n\t} else {\n\t\tptr->size += (ptr->sampleCount) * (fieldSize/8);\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid stts_box_del(GF_Box *s)\n{\n\tGF_TimeToSampleBox *ptr = (GF_TimeToSampleBox *)s;\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);\n}\n\n\nGF_Err stts_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tBool logged=GF_FALSE;\n\tGF_TimeToSampleBox *ptr = (GF_TimeToSampleBox *)s;\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tptr->w_LastDTS = 0;\n#endif\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->nb_entries = gf_bs_read_u32(bs);\n\tif (ptr->size / 8 < ptr->nb_entries || (u64)ptr->nb_entries > (u64)SIZE_MAX/sizeof(GF_SttsEntry)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in stts\\n\", ptr->nb_entries));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tptr->alloc_size = ptr->nb_entries;\n\tptr->entries = gf_malloc(sizeof(GF_SttsEntry)*ptr->alloc_size);\n\tif (!ptr->entries) return GF_OUT_OF_MEM;\n\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tptr->entries[i].sampleCount = gf_bs_read_u32(bs);\n\t\tptr->entries[i].sampleDelta = gf_bs_read_u32(bs);\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\t\tptr->w_currentSampleNum += ptr->entries[i].sampleCount;\n\t\tptr->w_LastDTS += (u64)ptr->entries[i].sampleCount * ptr->entries[i].sampleDelta;\n#endif\n\t\tif (ptr->max_ts_delta<ptr->entries[i].sampleDelta)\n\t\t\tptr->max_ts_delta = ptr->entries[i].sampleDelta;\n\n\t\tif (!ptr->entries[i].sampleDelta) {\n\t\t\tif ((i+1<ptr->nb_entries) ) {\n\t\t\t\tif (!logged) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Found stts entry with sample_delta=0 - forbidden ! Fixing to 1\\n\" ));\n\t\t\t\t\tlogged=GF_TRUE;\n\t\t\t\t}\n\t\t\t\tptr->entries[i].sampleDelta = 1;\n\t\t\t} else if (ptr->entries[i].sampleCount>1) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] more than one stts entry at the end of the track with sample_delta=0 - forbidden ! Fixing to 1\\n\" ));\n\t\t\t\tptr->entries[i].sampleDelta = 1;\n\t\t\t}\n\t\t}\n\t\t//cf issue 1644: some media streams may have sample duration > 2^31 (ttml mostly), we cannot patch this\n\t\t//for now we disable the check, one opt could be to have the check only for some media types, or only for the first entry\n#if 0\n\t\telse if ((s32) ptr->entries[i].sampleDelta < 0) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] stts entry %d has negative duration %d - forbidden ! Fixing to 1, sync may get lost (consider re-importing raw media)\\n\", i, (s32) ptr->entries[i].sampleDelta ));\n\t\t\tptr->entries[i].sampleDelta = 1;\n\t\t}\n#endif\n\n\t}\n\tISOM_DECREASE_SIZE(ptr, ptr->nb_entries*8);\n\n\t//remove the last sample delta.\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tif (ptr->nb_entries) ptr->w_LastDTS -= ptr->entries[ptr->nb_entries-1].sampleDelta;\n#endif\n\treturn GF_OK;\n}\n\nGF_Box *stts_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TimeToSampleBox, GF_ISOM_BOX_TYPE_STTS);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stts_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_TimeToSampleBox *ptr = (GF_TimeToSampleBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->nb_entries);\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tgf_bs_write_u32(bs, ptr->entries[i].sampleCount);\n\t\tgf_bs_write_u32(bs, ptr->entries[i].sampleDelta);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err stts_box_size(GF_Box *s)\n{\n\tGF_TimeToSampleBox *ptr = (GF_TimeToSampleBox *)s;\n\tptr->size += 4 + (8 * ptr->nb_entries);\n\treturn GF_OK;\n}\n\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\nvoid tfhd_box_del(GF_Box *s)\n{\n\tGF_TrackFragmentHeaderBox *ptr = (GF_TrackFragmentHeaderBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\nGF_Err tfhd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TrackFragmentHeaderBox *ptr = (GF_TrackFragmentHeaderBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->trackID = gf_bs_read_u32(bs);\n\n\t//The rest depends on the flags\n\tif (ptr->flags & GF_ISOM_TRAF_BASE_OFFSET) {\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\tptr->base_data_offset = gf_bs_read_u64(bs);\n\t}\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_DESC) {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->sample_desc_index = gf_bs_read_u32(bs);\n\t}\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_DUR) {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->def_sample_duration = gf_bs_read_u32(bs);\n\t}\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_SIZE) {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->def_sample_size = gf_bs_read_u32(bs);\n\t}\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_FLAGS) {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->def_sample_flags = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *tfhd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackFragmentHeaderBox, GF_ISOM_BOX_TYPE_TFHD);\n\t//NO FLAGS SET BY DEFAULT\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err tfhd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TrackFragmentHeaderBox *ptr = (GF_TrackFragmentHeaderBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->trackID);\n\n\t//The rest depends on the flags\n\tif (ptr->flags & GF_ISOM_TRAF_BASE_OFFSET) {\n\t\tgf_bs_write_u64(bs, ptr->base_data_offset);\n\t}\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_DESC) {\n\t\tgf_bs_write_u32(bs, ptr->sample_desc_index);\n\t}\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_DUR) {\n\t\tgf_bs_write_u32(bs, ptr->def_sample_duration);\n\t}\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_SIZE) {\n\t\tgf_bs_write_u32(bs, ptr->def_sample_size);\n\t}\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_FLAGS) {\n\t\tgf_bs_write_u32(bs, ptr->def_sample_flags);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err tfhd_box_size(GF_Box *s)\n{\n\tGF_TrackFragmentHeaderBox *ptr = (GF_TrackFragmentHeaderBox *)s;\n\tptr->size += 4;\n\n\t//The rest depends on the flags\n\tif (ptr->flags & GF_ISOM_TRAF_BASE_OFFSET) ptr->size += 8;\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_DESC) ptr->size += 4;\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_DUR) ptr->size += 4;\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_SIZE) ptr->size += 4;\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_FLAGS) ptr->size += 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM_FRAGMENTS*/\n\n\nvoid tims_box_del(GF_Box *s)\n{\n\tGF_TSHintEntryBox *tims = (GF_TSHintEntryBox *)s;\n\tgf_free(tims);\n}\n\nGF_Err tims_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TSHintEntryBox *ptr = (GF_TSHintEntryBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->timeScale = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\nGF_Box *tims_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TSHintEntryBox, GF_ISOM_BOX_TYPE_TIMS);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err tims_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TSHintEntryBox *ptr = (GF_TSHintEntryBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->timeScale);\n\treturn GF_OK;\n}\n\nGF_Err tims_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid tkhd_box_del(GF_Box *s)\n{\n\tGF_TrackHeaderBox *ptr = (GF_TrackHeaderBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n\treturn;\n}\n\n\nGF_Err tkhd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TrackHeaderBox *ptr = (GF_TrackHeaderBox *)s;\n\n\tif (ptr->version == 1) {\n\t\tISOM_DECREASE_SIZE(ptr, 32);\n\t\tptr->creationTime = gf_bs_read_u64(bs);\n\t\tptr->modificationTime = gf_bs_read_u64(bs);\n\t\tptr->trackID = gf_bs_read_u32(bs);\n\t\tptr->reserved1 = gf_bs_read_u32(bs);\n\t\tptr->duration = gf_bs_read_u64(bs);\n\t} else {\n\t\tISOM_DECREASE_SIZE(ptr, 20);\n\t\tptr->creationTime = gf_bs_read_u32(bs);\n\t\tptr->modificationTime = gf_bs_read_u32(bs);\n\t\tptr->trackID = gf_bs_read_u32(bs);\n\t\tptr->reserved1 = gf_bs_read_u32(bs);\n\t\tptr->duration = gf_bs_read_u32(bs);\n\t}\n\tptr->initial_duration = ptr->duration;\n\n\tISOM_DECREASE_SIZE(ptr, 60);\n\tptr->reserved2[0] = gf_bs_read_u32(bs);\n\tptr->reserved2[1] = gf_bs_read_u32(bs);\n\tptr->layer = gf_bs_read_u16(bs);\n\tptr->alternate_group = gf_bs_read_u16(bs);\n\tptr->volume = gf_bs_read_u16(bs);\n\tptr->reserved3 = gf_bs_read_u16(bs);\n\tptr->matrix[0] = gf_bs_read_u32(bs);\n\tptr->matrix[1] = gf_bs_read_u32(bs);\n\tptr->matrix[2] = gf_bs_read_u32(bs);\n\tptr->matrix[3] = gf_bs_read_u32(bs);\n\tptr->matrix[4] = gf_bs_read_u32(bs);\n\tptr->matrix[5] = gf_bs_read_u32(bs);\n\tptr->matrix[6] = gf_bs_read_u32(bs);\n\tptr->matrix[7] = gf_bs_read_u32(bs);\n\tptr->matrix[8] = gf_bs_read_u32(bs);\n\tptr->width = gf_bs_read_u32(bs);\n\tptr->height = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\nGF_Box *tkhd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackHeaderBox, GF_ISOM_BOX_TYPE_TKHD);\n\ttmp->matrix[0] = 0x00010000;\n\ttmp->matrix[4] = 0x00010000;\n\ttmp->matrix[8] = 0x40000000;\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err tkhd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TrackHeaderBox *ptr = (GF_TrackHeaderBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tif (ptr->version == 1) {\n\t\tgf_bs_write_u64(bs, ptr->creationTime);\n\t\tgf_bs_write_u64(bs, ptr->modificationTime);\n\t\tgf_bs_write_u32(bs, ptr->trackID);\n\t\tgf_bs_write_u32(bs, ptr->reserved1);\n\t\tgf_bs_write_u64(bs, ptr->duration);\n\t} else {\n\t\tgf_bs_write_u32(bs, (u32) ptr->creationTime);\n\t\tgf_bs_write_u32(bs, (u32) ptr->modificationTime);\n\t\tgf_bs_write_u32(bs, ptr->trackID);\n\t\tgf_bs_write_u32(bs, ptr->reserved1);\n\t\tgf_bs_write_u32(bs, (u32) ptr->duration);\n\t}\n\tgf_bs_write_u32(bs, ptr->reserved2[0]);\n\tgf_bs_write_u32(bs, ptr->reserved2[1]);\n\tgf_bs_write_u16(bs, ptr->layer);\n\tgf_bs_write_u16(bs, ptr->alternate_group);\n\tgf_bs_write_u16(bs, ptr->volume);\n\tgf_bs_write_u16(bs, ptr->reserved3);\n\tgf_bs_write_u32(bs, ptr->matrix[0]);\n\tgf_bs_write_u32(bs, ptr->matrix[1]);\n\tgf_bs_write_u32(bs, ptr->matrix[2]);\n\tgf_bs_write_u32(bs, ptr->matrix[3]);\n\tgf_bs_write_u32(bs, ptr->matrix[4]);\n\tgf_bs_write_u32(bs, ptr->matrix[5]);\n\tgf_bs_write_u32(bs, ptr->matrix[6]);\n\tgf_bs_write_u32(bs, ptr->matrix[7]);\n\tgf_bs_write_u32(bs, ptr->matrix[8]);\n\tgf_bs_write_u32(bs, ptr->width);\n\tgf_bs_write_u32(bs, ptr->height);\n\treturn GF_OK;\n}\n\nGF_Err tkhd_box_size(GF_Box *s)\n{\n\tGF_TrackHeaderBox *ptr = (GF_TrackHeaderBox *)s;\n\n\tif (ptr->duration==(u64) -1) ptr->version = 0;\n\telse ptr->version = (ptr->duration>0xFFFFFFFF) ? 1 : 0;\n\tptr->size += (ptr->version == 1) ? 32 : 20;\n\tptr->size += 60;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\nvoid traf_box_del(GF_Box *s)\n{\n\tGF_TrackFragmentBox *ptr = (GF_TrackFragmentBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->sub_samples) gf_list_del(ptr->sub_samples);\n\tgf_list_del(ptr->TrackRuns);\n\tif (ptr->sampleGroups) gf_list_del(ptr->sampleGroups);\n\tif (ptr->sampleGroupsDescription) gf_list_del(ptr->sampleGroupsDescription);\n\tif (ptr->sai_sizes) gf_list_del(ptr->sai_sizes);\n\tif (ptr->sai_offsets) gf_list_del(ptr->sai_offsets);\n\tgf_free(ptr);\n}\n\nGF_Err traf_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_TrackFragmentBox *ptr = (GF_TrackFragmentBox *)s;\n\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_TFHD:\n\t\tBOX_FIELD_ASSIGN(tfhd, GF_TrackFragmentHeaderBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_TRUN:\n\t\tBOX_FIELD_LIST_ASSIGN(TrackRuns)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_SDTP:\n\t\tBOX_FIELD_ASSIGN(sdtp, GF_SampleDependencyTypeBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_TFDT:\n\t\tBOX_FIELD_ASSIGN(tfdt, GF_TFBaseMediaDecodeTimeBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_SUBS:\n\t\tBOX_FIELD_LIST_ASSIGN(sub_samples)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_SBGP:\n\tcase GF_ISOM_BOX_TYPE_CSGP:\n\t\tBOX_FIELD_LIST_ASSIGN(sampleGroups)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_SGPD:\n\t\tBOX_FIELD_LIST_ASSIGN(sampleGroupsDescription)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_SAIZ:\n\t\tBOX_FIELD_LIST_ASSIGN(sai_sizes)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_SAIO:\n\t\tBOX_FIELD_LIST_ASSIGN(sai_offsets)\n\t\treturn GF_OK;\n\t//we will throw an error if both PIFF_PSEC and SENC are found. Not such files seen yet\n\tcase GF_ISOM_BOX_TYPE_UUID:\n\t\tif ( ((GF_UUIDBox *)a)->internal_4cc==GF_ISOM_BOX_UUID_PSEC) {\n\t\t\tBOX_FIELD_ASSIGN(sample_encryption, GF_SampleEncryptionBox)\n\t\t\tif (!is_rem)\n\t\t\t\tptr->sample_encryption->traf = ptr;\n\t\t\treturn GF_OK;\n\t\t} else if ( ((GF_UUIDBox *)a)->internal_4cc==GF_ISOM_BOX_UUID_TFXD) {\n\t\t\tBOX_FIELD_ASSIGN(tfxd, GF_MSSTimeExtBox)\n\t\t\treturn GF_OK;\n\t\t} else if ( ((GF_UUIDBox *)a)->internal_4cc==GF_ISOM_BOX_UUID_TFRF) {\n\t\t\tBOX_FIELD_ASSIGN(tfrf, GF_MSSTimeRefBox)\n\t\t\treturn GF_OK;\n\t\t} else {\n\t\t\treturn GF_OK;\n\t\t}\n\tcase GF_ISOM_BOX_TYPE_SENC:\n\t\tBOX_FIELD_ASSIGN(sample_encryption, GF_SampleEncryptionBox)\n\t\tif (!is_rem)\n\t\t\tptr->sample_encryption->traf = ptr;\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err traf_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TrackFragmentBox *ptr = (GF_TrackFragmentBox *)s;\n\tGF_Err e = gf_isom_box_array_read(s, bs);\n\tif (e) return e;\n\n\tif (!ptr->tfhd) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing TrackFragmentHeaderBox \\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *traf_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackFragmentBox, GF_ISOM_BOX_TYPE_TRAF);\n\ttmp->TrackRuns = gf_list_new();\n\n\tif (gf_sys_old_arch_compat())\n\t\ttmp->no_sdtp_first_flags = 1;\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err traf_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err traf_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_TrackFragmentBox *ptr = (GF_TrackFragmentBox *) s;\n\n\t//Header first\n\tgf_isom_check_position(s, (GF_Box *)ptr->tfhd, &pos);\n\tgf_isom_check_position_list(s, ptr->sub_samples, &pos);\n\n\tgf_isom_check_position(s, (GF_Box *)ptr->tfdt, &pos);\n\n\t//cmaf-like\n\tif (ptr->truns_first) {\n\t\tgf_isom_check_position_list(s, ptr->TrackRuns, &pos);\n\t\tgf_isom_check_position_list(s, ptr->sai_sizes, &pos);\n\t\tgf_isom_check_position_list(s, ptr->sai_offsets, &pos);\n\t\t//senc MUST be after saio in GPAC, as senc writing uses info from saio writing\n\t\tgf_isom_check_position(s, (GF_Box *)ptr->sample_encryption, &pos);\n\t\tgf_isom_check_position_list(s, ptr->sampleGroupsDescription, &pos);\n\t\tgf_isom_check_position_list(s, ptr->sampleGroups, &pos);\n\t\t//subsamples will be last\n\t} else {\n\t\tgf_isom_check_position_list(s, ptr->sampleGroupsDescription, &pos);\n\t\tgf_isom_check_position_list(s, ptr->sampleGroups, &pos);\n\t\tgf_isom_check_position_list(s, ptr->sai_sizes, &pos);\n\t\tgf_isom_check_position_list(s, ptr->sai_offsets, &pos);\n\t\tgf_isom_check_position(s, (GF_Box *)ptr->sample_encryption, &pos);\n\t\tgf_isom_check_position_list(s, ptr->TrackRuns, &pos);\n\t}\n\n\t//when sdtp is present (smooth-like) write it after the trun box\n\tgf_isom_check_position(s, (GF_Box *)ptr->sdtp, &pos);\n\n\t//tfxd should be last ...\n\tif (ptr->tfxd)\n\t\tgf_isom_check_position(s, (GF_Box *)ptr->tfxd, &pos);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *tfxd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MSSTimeExtBox, GF_ISOM_BOX_TYPE_UUID);\n\ttmp->internal_4cc = GF_ISOM_BOX_UUID_TFXD;\n\ttmp->version = 1;\n\treturn (GF_Box *)tmp;\n}\n\nvoid tfxd_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\n\nGF_Err tfxd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MSSTimeExtBox *ptr = (GF_MSSTimeExtBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->version = gf_bs_read_u8(bs);\n\tptr->flags = gf_bs_read_u24(bs);\n\n\tif (ptr->version == 0x01) {\n\t\tISOM_DECREASE_SIZE(ptr, 16);\n\t\tptr->absolute_time_in_track_timescale = gf_bs_read_u64(bs);\n\t\tptr->fragment_duration_in_track_timescale = gf_bs_read_u64(bs);\n\t} else {\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\tptr->absolute_time_in_track_timescale = gf_bs_read_u32(bs);\n\t\tptr->fragment_duration_in_track_timescale = gf_bs_read_u32(bs);\n\t}\n\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err tfxd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MSSTimeExtBox *ptr = (GF_MSSTimeExtBox*)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u8(bs, ptr->version);\n\tgf_bs_write_u24(bs, 0);\n\tif (ptr->version) {\n\t\tgf_bs_write_u64(bs, ptr->absolute_time_in_track_timescale);\n\t\tgf_bs_write_u64(bs, ptr->fragment_duration_in_track_timescale);\n\t} else {\n\t\tgf_bs_write_u32(bs, (u32) ptr->absolute_time_in_track_timescale);\n\t\tgf_bs_write_u32(bs, (u32) ptr->fragment_duration_in_track_timescale);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err tfxd_box_size(GF_Box *s)\n{\n\tGF_MSSTimeExtBox *ptr = (GF_MSSTimeExtBox*)s;\n\ts->size += 4 + (ptr->version ? 16 : 8);\n\treturn GF_OK;\n}\n#endif //GPAC_DISABLE_ISOM_WRITE\n\n\n\nGF_Box *tfrf_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MSSTimeRefBox, GF_ISOM_BOX_TYPE_UUID);\n\ttmp->internal_4cc = GF_ISOM_BOX_UUID_TFRF;\n\treturn (GF_Box *)tmp;\n}\n\nvoid tfrf_box_del(GF_Box *s)\n{\n\tGF_MSSTimeRefBox *ptr = (GF_MSSTimeRefBox *)s;\n\tif (ptr->frags) gf_free(ptr->frags);\n\tgf_free(s);\n}\n\n\nGF_Err tfrf_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_MSSTimeRefBox *ptr = (GF_MSSTimeRefBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 5);\n\tptr->version = gf_bs_read_u8(bs);\n\tptr->flags = gf_bs_read_u24(bs);\n\tptr->frags_count = gf_bs_read_u8(bs);\n\tptr->frags = gf_malloc(sizeof(GF_MSSTimeEntry) * ptr->frags_count);\n\tif (!ptr->frags) return GF_OUT_OF_MEM;\n\n\tfor (i=0; i<ptr->frags_count; i++) {\n\t\tif (ptr->version == 0x01) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 16);\n\t\t\tptr->frags[i].absolute_time_in_track_timescale = gf_bs_read_u64(bs);\n\t\t\tptr->frags[i].fragment_duration_in_track_timescale = gf_bs_read_u64(bs);\n\t\t} else {\n\t\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\t\tptr->frags[i].absolute_time_in_track_timescale = gf_bs_read_u32(bs);\n\t\t\tptr->frags[i].fragment_duration_in_track_timescale = gf_bs_read_u32(bs);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err tfrf_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_MSSTimeRefBox *ptr = (GF_MSSTimeRefBox*)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u8(bs, ptr->version);\n\tgf_bs_write_u24(bs, 0);\n\tgf_bs_write_u8(bs, ptr->frags_count);\n\tfor (i=0; i<ptr->frags_count; i++) {\n\t\tif (ptr->version==0x01) {\n\t\t\tgf_bs_write_u64(bs, ptr->frags[i].absolute_time_in_track_timescale);\n\t\t\tgf_bs_write_u64(bs, ptr->frags[i].fragment_duration_in_track_timescale);\n\t\t} else {\n\t\t\tgf_bs_write_u32(bs, (u32) ptr->frags[i].absolute_time_in_track_timescale);\n\t\t\tgf_bs_write_u32(bs, (u32) ptr->frags[i].fragment_duration_in_track_timescale);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err tfrf_box_size(GF_Box *s)\n{\n\tGF_MSSTimeRefBox *ptr = (GF_MSSTimeRefBox*)s;\n\ts->size += 5;\n\tif (ptr->version) s->size += 16 * ptr->frags_count;\n\telse s->size += 8 * ptr->frags_count;\n\treturn GF_OK;\n}\n#endif //GPAC_DISABLE_ISOM_WRITE\n\n#endif /*GPAC_DISABLE_ISOM_FRAGMENTS*/\n\n\nvoid trak_box_del(GF_Box *s)\n{\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tGF_TrackBox *ptr = (GF_TrackBox *)s;\n\tif (ptr->chunk_cache)\n\t\tgf_bs_del(ptr->chunk_cache);\n#endif\n\tgf_free(s);\n}\n\nstatic void stsd_switch_box(GF_BitStream *bs, GF_Box *box, GF_UnknownBox *a, u8 **data, u32 *data_size, u32 *EntryType, GF_SampleDescriptionBox *stsd, u32 stsd_idx)\n{\n\tif (gf_bs_available(bs)) {\n\t\tGF_Err e;\n\t\tu32 count_subb;\n\t\tgf_bs_set_cookie(bs, GF_ISOM_BS_COOKIE_NO_LOGS);\n\t\te = gf_isom_box_array_read(box, bs);\n\t\tcount_subb = box->child_boxes ? gf_list_count(box->child_boxes) : 0;\n\t\tif (count_subb && !e) {\n\t\t\tu32 i;\n\t\t\tGF_BitStream *new_dsi = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\t\t//serialize all unknown boxes\n\t\t\tfor (i=0; i<count_subb; i++) {\n\t\t\t\tGF_UnknownBox *priv = gf_list_get(box->child_boxes, i);\n\t\t\t\tif (priv->type != GF_ISOM_BOX_TYPE_UNKNOWN) continue;\n\t\t\t\tgf_bs_write_u32(new_dsi, 8 + priv->dataSize);\n\t\t\t\tgf_bs_write_u32(new_dsi, priv->original_4cc);\n\t\t\t\tgf_bs_write_data(new_dsi, priv->data, priv->dataSize);\n\t\t\t\tgf_list_rem(box->child_boxes, i);\n\t\t\t\tgf_isom_box_del((GF_Box*)priv);\n\t\t\t\tcount_subb--;\n\t\t\t\ti--;\n\t\t\t}\n\t\t\tif (*data) gf_free(*data);\n\t\t\tgf_bs_get_content(new_dsi, data, data_size);\n\t\t\tgf_bs_del(new_dsi);\n\t\t} else {\n\t\t\t*data_size = 0;\n\t\t}\n\t}\n\tgf_bs_del(bs);\n\tif (!*data_size && *data) {\n\t\tgf_free(*data);\n\t\t*data = NULL;\n\t}\n\tbox->size = 0;\n\t*EntryType = a->original_4cc;\n\tgf_list_rem(stsd->child_boxes, stsd_idx);\n\tgf_isom_box_del((GF_Box *)a);\n\tgf_list_insert(stsd->child_boxes, box, stsd_idx);\n}\n\n\nstatic GF_Err gf_isom_check_sample_desc(GF_TrackBox *trak)\n{\n\tGF_BitStream *bs;\n\tGF_UnknownBox *a;\n\tu32 i;\n\tGF_Err e;\n\tGF_SampleTableBox *stbl;\n\n\tif (!trak->Media || !trak->Media->information) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Track with no media box !\\n\" ));\n\t\treturn GF_OK;\n\t}\n\tif (!trak->Media->information->sampleTable) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Track with no sample table !\\n\" ));\n\t\ttrak->Media->information->sampleTable = (GF_SampleTableBox *) gf_isom_box_new_parent(&trak->Media->information->child_boxes, GF_ISOM_BOX_TYPE_STBL);\n\t}\n\tstbl = trak->Media->information->sampleTable;\n\n\tif (!stbl->SampleDescription) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Track with no sample description box !\\n\" ));\n\t\tstbl->SampleDescription = (GF_SampleDescriptionBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STSD);\n\t\treturn GF_OK;\n\t}\n\n\ti=0;\n\twhile ((a = (GF_UnknownBox*)gf_list_enum(stbl->SampleDescription->child_boxes, &i))) {\n\t\tGF_ProtectionSchemeInfoBox *sinf;\n\t\tu32 base_ent_type = 0;\n\t\tu32 type = a->type;\n\t\tu32 sinf_type = GF_ISOM_BOX_TYPE_SINF;\n\t\tswitch (a->type) {\n\t\tcase GF_ISOM_BOX_TYPE_RESV:\n\t\t\tsinf_type = GF_ISOM_BOX_TYPE_RINF;\n\t\tcase GF_ISOM_BOX_TYPE_ENCS:\n\t\tcase GF_ISOM_BOX_TYPE_ENCA:\n\t\tcase GF_ISOM_BOX_TYPE_ENCV:\n\t\tcase GF_ISOM_BOX_TYPE_ENCT:\n\t\t\tsinf = (GF_ProtectionSchemeInfoBox *) gf_isom_box_find_child(a->child_boxes, sinf_type);\n\t\t\tif (!sinf || !sinf->original_format) return GF_ISOM_INVALID_FILE;\n\t\t\ttype = sinf->original_format->data_format;\n\t\t\tbase_ent_type = ((GF_SampleEntryBox *)a)->internal_type;\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (type) {\n\t\tcase GF_ISOM_BOX_TYPE_MP4S:\n\t\t\tif (base_ent_type && (base_ent_type != GF_ISOM_SAMPLE_ENTRY_MP4S)) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Protected sample entry %s uses incompatible sample description %s\\n\", gf_4cc_to_str(a->type), gf_4cc_to_str(type) ));\n\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t\tcontinue;\n\n\t\tcase GF_ISOM_SUBTYPE_3GP_AMR:\n\t\tcase GF_ISOM_SUBTYPE_3GP_AMR_WB:\n\t\tcase GF_ISOM_SUBTYPE_3GP_EVRC:\n\t\tcase GF_ISOM_SUBTYPE_3GP_QCELP:\n\t\tcase GF_ISOM_SUBTYPE_3GP_SMV:\n\t\tcase GF_ISOM_BOX_TYPE_MP4A:\n\t\tcase GF_ISOM_BOX_TYPE_MP3:\n\t\tcase GF_ISOM_BOX_TYPE_MHA1:\n\t\tcase GF_ISOM_BOX_TYPE_MHA2:\n\t\tcase GF_ISOM_BOX_TYPE_MHM1:\n\t\tcase GF_ISOM_BOX_TYPE_MHM2:\n\t\tcase GF_ISOM_BOX_TYPE_OPUS:\n\t\tcase GF_ISOM_BOX_TYPE_AC3:\n\t\tcase GF_ISOM_BOX_TYPE_EC3:\n\t\tcase GF_QT_SUBTYPE_RAW_AUD:\n\t\tcase GF_QT_SUBTYPE_TWOS:\n\t\tcase GF_QT_SUBTYPE_SOWT:\n\t\tcase GF_QT_SUBTYPE_FL32:\n\t\tcase GF_QT_SUBTYPE_FL64:\n\t\tcase GF_QT_SUBTYPE_IN24:\n\t\tcase GF_QT_SUBTYPE_IN32:\n\t\tcase GF_QT_SUBTYPE_ULAW:\n\t\tcase GF_QT_SUBTYPE_ALAW:\n\t\tcase GF_QT_SUBTYPE_ADPCM:\n\t\tcase GF_QT_SUBTYPE_IMA_ADPCM:\n\t\tcase GF_QT_SUBTYPE_DVCA:\n\t\tcase GF_QT_SUBTYPE_QDMC:\n\t\tcase GF_QT_SUBTYPE_QDMC2:\n\t\tcase GF_QT_SUBTYPE_QCELP:\n\t\tcase GF_QT_SUBTYPE_kMP3:\n\t\tcase GF_ISOM_BOX_TYPE_IPCM:\n\t\tcase GF_ISOM_BOX_TYPE_FPCM:\n\t\t\tif (base_ent_type && (base_ent_type != GF_ISOM_SAMPLE_ENTRY_AUDIO))\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\tcontinue;\n\n\t\tcase GF_ISOM_BOX_TYPE_MP4V:\n\t\tcase GF_ISOM_SUBTYPE_3GP_H263:\n\t\tcase GF_ISOM_BOX_TYPE_AVC1:\n\t\tcase GF_ISOM_BOX_TYPE_AVC2:\n\t\tcase GF_ISOM_BOX_TYPE_AVC3:\n\t\tcase GF_ISOM_BOX_TYPE_AVC4:\n\t\tcase GF_ISOM_BOX_TYPE_SVC1:\n\t\tcase GF_ISOM_BOX_TYPE_MVC1:\n\t\tcase GF_ISOM_BOX_TYPE_HVC1:\n\t\tcase GF_ISOM_BOX_TYPE_HEV1:\n\t\tcase GF_ISOM_BOX_TYPE_HVC2:\n\t\tcase GF_ISOM_BOX_TYPE_HEV2:\n\t\tcase GF_ISOM_BOX_TYPE_HVT1:\n\t\tcase GF_ISOM_BOX_TYPE_LHV1:\n\t\tcase GF_ISOM_BOX_TYPE_LHE1:\n\t\tcase GF_ISOM_BOX_TYPE_AV01:\n\t\tcase GF_ISOM_BOX_TYPE_VP08:\n\t\tcase GF_ISOM_BOX_TYPE_VP09:\n\t\tcase GF_ISOM_BOX_TYPE_AV1C:\n\t\tcase GF_ISOM_BOX_TYPE_JPEG:\n\t\tcase GF_ISOM_BOX_TYPE_PNG:\n\t\tcase GF_ISOM_BOX_TYPE_JP2K:\n\t\tcase GF_ISOM_BOX_TYPE_MJP2:\n\t\tcase GF_QT_SUBTYPE_APCH:\n\t\tcase GF_QT_SUBTYPE_APCO:\n\t\tcase GF_QT_SUBTYPE_APCN:\n\t\tcase GF_QT_SUBTYPE_APCS:\n\t\tcase GF_QT_SUBTYPE_AP4X:\n\t\tcase GF_QT_SUBTYPE_AP4H:\n\t\tcase GF_ISOM_BOX_TYPE_VVC1:\n\t\tcase GF_ISOM_BOX_TYPE_VVI1:\n\t\tcase GF_QT_SUBTYPE_RAW_VID:\n\t\tcase GF_QT_SUBTYPE_YUYV:\n\t\tcase GF_QT_SUBTYPE_UYVY:\n\t\tcase GF_QT_SUBTYPE_YUV444:\n\t\tcase GF_QT_SUBTYPE_YUVA444:\n\t\tcase GF_QT_SUBTYPE_YUV422_10:\n\t\tcase GF_QT_SUBTYPE_YUV444_10:\n\t\tcase GF_QT_SUBTYPE_YUV422_16:\n\t\tcase GF_QT_SUBTYPE_YUV420:\n\t\tcase GF_QT_SUBTYPE_I420:\n\t\tcase GF_QT_SUBTYPE_IYUV:\n\t\tcase GF_QT_SUBTYPE_YV12:\n\t\tcase GF_QT_SUBTYPE_YVYU:\n\t\tcase GF_QT_SUBTYPE_RGBA:\n\t\tcase GF_QT_SUBTYPE_ABGR:\n\t\tcase GF_ISOM_BOX_TYPE_DVHE:\n\t\tcase GF_ISOM_BOX_TYPE_DVH1:\n\t\tcase GF_ISOM_BOX_TYPE_DVA1:\n\t\tcase GF_ISOM_BOX_TYPE_DVAV:\n\t\tcase GF_ISOM_BOX_TYPE_DAV1:\n\t\t\tif (base_ent_type && (base_ent_type != GF_ISOM_SAMPLE_ENTRY_VIDEO))\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\tcontinue;\n\n\n\t\tcase GF_ISOM_BOX_TYPE_METX:\n\t\tcase GF_ISOM_BOX_TYPE_METT:\n\t\tcase GF_ISOM_BOX_TYPE_STXT:\n\t\tcase GF_ISOM_BOX_TYPE_TX3G:\n\t\tcase GF_ISOM_BOX_TYPE_TEXT:\n\t\tcase GF_ISOM_BOX_TYPE_GHNT:\n\t\tcase GF_ISOM_BOX_TYPE_RTP_STSD:\n\t\tcase GF_ISOM_BOX_TYPE_SRTP_STSD:\n\t\tcase GF_ISOM_BOX_TYPE_FDP_STSD:\n\t\tcase GF_ISOM_BOX_TYPE_RRTP_STSD:\n\t\tcase GF_ISOM_BOX_TYPE_RTCP_STSD:\n\t\tcase GF_ISOM_BOX_TYPE_DIMS:\n\t\tcase GF_ISOM_BOX_TYPE_LSR1:\n\t\tcase GF_ISOM_BOX_TYPE_WVTT:\n\t\tcase GF_ISOM_BOX_TYPE_STPP:\n\t\tcase GF_ISOM_BOX_TYPE_SBTT:\n\t\t\tif (base_ent_type && (base_ent_type != GF_ISOM_SAMPLE_ENTRY_GENERIC))\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\tcontinue;\n\n\n\t\tcase GF_ISOM_BOX_TYPE_UNKNOWN:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (gf_box_valid_in_parent((GF_Box *) a, \"stsd\")) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Unexpected box %s in stsd!\\n\", gf_4cc_to_str(a->type)));\n\t\t\tcontinue;\n\t\t}\n\t\t//we are sure to have an unknown box here\n\t\tassert(a->type==GF_ISOM_BOX_TYPE_UNKNOWN);\n\n\t\tif (!a->data || (a->dataSize<8) ) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Sample description %s does not have at least 8 bytes!\\n\", gf_4cc_to_str(a->original_4cc) ));\n\t\t\tcontinue;\n\t\t}\n\t\telse if (a->dataSize > a->size) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Sample description %s has wrong data size %d!\\n\", gf_4cc_to_str(a->original_4cc), a->dataSize));\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*only process visual or audio\n\t\tnote: no need for new_box_parent here since we always store sample descriptions in child_boxes*/\n\t\tswitch (trak->Media->handler->handlerType) {\n        case GF_ISOM_MEDIA_VISUAL:\n\t\tcase GF_ISOM_MEDIA_AUXV:\n\t\tcase GF_ISOM_MEDIA_PICT:\n\t\t{\n\t\t\tGF_GenericVisualSampleEntryBox *genv = (GF_GenericVisualSampleEntryBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_GNRV);\n\t\t\tbs = gf_bs_new(a->data, a->dataSize, GF_BITSTREAM_READ);\n\t\t\tgenv->size = a->size-8;\n\t\t\tgf_isom_video_sample_entry_read((GF_VisualSampleEntryBox *) genv, bs);\n\n\t\t\tstsd_switch_box(bs, (GF_Box *) genv, a, &genv->data, &genv->data_size, &genv->EntryType, trak->Media->information->sampleTable->SampleDescription, i-1);\n\t\t}\n\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_AUDIO:\n\t\t{\n\t\t\tGF_GenericAudioSampleEntryBox *gena = (GF_GenericAudioSampleEntryBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_GNRA);\n\t\t\tgena->size = a->size-8;\n\t\t\tbs = gf_bs_new(a->data, a->dataSize, GF_BITSTREAM_READ);\n\t\t\tgf_isom_audio_sample_entry_read((GF_AudioSampleEntryBox *) gena, bs);\n\n\t\t\tstsd_switch_box(bs, (GF_Box *) gena, a, &gena->data, &gena->data_size, &gena->EntryType, trak->Media->information->sampleTable->SampleDescription, i-1);\n\t\t}\n\t\tbreak;\n\n\t\tdefault:\n\t\t{\n\t\t\tGF_GenericSampleEntryBox *genm = (GF_GenericSampleEntryBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_GNRM);\n\t\t\tgenm->size = a->size-8;\n\t\t\tbs = gf_bs_new(a->data, a->dataSize, GF_BITSTREAM_READ);\n\n\t\t\te = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)genm, bs);\n\t\t\tif (e) return e;\n\n\t\t\tstsd_switch_box(bs, (GF_Box *) genm, a, &genm->data, &genm->data_size, &genm->EntryType, trak->Media->information->sampleTable->SampleDescription, i-1);\n\t\t}\n\t\tbreak;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err trak_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_TrackBox *ptr = (GF_TrackBox *)s;\n\tif (!a) return GF_OK;\n\tswitch(a->type) {\n\tcase GF_ISOM_BOX_TYPE_TKHD:\n\t\tBOX_FIELD_ASSIGN(Header, GF_TrackHeaderBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_EDTS:\n\t\tBOX_FIELD_ASSIGN(editBox, GF_EditBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_UDTA:\n\t\tBOX_FIELD_ASSIGN(udta, GF_UserDataBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_META:\n\t\tBOX_FIELD_ASSIGN(meta, GF_MetaBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_TREF:\n\t\tBOX_FIELD_ASSIGN(References, GF_TrackReferenceBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_MDIA:\n\t\tBOX_FIELD_ASSIGN(Media, GF_MediaBox)\n\t\tif (!is_rem)\n\t\t\t((GF_MediaBox *)a)->mediaTrack = ptr;\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_TRGR:\n\t\tBOX_FIELD_ASSIGN(groups, GF_TrackGroupBox)\n\t\treturn GF_OK;\n\tcase GF_QT_BOX_TYPE_TAPT:\n\t\tBOX_FIELD_ASSIGN(Aperture, GF_Box)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_SENC:\n\t\tBOX_FIELD_ASSIGN(sample_encryption, GF_SampleEncryptionBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_UUID:\n\t\tif (((GF_UnknownUUIDBox *)a)->internal_4cc == GF_ISOM_BOX_UUID_PSEC) {\n\t\t\tBOX_FIELD_ASSIGN(sample_encryption, GF_SampleEncryptionBox)\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err trak_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_TrackBox *ptr = (GF_TrackBox *)s;\n\te = gf_isom_box_array_read(s, bs);\n\tif (e) return e;\n\te = gf_isom_check_sample_desc(ptr);\n\tif (e) return e;\n\n\tif (!ptr->Header) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing TrackHeaderBox\\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tif (!ptr->Media) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing MediaBox\\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tif (!ptr->Media->information || !ptr->Media->information->sampleTable) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid MediaBox\\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tif (!ptr->Media->information->sampleTable->SampleSize || (ptr->Media->information->sampleTable->SampleSize->sampleCount==0)) {\n\t\tif (ptr->Header->initial_duration) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Track with no samples but duration defined, ignoring duration\\n\"));\n\t\t\tptr->Header->initial_duration = 0;\n\t\t}\n\t}\n\n\tfor (i=0; i<gf_list_count(ptr->Media->information->sampleTable->child_boxes); i++) {\n\t\tGF_Box *a = gf_list_get(ptr->Media->information->sampleTable->child_boxes, i);\n\t\tif ((a->type ==GF_ISOM_BOX_TYPE_UUID) && (((GF_UUIDBox *)a)->internal_4cc == GF_ISOM_BOX_UUID_PSEC)) {\n\t\t\tptr->sample_encryption = (struct __sample_encryption_box *) a;\n\t\t\tbreak;\n\t\t}\n\t\telse if (a->type == GF_ISOM_BOX_TYPE_SENC) {\n\t\t\tptr->sample_encryption = (struct __sample_encryption_box *)a;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn e;\n}\n\nGF_Box *trak_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackBox, GF_ISOM_BOX_TYPE_TRAK);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err trak_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err trak_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_TrackBox *ptr = (GF_TrackBox *)s;\n\n\tif (ptr->sample_encryption && ptr->sample_encryption->load_needed) {\n\t\tif (!ptr->moov || !ptr->moov->mov || !ptr->moov->mov->movieFileMap)\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\tGF_Err e = senc_Parse(ptr->moov->mov->movieFileMap->bs, ptr, NULL, ptr->sample_encryption);\n\t\tif (e) return e;\n\t}\n\n\tgf_isom_check_position(s, (GF_Box *)ptr->Header, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->Aperture, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->References, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->editBox, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->Media, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->meta, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->groups, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->udta, &pos);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid stri_box_del(GF_Box *s)\n{\n\tGF_SubTrackInformationBox *ptr = (GF_SubTrackInformationBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->attribute_list) gf_free(ptr->attribute_list);\n\tgf_free(ptr);\n}\n\nGF_Err stri_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tsize_t i;\n\tGF_SubTrackInformationBox *ptr = (GF_SubTrackInformationBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 8)\n\tptr->switch_group = gf_bs_read_u16(bs);\n\tptr->alternate_group = gf_bs_read_u16(bs);\n\tptr->sub_track_id = gf_bs_read_u32(bs);\n\tptr->attribute_count = ptr->size / 4;\n\tif ((u64)ptr->attribute_count > (u64)SIZE_MAX/sizeof(u32)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid size %llu in stri\\n\", ptr->size));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tGF_SAFE_ALLOC_N(ptr->attribute_list, (size_t)ptr->attribute_count, u32);\n\tif (!ptr->attribute_list) return GF_OUT_OF_MEM;\n\tfor (i = 0; i < ptr->attribute_count; i++) {\n\t\tISOM_DECREASE_SIZE(ptr, 4)\n\t\tptr->attribute_list[i] = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *stri_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SubTrackInformationBox, GF_ISOM_BOX_TYPE_STRI);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stri_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_SubTrackInformationBox *ptr = (GF_SubTrackInformationBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u16(bs, ptr->switch_group);\n\tgf_bs_write_u16(bs, ptr->alternate_group);\n\tgf_bs_write_u32(bs, ptr->sub_track_id);\n\tfor (i = 0; i < ptr->attribute_count; i++) {\n\t\tgf_bs_write_u32(bs, ptr->attribute_list[i]);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err stri_box_size(GF_Box *s)\n{\n\tGF_SubTrackInformationBox *ptr = (GF_SubTrackInformationBox *)s;\n\n\tptr->size += 8 + 4 * ptr->attribute_count;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid stsg_box_del(GF_Box *s)\n{\n\tGF_SubTrackSampleGroupBox *ptr = (GF_SubTrackSampleGroupBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->group_description_index) gf_free(ptr->group_description_index);\n\tgf_free(ptr);\n}\n\nGF_Err stsg_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_SubTrackSampleGroupBox *ptr = (GF_SubTrackSampleGroupBox *)s;\n\tISOM_DECREASE_SIZE(s, 6);\n\tptr->grouping_type = gf_bs_read_u32(bs);\n\tptr->nb_groups = gf_bs_read_u16(bs);\n\tISOM_DECREASE_SIZE(s, ptr->nb_groups*4);\n\tGF_SAFE_ALLOC_N(ptr->group_description_index, ptr->nb_groups, u32);\n\tif (!ptr->group_description_index) return GF_OUT_OF_MEM;\n\tfor (i = 0; i < ptr->nb_groups; i++) {\n\t\tptr->group_description_index[i] = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *stsg_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SubTrackSampleGroupBox, GF_ISOM_BOX_TYPE_STSG);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stsg_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_SubTrackSampleGroupBox *ptr = (GF_SubTrackSampleGroupBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->grouping_type);\n\tgf_bs_write_u16(bs, ptr->nb_groups);\n\tfor (i = 0; i < ptr->nb_groups; i++) {\n\t\tgf_bs_write_u32(bs, ptr->group_description_index[i]);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err stsg_box_size(GF_Box *s)\n{\n\tGF_SubTrackSampleGroupBox *ptr = (GF_SubTrackSampleGroupBox *)s;\n\tptr->size += 6 + 4 * ptr->nb_groups;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid strk_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err strk_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_SubTrackBox *ptr = (GF_SubTrackBox *)s;\n\tif (!a) return GF_OK;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_STRI:\n\t\tBOX_FIELD_ASSIGN(info, GF_SubTrackInformationBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_STRD:\n\t\tBOX_FIELD_ASSIGN(strd, GF_Box)\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err strk_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SubTrackBox *ptr = (GF_SubTrackBox *)s;\n\te = gf_isom_box_array_read(s, bs);\n\tif (e) return e;\n\n\tif (!ptr->info) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing SubTrackInformationBox\\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *strk_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SubTrackBox, GF_ISOM_BOX_TYPE_STRK);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err strk_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err strk_box_size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid tref_box_del(GF_Box *s)\n{\n\tGF_TrackReferenceBox *ptr = (GF_TrackReferenceBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err tref_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *tref_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackReferenceBox, GF_ISOM_BOX_TYPE_TREF);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err tref_box_write(GF_Box *s, GF_BitStream *bs)\n{\n//\tGF_TrackReferenceBox *ptr = (GF_TrackReferenceBox *)s;\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err tref_box_size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid reftype_box_del(GF_Box *s)\n{\n\tGF_TrackReferenceTypeBox *ptr = (GF_TrackReferenceTypeBox *)s;\n\tif (!ptr) return;\n\tif (ptr->trackIDs) gf_free(ptr->trackIDs);\n\tgf_free(ptr);\n}\n\n\nGF_Err reftype_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 bytesToRead;\n\tu32 i;\n\tGF_TrackReferenceTypeBox *ptr = (GF_TrackReferenceTypeBox *)s;\n\n\tbytesToRead = (u32) (ptr->size);\n\tif (!bytesToRead) return GF_OK;\n\n\tptr->trackIDCount = (u32) (bytesToRead) / sizeof(u32);\n\tptr->trackIDs = (GF_ISOTrackID *) gf_malloc(ptr->trackIDCount * sizeof(GF_ISOTrackID));\n\tif (!ptr->trackIDs) return GF_OUT_OF_MEM;\n\n\tfor (i = 0; i < ptr->trackIDCount; i++) {\n\t\tptr->trackIDs[i] = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *reftype_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackReferenceTypeBox, GF_ISOM_BOX_TYPE_REFT);\n\treturn (GF_Box *)tmp;\n}\n\n\nGF_Err reftype_AddRefTrack(GF_TrackReferenceTypeBox *ref, GF_ISOTrackID trackID, u16 *outRefIndex)\n{\n\tu32 i;\n\tif (!ref || !trackID) return GF_BAD_PARAM;\n\n\tif (outRefIndex) *outRefIndex = 0;\n\t//don't add a dep if already here !!\n\tfor (i = 0; i < ref->trackIDCount; i++) {\n\t\tif (ref->trackIDs[i] == trackID) {\n\t\t\tif (outRefIndex) *outRefIndex = i+1;\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\n\tref->trackIDs = (GF_ISOTrackID *) gf_realloc(ref->trackIDs, (ref->trackIDCount + 1) * sizeof(GF_ISOTrackID) );\n\tif (!ref->trackIDs) return GF_OUT_OF_MEM;\n\tref->trackIDs[ref->trackIDCount] = trackID;\n\tref->trackIDCount++;\n\tif (outRefIndex) *outRefIndex = ref->trackIDCount;\n\treturn GF_OK;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err reftype_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_TrackReferenceTypeBox *ptr = (GF_TrackReferenceTypeBox *)s;\n\tif (ptr->reference_type == GF_ISOM_BOX_TYPE_UUID) return GF_BAD_PARAM;\n\tptr->type = ptr->reference_type;\n\te = gf_isom_box_write_header(s, bs);\n\tptr->type = GF_ISOM_BOX_TYPE_REFT;\n\tif (e) return e;\n\tfor (i = 0; i < ptr->trackIDCount; i++) {\n\t\tgf_bs_write_u32(bs, ptr->trackIDs[i]);\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err reftype_box_size(GF_Box *s)\n{\n\tGF_TrackReferenceTypeBox *ptr = (GF_TrackReferenceTypeBox *)s;\n\tif (ptr->trackIDCount)\n\t\tptr->size += (ptr->trackIDCount * sizeof(u32));\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\nvoid trex_box_del(GF_Box *s)\n{\n\tGF_TrackExtendsBox *ptr = (GF_TrackExtendsBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err trex_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TrackExtendsBox *ptr = (GF_TrackExtendsBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 20);\n\tptr->trackID = gf_bs_read_u32(bs);\n\tptr->def_sample_desc_index = gf_bs_read_u32(bs);\n\tptr->def_sample_duration = gf_bs_read_u32(bs);\n\tptr->def_sample_size = gf_bs_read_u32(bs);\n\tptr->def_sample_flags = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\nGF_Box *trex_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackExtendsBox, GF_ISOM_BOX_TYPE_TREX);\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err trex_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TrackExtendsBox *ptr = (GF_TrackExtendsBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->trackID);\n\t//we always write 1 in trex default sample desc as using 0 breaks chrome/opera/...\n\tgf_bs_write_u32(bs, ptr->def_sample_desc_index ? ptr->def_sample_desc_index : 1);\n\tgf_bs_write_u32(bs, ptr->def_sample_duration);\n\tgf_bs_write_u32(bs, ptr->def_sample_size);\n\tgf_bs_write_u32(bs, ptr->def_sample_flags);\n\treturn GF_OK;\n}\n\nGF_Err trex_box_size(GF_Box *s)\n{\n\tGF_TrackExtendsBox *ptr = (GF_TrackExtendsBox *)s;\n\tptr->size += 20;\n\treturn GF_OK;\n}\n\n\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid trep_box_del(GF_Box *s)\n{\n\tGF_TrackExtensionPropertiesBox *ptr = (GF_TrackExtensionPropertiesBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err trep_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TrackExtensionPropertiesBox *ptr = (GF_TrackExtensionPropertiesBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->trackID = gf_bs_read_u32(bs);\n\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *trep_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackExtensionPropertiesBox, GF_ISOM_BOX_TYPE_TREP);\n\ttmp->child_boxes = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err trep_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TrackExtensionPropertiesBox *ptr = (GF_TrackExtensionPropertiesBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->trackID);\n\treturn GF_OK;\n}\n\nGF_Err trep_box_size(GF_Box *s)\n{\n\tGF_TrackExtensionPropertiesBox *ptr = (GF_TrackExtensionPropertiesBox *)s;\n\tptr->size += 4;\n\treturn GF_OK;\n}\n\n\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM_FRAGMENTS*/\n\n\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\nvoid trun_box_del(GF_Box *s)\n{\n\tGF_TrackFragmentRunBox *ptr = (GF_TrackFragmentRunBox *)s;\n\tif (ptr == NULL) return;\n\n\tif (ptr->samples) gf_free(ptr->samples);\n\tif (ptr->cache) gf_bs_del(ptr->cache);\n\tif (ptr->sample_order) gf_free(ptr->sample_order);\n\tif (ptr->sample_refs) {\n\t\twhile (gf_list_count(ptr->sample_refs)) {\n\t\t\tGF_TrafSampleRef *sref = gf_list_pop_back(ptr->sample_refs);\n\t\t\tif (!sref->ref) gf_free(sref->data);\n\t\t\tgf_free(sref);\n\t\t}\n\t\tgf_list_del(ptr->sample_refs);\n\t}\n\tgf_free(ptr);\n}\n\n#ifdef GF_ENABLE_CTRN\n\nstatic u32 ctrn_field_size(u32 field_idx)\n{\n\tif (field_idx==3) return 4;\n\treturn field_idx;\n}\n\nu32 gf_isom_ctrn_field_size_bits(u32 field_idx)\n{\n\tif (field_idx==3) return 32;\n\treturn field_idx*8;\n}\nstatic u32 ctrn_read_flags(GF_BitStream *bs, u32 nbbits)\n{\n\tu32 val = gf_bs_read_int(bs, nbbits);\n\tif (nbbits==16) val <<= 16;\n\telse if (nbbits==8) val <<= 24;\n\treturn val;\n}\n\nstatic GF_Err ctrn_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i, count, flags, first_idx=0;\n\tBool inherit_dur, inherit_size, inherit_flags, inherit_ctso;\n\tGF_TrunEntry *ent;\n\tGF_TrackFragmentRunBox *ptr = (GF_TrackFragmentRunBox *)s;\n\tflags = ptr->flags;\n\tptr->ctrn_flags = flags;\n\tptr->flags = 0;\n\n\tptr->sample_count = gf_bs_read_u16(bs);\n\tISOM_DECREASE_SIZE(ptr, 2);\n\n\tif (flags & GF_ISOM_TRUN_DATA_OFFSET) {\n\t\tif (flags & GF_ISOM_CTRN_DATAOFFSET_16) {\n\t\t\tptr->data_offset = gf_bs_read_u16(bs);\n\t\t\tISOM_DECREASE_SIZE(ptr, 2);\n\t\t} else {\n\t\t\tptr->data_offset = gf_bs_read_u32(bs);\n\t\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\t}\n\t\tptr->flags |= GF_ISOM_TRUN_DATA_OFFSET;\n\t}\n\tif (flags & GF_ISOM_CTRN_CTSO_MULTIPLIER) {\n\t\tptr->ctso_multiplier = gf_bs_read_u16(bs);\n\t\tISOM_DECREASE_SIZE(ptr, 2);\n\t}\n\t/*no sample dur/sample_flag/size/ctso for first or following, create a pack sample */\n\tif (! (flags & 0x00FFFF00)) {\n\t\tGF_SAFEALLOC(ent, GF_TrunEntry);\n\t\tif (!ent) return GF_OUT_OF_MEM;\n\t\tent->nb_pack = ptr->sample_count;\n\t\tgf_list_add(ptr->entries, ent);\n\t\treturn GF_OK;\n\t}\n\t/*allocate all entries*/\n\tfor (i=0; i<ptr->sample_count; i++) {\n\t\tGF_SAFEALLOC(ent, GF_TrunEntry);\n\t\tif (!ent) return GF_OUT_OF_MEM;\n\t\tgf_list_add(ptr->entries, ent);\n\t}\n\t//unpack flags\n\tptr->ctrn_first_dur = (flags>>22) & 0x3;\n\tptr->ctrn_first_size = (flags>>20) & 0x3;\n\tptr->ctrn_first_sample_flags = (flags>>18) & 0x3;\n\tptr->ctrn_first_ctts = (flags>>16) & 0x3;\n\tptr->ctrn_dur = (flags>>14) & 0x3;\n\tptr->ctrn_size = (flags>>12) & 0x3;\n\tptr->ctrn_sample_flags = (flags>>10) & 0x3;\n\tptr->ctrn_ctts = (flags>>8) & 0x3;\n\n\tinherit_dur = flags & GF_ISOM_CTRN_INHERIT_DUR;\n\tinherit_size = flags & GF_ISOM_CTRN_INHERIT_SIZE;\n\tinherit_flags = flags & GF_ISOM_CTRN_INHERIT_FLAGS;\n\tinherit_ctso = flags & GF_ISOM_CTRN_INHERIT_CTSO;\n\n\tif (flags & GF_ISOM_CTRN_FIRST_SAMPLE) {\n\t\tent = gf_list_get(ptr->entries, 0);\n\t\tfirst_idx = 1;\n\t\tif (!inherit_dur && ptr->ctrn_first_dur) {\n\t\t\tent->Duration = gf_bs_read_int(bs, gf_isom_ctrn_field_size_bits(ptr->ctrn_first_dur) );\n\t\t\tISOM_DECREASE_SIZE(ptr, ctrn_field_size(ptr->ctrn_first_dur) );\n\t\t}\n\t\tif (!inherit_size && ptr->ctrn_first_size) {\n\t\t\tent->size = gf_bs_read_int(bs, gf_isom_ctrn_field_size_bits(ptr->ctrn_first_size) );\n\t\t\tISOM_DECREASE_SIZE(ptr, ctrn_field_size(ptr->ctrn_first_size) );\n\t\t}\n\t\tif (!inherit_flags && ptr->ctrn_first_sample_flags) {\n\t\t\tent->flags = ctrn_read_flags(bs, gf_isom_ctrn_field_size_bits(ptr->ctrn_first_sample_flags) );\n\t\t\tISOM_DECREASE_SIZE(ptr, ctrn_field_size(ptr->ctrn_first_sample_flags) );\n\t\t}\n\t\tif (!inherit_ctso && ptr->ctrn_first_ctts) {\n\t\t\tent->CTS_Offset = gf_bs_read_int(bs, gf_isom_ctrn_field_size_bits(ptr->ctrn_first_ctts) );\n\t\t\tISOM_DECREASE_SIZE(ptr, ctrn_field_size(ptr->ctrn_first_ctts) );\n\t\t\tif (ptr->ctso_multiplier)\n\t\t\t\tent->CTS_Offset *= (s32) ptr->ctso_multiplier;\n\t\t}\n\t}\n\tcount = ptr->sample_count - first_idx;\n\tif (!inherit_dur && ptr->ctrn_dur) {\n\t\tu32 nbbits = gf_isom_ctrn_field_size_bits(ptr->ctrn_dur);\n\t\tISOM_DECREASE_SIZE(ptr, count * nbbits / 8);\n\t\tfor (i=first_idx; i<ptr->sample_count; i++) {\n\t\t\tent = gf_list_get(ptr->entries, i);\n\t\t\tent->Duration = gf_bs_read_int(bs, nbbits);\n\t\t}\n\t}\n\tif (!inherit_size && ptr->ctrn_size) {\n\t\tu32 nbbits = gf_isom_ctrn_field_size_bits(ptr->ctrn_size);\n\t\tISOM_DECREASE_SIZE(ptr, count * nbbits / 8);\n\t\tfor (i=first_idx; i<ptr->sample_count; i++) {\n\t\t\tent = gf_list_get(ptr->entries, i);\n\t\t\tent->size = gf_bs_read_int(bs, nbbits);\n\t\t}\n\t}\n\tif (!inherit_flags && ptr->ctrn_sample_flags) {\n\t\tu32 nbbits = gf_isom_ctrn_field_size_bits(ptr->ctrn_sample_flags);\n\t\tISOM_DECREASE_SIZE(ptr, count * nbbits / 8);\n\t\tfor (i=first_idx; i<ptr->sample_count; i++) {\n\t\t\tent = gf_list_get(ptr->entries, i);\n\t\t\tent->flags = ctrn_read_flags(bs, nbbits);\n\t\t}\n\t}\n\tif (!inherit_ctso && ptr->ctrn_ctts) {\n\t\tu32 nbbits = gf_isom_ctrn_field_size_bits(ptr->ctrn_ctts);\n\t\tISOM_DECREASE_SIZE(ptr, count * nbbits / 8);\n\t\tfor (i=first_idx; i<ptr->sample_count; i++) {\n\t\t\tent = gf_list_get(ptr->entries, i);\n\t\t\tent->CTS_Offset = gf_bs_read_int(bs, nbbits);\n\t\t\tif (ptr->ctso_multiplier)\n\t\t\t\tent->CTS_Offset *= (s32) ptr->ctso_multiplier;\n\t\t}\n\t}\n\n\treturn GF_OK;\n}\n#endif\n\nGF_Err trun_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_TrackFragmentRunBox *ptr = (GF_TrackFragmentRunBox *)s;\n\n#ifdef GF_ENABLE_CTRN\n\tif (ptr->type == GF_ISOM_BOX_TYPE_CTRN) {\n\t\tptr->type = GF_ISOM_BOX_TYPE_TRUN;\n\t\tptr->use_ctrn = GF_TRUE;\n\t\treturn ctrn_box_read(s, bs);\n\t}\n#endif\n\n\t//check this is a good file\n\tif ((ptr->flags & GF_ISOM_TRUN_FIRST_FLAG) && (ptr->flags & GF_ISOM_TRUN_FLAGS))\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->sample_count = gf_bs_read_u32(bs);\n\n\t//The rest depends on the flags\n\tif (ptr->flags & GF_ISOM_TRUN_DATA_OFFSET) {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->data_offset = gf_bs_read_u32(bs);\n\t}\n\tif (ptr->flags & GF_ISOM_TRUN_FIRST_FLAG) {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->first_sample_flags = gf_bs_read_u32(bs);\n\t}\n\tif (! (ptr->flags & (GF_ISOM_TRUN_DURATION | GF_ISOM_TRUN_SIZE | GF_ISOM_TRUN_FLAGS | GF_ISOM_TRUN_CTS_OFFSET) ) ) {\n\t\tptr->samples = gf_malloc(sizeof(GF_TrunEntry));\n\t\tif (!ptr->samples) return GF_OUT_OF_MEM;\n\t\t//memset to 0 !!\n\t\tmemset(ptr->samples, 0, sizeof(GF_TrunEntry));\n\t\tptr->sample_alloc = ptr->nb_samples = 1;\n\t\tptr->samples[0].nb_pack = ptr->sample_count;\n\t} else {\n\t\t//if we get here, at least one flag (so at least 4 bytes) is set, check size\n\t\tif (ptr->sample_count * 4 > ptr->size) {\n\t\t\tISOM_DECREASE_SIZE(ptr, ptr->sample_count*4);\n\t\t}\n\t\tif ((u64)ptr->sample_count > (u64)SIZE_MAX/sizeof(GF_TrunEntry)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of samples %d in trun\\n\", ptr->sample_count));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t\tptr->samples = gf_malloc(sizeof(GF_TrunEntry) * ptr->sample_count);\n\t\tif (!ptr->samples) return GF_OUT_OF_MEM;\n\t\tptr->sample_alloc = ptr->nb_samples = ptr->sample_count;\n\t\t//memset to 0 upfront\n\t\tmemset(ptr->samples, 0, ptr->sample_count * sizeof(GF_TrunEntry));\n\n\t\t//read each entry (even though nothing may be written)\n\t\tfor (i=0; i<ptr->sample_count; i++) {\n\t\t\tu32 trun_size = 0;\n\t\t\tGF_TrunEntry *p = &ptr->samples[i];\n\n\t\t\tif (ptr->flags & GF_ISOM_TRUN_DURATION) {\n\t\t\t\tp->Duration = gf_bs_read_u32(bs);\n\t\t\t\ttrun_size += 4;\n\n\t\t\t\tif (!ptr->min_duration || (ptr->min_duration>p->Duration))\n\t\t\t\t\tptr->min_duration = p->Duration;\n\t\t\t}\n\t\t\tif (ptr->flags & GF_ISOM_TRUN_SIZE) {\n\t\t\t\tp->size = gf_bs_read_u32(bs);\n\t\t\t\ttrun_size += 4;\n\t\t\t}\n\t\t\t//SHOULDN'T BE USED IF GF_ISOM_TRUN_FIRST_FLAG IS DEFINED\n\t\t\tif (ptr->flags & GF_ISOM_TRUN_FLAGS) {\n\t\t\t\tp->flags = gf_bs_read_u32(bs);\n\t\t\t\ttrun_size += 4;\n\t\t\t}\n\t\t\tif (ptr->flags & GF_ISOM_TRUN_CTS_OFFSET) {\n\t\t\t\tif (ptr->version==0) {\n\t\t\t\t\tp->CTS_Offset = (u32) gf_bs_read_u32(bs);\n\t\t\t\t} else {\n\t\t\t\t\tp->CTS_Offset = (s32) gf_bs_read_u32(bs);\n\t\t\t\t}\n\t\t\t\ttrun_size += 4;\n\t\t\t}\n\t\t\tISOM_DECREASE_SIZE(ptr, trun_size);\n\t\t}\n\t}\n\t/*todo parse sample reorder*/\n\tif (ptr->size) {\n\t\tgf_bs_skip_bytes(bs, ptr->size);\n\t\tptr->size = 0;\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *trun_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackFragmentRunBox, GF_ISOM_BOX_TYPE_TRUN);\n\t//NO FLAGS SET BY DEFAULT\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n#ifdef GF_ENABLE_CTRN\nstatic void ctrn_write_sample_flags(GF_BitStream *bs, u32 flags, u32 field_size)\n{\n\tif (!field_size) return;\n\n\tif (field_size==8) flags = flags>>24;\n\telse if (field_size==16) flags = flags>>16;\n\tgf_bs_write_int(bs, flags, field_size);\n}\n\n\nstatic void ctrn_write_ctso(GF_TrackFragmentRunBox *ctrn, GF_BitStream *bs, u32 ctso, u32 field_size)\n{\n\tif (!field_size) return;\n\n\tif (ctrn->ctso_multiplier) {\n\t\tgf_bs_write_int(bs, ctso / ctrn->ctso_multiplier, field_size);\n\t} else {\n\t\tgf_bs_write_int(bs, ctso, field_size);\n\t}\n}\n\nGF_Err ctrn_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i, count, flags;\n\tGF_TrunEntry *ent;\n\tGF_TrackFragmentRunBox *ctrn = (GF_TrackFragmentRunBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\tflags = ctrn->flags;\n\tctrn->flags = ctrn->ctrn_flags;\n\tctrn->type = GF_ISOM_BOX_TYPE_CTRN;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tctrn->flags = flags;\n\tctrn->type = GF_ISOM_BOX_TYPE_TRUN;\n\n\tgf_bs_write_u16(bs, ctrn->sample_count);\n\tif (ctrn->flags & GF_ISOM_TRUN_DATA_OFFSET) {\n\t\tif (ctrn->ctrn_flags & GF_ISOM_CTRN_DATAOFFSET_16) {\n\t\t\tgf_bs_write_u16(bs, ctrn->data_offset);\n\t\t} else {\n\t\t\tgf_bs_write_u32(bs, ctrn->data_offset);\n\t\t}\n\t}\n\tif (ctrn->ctso_multiplier) {\n\t\tgf_bs_write_u16(bs, ctrn->ctso_multiplier);\n\t}\n\t/*we always write first sample using first flags*/\n\tent = gf_list_get(ctrn->entries, 0);\n\tgf_bs_write_int(bs, ent->Duration, gf_isom_ctrn_field_size_bits(ctrn->ctrn_first_dur) );\n\tgf_bs_write_int(bs, ent->size, gf_isom_ctrn_field_size_bits(ctrn->ctrn_first_size) );\n\tctrn_write_sample_flags(bs, ent->flags, gf_isom_ctrn_field_size_bits(ctrn->ctrn_first_sample_flags) );\n\tctrn_write_ctso(ctrn,bs, ent->CTS_Offset, gf_isom_ctrn_field_size_bits(ctrn->ctrn_first_ctts) );\n\n\tcount = gf_list_count(ctrn->entries);\n\tif (ctrn->ctrn_dur) {\n\t\tu32 nbbits = gf_isom_ctrn_field_size_bits(ctrn->ctrn_dur);\n\t\tfor (i=1; i<count; i++) {\n\t\t\tGF_TrunEntry *a_ent = gf_list_get(ctrn->entries, i);\n\t\t\tgf_bs_write_int(bs, a_ent->Duration, nbbits);\n\t\t}\n\t}\n\tif (ctrn->ctrn_size) {\n\t\tu32 nbbits = gf_isom_ctrn_field_size_bits(ctrn->ctrn_size);\n\t\tfor (i=1; i<count; i++) {\n\t\t\tGF_TrunEntry *a_ent = gf_list_get(ctrn->entries, i);\n\t\t\tgf_bs_write_int(bs, a_ent->size, nbbits);\n\t\t}\n\t}\n\tif (ctrn->ctrn_sample_flags) {\n\t\tu32 nbbits = gf_isom_ctrn_field_size_bits(ctrn->ctrn_sample_flags);\n\t\tfor (i=1; i<count; i++) {\n\t\t\tGF_TrunEntry *a_ent = gf_list_get(ctrn->entries, i);\n\t\t\tctrn_write_sample_flags(bs, a_ent->flags, nbbits);\n\t\t}\n\t}\n\tif (ctrn->ctrn_ctts) {\n\t\tu32 nbbits = gf_isom_ctrn_field_size_bits(ctrn->ctrn_ctts);\n\t\tfor (i=1; i<count; i++) {\n\t\t\tGF_TrunEntry *a_ent = gf_list_get(ctrn->entries, i);\n\t\t\tctrn_write_ctso(ctrn, bs, a_ent->CTS_Offset, nbbits);\n\t\t}\n\t}\n\n\treturn GF_OK;\n}\n#endif\n\nGF_Err trun_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_TrackFragmentRunBox *ptr = (GF_TrackFragmentRunBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\n#ifdef GF_ENABLE_CTRN\n\tif (ptr->use_ctrn)\n\t\treturn ctrn_box_write(s, bs);\n#endif\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->sample_count);\n\n\t//The rest depends on the flags\n\tif (ptr->flags & GF_ISOM_TRUN_DATA_OFFSET) {\n\t\tgf_bs_write_u32(bs, ptr->data_offset);\n\t}\n\tif (ptr->flags & GF_ISOM_TRUN_FIRST_FLAG) {\n\t\tgf_bs_write_u32(bs, ptr->first_sample_flags);\n\t}\n\n\tif (ptr->flags & (GF_ISOM_TRUN_DURATION | GF_ISOM_TRUN_SIZE | GF_ISOM_TRUN_FLAGS | GF_ISOM_TRUN_CTS_OFFSET) )  {\n\t\tfor (i=0; i<ptr->nb_samples; i++) {\n\t\t\tGF_TrunEntry *p = &ptr->samples[i];\n\n\t\t\tif (ptr->flags & GF_ISOM_TRUN_DURATION) {\n\t\t\t\tgf_bs_write_u32(bs, p->Duration);\n\t\t\t}\n\t\t\tif (ptr->flags & GF_ISOM_TRUN_SIZE) {\n\t\t\t\tgf_bs_write_u32(bs, p->size);\n\t\t\t}\n\t\t\t//SHOULDN'T BE USED IF GF_ISOM_TRUN_FIRST_FLAG IS DEFINED\n\t\t\tif (ptr->flags & GF_ISOM_TRUN_FLAGS) {\n\t\t\t\tgf_bs_write_u32(bs, p->flags);\n\t\t\t}\n\t\t\tif (ptr->flags & GF_ISOM_TRUN_CTS_OFFSET) {\n\t\t\t\tif (ptr->version==0) {\n\t\t\t\t\tgf_bs_write_u32(bs, p->CTS_Offset);\n\t\t\t\t} else {\n\t\t\t\t\tgf_bs_write_u32(bs, (u32) p->CTS_Offset);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ptr->sample_order) {\n\t\tu32 nb_bits = 8;\n\t\tif (ptr->sample_count>0xFFFFFF) nb_bits = 32;\n\t\telse if (ptr->sample_count>0xFFFF) nb_bits = 24;\n\t\telse if (ptr->sample_count>0xFF) nb_bits = 16;\n\n\t\tfor (i=0; i<ptr->sample_count; i++) {\n\t\t\tgf_bs_write_int(bs, ptr->sample_order[i], nb_bits);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n#ifdef GF_ENABLE_CTRN\nstatic u32 ctrn_sample_flags_to_index(u32 val)\n{\n\tif (!val) return 0;\n\tif (val & 0x0000FFFF)\n\t\treturn 3;\n\tif (val & 0x00FF0000)\n\t\treturn 2;\n\treturn 1;\n}\nstatic u32 ctrn_u32_to_index(u32 val)\n{\n\tif (!val) return 0;\n\tif (val<=255) return 1;\n\tif (val<=65535) return 2;\n\treturn 3;\n}\nstatic u32 ctrn_s32_to_index(s32 val)\n{\n\tif (!val) return 0;\n\tif (ABS(val)<=127) return 1;\n\tif (ABS(val)<=32767) return 2;\n\treturn 3;\n}\nstatic u32 ctrn_ctts_to_index(GF_TrackFragmentRunBox *ctrn, s32 ctts)\n{\n\tif (!(ctrn->flags & GF_ISOM_TRUN_CTS_OFFSET))\n\t\treturn 0;\n\n\tif (!ctts) return 0;\n\n\tif (ctrn->version) {\n\t\tif (ctrn->ctso_multiplier) return ctrn_s32_to_index(ctts / ctrn->ctso_multiplier);\n\t\treturn ctrn_s32_to_index(ctts);\n\t}\n\tassert(ctts>0);\n\tif (ctrn->ctso_multiplier) return ctrn_u32_to_index((u32)ctts / ctrn->ctso_multiplier);\n\treturn ctrn_s32_to_index((u32)ctts);\n}\n\nstatic GF_Err ctrn_box_size(GF_TrackFragmentRunBox *ctrn)\n{\n\tBool use_ctso_multi = GF_TRUE;\n\tu32 i, count;\n\tGF_TrunEntry *ent;\n\n\tctrn->ctrn_flags = 0;\n\tctrn->ctrn_first_dur = ctrn->ctrn_first_size = ctrn->ctrn_first_sample_flags = ctrn->ctrn_first_ctts = 0;\n\tctrn->ctrn_dur = ctrn->ctrn_size = ctrn->ctrn_sample_flags = ctrn->ctrn_ctts = 0;\n\n\tctrn->size += 2; //16 bits for sample count\n\tif (ctrn->flags & GF_ISOM_TRUN_DATA_OFFSET) {\n\t\tctrn->ctrn_flags |= GF_ISOM_TRUN_DATA_OFFSET;\n\t\tif (ABS(ctrn->data_offset) < 32767) {\n\t\t\tctrn->size += 2;\n\t\t\tctrn->ctrn_flags |= GF_ISOM_CTRN_DATAOFFSET_16;\n\t\t} else\n\t\t\tctrn->size += 4;\n\t}\n\n\tcount = gf_list_count(ctrn->entries);\n\tif (ctrn->ctso_multiplier && (ctrn->flags & GF_ISOM_TRUN_CTS_OFFSET) && (ctrn->ctso_multiplier<=0xFFFF) ) {\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_TrunEntry *a_ent = gf_list_get(ctrn->entries, i);\n\t\t\tif (a_ent->CTS_Offset % ctrn->ctso_multiplier) {\n\t\t\t\tuse_ctso_multi = GF_FALSE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tuse_ctso_multi = GF_FALSE;\n\t}\n\tif (ctrn->use_inherit) {\n\t\tuse_ctso_multi = GF_FALSE;\n\t\tctrn->ctrn_flags |= 0xB0; //duration=1,size=0,flags=1,cts=1 << 4\n\t}\n\n\tif (use_ctso_multi) {\n\t\tctrn->size += 2;\n\t\tctrn->ctrn_flags |= GF_ISOM_CTRN_CTSO_MULTIPLIER;\n\t} else {\n\t\tctrn->ctso_multiplier = 0;\n\t}\n\n\t/*we always write first sample using first flags*/\n\tent = gf_list_get(ctrn->entries, 0);\n\tctrn->ctrn_flags |= GF_ISOM_CTRN_FIRST_SAMPLE;\n\n\tif (!ctrn->use_inherit && (ctrn->flags & GF_ISOM_TRUN_DURATION)) {\n\t\tctrn->ctrn_first_dur = ctrn_u32_to_index(ent->Duration);\n\t\tif (ctrn->ctrn_first_dur) {\n\t\t\tctrn->size += ctrn_field_size(ctrn->ctrn_first_dur);\n\t\t\tctrn->ctrn_flags |= ctrn->ctrn_first_dur<<22;\n\t\t}\n\t}\n\n\tif (ctrn->flags & GF_ISOM_TRUN_SIZE) {\n\t\tctrn->ctrn_first_size = ctrn_u32_to_index(ent->size);\n\t\tif (ctrn->ctrn_first_size) {\n\t\t\tctrn->size += ctrn_field_size(ctrn->ctrn_first_size);\n\t\t\tctrn->ctrn_flags |= ctrn->ctrn_first_size<<20;\n\t\t}\n\t}\n\n\tif (!ctrn->use_inherit && (ctrn->flags & GF_ISOM_TRUN_FLAGS)) {\n\t\tctrn->ctrn_first_sample_flags = ctrn_sample_flags_to_index(ent->flags);\n\t\tif (ctrn->ctrn_first_sample_flags) {\n\t\t\tctrn->size += ctrn_field_size(ctrn->ctrn_first_sample_flags);\n\t\t\tctrn->ctrn_flags |= ctrn->ctrn_first_sample_flags<<18;\n\t\t}\n\t}\n\tif (!ctrn->use_inherit && (ctrn->flags & GF_ISOM_TRUN_CTS_OFFSET)) {\n\t\tctrn->ctrn_first_ctts = ctrn_ctts_to_index(ctrn, ent->CTS_Offset);\n\t\tif (ctrn->ctrn_first_ctts) {\n\t\t\tctrn->size += ctrn_field_size(ctrn->ctrn_first_ctts);\n\t\t\tctrn->ctrn_flags |= ctrn->ctrn_first_ctts<<16;\n\t\t}\n\t}\n\n\tfor (i=1; i<count; i++) {\n\t\tu8 field_idx;\n\t\tGF_TrunEntry *a_ent = gf_list_get(ctrn->entries, i);\n\n\t\tif (!ctrn->use_inherit && (ctrn->flags & GF_ISOM_TRUN_DURATION)) {\n\t\t\tfield_idx = ctrn_u32_to_index(a_ent->Duration);\n\t\t\tif (ctrn->ctrn_dur < field_idx)\n\t\t\t\tctrn->ctrn_dur = field_idx;\n\t\t}\n\t\tif (ctrn->flags & GF_ISOM_TRUN_SIZE) {\n\t\t\tfield_idx = ctrn_u32_to_index(a_ent->size);\n\t\t\tif (ctrn->ctrn_size < field_idx)\n\t\t\t\tctrn->ctrn_size = field_idx;\n\t\t}\n\t\tif (!ctrn->use_inherit && (ctrn->flags & GF_ISOM_TRUN_FLAGS)) {\n\t\t\tfield_idx = ctrn_sample_flags_to_index(a_ent->flags);\n\t\t\tif (ctrn->ctrn_sample_flags < field_idx)\n\t\t\t\tctrn->ctrn_sample_flags = field_idx;\n\t\t}\n\t\tif (!ctrn->use_inherit) {\n\t\t\tfield_idx = ctrn_ctts_to_index(ctrn, a_ent->CTS_Offset);\n\t\t\tif (ctrn->ctrn_ctts < field_idx)\n\t\t\t\tctrn->ctrn_ctts = field_idx;\n\t\t}\n\t}\n\tcount-=1;\n\tif (ctrn->ctrn_dur) {\n\t\tctrn->size += count * ctrn_field_size(ctrn->ctrn_dur);\n\t\tctrn->ctrn_flags |= ctrn->ctrn_dur<<14;\n\t}\n\tif (ctrn->ctrn_size) {\n\t\tctrn->size += count * ctrn_field_size(ctrn->ctrn_size);\n\t\tctrn->ctrn_flags |= ctrn->ctrn_size<<12;\n\t}\n\tif (ctrn->ctrn_sample_flags) {\n\t\tctrn->size += count * ctrn_field_size(ctrn->ctrn_sample_flags);\n\t\tctrn->ctrn_flags |= ctrn->ctrn_sample_flags<<10;\n\t}\n\tif (ctrn->ctrn_ctts) {\n\t\tctrn->size += count * ctrn_field_size(ctrn->ctrn_ctts);\n\t\tctrn->ctrn_flags |= ctrn->ctrn_ctts<<8;\n\t}\n\treturn GF_OK;\n}\n#endif\n\nGF_Err trun_box_size(GF_Box *s)\n{\n\tGF_TrackFragmentRunBox *ptr = (GF_TrackFragmentRunBox *)s;\n\n#ifdef GF_ENABLE_CTRN\n\tif (ptr->use_ctrn)\n\t\treturn ctrn_box_size(ptr);\n#endif\n\n\tptr->size += 4;\n\t//The rest depends on the flags\n\tif (ptr->flags & GF_ISOM_TRUN_DATA_OFFSET) ptr->size += 4;\n\tif (ptr->flags & GF_ISOM_TRUN_FIRST_FLAG) ptr->size += 4;\n\n\tif (ptr->sample_order) {\n\t\tu32 nb_bytes = 1;\n\t\tif (ptr->sample_count>0xFFFFFF) nb_bytes = 4;\n\t\telse if (ptr->sample_count>0xFFFF) nb_bytes = 3;\n\t\telse if (ptr->sample_count>0xFF) nb_bytes = 2;\n\t\tptr->size += ptr->sample_count*nb_bytes;\n\t}\n\n\tif (! (ptr->flags & (GF_ISOM_TRUN_DURATION | GF_ISOM_TRUN_SIZE | GF_ISOM_TRUN_FLAGS | GF_ISOM_TRUN_CTS_OFFSET) ) ) {\n\t\treturn GF_OK;\n\t}\n\n\t//if nothing to do, this will be skipped automatically\n\tif (ptr->flags & GF_ISOM_TRUN_DURATION) ptr->size += 4*ptr->nb_samples;\n\tif (ptr->flags & GF_ISOM_TRUN_SIZE) ptr->size += 4*ptr->nb_samples;\n\t//SHOULDN'T BE USED IF GF_ISOM_TRUN_FIRST_FLAG IS DEFINED\n\tif (ptr->flags & GF_ISOM_TRUN_FLAGS) ptr->size += 4*ptr->nb_samples;\n\tif (ptr->flags & GF_ISOM_TRUN_CTS_OFFSET) ptr->size += 4*ptr->nb_samples;\n\n\treturn GF_OK;\n}\n\n\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM_FRAGMENTS*/\n\n\nvoid tsro_box_del(GF_Box *s)\n{\n\tGF_TimeOffHintEntryBox *tsro = (GF_TimeOffHintEntryBox *)s;\n\tgf_free(tsro);\n}\n\nGF_Err tsro_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TimeOffHintEntryBox *ptr = (GF_TimeOffHintEntryBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->TimeOffset = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\nGF_Box *tsro_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TimeOffHintEntryBox, GF_ISOM_BOX_TYPE_TSRO);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err tsro_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TimeOffHintEntryBox *ptr = (GF_TimeOffHintEntryBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->TimeOffset);\n\treturn GF_OK;\n}\n\nGF_Err tsro_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid udta_box_del(GF_Box *s)\n{\n\tu32 i;\n\tGF_UserDataMap *map;\n\tGF_UserDataBox *ptr = (GF_UserDataBox *)s;\n\tif (ptr == NULL) return;\n\ti=0;\n\twhile ((map = (GF_UserDataMap *)gf_list_enum(ptr->recordList, &i))) {\n\t\tgf_isom_box_array_del(map->boxes);\n\t\tgf_free(map);\n\t}\n\tgf_list_del(ptr->recordList);\n\tgf_free(ptr);\n}\n\nGF_UserDataMap *udta_getEntry(GF_UserDataBox *ptr, u32 box_type, bin128 *uuid)\n{\n\tu32 i;\n\tGF_UserDataMap *map;\n\tif (ptr == NULL) return NULL;\n\ti=0;\n\twhile ((map = (GF_UserDataMap *)gf_list_enum(ptr->recordList, &i))) {\n\t\tif (map->boxType == box_type) {\n\t\t\tif ((box_type != GF_ISOM_BOX_TYPE_UUID) || !uuid) return map;\n\t\t\tif (!memcmp(map->uuid, *uuid, 16)) return map;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nGF_Err udta_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_Err e;\n\tu32 box_type;\n\tGF_UserDataMap *map;\n\tGF_UserDataBox *ptr = (GF_UserDataBox *)s;\n\tif (!ptr) return GF_BAD_PARAM;\n\tif (!a) return GF_OK;\n\n\t//detach from parent list if any\n\tgf_list_del_item(ptr->child_boxes, a);\n\n\t/* for unknown udta boxes, we reference them by their original box type */\n\tbox_type = a->type;\n\tif (box_type == GF_ISOM_BOX_TYPE_UNKNOWN) {\n\t\tGF_UnknownBox* unkn = (GF_UnknownBox *)a;\n\t\tbox_type = unkn->original_4cc;\n\t}\n\n\tmap = udta_getEntry(ptr, box_type, (a->type==GF_ISOM_BOX_TYPE_UUID) ? & ((GF_UUIDBox *)a)->uuid : NULL);\n\tif (map == NULL) {\n\t\tif (is_rem) return GF_OK;\n\n\t\tmap = (GF_UserDataMap *) gf_malloc(sizeof(GF_UserDataMap));\n\t\tif (map == NULL) return GF_OUT_OF_MEM;\n\t\tmemset(map, 0, sizeof(GF_UserDataMap));\n\n\t\tmap->boxType = box_type;\n\t\tif (a->type == GF_ISOM_BOX_TYPE_UUID)\n\t\t\tmemcpy(map->uuid, ((GF_UUIDBox *)a)->uuid, 16);\n\t\tmap->boxes = gf_list_new();\n\t\tif (!map->boxes) {\n\t\t\tgf_free(map);\n\t\t\treturn GF_OUT_OF_MEM;\n\t\t}\n\t\te = gf_list_add(ptr->recordList, map);\n\t\tif (e) return e;\n\t}\n\tif (is_rem) {\n\t\tgf_list_del_item(map->boxes, a);\n\t\treturn GF_OK;\n\t}\n\tu32 i, count = gf_list_count(map->boxes);\n\tfor (i=0; i<count; i++) {\n\t\tGF_Box *b = gf_list_get(map->boxes, i);\n\t\tu32 btype = b->type;\n\t\tif (b->type==GF_ISOM_BOX_TYPE_UNKNOWN) btype = ((GF_UnknownBox*)b)->original_4cc;\n\t\tif (btype != box_type) continue;\n\t\tif (box_type == GF_ISOM_BOX_TYPE_UUID) {\n\t\t\tif (memcmp( ((GF_UUIDBox *)a)->uuid, ((GF_UUIDBox *)b)->uuid, 16)) continue;\n\t\t}\n\t\tgf_isom_box_del(b);\n\t\tgf_list_rem(map->boxes, i);\n\t\tbreak;\n\t}\n\treturn gf_list_add(map->boxes, a);\n}\n\n\nGF_Err udta_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e = gf_isom_box_array_read(s, bs);\n\tif (e) return e;\n\tif (s->size==4) {\n\t\tu32 val = gf_bs_read_u32(bs);\n\t\ts->size = 0;\n\t\tif (val) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] udta has 4 remaining bytes set to %08X but they should be 0\\n\", val));\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *udta_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_UserDataBox, GF_ISOM_BOX_TYPE_UDTA);\n\ttmp->recordList = gf_list_new();\n\tif (!tmp->recordList) {\n\t\tgf_free(tmp);\n\t\treturn NULL;\n\t}\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err udta_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_UserDataMap *map;\n\tGF_UserDataBox *ptr = (GF_UserDataBox *)s;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\ti=0;\n\twhile ((map = (GF_UserDataMap *)gf_list_enum(ptr->recordList, &i))) {\n\t\t//warning: here we are not passing the actual \"parent\" of the list\n\t\t//but the UDTA box. The parent itself is not an box, we don't care about it\n\t\te = gf_isom_box_array_write(s, map->boxes, bs);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err udta_box_size(GF_Box *s)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_UserDataMap *map;\n\tGF_UserDataBox *ptr = (GF_UserDataBox *)s;\n\n\ti=0;\n\twhile ((map = (GF_UserDataMap *)gf_list_enum(ptr->recordList, &i))) {\n\t\t//warning: here we are not passing the actual \"parent\" of the list\n\t\t//but the UDTA box. The parent itself is not an box, we don't care about it\n\t\te = gf_isom_box_array_size(s, map->boxes);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid vmhd_box_del(GF_Box *s)\n{\n\tGF_VideoMediaHeaderBox *ptr = (GF_VideoMediaHeaderBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err vmhd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_VideoMediaHeaderBox *ptr = (GF_VideoMediaHeaderBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 8);\n\tptr->reserved = gf_bs_read_u64(bs);\n\treturn GF_OK;\n}\n\nGF_Box *vmhd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_VideoMediaHeaderBox, GF_ISOM_BOX_TYPE_VMHD);\n\ttmp->flags = 1;\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err vmhd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_VideoMediaHeaderBox *ptr = (GF_VideoMediaHeaderBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u64(bs, ptr->reserved);\n\treturn GF_OK;\n}\n\nGF_Err vmhd_box_size(GF_Box *s)\n{\n\tGF_VideoMediaHeaderBox *ptr = (GF_VideoMediaHeaderBox *)s;\n\tptr->size += 8;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid void_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\n\nGF_Err void_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tif (s->size) return GF_ISOM_INVALID_FILE;\n\treturn GF_OK;\n}\n\nGF_Box *void_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_Box, GF_ISOM_BOX_TYPE_VOID);\n\treturn tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err void_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tgf_bs_write_u32(bs, 0);\n\treturn GF_OK;\n}\n\nGF_Err void_box_size(GF_Box *s)\n{\n\ts->size = 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Box *pdin_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ProgressiveDownloadBox, GF_ISOM_BOX_TYPE_PDIN);\n\treturn (GF_Box *)tmp;\n}\n\n\nvoid pdin_box_del(GF_Box *s)\n{\n\tGF_ProgressiveDownloadBox *ptr = (GF_ProgressiveDownloadBox*)s;\n\tif (ptr == NULL) return;\n\tif (ptr->rates) gf_free(ptr->rates);\n\tif (ptr->times) gf_free(ptr->times);\n\tgf_free(ptr);\n}\n\n\nGF_Err pdin_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_ProgressiveDownloadBox *ptr = (GF_ProgressiveDownloadBox*)s;\n\n\tptr->count = (u32) (ptr->size) / 8;\n\tptr->rates = (u32*)gf_malloc(sizeof(u32)*ptr->count);\n\tif (!ptr->rates) return GF_OUT_OF_MEM;\n\tptr->times = (u32*)gf_malloc(sizeof(u32)*ptr->count);\n\tif (!ptr->times) return GF_OUT_OF_MEM;\n\tfor (i=0; i<ptr->count; i++) {\n\t\tptr->rates[i] = gf_bs_read_u32(bs);\n\t\tptr->times[i] = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err pdin_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_ProgressiveDownloadBox *ptr = (GF_ProgressiveDownloadBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tfor (i=0; i<ptr->count; i++) {\n\t\tgf_bs_write_u32(bs, ptr->rates[i]);\n\t\tgf_bs_write_u32(bs, ptr->times[i]);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err pdin_box_size(GF_Box *s)\n{\n\tGF_ProgressiveDownloadBox *ptr = (GF_ProgressiveDownloadBox *)s;\n\tptr->size += 8*ptr->count;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n\nGF_Box *sdtp_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleDependencyTypeBox, GF_ISOM_BOX_TYPE_SDTP);\n\treturn (GF_Box *)tmp;\n}\n\n\nvoid sdtp_box_del(GF_Box *s)\n{\n\tGF_SampleDependencyTypeBox *ptr = (GF_SampleDependencyTypeBox*)s;\n\tif (ptr == NULL) return;\n\tif (ptr->sample_info) gf_free(ptr->sample_info);\n\tgf_free(ptr);\n}\n\n\nGF_Err sdtp_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_SampleDependencyTypeBox *ptr = (GF_SampleDependencyTypeBox*)s;\n\n\t/*out-of-order sdtp, assume no padding at the end*/\n\tif (!ptr->sampleCount) ptr->sampleCount = (u32) ptr->size;\n\telse if (ptr->sampleCount > (u32) ptr->size) return GF_ISOM_INVALID_FILE;\n\n\tptr->sample_info = (u8 *) gf_malloc(sizeof(u8)*ptr->sampleCount);\n\tif (!ptr->sample_info) return GF_OUT_OF_MEM;\n\tptr->sample_alloc = ptr->sampleCount;\n\tgf_bs_read_data(bs, (char*)ptr->sample_info, ptr->sampleCount);\n\tISOM_DECREASE_SIZE(ptr, ptr->sampleCount);\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err sdtp_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SampleDependencyTypeBox *ptr = (GF_SampleDependencyTypeBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_data(bs, (char*)ptr->sample_info, ptr->sampleCount);\n\treturn GF_OK;\n}\n\nGF_Err sdtp_box_size(GF_Box *s)\n{\n\tGF_SampleDependencyTypeBox *ptr = (GF_SampleDependencyTypeBox *)s;\n\tptr->size += ptr->sampleCount;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *pasp_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_PixelAspectRatioBox, GF_ISOM_BOX_TYPE_PASP);\n\treturn (GF_Box *)tmp;\n}\n\n\nvoid pasp_box_del(GF_Box *s)\n{\n\tGF_PixelAspectRatioBox *ptr = (GF_PixelAspectRatioBox*)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err pasp_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_PixelAspectRatioBox *ptr = (GF_PixelAspectRatioBox*)s;\n\tISOM_DECREASE_SIZE(ptr, 8);\n\tptr->hSpacing = gf_bs_read_u32(bs);\n\tptr->vSpacing = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err pasp_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_PixelAspectRatioBox *ptr = (GF_PixelAspectRatioBox *)s;\n\tGF_Err e = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->hSpacing);\n\tgf_bs_write_u32(bs, ptr->vSpacing);\n\treturn GF_OK;\n}\n\nGF_Err pasp_box_size(GF_Box *s)\n{\n\ts->size += 8;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Box *clap_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_CleanApertureBox, GF_ISOM_BOX_TYPE_CLAP);\n\treturn (GF_Box *)tmp;\n}\n\n\nvoid clap_box_del(GF_Box *s)\n{\n\tGF_CleanApertureBox *ptr = (GF_CleanApertureBox*)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err clap_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_CleanApertureBox *ptr = (GF_CleanApertureBox*)s;\n\tISOM_DECREASE_SIZE(ptr, 32);\n\tptr->cleanApertureWidthN = gf_bs_read_u32(bs);\n\tptr->cleanApertureWidthD = gf_bs_read_u32(bs);\n\tptr->cleanApertureHeightN = gf_bs_read_u32(bs);\n\tptr->cleanApertureHeightD = gf_bs_read_u32(bs);\n\tptr->horizOffN = (s32) gf_bs_read_u32(bs);\n\tptr->horizOffD = gf_bs_read_u32(bs);\n\tptr->vertOffN = (s32) gf_bs_read_u32(bs);\n\tptr->vertOffD = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err clap_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_CleanApertureBox *ptr = (GF_CleanApertureBox *)s;\n\tGF_Err e = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->cleanApertureWidthN);\n\tgf_bs_write_u32(bs, ptr->cleanApertureWidthD);\n\tgf_bs_write_u32(bs, ptr->cleanApertureHeightN);\n\tgf_bs_write_u32(bs, ptr->cleanApertureHeightD);\n\tgf_bs_write_u32(bs, (u32) ptr->horizOffN);\n\tgf_bs_write_u32(bs, ptr->horizOffD);\n\tgf_bs_write_u32(bs, (u32) ptr->vertOffN);\n\tgf_bs_write_u32(bs, ptr->vertOffD);\n\treturn GF_OK;\n}\n\nGF_Err clap_box_size(GF_Box *s)\n{\n\ts->size += 32;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n\nGF_Box *metx_box_new()\n{\n\t//type is overridden by the box constructor\n\tISOM_DECL_BOX_ALLOC(GF_MetaDataSampleEntryBox, GF_ISOM_BOX_TYPE_METX);\n\tgf_isom_sample_entry_init((GF_SampleEntryBox*)tmp);\n\treturn (GF_Box *)tmp;\n}\n\n\nvoid metx_box_del(GF_Box *s)\n{\n\tGF_MetaDataSampleEntryBox *ptr = (GF_MetaDataSampleEntryBox*)s;\n\tif (ptr == NULL) return;\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)s);\n\n\tif (ptr->content_encoding) gf_free(ptr->content_encoding);\n\tif (ptr->xml_namespace) gf_free(ptr->xml_namespace);\n\tif (ptr->xml_schema_loc) gf_free(ptr->xml_schema_loc);\n\tif (ptr->mime_type) gf_free(ptr->mime_type);\n\tgf_free(ptr);\n}\n\n\nGF_Err metx_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_MetaDataSampleEntryBox *ptr = (GF_MetaDataSampleEntryBox *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_TXTC:\n\t\t//we allow the config box on metx\n\t\tBOX_FIELD_ASSIGN(config, GF_TextConfigBox)\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err metx_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 size, i;\n\tGF_Err e;\n\tchar *str;\n\tGF_MetaDataSampleEntryBox *ptr = (GF_MetaDataSampleEntryBox*)s;\n\n\te = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)ptr, bs);\n\tif (e) return e;\n\tISOM_DECREASE_SIZE(ptr, 8);\n\n\tif (ptr->size > (u64)SIZE_MAX) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid size \"LLU\" in metx\\n\", ptr->size));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tsize = (u32) ptr->size;\n\tstr = gf_malloc(sizeof(char)*size);\n\tif (!str) return GF_OUT_OF_MEM;\n\ti=0;\n\n\twhile (size) {\n\t\tstr[i] = gf_bs_read_u8(bs);\n\t\tsize--;\n\t\tif (!str[i]) {\n\t\t\ti++;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\tif (!size && i>1 && str[i-1]) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] metx read invalid string\\n\"));\n\t\tgf_free(str);\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tif (i>1) {\n\t\tif (ptr->type==GF_ISOM_BOX_TYPE_STPP) {\n\t\t\tptr->xml_namespace = gf_strdup(str);\n\t\t} else {\n\t\t\tptr->content_encoding = gf_strdup(str);\n\t\t}\n\t}\n\n\ti=0;\n\twhile (size) {\n\t\tstr[i] = gf_bs_read_u8(bs);\n\t\tsize--;\n\t\tif (!str[i]) {\n\t\t\ti++;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\tif (!size && i>1 && str[i-1]) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] metx read invalid string\\n\"));\n\t\tgf_free(str);\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tif ((ptr->type==GF_ISOM_BOX_TYPE_METX) || (ptr->type==GF_ISOM_BOX_TYPE_STPP)) {\n\t\tif (i>1) {\n\t\t\tif (ptr->type==GF_ISOM_BOX_TYPE_STPP) {\n\t\t\t\tptr->xml_schema_loc = gf_strdup(str);\n\t\t\t} else {\n\t\t\t\tptr->xml_namespace = gf_strdup(str);\n\t\t\t}\n\t\t}\n\n\t\ti=0;\n\t\twhile (size) {\n\t\t\tstr[i] = gf_bs_read_u8(bs);\n\t\t\tsize--;\n\t\t\tif (!str[i]) {\n\t\t\t\ti++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tif (!size && i>1 && str[i-1]) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] metx read invalid string\\n\"));\n\t\t\tgf_free(str);\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t\tif (i>1) {\n\t\t\tif (ptr->type==GF_ISOM_BOX_TYPE_STPP) {\n\t\t\t\tptr->mime_type = gf_strdup(str);\n\t\t\t} else {\n\t\t\t\tptr->xml_schema_loc = gf_strdup(str);\n\t\t\t}\n\t\t}\n\t}\n\t//mett, sbtt, stxt, stpp\n\telse {\n\t\tif (i>1) ptr->mime_type = gf_strdup(str);\n\t}\n\tptr->size = size;\n\tgf_free(str);\n\treturn gf_isom_box_array_read(s, bs);\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err metx_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MetaDataSampleEntryBox *ptr = (GF_MetaDataSampleEntryBox *)s;\n\tGF_Err e = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_data(bs, ptr->reserved, 6);\n\tgf_bs_write_u16(bs, ptr->dataReferenceIndex);\n\n\tif (ptr->type!=GF_ISOM_BOX_TYPE_STPP) {\n\t\tif (ptr->content_encoding)\n\t\t\tgf_bs_write_data(bs, ptr->content_encoding, (u32) strlen(ptr->content_encoding));\n\t\tgf_bs_write_u8(bs, 0);\n\t}\n\n\tif ((ptr->type==GF_ISOM_BOX_TYPE_METX) || (ptr->type==GF_ISOM_BOX_TYPE_STPP)) {\n\t\tif (ptr->xml_namespace)\n\t\t\tgf_bs_write_data(bs, ptr->xml_namespace, (u32) strlen(ptr->xml_namespace));\n\n\t\tgf_bs_write_u8(bs, 0);\n\n\t\tif (ptr->xml_schema_loc)\n\t\t\tgf_bs_write_data(bs, ptr->xml_schema_loc, (u32) strlen(ptr->xml_schema_loc));\n\t\tgf_bs_write_u8(bs, 0);\n\n\t\tif (ptr->type==GF_ISOM_BOX_TYPE_STPP) {\n\t\t\tif (ptr->mime_type)\n\t\t\t\tgf_bs_write_data(bs, ptr->mime_type, (u32) strlen(ptr->mime_type));\n\n\t\t\tgf_bs_write_u8(bs, 0);\n\t\t}\n\t}\n\t//mett, sbtt, stxt\n\telse {\n\t\tif (ptr->mime_type)\n\t\t\tgf_bs_write_data(bs, ptr->mime_type, (u32) strlen(ptr->mime_type));\n\n\t\tgf_bs_write_u8(bs, 0);\n\t}\n\n\treturn GF_OK;\n}\n\nGF_Err metx_box_size(GF_Box *s)\n{\n\tGF_MetaDataSampleEntryBox *ptr = (GF_MetaDataSampleEntryBox *)s;\n\tptr->size += 8;\n\n\tif (ptr->type!=GF_ISOM_BOX_TYPE_STPP) {\n\t\tif (ptr->content_encoding)\n\t\t\tptr->size += strlen(ptr->content_encoding);\n\t\tptr->size++;\n\t}\n\n\tif ((ptr->type==GF_ISOM_BOX_TYPE_METX) || (ptr->type==GF_ISOM_BOX_TYPE_STPP)) {\n\n\t\tif (ptr->xml_namespace)\n\t\t\tptr->size += strlen(ptr->xml_namespace);\n\t\tptr->size++;\n\n\t\tif (ptr->xml_schema_loc)\n\t\t\tptr->size += strlen(ptr->xml_schema_loc);\n\t\tptr->size++;\n\n\t\tif (ptr->type==GF_ISOM_BOX_TYPE_STPP) {\n\t\t\tif (ptr->mime_type)\n\t\t\t\tptr->size += strlen(ptr->mime_type);\n\t\t\tptr->size++;\n\t\t}\n\n\t}\n\t//mett, sbtt, stxt\n\telse {\n\t\tif (ptr->mime_type)\n\t\t\tptr->size += strlen(ptr->mime_type);\n\t\tptr->size++;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/* SimpleTextSampleEntry */\nGF_Box *txtc_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TextConfigBox, GF_ISOM_BOX_TYPE_TXTC);\n\treturn (GF_Box *)tmp;\n}\n\n\nvoid txtc_box_del(GF_Box *s)\n{\n\tGF_TextConfigBox *ptr = (GF_TextConfigBox*)s;\n\tif (ptr == NULL) return;\n\n\tif (ptr->config) gf_free(ptr->config);\n\tgf_free(ptr);\n}\n\nGF_Err txtc_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TextConfigBox *ptr = (GF_TextConfigBox*)s;\n\tif ((u32)ptr->size >= (u32)0xFFFFFFFF) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid size %llu in txtc box\\n\", ptr->size));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tptr->config = (char *)gf_malloc(sizeof(char)*((u32) ptr->size+1));\n\tif (!ptr->config) return GF_OUT_OF_MEM;\n\tgf_bs_read_data(bs, ptr->config, (u32) ptr->size);\n\tptr->config[ptr->size] = 0;\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err txtc_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TextConfigBox *ptr = (GF_TextConfigBox *)s;\n\tGF_Err e = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tif (ptr->config)\n\t\tgf_bs_write_data(bs, ptr->config, (u32) strlen(ptr->config));\n\tgf_bs_write_u8(bs, 0);\n\treturn GF_OK;\n}\n\nGF_Err txtc_box_size(GF_Box *s)\n{\n\tGF_TextConfigBox *ptr = (GF_TextConfigBox *)s;\n\tif (ptr->config)\n\t\tptr->size += strlen(ptr->config);\n\tptr->size++;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *dac3_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_AC3ConfigBox, GF_ISOM_BOX_TYPE_DAC3);\n\treturn (GF_Box *)tmp;\n}\n\nGF_Box *dec3_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_AC3ConfigBox, GF_ISOM_BOX_TYPE_DAC3);\n\ttmp->cfg.is_ec3 = 1;\n\treturn (GF_Box *)tmp;\n}\n\nvoid dac3_box_del(GF_Box *s)\n{\n\tGF_AC3ConfigBox *ptr = (GF_AC3ConfigBox *)s;\n\tgf_free(ptr);\n}\n\n\nGF_Err dac3_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu64 pos;\n\tGF_AC3ConfigBox *ptr = (GF_AC3ConfigBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\tpos = gf_bs_get_position(bs);\n\te = gf_odf_ac3_config_parse_bs(bs, ptr->cfg.is_ec3, &ptr->cfg);\n\tif (e) return e;\n\tpos = gf_bs_get_position(bs) - pos;\n\tISOM_DECREASE_SIZE(ptr, pos);\n\n\tif (ptr->size>=2) {\n\t\tptr->size-=2;\n\t\tgf_bs_read_int(bs, 7);\n\t\tptr->cfg.atmos_ec3_ext = gf_bs_read_int(bs, 1);\n\t\tptr->cfg.complexity_index_type = gf_bs_read_u8(bs);\n\t}\n\t//the rest is reserved\n\tgf_bs_skip_bytes(bs, ptr->size);\n\tptr->size = 0;\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err dac3_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_AC3ConfigBox *ptr = (GF_AC3ConfigBox *)s;\n\n\tif (ptr->cfg.is_ec3) s->type = GF_ISOM_BOX_TYPE_DEC3;\n\te = gf_isom_box_write_header(s, bs);\n\tif (ptr->cfg.is_ec3) s->type = GF_ISOM_BOX_TYPE_DAC3;\n\tif (e) return e;\n\n\te = gf_odf_ac3_cfg_write_bs(&ptr->cfg, bs);\n\tif (e) return e;\n\n\tif (ptr->cfg.atmos_ec3_ext || ptr->cfg.complexity_index_type) {\n\t\tgf_bs_write_int(bs, 0, 7);\n\t\tgf_bs_write_int(bs, ptr->cfg.atmos_ec3_ext, 1);\n\t\tgf_bs_write_u8(bs, ptr->cfg.complexity_index_type);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err dac3_box_size(GF_Box *s)\n{\n\tGF_AC3ConfigBox *ptr = (GF_AC3ConfigBox *)s;\n\n\tif (ptr->cfg.is_ec3) {\n\t\tu32 i;\n\t\ts->size += 2;\n\t\tfor (i=0; i<ptr->cfg.nb_streams; i++) {\n\t\t\ts->size += 3;\n\t\t\tif (ptr->cfg.streams[i].nb_dep_sub)\n\t\t\t\ts->size += 1;\n\t\t}\n\t} else {\n\t\ts->size += 3;\n\t}\n\tif (ptr->cfg.atmos_ec3_ext || ptr->cfg.complexity_index_type) {\n\t\ts->size += 2;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid lsrc_box_del(GF_Box *s)\n{\n\tGF_LASERConfigurationBox *ptr = (GF_LASERConfigurationBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->hdr) gf_free(ptr->hdr);\n\tgf_free(ptr);\n}\n\n\nGF_Err lsrc_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_LASERConfigurationBox *ptr = (GF_LASERConfigurationBox *)s;\n\tptr->hdr_size = (u32) ptr->size;\n\tptr->hdr = gf_malloc(sizeof(char)*ptr->hdr_size);\n\tif (!ptr->hdr) return GF_OUT_OF_MEM;\n\tgf_bs_read_data(bs, ptr->hdr, ptr->hdr_size);\n\treturn GF_OK;\n}\n\nGF_Box *lsrc_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_LASERConfigurationBox, GF_ISOM_BOX_TYPE_LSRC);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err lsrc_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_LASERConfigurationBox *ptr = (GF_LASERConfigurationBox *)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_data(bs, ptr->hdr, ptr->hdr_size);\n\treturn GF_OK;\n}\n\nGF_Err lsrc_box_size(GF_Box *s)\n{\n\tGF_LASERConfigurationBox *ptr = (GF_LASERConfigurationBox *)s;\n\tptr->size += ptr->hdr_size;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid lsr1_box_del(GF_Box *s)\n{\n\tGF_LASeRSampleEntryBox *ptr = (GF_LASeRSampleEntryBox *)s;\n\tif (ptr == NULL) return;\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)s);\n\tif (ptr->slc) gf_odf_desc_del((GF_Descriptor *)ptr->slc);\n\tgf_free(ptr);\n}\n\nGF_Err lsr1_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_LASeRSampleEntryBox *ptr = (GF_LASeRSampleEntryBox *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_LSRC:\n\t\tBOX_FIELD_ASSIGN(lsr_config, GF_LASERConfigurationBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_M4DS:\n\t\tBOX_FIELD_ASSIGN(descr, GF_MPEG4ExtensionDescriptorsBox)\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err lsr1_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_LASeRSampleEntryBox *ptr = (GF_LASeRSampleEntryBox*)s;\n\n\te = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)ptr, bs);\n\tif (e) return e;\n\n\tISOM_DECREASE_SIZE(ptr, 8);\n\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *lsr1_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_LASeRSampleEntryBox, GF_ISOM_BOX_TYPE_LSR1);\n\tgf_isom_sample_entry_init((GF_SampleEntryBox*)tmp);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err lsr1_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_LASeRSampleEntryBox *ptr = (GF_LASeRSampleEntryBox *)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_data(bs, ptr->reserved, 6);\n\tgf_bs_write_u16(bs, ptr->dataReferenceIndex);\n\treturn GF_OK;\n}\n\nGF_Err lsr1_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_LASeRSampleEntryBox *ptr = (GF_LASeRSampleEntryBox *)s;\n\ts->size += 8;\n\tgf_isom_check_position(s, (GF_Box *)ptr->lsr_config, &pos);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid sidx_box_del(GF_Box *s)\n{\n\tGF_SegmentIndexBox *ptr = (GF_SegmentIndexBox *) s;\n\tif (ptr == NULL) return;\n\tif (ptr->refs) gf_free(ptr->refs);\n\tgf_free(ptr);\n}\n\nGF_Err sidx_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_SegmentIndexBox *ptr = (GF_SegmentIndexBox*) s;\n\n\tISOM_DECREASE_SIZE(ptr, 8);\n\tptr->reference_ID = gf_bs_read_u32(bs);\n\tptr->timescale = gf_bs_read_u32(bs);\n\n\tif (ptr->version==0) {\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\tptr->earliest_presentation_time = gf_bs_read_u32(bs);\n\t\tptr->first_offset = gf_bs_read_u32(bs);\n\t} else {\n\t\tISOM_DECREASE_SIZE(ptr, 16);\n\t\tptr->earliest_presentation_time = gf_bs_read_u64(bs);\n\t\tptr->first_offset = gf_bs_read_u64(bs);\n\t}\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tgf_bs_read_u16(bs); /* reserved */\n\tptr->nb_refs = gf_bs_read_u16(bs);\n\n\tptr->refs = gf_malloc(sizeof(GF_SIDXReference)*ptr->nb_refs);\n\tif (!ptr->refs) return GF_OUT_OF_MEM;\n\tfor (i=0; i<ptr->nb_refs; i++) {\n\t\tptr->refs[i].reference_type = gf_bs_read_int(bs, 1);\n\t\tptr->refs[i].reference_size = gf_bs_read_int(bs, 31);\n\t\tptr->refs[i].subsegment_duration = gf_bs_read_u32(bs);\n\t\tptr->refs[i].starts_with_SAP = gf_bs_read_int(bs, 1);\n\t\tptr->refs[i].SAP_type = gf_bs_read_int(bs, 3);\n\t\tptr->refs[i].SAP_delta_time = gf_bs_read_int(bs, 28);\n\n\t\tISOM_DECREASE_SIZE(ptr, 12);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *sidx_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SegmentIndexBox, GF_ISOM_BOX_TYPE_SIDX);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err sidx_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_SegmentIndexBox *ptr = (GF_SegmentIndexBox*) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->reference_ID);\n\tgf_bs_write_u32(bs, ptr->timescale);\n\tif (ptr->version==0) {\n\t\tgf_bs_write_u32(bs, (u32) ptr->earliest_presentation_time);\n\t\tgf_bs_write_u32(bs, (u32) ptr->first_offset);\n\t} else {\n\t\tgf_bs_write_u64(bs, ptr->earliest_presentation_time);\n\t\tgf_bs_write_u64(bs, ptr->first_offset);\n\t}\n\tgf_bs_write_u16(bs, 0);\n\tgf_bs_write_u16(bs, ptr->nb_refs);\n\tfor (i=0; i<ptr->nb_refs; i++ ) {\n\t\tgf_bs_write_int(bs, ptr->refs[i].reference_type, 1);\n\t\tgf_bs_write_int(bs, ptr->refs[i].reference_size, 31);\n\t\tgf_bs_write_u32(bs, ptr->refs[i].subsegment_duration);\n\t\tgf_bs_write_int(bs, ptr->refs[i].starts_with_SAP, 1);\n\t\tgf_bs_write_int(bs, ptr->refs[i].SAP_type, 3);\n\t\tgf_bs_write_int(bs, ptr->refs[i].SAP_delta_time, 28);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err sidx_box_size(GF_Box *s)\n{\n\tGF_SegmentIndexBox *ptr = (GF_SegmentIndexBox*) s;\n\n\tptr->size += 12;\n\tif (ptr->version==0) {\n\t\tptr->size += 8;\n\t} else {\n\t\tptr->size += 16;\n\t}\n\tptr->size += ptr->nb_refs * 12;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid ssix_box_del(GF_Box *s)\n{\n\tu32 i;\n\tGF_SubsegmentIndexBox *ptr = (GF_SubsegmentIndexBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->subsegments) {\n\t\tfor (i = 0; i < ptr->subsegment_alloc; i++) {\n\t\t\tGF_SubsegmentInfo *subsegment = &ptr->subsegments[i];\n\t\t\tif (subsegment->ranges) gf_free(subsegment->ranges);\n\t\t}\n\t\tgf_free(ptr->subsegments);\n\t}\n\tgf_free(ptr);\n}\n\nGF_Err ssix_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i,j;\n\tGF_SubsegmentIndexBox *ptr = (GF_SubsegmentIndexBox*)s;\n\n\tISOM_DECREASE_SIZE(ptr, 4)\n\tptr->subsegment_count = gf_bs_read_u32(bs);\n\t//each subseg has at least one range_count (4 bytes), abort if not enough bytes (broken box)\n\tif (ptr->size / 4 < ptr->subsegment_count || (u64)ptr->subsegment_count > (u64)SIZE_MAX/sizeof(GF_SubsegmentInfo))\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tptr->subsegment_alloc = ptr->subsegment_count;\n\tGF_SAFE_ALLOC_N(ptr->subsegments, ptr->subsegment_count, GF_SubsegmentInfo);\n\tif (!ptr->subsegments)\n\t    return GF_OUT_OF_MEM;\n\tfor (i = 0; i < ptr->subsegment_count; i++) {\n\t\tGF_SubsegmentInfo *subseg = &ptr->subsegments[i];\n\t\tISOM_DECREASE_SIZE(ptr, 4)\n\t\tsubseg->range_count = gf_bs_read_u32(bs);\n\t\t//each range is 4 bytes, abort if not enough bytes\n\t\tif (ptr->size / 4 < subseg->range_count || (u64)subseg->range_count > (u64)SIZE_MAX/sizeof(GF_SubsegmentRangeInfo))\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\tsubseg->ranges = (GF_SubsegmentRangeInfo*) gf_malloc(sizeof(GF_SubsegmentRangeInfo) * subseg->range_count);\n\t\tif (!subseg->ranges) return GF_OUT_OF_MEM;\n\t\tfor (j = 0; j < subseg->range_count; j++) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 4)\n\t\t\tsubseg->ranges[j].level = gf_bs_read_u8(bs);\n\t\t\tsubseg->ranges[j].range_size = gf_bs_read_u24(bs);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *ssix_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SubsegmentIndexBox, GF_ISOM_BOX_TYPE_SSIX);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err ssix_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i, j;\n\tGF_SubsegmentIndexBox *ptr = (GF_SubsegmentIndexBox*)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->subsegment_count);\n\tfor (i = 0; i<ptr->subsegment_count; i++) {\n\t\tgf_bs_write_u32(bs, ptr->subsegments[i].range_count);\n\t\tfor (j = 0; j < ptr->subsegments[i].range_count; j++) {\n\t\t\tgf_bs_write_u8(bs, ptr->subsegments[i].ranges[j].level);\n\t\t\tgf_bs_write_u24(bs, ptr->subsegments[i].ranges[j].range_size);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err ssix_box_size(GF_Box *s)\n{\n\tu32 i;\n\tGF_SubsegmentIndexBox *ptr = (GF_SubsegmentIndexBox*)s;\n\n\tptr->size += 4;\n\tfor (i = 0; i < ptr->subsegment_count; i++) {\n\t\tptr->size += 4 + 4 * ptr->subsegments[i].range_count;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid leva_box_del(GF_Box *s)\n{\n\tGF_LevelAssignmentBox *ptr = (GF_LevelAssignmentBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->levels) gf_free(ptr->levels);\n\tgf_free(ptr);\n}\n\nGF_Err leva_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_LevelAssignmentBox *ptr = (GF_LevelAssignmentBox*)s;\n\n\tISOM_DECREASE_SIZE(ptr, 1)\n\tptr->level_count = gf_bs_read_u8(bs);\n\t//each level is at least 5 bytes\n\tif (ptr->size / 5 < ptr->level_count)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tGF_SAFE_ALLOC_N(ptr->levels, ptr->level_count, GF_LevelAssignment);\n\tif (!ptr->levels) return GF_OUT_OF_MEM;\n\n\tfor (i = 0; i < ptr->level_count; i++) {\n\t\tGF_LevelAssignment *level = &ptr->levels[i];\n\t\tu8 tmp;\n\t\tif (!level || ptr->size < 5) return GF_BAD_PARAM;\n\t\tISOM_DECREASE_SIZE(ptr, 5)\n\n\t\tlevel->track_id = gf_bs_read_u32(bs);\n\t\ttmp = gf_bs_read_u8(bs);\n\t\tlevel->padding_flag = tmp >> 7;\n\t\tlevel->type = tmp & 0x7F;\n\t\tif (level->type == 0) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 4)\n\t\t\tlevel->grouping_type = gf_bs_read_u32(bs);\n\t\t}\n\t\telse if (level->type == 1) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\t\tlevel->grouping_type = gf_bs_read_u32(bs);\n\t\t\tlevel->grouping_type_parameter = gf_bs_read_u32(bs);\n\t\t}\n\t\telse if (level->type == 4) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 4)\n\t\t\tlevel->sub_track_id = gf_bs_read_u32(bs);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *leva_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_LevelAssignmentBox, GF_ISOM_BOX_TYPE_LEVA);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err leva_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_LevelAssignmentBox *ptr = (GF_LevelAssignmentBox*)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u8(bs, ptr->level_count);\n\tfor (i = 0; i<ptr->level_count; i++) {\n\t\tgf_bs_write_u32(bs, ptr->levels[i].track_id);\n\t\tgf_bs_write_u8(bs, ptr->levels[i].padding_flag << 7 | (ptr->levels[i].type & 0x7F));\n\t\tif (ptr->levels[i].type == 0) {\n\t\t\tgf_bs_write_u32(bs, ptr->levels[i].grouping_type);\n\t\t}\n\t\telse if (ptr->levels[i].type == 1) {\n\t\t\tgf_bs_write_u32(bs, ptr->levels[i].grouping_type);\n\t\t\tgf_bs_write_u32(bs, ptr->levels[i].grouping_type_parameter);\n\t\t}\n\t\telse if (ptr->levels[i].type == 4) {\n\t\t\tgf_bs_write_u32(bs, ptr->levels[i].sub_track_id);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err leva_box_size(GF_Box *s)\n{\n\tu32 i;\n\tGF_LevelAssignmentBox *ptr = (GF_LevelAssignmentBox*)s;\n\n\tptr->size += 1;\n\tfor (i = 0; i < ptr->level_count; i++) {\n\t\tptr->size += 5;\n\t\tif (ptr->levels[i].type == 0 || ptr->levels[i].type == 4) {\n\t\t\tptr->size += 4;\n\t\t}\n\t\telse if (ptr->levels[i].type == 1) {\n\t\t\tptr->size += 8;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *pcrb_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_PcrInfoBox, GF_ISOM_BOX_TYPE_PCRB);\n\treturn (GF_Box *)tmp;\n}\n\nvoid pcrb_box_del(GF_Box *s)\n{\n\tGF_PcrInfoBox *ptr = (GF_PcrInfoBox *) s;\n\tif (ptr == NULL) return;\n\tif (ptr->pcr_values) gf_free(ptr->pcr_values);\n\tgf_free(ptr);\n}\n\nGF_Err pcrb_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_PcrInfoBox *ptr = (GF_PcrInfoBox*) s;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->subsegment_count = gf_bs_read_u32(bs);\n\n\tif ((u64)ptr->subsegment_count > ptr->size / 8 || (u64)ptr->subsegment_count > (u64)SIZE_MAX/sizeof(u64)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of subsegment %d in pcrb\\n\", ptr->subsegment_count));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tptr->pcr_values = gf_malloc(sizeof(u64)*ptr->subsegment_count);\n\tif (!ptr->pcr_values) return GF_OUT_OF_MEM;\n\tfor (i=0; i<ptr->subsegment_count; i++) {\n\t\tu64 data1 = gf_bs_read_u32(bs);\n\t\tu64 data2 = gf_bs_read_u16(bs);\n\t\tISOM_DECREASE_SIZE(ptr, 6);\n\t\tptr->pcr_values[i] = (data1 << 10) | (data2 >> 6);\n\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err pcrb_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_PcrInfoBox *ptr = (GF_PcrInfoBox*) s;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->subsegment_count);\n\n\tfor (i=0; i<ptr->subsegment_count; i++ ) {\n\t\tu32 data1 = (u32) (ptr->pcr_values[i] >> 10);\n\t\tu16 data2 = (u16) (ptr->pcr_values[i] << 6);\n\n\t\tgf_bs_write_u32(bs, data1);\n\t\tgf_bs_write_u16(bs, data2);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err pcrb_box_size(GF_Box *s)\n{\n\tGF_PcrInfoBox *ptr = (GF_PcrInfoBox*) s;\n\n\tptr->size += 4;\n\tptr->size += ptr->subsegment_count * 6;\n\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *subs_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SubSampleInformationBox, GF_ISOM_BOX_TYPE_SUBS);\n\ttmp->Samples = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\nvoid subs_box_del(GF_Box *s)\n{\n\tGF_SubSampleInformationBox *ptr = (GF_SubSampleInformationBox *)s;\n\tif (ptr == NULL) return;\n\n\twhile (gf_list_count(ptr->Samples)) {\n\t\tGF_SubSampleInfoEntry *pSamp;\n\t\tpSamp = (GF_SubSampleInfoEntry*)gf_list_get(ptr->Samples, 0);\n\t\twhile (gf_list_count(pSamp->SubSamples)) {\n\t\t\tGF_SubSampleEntry *pSubSamp;\n\t\t\tpSubSamp = (GF_SubSampleEntry*) gf_list_get(pSamp->SubSamples, 0);\n\t\t\tgf_free(pSubSamp);\n\t\t\tgf_list_rem(pSamp->SubSamples, 0);\n\t\t}\n\t\tgf_list_del(pSamp->SubSamples);\n\t\tgf_free(pSamp);\n\t\tgf_list_rem(ptr->Samples, 0);\n\t}\n\tgf_list_del(ptr->Samples);\n\tgf_free(ptr);\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err subs_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i, j, entry_count;\n\tu16 subsample_count;\n\tGF_SubSampleEntry *pSubSamp;\n\tGF_SubSampleInformationBox *ptr = (GF_SubSampleInformationBox *) s;\n\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tentry_count = gf_list_count(ptr->Samples);\n\tgf_bs_write_u32(bs, entry_count);\n\n\tfor (i=0; i<entry_count; i++) {\n\t\tGF_SubSampleInfoEntry *pSamp = (GF_SubSampleInfoEntry*) gf_list_get(ptr->Samples, i);\n\t\tsubsample_count = gf_list_count(pSamp->SubSamples);\n\t\tgf_bs_write_u32(bs, pSamp->sample_delta);\n\t\tgf_bs_write_u16(bs, subsample_count);\n\n\t\tfor (j=0; j<subsample_count; j++) {\n\t\t\tpSubSamp = (GF_SubSampleEntry*) gf_list_get(pSamp->SubSamples, j);\n\t\t\tif (ptr->version == 1) {\n\t\t\t\tgf_bs_write_u32(bs, pSubSamp->subsample_size);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_u16(bs, pSubSamp->subsample_size);\n\t\t\t}\n\t\t\tgf_bs_write_u8(bs, pSubSamp->subsample_priority);\n\t\t\tgf_bs_write_u8(bs, pSubSamp->discardable);\n\t\t\tgf_bs_write_u32(bs, pSubSamp->reserved);\n\t\t}\n\t}\n\treturn e;\n}\n\nGF_Err subs_box_size(GF_Box *s)\n{\n\tGF_SubSampleInformationBox *ptr = (GF_SubSampleInformationBox *) s;\n\tu32 entry_count, i;\n\tu16 subsample_count;\n\n\t// add 4 byte for entry_count\n\tptr->size += 4;\n\tentry_count = gf_list_count(ptr->Samples);\n\tfor (i=0; i<entry_count; i++) {\n\t\tGF_SubSampleInfoEntry *pSamp = (GF_SubSampleInfoEntry*) gf_list_get(ptr->Samples, i);\n\t\tsubsample_count = gf_list_count(pSamp->SubSamples);\n\t\t// 4 byte for sample_delta, 2 byte for subsample_count\n\t\t// and 6 + (4 or 2) bytes for each subsample\n\t\tptr->size += 4 + 2 + subsample_count * (6 + (ptr->version==1 ? 4 : 2));\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Err subs_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_SubSampleInformationBox *ptr = (GF_SubSampleInformationBox *)s;\n\tu32 entry_count, i, j;\n\tu16 subsample_count;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tentry_count = gf_bs_read_u32(bs);\n\n\tfor (i=0; i<entry_count; i++) {\n\t\tu32 subs_size=0;\n\t\tGF_SubSampleInfoEntry *pSamp = (GF_SubSampleInfoEntry*) gf_malloc(sizeof(GF_SubSampleInfoEntry));\n\t\tif (!pSamp) return GF_OUT_OF_MEM;\n\n\t\tmemset(pSamp, 0, sizeof(GF_SubSampleInfoEntry));\n\t\tpSamp->SubSamples = gf_list_new();\n\t\tpSamp->sample_delta = gf_bs_read_u32(bs);\n\t\tsubsample_count = gf_bs_read_u16(bs);\n\t\tsubs_size=6;\n\n\t\tfor (j=0; j<subsample_count; j++) {\n\t\t\tGF_SubSampleEntry *pSubSamp = (GF_SubSampleEntry*) gf_malloc(sizeof(GF_SubSampleEntry));\n\t\t\tif (!pSubSamp) return GF_OUT_OF_MEM;\n\n\t\t\tmemset(pSubSamp, 0, sizeof(GF_SubSampleEntry));\n\t\t\tif (ptr->version==1) {\n\t\t\t\tpSubSamp->subsample_size = gf_bs_read_u32(bs);\n\t\t\t\tsubs_size+=4;\n\t\t\t} else {\n\t\t\t\tpSubSamp->subsample_size = gf_bs_read_u16(bs);\n\t\t\t\tsubs_size+=2;\n\t\t\t}\n\t\t\tpSubSamp->subsample_priority = gf_bs_read_u8(bs);\n\t\t\tpSubSamp->discardable = gf_bs_read_u8(bs);\n\t\t\tpSubSamp->reserved = gf_bs_read_u32(bs);\n\t\t\tsubs_size+=6;\n\n\t\t\tgf_list_add(pSamp->SubSamples, pSubSamp);\n\t\t}\n\t\tgf_list_add(ptr->Samples, pSamp);\n\t\tISOM_DECREASE_SIZE(ptr, subs_size);\n\t}\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\nGF_Box *tfdt_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TFBaseMediaDecodeTimeBox, GF_ISOM_BOX_TYPE_TFDT);\n\treturn (GF_Box *)tmp;\n}\n\nvoid tfdt_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\n/*this is using chpl format according to some NeroRecode samples*/\nGF_Err tfdt_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_TFBaseMediaDecodeTimeBox *ptr = (GF_TFBaseMediaDecodeTimeBox *)s;\n\n\tif (ptr->version==1) {\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\tptr->baseMediaDecodeTime = gf_bs_read_u64(bs);\n\t} else {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->baseMediaDecodeTime = (u32) gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err tfdt_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TFBaseMediaDecodeTimeBox *ptr = (GF_TFBaseMediaDecodeTimeBox *) s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tif (ptr->version==1) {\n\t\tgf_bs_write_u64(bs, ptr->baseMediaDecodeTime);\n\t} else {\n\t\tgf_bs_write_u32(bs, (u32) ptr->baseMediaDecodeTime);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err tfdt_box_size(GF_Box *s)\n{\n\tGF_TFBaseMediaDecodeTimeBox *ptr = (GF_TFBaseMediaDecodeTimeBox *)s;\n\n\tif (!ptr->version && (ptr->baseMediaDecodeTime<=0xFFFFFFFF)) {\n\t\t//ptr->version = 0;\n\t\tptr->size += 4;\n\t} else {\n\t\tptr->version = 1;\n\t\tptr->size += 8;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM_FRAGMENTS*/\n\n\nGF_Box *rvcc_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_RVCConfigurationBox, GF_ISOM_BOX_TYPE_RVCC);\n\treturn (GF_Box *)tmp;\n}\n\nvoid rvcc_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err rvcc_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_RVCConfigurationBox *ptr = (GF_RVCConfigurationBox*)s;\n\tISOM_DECREASE_SIZE(ptr, 2);\n\tptr->predefined_rvc_config = gf_bs_read_u16(bs);\n\tif (!ptr->predefined_rvc_config) {\n\t\tISOM_DECREASE_SIZE(ptr, 2);\n\t\tptr->rvc_meta_idx = gf_bs_read_u16(bs);\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err rvcc_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_RVCConfigurationBox *ptr = (GF_RVCConfigurationBox*) s;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u16(bs, ptr->predefined_rvc_config);\n\tif (!ptr->predefined_rvc_config) {\n\t\tgf_bs_write_u16(bs, ptr->rvc_meta_idx);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err rvcc_box_size(GF_Box *s)\n{\n\tGF_RVCConfigurationBox *ptr = (GF_RVCConfigurationBox *)s;\n\tptr->size += 2;\n\tif (! ptr->predefined_rvc_config) ptr->size += 2;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Box *sbgp_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleGroupBox, GF_ISOM_BOX_TYPE_SBGP);\n\treturn (GF_Box *)tmp;\n}\nvoid sbgp_box_del(GF_Box *a)\n{\n\tGF_SampleGroupBox *p = (GF_SampleGroupBox *)a;\n\tif (p->sample_entries) gf_free(p->sample_entries);\n\tgf_free(p);\n}\n\nGF_Err sbgp_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_SampleGroupBox *ptr = (GF_SampleGroupBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 8);\n\tptr->grouping_type = gf_bs_read_u32(bs);\n\n\tif (ptr->version==1) {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->grouping_type_parameter = gf_bs_read_u32(bs);\n\t}\n\tptr->entry_count = gf_bs_read_u32(bs);\n\n\tif (ptr->size < sizeof(GF_SampleGroupEntry)*ptr->entry_count || (u64)ptr->entry_count > (u64)SIZE_MAX/sizeof(GF_SampleGroupEntry))\n\t    return GF_ISOM_INVALID_FILE;\n\n\tptr->sample_entries = gf_malloc(sizeof(GF_SampleGroupEntry)*ptr->entry_count);\n\tif (!ptr->sample_entries) return GF_OUT_OF_MEM;\n\n\tfor (i=0; i<ptr->entry_count; i++) {\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\tptr->sample_entries[i].sample_count = gf_bs_read_u32(bs);\n\t\tptr->sample_entries[i].group_description_index = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err sbgp_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_Err e;\n\tGF_SampleGroupBox *p = (GF_SampleGroupBox*)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, p->grouping_type);\n\tif (p->version==1)\n\t\tgf_bs_write_u32(bs, p->grouping_type_parameter);\n\n\tgf_bs_write_u32(bs, p->entry_count);\n\tfor (i = 0; i<p->entry_count; i++ ) {\n\t\tgf_bs_write_u32(bs, p->sample_entries[i].sample_count);\n\t\tgf_bs_write_u32(bs, p->sample_entries[i].group_description_index);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err sbgp_box_size(GF_Box *s)\n{\n\tGF_SampleGroupBox *p = (GF_SampleGroupBox*)s;\n\n\tp->size += 8;\n\tif (p->grouping_type_parameter) p->version=1;\n\n\tif (p->version==1) p->size += 4;\n\tp->size += 8*p->entry_count;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid *sgpd_parse_entry(GF_SampleGroupDescriptionBox *p, GF_BitStream *bs, s32 bytes_in_box, u32 entry_size, u32 *total_bytes)\n{\n\tBool null_size_ok = GF_FALSE;\n\tGF_DefaultSampleGroupDescriptionEntry *def_ptr;\n\tp->is_opaque = GF_FALSE;\n\tswitch (p->grouping_type) {\n\tcase GF_ISOM_SAMPLE_GROUP_ROLL:\n\tcase GF_ISOM_SAMPLE_GROUP_PROL:\n\t{\n\t\tGF_RollRecoveryEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_RollRecoveryEntry);\n\t\tif (!ptr) return NULL;\n\t\tptr->roll_distance = gf_bs_read_int(bs, 16);\n\t\t*total_bytes = 2;\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_RAP:\n\t{\n\t\tGF_VisualRandomAccessEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_VisualRandomAccessEntry);\n\t\tif (!ptr) return NULL;\n\t\tptr->num_leading_samples_known = gf_bs_read_int(bs, 1);\n\t\tptr->num_leading_samples = gf_bs_read_int(bs, 7);\n\t\t*total_bytes = 1;\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_SAP:\n\t{\n\t\tGF_SAPEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_SAPEntry);\n\t\tif (!ptr) return NULL;\n\t\tptr->dependent_flag = gf_bs_read_int(bs, 1);\n\t\tgf_bs_read_int(bs, 3);\n\t\tptr->SAP_type = gf_bs_read_int(bs, 4);\n\t\t*total_bytes = 1;\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_SYNC:\n\t{\n\t\tGF_SYNCEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_SYNCEntry);\n\t\tif (!ptr) return NULL;\n\t\tgf_bs_read_int(bs, 2);\n\t\tptr->NALU_type = gf_bs_read_int(bs, 6);\n\t\t*total_bytes = 1;\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_TELE:\n\t{\n\t\tGF_TemporalLevelEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_TemporalLevelEntry);\n\t\tif (!ptr) return NULL;\n\t\tptr->level_independently_decodable = gf_bs_read_int(bs, 1);\n\t\tgf_bs_read_int(bs, 7);\n\t\t*total_bytes = 1;\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_SEIG:\n\t{\n\t\tGF_CENCSampleEncryptionGroupEntry *ptr;\n\t\tif (bytes_in_box<3) return NULL;\n\t\tGF_SAFEALLOC(ptr, GF_CENCSampleEncryptionGroupEntry);\n\t\tif (!ptr) return NULL;\n\t\tBool use_mkey = gf_bs_read_int(bs, 1);\n\t\tgf_bs_read_int(bs, 7); //reserved\n\t\tptr->crypt_byte_block = gf_bs_read_int(bs, 4);\n\t\tptr->skip_byte_block = gf_bs_read_int(bs, 4);\n\t\tptr->IsProtected = gf_bs_read_u8(bs);\n\t\tbytes_in_box -= 3;\n\t\tif (use_mkey) {\n\t\t\tu64 pos = gf_bs_get_position(bs);\n\t\t\tu32 i, count = gf_bs_read_u16(bs);\n\t\t\tbytes_in_box -= 2;\n\t\t\tif (bytes_in_box<0) {\n\t\t\t\tgf_free(ptr);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tu8 ivsize = gf_bs_read_u8(bs);\n\t\t\t\tgf_bs_skip_bytes(bs, 16);\n\t\t\t\tbytes_in_box -= 17;\n\t\t\t\tif (!ivsize) {\n\t\t\t\t\t//const IV\n\t\t\t\t\tivsize = gf_bs_read_u8(bs);\n\t\t\t\t\tgf_bs_skip_bytes(bs, ivsize);\n\t\t\t\t\tbytes_in_box -= 1 + ivsize;\n\t\t\t\t}\n\t\t\t\tif (bytes_in_box<0) {\n\t\t\t\t\tgf_free(ptr);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tptr->key_info_size = 1 + (u32) (gf_bs_get_position(bs) - pos);\n\t\t\tptr->key_info = gf_malloc(sizeof(u8) * ptr->key_info_size);\n\t\t\tif (!ptr->key_info) {\n\t\t\t\tgf_free(ptr);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tgf_bs_seek(bs, pos);\n\t\t\tptr->key_info[0] = 1;\n\t\t\tgf_bs_read_data(bs, ptr->key_info + 1, ptr->key_info_size - 1);\n\t\t\t*total_bytes = 3 + ptr->key_info_size - 1;\n\n\t\t\tif (!gf_cenc_validate_key_info(ptr->key_info, ptr->key_info_size)) {\n\t\t\t\tgf_free(ptr->key_info);\n\t\t\t\tgf_free(ptr);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tbin128 kid;\n\t\t\tu8 const_iv_size = 0;\n\t\t\tu8 iv_size = gf_bs_read_u8(bs);\n\t\t\tgf_bs_read_data(bs, kid, 16);\n\t\t\tbytes_in_box -= 17;\n\t\t\tif (bytes_in_box<0) {\n\t\t\t\tgf_free(ptr);\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\t*total_bytes = 20;\n\t\t\tif ((ptr->IsProtected == 1) && !iv_size) {\n\t\t\t\tconst_iv_size = gf_bs_read_u8(bs);\n\t\t\t\tif ((const_iv_size != 8) && (const_iv_size != 16)) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] seig sample group have invalid constant_IV size\\n\"));\n\t\t\t\t\tgf_free(ptr);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tptr->key_info_size = 20;\n\t\t\tif (!iv_size && ptr->IsProtected) {\n\t\t\t\tptr->key_info_size += 1 + const_iv_size;\n\t\t\t}\n\t\t\tptr->key_info = gf_malloc(sizeof(u8) * ptr->key_info_size);\n\t\t\tif (!ptr->key_info) {\n\t\t\t\tgf_free(ptr);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tptr->key_info[0] = 0;\n\t\t\tptr->key_info[1] = 0;\n\t\t\tptr->key_info[2] = 0;\n\t\t\tptr->key_info[3] = iv_size;\n\t\t\tmemcpy(ptr->key_info+4, kid, 16);\n\t\t\tif (!iv_size && ptr->IsProtected) {\n\t\t\t\tptr->key_info[20] = const_iv_size;\n\t\t\t\tgf_bs_read_data(bs, (char *)ptr->key_info+21, const_iv_size);\n\t\t\t\t*total_bytes += 1 + const_iv_size;\n\t\t\t}\n\t\t}\n\n\t\tif (!entry_size) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] seig sample group does not indicate entry size, deprecated in spec\\n\"));\n\t\t}\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_OINF:\n\t{\n\t\tGF_OperatingPointsInformation *ptr = gf_isom_oinf_new_entry();\n\t\tu32 s = (u32) gf_bs_get_position(bs);\n\t\tgf_isom_oinf_read_entry(ptr, bs);\n\t\t*total_bytes = (u32) gf_bs_get_position(bs) - s;\n\t\tif (!entry_size) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] oinf sample group does not indicate entry size, deprecated in spec\\n\"));\n\t\t}\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_LINF:\n\t{\n\t\tGF_LHVCLayerInformation *ptr = gf_isom_linf_new_entry();\n\t\tu32 s = (u32) gf_bs_get_position(bs);\n\t\tgf_isom_linf_read_entry(ptr, bs);\n\t\t*total_bytes = (u32) gf_bs_get_position(bs) - s;\n\t\tif (!entry_size) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] linf sample group does not indicate entry size, deprecated in spec\\n\"));\n\t\t}\n\t\treturn ptr;\n\t}\n\n\tcase GF_ISOM_SAMPLE_GROUP_TRIF:\n\t\tif (! entry_size) {\n\t\t\tu32 flags = gf_bs_peek_bits(bs, 24, 0);\n\t\t\tif (flags & 0x10000) entry_size=3;\n\t\t\telse {\n\t\t\t\tif (flags & 0x80000) entry_size=7;\n\t\t\t\telse entry_size=11;\n\t\t\t\t//have dependency list\n\t\t\t\tif (flags & 0x200000) {\n\t\t\t\t\tu32 nb_entries = gf_bs_peek_bits(bs, 16, entry_size);\n\t\t\t\t\tentry_size += 2 + 2*nb_entries;\n\t\t\t\t}\n\t\t\t}\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] trif sample group does not indicate entry size, deprecated in spec\\n\"));\n\t\t}\n\t\tbreak;\n\tcase GF_ISOM_SAMPLE_GROUP_NALM:\n\t\tif (! entry_size) {\n\t\t\tu64 start = gf_bs_get_position(bs);\n\t\t\tBool rle, large_size;\n\t\t\tu32 entry_count;\n\t\t\tgf_bs_read_int(bs, 6);\n\t\t\tlarge_size = gf_bs_read_int(bs, 1);\n\t\t\trle = gf_bs_read_int(bs, 1);\n\t\t\tentry_count = gf_bs_read_int(bs, large_size ? 16 : 8);\n\t\t\tgf_bs_seek(bs, start);\n\t\t\tentry_size = 1 + (large_size ? 2 : 1);\n\t\t\tentry_size += entry_count * 2;\n\t\t\tif (rle) entry_size += entry_count * (large_size ? 2 : 1);\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] nalm sample group does not indicate entry size, deprecated in spec\\n\"));\n\t\t}\n\t\tbreak;\n\n\tcase GF_ISOM_SAMPLE_GROUP_TSAS:\n\tcase GF_ISOM_SAMPLE_GROUP_STSA:\n\t\tnull_size_ok = GF_TRUE;\n\t\tbreak;\n\t//TODO, add support for these ones ?\n\tcase GF_ISOM_SAMPLE_GROUP_TSCL:\n\t\tentry_size = 20;\n\t\tbreak;\n\tcase GF_ISOM_SAMPLE_GROUP_LBLI:\n\t\tentry_size = 2;\n\t\tbreak;\n\tcase GF_ISOM_SAMPLE_GROUP_SPOR:\n\t{\n\t\tu32 i;\n\t\tGF_SubpictureOrderEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_SubpictureOrderEntry);\n\t\tif (!ptr) return NULL;\n\t\tptr->subpic_id_info_flag = gf_bs_read_int(bs, 1);\n\t\tptr->num_subpic_ref_idx = gf_bs_read_int(bs, 15);\n\t\t*total_bytes = 2;\n\t\tptr->subp_track_ref_idx = gf_malloc(sizeof(u16) * ptr->num_subpic_ref_idx);\n\t\tif (!ptr->subp_track_ref_idx) {\n\t\t\tgf_free(ptr);\n\t\t\treturn NULL;\n\t\t}\n\t\tfor (i=0; i<ptr->num_subpic_ref_idx; i++) {\n\t\t\tptr->subp_track_ref_idx[i] = gf_bs_read_u16(bs);\n\t\t\t*total_bytes += 2;\n\t\t}\n\t\tif (ptr->subpic_id_info_flag) {\n\t\t\tptr->spinfo.subpic_id_len_minus1 = gf_bs_read_int(bs, 4);\n\t\t\tptr->spinfo.subpic_id_bit_pos = gf_bs_read_int(bs, 12);\n\t\t\tptr->spinfo.start_code_emul_flag = gf_bs_read_int(bs, 1);\n\t\t\tptr->spinfo.pps_sps_subpic_id_flag = gf_bs_read_int(bs, 1);\n\t\t\tif (ptr->spinfo.pps_sps_subpic_id_flag) {\n\t\t\t\tptr->spinfo.xps_id = gf_bs_read_int(bs, 6);\n\t\t\t} else {\n\t\t\t\tptr->spinfo.xps_id = gf_bs_read_int(bs, 4);\n\t\t\t\tgf_bs_read_int(bs, 2);\n\t\t\t}\n\t\t\t*total_bytes += 3;\n\t\t}\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_SULM:\n\t{\n\t\tu32 i;\n\t\tGF_SubpictureLayoutMapEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_SubpictureLayoutMapEntry);\n\t\tif (!ptr) return NULL;\n\t\tptr->groupID_info_4cc = gf_bs_read_u32(bs);\n\t\tptr->nb_entries = 1 + gf_bs_read_u16(bs);\n\t\t*total_bytes = 6;\n\t\tptr->groupIDs = gf_malloc(sizeof(u16) * ptr->nb_entries);\n\t\tif (!ptr->groupIDs) {\n\t\t\tgf_free(ptr);\n\t\t\treturn NULL;\n\t\t}\n\t\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\t\tptr->groupIDs[i] = gf_bs_read_u16(bs);\n\t\t\t*total_bytes += 2;\n\t\t}\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_ILCE:\n\t{\n\t\tGF_FieldInterlaceType *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_FieldInterlaceType);\n\t\tif (!ptr) return NULL;\n\t\tptr->ilce_type = gf_bs_read_u8(bs);\n\t\t*total_bytes = 1;\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_ESGH:\n\t{\n\t\tu32 i;\n\t\tGF_EssentialSamplegroupEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_EssentialSamplegroupEntry);\n\t\tif (!ptr) return NULL;\n\t\tptr->nb_types = gf_bs_read_u32(bs);\n\t\tif (ptr->nb_types * 4 + 4 > entry_size) {\n\t\t\tgf_free(ptr);\n\t\t\treturn NULL;\n\t\t}\n\t\t*total_bytes = 4;\n\t\tptr->group_types = gf_malloc(sizeof(u32) * ptr->nb_types);\n\t\tif (!ptr->group_types) {\n\t\t\tgf_free(ptr);\n\t\t\treturn NULL;\n\t\t}\n\t\tfor (i=0; i<ptr->nb_types; i++) {\n\t\t\tptr->group_types[i] = gf_bs_read_u32(bs);\n\t\t\t*total_bytes += 4;\n\t\t}\n\t\treturn ptr;\n\t}\n\tcase 0:\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] sgpd entry null grouping_type is invalid\\n\") );\n\t\treturn NULL;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (!entry_size && !null_size_ok) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] %s sample group does not indicate entry size and is not implemented, cannot parse!\\n\", gf_4cc_to_str( p->grouping_type) ));\n\t\treturn NULL;\n\t}\n\tp->is_opaque = GF_TRUE;\n\tGF_SAFEALLOC(def_ptr, GF_DefaultSampleGroupDescriptionEntry);\n\tif (!def_ptr) return NULL;\n\tif (entry_size) {\n\t\tdef_ptr->length = entry_size;\n\t\tdef_ptr->data = (u8 *) gf_malloc(sizeof(u8)*def_ptr->length);\n\t\tif (!def_ptr->data) {\n\t\t\tgf_free(def_ptr);\n\t\t\treturn NULL;\n\t\t}\n\t\tgf_bs_read_data(bs, (char *) def_ptr->data, def_ptr->length);\n\t\t*total_bytes = entry_size;\n\t}\n\treturn def_ptr;\n}\n\nvoid sgpd_del_entry(u32 grouping_type, void *entry)\n{\n\tswitch (grouping_type) {\n\tcase GF_ISOM_SAMPLE_GROUP_SYNC:\n\tcase GF_ISOM_SAMPLE_GROUP_ROLL:\n\tcase GF_ISOM_SAMPLE_GROUP_PROL:\n\tcase GF_ISOM_SAMPLE_GROUP_RAP:\n\tcase GF_ISOM_SAMPLE_GROUP_TELE:\n\tcase GF_ISOM_SAMPLE_GROUP_SAP:\n\t\tgf_free(entry);\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_SEIG:\n\t{\n\t\tGF_CENCSampleEncryptionGroupEntry *seig = (GF_CENCSampleEncryptionGroupEntry *)entry;\n\t\tif (seig->key_info) gf_free(seig->key_info);\n\t\tgf_free(entry);\n\t}\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_OINF:\n\t\tgf_isom_oinf_del_entry(entry);\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_LINF:\n\t\tgf_isom_linf_del_entry(entry);\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_SPOR:\n\t{\n\t\tGF_SubpictureOrderEntry *spor = (GF_SubpictureOrderEntry *)entry;\n\t\tif (spor->subp_track_ref_idx) gf_free(spor->subp_track_ref_idx);\n\t\tgf_free(spor);\n\t}\n\t\treturn;\n\n\tcase GF_ISOM_SAMPLE_GROUP_SULM:\n\t{\n\t\tGF_SubpictureLayoutMapEntry *sulm = (GF_SubpictureLayoutMapEntry *) entry;\n\t\tif (sulm->groupIDs) gf_free(sulm->groupIDs);\n\t\tgf_free(sulm);\n\t\treturn;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_ILCE:\n\t\tgf_free(entry);\n\t\treturn;\n\n\tcase GF_ISOM_SAMPLE_GROUP_ESGH:\n\t{\n\t\tGF_EssentialSamplegroupEntry *esgh = (GF_EssentialSamplegroupEntry *) entry;\n\t\tif (esgh->group_types) gf_free(esgh->group_types);\n\t\tgf_free(esgh);\n\t\treturn;\n\t}\n\n\tdefault:\n\t{\n\t\tGF_DefaultSampleGroupDescriptionEntry *ptr = (GF_DefaultSampleGroupDescriptionEntry *)entry;\n\t\tif (ptr->data) gf_free(ptr->data);\n\t\tgf_free(ptr);\n\t}\n\t}\n}\n\nvoid sgpd_write_entry(u32 grouping_type, void *entry, GF_BitStream *bs)\n{\n\tswitch (grouping_type) {\n\tcase GF_ISOM_SAMPLE_GROUP_ROLL:\n\tcase GF_ISOM_SAMPLE_GROUP_PROL:\n\t\tgf_bs_write_int(bs, ((GF_RollRecoveryEntry*)entry)->roll_distance, 16);\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_RAP:\n\t\tgf_bs_write_int(bs, ((GF_VisualRandomAccessEntry*)entry)->num_leading_samples_known, 1);\n\t\tgf_bs_write_int(bs, ((GF_VisualRandomAccessEntry*)entry)->num_leading_samples, 7);\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_SAP:\n\t\tgf_bs_write_int(bs, ((GF_SAPEntry*)entry)->dependent_flag, 1);\n\t\tgf_bs_write_int(bs, 0, 3);\n\t\tgf_bs_write_int(bs, ((GF_SAPEntry*)entry)->SAP_type, 4);\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_SYNC:\n\t\tgf_bs_write_int(bs, 0, 2);\n\t\tgf_bs_write_int(bs, ((GF_SYNCEntry*)entry)->NALU_type, 6);\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_TELE:\n\t\tgf_bs_write_int(bs, ((GF_TemporalLevelEntry*)entry)->level_independently_decodable, 1);\n\t\tgf_bs_write_int(bs, 0, 7);\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_SEIG:\n\t{\n\t\tGF_CENCSampleEncryptionGroupEntry *seig = (GF_CENCSampleEncryptionGroupEntry *)entry;\n\t\tBool use_mkey = seig->key_info[0];\n\t\tu32 nb_keys = 1;\n\t\tif (use_mkey) {\n\t\t\tnb_keys = seig->key_info[1];\n\t\t\tnb_keys<<=8;\n\t\t\tnb_keys |= seig->key_info[2];\n\t\t}\n\t\tgf_bs_write_int(bs, use_mkey ? 1 : 0, 1);\n\t\tgf_bs_write_int(bs, 0, 7);\n\t\tgf_bs_write_int(bs, seig->crypt_byte_block, 4);\n\t\tgf_bs_write_int(bs, seig->skip_byte_block, 4);\n\t\tgf_bs_write_u8(bs, seig->IsProtected);\n\t\tif (nb_keys>1) {\n\t\t\tgf_bs_write_data(bs, seig->key_info+1, seig->key_info_size-1);\n\t\t} else {\n\t\t\tgf_bs_write_data(bs, seig->key_info+3, seig->key_info_size - 3);\n\t\t}\n\t}\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_OINF:\n\t\tgf_isom_oinf_write_entry(entry, bs);\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_LINF:\n\t\tgf_isom_linf_write_entry(entry, bs);\n\t\treturn;\n\n\tcase GF_ISOM_SAMPLE_GROUP_SPOR:\n\t{\n\t\tu32 i;\n\t\tGF_SubpictureOrderEntry *spor = (GF_SubpictureOrderEntry *) entry;\n\t\tgf_bs_write_int(bs, spor->subpic_id_info_flag, 1);\n\t\tgf_bs_write_int(bs, spor->num_subpic_ref_idx, 15);\n\t\tfor (i=0; i<spor->num_subpic_ref_idx; i++) {\n\t\t\tgf_bs_write_u16(bs, spor->subp_track_ref_idx[i]);\n\t\t}\n\t\tif (spor->subpic_id_info_flag) {\n\t\t\tgf_bs_write_int(bs, spor->spinfo.subpic_id_len_minus1, 4);\n\t\t\tgf_bs_write_int(bs, spor->spinfo.subpic_id_bit_pos, 12);\n\t\t\tgf_bs_write_int(bs, spor->spinfo.start_code_emul_flag, 1);\n\t\t\tgf_bs_write_int(bs, spor->spinfo.pps_sps_subpic_id_flag, 1);\n\t\t\tif (spor->spinfo.pps_sps_subpic_id_flag) {\n\t\t\t\tgf_bs_write_int(bs, spor->spinfo.xps_id, 6);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_int(bs, spor->spinfo.xps_id, 4);\n\t\t\t\tgf_bs_write_int(bs, 0, 2);\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\tcase GF_ISOM_SAMPLE_GROUP_SULM:\n\t{\n\t\tu32 i;\n\t\tGF_SubpictureLayoutMapEntry *sulm = (GF_SubpictureLayoutMapEntry *) entry;\n\t\tgf_bs_write_u32(bs, sulm->groupID_info_4cc);\n\t\tgf_bs_write_u16(bs, sulm->nb_entries - 1);\n\t\tfor (i=0; i<sulm->nb_entries; i++) {\n\t\t\tgf_bs_write_u16(bs, sulm->groupIDs[i]);\n\t\t}\n\t\treturn;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_ILCE:\n\t{\n\t\tGF_FieldInterlaceType *ilce = (GF_FieldInterlaceType *) entry;\n\t\tgf_bs_write_u8(bs, ilce->ilce_type);\n\t\treturn;\n\t}\n\n\tcase GF_ISOM_SAMPLE_GROUP_ESGH:\n\t{\n\t\tu32 i;\n\t\tGF_EssentialSamplegroupEntry *esgh = (GF_EssentialSamplegroupEntry *) entry;\n\t\tgf_bs_write_u32(bs, esgh->nb_types);\n\t\tfor (i=0; i<esgh->nb_types; i++) {\n\t\t\tgf_bs_write_u32(bs, esgh->group_types[i]);\n\t\t}\n\t\treturn;\n\t}\n\n\tdefault:\n\t{\n\t\tGF_DefaultSampleGroupDescriptionEntry *ptr = (GF_DefaultSampleGroupDescriptionEntry *)entry;\n\t\tif (ptr->length)\n\t\t\tgf_bs_write_data(bs, (char *) ptr->data, ptr->length);\n\t}\n\t}\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nstatic u32 sgpd_size_entry(u32 grouping_type, void *entry)\n{\n\tswitch (grouping_type) {\n\tcase GF_ISOM_SAMPLE_GROUP_ROLL:\n\tcase GF_ISOM_SAMPLE_GROUP_PROL:\n\t\treturn 2;\n\tcase GF_ISOM_SAMPLE_GROUP_TELE:\n\tcase GF_ISOM_SAMPLE_GROUP_RAP:\n\tcase GF_ISOM_SAMPLE_GROUP_SAP:\n\tcase GF_ISOM_SAMPLE_GROUP_SYNC:\n\t\treturn 1;\n\tcase GF_ISOM_SAMPLE_GROUP_TSCL:\n\t\treturn 20;\n\tcase GF_ISOM_SAMPLE_GROUP_LBLI:\n\t\treturn 2;\n\tcase GF_ISOM_SAMPLE_GROUP_TSAS:\n\tcase GF_ISOM_SAMPLE_GROUP_STSA:\n\t\treturn 0;\n\tcase GF_ISOM_SAMPLE_GROUP_SEIG:\n\t{\n\t\tGF_CENCSampleEncryptionGroupEntry *seig = (GF_CENCSampleEncryptionGroupEntry *)entry;\n\t\tBool use_mkey = seig->key_info[0] ? GF_TRUE : GF_FALSE;\n\t\tif (use_mkey) {\n\t\t\treturn 3 + seig->key_info_size-1;\n\t\t}\n\t\treturn seig->key_info_size; //== 3 + (seig->key_info_size-3);\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_OINF:\n\t\treturn gf_isom_oinf_size_entry(entry);\n\tcase GF_ISOM_SAMPLE_GROUP_LINF:\n\t\treturn gf_isom_linf_size_entry(entry);\n\tcase GF_ISOM_SAMPLE_GROUP_SPOR:\n\t{\n\t\tGF_SubpictureOrderEntry *spor = (GF_SubpictureOrderEntry *)entry;\n\t\tu32 s = 2 + 2*spor->num_subpic_ref_idx;\n\t\tif (spor->subpic_id_info_flag) {\n\t\t\ts += 3;\n\t\t}\n\t\treturn s;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_SULM:\n\t{\n\t\tGF_SubpictureLayoutMapEntry *sulm = (GF_SubpictureLayoutMapEntry *) entry;\n\t\treturn 6 + 2*sulm->nb_entries;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_ILCE:\n\t\treturn 1;\n\n\tcase GF_ISOM_SAMPLE_GROUP_ESGH:\n\t{\n\t\tGF_EssentialSamplegroupEntry *esgh = (GF_EssentialSamplegroupEntry *) entry;\n\t\treturn 4 + 4*esgh->nb_types;\n\t}\n\n\tdefault:\n\t\treturn ((GF_DefaultSampleGroupDescriptionEntry *)entry)->length;\n\t}\n}\n#endif\n\nGF_Box *sgpd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleGroupDescriptionBox, GF_ISOM_BOX_TYPE_SGPD);\n\t/*version 0 is deprecated, use v1 by default*/\n\ttmp->version = 1;\n\ttmp->group_descriptions = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\nvoid sgpd_box_del(GF_Box *a)\n{\n\tGF_SampleGroupDescriptionBox *p = (GF_SampleGroupDescriptionBox *)a;\n\twhile (gf_list_count(p->group_descriptions)) {\n\t\tvoid *ptr = gf_list_last(p->group_descriptions);\n\t\tsgpd_del_entry(p->grouping_type, ptr);\n\t\tgf_list_rem_last(p->group_descriptions);\n\t}\n\tgf_list_del(p->group_descriptions);\n\tgf_free(p);\n}\n\nGF_Err sgpd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 entry_count;\n\tGF_SampleGroupDescriptionBox *p = (GF_SampleGroupDescriptionBox *)s;\n\n\tISOM_DECREASE_SIZE(p, 8);\n\tp->grouping_type = gf_bs_read_u32(bs);\n\n\tif (p->version>=1) {\n\t\tISOM_DECREASE_SIZE(p, 4);\n\t\tp->default_length = gf_bs_read_u32(bs);\n\t}\n\tif (p->version>=2) {\n\t\tISOM_DECREASE_SIZE(p, 4);\n\t\tp->default_description_index = gf_bs_read_u32(bs);\n\t}\n\tentry_count = gf_bs_read_u32(bs);\n\n\tif (entry_count>p->size)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\twhile (entry_count) {\n\t\tvoid *ptr;\n\t\tu32 parsed_bytes=0;\n\t\tu32 size = p->default_length;\n\t\tif ((p->version>=1) && !size) {\n\t\t\tsize = gf_bs_read_u32(bs);\n\t\t\tISOM_DECREASE_SIZE(p, 4);\n\t\t}\n\t\tptr = sgpd_parse_entry(p, bs, (s32) p->size, size, &parsed_bytes);\n\t\t//don't return an error, just stop parsing so that we skip over the sgpd box\n\t\tif (!ptr) return GF_OK;\n\t\tgf_list_add(p->group_descriptions, ptr);\n\n\t\tISOM_DECREASE_SIZE(p, parsed_bytes);\n\t\tentry_count--;\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err sgpd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i, nb_descs;\n\tGF_SampleGroupDescriptionBox *p = (GF_SampleGroupDescriptionBox *)s;\n\tGF_Err e;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, p->grouping_type);\n\tif (p->version>=1) gf_bs_write_u32(bs, p->default_length);\n\tif (p->version>=2) gf_bs_write_u32(bs, p->default_description_index);\n\tnb_descs = gf_list_count(p->group_descriptions);\n\tgf_bs_write_u32(bs, nb_descs);\n\n\tfor (i=0; i<nb_descs; i++) {\n\t\tvoid *ptr = gf_list_get(p->group_descriptions, i);\n\t\tif ((p->version >= 1) && !p->default_length) {\n\t\t\tu32 size = sgpd_size_entry(p->grouping_type, ptr);\n\t\t\tgf_bs_write_u32(bs, size);\n\t\t}\n\t\tsgpd_write_entry(p->grouping_type, ptr, bs);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err sgpd_box_size(GF_Box *s)\n{\n\tu32 i, nb_descs;\n\tBool use_def_size = GF_TRUE;\n\tGF_SampleGroupDescriptionBox *p = (GF_SampleGroupDescriptionBox *)s;\n\n\tp->size += 8;\n\n\t//we force all sample groups to version 1, v0 being deprecated\n\tif (!p->version)\n\t\tp->version = 1;\n\tp->size += 4;\n\n\tif (p->version>=2)\n\t\tp->size += 4;\n\tp->default_length = 0;\n\n\tnb_descs = gf_list_count(p->group_descriptions);\n\tfor (i=0; i<nb_descs; i++) {\n\t\tvoid *ptr = gf_list_get(p->group_descriptions, i);\n\t\tu32 size = sgpd_size_entry(p->grouping_type, ptr);\n\t\tp->size += size;\n\t\tif (use_def_size && !p->default_length) {\n\t\t\tp->default_length = size;\n\t\t} else if (p->default_length != size) {\n\t\t\tuse_def_size = GF_FALSE;\n\t\t\tp->default_length = 0;\n\t\t}\n\t}\n\tif (p->version>=1) {\n\t\tif (!p->default_length) p->size += nb_descs * 4;\n\t}\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid saiz_box_del(GF_Box *s)\n{\n\tGF_SampleAuxiliaryInfoSizeBox*ptr = (GF_SampleAuxiliaryInfoSizeBox*)s;\n\tif (ptr == NULL) return;\n\tif (ptr->sample_info_size) gf_free(ptr->sample_info_size);\n\tgf_free(ptr);\n}\n\n\nGF_Err saiz_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_SampleAuxiliaryInfoSizeBox*ptr = (GF_SampleAuxiliaryInfoSizeBox*)s;\n\n\tif (ptr->flags & 1) {\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\tptr->aux_info_type = gf_bs_read_u32(bs);\n\t\tptr->aux_info_type_parameter = gf_bs_read_u32(bs);\n\t}\n\tISOM_DECREASE_SIZE(ptr, 5);\n\tptr->default_sample_info_size = gf_bs_read_u8(bs);\n\tptr->sample_count = gf_bs_read_u32(bs);\n\n\tif (ptr->default_sample_info_size == 0) {\n\t\tif (ptr->size < ptr->sample_count)\n\t\t    return GF_ISOM_INVALID_FILE;\n\n\t\tptr->sample_info_size = gf_malloc(sizeof(u8)*ptr->sample_count);\n\t\tptr->sample_alloc = ptr->sample_count;\n\t\tif (!ptr->sample_info_size)\n\t\t    return GF_OUT_OF_MEM;\n\n\t\tISOM_DECREASE_SIZE(ptr, ptr->sample_count);\n\t\tgf_bs_read_data(bs, (char *) ptr->sample_info_size, ptr->sample_count);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *saiz_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleAuxiliaryInfoSizeBox, GF_ISOM_BOX_TYPE_SAIZ);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err saiz_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SampleAuxiliaryInfoSizeBox*ptr = (GF_SampleAuxiliaryInfoSizeBox*) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tif (ptr->flags & 1) {\n\t\tgf_bs_write_u32(bs, ptr->aux_info_type);\n\t\tgf_bs_write_u32(bs, ptr->aux_info_type_parameter);\n\t}\n\tgf_bs_write_u8(bs, ptr->default_sample_info_size);\n\tgf_bs_write_u32(bs, ptr->sample_count);\n\tif (!ptr->default_sample_info_size) {\n\t\tif (!ptr->sample_info_size)\n\t\t\tgf_bs_write_u8(bs, 0);\n\t\telse\n\t\t\tgf_bs_write_data(bs, (char *) ptr->sample_info_size, ptr->sample_count);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err saiz_box_size(GF_Box *s)\n{\n\tGF_SampleAuxiliaryInfoSizeBox *ptr = (GF_SampleAuxiliaryInfoSizeBox*)s;\n\n\tif (ptr->aux_info_type || ptr->aux_info_type_parameter) {\n\t\tptr->flags |= 1;\n\t}\n\tif (ptr->flags & 1) ptr->size += 8;\n\tptr->size += 5;\n\tif (ptr->default_sample_info_size==0)  ptr->size += ptr->sample_count;\n\treturn GF_OK;\n}\n#endif //GPAC_DISABLE_ISOM_WRITE\n\nvoid saio_box_del(GF_Box *s)\n{\n\tGF_SampleAuxiliaryInfoOffsetBox *ptr = (GF_SampleAuxiliaryInfoOffsetBox*)s;\n\tif (ptr == NULL) return;\n\tif (ptr->offsets) gf_free(ptr->offsets);\n\tif (ptr->cached_data) gf_free(ptr->cached_data);\n\tgf_free(ptr);\n}\n\n\nGF_Err saio_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_SampleAuxiliaryInfoOffsetBox *ptr = (GF_SampleAuxiliaryInfoOffsetBox *)s;\n\n\tif (ptr->flags & 1) {\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\tptr->aux_info_type = gf_bs_read_u32(bs);\n\t\tptr->aux_info_type_parameter = gf_bs_read_u32(bs);\n\t}\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->entry_count = gf_bs_read_u32(bs);\n\n\tif (ptr->entry_count) {\n\t\tu32 i;\n\t\tif (ptr->size / (ptr->version == 0 ? 4 : 8) < ptr->entry_count || (u64)ptr->entry_count > (u64)SIZE_MAX/sizeof(u64))\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\tptr->offsets = gf_malloc(sizeof(u64)*ptr->entry_count);\n\t\tif (!ptr->offsets)\n\t\t\treturn GF_OUT_OF_MEM;\n\t\tptr->entry_alloc = ptr->entry_count;\n\t\tif (ptr->version==0) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 4*ptr->entry_count);\n\t\t\tfor (i=0; i<ptr->entry_count; i++)\n\t\t\t\tptr->offsets[i] = gf_bs_read_u32(bs);\n\t\t} else {\n\t\t\tISOM_DECREASE_SIZE(ptr, 8*ptr->entry_count);\n\t\t\tfor (i=0; i<ptr->entry_count; i++)\n\t\t\t\tptr->offsets[i] = gf_bs_read_u64(bs);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *saio_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleAuxiliaryInfoOffsetBox, GF_ISOM_BOX_TYPE_SAIO);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err saio_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SampleAuxiliaryInfoOffsetBox *ptr = (GF_SampleAuxiliaryInfoOffsetBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tif (ptr->flags & 1) {\n\t\tgf_bs_write_u32(bs, ptr->aux_info_type);\n\t\tgf_bs_write_u32(bs, ptr->aux_info_type_parameter);\n\t}\n\n\n\tgf_bs_write_u32(bs, ptr->entry_count);\n\tif (ptr->entry_count) {\n\t\tu32 i;\n\t\tif (ptr->sai_data) {\n\t\t\tif (ptr->sai_data->sai_offset) {\n\t\t\t\tif (ptr->version==0) {\n\t\t\t\t\tgf_bs_write_u32(bs, (u32) ptr->sai_data->sai_offset);\n\t\t\t\t} else {\n\t\t\t\t\tgf_bs_write_u64(bs, ptr->sai_data->sai_offset);\n\t\t\t\t}\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\tptr->sai_data->saio_box = ptr;\n\t\t}\n\n\t\t//store position in bitstream before writing data - offsets can be NULL if a single offset is rewritten later on (cf senc_box_write)\n\t\tptr->offset_first_offset_field = gf_bs_get_position(bs);\n\t\tif (ptr->version==0) {\n\t\t\tif (!ptr->offsets) {\n\t\t\t\tgf_bs_write_u32(bs, 0);\n\t\t\t} else {\n\t\t\t\tfor (i=0; i<ptr->entry_count; i++)\n\t\t\t\t\tgf_bs_write_u32(bs, (u32) ptr->offsets[i]);\n\t\t\t}\n\t\t} else {\n\t\t\tif (!ptr->offsets) {\n\t\t\t\tgf_bs_write_u64(bs, 0);\n\t\t\t} else {\n\t\t\t\tfor (i=0; i<ptr->entry_count; i++)\n\t\t\t\t\tgf_bs_write_u64(bs, ptr->offsets[i]);\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err saio_box_size(GF_Box *s)\n{\n\tGF_SampleAuxiliaryInfoOffsetBox *ptr = (GF_SampleAuxiliaryInfoOffsetBox*)s;\n\n\tif (ptr->aux_info_type || ptr->aux_info_type_parameter) {\n\t\tptr->flags |= 1;\n\t}\n\n\tif (ptr->flags & 1) ptr->size += 8;\n\tptr->size += 4;\n\t//a little optim here: in cenc, the saio always points to a single data block, only one entry is needed\n\tswitch (ptr->aux_info_type) {\n\tcase GF_ISOM_CENC_SCHEME:\n\tcase GF_ISOM_CBC_SCHEME:\n\tcase GF_ISOM_CENS_SCHEME:\n\tcase GF_ISOM_CBCS_SCHEME:\n\t\tif (ptr->offsets) gf_free(ptr->offsets);\n\t\tptr->offsets = NULL;\n\t\tptr->entry_alloc = 0;\n\t\tptr->entry_count = 1;\n\t\tbreak;\n\t}\n\n\tptr->size += ((ptr->version==1) ? 8 : 4) * ptr->entry_count;\n\treturn GF_OK;\n}\n#endif //GPAC_DISABLE_ISOM_WRITE\n\n\nvoid prft_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err prft_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_ProducerReferenceTimeBox *ptr = (GF_ProducerReferenceTimeBox *) s;\n\n\tISOM_DECREASE_SIZE(ptr, 12);\n\tptr->refTrackID = gf_bs_read_u32(bs);\n\tptr->ntp = gf_bs_read_u64(bs);\n\tif (ptr->version==0) {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->timestamp = gf_bs_read_u32(bs);\n\t} else {\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\tptr->timestamp = gf_bs_read_u64(bs);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *prft_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ProducerReferenceTimeBox, GF_ISOM_BOX_TYPE_PRFT);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err prft_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ProducerReferenceTimeBox *ptr = (GF_ProducerReferenceTimeBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->refTrackID);\n\tgf_bs_write_u64(bs, ptr->ntp);\n\tif (ptr->version==0) {\n\t\tgf_bs_write_u32(bs, (u32) ptr->timestamp);\n\t} else {\n\t\tgf_bs_write_u64(bs, ptr->timestamp);\n\t}\n\n\treturn GF_OK;\n}\n\nGF_Err prft_box_size(GF_Box *s)\n{\n\tGF_ProducerReferenceTimeBox *ptr = (GF_ProducerReferenceTimeBox*)s;\n\n\tptr->size += 4+8+ (ptr->version ? 8 : 4);\n\treturn GF_OK;\n}\n#endif //GPAC_DISABLE_ISOM_WRITE\n\nGF_Box *trgr_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackGroupBox, GF_ISOM_BOX_TYPE_TRGR);\n\ttmp->groups = gf_list_new();\n\tif (!tmp->groups) {\n\t\tgf_free(tmp);\n\t\treturn NULL;\n\t}\n\treturn (GF_Box *)tmp;\n}\n\nvoid trgr_box_del(GF_Box *s)\n{\n\tGF_TrackGroupBox *ptr = (GF_TrackGroupBox *)s;\n\tif (ptr == NULL) return;\n\tgf_list_del(ptr->groups);\n\tgf_free(ptr);\n}\n\n\nGF_Err trgr_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_TrackGroupBox *ptr = (GF_TrackGroupBox *)s;\n\n\tBOX_FIELD_LIST_ASSIGN(groups)\n\treturn GF_OK;\n}\n\n\nGF_Err trgr_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err trgr_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err trgr_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_TrackGroupBox *ptr = (GF_TrackGroupBox *) s;\n\tgf_isom_check_position_list(s, ptr->groups, &pos);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *trgt_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackGroupTypeBox, GF_ISOM_BOX_TYPE_TRGT);\n\treturn (GF_Box *)tmp;\n}\n\nvoid trgt_box_del(GF_Box *s)\n{\n\tGF_TrackGroupTypeBox *ptr = (GF_TrackGroupTypeBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\nGF_Err trgt_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TrackGroupTypeBox *ptr = (GF_TrackGroupTypeBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->track_group_id = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err trgt_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TrackGroupTypeBox *ptr = (GF_TrackGroupTypeBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\tif (ptr->group_type == GF_ISOM_BOX_TYPE_UUID) return GF_BAD_PARAM;\n\ts->type = ptr->group_type;\n\te = gf_isom_full_box_write(s, bs);\n\ts->type = GF_ISOM_BOX_TYPE_TRGT;\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->track_group_id);\n\treturn GF_OK;\n}\n\nGF_Err trgt_box_size(GF_Box *s)\n{\n\tGF_TrackGroupBox *ptr = (GF_TrackGroupBox *)s;\n\n\tptr->size+= 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Box *stvi_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_StereoVideoBox, GF_ISOM_BOX_TYPE_STVI);\n\treturn (GF_Box *)tmp;\n}\n\nvoid stvi_box_del(GF_Box *s)\n{\n\tGF_StereoVideoBox *ptr = (GF_StereoVideoBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->stereo_indication_type) gf_free(ptr->stereo_indication_type);\n\tgf_free(ptr);\n}\n\nGF_Err stvi_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_StereoVideoBox *ptr = (GF_StereoVideoBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 12);\n\tgf_bs_read_int(bs, 30);\n\tptr->single_view_allowed = gf_bs_read_int(bs, 2);\n\tptr->stereo_scheme = gf_bs_read_u32(bs);\n\tptr->sit_len = gf_bs_read_u32(bs);\n\tISOM_DECREASE_SIZE(ptr, ptr->sit_len);\n\n\tptr->stereo_indication_type = gf_malloc(sizeof(char)*ptr->sit_len);\n\tif (!ptr->stereo_indication_type) return GF_OUT_OF_MEM;\n\n\tgf_bs_read_data(bs, ptr->stereo_indication_type, ptr->sit_len);\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stvi_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_StereoVideoBox *ptr = (GF_StereoVideoBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_int(bs, 0, 30);\n\tgf_bs_write_int(bs, ptr->single_view_allowed, 2);\n\tgf_bs_write_u32(bs, ptr->stereo_scheme);\n\tgf_bs_write_u32(bs, ptr->sit_len);\n\tgf_bs_write_data(bs, ptr->stereo_indication_type, ptr->sit_len);\n\n\treturn GF_OK;\n}\n\nGF_Err stvi_box_size(GF_Box *s)\n{\n\tGF_StereoVideoBox *ptr = (GF_StereoVideoBox *)s;\n\n\tptr->size+= 12 + ptr->sit_len;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Box *fiin_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(FDItemInformationBox, GF_ISOM_BOX_TYPE_FIIN);\n\treturn (GF_Box *)tmp;\n}\n\nvoid fiin_box_del(GF_Box *s)\n{\n\tFDItemInformationBox *ptr = (FDItemInformationBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->partition_entries) gf_list_del(ptr->partition_entries);\n\tgf_free(ptr);\n}\n\n\nGF_Err fiin_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tFDItemInformationBox *ptr = (FDItemInformationBox *)s;\n\tswitch(a->type) {\n\tcase GF_ISOM_BOX_TYPE_PAEN:\n\t\tBOX_FIELD_LIST_ASSIGN(partition_entries)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_SEGR:\n\t\tBOX_FIELD_ASSIGN(session_info, FDSessionGroupBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_GITN:\n\t\tBOX_FIELD_ASSIGN(group_id_to_name, GroupIdToNameBox)\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err fiin_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tFDItemInformationBox *ptr = (FDItemInformationBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 2);\n\tgf_bs_read_u16(bs);\n\treturn gf_isom_box_array_read(s, bs);\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err fiin_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tFDItemInformationBox *ptr = (FDItemInformationBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u16(bs, gf_list_count(ptr->partition_entries) );\n\treturn GF_OK;\n}\n\nGF_Err fiin_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tFDItemInformationBox *ptr = (FDItemInformationBox *) s;\n\ts->size+= 2;\n\tgf_isom_check_position_list(s, ptr->partition_entries, &pos);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *paen_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(FDPartitionEntryBox, GF_ISOM_BOX_TYPE_PAEN);\n\treturn (GF_Box *)tmp;\n}\n\nvoid paen_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\n\nGF_Err paen_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tFDPartitionEntryBox *ptr = (FDPartitionEntryBox *)s;\n\tswitch(a->type) {\n\tcase GF_ISOM_BOX_TYPE_FPAR:\n\t\tBOX_FIELD_ASSIGN(blocks_and_symbols, FilePartitionBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_FECR:\n\t\tBOX_FIELD_ASSIGN(FEC_symbol_locations, FECReservoirBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_FIRE:\n\t\tBOX_FIELD_ASSIGN(File_symbol_locations, FileReservoirBox)\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err paen_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err paen_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tif (!s) return GF_BAD_PARAM;\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err paen_box_size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n\nGF_Box *fpar_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(FilePartitionBox, GF_ISOM_BOX_TYPE_FPAR);\n\treturn (GF_Box *)tmp;\n}\n\nvoid fpar_box_del(GF_Box *s)\n{\n\tFilePartitionBox *ptr = (FilePartitionBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->scheme_specific_info) gf_free(ptr->scheme_specific_info);\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);\n}\n\nGF_Err gf_isom_read_null_terminated_string(GF_Box *s, GF_BitStream *bs, u64 size, char **out_str)\n{\n\tu32 len=10;\n\tu32 i=0;\n\n\t*out_str = gf_malloc(sizeof(char)*len);\n\tif (! *out_str) return GF_OUT_OF_MEM;\n\n\tif (!s->size) {\n\t\t*out_str[0] = 0;\n\t\treturn GF_OK;\n\t}\n\n\twhile (1) {\n\t\tISOM_DECREASE_SIZE(s, 1 );\n\t\t(*out_str)[i] = gf_bs_read_u8(bs);\n\t\tif (!(*out_str)[i]) break;\n\t\ti++;\n\t\tif (i==len) {\n\t\t\tlen += 10;\n\t\t\t*out_str = gf_realloc(*out_str, sizeof(char)*len);\n\t\t}\n\t\tif (gf_bs_available(bs) == 0) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] missing null character in null terminated string\\n\"));\n\t\t\t(*out_str)[i] = 0;\n\t\t\treturn GF_OK;\n\t\t}\n\t\tif (i >= size) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] string bigger than container, probably missing null character\\n\"));\n\t\t\t(*out_str)[i] = 0;\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err fpar_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_Err e;\n\tFilePartitionBox *ptr = (FilePartitionBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, ((ptr->version ? 4 : 2) + 12) );\n\tptr->itemID = gf_bs_read_int(bs, ptr->version ? 32 : 16);\n\tptr->packet_payload_size = gf_bs_read_u16(bs);\n\tgf_bs_read_u8(bs);\n\tptr->FEC_encoding_ID = gf_bs_read_u8(bs);\n\tptr->FEC_instance_ID = gf_bs_read_u16(bs);\n\tptr->max_source_block_length = gf_bs_read_u16(bs);\n\tptr->encoding_symbol_length = gf_bs_read_u16(bs);\n\tptr->max_number_of_encoding_symbols = gf_bs_read_u16(bs);\n\n\te = gf_isom_read_null_terminated_string(s, bs, ptr->size, &ptr->scheme_specific_info);\n\tif (e) return e;\n\n\tISOM_DECREASE_SIZE(ptr, (ptr->version ? 4 : 2) );\n\tptr->nb_entries = gf_bs_read_int(bs, ptr->version ? 32 : 16);\n\tif (ptr->nb_entries > ptr->size / 6 || (u64)ptr->nb_entries > (u64)SIZE_MAX/sizeof(FilePartitionEntry))\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tISOM_DECREASE_SIZE(ptr, ptr->nb_entries * 6 );\n\tGF_SAFE_ALLOC_N(ptr->entries, ptr->nb_entries, FilePartitionEntry);\n\tif (!ptr->entries) return GF_OUT_OF_MEM;\n\n\tfor (i=0;i < ptr->nb_entries; i++) {\n\t\tptr->entries[i].block_count = gf_bs_read_u16(bs);\n\t\tptr->entries[i].block_size = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err fpar_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tFilePartitionBox *ptr = (FilePartitionBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_int(bs, ptr->itemID, ptr->version ? 32 : 16);\n\tgf_bs_write_u16(bs, ptr->packet_payload_size);\n\tgf_bs_write_u8(bs, 0);\n\tgf_bs_write_u8(bs, ptr->FEC_encoding_ID);\n\tgf_bs_write_u16(bs, ptr->FEC_instance_ID);\n\tgf_bs_write_u16(bs, ptr->max_source_block_length);\n\tgf_bs_write_u16(bs, ptr->encoding_symbol_length);\n\tgf_bs_write_u16(bs, ptr->max_number_of_encoding_symbols);\n\tif (ptr->scheme_specific_info) {\n\t\tgf_bs_write_data(bs, ptr->scheme_specific_info, (u32)strlen(ptr->scheme_specific_info) );\n\t}\n\t//null terminated string\n\tgf_bs_write_u8(bs, 0);\n\n\tgf_bs_write_int(bs, ptr->nb_entries, ptr->version ? 32 : 16);\n\n\tfor (i=0;i < ptr->nb_entries; i++) {\n\t\tgf_bs_write_u16(bs, ptr->entries[i].block_count);\n\t\tgf_bs_write_u32(bs, ptr->entries[i].block_size);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err fpar_box_size(GF_Box *s)\n{\n\tFilePartitionBox *ptr = (FilePartitionBox *)s;\n\n\tptr->size += 13 + (ptr->version ? 8 : 4);\n\tif (ptr->scheme_specific_info)\n\t\tptr->size += strlen(ptr->scheme_specific_info);\n\n\tptr->size+= ptr->nb_entries * 6;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *fecr_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(FECReservoirBox, GF_ISOM_BOX_TYPE_FECR);\n\treturn (GF_Box *)tmp;\n}\n\nvoid fecr_box_del(GF_Box *s)\n{\n\tFECReservoirBox *ptr = (FECReservoirBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);\n}\n\nGF_Err fecr_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tFECReservoirBox *ptr = (FECReservoirBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, (ptr->version ? 4 : 2) );\n\tptr->nb_entries = gf_bs_read_int(bs, ptr->version ? 32 : 16);\n\n\tif (ptr->nb_entries > ptr->size / (ptr->version ? 8 : 6) || (u64)ptr->nb_entries > (u64)SIZE_MAX/sizeof(FECReservoirEntry) ) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in fecr\\n\", ptr->nb_entries));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tISOM_DECREASE_SIZE(ptr, ptr->nb_entries * (ptr->version ? 8 : 6) );\n\tGF_SAFE_ALLOC_N(ptr->entries, ptr->nb_entries, FECReservoirEntry);\n\tif (!ptr->entries) return GF_OUT_OF_MEM;\n\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tptr->entries[i].item_id = gf_bs_read_int(bs, ptr->version ? 32 : 16);\n\t\tptr->entries[i].symbol_count = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err fecr_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tFECReservoirBox *ptr = (FECReservoirBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_int(bs, ptr->nb_entries, ptr->version ? 32 : 16);\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tgf_bs_write_int(bs, ptr->entries[i].item_id, ptr->version ? 32 : 16);\n\t\tgf_bs_write_u32(bs, ptr->entries[i].symbol_count);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err fecr_box_size(GF_Box *s)\n{\n\tFECReservoirBox *ptr = (FECReservoirBox *)s;\n\tptr->size += (ptr->version ? 4 : 2) +  ptr->nb_entries * (ptr->version ? 8 : 6);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Box *segr_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(FDSessionGroupBox, GF_ISOM_BOX_TYPE_SEGR);\n\treturn (GF_Box *)tmp;\n}\n\nvoid segr_box_del(GF_Box *s)\n{\n\tu32 i;\n\tFDSessionGroupBox *ptr = (FDSessionGroupBox *)s;\n\tif (ptr == NULL) return;\n\tfor (i=0; i<ptr->num_session_groups; i++) {\n\t\tif (ptr->session_groups[i].group_ids) gf_free(ptr->session_groups[i].group_ids);\n\t\tif (ptr->session_groups[i].channels) gf_free(ptr->session_groups[i].channels);\n\t}\n\tif (ptr->session_groups) gf_free(ptr->session_groups);\n\tgf_free(ptr);\n}\n\nGF_Err segr_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i, k;\n\tFDSessionGroupBox *ptr = (FDSessionGroupBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 2);\n\tptr->num_session_groups = gf_bs_read_u16(bs);\n\tif (ptr->size < ptr->num_session_groups) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in segr\\n\", ptr->num_session_groups));\n\t\tptr->num_session_groups = 0;\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tGF_SAFE_ALLOC_N(ptr->session_groups, ptr->num_session_groups, SessionGroupEntry);\n\tif (!ptr->session_groups) return GF_OUT_OF_MEM;\n\n\tfor (i=0; i<ptr->num_session_groups; i++) {\n\t\tptr->session_groups[i].nb_groups = gf_bs_read_u8(bs);\n\t\tISOM_DECREASE_SIZE(ptr, 1);\n\n\t\tISOM_DECREASE_SIZE(ptr, ptr->session_groups[i].nb_groups*4);\n\n\t\tGF_SAFE_ALLOC_N(ptr->session_groups[i].group_ids, ptr->session_groups[i].nb_groups, u32);\n\t\tif (!ptr->session_groups[i].group_ids) return GF_OUT_OF_MEM;\n\n\t\tfor (k=0; k<ptr->session_groups[i].nb_groups; k++) {\n\t\t\tptr->session_groups[i].group_ids[k] = gf_bs_read_u32(bs);\n\t\t}\n\n\t\tptr->session_groups[i].nb_channels = gf_bs_read_u16(bs);\n\t\tISOM_DECREASE_SIZE(ptr, ptr->session_groups[i].nb_channels*4);\n\n\t\tGF_SAFE_ALLOC_N(ptr->session_groups[i].channels, ptr->session_groups[i].nb_channels, u32);\n\t\tif (!ptr->session_groups[i].channels) return GF_OUT_OF_MEM;\n\n\t\tfor (k=0; k<ptr->session_groups[i].nb_channels; k++) {\n\t\t\tptr->session_groups[i].channels[k] = gf_bs_read_u32(bs);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err segr_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i, k;\n\tGF_Err e;\n\tFDSessionGroupBox *ptr = (FDSessionGroupBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u16(bs, ptr->num_session_groups);\n\tfor (i=0; i<ptr->num_session_groups; i++) {\n\t\tgf_bs_write_u8(bs, ptr->session_groups[i].nb_groups);\n\t\tfor (k=0; k<ptr->session_groups[i].nb_groups; k++) {\n\t\t\tgf_bs_write_u32(bs, ptr->session_groups[i].group_ids[k]);\n\t\t}\n\n\t\tgf_bs_write_u16(bs, ptr->session_groups[i].nb_channels);\n\t\tfor (k=0; k<ptr->session_groups[i].nb_channels; k++) {\n\t\t\tgf_bs_write_u32(bs, ptr->session_groups[i].channels[k]);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err segr_box_size(GF_Box *s)\n{\n\tu32 i;\n\tFDSessionGroupBox *ptr = (FDSessionGroupBox *)s;\n\n\tptr->size += 2;\n\n\tfor (i=0; i<ptr->num_session_groups; i++) {\n\t\tptr->size += 1 + 4*ptr->session_groups[i].nb_groups;\n\t\tptr->size += 2 + 4*ptr->session_groups[i].nb_channels;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *gitn_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GroupIdToNameBox, GF_ISOM_BOX_TYPE_GITN);\n\treturn (GF_Box *)tmp;\n}\n\nvoid gitn_box_del(GF_Box *s)\n{\n\tu32 i;\n\tGroupIdToNameBox *ptr = (GroupIdToNameBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->entries) {\n\t\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\t\tif (ptr->entries[i].name) gf_free(ptr->entries[i].name);\n\t\t}\n\t\tgf_free(ptr->entries);\n\t}\n\tgf_free(ptr);\n}\n\nGF_Err gitn_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_Err e;\n\tGroupIdToNameBox *ptr = (GroupIdToNameBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 2);\n\tptr->nb_entries = gf_bs_read_u16(bs);\n\tif (ptr->size / 4 < ptr->nb_entries)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tGF_SAFE_ALLOC_N(ptr->entries, ptr->nb_entries, GroupIdNameEntry);\n\tif (!ptr->entries) return GF_OUT_OF_MEM;\n\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->entries[i].group_id = gf_bs_read_u32(bs);\n\n\t\te = gf_isom_read_null_terminated_string(s, bs, ptr->size, &ptr->entries[i].name);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err gitn_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGroupIdToNameBox *ptr = (GroupIdToNameBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u16(bs, ptr->nb_entries);\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tgf_bs_write_u32(bs, ptr->entries[i].group_id);\n\t\tif (ptr->entries[i].name) gf_bs_write_data(bs, ptr->entries[i].name, (u32)strlen(ptr->entries[i].name) );\n\t\tgf_bs_write_u8(bs, 0);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err gitn_box_size(GF_Box *s)\n{\n\tu32 i;\n\tGroupIdToNameBox *ptr = (GroupIdToNameBox *)s;\n\tptr->size += 2;\n\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tptr->size += 5;\n\t\tif (ptr->entries[i].name) ptr->size += strlen(ptr->entries[i].name);\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#ifndef GPAC_DISABLE_ISOM_HINTING\n\nGF_Box *fdpa_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_FDpacketBox, GF_ISOM_BOX_TYPE_FDPA);\n\treturn (GF_Box *)tmp;\n}\n\nvoid fdpa_box_del(GF_Box *s)\n{\n\tu32 i;\n\tGF_FDpacketBox *ptr = (GF_FDpacketBox *)s;\n\tif (ptr == NULL) return;\n\n\tif (ptr->headers) {\n\t\tfor (i=0; i<ptr->header_ext_count; i++) {\n\t\t\tif (ptr->headers[i].data) gf_free(ptr->headers[i].data);\n\t\t}\n\t\tgf_free(ptr->headers);\n\t}\n\tgf_free(ptr);\n}\n\nGF_Err fdpa_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_FDpacketBox *ptr = (GF_FDpacketBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 3);\n\tptr->info.sender_current_time_present = gf_bs_read_int(bs, 1);\n\tptr->info.expected_residual_time_present = gf_bs_read_int(bs, 1);\n\tptr->info.session_close_bit = gf_bs_read_int(bs, 1);\n\tptr->info.object_close_bit = gf_bs_read_int(bs, 1);\n\tgf_bs_read_int(bs, 4);\n\tptr->info.transport_object_identifier = gf_bs_read_u16(bs);\n\tISOM_DECREASE_SIZE(ptr, 2);\n\tptr->header_ext_count = gf_bs_read_u16(bs);\n\tif (ptr->size / 2 < ptr->header_ext_count) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in fdpa\\n\", ptr->header_ext_count));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tGF_SAFE_ALLOC_N(ptr->headers, ptr->header_ext_count, GF_LCTheaderExtension);\n\tif (!ptr->headers) return GF_OUT_OF_MEM;\n\n\tfor (i=0; i<ptr->header_ext_count; i++) {\n\t\tptr->headers[i].header_extension_type = gf_bs_read_u8(bs);\n\t\tISOM_DECREASE_SIZE(ptr, 1);\n\n\t\tif (ptr->headers[i].header_extension_type > 127) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 3);\n\t\t\tgf_bs_read_data(bs, (char *) ptr->headers[i].content, 3);\n\t\t} else {\n\t\t\tISOM_DECREASE_SIZE(ptr, 1);\n\t\t\tptr->headers[i].data_length = gf_bs_read_u8(bs);\n\t\t\tif (ptr->headers[i].data_length) {\n\t\t\t\tptr->headers[i].data_length = 4*ptr->headers[i].data_length - 2;\n\t\t\t\tif (ptr->size < sizeof(char) * ptr->headers[i].data_length)\n\t\t\t\t    return GF_ISOM_INVALID_FILE;\n\t\t\t\tptr->headers[i].data = gf_malloc(sizeof(char) * ptr->headers[i].data_length);\n\t\t\t\tif (!ptr->headers[i].data) return GF_OUT_OF_MEM;\n\n\t\t\t\tISOM_DECREASE_SIZE(ptr, ptr->headers[i].data_length);\n\t\t\t\tgf_bs_read_data(bs, ptr->headers[i].data, ptr->headers[i].data_length);\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err fdpa_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_FDpacketBox *ptr = (GF_FDpacketBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_int(bs, ptr->info.sender_current_time_present, 1);\n\tgf_bs_write_int(bs, ptr->info.expected_residual_time_present, 1);\n\tgf_bs_write_int(bs, ptr->info.session_close_bit, 1);\n\tgf_bs_write_int(bs, ptr->info.object_close_bit, 1);\n\tgf_bs_write_int(bs, 0, 4);\n\tgf_bs_write_u16(bs, ptr->info.transport_object_identifier);\n\tgf_bs_write_u16(bs, ptr->header_ext_count);\n\tfor (i=0; i<ptr->header_ext_count; i++) {\n\t\tgf_bs_write_u8(bs, ptr->headers[i].header_extension_type);\n\t\tif (ptr->headers[i].header_extension_type > 127) {\n\t\t\tgf_bs_write_data(bs, (const char *) ptr->headers[i].content, 3);\n\t\t} else {\n\t\t\tgf_bs_write_u8(bs, ptr->headers[i].data_length ? (ptr->headers[i].data_length+2)/4 : 0);\n\t\t\tif (ptr->headers[i].data_length) {\n\t\t\t\tgf_bs_write_data(bs, ptr->headers[i].data, ptr->headers[i].data_length);\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err fdpa_box_size(GF_Box *s)\n{\n\tu32 i;\n\tGF_FDpacketBox *ptr = (GF_FDpacketBox *)s;\n\n\tptr->size += 5;\n\n\tfor (i=0; i<ptr->header_ext_count; i++) {\n\t\tptr->size += 1;\n\t\tif (ptr->headers[i].header_extension_type > 127) {\n\t\t\tptr->size += 3;\n\t\t} else {\n\t\t\tptr->size += 1 + ptr->headers[i].data_length;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *extr_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ExtraDataBox, GF_ISOM_BOX_TYPE_EXTR);\n\treturn (GF_Box *)tmp;\n}\n\nvoid extr_box_del(GF_Box *s)\n{\n\tGF_ExtraDataBox *ptr = (GF_ExtraDataBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->feci) gf_isom_box_del((GF_Box*)ptr->feci);\n\tif (ptr->data) gf_free(ptr->data);\n\tgf_free(ptr);\n}\n\nGF_Err extr_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ExtraDataBox *ptr = (GF_ExtraDataBox *)s;\n\n\te = gf_isom_box_parse((GF_Box**) &ptr->feci, bs);\n\tif (e) return e;\n\tif (!ptr->feci || ptr->feci->size > ptr->size) return GF_ISOM_INVALID_MEDIA;\n\tptr->data_length = (u32) (ptr->size - ptr->feci->size);\n\tptr->data = gf_malloc(sizeof(char)*ptr->data_length);\n\tif (!ptr->data) return GF_OUT_OF_MEM;\n\tgf_bs_read_data(bs, ptr->data, ptr->data_length);\n\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err extr_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ExtraDataBox *ptr = (GF_ExtraDataBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tif (ptr->feci) {\n\t\te = gf_isom_box_write((GF_Box *)ptr->feci, bs);\n\t\tif (e) return e;\n\t}\n\tgf_bs_write_data(bs, ptr->data, ptr->data_length);\n\treturn GF_OK;\n}\n\nGF_Err extr_box_size(GF_Box *s)\n{\n\tGF_ExtraDataBox *ptr = (GF_ExtraDataBox *) s;\n\tptr->size += ptr->data_length;\n\tif (ptr->feci) {\n\t\tGF_Err e = gf_isom_box_size((GF_Box*)ptr->feci);\n\t\tif (e) return e;\n\t\tptr->size += ptr->feci->size;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Box *fdsa_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_HintSample, GF_ISOM_BOX_TYPE_FDSA);\n\tif (!tmp) return NULL;\n\ttmp->packetTable = gf_list_new();\n\ttmp->hint_subtype = GF_ISOM_BOX_TYPE_FDP_STSD;\n\treturn (GF_Box*)tmp;\n}\n\nvoid fdsa_box_del(GF_Box *s)\n{\n\tGF_HintSample *ptr = (GF_HintSample *)s;\n\tgf_list_del(ptr->packetTable);\n\tgf_free(ptr);\n}\n\nGF_Err fdsa_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_HintSample *ptr = (GF_HintSample *)s;\n\tswitch(a->type) {\n\tcase GF_ISOM_BOX_TYPE_FDPA:\n\t\tBOX_FIELD_LIST_ASSIGN(packetTable)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_EXTR:\n\t\tBOX_FIELD_ASSIGN(extra_data, GF_ExtraDataBox)\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\nGF_Err fdsa_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err fdsa_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_HintSample *ptr = (GF_HintSample *) s;\n\tif (!s) return GF_BAD_PARAM;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\te = gf_isom_box_array_write(s, ptr->packetTable, bs);\n\tif (e) return e;\n\tif (ptr->extra_data) {\n\t\te = gf_isom_box_write((GF_Box *)ptr->extra_data, bs);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err fdsa_box_size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM_HINTING*/\n\n\nvoid trik_box_del(GF_Box *s)\n{\n\tGF_TrickPlayBox *ptr = (GF_TrickPlayBox *) s;\n\tif (ptr == NULL) return;\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);\n}\n\nGF_Err trik_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_TrickPlayBox *ptr = (GF_TrickPlayBox *) s;\n\tptr->entry_count = (u32) ptr->size;\n\tif ((u64)ptr->entry_count > (u64)SIZE_MAX/sizeof(GF_TrickPlayBoxEntry)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid size %llu in trik\\n\", ptr->size));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tptr->entries = (GF_TrickPlayBoxEntry *) gf_malloc(ptr->entry_count * sizeof(GF_TrickPlayBoxEntry) );\n\tif (!ptr->entries) return GF_OUT_OF_MEM;\n\n\tfor (i=0; i< ptr->entry_count; i++) {\n\t\tptr->entries[i].pic_type = gf_bs_read_int(bs, 2);\n\t\tptr->entries[i].dependency_level = gf_bs_read_int(bs, 6);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *trik_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrickPlayBox, GF_ISOM_BOX_TYPE_TRIK);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err trik_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_TrickPlayBox *ptr = (GF_TrickPlayBox *) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tfor (i=0; i < ptr->entry_count; i++ ) {\n\t\tgf_bs_write_int(bs, ptr->entries[i].pic_type, 2);\n\t\tgf_bs_write_int(bs, ptr->entries[i].dependency_level, 6);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err trik_box_size(GF_Box *s)\n{\n\tGF_TrickPlayBox *ptr = (GF_TrickPlayBox *) s;\n\tptr->size += 8 * ptr->entry_count;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid bloc_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err bloc_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_BaseLocationBox *ptr = (GF_BaseLocationBox *) s;\n\n\tISOM_DECREASE_SIZE(s, 256)\n\tgf_bs_read_data(bs, (char *) ptr->baseLocation, 256);\n\tptr->baseLocation[256]=0;\n\tISOM_DECREASE_SIZE(s, 256)\n\tgf_bs_read_data(bs, (char *) ptr->basePurlLocation, 256);\n\tISOM_DECREASE_SIZE(s, 512)\n\tptr->basePurlLocation[256]=0;\n\tgf_bs_skip_bytes(bs, 512);\n\treturn GF_OK;\n}\n\nGF_Box *bloc_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_BaseLocationBox, GF_ISOM_BOX_TYPE_BLOC);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err bloc_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_BaseLocationBox *ptr = (GF_BaseLocationBox *) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_data(bs, (const char *) ptr->baseLocation, 256);\n\tgf_bs_write_data(bs, (const char *) ptr->basePurlLocation, 256);\n\tfor (i=0; i < 64; i++ ) {\n\t\tgf_bs_write_u64(bs, 0);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err bloc_box_size(GF_Box *s)\n{\n\ts->size += 1024;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid ainf_box_del(GF_Box *s)\n{\n\tGF_AssetInformationBox *ptr = (GF_AssetInformationBox *) s;\n\tif (ptr->APID) gf_free(ptr->APID);\n\tgf_free(s);\n}\n\nGF_Err ainf_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_AssetInformationBox *ptr = (GF_AssetInformationBox *) s;\n\n\tISOM_DECREASE_SIZE(s, 4)\n\tptr->profile_version = gf_bs_read_u32(bs);\n\treturn gf_isom_read_null_terminated_string(s, bs, s->size, &ptr->APID);\n}\n\nGF_Box *ainf_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_AssetInformationBox, GF_ISOM_BOX_TYPE_AINF);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err ainf_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_AssetInformationBox *ptr = (GF_AssetInformationBox *) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->profile_version);\n    if (ptr->APID)\n        gf_bs_write_data(bs, ptr->APID, (u32) strlen(ptr->APID) );\n    gf_bs_write_u8(bs, 0);\n\treturn GF_OK;\n}\n\nGF_Err ainf_box_size(GF_Box *s)\n{\n\tGF_AssetInformationBox *ptr = (GF_AssetInformationBox *) s;\n    s->size += 4 + (ptr->APID ? strlen(ptr->APID) : 0 ) + 1;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid mhac_box_del(GF_Box *s)\n{\n\tGF_MHAConfigBox *ptr = (GF_MHAConfigBox *) s;\n\tif (ptr->mha_config) gf_free(ptr->mha_config);\n\tgf_free(s);\n}\n\nGF_Err mhac_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_MHAConfigBox *ptr = (GF_MHAConfigBox *) s;\n\n\tISOM_DECREASE_SIZE(s, 5)\n\tptr->configuration_version = gf_bs_read_u8(bs);\n\tptr->mha_pl_indication = gf_bs_read_u8(bs);\n\tptr->reference_channel_layout = gf_bs_read_u8(bs);\n\tptr->mha_config_size = gf_bs_read_u16(bs);\n\tif (ptr->mha_config_size) {\n\t\tISOM_DECREASE_SIZE(s, ptr->mha_config_size)\n\n\t\tptr->mha_config = gf_malloc(sizeof(char)*ptr->mha_config_size);\n\t\tif (!ptr->mha_config) return GF_OUT_OF_MEM;\n\n\t\tgf_bs_read_data(bs, ptr->mha_config, ptr->mha_config_size);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *mhac_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MHAConfigBox, GF_ISOM_BOX_TYPE_MHAC);\n\ttmp->configuration_version = 1;\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err mhac_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MHAConfigBox *ptr = (GF_MHAConfigBox *) s;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u8(bs, ptr->configuration_version);\n\tgf_bs_write_u8(bs, ptr->mha_pl_indication);\n\tgf_bs_write_u8(bs, ptr->reference_channel_layout);\n\tgf_bs_write_u16(bs, ptr->mha_config ? ptr->mha_config_size : 0);\n\tif (ptr->mha_config && ptr->mha_config_size)\n\t\tgf_bs_write_data(bs, ptr->mha_config, ptr->mha_config_size);\n\n\treturn GF_OK;\n}\n\nGF_Err mhac_box_size(GF_Box *s)\n{\n\tGF_MHAConfigBox *ptr = (GF_MHAConfigBox *) s;\n\ts->size += 5;\n\tif (ptr->mha_config_size && ptr->mha_config) s->size += ptr->mha_config_size;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid mhap_box_del(GF_Box *s)\n{\n\tGF_MHACompatibleProfilesBox *ptr = (GF_MHACompatibleProfilesBox *) s;\n\tif (ptr->compat_profiles) gf_free(ptr->compat_profiles);\n\tgf_free(s);\n}\n\nGF_Err mhap_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_MHACompatibleProfilesBox *ptr = (GF_MHACompatibleProfilesBox *) s;\n\n\tISOM_DECREASE_SIZE(s, 1)\n\tptr->num_profiles = gf_bs_read_u8(bs);\n\tif (!ptr->num_profiles) return GF_OK;\n\n\tISOM_DECREASE_SIZE(s, ptr->num_profiles)\n\tptr->compat_profiles = gf_malloc(sizeof(u8) * ptr->num_profiles);\n\tif (!ptr->compat_profiles) return GF_OUT_OF_MEM;\n\tfor (i=0; i<ptr->num_profiles; i++) {\n\t\tptr->compat_profiles[i] = gf_bs_read_u8(bs);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *mhap_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MHACompatibleProfilesBox, GF_ISOM_BOX_TYPE_MHAP);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err mhap_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_Err e;\n\tGF_MHACompatibleProfilesBox *ptr = (GF_MHACompatibleProfilesBox *) s;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u8(bs, ptr->num_profiles);\n\tfor (i=0; i<ptr->num_profiles; i++) {\n\t\tgf_bs_write_u8(bs, ptr->compat_profiles[i]);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err mhap_box_size(GF_Box *s)\n{\n\tGF_MHACompatibleProfilesBox *ptr = (GF_MHACompatibleProfilesBox *) s;\n\ts->size += 1 + ptr->num_profiles;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid jp2h_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err jp2h_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_J2KHeaderBox *ptr = (GF_J2KHeaderBox *)s;\n\tswitch(a->type) {\n\tcase GF_ISOM_BOX_TYPE_IHDR:\n\t\tBOX_FIELD_ASSIGN(ihdr, GF_J2KImageHeaderBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_COLR:\n\t\tBOX_FIELD_ASSIGN(colr, GF_ColourInformationBox)\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\nGF_Err jp2h_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *jp2h_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_J2KHeaderBox, GF_ISOM_BOX_TYPE_JP2H);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err jp2h_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err jp2h_box_size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid ihdr_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err ihdr_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_J2KImageHeaderBox *ptr = (GF_J2KImageHeaderBox *) s;\n\n\tISOM_DECREASE_SIZE(s, 14)\n\n\tptr->height = gf_bs_read_u32(bs);\n\tptr->width = gf_bs_read_u32(bs);\n\tptr->nb_comp = gf_bs_read_u16(bs);\n\tptr->bpc = gf_bs_read_u8(bs);\n\tptr->Comp = gf_bs_read_u8(bs);\n\tptr->UnkC = gf_bs_read_u8(bs);\n\tptr->IPR = gf_bs_read_u8(bs);\n\n\treturn GF_OK;\n}\n\nGF_Box *ihdr_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_J2KImageHeaderBox, GF_ISOM_BOX_TYPE_IHDR);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err ihdr_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_J2KImageHeaderBox *ptr = (GF_J2KImageHeaderBox *) s;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->height);\n\tgf_bs_write_u32(bs, ptr->width);\n\tgf_bs_write_u16(bs, ptr->nb_comp);\n\tgf_bs_write_u8(bs, ptr->bpc);\n\tgf_bs_write_u8(bs, ptr->Comp);\n\tgf_bs_write_u8(bs, ptr->UnkC);\n\tgf_bs_write_u8(bs, ptr->IPR);\n\treturn GF_OK;\n}\n\nGF_Err ihdr_box_size(GF_Box *s)\n{\n\ts->size += 14;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/* Dolby Vision */\n\nGF_Box *dvcC_box_new()\n{\n\tGF_DOVIConfigurationBox *tmp = (GF_DOVIConfigurationBox *)gf_malloc(sizeof(GF_DOVIConfigurationBox));\n\tif (tmp == NULL) return NULL;\n\tmemset(tmp, 0, sizeof(GF_DOVIConfigurationBox));\n\ttmp->type = GF_ISOM_BOX_TYPE_DVCC;\n\treturn (GF_Box *)tmp;\n}\n\nvoid dvcC_box_del(GF_Box *s)\n{\n\tGF_DOVIConfigurationBox *ptr = (GF_DOVIConfigurationBox*)s;\n\tgf_free(ptr);\n}\n\nGF_Err dvcC_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_DOVIConfigurationBox *ptr = (GF_DOVIConfigurationBox *)s;\n\n\t//GF_DOVIDecoderConfigurationRecord\n\tISOM_DECREASE_SIZE(ptr, 24)\n\tptr->DOVIConfig.dv_version_major = gf_bs_read_u8(bs);\n\tptr->DOVIConfig.dv_version_minor = gf_bs_read_u8(bs);\n\tptr->DOVIConfig.dv_profile = gf_bs_read_int(bs, 7);\n\tptr->DOVIConfig.dv_level = gf_bs_read_int(bs, 6);\n\tptr->DOVIConfig.rpu_present_flag = gf_bs_read_int(bs, 1);\n\tptr->DOVIConfig.el_present_flag = gf_bs_read_int(bs, 1);\n\tptr->DOVIConfig.bl_present_flag = gf_bs_read_int(bs, 1);\n\tptr->DOVIConfig.dv_bl_signal_compatibility_id = gf_bs_read_int(bs, 4);\n\tif (gf_bs_read_int(bs, 28) != 0)\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] dvcC reserved bits are not zero\\n\"));\n\n\tfor (i = 0; i < 4; i++) {\n\t\tif (gf_bs_read_u32(bs) != 0) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] dvcC reserved bits are not zero\\n\"));\n\t\t}\n\t}\n\tswitch (ptr->DOVIConfig.dv_bl_signal_compatibility_id) {\n\tcase 0:\n\tcase 1:\n\tcase 2:\n\tcase 4:\n\tcase 6:\n\t\tbreak;\n\tdefault:\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] dvcC compatibility ID %d is not valid (only 0, 1, 2, 4 or 6 defined), patching to 0\\n\", ptr->DOVIConfig.dv_bl_signal_compatibility_id));\n\t\tptr->DOVIConfig.dv_bl_signal_compatibility_id = 0;\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err dvcC_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_DOVIConfigurationBox *ptr = (GF_DOVIConfigurationBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\t//GF_DOVIDecoderConfigurationRecord\n\tgf_bs_write_u8(bs,  ptr->DOVIConfig.dv_version_major);\n\tgf_bs_write_u8(bs,  ptr->DOVIConfig.dv_version_minor);\n\tgf_bs_write_int(bs, ptr->DOVIConfig.dv_profile, 7);\n\tgf_bs_write_int(bs, ptr->DOVIConfig.dv_level, 6);\n\tgf_bs_write_int(bs, ptr->DOVIConfig.rpu_present_flag, 1);\n\tgf_bs_write_int(bs, ptr->DOVIConfig.el_present_flag, 1);\n\tgf_bs_write_int(bs, ptr->DOVIConfig.bl_present_flag, 1);\n\tgf_bs_write_int(bs, ptr->DOVIConfig.dv_bl_signal_compatibility_id, 4);\n\tgf_bs_write_int(bs, 0, 28);\n\tgf_bs_write_u32(bs, 0);\n\tgf_bs_write_u32(bs, 0);\n\tgf_bs_write_u32(bs, 0);\n\tgf_bs_write_u32(bs, 0);\n\n\treturn GF_OK;\n}\n\nGF_Err dvcC_box_size(GF_Box *s)\n{\n\tGF_DOVIConfigurationBox *ptr = (GF_DOVIConfigurationBox *)s;\n\n\tptr->size += 24;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *dvvC_box_new()\n{\n\tGF_DOVIConfigurationBox *tmp = (GF_DOVIConfigurationBox *)gf_malloc(sizeof(GF_DOVIConfigurationBox));\n\tif (tmp == NULL) return NULL;\n\tmemset(tmp, 0, sizeof(GF_DOVIConfigurationBox));\n\ttmp->type = GF_ISOM_BOX_TYPE_DVVC;\n\treturn (GF_Box *)tmp;\n}\n\nvoid dvvC_box_del(GF_Box *s)\n{\n\tGF_DOVIConfigurationBox *ptr = (GF_DOVIConfigurationBox*)s;\n\tgf_free(ptr);\n}\n\nGF_Err dvvC_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn dvcC_box_read(s, bs);\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err dvvC_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn dvcC_box_write(s, bs);\n}\n\nGF_Err dvvC_box_size(GF_Box *s)\n{\n\treturn dvcC_box_size(s);\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *dOps_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_OpusSpecificBox, GF_ISOM_BOX_TYPE_DOPS);\n\treturn (GF_Box *)tmp;\n}\n\nvoid dOps_box_del(GF_Box *s)\n{\n\tGF_OpusSpecificBox *ptr = (GF_OpusSpecificBox *)s;\n\tif (ptr) gf_free(ptr);\n}\n\n//we don't use odf_opus_cfg read due to endianness\nGF_Err dOps_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_OpusSpecificBox *ptr = (GF_OpusSpecificBox *)s;\n\tptr->opcfg.version = gf_bs_read_u8(bs);\n\tif (ptr->opcfg.version) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[IsoMedia] Opus config version not 0 !\\n\", ptr->size));\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\t//force version to 1 as used in ogg/opus\n\tptr->opcfg.version = 1;\n\tptr->opcfg.OutputChannelCount = gf_bs_read_u8(bs);\n\tptr->opcfg.PreSkip = gf_bs_read_u16(bs);\n\tptr->opcfg.InputSampleRate = gf_bs_read_u32(bs);\n\tptr->opcfg.OutputGain = gf_bs_read_u16(bs);\n\tptr->opcfg.ChannelMappingFamily = gf_bs_read_u8(bs);\n\tISOM_DECREASE_SIZE(ptr, 11)\n\tif (ptr->size) {\n\t\tISOM_DECREASE_SIZE(ptr, 2+ptr->opcfg.OutputChannelCount);\n\t\tptr->opcfg.StreamCount = gf_bs_read_u8(bs);\n\t\tptr->opcfg.CoupledCount = gf_bs_read_u8(bs);\n\t\tgf_bs_read_data(bs, (char *) ptr->opcfg.ChannelMapping, ptr->opcfg.OutputChannelCount);\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n//we don't use odf_opus_cfg write due to endianness\nGF_Err dOps_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_OpusSpecificBox *ptr = (GF_OpusSpecificBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\t//we always write 0 - the version may also be set to 1 when fed from ffenc or opus+ogg\n\tgf_bs_write_u8(bs, /*ptr->opcfg.version*/ 0);\n\tgf_bs_write_u8(bs, ptr->opcfg.OutputChannelCount);\n\tgf_bs_write_u16(bs, ptr->opcfg.PreSkip);\n\tgf_bs_write_u32(bs, ptr->opcfg.InputSampleRate);\n\tgf_bs_write_u16(bs, ptr->opcfg.OutputGain);\n\tgf_bs_write_u8(bs, ptr->opcfg.ChannelMappingFamily);\n\tif (ptr->opcfg.ChannelMappingFamily) {\n\t\tgf_bs_write_u8(bs, ptr->opcfg.StreamCount);\n\t\tgf_bs_write_u8(bs, ptr->opcfg.CoupledCount);\n\t\tgf_bs_write_data(bs, (char *) ptr->opcfg.ChannelMapping, ptr->opcfg.OutputChannelCount);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err dOps_box_size(GF_Box *s)\n{\n\tGF_OpusSpecificBox *ptr = (GF_OpusSpecificBox *)s;\n\tptr->size += 11;\n\tif (ptr->opcfg.ChannelMappingFamily)\n\t\tptr->size += 2 + ptr->opcfg.OutputChannelCount;\n\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid dfla_box_del(GF_Box *s)\n{\n\tGF_FLACConfigBox *ptr = (GF_FLACConfigBox *) s;\n\tif (ptr->data) gf_free(ptr->data);\n\tgf_free(ptr);\n}\n\nGF_Err dfla_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_FLACConfigBox *ptr = (GF_FLACConfigBox *) s;\n\tptr->dataSize = (u32) ptr->size;\n\tptr->size=0;\n\tptr->data = gf_malloc(ptr->dataSize);\n\tgf_bs_read_data(bs, ptr->data, ptr->dataSize);\n\treturn GF_OK;\n}\n\nGF_Box *dfla_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_FLACConfigBox, GF_ISOM_BOX_TYPE_DFLA);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err dfla_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_FLACConfigBox *ptr = (GF_FLACConfigBox *) s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_data(bs, ptr->data, ptr->dataSize);\n\treturn GF_OK;\n}\n\nGF_Err dfla_box_size(GF_Box *s)\n{\n\tGF_FLACConfigBox *ptr = (GF_FLACConfigBox *) s;\n\tptr->size += ptr->dataSize;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid mvcg_box_del(GF_Box *s)\n{\n\tGF_MultiviewGroupBox *ptr = (GF_MultiviewGroupBox *) s;\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);\n}\n\nGF_Err mvcg_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_MultiviewGroupBox *ptr = (GF_MultiviewGroupBox *) s;\n\tISOM_DECREASE_SIZE(s, 7)\n\tptr->multiview_group_id = gf_bs_read_u32(bs);\n\tptr->num_entries = gf_bs_read_u16(bs);\n\tgf_bs_read_u8(bs);\n\tptr->entries = gf_malloc(ptr->num_entries * sizeof(MVCIEntry));\n\tmemset(ptr->entries, 0, ptr->num_entries * sizeof(MVCIEntry));\n\tfor (i=0; i<ptr->num_entries; i++) {\n\t\tISOM_DECREASE_SIZE(s, 1)\n\t\tptr->entries[i].entry_type = gf_bs_read_u8(bs);\n\t\tswitch (ptr->entries[i].entry_type) {\n\t\tcase 0:\n\t\t\tISOM_DECREASE_SIZE(s, 4)\n\t\t\tptr->entries[i].trackID = gf_bs_read_u32(bs);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tISOM_DECREASE_SIZE(s, 6)\n\t\t\tptr->entries[i].trackID = gf_bs_read_u32(bs);\n\t\t\tptr->entries[i].tierID = gf_bs_read_u16(bs);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tISOM_DECREASE_SIZE(s, 2)\n\t\t\tgf_bs_read_int(bs, 6);\n\t\t\tptr->entries[i].output_view_id = gf_bs_read_int(bs, 10);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tISOM_DECREASE_SIZE(s, 4)\n\t\t\tgf_bs_read_int(bs, 6)\t;\n\t\t\tptr->entries[i].start_view_id = gf_bs_read_int(bs, 10);\n\t\t\tptr->entries[i].view_count = gf_bs_read_u16(bs);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *mvcg_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MultiviewGroupBox, GF_ISOM_BOX_TYPE_MVCG);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err mvcg_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_MultiviewGroupBox *ptr = (GF_MultiviewGroupBox *) s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\n\tgf_bs_write_u32(bs, ptr->multiview_group_id);\n\tgf_bs_write_u16(bs, ptr->num_entries);\n\tgf_bs_write_u8(bs, 0);\n\n\tfor (i=0; i<ptr->num_entries; i++) {\n\t\tgf_bs_write_u8(bs, ptr->entries[i].entry_type);\n\t\tswitch (ptr->entries[i].entry_type) {\n\t\tcase 0:\n\t\t\tgf_bs_write_u32(bs, ptr->entries[i].trackID);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tgf_bs_write_u32(bs, ptr->entries[i].trackID);\n\t\t\tgf_bs_write_u16(bs, ptr->entries[i].tierID);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tgf_bs_write_int(bs, 0, 6);\n\t\t\tgf_bs_write_int(bs, ptr->entries[i].output_view_id, 10);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tgf_bs_write_int(bs, 0, 6)\t;\n\t\t\tgf_bs_write_int(bs, ptr->entries[i].start_view_id, 10);\n\t\t\tgf_bs_write_u16(bs, ptr->entries[i].view_count);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err mvcg_box_size(GF_Box *s)\n{\n\tu32 i;\n\tGF_MultiviewGroupBox *ptr = (GF_MultiviewGroupBox *) s;\n\n\tptr->size += 7;\n\tfor (i=0; i<ptr->num_entries; i++) {\n\t\tswitch (ptr->entries[i].entry_type) {\n\t\tcase 0:\n\t\t\tptr->size += 1 + 4;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tptr->size += 1 + 6;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tptr->size += 1 + 2;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tptr->size += 1 + 4;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid vwid_box_del(GF_Box *s)\n{\n\tu32 i;\n\tGF_ViewIdentifierBox *ptr = (GF_ViewIdentifierBox *) s;\n\tif (ptr->views) {\n\t\tfor (i=0; i<ptr->num_views; i++) {\n\t\t\tif (ptr->views[i].view_refs)\n\t\t\t\tgf_free(ptr->views[i].view_refs);\n\t\t}\n\t\tgf_free(ptr->views);\n\t}\n\tgf_free(ptr);\n}\n\nGF_Err vwid_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_ViewIdentifierBox *ptr = (GF_ViewIdentifierBox *) s;\n\tISOM_DECREASE_SIZE(s, 3)\n\tgf_bs_read_int(bs, 2);\n\tptr->min_temporal_id = gf_bs_read_int(bs, 3);\n\tptr->max_temporal_id = gf_bs_read_int(bs, 3);\n\tptr->num_views = gf_bs_read_u16(bs);\n\tif (ptr->num_views > ptr->size / 6)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tptr->views = gf_malloc(sizeof(ViewIDEntry)*ptr->num_views);\n\tmemset(ptr->views, 0, sizeof(ViewIDEntry)*ptr->num_views);\n\tfor (i=0; i<ptr->num_views; i++) {\n\t\tu32 j;\n\t\tISOM_DECREASE_SIZE(s, 6)\n\n\t\tgf_bs_read_int(bs, 6);\n\t\tptr->views[i].view_id = gf_bs_read_int(bs, 10);\n\t\tgf_bs_read_int(bs, 6);\n\t\tptr->views[i].view_order_index = gf_bs_read_int(bs, 10);\n\t\tptr->views[i].texture_in_stream = gf_bs_read_int(bs, 1);\n\t\tptr->views[i].texture_in_track = gf_bs_read_int(bs, 1);\n\t\tptr->views[i].depth_in_stream = gf_bs_read_int(bs, 1);\n\t\tptr->views[i].depth_in_track = gf_bs_read_int(bs, 1);\n\t\tptr->views[i].base_view_type = gf_bs_read_int(bs, 2);\n\t\tptr->views[i].num_ref_views = gf_bs_read_int(bs, 10);\n\n\t\tif (ptr->views[i].num_ref_views > ptr->size / 2)\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\n\t\tptr->views[i].view_refs = gf_malloc(sizeof(ViewIDRefViewEntry)*ptr->views[i].num_ref_views);\n\t\tfor (j=0; j<ptr->views[i].num_ref_views; j++) {\n\t\t\tISOM_DECREASE_SIZE(s, 2)\n\t\t\tgf_bs_read_int(bs, 4);\n\t\t\tptr->views[i].view_refs[j].dep_comp_idc = gf_bs_read_int(bs, 2);\n\t\t\tptr->views[i].view_refs[j].ref_view_id = gf_bs_read_int(bs, 10);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *vwid_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ViewIdentifierBox, GF_ISOM_BOX_TYPE_VWID);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err vwid_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i, j;\n\tGF_ViewIdentifierBox *ptr = (GF_ViewIdentifierBox *) s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_int(bs, 0, 2);\n\tgf_bs_write_int(bs, ptr->min_temporal_id, 3);\n\tgf_bs_write_int(bs, ptr->max_temporal_id, 3);\n\tgf_bs_write_u16(bs, ptr->num_views);\n\n\tfor (i=0; i<ptr->num_views; i++) {\n\t\tgf_bs_write_int(bs, 0, 6);\n\t\tgf_bs_write_int(bs, ptr->views[i].view_id, 10);\n\t\tgf_bs_write_int(bs, 0, 6);\n\t\tgf_bs_write_int(bs, ptr->views[i].view_order_index, 10);\n\n\t\tgf_bs_write_int(bs, ptr->views[i].texture_in_stream, 1);\n\t\tgf_bs_write_int(bs, ptr->views[i].texture_in_track, 1);\n\t\tgf_bs_write_int(bs, ptr->views[i].depth_in_stream, 1);\n\t\tgf_bs_write_int(bs, ptr->views[i].depth_in_track, 1);\n\t\tgf_bs_write_int(bs, ptr->views[i].base_view_type, 2);\n\t\tgf_bs_write_int(bs, ptr->views[i].num_ref_views, 10);\n\n\t\tfor (j=0; j<ptr->views[i].num_ref_views; j++) {\n\t\t\tgf_bs_write_int(bs, 0, 4);\n\t\t\tgf_bs_write_int(bs, ptr->views[i].view_refs[j].dep_comp_idc, 2);\n\t\t\tgf_bs_write_int(bs, ptr->views[i].view_refs[j].ref_view_id, 10);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err vwid_box_size(GF_Box *s)\n{\n\tu32 i;\n\tGF_ViewIdentifierBox *ptr = (GF_ViewIdentifierBox *) s;\n\tptr->size += 3;\n\tfor (i=0; i<ptr->num_views; i++) {\n\t\tptr->size += 6 + 2 * ptr->views[i].num_ref_views;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid pcmC_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err pcmC_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_PCMConfigBox *ptr = (GF_PCMConfigBox *) s;\n\n\tISOM_DECREASE_SIZE(s, 2)\n\tptr->format_flags = gf_bs_read_u8(bs);\n\tptr->PCM_sample_size = gf_bs_read_u8(bs);\n\treturn GF_OK;\n}\n\nGF_Box *pcmC_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_PCMConfigBox, GF_ISOM_BOX_TYPE_PCMC);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err pcmC_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_PCMConfigBox *ptr = (GF_PCMConfigBox *) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u8(bs, ptr->format_flags);\n\tgf_bs_write_u8(bs, ptr->PCM_sample_size);\n\treturn GF_OK;\n}\n\nGF_Err pcmC_box_size(GF_Box *s)\n{\n\ts->size += 2;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid chnl_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err chnl_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_ChannelLayoutBox *ptr = (GF_ChannelLayoutBox *) s;\n\n\tISOM_DECREASE_SIZE(s, 1)\n\tptr->layout.stream_structure = gf_bs_read_u8(bs);\n\tif (ptr->layout.stream_structure & 1) {\n\t\tISOM_DECREASE_SIZE(s, 1)\n\t\tptr->layout.definedLayout = gf_bs_read_u8(bs);\n\t\tif (ptr->layout.definedLayout==0) {\n\t\t\tu32 remain = (u32) ptr->size;\n\t\t\tif (ptr->layout.stream_structure & 2) remain--;\n\t\t\tptr->layout.channels_count = 0;\n\t\t\twhile (remain) {\n\t\t\t\tISOM_DECREASE_SIZE(s, 1)\n\t\t\t\tptr->layout.layouts[ptr->layout.channels_count].position = gf_bs_read_u8(bs);\n\t\t\t\tremain--;\n\t\t\t\tif (ptr->layout.layouts[ptr->layout.channels_count].position == 126) {\n\t\t\t\t\tISOM_DECREASE_SIZE(s, 3)\n\t\t\t\t\tptr->layout.layouts[ptr->layout.channels_count].azimuth = gf_bs_read_int(bs, 16);\n\t\t\t\t\tptr->layout.layouts[ptr->layout.channels_count].elevation = gf_bs_read_int(bs, 8);\n\t\t\t\t\tremain-=3;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tISOM_DECREASE_SIZE(s, 8)\n\t\t\tptr->layout.omittedChannelsMap = gf_bs_read_u64(bs);\n\t\t}\n\t}\n\tif (ptr->layout.stream_structure & 2) {\n\t\tISOM_DECREASE_SIZE(s, 1)\n\t\tptr->layout.object_count = gf_bs_read_u8(bs);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *chnl_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ChannelLayoutBox, GF_ISOM_BOX_TYPE_CHNL);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err chnl_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ChannelLayoutBox *ptr = (GF_ChannelLayoutBox *) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u8(bs, ptr->layout.stream_structure);\n\tif (ptr->layout.stream_structure & 1) {\n\t\tgf_bs_write_u8(bs, ptr->layout.definedLayout);\n\t\tif (ptr->layout.definedLayout==0) {\n\t\t\tu32 i;\n\t\t\tfor (i=0; i<ptr->layout.channels_count; i++) {\n\t\t\t\tgf_bs_write_u8(bs, ptr->layout.layouts[i].position);\n\t\t\t\tif (ptr->layout.layouts[i].position==126) {\n\t\t\t\t\tgf_bs_write_int(bs, ptr->layout.layouts[i].azimuth, 16);\n\t\t\t\t\tgf_bs_write_int(bs, ptr->layout.layouts[i].elevation, 8);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tgf_bs_write_u64(bs, ptr->layout.omittedChannelsMap);\n\t\t}\n\t}\n\tif (ptr->layout.stream_structure & 2) {\n\t\tgf_bs_write_u8(bs, ptr->layout.object_count);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err chnl_box_size(GF_Box *s)\n{\n\tGF_ChannelLayoutBox *ptr = (GF_ChannelLayoutBox *) s;\n\ts->size += 1;\n\tif (ptr->layout.stream_structure & 1) {\n\t\ts->size += 1;\n\t\tif (ptr->layout.definedLayout==0) {\n\t\t\tu32 i;\n\t\t\tfor (i=0; i<ptr->layout.channels_count; i++) {\n\t\t\t\ts->size+=1;\n\t\t\t\tif (ptr->layout.layouts[i].position==126)\n\t\t\t\t\ts->size+=3;\n\t\t\t}\n\t\t} else {\n\t\t\ts->size += 8;\n\t\t}\n\t}\n\tif (ptr->layout.stream_structure & 2) {\n\t\ts->size += 1;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *emsg_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_EventMessageBox, GF_ISOM_BOX_TYPE_EMSG);\n\treturn (GF_Box *)tmp;\n}\n\nvoid emsg_box_del(GF_Box *s)\n{\n\tGF_EventMessageBox *ptr = (GF_EventMessageBox *) s;\n\tif (ptr == NULL) return;\n\tif (ptr->scheme_id_uri) gf_free(ptr->scheme_id_uri);\n\tif (ptr->value) gf_free(ptr->value);\n\tif (ptr->message_data) gf_free(ptr->message_data);\n\tgf_free(ptr);\n}\n\nGF_Err emsg_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_EventMessageBox *ptr = (GF_EventMessageBox*) s;\n\n\tif (ptr->version==0) {\n\t\te = gf_isom_read_null_terminated_string(s, bs, ptr->size, &ptr->scheme_id_uri);\n\t\tif (e) return e;\n\t\te = gf_isom_read_null_terminated_string(s, bs, ptr->size, &ptr->value);\n\t\tif (e) return e;\n\n\t\tISOM_DECREASE_SIZE(ptr, 16);\n\t\tptr->timescale = gf_bs_read_u32(bs);\n\t\tptr->presentation_time_delta = gf_bs_read_u32(bs);\n\t\tptr->event_duration = gf_bs_read_u32(bs);\n\t\tptr->event_id = gf_bs_read_u32(bs);\n\t} else if (ptr->version==1) {\n\t\tISOM_DECREASE_SIZE(ptr, 20);\n\t\tptr->timescale = gf_bs_read_u32(bs);\n\t\tptr->presentation_time_delta = gf_bs_read_u64(bs);\n\t\tptr->event_duration = gf_bs_read_u32(bs);\n\t\tptr->event_id = gf_bs_read_u32(bs);\n\n\t\te = gf_isom_read_null_terminated_string(s, bs, ptr->size, &ptr->scheme_id_uri);\n\t\tif (e) return e;\n\t\te = gf_isom_read_null_terminated_string(s, bs, ptr->size, &ptr->value);\n\t\tif (e) return e;\n\t} else {\n\t\treturn GF_OK;\n\t}\n\tif (ptr->size) {\n\t\tif (ptr->size>0xFFFFFFFUL) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[IsoMedia] emsg message data size too big (\"LLU\") to be loaded\\n\", ptr->size));\n\t\t\treturn GF_OUT_OF_MEM;\n\t\t}\n\t\tptr->message_data_size = (u32) ptr->size;\n\t\tptr->message_data = gf_malloc(ptr->message_data_size);\n\t\tif (!ptr->message_data) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->message_data, ptr->message_data_size);\n\t\tptr->size = 0;\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err emsg_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 len;\n\tGF_EventMessageBox *ptr = (GF_EventMessageBox*) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tif (ptr->version==1) {\n\t\tgf_bs_write_u32(bs, ptr->timescale);\n\t\tgf_bs_write_u64(bs, ptr->presentation_time_delta);\n\t\tgf_bs_write_u32(bs, ptr->event_duration);\n\t\tgf_bs_write_u32(bs, ptr->event_id);\n\t}\n\n\tlen = ptr->scheme_id_uri ? (u32) strlen(ptr->scheme_id_uri) : 0;\n\tif (len) gf_bs_write_data(bs, ptr->scheme_id_uri, len);\n\tgf_bs_write_u8(bs, 0);\n\n\tlen = ptr->value ? (u32) strlen(ptr->value) : 0;\n\tif (len) gf_bs_write_data(bs, ptr->value, len);\n\tgf_bs_write_u8(bs, 0);\n\n\tif (ptr->version==0) {\n\t\tgf_bs_write_u32(bs, ptr->timescale);\n\t\tgf_bs_write_u32(bs, (u32) ptr->presentation_time_delta);\n\t\tgf_bs_write_u32(bs, ptr->event_duration);\n\t\tgf_bs_write_u32(bs, ptr->event_id);\n\t}\n\tif (ptr->message_data)\n\t\tgf_bs_write_data(bs, ptr->message_data, ptr->message_data_size);\n\treturn GF_OK;\n}\n\nGF_Err emsg_box_size(GF_Box *s)\n{\n\tGF_EventMessageBox *ptr = (GF_EventMessageBox*) s;\n\n\tif (ptr->version) {\n\t\tptr->size += 20;\n\t} else {\n\t\tptr->size += 16;\n\t}\n\tptr->size+=2; //1 NULL-terminated strings\n\tif (ptr->scheme_id_uri) ptr->size += strlen(ptr->scheme_id_uri);\n\tif (ptr->value) ptr->size += strlen(ptr->value);\n\tif (ptr->message_data)\n\t\tptr->size += ptr->message_data_size;\n\n\treturn GF_OK;\n}\n#endif // GPAC_DISABLE_ISOM_WRITE\n\n\n\n\nGF_Box *csgp_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_CompactSampleGroupBox, GF_ISOM_BOX_TYPE_CSGP);\n\treturn (GF_Box *)tmp;\n}\nvoid csgp_box_del(GF_Box *a)\n{\n\tGF_CompactSampleGroupBox *p = (GF_CompactSampleGroupBox *)a;\n\tif (p->patterns) {\n\t\tu32 i;\n\t\tfor (i=0; i<p->pattern_count; i++) {\n\t\t\tif (p->patterns[i].sample_group_description_indices)\n\t\t\t\tgf_free(p->patterns[i].sample_group_description_indices);\n\t\t}\n\t\tgf_free(p->patterns);\n\t}\n\tgf_free(p);\n}\n\nu32 get_size_by_code(u32 code)\n{\n\tif (code==0) return 4;\n\tif (code==1) return 8;\n\tif (code==2) return 16;\n\treturn 32;\n}\nGF_Err csgp_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i, bits, gidx_mask;\n\tBool index_msb_indicates_fragment_local_description, grouping_type_parameter_present;\n\tu32 pattern_size, scount_size, index_size;\n\tGF_CompactSampleGroupBox *ptr = (GF_CompactSampleGroupBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 8);\n\tptr->version = gf_bs_read_u8(bs);\n\tptr->flags = gf_bs_read_u24(bs);\n\n\tindex_msb_indicates_fragment_local_description = (ptr->flags & (1<<7)) ? GF_TRUE : GF_FALSE;\n\tgrouping_type_parameter_present = (ptr->flags & (1<<6)) ? GF_TRUE : GF_FALSE;\n\n\tpattern_size = get_size_by_code( ((ptr->flags>>4) & 0x3) );\n\tscount_size = get_size_by_code( ((ptr->flags>>2) & 0x3) );\n\tindex_size = get_size_by_code( (ptr->flags & 0x3) );\n\n\tif (((pattern_size==4) && (scount_size!=4)) || ((pattern_size!=4) && (scount_size==4))) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] compact sample group pattern_size and sample_count_size mare not both 4 bits\\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tptr->grouping_type = gf_bs_read_u32(bs);\n\tif (grouping_type_parameter_present) {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->grouping_type_parameter = gf_bs_read_u32(bs);\n\t}\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->pattern_count = gf_bs_read_u32(bs);\n\n\n\tif ( (ptr->size / ( (pattern_size + scount_size) / 8 ) < ptr->pattern_count) || (u64)ptr->pattern_count > (u64)SIZE_MAX/sizeof(GF_CompactSampleGroupPattern) ) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] compact sample group pattern_count value (%lu) invalid\\n\", ptr->pattern_count));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tptr->patterns = gf_malloc(sizeof(GF_CompactSampleGroupPattern) * ptr->pattern_count);\n\tif (!ptr->patterns) return GF_OUT_OF_MEM;\n\tmemset(ptr->patterns, 0, sizeof(GF_CompactSampleGroupPattern) * ptr->pattern_count);\n\n\tu64 patterns_sizes=0;\n\tbits = 0;\n\tfor (i=0; i<ptr->pattern_count; i++) {\n\t\tptr->patterns[i].length = gf_bs_read_int(bs, pattern_size);\n\t\tptr->patterns[i].sample_count = gf_bs_read_int(bs, scount_size);\n\t\tbits += pattern_size + scount_size;\n\t\tif (! (bits % 8)) {\n\t\t\tbits/=8;\n\t\t\tISOM_DECREASE_SIZE(ptr, bits);\n\t\t\tbits=0;\n\t\t}\n\t\tpatterns_sizes+=ptr->patterns[i].length;\n\t\tif (patterns_sizes * index_size > ptr->size*8) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] compact sample group pattern cumulated sizes \"LLU\" larger than box size \"LLU\"\\n\", patterns_sizes, ptr->size));\n\t\t\tptr->patterns[i].sample_group_description_indices = NULL;\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\n\t\tif ( (u64)ptr->patterns[i].length > (u64)SIZE_MAX/sizeof(u32) ) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] compact sample group pattern #%d value (%lu) invalid\\n\", i, ptr->patterns[i].length));\n\t\t\tptr->patterns[i].sample_group_description_indices = NULL;\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t\tptr->patterns[i].sample_group_description_indices = gf_malloc(sizeof(u32) * ptr->patterns[i].length);\n\t\tif (!ptr->patterns[i].sample_group_description_indices) return GF_OUT_OF_MEM;\n\t}\n\tbits = 0;\n\tgidx_mask = ((u32)1) << (index_size-1);\n\tfor (i=0; i<ptr->pattern_count; i++) {\n\t\tu32 j;\n\t\tfor (j=0; j<ptr->patterns[i].length; j++) {\n\t\t\tu32 idx = gf_bs_read_int(bs, index_size);\n\t\t\tif (index_msb_indicates_fragment_local_description) {\n\t\t\t\t//MSB set, this is a index of a group described in the fragment\n\t\t\t\tif (idx & gidx_mask) {\n\t\t\t\t\tidx += 0x10000;\n\t\t\t\t\tidx &= ~gidx_mask;\n\t\t\t\t}\n\t\t\t}\n\t\t\tptr->patterns[i].sample_group_description_indices[j] = idx;\n\t\t\tbits += index_size;\n\n\t\t\tif (! (bits % 8)) {\n\t\t\t\tbits/=8;\n\t\t\t\tISOM_DECREASE_SIZE(ptr, bits);\n\t\t\t\tbits=0;\n\t\t\t}\n\t\t}\n\t}\n\tif (bits)\n\t\tgf_bs_align(bs);\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err csgp_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_Err e;\n\tGF_CompactSampleGroupBox *ptr = (GF_CompactSampleGroupBox*)s;\n\tu32 pattern_size = get_size_by_code( ((ptr->flags>>4) & 0x3) );\n\tu32 scount_size = get_size_by_code( ((ptr->flags>>2) & 0x3) );\n\tu32 index_size = get_size_by_code( (ptr->flags & 0x3) );\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u8(bs, ptr->version);\n\tgf_bs_write_int(bs, ptr->flags, 24);\n\tgf_bs_write_u32(bs, ptr->grouping_type);\n\n\tif (ptr->flags & (1<<6))\n\t\tgf_bs_write_u32(bs, ptr->grouping_type_parameter);\n\n\tgf_bs_write_u32(bs, ptr->pattern_count);\n\n\tfor (i = 0; i<ptr->pattern_count; i++ ) {\n\t\tgf_bs_write_int(bs, ptr->patterns[i].length, pattern_size);\n\t\tgf_bs_write_int(bs, ptr->patterns[i].sample_count, scount_size);\n\t}\n\n\tfor (i = 0; i<ptr->pattern_count; i++ ) {\n\t\tu32 j;\n\t\tfor (j=0; j<ptr->patterns[i].length; j++) {\n\t\t\tu32 idx = ptr->patterns[i].sample_group_description_indices[j];\n\t\t\tif (idx > 0x10000) {\n\t\t\t\tidx -= 0x10000;\n\t\t\t\tgf_bs_write_int(bs, 1, 1);\n\t\t\t\tgf_bs_write_int(bs, idx, index_size-1);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_int(bs, idx, index_size);\n\t\t\t}\n\t\t}\n\t}\n\tgf_bs_align(bs);\n\treturn GF_OK;\n}\n\nGF_Err csgp_box_size(GF_Box *s)\n{\n\tu32 i, bits;\n\tGF_CompactSampleGroupBox *ptr = (GF_CompactSampleGroupBox*)s;\n\tu32 pattern_size = get_size_by_code( ((ptr->flags>>4) & 0x3) );\n\tu32 scount_size = get_size_by_code( ((ptr->flags>>2) & 0x3) );\n\tu32 index_size = get_size_by_code( (ptr->flags & 0x3) );\n\n\tptr->size += 12; //v, flags , grouping_type, pattern_length\n\tif (ptr->flags & (1<<6))\n\t\tptr->size+=4;\n\n\tptr->size += ptr->pattern_count * (pattern_size + scount_size) / 8;\n\tbits=0;\n\tfor (i=0; i<ptr->pattern_count; i++)\n\t\tbits += ptr->patterns[i].length * index_size;\n\tptr->size += bits/8;\n\tif (bits % 8) ptr->size++;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *dmlp_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrueHDConfigBox, GF_ISOM_BOX_TYPE_DMLP);\n\treturn (GF_Box *)tmp;\n}\n\nvoid dmlp_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\n\nGF_Err dmlp_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TrueHDConfigBox *ptr = (GF_TrueHDConfigBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 10)\n\tptr->format_info = gf_bs_read_u32(bs);\n\tptr->peak_data_rate = gf_bs_read_int(bs, 15);\n\tgf_bs_read_int(bs, 1);\n\tgf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err dmlp_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TrueHDConfigBox *ptr = (GF_TrueHDConfigBox *)s;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->format_info);\n\tgf_bs_write_int(bs, ptr->peak_data_rate, 15);\n\tgf_bs_write_int(bs, 0, 1);\n\tgf_bs_write_u32(bs, 0);\n\treturn GF_OK;\n}\n\nGF_Err dmlp_box_size(GF_Box *s)\n{\n\ts->size += 10;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *xtra_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_XtraBox, GF_ISOM_BOX_TYPE_XTRA);\n\ttmp->tags = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\nvoid xtra_box_del(GF_Box *s)\n{\n\tGF_XtraBox *ptr = (GF_XtraBox *)s;\n\twhile (gf_list_count(ptr->tags)) {\n\t\tGF_XtraTag *tag = gf_list_pop_back(ptr->tags);\n\t\tif (tag->name) gf_free(tag->name);\n\t\tif (tag->prop_value) gf_free(tag->prop_value);\n\t\tgf_free(tag);\n\t}\n\tgf_list_del(ptr->tags);\n\tgf_free(s);\n}\n\nGF_Err xtra_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_XtraBox *ptr = (GF_XtraBox *)s;\n\twhile (ptr->size) {\n\t\tGF_XtraTag *tag;\n\t\tu32 prop_type = 0;\n\n\t\tchar *data=NULL, *data2=NULL;\n\t\tISOM_DECREASE_SIZE_NO_ERR(ptr, 8)\n\t\ts32 tag_size = gf_bs_read_u32(bs);\n\t\tu32 name_size = gf_bs_read_u32(bs);\n\t\tif (tag_size < 8) return GF_ISOM_INVALID_FILE;\n\n\t\ttag_size -= 8;\n\t\tif ((tag_size>ptr->size) || (name_size>ptr->size)) {\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t\tISOM_DECREASE_SIZE_NO_ERR(ptr, 10)\n\n\t\tISOM_DECREASE_SIZE_NO_ERR(ptr, name_size)\n\t\tdata = gf_malloc(sizeof(char) * (name_size+1));\n\t\tgf_bs_read_data(bs, data, name_size);\n\t\tdata[name_size] = 0;\n\t\ttag_size-=name_size;\n\n\t\tu32 flags = gf_bs_read_u32(bs);\n\t\tu32 prop_size = gf_bs_read_u32(bs);\n\t\ttag_size-=8;\n\n\t\tif (prop_size>4) {\n\t\t\ttag_size-=2;\n\t\t\tprop_type = gf_bs_read_u16(bs);\n\t\t\tprop_size -= 6;\n\t\t\tISOM_DECREASE_SIZE_NO_ERR(ptr, prop_size)\n\t\t\t//add 3 extra bytes for UTF16 case string dump (3 because we need 0-aligned short value)\n\t\t\tdata2 = gf_malloc(sizeof(char) * (prop_size+3));\n\t\t\tgf_bs_read_data(bs, data2, prop_size);\n\t\t\tdata2[prop_size] = 0;\n\t\t\tdata2[prop_size+1] = 0;\n\t\t\tdata2[prop_size+2] = 0;\n\t\t\ttag_size-=prop_size;\n\t\t} else {\n\t\t\tprop_size = 0;\n\t\t}\n\t\tGF_SAFEALLOC(tag, GF_XtraTag)\n\t\ttag->flags = flags;\n\t\ttag->name = data;\n\t\ttag->prop_size = prop_size;\n\t\ttag->prop_value = data2;\n\t\ttag->prop_type = prop_type;\n\t\tgf_list_add(ptr->tags, tag);\n\n\t\tif (tag_size) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[isom] left-over bytes in tag %s in Xtra !\\n\", data));\n\t\t\tgf_bs_skip_bytes(bs, tag_size);\n\t\t\tISOM_DECREASE_SIZE_NO_ERR(ptr, tag_size)\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err xtra_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_XtraBox *ptr = (GF_XtraBox *)s;\n\tu32 i, count = gf_list_count(ptr->tags);\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tfor (i=0; i<count; i++) {\n\t\tGF_XtraTag *tag = gf_list_get(ptr->tags, i);\n\t\tu32 tag_size = 16;\n\t\tu32 name_len = tag->name ? (u32) strlen(tag->name) : 0;\n\t\ttag_size += name_len;\n\t\tif (tag->prop_value) {\n\t\t\ttag_size += 2 + tag->prop_size;\n\t\t}\n\t\tgf_bs_write_u32(bs, tag_size);\n\t\tgf_bs_write_u32(bs, name_len);\n\t\tgf_bs_write_data(bs, tag->name, name_len);\n\t\tgf_bs_write_u32(bs, tag->flags);\n\t\tgf_bs_write_u32(bs, 6 + tag->prop_size);\n\t\tgf_bs_write_u16(bs, tag->prop_type);\n\t\tgf_bs_write_data(bs, tag->prop_value, tag->prop_size);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err xtra_box_size(GF_Box *s)\n{\n\tGF_XtraBox *ptr = (GF_XtraBox *)s;\n\tu32 i, count = gf_list_count(ptr->tags);\n\tfor (i=0; i<count; i++) {\n\t\tGF_XtraTag *tag = gf_list_get(ptr->tags, i);\n\t\tptr->size += 18 + (u32) strlen(tag->name) + tag->prop_size;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Box *st3d_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_Stereo3DBox, GF_ISOM_BOX_TYPE_ST3D);\n\treturn (GF_Box *)tmp;\n}\n\nvoid st3d_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\n\nGF_Err st3d_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Stereo3DBox *ptr = (GF_Stereo3DBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 1)\n\tptr->stereo_type = gf_bs_read_u8(bs);\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err st3d_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_Stereo3DBox *ptr = (GF_Stereo3DBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u8(bs, ptr->stereo_type);\n\treturn GF_OK;\n}\n\nGF_Err st3d_box_size(GF_Box *s)\n{\n\ts->size += 1;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Box *svhd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SphericalVideoInfoBox, GF_ISOM_BOX_TYPE_SVHD);\n\treturn (GF_Box *)tmp;\n}\n\nvoid svhd_box_del(GF_Box *s)\n{\n\tGF_SphericalVideoInfoBox *ptr = (GF_SphericalVideoInfoBox *)s;\n\tif (ptr->string) gf_free(ptr->string);\n\tgf_free(s);\n}\n\n\nGF_Err svhd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_SphericalVideoInfoBox *ptr = (GF_SphericalVideoInfoBox *)s;\n\tif ((u32)ptr->size >= (u32)0xFFFFFFFF) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid size %llu in svhd box\\n\", ptr->size));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tptr->string = gf_malloc(sizeof(char) * ((u32) ptr->size+1));\n\tif (!ptr->string) return GF_OUT_OF_MEM;\n\tgf_bs_read_data(bs, ptr->string, (u32) ptr->size);\n\tptr->string[ptr->size] = 0;\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err svhd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SphericalVideoInfoBox *ptr = (GF_SphericalVideoInfoBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tif (ptr->string)\n\t\tgf_bs_write_data(bs, ptr->string, (u32) strlen(ptr->string));\n\tgf_bs_write_u8(bs, 0);\n\treturn GF_OK;\n}\n\nGF_Err svhd_box_size(GF_Box *s)\n{\n\tGF_SphericalVideoInfoBox *ptr = (GF_SphericalVideoInfoBox *)s;\n\tif (ptr->string)\n\t\ts->size += (u32) strlen(ptr->string);\n\ts->size += 1;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *prhd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ProjectionHeaderBox, GF_ISOM_BOX_TYPE_PRHD);\n\treturn (GF_Box *)tmp;\n}\n\nvoid prhd_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\n\nGF_Err prhd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_ProjectionHeaderBox *ptr = (GF_ProjectionHeaderBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 12)\n\tptr->yaw = (s32) gf_bs_read_u32(bs);\n\tptr->pitch = (s32) gf_bs_read_u32(bs);\n\tptr->roll = (s32) gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err prhd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ProjectionHeaderBox *ptr = (GF_ProjectionHeaderBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->yaw);\n\tgf_bs_write_u32(bs, ptr->pitch);\n\tgf_bs_write_u32(bs, ptr->roll);\n\treturn GF_OK;\n}\n\nGF_Err prhd_box_size(GF_Box *s)\n{\n\ts->size += 12;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *proj_type_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ProjectionTypeBox, GF_ISOM_BOX_TYPE_EQUI); //will be overwritten\n\treturn (GF_Box *)tmp;\n}\n\nvoid proj_type_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err proj_type_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_ProjectionTypeBox *ptr = (GF_ProjectionTypeBox *)s;\n\n\tif (ptr->type==GF_ISOM_BOX_TYPE_CBMP) {\n\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\tptr->layout = gf_bs_read_u32(bs);\n\t\tptr->padding = gf_bs_read_u32(bs);\n\t}\n\telse if (ptr->type==GF_ISOM_BOX_TYPE_EQUI) {\n\t\tISOM_DECREASE_SIZE(ptr, 16)\n\t\tptr->bounds_top = gf_bs_read_u32(bs);\n\t\tptr->bounds_bottom = gf_bs_read_u32(bs);\n\t\tptr->bounds_left = gf_bs_read_u32(bs);\n\t\tptr->bounds_right = gf_bs_read_u32(bs);\n\t} else {\n\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\tptr->crc = gf_bs_read_u32(bs);\n\t\tptr->encoding_4cc = gf_bs_read_u32(bs);\n\t}\n\treturn gf_isom_box_array_read(s, bs);\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err proj_type_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ProjectionTypeBox *ptr = (GF_ProjectionTypeBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tif (ptr->type==GF_ISOM_BOX_TYPE_CBMP) {\n\t\tgf_bs_write_u32(bs, ptr->layout);\n\t\tgf_bs_write_u32(bs, ptr->padding);\n\t}\n\telse if (ptr->type==GF_ISOM_BOX_TYPE_EQUI) {\n\t\tgf_bs_write_u32(bs, ptr->bounds_top);\n\t\tgf_bs_write_u32(bs, ptr->bounds_bottom);\n\t\tgf_bs_write_u32(bs, ptr->bounds_left);\n\t\tgf_bs_write_u32(bs, ptr->bounds_right);\n\t} else {\n\t\tgf_bs_write_u32(bs, ptr->crc);\n\t\tgf_bs_write_u32(bs, ptr->encoding_4cc);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err proj_type_box_size(GF_Box *s)\n{\n\tGF_ProjectionTypeBox *ptr = (GF_ProjectionTypeBox *)s;\n\tif (ptr->type==GF_ISOM_BOX_TYPE_CBMP)\n\t\ts->size += 8;\n\telse if (ptr->type==GF_ISOM_BOX_TYPE_EQUI)\n\t\ts->size += 16;\n\telse\n\t\ts->size += 8;\n\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *empty_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_Box, GF_QT_BOX_TYPE_FRCD);\n\treturn (GF_Box *) tmp;\n}\n\nvoid empty_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err empty_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err empty_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err empty_box_size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM*/\n", "/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2023\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISO Media File Format sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/internal/isomedia_dev.h>\n#include <gpac/constants.h>\n#include <gpac/iso639.h>\n\n\n#if !defined(GPAC_DISABLE_ISOM) && !defined(GPAC_DISABLE_ISOM_WRITE)\n\nGF_Err CanAccessMovie(GF_ISOFile *movie, GF_ISOOpenMode Mode)\n{\n\tif (!movie) return GF_BAD_PARAM;\n\tif (movie->openMode < Mode) return GF_ISOM_INVALID_MODE;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY) return GF_ISOM_INVALID_MODE;\n#endif\n\treturn GF_OK;\n}\n\nstatic GF_Err unpack_track(GF_TrackBox *trak)\n{\n\tGF_Err e = GF_OK;\n\tif (!trak->is_unpacked) {\n\t\te = stbl_UnpackOffsets(trak->Media->information->sampleTable);\n\t\tif (e) return e;\n\t\te = stbl_unpackCTS(trak->Media->information->sampleTable);\n\t\ttrak->is_unpacked = GF_TRUE;\n\t}\n\treturn e;\n}\n\n\nGF_Err FlushCaptureMode(GF_ISOFile *movie)\n{\n\tGF_Err e;\n\tif (movie->openMode != GF_ISOM_OPEN_WRITE) {\n\t\tif (!movie->editFileMap) return GF_ISOM_INVALID_MODE;\n\t\treturn GF_OK;\n\t}\n\t/*make sure nothing was added*/\n\tif (gf_bs_get_position(movie->editFileMap->bs)) return GF_OK;\n\n\tif (!strcmp(movie->fileName, \"_gpac_isobmff_redirect\")) {\n\t\tif (!movie->on_block_out) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[ISOBMFF] Missing output block callback, cannot write\\n\"));\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\n\t\tgf_bs_del(movie->editFileMap->bs);\n\t\tmovie->editFileMap->bs = gf_bs_new_cbk(isom_on_block_out, movie, movie->on_block_out_block_size);\n\t}\n\n\t/*add all first boxes*/\n\tif (movie->brand) {\n\t\te = gf_isom_box_size((GF_Box *)movie->brand);\n\t\tif (e) return e;\n\t\te = gf_isom_box_write((GF_Box *)movie->brand, movie->editFileMap->bs);\n\t\tif (e) return e;\n\t}\n\tif (movie->pdin) {\n\t\te = gf_isom_box_size((GF_Box *)movie->pdin);\n\t\tif (e) return e;\n\t\te = gf_isom_box_write((GF_Box *)movie->pdin, movie->editFileMap->bs);\n\t\tif (e) return e;\n\t}\n\tmovie->mdat->bsOffset = gf_bs_get_position(movie->editFileMap->bs);\n\n\t/*we have a trick here: the data will be stored on the fly, so the first\n\tthing in the file is the MDAT. As we don't know if we have a large file (>4 GB) or not\n\tdo as if we had one and write 16 bytes: 4 (type) + 4 (size) + 8 (largeSize)...*/\n\tgf_bs_write_long_int(movie->editFileMap->bs, 0, 64);\n\tgf_bs_write_long_int(movie->editFileMap->bs, 0, 64);\n\treturn GF_OK;\n}\n\nstatic GF_Err CheckNoData(GF_ISOFile *movie)\n{\n\tif (movie->openMode != GF_ISOM_OPEN_WRITE) return GF_OK;\n\tif (gf_bs_get_position(movie->editFileMap->bs)) return GF_BAD_PARAM;\n\treturn GF_OK;\n}\n\n/**************************************************************\n\t\t\t\t\tFile Writing / Editing\n**************************************************************/\n//quick function to add an IOD/OD to the file if not present (iods is optional)\nGF_Err AddMovieIOD(GF_MovieBox *moov, u8 isIOD)\n{\n\tGF_Descriptor *od;\n\tGF_ObjectDescriptorBox *iods;\n\n\t//do we have an IOD ?? If not, create one.\n\tif (moov->iods) return GF_OK;\n\n\tif (isIOD) {\n\t\tod = gf_odf_desc_new(GF_ODF_ISOM_IOD_TAG);\n\t} else {\n\t\tod = gf_odf_desc_new(GF_ODF_ISOM_OD_TAG);\n\t}\n\tif (!od) return GF_OUT_OF_MEM;\n\t((GF_IsomObjectDescriptor *)od)->objectDescriptorID = 1;\n\n\tiods = (GF_ObjectDescriptorBox *) gf_isom_box_new_parent(&moov->child_boxes, GF_ISOM_BOX_TYPE_IODS);\n\tif (!iods) return GF_OUT_OF_MEM;\n\tiods->descriptor = od;\n\treturn moov_on_child_box((GF_Box*)moov, (GF_Box *)iods, GF_FALSE);\n}\n\n//add a track to the root OD\nGF_EXPORT\nGF_Err gf_isom_add_track_to_root_od(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_Err e;\n\tGF_ES_ID_Inc *inc;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\n\tif (!movie->moov->iods) AddMovieIOD(movie->moov, 0);\n\n\tif (gf_isom_is_track_in_root_od(movie, trackNumber) == 1) return GF_OK;\n\n\tinc = (GF_ES_ID_Inc *) gf_odf_desc_new(GF_ODF_ESD_INC_TAG);\n\tinc->trackID = gf_isom_get_track_id(movie, trackNumber);\n\tif (!inc->trackID) {\n\t\tgf_odf_desc_del((GF_Descriptor *)inc);\n\t\treturn movie->LastError;\n\t}\n\tif ( (movie->LastError = gf_isom_add_desc_to_root_od(movie, (GF_Descriptor *)inc) ) ) {\n\t\treturn movie->LastError;\n\t}\n\tgf_odf_desc_del((GF_Descriptor *)inc);\n\treturn GF_OK;\n}\n\n//remove the root OD\nGF_EXPORT\nGF_Err gf_isom_remove_root_od(GF_ISOFile *movie)\n{\n\tGF_Err e;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\tif (!movie->moov || !movie->moov->iods) return GF_OK;\n\tgf_isom_box_del_parent(&movie->moov->child_boxes, (GF_Box *)movie->moov->iods);\n\tmovie->moov->iods = NULL;\n\treturn GF_OK;\n}\n\n//remove a track to the root OD\nGF_EXPORT\nGF_Err gf_isom_remove_track_from_root_od(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_List *esds;\n\tGF_ES_ID_Inc *inc;\n\tu32 i;\n\tGF_Err e;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\tif (!movie->moov) return GF_OK;\n\n\tif (!gf_isom_is_track_in_root_od(movie, trackNumber)) return GF_OK;\n\n\tif (!movie->moov->iods) {\n\t\te = AddMovieIOD(movie->moov, 0);\n\t\tif (e) return e;\n\t}\n\tswitch (movie->moov->iods->descriptor->tag) {\n\tcase GF_ODF_ISOM_IOD_TAG:\n\t\tesds = ((GF_IsomInitialObjectDescriptor *)movie->moov->iods->descriptor)->ES_ID_IncDescriptors;\n\t\tbreak;\n\tcase GF_ODF_ISOM_OD_TAG:\n\t\tesds = ((GF_IsomObjectDescriptor *)movie->moov->iods->descriptor)->ES_ID_IncDescriptors;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\t//get the desc\n\ti=0;\n\twhile ((inc = (GF_ES_ID_Inc*)gf_list_enum(esds, &i))) {\n\t\tif (inc->trackID == (u32) gf_isom_get_track_id(movie, trackNumber)) {\n\t\t\tgf_odf_desc_del((GF_Descriptor *)inc);\n\t\t\tgf_list_rem(esds, i-1);\n\t\t\tbreak;\n\t\t}\n\t}\n\t//we don't remove the iod for P&Ls and other potential info\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_creation_time(GF_ISOFile *movie, u64 ctime, u64 mtime)\n{\n\tif (!movie || !movie->moov) return GF_BAD_PARAM;\n\tmovie->moov->mvhd->creationTime = ctime;\n\tmovie->moov->mvhd->modificationTime = mtime;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_track_creation_time(GF_ISOFile *movie,u32 trackNumber, u64 ctime, u64 mtime)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\ttrak->Header->creationTime = ctime;\n\ttrak->Header->modificationTime = mtime;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_media_creation_time(GF_ISOFile *movie,u32 trackNumber, u64 ctime, u64 mtime)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\tif (!trak->Media || !trak->Media->mediaHeader) return GF_ISOM_INVALID_FILE;\n\n\ttrak->Media->mediaHeader->creationTime = ctime;\n\ttrak->Media->mediaHeader->modificationTime = mtime;\n\treturn GF_OK;\n}\n\n//sets the enable flag of a track\nGF_EXPORT\nGF_Err gf_isom_set_track_enabled(GF_ISOFile *movie, u32 trackNumber, Bool enableTrack)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tif (enableTrack) {\n\t\ttrak->Header->flags |= 1;\n\t} else {\n\t\ttrak->Header->flags &= ~1;\n\t}\n\treturn GF_OK;\n}\n\n//sets the enable flag of a track\nGF_EXPORT\nGF_Err gf_isom_set_track_flags(GF_ISOFile *movie, u32 trackNumber, u32 flags, GF_ISOMTrackFlagOp op)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\tif (op==GF_ISOM_TKFLAGS_ADD)\n\t\ttrak->Header->flags |= flags;\n\telse if (op==GF_ISOM_TKFLAGS_REM)\n\t\ttrak->Header->flags &= ~flags;\n\telse\n\t\ttrak->Header->flags = flags;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_media_language(GF_ISOFile *movie, u32 trackNumber, char *code)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !code) return GF_BAD_PARAM;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\t// Old language-storage processing\n\t// if the new code is on 3 chars, we use it\n\t// otherwise, we find the associated 3 chars code and use it\n\tif (strlen(code) == 3) {\n\t\tmemcpy(trak->Media->mediaHeader->packedLanguage, code, sizeof(char)*3);\n\t} else {\n\t\ts32 lang_idx;\n\t\tconst char *code_3cc;\n\t\tlang_idx = gf_lang_find(code);\n\t\tif (lang_idx == -1) {\n\t\t\tif (code[0]!=0) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"The given code is not a valid one: %s, using 'und' as 3-letter code\\n\", code));\n\t\t\t}\n\t\t\tcode_3cc = \"und\";\n\t\t} else {\n\t\t\tcode_3cc = gf_lang_get_3cc(lang_idx);\n\t\t}\n\t\tmemcpy(trak->Media->mediaHeader->packedLanguage, code_3cc, sizeof(char)*3);\n\t}\n\n\t// New language-storage processing\n\t// change the code in the extended language box (if any)\n\t// otherwise add an extended language box only if the given code is not 3 chars\n\t{\n\t\tu32 i, count;\n\t\tGF_ExtendedLanguageBox *elng;\n\t\telng = NULL;\n\t\tcount = gf_list_count(trak->Media->child_boxes);\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tGF_Box *box = (GF_Box *)gf_list_get(trak->Media->child_boxes, i);\n\t\t\tif (box->type == GF_ISOM_BOX_TYPE_ELNG) {\n\t\t\t\telng = (GF_ExtendedLanguageBox *)box;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!elng && (strlen(code) > 3)) {\n\t\t\telng = (GF_ExtendedLanguageBox *)gf_isom_box_new_parent(&trak->Media->child_boxes, GF_ISOM_BOX_TYPE_ELNG);\n\t\t\tif (!elng) return GF_OUT_OF_MEM;\n\t\t}\n\t\tif (elng) {\n\t\t\tif (elng->extended_language) {\n\t\t\t\tgf_free(elng->extended_language);\n\t\t\t}\n\t\t\telng->extended_language = gf_strdup(code);\n\t\t}\n\t}\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\treturn GF_OK;\n}\n\nstatic GF_Err gf_isom_set_root_iod(GF_ISOFile *movie)\n{\n\tGF_IsomInitialObjectDescriptor *iod;\n\tGF_IsomObjectDescriptor *od;\n\tGF_Err e;\n\t\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\tif (!movie->moov->iods) {\n\t\tAddMovieIOD(movie->moov, 1);\n\t\treturn GF_OK;\n\t}\n\t//if OD, switch to IOD\n\tif (movie->moov->iods->descriptor->tag == GF_ODF_ISOM_IOD_TAG) return GF_OK;\n\tod = (GF_IsomObjectDescriptor *) movie->moov->iods->descriptor;\n\tiod = (GF_IsomInitialObjectDescriptor*)gf_malloc(sizeof(GF_IsomInitialObjectDescriptor));\n\tif (!iod) return GF_OUT_OF_MEM;\n\n\tmemset(iod, 0, sizeof(GF_IsomInitialObjectDescriptor));\n\n\tiod->ES_ID_IncDescriptors = od->ES_ID_IncDescriptors;\n\tod->ES_ID_IncDescriptors = NULL;\n\t//not used in root OD\n\tiod->ES_ID_RefDescriptors = NULL;\n\tiod->extensionDescriptors = od->extensionDescriptors;\n\tod->extensionDescriptors = NULL;\n\tiod->IPMP_Descriptors = od->IPMP_Descriptors;\n\tod->IPMP_Descriptors = NULL;\n\tiod->objectDescriptorID = od->objectDescriptorID;\n\tiod->OCIDescriptors = od->OCIDescriptors;\n\tod->OCIDescriptors = NULL;\n\tiod->tag = GF_ODF_ISOM_IOD_TAG;\n\tiod->URLString = od->URLString;\n\tod->URLString = NULL;\n\n\tgf_odf_desc_del((GF_Descriptor *) od);\n\tmovie->moov->iods->descriptor = (GF_Descriptor *)iod;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_add_desc_to_root_od(GF_ISOFile *movie, const GF_Descriptor *theDesc)\n{\n\tGF_Err e;\n\tGF_Descriptor *desc, *dupDesc;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\n\tif (!movie->moov->iods) {\n\t\te = AddMovieIOD(movie->moov, 0);\n\t\tif (e) return e;\n\t}\n\tif (theDesc->tag==GF_ODF_IPMP_TL_TAG) gf_isom_set_root_iod(movie);\n\n\tdesc = movie->moov->iods->descriptor;\n\t//the type of desc is handled at the OD/IOD level, we'll be notified\n\t//if the desc is not allowed\n\tswitch (desc->tag) {\n\tcase GF_ODF_ISOM_IOD_TAG:\n\tcase GF_ODF_ISOM_OD_TAG:\n\t\t//duplicate the desc\n\t\te = gf_odf_desc_copy((GF_Descriptor *)theDesc, &dupDesc);\n\t\tif (e) return e;\n\t\t//add it (MUST BE  (I)OD level desc)\n\t\tmovie->LastError = gf_odf_desc_add_desc(desc, dupDesc);\n\t\tif (movie->LastError) gf_odf_desc_del((GF_Descriptor *)dupDesc);\n\t\tbreak;\n\tdefault:\n\t\tmovie->LastError = GF_ISOM_INVALID_FILE;\n\t\tbreak;\n\t}\n\treturn movie->LastError;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_set_timescale(GF_ISOFile *movie, u32 timeScale)\n{\n\tGF_TrackBox *trak;\n\tu32 i;\n\tGF_Err e;\n\tif (!timeScale) return GF_BAD_PARAM;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\n\tif (movie->moov->mvhd->timeScale == timeScale) return GF_OK;\n\n\t/*rewrite all durations and edit lists*/\n\tmovie->moov->mvhd->duration *= timeScale;\n\tmovie->moov->mvhd->duration /= movie->moov->mvhd->timeScale;\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (movie->moov->mvex && movie->moov->mvex->mehd) {\n\t\tmovie->moov->mvex->mehd->fragment_duration *= timeScale;\n\t\tmovie->moov->mvex->mehd->fragment_duration /= movie->moov->mvhd->timeScale;\n\t}\n#endif\n\n\ti=0;\n\twhile ((trak = (GF_TrackBox*)gf_list_enum(movie->moov->trackList, &i))) {\n\t\ttrak->Header->duration *= timeScale;\n\t\ttrak->Header->duration /= movie->moov->mvhd->timeScale;\n\n\t\tif (trak->editBox && trak->editBox->editList) {\n\t\t\tu32 j, count = gf_list_count(trak->editBox->editList->entryList);\n\t\t\tfor (j=0; j<count; j++) {\n\t\t\t\tGF_EdtsEntry *ent = (GF_EdtsEntry *)gf_list_get(trak->editBox->editList->entryList, j);\n\t\t\t\tent->segmentDuration *= timeScale;\n\t\t\t\tent->segmentDuration /= movie->moov->mvhd->timeScale;\n\t\t\t}\n\t\t}\n\t}\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (movie->moov->mvex && movie->moov->mvex->mehd) {\n\t\tmovie->moov->mvex->mehd->fragment_duration *= timeScale;\n\t\tmovie->moov->mvex->mehd->fragment_duration /= movie->moov->mvhd->timeScale;\n\t}\n#endif\n\tmovie->moov->mvhd->timeScale = timeScale;\n\tmovie->interleavingTime = timeScale;\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_set_pl_indication(GF_ISOFile *movie, GF_ISOProfileLevelType PL_Code, u8 ProfileLevel)\n{\n\tGF_IsomInitialObjectDescriptor *iod;\n\tGF_Err e;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\te = gf_isom_set_root_iod(movie);\n\tif (e) return e;\n\n\tiod = (GF_IsomInitialObjectDescriptor *)movie->moov->iods->descriptor;\n\n\tswitch (PL_Code) {\n\tcase GF_ISOM_PL_AUDIO:\n\t\tiod->audio_profileAndLevel = ProfileLevel;\n\t\tbreak;\n\tcase GF_ISOM_PL_GRAPHICS:\n\t\tiod->graphics_profileAndLevel = ProfileLevel;\n\t\tbreak;\n\tcase GF_ISOM_PL_OD:\n\t\tiod->OD_profileAndLevel = ProfileLevel;\n\t\tbreak;\n\tcase GF_ISOM_PL_SCENE:\n\t\tiod->scene_profileAndLevel = ProfileLevel;\n\t\tbreak;\n\tcase GF_ISOM_PL_VISUAL:\n\t\tiod->visual_profileAndLevel = ProfileLevel;\n\t\tbreak;\n\tcase GF_ISOM_PL_INLINE:\n\t\tiod->inlineProfileFlag = ProfileLevel ? 1 : 0;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_root_od_id(GF_ISOFile *movie, u32 OD_ID)\n{\n\tGF_Err e;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\tif (!movie->moov->iods) {\n\t\te = AddMovieIOD(movie->moov, 0);\n\t\tif (e) return e;\n\t}\n\n\tswitch (movie->moov->iods->descriptor->tag) {\n\tcase GF_ODF_ISOM_OD_TAG:\n\t\t((GF_IsomObjectDescriptor *)movie->moov->iods->descriptor)->objectDescriptorID = OD_ID;\n\t\tbreak;\n\tcase GF_ODF_ISOM_IOD_TAG:\n\t\t((GF_IsomInitialObjectDescriptor *)movie->moov->iods->descriptor)->objectDescriptorID = OD_ID;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_root_od_url(GF_ISOFile *movie, const char *url_string)\n{\n\tGF_Err e;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\n\tif (!movie->moov->iods) {\n\t\te = AddMovieIOD(movie->moov, 0);\n\t\tif (e) return e;\n\t}\n\n\tswitch (movie->moov->iods->descriptor->tag) {\n\tcase GF_ODF_ISOM_OD_TAG:\n\t\tif (((GF_IsomObjectDescriptor *)movie->moov->iods->descriptor)->URLString) gf_free(((GF_IsomObjectDescriptor *)movie->moov->iods->descriptor)->URLString);\n\t\t((GF_IsomObjectDescriptor *)movie->moov->iods->descriptor)->URLString = url_string ? gf_strdup(url_string) : NULL;\n\t\tbreak;\n\tcase GF_ODF_ISOM_IOD_TAG:\n\t\tif (((GF_IsomInitialObjectDescriptor *)movie->moov->iods->descriptor)->URLString) gf_free(((GF_IsomInitialObjectDescriptor *)movie->moov->iods->descriptor)->URLString);\n\t\t((GF_IsomInitialObjectDescriptor *)movie->moov->iods->descriptor)->URLString = url_string ? gf_strdup(url_string) : NULL;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_ISOTrackID gf_isom_get_last_created_track_id(GF_ISOFile *movie)\n{\n\treturn movie ? movie->last_created_track_id : 0;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_load_extra_boxes(GF_ISOFile *movie, u8 *moov_boxes, u32 moov_boxes_size, Bool udta_only)\n{\n\tGF_BitStream *bs;\n\n\tGF_Err e = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\n\tbs = gf_bs_new(moov_boxes, moov_boxes_size, GF_BITSTREAM_READ);\n\n\t//we may have terminators in some QT files (4 bytes set to 0 ...)\n\twhile (gf_bs_available(bs) >= 8) {\n\t\tGF_Box *a_box;\n\t\te = gf_isom_box_parse_ex((GF_Box**)&a_box, bs, GF_ISOM_BOX_TYPE_MOOV, GF_FALSE, 0);\n\t\tif (e || !a_box) goto exit;\n\n\t\tif (a_box->type == GF_ISOM_BOX_TYPE_UDTA) {\n\t\t\tif (movie->moov->udta) gf_isom_box_del_parent(&movie->moov->child_boxes, (GF_Box*)movie->moov->udta);\n\t\t\tmovie->moov->udta = (GF_UserDataBox*) a_box;\n\n\t\t\tif (!movie->moov->child_boxes) movie->moov->child_boxes = gf_list_new();\n\t\t\tgf_list_add(movie->moov->child_boxes, a_box);\n\n\t\t} else if (!udta_only && (a_box->type!=GF_ISOM_BOX_TYPE_PSSH) ) {\n\t\t\tif (!movie->moov->child_boxes) movie->moov->child_boxes = gf_list_new();\n\t\t\tgf_list_add(movie->moov->child_boxes, a_box);\n\t\t} else {\n\t\t\tgf_isom_box_del(a_box);\n\t\t}\n\t}\nexit:\n\tgf_bs_del(bs);\n\treturn e;\n}\n\n//creates a new Track. If trackID = 0, the trackID is chosen by the API\n//returns the track number or 0 if error\nGF_EXPORT\nu32 gf_isom_new_track_from_template(GF_ISOFile *movie, GF_ISOTrackID trakID, u32 MediaType, u32 TimeScale, u8 *tk_box, u32 tk_box_size, Bool udta_only)\n{\n\tGF_Err e;\n\tu64 now;\n\tu8 isHint;\n\tGF_TrackBox *trak;\n\tGF_TrackHeaderBox *tkhd;\n\tGF_MediaBox *mdia;\n\tGF_UserDataBox *udta = NULL;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) {\n\t\tgf_isom_set_last_error(movie, e);\n\t\treturn 0;\n\t}\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\n\n\tisHint = 0;\n\t//we're creating a hint track... it's the same, but mode HAS TO BE EDIT\n\tif (MediaType == GF_ISOM_MEDIA_HINT) {\n//\t\tif (movie->openMode != GF_ISOM_OPEN_EDIT) return 0;\n\t\tisHint = 1;\n\t}\n\n\tmdia = NULL;\n\ttkhd = NULL;\n\ttrak = NULL;\n\tif (trakID) {\n\t\t//check if we are in ES_ID boundaries\n\t\tif (!isHint && (trakID > 0xFFFF)) {\n\t\t\tgf_isom_set_last_error(movie, GF_BAD_PARAM);\n\t\t\treturn 0;\n\t\t}\n\t\t//here we should look for available IDs ...\n\t\tif (!RequestTrack(movie->moov, trakID)) return 0;\n\t} else {\n\t\ttrakID = movie->moov->mvhd->nextTrackID;\n\t\tif (!trakID) trakID = 1;\n\t\t/*ESIDs are on 16 bits*/\n\t\tif (! isHint && (trakID > 0xFFFF)) trakID = 1;\n\n\t\twhile (1) {\n\t\t\tif (RequestTrack(movie->moov, trakID)) break;\n\t\t\ttrakID += 1;\n\t\t\tif (trakID == 0xFFFFFFFF) break;\n\t\t}\n\t\tif (trakID == 0xFFFFFFFF) {\n\t\t\tgf_isom_set_last_error(movie, GF_BAD_PARAM);\n\t\t\treturn 0;\n\t\t}\n\t\tif (! isHint && (trakID > 0xFFFF)) {\n\t\t\tgf_isom_set_last_error(movie, GF_BAD_PARAM);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (tk_box) {\n\t\tGF_BitStream *bs = gf_bs_new(tk_box, tk_box_size, GF_BITSTREAM_READ);\n\t\tgf_bs_set_cookie(bs, GF_ISOM_BS_COOKIE_NO_LOGS|GF_ISOM_BS_COOKIE_CLONE_TRACK);\n\n\t\te = gf_isom_box_parse_ex((GF_Box**)&trak, bs, GF_ISOM_BOX_TYPE_MOOV, GF_FALSE, 0);\n\t\tgf_bs_del(bs);\n\t\tif (e) trak = NULL;\n\t\telse if (udta_only) {\n\t\t\tudta = trak->udta;\n\t\t\ttrak->udta = NULL;\n\t\t\tgf_list_del_item(trak->child_boxes, udta);\n\t\t\tgf_isom_box_del((GF_Box*)trak);\n\t\t\ttrak = NULL;\n\t\t} else {\n\t\t\tBool tpl_ok = GF_TRUE;\n\t\t\tif (!trak->Header || !trak->Media || !trak->Media->handler || !trak->Media->mediaHeader || !trak->Media->information) tpl_ok = GF_FALSE;\n\n\t\t\telse {\n\t\t\t\tif (!MediaType) MediaType = trak->Media->handler->handlerType;\n\t\t\t\te = NewMedia(&trak->Media, MediaType, TimeScale);\n\t\t\t\tif (e) tpl_ok = GF_FALSE;\n\t\t\t}\n\t\t\tif (!tpl_ok) {\n\t\t\t\tudta = trak->udta;\n\t\t\t\ttrak->udta = NULL;\n\t\t\t\tgf_isom_box_del((GF_Box*)trak);\n\t\t\t}\n\t\t}\n\t}\n\tnow = gf_isom_get_mp4time();\n\tif (!trak) {\n\t\t//OK, now create a track...\n\t\ttrak = (GF_TrackBox *) gf_isom_box_new_parent(&movie->moov->child_boxes, GF_ISOM_BOX_TYPE_TRAK);\n\t\tif (!trak) {\n\t\t\tgf_isom_set_last_error(movie, GF_OUT_OF_MEM);\n\t\t\treturn 0;\n\t\t}\n\t\ttkhd = (GF_TrackHeaderBox *) gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_TKHD);\n\t\tif (!tkhd) {\n\t\t\tgf_isom_set_last_error(movie, GF_OUT_OF_MEM);\n\t\t\treturn 0;\n\t\t}\n\n\t\t//OK, set up the media trak\n\t\te = NewMedia(&mdia, MediaType, TimeScale);\n\t\tif (e) {\n\t\t\tgf_isom_box_del((GF_Box *)mdia);\n\t\t\treturn 0;\n\t\t}\n\t\tassert(trak->child_boxes);\n\t\tgf_list_add(trak->child_boxes, mdia);\n\n\t\t//OK, add this media to our track\n\t\tmdia->mediaTrack = trak;\n\n\t\te = trak_on_child_box((GF_Box*)trak, (GF_Box *) tkhd, GF_FALSE);\n\t\tif (e) goto err_exit;\n\t\te = trak_on_child_box((GF_Box*)trak, (GF_Box *) mdia, GF_FALSE);\n\t\tif (e) goto err_exit;\n\t\ttkhd->trackID = trakID;\n\n\t\tif (gf_sys_is_test_mode() ) {\n\t\t\ttkhd->creationTime = 0;\n\t\t\tmdia->mediaHeader->creationTime = 0;\n\t\t} else {\n\t\t\ttkhd->creationTime = now;\n\t\t\tmdia->mediaHeader->creationTime = now;\n\t\t}\n\n\t} else {\n\t\ttkhd = trak->Header;\n\t\ttkhd->trackID = trakID;\n\t\tmdia = trak->Media;\n\t\tmdia->mediaTrack = trak;\n\t\tmdia->mediaHeader->timeScale = TimeScale;\n\t\tif (mdia->handler->handlerType != MediaType) {\n\t\t\tmdia->handler->handlerType = MediaType;\n\t\t\ttkhd->width = 0;\n\t\t\ttkhd->height = 0;\n\t\t\ttkhd->volume = 0;\n\t\t} else {\n\t\t\tMediaType = 0;\n\t\t}\n\t\ttrak->Header->duration = 0;\n\t\tmdia->mediaHeader->duration = 0;\n\n\t\tif (!movie->moov->child_boxes) movie->moov->child_boxes = gf_list_new();\n\t\tgf_list_add(movie->moov->child_boxes, trak);\n\t}\n\tif (MediaType) {\n\t\t//some default properties for Audio, Visual or private tracks\n\t\tswitch (MediaType) {\n\t\tcase GF_ISOM_MEDIA_VISUAL:\n\t\tcase GF_ISOM_MEDIA_AUXV:\n\t\tcase GF_ISOM_MEDIA_PICT:\n\t\tcase GF_ISOM_MEDIA_SCENE:\n\t\tcase GF_ISOM_MEDIA_TEXT:\n\t\tcase GF_ISOM_MEDIA_SUBT:\n\t\t\t/*320-240 pix in 16.16*/\n\t\t\ttkhd->width = 0x01400000;\n\t\t\ttkhd->height = 0x00F00000;\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_AUDIO:\n\t\t\ttkhd->volume = 0x0100;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmovie->last_created_track_id = tkhd->trackID;\n\t\n\tif (!movie->keep_utc && !gf_sys_is_test_mode() ) {\n\t\ttkhd->modificationTime = now;\n\t \tmdia->mediaHeader->modificationTime = now;\n\t}\n\n\t//OK, add our trak\n\te = moov_on_child_box((GF_Box*)movie->moov, (GF_Box *)trak, GF_FALSE);\n\tif (e) goto err_exit;\n\t//set the next track ID available\n\tif (trakID >= movie->moov->mvhd->nextTrackID)\n\t\tmovie->moov->mvhd->nextTrackID = trakID+1;\n\n\tif (udta) {\n\t\ttrak->udta = udta;\n\t\tgf_list_add(trak->child_boxes, udta);\n\t}\n\n\t//and return our track number\n\treturn gf_isom_get_track_by_id(movie, trakID);\n\nerr_exit:\n\t//tkhd is registered with track and will be destroyed there\n\tif (trak) gf_isom_box_del((GF_Box *)trak);\n\tif (mdia) gf_isom_box_del((GF_Box *)mdia);\n\treturn 0;\n}\n\nGF_Err gf_isom_set_track_stsd_templates(GF_ISOFile *movie, u32 trackNumber, u8 *stsd_data, u32 stsd_data_size)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tGF_SampleDescriptionBox *stsd=NULL;\n\tGF_List *tmp;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media) return GF_BAD_PARAM;\n\tif (gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes))\n\t\treturn GF_BAD_PARAM;\n\n\tGF_BitStream *bs = gf_bs_new(stsd_data, stsd_data_size, GF_BITSTREAM_READ);\n\te = gf_isom_box_parse_ex((GF_Box **) &stsd, bs, GF_ISOM_BOX_TYPE_STBL, GF_FALSE, 0);\n\tgf_bs_del(bs);\n\tif (!e && (stsd->type==GF_ISOM_BOX_TYPE_STSD)) {\n\t\ttmp = trak->Media->information->sampleTable->SampleDescription->child_boxes;\n\t\ttrak->Media->information->sampleTable->SampleDescription->child_boxes = stsd->child_boxes;\n\t\tstsd->child_boxes = tmp;\n\t}\n\tif (stsd) gf_isom_box_del((GF_Box*)stsd);\n\treturn e;\n}\n\nGF_EXPORT\nu32 gf_isom_new_track(GF_ISOFile *movie, GF_ISOTrackID trakID, u32 MediaType, u32 TimeScale)\n{\n\treturn gf_isom_new_track_from_template(movie, trakID, MediaType, TimeScale, NULL, 0, GF_FALSE);\n}\n\nGF_EXPORT\nGF_Err gf_isom_remove_stream_description(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tGF_SampleEntryBox *entry;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media) return GF_BAD_PARAM;\n\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tentry = (GF_SampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, StreamDescriptionIndex - 1);\n\tif (!entry) return GF_BAD_PARAM;\n\tgf_list_rem(trak->Media->information->sampleTable->SampleDescription->child_boxes, StreamDescriptionIndex - 1);\n\tgf_isom_box_del((GF_Box *)entry);\n\treturn GF_OK;\n}\n\n//Create a new StreamDescription in the file. The URL and URN are used to describe external media\nGF_EXPORT\nGF_Err gf_isom_new_mpeg4_description(GF_ISOFile *movie,\n                                     u32 trackNumber,\n                                     const GF_ESD *esd,\n                                     const char *URLname,\n                                     const char *URNname,\n                                     u32 *outDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tu32 dataRefIndex;\n\tGF_ESD *new_esd;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media ||\n\t        !esd || !esd->decoderConfig ||\n\t        !esd->slConfig) return GF_BAD_PARAM;\n\n\t//get or create the data ref\n\te = Media_FindDataRef(trak->Media->information->dataInformation->dref, (char *)URLname, (char *)URNname, &dataRefIndex);\n\tif (e) return e;\n\tif (!dataRefIndex) {\n\t\te = Media_CreateDataRef(movie, trak->Media->information->dataInformation->dref, (char *)URLname, (char *)URNname, &dataRefIndex);\n\t\tif (e) return e;\n\t}\n\t//duplicate our desc\n\te = gf_odf_desc_copy((GF_Descriptor *)esd, (GF_Descriptor **)&new_esd);\n\tif (e) return e;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\te = Track_SetStreamDescriptor(trak, 0, dataRefIndex, new_esd, outDescriptionIndex);\n\tif (e) {\n\t\tgf_odf_desc_del((GF_Descriptor *)new_esd);\n\t\treturn e;\n\t}\n\treturn e;\n}\n\nGF_Err gf_isom_flush_chunk(GF_TrackBox *trak, Bool is_final)\n{\n\tGF_Err e;\n\tu64 data_offset;\n\tu32 sample_number;\n\tu8 *chunk_data;\n\tu32 chunk_size, chunk_alloc;\n\tif (!trak->chunk_cache) return GF_OK;\n\n\tgf_bs_get_content_no_truncate(trak->chunk_cache, &chunk_data, &chunk_size, &chunk_alloc);\n\n\tdata_offset = gf_isom_datamap_get_offset(trak->Media->information->dataHandler);\n\n\te = gf_isom_datamap_add_data(trak->Media->information->dataHandler, chunk_data, chunk_size);\n\tif (e) return e;\n\n\tsample_number = 1 + trak->Media->information->sampleTable->SampleSize->sampleCount;\n\tsample_number -= trak->nb_samples_in_cache;\n\n\te = stbl_AddChunkOffset(trak->Media, sample_number, trak->chunk_stsd_idx, data_offset, trak->nb_samples_in_cache);\n\n\tif (is_final) {\n\t\tgf_free(chunk_data);\n\t\tgf_bs_del(trak->chunk_cache);\n\t\ttrak->chunk_cache = NULL;\n\t} else {\n\t\tgf_bs_reassign_buffer(trak->chunk_cache, chunk_data, chunk_alloc);\n\t}\n\treturn e;\n}\n\nstatic GF_Err trak_add_sample(GF_ISOFile *movie, GF_TrackBox *trak, const GF_ISOSample *sample, u32 descIndex, u64 data_offset, u32 syncShadowSampleNum)\n{\n\tBool skip_data = GF_FALSE;\n\tGF_Err e;\n\n\t//faststart mode with interleaving time, cache data until we have a full chunk\n\tif ((movie->storageMode==GF_ISOM_STORE_FASTSTART) && movie->interleavingTime) {\n\t\tBool flush_chunk = GF_FALSE;\n\t\tu64 stime = sample->DTS;\n\t\tstime *= movie->moov->mvhd->timeScale;\n\t\tstime /= trak->Media->mediaHeader->timeScale;\n\n\t\tif (stime - trak->first_dts_chunk > movie->interleavingTime)\n\t\t\tflush_chunk = GF_TRUE;\n\n\t\tif (movie->next_flush_chunk_time < stime)\n\t\t\tflush_chunk = GF_TRUE;\n\n\t\tif (trak->chunk_stsd_idx != descIndex)\n\t\t\tflush_chunk = GF_TRUE;\n\n\t\tif (trak->Media->information->sampleTable->MaxChunkSize && trak->Media->information->sampleTable->MaxChunkSize < trak->chunk_cache_size + sample->dataLength)\n\t\t\tflush_chunk = GF_TRUE;\n\n\t\tif (flush_chunk) {\n\t\t\tmovie->next_flush_chunk_time = stime + movie->interleavingTime;\n\t\t\tif (trak->chunk_cache) {\n\t\t\t\te = gf_isom_flush_chunk(trak, GF_FALSE);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\t\t\ttrak->nb_samples_in_cache = 0;\n\t\t\ttrak->chunk_cache_size = 0;\n\t\t\ttrak->first_dts_chunk = stime;\n\t\t}\n\t\tif (!trak->chunk_cache)\n\t\t\ttrak->chunk_cache = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\tgf_bs_write_data(trak->chunk_cache, sample->data, sample->dataLength);\n\t\ttrak->nb_samples_in_cache += sample->nb_pack ? sample->nb_pack : 1;\n\t\ttrak->chunk_cache_size += sample->dataLength;\n\t\ttrak->chunk_stsd_idx = descIndex;\n\n\t\tskip_data = GF_TRUE;\n\t}\n\n\te = Media_AddSample(trak->Media, data_offset, sample, descIndex, syncShadowSampleNum);\n\tif (e) return e;\n\n\tif (!skip_data && sample->dataLength) {\n\t\te = gf_isom_datamap_add_data(trak->Media->information->dataHandler, sample->data, sample->dataLength);\n\t\tif (e) return e;\n\t}\n\n\treturn GF_OK;\n}\n\n//Add samples to a track. Use streamDescriptionIndex to specify the desired stream (if several)\nGF_EXPORT\nGF_Err gf_isom_add_sample(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, const GF_ISOSample *sample)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tu32 dataRefIndex;\n\tu64 data_offset;\n\tu32 descIndex;\n\tGF_DataEntryURLBox *Dentry;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\te = FlushCaptureMode(movie);\n\tif (e) return e;\n\n\te = unpack_track(trak);\n\tif (e) return e;\n\n\t//OK, add the sample\n\t//1- Get the streamDescriptionIndex and dataRefIndex\n\t//not specified, get the latest used...\n\tdescIndex = StreamDescriptionIndex;\n\tif (!StreamDescriptionIndex) {\n\t\tdescIndex = trak->Media->information->sampleTable->currentEntryIndex;\n\t}\n\te = Media_GetSampleDesc(trak->Media, descIndex, &entry, &dataRefIndex);\n\tif (e) return e;\n\tif (!entry || !dataRefIndex) return GF_BAD_PARAM;\n\t//set the current to this one\n\ttrak->Media->information->sampleTable->currentEntryIndex = descIndex;\n\n\n\t//get this dataRef and return false if not self contained\n\tDentry = (GF_DataEntryURLBox*)gf_list_get(trak->Media->information->dataInformation->dref->child_boxes, dataRefIndex - 1);\n\tif (!Dentry || Dentry->flags != 1) return GF_BAD_PARAM;\n\n\t//Open our data map. We are adding stuff, so use EDIT\n\te = gf_isom_datamap_open(trak->Media, dataRefIndex, 1);\n\tif (e) return e;\n\n\t//Get the offset...\n\tdata_offset = gf_isom_datamap_get_offset(trak->Media->information->dataHandler);\n\n\t/*rewrite OD frame*/\n\tif (trak->Media->handler->handlerType == GF_ISOM_MEDIA_OD) {\n\t\tGF_ISOSample *od_sample = NULL;\n\n\t\te = Media_ParseODFrame(trak->Media, sample, &od_sample);\n\t\tif (e) return e;\n\n\t\te = trak_add_sample(movie, trak, od_sample, descIndex, data_offset, 0);\n\n\t\tif (od_sample)\n\t\t\tgf_isom_sample_del(&od_sample);\n\t} else {\n\t\te = trak_add_sample(movie, trak, sample, descIndex, data_offset, 0);\n\t}\n\tif (e) return e;\n\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\t//update media duration\n\tif ((s64)sample->DTS + sample->CTS_Offset>=0) {\n\t\tGF_TimeToSampleBox *stts = trak->Media->information->sampleTable->TimeToSample;\n\t\tu64 dur = sample->DTS + sample->CTS_Offset;\n\t\tdur += stts->entries[stts->nb_entries-1].sampleDelta;\n\n\t\tif (dur > trak->Media->mediaHeader->duration) {\n\t\t\ttrak->Media->mediaHeader->duration = dur;\n\t\t}\n\t}\n\t//do not update track duration yet, this is done on close\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_add_sample_shadow(GF_ISOFile *movie, u32 trackNumber, GF_ISOSample *sample)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_ISOSample *prev;\n\tGF_SampleEntryBox *entry;\n\tu32 dataRefIndex;\n\tu64 data_offset;\n\tu32 descIndex;\n\tu32 sampleNum, prevSampleNum;\n\tGF_DataEntryURLBox *Dentry;\n\tBool offset_times = GF_FALSE;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !sample) return GF_BAD_PARAM;\n\n\te = FlushCaptureMode(movie);\n\tif (e) return e;\n\n\te = unpack_track(trak);\n\tif (e) return e;\n\n\te = stbl_findEntryForTime(trak->Media->information->sampleTable, sample->DTS, 0, &sampleNum, &prevSampleNum);\n\tif (e) return e;\n\t/*we need the EXACT match*/\n\tif (!sampleNum) return GF_BAD_PARAM;\n\n\tprev = gf_isom_get_sample_info(movie, trackNumber, sampleNum, &descIndex, NULL);\n\tif (!prev) return gf_isom_last_error(movie);\n\t/*for conformance*/\n\tif (sample->DTS==prev->DTS) offset_times = GF_TRUE;\n\tgf_isom_sample_del(&prev);\n\n\te = Media_GetSampleDesc(trak->Media, descIndex, &entry, &dataRefIndex);\n\tif (e) return e;\n\tif (!entry || !dataRefIndex) return GF_BAD_PARAM;\n\ttrak->Media->information->sampleTable->currentEntryIndex = descIndex;\n\n\t//get this dataRef and return false if not self contained\n\tDentry = (GF_DataEntryURLBox*)gf_list_get(trak->Media->information->dataInformation->dref->child_boxes, dataRefIndex - 1);\n\tif (!Dentry || Dentry->flags != 1) return GF_BAD_PARAM;\n\n\t//Open our data map. We are adding stuff, so use EDIT\n\te = gf_isom_datamap_open(trak->Media, dataRefIndex, 1);\n\tif (e) return e;\n\n\tdata_offset = gf_isom_datamap_get_offset(trak->Media->information->dataHandler);\n\tif (offset_times) sample->DTS += 1;\n\n\t/*REWRITE ANY OD STUFF*/\n\tif (trak->Media->handler->handlerType == GF_ISOM_MEDIA_OD) {\n\t\tGF_ISOSample *od_sample = NULL;\n\t\te = Media_ParseODFrame(trak->Media, sample, &od_sample);\n\t\tif (e) return e;\n\n\t\te = trak_add_sample(movie, trak, od_sample, descIndex, data_offset, sampleNum);\n\t\tif (od_sample)\n\t\t\tgf_isom_sample_del(&od_sample);\n\t} else {\n\t\te = trak_add_sample(movie, trak, sample, descIndex, data_offset, sampleNum);\n\t}\n\tif (e) return e;\n\tif (offset_times) sample->DTS -= 1;\n\n\t//OK, update duration\n\te = Media_SetDuration(trak);\n\tif (e) return e;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\treturn SetTrackDuration(trak);\n}\n\nGF_EXPORT\nGF_Err gf_isom_append_sample_data(GF_ISOFile *movie, u32 trackNumber, u8 *data, u32 data_size)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tu32 dataRefIndex;\n\tu32 descIndex;\n\tGF_DataEntryURLBox *Dentry;\n\n\tif (!data_size) return GF_OK;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tif (trak->Media->handler->handlerType == GF_ISOM_MEDIA_OD) return GF_BAD_PARAM;\n\n\t//OK, add the sample\n\tdescIndex = trak->Media->information->sampleTable->currentEntryIndex;\n\n\te = Media_GetSampleDesc(trak->Media, descIndex, &entry, &dataRefIndex);\n\tif (e) return e;\n\tif (!entry || !dataRefIndex) return GF_BAD_PARAM;\n\n\t//get this dataRef and return false if not self contained\n\tDentry = (GF_DataEntryURLBox*)gf_list_get(trak->Media->information->dataInformation->dref->child_boxes, dataRefIndex - 1);\n\tif (!Dentry || Dentry->flags != 1) return GF_BAD_PARAM;\n\n\t//Open our data map. We are adding stuff, so use EDIT\n\te = gf_isom_datamap_open(trak->Media, dataRefIndex, 1);\n\tif (e) return e;\n\n\t//add the media data\n\tif (trak->chunk_cache) {\n\t\tgf_bs_write_data(trak->chunk_cache, data, data_size);\n\t\ttrak->chunk_cache_size += data_size;\n\t} else {\n\t\te = gf_isom_datamap_add_data(trak->Media->information->dataHandler, data, data_size);\n\t\tif (e) return e;\n\t}\n\t//update data size\n\treturn stbl_SampleSizeAppend(trak->Media->information->sampleTable->SampleSize, data_size);\n}\n\n\n//Add sample reference to a track. The SampleOffset is the offset of the data in the referenced file\n//you must have created a StreamDescription with URL or URN specifying your referenced file\n//the data offset specifies the beginning of the chunk\n//Use streamDescriptionIndex to specify the desired stream (if several)\nGF_EXPORT\nGF_Err gf_isom_add_sample_reference(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, GF_ISOSample *sample, u64 dataOffset)\n{\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tu32 dataRefIndex;\n\tu32 descIndex;\n\tGF_DataEntryURLBox *Dentry;\n\tGF_Err e;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\te = unpack_track(trak);\n\tif (e) return e;\n\n\t//OD is not allowed as a data ref\n\tif (trak->Media->handler->handlerType == GF_ISOM_MEDIA_OD) {\n\t\treturn GF_BAD_PARAM;\n\t}\n\t//OK, add the sample\n\t//1- Get the streamDescriptionIndex and dataRefIndex\n\t//not specified, get the latest used...\n\tdescIndex = StreamDescriptionIndex;\n\tif (!StreamDescriptionIndex) {\n\t\tdescIndex = trak->Media->information->sampleTable->currentEntryIndex;\n\t}\n\te = Media_GetSampleDesc(trak->Media, descIndex, &entry, &dataRefIndex);\n\tif (e) return e;\n\tif (!entry || !dataRefIndex) return GF_BAD_PARAM;\n\t//set the current to this one\n\ttrak->Media->information->sampleTable->currentEntryIndex = descIndex;\n\n\n\t//get this dataRef and return false if self contained\n\tDentry =(GF_DataEntryURLBox*) gf_list_get(trak->Media->information->dataInformation->dref->child_boxes, dataRefIndex - 1);\n\tif (Dentry->flags == 1) return GF_BAD_PARAM;\n\n\t//add the meta data\n\te = Media_AddSample(trak->Media, dataOffset, sample, descIndex, 0);\n\tif (e) return e;\n\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\t//OK, update duration\n\te = Media_SetDuration(trak);\n\tif (e) return e;\n\treturn SetTrackDuration(trak);\n\n}\n\n//set the duration of the last media sample. If not set, the duration of the last sample is the\n//duration of the previous one if any, or 1000 (default value).\nstatic GF_Err gf_isom_set_last_sample_duration_internal(GF_ISOFile *movie, u32 trackNumber, u64 dur_num, u32 dur_den, u32 mode)\n{\n\tGF_TrackBox *trak;\n\tGF_SttsEntry *ent;\n\tGF_TimeToSampleBox *stts;\n\tu64 mdur;\n\tu32 duration;\n\tGF_Err e;\n\tBool is_patch = GF_FALSE;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tif (mode==0) {\n\t\tduration = (u32) dur_num;\n\t} else if (mode==1) {\n\t\tduration = (u32) dur_num;\n\t\tif (dur_den) {\n\t\t\tduration *= trak->Media->mediaHeader->timeScale;\n\t\t\tduration /= dur_den;\n\t\t}\n\t} else {\n\t\tis_patch = GF_TRUE;\n\t}\n\tmdur = trak->Media->mediaHeader->duration;\n\tstts = trak->Media->information->sampleTable->TimeToSample;\n\tif (!stts->nb_entries) return GF_BAD_PARAM;\n\n\tif (is_patch) {\n\t\tu32 i, avg_dur, nb_samp=0;\n\t\tu64 cum_dur=0;\n\t\tfor (i=0; i<stts->nb_entries; i++) {\n\t\t\tent = (GF_SttsEntry*) &stts->entries[i];\n\t\t\tcum_dur += ent->sampleCount*ent->sampleDelta;\n\t\t\tnb_samp += ent->sampleCount;\n\t\t}\n\t\tif (cum_dur <= dur_num || !nb_samp) return GF_OK;\n\t\tavg_dur = (u32) (dur_num / nb_samp);\n\n\t\tstts->entries[0].sampleDelta = avg_dur;\n\t\tstts->entries[0].sampleCount = nb_samp;\n\t\tstts->nb_entries = 1;\n\t\tstts->w_LastDTS = dur_num - avg_dur;\n\t\treturn GF_OK;\n\t}\n\t//get the last entry\n\tent = (GF_SttsEntry*) &stts->entries[stts->nb_entries-1];\n\tif ((mode==1) && !duration && !dur_den) {\n\t\t//same as previous, nothing to adjust\n\t\tif (ent->sampleCount>1) return GF_OK;\n\t\tif (stts->nb_entries==1) return GF_OK;\n\t\tduration = stts->entries[stts->nb_entries-2].sampleDelta;\n\t}\n\n\tmdur -= ent->sampleDelta;\n\tmdur += duration;\n\n\t//we only have one sample\n\tif (ent->sampleCount == 1) {\n\t\tent->sampleDelta = (u32) duration;\n\t\tif (mode && (stts->nb_entries>1) && (stts->entries[stts->nb_entries-2].sampleDelta==duration)) {\n\t\t\tstts->entries[stts->nb_entries-2].sampleCount++;\n\t\t\tstts->nb_entries--;\n\t\t\t//and update the write cache\n\t\t\tstts->w_currentSampleNum = trak->Media->information->sampleTable->SampleSize->sampleCount;\n\t\t}\n\t} else {\n\t\tif (ent->sampleDelta == duration) return GF_OK;\n\t\tent->sampleCount -= 1;\n\n\t\tif (stts->nb_entries==stts->alloc_size) {\n\t\t\tstts->alloc_size++;\n\t\t\tstts->entries = (GF_SttsEntry*)gf_realloc(stts->entries, sizeof(GF_SttsEntry)*stts->alloc_size);\n\t\t\tif (!stts->entries) return GF_OUT_OF_MEM;\n\t\t}\n\t\tstts->entries[stts->nb_entries].sampleCount = 1;\n\t\tstts->entries[stts->nb_entries].sampleDelta = (u32) duration;\n\t\tstts->nb_entries++;\n\t\t//and update the write cache\n\t\tstts->w_currentSampleNum = trak->Media->information->sampleTable->SampleSize->sampleCount;\n\t}\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\t//update media duration if duration was set\n\tif (trak->Media->mediaHeader->duration)\n\t\ttrak->Media->mediaHeader->duration = mdur;\n\t//do not update track duration yet, this is done on close\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_last_sample_duration(GF_ISOFile *movie, u32 trackNumber, u32 duration)\n{\n\treturn gf_isom_set_last_sample_duration_internal(movie, trackNumber, duration, 0, 0);\n}\n\nGF_EXPORT\nGF_Err gf_isom_patch_last_sample_duration(GF_ISOFile *movie, u32 trackNumber, u64 next_dts)\n{\n\treturn gf_isom_set_last_sample_duration_internal(movie, trackNumber, next_dts, 0, 2);\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_last_sample_duration_ex(GF_ISOFile *movie, u32 trackNumber, u32 dur_num, u32 dur_den)\n{\n\treturn gf_isom_set_last_sample_duration_internal(movie, trackNumber, dur_num, dur_den, 1);\n}\n\n//update a sample data in the media. Note that the sample MUST exists\nGF_EXPORT\nGF_Err gf_isom_update_sample(GF_ISOFile *movie, u32 trackNumber, u32 sampleNumber, GF_ISOSample *sample, Bool data_only)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_EDIT);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\te = unpack_track(trak);\n\tif (e) return e;\n\n\t//block for hint tracks\n\tif (trak->Media->handler->handlerType == GF_ISOM_MEDIA_HINT) return GF_BAD_PARAM;\n\n\t//REWRITE ANY OD STUFF\n\tif (trak->Media->handler->handlerType == GF_ISOM_MEDIA_OD) {\n\t\tGF_ISOSample *od_sample = NULL;\n\t\te = Media_ParseODFrame(trak->Media, sample, &od_sample);\n\t\tif (!e) e = Media_UpdateSample(trak->Media, sampleNumber, od_sample, data_only);\n\t\tif (od_sample) gf_isom_sample_del(&od_sample);\n\t} else {\n\t\te = Media_UpdateSample(trak->Media, sampleNumber, sample, data_only);\n\t}\n\tif (e) return e;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tgf_isom_disable_inplace_rewrite(movie);\n\treturn GF_OK;\n}\n\n//update a sample data in the media. Note that the sample MUST exists,\n//that sample->data MUST be NULL and sample->dataLength must be NON NULL;\nGF_EXPORT\nGF_Err gf_isom_update_sample_reference(GF_ISOFile *movie, u32 trackNumber, u32 sampleNumber, GF_ISOSample *sample, u64 data_offset)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_EDIT);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\t//block for hint tracks\n\tif (trak->Media->handler->handlerType == GF_ISOM_MEDIA_HINT) return GF_BAD_PARAM;\n\n\tif (!sampleNumber || !sample) return GF_BAD_PARAM;\n\n\te = unpack_track(trak);\n\tif (e) return e;\n\n\t//OD is not allowed as a data ref\n\tif (trak->Media->handler->handlerType == GF_ISOM_MEDIA_OD) {\n\t\treturn GF_BAD_PARAM;\n\t}\n\t//OK, update it\n\te = Media_UpdateSampleReference(trak->Media, sampleNumber, sample, data_offset);\n\tif (e) return e;\n\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\treturn GF_OK;\n}\n\n//for gf_isom_remove_sample and gf_isom_remove_track: check all items sharing their data with a sample being removed\n//and remove sharing flag\n// sample_number can be 0 for complete track removal\nstatic void gf_isom_meta_track_remove(GF_ISOFile *movie, GF_TrackBox *trak, u32 sample_number)\n{\n\tu32 i, count;\n\tif (!movie || !movie->meta || !movie->meta->use_item_sample_sharing)\n\t\treturn;\n\n\tcount = gf_list_count(movie->meta->item_locations->location_entries);\n\tfor (i=0; i<count; i++) {\n\t\tu32 j;\n\t\tGF_ItemLocationEntry *iloc = (GF_ItemLocationEntry *)gf_list_get(movie->meta->item_locations->location_entries, i);\n\t\t/*get item info*/\n\t\tGF_ItemInfoEntryBox *iinf = NULL;\n\t\tj=0;\n\t\twhile ((iinf = (GF_ItemInfoEntryBox *)gf_list_enum(movie->meta->item_infos->item_infos, &j))) {\n\t\t\tif (iinf->item_ID==iloc->item_ID) break;\n\t\t}\n\t\tif (!iinf || !iinf->tk_id) continue;\n\t\tif (iinf->tk_id != trak->Header->trackID) continue;\n\n\t\tif (sample_number && (iinf->sample_num != sample_number)) continue;\n\t\tiinf->tk_id = 0;\n\t\tiinf->sample_num = 0;\n\t}\n}\n\n\n\n//Remove a given sample\nGF_EXPORT\nGF_Err gf_isom_remove_sample(GF_ISOFile *movie, u32 trackNumber, u32 sampleNumber)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_EDIT);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !sampleNumber || (sampleNumber > trak->Media->information->sampleTable->SampleSize->sampleCount) )\n\t\treturn GF_BAD_PARAM;\n\n\t//block for hint tracks\n\tif (trak->Media->handler->handlerType == GF_ISOM_MEDIA_HINT) return GF_BAD_PARAM;\n\n\te = unpack_track(trak);\n\tif (e) return e;\n\t//do NOT change the order DTS, CTS, size chunk\n\n\t//remove DTS\n\te = stbl_RemoveDTS(trak->Media->information->sampleTable, sampleNumber, 1, trak->Media->mediaHeader->timeScale);\n\tif (e) return e;\n\t//remove CTS if any\n\tif (trak->Media->information->sampleTable->CompositionOffset) {\n\t\te = stbl_RemoveCTS(trak->Media->information->sampleTable, sampleNumber, 1);\n\t\tif (e) return e;\n\t}\n\t//remove size\n\te = stbl_RemoveSize(trak->Media->information->sampleTable, sampleNumber, 1);\n\tif (e) return e;\n\t//remove sampleToChunk and chunk\n\te = stbl_RemoveChunk(trak->Media->information->sampleTable, sampleNumber, 1);\n\tif (e) return e;\n\t//remove sync\n\tif (trak->Media->information->sampleTable->SyncSample) {\n\t\te = stbl_RemoveRAP(trak->Media->information->sampleTable, sampleNumber);\n\t\tif (e) return e;\n\t}\n\t//remove sample dep\n\tif (trak->Media->information->sampleTable->SampleDep) {\n\t\te = stbl_RemoveRedundant(trak->Media->information->sampleTable, sampleNumber, 1);\n\t\tif (e) return e;\n\t}\n\t//remove shadow\n\te = stbl_RemoveShadow(trak->Media->information->sampleTable, sampleNumber);\n\tif (e) return e;\n\n\t//remove padding\n\te = stbl_RemovePaddingBits(trak->Media->information->sampleTable, sampleNumber);\n\tif (e) return e;\n\n\te = stbl_RemoveSubSample(trak->Media->information->sampleTable, sampleNumber);\n\tif (e) return e;\n\n\te = stbl_RemoveSampleGroup(trak->Media->information->sampleTable, sampleNumber);\n\tif (e) return e;\n\n\tgf_isom_disable_inplace_rewrite(movie);\n\n\tgf_isom_meta_track_remove(movie, trak, sampleNumber);\n\n\treturn SetTrackDuration(trak);\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_set_final_name(GF_ISOFile *movie, char *filename)\n{\n\tGF_Err e;\n\tif (!movie ) return GF_BAD_PARAM;\n\n\t//if mode is not OPEN_EDIT file was created under the right name\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_EDIT);\n\tif (e) return e;\n\n\tif (filename) {\n\t\t//we don't allow file overwriting\n\t\tif ( (movie->openMode == GF_ISOM_OPEN_EDIT)\n\t\t        && movie->fileName && !strcmp(filename, movie->fileName))\n\t\t\treturn GF_BAD_PARAM;\n\t\tif (movie->finalName) gf_free(movie->finalName);\n\t\tmovie->finalName = gf_strdup(filename);\n\t\tif (!movie->finalName) return GF_OUT_OF_MEM;\n\t\tgf_isom_disable_inplace_rewrite(movie);\n\t}\n\treturn GF_OK;\n}\n\n//Add a system descriptor to the ESD of a stream(EDIT or WRITE mode only)\nGF_EXPORT\nGF_Err gf_isom_add_desc_to_description(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, const GF_Descriptor *theDesc)\n{\n\tGF_IPIPtr *ipiD;\n\tGF_Err e;\n\tu16 tmpRef;\n\tGF_TrackBox *trak;\n\tGF_Descriptor *desc;\n\tGF_ESD *esd;\n\tGF_TrackReferenceBox *tref;\n\tGF_TrackReferenceTypeBox *dpnd;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\tu32 msubtype;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\t/*GETS NATIVE DESCRIPTOR ONLY*/\n\te = Media_GetESD(trak->Media, StreamDescriptionIndex, &esd, GF_TRUE);\n\tif (e) return e;\n\n\tentry = gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, StreamDescriptionIndex-1);\n\tif (!entry) return GF_BAD_PARAM;\n\tmsubtype = entry->type;\n\tif ((msubtype==GF_ISOM_BOX_TYPE_ENCV) || (msubtype==GF_ISOM_BOX_TYPE_ENCA))\n\t\tgf_isom_get_original_format_type(movie, trackNumber, StreamDescriptionIndex, &msubtype);\n\n\t//duplicate the desc\n\te = gf_odf_desc_copy((GF_Descriptor *)theDesc, &desc);\n\tif (e) return e;\n\n\t//and add it to the ESD EXCEPT IPI PTR (we need to translate from ES_ID to TrackID!!!\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tswitch (desc->tag) {\n\tcase GF_ODF_IPI_PTR_TAG:\n\t\tgoto insertIPI;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif ((msubtype==GF_ISOM_BOX_TYPE_MP4S) || (msubtype==GF_ISOM_BOX_TYPE_MP4V) || (msubtype==GF_ISOM_BOX_TYPE_MP4A)) {\n\t\treturn gf_odf_desc_add_desc((GF_Descriptor *)esd, desc);\n\t}\n\n\tif (trak->Media->handler->handlerType!=GF_ISOM_MEDIA_VISUAL) {\n\t\tgf_odf_desc_del(desc);\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\tGF_MPEG4ExtensionDescriptorsBox *mdesc = (GF_MPEG4ExtensionDescriptorsBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_M4DS);\n\tif (!mdesc) {\n\t\tmdesc = (GF_MPEG4ExtensionDescriptorsBox *) gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_M4DS);\n\t}\n\treturn gf_list_add(mdesc->descriptors, desc);\n\ninsertIPI:\n\tif (esd->ipiPtr) {\n\t\tgf_odf_desc_del((GF_Descriptor *) esd->ipiPtr);\n\t\tesd->ipiPtr = NULL;\n\t}\n\n\tipiD = (GF_IPIPtr *) desc;\n\t//find a tref\n\tif (!trak->References) {\n\t\ttref = (GF_TrackReferenceBox *) gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_TREF);\n\t\tif (!tref) return GF_OUT_OF_MEM;\n\t\te = trak_on_child_box((GF_Box*)trak, (GF_Box *)tref, GF_FALSE);\n\t\tif (e) return e;\n\t}\n\ttref = trak->References;\n\n\te = Track_FindRef(trak, GF_ISOM_REF_IPI, &dpnd);\n\tif (e) return e;\n\tif (!dpnd) {\n\t\ttmpRef = 0;\n\t\tdpnd = (GF_TrackReferenceTypeBox *) gf_isom_box_new_parent(&tref->child_boxes, GF_ISOM_BOX_TYPE_REFT);\n\t\tif (!dpnd) return GF_OUT_OF_MEM;\n\t\tdpnd->reference_type = GF_ISOM_BOX_TYPE_IPIR;\n\t\te = reftype_AddRefTrack(dpnd, ipiD->IPI_ES_Id, &tmpRef);\n\t\tif (e) return e;\n\t\t//and replace the tag and value...\n\t\tipiD->IPI_ES_Id = tmpRef;\n\t\tipiD->tag = GF_ODF_ISOM_IPI_PTR_TAG;\n\t} else {\n\t\t//Watch out! ONLY ONE IPI dependency is allowed per stream\n\t\tdpnd->trackIDCount = 1;\n\t\tdpnd->trackIDs[0] = ipiD->IPI_ES_Id;\n\t\t//and replace the tag and value...\n\t\tipiD->IPI_ES_Id = 1;\n\t\tipiD->tag = GF_ODF_ISOM_IPI_PTR_TAG;\n\t}\n\t//and add the desc to the esd...\n\treturn gf_odf_desc_add_desc((GF_Descriptor *)esd, desc);\n}\n\n\n//use carefully. Very useful when you made a lot of changes (IPMP, IPI, OCI, ...)\n//THIS WILL REPLACE THE WHOLE DESCRIPTOR ...\nGF_EXPORT\nGF_Err gf_isom_change_mpeg4_description(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, const GF_ESD *newESD)\n{\n\tGF_Err e;\n\tGF_ESD *esd;\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn movie->LastError = GF_BAD_PARAM;\n\t}\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\t//duplicate our desc\n\te = gf_odf_desc_copy((GF_Descriptor *)newESD, (GF_Descriptor **)&esd);\n\tif (e) return e;\n\te = Track_SetStreamDescriptor(trak, StreamDescriptionIndex, entry->dataReferenceIndex, esd, NULL);\n\tif (e != GF_OK) {\n\t\tgf_odf_desc_del((GF_Descriptor *) esd);\n\t}\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_visual_info(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, u32 Width, u32 Height)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) {\n\t\treturn movie->LastError = GF_ISOM_INVALID_FILE;\n\t}\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn movie->LastError = GF_BAD_PARAM;\n\t}\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\t//valid for MPEG visual, JPG and 3GPP H263\n\tif (entry->internal_type == GF_ISOM_SAMPLE_ENTRY_VIDEO) {\n\t\t((GF_VisualSampleEntryBox*)entry)->Width = Width;\n\t\t((GF_VisualSampleEntryBox*)entry)->Height = Height;\n\t\ttrak->Header->width = Width<<16;\n\t\ttrak->Header->height = Height<<16;\n\t\treturn GF_OK;\n\t} else if (trak->Media->handler->handlerType==GF_ISOM_MEDIA_SCENE) {\n\t\ttrak->Header->width = Width<<16;\n\t\ttrak->Header->height = Height<<16;\n\t\treturn GF_OK;\n\t} else {\n\t\treturn GF_BAD_PARAM;\n\t}\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_visual_bit_depth(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, u16 bitDepth)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tswitch (trak->Media->handler->handlerType) {\n\tcase GF_ISOM_MEDIA_VISUAL:\n\tcase GF_ISOM_MEDIA_PICT:\n\tcase GF_ISOM_MEDIA_AUXV:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_OK;\n\t}\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) {\n\t\treturn movie->LastError = GF_ISOM_INVALID_FILE;\n\t}\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn movie->LastError = GF_BAD_PARAM;\n\t}\n\tentry = (GF_MPEGVisualSampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\tentry->bit_depth = bitDepth;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_pixel_aspect_ratio(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, s32 hSpacing, s32 vSpacing, Bool force_par)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn movie->LastError = GF_BAD_PARAM;\n\t}\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return GF_BAD_PARAM;\n\n\tif (hSpacing<0) hSpacing = 1;\n\tif (vSpacing<0) vSpacing = 1;\n\n\tGF_PixelAspectRatioBox *pasp = (GF_PixelAspectRatioBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_PASP);\n\tif (!hSpacing || !vSpacing || ((hSpacing == vSpacing) && !force_par))  {\n\t\tif (pasp) gf_isom_box_del_parent(&entry->child_boxes, (GF_Box *)pasp);\n\t\treturn GF_OK;\n\t}\n\tif (!pasp) {\n\t\tpasp = (GF_PixelAspectRatioBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_PASP);\n\t\tif (!pasp) return GF_OUT_OF_MEM;\n\t}\n\tpasp->hSpacing = (u32) hSpacing;\n\tpasp->vSpacing = (u32) vSpacing;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_visual_color_info(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, u32 colour_type, u16 colour_primaries, u16 transfer_characteristics, u16 matrix_coefficients, Bool full_range_flag, u8 *icc_data, u32 icc_size)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\tGF_ColourInformationBox *clr=NULL;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn movie->LastError = GF_BAD_PARAM;\n\t}\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return GF_OK;\n\n\tclr = (GF_ColourInformationBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_COLR);\n\tif (!colour_type) {\n\t\tif (clr) gf_isom_box_del_parent(&entry->child_boxes, (GF_Box *)clr);\n\t\treturn GF_OK;\n\t}\n\tif (clr) {\n\t\t//create another color box\n\t\tif (clr->opaque && !icc_data) clr = NULL;\n\t\telse if (!clr->opaque && icc_data) clr = NULL;\n\t}\n\n\tif (!clr) {\n\t\tclr = (GF_ColourInformationBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_COLR);\n\t\tif (!clr) return GF_OUT_OF_MEM;\n\t}\n\tclr->colour_type = colour_type;\n\tclr->colour_primaries = colour_primaries;\n\tclr->transfer_characteristics = transfer_characteristics;\n\tclr->matrix_coefficients = matrix_coefficients;\n\tclr->full_range_flag = full_range_flag;\n\tif (clr->opaque) gf_free(clr->opaque);\n\tclr->opaque = NULL;\n\tclr->opaque_size = 0;\n\tif ((colour_type==GF_ISOM_SUBTYPE_RICC) || (colour_type==GF_ISOM_SUBTYPE_PROF)) {\n\t\tclr->opaque_size = icc_data ? icc_size : 0;\n\t\tif (clr->opaque_size) {\n\t\t\tclr->opaque = gf_malloc(sizeof(char)*clr->opaque_size);\n\t\t\tif (!clr->opaque) return GF_OUT_OF_MEM;\n\t\t\tmemcpy(clr->opaque, icc_data, sizeof(char)*clr->opaque_size);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_dolby_vision_profile(GF_ISOFile* movie, u32 trackNumber, u32 StreamDescriptionIndex, GF_DOVIDecoderConfigurationRecord *dvcc)\n{\n\tGF_Err e;\n\tGF_TrackBox* trak;\n\tGF_Box *dv_cfge = NULL;\n\tGF_MPEGVisualSampleEntryBox* entry;\n\tBool switch_type = GF_FALSE;\n\tBool is_avc = GF_FALSE;\n\tGF_SampleDescriptionBox* stsd;\n\tGF_DOVIConfigurationBox* dovi = NULL;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn movie->LastError = GF_BAD_PARAM;\n\t}\n\tentry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return GF_OK;\n\n\tif (dvcc) {\n\t\tswitch_type = dvcc->force_dv;\n\t\tswitch (dvcc->dv_profile) {\n\t\tcase 1:\n\t\tcase 3:\n\t\tcase 5:\n\t\t\tswitch_type = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (entry->type) {\n\tcase GF_ISOM_BOX_TYPE_HEV1:\n\tcase GF_ISOM_BOX_TYPE_HEV2:\n\tcase GF_ISOM_BOX_TYPE_DVHE:\n\t\tentry->type = switch_type ? GF_ISOM_BOX_TYPE_DVHE : GF_ISOM_BOX_TYPE_HEV1;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_HVC1:\n\tcase GF_ISOM_BOX_TYPE_HVC2:\n\tcase GF_ISOM_BOX_TYPE_DVH1:\n\t\tentry->type = switch_type ? GF_ISOM_BOX_TYPE_DVH1 : GF_ISOM_BOX_TYPE_HVC1;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_AVC1:\n\tcase GF_ISOM_BOX_TYPE_DVA1:\n\t\tis_avc = GF_TRUE;\n\t\tentry->type = switch_type ? GF_ISOM_BOX_TYPE_DVA1 : GF_ISOM_BOX_TYPE_AVC1;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_AVC3:\n\tcase GF_ISOM_BOX_TYPE_DVAV:\n\t\tis_avc = GF_TRUE;\n\t\tentry->type = switch_type ? GF_ISOM_BOX_TYPE_DVAV : GF_ISOM_BOX_TYPE_AVC3;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_AV01:\n\tcase GF_ISOM_BOX_TYPE_DAV1:\n\t\tentry->type = switch_type ? GF_ISOM_BOX_TYPE_DAV1 : GF_ISOM_BOX_TYPE_AV01;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\n\tu32 dve_type = is_avc ? GF_ISOM_BOX_TYPE_AVCE : GF_ISOM_BOX_TYPE_HVCE;\n\tdv_cfge = gf_isom_box_find_child(entry->child_boxes, dve_type);\n\n\tdovi = entry->dovi_config;\n\tif (!dvcc) {\n\t\tif (dovi) gf_isom_box_del_parent(&entry->child_boxes, (GF_Box*)dovi);\n\t\tentry->dovi_config = NULL;\n\n\t\tif (dv_cfge) gf_isom_box_del_parent(&entry->child_boxes, dv_cfge);\n\t\t//reverse entry type\n\t\tswitch (entry->type) {\n\t\tcase GF_ISOM_BOX_TYPE_DVHE:\n\t\t\tentry->type = GF_ISOM_BOX_TYPE_HEV1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_DVH1:\n\t\t\tentry->type = GF_ISOM_BOX_TYPE_HVC1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_DVA1:\n\t\t\tentry->type = GF_ISOM_BOX_TYPE_AVC1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_DVAV:\n\t\t\tentry->type = GF_ISOM_BOX_TYPE_AVC3;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_DAV1:\n\t\t\tentry->type = GF_ISOM_BOX_TYPE_AV01;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\tif (!dovi) {\n\t\tdovi = (GF_DOVIConfigurationBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_DVCC);\n\t\tif (!dovi) return GF_OUT_OF_MEM;\n\t\tentry->dovi_config = dovi;\n\t}\n\tif (dvcc->dv_profile < 8) {\n\t\tdovi->type = GF_ISOM_BOX_TYPE_DVCC;\n\t} else {\n\t\tdovi->type = GF_ISOM_BOX_TYPE_DVVC;\n\t}\n\tdovi->DOVIConfig = *dvcc;\n\n\tif (dv_cfge) gf_isom_box_del_parent(&entry->child_boxes, dv_cfge);\n\tdv_cfge = NULL;\n\n\t//inject avcE / hvcE if enhancement layer and RPU present in single-track case\n\t//not clear from the spec what is supposed to be in these, we just clone avcC/hvcC\n\tif (dvcc->bl_present_flag && dvcc->el_present_flag && dvcc->rpu_present_flag) {\n\t\tGF_Box *src = is_avc ? (GF_Box *)entry->avc_config : (GF_Box *)entry->hevc_config;\n\t\tif (!src) return GF_BAD_PARAM;\n\t\te = gf_isom_clone_box(src, &dv_cfge);\n\t\tif (e) return e;\n\t\tdv_cfge->type = dve_type;\n\t\tgf_list_add(entry->child_boxes, dv_cfge);\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_high_dynamic_range_info(GF_ISOFile* movie, u32 trackNumber, u32 StreamDescriptionIndex, GF_MasteringDisplayColourVolumeInfo* mdcv, GF_ContentLightLevelInfo* clli)\n{\n\tGF_Err e;\n\tGF_TrackBox* trak;\n\tGF_SampleEntryBox* entry;\n\tGF_SampleDescriptionBox* stsd;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn movie->LastError = GF_BAD_PARAM;\n\t}\n\tentry = (GF_SampleEntryBox*)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return GF_BAD_PARAM;\n\n\tGF_MasteringDisplayColourVolumeBox *mdcvb = (GF_MasteringDisplayColourVolumeBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_MDCV);\n\tif (mdcv) {\n\t\tif (!mdcvb) {\n\t\t\tmdcvb = (GF_MasteringDisplayColourVolumeBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_MDCV);\n\t\t\tif (!mdcvb) return GF_OUT_OF_MEM;\n\t\t}\n\t\tmdcvb->mdcv = *mdcv;\n\t} else {\n\t\tif (mdcvb) gf_isom_box_del_parent(&entry->child_boxes, (GF_Box *) mdcvb);\n\t}\n\n\t/*clli*/\n\tGF_ContentLightLevelBox *cllib = (GF_ContentLightLevelBox *)gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_CLLI);\n\tif (clli) {\n\t\tif (!cllib) {\n\t\t\tcllib = (GF_ContentLightLevelBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_CLLI);\n\t\t\tif (!cllib) return GF_OUT_OF_MEM;\n\t\t}\n\t\tcllib->clli = *clli;\n\t} else {\n\t\tif (cllib) gf_isom_box_del_parent(&entry->child_boxes, (GF_Box *) cllib);\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_clean_aperture(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, u32 cleanApertureWidthN, u32 cleanApertureWidthD, u32 cleanApertureHeightN, u32 cleanApertureHeightD, s32 horizOffN, u32 horizOffD, s32 vertOffN, u32 vertOffD)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn movie->LastError = GF_BAD_PARAM;\n\t}\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return GF_BAD_PARAM;\n\n\tGF_CleanApertureBox *clap = (GF_CleanApertureBox *)gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_CLAP);\n\tif (!cleanApertureHeightD || !cleanApertureWidthD || !horizOffD || !vertOffD) {\n\t\tif (clap) gf_isom_box_del_parent(&entry->child_boxes, (GF_Box*)clap);\n\t\treturn GF_OK;\n\t}\n\tif (!clap) {\n\t\tclap = (GF_CleanApertureBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_CLAP);\n\t\tif (!clap) return GF_OUT_OF_MEM;\n\t}\n\n\tclap->cleanApertureWidthN = cleanApertureWidthN;\n\tclap->cleanApertureWidthD = cleanApertureWidthD;\n\tclap->cleanApertureHeightN = cleanApertureHeightN;\n\tclap->cleanApertureHeightD = cleanApertureHeightD;\n\tclap->horizOffN = horizOffN;\n\tclap->horizOffD = horizOffD;\n\tclap->vertOffN = vertOffN;\n\tclap->vertOffD = vertOffD;\n\treturn GF_OK;\n}\n\n#include <gpac/maths.h>\nGF_Err gf_isom_update_aperture_info(GF_ISOFile *movie, u32 trackNumber, Bool remove)\n{\n\tGF_Err e;\n\tGF_Box *box, *enof, *prof, *clef;\n\tGF_TrackBox *trak;\n\tGF_VisualSampleEntryBox *ventry;\n\tGF_PixelAspectRatioBox *pasp;\n\tGF_CleanApertureBox *clap;\n\tu32 j, hspacing, vspacing, clap_width_num, clap_width_den, clap_height_num, clap_height_den, high, low;\n\tDouble width, height;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tif (remove) {\n\t\tif (trak->Aperture) {\n\t\t\tgf_isom_box_del(trak->Aperture);\n\t\t\ttrak->Aperture = NULL;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\tenof = prof = clef = NULL;\n\tif (!trak->Aperture) {\n\t\ttrak->Aperture = gf_isom_box_new_parent(&trak->child_boxes, GF_QT_BOX_TYPE_TAPT);\n\t\tif (!trak->Aperture) return GF_OUT_OF_MEM;\n\t}\n\tif (!trak->Aperture->child_boxes) {\n\t\ttrak->Aperture->child_boxes = gf_list_new();\n\t\tif (!trak->Aperture->child_boxes)\n\t\t\treturn GF_OUT_OF_MEM;\n\t}\n\n\tj=0;\n\twhile ( (box = gf_list_enum(trak->Aperture->child_boxes, &j))) {\n\t\tswitch (box->type) {\n\t\tcase GF_QT_BOX_TYPE_CLEF: clef = box; break;\n\t\tcase GF_QT_BOX_TYPE_PROF: prof = box; break;\n\t\tcase GF_QT_BOX_TYPE_ENOF: enof = box; break;\n\t\t}\n\t}\n\tif (!clef) {\n\t\tclef = gf_isom_box_new(GF_QT_BOX_TYPE_CLEF);\n\t\tif (!clef) return GF_OUT_OF_MEM;\n\t\tgf_list_add(trak->Aperture->child_boxes, clef);\n\t}\n\tif (!enof) {\n\t\tenof = gf_isom_box_new(GF_QT_BOX_TYPE_ENOF);\n\t\tif (!enof) return GF_OUT_OF_MEM;\n\t\tgf_list_add(trak->Aperture->child_boxes, enof);\n\t}\n\tif (!prof) {\n\t\tprof = gf_isom_box_new(GF_QT_BOX_TYPE_PROF);\n\t\tif (!prof) return GF_OUT_OF_MEM;\n\t\tgf_list_add(trak->Aperture->child_boxes, prof);\n\t}\n\n\tventry = (GF_VisualSampleEntryBox *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, 0);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (ventry == NULL) return GF_BAD_PARAM;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tif (ventry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return GF_BAD_PARAM;\n\n\tpasp = (GF_PixelAspectRatioBox *) gf_isom_box_find_child(ventry->child_boxes, GF_ISOM_BOX_TYPE_PASP);\n\thspacing = vspacing = 0;\n\tif (pasp) {\n\t\thspacing = pasp->hSpacing;\n\t\tvspacing = pasp->vSpacing;\n\t}\n\tclap_width_num = ventry->Width;\n\tclap_width_den = 1;\n\tclap_height_num = ventry->Height;\n\tclap_height_den = 1;\n\tclap = (GF_CleanApertureBox *) gf_isom_box_find_child(ventry->child_boxes, GF_ISOM_BOX_TYPE_CLAP);\n\tif (clap) {\n\t\tclap_width_num = clap->cleanApertureWidthN;\n\t\tclap_width_den = clap->cleanApertureWidthD;\n\t\tclap_height_num = clap->cleanApertureHeightN;\n\t\tclap_height_den = clap->cleanApertureHeightD;\n\t}\n\t//enof: encoded pixels in 16.16\n\t((GF_ApertureBox *)enof)->width = (ventry->Width)<<16;\n\t((GF_ApertureBox *)enof)->height = (ventry->Height)<<16;\n\n\t//prof: encoded pixels + pasp in 16.16\n\twidth = (Float) (ventry->Width * hspacing);\n\twidth /= vspacing;\n\thigh = (u32) floor((Float)width);\n\tlow = (u32) ( 0xFFFF * (width - (Double)high) );\n\t((GF_ApertureBox *)prof)->width = (high)<<16 | low;\n\t((GF_ApertureBox *)prof)->height = (ventry->Height)<<16;\n\n\t//clef: encoded pixels + pasp + clap in 16.16\n\twidth = (Double) (clap_width_num * hspacing);\n\twidth /= clap_width_den * vspacing;\n\theight = (Float) clap_height_num;\n\theight /= clap_height_den;\n\n\thigh = (u32) floor((Float)width);\n\tlow = (u32) (0xFFFF * (width - (Double)high));\n\t((GF_ApertureBox *)clef)->width = (high)<<16 | low;\n\thigh = (u32) floor((Float)height);\n\tlow = (u32) (0xFFFF * (height - (Double)high));\n\t((GF_ApertureBox *)clef)->height = (high)<<16 | low;\n\n\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_image_sequence_coding_constraints(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, Bool remove, Bool all_ref_pics_intra, Bool intra_pred_used, u32 max_ref_per_pic)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn movie->LastError = GF_BAD_PARAM;\n\t}\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return GF_BAD_PARAM;\n\n\tGF_CodingConstraintsBox*ccst = (GF_CodingConstraintsBox*) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_CCST);\n\tif (remove)  {\n\t\tif (ccst) gf_isom_box_del_parent(&entry->child_boxes, (GF_Box*)ccst);\n\t\treturn GF_OK;\n\t}\n\tif (!ccst) {\n\t\tccst = (GF_CodingConstraintsBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_CCST);\n\t\tif (!ccst) return GF_OUT_OF_MEM;\n\t}\n\tccst->all_ref_pics_intra = all_ref_pics_intra;\n\tccst->intra_pred_used = intra_pred_used;\n\tccst->max_ref_per_pic = max_ref_per_pic;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_image_sequence_alpha(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, Bool remove)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn movie->LastError = GF_BAD_PARAM;\n\t}\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return GF_BAD_PARAM;\n\n\tGF_AuxiliaryTypeInfoBox *auxi = (GF_AuxiliaryTypeInfoBox *)gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_AUXI);\n\tif (remove)  {\n\t\tif (auxi) gf_isom_box_del_parent(&entry->child_boxes, (GF_Box*)auxi);\n\t\treturn GF_OK;\n\t}\n\tif (!auxi) {\n\t\tauxi = (GF_AuxiliaryTypeInfoBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_AUXI);\n\t\tif (!auxi) return GF_OUT_OF_MEM;\n\t}\n\tauxi->aux_track_type = gf_strdup(\"urn:mpeg:mpegB:cicp:systems:auxiliary:alpha\");\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_audio_info(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, u32 sampleRate, u32 nbChannels, u8 bitsPerSample, GF_AudioSampleEntryImportMode asemode)\n{\n\tGF_Err e;\n\tu32 i, old_qtff_mode=GF_ISOM_AUDIO_QTFF_NONE;\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_AudioSampleEntryBox*aud_entry;\n\tGF_SampleDescriptionBox *stsd;\n\tGF_Box *wave_box = NULL;\n\tGF_Box *gf_isom_audio_sample_get_audio_codec_cfg_box(GF_AudioSampleEntryBox *ptr);\n\tGF_Box *codec_ext = NULL;\n#if 0\n\tGF_ChannelLayoutInfoBox *chan=NULL;\n#endif\n\tGF_OriginalFormatBox *frma=NULL;\n\tGF_ChromaInfoBox *enda=NULL;\n\tGF_ESDBox *esds=NULL;\n\tGF_Box *terminator=NULL;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) {\n\t\treturn movie->LastError = GF_ISOM_INVALID_FILE;\n\t}\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn movie->LastError = GF_BAD_PARAM;\n\t}\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_AUDIO) return GF_BAD_PARAM;\n\taud_entry = (GF_AudioSampleEntryBox*) entry;\n\n\tif (entry->type==GF_ISOM_BOX_TYPE_MLPA) {\n\t\taud_entry->samplerate_hi = sampleRate>>16;\n\t\taud_entry->samplerate_lo = sampleRate & 0x0000FFFF;\n\t} else {\n\t\taud_entry->samplerate_hi = sampleRate;\n\t\taud_entry->samplerate_lo = 0;\n\t}\n\taud_entry->bitspersample = bitsPerSample;\n\n\tswitch (asemode) {\n\tcase GF_IMPORT_AUDIO_SAMPLE_ENTRY_v0_2:\n\t\tstsd->version = 0;\n\t\taud_entry->version = 0;\n\t\taud_entry->qtff_mode = GF_ISOM_AUDIO_QTFF_NONE;\n\t\taud_entry->channel_count = 2;\n\t\tbreak;\n\tcase GF_IMPORT_AUDIO_SAMPLE_ENTRY_NOT_SET:\n\tcase GF_IMPORT_AUDIO_SAMPLE_ENTRY_v0_BS:\n\t\tstsd->version = 0;\n\t\taud_entry->version = 0;\n\t\taud_entry->qtff_mode = GF_ISOM_AUDIO_QTFF_NONE;\n\t\taud_entry->channel_count = nbChannels;\n\t\tbreak;\n\tcase GF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_MPEG:\n\t\tstsd->version = 1;\n\t\taud_entry->version = 1;\n\t\taud_entry->qtff_mode = GF_ISOM_AUDIO_QTFF_NONE;\n\t\taud_entry->channel_count = nbChannels;\n\t\tbreak;\n\tcase GF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_QTFF:\n\t\tstsd->version = 0;\n\t\t//don't change if already v2\n\t\tif ((aud_entry->version==2) && aud_entry->qtff_mode) {\n\t\t\tbreak;\n\t\t}\n\t\taud_entry->version = 1;\n\t\taud_entry->channel_count = nbChannels;\n\t\told_qtff_mode = aud_entry->qtff_mode;\n\t\tif (aud_entry->qtff_mode != GF_ISOM_AUDIO_QTFF_ON_EXT_VALID)\n\t\t\taud_entry->qtff_mode = GF_ISOM_AUDIO_QTFF_ON_NOEXT;\n\t\tbreak;\n\t}\n\n\taud_entry->compression_id = 0;\n\n\t//check for wave+children and chan for QTFF or remove them for isobmff\n\tfor (i=0; i<gf_list_count(aud_entry->child_boxes); i++) {\n\t\tGF_Box *b = gf_list_get(aud_entry->child_boxes, i);\n\t\tif ((b->type != GF_QT_BOX_TYPE_WAVE) && (b->type != GF_QT_BOX_TYPE_CHAN) ) continue;\n\t\tif (asemode==GF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_QTFF) {\n\t\t\tif (b->type == GF_QT_BOX_TYPE_WAVE) wave_box = b;\n#if 0\n\t\t\telse chan = (GF_ChannelLayoutInfoBox *)b;\n#endif\n\n\t\t} else {\n\t\t\tgf_isom_box_del_parent(&aud_entry->child_boxes, b);\n\t\t\ti--;\n\t\t}\n\t}\n\n\t//TODO: insert channelLayout for ISOBMFF\n\tif (asemode!=GF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_QTFF) return GF_OK;\n\n\tif (aud_entry->type==GF_ISOM_BOX_TYPE_MP4A)\n\t\taud_entry->compression_id = -2;\n\n\tif (!aud_entry->child_boxes) aud_entry->child_boxes = gf_list_new();\n\n#if 0\n\tif (!chan) {\n\t\tchan = (GF_ChannelLayoutInfoBox *) gf_isom_box_new_parent(&aud_entry->child_boxes, GF_QT_BOX_TYPE_CHAN);\n\t}\n\t//TODO, proper channel mapping\n\tchan->layout_tag = (nbChannels==2) ? 6750210 : 6553601;\n#endif\n\n\tcodec_ext = gf_isom_audio_sample_get_audio_codec_cfg_box((GF_AudioSampleEntryBox *)aud_entry);\n\tif (!codec_ext) return GF_OK;\n\n\tif (!wave_box) {\n\t\twave_box = gf_isom_box_new_parent(&aud_entry->child_boxes, GF_QT_BOX_TYPE_WAVE);\n\t}\n\n\tfor (i=0; i<gf_list_count(wave_box->child_boxes); i++) {\n\t\tGF_Box *b = gf_list_get(wave_box->child_boxes, i);\n\t\tswitch (b->type) {\n\t\tcase GF_QT_BOX_TYPE_ENDA:\n\t\t\tenda = (GF_ChromaInfoBox *)b;\n\t\t\tbreak;\n\t\tcase GF_QT_BOX_TYPE_FRMA:\n\t\t\tfrma = (GF_OriginalFormatBox *)b;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_ESDS:\n\t\t\tesds = (GF_ESDBox *)b;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_UNKNOWN:\n\t\t\tif ( ((GF_UnknownBox*)b)->original_4cc == 0)\n\t\t\t\tterminator = b;\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tterminator = b;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!wave_box->child_boxes) wave_box->child_boxes = gf_list_new();\n\n\t//do not use new_parent, we do this manually to ensure the order\n\taud_entry->qtff_mode = old_qtff_mode ? old_qtff_mode : GF_ISOM_AUDIO_QTFF_ON_NOEXT;\n\tif (!frma) {\n\t\tfrma = (GF_OriginalFormatBox *)gf_isom_box_new(GF_QT_BOX_TYPE_FRMA);\n\t} else {\n\t\tgf_list_del_item(wave_box->child_boxes, frma);\n\t}\n\tgf_list_add(wave_box->child_boxes, frma);\n\n\tif (esds) gf_list_del_item(wave_box->child_boxes, esds);\n\tif (!esds && (aud_entry->type==GF_ISOM_BOX_TYPE_MP4A) && ((GF_MPEGAudioSampleEntryBox*)aud_entry)->esd) {\n\t\tgf_list_del_item(entry->child_boxes, (GF_Box *) ((GF_MPEGAudioSampleEntryBox*)aud_entry)->esd);\n\t\tgf_list_add(wave_box->child_boxes, (GF_Box *) ((GF_MPEGAudioSampleEntryBox*)aud_entry)->esd);\n\t}\n\n\tif (!enda) {\n\t\tenda = (GF_ChromaInfoBox *)gf_isom_box_new(GF_QT_BOX_TYPE_ENDA);\n\t} else {\n\t\tgf_list_del_item(wave_box->child_boxes, enda);\n\t}\n\tenda->chroma=1;\n\tgf_list_add(wave_box->child_boxes, enda);\n\n\tif (!terminator) {\n\t\tterminator = gf_isom_box_new(0);\n\t} else {\n\t\tgf_list_del_item(wave_box->child_boxes, terminator);\n\t}\n\tgf_list_add(wave_box->child_boxes, terminator);\n\n\tif (aud_entry->type==GF_ISOM_BOX_TYPE_GNRA) {\n\t\tfrma->data_format = ((GF_GenericAudioSampleEntryBox*) aud_entry)->EntryType;\n\t} else {\n\t\tfrma->data_format = aud_entry->type;\n\t}\n\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_audio_layout(GF_ISOFile *movie, u32 trackNumber, u32 sampleDescriptionIndex, GF_AudioChannelLayout *layout)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_AudioSampleEntryBox*aud_entry;\n\tGF_SampleDescriptionBox *stsd;\n\tGF_ChannelLayoutBox *chnl;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) {\n\t\treturn movie->LastError = GF_ISOM_INVALID_FILE;\n\t}\n\tif (!sampleDescriptionIndex || sampleDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn movie->LastError = GF_BAD_PARAM;\n\t}\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, sampleDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_AUDIO) return GF_BAD_PARAM;\n\taud_entry = (GF_AudioSampleEntryBox*) entry;\n\tif (aud_entry->qtff_mode) {\n\t\tu32 sr = aud_entry->samplerate_hi;\n\t\tif (aud_entry->type==GF_ISOM_BOX_TYPE_MLPA) {\n\t\t\tsr <<= 16;\n\t\t\tsr |= aud_entry->samplerate_lo;\n\t\t}\n\t\te = gf_isom_set_audio_info(movie, trackNumber, sampleDescriptionIndex, sr, aud_entry->channel_count, (u8) aud_entry->bitspersample, GF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_MPEG);\n\t\tif (e) return e;\n\t}\n\tchnl = (GF_ChannelLayoutBox *) gf_isom_box_find_child(aud_entry->child_boxes, GF_ISOM_BOX_TYPE_CHNL);\n\tif (!chnl) {\n\t\tchnl = (GF_ChannelLayoutBox *)gf_isom_box_new_parent(&aud_entry->child_boxes, GF_ISOM_BOX_TYPE_CHNL);\n\t\tif (!chnl) return GF_OUT_OF_MEM;\n\t}\n\taud_entry->channel_count = layout->channels_count;\n\tmemcpy(&chnl->layout, layout, sizeof(GF_AudioChannelLayout));\n\treturn GF_OK;\n}\n\n//set the storage mode of a file (FLAT, STREAMABLE, INTERLEAVED)\nGF_EXPORT\nGF_Err gf_isom_set_storage_mode(GF_ISOFile *movie, GF_ISOStorageMode storageMode)\n{\n\tGF_Err e;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tswitch (storageMode) {\n\tcase GF_ISOM_STORE_FLAT:\n\tcase GF_ISOM_STORE_STREAMABLE:\n\tcase GF_ISOM_STORE_INTERLEAVED:\n\tcase GF_ISOM_STORE_DRIFT_INTERLEAVED:\n\tcase GF_ISOM_STORE_TIGHT:\n\tcase GF_ISOM_STORE_FASTSTART:\n\t\tmovie->storageMode = storageMode;\n\t\t//specifying a storage mode disables inplace rewrite\n\t\tgf_isom_disable_inplace_rewrite(movie);\n\t\treturn GF_OK;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_enable_compression(GF_ISOFile *file, GF_ISOCompressMode compress_mode, u32 compress_flags)\n{\n\tif (!file) return GF_BAD_PARAM;\n\tfile->compress_mode = compress_mode;\n\tfile->compress_flags = compress_flags;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_force_64bit_chunk_offset(GF_ISOFile *file, Bool set_on)\n{\n\tif (!file) return GF_BAD_PARAM;\n\tfile->force_co64 = set_on;\n\treturn GF_OK;\n}\n\n\n//update or insert a new edit segment in the track time line. Edits are used to modify\n//the media normal timing. EditTime and EditDuration are expressed in Movie TimeScale\n//If a segment with EditTime already exists, IT IS ERASED\nstatic GF_Err gf_isom_set_edit_internal(GF_ISOFile *movie, u32 trackNumber, u64 EditTime, u64 EditDuration, u64 MediaTime, u32 media_rate, GF_ISOEditType EditMode)\n{\n\tGF_TrackBox *trak;\n\tGF_EditBox *edts;\n\tGF_EditListBox *elst;\n\tGF_EdtsEntry *ent, *newEnt;\n\tu32 i;\n\tGF_Err e;\n\tu64 startTime;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tedts = trak->editBox;\n\tif (! edts) {\n\t\tedts = (GF_EditBox *) gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_EDTS);\n\t\tif (!edts) return GF_OUT_OF_MEM;\n\t\ttrak_on_child_box((GF_Box*)trak, (GF_Box *)edts, GF_FALSE);\n\t}\n\telst = edts->editList;\n\tif (!elst) {\n\t\telst = (GF_EditListBox *) gf_isom_box_new_parent(&edts->child_boxes, GF_ISOM_BOX_TYPE_ELST);\n\t\tif (!elst) return GF_OUT_OF_MEM;\n\t\tedts_on_child_box((GF_Box*)edts, (GF_Box *)elst, GF_FALSE);\n\t}\n\n\tstartTime = 0;\n\tent = NULL;\n\t//get the prev entry to this startTime if any\n\ti=0;\n\twhile ((ent = (GF_EdtsEntry *)gf_list_enum(elst->entryList, &i))) {\n\t\tif ( (startTime <= EditTime) && (startTime + ent->segmentDuration > EditTime) )\n\t\t\tgoto found;\n\t\tstartTime += ent->segmentDuration;\n\t}\n\n\t//not found, add a new entry, insert empty one if gap\n\tif (!ent) {\n\t\tBool empty_inserted = GF_FALSE;\n\t\tif (startTime != EditTime) {\n\t\t\tnewEnt = CreateEditEntry(EditTime - startTime, 0, 0, GF_ISOM_EDIT_EMPTY);\n\t\t\tif (!newEnt) return GF_OUT_OF_MEM;\n\t\t\tempty_inserted = GF_TRUE;\n\t\t\tgf_list_add(elst->entryList, newEnt);\n\t\t}\n\t\tnewEnt = CreateEditEntry(EditDuration, MediaTime, media_rate, EditMode);\n\t\tif (!newEnt) return GF_OUT_OF_MEM;\n\t\tgf_list_add(elst->entryList, newEnt);\n\t\te = SetTrackDuration(trak);\n\t\tif (e) return e;\n\t\treturn empty_inserted ? GF_EOS : GF_OK;\n\t}\n\n\tstartTime -= ent->segmentDuration;\n\nfound:\n\n\t//if same time, we erase the current one...\n\tif (startTime == EditTime) {\n\t\tent->segmentDuration = EditDuration;\n\t\tswitch (EditMode) {\n\t\tcase GF_ISOM_EDIT_EMPTY:\n\t\t\tent->mediaRate = 0x10000;\n\t\t\tent->mediaTime = -1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_EDIT_DWELL:\n\t\t\tent->mediaRate = 0;\n\t\t\tent->mediaTime = MediaTime;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tent->mediaRate = media_rate;\n\t\t\tent->mediaTime = MediaTime;\n\t\t\tbreak;\n\t\t}\n\t\treturn SetTrackDuration(trak);\n\t}\n\n\t//adjust so that the prev ent leads to EntryTime\n\t//Note: we don't change the next one as it is unknown to us in\n\t//a lot of case (the author's changes)\n\tent->segmentDuration = EditTime - startTime;\n\tnewEnt = CreateEditEntry(EditDuration, MediaTime, media_rate, EditMode);\n\tif (!newEnt) return GF_OUT_OF_MEM;\n\t//is it the last entry ???\n\tif (i >= gf_list_count(elst->entryList) - 1) {\n\t\t//add the new entry at the end\n\t\tgf_list_add(elst->entryList, newEnt);\n\t\treturn SetTrackDuration(trak);\n\t} else {\n\t\t//insert after the current entry (which is i)\n\t\tgf_list_insert(elst->entryList, newEnt, i+1);\n\t\treturn SetTrackDuration(trak);\n\t}\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_edit(GF_ISOFile *movie, u32 trackNumber, u64 EditTime, u64 EditDuration, u64 MediaTime, GF_ISOEditType EditMode)\n{\n\treturn gf_isom_set_edit_internal(movie, trackNumber, EditTime, EditDuration, MediaTime, 0x10000, EditMode);\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_edit_with_rate(GF_ISOFile *movie, u32 trackNumber, u64 EditTime, u64 EditDuration, u64 MediaTime, u32 media_rate)\n{\n\treturn gf_isom_set_edit_internal(movie, trackNumber, EditTime, EditDuration, MediaTime, media_rate, GF_ISOM_EDIT_NORMAL);\n\n}\n\n//remove the edit segments for the whole track\nGF_EXPORT\nGF_Err gf_isom_remove_edits(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tif (!trak->editBox || !trak->editBox->editList) return GF_OK;\n\n\twhile (gf_list_count(trak->editBox->editList->entryList)) {\n\t\tGF_EdtsEntry *ent = (GF_EdtsEntry*)gf_list_get(trak->editBox->editList->entryList, 0);\n\t\tgf_free(ent);\n\t\te = gf_list_rem(trak->editBox->editList->entryList, 0);\n\t\tif (e) return e;\n\t}\n\t//then delete the GF_EditBox...\n\tgf_isom_box_del_parent(&trak->child_boxes, (GF_Box *)trak->editBox);\n\ttrak->editBox = NULL;\n\treturn SetTrackDuration(trak);\n}\n\n\n//remove the edit segments for the whole track\nGF_EXPORT\nGF_Err gf_isom_remove_edit(GF_ISOFile *movie, u32 trackNumber, u32 seg_index)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_EdtsEntry *ent, *next_ent;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !seg_index) return GF_BAD_PARAM;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tif (!trak->editBox || !trak->editBox->editList) return GF_OK;\n\tif (gf_list_count(trak->editBox->editList->entryList)<=1) return gf_isom_remove_edits(movie, trackNumber);\n\n\tent = (GF_EdtsEntry*) gf_list_get(trak->editBox->editList->entryList, seg_index-1);\n\tgf_list_rem(trak->editBox->editList->entryList, seg_index-1);\n\tnext_ent = (GF_EdtsEntry *)gf_list_get(trak->editBox->editList->entryList, seg_index-1);\n\tif (next_ent) next_ent->segmentDuration += ent->segmentDuration;\n\tgf_free(ent);\n\treturn SetTrackDuration(trak);\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_append_edit(GF_ISOFile *movie, u32 trackNumber, u64 EditDuration, u64 MediaTime, GF_ISOEditType EditMode)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_EdtsEntry *ent;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tif (!trak->editBox) {\n\t\tGF_EditBox *edts = (GF_EditBox *) gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_EDTS);\n\t\tif (!edts) return GF_OUT_OF_MEM;\n\t\ttrak_on_child_box((GF_Box*)trak, (GF_Box *)edts, GF_FALSE);\n\t\tassert(trak->editBox);\n\t}\n\tif (!trak->editBox->editList) {\n\t\tGF_EditListBox *elst = (GF_EditListBox *) gf_isom_box_new_parent(&trak->editBox->child_boxes, GF_ISOM_BOX_TYPE_ELST);\n\t\tif (!elst) return GF_OUT_OF_MEM;\n\t\tedts_on_child_box((GF_Box*)trak->editBox, (GF_Box *)elst, GF_FALSE);\n\t\tassert(trak->editBox->editList);\n\t}\n\tent = (GF_EdtsEntry *)gf_malloc(sizeof(GF_EdtsEntry));\n\tif (!ent) return GF_OUT_OF_MEM;\n\n\tent->segmentDuration = EditDuration;\n\tswitch (EditMode) {\n\tcase GF_ISOM_EDIT_EMPTY:\n\t\tent->mediaRate = 0x10000;\n\t\tent->mediaTime = -1;\n\t\tbreak;\n\tcase GF_ISOM_EDIT_DWELL:\n\t\tent->mediaRate = 0;\n\t\tent->mediaTime = MediaTime;\n\t\tbreak;\n\tdefault:\n\t\tent->mediaRate = 0x10000;\n\t\tent->mediaTime = MediaTime;\n\t\tbreak;\n\t}\n\tgf_list_add(trak->editBox->editList->entryList, ent);\n\treturn SetTrackDuration(trak);\n}\n\nGF_EXPORT\nGF_Err gf_isom_modify_edit(GF_ISOFile *movie, u32 trackNumber, u32 seg_index, u64 EditDuration, u64 MediaTime, GF_ISOEditType EditMode)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_EdtsEntry *ent;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !seg_index) return GF_BAD_PARAM;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tif (!trak->editBox || !trak->editBox->editList) return GF_OK;\n\tif (gf_list_count(trak->editBox->editList->entryList)<seg_index) return GF_BAD_PARAM;\n\tent = (GF_EdtsEntry*) gf_list_get(trak->editBox->editList->entryList, seg_index-1);\n\n\tent->segmentDuration = EditDuration;\n\tswitch (EditMode) {\n\tcase GF_ISOM_EDIT_EMPTY:\n\t\tent->mediaRate = 0x10000;\n\t\tent->mediaTime = -1;\n\t\tbreak;\n\tcase GF_ISOM_EDIT_DWELL:\n\t\tent->mediaRate = 0;\n\t\tent->mediaTime = MediaTime;\n\t\tbreak;\n\tdefault:\n\t\tent->mediaRate = 0x10000;\n\t\tent->mediaTime = MediaTime;\n\t\tbreak;\n\t}\n\treturn SetTrackDuration(trak);\n}\n\nstatic void update_next_track_id(GF_ISOFile *movie)\n{\n\tGF_TrackBox *trak;\n\t/*update next track ID*/\n\tmovie->moov->mvhd->nextTrackID = 0;\n\tu32 i=0;\n\twhile ((trak = (GF_TrackBox *)gf_list_enum(movie->moov->trackList, &i))) {\n\t\tif (trak->Header->trackID>movie->moov->mvhd->nextTrackID)\n\t\t\tmovie->moov->mvhd->nextTrackID = trak->Header->trackID;\n\t}\n\t//shall be larger than the largest track_ID in use\n\tmovie->moov->mvhd->nextTrackID++;\n}\n\n//removes the desired track\nGF_EXPORT\nGF_Err gf_isom_remove_track(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_Err e;\n\tGF_TrackBox *the_trak, *trak;\n\tGF_TrackReferenceTypeBox *tref;\n\tu32 i, j, k, descIndex;\n\tGF_ISOTrackID *newRefs;\n\tu8 found;\n\tGF_ISOSample *samp;\n\tthe_trak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!the_trak) return GF_BAD_PARAM;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tif (movie->moov->iods && movie->moov->iods->descriptor) {\n\t\tGF_Descriptor *desc;\n\t\tGF_ES_ID_Inc *inc;\n\t\tGF_List *ESDs;\n\t\tdesc = movie->moov->iods->descriptor;\n\t\tif (desc->tag == GF_ODF_ISOM_IOD_TAG) {\n\t\t\tESDs = ((GF_IsomInitialObjectDescriptor *)desc)->ES_ID_IncDescriptors;\n\t\t} else if (desc->tag == GF_ODF_ISOM_OD_TAG) {\n\t\t\tESDs = ((GF_IsomObjectDescriptor *)desc)->ES_ID_IncDescriptors;\n\t\t} else {\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\n\t\t//remove the track ref from the root OD if any\n\t\ti=0;\n\t\twhile ((inc = (GF_ES_ID_Inc *)gf_list_enum(ESDs, &i))) {\n\t\t\tif (inc->trackID == the_trak->Header->trackID) {\n\t\t\t\tgf_odf_desc_del((GF_Descriptor *)inc);\n\t\t\t\ti--;\n\t\t\t\tgf_list_rem(ESDs, i);\n\t\t\t}\n\t\t}\n\t}\n\n\t//remove the track from the movie\n\tgf_list_del_item(movie->moov->trackList, the_trak);\n\n\t//rewrite any OD tracks\n\ti=0;\n\twhile ((trak = (GF_TrackBox *)gf_list_enum(movie->moov->trackList, &i))) {\n\t\tif (trak->Media->handler->handlerType != GF_ISOM_MEDIA_OD) continue;\n\n\t\t//this is an OD track...\n\t\tj = gf_isom_get_sample_count(movie, i);\n\t\tfor (k=0; k < j; k++) {\n\t\t\t//getting the sample will remove the references to the deleted track in the output OD frame\n\t\t\tsamp = gf_isom_get_sample(movie, i, k+1, &descIndex);\n\t\t\tif (!samp) break;\n\t\t\t//so let's update with the new OD frame ! If the sample is empty, remove it\n\t\t\tif (!samp->dataLength) {\n\t\t\t\te = gf_isom_remove_sample(movie, i, k+1);\n\t\t\t\tif (e) return e;\n\t\t\t} else {\n\t\t\t\te = gf_isom_update_sample(movie, i, k+1, samp, GF_TRUE);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\t\t\t//and don't forget to delete the sample\n\t\t\tgf_isom_sample_del(&samp);\n\t\t}\n\t}\n\n\t//remove the track ref from any \"tref\" box in all tracks, except the one to delete\n\t//note that we don't touch scal references, as we don't want to rewrite AVC/HEVC samples ...\n\ti=0;\n\twhile ((trak = (GF_TrackBox *)gf_list_enum(movie->moov->trackList, &i))) {\n\t\tif (! trak->References || ! gf_list_count(trak->References->child_boxes)) continue;\n\n\t\tj=0;\n\t\twhile ((tref = (GF_TrackReferenceTypeBox *)gf_list_enum(trak->References->child_boxes, &j))) {\n\t\t\tif (tref->reference_type==GF_ISOM_REF_SCAL)\n\t\t\t\tcontinue;\n\n\t\t\tfound = 0;\n\t\t\tfor (k=0; k<tref->trackIDCount; k++) {\n\t\t\t\tif (tref->trackIDs[k] == the_trak->Header->trackID) found++;\n\t\t\t}\n\t\t\tif (!found) continue;\n\t\t\t//no more refs, remove this ref_type\n\t\t\tif (found == tref->trackIDCount) {\n\t\t\t\tgf_isom_box_del_parent(&trak->References->child_boxes, (GF_Box *)tref);\n\t\t\t\tj--;\n\t\t\t} else {\n\t\t\t\tnewRefs = (GF_ISOTrackID*)gf_malloc(sizeof(GF_ISOTrackID) * (tref->trackIDCount - found));\n\t\t\t\tif (!newRefs) return GF_OUT_OF_MEM;\n\t\t\t\tfound = 0;\n\t\t\t\tfor (k = 0; k < tref->trackIDCount; k++) {\n\t\t\t\t\tif (tref->trackIDs[k] != the_trak->Header->trackID) {\n\t\t\t\t\t\tnewRefs[k-found] = tref->trackIDs[k];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfound++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgf_free(tref->trackIDs);\n\t\t\t\ttref->trackIDs = newRefs;\n\t\t\t\ttref->trackIDCount -= found;\n\t\t\t}\n\t\t}\n\t\t//a little opt: remove the ref box if empty...\n\t\tif (! gf_list_count(trak->References->child_boxes)) {\n\t\t\tgf_isom_box_del_parent(&trak->child_boxes, (GF_Box *)trak->References);\n\t\t\ttrak->References = NULL;\n\t\t}\n\t}\n\n\tgf_isom_disable_inplace_rewrite(movie);\n\n\tgf_isom_meta_track_remove(movie, the_trak, 0);\n\n\t//delete the track\n\tgf_isom_box_del_parent(&movie->moov->child_boxes, (GF_Box *)the_trak);\n\n\t/*update next track ID*/\n\tupdate_next_track_id(movie);\n\n\tif (!gf_list_count(movie->moov->trackList)) {\n\t\tgf_list_del_item(movie->TopBoxes, movie->moov);\n\t\tgf_isom_box_del((GF_Box *)movie->moov);\n\t\tmovie->moov = NULL;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_set_copyright(GF_ISOFile *movie, const char *threeCharCode, char *notice)\n{\n\tGF_Err e;\n\tGF_CopyrightBox *ptr;\n\tGF_UserDataMap *map;\n\tu32 count, i;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tif (!notice || !threeCharCode) return GF_BAD_PARAM;\n\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\n\tif (!movie->moov->udta) {\n\t\te = moov_on_child_box((GF_Box*)movie->moov, gf_isom_box_new_parent(&movie->moov->child_boxes, GF_ISOM_BOX_TYPE_UDTA), GF_FALSE);\n\t\tif (e) return e;\n\t}\n\tmap = udta_getEntry(movie->moov->udta, GF_ISOM_BOX_TYPE_CPRT, NULL);\n\n\tif (map) {\n\t\t//try to find one in our language...\n\t\tcount = gf_list_count(map->boxes);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tptr = (GF_CopyrightBox*)gf_list_get(map->boxes, i);\n\t\t\tif (!strcmp(threeCharCode, (const char *) ptr->packedLanguageCode)) {\n\t\t\t\tgf_free(ptr->notice);\n\t\t\t\tptr->notice = (char*)gf_malloc(sizeof(char) * (strlen(notice) + 1));\n\t\t\t\tif (!ptr->notice) return GF_OUT_OF_MEM;\n\t\t\t\tstrcpy(ptr->notice, notice);\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t}\n\t}\n\t//nope, create one\n\tptr = (GF_CopyrightBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_CPRT);\n\tif (!ptr) return GF_OUT_OF_MEM;\n\n\tmemcpy(ptr->packedLanguageCode, threeCharCode, 4);\n\tptr->notice = (char*)gf_malloc(sizeof(char) * (strlen(notice)+1));\n\tif (!ptr->notice) return GF_OUT_OF_MEM;\n\tstrcpy(ptr->notice, notice);\n\treturn udta_on_child_box((GF_Box *)movie->moov->udta, (GF_Box *) ptr, GF_FALSE);\n}\n\nGF_EXPORT\nGF_Err gf_isom_add_track_kind(GF_ISOFile *movie, u32 trackNumber, const char *schemeURI, const char *value)\n{\n\tGF_Err e;\n\tGF_KindBox *ptr;\n\tGF_UserDataBox *udta;\n\tGF_UserDataMap *map;\n\tu32 i, count;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\n\tif (trackNumber) {\n\t\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\tif (!trak->udta) {\n\t\t\te = trak_on_child_box((GF_Box*)trak, gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_UDTA), GF_FALSE);\n\t\t\tif (e) return e;\n\t\t}\n\t\tudta = trak->udta;\n\t} else {\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tmap = udta_getEntry(udta, GF_ISOM_BOX_TYPE_KIND, NULL);\n\tif (map) {\n\t\tcount = gf_list_count(map->boxes);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_Box *b = (GF_Box *)gf_list_get(map->boxes, i);\n\t\t\tif (b->type == GF_ISOM_BOX_TYPE_KIND) {\n\t\t\t\tGF_KindBox *kb = (GF_KindBox *)b;\n\t\t\t\tif (!strcmp(kb->schemeURI, schemeURI) &&\n\t\t\t\t        ((value && kb->value && !strcmp(value, kb->value)) || (!value && !kb->value))) {\n\t\t\t\t\t// Already there\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tptr = (GF_KindBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_KIND);\n\tif (e) return e;\n\n\tptr->schemeURI = gf_strdup(schemeURI);\n\tif (value) ptr->value = gf_strdup(value);\n\treturn udta_on_child_box((GF_Box *)udta, (GF_Box *) ptr, GF_FALSE);\n}\n\nGF_EXPORT\nGF_Err gf_isom_remove_track_kind(GF_ISOFile *movie, u32 trackNumber, const char *schemeURI, const char *value)\n{\n\tGF_Err e;\n\tGF_UserDataBox *udta;\n\tGF_UserDataMap *map;\n\tu32 i;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\n\tif (trackNumber) {\n\t\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\tif (!trak->udta) {\n\t\t\te = trak_on_child_box((GF_Box*)trak, gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_UDTA), GF_FALSE);\n\t\t\tif (e) return e;\n\t\t}\n\t\tudta = trak->udta;\n\t} else {\n\t\treturn GF_OK;\n\t}\n\tmap = udta_getEntry(udta, GF_ISOM_BOX_TYPE_KIND, NULL);\n\tif (map) {\n\t\tfor (i=0; i<gf_list_count(map->boxes); i++) {\n\t\t\tGF_Box *b = (GF_Box *)gf_list_get(map->boxes, i);\n\t\t\tif (b->type == GF_ISOM_BOX_TYPE_KIND) {\n\t\t\t\tGF_KindBox *kb = (GF_KindBox *)b;\n\t\t\t\tif (!schemeURI ||\n\t\t\t\t        (!strcmp(kb->schemeURI, schemeURI) &&\n\t\t\t\t         ((value && kb->value && !strcmp(value, kb->value)) || (!value && !kb->value)))) {\n\t\t\t\t\tgf_isom_box_del_parent(&map->boxes, b);\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_add_chapter(GF_ISOFile *movie, u32 trackNumber, u64 timestamp, char *name)\n{\n\tGF_Err e;\n\tGF_ChapterListBox *ptr;\n\tu32 i, count;\n\tGF_ChapterEntry *ce;\n\tGF_UserDataBox *udta;\n\tGF_UserDataMap *map;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\n\tif (trackNumber) {\n\t\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\tif (!trak->udta) {\n\t\t\te = trak_on_child_box((GF_Box*)trak, gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_UDTA), GF_FALSE);\n\t\t\tif (e) return e;\n\t\t}\n\t\tudta = trak->udta;\n\t} else {\n\t\tif (!movie->moov->udta) {\n\t\t\te = moov_on_child_box((GF_Box*)movie->moov, gf_isom_box_new_parent(&movie->moov->child_boxes, GF_ISOM_BOX_TYPE_UDTA), GF_FALSE);\n\t\t\tif (e) return e;\n\t\t}\n\t\tudta = movie->moov->udta;\n\t}\n\n\tptr = NULL;\n\tmap = udta_getEntry(udta, GF_ISOM_BOX_TYPE_CHPL, NULL);\n\tif (!map) {\n\t\tptr = (GF_ChapterListBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_CHPL);\n\t\te = udta_on_child_box((GF_Box *)udta, (GF_Box *) ptr, GF_FALSE);\n\t\tif (e) return e;\n\t\tmap = udta_getEntry(udta, GF_ISOM_BOX_TYPE_CHPL, NULL);\n\t} else {\n\t\tptr = (GF_ChapterListBox*)gf_list_get(map->boxes, 0);\n\t}\n\tif (!map) return GF_OUT_OF_MEM;\n\n\t/*this may happen if original MP4 is not properly formatted*/\n\tif (!ptr) {\n\t\tptr = (GF_ChapterListBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_CHPL);\n\t\tif (!ptr) return GF_OUT_OF_MEM;\n\t\tgf_list_add(map->boxes, ptr);\n\t}\n\n\tGF_SAFEALLOC(ce, GF_ChapterEntry);\n\tif (!ce) return GF_OUT_OF_MEM;\n\n\tce->start_time = timestamp * 10000L;\n\tce->name = name ? gf_strdup(name) : NULL;\n\n\t/*insert in order*/\n\tcount = gf_list_count(ptr->list);\n\tfor (i=0; i<count; i++) {\n\t\tGF_ChapterEntry *ace = (GF_ChapterEntry *)gf_list_get(ptr->list, i);\n\t\tif (ace->start_time == ce->start_time) {\n\t\t\tif (ace->name) gf_free(ace->name);\n\t\t\tace->name = ce->name;\n\t\t\tgf_free(ce);\n\t\t\treturn GF_OK;\n\t\t}\n\t\tif (ace->start_time >= ce->start_time)\n\t\t\treturn gf_list_insert(ptr->list, ce, i);\n\t}\n\treturn gf_list_add(ptr->list, ce);\n}\n\nGF_EXPORT\nGF_Err gf_isom_remove_chapter(GF_ISOFile *movie, u32 trackNumber, u32 index)\n{\n\tGF_Err e;\n\tGF_ChapterListBox *ptr;\n\tGF_ChapterEntry *ce;\n\tGF_UserDataBox *udta;\n\tGF_UserDataMap *map;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\n\tif (trackNumber) {\n\t\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\tif (!trak->udta) return GF_OK;\n\t\tudta = trak->udta;\n\t} else {\n\t\tif (!movie->moov->udta) return GF_OK;\n\t\tudta = movie->moov->udta;\n\t}\n\n\tmap = udta_getEntry(udta, GF_ISOM_BOX_TYPE_CHPL, NULL);\n\tif (!map) return GF_OK;\n\tptr = (GF_ChapterListBox*)gf_list_get(map->boxes, 0);\n\tif (!ptr) return GF_OK;\n\n\tif (index) {\n\t\tce = (GF_ChapterEntry *)gf_list_get(ptr->list, index-1);\n\t\tif (!ce) return GF_BAD_PARAM;\n\t\tif (ce->name) gf_free(ce->name);\n\t\tgf_free(ce);\n\t\tgf_list_rem(ptr->list, index-1);\n\t} else {\n\t\twhile (gf_list_count(ptr->list)) {\n\t\t\tce = (GF_ChapterEntry *)gf_list_get(ptr->list, 0);\n\t\t\tif (ce->name) gf_free(ce->name);\n\t\t\tgf_free(ce);\n\t\t\tgf_list_rem(ptr->list, 0);\n\t\t}\n\t}\n\tif (!gf_list_count(ptr->list)) {\n\t\tgf_list_del_item(udta->recordList, map);\n\t\tgf_isom_box_array_del(map->boxes);\n\t\tgf_free(map);\n\t}\n\treturn GF_OK;\n}\n\n#if 0 //unused\nGF_Err gf_isom_remove_copyright(GF_ISOFile *movie, u32 index)\n{\n\tGF_Err e;\n\tGF_CopyrightBox *ptr;\n\tGF_UserDataMap *map;\n\tu32 count;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\n\tif (!index) return GF_BAD_PARAM;\n\tif (!movie->moov->udta) return GF_OK;\n\n\tmap = udta_getEntry(movie->moov->udta, GF_ISOM_BOX_TYPE_CPRT, NULL);\n\tif (!map) return GF_OK;\n\n\tcount = gf_list_count(map->boxes);\n\tif (index>count) return GF_BAD_PARAM;\n\n\tptr = (GF_CopyrightBox*)gf_list_get(map->boxes, index-1);\n\tif (ptr) {\n\t\tgf_list_rem(map->boxes, index-1);\n\t\tif (ptr->notice) gf_free(ptr->notice);\n\t\tgf_free(ptr);\n\t}\n\t/*last copyright, remove*/\n\tif (!gf_list_count(map->boxes)) {\n\t\tgf_list_del_item(movie->moov->udta->recordList, map);\n\t\tgf_list_del(map->boxes);\n\t\tgf_free(map);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err gf_isom_set_watermark(GF_ISOFile *movie, bin128 UUID, u8* data, u32 length)\n{\n\tGF_Err e;\n\tGF_UnknownUUIDBox *ptr;\n\tGF_UserDataMap *map;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\tif (!movie->moov->udta) {\n\t\te = moov_on_child_box((GF_Box*)movie->moov, gf_isom_box_new_parent(&movie->moov->child_boxes, GF_ISOM_BOX_TYPE_UDTA));\n\t\tif (e) return e;\n\t}\n\n\tmap = udta_getEntry(movie->moov->udta, GF_ISOM_BOX_TYPE_UUID, (bin128 *) & UUID);\n\tif (map) {\n\t\tptr = (GF_UnknownUUIDBox *)gf_list_get(map->boxes, 0);\n\t\tif (ptr) {\n\t\t\tgf_free(ptr->data);\n\t\t\tptr->data = (char*)gf_malloc(length);\n\t\t\tif (!ptr->data) return GF_OUT_OF_MEM;\n\t\t\tmemcpy(ptr->data, data, length);\n\t\t\tptr->dataSize = length;\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\t//nope, create one\n\tptr = (GF_UnknownUUIDBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_UUID);\n\tif (!ptr) return GF_OUT_OF_MEM;\n\n\tmemcpy(ptr->uuid, UUID, 16);\n\tptr->data = (char*)gf_malloc(length);\n\tif (!ptr->data) return GF_OUT_OF_MEM;\n\tmemcpy(ptr->data, data, length);\n\tptr->dataSize = length;\n\treturn udta_on_child_box((GF_Box *)movie->moov->udta, (GF_Box *) ptr);\n}\n#endif\n\n//set the interleaving time of media data (INTERLEAVED mode only)\n//InterleaveTime is in MovieTimeScale\nGF_EXPORT\nGF_Err gf_isom_set_interleave_time(GF_ISOFile *movie, u32 InterleaveTime)\n{\n\tGF_Err e;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tif (!InterleaveTime || !movie->moov) return GF_OK;\n\tmovie->interleavingTime = InterleaveTime;\n\treturn GF_OK;\n}\n\n\n\n//use a compact track version for sample size. This is not usually recommended\n//except for speech codecs where the track has a lot of small samples\n//compaction is done automatically while writing based on the track's sample sizes\nGF_EXPORT\nGF_Err gf_isom_use_compact_size(GF_ISOFile *movie, u32 trackNumber, Bool CompactionOn)\n{\n\tGF_TrackBox *trak;\n\tu32 i, size;\n\tGF_SampleSizeBox *stsz;\n\tGF_Err e;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tif (!trak->Media || !trak->Media->information\n\t        || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->SampleSize)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tstsz = trak->Media->information->sampleTable->SampleSize;\n\n\t//switch to regular table\n\tif (!CompactionOn) {\n\t\tif (stsz->type == GF_ISOM_BOX_TYPE_STSZ) return GF_OK;\n\t\tstsz->type = GF_ISOM_BOX_TYPE_STSZ;\n\t\t//invalidate the sampleSize and recompute it\n\t\tstsz->sampleSize = 0;\n\t\tif (!stsz->sampleCount) return GF_OK;\n\t\t//if the table is empty we can only assume the track is empty (no size indication)\n\t\tif (!stsz->sizes) return GF_OK;\n\t\tsize = stsz->sizes[0];\n\t\t//check whether the sizes are all the same or not\n\t\tfor (i=1; i<stsz->sampleCount; i++) {\n\t\t\tif (size != stsz->sizes[i]) {\n\t\t\t\tsize = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (size) {\n\t\t\tgf_free(stsz->sizes);\n\t\t\tstsz->sizes = NULL;\n\t\t\tstsz->sampleSize = size;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\n\t//switch to compact table\n\tif (stsz->type == GF_ISOM_BOX_TYPE_STZ2) return GF_OK;\n\t//fill the table. Although it seems weird , this is needed in case of edition\n\t//after the function is called. NOte however than we force regular table\n\t//at write time if all samples are of same size\n\tif (stsz->sampleSize) {\n\t\t//this is a weird table indeed ;)\n\t\tif (stsz->sizes) gf_free(stsz->sizes);\n\t\tstsz->sizes = (u32*) gf_malloc(sizeof(u32)*stsz->sampleCount);\n\t\tif (!stsz->sizes) return GF_OUT_OF_MEM;\n\t\tmemset(stsz->sizes, stsz->sampleSize, sizeof(u32));\n\t}\n\t//set the SampleSize to 0 while the file is open\n\tstsz->sampleSize = 0;\n\tstsz->type = GF_ISOM_BOX_TYPE_STZ2;\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_disable_brand_rewrite(GF_ISOFile *movie, Bool do_disable)\n{\n\tif (!movie) return GF_BAD_PARAM;\n\tmovie->disable_brand_rewrite = do_disable ? 1: 0;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_brand_info(GF_ISOFile *movie, u32 MajorBrand, u32 MinorVersion)\n{\n\tu32 i, *p;\n\n\tif (!movie) return GF_BAD_PARAM;\n\tif (movie->disable_brand_rewrite) return GF_OK;\n\tif (!MajorBrand) return GF_BAD_PARAM;\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (! (movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY)) {\n\t\tGF_Err e = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\t\tif (e) return e;\n\n\t\te = CheckNoData(movie);\n\t\tif (e) return e;\n\t}\n#endif\n\n\tif (!movie->brand) {\n\t\tmovie->brand = (GF_FileTypeBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_FTYP);\n\t\tif (!movie->brand) return GF_OUT_OF_MEM;\n\t\tgf_list_add(movie->TopBoxes, movie->brand);\n\t}\n\n\tmovie->brand->majorBrand = MajorBrand;\n\tmovie->brand->minorVersion = MinorVersion;\n\n\tif (!movie->brand->altBrand) {\n\t\tmovie->brand->altBrand = (u32*)gf_malloc(sizeof(u32));\n\t\tif (!movie->brand->altBrand) return GF_OUT_OF_MEM;\n\t\tmovie->brand->altBrand[0] = MajorBrand;\n\t\tmovie->brand->altCount = 1;\n\t\treturn GF_OK;\n\t}\n\n\t//if brand already present don't change anything\n\tfor (i=0; i<movie->brand->altCount; i++) {\n\t\tif (movie->brand->altBrand[i] == MajorBrand) return GF_OK;\n\t}\n\tp = (u32*)gf_malloc(sizeof(u32)*(movie->brand->altCount + 1));\n\tif (!p) return GF_OUT_OF_MEM;\n\tmemcpy(p, movie->brand->altBrand, sizeof(u32)*movie->brand->altCount);\n\tp[movie->brand->altCount] = MajorBrand;\n\tmovie->brand->altCount += 1;\n\tgf_free(movie->brand->altBrand);\n\tmovie->brand->altBrand = p;\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_modify_alternate_brand(GF_ISOFile *movie, u32 Brand, Bool AddIt)\n{\n\tu32 i, k, *p;\n\n\tif (!movie) return GF_BAD_PARAM;\n\tif (movie->disable_brand_rewrite) return GF_OK;\n\tif (!Brand) return GF_BAD_PARAM;\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (! (movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY)) {\n\t\tGF_Err e = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\t\tif (e) return e;\n\n\t\te = CheckNoData(movie);\n\t\tif (e) return e;\n\t}\n#endif\n\n\tif (!movie->brand && AddIt) {\n\t\tmovie->brand = (GF_FileTypeBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_FTYP);\n\t\tif (!movie->brand) return GF_OUT_OF_MEM;\n\t\tgf_list_add(movie->TopBoxes, movie->brand);\n\t}\n\tif (!AddIt && !movie->brand) return GF_OK;\n\n\t//do not mofify major one\n\tif (!AddIt && movie->brand->majorBrand == Brand) return GF_OK;\n\n\tif (!AddIt && movie->brand->altCount == 1) {\n\t\t//fixes it in case\n\t\tmovie->brand->altBrand[0] = movie->brand->majorBrand;\n\t\treturn GF_OK;\n\t}\n\t//check for the brand\n\tfor (i=0; i<movie->brand->altCount; i++) {\n\t\tif (movie->brand->altBrand[i] == Brand) goto found;\n\t}\n\t//Not found\n\tif (!AddIt) return GF_OK;\n\t//add it\n\tp = (u32*)gf_malloc(sizeof(u32)*(movie->brand->altCount + 1));\n\tif (!p) return GF_OUT_OF_MEM;\n\tif (movie->brand->altBrand) {\n\t\tmemcpy(p, movie->brand->altBrand, sizeof(u32)*movie->brand->altCount);\n\t\tgf_free(movie->brand->altBrand);\n\t}\n\tp[movie->brand->altCount] = Brand;\n\tmovie->brand->altCount += 1;\n\tmovie->brand->altBrand = p;\n\treturn GF_OK;\n\nfound:\n\n\t//found\n\tif (AddIt) return GF_OK;\n\tassert(movie->brand->altCount>1);\n\n\t//remove it\n\tp = (u32*)gf_malloc(sizeof(u32)*(movie->brand->altCount - 1));\n\tif (!p) return GF_OUT_OF_MEM;\n\tk = 0;\n\tfor (i=0; i<movie->brand->altCount; i++) {\n\t\tif (movie->brand->altBrand[i] == Brand) continue;\n\t\telse {\n\t\t\tp[k] = movie->brand->altBrand[i];\n\t\t\tk++;\n\t\t}\n\t}\n\tmovie->brand->altCount -= 1;\n\tgf_free(movie->brand->altBrand);\n\tmovie->brand->altBrand = p;\n\treturn GF_OK;\n}\n\n\nGF_Err gf_isom_reset_alt_brands_ex(GF_ISOFile *movie, Bool leave_empty)\n{\n\tu32 *p;\n\n\tif (!movie) return GF_BAD_PARAM;\n\tif (movie->disable_brand_rewrite) return GF_OK;\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (! (movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY)) {\n\t\tGF_Err e = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\t\tif (e) return e;\n\n\t\te = CheckNoData(movie);\n\t\tif (e) return e;\n\t}\n#endif\n\n\tif (!movie->brand) {\n\t\tmovie->brand = (GF_FileTypeBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_FTYP);\n\t\tif (!movie->brand) return GF_OUT_OF_MEM;\n\t\tgf_list_add(movie->TopBoxes, movie->brand);\n\t}\n\tgf_free(movie->brand->altBrand);\n\tif (leave_empty) {\n\t\tmovie->brand->altCount = 0;\n\t\tmovie->brand->altBrand = NULL;\n\t} else {\n\t\tp = (u32*)gf_malloc(sizeof(u32));\n\t\tif (!p) return GF_OUT_OF_MEM;\n\t\tp[0] = movie->brand->majorBrand;\n\t\tmovie->brand->altCount = 1;\n\t\tmovie->brand->altBrand = p;\n\t}\n\treturn GF_OK;\n}\nGF_EXPORT\nGF_Err gf_isom_reset_alt_brands(GF_ISOFile *movie)\n{\n\treturn gf_isom_reset_alt_brands_ex(movie, GF_FALSE);\n}\n\n#if 0 //unused\nGF_Err gf_isom_set_sample_padding_bits(GF_ISOFile *movie, u32 trackNumber, u32 sampleNumber, u8 NbBits)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || NbBits > 7) return GF_BAD_PARAM;\n\n\t//set Padding info\n\treturn stbl_SetPaddingBits(trak->Media->information->sampleTable, sampleNumber, NbBits);\n}\n#endif\n\nGF_EXPORT\nGF_Err gf_isom_remove_user_data_item(GF_ISOFile *movie, u32 trackNumber, u32 UserDataType, bin128 UUID, u32 UserDataIndex)\n{\n\tGF_UserDataMap *map;\n\tGF_Box *a;\n\tu32 i;\n\tbin128 t;\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_UserDataBox *udta;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tif (UserDataType == GF_ISOM_BOX_TYPE_UUID) UserDataType = 0;\n\tmemset(t, 1, 16);\n\n\tif (trackNumber) {\n\t\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\tudta = trak->udta;\n\t} else {\n\t\tif (!movie->moov) return GF_BAD_PARAM;\n\t\tudta = movie->moov->udta;\n\t}\n\tif (!udta) return GF_BAD_PARAM;\n\tif (!UserDataIndex) return GF_BAD_PARAM;\n\n\ti=0;\n\twhile ((map = (GF_UserDataMap*)gf_list_enum(udta->recordList, &i))) {\n\t\tif ((map->boxType == GF_ISOM_BOX_TYPE_UUID)  && !memcmp(map->uuid, UUID, 16)) goto found;\n\t\telse if (map->boxType == UserDataType) goto found;\n\t}\n\t//not found\n\treturn GF_OK;\n\nfound:\n\n\tif (UserDataIndex > gf_list_count(map->boxes) ) return GF_BAD_PARAM;\n\t//delete the box\n\ta = (GF_Box*)gf_list_get(map->boxes, UserDataIndex-1);\n\tgf_isom_box_del_parent(&map->boxes, a);\n\n\t//remove the map if empty\n\tif (!gf_list_count(map->boxes)) {\n\t\tgf_list_rem(udta->recordList, i-1);\n\t\tgf_isom_box_array_del(map->boxes);\n\t\tgf_free(map);\n\t}\n\t//but we keep the UDTA no matter what\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_remove_user_data(GF_ISOFile *movie, u32 trackNumber, u32 UserDataType, bin128 UUID)\n{\n\tGF_UserDataMap *map;\n\tu32 i;\n\tGF_Err e;\n\tbin128 t;\n\tGF_TrackBox *trak;\n\tGF_UserDataBox *udta;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tif (UserDataType == GF_ISOM_BOX_TYPE_UUID) UserDataType = 0;\n\tmemset(t, 1, 16);\n\n\tif (trackNumber) {\n\t\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return GF_EOS;\n\t\tudta = trak->udta;\n\t} else {\n\t\tif (!movie->moov) return GF_BAD_PARAM;\n\t\tudta = movie->moov->udta;\n\t}\n\t//do not return any error if no udta\n\tif (!udta) return GF_EOS;\n\n\ti=0;\n\twhile ((map = (GF_UserDataMap*)gf_list_enum(udta->recordList, &i))) {\n\t\tif ((map->boxType == GF_ISOM_BOX_TYPE_UUID)  && !memcmp(map->uuid, UUID, 16)) goto found;\n\t\telse if (map->boxType == UserDataType) goto found;\n\t}\n\t//not found\n\treturn GF_OK;\n\nfound:\n\n\tgf_list_rem(udta->recordList, i-1);\n\tgf_isom_box_array_del(map->boxes);\n\tgf_free(map);\n\n\t//but we keep the UDTA no matter what\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_add_user_data(GF_ISOFile *movie, u32 trackNumber, u32 UserDataType, bin128 UUID, u8 *data, u32 DataLength)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_UserDataBox *udta;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tif (UserDataType == GF_ISOM_BOX_TYPE_UUID) UserDataType = 0;\n\n\tif (trackNumber) {\n\t\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\tif (!trak->udta) trak_on_child_box((GF_Box*)trak, gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_UDTA), GF_FALSE);\n\t\tudta = trak->udta;\n\t} else {\n\t\tif (!movie->moov) return GF_BAD_PARAM;\n\t\tif (!movie->moov->udta) moov_on_child_box((GF_Box*)movie->moov, gf_isom_box_new_parent(&movie->moov->child_boxes, GF_ISOM_BOX_TYPE_UDTA), GF_FALSE);\n\t\tudta = movie->moov->udta;\n\t}\n\tif (!udta) return GF_OUT_OF_MEM;\n\n\t//create a default box\n\tif (UserDataType) {\n\t\tGF_UnknownBox *a = (GF_UnknownBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_UNKNOWN);\n\t\tif (!a) return GF_OUT_OF_MEM;\n\t\ta->original_4cc = UserDataType;\n\t\tif (DataLength) {\n\t\t\ta->data = (char*)gf_malloc(sizeof(char)*DataLength);\n\t\t\tif (!a->data) return GF_OUT_OF_MEM;\n\t\t\tmemcpy(a->data, data, DataLength);\n\t\t\ta->dataSize = DataLength;\n\t\t}\n\t\treturn udta_on_child_box((GF_Box *)udta, (GF_Box *) a, GF_FALSE);\n\t} else if (UUID) {\n\t\tGF_UnknownUUIDBox *a = (GF_UnknownUUIDBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_UUID);\n\t\tif (!a) return GF_OUT_OF_MEM;\n\t\tmemcpy(a->uuid, UUID, 16);\n\t\tif (DataLength) {\n\t\t\ta->data = (char*)gf_malloc(sizeof(char)*DataLength);\n\t\t\tif (!a->data) return GF_OUT_OF_MEM;\n\t\t\tmemcpy(a->data, data, DataLength);\n\t\t\ta->dataSize = DataLength;\n\t\t}\n\t\treturn udta_on_child_box((GF_Box *)udta, (GF_Box *) a, GF_FALSE);\n\t} else {\n\t\treturn GF_BAD_PARAM;\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_add_user_data_boxes(GF_ISOFile *movie, u32 trackNumber, u8 *data, u32 DataLength)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_UserDataBox *udta;\n\tGF_BitStream *bs;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tif (trackNumber) {\n\t\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\tif (!trak->udta) trak_on_child_box((GF_Box*)trak, gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_UDTA), GF_FALSE);\n\t\tudta = trak->udta;\n\t} else {\n\t\tif (!movie->moov) return GF_BAD_PARAM;\n\t\tif (!movie->moov->udta) moov_on_child_box((GF_Box*)movie->moov, gf_isom_box_new_parent(&movie->moov->child_boxes, GF_ISOM_BOX_TYPE_UDTA), GF_FALSE);\n\t\tudta = movie->moov->udta;\n\t}\n\tif (!udta) return GF_OUT_OF_MEM;\n\n\tbs = gf_bs_new(data, DataLength, GF_BITSTREAM_READ);\n\twhile (gf_bs_available(bs)) {\n\t\tGF_Box *a;\n\t\te = gf_isom_box_parse(&a, bs);\n\t\tif (e) break;\n\t\te = udta_on_child_box((GF_Box *)udta, a, GF_FALSE);\n\t\tif (e) break;\n\t}\n\tgf_bs_del(bs);\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_isom_clone_pl_indications(GF_ISOFile *orig, GF_ISOFile *dest)\n{\n\tGF_IsomInitialObjectDescriptor *iod_d;\n\tif (!orig || !dest) return GF_BAD_PARAM;\n\tif (!orig->moov->iods || !orig->moov->iods->descriptor) return GF_OK;\n\tif (orig->moov->iods->descriptor->tag != GF_ODF_ISOM_IOD_TAG) return GF_OK;\n\n\tAddMovieIOD(dest->moov, 1);\n\tgf_odf_desc_del((GF_Descriptor *)dest->moov->iods->descriptor);\n\tgf_odf_desc_copy((GF_Descriptor *)orig->moov->iods->descriptor, (GF_Descriptor **)&dest->moov->iods->descriptor);\n\tiod_d = (GF_IsomInitialObjectDescriptor *) dest->moov->iods->descriptor;\n\twhile (gf_list_count(iod_d->ES_ID_IncDescriptors)) {\n\t\tGF_Descriptor *d = (GF_Descriptor *)gf_list_get(iod_d->ES_ID_IncDescriptors, 0);\n\t\tgf_list_rem(iod_d->ES_ID_IncDescriptors, 0);\n\t\tgf_odf_desc_del(d);\n\t}\n\twhile (gf_list_count(iod_d->ES_ID_RefDescriptors)) {\n\t\tGF_Descriptor *d = (GF_Descriptor *)gf_list_get(iod_d->ES_ID_RefDescriptors, 0);\n\t\tgf_list_rem(iod_d->ES_ID_RefDescriptors, 0);\n\t\tgf_odf_desc_del(d);\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_clone_box(GF_Box *src, GF_Box **dst)\n{\n\tGF_Err e;\n\tu8 *data;\n\tu32 data_size;\n\tGF_BitStream *bs;\n\n\tif (*dst) {\n\t\tgf_isom_box_del(*dst);\n\t\t*dst=NULL;\n\t}\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tif (!bs) return GF_OUT_OF_MEM;\n\te = gf_isom_box_size( (GF_Box *) src);\n\tif (!e) e = gf_isom_box_write((GF_Box *) src, bs);\n\tgf_bs_get_content(bs, &data, &data_size);\n\tgf_bs_del(bs);\n\tif (e) {\n\t\tif (data) gf_free(data);\n\t\treturn e;\n\t}\n\tbs = gf_bs_new(data, data_size, GF_BITSTREAM_READ);\n\tif (!bs) {\n\t\tif (data) gf_free(data);\n\t\treturn GF_OUT_OF_MEM;\n\t}\n\te = gf_isom_box_parse(dst, bs);\n\tgf_bs_del(bs);\n\tgf_free(data);\n\treturn e;\n}\n\n#if 0 //unused\n/*clones the entire movie file to destination. Tracks can be cloned if clone_tracks is set, in which case hint tracks can be\nkept if keep_hint_tracks is set\nif keep_pssh, all pssh boxes will be kept\nfragment information (mvex) is not kept*/\nGF_Err gf_isom_clone_movie(GF_ISOFile *orig_file, GF_ISOFile *dest_file, Bool clone_tracks, Bool keep_hint_tracks, Bool keep_pssh)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_Box *box;\n\n\te = CanAccessMovie(dest_file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tif (orig_file->brand) {\n\t\tgf_list_del_item(dest_file->TopBoxes, dest_file->brand);\n\t\tgf_isom_box_del((GF_Box *)dest_file->brand);\n\t\tdest_file->brand = NULL;\n\t\tgf_isom_clone_box((GF_Box *)orig_file->brand, (GF_Box **)&dest_file->brand);\n\t\tif (dest_file->brand) gf_list_add(dest_file->TopBoxes, dest_file->brand);\n\t}\n\n\tif (orig_file->meta) {\n\t\tgf_list_del_item(dest_file->TopBoxes, dest_file->meta);\n\t\tgf_isom_box_del((GF_Box *)dest_file->meta);\n\t\tdest_file->meta = NULL;\n\t\t/*fixme - check imports*/\n\t\tgf_isom_clone_box((GF_Box *)orig_file->meta, (GF_Box **)&dest_file->meta);\n\t\tif (dest_file->meta) gf_list_add(dest_file->TopBoxes, dest_file->meta);\n\t}\n\tif (orig_file->moov) {\n\t\tu32 i, dstTrack;\n\t\tGF_Box *iods;\n\t\tGF_List *tracks = gf_list_new();\n\t\tGF_List *old_tracks = orig_file->moov->trackList;\n\t\torig_file->moov->trackList = tracks;\n\t\tiods = (GF_Box*)orig_file->moov->iods;\n\t\torig_file->moov->iods = NULL;\n\t\te = gf_isom_clone_box((GF_Box *)orig_file->moov, (GF_Box **)&dest_file->moov);\n\t\tif (e) {\n\t\t\tgf_list_del(tracks);\n\t\t\torig_file->moov->trackList = old_tracks;\n\t\t\treturn e;\n\t\t}\n\t\torig_file->moov->trackList = old_tracks;\n\t\tgf_list_del(tracks);\n\t\torig_file->moov->iods = (GF_ObjectDescriptorBox*)iods;\n\t\tgf_list_add(dest_file->TopBoxes, dest_file->moov);\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\tif (dest_file->moov->mvex) {\n\t\t\tgf_isom_box_del_parent(&dest_file->moov->child_boxes, (GF_Box *)dest_file->moov->mvex);\n\t\t\tdest_file->moov->mvex = NULL;\n\t\t}\n#endif\n\n\t\tif (clone_tracks) {\n\t\t\tfor (i=0; i<gf_list_count(orig_file->moov->trackList); i++) {\n\t\t\t\tGF_TrackBox *trak = (GF_TrackBox*)gf_list_get( orig_file->moov->trackList, i);\n\t\t\t\tif (!trak) continue;\n\t\t\t\tif (keep_hint_tracks || (trak->Media->handler->handlerType != GF_ISOM_MEDIA_HINT)) {\n\t\t\t\t\te = gf_isom_clone_track(orig_file, i+1, dest_file, 0, &dstTrack);\n\t\t\t\t\tif (e) return e;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (iods)\n\t\t\t\tgf_isom_clone_box((GF_Box *)orig_file->moov->iods, (GF_Box **)dest_file->moov->iods);\n\t\t} else {\n\t\t\tdest_file->moov->mvhd->nextTrackID = 1;\n\t\t\tgf_isom_clone_pl_indications(orig_file, dest_file);\n\t\t}\n\t\tdest_file->moov->mov = dest_file;\n\t}\n\n\tif (!keep_pssh) {\n\t\ti=0;\n\t\twhile ((box = (GF_Box*)gf_list_get(dest_file->moov->child_boxes, i++))) {\n\t\t\tif (box->type == GF_ISOM_BOX_TYPE_PSSH) {\n\t\t\t\ti--;\n\t\t\t\tgf_isom_box_del_parent(&dest_file->moov->child_boxes, box);\n\t\t\t}\n\t\t}\n\t}\n\n\t//duplicate other boxes\n\ti=0;\n\twhile ((box = (GF_Box*)gf_list_get(orig_file->TopBoxes, i++))) {\n\t\tswitch(box->type) {\n\t\tcase GF_ISOM_BOX_TYPE_MOOV:\n\t\tcase GF_ISOM_BOX_TYPE_META:\n\t\tcase GF_ISOM_BOX_TYPE_MDAT:\n\t\tcase GF_ISOM_BOX_TYPE_FTYP:\n\t\tcase GF_ISOM_BOX_TYPE_PDIN:\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t\tcase GF_ISOM_BOX_TYPE_STYP:\n\t\tcase GF_ISOM_BOX_TYPE_SIDX:\n\t\tcase GF_ISOM_BOX_TYPE_SSIX:\n\t\tcase GF_ISOM_BOX_TYPE_MOOF:\n#endif\n\t\tcase GF_ISOM_BOX_TYPE_JP:\n\t\t\tbreak;\n\n\t\tcase GF_ISOM_BOX_TYPE_PSSH:\n\t\t\tif (!keep_pssh)\n\t\t\t\tbreak;\n\n\t\tdefault:\n\t\t{\n\t\t\tGF_Box *box2 = NULL;\n\t\t\tgf_isom_clone_box(box, &box2);\n\t\t\tgf_list_add(dest_file->TopBoxes, box2);\n\t\t}\n\t\tbreak;\n\t\t}\n\t}\n\n\treturn GF_OK;\n}\n#endif\n\n\nGF_EXPORT\nGF_Err gf_isom_get_raw_user_data(GF_ISOFile *file, u8 **output, u32 *output_size)\n{\n\tGF_BitStream *bs;\n\tGF_Err e;\n\tGF_Box *b;\n\tu32 i;\n\n\t*output = NULL;\n\t*output_size = 0;\n\tif (!file || !file->moov || (!file->moov->udta && !file->moov->child_boxes)) return GF_OK;\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\tif (file->moov->udta) {\n\t\te = gf_isom_box_size( (GF_Box *) file->moov->udta);\n\t\tif (e) goto exit;\n\t\te = gf_isom_box_write((GF_Box *) file->moov->udta, bs);\n\t\tif (e) goto exit;\n\t}\n\te = GF_OK;\n\ti=0;\n\twhile ((b = gf_list_enum(file->moov->child_boxes, &i))) {\n\t\tswitch (b->type) {\n\t\tcase GF_ISOM_BOX_TYPE_TRAK:\n\t\tcase GF_ISOM_BOX_TYPE_MVHD:\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\tcase GF_ISOM_BOX_TYPE_MVEX:\n#endif\n\t\tcase GF_ISOM_BOX_TYPE_IODS:\n\t\tcase GF_ISOM_BOX_TYPE_META:\n\t\t\tcontinue;\n\t\t}\n\t\te = gf_isom_box_size( (GF_Box *) b);\n\t\tif (e) goto exit;\n\t\te = gf_isom_box_write((GF_Box *) b, bs);\n\t\tif (e) goto exit;\n\t}\n\n\tgf_bs_get_content(bs, output, output_size);\n\nexit:\n\tgf_bs_del(bs);\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_track_template(GF_ISOFile *file, u32 track, u8 **output, u32 *output_size)\n{\n\tGF_TrackBox *trak;\n\tGF_BitStream *bs;\n\tGF_DataReferenceBox *dref;\n\tGF_SampleTableBox *stbl, *stbl_temp;\n\tGF_SampleEncryptionBox *senc;\n\tGF_List *gpac_internals = NULL;\n\tu32 i, count;\n\n\t*output = NULL;\n\t*output_size = 0;\n\t/*get orig sample desc and clone it*/\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak || !trak->Media) return GF_BAD_PARAM;\n\n\t//don't serialize dref\n\tdref = NULL;\n\tif (trak->Media->information->dataInformation) {\n\t\tdref = trak->Media->information->dataInformation->dref;\n\t\ttrak->Media->information->dataInformation->dref = NULL;\n\t\tgf_list_del_item(trak->Media->information->dataInformation->child_boxes, dref);\n\t}\n\n\t//don't serialize stbl but create a temp one\n\tstbl_temp = (GF_SampleTableBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_STBL);\n\tif (!stbl_temp->child_boxes) stbl_temp->child_boxes = gf_list_new();\n\tstbl = trak->Media->information->sampleTable;\n\tgf_list_del_item(trak->Media->information->child_boxes, stbl);\n\n\ttrak->Media->information->sampleTable = stbl_temp;\n\tgf_list_add(trak->Media->information->child_boxes, stbl_temp);\n\n\t/*do not clone sampleDescription table but create an empty one*/\n\tstbl_temp->SampleDescription = (GF_SampleDescriptionBox *) gf_isom_box_new_parent(&stbl_temp->child_boxes, GF_ISOM_BOX_TYPE_STSD);\n\n\t/*clone sampleGroups description tables if any*/\n\tstbl_temp->sampleGroupsDescription = stbl->sampleGroupsDescription;\n\tcount = gf_list_count(stbl->sampleGroupsDescription);\n\tfor (i=0;i<count; i++) {\n\t\tGF_SampleGroupDescriptionBox *b = gf_list_get(stbl->sampleGroupsDescription, i);\n\t\t//don't add our internal sample groups\n\t\tif (b->grouping_type==GF_4CC('E','M','S','G'))\n\t\t\tcontinue;\n\t\tif (b->grouping_type==GF_4CC('P','S','S','H'))\n\t\t\tcontinue;\n\t\tgf_list_add(stbl_temp->child_boxes, b);\n\t}\n\t/*clone CompositionToDecode table, we may remove it later*/\n\tstbl_temp->CompositionToDecode = stbl->CompositionToDecode;\n\tgf_list_add(stbl_temp->child_boxes, stbl->CompositionToDecode);\n\n\n\tcount = gf_list_count(trak->child_boxes);\n\tfor (i=0;i<count; i++) {\n\t\tGF_UnknownBox *b = gf_list_get(trak->child_boxes, i);\n\t\tif (b->type != GF_ISOM_BOX_TYPE_UNKNOWN) continue;\n\t\tif (b->original_4cc==GF_ISOM_BOX_TYPE_GDAT) {\n\t\t\tif (!gpac_internals) gpac_internals = gf_list_new();\n\t\t\tgf_list_add(gpac_internals, b);\n\t\t\tgf_list_rem(trak->child_boxes, i);\n\t\t\ti--;\n\t\t\tcount--;\n\t\t}\n\t}\n\n\t//don't serialize senc\n\tsenc = trak->sample_encryption;\n\tif (senc) {\n\t\tassert(trak->child_boxes);\n\t\tgf_list_del_item(trak->child_boxes, senc);\n\t\ttrak->sample_encryption = NULL;\n\t}\n\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\tgf_isom_box_size( (GF_Box *) trak);\n\tgf_isom_box_write((GF_Box *) trak, bs);\n\tgf_bs_get_content(bs, output, output_size);\n\tgf_bs_del(bs);\n\n\t//restore our pointers\n\tif (dref) {\n\t\ttrak->Media->information->dataInformation->dref = dref;\n\t\tgf_list_add(trak->Media->information->dataInformation->child_boxes, dref);\n\t}\n\ttrak->Media->information->sampleTable = stbl;\n\tgf_list_add(trak->Media->information->child_boxes, stbl);\n\tgf_list_del_item(trak->Media->information->child_boxes, stbl_temp);\n\tif (senc) {\n\t\ttrak->sample_encryption = senc;\n\t\tgf_list_add(trak->child_boxes, senc);\n\t}\n\n\tstbl_temp->sampleGroupsDescription = NULL;\n\tcount = gf_list_count(stbl->sampleGroupsDescription);\n\tfor (i=0;i<count; i++) {\n\t\tGF_Box *b = gf_list_get(stbl->sampleGroupsDescription, i);\n\t\tgf_list_del_item(stbl_temp->child_boxes, b);\n\t}\n\n\tstbl_temp->CompositionToDecode = NULL;\n\tgf_list_del_item(stbl_temp->child_boxes, stbl->CompositionToDecode);\n\tgf_isom_box_del((GF_Box *)stbl_temp);\n\n\tif (gpac_internals) {\n\t\tgf_list_transfer(trak->child_boxes, gpac_internals);\n\t\tgf_list_del(gpac_internals);\n\t}\n\treturn GF_OK;\n\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_trex_template(GF_ISOFile *file, u32 track, u8 **output, u32 *output_size)\n{\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tGF_TrackBox *trak;\n\tGF_BitStream *bs;\n\tu32 i;\n\tGF_TrackExtendsBox *trex = NULL;\n\tGF_TrackExtensionPropertiesBox *trexprop = NULL;\n\n\t*output = NULL;\n\t*output_size = 0;\n\t/*get orig sample desc and clone it*/\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak || !trak->Media) return GF_BAD_PARAM;\n\tif (!file->moov->mvex) return GF_NOT_FOUND;\n\tfor (i=0; i<gf_list_count(file->moov->mvex->TrackExList); i++) {\n\t\ttrex = gf_list_get(file->moov->mvex->TrackExList, i);\n\t\tif (trex->trackID == trak->Header->trackID) break;\n\t\ttrex = NULL;\n\t}\n\tif (!trex) return GF_NOT_FOUND;\n\n\tfor (i=0; i<gf_list_count(file->moov->mvex->TrackExPropList); i++) {\n\t\ttrexprop = gf_list_get(file->moov->mvex->TrackExPropList, i);\n\t\tif (trexprop->trackID== trak->Header->trackID) break;\n\t\ttrexprop = NULL;\n\t}\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tgf_isom_box_size( (GF_Box *) trex);\n\tgf_isom_box_write((GF_Box *) trex, bs);\n\n\tif (trexprop) {\n\t\tgf_isom_box_size( (GF_Box *) trexprop);\n\t\tgf_isom_box_write((GF_Box *) trexprop, bs);\n\t}\n\tgf_bs_get_content(bs, output, output_size);\n\tgf_bs_del(bs);\n\n#else\n\t*output = NULL;\n\t*output_size = 0;\n#endif\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_stsd_template(GF_ISOFile *file, u32 track, u32 stsd_idx, u8 **output, u32 *output_size)\n{\n\tGF_TrackBox *trak;\n\tGF_BitStream *bs;\n\tGF_Box *ent;\n\n\t*output = NULL;\n\t*output_size = 0;\n\t/*get orig sample desc and clone it*/\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->SampleDescription) return GF_BAD_PARAM;\n\n\tif (stsd_idx) {\n\t\tent = gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, stsd_idx-1);\n\t\tif (!ent) return GF_BAD_PARAM;\n\t} else {\n\t\tent = (GF_Box*) trak->Media->information->sampleTable->SampleDescription;\n\t}\n\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\tgf_isom_box_size(ent);\n\tgf_isom_box_write(ent, bs);\n\tgf_bs_get_content(bs, output, output_size);\n\tgf_bs_del(bs);\n\treturn GF_OK;\n\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_clone_track(GF_ISOFile *orig_file, u32 orig_track, GF_ISOFile *dest_file, GF_ISOTrackCloneFlags flags, u32 *dest_track)\n{\n\tGF_TrackBox *trak, *new_tk;\n\tGF_BitStream *bs;\n\tu8 *data;\n\tconst u8 *buffer;\n\tu32 data_size;\n\tu32 i, count;\n\tGF_Err e;\n\tGF_SampleTableBox *stbl, *stbl_temp;\n\tGF_SampleEncryptionBox *senc;\n\n\te = CanAccessMovie(dest_file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\te = gf_isom_insert_moov(dest_file);\n\tif (e) return e;\n\n\t/*get orig sample desc and clone it*/\n\ttrak = gf_isom_get_track_from_file(orig_file, orig_track);\n\tif (!trak || !trak->Media) return GF_BAD_PARAM;\n\n\tstbl = trak->Media->information->sampleTable;\n\tstbl_temp = (GF_SampleTableBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_STBL);\n\tif (!stbl_temp->child_boxes) stbl_temp->child_boxes = gf_list_new();\n\n\ttrak->Media->information->sampleTable = stbl_temp;\n\tgf_list_add(trak->Media->information->child_boxes, stbl_temp);\n\tgf_list_del_item(trak->Media->information->child_boxes, stbl);\n\n\tif (!stbl_temp->child_boxes) stbl_temp->child_boxes = gf_list_new();\n\n\t/*clone sampleDescription table*/\n\tstbl_temp->SampleDescription = stbl->SampleDescription;\n\tgf_list_add(stbl_temp->child_boxes, stbl->SampleDescription);\n\t/*also clone sampleGroups description tables if any*/\n\tstbl_temp->sampleGroupsDescription = stbl->sampleGroupsDescription;\n\tcount = gf_list_count(stbl->sampleGroupsDescription);\n\tfor (i=0; i<count; i++) {\n\t\tGF_Box *b = gf_list_get(stbl->sampleGroupsDescription, i);\n\t\tgf_list_add(stbl_temp->child_boxes, b);\n\t}\n\t/*clone CompositionToDecode table, we may remove it later*/\n\tstbl_temp->CompositionToDecode = stbl->CompositionToDecode;\n\tgf_list_add(stbl_temp->child_boxes, stbl->CompositionToDecode);\n\n\tsenc = trak->sample_encryption;\n\tif (senc) {\n\t\tassert(trak->child_boxes);\n\t\tgf_list_del_item(trak->child_boxes, senc);\n\t\ttrak->sample_encryption = NULL;\n\t}\n\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\tgf_isom_box_size( (GF_Box *) trak);\n\tgf_isom_box_write((GF_Box *) trak, bs);\n\tgf_bs_get_content(bs, &data, &data_size);\n\tgf_bs_del(bs);\n\tbs = gf_bs_new(data, data_size, GF_BITSTREAM_READ);\n\tif (flags & GF_ISOM_CLONE_TRACK_NO_QT)\n\t\tgf_bs_set_cookie(bs, GF_ISOM_BS_COOKIE_QT_CONV | GF_ISOM_BS_COOKIE_CLONE_TRACK);\n\telse\n\t\tgf_bs_set_cookie(bs, GF_ISOM_BS_COOKIE_CLONE_TRACK);\n\n\te = gf_isom_box_parse((GF_Box **) &new_tk, bs);\n\tgf_bs_del(bs);\n\tgf_free(data);\n\n\ttrak->Media->information->sampleTable = stbl;\n\tgf_list_del_item(trak->Media->information->child_boxes, stbl_temp);\n\tgf_list_add(trak->Media->information->child_boxes, stbl);\n\n\tif (senc) {\n\t\ttrak->sample_encryption = senc;\n\t\tgf_list_add(trak->child_boxes, senc);\n\t}\n\tgf_list_del_item(stbl_temp->child_boxes, stbl_temp->SampleDescription);\n\tstbl_temp->SampleDescription = NULL;\n\n\tcount = gf_list_count(stbl->sampleGroupsDescription);\n\tfor (i=0; i<count; i++) {\n\t\tGF_Box *b = gf_list_get(stbl->sampleGroupsDescription, i);\n\t\tgf_list_del_item(stbl_temp->child_boxes, b);\n\t}\n\tstbl_temp->sampleGroupsDescription = NULL;\n\n\tgf_list_del_item(stbl_temp->child_boxes, stbl_temp->CompositionToDecode);\n\tstbl_temp->CompositionToDecode = NULL;\n\tgf_isom_box_del((GF_Box *)stbl_temp);\n\n\tif (e) {\n\t\tif (new_tk) gf_isom_box_del((GF_Box *)new_tk);\n\t\treturn e;\n\t}\n\n\tgf_isom_disable_inplace_rewrite(dest_file);\n\n\t/*create default boxes*/\n\tstbl = new_tk->Media->information->sampleTable;\n\tstbl->ChunkOffset = gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STCO);\n\tif (!stbl->ChunkOffset) return GF_OUT_OF_MEM;\n\tstbl->SampleSize = (GF_SampleSizeBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STSZ);\n\tif (!stbl->SampleSize) return GF_OUT_OF_MEM;\n\tstbl->SampleToChunk = (GF_SampleToChunkBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STSC);\n\tif (!stbl->SampleToChunk) return GF_OUT_OF_MEM;\n\tstbl->TimeToSample = (GF_TimeToSampleBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STTS);\n\tif (!stbl->TimeToSample) return GF_OUT_OF_MEM;\n\n\tif (flags & GF_ISOM_CLONE_TRACK_DROP_ID)\n\t\tnew_tk->Header->trackID = 0;\n\n\t/*check trackID validity before adding track*/\n\tif (!new_tk->Header->trackID || gf_isom_get_track_by_id(dest_file, new_tk->Header->trackID)) {\n\t\tu32 ID = 1;\n\t\twhile (1) {\n\t\t\tif (RequestTrack(dest_file->moov, ID)) break;\n\t\t\tID += 1;\n\t\t\tif (ID == 0xFFFFFFFF) break;\n\t\t}\n\t\tnew_tk->Header->trackID = ID;\n\t}\n\tif (!dest_file->moov->child_boxes) dest_file->moov->child_boxes = gf_list_new();\n\tgf_list_add(dest_file->moov->child_boxes, new_tk);\n\tmoov_on_child_box((GF_Box*)dest_file->moov, (GF_Box *)new_tk, GF_FALSE);\n\n\t/*set originalID*/\n\tnew_tk->originalID = trak->Header->trackID;\n\t/*set originalFile*/\n\tbuffer = gf_isom_get_filename(orig_file);\n\tnew_tk->originalFile = gf_crc_32(buffer, (u32) strlen(buffer));\n\n\t/*rewrite edit list segmentDuration to new movie timescale*/\n\tif (dest_file->moov->mvhd->timeScale != orig_file->moov->mvhd->timeScale) {\n\t\tDouble ts_scale = dest_file->moov->mvhd->timeScale;\n\t\tts_scale /= orig_file->moov->mvhd->timeScale;\n\t\tnew_tk->Header->duration = (u64) (new_tk->Header->duration * ts_scale);\n\t\tif (new_tk->editBox && new_tk->editBox->editList) {\n\t\t\tcount = gf_list_count(new_tk->editBox->editList->entryList);\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tGF_EdtsEntry *ent = (GF_EdtsEntry *)gf_list_get(new_tk->editBox->editList->entryList, i);\n\t\t\t\tent->segmentDuration = (u64) (ent->segmentDuration * ts_scale);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (flags & GF_ISOM_CLONE_RESET_DURATION)\n\t\tnew_tk->Media->mediaHeader->duration = 0;\n\n\tif (!new_tk->Media->information->dataInformation->dref) return GF_BAD_PARAM;\n\n\t/*reset data ref*/\n\tif (! (flags & GF_ISOM_CLONE_TRACK_KEEP_DREF) ) {\n\t\tGF_SampleEntryBox *entry;\n\t\tBool use_alis = GF_FALSE;\n\t\tif (! (flags & GF_ISOM_CLONE_TRACK_NO_QT)) {\n\t\t\tGF_Box *b = gf_list_get(new_tk->Media->information->dataInformation->dref->child_boxes, 0);\n\t\t\tif (b && (b->type==GF_QT_BOX_TYPE_ALIS))\n\t\t\t\tuse_alis = GF_TRUE;\n\t\t}\n\t\tgf_isom_box_array_del(new_tk->Media->information->dataInformation->dref->child_boxes);\n\t\tnew_tk->Media->information->dataInformation->dref->child_boxes = gf_list_new();\n\t\t/*update data ref*/\n\t\tentry = (GF_SampleEntryBox*)gf_list_get(new_tk->Media->information->sampleTable->SampleDescription->child_boxes, 0);\n\t\tif (entry) {\n\t\t\tu32 dref;\n\t\t\tMedia_CreateDataRef(dest_file, new_tk->Media->information->dataInformation->dref, use_alis ?  \"alis\" : NULL, NULL, &dref);\n\t\t\tentry->dataReferenceIndex = dref;\n\t\t}\n\t} else {\n\t\tfor (i=0; i<gf_list_count(new_tk->Media->information->dataInformation->dref->child_boxes); i++) {\n\t\t\tGF_DataEntryBox *dref_entry = (GF_DataEntryBox *)gf_list_get(new_tk->Media->information->dataInformation->dref->child_boxes, i);\n\t\t\tif (dref_entry->flags & 1) {\n\t\t\t\tdref_entry->flags &= ~1;\n\t\t\t\te = Media_SetDrefURL((GF_DataEntryURLBox *)dref_entry, orig_file->fileName, dest_file->finalName);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\t\t}\n\t}\n\n\t//purge all 'gpac' boxes at track level\n\tfor (i=0; i<gf_list_count(new_tk->child_boxes); i++) {\n\t\tGF_UnknownBox *b = (GF_UnknownBox *)gf_list_get(new_tk->child_boxes, i);\n\t\tif (b->type != GF_ISOM_BOX_TYPE_UNKNOWN) continue;\n\t\tif (b->original_4cc==GF_ISOM_BOX_TYPE_GDAT) {\n\t\t\tgf_list_rem(new_tk->child_boxes, i);\n\t\t\ti--;\n\t\t\tgf_isom_box_del((GF_Box*)b);\n\t\t}\n\t}\n\n\t*dest_track = gf_list_count(dest_file->moov->trackList);\n\n\tif (dest_file->moov->mvhd->nextTrackID <= new_tk->Header->trackID)\n\t\tdest_file->moov->mvhd->nextTrackID = new_tk->Header->trackID+1;\n\n\treturn GF_OK;\n}\n\n#if 0\n/*clones all sampleDescription entries in new track, after an optional reset of existing entries*/\nGF_Err gf_isom_clone_sample_descriptions(GF_ISOFile *the_file, u32 trackNumber, GF_ISOFile *orig_file, u32 orig_track, Bool reset_existing)\n{\n\tu32 i;\n\tGF_TrackBox *dst_trak, *src_trak;\n\tGF_Err e = CanAccessMovie(the_file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tdst_trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!dst_trak || !dst_trak->Media) return GF_BAD_PARAM;\n\tsrc_trak = gf_isom_get_track_from_file(orig_file, orig_track);\n\tif (!src_trak || !src_trak->Media) return GF_BAD_PARAM;\n\n\tif (reset_existing) {\n\t\tgf_isom_box_array_del(dst_trak->Media->information->sampleTable->SampleDescription->child_boxes);\n\t\tdst_trak->Media->information->sampleTable->SampleDescription->child_boxes = gf_list_new();\n\t}\n\n\tfor (i=0; i<gf_list_count(src_trak->Media->information->sampleTable->SampleDescription->child_boxes); i++) {\n\t\tu32 outDesc;\n\t\te = gf_isom_clone_sample_description(the_file, trackNumber, orig_file, orig_track, i+1, NULL, NULL, &outDesc);\n\t\tif (e) break;\n\t}\n\treturn e;\n}\n#endif\n\n\nGF_EXPORT\nGF_Err gf_isom_clone_sample_description(GF_ISOFile *the_file, u32 trackNumber, GF_ISOFile *orig_file, u32 orig_track, u32 orig_desc_index, const char *URLname, const char *URNname, u32 *outDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_BitStream *bs;\n\tu8 *data;\n\tu32 data_size;\n\tGF_Box *entry;\n\tGF_Err e;\n\tu32 dataRefIndex;\n    u32 mtype;\n\tu32 internal_type;\n\n\te = CanAccessMovie(the_file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\t/*get orig sample desc and clone it*/\n\ttrak = gf_isom_get_track_from_file(orig_file, orig_track);\n\tif (!trak || !trak->Media) return GF_BAD_PARAM;\n\n\tentry = (GF_Box*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, orig_desc_index-1);\n\tif (!entry) return GF_BAD_PARAM;\n\tinternal_type = ((GF_SampleEntryBox *)entry)->internal_type;\n\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\tgf_isom_box_size(entry);\n\tgf_isom_box_write(entry, bs);\n\tgf_bs_get_content(bs, &data, &data_size);\n\tgf_bs_del(bs);\n\tbs = gf_bs_new(data, data_size, GF_BITSTREAM_READ);\n\te = gf_isom_box_parse(&entry, bs);\n\tgf_bs_del(bs);\n\tgf_free(data);\n\tif (e) return e;\n\tif (entry->type==GF_ISOM_BOX_TYPE_UNKNOWN) {\n\t\tGF_UnknownBox *ubox = (GF_UnknownBox*)entry;\n\t\tif (internal_type == GF_ISOM_SAMPLE_ENTRY_VIDEO) {\n\t\t\tGF_GenericVisualSampleEntryBox *ve = (GF_GenericVisualSampleEntryBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_GNRV);\n\t\t\tve->EntryType = ubox->type;\n\t\t\tve->data = ubox->data;\n\t\t\tve->data_size = ubox->dataSize;\n\t\t\tentry = (GF_Box *) ve;\n\t\t}\n\t\telse if (internal_type == GF_ISOM_SAMPLE_ENTRY_AUDIO) {\n\t\t\tGF_GenericAudioSampleEntryBox *ae = (GF_GenericAudioSampleEntryBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_GNRA);\n\t\t\tae->EntryType = ubox->type;\n\t\t\tae->data = ubox->data;\n\t\t\tae->data_size = ubox->dataSize;\n\t\t\tentry = (GF_Box *) ae;\n\t\t}\n\t\telse {\n\t\t\tGF_GenericSampleEntryBox *ge = (GF_GenericSampleEntryBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_GNRM);\n\t\t\tge->EntryType = ubox->type;\n\t\t\tge->data = ubox->data;\n\t\t\tge->data_size = ubox->dataSize;\n\t\t\tentry = (GF_Box *) ge;\n\t\t}\n\t\tubox->data = NULL;\n\t\tubox->dataSize = 0;\n\t\tgf_isom_box_del((GF_Box *)ubox);\n\t}\n\n\t/*get new track and insert clone*/\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media) goto exit;\n\n\t/*get or create the data ref*/\n\te = Media_FindDataRef(trak->Media->information->dataInformation->dref, (char *)URLname, (char *)URNname, &dataRefIndex);\n\tif (e) goto exit;\n\tif (!dataRefIndex) {\n\t\te = Media_CreateDataRef(the_file, trak->Media->information->dataInformation->dref, (char *)URLname, (char *)URNname, &dataRefIndex);\n\t\tif (e) goto exit;\n\t}\n\tif (!the_file->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\t/*overwrite dref*/\n\t((GF_SampleEntryBox *)entry)->dataReferenceIndex = dataRefIndex;\n\te = gf_list_add(trak->Media->information->sampleTable->SampleDescription->child_boxes, entry);\n\t*outDescriptionIndex = gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes);\n\n\t/*also clone track w/h info*/\n    mtype = gf_isom_get_media_type(the_file, trackNumber);\n\tif (gf_isom_is_video_handler_type(mtype) ) {\n\t\tgf_isom_set_visual_info(the_file, trackNumber, (*outDescriptionIndex), ((GF_VisualSampleEntryBox*)entry)->Width, ((GF_VisualSampleEntryBox*)entry)->Height);\n\t}\n\treturn e;\n\nexit:\n\tgf_isom_box_del(entry);\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_isom_new_generic_sample_description(GF_ISOFile *movie, u32 trackNumber, const char *URLname, const char *URNname, GF_GenericSampleDescription *udesc, u32 *outDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tu8 **wrap_data;\n\tu32 *wrap_size;\n\tu32 dataRefIndex;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media || !udesc) return GF_BAD_PARAM;\n\n\t//get or create the data ref\n\te = Media_FindDataRef(trak->Media->information->dataInformation->dref, (char *)URLname, (char *)URNname, &dataRefIndex);\n\tif (e) return e;\n\tif (!dataRefIndex) {\n\t\te = Media_CreateDataRef(movie, trak->Media->information->dataInformation->dref, (char *)URLname, (char *)URNname, &dataRefIndex);\n\t\tif (e) return e;\n\t}\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tif (gf_isom_is_video_handler_type(trak->Media->handler->handlerType)) {\n\t\tGF_GenericVisualSampleEntryBox *entry;\n\t\t//create a new entry\n\t\tentry = (GF_GenericVisualSampleEntryBox*) gf_isom_box_new(GF_ISOM_BOX_TYPE_GNRV);\n\t\tif (!entry) return GF_OUT_OF_MEM;\n\n\t\tif (!udesc->codec_tag) {\n\t\t\tentry->EntryType = GF_ISOM_BOX_TYPE_UUID;\n\t\t\tmemcpy(entry->uuid, udesc->UUID, sizeof(bin128));\n\t\t} else {\n\t\t\tentry->EntryType = udesc->codec_tag;\n\t\t}\n\t\tif (entry->EntryType == 0) {\n\t\t\tgf_isom_box_del((GF_Box *)entry);\n\t\t\treturn GF_NOT_SUPPORTED;\n\t\t}\n\n\t\tentry->dataReferenceIndex = dataRefIndex;\n\t\tentry->vendor = udesc->vendor_code;\n\t\tentry->version = udesc->version;\n\t\tentry->revision = udesc->revision;\n\t\tentry->temporal_quality = udesc->temporal_quality;\n\t\tentry->spatial_quality = udesc->spatial_quality;\n\t\tentry->Width = udesc->width;\n\t\tentry->Height = udesc->height;\n\t\tstrcpy(entry->compressor_name, udesc->compressor_name);\n\t\tentry->color_table_index = -1;\n\t\tentry->frames_per_sample = 1;\n\t\tentry->horiz_res = udesc->h_res ? udesc->h_res : 0x00480000;\n\t\tentry->vert_res = udesc->v_res ? udesc->v_res : 0x00480000;\n\t\tentry->bit_depth = udesc->depth ? udesc->depth : 0x18;\n\t\twrap_data = &entry->data;\n\t\twrap_size = &entry->data_size;\n\t\te = gf_list_add(trak->Media->information->sampleTable->SampleDescription->child_boxes, entry);\n\t}\n\telse if (trak->Media->handler->handlerType==GF_ISOM_MEDIA_AUDIO) {\n\t\tGF_GenericAudioSampleEntryBox *gena;\n\t\t//create a new entry\n\t\tgena = (GF_GenericAudioSampleEntryBox*) gf_isom_box_new(GF_ISOM_BOX_TYPE_GNRA);\n\t\tif (!gena) return GF_OUT_OF_MEM;\n\n\t\tif (!udesc->codec_tag) {\n\t\t\tgena->EntryType = GF_ISOM_BOX_TYPE_UUID;\n\t\t\tmemcpy(gena->uuid, udesc->UUID, sizeof(bin128));\n\t\t} else {\n\t\t\tgena->EntryType = udesc->codec_tag;\n\t\t}\n\t\tif (gena->EntryType == 0) {\n\t\t\tgf_isom_box_del((GF_Box *)gena);\n\t\t\treturn GF_NOT_SUPPORTED;\n\t\t}\n\n\t\tgena->dataReferenceIndex = dataRefIndex;\n\t\tgena->vendor = udesc->vendor_code;\n\t\tgena->version = udesc->version;\n\t\tgena->revision = udesc->revision;\n\t\tgena->bitspersample = udesc->bits_per_sample ? udesc->bits_per_sample : 16;\n\t\tgena->channel_count = udesc->nb_channels ? udesc->nb_channels : 2;\n\t\tgena->samplerate_hi = udesc->samplerate;\n\t\tgena->samplerate_lo = 0;\n\t\tgena->qtff_mode = udesc->is_qtff ? GF_ISOM_AUDIO_QTFF_ON_NOEXT : GF_ISOM_AUDIO_QTFF_NONE;\n\t\tif (gena->EntryType==GF_QT_SUBTYPE_LPCM) {\n\t\t\tgena->version = 2;\n\t\t\tgena->qtff_mode = GF_ISOM_AUDIO_QTFF_ON_EXT_VALID;\n\t\t\tGF_BitStream *bs = gf_bs_new(gena->extensions, 36, GF_BITSTREAM_WRITE);\n\t\t\tgf_bs_write_u32(bs, 72);\n\t\t\tgf_bs_write_double(bs, udesc->samplerate);\n\t\t\tgf_bs_write_u32(bs, udesc->nb_channels);\n\t\t\tgf_bs_write_u32(bs, 0x7F000000);\n\t\t\tgf_bs_write_u32(bs, gena->bitspersample);\n\t\t\tgf_bs_write_u32(bs, udesc->lpcm_flags);\n\t\t\tgf_bs_write_u32(bs, udesc->nb_channels*gena->bitspersample/8); //constBytesPerAudioPacket\n\t\t\tgf_bs_write_u32(bs, 1); //constLPCMFramesPerAudioPacket\n\t\t\tgf_bs_del(bs);\n\t\t\tgena->revision = 0;\n\t\t\tgena->vendor = 0;\n\t\t\tgena->channel_count = 3;\n\t\t\tgena->bitspersample = 16;\n\t\t\tgena->compression_id = 0xFFFE;\n\t\t\tgena->packet_size = 0;\n\t\t\tgena->samplerate_hi = 1;\n\t\t} else if (udesc->is_qtff) {\n\t\t\tGF_Box *b = gf_isom_box_new_parent(&gena->child_boxes, GF_QT_BOX_TYPE_WAVE);\n\t\t\tGF_ChromaInfoBox *enda = (GF_ChromaInfoBox*) gf_isom_box_new_parent(&b->child_boxes, GF_QT_BOX_TYPE_ENDA);\n\t\t\t((GF_ChromaInfoBox *)enda)->chroma = (udesc->lpcm_flags & (1<<1)) ? 0 : 1;\n\n\t\t\tGF_UnknownBox *term = (GF_UnknownBox*) gf_isom_box_new_parent(&b->child_boxes, GF_ISOM_BOX_TYPE_UNKNOWN);\n\t\t\tif (term) term->original_4cc = 0;\n\t\t}\n\n\t\twrap_data = &gena->data;\n\t\twrap_size = &gena->data_size;\n\t\te = gf_list_add(trak->Media->information->sampleTable->SampleDescription->child_boxes, gena);\n\t}\n\telse {\n\t\tGF_GenericSampleEntryBox *genm;\n\t\t//create a new entry\n\t\tgenm = (GF_GenericSampleEntryBox*) gf_isom_box_new(GF_ISOM_BOX_TYPE_GNRM);\n\t\tif (!genm) return GF_OUT_OF_MEM;\n\n\t\tif (!udesc->codec_tag) {\n\t\t\tgenm->EntryType = GF_ISOM_BOX_TYPE_UUID;\n\t\t\tmemcpy(genm->uuid, udesc->UUID, sizeof(bin128));\n\t\t} else {\n\t\t\tgenm->EntryType = udesc->codec_tag;\n\t\t}\n\t\tif (genm->EntryType == 0) {\n\t\t\tgf_isom_box_del((GF_Box *)genm);\n\t\t\treturn GF_NOT_SUPPORTED;\n\t\t}\n\t\tgenm->dataReferenceIndex = dataRefIndex;\n\t\twrap_data = &genm->data;\n\t\twrap_size = &genm->data_size;\n\t\te = gf_list_add(trak->Media->information->sampleTable->SampleDescription->child_boxes, genm);\n\t}\n\t*outDescriptionIndex = gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes);\n\n\tif (udesc->extension_buf && udesc->extension_buf_size) {\n\t\tGF_BitStream *bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\tif (udesc->ext_box_wrap) {\n\t\t\tgf_bs_write_u32(bs, 8+udesc->extension_buf_size);\n\t\t\tgf_bs_write_u32(bs, udesc->ext_box_wrap);\n\t\t}\n\t\tgf_bs_write_data(bs, udesc->extension_buf, udesc->extension_buf_size);\n\t\tgf_bs_get_content(bs, wrap_data, wrap_size);\n\t\tgf_bs_del(bs);\n\t}\n\treturn e;\n}\n\n//use carefully. Very useful when you made a lot of changes (IPMP, IPI, OCI, ...)\n//THIS WILL REPLACE THE WHOLE DESCRIPTOR ...\n#if 0 //unused\n/*change the data field of an unknown sample description*/\nGF_Err gf_isom_change_generic_sample_description(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, GF_GenericSampleDescription *udesc)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tGF_GenericVisualSampleEntryBox *entry;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media || !StreamDescriptionIndex) return GF_BAD_PARAM;\n\n\tentry = (GF_GenericVisualSampleEntryBox *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, StreamDescriptionIndex-1);\n\tif (!entry) return GF_BAD_PARAM;\n\tif (entry->type == GF_ISOM_BOX_TYPE_GNRV) {\n\t\tentry->vendor = udesc->vendor_code;\n\t\tentry->version = udesc->version;\n\t\tentry->revision = udesc->revision;\n\t\tentry->temporal_quality = udesc->temporal_quality;\n\t\tentry->spatial_quality = udesc->spatial_quality;\n\t\tentry->Width = udesc->width;\n\t\tentry->Height = udesc->height;\n\t\tstrcpy(entry->compressor_name, udesc->compressor_name);\n\t\tentry->color_table_index = -1;\n\t\tentry->frames_per_sample = 1;\n\t\tentry->horiz_res = udesc->h_res ? udesc->h_res : 0x00480000;\n\t\tentry->vert_res = udesc->v_res ? udesc->v_res : 0x00480000;\n\t\tentry->bit_depth = udesc->depth ? udesc->depth : 0x18;\n\t\tif (entry->data) gf_free(entry->data);\n\t\tentry->data = NULL;\n\t\tentry->data_size = 0;\n\t\tif (udesc->extension_buf && udesc->extension_buf_size) {\n\t\t\tentry->data = (char*)gf_malloc(sizeof(char) * udesc->extension_buf_size);\n\t\t\tif (!entry->data) {\n\t\t\t\tgf_isom_box_del((GF_Box *) entry);\n\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t}\n\t\t\tmemcpy(entry->data, udesc->extension_buf, udesc->extension_buf_size);\n\t\t\tentry->data_size = udesc->extension_buf_size;\n\t\t}\n\t\treturn GF_OK;\n\t} else if (entry->type == GF_ISOM_BOX_TYPE_GNRA) {\n\t\tGF_GenericAudioSampleEntryBox *gena = (GF_GenericAudioSampleEntryBox *)entry;\n\t\tgena->vendor = udesc->vendor_code;\n\t\tgena->version = udesc->version;\n\t\tgena->revision = udesc->revision;\n\t\tgena->bitspersample = udesc->bits_per_sample ? udesc->bits_per_sample : 16;\n\t\tgena->channel_count = udesc->nb_channels ? udesc->nb_channels : 2;\n\t\tgena->samplerate_hi = udesc->samplerate;\n\t\tgena->samplerate_lo = 0;\n\t\tif (gena->data) gf_free(gena->data);\n\t\tgena->data = NULL;\n\t\tgena->data_size = 0;\n\n\t\tif (udesc->extension_buf && udesc->extension_buf_size) {\n\t\t\tgena->data = (char*)gf_malloc(sizeof(char) * udesc->extension_buf_size);\n\t\t\tif (!gena->data) {\n\t\t\t\tgf_isom_box_del((GF_Box *) gena);\n\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t}\n\t\t\tmemcpy(gena->data, udesc->extension_buf, udesc->extension_buf_size);\n\t\t\tgena->data_size = udesc->extension_buf_size;\n\t\t}\n\t\treturn GF_OK;\n\t} else if (entry->type == GF_ISOM_BOX_TYPE_GNRM) {\n\t\tGF_GenericSampleEntryBox *genm = (GF_GenericSampleEntryBox *)entry;\n\t\tif (genm->data) gf_free(genm->data);\n\t\tgenm->data = NULL;\n\t\tgenm->data_size = 0;\n\n\t\tif (udesc->extension_buf && udesc->extension_buf_size) {\n\t\t\tgenm->data = (char*)gf_malloc(sizeof(char) * udesc->extension_buf_size);\n\t\t\tif (!genm->data) {\n\t\t\t\tgf_isom_box_del((GF_Box *) genm);\n\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t}\n\t\t\tmemcpy(genm->data, udesc->extension_buf, udesc->extension_buf_size);\n\t\t\tgenm->data_size = udesc->extension_buf_size;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\treturn GF_BAD_PARAM;\n}\n#endif\n\n#if 0\n/*removes given stream description*/\nGF_Err gf_isom_remove_sample_description(GF_ISOFile *movie, u32 trackNumber, u32 streamDescIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tGF_Box *entry;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media || !streamDescIndex) return GF_BAD_PARAM;\n\tentry = (GF_Box*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, streamDescIndex-1);\n\tif (!entry) return GF_BAD_PARAM;\n\tgf_list_rem(trak->Media->information->sampleTable->SampleDescription->child_boxes, streamDescIndex-1);\n\tgf_isom_box_del(entry);\n\treturn GF_OK;\n}\n#endif\n\n//sets a track reference\nGF_EXPORT\nGF_Err gf_isom_set_track_reference(GF_ISOFile *the_file, u32 trackNumber, u32 referenceType, GF_ISOTrackID ReferencedTrackID)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_TrackReferenceBox *tref;\n\tGF_TrackReferenceTypeBox *dpnd;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\t//no tref, create one\n\ttref = trak->References;\n\tif (!tref) {\n\t\ttref = (GF_TrackReferenceBox *) gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_TREF);\n\t\tif (!tref) return GF_OUT_OF_MEM;\n\t\te = trak_on_child_box((GF_Box*)trak, (GF_Box *) tref, GF_FALSE);\n\t\tif (e) return e;\n\t}\n\t//find a ref of the given type\n\te = Track_FindRef(trak, referenceType, &dpnd);\n\tif (e) return e;\n\n\tif (!dpnd) {\n\t\tdpnd = (GF_TrackReferenceTypeBox *) gf_isom_box_new_parent(&tref->child_boxes, GF_ISOM_BOX_TYPE_REFT);\n\t\tif (!dpnd) return GF_OUT_OF_MEM;\n\t\tdpnd->reference_type = referenceType;\n\t}\n\t//add the ref\n\treturn reftype_AddRefTrack(dpnd, ReferencedTrackID, NULL);\n}\n\nGF_EXPORT\nGF_Err gf_isom_purge_track_reference(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\tGF_TrackReferenceTypeBox *ref;\n\tu32 i=0;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\t//no tref, nothing to remove\n\tif (!trak->References) return GF_OK;\n\n\twhile ((ref = gf_list_enum(trak->References->child_boxes, &i))) {\n\t\tu32 k;\n\t\tif (!ref->reference_type) continue;\n\n\t\tfor (k=0; k<ref->trackIDCount; k++) {\n\t\t\tu32 tk = gf_isom_get_track_by_id(the_file, ref->trackIDs[k]);\n\t\t\tif (!tk) {\n\t\t\t\tmemmove(&ref->trackIDs[k], &ref->trackIDs[k+1], ref->trackIDCount-k-1);\n\t\t\t\tk--;\n\t\t\t\tref->trackIDCount--;\n\t\t\t}\n\t\t}\n\t\tif (!ref->trackIDCount) {\n\t\t\ti--;\n\t\t\tgf_isom_box_del_parent(&trak->References->child_boxes, (GF_Box *) ref);\n\t\t}\n\t}\n\tif (!trak->References->child_boxes || !gf_list_count(trak->References->child_boxes)) {\n\t\tgf_isom_box_del_parent(&trak->child_boxes, (GF_Box *) trak->References);\n\t\ttrak->References = NULL;\n\t}\n\treturn GF_OK;\n}\n\n//sets a track reference\nGF_EXPORT\nGF_Err gf_isom_remove_track_references(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tif (trak->References) {\n\t\tgf_isom_box_del_parent(&trak->child_boxes, (GF_Box *)trak->References);\n\t\ttrak->References = NULL;\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_remove_track_reference(GF_ISOFile *isom_file, u32 trackNumber, u32 ref_type)\n{\n\tGF_TrackBox *trak;\n\tu32 i=0;\n\tGF_TrackReferenceTypeBox *ref;\n\ttrak = gf_isom_get_track_from_file(isom_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tif (!trak->References) return GF_OK;\n\twhile ((ref = gf_list_enum(trak->References->child_boxes, &i))) {\n\t\tif (ref->reference_type == ref_type) {\n\t\t\tgf_isom_box_del_parent(&trak->References->child_boxes, (GF_Box *)ref);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!gf_list_count(trak->References->child_boxes)) {\n\t\tgf_isom_box_del_parent(&trak->child_boxes, (GF_Box *)trak->References);\n\t\ttrak->References = NULL;\n\t}\n\treturn GF_OK;\n\n}\n\n//changes track ID\nGF_EXPORT\nGF_Err gf_isom_set_track_id(GF_ISOFile *movie, u32 trackNumber, GF_ISOTrackID trackID)\n{\n\tGF_TrackReferenceTypeBox *ref;\n\tGF_TrackBox *trak, *a_trak;\n\tu32 i, j, k;\n\n\tif (!movie) return GF_BAD_PARAM;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (trak && (trak->Header->trackID==trackID)) return GF_OK;\n\ta_trak = gf_isom_get_track_from_id(movie->moov, trackID);\n\tif (!trak || a_trak) return GF_BAD_PARAM;\n\n\t/*rewrite all dependencies*/\n\ti=0;\n\twhile ((a_trak = (GF_TrackBox*)gf_list_enum(movie->moov->trackList, &i))) {\n\t\tif (!a_trak->References) continue;\n\t\tj=0;\n\t\twhile ((ref = (GF_TrackReferenceTypeBox *)gf_list_enum(a_trak->References->child_boxes, &j))) {\n\t\t\tfor (k=0; k<ref->trackIDCount; k++) {\n\t\t\t\tif (ref->trackIDs[k]==trak->Header->trackID) {\n\t\t\t\t\tref->trackIDs[k] = trackID;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/*and update IOD if any*/\n\tif (movie->moov->iods && movie->moov->iods->descriptor) {\n\t\tGF_ES_ID_Inc *inc;\n\t\tGF_IsomObjectDescriptor *od = (GF_IsomObjectDescriptor *)movie->moov->iods->descriptor;\n\n\t\ti=0;\n\t\twhile ((inc = (GF_ES_ID_Inc*)gf_list_enum(od->ES_ID_IncDescriptors, &i))) {\n\t\t\tif (inc->trackID==trak->Header->trackID) inc->trackID = trackID;\n\t\t}\n\t}\n\ttrak->Header->trackID = trackID;\n\tupdate_next_track_id(movie);\n\treturn GF_OK;\n}\n\n/*force to rewrite all dependencies when the trackID of referenced track changes*/\nGF_EXPORT\nGF_Err gf_isom_rewrite_track_dependencies(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_TrackReferenceTypeBox *ref;\n\tGF_TrackBox *trak, *a_trak;\n\tu32 i, k;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak)\n\t\treturn GF_BAD_PARAM;\n\tif (!trak->References)\n\t\treturn GF_OK;\n\n\ti=0;\n\twhile ((ref = (GF_TrackReferenceTypeBox *)gf_list_enum(trak->References->child_boxes, &i))) {\n\t\tfor (k=0; k < ref->trackIDCount; k++) {\n\t\t\ta_trak = gf_isom_get_track_from_original_id(movie->moov, ref->trackIDs[k], trak->originalFile);\n\t\t\tif (a_trak) {\n\t\t\t\tref->trackIDs[k] = a_trak->Header->trackID;\n\t\t\t} else {\n\t\t\t\ta_trak = gf_isom_get_track_from_id(movie->moov, ref->trackIDs[k]);\n\t\t\t\t/*we should have a track with no original ID (not imported) - should we rewrite the dependency ?*/\n\t\t\t\tif (! a_trak || a_trak->originalID) return GF_BAD_PARAM;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn GF_OK;\n}\n\n#if 0 //unused\n\n/*! changes the sample description index of a sample\n\\param isom_file the destination ISO file\n\\param trackNumber the destination track\n\\param sampleNum the target sample number\n\\param fnewSampleDescIndex the new sample description index to assign to the sample\n\\return error if any\n*/\nGF_EXPORT\nGF_Err gf_isom_change_sample_desc_index(GF_ISOFile *the_file, u32 trackNumber, u32 sample_number, u32 newSampleDescIndex)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !sample_number || !newSampleDescIndex) return GF_BAD_PARAM;\n\tif (!trak->is_unpacked) {\n\t\tunpack_track(trak);\n\t}\n\tif (!trak->Media->information->sampleTable->SampleToChunk) return GF_BAD_PARAM;\n\tif (trak->Media->information->sampleTable->SampleToChunk->nb_entries < sample_number) return GF_BAD_PARAM;\n\ttrak->Media->information->sampleTable->SampleToChunk->entries[sample_number-1].sampleDescriptionIndex = newSampleDescIndex;\n\treturn GF_OK;\n}\n\n/*modify CTS offset of a given sample (used for B-frames) - MUST be called in unpack mode only*/\nGF_EXPORT\nGF_Err gf_isom_modify_cts_offset(GF_ISOFile *the_file, u32 trackNumber, u32 sample_number, u32 offset)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\tif (!trak->Media->information->sampleTable->CompositionOffset) return GF_BAD_PARAM;\n\tif (!trak->Media->information->sampleTable->CompositionOffset->unpack_mode) return GF_BAD_PARAM;\n\t/*we're in unpack mode: one entry per sample*/\n\ttrak->Media->information->sampleTable->CompositionOffset->entries[sample_number - 1].decodingOffset = offset;\n\treturn GF_OK;\n}\n#endif\n\nGF_EXPORT\nGF_Err gf_isom_shift_cts_offset(GF_ISOFile *the_file, u32 trackNumber, s32 offset_shift)\n{\n\tu32 i;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\tif (!trak->Media->information->sampleTable->CompositionOffset) return GF_BAD_PARAM;\n\tif (!trak->Media->information->sampleTable->CompositionOffset->unpack_mode) return GF_BAD_PARAM;\n\n\tGF_CompositionOffsetBox *ctso = trak->Media->information->sampleTable->CompositionOffset;\n\tfor (i=0; i<ctso->nb_entries; i++) {\n\t\ts64 new_ts = ctso->entries[i].decodingOffset;\n\t\tnew_ts -= offset_shift;\n\t\t/*we're in unpack mode: one entry per sample*/\n\t\tctso->entries[i].decodingOffset = (s32) new_ts;\n\t}\n\tif (trak->Media->mediaHeader->duration >= -offset_shift) {\n\t\ts64 new_dur = trak->Media->mediaHeader->duration;\n\t\tnew_dur -= offset_shift;\n\t\tif (new_dur<0) new_dur = 0;\n\t\ttrak->Media->mediaHeader->duration = (u32) new_dur;\n\t}\n\treturn GF_OK;\n}\n\n#if 0 //unused\nGF_Err gf_isom_remove_cts_info(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_SampleTableBox *stbl;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstbl = trak->Media->information->sampleTable;\n\tif (!stbl->CompositionOffset) return GF_OK;\n\n\tgf_isom_box_del_parent(&stbl->child_boxes, (GF_Box *)stbl->CompositionOffset);\n\tstbl->CompositionOffset = NULL;\n\treturn GF_OK;\n}\n#endif\n\nGF_EXPORT\nGF_Err gf_isom_set_cts_packing(GF_ISOFile *the_file, u32 trackNumber, Bool unpack)\n{\n\tGF_Err e;\n\tGF_Err stbl_repackCTS(GF_CompositionOffsetBox *ctts);\n\tGF_Err stbl_unpackCTS(GF_SampleTableBox *stbl);\n\tGF_SampleTableBox *stbl;\n\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstbl = trak->Media->information->sampleTable;\n\tif (unpack) {\n\t\tif (!stbl->CompositionOffset) {\n\t\t\tstbl->CompositionOffset = (GF_CompositionOffsetBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_CTTS);\n\t\t\tif (!stbl->CompositionOffset) return GF_OUT_OF_MEM;\n\t\t}\n\t\te = stbl_unpackCTS(stbl);\n\t} else {\n\t\tif (!stbl->CompositionOffset) return GF_OK;\n\t\te = stbl_repackCTS(stbl->CompositionOffset);\n\t}\n\tif (e) return e;\n\treturn SetTrackDuration(trak);\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_track_matrix(GF_ISOFile *the_file, u32 trackNumber, s32 matrix[9])\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Header) return GF_BAD_PARAM;\n\tmemcpy(trak->Header->matrix, matrix, sizeof(trak->Header->matrix));\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_track_layout_info(GF_ISOFile *the_file, u32 trackNumber, u32 width, u32 height, s32 translation_x, s32 translation_y, s16 layer)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Header) return GF_BAD_PARAM;\n\ttrak->Header->width = width;\n\ttrak->Header->height = height;\n\ttrak->Header->matrix[6] = translation_x;\n\ttrak->Header->matrix[7] = translation_y;\n\ttrak->Header->layer = layer;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_media_timescale(GF_ISOFile *the_file, u32 trackNumber, u32 newTS, u32 new_tsinc, u32 force_rescale_type)\n{\n\tDouble scale;\n\tu32 old_ts_inc=0;\n\tu32 old_timescale;\n\tGF_TrackBox *trak;\n\tGF_SampleTableBox *stbl;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->mediaHeader) return GF_BAD_PARAM;\n\tif ((trak->Media->mediaHeader->timeScale==newTS) && !new_tsinc)\n\t\treturn GF_EOS;\n\n\tif (!newTS) newTS = trak->Media->mediaHeader->timeScale;\n\tscale = newTS;\n\tscale /= trak->Media->mediaHeader->timeScale;\n\told_timescale = trak->Media->mediaHeader->timeScale;\n\ttrak->Media->mediaHeader->timeScale = newTS;\n\n\tstbl = trak->Media->information->sampleTable;\n\tif (new_tsinc) {\n\t\tu32 i;\n\t\tif (!stbl->TimeToSample || !stbl->TimeToSample->nb_entries)\n\t\t\treturn GF_BAD_PARAM;\n\n\t\tfor (i=0; i<stbl->TimeToSample->nb_entries; i++) {\n\t\t\tif (!old_ts_inc)\n\t\t\t\told_ts_inc = stbl->TimeToSample->entries[i].sampleDelta;\n\t\t\telse if (old_ts_inc<stbl->TimeToSample->entries[i].sampleDelta)\n\t\t\t\told_ts_inc = stbl->TimeToSample->entries[i].sampleDelta;\n\t\t}\n\n\t\tif ((old_timescale==newTS) && (old_ts_inc==new_tsinc) && (force_rescale_type!=2) )\n\t\t\treturn GF_EOS;\n\n\t\tif (!force_rescale_type)\n\t\t\tforce_rescale_type = 1;\n\t\telse if (force_rescale_type==2) {\n\t\t\tgf_free(stbl->TimeToSample->entries);\n\t\t\tstbl->TimeToSample->alloc_size = 1;\n\t\t\tstbl->TimeToSample->nb_entries = 1;\n\t\t\tstbl->TimeToSample->entries = gf_malloc(sizeof(GF_SttsEntry));\n\t\t\tstbl->TimeToSample->entries[0].sampleDelta = new_tsinc;\n\t\t\tstbl->TimeToSample->entries[0].sampleCount = stbl->SampleSize->sampleCount;\n\t\t}\n\n\n\t\tfor (i=0; i<stbl->TimeToSample->nb_entries; i++) {\n\t\t\tstbl->TimeToSample->entries[i].sampleDelta = new_tsinc;\n\t\t}\n\n\t\tif (stbl->CompositionOffset) {\n\t\t\tfor (i=0; i<stbl->CompositionOffset->nb_entries; i++) {\n\t\t\t\tu32 old_offset = stbl->CompositionOffset->entries[i].decodingOffset;\n\t\t\t\tif (force_rescale_type==2) {\n\t\t\t\t\tu32 val = old_offset ;\n\t\t\t\t\t//get number of TS delta\n\t\t\t\t\told_offset /= old_ts_inc;\n\t\t\t\t\tif (old_offset * old_ts_inc < val)\n\t\t\t\t\t\told_offset++;\n\t\t\t\t\told_offset *= new_tsinc;\n\t\t\t\t} else {\n\t\t\t\t\told_offset *= new_tsinc;\n\t\t\t\t\told_offset /= old_ts_inc;\n\t\t\t\t}\n\t\t\t\tstbl->CompositionOffset->entries[i].decodingOffset = old_offset;\n\t\t\t}\n\t\t}\n\n#define RESCALE_TSVAL(_tsval) {\\\n\t\t\ts64 val = ((s64) _tsval) * new_tsinc;\\\n\t\t\tval /= old_ts_inc;\\\n\t\t\t_tsval = (s32) val;\\\n\t\t}\n\n\t\tif (stbl->CompositionToDecode) {\n\t\t\tRESCALE_TSVAL(stbl->CompositionToDecode->compositionEndTime)\n\t\t\tRESCALE_TSVAL(stbl->CompositionToDecode->compositionStartTime)\n\t\t\tRESCALE_TSVAL(stbl->CompositionToDecode->compositionToDTSShift)\n\t\t\tRESCALE_TSVAL(stbl->CompositionToDecode->greatestDecodeToDisplayDelta)\n\t\t\tRESCALE_TSVAL(stbl->CompositionToDecode->leastDecodeToDisplayDelta)\n\t\t}\n\t\tif (trak->editBox) {\n\t\t\tGF_EdtsEntry *ent;\n\t\t\ti=0;\n\t\t\twhile ((ent = (GF_EdtsEntry*)gf_list_enum(trak->editBox->editList->entryList, &i))) {\n\t\t\t\tRESCALE_TSVAL(ent->mediaTime)\n\t\t\t}\n\t\t}\n#undef RESCALE_TSVAL\n\t\t//force recompute of duration\n\t\ttrak->Media->mediaHeader->duration=0;\n\t\treturn SetTrackDuration(trak);\n\t}\n\n\t//rescale timings\n\tu32 i, k, idx, last_delta;\n\tu64 cur_dts;\n\tu64*DTSs = NULL;\n\ts64*CTSs = NULL;\n\n\tif (trak->editBox) {\n\t\tGF_EdtsEntry *ent;\n\t\ti=0;\n\t\twhile ((ent = (GF_EdtsEntry*)gf_list_enum(trak->editBox->editList->entryList, &i))) {\n\t\t\t//only update if media time is >=0 (neg means empty edit)\n\t\t\tif (ent->mediaTime>=0)\n\t\t\t\tent->mediaTime = (u32) (scale*ent->mediaTime);\n\t\t}\n\t}\n\tif (! stbl || !stbl->TimeToSample || !stbl->TimeToSample->nb_entries) {\n\t\treturn SetTrackDuration(trak);\n\t}\n\n\tidx = 0;\n\tcur_dts = 0;\n\t//unpack the DTSs\n\tDTSs = (u64*)gf_malloc(sizeof(u64) * (stbl->SampleSize->sampleCount) );\n\tif (!DTSs) return GF_OUT_OF_MEM;\n\n\tCTSs = NULL;\n\tif (stbl->CompositionOffset) {\n\t\tCTSs = (s64*)gf_malloc(sizeof(u64) * (stbl->SampleSize->sampleCount) );\n\t\tif (!CTSs) return GF_OUT_OF_MEM;\n\t}\n\n\tfor (i=0; i<stbl->TimeToSample->nb_entries; i++) {\n\t\tfor (k=0; k<stbl->TimeToSample->entries[i].sampleCount; k++) {\n\t\t\tcur_dts += stbl->TimeToSample->entries[i].sampleDelta;\n\t\t\tDTSs[idx] = (u64) (cur_dts * scale);\n\n\t\t\tif (stbl->CompositionOffset) {\n\t\t\t\ts32 cts_o;\n\t\t\t\tstbl_GetSampleCTS(stbl->CompositionOffset, idx+1, &cts_o);\n\t\t\t\tCTSs[idx] = (s64) ( ((s64) cur_dts + cts_o) * scale);\n\t\t\t}\n\t\t\tidx++;\n\t\t}\n\t}\n\tlast_delta = (u32) (stbl->TimeToSample->entries[stbl->TimeToSample->nb_entries-1].sampleDelta * scale);\n\n\t//repack DTS\n\tif (stbl->SampleSize->sampleCount) {\n\t\tstbl->TimeToSample->entries = gf_realloc(stbl->TimeToSample->entries, sizeof(GF_SttsEntry)*stbl->SampleSize->sampleCount);\n\t\tmemset(stbl->TimeToSample->entries, 0, sizeof(GF_SttsEntry)*stbl->SampleSize->sampleCount);\n\t\tstbl->TimeToSample->entries[0].sampleDelta = (u32) DTSs[0];\n\t\tstbl->TimeToSample->entries[0].sampleCount = 1;\n\t\tidx=0;\n\t\tfor (i=1; i< stbl->SampleSize->sampleCount - 1; i++) {\n\t\t\tif (DTSs[i+1] - DTSs[i] == stbl->TimeToSample->entries[idx].sampleDelta) {\n\t\t\t\tstbl->TimeToSample->entries[idx].sampleCount++;\n\t\t\t} else {\n\t\t\t\tidx++;\n\t\t\t\tstbl->TimeToSample->entries[idx].sampleDelta = (u32) ( DTSs[i+1] - DTSs[i] );\n\t\t\t\tstbl->TimeToSample->entries[idx].sampleCount=1;\n\t\t\t}\n\t\t}\n\t\tif (stbl->SampleSize->sampleCount > 1) {\n\t\t\t//add the sample delta for the last sample\n\t\t\tif (stbl->TimeToSample->entries[idx].sampleDelta == last_delta) {\n\t\t\t\tstbl->TimeToSample->entries[idx].sampleCount++;\n\t\t\t} else {\n\t\t\t\tidx++;\n\t\t\t\tstbl->TimeToSample->entries[idx].sampleDelta = last_delta;\n\t\t\t\tstbl->TimeToSample->entries[idx].sampleCount=1;\n\t\t\t}\n\n\t\t\tstbl->TimeToSample->nb_entries = idx+1;\n\t\t\tstbl->TimeToSample->entries = gf_realloc(stbl->TimeToSample->entries, sizeof(GF_SttsEntry)*stbl->TimeToSample->nb_entries);\n\t\t}\n\t}\n\n\tif (CTSs && stbl->SampleSize->sampleCount>0) {\n\t\t//repack CTS\n\t\tstbl->CompositionOffset->entries = gf_realloc(stbl->CompositionOffset->entries, sizeof(GF_DttsEntry)*stbl->SampleSize->sampleCount);\n\t\tmemset(stbl->CompositionOffset->entries, 0, sizeof(GF_DttsEntry)*stbl->SampleSize->sampleCount);\n\t\tstbl->CompositionOffset->entries[0].decodingOffset = (s32) (CTSs[0] - DTSs[0]);\n\t\tstbl->CompositionOffset->entries[0].sampleCount = 1;\n\t\tidx=0;\n\t\tfor (i=1; i< stbl->SampleSize->sampleCount; i++) {\n\t\t\ts32 cts_o = (s32) (CTSs[i] - DTSs[i]);\n\t\t\tif (cts_o == stbl->CompositionOffset->entries[idx].decodingOffset) {\n\t\t\t\tstbl->CompositionOffset->entries[idx].sampleCount++;\n\t\t\t} else {\n\t\t\t\tidx++;\n\t\t\t\tstbl->CompositionOffset->entries[idx].decodingOffset = cts_o;\n\t\t\t\tstbl->CompositionOffset->entries[idx].sampleCount=1;\n\t\t\t}\n\t\t}\n\t\tstbl->CompositionOffset->nb_entries = idx+1;\n\t\tstbl->CompositionOffset->entries = gf_realloc(stbl->CompositionOffset->entries, sizeof(GF_DttsEntry)*stbl->CompositionOffset->nb_entries);\n\n\t\tgf_free(CTSs);\n\t}\n\tgf_free(DTSs);\n\n\tif (stbl->CompositionToDecode) {\n\t\tstbl->CompositionToDecode->compositionEndTime = (s32) (stbl->CompositionToDecode->compositionEndTime * scale);\n\t\tstbl->CompositionToDecode->compositionStartTime = (s32)(stbl->CompositionToDecode->compositionStartTime * scale);\n\t\tstbl->CompositionToDecode->compositionToDTSShift = (s32)(stbl->CompositionToDecode->compositionToDTSShift * scale);\n\t\tstbl->CompositionToDecode->greatestDecodeToDisplayDelta = (s32)(stbl->CompositionToDecode->greatestDecodeToDisplayDelta * scale);\n\t\tstbl->CompositionToDecode->leastDecodeToDisplayDelta = (s32)(stbl->CompositionToDecode->leastDecodeToDisplayDelta * scale);\n\t}\n\n\treturn SetTrackDuration(trak);\n}\n\nGF_EXPORT\nBool gf_isom_box_equal(GF_Box *a, GF_Box *b)\n{\n\tBool ret;\n\tu8 *data1, *data2;\n\tu32 data1_size, data2_size;\n\tGF_BitStream *bs;\n\n\tif (a == b) return GF_TRUE;\n\tif (!a || !b) return GF_FALSE;\n\n\tdata1 = data2 = NULL;\n\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tgf_isom_box_size(a);\n\tgf_isom_box_write(a, bs);\n\tgf_bs_get_content(bs, &data1, &data1_size);\n\tgf_bs_del(bs);\n\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tgf_isom_box_size(b);\n\tgf_isom_box_write(b, bs);\n\tgf_bs_get_content(bs, &data2, &data2_size);\n\tgf_bs_del(bs);\n\n\tret = GF_FALSE;\n\tif (data1_size == data2_size) {\n\t\tret = (memcmp(data1, data2, sizeof(char)*data1_size) == 0) ? GF_TRUE : GF_FALSE;\n\t}\n\tgf_free(data1);\n\tgf_free(data2);\n\treturn ret;\n}\n\nstatic u32 base_sample_entry_type(u32 type)\n{\n\tif (type==GF_ISOM_SUBTYPE_DVH1) return GF_ISOM_SUBTYPE_HVC1;\n\tif (type==GF_ISOM_SUBTYPE_DVHE) return GF_ISOM_SUBTYPE_HEV1;\n\tif (type==GF_ISOM_SUBTYPE_DVA1) return GF_ISOM_SUBTYPE_AVC_H264;\n\tif (type==GF_ISOM_SUBTYPE_DVAV) return GF_ISOM_SUBTYPE_AVC3_H264;\n\tif (type==GF_ISOM_SUBTYPE_DAV1) return GF_ISOM_SUBTYPE_AV01;\n\treturn type;\n}\n\nGF_EXPORT\nBool gf_isom_is_same_sample_description(GF_ISOFile *f1, u32 tk1, u32 sdesc_index1, GF_ISOFile *f2, u32 tk2, u32 sdesc_index2)\n{\n\tu32 i, count;\n\tGF_TrackBox *trak1, *trak2;\n\tGF_ESD *esd1, *esd2;\n\tBool need_memcmp, ret;\n\tGF_Box *a, *b;\n\n\t/*get orig sample desc and clone it*/\n\ttrak1 = gf_isom_get_track_from_file(f1, tk1);\n\tif (!trak1 || !trak1->Media) return GF_FALSE;\n\ttrak2 = gf_isom_get_track_from_file(f2, tk2);\n\tif (!trak2 || !trak2->Media) return GF_FALSE;\n\n\tif (trak1->Media->handler->handlerType != trak2->Media->handler->handlerType) return GF_FALSE;\n\tcount = gf_list_count(trak1->Media->information->sampleTable->SampleDescription->child_boxes);\n\tif (count != gf_list_count(trak2->Media->information->sampleTable->SampleDescription->child_boxes)) {\n\t\tif (!sdesc_index1 && !sdesc_index2) return GF_FALSE;\n\t}\n\n\tneed_memcmp = GF_TRUE;\n\tfor (i=0; i<count; i++) {\n\t\tu32 type1, type2;\n\t\tGF_SampleEntryBox *ent1 = (GF_SampleEntryBox *)gf_list_get(trak1->Media->information->sampleTable->SampleDescription->child_boxes, i);\n\t\tGF_SampleEntryBox *ent2 = (GF_SampleEntryBox *)gf_list_get(trak2->Media->information->sampleTable->SampleDescription->child_boxes, i);\n\n\t\tif (sdesc_index1) ent1 = (GF_SampleEntryBox *)gf_list_get(trak1->Media->information->sampleTable->SampleDescription->child_boxes, sdesc_index1 - 1);\n\t\tif (sdesc_index2) ent2 = (GF_SampleEntryBox *)gf_list_get(trak2->Media->information->sampleTable->SampleDescription->child_boxes, sdesc_index2 - 1);\n\n\t\tif (!ent1 || !ent2) return GF_FALSE;\n\t\tif (ent1->internal_type != ent2->internal_type) return GF_FALSE;\n\t\ttype1 = base_sample_entry_type(ent1->type);\n\t\ttype2 = base_sample_entry_type(ent2->type);\n\t\tif (type1 != type2) return GF_FALSE;\n\n\t\tswitch (ent1->type) {\n\t\t/*for MPEG-4 streams, only compare decSpecInfo (bitrate may not be the same but that's not an issue)*/\n\t\tcase GF_ISOM_BOX_TYPE_MP4S:\n\t\tcase GF_ISOM_BOX_TYPE_MP4A:\n\t\tcase GF_ISOM_BOX_TYPE_MP4V:\n\t\tcase GF_ISOM_BOX_TYPE_ENCA:\n\t\tcase GF_ISOM_BOX_TYPE_ENCV:\n\t\tcase GF_ISOM_BOX_TYPE_RESV:\n\t\tcase GF_ISOM_BOX_TYPE_ENCS:\n\t\t\tMedia_GetESD(trak1->Media, sdesc_index1 ? sdesc_index1 : i+1, &esd1, GF_TRUE);\n\t\t\tMedia_GetESD(trak2->Media, sdesc_index2 ? sdesc_index2 : i+1, &esd2, GF_TRUE);\n\t\t\tif (!esd1 || !esd2) continue;\n\t\t\tneed_memcmp = GF_FALSE;\n\t\t\tif (esd1->decoderConfig->streamType != esd2->decoderConfig->streamType) return GF_FALSE;\n\t\t\tif (esd1->decoderConfig->objectTypeIndication != esd2->decoderConfig->objectTypeIndication) return GF_FALSE;\n\t\t\tif (!esd1->decoderConfig->decoderSpecificInfo && esd2->decoderConfig->decoderSpecificInfo) return GF_FALSE;\n\t\t\tif (esd1->decoderConfig->decoderSpecificInfo && !esd2->decoderConfig->decoderSpecificInfo) return GF_FALSE;\n\t\t\tif (!esd1->decoderConfig->decoderSpecificInfo || !esd2->decoderConfig->decoderSpecificInfo) continue;\n\t\t\tif (esd1->decoderConfig->decoderSpecificInfo->dataLength != esd2->decoderConfig->decoderSpecificInfo->dataLength)\n\t\t\t\treturn GF_FALSE;\n\t\t\tif (memcmp(esd1->decoderConfig->decoderSpecificInfo->data, esd2->decoderConfig->decoderSpecificInfo->data, sizeof(char)*esd1->decoderConfig->decoderSpecificInfo->dataLength)!=0) return GF_FALSE;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_HVT1:\n\t\t\treturn GF_TRUE;\n\t\tcase GF_ISOM_BOX_TYPE_AVC1:\n\t\tcase GF_ISOM_BOX_TYPE_AVC2:\n\t\tcase GF_ISOM_BOX_TYPE_AVC3:\n\t\tcase GF_ISOM_BOX_TYPE_AVC4:\n\t\tcase GF_ISOM_BOX_TYPE_SVC1:\n\t\tcase GF_ISOM_BOX_TYPE_MVC1:\n\t\tcase GF_ISOM_BOX_TYPE_HVC1:\n\t\tcase GF_ISOM_BOX_TYPE_HEV1:\n\t\tcase GF_ISOM_BOX_TYPE_HVC2:\n\t\tcase GF_ISOM_BOX_TYPE_HEV2:\n\t\tcase GF_ISOM_BOX_TYPE_LHE1:\n\t\tcase GF_ISOM_BOX_TYPE_LHV1:\n\t\tcase GF_ISOM_BOX_TYPE_AV01:\n\t\tcase GF_ISOM_BOX_TYPE_VVC1:\n\t\tcase GF_ISOM_BOX_TYPE_VVI1:\n\t\tcase GF_ISOM_BOX_TYPE_DVHE:\n\t\tcase GF_ISOM_BOX_TYPE_DVH1:\n\t\tcase GF_ISOM_BOX_TYPE_DVA1:\n\t\tcase GF_ISOM_BOX_TYPE_DVAV:\n\t\tcase GF_ISOM_BOX_TYPE_DAV1:\n\t\t{\n\t\t\tGF_MPEGVisualSampleEntryBox *avc1 = (GF_MPEGVisualSampleEntryBox *)ent1;\n\t\t\tGF_MPEGVisualSampleEntryBox *avc2 = (GF_MPEGVisualSampleEntryBox *)ent2;\n\n\t\t\tif (avc1->hevc_config)\n\t\t\t\ta = (GF_Box *) avc1->hevc_config;\n\t\t\telse if (avc1->lhvc_config)\n\t\t\t\ta = (GF_Box *) avc1->lhvc_config;\n\t\t\telse if (avc1->svc_config)\n\t\t\t\ta = (GF_Box *) avc1->svc_config;\n\t\t\telse if (avc1->mvc_config)\n\t\t\t\ta = (GF_Box *) avc1->mvc_config;\n\t\t\telse if (avc1->av1_config)\n\t\t\t\ta = (GF_Box *)avc1->av1_config;\n\t\t\telse\n\t\t\t\ta = (GF_Box *) avc1->avc_config;\n\n\t\t\tif (avc2->hevc_config)\n\t\t\t\tb = (GF_Box *) avc2->hevc_config;\n\t\t\telse if (avc2->lhvc_config)\n\t\t\t\tb = (GF_Box *) avc2->lhvc_config;\n\t\t\telse if (avc2->svc_config)\n\t\t\t\tb = (GF_Box *) avc2->svc_config;\n\t\t\telse if (avc2->mvc_config)\n\t\t\t\tb = (GF_Box *) avc2->mvc_config;\n\t\t\telse if (avc2->av1_config)\n\t\t\t\tb = (GF_Box *)avc2->av1_config;\n\t\t\telse\n\t\t\t\tb = (GF_Box *) avc2->avc_config;\n\n\t\t\treturn gf_isom_box_equal(a,b);\n\t\t}\n\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_LSR1:\n\t\t{\n\t\t\tGF_LASeRSampleEntryBox *lsr1 = (GF_LASeRSampleEntryBox *)ent1;\n\t\t\tGF_LASeRSampleEntryBox *lsr2 = (GF_LASeRSampleEntryBox *)ent2;\n\t\t\tif (lsr1->lsr_config && lsr2->lsr_config\n\t\t\t        && lsr1->lsr_config->hdr && lsr2->lsr_config->hdr\n\t\t\t        && (lsr1->lsr_config->hdr_size==lsr2->lsr_config->hdr_size)\n\t\t\t        && !memcmp(lsr1->lsr_config->hdr, lsr2->lsr_config->hdr, lsr2->lsr_config->hdr_size)\n\t\t\t   ) {\n\t\t\t\treturn GF_TRUE;\n\t\t\t}\n\t\t\treturn GF_FALSE;\n\t\t}\n\t\tbreak;\n#ifndef GPAC_DISABLE_VTT\n\t\tcase GF_ISOM_BOX_TYPE_WVTT:\n\t\t{\n\t\t\tGF_WebVTTSampleEntryBox *wvtt1 = (GF_WebVTTSampleEntryBox *)ent1;\n\t\t\tGF_WebVTTSampleEntryBox *wvtt2 = (GF_WebVTTSampleEntryBox *)ent2;\n\t\t\tif (wvtt1->config && wvtt2->config &&\n\t\t\t        (wvtt1->config->string && wvtt2->config->string && !strcmp(wvtt1->config->string, wvtt2->config->string))) {\n\t\t\t\treturn GF_TRUE;\n\t\t\t}\n\t\t\treturn GF_FALSE;\n\t\t}\n\t\tbreak;\n#endif\n\t\tcase GF_ISOM_BOX_TYPE_STPP:\n\t\t{\n\t\t\tGF_MetaDataSampleEntryBox *stpp1 = (GF_MetaDataSampleEntryBox *)ent1;\n\t\t\tGF_MetaDataSampleEntryBox *stpp2 = (GF_MetaDataSampleEntryBox *)ent2;\n\t\t\tif (stpp1->xml_namespace && stpp2->xml_namespace && !strcmp(stpp1->xml_namespace, stpp2->xml_namespace)) {\n\t\t\t\treturn GF_TRUE;\n\t\t\t}\n\t\t\treturn GF_FALSE;\n\t\t}\n\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_SBTT:\n\t\t{\n\t\t\treturn GF_FALSE;\n\t\t}\n\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_STXT:\n\t\t{\n\t\t\tGF_MetaDataSampleEntryBox *stxt1 = (GF_MetaDataSampleEntryBox *)ent1;\n\t\t\tGF_MetaDataSampleEntryBox *stxt2 = (GF_MetaDataSampleEntryBox *)ent2;\n\t\t\tif (stxt1->mime_type && stxt2->mime_type &&\n\t\t\t        ( (!stxt1->config && !stxt2->config) ||\n\t\t\t          (stxt1->config && stxt2->config && stxt1->config->config && stxt2->config->config &&\n\t\t\t           !strcmp(stxt1->config->config, stxt2->config->config)))) {\n\t\t\t\treturn GF_TRUE;\n\t\t\t}\n\t\t\treturn GF_FALSE;\n\t\t}\n\t\tcase GF_ISOM_BOX_TYPE_MP3:\n\t\tcase GF_QT_SUBTYPE_RAW_AUD:\n\t\tcase GF_QT_SUBTYPE_TWOS:\n\t\tcase GF_QT_SUBTYPE_SOWT:\n\t\tcase GF_QT_SUBTYPE_FL32:\n\t\tcase GF_QT_SUBTYPE_FL64:\n\t\tcase GF_QT_SUBTYPE_IN24:\n\t\tcase GF_QT_SUBTYPE_IN32:\n\t\tcase GF_QT_SUBTYPE_ULAW:\n\t\tcase GF_QT_SUBTYPE_ALAW:\n\t\tcase GF_QT_SUBTYPE_ADPCM:\n\t\tcase GF_QT_SUBTYPE_IMA_ADPCM:\n\t\tcase GF_QT_SUBTYPE_DVCA:\n\t\tcase GF_QT_SUBTYPE_QDMC:\n\t\tcase GF_QT_SUBTYPE_QDMC2:\n\t\tcase GF_QT_SUBTYPE_QCELP:\n\t\tcase GF_QT_SUBTYPE_kMP3:\n\t\tcase GF_QT_SUBTYPE_APCH:\n\t\tcase GF_QT_SUBTYPE_APCO:\n\t\tcase GF_QT_SUBTYPE_APCN:\n\t\tcase GF_QT_SUBTYPE_APCS:\n\t\tcase GF_QT_SUBTYPE_AP4X:\n\t\tcase GF_QT_SUBTYPE_AP4H:\n\t\tcase GF_QT_SUBTYPE_RAW_VID:\n\t\tcase GF_QT_SUBTYPE_YUYV:\n\t\tcase GF_QT_SUBTYPE_UYVY:\n\t\tcase GF_QT_SUBTYPE_YUV444:\n\t\tcase GF_QT_SUBTYPE_YUVA444:\n\t\tcase GF_QT_SUBTYPE_YUV422_10:\n\t\tcase GF_QT_SUBTYPE_YUV444_10:\n\t\tcase GF_QT_SUBTYPE_YUV422_16:\n\t\tcase GF_QT_SUBTYPE_YUV420:\n\t\tcase GF_QT_SUBTYPE_I420:\n\t\tcase GF_QT_SUBTYPE_IYUV:\n\t\tcase GF_QT_SUBTYPE_YV12:\n\t\tcase GF_QT_SUBTYPE_YVYU:\n\t\tcase GF_QT_SUBTYPE_RGBA:\n\t\tcase GF_QT_SUBTYPE_ABGR:\n\t\tdefault:\n\t\t\tif (ent1->internal_type == GF_ISOM_SAMPLE_ENTRY_VIDEO) {\n\t\t\t\tGF_VisualSampleEntryBox *vent1 = (GF_VisualSampleEntryBox *) ent1;\n\t\t\t\tGF_VisualSampleEntryBox *vent2 = (GF_VisualSampleEntryBox *) ent2;\n\t\t\t\tif (vent1->Width != vent2->Width) return GF_FALSE;\n\t\t\t\tif (vent1->Height != vent2->Height) return GF_FALSE;\n\t\t\t}\n\t\t\telse if (ent1->internal_type == GF_ISOM_SAMPLE_ENTRY_AUDIO) {\n\t\t\t\tGF_AudioSampleEntryBox *aent1 = (GF_AudioSampleEntryBox *) ent1;\n\t\t\t\tGF_AudioSampleEntryBox *aent2 = (GF_AudioSampleEntryBox *) ent2;\n\t\t\t\tif (aent1->samplerate_hi != aent2->samplerate_hi) return GF_FALSE;\n\t\t\t\tif (aent1->samplerate_lo != aent2->samplerate_lo) return GF_FALSE;\n\t\t\t\tif (aent1->channel_count != aent2->channel_count) return GF_FALSE;\n\t\t\t}\n\t\t\treturn GF_TRUE;\n\t\t}\n\n\t\tif (sdesc_index1 && sdesc_index2) break;\n\t}\n\tif (!need_memcmp) return GF_TRUE;\n\ta = (GF_Box *)trak1->Media->information->sampleTable->SampleDescription;\n\tb = (GF_Box *)trak2->Media->information->sampleTable->SampleDescription;\n\t//we ignore all bitrate boxes when comparing the box, disable their writing\n\tgf_isom_registry_disable(GF_ISOM_BOX_TYPE_BTRT, GF_TRUE);\n\tret = gf_isom_box_equal(a,b);\n\t//re-enable btrt writing\n\tgf_isom_registry_disable(GF_ISOM_BOX_TYPE_BTRT, GF_FALSE);\n\n\treturn ret;\n}\n\nGF_EXPORT\nu64 gf_isom_estimate_size(GF_ISOFile *movie)\n{\n\tGF_Err e;\n\tGF_Box *a;\n\tu32 i, count;\n\tu64 mdat_size;\n\tif (!movie || !movie->moov) return 0;\n\n\tmdat_size = 0;\n\tcount = gf_list_count(movie->moov->trackList);\n\tfor (i=0; i<count; i++) {\n\t\tmdat_size += gf_isom_get_media_data_size(movie, i+1);\n\t}\n\tif (mdat_size) {\n\t\tmdat_size += 8;\n\t\tif (mdat_size > 0xFFFFFFFF) mdat_size += 8;\n\t}\n\n\ti=0;\n\twhile ((a = (GF_Box*)gf_list_enum(movie->TopBoxes, &i))) {\n\t\te = gf_isom_box_size(a);\n\t\tif (e == GF_OK)\n\t\t\tmdat_size += a->size;\n\t}\n\treturn mdat_size;\n}\n\n\n//set shadowing on/off\n#if 0 //unused\nGF_Err gf_isom_remove_sync_shadows(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\tGF_SampleTableBox *stbl;\n\n\tif (movie->openMode == GF_ISOM_OPEN_READ) return GF_ISOM_INVALID_MODE;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstbl = trak->Media->information->sampleTable;\n\tif (stbl->ShadowSync) {\n\t\tgf_isom_box_del_parent(&stbl->child_boxes, (GF_Box *) stbl->ShadowSync);\n\t\tstbl->ShadowSync = NULL;\n\t}\n\treturn GF_OK;\n}\n\n/*Use this function to do the shadowing if you use shadowing.\nthe sample to be shadowed MUST be a non-sync sample (ignored if not)\nthe sample shadowing must be a Sync sample (error if not)*/\nGF_Err gf_isom_set_sync_shadow(GF_ISOFile *movie, u32 trackNumber, u32 sampleNumber, u32 syncSample)\n{\n\tGF_TrackBox *trak;\n\tGF_SampleTableBox *stbl;\n\tGF_ISOSAPType isRAP;\n\tGF_Err e;\n\n\tif (movie->openMode == GF_ISOM_OPEN_READ) return GF_ISOM_INVALID_MODE;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !sampleNumber || !syncSample) return GF_BAD_PARAM;\n\n\tstbl = trak->Media->information->sampleTable;\n\tif (!stbl->ShadowSync) {\n\t\tstbl->ShadowSync = (GF_ShadowSyncBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STSH);\n\t\tif (!stbl->ShadowSync) return GF_OUT_OF_MEM;\n\t}\n\n\t//if no sync, skip\n\tif (!stbl->SyncSample) return GF_OK;\n\t//else set the sync shadow.\n\t//if the sample is sync, ignore\n\te = stbl_GetSampleRAP(stbl->SyncSample, sampleNumber, &isRAP, NULL, NULL);\n\tif (e) return e;\n\tif (isRAP) return GF_OK;\n\t//if the shadowing sample is not sync, error\n\te = stbl_GetSampleRAP(stbl->SyncSample, syncSample, &isRAP, NULL, NULL);\n\tif (e) return e;\n\tif (!isRAP) return GF_BAD_PARAM;\n\n\treturn stbl_SetSyncShadow(stbl->ShadowSync, sampleNumber, syncSample);\n}\n#endif\n\n//set the GroupID of a track (only used for interleaving)\nGF_EXPORT\nGF_Err gf_isom_set_track_interleaving_group(GF_ISOFile *movie, u32 trackNumber, u32 GroupID)\n{\n\tGF_TrackBox *trak;\n\n\tif (movie->openMode != GF_ISOM_OPEN_EDIT) return GF_ISOM_INVALID_MODE;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !GroupID) return GF_BAD_PARAM;\n\n\ttrak->Media->information->sampleTable->groupID = GroupID;\n\treturn GF_OK;\n}\n\n\n//set the Priority of a track within a Group (only used for tight interleaving)\n//Priority ranges from 1 to 9\nGF_EXPORT\nGF_Err gf_isom_set_track_priority_in_group(GF_ISOFile *movie, u32 trackNumber, u32 Priority)\n{\n\tGF_TrackBox *trak;\n\n\tif (movie->openMode != GF_ISOM_OPEN_EDIT) return GF_ISOM_INVALID_MODE;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !Priority) return GF_BAD_PARAM;\n\n\ttrak->Media->information->sampleTable->trackPriority = Priority > 255 ? 255 : Priority;\n\treturn GF_OK;\n}\n\n//set the max SamplesPerChunk (for file optimization)\nGF_EXPORT\nGF_Err gf_isom_hint_max_chunk_size(GF_ISOFile *movie, u32 trackNumber, u32 maxChunkSize)\n{\n\tGF_TrackBox *trak;\n\n\tif (movie->openMode == GF_ISOM_OPEN_READ) return GF_ISOM_INVALID_MODE;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !maxChunkSize) return GF_BAD_PARAM;\n\n\ttrak->Media->information->sampleTable->MaxChunkSize = maxChunkSize;\n\treturn GF_OK;\n}\n\n\n//set the max SamplesPerChunk (for file optimization)\nGF_EXPORT\nGF_Err gf_isom_hint_max_chunk_duration(GF_ISOFile *movie, u32 trackNumber, u32 maxChunkDur)\n{\n\tGF_TrackBox *trak;\n\n\tif (movie->openMode == GF_ISOM_OPEN_READ) return GF_ISOM_INVALID_MODE;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\ttrak->Media->information->sampleTable->MaxChunkDur = maxChunkDur;\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_set_extraction_slc(GF_ISOFile *the_file, u32 trackNumber, u32 StreamDescriptionIndex, const GF_SLConfig *slConfig)\n{\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_Err e;\n\tGF_SLConfig **slc;\n\tGF_ESDBox *esds;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\te = Media_GetSampleDesc(trak->Media, StreamDescriptionIndex, &entry, NULL);\n\tif (e) return e;\n\n\t//we must be sure we are not using a remote ESD\n\tswitch (entry->type) {\n\tcase GF_ISOM_BOX_TYPE_MP4S:\n\t\tesds = ((GF_MPEGSampleEntryBox *)entry)->esd;\n\t\tif (!esds || !esds->desc || !esds->desc->slConfig || (esds->desc->slConfig->predefined != SLPredef_MP4))\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\tslc = & ((GF_MPEGSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4A:\n\t\tesds = ((GF_MPEGAudioSampleEntryBox *)entry)->esd;\n\t\tif (!esds || !esds->desc || !esds->desc->slConfig || (esds->desc->slConfig->predefined != SLPredef_MP4))\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\tslc = & ((GF_MPEGAudioSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4V:\n\t\tesds = ((GF_MPEGVisualSampleEntryBox *)entry)->esd;\n\t\tif (!esds || !esds->desc || !esds->desc->slConfig || (esds->desc->slConfig->predefined != SLPredef_MP4))\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\tslc = & ((GF_MPEGVisualSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_OK;\n\t}\n\n\tif (*slc) {\n\t\tgf_odf_desc_del((GF_Descriptor *)*slc);\n\t\t*slc = NULL;\n\t}\n\tif (!slConfig) return GF_OK;\n\t//finally duplicate the SL\n\treturn gf_odf_desc_copy((GF_Descriptor *) slConfig, (GF_Descriptor **) slc);\n}\n\n#if 0 //unused\nGF_Err gf_isom_get_extraction_slc(GF_ISOFile *the_file, u32 trackNumber, u32 StreamDescriptionIndex, GF_SLConfig **slConfig)\n{\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_Err e;\n\tGF_SLConfig *slc;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\te = Media_GetSampleDesc(trak->Media, StreamDescriptionIndex, &entry, NULL);\n\tif (e) return e;\n\n\t//we must be sure we are not using a remote ESD\n\tslc = NULL;\n\t*slConfig = NULL;\n\tswitch (entry->type) {\n\tcase GF_ISOM_BOX_TYPE_MP4S:\n\t\tif (((GF_MPEGSampleEntryBox *)entry)->esd->desc->slConfig->predefined != SLPredef_MP4) return GF_BAD_PARAM;\n\t\tslc = ((GF_MPEGSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4A:\n\t\tif (((GF_MPEGAudioSampleEntryBox *)entry)->esd->desc->slConfig->predefined != SLPredef_MP4) return GF_BAD_PARAM;\n\t\tslc = ((GF_MPEGAudioSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4V:\n\t\tif (((GF_MPEGVisualSampleEntryBox *)entry)->esd->desc->slConfig->predefined != SLPredef_MP4) return GF_BAD_PARAM;\n\t\tslc = ((GF_MPEGVisualSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tif (!slc) return GF_OK;\n\t//finally duplicate the SL\n\treturn gf_odf_desc_copy((GF_Descriptor *) slc, (GF_Descriptor **) slConfig);\n}\n\nu32 gf_isom_get_track_group(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 0;\n\treturn trak->Media->information->sampleTable->groupID;\n}\n\nu32 gf_isom_get_track_priority_in_group(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 0;\n\treturn trak->Media->information->sampleTable->trackPriority;\n}\n#endif\n\n\nGF_EXPORT\nGF_Err gf_isom_make_interleave_ex(GF_ISOFile *file, GF_Fraction *fTimeInSec)\n{\n\tGF_Err e;\n\tu64 itime;\n\tif (!file || !fTimeInSec->den || (fTimeInSec->num<=0)) return GF_BAD_PARAM;\n\n\titime = (u64) fTimeInSec->num;\n\titime *= gf_isom_get_timescale(file);\n\titime /= fTimeInSec->den;\n\tif (file->storageMode==GF_ISOM_STORE_FASTSTART) {\n\t\treturn gf_isom_set_interleave_time(file, (u32) itime);\n\t}\n\tif (gf_isom_get_mode(file) < GF_ISOM_OPEN_EDIT) return GF_BAD_PARAM;\n\te = gf_isom_set_storage_mode(file, GF_ISOM_STORE_DRIFT_INTERLEAVED);\n\tif (e) return e;\n\treturn gf_isom_set_interleave_time(file, (u32) itime);\n}\n\nGF_EXPORT\nGF_Err gf_isom_make_interleave(GF_ISOFile *file, Double TimeInSec)\n{\n\tGF_Fraction f;\n\tf.num = (s32) (TimeInSec * 1000);\n\tf.den = 1000;\n\treturn gf_isom_make_interleave_ex(file, &f);\n\n}\nGF_EXPORT\nGF_Err gf_isom_set_handler_name(GF_ISOFile *the_file, u32 trackNumber, const char *nameUTF8)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\tif (trak->Media->handler->nameUTF8) gf_free(trak->Media->handler->nameUTF8);\n\ttrak->Media->handler->nameUTF8 = NULL;\n\n\tif (!nameUTF8) return GF_OK;\n\n\tif (!strnicmp(nameUTF8, \"file://\", 7)) {\n\t\tu8 BOM[4];\n\t\tFILE *f = gf_fopen(nameUTF8+7, \"rb\");\n\t\tu64 size;\n\t\tif (!f) return GF_URL_ERROR;\n\t\tsize = gf_fsize(f);\n\t\tif (3!=gf_fread(BOM, 3, f)) {\n\t\t\tgf_fclose(f);\n\t\t\treturn GF_CORRUPTED_DATA;\n\t\t}\n\t\t/*skip BOM if any*/\n\t\tif ((BOM[0]==0xEF) && (BOM[1]==0xBB) && (BOM[2]==0xBF)) size -= 3;\n\t\telse if ((BOM[0]==0xEF) || (BOM[0]==0xFF)) {\n\t\t\tgf_fclose(f);\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t\telse gf_fseek(f, 0, SEEK_SET);\n\t\ttrak->Media->handler->nameUTF8 = (char*)gf_malloc(sizeof(char)*(size_t)(size+1));\n\t\tif (!trak->Media->handler->nameUTF8) {\n\t\t\tgf_fclose(f);\n\t\t\treturn GF_OUT_OF_MEM;\n\t\t}\n\t\tsize = gf_fread(trak->Media->handler->nameUTF8, (size_t)size, f);\n\t\ttrak->Media->handler->nameUTF8[size] = 0;\n\t\tgf_fclose(f);\n\t} else {\n\t\tu32 i, j, len;\n\t\tchar szOrig[1024], szLine[1024];\n\t\tstrcpy(szOrig, nameUTF8);\n\t\tj=0;\n\t\tlen = (u32) strlen(szOrig);\n\t\tfor (i=0; i<len; i++) {\n\t\t\tif (szOrig[i] & 0x80) {\n\t\t\t\t/*non UTF8 (likely some win-CP)*/\n\t\t\t\tif ( (szOrig[i+1] & 0xc0) != 0x80) {\n\t\t\t\t\tszLine[j] = 0xc0 | ( (szOrig[i] >> 6) & 0x3 );\n\t\t\t\t\tj++;\n\t\t\t\t\tszOrig[i] &= 0xbf;\n\t\t\t\t}\n\t\t\t\t/*UTF8 2 bytes char */\n\t\t\t\telse if ( (szOrig[i] & 0xe0) == 0xc0) {\n\t\t\t\t\tszLine[j] = szOrig[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\t/*UTF8 3 bytes char */\n\t\t\t\telse if ( (szOrig[i] & 0xf0) == 0xe0) {\n\t\t\t\t\tszLine[j] = szOrig[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t\tszLine[j] = szOrig[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\t/*UTF8 4 bytes char */\n\t\t\t\telse if ( (szOrig[i] & 0xf8) == 0xf0) {\n\t\t\t\t\tszLine[j] = szOrig[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t\tszLine[j] = szOrig[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t\tszLine[j] = szOrig[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tszLine[j] = szOrig[i];\n\t\t\tj++;\n\t\t}\n\t\tszLine[j] = 0;\n\t\ttrak->Media->handler->nameUTF8 = gf_strdup(szLine);\n\t}\n\treturn GF_OK;\n}\n\n#if 0 //unused\n/*clones root OD from input to output file, without copying root OD track references*/\nGF_Err gf_isom_clone_root_od(GF_ISOFile *input, GF_ISOFile *output)\n{\n\tGF_List *esds;\n\tGF_Err e;\n\tu32 i;\n\tGF_Descriptor *desc;\n\n\te = gf_isom_remove_root_od(output);\n\tif (e) return e;\n\tif (!input->moov || !input->moov->iods || !input->moov->iods->descriptor) return GF_OK;\n\te = gf_isom_insert_moov(output);\n\tif (e) return e;\n\te = AddMovieIOD(output->moov, 0);\n\tif (e) return e;\n\tif (output->moov->iods->descriptor) gf_odf_desc_del(output->moov->iods->descriptor);\n\toutput->moov->iods->descriptor = NULL;\n\tgf_odf_desc_copy(input->moov->iods->descriptor, &output->moov->iods->descriptor);\n\n\tswitch (output->moov->iods->descriptor->tag) {\n\tcase GF_ODF_ISOM_IOD_TAG:\n\t\tesds = ((GF_IsomInitialObjectDescriptor *)output->moov->iods->descriptor)->ES_ID_IncDescriptors;\n\t\tbreak;\n\tcase GF_ODF_ISOM_OD_TAG:\n\t\tesds = ((GF_IsomObjectDescriptor *)output->moov->iods->descriptor)->ES_ID_IncDescriptors;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\t//get the desc\n\ti=0;\n\twhile ((desc = (GF_Descriptor*)gf_list_enum(esds, &i))) {\n\t\tgf_odf_desc_del(desc);\n\t\tgf_list_rem(esds, i-1);\n\t}\n\treturn GF_OK;\n}\n#endif\n\nGF_EXPORT\nGF_Err gf_isom_set_media_type(GF_ISOFile *movie, u32 trackNumber, u32 new_type)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !new_type) return GF_BAD_PARAM;\n\ttrak->Media->handler->handlerType = new_type;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_media_subtype(GF_ISOFile *movie, u32 trackNumber, u32 sampleDescriptionIndex, u32 new_type)\n{\n\tGF_SampleEntryBox*entry;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !sampleDescriptionIndex || !new_type) return GF_BAD_PARAM;\n\n\tentry = (GF_SampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, sampleDescriptionIndex - 1);\n\tif (!entry) return GF_BAD_PARAM;\n\tif (entry->type==GF_ISOM_BOX_TYPE_GNRV) {\n\t\t((GF_GenericVisualSampleEntryBox *)entry)->EntryType = new_type;\n\t} else if (entry->type==GF_ISOM_BOX_TYPE_GNRA) {\n\t\t((GF_GenericAudioSampleEntryBox *)entry)->EntryType = new_type;\n\t} else if (entry->type==GF_ISOM_BOX_TYPE_GNRM) {\n\t\t((GF_GenericSampleEntryBox *)entry)->EntryType = new_type;\n\t} else {\n\t\tentry->type = new_type;\n\t}\n\treturn GF_OK;\n}\n\n\n#if 0 //unused\nGF_Err gf_isom_set_JPEG2000(GF_ISOFile *mov, Bool set_on)\n{\n\tif (!mov) return GF_BAD_PARAM;\n\tmov->is_jp2 = set_on;\n\treturn GF_OK;\n}\n#endif\n\nGF_Err gf_isom_remove_uuid(GF_ISOFile *movie, u32 trackNumber, bin128 UUID)\n{\n\tu32 i, count;\n\tGF_List *list;\n\n\tif (trackNumber==(u32) -1) {\n\t\tif (!movie) return GF_BAD_PARAM;\n\t\tlist = movie->TopBoxes;\n\t} else if (trackNumber) {\n\t\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\tlist = trak->child_boxes;\n\t} else {\n\t\tif (!movie) return GF_BAD_PARAM;\n\t\tlist = movie->moov->child_boxes;\n\t}\n\n\tcount = list ? gf_list_count(list) : 0;\n\tfor (i=0; i<count; i++) {\n\t\tGF_UnknownUUIDBox *uuid = (GF_UnknownUUIDBox *)gf_list_get(list, i);\n\t\tif (uuid->type != GF_ISOM_BOX_TYPE_UUID) continue;\n\t\tif (memcmp(UUID, uuid->uuid, sizeof(bin128))) continue;\n\t\tgf_list_rem(list, i);\n\t\ti--;\n\t\tcount--;\n\t\tgf_isom_box_del((GF_Box*)uuid);\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_add_uuid(GF_ISOFile *movie, u32 trackNumber, bin128 UUID, const u8 *data, u32 data_size)\n{\n\tGF_List *list;\n    u32 btype;\n\tGF_Box *box;\n\tGF_UnknownUUIDBox *uuidb;\n\n\tif (data_size && !data) return GF_BAD_PARAM;\n\tif (trackNumber==(u32) -1) {\n\t\tif (!movie) return GF_BAD_PARAM;\n\t\tlist = movie->TopBoxes;\n\t} else if (trackNumber) {\n\t\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\tif (!trak->child_boxes) trak->child_boxes = gf_list_new();\n\t\tlist = trak->child_boxes;\n\t} else {\n\t\tif (!movie) return GF_BAD_PARAM;\n\t\tif (!movie->moov->child_boxes) movie->moov->child_boxes = gf_list_new();\n\t\tlist = movie->moov->child_boxes;\n\t}\n    btype = gf_isom_solve_uuid_box((char *) UUID);\n    if (!btype) btype = GF_ISOM_BOX_TYPE_UUID;\n    box = gf_isom_box_new(btype);\n    if (!box) return GF_OUT_OF_MEM;\n\tuuidb = (GF_UnknownUUIDBox*)box;\n\tuuidb->internal_4cc = gf_isom_solve_uuid_box((char *) UUID);\n\tmemcpy(uuidb->uuid, UUID, sizeof(bin128));\n\tuuidb->dataSize = data_size;\n\tif (data_size) {\n\t\tuuidb->data = (char*)gf_malloc(sizeof(char)*data_size);\n\t\tif (!uuidb->data) return GF_OUT_OF_MEM;\n\t\tmemcpy(uuidb->data, data, sizeof(char)*data_size);\n\t}\n\tgf_list_add(list, uuidb);\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_apple_set_tag(GF_ISOFile *mov, GF_ISOiTunesTag tag, const u8 *data, u32 data_len, u64 int_val, u32 int_val2)\n{\n\tGF_Err e;\n\tGF_ItemListBox *ilst;\n\tGF_MetaBox *meta;\n\tGF_ListItemBox *info;\n\tu32 btype, i, itype;\n\ts32 tag_idx;\n\tu32 n=0, d=0;\n\tu8 loc_data[10];\n\tu32 int_flags = 0x15;\n\tGF_DataBox *dbox;\n\n\te = CanAccessMovie(mov, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttag_idx = gf_itags_find_by_itag(tag);\n\tif (tag_idx<0) {\n\t\titype = GF_ITAG_STR;\n\t} else {\n\t\titype = gf_itags_get_type(tag_idx);\n\t}\n\tmeta = (GF_MetaBox *) gf_isom_create_meta_extensions(mov, GF_FALSE);\n\tif (!meta) return GF_BAD_PARAM;\n\n\tilst = gf_isom_locate_box(meta->child_boxes, GF_ISOM_BOX_TYPE_ILST, NULL);\n\tif (!ilst) {\n\t\tilst = (GF_ItemListBox *) gf_isom_box_new_parent(&meta->child_boxes, GF_ISOM_BOX_TYPE_ILST);\n\t}\n\n\tif (tag==GF_ISOM_ITUNE_RESET) {\n\t\tgf_isom_box_del_parent(&meta->child_boxes, (GF_Box *) ilst);\n\t\t//if last, delete udta - we may still have a handler box remaining\n\t\tif ((gf_list_count(meta->child_boxes) <= 1) && (gf_list_count(mov->moov->udta->recordList)==1)) {\n\t\t\tgf_isom_box_del_parent(&mov->moov->child_boxes, (GF_Box *) mov->moov->udta);\n\t\t\tmov->moov->udta = NULL;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\n\tif (tag==GF_ISOM_ITUNE_GENRE) {\n\t\tif (!int_val && data) {\n\t\t\tint_val = gf_id3_get_genre_tag(data);\n\t\t\tif (int_val) {\n\t\t\t\tdata = NULL;\n\t\t\t\tdata_len = 0;\n\t\t\t\titype = GF_ITAG_INT16;\n\t\t\t\tint_flags = 0;\n\t\t\t}\n\t\t}\n\t\tbtype = data ? GF_ISOM_ITUNE_GENRE_USER : GF_ISOM_ITUNE_GENRE;\n\t} else {\n\t\tbtype = tag;\n\t}\n\t/*remove tag*/\n\ti = 0;\n\twhile ((info = (GF_ListItemBox*)gf_list_enum(ilst->child_boxes, &i))) {\n\t\tif (info->type==btype) {\n\t\t\tgf_isom_box_del_parent(&ilst->child_boxes, (GF_Box *) info);\n\t\t\tinfo = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (info->type==GF_ISOM_BOX_TYPE_UNKNOWN) {\n\t\t\tGF_UnknownBox *u = (GF_UnknownBox *) info;\n\t\t\tif (u->original_4cc==btype) {\n\t\t\t\tgf_isom_box_del_parent(&ilst->child_boxes, (GF_Box *) info);\n\t\t\t\tinfo = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!data && data_len) {\n\t\tif (!gf_list_count(ilst->child_boxes) )\n\t\t\tgf_isom_box_del_parent(&meta->child_boxes, (GF_Box *) ilst);\n\t\treturn GF_OK;\n\t}\n\n\t//watch out for cprt, we don't want to create a regular cprt box\n\tif (btype==GF_ISOM_ITUNE_COPYRIGHT) {\n\t\tinfo = (GF_ListItemBox *)gf_isom_box_new(GF_ISOM_ITUNE_TOOL);\n\t\tinfo->type = GF_ISOM_ITUNE_COPYRIGHT;\n\t} else {\n\t\tinfo = (GF_ListItemBox *)gf_isom_box_new(btype);\n\t}\n\tif (info == NULL) return GF_OUT_OF_MEM;\n\n\tdbox = (GF_DataBox *)gf_isom_box_new_parent(&info->child_boxes, GF_ISOM_BOX_TYPE_DATA);\n\tif (!dbox) {\n\t\tgf_isom_box_del((GF_Box *)info);\n\t\treturn GF_OUT_OF_MEM;\n\t}\n\tif (info->type!=GF_ISOM_BOX_TYPE_UNKNOWN) {\n\t\tinfo->data = dbox;\n\t}\n\n\tswitch (itype) {\n\tcase GF_ITAG_FRAC6:\n\tcase GF_ITAG_FRAC8:\n\t\tif (data && data_len) {\n\t\t\tif (sscanf(data, \"%u/%u\", &n, &d) != 2) {\n\t\t\t\tn = d = 0;\n\t\t\t\tif (sscanf(data, \"%u\", &n) != 1)\n\t\t\t\t\tn = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tn = (u32) int_val;\n\t\t\td = int_val2;\n\t\t}\n\t\tif (n) {\n\t\t\tmemset(loc_data, 0, sizeof(char) * 8);\n\t\t\tdata_len = (itype == GF_ITAG_FRAC6) ? 6 : 8;\n\t\t\tloc_data[3] = n;\n\t\t\tloc_data[2] = n >> 8;\n\t\t\tloc_data[5] = d;\n\t\t\tloc_data[4] = d >> 8;\n\t\t\tdata = loc_data;\n\t\t} else {\n\t\t\tdata = NULL;\n\t\t}\n\t\tdbox->flags = 0x15;\n\t\tbreak;\n\tcase GF_ITAG_BOOL:\n\t\tloc_data[0] = 0;\n\t\tif (data && data_len) {\n\t\t\tif ( !strcmp(data, \"yes\") || !strcmp(data, \"1\") || !strcmp(data, \"true\"))\n\t\t\t\tloc_data[0] = 1;\n\t\t} else {\n\t\t\tloc_data[0] = int_val ? 1 : 0;\n\t\t}\n\t\tdata = loc_data;\n\t\tdata_len = 1;\n\t\tdbox->flags = int_flags;\n\t\tbreak;\n\tcase GF_ITAG_INT8:\n\t\tloc_data[0] = 0;\n\t\tif (data && data_len) int_val = atoi(data);\n\t\tloc_data[0] = (u8) int_val;\n\t\tdata = loc_data;\n\t\tdata_len = 1;\n\t\tdbox->flags = int_flags;\n\t\tbreak;\n\tcase GF_ITAG_INT16:\n\t\tloc_data[0] = 0;\n\t\tif (data && data_len) int_val = atoi(data);\n\t\tloc_data[1] = (u8) int_val;\n\t\tloc_data[0] = (u8) (int_val>>8);\n\t\tdata = loc_data;\n\t\tdata_len = 2;\n\t\tdbox->flags = int_flags;\n\t\tbreak;\n\tcase GF_ITAG_INT32:\n\t\tloc_data[0] = 0;\n\t\tif (data && data_len) int_val = atoi(data);\n\t\tloc_data[3] = (u8) int_val;\n\t\tloc_data[2] = (u8) (int_val>>8);\n\t\tloc_data[1] = (u8) (int_val>>16);\n\t\tloc_data[0] = (u8) (int_val>>24);\n\t\tdata = loc_data;\n\t\tdata_len = 4;\n\t\tdbox->flags = int_flags;\n\t\tbreak;\n\tcase GF_ITAG_INT64:\n\t\tloc_data[0] = 0;\n\t\tif (data && data_len) sscanf(data, LLU, &int_val);\n\t\tloc_data[7] = (u8) int_val;\n\t\tloc_data[6] = (u8) (int_val>>8);\n\t\tloc_data[5] = (u8) (int_val>>16);\n\t\tloc_data[4] = (u8) (int_val>>24);\n\t\tloc_data[3] = (u8) (int_val>>32);\n\t\tloc_data[2] = (u8) (int_val>>40);\n\t\tloc_data[1] = (u8) (int_val>>48);\n\t\tloc_data[0] = (u8) (int_val>>56);\n\t\tdata = loc_data;\n\t\tdata_len = 8;\n\t\tdbox->flags = int_flags;\n\t\tbreak;\n\tdefault:\n\t\tdbox->flags = 1;\n\t\tbreak;\n\t}\n\n\tif (!data) return GF_BAD_PARAM;\n\n\n\tif (tag==GF_ISOM_ITUNE_COVER_ART) {\n\t\tinfo->data->flags = 0;\n\t\t/*check for PNG sig*/\n\t\tif ((data_len>4) && (data[0] == 0x89) && (data[1] == 0x50) && (data[2] == 0x4E) && (data[3] == 0x47) ) {\n\t\t\tinfo->data->flags = 14;\n\t\t}\n\t\t//JPG and JFIF - do not check second tag type\n\t\telse if ((data_len>4) && (data[0] == 0xFF) && (data[1] == 0xD8) && (data[2] == 0xFF) /*&& ((data[3] == 0xE0) || (data[3] == 0xDB))*/ ) {\n\t\t\tinfo->data->flags = 13;\n\t\t}\n\t\t//GIF\n\t\telse if ((data_len>3) && (data[0] == 'G') && (data[1] == 'I') && (data[2] == 'F') ) {\n\t\t\tinfo->data->flags = 12;\n\t\t}\n\t}\n\n\tdbox->dataSize = data_len;\n\tdbox->data = (char*)gf_malloc(sizeof(char)*data_len);\n\tif (!dbox->data) return GF_OUT_OF_MEM;\n\tmemcpy(dbox->data, data, sizeof(char)*data_len);\n\n\tif (!info && !gf_list_count(ilst->child_boxes) ) {\n\t\tgf_isom_box_del_parent(&meta->child_boxes, (GF_Box *) ilst);\n\t\treturn GF_OK;\n\t}\n\tif (!ilst->child_boxes) ilst->child_boxes = gf_list_new();\n\t\n\treturn gf_list_add(ilst->child_boxes, info);\n}\n\n#include <gpac/utf.h>\n\nGF_EXPORT\nGF_Err gf_isom_wma_set_tag(GF_ISOFile *mov, char *name, char *value)\n{\n\tGF_Err e;\n\tGF_XtraTag *tag=NULL;\n\tu32 count, i;\n\tGF_XtraBox *xtra;\n\n\te = CanAccessMovie(mov, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tgf_isom_create_meta_extensions(mov, GF_FALSE);\n\n\txtra = (GF_XtraBox *) gf_isom_create_meta_extensions(mov, GF_TRUE);\n\tif (!xtra) return GF_BAD_PARAM;\n\n\tcount = gf_list_count(xtra->tags);\n\tfor (i=0; i<count; i++) {\n\t\ttag = gf_list_get(xtra->tags, i);\n\t\tif (name && tag->name && !strcmp(tag->name, name)) {\n\n\t\t} else {\n\t\t\ttag = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!value) {\n\t\t\tgf_list_rem(xtra->tags, i);\n\t\t\tgf_free(tag->name);\n\t\t\tif (tag->prop_value) gf_free(tag->prop_value);\n\t\t\tgf_free(tag);\n\t\t\treturn GF_OK;\n\t\t}\n\t\tgf_free(tag->prop_value);\n\t\ttag->prop_value = 0;\n\t}\n\tif (!tag) {\n\t\tif (!name) return GF_OK;\n\n\t\tGF_SAFEALLOC(tag, GF_XtraTag);\n\t\ttag->name = gf_strdup(name);\n\t\ttag->prop_type = 0;\n\t\ttag->flags = 1;\n\t\tgf_list_add(xtra->tags, tag);\n\t}\n\n\tu32 len = (u32) strlen(value);\n\ttag->prop_value = gf_malloc(sizeof(u16) * (len+1) );\n\tmemset(tag->prop_value, 0, sizeof(u16) * (len+1) );\n\tif (len) {\n\t\tu32 _len = gf_utf8_mbstowcs((u16 *) tag->prop_value, len, (const char **) &value);\n\t\tif (_len == GF_UTF8_FAIL) _len = 0;\n\t\ttag->prop_value[2 * _len] = 0;\n\t\ttag->prop_value[2 * _len + 1] = 0;\n\t\ttag->prop_size = 2 * _len + 2;\n\t} else {\n\t\ttag->prop_size = 2;\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_qt_key(GF_ISOFile *movie, GF_QT_UDTAKey *key)\n{\n\tGF_Err e;\n\tGF_MetaBox *meta;\n\tGF_ItemListBox *ilst;\n\tGF_MetaKeysBox *keys;\n\tu32 i, nb_keys;\n\n\tif (!movie) return GF_BAD_PARAM;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) {\n\t\tgf_isom_set_last_error(movie, e);\n\t\treturn 0;\n\t}\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\n\tmeta = (GF_MetaBox *) gf_isom_create_meta_extensions(movie, 2);\n\tif (!meta) return GF_BAD_PARAM;\n\n\tkeys = (GF_MetaKeysBox *) gf_isom_locate_box(meta->child_boxes, GF_ISOM_BOX_TYPE_KEYS, NULL);\n\tif (!keys) {\n\t\tkeys = (GF_MetaKeysBox *) gf_isom_box_new_parent(&meta->child_boxes, GF_ISOM_BOX_TYPE_KEYS);\n\t\tmeta->keys = keys;\n\t}\n\tilst = (GF_ItemListBox *) gf_isom_locate_box(meta->child_boxes, GF_ISOM_BOX_TYPE_ILST, NULL);\n\tif (!ilst) {\n\t\tilst = (GF_ItemListBox *) gf_isom_box_new_parent(&meta->child_boxes, GF_ISOM_BOX_TYPE_ILST);\n\t}\n\tif (!keys || !ilst) return GF_OUT_OF_MEM;\n\n\tnb_keys = gf_list_count(keys->keys);\n\tif (!key) {\n\t\tgf_isom_box_del_parent(&meta->child_boxes, (GF_Box *) keys);\n\t\tfor (i=0; i<gf_list_count(ilst->child_boxes); i++) {\n\t\t\tGF_ListItemBox *info = gf_list_get(ilst->child_boxes, i);\n\t\t\tif (info->type <= nb_keys) {\n\t\t\t\tgf_isom_box_del_parent(&ilst->child_boxes, (GF_Box *) info);\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\t\tif (!gf_list_count(ilst->child_boxes)) {\n\t\t\tgf_isom_box_del_parent(&meta->child_boxes, (GF_Box *) ilst);\n\t\t\t//if last, delete udta - we may still have a handler box remaining\n\t\t\tif ((gf_list_count(meta->child_boxes) <= 1) && (gf_list_count(movie->moov->udta->recordList)==1)) {\n\t\t\t\tgf_isom_box_del_parent(&movie->moov->child_boxes, (GF_Box *) movie->moov->udta);\n\t\t\t\tmovie->moov->udta = NULL;\n\t\t\t}\n\t\t}\n\t\treturn GF_OK;\n\t}\n\t//locate key\n\tGF_MetaKey *o_key = NULL;\n\tu32 ksize = (u32) strlen(key->name);\n\tfor (i=0; i<nb_keys; i++) {\n\t\to_key = gf_list_get(keys->keys, i);\n\t\tif ((o_key->ns == key->ns) && (o_key->size==ksize) && !strcmp(o_key->data, key->name))\n\t\t\tbreak;\n\t\to_key = NULL;\n\t}\n\tif (!o_key) {\n\t\tif (key->type==GF_QT_KEY_REMOVE) return GF_OK;\n\t\tGF_SAFEALLOC(o_key, GF_MetaKey);\n\t\to_key->ns = key->ns;\n\t\to_key->data = gf_strdup(key->name);\n\t\to_key->size = ksize;\n\t\tgf_list_add(keys->keys, o_key);\n\t}\n\tu32 key_idx = gf_list_find(keys->keys, o_key)+1;\n\tGF_UnknownBox *info=NULL;\n\tfor (i=0; i<gf_list_count(ilst->child_boxes); i++) {\n\t\tinfo = gf_list_get(ilst->child_boxes, i);\n\t\tif (info->original_4cc == key_idx) break;\n\t\tinfo = NULL;\n\t}\n\n\tif (key->type==GF_QT_KEY_REMOVE) {\n\t\tgf_list_del_item(keys->keys, o_key);\n\t\tif (o_key->data) gf_free(o_key->data);\n\t\tgf_free(o_key);\n\t\tfor (i=0; i<gf_list_count(ilst->child_boxes); i++) {\n\t\t\tinfo = gf_list_get(ilst->child_boxes, i);\n\t\t\tif (info->type!=GF_ISOM_BOX_TYPE_UNKNOWN) continue;\n\t\t\tif (info->original_4cc==key_idx) {\n\t\t\t\tgf_isom_box_del_parent(&ilst->child_boxes, (GF_Box *)info);\n\t\t\t\ti--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (info->original_4cc>key_idx) {\n\t\t\t\tinfo->original_4cc--;\n\t\t\t}\n\t\t}\n\t\treturn GF_OK;\n\t}\n\tif (!info) {\n\t\tinfo = (GF_UnknownBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_UNKNOWN);\n\t\tif (!info) return GF_OUT_OF_MEM;\n\t\tif (!ilst->child_boxes) ilst->child_boxes = gf_list_new();\n\t\tgf_list_add(ilst->child_boxes, info);\n\t}\n\n\tGF_DataBox *dbox = (GF_DataBox *) gf_isom_box_find_child(info->child_boxes, GF_ISOM_BOX_TYPE_DATA);\n\tif (!dbox) {\n\t\tdbox = (GF_DataBox *)gf_isom_box_new_parent(&info->child_boxes, GF_ISOM_BOX_TYPE_DATA);\n\t\tif (!dbox) {\n\t\t\tgf_isom_box_del((GF_Box *)info);\n\t\t\treturn GF_OUT_OF_MEM;\n\t\t}\n\t}\n\tu32 nb_bits=0;\n\tinfo->original_4cc = key_idx;\n\tdbox->version = 0;\n\tdbox->flags = key->type;\n\t//serialize\n\tGF_BitStream *bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\tswitch (key->type) {\n\tcase GF_QT_KEY_UTF8:\n\tcase GF_QT_KEY_UTF8_SORT:\n\t\tif (key->value.string)\n\t\t\tgf_bs_write_data(bs, key->value.string, (u32) strlen(key->value.string));\n\t\tbreak;\n\n\tcase GF_QT_KEY_SIGNED_VSIZE:\n\t\tif (ABS(key->value.sint)<=0x7F) nb_bits=8;\n\t\telse if (ABS(key->value.sint)<=0x7FFF) nb_bits=16;\n\t\telse if (ABS(key->value.sint)<=0x7FFFFF) nb_bits=24;\n\t\telse nb_bits = 32;\n\t\tgf_bs_write_int(bs, (s32) key->value.sint, nb_bits);\n\t\tbreak;\n\tcase GF_QT_KEY_UNSIGNED_VSIZE:\n\t\tif (key->value.uint<=0xFF) nb_bits=8;\n\t\telse if (key->value.uint<=0xFFFF) nb_bits=16;\n\t\telse if (key->value.uint<=0xFFFFFF) nb_bits=24;\n\t\telse nb_bits = 32;\n\t\tgf_bs_write_int(bs, (u32) key->value.uint, nb_bits);\n\t\tbreak;\n\tcase GF_QT_KEY_FLOAT:\n\t\tgf_bs_write_float(bs, (Float) key->value.number);\n\t\tbreak;\n\tcase GF_QT_KEY_DOUBLE:\n\t\tgf_bs_write_double(bs, key->value.number);\n\t\tbreak;\n\tcase GF_QT_KEY_SIGNED_8:\n\t\tgf_bs_write_int(bs, (s32) key->value.sint, 8);\n\t\tbreak;\n\tcase GF_QT_KEY_SIGNED_16:\n\t\tgf_bs_write_int(bs, (s32) key->value.sint, 16);\n\t\tbreak;\n\tcase GF_QT_KEY_SIGNED_32:\n\t\tgf_bs_write_int(bs, (s32) key->value.sint, 32);\n\t\tbreak;\n\tcase GF_QT_KEY_SIGNED_64:\n\t\tgf_bs_write_long_int(bs, key->value.sint, 64);\n\t\tbreak;\n\tcase GF_QT_KEY_POINTF:\n\tcase GF_QT_KEY_SIZEF:\n\t\tgf_bs_write_float(bs, key->value.pos_size.x);\n\t\tgf_bs_write_float(bs, key->value.pos_size.y);\n\t\tbreak;\n\tcase GF_QT_KEY_RECTF:\n\t\tgf_bs_write_float(bs, key->value.rect.x);\n\t\tgf_bs_write_float(bs, key->value.rect.y);\n\t\tgf_bs_write_float(bs, key->value.rect.w);\n\t\tgf_bs_write_float(bs, key->value.rect.h);\n\t\tbreak;\n\n\tcase GF_QT_KEY_UNSIGNED_8:\n\t\tgf_bs_write_int(bs, (s32) key->value.uint, 8);\n\t\tbreak;\n\tcase GF_QT_KEY_UNSIGNED_16:\n\t\tgf_bs_write_int(bs, (s32) key->value.uint, 16);\n\t\tbreak;\n\tcase GF_QT_KEY_UNSIGNED_32:\n\t\tgf_bs_write_int(bs, (s32) key->value.uint, 32);\n\t\tbreak;\n\tcase GF_QT_KEY_UNSIGNED_64:\n\t\tgf_bs_write_long_int(bs, key->value.uint, 64);\n\t\tbreak;\n\tcase GF_QT_KEY_MATRIXF:\n\t\tfor (i=0; i<9; i++)\n\t\t\tgf_bs_write_float(bs, (Float) key->value.matrix[i] );\n\t\tbreak;\n\n\tcase GF_QT_KEY_OPAQUE:\n\tcase GF_QT_KEY_UTF16_BE:\n\tcase GF_QT_KEY_JIS:\n\tcase GF_QT_KEY_UTF16_SORT:\n\tcase GF_QT_KEY_JPEG:\n\tcase GF_QT_KEY_PNG:\n\tcase GF_QT_KEY_BMP:\n\tcase GF_QT_KEY_METABOX:\n\tdefault:\n\t\tgf_bs_write_data(bs, key->value.data.data, key->value.data.data_len);\n\t\tbreak;\n\t}\n\t//write extra 0 at end, not serialized\n\tgf_bs_write_u8(bs, 0);\n\tif (dbox->data) gf_free(dbox->data);\n\n\tgf_bs_get_content(bs, &dbox->data, &i);\n\tif (i) i--;\n\tdbox->dataSize = i;\n\tgf_bs_del(bs);\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_set_alternate_group_id(GF_ISOFile *movie, u32 trackNumber, u32 groupId)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\ttrak->Header->alternate_group = groupId;\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_set_track_switch_parameter(GF_ISOFile *movie, u32 trackNumber, u32 trackRefGroup, Bool is_switch_group, u32 *switchGroupID, u32 *criteriaList, u32 criteriaListCount)\n{\n\tGF_TrackSelectionBox *tsel;\n\tGF_TrackBox *trak;\n\tGF_UserDataMap *map;\n\tGF_Err e;\n\tu32 alternateGroupID = 0;\n\tu32 next_switch_group_id = 0;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !switchGroupID) return GF_BAD_PARAM;\n\n\n\tif (trackRefGroup) {\n\t\tGF_TrackBox *trak_ref = gf_isom_get_track_from_file(movie, trackRefGroup);\n\t\tif (trak_ref != trak) {\n\t\t\tif (!trak_ref || !trak_ref->Header->alternate_group) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"Track %d has not an alternate group - skipping\\n\", trak_ref ? trak_ref->Header->trackID : 0));\n\t\t\t\treturn GF_BAD_PARAM;\n\t\t\t}\n\t\t\talternateGroupID = trak_ref->Header->alternate_group;\n\t\t} else {\n\t\t\talternateGroupID = trak->Header->alternate_group;\n\t\t}\n\t}\n\tif (!alternateGroupID) {\n\t\t/*there is a function for this ....*/\n\t\tif (trak->Header->alternate_group) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"Track %d has already an alternate group - skipping\\n\", trak->Header->trackID));\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t\talternateGroupID = gf_isom_get_next_alternate_group_id(movie);\n\t}\n\n\tif (is_switch_group) {\n\t\tu32 i=0;\n\t\twhile (i< gf_isom_get_track_count(movie) ) {\n\t\t\t//locate first available ID\n\t\t\tGF_TrackBox *a_trak = gf_isom_get_track_from_file(movie, i+1);\n\n\t\t\tif (a_trak->udta) {\n\t\t\t\tu32 j, count;\n\t\t\t\tmap = udta_getEntry(a_trak->udta, GF_ISOM_BOX_TYPE_TSEL, NULL);\n\t\t\t\tif (map) {\n\t\t\t\t\tcount = gf_list_count(map->boxes);\n\t\t\t\t\tfor (j=0; j<count; j++) {\n\t\t\t\t\t\ttsel = (GF_TrackSelectionBox*)gf_list_get(map->boxes, j);\n\n\t\t\t\t\t\tif (*switchGroupID) {\n\t\t\t\t\t\t\tif (tsel->switchGroup==next_switch_group_id) {\n\t\t\t\t\t\t\t\tif (a_trak->Header->alternate_group != alternateGroupID) return GF_BAD_PARAM;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (tsel->switchGroup && (tsel->switchGroup>=next_switch_group_id) )\n\t\t\t\t\t\t\t\tnext_switch_group_id = tsel->switchGroup;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tif (! *switchGroupID) *switchGroupID = next_switch_group_id+1;\n\t}\n\n\n\ttrak->Header->alternate_group = alternateGroupID;\n\n\ttsel = NULL;\n\tif (*switchGroupID) {\n\t\tif (!trak->udta) {\n\t\t\te = trak_on_child_box((GF_Box*)trak, gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_UDTA), GF_FALSE);\n\t\t\tif (e) return e;\n\t\t}\n\n\t\tmap = udta_getEntry(trak->udta, GF_ISOM_BOX_TYPE_TSEL, NULL);\n\n\t\t/*locate tsel box with no switch group*/\n\t\tif (map)  {\n\t\t\tu32 j, count = gf_list_count(map->boxes);\n\t\t\tfor (j=0; j<count; j++) {\n\t\t\t\ttsel = (GF_TrackSelectionBox*)gf_list_get(map->boxes, j);\n\t\t\t\tif (tsel->switchGroup == *switchGroupID) break;\n\t\t\t\ttsel = NULL;\n\t\t\t}\n\t\t}\n\t\tif (!tsel) {\n\t\t\ttsel = (GF_TrackSelectionBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_TSEL);\n\t\t\tif (!tsel) return GF_OUT_OF_MEM;\n\t\t\te = udta_on_child_box((GF_Box *)trak->udta, (GF_Box *) tsel, GF_FALSE);\n\t\t\tif (e) return e;\n\t\t}\n\n\t\ttsel->switchGroup = *switchGroupID;\n\t\ttsel->attributeListCount = criteriaListCount;\n\t\tif (tsel->attributeList) gf_free(tsel->attributeList);\n\t\ttsel->attributeList = (u32*)gf_malloc(sizeof(u32)*criteriaListCount);\n\t\tif (!tsel->attributeList) return GF_OUT_OF_MEM;\n\t\tmemcpy(tsel->attributeList, criteriaList, sizeof(u32)*criteriaListCount);\n\t}\n\treturn GF_OK;\n}\n\nvoid reset_tsel_box(GF_TrackBox *trak)\n{\n\tGF_UserDataMap *map;\n\ttrak->Header->alternate_group = 0;\n\tmap = udta_getEntry(trak->udta, GF_ISOM_BOX_TYPE_TSEL, NULL);\n\tif (map) {\n\t\tgf_list_del_item(trak->udta->recordList, map);\n\t\tgf_isom_box_array_del(map->boxes);\n\t\tgf_free(map);\n\t}\n\n}\n\nGF_EXPORT\nGF_Err gf_isom_reset_track_switch_parameter(GF_ISOFile *movie, u32 trackNumber, Bool reset_all_group)\n{\n\tGF_TrackBox *trak;\n\tu32 alternateGroupID = 0;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\tif (!trak->Header->alternate_group) return GF_OK;\n\n\talternateGroupID = trak->Header->alternate_group;\n\tif (reset_all_group) {\n\t\tu32 i=0;\n\t\twhile (i< gf_isom_get_track_count(movie) ) {\n\t\t\t//locate first available ID\n\t\t\tGF_TrackBox *a_trak = gf_isom_get_track_from_file(movie, i+1);\n\t\t\tif (a_trak->Header->alternate_group == alternateGroupID) reset_tsel_box(a_trak);\n\t\t\ti++;\n\t\t}\n\t} else {\n\t\treset_tsel_box(trak);\n\t}\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_reset_switch_parameters(GF_ISOFile *movie)\n{\n\tu32 i=0;\n\twhile (i< gf_isom_get_track_count(movie) ) {\n\t\t//locate first available ID\n\t\tGF_TrackBox *a_trak = gf_isom_get_track_from_file(movie, i+1);\n\t\treset_tsel_box(a_trak);\n\t\ti++;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err gf_isom_add_subsample(GF_ISOFile *movie, u32 track, u32 sampleNumber, u32 flags, u32 subSampleSize, u8 priority, u32 reserved, Bool discardable)\n{\n\tu32 i, count;\n\tGF_SubSampleInformationBox *sub_samples;\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, track);\n\tif (!trak || !trak->Media || !trak->Media->information->sampleTable)\n\t\treturn GF_BAD_PARAM;\n\n\tif (!trak->Media->information->sampleTable->sub_samples) {\n\t\ttrak->Media->information->sampleTable->sub_samples=gf_list_new();\n\t}\n\n\tsub_samples = NULL;\n\tcount = gf_list_count(trak->Media->information->sampleTable->sub_samples);\n\tfor (i=0; i<count; i++) {\n\t\tsub_samples = gf_list_get(trak->Media->information->sampleTable->sub_samples, i);\n\t\tif (sub_samples->flags==flags) break;\n\t\tsub_samples = NULL;\n\t}\n\tif (!sub_samples) {\n\t\tsub_samples = (GF_SubSampleInformationBox *) gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_SUBS);\n\t\tif (!sub_samples) return GF_OUT_OF_MEM;\n\t\tgf_list_add(trak->Media->information->sampleTable->sub_samples, sub_samples);\n\t\tsub_samples->version = (subSampleSize>0xFFFF) ? 1 : 0;\n\t\tsub_samples->flags = flags;\n\t}\n\treturn gf_isom_add_subsample_info(sub_samples, sampleNumber, subSampleSize, priority, reserved, discardable);\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_set_rvc_config(GF_ISOFile *movie, u32 track, u32 sampleDescriptionIndex, u16 rvc_predefined, char *mime, u8 *data, u32 size)\n{\n\tGF_MPEGVisualSampleEntryBox *entry;\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, track);\n\tif (!trak) return GF_BAD_PARAM;\n\n\n\tentry = (GF_MPEGVisualSampleEntryBox *) gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, sampleDescriptionIndex-1);\n\tif (!entry ) return GF_BAD_PARAM;\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return GF_BAD_PARAM;\n\n\tGF_RVCConfigurationBox *rvcc = (GF_RVCConfigurationBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_RVCC);\n\tif (rvcc && rvcc->rvc_meta_idx) {\n\t\tgf_isom_remove_meta_item(movie, GF_FALSE, track, rvcc->rvc_meta_idx, GF_FALSE, NULL);\n\t\trvcc->rvc_meta_idx = 0;\n\t}\n\n\tif (!rvcc) {\n\t\trvcc = (GF_RVCConfigurationBox *) gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_RVCC);\n\t\tif (!rvcc) return GF_OUT_OF_MEM;\n\t}\n\trvcc->predefined_rvc_config = rvc_predefined;\n\tif (!rvc_predefined) {\n\t\tu32 it_id=0;\n\t\te = gf_isom_set_meta_type(movie, GF_FALSE, track, GF_META_TYPE_RVCI);\n\t\tif (e) return e;\n\t\tgf_isom_modify_alternate_brand(movie, GF_ISOM_BRAND_ISO2, GF_TRUE);\n\t\te = gf_isom_add_meta_item_memory(movie, GF_FALSE, track, \"rvcconfig.xml\", &it_id, GF_META_ITEM_TYPE_MIME, mime, NULL, NULL, data, size, NULL);\n\t\tif (e) return e;\n\t\trvcc->rvc_meta_idx = gf_isom_get_meta_item_count(movie, GF_FALSE, track);\n\t}\n\treturn GF_OK;\n}\n\n/*for now not exported*/\n/*expands sampleGroup table for the given grouping type and sample_number. If sample_number is 0, just appends an entry at the end of the table*/\nstatic GF_Err gf_isom_add_sample_group_entry(GF_List *sampleGroups, u32 sample_number, GF_SampleGroupDescriptionBox *sgdesc, u32 grouping_type_parameter, u32 sampleGroupDescriptionIndex, GF_List *parent, GF_SampleTableBox *stbl)\n{\n\tGF_SampleGroupBox *sgroup = NULL;\n\tu32 i, count, last_sample_in_entry;\n\tBool all_samples = GF_FALSE;\n\tassert(sampleGroups);\n\tif (!sgdesc) return GF_BAD_PARAM;\n\tcount = gf_list_count(sampleGroups);\n\tfor (i=0; i<count; i++) {\n\t\tsgroup = (GF_SampleGroupBox*)gf_list_get(sampleGroups, i);\n\t\tif (sgroup->grouping_type==sgdesc->grouping_type) break;\n\t\tsgroup = NULL;\n\t}\n\tif (!sgroup) {\n\t\tsgroup = (GF_SampleGroupBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_SBGP);\n\t\tif (!sgroup) return GF_OUT_OF_MEM;\n\t\tsgroup->grouping_type = sgdesc->grouping_type;\n\t\tsgroup->grouping_type_parameter = grouping_type_parameter;\n//\t\tgf_list_add(sampleGroups, sgroup);\n\t\t//crude patch to align old arch and filters\n\t\tgf_list_insert(sampleGroups, sgroup, 0);\n\t\tassert(parent);\n\t\tgf_list_add(parent, sgroup);\n\t}\n\tu32 def_insert_value = (sgdesc && (sgdesc->version==2)) ? sgdesc->default_description_index : 0;\n\n\t/*used in fragments, means we are adding the last sample*/\n\tif (!sample_number) {\n\t\tsample_number = 1;\n\t\tif (sgroup->entry_count) {\n\t\t\tfor (i=0; i<sgroup->entry_count; i++) {\n\t\t\t\tsample_number += sgroup->sample_entries[i].sample_count;\n\t\t\t}\n\t\t}\n\t} else if (sample_number==(u32) -1) {\n\t\tall_samples = GF_TRUE;\n\t\tsample_number = 1;\n\t}\n\n\tif (!sgroup->entry_count) {\n\t\tu32 idx = 0;\n\t\tsgroup->entry_count = (sample_number>1) ? 2 : 1;\n\t\tsgroup->sample_entries = (GF_SampleGroupEntry*)gf_malloc(sizeof(GF_SampleGroupEntry) * sgroup->entry_count );\n\t\tif (!sgroup->sample_entries) return GF_OUT_OF_MEM;\n\t\tif (sample_number>1) {\n\t\t\tsgroup->sample_entries[0].sample_count = sample_number-1;\n\t\t\tsgroup->sample_entries[0].group_description_index = sampleGroupDescriptionIndex ? def_insert_value : 1;\n\t\t\tidx = 1;\n\t\t}\n\t\tsgroup->sample_entries[idx].sample_count = 1;\n\t\tsgroup->sample_entries[idx].group_description_index = sampleGroupDescriptionIndex;\n\t\tif (all_samples && stbl) {\n\t\t\tsgroup->sample_entries[idx].sample_count = stbl->SampleSize->sampleCount;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\tif (all_samples && stbl) {\n\t\tsgroup->entry_count = 1;\n\t\tsgroup->sample_entries[0].group_description_index = sampleGroupDescriptionIndex;\n\t\tsgroup->sample_entries[0].sample_count = stbl->SampleSize->sampleCount;\n\t\treturn GF_OK;\n\t}\n\tlast_sample_in_entry = 0;\n\tfor (i=0; i<sgroup->entry_count; i++) {\n\t\t/*TODO*/\n\t\tif (last_sample_in_entry + sgroup->sample_entries[i].sample_count > sample_number)\n\t\t\treturn GF_NOT_SUPPORTED;\n\t\tlast_sample_in_entry += sgroup->sample_entries[i].sample_count;\n\t}\n\n\tif (last_sample_in_entry == sample_number) {\n\t\tif (sgroup->sample_entries[sgroup->entry_count-1].group_description_index==sampleGroupDescriptionIndex)\n\t\t\treturn GF_OK;\n\t\telse\n\t\t\treturn GF_NOT_SUPPORTED;\n\t}\n\n\tif ((sgroup->sample_entries[sgroup->entry_count-1].group_description_index==sampleGroupDescriptionIndex) && (last_sample_in_entry+1==sample_number)) {\n\t\tsgroup->sample_entries[sgroup->entry_count-1].sample_count++;\n\t\treturn GF_OK;\n\t}\n\t/*last entry was an empty desc (no group associated), just add the number of samples missing until new one, then add new one*/\n\tif (! sgroup->sample_entries[sgroup->entry_count-1].group_description_index) {\n\t\tsgroup->sample_entries[sgroup->entry_count-1].sample_count += sample_number - 1 - last_sample_in_entry;\n\t\tsgroup->sample_entries = (GF_SampleGroupEntry*)gf_realloc(sgroup->sample_entries, sizeof(GF_SampleGroupEntry) * (sgroup->entry_count + 1) );\n\t\tsgroup->sample_entries[sgroup->entry_count].sample_count = 1;\n\t\tsgroup->sample_entries[sgroup->entry_count].group_description_index = sampleGroupDescriptionIndex;\n\t\tsgroup->entry_count++;\n\t\treturn GF_OK;\n\t}\n\t/*we are adding a sample with no desc, add entry at the end*/\n\tif (!sampleGroupDescriptionIndex || (sample_number - 1 - last_sample_in_entry==0) ) {\n\t\tsgroup->sample_entries = (GF_SampleGroupEntry*)gf_realloc(sgroup->sample_entries, sizeof(GF_SampleGroupEntry) * (sgroup->entry_count + 1) );\n\t\tsgroup->sample_entries[sgroup->entry_count].sample_count = 1;\n\t\tsgroup->sample_entries[sgroup->entry_count].group_description_index = sampleGroupDescriptionIndex;\n\t\tsgroup->entry_count++;\n\t\treturn GF_OK;\n\t}\n\t/*need to insert two entries ...*/\n\tsgroup->sample_entries = (GF_SampleGroupEntry*)gf_realloc(sgroup->sample_entries, sizeof(GF_SampleGroupEntry) * (sgroup->entry_count + 2) );\n\n\tsgroup->sample_entries[sgroup->entry_count].sample_count = sample_number - 1 - last_sample_in_entry;\n\tsgroup->sample_entries[sgroup->entry_count].group_description_index = def_insert_value;\n\n\tsgroup->sample_entries[sgroup->entry_count+1].sample_count = 1;\n\tsgroup->sample_entries[sgroup->entry_count+1].group_description_index = sampleGroupDescriptionIndex;\n\tsgroup->entry_count+=2;\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\nstatic GF_SampleGroupDescriptionBox *get_sgdp(GF_SampleTableBox *stbl, GF_TrackFragmentBox *traf, u32 grouping_type, Bool *is_traf_sgdp)\n#else\nstatic GF_SampleGroupDescriptionBox *get_sgdp(GF_SampleTableBox *stbl, void *traf, u32 grouping_type, Bool *is_traf_sgdp)\n#endif /* GPAC_DISABLE_ISOM_FRAGMENTS */\n{\n\tGF_List *groupList=NULL;\n\tGF_List **parent=NULL;\n\tGF_SampleGroupDescriptionBox *sgdesc=NULL;\n\tu32 count, i;\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (!stbl && traf && traf->trex->track->Media->information->sampleTable)\n\t\tstbl = traf->trex->track->Media->information->sampleTable;\n#endif\n\tif (stbl) {\n\t\tif (!stbl->sampleGroupsDescription && !traf)\n\t\t\tstbl->sampleGroupsDescription = gf_list_new();\n\n\t\tgroupList = stbl->sampleGroupsDescription;\n\t\tif (is_traf_sgdp) *is_traf_sgdp = GF_FALSE;\n\t\tparent = &stbl->child_boxes;\n\n\t\tcount = gf_list_count(groupList);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tsgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(groupList, i);\n\t\t\tif (sgdesc->grouping_type==grouping_type) break;\n\t\t\tsgdesc = NULL;\n\t\t}\n\t}\n\t\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t/*look in stbl or traf for sample sampleGroupsDescription*/\n\tif (!sgdesc && traf) {\n\t\tif (!traf->sampleGroupsDescription)\n\t\t\ttraf->sampleGroupsDescription = gf_list_new();\n\t\tgroupList = traf->sampleGroupsDescription;\n\t\tparent = &traf->child_boxes;\n\t\tif (is_traf_sgdp) *is_traf_sgdp = GF_TRUE;\n\n\t\tcount = gf_list_count(groupList);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tsgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(groupList, i);\n\t\t\tif (sgdesc->grouping_type==grouping_type) break;\n\t\t\tsgdesc = NULL;\n\t\t}\n\t}\n#endif\n\n\tif (!sgdesc) {\n\t\tsgdesc = (GF_SampleGroupDescriptionBox *) gf_isom_box_new_parent(parent, GF_ISOM_BOX_TYPE_SGPD);\n\t\tif (!sgdesc) return NULL;\n\t\tsgdesc->grouping_type = grouping_type;\n\t\tassert(groupList);\n\t\tgf_list_add(groupList, sgdesc);\n\t}\n\treturn sgdesc;\n}\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\nstatic GF_Err gf_isom_set_sample_group_info_ex(GF_SampleTableBox *stbl, GF_TrackFragmentBox *traf, u32 sample_number, u32 grouping_type, u32 grouping_type_parameter, void *udta, void *(*sg_create_entry)(void *udta), Bool (*sg_compare_entry)(void *udta, void *entry))\n#else\nstatic GF_Err gf_isom_set_sample_group_info_ex(GF_SampleTableBox *stbl, void *traf, u32 sample_number, u32 grouping_type, u32 grouping_type_parameter, void *udta, void *(*sg_create_entry)(void *udta), Bool (*sg_compare_entry)(void *udta, void *entry))\n#endif /* GPAC_DISABLE_ISOM_FRAGMENTS */\n{\n\tGF_List *groupList, *parent;\n\tvoid *entry;\n\tBool is_traf_sgpd;\n\tGF_SampleGroupDescriptionBox *sgdesc = NULL;\n\tu32 i, entry_idx;\n\n\tif (!stbl && !traf) return GF_BAD_PARAM;\n\n\tsgdesc = get_sgdp(stbl, traf, grouping_type, &is_traf_sgpd);\n\tif (!sgdesc) return GF_OUT_OF_MEM;\n\n\tentry = NULL;\n\tif (sg_compare_entry) {\n\t\tfor (i=0; i<gf_list_count(sgdesc->group_descriptions); i++) {\n\t\t\tentry = gf_list_get(sgdesc->group_descriptions, i);\n\t\t\tif (sg_compare_entry(udta, entry)) break;\n\t\t\tentry = NULL;\n\t\t}\n\t}\n\tif (!entry && sg_create_entry) {\n\t\tentry = sg_create_entry(udta);\n\t\tif (!entry) return GF_IO_ERR;\n\t\tif (traf && !is_traf_sgpd) {\n\t\t\tsgdesc = get_sgdp(NULL, traf, grouping_type, &is_traf_sgpd);\n\t\t}\n\t\tgf_list_add(sgdesc->group_descriptions, entry);\n\t}\n\tif (!entry)\n\t\tentry_idx = 0;\n\telse\n\t\tentry_idx = 1 + gf_list_find(sgdesc->group_descriptions, entry);\n\n\t/*look in stbl or traf for sample sampleGroups*/\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (traf) {\n\t\tif (!traf->sampleGroups)\n\t\t\ttraf->sampleGroups = gf_list_new();\n\t\tgroupList = traf->sampleGroups;\n\t\tparent = traf->child_boxes;\n\t\tif (entry_idx && is_traf_sgpd)\n\t\t\tentry_idx |= 0x10000;\n\t} else\n#endif\n\t{\n\t\tif (!stbl->sampleGroups)\n\t\t\tstbl->sampleGroups = gf_list_new();\n\t\tgroupList = stbl->sampleGroups;\n\t\tparent = stbl->child_boxes;\n\t}\n\n\treturn gf_isom_add_sample_group_entry(groupList, sample_number, sgdesc, grouping_type_parameter, entry_idx, parent, stbl);\n}\n\nstatic GF_Err gf_isom_set_sample_group_info_internal(GF_ISOFile *movie, u32 track, u32 trafID, u32 sample_number, u32 grouping_type, u32 grouping_type_parameter, void *udta, void *(*sg_create_entry)(void *udta), Bool (*sg_compare_entry)(void *udta, void *entry))\n{\n\tGF_Err e;\n\tGF_TrackBox *trak=NULL;\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tGF_TrackFragmentBox *traf=NULL;\n#endif\n\tif (!trafID && (movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY)) {\n\t\ttrak = gf_isom_get_track_from_file(movie, track);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\ttrafID = trak->Header->trackID;\n\t}\n\n\tif (trafID) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\tif (!movie->moof || !(movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY) )\n\t\t\treturn GF_BAD_PARAM;\n\n\t\ttraf = gf_isom_get_traf(movie, trafID);\n#else\n\t\treturn GF_NOT_SUPPORTED;\n#endif\n\n\t} else if (track) {\n\t\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\t\tif (e) return e;\n\n\t\ttrak = gf_isom_get_track_from_file(movie, track);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t}\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\treturn gf_isom_set_sample_group_info_ex(trak ? trak->Media->information->sampleTable : NULL, traf, sample_number, grouping_type, grouping_type_parameter, udta, sg_create_entry, sg_compare_entry);\n#else\n\treturn gf_isom_set_sample_group_info_ex(trak->Media->information->sampleTable, NULL, sample_number, grouping_type, grouping_type_parameter, udta, sg_create_entry, sg_compare_entry);\n#endif\n\n}\n\nvoid *sgpd_parse_entry(GF_SampleGroupDescriptionBox *p, GF_BitStream *bs, s32 bytes_in_box, u32 entry_size, u32 *total_bytes);\n\nGF_Err gf_isom_add_sample_group_info_internal(GF_ISOFile *movie, u32 track, u32 grouping_type, void *data, u32 data_size, u32 sgpd_flags, u32 *sampleGroupDescriptionIndex, Bool *is_traf_sgpd, Bool check_access, Bool *use_default, GF_SampleGroupDescriptionBox **out_sgdesc)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak=NULL;\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tGF_TrackFragmentBox *traf=NULL;\n#else\n\tvoid *traf=NULL;\n#endif\n\tu32 trafID=0;\n\tGF_DefaultSampleGroupDescriptionEntry *entry=NULL;\n\tGF_SampleGroupDescriptionBox *sgdesc = NULL;\n\tBool is_default = sgpd_flags & 0x80000000;\n\n\tif (sampleGroupDescriptionIndex) *sampleGroupDescriptionIndex = 0;\n\n\tif (movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY) {\n\t\ttrak = gf_isom_get_track_from_file(movie, track);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\ttrafID = trak->Header->trackID;\n\t}\n\n\tif (trafID) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\tif (!movie->moof || !(movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY) )\n\t\t\treturn GF_BAD_PARAM;\n\n\t\ttraf = gf_isom_get_traf(movie, trafID);\n#else\n\t\treturn GF_NOT_SUPPORTED;\n#endif\n\t} else {\n\t\tif (check_access) {\n\t\t\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\t\t\tif (e) return e;\n\t\t}\n\n\t\ttrak = gf_isom_get_track_from_file(movie, track);\n\t}\n\tif (!trak) return GF_BAD_PARAM;\n\n\t//get sample group desc for this grouping type\n\tsgdesc = get_sgdp(trak->Media->information->sampleTable, traf, grouping_type, is_traf_sgpd);\n\tif (!sgdesc) return GF_OUT_OF_MEM;\n\t//first time we create the sample group description, set flags\n\tif (!gf_list_count(sgdesc->group_descriptions) && !traf) {\n\t\tif (sgpd_flags&1) sgdesc->flags |= 1;\n\t\tif (sgpd_flags&2) sgdesc->flags |= 2;\n\t\tif (sgpd_flags&0x40000000) sgdesc->version=3;\n\t}\n\n\n\tGF_BitStream *bs = gf_bs_new(data, data_size, GF_BITSTREAM_READ);\n\tu32 bytes;\n\tentry = sgpd_parse_entry(sgdesc, bs, data_size, data_size, &bytes);\n\tgf_bs_del(bs);\n\tif (!entry) return GF_NON_COMPLIANT_BITSTREAM;\n\n\tif (out_sgdesc) *out_sgdesc = sgdesc;\n\n\n\t//find the same entry\n\tu32 k;\n\tfor (k=0; k<gf_list_count(sgdesc->group_descriptions); k++) {\n\t\tvoid *sgde_dst = gf_list_get(sgdesc->group_descriptions, k);\n\t\tif (gf_isom_is_identical_sgpd(entry, sgde_dst, sgdesc->grouping_type)) {\n\t\t\tif (sampleGroupDescriptionIndex) *sampleGroupDescriptionIndex = k+1;\n\t\t\tsgpd_del_entry(sgdesc->grouping_type, entry);\n\t\t\tif (use_default) {\n\t\t\t\tu32 idx = k+1;\n\t\t\t\tif (is_traf_sgpd && *is_traf_sgpd) idx |= 0x10000;\n\t\t\t\t*use_default = (sgdesc->default_description_index==idx) ? GF_TRUE : GF_FALSE;\n\t\t\t}\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\n\tif (traf && ! *is_traf_sgpd) {\n\t\tsgdesc = get_sgdp(NULL, traf, grouping_type, is_traf_sgpd);\n\t\tif (!sgdesc) return GF_OUT_OF_MEM;\n\t}\n\tif (out_sgdesc) *out_sgdesc = sgdesc;\n\n\te = gf_list_add(sgdesc->group_descriptions, entry);\n\tif (e) {\n\t\tsgpd_del_entry(sgdesc->grouping_type, entry);\n\t\treturn e;\n\t}\n\n#if 0\n\tif (grouping_type==GF_ISOM_SAMPLE_GROUP_OINF) {\n\t\tGF_OperatingPointsInformation *ptr = gf_isom_oinf_new_entry();\n\t\tGF_BitStream *bs=gf_bs_new(data, data_size, GF_BITSTREAM_READ);\n\t\te = gf_isom_oinf_read_entry(ptr, bs);\n\t\tgf_bs_del(bs);\n\t\tif (e) {\n\t\t\tgf_isom_oinf_del_entry(ptr);\n\t\t\treturn e;\n\t\t}\n\t\t//not in track, create new sgdp\n\t\tif (traf && ! *is_traf_sgpd) {\n\t\t\tsgdesc  = get_sgdp(NULL, traf, grouping_type, is_traf_sgpd);\n\t\t\tif (!sgdesc) return GF_OUT_OF_MEM;\n\t\t}\n\t\te = gf_list_add(sgdesc->group_descriptions, ptr);\n\t\tif (e) return e;\n\t\tentry = (GF_DefaultSampleGroupDescriptionEntry *) ptr;\n\t} else if (grouping_type==GF_ISOM_SAMPLE_GROUP_LINF) {\n\t\tGF_LHVCLayerInformation *ptr = gf_isom_linf_new_entry();\n\t\tGF_BitStream *bs=gf_bs_new(data, data_size, GF_BITSTREAM_READ);\n\t\te = gf_isom_linf_read_entry(ptr, bs);\n\t\tgf_bs_del(bs);\n\t\tif (e) {\n\t\t\tgf_isom_linf_del_entry(ptr);\n\t\t\treturn e;\n\t\t}\n\n\t\tif (traf && ! *is_traf_sgpd) {\n\t\t\tsgdesc = get_sgdp(NULL, traf, grouping_type, is_traf_sgpd);\n\t\t\tif (!sgdesc) return GF_OUT_OF_MEM;\n\t\t}\n\n\t\te = gf_list_add(sgdesc->group_descriptions, ptr);\n\t\tif (e) return e;\n\t\tentry = (GF_DefaultSampleGroupDescriptionEntry *) ptr;\n\t} else {\n\t\tu32 i, count=gf_list_count(sgdesc->group_descriptions);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_DefaultSampleGroupDescriptionEntry *ent = gf_list_get(sgdesc->group_descriptions, i);\n\t\t\tif ((ent->length == data_size) && !memcmp(ent->data, data, data_size)) {\n\t\t\t\tentry = ent;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tentry=NULL;\n\t\t}\n\t\tif (!entry) {\n\t\t\tGF_SAFEALLOC(entry, GF_DefaultSampleGroupDescriptionEntry);\n\t\t\tif (!entry) return GF_OUT_OF_MEM;\n\t\t\tentry->data = (u8*)gf_malloc(sizeof(char) * data_size);\n\t\t\tif (!entry->data) {\n\t\t\t\tgf_free(entry);\n\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t}\n\t\t\tentry->length = data_size;\n\t\t\tmemcpy(entry->data, data, sizeof(char) * data_size);\n\n\t\t\tif (traf && ! *is_traf_sgpd) {\n\t\t\t\tsgdesc = get_sgdp(NULL, traf, grouping_type, is_traf_sgpd);\n\t\t\t\tif (!sgdesc) return GF_OUT_OF_MEM;\n\t\t\t}\n\n\t\t\te = gf_list_add(sgdesc->group_descriptions, entry);\n\t\t\tif (e) {\n\t\t\t\tgf_free(entry->data);\n\t\t\t\tgf_free(entry);\n\t\t\t\treturn e;\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\n\tif (is_default && !sgdesc->default_description_index) {\n\t\tsgdesc->default_description_index = 1 + gf_list_find(sgdesc->group_descriptions, entry);\n\t\tif (sgdesc->version < 2) sgdesc->version = 2;\n\t\tif (is_traf_sgpd && *is_traf_sgpd) {\n\t\t\tsgdesc->default_description_index |= 0x10000;\n\t\t}\n\t}\n\tu32 grp_idx =  1 + gf_list_find(sgdesc->group_descriptions, entry);\n\tif (sampleGroupDescriptionIndex) *sampleGroupDescriptionIndex = grp_idx;\n\tif (use_default) {\n\t\tif (*is_traf_sgpd)\n\t\t\tgrp_idx |= 0x10000;\n\t\t*use_default = (sgdesc->default_description_index==grp_idx) ? GF_TRUE : GF_FALSE;\n\t}\n\treturn GF_OK;\n}\nGF_EXPORT\nGF_Err gf_isom_add_sample_group_info(GF_ISOFile *movie, u32 track, u32 grouping_type, void *data, u32 data_size, Bool is_default, u32 *sampleGroupDescriptionIndex)\n{\n\treturn gf_isom_add_sample_group_info_internal(movie, track, grouping_type, data, data_size, is_default ? 0x80000000 : 0, sampleGroupDescriptionIndex, NULL, GF_TRUE, NULL, NULL);\n}\n\nGF_Err gf_isom_set_sample_group_description_internal(GF_ISOFile *movie, u32 track, u32 sample_number, u32 grouping_type, u32 grouping_type_parameter, void *data, u32 data_size, Bool check_access, u32 sgpd_flags)\n{\n\tu32 sampleGroupDescriptionIndex, trafID=0;\n\tGF_Err e;\n\tGF_SampleGroupDescriptionBox *sgdesc=NULL;\n\tBool is_traf_sgpd, use_default=GF_FALSE;\n\tGF_List *groupList=NULL, *parent=NULL;\n\n\te = gf_isom_add_sample_group_info_internal(movie, track, grouping_type, data, data_size, sgpd_flags, &sampleGroupDescriptionIndex, &is_traf_sgpd, check_access, &use_default, &sgdesc);\n\tif (e) return e;\n\tif (use_default) return GF_OK;\n\n\tGF_SampleTableBox *stbl=NULL;\n\tGF_TrackBox *trak=NULL;\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tGF_TrackFragmentBox *traf=NULL;\n#endif\n\tif (movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY) {\n\t\ttrak = gf_isom_get_track_from_file(movie, track);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\ttrafID = trak->Header->trackID;\n\t}\n\n\tif (trafID) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\tif (!movie->moof || !(movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY) )\n\t\t\treturn GF_BAD_PARAM;\n\n\t\ttraf = gf_isom_get_traf(movie, trafID);\n#else\n\t\treturn GF_NOT_SUPPORTED;\n#endif\n\n\t} else if (track) {\n\t\tif (check_access) {\n\t\t\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\t\t\tif (e) return e;\n\t\t}\n\n\t\ttrak = gf_isom_get_track_from_file(movie, track);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t}\n\n\t/*look in stbl or traf for sample sampleGroups*/\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (traf) {\n\t\tif (!traf->sampleGroups)\n\t\t\ttraf->sampleGroups = gf_list_new();\n\t\tgroupList = traf->sampleGroups;\n\t\tparent = traf->child_boxes;\n\t\tif (sampleGroupDescriptionIndex && is_traf_sgpd)\n\t\t\tsampleGroupDescriptionIndex |= 0x10000;\n\t} else\n#endif\n\t{\n\t\tstbl = trak->Media->information->sampleTable;\n\t\tif (!stbl->sampleGroups)\n\t\t\tstbl->sampleGroups = gf_list_new();\n\t\tgroupList = stbl->sampleGroups;\n\t\tparent = stbl->child_boxes;\n\t}\n\n\treturn gf_isom_add_sample_group_entry(groupList, sample_number, sgdesc, grouping_type_parameter, sampleGroupDescriptionIndex, parent, stbl);\n\n}\n\nGF_Err gf_isom_set_sample_group_description(GF_ISOFile *movie, u32 track, u32 sample_number, u32 grouping_type, u32 grouping_type_parameter, void *data, u32 data_size, u32 sgpd_flags)\n{\n\treturn gf_isom_set_sample_group_description_internal(movie, track, sample_number, grouping_type, grouping_type_parameter, data, data_size, GF_TRUE, sgpd_flags);\n}\n\nGF_EXPORT\nGF_Err gf_isom_remove_sample_group(GF_ISOFile *movie, u32 track, u32 grouping_type)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tu32 count, i;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, track);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tif (trak->Media->information->sampleTable->sampleGroupsDescription) {\n\t\tcount = gf_list_count(trak->Media->information->sampleTable->sampleGroupsDescription);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_SampleGroupDescriptionBox *sgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(trak->Media->information->sampleTable->sampleGroupsDescription, i);\n\t\t\tif (sgdesc->grouping_type==grouping_type) {\n\t\t\t\tgf_isom_box_del_parent(&trak->Media->information->sampleTable->child_boxes, (GF_Box*)sgdesc);\n\t\t\t\tgf_list_rem(trak->Media->information->sampleTable->sampleGroupsDescription, i);\n\t\t\t\ti--;\n\t\t\t\tcount--;\n\t\t\t}\n\t\t}\n\t}\n\tif (trak->Media->information->sampleTable->sampleGroups) {\n\t\tcount = gf_list_count(trak->Media->information->sampleTable->sampleGroups);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_SampleGroupBox *sgroup = gf_list_get(trak->Media->information->sampleTable->sampleGroups, i);\n\t\t\tif (sgroup->grouping_type==grouping_type) {\n\t\t\t\tgf_isom_box_del_parent(&trak->Media->information->sampleTable->child_boxes, (GF_Box*)sgroup);\n\t\t\t\tgf_list_rem(trak->Media->information->sampleTable->sampleGroups, i);\n\t\t\t\ti--;\n\t\t\t\tcount--;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_add_sample_info(GF_ISOFile *movie, u32 track, u32 sample_number, u32 grouping_type, u32 sampleGroupDescriptionIndex, u32 grouping_type_parameter)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_List *groupList;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, track);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tif (!trak->Media->information->sampleTable->sampleGroups)\n\t\ttrak->Media->information->sampleTable->sampleGroups = gf_list_new();\n\n\n\tGF_SampleGroupDescriptionBox *sgdesc = get_sgdp(trak->Media->information->sampleTable, NULL, grouping_type, NULL);\n\tif (!sgdesc) return GF_BAD_PARAM;\n\n\tgroupList = trak->Media->information->sampleTable->sampleGroups;\n\treturn gf_isom_add_sample_group_entry(groupList, sample_number, sgdesc, grouping_type_parameter, sampleGroupDescriptionIndex, trak->Media->information->sampleTable->child_boxes, trak->Media->information->sampleTable);\n}\n\nvoid *sg_rap_create_entry(void *udta)\n{\n\tGF_VisualRandomAccessEntry *entry;\n\tu32 *num_leading_samples = (u32 *) udta;\n\tassert(udta);\n\tGF_SAFEALLOC(entry, GF_VisualRandomAccessEntry);\n\tif (!entry) return NULL;\n\tentry->num_leading_samples = *num_leading_samples;\n\tentry->num_leading_samples_known = entry->num_leading_samples ? 1 : 0;\n\treturn entry;\n}\n\nBool sg_rap_compare_entry(void *udta, void *entry)\n{\n\tu32 *num_leading_samples = (u32 *) udta;\n\tif (*num_leading_samples == ((GF_VisualRandomAccessEntry *)entry)->num_leading_samples) return GF_TRUE;\n\treturn GF_FALSE;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_sample_rap_group(GF_ISOFile *movie, u32 track, u32 sample_number, Bool is_rap, u32 num_leading_samples)\n{\n\treturn gf_isom_set_sample_group_info_internal(movie, track, 0, sample_number, GF_ISOM_SAMPLE_GROUP_RAP, 0, &num_leading_samples, is_rap ? sg_rap_create_entry : NULL, is_rap ? sg_rap_compare_entry : NULL);\n}\n\nGF_Err gf_isom_fragment_set_sample_rap_group(GF_ISOFile *movie, GF_ISOTrackID trackID, u32 sample_number_in_frag, Bool is_rap, u32 num_leading_samples)\n{\n\treturn gf_isom_set_sample_group_info_internal(movie, 0, trackID, sample_number_in_frag, GF_ISOM_SAMPLE_GROUP_RAP, 0, &num_leading_samples, is_rap ? sg_rap_create_entry : NULL, is_rap ? sg_rap_compare_entry : NULL);\n}\n\n\n\nvoid *sg_roll_create_entry(void *udta)\n{\n\tGF_RollRecoveryEntry *entry;\n\ts16 *roll_distance = (s16 *) udta;\n\tGF_SAFEALLOC(entry, GF_RollRecoveryEntry);\n\tif (!entry) return NULL;\n\tentry->roll_distance = *roll_distance;\n\treturn entry;\n}\n\nBool sg_roll_compare_entry(void *udta, void *entry)\n{\n\ts16 *roll_distance = (s16 *) udta;\n\tif (*roll_distance == ((GF_RollRecoveryEntry *)entry)->roll_distance) return GF_TRUE;\n\treturn GF_FALSE;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_sample_roll_group(GF_ISOFile *movie, u32 track, u32 sample_number, GF_ISOSampleRollType roll_type, s16 roll_distance)\n{\n\tu32 grp_type = (roll_type>=GF_ISOM_SAMPLE_PREROLL) ? GF_ISOM_SAMPLE_GROUP_PROL : GF_ISOM_SAMPLE_GROUP_ROLL;\n\tif (roll_type==GF_ISOM_SAMPLE_PREROLL_NONE)\n\t\troll_type = 0;\n\n\treturn gf_isom_set_sample_group_info_internal(movie, track, 0, sample_number, grp_type, 0, &roll_distance, roll_type ? sg_roll_create_entry : NULL, roll_type ? sg_roll_compare_entry : NULL);\n}\n\nGF_EXPORT\nGF_Err gf_isom_fragment_set_sample_roll_group(GF_ISOFile *movie, GF_ISOTrackID trackID, u32 sample_number_in_frag, GF_ISOSampleRollType roll_type, s16 roll_distance)\n{\n\tu32 grp_type = (roll_type>=GF_ISOM_SAMPLE_PREROLL) ? GF_ISOM_SAMPLE_GROUP_PROL : GF_ISOM_SAMPLE_GROUP_ROLL;\n\tif (roll_type==GF_ISOM_SAMPLE_PREROLL_NONE)\n\t\troll_type = 0;\n\n\treturn gf_isom_set_sample_group_info_internal(movie, 0, trackID, sample_number_in_frag, grp_type, 0, &roll_distance, roll_type ? sg_roll_create_entry : NULL, roll_type ? sg_roll_compare_entry : NULL);\n}\n\n\nvoid *sg_encryption_create_entry(void *udta)\n{\n\tGF_CENCSampleEncryptionGroupEntry *entry, *from_entry;\n\tGF_SAFEALLOC(entry, GF_CENCSampleEncryptionGroupEntry);\n\tif (!entry) return NULL;\n\tfrom_entry = (GF_CENCSampleEncryptionGroupEntry *)udta;\n\tmemcpy(entry, from_entry, sizeof(GF_CENCSampleEncryptionGroupEntry) );\n\tentry->key_info = gf_malloc(sizeof(u8) * entry->key_info_size);\n\tif (!entry->key_info) {\n\t\tgf_free(entry);\n\t\treturn NULL;\n\t}\n\tmemcpy(entry->key_info, from_entry->key_info, entry->key_info_size);\n\treturn entry;\n}\n\nBool sg_encryption_compare_entry(void *udta, void *_entry)\n{\n\tGF_CENCSampleEncryptionGroupEntry *entry = (GF_CENCSampleEncryptionGroupEntry *)_entry;\n\tGF_CENCSampleEncryptionGroupEntry *with_entry = (GF_CENCSampleEncryptionGroupEntry *)udta;\n\n\tif (entry->IsProtected != with_entry->IsProtected) return GF_FALSE;\n\tif (entry->skip_byte_block != with_entry->skip_byte_block) return GF_FALSE;\n\tif (entry->crypt_byte_block != with_entry->crypt_byte_block) return GF_FALSE;\n\tif (entry->key_info_size != with_entry->key_info_size) return GF_FALSE;\n\n\tif (!memcmp(entry->key_info, with_entry->key_info, with_entry->key_info_size))\n\t\treturn GF_TRUE;\n\treturn GF_FALSE;\n}\n\n\n/*sample encryption information group can be in stbl or traf*/\nGF_EXPORT\nGF_Err gf_isom_set_sample_cenc_group(GF_ISOFile *movie, u32 track, u32 sample_number, u8 isEncrypted, u8 crypt_byte_block, u8 skip_byte_block, u8 *key_info, u32 key_info_size)\n{\n\tGF_CENCSampleEncryptionGroupEntry entry;\n\tif (!key_info || (key_info_size<19))\n\t\treturn GF_BAD_PARAM;\n\n\tmemset(&entry, 0, sizeof(GF_CENCSampleEncryptionGroupEntry));\n\tentry.crypt_byte_block = crypt_byte_block;\n\tentry.skip_byte_block = skip_byte_block;\n\tentry.IsProtected = isEncrypted;\n\tentry.key_info = key_info;\n\tentry.key_info_size = key_info_size;\n\n\treturn gf_isom_set_sample_group_info_internal(movie, track, 0, sample_number, GF_ISOM_SAMPLE_GROUP_SEIG, 0, &entry, sg_encryption_create_entry, sg_encryption_compare_entry);\n}\n\n\n\nGF_EXPORT\nGF_Err gf_isom_set_sample_cenc_default_group(GF_ISOFile *movie, u32 track, u32 sample_number)\n{\n\treturn gf_isom_set_sample_group_info_internal(movie, track, 0, sample_number, GF_ISOM_SAMPLE_GROUP_SEIG, 0, NULL, NULL, NULL);\n}\n\nGF_Err gf_isom_force_ctts(GF_ISOFile *file, u32 track)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e = CanAccessMovie(file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n \ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) return GF_BAD_PARAM;\n\tif (trak->Media->information->sampleTable->CompositionOffset) return GF_OK;\n\n\ttrak->Media->information->sampleTable->CompositionOffset = (GF_CompositionOffsetBox *) gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_CTTS);\n\tif (!trak->Media->information->sampleTable->CompositionOffset) return GF_OUT_OF_MEM;\n\ttrak->Media->information->sampleTable->CompositionOffset->nb_entries = 1;\n\ttrak->Media->information->sampleTable->CompositionOffset->entries = gf_malloc(sizeof(GF_DttsEntry));\n\ttrak->Media->information->sampleTable->CompositionOffset->entries[0].decodingOffset = 0;\n\ttrak->Media->information->sampleTable->CompositionOffset->entries[0].sampleCount = \ttrak->Media->information->sampleTable->SampleSize->sampleCount;\n\treturn GF_OK;\n}\n\nGF_Err gf_isom_set_ctts_v1(GF_ISOFile *file, u32 track, u32 ctts_shift)\n{\n\tu32 i, shift;\n\tu64 duration;\n\tGF_CompositionOffsetBox *ctts;\n\tGF_CompositionToDecodeBox *cslg;\n\ts32 leastCTTS, greatestCTTS;\n\tGF_TrackBox *trak;\n\tGF_Err e = CanAccessMovie(file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n \ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tctts = trak->Media->information->sampleTable->CompositionOffset;\n\tif (ctts->version) {\n\t\tshift = ctts_shift;\n\t} else {\n\t\tshift = ctts->nb_entries ? ctts->entries[0].decodingOffset : 0;\n\t}\n\tleastCTTS = GF_INT_MAX;\n\tgreatestCTTS = 0;\n\tfor (i=0; i<ctts->nb_entries; i++) {\n\t\tif (!ctts->version)\n\t\t\tctts->entries[i].decodingOffset -= shift;\n\n\t\tif ((s32)ctts->entries[i].decodingOffset < leastCTTS)\n\t\t\tleastCTTS = ctts->entries[i].decodingOffset;\n\t\tif ((s32)ctts->entries[i].decodingOffset > greatestCTTS)\n\t\t\tgreatestCTTS = ctts->entries[i].decodingOffset;\n\t}\n\tif (!ctts->version) {\n\t\tctts->version = 1;\n\t\t//if we had edit lists, shift all media times by the given amount\n\t\tif (trak->editBox && trak->editBox->editList) {\n\t\t\tfor (i=0; i<gf_list_count(trak->editBox->editList->entryList); i++) {\n\t\t\t\tGF_EdtsEntry *ent = (GF_EdtsEntry*)gf_list_get(trak->editBox->editList->entryList, i);\n\t\t\t\t//empty edit\n\t\t\t\tif (ent->mediaTime<0) continue;\n\t\t\t\tif (ent->mediaTime>=shift) ent->mediaTime -= shift;\n\t\t\t\telse ent->mediaTime = 0;\n\t\t\t\t//no offset and last entry, trash edit\n\t\t\t\tif (!ent->mediaTime && (gf_list_count(trak->editBox->editList->entryList)==1)) {\n\t\t\t\t\tgf_isom_box_del_parent(&trak->child_boxes, (GF_Box *)trak->editBox);\n\t\t\t\t\ttrak->editBox = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSetTrackDuration(trak);\n\t\t}\n\t}\n\n\tif (!trak->Media->information->sampleTable->CompositionToDecode) {\n\t\ttrak->Media->information->sampleTable->CompositionToDecode = (GF_CompositionToDecodeBox *) gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_CSLG);\n\t\tif (!trak->Media->information->sampleTable->CompositionToDecode)\n\t\t\treturn GF_OUT_OF_MEM;\n\t}\n\n\tcslg = trak->Media->information->sampleTable->CompositionToDecode;\n\tif (cslg) {\n\t\tcslg->compositionToDTSShift = shift;\n\t\tcslg->leastDecodeToDisplayDelta = leastCTTS;\n\t\tcslg->greatestDecodeToDisplayDelta = greatestCTTS;\n\t\tcslg->compositionStartTime = 0;\n\t\t/*for our use case (first CTS set to 0), the composition end time is the media duration if it fits on 32 bits*/\n\t\tduration = gf_isom_get_media_duration(file, track);\n\t\tcslg->compositionEndTime = (duration<0x7FFFFFFF) ? (s32) duration : 0;\n\t}\n\n\tgf_isom_modify_alternate_brand(file, GF_ISOM_BRAND_ISO4, GF_TRUE);\n\treturn GF_OK;\n}\n\nstatic GF_Err gf_isom_set_ctts_v0(GF_ISOFile *file, GF_TrackBox *trak)\n{\n\tu32 i;\n\ts32 shift;\n\tGF_CompositionOffsetBox *ctts;\n\tGF_CompositionToDecodeBox *cslg;\n\n\tctts = trak->Media->information->sampleTable->CompositionOffset;\n\n\tif (!trak->Media->information->sampleTable->CompositionToDecode)\n\t{\n\t\tshift = 0;\n\t\tfor (i=0; i<ctts->nb_entries; i++) {\n\t\t\tif (-ctts->entries[i].decodingOffset > shift)\n\t\t\t\tshift = -ctts->entries[i].decodingOffset;\n\t\t}\n\t\tif (shift > 0)\n\t\t{\n\t\t\tfor (i=0; i<ctts->nb_entries; i++) {\n\t\t\t\ts64 new_ts = ctts->entries[i].decodingOffset;\n\t\t\t\tnew_ts += shift;\n\t\t\t\tctts->entries[i].decodingOffset = (s32) new_ts;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tcslg = trak->Media->information->sampleTable->CompositionToDecode;\n\t\tshift = cslg->compositionToDTSShift;\n\t\tfor (i=0; i<ctts->nb_entries; i++) {\n\t\t\ts64 new_ts = ctts->entries[i].decodingOffset;\n\t\t\tnew_ts += shift;\n\t\t\tctts->entries[i].decodingOffset = (s32) new_ts;\n\t\t}\n\t\tgf_isom_box_del_parent(&trak->Media->information->sampleTable->child_boxes, (GF_Box *)cslg);\n\t\ttrak->Media->information->sampleTable->CompositionToDecode = NULL;\n\t}\n\tif (shift>0) {\n\t\t//no edits, insert one\n\t\tif (! trak->editBox) {\n\t\t\tu64 dur = trak->Media->mediaHeader->duration;\n\t\t\tdur *= file->moov->mvhd->timeScale;\n\t\t\tdur /= trak->Media->mediaHeader->timeScale;\n\t\t\tgf_isom_set_edit(file, gf_list_find(file->moov->trackList, trak)+1, 0, dur, shift, GF_ISOM_EDIT_NORMAL);\n\t\t} else {\n\t\t\t//otherwise shift media times in all entries\n\t\t\tfor (i=0; i<gf_list_count(trak->editBox->editList->entryList); i++) {\n\t\t\t\tGF_EdtsEntry *ent = (GF_EdtsEntry*)gf_list_get(trak->editBox->editList->entryList, i);\n\t\t\t\t//empty edit\n\t\t\t\tif (ent->mediaTime<0) continue;\n\t\t\t\tent->mediaTime += shift;\n\t\t\t}\n\t\t\tSetTrackDuration(trak);\n\t\t}\n\t}\n\tctts->version = 0;\n\tgf_isom_modify_alternate_brand(file, GF_ISOM_BRAND_ISO4, GF_FALSE);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_composition_offset_mode(GF_ISOFile *file, u32 track, Bool use_negative_offsets)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_CompositionOffsetBox *ctts;\n\n\te = CanAccessMovie(file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tctts = trak->Media->information->sampleTable->CompositionOffset;\n\tif (!ctts) {\n\t\tif (!use_negative_offsets && trak->Media->information->sampleTable->CompositionToDecode) {\n\t\t\tgf_isom_box_del_parent(&trak->Media->information->sampleTable->child_boxes, (GF_Box *)trak->Media->information->sampleTable->CompositionToDecode);\n\t\t\ttrak->Media->information->sampleTable->CompositionToDecode = NULL;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\n\tif (use_negative_offsets) {\n\t\treturn gf_isom_set_ctts_v1(file, track, 0);\n\t} else {\n\t\tif (ctts->version==0) return GF_OK;\n\t\treturn gf_isom_set_ctts_v0(file, trak);\n\t}\n}\n\n#if 0 //unused\nGF_Err gf_isom_set_sync_table(GF_ISOFile *file, u32 track)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\n\te = CanAccessMovie(file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tif (!trak->Media->information->sampleTable->SyncSample) {\n\t\ttrak->Media->information->sampleTable->SyncSample = (GF_SyncSampleBox *) gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_STSS);\n\n\t\tif (!trak->Media->information->sampleTable->SyncSample)\n\t\t\treturn GF_OUT_OF_MEM;\n\t}\n\treturn GF_OK;\n}\n#endif\n\nGF_Err gf_isom_set_sample_flags(GF_ISOFile *file, u32 track, u32 sampleNumber, u32 isLeading, u32 dependsOn, u32 dependedOn, u32 redundant)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\n\te = CanAccessMovie(file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) return GF_BAD_PARAM;\n\treturn stbl_SetDependencyType(trak->Media->information->sampleTable, sampleNumber, isLeading, dependsOn, dependedOn, redundant);\n}\n\n#if 0 //unused\nGF_Err gf_isom_sample_set_dep_info(GF_ISOFile *file, u32 track, u32 sampleNumber, u32 isLeading, u32 dependsOn, u32 dependedOn, u32 redundant)\n{\n\tGF_TrackBox *trak;\n\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) return GF_BAD_PARAM;\n\n\treturn stbl_AddDependencyType(trak->Media->information->sampleTable, sampleNumber, isLeading, dependsOn, dependedOn, redundant);\n}\n#endif\n\nGF_EXPORT\nGF_Err gf_isom_copy_sample_info(GF_ISOFile *dst, u32 dst_track, GF_ISOFile *src, u32 src_track, u32 sampleNumber)\n{\n\tu32 i, count, idx, dst_sample_num, subs_flags;\n\tGF_SubSampleInfoEntry *sub_sample;\n\tGF_Err e;\n\tGF_TrackBox *src_trak, *dst_trak;\n\n\tsrc_trak = gf_isom_get_track_from_file(src, src_track);\n\tif (!src_trak) return GF_BAD_PARAM;\n\n\tdst_trak = gf_isom_get_track_from_file(dst, dst_track);\n\tif (!dst_trak) return GF_BAD_PARAM;\n\n\tdst_sample_num = dst_trak->Media->information->sampleTable->SampleSize->sampleCount;\n\n\t/*modify depends flags*/\n\tif (src_trak->Media->information->sampleTable->SampleDep) {\n\t\tu32 isLeading, dependsOn, dependedOn, redundant;\n\n\t\tisLeading = dependsOn = dependedOn = redundant = 0;\n\n\t\te = stbl_GetSampleDepType(src_trak->Media->information->sampleTable->SampleDep, sampleNumber, &isLeading, &dependsOn, &dependedOn, &redundant);\n\t\tif (e) return e;\n\n\t\te = stbl_AppendDependencyType(dst_trak->Media->information->sampleTable, isLeading, dependsOn, dependedOn, redundant);\n\t\tif (e) return e;\n\t}\n\n\t/*copy subsample info if any*/\n\tidx=1;\n\twhile (gf_isom_get_subsample_types(src, src_track, idx, &subs_flags)) {\n\t\tGF_SubSampleInformationBox *dst_subs=NULL;\n\t\tidx++;\n\n\t\tif ( ! gf_isom_sample_get_subsample_entry(src, src_track, sampleNumber, subs_flags, &sub_sample))\n\t\t\tcontinue;\n\n\t\t/*create subsample if needed*/\n\t\tif (!dst_trak->Media->information->sampleTable->sub_samples) {\n\t\t\tdst_trak->Media->information->sampleTable->sub_samples = gf_list_new();\n\t\t}\n\t\tcount = gf_list_count(dst_trak->Media->information->sampleTable->sub_samples);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tdst_subs = gf_list_get(dst_trak->Media->information->sampleTable->sub_samples, i);\n\t\t\tif (dst_subs->flags==subs_flags) break;\n\t\t\tdst_subs=NULL;\n\t\t}\n\t\tif (!dst_subs) {\n\t\t\tdst_subs = (GF_SubSampleInformationBox *) gf_isom_box_new_parent(&dst_trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_SUBS);\n\t\t\tif (!dst_subs) return GF_OUT_OF_MEM;\n\t\t\tdst_subs->version=0;\n\t\t\tdst_subs->flags = subs_flags;\n\t\t\tgf_list_add(dst_trak->Media->information->sampleTable->sub_samples, dst_subs);\n\t\t}\n\n\t\tcount = gf_list_count(sub_sample->SubSamples);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_SubSampleEntry *entry = (GF_SubSampleEntry*)gf_list_get(sub_sample->SubSamples, i);\n\t\t\te = gf_isom_add_subsample_info(dst_subs, dst_sample_num, entry->subsample_size, entry->subsample_priority, entry->reserved, entry->discardable);\n\t\t\tif (e) return e;\n\t\t}\n\t}\n\n\t/*copy sampleToGroup info if any*/\n\tcount = 0;\n\tif (src_trak->Media->information->sampleTable->sampleGroups)\n\t\tcount = gf_list_count(src_trak->Media->information->sampleTable->sampleGroups);\n\n\tfor (i=0; i<count; i++) {\n\t\tGF_SampleGroupBox *sg;\n\t\tu32 j, k, default_index;\n\t\tu32 first_sample_in_entry, last_sample_in_entry, group_desc_index_src, group_desc_index_dst;\n\t\tfirst_sample_in_entry = 1;\n\n\t\tsg = (GF_SampleGroupBox*)gf_list_get(src_trak->Media->information->sampleTable->sampleGroups, i);\n\t\tfor (j=0; j<sg->entry_count; j++) {\n\t\t\tGF_SampleGroupDescriptionBox *sgd_dst = NULL;\n\t\t\tlast_sample_in_entry = first_sample_in_entry + sg->sample_entries[j].sample_count - 1;\n\t\t\tif ((sampleNumber<first_sample_in_entry) || (sampleNumber>last_sample_in_entry)) {\n\t\t\t\tfirst_sample_in_entry = last_sample_in_entry+1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!dst_trak->Media->information->sampleTable->sampleGroups)\n\t\t\t\tdst_trak->Media->information->sampleTable->sampleGroups = gf_list_new();\n\n\t\t\tgroup_desc_index_src = group_desc_index_dst = sg->sample_entries[j].group_description_index;\n\n\t\t\tif (group_desc_index_src) {\n\t\t\t\tGF_SampleGroupDescriptionBox *sgd_src;\n\t\t\t\tvoid *sgde_src, *sgde_dst;\n\n\t\t\t\tgroup_desc_index_dst = 0;\n\t\t\t\t//check that the sample group description exists !!\n\t\t\t\tsgde_src = gf_isom_get_sample_group_info_entry(src, src_trak, sg->grouping_type, sg->sample_entries[j].group_description_index, &default_index, &sgd_src);\n\n\t\t\t\tif (!sgde_src) break;\n\n\t\t\t\tif (!dst_trak->Media->information->sampleTable->sampleGroupsDescription)\n\t\t\t\t\tdst_trak->Media->information->sampleTable->sampleGroupsDescription = gf_list_new();\n\n\t\t\t\tsgd_dst = NULL;\n\t\t\t\tfor (k=0; k< gf_list_count(dst_trak->Media->information->sampleTable->sampleGroupsDescription); k++) {\n\t\t\t\t\tsgd_dst = gf_list_get(dst_trak->Media->information->sampleTable->sampleGroupsDescription, k);\n\t\t\t\t\tif (sgd_dst->grouping_type==sgd_src->grouping_type) break;\n\t\t\t\t\tsgd_dst = NULL;\n\t\t\t\t}\n\t\t\t\tif (!sgd_dst) {\n\t\t\t\t\tgf_isom_clone_box( (GF_Box *) sgd_src, (GF_Box **) &sgd_dst);\n\t\t\t\t\tif (!sgd_dst) return GF_OUT_OF_MEM;\n\t\t\t\t\tgf_list_add(dst_trak->Media->information->sampleTable->sampleGroupsDescription, sgd_dst);\n\t\t\t\t\tgf_list_add(dst_trak->Media->information->sampleTable->child_boxes, sgd_dst);\n\t\t\t\t}\n\n\t\t\t\t//find the same entry\n\t\t\t\tfor (k=0; k<gf_list_count(sgd_dst->group_descriptions); k++) {\n\t\t\t\t\tsgde_dst = gf_list_get(sgd_dst->group_descriptions, k);\n\t\t\t\t\tif (gf_isom_is_identical_sgpd(sgde_src, sgde_dst, sgd_src->grouping_type)) {\n\t\t\t\t\t\tgroup_desc_index_dst = k+1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!group_desc_index_dst) {\n\t\t\t\t\tGF_SampleGroupDescriptionBox *cloned=NULL;\n\t\t\t\t\tgf_isom_clone_box( (GF_Box *) sgd_src, (GF_Box **)  &cloned);\n\t\t\t\t\tif (!cloned) return GF_OUT_OF_MEM;\n\t\t\t\t\tsgde_dst = gf_list_get(cloned->group_descriptions, group_desc_index_dst);\n\t\t\t\t\tgf_list_rem(cloned->group_descriptions, group_desc_index_dst);\n\t\t\t\t\tgf_isom_box_del( (GF_Box *) cloned);\n\t\t\t\t\tgf_list_add(sgd_dst->group_descriptions, sgde_dst);\n\t\t\t\t\tgroup_desc_index_dst = gf_list_count(sgd_dst->group_descriptions);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tgf_isom_get_sample_group_info_entry(dst, dst_trak, sg->grouping_type, 1, NULL, &sgd_dst);\n\t\t\t\tif (!sgd_dst) continue;\n\t\t\t}\n\n\t\t\t/*found our sample, add it to trak->sampleGroups*/\n\t\t\te = gf_isom_add_sample_group_entry(dst_trak->Media->information->sampleTable->sampleGroups, dst_sample_num, sgd_dst, sg->grouping_type_parameter, group_desc_index_dst, dst_trak->Media->information->sampleTable->child_boxes, NULL);\n\t\t\tif (e) return e;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t//copy auxiliary info\n\tcount = gf_list_count(src_trak->Media->information->sampleTable->sai_sizes);\n\tfor (i=0; i<count; i++) {\n\t\tu32 j;\n\t\tGF_SampleAuxiliaryInfoOffsetBox *saio = NULL;\n\t\tGF_SampleAuxiliaryInfoSizeBox *saiz = gf_list_get(src_trak->Media->information->sampleTable->sai_sizes, i);\n\n\t\tswitch (saiz->aux_info_type) {\n\t\tcase GF_ISOM_CENC_SCHEME:\n\t\tcase GF_ISOM_CBC_SCHEME:\n\t\tcase GF_ISOM_CENS_SCHEME:\n\t\tcase GF_ISOM_CBCS_SCHEME:\n\t\tcase GF_ISOM_PIFF_SCHEME:\n\t\tcase 0:\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\t//no aux sample associated\n\t\tif (saiz->sample_count<sampleNumber) continue;\n\t\t//no size associated\n\t\tif (!saiz->default_sample_info_size && !saiz->sample_info_size[sampleNumber-1]) continue;\n\n\t\tfor (j=0; j<gf_list_count(src_trak->Media->information->sampleTable->sai_offsets); j++) {\n\t\t\tsaio = gf_list_get(src_trak->Media->information->sampleTable->sai_offsets, j);\n\t\t\tif ((saio->aux_info_type==saiz->aux_info_type) && (saio->aux_info_type_parameter==saiz->aux_info_type_parameter)) break;\n\t\t\tsaio=NULL;\n\t\t}\n\t\tif (!saio) continue;\n\t\tif (!saio->offsets && !saio->sai_data) continue;\n\n\t\tu64 offset = saio->offsets ? saio->offsets[0] : 0;\n\t\tu32 nb_saio = saio->entry_count;\n\t\tif ((nb_saio>1) && (saio->entry_count != saiz->sample_count)) continue;\n\n\t\tu32 size;\n\n\t\tif (nb_saio == 1) {\n\t\t\tfor (j=0; j < sampleNumber-1; j++) {\n\t\t\t\tsize = saiz->default_sample_info_size ? saiz->default_sample_info_size : saiz->sample_info_size[j];\n\t\t\t\toffset += size;\n\t\t\t}\n\t\t} else {\n\t\t\toffset = saio->offsets[sampleNumber-1];\n\t\t}\n\n\t\tsize = saiz->default_sample_info_size ? saiz->default_sample_info_size : saiz->sample_info_size[j];\n\n\t\tif (saio->sai_data) {\n\t\t\te = gf_isom_add_sample_aux_info_internal(dst_trak, NULL, j+1, saiz->aux_info_type, saiz->aux_info_type_parameter, saio->sai_data->data + offset, size);\n\t\t} else {\n\t\t\tu8 *sai = gf_malloc(size);\n\t\t\tif (!sai) return GF_OUT_OF_MEM;\n\n\t\t\tu64 cur_position = gf_bs_get_position(src_trak->moov->mov->movieFileMap->bs);\n\t\t\tgf_bs_seek(src_trak->moov->mov->movieFileMap->bs, offset);\n\n\t\t\tgf_bs_read_data(src_trak->moov->mov->movieFileMap->bs, sai, size);\n\t\t\tgf_bs_seek(src_trak->moov->mov->movieFileMap->bs, cur_position);\n\t\t\te = gf_isom_add_sample_aux_info_internal(dst_trak, NULL, j+1, saiz->aux_info_type, saiz->aux_info_type_parameter, sai, size);\n\t\t\tgf_free(sai);\n\t\t}\n\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[isobmf] Failed to clone sai data: %s\\n\", gf_error_to_string(e) ));\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_text_set_display_flags(GF_ISOFile *file, u32 track, u32 desc_index, u32 flags, GF_TextFlagsMode op_type)\n{\n\tu32 i;\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\n\te = CanAccessMovie(file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tfor (i=0; i < gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes); i++) {\n\t\tGF_Tx3gSampleEntryBox *txt;\n\t\tif (desc_index && (i+1 != desc_index)) continue;\n\n\t\ttxt = (GF_Tx3gSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, i);\n\t\tif (txt->type != GF_ISOM_BOX_TYPE_TX3G) continue;\n\n\t\tswitch (op_type) {\n\t\tcase GF_ISOM_TEXT_FLAGS_TOGGLE:\n\t\t\ttxt->displayFlags |= flags;\n\t\t\tbreak;\n\t\tcase GF_ISOM_TEXT_FLAGS_UNTOGGLE:\n\t\t\ttxt->displayFlags &= ~flags;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttxt->displayFlags = flags;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn GF_OK;\n\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_update_duration(GF_ISOFile *movie)\n{\n\tu32 i;\n\tu64 maxDur;\n\tGF_TrackBox *trak;\n\n\tif (!movie || !movie->moov) return GF_BAD_PARAM;\n\n\t//if file was open in Write or Edit mode, recompute the duration\n\t//the duration of a movie is the MaxDuration of all the tracks...\n\n\tmaxDur = 0;\n\ti=0;\n\twhile ((trak = (GF_TrackBox *)gf_list_enum(movie->moov->trackList, &i))) {\n\t\tif( (movie->LastError = SetTrackDuration(trak))\t) return movie->LastError;\n\t\tif (trak->Header && (trak->Header->duration > maxDur))\n\t\t\tmaxDur = trak->Header->duration;\n\t}\n\tmovie->moov->mvhd->duration = maxDur;\n\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_update_edit_list_duration(GF_ISOFile *file, u32 track)\n{\n\tu32 i;\n\tu64 trackDuration;\n\tGF_EdtsEntry *ent;\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\n\te = CanAccessMovie(file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) return GF_BAD_PARAM;\n\n\n\t//the total duration is the media duration: adjust it in case...\n\te = Media_SetDuration(trak);\n\tif (e) return e;\n\n\t//assert the timeScales are non-NULL\n\tif (!trak->moov->mvhd->timeScale || !trak->Media->mediaHeader->timeScale) return GF_ISOM_INVALID_FILE;\n\ttrackDuration = (trak->Media->mediaHeader->duration * trak->moov->mvhd->timeScale) / trak->Media->mediaHeader->timeScale;\n\n\t//if we have an edit list, the duration is the sum of all the editList\n\t//entries' duration (always expressed in MovieTimeScale)\n\tif (trak->editBox && trak->editBox->editList) {\n\t\tu64 editListDuration = 0;\n\t\tGF_EditListBox *elst = trak->editBox->editList;\n\t\ti=0;\n\t\twhile ((ent = (GF_EdtsEntry*)gf_list_enum(elst->entryList, &i))) {\n\t\t\tif ((ent->mediaTime>=0) && (ent->mediaRate==0x10000) && (ent->segmentDuration > trackDuration))\n\t\t\t\tent->segmentDuration = trackDuration;\n\n\t\t\tif (!ent->segmentDuration) {\n\t\t\t\tu64 diff;\n\t\t\t\tent->segmentDuration = trackDuration;\n\t\t\t\tif (ent->mediaTime>0) {\n\t\t\t\t\tdiff = ent->mediaTime;\n\t\t\t\t\tdiff *= trak->moov->mvhd->timeScale;\n\t\t\t\t\tdiff /= trak->Media->mediaHeader->timeScale;\n\t\t\t\t\tif (diff < ent->segmentDuration)\n\t\t\t\t\t\tent->segmentDuration -= diff;\n\t\t\t\t\t/*\n\t\t\t\t\telse\n\t\t\t\t\t\tdiff = 0;\n\t\t\t\t\t*/\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((ent->mediaTime>=0) && ((u64) ent->mediaTime>=trak->Media->mediaHeader->duration)) {\n\t\t\t\tent->mediaTime = trak->Media->mediaHeader->duration;\n\t\t\t}\n\t\t\teditListDuration += ent->segmentDuration;\n\t\t}\n\t\ttrackDuration = editListDuration;\n\t}\n\tif (!trackDuration) {\n\t\ttrackDuration = (trak->Media->mediaHeader->duration * trak->moov->mvhd->timeScale) / trak->Media->mediaHeader->timeScale;\n\t}\n\ttrak->Header->duration = trackDuration;\n\n\treturn GF_OK;\n\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_clone_pssh(GF_ISOFile *output, GF_ISOFile *input, Bool in_moof) {\n\tGF_Box *a;\n\tu32 i;\n\ti = 0;\n\n\twhile ((a = (GF_Box *)gf_list_enum(input->moov->child_boxes, &i))) {\n\t\tif (a->type == GF_ISOM_BOX_TYPE_PSSH) {\n\t\t\tGF_List **child_boxes = &output->moov->child_boxes;\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\tif (in_moof)\n\t\t\t\tchild_boxes = &output->moof->child_boxes;\n#endif\n\n\t\t\tGF_ProtectionSystemHeaderBox *pssh = (GF_ProtectionSystemHeaderBox *)gf_isom_box_new_parent(child_boxes, GF_ISOM_BOX_TYPE_PSSH);\n\t\t\tif (!pssh) return GF_OUT_OF_MEM;\n\t\t\tmemmove(pssh->SystemID, ((GF_ProtectionSystemHeaderBox *)a)->SystemID, 16);\n\t\t\tif (((GF_ProtectionSystemHeaderBox *)a)->KIDs && ((GF_ProtectionSystemHeaderBox *)a)->KID_count > 0) {\n\t\t\t\tpssh->KID_count = ((GF_ProtectionSystemHeaderBox *)a)->KID_count;\n\t\t\t\tpssh->KIDs = (bin128 *)gf_malloc(pssh->KID_count*sizeof(bin128));\n\t\t\t\tif (!pssh->KIDs) return GF_OUT_OF_MEM;\n\t\t\t\tmemmove(pssh->KIDs, ((GF_ProtectionSystemHeaderBox *)a)->KIDs, pssh->KID_count*sizeof(bin128));\n\t\t\t}\n\t\t\tpssh->private_data_size = ((GF_ProtectionSystemHeaderBox *)a)->private_data_size;\n\t\t\tpssh->private_data = (u8 *)gf_malloc(pssh->private_data_size*sizeof(char));\n\t\t\tif (!pssh->private_data) return GF_OUT_OF_MEM;\n\t\t\tmemmove(pssh->private_data, ((GF_ProtectionSystemHeaderBox *)a)->private_data, pssh->private_data_size);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_track_group(GF_ISOFile *file, u32 track_number, u32 track_group_id, u32 group_type, Bool do_add)\n{\n\tu32 i, j;\n\tGF_TrackGroupTypeBox *trgt;\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\n\te = CanAccessMovie(file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(file, track_number);\n\tif (!trak) return GF_BAD_PARAM;\n\tif (!trak->groups) trak->groups = (GF_TrackGroupBox*) gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_TRGR);\n\tif (!trak->groups) return GF_OUT_OF_MEM;\n\n\tfor (j=0; j<gf_list_count(file->moov->trackList); j++) {\n\t\tGF_TrackBox *a_trak = gf_list_get(file->moov->trackList, j);\n\t\tif (!a_trak->groups) continue;\n\n\t\tfor (i=0; i<gf_list_count(a_trak->groups->groups); i++) {\n\t\t\ttrgt = gf_list_get(a_trak->groups->groups, i);\n\n\t\t\tif (trgt->track_group_id==track_group_id) {\n\t\t\t\tif (trgt->group_type != group_type) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"A track with same group ID is already defined for different group type %s\\n\", gf_4cc_to_str(trgt->group_type) ));\n\t\t\t\t\treturn GF_BAD_PARAM;\n\t\t\t\t}\n\t\t\t\tif (a_trak==trak) {\n\t\t\t\t\tif (!do_add) {\n\t\t\t\t\t\tgf_list_rem(trak->groups->groups, i);\n\t\t\t\t\t\tgf_isom_box_del_parent(&trak->groups->child_boxes, (GF_Box *)trgt);\n\t\t\t\t\t}\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//not found, add new group\n\ttrgt = (GF_TrackGroupTypeBox*) gf_isom_box_new_parent(&trak->groups->child_boxes, GF_ISOM_BOX_TYPE_TRGT);\n\tif (!trgt) return GF_OUT_OF_MEM;\n\ttrgt->track_group_id = track_group_id;\n\ttrgt->group_type = group_type;\n\treturn gf_list_add(trak->groups->groups, trgt);\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_nalu_length_field(GF_ISOFile *file, u32 track, u32 StreamDescriptionIndex, u32 nalu_size_length)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_MPEGVisualSampleEntryBox *ve;\n\tGF_SampleDescriptionBox *stsd;\n\n\te = CanAccessMovie(file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd || !StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (!entry || ! gf_isom_is_nalu_based_entry(trak->Media, entry)) {\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tve = (GF_MPEGVisualSampleEntryBox*)entry;\n\tif (ve->avc_config) ve->avc_config->config->nal_unit_size = nalu_size_length;\n\tif (ve->svc_config) ve->svc_config->config->nal_unit_size = nalu_size_length;\n\tif (ve->hevc_config) ve->hevc_config->config->nal_unit_size = nalu_size_length;\n\tif (ve->lhvc_config) ve->lhvc_config->config->nal_unit_size = nalu_size_length;\n\tif (ve->vvc_config) ve->vvc_config->config->nal_unit_size = nalu_size_length;\n\treturn GF_OK;\n}\n\nGF_Err gf_isom_set_sample_group_in_traf(GF_ISOFile *file)\n{\n\tGF_Err e;\n\te = CanAccessMovie(file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tfile->sample_groups_in_traf = GF_TRUE;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nvoid gf_isom_set_progress_callback(GF_ISOFile *file, void (*progress_cbk)(void *udta, u64 nb_done, u64 nb_total), void *progress_cbk_udta)\n{\n\tif (file) {\n\t\tfile->progress_cbk = progress_cbk;\n\t\tfile->progress_cbk_udta = progress_cbk_udta;\n\n\t}\n}\n\nGF_Err gf_isom_update_video_sample_entry_fields(GF_ISOFile *file, u32 track, u32 stsd_idx, u16 revision, u32 vendor, u32 temporalQ, u32 spatialQ, u32 horiz_res, u32 vert_res, u16 frames_per_sample, const char *compressor_name, s16 color_table_index)\n{\n\n\tGF_TrackBox *trak;\n\tGF_MPEGVisualSampleEntryBox *vid_ent;\n\n\t/*get orig sample desc and clone it*/\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak || !stsd_idx) return GF_BAD_PARAM;\n\n\tif (!trak->Media || !trak->Media->handler || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->SampleDescription)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tswitch (trak->Media->handler->handlerType) {\n\tcase GF_ISOM_MEDIA_VISUAL:\n    case GF_ISOM_MEDIA_AUXV:\n    case GF_ISOM_MEDIA_PICT:\n    \tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\tvid_ent = gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, stsd_idx-1);\n\tif (!vid_ent)\n\t\treturn GF_BAD_PARAM;\n\n\tvid_ent->revision = revision;\n\tvid_ent->vendor = vendor;\n\tvid_ent->temporal_quality = temporalQ;\n\tvid_ent->spatial_quality = spatialQ;\n\tvid_ent->horiz_res = horiz_res;\n\tvid_ent->vert_res = vert_res;\n\tvid_ent->frames_per_sample = frames_per_sample;\n\tif (compressor_name)\n\t\tstrncpy(vid_ent->compressor_name, compressor_name, 32);\n\n\tvid_ent->color_table_index = color_table_index;\n\treturn GF_OK;\n}\n\n\nGF_Err gf_isom_update_sample_description_from_template(GF_ISOFile *file, u32 track, u32 sampleDescriptionIndex, u8 *data, u32 size)\n{\n\tGF_BitStream *bs;\n\tGF_TrackBox *trak;\n\tGF_Box *ent, *tpl_ent;\n\tGF_Err e;\n\t/*get orig sample desc and clone it*/\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak || !sampleDescriptionIndex) return GF_BAD_PARAM;\n\n\tif (!trak->Media || !trak->Media->handler || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->SampleDescription)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tent = gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, sampleDescriptionIndex-1);\n\tif (!ent) return GF_BAD_PARAM;\n\n\tbs = gf_bs_new(data, size, GF_BITSTREAM_READ);\n//\te = gf_isom_box_parse(&tpl_ent, bs);\n\te = gf_isom_box_parse_ex(&tpl_ent, bs, GF_ISOM_BOX_TYPE_STSD, GF_FALSE, 0);\n\tgf_bs_del(bs);\n\tif (e) return e;\n\n\twhile (gf_list_count(tpl_ent->child_boxes)) {\n\t\tu32 j=0;\n\t\tBool found = GF_FALSE;\n\t\tGF_Box *abox = gf_list_pop_front(tpl_ent->child_boxes);\n\n\t\tswitch (abox->type) {\n\t\tcase GF_ISOM_BOX_TYPE_SINF:\n\t\tcase GF_ISOM_BOX_TYPE_RINF:\n\t\tcase GF_ISOM_BOX_TYPE_BTRT:\n\t\t\tfound = GF_TRUE;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (found) {\n\t\t\tgf_isom_box_del(abox);\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif (!ent->child_boxes) ent->child_boxes = gf_list_new();\n\t\tfor (j=0; j<gf_list_count(ent->child_boxes); j++) {\n\t\t\tGF_Box *b = gf_list_get(ent->child_boxes, j);\n\t\t\tif (b->type == abox->type) {\n\t\t\t\tfound = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!found) {\n\t\t\tgf_list_add(ent->child_boxes, abox);\n\t\t} else {\n\t\t\tgf_isom_box_del(abox);\n\t\t}\n\t}\n\tgf_isom_box_del(tpl_ent);\n\n\t//patch for old export\n\tGF_Box *abox = gf_isom_box_find_child(ent->child_boxes, GF_ISOM_BOX_TYPE_SINF);\n\tif (abox) {\n\t\tgf_list_del_item(ent->child_boxes, abox);\n\t\tgf_list_add(ent->child_boxes, abox);\n\t}\n\treturn GF_OK;\n}\n\n\n#include <gpac/xml.h>\nGF_EXPORT\nGF_Err gf_isom_apply_box_patch(GF_ISOFile *file, GF_ISOTrackID globalTrackID, const char *box_patch_filename, Bool for_fragments)\n{\n\tGF_Err e;\n\tGF_DOMParser *dom;\n\tu32 i;\n\tGF_XMLNode *root;\n\tu8 *box_data=NULL;\n\tu32 box_data_size;\n\tif (!file || !box_patch_filename) return GF_BAD_PARAM;\n#ifdef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (for_fragments) return GF_NOT_SUPPORTED;\n#endif\n\tdom = gf_xml_dom_new();\n\tif (strstr(box_patch_filename, \"<?xml\")) {\n\t\te = gf_xml_dom_parse_string(dom, (char *) box_patch_filename);\n\t} else {\n\t\te = gf_xml_dom_parse(dom, box_patch_filename, NULL, NULL);\n\t}\n\tif (e) goto err_exit;\n\n\troot = gf_xml_dom_get_root(dom);\n\tif (!root || strcmp(root->name, \"GPACBOXES\")) {\n\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\tgoto err_exit;\n\t}\n\n\t//compute size of each child boxes to freeze the order\n\tif (for_fragments) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\tu32 count = file->moof ? gf_list_count(file->moof->child_boxes) : 0;\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_Box *box = gf_list_get(file->moof->child_boxes, i);\n\t\t\tif (!(box->internal_flags & GF_ISOM_ORDER_FREEZE)) {\n\t\t\t\tgf_isom_box_size(box);\n\t\t\t\tgf_isom_box_freeze_order(box);\n\t\t\t}\n\t\t}\n#endif\n\t} else {\n\t\tfor (i=0; i<gf_list_count(file->TopBoxes); i++) {\n\t\t\tGF_Box *box = gf_list_get(file->TopBoxes, i);\n\t\t\tif (!(box->internal_flags & GF_ISOM_ORDER_FREEZE)) {\n\t\t\t\tgf_isom_box_size(box);\n\t\t\t\tgf_isom_box_freeze_order(box);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i=0; i<gf_list_count(root->content); i++) {\n\t\tu32 j;\n\t\tu32 path_len;\n\t\tBool essential_prop=GF_FALSE;\n\t\tu32 trackID=globalTrackID;\n\t\tu32 item_id=trackID;\n\t\tBool is_frag_box;\n\t\tchar *box_path=NULL;\n\t\tGF_Box *parent_box = NULL;\n\t\tGF_XMLNode *box_edit = gf_list_get(root->content, i);\n\t\tif (!box_edit->name || strcmp(box_edit->name, \"Box\")) continue;\n\n\t\tfor (j=0; j<gf_list_count(box_edit->attributes);j++) {\n\t\t\tGF_XMLAttribute *att = gf_list_get(box_edit->attributes, j);\n\t\t\tif (!strcmp(att->name, \"path\")) box_path = att->value;\n\t\t\telse if (!strcmp(att->name, \"essential\")) {\n\t\t\t\tif (!strcmp(att->value, \"yes\") || !strcmp(att->value, \"true\") || !strcmp(att->value, \"1\")) {\n\t\t\t\t\tessential_prop=GF_TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!strcmp(att->name, \"itemID\"))\n\t\t\t\titem_id = atoi(att->value);\n\t\t\telse if (!globalTrackID && !strcmp(att->name, \"trackID\"))\n\t\t\t\ttrackID = atoi(att->value);\n\t\t}\n\n\t\tif (!box_path) continue;\n\t\tpath_len = (u32) strlen(box_path);\n\n\t\tis_frag_box = !strncmp(box_path, \"traf\", 4) ? GF_TRUE : GF_FALSE;\n\n\t\tif (for_fragments && !is_frag_box) continue;\n\t\telse if (!for_fragments && is_frag_box) continue;\n\n\t\tgf_xml_parse_bit_sequence(box_edit, box_patch_filename, &box_data, &box_data_size);\n\t\tif (box_data_size && (box_data_size<4) ) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[ISOBMFF] Wrong BS specification for box, shall either be empty or at least 4 bytes for box type\\n\"));\n\t\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\tgoto err_exit;\n\t\t}\n\n\t\twhile (box_path && (path_len>=4)) {\n\t\t\tu32 parent_list_box_type;\n\t\t\tGF_List **parent_list;\n\t\t\tu32 box_type = GF_4CC(box_path[0],box_path[1],box_path[2],box_path[3]);\n\t\t\tGF_Box *box=NULL;\n\t\t\tGF_BitStream *bs;\n\t\t\ts32 insert_pos = -1;\n\t\t\tbox_path+=4;\n\t\t\tpath_len-=4;\n\n\t\t\tif (!parent_box) {\n\t\t\t\tbox=gf_isom_box_find_child(file->TopBoxes, box_type);\n\t\t\t\tif (!box) {\n\t\t\t\t\tif (box_type==GF_ISOM_BOX_TYPE_TRAK) {\n\t\t\t\t\t\tif (trackID) {\n\t\t\t\t\t\t\tbox = (GF_Box *) gf_isom_get_track_from_file(file, gf_isom_get_track_by_id(file, trackID) );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!box && gf_list_count(file->moov->trackList)==1) {\n\t\t\t\t\t\t\tbox = gf_list_get(file->moov->trackList, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\t\t\telse if (box_type==GF_ISOM_BOX_TYPE_TRAF) {\n\t\t\t\t\t\tif (trackID) {\n\t\t\t\t\t\t\tbox = (GF_Box *) gf_isom_get_traf(file, trackID);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!box && file->moof && gf_list_count(file->moof->TrackList)==1) {\n\t\t\t\t\t\t\tbox = gf_list_get(file->moof->TrackList, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#endif\n\t\t\t\t}\n\t\t\t\tif (!box) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[ISOBMFF] Cannot locate box type %s at root or as track\\n\", gf_4cc_to_str(box_type) ));\n\t\t\t\t\te = GF_BAD_PARAM;\n\t\t\t\t\tgoto err_exit;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbox = gf_isom_box_find_child(parent_box->child_boxes, box_type);\n\t\t\t\tif (!box) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[ISOBMFF] Cannot locate box type %s at child of %s\\n\", gf_4cc_to_str(box_type), gf_4cc_to_str(parent_box->type)));\n\t\t\t\t\te = GF_BAD_PARAM;\n\t\t\t\t\tgoto err_exit;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// '.' is child access\n\t\t\tif (path_len && (box_path[0]=='.')) {\n\t\t\t\tbox_path += 1;\n\t\t\t\tpath_len-=1;\n\t\t\t\tparent_box = box;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (parent_box && !parent_box->child_boxes) parent_box->child_boxes = gf_list_new();\n\t\t\tparent_list = parent_box ? &parent_box->child_boxes : &file->TopBoxes;\n\t\t\tparent_list_box_type = parent_box ? parent_box->type : 0;\n\n\t\t\t// '+' is append after, '-' is insert before\n\t\t\tif (path_len && ((box_path[0]=='-') || (box_path[0]=='+')) ) {\n\t\t\t\ts32 idx = gf_list_find(*parent_list, box);\n\t\t\t\tassert(idx>=0);\n\t\t\t\tif (box_path[0]=='+') insert_pos = idx+1;\n\t\t\t\telse insert_pos = idx;\n\t\t\t}\n\t\t\telse if (path_len) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[ISOBMFF] Invalid path %s, expecting either '-', '+' or '.' as separators\\n\", box_path));\n\t\t\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\tgoto err_exit;\n\t\t\t}\n\n\t\t\tif (!box_data) {\n\t\t\t\tif (insert_pos>=0) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[ISOBMFF] Invalid path %s for box removal, ignoring position\\n\", box_path));\n\t\t\t\t}\n\t\t\t\tswitch (box->type) {\n\t\t\t\tcase GF_ISOM_BOX_TYPE_MOOV:\n\t\t\t\t\tfile->moov = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_ISOM_BOX_TYPE_MDAT:\n\t\t\t\t\tfile->mdat = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_ISOM_BOX_TYPE_PDIN:\n\t\t\t\t\tfile->pdin = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_ISOM_BOX_TYPE_FTYP:\n\t\t\t\t\tfile->brand = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_ISOM_BOX_TYPE_META:\n\t\t\t\t\tif ((GF_Box *) file->meta == box) file->meta = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (parent_box) {\n\t\t\t\t\tgf_isom_box_remove_from_parent(parent_box, box);\n\t\t\t\t}\n\t\t\t\tgf_isom_box_del_parent(parent_list, box);\n\t\t\t} else {\n\t\t\t\tu32 size;\n\n\t\t\t\tbs = gf_bs_new(box_data, box_data_size, GF_BITSTREAM_READ);\n\t\t\t\tsize = gf_bs_read_u32(bs);\n\t\t\t\tif (size != box_data_size) {\n\t\t\t\t\tGF_UnknownBox *new_box = (GF_UnknownBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_UNKNOWN);\n\t\t\t\t\tnew_box->original_4cc = size;\n\t\t\t\t\tnew_box->dataSize = (u32) gf_bs_available(bs);\n\t\t\t\t\tnew_box->data = gf_malloc(sizeof(u8)*new_box->dataSize);\n\t\t\t\t\tgf_bs_read_data(bs, new_box->data, new_box->dataSize);\n\t\t\t\t\tif (insert_pos<0) {\n\t\t\t\t\t\tgf_list_add(box->child_boxes, new_box);\n\t\t\t\t\t\tinsert_pos = gf_list_find(box->child_boxes, new_box);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgf_list_insert(*parent_list, new_box, insert_pos);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (parent_box && (parent_box->type==GF_ISOM_BOX_TYPE_IPRP)) {\n\t\t\t\t\t\tGF_ItemPropertyAssociationBox *ipma = (GF_ItemPropertyAssociationBox *) gf_isom_box_find_child(parent_box->child_boxes, GF_ISOM_BOX_TYPE_IPMA);\n\t\t\t\t\t\tif (!item_id) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[ISOBMFF] Inserting box in ipco without itemID, no association added\\n\"));\n\t\t\t\t\t\t} else if (ipma) {\n\t\t\t\t\t\t\tu32 nb_asso, k;\n\t\t\t\t\t\t\tGF_ItemPropertyAssociationEntry *entry = NULL;\n\t\t\t\t\t\t\tnb_asso = gf_list_count(ipma->entries);\n\t\t\t\t\t\t\tfor (k=0; k<nb_asso;k++) {\n\t\t\t\t\t\t\t\tentry = gf_list_get(ipma->entries, k);\n\t\t\t\t\t\t\t\tif (entry->item_id==item_id) break;\n\t\t\t\t\t\t\t\tentry = NULL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!entry) {\n\t\t\t\t\t\t\t\tGF_SAFEALLOC(entry, GF_ItemPropertyAssociationEntry);\n\t\t\t\t\t\t\t\tif (!entry) return GF_OUT_OF_MEM;\n\t\t\t\t\t\t\t\tgf_list_add(ipma->entries, entry);\n\t\t\t\t\t\t\t\tentry->item_id = item_id;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tentry->associations = gf_realloc(entry->associations, sizeof(GF_ItemPropertyAssociationSlot) * (entry->nb_associations+1));\n\t\t\t\t\t\t\tentry->associations[entry->nb_associations].essential = essential_prop;\n\t\t\t\t\t\t\tentry->associations[entry->nb_associations].index = 1+insert_pos;\n\t\t\t\t\t\t\tentry->nb_associations++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tu32 box_idx = 0;\n\n\t\t\t\t\tgf_bs_seek(bs, 0);\n\t\t\t\t\twhile (gf_bs_available(bs)) {\n\t\t\t\t\t\tGF_Box *new_box;\n\t\t\t\t\t\te = gf_isom_box_parse_ex(&new_box, bs, (insert_pos<0) ? box->type : parent_list_box_type, parent_box ? GF_FALSE : GF_TRUE, 0);\n\t\t\t\t\t\tif (e) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[ISOBMFF] failed to parse box\\n\", box_path));\n\t\t\t\t\t\t\tgf_bs_del(bs);\n\t\t\t\t\t\t\tgoto err_exit;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (insert_pos<0) {\n\t\t\t\t\t\t\tgf_list_add(box->child_boxes, new_box);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgf_list_insert(*parent_list, new_box, insert_pos+box_idx);\n\t\t\t\t\t\t\tbox_idx++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgf_bs_del(bs);\n\n\t\t\t}\n\t\t\tgf_free(box_data);\n\t\t\tbox_data = NULL;\n\t\t\tbox_path = NULL;\n\t\t}\n\t}\n\nerr_exit:\n\n\tgf_xml_dom_del(dom);\n\tif (box_data) gf_free(box_data);\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_track_magic(GF_ISOFile *movie, u32 trackNumber, u64 magic)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\ttrak->magic = magic;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_track_index(GF_ISOFile *movie, u32 trackNumber, u32 index, void (*track_num_changed)(void *udta, u32 old_track_num, u32 new_track_num), void *udta)\n{\n\tu32 i, j, count;\n\tGF_List *tracks;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !index) return GF_BAD_PARAM;\n\ttrak->index = index;\n\ttracks = gf_list_new();\n\tcount = gf_list_count(movie->moov->trackList);\n\t//sort tracks in new list\n\tfor (i=0; i<count; i++) {\n\t\tGF_TrackBox *a_tk = gf_list_get(movie->moov->trackList, i);\n\t\tif (!a_tk->index) {\n\t\t\tgf_list_insert(tracks, a_tk, 0);\n\t\t} else {\n\t\t\tfor (j=0; j<gf_list_count(tracks); j++) {\n\t\t\t\tGF_TrackBox *a_tki = gf_list_get(tracks, j);\n\t\t\t\tif (a_tki->index<a_tk->index) continue;\n\t\t\t\tgf_list_insert(tracks, a_tk, j);\n\t\t\t\ta_tk = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (a_tk)\n\t\t\t\tgf_list_add(tracks, a_tk);\n\t\t}\n\t}\n\tif (gf_list_count(tracks) != count) {\n\t\tgf_list_del(tracks);\n\t\treturn GF_OUT_OF_MEM;\n\t}\n\tif (track_num_changed) {\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_TrackBox *a_tk = gf_list_get(tracks, i);\n\t\t\ts32 old_pos = gf_list_find(movie->moov->trackList, a_tk);\n\t\t\tassert(old_pos>=0);\n\t\t\tif (old_pos != i)\n\t\t\t\ttrack_num_changed(udta, old_pos+1, i+1);\n\t\t}\n\t}\n\tgf_list_del(movie->moov->trackList);\n\tmovie->moov->trackList = tracks;\n\tfor (j=0; j<gf_list_count(tracks); j++) {\n\t\tGF_TrackBox *tki = gf_list_get(tracks, j);\n\t\ttki->index = j+1;\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_ipod_compatible(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\n\te = CanAccessMovie(the_file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media) return GF_BAD_PARAM;\n\tentry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, 0);\n\tif (!entry) return GF_OK;\n\tswitch (entry->type) {\n\tcase GF_ISOM_BOX_TYPE_AVC1:\n\tcase GF_ISOM_BOX_TYPE_AVC2:\n\tcase GF_ISOM_BOX_TYPE_AVC3:\n\tcase GF_ISOM_BOX_TYPE_AVC4:\n\tcase GF_ISOM_BOX_TYPE_SVC1:\n\tcase GF_ISOM_BOX_TYPE_MVC1:\n\tcase GF_ISOM_BOX_TYPE_HVC1:\n\tcase GF_ISOM_BOX_TYPE_HEV1:\n\tcase GF_ISOM_BOX_TYPE_HVT1:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_OK;\n\t}\n\n\tif (!entry->ipod_ext) {\n\t\tentry->ipod_ext = (GF_UnknownUUIDBox *) gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_UUID);\n\t\tif (!entry->ipod_ext) return GF_OUT_OF_MEM;\n\t}\n\tmemcpy(entry->ipod_ext->uuid, GF_ISOM_IPOD_EXT, sizeof(u8)*16);\n\tentry->ipod_ext->dataSize = 4;\n\tentry->ipod_ext->data = gf_malloc(sizeof(u8)*4);\n\tif (!entry->ipod_ext->data) return GF_OUT_OF_MEM;\n\tmemset(entry->ipod_ext->data, 0, sizeof(u8)*4);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nBool gf_isom_is_inplace_rewrite(GF_ISOFile *movie)\n{\n\tif (!movie) return GF_FALSE;\n\tif (!movie->no_inplace_rewrite) {\n\t\t//things where added to the file, no inplace rewrite\n\t\tif (movie->editFileMap && gf_bs_get_size(movie->editFileMap->bs))\n\t\t\tmovie->no_inplace_rewrite = GF_TRUE;\n\t\t//block redirect (used by mp4mx), no inplace rewrite\n\t\telse if (movie->on_block_out || !strcmp(movie->finalName, \"_gpac_isobmff_redirect\"))\n\t\t\tmovie->no_inplace_rewrite = GF_TRUE;\n\t\t//stdout redirect, no inplace rewrite\n\t\telse if (!strcmp(movie->finalName, \"std\"))\n\t\t\tmovie->no_inplace_rewrite = GF_TRUE;\n\t\t//new file, no inplace rewrite\n\t\telse if (!movie->fileName)\n\t\t\tmovie->no_inplace_rewrite = GF_TRUE;\n\t}\n\tif (movie->no_inplace_rewrite) return GF_FALSE;\n\n\treturn GF_TRUE;\n}\n\nGF_EXPORT\nvoid gf_isom_disable_inplace_rewrite(GF_ISOFile *movie)\n{\n\tif (movie)\n\t\tmovie->no_inplace_rewrite = GF_TRUE;\n}\n\n\nGF_Err gf_isom_set_y3d_info(GF_ISOFile *movie, u32 trackNumber, u32 sampleDescriptionIndex, GF_ISOM_Y3D_Info *info)\n{\n\tGF_Err e;\n\tu32 proj_type;\n\tGF_SampleEntryBox *ent;\n\tGF_TrackBox *trak;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media || !info) return GF_BAD_PARAM;\n\n\tent = gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, sampleDescriptionIndex-1);\n\tif (!ent) return GF_BAD_PARAM;\n\n\tif (info->projection_type > GF_PROJ360_EQR) return GF_NOT_SUPPORTED;\n\n\tGF_Stereo3DBox *st3d = (GF_Stereo3DBox *) gf_isom_box_find_child(ent->child_boxes, GF_ISOM_BOX_TYPE_ST3D);\n\tif (st3d) {\n\t\tif (info->stereo_type) {\n\t\t\tst3d->stereo_type = info->stereo_type;\n\t\t} else {\n\t\t\tgf_isom_box_del_parent(&ent->child_boxes, (GF_Box *) st3d);\n\t\t}\n\t} else if (info->stereo_type) {\n\t\tst3d = (GF_Stereo3DBox *) gf_isom_box_new_parent(&ent->child_boxes, GF_ISOM_BOX_TYPE_ST3D);\n\t\tif (!st3d) return GF_OUT_OF_MEM;\n\t\tst3d->stereo_type = info->stereo_type;\n\t}\n\n\n\tGF_Box *sv3d = gf_isom_box_find_child(ent->child_boxes, GF_ISOM_BOX_TYPE_SV3D);\n\tif (sv3d && !info->projection_type) {\n\t\tgf_isom_box_del_parent(&ent->child_boxes, sv3d);\n\t\treturn GF_OK;\n\t}\n\n\tif (!sv3d && !info->projection_type) {\n\t\treturn GF_OK;\n\t}\n\tif (!sv3d) {\n\t\tsv3d = gf_isom_box_new_parent(&ent->child_boxes, GF_ISOM_BOX_TYPE_SV3D);\n\t\tif (!sv3d) return GF_OUT_OF_MEM;\n\t}\n\n\t//svhd mandatory\n\tGF_SphericalVideoInfoBox *svhd = (GF_SphericalVideoInfoBox *) gf_isom_box_find_child(sv3d->child_boxes, GF_ISOM_BOX_TYPE_SVHD);\n\tif (svhd) {\n\t\tif (svhd->string) gf_free(svhd->string);\n\t} else {\n\t\tsvhd = (GF_SphericalVideoInfoBox *) gf_isom_box_new_parent(&sv3d->child_boxes, GF_ISOM_BOX_TYPE_SVHD);\n\t\tif (!svhd) return GF_OUT_OF_MEM;\n\t}\n\tsvhd->string = gf_strdup(info->meta_data ? info->meta_data : \"\");\n\n\t//proj mandatory\n\tGF_Box *proj = gf_isom_box_find_child(sv3d->child_boxes, GF_ISOM_BOX_TYPE_PROJ);\n\tif (!proj) {\n\t\tproj = gf_isom_box_new_parent(&sv3d->child_boxes, GF_ISOM_BOX_TYPE_PROJ);\n\t\tif (!proj) return GF_OUT_OF_MEM;\n\t}\n\n\tGF_ProjectionHeaderBox *projh = (GF_ProjectionHeaderBox *) gf_isom_box_find_child(proj->child_boxes, GF_ISOM_BOX_TYPE_PRHD);\n\t//prj header mandatory\n\tif (!projh) {\n\t\tprojh = (GF_ProjectionHeaderBox *) gf_isom_box_new_parent(&proj->child_boxes, GF_ISOM_BOX_TYPE_PRHD);\n\t\tif (!projh) return GF_OUT_OF_MEM;\n\t}\n\tprojh->yaw = info->yaw;\n\tprojh->pitch = info->pitch;\n\tprojh->roll = info->roll;\n\n\tproj_type = (info->projection_type==GF_PROJ360_CUBE_MAP) ? GF_ISOM_BOX_TYPE_CBMP : GF_ISOM_BOX_TYPE_EQUI;\n\n\tGF_ProjectionTypeBox *projt = (GF_ProjectionTypeBox *) gf_isom_box_find_child(proj->child_boxes, proj_type);\n\tif (!projt) {\n\t\tprojt = (GF_ProjectionTypeBox *) gf_isom_box_new_parent(&proj->child_boxes, proj_type);\n\t\tif (!projt) return GF_OUT_OF_MEM;\n\t}\n\tif (info->projection_type==GF_PROJ360_CUBE_MAP) {\n\t\tprojt->layout = info->layout;\n\t\tprojt->padding = info->padding;\n\t} else {\n\t\tprojt->bounds_top = info->top;\n\t\tprojt->bounds_bottom = info->bottom;\n\t\tprojt->bounds_left = info->left;\n\t\tprojt->bounds_right = info->right;\n\t}\n\n\t//remove other ones\n\tGF_Box *b = gf_isom_box_new_parent(&proj->child_boxes, GF_ISOM_BOX_TYPE_MSHP);\n\tif (b) gf_isom_box_del_parent(&proj->child_boxes, b);\n\tif (info->projection_type==GF_PROJ360_CUBE_MAP) {\n\t\tb = gf_isom_box_new_parent(&proj->child_boxes, GF_ISOM_BOX_TYPE_EQUI);\n\t\tif (b) gf_isom_box_del_parent(&proj->child_boxes, b);\n\t} else {\n\t\tb = gf_isom_box_new_parent(&proj->child_boxes, GF_ISOM_BOX_TYPE_EQUI);\n\t\tif (b) gf_isom_box_del_parent(&proj->child_boxes, b);\n\n\t}\n\treturn GF_OK;\n}\n\n#endif //!defined(GPAC_DISABLE_ISOM_WRITE)\n\n#ifndef GPAC_DISABLE_ISOM\n\nGF_Err gf_isom_add_sample_aux_info_internal(GF_TrackBox *trak, void *_traf, u32 sampleNumber, u32 aux_type, u32 aux_info, u8 *data, u32 size)\n{\n\tu32 i, count;\n\tGF_List **child_box_cont, **child_box_sai, **child_box_saiz, **child_box_saio;\n\tGF_UnknownBox *sai_cont = NULL;\n\n\tif (!trak && !_traf) return GF_BAD_PARAM;\n\n\tif (trak) {\n\t\tchild_box_cont = &trak->child_boxes;\n\t\tchild_box_sai = &trak->Media->information->sampleTable->child_boxes;\n\t\tchild_box_saiz = &trak->Media->information->sampleTable->sai_sizes;\n\t\tchild_box_saio = &trak->Media->information->sampleTable->sai_offsets;\n\t} else {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\tGF_TrackFragmentBox *traf = (GF_TrackFragmentBox *)_traf;\n\n\t\tchild_box_cont = &traf->child_boxes;\n\t\tchild_box_sai = &traf->child_boxes;\n\t\tchild_box_saiz = &traf->sai_sizes;\n\t\tchild_box_saio = &traf->sai_offsets;\n#endif\n\t}\n\n\tcount = gf_list_count(*child_box_cont);\n\tfor (i=0; i<count; i++) {\n\t\tGF_UnknownBox *unkn = gf_list_get(*child_box_cont, i);\n\t\tif (unkn->type != GF_ISOM_BOX_TYPE_UNKNOWN) continue;\n\t\tif (unkn->original_4cc != GF_ISOM_BOX_TYPE_GDAT) continue;\n\t\tif (unkn->sai_type != aux_type) continue;\n\t\tif (unkn->sai_aux_info != aux_info) continue;\n\t\tsai_cont = unkn;\n\t\tbreak;\n\t}\n\tif (!sai_cont) {\n\t\tsai_cont = (GF_UnknownBox *) gf_isom_box_new_parent(child_box_cont, GF_ISOM_BOX_TYPE_UNKNOWN);\n\t\tif (!sai_cont) return GF_OUT_OF_MEM;\n\t\tsai_cont->original_4cc = GF_ISOM_BOX_TYPE_GDAT;\n\t\tsai_cont->sai_type = aux_type;\n\t\tsai_cont->sai_aux_info = aux_info;\n\t}\n\tsai_cont->data = gf_realloc(sai_cont->data, (size+sai_cont->dataSize));\n\tif (!sai_cont->data) return GF_OUT_OF_MEM;\n\tmemcpy(sai_cont->data+sai_cont->dataSize, data, size);\n\tsai_cont->dataSize += size;\n\n\tGF_SampleAuxiliaryInfoSizeBox *saiz=NULL;\n\tGF_SampleAuxiliaryInfoOffsetBox *saio=NULL;\n\tcount = gf_list_count(*child_box_saiz);\n\tfor (i=0; i<count; i++) {\n\t\tsaiz = gf_list_get(*child_box_saiz, i);\n\t\tif ((saiz->aux_info_type==aux_type) && (saiz->aux_info_type_parameter==aux_info)) break;\n\t\tsaiz = NULL;\n\t}\n\tif (!saiz) {\n\t\tsaiz = (GF_SampleAuxiliaryInfoSizeBox *) gf_isom_box_new_parent(child_box_sai, GF_ISOM_BOX_TYPE_SAIZ);\n\t\tif (!saiz) return GF_OUT_OF_MEM;\n\t\tif (! *child_box_saiz) *child_box_saiz = gf_list_new();\n\t\tgf_list_add(*child_box_saiz, saiz);\n\n\t\tsaiz->aux_info_type = aux_type;\n\t\tsaiz->aux_info_type_parameter = aux_info;\n\t}\n\n\tif (saiz->sample_count >= sampleNumber)\n\t\treturn GF_BAD_PARAM;\n\n\tif ( (!saiz->sample_count && (sampleNumber==1))\n\t\t|| ((saiz->default_sample_info_size==size) && size)\n\t) {\n\t\tsaiz->sample_count ++;\n\t\tsaiz->default_sample_info_size = size;\n\t} else {\n\t\tif (sampleNumber > saiz->sample_alloc) {\n\t\t\tsaiz->sample_alloc = sampleNumber+10;\n\t\t\tsaiz->sample_info_size = (u8*)gf_realloc(saiz->sample_info_size, sizeof(u8)*(saiz->sample_alloc));\n\t\t}\n\n\t\tif (saiz->default_sample_info_size) {\n\t\t\tfor (i=0; i<saiz->sample_count; i++)\n\t\t\t\tsaiz->sample_info_size[i] = saiz->default_sample_info_size;\n\t\t\tsaiz->default_sample_info_size = 0;\n\t\t}\n\t\tfor (i=saiz->sample_count; i<sampleNumber-1; i++)\n\t\t\tsaiz->sample_info_size[i] = 0;\n\n\t\tsaiz->sample_info_size[sampleNumber-1] = size;\n\t\tsaiz->sample_count = sampleNumber;\n\t}\n\n\n\tcount = gf_list_count(*child_box_saio);\n\tfor (i=0; i<count; i++) {\n\t\tsaio = gf_list_get(*child_box_saio, i);\n\t\tif ((saio->aux_info_type==aux_type) && (saio->aux_info_type_parameter==aux_info)) break;\n\t\tsaio = NULL;\n\t}\n\tif (!saio) {\n\t\tsaio = (GF_SampleAuxiliaryInfoOffsetBox *) gf_isom_box_new_parent(child_box_sai, GF_ISOM_BOX_TYPE_SAIO);\n\t\tif (!saio) return GF_OUT_OF_MEM;\n\t\tif (! *child_box_saio) *child_box_saio = gf_list_new();\n\t\tgf_list_add(*child_box_saio, saio);\n\t\tsaio->aux_info_type = aux_type;\n\t\tsaio->aux_info_type_parameter = aux_info;\n\t}\n\tif (!saio->sai_data) saio->sai_data = sai_cont;\n\tsaio->version = 1;\n\tsaio->entry_count = 1;\n\n\treturn GF_OK;\n}\n#endif // GPAC_DISABLE_ISOM\n\n\n#if !defined(GPAC_DISABLE_ISOM_WRITE)\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\nGF_Err gf_isom_fragment_set_sample_aux_info(GF_ISOFile *movie, u32 trackID, u32 sample_number_in_frag, u32 aux_type, u32 aux_info, u8 *data, u32 size)\n{\n\tGF_TrackFragmentBox *traf;\n\tif (!movie || !movie->moof || !(movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY) ) return GF_BAD_PARAM;\n\n\ttraf = gf_isom_get_traf(movie, trackID);\n\tif (!traf) return GF_BAD_PARAM;\n\treturn gf_isom_add_sample_aux_info_internal(NULL, traf, sample_number_in_frag, aux_type, aux_info, data, size);\n}\n#endif\n\nGF_Err gf_isom_add_sample_aux_info(GF_ISOFile *file, u32 track, u32 sampleNumber, u32 aux_type, u32 aux_info, u8 *data, u32 size)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\n\te = CanAccessMovie(file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) return GF_BAD_PARAM;\n\n\treturn gf_isom_add_sample_aux_info_internal(trak, NULL, sampleNumber, aux_type, aux_info, data, size);\n}\n\n\nGF_Err gf_isom_set_meta_qt(GF_ISOFile *file)\n{\n\tu32 i, count;\n\tif (!file) return GF_BAD_PARAM;\n\tGF_Err e = CanAccessMovie(file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\tif (file->moov->meta)\n\t\tfile->moov->meta->write_qt = 1;\n\n\tcount = gf_list_count(file->moov->trackList);\n\tfor (i=0; i<count; i++) {\n\t\tGF_TrackBox *trak = gf_list_get(file->moov->trackList, i);\n\t\tif (trak->meta)\n\t\t\ttrak->meta->write_qt = 1;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_set_mpegh_compatible_profiles(GF_ISOFile *movie, u32 trackNumber, u32 sampleDescIndex, const u32 *profiles, u32 nb_compat_profiles)\n{\n\tu32 i, type;\n\tGF_SampleEntryBox *ent;\n\tGF_MHACompatibleProfilesBox *mhap;\n\tGF_TrackBox *trak;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media) return GF_BAD_PARAM;\n\tent = gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, sampleDescIndex-1);\n\tif (!ent) return GF_BAD_PARAM;\n\ttype = ent->type;\n\tif (type==GF_ISOM_BOX_TYPE_GNRA)\n\t\ttype = ((GF_GenericAudioSampleEntryBox *)ent)->EntryType;\n\n\tswitch (type) {\n\tcase GF_ISOM_BOX_TYPE_MHA1:\n\tcase GF_ISOM_BOX_TYPE_MHA2:\n\tcase GF_ISOM_BOX_TYPE_MHM1:\n\tcase GF_ISOM_BOX_TYPE_MHM2:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\tmhap = (GF_MHACompatibleProfilesBox *) gf_isom_box_find_child(ent->child_boxes, GF_ISOM_BOX_TYPE_MHAP);\n\tif (!mhap) {\n\t\tif (! profiles || !nb_compat_profiles) return GF_OK;\n\t\tmhap = (GF_MHACompatibleProfilesBox *) gf_isom_box_new_parent(&ent->child_boxes, GF_ISOM_BOX_TYPE_MHAP);\n\t} else if (! profiles || !nb_compat_profiles) {\n\t\tgf_isom_box_del_parent(&ent->child_boxes, (GF_Box*)mhap);\n\t\treturn GF_OK;\n\t}\n\tif (mhap->compat_profiles) gf_free(mhap->compat_profiles);\n\tmhap->compat_profiles = gf_malloc(sizeof(u8) * nb_compat_profiles);\n\tif (!mhap->compat_profiles) return GF_OUT_OF_MEM;\n\tfor (i=0; i<nb_compat_profiles; i++) {\n\t\tmhap->compat_profiles[i] = (u8) profiles[i];\n\t}\n\tmhap->num_profiles = nb_compat_profiles;\n\treturn GF_OK;\n}\n\nGF_Err gf_isom_set_sample_description_restricted(GF_ISOFile *movie, u32 trackNumber, u32 sampleDescIndex, u32 scheme_type)\n{\n\tu32 type;\n\tGF_SampleEntryBox *ent;\n\tGF_TrackBox *trak;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media) return GF_BAD_PARAM;\n\tent = gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, sampleDescIndex-1);\n\tif (!ent) return GF_BAD_PARAM;\n\ttype = ent->type;\n\n\tu32 original_format = type;\n\tu32 gnr_type=0;\n\tif (original_format==GF_ISOM_BOX_TYPE_GNRA) {\n\t\tgnr_type = original_format;\n\t\ttype = ((GF_GenericAudioSampleEntryBox*)ent)->EntryType;\n\t} else if (original_format==GF_ISOM_BOX_TYPE_GNRV) {\n\t\tgnr_type = original_format;\n\t\ttype = ((GF_GenericVisualSampleEntryBox*)ent)->EntryType;\n\t} else if (original_format==GF_ISOM_BOX_TYPE_GNRM) {\n\t\tgnr_type = original_format;\n\t\ttype = ((GF_GenericSampleEntryBox*)ent)->EntryType;\n\t}\n\n\tswitch (type) {\n\tcase GF_ISOM_BOX_TYPE_RESV:\n\tcase GF_ISOM_BOX_TYPE_RESA:\n\tcase GF_ISOM_BOX_TYPE_RESM:\n\tcase GF_ISOM_BOX_TYPE_REST:\n\tcase GF_ISOM_BOX_TYPE_RESU:\n\tcase GF_ISOM_BOX_TYPE_RESS:\n\tcase GF_ISOM_BOX_TYPE_RESF:\n\tcase GF_ISOM_BOX_TYPE_RESP:\n\tcase GF_ISOM_BOX_TYPE_RES3:\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_STXT:\n\t\ttype = GF_ISOM_BOX_TYPE_REST;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_STPP:\n\t\ttype = GF_ISOM_BOX_TYPE_RESU;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_METX:\n\tcase GF_ISOM_BOX_TYPE_METT:\n\tcase GF_ISOM_BOX_TYPE_URIM:\n\tcase GF_ISOM_BOX_TYPE_MEBX:\n\t\ttype = GF_ISOM_BOX_TYPE_RESM;\n\t\tbreak;\n\tdefault:\n\t\ttype=0;\n\t\tswitch (trak->Media->handler->handlerType) {\n\t\tcase GF_ISOM_MEDIA_VISUAL:\n\t\tcase GF_ISOM_MEDIA_AUXV:\n\t\tcase GF_ISOM_MEDIA_PICT:\n\t\t\ttype = GF_ISOM_BOX_TYPE_RESV;\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_AUDIO:\n\t\t\ttype = GF_ISOM_BOX_TYPE_RESA;\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_OD:\n\t\tcase GF_ISOM_MEDIA_OCR:\n\t\tcase GF_ISOM_MEDIA_SCENE:\n\t\tcase GF_ISOM_MEDIA_MPEG7:\n\t\tcase GF_ISOM_MEDIA_OCI:\n\t\tcase GF_ISOM_MEDIA_IPMP:\n\t\tcase GF_ISOM_MEDIA_MPEGJ:\n\t\t\ttype = GF_ISOM_BOX_TYPE_RESS;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\tif (!type) return GF_NOT_SUPPORTED;\n\n\tGF_ProtectionSchemeInfoBox *rinf;\n\trinf = (GF_ProtectionSchemeInfoBox *) gf_isom_box_find_child(ent->child_boxes, GF_ISOM_BOX_TYPE_RINF);\n\tif (rinf) gf_isom_box_del_parent(&ent->child_boxes, (GF_Box *)rinf);\n\n\trinf = (GF_ProtectionSchemeInfoBox *)gf_isom_box_new_parent(&ent->child_boxes, GF_ISOM_BOX_TYPE_RINF);\n\tif (!rinf) return GF_OUT_OF_MEM;\n\n\n\trinf->original_format = (GF_OriginalFormatBox *)gf_isom_box_new_parent(&rinf->child_boxes, GF_ISOM_BOX_TYPE_FRMA);\n\tif (!rinf->original_format) return GF_OUT_OF_MEM;\n\tif (gnr_type) {\n\t\trinf->original_format->data_format = gnr_type;\n\t\trinf->original_format->gnr_type = original_format;\n\t} else {\n\t\trinf->original_format->data_format = original_format;\n\t}\n\t//common to isma, cenc and oma\n\trinf->scheme_type = (GF_SchemeTypeBox *)gf_isom_box_new_parent(&rinf->child_boxes, GF_ISOM_BOX_TYPE_SCHM);\n\tif (!rinf->scheme_type) return GF_OUT_OF_MEM;\n\trinf->scheme_type->scheme_type  = scheme_type;\n\n\tent->type = type;\n\treturn GF_OK;\n}\n\n\n#endif\t/*!defined(GPAC_DISABLE_ISOM) && !defined(GPAC_DISABLE_ISOM_WRITE)*/\n\n"], "fixing_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2023\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISO Media File Format sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n\n\n#ifndef _GF_ISOMEDIA_H_\n#define _GF_ISOMEDIA_H_\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/*!\n\\file <gpac/isomedia.h>\n\\brief ISOBMFF parsing and writing library.\n*/\n\n/*!\n\\addtogroup iso_grp ISO Base Media File\n\\brief ISOBMF, 3GPP, AVC and HEVC file format utilities.\n\nThis section documents the reading and writing of ISOBMF (MP4, 3GPP, AVC, HEVC HEIF ...)\nThe library supports:\n- regular movie read\n- regular movie write\n- fragmented movie and movie segments read\n- fragmented movie and movie segments write\n- QT support\n- Sample descriptions for most common media found in such files (audio, video, text and subtitles)\n- Meta and HEIF read\n- Meta and HEIF write\n- Common Encryption ISMA E&A and OMA DRM support\n- MPEG-4 Systems extensions\n\n\nAll the READ function in this API can be used in EDIT/WRITE mode.\nHowever, some unexpected errors or values may happen in that case, depending\non how much modifications you made (timing, track with 0 samples, ...).\nOn the other hand, none of the EDIT/WRITE functions will work in READ mode.\n\nThe output structure of a edited file will sometimes be different\nfrom the original file, but the media-data and meta-data will be identical.\nThe only change happens in the file media-data container(s) during edition\n\nWhen editing the file, you MUST set the final name of the modified file\nto something different. This API doesn't allow file overwriting.\n\n@{\n */\n\n#include <gpac/tools.h>\n\n\n/*! Track reference types\n\nSome track may depend on other tracks for several reasons. They reference these tracks through the following Reference Types\n*/\nenum\n{\n\t/*! ref type for the OD track dependencies*/\n\tGF_ISOM_REF_OD = GF_4CC( 'm', 'p', 'o', 'd' ),\n\t/*! ref type for stream dependencies*/\n\tGF_ISOM_REF_DECODE = GF_4CC( 'd', 'p', 'n', 'd' ),\n\t/*! ref type for OCR (Object Clock Reference) dependencies*/\n\tGF_ISOM_REF_OCR = GF_4CC( 's', 'y', 'n', 'c' ),\n\t/*! ref type for IPI (Intellectual Property Information) dependencies*/\n\tGF_ISOM_REF_IPI = GF_4CC( 'i', 'p', 'i', 'r' ),\n\t/*! this track describes the referenced tr*/\n\tGF_ISOM_REF_META = GF_4CC( 'c', 'd', 's', 'c' ),\n\t/*! ref type for Hint tracks*/\n\tGF_ISOM_REF_HINT = GF_4CC( 'h', 'i', 'n', 't' ),\n\t/*! ref type for QT Chapter tracks*/\n\tGF_ISOM_REF_CHAP = GF_4CC( 'c', 'h', 'a', 'p' ),\n\t/*! ref type for the SVC and SHVC base tracks*/\n\tGF_ISOM_REF_BASE = GF_4CC( 's', 'b', 'a', 's' ),\n\t/*! ref type for the SVC and SHVC extractor reference tracks*/\n\tGF_ISOM_REF_SCAL = GF_4CC( 's', 'c', 'a', 'l' ),\n\t/*! ref type for the SHVC tile base tracks*/\n\tGF_ISOM_REF_TBAS = GF_4CC( 't', 'b', 'a', 's' ),\n\t/*! ref type for the SHVC tile tracks*/\n\tGF_ISOM_REF_SABT = GF_4CC( 's', 'a', 'b', 't' ),\n\t/*! ref type for the SHVC oinf track*/\n\tGF_ISOM_REF_OREF = GF_4CC( 'o', 'r', 'e', 'f' ),\n\t/*! this track uses fonts carried/defined in the referenced track*/\n\tGF_ISOM_REF_FONT = GF_4CC( 'f', 'o', 'n', 't' ),\n\t/*! this track depends on the referenced hint track, i.e., it should only be used if the referenced hint track is used.*/\n\tGF_ISOM_REF_HIND = GF_4CC( 'h', 'i', 'n', 'd' ),\n\t/*! this track contains auxiliary depth video information for the referenced video track*/\n\tGF_ISOM_REF_VDEP = GF_4CC( 'v', 'd', 'e', 'p' ),\n\t/*! this track contains auxiliary parallax video information for the referenced video track*/\n\tGF_ISOM_REF_VPLX = GF_4CC( 'v', 'p', 'l', 'x' ),\n\t/*! this track contains subtitle, timed text or overlay graphical information for the referenced track or any track in the alternate group to which the track belongs, if any*/\n\tGF_ISOM_REF_SUBT = GF_4CC( 's', 'u', 'b', 't' ),\n\t/*! thumbnail track*/\n\tGF_ISOM_REF_THUMB = GF_4CC( 't', 'h', 'm', 'b' ),\n\t/*DRC*/\n\t/*! additional audio track*/\n\tGF_ISOM_REF_ADDA = GF_4CC( 'a', 'd', 'd', 'a' ),\n\t/*! DRC metadata*/\n\tGF_ISOM_REF_ADRC = GF_4CC( 'a', 'd', 'r', 'c' ),\n\t/*! item->track location*/\n\tGF_ISOM_REF_ILOC = GF_4CC( 'i', 'l', 'o', 'c' ),\n\t/*! AVC dep stream*/\n\tGF_ISOM_REF_AVCP = GF_4CC( 'a', 'v', 'c', 'p' ),\n\t/*! AVC switch to*/\n\tGF_ISOM_REF_SWTO = GF_4CC( 's', 'w', 't', 'o' ),\n\t/*! AVC switch from*/\n\tGF_ISOM_REF_SWFR = GF_4CC( 's', 'w', 'f', 'r' ),\n\n\t/*! Time code*/\n\tGF_ISOM_REF_TMCD = GF_4CC( 't', 'm', 'c', 'd' ),\n\t/*! Structural dependency*/\n\tGF_ISOM_REF_CDEP = GF_4CC( 'c', 'd', 'e', 'p' ),\n\t/*! transcript*/\n\tGF_ISOM_REF_SCPT = GF_4CC( 's', 'c', 'p', 't' ),\n\t/*! nonprimary source description*/\n\tGF_ISOM_REF_SSRC = GF_4CC( 's', 's', 'r', 'c' ),\n\t/*! layer audio track dependency*/\n\tGF_ISOM_REF_LYRA = GF_4CC( 'l', 'y', 'r', 'a' ),\n\t/*! File Delivery Item Information Extension */\n\tGF_ISOM_REF_FDEL = GF_4CC( 'f', 'd', 'e', 'l' ),\n#ifdef GF_ENABLE_CTRN\n\t/*! Track fragment inherit */\n\tGF_ISOM_REF_TRIN = GF_4CC( 't', 'r', 'i', 'n' ),\n#endif\n\n\t/*! Item auxiliary reference */\n\tGF_ISOM_REF_AUXR = GF_4CC( 'a', 'u', 'x', 'r' ),\n\n\t/*! ref type for the VVC subpicture tracks*/\n\tGF_ISOM_REF_SUBPIC = GF_4CC( 's', 'u', 'b', 'p' ),\n};\n\n/*! Track Edit list type*/\ntypedef enum {\n\t/*! empty segment in the track (no media for this segment)*/\n\tGF_ISOM_EDIT_EMPTY\t\t=\t0x00,\n\t/*! dwelled segment in the track (one media sample for this segment)*/\n\tGF_ISOM_EDIT_DWELL\t\t=\t0x01,\n\t/*! normal segment in the track*/\n\tGF_ISOM_EDIT_NORMAL\t\t=\t0x02\n} GF_ISOEditType;\n\n/*! Generic Media Types (YOU HAVE TO USE ONE OF THESE TYPES FOR COMPLIANT ISO MEDIA FILES)*/\nenum\n{\n\t/*base media types*/\n\tGF_ISOM_MEDIA_VISUAL\t= GF_4CC( 'v', 'i', 'd', 'e' ),\n    GF_ISOM_MEDIA_AUXV      = GF_4CC( 'a', 'u', 'x', 'v' ),\n    GF_ISOM_MEDIA_PICT      = GF_4CC( 'p', 'i', 'c', 't' ),\n\tGF_ISOM_MEDIA_AUDIO\t\t= GF_4CC( 's', 'o', 'u', 'n' ),\n\tGF_ISOM_MEDIA_HINT\t\t= GF_4CC( 'h', 'i', 'n', 't' ),\n\tGF_ISOM_MEDIA_META\t\t= GF_4CC( 'm', 'e', 't', 'a' ),\n\tGF_ISOM_MEDIA_TEXT\t\t= GF_4CC( 't', 'e', 'x', 't' ),\n\t/*subtitle code point used on ipod - same as text*/\n\tGF_ISOM_MEDIA_SUBT\t\t= GF_4CC( 's', 'b', 't', 'l' ),\n\tGF_ISOM_MEDIA_SUBPIC\t= GF_4CC( 's', 'u', 'b', 'p' ),\n\tGF_ISOM_MEDIA_MPEG_SUBT\t= GF_4CC( 's', 'u', 'b', 't' ),\n\t/*closed caption track types for QT/ProRes*/\n\tGF_ISOM_MEDIA_CLOSED_CAPTION\t\t= GF_4CC( 'c', 'l', 'c', 'p' ),\n\t/*timecode metadata for QT/ProRes*/\n\tGF_ISOM_MEDIA_TIMECODE\t\t= GF_4CC( 't', 'm', 'c', 'd' ),\n\t/*MPEG-4 media types*/\n\tGF_ISOM_MEDIA_OD\t\t= GF_4CC( 'o', 'd', 's', 'm' ),\n\tGF_ISOM_MEDIA_OCR\t\t= GF_4CC( 'c', 'r', 's', 'm' ),\n\tGF_ISOM_MEDIA_SCENE\t\t= GF_4CC( 's', 'd', 's', 'm' ),\n\tGF_ISOM_MEDIA_MPEG7\t\t= GF_4CC( 'm', '7', 's', 'm' ),\n\tGF_ISOM_MEDIA_OCI\t\t= GF_4CC( 'o', 'c', 's', 'm' ),\n\tGF_ISOM_MEDIA_IPMP\t\t= GF_4CC( 'i', 'p', 's', 'm' ),\n\tGF_ISOM_MEDIA_MPEGJ\t\t= GF_4CC( 'm', 'j', 's', 'm' ),\n\t/*GPAC-defined, for any track using MPEG-4 systems signaling but with undefined streaml types*/\n\tGF_ISOM_MEDIA_ESM\t\t= GF_4CC( 'g', 'e', 's', 'm' ),\n\t/*DIMS media type (same as scene but with a different mediaInfo)*/\n\tGF_ISOM_MEDIA_DIMS\t\t= GF_4CC( 'd', 'i', 'm', 's' ),\n\t/*SWF file embedded in media track*/\n\tGF_ISOM_MEDIA_FLASH\t\t= GF_4CC( 'f', 'l', 's', 'h' ),\n\t/*QTVR track*/\n\tGF_ISOM_MEDIA_QTVR\t\t= GF_4CC( 'q', 't', 'v', 'r' ),\n\tGF_ISOM_MEDIA_JPEG\t\t= GF_4CC( 'j', 'p', 'e', 'g' ),\n\tGF_ISOM_MEDIA_JP2\t\t= GF_4CC( 'j', 'p', '2', ' ' ),\n\tGF_ISOM_MEDIA_PNG\t\t= GF_4CC( 'p', 'n', 'g', ' ' ),\n};\n\n\n/*! specific media sub-types - you shall make sure the media sub type is what you expect*/\nenum\n{\n\t/*reserved, internal use in the lib. Indicates the track complies to MPEG-4 system\n\tspecification, and the usual OD framework tools may be used*/\n\tGF_ISOM_SUBTYPE_MPEG4\t\t= GF_4CC( 'M', 'P', 'E', 'G' ),\n\n\t/*reserved, internal use in the lib. Indicates the track is of GF_ISOM_SUBTYPE_MPEG4\n\tbut it is encrypted.*/\n\tGF_ISOM_SUBTYPE_MPEG4_CRYP\t= GF_4CC( 'E', 'N', 'C', 'M' ),\n\n\t/*restricted video subtype*/\n\tGF_ISOM_SUBTYPE_RESV\t= GF_4CC( 'r', 'e', 's', 'v' ),\n\n\n\t/*AVC/H264 media type - not listed as an MPEG-4 type, ALTHOUGH this library automatically remaps\n\tGF_AVCConfig to MPEG-4 ESD*/\n\tGF_ISOM_SUBTYPE_AVC_H264\t\t= GF_4CC( 'a', 'v', 'c', '1' ),\n\tGF_ISOM_SUBTYPE_AVC2_H264\t\t= GF_4CC( 'a', 'v', 'c', '2' ),\n\tGF_ISOM_SUBTYPE_AVC3_H264\t\t= GF_4CC( 'a', 'v', 'c', '3' ),\n\tGF_ISOM_SUBTYPE_AVC4_H264\t\t= GF_4CC( 'a', 'v', 'c', '4' ),\n\tGF_ISOM_SUBTYPE_SVC_H264\t\t= GF_4CC( 's', 'v', 'c', '1' ),\n\tGF_ISOM_SUBTYPE_MVC_H264\t\t= GF_4CC( 'm', 'v', 'c', '1' ),\n\n\t/*HEVC media type*/\n\tGF_ISOM_SUBTYPE_HVC1\t\t\t= GF_4CC( 'h', 'v', 'c', '1' ),\n\tGF_ISOM_SUBTYPE_HEV1\t\t\t= GF_4CC( 'h', 'e', 'v', '1' ),\n\tGF_ISOM_SUBTYPE_HVC2\t\t\t= GF_4CC( 'h', 'v', 'c', '2' ),\n\tGF_ISOM_SUBTYPE_HEV2\t\t\t= GF_4CC( 'h', 'e', 'v', '2' ),\n\tGF_ISOM_SUBTYPE_LHV1\t\t\t= GF_4CC( 'l', 'h', 'v', '1' ),\n\tGF_ISOM_SUBTYPE_LHE1\t\t\t= GF_4CC( 'l', 'h', 'e', '1' ),\n\tGF_ISOM_SUBTYPE_HVT1\t\t\t= GF_4CC( 'h', 'v', 't', '1' ),\n\n\t/*VVC media types*/\n\tGF_ISOM_SUBTYPE_VVC1\t\t\t= GF_4CC( 'v', 'v', 'c', '1' ),\n\tGF_ISOM_SUBTYPE_VVI1\t\t\t= GF_4CC( 'v', 'v', 'i', '1' ),\n\tGF_ISOM_SUBTYPE_VVS1\t\t\t= GF_4CC( 'v', 'v', 's', '1' ),\n\tGF_ISOM_SUBTYPE_VVCN\t\t\t= GF_4CC( 'v', 'v', 'c', 'N' ),\n\n\t/*AV1 media type*/\n\tGF_ISOM_SUBTYPE_AV01 = GF_4CC('a', 'v', '0', '1'),\n\n\t/*Opus media type*/\n\tGF_ISOM_SUBTYPE_OPUS = GF_4CC('O', 'p', 'u', 's'),\n\tGF_ISOM_SUBTYPE_FLAC = GF_4CC( 'f', 'L', 'a', 'C' ),\n\n\t/* VP */\n\tGF_ISOM_SUBTYPE_VP08 = GF_4CC('v', 'p', '0', '8'),\n\tGF_ISOM_SUBTYPE_VP09 = GF_4CC('v', 'p', '0', '9'),\n\tGF_ISOM_SUBTYPE_VP10 = GF_4CC('v', 'p', '1', '0'),\n\n\t/* Dolby Vision */\n\tGF_ISOM_SUBTYPE_DVHE = GF_4CC('d', 'v', 'h', 'e'),\n\tGF_ISOM_SUBTYPE_DVH1 = GF_4CC('d', 'v', 'h', '1'),\n\tGF_ISOM_SUBTYPE_DVA1 = GF_4CC('d', 'v', 'a', '1'),\n\tGF_ISOM_SUBTYPE_DVAV = GF_4CC('d', 'v', 'a', 'v'),\n\tGF_ISOM_SUBTYPE_DAV1 = GF_4CC('d', 'a', 'v', '1'),\n\n\t/*3GPP(2) extension subtypes*/\n\tGF_ISOM_SUBTYPE_3GP_H263\t= GF_4CC( 's', '2', '6', '3' ),\n\tGF_ISOM_SUBTYPE_3GP_AMR\t\t= GF_4CC( 's', 'a', 'm', 'r' ),\n\tGF_ISOM_SUBTYPE_3GP_AMR_WB\t= GF_4CC( 's', 'a', 'w', 'b' ),\n\tGF_ISOM_SUBTYPE_3GP_EVRC\t= GF_4CC( 's', 'e', 'v', 'c' ),\n\tGF_ISOM_SUBTYPE_3GP_QCELP\t= GF_4CC( 's', 'q', 'c', 'p' ),\n\tGF_ISOM_SUBTYPE_3GP_SMV\t\t= GF_4CC( 's', 's', 'm', 'v' ),\n\n\t/*3GPP DIMS*/\n\tGF_ISOM_SUBTYPE_3GP_DIMS\t= GF_4CC( 'd', 'i', 'm', 's' ),\n\n\tGF_ISOM_SUBTYPE_AC3\t\t\t= GF_4CC( 'a', 'c', '-', '3' ),\n\tGF_ISOM_SUBTYPE_EC3\t\t\t= GF_4CC( 'e', 'c', '-', '3' ),\n\tGF_ISOM_SUBTYPE_MP3\t\t\t= GF_4CC( '.', 'm', 'p', '3' ),\n\tGF_ISOM_SUBTYPE_MLPA\t\t= GF_4CC( 'm', 'l', 'p', 'a' ),\n\n\tGF_ISOM_SUBTYPE_MP4A\t\t= GF_4CC( 'm', 'p', '4', 'a' ),\n\tGF_ISOM_SUBTYPE_MP4S\t\t= GF_4CC( 'm', 'p', '4', 's' ),\n\n\tGF_ISOM_SUBTYPE_LSR1\t\t= GF_4CC( 'l', 's', 'r', '1' ),\n\tGF_ISOM_SUBTYPE_WVTT\t\t= GF_4CC( 'w', 'v', 't', 't' ),\n\tGF_ISOM_SUBTYPE_STXT\t\t= GF_4CC( 's', 't', 'x', 't' ),\n\tGF_ISOM_SUBTYPE_STPP\t\t= GF_4CC( 's', 't', 'p', 'p' ),\n\tGF_ISOM_SUBTYPE_SBTT\t\t= GF_4CC( 's', 'b', 't', 't' ),\n\tGF_ISOM_SUBTYPE_METT\t\t= GF_4CC( 'm', 'e', 't', 't' ),\n\tGF_ISOM_SUBTYPE_METX\t\t= GF_4CC( 'm', 'e', 't', 'x' ),\n\tGF_ISOM_SUBTYPE_TX3G\t\t= GF_4CC( 't', 'x', '3', 'g' ),\n\tGF_ISOM_SUBTYPE_TEXT\t\t= GF_4CC( 't', 'e', 'x', 't' ),\n\tGF_ISOM_SUBTYPE_SUBTITLE\t= GF_4CC( 's', 'b', 't', 'l' ),\n\n\n\tGF_ISOM_SUBTYPE_RTP\t\t\t= GF_4CC( 'r', 't', 'p', ' ' ),\n\tGF_ISOM_SUBTYPE_SRTP\t\t= GF_4CC( 's', 'r', 't', 'p' ),\n\tGF_ISOM_SUBTYPE_RRTP\t\t= GF_4CC( 'r', 'r', 't', 'p' ),\n\tGF_ISOM_SUBTYPE_RTCP\t\t= GF_4CC( 'r', 't', 'c', 'p' ),\n\tGF_ISOM_SUBTYPE_FLUTE\t\t= GF_4CC( 'f', 'd', 'p', ' ' ),\n\n\t/* Apple XDCAM */\n\tGF_ISOM_SUBTYPE_XDVB\t\t= GF_4CC( 'x', 'd', 'v', 'b' ),\n\n\tGF_ISOM_SUBTYPE_H263\t\t= GF_4CC( 'h', '2', '6', '3' ),\n\n\tGF_ISOM_SUBTYPE_JPEG\t\t= GF_4CC( 'j', 'p', 'e', 'g' ),\n\tGF_ISOM_SUBTYPE_PNG \t\t= GF_4CC( 'p', 'n', 'g', ' ' ),\n\tGF_ISOM_SUBTYPE_MJP2 \t\t= GF_4CC( 'm', 'j', 'p', '2' ),\n\tGF_ISOM_SUBTYPE_JP2K\t\t= GF_4CC('j','p','2','k'),\n\n\tGF_ISOM_SUBTYPE_MH3D_MHA1\t= GF_4CC( 'm', 'h', 'a', '1' ),\n\tGF_ISOM_SUBTYPE_MH3D_MHA2\t= GF_4CC( 'm', 'h', 'a', '2' ),\n\tGF_ISOM_SUBTYPE_MH3D_MHM1\t= GF_4CC( 'm', 'h', 'm', '1' ),\n\tGF_ISOM_SUBTYPE_MH3D_MHM2\t= GF_4CC( 'm', 'h', 'm', '2' ),\n\n\tGF_ISOM_SUBTYPE_IPCM\t\t= GF_4CC( 'i', 'p', 'c', 'm' ),\n\tGF_ISOM_SUBTYPE_FPCM\t\t= GF_4CC( 'f', 'p', 'c', 'm' ),\n\n\t/* on-screen colours */\n\tGF_ISOM_SUBTYPE_NCLX \t\t= GF_4CC( 'n', 'c', 'l', 'x' ),\n\tGF_ISOM_SUBTYPE_NCLC \t\t= GF_4CC( 'n', 'c', 'l', 'c' ),\n\tGF_ISOM_SUBTYPE_PROF \t\t= GF_4CC( 'p', 'r', 'o', 'f' ),\n\tGF_ISOM_SUBTYPE_RICC \t\t= GF_4CC( 'r', 'I', 'C', 'C' ),\n\n\t/* QT audio codecs */\n\t//this one is also used for 24bit RGB\n\tGF_QT_SUBTYPE_RAW\t= GF_4CC('r','a','w',' '),\n\tGF_QT_SUBTYPE_TWOS \t= GF_4CC('t','w','o','s'),\n\tGF_QT_SUBTYPE_SOWT \t= GF_4CC('s','o','w','t'),\n\tGF_QT_SUBTYPE_FL32 \t= GF_4CC('f','l','3','2'),\n\tGF_QT_SUBTYPE_FL64 \t= GF_4CC('f','l','6','4'),\n\tGF_QT_SUBTYPE_IN24 \t= GF_4CC('i','n','2','4'),\n\tGF_QT_SUBTYPE_IN32 \t= GF_4CC('i','n','3','2'),\n\tGF_QT_SUBTYPE_ULAW \t= GF_4CC('u','l','a','w'),\n\tGF_QT_SUBTYPE_ALAW \t= GF_4CC('a','l','a','w'),\n\tGF_QT_SUBTYPE_ADPCM \t= GF_4CC(0x6D,0x73,0x00,0x02),\n\tGF_QT_SUBTYPE_IMA_ADPCM \t= GF_4CC(0x6D,0x73,0x00,0x11),\n\tGF_QT_SUBTYPE_DVCA \t= GF_4CC('d','v','c','a'),\n\tGF_QT_SUBTYPE_QDMC \t= GF_4CC('Q','D','M','C'),\n\tGF_QT_SUBTYPE_QDMC2\t= GF_4CC('Q','D','M','2'),\n\tGF_QT_SUBTYPE_QCELP\t= GF_4CC('Q','c','l','p'),\n\tGF_QT_SUBTYPE_kMP3 \t= GF_4CC(0x6D,0x73,0x00,0x55),\n\n\t/* QT video codecs */\n\tGF_QT_SUBTYPE_C608\t= GF_4CC( 'c', '6', '0', '8' ),\n\tGF_QT_SUBTYPE_APCH\t= GF_4CC( 'a', 'p', 'c', 'h' ),\n\tGF_QT_SUBTYPE_APCO\t= GF_4CC( 'a', 'p', 'c', 'o' ),\n\tGF_QT_SUBTYPE_APCN\t= GF_4CC( 'a', 'p', 'c', 'n' ),\n\tGF_QT_SUBTYPE_APCS\t= GF_4CC( 'a', 'p', 'c', 's' ),\n\tGF_QT_SUBTYPE_AP4X\t= GF_4CC( 'a', 'p', '4', 'x' ),\n\tGF_QT_SUBTYPE_AP4H\t= GF_4CC( 'a', 'p', '4', 'h' ),\n\tGF_QT_SUBTYPE_YUYV = GF_4CC('y','u','v','2'),\n\tGF_QT_SUBTYPE_UYVY = GF_4CC('2','v','u','y'),\n\tGF_QT_SUBTYPE_YUV444 = GF_4CC('v','3','0','8'),\n\tGF_QT_SUBTYPE_YUVA444 = GF_4CC('v','4','0','8'),\n\tGF_QT_SUBTYPE_YUV422_10 = GF_4CC('v','2','1','0'),\n\tGF_QT_SUBTYPE_YUV444_10 = GF_4CC('v','4','1','0'),\n\tGF_QT_SUBTYPE_YUV422_16 = GF_4CC('v','2','1','6'),\n\tGF_QT_SUBTYPE_YUV420 = GF_4CC('j','4','2','0'),\n\tGF_QT_SUBTYPE_I420 = GF_4CC('I','4','2','0'),\n\tGF_QT_SUBTYPE_IYUV = GF_4CC('I','Y','U','V'),\n\tGF_QT_SUBTYPE_YV12 = GF_4CC('y','v','1','2'),\n\tGF_QT_SUBTYPE_YVYU = GF_4CC('Y','V','Y','U'),\n\tGF_QT_SUBTYPE_RGBA = GF_4CC('R','G','B','A'),\n\tGF_QT_SUBTYPE_ABGR = GF_4CC('A','B','G','R'),\n\tGF_QT_SUBTYPE_ALAC =  GF_4CC('a','l','a','c'),\n\tGF_QT_SUBTYPE_LPCM =  GF_4CC('l','p','c','m'),\n\tGF_ISOM_SUBTYPE_FFV1\t\t= GF_4CC( 'F', 'F', 'V', '1' ),\n\n\tGF_ISOM_ITEM_TYPE_AUXI \t= GF_4CC('a', 'u', 'x', 'i'),\n\n\tGF_QT_SUBTYPE_TMCD = GF_4CC( 't', 'm', 'c', 'd' ),\n\n\tGF_ISOM_SUBTYPE_VC1 = GF_4CC( 'v', 'c', '-', '1' ),\n\n\t/*GPAC extensions*/\n\tGF_ISOM_SUBTYPE_DVB_SUBS\t= GF_4CC( 'd', 'v', 'b', 's' ),\n\tGF_ISOM_SUBTYPE_DVB_TELETEXT\t= GF_4CC( 'd', 'v', 'b', 't' ),\n\n\n\tGF_ISOM_SUBTYPE_DTSC = GF_4CC('d','t','s','c'),\n\tGF_ISOM_SUBTYPE_DTSH = GF_4CC('d','t','s','h'),\n\tGF_ISOM_SUBTYPE_DTSL = GF_4CC('d','t','s','l'),\n\tGF_ISOM_SUBTYPE_DTSE = GF_4CC('d','t','s','e'),\n\tGF_ISOM_SUBTYPE_DTSX = GF_4CC('d','t','s','x'),\n\tGF_ISOM_SUBTYPE_DTSY = GF_4CC('d','t','s','y'),\n\n\tGF_ISOM_SUBTYPE_UNCV\t= GF_4CC( 'u', 'n', 'c', 'v' ),\n\tGF_ISOM_ITEM_TYPE_UNCI\t= GF_4CC( 'u', 'n', 'c', 'i' ),\n};\n\n\n\n\n/*! direction for sample search (including SyncSamples search)\nFunction using search allways specify the desired time in composition (presentation) time\n\t\t(Sample N-1)\tDesiredTime\t\t(Sample N)\n*/\ntypedef enum\n{\n\t/*! FORWARD: will give the next sample given the desired time (eg, N)*/\n\tGF_ISOM_SEARCH_FORWARD\t\t=\t1,\n\t/*! BACKWARD: will give the previous sample given the desired time (eg, N-1)*/\n\tGF_ISOM_SEARCH_BACKWARD\t\t=\t2,\n\t/*! SYNCFORWARD: will search from the desired point in time for a sync sample if any. If no sync info, behaves as FORWARD*/\n\tGF_ISOM_SEARCH_SYNC_FORWARD\t=\t3,\n\t/*! SYNCBACKWARD: will search till the desired point in time for a sync sample if any. If no sync info, behaves as BACKWARD*/\n\tGF_ISOM_SEARCH_SYNC_BACKWARD\t=\t4,\n\t/*! SYNCSHADOW: use the sync shadow information to retrieve the sample. If no SyncShadow info, behave as SYNCBACKWARD\n\t\\warning deprecated in ISOBMFF*/\n\tGF_ISOM_SEARCH_SYNC_SHADOW\t\t=\t5\n} GF_ISOSearchMode;\n\n/*! Predefined File Brand codes (MPEG-4 and JPEG2000)*/\nenum\n{\n\t/*file complying to the generic ISO Media File (base specification ISO/IEC 14496-12)\n\tthis is the default brand when creating a new movie*/\n\tGF_ISOM_BRAND_ISOM = GF_4CC( 'i', 's', 'o', 'm' ),\n\t/*file complying to the generic ISO Media File (base specification ISO/IEC 14496-12) + Meta extensions*/\n\tGF_ISOM_BRAND_ISO2 =  GF_4CC( 'i', 's', 'o', '2' ),\n\t/*file complying to ISO/IEC 14496-1 2001 edition. A .mp4 file without a brand\n\tis equivalent to a file compatible with this brand*/\n\tGF_ISOM_BRAND_MP41 = GF_4CC( 'm', 'p', '4', '1' ),\n\t/*file complying to ISO/IEC 14496-14 (MP4 spec)*/\n\tGF_ISOM_BRAND_MP42 = GF_4CC( 'm', 'p', '4', '2' ),\n\t/*file complying to ISO/IEC 15444-3 (JPEG2000) without profile restriction*/\n\tGF_ISOM_BRAND_MJP2 = GF_4CC( 'm', 'j', 'p', '2' ),\n\t/*file complying to ISO/IEC 15444-3 (JPEG2000) with simple profile restriction*/\n\tGF_ISOM_BRAND_MJ2S = GF_4CC( 'm', 'j', '2', 's' ),\n\t/*old versions of 3GPP spec (without timed text)*/\n\tGF_ISOM_BRAND_3GP4 = GF_4CC('3', 'g', 'p', '4'),\n\tGF_ISOM_BRAND_3GP5 = GF_4CC('3', 'g', 'p', '5'),\n\t/*final version of 3GPP file spec*/\n\tGF_ISOM_BRAND_3GP6 = GF_4CC('3', 'g', 'p', '6'),\n\t/*generci 3GPP file (several audio tracks, etc..)*/\n\tGF_ISOM_BRAND_3GG5 = GF_4CC('3', 'g', 'g', '5'),\n\tGF_ISOM_BRAND_3GG6 = GF_4CC('3', 'g', 'g', '6'),\n\t/*3GPP2 file spec*/\n\tGF_ISOM_BRAND_3G2A = GF_4CC('3', 'g', '2', 'a'),\n\t/*AVC file spec*/\n\tGF_ISOM_BRAND_AVC1 = GF_4CC('a', 'v', 'c', '1'),\n\t/* file complying to ISO/IEC 21000-9:2005 (MPEG-21 spec)*/\n\tGF_ISOM_BRAND_MP21 = GF_4CC('m', 'p', '2', '1'),\n\t/*file complying to the generic ISO Media File (base specification ISO/IEC 14496-12) + support for version 1*/\n\tGF_ISOM_BRAND_ISO4 =  GF_4CC( 'i', 's', 'o', '4' ),\n\t/* Image File Format */\n\tGF_ISOM_BRAND_HEIF = GF_4CC('h', 'e', 'i', 'f'),\n\tGF_ISOM_BRAND_MIF1 = GF_4CC('m', 'i', 'f', '1'),\n\tGF_ISOM_BRAND_HEIC = GF_4CC('h', 'e', 'i', 'c'),\n\tGF_ISOM_BRAND_HEIM = GF_4CC('h', 'e', 'i', 'm'),\n\tGF_ISOM_BRAND_AVIF = GF_4CC('a', 'v', 'i', 'f'),\n\tGF_ISOM_BRAND_AVCI = GF_4CC('a', 'v', 'c', 'i'),\n\tGF_ISOM_BRAND_VVIC = GF_4CC('v', 'v', 'i', 'c'),\n\n\t/*other iso media brands */\n\tGF_ISOM_BRAND_ISO1 = GF_4CC( 'i', 's', 'o', '1' ),\n\tGF_ISOM_BRAND_ISO3 = GF_4CC( 'i', 's', 'o', '3' ),\n\tGF_ISOM_BRAND_ISO5 = GF_4CC( 'i', 's', 'o', '5' ),\n\tGF_ISOM_BRAND_ISO6 = GF_4CC( 'i', 's', 'o', '6' ),\n\tGF_ISOM_BRAND_ISO7 = GF_4CC( 'i', 's', 'o', '7' ),\n\tGF_ISOM_BRAND_ISO8 = GF_4CC( 'i', 's', 'o', '8' ),\n\tGF_ISOM_BRAND_ISO9 = GF_4CC( 'i', 's', 'o', '9' ),\n\tGF_ISOM_BRAND_ISOA = GF_4CC( 'i', 's', 'o', 'a' ),\n\n\t/* QT brand*/\n\tGF_ISOM_BRAND_QT  = GF_4CC( 'q', 't', ' ', ' ' ),\n\n\t/* JPEG 2000 Image (.JP2) [ISO 15444-1] */\n\tGF_ISOM_BRAND_JP2  = GF_4CC( 'j', 'p', '2', ' ' ),\n\n\t/* MPEG-4 (.MP4) for SonyPSP */\n\tGF_ISOM_BRAND_MSNV = GF_4CC( 'M', 'S', 'N', 'V' ),\n\t/* Apple iTunes AAC-LC (.M4A) Audio */\n\tGF_ISOM_BRAND_M4A  = GF_4CC( 'M', '4', 'A', ' ' ),\n\t/* Apple iTunes Video (.M4V) Video */\n\tGF_ISOM_BRAND_M4V  = GF_4CC( 'M', '4', 'V', ' ' ),\n\n\tGF_ISOM_BRAND_HVCE = GF_4CC( 'h', 'v', 'c', 'e' ),\n\tGF_ISOM_BRAND_HVCI = GF_4CC( 'h', 'v', 'c', 'i' ),\n\tGF_ISOM_BRAND_HVTI = GF_4CC( 'h', 'v', 't', 'i' ),\n\n\n\tGF_ISOM_BRAND_AV01 = GF_4CC( 'a', 'v', '0', '1'),\n\n\tGF_ISOM_BRAND_OPUS = GF_4CC( 'O', 'p', 'u', 's'),\n\n\tGF_ISOM_BRAND_ISMA = GF_4CC( 'I', 'S', 'M', 'A' ),\n\n\t/* dash related brands (ISO/IEC 23009-1) */\n\tGF_ISOM_BRAND_DASH = GF_4CC('d','a','s','h'),\n\t/* Media Segment conforming to the DASH Self-Initializing Media Segment format type */\n\tGF_ISOM_BRAND_DSMS = GF_4CC('d','s','m','s'),\n\t/* Media Segment conforming to the general format type */\n\tGF_ISOM_BRAND_MSDH = GF_4CC('m','s','d','h'),\n\t/* Media Segment conforming to the Indexed Media Segment format type */\n\tGF_ISOM_BRAND_MSIX = GF_4CC('m','s','i','x'),\n\t/* Representation Index Segment used to index MPEG-2 TS based Media Segments */\n\tGF_ISOM_BRAND_RISX = GF_4CC('r','i','s','x'),\n\t/* last Media Segment indicator for ISO base media file format */\n\tGF_ISOM_BRAND_LMSG = GF_4CC('l','m','s','g'),\n\t/* Single Index Segment used to index MPEG-2 TS based Media Segments */\n\tGF_ISOM_BRAND_SISX = GF_4CC('s','i','s','x'),\n\t/* Subsegment Index Segment used to index MPEG-2 TS based Media Segments */\n\tGF_ISOM_BRAND_SSSS = GF_4CC('s','s','s','s'),\n\n\t/* CMAF brand */\n\tGF_ISOM_BRAND_CMFC = GF_4CC('c','m','f','c'),\n\t/* CMAF brand with neg ctts */\n\tGF_ISOM_BRAND_CMF2 = GF_4CC('c','m','f','2'),\n\n\t/* from ismacryp.c */\n\t/* OMA DCF DRM Format 2.0 (OMA-TS-DRM-DCF-V2_0-20060303-A) */\n\tGF_ISOM_BRAND_ODCF = GF_4CC('o','d','c','f'),\n\t/* OMA PDCF DRM Format 2.1 (OMA-TS-DRM-DCF-V2_1-20070724-C) */\n\tGF_ISOM_BRAND_OPF2 = GF_4CC('o','p','f','2'),\n\n\t/* compressed brand*/\n\tGF_ISOM_BRAND_COMP  = GF_4CC( 'c', 'o', 'm', 'p' ),\n\tGF_ISOM_BRAND_ISOC  = GF_4CC( 'i', 's', 'o', 'C' ),\n\n};\n\n/*! sample roll information type*/\ntypedef enum\n{\n\t/*! no roll info associated*/\n\tGF_ISOM_SAMPLE_ROLL_NONE=0,\n\t/*! roll info describes a roll operation*/\n\tGF_ISOM_SAMPLE_ROLL,\n\t/*! roll info describes an audio preroll*/\n\tGF_ISOM_SAMPLE_PREROLL,\n\t/*! roll info describes audio preroll but is not set for this sample*/\n\tGF_ISOM_SAMPLE_PREROLL_NONE\n} GF_ISOSampleRollType;\n\n#ifndef GPAC_DISABLE_ISOM\n\n#include <gpac/mpeg4_odf.h>\n\n/*! isomedia file*/\ntypedef struct __tag_isom GF_ISOFile;\n\n/*! a track ID value - just a 32 bit value but typedefed for API safety*/\ntypedef u32 GF_ISOTrackID;\n\n/*! @} */\n\n/*!\n\\addtogroup isosample_grp ISO Sample\n\\ingroup iso_grp\n\nMedia sample for ISOBMFF API.\n@{\n*/\n\n/*! Random Access Point flag*/\ntypedef enum {\n\t/*! redundant sync shadow - only set when reading sample*/\n\tRAP_REDUNDANT = -1,\n\t/*! not rap*/\n\tRAP_NO = 0,\n\t/*! sync point (IDR)*/\n\tRAP = 1,\n\t/*! sync point (IDR)*/\n\tSAP_TYPE_1 = 1,\n\t/*! sync point (IDR)*/\n\tSAP_TYPE_2 = 2,\n\t/*! RAP, OpenGOP*/\n\tSAP_TYPE_3 = 3,\n\t/*! RAP, roll info (GDR or audio preroll)*/\n\tSAP_TYPE_4 = 4,\n} GF_ISOSAPType;\n\n/*! media sample object*/\ntypedef struct\n{\n\t/*! data size*/\n\tu32 dataLength;\n\t/*! data with padding if requested*/\n\tu8 *data;\n\t/*! decoding time*/\n\tu64 DTS;\n\t/*! relative offset for composition if needed*/\n\ts32 CTS_Offset;\n\t/*! SAP type*/\n\tGF_ISOSAPType IsRAP;\n\t/*! allocated data size - used only when using static sample in \\ref gf_isom_get_sample_ex*/\n\tu32 alloc_size;\n\t\n\t/*! number of packed samples in this sample. If 0 or 1, only 1 sample is present\n\tonly used for constant size and constant duration samples*/\n\tu32 nb_pack;\n\n\t/*! read API only - sample duration (multiply by nb_pack to get full duration)*/\n\tu32 duration;\n} GF_ISOSample;\n\n\n/*! creates a new empty sample\n\\return the newly allocated ISO sample*/\nGF_ISOSample *gf_isom_sample_new();\n\n/*! delete a sample.\n\\note The buffer content will be destroyed by default. If you wish to keep the buffer, set dataLength to 0 in the sample before deleting it\nthe pointer is set to NULL after deletion\n\\param samp pointer to the target ISO sample\n*/\nvoid gf_isom_sample_del(GF_ISOSample **samp);\n\n\n/*! @} */\n\n/*!\n\\addtogroup isogen_grp Generic API\n\\ingroup iso_grp\n\nGeneric API functions\n@{\n*/\n\n/*! Movie file opening modes */\ntypedef enum\n{\n\t/*! Opens file for dumping: same as read-only but keeps all movie fragments info untouched*/\n\tGF_ISOM_OPEN_READ_DUMP = 0,\n\t/*! Opens a file in READ ONLY mode*/\n\tGF_ISOM_OPEN_READ,\n\t/*! Opens a file in WRITE ONLY mode. Media Data is captured on the fly and storage mode is always flat (moov at end).\n\tIn this mode, the editing functions are disabled.*/\n\tGF_ISOM_OPEN_WRITE,\n\t/*! Opens an existing file in EDIT mode*/\n\tGF_ISOM_OPEN_EDIT,\n\t/*! Creates a new file in EDIT mode*/\n\tGF_ISOM_WRITE_EDIT,\n\t/*! Opens an existing file and keep fragment information*/\n\tGF_ISOM_OPEN_KEEP_FRAGMENTS,\n\t/*! Opens an existing file in READ ONLY mode but enables most of the file edit functions except fragmentation\n\tSamples may be added to the file in this mode, they will be stored in memory\n\t*/\n\tGF_ISOM_OPEN_READ_EDIT,\n} GF_ISOOpenMode;\n\n/*! indicates if target file is an IsoMedia file\n\\param fileName the target local file name or path to probe, gmem:// or gfio:// resource\n\\return 1 if it is a non-special file, 2 if an init segment, 3 if a media segment, 0 otherwise\n*/\nu32 gf_isom_probe_file(const char *fileName);\n\n/*! indicates if target file is an IsoMedia file\n\\param fileName the target local file name or path to probe, gmem:// or gfio:// resource\n\\param start_range the offset in the file to start probing from\n\\param end_range the offset in the file at which probing shall stop\n\\return 1 if it is a non-special file, 2 if an init segment, 3 if a media segment, 4 if empty or no file, 0 otherwise\n*/\nu32 gf_isom_probe_file_range(const char *fileName, u64 start_range, u64 end_range);\n\n/*! indicates if target file is an IsoMedia file\n\\param inBuf the buffer to probe\n\\param inSize the sizeo of the buffer to probe\n\\returns 1 if it is a non-special file, 2 if an init segment, 3 if a media segment, 0 otherwise (non recognized or too short)\n*/\nu32 gf_isom_probe_data(const u8*inBuf, u32 inSize);\n\n/*! opens an isoMedia File.\nIf fileName is NULL data will be written in memory ; write with gf_isom_write() ; use gf_isom_get_bs() to get the data ; use gf_isom_delete() to delete the internal data.\n\\param fileName name of the file to open, , gmem:// or gfio:// resource. The special name \"_gpac_isobmff_redirect\" is used to indicate that segment shall be written to a memory buffer passed to callback function set through \\ref gf_isom_set_write_callback.\n\\param OpenMode file opening mode\n\\param tmp_dir for the 2 edit modes only, specifies a location for temp file. If NULL, the library will use the default libgpac temporary file management schemes.\n\\return the created ISO file if no error\n*/\nGF_ISOFile *gf_isom_open(const char *fileName, GF_ISOOpenMode OpenMode, const char *tmp_dir);\n\n/*! closes the file, write it if new/edited - equivalent to gf_isom_write()+gf_isom_delete()\n\\param isom_file the target ISO file\n\\return error if any\n*/\nGF_Err gf_isom_close(GF_ISOFile *isom_file);\n\n/*! deletes the movie without saving it\n\\param isom_file the target ISO file\n*/\nvoid gf_isom_delete(GF_ISOFile *isom_file);\n\n/*! gets the last fatal error that occured in the file\nANY FUNCTION OF THIS API WON'T BE PROCESSED IF THE FILE HAS AN ERROR\n\\note Some function may return an error while the movie has no error\nthe last error is a FatalError, and is not always set if a bad\nparam is specified...\n\\param isom_file the target ISO file\n\\return error if any\n*/\nGF_Err gf_isom_last_error(GF_ISOFile *isom_file);\n\n/*! gets the mode of an open file\n\\param isom_file the target ISO file\n\\return open mode of the file\n*/\nu8 gf_isom_get_mode(GF_ISOFile *isom_file);\n\n/*! checks if file is J2K image\n\\param isom_file the target ISO file\n\\return GF_TRUE if file is a j2k image, GF_FALSE otherwise\n*/\nBool gf_isom_is_JPEG2000(GF_ISOFile *isom_file);\n\n\n/*! checks if a given four character code matches a known video handler type (vide, auxv, pict, ...)\n\\param mtype the four character code to check\n\\return GF_TRUE if the type is a video media type*/\nBool gf_isom_is_video_handler_type(u32 mtype);\n\n/*! gets number of implemented boxes in  (including the internal unknown box wrapper).\n\\note There can be several times the same type returned due to variation of the box (versions or flags)\n\\return number of implemented boxes\n*/\nu32 gf_isom_get_num_supported_boxes();\n\n/*! gets four character code of box given its index. Index 0 is GPAC internal unknown box handler\n\\param idx 0-based index of the box\n\\return four character code of the box\n*/\nu32 gf_isom_get_supported_box_type(u32 idx);\n\n#ifndef GPAC_DISABLE_ISOM_DUMP\n\n/*! prints default box syntax of box given its index. Index 0 is GPAC internal unknown box handler\n\\param idx 0-based index of the box\n\\param trace the file object to dump to\n\\return error if any\n*/\nGF_Err gf_isom_dump_supported_box(u32 idx, FILE * trace);\n\n#endif\n\n/*! @} */\n\n/*!\n\\addtogroup isoread_grp ISOBMFF Reading\n\\ingroup iso_grp\n\nISOBMF file reading\n@{\n*/\n\n/*! checks if moov box is before any mdat box\n\\param isom_file the target ISO file\n\\return GF_TRUE if if moov box is before any mdat box, GF_FALSE otherwise\n*/\nBool gf_isom_moov_first(GF_ISOFile *isom_file);\n\n/*! when reading a file, indicates that file data is missing the indicated bytes\n\\param isom_file the target ISO file\n\\param byte_offset number of bytes not present at the beginning of the file\n\\return error if any\n*/\nGF_Err gf_isom_set_byte_offset(GF_ISOFile *isom_file, s64 byte_offset);\n\n\n/*! opens a movie that can be uncomplete in READ_ONLY mode\nto use for http streaming & co\n\nstart_range and end_range restricts the media byte range in the URL (used by DASH)\nif 0 or end_range<=start_range, the entire URL is used when parsing\n\nIf the url indicates a gfio or gmem resource, the file can be played from the associated underlying buffer. For gmem, you must call \\ref gf_isom_refresh_fragmented and gf_isom_set_removed_bytes whenever the underlying buffer is modified.\n\n\\param fileName the name of the local file or cache to open, gmem:// or gfio://\n\\param start_range only loads starting from indicated byte range\n\\param end_range loading stops at indicated byte range\n\\param enable_frag_templates loads fragment and segment boundaries in an internal table\n\\param isom_file pointer set to the opened file if success\n\\param BytesMissing is set to the predicted number of bytes missing for the file to be loaded\nNote that if the file is not optimized for streaming, this number is not accurate\nIf the movie is successfully loaded (isom_file non-NULL), BytesMissing is zero\n\\return error if any\n*/\nGF_Err gf_isom_open_progressive(const char *fileName, u64 start_range, u64 end_range, Bool enable_frag_templates, GF_ISOFile **isom_file, u64 *BytesMissing);\n\n\n/*! same as  \\ref gf_isom_open_progressive but allows fetching the incomplete box type\n\n\\param fileName the name of the local file or cache to open\n\\param start_range only loads starting from indicated byte range\n\\param end_range loading stops at indicated byte range\n\\param enable_frag_templates loads fragment and segment boundaries in an internal table\n\\param isom_file pointer set to the opened file if success\n\\param BytesMissing is set to the predicted number of bytes missing for the file to be loaded\n\\param topBoxType is set to the 4CC of the incomplete top-level box found - may be NULL\nNote that if the file is not optimized for streaming, this number is not accurate\nIf the movie is successfully loaded (isom_file non-NULL), BytesMissing is zero\n\\return error if any\n*/\nGF_Err gf_isom_open_progressive_ex(const char *fileName, u64 start_range, u64 end_range, Bool enable_frag_templates, GF_ISOFile **isom_file, u64 *BytesMissing, u32 *topBoxType);\n\n/*! retrieves number of bytes missing.\nif requesting a sample fails with error GF_ISOM_INCOMPLETE_FILE, use this function\nto get the number of bytes missing to retrieve the sample\n\\param isom_file the target ISO file\n\\param trackNumber the desired track to query\n\\return the number of bytes missing to fetch the sample\n*/\nu64 gf_isom_get_missing_bytes(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! checks if a file has movie info (moov box with tracks & dynamic media). Some files may just use\nthe base IsoMedia structure without \"moov\" container\n\\param isom_file the target ISO file\n\\return GF_TRUE if the file has a movie, GF_FALSE otherwise\n*/\nBool gf_isom_has_movie(GF_ISOFile *isom_file);\n\n/*! gets number of tracks\n\\param isom_file the target ISO file\n\\return the number of tracks in the movie, or -1 if error*/\nu32 gf_isom_get_track_count(GF_ISOFile *isom_file);\n\n/*! gets the movie timescale\n\\param isom_file the target ISO file\n\\return the timescale of the movie, 0 if error*/\nu32 gf_isom_get_timescale(GF_ISOFile *isom_file);\n\n/*! gets the movie duration computed based on media samples and edit lists\n\\param isom_file the target ISO file\n\\return the computed duration of the movie, 0 if error*/\nu64 gf_isom_get_duration(GF_ISOFile *isom_file);\n\n/*! gets the original movie duration as written in the file, regardless of the media data\n\\param isom_file the target ISO file\n\\return the duration of the movie*/\nu64 gf_isom_get_original_duration(GF_ISOFile *isom_file);\n\n/*! time offset since UNIX EPOC for MP4/QT/MJ2K files*/\n#define GF_ISOM_MAC_TIME_OFFSET 2082844800\n\n/*! gets the creation info of the movie\n\\param isom_file the target ISO file\n\\param creationTime set to the creation time of the movie\n\\param modificationTime set to the modification time of the movie\n\\return error if any\n*/\nGF_Err gf_isom_get_creation_time(GF_ISOFile *isom_file, u64 *creationTime, u64 *modificationTime);\n\n\n/*! gets the creation info of the movie\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param creationTime set to the creation time of the movie\n\\param modificationTime set to the modification time of the movie\n\\return error if any\n*/\nGF_Err gf_isom_get_track_creation_time(GF_ISOFile *isom_file, u32 trackNumber, u64 *creationTime, u64 *modificationTime);\n\n/*! gets the ID of a track\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return the trackID of the track, or 0 if error*/\nGF_ISOTrackID gf_isom_get_track_id(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! gets a track number by its ID\n\\param isom_file the target ISO file\n\\param trackID the target track ID\n\\return the track number of the track, or 0 if error*/\nu32 gf_isom_get_track_by_id(GF_ISOFile *isom_file, GF_ISOTrackID trackID);\n\n/*! gets the track original ID (before cloning from another file)\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return the original trackID of the track, or 0 if error*/\nGF_ISOTrackID gf_isom_get_track_original_id(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! gets the enable flag of a track\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return 0: not enabled, 1: enabled, 2: error\n*/\nu8 gf_isom_is_track_enabled(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! gets track flags\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return the track flags\n*/\nu32 gf_isom_get_track_flags(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! gets the track duration - this will try to fix any discrepencies between media duration+edit lists vs track duration\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return the track duration in movie timescale, or 0 if error*/\nu64 gf_isom_get_track_duration(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! gets the unmodified track duration - mus be called before any call to \\ref gf_isom_get_track_duration\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return the track duration in movie timescale, or 0 if error*/\nu64 gf_isom_get_track_duration_orig(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! gets the media type (audio, video, etc) of a track\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return the media type four character code of the media*/\nu32 gf_isom_get_media_type(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! gets media subtype of a sample description entry\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index (1-based)\n\\return the media type four character code of the given sample description*/\nu32 gf_isom_get_media_subtype(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex);\n\n/*! gets the composition time (media time) given the absolute time in the Movie\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param movieTime desired time in movie timescale\n\\param mediaTime is set to 0 if the media is not playing at that time (empty time segment)\n\\return error if any*/\nGF_Err gf_isom_get_media_time(GF_ISOFile *isom_file, u32 trackNumber, u32 movieTime, u64 *mediaTime);\n\n/*! gets the number of sample descriptions in the media - a media can have several stream descriptions (eg different codec configurations, different protetcions, different visual sizes).\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return the number of sample descriptions\n*/\nu32 gf_isom_get_sample_description_count(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! gets the stream description index for a given time in media time\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param for_time the desired time in media timescale\n\\return the sample description index, or 0 if error or if empty*/\nu32 gf_isom_get_sample_description_index(GF_ISOFile *isom_file, u32 trackNumber, u64 for_time);\n\n/*! checks if a sample stream description is self-contained (samples located in the file)\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index (1-based)\n\\return GF_TRUE if samples referring to the given stream description are present in the file, GF_FALSE otherwise*/\nBool gf_isom_is_self_contained(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex);\n\n/*! gets the media duration (without edit) based on sample table\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return the media duration, 0 if no samples\n*/\nu64 gf_isom_get_media_duration(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! gets the original media duration (without edit) as indicated in the file\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return the media duration\n*/\nu64 gf_isom_get_media_original_duration(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! gets the media timescale\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return the timeScale of the media\n*/\nu32 gf_isom_get_media_timescale(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! gets media chunking information for non-fragmented files\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param dur_min set to minimum chunk duration in media timescale (optional, can be NULL)\n\\param dur_avg set to average chunk duration in media timescale (optional, can be NULL)\n\\param dur_max set to maximum chunk duration in media timescale (optional, can be NULL)\n\\param size_min set to smallest chunk size in bytes (optional, can be NULL)\n\\param size_avg set to average chunk size in bytes (optional, can be NULL)\n\\param size_max set to largest chunk size in bytes (optional, can be NULL)\n\\return error if any\n*/\nGF_Err gf_isom_get_chunks_infos(GF_ISOFile *isom_file, u32 trackNumber, u32 *dur_min, u32 *dur_avg, u32 *dur_max, u32 *size_min, u32 *size_avg, u32 *size_max);\n\n/*! gets the handler name. The outName must be:\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param outName set to the handler name (must be non NULL)\n\\return error if any\n*/\nGF_Err gf_isom_get_handler_name(GF_ISOFile *isom_file, u32 trackNumber, const char **outName);\n\n/*! checks if the data reference for the given track and sample description is valid and supported\n(a data Reference allows to construct a file without integrating the media data, however this library only handles local storage external data references)\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index (1-based)\n\\return error if any\n*/\nGF_Err gf_isom_check_data_reference(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex);\n\n/*! gets the location of the data. If both outURL and outURN are set to NULL, the data is in this file\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index (1-based)\n\\param outURL set to URL value of the data reference\n\\param outURN set to URN value of the data reference\n\\return error if any\n*/\nGF_Err gf_isom_get_data_reference(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, const char **outURL, const char **outURN);\n\n/*! gets the number of samples in a track\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return the number of samples, or 0 if error*/\nu32 gf_isom_get_sample_count(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! gets the constant sample size for samples of a track\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return constant size of samples or 0 if size not constant\n*/\nu32 gf_isom_get_constant_sample_size(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! gets the constant sample duration for samples of a track\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return constant duration of samples, or 0 if duration not constant*/\nu32 gf_isom_get_constant_sample_duration(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! sets max audio sample packing in a single ISOSample.\nThis is mostly used when processing raw audio tracks, for which extracting samples per samples would be too time consuming\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param pack_num_samples the target number of samples to pack in one ISOSample\n\\return GF_TRUE if packing was successfull, GF_FALSE otherwise (non constant size and non constant duration)\n*/\nBool gf_isom_enable_raw_pack(GF_ISOFile *isom_file, u32 trackNumber, u32 pack_num_samples);\n\n/*! gets the total media data size of a track (whether in the file or not)\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return total amount of media bytes in track\n*/\nu64 gf_isom_get_media_data_size(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! sets sample padding bytes when reading a sample\nIt may be desired to fetch samples with a bigger allocated buffer than their real size, in case the decoder\nreads more data than available. This sets the amount of extra bytes to allocate when reading samples from this track\n\\note The dataLength of the sample does NOT include padding\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param padding_bytes the amount of bytes to add at the end of a sample data buffer\n\\return error if any\n*/\nGF_Err gf_isom_set_sample_padding(GF_ISOFile *isom_file, u32 trackNumber, u32 padding_bytes);\n\n/*! fetches a sample from a track. The sample must be destroyed using \\ref gf_isom_sample_del\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleNumber the desired sample number (1-based index)\n\\param sampleDescriptionIndex set to the sample description index corresponding to this sample\n\\return the ISO sample or NULL if not found or end of stream  or incomplete file. Use \\ref gf_isom_last_error to check the error code\n*/\nGF_ISOSample *gf_isom_get_sample(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleNumber, u32 *sampleDescriptionIndex);\n\n/*! fetches a sample from a track without allocating a new sample.\nThis function is the same as \\ref gf_isom_get_sample except that it fills in the static_sample passed as argument, potentially reallocating buffers\n\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleNumber the desired sample number (1-based index)\n\\param sampleDescriptionIndex set to the sample description index corresponding to this sample\n\\param static_sample a caller-allocated ISO sample to use as the returned sample\n\\param data_offset set to data offset in file / current bitstream - may be NULL\n\\return the ISO sample or NULL if not found or end of stream or incomplete file. Use \\ref gf_isom_last_error to check the error code\n\\note If the function returns NULL, the static_sample and its associated data are NOT destroyed\n*/\nGF_ISOSample *gf_isom_get_sample_ex(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleNumber, u32 *sampleDescriptionIndex, GF_ISOSample *static_sample, u64 *data_offset);\n\n/*! gets sample information. This is the same as \\ref gf_isom_get_sample but doesn't fetch media data\n\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleNumber the desired sample number (1-based index)\n\\param sampleDescriptionIndex set to the sample description index corresponding to this sample (optional, can be NULL)\n\\param data_offset set to the sample start offset in file (optional, can be NULL)\n\\note When both sampleDescriptionIndex and data_offset are NULL, only DTS, CTS_Offset and RAP indications are retrieved (faster)\n\\return the ISO sample without data or NULL if not found or end of stream  or incomplete file. Use \\ref gf_isom_last_error to check the error code\n*/\nGF_ISOSample *gf_isom_get_sample_info(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleNumber, u32 *sampleDescriptionIndex, u64 *data_offset);\n\n/*! gets sample information with a user-allocated sample. This is the same as \\ref gf_isom_get_sample_info but uses a static allocated sample as input\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleNumber the desired sample number (1-based index)\n\\param sampleDescriptionIndex set to the sample description index corresponding to this sample (optional, can be NULL)\n\\param data_offset set to the sample start offset in file (optional, can be NULL)\n\\note When both sampleDescriptionIndex and data_offset are NULL, only DTS, CTS_Offset and RAP indications are retrieved (faster)\n\\param static_sample a caller-allocated ISO sample to use as the returned sample\n\\return the ISO sample without data or NULL if not found or end of stream  or incomplete file. Use \\ref gf_isom_last_error to check the error code\n\\note If the function returns NULL, the static_sample and its associated data if any are NOT destroyed\n*/\nGF_ISOSample *gf_isom_get_sample_info_ex(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleNumber, u32 *sampleDescriptionIndex, u64 *data_offset, GF_ISOSample *static_sample);\n\n/*! get sample decoding time\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleNumber the desired sample number (1-based index)\n\\return decoding time in media timescale\n*/\nu64 gf_isom_get_sample_dts(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleNumber);\n\n/*! gets sample duration\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleNumber the desired sample number (1-based index)\n\\return sample duration in media timescale*/\nu32 gf_isom_get_sample_duration(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleNumber);\n\n/*! gets sample size\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleNumber the desired sample number (1-based index)\n\\return sample size in bytes*/\nu32 gf_isom_get_sample_size(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleNumber);\n\n/*! gets maximum sample size in track\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return max size of any sample in track*/\nu32 gf_isom_get_max_sample_size(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! gets average sample size in a track\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return average size of sample in track\n*/\nu32 gf_isom_get_avg_sample_size(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! gets maximum sample duration in track\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return max sample delta in media timescale\n*/\nu32 gf_isom_get_max_sample_delta(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! gets average sample duration in track, i.e. the sample delta occuring most often\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return average  sample delta in media timescale\n*/\nu32 gf_isom_get_avg_sample_delta(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! gets max sample CTS offset (CTS-DTS) in track\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return max sample cts offset in media timescale*/\nu32 gf_isom_get_max_sample_cts_offset(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! gets sample sync flag. This does not check other sample groups ('rap ' or 'sap ')\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleNumber the desired sample number (1-based index)\n\\return GF_TRUE if sample is sync, GF_FALSE otherwise*/\nBool gf_isom_get_sample_sync(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleNumber);\n\n/*! gets sample dependency flags - see ISO/IEC 14496-12 and \\ref gf_filter_pck_set_dependency_flags\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleNumber the desired sample number (1-based index)\n\\param is_leading set to 1 if sample is a leading picture\n\\param dependsOn set to the depends_on flag\n\\param dependedOn set to the depended_on flag\n\\param redundant set to the redundant flag\n\\return error if any\n*/\nGF_Err gf_isom_get_sample_flags(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleNumber, u32 *is_leading, u32 *dependsOn, u32 *dependedOn, u32 *redundant);\n\n/*! gets a sample given a desired decoding time and set the sampleDescriptionIndex of this sample\n\n\\warning The sample may not be sync even though the sync was requested (depends on the media and the editList)\nthe SampleNum is optional. If non-NULL, will contain the sampleNumber\n\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param desiredTime the desired time in media timescale\n\\param sampleDescriptionIndex set to the sample description index corresponding to this sample (optional, can be NULL)\n\\param SearchMode the search direction mode\n\\param sample set to the fetched sample if any. If NULL, sample is not fetched (optional, can be NULL)\n\\param sample_number set to the fetched sample number if any, set to 0 otherwise (optional, can be NULL)\n\\param data_offset set to the sample start offset in file (optional, can be NULL)\n\n\\return GF_EOS if the desired time exceeds the media duration or error if any\n*/\nGF_Err gf_isom_get_sample_for_media_time(GF_ISOFile *isom_file, u32 trackNumber, u64 desiredTime, u32 *sampleDescriptionIndex, GF_ISOSearchMode SearchMode, GF_ISOSample **sample, u32 *sample_number, u64 *data_offset);\n\n/*! gets sample number for a given decode time\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param dts the desired decode time in media timescale\n\\return the sample number or 0 if not found\n*/\nu32 gf_isom_get_sample_from_dts(GF_ISOFile *isom_file, u32 trackNumber, u64 dts);\n\n\n/*! enumerates the type and references IDs of a track\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param idx 0-based index of reference to query\n\\param referenceType set to the four character code of the reference entry\n\\param referenceCount set to the number of track ID references for  the reference entry\n\\return list of track IDs, NULL if no references - do NOT modify !*/\nconst GF_ISOTrackID *gf_isom_enum_track_references(GF_ISOFile *isom_file, u32 trackNumber, u32 idx, u32 *referenceType, u32 *referenceCount);\n\n/*! get the number of track references of a track for a given ReferenceType\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param referenceType the four character code of the reference to query\n\\return -1 if error or the number of references*/\ns32 gf_isom_get_reference_count(GF_ISOFile *isom_file, u32 trackNumber, u32 referenceType);\n\n/*! get the referenced track number for a track and a given ReferenceType and Index\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param referenceType the four character code of the reference to query\n\\param referenceIndex the 1-based index of the reference to query (see \\ref gf_isom_get_reference_count)\n\\param refTrack set to the track number of the referenced track\n\\return error if any\n*/\nGF_Err gf_isom_get_reference(GF_ISOFile *isom_file, u32 trackNumber, u32 referenceType, u32 referenceIndex, u32 *refTrack);\n\n/*! get the referenced track ID for a track and a given ReferenceType and Index\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param referenceType the four character code of the reference to query\n\\param referenceIndex the 1-based index of the reference to query (see \\ref gf_isom_get_reference_count)\n\\param refTrackID set to the track ID of the referenced track\n\\return error if any\n*/\nGF_Err gf_isom_get_reference_ID(GF_ISOFile *isom_file, u32 trackNumber, u32 referenceType, u32 referenceIndex, GF_ISOTrackID *refTrackID);\n\n/*! checks if a track has a reference of given type to another track\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param referenceType the four character code of the reference to query\n\\param refTrackID set to the track number of the referenced track\n\\return the reference index if the given track has a reference of type referenceType to refTreckID, 0 otherwise*/\nu32 gf_isom_has_track_reference(GF_ISOFile *isom_file, u32 trackNumber, u32 referenceType, GF_ISOTrackID refTrackID);\n\n/*! checks if a track is referenced by another track wuth the given reference type\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param referenceType the four character code of the reference to query\n\\return the track number of the first track  referencing the target track, 0 otherwise*/\nu32 gf_isom_is_track_referenced(GF_ISOFile *movie, u32 trackNumber, u32 referenceType);\n\n/*! fetches a sample for a given movie time, handling possible track edit lists.\n\nif no sample is playing, an empty sample is returned with no data and a DTS set to MovieTime when searching in sync modes\nif no sample is playing, the closest sample in the edit time-line is returned when searching in regular modes\n\n\\warning The sample may not be sync even though the sync was requested (depends on the media and the editList)\n\n\\note This function will handle re-timestamping the sample according to the mapping  of the media time-line\non the track time-line. The sample TSs (DTS / CTS offset) are expressed in MEDIA TIME SCALE\n(to match the media stream TS resolution as indicated in media header / SLConfig)\n\n\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param movieTime the desired movie time in media timescale\n\\param sampleDescriptionIndex set to the sample description index corresponding to this sample (optional, can be NULL)\n\\param SearchMode the search direction mode\n\\param sample set to the fetched sample if any. If NULL, sample is not fetched (optional, can be NULL)\n\\param sample_number set to the fetched sample number if any, set to 0 otherwise (optional, can be NULL)\n\\param data_offset set to the sample start offset in file (optional, can be NULL)\n\\return error if any\n*/\nGF_Err gf_isom_get_sample_for_movie_time(GF_ISOFile *isom_file, u32 trackNumber, u64 movieTime, u32 *sampleDescriptionIndex, GF_ISOSearchMode SearchMode, GF_ISOSample **sample, u32 *sample_number, u64 *data_offset);\n\n/*! gets edit list type\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param mediaOffset set to the media offset of the edit for time-shifting edits\n\\return GF_TRUE if complex edit list, GF_FALSE if no edit list or time-shifting only edit list, in which case mediaOffset is set to the CTS of the first sample to present at presentation time 0\nA negative value implies that the samples with CTS between 0 and mediaOffset should not be presented (skip)\nA positive value value implies that there is nothing to present between 0 and CTS (hold)\n*/\nBool gf_isom_get_edit_list_type(GF_ISOFile *isom_file, u32 trackNumber, s64 *mediaOffset);\n\n/*! gets the number of edits in an edit list\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return number of edits\n*/\nu32 gf_isom_get_edits_count(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! gets the desired edit information\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param EditIndex index of the edit to query (1-based index)\n\\param EditTime set to the edit time in movie timescale\n\\param SegmentDuration set to the edit duration in movie timescale\n\\param MediaTime set to the edit media start time in media timescale\n\\param EditMode set to the mode of the edit\n\\return error if any\n*/\nGF_Err gf_isom_get_edit(GF_ISOFile *isom_file, u32 trackNumber, u32 EditIndex, u64 *EditTime, u64 *SegmentDuration, u64 *MediaTime, GF_ISOEditType *EditMode);\n\n/*! gets the number of languages for the copyright\n\\param isom_file the target ISO file\n\\return number of languages, 0 if no copyright*/\nu32 gf_isom_get_copyright_count(GF_ISOFile *isom_file);\n\n/*! gets a copyright and its language code\n\\param isom_file the target ISO file\n\\param Index the 1-based index of the copyright notice to query\n\\param threeCharCodes set to the copyright language code\n\\param notice set to the copyright notice\n\\return error if any\n*/\nGF_Err gf_isom_get_copyright(GF_ISOFile *isom_file, u32 Index, const char **threeCharCodes, const char **notice);\n\n/*! gets the number of chapter for movie or track (chapters can be assigned to tracks or to movies)\n\\param isom_file the target ISO file\n\\param trackNumber the target track to queryy. If 0, looks for chapter at the movie level\n\\return number of chapters\n*/\nu32 gf_isom_get_chapter_count(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! gets the given chapter time and name for a movie or track\n\\param isom_file the target ISO file\n\\param trackNumber the target track to queryy. If 0, looks for chapter at the movie level\n\\param Index the index of the ckhapter to queryy\n\\param chapter_time set to chapter start time in milliseconds (optional, may be NULL)\n\\param name set to chapter name (optional, may be NULL)\n\\return error if any\n*/\nGF_Err gf_isom_get_chapter(GF_ISOFile *isom_file, u32 trackNumber, u32 Index, u64 *chapter_time, const char **name);\n\n/*! checks if a media has sync points\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return 0 if the media has no sync point info (eg, all samples are RAPs), 1 if the media has sync points (eg some samples are RAPs),  2 if the media has empty sync point info (no samples are RAPs - this will likely only happen\n\t\t\tin scalable context)\n*/\nu8 gf_isom_has_sync_points(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! gets the number of sync points in a media\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return number of sync points*/\nu32 gf_isom_get_sync_point_count(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! checks if a media track hhas composition time offset\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return 1 if the track uses unsigned compositionTime offsets (B-frames or similar), 2 if the track uses signed compositionTime offsets (B-frames or similar), 0 if the track does not use compositionTime offsets (CTS == DTS)\n*/\nu32 gf_isom_has_time_offset(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! gets cts to dts shift value if defined.\nThis shift is defined only in cases of negative CTS offset (ctts version 1) and not always present in files!\nAdding shift to CTS guarantees that the shifted CTS is always greater than the DTS for any sample\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return the shift from composition time to decode time for that track if indicated, or 0 if not found\n*/\ns64 gf_isom_get_cts_to_dts_shift(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! checks if a track has sync shadow samples (RAP samples replacing non RAP ones)\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return GF_TRUE if the track has sync shadow samples*/\nBool gf_isom_has_sync_shadows(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! checks if a track has sample dependencoes indicated\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return GF_TRUE if the track has sample dep indications*/\nBool gf_isom_has_sample_dependency(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! gets a rough estimation of file size. This only works for completely self-contained files and without fragmentation\nfor the current time\n\\param isom_file the target ISO file\n\\return estimated file size in bytes*/\nu64 gf_isom_estimate_size(GF_ISOFile *isom_file);\n\n/*! gets next alternate group ID available\n\\param isom_file the target ISO file\n\\return next available ID for alternate groups\n*/\nu32 gf_isom_get_next_alternate_group_id(GF_ISOFile *isom_file);\n\n\n/*! gets file name of an opened ISO file\n\\param isom_file the target ISO file\n\\return the file name*/\nconst char *gf_isom_get_filename(GF_ISOFile *isom_file);\n\n\n/*! gets file brand information\nThe brand is used to\n- differenciate MP4, MJPEG2000 and QT while indicating compatibilities\n- identify tools that shall be supported for correct parsing of the file\n\nThe function will set brand, minorVersion and AlternateBrandsCount to 0 if no brand indication is found in the file\n\n\\param isom_file the target ISO file\n\\param brand set to the four character code of the brand\n\\param minorVersion set to an informative integer for the minor version of the major brand (optional, can be NULL)\n\\param AlternateBrandsCount set to the number of compatible brands (optional, can be NULL).\n\\return error if any*/\nGF_Err gf_isom_get_brand_info(GF_ISOFile *isom_file, u32 *brand, u32 *minorVersion, u32 *AlternateBrandsCount);\n\n/*! gets an alternate brand indication\n\\note the Major brand should always be indicated in the alternate brands\n\\param isom_file the target ISO file\n\\param BrandIndex 1-based index of alternate brand to query (cf \\ref gf_isom_get_brand_info)\n\\param brand set to the four character code of the brand\n\\return error if any*/\nGF_Err gf_isom_get_alternate_brand(GF_ISOFile *isom_file, u32 BrandIndex, u32 *brand);\n\n/*! gets the internal list of brands\n\\param isom_file the target ISO file\n\\return the internal list of brands. DO NOT MODIFY the content\n*/\nconst u32 *gf_isom_get_brands(GF_ISOFile *isom_file);\n\n/*! gets the number of padding bits at the end of a given sample if any\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleNumber the desired sample number (1-based index)\n\\param NbBits set to the number of padded bits at the end of the sample\n\\return error if any*/\nGF_Err gf_isom_get_sample_padding_bits(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleNumber, u8 *NbBits);\n\n/*! checks if a track samples use padding bits or not\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return GF_TRUE if samples have padding bits information, GF_FALSE otherwise*/\nBool gf_isom_has_padding_bits(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! gets information of a visual track for a given sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index (1-based)\n\\param Width set to the width of the sample description in pixels\n\\param Height set to the height of the sample description in pixels\n\\return error if any*/\nGF_Err gf_isom_get_visual_info(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, u32 *Width, u32 *Height);\n\n/*! gets bit depth of a sample description of a visual track (for uncompressed media usually)\n\\param isom_file the target ISO file\n\\param trackNumber the target track number\n\\param sampleDescriptionIndex the target sample description index\n\\param bitDepth the bit depth of each pixel (eg 24 for RGB, 32 for RGBA)\n\\return error if any\n*/\nGF_Err gf_isom_get_visual_bit_depth(GF_ISOFile* isom_file, u32 trackNumber, u32 sampleDescriptionIndex, u16 *bitDepth);\n\n/*! gets information of an audio track for a given sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index (1-based)\n\\param SampleRate set to the audio sample rate of the sample description\n\\param Channels set to the audio channel count of the sample description\n\\param bitsPerSample set to the audio bits per sample for raw audio of the sample description\n\\return error if any*/\nGF_Err gf_isom_get_audio_info(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, u32 *SampleRate, u32 *Channels, u32 *bitsPerSample);\n\n/*! Audio channel layout description, ISOBMFF style*/\ntypedef struct\n{\n\t/*! stream structure flags, 1: has channel layout, 2: has objects*/\n\tu8 stream_structure;\n\t/*!  order of formats in the stream : 0 unknown, 1: Channels, possibly followed by Objects, 2 Objects, possibly followed by Channels*/\n\tu8 format_ordering;\n\t/*! combined channel count of the channel layout and the object count*/\n\tu8 base_channel_count;\n\n\t/*! defined CICP channel layout*/\n\tu8 definedLayout;\n\t/*! indicates where the ordering of the audio channels for the definedLayout are specified\n\t0: as listed for the ChannelConfigurations in ISO/IEC 23091-3\n\t1: Default order of audio codec specification\n\t2: Channel ordering #2 of audio codec specification\n\t3: Channel ordering #3 of audio codec specification\n\t4: Channel ordering #4 of audio codec specification\n\t*/\n\tu8 channel_order_definition;\n\t/*! indicates if omittedChannelsMap is present*/\n\tu8 omitted_channels_present;\n\n\t/*! number of channels*/\n\tu32 channels_count;\n\tstruct {\n\t\t/*! speaker position*/\n\t\tu8 position;\n\t\t/*! speaker elevation if position==126*/\n\t\ts8 elevation;\n\t\t/*! speaker azimuth if position==126*/\n\t\ts16 azimuth;\n\t} layouts[64];\n\t/*! bit-map of omitted channels using bit positions defined in CICP - only valid if definedLayout is not 0*/\n\tu64 omittedChannelsMap;\n\t/*! number of objects in the stream*/\n\tu8 object_count;\n} GF_AudioChannelLayout;\n\n/*! get channel layout info for an audio track, ISOBMFF style\n \\param isom_file the target ISO file\n \\param trackNumber the target track\n \\param sampleDescriptionIndex the target sample description index (1-based)\n \\param layout set to the channel/object layout info for this track\n \\return GF_NOT_FOUND if not set in file, or other error if any*/\nGF_Err gf_isom_get_audio_layout(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, GF_AudioChannelLayout *layout);\n\n\n/*! gets visual track layout information\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param width set to the width of the track in pixels\n\\param height set to the height of the track in pixels\n\\param translation_x set to the horizontal translation of the track in pixels\n\\param translation_y set to the vertical translation of the track in pixels\n\\param layer set to the z-order of the track\n\\return error if any*/\nGF_Err gf_isom_get_track_layout_info(GF_ISOFile *isom_file, u32 trackNumber, u32 *width, u32 *height, s32 *translation_x, s32 *translation_y, s16 *layer);\n\n/*! gets matrix of a visual track\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param matrix set to the track matrix - all coord values are expressed as 16.16 fixed point floats\n\\return error if any*/\nGF_Err gf_isom_get_track_matrix(GF_ISOFile *isom_file, u32 trackNumber, u32 matrix[9]);\n\n/*! gets sample (pixel) aspect ratio information of a visual track for a given sample description\nThe aspect ratio is hSpacing divided by vSpacing\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index (1-based)\n\\param hSpacing horizontal spacing\n\\param vSpacing vertical spacing\n\\return error if any*/\nGF_Err gf_isom_get_pixel_aspect_ratio(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, u32 *hSpacing, u32 *vSpacing);\n\n/*! gets color information of a visual track for a given sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index (1-based)\n\\param colour_type set to the four character code of the colour type mode used (nclx, nclc, prof or ricc currently defined)\n\\param colour_primaries set to the colour primaries for nclc/nclx as defined in ISO/IEC 23001-8\n\\param transfer_characteristics set to the colour primaries for nclc/nclx as defined in ISO/IEC 23001-8\n\\param matrix_coefficients set to the colour primaries for nclc/nclx as defined in ISO/IEC 23001-8\n\\param full_range_flag set to the colour primaries for nclc as defined in ISO/IEC 23001-8\n\\return error if any*/\nGF_Err gf_isom_get_color_info(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, u32 *colour_type, u16 *colour_primaries, u16 *transfer_characteristics, u16 *matrix_coefficients, Bool *full_range_flag);\n\n\n/*! gets ICC profile\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index (1-based)\n\\param icc_restricted  set to GF_TRUE of restricted ICC profile, GF_FALSE otherwise\n\\param icc  set to profile data, NULL if none\n\\param icc_size  set to profile size, 0 if none\n\\return error if any*/\nGF_Err gf_isom_get_icc_profile(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, Bool *icc_restricted, const u8 **icc, u32 *icc_size);\n\n/*! gets clean aperture (crop window, see ISO/IEC 14496-12) for a sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track number\n\\param sampleDescriptionIndex the target sample description index\n\\param cleanApertureWidthN set to nominator of clean aperture horizontal size, may be NULL\n\\param cleanApertureWidthD set to denominator of clean aperture horizontal size, may be NULL\n\\param cleanApertureHeightN set to nominator of clean aperture vertical size, may be NULL\n\\param cleanApertureHeightD set to denominator of clean aperture vertical size, may be NULL\n\\param horizOffN set to nominator of horizontal offset of clean aperture center minus (width-1)/2 (eg 0 sets center to center of video), may be NULL\n\\param horizOffD set to denominator of horizontal offset of clean aperture center minus (width-1)/2 (eg 0 sets center to center of video), may be NULL\n\\param vertOffN set to nominator of vertical offset of clean aperture center minus (height-1)/2 (eg 0 sets center to center of video), may be NULL\n\\param vertOffD set to denominator of vertical offset of clean aperture center minus (height-1)/2 (eg 0 sets center to center of video), may be NULL\n\\return error if any\n*/\nGF_Err gf_isom_get_clean_aperture(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, u32 *cleanApertureWidthN, u32 *cleanApertureWidthD, u32 *cleanApertureHeightN, u32 *cleanApertureHeightD, s32 *horizOffN, u32 *horizOffD, s32 *vertOffN, u32 *vertOffD);\n\n/*! content light level info*/\ntypedef struct  {\n\t/*! max content ligth level*/\n\tu16 max_content_light_level;\n\t/*! max picture average ligth level*/\n\tu16 max_pic_average_light_level;\n} GF_ContentLightLevelInfo;\n\n/*! mastering display colour volume info*/\ntypedef struct  {\n\t/*! display primaries*/\n\tstruct {\n\t\tu16 x;\n\t\tu16 y;\n\t} display_primaries[3];\n\t/*! X white point*/\n\tu16 white_point_x;\n\t/*! Y white point*/\n\tu16 white_point_y;\n\tu32 max_display_mastering_luminance;\n\t/*! min display mastering luminance*/\n\tu32 min_display_mastering_luminance;\n} GF_MasteringDisplayColourVolumeInfo;\n\n/*! gets master display colour info if any\n\\param isom_file the target ISO file\n\\param trackNumber the target track number\n\\param sampleDescriptionIndex the target sample description index\n\\return the mdcv info, or NULL if none or not a valid video track\n*/\nconst GF_MasteringDisplayColourVolumeInfo *gf_isom_get_mastering_display_colour_info(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex);\n\n/*! gets content light level info if any\n\\param isom_file the target ISO file\n\\param trackNumber the target track number\n\\param sampleDescriptionIndex the target sample description index\n\\return the clli info, or NULL if none or not a valid video track\n*/\nconst GF_ContentLightLevelInfo *gf_isom_get_content_light_level_info(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex);\n\n\n/*! gets the media language code of a track\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param lang set to a newly allocated string containg 3 chars (if old files) or longer form (BCP-47) - shall be freed by caller\n\\return error if any*/\nGF_Err gf_isom_get_media_language(GF_ISOFile *isom_file, u32 trackNumber, char **lang);\n\n/*! gets the number of kind (media role) for a given track\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return number of kind defined\n*/\nu32 gf_isom_get_track_kind_count(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! gets a given kind (media role) information for a given track\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param index the 1-based index of the kind to retrieve\n\\param scheme set to the scheme of the kind information - shall be freed by caller\n\\param value set to the value of the kind information - shall be freed by caller\n\\return error if any*/\nGF_Err gf_isom_get_track_kind(GF_ISOFile *isom_file, u32 trackNumber, u32 index, char **scheme, char **value);\n\n/*! gets the magic number associated with a track. The magic number is usually set by a file muxer, and is not serialized to file\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return the magic number (0 by default)\n*/\nu64 gf_isom_get_track_magic(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! gets track group ID of a given track group type for this track\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param track_group_type the target track group type\n\\return the track group ID, 0 if not found\n*/\nu32 gf_isom_get_track_group(GF_ISOFile *isom_file, u32 trackNumber, u32 track_group_type);\n\n/*! gets track group ID of a given track group type for this track\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param idx 0-based index of enumeration, incremented by the function if success\n\\param track_group_type set to the track group type - may be NULL\n\\param track_group_id set to the track group ID - may be NULL\n\\return GF_TRUE if success, GF_FALSE otherwise\n*/\nBool gf_isom_enum_track_group(GF_ISOFile *isom_file, u32 trackNumber, u32 *idx, u32 *track_group_type, u32 *track_group_id);\n\n/*! checks if file is a single AV file with max one audio, one video, one text and basic od/bifs\n\\param isom_file the target ISO file\n\\return GF_TRUE if file is single AV, GF_FALSE otherwise\n*/\nBool gf_isom_is_single_av(GF_ISOFile *isom_file);\n\n/*! guesses which specification this file refers to.\n\\param isom_file the target ISO file\n\\return possible values are:\n\tGF_ISOM_BRAND_ISOM: unrecognized std\n\tGF_ISOM_BRAND_3GP5: 3GP file (max 1 audio, 1 video) without text track\n\tGF_ISOM_BRAND_3GP6: 3GP file (max 1 audio, 1 video) with text track\n\tGF_ISOM_BRAND_3GG6: 3GP file multitrack file\n\tGF_ISOM_BRAND_3G2A: 3GP2 file\n\tGF_ISOM_BRAND_AVC1: AVC file\n\tFCC(\"ISMA\"): ISMA file (may overlap with 3GP)\n\tGF_ISOM_BRAND_MP42: any generic MP4 file (eg with BIFS/OD/MPEG-4 systems stuff)\n\n  for files without movie, returns the file meta handler type\n*/\nu32 gf_isom_guess_specification(GF_ISOFile *isom_file);\n\n\n/*! gets the nalu_length_field size used for this sample description if NALU-based (AVC/HEVC/...)\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index (1-based)\n\\return number of bytes used to code the NALU size, or 0 if not NALU-based*/\nu32 gf_isom_get_nalu_length_field(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex);\n\n/*! gets max/average rate information as indicated in ESDS or BTRT boxes. If not found all values are set to 0\nif sampleDescriptionIndex is 0, gather for all sample descriptions\n\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index (1-based)\n\\param average_bitrate set to the average bitrate in bits per second of the media\n\\param max_bitrate set to the maximum bitrate in bits per second of the media\n\\param decode_buffer_size set to the decoder buffer size in bytes of the media\n\\return error if any*/\nGF_Err gf_isom_get_bitrate(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, u32 *average_bitrate, u32 *max_bitrate, u32 *decode_buffer_size);\n\n\n/*! gets the track template of a track. This serializes track box without serializing sample tables nor sample description info\n\\param isom_file the destination ISO file\n\\param trackNumber the destination track\n\\param output will be set to a newly allocated buffer containing the serialized box - caller shall free it\n\\param output_size will be set to the size of the allocated buffer\n\\return error if any\n*/\nGF_Err gf_isom_get_track_template(GF_ISOFile *isom_file, u32 trackNumber, u8 **output, u32 *output_size);\n\n/*! gets the trex template of a track. This serializes trex box\n\\param isom_file the destination ISO file\n\\param trackNumber the destination track\n\\param output will be set to a newly allocated buffer containing the serialized box - caller shall free it\n\\param output_size will be set to the size of the allocated buffer\n\\return error if any\n*/\nGF_Err gf_isom_get_trex_template(GF_ISOFile *isom_file, u32 trackNumber, u8 **output, u32 *output_size);\n\n/*! sets the number of removed bytes form the input bitstream when using gmem:// url\n The number of bytes shall be the total number since the opening of the movie\n\\param isom_file the target ISO file\n\\param bytes_removed number of bytes removed\n\\return error if any\n*/\nGF_Err gf_isom_set_removed_bytes(GF_ISOFile *isom_file, u64 bytes_removed);\n\n/*! gets the current file offset of the current incomplete top level box not parsed\n This shall be checked to avoid discarding bytes at or after the current top box header\n\\param isom_file the target ISO file\n\\param current_top_box_offset set to the offset from file first byte\n\\return error if any\n*/\nGF_Err gf_isom_get_current_top_box_offset(GF_ISOFile *isom_file, u64 *current_top_box_offset);\n\n/*! purges the given number of samples, starting from the first sample, from a track of a fragmented file.\n This avoids having sample tables growing in size when reading a fragmented file in pure streaming mode (no seek).\n You should always keep one sample in the track\n\\param isom_file the target ISO file\n\\param trackNumber the desired track to purge\n\\param nb_samples the number of samples to remove\n\\return error if any\n*/\nGF_Err gf_isom_purge_samples(GF_ISOFile *isom_file, u32 trackNumber, u32 nb_samples);\n\n#ifndef GPAC_DISABLE_ISOM_DUMP\n\n/*! dumps file structures into XML trace file\n\\param isom_file the target ISO file\n\\param trace the file object to dump to\n\\param skip_init does not dump init segment structure\n\\param skip_samples does not dump sample tables\n\\return error if any\n*/\nGF_Err gf_isom_dump(GF_ISOFile *isom_file, FILE *trace, Bool skip_init, Bool skip_samples);\n\n#endif /*GPAC_DISABLE_ISOM_DUMP*/\n\n\n/*! gets number of chunks in track\n\\param isom_file the target ISO file\n\\param trackNumber the desired track to purge\n\\return number of chunks in track\n*/\nu32 gf_isom_get_chunk_count(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! gets info for a given chunk in track\n\\param isom_file the target ISO file\n\\param trackNumber the desired track to purge\n\\param chunkNumber the 1-based index of the desired chunk\n\\param chunk_offset set to the chunk offset in bytes from start of file\n\\param first_sample_num set to the sample number of the first sample in the chunk\n\\param sample_per_chunk set to number of samples per chunk\n\\param sample_desc_idx set to sample desc index of samples of this chunk\n\\param cache_1 updated by function at each call. May be NULL (slower). Must be set to 0 if not querying consecutive chunks\n\\param cache_2 updated by function at each call. May be NULL (slower). Must be set to 0 if not querying consecutive chunks\n\\return error if any\n*/\nGF_Err gf_isom_get_chunk_info(GF_ISOFile *isom_file, u32 trackNumber, u32 chunkNumber, u64 *chunk_offset, u32 *first_sample_num, u32 *sample_per_chunk, u32 *sample_desc_idx, u32 *cache_1, u32 *cache_2);\n\n\n/*! gets the file offset of the first usable byte of the first mdat box in the file\n\\param isom_file the target ISO file\n\\return byte offset\n*/\nu64 gf_isom_get_first_mdat_start(GF_ISOFile *isom_file);\n\n/*! gets the size of all skip, free and wide boxes present in the file and bytes skipped during parsing (assumes a single file was opened)\n\\param isom_file the target ISO file\n\\return size\n*/\nu64 gf_isom_get_unused_box_bytes(GF_ISOFile *isom_file);\n\n/*! @} */\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n/*!\n\\addtogroup isowrite_grp ISOBMFF Writing\n\\ingroup iso_grp\n\nISOBMF file writing\n@{\n*/\n\n/*! Movie Storage modes*/\ntypedef enum\n{\n\t/*! FLAT: the MediaData is stored at the beginning of the file*/\n\tGF_ISOM_STORE_FLAT = 1,\n\t/*! STREAMABLE: the MetaData (File Info) is stored at the beginning of the file\n\tfor fast access during download*/\n\tGF_ISOM_STORE_STREAMABLE,\n\t/*! INTERLEAVED: Same as STREAMABLE, plus the media data is mixed by chunk  of fixed duration*/\n\tGF_ISOM_STORE_INTERLEAVED,\n\t/*! INTERLEAVED +DRIFT: Same as INTERLEAVED, and adds time drift control to avoid creating too long chunks*/\n\tGF_ISOM_STORE_DRIFT_INTERLEAVED,\n\t/*! tightly interleaves samples based on their DTS, therefore allowing better placement of samples in the file.\n\tThis is used for both http interleaving and Hinting optimizations*/\n\tGF_ISOM_STORE_TIGHT,\n\t/*! FASTSTART: same as FLAT but moves moov before mdat at the end*/\n\tGF_ISOM_STORE_FASTSTART,\n} GF_ISOStorageMode;\n\n/*! writes the file without deleting (see \\ref gf_isom_delete)\n\\param isom_file the target ISO file\n\\return error if any\n*/\nGF_Err gf_isom_write(GF_ISOFile *isom_file);\n\n/*! freezes order of the current box tree in the file.\nBy default the library always reorder boxes in the recommended order in the various specifications implemented.\nNew created tracks or meta items will not have a frozen order of boxes, but the function can be called several time\n\\param isom_file the target ISO file\n\\return error if any\n*/\nGF_Err gf_isom_freeze_order(GF_ISOFile *isom_file);\n\n/*! keeps UTC edit times when storing\n\\param isom_file the target ISO file\n\\param keep_utc if GF_TRUE, do not edit times\n*/\nvoid gf_isom_keep_utc_times(GF_ISOFile *isom_file, Bool keep_utc);\n\n#endif\n\n/*! Checks if UTC keeping is enabled\n\\param isom_file the target ISO file\n\\return GF_TRUE if UTC keeping is enabled\n*/\nBool gf_isom_has_keep_utc_times(GF_ISOFile *isom_file);\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n/*! sets the timescale of the movie. This rescales times expressed in movie timescale in edit lists and mvex boxes\n\\param isom_file the target ISO file\n\\param timeScale the target timescale\n\\return error if any\n*/\nGF_Err gf_isom_set_timescale(GF_ISOFile *isom_file, u32 timeScale);\n\n/*! loads a set of top-level boxes in moov udta and child boxes. UDTA will be replaced if already present\n\\param isom_file the target ISO file\n\\param moov_boxes a serialized array of boxes to add\n\\param moov_boxes_size the size of the serialized array of boxes\n\\param udta_only only replace/inject udta box and entries\n\\return error if any\n*/\nGF_Err gf_isom_load_extra_boxes(GF_ISOFile *isom_file, u8 *moov_boxes, u32 moov_boxes_size, Bool udta_only);\n\n/*! creates a new track\n\\param isom_file the target ISO file\n\\param trackID the ID of the track - if 0, the track ID is chosen by the API\n\\param MediaType the handler type (four character code) of the media\n\\param TimeScale the time scale of the media\n\\return the track number or 0 if error*/\nu32 gf_isom_new_track(GF_ISOFile *isom_file, GF_ISOTrackID trackID, u32 MediaType, u32 TimeScale);\n\n/*! creates a new track from an encoded trak box.\n\\param isom_file the target ISO file\n\\param trackID the ID of the track - if 0, the track ID is chosen by the API\n\\param MediaType the handler type (four character code) of the media\n\\param TimeScale the time scale of the media\n\\param tk_box a serialized trak box to use as template\n\\param tk_box_size the size of the serialized trak box\n\\param udta_only only replace/inject udta box and entries\n\\return the track number or 0 if error*/\nu32 gf_isom_new_track_from_template(GF_ISOFile *isom_file, GF_ISOTrackID trackID, u32 MediaType, u32 TimeScale, u8 *tk_box, u32 tk_box_size, Bool udta_only);\n\n/*! removes a track - internal cross dependencies will be updated.\n\\warning Any OD streams with references to this track through  ODUpdate, ESDUpdate, ESDRemove commands\nwill be rewritten\n\\param isom_file the target ISO file\n\\param trackNumber the target track to remove file\n\\return error if any\n*/\nGF_Err gf_isom_remove_track(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! sets the enable flag of a track\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param enableTrack if GF_TRUE, track is enabled, otherwise disabled\n\\return error if any\n*/\nGF_Err gf_isom_set_track_enabled(GF_ISOFile *isom_file, u32 trackNumber, Bool enableTrack);\n\n/*! Track header flags operation type*/\ntypedef enum\n{\n\t/*! set flags, erasing previous value*/\n\tGF_ISOM_TKFLAGS_SET = 1,\n\t/*! add flags*/\n\tGF_ISOM_TKFLAGS_REM,\n\t/*! remove flags*/\n\tGF_ISOM_TKFLAGS_ADD,\n} GF_ISOMTrackFlagOp;\n\n#endif //GPAC_DISABLE_ISOM_WRITE\n\n/*! Track header flags*/\nenum\n{\n\t/*! track is enabled */\n\tGF_ISOM_TK_ENABLED = 1,\n\t/*! track is in regular presentation*/\n\tGF_ISOM_TK_IN_MOVIE = 1<<1,\n\t/*! track is in preview*/\n\tGF_ISOM_TK_IN_PREVIEW = 1<<2,\n\t/*! track size is an aspect ratio indicator only*/\n\tGF_ISOM_TK_SIZE_IS_AR = 1<<3\n};\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n/*! toggles track flags on or off\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param flags flags to modify\n\\param op flag operation mode\n\\return error if any\n*/\nGF_Err gf_isom_set_track_flags(GF_ISOFile *isom_file, u32 trackNumber, u32 flags, GF_ISOMTrackFlagOp op);\n\n/*! sets creationTime and modificationTime of the movie to the specified dates (no validty check)\n\\param isom_file the target ISO file\n\\param create_time the new creation time\n\\param modif_time the new modification time\n\\return error if any\n*/\nGF_Err gf_isom_set_creation_time(GF_ISOFile *isom_file, u64 create_time, u64 modif_time);\n\n/*! sets creationTime and modificationTime of the track to the specified dates\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param create_time the new creation time\n\\param modif_time the new modification time\n\\return error if any\n*/\nGF_Err gf_isom_set_track_creation_time(GF_ISOFile *isom_file, u32 trackNumber, u64 create_time, u64 modif_time);\n\n/*! sets creationTime and modificationTime of the track media header to the specified dates\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param create_time the new creation time\n\\param modif_time the new modification time\n\\return error if any\n*/\nGF_Err gf_isom_set_media_creation_time(GF_ISOFile *isom_file, u32 trackNumber, u64 create_time, u64 modif_time);\n\n/*! changes the ID of a track - all track references present in the file are updated\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param trackID the new track ID\n\\return error if trackID is already in used in the file*/\nGF_Err gf_isom_set_track_id(GF_ISOFile *isom_file, u32 trackNumber, GF_ISOTrackID trackID);\n\n/*! forces to rewrite all dependencies when track ID changes. Used to check if track references are broken during import of a single track\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return error if any\n*/\nGF_Err gf_isom_rewrite_track_dependencies(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! adds a sample to a track\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index associated with the sample\n\\param sample the target sample to add\n\\return error if any\n*/\nGF_Err gf_isom_add_sample(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, const GF_ISOSample *sample);\n\n/*! copies all sample dependency, subSample and sample group information from the given sampleNumber in source file to the last added sample in dest file\n\\param dst the destination ISO file\n\\param dst_track the destination track\n\\param src the source ISO file\n\\param src_track the source track\n\\param sampleNumber the source sample number\n\\return error if any\n*/\nGF_Err gf_isom_copy_sample_info(GF_ISOFile *dst, u32 dst_track, GF_ISOFile *src, u32 src_track, u32 sampleNumber);\n\n/*! adds a sync shadow sample to a track.\n- There must be a regular sample with the same DTS.\n- Sync Shadow samples MUST be RAP and can only use the same sample description as the sample they shadow\n- Currently, adding sync shadow must be done in order (no sample insertion)\n\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sample the target shadow sample to add\n\\return error if any\n*/\nGF_Err gf_isom_add_sample_shadow(GF_ISOFile *isom_file, u32 trackNumber, GF_ISOSample *sample);\n\n/*! adds data to current sample in the track. This will update the data size.\nCANNOT be used with OD media type\nThere shall not be any other\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param data the data to append to the sample\n\\param data_size the size of the data to append\n\\return error if any\n*/\nGF_Err gf_isom_append_sample_data(GF_ISOFile *isom_file, u32 trackNumber, u8 *data, u32 data_size);\n\n/*! adds sample references to a track\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index associated with the sample\n\\param sample the target sample to add\n\\param dataOffset is the offset in bytes of the data in the referenced file.\n\\return error if any\n*/\nGF_Err gf_isom_add_sample_reference(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, GF_ISOSample *sample, u64 dataOffset);\n\n/*! sets the duration of the last media sample. If not set, the duration of the last sample is the\nduration of the previous one if any, or media TimeScale (default value). This does not modify the edit list if any,\nyou must modify this using \\ref gf_isom_set_edit\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param duration duration of last sample in media timescale\n\\return error if any\n*/\nGF_Err gf_isom_set_last_sample_duration(GF_ISOFile *isom_file, u32 trackNumber, u32 duration);\n\n/*! sets the duration of the last media sample. If not set, the duration of the last sample is the\nduration of the previous one if any, or media TimeScale (default value). This does not modify the edit list if any,\nyou must modify this using \\ref gf_isom_set_edit.\nIf both dur_num and dur_den are both zero, forces last sample duration to be the same as previous sample\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param dur_num duration num value\n\\param dur_den duration num value\n\\return error if any\n*/\nGF_Err gf_isom_set_last_sample_duration_ex(GF_ISOFile *isom_file, u32 trackNumber, u32 dur_num, u32 dur_den);\n\n/*! patches last stts entry to make sure the cumulated duration equals the given next_dts value - this will overrite timing of all previous samples using an average dur\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param next_dts target decode time of next sample\n\\return error if any\n*/\nGF_Err gf_isom_patch_last_sample_duration(GF_ISOFile *isom_file, u32 trackNumber, u64 next_dts);\n\n/*! adds a track reference to another track\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param referenceType the four character code of the reference\n\\param ReferencedTrackID the ID of the track referred to\n\\return error if any\n*/\nGF_Err gf_isom_set_track_reference(GF_ISOFile *isom_file, u32 trackNumber, u32 referenceType, GF_ISOTrackID ReferencedTrackID);\n\n/*! removes all track references\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return error if any\n*/\nGF_Err gf_isom_remove_track_references(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! removes any track reference poiting to a non-existing track\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return error if any\n*/\nGF_Err gf_isom_purge_track_reference(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! removes all track references of a given type\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param ref_type the reference type to remove\n\\return error if any\n*/\nGF_Err gf_isom_remove_track_reference(GF_ISOFile *isom_file, u32 trackNumber, u32 ref_type);\n\n/*! sets track handler name.\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param nameUTF8 the handler name; either NULL (reset), a UTF-8 formatted string or a UTF8 file resource in the form \"file://path/to/file_utf8\"\n\\return error if any\n*/\nGF_Err gf_isom_set_handler_name(GF_ISOFile *isom_file, u32 trackNumber, const char *nameUTF8);\n\n/*! updates the sample size table - this is needed when using \\ref gf_isom_append_sample_data in case the resulting samples\nare of same sizes (typically in 3GP speech tracks)\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return error if any\n*/\nGF_Err gf_isom_refresh_size_info(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! updates the duration of the movie.This is done automatically when storing the file or editing timesales/edit list, but it is not done when adding samples.\n\\param isom_file the target ISO file\n\\return error if any\n*/\nGF_Err gf_isom_update_duration(GF_ISOFile *isom_file);\n\n\n/*! updates a given sample of the media. This function updates both media data of sample and sample properties (DTS, CTS, SAP type)\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleNumber the number of the sample to update\n\\param sample the new sample\n\\param data_only if set to GF_TRUE, only the sample data is updated, not other info\n\\return error if any\n*/\nGF_Err gf_isom_update_sample(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleNumber, GF_ISOSample *sample, Bool data_only);\n\n/*! updates a sample reference in the media. Note that the sample MUST exists, and that sample->data MUST be NULL and sample->dataLength must be NON NULL.\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleNumber the number of the sample to update\n\\param sample the new sample\n\\param data_offset new offset of sample in referenced file\n\\return error if any\n*/\nGF_Err gf_isom_update_sample_reference(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleNumber, GF_ISOSample *sample, u64 data_offset);\n\n/*! removes a given sample\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleNumber the number of the sample to update\n\\return error if any\n*/\nGF_Err gf_isom_remove_sample(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleNumber);\n\n\n/*! changes media time scale\n\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param new_timescale the new timescale to set\n\\param new_tsinc if not 0, changes sample duration and composition offsets to new_tsinc/new_timescale. If non-constant sample dur is used, uses the samllest sample dur in the track. Otherwise, only changes the timescale\n\\param force_rescale_type type fo rescaling, Ignored if new_tsinc is not 0:\n - if set to 0, rescale timings.\n - if set to 1, only the media timescale is changed but media times are not updated.\n - if set to 2,  media timescale is updated if new_timescale is set, and all sample durations are set to new_tsinc\n\\return GF_EOS if no action taken (same config), or error if any\n*/\nGF_Err gf_isom_set_media_timescale(GF_ISOFile *isom_file, u32 trackNumber, u32 new_timescale, u32 new_tsinc, u32 force_rescale_type);\n\n\n\n/*! adds sample auxiliary data\n\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleNumber the sample number. Must be equal or larger to last auxiliary\n\\param aux_type auxiliary sample data type, shall not be 0\n\\param aux_info auxiliary sample data specific info type, may be 0\n\\param data data to add\n\\param size size of data to add\n\\return error if any\n*/\nGF_Err gf_isom_add_sample_aux_info(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleNumber, u32 aux_type, u32 aux_info, u8 *data, u32 size);\n\n/*! sets the save file name of the (edited) movie.\nIf the movie is edited, the default fileName is the open name suffixed with an internally defined extension \"%p_isotmp\")\"\n\\note you cannot save an edited file under the same name (overwrite not allowed)\nIf the movie is created (WRITE mode), the default filename is $OPEN_NAME\n\n\\param isom_file the target ISO file\n\\param filename the new final filename\n\\return error if any\n*/\nGF_Err gf_isom_set_final_name(GF_ISOFile *isom_file, char *filename);\n\n/*! sets the storage mode of a file (FLAT, STREAMABLE, INTERLEAVED)\n\\param isom_file the target ISO file\n\\param storage_mode the target storage mode\n\\return error if any\n*/\nGF_Err gf_isom_set_storage_mode(GF_ISOFile *isom_file, GF_ISOStorageMode storage_mode);\n\n/*! sets the interleaving time of media data (INTERLEAVED mode only)\n\\param isom_file the target ISO file\n\\param InterleaveTime the target interleaving time in movie timescale\n\\return error if any\n*/\nGF_Err gf_isom_set_interleave_time(GF_ISOFile *isom_file, u32 InterleaveTime);\n\n/*! forces usage of 64 bit chunk offsets\n\\param isom_file the target ISO file\n\\param set_on if GF_TRUE, 64 bit chunk offsets are always used; otherwise, they are used only for large files\n\\return error if any\n*/\nGF_Err gf_isom_force_64bit_chunk_offset(GF_ISOFile *isom_file, Bool set_on);\n\n/*! compression mode of top-level boxes*/\ntypedef enum\n{\n\t/*! no compression is used*/\n\tGF_ISOM_COMP_NONE=0,\n\t/*! only moov box is compressed*/\n\tGF_ISOM_COMP_MOOV,\n\t/*! only moof boxes are compressed*/\n\tGF_ISOM_COMP_MOOF,\n\t/*! only moof and sidx boxes are compressed*/\n\tGF_ISOM_COMP_MOOF_SIDX,\n\t/*! only moof,  sidx and ssix boxes are compressed*/\n\tGF_ISOM_COMP_MOOF_SSIX,\n\t/*! all (moov, moof,  sidx and ssix) boxes are compressed*/\n\tGF_ISOM_COMP_ALL,\n} GF_ISOCompressMode;\n\nenum\n{\n\t/*! forces compressed box even if compress size is larger than uncompressed size*/\n\tGF_ISOM_COMP_FORCE_ALL\t=\t0x01,\n\t/*! wraps ftyp in otyp*/\n\tGF_ISOM_COMP_WRAP_FTYPE\t=\t0x02,\n};\n\n\n/*! sets compression mode of file\n\\param isom_file the target ISO file\n\\param compress_mode the desired compress mode\n\\param compress_flags compress mode flags\n\\return error if any\n*/\nGF_Err gf_isom_enable_compression(GF_ISOFile *isom_file, GF_ISOCompressMode compress_mode, u32 compress_flags);\n\n/*! sets the copyright in one language\n\\param isom_file the target ISO file\n\\param threeCharCode the ISO three character language code for copyright\n\\param notice the copyright notice to add\n\\return error if any\n*/\nGF_Err gf_isom_set_copyright(GF_ISOFile *isom_file, const char *threeCharCode, char *notice);\n\n/*! adds a kind type to a track\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param schemeURI the scheme URI of the added kind\n\\param value the value of the added kind\n\\return error if any\n*/\nGF_Err gf_isom_add_track_kind(GF_ISOFile *isom_file, u32 trackNumber, const char *schemeURI, const char *value);\n\n/*! removes a kind type to the track, all if NULL params\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param schemeURI the scheme URI of the removed kind\n\\param value the value of the removed kind\n\\return error if any\n*/\nGF_Err gf_isom_remove_track_kind(GF_ISOFile *isom_file, u32 trackNumber, const char *schemeURI, const char *value);\n\n/*! changes the handler type of the media\n\\warning This may completely breaks the parsing of the media track\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param new_type the new handler four character type\n\\return error if any\n*/\nGF_Err gf_isom_set_media_type(GF_ISOFile *isom_file, u32 trackNumber, u32 new_type);\n\n/*! changes the type of the sampleDescriptionBox\n\\warning This may completely breaks the parsing of the media track\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\param new_type the new four character code type of the smaple description\n\\return error if any\n*/\nGF_Err gf_isom_set_media_subtype(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, u32 new_type);\n\n/*! sets a track in an alternate group\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param groupId the alternate group ID\n\\return error if any\n*/\nGF_Err gf_isom_set_alternate_group_id(GF_ISOFile *isom_file, u32 trackNumber, u32 groupId);\n\n/*! adds chapter info:\n\n\\param isom_file the target ISO file\n\\param trackNumber the target track. If 0, the chapter info is added to the movie, otherwise to the track\n\\param timestamp the chapter start time in milliseconds. Chapters are added in order to the file. If a chapter with same timestamp\n\tis found, its name is updated but no entry is created.\n\\param name the chapter name. If NULL, defaults to 'Chapter N'\n\\return error if any\n*/\nGF_Err gf_isom_add_chapter(GF_ISOFile *isom_file, u32 trackNumber, u64 timestamp, char *name);\n\n/*! deletes copyright\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param index the 1-based index of the copyright notice to remove, or 0 to remove all chapters\n\\return error if any\n*/\nGF_Err gf_isom_remove_chapter(GF_ISOFile *isom_file, u32 trackNumber, u32 index);\n\n/*! updates or inserts a new edit in the track time line. Edits are used to modify\nthe media normal timing. EditTime and EditDuration are expressed in movie timescale\n\\note If a segment with EditTime already exists, it is erase\n\\note If there is a segment before this new one, its duration is adjust to match EditTime of the new segment\n\\warning The first segment always have an EditTime of 0. You should insert an empty or dwelled segment first\n\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param EditTime the start of the edit in movie timescale\n\\param EditDuration the duration of the edit in movie timecale\n\\param MediaTime the corresponding media time of the start of the edit, in media timescale. -1 for empty edits\n\\param EditMode the edit mode\n\\return error if any, GF_EOS if empty edit was inserted \n*/\nGF_Err gf_isom_set_edit(GF_ISOFile *isom_file, u32 trackNumber, u64 EditTime, u64 EditDuration, u64 MediaTime, GF_ISOEditType EditMode);\n\n\n\n/*! updates or inserts a new edit in the track time line. Edits are used to modify\nthe media normal timing. EditTime and EditDuration are expressed in movie timescale\n\\note If a segment with EditTime already exists, it is erase\n\\note If there is a segment before this new one, its duration is adjust to match EditTime of the new segment\n\\warning The first segment always have an EditTime of 0. You should insert an empty or dwelled segment first\n\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param EditTime the start of the edit in movie timescale\n\\param EditDuration the duration of the edit in movie timecale\n\\param MediaTime the corresponding media time of the start of the edit, in media timescale. -1 for empty edits\n\\param MediaRate a 16.16 rate (0x10000 means normal playback)\n\\return error if any\n*/\nGF_Err gf_isom_set_edit_with_rate(GF_ISOFile *isom_file, u32 trackNumber, u64 EditTime, u64 EditDuration, u64 MediaTime, u32 MediaRate);\n\n\n/*! same as \\ref gf_isom_set_edit except only modifies duration type and mediaType\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param edit_index the 1-based index of the edit to update\n\\param EditDuration duration of the edit in movie timescale\n\\param MediaTime the corresponding media time of the start of the edit, in media timescale. -1 for empty edits\n\\param EditMode the edit mode\n\\return error if any\n*/\nGF_Err gf_isom_modify_edit(GF_ISOFile *isom_file, u32 trackNumber, u32 edit_index, u64 EditDuration, u64 MediaTime, GF_ISOEditType EditMode);\n\n/*! same as \\ref gf_isom_modify_edit except only appends new segment\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param EditDuration duration of the edit in movie timescale\n\\param MediaTime the corresponding media time of the start of the edit, in media timescale. -1 for empty edits\n\\param EditMode the edit mode\n\\return error if any\n*/\nGF_Err gf_isom_append_edit(GF_ISOFile *isom_file, u32 trackNumber, u64 EditDuration, u64 MediaTime, GF_ISOEditType EditMode);\n\n/*! removes all edits in the track\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return error if any\n*/\nGF_Err gf_isom_remove_edits(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! removes the given edit. If this is not the last segment, the next segment duration is updated to maintain a continous timeline\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param edit_index the 1-based index of the edit to update\n\\return error if any\n*/\nGF_Err gf_isom_remove_edit(GF_ISOFile *isom_file, u32 trackNumber, u32 edit_index);\n\n/*! updates edit list after track edition. All edit entries with a duration or media starttime larger than the media duration are clamped to media duration\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return error if any\n*/\nGF_Err gf_isom_update_edit_list_duration(GF_ISOFile *isom_file, u32 trackNumber);\n\n\n/*! remove track, moov or file-level UUID box of matching type\n\\param isom_file the target ISO file\n\\param trackNumber the target track for the UUID box; if 0, removes from movie; if 0xFFFFFFFF, removes from file\n\\param UUID the UUID of the box to remove\n\\return error if any\n*/\nGF_Err gf_isom_remove_uuid(GF_ISOFile *isom_file, u32 trackNumber, bin128 UUID);\n\n/*! adds track, moov or file-level UUID box\n\\param isom_file the target ISO file\n\\param trackNumber the target track for the UUID box; if 0, removes from movie; if 0xFFFFFFFF, removes from file\n\\param UUID the UUID of the box to remove\n\\param data the data to add, may be NULL\n\\param size the size of the data to add, shall be 0 when data is NULL\n\\return error if any\n*/\nGF_Err gf_isom_add_uuid(GF_ISOFile *isom_file, u32 trackNumber, bin128 UUID, const u8 *data, u32 size);\n\n/*! uses a compact track version for sample size. This is not usually recommended\nexcept for speech codecs where the track has a lot of small samples\ncompaction is done automatically while writing based on the track's sample sizes\n\\param isom_file the target ISO file\n\\param trackNumber the target track for the udta box; if 0, add the udta to the movie;\n\\param CompactionOn if set to GF_TRUE, compact size tables are used; otherwise regular size tables are used\n\\return error if any\n*/\nGF_Err gf_isom_use_compact_size(GF_ISOFile *isom_file, u32 trackNumber, Bool CompactionOn);\n\n/*! disabled brand rewrite for file, usually done for temporary import in an existing file\n\\param isom_file the target ISO file\n\\param do_disable if true, brand rewrite is disabled, otherwise enabled\n\\return error if any\n*/\nGF_Err gf_isom_disable_brand_rewrite(GF_ISOFile *isom_file, Bool do_disable);\n\n/*! sets the brand of the movie\n\\note this automatically adds the major brand to the set of alternate brands if not present\n\\param isom_file the target ISO file\n\\param MajorBrand four character code of the major brand to set\n\\param MinorVersion version of the brand\n\\return error if any\n*/\nGF_Err gf_isom_set_brand_info(GF_ISOFile *isom_file, u32 MajorBrand, u32 MinorVersion);\n\n/*! adds or removes an alternate brand for the movie.\n\\note When removing an alternate brand equal to the major brand, the major brand is updated with the first alternate brand remaining, or 'isom' otherwise\n\\param isom_file the target ISO file\n\\param Brand four character code of the brand to add or remove\n\\param AddIt if set to GF_TRUE, the brand is added, otherwise it is removed\n\\return error if any\n*/\nGF_Err gf_isom_modify_alternate_brand(GF_ISOFile *isom_file, u32 Brand, Bool AddIt);\n\n/*! removes all alternate brands except major brand\n\\param isom_file the target ISO file\n\\return error if any\n*/\nGF_Err gf_isom_reset_alt_brands(GF_ISOFile *isom_file);\n\n/*! removes all alternate brands except major brand\n\\param isom_file the target ISO file\n\\param leave_empty if GF_TRUE, does not create a default alternate brand matching the major brand\n\\return error if any\n*/\nGF_Err gf_isom_reset_alt_brands_ex(GF_ISOFile *isom_file, Bool leave_empty);\n\n/*! set sample dependency flags - see ISO/IEC 14496-12 and \\ref gf_filter_pck_set_dependency_flags\n\\param isom_file the target ISO file\n\\param trackNumber the target track number\n\\param sampleNumber the target sample number\n\\param isLeading indicates that the sample is a leading picture\n\\param dependsOn indicates the sample dependency towards other samples\n\\param dependedOn indicates the sample dependency from other samples\n\\param redundant indicates that the sample contains redundant coding\n\\return error if any\n*/\nGF_Err gf_isom_set_sample_flags(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleNumber, u32 isLeading, u32 dependsOn, u32 dependedOn, u32 redundant);\n\n/*! sets size information of a sample description of a visual track\n\\param isom_file the target ISO file\n\\param trackNumber the target track number\n\\param sampleDescriptionIndex the target sample description index\n\\param Width the width in pixels\n\\param Height the height in pixels\n\\return error if any\n*/\nGF_Err gf_isom_set_visual_info(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, u32 Width, u32 Height);\n\n/*! sets bit depth of a sample description of a visual track (for uncompressed media usually)\n\\param isom_file the target ISO file\n\\param trackNumber the target track number\n\\param sampleDescriptionIndex the target sample description index\n\\param bitDepth the bit depth of each pixel (eg 24 for RGB, 32 for RGBA)\n\\return error if any\n*/\nGF_Err gf_isom_set_visual_bit_depth(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, u16 bitDepth);\n\n/*! sets a visual track layout info\n\\param isom_file the target ISO file\n\\param trackNumber the target track number\n\\param width the track width in pixels\n\\param height the track height in pixels\n\\param translation_x the horizontal translation (from the left) of the track in the movie canvas, expressed as 16.16 fixed point float\n\\param translation_y the vertical translation (from the top) of the track in the movie canvas, expressed as 16.16 fixed point float\n\\param layer z order of the track on the canvas\n\\return error if any\n*/\nGF_Err gf_isom_set_track_layout_info(GF_ISOFile *isom_file, u32 trackNumber, u32 width, u32 height, s32 translation_x, s32 translation_y, s16 layer);\n\n/*! sets track matrix\n\\param isom_file the target ISO file\n\\param trackNumber the target track number\n\\param matrix the transformation matrix of the track on the movie canvas; all coeficients are expressed as 16.16 floating points\n\\return error if any\n */\nGF_Err gf_isom_set_track_matrix(GF_ISOFile *isom_file, u32 trackNumber, s32 matrix[9]);\n\n/*! sets the pixel aspect ratio for a sample description\n\\note the aspect ratio is expressed as hSpacing divided by vSpacing; 2:1 means pixel is twice as wide as it is high\n\\param isom_file the target ISO file\n\\param trackNumber the target track number\n\\param sampleDescriptionIndex the target sample description index\n\\param hSpacing horizontal spacing of the aspect ratio; a value of 0 removes PAR; negative value means 1\n\\param vSpacing vertical spacing of the aspect ratio; a value of 0 removes PAR; negative value means 1\n\\param force_par if set, forces PAR to 1:1 when hSpacing=vSpacing; otherwise removes PAR when hSpacing=vSpacing\n\\return error if any\n*/\nGF_Err gf_isom_set_pixel_aspect_ratio(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, s32 hSpacing, s32 vSpacing, Bool force_par);\n\n/*! sets clean aperture (crop window, see ISO/IEC 14496-12) for a sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track number\n\\param sampleDescriptionIndex the target sample description index\n\\param cleanApertureWidthN nominator of clean aperture horizontal size\n\\param cleanApertureWidthD denominator of clean aperture horizontal size\n\\param cleanApertureHeightN nominator of clean aperture vertical size\n\\param cleanApertureHeightD denominator of clean aperture vertical size\n\\param horizOffN nominator of horizontal offset of clean aperture center minus (width-1)/2 (eg 0 sets center to center of video)\n\\param horizOffD denominator of horizontal offset of clean aperture center minus (width-1)/2 (eg 0 sets center to center of video)\n\\param vertOffN nominator of vertical offset of clean aperture center minus (height-1)/2 (eg 0 sets center to center of video)\n\\param vertOffD denominator of vertical offset of clean aperture center minus (height-1)/2 (eg 0 sets center to center of video)\n\\return error if any\n*/\nGF_Err gf_isom_set_clean_aperture(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, u32 cleanApertureWidthN, u32 cleanApertureWidthD, u32 cleanApertureHeightN, u32 cleanApertureHeightD, s32 horizOffN, u32 horizOffD, s32 vertOffN, u32 vertOffD);\n\n/*! updates track aperture information for QT/ProRes\n\\param isom_file the target ISO file\n\\param trackNumber the target track number\n\\param remove if GF_TRUE, remove track aperture information, otherwise updates it\n\\return error if any\n*/\nGF_Err gf_isom_update_aperture_info(GF_ISOFile *isom_file, u32 trackNumber, Bool remove);\n\n\n/*! sets high dynamic range information for a sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track number\n\\param sampleDescriptionIndex the target sample description index\n\\param mdcv the mastering display colour volume to set, if NULL removes the info\n\\param clli the content light level to set, if NULL removes the info\n\\return error if any\n*/\nGF_Err gf_isom_set_high_dynamic_range_info(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, GF_MasteringDisplayColourVolumeInfo *mdcv, GF_ContentLightLevelInfo *clli);\n\n/*! force Dolby Vision profile: mainly used when the bitstream doesn't contain all the necessary information\n\\param isom_file the target ISO file\n\\param trackNumber the target track number\n\\param sampleDescriptionIndex the target sample description index\n\\param dvcc the Dolby Vision configuration\n\\return error if any\n*/\nGF_Err gf_isom_set_dolby_vision_profile(GF_ISOFile* isom_file, u32 trackNumber, u32 sampleDescriptionIndex, GF_DOVIDecoderConfigurationRecord *dvcc);\n\n\n/*! sets image sequence coding constraints (mostly used for HEIF image files)\n\\param isom_file the target ISO file\n\\param trackNumber the target track number\n\\param sampleDescriptionIndex the target sample description index\n\\param remove if set to GF_TRUE, removes coding constraints\n\\param all_ref_pics_intra indicates if all reference pictures are intra frames\n\\param intra_pred_used indicates if intra prediction is used\n\\param max_ref_per_pic indicates the max number of reference images per picture\n\\return error if any\n */\nGF_Err gf_isom_set_image_sequence_coding_constraints(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, Bool remove, Bool all_ref_pics_intra, Bool intra_pred_used, u32 max_ref_per_pic);\n\n/*! sets image sequence alpha flag (mostly used for HEIF image files). The alpha flag indicates the image sequence is an alpha plane\nor has an alpha channel\n\\param isom_file the target ISO file\n\\param trackNumber the target track number\n\\param sampleDescriptionIndex the target sample description index\n\\param remove if set to GF_TRUE, removes coding constraints\n\\return error if any\n*/\nGF_Err gf_isom_set_image_sequence_alpha(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, Bool remove);\n\n/*! sets colour information for a sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track number\n\\param sampleDescriptionIndex the target sample description index\n\\param colour_type the four character code of the colour type to set (nclc, nclx, prof, ricc); if 0, removes all color info\n\\param colour_primaries the colour primaries for nclc/nclx as defined in ISO/IEC 23001-8\n\\param transfer_characteristics the colour primaries for nclc/nclx as defined in ISO/IEC 23001-8\n\\param matrix_coefficients the colour primaries for nclc/nclx as defined in ISO/IEC 23001-8\n\\param full_range_flag the colour primaries for nclc as defined in ISO/IEC 23001-8\n\\param icc_data the icc data pto set for prof and ricc types\n\\param icc_size the size of the icc data\n\\return error if any\n*/\nGF_Err gf_isom_set_visual_color_info(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, u32 colour_type, u16 colour_primaries, u16 transfer_characteristics, u16 matrix_coefficients, Bool full_range_flag, u8 *icc_data, u32 icc_size);\n\n\n/*! Audio Sample Description signaling mode*/\ntypedef enum {\n\t/*! use ISOBMF sample entry v0*/\n\tGF_IMPORT_AUDIO_SAMPLE_ENTRY_NOT_SET = 0,\n\t/*! use ISOBMF sample entry v0*/\n\tGF_IMPORT_AUDIO_SAMPLE_ENTRY_v0_BS,\n\t/*! use ISOBMF sample entry v0 and forces channel count to 2*/\n\tGF_IMPORT_AUDIO_SAMPLE_ENTRY_v0_2,\n\t/*! use ISOBMF sample entry v1*/\n\tGF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_MPEG,\n\t/*! use QTFF sample entry v1*/\n\tGF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_QTFF\n} GF_AudioSampleEntryImportMode;\n\n\n/*! sets audio format  information for a sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track number\n\\param sampleDescriptionIndex the target sample description index\n\\param sampleRate the audio sample rate\n\\param nbChannels the number of audio channels\n\\param bitsPerSample the number of bits per sample, mostly used for raw audio\n\\param asemode type of audio entry signaling desired\n\\return error if any\n*/\nGF_Err gf_isom_set_audio_info(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, u32 sampleRate, u32 nbChannels, u8 bitsPerSample, GF_AudioSampleEntryImportMode asemode);\n\n\n/*! sets audio channel and object layout  information for a sample description, ISOBMFF style\n\\param isom_file the target ISO file\n\\param trackNumber the target track number\n\\param sampleDescriptionIndex the target sample description index\n\\param layout the layout information\n\\return error if any\n*/\nGF_Err gf_isom_set_audio_layout(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, GF_AudioChannelLayout *layout);\n\n/*! sets CTS unpack mode (used for B-frames & like): in unpack mode, each sample uses one entry in CTTS tables\n\n\\param isom_file the target ISO file\n\\param trackNumber the target track number\n\\param unpack if GF_TRUE, sets unpack on, creating a ctts table if none found; if GF_FALSE, sets unpack off and repacks all table info\n\\return error if any\n*/\nGF_Err gf_isom_set_cts_packing(GF_ISOFile *isom_file, u32 trackNumber, Bool unpack);\n\n/*! shifts all CTS with the given offset. This MUST be called in unpack mode only\n\\param isom_file the target ISO file\n\\param trackNumber the target track number\n\\param offset_shift CTS offset shift in media timescale\n\\return error if any\n*/\nGF_Err gf_isom_shift_cts_offset(GF_ISOFile *isom_file, u32 trackNumber, s32 offset_shift);\n\n/*! enables negative composition offset in track\n\\note this will compute the composition to decode time information\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param use_negative_offsets if GF_TRUE, negative offsets are used, otherwise they are disabled\n\\return error if any\n*/\nGF_Err gf_isom_set_composition_offset_mode(GF_ISOFile *isom_file, u32 trackNumber, Bool use_negative_offsets);\n\n/*! enables negative composition offset in track and shift offsets\n\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param ctts_shift shif CTS offsets by the given time in media timescale if positive offsets only are used\n\\return error if any\n*/\nGF_Err gf_isom_set_ctts_v1(GF_ISOFile *isom_file, u32 trackNumber, u32 ctts_shift);\n\n\n/*! sets language for a track\n\\param isom_file the target ISO file\n\\param trackNumber the target track number\n\\param code 3-character code or BCP-47 code media language\n\\return error if any\n*/\nGF_Err gf_isom_set_media_language(GF_ISOFile *isom_file, u32 trackNumber, char *code);\n\n/*! gets the ID of the last created track\n\\param isom_file the target ISO file\n\\return the last created track ID\n*/\nGF_ISOTrackID gf_isom_get_last_created_track_id(GF_ISOFile *isom_file);\n\n/*! applies a box patch to the file. See examples in gpac test suite, media/boxpatch/\n\\param isom_file the target ISO file\n\\param trackID the ID of the track to patch, in case one of the box patch applies to a track\n\\param box_patch_filename the name of the file containing the box patches\n\\param for_fragments indicates if the patch targets movie fragments or regular moov\n\\return error if any\n*/\nGF_Err gf_isom_apply_box_patch(GF_ISOFile *isom_file, GF_ISOTrackID trackID, const char *box_patch_filename, Bool for_fragments);\n\n/*! sets track magic number\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param magic the magic number to set; magic number is not written to file\n\\return error if any\n*/\nGF_Err gf_isom_set_track_magic(GF_ISOFile *isom_file, u32 trackNumber, u64 magic);\n\n/*! sets track index in moov\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param index the 1-based index to set. Tracks will be reordered after this!\n\\param track_num_changed callback function used to notify track changes during the call to this function\n\\param udta opaque user data for the callback function\n\\return error if any\n*/\nGF_Err gf_isom_set_track_index(GF_ISOFile *isom_file, u32 trackNumber, u32 index, void (*track_num_changed)(void *udta, u32 old_track_num, u32 new_track_num), void *udta);\n\n/*! removes a sample description with the given index\n\\warning This does not remove any added samples for that stream description, nor rewrite the sample to chunk and other boxes referencing the sample description index !\n\\param isom_file the target ISO file\n\\param trackNumber the target track number\n\\param sampleDescriptionIndex the target sample description to remove\n\\return error if any\n*/\nGF_Err gf_isom_remove_stream_description(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex);\n\n/*! updates average and max bitrate of a sample description\nif both average_bitrate and max_bitrate are 0, this removes any bitrate information\n\\param isom_file the target ISO file\n\\param trackNumber the target track number\n\\param sampleDescriptionIndex the target sample description\n\\param average_bitrate the average bitrate of the media for that sample description\n\\param max_bitrate the maximum bitrate of the media for that sample description\n\\param decode_buffer_size the decoder buffer size in bytes for that sample description\n\\return error if any\n*/\nGF_Err gf_isom_update_bitrate(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, u32 average_bitrate, u32 max_bitrate, u32 decode_buffer_size);\n\n\n/*! track clone flags*/\ntypedef enum\n{\n\t/*! set this flag to keep data reference entries while cloning track*/\n\tGF_ISOM_CLONE_TRACK_KEEP_DREF = 1,\n\t/*! set this flag to avoid cloning track as a QT track while cloning track*/\n\tGF_ISOM_CLONE_TRACK_NO_QT = 1<<1,\n\t/*! drop track ID while importing*/\n\tGF_ISOM_CLONE_TRACK_DROP_ID = 1<<2,\n\t/*! reset media duration when cloning */\n\tGF_ISOM_CLONE_RESET_DURATION = 1<<3\n} GF_ISOTrackCloneFlags;\n\n/*! clones a track. This clones everything except media data and sample info (DTS, CTS, RAPs, etc...), and also clones sample descriptions\n\\param orig_file the source ISO file\n\\param orig_track the source track\n\\param dest_file the destination ISO file\n\\param flags flags to use during clone\n\\param dest_track set to the track number of cloned track\n\\return error if any\n*/\nGF_Err gf_isom_clone_track(GF_ISOFile *orig_file, u32 orig_track, GF_ISOFile *dest_file, GF_ISOTrackCloneFlags flags, u32 *dest_track);\n\n\n/*! sets the GroupID of a track (only used for optimized interleaving). By setting GroupIDs\nyou can specify the storage order for media data of a group of streams. This is useful\nfor BIFS presentation so that static resources of the scene can be downloaded before BIFS\n\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param GroupID the desired group ID\n\\return error if any\n*/\nGF_Err gf_isom_set_track_interleaving_group(GF_ISOFile *isom_file, u32 trackNumber, u32 GroupID);\n\n/*! sets the priority of a track within a Group (used for optimized interleaving and hinting).\nThis allows tracks to be stored before other within a same group, for instance the\nhint track data can be stored just before the media data, reducing disk seeking\n\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param InversePriority the desired priority. For a same time, within a group of tracks, the track with the lowest InversePriority will\nbe written first\n\\return error if any\n*/\nGF_Err gf_isom_set_track_priority_in_group(GF_ISOFile *isom_file, u32 trackNumber, u32 InversePriority);\n\n/*! sets the maximum chunk size for a track\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param maxChunkSize the maximum chunk size in bytes\n\\return error if any\n*/\nGF_Err gf_isom_hint_max_chunk_size(GF_ISOFile *isom_file, u32 trackNumber, u32 maxChunkSize);\n\n/*! sets the maximum chunk duration for a track\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param maxChunkDur the maximum chunk duration in media timescale\n\\return error if any\n*/\nGF_Err gf_isom_hint_max_chunk_duration(GF_ISOFile *isom_file, u32 trackNumber, u32 maxChunkDur);\n\n/*! sets up interleaving for storage (shortcut for storeage mode + interleave_time)\n\\param isom_file the target ISO file\n\\param TimeInSec the desired interleaving time in seconds\n\\return error if any\n*/\nGF_Err gf_isom_make_interleave(GF_ISOFile *isom_file, Double TimeInSec);\n\n/*! sets up interleaving for storage (shortcut for storeage mode + interleave_time)\n\\param isom_file the target ISO file\n\\param fTimeInSec the desired interleaving time in seconds, as a fraction\n\\return error if any\n*/\nGF_Err gf_isom_make_interleave_ex(GF_ISOFile *isom_file, GF_Fraction *fTimeInSec);\n\n/*! sets progress callback when writing a file\n\\param isom_file the target ISO file\n\\param progress_cbk the progress callback function\n\\param progress_cbk_udta opaque data passed to the progress callback function\n*/\nvoid gf_isom_set_progress_callback(GF_ISOFile *isom_file, void (*progress_cbk)(void *udta, u64 nb_done, u64 nb_total), void *progress_cbk_udta);\n\n/*! sets write callback functions for in-memory file writing\n\\param isom_file the target ISO file\n\\param on_block_out the block write callback function\n\\param on_block_patch the block patch callback function\n\\param on_last_block_start called before writing the last block of a sequence of movie fragments\n\\param usr_data opaque user data passed to callback functions\n\\param block_size desired block size in bytes\n\\return error if any\n*/\nGF_Err gf_isom_set_write_callback(GF_ISOFile *isom_file,\n\t\t\tGF_Err (*on_block_out)(void *cbk, u8 *data, u32 block_size, void *cbk_data, u32 cbk_magic),\n\t\t\tGF_Err (*on_block_patch)(void *usr_data, u8 *block, u32 block_size, u64 block_offset, Bool is_insert),\n \t\t\tvoid (*on_last_block_start)(void *cbk),\n \t\t\tvoid *usr_data,\n \t\t\tu32 block_size);\n\n/*! checks if file will use in-place rewriting or not\n\\param isom_file the target ISO file\n\\return GF_TRUE if in-place rewrite is used, GF_FALSE otherwise\n*/\nBool gf_isom_is_inplace_rewrite(GF_ISOFile *isom_file);\n\n/*! Disables inplace rewrite. Once in-place rewrite  is disabled, the file can no longer be rewrittten in place.\n\n In-place rewriting allows editing the file structure (ftyp, moov and meta boxes) without modifying the media data size.\n\n In-place rewriting is disabled for any of the following:\n - specifying a storage mode using  \\ref gf_isom_set_storage_mode\n - removing or adding tracks or items\n - removing, adding or updating samples\n - using stdout, redirect file \"_gpac_isobmff_redirect\",  memory file \" gmem://\"\n\nIn-place rewriting is enabled by default on files open in edit mode.\n\n\\param isom_file the target ISO file\n*/\nvoid gf_isom_disable_inplace_rewrite(GF_ISOFile *isom_file);\n\n/*! sets amount of bytes to reserve after moov for future in-place editing. This may be ignored depending on the final write mode\n\\param isom_file the target ISO file\n\\param padding amount of bytes to reserve\n\\return error if any\n*/\nGF_Err gf_isom_set_inplace_padding(GF_ISOFile *isom_file, u32 padding);\n\n/*! @} */\n\n#endif // GPAC_DISABLE_ISOM_WRITE\n\n/*!\n\\addtogroup isomp4sys_grp ISOBMFF MPEG-4 Systems\n\\ingroup iso_grp\n\nMPEG-4 Systems extensions\n@{\n*/\n\n\n/*! MPEG-4 ProfileAndLevel codes*/\ntypedef enum\n{\n\t/*! Audio PL*/\n\tGF_ISOM_PL_AUDIO,\n\t/*! Visual PL*/\n\tGF_ISOM_PL_VISUAL,\n\t/*! Graphics PL*/\n\tGF_ISOM_PL_GRAPHICS,\n\t/*! Scene PL*/\n\tGF_ISOM_PL_SCENE,\n\t/*! OD PL*/\n\tGF_ISOM_PL_OD,\n\t/*! MPEG-J PL*/\n\tGF_ISOM_PL_MPEGJ,\n\t/*! not a profile, just set/unset inlineFlag*/\n\tGF_ISOM_PL_INLINE,\n} GF_ISOProfileLevelType;\n\n/*! gets MPEG-4 subtype of a sample description entry (eg, mp4a, mp4v, enca, encv, resv, etc...)\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index (1-based)\n\\return the media type FOUR CHAR code type of an MPEG4 media, or 0 if not MPEG-4 subtype\n */\nu32 gf_isom_get_mpeg4_subtype(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex);\n\n/*! fetches the root OD of a file  (can be NULL, OD or IOD, you have to check its tag)\n\\param isom_file the target ISO file\n\\return the OD/IOD if any. Caller must destroy the descriptor\n*/\nGF_Descriptor *gf_isom_get_root_od(GF_ISOFile *isom_file);\n\n/*! disable OD conversion from ISOM internal to regular OD tags\n\\param isom_file the target ISO file\n\\param disable if TRUE, ODs and ESDs will not be converted\n*/\nvoid gf_isom_disable_odf_conversion(GF_ISOFile *isom_file, Bool disable);\n\n/*! checks the presence of a track in rood OD/IOD\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return 0: NO, 1: YES, 2: ERROR*/\nu8 gf_isom_is_track_in_root_od(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! gets the GF_ESD given the sampleDescriptionIndex\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index (1-based)\n\\return the ESD associated to the sample description index, or NULL if error or not supported. Caller must destroy the ESD*/\nGF_ESD *gf_isom_get_esd(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex);\n\n/*! gets the decoderConfigDescriptor given the sampleDescriptionIndex\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index (1-based)\n\\return the decoder configuration descriptor associated to the sample description index, or NULL if error or not supported. Caller must destroy the descriptor\n*/\nGF_DecoderConfig *gf_isom_get_decoder_config(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex);\n\n/*! sets default TrackID (or ES_ID) for clock references.\n\\param isom_file the target ISO file\n\\param trackNumber the target track to set as a clock reference. If 0, default sync track ID is reseted and will be reassigned at next ESD fetch*/\nvoid gf_isom_set_default_sync_track(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! gets the profile and level value for MPEG-4 streams\n\\param isom_file the target ISO file\n\\param PL_Code the target profile to query file\n\\return the profile and level value, 0xFF if not defined\n*/\nu8 gf_isom_get_pl_indication(GF_ISOFile *isom_file, GF_ISOProfileLevelType PL_Code);\n\n/*! finds the first ObjectDescriptor using the given track by inspecting all OD tracks\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return the OD ID if dound, 0 otherwise*/\nu32 gf_isom_find_od_id_for_track(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! sets a profile and level indication for the movie iod (created if needed)\n\\note Use for MPEG-4 Systems only\nif the flag is ProfileLevel is 0 this means the movie doesn't require\nthe specific codec (equivalent to 0xFF value in MPEG profiles)\n\\param isom_file the target ISO file\n\\param PL_Code the profile and level code to set\n\\param ProfileLevel the profile and level value to set\n\\return error if any\n*/\nGF_Err gf_isom_set_pl_indication(GF_ISOFile *isom_file, GF_ISOProfileLevelType PL_Code, u8 ProfileLevel);\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n/*! sets the rootOD ID of the movie if you need it. By default, movies are created without root ODs\n\\note Use for MPEG-4 Systems only\n\\param isom_file the target ISO file\n\\param OD_ID ID to assign to the root OD/IOD\n\\return error if any\n*/\nGF_Err gf_isom_set_root_od_id(GF_ISOFile *isom_file, u32 OD_ID);\n\n/*! sets the rootOD URL of the movie if you need it (only needed to create an empty file pointing\nto external resource)\n\\note Use for MPEG-4 Systems only\n\\param isom_file the target ISO file\n\\param url_string the URL to assign to the root OD/IOD\n\\return error if any\n*/\nGF_Err gf_isom_set_root_od_url(GF_ISOFile *isom_file, const char *url_string);\n\n/*! removes the root OD\n\\note Use for MPEG-4 Systems only\n\\param isom_file the target ISO file\n\\return error if any\n*/\nGF_Err gf_isom_remove_root_od(GF_ISOFile *isom_file);\n\n/*! adds a system descriptor to the OD of the movie\n\\note Use for MPEG-4 Systems only\n\\param isom_file the target ISO file\n\\param theDesc the descriptor to add\n\\return error if any\n*/\nGF_Err gf_isom_add_desc_to_root_od(GF_ISOFile *isom_file, const GF_Descriptor *theDesc);\n\n/*! adds a track to the root OD\n\\note Use for MPEG-4 Systems only\n\\param isom_file the target ISO file\n\\param trackNumber the track to add to the root OD\n\\return error if any\n*/\nGF_Err gf_isom_add_track_to_root_od(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! removes a track to the root OD\n\\note Use for MPEG-4 Systems only\n\\param isom_file the target ISO file\n\\param trackNumber the track to remove from the root OD\n\\return error if any\n*/\nGF_Err gf_isom_remove_track_from_root_od(GF_ISOFile *isom_file, u32 trackNumber);\n\n\n/*! creates a new MPEG-4 sample description in a track\n\n\\note Used for MPEG-4 Systems, AAC and MPEG-4 Visual (part 2)\n\n\\param isom_file the target ISO file\n\\param trackNumber the target track number\n\\param esd the ESD to use for that sample description\n\\param URLname URL value of the data reference, NULL if no data reference (media in the file)\n\\param URNname URN value of the data reference, NULL if no data reference (media in the file)\n\\param outDescriptionIndex set to index of the new sample description\n\\return error if any\n*/\nGF_Err gf_isom_new_mpeg4_description(GF_ISOFile *isom_file, u32 trackNumber, const GF_ESD *esd, const char *URLname, const char *URNname, u32 *outDescriptionIndex);\n\n/*! changes an MPEG-4 sample description\n\\note Used for MPEG-4 Systems, AAC and MPEG-4 Visual (part 2)\n\\warning This will replace the whole ESD\n\\param isom_file the target ISO file\n\\param trackNumber the target track number\n\\param sampleDescriptionIndex the target sample description\n\\param newESD the new ESD to use for that sample description\n\\return error if any\n*/\nGF_Err gf_isom_change_mpeg4_description(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, const GF_ESD *newESD);\n\n/*! adds an MPEG-4 systems descriptor to the ESD of a sample description\n\\note Used for MPEG-4 Systems, AAC and MPEG-4 Visual (part 2)\n\\warning This will replace the whole ESD\n\\param isom_file the target ISO file\n\\param trackNumber the target track number\n\\param sampleDescriptionIndex the target sample description\n\\param theDesc the descriptor to add to the ESD of the sample description\n\\return error if any\n*/\nGF_Err gf_isom_add_desc_to_description(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, const GF_Descriptor *theDesc);\n\n/*! clones IOD PLs from orig to dest if any\n\\param orig_file the source ISO file\n\\param dest_file the destination ISO file\n\\return error if any\n*/\nGF_Err gf_isom_clone_pl_indications(GF_ISOFile *orig_file, GF_ISOFile *dest_file);\n\n/*deletes chapter (1-based index, index 0 for all)*/\nGF_Err gf_isom_remove_chapter(GF_ISOFile *the_file, u32 trackNumber, u32 index);\n\n/*! associates a given SL config with a given ESD while extracting the OD information\nThis is useful while reading the IOD / OD stream of an MP4 file. Note however that\nonly full AUs are extracted, therefore the calling application must SL-packetize the streams\n\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex set to the sample description index corresponding to this sample (optional, can be NULL)\n\\param slConfig the SL configuration descriptor to set. The descriptor is copied by the API for further use. A NULL pointer will result\nin using the default SLConfig (predefined = 2) remapped to predefined = 0\n\\return error if any\n*/\nGF_Err gf_isom_set_extraction_slc(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, const GF_SLConfig *slConfig);\n\n#endif //GPAC_DISABLE_ISOM_WRITE\n\n\n/*! @} */\n\n/*!\n\\addtogroup isostsd_grp ISOBMFF Sample Descriptions\n\\ingroup iso_grp\n\nSample Description functions are used to query and set codec parameters of a track\n\n@{\n*/\n\n/*! Unknown sample description*/\ntypedef struct\n{\n\t/*! codec tag is the containing box's tag, 0 if UUID is used*/\n\tu32 codec_tag;\n\t/*! entry UUID if no tag is used*/\n\tbin128 UUID;\n\t/*! codec version*/\n\tu16 version;\n\t/*! codec revision*/\n\tu16 revision;\n\t/*! vendor four character code*/\n\tu32 vendor_code;\n\n\t/*! temporal quality, video codecs only*/\n\tu32 temporal_quality;\n\t/*! spatial quality, video codecs only*/\n\tu32 spatial_quality;\n\t/*! width in pixels, video codecs only*/\n\tu16 width;\n\t/*! height in pixels, video codecs only*/\n\tu16 height;\n\t/*! horizontal resolution as 16.16 fixed point, video codecs only*/\n\tu32 h_res;\n\t/*! vertical resolution as 16.16 fixed point, video codecs only*/\n\tu32 v_res;\n\t/*! bit depth resolution in bits, video codecs only*/\n\tu16 depth;\n\t/*! color table, video codecs only*/\n\tu16 color_table_index;\n\t/*! compressor name, video codecs only*/\n\tchar compressor_name[33];\n\n\t/*! sample rate, audio codecs only*/\n\tu32 samplerate;\n\t/*! number of channels, audio codecs only*/\n\tu16 nb_channels;\n\t/*! bits per sample, audio codecs only*/\n\tu16 bits_per_sample;\n\t/*! indicates if QTFF signaling should be used, audio codecs only*/\n\tBool is_qtff;\n\t/*! for lpcm only, indicates format flags*/\n\tu32 lpcm_flags;\n\n\t/*optional, sample description specific configuration*/\n\tu8 *extension_buf;\n\t/*optional, sample description specific size*/\n\tu32 extension_buf_size;\n\t/*optional, wraps sample description specific data into a box if given type*/\n\tu32 ext_box_wrap;\n} GF_GenericSampleDescription;\n\n/*! gets an unknown sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index (1-based)\n\\return generic sample description information, or NULL if error\n*/\nGF_GenericSampleDescription *gf_isom_get_generic_sample_description(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex);\n\n/*! gets the decoder configuration of a JP2 file\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index (1-based)\n\\param out_dsi set to the decoder configuration - shall be freed by user\n\\param out_size set to the decoder configuration size\n\\return error if any\n*/\nGF_Err gf_isom_get_jp2_config(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, u8 **out_dsi, u32 *out_size);\n\n\n\n/*! gets RVC (Reconvigurable Video Coding) config of a track for a given sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index (1-based)\n\\param rvc_predefined set to a predefined value of RVC\n\\param data set to the RVC config buffer if not predefined, NULL otherwise\n\\param size set to the RVC config buffer size\n\\param mime set to the associated mime type of the stream\n\\return error if any*/\nGF_Err gf_isom_get_rvc_config(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, u16 *rvc_predefined, u8 **data, u32 *size, const char **mime);\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n/*! sets the RVC config for the given track sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track number\n\\param sampleDescriptionIndex the target sample description index\n\\param rvc_predefined the predefined RVC configuration code, 0 if not predefined\n\\param mime the associated mime type of the video\n\\param data the RVC configuration data; ignored if rvc_predefined is not 0\n\\param size the size of the RVC configuration data; ignored if rvc_predefined is not 0\n\\return error if any\n*/\nGF_Err gf_isom_set_rvc_config(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, u16 rvc_predefined, char *mime, u8 *data, u32 size);\n\n\n/*! updates fields of given visual sample description - these fields are reserved in ISOBMFF, this should only be used for QT, see QTFF\n\\param isom_file the target ISO file\n\\param trackNumber the target track number\n\\param sampleDescriptionIndex the target sample description\n\\param revision revision of the sample description format\n\\param vendor four character code of the vendor\n\\param temporalQ temporal quality\n\\param spatialQ spatial quality\n\\param horiz_res horizontal resolution as 16.16 fixed point number\n\\param vert_res vertical resolution as 16.16 fixed point number\n\\param frames_per_sample number of frames per media samples\n\\param compressor_name human readable name for the compressor\n\\param color_table_index color table index, use -1 if no color table (most common case)\n\\return error if any\n*/\nGF_Err gf_isom_update_video_sample_entry_fields(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, u16 revision, u32 vendor, u32 temporalQ, u32 spatialQ, u32 horiz_res, u32 vert_res, u16 frames_per_sample, const char *compressor_name, s16 color_table_index);\n\n/*! updates a sample description from a serialized sample description box. Only child boxes are removed in the process\n\\param isom_file the target ISO file\n\\param trackNumber the target track number\n\\param sampleDescriptionIndex the target sample description\n\\param data a serialized sample description box\n\\param size size of the serialized sample description\n\\return error if any\n*/\nGF_Err gf_isom_update_sample_description_from_template(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, u8 *data, u32 size);\n\n\n/*! creates a new unknown StreamDescription in the file.\n\\note use this to store media not currently supported by the ISO media format or media types not implemented in this library\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param URLname URL value of the data reference, NULL if no data reference (media in the file)\n\\param URNname URN value of the data reference, NULL if no data reference (media in the file)\n\\param udesc generic sample description information to use\n\\param outDescriptionIndex set to index of the new sample description\n\\return error if any\n*/\nGF_Err gf_isom_new_generic_sample_description(GF_ISOFile *isom_file, u32 trackNumber, const char *URLname, const char *URNname, GF_GenericSampleDescription *udesc, u32 *outDescriptionIndex);\n\n/*! clones a sample description without inspecting media types\n\\param isom_file the destination ISO file\n\\param trackNumber the destination track\n\\param orig_file the source ISO file\n\\param orig_track the source track\n\\param orig_desc_index the source sample description to clone\n\\param URLname URL value of the data reference, NULL if no data reference (media in the file)\n\\param URNname URN value of the data reference, NULL if no data reference (media in the file)\n\\param outDescriptionIndex set to index of the new sample description\n\\return error if any\n*/\nGF_Err gf_isom_clone_sample_description(GF_ISOFile *isom_file, u32 trackNumber, GF_ISOFile *orig_file, u32 orig_track, u32 orig_desc_index, const char *URLname, const char *URNname, u32 *outDescriptionIndex);\n\n/*! gets the sample description template of a track. This serializes sample description box\n\\param isom_file the destination ISO file\n\\param trackNumber the destination track\n\\param sampleDescriptionIndex the target sample description\n\\param output will be set to a newly allocated buffer containing the serialized box - caller shall free it\n\\param output_size will be set to the size of the allocated buffer\n\\return error if any\n*/\nGF_Err gf_isom_get_stsd_template(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, u8 **output, u32 *output_size);\n\n#endif // GPAC_DISABLE_ISOM_WRITE\n\n/*! checks if sample descriptions are the same. This does include self-contained checking and reserved flags. The specific media cfg (DSI & co) is not analysed, only a memory comparaison is done\n\\param f1 the first ISO file\n\\param tk1 the first track\n\\param sdesc_index1 the first sample description\n\\param f2 the second ISO file\n\\param tk2 the second track\n\\param sdesc_index2 the second sample description\n\\return GF_TRUE if sample descriptions match, GF_FALSE otherwise\n*/\nBool gf_isom_is_same_sample_description(GF_ISOFile *f1, u32 tk1, u32 sdesc_index1, GF_ISOFile *f2, u32 tk2, u32 sdesc_index2);\n\n\n/*! Generic 3GP/3GP2 config record*/\ntypedef struct\n{\n\t/*GF_4CC record type, one fo the above GF_ISOM_SUBTYPE_3GP_ * subtypes*/\n\tu32 type;\n\t/*4CC vendor name*/\n\tu32 vendor;\n\t/*codec version*/\n\tu8 decoder_version;\n\t/*number of sound frames per IsoMedia sample, >0 and <=15. The very last sample may contain less frames. */\n\tu8 frames_per_sample;\n\t/*H263 ONLY - Level*/\n\tu8 H263_level;\n\t/*H263 Profile*/\n\tu8 H263_profile;\n\t/*AMR(WB) ONLY - num of mode for the codec*/\n\tu16 AMR_mode_set;\n\t/*AMR(WB) ONLY - changes in codec mode per sample*/\n\tu8 AMR_mode_change_period;\n} GF_3GPConfig;\n\n\n/*! gets a 3GPP sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\return the 3GP config for this sample description, NULL if not a 3GPP track\n*/\nGF_3GPConfig *gf_isom_3gp_config_get(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex);\n#ifndef GPAC_DISABLE_ISOM_WRITE\n/*! creates a 3GPP sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param config the 3GP config for this sample description\n\\param URLname URL value of the data reference, NULL if no data reference (media in the file)\n\\param URNname URN value of the data reference, NULL if no data reference (media in the file)\n\\param outDescriptionIndex set to the index of the created sample description\n\\return error if any\n*/\nGF_Err gf_isom_3gp_config_new(GF_ISOFile *isom_file, u32 trackNumber, GF_3GPConfig *config, const char *URLname, const char *URNname, u32 *outDescriptionIndex);\n/*! updates the 3GPP config - subtypes shall NOT differ\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param config the 3GP config for this sample description\n\\param sampleDescriptionIndex the target sample description index\n\\return error if any\n*/\nGF_Err gf_isom_3gp_config_update(GF_ISOFile *isom_file, u32 trackNumber, GF_3GPConfig *config, u32 sampleDescriptionIndex);\n#endif\t/*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/*! gets AVC config for a sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\return the AVC config - user is responsible for deleting it\n*/\nGF_AVCConfig *gf_isom_avc_config_get(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex);\n/*! gets SVC config for a sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\return the SVC config - user is responsible for deleting it\n*/\nGF_AVCConfig *gf_isom_svc_config_get(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex);\n/*! gets MVC config for a sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\return the SVC config - user is responsible for deleting it\n*/\nGF_AVCConfig *gf_isom_mvc_config_get(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex);\n\n/*! AVC familiy type*/\ntypedef enum\n{\n\t/*! not an AVC codec*/\n\tGF_ISOM_AVCTYPE_NONE=0,\n\t/*! AVC only*/\n\tGF_ISOM_AVCTYPE_AVC_ONLY,\n\t/*! AVC+SVC in same track*/\n\tGF_ISOM_AVCTYPE_AVC_SVC,\n\t/*! SVC only*/\n\tGF_ISOM_AVCTYPE_SVC_ONLY,\n\t/*! AVC+MVC in same track*/\n\tGF_ISOM_AVCTYPE_AVC_MVC,\n\t/*! SVC only*/\n\tGF_ISOM_AVCTYPE_MVC_ONLY,\n} GF_ISOMAVCType;\n\n/*! gets the AVC family type for a sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target hint track\n\\param sampleDescriptionIndex the target sample description index\n\\return the type of AVC media\n*/\nGF_ISOMAVCType gf_isom_get_avc_svc_type(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex);\n\n/*! HEVC family type*/\ntypedef enum\n{\n\t/*! not an HEVC codec*/\n\tGF_ISOM_HEVCTYPE_NONE=0,\n\t/*! HEVC only*/\n\tGF_ISOM_HEVCTYPE_HEVC_ONLY,\n\t/*! HEVC+LHVC in same track*/\n\tGF_ISOM_HEVCTYPE_HEVC_LHVC,\n\t/*! LHVC only*/\n\tGF_ISOM_HEVCTYPE_LHVC_ONLY,\n} GF_ISOMHEVCType;\n\n/*! gets the HEVC family type for a sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\return the type of HEVC media\n*/\nGF_ISOMHEVCType gf_isom_get_hevc_lhvc_type(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex);\n\n/*! gets HEVC config for a sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\return the HEVC config - user is responsible for deleting it\n*/\nGF_HEVCConfig *gf_isom_hevc_config_get(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex);\n/*! gets LHVC config for a sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\return the LHVC config - user is responsible for deleting it\n*/\nGF_HEVCConfig *gf_isom_lhvc_config_get(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex);\n\n/*! VVC family type*/\ntypedef enum\n{\n\t/*! not an VVC codec*/\n\tGF_ISOM_VVCTYPE_NONE=0,\n\t/*! VVC only*/\n\tGF_ISOM_VVCTYPE_ONLY,\n\t/*! VVC subpicture track*/\n\tGF_ISOM_VVCTYPE_SUBPIC,\n\t/*! VVC non-VCL only*/\n\tGF_ISOM_VVCTYPE_NVCL,\n} GF_ISOMVVCType;\n\n/*! gets the VVC family type for a sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\return the type of VVC media\n*/\nGF_ISOMVVCType gf_isom_get_vvc_type(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex);\n\n/*! gets VVC config for a sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\return the VVC config - user is responsible for deleting it\n*/\nGF_VVCConfig *gf_isom_vvc_config_get(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex);\n\n/*! gets AV1 config for a sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\return the AV1 config - user is responsible for deleting it\n*/\nGF_AV1Config *gf_isom_av1_config_get(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex);\n\n/*! gets VP8/9 config for a sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\return the VP8/9 config - user is responsible for deleting it\n*/\nGF_VPConfig *gf_isom_vp_config_get(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex);\n\n/*! gets DOVI config for a sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\return the DOVI config - user is responsible for deleting it\n*/\nGF_DOVIDecoderConfigurationRecord* gf_isom_dovi_config_get(GF_ISOFile* isom_file, u32 trackNumber, u32 sampleDescriptionIndex);\n\n/*! checks if some tracks in file needs layer reconstruction\n\\param isom_file the target ISO file\n\\return GF_TRUE if track dependencies implying extractors or implicit reconstruction are found, GF_FALSE otherwise\n*/\nBool gf_isom_needs_layer_reconstruction(GF_ISOFile *isom_file);\n\n/*! NALU extract modes and flags*/\ntypedef enum\n{\n\t/*! all extractors are rewritten*/\n\tGF_ISOM_NALU_EXTRACT_DEFAULT = 0,\n\t/*! all extractors are skipped but NALU data from this track is kept*/\n\tGF_ISOM_NALU_EXTRACT_LAYER_ONLY,\n\t/*! all extractors are kept (untouched sample) - used for dumping modes*/\n\tGF_ISOM_NALU_EXTRACT_INSPECT,\n\t/*! above mode is applied and PPS/SPS/... are appended in the front of every IDR*/\n\tGF_ISOM_NALU_EXTRACT_INBAND_PS_FLAG = 1<<16,\n\t/*! above mode is applied and all start codes are rewritten (xPS inband as well)*/\n\tGF_ISOM_NALU_EXTRACT_ANNEXB_FLAG = 2<<17,\n\t/*! above mode is applied and VDRD NAL unit is inserted before SVC slice*/\n\tGF_ISOM_NALU_EXTRACT_VDRD_FLAG = 1<<18,\n\t/*! all extractors are skipped and only tile track data is kept*/\n\tGF_ISOM_NALU_EXTRACT_TILE_ONLY = 1<<19\n} GF_ISONaluExtractMode;\n\n/*! sets the NALU extraction mode for this track\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param nalu_extract_mode the NALU extraction mode to set\n\\return error if any\n*/\nGF_Err gf_isom_set_nalu_extract_mode(GF_ISOFile *isom_file, u32 trackNumber, GF_ISONaluExtractMode nalu_extract_mode);\n/*! gets the NALU extraction mode for this track\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return the NALU extraction mode used\n*/\nGF_ISONaluExtractMode gf_isom_get_nalu_extract_mode(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! gets the composition offset shift if any for track using negative ctts\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return the composition offset shift or 0\n*/\ns32 gf_isom_get_composition_offset_shift(GF_ISOFile *isom_file, u32 trackNumber);\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n/*! creates a new AVC sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param cfg the AVC config for this sample description\n\\param URLname URL value of the data reference, NULL if no data reference (media in the file)\n\\param URNname URN value of the data reference, NULL if no data reference (media in the file)\n\\param outDescriptionIndex set to the index of the created sample description\n\\return error if any\n*/\nGF_Err gf_isom_avc_config_new(GF_ISOFile *isom_file, u32 trackNumber, GF_AVCConfig *cfg, const char *URLname, const char *URNname, u32 *outDescriptionIndex);\n/*! updates an AVC sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index to update\n\\param cfg the AVC config for this sample description\n\\return error if any\n*/\nGF_Err gf_isom_avc_config_update(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, GF_AVCConfig *cfg);\n\n/*! creates a new SVC sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param cfg the SVC config for this sample description\n\\param URLname URL value of the data reference, NULL if no data reference (media in the file)\n\\param URNname URN value of the data reference, NULL if no data reference (media in the file)\n\\param outDescriptionIndex set to the index of the created sample description\n\\return error if any\n*/\nGF_Err gf_isom_svc_config_new(GF_ISOFile *isom_file, u32 trackNumber, GF_AVCConfig *cfg, const char *URLname, const char *URNname, u32 *outDescriptionIndex);\n/*! updates an SVC sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index to update\n\\param cfg the AVC config for this sample description\n\\param is_additional if set, the SVCConfig will be added to the AVC sample description, otherwise the sample description will be SVC-only\n\\return error if any\n*/\nGF_Err gf_isom_svc_config_update(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, GF_AVCConfig *cfg, Bool is_additional);\n/*! deletes an SVC sample description\n\\warning Associated samples if any are NOT deleted\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index to delete\n\\return error if any\n*/\nGF_Err gf_isom_svc_config_del(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex);\n\n/*! creates a new MVC sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param cfg the SVC config for this sample description\n\\param URLname URL value of the data reference, NULL if no data reference (media in the file)\n\\param URNname URN value of the data reference, NULL if no data reference (media in the file)\n\\param outDescriptionIndex set to the index of the created sample description\n\\return error if any\n*/\nGF_Err gf_isom_mvc_config_new(GF_ISOFile *isom_file, u32 trackNumber, GF_AVCConfig *cfg, const char *URLname, const char *URNname, u32 *outDescriptionIndex);\n\n/*! updates an MVC sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index to update\n\\param cfg the AVC config for this sample description\n\\param is_additional if set, the MVCConfig will be added to the AVC sample description, otherwise the sample description will be MVC-only\n\\return error if any\n*/\nGF_Err gf_isom_mvc_config_update(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, GF_AVCConfig *cfg, Bool is_additional);\n\n/*! deletes an MVC sample description\n\\warning Associated samples if any are NOT deleted\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index to delete\n\\return error if any\n*/\nGF_Err gf_isom_mvc_config_del(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex);\n\n/*! sets avc3 entry type (inband SPS/PPS) instead of avc1 (SPS/PPS in avcC box)\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\param keep_xps if set to GF_TRUE, keeps parameter set in the configuration record otherwise removes them\n\\return error if any\n*/\nGF_Err gf_isom_avc_set_inband_config(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, Bool keep_xps);\n\n/*! sets hev1 entry type (inband SPS/PPS) instead of hvc1 (SPS/PPS in hvcC box)\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\param keep_xps if set to GF_TRUE, keeps parameter set in the configuration record otherwise removes them\n\\return error if any\n*/\nGF_Err gf_isom_hevc_set_inband_config(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, Bool keep_xps);\n\n/*! sets lhe1 entry type instead of lhc1 but keep lhcC box intact\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\return error if any\n*/\nGF_Err gf_isom_lhvc_force_inband_config(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex);\n\n/*! sets hvt1 entry type (tile track) or hev2/hvc2 type if is_base_track is set. It is the use responsibility to set the tbas track reference to the base hevc track\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\param cfg may be set to the tile track configuration to indicate sub-profile of the tile, or NULL\n\\param is_base_track if set to GF_TRUE, indicates this is a tile base track, otherwise this is a tile track\n\\return error if any\n*/\nGF_Err gf_isom_hevc_set_tile_config(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, GF_HEVCConfig *cfg, Bool is_base_track);\n\n/*! creates a new HEVC sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param cfg the HEVC config for this sample description\n\\param URLname URL value of the data reference, NULL if no data reference (media in the file)\n\\param URNname URN value of the data reference, NULL if no data reference (media in the file)\n\\param outDescriptionIndex set to the index of the created sample description\n\\return error if any\n*/\nGF_Err gf_isom_hevc_config_new(GF_ISOFile *isom_file, u32 trackNumber, GF_HEVCConfig *cfg, const char *URLname, const char *URNname, u32 *outDescriptionIndex);\n\n/*! updates an HEVC sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index to update\n\\param cfg the HEVC config for this sample description\n\\return error if any\n*/\nGF_Err gf_isom_hevc_config_update(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, GF_HEVCConfig *cfg);\n\n/*! Updates L-HHVC config*/\ntypedef enum {\n\t//! changes track type to LHV1/LHE1: no base nor extractors in track, just enhancement layers\n\tGF_ISOM_LEHVC_ONLY = 0,\n\t//! changes track type to HVC2/HEV2: base and extractors/enh. in track\n\tGF_ISOM_LEHVC_WITH_BASE,\n\t//! changes track type to HVC1/HEV1 with additional cfg: base and enh. in track no extractors\n\tGF_ISOM_LEHVC_WITH_BASE_BACKWARD,\n\t//! changes track type to HVC2/HEV2 for tile base tracks\n\tGF_ISOM_HEVC_TILE_BASE,\n} GF_ISOMLHEVCTrackType;\n\n/*! updates an HEVC sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index to update\n\\param cfg the LHVC config for this sample description\n\\param track_type indicates the LHVC track type to set\n\\return error if any\n*/\nGF_Err gf_isom_lhvc_config_update(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, GF_HEVCConfig *cfg, GF_ISOMLHEVCTrackType track_type);\n\n/*! sets nalu size length\n\\warning Any previously added samples must be rewritten by the caller\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index to update\n\\param nalu_size_length the new NALU size length in bytes\n\\return error if any\n*/\nGF_Err gf_isom_set_nalu_length_field(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, u32 nalu_size_length);\n\n\n/*! creates a new VVC sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param cfg the VVC config for this sample description\n\\param URLname URL value of the data reference, NULL if no data reference (media in the file)\n\\param URNname URN value of the data reference, NULL if no data reference (media in the file)\n\\param outDescriptionIndex set to the index of the created sample description\n\\return error if any\n*/\nGF_Err gf_isom_vvc_config_new(GF_ISOFile *isom_file, u32 trackNumber, GF_VVCConfig *cfg, const char *URLname, const char *URNname, u32 *outDescriptionIndex);\n\n/*! sets vvi1 entry type (inband SPS/PPS) instead of vvc1 (SPS/PPS in hvcC box)\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\param keep_xps if set to GF_TRUE, keeps parameter set in the configuration record otherwise removes them\n\\return error if any\n*/\nGF_Err gf_isom_vvc_set_inband_config(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, Bool keep_xps);\n\n/*! updates vvcC configuration\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\param cfg new config to set\n\\return error if any\n*/\nGF_Err gf_isom_vvc_config_update(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, GF_VVCConfig *cfg);\n\n/*! creates new VPx config\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param cfg the VPx config for this sample description\n\\param URLname URL value of the data reference, NULL if no data reference (media in the file)\n\\param URNname URN value of the data reference, NULL if no data reference (media in the file)\n\\param outDescriptionIndex set to the index of the created sample description\n\\param vpx_type four character code of entry ('vp08', 'vp09' or 'vp10')\n\\return error if any\n*/\nGF_Err gf_isom_vp_config_new(GF_ISOFile *isom_file, u32 trackNumber, GF_VPConfig *cfg, const char *URLname, const char *URNname, u32 *outDescriptionIndex, u32 vpx_type);\n\n\n/*! creates new AV1 config\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param cfg the AV1 config for this sample description\n\\param URLname URL value of the data reference, NULL if no data reference (media in the file)\n\\param URNname URN value of the data reference, NULL if no data reference (media in the file)\n\\param outDescriptionIndex set to the index of the created sample description\n\\return error if any\n*/\nGF_Err gf_isom_av1_config_new(GF_ISOFile *isom_file, u32 trackNumber, GF_AV1Config *cfg, const char *URLname, const char *URNname, u32 *outDescriptionIndex);\n\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/*! Sample entry description for 3GPP DIMS*/\ntypedef struct\n{\n\t/*! profile*/\n\tu8 profile;\n\t/*! level*/\n\tu8 level;\n\t/*! number of components in path*/\n\tu8 pathComponents;\n\t/*! full request*/\n\tBool fullRequestHost;\n\t/*! stream type*/\n\tBool streamType;\n\t/*! has redundant sample (carousel)*/\n\tu8 containsRedundant;\n\t/*! text encoding string*/\n\tconst char *textEncoding;\n\t/*! content encoding string*/\n\tconst char *contentEncoding;\n\t/*! script string*/\n\tconst char *content_script_types;\n\t/*! mime type string*/\n\tconst char *mime_type;\n\t/*! xml schema location string*/\n\tconst char *xml_schema_loc;\n} GF_DIMSDescription;\n\n/*! gets a DIMS sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\param desc set to the DIMS description\n\\return error if any\n*/\nGF_Err gf_isom_get_dims_description(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, GF_DIMSDescription *desc);\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n/*! creates a DIMS sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param desc the DIMS config for this sample description\n\\param URLname URL value of the data reference, NULL if no data reference (media in the file)\n\\param URNname URN value of the data reference, NULL if no data reference (media in the file)\n\\param outDescriptionIndex set to the index of the created sample description\n\\return error if any\n*/\nGF_Err gf_isom_new_dims_description(GF_ISOFile *isom_file, u32 trackNumber, GF_DIMSDescription *desc, const char *URLname, const char *URNname, u32 *outDescriptionIndex);\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n/*! gets an AC3 sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\return AC-3 config\n*/\nGF_AC3Config *gf_isom_ac3_config_get(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex);\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n/*! creates an AC3 or EAC3 sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param cfg the AC3 config for this sample description\n\\param URLname URL value of the data reference, NULL if no data reference (media in the file)\n\\param URNname URN value of the data reference, NULL if no data reference (media in the file)\n\\param outDescriptionIndex set to the index of the created sample description\n\\return error if any\n*/\nGF_Err gf_isom_ac3_config_new(GF_ISOFile *isom_file, u32 trackNumber, GF_AC3Config *cfg, const char *URLname, const char *URNname, u32 *outDescriptionIndex);\n\n/*! updates an AC3 or EAC3 sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\param cfg the AC3 config for this sample description\n\\return error if any\n*/\nGF_Err gf_isom_ac3_config_update(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, GF_AC3Config *cfg);\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n/*! gets TrueHD  sample description info\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\param format_info set to the format info - may be NULL\n\\param peak_data_rate set to the peak data rate info - may be NULL\n\\return error if any\n*/\nGF_Err gf_isom_truehd_config_get(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, u32 *format_info, u32 *peak_data_rate);\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n/*! creates a FLAC sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param URLname URL value of the data reference, NULL if no data reference (media in the file)\n\\param URNname URN value of the data reference, NULL if no data reference (media in the file)\n\\param format_info TrueHD format info\n\\param peak_data_rate TrueHD peak data rate\n\\param outDescriptionIndex set to the index of the created sample description\n\\return error if any\n*/\nGF_Err gf_isom_truehd_config_new(GF_ISOFile *isom_file, u32 trackNumber, char *URLname, char *URNname, u32 format_info, u32 peak_data_rate, u32 *outDescriptionIndex);\n#endif\n\n/*! gets a FLAC sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\param dsi set to the flac decoder config - shall be freeed by caller\n\\param dsi_size set to the size of the flac decoder config\n\\return error if any\n*/\nGF_Err gf_isom_flac_config_get(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, u8 **dsi, u32 *dsi_size);\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n/*! creates a FLAC sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param metadata the flac decoder config buffer\n\\param metadata_size the size of flac decoder config\n\\param URLname URL value of the data reference, NULL if no data reference (media in the file)\n\\param URNname URN value of the data reference, NULL if no data reference (media in the file)\n\\param outDescriptionIndex set to the index of the created sample description\n\\return error if any\n*/\nGF_Err gf_isom_flac_config_new(GF_ISOFile *isom_file, u32 trackNumber, u8 *metadata, u32 metadata_size, const char *URLname, const char *URNname, u32 *outDescriptionIndex);\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n/*! gets a OPUS  sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\param dsi set to the OPUS decoder config (without OpusHead tag), may be NULL - shall be freeed by caller\n\\param dsi_size set to the size of the OPUS decoder config, may be NULL\n\\return error if any\n*/\nGF_Err gf_isom_opus_config_get(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, u8 **dsi, u32 *dsi_size);\n\n/*! gets a OPUS  sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\param opcfg opus config to get\n\\return error if any\n*/\nGF_Err gf_isom_opus_config_get_desc(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, GF_OpusConfig *opcfg);\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n/*! creates a new opus  sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param cfg the opus stream configuration\n\\param URLname URL value of the data reference, NULL if no data reference (media in the file)\n\\param URNname URN value of the data reference, NULL if no data reference (media in the file)\n\\param outDescriptionIndex set to the index of the created sample description\n\\return error if any\n*/\nGF_Err gf_isom_opus_config_new(GF_ISOFile *isom_file, u32 trackNumber, GF_OpusConfig *cfg, char *URLname, char *URNname, u32 *outDescriptionIndex);\n#endif\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n/*! creates a motion jpeg 2000 sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param URLname URL value of the data reference, NULL if no data reference (media in the file)\n\\param URNname URN value of the data reference, NULL if no data reference (media in the file)\n\\param outDescriptionIndex set to the index of the created sample description\n\\param dsi the jpeg2000 decoder config buffer\n\\param dsi_len the size of jpeg2000 decoder config\n\\return error if any\n*/\nGF_Err gf_isom_new_mj2k_description(GF_ISOFile *isom_file, u32 trackNumber, const char *URLname, const char *URNname, u32 *outDescriptionIndex, u8 *dsi, u32 dsi_len);\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n/*! creates a time code metadata sample description\n\\note frames_per_counter_tick<0 disables counter flag but signals frames_per_tick\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param fps_num the frame rate numerator\n\\param fps_den the frame rate denumerator (frame rate numerator will be track media timescale)\n\\param frames_per_counter_tick if not 0, enables counter mode (sample data is an counter) and use this value as number of frames per counter tick. Otherwise, disables counter mode (sample data write h,m,s,frames)\n\\param is_drop indicates that the time code in samples is a drop timecode\n\\param is_counter indicates that the counter flag should be set\n\\param outDescriptionIndex set to the index of the created sample description\n\\return error if any\n*/\nGF_Err gf_isom_tmcd_config_new(GF_ISOFile *isom_file, u32 trackNumber, u32 fps_num, u32 fps_den, s32 frames_per_counter_tick, Bool is_drop, Bool is_counter, u32 *outDescriptionIndex);\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n/*! gets information of a time code metadata sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\param tmcd_flags set to the timecode description flags\n\\param tmcd_fps_num set to fps numerator of timecode description\n\\param tmcd_fps_den set to fps denominator of timecode description\n\\param tmcd_fpt set to the ticks per second for counter mode (tmcd_flags & 0x1)\n\\return error if any\n*/\nGF_Err gf_isom_get_tmcd_config(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, u32 *tmcd_flags, u32 *tmcd_fps_num, u32 *tmcd_fps_den, u32 *tmcd_fpt);\n\n/*! gets information of a raw PCM  sample description, ISOBMFF style\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\param flags set to the pcm config flags (0: big endian, 1: little endian), may be NULL\n\\param pcm_size  set to PCM sample size (per channel, 16, 24, 32, 64, may be NULL\n\\return error if any\n*/\nGF_Err gf_isom_get_pcm_config(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, u32 *flags, u32 *pcm_size);\n\n/*! gets information of a raw PCM  sample description, QT style (lpcm codecid)\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\param sample_rate set to the pcm sample rate, may be NULL\n\\param nb_channels set to the pcm channel count, may be NULL\n\\param flags set to the pcm config flags (1: float, 2: big endian, 4: signed, other flags cf QTFF), may be NULL\n\\param pcm_size  set to PCM sample size (per channel, 16, 24, 32, 64, may be NULL\n\\return error if any\n*/\nGF_Err gf_isom_get_lpcm_config(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, Double *sample_rate, u32 *nb_channels, u32 *flags, u32 *pcm_size);\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n/*! creates a MPHA  sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param URLname URL value of the data reference, NULL if no data reference (media in the file)\n\\param URNname URN value of the data reference, NULL if no data reference (media in the file)\n\\param outDescriptionIndex set to the index of the created sample description\n\\param dsi the MPEGH audio config (payload of mhaC box):  byte[0]=1 (config version) ,byte[1]=ProfileLevel,  byte[2]=channel layout, byte[3],byte[4]: the size of what follows the rest being a mpegh3daConfig\n\\param dsi_size the size of the MPEGH audio config\n\\param mha_subtype mha1/mha2:/mhm1/mhm2 subtype to use\n\\return error if any\n*/\nGF_Err gf_isom_new_mpha_description(GF_ISOFile *isom_file, u32 trackNumber, const char *URLname, const char *URNname, u32 *outDescriptionIndex, u8 *dsi, u32 dsi_size, u32 mha_subtype);\n#endif\n\n/*! gets compatible profile list for mpegh entry\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\param nb_compatible_profiles set to the number of compatible profiles returned\n\\return array of compatible profiles, NULL if none found\n*/\nconst u8 *gf_isom_get_mpegh_compatible_profiles(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, u32 *nb_compatible_profiles);\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n/*! sets compatible profile list for mpegh entry\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\param profiles array of compatible profiles, NULL to remove compatible profiles\n\\param nb_compatible_profiles  number of compatible profiles in list, 0 to remove compatible profiles\n\\return error if any\n*/\nGF_Err gf_isom_set_mpegh_compatible_profiles(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, const u32 *profiles, u32 nb_compatible_profiles);\n#endif\n\n/*! structure holding youtube 360 video info\n- cf https://github.com/google/spatial-media/blob/master/docs/spherical-video-v2-rfc.md#stereoscopic-3d-video-box-st3d\n */\ntypedef struct\n{\n\t/*! stereo type  holding youtube 360 video info*/\n\tu32 stereo_type;\n\t/*! 0: unknown (not present), 1: cube map, 2: EQR, 3: mesh*/\n\tu32 projection_type;\n\t/*! metadata about 3D software creator*/\n\tconst char *meta_data;\n\t/*! indicate default pause is present*/\n\tBool pose_present;\n\t/*! default pause yaw as 16.16 fixed point*/\n\tu32 yaw;\n\t/*! default pause pitch as 16.16 fixed point*/\n\tu32 pitch;\n\t/*! default pause roll as 16.16 fixed point*/\n\tu32 roll;\n\n\t/*! cube map layout*/\n\tu32 layout;\n\t/*! cube map padding*/\n\tu32 padding;\n\n\t/*! EQR top crop pos in frame, in pixels*/\n\tu32 top;\n\t/*! EQR bottom crop pos in frame, in pixels*/\n\tu32 bottom;\n\t/*! EQR left crop pos in frame, in pixels*/\n\tu32 left;\n\t/*! EQR right crop pos in frame, in pixels*/\n\tu32 right;\n\n} GF_ISOM_Y3D_Info;\n\n\n/*! gets youtube 3D/360 info\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\param info filled with 3D info\n\\return error if any, GF_NOT_FOUND if no 3D/360 or setero info\n*/\nGF_Err gf_isom_get_y3d_info(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, GF_ISOM_Y3D_Info *info);\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n/*! sets youtube 3D/360 info\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\param info  3D info to set\n\\return error if any\n*/\nGF_Err gf_isom_set_y3d_info(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, GF_ISOM_Y3D_Info *info);\n#endif\n\n/*! @} */\n\n\n/*!\n\\addtogroup isofragred_grp Fragmented ISOBMFF Read\n\\ingroup iso_grp\n\nThis describes function specific to fragmented ISOBMF files\n\n@{\n*/\n\n/*! checks if a movie file is fragmented\n\\param isom_file the target ISO file\n\\return GF_FALSE if movie isn't fragmented, GF_TRUE otherwise\n*/\nBool gf_isom_is_fragmented(GF_ISOFile *isom_file);\n\n/*! checks if a movie file is fragmented\n\\param isom_file the target ISO file\n\\param TrackID the target track\n\\return GF_FALSE if track isn't fragmented, GF_TRUE otherwise*/\nBool gf_isom_is_track_fragmented(GF_ISOFile *isom_file, GF_ISOTrackID TrackID);\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\n/*! checks if a file has a top styp box\n\\param isom_file the target ISO file\n\\param brand set to the major brand of the styp box\n\\param version set to version of the styp box\n\\return GF_TRUE of the file has a styp box, GF_FALSE otherwise\n*/\nBool gf_isom_has_segment(GF_ISOFile *isom_file, u32 *brand, u32 *version);\n/*! gets number of movie fragments in the file\n\\param isom_file the target ISO file\n\\returns number of movie fragments in the file, 0 if none\n*/\nu32 gf_isom_segment_get_fragment_count(GF_ISOFile *isom_file);\n/*! gets number of track fragments in the indicated movie fragment\n\\param isom_file the target ISO file\n\\param moof_index the target movie fragment  (1-based index)\n\\return number of track fragments, 0 if none\n*/\nu32 gf_isom_segment_get_track_fragment_count(GF_ISOFile *isom_file, u32 moof_index);\n/*! get the track fragment decode time of a track fragment\n\\param isom_file the target ISO file\n\\param moof_index the target movie fragment (1-based index)\n\\param traf_index the target track fragment (1-based index)\n\\param decode_time set to the track fragment decode time if present, 0 otherwise\n\\return the track ID of the track fragment\n*/\nu32 gf_isom_segment_get_track_fragment_decode_time(GF_ISOFile *isom_file, u32 moof_index, u32 traf_index, u64 *decode_time);\n\n/*! get the movie fragment size, i.e. the size of moof, mdat and related boxes before moof/mdat\n\n\\param isom_file the target ISO file\n\\param moof_index the target movie fragment (1-based index)\n\\param moof_size set to moof box size, may be NULL\n\\return the movie fragemnt size\n*/\nu64 gf_isom_segment_get_fragment_size(GF_ISOFile *isom_file, u32 moof_index, u32 *moof_size);\n\n/*! enables single moof mode. In single moof mode, file is parsed only one moof/mdat at a time\n   in order to proceed to next moof, \\ref gf_isom_reset_data_offset must be called to parse the next moof\n\\param isom_file the target ISO file\n\\param mode if GF_TRUE, enables single moof mode; otherwise disables it\n*/\nvoid gf_isom_set_single_moof_mode(GF_ISOFile *isom_file, Bool mode);\n\n/*! gets closest file offset for the given time, when the file uses an segment index (sidx)\n\\param isom_file the target ISO file\n\\param start_time the start time in seconds\n\\param offset set to the file offset of the segment containing the desired time\n\\return error if any\n*/\nGF_Err gf_isom_get_file_offset_for_time(GF_ISOFile *isom_file, Double start_time, u64 *offset);\n\n/*! gets sidx duration, when the file uses an segment index (sidx)\n\\param isom_file the target ISO file\n\\param sidx_dur set to the total duration documented in the segment index\n\\param sidx_timescale set timescale used to represent the duration in the segment index\n\\return error if any\n*/\nGF_Err gf_isom_get_sidx_duration(GF_ISOFile *isom_file, u64 *sidx_dur, u32 *sidx_timescale);\n\n\n/*! refreshes a fragmented file\nA file being downloaded may be a fragmented file. In this case only partial info\nis available once the file is successfully open (gf_isom_open_progressive), and since there is\nno information wrt number fragments (which could actually be generated on the fly\nat the sender side), you must call this function on regular basis in order to\nload newly downloaded fragments. Note this may result in Track/Movie duration changes\nand SampleCount change too ...\n\nThis function should also be called when using memory read (gmem://) to refresh the underlying bitstream after appendin data to your blob.\nIn the case where the file is not fragmented, no further box parsing will be done.\n\n\\param isom_file the target ISO file\n\\param MissingBytes set to the number of missing bytes to parse the last incomplete top-level box found\n\\param new_location if set, the previous bitstream is changed to this new location, otherwise it is refreshed (disk flush)\n\\return error if any\n*/\nGF_Err gf_isom_refresh_fragmented(GF_ISOFile *isom_file, u64 *MissingBytes, const char *new_location);\n\n/*! gets the current track fragment decode time of the track (the one of the last fragment parsed).\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return the track fragment decode time in media timescale\n*/\nu64 gf_isom_get_current_tfdt(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! gets the estimated DTS of the first sample of the next segment for SmoothStreaming files (no tfdt, no tfxd)\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return the next track fragment decode time in media timescale\n*/\nu64 gf_isom_get_smooth_next_tfdt(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! checks if the movie is a smooth streaming recomputed initial movie\n\\param isom_file the target ISO file\n\\return GF_TRUE if the file init segment (moov) was generated from external meta-data (smooth streaming)\n*/\nBool gf_isom_is_smooth_streaming_moov(GF_ISOFile *isom_file);\n\n\n/*! gets default values of samples in a track to use for track fragments default. Each variable is optional and\nif set will contain the default value for this track samples\n\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param defaultDuration set to the default duration of samples, 0 if not computable\n\\param defaultSize set to the default size of samples, 0 if not computable\n\\param defaultDescriptionIndex set to the default sample description index of samples, 0 if not computable\n\\param defaultRandomAccess set to the default sync flag of samples, 0 if not computable\n\\param defaultPadding set to the default padding bits of samples, 0 if not computable\n\\param defaultDegradationPriority set to the default degradation priority of samples, 0 if not computable\n\\return error if any*/\nGF_Err gf_isom_get_fragment_defaults(GF_ISOFile *isom_file, u32 trackNumber,\n                                     u32 *defaultDuration, u32 *defaultSize, u32 *defaultDescriptionIndex,\n                                     u32 *defaultRandomAccess, u8 *defaultPadding, u16 *defaultDegradationPriority);\n\n\n\n/*! gets last UTC/timestamp values indicated for the reference track in the file if any (pfrt box)\n\\param isom_file the target ISO file\n\\param refTrackID set to the ID of the reference track used by the pfrt box\n\\param ntp set to the NTP timestamp found\n\\param timestamp set to the corresponding media timestamp in refTrackID timescale\n\\param reset_info if GF_TRUE, discards current NTP mapping info; this will trigger parsing of the next prft box found. If not set, subsequent pfrt boxes will not be parsed until the function is called with reset_info=GF_TRUE\n\\return GF_FALSE if no info found, GF_TRUE if OK\n*/\nBool gf_isom_get_last_producer_time_box(GF_ISOFile *isom_file, GF_ISOTrackID *refTrackID, u64 *ntp, u64 *timestamp, Bool reset_info);\n\n/*! enables storage of traf templates (serialized sidx/moof/traf without trun/senc) at segment boundaries\nThis is mostly used to recreate identical segment information when refragmenting a file\n\\param isom_file the target ISO file\n*/\nvoid gf_isom_enable_traf_map_templates(GF_ISOFile *isom_file);\n/*! get byte range of root sidx if any\n\\param isom_file the target ISO file\n\\param start set to start offset (0=first byte) of the root sidx\n\\param end set to end offset (0 if no sidx) of the root sidx\n\\return true if success\n*/\nBool gf_isom_get_root_sidx_offsets(GF_ISOFile *isom_file, u64 *start, u64 *end);\n\n/*! Segment boundary information*/\ntypedef struct\n{\n\t/*! fragment start offset*/\n\tu64 frag_start;\n\t/*! mdat end offset*/\n\tu64 mdat_end;\n\t/*segment start offset plus one:\n\t\t0 if regular fragment, 1 if dash segment, offset indicates start of segment (styp or sidx)\n\t\tif sidx, it is written in the moof_template\n\t*/\n\tu64 seg_start_plus_one;\n\n\t/*! serialized array of styp (if present) sidx (if present) and moof with only the current traf*/\n\tconst u8 *moof_template;\n\t/*! size of serialized buffer*/\n\tu32 moof_template_size;\n\t/*! sidx start, 0 if absent*/\n\tu64 sidx_start;\n\t/*! sidx end, 0 if absent*/\n\tu64 sidx_end;\n\t/*! DTS of first sample in this fragment fotr the queried track*/\n\tu64 first_dts;\n} GF_ISOFragmentBoundaryInfo;\n\n/*! checks if a sample is a fragment start\nOnly use this function if \\ref gf_isom_enable_traf_map_templates has been called\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleNum the target sample number\n\\param frag_info filled with information on fragment boundaries (optional - can be NULL)\n\\return GF_TRUE if this sample was the first sample of a traf in the fragmented source file, GF_FALSE otherwise*/\nBool gf_isom_sample_is_fragment_start(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleNum, GF_ISOFragmentBoundaryInfo *frag_info);\n\n/*! releases current movie segment. This closes the associated file IO object.\n\\note seeking in the file is no longer possible when tables are rested\n\\warning The sample count is not reseted after the release of tables. use \\ref gf_isom_reset_tables for this\n\n\\param isom_file the target ISO file\n\\param reset_tables if set, sample information for all tracks setup as segment are destroyed, along with all PSSH boxes. This allows keeping the memory footprint low when playing segments.\n\\return error if any\n*/\nGF_Err gf_isom_release_segment(GF_ISOFile *isom_file, Bool reset_tables);\n\n#endif //GPAC_DISABLE_ISOM_FRAGMENTS\n\n\n/*! resets sample information for all tracks setup. This allows keeping the memory footprint low when playing DASH/CMAF segments\n\\note seeking in the file is then no longer possible\n\\param isom_file the target ISO file\n\\param reset_sample_count if GF_TRUE, sets sample count of all tracks back to 0\n\\return error if any\n*/\nGF_Err gf_isom_reset_tables(GF_ISOFile *isom_file, Bool reset_sample_count);\n\n/*! sets the offset for parsing from the input buffer to 0 (used to reclaim input buffer)\n\\param isom_file the target ISO file\n\\param top_box_start set to the byte offset in the source buffer of the first top level box, may be NULL\n\\return error if any\n*/\nGF_Err gf_isom_reset_data_offset(GF_ISOFile *isom_file, u64 *top_box_start);\n\n/*! Flags for gf_isom_open_segment*/\ntypedef enum\n{\n\t/*! do not check for movie fragment sequence number*/\n\tGF_ISOM_SEGMENT_NO_ORDER_FLAG = 1,\n\t/*! the segment contains a scalable layer of the last opened segment*/\n\tGF_ISOM_SEGMENT_SCALABLE_FLAG = 1<<1,\n} GF_ISOSegOpenMode;\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\n/*! opens a new segment file. Access to samples in previous segments is no longer possible\nif end_range>start_range, restricts the URL to the given byterange when parsing\n\n\\param isom_file the target ISO file\n\\param fileName the file name of the new segment to open\n\\param start_range the start offset in bytes in the file of the segment data\n\\param end_range the end offset in bytes in the file of the segment data\n\\param flags flags to use when opening the segment\n\\return error if any\n*/\nGF_Err gf_isom_open_segment(GF_ISOFile *isom_file, const char *fileName, u64 start_range, u64 end_range, GF_ISOSegOpenMode flags);\n\n/*! returns the track ID of the track containing the highest enhancement layer for the given base track\n\\param isom_file the target ISO file\n\\param for_base_track the number of the base track\n\\return the track ID of the highest enahnacement track\n*/\nGF_ISOTrackID gf_isom_get_highest_track_in_scalable_segment(GF_ISOFile *isom_file, u32 for_base_track);\n\n/*! resets internal info (track fragement decode time, number of samples, next moof number)used with fragments and segment.\n\\note This should be called when seeking (with keep_sample_count=0) or when loading a media segments with the same timing as the previously loaded segment\n\\param isom_file the target ISO file\n\\param keep_sample_count if GF_TRUE, does not reset the sample count on tracks\n*/\nvoid gf_isom_reset_fragment_info(GF_ISOFile *isom_file, Bool keep_sample_count);\n\n/*! resets sample count to 0 and next moof number to 0. When doing scalable media, should be called before opening the segment containing\nthe base layer in order to make sure the sample count base number is always the same (ie 1) on all tracks\n\\param isom_file the target ISO file\n*/\nvoid gf_isom_reset_sample_count(GF_ISOFile *isom_file);\n/*! resets moof sequence number to 0\n\\param isom_file the target ISO file\n*/\nvoid gf_isom_reset_seq_num(GF_ISOFile *isom_file);\n\n/*! gets the duration of movie+fragments\n\\param isom_file the target ISO file\n\\return the duration in movie timescale, 0 if unknown or if error*/\nu64 gf_isom_get_fragmented_duration(GF_ISOFile *isom_file);\n\n/*! gets the number of fragments or segments when the file is opened in \\ref GF_ISOM_OPEN_READ_DUMP mode\n\\param isom_file the target ISO file\n\\param segments_only if set to GF_TRUE, counts segments (sidx), otherwise counts fragments\n\\return the number of segments or fragments\n*/\nu32 gf_isom_get_fragments_count(GF_ISOFile *isom_file, Bool segments_only);\n\n/*! gets total sample number and duration when the file is opened in \\ref GF_ISOM_OPEN_READ_DUMP mode\n\\param isom_file the target ISO file\n\\param trackID the ID of the target track\n\\param nb_samples set to the number of samples in the track\n\\param duration set to the total duration in media timescale\n\\return error if any\n*/\nGF_Err gf_isom_get_fragmented_samples_info(GF_ISOFile *isom_file, GF_ISOTrackID trackID, u32 *nb_samples, u64 *duration);\n\n/*! gets the number of the next moof to be produced\n\\param isom_file the target ISO file\n\\return number of the next moof\n*/\nu32 gf_isom_get_next_moof_number(GF_ISOFile *isom_file);\n\n/*! @} */\n#endif //GPAC_DISABLE_ISOM_FRAGMENTS\n\n\n/*!\n\\addtogroup isoudta_grp ISOBMFF UserData Manipulation\n\\ingroup iso_grp\n\n\t\t\t\tUser Data Manipulation\n\nYou can add specific typed data to either a track or the movie: the UserData\n\tThe type must be formatted as a FourCC if you have a registered 4CC type\n\tbut the usual is to set a UUID (128 bit ID for box type) which never conflict\n\twith existing structures in the format\n\t\tTo manipulate a UUID user data set the UserDataType to 0 and specify a valid UUID.\nOtherwise the UUID parameter is ignored\n\t\tSeveral items with the same ID or UUID can be added (this allows you to store any\n\tkind/number of private information under a unique ID / UUID)\n\n@{\n*/\n\n/*! gets number of udta (user data) entries of a movie or track\n\\param isom_file the target ISO file\n\\param trackNumber the target track if not 0; if 0, the movie udta is checked\n\\return the number of entries in UDTA*/\nu32 gf_isom_get_udta_count(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! checks type of a given udta entry\n\\param isom_file the target ISO file\n\\param trackNumber the target track if not 0; if 0, the movie udta is checked\n\\param udta_idx 1-based index of the user data to query\n\\param UserDataType set to the four character code of the user data entry (optional, can be NULL)\n\\param UUID set to the UUID of the user data entry (optional, can be NULL)\n\\return error if any*/\nGF_Err gf_isom_get_udta_type(GF_ISOFile *isom_file, u32 trackNumber, u32 udta_idx, u32 *UserDataType, bin128 *UUID);\n\n/*! gets the number of UserDataItems with the same ID / UUID in the desired track or movie\n\\param isom_file the target ISO file\n\\param trackNumber the target track if not 0; if 0, the movie udta is checked\n\\param UserDataType the four character code of the user data entry to query\n\\param UUID the UUID of the user data entry\n\\return number of UDTA entries with the given type*/\nu32 gf_isom_get_user_data_count(GF_ISOFile *isom_file, u32 trackNumber, u32 UserDataType, bin128 UUID);\n\n/*! gets the UserData for the specified item from the track or the movie\n\\param isom_file the target ISO file\n\\param trackNumber the target track if not 0; if 0, the movie udta is checked\n\\param UserDataType the four character code of the user data entry to query\n\\param UUID the UUID of the user data entry\n\\param UserDataIndex 1-based index of the user data of the given type to fetch. If 0, all boxes with type==UserDataType will be serialized (including box header and size) in the output buffer\n\\param userData set to a newly allocated buffer containing the serialized data - shall be freed by caller, you must pass (userData != NULL && *userData=NULL)\n\\param userDataSize set to the size of the allocated buffer\n\\return error if any*/\nGF_Err gf_isom_get_user_data(GF_ISOFile *isom_file, u32 trackNumber, u32 UserDataType, bin128 UUID, u32 UserDataIndex, u8 **userData, u32 *userDataSize);\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n/*! adds a user data item in the desired track or in the movie\n\\param isom_file the target ISO file\n\\param trackNumber the target track for the user data; if 0, adds user data to the movie\n\\param UserDataType the user data four character code type\n\\param UUID the user data UUID\n\\param data the data to add, may be NULL\n\\param size the size of the data to add, shall be 0 when data is NULL\n\\return error if any\n*/\nGF_Err gf_isom_add_user_data(GF_ISOFile *isom_file, u32 trackNumber, u32 UserDataType, bin128 UUID, u8 *data, u32 size);\n\n/*! removes all user data items from a track or movie\n\\param isom_file the target ISO file\n\\param trackNumber the target track for the user data; if 0, adds user data to the movie\n\\param UserDataType the user data four character code type\n\\param UUID the user data UUID\n\\return error if any\n*/\nGF_Err gf_isom_remove_user_data(GF_ISOFile *isom_file, u32 trackNumber, u32 UserDataType, bin128 UUID);\n\n/*! removes a user data item from a track or movie\nuse the UDAT read functions to get the item index\n\\param isom_file the target ISO file\n\\param trackNumber the target track for the user data; if 0, adds user data to the movie\n\\param UserDataType the user data four character code type\n\\param UUID the user data UUID\n\\param UserDataIndex the 1-based index of the user data item to remove - see \\ref gf_isom_get_user_data_count\n\\return error if any\n*/\nGF_Err gf_isom_remove_user_data_item(GF_ISOFile *isom_file, u32 trackNumber, u32 UserDataType, bin128 UUID, u32 UserDataIndex);\n\n/*! adds a user data item in a track or movie using a serialzed buffer of ISOBMFF boxes\n\\param isom_file the target ISO file\n\\param trackNumber the target track for the udta box; if 0, add the udta to the movie;\n\\param data the serialized udta box to add, shall not be NULL\n\\param size the size of the data to add\n\\return error if any\n*/\nGF_Err gf_isom_add_user_data_boxes(GF_ISOFile *isom_file, u32 trackNumber, u8 *data, u32 size);\n\n/*! gets serialized user data box of a movie\n\\param isom_file the destination ISO file\n\\param output will be set to a newly allocated buffer containing the serialized box - caller shall free it\n\\param output_size will be set to the size of the allocated buffer\n\\return error if any\n*/\nGF_Err gf_isom_get_raw_user_data(GF_ISOFile *isom_file, u8 **output, u32 *output_size);\n\n#endif //GPAC_DISABLE_ISOM_WRITE\n\n/*! @} */\n\n\n#if !defined(GPAC_DISABLE_ISOM_FRAGMENTS) && !defined(GPAC_DISABLE_ISOM_WRITE)\n\n/*!\n\\addtogroup isofragwrite_grp Fragmented ISOBMFF Writing\n\\ingroup iso_grp\n\n\t\t\tMovie Fragments Writing API\n\t\tMovie Fragments is a feature of ISO media files for fragmentation\n\tof a presentation meta-data and interleaving with its media data.\n\tThis enables faster http fast start for big movies, and also reduces the risk\n\tof data loss in case of a recording crash, because meta data and media data\n\tcan be written to disk at regular times\n\t\tThis API provides simple function calls to setup such a movie and write it\n\tThe process implies:\n\t\t1- creating a movie in the usual way (track, stream descriptions, (IOD setup\n\tcopyright, ...)\n\t\t2- possibly add some samples in the regular fashion\n\t\t3- setup track fragments for all track that will be written in a fragmented way\n\t(note that you can create/write a track that has no fragmentation at all)\n\t\t4- finalize the movie for fragmentation (this will flush all meta-data and\n\tany media-data added to disk, ensuring all vital information for the presentation\n\tis stored on file and not lost in case of crash/poweroff)\n\n\t  then 5-6 as often as desired\n\t\t5- start a new movie fragment\n\t\t6- add samples to each setup track\n\n\n  IMPORTANT NOTES:\n\t\t* Movie Fragments can only be used in GF_ISOM_OPEN_WRITE mode (capturing)\n  and no editing functionalities can be used\n\t\t* the fragmented movie API uses TrackID and not TrackNumber\n\n@{\n*/\n\n/*! flag indicating default samples are sync*/\n#define GF_ISOM_FRAG_DEF_IS_SYNC 1\n/*! flag indicating a sync sample table shall be added in the track - cf CMAF rules*/\n#define GF_ISOM_FRAG_USE_SYNC_TABLE (1<<1)\n\n/*! sets up a track for fragmentation by specifying some default values for storage efficiency\n\\note If all the defaults are 0, traf flags will always be used to signal them.\n\\param isom_file the target ISO file\n\\param TrackID ID of the target track\n\\param DefaultSampleDescriptionIndex the default description used by samples in this track\n\\param DefaultSampleDuration default duration of samples in this track\n\\param DefaultSampleSize default size of samples in this track (0 if unknown)\n\\param DefaultSampleSyncFlags combination of GF_ISOM_FRAG_* flags\n\\param DefaultSamplePadding default padding bits for samples in this track\n\\param DefaultDegradationPriority default degradation priority for samples in this track\n\\param force_traf_flags if GF_TRUE, will ignore these default in each traf but will still write them in moov\n\\return error if any\n*/\nGF_Err gf_isom_setup_track_fragment(GF_ISOFile *isom_file, GF_ISOTrackID TrackID,\n                                    u32 DefaultSampleDescriptionIndex,\n                                    u32 DefaultSampleDuration,\n                                    u32 DefaultSampleSize,\n                                    u8 DefaultSampleSyncFlags,\n                                    u8 DefaultSamplePadding,\n                                    u16 DefaultDegradationPriority,\n\t\t\t\t\t\t\t\t\tBool force_traf_flags);\n\n/*! changes the default parameters of an existing trak fragment\n\\warning This should not be used if samples have already been added\n\n\\param isom_file the target ISO file\n\\param TrackID ID of the target track\n\\param DefaultSampleDescriptionIndex the default description used by samples in this track\n\\param DefaultSampleDuration default duration of samples in this track\n\\param DefaultSampleSize default size of samples in this track (0 if unknown)\n\\param DefaultSampleIsSync default key-flag (RAP) of samples in this track\n\\param DefaultSamplePadding default padding bits for samples in this track\n\\param DefaultDegradationPriority default degradation priority for samples in this track\n\\param force_traf_flags if GF_TRUE, will ignore these default in each traf but will still write them in moov\n\\return error if any\n*/\nGF_Err gf_isom_change_track_fragment_defaults(GF_ISOFile *isom_file, GF_ISOTrackID TrackID,\n        u32 DefaultSampleDescriptionIndex,\n        u32 DefaultSampleDuration,\n        u32 DefaultSampleSize,\n        u8 DefaultSampleIsSync,\n        u8 DefaultSamplePadding,\n        u16 DefaultDegradationPriority,\n        u8 force_traf_flags);\n\n/*! flushes data to disk and prepare movie fragmentation\n\\param isom_file the target ISO file\n\\param media_segment_type 0 if no segments, 1 if regular segment, 2 if single segment\n\\param mvex_after_tracks forces writing mvex box after track boxes\n\\return error if any\n*/\nGF_Err gf_isom_finalize_for_fragment(GF_ISOFile *isom_file, u32 media_segment_type, Bool mvex_after_tracks);\n\n/*! sets the duration of the movie in case of movie fragments\n\\param isom_file the target ISO file\n\\param duration the complete duration (movie and all fragments) in movie timescale\n\\param remove_mehd force removal of mehd box, only setting mvhd.duration to 0\n\\return error if any\n*/\nGF_Err gf_isom_set_movie_duration(GF_ISOFile *isom_file, u64 duration, Bool remove_mehd);\n\n/*! fragment creatio option*/\ntypedef enum\n{\n\t/*! moof is stored before mdat - will require temporary storage of data in memory*/\n\tGF_ISOM_FRAG_MOOF_FIRST = 1,\n#ifdef GF_ENABLE_CTRN\n\t/*! use compact fragment syntax*/\n\tGF_ISOM_FRAG_USE_COMPACT = 1<<1,\n#endif\n} GF_ISOStartFragmentFlags;\n/*! starts a new movie fragment\n\\param isom_file the target ISO file\n\\param moof_first if GF_TRUE, the moof will be written before the mdat\n\\return error if any\n*/\nGF_Err gf_isom_start_fragment(GF_ISOFile *isom_file, GF_ISOStartFragmentFlags moof_first);\n\n/*! starts a new segment in the file\n\\param isom_file the target ISO file\n\\param SegName if not NULL, the output will be written in the SegName file. If NULL, segment will be created in same file as movie. The special name \"_gpac_isobmff_redirect\" is used to indicate that segment shall be written to a memory buffer passed to callback function set through \\ref gf_isom_set_write_callback\n\\param memory_mode if set, all samples writing is done in memory rather than on disk. Ignored in callback mode\n\\return error if any\n*/\nGF_Err gf_isom_start_segment(GF_ISOFile *isom_file, const char *SegName, Bool memory_mode);\n\n/*! sets the baseMediaDecodeTime of the first sample of the given track\n\\param isom_file the target ISO file\n\\param TrackID ID of the target track\n\\param decode_time the decode time in media timescale\n\\return error if any\n*/\nGF_Err gf_isom_set_traf_base_media_decode_time(GF_ISOFile *isom_file, GF_ISOTrackID TrackID, u64 decode_time);\n\n/*! enables mfra (movie fragment random access computing) when writing movie fragments\n\\note this should only be used when generating segments in a single file\n\\param isom_file the target ISO file\n\\return error if any\n*/\nGF_Err gf_isom_enable_mfra(GF_ISOFile *isom_file);\n\n/*! sets Microsoft Smooth Streaming traf 'tfxd' box info, written at the end of each traf\n\\param isom_file the target ISO file\n\\param reference_track_ID ID of the reference track giving the media timescale\n\\param decode_traf_time decode time of the first sample in the segment in media timescale (hardcoded to 10MHz in Smooth)\n\\param traf_duration duration of all samples in the traf in media timescale (hardcoded to 10MHz in Smooth)\n\\return error if any\n*/\nGF_Err gf_isom_set_traf_mss_timeext(GF_ISOFile *isom_file, GF_ISOTrackID reference_track_ID, u64 decode_traf_time, u64 traf_duration);\n\n/*! closes current segment, producing a segment index box if desired\n\\param isom_file the target ISO file\n\\param subsegs_per_sidx number of subsegments per sidx box; a negative value disables sidx, 0 forces a single sidx for the segment (or subsegment)\n\\param referenceTrackID the ID of the track used as a reference for the segment index box\n\\param ref_track_decode_time the decode time fo the first sample in the reference track for this segment\n\\param timestamp_shift the constant difference between media time and presentation time (derived from edit list)\n\\param ref_track_next_cts the CTS of the first sample in the reference track in the next segment\n\\param daisy_chain_sidx if GF_TRUE, indicates chained sidx shall be used. Otherwise, an array of indexes is used\n\\param use_ssix if GF_TRUE, produces an ssix box using I-frames as first level and all other frames as second level\n\\param last_segment indicates if this is the last segment of the session\n\\param close_segment_handle if set to GF_TRUE, the associated file if any will be closed\n\\param segment_marker_4cc a four character code used to insert an empty box at the end of the saegment with the given type. If 0, no such box is inserted\n\\param index_start_range set to the start offset in bytes of the segment in the media file\n\\param index_end_range set to the end offset in bytes of the segment in the media file\n\\param out_seg_size set to the segment size in bytes (optional, can be NULL)\n\\return error if any\n*/\nGF_Err gf_isom_close_segment(GF_ISOFile *isom_file, s32 subsegs_per_sidx, GF_ISOTrackID referenceTrackID, u64 ref_track_decode_time, s32 timestamp_shift, u64 ref_track_next_cts, Bool daisy_chain_sidx, Bool use_ssix, Bool last_segment, Bool close_segment_handle, u32 segment_marker_4cc, u64 *index_start_range, u64 *index_end_range, u64 *out_seg_size);\n\n/*! writes any pending fragment to file for low-latency output.\n\\warning This shall only be used if no SIDX is used: subsegs_per_sidx<0 or flushing all fragments before calling \\ref gf_isom_close_segment\n\n\\param isom_file the target ISO file\n\\param last_segment indicates if this is the last segment of the session\n\\return error if any\n*/\nGF_Err gf_isom_flush_fragments(GF_ISOFile *isom_file, Bool last_segment);\n\n/*! sets fragment prft box info, written just before the moof\n\\param isom_file the target ISO file\n\\param reference_track_ID the ID of the track used as a reference for media timestamps\n\\param ntp absolute NTP time\n\\param timestamp media time corresponding to the NTP time, in reference track media timescale\n\\return error if any\n*/\nGF_Err gf_isom_set_fragment_reference_time(GF_ISOFile *isom_file, GF_ISOTrackID reference_track_ID, u64 ntp, u64 timestamp);\n\n/*! writes an empty sidx in the current movie.\n\nThe SIDX will be forced to have nb_segs entries, and nb_segs shall match the number of calls to\n\\ref gf_isom_close_segment that will follow.\nThis avoids wasting time and disk space moving data around. Once \\ref gf_isom_close_segment has then been called nb_segs times,\nthe pre-allocated SIDX is destroyed and successive calls to \\ref gf_isom_close_segment will create their own sidx, unless gf_isom_allocate_sidx is called again.\n\n\\param isom_file the target ISO file\n\\param subsegs_per_sidx reserved to 0, currently ignored\n\\param daisy_chain_sidx reserved to 0, currently ignored\n\\param nb_segs number of entries in the segment index\n\\param frags_per_segment reserved, currently ignored\n\\param start_range set to the start offset in bytes of the segment index box\n\\param end_range set to the end offset in bytes of the segment index box\n\\param use_ssix if GF_TRUE, produces an ssix box using I-frames as first level and all other frames as second level\n\\return error if any\n*/\nGF_Err gf_isom_allocate_sidx(GF_ISOFile *isom_file, s32 subsegs_per_sidx, Bool daisy_chain_sidx, u32 nb_segs, u32 *frags_per_segment, u32 *start_range, u32 *end_range, Bool use_ssix);\n\n/*! sets up track fragment defaults using the given template. The template shall be a serialized array of one or more trex boxes\n\n\\param isom_file the target ISO file\n\\param TrackID ID of the target track\n\\param boxes serialized array of trex boxes\n\\param boxes_size size of the serialized array\n\\param force_traf_flags if GF_TRUE, will ignore these default in each traf but will still write them in moov\n\\return error if any\n*/\nGF_Err gf_isom_setup_track_fragment_template(GF_ISOFile *isom_file, GF_ISOTrackID TrackID, u8 *boxes, u32 boxes_size, u8 force_traf_flags);\n\n#ifdef GF_ENABLE_CTRN\n/*! enables track fragment inheriting from a given traf.\nThis shall only be set when the inherited traf shares exactly the same syntax except the sample sizes, this library does not compute which\nsample values can be inherited\n\n\\param isom_file the target ISO file\n\\param TrackID ID of the target track\n\\param BaseTrackID ID of the track from which sample values are inherited in track fragments\n\\return error if any\n*/\nGF_Err gf_isom_enable_traf_inherit(GF_ISOFile *isom_file, GF_ISOTrackID TrackID, GF_ISOTrackID BaseTrackID);\n#endif\n\n/*! Track fragment options*/\ntypedef enum\n{\n\t/*! indicates that the track fragment has no samples but still has a duration\n\t(silence-detection in audio codecs, ...).\n\tparam: indicates duration*/\n\tGF_ISOM_TRAF_EMPTY,\n\t/*! I-Frame detection: this can reduce file size by detecting I-frames and\n\toptimizing sample flags (padding, priority, ..)\n\tparam: on/off (0/1)*/\n\tGF_ISOM_TRAF_RANDOM_ACCESS,\n\t/*! activate data cache on track fragment. This is useful when writing interleaved\n\tmedia from a live source (typically audio-video), and greatly reduces file size\n\tparam: Number of samples (> 1) to cache before disk flushing. You shouldn't try\n\tto cache too many samples since this will load your memory. base that on FPS/SR*/\n\tGF_ISOM_TRAF_DATA_CACHE,\n\t/*! forces moof base offsets when traf based offsets would be chosen\n\tparam: on/off (0/1)*/\n\tGF_ISOM_TFHD_FORCE_MOOF_BASE_OFFSET,\n\t/*! use sdtp box in traf rather than storing sample deps in trun entry. param values are:\n\t\t0: disables sdtp\n\t\t1: enables sdtp and disables sample dependency flags in trun\n\t\t2: enables sdtp and also use sample dependency flags in trun\n\t*/\n\tGF_ISOM_TRAF_USE_SAMPLE_DEPS_BOX,\n\t/*! forces new trun at next sample add\n\tparam: ignored*/\n\tGF_ISOM_TRUN_FORCE,\n\t/*! sets interleave group ID of the  next sample add. Samples with lower interleave ID will be stored first, creating new trun whenever a new group is detected\n\tThis will enable data cache\n\tparam: interleave ID*/\n\tGF_ISOM_TRUN_SET_INTERLEAVE_ID,\n\t/*! store truns before sample encryption and sample groups info\n \tparam: 1 to store before and follow CMAF (recommended?) order, 0, to store after*/\n\tGF_ISOM_TRAF_TRUNS_FIRST,\n\t/*! forces trun v1\n\tparam: on/off (0/1)*/\n\tGF_ISOM_TRAF_TRUN_V1,\n\t/*force usage of 64 bits in tfdt and in per-segment sidx*/\n\tGF_ISOM_TRAF_USE_LARGE_TFDT\n} GF_ISOTrackFragmentOption;\n\n/*! sets a track fragment option. Options can be set at the beginning of each new fragment only, and for the\nlifetime of the fragment\n\\param isom_file the target ISO file\n\\param TrackID ID of the target track\n\\param Code the option type to set\n\\param param the option value\n\\return error if any\n*/\nGF_Err gf_isom_set_fragment_option(GF_ISOFile *isom_file, GF_ISOTrackID TrackID, GF_ISOTrackFragmentOption Code, u32 param);\n\n/*! adds a sample to a fragmented track\n\n\\param isom_file the target ISO file\n\\param TrackID destination track\n\\param sample sample to add\n\\param sampleDescriptionIndex sample description for this sample. If 0, the default one\nis used\n\\param Duration sample duration; the sample duration MUST be provided at least for the last sample (for intermediate samples, it is recomputed internally by the lib)\n\\param PaddingBits padding bits for the sample, or 0\n\\param DegradationPriority for the sample, or 0\n\\param redundantCoding indicates this is samples acts as a sync shadow point\n\\return error if any\n*/\nGF_Err gf_isom_fragment_add_sample(GF_ISOFile *isom_file, GF_ISOTrackID TrackID, const GF_ISOSample *sample,\n                                   u32 sampleDescriptionIndex,\n                                   u32 Duration, u8 PaddingBits, u16 DegradationPriority, Bool redundantCoding);\n\n/*! appends data into last sample of track for video fragments/other media\n\\warning This shall not be used with OD tracks\n\\param isom_file the target ISO file\n\\param TrackID destination track\n\\param data the data to append\n\\param data_size the size of the data to append\n\\param PaddingBits padding bits for the sample, or 0\n\\return error if any\n*/\nGF_Err gf_isom_fragment_append_data(GF_ISOFile *isom_file, GF_ISOTrackID TrackID, u8 *data, u32 data_size, u8 PaddingBits);\n\n\n/*! sets side information for common encryption for the last added sample\n\\param isom_file the target ISO file\n\\param trackID the ID of the target track\n\\param sai_b buffer containing the SAI information of the sample\n\\param sai_b_size size of the SAI buffer. If sai_b is NULL or sai_b_size is 0, add a clear SAI data\n\\param use_subsample indicates if the media uses CENC subsamples\n\\param use_saio_32bit indicates if 32-bit saio shall be used\n\\param use_multikey indicates if multikey is in use (required to tag saiz/saio boxes)\n\\return error if any\n*/\nGF_Err gf_isom_fragment_set_cenc_sai(GF_ISOFile *isom_file, GF_ISOTrackID trackID, u8 *sai_b, u32 sai_b_size, Bool use_subsample, Bool use_saio_32bit, Bool use_multikey);\n\n#endif // !defined(GPAC_DISABLE_ISOM_FRAGMENTS) && !defined(GPAC_DISABLE_ISOM_WRITE)\n\n#if !defined(GPAC_DISABLE_ISOM_WRITE)\n\n/*! clones PSSH data between two files\n\\param dst_file the target ISO file\n\\param src_file the source ISO file\n\\param in_moof if GF_TRUE, indicates the pssh should be cloned in current moof box\n\\return error if any\n*/\nGF_Err gf_isom_clone_pssh(GF_ISOFile *dst_file, GF_ISOFile *src_file, Bool in_moof);\n\n#endif\n\n\n#if !defined(GPAC_DISABLE_ISOM_FRAGMENTS) && !defined(GPAC_DISABLE_ISOM_WRITE)\n\n/*! sets roll information for a sample in a track fragment\n\\param isom_file the target ISO file\n\\param trackID the ID of the target track\n\\param sample_number the sample number of the last sample\n\\param roll_type indicate the sample roll type\n\\param roll_distance set to the roll distance for a roll sample\n\\return error if any\n*/\nGF_Err gf_isom_fragment_set_sample_roll_group(GF_ISOFile *isom_file, GF_ISOTrackID trackID, u32 sample_number, GF_ISOSampleRollType roll_type, s16 roll_distance);\n\n/*! sets rap information for a sample in a track fragment\n\\param isom_file the target ISO file\n\\param trackID the ID of the target track\n\\param sample_number_in_frag the sample number of the sample in the traf\n\\param is_rap set to GF_TRUE to indicate the sample is a RAP sample (open-GOP), GF_FALSE otherwise\n\\param num_leading_samples set to the number of leading pictures for a RAP sample\n\\return error if any\n*/\nGF_Err gf_isom_fragment_set_sample_rap_group(GF_ISOFile *isom_file, GF_ISOTrackID trackID, u32 sample_number_in_frag, Bool is_rap, u32 num_leading_samples);\n\n/*! sets sample dependency flags in a track fragment - see ISO/IEC 14496-12 and \\ref gf_filter_pck_set_dependency_flags\n\\param isom_file the target ISO file\n\\param trackID the ID of the target track\n\\param is_leading indicates that the sample is a leading picture\n\\param dependsOn indicates the sample dependency towards other samples\n\\param dependedOn indicates the sample dependency from other samples\n\\param redundant indicates that the sample contains redundant coding\n\\return error if any\n*/\nGF_Err gf_isom_fragment_set_sample_flags(GF_ISOFile *isom_file, GF_ISOTrackID trackID, u32 is_leading, u32 dependsOn, u32 dependedOn, u32 redundant);\n\n\n\n/*! adds sample auxiliary data\n\n\\param isom_file the target ISO file\n\\param trackID the ID of the target track\n\\param sample_number_in_frag the sample number in the current fragment. Must be equal or larger to last auxiliary added\n\\param aux_type auxiliary sample data type, shall not be 0\n\\param aux_info auxiliary sample data specific info type, may be 0\n\\param data data to add\n\\param size size of data to add\n\\return error if any\n*/\nGF_Err gf_isom_fragment_set_sample_aux_info(GF_ISOFile *isom_file, u32 trackID, u32 sample_number_in_frag, u32 aux_type, u32 aux_info, u8 *data, u32 size);\n\n\n/*! sets the number of the next moof to be produced\n\\param isom_file the target ISO file\n\\param value the number of the next moof\n*/\nvoid gf_isom_set_next_moof_number(GF_ISOFile *isom_file, u32 value);\n\n\n/*! @} */\n#endif// !defined(GPAC_DISABLE_ISOM_FRAGMENTS) && !defined(GPAC_DISABLE_ISOM_WRITE)\n\n\n/*!\n\\addtogroup isortp_grp ISOBMFF RTP Hinting\n\\ingroup iso_grp\n\n@{\n*/\n\n/*! supported hint formats - ONLY RTP now*/\ntypedef enum\n{\n\t/*! RTP hint type*/\n\tGF_ISOM_HINT_RTP = GF_4CC('r', 't', 'p', ' '),\n} GF_ISOHintFormat;\n\n#if !defined(GPAC_DISABLE_ISOM_WRITE) && !defined(GPAC_DISABLE_ISOM_HINTING)\n\n/*! sets up a hint track based on the hint format\n\\warning This function MUST be called after creating a new hint track and before any other calls on this track\n\\param isom_file the target ISO file\n\\param trackNumber the target hint track\n\\param HintType the desired hint type\n\\return error if any\n*/\nGF_Err gf_isom_setup_hint_track(GF_ISOFile *isom_file, u32 trackNumber, GF_ISOHintFormat HintType);\n\n/*! creates a HintDescription for the HintTrack\n\\param isom_file the target ISO file\n\\param trackNumber the target hint track\n\\param HintTrackVersion version of hint track\n\\param LastCompatibleVersion last compatible version of hint track\n\\param Rely flag indicating whether a reliable transport protocol is desired/required\nfor data transport\n\t0: not desired (UDP/IP). NB: most RTP streaming servers only support UDP/IP for data\n\t1: preferable (TCP/IP if possible or UDP/IP)\n\t2: required (TCP/IP only)\n\\param HintDescriptionIndex is set to the newly created hint sample description index\n\\return error if any\n*/\nGF_Err gf_isom_new_hint_description(GF_ISOFile *isom_file, u32 trackNumber, s32 HintTrackVersion, s32 LastCompatibleVersion, u8 Rely, u32 *HintDescriptionIndex);\n\n/*! starts a new sample for the hint track. A sample is just a collection of packets\nthe transmissionTime is indicated in the media timeScale of the hint track\n\\param isom_file the target ISO file\n\\param trackNumber the target hint track\n\\param HintDescriptionIndex the target hint sample description index\n\\param TransmissionTime the target transmission time in hint media timescale\n\\return error if any\n*/\nGF_Err gf_isom_begin_hint_sample(GF_ISOFile *isom_file, u32 trackNumber, u32 HintDescriptionIndex, u32 TransmissionTime);\n\n/*! ends an hint sample once all your packets for this sample are done\n\\param isom_file the target ISO file\n\\param trackNumber the target hint track\n\\param IsRandomAccessPoint set to GF_TRUE if you want to indicate that this is a random access point in the stream\n\\return error if any\n*/\nGF_Err gf_isom_end_hint_sample(GF_ISOFile *isom_file, u32 trackNumber, u8 IsRandomAccessPoint);\n\n\n/*!\n\t\tPacketHandling functions\n\t\tData can be added at the end or at the beginning of the current packet\n\t\tby setting AtBegin to 1 the data will be added at the beginning\n\t\tThis allows constructing the packet payload before any meta-data\n*/\n\n/*! adds a blank chunk of data in the sample that is skipped while streaming\n\\param isom_file the target ISO file\n\\param trackNumber the target hint track\n\\param AtBegin indicates if the blank chunk should be at the end or at the beginning of the hint packet\n\\return error if any\n*/\nGF_Err gf_isom_hint_blank_data(GF_ISOFile *isom_file, u32 trackNumber, u8 AtBegin);\n\n/*! adds a chunk of data in the packet that is directly copied while streaming\n\\note DataLength MUST BE <= 14 bytes, and you should only use this function\nto add small blocks of data (encrypted parts, specific headers, ...)\n\\param isom_file the target ISO file\n\\param trackNumber the target hint track\n\\param data buffer to add to the RTP packet\n\\param dataLength size of buffer to add to the RTP packet\n\\param AtBegin indicates if the blank chunk should be at the end or at the beginning of the hint packet\n\\return error if any\n*/\nGF_Err gf_isom_hint_direct_data(GF_ISOFile *isom_file, u32 trackNumber, u8 *data, u32 dataLength, u8 AtBegin);\n\n/*! adds a reference to some sample data in the packet\n\\note if you want to reference a previous HintSample in the hintTrack, you will have to parse the sample yourself ...\n\n\\param isom_file the target ISO file\n\\param trackNumber the target hint track\n\\param SourceTrackID the ID of the track where the referenced sample is\n\\param SampleNumber the sample number containing the data to be added\n\\param DataLength the length of bytes to copy in the packet\n\\param offsetInSample the offset in bytes in the sample at which to begin copying data\n\\param extra_data only used when the sample is actually the sample that will contain this packet\n(useful to store en encrypted version of a packet only available while streaming)\n\tIn this case, set SourceTrackID to the HintTrack ID and SampleNumber to 0\n\tIn this case, the DataOffset MUST BE NULL and length will indicate the extra_data size\n\\param AtBegin indicates if the blank chunk should be at the end or at the beginning of the hint packet\n\\return error if any\n*/\nGF_Err gf_isom_hint_sample_data(GF_ISOFile *isom_file, u32 trackNumber, GF_ISOTrackID SourceTrackID, u32 SampleNumber, u16 DataLength, u32 offsetInSample, u8 *extra_data, u8 AtBegin);\n\n\n/*! adds a reference to some stream description data in the packet (headers, ...)\n\n\\param isom_file the target ISO file\n\\param trackNumber the target hint track\n\\param SourceTrackID the ID of the track where the referenced sample is\n\\param sampleDescriptionIndex the index of the stream description in the desired track\n\\param DataLength the length of bytes to copy in the packet\n\\param offsetInDescription the offset in bytes in the description at which to begin copying data. Since it is far from being obvious / interoperable what this offset is, we recommend not using this function and injecting the data instead using \\ref gf_isom_hint_direct_data.\n\\param AtBegin indicates if the blank chunk should be at the end or at the beginning of the hint packet\n\\return error if any\n*/\nGF_Err gf_isom_hint_sample_description_data(GF_ISOFile *isom_file, u32 trackNumber, GF_ISOTrackID SourceTrackID, u32 sampleDescriptionIndex, u16 DataLength, u32 offsetInDescription, u8 AtBegin);\n\n\n/*! creates a new RTP packet in the HintSample. If a previous packet was created,\nit is stored in the hint sample and a new packet is created.\n\n\\param isom_file the target ISO file\n\\param trackNumber the target hint track\n\\param relativeTime RTP time offset of this packet in the HintSample if any - in hint track\ntime scale. Used for data smoothing by servers.\n\\param PackingBit the 'P' bit of the RTP packet header\n\\param eXtensionBit the'X' bit of the RTP packet header\n\\param MarkerBit the 'M' bit of the RTP packet header\n\\param PayloadType the payload type, on 7 bits, format 0x0XXXXXXX\n\\param disposable_packet indicates if this packet can be skipped by a server\n\\param IsRepeatedPacket indicates if this is a duplicate packet of a previous one and can be skipped by a server\n\\param SequenceNumber the RTP base sequence number of the packet. Because of support for repeated packets, you have to set the sequence number yourself.\n\\return error if any\n*/\nGF_Err gf_isom_rtp_packet_begin(GF_ISOFile *isom_file, u32 trackNumber, s32 relativeTime, u8 PackingBit, u8 eXtensionBit, u8 MarkerBit, u8 PayloadType, u8 disposable_packet, u8 IsRepeatedPacket, u16 SequenceNumber);\n\n/*! sets the flags of the RTP packet\n\\param isom_file the target ISO file\n\\param trackNumber the target hint track\n\\param PackingBit the 'P' bit of the RTP packet header\n\\param eXtensionBit the'X' bit of the RTP packet header\n\\param MarkerBit the 'M' bit of the RTP packet header\n\\param disposable_packet indicates if this packet can be skipped by a server\n\\param IsRepeatedPacket indicates if this is a duplicate packet of a previous one and can be skipped by a server\n\\return error if any*/\nGF_Err gf_isom_rtp_packet_set_flags(GF_ISOFile *isom_file, u32 trackNumber, u8 PackingBit, u8 eXtensionBit, u8 MarkerBit, u8 disposable_packet, u8 IsRepeatedPacket);\n\n/*! sets the time offset of this packet. This enables packets to be placed in the hint track\nin decoding order, but have their presentation time-stamp in the transmitted\npacket in a different order. Typically used for MPEG video with B-frames\n\\param isom_file the target ISO file\n\\param trackNumber the target hint track\n\\param timeOffset time offset in RTP media timescale\n\\return error if any\n*/\nGF_Err gf_isom_rtp_packet_set_offset(GF_ISOFile *isom_file, u32 trackNumber, s32 timeOffset);\n\n\n/*! sets the RTP TimeScale that the server use to send packets\nsome RTP payloads may need a specific timeScale that is not the timeScale in the file format\nthe default timeScale choosen by the API is the MediaTimeScale of the hint track\n\\param isom_file the target ISO file\n\\param trackNumber the target hint track\n\\param HintDescriptionIndex the target hint sample description index\n\\param TimeScale the RTP timescale to use\n\\return error if any\n*/\nGF_Err gf_isom_rtp_set_timescale(GF_ISOFile *isom_file, u32 trackNumber, u32 HintDescriptionIndex, u32 TimeScale);\n\n/*! sets the RTP TimeOffset that the server will add to the packets\nif not set, the server adds a random offset\n\\param isom_file the target ISO file\n\\param trackNumber the target hint track\n\\param HintDescriptionIndex the target hint sample description index\n\\param TimeOffset the time offset in RTP timescale\n\\return error if any\n*/\nGF_Err gf_isom_rtp_set_time_offset(GF_ISOFile *isom_file, u32 trackNumber, u32 HintDescriptionIndex, u32 TimeOffset);\n\n/*! sets the RTP SequenceNumber Offset that the server will add to the packets\nif not set, the server adds a random offset\n\\param isom_file the target ISO file\n\\param trackNumber the target hint track\n\\param HintDescriptionIndex the target hint sample description index\n\\param SequenceNumberOffset the sequence number offset\n\\return error if any\n*/\nGF_Err gf_isom_rtp_set_time_sequence_offset(GF_ISOFile *isom_file, u32 trackNumber, u32 HintDescriptionIndex, u32 SequenceNumberOffset);\n\n/*! adds an SDP line to the SDP container at the track level (media-specific SDP info)\n\\note the CRLF end of line for SDP is automatically inserted\n\\param isom_file the target ISO file\n\\param trackNumber the target hint track\n\\param text the SDP text to add the target hint track\n\\return error if any\n*/\nGF_Err gf_isom_sdp_add_track_line(GF_ISOFile *isom_file, u32 trackNumber, const char *text);\n/*! removes all SDP info at the track level\n\\param isom_file the target ISO file\n\\param trackNumber the target hint track\n\\return error if any\n*/\nGF_Err gf_isom_sdp_clean_track(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! adds an SDP line to the SDP container at the movie level (presentation SDP info)\n\\note The CRLF end of line for SDP is automatically inserted\n\\param isom_file the target ISO file\n\\param text the SDP text to add the target hint track\n\\return error if any\n*/\nGF_Err gf_isom_sdp_add_line(GF_ISOFile *isom_file, const char *text);\n/*! removes all SDP info at the movie level\n\\param isom_file the target ISO file\n\\return error if any\n*/\nGF_Err gf_isom_sdp_clean(GF_ISOFile *isom_file);\n\n#endif// !defined(GPAC_DISABLE_ISOM_WRITE) && !defined(GPAC_DISABLE_ISOM_HINTING)\n\n\n#ifndef GPAC_DISABLE_ISOM_HINTING\n\n#ifndef GPAC_DISABLE_ISOM_DUMP\n/*! dumps RTP hint samples structure into XML trace file\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param SampleNum the target sample number\n\\param trace the file object to dump to\n\\return error if any\n*/\nGF_Err gf_isom_dump_hint_sample(GF_ISOFile *isom_file, u32 trackNumber, u32 SampleNum, FILE * trace);\n#endif\n\n/*! gets SDP info at the movie level\n\\param isom_file the target ISO file\n\\param sdp set to the sdp text, including a null-terminating character - do not modify\n\\param length set to the sdp length, not including the null-terminating character\n\\return error if any\n*/\nGF_Err gf_isom_sdp_get(GF_ISOFile *isom_file, const char **sdp, u32 *length);\n/*! gets SDP info at the track level\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sdp set to the sdp text, including a null-terminating character - do not modify\n\\param length set to the sdp length, not including the null-terminating character\n\\return error if any\n*/\nGF_Err gf_isom_sdp_track_get(GF_ISOFile *isom_file, u32 trackNumber, const char **sdp, u32 *length);\n/*! gets number of payload type defines for an RTP hint track\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return the number of payload types defined\n*/\nu32 gf_isom_get_payt_count(GF_ISOFile *isom_file, u32 trackNumber);\n/*! gets payload type information for an RTP hint track\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param index the payload type 1_based index\n\\param payID set to the ID of the payload type\n\\return the sdp fmtp attribute describing the payload\n*/\nconst char *gf_isom_get_payt_info(GF_ISOFile *isom_file, u32 trackNumber, u32 index, u32 *payID);\n\n\n#endif /*GPAC_DISABLE_ISOM_HINTING*/\n\n\n/*! @} */\n\n/*!\n\\addtogroup isotxt_grp Subtitles and Timed Text\n\\ingroup iso_grp\n\n@{\n*/\n\n\n/*! sets streaming text reading mode (MPEG-4 text vs 3GPP)\n\\param isom_file the target ISO file\n\\param do_convert is set, all text samples will be retrieved as TTUs and ESD will be emulated for text tracks\n\\return error if any\n*/\nGF_Err gf_isom_text_set_streaming_mode(GF_ISOFile *isom_file, Bool do_convert);\n\n\n#ifndef GPAC_DISABLE_ISOM_DUMP\n/*! text track export type*/\ntypedef enum {\n\t/*! dump as TTXT XML*/\n\tGF_TEXTDUMPTYPE_TTXT = 0,\n\t/*! dump as TTXT XML with box */\n\tGF_TEXTDUMPTYPE_TTXT_BOXES,\n\t/*! dump as SRT*/\n\tGF_TEXTDUMPTYPE_SRT,\n\t/*! dump as SVG*/\n\tGF_TEXTDUMPTYPE_SVG,\n\t/*! dump as TTXT chapters (omits empty text samples)*/\n\tGF_TEXTDUMPTYPE_TTXT_CHAP,\n\t/*! dump as OGG chapters*/\n\tGF_TEXTDUMPTYPE_OGG_CHAP,\n\t/*! dump as Zoom chapters*/\n\tGF_TEXTDUMPTYPE_ZOOM_CHAP\n} GF_TextDumpType;\n/*! dumps a text track to a file\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param dump the file object to write to (binary open mode)\n\\param dump_type the dump type mode\n\\return error if any\n*/\nGF_Err gf_isom_text_dump(GF_ISOFile *isom_file, u32 trackNumber, FILE *dump, GF_TextDumpType dump_type);\n#endif\n\n/*! gets encoded TX3G box (text sample description for 3GPP text streams) as needed by RTP or other standards:\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the sample description index\n\\param sidx_offset if 0, the sidx will NOT be written before the encoded TX3G. If not 0, the sidx will be written before the encoded TX3G, with the given offset. Offset sshould be at least 128 for most common usage of TX3G (RTP, MPEG-4 timed text, etc)\n\\param tx3g set to a newly allocated buffer containing the encoded tx3g - to be freed by caller\n\\param tx3g_size set to the size of the encoded config\n\\return error if any\n*/\nGF_Err gf_isom_text_get_encoded_tx3g(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, u32 sidx_offset, u8 **tx3g, u32 *tx3g_size);\n\n/*! sets TX3G flags for forced samples\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the sample description index\n\\param force_type if 0, no forced subs are present. If 1, some forced subs are present; if 2, all samples are forced subs\n\\return error if any\n*/\nGF_Err gf_isom_set_forced_text(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, u32 force_type);\n\n/*! text sample formatting*/\ntypedef struct _3gpp_text_sample GF_TextSample;\n/*! creates text sample handle\n\\return a newly allocated text sample\n*/\nGF_TextSample *gf_isom_new_text_sample();\n/*! destroys text sample handle\n\\param tx_samp the target text sample\n*/\nvoid gf_isom_delete_text_sample(GF_TextSample *tx_samp);\n\n/*! generic subtitle sample formatting*/\ntypedef struct _generic_subtitle_sample GF_GenericSubtitleSample;\n/*! creates generic subtitle sample handle\n\\return a newly allocated generic subtitle sample\n*/\nGF_GenericSubtitleSample *gf_isom_new_generic_subtitle_sample();\n/*! destroys generic subtitle sample handle\n\\param generic_subtitle_samp the target generic subtitle sample\n*/\nvoid gf_isom_delete_generic_subtitle_sample(GF_GenericSubtitleSample *generic_subtitle_samp);\n\n#ifndef GPAC_DISABLE_VTT\n/*! creates new WebVTT config\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param URLname URL value of the data reference, NULL if no data reference (media in the file)\n\\param URNname URN value of the data reference, NULL if no data reference (media in the file)\n\\param outDescriptionIndex set to the index of the created sample description\n\\param config the WebVTT configuration string\n\\return error if any\n*/\nGF_Err gf_isom_new_webvtt_description(GF_ISOFile *isom_file, u32 trackNumber, const char *URLname, const char *URNname, u32 *outDescriptionIndex, const char *config);\n#endif\n\n/*! gets WebVTT config for a sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\return the WebVTT configuration string\n*/\nconst char *gf_isom_get_webvtt_config(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex);\n\n/*! gets simple streaming text config for a sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\param mime set to the mime type (optional, can be NULL)\n\\param encoding set to the text encoding type (optional, can be NULL)\n\\param config set to the WebVTT configuration string (optional, can be NULL)\n\\return error if any\n*/\nGF_Err gf_isom_stxt_get_description(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, const char **mime, const char **encoding, const char **config);\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n/*! creates new simple streaming text config\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param type the four character code of the simple text sample description (sbtt, stxt, mett)\n\\param mime the mime type\n\\param encoding the text encoding, if any\n\\param config the configuration string, if any\n\\param outDescriptionIndex set to the index of the created sample description\n\\return error if any\n*/\nGF_Err gf_isom_new_stxt_description(GF_ISOFile *isom_file, u32 trackNumber, u32 type, const char *mime, const char *encoding, const char *config, u32 *outDescriptionIndex);\n\n#endif // GPAC_DISABLE_ISOM_WRITE\n\n/*! gets XML streaming text config for a sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\param xmlnamespace set to the XML namespace (optional, can be NULL)\n\\param xml_schema_loc set to the XML schema location (optional, can be NULL)\n\\param mimes set to the associated mime(s) types (optional, can be NULL)\n\\return error if any\n*/\nGF_Err gf_isom_xml_subtitle_get_description(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex,\n        const char **xmlnamespace, const char **xml_schema_loc, const char **mimes);\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n/*! creates a new XML streaming text config\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param xmlnamespace the XML namespace\n\\param xml_schema_loc the XML schema location (optional, can be NULL)\n\\param auxiliary_mimes the associated mime(s) types (optional, can be NULL)\n\\param outDescriptionIndex set to the index of the created sample description\n\\return error if any\n*/\nGF_Err gf_isom_new_xml_subtitle_description(GF_ISOFile *isom_file, u32 trackNumber,\n        const char *xmlnamespace, const char *xml_schema_loc, const char *auxiliary_mimes,\n        u32 *outDescriptionIndex);\n#endif // GPAC_DISABLE_ISOM_WRITE\n\n\n/*! gets MIME parameters  (type/subtype + codecs and profiles) associated with a sample descritpion\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\return MIME param if present, NULL otherwise\n*/\nconst char *gf_isom_subtitle_get_mime(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex);\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n/*! gets MIME parameters associated with a sample descritpion\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\param full_mime MIME param (type/subtype + codecs and profiles) to set, if NULL removes MIME parameter info\n\\return error if any\n*/\nGF_Err gf_isom_subtitle_set_mime(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, const char *full_mime);\n#endif\n\n\n/*! gets XML metadata for a sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\param xmlnamespace set to the XML namespace (optional, can be NULL)\n\\param schema_loc set to the XML schema location (optional, can be NULL)\n\\param content_encoding set to the content encoding string (optional, can be NULL)\n\\return error if any\n*/\nGF_Err gf_isom_get_xml_metadata_description(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, const char **xmlnamespace, const char **schema_loc, const char **content_encoding);\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n/*! creates a new timed metadata sample description for this track\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param xmlnamespace the XML namespace\n\\param schema_loc the XML schema location (optional, can be NULL)\n\\param content_encoding the content encoding string (optional, can be NULL)\n\\param outDescriptionIndex set to the index of the created sample description\n\\return error if any\n*/\nGF_Err gf_isom_new_xml_metadata_description(GF_ISOFile *isom_file, u32 trackNumber, const char *xmlnamespace, const char *schema_loc, const char *content_encoding, u32 *outDescriptionIndex);\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n\n/*! text flags operation type*/\ntypedef enum\n{\n\tGF_ISOM_TEXT_FLAGS_OVERWRITE = 0,\n\tGF_ISOM_TEXT_FLAGS_TOGGLE,\n\tGF_ISOM_TEXT_FLAGS_UNTOGGLE,\n} GF_TextFlagsMode;\n/*! sets text display flags according to given mode.\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index. If 0, sets the flags for all text descriptions\n\\param flags the flag to set\n\\param op_type the flag toggle mode\n\\return error if any\n*/\nGF_Err gf_isom_text_set_display_flags(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, u32 flags, GF_TextFlagsMode op_type);\n\n/*! gets text description of a sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\param out_desc set to a newly allocated text sample descriptor - shall be freeed by user\n\\return error if any\n*/\nGF_Err gf_isom_get_text_description(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, GF_TextSampleDescriptor **out_desc);\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n/*! creates a new TextSampleDescription in the file.\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param desc the text sample description\n\\param URLname URL value of the data reference, NULL if no data reference (media in the file)\n\\param URNname URN value of the data reference, NULL if no data reference (media in the file)\n\\param outDescriptionIndex set to the index of the created sample description\n\\return error if any\n*/\nGF_Err gf_isom_new_text_description(GF_ISOFile *isom_file, u32 trackNumber, GF_TextSampleDescriptor *desc, const char *URLname, const char *URNname, u32 *outDescriptionIndex);\n\n/*! resets text sample content\n\\param tx_samp the target text sample\n\\return error if any\n*/\nGF_Err gf_isom_text_reset(GF_TextSample * tx_samp);\n/*! resets text sample styles but keep text\n\\param tx_samp the target text sample\n\\return error if any\n*/\nGF_Err gf_isom_text_reset_styles(GF_TextSample *tx_samp);\n\n/*! appends text to sample - text_len is the number of bytes to be written from text_data. This allows\nhandling UTF8 and UTF16 strings in a transparent manner\n\\param tx_samp the target text sample\n\\param text_data the text data to add\n\\param text_len the size of the data to add\n\\return error if any\n*/\nGF_Err gf_isom_text_add_text(GF_TextSample *tx_samp, char *text_data, u32 text_len);\n/*! appends style modifyer to sample\n\\param tx_samp the target text sample\n\\param rec the style record to add\n\\return error if any\n*/\nGF_Err gf_isom_text_add_style(GF_TextSample *tx_samp, GF_StyleRecord *rec);\n/*! appends highlight modifier for the sample\n\\param tx_samp the target text sample\n\\param start_char first char highlighted,\n\\param end_char first char not highlighted\n\\return error if any\n*/\nGF_Err gf_isom_text_add_highlight(GF_TextSample *tx_samp, u16 start_char, u16 end_char);\n\n/*! sets highlight color for the whole sample\n\\param tx_samp the target text sample\n\\param argb color value\n\\return error if any\n*/\nGF_Err gf_isom_text_set_highlight_color(GF_TextSample *tx_samp, u32 argb);\n/*! appends a new karaoke sequence in the sample\n\\param tx_samp the target text sample\n\\param start_time karaoke start time expressed in text stream timescale, but relative to the sample media time\n\\return error if any\n*/\nGF_Err gf_isom_text_add_karaoke(GF_TextSample *tx_samp, u32 start_time);\n/*! appends a new segment in the current karaoke sequence - you must build sequences in order to be compliant\n\\param tx_samp the target text sample\n\\param end_time segment end time expressed in text stream timescale, but relative to the sample media time\n\\param start_char first char highlighted,\n\\param end_char first char not highlighted\n\\return error if any\n*/\nGF_Err gf_isom_text_set_karaoke_segment(GF_TextSample *tx_samp, u32 end_time, u16 start_char, u16 end_char);\n/*! sets scroll delay for the whole sample (scrolling is enabled through GF_TextSampleDescriptor.DisplayFlags)\n\\param tx_samp the target text sample\n\\param scroll_delay delay for scrolling expressed in text stream timescale\n\\return error if any\n*/\nGF_Err gf_isom_text_set_scroll_delay(GF_TextSample *tx_samp, u32 scroll_delay);\n/*! appends hyperlinking for the sample\n\\param tx_samp the target text sample\n\\param URL UTF-8 url\n\\param altString UTF-8 hint (tooltip, ...) for end user\n\\param start_char first char hyperlinked,\n\\param end_char first char not hyperlinked\n\\return error if any\n*/\nGF_Err gf_isom_text_add_hyperlink(GF_TextSample *tx_samp, char *URL, char *altString, u16 start_char, u16 end_char);\n/*! sets current text box (display pos&size within the text track window) for the sample\n\\param tx_samp the target text sample\n\\param top top coordinate of box\n\\param left left coordinate of box\n\\param bottom bottom coordinate of box\n\\param right right coordinate of box\n\\return error if any\n*/\nGF_Err gf_isom_text_set_box(GF_TextSample *tx_samp, s16 top, s16 left, s16 bottom, s16 right);\n/*! appends blinking for the sample\n\\param tx_samp the target text sample\n\\param start_char first char blinking,\n\\param end_char first char not blinking\n\\return error if any\n*/\nGF_Err gf_isom_text_add_blink(GF_TextSample *tx_samp, u16 start_char, u16 end_char);\n/*! sets wrap flag for the sample\n\\param tx_samp the target text sample\n\\param wrap_flags text wrap flags - currently only 0 (no wrap) and 1 (\"soft wrap\") are allowed in 3GP\n\\return error if any\n*/\nGF_Err gf_isom_text_set_wrap(GF_TextSample *tx_samp, u8 wrap_flags);\n\n/*! sets force for the sample\n\\param tx_samp the target text sample\n\\param is_force for ce sample if TRUE\n\\return error if any\n*/\nGF_Err gf_isom_text_set_forced(GF_TextSample *tx_samp, Bool is_forced);\n\n/*! formats sample as a regular GF_ISOSample payload in a bitstream object.\n\\param tx_samp the target text sample\n\\param bs thetarget bitstream\n\\return error if any\n*/\nGF_Err gf_isom_text_sample_write_bs(const GF_TextSample *tx_samp, GF_BitStream *bs);\n\n\n/*! formats sample as a regular GF_ISOSample.\nThe resulting sample will always be marked as random access\n\\param tx_samp the target text sample\n\\return the corresponding serialized ISO sample\n*/\nGF_ISOSample *gf_isom_text_to_sample(const GF_TextSample *tx_samp);\n\n/*! gets the serialized size of the text sample\n\\param tx_samp the target text sample\n\\return the serialized size\n*/\nu32 gf_isom_text_sample_size(GF_TextSample *tx_samp);\n\n/*! creates a new XML subtitle sample\n\\return a new XML subtitle sample\n*/\nGF_GenericSubtitleSample *gf_isom_new_xml_subtitle_sample();\n/*! deletes an XML subtitle sample\n\\param subt_samp the target XML subtitle sample\n*/\nvoid gf_isom_delete_xml_subtitle_sample(GF_GenericSubtitleSample *subt_samp);\n/*! resets content of an XML subtitle sample\n\\param subt_samp the target XML subtitle sample\n\\return error if any\n*/\nGF_Err gf_isom_xml_subtitle_reset(GF_GenericSubtitleSample *subt_samp);\n/*! the corresponding serialized ISO sample\n\\param subt_samp the target XML subtitle sample\n\\return the corresponding serialized ISO sample\n*/\nGF_ISOSample *gf_isom_xml_subtitle_to_sample(GF_GenericSubtitleSample *subt_samp);\n/*! appends text to an XML subtitle sample\n\\param subt_samp the target XML subtitle sample\n\\param text_data the UTF-8 or UTF-16 data to add\n\\param text_len the size of the text to add in bytes\n\\return error if any\n*/\nGF_Err gf_isom_xml_subtitle_sample_add_text(GF_GenericSubtitleSample *subt_samp, char *text_data, u32 text_len);\n\n\n#endif\t/*GPAC_DISABLE_ISOM_WRITE*/\n\n/*! @} */\n\n\n/*!\n\\addtogroup isocrypt_grp Content Protection\n\\ingroup iso_grp\n\n@{\n*/\n\n#endif // GPAC_DISABLE_ISOM\n\n/*! DRM related code points*/\nenum\n{\n\t/*! Storage location of CENC sample auxiliary in PSEC UUID box*/\n\tGF_ISOM_BOX_UUID_PSEC = GF_4CC( 'P', 'S', 'E', 'C' ),\n\t/*! Storage location of CENC sample auxiliary in senc box*/\n\tGF_ISOM_BOX_TYPE_SENC = GF_4CC( 's', 'e', 'n', 'c'),\n\t/*! PSSH box type */\n\tGF_ISOM_BOX_TYPE_PSSH = GF_4CC( 'p', 's', 's', 'h'),\n\t/*! ISMA Encryption Scheme Type in the SchemeTypeInfoBox */\n\tGF_ISOM_ISMACRYP_SCHEME\t= GF_4CC( 'i', 'A', 'E', 'C' ),\n\t/*! OMA DRM Encryption Scheme Type in the SchemeTypeInfoBox */\n\tGF_ISOM_OMADRM_SCHEME = GF_4CC('o','d','k','m'),\n\t/*! CENC AES-CTR Encryption Scheme Type in the SchemeTypeInfoBox */\n\tGF_ISOM_CENC_SCHEME\t= GF_4CC('c','e','n','c'),\n\t/*! CENC AES-CBC Encryption Scheme Type in the SchemeTypeInfoBox */\n\tGF_ISOM_CBC_SCHEME = GF_4CC('c','b','c','1'),\n\t/*! Adobe Encryption Scheme Type in the SchemeTypeInfoBox */\n\tGF_ISOM_ADOBE_SCHEME = GF_4CC('a','d','k','m'),\n\t/*! CENC AES-CTR Pattern Encryption Scheme Type in the SchemeTypeInfoBox */\n\tGF_ISOM_CENS_SCHEME\t= GF_4CC('c','e','n','s'),\n\t/*! CENC AES-CBC Pattern Encryption Scheme Type in the SchemeTypeInfoBox */\n\tGF_ISOM_CBCS_SCHEME\t= GF_4CC('c','b','c','s'),\n\t/*! PIFF Scheme Type in the SchemeTypeInfoBox */\n\tGF_ISOM_PIFF_SCHEME\t= GF_4CC('p','i','f','f'),\n\t/*! CENC sensitive encryption */\n\tGF_ISOM_SVE1_SCHEME\t= GF_4CC('s','v','e','1'),\n};\n\n\n/*! flags for GF_ISMASample*/\ntypedef enum\n{\n\t/*! signals the stream the sample belongs to uses selective encryption*/\n\tGF_ISOM_ISMA_USE_SEL_ENC = 1,\n\t/*! signals the sample is encrypted*/\n\tGF_ISOM_ISMA_IS_ENCRYPTED = 2,\n} GF_ISOISMACrypFlags;\n\n\n#ifndef GPAC_DISABLE_ISOM\n\n/*! checks if a track is encrypted or protected\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return GF_TRUE if track is protected, GF_FALSE otherwise*/\nBool gf_isom_is_track_encrypted(GF_ISOFile *isom_file, u32 trackNumber);\n\n\n\n/*! ISMA sample*/\ntypedef struct\n{\n\t/*! IV in ISMACryp is Byte Stream Offset*/\n\tu64 IV;\n\t/*! IV size in bytes, repeated from sampleDesc for convenience*/\n\tu8 IV_length;\n\t/*! key indicator*/\n\tu8 *key_indicator;\n\t/*! key indicator size, repeated from sampleDesc for convenience*/\n\tu8 KI_length;\n\t/*! payload size*/\n\tu32 dataLength;\n\t/*! payload*/\n\tu8 *data;\n\t/*! flags*/\n\tu32 flags;\n} GF_ISMASample;\n/*! creates a new empty ISMA sample\n\\return a new empty ISMA sample\n*/\nGF_ISMASample *gf_isom_ismacryp_new_sample();\n\n/*! delete an ISMA sample.\n\\note the buffer content will be destroyed by default. If you wish to keep the buffer, set dataLength to 0 in the sample before deleting it\n\\param samp the target ISMA sample\n*/\nvoid gf_isom_ismacryp_delete_sample(GF_ISMASample *samp);\n\n/*! decodes ISMACryp sample based on all info in ISMACryp sample description\n\\param data sample data\n\\param dataLength sample data size in bytes\n\\param use_selective_encryption set to GF_TRUE if sample uses selective encryption\n\\param KI_length set to the size in bytes of the key indicator - 0 means no key roll\n\\param IV_length set to the size in bytes of the initialization vector\n\\return a newly allocated ISMA sample with the parsed data\n*/\nGF_ISMASample *gf_isom_ismacryp_sample_from_data(u8 *data, u32 dataLength, Bool use_selective_encryption, u8 KI_length, u8 IV_length);\n\n/*! decodes ISMACryp sample based on sample and its descrition index\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param samp the sample to decode\n\\param sampleDescriptionIndex the sample description index of the sample to decode\n\\return the ISMA sample or NULL if not an ISMA sample or error\n*/\nGF_ISMASample *gf_isom_get_ismacryp_sample(GF_ISOFile *isom_file, u32 trackNumber, const GF_ISOSample *samp, u32 sampleDescriptionIndex);\n\n/*! checks if sample description is protected or not\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the sample description index. If 0, checks all sample descriptions for protected ones\n\\return scheme protection 4CC or 0 if not protected*/\nu32 gf_isom_is_media_encrypted(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex);\n\n/*! checks if sample description is protected with ISMACryp\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the sample description index\n\\return GF_TRUE if ISMA protection is used*/\nBool gf_isom_is_ismacryp_media(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex);\n\n/*! checks if sample description is protected with OMA DRM\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the sample description index\n\\return GF_TRUE if OMA DRM protection is used*/\nBool gf_isom_is_omadrm_media(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex);\n\n/*! gets OMA DRM configuration - all output parameters are optional and may be NULL\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the sample description index\n\\param outOriginalFormat four character code of the unprotected sample description\n\\param outSchemeType set to four character code of the protection scheme type\n\\param outSchemeVersion set to scheme protection version\n\\param outContentID set to associated ID of content\n\\param outRightsIssuerURL set to the rights issuer (license server) URL\n\\param outTextualHeaders set to OMA textual headers\n\\param outTextualHeadersLen set to the size in bytes of OMA textual headers\n\\param outPlaintextLength set to the size in bytes of clear data in file\n\\param outEncryptionType set to the OMA encryption type used\n\\param outSelectiveEncryption set to GF_TRUE if sample description uses selective encryption\n\\param outIVLength set to the size of the initialization vector\n\\param outKeyIndicationLength set to the size of the key indicator\n\\return error if any\n*/\nGF_Err gf_isom_get_omadrm_info(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, u32 *outOriginalFormat,\n                               u32 *outSchemeType, u32 *outSchemeVersion,\n                               const char **outContentID, const char **outRightsIssuerURL, const char **outTextualHeaders, u32 *outTextualHeadersLen, u64 *outPlaintextLength, u32 *outEncryptionType, Bool *outSelectiveEncryption, u32 *outIVLength, u32 *outKeyIndicationLength);\n\n/*! retrieves ISMACryp info for the given track & SDI - all output parameters are optional - URIs SHALL NOT BE MODIFIED BY USER\n\n\\note outSelectiveEncryption, outIVLength and outKeyIndicationLength are usually not needed to decode an ISMA sample when using \\ref gf_isom_get_ismacryp_sample\n\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the sample description index\n\\param outOriginalFormat set to orginal unprotected media format\n\\param outSchemeType set to 4CC of protection scheme (GF_ISOM_ISMACRYP_SCHEME = iAEC in ISMACryp 1.0)\n\\param outSchemeVersion set to version of protection scheme (1 in ISMACryp 1.0)\n\\param outSchemeURI set to URI location of scheme\n\\param outKMS_URI set to URI location of key management system - only valid with ISMACryp 1.0\n\\param outSelectiveEncryption set to whether sample-based encryption is used in media - only valid with ISMACryp 1.0\n\\param outIVLength set to length of Initial Vector - only valid with ISMACryp 1.0\n\\param outKeyIndicationLength set to length of key indicator - only valid with ISMACryp 1.0\n\\return error if any\n*/\nGF_Err gf_isom_get_ismacryp_info(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, u32 *outOriginalFormat, u32 *outSchemeType, u32 *outSchemeVersion, const char **outSchemeURI, const char **outKMS_URI, Bool *outSelectiveEncryption, u32 *outIVLength, u32 *outKeyIndicationLength);\n\n/*! gets original format four character code type of a protected media sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the sample description index. If 0, checks all sample descriptions for a protected one\n\\param outOriginalFormat set to orginal unprotected media format\n\\return error if any\n*/\nGF_Err gf_isom_get_original_format_type(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, u32 *outOriginalFormat);\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n/*! creates ISMACryp protection info for a sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the sample description index\n\\param scheme_type 4CC of protection scheme (GF_ISOM_ISMACRYP_SCHEME = iAEC in ISMACryp 1.0)\n\\param scheme_version version of protection scheme (1 in ISMACryp 1.0)\n\\param scheme_uri URI location of scheme\n\\param kms_URI URI location of key management system - only valid with ISMACryp 1.0\n\\param selective_encryption whether sample-based encryption is used in media - only valid with ISMACryp 1.0\n\\param KI_length length of key indicator - only valid with ISMACryp 1.0\n\\param IV_length length of Initial Vector - only valid with ISMACryp 1.0\n\\return error if any\n*/\nGF_Err gf_isom_set_ismacryp_protection(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, u32 scheme_type,\n                                       u32 scheme_version, char *scheme_uri, char *kms_URI,\n                                       Bool selective_encryption, u32 KI_length, u32 IV_length);\n\n/*! changes scheme URI and/or KMS URI for crypted files. Other params cannot be changed once the media is crypted\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the sample description index\n\\param scheme_uri new scheme URI, or NULL to keep previous\n\\param kms_uri new KMS URI, or NULL to keep previous\n\\return error if any\n*/\nGF_Err gf_isom_change_ismacryp_protection(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, char *scheme_uri, char *kms_uri);\n\n\n/*! creates OMA DRM protection for a sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the sample description index\n\\param contentID associated ID of content\n\\param kms_URI the rights issuer (license server) URL\n\\param encryption_type the OMA encryption type used\n\\param plainTextLength the size in bytes of clear data in file\n\\param textual_headers OMA textual headers\n\\param textual_headers_len the size in bytes of OMA textual headers\n\\param selective_encryption GF_TRUE if sample description uses selective encryption\n\\param KI_length the size of the key indicator\n\\param IV_length the size of the initialization vector\n\\return error if any\n*/\nGF_Err gf_isom_set_oma_protection(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex,\n                                  char *contentID, char *kms_URI, u32 encryption_type, u64 plainTextLength, char *textual_headers, u32 textual_headers_len,\n                                  Bool selective_encryption, u32 KI_length, u32 IV_length);\n\n/*! creates a generic protection for a sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the sample description index\n\\param scheme_type 4CC of protection scheme (GF_ISOM_ISMACRYP_SCHEME = iAEC in ISMACryp 1.0)\n\\param scheme_version version of protection scheme (1 in ISMACryp 1.0)\n\\param scheme_uri URI location of scheme\n\\param kms_URI the rights issuer (license server) URL\n\\return error if any\n*/\nGF_Err gf_isom_set_generic_protection(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, u32 scheme_type, u32 scheme_version, char *scheme_uri, char *kms_URI);\n\n/*! allocates storage for CENC side data in a senc box\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return error if any\n*/\nGF_Err gf_isom_cenc_allocate_storage(GF_ISOFile *isom_file, u32 trackNumber);\n\n/*! allocates storage for CENC side data in a PIFF senc UUID box\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param AlgorithmID algorith ID, usually 0\n\\param IV_size the size of the init vector\n\\param KID the default Key ID\n\\return error if any\n*/\nGF_Err gf_isom_piff_allocate_storage(GF_ISOFile *isom_file, u32 trackNumber, u32 AlgorithmID, u8 IV_size, bin128 KID);\n\n\n/*! adds cenc SAI for the last sample added to a track\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param container_type the code of the container (currently 'senc' for CENC or 'PSEC' for smooth)\n\\param buf the SAI buffer\n\\param len the size of the SAI buffer. If buf is NULL or len is 0, this adds an unencrypted entry (not written to file)\n\\param use_subsamples if GF_TRUE, the media format uses CENC subsamples\n\\param use_saio_32bit forces usage of 32-bit saio boxes\n\\param is_multi_key indicates if multi key is in use (required to tag saio and saiz boxes)\n\\return error if any\n*/\nGF_Err gf_isom_track_cenc_add_sample_info(GF_ISOFile *isom_file, u32 trackNumber, u32 container_type, u8 *buf, u32 len, Bool use_subsamples, Bool use_saio_32bit, Bool is_multi_key);\n\n\n\n/*! creates CENC protection for a sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the sample description index\n\\param scheme_type 4CC of protection scheme (GF_ISOM_ISMACRYP_SCHEME = iAEC in ISMACryp 1.0)\n\\param scheme_version version of protection scheme (1 in ISMACryp 1.0)\n\\param default_IsEncrypted default isEncrypted flag\n\\param default_crypt_byte_block default crypt block size for pattern encryption\n\\param default_skip_byte_block default skip block size for pattern encryption\n\\param key_info key descriptor formatted as a multi-key info (cf GF_PROP_PID_CENC_KEY)\n\\param key_info_size key descriptor size\n\\return error if any\n*/\nGF_Err gf_isom_set_cenc_protection(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, u32 scheme_type,\n                                   u32 scheme_version, u32 default_IsEncrypted, u8 default_crypt_byte_block, u8 default_skip_byte_block,\n\t\t\t\t\t\t\t\t    u8 *key_info, u32 key_info_size);\n\n\n/*! creates CENC protection for a multi-key sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the sample description index\n\\param scheme_type 4CC of protection scheme (GF_ISOM_ISMACRYP_SCHEME = iAEC in ISMACryp 1.0)\n\\param scheme_version version of protection scheme (1 in ISMACryp 1.0)\n\\param default_IsEncrypted default isEncrypted flag\n\\param default_crypt_byte_block default crypt block size for pattern encryption\n\\param default_skip_byte_block default skip block size for pattern encryption\n\\param key_info key  info (cf CENC and GF_PROP_PID_CENC_KEY)\n\\param key_info_size key info size\n\\return error if any\n*/\nGF_Err gf_isom_set_cenc_protection_mkey(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, u32 scheme_type,\n                                   u32 scheme_version, u32 default_IsEncrypted, u8 default_crypt_byte_block, u8 default_skip_byte_block,\n\t\t\t\t\t\t\t\t    u8 *key_info, u32 key_info_size);\n\n\n/*! adds PSSH info for a file, can be called several time per system ID\n\\param isom_file the target ISO file\n\\param systemID the ID of the protection system\n\\param version the version of the protection system\n\\param KID_count the number of key IDs\n\\param KID the list of key IDs\n\\param data opaque data for the protection system\n\\param len size of the opaque data\n\\param pssh_mode 0: regular PSSH in moov, 1: PIFF PSSH in moov, 2: regular PSSH in meta\n\\return error if any\n*/\nGF_Err gf_cenc_set_pssh(GF_ISOFile *isom_file, bin128 systemID, u32 version, u32 KID_count, bin128 *KID, u8 *data, u32 len, u32 pssh_mode);\n\n/*! removes CENC senc box info\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return error if any\n*/\nGF_Err gf_isom_remove_samp_enc_box(GF_ISOFile *isom_file, u32 trackNumber);\n/*! removes all CENC sample groups\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return error if any\n*/\nGF_Err gf_isom_remove_samp_group_box(GF_ISOFile *isom_file, u32 trackNumber);\n\n#endif //GPAC_DISABLE_ISOM_WRITE\n\n/*! checks if sample description is protected with Adobe systems\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the sample description index\n\\return GF_TRUE if ADOBE protection is used\n*/\nBool gf_isom_is_adobe_protection_media(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex);\n\n/*! gets adobe protection information for a sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the sample description index\n\\param outOriginalFormat set to orginal unprotected media format\n\\param outSchemeType set to 4CC of protection scheme (GF_ISOM_ISMACRYP_SCHEME = iAEC in ISMACryp 1.0)\n\\param outSchemeVersion set to version of protection scheme (1 in ISMACryp 1.0)\n\\param outMetadata set to adobe metadata string\n\\return GF_TRUE if ADOBE protection is used\n*/\nGF_Err gf_isom_get_adobe_protection_info(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, u32 *outOriginalFormat, u32 *outSchemeType, u32 *outSchemeVersion, const char **outMetadata);\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n/*! creates an adobe protection for a sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the sample description index\n\\param scheme_type 4CC of protection scheme (GF_ISOM_ISMACRYP_SCHEME = iAEC in ISMACryp 1.0)\n\\param scheme_version version of protection scheme (1 in ISMACryp 1.0)\n\\param is_selective_enc indicates if selective encryption is used\n\\param metadata metadata information\n\\param len size of metadata information in bytes\n\\return error if any\n*/\nGF_Err gf_isom_set_adobe_protection(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, u32 scheme_type, u32 scheme_version, Bool is_selective_enc, char *metadata, u32 len);\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n/*! checks of sample description is protected with CENC\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the sample description index. If 0, checks all sample descriptions for protected ones\n\\return GF_TRUE if sample protection is CENC\n*/\nBool gf_isom_is_cenc_media(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex);\n/*! gets CENC information of a sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the sample description index\n\\param outOriginalFormat set to orginal unprotected media format\n\\param outSchemeType set to 4CC of protection scheme (GF_ISOM_ISMACRYP_SCHEME = iAEC in ISMACryp 1.0)\n\\param outSchemeVersion set to version of protection scheme (1 in ISMACryp 1.0)\n\\return error if any\n*/\nGF_Err gf_isom_get_cenc_info(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, u32 *outOriginalFormat, u32 *outSchemeType, u32 *outSchemeVersion);\n\n\n/*! gets CENC auxiliary info of a sample as a buffer\n\\note the serialized buffer format is exactly a CencSampleAuxiliaryDataFormat\n\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleNumber the target sample\n\\param sampleDescIndex the sample description index\n\\param container_type is type of box which contains the sample auxiliary information. Now we have two type: GF_ISOM_BOX_UUID_PSEC and GF_ISOM_BOX_TYPE_SENC\n\\param out_buffer set to a newly allocated buffer, or reallocated buffer if not NULL\n\\param outSize set to the size of the serialized buffer. If an existing buffer was passed, the passed value shall be the allocated buffer size (the returned value is still the buffer size)\n\\return error if any\n*/\nGF_Err gf_isom_cenc_get_sample_aux_info(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleNumber, u32 sampleDescIndex, u32 *container_type, u8 **out_buffer, u32 *outSize);\n\n/*! gets CENC default info for a sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the sample description index\n\\param container_type set to the container type of SAI data\n\\param default_IsEncrypted set to default isEncrypted flag\n\\param crypt_byte_block set to default crypt block size for pattern encryption\n\\param skip_byte_block set to default skip block size for pattern encryption\n\\param key_info set to multikey descriptor (cf CENC and GF_PROP_PID_CENC_KEY)\n\\param key_info_size set to multikey descriptor size\n\\return error if any\n*/\nGF_Err gf_isom_cenc_get_default_info(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleDescriptionIndex, u32 *container_type, Bool *default_IsEncrypted, u8 *crypt_byte_block, u8 *skip_byte_block, const u8 **key_info, u32 *key_info_size);\n\n/*! gets the number of PSSH defined\n\\param isom_file the target ISO file\n\\return number of PSSH defined\n*/\nu32 gf_isom_get_pssh_count(GF_ISOFile *isom_file);\n\n/*! gets PSS info\n\\param isom_file the target ISO file\n\\param pssh_index 1-based index of PSSH to query, see \\ref gf_isom_get_pssh_count\n\\param SystemID set to the protection system ID\n\\param version set to the protection system version\n\\param KID_count set to the number of key IDs defined\n\\param KIDs array of defined key IDs\n\\param private_data set to a buffer containing system ID private data\n\\param private_data_size set to the size of the system ID private data\n\\return error if any\n*/\nGF_Err gf_isom_get_pssh_info(GF_ISOFile *isom_file, u32 pssh_index, bin128 SystemID, u32 *version, u32 *KID_count, const bin128 **KIDs, const u8 **private_data, u32 *private_data_size);\n\n#ifndef GPAC_DISABLE_ISOM_DUMP\n/*! dumps ismacrypt protection of sample descriptions to xml trace\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param trace the file object to dump to\n\\return error if any\n*/\nGF_Err gf_isom_dump_ismacryp_protection(GF_ISOFile *isom_file, u32 trackNumber, FILE * trace);\n/*! dumps ismacrypt sample to xml trace\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param SampleNum the target sample number\n\\param trace the file object to dump to\n\\return error if any\n*/\nGF_Err gf_isom_dump_ismacryp_sample(GF_ISOFile *isom_file, u32 trackNumber, u32 SampleNum, FILE *trace);\n#endif\n\n/*! gets CENC configuration for a given sample\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleNumber the target sample number\n\\param IsEncrypted set to GF_TRUE if the sample is encrypted, GF_FALSE otherwise (optional can be NULL)\n\\param crypt_byte_block set to crypt block count for pattern encryption (optional can be NULL)\n\\param skip_byte_block set to skip block count for pattern encryption (optional can be NULL)\n\\param key_info set to key descriptor (cf GF_PROP_PID_CENC_KEY)\n\\param key_info_size set to key descriptor size\n\\return error if any\n*/\nGF_Err gf_isom_get_sample_cenc_info(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleNumber, Bool *IsEncrypted, u8 *crypt_byte_block, u8 *skip_byte_block, const u8 **key_info, u32 *key_info_size);\n\n/*! @} */\n\n/*!\n\\addtogroup isometa_grp Meta and Image File Format\n\\ingroup iso_grp\n\n@{\n*/\n\n\n/*! gets meta type\n\\param isom_file the target ISO file\n\\param root_meta if GF_TRUE uses meta at the file, otherwise uses meta at the movie level if track number is 0\n\\param track_num if GF_TRUE and root_meta is GF_FALSE, uses meta at the track level\n\\return 0 if no meta found, or four char code of meta (eg, \"mp21\", \"smil\", ...)*/\nu32 gf_isom_get_meta_type(GF_ISOFile *isom_file, Bool root_meta, u32 track_num);\n\n/*! checks if the meta has an XML container (note that XML data can also be included as items).\n\\param isom_file the target ISO file\n\\param root_meta if GF_TRUE uses meta at the file, otherwise uses meta at the movie level if track number is 0\n\\param track_num if GF_TRUE and root_meta is GF_FALSE, uses meta at the track level\n\\return 0 (no XML or error), 1 (XML text), 2 (BinaryXML, eg BiM) */\nu32 gf_isom_has_meta_xml(GF_ISOFile *isom_file, Bool root_meta, u32 track_num);\n\n/*! extracts XML (if any) from given meta\n\\param isom_file the target ISO file\n\\param root_meta if GF_TRUE uses meta at the file, otherwise uses meta at the movie level if track number is 0\n\\param track_num if GF_TRUE and root_meta is GF_FALSE, uses meta at the track level\n\\param outName output file path and location for writing\n\\param is_binary indicates if XML is Bim or regular XML\n\\return error if any\n*/\nGF_Err gf_isom_extract_meta_xml(GF_ISOFile *isom_file, Bool root_meta, u32 track_num, char *outName, Bool *is_binary);\n\n/*! checks the number of items in a meta\n\\param isom_file the target ISO file\n\\param root_meta if GF_TRUE uses meta at the file, otherwise uses meta at the movie level if track number is 0\n\\param track_num if GF_TRUE and root_meta is GF_FALSE, uses meta at the track level\n\\return number of items*/\nu32 gf_isom_get_meta_item_count(GF_ISOFile *isom_file, Bool root_meta, u32 track_num);\n\n/*! gets item info for the given item\n\\note When an item is fully contained in file, both item_url and item_urn are set to NULL\n\n\\param isom_file the target ISO file\n\\param root_meta if GF_TRUE uses meta at the file, otherwise uses meta at the movie level if track number is 0\n\\param track_num if GF_TRUE and root_meta is GF_FALSE, uses meta at the track level\n\\param item_num 1-based index of item to query\n\\param itemID set to item ID in file (optional, can be NULL)\n\\param type set to item 4CC type\n\\param protection_scheme set to 0 if not protected, or scheme type used if item is protected. If protected but scheme type not present, set to 'unkw'\n\\param protection_scheme_version set to 0 if not protected, or scheme version used if item is protected\n\\param is_self_reference set to item is the file itself\n\\param item_name set to the item name (optional, can be NULL)\n\\param item_mime_type set to the item mime type (optional, can be NULL)\n\\param item_encoding set to the item content encoding type (optional, can be NULL)\n\\param item_url set to the URL of external resource containing this item data if any.\n\\param item_urn set to the URN of external resource containing this item data if any.\n\\return error if any\n*/\nGF_Err gf_isom_get_meta_item_info(GF_ISOFile *isom_file, Bool root_meta, u32 track_num, u32 item_num,\n                                  u32 *itemID, u32 *type, u32 *protection_scheme, u32 *protection_scheme_version, Bool *is_self_reference,\n                                  const char **item_name, const char **item_mime_type, const char **item_encoding,\n                                  const char **item_url, const char **item_urn);\n\n/*! gets item flags for the given item\n\n\\param isom_file the target ISO file\n\\param root_meta if GF_TRUE uses meta at the file, otherwise uses meta at the movie level if track number is 0\n\\param track_num if GF_TRUE and root_meta is GF_FALSE, uses meta at the track level\n\\param item_num 1-based index of item to query\n\\return item flags\n*/\nu32 gf_isom_get_meta_item_flags(GF_ISOFile *isom_file, Bool root_meta, u32 track_num, u32 item_num);\n\n/*! gets item index from item ID\n\\param isom_file the target ISO file\n\\param root_meta if GF_TRUE uses meta at the file, otherwise uses meta at the movie level if track number is 0\n\\param track_num if GF_TRUE and root_meta is GF_FALSE, uses meta at the track level\n\\param item_ID ID of the item to search\n\\return item index if found, 0 otherwise\n*/\nu32 gf_isom_get_meta_item_by_id(GF_ISOFile *isom_file, Bool root_meta, u32 track_num, u32 item_ID);\n\n/*! extracts an item from given meta\n\\param isom_file the target ISO file\n\\param root_meta if GF_TRUE uses meta at the file, otherwise uses meta at the movie level if track number is 0\n\\param track_num if GF_TRUE and root_meta is GF_FALSE, uses meta at the track level\n\\param item_num 1-based index of item to query\n\\param dump_file_name if NULL, uses item name for dumping, otherwise dumps in given file object (binary write mode)\n\\return error if any\n*/\nGF_Err gf_isom_extract_meta_item(GF_ISOFile *isom_file, Bool root_meta, u32 track_num, u32 item_num, const char *dump_file_name);\n\n/*! extracts item from given meta in memory\n\\param isom_file the target ISO file\n\\param root_meta if GF_TRUE uses meta at the file, otherwise uses meta at the movie level if track number is 0\n\\param track_num if GF_TRUE and root_meta is GF_FALSE, uses meta at the track level\n\\param item_id the ID of the item to dump\n\\param out_data set to allocated buffer containing the item, shall be freeed by user\n\\param out_size set to the size of the allocated buffer\n\\param out_alloc_size set to the allocated size of the buffer (this allows passing an existing buffer without always reallocating it)\n\\param mime_type set to the mime type of the item\n\\param use_annex_b for image items based on NALU formats (AVC, HEVC) indicates to extract the data as Annex B format (with start codes)\n\\return error if any\n*/\nGF_Err gf_isom_extract_meta_item_mem(GF_ISOFile *isom_file, Bool root_meta, u32 track_num, u32 item_id, u8 **out_data, u32 *out_size, u32 *out_alloc_size, const char **mime_type, Bool use_annex_b);\n\n\n/*! fetch CENC info for an item\n\\param isom_file the target ISO file\n\\param root_meta if GF_TRUE uses meta at the file, otherwise uses meta at the movie level if track number is 0\n\\param track_num if GF_TRUE and root_meta is GF_FALSE, uses meta at the track level\n\\param item_id the ID of the item to dump\n\\param is_protected set to GF_TRUE if item is protected\n\\param skip_byte_block set to skip_byte_block or 0 if no pattern\n\\param crypt_byte_block set to crypt_byte_block or 0 if no pattern\n\\param key_info set to key info\n\\param key_info_size set to key info size\n\\param aux_info_type_parameter set to the CENC auxiliary type param of SAI data\n\\param sai_out_data set to allocated buffer containing the item, shall be freeed by user - may be NULL to only retrieve the info\n\\param sai_out_size set to the size of the allocated buffer - may be NULL if  sai_out_data is NULL\n\\param sai_out_alloc_size set to the allocated size of the buffer (this allows passing an existing buffer without always reallocating it) - may be NULL if  sai_out_data is NULL\n\\return error if any\n*/\nGF_Err gf_isom_extract_meta_item_get_cenc_info(GF_ISOFile *isom_file, Bool root_meta, u32 track_num, u32 item_id, Bool *is_protected,\n\tu8 *skip_byte_block, u8 *crypt_byte_block, const u8 **key_info, u32 *key_info_size, u32 *aux_info_type_parameter,\n\tu8 **sai_out_data, u32 *sai_out_size, u32 *sai_out_alloc_size);\n\n/*! gets primary item ID\n\\param isom_file the target ISO file\n\\param root_meta if GF_TRUE uses meta at the file, otherwise uses meta at the movie level if track number is 0\n\\param track_num if GF_TRUE and root_meta is GF_FALSE, uses meta at the track level\n\\return primary item ID, 0 if none found (primary can also be stored through meta XML)*/\nu32 gf_isom_get_meta_primary_item_id(GF_ISOFile *isom_file, Bool root_meta, u32 track_num);\n\n/*! gets number of references of a given type from a given item ID\n\\param isom_file the target ISO file\n\\param root_meta if GF_TRUE uses meta at the file, otherwise uses meta at the movie level if track number is 0\n\\param track_num if GF_TRUE and root_meta is GF_FALSE, uses meta at the track level\n\\param from_id item ID to check\n\\param type reference type to check\n\\return number of referenced items*/\nu32 gf_isom_meta_get_item_ref_count(GF_ISOFile *isom_file, Bool root_meta, u32 track_num, u32 from_id, u32 type);\n\n/*! gets ID  of reference of a given type and index from a given item ID\n\\param isom_file the target ISO file\n\\param root_meta if GF_TRUE uses meta at the file, otherwise uses meta at the movie level if track number is 0\n\\param track_num if GF_TRUE and root_meta is GF_FALSE, uses meta at the track level\n\\param from_id item ID to check\n\\param type reference type to check\n\\param ref_idx 1-based index of reference to check\n\\return ID if the referred item*/\nu32 gf_isom_meta_get_item_ref_id(GF_ISOFile *isom_file, Bool root_meta, u32 track_num, u32 from_id, u32 type, u32 ref_idx);\n\n/*! gets number of references of a given type to a given item ID\n\\param isom_file the target ISO file\n\\param root_meta if GF_TRUE uses meta at the file, otherwise uses meta at the movie level if track number is 0\n\\param track_num if GF_TRUE and root_meta is GF_FALSE, uses meta at the track level\n\\param from_id item ID to check\n\\param type reference type to check\n\\return number of referenced items*/\nu32 gf_isom_meta_item_has_ref(GF_ISOFile *isom_file, Bool root_meta, u32 track_num, u32 to_id, u32 type);\n\n\n/*! item tile mode*/\ntypedef enum {\n\t/*! not a tile item*/\n\tTILE_ITEM_NONE = 0,\n\t/*! a tile item without base*/\n\tTILE_ITEM_ALL_NO_BASE,\n\t/*! a tile item with base*/\n\tTILE_ITEM_ALL_BASE,\n\t/*! a tile item grid*/\n\tTILE_ITEM_ALL_GRID,\n\t/*! a tile item single*/\n\tTILE_ITEM_SINGLE\n} GF_TileItemMode;\n\n/*! Image overlay offset properties*/\ntypedef struct {\n\tu32 horizontal;\n\tu32 vertical;\n} GF_ImageItemOverlayOffset;\n\n/*! Image protection item properties*/\ntypedef struct\n{\n\tu32 scheme_type;\n\tu32 scheme_version;\n\tu8 crypt_byte_block;\n\tu8 skip_byte_block;\n\tconst u8 *key_info;\n\tu32 key_info_size;\n\tconst u8 *sai_data;\n\tu32 sai_data_size;\n} GF_ImageItemProtection;\n\n/*! Image item properties*/\ntypedef struct\n{\n\t/*! width in pixels*/\n\tu32 width;\n\t/*! height in pixless*/\n\tu32 height;\n\t/*! pixel aspect ratio numerator*/\n\tu32 hSpacing;\n\t/*! pixel aspect ratio denominator*/\n\tu32 vSpacing;\n\t/*! horizontal offset in pixels*/\n\tu32 hOffset;\n\t/*! vertical offset in pixels*/\n\tu32 vOffset;\n\t/*! angle in radians*/\n\tu32 angle;\n\t/*! mirroring axis: 0 = not set, 1 = vertical, 2 = horizontal*/\n\tu32 mirror;\n\t/*! hidden flag*/\n\tBool hidden;\n\t/*! clean aperture */\n\tu32 clap_wnum, clap_wden, clap_hnum, clap_hden, clap_hoden, clap_voden;\n\ts32 clap_honum, clap_vonum;\n\t/*! pointer to configuration box*/\n\tvoid *config;\n\t/*! tile item mode*/\n\tGF_TileItemMode tile_mode;\n\t/*! tile number */\n\tu32 single_tile_number;\n\t/*! time for importing*/\n\tDouble time;\n\t/*! end time for importing*/\n\tDouble end_time;\n\t/*! step time between imports*/\n\tDouble step_time;\n\t/*! sample num for importing*/\n\tu32 sample_num;\n\t/*! file containg iCC data for importing*/\n\tchar iccPath[GF_MAX_PATH];\n\t/*! is alpha*/\n\tBool alpha;\n\t/*! is depth*/\n\tBool depth;\n\t/*! number of channels*/\n\tu8 num_channels;\n\t/*! bits per channels in bits*/\n\tu32 bits_per_channel[3];\n\t/*! number of columns in grid*/\n\tu32 num_grid_columns;\n\t/*! number of rows in grid*/\n\tu32 num_grid_rows;\n\t/*! number of overlayed images*/\n\tu32 overlay_count;\n\t/*! overlay offsets*/\n\tGF_ImageItemOverlayOffset *overlay_offsets;\n\t/*! canvas overlay color*/\n\tu32 overlay_canvas_fill_value_r;\n\tu32 overlay_canvas_fill_value_g;\n\tu32 overlay_canvas_fill_value_b;\n\tu32 overlay_canvas_fill_value_a;\n\t/*! protection info, NULL if item is not protected*/\n\tGF_ImageItemProtection *cenc_info;\n\t/*! If set, reference image from sample sample_num (same file data used for sample and item)*/\n\tBool use_reference;\n\t/*ID of item to use as source*/\n\tu32 item_ref_id;\n\t/*if set, copy all properties of source item*/\n\tBool copy_props;\n\t/*only set when importing non-ref from ISOBMF*/\n\tGF_ISOFile *src_file;\n\tBool auto_grid;\n\tDouble auto_grid_ratio;\n\t/*AV1 layer sizes except last layer - set during import*/\n\tu32 av1_layer_size[3];\n\t/*AV1 operation point index*/\n\tu8 av1_op_index;\n\n\t/*interlace type - uncv*/\n\tu8 interlace_type;\n\n\tconst char *aux_urn;\n\tconst u8 *aux_data;\n\tu32 aux_data_len;\n\n\t//serialized box array config, only used for creating item\n\tu8 *config_ba;\n\tu32 config_ba_size;\n\n} GF_ImageItemProperties;\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n/*! sets meta type (four char int, eg \"mp21\", ...), creating a meta box if not found\n\\param isom_file the target ISO file\n\\param root_meta if GF_TRUE uses meta at the file, otherwise uses meta at the movie level if track number is 0\n\\param track_num if GF_TRUE and root_meta is GF_FALSE, uses meta at the track level\n\\param metaType the type of meta to create. If 0, removes the meta box\n\\return error if any\n*/\nGF_Err gf_isom_set_meta_type(GF_ISOFile *isom_file, Bool root_meta, u32 track_num, u32 metaType);\n\n/*! removes meta XML info if any\n\\param isom_file the target ISO file\n\\param root_meta if GF_TRUE uses meta at the file, otherwise uses meta at the movie level if track number is 0\n\\param track_num if GF_TRUE and root_meta is GF_FALSE, uses meta at the track level\n\\return error if any\n*/\nGF_Err gf_isom_remove_meta_xml(GF_ISOFile *isom_file, Bool root_meta, u32 track_num);\n\n/*! sets meta XML data from file or memory - erase any previously (Binary)XML info\n\\param isom_file the target ISO file\n\\param root_meta if GF_TRUE uses meta at the file, otherwise uses meta at the movie level if track number is 0\n\\param track_num if GF_TRUE and root_meta is GF_FALSE, uses meta at the track level\n\\param XMLFileName the XML file to import as XML item, or NULL if data is specified\n\\param data buffer containing XML data, or NULL if file is specified\n\\param data_size size of buffer in bytes, ignored if file is specified\n\\param IsBinaryXML indicates if the content of the XML file is binary XML (BIM) or not\n\\return error if any\n*/\nGF_Err gf_isom_set_meta_xml(GF_ISOFile *isom_file, Bool root_meta, u32 track_num, char *XMLFileName, unsigned char *data, u32 data_size, Bool IsBinaryXML);\n\n/*! gets next available item ID in a meta\n\\param isom_file the target ISO file\n\\param root_meta if GF_TRUE uses meta at the file, otherwise uses meta at the movie level if track number is 0\n\\param track_num if GF_TRUE and root_meta is GF_FALSE, uses meta at the track level\n\\param item_id set to the next available item ID\n\\return error if any\n*/\nGF_Err gf_isom_meta_get_next_item_id(GF_ISOFile *isom_file, Bool root_meta, u32 track_num, u32 *item_id);\n\n/*! adds an item to a meta box from file\n\\param isom_file the target ISO file\n\\param root_meta if GF_TRUE uses meta at the file, otherwise uses meta at the movie level if track number is 0\n\\param track_num if GF_TRUE and root_meta is GF_FALSE, uses meta at the track level\n\\param self_reference if GF_TRUE, indicates that the item is in fact the entire container file\n\\param resource_path path to the file to add\n\\param item_name name of the item\n\\param item_id ID of the item, can be 0\n\\param item_type four character code of item type\n\\param mime_type mime type of the item, can be NULL\n\\param content_encoding content encoding of the item, can be NULL\n\\param URL URL of the item for external data reference (data is not contained in meta parent file)\n\\param URN URN of the item for external data reference (data is not contained in meta parent file)\n\\param image_props image properties information for image items\n\\return error if any\n*/\nGF_Err gf_isom_add_meta_item(GF_ISOFile *isom_file, Bool root_meta, u32 track_num, Bool self_reference, char *resource_path, const char *item_name, u32 item_id, u32 item_type, const char *mime_type, const char *content_encoding, const char *URL, const char *URN, GF_ImageItemProperties *image_props);\n\n#endif //GPAC_DISABLE_ISOM\n\n/*! item extend description*/\ntypedef struct\n{\n\t/*! offset of extent in file*/\n\tu64 extent_offset;\n\t/*! size of extent*/\n\tu64 extent_length;\n\t/*! index of extent*/\n\tu64 extent_index;\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\t/*! for storage only, original offset in source file*/\n\tu64 original_extent_offset;\n#endif\n} GF_ItemExtentEntry;\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n/*! adds an item to a meta box from memory\n\\param isom_file the target ISO file\n\\param root_meta if GF_TRUE uses meta at the file, otherwise uses meta at the movie level if track number is 0\n\\param track_num if GF_TRUE and root_meta is GF_FALSE, uses meta at the track level\n\\param item_name name of the item\n\\param item_id ID of the item, can be NULL, can be 0 in input, set to item ID after call\n\\param item_type four character code of item type\n\\param mime_type mime type of the item, can be NULL\n\\param content_encoding content encoding of the item, can be NULL\n\\param image_props image properties information for image items\n\\param data buffer containing the item data\n\\param data_len size of item data buffer in bytes\n\\param item_extent_refs list of item extend description, or NULL\n\\return error if any\n*/\nGF_Err gf_isom_add_meta_item_memory(GF_ISOFile *isom_file, Bool root_meta, u32 track_num, const char *item_name, u32 *item_id, u32 item_type, const char *mime_type, const char *content_encoding, GF_ImageItemProperties *image_props, char *data, u32 data_len, GF_List *item_extent_refs);\n\n/*! adds an item to a meta box as a reference to a sample\n\\param isom_file the target ISO file\n\\param root_meta if GF_TRUE uses meta at the file, otherwise uses meta at the movie level if track number is 0\n\\param track_num if GF_TRUE and root_meta is GF_FALSE, uses meta at the track level\n\\param item_name name of the item\n\\param item_id ID of the item, can be 0\n\\param item_type four character code of item type\n\\param mime_type mime type of the item, can be NULL\n\\param content_encoding content encoding of the item, can be NULL\n\\param image_props image properties information for image items\n\\param tk_id source track ID\n\\param sample_num number of sample to reference\n\\return error if any\n*/\nGF_Err gf_isom_add_meta_item_sample_ref(GF_ISOFile *isom_file, Bool root_meta, u32 track_num, const char *item_name, u32 *item_id, u32 item_type, const char *mime_type, const char *content_encoding, GF_ImageItemProperties *image_props, GF_ISOTrackID tk_id, u32 sample_num);\n\n/*! creates an image grid item\n\\param isom_file the target ISO file\n\\param root_meta if GF_TRUE uses meta at the file, otherwise uses meta at the movie level if meta_track_number is 0\n\\param meta_track_number if GF_TRUE and root_meta is GF_FALSE, uses meta at the track level\n\\param item_name name of the item\n\\param item_id ID of the item, can be 0\n\\param image_props image properties information for image items\n\\return error if any\n*/\nGF_Err gf_isom_iff_create_image_grid_item(GF_ISOFile *isom_file, Bool root_meta, u32 meta_track_number, const char *item_name, u32 item_id, GF_ImageItemProperties *image_props);\n\n/*! creates an image overlay item\n\\param isom_file the target ISO file\n\\param root_meta if GF_TRUE uses meta at the file, otherwise uses meta at the movie level if meta_track_number is 0\n\\param meta_track_number if GF_TRUE and root_meta is GF_FALSE, uses meta at the track level\n\\param item_name name of the item\n\\param item_id ID of the item, can be 0\n\\param image_props image properties information for image items\n\\return error if any\n*/\nGF_Err gf_isom_iff_create_image_overlay_item(GF_ISOFile *isom_file, Bool root_meta, u32 meta_track_number, const char *item_name, u32 item_id, GF_ImageItemProperties *image_props);\n\n/*! creates an image identity item\n\\param isom_file the target ISO file\n\\param root_meta if GF_TRUE uses meta at the file, otherwise uses meta at the movie level if meta_track_number is 0\n\\param meta_track_number if GF_TRUE and root_meta is GF_FALSE, uses meta at the track level\n\\param item_name name of the item\n\\param item_id ID of the item, can be 0\n\\param image_props image properties information for image items\n\\return error if any\n*/\nGF_Err gf_isom_iff_create_image_identity_item(GF_ISOFile *isom_file, Bool root_meta, u32 meta_track_number, const char *item_name, u32 item_id, GF_ImageItemProperties *image_props);\n\n/*! creates image item(s) from samples of a media track\n\\param isom_file the target ISO file\n\\param root_meta if GF_TRUE uses meta at the file, otherwise uses meta at the movie level if meta_track_number is 0\n\\param meta_track_number if GF_TRUE and root_meta is GF_FALSE, uses meta at the track level\n\\param media_track track number to import samples from\n\\param item_name name of the item\n\\param item_id ID of the item, can be 0\n\\param image_props image properties information for image items\n\\param item_extent_refs list of item extend description, or NULL\n\\return error if any\n*/\nGF_Err gf_isom_iff_create_image_item_from_track(GF_ISOFile *isom_file, Bool root_meta, u32 meta_track_number, u32 media_track, const char *item_name, u32 item_id, GF_ImageItemProperties *image_props, GF_List *item_extent_refs);\n\n/*! removes item from meta\n\\param isom_file the target ISO file\n\\param root_meta if GF_TRUE uses meta at the file, otherwise uses meta at the movie level if track number is 0\n\\param track_num if GF_TRUE and root_meta is GF_FALSE, uses meta at the track level\n\\param item_num 1-based index of the item to remove\n\\param keep_refs do not modify item reference, typically used when replacing an item\n\\param keep_props keep property association for properties with 4CC listed in keep_props (coma-seprated list)\n\\return error if any\n*/\nGF_Err gf_isom_remove_meta_item(GF_ISOFile *isom_file, Bool root_meta, u32 track_num, u32 item_num, Bool keep_refs, const char *keep_props);\n\n/*! sets the given item as the primary one\n\\warning This SHALL NOT be used if the meta has a valid XML data\n\\param isom_file the target ISO file\n\\param root_meta if GF_TRUE uses meta at the file, otherwise uses meta at the movie level if track number is 0\n\\param track_num if GF_TRUE and root_meta is GF_FALSE, uses meta at the track level\n\\param item_num 1-based index of the item to remove\n\\return error if any\n*/\nGF_Err gf_isom_set_meta_primary_item(GF_ISOFile *isom_file, Bool root_meta, u32 track_num, u32 item_num);\n\n/*! adds an item reference to another item\n\\param isom_file the target ISO file\n\\param root_meta if GF_TRUE uses meta at the file, otherwise uses meta at the movie level if track number is 0\n\\param track_num if GF_TRUE and root_meta is GF_FALSE, uses meta at the track level\n\\param from_id ID of item the reference is from\n\\param to_id ID of item the reference is to\n\\param type four character code of reference\n\\param ref_index set to the 1-based index of the reference\n\\return error if any\n*/\nGF_Err gf_isom_meta_add_item_ref(GF_ISOFile *isom_file, Bool root_meta, u32 track_num, u32 from_id, u32 to_id, u32 type, u64 *ref_index);\n\n/*! adds the item to the given group\n\\param isom_file the target ISO file\n\\param root_meta if GF_TRUE uses meta at the file, otherwise uses meta at the movie level if track number is 0\n\\param track_num if GF_TRUE and root_meta is GF_FALSE, uses meta at the track level\n\\param item_id ID of item to add\n\\param group_id ID of group, 0 if needs to be determined from the file\n\\param group_type four character code of group\n\\return error if any\n*/\nGF_Err gf_isom_meta_add_item_group(GF_ISOFile *isom_file, Bool root_meta, u32 track_num, u32 item_id, u32 group_id, u32 group_type);\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n/*! gets image item properties\n\\param isom_file the target ISO file\n\\param root_meta if GF_TRUE uses meta at the file, otherwise uses meta at the movie level if track number is 0\n\\param track_num if GF_TRUE and root_meta is GF_FALSE, uses meta at the track level\n\\param item_id ID of the item\n\\param out_image_props set to the image properties information of the item\n\\param unmapped_props will contain all properties (box) not mapped to image properties. May be NULL. DO NOT DESTROY the content of the list\n\n\\return error if any\n*/\nGF_Err gf_isom_get_meta_image_props(GF_ISOFile *isom_file, Bool root_meta, u32 track_num, u32 item_id, GF_ImageItemProperties *out_image_props, GF_List *unmapped_props);\n\n/*! @} */\n\n\n#endif //GPAC_DISABLE_ISOM\n\n/*!\n\\addtogroup isotags_grp iTunes tagging\n\\ingroup iso_grp\n\n@{\n*/\n\n/*! iTunes info tags */\ntypedef enum\n{\n\t/*probe is only used to check if iTunes info are present*/\n\tGF_ISOM_ITUNE_PROBE = 0,\n\t/*all is only used to remove all tags*/\n\tGF_ISOM_ITUNE_RESET = 1,\n\tGF_ISOM_ITUNE_NAME \t\t\t\t= GF_4CC( 0xA9, 'n', 'a', 'm' ),\n\tGF_ISOM_ITUNE_ARTIST \t\t\t= GF_4CC( 0xA9, 'A', 'R', 'T' ),\n\tGF_ISOM_ITUNE_ALBUM_ARTIST \t\t= GF_4CC( 'a', 'A', 'R', 'T' ),\n\tGF_ISOM_ITUNE_ALBUM\t\t\t\t= GF_4CC( 0xA9, 'a', 'l', 'b' ),\n\tGF_ISOM_ITUNE_GROUP \t\t\t= GF_4CC( 0xA9, 'g', 'r', 'p' ),\n\tGF_ISOM_ITUNE_WRITER \t\t\t= GF_4CC( 0xA9, 'w', 'r', 't' ),\n\tGF_ISOM_ITUNE_COMMENT \t\t\t= GF_4CC( 0xA9, 'c', 'm', 't' ),\n\tGF_ISOM_ITUNE_GENRE_USER\t\t= GF_4CC( 0xA9, 'g', 'e', 'n'),\n\tGF_ISOM_ITUNE_GENRE \t\t\t= GF_4CC( 'g', 'n', 'r', 'e' ),\n\tGF_ISOM_ITUNE_CREATED \t\t\t= GF_4CC( 0xA9, 'd', 'a', 'y' ),\n\tGF_ISOM_ITUNE_TRACKNUMBER \t\t= GF_4CC( 't', 'r', 'k', 'n' ),\n\tGF_ISOM_ITUNE_DISK \t\t\t\t= GF_4CC( 'd', 'i', 's', 'k' ),\n\tGF_ISOM_ITUNE_TEMPO \t\t\t= GF_4CC( 't', 'm', 'p', 'o' ),\n\tGF_ISOM_ITUNE_COMPILATION \t\t= GF_4CC( 'c', 'p', 'i', 'l' ),\n\tGF_ISOM_ITUNE_TV_SHOW \t\t\t= GF_4CC( 't', 'v', 's', 'h'),\n\tGF_ISOM_ITUNE_TV_EPISODE \t\t= GF_4CC( 't', 'v', 'e', 'n'),\n\tGF_ISOM_ITUNE_TV_SEASON \t\t= GF_4CC( 't', 'v', 's', 'n'),\n\tGF_ISOM_ITUNE_TV_EPISODE_NUM \t= GF_4CC( 't', 'v', 'e', 's'),\n\tGF_ISOM_ITUNE_TV_NETWORK \t\t= GF_4CC( 't', 'v', 'n', 'n'),\n\tGF_ISOM_ITUNE_DESCRIPTION\t \t= GF_4CC( 'd', 'e', 's', 'c' ),\n\tGF_ISOM_ITUNE_LONG_DESCRIPTION\t= GF_4CC( 'l', 'd', 'e', 's'),\n\tGF_ISOM_ITUNE_LYRICS \t\t\t= GF_4CC( 0xA9, 'l', 'y', 'r' ),\n\tGF_ISOM_ITUNE_SORT_NAME \t\t= GF_4CC( 's', 'o', 'n', 'm' ),\n\tGF_ISOM_ITUNE_SORT_ARTIST \t\t= GF_4CC( 's', 'o', 'a', 'r' ),\n\tGF_ISOM_ITUNE_SORT_ALB_ARTIST \t= GF_4CC( 's', 'o', 'a', 'a' ),\n\tGF_ISOM_ITUNE_SORT_ALBUM\t \t= GF_4CC( 's', 'o', 'a', 'l' ),\n\tGF_ISOM_ITUNE_SORT_COMPOSER\t \t= GF_4CC( 's', 'o', 'c', 'o' ),\n\tGF_ISOM_ITUNE_SORT_SHOW\t \t\t= GF_4CC( 's', 'o', 's', 'n' ),\n\tGF_ISOM_ITUNE_COVER_ART \t\t= GF_4CC( 'c', 'o', 'v', 'r' ),\n\tGF_ISOM_ITUNE_COPYRIGHT \t\t= GF_4CC( 'c', 'p', 'r', 't' ),\n\tGF_ISOM_ITUNE_TOOL \t\t\t\t= GF_4CC( 0xA9, 't', 'o', 'o' ),\n\tGF_ISOM_ITUNE_ENCODER \t\t\t= GF_4CC( 0xA9, 'e', 'n', 'c' ),\n\tGF_ISOM_ITUNE_PURCHASE_DATE \t= GF_4CC( 'p', 'u', 'r', 'd' ),\n\tGF_ISOM_ITUNE_PODCAST\t\t \t= GF_4CC( 'p', 'c', 's', 't' ),\n\tGF_ISOM_ITUNE_PODCAST_URL\t \t= GF_4CC( 'p', 'u', 'r', 'l' ),\n\tGF_ISOM_ITUNE_KEYWORDS \t\t\t= GF_4CC( 'k', 'y', 'y', 'w'),\n\tGF_ISOM_ITUNE_CATEGORY \t\t\t= GF_4CC( 'c', 'a', 't', 'g'),\n\tGF_ISOM_ITUNE_HD_VIDEO \t\t\t= GF_4CC( 'h', 'd', 'v', 'd'),\n\tGF_ISOM_ITUNE_MEDIA_TYPE \t\t= GF_4CC( 's', 't', 'i', 'k'),\n\tGF_ISOM_ITUNE_RATING\t \t\t= GF_4CC( 'r', 't', 'n', 'g'),\n\tGF_ISOM_ITUNE_GAPLESS \t\t\t= GF_4CC( 'p', 'g', 'a', 'p' ),\n\tGF_ISOM_ITUNE_COMPOSER \t\t= GF_4CC( 0xA9, 'c', 'o', 'm' ),\n\tGF_ISOM_ITUNE_TRACK \t\t= GF_4CC( 0xA9, 't', 'r', 'k' ),\n\tGF_ISOM_ITUNE_CONDUCTOR \t= GF_4CC( 0xA9, 'c', 'o', 'n' ),\n\n\tGF_ISOM_ITUNE_ART_DIRECTOR \t= GF_4CC( 0xA9, 'a', 'r', 'd' ),\n\tGF_ISOM_ITUNE_ARRANGER\t \t= GF_4CC( 0xA9, 'a', 'r', 'g' ),\n\tGF_ISOM_ITUNE_LYRICIST\t \t= GF_4CC( 0xA9, 'a', 'u', 't' ),\n\tGF_ISOM_ITUNE_COPY_ACK\t \t= GF_4CC( 0xA9, 'c', 'a', 'k' ),\n\tGF_ISOM_ITUNE_SONG_DESC\t \t= GF_4CC( 0xA9, 'd', 'e', 's' ),\n\tGF_ISOM_ITUNE_DIRECTOR\t \t= GF_4CC( 0xA9, 'd', 'i', 'r' ),\n\tGF_ISOM_ITUNE_EQ_PRESET\t \t= GF_4CC( 0xA9, 'e', 'q', 'u' ),\n\tGF_ISOM_ITUNE_LINER_NOTES \t= GF_4CC( 0xA9, 'l', 'n', 't' ),\n\tGF_ISOM_ITUNE_REC_COMPANY \t= GF_4CC( 0xA9, 'm', 'a', 'k' ),\n\tGF_ISOM_ITUNE_ORIG_ARTIST \t= GF_4CC( 0xA9, 'o', 'p', 'e' ),\n\tGF_ISOM_ITUNE_PHONO_RIGHTS \t= GF_4CC( 0xA9, 'p', 'h', 'g' ),\n\tGF_ISOM_ITUNE_PRODUCER\t \t= GF_4CC( 0xA9, 'p', 'r', 'd' ),\n\tGF_ISOM_ITUNE_PERFORMER\t \t= GF_4CC( 0xA9, 'p', 'r', 'f' ),\n\tGF_ISOM_ITUNE_PUBLISHER\t \t= GF_4CC( 0xA9, 'p', 'u', 'b' ),\n\tGF_ISOM_ITUNE_SOUND_ENG\t \t= GF_4CC( 0xA9, 's', 'n', 'e' ),\n\tGF_ISOM_ITUNE_SOLOIST\t \t= GF_4CC( 0xA9, 's', 'o', 'l' ),\n\tGF_ISOM_ITUNE_CREDITS\t \t= GF_4CC( 0xA9, 's', 'r', 'c' ),\n\tGF_ISOM_ITUNE_THANKS\t \t= GF_4CC( 0xA9, 't', 'h', 'x' ),\n\tGF_ISOM_ITUNE_ONLINE\t \t= GF_4CC( 0xA9, 'u', 'r', 'l' ),\n\tGF_ISOM_ITUNE_EXEC_PRODUCER\t= GF_4CC( 0xA9, 'x', 'p', 'd' ),\n\tGF_ISOM_ITUNE_LOCATION\t \t= GF_4CC( 0xA9, 'x', 'y', 'z' ),\n\n\n\tGF_ISOM_ITUNE_ITUNES_DATA \t= GF_4CC( '-', '-', '-', '-' ),\n\n\t/* not mapped:\nPurchase Account \tapID \tUTF-8 string \t\tiTunesAccount (read only)\nAccount Type \takID \t8-bit integer \tIdentifies the iTunes Store account type \tiTunesAccountType (read only)\n\tcnID \t32-bit integer \tiTunes Catalog ID, used for combing SD and HD encodes in iTunes \tcnID\nCountry Code \tsfID \t32-bit integer \tIdentifies in which iTunes Store a file was bought \tiTunesCountry (read only)\n\tatID \t32-bit integer \tUse? \tatID\n\tplID \t64-bit integer \tUse?\n\tgeID \t32-bit integer \tUse? \tgeID\n\t\u00a9st3 \tUTF-8 string \tUse?\n\t*/\n\n} GF_ISOiTunesTag;\n\n#ifndef GPAC_DISABLE_ISOM\n\n/*! gets the given itunes tag info.\n\\warning 'genre' may be coded by ID, the libisomedia doesn't translate the ID. In such a case, the result data is set to NULL and the data_len to the genre ID\n\n\\param isom_file the target ISO file\n\\param tag the tag to query\n\\param data set to the tag data pointer - do not modify\n\\param data_len set to the size of the tag data\n\\return error if any (GF_URL_ERROR if no tag is present in the file)\n*/\nGF_Err gf_isom_apple_get_tag(GF_ISOFile *isom_file, GF_ISOiTunesTag tag, const u8 **data, u32 *data_len);\n\n/*! enumerate itunes tags.\n\n\\param isom_file the target ISO file\n\\param idx 0-based index of the tag to get\n\\param out_tag set to the tag code\n\\param data set to the tag data pointer - do not modify\n\\param data_len set to the size of the tag data. Data is set to NULL and data_size to 1 if the associated tag has no data\n\\param out_int_val set to the int/bool/frac numerator type for known tags, in which case data is set to NULL\n\\param out_int_val2 set to the frac denominator for known tags, in which case data is set to NULL\n\\param out_flags set to the flags value of the data container box\n\\return error if any (GF_URL_ERROR if no more tags)\n*/\nGF_Err gf_isom_apple_enum_tag(GF_ISOFile *isom_file, u32 idx, GF_ISOiTunesTag *out_tag, const u8 **data, u32 *data_len, u64 *out_int_val, u32 *out_int_val2, u32 *out_flags);\n\n\n/*! enumerate WMA tags.\n\n\\param isom_file the target ISO file\n\\param idx 0-based index of the tag to get\n\\param out_tag set to the tag name\n\\param data set to the tag data pointer - do not modify\n\\param data_len set to the size of the tag data\n\\param version  set to the WMA tag version\n\\param data_type set to the WMA data type\n\\return error if any (GF_URL_ERROR if no more tags)\n*/\nGF_Err gf_isom_wma_enum_tag(GF_ISOFile *isom_file, u32 idx, char **out_tag, const u8 **data, u32 *data_len, u32 *version, u32 *data_type);\n\n/*! QT key types */\ntypedef enum\n{\n\tGF_QT_KEY_OPAQUE=0,\n\tGF_QT_KEY_UTF8=1,\n\tGF_QT_KEY_UTF16_BE=2,\n\tGF_QT_KEY_JIS=3,\n\tGF_QT_KEY_UTF8_SORT=4,\n\tGF_QT_KEY_UTF16_SORT=5,\n\tGF_QT_KEY_JPEG=13,\n\tGF_QT_KEY_PNG=14,\n\tGF_QT_KEY_SIGNED_VSIZE=21,\n\tGF_QT_KEY_UNSIGNED_VSIZE=22,\n\tGF_QT_KEY_FLOAT=23,\n\tGF_QT_KEY_DOUBLE=24,\n\tGF_QT_KEY_BMP=27,\n\tGF_QT_KEY_METABOX=28,\n\tGF_QT_KEY_SIGNED_8=65,\n\tGF_QT_KEY_SIGNED_16=66,\n\tGF_QT_KEY_SIGNED_32=67,\n\tGF_QT_KEY_POINTF=70,\n\tGF_QT_KEY_SIZEF=71,\n\tGF_QT_KEY_RECTF=72,\n\tGF_QT_KEY_SIGNED_64=74,\n\tGF_QT_KEY_UNSIGNED_8=75,\n\tGF_QT_KEY_UNSIGNED_16=76,\n\tGF_QT_KEY_UNSIGNED_32=77,\n\tGF_QT_KEY_UNSIGNED_64=78,\n\tGF_QT_KEY_MATRIXF=79,\n\n\t//used to remove a key\n\tGF_QT_KEY_REMOVE=0xFFFFFFFF\n} GF_QTKeyType;\n\n\n/*! QT userdata key*/\ntypedef struct\n{\n\t/*! key name*/\n\tconst char *name;\n\t/*! key namespace 4CC*/\n\tu32 ns;\n\n\t/*! key type*/\n\tGF_QTKeyType type;\n\tunion {\n\t\t/*! UTF-8 string, for GF_QT_KEY_UTF8 and GF_QT_KEY_UTF8_SORT */\n\t\tconst char *string;\n\t\t/*! data, for unsupported types, image types, UTF16 types and metabox */\n\t\tstruct _tag_data {\n\t\t\t/*! data */\n\t\t\tconst u8 *data;\n\t\t\t/*! size */\n\t\t\tu32 data_len;\n\t\t} data;\n\t\t/*! unsigned integer value*/\n\t\tu64 uint;\n\t\t/*! signed integer value*/\n\t\ts64 sint;\n\t\t/*! number value for GF_QT_KEY_FLOAT and GF_QT_KEY_DOUBLE*/\n\t\tDouble number;\n\t\t/*! 2D float value, for GF_QT_KEY_POINTF and GF_QT_KEY_SIZEFF*/\n\t\tstruct _tag_vec2 {\n\t\t\t/*! x-coord*/\n\t\t\tFloat x;\n\t\t\t/*! y-coord*/\n\t\t\tFloat y;\n\t\t} pos_size;\n\t\t/*! 4D value, for GF_QT_KEY_RECTF*/\n\t\tstruct _tag_rec {\n\t\t\t/*! x-coord*/\n\t\t\tFloat x;\n\t\t\t/*! y-coord*/\n\t\t\tFloat y;\n\t\t\t/*! width*/\n\t\t\tFloat w;\n\t\t\t/*! height*/\n\t\t\tFloat h;\n\t\t} rect;\n\t\t/*! 2x3 matrix */\n\t\tDouble matrix[9];\n\t} value;\n} GF_QT_UDTAKey;\n\n/*! enumerate QT keys tags.\n\n\\param isom_file the target ISO file\n\\param idx 0-based index of the tag to get\n\\param out_key key to be filled with key at given index\n\\return error if any (GF_URL_ERROR if no more tags)\n*/\nGF_Err gf_isom_enum_udta_keys(GF_ISOFile *isom_file, u32 idx, GF_QT_UDTAKey *out_key);\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n/*! sets the given tag info.\n\n\\param isom_file the target ISO file\n\\param tag the tag to set\n\\param data tag data buffer or string to parse\n\\param data_len size of the tag data buffer. If data is NULL and and data_len not  0, removes the given tag\n\\param int_val value for integer/boolean tags. If data and data_len are set, parse data as string  to get the value\n\\param int_val2 value for fractional  tags. If data and data_len are set, parse data as string to get the value\n\\return error if any\n*/\nGF_Err gf_isom_apple_set_tag(GF_ISOFile *isom_file, GF_ISOiTunesTag tag, const u8 *data, u32 data_len, u64 int_val, u32 int_val2);\n\n\n/*! sets the given WMA tag info (only string tags are supported).\n\n\\param isom_file the target ISO file\n\\param name name of the tag to set\n\\param value string value to set\n\\return error if any\n*/\nGF_Err gf_isom_wma_set_tag(GF_ISOFile *isom_file, char *name, char *value);\n\n/*! sets key (QT style metadata)\n\\param isom_file the target ISO file\n\\param key the key to use. if NULL, removes ALL keys\n\\return error if any\n*/\nGF_Err gf_isom_set_qt_key(GF_ISOFile *isom_file, GF_QT_UDTAKey *key);\n\n/*! sets compatibility tag on AVC tracks (needed by iPod to play files... hurray for standards)\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return error if any\n*/\nGF_Err gf_isom_set_ipod_compatible(GF_ISOFile *isom_file, u32 trackNumber);\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n/*! @} */\n\n/*!\n\\addtogroup isogrp_grp Track Groups\n\\ingroup iso_grp\n\n@{\n*/\n\n/*! gets the number of switching groups declared in this track if any\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param alternateGroupID alternate group id of track if speciifed, 0 otherwise\n\\param nb_groups set to number of switching groups defined for this track\n\\return error if any\n*/\nGF_Err gf_isom_get_track_switch_group_count(GF_ISOFile *isom_file, u32 trackNumber, u32 *alternateGroupID, u32 *nb_groups);\n\n/*! get the list of criteria (expressed as 4CC IDs, cf 3GPP TS 26.244)\n\\param isom_file the target ISO file\n\\param trackNumber the track number\n\\param group_index the 1-based index of the group to inspect\n\\param switchGroupID set to the ID of the switch group if any, 0 otherwise (alternate-only group)\n\\param criteriaListSize set to the number of criteria items in returned list\n\\return list of criteria (four character codes, cf 3GPP TS 26.244) for the switch group\n*/\nconst u32 *gf_isom_get_track_switch_parameter(GF_ISOFile *isom_file, u32 trackNumber, u32 group_index, u32 *switchGroupID, u32 *criteriaListSize);\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n/*! sets a new (switch) group for this track\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param trackRefGroup number of a track belonging to the same alternate group. If 0, a new alternate group will be created for this track\n\\param is_switch_group if set, indicates that a switch group identifier shall be assigned to the created group. Otherwise, the criteria list is associated with the entire alternate group\n\\param switchGroupID set to the ID of the switch group. On input, specifies the desired switchGroupID to use; if value is 0, next available switchGroupID in file is used. On output, is set to the switchGroupID used.\n\\param criteriaList list of four character codes used as criteria - cf 3GPP TS 26.244\n\\param criteriaListCount number of criterias in list\n\\return error if any\n*/\nGF_Err gf_isom_set_track_switch_parameter(GF_ISOFile *isom_file, u32 trackNumber, u32 trackRefGroup, Bool is_switch_group, u32 *switchGroupID, u32 *criteriaList, u32 criteriaListCount);\n\n/*! resets track switch group information\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param reset_all_group if GF_TRUE, resets the entire alternate group this track belongs to; otherwise, resets switch group for the track only\n\\return error if any\n*/\nGF_Err gf_isom_reset_track_switch_parameter(GF_ISOFile *isom_file, u32 trackNumber, Bool reset_all_group);\n\n/*! resets all track switch group information in the entire movie\n\\param isom_file the target ISO file\n\\return error if any\n*/\nGF_Err gf_isom_reset_switch_parameters(GF_ISOFile *isom_file);\n\n/*! sets track in group of a given type and ID\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param track_group_id ID of the track group\n\\param group_type four character code of the track group\n\\param do_add if GF_FALSE, track is removed from that group, otherwise it is added\n\\return error if any\n*/\nGF_Err gf_isom_set_track_group(GF_ISOFile *isom_file, u32 trackNumber, u32 track_group_id, u32 group_type, Bool do_add);\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n/*! @} */\n\n/*!\n\\addtogroup isosubs_grp Subsamples\n\\ingroup iso_grp\n\n@{\n*/\n\n/*! gets serialized subsample info for the sample\nThe buffer is formatted as N times [(u32)flags(u32)sub_size(u32)codec_param(u8)priority(u8) discardable]\nIf several subsample info are present, they are gathered by flags\n\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleNumber the target sample number\n\\param osize set to output buffer size\n\\return the serialized buffer, or NULL oif no associated subsample*/\nu8 *gf_isom_sample_get_subsamples_buffer(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleNumber, u32 *osize);\n\n/*! checks if a sample has subsample information\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleNumber the target sample number. Set to 0 to check for presence of subsample info (will return 1 or 0 in this case)\n\\param flags the subsample flags to query (may be 0)\n\\return the number of subsamples in the given sample for the given flags*/\nu32 gf_isom_sample_has_subsamples(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleNumber, u32 flags);\n\n/*! gets subsample information on a sample\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleNumber the target sample number\n\\param flags the subsample flags to query (may be 0)\n\\param subSampleNumber the 1-based index of the subsample (see \\ref gf_isom_sample_has_subsamples)\n\\param size set to the subsample size\n\\param priority set to the subsample priority\n\\param reserved set to the subsample reserved value (may be used by derived specifications)\n\\param discardable set to GF_TRUE if subsample is discardable\n\\return error if any*/\nGF_Err gf_isom_sample_get_subsample(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleNumber, u32 flags, u32 subSampleNumber, u32 *size, u8 *priority, u32 *reserved, Bool *discardable);\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n/*! adds subsample information to a given sample. Subsample information shall be added in increasing order of sampleNumbers, insertion of information is not supported\n\n\\note it is possible to  add subsample information for samples not yet added to the file\n\\note specifying 0 as subSampleSize will remove the last subsample information if any\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleNumber the target sample number\n\\param flags the subsample flags to query (may be 0)\n\\param subSampleSize size of the subsample. If 0, this will remove the last subsample information if any\n\\param priority the subsample priority\n\\param reserved the subsample reserved value (may be used by derived specifications)\n\\param discardable indicates if the subsample is discardable\n\\return error if any*/\nGF_Err gf_isom_add_subsample(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleNumber, u32 flags, u32 subSampleSize, u8 priority, u32 reserved, Bool discardable);\n\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n/*! adds subsample information for the latest sample added to the current track fragment\n\\param isom_file the target ISO file\n\\param TrackID the ID of the target track\n\\param flags the subsample flags to query (may be 0)\n\\param subSampleSize size of the subsample. If 0, this will remove the last subsample information if any\n\\param priority the subsample priority\n\\param reserved the subsample reserved value (may be used by derived specifications)\n\\param discardable indicates if the subsample is discardable\n\\return error if any*/\nGF_Err gf_isom_fragment_add_subsample(GF_ISOFile *isom_file, GF_ISOTrackID TrackID, u32 flags, u32 subSampleSize, u8 priority, u32 reserved, Bool discardable);\n#endif // GPAC_DISABLE_ISOM_FRAGMENTS\n\n#endif //GPAC_DISABLE_ISOM_WRITE\n\n/*! @} */\n\n/*!\n\\addtogroup isosgdp_grp Sample Groups\n\\ingroup iso_grp\n\n@{\n*/\n\n/*! defined sample groups in GPAC*/\nenum {\n\tGF_ISOM_SAMPLE_GROUP_ROLL = GF_4CC( 'r', 'o', 'l', 'l'),\n\tGF_ISOM_SAMPLE_GROUP_PROL = GF_4CC( 'p', 'r', 'o', 'l'),\n\tGF_ISOM_SAMPLE_GROUP_RAP = GF_4CC( 'r', 'a', 'p', ' ' ),\n\tGF_ISOM_SAMPLE_GROUP_SEIG = GF_4CC( 's', 'e', 'i', 'g' ),\n\tGF_ISOM_SAMPLE_GROUP_OINF = GF_4CC( 'o', 'i', 'n', 'f'),\n\tGF_ISOM_SAMPLE_GROUP_LINF = GF_4CC( 'l', 'i', 'n', 'f'),\n\tGF_ISOM_SAMPLE_GROUP_TRIF = GF_4CC( 't', 'r', 'i', 'f' ),\n\tGF_ISOM_SAMPLE_GROUP_NALM = GF_4CC( 'n', 'a', 'l', 'm'),\n\tGF_ISOM_SAMPLE_GROUP_TELE = GF_4CC( 't', 'e', 'l', 'e'),\n\tGF_ISOM_SAMPLE_GROUP_SAP = GF_4CC( 's', 'a', 'p', ' '),\n\tGF_ISOM_SAMPLE_GROUP_ALST = GF_4CC( 'a', 'l', 's', 't'),\n\tGF_ISOM_SAMPLE_GROUP_RASH = GF_4CC( 'r', 'a', 's', 'h'),\n\tGF_ISOM_SAMPLE_GROUP_AVLL = GF_4CC( 'a', 'v', 'l', 'l'), //p15\n\tGF_ISOM_SAMPLE_GROUP_AVSS = GF_4CC( 'a', 'v', 's', 's'), //p15\n\tGF_ISOM_SAMPLE_GROUP_DTRT = GF_4CC( 'd', 't', 'r', 't'), //p15\n\tGF_ISOM_SAMPLE_GROUP_MVIF = GF_4CC( 'm', 'v', 'i', 'f'), //p15\n\tGF_ISOM_SAMPLE_GROUP_SCIF = GF_4CC( 's', 'c', 'i', 'f'), //p15\n\tGF_ISOM_SAMPLE_GROUP_SCNM = GF_4CC( 's', 'c', 'n', 'm'), //p15\n\tGF_ISOM_SAMPLE_GROUP_STSA = GF_4CC( 's', 't', 's', 'a'), //p15\n\tGF_ISOM_SAMPLE_GROUP_TSAS = GF_4CC( 't', 's', 'a', 's'), //p15\n\tGF_ISOM_SAMPLE_GROUP_SYNC = GF_4CC( 's', 'y', 'n', 'c'), //p15\n\tGF_ISOM_SAMPLE_GROUP_TSCL = GF_4CC( 't', 's', 'c', 'l'), //p15\n\tGF_ISOM_SAMPLE_GROUP_VIPR = GF_4CC( 'v', 'i', 'p', 'r'), //p15\n\tGF_ISOM_SAMPLE_GROUP_LBLI = GF_4CC( 'l', 'b', 'l', 'i'), //p15\n\tGF_ISOM_SAMPLE_GROUP_3GAG = GF_4CC( '3', 'g', 'a', 'g'), //3gpp\n\tGF_ISOM_SAMPLE_GROUP_AVCB = GF_4CC( 'a', 'v', 'c', 'b'), //avif\n\tGF_ISOM_SAMPLE_GROUP_SPOR = GF_4CC( 's', 'p', 'o', 'r'), //p15\n\tGF_ISOM_SAMPLE_GROUP_SULM = GF_4CC( 's', 'u', 'l', 'm'), //p15\n\tGF_ISOM_SAMPLE_GROUP_ESGH = GF_4CC( 'e', 's', 'g', 'h'), //p12\n\tGF_ISOM_SAMPLE_GROUP_ILCE = GF_4CC( 'i', 'l', 'c', 'e'), //uncv\n};\n\n/*! gets 'rap ' and 'roll' group info for the given sample\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleNumber the target sample number\n\\param is_rap set to GF_TRUE if sample is a rap (open gop), GF_FALSE otherwise\n\\param roll_type set to GF_ISOM_SAMPLE_ROLL if sample has roll information, GF_ISOM_SAMPLE_PREROLL if sample has preroll information, GF_ISOM_SAMPLE_ROLL_NONE otherwise\n\\param roll_distance if sample has roll information, set to roll distance\n\\return error if any*/\nGF_Err gf_isom_get_sample_rap_roll_info(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleNumber, Bool *is_rap, GF_ISOSampleRollType *roll_type, s32 *roll_distance);\n\n/*! returns opaque data of sample group\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sample_group_description_index index of sample group description entry to query\n\\param grouping_type four character code of grouping type of sample group description to query\n\\param default_index set to the default index for this sample group description if any, 0 otherwise (no defaults)\n\\param data set to the internal sample group description data buffer\n\\param size set to size of the sample group description data buffer\n\\return GF_TRUE if found, GF_FALSE otherwise*/\nBool gf_isom_get_sample_group_info(GF_ISOFile *isom_file, u32 trackNumber, u32 sample_group_description_index, u32 grouping_type, u32 *default_index, const u8 **data, u32 *size);\n\n/*! gets sample group description index for a given sample and grouping type.\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sample_number sample number to query\n\\param grouping_type four character code of grouping type of sample group description to query\n\\param grouping_type_parameter  grouping type parameter of sample group description to query\n\\param sampleGroupDescIndex set to the 1-based sample group description index, or 0 if no sample group of this type is associated\n\\return error if any\n*/\nGF_Err gf_isom_get_sample_to_group_info(GF_ISOFile *isom_file, u32 trackNumber, u32 sample_number, u32 grouping_type, u32 grouping_type_parameter, u32 *sampleGroupDescIndex);\n\n/*! checks if a track as a CENC seig sample group used for key rolling\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param has_selective set to TRUE if some entries describe unprotected samples - may be NULL\n\\param has_roll set to TRUE if more than one key defined - may be NULL\n\\return GF_TRUE if found, GF_FALSE otherwise*/\nBool gf_isom_has_cenc_sample_group(GF_ISOFile *isom_file, u32 trackNumber, Bool *has_selective, Bool *has_roll);\n\n/*! gets HEVC tiling info\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sample_group_description_index index of sample group description entry to query\n\\param default_sample_group_index set to the default index for this sample group description if any, 0 otherwise (no defaults)\n\\param id set to the tile group ID\n\\param independent set to independent flag of the tile group (0: not constrained, 1: constrained in layer, 2: all intra slices)\n\\param full_frame set to GF_TRUE if the tile corresponds to the entire picture\n\\param x set to the horizontal position in pixels\n\\param y set to the vertical position in pixels\n\\param w set to the width in pixels\n\\param h set to the height in pixels\n\\return GF_TRUE if found, GF_FALSE otherwise*/\nBool gf_isom_get_tile_info(GF_ISOFile *isom_file, u32 trackNumber, u32 sample_group_description_index, u32 *default_sample_group_index, u32 *id, u32 *independent, Bool *full_frame, u32 *x, u32 *y, u32 *w, u32 *h);\n\n\n/*! enumerates custom sample groups (not natively supported by this library) for a given sample\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sample_number the target sample\n\\param sgrp_idx the current index. Must be set to 0 on first call, incremented by this call on each success, must not be NULL\n\\param sgrp_type set to the grouping type, or set to 0 if no more sample group descriptions, must not be NULL\n\\param sgrp_flags set to the grouping flags, (0x1: static_group_description, 0x2: static_mapping)\n\\param sgrp_parameter set to the grouping_type_parameter or 0 if not defined\n\\param sgrp_data set to the sample group description data, may be NULL - MUST be freed by caller\n\\param sgrp_size set to the sample group description size, may be NULL\n\\return error if any\n*/\nGF_Err gf_isom_enum_sample_group(GF_ISOFile *isom_file, u32 trackNumber, u32 sample_number, u32 *sgrp_idx, u32 *sgrp_type, u32 *sgrp_flags, u32 *sgrp_parameter, u8 **sgrp_data, u32 *sgrp_size);\n\n/*! enumerates custom sample auxiliary data (not natively supported by this library) for a given sample\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sample_number the target sample\n\\param sai_idx the current index. Must be et to 0 on first call, incremented by this call on each success, must not be NULL\n\\param sai_type set to the grouping type, or set to 0 if no more sample group descriptions, must not be NULL\n\\param sai_parameter set to the grouping_type_parameter or 0 if not defined\n\\param sai_data set (allocated) to the sample group description data, must not be NULL and must be freed by caller\n\\param sai_size set to the sample group description size, must not be NULL\n\\return error if any\n*/\nGF_Err gf_isom_enum_sample_aux_data(GF_ISOFile *isom_file, u32 trackNumber, u32 sample_number, u32 *sai_idx, u32 *sai_type, u32 *sai_parameter, u8 **sai_data, u32 *sai_size);\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n/*! sets rap flag for sample_number - this is used by non-IDR RAPs in AVC (also in USAC) were SYNC flag (stss table) cannot be used\n\\warning Sample group info MUST be added in order (no insertion in the tables)\n\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleNumber the target sample number\n\\param is_rap indicates if the sample is a RAP (open gop) sample\n\\param num_leading_samples indicates the number of leading samples (samples after this RAP that have dependences on samples before this RAP and hence should be discarded when tuning in)\n\\return error if any\n*/\nGF_Err gf_isom_set_sample_rap_group(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleNumber, Bool is_rap, u32 num_leading_samples);\n\n/*! sets roll_distance info for sample_number (number of frames before (<0) or after (>0) this sample to have a complete refresh of the decoded data (used by GDR in AVC)\n\n\\warning Sample group info MUST be added in order (no insertion in the tables)\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleNumber the target sample number. If 0, assumes last added sample. If 0xFFFFFFFF, marks all samples as belonging to the roll group\n\\param roll_type indicates  the sample roll recovery type\n\\param roll_distance indicates the roll distance before a correct decoding is produced\n\\return error if any\n*/\nGF_Err gf_isom_set_sample_roll_group(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleNumber, GF_ISOSampleRollType roll_type, s16 roll_distance);\n\n/*! sets encryption group for a sample number\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleNumber the target sample number\n\\param isEncrypted isEncrypted flag\n\\param crypt_byte_block crypt block size for pattern encryption, can be 0\n\\param skip_byte_block skip block size for pattern encryption, can be 0\n\\param key_info multikey descriptor (cf CENC and GF_PROP_PID_CENC_KEY)\n\\param key_info_size multikey descriptor size\n\\return error if any\n*/\nGF_Err gf_isom_set_sample_cenc_group(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleNumber, u8 isEncrypted, u8 crypt_byte_block, u8 skip_byte_block, u8 *key_info, u32 key_info_size);\n\n\n/*! sets a sample using the default CENC parameters in a CENC saig sample group SEIG, creating a sample group description if needed (when seig is already defined)\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleNumber the target sample number\n\\return error if any\n*/\nGF_Err gf_isom_set_sample_cenc_default_group(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleNumber);\n\n/*! adds the given blob as a sample group description entry of the given grouping type.\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param grouping_type the four character code of the grouping type\n\\param data the payload of the sample group description\n\\param data_size the size of the payload\n\\param is_default if GF_TRUE, thie created entry will be marked as the default entry for the sample group description\n\\param sampleGroupDescriptionIndex is set to the sample group description index (optional, can be NULL)\n\\return error if any\n*/\nGF_Err gf_isom_add_sample_group_info(GF_ISOFile *isom_file, u32 trackNumber, u32 grouping_type, void *data, u32 data_size, Bool is_default, u32 *sampleGroupDescriptionIndex);\n\n/*! removes a sample group description of the give grouping type, if found\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param grouping_type the four character code of the grouping type\n\\return error if any\n*/\nGF_Err gf_isom_remove_sample_group(GF_ISOFile *isom_file, u32 trackNumber, u32 grouping_type);\n\n/*! adds the given blob as a sample group description entry of the given grouping type for the given sample.\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleNumber the target sample number.Use 0 for setting sample group info to last sample in a track fragment\n\\param grouping_type the four character code of the grouping type\n\\param grouping_type_parameter associated grouping type parameter (usually 0)\n\\param data the payload of the sample group description\n\\param data_size the size of the payload\n\\param sgpd_flags flags for sgpd: 1: static description, 2, static mapping, 1<<30: essential sample group, 1<<31: default sample description\n\\return error if any\n*/\nGF_Err gf_isom_set_sample_group_description(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleNumber, u32 grouping_type, u32 grouping_type_parameter, void *data, u32 data_size, u32 sgpd_flags);\n\n\n/*! adds a sample to the given sample group\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleNumber the target sample number\n\\param grouping_type the four character code of the grouping type\n\\param sampleGroupDescriptionIndex the 1-based index of the sample group description entry\n\\param grouping_type_parameter the grouping type paramter (see ISO/IEC 14496-12)\n\\return error if any\n*/\nGF_Err gf_isom_add_sample_info(GF_ISOFile *isom_file, u32 trackNumber, u32 sampleNumber, u32 grouping_type, u32 sampleGroupDescriptionIndex, u32 grouping_type_parameter);\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n/*! sets sample group descriptions storage in trafs and not in initial movie (Smooth compatibility)\n\\param isom_file the target ISO file\n\\return error if any*/\nGF_Err gf_isom_set_sample_group_in_traf(GF_ISOFile *isom_file);\n#endif\n\n#endif // GPAC_DISABLE_ISOM_WRITE\n\n\n/*! @} */\n\n#endif /*GPAC_DISABLE_ISOM*/\n\n#ifdef __cplusplus\n}\n#endif\n\n\n#endif\t/*_GF_ISOMEDIA_H_*/\n\n\n", "/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2023\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISO Media File Format sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/internal/isomedia_dev.h>\n\n\n\n#ifndef GPAC_DISABLE_ISOM\n\nvoid co64_box_del(GF_Box *s)\n{\n\tGF_ChunkLargeOffsetBox *ptr;\n\tptr = (GF_ChunkLargeOffsetBox *) s;\n\tif (ptr == NULL) return;\n\tif (ptr->offsets) gf_free(ptr->offsets);\n\tgf_free(ptr);\n}\n\nGF_Err co64_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tu32 entries;\n\tGF_ChunkLargeOffsetBox *ptr = (GF_ChunkLargeOffsetBox *) s;\n\tptr->nb_entries = gf_bs_read_u32(bs);\n\n\tISOM_DECREASE_SIZE(ptr, 4)\n\n\tif ((u64)ptr->nb_entries > ptr->size / 8 || (u64)ptr->nb_entries > (u64)SIZE_MAX/sizeof(u64)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in co64\\n\", ptr->nb_entries));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tptr->offsets = (u64 *) gf_malloc(ptr->nb_entries * sizeof(u64) );\n\tif (ptr->offsets == NULL) return GF_OUT_OF_MEM;\n\tptr->alloc_size = ptr->nb_entries;\n\tfor (entries = 0; entries < ptr->nb_entries; entries++) {\n\t\tptr->offsets[entries] = gf_bs_read_u64(bs);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *co64_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ChunkLargeOffsetBox, GF_ISOM_BOX_TYPE_CO64);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err co64_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_ChunkLargeOffsetBox *ptr = (GF_ChunkLargeOffsetBox *) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->nb_entries);\n\tfor (i = 0; i < ptr->nb_entries; i++ ) {\n\t\tgf_bs_write_u64(bs, ptr->offsets[i]);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err co64_box_size(GF_Box *s)\n{\n\tGF_ChunkLargeOffsetBox *ptr = (GF_ChunkLargeOffsetBox *) s;\n\n\tptr->size += 4 + (8 * ptr->nb_entries);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid cprt_box_del(GF_Box *s)\n{\n\tGF_CopyrightBox *ptr = (GF_CopyrightBox *) s;\n\tif (ptr == NULL) return;\n\tif (ptr->notice)\n\t\tgf_free(ptr->notice);\n\tgf_free(ptr);\n}\n\n\nGF_Box *chpl_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ChapterListBox, GF_ISOM_BOX_TYPE_CHPL);\n\ttmp->list = gf_list_new();\n\ttmp->version = 1;\n\treturn (GF_Box *)tmp;\n}\n\nvoid chpl_box_del(GF_Box *s)\n{\n\tGF_ChapterListBox *ptr = (GF_ChapterListBox *) s;\n\tif (ptr == NULL) return;\n\twhile (gf_list_count(ptr->list)) {\n\t\tGF_ChapterEntry *ce = (GF_ChapterEntry *)gf_list_get(ptr->list, 0);\n\t\tif (ce->name) gf_free(ce->name);\n\t\tgf_free(ce);\n\t\tgf_list_rem(ptr->list, 0);\n\t}\n\tgf_list_del(ptr->list);\n\tgf_free(ptr);\n}\n\n/*this is using chpl format according to some NeroRecode samples*/\nGF_Err chpl_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_ChapterEntry *ce;\n\tu32 nb_chaps, len, i, count;\n\tGF_ChapterListBox *ptr = (GF_ChapterListBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 5)\n\t/*reserved or ???*/\n\tgf_bs_read_u32(bs);\n\tnb_chaps = gf_bs_read_u8(bs);\n\n\tcount = 0;\n\twhile (nb_chaps) {\n\t\tGF_SAFEALLOC(ce, GF_ChapterEntry);\n\t\tif (!ce) return GF_OUT_OF_MEM;\n\t\tISOM_DECREASE_SIZE(ptr, 9)\n\t\tce->start_time = gf_bs_read_u64(bs);\n\t\tlen = gf_bs_read_u8(bs);\n\t\tif (ptr->size<len) return GF_ISOM_INVALID_FILE;\n\t\tif (len) {\n\t\t\tce->name = (char *)gf_malloc(sizeof(char)*(len+1));\n\t\t\tif (!ce->name) return GF_OUT_OF_MEM;\n\t\t\tISOM_DECREASE_SIZE(ptr, len)\n\t\t\tgf_bs_read_data(bs, ce->name, len);\n\t\t\tce->name[len] = 0;\n\t\t} else {\n\t\t\tce->name = gf_strdup(\"\");\n\t\t}\n\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_ChapterEntry *ace = (GF_ChapterEntry *) gf_list_get(ptr->list, i);\n\t\t\tif (ace->start_time >= ce->start_time) {\n\t\t\t\tgf_list_insert(ptr->list, ce, i);\n\t\t\t\tce = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ce) gf_list_add(ptr->list, ce);\n\t\tcount++;\n\t\tnb_chaps--;\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err chpl_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 count, i;\n\tGF_ChapterListBox *ptr = (GF_ChapterListBox *) s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tcount = gf_list_count(ptr->list);\n\tgf_bs_write_u32(bs, 0);\n\tgf_bs_write_u8(bs, count);\n\tfor (i=0; i<count; i++) {\n\t\tu32 len;\n\t\tGF_ChapterEntry *ce = (GF_ChapterEntry *)gf_list_get(ptr->list, i);\n\t\tgf_bs_write_u64(bs, ce->start_time);\n\t\tif (ce->name) {\n\t\t\tlen = (u32) strlen(ce->name);\n\t\t\tif (len>255) len = 255;\n\t\t\tgf_bs_write_u8(bs, len);\n\t\t\tgf_bs_write_data(bs, ce->name, len);\n\t\t} else {\n\t\t\tgf_bs_write_u8(bs, 0);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err chpl_box_size(GF_Box *s)\n{\n\tu32 count, i;\n\tGF_ChapterListBox *ptr = (GF_ChapterListBox *)s;\n\n\tptr->size += 5;\n\n\tcount = gf_list_count(ptr->list);\n\tfor (i=0; i<count; i++) {\n\t\tGF_ChapterEntry *ce = (GF_ChapterEntry *)gf_list_get(ptr->list, i);\n\t\tptr->size += 9; /*64bit time stamp + 8bit str len*/\n\t\tif (ce->name) ptr->size += strlen(ce->name);\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Err cprt_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_CopyrightBox *ptr = (GF_CopyrightBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 2);\n\tgf_bs_read_int(bs, 1);\n\t//the spec is unclear here, just says \"the value 0 is interpreted as undetermined\"\n\tptr->packedLanguageCode[0] = gf_bs_read_int(bs, 5);\n\tptr->packedLanguageCode[1] = gf_bs_read_int(bs, 5);\n\tptr->packedLanguageCode[2] = gf_bs_read_int(bs, 5);\n\n\t//but before or after compaction ?? We assume before\n\tif (ptr->packedLanguageCode[0] || ptr->packedLanguageCode[1] || ptr->packedLanguageCode[2]) {\n\t\tptr->packedLanguageCode[0] += 0x60;\n\t\tptr->packedLanguageCode[1] += 0x60;\n\t\tptr->packedLanguageCode[2] += 0x60;\n\t} else {\n\t\tptr->packedLanguageCode[0] = 'u';\n\t\tptr->packedLanguageCode[1] = 'n';\n\t\tptr->packedLanguageCode[2] = 'd';\n\t}\n\tif (ptr->size) {\n\t\tu32 bytesToRead = (u32) ptr->size;\n\t\tptr->notice = (char*)gf_malloc((bytesToRead+1) * sizeof(char));\n\t\tif (ptr->notice == NULL) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->notice, bytesToRead);\n\t\tptr->notice[bytesToRead] = 0;\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *cprt_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_CopyrightBox, GF_ISOM_BOX_TYPE_CPRT);\n\ttmp->packedLanguageCode[0] = 'u';\n\ttmp->packedLanguageCode[1] = 'n';\n\ttmp->packedLanguageCode[2] = 'd';\n\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err cprt_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_CopyrightBox *ptr = (GF_CopyrightBox *) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_int(bs, 0, 1);\n\tif (ptr->packedLanguageCode[0]) {\n\t\tgf_bs_write_int(bs, ptr->packedLanguageCode[0] - 0x60, 5);\n\t\tgf_bs_write_int(bs, ptr->packedLanguageCode[1] - 0x60, 5);\n\t\tgf_bs_write_int(bs, ptr->packedLanguageCode[2] - 0x60, 5);\n\t} else {\n\t\tgf_bs_write_int(bs, 0, 15);\n\t}\n\tif (ptr->notice) {\n\t\tgf_bs_write_data(bs, ptr->notice, (u32) (strlen(ptr->notice) + 1) );\n\t}\n\treturn GF_OK;\n}\n\nGF_Err cprt_box_size(GF_Box *s)\n{\n\tGF_CopyrightBox *ptr = (GF_CopyrightBox *)s;\n\n\tptr->size += 2;\n\tif (ptr->notice)\n\t\tptr->size += strlen(ptr->notice) + 1;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid kind_box_del(GF_Box *s)\n{\n\tGF_KindBox *ptr = (GF_KindBox *) s;\n\tif (ptr == NULL) return;\n\tif (ptr->schemeURI) gf_free(ptr->schemeURI);\n\tif (ptr->value) gf_free(ptr->value);\n\tgf_free(ptr);\n}\n\nGF_Err kind_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_KindBox *ptr = (GF_KindBox *)s;\n\n\tif (ptr->size) {\n\t\tu32 bytesToRead = (u32) ptr->size;\n\t\tchar *data;\n\t\tu32 schemeURIlen;\n\t\tdata = (char*)gf_malloc(bytesToRead * sizeof(char));\n\t\tif (!data) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, data, bytesToRead);\n\t\t/*safety check in case the string is not null-terminated*/\n\t\tif (data[bytesToRead-1]) {\n\t\t\tdata = (char*)gf_realloc(data, sizeof(char)*(bytesToRead + 1));\n\t\t\tif (!data) return GF_OUT_OF_MEM;\n\t\t\tdata[bytesToRead] = 0;\n\t\t\tbytesToRead++;\n\t\t}\n\t\tptr->schemeURI = gf_strdup(data);\n\t\tif (!ptr->schemeURI) return GF_OUT_OF_MEM;\n\t\tschemeURIlen = (u32) strlen(data);\n\t\tif (bytesToRead > schemeURIlen+1) {\n\t\t\t/* read the value */\n\t\t\tchar *data_value = data + schemeURIlen +1;\n\t\t\tptr->value = gf_strdup(data_value);\n\t\t\tif (!ptr->value) return GF_OUT_OF_MEM;\n\t\t}\n\t\tgf_free(data);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *kind_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_KindBox, GF_ISOM_BOX_TYPE_KIND);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err kind_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_KindBox *ptr = (GF_KindBox *) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n    if (ptr->schemeURI)\n        gf_bs_write_data(bs, ptr->schemeURI, (u32) (strlen(ptr->schemeURI) + 1 ));\n    else\n        gf_bs_write_u8(bs, 0);\n\n    if (ptr->value) {\n\t\tgf_bs_write_data(bs, ptr->value, (u32) (strlen(ptr->value) + 1) );\n\t}\n\treturn GF_OK;\n}\n\nGF_Err kind_box_size(GF_Box *s)\n{\n\tGF_KindBox *ptr = (GF_KindBox *)s;\n\n    ptr->size += (ptr->schemeURI ? strlen(ptr->schemeURI) : 0) + 1;\n\tif (ptr->value) {\n\t\tptr->size += strlen(ptr->value) + 1;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid ctts_box_del(GF_Box *s)\n{\n\tGF_CompositionOffsetBox *ptr = (GF_CompositionOffsetBox *)s;\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);\n}\n\n\n\nGF_Err ctts_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tu32 sampleCount;\n\tGF_CompositionOffsetBox *ptr = (GF_CompositionOffsetBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->nb_entries = gf_bs_read_u32(bs);\n\n\tif (ptr->nb_entries > ptr->size / 8 || (u64)ptr->nb_entries > (u64)SIZE_MAX/sizeof(GF_DttsEntry) ) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in ctts\\n\", ptr->nb_entries));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tptr->alloc_size = ptr->nb_entries;\n\tptr->entries = (GF_DttsEntry *)gf_malloc(sizeof(GF_DttsEntry)*ptr->alloc_size);\n\tif (!ptr->entries) return GF_OUT_OF_MEM;\n\tsampleCount = 0;\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\tptr->entries[i].sampleCount = gf_bs_read_u32(bs);\n\t\tif (ptr->version)\n\t\t\tptr->entries[i].decodingOffset = gf_bs_read_int(bs, 32);\n\t\telse\n\t\t\tptr->entries[i].decodingOffset = (s32) gf_bs_read_u32(bs);\n\n\t\tif (ptr->max_cts_delta <= ABS(ptr->entries[i].decodingOffset)) {\n\t\t\tptr->max_cts_delta = ABS(ptr->entries[i].decodingOffset);\n\t\t\t//ptr->sample_num_max_cts_delta = sampleCount;\n\t\t}\n\t\tsampleCount += ptr->entries[i].sampleCount;\n\t}\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tptr->w_LastSampleNumber = sampleCount;\n#endif\n\treturn GF_OK;\n}\n\nGF_Box *ctts_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_CompositionOffsetBox, GF_ISOM_BOX_TYPE_CTTS);\n\treturn (GF_Box *) tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err ctts_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_CompositionOffsetBox *ptr = (GF_CompositionOffsetBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->nb_entries);\n\tfor (i=0; i<ptr->nb_entries; i++ ) {\n\t\tgf_bs_write_u32(bs, ptr->entries[i].sampleCount);\n\t\tif (ptr->version) {\n\t\t\tgf_bs_write_int(bs, ptr->entries[i].decodingOffset, 32);\n\t\t} else {\n\t\t\tgf_bs_write_u32(bs, (u32) ptr->entries[i].decodingOffset);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err ctts_box_size(GF_Box *s)\n{\n\tGF_CompositionOffsetBox *ptr = (GF_CompositionOffsetBox *) s;\n\n\tptr->size += 4 + (8 * ptr->nb_entries);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid cslg_box_del(GF_Box *s)\n{\n\tGF_CompositionToDecodeBox *ptr = (GF_CompositionToDecodeBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n\treturn;\n}\n\nGF_Err cslg_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_CompositionToDecodeBox *ptr = (GF_CompositionToDecodeBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 20);\n\tptr->compositionToDTSShift = gf_bs_read_int(bs, 32);\n\tptr->leastDecodeToDisplayDelta = gf_bs_read_int(bs, 32);\n\tptr->greatestDecodeToDisplayDelta = gf_bs_read_int(bs, 32);\n\tptr->compositionStartTime = gf_bs_read_int(bs, 32);\n\tptr->compositionEndTime = gf_bs_read_int(bs, 32);\n\treturn GF_OK;\n}\n\nGF_Box *cslg_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_CompositionToDecodeBox, GF_ISOM_BOX_TYPE_CSLG);\n\treturn (GF_Box *) tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err cslg_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_CompositionToDecodeBox *ptr = (GF_CompositionToDecodeBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_int(bs, ptr->compositionToDTSShift, 32);\n\tgf_bs_write_int(bs, ptr->leastDecodeToDisplayDelta, 32);\n\tgf_bs_write_int(bs, ptr->greatestDecodeToDisplayDelta, 32);\n\tgf_bs_write_int(bs, ptr->compositionStartTime, 32);\n\tgf_bs_write_int(bs, ptr->compositionEndTime, 32);\n\treturn GF_OK;\n}\n\nGF_Err cslg_box_size(GF_Box *s)\n{\n\tGF_CompositionToDecodeBox *ptr = (GF_CompositionToDecodeBox *)s;\n\n\tptr->size += 20;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid ccst_box_del(GF_Box *s)\n{\n\tGF_CodingConstraintsBox *ptr = (GF_CodingConstraintsBox *)s;\n\tif (ptr) gf_free(ptr);\n\treturn;\n}\n\nGF_Err ccst_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_CodingConstraintsBox *ptr = (GF_CodingConstraintsBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->all_ref_pics_intra = gf_bs_read_int(bs, 1);\n\tptr->intra_pred_used = gf_bs_read_int(bs, 1);\n\tptr->max_ref_per_pic = gf_bs_read_int(bs, 4);\n\tptr->reserved = gf_bs_read_int(bs, 26);\n\treturn GF_OK;\n}\n\nGF_Box *ccst_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_CodingConstraintsBox, GF_ISOM_BOX_TYPE_CCST);\n\treturn (GF_Box *) tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err ccst_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_CodingConstraintsBox *ptr = (GF_CodingConstraintsBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_int(bs, ptr->all_ref_pics_intra, 1);\n\tgf_bs_write_int(bs, ptr->intra_pred_used, 1);\n\tgf_bs_write_int(bs, ptr->max_ref_per_pic, 4);\n\tgf_bs_write_int(bs, 0, 26);\n\treturn GF_OK;\n}\n\nGF_Err ccst_box_size(GF_Box *s)\n{\n\tGF_CodingConstraintsBox *ptr = (GF_CodingConstraintsBox *)s;\n\tptr->size += 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid url_box_del(GF_Box *s)\n{\n\tGF_DataEntryURLBox *ptr = (GF_DataEntryURLBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->location) gf_free(ptr->location);\n\tgf_free(ptr);\n\treturn;\n}\n\n\nGF_Err url_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_DataEntryURLBox *ptr = (GF_DataEntryURLBox *)s;\n\n\tif (ptr->size) {\n\t\tu32 location_size = (u32) ptr->size;\n\t\tif (location_size < 1) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid size %llu in svhd box\\n\", ptr->size));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t\tptr->location = (char*)gf_malloc(location_size);\n\t\tif (! ptr->location) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->location, location_size);\n\t\tif (ptr->location[location_size-1]) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] url box location is not 0-terminated\\n\" ));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *url_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DataEntryURLBox, GF_ISOM_BOX_TYPE_URL);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err url_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_DataEntryURLBox *ptr = (GF_DataEntryURLBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\t//the flag set indicates we have a string (WE HAVE TO for URLs)\n\tif ( !(ptr->flags & 1)) {\n\t\tif (ptr->location) {\n\t\t\tgf_bs_write_data(bs, ptr->location, (u32)strlen(ptr->location) + 1);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err url_box_size(GF_Box *s)\n{\n\tGF_DataEntryURLBox *ptr = (GF_DataEntryURLBox *)s;\n\n\tif ( !(ptr->flags & 1)) {\n\t\tif (ptr->location) ptr->size += 1 + strlen(ptr->location);\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid urn_box_del(GF_Box *s)\n{\n\tGF_DataEntryURNBox *ptr = (GF_DataEntryURNBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->location) gf_free(ptr->location);\n\tif (ptr->nameURN) gf_free(ptr->nameURN);\n\tgf_free(ptr);\n}\n\n\nGF_Err urn_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i, to_read;\n\tchar *tmpName;\n\tGF_DataEntryURNBox *ptr = (GF_DataEntryURNBox *)s;\n\tif (! ptr->size ) return GF_OK;\n\n\t//here we have to handle that in a clever way\n\tto_read = (u32) ptr->size;\n\ttmpName = (char*)gf_malloc(sizeof(char) * to_read);\n\tif (!tmpName) return GF_OUT_OF_MEM;\n\t//get the data\n\tgf_bs_read_data(bs, tmpName, to_read);\n\n\t//then get the break\n\ti = 0;\n\twhile ( (i < to_read) && (tmpName[i] != 0) ) {\n\t\ti++;\n\t}\n\t//check the data is consistent\n\tif (i == to_read) {\n\t\tgf_free(tmpName);\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\t//no NULL char, URL is not specified\n\tif (i == to_read - 1) {\n\t\tptr->nameURN = tmpName;\n\t\tptr->location = NULL;\n\t\treturn GF_OK;\n\t}\n\t//OK, this has both URN and URL\n\tptr->nameURN = (char*)gf_malloc(sizeof(char) * (i+1));\n\tif (!ptr->nameURN) {\n\t\tgf_free(tmpName);\n\t\treturn GF_OUT_OF_MEM;\n\t}\n\tmemcpy(ptr->nameURN, tmpName, i + 1);\n\n\tif (tmpName[to_read - 1] != 0) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] urn box contains invalid location field\\n\" ));\n\t}\n\telse {\n\t\tptr->location = (char*)gf_malloc(sizeof(char) * (to_read - i - 1));\n\t\tif (!ptr->location) {\n\t\t\tgf_free(tmpName);\n\t\t\tgf_free(ptr->nameURN);\n\t\t\tptr->nameURN = NULL;\n\t\t\treturn GF_OUT_OF_MEM;\n\t\t}\n\t\tmemcpy(ptr->location, tmpName + i + 1, (to_read - i - 1));\n\t}\n\n\tgf_free(tmpName);\n\treturn GF_OK;\n}\n\nGF_Box *urn_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DataEntryURNBox, GF_ISOM_BOX_TYPE_URN);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err urn_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_DataEntryURNBox *ptr = (GF_DataEntryURNBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\t//the flag set indicates we have a string (WE HAVE TO for URLs)\n\tif ( !(ptr->flags & 1)) {\n\t\t//to check, the spec says: First name, then location\n\t\tif (ptr->nameURN) {\n\t\t\tgf_bs_write_data(bs, ptr->nameURN, (u32)strlen(ptr->nameURN) + 1);\n\t\t}\n\t\tif (ptr->location) {\n\t\t\tgf_bs_write_data(bs, ptr->location, (u32)strlen(ptr->location) + 1);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err urn_box_size(GF_Box *s)\n{\n\tGF_DataEntryURNBox *ptr = (GF_DataEntryURNBox *)s;\n\n\tif ( !(ptr->flags & 1)) {\n\t\tif (ptr->nameURN) ptr->size += 1 + strlen(ptr->nameURN);\n\t\tif (ptr->location) ptr->size += 1 + strlen(ptr->location);\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid unkn_box_del(GF_Box *s)\n{\n\tGF_UnknownBox *ptr = (GF_UnknownBox *) s;\n\tif (!s) return;\n\tif (ptr->data) gf_free(ptr->data);\n\tgf_free(ptr);\n}\n\n\nGF_Err unkn_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 bytesToRead, sub_size, sub_a;\n\tGF_BitStream *sub_bs;\n\tGF_UnknownBox *ptr = (GF_UnknownBox *)s;\n\tif (ptr->size > 0xFFFFFFFF) return GF_ISOM_INVALID_FILE;\n\tbytesToRead = (u32) (ptr->size);\n\n\tif (!bytesToRead) return GF_OK;\n\tif (bytesToRead>1000000) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Unknown box %s (0x%08X) with payload larger than 1 MBytes, ignoring\\n\", gf_4cc_to_str(ptr->original_4cc), ptr->original_4cc ));\n\t\tgf_bs_skip_bytes(bs, ptr->dataSize);\n\t\treturn GF_OK;\n\t}\n\n\tptr->data = (char*)gf_malloc(bytesToRead);\n\tif (ptr->data == NULL ) return GF_OUT_OF_MEM;\n\tptr->dataSize = bytesToRead;\n\tgf_bs_read_data(bs, ptr->data, ptr->dataSize);\n\n\t//try to parse container boxes, check if next 8 bytes match a subbox\n\tsub_bs = gf_bs_new(ptr->data, ptr->dataSize, GF_BITSTREAM_READ);\n\tsub_size = gf_bs_read_u32(sub_bs);\n\tsub_a = gf_bs_read_u8(sub_bs);\n\te = (sub_size && (sub_size <= ptr->dataSize)) ? GF_OK : GF_NOT_SUPPORTED;\n\tif (! isalnum(sub_a)) e = GF_NOT_SUPPORTED;\n\tsub_a = gf_bs_read_u8(sub_bs);\n\tif (! isalnum(sub_a)) e = GF_NOT_SUPPORTED;\n\tsub_a = gf_bs_read_u8(sub_bs);\n\tif (! isalnum(sub_a)) e = GF_NOT_SUPPORTED;\n\tsub_a = gf_bs_read_u8(sub_bs);\n\tif (! isalnum(sub_a)) e = GF_NOT_SUPPORTED;\n\n\tif (e == GF_OK) {\n\t\tgf_bs_seek(sub_bs, 0);\n\t\tgf_bs_set_cookie(sub_bs, GF_ISOM_BS_COOKIE_NO_LOGS);\n\t\te = gf_isom_box_array_read(s, sub_bs);\n\t}\n\tgf_bs_del(sub_bs);\n\tif (e==GF_OK) {\n\t\tgf_free(ptr->data);\n\t\tptr->data = NULL;\n\t\tptr->dataSize = 0;\n\t} else if (s->child_boxes) {\n\t\tgf_isom_box_array_del(s->child_boxes);\n\t\ts->child_boxes=NULL;\n\t}\n\n\treturn GF_OK;\n}\n\nGF_Box *unkn_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_UnknownBox, GF_ISOM_BOX_TYPE_UNKNOWN);\n\treturn (GF_Box *) tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err unkn_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 type;\n\tGF_UnknownBox *ptr = (GF_UnknownBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\tif (ptr->original_4cc == GF_ISOM_BOX_TYPE_UUID) return GF_BAD_PARAM;\n\ttype = s->type;\n\tptr->type = ptr->original_4cc;\n\te = gf_isom_box_write_header(s, bs);\n\tptr->type = type;\n\tif (e) return e;\n\n\tif (ptr->sai_type) {\n\t\tif (ptr->saio_box) {\n\t\t\tu64 pos = gf_bs_get_position(bs);\n\t\t\tgf_bs_seek(bs, ptr->saio_box->offset_first_offset_field);\n\t\t\tif (ptr->saio_box->version)\n\t\t\t\tgf_bs_write_u64(bs, pos);\n\t\t\telse\n\t\t\t\tgf_bs_write_u32(bs, (u32) pos);\n\t\t\tgf_bs_seek(bs, pos);\n\t\t} else {\n\t\t\tptr->sai_offset = gf_bs_get_position(bs);\n\t\t}\n\t}\n\n\tif (ptr->dataSize && ptr->data) {\n\t\tgf_bs_write_data(bs, ptr->data, ptr->dataSize);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err unkn_box_size(GF_Box *s)\n{\n\tGF_UnknownBox *ptr = (GF_UnknownBox *)s;\n\n\tif (ptr->dataSize && ptr->data) {\n\t\tptr->size += ptr->dataSize;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid def_parent_box_del(GF_Box *s)\n{\n\tif (s) gf_free(s);\n}\n\n\nGF_Err def_parent_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *def_parent_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_Box, 0);\n\treturn (GF_Box *) tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err def_parent_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err def_parent_box_size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid def_parent_full_box_del(GF_Box *s)\n{\n\tif (s) gf_free(s);\n}\n\n\nGF_Err def_parent_full_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *def_parent_full_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_Box, 0);\n\treturn (GF_Box *) tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err def_parent_full_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_full_box_write(s, bs);\n}\n\nGF_Err def_parent_full_box_size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid uuid_box_del(GF_Box *s)\n{\n\tGF_UnknownUUIDBox *ptr = (GF_UnknownUUIDBox *) s;\n\tif (!s) return;\n\tif (ptr->data) gf_free(ptr->data);\n\tgf_free(ptr);\n}\n\n\nGF_Err uuid_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 bytesToRead;\n\tGF_UnknownUUIDBox *ptr = (GF_UnknownUUIDBox *)s;\n\tif (ptr->size > 0xFFFFFFFF) return GF_ISOM_INVALID_FILE;\n\tbytesToRead = (u32) (ptr->size);\n\n\tif (bytesToRead) {\n\t\tptr->data = (char*)gf_malloc(bytesToRead);\n\t\tif (ptr->data == NULL ) return GF_OUT_OF_MEM;\n\t\tptr->dataSize = bytesToRead;\n\t\tgf_bs_read_data(bs, ptr->data, ptr->dataSize);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *uuid_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_UnknownUUIDBox, GF_ISOM_BOX_TYPE_UUID);\n\treturn (GF_Box *) tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err uuid_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_UnknownUUIDBox *ptr = (GF_UnknownUUIDBox*)s;\n\tif (!s) return GF_BAD_PARAM;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tif (ptr->data) {\n\t\tgf_bs_write_data(bs, ptr->data, ptr->dataSize);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err uuid_box_size(GF_Box *s)\n{\n\tGF_UnknownUUIDBox*ptr = (GF_UnknownUUIDBox*)s;\n\tptr->size += ptr->dataSize;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid dinf_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\n\nGF_Err dinf_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_DataInformationBox *ptr = (GF_DataInformationBox *)s;\n\tswitch(a->type) {\n\tcase GF_ISOM_BOX_TYPE_DREF:\n\t\tBOX_FIELD_ASSIGN(dref, GF_DataReferenceBox)\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err dinf_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_DataInformationBox *dinf;\n\tGF_Err e = gf_isom_box_array_read(s, bs);\n\tif (e) {\n\t\treturn e;\n\t}\n\tdinf = (GF_DataInformationBox *)s;\n\tif (!dinf->dref) {\n\t\tif (! (gf_bs_get_cookie(bs) & GF_ISOM_BS_COOKIE_NO_LOGS) ) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing dref box in dinf\\n\"));\n\t\t}\n\t\tdinf->dref = (GF_DataReferenceBox *) gf_isom_box_new_parent(&dinf->child_boxes, GF_ISOM_BOX_TYPE_DREF);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *dinf_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DataInformationBox, GF_ISOM_BOX_TYPE_DINF);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err dinf_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err dinf_box_size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid dref_box_del(GF_Box *s)\n{\n\tGF_DataReferenceBox *ptr = (GF_DataReferenceBox *) s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err dref_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_DataReferenceBox *ptr = (GF_DataReferenceBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tgf_bs_read_u32(bs);\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *dref_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DataReferenceBox, GF_ISOM_BOX_TYPE_DREF);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err dref_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 count;\n\tGF_DataReferenceBox *ptr = (GF_DataReferenceBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tcount = ptr->child_boxes ? gf_list_count(ptr->child_boxes) : 0;\n\tgf_bs_write_u32(bs, count);\n\treturn GF_OK;\n}\n\nGF_Err dref_box_size(GF_Box *s)\n{\n\tGF_DataReferenceBox *ptr = (GF_DataReferenceBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\n\tptr->size += 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid edts_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\n\nGF_Err edts_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_EditBox *ptr = (GF_EditBox *)s;\n\tif (a->type == GF_ISOM_BOX_TYPE_ELST) {\n\t\tBOX_FIELD_ASSIGN(editList, GF_EditListBox)\n\t\treturn GF_OK;\n\t} else {\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err edts_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *edts_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_EditBox, GF_ISOM_BOX_TYPE_EDTS);\n\treturn (GF_Box *) tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err edts_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_EditBox *ptr = (GF_EditBox *)s;\n\n\t//here we have a trick: if editList is empty, skip the box\n\tif (ptr->editList && gf_list_count(ptr->editList->entryList)) {\n\t\treturn gf_isom_box_write_header(s, bs);\n\t} else {\n\t\ts->size = 0;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err edts_box_size(GF_Box *s)\n{\n\tGF_EditBox *ptr = (GF_EditBox *)s;\n\n\t//here we have a trick: if editList is empty, skip the box\n\tif (!ptr->editList || ! gf_list_count(ptr->editList->entryList)) {\n\t\tptr->size = 0;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid elst_box_del(GF_Box *s)\n{\n\tGF_EditListBox *ptr;\n\tu32 nb_entries;\n\tu32 i;\n\n\tptr = (GF_EditListBox *)s;\n\tif (ptr == NULL) return;\n\tnb_entries = gf_list_count(ptr->entryList);\n\tfor (i = 0; i < nb_entries; i++) {\n\t\tGF_EdtsEntry *p = (GF_EdtsEntry*)gf_list_get(ptr->entryList, i);\n\t\tif (p) gf_free(p);\n\t}\n\tgf_list_del(ptr->entryList);\n\tgf_free(ptr);\n}\n\nGF_Err elst_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 entries;\n\ts32 tr;\n\tu32 nb_entries;\n\tGF_EditListBox *ptr = (GF_EditListBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tnb_entries = gf_bs_read_u32(bs);\n\n\tif (ptr->version == 1) {\n\t\tif (nb_entries > ptr->size / 20) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in ctts\\n\", nb_entries));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t} else {\n\t\tif (nb_entries > ptr->size / 12) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in ctts\\n\", nb_entries));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t}\n\n\n\tfor (entries = 0; entries < nb_entries; entries++) {\n\t\tGF_EdtsEntry *p;\n\t\tGF_SAFEALLOC(p, GF_EdtsEntry);\n\t\tif (!p) return GF_OUT_OF_MEM;\n\t\tif (ptr->version == 1) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 16);\n\t\t\tp->segmentDuration = gf_bs_read_u64(bs);\n\t\t\tp->mediaTime = (s64) gf_bs_read_u64(bs);\n\t\t} else {\n\t\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\t\tp->segmentDuration = gf_bs_read_u32(bs);\n\t\t\ttr = gf_bs_read_u32(bs);\n\t\t\tp->mediaTime = (s64) tr;\n\t\t}\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tp->mediaRate = gf_bs_read_u32(bs);\n\t\tgf_list_add(ptr->entryList, p);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *elst_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_EditListBox, GF_ISOM_BOX_TYPE_ELST);\n\ttmp->entryList = gf_list_new();\n\tif (!tmp->entryList) {\n\t\tgf_free(tmp);\n\t\treturn NULL;\n\t}\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err elst_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tu32 nb_entries;\n\tGF_EditListBox *ptr = (GF_EditListBox *)s;\n\tif (!ptr) return GF_BAD_PARAM;\n\n\tnb_entries = gf_list_count(ptr->entryList);\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, nb_entries);\n\tfor (i = 0; i < nb_entries; i++ ) {\n\t\tGF_EdtsEntry *p = (GF_EdtsEntry*)gf_list_get(ptr->entryList, i);\n\t\tif (ptr->version == 1) {\n\t\t\tgf_bs_write_u64(bs, p->segmentDuration);\n\t\t\tgf_bs_write_u64(bs, p->mediaTime);\n\t\t} else {\n\t\t\tgf_bs_write_u32(bs, (u32) p->segmentDuration);\n\t\t\tgf_bs_write_u32(bs, (s32) p->mediaTime);\n\t\t}\n\t\tgf_bs_write_u32(bs, p->mediaRate);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err elst_box_size(GF_Box *s)\n{\n\tu32 durtimebytes;\n\tu32 i, nb_entries;\n\tGF_EditListBox *ptr = (GF_EditListBox *)s;\n\n\t//entry count\n\tptr->size += 4;\n\tnb_entries = gf_list_count(ptr->entryList);\n\tptr->version = 0;\n\tfor (i=0; i<nb_entries; i++) {\n\t\tGF_EdtsEntry *p = (GF_EdtsEntry*)gf_list_get(ptr->entryList, i);\n\t\tif ((p->segmentDuration>0xFFFFFFFF) || (p->mediaTime>0xFFFFFFFF)) {\n\t\t\tptr->version = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tdurtimebytes = (ptr->version == 1 ? 16 : 8) + 4;\n\tptr->size += (nb_entries * durtimebytes);\n\treturn GF_OK;\n}\n\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid esds_box_del(GF_Box *s)\n{\n\tGF_ESDBox *ptr = (GF_ESDBox *)s;\n\tif (ptr == NULL)\treturn;\n\tif (ptr->desc) gf_odf_desc_del((GF_Descriptor *)ptr->desc);\n\tgf_free(ptr);\n}\n\n\nGF_Err esds_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e=GF_OK;\n\tu32 descSize;\n\tGF_ESDBox *ptr = (GF_ESDBox *)s;\n\n\tdescSize = (u32) (ptr->size);\n\n\tif (descSize) {\n\t\tchar *enc_desc = (char*)gf_malloc(sizeof(char) * descSize);\n\t\tif (!enc_desc) return GF_OUT_OF_MEM;\n\t\t//get the payload\n\t\tgf_bs_read_data(bs, enc_desc, descSize);\n\t\t//send it to the OD Codec\n\t\te = gf_odf_desc_read(enc_desc, descSize, (GF_Descriptor **) &ptr->desc);\n\t\t//OK, free our desc\n\t\tgf_free(enc_desc);\n\n\t\tif (ptr->desc && (ptr->desc->tag!=GF_ODF_ESD_TAG) ) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid descriptor tag 0x%x in esds\\n\", ptr->desc->tag));\n\t\t\tgf_odf_desc_del((GF_Descriptor*)ptr->desc);\n\t\t\tptr->desc=NULL;\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\n\t\tif (e) {\n\t\t\tptr->desc = NULL;\n\t\t} else {\n\t\t\t/*fix broken files*/\n\t\t\tif (ptr->desc && !ptr->desc->URLString) {\n\t\t\t\tif (!ptr->desc->slConfig) {\n\t\t\t\t\tptr->desc->slConfig = (GF_SLConfig *) gf_odf_desc_new(GF_ODF_SLC_TAG);\n\t\t\t\t\tptr->desc->slConfig->predefined = SLPredef_MP4;\n\t\t\t\t} else if (ptr->desc->slConfig->predefined != SLPredef_MP4) {\n\t\t\t\t\tptr->desc->slConfig->predefined = SLPredef_MP4;\n\t\t\t\t\tgf_odf_slc_set_pref(ptr->desc->slConfig);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn e;\n}\n\nGF_Box *esds_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ESDBox, GF_ISOM_BOX_TYPE_ESDS);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err esds_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu8 *enc_desc;\n\tu32 descSize = 0;\n\tGF_ESDBox *ptr = (GF_ESDBox *)s;\n\t//make sure we write with no ESID and no OCRESID\n    if (ptr->desc) {\n        ptr->desc->ESID = 0;\n        ptr->desc->OCRESID = 0;\n    }\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\te = gf_odf_desc_write((GF_Descriptor *)ptr->desc, &enc_desc, &descSize);\n\tif (e) return e;\n\tgf_bs_write_data(bs, enc_desc, descSize);\n\t//free our buffer\n\tgf_free(enc_desc);\n\treturn GF_OK;\n}\n\nGF_Err esds_box_size(GF_Box *s)\n{\n\tu32 descSize = 0;\n\tGF_ESDBox *ptr = (GF_ESDBox *)s;\n\t//make sure we write with no ESID and no OCRESID\n    if (ptr->desc) {\n        ptr->desc->ESID = 0;\n        ptr->desc->OCRESID = 0;\n    }\n\tdescSize = gf_odf_desc_size((GF_Descriptor *)ptr->desc);\n\tptr->size += descSize;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid free_box_del(GF_Box *s)\n{\n\tGF_FreeSpaceBox *ptr = (GF_FreeSpaceBox *)s;\n\tif (ptr->data) gf_free(ptr->data);\n\tgf_free(ptr);\n}\n\n\nGF_Err free_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 bytesToRead;\n\tGF_FreeSpaceBox *ptr = (GF_FreeSpaceBox *)s;\n\n\tif (ptr->size > 0xFFFFFFFF) return GF_IO_ERR;\n\n\tbytesToRead = (u32) (ptr->size);\n\n\tif (bytesToRead) {\n\t\tptr->data = (char*)gf_malloc(bytesToRead * sizeof(char));\n\t\tif (!ptr->data) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->data, bytesToRead);\n\t\tptr->dataSize = bytesToRead;\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *free_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_FreeSpaceBox, GF_ISOM_BOX_TYPE_FREE);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err free_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_FreeSpaceBox *ptr = (GF_FreeSpaceBox *)s;\n\tif (ptr->original_4cc) {\n\t\tu32 t = s->type;\n\t\ts->type=ptr->original_4cc;\n\t\te = gf_isom_box_write_header(s, bs);\n\t\ts->type=t;\n\t} else {\n\t\te = gf_isom_box_write_header(s, bs);\n\t}\n\tif (e) return e;\n\tif (ptr->dataSize)\t{\n\t\tif (ptr->data) {\n\t\t\tgf_bs_write_data(bs, ptr->data, ptr->dataSize);\n\t\t} else {\n\t\t\tu32 i = 0;\n\t\t\twhile (i<ptr->dataSize) {\n\t\t\t\tgf_bs_write_u8(bs, 0);\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err free_box_size(GF_Box *s)\n{\n\tGF_FreeSpaceBox *ptr = (GF_FreeSpaceBox *)s;\n\tptr->size += ptr->dataSize;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid ftyp_box_del(GF_Box *s)\n{\n\tGF_FileTypeBox *ptr = (GF_FileTypeBox *) s;\n\tif (ptr->altBrand) gf_free(ptr->altBrand);\n\tgf_free(ptr);\n}\n\nGF_Box *ftyp_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_FileTypeBox, GF_ISOM_BOX_TYPE_FTYP);\n\treturn (GF_Box *)tmp;\n}\n\nGF_Err ftyp_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_FileTypeBox *ptr = (GF_FileTypeBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 8);\n\tptr->majorBrand = gf_bs_read_u32(bs);\n\tptr->minorVersion = gf_bs_read_u32(bs);\n\n\tif (ptr->size % 4) return GF_ISOM_INVALID_FILE;\n\tptr->altCount = ( (u32) (ptr->size)) / 4;\n\tif (!ptr->altCount) return GF_OK;\n\n\tptr->altBrand = (u32*)gf_malloc(sizeof(u32)*ptr->altCount);\n\tif (!ptr->altBrand) return GF_OUT_OF_MEM;\n\n\tfor (i = 0; i<ptr->altCount; i++) {\n\t\tptr->altBrand[i] = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err ftyp_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_FileTypeBox *ptr = (GF_FileTypeBox *) s;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->majorBrand);\n\tgf_bs_write_u32(bs, ptr->minorVersion);\n\tfor (i=0; i<ptr->altCount; i++) {\n\t\tgf_bs_write_u32(bs, ptr->altBrand[i]);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err ftyp_box_size(GF_Box *s)\n{\n\tGF_FileTypeBox *ptr = (GF_FileTypeBox *)s;\n\n\tptr->size += 8 + ptr->altCount * 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid gnrm_box_del(GF_Box *s)\n{\n\tGF_GenericSampleEntryBox *ptr = (GF_GenericSampleEntryBox *)s;\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)ptr);\n\tif (ptr->data) gf_free(ptr->data);\n\tgf_free(ptr);\n}\n\nGF_Box *gnrm_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_GenericSampleEntryBox, GF_ISOM_BOX_TYPE_GNRM);\n\n\tgf_isom_sample_entry_init((GF_SampleEntryBox*)tmp);\n\treturn (GF_Box *)tmp;\n}\n\n//dummy\nGF_Err gnrm_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err gnrm_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_GenericSampleEntryBox *ptr = (GF_GenericSampleEntryBox *)s;\n\n\t//careful we are not writing the box type but the entry type so switch for write\n\tif (ptr->EntryType == GF_ISOM_BOX_TYPE_UUID) return GF_BAD_PARAM;\n\tptr->type = ptr->EntryType;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tptr->type = GF_ISOM_BOX_TYPE_GNRM;\n\tgf_bs_write_data(bs, ptr->reserved, 6);\n\tgf_bs_write_u16(bs, ptr->dataReferenceIndex);\n\tgf_bs_write_data(bs,  ptr->data, ptr->data_size);\n\treturn GF_OK;\n}\n\nGF_Err gnrm_box_size(GF_Box *s)\n{\n\tGF_GenericSampleEntryBox *ptr = (GF_GenericSampleEntryBox *)s;\n\ts->type = GF_ISOM_BOX_TYPE_GNRM;\n\tptr->size += 8+ptr->data_size;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid gnrv_box_del(GF_Box *s)\n{\n\tGF_GenericVisualSampleEntryBox *ptr = (GF_GenericVisualSampleEntryBox *)s;\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)ptr);\n\tif (ptr->data) gf_free(ptr->data);\n\tgf_free(ptr);\n}\n\nGF_Box *gnrv_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_GenericVisualSampleEntryBox, GF_ISOM_BOX_TYPE_GNRV);\n\tgf_isom_video_sample_entry_init((GF_VisualSampleEntryBox*) tmp);\n\treturn (GF_Box *)tmp;\n}\n//dummy\nGF_Err gnrv_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err gnrv_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_GenericVisualSampleEntryBox *ptr = (GF_GenericVisualSampleEntryBox *)s;\n\n\t//careful we are not writing the box type but the entry type so switch for write\n\tif (ptr->EntryType == GF_ISOM_BOX_TYPE_UUID) return GF_BAD_PARAM;\n\tptr->type = ptr->EntryType;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tptr->type = GF_ISOM_BOX_TYPE_GNRV;\n\n\tgf_isom_video_sample_entry_write((GF_VisualSampleEntryBox *)ptr, bs);\n\tgf_bs_write_data(bs,  ptr->data, ptr->data_size);\n\treturn GF_OK;\n}\n\nGF_Err gnrv_box_size(GF_Box *s)\n{\n\tGF_GenericVisualSampleEntryBox *ptr = (GF_GenericVisualSampleEntryBox *)s;\n\ts->type = GF_ISOM_BOX_TYPE_GNRV;\n\tgf_isom_video_sample_entry_size((GF_VisualSampleEntryBox *)s);\n\tptr->size += ptr->data_size;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid gnra_box_del(GF_Box *s)\n{\n\tGF_GenericAudioSampleEntryBox *ptr = (GF_GenericAudioSampleEntryBox *)s;\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)ptr);\n\tif (ptr->data) gf_free(ptr->data);\n\tgf_free(ptr);\n}\n\nGF_Box *gnra_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_GenericAudioSampleEntryBox, GF_ISOM_BOX_TYPE_GNRA);\n\tgf_isom_audio_sample_entry_init((GF_AudioSampleEntryBox*) tmp);\n\treturn (GF_Box *)tmp;\n}\n//dummy\nGF_Err gnra_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn GF_OK;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err gnra_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_GenericAudioSampleEntryBox *ptr = (GF_GenericAudioSampleEntryBox *)s;\n\n\t//careful we are not writing the box type but the entry type so switch for write\n\tif (ptr->EntryType == GF_ISOM_BOX_TYPE_UUID) return GF_BAD_PARAM;\n\tptr->type = ptr->EntryType;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tptr->type = GF_ISOM_BOX_TYPE_GNRA;\n\n\tgf_isom_audio_sample_entry_write((GF_AudioSampleEntryBox *)ptr, bs);\n\tif (ptr->data) {\n\t\tgf_bs_write_data(bs,  ptr->data, ptr->data_size);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err gnra_box_size(GF_Box *s)\n{\n\tGF_GenericAudioSampleEntryBox *ptr = (GF_GenericAudioSampleEntryBox *)s;\n\ts->type = GF_ISOM_BOX_TYPE_GNRA;\n\tgf_isom_audio_sample_entry_size((GF_AudioSampleEntryBox *)s);\n\tptr->size += ptr->data_size;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid hdlr_box_del(GF_Box *s)\n{\n\tGF_HandlerBox *ptr = (GF_HandlerBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->nameUTF8) gf_free(ptr->nameUTF8);\n\tgf_free(ptr);\n}\n\n\nGF_Err hdlr_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu64 cookie;\n\tGF_HandlerBox *ptr = (GF_HandlerBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 20);\n\tptr->reserved1 = gf_bs_read_u32(bs);\n\tptr->handlerType = gf_bs_read_u32(bs);\n\tgf_bs_read_data(bs, (char*)ptr->reserved2, 12);\n\n\tcookie = gf_bs_get_cookie(bs);\n\tif (ptr->handlerType==GF_ISOM_MEDIA_VISUAL)\n\t\tcookie |= GF_ISOM_BS_COOKIE_VISUAL_TRACK;\n\telse\n\t\tcookie &= ~GF_ISOM_BS_COOKIE_VISUAL_TRACK;\n\tgf_bs_set_cookie(bs, cookie);\n\n\tif (ptr->size) {\n\t\tu32 name_size = (u32) ptr->size;\n\t\tif (name_size < 1) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid size %llu in hdlr\\n\", ptr->size));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t\tptr->nameUTF8 = (char*)gf_malloc(name_size);\n\t\tif (!ptr->nameUTF8) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->nameUTF8, name_size);\n\n\t\t//patch for old QT files - we cannot rely on checking if str[0]==len(str+1) since we may have\n\t\t//cases where the first character of the string decimal value is indeed the same as the string length!!\n\t\t//we had this issue with encryption_import test\n\t\t//we therefore only check if last char is null, and if not so assume old QT style\n\t\tif (ptr->nameUTF8[name_size-1]) {\n\t\t\tif (name_size > 1)\n\t\t\t\tmemmove(ptr->nameUTF8, ptr->nameUTF8+1, sizeof(char) * (u32) (name_size-1) );\n\t\t\tptr->nameUTF8[name_size-1] = 0;\n\t\t\tptr->store_counted_string = GF_TRUE;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *hdlr_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_HandlerBox, GF_ISOM_BOX_TYPE_HDLR);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err hdlr_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_HandlerBox *ptr = (GF_HandlerBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->reserved1);\n\tgf_bs_write_u32(bs, ptr->handlerType);\n\tgf_bs_write_data(bs, (char*)ptr->reserved2, 12);\n\n\tif (ptr->nameUTF8) {\n\t\tu32 len = (u32)strlen(ptr->nameUTF8);\n\t\tif (ptr->store_counted_string) {\n\t\t\tgf_bs_write_u8(bs, len);\n\t\t\tgf_bs_write_data(bs, ptr->nameUTF8, len);\n\t\t} else {\n\t\t\tgf_bs_write_data(bs, ptr->nameUTF8, len);\n\t\t\tgf_bs_write_u8(bs, 0);\n\t\t}\n\t} else {\n\t\tgf_bs_write_u8(bs, 0);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err hdlr_box_size(GF_Box *s)\n{\n\tGF_HandlerBox *ptr = (GF_HandlerBox *)s;\n\tptr->size += 20 + 1; //null term or counted string\n\tif (ptr->nameUTF8) {\n\t\tptr->size += strlen(ptr->nameUTF8);\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid hinf_box_del(GF_Box *s)\n{\n\tGF_HintInfoBox *hinf = (GF_HintInfoBox *)s;\n\tgf_free(hinf);\n}\n\nGF_Box *hinf_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_HintInfoBox, GF_ISOM_BOX_TYPE_HINF);\n\n\ttmp->child_boxes = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\nGF_Err hinf_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_HintInfoBox *hinf = (GF_HintInfoBox *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_MAXR:\n\t\tif (!is_rem) {\n\t\t\tu32 i=0;\n\t\t\tGF_MAXRBox *maxR;\n\t\t\twhile ((maxR = (GF_MAXRBox *)gf_list_enum(hinf->child_boxes, &i))) {\n\t\t\t\tif ((maxR->type==GF_ISOM_BOX_TYPE_MAXR) && (maxR->granularity == ((GF_MAXRBox *)a)->granularity))\n\t\t\t\t\tERROR_ON_DUPLICATED_BOX(a, s)\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err hinf_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err hinf_box_write(GF_Box *s, GF_BitStream *bs)\n{\n//\tGF_HintInfoBox *ptr = (GF_HintInfoBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err hinf_box_size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid hmhd_box_del(GF_Box *s)\n{\n\tGF_HintMediaHeaderBox *ptr = (GF_HintMediaHeaderBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err hmhd_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_HintMediaHeaderBox *ptr = (GF_HintMediaHeaderBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 16);\n\tptr->maxPDUSize = gf_bs_read_u16(bs);\n\tptr->avgPDUSize = gf_bs_read_u16(bs);\n\tptr->maxBitrate = gf_bs_read_u32(bs);\n\tptr->avgBitrate = gf_bs_read_u32(bs);\n\tptr->slidingAverageBitrate = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\nGF_Box *hmhd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_HintMediaHeaderBox, GF_ISOM_BOX_TYPE_HMHD);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err hmhd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_HintMediaHeaderBox *ptr = (GF_HintMediaHeaderBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u16(bs, ptr->maxPDUSize);\n\tgf_bs_write_u16(bs, ptr->avgPDUSize);\n\tgf_bs_write_u32(bs, ptr->maxBitrate);\n\tgf_bs_write_u32(bs, ptr->avgBitrate);\n\tgf_bs_write_u32(bs, ptr->slidingAverageBitrate);\n\treturn GF_OK;\n}\n\nGF_Err hmhd_box_size(GF_Box *s)\n{\n\tGF_HintMediaHeaderBox *ptr = (GF_HintMediaHeaderBox *)s;\n\tptr->size += 16;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *hnti_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_HintTrackInfoBox, GF_ISOM_BOX_TYPE_HNTI);\n\treturn (GF_Box *)tmp;\n}\n\nvoid hnti_box_del(GF_Box *a)\n{\n\tgf_free(a);\n}\n\nGF_Err hnti_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_HintTrackInfoBox *ptr = (GF_HintTrackInfoBox *)s;\n\tif (!ptr || !a) return GF_BAD_PARAM;\n\n\tswitch (a->type) {\n\t//this is the value for GF_RTPBox - same as HintSampleEntry for RTP !!!\n\tcase GF_ISOM_BOX_TYPE_RTP:\n\tcase GF_ISOM_BOX_TYPE_SDP:\n\t\tBOX_FIELD_ASSIGN(SDP, GF_Box)\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err hnti_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err hnti_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\n\nGF_Err hnti_box_size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n/**********************************************************\n\t\tGF_SDPBox\n**********************************************************/\n\nvoid sdp_box_del(GF_Box *s)\n{\n\tGF_SDPBox *ptr = (GF_SDPBox *)s;\n\tif (ptr->sdpText) gf_free(ptr->sdpText);\n\tgf_free(ptr);\n\n}\nGF_Err sdp_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 length;\n\tGF_SDPBox *ptr = (GF_SDPBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\n\tlength = (u32) (ptr->size);\n\n\tif (length >= (u32)0xFFFFFFFF) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid length %lu in sdp box\\n\", length));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\t//sdp text has no delimiter !!!\n\tptr->sdpText = (char*)gf_malloc(sizeof(char) * (length+1));\n\tif (!ptr->sdpText) return GF_OUT_OF_MEM;\n\n\tgf_bs_read_data(bs, ptr->sdpText, length);\n\tptr->sdpText[length] = 0;\n\treturn GF_OK;\n}\nGF_Box *sdp_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SDPBox, GF_ISOM_BOX_TYPE_SDP);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err sdp_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SDPBox *ptr = (GF_SDPBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\t//don't write the NULL char!!!\n\tif (ptr->sdpText)\n\t\tgf_bs_write_data(bs, ptr->sdpText, (u32) strlen(ptr->sdpText));\n\treturn GF_OK;\n}\nGF_Err sdp_box_size(GF_Box *s)\n{\n\tGF_SDPBox *ptr = (GF_SDPBox *)s;\n\t//don't count the NULL char!!!\n\tif (ptr->sdpText)\n\t\tptr->size += strlen(ptr->sdpText);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n\nvoid rtp_hnti_box_del(GF_Box *s)\n{\n\tGF_RTPBox *ptr = (GF_RTPBox *)s;\n\tif (ptr->sdpText) gf_free(ptr->sdpText);\n\tgf_free(ptr);\n\n}\nGF_Err rtp_hnti_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 length;\n\tGF_RTPBox *ptr = (GF_RTPBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\n\tISOM_DECREASE_SIZE(ptr, 4)\n\tptr->subType = gf_bs_read_u32(bs);\n\n\tlength = (u32) (ptr->size);\n\n\tif (length >= (u32)0xFFFFFFFF) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid length %lu in rtp_hnti box\\n\", length));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\t//sdp text has no delimiter !!!\n\tptr->sdpText = (char*)gf_malloc(sizeof(char) * (length+1));\n\tif (!ptr->sdpText) return GF_OUT_OF_MEM;\n\n\tgf_bs_read_data(bs, ptr->sdpText, length);\n\tptr->sdpText[length] = 0;\n\treturn GF_OK;\n}\n\nGF_Box *rtp_hnti_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_RTPBox, GF_ISOM_BOX_TYPE_RTP);\n\ttmp->subType = GF_ISOM_BOX_TYPE_SDP;\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err rtp_hnti_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_RTPBox *ptr = (GF_RTPBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->subType);\n\t//don't write the NULL char!!!\n\tgf_bs_write_data(bs, ptr->sdpText, (u32) strlen(ptr->sdpText));\n\treturn GF_OK;\n}\n\nGF_Err rtp_hnti_box_size(GF_Box *s)\n{\n\tGF_RTPBox *ptr = (GF_RTPBox *)s;\n\tptr->size += 4 + strlen(ptr->sdpText);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tTRPY GF_Box\n**********************************************************/\n\nvoid trpy_box_del(GF_Box *s)\n{\n\tgf_free((GF_TRPYBox *)s);\n}\nGF_Err trpy_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TRPYBox *ptr = (GF_TRPYBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 8);\n\tptr->nbBytes = gf_bs_read_u64(bs);\n\treturn GF_OK;\n}\nGF_Box *trpy_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TRPYBox, GF_ISOM_BOX_TYPE_TRPY);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err trpy_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TRPYBox *ptr = (GF_TRPYBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u64(bs, ptr->nbBytes);\n\treturn GF_OK;\n}\nGF_Err trpy_box_size(GF_Box *s)\n{\n\ts->size += 8;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n/**********************************************************\n\t\tTOTL GF_Box\n**********************************************************/\n\nvoid totl_box_del(GF_Box *s)\n{\n\tgf_free((GF_TRPYBox *)s);\n}\nGF_Err totl_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TOTLBox *ptr = (GF_TOTLBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->nbBytes = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\nGF_Box *totl_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TOTLBox, GF_ISOM_BOX_TYPE_TOTL);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err totl_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TOTLBox *ptr = (GF_TOTLBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->nbBytes);\n\treturn GF_OK;\n}\nGF_Err totl_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tNUMP GF_Box\n**********************************************************/\n\nvoid nump_box_del(GF_Box *s)\n{\n\tgf_free((GF_NUMPBox *)s);\n}\nGF_Err nump_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_NUMPBox *ptr = (GF_NUMPBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 8);\n\tptr->nbPackets = gf_bs_read_u64(bs);\n\treturn GF_OK;\n}\nGF_Box *nump_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_NUMPBox, GF_ISOM_BOX_TYPE_NUMP);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err nump_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_NUMPBox *ptr = (GF_NUMPBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u64(bs, ptr->nbPackets);\n\treturn GF_OK;\n}\nGF_Err nump_box_size(GF_Box *s)\n{\n\ts->size += 8;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tNPCK GF_Box\n**********************************************************/\n\nvoid npck_box_del(GF_Box *s)\n{\n\tgf_free((GF_NPCKBox *)s);\n}\nGF_Err npck_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_NPCKBox *ptr = (GF_NPCKBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->nbPackets = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\nGF_Box *npck_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_NPCKBox, GF_ISOM_BOX_TYPE_NPCK);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err npck_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_NPCKBox *ptr = (GF_NPCKBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->nbPackets);\n\treturn GF_OK;\n}\nGF_Err npck_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tTPYL GF_Box\n**********************************************************/\n\nvoid tpyl_box_del(GF_Box *s)\n{\n\tgf_free((GF_NTYLBox *)s);\n}\nGF_Err tpyl_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_NTYLBox *ptr = (GF_NTYLBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\tISOM_DECREASE_SIZE(ptr, 8);\n\tptr->nbBytes = gf_bs_read_u64(bs);\n\treturn GF_OK;\n}\nGF_Box *tpyl_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_NTYLBox, GF_ISOM_BOX_TYPE_TPYL);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err tpyl_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_NTYLBox *ptr = (GF_NTYLBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u64(bs, ptr->nbBytes);\n\treturn GF_OK;\n}\nGF_Err tpyl_box_size(GF_Box *s)\n{\n\ts->size += 8;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n/**********************************************************\n\t\tTPAY GF_Box\n**********************************************************/\n\nvoid tpay_box_del(GF_Box *s)\n{\n\tgf_free((GF_TPAYBox *)s);\n}\nGF_Err tpay_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TPAYBox *ptr = (GF_TPAYBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->nbBytes = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\nGF_Box *tpay_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TPAYBox, GF_ISOM_BOX_TYPE_TPAY);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err tpay_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TPAYBox *ptr = (GF_TPAYBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->nbBytes);\n\treturn GF_OK;\n}\nGF_Err tpay_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tMAXR GF_Box\n**********************************************************/\n\nvoid maxr_box_del(GF_Box *s)\n{\n\tgf_free((GF_MAXRBox *)s);\n}\nGF_Err maxr_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MAXRBox *ptr = (GF_MAXRBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\tISOM_DECREASE_SIZE(ptr, 8);\n\tptr->granularity = gf_bs_read_u32(bs);\n\tptr->maxDataRate = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\nGF_Box *maxr_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MAXRBox, GF_ISOM_BOX_TYPE_MAXR);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err maxr_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MAXRBox *ptr = (GF_MAXRBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->granularity);\n\tgf_bs_write_u32(bs, ptr->maxDataRate);\n\treturn GF_OK;\n}\nGF_Err maxr_box_size(GF_Box *s)\n{\n\ts->size += 8;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tDMED GF_Box\n**********************************************************/\n\nvoid dmed_box_del(GF_Box *s)\n{\n\tgf_free((GF_DMEDBox *)s);\n}\nGF_Err dmed_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_DMEDBox *ptr = (GF_DMEDBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 8);\n\tptr->nbBytes = gf_bs_read_u64(bs);\n\treturn GF_OK;\n}\nGF_Box *dmed_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DMEDBox, GF_ISOM_BOX_TYPE_DMED);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err dmed_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_DMEDBox *ptr = (GF_DMEDBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u64(bs, ptr->nbBytes);\n\treturn GF_OK;\n}\nGF_Err dmed_box_size(GF_Box *s)\n{\n\ts->size += 8;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n/**********************************************************\n\t\tDIMM GF_Box\n**********************************************************/\n\nvoid dimm_box_del(GF_Box *s)\n{\n\tgf_free((GF_DIMMBox *)s);\n}\nGF_Err dimm_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_DIMMBox *ptr = (GF_DIMMBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 8)\n\tptr->nbBytes = gf_bs_read_u64(bs);\n\treturn GF_OK;\n}\nGF_Box *dimm_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DIMMBox, GF_ISOM_BOX_TYPE_DIMM);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err dimm_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_DIMMBox *ptr = (GF_DIMMBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u64(bs, ptr->nbBytes);\n\treturn GF_OK;\n}\nGF_Err dimm_box_size(GF_Box *s)\n{\n\ts->size += 8;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n/**********************************************************\n\t\tDREP GF_Box\n**********************************************************/\n\nvoid drep_box_del(GF_Box *s)\n{\n\tgf_free((GF_DREPBox *)s);\n}\nGF_Err drep_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_DREPBox *ptr = (GF_DREPBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 8)\n\tptr->nbBytes = gf_bs_read_u64(bs);\n\treturn GF_OK;\n}\nGF_Box *drep_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DREPBox, GF_ISOM_BOX_TYPE_DREP);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err drep_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_DREPBox *ptr = (GF_DREPBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u64(bs, ptr->nbBytes);\n\treturn GF_OK;\n}\nGF_Err drep_box_size(GF_Box *s)\n{\n\ts->size += 8;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n/**********************************************************\n\t\tTMIN GF_Box\n**********************************************************/\n\nvoid tmin_box_del(GF_Box *s)\n{\n\tgf_free((GF_TMINBox *)s);\n}\nGF_Err tmin_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TMINBox *ptr = (GF_TMINBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4)\n\tptr->minTime = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\nGF_Box *tmin_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TMINBox, GF_ISOM_BOX_TYPE_TMIN);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err tmin_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TMINBox *ptr = (GF_TMINBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->minTime);\n\treturn GF_OK;\n}\nGF_Err tmin_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tTMAX GF_Box\n**********************************************************/\n\nvoid tmax_box_del(GF_Box *s)\n{\n\tgf_free((GF_TMAXBox *)s);\n}\nGF_Err tmax_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TMAXBox *ptr = (GF_TMAXBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4)\n\tptr->maxTime = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\nGF_Box *tmax_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TMAXBox, GF_ISOM_BOX_TYPE_TMAX);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err tmax_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TMAXBox *ptr = (GF_TMAXBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->maxTime);\n\treturn GF_OK;\n}\nGF_Err tmax_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tPMAX GF_Box\n**********************************************************/\n\nvoid pmax_box_del(GF_Box *s)\n{\n\tgf_free((GF_PMAXBox *)s);\n}\nGF_Err pmax_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_PMAXBox *ptr = (GF_PMAXBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4)\n\tptr->maxSize = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\nGF_Box *pmax_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_PMAXBox, GF_ISOM_BOX_TYPE_PMAX);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err pmax_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_PMAXBox *ptr = (GF_PMAXBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->maxSize);\n\treturn GF_OK;\n}\nGF_Err pmax_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tDMAX GF_Box\n**********************************************************/\n\nvoid dmax_box_del(GF_Box *s)\n{\n\tgf_free((GF_DMAXBox *)s);\n}\nGF_Err dmax_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_DMAXBox *ptr = (GF_DMAXBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4)\n\tptr->maxDur = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\nGF_Box *dmax_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DMAXBox, GF_ISOM_BOX_TYPE_DMAX);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err dmax_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_DMAXBox *ptr = (GF_DMAXBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->maxDur);\n\treturn GF_OK;\n}\nGF_Err dmax_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tPAYT GF_Box\n**********************************************************/\n\nvoid payt_box_del(GF_Box *s)\n{\n\tGF_PAYTBox *payt = (GF_PAYTBox *)s;\n\tif (payt->payloadString) gf_free(payt->payloadString);\n\tgf_free(payt);\n}\nGF_Err payt_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 length;\n\tGF_PAYTBox *ptr = (GF_PAYTBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 5 );\n\tptr->payloadCode = gf_bs_read_u32(bs);\n\tlength = gf_bs_read_u8(bs);\n\tISOM_DECREASE_SIZE(ptr, length);\n\tptr->payloadString = (char*)gf_malloc(sizeof(char) * (length+1) );\n\tif (! ptr->payloadString) return GF_OUT_OF_MEM;\n\tgf_bs_read_data(bs, ptr->payloadString, length);\n\tptr->payloadString[length] = 0;\n\n\treturn GF_OK;\n}\nGF_Box *payt_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_PAYTBox, GF_ISOM_BOX_TYPE_PAYT);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err payt_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 len;\n\tGF_Err e;\n\tGF_PAYTBox *ptr = (GF_PAYTBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->payloadCode);\n    len = ptr->payloadString ? (u32) strlen(ptr->payloadString) : 0;\n\tgf_bs_write_u8(bs, len);\n\tif (len) gf_bs_write_data(bs, ptr->payloadString, len);\n\treturn GF_OK;\n}\nGF_Err payt_box_size(GF_Box *s)\n{\n\tGF_PAYTBox *ptr = (GF_PAYTBox *)s;\n\ts->size += 4 + 1;\n\tif (ptr->payloadString) ptr->size += strlen(ptr->payloadString);\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tPAYT GF_Box\n**********************************************************/\n\nvoid name_box_del(GF_Box *s)\n{\n\tGF_NameBox *name = (GF_NameBox *)s;\n\tif (name->string) gf_free(name->string);\n\tgf_free(name);\n}\nGF_Err name_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 length;\n\tGF_NameBox *ptr = (GF_NameBox *)s;\n\n\tlength = (u32) (ptr->size);\n\n\tif (length >= (u32)0xFFFFFFFF) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid length %lu in name box\\n\", length));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tptr->string = (char*)gf_malloc(sizeof(char) * (length+1));\n\tif (! ptr->string) return GF_OUT_OF_MEM;\n\n\tgf_bs_read_data(bs, ptr->string, length);\n\tptr->string[length] = 0;\n\treturn GF_OK;\n}\nGF_Box *name_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_NameBox, GF_ISOM_BOX_TYPE_NAME);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err name_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_NameBox *ptr = (GF_NameBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tif (ptr->string) {\n\t\tgf_bs_write_data(bs, ptr->string, (u32) strlen(ptr->string) + 1);\n\t}\n\treturn GF_OK;\n}\nGF_Err name_box_size(GF_Box *s)\n{\n\tGF_NameBox *ptr = (GF_NameBox *)s;\n\tif (ptr->string) ptr->size += strlen(ptr->string) + 1;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid tssy_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\nGF_Err tssy_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TimeStampSynchronyBox *ptr = (GF_TimeStampSynchronyBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 1)\n\tgf_bs_read_int(bs, 6);\n\tptr->timestamp_sync = gf_bs_read_int(bs, 2);\n\treturn GF_OK;\n}\nGF_Box *tssy_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TimeStampSynchronyBox, GF_ISOM_BOX_TYPE_TSSY);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err tssy_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TimeStampSynchronyBox *ptr = (GF_TimeStampSynchronyBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_int(bs, 0, 6);\n\tgf_bs_write_int(bs, ptr->timestamp_sync, 2);\n\treturn GF_OK;\n}\nGF_Err tssy_box_size(GF_Box *s)\n{\n\ts->size += 1;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid srpp_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err srpp_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_SRTPProcessBox *ptr = (GF_SRTPProcessBox *)s;\n\tswitch(a->type) {\n\tcase GF_ISOM_BOX_TYPE_SCHI:\n\t\tBOX_FIELD_ASSIGN(info, GF_SchemeInformationBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_SCHM:\n\t\tBOX_FIELD_ASSIGN(scheme_type, GF_SchemeTypeBox)\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err srpp_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_SRTPProcessBox *ptr = (GF_SRTPProcessBox *)s;\n\n\tISOM_DECREASE_SIZE(s, 16)\n\tptr->encryption_algorithm_rtp = gf_bs_read_u32(bs);\n\tptr->encryption_algorithm_rtcp = gf_bs_read_u32(bs);\n\tptr->integrity_algorithm_rtp = gf_bs_read_u32(bs);\n\tptr->integrity_algorithm_rtcp = gf_bs_read_u32(bs);\n\treturn gf_isom_box_array_read(s, bs);\n}\nGF_Box *srpp_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SRTPProcessBox, GF_ISOM_BOX_TYPE_SRPP);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err srpp_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SRTPProcessBox *ptr = (GF_SRTPProcessBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->encryption_algorithm_rtp);\n\tgf_bs_write_u32(bs, ptr->encryption_algorithm_rtcp);\n\tgf_bs_write_u32(bs, ptr->integrity_algorithm_rtp);\n\tgf_bs_write_u32(bs, ptr->integrity_algorithm_rtcp);\n\n\treturn GF_OK;\n}\nGF_Err srpp_box_size(GF_Box *s)\n{\n\tu32 pos = 0;\n\tGF_SRTPProcessBox *ptr = (GF_SRTPProcessBox *)s;\n\ts->size += 16;\n\tgf_isom_check_position(s, (GF_Box*)ptr->info, &pos);\n\tgf_isom_check_position(s, (GF_Box*)ptr->scheme_type, &pos);\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid rssr_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\nGF_Err rssr_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_ReceivedSsrcBox *ptr = (GF_ReceivedSsrcBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4)\n\tptr->ssrc = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\nGF_Box *rssr_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ReceivedSsrcBox, GF_ISOM_BOX_TYPE_RSSR);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err rssr_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ReceivedSsrcBox *ptr = (GF_ReceivedSsrcBox *)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->ssrc);\n\treturn GF_OK;\n}\nGF_Err rssr_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n\nvoid iods_box_del(GF_Box *s)\n{\n\tGF_ObjectDescriptorBox *ptr = (GF_ObjectDescriptorBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->descriptor) gf_odf_desc_del(ptr->descriptor);\n\tgf_free(ptr);\n}\n\n\nGF_Err iods_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 descSize;\n\tchar *desc;\n\tGF_ObjectDescriptorBox *ptr = (GF_ObjectDescriptorBox *)s;\n\n\t//use the OD codec...\n\tdescSize = (u32) (ptr->size);\n\tdesc = (char*)gf_malloc(sizeof(char) * descSize);\n\tif (!desc) return GF_OUT_OF_MEM;\n\n\tgf_bs_read_data(bs, desc, descSize);\n\te = gf_odf_desc_read(desc, descSize, &ptr->descriptor);\n\t//OK, free our desc\n\tgf_free(desc);\n\n\tif (e) return e;\n\tswitch (ptr->descriptor->tag) {\n\tcase GF_ODF_ISOM_OD_TAG:\n\tcase GF_ODF_ISOM_IOD_TAG:\n\t\tbreak;\n\tdefault:\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid descriptor in iods, tag %u found but only %u or %u allowed\\n\", ptr->descriptor->tag, GF_ODF_ISOM_IOD_TAG, GF_ODF_ISOM_OD_TAG ));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *iods_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ObjectDescriptorBox, GF_ISOM_BOX_TYPE_IODS);\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err iods_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 descSize;\n\tu8 *desc;\n\tGF_ObjectDescriptorBox *ptr = (GF_ObjectDescriptorBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\t//call our OD codec\n\te = gf_odf_desc_write(ptr->descriptor, &desc, &descSize);\n\tif (e) return e;\n\tgf_bs_write_data(bs, desc, descSize);\n\t//and free our stuff maybe!!\n\tgf_free(desc);\n\treturn GF_OK;\n}\n\nGF_Err iods_box_size(GF_Box *s)\n{\n\tGF_ObjectDescriptorBox *ptr = (GF_ObjectDescriptorBox *)s;\n\n\tptr->size += gf_odf_desc_size(ptr->descriptor);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid mdat_box_del(GF_Box *s)\n{\n\tGF_MediaDataBox *ptr = (GF_MediaDataBox *)s;\n\tif (!s) return;\n\n\tif (ptr->data) gf_free(ptr->data);\n\tgf_free(ptr);\n}\n\n\nGF_Err mdat_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MediaDataBox *ptr = (GF_MediaDataBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\tif (ptr->type==GF_ISOM_BOX_TYPE_IMDA) {\n\t\tptr->type = GF_ISOM_BOX_TYPE_MDAT;\n\t\tptr->is_imda = 1;\n\t\tISOM_DECREASE_SIZE(s, 4)\n\t\tptr->imda_id = gf_bs_read_u32(bs);\n\t}\n\n\tptr->dataSize = s->size;\n\tptr->bsOffset = gf_bs_get_position(bs);\n\n\t//store idat for rewrite\n\tif (ptr->type==GF_ISOM_BOX_TYPE_IDAT) {\n\t\tptr->data = gf_malloc(sizeof(u8) * (size_t)ptr->dataSize);\n\t\tif (!ptr->data) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->data, (u32) ptr->dataSize);\n\t\tptr->size = 0;\n\t\treturn GF_OK;\n\t}\n\n\t//then skip these bytes\n\tgf_bs_skip_bytes(bs, ptr->dataSize);\n\treturn GF_OK;\n}\n\nGF_Box *mdat_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MediaDataBox, GF_ISOM_BOX_TYPE_MDAT);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err mdat_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MediaDataBox *ptr = (GF_MediaDataBox *)s;\n\tif (ptr->is_imda) {\n\t\ts->type = GF_ISOM_BOX_TYPE_IMDA;\n\t\te = gf_isom_box_write_header(s, bs);\n\t\ts->type = GF_ISOM_BOX_TYPE_MDAT;\n\t\tif (e) return e;\n\t\tgf_bs_write_u32(bs, ptr->imda_id);\n\t} else {\n\t\te = gf_isom_box_write_header(s, bs);\n\t\tif (e) return e;\n\t}\n\n\t//make sure we have some data ...\n\t//if not, we handle that independently (edit files)\n\tif (ptr->data) {\n\t\tgf_bs_write_data(bs, ptr->data, (u32) ptr->dataSize);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err mdat_box_size(GF_Box *s)\n{\n\tGF_MediaDataBox *ptr = (GF_MediaDataBox *)s;\n\tptr->size += ptr->dataSize;\n\tif (ptr->is_imda)\n\t\tptr->size += 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid mdhd_box_del(GF_Box *s)\n{\n\tGF_MediaHeaderBox *ptr = (GF_MediaHeaderBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n// Mapping of QuickTime old language codes\n// https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap4/qtff4.html#//apple_ref/doc/uid/TP40000939-CH206-34320\n// to 3-letter codes (per ISO/IEC 639-2/T, https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes)\n// NOTE that Media Info maps them to 2-letter codes, possibly with region codes https://github.com/MediaArea/MediaInfoLib/blob/72213574cbf2ca01c0fbb97d2239b53891ad7b9d/Source/MediaInfo/Multiple/File_Mpeg4.cpp#L754\n// NOTE that FFMPEG mostly maps to ISO/IEC 639-2/B and sometimes 2-letter code\n// (see https://ffmpeg.org/doxygen/trunk/isom_8c_source.html)\nstatic const char* qtLanguages[] = {\n\t\"eng\", //  0 English\n\t\"fra\", //  1 French\n\t\"deu\", //  2 German\n\t\"ita\", //  3 Italian\n\t\"nld\", //  4 Dutch\n\t\"swe\", //  5 Swedish\n\t\"spa\", //  6 Spanish\n\t\"dan\", //  7 Danish\n\t\"por\", //  8 Portuguese\n\t\"nor\", //  9 Norwegian\n\t\"heb\", // 10 Hebrew\n\t\"jpn\", // 11 Japanese\n\t\"ara\", // 12 Arabic\n\t\"fin\", // 13 Finnish\n\t\"ell\", // 14 Greek\n\t\"isl\", // 15 Icelandic\n\t\"mlt\", // 16 Maltese\n\t\"tur\", // 17 Turkish\n\t\"hrv\", // 18 Croatian\n\t\"zho\", // 19 Traditional Chinese - general 3-letter code, ignoring the \"Traditional\" part\n\t\"urd\", // 20 Urdu\n\t\"hin\", // 21 Hindi\n\t\"tha\", // 22 Thai\n\t\"kor\", // 23 Korean\n\t\"lit\", // 24 Lithuanian\n\t\"pol\", // 25 Polish\n\t\"hun\", // 26 Hungarian\n\t\"est\", // 27 Estonian\n\t\"lav\", // 28 Lettish or Latvian\n\t\"sme\", // 29 Saami or Sami\n\t\"fao\", // 30 Faroese\n\t\"fas\", // 31 Farsi\n\t\"rus\", // 32 Russian\n\t\"zho\", // 33 Simplified Chinese - general 3-letter code, ignoring the \"Simplified\" part\n\t\"nld\", // 34 Flemish - using same code as Dutch\n\t\"gle\", // 35 Irish\n\t\"sqi\", // 36 Albanian\n\t\"ron\", // 37 Romanian\n\t\"ces\", // 38 Czech\n\t\"slk\", // 39 Slovak\n\t\"slv\", // 40 Slovenian\n\t\"yid\", // 41 Yiddish\n\t\"srp\", // 42 Serbian\n\t\"mkd\", // 43 Macedonian\n\t\"bul\", // 44 Bulgarian\n\t\"ukr\", // 45 Ukrainian\n\t\"bel\", // 46 Belarusian\n\t\"uzb\", // 47 Uzbek\n\t\"kaz\", // 48 Kazakh\n\t\"aze\", // 49 Azerbaijani\n\t\"aze\", // 50 AzerbaijanAr (Armenian-Azerbaijani) - using same code as Azerbaijani\n\t\"hye\", // 51 Armenian\n\t\"kat\", // 52 Georgian\n\t\"ron\", // 53 Moldavian\n\t\"kir\", // 54 Kirghiz\n\t\"tgk\", // 55 Tajik\n\t\"tuk\", // 56 Turkmen\n\t\"mon\", // 57 Mongolian\n\t\"mon\", // 58 MongolianCyr - using same code as Mongolian\n\t\"pus\", // 59 Pashto\n\t\"kur\", // 60 Kurdish\n\t\"kas\", // 61 Kashmiri\n\t\"snd\", // 62 Sindhi\n\t\"bod\", // 63 Tibetan\n\t\"nep\", // 64 Nepali\n\t\"san\", // 65 Sanskrit\n\t\"mar\", // 66 Marathi\n\t\"ben\", // 67 Bengali\n\t\"asm\", // 68 Assamese\n\t\"guj\", // 69 Gujarati\n\t\"pan\", // 70 Punjabi\n\t\"ori\", // 71 Oriya\n\t\"mal\", // 72 Malayalam\n\t\"kan\", // 73 Kannada\n\t\"tam\", // 74 Tamil\n\t\"tel\", // 75 Telugu\n\t\"sin\", // 76 Sinhala\n\t\"mya\", // 77 Burmese\n\t\"khm\", // 78 Khmer\n\t\"lao\", // 79 Lao\n\t\"vie\", // 80 Vietnamese\n\t\"ind\", // 81 Indonesian\n\t\"tgl\", // 82 Tagalog\n\t\"msa\", // 83 MalayRoman\n\t\"msa\", // 84 MalayArabic\n\t\"amh\", // 85 Amharic\n\t\"   \", // 86 Empty\n\t\"orm\", // 87 Oromo\n\t\"som\", // 88 Somali\n\t\"swa\", // 89 Swahili\n\t\"kin\", // 90 Kinyarwanda\n\t\"run\", // 91 Rundi\n\t\"nya\", // 92 Nyanja\n\t\"mlg\", // 93 Malagasy\n\t\"epo\", // 94 Esperanto\n\t// Gap 95-127\n\t\"cym\", // 128 Welsh\n\t\"eus\", // 129 Basque\n\t\"cat\", // 130 Catalan\n\t\"lat\", // 131 Latin\n\t\"que\", // 132 Quechua\n\t\"grn\", // 133 Guarani\n\t\"aym\", // 134 Aymara\n\t\"tat\", // 135 Tatar\n\t\"uig\", // 136 Uighur\n\t\"dzo\", // 127 Dzongkha\n\t\"jav\"  // 138 Javanese\n};\n//static const u8 qtLanguagesSize = GF_ARRAY_LENGTH(qtLanguages);\n\nGF_Err set_quicktime_lang(char lang[4], u8 code) {\n\tif (code > 138 || (code > 94 && code < 128) || code == 86) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid QuickTime Language Code %d\\n\", code));\n\t\treturn GF_BAD_PARAM;\n\t}\n\tif (code > 94)\n\t\tcode -=(128-94); // Gap in the list\n\tlang[0] = qtLanguages[code][0];\n\tlang[1] = qtLanguages[code][1];\n\tlang[2] = qtLanguages[code][2];\n\tlang[3] = qtLanguages[code][3];\n\treturn GF_OK;\n}\n\nGF_Err mdhd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MediaHeaderBox *ptr = (GF_MediaHeaderBox *)s;\n\n\tif (ptr->version == 1) {\n\t\tISOM_DECREASE_SIZE(ptr, 28)\n\t\tptr->creationTime = gf_bs_read_u64(bs);\n\t\tptr->modificationTime = gf_bs_read_u64(bs);\n\t\tptr->timeScale = gf_bs_read_u32(bs);\n\t\tptr->duration = gf_bs_read_u64(bs);\n\t} else {\n\t\tISOM_DECREASE_SIZE(ptr, 16)\n\t\tptr->creationTime = gf_bs_read_u32(bs);\n\t\tptr->modificationTime = gf_bs_read_u32(bs);\n\t\tptr->timeScale = gf_bs_read_u32(bs);\n\t\tptr->duration = gf_bs_read_u32(bs);\n\t}\n\tif (!ptr->timeScale) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Media header timescale is 0 - defaulting to 90000\\n\" ));\n\t\tptr->timeScale = 90000;\n\t}\n\n\tptr->original_duration = ptr->duration;\n\n\tISOM_DECREASE_SIZE(ptr, 4)\n\t//our padding bit\n\tgf_bs_read_int(bs, 1);\n\t//the spec is unclear here, just says \"the value 0 is interpreted as undetermined\"\n\tptr->packedLanguage[0] = gf_bs_read_int(bs, 5);\n\tptr->packedLanguage[1] = gf_bs_read_int(bs, 5);\n\tptr->packedLanguage[2] = gf_bs_read_int(bs, 5);\n\t//but before or after compaction ?? We assume before\n\tif (ptr->packedLanguage[0] || ptr->packedLanguage[1] || ptr->packedLanguage[2]) {\n\t\tif (ptr->packedLanguage[0] < 0x04) {\n\t\t\t// QuickTime Language Codes\n\t\t\tu8 code = (ptr->packedLanguage[0] << 16) | (ptr->packedLanguage[1] << 8) | ptr->packedLanguage[2];\n\t\t\tset_quicktime_lang(ptr->packedLanguage, code);\n\t\t} else {\n\t\t\tptr->packedLanguage[0] += 0x60;\n\t\t\tptr->packedLanguage[1] += 0x60;\n\t\t\tptr->packedLanguage[2] += 0x60;\n\t\t}\n\t} else {\n\t\tptr->packedLanguage[0] = 'u';\n\t\tptr->packedLanguage[1] = 'n';\n\t\tptr->packedLanguage[2] = 'd';\n\t}\n\tptr->reserved = gf_bs_read_u16(bs);\n\treturn GF_OK;\n}\n\nGF_Box *mdhd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MediaHeaderBox, GF_ISOM_BOX_TYPE_MDHD);\n\n\ttmp->packedLanguage[0] = 'u';\n\ttmp->packedLanguage[1] = 'n';\n\ttmp->packedLanguage[2] = 'd';\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err mdhd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MediaHeaderBox *ptr = (GF_MediaHeaderBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tif (ptr->version == 1) {\n\t\tgf_bs_write_u64(bs, ptr->creationTime);\n\t\tgf_bs_write_u64(bs, ptr->modificationTime);\n\t\tgf_bs_write_u32(bs, ptr->timeScale);\n\t\tgf_bs_write_u64(bs, ptr->duration);\n\t} else {\n\t\tgf_bs_write_u32(bs, (u32) ptr->creationTime);\n\t\tgf_bs_write_u32(bs, (u32) ptr->modificationTime);\n\t\tgf_bs_write_u32(bs, ptr->timeScale);\n\t\tgf_bs_write_u32(bs, (u32) ptr->duration);\n\t}\n\t//SPECS: BIT(1) of padding\n\tgf_bs_write_int(bs, 0, 1);\n\tgf_bs_write_int(bs, ptr->packedLanguage[0] - 0x60, 5);\n\tgf_bs_write_int(bs, ptr->packedLanguage[1] - 0x60, 5);\n\tgf_bs_write_int(bs, ptr->packedLanguage[2] - 0x60, 5);\n\tgf_bs_write_u16(bs, ptr->reserved);\n\treturn GF_OK;\n}\n\nGF_Err mdhd_box_size(GF_Box *s)\n{\n\tGF_MediaHeaderBox *ptr = (GF_MediaHeaderBox *)s;\n\tptr->version = (ptr->duration>0xFFFFFFFF) ? 1 : 0;\n\n\tptr->size += 4;\n\tptr->size += (ptr->version == 1) ? 28 : 16;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid mdia_box_del(GF_Box *s)\n{\n\tGF_MediaBox *ptr = (GF_MediaBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->nalu_parser) gf_bs_del(ptr->nalu_parser);\n\tif (ptr->nalu_out_bs) gf_bs_del(ptr->nalu_out_bs);\n\tif (ptr->nalu_ps_bs) gf_bs_del(ptr->nalu_ps_bs);\n\tif (ptr->extracted_bs) gf_bs_del(ptr->extracted_bs);\n\tif (ptr->extracted_samp) gf_isom_sample_del(&ptr->extracted_samp);\n\tif (ptr->in_sample_buffer) gf_free(ptr->in_sample_buffer);\n\tif (ptr->tmp_nal_copy_buffer) gf_free(ptr->tmp_nal_copy_buffer);\n\tgf_free(ptr);\n}\n\n\nGF_Err mdia_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_MediaBox *ptr = (GF_MediaBox *)s;\n\tswitch(a->type) {\n\tcase GF_ISOM_BOX_TYPE_MDHD:\n\t\tBOX_FIELD_ASSIGN(mediaHeader, GF_MediaHeaderBox)\n\t\treturn GF_OK;\n\n\tcase GF_ISOM_BOX_TYPE_HDLR:\n\t\tBOX_FIELD_ASSIGN(handler, GF_HandlerBox)\n\t\treturn GF_OK;\n\n\tcase GF_ISOM_BOX_TYPE_MINF:\n\t\tBOX_FIELD_ASSIGN(information, GF_MediaInformationBox)\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err mdia_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu64 cookie = gf_bs_get_cookie(bs);\n\tcookie &= ~GF_ISOM_BS_COOKIE_VISUAL_TRACK;\n\tgf_bs_set_cookie(bs, cookie);\n\te = gf_isom_box_array_read(s, bs);\n\tgf_bs_set_cookie(bs, cookie);\n\n\tif (e) return e;\n\tif (!((GF_MediaBox *)s)->information) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing MediaInformationBox\\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tif (!((GF_MediaBox *)s)->handler) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing HandlerBox\\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tif (!((GF_MediaBox *)s)->mediaHeader) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing MediaHeaderBox\\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *mdia_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MediaBox, GF_ISOM_BOX_TYPE_MDIA);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err mdia_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err mdia_box_size(GF_Box *s)\n{\n\tu32 pos = 0;\n\tGF_MediaBox *ptr = (GF_MediaBox *)s;\n\t//Header first\n\tgf_isom_check_position(s, (GF_Box*)ptr->mediaHeader, &pos);\n\t//then handler\n\tgf_isom_check_position(s, (GF_Box*)ptr->handler, &pos);\n\n#if 0\n\t//elng before info for CMAF info - we deactiveate for now, no specific errors raised and CMAF should not impose any order\n\tGF_Box *elng = gf_isom_box_find_child(ptr->child_boxes, GF_ISOM_BOX_TYPE_ELNG);\n\tif (elng)\n\t\tgf_isom_check_position(s, elng, &pos);\n#endif\n\n\t//then info\n\tgf_isom_check_position(s, (GF_Box*)ptr->information, &pos);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid mfra_box_del(GF_Box *s)\n{\n\tGF_MovieFragmentRandomAccessBox *ptr = (GF_MovieFragmentRandomAccessBox *)s;\n\tif (ptr == NULL) return;\n\tgf_list_del(ptr->tfra_list);\n\tgf_free(ptr);\n}\n\nGF_Box *mfra_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MovieFragmentRandomAccessBox, GF_ISOM_BOX_TYPE_MFRA);\n\ttmp->tfra_list = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\nGF_Err mfra_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_MovieFragmentRandomAccessBox *ptr = (GF_MovieFragmentRandomAccessBox *)s;\n\tswitch(a->type) {\n\tcase GF_ISOM_BOX_TYPE_TFRA:\n\t\tBOX_FIELD_LIST_ASSIGN(tfra_list);\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_MFRO:\n\t\tBOX_FIELD_ASSIGN(mfro, GF_MovieFragmentRandomAccessOffsetBox)\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err mfra_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err mfra_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err mfra_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_MovieFragmentRandomAccessBox *ptr = (GF_MovieFragmentRandomAccessBox *)s;\n\tgf_isom_check_position_list(s, ptr->tfra_list, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->mfro, &pos);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid tfra_box_del(GF_Box *s)\n{\n\tGF_TrackFragmentRandomAccessBox *ptr = (GF_TrackFragmentRandomAccessBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);\n}\n\nGF_Box *tfra_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackFragmentRandomAccessBox, GF_ISOM_BOX_TYPE_TFRA);\n\treturn (GF_Box *)tmp;\n}\n\nGF_Err tfra_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_RandomAccessEntry *p = 0;\n\tGF_TrackFragmentRandomAccessBox *ptr = (GF_TrackFragmentRandomAccessBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 12);\n\n\tptr->track_id = gf_bs_read_u32(bs);\n\tif (gf_bs_read_int(bs, 26) != 0)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tptr->traf_bits = (gf_bs_read_int(bs, 2) + 1) * 8;\n\tptr->trun_bits = (gf_bs_read_int(bs, 2) + 1) * 8;\n\tptr->sample_bits = (gf_bs_read_int(bs, 2) + 1) * 8;\n\n\tptr->nb_entries = gf_bs_read_u32(bs);\n\n\tif (ptr->version == 1) {\n\t\tif (ptr->nb_entries > ptr->size / (16+(ptr->traf_bits+ptr->trun_bits+ptr->sample_bits)/8)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in traf\\n\", ptr->nb_entries));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t} else {\n\t\tif (ptr->nb_entries > ptr->size / (8+(ptr->traf_bits+ptr->trun_bits+ptr->sample_bits)/8)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in traf\\n\", ptr->nb_entries));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t}\n\n\tif (ptr->nb_entries) {\n\t\tif ((u64)ptr->nb_entries > (u64)SIZE_MAX/sizeof(GF_RandomAccessEntry)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in traf\\n\", ptr->nb_entries));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t\tp = (GF_RandomAccessEntry *) gf_malloc(sizeof(GF_RandomAccessEntry) * ptr->nb_entries);\n\t\tif (!p) return GF_OUT_OF_MEM;\n\t}\n\n\tptr->entries = p;\n\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tmemset(p, 0, sizeof(GF_RandomAccessEntry));\n\n\t\tif (ptr->version == 1) {\n\t\t\tp->time = gf_bs_read_u64(bs);\n\t\t\tp->moof_offset = gf_bs_read_u64(bs);\n\t\t} else {\n\t\t\tp->time = gf_bs_read_u32(bs);\n\t\t\tp->moof_offset = gf_bs_read_u32(bs);\n\t\t}\n\t\tp->traf_number = gf_bs_read_int(bs, ptr->traf_bits);\n\t\tp->trun_number = gf_bs_read_int(bs, ptr->trun_bits);\n\t\tp->sample_number = gf_bs_read_int(bs, ptr->sample_bits);\n\n\t\t++p;\n\t}\n\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err tfra_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i, sap_nb_entries;\n\tGF_TrackFragmentRandomAccessBox *ptr = (GF_TrackFragmentRandomAccessBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->track_id);\n\tgf_bs_write_int(bs, 0, 26);\n\n\tgf_bs_write_int(bs, ptr->traf_bits/8 - 1, 2);\n\tgf_bs_write_int(bs, ptr->trun_bits/8 - 1, 2);\n\tgf_bs_write_int(bs, ptr->sample_bits/8 - 1, 2);\n\n\tsap_nb_entries = 0;\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tGF_RandomAccessEntry *p = &ptr->entries[i];\n\t\t//no sap found, do not store\n\t\tif (p->trun_number) sap_nb_entries++;\n\t}\n\n\tgf_bs_write_u32(bs, sap_nb_entries);\n\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tGF_RandomAccessEntry *p = &ptr->entries[i];\n\t\t//no sap found, do not store\n\t\tif (!p->trun_number) continue;\n\t\tif (ptr->version==1) {\n\t\t\tgf_bs_write_u64(bs, p->time);\n\t\t\tgf_bs_write_u64(bs, p->moof_offset);\n\t\t} else {\n\t\t\tgf_bs_write_u32(bs, (u32) p->time);\n\t\t\tgf_bs_write_u32(bs, (u32) p->moof_offset);\n\t\t}\n\t\tgf_bs_write_int(bs, p->traf_number, ptr->traf_bits);\n\t\tgf_bs_write_int(bs, p->trun_number, ptr->trun_bits);\n\t\tgf_bs_write_int(bs, p->sample_number, ptr->sample_bits);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err tfra_box_size(GF_Box *s)\n{\n\tu32 i;\n\tGF_TrackFragmentRandomAccessBox *ptr = (GF_TrackFragmentRandomAccessBox *)s;\n\tptr->size += 12;\n\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tGF_RandomAccessEntry *p = &ptr->entries[i];\n\t\t//no sap found, do not store\n\t\tif (!p->trun_number) continue;\n\t\tptr->size +=  ((ptr->version==1) ? 16 : 8 ) + ptr->traf_bits/8 + ptr->trun_bits/8 + ptr->sample_bits/8;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid mfro_box_del(GF_Box *s)\n{\n\tGF_MovieFragmentRandomAccessOffsetBox *ptr = (GF_MovieFragmentRandomAccessOffsetBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\nGF_Box *mfro_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MovieFragmentRandomAccessOffsetBox, GF_ISOM_BOX_TYPE_MFRO);\n\treturn (GF_Box *)tmp;\n}\n\nGF_Err mfro_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MovieFragmentRandomAccessOffsetBox *ptr = (GF_MovieFragmentRandomAccessOffsetBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->container_size = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err mfro_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MovieFragmentRandomAccessOffsetBox *ptr = (GF_MovieFragmentRandomAccessOffsetBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->container_size);\n\treturn GF_OK;\n}\n\nGF_Err mfro_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid elng_box_del(GF_Box *s)\n{\n\tGF_ExtendedLanguageBox *ptr = (GF_ExtendedLanguageBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->extended_language) gf_free(ptr->extended_language);\n\tgf_free(ptr);\n}\n\nGF_Err elng_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_ExtendedLanguageBox *ptr = (GF_ExtendedLanguageBox *)s;\n\n\tif (ptr->size) {\n\t\tptr->extended_language = (char*)gf_malloc((u32) ptr->size);\n\t\tif (ptr->extended_language == NULL) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->extended_language, (u32) ptr->size);\n\t\t/*safety check in case the string is not null-terminated*/\n\t\tif (ptr->extended_language[ptr->size-1]) {\n\t\t\tchar *str = (char*)gf_malloc((u32) ptr->size + 1);\n\t\t\tif (!str) return GF_OUT_OF_MEM;\n\t\t\tmemcpy(str, ptr->extended_language, (u32) ptr->size);\n\t\t\tstr[ptr->size] = 0;\n\t\t\tgf_free(ptr->extended_language);\n\t\t\tptr->extended_language = str;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *elng_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MediaBox, GF_ISOM_BOX_TYPE_ELNG);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err elng_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ExtendedLanguageBox *ptr = (GF_ExtendedLanguageBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tif (ptr->extended_language) {\n\t\tgf_bs_write_data(bs, ptr->extended_language, (u32)(strlen(ptr->extended_language)+1));\n\t}\n\treturn GF_OK;\n}\n\nGF_Err elng_box_size(GF_Box *s)\n{\n\tGF_ExtendedLanguageBox *ptr = (GF_ExtendedLanguageBox *)s;\n\n\tif (ptr->extended_language) {\n\t\tptr->size += strlen(ptr->extended_language)+1;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\nvoid mfhd_box_del(GF_Box *s)\n{\n\tGF_MovieFragmentHeaderBox *ptr = (GF_MovieFragmentHeaderBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\nGF_Err mfhd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MovieFragmentHeaderBox *ptr = (GF_MovieFragmentHeaderBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->sequence_number = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\nGF_Box *mfhd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MovieFragmentHeaderBox, GF_ISOM_BOX_TYPE_MFHD);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err mfhd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MovieFragmentHeaderBox *ptr = (GF_MovieFragmentHeaderBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->sequence_number);\n\treturn GF_OK;\n}\n\nGF_Err mfhd_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n\n\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM_FRAGMENTS*/\n\n\nvoid minf_box_del(GF_Box *s)\n{\n\tGF_MediaInformationBox *ptr = (GF_MediaInformationBox *)s;\n\tif (ptr == NULL) return;\n\n\t//if we have a Handler not self-contained, delete it (the self-contained belongs to the movie)\n\tif (ptr->dataHandler) {\n\t\tgf_isom_datamap_close(ptr);\n\t}\n\tgf_free(ptr);\n}\n\nGF_Err minf_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_MediaInformationBox *ptr = (GF_MediaInformationBox *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_NMHD:\n\tcase GF_ISOM_BOX_TYPE_STHD:\n\tcase GF_ISOM_BOX_TYPE_VMHD:\n\tcase GF_ISOM_BOX_TYPE_SMHD:\n\tcase GF_ISOM_BOX_TYPE_HMHD:\n\tcase GF_ISOM_BOX_TYPE_GMHD:\n\t\tBOX_FIELD_ASSIGN(InfoHeader, GF_Box)\n\t\treturn GF_OK;\n\n\tcase GF_ISOM_BOX_TYPE_DINF:\n\t\tBOX_FIELD_ASSIGN(dataInformation, GF_DataInformationBox)\n\t\treturn GF_OK;\n\n\tcase GF_ISOM_BOX_TYPE_STBL:\n\t\tBOX_FIELD_ASSIGN(sampleTable, GF_SampleTableBox)\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err minf_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MediaInformationBox *ptr = (GF_MediaInformationBox *)s;\n\tGF_Err e;\n\n\te = gf_isom_box_array_read(s, bs);\n\n\tif (!e && ! ptr->dataInformation) {\n\t\tGF_Box *url;\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing DataInformationBox\\n\"));\n\t\t//commented on purpose, we are still able to handle the file, we only throw an error but keep processing\n//\t\te = GF_ISOM_INVALID_FILE;\n\n\t\t//add a dinf box to avoid any access to a null dinf\n\t\tptr->dataInformation = (GF_DataInformationBox *) gf_isom_box_new_parent(&ptr->child_boxes, GF_ISOM_BOX_TYPE_DINF);\n\t\tif (!ptr->dataInformation) return GF_OUT_OF_MEM;\n\n\t\tptr->dataInformation->dref = (GF_DataReferenceBox *) gf_isom_box_new_parent(&ptr->dataInformation->child_boxes, GF_ISOM_BOX_TYPE_DREF);\n\t\tif (!ptr->dataInformation->dref) return GF_OUT_OF_MEM;\n\n\t\turl = gf_isom_box_new_parent(&ptr->dataInformation->dref->child_boxes, GF_ISOM_BOX_TYPE_URL);\n\t\tif (!url) return GF_OUT_OF_MEM;\n\t\t((GF_FullBox*)url)->flags = 1;\n\t}\n\treturn e;\n}\n\nGF_Box *minf_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MediaInformationBox, GF_ISOM_BOX_TYPE_MINF);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err minf_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err minf_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_MediaInformationBox *ptr = (GF_MediaInformationBox *)s;\n\t//Header first\n\tgf_isom_check_position(s, (GF_Box *)ptr->InfoHeader, &pos);\n\t//then dataInfo\n\tgf_isom_check_position(s, (GF_Box *)ptr->dataInformation, &pos);\n\tgf_isom_check_position(s, gf_isom_box_find_child(s->child_boxes, GF_ISOM_BOX_TYPE_MVCI), &pos);\n\t//then sampleTable\n\tgf_isom_check_position(s, (GF_Box *)ptr->sampleTable, &pos);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\nvoid moof_box_del(GF_Box *s)\n{\n\tGF_MovieFragmentBox *ptr = (GF_MovieFragmentBox *)s;\n\tif (ptr == NULL) return;\n\n\tgf_list_del(ptr->TrackList);\n\tif (ptr->PSSHs) gf_list_del(ptr->PSSHs);\n\tif (ptr->mdat) gf_free(ptr->mdat);\n\t//happens if error while fragmenting, the emsg boxes are not part of the moof hierarchy !\n\tif (ptr->emsgs) {\n\t\twhile (1) {\n\t\t\tGF_Box *emsg = gf_list_pop_front(ptr->emsgs);\n\t\t\tif (!emsg) break;\n\t\t\tgf_isom_box_del(emsg);\n\t\t}\n\t\tgf_list_del(ptr->emsgs);\n\t}\n\tgf_list_del(ptr->trun_list);\n\tgf_free(ptr);\n}\n\nGF_Err moof_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_MovieFragmentBox *ptr = (GF_MovieFragmentBox *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_MFHD:\n\t\tBOX_FIELD_ASSIGN(mfhd, GF_MovieFragmentHeaderBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_TRAF:\n\t\tBOX_FIELD_LIST_ASSIGN(TrackList)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_PSSH:\n\t\tBOX_FIELD_LIST_ASSIGN(PSSHs)\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err moof_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *moof_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MovieFragmentBox, GF_ISOM_BOX_TYPE_MOOF);\n\ttmp->TrackList = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err moof_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err moof_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_MovieFragmentBox *ptr = (GF_MovieFragmentBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\t//Header First\n\tgf_isom_check_position(s, (GF_Box *)ptr->mfhd, &pos);\n\t//then PSSH\n\tgf_isom_check_position_list(s, ptr->PSSHs, &pos);\n\t//then the track list\n\tgf_isom_check_position_list(s, ptr->TrackList, &pos);\n\treturn GF_OK;\n}\n\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM_FRAGMENTS*/\n\nvoid moov_box_del(GF_Box *s)\n{\n\tGF_MovieBox *ptr = (GF_MovieBox *)s;\n\tif (ptr == NULL) return;\n\tgf_list_del(ptr->trackList);\n\tgf_free(ptr);\n}\n\nGF_Err moov_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_MovieBox *ptr = (GF_MovieBox *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_IODS:\n\t\tBOX_FIELD_ASSIGN(iods, GF_ObjectDescriptorBox)\n\t\t//if no IOD, delete the box\n\t\tif (ptr->iods && !ptr->iods->descriptor) {\n\t\t\tptr->iods = NULL;\n\t\t\tgf_isom_box_del_parent(&s->child_boxes, a);\n\t\t}\n\t\treturn GF_OK;\n\n\tcase GF_ISOM_BOX_TYPE_MVHD:\n\t\tBOX_FIELD_ASSIGN(mvhd, GF_MovieHeaderBox)\n\t\treturn GF_OK;\n\n\tcase GF_ISOM_BOX_TYPE_UDTA:\n\t\tBOX_FIELD_ASSIGN(udta, GF_UserDataBox)\n\t\treturn GF_OK;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tcase GF_ISOM_BOX_TYPE_MVEX:\n\t\tBOX_FIELD_ASSIGN(mvex, GF_MovieExtendsBox)\n\t\tif (ptr->mvex)\n\t\t\tptr->mvex->mov = ptr->mov;\n\t\treturn GF_OK;\n#endif\n\n\tcase GF_ISOM_BOX_TYPE_META:\n\t\tBOX_FIELD_ASSIGN(meta, GF_MetaBox)\n\t\treturn GF_OK;\n\n\tcase GF_ISOM_BOX_TYPE_TRAK:\n\t\tif (is_rem) {\n\t\t\tgf_list_del_item(ptr->trackList, a);\n\t\t\treturn GF_OK;\n\t\t}\n\t\t{\n\t\t\tGF_TrackBox *tk = (GF_TrackBox *)a;\n\t\t\t//set our pointer to this obj\n\t\t\ttk->moov = ptr;\n\t\t\ttk->index = 1+gf_list_count(ptr->trackList);\n\t\t\tif (tk->References) {\n\t\t\t\tGF_TrackReferenceTypeBox *dpnd=NULL;\n\t\t\t\tTrack_FindRef(tk, GF_ISOM_REF_BASE, &dpnd);\n\t\t\t\tif (dpnd)\n\t\t\t\t\ttk->nb_base_refs = dpnd->trackIDCount;\n\t\t\t}\n\t\t}\n\t\treturn gf_list_add(ptr->trackList, a);\n\tcase GF_QT_BOX_TYPE_CMVD:\n\t\tptr->has_cmvd = GF_TRUE;\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err moov_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *moov_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MovieBox, GF_ISOM_BOX_TYPE_MOOV);\n\ttmp->trackList = gf_list_new();\n\tif (!tmp->trackList) {\n\t\tgf_free(tmp);\n\t\treturn NULL;\n\t}\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err moov_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err moov_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_MovieBox *ptr = (GF_MovieBox *)s;\n\n\tgf_isom_check_position(s, (GF_Box *) ptr->mvhd, &pos);\n\tgf_isom_check_position(s, (GF_Box *) ptr->iods, &pos);\n\tgf_isom_check_position(s, (GF_Box *) ptr->meta, &pos);\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (ptr->mvex && !ptr->mvex_after_traks) {\n\t\tgf_isom_check_position(s, (GF_Box *) ptr->mvex, &pos);\n\t}\n#endif\n\tgf_isom_check_position_list(s, ptr->trackList, &pos);\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (ptr->mvex && ptr->mvex_after_traks) {\n\t\tgf_isom_check_position(s, (GF_Box *) ptr->mvex, &pos);\n\t}\n#endif\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid audio_sample_entry_box_del(GF_Box *s)\n{\n\tGF_MPEGAudioSampleEntryBox *ptr = (GF_MPEGAudioSampleEntryBox *)s;\n\tif (ptr == NULL) return;\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)s);\n\tif (ptr->slc) gf_odf_desc_del((GF_Descriptor *)ptr->slc);\n\tgf_free(ptr);\n}\n\nGF_Err audio_sample_entry_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_UnknownBox *wave = NULL;\n\tBool drop_wave=GF_FALSE;\n\tGF_MPEGAudioSampleEntryBox *ptr = (GF_MPEGAudioSampleEntryBox *)s;\n\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_ESDS:\n\t\tBOX_FIELD_ASSIGN(esd, GF_ESDBox)\n\t\tptr->qtff_mode = GF_ISOM_AUDIO_QTFF_NONE;\n\t\tbreak;\n\n\tcase GF_ISOM_BOX_TYPE_DAMR:\n\tcase GF_ISOM_BOX_TYPE_DEVC:\n\tcase GF_ISOM_BOX_TYPE_DQCP:\n\tcase GF_ISOM_BOX_TYPE_DSMV:\n\t\tBOX_FIELD_ASSIGN(cfg_3gpp, GF_3GPPConfigBox)\n\t\t/*for 3GP config, remember sample entry type in config*/\n\t\tptr->cfg_3gpp->cfg.type = ptr->type;\n\t\tptr->qtff_mode = GF_ISOM_AUDIO_QTFF_NONE;\n\t\tbreak;\n\n\tcase GF_ISOM_BOX_TYPE_DOPS:\n\t\tBOX_FIELD_ASSIGN(cfg_opus, GF_OpusSpecificBox)\n\t\tptr->qtff_mode = GF_ISOM_AUDIO_QTFF_NONE;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_DAC3:\n\t\tBOX_FIELD_ASSIGN(cfg_ac3, GF_AC3ConfigBox)\n\t\tptr->qtff_mode = GF_ISOM_AUDIO_QTFF_NONE;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_DEC3:\n\t\tBOX_FIELD_ASSIGN(cfg_ac3, GF_AC3ConfigBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_DMLP:\n\t\tBOX_FIELD_ASSIGN(cfg_mlp, GF_TrueHDConfigBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MHAC:\n\t\tBOX_FIELD_ASSIGN(cfg_mha, GF_MHAConfigBox)\n\t\tptr->qtff_mode = GF_ISOM_AUDIO_QTFF_NONE;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_DFLA:\n\t\tBOX_FIELD_ASSIGN(cfg_flac, GF_FLACConfigBox)\n\t\tptr->qtff_mode = GF_ISOM_AUDIO_QTFF_NONE;\n\t\tbreak;\n\n\tcase GF_ISOM_BOX_TYPE_UNKNOWN:\n\t\twave = (GF_UnknownBox *)a;\n\t\t/*HACK for QT files: get the esds box from the track*/\n\t\tif (s->type == GF_ISOM_BOX_TYPE_MP4A) {\n\t\t\tif (is_rem) {\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\tif (ptr->esd) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\t//wave subboxes may have been properly parsed\n \t\t\tif ((wave->original_4cc == GF_QT_BOX_TYPE_WAVE) && gf_list_count(wave->child_boxes)) {\n \t\t\t\tu32 i;\n                for (i =0; i<gf_list_count(wave->child_boxes); i++) {\n                    GF_Box *inner_box = (GF_Box *)gf_list_get(wave->child_boxes, i);\n                    if (inner_box->type == GF_ISOM_BOX_TYPE_ESDS) {\n                        ptr->esd = (GF_ESDBox *)inner_box;\n \t\t\t\t\t\tif (ptr->qtff_mode & GF_ISOM_AUDIO_QTFF_CONVERT_FLAG) {\n                        \tgf_list_rem(a->child_boxes, i);\n                        \tdrop_wave=GF_TRUE;\n                        \tptr->compression_id = 0;\n                        \tgf_list_add(ptr->child_boxes, inner_box);\n\t\t\t\t\t\t}\n                    }\n                }\n\t\t\t\tif (drop_wave) {\n\t\t\t\t\tgf_isom_box_del_parent(&ptr->child_boxes, a);\n                \tptr->qtff_mode = GF_ISOM_AUDIO_QTFF_NONE;\n\t\t\t\t\tptr->version = 0;\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t}\n                ptr->qtff_mode = GF_ISOM_AUDIO_QTFF_ON_EXT_VALID;\n                return GF_OK;\n            }\n            gf_isom_box_del_parent(&ptr->child_boxes, a);\n            return GF_ISOM_INVALID_MEDIA;\n\n\t\t}\n \t\tptr->qtff_mode &= ~GF_ISOM_AUDIO_QTFF_CONVERT_FLAG;\n\n \t\tif ((wave->original_4cc == GF_QT_BOX_TYPE_WAVE) && gf_list_count(wave->child_boxes)) {\n\t\t\tptr->qtff_mode = GF_ISOM_AUDIO_QTFF_ON_NOEXT;\n\t\t}\n\t\treturn GF_OK;\n\tcase GF_QT_BOX_TYPE_WAVE:\n\t{\n\t\tu32 subtype = 0;\n\t\tGF_Box **cfg_ptr = NULL;\n\t\tif (s->type == GF_ISOM_BOX_TYPE_MP4A) {\n\t\t\tcfg_ptr = (GF_Box **) &ptr->esd;\n\t\t\tsubtype = GF_ISOM_BOX_TYPE_ESDS;\n\t\t}\n\t\telse if (s->type == GF_ISOM_BOX_TYPE_AC3) {\n\t\t\tcfg_ptr = (GF_Box **) &ptr->cfg_ac3;\n\t\t\tsubtype = GF_ISOM_BOX_TYPE_DAC3;\n\t\t}\n\t\telse if (s->type == GF_ISOM_BOX_TYPE_EC3) {\n\t\t\tcfg_ptr = (GF_Box **) &ptr->cfg_ac3;\n\t\t\tsubtype = GF_ISOM_BOX_TYPE_DEC3;\n\t\t}\n\t\telse if (s->type == GF_ISOM_BOX_TYPE_OPUS) {\n\t\t\tcfg_ptr = (GF_Box **) &ptr->cfg_opus;\n\t\t\tsubtype = GF_ISOM_BOX_TYPE_DOPS;\n\t\t}\n\t\telse if ((s->type == GF_ISOM_BOX_TYPE_MHA1)\n\t\t\t|| (s->type == GF_ISOM_BOX_TYPE_MHA2)\n\t\t\t|| (s->type == GF_ISOM_BOX_TYPE_MHM1)\n\t\t\t|| (s->type == GF_ISOM_BOX_TYPE_MHM2)\n\t\t) {\n\t\t\tcfg_ptr = (GF_Box **) &ptr->cfg_mha;\n\t\t\tsubtype = GF_ISOM_BOX_TYPE_MHAC;\n\t\t}\n\t\telse if (s->type == GF_ISOM_BOX_TYPE_MLPA) {\n\t\t\tcfg_ptr = (GF_Box **) &ptr->cfg_mlp;\n\t\t\tsubtype = GF_ISOM_BOX_TYPE_DMLP;\n\t\t}\n\n\t\tif (cfg_ptr) {\n\t\t\tif (is_rem) {\n\t\t\t\t*cfg_ptr = NULL;\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\tif (*cfg_ptr) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\n\t\t\t//wave subboxes may have been properly parsed\n \t\t\tif (gf_list_count(a->child_boxes)) {\n \t\t\t\tu32 i;\n                for (i =0; i<gf_list_count(a->child_boxes); i++) {\n                    GF_Box *inner_box = (GF_Box *)gf_list_get(a->child_boxes, i);\n                    if (inner_box->type == subtype) {\n                        *cfg_ptr = inner_box;\n \t\t\t\t\t\tif (ptr->qtff_mode & GF_ISOM_AUDIO_QTFF_CONVERT_FLAG) {\n                        \tgf_list_rem(a->child_boxes, i);\n                        \tdrop_wave=GF_TRUE;\n                        \tgf_list_add(ptr->child_boxes, inner_box);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n                    }\n                }\n\t\t\t\tif (drop_wave) {\n\t\t\t\t\tgf_isom_box_del_parent(&ptr->child_boxes, a);\n                \tptr->qtff_mode = GF_ISOM_AUDIO_QTFF_NONE;\n\t\t\t\t\tptr->compression_id = 0;\n\t\t\t\t\tptr->version = 0;\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t}\n                ptr->qtff_mode = GF_ISOM_AUDIO_QTFF_ON_EXT_VALID;\n                return GF_OK;\n            }\n\t\t}\n\t}\n \t\tptr->qtff_mode = GF_ISOM_AUDIO_QTFF_ON_EXT_VALID;\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\nGF_Err audio_sample_entry_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MPEGAudioSampleEntryBox *ptr;\n\tchar *data;\n\tu8 a, b, c, d;\n\tu32 i, size, v, nb_alnum;\n\tGF_Err e;\n\tu64 pos, start;\n\n\tptr = (GF_MPEGAudioSampleEntryBox *)s;\n\n\tstart = gf_bs_get_position(bs);\n\tv = gf_bs_peek_bits(bs, 16, 8);\n\tif (v)\n\t\tptr->qtff_mode = GF_ISOM_AUDIO_QTFF_ON_NOEXT;\n\n\t//try to disambiguate QTFF v1 and MP4 v1 audio sample entries ...\n\tif (v==1) {\n\t\t//go to end of ISOM audio sample entry, skip 4 byte (box size field), read 4 bytes (box type) and check if this looks like a box\n\t\tgf_bs_skip_bytes(bs, 8 + 20 + 4);\n\t\ta = gf_bs_read_u8(bs);\n\t\tb = gf_bs_read_u8(bs);\n\t\tc = gf_bs_read_u8(bs);\n\t\td = gf_bs_read_u8(bs);\n\t\tnb_alnum = 0;\n\t\tif (isalnum(a)) nb_alnum++;\n\t\tif (isalnum(b)) nb_alnum++;\n\t\tif (isalnum(c)) nb_alnum++;\n\t\tif (isalnum(d)) nb_alnum++;\n\t\tif (nb_alnum>2) ptr->qtff_mode = GF_ISOM_AUDIO_QTFF_NONE;\n\t\tgf_bs_seek(bs, start);\n\t}\n\n\te = gf_isom_audio_sample_entry_read((GF_AudioSampleEntryBox*)s, bs);\n\tif (e) return e;\n\tpos = gf_bs_get_position(bs);\n\tsize = (u32) s->size;\n\n\t//when cookie is set on bs, always convert qtff-style mp4a to isobmff-style\n\t//since the conversion is done in addBox and we don't have the bitstream there (arg...), flag the box\n \tif (gf_bs_get_cookie(bs) & GF_ISOM_BS_COOKIE_QT_CONV) {\n \t\tptr->qtff_mode |= GF_ISOM_AUDIO_QTFF_CONVERT_FLAG;\n \t}\n\n\te = gf_isom_box_array_read(s, bs);\n\tif (!e) {\n\t\tif (s->type==GF_ISOM_BOX_TYPE_ENCA) {\n\t\t\tGF_ProtectionSchemeInfoBox *sinf = (GF_ProtectionSchemeInfoBox *) gf_isom_box_find_child(s->child_boxes, GF_ISOM_BOX_TYPE_SINF);\n\n\t\t\tif (sinf && sinf->original_format) {\n\t\t\t\tu32 type = sinf->original_format->data_format;\n\t\t\t\tswitch (type) {\n\t\t\t\tcase GF_ISOM_SUBTYPE_3GP_AMR:\n\t\t\t\tcase GF_ISOM_SUBTYPE_3GP_AMR_WB:\n\t\t\t\tcase GF_ISOM_SUBTYPE_3GP_EVRC:\n\t\t\t\tcase GF_ISOM_SUBTYPE_3GP_QCELP:\n\t\t\t\tcase GF_ISOM_SUBTYPE_3GP_SMV:\n\t\t\t\t\tif (ptr->cfg_3gpp) ptr->cfg_3gpp->cfg.type = type;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn GF_OK;\n\t}\n\tif (size<8) return GF_ISOM_INVALID_FILE;\n\n\n\t/*hack for some weird files (possibly recorded with live.com tools, needs further investigations)*/\n\tgf_bs_seek(bs, pos);\n\tdata = (char*)gf_malloc(sizeof(char) * size);\n\tif (!data) return GF_OUT_OF_MEM;\n\n\tgf_bs_read_data(bs, data, size);\n\tfor (i=0; i<size-8; i++) {\n\t\tif (GF_4CC((u32)data[i+4], (u8)data[i+5], (u8)data[i+6], (u8)data[i+7]) == GF_ISOM_BOX_TYPE_ESDS) {\n\t\t\tGF_BitStream *mybs = gf_bs_new(data + i, size - i, GF_BITSTREAM_READ);\n\t\t\tgf_bs_set_cookie(mybs, GF_ISOM_BS_COOKIE_NO_LOGS);\n\t\t\tif (ptr->esd) gf_isom_box_del_parent(&ptr->child_boxes, (GF_Box *)ptr->esd);\n\t\t\tptr->esd = NULL;\n\t\t\te = gf_isom_box_parse((GF_Box **)&ptr->esd, mybs);\n\t\t\tgf_bs_del(mybs);\n\n\t\t\tif ((e==GF_OK) && ptr->esd && (ptr->esd->type == GF_ISOM_BOX_TYPE_ESDS)) {\n\t\t\t\tif (!ptr->child_boxes) ptr->child_boxes = gf_list_new();\n\t\t\t\tgf_list_add(ptr->child_boxes, ptr->esd);\n\t\t\t} else if (ptr->esd) {\n\t\t\t\tgf_isom_box_del((GF_Box *)ptr->esd);\n\t\t\t\tptr->esd = NULL;\n\t\t\t}\n\t\t\te = GF_OK;\n\t\t\tbreak;\n\t\t}\n\t}\n\tgf_free(data);\n\treturn e;\n}\n\nGF_Box *audio_sample_entry_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MPEGAudioSampleEntryBox, GF_ISOM_BOX_TYPE_MP4A);\n\tgf_isom_audio_sample_entry_init((GF_AudioSampleEntryBox*)tmp);\n\treturn (GF_Box *)tmp;\n}\n\nGF_Box *enca_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MPEGAudioSampleEntryBox, GF_ISOM_BOX_TYPE_ENCA);\n\tgf_isom_audio_sample_entry_init((GF_AudioSampleEntryBox*)tmp);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err audio_sample_entry_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_isom_audio_sample_entry_write((GF_AudioSampleEntryBox*)s, bs);\n\treturn GF_OK;\n}\n\nGF_Err audio_sample_entry_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_MPEGAudioSampleEntryBox *ptr = (GF_MPEGAudioSampleEntryBox *)s;\n\tgf_isom_audio_sample_entry_size((GF_AudioSampleEntryBox*)s);\n\tif (ptr->qtff_mode)\n\t\treturn GF_OK;\n\n\tgf_isom_check_position(s, (GF_Box *)ptr->esd, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->cfg_mha, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->cfg_3gpp, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->cfg_opus, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->cfg_ac3, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->cfg_flac, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->cfg_mlp, &pos);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid gen_sample_entry_box_del(GF_Box *s)\n{\n\tGF_SampleEntryBox *ptr = (GF_SampleEntryBox *)s;\n\tif (ptr == NULL) return;\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)s);\n\tgf_free(ptr);\n}\n\n\nGF_Err gen_sample_entry_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)s, bs);\n\tif (e) return e;\n\tISOM_DECREASE_SIZE(s, 8);\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *gen_sample_entry_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleEntryBox, GF_QT_SUBTYPE_C608);//type will be overriten\n\tgf_isom_sample_entry_init((GF_SampleEntryBox*)tmp);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err gen_sample_entry_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SampleEntryBox *ptr = (GF_SampleEntryBox *)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_data(bs, ptr->reserved, 6);\n\tgf_bs_write_u16(bs, ptr->dataReferenceIndex);\n\treturn GF_OK;\n}\n\nGF_Err gen_sample_entry_box_size(GF_Box *s)\n{\n\tGF_SampleEntryBox *ptr = (GF_SampleEntryBox *)s;\n\tptr->size += 8;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid mp4s_box_del(GF_Box *s)\n{\n\tGF_MPEGSampleEntryBox *ptr = (GF_MPEGSampleEntryBox *)s;\n\tif (ptr == NULL) return;\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)s);\n\tif (ptr->slc) gf_odf_desc_del((GF_Descriptor *)ptr->slc);\n\tgf_free(ptr);\n}\n\nGF_Err mp4s_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_MPEGSampleEntryBox *ptr = (GF_MPEGSampleEntryBox *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_ESDS:\n\t\tBOX_FIELD_ASSIGN(esd, GF_ESDBox)\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err mp4s_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MPEGSampleEntryBox *ptr = (GF_MPEGSampleEntryBox *)s;\n\n\te = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)ptr, bs);\n\tif (e) return e;\n\n\tISOM_DECREASE_SIZE(ptr, 8);\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *mp4s_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MPEGSampleEntryBox, GF_ISOM_BOX_TYPE_MP4S);\n\tgf_isom_sample_entry_init((GF_SampleEntryBox*)tmp);\n\ttmp->internal_type = GF_ISOM_SAMPLE_ENTRY_MP4S;\n\treturn (GF_Box *)tmp;\n}\n\nGF_Box *encs_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MPEGSampleEntryBox, GF_ISOM_BOX_TYPE_ENCS);\n\tgf_isom_sample_entry_init((GF_SampleEntryBox*)tmp);\n\ttmp->internal_type = GF_ISOM_SAMPLE_ENTRY_MP4S;\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err mp4s_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MPEGSampleEntryBox *ptr = (GF_MPEGSampleEntryBox *)s;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_data(bs, ptr->reserved, 6);\n\tgf_bs_write_u16(bs, ptr->dataReferenceIndex);\n    return GF_OK;\n}\n\nGF_Err mp4s_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_MPEGSampleEntryBox *ptr = (GF_MPEGSampleEntryBox *)s;\n\ts->size += 8;\n\tgf_isom_check_position(s, (GF_Box *)ptr->esd, &pos);\n    return GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid video_sample_entry_box_del(GF_Box *s)\n{\n\tGF_MPEGVisualSampleEntryBox *ptr = (GF_MPEGVisualSampleEntryBox *)s;\n\tif (ptr == NULL) return;\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)s);\n\n\tif (ptr->slc) gf_odf_desc_del((GF_Descriptor *)ptr->slc);\n\t/*for publishing*/\n\tif (ptr->emul_esd) gf_odf_desc_del((GF_Descriptor *)ptr->emul_esd);\n\tgf_free(ptr);\n}\n\nGF_Err video_sample_entry_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_MPEGVisualSampleEntryBox *ptr = (GF_MPEGVisualSampleEntryBox *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_ESDS:\n\t\tBOX_FIELD_ASSIGN(esd, GF_ESDBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_RINF:\n\t\tBOX_FIELD_ASSIGN(rinf, GF_RestrictedSchemeInfoBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_AVCC:\n\t\tBOX_FIELD_ASSIGN(avc_config, GF_AVCConfigurationBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_HVCC:\n\t\tBOX_FIELD_ASSIGN(hevc_config, GF_HEVCConfigurationBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_VVCC:\n\t\tBOX_FIELD_ASSIGN(vvc_config, GF_VVCConfigurationBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_SVCC:\n\t\tBOX_FIELD_ASSIGN(svc_config, GF_AVCConfigurationBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MVCC:\n\t\tBOX_FIELD_ASSIGN(mvc_config, GF_AVCConfigurationBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_LHVC:\n\t\tBOX_FIELD_ASSIGN(lhvc_config, GF_HEVCConfigurationBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_AV1C:\n\t\tBOX_FIELD_ASSIGN(av1_config, GF_AV1ConfigurationBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_VPCC:\n\t\tBOX_FIELD_ASSIGN(vp_config, GF_VPConfigurationBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_DVCC:\n\tcase GF_ISOM_BOX_TYPE_DVVC:\n\t\tBOX_FIELD_ASSIGN(dovi_config, GF_DOVIConfigurationBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_UUID:\n\t\tif (! memcmp(((GF_UnknownUUIDBox*)a)->uuid, GF_ISOM_IPOD_EXT, 16)) {\n\t\t\tBOX_FIELD_ASSIGN(ipod_ext, GF_UnknownUUIDBox)\n\t\t} else {\n\t\t\treturn GF_OK;\n\t\t}\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_D263:\n\t\tBOX_FIELD_ASSIGN(cfg_3gpp, GF_3GPPConfigBox)\n\t\t/*for 3GP config, remember sample entry type in config*/\n\t\tif (ptr->cfg_3gpp)\n\t\t\tptr->cfg_3gpp->cfg.type = ptr->type;\n\t\tbreak;\n\n\tcase GF_ISOM_BOX_TYPE_JP2H:\n\t\tBOX_FIELD_ASSIGN(jp2h, GF_J2KHeaderBox)\n\t\treturn GF_OK;\n\n\tcase GF_ISOM_BOX_TYPE_PASP:\n\tcase GF_ISOM_BOX_TYPE_CLAP:\n\tcase GF_ISOM_BOX_TYPE_COLR:\n\tcase GF_ISOM_BOX_TYPE_MDCV:\n\tcase GF_ISOM_BOX_TYPE_CLLI:\n\tcase GF_ISOM_BOX_TYPE_CCST:\n\tcase GF_ISOM_BOX_TYPE_AUXI:\n\tcase GF_ISOM_BOX_TYPE_RVCC:\n\tcase GF_ISOM_BOX_TYPE_M4DS:\n\t\tif (!is_rem && !gf_isom_box_check_unique(s->child_boxes, a)) {\n\t\t\tERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t}\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err video_sample_entry_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MPEGVisualSampleEntryBox *mp4v = (GF_MPEGVisualSampleEntryBox*)s;\n\tGF_Err e;\n\te = gf_isom_video_sample_entry_read((GF_VisualSampleEntryBox *)s, bs);\n\tif (e) return e;\n\te = gf_isom_box_array_read(s, bs);\n\tif (e) return e;\n\t/*this is an AVC sample desc*/\n\tif (mp4v->avc_config || mp4v->svc_config || mp4v->mvc_config)\n\t\tAVC_RewriteESDescriptor(mp4v);\n\t/*this is an HEVC sample desc*/\n\tif (mp4v->hevc_config || mp4v->lhvc_config || (mp4v->type==GF_ISOM_BOX_TYPE_HVT1))\n\t\tHEVC_RewriteESDescriptor(mp4v);\n\t/*this is an AV1 sample desc*/\n\tif (mp4v->av1_config)\n\t\tAV1_RewriteESDescriptor(mp4v);\n\t/*this is a VP8-9 sample desc*/\n\tif (mp4v->vp_config)\n\t\tVP9_RewriteESDescriptor(mp4v);\n\n\tif (s->type==GF_ISOM_BOX_TYPE_ENCV) {\n\t\tGF_ProtectionSchemeInfoBox *sinf = (GF_ProtectionSchemeInfoBox *) gf_isom_box_find_child(s->child_boxes, GF_ISOM_BOX_TYPE_SINF);\n\n\t\tif (sinf && sinf->original_format) {\n\t\t\tu32 type = sinf->original_format->data_format;\n\t\t\tswitch (type) {\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_H263:\n\t\t\t\tif (mp4v->cfg_3gpp) mp4v->cfg_3gpp->cfg.type = type;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *video_sample_entry_box_new()\n{\n\tGF_MPEGVisualSampleEntryBox *tmp;\n\tGF_SAFEALLOC(tmp, GF_MPEGVisualSampleEntryBox);\n\tif (tmp == NULL) return NULL;\n\n\tgf_isom_video_sample_entry_init((GF_VisualSampleEntryBox *)tmp);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err video_sample_entry_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_isom_video_sample_entry_write((GF_VisualSampleEntryBox *)s, bs);\n\treturn GF_OK;\n}\n\nGF_Err video_sample_entry_box_size(GF_Box *s)\n{\n\tGF_Box *b;\n\tu32 pos=0;\n\tGF_MPEGVisualSampleEntryBox *ptr = (GF_MPEGVisualSampleEntryBox *)s;\n\tgf_isom_video_sample_entry_size((GF_VisualSampleEntryBox *)s);\n\n\t/*make sure we write the config box first, we don't care about the rest*/\n\n\t/*mp4v*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->esd, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->cfg_3gpp, &pos);\n\t/*avc / SVC + MVC*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->avc_config, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->svc_config, &pos);\n\tif (ptr->mvc_config) {\n\t\tgf_isom_check_position(s, gf_isom_box_find_child(s->child_boxes, GF_ISOM_BOX_TYPE_VWID), &pos);\n\t\tgf_isom_check_position(s, (GF_Box *)ptr->mvc_config, &pos);\n\t}\n\n\t/*HEVC*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->hevc_config, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->lhvc_config, &pos);\n\n\t/*VVC*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->vvc_config, &pos);\n\n\t/*AV1*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->av1_config, &pos);\n\n\t/*VPx*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->vp_config, &pos);\n\n\t/*JP2H*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->jp2h, &pos);\n\n\t/*DolbyVision*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->dovi_config, &pos);\n\n\tb = gf_isom_box_find_child(ptr->child_boxes, GF_ISOM_BOX_TYPE_ST3D);\n\tif (b) gf_isom_check_position(s, b, &pos);\n\n\tb = gf_isom_box_find_child(ptr->child_boxes, GF_ISOM_BOX_TYPE_SV3D);\n\tif (b) gf_isom_check_position(s, b, &pos);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\nvoid mvex_box_del(GF_Box *s)\n{\n\tGF_MovieExtendsBox *ptr = (GF_MovieExtendsBox *)s;\n\tif (ptr == NULL) return;\n\tgf_list_del(ptr->TrackExList);\n\tgf_list_del(ptr->TrackExPropList);\n\tgf_free(ptr);\n}\n\n\nGF_Err mvex_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_MovieExtendsBox *ptr = (GF_MovieExtendsBox *)s;\n\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_TREX:\n\t\tBOX_FIELD_LIST_ASSIGN(TrackExList)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_TREP:\n\t\tBOX_FIELD_LIST_ASSIGN(TrackExPropList)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_MEHD:\n\t\tBOX_FIELD_ASSIGN(mehd, GF_MovieExtendsHeaderBox)\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\n\n\nGF_Err mvex_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *mvex_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MovieExtendsBox, GF_ISOM_BOX_TYPE_MVEX);\n\ttmp->TrackExList = gf_list_new();\n\tif (!tmp->TrackExList) {\n\t\tgf_free(tmp);\n\t\treturn NULL;\n\t}\n\ttmp->TrackExPropList = gf_list_new();\n\tif (!tmp->TrackExPropList) {\n\t\tgf_list_del(tmp->TrackExList);\n\t\tgf_free(tmp);\n\t\treturn NULL;\n\t}\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err mvex_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err mvex_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_MovieExtendsBox *ptr = (GF_MovieExtendsBox *) s;\n\tgf_isom_check_position(s, (GF_Box *)ptr->mehd, &pos);\n\tgf_isom_check_position_list(s, ptr->TrackExList, &pos);\n\tgf_isom_check_position_list(s, ptr->TrackExPropList, &pos);\n\treturn GF_OK;\n}\n\n\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *mehd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MovieExtendsHeaderBox, GF_ISOM_BOX_TYPE_MEHD);\n\treturn (GF_Box *)tmp;\n}\nvoid mehd_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\nGF_Err mehd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MovieExtendsHeaderBox *ptr = (GF_MovieExtendsHeaderBox *)s;\n\n\tif (ptr->version==1) {\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\tptr->fragment_duration = gf_bs_read_u64(bs);\n\t} else {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->fragment_duration = (u64) gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err mehd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MovieExtendsHeaderBox *ptr = (GF_MovieExtendsHeaderBox *)s;\n\tGF_Err e = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tif (ptr->version == 1) {\n\t\tgf_bs_write_u64(bs, ptr->fragment_duration);\n\t} else {\n\t\tgf_bs_write_u32(bs, (u32) ptr->fragment_duration);\n\t}\n\treturn GF_OK;\n}\nGF_Err mehd_box_size(GF_Box *s)\n{\n\tGF_MovieExtendsHeaderBox *ptr = (GF_MovieExtendsHeaderBox *)s;\n\tptr->version = (ptr->fragment_duration>0xFFFFFFFF) ? 1 : 0;\n\ts->size += (ptr->version == 1) ? 8 : 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM_FRAGMENTS*/\n\n\nvoid mvhd_box_del(GF_Box *s)\n{\n\tGF_MovieHeaderBox *ptr = (GF_MovieHeaderBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err mvhd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MovieHeaderBox *ptr = (GF_MovieHeaderBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\tif (ptr->version == 1) {\n\t\tISOM_DECREASE_SIZE(ptr, 28);\n\t\tptr->creationTime = gf_bs_read_u64(bs);\n\t\tptr->modificationTime = gf_bs_read_u64(bs);\n\t\tptr->timeScale = gf_bs_read_u32(bs);\n\t\tptr->duration = gf_bs_read_u64(bs);\n\t} else {\n\t\tISOM_DECREASE_SIZE(ptr, 16);\n\t\tptr->creationTime = gf_bs_read_u32(bs);\n\t\tptr->modificationTime = gf_bs_read_u32(bs);\n\t\tptr->timeScale = gf_bs_read_u32(bs);\n\t\tptr->duration = gf_bs_read_u32(bs);\n\t}\n\tif (!ptr->timeScale) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Movie header timescale is invalid (0) - defaulting to 600\\n\" ));\n\t\tptr->timeScale = 600;\n\t}\n\tISOM_DECREASE_SIZE(ptr, 80);\n\tptr->preferredRate = gf_bs_read_u32(bs);\n\tptr->preferredVolume = gf_bs_read_u16(bs);\n\tgf_bs_read_data(bs, ptr->reserved, 10);\n\tptr->matrixA = gf_bs_read_u32(bs);\n\tptr->matrixB = gf_bs_read_u32(bs);\n\tptr->matrixU = gf_bs_read_u32(bs);\n\tptr->matrixC = gf_bs_read_u32(bs);\n\tptr->matrixD = gf_bs_read_u32(bs);\n\tptr->matrixV = gf_bs_read_u32(bs);\n\tptr->matrixX = gf_bs_read_u32(bs);\n\tptr->matrixY = gf_bs_read_u32(bs);\n\tptr->matrixW = gf_bs_read_u32(bs);\n\tptr->previewTime = gf_bs_read_u32(bs);\n\tptr->previewDuration = gf_bs_read_u32(bs);\n\tptr->posterTime = gf_bs_read_u32(bs);\n\tptr->selectionTime = gf_bs_read_u32(bs);\n\tptr->selectionDuration = gf_bs_read_u32(bs);\n\tptr->currentTime = gf_bs_read_u32(bs);\n\tptr->nextTrackID = gf_bs_read_u32(bs);\n\tptr->original_duration = ptr->duration;\n\treturn GF_OK;\n}\n\nGF_Box *mvhd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MovieHeaderBox, GF_ISOM_BOX_TYPE_MVHD);\n\n\ttmp->preferredRate = (1<<16);\n\ttmp->preferredVolume = (1<<8);\n\n\ttmp->matrixA = (1<<16);\n\ttmp->matrixD = (1<<16);\n\ttmp->matrixW = (1<<30);\n\n\ttmp->nextTrackID = 1;\n\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err mvhd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MovieHeaderBox *ptr = (GF_MovieHeaderBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tif (ptr->version == 1) {\n\t\tgf_bs_write_u64(bs, ptr->creationTime);\n\t\tgf_bs_write_u64(bs, ptr->modificationTime);\n\t\tgf_bs_write_u32(bs, ptr->timeScale);\n\t\tgf_bs_write_u64(bs, ptr->duration);\n\t} else {\n\t\tgf_bs_write_u32(bs, (u32) ptr->creationTime);\n\t\tgf_bs_write_u32(bs, (u32) ptr->modificationTime);\n\t\tgf_bs_write_u32(bs, ptr->timeScale);\n\t\tgf_bs_write_u32(bs, (u32) ptr->duration);\n\t}\n\tgf_bs_write_u32(bs, ptr->preferredRate);\n\tgf_bs_write_u16(bs, ptr->preferredVolume);\n\tgf_bs_write_data(bs, ptr->reserved, 10);\n\tgf_bs_write_u32(bs, ptr->matrixA);\n\tgf_bs_write_u32(bs, ptr->matrixB);\n\tgf_bs_write_u32(bs, ptr->matrixU);\n\tgf_bs_write_u32(bs, ptr->matrixC);\n\tgf_bs_write_u32(bs, ptr->matrixD);\n\tgf_bs_write_u32(bs, ptr->matrixV);\n\tgf_bs_write_u32(bs, ptr->matrixX);\n\tgf_bs_write_u32(bs, ptr->matrixY);\n\tgf_bs_write_u32(bs, ptr->matrixW);\n\tgf_bs_write_u32(bs, ptr->previewTime);\n\tgf_bs_write_u32(bs, ptr->previewDuration);\n\tgf_bs_write_u32(bs, ptr->posterTime);\n\tgf_bs_write_u32(bs, ptr->selectionTime);\n\tgf_bs_write_u32(bs, ptr->selectionDuration);\n\tgf_bs_write_u32(bs, ptr->currentTime);\n\tgf_bs_write_u32(bs, ptr->nextTrackID);\n\treturn GF_OK;\n}\n\nGF_Err mvhd_box_size(GF_Box *s)\n{\n\tGF_MovieHeaderBox *ptr = (GF_MovieHeaderBox *)s;\n\tif (ptr->duration==(u64) -1) ptr->version = 0;\n\telse ptr->version = (ptr->duration>0xFFFFFFFF) ? 1 : 0;\n\n\tptr->size += (ptr->version == 1) ? 28 : 16;\n\tptr->size += 80;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid nmhd_box_del(GF_Box *s)\n{\n\tGF_MPEGMediaHeaderBox *ptr = (GF_MPEGMediaHeaderBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\n\nGF_Err nmhd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn GF_OK;\n}\n\nGF_Box *nmhd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MPEGMediaHeaderBox, GF_ISOM_BOX_TYPE_NMHD);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err nmhd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_full_box_write(s, bs);\n}\n\nGF_Err nmhd_box_size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid padb_box_del(GF_Box *s)\n{\n\tGF_PaddingBitsBox *ptr = (GF_PaddingBitsBox *) s;\n\tif (ptr == NULL) return;\n\tif (ptr->padbits) gf_free(ptr->padbits);\n\tgf_free(ptr);\n}\n\n\nGF_Err padb_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_PaddingBitsBox *ptr = (GF_PaddingBitsBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->SampleCount = gf_bs_read_u32(bs);\n\tif (ptr->size < ptr->SampleCount/2) //half byte per sample\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tptr->padbits = (u8 *)gf_malloc(sizeof(u8)*ptr->SampleCount);\n\tif (!ptr->padbits) return GF_OUT_OF_MEM;\n\n\tfor (i=0; i<ptr->SampleCount; i += 2) {\n\t\tgf_bs_read_int(bs, 1);\n\t\tif (i+1 < ptr->SampleCount) {\n\t\t\tptr->padbits[i+1] = gf_bs_read_int(bs, 3);\n\t\t} else {\n\t\t\tgf_bs_read_int(bs, 3);\n\t\t}\n\t\tgf_bs_read_int(bs, 1);\n\t\tptr->padbits[i] = gf_bs_read_int(bs, 3);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *padb_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_PaddingBitsBox, GF_ISOM_BOX_TYPE_PADB);\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err padb_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_Err e;\n\tGF_PaddingBitsBox *ptr = (GF_PaddingBitsBox *) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_int(bs, ptr->SampleCount, 32);\n\n\tfor (i=0 ; i<ptr->SampleCount; i += 2) {\n\t\tgf_bs_write_int(bs, 0, 1);\n\t\tif (i+1 < ptr->SampleCount) {\n\t\t\tgf_bs_write_int(bs, ptr->padbits[i+1], 3);\n\t\t} else {\n\t\t\tgf_bs_write_int(bs, 0, 3);\n\t\t}\n\t\tgf_bs_write_int(bs, 0, 1);\n\t\tgf_bs_write_int(bs, ptr->padbits[i], 3);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err padb_box_size(GF_Box *s)\n{\n\tGF_PaddingBitsBox *ptr = (GF_PaddingBitsBox *)s;\n\tptr->size += 4;\n\tif (ptr->SampleCount) ptr->size += (ptr->SampleCount + 1) / 2;\n\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid rely_box_del(GF_Box *s)\n{\n\tGF_RelyHintBox *rely = (GF_RelyHintBox *)s;\n\tgf_free(rely);\n}\n\nGF_Err rely_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_RelyHintBox *ptr = (GF_RelyHintBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 1);\n\tptr->reserved = gf_bs_read_int(bs, 6);\n\tptr->preferred = gf_bs_read_int(bs, 1);\n\tptr->required = gf_bs_read_int(bs, 1);\n\treturn GF_OK;\n}\n\nGF_Box *rely_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_RelyHintBox, GF_ISOM_BOX_TYPE_RELY);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err rely_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_RelyHintBox *ptr = (GF_RelyHintBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_int(bs, ptr->reserved, 6);\n\tgf_bs_write_int(bs, ptr->preferred, 1);\n\tgf_bs_write_int(bs, ptr->required, 1);\n\treturn GF_OK;\n}\n\nGF_Err rely_box_size(GF_Box *s)\n{\n\ts->size += 1;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid rtpo_box_del(GF_Box *s)\n{\n\tGF_RTPOBox *rtpo = (GF_RTPOBox *)s;\n\tgf_free(rtpo);\n}\n\nGF_Err rtpo_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_RTPOBox *ptr = (GF_RTPOBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->timeOffset = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\nGF_Box *rtpo_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_RTPOBox, GF_ISOM_BOX_TYPE_RTPO);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err rtpo_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_RTPOBox *ptr = (GF_RTPOBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\n\t//here we have no pb, just remembed that some entries will have to\n\t//be 4-bytes aligned ...\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->timeOffset);\n\treturn GF_OK;\n}\n\nGF_Err rtpo_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid smhd_box_del(GF_Box *s)\n{\n\tGF_SoundMediaHeaderBox *ptr = (GF_SoundMediaHeaderBox *)s;\n\tif (ptr == NULL ) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err smhd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_SoundMediaHeaderBox *ptr = (GF_SoundMediaHeaderBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->balance = gf_bs_read_u16(bs);\n\tptr->reserved = gf_bs_read_u16(bs);\n\treturn GF_OK;\n}\n\nGF_Box *smhd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SoundMediaHeaderBox, GF_ISOM_BOX_TYPE_SMHD);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err smhd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SoundMediaHeaderBox *ptr = (GF_SoundMediaHeaderBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u16(bs, ptr->balance);\n\tgf_bs_write_u16(bs, ptr->reserved);\n\treturn GF_OK;\n}\n\nGF_Err smhd_box_size(GF_Box *s)\n{\n\tGF_SoundMediaHeaderBox *ptr = (GF_SoundMediaHeaderBox *)s;\n\n\tptr->reserved = 0;\n\tptr->size += 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid snro_box_del(GF_Box *s)\n{\n\tGF_SeqOffHintEntryBox *snro = (GF_SeqOffHintEntryBox *)s;\n\tgf_free(snro);\n}\n\nGF_Err snro_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_SeqOffHintEntryBox *ptr = (GF_SeqOffHintEntryBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->SeqOffset = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\nGF_Box *snro_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SeqOffHintEntryBox, GF_ISOM_BOX_TYPE_SNRO);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err snro_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SeqOffHintEntryBox *ptr = (GF_SeqOffHintEntryBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->SeqOffset);\n\treturn GF_OK;\n}\n\nGF_Err snro_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid stbl_box_del(GF_Box *s)\n{\n\tGF_SampleTableBox *ptr = (GF_SampleTableBox *)s;\n\tif (ptr == NULL) return;\n\n\tif (ptr->sub_samples) gf_list_del(ptr->sub_samples);\n\tif (ptr->sampleGroups) gf_list_del(ptr->sampleGroups);\n\tif (ptr->sampleGroupsDescription) gf_list_del(ptr->sampleGroupsDescription);\n\tif (ptr->sai_sizes) gf_list_del(ptr->sai_sizes);\n\tif (ptr->sai_offsets) gf_list_del(ptr->sai_offsets);\n\tif (ptr->traf_map) {\n\t\tif (ptr->traf_map->frag_starts) {\n\t\t\tu32 i;\n\t\t\tfor (i=0; i<ptr->traf_map->nb_entries; i++) {\n\t\t\t\tif (ptr->traf_map->frag_starts[i].moof_template)\n\t\t\t\t\tgf_free(ptr->traf_map->frag_starts[i].moof_template);\n\t\t\t}\n\t\t\tgf_free(ptr->traf_map->frag_starts);\n\t\t}\n\t\tgf_free(ptr->traf_map);\n\t}\n\tgf_free(ptr);\n}\n\nGF_Err stbl_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_SampleTableBox *ptr = (GF_SampleTableBox *)s;\n\tif (!a) return GF_OK;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_STTS:\n\t\tBOX_FIELD_ASSIGN(TimeToSample, GF_TimeToSampleBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_CTTS:\n\t\tBOX_FIELD_ASSIGN(CompositionOffset, GF_CompositionOffsetBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_CSLG:\n\t\tBOX_FIELD_ASSIGN(CompositionToDecode, GF_CompositionToDecodeBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_STSS:\n\t\tBOX_FIELD_ASSIGN(SyncSample, GF_SyncSampleBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_STSD:\n\t\tBOX_FIELD_ASSIGN(SampleDescription, GF_SampleDescriptionBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_STZ2:\n\tcase GF_ISOM_BOX_TYPE_STSZ:\n\t\tBOX_FIELD_ASSIGN(SampleSize, GF_SampleSizeBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_STSC:\n\t\tBOX_FIELD_ASSIGN(SampleToChunk, GF_SampleToChunkBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_PADB:\n\t\tBOX_FIELD_ASSIGN(PaddingBits, GF_PaddingBitsBox)\n\t\tbreak;\n\n\t//WARNING: AS THIS MAY CHANGE DYNAMICALLY DURING EDIT,\n\tcase GF_ISOM_BOX_TYPE_CO64:\n\tcase GF_ISOM_BOX_TYPE_STCO:\n\t\tBOX_FIELD_ASSIGN(ChunkOffset, GF_Box)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_STSH:\n\t\tBOX_FIELD_ASSIGN(ShadowSync, GF_ShadowSyncBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_STDP:\n\t\tBOX_FIELD_ASSIGN(DegradationPriority, GF_DegradationPriorityBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_SDTP:\n\t\tBOX_FIELD_ASSIGN(SampleDep, GF_SampleDependencyTypeBox)\n\t\tbreak;\n\n\tcase GF_ISOM_BOX_TYPE_SUBS:\n\t\tBOX_FIELD_LIST_ASSIGN(sub_samples)\n\t\t//check subsample box\n\t\tif (!is_rem) {\n\t\t\tGF_SubSampleInformationBox *subs = (GF_SubSampleInformationBox *)a;\n\t\t\tGF_SubSampleInfoEntry *ent = gf_list_get(subs->Samples, 0);\n\t\t\tif (!ent) {\n\t\t\t\tgf_list_rem(subs->Samples, 0);\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] first entry in SubSample in track SampleTable is invalid\\n\"));\n\t\t\t}\n\t\t\telse if (ent->sample_delta==0) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] first entry in SubSample in track SampleTable has sample_delta of 0, should be one. Fixing\\n\"));\n\t\t\t\tent->sample_delta = 1;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase GF_ISOM_BOX_TYPE_SBGP:\n\tcase GF_ISOM_BOX_TYPE_CSGP:\n\t\tBOX_FIELD_LIST_ASSIGN(sampleGroups)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_SGPD:\n\t\tBOX_FIELD_LIST_ASSIGN(sampleGroupsDescription)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_SAIZ:\n\t\tBOX_FIELD_LIST_ASSIGN(sai_sizes)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_SAIO:\n\t\tBOX_FIELD_LIST_ASSIGN(sai_offsets)\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\n\n\n\nGF_Err stbl_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\t//we need to parse DegPrior in a special way\n\tGF_SampleTableBox *ptr = (GF_SampleTableBox *)s;\n\n\te = gf_isom_box_array_read(s, bs);\n\tif (e) return e;\n\n\tif (!ptr->SyncSample)\n\t\tptr->no_sync_found = 1;\n\n\tptr->nb_sgpd_in_stbl = gf_list_count(ptr->sampleGroupsDescription);\n\tptr->nb_stbl_boxes = gf_list_count(ptr->child_boxes);\n\n\tif (gf_bs_get_cookie(bs) & GF_ISOM_BS_COOKIE_CLONE_TRACK)\n\t\treturn GF_OK;\n//\treturn GF_OK;\n\n#define CHECK_BOX(_name) \\\n\tif (!ptr->_name) {\\\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Mandatory box %s is missing\\n\", #_name)); \\\n\t\treturn GF_ISOM_INVALID_FILE; \\\n\t}\n\n\tCHECK_BOX(SampleToChunk)\n\tCHECK_BOX(SampleSize)\n\tCHECK_BOX(ChunkOffset)\n\tCHECK_BOX(TimeToSample)\n\n\t//sanity check\n\tif (ptr->SampleSize->sampleCount) {\n\t\tif (!ptr->TimeToSample->nb_entries || !ptr->SampleToChunk->nb_entries)\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tu32 i, max_chunks=0;\n\tif (ptr->ChunkOffset->type == GF_ISOM_BOX_TYPE_STCO) {\n\t\tmax_chunks = ((GF_ChunkOffsetBox *)ptr->ChunkOffset)->nb_entries;\n\t}\n\telse if (ptr->ChunkOffset->type == GF_ISOM_BOX_TYPE_CO64) {\n\t\tmax_chunks = ((GF_ChunkOffsetBox *)ptr->ChunkOffset)->nb_entries;\n\t}\n\n\t//sanity check on stsc vs chunk offset tables\n\tfor (i=0; i<ptr->SampleToChunk->nb_entries; i++) {\n\t\tGF_StscEntry *ent = &ptr->SampleToChunk->entries[i];\n\t\tif (!i && (ent->firstChunk!=1)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] first_chunk of first entry shall be 1 but is %u\\n\", ent->firstChunk));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t\tif (ptr->SampleToChunk->entries[i].firstChunk > max_chunks) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] first_chunk is %u but number of chunks defined %u\\n\", ptr->SampleToChunk->entries[i].firstChunk, max_chunks));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t\tif (i+1 == ptr->SampleToChunk->nb_entries) break;\n\t\tGF_StscEntry *next_ent = &ptr->SampleToChunk->entries[i+1];\n\t\tif (next_ent->firstChunk < ent->firstChunk) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] first_chunk (%u) for entry %u is greater than first_chunk (%u) for entry %u\\n\", i+1, ent->firstChunk, i+2, next_ent->firstChunk));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *stbl_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleTableBox, GF_ISOM_BOX_TYPE_STBL);\n\t//maxSamplePer chunk is 10 by default\n\ttmp->MaxSamplePerChunk = 10;\n\ttmp->groupID = 1;\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stbl_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err stbl_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_SampleTableBox *ptr = (GF_SampleTableBox *)s;\n\n\tgf_isom_check_position(s, (GF_Box *)ptr->SampleDescription, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->TimeToSample, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->CompositionOffset, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->CompositionToDecode, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->SyncSample, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->ShadowSync, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->SampleToChunk, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->SampleSize, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->ChunkOffset, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->DegradationPriority, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->SampleDep, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->PaddingBits, &pos);\n\n\tif (ptr->sub_samples) {\n\t\tgf_isom_check_position_list(s, ptr->sub_samples, &pos);\n\t}\n\tif (ptr->sampleGroupsDescription) {\n\t\tgf_isom_check_position_list(s, ptr->sampleGroupsDescription, &pos);\n\t}\n\tif (ptr->sampleGroups) {\n\t\tgf_isom_check_position_list(s, ptr->sampleGroups, &pos);\n\t}\n\tif (ptr->sai_sizes) {\n\t\tgf_isom_check_position_list(s, ptr->sai_sizes, &pos);\n\t}\n\tif (ptr->sai_offsets) {\n\t\tgf_isom_check_position_list(s, ptr->sai_offsets, &pos);\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid stco_box_del(GF_Box *s)\n{\n\tGF_ChunkOffsetBox *ptr = (GF_ChunkOffsetBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->offsets) gf_free(ptr->offsets);\n\tgf_free(ptr);\n}\n\n\nGF_Err stco_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 entries;\n\tGF_ChunkOffsetBox *ptr = (GF_ChunkOffsetBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->nb_entries = gf_bs_read_u32(bs);\n\tif (ptr->nb_entries > ptr->size / 4 || (u64)ptr->nb_entries > (u64)SIZE_MAX/sizeof(u32)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in stco\\n\", ptr->nb_entries));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tif (ptr->nb_entries) {\n\t\tptr->offsets = (u32 *) gf_malloc(ptr->nb_entries * sizeof(u32) );\n\t\tif (ptr->offsets == NULL) return GF_OUT_OF_MEM;\n\t\tptr->alloc_size = ptr->nb_entries;\n\n\t\tfor (entries = 0; entries < ptr->nb_entries; entries++) {\n\t\t\tptr->offsets[entries] = gf_bs_read_u32(bs);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *stco_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ChunkOffsetBox, GF_ISOM_BOX_TYPE_STCO);\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stco_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_ChunkOffsetBox *ptr = (GF_ChunkOffsetBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->nb_entries);\n\tfor (i = 0; i < ptr->nb_entries; i++) {\n\t\tgf_bs_write_u32(bs, ptr->offsets[i]);\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err stco_box_size(GF_Box *s)\n{\n\tGF_ChunkOffsetBox *ptr = (GF_ChunkOffsetBox *)s;\n\n\tptr->size += 4 + (4 * ptr->nb_entries);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid stdp_box_del(GF_Box *s)\n{\n\tGF_DegradationPriorityBox *ptr = (GF_DegradationPriorityBox *)s;\n\tif (ptr == NULL ) return;\n\tif (ptr->priorities) gf_free(ptr->priorities);\n\tgf_free(ptr);\n}\n\n//this is called through stbl_read...\nGF_Err stdp_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 entry;\n\tGF_DegradationPriorityBox *ptr = (GF_DegradationPriorityBox *)s;\n\n\t/*out-of-order stdp, assume no padding at the end and take the entire remaining data for entries*/\n\tif (!ptr->nb_entries) ptr->nb_entries = (u32) ptr->size / 2;\n\telse if (ptr->nb_entries > ptr->size / 2) return GF_ISOM_INVALID_FILE;\n\n\tptr->priorities = (u16 *) gf_malloc(ptr->nb_entries * sizeof(u16));\n\tif (ptr->priorities == NULL) return GF_OUT_OF_MEM;\n\tfor (entry = 0; entry < ptr->nb_entries; entry++) {\n\t\tptr->priorities[entry] = gf_bs_read_u16(bs);\n\t}\n\tISOM_DECREASE_SIZE(ptr, (2*ptr->nb_entries) );\n\treturn GF_OK;\n}\n\nGF_Box *stdp_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DegradationPriorityBox, GF_ISOM_BOX_TYPE_STDP);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stdp_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_DegradationPriorityBox *ptr = (GF_DegradationPriorityBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tfor (i = 0; i < ptr->nb_entries; i++) {\n\t\tgf_bs_write_u16(bs, ptr->priorities[i]);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err stdp_box_size(GF_Box *s)\n{\n\tGF_DegradationPriorityBox *ptr = (GF_DegradationPriorityBox *)s;\n\n\tptr->size += (2 * ptr->nb_entries);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid stsc_box_del(GF_Box *s)\n{\n\tGF_SampleToChunkBox *ptr = (GF_SampleToChunkBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);\n}\n\n\nGF_Err stsc_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_SampleToChunkBox *ptr = (GF_SampleToChunkBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->nb_entries = gf_bs_read_u32(bs);\n\n\tif (ptr->nb_entries > ptr->size / 12 || (u64)ptr->nb_entries > (u64)SIZE_MAX/sizeof(GF_StscEntry)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in stsc\\n\", ptr->nb_entries));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tptr->alloc_size = ptr->nb_entries;\n\tptr->entries = NULL;\n\tif (ptr->nb_entries) {\n\t\tptr->entries = gf_malloc(sizeof(GF_StscEntry)*ptr->alloc_size);\n\t\tif (!ptr->entries) return GF_OUT_OF_MEM;\n\t}\n\n\tfor (i = 0; i < ptr->nb_entries; i++) {\n\t\tptr->entries[i].firstChunk = gf_bs_read_u32(bs);\n\t\tptr->entries[i].samplesPerChunk = gf_bs_read_u32(bs);\n\t\tptr->entries[i].sampleDescriptionIndex = gf_bs_read_u32(bs);\n\t\tptr->entries[i].isEdited = 0;\n\t\tptr->entries[i].nextChunk = 0;\n\t\tif (!ptr->entries[i].firstChunk) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] invalid first chunk 0 in stsc entry\\n\", ptr->nb_entries));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\n\t\t//update the next chunk in the previous entry\n\t\tif (i) ptr->entries[i-1].nextChunk = ptr->entries[i].firstChunk;\n\t}\n\tptr->currentIndex = 0;\n\tptr->firstSampleInCurrentChunk = 0;\n\tptr->currentChunk = 0;\n\tptr->ghostNumber = 0;\n\treturn GF_OK;\n}\n\nGF_Box *stsc_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleToChunkBox, GF_ISOM_BOX_TYPE_STSC);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stsc_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_SampleToChunkBox *ptr = (GF_SampleToChunkBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->nb_entries);\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tgf_bs_write_u32(bs, ptr->entries[i].firstChunk);\n\t\tgf_bs_write_u32(bs, ptr->entries[i].samplesPerChunk);\n\t\tgf_bs_write_u32(bs, ptr->entries[i].sampleDescriptionIndex);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err stsc_box_size(GF_Box *s)\n{\n\tGF_SampleToChunkBox *ptr = (GF_SampleToChunkBox *)s;\n\n\tptr->size += 4 + (12 * ptr->nb_entries);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid stsd_box_del(GF_Box *s)\n{\n\tGF_SampleDescriptionBox *ptr = (GF_SampleDescriptionBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\nGF_Err stsd_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_UnknownBox *def;\n\tif (!a) return GF_OK;\n\n\tif (is_rem || gf_box_valid_in_parent(a, \"stsd\")) {\n\t\treturn GF_OK;\n\t}\n\tswitch (a->type) {\n\t//unknown sample description: we need a specific box to handle the data ref index\n\t//rather than a default box ...\n\tcase GF_ISOM_BOX_TYPE_UNKNOWN:\n\t\tdef = (GF_UnknownBox *)a;\n\t\t/*we need at least 8 bytes for unknown sample entries*/\n\t\tif (def->dataSize < 8) {\n\t\t\tgf_isom_box_del_parent(&s->child_boxes, a);\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\t}\n\t\treturn GF_OK;\n\n\tdefault:\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Cannot process box of type %s\\n\", gf_4cc_to_str(a->type)));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n}\n\n\nGF_Err stsd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tISOM_DECREASE_SIZE(s, 4)\n\tgf_bs_read_u32(bs);\n\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *stsd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleDescriptionBox, GF_ISOM_BOX_TYPE_STSD);\n\ttmp->child_boxes = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stsd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 nb_entries;\n\tGF_SampleDescriptionBox *ptr = (GF_SampleDescriptionBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tnb_entries = gf_list_count(ptr->child_boxes);\n\tgf_bs_write_u32(bs, nb_entries);\n\treturn GF_OK;\n}\n\nGF_Err stsd_box_size(GF_Box *s)\n{\n\tGF_SampleDescriptionBox *ptr = (GF_SampleDescriptionBox *)s;\n\tptr->size += 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid stsh_box_del(GF_Box *s)\n{\n\tu32 i = 0;\n\tGF_StshEntry *ent;\n\tGF_ShadowSyncBox *ptr = (GF_ShadowSyncBox *)s;\n\tif (ptr == NULL) return;\n\twhile ( (ent = (GF_StshEntry *)gf_list_enum(ptr->entries, &i)) ) {\n\t\tgf_free(ent);\n\t}\n\tgf_list_del(ptr->entries);\n\tgf_free(ptr);\n}\n\n\n\nGF_Err stsh_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 count, i;\n\tGF_ShadowSyncBox *ptr = (GF_ShadowSyncBox *)s;\n\n\tISOM_DECREASE_SIZE(s, 4)\n\tcount = gf_bs_read_u32(bs);\n\tif (ptr->size / 8 < count)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tfor (i = 0; i < count; i++) {\n\t\tGF_StshEntry *ent = (GF_StshEntry *) gf_malloc(sizeof(GF_StshEntry));\n\t\tif (!ent) return GF_OUT_OF_MEM;\n\t\tent->shadowedSampleNumber = gf_bs_read_u32(bs);\n\t\tent->syncSampleNumber = gf_bs_read_u32(bs);\n\t\te = gf_list_add(ptr->entries, ent);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *stsh_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ShadowSyncBox, GF_ISOM_BOX_TYPE_STSH);\n\n\ttmp->entries = gf_list_new();\n\tif (!tmp->entries) {\n\t\tgf_free(tmp);\n\t\treturn NULL;\n\t}\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stsh_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_StshEntry *ent;\n\tGF_ShadowSyncBox *ptr = (GF_ShadowSyncBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, gf_list_count(ptr->entries));\n\ti=0;\n\twhile ((ent = (GF_StshEntry *)gf_list_enum(ptr->entries, &i))) {\n\t\tgf_bs_write_u32(bs, ent->shadowedSampleNumber);\n\t\tgf_bs_write_u32(bs, ent->syncSampleNumber);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err stsh_box_size(GF_Box *s)\n{\n\tGF_ShadowSyncBox *ptr = (GF_ShadowSyncBox *)s;\n\tptr->size += 4 + (8 * gf_list_count(ptr->entries));\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid stss_box_del(GF_Box *s)\n{\n\tGF_SyncSampleBox *ptr = (GF_SyncSampleBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->sampleNumbers) gf_free(ptr->sampleNumbers);\n\tgf_free(ptr);\n}\n\nGF_Err stss_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_SyncSampleBox *ptr = (GF_SyncSampleBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->nb_entries = gf_bs_read_u32(bs);\n\tif (ptr->size / 4 <  ptr->nb_entries || (u64)ptr->nb_entries > (u64)SIZE_MAX/sizeof(u32)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in stss\\n\", ptr->nb_entries));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tptr->alloc_size = ptr->nb_entries;\n\tptr->sampleNumbers = (u32 *) gf_malloc( ptr->alloc_size * sizeof(u32));\n\tif (ptr->sampleNumbers == NULL) return GF_OUT_OF_MEM;\n\n\tfor (i = 0; i < ptr->nb_entries; i++) {\n\t\tptr->sampleNumbers[i] = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *stss_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SyncSampleBox, GF_ISOM_BOX_TYPE_STSS);\n\treturn (GF_Box*)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stss_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_SyncSampleBox *ptr = (GF_SyncSampleBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->nb_entries);\n\tfor (i = 0; i < ptr->nb_entries; i++) {\n\t\tgf_bs_write_u32(bs, ptr->sampleNumbers[i]);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err stss_box_size(GF_Box *s)\n{\n\tGF_SyncSampleBox *ptr = (GF_SyncSampleBox *)s;\n\tptr->size += 4 + (4 * ptr->nb_entries);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid stsz_box_del(GF_Box *s)\n{\n\tGF_SampleSizeBox *ptr = (GF_SampleSizeBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->sizes) gf_free(ptr->sizes);\n\tgf_free(ptr);\n}\n\n\nGF_Err stsz_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i, estSize;\n\tGF_SampleSizeBox *ptr = (GF_SampleSizeBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\n\t//support for CompactSizes\n\tif (s->type == GF_ISOM_BOX_TYPE_STSZ) {\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\tptr->sampleSize = gf_bs_read_u32(bs);\n\t\tptr->sampleCount = gf_bs_read_u32(bs);\n\t} else {\n\t\t//24-reserved\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\tgf_bs_read_int(bs, 24);\n\t\ti = gf_bs_read_u8(bs);\n\t\tptr->sampleCount = gf_bs_read_u32(bs);\n\t\tswitch (i) {\n\t\tcase 4:\n\t\tcase 8:\n\t\tcase 16:\n\t\t\tptr->sampleSize = i;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t//try to fix the file\n\t\t\t//no samples, no parsing pb\n\t\t\tif (!ptr->sampleCount) {\n\t\t\t\tptr->sampleSize = 16;\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\testSize = (u32) (ptr->size) / ptr->sampleCount;\n\t\t\tif (!estSize && ((ptr->sampleCount+1)/2 == (ptr->size)) ) {\n\t\t\t\tptr->sampleSize = 4;\n\t\t\t\tbreak;\n\t\t\t} else if (estSize == 1 || estSize == 2) {\n\t\t\t\tptr->sampleSize = 8 * estSize;\n\t\t\t} else {\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t}\n\t}\n\tif (ptr->sampleCount && (u64)ptr->sampleCount > (u64)SIZE_MAX/sizeof(u32)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in stsz\\n\", ptr->sampleCount));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tif (s->type == GF_ISOM_BOX_TYPE_STSZ) {\n\t\tif (! ptr->sampleSize && ptr->sampleCount) {\n\t\t\tif (ptr->sampleCount > ptr->size / 4) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in stsz\\n\", ptr->sampleCount));\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t\tptr->sizes = (u32 *) gf_malloc(ptr->sampleCount * sizeof(u32));\n\t\t\tif (! ptr->sizes) return GF_OUT_OF_MEM;\n\t\t\tptr->alloc_size = ptr->sampleCount;\n\t\t\tfor (i = 0; i < ptr->sampleCount; i++) {\n\t\t\t\tptr->sizes[i] = gf_bs_read_u32(bs);\n\t\t\t\tif (ptr->max_size < ptr->sizes[i])\n\t\t\t\t\tptr->max_size = ptr->sizes[i];\n\t\t\t\tptr->total_size += ptr->sizes[i];\n\t\t\t\tptr->total_samples++;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (ptr->sampleSize==4) {\n\t\t\tif (ptr->sampleCount / 2 > ptr->size) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in stsz\\n\", ptr->sampleCount));\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t} else {\n\t\t\tif (ptr->sampleCount > ptr->size / (ptr->sampleSize/8)) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in stsz\\n\", ptr->sampleCount));\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t}\n\t\t//note we could optimize the mem usage by keeping the table compact\n\t\t//in memory. But that would complicate both caching and editing\n\t\t//we therefore keep all sizes as u32 and uncompress the table\n\t\tptr->sizes = (u32 *) gf_malloc(ptr->sampleCount * sizeof(u32));\n\t\tif (! ptr->sizes) return GF_OUT_OF_MEM;\n\t\tptr->alloc_size = ptr->sampleCount;\n\n\t\tfor (i = 0; i < ptr->sampleCount; ) {\n\t\t\tu32 s_size;\n\t\t\tswitch (ptr->sampleSize) {\n\t\t\tcase 4:\n\t\t\t\ts_size = ptr->sizes[i] = gf_bs_read_int(bs, 4);\n\t\t\t\tif (ptr->max_size < s_size)\n\t\t\t\t\tptr->max_size = s_size;\n\t\t\t\tptr->total_size += s_size;\n\t\t\t\tptr->total_samples++;\n\t\t\t\tif (i+1 < ptr->sampleCount) {\n\t\t\t\t\ts_size = ptr->sizes[i+1] = gf_bs_read_int(bs, 4);\n\t\t\t\t\tif (ptr->max_size < s_size)\n\t\t\t\t\t\tptr->max_size = s_size;\n\t\t\t\t\tptr->total_size += s_size;\n\t\t\t\t\tptr->total_samples++;\n\t\t\t\t} else {\n\t\t\t\t\t//0 padding in odd sample count\n\t\t\t\t\tgf_bs_read_int(bs, 4);\n\t\t\t\t}\n\t\t\t\ti += 2;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\ts_size = ptr->sizes[i] = gf_bs_read_int(bs, ptr->sampleSize);\n\t\t\t\tif (ptr->max_size < s_size)\n\t\t\t\t\tptr->max_size = s_size;\n\t\t\t\tptr->total_size += s_size;\n\t\t\t\tptr->total_samples++;\n\t\t\t\ti += 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *stsz_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleSizeBox, 0);\n\n\t//type is unknown here, can be regular or compact table\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stsz_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_SampleSizeBox *ptr = (GF_SampleSizeBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\t//in both versions this is still valid\n\tif (ptr->type == GF_ISOM_BOX_TYPE_STSZ) {\n\t\tgf_bs_write_u32(bs, ptr->sampleSize);\n\t} else {\n\t\tgf_bs_write_u24(bs, 0);\n\t\tgf_bs_write_u8(bs, ptr->sampleSize);\n\t}\n\tgf_bs_write_u32(bs, ptr->sampleCount);\n\n\tif (ptr->type == GF_ISOM_BOX_TYPE_STSZ) {\n\t\tif (ptr->sampleSize) return GF_OK;\n\t\tfor (i = 0; i < ptr->sampleCount; i++) {\n\t\t\tgf_bs_write_u32(bs, ptr->sizes ? ptr->sizes[i] : 0);\n\t\t}\n\t} else {\n\t\tif (!ptr->sizes) return GF_ISOM_INVALID_FILE;\n\t\tfor (i = 0; i < ptr->sampleCount; ) {\n\t\t\tswitch (ptr->sampleSize) {\n\t\t\tcase 4:\n\t\t\t\tgf_bs_write_int(bs, ptr->sizes[i], 4);\n\t\t\t\tif (i+1 < ptr->sampleCount) {\n\t\t\t\t\tgf_bs_write_int(bs, ptr->sizes[i+1], 4);\n\t\t\t\t} else {\n\t\t\t\t\t//0 padding in odd sample count\n\t\t\t\t\tgf_bs_write_int(bs, 0, 4);\n\t\t\t\t}\n\t\t\t\ti += 2;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgf_bs_write_int(bs, ptr->sizes[i], ptr->sampleSize);\n\t\t\t\ti += 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err stsz_box_size(GF_Box *s)\n{\n\tu32 i, fieldSize, size;\n\tGF_SampleSizeBox *ptr = (GF_SampleSizeBox *)s;\n\n\tptr->size += 8;\n\tif (!ptr->sampleCount) return GF_OK;\n\n\t//regular table\n\tif (ptr->type == GF_ISOM_BOX_TYPE_STSZ) {\n\t\tif (ptr->sampleSize) return GF_OK;\n\t\tptr->size += (4 * ptr->sampleCount);\n\t\treturn GF_OK;\n\t}\n\tif (!ptr->sizes) return GF_ISOM_INVALID_FILE;\n\n\t//compact size table\n\tfieldSize = 4;\n\tsize = ptr->sizes[0];\n\n\tfor (i=0; i < ptr->sampleCount; i++) {\n\t\tif (ptr->sizes[i] <= 0xF) {\n\t\t}\n\t\t//switch to 8-bit table\n\t\telse if (ptr->sizes[i] <= 0xFF) {\n\t\t\tfieldSize = 8;\n\t\t}\n\t\t//switch to 16-bit table\n\t\telse if (ptr->sizes[i] <= 0xFFFF) {\n\t\t\tfieldSize = 16;\n\t\t}\n\t\t//switch to 32-bit table\n\t\telse {\n\t\t\tfieldSize = 32;\n\t\t}\n\n\t\t//check the size\n\t\tif (size != ptr->sizes[i]) size = 0;\n\t}\n\t//if all samples are of the same size, switch to regular (more compact)\n\tif (size) {\n\t\tptr->type = GF_ISOM_BOX_TYPE_STSZ;\n\t\tptr->sampleSize = size;\n\t\tgf_free(ptr->sizes);\n\t\tptr->sizes = NULL;\n\t\treturn GF_OK;\n\t}\n\n\tif (fieldSize == 32) {\n\t\t//oops, doesn't fit in a compact table\n\t\tptr->type = GF_ISOM_BOX_TYPE_STSZ;\n\t\tptr->size += (4 * ptr->sampleCount);\n\t\treturn GF_OK;\n\t}\n\n\t//make sure we are a compact table (no need to change the mem representation)\n\tptr->type = GF_ISOM_BOX_TYPE_STZ2;\n\tptr->sampleSize = fieldSize;\n\tif (fieldSize == 4) {\n\t\t//do not forget the 0 padding field for odd count\n\t\tptr->size += (ptr->sampleCount + 1) / 2;\n\t} else {\n\t\tptr->size += (ptr->sampleCount) * (fieldSize/8);\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid stts_box_del(GF_Box *s)\n{\n\tGF_TimeToSampleBox *ptr = (GF_TimeToSampleBox *)s;\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);\n}\n\n\nGF_Err stts_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tBool logged=GF_FALSE;\n\tGF_TimeToSampleBox *ptr = (GF_TimeToSampleBox *)s;\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tptr->w_LastDTS = 0;\n#endif\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->nb_entries = gf_bs_read_u32(bs);\n\tif (ptr->size / 8 < ptr->nb_entries || (u64)ptr->nb_entries > (u64)SIZE_MAX/sizeof(GF_SttsEntry)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in stts\\n\", ptr->nb_entries));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tptr->alloc_size = ptr->nb_entries;\n\tptr->entries = gf_malloc(sizeof(GF_SttsEntry)*ptr->alloc_size);\n\tif (!ptr->entries) return GF_OUT_OF_MEM;\n\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tptr->entries[i].sampleCount = gf_bs_read_u32(bs);\n\t\tptr->entries[i].sampleDelta = gf_bs_read_u32(bs);\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\t\tptr->w_currentSampleNum += ptr->entries[i].sampleCount;\n\t\tptr->w_LastDTS += (u64)ptr->entries[i].sampleCount * ptr->entries[i].sampleDelta;\n#endif\n\t\tif (ptr->max_ts_delta<ptr->entries[i].sampleDelta)\n\t\t\tptr->max_ts_delta = ptr->entries[i].sampleDelta;\n\n\t\tif (!ptr->entries[i].sampleDelta) {\n\t\t\tif ((i+1<ptr->nb_entries) ) {\n\t\t\t\tif (!logged) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Found stts entry with sample_delta=0 - forbidden ! Fixing to 1\\n\" ));\n\t\t\t\t\tlogged=GF_TRUE;\n\t\t\t\t}\n\t\t\t\tptr->entries[i].sampleDelta = 1;\n\t\t\t} else if (ptr->entries[i].sampleCount>1) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] more than one stts entry at the end of the track with sample_delta=0 - forbidden ! Fixing to 1\\n\" ));\n\t\t\t\tptr->entries[i].sampleDelta = 1;\n\t\t\t}\n\t\t}\n\t\t//cf issue 1644: some media streams may have sample duration > 2^31 (ttml mostly), we cannot patch this\n\t\t//for now we disable the check, one opt could be to have the check only for some media types, or only for the first entry\n#if 0\n\t\telse if ((s32) ptr->entries[i].sampleDelta < 0) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] stts entry %d has negative duration %d - forbidden ! Fixing to 1, sync may get lost (consider re-importing raw media)\\n\", i, (s32) ptr->entries[i].sampleDelta ));\n\t\t\tptr->entries[i].sampleDelta = 1;\n\t\t}\n#endif\n\n\t}\n\tISOM_DECREASE_SIZE(ptr, ptr->nb_entries*8);\n\n\t//remove the last sample delta.\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tif (ptr->nb_entries) ptr->w_LastDTS -= ptr->entries[ptr->nb_entries-1].sampleDelta;\n#endif\n\treturn GF_OK;\n}\n\nGF_Box *stts_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TimeToSampleBox, GF_ISOM_BOX_TYPE_STTS);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stts_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_TimeToSampleBox *ptr = (GF_TimeToSampleBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->nb_entries);\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tgf_bs_write_u32(bs, ptr->entries[i].sampleCount);\n\t\tgf_bs_write_u32(bs, ptr->entries[i].sampleDelta);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err stts_box_size(GF_Box *s)\n{\n\tGF_TimeToSampleBox *ptr = (GF_TimeToSampleBox *)s;\n\tptr->size += 4 + (8 * ptr->nb_entries);\n\treturn GF_OK;\n}\n\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\nvoid tfhd_box_del(GF_Box *s)\n{\n\tGF_TrackFragmentHeaderBox *ptr = (GF_TrackFragmentHeaderBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\nGF_Err tfhd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TrackFragmentHeaderBox *ptr = (GF_TrackFragmentHeaderBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->trackID = gf_bs_read_u32(bs);\n\n\t//The rest depends on the flags\n\tif (ptr->flags & GF_ISOM_TRAF_BASE_OFFSET) {\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\tptr->base_data_offset = gf_bs_read_u64(bs);\n\t}\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_DESC) {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->sample_desc_index = gf_bs_read_u32(bs);\n\t}\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_DUR) {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->def_sample_duration = gf_bs_read_u32(bs);\n\t}\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_SIZE) {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->def_sample_size = gf_bs_read_u32(bs);\n\t}\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_FLAGS) {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->def_sample_flags = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *tfhd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackFragmentHeaderBox, GF_ISOM_BOX_TYPE_TFHD);\n\t//NO FLAGS SET BY DEFAULT\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err tfhd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TrackFragmentHeaderBox *ptr = (GF_TrackFragmentHeaderBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->trackID);\n\n\t//The rest depends on the flags\n\tif (ptr->flags & GF_ISOM_TRAF_BASE_OFFSET) {\n\t\tgf_bs_write_u64(bs, ptr->base_data_offset);\n\t}\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_DESC) {\n\t\tgf_bs_write_u32(bs, ptr->sample_desc_index);\n\t}\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_DUR) {\n\t\tgf_bs_write_u32(bs, ptr->def_sample_duration);\n\t}\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_SIZE) {\n\t\tgf_bs_write_u32(bs, ptr->def_sample_size);\n\t}\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_FLAGS) {\n\t\tgf_bs_write_u32(bs, ptr->def_sample_flags);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err tfhd_box_size(GF_Box *s)\n{\n\tGF_TrackFragmentHeaderBox *ptr = (GF_TrackFragmentHeaderBox *)s;\n\tptr->size += 4;\n\n\t//The rest depends on the flags\n\tif (ptr->flags & GF_ISOM_TRAF_BASE_OFFSET) ptr->size += 8;\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_DESC) ptr->size += 4;\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_DUR) ptr->size += 4;\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_SIZE) ptr->size += 4;\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_FLAGS) ptr->size += 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM_FRAGMENTS*/\n\n\nvoid tims_box_del(GF_Box *s)\n{\n\tGF_TSHintEntryBox *tims = (GF_TSHintEntryBox *)s;\n\tgf_free(tims);\n}\n\nGF_Err tims_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TSHintEntryBox *ptr = (GF_TSHintEntryBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->timeScale = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\nGF_Box *tims_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TSHintEntryBox, GF_ISOM_BOX_TYPE_TIMS);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err tims_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TSHintEntryBox *ptr = (GF_TSHintEntryBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->timeScale);\n\treturn GF_OK;\n}\n\nGF_Err tims_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid tkhd_box_del(GF_Box *s)\n{\n\tGF_TrackHeaderBox *ptr = (GF_TrackHeaderBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n\treturn;\n}\n\n\nGF_Err tkhd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TrackHeaderBox *ptr = (GF_TrackHeaderBox *)s;\n\n\tif (ptr->version == 1) {\n\t\tISOM_DECREASE_SIZE(ptr, 32);\n\t\tptr->creationTime = gf_bs_read_u64(bs);\n\t\tptr->modificationTime = gf_bs_read_u64(bs);\n\t\tptr->trackID = gf_bs_read_u32(bs);\n\t\tptr->reserved1 = gf_bs_read_u32(bs);\n\t\tptr->duration = gf_bs_read_u64(bs);\n\t} else {\n\t\tISOM_DECREASE_SIZE(ptr, 20);\n\t\tptr->creationTime = gf_bs_read_u32(bs);\n\t\tptr->modificationTime = gf_bs_read_u32(bs);\n\t\tptr->trackID = gf_bs_read_u32(bs);\n\t\tptr->reserved1 = gf_bs_read_u32(bs);\n\t\tptr->duration = gf_bs_read_u32(bs);\n\t}\n\tptr->initial_duration = ptr->duration;\n\n\tISOM_DECREASE_SIZE(ptr, 60);\n\tptr->reserved2[0] = gf_bs_read_u32(bs);\n\tptr->reserved2[1] = gf_bs_read_u32(bs);\n\tptr->layer = gf_bs_read_u16(bs);\n\tptr->alternate_group = gf_bs_read_u16(bs);\n\tptr->volume = gf_bs_read_u16(bs);\n\tptr->reserved3 = gf_bs_read_u16(bs);\n\tptr->matrix[0] = gf_bs_read_u32(bs);\n\tptr->matrix[1] = gf_bs_read_u32(bs);\n\tptr->matrix[2] = gf_bs_read_u32(bs);\n\tptr->matrix[3] = gf_bs_read_u32(bs);\n\tptr->matrix[4] = gf_bs_read_u32(bs);\n\tptr->matrix[5] = gf_bs_read_u32(bs);\n\tptr->matrix[6] = gf_bs_read_u32(bs);\n\tptr->matrix[7] = gf_bs_read_u32(bs);\n\tptr->matrix[8] = gf_bs_read_u32(bs);\n\tptr->width = gf_bs_read_u32(bs);\n\tptr->height = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\nGF_Box *tkhd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackHeaderBox, GF_ISOM_BOX_TYPE_TKHD);\n\ttmp->matrix[0] = 0x00010000;\n\ttmp->matrix[4] = 0x00010000;\n\ttmp->matrix[8] = 0x40000000;\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err tkhd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TrackHeaderBox *ptr = (GF_TrackHeaderBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tif (ptr->version == 1) {\n\t\tgf_bs_write_u64(bs, ptr->creationTime);\n\t\tgf_bs_write_u64(bs, ptr->modificationTime);\n\t\tgf_bs_write_u32(bs, ptr->trackID);\n\t\tgf_bs_write_u32(bs, ptr->reserved1);\n\t\tgf_bs_write_u64(bs, ptr->duration);\n\t} else {\n\t\tgf_bs_write_u32(bs, (u32) ptr->creationTime);\n\t\tgf_bs_write_u32(bs, (u32) ptr->modificationTime);\n\t\tgf_bs_write_u32(bs, ptr->trackID);\n\t\tgf_bs_write_u32(bs, ptr->reserved1);\n\t\tgf_bs_write_u32(bs, (u32) ptr->duration);\n\t}\n\tgf_bs_write_u32(bs, ptr->reserved2[0]);\n\tgf_bs_write_u32(bs, ptr->reserved2[1]);\n\tgf_bs_write_u16(bs, ptr->layer);\n\tgf_bs_write_u16(bs, ptr->alternate_group);\n\tgf_bs_write_u16(bs, ptr->volume);\n\tgf_bs_write_u16(bs, ptr->reserved3);\n\tgf_bs_write_u32(bs, ptr->matrix[0]);\n\tgf_bs_write_u32(bs, ptr->matrix[1]);\n\tgf_bs_write_u32(bs, ptr->matrix[2]);\n\tgf_bs_write_u32(bs, ptr->matrix[3]);\n\tgf_bs_write_u32(bs, ptr->matrix[4]);\n\tgf_bs_write_u32(bs, ptr->matrix[5]);\n\tgf_bs_write_u32(bs, ptr->matrix[6]);\n\tgf_bs_write_u32(bs, ptr->matrix[7]);\n\tgf_bs_write_u32(bs, ptr->matrix[8]);\n\tgf_bs_write_u32(bs, ptr->width);\n\tgf_bs_write_u32(bs, ptr->height);\n\treturn GF_OK;\n}\n\nGF_Err tkhd_box_size(GF_Box *s)\n{\n\tGF_TrackHeaderBox *ptr = (GF_TrackHeaderBox *)s;\n\n\tif (ptr->duration==(u64) -1) ptr->version = 0;\n\telse ptr->version = (ptr->duration>0xFFFFFFFF) ? 1 : 0;\n\tptr->size += (ptr->version == 1) ? 32 : 20;\n\tptr->size += 60;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\nvoid traf_box_del(GF_Box *s)\n{\n\tGF_TrackFragmentBox *ptr = (GF_TrackFragmentBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->sub_samples) gf_list_del(ptr->sub_samples);\n\tgf_list_del(ptr->TrackRuns);\n\tif (ptr->sampleGroups) gf_list_del(ptr->sampleGroups);\n\tif (ptr->sampleGroupsDescription) gf_list_del(ptr->sampleGroupsDescription);\n\tif (ptr->sai_sizes) gf_list_del(ptr->sai_sizes);\n\tif (ptr->sai_offsets) gf_list_del(ptr->sai_offsets);\n\tgf_free(ptr);\n}\n\nGF_Err traf_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_TrackFragmentBox *ptr = (GF_TrackFragmentBox *)s;\n\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_TFHD:\n\t\tBOX_FIELD_ASSIGN(tfhd, GF_TrackFragmentHeaderBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_TRUN:\n\t\tBOX_FIELD_LIST_ASSIGN(TrackRuns)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_SDTP:\n\t\tBOX_FIELD_ASSIGN(sdtp, GF_SampleDependencyTypeBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_TFDT:\n\t\tBOX_FIELD_ASSIGN(tfdt, GF_TFBaseMediaDecodeTimeBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_SUBS:\n\t\tBOX_FIELD_LIST_ASSIGN(sub_samples)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_SBGP:\n\tcase GF_ISOM_BOX_TYPE_CSGP:\n\t\tBOX_FIELD_LIST_ASSIGN(sampleGroups)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_SGPD:\n\t\tBOX_FIELD_LIST_ASSIGN(sampleGroupsDescription)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_SAIZ:\n\t\tBOX_FIELD_LIST_ASSIGN(sai_sizes)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_SAIO:\n\t\tBOX_FIELD_LIST_ASSIGN(sai_offsets)\n\t\treturn GF_OK;\n\t//we will throw an error if both PIFF_PSEC and SENC are found. Not such files seen yet\n\tcase GF_ISOM_BOX_TYPE_UUID:\n\t\tif ( ((GF_UUIDBox *)a)->internal_4cc==GF_ISOM_BOX_UUID_PSEC) {\n\t\t\tBOX_FIELD_ASSIGN(sample_encryption, GF_SampleEncryptionBox)\n\t\t\tif (!is_rem)\n\t\t\t\tptr->sample_encryption->traf = ptr;\n\t\t\treturn GF_OK;\n\t\t} else if ( ((GF_UUIDBox *)a)->internal_4cc==GF_ISOM_BOX_UUID_TFXD) {\n\t\t\tBOX_FIELD_ASSIGN(tfxd, GF_MSSTimeExtBox)\n\t\t\treturn GF_OK;\n\t\t} else if ( ((GF_UUIDBox *)a)->internal_4cc==GF_ISOM_BOX_UUID_TFRF) {\n\t\t\tBOX_FIELD_ASSIGN(tfrf, GF_MSSTimeRefBox)\n\t\t\treturn GF_OK;\n\t\t} else {\n\t\t\treturn GF_OK;\n\t\t}\n\tcase GF_ISOM_BOX_TYPE_SENC:\n\t\tBOX_FIELD_ASSIGN(sample_encryption, GF_SampleEncryptionBox)\n\t\tif (!is_rem)\n\t\t\tptr->sample_encryption->traf = ptr;\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err traf_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TrackFragmentBox *ptr = (GF_TrackFragmentBox *)s;\n\tGF_Err e = gf_isom_box_array_read(s, bs);\n\tif (e) return e;\n\n\tif (!ptr->tfhd) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing TrackFragmentHeaderBox \\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *traf_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackFragmentBox, GF_ISOM_BOX_TYPE_TRAF);\n\ttmp->TrackRuns = gf_list_new();\n\n\tif (gf_sys_old_arch_compat())\n\t\ttmp->no_sdtp_first_flags = 1;\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err traf_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err traf_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_TrackFragmentBox *ptr = (GF_TrackFragmentBox *) s;\n\n\t//Header first\n\tgf_isom_check_position(s, (GF_Box *)ptr->tfhd, &pos);\n\tgf_isom_check_position_list(s, ptr->sub_samples, &pos);\n\n\tgf_isom_check_position(s, (GF_Box *)ptr->tfdt, &pos);\n\n\t//cmaf-like\n\tif (ptr->truns_first) {\n\t\tgf_isom_check_position_list(s, ptr->TrackRuns, &pos);\n\t\tgf_isom_check_position_list(s, ptr->sai_sizes, &pos);\n\t\tgf_isom_check_position_list(s, ptr->sai_offsets, &pos);\n\t\t//senc MUST be after saio in GPAC, as senc writing uses info from saio writing\n\t\tgf_isom_check_position(s, (GF_Box *)ptr->sample_encryption, &pos);\n\t\tgf_isom_check_position_list(s, ptr->sampleGroupsDescription, &pos);\n\t\tgf_isom_check_position_list(s, ptr->sampleGroups, &pos);\n\t\t//subsamples will be last\n\t} else {\n\t\tgf_isom_check_position_list(s, ptr->sampleGroupsDescription, &pos);\n\t\tgf_isom_check_position_list(s, ptr->sampleGroups, &pos);\n\t\tgf_isom_check_position_list(s, ptr->sai_sizes, &pos);\n\t\tgf_isom_check_position_list(s, ptr->sai_offsets, &pos);\n\t\tgf_isom_check_position(s, (GF_Box *)ptr->sample_encryption, &pos);\n\t\tgf_isom_check_position_list(s, ptr->TrackRuns, &pos);\n\t}\n\n\t//when sdtp is present (smooth-like) write it after the trun box\n\tgf_isom_check_position(s, (GF_Box *)ptr->sdtp, &pos);\n\n\t//tfxd should be last ...\n\tif (ptr->tfxd)\n\t\tgf_isom_check_position(s, (GF_Box *)ptr->tfxd, &pos);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *tfxd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MSSTimeExtBox, GF_ISOM_BOX_TYPE_UUID);\n\ttmp->internal_4cc = GF_ISOM_BOX_UUID_TFXD;\n\ttmp->version = 1;\n\treturn (GF_Box *)tmp;\n}\n\nvoid tfxd_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\n\nGF_Err tfxd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MSSTimeExtBox *ptr = (GF_MSSTimeExtBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->version = gf_bs_read_u8(bs);\n\tptr->flags = gf_bs_read_u24(bs);\n\n\tif (ptr->version == 0x01) {\n\t\tISOM_DECREASE_SIZE(ptr, 16);\n\t\tptr->absolute_time_in_track_timescale = gf_bs_read_u64(bs);\n\t\tptr->fragment_duration_in_track_timescale = gf_bs_read_u64(bs);\n\t} else {\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\tptr->absolute_time_in_track_timescale = gf_bs_read_u32(bs);\n\t\tptr->fragment_duration_in_track_timescale = gf_bs_read_u32(bs);\n\t}\n\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err tfxd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MSSTimeExtBox *ptr = (GF_MSSTimeExtBox*)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u8(bs, ptr->version);\n\tgf_bs_write_u24(bs, 0);\n\tif (ptr->version) {\n\t\tgf_bs_write_u64(bs, ptr->absolute_time_in_track_timescale);\n\t\tgf_bs_write_u64(bs, ptr->fragment_duration_in_track_timescale);\n\t} else {\n\t\tgf_bs_write_u32(bs, (u32) ptr->absolute_time_in_track_timescale);\n\t\tgf_bs_write_u32(bs, (u32) ptr->fragment_duration_in_track_timescale);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err tfxd_box_size(GF_Box *s)\n{\n\tGF_MSSTimeExtBox *ptr = (GF_MSSTimeExtBox*)s;\n\ts->size += 4 + (ptr->version ? 16 : 8);\n\treturn GF_OK;\n}\n#endif //GPAC_DISABLE_ISOM_WRITE\n\n\n\nGF_Box *tfrf_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MSSTimeRefBox, GF_ISOM_BOX_TYPE_UUID);\n\ttmp->internal_4cc = GF_ISOM_BOX_UUID_TFRF;\n\treturn (GF_Box *)tmp;\n}\n\nvoid tfrf_box_del(GF_Box *s)\n{\n\tGF_MSSTimeRefBox *ptr = (GF_MSSTimeRefBox *)s;\n\tif (ptr->frags) gf_free(ptr->frags);\n\tgf_free(s);\n}\n\n\nGF_Err tfrf_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_MSSTimeRefBox *ptr = (GF_MSSTimeRefBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 5);\n\tptr->version = gf_bs_read_u8(bs);\n\tptr->flags = gf_bs_read_u24(bs);\n\tptr->frags_count = gf_bs_read_u8(bs);\n\tptr->frags = gf_malloc(sizeof(GF_MSSTimeEntry) * ptr->frags_count);\n\tif (!ptr->frags) return GF_OUT_OF_MEM;\n\n\tfor (i=0; i<ptr->frags_count; i++) {\n\t\tif (ptr->version == 0x01) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 16);\n\t\t\tptr->frags[i].absolute_time_in_track_timescale = gf_bs_read_u64(bs);\n\t\t\tptr->frags[i].fragment_duration_in_track_timescale = gf_bs_read_u64(bs);\n\t\t} else {\n\t\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\t\tptr->frags[i].absolute_time_in_track_timescale = gf_bs_read_u32(bs);\n\t\t\tptr->frags[i].fragment_duration_in_track_timescale = gf_bs_read_u32(bs);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err tfrf_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_MSSTimeRefBox *ptr = (GF_MSSTimeRefBox*)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u8(bs, ptr->version);\n\tgf_bs_write_u24(bs, 0);\n\tgf_bs_write_u8(bs, ptr->frags_count);\n\tfor (i=0; i<ptr->frags_count; i++) {\n\t\tif (ptr->version==0x01) {\n\t\t\tgf_bs_write_u64(bs, ptr->frags[i].absolute_time_in_track_timescale);\n\t\t\tgf_bs_write_u64(bs, ptr->frags[i].fragment_duration_in_track_timescale);\n\t\t} else {\n\t\t\tgf_bs_write_u32(bs, (u32) ptr->frags[i].absolute_time_in_track_timescale);\n\t\t\tgf_bs_write_u32(bs, (u32) ptr->frags[i].fragment_duration_in_track_timescale);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err tfrf_box_size(GF_Box *s)\n{\n\tGF_MSSTimeRefBox *ptr = (GF_MSSTimeRefBox*)s;\n\ts->size += 5;\n\tif (ptr->version) s->size += 16 * ptr->frags_count;\n\telse s->size += 8 * ptr->frags_count;\n\treturn GF_OK;\n}\n#endif //GPAC_DISABLE_ISOM_WRITE\n\n#endif /*GPAC_DISABLE_ISOM_FRAGMENTS*/\n\n\nvoid trak_box_del(GF_Box *s)\n{\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tGF_TrackBox *ptr = (GF_TrackBox *)s;\n\tif (ptr->chunk_cache)\n\t\tgf_bs_del(ptr->chunk_cache);\n#endif\n\tgf_free(s);\n}\n\nstatic void stsd_switch_box(GF_BitStream *bs, GF_Box *box, GF_UnknownBox *a, u8 **data, u32 *data_size, u32 *EntryType, GF_SampleDescriptionBox *stsd, u32 stsd_idx)\n{\n\tif (gf_bs_available(bs)) {\n\t\tGF_Err e;\n\t\tu32 count_subb;\n\t\tgf_bs_set_cookie(bs, GF_ISOM_BS_COOKIE_NO_LOGS);\n\t\te = gf_isom_box_array_read(box, bs);\n\t\tcount_subb = box->child_boxes ? gf_list_count(box->child_boxes) : 0;\n\t\tif (count_subb && !e) {\n\t\t\tu32 i;\n\t\t\tGF_BitStream *new_dsi = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\t\t//serialize all unknown boxes\n\t\t\tfor (i=0; i<count_subb; i++) {\n\t\t\t\tGF_UnknownBox *priv = gf_list_get(box->child_boxes, i);\n\t\t\t\tif (priv->type != GF_ISOM_BOX_TYPE_UNKNOWN) continue;\n\t\t\t\tgf_bs_write_u32(new_dsi, 8 + priv->dataSize);\n\t\t\t\tgf_bs_write_u32(new_dsi, priv->original_4cc);\n\t\t\t\tgf_bs_write_data(new_dsi, priv->data, priv->dataSize);\n\t\t\t\tgf_list_rem(box->child_boxes, i);\n\t\t\t\tgf_isom_box_del((GF_Box*)priv);\n\t\t\t\tcount_subb--;\n\t\t\t\ti--;\n\t\t\t}\n\t\t\tif (*data) gf_free(*data);\n\t\t\tgf_bs_get_content(new_dsi, data, data_size);\n\t\t\tgf_bs_del(new_dsi);\n\t\t} else {\n\t\t\t*data_size = 0;\n\t\t}\n\t}\n\tgf_bs_del(bs);\n\tif (!*data_size && *data) {\n\t\tgf_free(*data);\n\t\t*data = NULL;\n\t}\n\tbox->size = 0;\n\t*EntryType = a->original_4cc;\n\tgf_list_rem(stsd->child_boxes, stsd_idx);\n\tgf_isom_box_del((GF_Box *)a);\n\tgf_list_insert(stsd->child_boxes, box, stsd_idx);\n}\n\n\nstatic GF_Err gf_isom_check_sample_desc(GF_TrackBox *trak)\n{\n\tGF_BitStream *bs;\n\tGF_UnknownBox *a;\n\tu32 i;\n\tGF_Err e;\n\tGF_SampleTableBox *stbl;\n\n\tif (!trak->Media || !trak->Media->information) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Track with no media box !\\n\" ));\n\t\treturn GF_OK;\n\t}\n\tif (!trak->Media->information->sampleTable) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Track with no sample table !\\n\" ));\n\t\ttrak->Media->information->sampleTable = (GF_SampleTableBox *) gf_isom_box_new_parent(&trak->Media->information->child_boxes, GF_ISOM_BOX_TYPE_STBL);\n\t}\n\tstbl = trak->Media->information->sampleTable;\n\n\tif (!stbl->SampleDescription) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Track with no sample description box !\\n\" ));\n\t\tstbl->SampleDescription = (GF_SampleDescriptionBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STSD);\n\t\treturn GF_OK;\n\t}\n\n\ti=0;\n\twhile ((a = (GF_UnknownBox*)gf_list_enum(stbl->SampleDescription->child_boxes, &i))) {\n\t\tGF_ProtectionSchemeInfoBox *sinf;\n\t\tu32 base_ent_type = 0;\n\t\tu32 type = a->type;\n\t\tu32 sinf_type = GF_ISOM_BOX_TYPE_SINF;\n\t\tswitch (a->type) {\n\t\tcase GF_ISOM_BOX_TYPE_RESV:\n\t\t\tsinf_type = GF_ISOM_BOX_TYPE_RINF;\n\t\tcase GF_ISOM_BOX_TYPE_ENCS:\n\t\tcase GF_ISOM_BOX_TYPE_ENCA:\n\t\tcase GF_ISOM_BOX_TYPE_ENCV:\n\t\tcase GF_ISOM_BOX_TYPE_ENCT:\n\t\t\tsinf = (GF_ProtectionSchemeInfoBox *) gf_isom_box_find_child(a->child_boxes, sinf_type);\n\t\t\tif (!sinf || !sinf->original_format) return GF_ISOM_INVALID_FILE;\n\t\t\ttype = sinf->original_format->data_format;\n\t\t\tbase_ent_type = ((GF_SampleEntryBox *)a)->internal_type;\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (type) {\n\t\tcase GF_ISOM_BOX_TYPE_MP4S:\n\t\t\tif (base_ent_type && (base_ent_type != GF_ISOM_SAMPLE_ENTRY_MP4S)) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Protected sample entry %s uses incompatible sample description %s\\n\", gf_4cc_to_str(a->type), gf_4cc_to_str(type) ));\n\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t\tcontinue;\n\n\t\tcase GF_ISOM_SUBTYPE_3GP_AMR:\n\t\tcase GF_ISOM_SUBTYPE_3GP_AMR_WB:\n\t\tcase GF_ISOM_SUBTYPE_3GP_EVRC:\n\t\tcase GF_ISOM_SUBTYPE_3GP_QCELP:\n\t\tcase GF_ISOM_SUBTYPE_3GP_SMV:\n\t\tcase GF_ISOM_BOX_TYPE_MP4A:\n\t\tcase GF_ISOM_BOX_TYPE_MP3:\n\t\tcase GF_ISOM_BOX_TYPE_MHA1:\n\t\tcase GF_ISOM_BOX_TYPE_MHA2:\n\t\tcase GF_ISOM_BOX_TYPE_MHM1:\n\t\tcase GF_ISOM_BOX_TYPE_MHM2:\n\t\tcase GF_ISOM_BOX_TYPE_OPUS:\n\t\tcase GF_ISOM_BOX_TYPE_AC3:\n\t\tcase GF_ISOM_BOX_TYPE_EC3:\n\t\tcase GF_QT_SUBTYPE_RAW_AUD:\n\t\tcase GF_QT_SUBTYPE_TWOS:\n\t\tcase GF_QT_SUBTYPE_SOWT:\n\t\tcase GF_QT_SUBTYPE_FL32:\n\t\tcase GF_QT_SUBTYPE_FL64:\n\t\tcase GF_QT_SUBTYPE_IN24:\n\t\tcase GF_QT_SUBTYPE_IN32:\n\t\tcase GF_QT_SUBTYPE_ULAW:\n\t\tcase GF_QT_SUBTYPE_ALAW:\n\t\tcase GF_QT_SUBTYPE_ADPCM:\n\t\tcase GF_QT_SUBTYPE_IMA_ADPCM:\n\t\tcase GF_QT_SUBTYPE_DVCA:\n\t\tcase GF_QT_SUBTYPE_QDMC:\n\t\tcase GF_QT_SUBTYPE_QDMC2:\n\t\tcase GF_QT_SUBTYPE_QCELP:\n\t\tcase GF_QT_SUBTYPE_kMP3:\n\t\tcase GF_ISOM_BOX_TYPE_IPCM:\n\t\tcase GF_ISOM_BOX_TYPE_FPCM:\n\t\t\tif (base_ent_type && (base_ent_type != GF_ISOM_SAMPLE_ENTRY_AUDIO))\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\tcontinue;\n\n\t\tcase GF_ISOM_BOX_TYPE_MP4V:\n\t\tcase GF_ISOM_SUBTYPE_3GP_H263:\n\t\tcase GF_ISOM_BOX_TYPE_AVC1:\n\t\tcase GF_ISOM_BOX_TYPE_AVC2:\n\t\tcase GF_ISOM_BOX_TYPE_AVC3:\n\t\tcase GF_ISOM_BOX_TYPE_AVC4:\n\t\tcase GF_ISOM_BOX_TYPE_SVC1:\n\t\tcase GF_ISOM_BOX_TYPE_MVC1:\n\t\tcase GF_ISOM_BOX_TYPE_HVC1:\n\t\tcase GF_ISOM_BOX_TYPE_HEV1:\n\t\tcase GF_ISOM_BOX_TYPE_HVC2:\n\t\tcase GF_ISOM_BOX_TYPE_HEV2:\n\t\tcase GF_ISOM_BOX_TYPE_HVT1:\n\t\tcase GF_ISOM_BOX_TYPE_LHV1:\n\t\tcase GF_ISOM_BOX_TYPE_LHE1:\n\t\tcase GF_ISOM_BOX_TYPE_AV01:\n\t\tcase GF_ISOM_BOX_TYPE_VP08:\n\t\tcase GF_ISOM_BOX_TYPE_VP09:\n\t\tcase GF_ISOM_BOX_TYPE_AV1C:\n\t\tcase GF_ISOM_BOX_TYPE_JPEG:\n\t\tcase GF_ISOM_BOX_TYPE_PNG:\n\t\tcase GF_ISOM_BOX_TYPE_JP2K:\n\t\tcase GF_ISOM_BOX_TYPE_MJP2:\n\t\tcase GF_QT_SUBTYPE_APCH:\n\t\tcase GF_QT_SUBTYPE_APCO:\n\t\tcase GF_QT_SUBTYPE_APCN:\n\t\tcase GF_QT_SUBTYPE_APCS:\n\t\tcase GF_QT_SUBTYPE_AP4X:\n\t\tcase GF_QT_SUBTYPE_AP4H:\n\t\tcase GF_ISOM_BOX_TYPE_VVC1:\n\t\tcase GF_ISOM_BOX_TYPE_VVI1:\n\t\tcase GF_QT_SUBTYPE_RAW_VID:\n\t\tcase GF_QT_SUBTYPE_YUYV:\n\t\tcase GF_QT_SUBTYPE_UYVY:\n\t\tcase GF_QT_SUBTYPE_YUV444:\n\t\tcase GF_QT_SUBTYPE_YUVA444:\n\t\tcase GF_QT_SUBTYPE_YUV422_10:\n\t\tcase GF_QT_SUBTYPE_YUV444_10:\n\t\tcase GF_QT_SUBTYPE_YUV422_16:\n\t\tcase GF_QT_SUBTYPE_YUV420:\n\t\tcase GF_QT_SUBTYPE_I420:\n\t\tcase GF_QT_SUBTYPE_IYUV:\n\t\tcase GF_QT_SUBTYPE_YV12:\n\t\tcase GF_QT_SUBTYPE_YVYU:\n\t\tcase GF_QT_SUBTYPE_RGBA:\n\t\tcase GF_QT_SUBTYPE_ABGR:\n\t\tcase GF_ISOM_BOX_TYPE_DVHE:\n\t\tcase GF_ISOM_BOX_TYPE_DVH1:\n\t\tcase GF_ISOM_BOX_TYPE_DVA1:\n\t\tcase GF_ISOM_BOX_TYPE_DVAV:\n\t\tcase GF_ISOM_BOX_TYPE_DAV1:\n\t\t\tif (base_ent_type && (base_ent_type != GF_ISOM_SAMPLE_ENTRY_VIDEO))\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\tcontinue;\n\n\n\t\tcase GF_ISOM_BOX_TYPE_METX:\n\t\tcase GF_ISOM_BOX_TYPE_METT:\n\t\tcase GF_ISOM_BOX_TYPE_STXT:\n\t\tcase GF_ISOM_BOX_TYPE_TX3G:\n\t\tcase GF_ISOM_BOX_TYPE_TEXT:\n\t\tcase GF_ISOM_BOX_TYPE_GHNT:\n\t\tcase GF_ISOM_BOX_TYPE_RTP_STSD:\n\t\tcase GF_ISOM_BOX_TYPE_SRTP_STSD:\n\t\tcase GF_ISOM_BOX_TYPE_FDP_STSD:\n\t\tcase GF_ISOM_BOX_TYPE_RRTP_STSD:\n\t\tcase GF_ISOM_BOX_TYPE_RTCP_STSD:\n\t\tcase GF_ISOM_BOX_TYPE_DIMS:\n\t\tcase GF_ISOM_BOX_TYPE_LSR1:\n\t\tcase GF_ISOM_BOX_TYPE_WVTT:\n\t\tcase GF_ISOM_BOX_TYPE_STPP:\n\t\tcase GF_ISOM_BOX_TYPE_SBTT:\n\t\t\tif (base_ent_type && (base_ent_type != GF_ISOM_SAMPLE_ENTRY_GENERIC))\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\tcontinue;\n\n\n\t\tcase GF_ISOM_BOX_TYPE_UNKNOWN:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (gf_box_valid_in_parent((GF_Box *) a, \"stsd\")) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Unexpected box %s in stsd!\\n\", gf_4cc_to_str(a->type)));\n\t\t\tcontinue;\n\t\t}\n\t\t//we are sure to have an unknown box here\n\t\tassert(a->type==GF_ISOM_BOX_TYPE_UNKNOWN);\n\n\t\tif (!a->data || (a->dataSize<8) ) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Sample description %s does not have at least 8 bytes!\\n\", gf_4cc_to_str(a->original_4cc) ));\n\t\t\tcontinue;\n\t\t}\n\t\telse if (a->dataSize > a->size) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Sample description %s has wrong data size %d!\\n\", gf_4cc_to_str(a->original_4cc), a->dataSize));\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*only process visual or audio\n\t\tnote: no need for new_box_parent here since we always store sample descriptions in child_boxes*/\n\t\tswitch (trak->Media->handler->handlerType) {\n        case GF_ISOM_MEDIA_VISUAL:\n\t\tcase GF_ISOM_MEDIA_AUXV:\n\t\tcase GF_ISOM_MEDIA_PICT:\n\t\t{\n\t\t\tGF_GenericVisualSampleEntryBox *genv = (GF_GenericVisualSampleEntryBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_GNRV);\n\t\t\tbs = gf_bs_new(a->data, a->dataSize, GF_BITSTREAM_READ);\n\t\t\tgenv->size = a->size-8;\n\t\t\tgf_isom_video_sample_entry_read((GF_VisualSampleEntryBox *) genv, bs);\n\n\t\t\tstsd_switch_box(bs, (GF_Box *) genv, a, &genv->data, &genv->data_size, &genv->EntryType, trak->Media->information->sampleTable->SampleDescription, i-1);\n\t\t}\n\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_AUDIO:\n\t\t{\n\t\t\tGF_GenericAudioSampleEntryBox *gena = (GF_GenericAudioSampleEntryBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_GNRA);\n\t\t\tgena->size = a->size-8;\n\t\t\tbs = gf_bs_new(a->data, a->dataSize, GF_BITSTREAM_READ);\n\t\t\tgf_isom_audio_sample_entry_read((GF_AudioSampleEntryBox *) gena, bs);\n\n\t\t\tstsd_switch_box(bs, (GF_Box *) gena, a, &gena->data, &gena->data_size, &gena->EntryType, trak->Media->information->sampleTable->SampleDescription, i-1);\n\t\t}\n\t\tbreak;\n\n\t\tdefault:\n\t\t{\n\t\t\tGF_GenericSampleEntryBox *genm = (GF_GenericSampleEntryBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_GNRM);\n\t\t\tgenm->size = a->size-8;\n\t\t\tbs = gf_bs_new(a->data, a->dataSize, GF_BITSTREAM_READ);\n\n\t\t\te = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)genm, bs);\n\t\t\tif (e) return e;\n\n\t\t\tstsd_switch_box(bs, (GF_Box *) genm, a, &genm->data, &genm->data_size, &genm->EntryType, trak->Media->information->sampleTable->SampleDescription, i-1);\n\t\t}\n\t\tbreak;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err trak_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_TrackBox *ptr = (GF_TrackBox *)s;\n\tif (!a) return GF_OK;\n\tswitch(a->type) {\n\tcase GF_ISOM_BOX_TYPE_TKHD:\n\t\tBOX_FIELD_ASSIGN(Header, GF_TrackHeaderBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_EDTS:\n\t\tBOX_FIELD_ASSIGN(editBox, GF_EditBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_UDTA:\n\t\tBOX_FIELD_ASSIGN(udta, GF_UserDataBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_META:\n\t\tBOX_FIELD_ASSIGN(meta, GF_MetaBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_TREF:\n\t\tBOX_FIELD_ASSIGN(References, GF_TrackReferenceBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_MDIA:\n\t\tBOX_FIELD_ASSIGN(Media, GF_MediaBox)\n\t\tif (!is_rem)\n\t\t\t((GF_MediaBox *)a)->mediaTrack = ptr;\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_TRGR:\n\t\tBOX_FIELD_ASSIGN(groups, GF_TrackGroupBox)\n\t\treturn GF_OK;\n\tcase GF_QT_BOX_TYPE_TAPT:\n\t\tBOX_FIELD_ASSIGN(Aperture, GF_Box)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_SENC:\n\t\tBOX_FIELD_ASSIGN(sample_encryption, GF_SampleEncryptionBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_UUID:\n\t\tif (((GF_UnknownUUIDBox *)a)->internal_4cc == GF_ISOM_BOX_UUID_PSEC) {\n\t\t\tBOX_FIELD_ASSIGN(sample_encryption, GF_SampleEncryptionBox)\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err trak_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_TrackBox *ptr = (GF_TrackBox *)s;\n\te = gf_isom_box_array_read(s, bs);\n\tif (e) return e;\n\te = gf_isom_check_sample_desc(ptr);\n\tif (e) return e;\n\n\tif (!ptr->Header) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing TrackHeaderBox\\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tif (!ptr->Media) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing MediaBox\\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tif (!ptr->Media->information || !ptr->Media->information->sampleTable) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid MediaBox\\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tif (!ptr->Media->information->sampleTable->SampleSize || (ptr->Media->information->sampleTable->SampleSize->sampleCount==0)) {\n\t\tif (ptr->Header->initial_duration) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Track with no samples but duration defined, ignoring duration\\n\"));\n\t\t\tptr->Header->initial_duration = 0;\n\t\t}\n\t}\n\n\tfor (i=0; i<gf_list_count(ptr->Media->information->sampleTable->child_boxes); i++) {\n\t\tGF_Box *a = gf_list_get(ptr->Media->information->sampleTable->child_boxes, i);\n\t\tif ((a->type ==GF_ISOM_BOX_TYPE_UUID) && (((GF_UUIDBox *)a)->internal_4cc == GF_ISOM_BOX_UUID_PSEC)) {\n\t\t\tptr->sample_encryption = (struct __sample_encryption_box *) a;\n\t\t\tbreak;\n\t\t}\n\t\telse if (a->type == GF_ISOM_BOX_TYPE_SENC) {\n\t\t\tptr->sample_encryption = (struct __sample_encryption_box *)a;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn e;\n}\n\nGF_Box *trak_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackBox, GF_ISOM_BOX_TYPE_TRAK);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err trak_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err trak_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_TrackBox *ptr = (GF_TrackBox *)s;\n\n\tif (ptr->sample_encryption && ptr->sample_encryption->load_needed) {\n\t\tif (!ptr->moov || !ptr->moov->mov || !ptr->moov->mov->movieFileMap)\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\tGF_Err e = senc_Parse(ptr->moov->mov->movieFileMap->bs, ptr, NULL, ptr->sample_encryption);\n\t\tif (e) return e;\n\t}\n\n\tgf_isom_check_position(s, (GF_Box *)ptr->Header, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->Aperture, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->References, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->editBox, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->Media, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->meta, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->groups, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->udta, &pos);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid stri_box_del(GF_Box *s)\n{\n\tGF_SubTrackInformationBox *ptr = (GF_SubTrackInformationBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->attribute_list) gf_free(ptr->attribute_list);\n\tgf_free(ptr);\n}\n\nGF_Err stri_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tsize_t i;\n\tGF_SubTrackInformationBox *ptr = (GF_SubTrackInformationBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 8)\n\tptr->switch_group = gf_bs_read_u16(bs);\n\tptr->alternate_group = gf_bs_read_u16(bs);\n\tptr->sub_track_id = gf_bs_read_u32(bs);\n\tptr->attribute_count = ptr->size / 4;\n\tif ((u64)ptr->attribute_count > (u64)SIZE_MAX/sizeof(u32)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid size %llu in stri\\n\", ptr->size));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tGF_SAFE_ALLOC_N(ptr->attribute_list, (size_t)ptr->attribute_count, u32);\n\tif (!ptr->attribute_list) return GF_OUT_OF_MEM;\n\tfor (i = 0; i < ptr->attribute_count; i++) {\n\t\tISOM_DECREASE_SIZE(ptr, 4)\n\t\tptr->attribute_list[i] = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *stri_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SubTrackInformationBox, GF_ISOM_BOX_TYPE_STRI);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stri_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_SubTrackInformationBox *ptr = (GF_SubTrackInformationBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u16(bs, ptr->switch_group);\n\tgf_bs_write_u16(bs, ptr->alternate_group);\n\tgf_bs_write_u32(bs, ptr->sub_track_id);\n\tfor (i = 0; i < ptr->attribute_count; i++) {\n\t\tgf_bs_write_u32(bs, ptr->attribute_list[i]);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err stri_box_size(GF_Box *s)\n{\n\tGF_SubTrackInformationBox *ptr = (GF_SubTrackInformationBox *)s;\n\n\tptr->size += 8 + 4 * ptr->attribute_count;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid stsg_box_del(GF_Box *s)\n{\n\tGF_SubTrackSampleGroupBox *ptr = (GF_SubTrackSampleGroupBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->group_description_index) gf_free(ptr->group_description_index);\n\tgf_free(ptr);\n}\n\nGF_Err stsg_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_SubTrackSampleGroupBox *ptr = (GF_SubTrackSampleGroupBox *)s;\n\tISOM_DECREASE_SIZE(s, 6);\n\tptr->grouping_type = gf_bs_read_u32(bs);\n\tptr->nb_groups = gf_bs_read_u16(bs);\n\tISOM_DECREASE_SIZE(s, ptr->nb_groups*4);\n\tGF_SAFE_ALLOC_N(ptr->group_description_index, ptr->nb_groups, u32);\n\tif (!ptr->group_description_index) return GF_OUT_OF_MEM;\n\tfor (i = 0; i < ptr->nb_groups; i++) {\n\t\tptr->group_description_index[i] = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *stsg_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SubTrackSampleGroupBox, GF_ISOM_BOX_TYPE_STSG);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stsg_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_SubTrackSampleGroupBox *ptr = (GF_SubTrackSampleGroupBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->grouping_type);\n\tgf_bs_write_u16(bs, ptr->nb_groups);\n\tfor (i = 0; i < ptr->nb_groups; i++) {\n\t\tgf_bs_write_u32(bs, ptr->group_description_index[i]);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err stsg_box_size(GF_Box *s)\n{\n\tGF_SubTrackSampleGroupBox *ptr = (GF_SubTrackSampleGroupBox *)s;\n\tptr->size += 6 + 4 * ptr->nb_groups;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid strk_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err strk_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_SubTrackBox *ptr = (GF_SubTrackBox *)s;\n\tif (!a) return GF_OK;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_STRI:\n\t\tBOX_FIELD_ASSIGN(info, GF_SubTrackInformationBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_STRD:\n\t\tBOX_FIELD_ASSIGN(strd, GF_Box)\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err strk_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SubTrackBox *ptr = (GF_SubTrackBox *)s;\n\te = gf_isom_box_array_read(s, bs);\n\tif (e) return e;\n\n\tif (!ptr->info) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing SubTrackInformationBox\\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *strk_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SubTrackBox, GF_ISOM_BOX_TYPE_STRK);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err strk_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err strk_box_size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid tref_box_del(GF_Box *s)\n{\n\tGF_TrackReferenceBox *ptr = (GF_TrackReferenceBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err tref_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *tref_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackReferenceBox, GF_ISOM_BOX_TYPE_TREF);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err tref_box_write(GF_Box *s, GF_BitStream *bs)\n{\n//\tGF_TrackReferenceBox *ptr = (GF_TrackReferenceBox *)s;\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err tref_box_size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid reftype_box_del(GF_Box *s)\n{\n\tGF_TrackReferenceTypeBox *ptr = (GF_TrackReferenceTypeBox *)s;\n\tif (!ptr) return;\n\tif (ptr->trackIDs) gf_free(ptr->trackIDs);\n\tgf_free(ptr);\n}\n\n\nGF_Err reftype_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 bytesToRead;\n\tu32 i;\n\tGF_TrackReferenceTypeBox *ptr = (GF_TrackReferenceTypeBox *)s;\n\n\tbytesToRead = (u32) (ptr->size);\n\tif (!bytesToRead) return GF_OK;\n\n\tptr->trackIDCount = (u32) (bytesToRead) / sizeof(u32);\n\tptr->trackIDs = (GF_ISOTrackID *) gf_malloc(ptr->trackIDCount * sizeof(GF_ISOTrackID));\n\tif (!ptr->trackIDs) return GF_OUT_OF_MEM;\n\n\tfor (i = 0; i < ptr->trackIDCount; i++) {\n\t\tptr->trackIDs[i] = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *reftype_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackReferenceTypeBox, GF_ISOM_BOX_TYPE_REFT);\n\treturn (GF_Box *)tmp;\n}\n\n\nGF_Err reftype_AddRefTrack(GF_TrackReferenceTypeBox *ref, GF_ISOTrackID trackID, u16 *outRefIndex)\n{\n\tu32 i;\n\tif (!ref || !trackID) return GF_BAD_PARAM;\n\n\tif (outRefIndex) *outRefIndex = 0;\n\t//don't add a dep if already here !!\n\tfor (i = 0; i < ref->trackIDCount; i++) {\n\t\tif (ref->trackIDs[i] == trackID) {\n\t\t\tif (outRefIndex) *outRefIndex = i+1;\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\n\tref->trackIDs = (GF_ISOTrackID *) gf_realloc(ref->trackIDs, (ref->trackIDCount + 1) * sizeof(GF_ISOTrackID) );\n\tif (!ref->trackIDs) return GF_OUT_OF_MEM;\n\tref->trackIDs[ref->trackIDCount] = trackID;\n\tref->trackIDCount++;\n\tif (outRefIndex) *outRefIndex = ref->trackIDCount;\n\treturn GF_OK;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err reftype_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_TrackReferenceTypeBox *ptr = (GF_TrackReferenceTypeBox *)s;\n\tif (ptr->reference_type == GF_ISOM_BOX_TYPE_UUID) return GF_BAD_PARAM;\n\tptr->type = ptr->reference_type;\n\te = gf_isom_box_write_header(s, bs);\n\tptr->type = GF_ISOM_BOX_TYPE_REFT;\n\tif (e) return e;\n\tfor (i = 0; i < ptr->trackIDCount; i++) {\n\t\tgf_bs_write_u32(bs, ptr->trackIDs[i]);\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err reftype_box_size(GF_Box *s)\n{\n\tGF_TrackReferenceTypeBox *ptr = (GF_TrackReferenceTypeBox *)s;\n\tif (ptr->trackIDCount)\n\t\tptr->size += (ptr->trackIDCount * sizeof(u32));\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\nvoid trex_box_del(GF_Box *s)\n{\n\tGF_TrackExtendsBox *ptr = (GF_TrackExtendsBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err trex_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TrackExtendsBox *ptr = (GF_TrackExtendsBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 20);\n\tptr->trackID = gf_bs_read_u32(bs);\n\tptr->def_sample_desc_index = gf_bs_read_u32(bs);\n\tptr->def_sample_duration = gf_bs_read_u32(bs);\n\tptr->def_sample_size = gf_bs_read_u32(bs);\n\tptr->def_sample_flags = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\nGF_Box *trex_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackExtendsBox, GF_ISOM_BOX_TYPE_TREX);\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err trex_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TrackExtendsBox *ptr = (GF_TrackExtendsBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->trackID);\n\t//we always write 1 in trex default sample desc as using 0 breaks chrome/opera/...\n\tgf_bs_write_u32(bs, ptr->def_sample_desc_index ? ptr->def_sample_desc_index : 1);\n\tgf_bs_write_u32(bs, ptr->def_sample_duration);\n\tgf_bs_write_u32(bs, ptr->def_sample_size);\n\tgf_bs_write_u32(bs, ptr->def_sample_flags);\n\treturn GF_OK;\n}\n\nGF_Err trex_box_size(GF_Box *s)\n{\n\tGF_TrackExtendsBox *ptr = (GF_TrackExtendsBox *)s;\n\tptr->size += 20;\n\treturn GF_OK;\n}\n\n\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid trep_box_del(GF_Box *s)\n{\n\tGF_TrackExtensionPropertiesBox *ptr = (GF_TrackExtensionPropertiesBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err trep_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TrackExtensionPropertiesBox *ptr = (GF_TrackExtensionPropertiesBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->trackID = gf_bs_read_u32(bs);\n\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *trep_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackExtensionPropertiesBox, GF_ISOM_BOX_TYPE_TREP);\n\ttmp->child_boxes = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err trep_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TrackExtensionPropertiesBox *ptr = (GF_TrackExtensionPropertiesBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->trackID);\n\treturn GF_OK;\n}\n\nGF_Err trep_box_size(GF_Box *s)\n{\n\tGF_TrackExtensionPropertiesBox *ptr = (GF_TrackExtensionPropertiesBox *)s;\n\tptr->size += 4;\n\treturn GF_OK;\n}\n\n\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM_FRAGMENTS*/\n\n\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\nvoid trun_box_del(GF_Box *s)\n{\n\tGF_TrackFragmentRunBox *ptr = (GF_TrackFragmentRunBox *)s;\n\tif (ptr == NULL) return;\n\n\tif (ptr->samples) gf_free(ptr->samples);\n\tif (ptr->cache) gf_bs_del(ptr->cache);\n\tif (ptr->sample_order) gf_free(ptr->sample_order);\n\tif (ptr->sample_refs) {\n\t\twhile (gf_list_count(ptr->sample_refs)) {\n\t\t\tGF_TrafSampleRef *sref = gf_list_pop_back(ptr->sample_refs);\n\t\t\tif (!sref->ref) gf_free(sref->data);\n\t\t\tgf_free(sref);\n\t\t}\n\t\tgf_list_del(ptr->sample_refs);\n\t}\n\tgf_free(ptr);\n}\n\n#ifdef GF_ENABLE_CTRN\n\nstatic u32 ctrn_field_size(u32 field_idx)\n{\n\tif (field_idx==3) return 4;\n\treturn field_idx;\n}\n\nu32 gf_isom_ctrn_field_size_bits(u32 field_idx)\n{\n\tif (field_idx==3) return 32;\n\treturn field_idx*8;\n}\nstatic u32 ctrn_read_flags(GF_BitStream *bs, u32 nbbits)\n{\n\tu32 val = gf_bs_read_int(bs, nbbits);\n\tif (nbbits==16) val <<= 16;\n\telse if (nbbits==8) val <<= 24;\n\treturn val;\n}\n\nstatic GF_Err ctrn_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i, count, flags, first_idx=0;\n\tBool inherit_dur, inherit_size, inherit_flags, inherit_ctso;\n\tGF_TrunEntry *ent;\n\tGF_TrackFragmentRunBox *ptr = (GF_TrackFragmentRunBox *)s;\n\tflags = ptr->flags;\n\tptr->ctrn_flags = flags;\n\tptr->flags = 0;\n\n\tptr->sample_count = gf_bs_read_u16(bs);\n\tISOM_DECREASE_SIZE(ptr, 2);\n\n\tif (flags & GF_ISOM_TRUN_DATA_OFFSET) {\n\t\tif (flags & GF_ISOM_CTRN_DATAOFFSET_16) {\n\t\t\tptr->data_offset = gf_bs_read_u16(bs);\n\t\t\tISOM_DECREASE_SIZE(ptr, 2);\n\t\t} else {\n\t\t\tptr->data_offset = gf_bs_read_u32(bs);\n\t\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\t}\n\t\tptr->flags |= GF_ISOM_TRUN_DATA_OFFSET;\n\t}\n\tif (flags & GF_ISOM_CTRN_CTSO_MULTIPLIER) {\n\t\tptr->ctso_multiplier = gf_bs_read_u16(bs);\n\t\tISOM_DECREASE_SIZE(ptr, 2);\n\t}\n\t/*no sample dur/sample_flag/size/ctso for first or following, create a pack sample */\n\tif (! (flags & 0x00FFFF00)) {\n\t\tGF_SAFEALLOC(ent, GF_TrunEntry);\n\t\tif (!ent) return GF_OUT_OF_MEM;\n\t\tent->nb_pack = ptr->sample_count;\n\t\tgf_list_add(ptr->entries, ent);\n\t\treturn GF_OK;\n\t}\n\t/*allocate all entries*/\n\tfor (i=0; i<ptr->sample_count; i++) {\n\t\tGF_SAFEALLOC(ent, GF_TrunEntry);\n\t\tif (!ent) return GF_OUT_OF_MEM;\n\t\tgf_list_add(ptr->entries, ent);\n\t}\n\t//unpack flags\n\tptr->ctrn_first_dur = (flags>>22) & 0x3;\n\tptr->ctrn_first_size = (flags>>20) & 0x3;\n\tptr->ctrn_first_sample_flags = (flags>>18) & 0x3;\n\tptr->ctrn_first_ctts = (flags>>16) & 0x3;\n\tptr->ctrn_dur = (flags>>14) & 0x3;\n\tptr->ctrn_size = (flags>>12) & 0x3;\n\tptr->ctrn_sample_flags = (flags>>10) & 0x3;\n\tptr->ctrn_ctts = (flags>>8) & 0x3;\n\n\tinherit_dur = flags & GF_ISOM_CTRN_INHERIT_DUR;\n\tinherit_size = flags & GF_ISOM_CTRN_INHERIT_SIZE;\n\tinherit_flags = flags & GF_ISOM_CTRN_INHERIT_FLAGS;\n\tinherit_ctso = flags & GF_ISOM_CTRN_INHERIT_CTSO;\n\n\tif (flags & GF_ISOM_CTRN_FIRST_SAMPLE) {\n\t\tent = gf_list_get(ptr->entries, 0);\n\t\tfirst_idx = 1;\n\t\tif (!inherit_dur && ptr->ctrn_first_dur) {\n\t\t\tent->Duration = gf_bs_read_int(bs, gf_isom_ctrn_field_size_bits(ptr->ctrn_first_dur) );\n\t\t\tISOM_DECREASE_SIZE(ptr, ctrn_field_size(ptr->ctrn_first_dur) );\n\t\t}\n\t\tif (!inherit_size && ptr->ctrn_first_size) {\n\t\t\tent->size = gf_bs_read_int(bs, gf_isom_ctrn_field_size_bits(ptr->ctrn_first_size) );\n\t\t\tISOM_DECREASE_SIZE(ptr, ctrn_field_size(ptr->ctrn_first_size) );\n\t\t}\n\t\tif (!inherit_flags && ptr->ctrn_first_sample_flags) {\n\t\t\tent->flags = ctrn_read_flags(bs, gf_isom_ctrn_field_size_bits(ptr->ctrn_first_sample_flags) );\n\t\t\tISOM_DECREASE_SIZE(ptr, ctrn_field_size(ptr->ctrn_first_sample_flags) );\n\t\t}\n\t\tif (!inherit_ctso && ptr->ctrn_first_ctts) {\n\t\t\tent->CTS_Offset = gf_bs_read_int(bs, gf_isom_ctrn_field_size_bits(ptr->ctrn_first_ctts) );\n\t\t\tISOM_DECREASE_SIZE(ptr, ctrn_field_size(ptr->ctrn_first_ctts) );\n\t\t\tif (ptr->ctso_multiplier)\n\t\t\t\tent->CTS_Offset *= (s32) ptr->ctso_multiplier;\n\t\t}\n\t}\n\tcount = ptr->sample_count - first_idx;\n\tif (!inherit_dur && ptr->ctrn_dur) {\n\t\tu32 nbbits = gf_isom_ctrn_field_size_bits(ptr->ctrn_dur);\n\t\tISOM_DECREASE_SIZE(ptr, count * nbbits / 8);\n\t\tfor (i=first_idx; i<ptr->sample_count; i++) {\n\t\t\tent = gf_list_get(ptr->entries, i);\n\t\t\tent->Duration = gf_bs_read_int(bs, nbbits);\n\t\t}\n\t}\n\tif (!inherit_size && ptr->ctrn_size) {\n\t\tu32 nbbits = gf_isom_ctrn_field_size_bits(ptr->ctrn_size);\n\t\tISOM_DECREASE_SIZE(ptr, count * nbbits / 8);\n\t\tfor (i=first_idx; i<ptr->sample_count; i++) {\n\t\t\tent = gf_list_get(ptr->entries, i);\n\t\t\tent->size = gf_bs_read_int(bs, nbbits);\n\t\t}\n\t}\n\tif (!inherit_flags && ptr->ctrn_sample_flags) {\n\t\tu32 nbbits = gf_isom_ctrn_field_size_bits(ptr->ctrn_sample_flags);\n\t\tISOM_DECREASE_SIZE(ptr, count * nbbits / 8);\n\t\tfor (i=first_idx; i<ptr->sample_count; i++) {\n\t\t\tent = gf_list_get(ptr->entries, i);\n\t\t\tent->flags = ctrn_read_flags(bs, nbbits);\n\t\t}\n\t}\n\tif (!inherit_ctso && ptr->ctrn_ctts) {\n\t\tu32 nbbits = gf_isom_ctrn_field_size_bits(ptr->ctrn_ctts);\n\t\tISOM_DECREASE_SIZE(ptr, count * nbbits / 8);\n\t\tfor (i=first_idx; i<ptr->sample_count; i++) {\n\t\t\tent = gf_list_get(ptr->entries, i);\n\t\t\tent->CTS_Offset = gf_bs_read_int(bs, nbbits);\n\t\t\tif (ptr->ctso_multiplier)\n\t\t\t\tent->CTS_Offset *= (s32) ptr->ctso_multiplier;\n\t\t}\n\t}\n\n\treturn GF_OK;\n}\n#endif\n\nGF_Err trun_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_TrackFragmentRunBox *ptr = (GF_TrackFragmentRunBox *)s;\n\n#ifdef GF_ENABLE_CTRN\n\tif (ptr->type == GF_ISOM_BOX_TYPE_CTRN) {\n\t\tptr->type = GF_ISOM_BOX_TYPE_TRUN;\n\t\tptr->use_ctrn = GF_TRUE;\n\t\treturn ctrn_box_read(s, bs);\n\t}\n#endif\n\n\t//check this is a good file\n\tif ((ptr->flags & GF_ISOM_TRUN_FIRST_FLAG) && (ptr->flags & GF_ISOM_TRUN_FLAGS))\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->sample_count = gf_bs_read_u32(bs);\n\n\t//The rest depends on the flags\n\tif (ptr->flags & GF_ISOM_TRUN_DATA_OFFSET) {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->data_offset = gf_bs_read_u32(bs);\n\t}\n\tif (ptr->flags & GF_ISOM_TRUN_FIRST_FLAG) {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->first_sample_flags = gf_bs_read_u32(bs);\n\t}\n\tif (! (ptr->flags & (GF_ISOM_TRUN_DURATION | GF_ISOM_TRUN_SIZE | GF_ISOM_TRUN_FLAGS | GF_ISOM_TRUN_CTS_OFFSET) ) ) {\n\t\tptr->samples = gf_malloc(sizeof(GF_TrunEntry));\n\t\tif (!ptr->samples) return GF_OUT_OF_MEM;\n\t\t//memset to 0 !!\n\t\tmemset(ptr->samples, 0, sizeof(GF_TrunEntry));\n\t\tptr->sample_alloc = ptr->nb_samples = 1;\n\t\tptr->samples[0].nb_pack = ptr->sample_count;\n\t} else {\n\t\t//if we get here, at least one flag (so at least 4 bytes) is set, check size\n\t\tif (ptr->sample_count * 4 > ptr->size) {\n\t\t\tISOM_DECREASE_SIZE(ptr, ptr->sample_count*4);\n\t\t}\n\t\tif ((u64)ptr->sample_count > (u64)SIZE_MAX/sizeof(GF_TrunEntry)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of samples %d in trun\\n\", ptr->sample_count));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t\tptr->samples = gf_malloc(sizeof(GF_TrunEntry) * ptr->sample_count);\n\t\tif (!ptr->samples) return GF_OUT_OF_MEM;\n\t\tptr->sample_alloc = ptr->nb_samples = ptr->sample_count;\n\t\t//memset to 0 upfront\n\t\tmemset(ptr->samples, 0, ptr->sample_count * sizeof(GF_TrunEntry));\n\n\t\t//read each entry (even though nothing may be written)\n\t\tfor (i=0; i<ptr->sample_count; i++) {\n\t\t\tu32 trun_size = 0;\n\t\t\tGF_TrunEntry *p = &ptr->samples[i];\n\n\t\t\tif (ptr->flags & GF_ISOM_TRUN_DURATION) {\n\t\t\t\tp->Duration = gf_bs_read_u32(bs);\n\t\t\t\ttrun_size += 4;\n\n\t\t\t\tif (!ptr->min_duration || (ptr->min_duration>p->Duration))\n\t\t\t\t\tptr->min_duration = p->Duration;\n\t\t\t}\n\t\t\tif (ptr->flags & GF_ISOM_TRUN_SIZE) {\n\t\t\t\tp->size = gf_bs_read_u32(bs);\n\t\t\t\ttrun_size += 4;\n\t\t\t}\n\t\t\t//SHOULDN'T BE USED IF GF_ISOM_TRUN_FIRST_FLAG IS DEFINED\n\t\t\tif (ptr->flags & GF_ISOM_TRUN_FLAGS) {\n\t\t\t\tp->flags = gf_bs_read_u32(bs);\n\t\t\t\ttrun_size += 4;\n\t\t\t}\n\t\t\tif (ptr->flags & GF_ISOM_TRUN_CTS_OFFSET) {\n\t\t\t\tif (ptr->version==0) {\n\t\t\t\t\tp->CTS_Offset = (u32) gf_bs_read_u32(bs);\n\t\t\t\t} else {\n\t\t\t\t\tp->CTS_Offset = (s32) gf_bs_read_u32(bs);\n\t\t\t\t}\n\t\t\t\ttrun_size += 4;\n\t\t\t}\n\t\t\tISOM_DECREASE_SIZE(ptr, trun_size);\n\t\t}\n\t}\n\t/*todo parse sample reorder*/\n\tif (ptr->size) {\n\t\tgf_bs_skip_bytes(bs, ptr->size);\n\t\tptr->size = 0;\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *trun_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackFragmentRunBox, GF_ISOM_BOX_TYPE_TRUN);\n\t//NO FLAGS SET BY DEFAULT\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n#ifdef GF_ENABLE_CTRN\nstatic void ctrn_write_sample_flags(GF_BitStream *bs, u32 flags, u32 field_size)\n{\n\tif (!field_size) return;\n\n\tif (field_size==8) flags = flags>>24;\n\telse if (field_size==16) flags = flags>>16;\n\tgf_bs_write_int(bs, flags, field_size);\n}\n\n\nstatic void ctrn_write_ctso(GF_TrackFragmentRunBox *ctrn, GF_BitStream *bs, u32 ctso, u32 field_size)\n{\n\tif (!field_size) return;\n\n\tif (ctrn->ctso_multiplier) {\n\t\tgf_bs_write_int(bs, ctso / ctrn->ctso_multiplier, field_size);\n\t} else {\n\t\tgf_bs_write_int(bs, ctso, field_size);\n\t}\n}\n\nGF_Err ctrn_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i, count, flags;\n\tGF_TrunEntry *ent;\n\tGF_TrackFragmentRunBox *ctrn = (GF_TrackFragmentRunBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\tflags = ctrn->flags;\n\tctrn->flags = ctrn->ctrn_flags;\n\tctrn->type = GF_ISOM_BOX_TYPE_CTRN;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tctrn->flags = flags;\n\tctrn->type = GF_ISOM_BOX_TYPE_TRUN;\n\n\tgf_bs_write_u16(bs, ctrn->sample_count);\n\tif (ctrn->flags & GF_ISOM_TRUN_DATA_OFFSET) {\n\t\tif (ctrn->ctrn_flags & GF_ISOM_CTRN_DATAOFFSET_16) {\n\t\t\tgf_bs_write_u16(bs, ctrn->data_offset);\n\t\t} else {\n\t\t\tgf_bs_write_u32(bs, ctrn->data_offset);\n\t\t}\n\t}\n\tif (ctrn->ctso_multiplier) {\n\t\tgf_bs_write_u16(bs, ctrn->ctso_multiplier);\n\t}\n\t/*we always write first sample using first flags*/\n\tent = gf_list_get(ctrn->entries, 0);\n\tgf_bs_write_int(bs, ent->Duration, gf_isom_ctrn_field_size_bits(ctrn->ctrn_first_dur) );\n\tgf_bs_write_int(bs, ent->size, gf_isom_ctrn_field_size_bits(ctrn->ctrn_first_size) );\n\tctrn_write_sample_flags(bs, ent->flags, gf_isom_ctrn_field_size_bits(ctrn->ctrn_first_sample_flags) );\n\tctrn_write_ctso(ctrn,bs, ent->CTS_Offset, gf_isom_ctrn_field_size_bits(ctrn->ctrn_first_ctts) );\n\n\tcount = gf_list_count(ctrn->entries);\n\tif (ctrn->ctrn_dur) {\n\t\tu32 nbbits = gf_isom_ctrn_field_size_bits(ctrn->ctrn_dur);\n\t\tfor (i=1; i<count; i++) {\n\t\t\tGF_TrunEntry *a_ent = gf_list_get(ctrn->entries, i);\n\t\t\tgf_bs_write_int(bs, a_ent->Duration, nbbits);\n\t\t}\n\t}\n\tif (ctrn->ctrn_size) {\n\t\tu32 nbbits = gf_isom_ctrn_field_size_bits(ctrn->ctrn_size);\n\t\tfor (i=1; i<count; i++) {\n\t\t\tGF_TrunEntry *a_ent = gf_list_get(ctrn->entries, i);\n\t\t\tgf_bs_write_int(bs, a_ent->size, nbbits);\n\t\t}\n\t}\n\tif (ctrn->ctrn_sample_flags) {\n\t\tu32 nbbits = gf_isom_ctrn_field_size_bits(ctrn->ctrn_sample_flags);\n\t\tfor (i=1; i<count; i++) {\n\t\t\tGF_TrunEntry *a_ent = gf_list_get(ctrn->entries, i);\n\t\t\tctrn_write_sample_flags(bs, a_ent->flags, nbbits);\n\t\t}\n\t}\n\tif (ctrn->ctrn_ctts) {\n\t\tu32 nbbits = gf_isom_ctrn_field_size_bits(ctrn->ctrn_ctts);\n\t\tfor (i=1; i<count; i++) {\n\t\t\tGF_TrunEntry *a_ent = gf_list_get(ctrn->entries, i);\n\t\t\tctrn_write_ctso(ctrn, bs, a_ent->CTS_Offset, nbbits);\n\t\t}\n\t}\n\n\treturn GF_OK;\n}\n#endif\n\nGF_Err trun_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_TrackFragmentRunBox *ptr = (GF_TrackFragmentRunBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\n#ifdef GF_ENABLE_CTRN\n\tif (ptr->use_ctrn)\n\t\treturn ctrn_box_write(s, bs);\n#endif\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->sample_count);\n\n\t//The rest depends on the flags\n\tif (ptr->flags & GF_ISOM_TRUN_DATA_OFFSET) {\n\t\tgf_bs_write_u32(bs, ptr->data_offset);\n\t}\n\tif (ptr->flags & GF_ISOM_TRUN_FIRST_FLAG) {\n\t\tgf_bs_write_u32(bs, ptr->first_sample_flags);\n\t}\n\n\tif (ptr->flags & (GF_ISOM_TRUN_DURATION | GF_ISOM_TRUN_SIZE | GF_ISOM_TRUN_FLAGS | GF_ISOM_TRUN_CTS_OFFSET) )  {\n\t\tfor (i=0; i<ptr->nb_samples; i++) {\n\t\t\tGF_TrunEntry *p = &ptr->samples[i];\n\n\t\t\tif (ptr->flags & GF_ISOM_TRUN_DURATION) {\n\t\t\t\tgf_bs_write_u32(bs, p->Duration);\n\t\t\t}\n\t\t\tif (ptr->flags & GF_ISOM_TRUN_SIZE) {\n\t\t\t\tgf_bs_write_u32(bs, p->size);\n\t\t\t}\n\t\t\t//SHOULDN'T BE USED IF GF_ISOM_TRUN_FIRST_FLAG IS DEFINED\n\t\t\tif (ptr->flags & GF_ISOM_TRUN_FLAGS) {\n\t\t\t\tgf_bs_write_u32(bs, p->flags);\n\t\t\t}\n\t\t\tif (ptr->flags & GF_ISOM_TRUN_CTS_OFFSET) {\n\t\t\t\tif (ptr->version==0) {\n\t\t\t\t\tgf_bs_write_u32(bs, p->CTS_Offset);\n\t\t\t\t} else {\n\t\t\t\t\tgf_bs_write_u32(bs, (u32) p->CTS_Offset);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ptr->sample_order) {\n\t\tu32 nb_bits = 8;\n\t\tif (ptr->sample_count>0xFFFFFF) nb_bits = 32;\n\t\telse if (ptr->sample_count>0xFFFF) nb_bits = 24;\n\t\telse if (ptr->sample_count>0xFF) nb_bits = 16;\n\n\t\tfor (i=0; i<ptr->sample_count; i++) {\n\t\t\tgf_bs_write_int(bs, ptr->sample_order[i], nb_bits);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n#ifdef GF_ENABLE_CTRN\nstatic u32 ctrn_sample_flags_to_index(u32 val)\n{\n\tif (!val) return 0;\n\tif (val & 0x0000FFFF)\n\t\treturn 3;\n\tif (val & 0x00FF0000)\n\t\treturn 2;\n\treturn 1;\n}\nstatic u32 ctrn_u32_to_index(u32 val)\n{\n\tif (!val) return 0;\n\tif (val<=255) return 1;\n\tif (val<=65535) return 2;\n\treturn 3;\n}\nstatic u32 ctrn_s32_to_index(s32 val)\n{\n\tif (!val) return 0;\n\tif (ABS(val)<=127) return 1;\n\tif (ABS(val)<=32767) return 2;\n\treturn 3;\n}\nstatic u32 ctrn_ctts_to_index(GF_TrackFragmentRunBox *ctrn, s32 ctts)\n{\n\tif (!(ctrn->flags & GF_ISOM_TRUN_CTS_OFFSET))\n\t\treturn 0;\n\n\tif (!ctts) return 0;\n\n\tif (ctrn->version) {\n\t\tif (ctrn->ctso_multiplier) return ctrn_s32_to_index(ctts / ctrn->ctso_multiplier);\n\t\treturn ctrn_s32_to_index(ctts);\n\t}\n\tassert(ctts>0);\n\tif (ctrn->ctso_multiplier) return ctrn_u32_to_index((u32)ctts / ctrn->ctso_multiplier);\n\treturn ctrn_s32_to_index((u32)ctts);\n}\n\nstatic GF_Err ctrn_box_size(GF_TrackFragmentRunBox *ctrn)\n{\n\tBool use_ctso_multi = GF_TRUE;\n\tu32 i, count;\n\tGF_TrunEntry *ent;\n\n\tctrn->ctrn_flags = 0;\n\tctrn->ctrn_first_dur = ctrn->ctrn_first_size = ctrn->ctrn_first_sample_flags = ctrn->ctrn_first_ctts = 0;\n\tctrn->ctrn_dur = ctrn->ctrn_size = ctrn->ctrn_sample_flags = ctrn->ctrn_ctts = 0;\n\n\tctrn->size += 2; //16 bits for sample count\n\tif (ctrn->flags & GF_ISOM_TRUN_DATA_OFFSET) {\n\t\tctrn->ctrn_flags |= GF_ISOM_TRUN_DATA_OFFSET;\n\t\tif (ABS(ctrn->data_offset) < 32767) {\n\t\t\tctrn->size += 2;\n\t\t\tctrn->ctrn_flags |= GF_ISOM_CTRN_DATAOFFSET_16;\n\t\t} else\n\t\t\tctrn->size += 4;\n\t}\n\n\tcount = gf_list_count(ctrn->entries);\n\tif (ctrn->ctso_multiplier && (ctrn->flags & GF_ISOM_TRUN_CTS_OFFSET) && (ctrn->ctso_multiplier<=0xFFFF) ) {\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_TrunEntry *a_ent = gf_list_get(ctrn->entries, i);\n\t\t\tif (a_ent->CTS_Offset % ctrn->ctso_multiplier) {\n\t\t\t\tuse_ctso_multi = GF_FALSE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tuse_ctso_multi = GF_FALSE;\n\t}\n\tif (ctrn->use_inherit) {\n\t\tuse_ctso_multi = GF_FALSE;\n\t\tctrn->ctrn_flags |= 0xB0; //duration=1,size=0,flags=1,cts=1 << 4\n\t}\n\n\tif (use_ctso_multi) {\n\t\tctrn->size += 2;\n\t\tctrn->ctrn_flags |= GF_ISOM_CTRN_CTSO_MULTIPLIER;\n\t} else {\n\t\tctrn->ctso_multiplier = 0;\n\t}\n\n\t/*we always write first sample using first flags*/\n\tent = gf_list_get(ctrn->entries, 0);\n\tctrn->ctrn_flags |= GF_ISOM_CTRN_FIRST_SAMPLE;\n\n\tif (!ctrn->use_inherit && (ctrn->flags & GF_ISOM_TRUN_DURATION)) {\n\t\tctrn->ctrn_first_dur = ctrn_u32_to_index(ent->Duration);\n\t\tif (ctrn->ctrn_first_dur) {\n\t\t\tctrn->size += ctrn_field_size(ctrn->ctrn_first_dur);\n\t\t\tctrn->ctrn_flags |= ctrn->ctrn_first_dur<<22;\n\t\t}\n\t}\n\n\tif (ctrn->flags & GF_ISOM_TRUN_SIZE) {\n\t\tctrn->ctrn_first_size = ctrn_u32_to_index(ent->size);\n\t\tif (ctrn->ctrn_first_size) {\n\t\t\tctrn->size += ctrn_field_size(ctrn->ctrn_first_size);\n\t\t\tctrn->ctrn_flags |= ctrn->ctrn_first_size<<20;\n\t\t}\n\t}\n\n\tif (!ctrn->use_inherit && (ctrn->flags & GF_ISOM_TRUN_FLAGS)) {\n\t\tctrn->ctrn_first_sample_flags = ctrn_sample_flags_to_index(ent->flags);\n\t\tif (ctrn->ctrn_first_sample_flags) {\n\t\t\tctrn->size += ctrn_field_size(ctrn->ctrn_first_sample_flags);\n\t\t\tctrn->ctrn_flags |= ctrn->ctrn_first_sample_flags<<18;\n\t\t}\n\t}\n\tif (!ctrn->use_inherit && (ctrn->flags & GF_ISOM_TRUN_CTS_OFFSET)) {\n\t\tctrn->ctrn_first_ctts = ctrn_ctts_to_index(ctrn, ent->CTS_Offset);\n\t\tif (ctrn->ctrn_first_ctts) {\n\t\t\tctrn->size += ctrn_field_size(ctrn->ctrn_first_ctts);\n\t\t\tctrn->ctrn_flags |= ctrn->ctrn_first_ctts<<16;\n\t\t}\n\t}\n\n\tfor (i=1; i<count; i++) {\n\t\tu8 field_idx;\n\t\tGF_TrunEntry *a_ent = gf_list_get(ctrn->entries, i);\n\n\t\tif (!ctrn->use_inherit && (ctrn->flags & GF_ISOM_TRUN_DURATION)) {\n\t\t\tfield_idx = ctrn_u32_to_index(a_ent->Duration);\n\t\t\tif (ctrn->ctrn_dur < field_idx)\n\t\t\t\tctrn->ctrn_dur = field_idx;\n\t\t}\n\t\tif (ctrn->flags & GF_ISOM_TRUN_SIZE) {\n\t\t\tfield_idx = ctrn_u32_to_index(a_ent->size);\n\t\t\tif (ctrn->ctrn_size < field_idx)\n\t\t\t\tctrn->ctrn_size = field_idx;\n\t\t}\n\t\tif (!ctrn->use_inherit && (ctrn->flags & GF_ISOM_TRUN_FLAGS)) {\n\t\t\tfield_idx = ctrn_sample_flags_to_index(a_ent->flags);\n\t\t\tif (ctrn->ctrn_sample_flags < field_idx)\n\t\t\t\tctrn->ctrn_sample_flags = field_idx;\n\t\t}\n\t\tif (!ctrn->use_inherit) {\n\t\t\tfield_idx = ctrn_ctts_to_index(ctrn, a_ent->CTS_Offset);\n\t\t\tif (ctrn->ctrn_ctts < field_idx)\n\t\t\t\tctrn->ctrn_ctts = field_idx;\n\t\t}\n\t}\n\tcount-=1;\n\tif (ctrn->ctrn_dur) {\n\t\tctrn->size += count * ctrn_field_size(ctrn->ctrn_dur);\n\t\tctrn->ctrn_flags |= ctrn->ctrn_dur<<14;\n\t}\n\tif (ctrn->ctrn_size) {\n\t\tctrn->size += count * ctrn_field_size(ctrn->ctrn_size);\n\t\tctrn->ctrn_flags |= ctrn->ctrn_size<<12;\n\t}\n\tif (ctrn->ctrn_sample_flags) {\n\t\tctrn->size += count * ctrn_field_size(ctrn->ctrn_sample_flags);\n\t\tctrn->ctrn_flags |= ctrn->ctrn_sample_flags<<10;\n\t}\n\tif (ctrn->ctrn_ctts) {\n\t\tctrn->size += count * ctrn_field_size(ctrn->ctrn_ctts);\n\t\tctrn->ctrn_flags |= ctrn->ctrn_ctts<<8;\n\t}\n\treturn GF_OK;\n}\n#endif\n\nGF_Err trun_box_size(GF_Box *s)\n{\n\tGF_TrackFragmentRunBox *ptr = (GF_TrackFragmentRunBox *)s;\n\n#ifdef GF_ENABLE_CTRN\n\tif (ptr->use_ctrn)\n\t\treturn ctrn_box_size(ptr);\n#endif\n\n\tptr->size += 4;\n\t//The rest depends on the flags\n\tif (ptr->flags & GF_ISOM_TRUN_DATA_OFFSET) ptr->size += 4;\n\tif (ptr->flags & GF_ISOM_TRUN_FIRST_FLAG) ptr->size += 4;\n\n\tif (ptr->sample_order) {\n\t\tu32 nb_bytes = 1;\n\t\tif (ptr->sample_count>0xFFFFFF) nb_bytes = 4;\n\t\telse if (ptr->sample_count>0xFFFF) nb_bytes = 3;\n\t\telse if (ptr->sample_count>0xFF) nb_bytes = 2;\n\t\tptr->size += ptr->sample_count*nb_bytes;\n\t}\n\n\tif (! (ptr->flags & (GF_ISOM_TRUN_DURATION | GF_ISOM_TRUN_SIZE | GF_ISOM_TRUN_FLAGS | GF_ISOM_TRUN_CTS_OFFSET) ) ) {\n\t\treturn GF_OK;\n\t}\n\n\t//if nothing to do, this will be skipped automatically\n\tif (ptr->flags & GF_ISOM_TRUN_DURATION) ptr->size += 4*ptr->nb_samples;\n\tif (ptr->flags & GF_ISOM_TRUN_SIZE) ptr->size += 4*ptr->nb_samples;\n\t//SHOULDN'T BE USED IF GF_ISOM_TRUN_FIRST_FLAG IS DEFINED\n\tif (ptr->flags & GF_ISOM_TRUN_FLAGS) ptr->size += 4*ptr->nb_samples;\n\tif (ptr->flags & GF_ISOM_TRUN_CTS_OFFSET) ptr->size += 4*ptr->nb_samples;\n\n\treturn GF_OK;\n}\n\n\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM_FRAGMENTS*/\n\n\nvoid tsro_box_del(GF_Box *s)\n{\n\tGF_TimeOffHintEntryBox *tsro = (GF_TimeOffHintEntryBox *)s;\n\tgf_free(tsro);\n}\n\nGF_Err tsro_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TimeOffHintEntryBox *ptr = (GF_TimeOffHintEntryBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->TimeOffset = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\nGF_Box *tsro_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TimeOffHintEntryBox, GF_ISOM_BOX_TYPE_TSRO);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err tsro_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TimeOffHintEntryBox *ptr = (GF_TimeOffHintEntryBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->TimeOffset);\n\treturn GF_OK;\n}\n\nGF_Err tsro_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid udta_box_del(GF_Box *s)\n{\n\tu32 i;\n\tGF_UserDataMap *map;\n\tGF_UserDataBox *ptr = (GF_UserDataBox *)s;\n\tif (ptr == NULL) return;\n\ti=0;\n\twhile ((map = (GF_UserDataMap *)gf_list_enum(ptr->recordList, &i))) {\n\t\tgf_isom_box_array_del(map->boxes);\n\t\tgf_free(map);\n\t}\n\tgf_list_del(ptr->recordList);\n\tgf_free(ptr);\n}\n\nGF_UserDataMap *udta_getEntry(GF_UserDataBox *ptr, u32 box_type, bin128 *uuid)\n{\n\tu32 i;\n\tGF_UserDataMap *map;\n\tif (ptr == NULL) return NULL;\n\ti=0;\n\twhile ((map = (GF_UserDataMap *)gf_list_enum(ptr->recordList, &i))) {\n\t\tif (map->boxType == box_type) {\n\t\t\tif ((box_type != GF_ISOM_BOX_TYPE_UUID) || !uuid) return map;\n\t\t\tif (!memcmp(map->uuid, *uuid, 16)) return map;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nGF_Err udta_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_Err e;\n\tu32 box_type;\n\tGF_UserDataMap *map;\n\tGF_UserDataBox *ptr = (GF_UserDataBox *)s;\n\tif (!ptr) return GF_BAD_PARAM;\n\tif (!a) return GF_OK;\n\n\t//detach from parent list if any\n\tgf_list_del_item(ptr->child_boxes, a);\n\n\t/* for unknown udta boxes, we reference them by their original box type */\n\tbox_type = a->type;\n\tif (box_type == GF_ISOM_BOX_TYPE_UNKNOWN) {\n\t\tGF_UnknownBox* unkn = (GF_UnknownBox *)a;\n\t\tbox_type = unkn->original_4cc;\n\t}\n\n\tmap = udta_getEntry(ptr, box_type, (a->type==GF_ISOM_BOX_TYPE_UUID) ? & ((GF_UUIDBox *)a)->uuid : NULL);\n\tif (map == NULL) {\n\t\tif (is_rem) return GF_OK;\n\n\t\tmap = (GF_UserDataMap *) gf_malloc(sizeof(GF_UserDataMap));\n\t\tif (map == NULL) return GF_OUT_OF_MEM;\n\t\tmemset(map, 0, sizeof(GF_UserDataMap));\n\n\t\tmap->boxType = box_type;\n\t\tif (a->type == GF_ISOM_BOX_TYPE_UUID)\n\t\t\tmemcpy(map->uuid, ((GF_UUIDBox *)a)->uuid, 16);\n\t\tmap->boxes = gf_list_new();\n\t\tif (!map->boxes) {\n\t\t\tgf_free(map);\n\t\t\treturn GF_OUT_OF_MEM;\n\t\t}\n\t\te = gf_list_add(ptr->recordList, map);\n\t\tif (e) return e;\n\t}\n\tif (is_rem) {\n\t\tgf_list_del_item(map->boxes, a);\n\t\treturn GF_OK;\n\t}\n\tu32 i, count = gf_list_count(map->boxes);\n\tfor (i=0; i<count; i++) {\n\t\tGF_Box *b = gf_list_get(map->boxes, i);\n\t\tu32 btype = b->type;\n\t\tif (b->type==GF_ISOM_BOX_TYPE_UNKNOWN) btype = ((GF_UnknownBox*)b)->original_4cc;\n\t\tif (btype != box_type) continue;\n\t\tif (box_type == GF_ISOM_BOX_TYPE_UUID) {\n\t\t\tif (memcmp( ((GF_UUIDBox *)a)->uuid, ((GF_UUIDBox *)b)->uuid, 16)) continue;\n\t\t}\n\t\tgf_isom_box_del(b);\n\t\tgf_list_rem(map->boxes, i);\n\t\tbreak;\n\t}\n\treturn gf_list_add(map->boxes, a);\n}\n\n\nGF_Err udta_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e = gf_isom_box_array_read(s, bs);\n\tif (e) return e;\n\tif (s->size==4) {\n\t\tu32 val = gf_bs_read_u32(bs);\n\t\ts->size = 0;\n\t\tif (val) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] udta has 4 remaining bytes set to %08X but they should be 0\\n\", val));\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *udta_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_UserDataBox, GF_ISOM_BOX_TYPE_UDTA);\n\ttmp->recordList = gf_list_new();\n\tif (!tmp->recordList) {\n\t\tgf_free(tmp);\n\t\treturn NULL;\n\t}\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err udta_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_UserDataMap *map;\n\tGF_UserDataBox *ptr = (GF_UserDataBox *)s;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\ti=0;\n\twhile ((map = (GF_UserDataMap *)gf_list_enum(ptr->recordList, &i))) {\n\t\t//warning: here we are not passing the actual \"parent\" of the list\n\t\t//but the UDTA box. The parent itself is not an box, we don't care about it\n\t\te = gf_isom_box_array_write(s, map->boxes, bs);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err udta_box_size(GF_Box *s)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_UserDataMap *map;\n\tGF_UserDataBox *ptr = (GF_UserDataBox *)s;\n\n\ti=0;\n\twhile ((map = (GF_UserDataMap *)gf_list_enum(ptr->recordList, &i))) {\n\t\t//warning: here we are not passing the actual \"parent\" of the list\n\t\t//but the UDTA box. The parent itself is not an box, we don't care about it\n\t\te = gf_isom_box_array_size(s, map->boxes);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid vmhd_box_del(GF_Box *s)\n{\n\tGF_VideoMediaHeaderBox *ptr = (GF_VideoMediaHeaderBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err vmhd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_VideoMediaHeaderBox *ptr = (GF_VideoMediaHeaderBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 8);\n\tptr->reserved = gf_bs_read_u64(bs);\n\treturn GF_OK;\n}\n\nGF_Box *vmhd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_VideoMediaHeaderBox, GF_ISOM_BOX_TYPE_VMHD);\n\ttmp->flags = 1;\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err vmhd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_VideoMediaHeaderBox *ptr = (GF_VideoMediaHeaderBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u64(bs, ptr->reserved);\n\treturn GF_OK;\n}\n\nGF_Err vmhd_box_size(GF_Box *s)\n{\n\tGF_VideoMediaHeaderBox *ptr = (GF_VideoMediaHeaderBox *)s;\n\tptr->size += 8;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid void_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\n\nGF_Err void_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tif (s->size) return GF_ISOM_INVALID_FILE;\n\treturn GF_OK;\n}\n\nGF_Box *void_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_Box, GF_ISOM_BOX_TYPE_VOID);\n\treturn tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err void_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tgf_bs_write_u32(bs, 0);\n\treturn GF_OK;\n}\n\nGF_Err void_box_size(GF_Box *s)\n{\n\ts->size = 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Box *pdin_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ProgressiveDownloadBox, GF_ISOM_BOX_TYPE_PDIN);\n\treturn (GF_Box *)tmp;\n}\n\n\nvoid pdin_box_del(GF_Box *s)\n{\n\tGF_ProgressiveDownloadBox *ptr = (GF_ProgressiveDownloadBox*)s;\n\tif (ptr == NULL) return;\n\tif (ptr->rates) gf_free(ptr->rates);\n\tif (ptr->times) gf_free(ptr->times);\n\tgf_free(ptr);\n}\n\n\nGF_Err pdin_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_ProgressiveDownloadBox *ptr = (GF_ProgressiveDownloadBox*)s;\n\n\tptr->count = (u32) (ptr->size) / 8;\n\tptr->rates = (u32*)gf_malloc(sizeof(u32)*ptr->count);\n\tif (!ptr->rates) return GF_OUT_OF_MEM;\n\tptr->times = (u32*)gf_malloc(sizeof(u32)*ptr->count);\n\tif (!ptr->times) return GF_OUT_OF_MEM;\n\tfor (i=0; i<ptr->count; i++) {\n\t\tptr->rates[i] = gf_bs_read_u32(bs);\n\t\tptr->times[i] = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err pdin_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_ProgressiveDownloadBox *ptr = (GF_ProgressiveDownloadBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tfor (i=0; i<ptr->count; i++) {\n\t\tgf_bs_write_u32(bs, ptr->rates[i]);\n\t\tgf_bs_write_u32(bs, ptr->times[i]);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err pdin_box_size(GF_Box *s)\n{\n\tGF_ProgressiveDownloadBox *ptr = (GF_ProgressiveDownloadBox *)s;\n\tptr->size += 8*ptr->count;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n\nGF_Box *sdtp_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleDependencyTypeBox, GF_ISOM_BOX_TYPE_SDTP);\n\treturn (GF_Box *)tmp;\n}\n\n\nvoid sdtp_box_del(GF_Box *s)\n{\n\tGF_SampleDependencyTypeBox *ptr = (GF_SampleDependencyTypeBox*)s;\n\tif (ptr == NULL) return;\n\tif (ptr->sample_info) gf_free(ptr->sample_info);\n\tgf_free(ptr);\n}\n\n\nGF_Err sdtp_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_SampleDependencyTypeBox *ptr = (GF_SampleDependencyTypeBox*)s;\n\n\t/*out-of-order sdtp, assume no padding at the end*/\n\tif (!ptr->sampleCount) ptr->sampleCount = (u32) ptr->size;\n\telse if (ptr->sampleCount > (u32) ptr->size) return GF_ISOM_INVALID_FILE;\n\n\tptr->sample_info = (u8 *) gf_malloc(sizeof(u8)*ptr->sampleCount);\n\tif (!ptr->sample_info) return GF_OUT_OF_MEM;\n\tptr->sample_alloc = ptr->sampleCount;\n\tgf_bs_read_data(bs, (char*)ptr->sample_info, ptr->sampleCount);\n\tISOM_DECREASE_SIZE(ptr, ptr->sampleCount);\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err sdtp_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SampleDependencyTypeBox *ptr = (GF_SampleDependencyTypeBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_data(bs, (char*)ptr->sample_info, ptr->sampleCount);\n\treturn GF_OK;\n}\n\nGF_Err sdtp_box_size(GF_Box *s)\n{\n\tGF_SampleDependencyTypeBox *ptr = (GF_SampleDependencyTypeBox *)s;\n\tptr->size += ptr->sampleCount;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *pasp_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_PixelAspectRatioBox, GF_ISOM_BOX_TYPE_PASP);\n\treturn (GF_Box *)tmp;\n}\n\n\nvoid pasp_box_del(GF_Box *s)\n{\n\tGF_PixelAspectRatioBox *ptr = (GF_PixelAspectRatioBox*)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err pasp_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_PixelAspectRatioBox *ptr = (GF_PixelAspectRatioBox*)s;\n\tISOM_DECREASE_SIZE(ptr, 8);\n\tptr->hSpacing = gf_bs_read_u32(bs);\n\tptr->vSpacing = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err pasp_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_PixelAspectRatioBox *ptr = (GF_PixelAspectRatioBox *)s;\n\tGF_Err e = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->hSpacing);\n\tgf_bs_write_u32(bs, ptr->vSpacing);\n\treturn GF_OK;\n}\n\nGF_Err pasp_box_size(GF_Box *s)\n{\n\ts->size += 8;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Box *clap_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_CleanApertureBox, GF_ISOM_BOX_TYPE_CLAP);\n\treturn (GF_Box *)tmp;\n}\n\n\nvoid clap_box_del(GF_Box *s)\n{\n\tGF_CleanApertureBox *ptr = (GF_CleanApertureBox*)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err clap_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_CleanApertureBox *ptr = (GF_CleanApertureBox*)s;\n\tISOM_DECREASE_SIZE(ptr, 32);\n\tptr->cleanApertureWidthN = gf_bs_read_u32(bs);\n\tptr->cleanApertureWidthD = gf_bs_read_u32(bs);\n\tptr->cleanApertureHeightN = gf_bs_read_u32(bs);\n\tptr->cleanApertureHeightD = gf_bs_read_u32(bs);\n\tptr->horizOffN = (s32) gf_bs_read_u32(bs);\n\tptr->horizOffD = gf_bs_read_u32(bs);\n\tptr->vertOffN = (s32) gf_bs_read_u32(bs);\n\tptr->vertOffD = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err clap_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_CleanApertureBox *ptr = (GF_CleanApertureBox *)s;\n\tGF_Err e = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->cleanApertureWidthN);\n\tgf_bs_write_u32(bs, ptr->cleanApertureWidthD);\n\tgf_bs_write_u32(bs, ptr->cleanApertureHeightN);\n\tgf_bs_write_u32(bs, ptr->cleanApertureHeightD);\n\tgf_bs_write_u32(bs, (u32) ptr->horizOffN);\n\tgf_bs_write_u32(bs, ptr->horizOffD);\n\tgf_bs_write_u32(bs, (u32) ptr->vertOffN);\n\tgf_bs_write_u32(bs, ptr->vertOffD);\n\treturn GF_OK;\n}\n\nGF_Err clap_box_size(GF_Box *s)\n{\n\ts->size += 32;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n\nGF_Box *metx_box_new()\n{\n\t//type is overridden by the box constructor\n\tISOM_DECL_BOX_ALLOC(GF_MetaDataSampleEntryBox, GF_ISOM_BOX_TYPE_METX);\n\tgf_isom_sample_entry_init((GF_SampleEntryBox*)tmp);\n\treturn (GF_Box *)tmp;\n}\n\n\nvoid metx_box_del(GF_Box *s)\n{\n\tGF_MetaDataSampleEntryBox *ptr = (GF_MetaDataSampleEntryBox*)s;\n\tif (ptr == NULL) return;\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)s);\n\n\tif (ptr->content_encoding) gf_free(ptr->content_encoding);\n\tif (ptr->xml_namespace) gf_free(ptr->xml_namespace);\n\tif (ptr->xml_schema_loc) gf_free(ptr->xml_schema_loc);\n\tif (ptr->mime_type) gf_free(ptr->mime_type);\n\tgf_free(ptr);\n}\n\n\nGF_Err metx_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_MetaDataSampleEntryBox *ptr = (GF_MetaDataSampleEntryBox *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_TXTC:\n\t\t//we allow the config box on metx\n\t\tBOX_FIELD_ASSIGN(config, GF_TextConfigBox)\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err metx_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 size, i;\n\tGF_Err e;\n\tchar *str;\n\tGF_MetaDataSampleEntryBox *ptr = (GF_MetaDataSampleEntryBox*)s;\n\n\te = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)ptr, bs);\n\tif (e) return e;\n\tISOM_DECREASE_SIZE(ptr, 8);\n\n\tif (ptr->size > (u64)SIZE_MAX) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid size \"LLU\" in metx\\n\", ptr->size));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tsize = (u32) ptr->size;\n\tstr = gf_malloc(sizeof(char)*size);\n\tif (!str) return GF_OUT_OF_MEM;\n\ti=0;\n\n\twhile (size) {\n\t\tstr[i] = gf_bs_read_u8(bs);\n\t\tsize--;\n\t\tif (!str[i]) {\n\t\t\ti++;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\tif (!size && i>1 && str[i-1]) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] metx read invalid string\\n\"));\n\t\tgf_free(str);\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tif (i>1) {\n\t\tif (ptr->type==GF_ISOM_BOX_TYPE_STPP) {\n\t\t\tptr->xml_namespace = gf_strdup(str);\n\t\t} else {\n\t\t\tptr->content_encoding = gf_strdup(str);\n\t\t}\n\t}\n\n\ti=0;\n\twhile (size) {\n\t\tstr[i] = gf_bs_read_u8(bs);\n\t\tsize--;\n\t\tif (!str[i]) {\n\t\t\ti++;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\tif (!size && i>1 && str[i-1]) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] metx read invalid string\\n\"));\n\t\tgf_free(str);\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tif ((ptr->type==GF_ISOM_BOX_TYPE_METX) || (ptr->type==GF_ISOM_BOX_TYPE_STPP)) {\n\t\tif (i>1) {\n\t\t\tif (ptr->type==GF_ISOM_BOX_TYPE_STPP) {\n\t\t\t\tptr->xml_schema_loc = gf_strdup(str);\n\t\t\t} else {\n\t\t\t\tptr->xml_namespace = gf_strdup(str);\n\t\t\t}\n\t\t}\n\n\t\ti=0;\n\t\twhile (size) {\n\t\t\tstr[i] = gf_bs_read_u8(bs);\n\t\t\tsize--;\n\t\t\tif (!str[i]) {\n\t\t\t\ti++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tif (!size && i>1 && str[i-1]) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] metx read invalid string\\n\"));\n\t\t\tgf_free(str);\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t\tif (i>1) {\n\t\t\tif (ptr->type==GF_ISOM_BOX_TYPE_STPP) {\n\t\t\t\tptr->mime_type = gf_strdup(str);\n\t\t\t} else {\n\t\t\t\tptr->xml_schema_loc = gf_strdup(str);\n\t\t\t}\n\t\t}\n\t}\n\t//mett, sbtt, stxt, stpp\n\telse {\n\t\tif (i>1) ptr->mime_type = gf_strdup(str);\n\t}\n\tptr->size = size;\n\tgf_free(str);\n\treturn gf_isom_box_array_read(s, bs);\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err metx_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MetaDataSampleEntryBox *ptr = (GF_MetaDataSampleEntryBox *)s;\n\tGF_Err e = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_data(bs, ptr->reserved, 6);\n\tgf_bs_write_u16(bs, ptr->dataReferenceIndex);\n\n\tif (ptr->type!=GF_ISOM_BOX_TYPE_STPP) {\n\t\tif (ptr->content_encoding)\n\t\t\tgf_bs_write_data(bs, ptr->content_encoding, (u32) strlen(ptr->content_encoding));\n\t\tgf_bs_write_u8(bs, 0);\n\t}\n\n\tif ((ptr->type==GF_ISOM_BOX_TYPE_METX) || (ptr->type==GF_ISOM_BOX_TYPE_STPP)) {\n\t\tif (ptr->xml_namespace)\n\t\t\tgf_bs_write_data(bs, ptr->xml_namespace, (u32) strlen(ptr->xml_namespace));\n\n\t\tgf_bs_write_u8(bs, 0);\n\n\t\tif (ptr->xml_schema_loc)\n\t\t\tgf_bs_write_data(bs, ptr->xml_schema_loc, (u32) strlen(ptr->xml_schema_loc));\n\t\tgf_bs_write_u8(bs, 0);\n\n\t\tif (ptr->type==GF_ISOM_BOX_TYPE_STPP) {\n\t\t\tif (ptr->mime_type)\n\t\t\t\tgf_bs_write_data(bs, ptr->mime_type, (u32) strlen(ptr->mime_type));\n\n\t\t\tgf_bs_write_u8(bs, 0);\n\t\t}\n\t}\n\t//mett, sbtt, stxt\n\telse {\n\t\tif (ptr->mime_type)\n\t\t\tgf_bs_write_data(bs, ptr->mime_type, (u32) strlen(ptr->mime_type));\n\n\t\tgf_bs_write_u8(bs, 0);\n\t}\n\n\treturn GF_OK;\n}\n\nGF_Err metx_box_size(GF_Box *s)\n{\n\tGF_MetaDataSampleEntryBox *ptr = (GF_MetaDataSampleEntryBox *)s;\n\tptr->size += 8;\n\n\tif (ptr->type!=GF_ISOM_BOX_TYPE_STPP) {\n\t\tif (ptr->content_encoding)\n\t\t\tptr->size += strlen(ptr->content_encoding);\n\t\tptr->size++;\n\t}\n\n\tif ((ptr->type==GF_ISOM_BOX_TYPE_METX) || (ptr->type==GF_ISOM_BOX_TYPE_STPP)) {\n\n\t\tif (ptr->xml_namespace)\n\t\t\tptr->size += strlen(ptr->xml_namespace);\n\t\tptr->size++;\n\n\t\tif (ptr->xml_schema_loc)\n\t\t\tptr->size += strlen(ptr->xml_schema_loc);\n\t\tptr->size++;\n\n\t\tif (ptr->type==GF_ISOM_BOX_TYPE_STPP) {\n\t\t\tif (ptr->mime_type)\n\t\t\t\tptr->size += strlen(ptr->mime_type);\n\t\t\tptr->size++;\n\t\t}\n\n\t}\n\t//mett, sbtt, stxt\n\telse {\n\t\tif (ptr->mime_type)\n\t\t\tptr->size += strlen(ptr->mime_type);\n\t\tptr->size++;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/* SimpleTextSampleEntry */\nGF_Box *txtc_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TextConfigBox, GF_ISOM_BOX_TYPE_TXTC);\n\treturn (GF_Box *)tmp;\n}\n\n\nvoid txtc_box_del(GF_Box *s)\n{\n\tGF_TextConfigBox *ptr = (GF_TextConfigBox*)s;\n\tif (ptr == NULL) return;\n\n\tif (ptr->config) gf_free(ptr->config);\n\tgf_free(ptr);\n}\n\nGF_Err txtc_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TextConfigBox *ptr = (GF_TextConfigBox*)s;\n\tif ((u32)ptr->size >= (u32)0xFFFFFFFF) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid size %llu in txtc box\\n\", ptr->size));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tptr->config = (char *)gf_malloc(sizeof(char)*((u32) ptr->size+1));\n\tif (!ptr->config) return GF_OUT_OF_MEM;\n\tgf_bs_read_data(bs, ptr->config, (u32) ptr->size);\n\tptr->config[ptr->size] = 0;\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err txtc_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TextConfigBox *ptr = (GF_TextConfigBox *)s;\n\tGF_Err e = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tif (ptr->config)\n\t\tgf_bs_write_data(bs, ptr->config, (u32) strlen(ptr->config));\n\tgf_bs_write_u8(bs, 0);\n\treturn GF_OK;\n}\n\nGF_Err txtc_box_size(GF_Box *s)\n{\n\tGF_TextConfigBox *ptr = (GF_TextConfigBox *)s;\n\tif (ptr->config)\n\t\tptr->size += strlen(ptr->config);\n\tptr->size++;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *dac3_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_AC3ConfigBox, GF_ISOM_BOX_TYPE_DAC3);\n\treturn (GF_Box *)tmp;\n}\n\nGF_Box *dec3_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_AC3ConfigBox, GF_ISOM_BOX_TYPE_DAC3);\n\ttmp->cfg.is_ec3 = 1;\n\treturn (GF_Box *)tmp;\n}\n\nvoid dac3_box_del(GF_Box *s)\n{\n\tGF_AC3ConfigBox *ptr = (GF_AC3ConfigBox *)s;\n\tgf_free(ptr);\n}\n\n\nGF_Err dac3_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu64 pos;\n\tGF_AC3ConfigBox *ptr = (GF_AC3ConfigBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\tpos = gf_bs_get_position(bs);\n\te = gf_odf_ac3_config_parse_bs(bs, ptr->cfg.is_ec3, &ptr->cfg);\n\tif (e) return e;\n\tpos = gf_bs_get_position(bs) - pos;\n\tISOM_DECREASE_SIZE(ptr, pos);\n\n\tif (ptr->size>=2) {\n\t\tptr->size-=2;\n\t\tgf_bs_read_int(bs, 7);\n\t\tptr->cfg.atmos_ec3_ext = gf_bs_read_int(bs, 1);\n\t\tptr->cfg.complexity_index_type = gf_bs_read_u8(bs);\n\t}\n\t//the rest is reserved\n\tgf_bs_skip_bytes(bs, ptr->size);\n\tptr->size = 0;\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err dac3_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_AC3ConfigBox *ptr = (GF_AC3ConfigBox *)s;\n\n\tif (ptr->cfg.is_ec3) s->type = GF_ISOM_BOX_TYPE_DEC3;\n\te = gf_isom_box_write_header(s, bs);\n\tif (ptr->cfg.is_ec3) s->type = GF_ISOM_BOX_TYPE_DAC3;\n\tif (e) return e;\n\n\te = gf_odf_ac3_cfg_write_bs(&ptr->cfg, bs);\n\tif (e) return e;\n\n\tif (ptr->cfg.atmos_ec3_ext || ptr->cfg.complexity_index_type) {\n\t\tgf_bs_write_int(bs, 0, 7);\n\t\tgf_bs_write_int(bs, ptr->cfg.atmos_ec3_ext, 1);\n\t\tgf_bs_write_u8(bs, ptr->cfg.complexity_index_type);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err dac3_box_size(GF_Box *s)\n{\n\tGF_AC3ConfigBox *ptr = (GF_AC3ConfigBox *)s;\n\n\tif (ptr->cfg.is_ec3) {\n\t\tu32 i;\n\t\ts->size += 2;\n\t\tfor (i=0; i<ptr->cfg.nb_streams; i++) {\n\t\t\ts->size += 3;\n\t\t\tif (ptr->cfg.streams[i].nb_dep_sub)\n\t\t\t\ts->size += 1;\n\t\t}\n\t} else {\n\t\ts->size += 3;\n\t}\n\tif (ptr->cfg.atmos_ec3_ext || ptr->cfg.complexity_index_type) {\n\t\ts->size += 2;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid lsrc_box_del(GF_Box *s)\n{\n\tGF_LASERConfigurationBox *ptr = (GF_LASERConfigurationBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->hdr) gf_free(ptr->hdr);\n\tgf_free(ptr);\n}\n\n\nGF_Err lsrc_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_LASERConfigurationBox *ptr = (GF_LASERConfigurationBox *)s;\n\tptr->hdr_size = (u32) ptr->size;\n\tptr->hdr = gf_malloc(sizeof(char)*ptr->hdr_size);\n\tif (!ptr->hdr) return GF_OUT_OF_MEM;\n\tgf_bs_read_data(bs, ptr->hdr, ptr->hdr_size);\n\treturn GF_OK;\n}\n\nGF_Box *lsrc_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_LASERConfigurationBox, GF_ISOM_BOX_TYPE_LSRC);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err lsrc_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_LASERConfigurationBox *ptr = (GF_LASERConfigurationBox *)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_data(bs, ptr->hdr, ptr->hdr_size);\n\treturn GF_OK;\n}\n\nGF_Err lsrc_box_size(GF_Box *s)\n{\n\tGF_LASERConfigurationBox *ptr = (GF_LASERConfigurationBox *)s;\n\tptr->size += ptr->hdr_size;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid lsr1_box_del(GF_Box *s)\n{\n\tGF_LASeRSampleEntryBox *ptr = (GF_LASeRSampleEntryBox *)s;\n\tif (ptr == NULL) return;\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)s);\n\tif (ptr->slc) gf_odf_desc_del((GF_Descriptor *)ptr->slc);\n\tgf_free(ptr);\n}\n\nGF_Err lsr1_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_LASeRSampleEntryBox *ptr = (GF_LASeRSampleEntryBox *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_LSRC:\n\t\tBOX_FIELD_ASSIGN(lsr_config, GF_LASERConfigurationBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_M4DS:\n\t\tBOX_FIELD_ASSIGN(descr, GF_MPEG4ExtensionDescriptorsBox)\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err lsr1_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_LASeRSampleEntryBox *ptr = (GF_LASeRSampleEntryBox*)s;\n\n\te = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)ptr, bs);\n\tif (e) return e;\n\n\tISOM_DECREASE_SIZE(ptr, 8);\n\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *lsr1_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_LASeRSampleEntryBox, GF_ISOM_BOX_TYPE_LSR1);\n\tgf_isom_sample_entry_init((GF_SampleEntryBox*)tmp);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err lsr1_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_LASeRSampleEntryBox *ptr = (GF_LASeRSampleEntryBox *)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_data(bs, ptr->reserved, 6);\n\tgf_bs_write_u16(bs, ptr->dataReferenceIndex);\n\treturn GF_OK;\n}\n\nGF_Err lsr1_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_LASeRSampleEntryBox *ptr = (GF_LASeRSampleEntryBox *)s;\n\ts->size += 8;\n\tgf_isom_check_position(s, (GF_Box *)ptr->lsr_config, &pos);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid sidx_box_del(GF_Box *s)\n{\n\tGF_SegmentIndexBox *ptr = (GF_SegmentIndexBox *) s;\n\tif (ptr == NULL) return;\n\tif (ptr->refs) gf_free(ptr->refs);\n\tgf_free(ptr);\n}\n\nGF_Err sidx_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_SegmentIndexBox *ptr = (GF_SegmentIndexBox*) s;\n\n\tISOM_DECREASE_SIZE(ptr, 8);\n\tptr->reference_ID = gf_bs_read_u32(bs);\n\tptr->timescale = gf_bs_read_u32(bs);\n\n\tif (ptr->version==0) {\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\tptr->earliest_presentation_time = gf_bs_read_u32(bs);\n\t\tptr->first_offset = gf_bs_read_u32(bs);\n\t} else {\n\t\tISOM_DECREASE_SIZE(ptr, 16);\n\t\tptr->earliest_presentation_time = gf_bs_read_u64(bs);\n\t\tptr->first_offset = gf_bs_read_u64(bs);\n\t}\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tgf_bs_read_u16(bs); /* reserved */\n\tptr->nb_refs = gf_bs_read_u16(bs);\n\n\tptr->refs = gf_malloc(sizeof(GF_SIDXReference)*ptr->nb_refs);\n\tif (!ptr->refs) return GF_OUT_OF_MEM;\n\tfor (i=0; i<ptr->nb_refs; i++) {\n\t\tptr->refs[i].reference_type = gf_bs_read_int(bs, 1);\n\t\tptr->refs[i].reference_size = gf_bs_read_int(bs, 31);\n\t\tptr->refs[i].subsegment_duration = gf_bs_read_u32(bs);\n\t\tptr->refs[i].starts_with_SAP = gf_bs_read_int(bs, 1);\n\t\tptr->refs[i].SAP_type = gf_bs_read_int(bs, 3);\n\t\tptr->refs[i].SAP_delta_time = gf_bs_read_int(bs, 28);\n\n\t\tISOM_DECREASE_SIZE(ptr, 12);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *sidx_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SegmentIndexBox, GF_ISOM_BOX_TYPE_SIDX);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err sidx_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_SegmentIndexBox *ptr = (GF_SegmentIndexBox*) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->reference_ID);\n\tgf_bs_write_u32(bs, ptr->timescale);\n\tif (ptr->version==0) {\n\t\tgf_bs_write_u32(bs, (u32) ptr->earliest_presentation_time);\n\t\tgf_bs_write_u32(bs, (u32) ptr->first_offset);\n\t} else {\n\t\tgf_bs_write_u64(bs, ptr->earliest_presentation_time);\n\t\tgf_bs_write_u64(bs, ptr->first_offset);\n\t}\n\tgf_bs_write_u16(bs, 0);\n\tgf_bs_write_u16(bs, ptr->nb_refs);\n\tfor (i=0; i<ptr->nb_refs; i++ ) {\n\t\tgf_bs_write_int(bs, ptr->refs[i].reference_type, 1);\n\t\tgf_bs_write_int(bs, ptr->refs[i].reference_size, 31);\n\t\tgf_bs_write_u32(bs, ptr->refs[i].subsegment_duration);\n\t\tgf_bs_write_int(bs, ptr->refs[i].starts_with_SAP, 1);\n\t\tgf_bs_write_int(bs, ptr->refs[i].SAP_type, 3);\n\t\tgf_bs_write_int(bs, ptr->refs[i].SAP_delta_time, 28);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err sidx_box_size(GF_Box *s)\n{\n\tGF_SegmentIndexBox *ptr = (GF_SegmentIndexBox*) s;\n\n\tptr->size += 12;\n\tif (ptr->version==0) {\n\t\tptr->size += 8;\n\t} else {\n\t\tptr->size += 16;\n\t}\n\tptr->size += ptr->nb_refs * 12;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid ssix_box_del(GF_Box *s)\n{\n\tu32 i;\n\tGF_SubsegmentIndexBox *ptr = (GF_SubsegmentIndexBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->subsegments) {\n\t\tfor (i = 0; i < ptr->subsegment_alloc; i++) {\n\t\t\tGF_SubsegmentInfo *subsegment = &ptr->subsegments[i];\n\t\t\tif (subsegment->ranges) gf_free(subsegment->ranges);\n\t\t}\n\t\tgf_free(ptr->subsegments);\n\t}\n\tgf_free(ptr);\n}\n\nGF_Err ssix_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i,j;\n\tGF_SubsegmentIndexBox *ptr = (GF_SubsegmentIndexBox*)s;\n\n\tISOM_DECREASE_SIZE(ptr, 4)\n\tptr->subsegment_count = gf_bs_read_u32(bs);\n\t//each subseg has at least one range_count (4 bytes), abort if not enough bytes (broken box)\n\tif (ptr->size / 4 < ptr->subsegment_count || (u64)ptr->subsegment_count > (u64)SIZE_MAX/sizeof(GF_SubsegmentInfo))\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tptr->subsegment_alloc = ptr->subsegment_count;\n\tGF_SAFE_ALLOC_N(ptr->subsegments, ptr->subsegment_count, GF_SubsegmentInfo);\n\tif (!ptr->subsegments)\n\t    return GF_OUT_OF_MEM;\n\tfor (i = 0; i < ptr->subsegment_count; i++) {\n\t\tGF_SubsegmentInfo *subseg = &ptr->subsegments[i];\n\t\tISOM_DECREASE_SIZE(ptr, 4)\n\t\tsubseg->range_count = gf_bs_read_u32(bs);\n\t\t//each range is 4 bytes, abort if not enough bytes\n\t\tif (ptr->size / 4 < subseg->range_count || (u64)subseg->range_count > (u64)SIZE_MAX/sizeof(GF_SubsegmentRangeInfo))\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\tsubseg->ranges = (GF_SubsegmentRangeInfo*) gf_malloc(sizeof(GF_SubsegmentRangeInfo) * subseg->range_count);\n\t\tif (!subseg->ranges) return GF_OUT_OF_MEM;\n\t\tfor (j = 0; j < subseg->range_count; j++) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 4)\n\t\t\tsubseg->ranges[j].level = gf_bs_read_u8(bs);\n\t\t\tsubseg->ranges[j].range_size = gf_bs_read_u24(bs);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *ssix_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SubsegmentIndexBox, GF_ISOM_BOX_TYPE_SSIX);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err ssix_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i, j;\n\tGF_SubsegmentIndexBox *ptr = (GF_SubsegmentIndexBox*)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->subsegment_count);\n\tfor (i = 0; i<ptr->subsegment_count; i++) {\n\t\tgf_bs_write_u32(bs, ptr->subsegments[i].range_count);\n\t\tfor (j = 0; j < ptr->subsegments[i].range_count; j++) {\n\t\t\tgf_bs_write_u8(bs, ptr->subsegments[i].ranges[j].level);\n\t\t\tgf_bs_write_u24(bs, ptr->subsegments[i].ranges[j].range_size);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err ssix_box_size(GF_Box *s)\n{\n\tu32 i;\n\tGF_SubsegmentIndexBox *ptr = (GF_SubsegmentIndexBox*)s;\n\n\tptr->size += 4;\n\tfor (i = 0; i < ptr->subsegment_count; i++) {\n\t\tptr->size += 4 + 4 * ptr->subsegments[i].range_count;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid leva_box_del(GF_Box *s)\n{\n\tGF_LevelAssignmentBox *ptr = (GF_LevelAssignmentBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->levels) gf_free(ptr->levels);\n\tgf_free(ptr);\n}\n\nGF_Err leva_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_LevelAssignmentBox *ptr = (GF_LevelAssignmentBox*)s;\n\n\tISOM_DECREASE_SIZE(ptr, 1)\n\tptr->level_count = gf_bs_read_u8(bs);\n\t//each level is at least 5 bytes\n\tif (ptr->size / 5 < ptr->level_count)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tGF_SAFE_ALLOC_N(ptr->levels, ptr->level_count, GF_LevelAssignment);\n\tif (!ptr->levels) return GF_OUT_OF_MEM;\n\n\tfor (i = 0; i < ptr->level_count; i++) {\n\t\tGF_LevelAssignment *level = &ptr->levels[i];\n\t\tu8 tmp;\n\t\tif (!level || ptr->size < 5) return GF_BAD_PARAM;\n\t\tISOM_DECREASE_SIZE(ptr, 5)\n\n\t\tlevel->track_id = gf_bs_read_u32(bs);\n\t\ttmp = gf_bs_read_u8(bs);\n\t\tlevel->padding_flag = tmp >> 7;\n\t\tlevel->type = tmp & 0x7F;\n\t\tif (level->type == 0) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 4)\n\t\t\tlevel->grouping_type = gf_bs_read_u32(bs);\n\t\t}\n\t\telse if (level->type == 1) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\t\tlevel->grouping_type = gf_bs_read_u32(bs);\n\t\t\tlevel->grouping_type_parameter = gf_bs_read_u32(bs);\n\t\t}\n\t\telse if (level->type == 4) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 4)\n\t\t\tlevel->sub_track_id = gf_bs_read_u32(bs);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *leva_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_LevelAssignmentBox, GF_ISOM_BOX_TYPE_LEVA);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err leva_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_LevelAssignmentBox *ptr = (GF_LevelAssignmentBox*)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u8(bs, ptr->level_count);\n\tfor (i = 0; i<ptr->level_count; i++) {\n\t\tgf_bs_write_u32(bs, ptr->levels[i].track_id);\n\t\tgf_bs_write_u8(bs, ptr->levels[i].padding_flag << 7 | (ptr->levels[i].type & 0x7F));\n\t\tif (ptr->levels[i].type == 0) {\n\t\t\tgf_bs_write_u32(bs, ptr->levels[i].grouping_type);\n\t\t}\n\t\telse if (ptr->levels[i].type == 1) {\n\t\t\tgf_bs_write_u32(bs, ptr->levels[i].grouping_type);\n\t\t\tgf_bs_write_u32(bs, ptr->levels[i].grouping_type_parameter);\n\t\t}\n\t\telse if (ptr->levels[i].type == 4) {\n\t\t\tgf_bs_write_u32(bs, ptr->levels[i].sub_track_id);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err leva_box_size(GF_Box *s)\n{\n\tu32 i;\n\tGF_LevelAssignmentBox *ptr = (GF_LevelAssignmentBox*)s;\n\n\tptr->size += 1;\n\tfor (i = 0; i < ptr->level_count; i++) {\n\t\tptr->size += 5;\n\t\tif (ptr->levels[i].type == 0 || ptr->levels[i].type == 4) {\n\t\t\tptr->size += 4;\n\t\t}\n\t\telse if (ptr->levels[i].type == 1) {\n\t\t\tptr->size += 8;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *pcrb_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_PcrInfoBox, GF_ISOM_BOX_TYPE_PCRB);\n\treturn (GF_Box *)tmp;\n}\n\nvoid pcrb_box_del(GF_Box *s)\n{\n\tGF_PcrInfoBox *ptr = (GF_PcrInfoBox *) s;\n\tif (ptr == NULL) return;\n\tif (ptr->pcr_values) gf_free(ptr->pcr_values);\n\tgf_free(ptr);\n}\n\nGF_Err pcrb_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_PcrInfoBox *ptr = (GF_PcrInfoBox*) s;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->subsegment_count = gf_bs_read_u32(bs);\n\n\tif ((u64)ptr->subsegment_count > ptr->size / 8 || (u64)ptr->subsegment_count > (u64)SIZE_MAX/sizeof(u64)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of subsegment %d in pcrb\\n\", ptr->subsegment_count));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tptr->pcr_values = gf_malloc(sizeof(u64)*ptr->subsegment_count);\n\tif (!ptr->pcr_values) return GF_OUT_OF_MEM;\n\tfor (i=0; i<ptr->subsegment_count; i++) {\n\t\tu64 data1 = gf_bs_read_u32(bs);\n\t\tu64 data2 = gf_bs_read_u16(bs);\n\t\tISOM_DECREASE_SIZE(ptr, 6);\n\t\tptr->pcr_values[i] = (data1 << 10) | (data2 >> 6);\n\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err pcrb_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_PcrInfoBox *ptr = (GF_PcrInfoBox*) s;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->subsegment_count);\n\n\tfor (i=0; i<ptr->subsegment_count; i++ ) {\n\t\tu32 data1 = (u32) (ptr->pcr_values[i] >> 10);\n\t\tu16 data2 = (u16) (ptr->pcr_values[i] << 6);\n\n\t\tgf_bs_write_u32(bs, data1);\n\t\tgf_bs_write_u16(bs, data2);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err pcrb_box_size(GF_Box *s)\n{\n\tGF_PcrInfoBox *ptr = (GF_PcrInfoBox*) s;\n\n\tptr->size += 4;\n\tptr->size += ptr->subsegment_count * 6;\n\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *subs_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SubSampleInformationBox, GF_ISOM_BOX_TYPE_SUBS);\n\ttmp->Samples = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\nvoid subs_box_del(GF_Box *s)\n{\n\tGF_SubSampleInformationBox *ptr = (GF_SubSampleInformationBox *)s;\n\tif (ptr == NULL) return;\n\n\twhile (gf_list_count(ptr->Samples)) {\n\t\tGF_SubSampleInfoEntry *pSamp;\n\t\tpSamp = (GF_SubSampleInfoEntry*)gf_list_get(ptr->Samples, 0);\n\t\twhile (gf_list_count(pSamp->SubSamples)) {\n\t\t\tGF_SubSampleEntry *pSubSamp;\n\t\t\tpSubSamp = (GF_SubSampleEntry*) gf_list_get(pSamp->SubSamples, 0);\n\t\t\tgf_free(pSubSamp);\n\t\t\tgf_list_rem(pSamp->SubSamples, 0);\n\t\t}\n\t\tgf_list_del(pSamp->SubSamples);\n\t\tgf_free(pSamp);\n\t\tgf_list_rem(ptr->Samples, 0);\n\t}\n\tgf_list_del(ptr->Samples);\n\tgf_free(ptr);\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err subs_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i, j, entry_count;\n\tu16 subsample_count;\n\tGF_SubSampleEntry *pSubSamp;\n\tGF_SubSampleInformationBox *ptr = (GF_SubSampleInformationBox *) s;\n\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tentry_count = gf_list_count(ptr->Samples);\n\tgf_bs_write_u32(bs, entry_count);\n\n\tfor (i=0; i<entry_count; i++) {\n\t\tGF_SubSampleInfoEntry *pSamp = (GF_SubSampleInfoEntry*) gf_list_get(ptr->Samples, i);\n\t\tsubsample_count = gf_list_count(pSamp->SubSamples);\n\t\tgf_bs_write_u32(bs, pSamp->sample_delta);\n\t\tgf_bs_write_u16(bs, subsample_count);\n\n\t\tfor (j=0; j<subsample_count; j++) {\n\t\t\tpSubSamp = (GF_SubSampleEntry*) gf_list_get(pSamp->SubSamples, j);\n\t\t\tif (ptr->version == 1) {\n\t\t\t\tgf_bs_write_u32(bs, pSubSamp->subsample_size);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_u16(bs, pSubSamp->subsample_size);\n\t\t\t}\n\t\t\tgf_bs_write_u8(bs, pSubSamp->subsample_priority);\n\t\t\tgf_bs_write_u8(bs, pSubSamp->discardable);\n\t\t\tgf_bs_write_u32(bs, pSubSamp->reserved);\n\t\t}\n\t}\n\treturn e;\n}\n\nGF_Err subs_box_size(GF_Box *s)\n{\n\tGF_SubSampleInformationBox *ptr = (GF_SubSampleInformationBox *) s;\n\tu32 entry_count, i;\n\tu16 subsample_count;\n\n\t// add 4 byte for entry_count\n\tptr->size += 4;\n\tentry_count = gf_list_count(ptr->Samples);\n\tfor (i=0; i<entry_count; i++) {\n\t\tGF_SubSampleInfoEntry *pSamp = (GF_SubSampleInfoEntry*) gf_list_get(ptr->Samples, i);\n\t\tsubsample_count = gf_list_count(pSamp->SubSamples);\n\t\t// 4 byte for sample_delta, 2 byte for subsample_count\n\t\t// and 6 + (4 or 2) bytes for each subsample\n\t\tptr->size += 4 + 2 + subsample_count * (6 + (ptr->version==1 ? 4 : 2));\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Err subs_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_SubSampleInformationBox *ptr = (GF_SubSampleInformationBox *)s;\n\tu32 entry_count, i, j;\n\tu16 subsample_count;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tentry_count = gf_bs_read_u32(bs);\n\n\tfor (i=0; i<entry_count; i++) {\n\t\tu32 subs_size=0;\n\t\tGF_SubSampleInfoEntry *pSamp = (GF_SubSampleInfoEntry*) gf_malloc(sizeof(GF_SubSampleInfoEntry));\n\t\tif (!pSamp) return GF_OUT_OF_MEM;\n\n\t\tmemset(pSamp, 0, sizeof(GF_SubSampleInfoEntry));\n\t\tpSamp->SubSamples = gf_list_new();\n\t\tpSamp->sample_delta = gf_bs_read_u32(bs);\n\t\tsubsample_count = gf_bs_read_u16(bs);\n\t\tsubs_size=6;\n\n\t\tfor (j=0; j<subsample_count; j++) {\n\t\t\tGF_SubSampleEntry *pSubSamp = (GF_SubSampleEntry*) gf_malloc(sizeof(GF_SubSampleEntry));\n\t\t\tif (!pSubSamp) return GF_OUT_OF_MEM;\n\n\t\t\tmemset(pSubSamp, 0, sizeof(GF_SubSampleEntry));\n\t\t\tif (ptr->version==1) {\n\t\t\t\tpSubSamp->subsample_size = gf_bs_read_u32(bs);\n\t\t\t\tsubs_size+=4;\n\t\t\t} else {\n\t\t\t\tpSubSamp->subsample_size = gf_bs_read_u16(bs);\n\t\t\t\tsubs_size+=2;\n\t\t\t}\n\t\t\tpSubSamp->subsample_priority = gf_bs_read_u8(bs);\n\t\t\tpSubSamp->discardable = gf_bs_read_u8(bs);\n\t\t\tpSubSamp->reserved = gf_bs_read_u32(bs);\n\t\t\tsubs_size+=6;\n\n\t\t\tgf_list_add(pSamp->SubSamples, pSubSamp);\n\t\t}\n\t\tgf_list_add(ptr->Samples, pSamp);\n\t\tISOM_DECREASE_SIZE(ptr, subs_size);\n\t}\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\nGF_Box *tfdt_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TFBaseMediaDecodeTimeBox, GF_ISOM_BOX_TYPE_TFDT);\n\treturn (GF_Box *)tmp;\n}\n\nvoid tfdt_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\n/*this is using chpl format according to some NeroRecode samples*/\nGF_Err tfdt_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_TFBaseMediaDecodeTimeBox *ptr = (GF_TFBaseMediaDecodeTimeBox *)s;\n\n\tif (ptr->version==1) {\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\tptr->baseMediaDecodeTime = gf_bs_read_u64(bs);\n\t} else {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->baseMediaDecodeTime = (u32) gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err tfdt_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TFBaseMediaDecodeTimeBox *ptr = (GF_TFBaseMediaDecodeTimeBox *) s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tif (ptr->version==1) {\n\t\tgf_bs_write_u64(bs, ptr->baseMediaDecodeTime);\n\t} else {\n\t\tgf_bs_write_u32(bs, (u32) ptr->baseMediaDecodeTime);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err tfdt_box_size(GF_Box *s)\n{\n\tGF_TFBaseMediaDecodeTimeBox *ptr = (GF_TFBaseMediaDecodeTimeBox *)s;\n\n\tif (!ptr->version && (ptr->baseMediaDecodeTime<=0xFFFFFFFF)) {\n\t\t//ptr->version = 0;\n\t\tptr->size += 4;\n\t} else {\n\t\tptr->version = 1;\n\t\tptr->size += 8;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM_FRAGMENTS*/\n\n\nGF_Box *rvcc_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_RVCConfigurationBox, GF_ISOM_BOX_TYPE_RVCC);\n\treturn (GF_Box *)tmp;\n}\n\nvoid rvcc_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err rvcc_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_RVCConfigurationBox *ptr = (GF_RVCConfigurationBox*)s;\n\tISOM_DECREASE_SIZE(ptr, 2);\n\tptr->predefined_rvc_config = gf_bs_read_u16(bs);\n\tif (!ptr->predefined_rvc_config) {\n\t\tISOM_DECREASE_SIZE(ptr, 2);\n\t\tptr->rvc_meta_idx = gf_bs_read_u16(bs);\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err rvcc_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_RVCConfigurationBox *ptr = (GF_RVCConfigurationBox*) s;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u16(bs, ptr->predefined_rvc_config);\n\tif (!ptr->predefined_rvc_config) {\n\t\tgf_bs_write_u16(bs, ptr->rvc_meta_idx);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err rvcc_box_size(GF_Box *s)\n{\n\tGF_RVCConfigurationBox *ptr = (GF_RVCConfigurationBox *)s;\n\tptr->size += 2;\n\tif (! ptr->predefined_rvc_config) ptr->size += 2;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Box *sbgp_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleGroupBox, GF_ISOM_BOX_TYPE_SBGP);\n\treturn (GF_Box *)tmp;\n}\nvoid sbgp_box_del(GF_Box *a)\n{\n\tGF_SampleGroupBox *p = (GF_SampleGroupBox *)a;\n\tif (p->sample_entries) gf_free(p->sample_entries);\n\tgf_free(p);\n}\n\nGF_Err sbgp_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_SampleGroupBox *ptr = (GF_SampleGroupBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 8);\n\tptr->grouping_type = gf_bs_read_u32(bs);\n\n\tif (ptr->version==1) {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->grouping_type_parameter = gf_bs_read_u32(bs);\n\t}\n\tptr->entry_count = gf_bs_read_u32(bs);\n\n\tif (ptr->size < sizeof(GF_SampleGroupEntry)*ptr->entry_count || (u64)ptr->entry_count > (u64)SIZE_MAX/sizeof(GF_SampleGroupEntry))\n\t    return GF_ISOM_INVALID_FILE;\n\n\tptr->sample_entries = gf_malloc(sizeof(GF_SampleGroupEntry)*ptr->entry_count);\n\tif (!ptr->sample_entries) return GF_OUT_OF_MEM;\n\n\tfor (i=0; i<ptr->entry_count; i++) {\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\tptr->sample_entries[i].sample_count = gf_bs_read_u32(bs);\n\t\tptr->sample_entries[i].group_description_index = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err sbgp_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_Err e;\n\tGF_SampleGroupBox *p = (GF_SampleGroupBox*)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, p->grouping_type);\n\tif (p->version==1)\n\t\tgf_bs_write_u32(bs, p->grouping_type_parameter);\n\n\tgf_bs_write_u32(bs, p->entry_count);\n\tfor (i = 0; i<p->entry_count; i++ ) {\n\t\tgf_bs_write_u32(bs, p->sample_entries[i].sample_count);\n\t\tgf_bs_write_u32(bs, p->sample_entries[i].group_description_index);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err sbgp_box_size(GF_Box *s)\n{\n\tGF_SampleGroupBox *p = (GF_SampleGroupBox*)s;\n\n\tp->size += 8;\n\tif (p->grouping_type_parameter) p->version=1;\n\n\tif (p->version==1) p->size += 4;\n\tp->size += 8*p->entry_count;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid *sgpd_parse_entry(GF_SampleGroupDescriptionBox *p, GF_BitStream *bs, s32 bytes_in_box, u32 entry_size, u32 *total_bytes)\n{\n\tBool null_size_ok = GF_FALSE;\n\tGF_DefaultSampleGroupDescriptionEntry *def_ptr;\n\tp->is_opaque = GF_FALSE;\n\tswitch (p->grouping_type) {\n\tcase GF_ISOM_SAMPLE_GROUP_ROLL:\n\tcase GF_ISOM_SAMPLE_GROUP_PROL:\n\t{\n\t\tGF_RollRecoveryEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_RollRecoveryEntry);\n\t\tif (!ptr) return NULL;\n\t\tptr->roll_distance = gf_bs_read_int(bs, 16);\n\t\t*total_bytes = 2;\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_RAP:\n\t{\n\t\tGF_VisualRandomAccessEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_VisualRandomAccessEntry);\n\t\tif (!ptr) return NULL;\n\t\tptr->num_leading_samples_known = gf_bs_read_int(bs, 1);\n\t\tptr->num_leading_samples = gf_bs_read_int(bs, 7);\n\t\t*total_bytes = 1;\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_SAP:\n\t{\n\t\tGF_SAPEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_SAPEntry);\n\t\tif (!ptr) return NULL;\n\t\tptr->dependent_flag = gf_bs_read_int(bs, 1);\n\t\tgf_bs_read_int(bs, 3);\n\t\tptr->SAP_type = gf_bs_read_int(bs, 4);\n\t\t*total_bytes = 1;\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_SYNC:\n\t{\n\t\tGF_SYNCEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_SYNCEntry);\n\t\tif (!ptr) return NULL;\n\t\tgf_bs_read_int(bs, 2);\n\t\tptr->NALU_type = gf_bs_read_int(bs, 6);\n\t\t*total_bytes = 1;\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_TELE:\n\t{\n\t\tGF_TemporalLevelEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_TemporalLevelEntry);\n\t\tif (!ptr) return NULL;\n\t\tptr->level_independently_decodable = gf_bs_read_int(bs, 1);\n\t\tgf_bs_read_int(bs, 7);\n\t\t*total_bytes = 1;\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_SEIG:\n\t{\n\t\tGF_CENCSampleEncryptionGroupEntry *ptr;\n\t\tif (bytes_in_box<3) return NULL;\n\t\tGF_SAFEALLOC(ptr, GF_CENCSampleEncryptionGroupEntry);\n\t\tif (!ptr) return NULL;\n\t\tBool use_mkey = gf_bs_read_int(bs, 1);\n\t\tgf_bs_read_int(bs, 7); //reserved\n\t\tptr->crypt_byte_block = gf_bs_read_int(bs, 4);\n\t\tptr->skip_byte_block = gf_bs_read_int(bs, 4);\n\t\tptr->IsProtected = gf_bs_read_u8(bs);\n\t\tbytes_in_box -= 3;\n\t\tif (use_mkey) {\n\t\t\tu64 pos = gf_bs_get_position(bs);\n\t\t\tu32 i, count = gf_bs_read_u16(bs);\n\t\t\tbytes_in_box -= 2;\n\t\t\tif (bytes_in_box<0) {\n\t\t\t\tgf_free(ptr);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tu8 ivsize = gf_bs_read_u8(bs);\n\t\t\t\tgf_bs_skip_bytes(bs, 16);\n\t\t\t\tbytes_in_box -= 17;\n\t\t\t\tif (!ivsize) {\n\t\t\t\t\t//const IV\n\t\t\t\t\tivsize = gf_bs_read_u8(bs);\n\t\t\t\t\tgf_bs_skip_bytes(bs, ivsize);\n\t\t\t\t\tbytes_in_box -= 1 + ivsize;\n\t\t\t\t}\n\t\t\t\tif (bytes_in_box<0) {\n\t\t\t\t\tgf_free(ptr);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tptr->key_info_size = 1 + (u32) (gf_bs_get_position(bs) - pos);\n\t\t\tptr->key_info = gf_malloc(sizeof(u8) * ptr->key_info_size);\n\t\t\tif (!ptr->key_info) {\n\t\t\t\tgf_free(ptr);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tgf_bs_seek(bs, pos);\n\t\t\tptr->key_info[0] = 1;\n\t\t\tgf_bs_read_data(bs, ptr->key_info + 1, ptr->key_info_size - 1);\n\t\t\t*total_bytes = 3 + ptr->key_info_size - 1;\n\n\t\t\tif (!gf_cenc_validate_key_info(ptr->key_info, ptr->key_info_size)) {\n\t\t\t\tgf_free(ptr->key_info);\n\t\t\t\tgf_free(ptr);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tbin128 kid;\n\t\t\tu8 const_iv_size = 0;\n\t\t\tu8 iv_size = gf_bs_read_u8(bs);\n\t\t\tgf_bs_read_data(bs, kid, 16);\n\t\t\tbytes_in_box -= 17;\n\t\t\tif (bytes_in_box<0) {\n\t\t\t\tgf_free(ptr);\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\t*total_bytes = 20;\n\t\t\tif ((ptr->IsProtected == 1) && !iv_size) {\n\t\t\t\tconst_iv_size = gf_bs_read_u8(bs);\n\t\t\t\tif ((const_iv_size != 8) && (const_iv_size != 16)) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] seig sample group have invalid constant_IV size\\n\"));\n\t\t\t\t\tgf_free(ptr);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tptr->key_info_size = 20;\n\t\t\tif (!iv_size && ptr->IsProtected) {\n\t\t\t\tptr->key_info_size += 1 + const_iv_size;\n\t\t\t}\n\t\t\tptr->key_info = gf_malloc(sizeof(u8) * ptr->key_info_size);\n\t\t\tif (!ptr->key_info) {\n\t\t\t\tgf_free(ptr);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tptr->key_info[0] = 0;\n\t\t\tptr->key_info[1] = 0;\n\t\t\tptr->key_info[2] = 0;\n\t\t\tptr->key_info[3] = iv_size;\n\t\t\tmemcpy(ptr->key_info+4, kid, 16);\n\t\t\tif (!iv_size && ptr->IsProtected) {\n\t\t\t\tptr->key_info[20] = const_iv_size;\n\t\t\t\tgf_bs_read_data(bs, (char *)ptr->key_info+21, const_iv_size);\n\t\t\t\t*total_bytes += 1 + const_iv_size;\n\t\t\t}\n\t\t}\n\n\t\tif (!entry_size) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] seig sample group does not indicate entry size, deprecated in spec\\n\"));\n\t\t}\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_OINF:\n\t{\n\t\tGF_OperatingPointsInformation *ptr = gf_isom_oinf_new_entry();\n\t\tu32 s = (u32) gf_bs_get_position(bs);\n\t\tgf_isom_oinf_read_entry(ptr, bs);\n\t\t*total_bytes = (u32) gf_bs_get_position(bs) - s;\n\t\tif (!entry_size) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] oinf sample group does not indicate entry size, deprecated in spec\\n\"));\n\t\t}\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_LINF:\n\t{\n\t\tGF_LHVCLayerInformation *ptr = gf_isom_linf_new_entry();\n\t\tu32 s = (u32) gf_bs_get_position(bs);\n\t\tgf_isom_linf_read_entry(ptr, bs);\n\t\t*total_bytes = (u32) gf_bs_get_position(bs) - s;\n\t\tif (!entry_size) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] linf sample group does not indicate entry size, deprecated in spec\\n\"));\n\t\t}\n\t\treturn ptr;\n\t}\n\n\tcase GF_ISOM_SAMPLE_GROUP_TRIF:\n\t\tif (! entry_size) {\n\t\t\tu32 flags = gf_bs_peek_bits(bs, 24, 0);\n\t\t\tif (flags & 0x10000) entry_size=3;\n\t\t\telse {\n\t\t\t\tif (flags & 0x80000) entry_size=7;\n\t\t\t\telse entry_size=11;\n\t\t\t\t//have dependency list\n\t\t\t\tif (flags & 0x200000) {\n\t\t\t\t\tu32 nb_entries = gf_bs_peek_bits(bs, 16, entry_size);\n\t\t\t\t\tentry_size += 2 + 2*nb_entries;\n\t\t\t\t}\n\t\t\t}\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] trif sample group does not indicate entry size, deprecated in spec\\n\"));\n\t\t}\n\t\tbreak;\n\tcase GF_ISOM_SAMPLE_GROUP_NALM:\n\t\tif (! entry_size) {\n\t\t\tu64 start = gf_bs_get_position(bs);\n\t\t\tBool rle, large_size;\n\t\t\tu32 entry_count;\n\t\t\tgf_bs_read_int(bs, 6);\n\t\t\tlarge_size = gf_bs_read_int(bs, 1);\n\t\t\trle = gf_bs_read_int(bs, 1);\n\t\t\tentry_count = gf_bs_read_int(bs, large_size ? 16 : 8);\n\t\t\tgf_bs_seek(bs, start);\n\t\t\tentry_size = 1 + (large_size ? 2 : 1);\n\t\t\tentry_size += entry_count * 2;\n\t\t\tif (rle) entry_size += entry_count * (large_size ? 2 : 1);\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] nalm sample group does not indicate entry size, deprecated in spec\\n\"));\n\t\t}\n\t\tbreak;\n\n\tcase GF_ISOM_SAMPLE_GROUP_TSAS:\n\tcase GF_ISOM_SAMPLE_GROUP_STSA:\n\t\tnull_size_ok = GF_TRUE;\n\t\tbreak;\n\t//TODO, add support for these ones ?\n\tcase GF_ISOM_SAMPLE_GROUP_TSCL:\n\t\tentry_size = 20;\n\t\tbreak;\n\tcase GF_ISOM_SAMPLE_GROUP_LBLI:\n\t\tentry_size = 2;\n\t\tbreak;\n\tcase GF_ISOM_SAMPLE_GROUP_SPOR:\n\t{\n\t\tu32 i;\n\t\tGF_SubpictureOrderEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_SubpictureOrderEntry);\n\t\tif (!ptr) return NULL;\n\t\tptr->subpic_id_info_flag = gf_bs_read_int(bs, 1);\n\t\tptr->num_subpic_ref_idx = gf_bs_read_int(bs, 15);\n\t\t*total_bytes = 2;\n\t\tptr->subp_track_ref_idx = gf_malloc(sizeof(u16) * ptr->num_subpic_ref_idx);\n\t\tif (!ptr->subp_track_ref_idx) {\n\t\t\tgf_free(ptr);\n\t\t\treturn NULL;\n\t\t}\n\t\tfor (i=0; i<ptr->num_subpic_ref_idx; i++) {\n\t\t\tptr->subp_track_ref_idx[i] = gf_bs_read_u16(bs);\n\t\t\t*total_bytes += 2;\n\t\t}\n\t\tif (ptr->subpic_id_info_flag) {\n\t\t\tptr->spinfo.subpic_id_len_minus1 = gf_bs_read_int(bs, 4);\n\t\t\tptr->spinfo.subpic_id_bit_pos = gf_bs_read_int(bs, 12);\n\t\t\tptr->spinfo.start_code_emul_flag = gf_bs_read_int(bs, 1);\n\t\t\tptr->spinfo.pps_sps_subpic_id_flag = gf_bs_read_int(bs, 1);\n\t\t\tif (ptr->spinfo.pps_sps_subpic_id_flag) {\n\t\t\t\tptr->spinfo.xps_id = gf_bs_read_int(bs, 6);\n\t\t\t} else {\n\t\t\t\tptr->spinfo.xps_id = gf_bs_read_int(bs, 4);\n\t\t\t\tgf_bs_read_int(bs, 2);\n\t\t\t}\n\t\t\t*total_bytes += 3;\n\t\t}\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_SULM:\n\t{\n\t\tu32 i;\n\t\tGF_SubpictureLayoutMapEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_SubpictureLayoutMapEntry);\n\t\tif (!ptr) return NULL;\n\t\tptr->groupID_info_4cc = gf_bs_read_u32(bs);\n\t\tptr->nb_entries = 1 + gf_bs_read_u16(bs);\n\t\t*total_bytes = 6;\n\t\tptr->groupIDs = gf_malloc(sizeof(u16) * ptr->nb_entries);\n\t\tif (!ptr->groupIDs) {\n\t\t\tgf_free(ptr);\n\t\t\treturn NULL;\n\t\t}\n\t\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\t\tptr->groupIDs[i] = gf_bs_read_u16(bs);\n\t\t\t*total_bytes += 2;\n\t\t}\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_ILCE:\n\t{\n\t\tGF_FieldInterlaceType *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_FieldInterlaceType);\n\t\tif (!ptr) return NULL;\n\t\tptr->ilce_type = gf_bs_read_u8(bs);\n\t\t*total_bytes = 1;\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_ESGH:\n\t{\n\t\tu32 i;\n\t\tGF_EssentialSamplegroupEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_EssentialSamplegroupEntry);\n\t\tif (!ptr) return NULL;\n\t\tptr->nb_types = gf_bs_read_u32(bs);\n\t\tif (ptr->nb_types * 4 + 4 > entry_size) {\n\t\t\tgf_free(ptr);\n\t\t\treturn NULL;\n\t\t}\n\t\t*total_bytes = 4;\n\t\tptr->group_types = gf_malloc(sizeof(u32) * ptr->nb_types);\n\t\tif (!ptr->group_types) {\n\t\t\tgf_free(ptr);\n\t\t\treturn NULL;\n\t\t}\n\t\tfor (i=0; i<ptr->nb_types; i++) {\n\t\t\tptr->group_types[i] = gf_bs_read_u32(bs);\n\t\t\t*total_bytes += 4;\n\t\t}\n\t\treturn ptr;\n\t}\n\tcase 0:\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] sgpd entry null grouping_type is invalid\\n\") );\n\t\treturn NULL;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (!entry_size && !null_size_ok) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] %s sample group does not indicate entry size and is not implemented, cannot parse!\\n\", gf_4cc_to_str( p->grouping_type) ));\n\t\treturn NULL;\n\t}\n\tp->is_opaque = GF_TRUE;\n\tGF_SAFEALLOC(def_ptr, GF_DefaultSampleGroupDescriptionEntry);\n\tif (!def_ptr) return NULL;\n\tif (entry_size) {\n\t\tdef_ptr->length = entry_size;\n\t\tdef_ptr->data = (u8 *) gf_malloc(sizeof(u8)*def_ptr->length);\n\t\tif (!def_ptr->data) {\n\t\t\tgf_free(def_ptr);\n\t\t\treturn NULL;\n\t\t}\n\t\tgf_bs_read_data(bs, (char *) def_ptr->data, def_ptr->length);\n\t\t*total_bytes = entry_size;\n\t}\n\treturn def_ptr;\n}\n\nvoid sgpd_del_entry(u32 grouping_type, void *entry)\n{\n\tswitch (grouping_type) {\n\tcase GF_ISOM_SAMPLE_GROUP_SYNC:\n\tcase GF_ISOM_SAMPLE_GROUP_ROLL:\n\tcase GF_ISOM_SAMPLE_GROUP_PROL:\n\tcase GF_ISOM_SAMPLE_GROUP_RAP:\n\tcase GF_ISOM_SAMPLE_GROUP_TELE:\n\tcase GF_ISOM_SAMPLE_GROUP_SAP:\n\t\tgf_free(entry);\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_SEIG:\n\t{\n\t\tGF_CENCSampleEncryptionGroupEntry *seig = (GF_CENCSampleEncryptionGroupEntry *)entry;\n\t\tif (seig->key_info) gf_free(seig->key_info);\n\t\tgf_free(entry);\n\t}\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_OINF:\n\t\tgf_isom_oinf_del_entry(entry);\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_LINF:\n\t\tgf_isom_linf_del_entry(entry);\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_SPOR:\n\t{\n\t\tGF_SubpictureOrderEntry *spor = (GF_SubpictureOrderEntry *)entry;\n\t\tif (spor->subp_track_ref_idx) gf_free(spor->subp_track_ref_idx);\n\t\tgf_free(spor);\n\t}\n\t\treturn;\n\n\tcase GF_ISOM_SAMPLE_GROUP_SULM:\n\t{\n\t\tGF_SubpictureLayoutMapEntry *sulm = (GF_SubpictureLayoutMapEntry *) entry;\n\t\tif (sulm->groupIDs) gf_free(sulm->groupIDs);\n\t\tgf_free(sulm);\n\t\treturn;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_ILCE:\n\t\tgf_free(entry);\n\t\treturn;\n\n\tcase GF_ISOM_SAMPLE_GROUP_ESGH:\n\t{\n\t\tGF_EssentialSamplegroupEntry *esgh = (GF_EssentialSamplegroupEntry *) entry;\n\t\tif (esgh->group_types) gf_free(esgh->group_types);\n\t\tgf_free(esgh);\n\t\treturn;\n\t}\n\n\tdefault:\n\t{\n\t\tGF_DefaultSampleGroupDescriptionEntry *ptr = (GF_DefaultSampleGroupDescriptionEntry *)entry;\n\t\tif (ptr->data) gf_free(ptr->data);\n\t\tgf_free(ptr);\n\t}\n\t}\n}\n\nvoid sgpd_write_entry(u32 grouping_type, void *entry, GF_BitStream *bs)\n{\n\tswitch (grouping_type) {\n\tcase GF_ISOM_SAMPLE_GROUP_ROLL:\n\tcase GF_ISOM_SAMPLE_GROUP_PROL:\n\t\tgf_bs_write_int(bs, ((GF_RollRecoveryEntry*)entry)->roll_distance, 16);\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_RAP:\n\t\tgf_bs_write_int(bs, ((GF_VisualRandomAccessEntry*)entry)->num_leading_samples_known, 1);\n\t\tgf_bs_write_int(bs, ((GF_VisualRandomAccessEntry*)entry)->num_leading_samples, 7);\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_SAP:\n\t\tgf_bs_write_int(bs, ((GF_SAPEntry*)entry)->dependent_flag, 1);\n\t\tgf_bs_write_int(bs, 0, 3);\n\t\tgf_bs_write_int(bs, ((GF_SAPEntry*)entry)->SAP_type, 4);\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_SYNC:\n\t\tgf_bs_write_int(bs, 0, 2);\n\t\tgf_bs_write_int(bs, ((GF_SYNCEntry*)entry)->NALU_type, 6);\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_TELE:\n\t\tgf_bs_write_int(bs, ((GF_TemporalLevelEntry*)entry)->level_independently_decodable, 1);\n\t\tgf_bs_write_int(bs, 0, 7);\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_SEIG:\n\t{\n\t\tGF_CENCSampleEncryptionGroupEntry *seig = (GF_CENCSampleEncryptionGroupEntry *)entry;\n\t\tBool use_mkey = seig->key_info[0];\n\t\tu32 nb_keys = 1;\n\t\tif (use_mkey) {\n\t\t\tnb_keys = seig->key_info[1];\n\t\t\tnb_keys<<=8;\n\t\t\tnb_keys |= seig->key_info[2];\n\t\t}\n\t\tgf_bs_write_int(bs, use_mkey ? 1 : 0, 1);\n\t\tgf_bs_write_int(bs, 0, 7);\n\t\tgf_bs_write_int(bs, seig->crypt_byte_block, 4);\n\t\tgf_bs_write_int(bs, seig->skip_byte_block, 4);\n\t\tgf_bs_write_u8(bs, seig->IsProtected);\n\t\tif (nb_keys>1) {\n\t\t\tgf_bs_write_data(bs, seig->key_info+1, seig->key_info_size-1);\n\t\t} else {\n\t\t\tgf_bs_write_data(bs, seig->key_info+3, seig->key_info_size - 3);\n\t\t}\n\t}\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_OINF:\n\t\tgf_isom_oinf_write_entry(entry, bs);\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_LINF:\n\t\tgf_isom_linf_write_entry(entry, bs);\n\t\treturn;\n\n\tcase GF_ISOM_SAMPLE_GROUP_SPOR:\n\t{\n\t\tu32 i;\n\t\tGF_SubpictureOrderEntry *spor = (GF_SubpictureOrderEntry *) entry;\n\t\tgf_bs_write_int(bs, spor->subpic_id_info_flag, 1);\n\t\tgf_bs_write_int(bs, spor->num_subpic_ref_idx, 15);\n\t\tfor (i=0; i<spor->num_subpic_ref_idx; i++) {\n\t\t\tgf_bs_write_u16(bs, spor->subp_track_ref_idx[i]);\n\t\t}\n\t\tif (spor->subpic_id_info_flag) {\n\t\t\tgf_bs_write_int(bs, spor->spinfo.subpic_id_len_minus1, 4);\n\t\t\tgf_bs_write_int(bs, spor->spinfo.subpic_id_bit_pos, 12);\n\t\t\tgf_bs_write_int(bs, spor->spinfo.start_code_emul_flag, 1);\n\t\t\tgf_bs_write_int(bs, spor->spinfo.pps_sps_subpic_id_flag, 1);\n\t\t\tif (spor->spinfo.pps_sps_subpic_id_flag) {\n\t\t\t\tgf_bs_write_int(bs, spor->spinfo.xps_id, 6);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_int(bs, spor->spinfo.xps_id, 4);\n\t\t\t\tgf_bs_write_int(bs, 0, 2);\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\tcase GF_ISOM_SAMPLE_GROUP_SULM:\n\t{\n\t\tu32 i;\n\t\tGF_SubpictureLayoutMapEntry *sulm = (GF_SubpictureLayoutMapEntry *) entry;\n\t\tgf_bs_write_u32(bs, sulm->groupID_info_4cc);\n\t\tgf_bs_write_u16(bs, sulm->nb_entries - 1);\n\t\tfor (i=0; i<sulm->nb_entries; i++) {\n\t\t\tgf_bs_write_u16(bs, sulm->groupIDs[i]);\n\t\t}\n\t\treturn;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_ILCE:\n\t{\n\t\tGF_FieldInterlaceType *ilce = (GF_FieldInterlaceType *) entry;\n\t\tgf_bs_write_u8(bs, ilce->ilce_type);\n\t\treturn;\n\t}\n\n\tcase GF_ISOM_SAMPLE_GROUP_ESGH:\n\t{\n\t\tu32 i;\n\t\tGF_EssentialSamplegroupEntry *esgh = (GF_EssentialSamplegroupEntry *) entry;\n\t\tgf_bs_write_u32(bs, esgh->nb_types);\n\t\tfor (i=0; i<esgh->nb_types; i++) {\n\t\t\tgf_bs_write_u32(bs, esgh->group_types[i]);\n\t\t}\n\t\treturn;\n\t}\n\n\tdefault:\n\t{\n\t\tGF_DefaultSampleGroupDescriptionEntry *ptr = (GF_DefaultSampleGroupDescriptionEntry *)entry;\n\t\tif (ptr->length)\n\t\t\tgf_bs_write_data(bs, (char *) ptr->data, ptr->length);\n\t}\n\t}\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nstatic u32 sgpd_size_entry(u32 grouping_type, void *entry)\n{\n\tswitch (grouping_type) {\n\tcase GF_ISOM_SAMPLE_GROUP_ROLL:\n\tcase GF_ISOM_SAMPLE_GROUP_PROL:\n\t\treturn 2;\n\tcase GF_ISOM_SAMPLE_GROUP_TELE:\n\tcase GF_ISOM_SAMPLE_GROUP_RAP:\n\tcase GF_ISOM_SAMPLE_GROUP_SAP:\n\tcase GF_ISOM_SAMPLE_GROUP_SYNC:\n\t\treturn 1;\n\tcase GF_ISOM_SAMPLE_GROUP_TSCL:\n\t\treturn 20;\n\tcase GF_ISOM_SAMPLE_GROUP_LBLI:\n\t\treturn 2;\n\tcase GF_ISOM_SAMPLE_GROUP_TSAS:\n\tcase GF_ISOM_SAMPLE_GROUP_STSA:\n\t\treturn 0;\n\tcase GF_ISOM_SAMPLE_GROUP_SEIG:\n\t{\n\t\tGF_CENCSampleEncryptionGroupEntry *seig = (GF_CENCSampleEncryptionGroupEntry *)entry;\n\t\tBool use_mkey = seig->key_info[0] ? GF_TRUE : GF_FALSE;\n\t\tif (use_mkey) {\n\t\t\treturn 3 + seig->key_info_size-1;\n\t\t}\n\t\treturn seig->key_info_size; //== 3 + (seig->key_info_size-3);\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_OINF:\n\t\treturn gf_isom_oinf_size_entry(entry);\n\tcase GF_ISOM_SAMPLE_GROUP_LINF:\n\t\treturn gf_isom_linf_size_entry(entry);\n\tcase GF_ISOM_SAMPLE_GROUP_SPOR:\n\t{\n\t\tGF_SubpictureOrderEntry *spor = (GF_SubpictureOrderEntry *)entry;\n\t\tu32 s = 2 + 2*spor->num_subpic_ref_idx;\n\t\tif (spor->subpic_id_info_flag) {\n\t\t\ts += 3;\n\t\t}\n\t\treturn s;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_SULM:\n\t{\n\t\tGF_SubpictureLayoutMapEntry *sulm = (GF_SubpictureLayoutMapEntry *) entry;\n\t\treturn 6 + 2*sulm->nb_entries;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_ILCE:\n\t\treturn 1;\n\n\tcase GF_ISOM_SAMPLE_GROUP_ESGH:\n\t{\n\t\tGF_EssentialSamplegroupEntry *esgh = (GF_EssentialSamplegroupEntry *) entry;\n\t\treturn 4 + 4*esgh->nb_types;\n\t}\n\n\tdefault:\n\t\treturn ((GF_DefaultSampleGroupDescriptionEntry *)entry)->length;\n\t}\n}\n#endif\n\nGF_Box *sgpd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleGroupDescriptionBox, GF_ISOM_BOX_TYPE_SGPD);\n\t/*version 0 is deprecated, use v1 by default*/\n\ttmp->version = 1;\n\ttmp->group_descriptions = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\nvoid sgpd_box_del(GF_Box *a)\n{\n\tGF_SampleGroupDescriptionBox *p = (GF_SampleGroupDescriptionBox *)a;\n\twhile (gf_list_count(p->group_descriptions)) {\n\t\tvoid *ptr = gf_list_last(p->group_descriptions);\n\t\tsgpd_del_entry(p->grouping_type, ptr);\n\t\tgf_list_rem_last(p->group_descriptions);\n\t}\n\tgf_list_del(p->group_descriptions);\n\tgf_free(p);\n}\n\nGF_Err sgpd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 entry_count;\n\tGF_SampleGroupDescriptionBox *p = (GF_SampleGroupDescriptionBox *)s;\n\n\tISOM_DECREASE_SIZE(p, 8);\n\tp->grouping_type = gf_bs_read_u32(bs);\n\n\tif (p->version>=1) {\n\t\tISOM_DECREASE_SIZE(p, 4);\n\t\tp->default_length = gf_bs_read_u32(bs);\n\t}\n\tif (p->version>=2) {\n\t\tISOM_DECREASE_SIZE(p, 4);\n\t\tp->default_description_index = gf_bs_read_u32(bs);\n\t}\n\tentry_count = gf_bs_read_u32(bs);\n\n\tif (entry_count>p->size)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\twhile (entry_count) {\n\t\tvoid *ptr;\n\t\tu32 parsed_bytes=0;\n\t\tu32 size = p->default_length;\n\t\tif ((p->version>=1) && !size) {\n\t\t\tsize = gf_bs_read_u32(bs);\n\t\t\tISOM_DECREASE_SIZE(p, 4);\n\t\t}\n\t\tptr = sgpd_parse_entry(p, bs, (s32) p->size, size, &parsed_bytes);\n\t\t//don't return an error, just stop parsing so that we skip over the sgpd box\n\t\tif (!ptr) return GF_OK;\n\t\tgf_list_add(p->group_descriptions, ptr);\n\n\t\tISOM_DECREASE_SIZE(p, parsed_bytes);\n\t\tentry_count--;\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err sgpd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i, nb_descs;\n\tGF_SampleGroupDescriptionBox *p = (GF_SampleGroupDescriptionBox *)s;\n\tGF_Err e;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, p->grouping_type);\n\tif (p->version>=1) gf_bs_write_u32(bs, p->default_length);\n\tif (p->version>=2) gf_bs_write_u32(bs, p->default_description_index);\n\tnb_descs = gf_list_count(p->group_descriptions);\n\tgf_bs_write_u32(bs, nb_descs);\n\n\tfor (i=0; i<nb_descs; i++) {\n\t\tvoid *ptr = gf_list_get(p->group_descriptions, i);\n\t\tif ((p->version >= 1) && !p->default_length) {\n\t\t\tu32 size = sgpd_size_entry(p->grouping_type, ptr);\n\t\t\tgf_bs_write_u32(bs, size);\n\t\t}\n\t\tsgpd_write_entry(p->grouping_type, ptr, bs);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err sgpd_box_size(GF_Box *s)\n{\n\tu32 i, nb_descs;\n\tBool use_def_size = GF_TRUE;\n\tGF_SampleGroupDescriptionBox *p = (GF_SampleGroupDescriptionBox *)s;\n\n\tp->size += 8;\n\n\t//we force all sample groups to version 1, v0 being deprecated\n\tif (!p->version)\n\t\tp->version = 1;\n\tp->size += 4;\n\n\tif (p->version>=2)\n\t\tp->size += 4;\n\tp->default_length = 0;\n\n\tnb_descs = gf_list_count(p->group_descriptions);\n\tfor (i=0; i<nb_descs; i++) {\n\t\tvoid *ptr = gf_list_get(p->group_descriptions, i);\n\t\tu32 size = sgpd_size_entry(p->grouping_type, ptr);\n\t\tp->size += size;\n\t\tif (use_def_size && !p->default_length) {\n\t\t\tp->default_length = size;\n\t\t} else if (p->default_length != size) {\n\t\t\tuse_def_size = GF_FALSE;\n\t\t\tp->default_length = 0;\n\t\t}\n\t}\n\tif (p->version>=1) {\n\t\tif (!p->default_length) p->size += nb_descs * 4;\n\t}\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid saiz_box_del(GF_Box *s)\n{\n\tGF_SampleAuxiliaryInfoSizeBox*ptr = (GF_SampleAuxiliaryInfoSizeBox*)s;\n\tif (ptr == NULL) return;\n\tif (ptr->sample_info_size) gf_free(ptr->sample_info_size);\n\tgf_free(ptr);\n}\n\n\nGF_Err saiz_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_SampleAuxiliaryInfoSizeBox*ptr = (GF_SampleAuxiliaryInfoSizeBox*)s;\n\n\tif (ptr->flags & 1) {\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\tptr->aux_info_type = gf_bs_read_u32(bs);\n\t\tptr->aux_info_type_parameter = gf_bs_read_u32(bs);\n\t}\n\tISOM_DECREASE_SIZE(ptr, 5);\n\tptr->default_sample_info_size = gf_bs_read_u8(bs);\n\tptr->sample_count = gf_bs_read_u32(bs);\n\n\tif (ptr->default_sample_info_size == 0) {\n\t\tif (ptr->size < ptr->sample_count)\n\t\t    return GF_ISOM_INVALID_FILE;\n\n\t\tptr->sample_info_size = gf_malloc(sizeof(u8)*ptr->sample_count);\n\t\tptr->sample_alloc = ptr->sample_count;\n\t\tif (!ptr->sample_info_size)\n\t\t    return GF_OUT_OF_MEM;\n\n\t\tISOM_DECREASE_SIZE(ptr, ptr->sample_count);\n\t\tgf_bs_read_data(bs, (char *) ptr->sample_info_size, ptr->sample_count);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *saiz_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleAuxiliaryInfoSizeBox, GF_ISOM_BOX_TYPE_SAIZ);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err saiz_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SampleAuxiliaryInfoSizeBox*ptr = (GF_SampleAuxiliaryInfoSizeBox*) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tif (ptr->flags & 1) {\n\t\tgf_bs_write_u32(bs, ptr->aux_info_type);\n\t\tgf_bs_write_u32(bs, ptr->aux_info_type_parameter);\n\t}\n\tgf_bs_write_u8(bs, ptr->default_sample_info_size);\n\tgf_bs_write_u32(bs, ptr->sample_count);\n\tif (!ptr->default_sample_info_size) {\n\t\tif (!ptr->sample_info_size)\n\t\t\tgf_bs_write_u8(bs, 0);\n\t\telse\n\t\t\tgf_bs_write_data(bs, (char *) ptr->sample_info_size, ptr->sample_count);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err saiz_box_size(GF_Box *s)\n{\n\tGF_SampleAuxiliaryInfoSizeBox *ptr = (GF_SampleAuxiliaryInfoSizeBox*)s;\n\n\tif (ptr->aux_info_type || ptr->aux_info_type_parameter) {\n\t\tptr->flags |= 1;\n\t}\n\tif (ptr->flags & 1) ptr->size += 8;\n\tptr->size += 5;\n\tif (ptr->default_sample_info_size==0)  ptr->size += ptr->sample_count;\n\treturn GF_OK;\n}\n#endif //GPAC_DISABLE_ISOM_WRITE\n\nvoid saio_box_del(GF_Box *s)\n{\n\tGF_SampleAuxiliaryInfoOffsetBox *ptr = (GF_SampleAuxiliaryInfoOffsetBox*)s;\n\tif (ptr == NULL) return;\n\tif (ptr->offsets) gf_free(ptr->offsets);\n\tif (ptr->cached_data) gf_free(ptr->cached_data);\n\tgf_free(ptr);\n}\n\n\nGF_Err saio_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_SampleAuxiliaryInfoOffsetBox *ptr = (GF_SampleAuxiliaryInfoOffsetBox *)s;\n\n\tif (ptr->flags & 1) {\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\tptr->aux_info_type = gf_bs_read_u32(bs);\n\t\tptr->aux_info_type_parameter = gf_bs_read_u32(bs);\n\t}\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->entry_count = gf_bs_read_u32(bs);\n\n\tif (ptr->entry_count) {\n\t\tu32 i;\n\t\tif (ptr->size / (ptr->version == 0 ? 4 : 8) < ptr->entry_count || (u64)ptr->entry_count > (u64)SIZE_MAX/sizeof(u64))\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\tptr->offsets = gf_malloc(sizeof(u64)*ptr->entry_count);\n\t\tif (!ptr->offsets)\n\t\t\treturn GF_OUT_OF_MEM;\n\t\tptr->entry_alloc = ptr->entry_count;\n\t\tif (ptr->version==0) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 4*ptr->entry_count);\n\t\t\tfor (i=0; i<ptr->entry_count; i++)\n\t\t\t\tptr->offsets[i] = gf_bs_read_u32(bs);\n\t\t} else {\n\t\t\tISOM_DECREASE_SIZE(ptr, 8*ptr->entry_count);\n\t\t\tfor (i=0; i<ptr->entry_count; i++)\n\t\t\t\tptr->offsets[i] = gf_bs_read_u64(bs);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *saio_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleAuxiliaryInfoOffsetBox, GF_ISOM_BOX_TYPE_SAIO);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err saio_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SampleAuxiliaryInfoOffsetBox *ptr = (GF_SampleAuxiliaryInfoOffsetBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tif (ptr->flags & 1) {\n\t\tgf_bs_write_u32(bs, ptr->aux_info_type);\n\t\tgf_bs_write_u32(bs, ptr->aux_info_type_parameter);\n\t}\n\n\n\tgf_bs_write_u32(bs, ptr->entry_count);\n\tif (ptr->entry_count) {\n\t\tu32 i;\n\t\tif (ptr->sai_data) {\n\t\t\tif (ptr->sai_data->sai_offset) {\n\t\t\t\tif (ptr->version==0) {\n\t\t\t\t\tgf_bs_write_u32(bs, (u32) ptr->sai_data->sai_offset);\n\t\t\t\t} else {\n\t\t\t\t\tgf_bs_write_u64(bs, ptr->sai_data->sai_offset);\n\t\t\t\t}\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\tptr->sai_data->saio_box = ptr;\n\t\t}\n\n\t\t//store position in bitstream before writing data - offsets can be NULL if a single offset is rewritten later on (cf senc_box_write)\n\t\tptr->offset_first_offset_field = gf_bs_get_position(bs);\n\t\tif (ptr->version==0) {\n\t\t\tif (!ptr->offsets) {\n\t\t\t\tgf_bs_write_u32(bs, 0);\n\t\t\t} else {\n\t\t\t\tfor (i=0; i<ptr->entry_count; i++)\n\t\t\t\t\tgf_bs_write_u32(bs, (u32) ptr->offsets[i]);\n\t\t\t}\n\t\t} else {\n\t\t\tif (!ptr->offsets) {\n\t\t\t\tgf_bs_write_u64(bs, 0);\n\t\t\t} else {\n\t\t\t\tfor (i=0; i<ptr->entry_count; i++)\n\t\t\t\t\tgf_bs_write_u64(bs, ptr->offsets[i]);\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err saio_box_size(GF_Box *s)\n{\n\tGF_SampleAuxiliaryInfoOffsetBox *ptr = (GF_SampleAuxiliaryInfoOffsetBox*)s;\n\n\tif (ptr->aux_info_type || ptr->aux_info_type_parameter) {\n\t\tptr->flags |= 1;\n\t}\n\n\tif (ptr->flags & 1) ptr->size += 8;\n\tptr->size += 4;\n\t//a little optim here: in cenc, the saio always points to a single data block, only one entry is needed\n\tswitch (ptr->aux_info_type) {\n\tcase GF_ISOM_CENC_SCHEME:\n\tcase GF_ISOM_CBC_SCHEME:\n\tcase GF_ISOM_CENS_SCHEME:\n\tcase GF_ISOM_CBCS_SCHEME:\n\t\tif (ptr->offsets) gf_free(ptr->offsets);\n\t\tptr->offsets = NULL;\n\t\tptr->entry_alloc = 0;\n\t\tptr->entry_count = 1;\n\t\tbreak;\n\t}\n\n\tptr->size += ((ptr->version==1) ? 8 : 4) * ptr->entry_count;\n\treturn GF_OK;\n}\n#endif //GPAC_DISABLE_ISOM_WRITE\n\n\nvoid prft_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err prft_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_ProducerReferenceTimeBox *ptr = (GF_ProducerReferenceTimeBox *) s;\n\n\tISOM_DECREASE_SIZE(ptr, 12);\n\tptr->refTrackID = gf_bs_read_u32(bs);\n\tptr->ntp = gf_bs_read_u64(bs);\n\tif (ptr->version==0) {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->timestamp = gf_bs_read_u32(bs);\n\t} else {\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\tptr->timestamp = gf_bs_read_u64(bs);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *prft_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ProducerReferenceTimeBox, GF_ISOM_BOX_TYPE_PRFT);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err prft_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ProducerReferenceTimeBox *ptr = (GF_ProducerReferenceTimeBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->refTrackID);\n\tgf_bs_write_u64(bs, ptr->ntp);\n\tif (ptr->version==0) {\n\t\tgf_bs_write_u32(bs, (u32) ptr->timestamp);\n\t} else {\n\t\tgf_bs_write_u64(bs, ptr->timestamp);\n\t}\n\n\treturn GF_OK;\n}\n\nGF_Err prft_box_size(GF_Box *s)\n{\n\tGF_ProducerReferenceTimeBox *ptr = (GF_ProducerReferenceTimeBox*)s;\n\n\tptr->size += 4+8+ (ptr->version ? 8 : 4);\n\treturn GF_OK;\n}\n#endif //GPAC_DISABLE_ISOM_WRITE\n\nGF_Box *trgr_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackGroupBox, GF_ISOM_BOX_TYPE_TRGR);\n\ttmp->groups = gf_list_new();\n\tif (!tmp->groups) {\n\t\tgf_free(tmp);\n\t\treturn NULL;\n\t}\n\treturn (GF_Box *)tmp;\n}\n\nvoid trgr_box_del(GF_Box *s)\n{\n\tGF_TrackGroupBox *ptr = (GF_TrackGroupBox *)s;\n\tif (ptr == NULL) return;\n\tgf_list_del(ptr->groups);\n\tgf_free(ptr);\n}\n\n\nGF_Err trgr_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_TrackGroupBox *ptr = (GF_TrackGroupBox *)s;\n\n\tBOX_FIELD_LIST_ASSIGN(groups)\n\treturn GF_OK;\n}\n\n\nGF_Err trgr_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err trgr_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err trgr_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_TrackGroupBox *ptr = (GF_TrackGroupBox *) s;\n\tgf_isom_check_position_list(s, ptr->groups, &pos);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *trgt_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackGroupTypeBox, GF_ISOM_BOX_TYPE_TRGT);\n\treturn (GF_Box *)tmp;\n}\n\nvoid trgt_box_del(GF_Box *s)\n{\n\tGF_TrackGroupTypeBox *ptr = (GF_TrackGroupTypeBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\nGF_Err trgt_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TrackGroupTypeBox *ptr = (GF_TrackGroupTypeBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->track_group_id = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err trgt_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TrackGroupTypeBox *ptr = (GF_TrackGroupTypeBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\tif (ptr->group_type == GF_ISOM_BOX_TYPE_UUID) return GF_BAD_PARAM;\n\ts->type = ptr->group_type;\n\te = gf_isom_full_box_write(s, bs);\n\ts->type = GF_ISOM_BOX_TYPE_TRGT;\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->track_group_id);\n\treturn GF_OK;\n}\n\nGF_Err trgt_box_size(GF_Box *s)\n{\n\tGF_TrackGroupBox *ptr = (GF_TrackGroupBox *)s;\n\n\tptr->size+= 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Box *stvi_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_StereoVideoBox, GF_ISOM_BOX_TYPE_STVI);\n\treturn (GF_Box *)tmp;\n}\n\nvoid stvi_box_del(GF_Box *s)\n{\n\tGF_StereoVideoBox *ptr = (GF_StereoVideoBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->stereo_indication_type) gf_free(ptr->stereo_indication_type);\n\tgf_free(ptr);\n}\n\nGF_Err stvi_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_StereoVideoBox *ptr = (GF_StereoVideoBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 12);\n\tgf_bs_read_int(bs, 30);\n\tptr->single_view_allowed = gf_bs_read_int(bs, 2);\n\tptr->stereo_scheme = gf_bs_read_u32(bs);\n\tptr->sit_len = gf_bs_read_u32(bs);\n\tISOM_DECREASE_SIZE(ptr, ptr->sit_len);\n\n\tptr->stereo_indication_type = gf_malloc(sizeof(char)*ptr->sit_len);\n\tif (!ptr->stereo_indication_type) return GF_OUT_OF_MEM;\n\n\tgf_bs_read_data(bs, ptr->stereo_indication_type, ptr->sit_len);\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stvi_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_StereoVideoBox *ptr = (GF_StereoVideoBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_int(bs, 0, 30);\n\tgf_bs_write_int(bs, ptr->single_view_allowed, 2);\n\tgf_bs_write_u32(bs, ptr->stereo_scheme);\n\tgf_bs_write_u32(bs, ptr->sit_len);\n\tgf_bs_write_data(bs, ptr->stereo_indication_type, ptr->sit_len);\n\n\treturn GF_OK;\n}\n\nGF_Err stvi_box_size(GF_Box *s)\n{\n\tGF_StereoVideoBox *ptr = (GF_StereoVideoBox *)s;\n\n\tptr->size+= 12 + ptr->sit_len;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Box *fiin_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(FDItemInformationBox, GF_ISOM_BOX_TYPE_FIIN);\n\treturn (GF_Box *)tmp;\n}\n\nvoid fiin_box_del(GF_Box *s)\n{\n\tFDItemInformationBox *ptr = (FDItemInformationBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->partition_entries) gf_list_del(ptr->partition_entries);\n\tgf_free(ptr);\n}\n\n\nGF_Err fiin_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tFDItemInformationBox *ptr = (FDItemInformationBox *)s;\n\tswitch(a->type) {\n\tcase GF_ISOM_BOX_TYPE_PAEN:\n\t\tBOX_FIELD_LIST_ASSIGN(partition_entries)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_SEGR:\n\t\tBOX_FIELD_ASSIGN(session_info, FDSessionGroupBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_GITN:\n\t\tBOX_FIELD_ASSIGN(group_id_to_name, GroupIdToNameBox)\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err fiin_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tFDItemInformationBox *ptr = (FDItemInformationBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 2);\n\tgf_bs_read_u16(bs);\n\treturn gf_isom_box_array_read(s, bs);\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err fiin_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tFDItemInformationBox *ptr = (FDItemInformationBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u16(bs, gf_list_count(ptr->partition_entries) );\n\treturn GF_OK;\n}\n\nGF_Err fiin_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tFDItemInformationBox *ptr = (FDItemInformationBox *) s;\n\ts->size+= 2;\n\tgf_isom_check_position_list(s, ptr->partition_entries, &pos);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *paen_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(FDPartitionEntryBox, GF_ISOM_BOX_TYPE_PAEN);\n\treturn (GF_Box *)tmp;\n}\n\nvoid paen_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\n\nGF_Err paen_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tFDPartitionEntryBox *ptr = (FDPartitionEntryBox *)s;\n\tswitch(a->type) {\n\tcase GF_ISOM_BOX_TYPE_FPAR:\n\t\tBOX_FIELD_ASSIGN(blocks_and_symbols, FilePartitionBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_FECR:\n\t\tBOX_FIELD_ASSIGN(FEC_symbol_locations, FECReservoirBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_FIRE:\n\t\tBOX_FIELD_ASSIGN(File_symbol_locations, FileReservoirBox)\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err paen_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err paen_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tif (!s) return GF_BAD_PARAM;\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err paen_box_size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n\nGF_Box *fpar_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(FilePartitionBox, GF_ISOM_BOX_TYPE_FPAR);\n\treturn (GF_Box *)tmp;\n}\n\nvoid fpar_box_del(GF_Box *s)\n{\n\tFilePartitionBox *ptr = (FilePartitionBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->scheme_specific_info) gf_free(ptr->scheme_specific_info);\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);\n}\n\nGF_Err gf_isom_read_null_terminated_string(GF_Box *s, GF_BitStream *bs, u64 size, char **out_str)\n{\n\tu32 len=10;\n\tu32 i=0;\n\n\t*out_str = gf_malloc(sizeof(char)*len);\n\tif (! *out_str) return GF_OUT_OF_MEM;\n\n\tif (!s->size) {\n\t\t*out_str[0] = 0;\n\t\treturn GF_OK;\n\t}\n\n\twhile (1) {\n\t\tISOM_DECREASE_SIZE(s, 1 );\n\t\t(*out_str)[i] = gf_bs_read_u8(bs);\n\t\tif (!(*out_str)[i]) break;\n\t\ti++;\n\t\tif (i==len) {\n\t\t\tlen += 10;\n\t\t\t*out_str = gf_realloc(*out_str, sizeof(char)*len);\n\t\t}\n\t\tif (gf_bs_available(bs) == 0) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] missing null character in null terminated string\\n\"));\n\t\t\t(*out_str)[i] = 0;\n\t\t\treturn GF_OK;\n\t\t}\n\t\tif (i >= size) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] string bigger than container, probably missing null character\\n\"));\n\t\t\t(*out_str)[i] = 0;\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err fpar_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_Err e;\n\tFilePartitionBox *ptr = (FilePartitionBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, ((ptr->version ? 4 : 2) + 12) );\n\tptr->itemID = gf_bs_read_int(bs, ptr->version ? 32 : 16);\n\tptr->packet_payload_size = gf_bs_read_u16(bs);\n\tgf_bs_read_u8(bs);\n\tptr->FEC_encoding_ID = gf_bs_read_u8(bs);\n\tptr->FEC_instance_ID = gf_bs_read_u16(bs);\n\tptr->max_source_block_length = gf_bs_read_u16(bs);\n\tptr->encoding_symbol_length = gf_bs_read_u16(bs);\n\tptr->max_number_of_encoding_symbols = gf_bs_read_u16(bs);\n\n\te = gf_isom_read_null_terminated_string(s, bs, ptr->size, &ptr->scheme_specific_info);\n\tif (e) return e;\n\n\tISOM_DECREASE_SIZE(ptr, (ptr->version ? 4 : 2) );\n\tptr->nb_entries = gf_bs_read_int(bs, ptr->version ? 32 : 16);\n\tif (ptr->nb_entries > ptr->size / 6 || (u64)ptr->nb_entries > (u64)SIZE_MAX/sizeof(FilePartitionEntry))\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tISOM_DECREASE_SIZE(ptr, ptr->nb_entries * 6 );\n\tGF_SAFE_ALLOC_N(ptr->entries, ptr->nb_entries, FilePartitionEntry);\n\tif (!ptr->entries) return GF_OUT_OF_MEM;\n\n\tfor (i=0;i < ptr->nb_entries; i++) {\n\t\tptr->entries[i].block_count = gf_bs_read_u16(bs);\n\t\tptr->entries[i].block_size = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err fpar_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tFilePartitionBox *ptr = (FilePartitionBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_int(bs, ptr->itemID, ptr->version ? 32 : 16);\n\tgf_bs_write_u16(bs, ptr->packet_payload_size);\n\tgf_bs_write_u8(bs, 0);\n\tgf_bs_write_u8(bs, ptr->FEC_encoding_ID);\n\tgf_bs_write_u16(bs, ptr->FEC_instance_ID);\n\tgf_bs_write_u16(bs, ptr->max_source_block_length);\n\tgf_bs_write_u16(bs, ptr->encoding_symbol_length);\n\tgf_bs_write_u16(bs, ptr->max_number_of_encoding_symbols);\n\tif (ptr->scheme_specific_info) {\n\t\tgf_bs_write_data(bs, ptr->scheme_specific_info, (u32)strlen(ptr->scheme_specific_info) );\n\t}\n\t//null terminated string\n\tgf_bs_write_u8(bs, 0);\n\n\tgf_bs_write_int(bs, ptr->nb_entries, ptr->version ? 32 : 16);\n\n\tfor (i=0;i < ptr->nb_entries; i++) {\n\t\tgf_bs_write_u16(bs, ptr->entries[i].block_count);\n\t\tgf_bs_write_u32(bs, ptr->entries[i].block_size);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err fpar_box_size(GF_Box *s)\n{\n\tFilePartitionBox *ptr = (FilePartitionBox *)s;\n\n\tptr->size += 13 + (ptr->version ? 8 : 4);\n\tif (ptr->scheme_specific_info)\n\t\tptr->size += strlen(ptr->scheme_specific_info);\n\n\tptr->size+= ptr->nb_entries * 6;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *fecr_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(FECReservoirBox, GF_ISOM_BOX_TYPE_FECR);\n\treturn (GF_Box *)tmp;\n}\n\nvoid fecr_box_del(GF_Box *s)\n{\n\tFECReservoirBox *ptr = (FECReservoirBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);\n}\n\nGF_Err fecr_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tFECReservoirBox *ptr = (FECReservoirBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, (ptr->version ? 4 : 2) );\n\tptr->nb_entries = gf_bs_read_int(bs, ptr->version ? 32 : 16);\n\n\tif (ptr->nb_entries > ptr->size / (ptr->version ? 8 : 6) || (u64)ptr->nb_entries > (u64)SIZE_MAX/sizeof(FECReservoirEntry) ) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in fecr\\n\", ptr->nb_entries));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tISOM_DECREASE_SIZE(ptr, ptr->nb_entries * (ptr->version ? 8 : 6) );\n\tGF_SAFE_ALLOC_N(ptr->entries, ptr->nb_entries, FECReservoirEntry);\n\tif (!ptr->entries) return GF_OUT_OF_MEM;\n\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tptr->entries[i].item_id = gf_bs_read_int(bs, ptr->version ? 32 : 16);\n\t\tptr->entries[i].symbol_count = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err fecr_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tFECReservoirBox *ptr = (FECReservoirBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_int(bs, ptr->nb_entries, ptr->version ? 32 : 16);\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tgf_bs_write_int(bs, ptr->entries[i].item_id, ptr->version ? 32 : 16);\n\t\tgf_bs_write_u32(bs, ptr->entries[i].symbol_count);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err fecr_box_size(GF_Box *s)\n{\n\tFECReservoirBox *ptr = (FECReservoirBox *)s;\n\tptr->size += (ptr->version ? 4 : 2) +  ptr->nb_entries * (ptr->version ? 8 : 6);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Box *segr_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(FDSessionGroupBox, GF_ISOM_BOX_TYPE_SEGR);\n\treturn (GF_Box *)tmp;\n}\n\nvoid segr_box_del(GF_Box *s)\n{\n\tu32 i;\n\tFDSessionGroupBox *ptr = (FDSessionGroupBox *)s;\n\tif (ptr == NULL) return;\n\tfor (i=0; i<ptr->num_session_groups; i++) {\n\t\tif (ptr->session_groups[i].group_ids) gf_free(ptr->session_groups[i].group_ids);\n\t\tif (ptr->session_groups[i].channels) gf_free(ptr->session_groups[i].channels);\n\t}\n\tif (ptr->session_groups) gf_free(ptr->session_groups);\n\tgf_free(ptr);\n}\n\nGF_Err segr_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i, k;\n\tFDSessionGroupBox *ptr = (FDSessionGroupBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 2);\n\tptr->num_session_groups = gf_bs_read_u16(bs);\n\tif (ptr->size < ptr->num_session_groups) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in segr\\n\", ptr->num_session_groups));\n\t\tptr->num_session_groups = 0;\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tGF_SAFE_ALLOC_N(ptr->session_groups, ptr->num_session_groups, SessionGroupEntry);\n\tif (!ptr->session_groups) return GF_OUT_OF_MEM;\n\n\tfor (i=0; i<ptr->num_session_groups; i++) {\n\t\tptr->session_groups[i].nb_groups = gf_bs_read_u8(bs);\n\t\tISOM_DECREASE_SIZE(ptr, 1);\n\n\t\tISOM_DECREASE_SIZE(ptr, ptr->session_groups[i].nb_groups*4);\n\n\t\tGF_SAFE_ALLOC_N(ptr->session_groups[i].group_ids, ptr->session_groups[i].nb_groups, u32);\n\t\tif (!ptr->session_groups[i].group_ids) return GF_OUT_OF_MEM;\n\n\t\tfor (k=0; k<ptr->session_groups[i].nb_groups; k++) {\n\t\t\tptr->session_groups[i].group_ids[k] = gf_bs_read_u32(bs);\n\t\t}\n\n\t\tptr->session_groups[i].nb_channels = gf_bs_read_u16(bs);\n\t\tISOM_DECREASE_SIZE(ptr, ptr->session_groups[i].nb_channels*4);\n\n\t\tGF_SAFE_ALLOC_N(ptr->session_groups[i].channels, ptr->session_groups[i].nb_channels, u32);\n\t\tif (!ptr->session_groups[i].channels) return GF_OUT_OF_MEM;\n\n\t\tfor (k=0; k<ptr->session_groups[i].nb_channels; k++) {\n\t\t\tptr->session_groups[i].channels[k] = gf_bs_read_u32(bs);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err segr_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i, k;\n\tGF_Err e;\n\tFDSessionGroupBox *ptr = (FDSessionGroupBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u16(bs, ptr->num_session_groups);\n\tfor (i=0; i<ptr->num_session_groups; i++) {\n\t\tgf_bs_write_u8(bs, ptr->session_groups[i].nb_groups);\n\t\tfor (k=0; k<ptr->session_groups[i].nb_groups; k++) {\n\t\t\tgf_bs_write_u32(bs, ptr->session_groups[i].group_ids[k]);\n\t\t}\n\n\t\tgf_bs_write_u16(bs, ptr->session_groups[i].nb_channels);\n\t\tfor (k=0; k<ptr->session_groups[i].nb_channels; k++) {\n\t\t\tgf_bs_write_u32(bs, ptr->session_groups[i].channels[k]);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err segr_box_size(GF_Box *s)\n{\n\tu32 i;\n\tFDSessionGroupBox *ptr = (FDSessionGroupBox *)s;\n\n\tptr->size += 2;\n\n\tfor (i=0; i<ptr->num_session_groups; i++) {\n\t\tptr->size += 1 + 4*ptr->session_groups[i].nb_groups;\n\t\tptr->size += 2 + 4*ptr->session_groups[i].nb_channels;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *gitn_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GroupIdToNameBox, GF_ISOM_BOX_TYPE_GITN);\n\treturn (GF_Box *)tmp;\n}\n\nvoid gitn_box_del(GF_Box *s)\n{\n\tu32 i;\n\tGroupIdToNameBox *ptr = (GroupIdToNameBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->entries) {\n\t\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\t\tif (ptr->entries[i].name) gf_free(ptr->entries[i].name);\n\t\t}\n\t\tgf_free(ptr->entries);\n\t}\n\tgf_free(ptr);\n}\n\nGF_Err gitn_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_Err e;\n\tGroupIdToNameBox *ptr = (GroupIdToNameBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 2);\n\tptr->nb_entries = gf_bs_read_u16(bs);\n\tif (ptr->size / 4 < ptr->nb_entries)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tGF_SAFE_ALLOC_N(ptr->entries, ptr->nb_entries, GroupIdNameEntry);\n\tif (!ptr->entries) return GF_OUT_OF_MEM;\n\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->entries[i].group_id = gf_bs_read_u32(bs);\n\n\t\te = gf_isom_read_null_terminated_string(s, bs, ptr->size, &ptr->entries[i].name);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err gitn_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGroupIdToNameBox *ptr = (GroupIdToNameBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u16(bs, ptr->nb_entries);\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tgf_bs_write_u32(bs, ptr->entries[i].group_id);\n\t\tif (ptr->entries[i].name) gf_bs_write_data(bs, ptr->entries[i].name, (u32)strlen(ptr->entries[i].name) );\n\t\tgf_bs_write_u8(bs, 0);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err gitn_box_size(GF_Box *s)\n{\n\tu32 i;\n\tGroupIdToNameBox *ptr = (GroupIdToNameBox *)s;\n\tptr->size += 2;\n\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tptr->size += 5;\n\t\tif (ptr->entries[i].name) ptr->size += strlen(ptr->entries[i].name);\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#ifndef GPAC_DISABLE_ISOM_HINTING\n\nGF_Box *fdpa_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_FDpacketBox, GF_ISOM_BOX_TYPE_FDPA);\n\treturn (GF_Box *)tmp;\n}\n\nvoid fdpa_box_del(GF_Box *s)\n{\n\tu32 i;\n\tGF_FDpacketBox *ptr = (GF_FDpacketBox *)s;\n\tif (ptr == NULL) return;\n\n\tif (ptr->headers) {\n\t\tfor (i=0; i<ptr->header_ext_count; i++) {\n\t\t\tif (ptr->headers[i].data) gf_free(ptr->headers[i].data);\n\t\t}\n\t\tgf_free(ptr->headers);\n\t}\n\tgf_free(ptr);\n}\n\nGF_Err fdpa_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_FDpacketBox *ptr = (GF_FDpacketBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 3);\n\tptr->info.sender_current_time_present = gf_bs_read_int(bs, 1);\n\tptr->info.expected_residual_time_present = gf_bs_read_int(bs, 1);\n\tptr->info.session_close_bit = gf_bs_read_int(bs, 1);\n\tptr->info.object_close_bit = gf_bs_read_int(bs, 1);\n\tgf_bs_read_int(bs, 4);\n\tptr->info.transport_object_identifier = gf_bs_read_u16(bs);\n\tISOM_DECREASE_SIZE(ptr, 2);\n\tptr->header_ext_count = gf_bs_read_u16(bs);\n\tif (ptr->size / 2 < ptr->header_ext_count) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in fdpa\\n\", ptr->header_ext_count));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tGF_SAFE_ALLOC_N(ptr->headers, ptr->header_ext_count, GF_LCTheaderExtension);\n\tif (!ptr->headers) return GF_OUT_OF_MEM;\n\n\tfor (i=0; i<ptr->header_ext_count; i++) {\n\t\tptr->headers[i].header_extension_type = gf_bs_read_u8(bs);\n\t\tISOM_DECREASE_SIZE(ptr, 1);\n\n\t\tif (ptr->headers[i].header_extension_type > 127) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 3);\n\t\t\tgf_bs_read_data(bs, (char *) ptr->headers[i].content, 3);\n\t\t} else {\n\t\t\tISOM_DECREASE_SIZE(ptr, 1);\n\t\t\tptr->headers[i].data_length = gf_bs_read_u8(bs);\n\t\t\tif (ptr->headers[i].data_length) {\n\t\t\t\tptr->headers[i].data_length = 4*ptr->headers[i].data_length - 2;\n\t\t\t\tif (ptr->size < sizeof(char) * ptr->headers[i].data_length)\n\t\t\t\t    return GF_ISOM_INVALID_FILE;\n\t\t\t\tptr->headers[i].data = gf_malloc(sizeof(char) * ptr->headers[i].data_length);\n\t\t\t\tif (!ptr->headers[i].data) return GF_OUT_OF_MEM;\n\n\t\t\t\tISOM_DECREASE_SIZE(ptr, ptr->headers[i].data_length);\n\t\t\t\tgf_bs_read_data(bs, ptr->headers[i].data, ptr->headers[i].data_length);\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err fdpa_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_FDpacketBox *ptr = (GF_FDpacketBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_int(bs, ptr->info.sender_current_time_present, 1);\n\tgf_bs_write_int(bs, ptr->info.expected_residual_time_present, 1);\n\tgf_bs_write_int(bs, ptr->info.session_close_bit, 1);\n\tgf_bs_write_int(bs, ptr->info.object_close_bit, 1);\n\tgf_bs_write_int(bs, 0, 4);\n\tgf_bs_write_u16(bs, ptr->info.transport_object_identifier);\n\tgf_bs_write_u16(bs, ptr->header_ext_count);\n\tfor (i=0; i<ptr->header_ext_count; i++) {\n\t\tgf_bs_write_u8(bs, ptr->headers[i].header_extension_type);\n\t\tif (ptr->headers[i].header_extension_type > 127) {\n\t\t\tgf_bs_write_data(bs, (const char *) ptr->headers[i].content, 3);\n\t\t} else {\n\t\t\tgf_bs_write_u8(bs, ptr->headers[i].data_length ? (ptr->headers[i].data_length+2)/4 : 0);\n\t\t\tif (ptr->headers[i].data_length) {\n\t\t\t\tgf_bs_write_data(bs, ptr->headers[i].data, ptr->headers[i].data_length);\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err fdpa_box_size(GF_Box *s)\n{\n\tu32 i;\n\tGF_FDpacketBox *ptr = (GF_FDpacketBox *)s;\n\n\tptr->size += 5;\n\n\tfor (i=0; i<ptr->header_ext_count; i++) {\n\t\tptr->size += 1;\n\t\tif (ptr->headers[i].header_extension_type > 127) {\n\t\t\tptr->size += 3;\n\t\t} else {\n\t\t\tptr->size += 1 + ptr->headers[i].data_length;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *extr_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ExtraDataBox, GF_ISOM_BOX_TYPE_EXTR);\n\treturn (GF_Box *)tmp;\n}\n\nvoid extr_box_del(GF_Box *s)\n{\n\tGF_ExtraDataBox *ptr = (GF_ExtraDataBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->feci) gf_isom_box_del((GF_Box*)ptr->feci);\n\tif (ptr->data) gf_free(ptr->data);\n\tgf_free(ptr);\n}\n\nGF_Err extr_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ExtraDataBox *ptr = (GF_ExtraDataBox *)s;\n\n\te = gf_isom_box_parse((GF_Box**) &ptr->feci, bs);\n\tif (e) return e;\n\tif (!ptr->feci || ptr->feci->size > ptr->size) return GF_ISOM_INVALID_MEDIA;\n\tptr->data_length = (u32) (ptr->size - ptr->feci->size);\n\tptr->data = gf_malloc(sizeof(char)*ptr->data_length);\n\tif (!ptr->data) return GF_OUT_OF_MEM;\n\tgf_bs_read_data(bs, ptr->data, ptr->data_length);\n\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err extr_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ExtraDataBox *ptr = (GF_ExtraDataBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tif (ptr->feci) {\n\t\te = gf_isom_box_write((GF_Box *)ptr->feci, bs);\n\t\tif (e) return e;\n\t}\n\tgf_bs_write_data(bs, ptr->data, ptr->data_length);\n\treturn GF_OK;\n}\n\nGF_Err extr_box_size(GF_Box *s)\n{\n\tGF_ExtraDataBox *ptr = (GF_ExtraDataBox *) s;\n\tptr->size += ptr->data_length;\n\tif (ptr->feci) {\n\t\tGF_Err e = gf_isom_box_size((GF_Box*)ptr->feci);\n\t\tif (e) return e;\n\t\tptr->size += ptr->feci->size;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Box *fdsa_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_HintSample, GF_ISOM_BOX_TYPE_FDSA);\n\tif (!tmp) return NULL;\n\ttmp->packetTable = gf_list_new();\n\ttmp->hint_subtype = GF_ISOM_BOX_TYPE_FDP_STSD;\n\treturn (GF_Box*)tmp;\n}\n\nvoid fdsa_box_del(GF_Box *s)\n{\n\tGF_HintSample *ptr = (GF_HintSample *)s;\n\tgf_list_del(ptr->packetTable);\n\tgf_free(ptr);\n}\n\nGF_Err fdsa_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_HintSample *ptr = (GF_HintSample *)s;\n\tswitch(a->type) {\n\tcase GF_ISOM_BOX_TYPE_FDPA:\n\t\tBOX_FIELD_LIST_ASSIGN(packetTable)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_EXTR:\n\t\tBOX_FIELD_ASSIGN(extra_data, GF_ExtraDataBox)\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\nGF_Err fdsa_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err fdsa_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_HintSample *ptr = (GF_HintSample *) s;\n\tif (!s) return GF_BAD_PARAM;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\te = gf_isom_box_array_write(s, ptr->packetTable, bs);\n\tif (e) return e;\n\tif (ptr->extra_data) {\n\t\te = gf_isom_box_write((GF_Box *)ptr->extra_data, bs);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err fdsa_box_size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM_HINTING*/\n\n\nvoid trik_box_del(GF_Box *s)\n{\n\tGF_TrickPlayBox *ptr = (GF_TrickPlayBox *) s;\n\tif (ptr == NULL) return;\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);\n}\n\nGF_Err trik_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_TrickPlayBox *ptr = (GF_TrickPlayBox *) s;\n\tptr->entry_count = (u32) ptr->size;\n\tif ((u64)ptr->entry_count > (u64)SIZE_MAX/sizeof(GF_TrickPlayBoxEntry)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid size %llu in trik\\n\", ptr->size));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tptr->entries = (GF_TrickPlayBoxEntry *) gf_malloc(ptr->entry_count * sizeof(GF_TrickPlayBoxEntry) );\n\tif (!ptr->entries) return GF_OUT_OF_MEM;\n\n\tfor (i=0; i< ptr->entry_count; i++) {\n\t\tptr->entries[i].pic_type = gf_bs_read_int(bs, 2);\n\t\tptr->entries[i].dependency_level = gf_bs_read_int(bs, 6);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *trik_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrickPlayBox, GF_ISOM_BOX_TYPE_TRIK);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err trik_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_TrickPlayBox *ptr = (GF_TrickPlayBox *) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tfor (i=0; i < ptr->entry_count; i++ ) {\n\t\tgf_bs_write_int(bs, ptr->entries[i].pic_type, 2);\n\t\tgf_bs_write_int(bs, ptr->entries[i].dependency_level, 6);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err trik_box_size(GF_Box *s)\n{\n\tGF_TrickPlayBox *ptr = (GF_TrickPlayBox *) s;\n\tptr->size += 8 * ptr->entry_count;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid bloc_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err bloc_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_BaseLocationBox *ptr = (GF_BaseLocationBox *) s;\n\n\tISOM_DECREASE_SIZE(s, 256)\n\tgf_bs_read_data(bs, (char *) ptr->baseLocation, 256);\n\tptr->baseLocation[256]=0;\n\tISOM_DECREASE_SIZE(s, 256)\n\tgf_bs_read_data(bs, (char *) ptr->basePurlLocation, 256);\n\tISOM_DECREASE_SIZE(s, 512)\n\tptr->basePurlLocation[256]=0;\n\tgf_bs_skip_bytes(bs, 512);\n\treturn GF_OK;\n}\n\nGF_Box *bloc_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_BaseLocationBox, GF_ISOM_BOX_TYPE_BLOC);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err bloc_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_BaseLocationBox *ptr = (GF_BaseLocationBox *) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_data(bs, (const char *) ptr->baseLocation, 256);\n\tgf_bs_write_data(bs, (const char *) ptr->basePurlLocation, 256);\n\tfor (i=0; i < 64; i++ ) {\n\t\tgf_bs_write_u64(bs, 0);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err bloc_box_size(GF_Box *s)\n{\n\ts->size += 1024;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid ainf_box_del(GF_Box *s)\n{\n\tGF_AssetInformationBox *ptr = (GF_AssetInformationBox *) s;\n\tif (ptr->APID) gf_free(ptr->APID);\n\tgf_free(s);\n}\n\nGF_Err ainf_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_AssetInformationBox *ptr = (GF_AssetInformationBox *) s;\n\n\tISOM_DECREASE_SIZE(s, 4)\n\tptr->profile_version = gf_bs_read_u32(bs);\n\treturn gf_isom_read_null_terminated_string(s, bs, s->size, &ptr->APID);\n}\n\nGF_Box *ainf_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_AssetInformationBox, GF_ISOM_BOX_TYPE_AINF);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err ainf_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_AssetInformationBox *ptr = (GF_AssetInformationBox *) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->profile_version);\n    if (ptr->APID)\n        gf_bs_write_data(bs, ptr->APID, (u32) strlen(ptr->APID) );\n    gf_bs_write_u8(bs, 0);\n\treturn GF_OK;\n}\n\nGF_Err ainf_box_size(GF_Box *s)\n{\n\tGF_AssetInformationBox *ptr = (GF_AssetInformationBox *) s;\n    s->size += 4 + (ptr->APID ? strlen(ptr->APID) : 0 ) + 1;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid mhac_box_del(GF_Box *s)\n{\n\tGF_MHAConfigBox *ptr = (GF_MHAConfigBox *) s;\n\tif (ptr->mha_config) gf_free(ptr->mha_config);\n\tgf_free(s);\n}\n\nGF_Err mhac_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_MHAConfigBox *ptr = (GF_MHAConfigBox *) s;\n\n\tISOM_DECREASE_SIZE(s, 5)\n\tptr->configuration_version = gf_bs_read_u8(bs);\n\tptr->mha_pl_indication = gf_bs_read_u8(bs);\n\tptr->reference_channel_layout = gf_bs_read_u8(bs);\n\tptr->mha_config_size = gf_bs_read_u16(bs);\n\tif (ptr->mha_config_size) {\n\t\tISOM_DECREASE_SIZE(s, ptr->mha_config_size)\n\n\t\tptr->mha_config = gf_malloc(sizeof(char)*ptr->mha_config_size);\n\t\tif (!ptr->mha_config) return GF_OUT_OF_MEM;\n\n\t\tgf_bs_read_data(bs, ptr->mha_config, ptr->mha_config_size);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *mhac_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MHAConfigBox, GF_ISOM_BOX_TYPE_MHAC);\n\ttmp->configuration_version = 1;\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err mhac_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MHAConfigBox *ptr = (GF_MHAConfigBox *) s;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u8(bs, ptr->configuration_version);\n\tgf_bs_write_u8(bs, ptr->mha_pl_indication);\n\tgf_bs_write_u8(bs, ptr->reference_channel_layout);\n\tgf_bs_write_u16(bs, ptr->mha_config ? ptr->mha_config_size : 0);\n\tif (ptr->mha_config && ptr->mha_config_size)\n\t\tgf_bs_write_data(bs, ptr->mha_config, ptr->mha_config_size);\n\n\treturn GF_OK;\n}\n\nGF_Err mhac_box_size(GF_Box *s)\n{\n\tGF_MHAConfigBox *ptr = (GF_MHAConfigBox *) s;\n\ts->size += 5;\n\tif (ptr->mha_config_size && ptr->mha_config) s->size += ptr->mha_config_size;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid mhap_box_del(GF_Box *s)\n{\n\tGF_MHACompatibleProfilesBox *ptr = (GF_MHACompatibleProfilesBox *) s;\n\tif (ptr->compat_profiles) gf_free(ptr->compat_profiles);\n\tgf_free(s);\n}\n\nGF_Err mhap_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_MHACompatibleProfilesBox *ptr = (GF_MHACompatibleProfilesBox *) s;\n\n\tISOM_DECREASE_SIZE(s, 1)\n\tptr->num_profiles = gf_bs_read_u8(bs);\n\tif (!ptr->num_profiles) return GF_OK;\n\n\tISOM_DECREASE_SIZE(s, ptr->num_profiles)\n\tptr->compat_profiles = gf_malloc(sizeof(u8) * ptr->num_profiles);\n\tif (!ptr->compat_profiles) return GF_OUT_OF_MEM;\n\tfor (i=0; i<ptr->num_profiles; i++) {\n\t\tptr->compat_profiles[i] = gf_bs_read_u8(bs);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *mhap_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MHACompatibleProfilesBox, GF_ISOM_BOX_TYPE_MHAP);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err mhap_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_Err e;\n\tGF_MHACompatibleProfilesBox *ptr = (GF_MHACompatibleProfilesBox *) s;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u8(bs, ptr->num_profiles);\n\tfor (i=0; i<ptr->num_profiles; i++) {\n\t\tgf_bs_write_u8(bs, ptr->compat_profiles[i]);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err mhap_box_size(GF_Box *s)\n{\n\tGF_MHACompatibleProfilesBox *ptr = (GF_MHACompatibleProfilesBox *) s;\n\ts->size += 1 + ptr->num_profiles;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid jp2h_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err jp2h_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_J2KHeaderBox *ptr = (GF_J2KHeaderBox *)s;\n\tswitch(a->type) {\n\tcase GF_ISOM_BOX_TYPE_IHDR:\n\t\tBOX_FIELD_ASSIGN(ihdr, GF_J2KImageHeaderBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_COLR:\n\t\tBOX_FIELD_ASSIGN(colr, GF_ColourInformationBox)\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\nGF_Err jp2h_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *jp2h_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_J2KHeaderBox, GF_ISOM_BOX_TYPE_JP2H);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err jp2h_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err jp2h_box_size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid ihdr_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err ihdr_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_J2KImageHeaderBox *ptr = (GF_J2KImageHeaderBox *) s;\n\n\tISOM_DECREASE_SIZE(s, 14)\n\n\tptr->height = gf_bs_read_u32(bs);\n\tptr->width = gf_bs_read_u32(bs);\n\tptr->nb_comp = gf_bs_read_u16(bs);\n\tptr->bpc = gf_bs_read_u8(bs);\n\tptr->Comp = gf_bs_read_u8(bs);\n\tptr->UnkC = gf_bs_read_u8(bs);\n\tptr->IPR = gf_bs_read_u8(bs);\n\n\treturn GF_OK;\n}\n\nGF_Box *ihdr_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_J2KImageHeaderBox, GF_ISOM_BOX_TYPE_IHDR);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err ihdr_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_J2KImageHeaderBox *ptr = (GF_J2KImageHeaderBox *) s;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->height);\n\tgf_bs_write_u32(bs, ptr->width);\n\tgf_bs_write_u16(bs, ptr->nb_comp);\n\tgf_bs_write_u8(bs, ptr->bpc);\n\tgf_bs_write_u8(bs, ptr->Comp);\n\tgf_bs_write_u8(bs, ptr->UnkC);\n\tgf_bs_write_u8(bs, ptr->IPR);\n\treturn GF_OK;\n}\n\nGF_Err ihdr_box_size(GF_Box *s)\n{\n\ts->size += 14;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/* Dolby Vision */\n\nGF_Box *dvcC_box_new()\n{\n\tGF_DOVIConfigurationBox *tmp = (GF_DOVIConfigurationBox *)gf_malloc(sizeof(GF_DOVIConfigurationBox));\n\tif (tmp == NULL) return NULL;\n\tmemset(tmp, 0, sizeof(GF_DOVIConfigurationBox));\n\ttmp->type = GF_ISOM_BOX_TYPE_DVCC;\n\treturn (GF_Box *)tmp;\n}\n\nvoid dvcC_box_del(GF_Box *s)\n{\n\tGF_DOVIConfigurationBox *ptr = (GF_DOVIConfigurationBox*)s;\n\tgf_free(ptr);\n}\n\nGF_Err dvcC_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_DOVIConfigurationBox *ptr = (GF_DOVIConfigurationBox *)s;\n\n\t//GF_DOVIDecoderConfigurationRecord\n\tISOM_DECREASE_SIZE(ptr, 24)\n\tptr->DOVIConfig.dv_version_major = gf_bs_read_u8(bs);\n\tptr->DOVIConfig.dv_version_minor = gf_bs_read_u8(bs);\n\tptr->DOVIConfig.dv_profile = gf_bs_read_int(bs, 7);\n\tptr->DOVIConfig.dv_level = gf_bs_read_int(bs, 6);\n\tptr->DOVIConfig.rpu_present_flag = gf_bs_read_int(bs, 1);\n\tptr->DOVIConfig.el_present_flag = gf_bs_read_int(bs, 1);\n\tptr->DOVIConfig.bl_present_flag = gf_bs_read_int(bs, 1);\n\tptr->DOVIConfig.dv_bl_signal_compatibility_id = gf_bs_read_int(bs, 4);\n\tif (gf_bs_read_int(bs, 28) != 0)\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] dvcC reserved bits are not zero\\n\"));\n\n\tfor (i = 0; i < 4; i++) {\n\t\tif (gf_bs_read_u32(bs) != 0) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] dvcC reserved bits are not zero\\n\"));\n\t\t}\n\t}\n\tswitch (ptr->DOVIConfig.dv_bl_signal_compatibility_id) {\n\tcase 0:\n\tcase 1:\n\tcase 2:\n\tcase 4:\n\tcase 6:\n\t\tbreak;\n\tdefault:\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] dvcC compatibility ID %d is not valid (only 0, 1, 2, 4 or 6 defined), patching to 0\\n\", ptr->DOVIConfig.dv_bl_signal_compatibility_id));\n\t\tptr->DOVIConfig.dv_bl_signal_compatibility_id = 0;\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err dvcC_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_DOVIConfigurationBox *ptr = (GF_DOVIConfigurationBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\t//GF_DOVIDecoderConfigurationRecord\n\tgf_bs_write_u8(bs,  ptr->DOVIConfig.dv_version_major);\n\tgf_bs_write_u8(bs,  ptr->DOVIConfig.dv_version_minor);\n\tgf_bs_write_int(bs, ptr->DOVIConfig.dv_profile, 7);\n\tgf_bs_write_int(bs, ptr->DOVIConfig.dv_level, 6);\n\tgf_bs_write_int(bs, ptr->DOVIConfig.rpu_present_flag, 1);\n\tgf_bs_write_int(bs, ptr->DOVIConfig.el_present_flag, 1);\n\tgf_bs_write_int(bs, ptr->DOVIConfig.bl_present_flag, 1);\n\tgf_bs_write_int(bs, ptr->DOVIConfig.dv_bl_signal_compatibility_id, 4);\n\tgf_bs_write_int(bs, 0, 28);\n\tgf_bs_write_u32(bs, 0);\n\tgf_bs_write_u32(bs, 0);\n\tgf_bs_write_u32(bs, 0);\n\tgf_bs_write_u32(bs, 0);\n\n\treturn GF_OK;\n}\n\nGF_Err dvcC_box_size(GF_Box *s)\n{\n\tGF_DOVIConfigurationBox *ptr = (GF_DOVIConfigurationBox *)s;\n\n\tptr->size += 24;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *dvvC_box_new()\n{\n\tGF_DOVIConfigurationBox *tmp = (GF_DOVIConfigurationBox *)gf_malloc(sizeof(GF_DOVIConfigurationBox));\n\tif (tmp == NULL) return NULL;\n\tmemset(tmp, 0, sizeof(GF_DOVIConfigurationBox));\n\ttmp->type = GF_ISOM_BOX_TYPE_DVVC;\n\treturn (GF_Box *)tmp;\n}\n\nvoid dvvC_box_del(GF_Box *s)\n{\n\tGF_DOVIConfigurationBox *ptr = (GF_DOVIConfigurationBox*)s;\n\tgf_free(ptr);\n}\n\nGF_Err dvvC_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn dvcC_box_read(s, bs);\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err dvvC_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn dvcC_box_write(s, bs);\n}\n\nGF_Err dvvC_box_size(GF_Box *s)\n{\n\treturn dvcC_box_size(s);\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *dOps_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_OpusSpecificBox, GF_ISOM_BOX_TYPE_DOPS);\n\treturn (GF_Box *)tmp;\n}\n\nvoid dOps_box_del(GF_Box *s)\n{\n\tGF_OpusSpecificBox *ptr = (GF_OpusSpecificBox *)s;\n\tif (ptr) gf_free(ptr);\n}\n\n//we don't use odf_opus_cfg read due to endianness\nGF_Err dOps_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_OpusSpecificBox *ptr = (GF_OpusSpecificBox *)s;\n\tptr->opcfg.version = gf_bs_read_u8(bs);\n\tif (ptr->opcfg.version) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[IsoMedia] Opus config version not 0 !\\n\", ptr->size));\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\t//force version to 1 as used in ogg/opus\n\tptr->opcfg.version = 1;\n\tptr->opcfg.OutputChannelCount = gf_bs_read_u8(bs);\n\tptr->opcfg.PreSkip = gf_bs_read_u16(bs);\n\tptr->opcfg.InputSampleRate = gf_bs_read_u32(bs);\n\tptr->opcfg.OutputGain = gf_bs_read_u16(bs);\n\tptr->opcfg.ChannelMappingFamily = gf_bs_read_u8(bs);\n\tISOM_DECREASE_SIZE(ptr, 11)\n\tif (ptr->size) {\n\t\tISOM_DECREASE_SIZE(ptr, 2+ptr->opcfg.OutputChannelCount);\n\t\tptr->opcfg.StreamCount = gf_bs_read_u8(bs);\n\t\tptr->opcfg.CoupledCount = gf_bs_read_u8(bs);\n\t\tgf_bs_read_data(bs, (char *) ptr->opcfg.ChannelMapping, ptr->opcfg.OutputChannelCount);\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n//we don't use odf_opus_cfg write due to endianness\nGF_Err dOps_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_OpusSpecificBox *ptr = (GF_OpusSpecificBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\t//we always write 0 - the version may also be set to 1 when fed from ffenc or opus+ogg\n\tgf_bs_write_u8(bs, /*ptr->opcfg.version*/ 0);\n\tgf_bs_write_u8(bs, ptr->opcfg.OutputChannelCount);\n\tgf_bs_write_u16(bs, ptr->opcfg.PreSkip);\n\tgf_bs_write_u32(bs, ptr->opcfg.InputSampleRate);\n\tgf_bs_write_u16(bs, ptr->opcfg.OutputGain);\n\tgf_bs_write_u8(bs, ptr->opcfg.ChannelMappingFamily);\n\tif (ptr->opcfg.ChannelMappingFamily) {\n\t\tgf_bs_write_u8(bs, ptr->opcfg.StreamCount);\n\t\tgf_bs_write_u8(bs, ptr->opcfg.CoupledCount);\n\t\tgf_bs_write_data(bs, (char *) ptr->opcfg.ChannelMapping, ptr->opcfg.OutputChannelCount);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err dOps_box_size(GF_Box *s)\n{\n\tGF_OpusSpecificBox *ptr = (GF_OpusSpecificBox *)s;\n\tptr->size += 11;\n\tif (ptr->opcfg.ChannelMappingFamily)\n\t\tptr->size += 2 + ptr->opcfg.OutputChannelCount;\n\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid dfla_box_del(GF_Box *s)\n{\n\tGF_FLACConfigBox *ptr = (GF_FLACConfigBox *) s;\n\tif (ptr->data) gf_free(ptr->data);\n\tgf_free(ptr);\n}\n\nGF_Err dfla_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_FLACConfigBox *ptr = (GF_FLACConfigBox *) s;\n\tptr->dataSize = (u32) ptr->size;\n\tptr->size=0;\n\tptr->data = gf_malloc(ptr->dataSize);\n\tgf_bs_read_data(bs, ptr->data, ptr->dataSize);\n\treturn GF_OK;\n}\n\nGF_Box *dfla_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_FLACConfigBox, GF_ISOM_BOX_TYPE_DFLA);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err dfla_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_FLACConfigBox *ptr = (GF_FLACConfigBox *) s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_data(bs, ptr->data, ptr->dataSize);\n\treturn GF_OK;\n}\n\nGF_Err dfla_box_size(GF_Box *s)\n{\n\tGF_FLACConfigBox *ptr = (GF_FLACConfigBox *) s;\n\tptr->size += ptr->dataSize;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid mvcg_box_del(GF_Box *s)\n{\n\tGF_MultiviewGroupBox *ptr = (GF_MultiviewGroupBox *) s;\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);\n}\n\nGF_Err mvcg_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_MultiviewGroupBox *ptr = (GF_MultiviewGroupBox *) s;\n\tISOM_DECREASE_SIZE(s, 7)\n\tptr->multiview_group_id = gf_bs_read_u32(bs);\n\tptr->num_entries = gf_bs_read_u16(bs);\n\tgf_bs_read_u8(bs);\n\tptr->entries = gf_malloc(ptr->num_entries * sizeof(MVCIEntry));\n\tmemset(ptr->entries, 0, ptr->num_entries * sizeof(MVCIEntry));\n\tfor (i=0; i<ptr->num_entries; i++) {\n\t\tISOM_DECREASE_SIZE(s, 1)\n\t\tptr->entries[i].entry_type = gf_bs_read_u8(bs);\n\t\tswitch (ptr->entries[i].entry_type) {\n\t\tcase 0:\n\t\t\tISOM_DECREASE_SIZE(s, 4)\n\t\t\tptr->entries[i].trackID = gf_bs_read_u32(bs);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tISOM_DECREASE_SIZE(s, 6)\n\t\t\tptr->entries[i].trackID = gf_bs_read_u32(bs);\n\t\t\tptr->entries[i].tierID = gf_bs_read_u16(bs);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tISOM_DECREASE_SIZE(s, 2)\n\t\t\tgf_bs_read_int(bs, 6);\n\t\t\tptr->entries[i].output_view_id = gf_bs_read_int(bs, 10);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tISOM_DECREASE_SIZE(s, 4)\n\t\t\tgf_bs_read_int(bs, 6)\t;\n\t\t\tptr->entries[i].start_view_id = gf_bs_read_int(bs, 10);\n\t\t\tptr->entries[i].view_count = gf_bs_read_u16(bs);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nGF_Box *mvcg_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MultiviewGroupBox, GF_ISOM_BOX_TYPE_MVCG);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err mvcg_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_MultiviewGroupBox *ptr = (GF_MultiviewGroupBox *) s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\n\tgf_bs_write_u32(bs, ptr->multiview_group_id);\n\tgf_bs_write_u16(bs, ptr->num_entries);\n\tgf_bs_write_u8(bs, 0);\n\n\tfor (i=0; i<ptr->num_entries; i++) {\n\t\tgf_bs_write_u8(bs, ptr->entries[i].entry_type);\n\t\tswitch (ptr->entries[i].entry_type) {\n\t\tcase 0:\n\t\t\tgf_bs_write_u32(bs, ptr->entries[i].trackID);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tgf_bs_write_u32(bs, ptr->entries[i].trackID);\n\t\t\tgf_bs_write_u16(bs, ptr->entries[i].tierID);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tgf_bs_write_int(bs, 0, 6);\n\t\t\tgf_bs_write_int(bs, ptr->entries[i].output_view_id, 10);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tgf_bs_write_int(bs, 0, 6)\t;\n\t\t\tgf_bs_write_int(bs, ptr->entries[i].start_view_id, 10);\n\t\t\tgf_bs_write_u16(bs, ptr->entries[i].view_count);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err mvcg_box_size(GF_Box *s)\n{\n\tu32 i;\n\tGF_MultiviewGroupBox *ptr = (GF_MultiviewGroupBox *) s;\n\n\tptr->size += 7;\n\tfor (i=0; i<ptr->num_entries; i++) {\n\t\tswitch (ptr->entries[i].entry_type) {\n\t\tcase 0:\n\t\t\tptr->size += 1 + 4;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tptr->size += 1 + 6;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tptr->size += 1 + 2;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tptr->size += 1 + 4;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid vwid_box_del(GF_Box *s)\n{\n\tu32 i;\n\tGF_ViewIdentifierBox *ptr = (GF_ViewIdentifierBox *) s;\n\tif (ptr->views) {\n\t\tfor (i=0; i<ptr->num_views; i++) {\n\t\t\tif (ptr->views[i].view_refs)\n\t\t\t\tgf_free(ptr->views[i].view_refs);\n\t\t}\n\t\tgf_free(ptr->views);\n\t}\n\tgf_free(ptr);\n}\n\nGF_Err vwid_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_ViewIdentifierBox *ptr = (GF_ViewIdentifierBox *) s;\n\tISOM_DECREASE_SIZE(s, 3)\n\tgf_bs_read_int(bs, 2);\n\tptr->min_temporal_id = gf_bs_read_int(bs, 3);\n\tptr->max_temporal_id = gf_bs_read_int(bs, 3);\n\tptr->num_views = gf_bs_read_u16(bs);\n\tif (ptr->num_views > ptr->size / 6)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tptr->views = gf_malloc(sizeof(ViewIDEntry)*ptr->num_views);\n\tmemset(ptr->views, 0, sizeof(ViewIDEntry)*ptr->num_views);\n\tfor (i=0; i<ptr->num_views; i++) {\n\t\tu32 j;\n\t\tISOM_DECREASE_SIZE(s, 6)\n\n\t\tgf_bs_read_int(bs, 6);\n\t\tptr->views[i].view_id = gf_bs_read_int(bs, 10);\n\t\tgf_bs_read_int(bs, 6);\n\t\tptr->views[i].view_order_index = gf_bs_read_int(bs, 10);\n\t\tptr->views[i].texture_in_stream = gf_bs_read_int(bs, 1);\n\t\tptr->views[i].texture_in_track = gf_bs_read_int(bs, 1);\n\t\tptr->views[i].depth_in_stream = gf_bs_read_int(bs, 1);\n\t\tptr->views[i].depth_in_track = gf_bs_read_int(bs, 1);\n\t\tptr->views[i].base_view_type = gf_bs_read_int(bs, 2);\n\t\tptr->views[i].num_ref_views = gf_bs_read_int(bs, 10);\n\n\t\tif (ptr->views[i].num_ref_views > ptr->size / 2)\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\n\t\tptr->views[i].view_refs = gf_malloc(sizeof(ViewIDRefViewEntry)*ptr->views[i].num_ref_views);\n\t\tfor (j=0; j<ptr->views[i].num_ref_views; j++) {\n\t\t\tISOM_DECREASE_SIZE(s, 2)\n\t\t\tgf_bs_read_int(bs, 4);\n\t\t\tptr->views[i].view_refs[j].dep_comp_idc = gf_bs_read_int(bs, 2);\n\t\t\tptr->views[i].view_refs[j].ref_view_id = gf_bs_read_int(bs, 10);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *vwid_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ViewIdentifierBox, GF_ISOM_BOX_TYPE_VWID);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err vwid_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i, j;\n\tGF_ViewIdentifierBox *ptr = (GF_ViewIdentifierBox *) s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_int(bs, 0, 2);\n\tgf_bs_write_int(bs, ptr->min_temporal_id, 3);\n\tgf_bs_write_int(bs, ptr->max_temporal_id, 3);\n\tgf_bs_write_u16(bs, ptr->num_views);\n\n\tfor (i=0; i<ptr->num_views; i++) {\n\t\tgf_bs_write_int(bs, 0, 6);\n\t\tgf_bs_write_int(bs, ptr->views[i].view_id, 10);\n\t\tgf_bs_write_int(bs, 0, 6);\n\t\tgf_bs_write_int(bs, ptr->views[i].view_order_index, 10);\n\n\t\tgf_bs_write_int(bs, ptr->views[i].texture_in_stream, 1);\n\t\tgf_bs_write_int(bs, ptr->views[i].texture_in_track, 1);\n\t\tgf_bs_write_int(bs, ptr->views[i].depth_in_stream, 1);\n\t\tgf_bs_write_int(bs, ptr->views[i].depth_in_track, 1);\n\t\tgf_bs_write_int(bs, ptr->views[i].base_view_type, 2);\n\t\tgf_bs_write_int(bs, ptr->views[i].num_ref_views, 10);\n\n\t\tfor (j=0; j<ptr->views[i].num_ref_views; j++) {\n\t\t\tgf_bs_write_int(bs, 0, 4);\n\t\t\tgf_bs_write_int(bs, ptr->views[i].view_refs[j].dep_comp_idc, 2);\n\t\t\tgf_bs_write_int(bs, ptr->views[i].view_refs[j].ref_view_id, 10);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err vwid_box_size(GF_Box *s)\n{\n\tu32 i;\n\tGF_ViewIdentifierBox *ptr = (GF_ViewIdentifierBox *) s;\n\tptr->size += 3;\n\tfor (i=0; i<ptr->num_views; i++) {\n\t\tptr->size += 6 + 2 * ptr->views[i].num_ref_views;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid pcmC_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err pcmC_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_PCMConfigBox *ptr = (GF_PCMConfigBox *) s;\n\n\tISOM_DECREASE_SIZE(s, 2)\n\tptr->format_flags = gf_bs_read_u8(bs);\n\tptr->PCM_sample_size = gf_bs_read_u8(bs);\n\treturn GF_OK;\n}\n\nGF_Box *pcmC_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_PCMConfigBox, GF_ISOM_BOX_TYPE_PCMC);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err pcmC_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_PCMConfigBox *ptr = (GF_PCMConfigBox *) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u8(bs, ptr->format_flags);\n\tgf_bs_write_u8(bs, ptr->PCM_sample_size);\n\treturn GF_OK;\n}\n\nGF_Err pcmC_box_size(GF_Box *s)\n{\n\ts->size += 2;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid chnl_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err chnl_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_ChannelLayoutBox *ptr = (GF_ChannelLayoutBox *) s;\n\n\tISOM_DECREASE_SIZE(s, 1)\n\tif (ptr->version==0) {\n\t\tptr->layout.stream_structure = gf_bs_read_u8(bs);\n\t} else {\n\t\tptr->layout.stream_structure = gf_bs_read_int(bs, 4);\n\t\tptr->layout.format_ordering = gf_bs_read_int(bs, 4);\n\t\tISOM_DECREASE_SIZE(s, 1)\n\t\tptr->layout.base_channel_count = gf_bs_read_u8(bs);\n\t}\n\tif (ptr->layout.stream_structure & 1) {\n\t\tISOM_DECREASE_SIZE(s, 1)\n\t\tptr->layout.definedLayout = gf_bs_read_u8(bs);\n\t\tif (ptr->layout.definedLayout==0) {\n\t\t\tu32 remain = (u32) ptr->size;\n\t\t\tif (ptr->layout.stream_structure & 2) remain--;\n\t\t\tptr->layout.channels_count = 0;\n\t\t\tu32 nb_channels = 0;\n\t\t\tif (ptr->version) {\n\t\t\t\tISOM_DECREASE_SIZE(s, 1)\n\t\t\t\tnb_channels = gf_bs_read_u8(bs);\n\t\t\t}\n\t\t\twhile (remain) {\n\t\t\t\tif (ptr->layout.channels_count==64) return GF_ISOM_INVALID_FILE;\n\n\t\t\t\tISOM_DECREASE_SIZE(s, 1)\n\t\t\t\tptr->layout.layouts[ptr->layout.channels_count].position = gf_bs_read_u8(bs);\n\t\t\t\tremain--;\n\t\t\t\tif (ptr->layout.layouts[ptr->layout.channels_count].position == 126) {\n\t\t\t\t\tISOM_DECREASE_SIZE(s, 3)\n\t\t\t\t\tptr->layout.layouts[ptr->layout.channels_count].azimuth = gf_bs_read_int(bs, 16);\n\t\t\t\t\tptr->layout.layouts[ptr->layout.channels_count].elevation = gf_bs_read_int(bs, 8);\n\t\t\t\t\tremain-=3;\n\t\t\t\t}\n\t\t\t\tptr->layout.channels_count++;\n\t\t\t\tif (ptr->version) {\n\t\t\t\t\tnb_channels--;\n\t\t\t\t\tif (!nb_channels) break;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (ptr->version==0) {\n\t\t\t\tISOM_DECREASE_SIZE(s, 8)\n\t\t\t\tptr->layout.omittedChannelsMap = gf_bs_read_u64(bs);\n\t\t\t\tptr->layout.omitted_channels_present = 1;\n\t\t\t\tptr->layout.channel_order_definition = 0;\n\t\t\t} else {\n\t\t\t\tISOM_DECREASE_SIZE(s, 1)\n\t\t\t\tgf_bs_read_int(bs, 4);\n\t\t\t\tptr->layout.channel_order_definition = gf_bs_read_int(bs, 3);\n\t\t\t\tptr->layout.omitted_channels_present = gf_bs_read_int(bs, 1);\n\t\t\t\tif (ptr->layout.omitted_channels_present) {\n\t\t\t\t\tISOM_DECREASE_SIZE(s, 8)\n\t\t\t\t\tptr->layout.omittedChannelsMap = gf_bs_read_u64(bs);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif ((ptr->version==0) && (ptr->layout.stream_structure & 2)) {\n\t\tISOM_DECREASE_SIZE(s, 1)\n\t\tptr->layout.object_count = gf_bs_read_u8(bs);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *chnl_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ChannelLayoutBox, GF_ISOM_BOX_TYPE_CHNL);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err chnl_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ChannelLayoutBox *ptr = (GF_ChannelLayoutBox *) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u8(bs, ptr->layout.stream_structure);\n\tif (ptr->version==0) {\n\t\tgf_bs_write_u8(bs, ptr->layout.stream_structure);\n\t} else {\n\t\tgf_bs_write_int(bs, ptr->layout.stream_structure, 4);\n\t\tgf_bs_write_int(bs, ptr->layout.format_ordering, 4);\n\t\tgf_bs_write_u8(bs, ptr->layout.base_channel_count);\n\t}\n\tif (ptr->layout.stream_structure & 1) {\n\t\tgf_bs_write_u8(bs, ptr->layout.definedLayout);\n\t\tif (ptr->layout.definedLayout==0) {\n\t\t\tu32 i;\n\t\t\tif (ptr->version==1) {\n\t\t\t\tgf_bs_write_u8(bs, ptr->layout.channels_count);\n\t\t\t}\n\t\t\tfor (i=0; i<ptr->layout.channels_count; i++) {\n\t\t\t\tgf_bs_write_u8(bs, ptr->layout.layouts[i].position);\n\t\t\t\tif (ptr->layout.layouts[i].position==126) {\n\t\t\t\t\tgf_bs_write_int(bs, ptr->layout.layouts[i].azimuth, 16);\n\t\t\t\t\tgf_bs_write_int(bs, ptr->layout.layouts[i].elevation, 8);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (ptr->version==1) {\n\t\t\t\tgf_bs_write_int(bs, 0, 4);\n\t\t\t\tgf_bs_write_int(bs, ptr->layout.channel_order_definition, 3);\n\t\t\t\tgf_bs_write_int(bs, ptr->layout.omitted_channels_present, 1);\n\t\t\t\tif (ptr->layout.omitted_channels_present)\n\t\t\t\t\tgf_bs_write_u64(bs, ptr->layout.omittedChannelsMap);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_u64(bs, ptr->layout.omittedChannelsMap);\n\t\t\t}\n\t\t}\n\t}\n\tif ((ptr->version==0) && (ptr->layout.stream_structure & 2)) {\n\t\tgf_bs_write_u8(bs, ptr->layout.object_count);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err chnl_box_size(GF_Box *s)\n{\n\tGF_ChannelLayoutBox *ptr = (GF_ChannelLayoutBox *) s;\n\ts->size += 1;\n\tif (ptr->version==1) s->size++;\n\tif (ptr->layout.stream_structure & 1) {\n\t\ts->size += 1;\n\t\tif (ptr->layout.definedLayout==0) {\n\t\t\tu32 i;\n\t\t\tif (ptr->version==1) s->size++;\n\t\t\tfor (i=0; i<ptr->layout.channels_count; i++) {\n\t\t\t\ts->size+=1;\n\t\t\t\tif (ptr->layout.layouts[i].position==126)\n\t\t\t\t\ts->size+=3;\n\t\t\t}\n\t\t} else {\n\t\t\tif (ptr->version==1) {\n\t\t\t\ts->size += 1;\n\t\t\t\tif (ptr->layout.omitted_channels_present)\n\t\t\t\t\ts->size += 8;\n\t\t\t} else {\n\t\t\t\ts->size += 8;\n\t\t\t}\n\t\t}\n\t}\n\tif ((ptr->version==0) && (ptr->layout.stream_structure & 2)) {\n\t\ts->size += 1;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *emsg_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_EventMessageBox, GF_ISOM_BOX_TYPE_EMSG);\n\treturn (GF_Box *)tmp;\n}\n\nvoid emsg_box_del(GF_Box *s)\n{\n\tGF_EventMessageBox *ptr = (GF_EventMessageBox *) s;\n\tif (ptr == NULL) return;\n\tif (ptr->scheme_id_uri) gf_free(ptr->scheme_id_uri);\n\tif (ptr->value) gf_free(ptr->value);\n\tif (ptr->message_data) gf_free(ptr->message_data);\n\tgf_free(ptr);\n}\n\nGF_Err emsg_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_EventMessageBox *ptr = (GF_EventMessageBox*) s;\n\n\tif (ptr->version==0) {\n\t\te = gf_isom_read_null_terminated_string(s, bs, ptr->size, &ptr->scheme_id_uri);\n\t\tif (e) return e;\n\t\te = gf_isom_read_null_terminated_string(s, bs, ptr->size, &ptr->value);\n\t\tif (e) return e;\n\n\t\tISOM_DECREASE_SIZE(ptr, 16);\n\t\tptr->timescale = gf_bs_read_u32(bs);\n\t\tptr->presentation_time_delta = gf_bs_read_u32(bs);\n\t\tptr->event_duration = gf_bs_read_u32(bs);\n\t\tptr->event_id = gf_bs_read_u32(bs);\n\t} else if (ptr->version==1) {\n\t\tISOM_DECREASE_SIZE(ptr, 20);\n\t\tptr->timescale = gf_bs_read_u32(bs);\n\t\tptr->presentation_time_delta = gf_bs_read_u64(bs);\n\t\tptr->event_duration = gf_bs_read_u32(bs);\n\t\tptr->event_id = gf_bs_read_u32(bs);\n\n\t\te = gf_isom_read_null_terminated_string(s, bs, ptr->size, &ptr->scheme_id_uri);\n\t\tif (e) return e;\n\t\te = gf_isom_read_null_terminated_string(s, bs, ptr->size, &ptr->value);\n\t\tif (e) return e;\n\t} else {\n\t\treturn GF_OK;\n\t}\n\tif (ptr->size) {\n\t\tif (ptr->size>0xFFFFFFFUL) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[IsoMedia] emsg message data size too big (\"LLU\") to be loaded\\n\", ptr->size));\n\t\t\treturn GF_OUT_OF_MEM;\n\t\t}\n\t\tptr->message_data_size = (u32) ptr->size;\n\t\tptr->message_data = gf_malloc(ptr->message_data_size);\n\t\tif (!ptr->message_data) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->message_data, ptr->message_data_size);\n\t\tptr->size = 0;\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err emsg_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 len;\n\tGF_EventMessageBox *ptr = (GF_EventMessageBox*) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tif (ptr->version==1) {\n\t\tgf_bs_write_u32(bs, ptr->timescale);\n\t\tgf_bs_write_u64(bs, ptr->presentation_time_delta);\n\t\tgf_bs_write_u32(bs, ptr->event_duration);\n\t\tgf_bs_write_u32(bs, ptr->event_id);\n\t}\n\n\tlen = ptr->scheme_id_uri ? (u32) strlen(ptr->scheme_id_uri) : 0;\n\tif (len) gf_bs_write_data(bs, ptr->scheme_id_uri, len);\n\tgf_bs_write_u8(bs, 0);\n\n\tlen = ptr->value ? (u32) strlen(ptr->value) : 0;\n\tif (len) gf_bs_write_data(bs, ptr->value, len);\n\tgf_bs_write_u8(bs, 0);\n\n\tif (ptr->version==0) {\n\t\tgf_bs_write_u32(bs, ptr->timescale);\n\t\tgf_bs_write_u32(bs, (u32) ptr->presentation_time_delta);\n\t\tgf_bs_write_u32(bs, ptr->event_duration);\n\t\tgf_bs_write_u32(bs, ptr->event_id);\n\t}\n\tif (ptr->message_data)\n\t\tgf_bs_write_data(bs, ptr->message_data, ptr->message_data_size);\n\treturn GF_OK;\n}\n\nGF_Err emsg_box_size(GF_Box *s)\n{\n\tGF_EventMessageBox *ptr = (GF_EventMessageBox*) s;\n\n\tif (ptr->version) {\n\t\tptr->size += 20;\n\t} else {\n\t\tptr->size += 16;\n\t}\n\tptr->size+=2; //1 NULL-terminated strings\n\tif (ptr->scheme_id_uri) ptr->size += strlen(ptr->scheme_id_uri);\n\tif (ptr->value) ptr->size += strlen(ptr->value);\n\tif (ptr->message_data)\n\t\tptr->size += ptr->message_data_size;\n\n\treturn GF_OK;\n}\n#endif // GPAC_DISABLE_ISOM_WRITE\n\n\n\n\nGF_Box *csgp_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_CompactSampleGroupBox, GF_ISOM_BOX_TYPE_CSGP);\n\treturn (GF_Box *)tmp;\n}\nvoid csgp_box_del(GF_Box *a)\n{\n\tGF_CompactSampleGroupBox *p = (GF_CompactSampleGroupBox *)a;\n\tif (p->patterns) {\n\t\tu32 i;\n\t\tfor (i=0; i<p->pattern_count; i++) {\n\t\t\tif (p->patterns[i].sample_group_description_indices)\n\t\t\t\tgf_free(p->patterns[i].sample_group_description_indices);\n\t\t}\n\t\tgf_free(p->patterns);\n\t}\n\tgf_free(p);\n}\n\nu32 get_size_by_code(u32 code)\n{\n\tif (code==0) return 4;\n\tif (code==1) return 8;\n\tif (code==2) return 16;\n\treturn 32;\n}\nGF_Err csgp_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i, bits, gidx_mask;\n\tBool index_msb_indicates_fragment_local_description, grouping_type_parameter_present;\n\tu32 pattern_size, scount_size, index_size;\n\tGF_CompactSampleGroupBox *ptr = (GF_CompactSampleGroupBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 8);\n\tptr->version = gf_bs_read_u8(bs);\n\tptr->flags = gf_bs_read_u24(bs);\n\n\tindex_msb_indicates_fragment_local_description = (ptr->flags & (1<<7)) ? GF_TRUE : GF_FALSE;\n\tgrouping_type_parameter_present = (ptr->flags & (1<<6)) ? GF_TRUE : GF_FALSE;\n\n\tpattern_size = get_size_by_code( ((ptr->flags>>4) & 0x3) );\n\tscount_size = get_size_by_code( ((ptr->flags>>2) & 0x3) );\n\tindex_size = get_size_by_code( (ptr->flags & 0x3) );\n\n\tif (((pattern_size==4) && (scount_size!=4)) || ((pattern_size!=4) && (scount_size==4))) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] compact sample group pattern_size and sample_count_size mare not both 4 bits\\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tptr->grouping_type = gf_bs_read_u32(bs);\n\tif (grouping_type_parameter_present) {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->grouping_type_parameter = gf_bs_read_u32(bs);\n\t}\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->pattern_count = gf_bs_read_u32(bs);\n\n\n\tif ( (ptr->size / ( (pattern_size + scount_size) / 8 ) < ptr->pattern_count) || (u64)ptr->pattern_count > (u64)SIZE_MAX/sizeof(GF_CompactSampleGroupPattern) ) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] compact sample group pattern_count value (%lu) invalid\\n\", ptr->pattern_count));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tptr->patterns = gf_malloc(sizeof(GF_CompactSampleGroupPattern) * ptr->pattern_count);\n\tif (!ptr->patterns) return GF_OUT_OF_MEM;\n\tmemset(ptr->patterns, 0, sizeof(GF_CompactSampleGroupPattern) * ptr->pattern_count);\n\n\tu64 patterns_sizes=0;\n\tbits = 0;\n\tfor (i=0; i<ptr->pattern_count; i++) {\n\t\tptr->patterns[i].length = gf_bs_read_int(bs, pattern_size);\n\t\tptr->patterns[i].sample_count = gf_bs_read_int(bs, scount_size);\n\t\tbits += pattern_size + scount_size;\n\t\tif (! (bits % 8)) {\n\t\t\tbits/=8;\n\t\t\tISOM_DECREASE_SIZE(ptr, bits);\n\t\t\tbits=0;\n\t\t}\n\t\tpatterns_sizes+=ptr->patterns[i].length;\n\t\tif (patterns_sizes * index_size > ptr->size*8) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] compact sample group pattern cumulated sizes \"LLU\" larger than box size \"LLU\"\\n\", patterns_sizes, ptr->size));\n\t\t\tptr->patterns[i].sample_group_description_indices = NULL;\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\n\t\tif ( (u64)ptr->patterns[i].length > (u64)SIZE_MAX/sizeof(u32) ) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] compact sample group pattern #%d value (%lu) invalid\\n\", i, ptr->patterns[i].length));\n\t\t\tptr->patterns[i].sample_group_description_indices = NULL;\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t\tptr->patterns[i].sample_group_description_indices = gf_malloc(sizeof(u32) * ptr->patterns[i].length);\n\t\tif (!ptr->patterns[i].sample_group_description_indices) return GF_OUT_OF_MEM;\n\t}\n\tbits = 0;\n\tgidx_mask = ((u32)1) << (index_size-1);\n\tfor (i=0; i<ptr->pattern_count; i++) {\n\t\tu32 j;\n\t\tfor (j=0; j<ptr->patterns[i].length; j++) {\n\t\t\tu32 idx = gf_bs_read_int(bs, index_size);\n\t\t\tif (index_msb_indicates_fragment_local_description) {\n\t\t\t\t//MSB set, this is a index of a group described in the fragment\n\t\t\t\tif (idx & gidx_mask) {\n\t\t\t\t\tidx += 0x10000;\n\t\t\t\t\tidx &= ~gidx_mask;\n\t\t\t\t}\n\t\t\t}\n\t\t\tptr->patterns[i].sample_group_description_indices[j] = idx;\n\t\t\tbits += index_size;\n\n\t\t\tif (! (bits % 8)) {\n\t\t\t\tbits/=8;\n\t\t\t\tISOM_DECREASE_SIZE(ptr, bits);\n\t\t\t\tbits=0;\n\t\t\t}\n\t\t}\n\t}\n\tif (bits)\n\t\tgf_bs_align(bs);\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err csgp_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_Err e;\n\tGF_CompactSampleGroupBox *ptr = (GF_CompactSampleGroupBox*)s;\n\tu32 pattern_size = get_size_by_code( ((ptr->flags>>4) & 0x3) );\n\tu32 scount_size = get_size_by_code( ((ptr->flags>>2) & 0x3) );\n\tu32 index_size = get_size_by_code( (ptr->flags & 0x3) );\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u8(bs, ptr->version);\n\tgf_bs_write_int(bs, ptr->flags, 24);\n\tgf_bs_write_u32(bs, ptr->grouping_type);\n\n\tif (ptr->flags & (1<<6))\n\t\tgf_bs_write_u32(bs, ptr->grouping_type_parameter);\n\n\tgf_bs_write_u32(bs, ptr->pattern_count);\n\n\tfor (i = 0; i<ptr->pattern_count; i++ ) {\n\t\tgf_bs_write_int(bs, ptr->patterns[i].length, pattern_size);\n\t\tgf_bs_write_int(bs, ptr->patterns[i].sample_count, scount_size);\n\t}\n\n\tfor (i = 0; i<ptr->pattern_count; i++ ) {\n\t\tu32 j;\n\t\tfor (j=0; j<ptr->patterns[i].length; j++) {\n\t\t\tu32 idx = ptr->patterns[i].sample_group_description_indices[j];\n\t\t\tif (idx > 0x10000) {\n\t\t\t\tidx -= 0x10000;\n\t\t\t\tgf_bs_write_int(bs, 1, 1);\n\t\t\t\tgf_bs_write_int(bs, idx, index_size-1);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_int(bs, idx, index_size);\n\t\t\t}\n\t\t}\n\t}\n\tgf_bs_align(bs);\n\treturn GF_OK;\n}\n\nGF_Err csgp_box_size(GF_Box *s)\n{\n\tu32 i, bits;\n\tGF_CompactSampleGroupBox *ptr = (GF_CompactSampleGroupBox*)s;\n\tu32 pattern_size = get_size_by_code( ((ptr->flags>>4) & 0x3) );\n\tu32 scount_size = get_size_by_code( ((ptr->flags>>2) & 0x3) );\n\tu32 index_size = get_size_by_code( (ptr->flags & 0x3) );\n\n\tptr->size += 12; //v, flags , grouping_type, pattern_length\n\tif (ptr->flags & (1<<6))\n\t\tptr->size+=4;\n\n\tptr->size += ptr->pattern_count * (pattern_size + scount_size) / 8;\n\tbits=0;\n\tfor (i=0; i<ptr->pattern_count; i++)\n\t\tbits += ptr->patterns[i].length * index_size;\n\tptr->size += bits/8;\n\tif (bits % 8) ptr->size++;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *dmlp_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrueHDConfigBox, GF_ISOM_BOX_TYPE_DMLP);\n\treturn (GF_Box *)tmp;\n}\n\nvoid dmlp_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\n\nGF_Err dmlp_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TrueHDConfigBox *ptr = (GF_TrueHDConfigBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 10)\n\tptr->format_info = gf_bs_read_u32(bs);\n\tptr->peak_data_rate = gf_bs_read_int(bs, 15);\n\tgf_bs_read_int(bs, 1);\n\tgf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err dmlp_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TrueHDConfigBox *ptr = (GF_TrueHDConfigBox *)s;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->format_info);\n\tgf_bs_write_int(bs, ptr->peak_data_rate, 15);\n\tgf_bs_write_int(bs, 0, 1);\n\tgf_bs_write_u32(bs, 0);\n\treturn GF_OK;\n}\n\nGF_Err dmlp_box_size(GF_Box *s)\n{\n\ts->size += 10;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *xtra_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_XtraBox, GF_ISOM_BOX_TYPE_XTRA);\n\ttmp->tags = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\nvoid xtra_box_del(GF_Box *s)\n{\n\tGF_XtraBox *ptr = (GF_XtraBox *)s;\n\twhile (gf_list_count(ptr->tags)) {\n\t\tGF_XtraTag *tag = gf_list_pop_back(ptr->tags);\n\t\tif (tag->name) gf_free(tag->name);\n\t\tif (tag->prop_value) gf_free(tag->prop_value);\n\t\tgf_free(tag);\n\t}\n\tgf_list_del(ptr->tags);\n\tgf_free(s);\n}\n\nGF_Err xtra_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_XtraBox *ptr = (GF_XtraBox *)s;\n\twhile (ptr->size) {\n\t\tGF_XtraTag *tag;\n\t\tu32 prop_type = 0;\n\n\t\tchar *data=NULL, *data2=NULL;\n\t\tISOM_DECREASE_SIZE_NO_ERR(ptr, 8)\n\t\ts32 tag_size = gf_bs_read_u32(bs);\n\t\tu32 name_size = gf_bs_read_u32(bs);\n\t\tif (tag_size < 8) return GF_ISOM_INVALID_FILE;\n\n\t\ttag_size -= 8;\n\t\tif ((tag_size>ptr->size) || (name_size>ptr->size)) {\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t\tISOM_DECREASE_SIZE_NO_ERR(ptr, 10)\n\n\t\tISOM_DECREASE_SIZE_NO_ERR(ptr, name_size)\n\t\tdata = gf_malloc(sizeof(char) * (name_size+1));\n\t\tgf_bs_read_data(bs, data, name_size);\n\t\tdata[name_size] = 0;\n\t\ttag_size-=name_size;\n\n\t\tu32 flags = gf_bs_read_u32(bs);\n\t\tu32 prop_size = gf_bs_read_u32(bs);\n\t\ttag_size-=8;\n\n\t\tif (prop_size>4) {\n\t\t\ttag_size-=2;\n\t\t\tprop_type = gf_bs_read_u16(bs);\n\t\t\tprop_size -= 6;\n\t\t\tISOM_DECREASE_SIZE_NO_ERR(ptr, prop_size)\n\t\t\t//add 3 extra bytes for UTF16 case string dump (3 because we need 0-aligned short value)\n\t\t\tdata2 = gf_malloc(sizeof(char) * (prop_size+3));\n\t\t\tgf_bs_read_data(bs, data2, prop_size);\n\t\t\tdata2[prop_size] = 0;\n\t\t\tdata2[prop_size+1] = 0;\n\t\t\tdata2[prop_size+2] = 0;\n\t\t\ttag_size-=prop_size;\n\t\t} else {\n\t\t\tprop_size = 0;\n\t\t}\n\t\tGF_SAFEALLOC(tag, GF_XtraTag)\n\t\ttag->flags = flags;\n\t\ttag->name = data;\n\t\ttag->prop_size = prop_size;\n\t\ttag->prop_value = data2;\n\t\ttag->prop_type = prop_type;\n\t\tgf_list_add(ptr->tags, tag);\n\n\t\tif (tag_size) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[isom] left-over bytes in tag %s in Xtra !\\n\", data));\n\t\t\tgf_bs_skip_bytes(bs, tag_size);\n\t\t\tISOM_DECREASE_SIZE_NO_ERR(ptr, tag_size)\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err xtra_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_XtraBox *ptr = (GF_XtraBox *)s;\n\tu32 i, count = gf_list_count(ptr->tags);\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tfor (i=0; i<count; i++) {\n\t\tGF_XtraTag *tag = gf_list_get(ptr->tags, i);\n\t\tu32 tag_size = 16;\n\t\tu32 name_len = tag->name ? (u32) strlen(tag->name) : 0;\n\t\ttag_size += name_len;\n\t\tif (tag->prop_value) {\n\t\t\ttag_size += 2 + tag->prop_size;\n\t\t}\n\t\tgf_bs_write_u32(bs, tag_size);\n\t\tgf_bs_write_u32(bs, name_len);\n\t\tgf_bs_write_data(bs, tag->name, name_len);\n\t\tgf_bs_write_u32(bs, tag->flags);\n\t\tgf_bs_write_u32(bs, 6 + tag->prop_size);\n\t\tgf_bs_write_u16(bs, tag->prop_type);\n\t\tgf_bs_write_data(bs, tag->prop_value, tag->prop_size);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err xtra_box_size(GF_Box *s)\n{\n\tGF_XtraBox *ptr = (GF_XtraBox *)s;\n\tu32 i, count = gf_list_count(ptr->tags);\n\tfor (i=0; i<count; i++) {\n\t\tGF_XtraTag *tag = gf_list_get(ptr->tags, i);\n\t\tptr->size += 18 + (u32) strlen(tag->name) + tag->prop_size;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Box *st3d_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_Stereo3DBox, GF_ISOM_BOX_TYPE_ST3D);\n\treturn (GF_Box *)tmp;\n}\n\nvoid st3d_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\n\nGF_Err st3d_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Stereo3DBox *ptr = (GF_Stereo3DBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 1)\n\tptr->stereo_type = gf_bs_read_u8(bs);\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err st3d_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_Stereo3DBox *ptr = (GF_Stereo3DBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u8(bs, ptr->stereo_type);\n\treturn GF_OK;\n}\n\nGF_Err st3d_box_size(GF_Box *s)\n{\n\ts->size += 1;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Box *svhd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SphericalVideoInfoBox, GF_ISOM_BOX_TYPE_SVHD);\n\treturn (GF_Box *)tmp;\n}\n\nvoid svhd_box_del(GF_Box *s)\n{\n\tGF_SphericalVideoInfoBox *ptr = (GF_SphericalVideoInfoBox *)s;\n\tif (ptr->string) gf_free(ptr->string);\n\tgf_free(s);\n}\n\n\nGF_Err svhd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_SphericalVideoInfoBox *ptr = (GF_SphericalVideoInfoBox *)s;\n\tif ((u32)ptr->size >= (u32)0xFFFFFFFF) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid size %llu in svhd box\\n\", ptr->size));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tptr->string = gf_malloc(sizeof(char) * ((u32) ptr->size+1));\n\tif (!ptr->string) return GF_OUT_OF_MEM;\n\tgf_bs_read_data(bs, ptr->string, (u32) ptr->size);\n\tptr->string[ptr->size] = 0;\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err svhd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SphericalVideoInfoBox *ptr = (GF_SphericalVideoInfoBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tif (ptr->string)\n\t\tgf_bs_write_data(bs, ptr->string, (u32) strlen(ptr->string));\n\tgf_bs_write_u8(bs, 0);\n\treturn GF_OK;\n}\n\nGF_Err svhd_box_size(GF_Box *s)\n{\n\tGF_SphericalVideoInfoBox *ptr = (GF_SphericalVideoInfoBox *)s;\n\tif (ptr->string)\n\t\ts->size += (u32) strlen(ptr->string);\n\ts->size += 1;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *prhd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ProjectionHeaderBox, GF_ISOM_BOX_TYPE_PRHD);\n\treturn (GF_Box *)tmp;\n}\n\nvoid prhd_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\n\nGF_Err prhd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_ProjectionHeaderBox *ptr = (GF_ProjectionHeaderBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 12)\n\tptr->yaw = (s32) gf_bs_read_u32(bs);\n\tptr->pitch = (s32) gf_bs_read_u32(bs);\n\tptr->roll = (s32) gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err prhd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ProjectionHeaderBox *ptr = (GF_ProjectionHeaderBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->yaw);\n\tgf_bs_write_u32(bs, ptr->pitch);\n\tgf_bs_write_u32(bs, ptr->roll);\n\treturn GF_OK;\n}\n\nGF_Err prhd_box_size(GF_Box *s)\n{\n\ts->size += 12;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *proj_type_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ProjectionTypeBox, GF_ISOM_BOX_TYPE_EQUI); //will be overwritten\n\treturn (GF_Box *)tmp;\n}\n\nvoid proj_type_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err proj_type_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_ProjectionTypeBox *ptr = (GF_ProjectionTypeBox *)s;\n\n\tif (ptr->type==GF_ISOM_BOX_TYPE_CBMP) {\n\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\tptr->layout = gf_bs_read_u32(bs);\n\t\tptr->padding = gf_bs_read_u32(bs);\n\t}\n\telse if (ptr->type==GF_ISOM_BOX_TYPE_EQUI) {\n\t\tISOM_DECREASE_SIZE(ptr, 16)\n\t\tptr->bounds_top = gf_bs_read_u32(bs);\n\t\tptr->bounds_bottom = gf_bs_read_u32(bs);\n\t\tptr->bounds_left = gf_bs_read_u32(bs);\n\t\tptr->bounds_right = gf_bs_read_u32(bs);\n\t} else {\n\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\tptr->crc = gf_bs_read_u32(bs);\n\t\tptr->encoding_4cc = gf_bs_read_u32(bs);\n\t}\n\treturn gf_isom_box_array_read(s, bs);\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err proj_type_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ProjectionTypeBox *ptr = (GF_ProjectionTypeBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tif (ptr->type==GF_ISOM_BOX_TYPE_CBMP) {\n\t\tgf_bs_write_u32(bs, ptr->layout);\n\t\tgf_bs_write_u32(bs, ptr->padding);\n\t}\n\telse if (ptr->type==GF_ISOM_BOX_TYPE_EQUI) {\n\t\tgf_bs_write_u32(bs, ptr->bounds_top);\n\t\tgf_bs_write_u32(bs, ptr->bounds_bottom);\n\t\tgf_bs_write_u32(bs, ptr->bounds_left);\n\t\tgf_bs_write_u32(bs, ptr->bounds_right);\n\t} else {\n\t\tgf_bs_write_u32(bs, ptr->crc);\n\t\tgf_bs_write_u32(bs, ptr->encoding_4cc);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err proj_type_box_size(GF_Box *s)\n{\n\tGF_ProjectionTypeBox *ptr = (GF_ProjectionTypeBox *)s;\n\tif (ptr->type==GF_ISOM_BOX_TYPE_CBMP)\n\t\ts->size += 8;\n\telse if (ptr->type==GF_ISOM_BOX_TYPE_EQUI)\n\t\ts->size += 16;\n\telse\n\t\ts->size += 8;\n\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *empty_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_Box, GF_QT_BOX_TYPE_FRCD);\n\treturn (GF_Box *) tmp;\n}\n\nvoid empty_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err empty_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err empty_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err empty_box_size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM*/\n", "/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2023\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISO Media File Format sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/internal/isomedia_dev.h>\n#include <gpac/constants.h>\n#include <gpac/iso639.h>\n\n\n#if !defined(GPAC_DISABLE_ISOM) && !defined(GPAC_DISABLE_ISOM_WRITE)\n\nGF_Err CanAccessMovie(GF_ISOFile *movie, GF_ISOOpenMode Mode)\n{\n\tif (!movie) return GF_BAD_PARAM;\n\tif (movie->openMode < Mode) return GF_ISOM_INVALID_MODE;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY) return GF_ISOM_INVALID_MODE;\n#endif\n\treturn GF_OK;\n}\n\nstatic GF_Err unpack_track(GF_TrackBox *trak)\n{\n\tGF_Err e = GF_OK;\n\tif (!trak->is_unpacked) {\n\t\te = stbl_UnpackOffsets(trak->Media->information->sampleTable);\n\t\tif (e) return e;\n\t\te = stbl_unpackCTS(trak->Media->information->sampleTable);\n\t\ttrak->is_unpacked = GF_TRUE;\n\t}\n\treturn e;\n}\n\n\nGF_Err FlushCaptureMode(GF_ISOFile *movie)\n{\n\tGF_Err e;\n\tif (movie->openMode != GF_ISOM_OPEN_WRITE) {\n\t\tif (!movie->editFileMap) return GF_ISOM_INVALID_MODE;\n\t\treturn GF_OK;\n\t}\n\t/*make sure nothing was added*/\n\tif (gf_bs_get_position(movie->editFileMap->bs)) return GF_OK;\n\n\tif (!strcmp(movie->fileName, \"_gpac_isobmff_redirect\")) {\n\t\tif (!movie->on_block_out) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[ISOBMFF] Missing output block callback, cannot write\\n\"));\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\n\t\tgf_bs_del(movie->editFileMap->bs);\n\t\tmovie->editFileMap->bs = gf_bs_new_cbk(isom_on_block_out, movie, movie->on_block_out_block_size);\n\t}\n\n\t/*add all first boxes*/\n\tif (movie->brand) {\n\t\te = gf_isom_box_size((GF_Box *)movie->brand);\n\t\tif (e) return e;\n\t\te = gf_isom_box_write((GF_Box *)movie->brand, movie->editFileMap->bs);\n\t\tif (e) return e;\n\t}\n\tif (movie->pdin) {\n\t\te = gf_isom_box_size((GF_Box *)movie->pdin);\n\t\tif (e) return e;\n\t\te = gf_isom_box_write((GF_Box *)movie->pdin, movie->editFileMap->bs);\n\t\tif (e) return e;\n\t}\n\tmovie->mdat->bsOffset = gf_bs_get_position(movie->editFileMap->bs);\n\n\t/*we have a trick here: the data will be stored on the fly, so the first\n\tthing in the file is the MDAT. As we don't know if we have a large file (>4 GB) or not\n\tdo as if we had one and write 16 bytes: 4 (type) + 4 (size) + 8 (largeSize)...*/\n\tgf_bs_write_long_int(movie->editFileMap->bs, 0, 64);\n\tgf_bs_write_long_int(movie->editFileMap->bs, 0, 64);\n\treturn GF_OK;\n}\n\nstatic GF_Err CheckNoData(GF_ISOFile *movie)\n{\n\tif (movie->openMode != GF_ISOM_OPEN_WRITE) return GF_OK;\n\tif (gf_bs_get_position(movie->editFileMap->bs)) return GF_BAD_PARAM;\n\treturn GF_OK;\n}\n\n/**************************************************************\n\t\t\t\t\tFile Writing / Editing\n**************************************************************/\n//quick function to add an IOD/OD to the file if not present (iods is optional)\nGF_Err AddMovieIOD(GF_MovieBox *moov, u8 isIOD)\n{\n\tGF_Descriptor *od;\n\tGF_ObjectDescriptorBox *iods;\n\n\t//do we have an IOD ?? If not, create one.\n\tif (moov->iods) return GF_OK;\n\n\tif (isIOD) {\n\t\tod = gf_odf_desc_new(GF_ODF_ISOM_IOD_TAG);\n\t} else {\n\t\tod = gf_odf_desc_new(GF_ODF_ISOM_OD_TAG);\n\t}\n\tif (!od) return GF_OUT_OF_MEM;\n\t((GF_IsomObjectDescriptor *)od)->objectDescriptorID = 1;\n\n\tiods = (GF_ObjectDescriptorBox *) gf_isom_box_new_parent(&moov->child_boxes, GF_ISOM_BOX_TYPE_IODS);\n\tif (!iods) return GF_OUT_OF_MEM;\n\tiods->descriptor = od;\n\treturn moov_on_child_box((GF_Box*)moov, (GF_Box *)iods, GF_FALSE);\n}\n\n//add a track to the root OD\nGF_EXPORT\nGF_Err gf_isom_add_track_to_root_od(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_Err e;\n\tGF_ES_ID_Inc *inc;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\n\tif (!movie->moov->iods) AddMovieIOD(movie->moov, 0);\n\n\tif (gf_isom_is_track_in_root_od(movie, trackNumber) == 1) return GF_OK;\n\n\tinc = (GF_ES_ID_Inc *) gf_odf_desc_new(GF_ODF_ESD_INC_TAG);\n\tinc->trackID = gf_isom_get_track_id(movie, trackNumber);\n\tif (!inc->trackID) {\n\t\tgf_odf_desc_del((GF_Descriptor *)inc);\n\t\treturn movie->LastError;\n\t}\n\tif ( (movie->LastError = gf_isom_add_desc_to_root_od(movie, (GF_Descriptor *)inc) ) ) {\n\t\treturn movie->LastError;\n\t}\n\tgf_odf_desc_del((GF_Descriptor *)inc);\n\treturn GF_OK;\n}\n\n//remove the root OD\nGF_EXPORT\nGF_Err gf_isom_remove_root_od(GF_ISOFile *movie)\n{\n\tGF_Err e;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\tif (!movie->moov || !movie->moov->iods) return GF_OK;\n\tgf_isom_box_del_parent(&movie->moov->child_boxes, (GF_Box *)movie->moov->iods);\n\tmovie->moov->iods = NULL;\n\treturn GF_OK;\n}\n\n//remove a track to the root OD\nGF_EXPORT\nGF_Err gf_isom_remove_track_from_root_od(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_List *esds;\n\tGF_ES_ID_Inc *inc;\n\tu32 i;\n\tGF_Err e;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\tif (!movie->moov) return GF_OK;\n\n\tif (!gf_isom_is_track_in_root_od(movie, trackNumber)) return GF_OK;\n\n\tif (!movie->moov->iods) {\n\t\te = AddMovieIOD(movie->moov, 0);\n\t\tif (e) return e;\n\t}\n\tswitch (movie->moov->iods->descriptor->tag) {\n\tcase GF_ODF_ISOM_IOD_TAG:\n\t\tesds = ((GF_IsomInitialObjectDescriptor *)movie->moov->iods->descriptor)->ES_ID_IncDescriptors;\n\t\tbreak;\n\tcase GF_ODF_ISOM_OD_TAG:\n\t\tesds = ((GF_IsomObjectDescriptor *)movie->moov->iods->descriptor)->ES_ID_IncDescriptors;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\t//get the desc\n\ti=0;\n\twhile ((inc = (GF_ES_ID_Inc*)gf_list_enum(esds, &i))) {\n\t\tif (inc->trackID == (u32) gf_isom_get_track_id(movie, trackNumber)) {\n\t\t\tgf_odf_desc_del((GF_Descriptor *)inc);\n\t\t\tgf_list_rem(esds, i-1);\n\t\t\tbreak;\n\t\t}\n\t}\n\t//we don't remove the iod for P&Ls and other potential info\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_creation_time(GF_ISOFile *movie, u64 ctime, u64 mtime)\n{\n\tif (!movie || !movie->moov) return GF_BAD_PARAM;\n\tmovie->moov->mvhd->creationTime = ctime;\n\tmovie->moov->mvhd->modificationTime = mtime;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_track_creation_time(GF_ISOFile *movie,u32 trackNumber, u64 ctime, u64 mtime)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\ttrak->Header->creationTime = ctime;\n\ttrak->Header->modificationTime = mtime;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_media_creation_time(GF_ISOFile *movie,u32 trackNumber, u64 ctime, u64 mtime)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\tif (!trak->Media || !trak->Media->mediaHeader) return GF_ISOM_INVALID_FILE;\n\n\ttrak->Media->mediaHeader->creationTime = ctime;\n\ttrak->Media->mediaHeader->modificationTime = mtime;\n\treturn GF_OK;\n}\n\n//sets the enable flag of a track\nGF_EXPORT\nGF_Err gf_isom_set_track_enabled(GF_ISOFile *movie, u32 trackNumber, Bool enableTrack)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tif (enableTrack) {\n\t\ttrak->Header->flags |= 1;\n\t} else {\n\t\ttrak->Header->flags &= ~1;\n\t}\n\treturn GF_OK;\n}\n\n//sets the enable flag of a track\nGF_EXPORT\nGF_Err gf_isom_set_track_flags(GF_ISOFile *movie, u32 trackNumber, u32 flags, GF_ISOMTrackFlagOp op)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\tif (op==GF_ISOM_TKFLAGS_ADD)\n\t\ttrak->Header->flags |= flags;\n\telse if (op==GF_ISOM_TKFLAGS_REM)\n\t\ttrak->Header->flags &= ~flags;\n\telse\n\t\ttrak->Header->flags = flags;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_media_language(GF_ISOFile *movie, u32 trackNumber, char *code)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !code) return GF_BAD_PARAM;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\t// Old language-storage processing\n\t// if the new code is on 3 chars, we use it\n\t// otherwise, we find the associated 3 chars code and use it\n\tif (strlen(code) == 3) {\n\t\tmemcpy(trak->Media->mediaHeader->packedLanguage, code, sizeof(char)*3);\n\t} else {\n\t\ts32 lang_idx;\n\t\tconst char *code_3cc;\n\t\tlang_idx = gf_lang_find(code);\n\t\tif (lang_idx == -1) {\n\t\t\tif (code[0]!=0) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"The given code is not a valid one: %s, using 'und' as 3-letter code\\n\", code));\n\t\t\t}\n\t\t\tcode_3cc = \"und\";\n\t\t} else {\n\t\t\tcode_3cc = gf_lang_get_3cc(lang_idx);\n\t\t}\n\t\tmemcpy(trak->Media->mediaHeader->packedLanguage, code_3cc, sizeof(char)*3);\n\t}\n\n\t// New language-storage processing\n\t// change the code in the extended language box (if any)\n\t// otherwise add an extended language box only if the given code is not 3 chars\n\t{\n\t\tu32 i, count;\n\t\tGF_ExtendedLanguageBox *elng;\n\t\telng = NULL;\n\t\tcount = gf_list_count(trak->Media->child_boxes);\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tGF_Box *box = (GF_Box *)gf_list_get(trak->Media->child_boxes, i);\n\t\t\tif (box->type == GF_ISOM_BOX_TYPE_ELNG) {\n\t\t\t\telng = (GF_ExtendedLanguageBox *)box;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!elng && (strlen(code) > 3)) {\n\t\t\telng = (GF_ExtendedLanguageBox *)gf_isom_box_new_parent(&trak->Media->child_boxes, GF_ISOM_BOX_TYPE_ELNG);\n\t\t\tif (!elng) return GF_OUT_OF_MEM;\n\t\t}\n\t\tif (elng) {\n\t\t\tif (elng->extended_language) {\n\t\t\t\tgf_free(elng->extended_language);\n\t\t\t}\n\t\t\telng->extended_language = gf_strdup(code);\n\t\t}\n\t}\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\treturn GF_OK;\n}\n\nstatic GF_Err gf_isom_set_root_iod(GF_ISOFile *movie)\n{\n\tGF_IsomInitialObjectDescriptor *iod;\n\tGF_IsomObjectDescriptor *od;\n\tGF_Err e;\n\t\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\tif (!movie->moov->iods) {\n\t\tAddMovieIOD(movie->moov, 1);\n\t\treturn GF_OK;\n\t}\n\t//if OD, switch to IOD\n\tif (movie->moov->iods->descriptor->tag == GF_ODF_ISOM_IOD_TAG) return GF_OK;\n\tod = (GF_IsomObjectDescriptor *) movie->moov->iods->descriptor;\n\tiod = (GF_IsomInitialObjectDescriptor*)gf_malloc(sizeof(GF_IsomInitialObjectDescriptor));\n\tif (!iod) return GF_OUT_OF_MEM;\n\n\tmemset(iod, 0, sizeof(GF_IsomInitialObjectDescriptor));\n\n\tiod->ES_ID_IncDescriptors = od->ES_ID_IncDescriptors;\n\tod->ES_ID_IncDescriptors = NULL;\n\t//not used in root OD\n\tiod->ES_ID_RefDescriptors = NULL;\n\tiod->extensionDescriptors = od->extensionDescriptors;\n\tod->extensionDescriptors = NULL;\n\tiod->IPMP_Descriptors = od->IPMP_Descriptors;\n\tod->IPMP_Descriptors = NULL;\n\tiod->objectDescriptorID = od->objectDescriptorID;\n\tiod->OCIDescriptors = od->OCIDescriptors;\n\tod->OCIDescriptors = NULL;\n\tiod->tag = GF_ODF_ISOM_IOD_TAG;\n\tiod->URLString = od->URLString;\n\tod->URLString = NULL;\n\n\tgf_odf_desc_del((GF_Descriptor *) od);\n\tmovie->moov->iods->descriptor = (GF_Descriptor *)iod;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_add_desc_to_root_od(GF_ISOFile *movie, const GF_Descriptor *theDesc)\n{\n\tGF_Err e;\n\tGF_Descriptor *desc, *dupDesc;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\n\tif (!movie->moov->iods) {\n\t\te = AddMovieIOD(movie->moov, 0);\n\t\tif (e) return e;\n\t}\n\tif (theDesc->tag==GF_ODF_IPMP_TL_TAG) gf_isom_set_root_iod(movie);\n\n\tdesc = movie->moov->iods->descriptor;\n\t//the type of desc is handled at the OD/IOD level, we'll be notified\n\t//if the desc is not allowed\n\tswitch (desc->tag) {\n\tcase GF_ODF_ISOM_IOD_TAG:\n\tcase GF_ODF_ISOM_OD_TAG:\n\t\t//duplicate the desc\n\t\te = gf_odf_desc_copy((GF_Descriptor *)theDesc, &dupDesc);\n\t\tif (e) return e;\n\t\t//add it (MUST BE  (I)OD level desc)\n\t\tmovie->LastError = gf_odf_desc_add_desc(desc, dupDesc);\n\t\tif (movie->LastError) gf_odf_desc_del((GF_Descriptor *)dupDesc);\n\t\tbreak;\n\tdefault:\n\t\tmovie->LastError = GF_ISOM_INVALID_FILE;\n\t\tbreak;\n\t}\n\treturn movie->LastError;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_set_timescale(GF_ISOFile *movie, u32 timeScale)\n{\n\tGF_TrackBox *trak;\n\tu32 i;\n\tGF_Err e;\n\tif (!timeScale) return GF_BAD_PARAM;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\n\tif (movie->moov->mvhd->timeScale == timeScale) return GF_OK;\n\n\t/*rewrite all durations and edit lists*/\n\tmovie->moov->mvhd->duration *= timeScale;\n\tmovie->moov->mvhd->duration /= movie->moov->mvhd->timeScale;\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (movie->moov->mvex && movie->moov->mvex->mehd) {\n\t\tmovie->moov->mvex->mehd->fragment_duration *= timeScale;\n\t\tmovie->moov->mvex->mehd->fragment_duration /= movie->moov->mvhd->timeScale;\n\t}\n#endif\n\n\ti=0;\n\twhile ((trak = (GF_TrackBox*)gf_list_enum(movie->moov->trackList, &i))) {\n\t\ttrak->Header->duration *= timeScale;\n\t\ttrak->Header->duration /= movie->moov->mvhd->timeScale;\n\n\t\tif (trak->editBox && trak->editBox->editList) {\n\t\t\tu32 j, count = gf_list_count(trak->editBox->editList->entryList);\n\t\t\tfor (j=0; j<count; j++) {\n\t\t\t\tGF_EdtsEntry *ent = (GF_EdtsEntry *)gf_list_get(trak->editBox->editList->entryList, j);\n\t\t\t\tent->segmentDuration *= timeScale;\n\t\t\t\tent->segmentDuration /= movie->moov->mvhd->timeScale;\n\t\t\t}\n\t\t}\n\t}\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (movie->moov->mvex && movie->moov->mvex->mehd) {\n\t\tmovie->moov->mvex->mehd->fragment_duration *= timeScale;\n\t\tmovie->moov->mvex->mehd->fragment_duration /= movie->moov->mvhd->timeScale;\n\t}\n#endif\n\tmovie->moov->mvhd->timeScale = timeScale;\n\tmovie->interleavingTime = timeScale;\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_set_pl_indication(GF_ISOFile *movie, GF_ISOProfileLevelType PL_Code, u8 ProfileLevel)\n{\n\tGF_IsomInitialObjectDescriptor *iod;\n\tGF_Err e;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\te = gf_isom_set_root_iod(movie);\n\tif (e) return e;\n\n\tiod = (GF_IsomInitialObjectDescriptor *)movie->moov->iods->descriptor;\n\n\tswitch (PL_Code) {\n\tcase GF_ISOM_PL_AUDIO:\n\t\tiod->audio_profileAndLevel = ProfileLevel;\n\t\tbreak;\n\tcase GF_ISOM_PL_GRAPHICS:\n\t\tiod->graphics_profileAndLevel = ProfileLevel;\n\t\tbreak;\n\tcase GF_ISOM_PL_OD:\n\t\tiod->OD_profileAndLevel = ProfileLevel;\n\t\tbreak;\n\tcase GF_ISOM_PL_SCENE:\n\t\tiod->scene_profileAndLevel = ProfileLevel;\n\t\tbreak;\n\tcase GF_ISOM_PL_VISUAL:\n\t\tiod->visual_profileAndLevel = ProfileLevel;\n\t\tbreak;\n\tcase GF_ISOM_PL_INLINE:\n\t\tiod->inlineProfileFlag = ProfileLevel ? 1 : 0;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_root_od_id(GF_ISOFile *movie, u32 OD_ID)\n{\n\tGF_Err e;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\tif (!movie->moov->iods) {\n\t\te = AddMovieIOD(movie->moov, 0);\n\t\tif (e) return e;\n\t}\n\n\tswitch (movie->moov->iods->descriptor->tag) {\n\tcase GF_ODF_ISOM_OD_TAG:\n\t\t((GF_IsomObjectDescriptor *)movie->moov->iods->descriptor)->objectDescriptorID = OD_ID;\n\t\tbreak;\n\tcase GF_ODF_ISOM_IOD_TAG:\n\t\t((GF_IsomInitialObjectDescriptor *)movie->moov->iods->descriptor)->objectDescriptorID = OD_ID;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_root_od_url(GF_ISOFile *movie, const char *url_string)\n{\n\tGF_Err e;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\n\tif (!movie->moov->iods) {\n\t\te = AddMovieIOD(movie->moov, 0);\n\t\tif (e) return e;\n\t}\n\n\tswitch (movie->moov->iods->descriptor->tag) {\n\tcase GF_ODF_ISOM_OD_TAG:\n\t\tif (((GF_IsomObjectDescriptor *)movie->moov->iods->descriptor)->URLString) gf_free(((GF_IsomObjectDescriptor *)movie->moov->iods->descriptor)->URLString);\n\t\t((GF_IsomObjectDescriptor *)movie->moov->iods->descriptor)->URLString = url_string ? gf_strdup(url_string) : NULL;\n\t\tbreak;\n\tcase GF_ODF_ISOM_IOD_TAG:\n\t\tif (((GF_IsomInitialObjectDescriptor *)movie->moov->iods->descriptor)->URLString) gf_free(((GF_IsomInitialObjectDescriptor *)movie->moov->iods->descriptor)->URLString);\n\t\t((GF_IsomInitialObjectDescriptor *)movie->moov->iods->descriptor)->URLString = url_string ? gf_strdup(url_string) : NULL;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_ISOTrackID gf_isom_get_last_created_track_id(GF_ISOFile *movie)\n{\n\treturn movie ? movie->last_created_track_id : 0;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_load_extra_boxes(GF_ISOFile *movie, u8 *moov_boxes, u32 moov_boxes_size, Bool udta_only)\n{\n\tGF_BitStream *bs;\n\n\tGF_Err e = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\n\tbs = gf_bs_new(moov_boxes, moov_boxes_size, GF_BITSTREAM_READ);\n\n\t//we may have terminators in some QT files (4 bytes set to 0 ...)\n\twhile (gf_bs_available(bs) >= 8) {\n\t\tGF_Box *a_box;\n\t\te = gf_isom_box_parse_ex((GF_Box**)&a_box, bs, GF_ISOM_BOX_TYPE_MOOV, GF_FALSE, 0);\n\t\tif (e || !a_box) goto exit;\n\n\t\tif (a_box->type == GF_ISOM_BOX_TYPE_UDTA) {\n\t\t\tif (movie->moov->udta) gf_isom_box_del_parent(&movie->moov->child_boxes, (GF_Box*)movie->moov->udta);\n\t\t\tmovie->moov->udta = (GF_UserDataBox*) a_box;\n\n\t\t\tif (!movie->moov->child_boxes) movie->moov->child_boxes = gf_list_new();\n\t\t\tgf_list_add(movie->moov->child_boxes, a_box);\n\n\t\t} else if (!udta_only && (a_box->type!=GF_ISOM_BOX_TYPE_PSSH) ) {\n\t\t\tif (!movie->moov->child_boxes) movie->moov->child_boxes = gf_list_new();\n\t\t\tgf_list_add(movie->moov->child_boxes, a_box);\n\t\t} else {\n\t\t\tgf_isom_box_del(a_box);\n\t\t}\n\t}\nexit:\n\tgf_bs_del(bs);\n\treturn e;\n}\n\n//creates a new Track. If trackID = 0, the trackID is chosen by the API\n//returns the track number or 0 if error\nGF_EXPORT\nu32 gf_isom_new_track_from_template(GF_ISOFile *movie, GF_ISOTrackID trakID, u32 MediaType, u32 TimeScale, u8 *tk_box, u32 tk_box_size, Bool udta_only)\n{\n\tGF_Err e;\n\tu64 now;\n\tu8 isHint;\n\tGF_TrackBox *trak;\n\tGF_TrackHeaderBox *tkhd;\n\tGF_MediaBox *mdia;\n\tGF_UserDataBox *udta = NULL;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) {\n\t\tgf_isom_set_last_error(movie, e);\n\t\treturn 0;\n\t}\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\n\n\tisHint = 0;\n\t//we're creating a hint track... it's the same, but mode HAS TO BE EDIT\n\tif (MediaType == GF_ISOM_MEDIA_HINT) {\n//\t\tif (movie->openMode != GF_ISOM_OPEN_EDIT) return 0;\n\t\tisHint = 1;\n\t}\n\n\tmdia = NULL;\n\ttkhd = NULL;\n\ttrak = NULL;\n\tif (trakID) {\n\t\t//check if we are in ES_ID boundaries\n\t\tif (!isHint && (trakID > 0xFFFF)) {\n\t\t\tgf_isom_set_last_error(movie, GF_BAD_PARAM);\n\t\t\treturn 0;\n\t\t}\n\t\t//here we should look for available IDs ...\n\t\tif (!RequestTrack(movie->moov, trakID)) return 0;\n\t} else {\n\t\ttrakID = movie->moov->mvhd->nextTrackID;\n\t\tif (!trakID) trakID = 1;\n\t\t/*ESIDs are on 16 bits*/\n\t\tif (! isHint && (trakID > 0xFFFF)) trakID = 1;\n\n\t\twhile (1) {\n\t\t\tif (RequestTrack(movie->moov, trakID)) break;\n\t\t\ttrakID += 1;\n\t\t\tif (trakID == 0xFFFFFFFF) break;\n\t\t}\n\t\tif (trakID == 0xFFFFFFFF) {\n\t\t\tgf_isom_set_last_error(movie, GF_BAD_PARAM);\n\t\t\treturn 0;\n\t\t}\n\t\tif (! isHint && (trakID > 0xFFFF)) {\n\t\t\tgf_isom_set_last_error(movie, GF_BAD_PARAM);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (tk_box) {\n\t\tGF_BitStream *bs = gf_bs_new(tk_box, tk_box_size, GF_BITSTREAM_READ);\n\t\tgf_bs_set_cookie(bs, GF_ISOM_BS_COOKIE_NO_LOGS|GF_ISOM_BS_COOKIE_CLONE_TRACK);\n\n\t\te = gf_isom_box_parse_ex((GF_Box**)&trak, bs, GF_ISOM_BOX_TYPE_MOOV, GF_FALSE, 0);\n\t\tgf_bs_del(bs);\n\t\tif (e) trak = NULL;\n\t\telse if (udta_only) {\n\t\t\tudta = trak->udta;\n\t\t\ttrak->udta = NULL;\n\t\t\tgf_list_del_item(trak->child_boxes, udta);\n\t\t\tgf_isom_box_del((GF_Box*)trak);\n\t\t\ttrak = NULL;\n\t\t} else {\n\t\t\tBool tpl_ok = GF_TRUE;\n\t\t\tif (!trak->Header || !trak->Media || !trak->Media->handler || !trak->Media->mediaHeader || !trak->Media->information) tpl_ok = GF_FALSE;\n\n\t\t\telse {\n\t\t\t\tif (!MediaType) MediaType = trak->Media->handler->handlerType;\n\t\t\t\te = NewMedia(&trak->Media, MediaType, TimeScale);\n\t\t\t\tif (e) tpl_ok = GF_FALSE;\n\t\t\t}\n\t\t\tif (!tpl_ok) {\n\t\t\t\tudta = trak->udta;\n\t\t\t\ttrak->udta = NULL;\n\t\t\t\tgf_isom_box_del((GF_Box*)trak);\n\t\t\t}\n\t\t}\n\t}\n\tnow = gf_isom_get_mp4time();\n\tif (!trak) {\n\t\t//OK, now create a track...\n\t\ttrak = (GF_TrackBox *) gf_isom_box_new_parent(&movie->moov->child_boxes, GF_ISOM_BOX_TYPE_TRAK);\n\t\tif (!trak) {\n\t\t\tgf_isom_set_last_error(movie, GF_OUT_OF_MEM);\n\t\t\treturn 0;\n\t\t}\n\t\ttkhd = (GF_TrackHeaderBox *) gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_TKHD);\n\t\tif (!tkhd) {\n\t\t\tgf_isom_set_last_error(movie, GF_OUT_OF_MEM);\n\t\t\treturn 0;\n\t\t}\n\n\t\t//OK, set up the media trak\n\t\te = NewMedia(&mdia, MediaType, TimeScale);\n\t\tif (e) {\n\t\t\tgf_isom_box_del((GF_Box *)mdia);\n\t\t\treturn 0;\n\t\t}\n\t\tassert(trak->child_boxes);\n\t\tgf_list_add(trak->child_boxes, mdia);\n\n\t\t//OK, add this media to our track\n\t\tmdia->mediaTrack = trak;\n\n\t\te = trak_on_child_box((GF_Box*)trak, (GF_Box *) tkhd, GF_FALSE);\n\t\tif (e) goto err_exit;\n\t\te = trak_on_child_box((GF_Box*)trak, (GF_Box *) mdia, GF_FALSE);\n\t\tif (e) goto err_exit;\n\t\ttkhd->trackID = trakID;\n\n\t\tif (gf_sys_is_test_mode() ) {\n\t\t\ttkhd->creationTime = 0;\n\t\t\tmdia->mediaHeader->creationTime = 0;\n\t\t} else {\n\t\t\ttkhd->creationTime = now;\n\t\t\tmdia->mediaHeader->creationTime = now;\n\t\t}\n\n\t} else {\n\t\ttkhd = trak->Header;\n\t\ttkhd->trackID = trakID;\n\t\tmdia = trak->Media;\n\t\tmdia->mediaTrack = trak;\n\t\tmdia->mediaHeader->timeScale = TimeScale;\n\t\tif (mdia->handler->handlerType != MediaType) {\n\t\t\tmdia->handler->handlerType = MediaType;\n\t\t\ttkhd->width = 0;\n\t\t\ttkhd->height = 0;\n\t\t\ttkhd->volume = 0;\n\t\t} else {\n\t\t\tMediaType = 0;\n\t\t}\n\t\ttrak->Header->duration = 0;\n\t\tmdia->mediaHeader->duration = 0;\n\n\t\tif (!movie->moov->child_boxes) movie->moov->child_boxes = gf_list_new();\n\t\tgf_list_add(movie->moov->child_boxes, trak);\n\t}\n\tif (MediaType) {\n\t\t//some default properties for Audio, Visual or private tracks\n\t\tswitch (MediaType) {\n\t\tcase GF_ISOM_MEDIA_VISUAL:\n\t\tcase GF_ISOM_MEDIA_AUXV:\n\t\tcase GF_ISOM_MEDIA_PICT:\n\t\tcase GF_ISOM_MEDIA_SCENE:\n\t\tcase GF_ISOM_MEDIA_TEXT:\n\t\tcase GF_ISOM_MEDIA_SUBT:\n\t\t\t/*320-240 pix in 16.16*/\n\t\t\ttkhd->width = 0x01400000;\n\t\t\ttkhd->height = 0x00F00000;\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_AUDIO:\n\t\t\ttkhd->volume = 0x0100;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmovie->last_created_track_id = tkhd->trackID;\n\t\n\tif (!movie->keep_utc && !gf_sys_is_test_mode() ) {\n\t\ttkhd->modificationTime = now;\n\t \tmdia->mediaHeader->modificationTime = now;\n\t}\n\n\t//OK, add our trak\n\te = moov_on_child_box((GF_Box*)movie->moov, (GF_Box *)trak, GF_FALSE);\n\tif (e) goto err_exit;\n\t//set the next track ID available\n\tif (trakID >= movie->moov->mvhd->nextTrackID)\n\t\tmovie->moov->mvhd->nextTrackID = trakID+1;\n\n\tif (udta) {\n\t\ttrak->udta = udta;\n\t\tgf_list_add(trak->child_boxes, udta);\n\t}\n\n\t//and return our track number\n\treturn gf_isom_get_track_by_id(movie, trakID);\n\nerr_exit:\n\t//tkhd is registered with track and will be destroyed there\n\tif (trak) gf_isom_box_del((GF_Box *)trak);\n\tif (mdia) gf_isom_box_del((GF_Box *)mdia);\n\treturn 0;\n}\n\nGF_Err gf_isom_set_track_stsd_templates(GF_ISOFile *movie, u32 trackNumber, u8 *stsd_data, u32 stsd_data_size)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tGF_SampleDescriptionBox *stsd=NULL;\n\tGF_List *tmp;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media) return GF_BAD_PARAM;\n\tif (gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes))\n\t\treturn GF_BAD_PARAM;\n\n\tGF_BitStream *bs = gf_bs_new(stsd_data, stsd_data_size, GF_BITSTREAM_READ);\n\te = gf_isom_box_parse_ex((GF_Box **) &stsd, bs, GF_ISOM_BOX_TYPE_STBL, GF_FALSE, 0);\n\tgf_bs_del(bs);\n\tif (!e && (stsd->type==GF_ISOM_BOX_TYPE_STSD)) {\n\t\ttmp = trak->Media->information->sampleTable->SampleDescription->child_boxes;\n\t\ttrak->Media->information->sampleTable->SampleDescription->child_boxes = stsd->child_boxes;\n\t\tstsd->child_boxes = tmp;\n\t}\n\tif (stsd) gf_isom_box_del((GF_Box*)stsd);\n\treturn e;\n}\n\nGF_EXPORT\nu32 gf_isom_new_track(GF_ISOFile *movie, GF_ISOTrackID trakID, u32 MediaType, u32 TimeScale)\n{\n\treturn gf_isom_new_track_from_template(movie, trakID, MediaType, TimeScale, NULL, 0, GF_FALSE);\n}\n\nGF_EXPORT\nGF_Err gf_isom_remove_stream_description(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tGF_SampleEntryBox *entry;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media) return GF_BAD_PARAM;\n\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tentry = (GF_SampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, StreamDescriptionIndex - 1);\n\tif (!entry) return GF_BAD_PARAM;\n\tgf_list_rem(trak->Media->information->sampleTable->SampleDescription->child_boxes, StreamDescriptionIndex - 1);\n\tgf_isom_box_del((GF_Box *)entry);\n\treturn GF_OK;\n}\n\n//Create a new StreamDescription in the file. The URL and URN are used to describe external media\nGF_EXPORT\nGF_Err gf_isom_new_mpeg4_description(GF_ISOFile *movie,\n                                     u32 trackNumber,\n                                     const GF_ESD *esd,\n                                     const char *URLname,\n                                     const char *URNname,\n                                     u32 *outDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tu32 dataRefIndex;\n\tGF_ESD *new_esd;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media ||\n\t        !esd || !esd->decoderConfig ||\n\t        !esd->slConfig) return GF_BAD_PARAM;\n\n\t//get or create the data ref\n\te = Media_FindDataRef(trak->Media->information->dataInformation->dref, (char *)URLname, (char *)URNname, &dataRefIndex);\n\tif (e) return e;\n\tif (!dataRefIndex) {\n\t\te = Media_CreateDataRef(movie, trak->Media->information->dataInformation->dref, (char *)URLname, (char *)URNname, &dataRefIndex);\n\t\tif (e) return e;\n\t}\n\t//duplicate our desc\n\te = gf_odf_desc_copy((GF_Descriptor *)esd, (GF_Descriptor **)&new_esd);\n\tif (e) return e;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\te = Track_SetStreamDescriptor(trak, 0, dataRefIndex, new_esd, outDescriptionIndex);\n\tif (e) {\n\t\tgf_odf_desc_del((GF_Descriptor *)new_esd);\n\t\treturn e;\n\t}\n\treturn e;\n}\n\nGF_Err gf_isom_flush_chunk(GF_TrackBox *trak, Bool is_final)\n{\n\tGF_Err e;\n\tu64 data_offset;\n\tu32 sample_number;\n\tu8 *chunk_data;\n\tu32 chunk_size, chunk_alloc;\n\tif (!trak->chunk_cache) return GF_OK;\n\n\tgf_bs_get_content_no_truncate(trak->chunk_cache, &chunk_data, &chunk_size, &chunk_alloc);\n\n\tdata_offset = gf_isom_datamap_get_offset(trak->Media->information->dataHandler);\n\n\te = gf_isom_datamap_add_data(trak->Media->information->dataHandler, chunk_data, chunk_size);\n\tif (e) return e;\n\n\tsample_number = 1 + trak->Media->information->sampleTable->SampleSize->sampleCount;\n\tsample_number -= trak->nb_samples_in_cache;\n\n\te = stbl_AddChunkOffset(trak->Media, sample_number, trak->chunk_stsd_idx, data_offset, trak->nb_samples_in_cache);\n\n\tif (is_final) {\n\t\tgf_free(chunk_data);\n\t\tgf_bs_del(trak->chunk_cache);\n\t\ttrak->chunk_cache = NULL;\n\t} else {\n\t\tgf_bs_reassign_buffer(trak->chunk_cache, chunk_data, chunk_alloc);\n\t}\n\treturn e;\n}\n\nstatic GF_Err trak_add_sample(GF_ISOFile *movie, GF_TrackBox *trak, const GF_ISOSample *sample, u32 descIndex, u64 data_offset, u32 syncShadowSampleNum)\n{\n\tBool skip_data = GF_FALSE;\n\tGF_Err e;\n\n\t//faststart mode with interleaving time, cache data until we have a full chunk\n\tif ((movie->storageMode==GF_ISOM_STORE_FASTSTART) && movie->interleavingTime) {\n\t\tBool flush_chunk = GF_FALSE;\n\t\tu64 stime = sample->DTS;\n\t\tstime *= movie->moov->mvhd->timeScale;\n\t\tstime /= trak->Media->mediaHeader->timeScale;\n\n\t\tif (stime - trak->first_dts_chunk > movie->interleavingTime)\n\t\t\tflush_chunk = GF_TRUE;\n\n\t\tif (movie->next_flush_chunk_time < stime)\n\t\t\tflush_chunk = GF_TRUE;\n\n\t\tif (trak->chunk_stsd_idx != descIndex)\n\t\t\tflush_chunk = GF_TRUE;\n\n\t\tif (trak->Media->information->sampleTable->MaxChunkSize && trak->Media->information->sampleTable->MaxChunkSize < trak->chunk_cache_size + sample->dataLength)\n\t\t\tflush_chunk = GF_TRUE;\n\n\t\tif (flush_chunk) {\n\t\t\tmovie->next_flush_chunk_time = stime + movie->interleavingTime;\n\t\t\tif (trak->chunk_cache) {\n\t\t\t\te = gf_isom_flush_chunk(trak, GF_FALSE);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\t\t\ttrak->nb_samples_in_cache = 0;\n\t\t\ttrak->chunk_cache_size = 0;\n\t\t\ttrak->first_dts_chunk = stime;\n\t\t}\n\t\tif (!trak->chunk_cache)\n\t\t\ttrak->chunk_cache = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\tgf_bs_write_data(trak->chunk_cache, sample->data, sample->dataLength);\n\t\ttrak->nb_samples_in_cache += sample->nb_pack ? sample->nb_pack : 1;\n\t\ttrak->chunk_cache_size += sample->dataLength;\n\t\ttrak->chunk_stsd_idx = descIndex;\n\n\t\tskip_data = GF_TRUE;\n\t}\n\n\te = Media_AddSample(trak->Media, data_offset, sample, descIndex, syncShadowSampleNum);\n\tif (e) return e;\n\n\tif (!skip_data && sample->dataLength) {\n\t\te = gf_isom_datamap_add_data(trak->Media->information->dataHandler, sample->data, sample->dataLength);\n\t\tif (e) return e;\n\t}\n\n\treturn GF_OK;\n}\n\n//Add samples to a track. Use streamDescriptionIndex to specify the desired stream (if several)\nGF_EXPORT\nGF_Err gf_isom_add_sample(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, const GF_ISOSample *sample)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tu32 dataRefIndex;\n\tu64 data_offset;\n\tu32 descIndex;\n\tGF_DataEntryURLBox *Dentry;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\te = FlushCaptureMode(movie);\n\tif (e) return e;\n\n\te = unpack_track(trak);\n\tif (e) return e;\n\n\t//OK, add the sample\n\t//1- Get the streamDescriptionIndex and dataRefIndex\n\t//not specified, get the latest used...\n\tdescIndex = StreamDescriptionIndex;\n\tif (!StreamDescriptionIndex) {\n\t\tdescIndex = trak->Media->information->sampleTable->currentEntryIndex;\n\t}\n\te = Media_GetSampleDesc(trak->Media, descIndex, &entry, &dataRefIndex);\n\tif (e) return e;\n\tif (!entry || !dataRefIndex) return GF_BAD_PARAM;\n\t//set the current to this one\n\ttrak->Media->information->sampleTable->currentEntryIndex = descIndex;\n\n\n\t//get this dataRef and return false if not self contained\n\tDentry = (GF_DataEntryURLBox*)gf_list_get(trak->Media->information->dataInformation->dref->child_boxes, dataRefIndex - 1);\n\tif (!Dentry || Dentry->flags != 1) return GF_BAD_PARAM;\n\n\t//Open our data map. We are adding stuff, so use EDIT\n\te = gf_isom_datamap_open(trak->Media, dataRefIndex, 1);\n\tif (e) return e;\n\n\t//Get the offset...\n\tdata_offset = gf_isom_datamap_get_offset(trak->Media->information->dataHandler);\n\n\t/*rewrite OD frame*/\n\tif (trak->Media->handler->handlerType == GF_ISOM_MEDIA_OD) {\n\t\tGF_ISOSample *od_sample = NULL;\n\n\t\te = Media_ParseODFrame(trak->Media, sample, &od_sample);\n\t\tif (e) return e;\n\n\t\te = trak_add_sample(movie, trak, od_sample, descIndex, data_offset, 0);\n\n\t\tif (od_sample)\n\t\t\tgf_isom_sample_del(&od_sample);\n\t} else {\n\t\te = trak_add_sample(movie, trak, sample, descIndex, data_offset, 0);\n\t}\n\tif (e) return e;\n\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\t//update media duration\n\tif ((s64)sample->DTS + sample->CTS_Offset>=0) {\n\t\tGF_TimeToSampleBox *stts = trak->Media->information->sampleTable->TimeToSample;\n\t\tu64 dur = sample->DTS + sample->CTS_Offset;\n\t\tdur += stts->entries[stts->nb_entries-1].sampleDelta;\n\n\t\tif (dur > trak->Media->mediaHeader->duration) {\n\t\t\ttrak->Media->mediaHeader->duration = dur;\n\t\t}\n\t}\n\t//do not update track duration yet, this is done on close\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_add_sample_shadow(GF_ISOFile *movie, u32 trackNumber, GF_ISOSample *sample)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_ISOSample *prev;\n\tGF_SampleEntryBox *entry;\n\tu32 dataRefIndex;\n\tu64 data_offset;\n\tu32 descIndex;\n\tu32 sampleNum, prevSampleNum;\n\tGF_DataEntryURLBox *Dentry;\n\tBool offset_times = GF_FALSE;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !sample) return GF_BAD_PARAM;\n\n\te = FlushCaptureMode(movie);\n\tif (e) return e;\n\n\te = unpack_track(trak);\n\tif (e) return e;\n\n\te = stbl_findEntryForTime(trak->Media->information->sampleTable, sample->DTS, 0, &sampleNum, &prevSampleNum);\n\tif (e) return e;\n\t/*we need the EXACT match*/\n\tif (!sampleNum) return GF_BAD_PARAM;\n\n\tprev = gf_isom_get_sample_info(movie, trackNumber, sampleNum, &descIndex, NULL);\n\tif (!prev) return gf_isom_last_error(movie);\n\t/*for conformance*/\n\tif (sample->DTS==prev->DTS) offset_times = GF_TRUE;\n\tgf_isom_sample_del(&prev);\n\n\te = Media_GetSampleDesc(trak->Media, descIndex, &entry, &dataRefIndex);\n\tif (e) return e;\n\tif (!entry || !dataRefIndex) return GF_BAD_PARAM;\n\ttrak->Media->information->sampleTable->currentEntryIndex = descIndex;\n\n\t//get this dataRef and return false if not self contained\n\tDentry = (GF_DataEntryURLBox*)gf_list_get(trak->Media->information->dataInformation->dref->child_boxes, dataRefIndex - 1);\n\tif (!Dentry || Dentry->flags != 1) return GF_BAD_PARAM;\n\n\t//Open our data map. We are adding stuff, so use EDIT\n\te = gf_isom_datamap_open(trak->Media, dataRefIndex, 1);\n\tif (e) return e;\n\n\tdata_offset = gf_isom_datamap_get_offset(trak->Media->information->dataHandler);\n\tif (offset_times) sample->DTS += 1;\n\n\t/*REWRITE ANY OD STUFF*/\n\tif (trak->Media->handler->handlerType == GF_ISOM_MEDIA_OD) {\n\t\tGF_ISOSample *od_sample = NULL;\n\t\te = Media_ParseODFrame(trak->Media, sample, &od_sample);\n\t\tif (e) return e;\n\n\t\te = trak_add_sample(movie, trak, od_sample, descIndex, data_offset, sampleNum);\n\t\tif (od_sample)\n\t\t\tgf_isom_sample_del(&od_sample);\n\t} else {\n\t\te = trak_add_sample(movie, trak, sample, descIndex, data_offset, sampleNum);\n\t}\n\tif (e) return e;\n\tif (offset_times) sample->DTS -= 1;\n\n\t//OK, update duration\n\te = Media_SetDuration(trak);\n\tif (e) return e;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\treturn SetTrackDuration(trak);\n}\n\nGF_EXPORT\nGF_Err gf_isom_append_sample_data(GF_ISOFile *movie, u32 trackNumber, u8 *data, u32 data_size)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tu32 dataRefIndex;\n\tu32 descIndex;\n\tGF_DataEntryURLBox *Dentry;\n\n\tif (!data_size) return GF_OK;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tif (trak->Media->handler->handlerType == GF_ISOM_MEDIA_OD) return GF_BAD_PARAM;\n\n\t//OK, add the sample\n\tdescIndex = trak->Media->information->sampleTable->currentEntryIndex;\n\n\te = Media_GetSampleDesc(trak->Media, descIndex, &entry, &dataRefIndex);\n\tif (e) return e;\n\tif (!entry || !dataRefIndex) return GF_BAD_PARAM;\n\n\t//get this dataRef and return false if not self contained\n\tDentry = (GF_DataEntryURLBox*)gf_list_get(trak->Media->information->dataInformation->dref->child_boxes, dataRefIndex - 1);\n\tif (!Dentry || Dentry->flags != 1) return GF_BAD_PARAM;\n\n\t//Open our data map. We are adding stuff, so use EDIT\n\te = gf_isom_datamap_open(trak->Media, dataRefIndex, 1);\n\tif (e) return e;\n\n\t//add the media data\n\tif (trak->chunk_cache) {\n\t\tgf_bs_write_data(trak->chunk_cache, data, data_size);\n\t\ttrak->chunk_cache_size += data_size;\n\t} else {\n\t\te = gf_isom_datamap_add_data(trak->Media->information->dataHandler, data, data_size);\n\t\tif (e) return e;\n\t}\n\t//update data size\n\treturn stbl_SampleSizeAppend(trak->Media->information->sampleTable->SampleSize, data_size);\n}\n\n\n//Add sample reference to a track. The SampleOffset is the offset of the data in the referenced file\n//you must have created a StreamDescription with URL or URN specifying your referenced file\n//the data offset specifies the beginning of the chunk\n//Use streamDescriptionIndex to specify the desired stream (if several)\nGF_EXPORT\nGF_Err gf_isom_add_sample_reference(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, GF_ISOSample *sample, u64 dataOffset)\n{\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tu32 dataRefIndex;\n\tu32 descIndex;\n\tGF_DataEntryURLBox *Dentry;\n\tGF_Err e;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\te = unpack_track(trak);\n\tif (e) return e;\n\n\t//OD is not allowed as a data ref\n\tif (trak->Media->handler->handlerType == GF_ISOM_MEDIA_OD) {\n\t\treturn GF_BAD_PARAM;\n\t}\n\t//OK, add the sample\n\t//1- Get the streamDescriptionIndex and dataRefIndex\n\t//not specified, get the latest used...\n\tdescIndex = StreamDescriptionIndex;\n\tif (!StreamDescriptionIndex) {\n\t\tdescIndex = trak->Media->information->sampleTable->currentEntryIndex;\n\t}\n\te = Media_GetSampleDesc(trak->Media, descIndex, &entry, &dataRefIndex);\n\tif (e) return e;\n\tif (!entry || !dataRefIndex) return GF_BAD_PARAM;\n\t//set the current to this one\n\ttrak->Media->information->sampleTable->currentEntryIndex = descIndex;\n\n\n\t//get this dataRef and return false if self contained\n\tDentry =(GF_DataEntryURLBox*) gf_list_get(trak->Media->information->dataInformation->dref->child_boxes, dataRefIndex - 1);\n\tif (Dentry->flags == 1) return GF_BAD_PARAM;\n\n\t//add the meta data\n\te = Media_AddSample(trak->Media, dataOffset, sample, descIndex, 0);\n\tif (e) return e;\n\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\t//OK, update duration\n\te = Media_SetDuration(trak);\n\tif (e) return e;\n\treturn SetTrackDuration(trak);\n\n}\n\n//set the duration of the last media sample. If not set, the duration of the last sample is the\n//duration of the previous one if any, or 1000 (default value).\nstatic GF_Err gf_isom_set_last_sample_duration_internal(GF_ISOFile *movie, u32 trackNumber, u64 dur_num, u32 dur_den, u32 mode)\n{\n\tGF_TrackBox *trak;\n\tGF_SttsEntry *ent;\n\tGF_TimeToSampleBox *stts;\n\tu64 mdur;\n\tu32 duration;\n\tGF_Err e;\n\tBool is_patch = GF_FALSE;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tif (mode==0) {\n\t\tduration = (u32) dur_num;\n\t} else if (mode==1) {\n\t\tduration = (u32) dur_num;\n\t\tif (dur_den) {\n\t\t\tduration *= trak->Media->mediaHeader->timeScale;\n\t\t\tduration /= dur_den;\n\t\t}\n\t} else {\n\t\tis_patch = GF_TRUE;\n\t}\n\tmdur = trak->Media->mediaHeader->duration;\n\tstts = trak->Media->information->sampleTable->TimeToSample;\n\tif (!stts->nb_entries) return GF_BAD_PARAM;\n\n\tif (is_patch) {\n\t\tu32 i, avg_dur, nb_samp=0;\n\t\tu64 cum_dur=0;\n\t\tfor (i=0; i<stts->nb_entries; i++) {\n\t\t\tent = (GF_SttsEntry*) &stts->entries[i];\n\t\t\tcum_dur += ent->sampleCount*ent->sampleDelta;\n\t\t\tnb_samp += ent->sampleCount;\n\t\t}\n\t\tif (cum_dur <= dur_num || !nb_samp) return GF_OK;\n\t\tavg_dur = (u32) (dur_num / nb_samp);\n\n\t\tstts->entries[0].sampleDelta = avg_dur;\n\t\tstts->entries[0].sampleCount = nb_samp;\n\t\tstts->nb_entries = 1;\n\t\tstts->w_LastDTS = dur_num - avg_dur;\n\t\treturn GF_OK;\n\t}\n\t//get the last entry\n\tent = (GF_SttsEntry*) &stts->entries[stts->nb_entries-1];\n\tif ((mode==1) && !duration && !dur_den) {\n\t\t//same as previous, nothing to adjust\n\t\tif (ent->sampleCount>1) return GF_OK;\n\t\tif (stts->nb_entries==1) return GF_OK;\n\t\tduration = stts->entries[stts->nb_entries-2].sampleDelta;\n\t}\n\n\tmdur -= ent->sampleDelta;\n\tmdur += duration;\n\n\t//we only have one sample\n\tif (ent->sampleCount == 1) {\n\t\tent->sampleDelta = (u32) duration;\n\t\tif (mode && (stts->nb_entries>1) && (stts->entries[stts->nb_entries-2].sampleDelta==duration)) {\n\t\t\tstts->entries[stts->nb_entries-2].sampleCount++;\n\t\t\tstts->nb_entries--;\n\t\t\t//and update the write cache\n\t\t\tstts->w_currentSampleNum = trak->Media->information->sampleTable->SampleSize->sampleCount;\n\t\t}\n\t} else {\n\t\tif (ent->sampleDelta == duration) return GF_OK;\n\t\tent->sampleCount -= 1;\n\n\t\tif (stts->nb_entries==stts->alloc_size) {\n\t\t\tstts->alloc_size++;\n\t\t\tstts->entries = (GF_SttsEntry*)gf_realloc(stts->entries, sizeof(GF_SttsEntry)*stts->alloc_size);\n\t\t\tif (!stts->entries) return GF_OUT_OF_MEM;\n\t\t}\n\t\tstts->entries[stts->nb_entries].sampleCount = 1;\n\t\tstts->entries[stts->nb_entries].sampleDelta = (u32) duration;\n\t\tstts->nb_entries++;\n\t\t//and update the write cache\n\t\tstts->w_currentSampleNum = trak->Media->information->sampleTable->SampleSize->sampleCount;\n\t}\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\t//update media duration if duration was set\n\tif (trak->Media->mediaHeader->duration)\n\t\ttrak->Media->mediaHeader->duration = mdur;\n\t//do not update track duration yet, this is done on close\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_last_sample_duration(GF_ISOFile *movie, u32 trackNumber, u32 duration)\n{\n\treturn gf_isom_set_last_sample_duration_internal(movie, trackNumber, duration, 0, 0);\n}\n\nGF_EXPORT\nGF_Err gf_isom_patch_last_sample_duration(GF_ISOFile *movie, u32 trackNumber, u64 next_dts)\n{\n\treturn gf_isom_set_last_sample_duration_internal(movie, trackNumber, next_dts, 0, 2);\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_last_sample_duration_ex(GF_ISOFile *movie, u32 trackNumber, u32 dur_num, u32 dur_den)\n{\n\treturn gf_isom_set_last_sample_duration_internal(movie, trackNumber, dur_num, dur_den, 1);\n}\n\n//update a sample data in the media. Note that the sample MUST exists\nGF_EXPORT\nGF_Err gf_isom_update_sample(GF_ISOFile *movie, u32 trackNumber, u32 sampleNumber, GF_ISOSample *sample, Bool data_only)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_EDIT);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\te = unpack_track(trak);\n\tif (e) return e;\n\n\t//block for hint tracks\n\tif (trak->Media->handler->handlerType == GF_ISOM_MEDIA_HINT) return GF_BAD_PARAM;\n\n\t//REWRITE ANY OD STUFF\n\tif (trak->Media->handler->handlerType == GF_ISOM_MEDIA_OD) {\n\t\tGF_ISOSample *od_sample = NULL;\n\t\te = Media_ParseODFrame(trak->Media, sample, &od_sample);\n\t\tif (!e) e = Media_UpdateSample(trak->Media, sampleNumber, od_sample, data_only);\n\t\tif (od_sample) gf_isom_sample_del(&od_sample);\n\t} else {\n\t\te = Media_UpdateSample(trak->Media, sampleNumber, sample, data_only);\n\t}\n\tif (e) return e;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tgf_isom_disable_inplace_rewrite(movie);\n\treturn GF_OK;\n}\n\n//update a sample data in the media. Note that the sample MUST exists,\n//that sample->data MUST be NULL and sample->dataLength must be NON NULL;\nGF_EXPORT\nGF_Err gf_isom_update_sample_reference(GF_ISOFile *movie, u32 trackNumber, u32 sampleNumber, GF_ISOSample *sample, u64 data_offset)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_EDIT);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\t//block for hint tracks\n\tif (trak->Media->handler->handlerType == GF_ISOM_MEDIA_HINT) return GF_BAD_PARAM;\n\n\tif (!sampleNumber || !sample) return GF_BAD_PARAM;\n\n\te = unpack_track(trak);\n\tif (e) return e;\n\n\t//OD is not allowed as a data ref\n\tif (trak->Media->handler->handlerType == GF_ISOM_MEDIA_OD) {\n\t\treturn GF_BAD_PARAM;\n\t}\n\t//OK, update it\n\te = Media_UpdateSampleReference(trak->Media, sampleNumber, sample, data_offset);\n\tif (e) return e;\n\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\treturn GF_OK;\n}\n\n//for gf_isom_remove_sample and gf_isom_remove_track: check all items sharing their data with a sample being removed\n//and remove sharing flag\n// sample_number can be 0 for complete track removal\nstatic void gf_isom_meta_track_remove(GF_ISOFile *movie, GF_TrackBox *trak, u32 sample_number)\n{\n\tu32 i, count;\n\tif (!movie || !movie->meta || !movie->meta->use_item_sample_sharing)\n\t\treturn;\n\n\tcount = gf_list_count(movie->meta->item_locations->location_entries);\n\tfor (i=0; i<count; i++) {\n\t\tu32 j;\n\t\tGF_ItemLocationEntry *iloc = (GF_ItemLocationEntry *)gf_list_get(movie->meta->item_locations->location_entries, i);\n\t\t/*get item info*/\n\t\tGF_ItemInfoEntryBox *iinf = NULL;\n\t\tj=0;\n\t\twhile ((iinf = (GF_ItemInfoEntryBox *)gf_list_enum(movie->meta->item_infos->item_infos, &j))) {\n\t\t\tif (iinf->item_ID==iloc->item_ID) break;\n\t\t}\n\t\tif (!iinf || !iinf->tk_id) continue;\n\t\tif (iinf->tk_id != trak->Header->trackID) continue;\n\n\t\tif (sample_number && (iinf->sample_num != sample_number)) continue;\n\t\tiinf->tk_id = 0;\n\t\tiinf->sample_num = 0;\n\t}\n}\n\n\n\n//Remove a given sample\nGF_EXPORT\nGF_Err gf_isom_remove_sample(GF_ISOFile *movie, u32 trackNumber, u32 sampleNumber)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_EDIT);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !sampleNumber || (sampleNumber > trak->Media->information->sampleTable->SampleSize->sampleCount) )\n\t\treturn GF_BAD_PARAM;\n\n\t//block for hint tracks\n\tif (trak->Media->handler->handlerType == GF_ISOM_MEDIA_HINT) return GF_BAD_PARAM;\n\n\te = unpack_track(trak);\n\tif (e) return e;\n\t//do NOT change the order DTS, CTS, size chunk\n\n\t//remove DTS\n\te = stbl_RemoveDTS(trak->Media->information->sampleTable, sampleNumber, 1, trak->Media->mediaHeader->timeScale);\n\tif (e) return e;\n\t//remove CTS if any\n\tif (trak->Media->information->sampleTable->CompositionOffset) {\n\t\te = stbl_RemoveCTS(trak->Media->information->sampleTable, sampleNumber, 1);\n\t\tif (e) return e;\n\t}\n\t//remove size\n\te = stbl_RemoveSize(trak->Media->information->sampleTable, sampleNumber, 1);\n\tif (e) return e;\n\t//remove sampleToChunk and chunk\n\te = stbl_RemoveChunk(trak->Media->information->sampleTable, sampleNumber, 1);\n\tif (e) return e;\n\t//remove sync\n\tif (trak->Media->information->sampleTable->SyncSample) {\n\t\te = stbl_RemoveRAP(trak->Media->information->sampleTable, sampleNumber);\n\t\tif (e) return e;\n\t}\n\t//remove sample dep\n\tif (trak->Media->information->sampleTable->SampleDep) {\n\t\te = stbl_RemoveRedundant(trak->Media->information->sampleTable, sampleNumber, 1);\n\t\tif (e) return e;\n\t}\n\t//remove shadow\n\te = stbl_RemoveShadow(trak->Media->information->sampleTable, sampleNumber);\n\tif (e) return e;\n\n\t//remove padding\n\te = stbl_RemovePaddingBits(trak->Media->information->sampleTable, sampleNumber);\n\tif (e) return e;\n\n\te = stbl_RemoveSubSample(trak->Media->information->sampleTable, sampleNumber);\n\tif (e) return e;\n\n\te = stbl_RemoveSampleGroup(trak->Media->information->sampleTable, sampleNumber);\n\tif (e) return e;\n\n\tgf_isom_disable_inplace_rewrite(movie);\n\n\tgf_isom_meta_track_remove(movie, trak, sampleNumber);\n\n\treturn SetTrackDuration(trak);\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_set_final_name(GF_ISOFile *movie, char *filename)\n{\n\tGF_Err e;\n\tif (!movie ) return GF_BAD_PARAM;\n\n\t//if mode is not OPEN_EDIT file was created under the right name\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_EDIT);\n\tif (e) return e;\n\n\tif (filename) {\n\t\t//we don't allow file overwriting\n\t\tif ( (movie->openMode == GF_ISOM_OPEN_EDIT)\n\t\t        && movie->fileName && !strcmp(filename, movie->fileName))\n\t\t\treturn GF_BAD_PARAM;\n\t\tif (movie->finalName) gf_free(movie->finalName);\n\t\tmovie->finalName = gf_strdup(filename);\n\t\tif (!movie->finalName) return GF_OUT_OF_MEM;\n\t\tgf_isom_disable_inplace_rewrite(movie);\n\t}\n\treturn GF_OK;\n}\n\n//Add a system descriptor to the ESD of a stream(EDIT or WRITE mode only)\nGF_EXPORT\nGF_Err gf_isom_add_desc_to_description(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, const GF_Descriptor *theDesc)\n{\n\tGF_IPIPtr *ipiD;\n\tGF_Err e;\n\tu16 tmpRef;\n\tGF_TrackBox *trak;\n\tGF_Descriptor *desc;\n\tGF_ESD *esd;\n\tGF_TrackReferenceBox *tref;\n\tGF_TrackReferenceTypeBox *dpnd;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\tu32 msubtype;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\t/*GETS NATIVE DESCRIPTOR ONLY*/\n\te = Media_GetESD(trak->Media, StreamDescriptionIndex, &esd, GF_TRUE);\n\tif (e) return e;\n\n\tentry = gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, StreamDescriptionIndex-1);\n\tif (!entry) return GF_BAD_PARAM;\n\tmsubtype = entry->type;\n\tif ((msubtype==GF_ISOM_BOX_TYPE_ENCV) || (msubtype==GF_ISOM_BOX_TYPE_ENCA))\n\t\tgf_isom_get_original_format_type(movie, trackNumber, StreamDescriptionIndex, &msubtype);\n\n\t//duplicate the desc\n\te = gf_odf_desc_copy((GF_Descriptor *)theDesc, &desc);\n\tif (e) return e;\n\n\t//and add it to the ESD EXCEPT IPI PTR (we need to translate from ES_ID to TrackID!!!\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tswitch (desc->tag) {\n\tcase GF_ODF_IPI_PTR_TAG:\n\t\tgoto insertIPI;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif ((msubtype==GF_ISOM_BOX_TYPE_MP4S) || (msubtype==GF_ISOM_BOX_TYPE_MP4V) || (msubtype==GF_ISOM_BOX_TYPE_MP4A)) {\n\t\treturn gf_odf_desc_add_desc((GF_Descriptor *)esd, desc);\n\t}\n\n\tif (trak->Media->handler->handlerType!=GF_ISOM_MEDIA_VISUAL) {\n\t\tgf_odf_desc_del(desc);\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\tGF_MPEG4ExtensionDescriptorsBox *mdesc = (GF_MPEG4ExtensionDescriptorsBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_M4DS);\n\tif (!mdesc) {\n\t\tmdesc = (GF_MPEG4ExtensionDescriptorsBox *) gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_M4DS);\n\t}\n\treturn gf_list_add(mdesc->descriptors, desc);\n\ninsertIPI:\n\tif (esd->ipiPtr) {\n\t\tgf_odf_desc_del((GF_Descriptor *) esd->ipiPtr);\n\t\tesd->ipiPtr = NULL;\n\t}\n\n\tipiD = (GF_IPIPtr *) desc;\n\t//find a tref\n\tif (!trak->References) {\n\t\ttref = (GF_TrackReferenceBox *) gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_TREF);\n\t\tif (!tref) return GF_OUT_OF_MEM;\n\t\te = trak_on_child_box((GF_Box*)trak, (GF_Box *)tref, GF_FALSE);\n\t\tif (e) return e;\n\t}\n\ttref = trak->References;\n\n\te = Track_FindRef(trak, GF_ISOM_REF_IPI, &dpnd);\n\tif (e) return e;\n\tif (!dpnd) {\n\t\ttmpRef = 0;\n\t\tdpnd = (GF_TrackReferenceTypeBox *) gf_isom_box_new_parent(&tref->child_boxes, GF_ISOM_BOX_TYPE_REFT);\n\t\tif (!dpnd) return GF_OUT_OF_MEM;\n\t\tdpnd->reference_type = GF_ISOM_BOX_TYPE_IPIR;\n\t\te = reftype_AddRefTrack(dpnd, ipiD->IPI_ES_Id, &tmpRef);\n\t\tif (e) return e;\n\t\t//and replace the tag and value...\n\t\tipiD->IPI_ES_Id = tmpRef;\n\t\tipiD->tag = GF_ODF_ISOM_IPI_PTR_TAG;\n\t} else {\n\t\t//Watch out! ONLY ONE IPI dependency is allowed per stream\n\t\tdpnd->trackIDCount = 1;\n\t\tdpnd->trackIDs[0] = ipiD->IPI_ES_Id;\n\t\t//and replace the tag and value...\n\t\tipiD->IPI_ES_Id = 1;\n\t\tipiD->tag = GF_ODF_ISOM_IPI_PTR_TAG;\n\t}\n\t//and add the desc to the esd...\n\treturn gf_odf_desc_add_desc((GF_Descriptor *)esd, desc);\n}\n\n\n//use carefully. Very useful when you made a lot of changes (IPMP, IPI, OCI, ...)\n//THIS WILL REPLACE THE WHOLE DESCRIPTOR ...\nGF_EXPORT\nGF_Err gf_isom_change_mpeg4_description(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, const GF_ESD *newESD)\n{\n\tGF_Err e;\n\tGF_ESD *esd;\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn movie->LastError = GF_BAD_PARAM;\n\t}\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\t//duplicate our desc\n\te = gf_odf_desc_copy((GF_Descriptor *)newESD, (GF_Descriptor **)&esd);\n\tif (e) return e;\n\te = Track_SetStreamDescriptor(trak, StreamDescriptionIndex, entry->dataReferenceIndex, esd, NULL);\n\tif (e != GF_OK) {\n\t\tgf_odf_desc_del((GF_Descriptor *) esd);\n\t}\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_visual_info(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, u32 Width, u32 Height)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) {\n\t\treturn movie->LastError = GF_ISOM_INVALID_FILE;\n\t}\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn movie->LastError = GF_BAD_PARAM;\n\t}\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\t//valid for MPEG visual, JPG and 3GPP H263\n\tif (entry->internal_type == GF_ISOM_SAMPLE_ENTRY_VIDEO) {\n\t\t((GF_VisualSampleEntryBox*)entry)->Width = Width;\n\t\t((GF_VisualSampleEntryBox*)entry)->Height = Height;\n\t\ttrak->Header->width = Width<<16;\n\t\ttrak->Header->height = Height<<16;\n\t\treturn GF_OK;\n\t} else if (trak->Media->handler->handlerType==GF_ISOM_MEDIA_SCENE) {\n\t\ttrak->Header->width = Width<<16;\n\t\ttrak->Header->height = Height<<16;\n\t\treturn GF_OK;\n\t} else {\n\t\treturn GF_BAD_PARAM;\n\t}\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_visual_bit_depth(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, u16 bitDepth)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tswitch (trak->Media->handler->handlerType) {\n\tcase GF_ISOM_MEDIA_VISUAL:\n\tcase GF_ISOM_MEDIA_PICT:\n\tcase GF_ISOM_MEDIA_AUXV:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_OK;\n\t}\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) {\n\t\treturn movie->LastError = GF_ISOM_INVALID_FILE;\n\t}\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn movie->LastError = GF_BAD_PARAM;\n\t}\n\tentry = (GF_MPEGVisualSampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\tentry->bit_depth = bitDepth;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_pixel_aspect_ratio(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, s32 hSpacing, s32 vSpacing, Bool force_par)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn movie->LastError = GF_BAD_PARAM;\n\t}\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return GF_BAD_PARAM;\n\n\tif (hSpacing<0) hSpacing = 1;\n\tif (vSpacing<0) vSpacing = 1;\n\n\tGF_PixelAspectRatioBox *pasp = (GF_PixelAspectRatioBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_PASP);\n\tif (!hSpacing || !vSpacing || ((hSpacing == vSpacing) && !force_par))  {\n\t\tif (pasp) gf_isom_box_del_parent(&entry->child_boxes, (GF_Box *)pasp);\n\t\treturn GF_OK;\n\t}\n\tif (!pasp) {\n\t\tpasp = (GF_PixelAspectRatioBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_PASP);\n\t\tif (!pasp) return GF_OUT_OF_MEM;\n\t}\n\tpasp->hSpacing = (u32) hSpacing;\n\tpasp->vSpacing = (u32) vSpacing;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_visual_color_info(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, u32 colour_type, u16 colour_primaries, u16 transfer_characteristics, u16 matrix_coefficients, Bool full_range_flag, u8 *icc_data, u32 icc_size)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\tGF_ColourInformationBox *clr=NULL;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn movie->LastError = GF_BAD_PARAM;\n\t}\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return GF_OK;\n\n\tclr = (GF_ColourInformationBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_COLR);\n\tif (!colour_type) {\n\t\tif (clr) gf_isom_box_del_parent(&entry->child_boxes, (GF_Box *)clr);\n\t\treturn GF_OK;\n\t}\n\tif (clr) {\n\t\t//create another color box\n\t\tif (clr->opaque && !icc_data) clr = NULL;\n\t\telse if (!clr->opaque && icc_data) clr = NULL;\n\t}\n\n\tif (!clr) {\n\t\tclr = (GF_ColourInformationBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_COLR);\n\t\tif (!clr) return GF_OUT_OF_MEM;\n\t}\n\tclr->colour_type = colour_type;\n\tclr->colour_primaries = colour_primaries;\n\tclr->transfer_characteristics = transfer_characteristics;\n\tclr->matrix_coefficients = matrix_coefficients;\n\tclr->full_range_flag = full_range_flag;\n\tif (clr->opaque) gf_free(clr->opaque);\n\tclr->opaque = NULL;\n\tclr->opaque_size = 0;\n\tif ((colour_type==GF_ISOM_SUBTYPE_RICC) || (colour_type==GF_ISOM_SUBTYPE_PROF)) {\n\t\tclr->opaque_size = icc_data ? icc_size : 0;\n\t\tif (clr->opaque_size) {\n\t\t\tclr->opaque = gf_malloc(sizeof(char)*clr->opaque_size);\n\t\t\tif (!clr->opaque) return GF_OUT_OF_MEM;\n\t\t\tmemcpy(clr->opaque, icc_data, sizeof(char)*clr->opaque_size);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_dolby_vision_profile(GF_ISOFile* movie, u32 trackNumber, u32 StreamDescriptionIndex, GF_DOVIDecoderConfigurationRecord *dvcc)\n{\n\tGF_Err e;\n\tGF_TrackBox* trak;\n\tGF_Box *dv_cfge = NULL;\n\tGF_MPEGVisualSampleEntryBox* entry;\n\tBool switch_type = GF_FALSE;\n\tBool is_avc = GF_FALSE;\n\tGF_SampleDescriptionBox* stsd;\n\tGF_DOVIConfigurationBox* dovi = NULL;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn movie->LastError = GF_BAD_PARAM;\n\t}\n\tentry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return GF_OK;\n\n\tif (dvcc) {\n\t\tswitch_type = dvcc->force_dv;\n\t\tswitch (dvcc->dv_profile) {\n\t\tcase 1:\n\t\tcase 3:\n\t\tcase 5:\n\t\t\tswitch_type = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (entry->type) {\n\tcase GF_ISOM_BOX_TYPE_HEV1:\n\tcase GF_ISOM_BOX_TYPE_HEV2:\n\tcase GF_ISOM_BOX_TYPE_DVHE:\n\t\tentry->type = switch_type ? GF_ISOM_BOX_TYPE_DVHE : GF_ISOM_BOX_TYPE_HEV1;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_HVC1:\n\tcase GF_ISOM_BOX_TYPE_HVC2:\n\tcase GF_ISOM_BOX_TYPE_DVH1:\n\t\tentry->type = switch_type ? GF_ISOM_BOX_TYPE_DVH1 : GF_ISOM_BOX_TYPE_HVC1;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_AVC1:\n\tcase GF_ISOM_BOX_TYPE_DVA1:\n\t\tis_avc = GF_TRUE;\n\t\tentry->type = switch_type ? GF_ISOM_BOX_TYPE_DVA1 : GF_ISOM_BOX_TYPE_AVC1;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_AVC3:\n\tcase GF_ISOM_BOX_TYPE_DVAV:\n\t\tis_avc = GF_TRUE;\n\t\tentry->type = switch_type ? GF_ISOM_BOX_TYPE_DVAV : GF_ISOM_BOX_TYPE_AVC3;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_AV01:\n\tcase GF_ISOM_BOX_TYPE_DAV1:\n\t\tentry->type = switch_type ? GF_ISOM_BOX_TYPE_DAV1 : GF_ISOM_BOX_TYPE_AV01;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\n\tu32 dve_type = is_avc ? GF_ISOM_BOX_TYPE_AVCE : GF_ISOM_BOX_TYPE_HVCE;\n\tdv_cfge = gf_isom_box_find_child(entry->child_boxes, dve_type);\n\n\tdovi = entry->dovi_config;\n\tif (!dvcc) {\n\t\tif (dovi) gf_isom_box_del_parent(&entry->child_boxes, (GF_Box*)dovi);\n\t\tentry->dovi_config = NULL;\n\n\t\tif (dv_cfge) gf_isom_box_del_parent(&entry->child_boxes, dv_cfge);\n\t\t//reverse entry type\n\t\tswitch (entry->type) {\n\t\tcase GF_ISOM_BOX_TYPE_DVHE:\n\t\t\tentry->type = GF_ISOM_BOX_TYPE_HEV1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_DVH1:\n\t\t\tentry->type = GF_ISOM_BOX_TYPE_HVC1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_DVA1:\n\t\t\tentry->type = GF_ISOM_BOX_TYPE_AVC1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_DVAV:\n\t\t\tentry->type = GF_ISOM_BOX_TYPE_AVC3;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_DAV1:\n\t\t\tentry->type = GF_ISOM_BOX_TYPE_AV01;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\tif (!dovi) {\n\t\tdovi = (GF_DOVIConfigurationBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_DVCC);\n\t\tif (!dovi) return GF_OUT_OF_MEM;\n\t\tentry->dovi_config = dovi;\n\t}\n\tif (dvcc->dv_profile < 8) {\n\t\tdovi->type = GF_ISOM_BOX_TYPE_DVCC;\n\t} else {\n\t\tdovi->type = GF_ISOM_BOX_TYPE_DVVC;\n\t}\n\tdovi->DOVIConfig = *dvcc;\n\n\tif (dv_cfge) gf_isom_box_del_parent(&entry->child_boxes, dv_cfge);\n\tdv_cfge = NULL;\n\n\t//inject avcE / hvcE if enhancement layer and RPU present in single-track case\n\t//not clear from the spec what is supposed to be in these, we just clone avcC/hvcC\n\tif (dvcc->bl_present_flag && dvcc->el_present_flag && dvcc->rpu_present_flag) {\n\t\tGF_Box *src = is_avc ? (GF_Box *)entry->avc_config : (GF_Box *)entry->hevc_config;\n\t\tif (!src) return GF_BAD_PARAM;\n\t\te = gf_isom_clone_box(src, &dv_cfge);\n\t\tif (e) return e;\n\t\tdv_cfge->type = dve_type;\n\t\tgf_list_add(entry->child_boxes, dv_cfge);\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_high_dynamic_range_info(GF_ISOFile* movie, u32 trackNumber, u32 StreamDescriptionIndex, GF_MasteringDisplayColourVolumeInfo* mdcv, GF_ContentLightLevelInfo* clli)\n{\n\tGF_Err e;\n\tGF_TrackBox* trak;\n\tGF_SampleEntryBox* entry;\n\tGF_SampleDescriptionBox* stsd;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn movie->LastError = GF_BAD_PARAM;\n\t}\n\tentry = (GF_SampleEntryBox*)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return GF_BAD_PARAM;\n\n\tGF_MasteringDisplayColourVolumeBox *mdcvb = (GF_MasteringDisplayColourVolumeBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_MDCV);\n\tif (mdcv) {\n\t\tif (!mdcvb) {\n\t\t\tmdcvb = (GF_MasteringDisplayColourVolumeBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_MDCV);\n\t\t\tif (!mdcvb) return GF_OUT_OF_MEM;\n\t\t}\n\t\tmdcvb->mdcv = *mdcv;\n\t} else {\n\t\tif (mdcvb) gf_isom_box_del_parent(&entry->child_boxes, (GF_Box *) mdcvb);\n\t}\n\n\t/*clli*/\n\tGF_ContentLightLevelBox *cllib = (GF_ContentLightLevelBox *)gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_CLLI);\n\tif (clli) {\n\t\tif (!cllib) {\n\t\t\tcllib = (GF_ContentLightLevelBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_CLLI);\n\t\t\tif (!cllib) return GF_OUT_OF_MEM;\n\t\t}\n\t\tcllib->clli = *clli;\n\t} else {\n\t\tif (cllib) gf_isom_box_del_parent(&entry->child_boxes, (GF_Box *) cllib);\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_clean_aperture(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, u32 cleanApertureWidthN, u32 cleanApertureWidthD, u32 cleanApertureHeightN, u32 cleanApertureHeightD, s32 horizOffN, u32 horizOffD, s32 vertOffN, u32 vertOffD)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn movie->LastError = GF_BAD_PARAM;\n\t}\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return GF_BAD_PARAM;\n\n\tGF_CleanApertureBox *clap = (GF_CleanApertureBox *)gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_CLAP);\n\tif (!cleanApertureHeightD || !cleanApertureWidthD || !horizOffD || !vertOffD) {\n\t\tif (clap) gf_isom_box_del_parent(&entry->child_boxes, (GF_Box*)clap);\n\t\treturn GF_OK;\n\t}\n\tif (!clap) {\n\t\tclap = (GF_CleanApertureBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_CLAP);\n\t\tif (!clap) return GF_OUT_OF_MEM;\n\t}\n\n\tclap->cleanApertureWidthN = cleanApertureWidthN;\n\tclap->cleanApertureWidthD = cleanApertureWidthD;\n\tclap->cleanApertureHeightN = cleanApertureHeightN;\n\tclap->cleanApertureHeightD = cleanApertureHeightD;\n\tclap->horizOffN = horizOffN;\n\tclap->horizOffD = horizOffD;\n\tclap->vertOffN = vertOffN;\n\tclap->vertOffD = vertOffD;\n\treturn GF_OK;\n}\n\n#include <gpac/maths.h>\nGF_Err gf_isom_update_aperture_info(GF_ISOFile *movie, u32 trackNumber, Bool remove)\n{\n\tGF_Err e;\n\tGF_Box *box, *enof, *prof, *clef;\n\tGF_TrackBox *trak;\n\tGF_VisualSampleEntryBox *ventry;\n\tGF_PixelAspectRatioBox *pasp;\n\tGF_CleanApertureBox *clap;\n\tu32 j, hspacing, vspacing, clap_width_num, clap_width_den, clap_height_num, clap_height_den, high, low;\n\tDouble width, height;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tif (remove) {\n\t\tif (trak->Aperture) {\n\t\t\tgf_isom_box_del(trak->Aperture);\n\t\t\ttrak->Aperture = NULL;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\tenof = prof = clef = NULL;\n\tif (!trak->Aperture) {\n\t\ttrak->Aperture = gf_isom_box_new_parent(&trak->child_boxes, GF_QT_BOX_TYPE_TAPT);\n\t\tif (!trak->Aperture) return GF_OUT_OF_MEM;\n\t}\n\tif (!trak->Aperture->child_boxes) {\n\t\ttrak->Aperture->child_boxes = gf_list_new();\n\t\tif (!trak->Aperture->child_boxes)\n\t\t\treturn GF_OUT_OF_MEM;\n\t}\n\n\tj=0;\n\twhile ( (box = gf_list_enum(trak->Aperture->child_boxes, &j))) {\n\t\tswitch (box->type) {\n\t\tcase GF_QT_BOX_TYPE_CLEF: clef = box; break;\n\t\tcase GF_QT_BOX_TYPE_PROF: prof = box; break;\n\t\tcase GF_QT_BOX_TYPE_ENOF: enof = box; break;\n\t\t}\n\t}\n\tif (!clef) {\n\t\tclef = gf_isom_box_new(GF_QT_BOX_TYPE_CLEF);\n\t\tif (!clef) return GF_OUT_OF_MEM;\n\t\tgf_list_add(trak->Aperture->child_boxes, clef);\n\t}\n\tif (!enof) {\n\t\tenof = gf_isom_box_new(GF_QT_BOX_TYPE_ENOF);\n\t\tif (!enof) return GF_OUT_OF_MEM;\n\t\tgf_list_add(trak->Aperture->child_boxes, enof);\n\t}\n\tif (!prof) {\n\t\tprof = gf_isom_box_new(GF_QT_BOX_TYPE_PROF);\n\t\tif (!prof) return GF_OUT_OF_MEM;\n\t\tgf_list_add(trak->Aperture->child_boxes, prof);\n\t}\n\n\tventry = (GF_VisualSampleEntryBox *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, 0);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (ventry == NULL) return GF_BAD_PARAM;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tif (ventry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return GF_BAD_PARAM;\n\n\tpasp = (GF_PixelAspectRatioBox *) gf_isom_box_find_child(ventry->child_boxes, GF_ISOM_BOX_TYPE_PASP);\n\thspacing = vspacing = 0;\n\tif (pasp) {\n\t\thspacing = pasp->hSpacing;\n\t\tvspacing = pasp->vSpacing;\n\t}\n\tclap_width_num = ventry->Width;\n\tclap_width_den = 1;\n\tclap_height_num = ventry->Height;\n\tclap_height_den = 1;\n\tclap = (GF_CleanApertureBox *) gf_isom_box_find_child(ventry->child_boxes, GF_ISOM_BOX_TYPE_CLAP);\n\tif (clap) {\n\t\tclap_width_num = clap->cleanApertureWidthN;\n\t\tclap_width_den = clap->cleanApertureWidthD;\n\t\tclap_height_num = clap->cleanApertureHeightN;\n\t\tclap_height_den = clap->cleanApertureHeightD;\n\t}\n\t//enof: encoded pixels in 16.16\n\t((GF_ApertureBox *)enof)->width = (ventry->Width)<<16;\n\t((GF_ApertureBox *)enof)->height = (ventry->Height)<<16;\n\n\t//prof: encoded pixels + pasp in 16.16\n\twidth = (Float) (ventry->Width * hspacing);\n\twidth /= vspacing;\n\thigh = (u32) floor((Float)width);\n\tlow = (u32) ( 0xFFFF * (width - (Double)high) );\n\t((GF_ApertureBox *)prof)->width = (high)<<16 | low;\n\t((GF_ApertureBox *)prof)->height = (ventry->Height)<<16;\n\n\t//clef: encoded pixels + pasp + clap in 16.16\n\twidth = (Double) (clap_width_num * hspacing);\n\twidth /= clap_width_den * vspacing;\n\theight = (Float) clap_height_num;\n\theight /= clap_height_den;\n\n\thigh = (u32) floor((Float)width);\n\tlow = (u32) (0xFFFF * (width - (Double)high));\n\t((GF_ApertureBox *)clef)->width = (high)<<16 | low;\n\thigh = (u32) floor((Float)height);\n\tlow = (u32) (0xFFFF * (height - (Double)high));\n\t((GF_ApertureBox *)clef)->height = (high)<<16 | low;\n\n\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_image_sequence_coding_constraints(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, Bool remove, Bool all_ref_pics_intra, Bool intra_pred_used, u32 max_ref_per_pic)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn movie->LastError = GF_BAD_PARAM;\n\t}\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return GF_BAD_PARAM;\n\n\tGF_CodingConstraintsBox*ccst = (GF_CodingConstraintsBox*) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_CCST);\n\tif (remove)  {\n\t\tif (ccst) gf_isom_box_del_parent(&entry->child_boxes, (GF_Box*)ccst);\n\t\treturn GF_OK;\n\t}\n\tif (!ccst) {\n\t\tccst = (GF_CodingConstraintsBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_CCST);\n\t\tif (!ccst) return GF_OUT_OF_MEM;\n\t}\n\tccst->all_ref_pics_intra = all_ref_pics_intra;\n\tccst->intra_pred_used = intra_pred_used;\n\tccst->max_ref_per_pic = max_ref_per_pic;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_image_sequence_alpha(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, Bool remove)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn movie->LastError = GF_BAD_PARAM;\n\t}\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return GF_BAD_PARAM;\n\n\tGF_AuxiliaryTypeInfoBox *auxi = (GF_AuxiliaryTypeInfoBox *)gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_AUXI);\n\tif (remove)  {\n\t\tif (auxi) gf_isom_box_del_parent(&entry->child_boxes, (GF_Box*)auxi);\n\t\treturn GF_OK;\n\t}\n\tif (!auxi) {\n\t\tauxi = (GF_AuxiliaryTypeInfoBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_AUXI);\n\t\tif (!auxi) return GF_OUT_OF_MEM;\n\t}\n\tauxi->aux_track_type = gf_strdup(\"urn:mpeg:mpegB:cicp:systems:auxiliary:alpha\");\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_audio_info(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, u32 sampleRate, u32 nbChannels, u8 bitsPerSample, GF_AudioSampleEntryImportMode asemode)\n{\n\tGF_Err e;\n\tu32 i, old_qtff_mode=GF_ISOM_AUDIO_QTFF_NONE;\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_AudioSampleEntryBox*aud_entry;\n\tGF_SampleDescriptionBox *stsd;\n\tGF_Box *wave_box = NULL;\n\tGF_Box *gf_isom_audio_sample_get_audio_codec_cfg_box(GF_AudioSampleEntryBox *ptr);\n\tGF_Box *codec_ext = NULL;\n#if 0\n\tGF_ChannelLayoutInfoBox *chan=NULL;\n#endif\n\tGF_OriginalFormatBox *frma=NULL;\n\tGF_ChromaInfoBox *enda=NULL;\n\tGF_ESDBox *esds=NULL;\n\tGF_Box *terminator=NULL;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) {\n\t\treturn movie->LastError = GF_ISOM_INVALID_FILE;\n\t}\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn movie->LastError = GF_BAD_PARAM;\n\t}\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_AUDIO) return GF_BAD_PARAM;\n\taud_entry = (GF_AudioSampleEntryBox*) entry;\n\n\tif (entry->type==GF_ISOM_BOX_TYPE_MLPA) {\n\t\taud_entry->samplerate_hi = sampleRate>>16;\n\t\taud_entry->samplerate_lo = sampleRate & 0x0000FFFF;\n\t} else {\n\t\taud_entry->samplerate_hi = sampleRate;\n\t\taud_entry->samplerate_lo = 0;\n\t}\n\taud_entry->bitspersample = bitsPerSample;\n\n\tswitch (asemode) {\n\tcase GF_IMPORT_AUDIO_SAMPLE_ENTRY_v0_2:\n\t\tstsd->version = 0;\n\t\taud_entry->version = 0;\n\t\taud_entry->qtff_mode = GF_ISOM_AUDIO_QTFF_NONE;\n\t\taud_entry->channel_count = 2;\n\t\tbreak;\n\tcase GF_IMPORT_AUDIO_SAMPLE_ENTRY_NOT_SET:\n\tcase GF_IMPORT_AUDIO_SAMPLE_ENTRY_v0_BS:\n\t\tstsd->version = 0;\n\t\taud_entry->version = 0;\n\t\taud_entry->qtff_mode = GF_ISOM_AUDIO_QTFF_NONE;\n\t\taud_entry->channel_count = nbChannels;\n\t\tbreak;\n\tcase GF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_MPEG:\n\t\tstsd->version = 1;\n\t\taud_entry->version = 1;\n\t\taud_entry->qtff_mode = GF_ISOM_AUDIO_QTFF_NONE;\n\t\taud_entry->channel_count = nbChannels;\n\t\tbreak;\n\tcase GF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_QTFF:\n\t\tstsd->version = 0;\n\t\t//don't change if already v2\n\t\tif ((aud_entry->version==2) && aud_entry->qtff_mode) {\n\t\t\tbreak;\n\t\t}\n\t\taud_entry->version = 1;\n\t\taud_entry->channel_count = nbChannels;\n\t\told_qtff_mode = aud_entry->qtff_mode;\n\t\tif (aud_entry->qtff_mode != GF_ISOM_AUDIO_QTFF_ON_EXT_VALID)\n\t\t\taud_entry->qtff_mode = GF_ISOM_AUDIO_QTFF_ON_NOEXT;\n\t\tbreak;\n\t}\n\n\taud_entry->compression_id = 0;\n\n\t//check for wave+children and chan for QTFF or remove them for isobmff\n\tfor (i=0; i<gf_list_count(aud_entry->child_boxes); i++) {\n\t\tGF_Box *b = gf_list_get(aud_entry->child_boxes, i);\n\t\tif ((b->type != GF_QT_BOX_TYPE_WAVE) && (b->type != GF_QT_BOX_TYPE_CHAN) ) continue;\n\t\tif (asemode==GF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_QTFF) {\n\t\t\tif (b->type == GF_QT_BOX_TYPE_WAVE) wave_box = b;\n#if 0\n\t\t\telse chan = (GF_ChannelLayoutInfoBox *)b;\n#endif\n\n\t\t} else {\n\t\t\tgf_isom_box_del_parent(&aud_entry->child_boxes, b);\n\t\t\ti--;\n\t\t}\n\t}\n\n\t//TODO: insert channelLayout for ISOBMFF\n\tif (asemode!=GF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_QTFF) return GF_OK;\n\n\tif (aud_entry->type==GF_ISOM_BOX_TYPE_MP4A)\n\t\taud_entry->compression_id = -2;\n\n\tif (!aud_entry->child_boxes) aud_entry->child_boxes = gf_list_new();\n\n#if 0\n\tif (!chan) {\n\t\tchan = (GF_ChannelLayoutInfoBox *) gf_isom_box_new_parent(&aud_entry->child_boxes, GF_QT_BOX_TYPE_CHAN);\n\t}\n\t//TODO, proper channel mapping\n\tchan->layout_tag = (nbChannels==2) ? 6750210 : 6553601;\n#endif\n\n\tcodec_ext = gf_isom_audio_sample_get_audio_codec_cfg_box((GF_AudioSampleEntryBox *)aud_entry);\n\tif (!codec_ext) return GF_OK;\n\n\tif (!wave_box) {\n\t\twave_box = gf_isom_box_new_parent(&aud_entry->child_boxes, GF_QT_BOX_TYPE_WAVE);\n\t}\n\n\tfor (i=0; i<gf_list_count(wave_box->child_boxes); i++) {\n\t\tGF_Box *b = gf_list_get(wave_box->child_boxes, i);\n\t\tswitch (b->type) {\n\t\tcase GF_QT_BOX_TYPE_ENDA:\n\t\t\tenda = (GF_ChromaInfoBox *)b;\n\t\t\tbreak;\n\t\tcase GF_QT_BOX_TYPE_FRMA:\n\t\t\tfrma = (GF_OriginalFormatBox *)b;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_ESDS:\n\t\t\tesds = (GF_ESDBox *)b;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_UNKNOWN:\n\t\t\tif ( ((GF_UnknownBox*)b)->original_4cc == 0)\n\t\t\t\tterminator = b;\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tterminator = b;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!wave_box->child_boxes) wave_box->child_boxes = gf_list_new();\n\n\t//do not use new_parent, we do this manually to ensure the order\n\taud_entry->qtff_mode = old_qtff_mode ? old_qtff_mode : GF_ISOM_AUDIO_QTFF_ON_NOEXT;\n\tif (!frma) {\n\t\tfrma = (GF_OriginalFormatBox *)gf_isom_box_new(GF_QT_BOX_TYPE_FRMA);\n\t} else {\n\t\tgf_list_del_item(wave_box->child_boxes, frma);\n\t}\n\tgf_list_add(wave_box->child_boxes, frma);\n\n\tif (esds) gf_list_del_item(wave_box->child_boxes, esds);\n\tif (!esds && (aud_entry->type==GF_ISOM_BOX_TYPE_MP4A) && ((GF_MPEGAudioSampleEntryBox*)aud_entry)->esd) {\n\t\tgf_list_del_item(entry->child_boxes, (GF_Box *) ((GF_MPEGAudioSampleEntryBox*)aud_entry)->esd);\n\t\tgf_list_add(wave_box->child_boxes, (GF_Box *) ((GF_MPEGAudioSampleEntryBox*)aud_entry)->esd);\n\t}\n\n\tif (!enda) {\n\t\tenda = (GF_ChromaInfoBox *)gf_isom_box_new(GF_QT_BOX_TYPE_ENDA);\n\t} else {\n\t\tgf_list_del_item(wave_box->child_boxes, enda);\n\t}\n\tenda->chroma=1;\n\tgf_list_add(wave_box->child_boxes, enda);\n\n\tif (!terminator) {\n\t\tterminator = gf_isom_box_new(0);\n\t} else {\n\t\tgf_list_del_item(wave_box->child_boxes, terminator);\n\t}\n\tgf_list_add(wave_box->child_boxes, terminator);\n\n\tif (aud_entry->type==GF_ISOM_BOX_TYPE_GNRA) {\n\t\tfrma->data_format = ((GF_GenericAudioSampleEntryBox*) aud_entry)->EntryType;\n\t} else {\n\t\tfrma->data_format = aud_entry->type;\n\t}\n\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_audio_layout(GF_ISOFile *movie, u32 trackNumber, u32 sampleDescriptionIndex, GF_AudioChannelLayout *layout)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_AudioSampleEntryBox*aud_entry;\n\tGF_SampleDescriptionBox *stsd;\n\tGF_ChannelLayoutBox *chnl;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tif (!layout) return GF_BAD_PARAM;\n\tif ((layout->stream_structure & 1) && (layout->definedLayout==0) && (layout->channels_count>=64))\n\t\treturn GF_BAD_PARAM;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) {\n\t\treturn movie->LastError = GF_ISOM_INVALID_FILE;\n\t}\n\tif (!sampleDescriptionIndex || sampleDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn movie->LastError = GF_BAD_PARAM;\n\t}\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, sampleDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_AUDIO) return GF_BAD_PARAM;\n\taud_entry = (GF_AudioSampleEntryBox*) entry;\n\tif (aud_entry->qtff_mode) {\n\t\tu32 sr = aud_entry->samplerate_hi;\n\t\tif (aud_entry->type==GF_ISOM_BOX_TYPE_MLPA) {\n\t\t\tsr <<= 16;\n\t\t\tsr |= aud_entry->samplerate_lo;\n\t\t}\n\t\te = gf_isom_set_audio_info(movie, trackNumber, sampleDescriptionIndex, sr, aud_entry->channel_count, (u8) aud_entry->bitspersample, GF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_MPEG);\n\t\tif (e) return e;\n\t}\n\tchnl = (GF_ChannelLayoutBox *) gf_isom_box_find_child(aud_entry->child_boxes, GF_ISOM_BOX_TYPE_CHNL);\n\tif (!chnl) {\n\t\tchnl = (GF_ChannelLayoutBox *)gf_isom_box_new_parent(&aud_entry->child_boxes, GF_ISOM_BOX_TYPE_CHNL);\n\t\tif (!chnl) return GF_OUT_OF_MEM;\n\t}\n\taud_entry->channel_count = layout->channels_count;\n\tmemcpy(&chnl->layout, layout, sizeof(GF_AudioChannelLayout));\n\treturn GF_OK;\n}\n\n//set the storage mode of a file (FLAT, STREAMABLE, INTERLEAVED)\nGF_EXPORT\nGF_Err gf_isom_set_storage_mode(GF_ISOFile *movie, GF_ISOStorageMode storageMode)\n{\n\tGF_Err e;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tswitch (storageMode) {\n\tcase GF_ISOM_STORE_FLAT:\n\tcase GF_ISOM_STORE_STREAMABLE:\n\tcase GF_ISOM_STORE_INTERLEAVED:\n\tcase GF_ISOM_STORE_DRIFT_INTERLEAVED:\n\tcase GF_ISOM_STORE_TIGHT:\n\tcase GF_ISOM_STORE_FASTSTART:\n\t\tmovie->storageMode = storageMode;\n\t\t//specifying a storage mode disables inplace rewrite\n\t\tgf_isom_disable_inplace_rewrite(movie);\n\t\treturn GF_OK;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_enable_compression(GF_ISOFile *file, GF_ISOCompressMode compress_mode, u32 compress_flags)\n{\n\tif (!file) return GF_BAD_PARAM;\n\tfile->compress_mode = compress_mode;\n\tfile->compress_flags = compress_flags;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_force_64bit_chunk_offset(GF_ISOFile *file, Bool set_on)\n{\n\tif (!file) return GF_BAD_PARAM;\n\tfile->force_co64 = set_on;\n\treturn GF_OK;\n}\n\n\n//update or insert a new edit segment in the track time line. Edits are used to modify\n//the media normal timing. EditTime and EditDuration are expressed in Movie TimeScale\n//If a segment with EditTime already exists, IT IS ERASED\nstatic GF_Err gf_isom_set_edit_internal(GF_ISOFile *movie, u32 trackNumber, u64 EditTime, u64 EditDuration, u64 MediaTime, u32 media_rate, GF_ISOEditType EditMode)\n{\n\tGF_TrackBox *trak;\n\tGF_EditBox *edts;\n\tGF_EditListBox *elst;\n\tGF_EdtsEntry *ent, *newEnt;\n\tu32 i;\n\tGF_Err e;\n\tu64 startTime;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tedts = trak->editBox;\n\tif (! edts) {\n\t\tedts = (GF_EditBox *) gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_EDTS);\n\t\tif (!edts) return GF_OUT_OF_MEM;\n\t\ttrak_on_child_box((GF_Box*)trak, (GF_Box *)edts, GF_FALSE);\n\t}\n\telst = edts->editList;\n\tif (!elst) {\n\t\telst = (GF_EditListBox *) gf_isom_box_new_parent(&edts->child_boxes, GF_ISOM_BOX_TYPE_ELST);\n\t\tif (!elst) return GF_OUT_OF_MEM;\n\t\tedts_on_child_box((GF_Box*)edts, (GF_Box *)elst, GF_FALSE);\n\t}\n\n\tstartTime = 0;\n\tent = NULL;\n\t//get the prev entry to this startTime if any\n\ti=0;\n\twhile ((ent = (GF_EdtsEntry *)gf_list_enum(elst->entryList, &i))) {\n\t\tif ( (startTime <= EditTime) && (startTime + ent->segmentDuration > EditTime) )\n\t\t\tgoto found;\n\t\tstartTime += ent->segmentDuration;\n\t}\n\n\t//not found, add a new entry, insert empty one if gap\n\tif (!ent) {\n\t\tBool empty_inserted = GF_FALSE;\n\t\tif (startTime != EditTime) {\n\t\t\tnewEnt = CreateEditEntry(EditTime - startTime, 0, 0, GF_ISOM_EDIT_EMPTY);\n\t\t\tif (!newEnt) return GF_OUT_OF_MEM;\n\t\t\tempty_inserted = GF_TRUE;\n\t\t\tgf_list_add(elst->entryList, newEnt);\n\t\t}\n\t\tnewEnt = CreateEditEntry(EditDuration, MediaTime, media_rate, EditMode);\n\t\tif (!newEnt) return GF_OUT_OF_MEM;\n\t\tgf_list_add(elst->entryList, newEnt);\n\t\te = SetTrackDuration(trak);\n\t\tif (e) return e;\n\t\treturn empty_inserted ? GF_EOS : GF_OK;\n\t}\n\n\tstartTime -= ent->segmentDuration;\n\nfound:\n\n\t//if same time, we erase the current one...\n\tif (startTime == EditTime) {\n\t\tent->segmentDuration = EditDuration;\n\t\tswitch (EditMode) {\n\t\tcase GF_ISOM_EDIT_EMPTY:\n\t\t\tent->mediaRate = 0x10000;\n\t\t\tent->mediaTime = -1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_EDIT_DWELL:\n\t\t\tent->mediaRate = 0;\n\t\t\tent->mediaTime = MediaTime;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tent->mediaRate = media_rate;\n\t\t\tent->mediaTime = MediaTime;\n\t\t\tbreak;\n\t\t}\n\t\treturn SetTrackDuration(trak);\n\t}\n\n\t//adjust so that the prev ent leads to EntryTime\n\t//Note: we don't change the next one as it is unknown to us in\n\t//a lot of case (the author's changes)\n\tent->segmentDuration = EditTime - startTime;\n\tnewEnt = CreateEditEntry(EditDuration, MediaTime, media_rate, EditMode);\n\tif (!newEnt) return GF_OUT_OF_MEM;\n\t//is it the last entry ???\n\tif (i >= gf_list_count(elst->entryList) - 1) {\n\t\t//add the new entry at the end\n\t\tgf_list_add(elst->entryList, newEnt);\n\t\treturn SetTrackDuration(trak);\n\t} else {\n\t\t//insert after the current entry (which is i)\n\t\tgf_list_insert(elst->entryList, newEnt, i+1);\n\t\treturn SetTrackDuration(trak);\n\t}\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_edit(GF_ISOFile *movie, u32 trackNumber, u64 EditTime, u64 EditDuration, u64 MediaTime, GF_ISOEditType EditMode)\n{\n\treturn gf_isom_set_edit_internal(movie, trackNumber, EditTime, EditDuration, MediaTime, 0x10000, EditMode);\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_edit_with_rate(GF_ISOFile *movie, u32 trackNumber, u64 EditTime, u64 EditDuration, u64 MediaTime, u32 media_rate)\n{\n\treturn gf_isom_set_edit_internal(movie, trackNumber, EditTime, EditDuration, MediaTime, media_rate, GF_ISOM_EDIT_NORMAL);\n\n}\n\n//remove the edit segments for the whole track\nGF_EXPORT\nGF_Err gf_isom_remove_edits(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tif (!trak->editBox || !trak->editBox->editList) return GF_OK;\n\n\twhile (gf_list_count(trak->editBox->editList->entryList)) {\n\t\tGF_EdtsEntry *ent = (GF_EdtsEntry*)gf_list_get(trak->editBox->editList->entryList, 0);\n\t\tgf_free(ent);\n\t\te = gf_list_rem(trak->editBox->editList->entryList, 0);\n\t\tif (e) return e;\n\t}\n\t//then delete the GF_EditBox...\n\tgf_isom_box_del_parent(&trak->child_boxes, (GF_Box *)trak->editBox);\n\ttrak->editBox = NULL;\n\treturn SetTrackDuration(trak);\n}\n\n\n//remove the edit segments for the whole track\nGF_EXPORT\nGF_Err gf_isom_remove_edit(GF_ISOFile *movie, u32 trackNumber, u32 seg_index)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_EdtsEntry *ent, *next_ent;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !seg_index) return GF_BAD_PARAM;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tif (!trak->editBox || !trak->editBox->editList) return GF_OK;\n\tif (gf_list_count(trak->editBox->editList->entryList)<=1) return gf_isom_remove_edits(movie, trackNumber);\n\n\tent = (GF_EdtsEntry*) gf_list_get(trak->editBox->editList->entryList, seg_index-1);\n\tgf_list_rem(trak->editBox->editList->entryList, seg_index-1);\n\tnext_ent = (GF_EdtsEntry *)gf_list_get(trak->editBox->editList->entryList, seg_index-1);\n\tif (next_ent) next_ent->segmentDuration += ent->segmentDuration;\n\tgf_free(ent);\n\treturn SetTrackDuration(trak);\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_append_edit(GF_ISOFile *movie, u32 trackNumber, u64 EditDuration, u64 MediaTime, GF_ISOEditType EditMode)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_EdtsEntry *ent;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tif (!trak->editBox) {\n\t\tGF_EditBox *edts = (GF_EditBox *) gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_EDTS);\n\t\tif (!edts) return GF_OUT_OF_MEM;\n\t\ttrak_on_child_box((GF_Box*)trak, (GF_Box *)edts, GF_FALSE);\n\t\tassert(trak->editBox);\n\t}\n\tif (!trak->editBox->editList) {\n\t\tGF_EditListBox *elst = (GF_EditListBox *) gf_isom_box_new_parent(&trak->editBox->child_boxes, GF_ISOM_BOX_TYPE_ELST);\n\t\tif (!elst) return GF_OUT_OF_MEM;\n\t\tedts_on_child_box((GF_Box*)trak->editBox, (GF_Box *)elst, GF_FALSE);\n\t\tassert(trak->editBox->editList);\n\t}\n\tent = (GF_EdtsEntry *)gf_malloc(sizeof(GF_EdtsEntry));\n\tif (!ent) return GF_OUT_OF_MEM;\n\n\tent->segmentDuration = EditDuration;\n\tswitch (EditMode) {\n\tcase GF_ISOM_EDIT_EMPTY:\n\t\tent->mediaRate = 0x10000;\n\t\tent->mediaTime = -1;\n\t\tbreak;\n\tcase GF_ISOM_EDIT_DWELL:\n\t\tent->mediaRate = 0;\n\t\tent->mediaTime = MediaTime;\n\t\tbreak;\n\tdefault:\n\t\tent->mediaRate = 0x10000;\n\t\tent->mediaTime = MediaTime;\n\t\tbreak;\n\t}\n\tgf_list_add(trak->editBox->editList->entryList, ent);\n\treturn SetTrackDuration(trak);\n}\n\nGF_EXPORT\nGF_Err gf_isom_modify_edit(GF_ISOFile *movie, u32 trackNumber, u32 seg_index, u64 EditDuration, u64 MediaTime, GF_ISOEditType EditMode)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_EdtsEntry *ent;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !seg_index) return GF_BAD_PARAM;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tif (!trak->editBox || !trak->editBox->editList) return GF_OK;\n\tif (gf_list_count(trak->editBox->editList->entryList)<seg_index) return GF_BAD_PARAM;\n\tent = (GF_EdtsEntry*) gf_list_get(trak->editBox->editList->entryList, seg_index-1);\n\n\tent->segmentDuration = EditDuration;\n\tswitch (EditMode) {\n\tcase GF_ISOM_EDIT_EMPTY:\n\t\tent->mediaRate = 0x10000;\n\t\tent->mediaTime = -1;\n\t\tbreak;\n\tcase GF_ISOM_EDIT_DWELL:\n\t\tent->mediaRate = 0;\n\t\tent->mediaTime = MediaTime;\n\t\tbreak;\n\tdefault:\n\t\tent->mediaRate = 0x10000;\n\t\tent->mediaTime = MediaTime;\n\t\tbreak;\n\t}\n\treturn SetTrackDuration(trak);\n}\n\nstatic void update_next_track_id(GF_ISOFile *movie)\n{\n\tGF_TrackBox *trak;\n\t/*update next track ID*/\n\tmovie->moov->mvhd->nextTrackID = 0;\n\tu32 i=0;\n\twhile ((trak = (GF_TrackBox *)gf_list_enum(movie->moov->trackList, &i))) {\n\t\tif (trak->Header->trackID>movie->moov->mvhd->nextTrackID)\n\t\t\tmovie->moov->mvhd->nextTrackID = trak->Header->trackID;\n\t}\n\t//shall be larger than the largest track_ID in use\n\tmovie->moov->mvhd->nextTrackID++;\n}\n\n//removes the desired track\nGF_EXPORT\nGF_Err gf_isom_remove_track(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_Err e;\n\tGF_TrackBox *the_trak, *trak;\n\tGF_TrackReferenceTypeBox *tref;\n\tu32 i, j, k, descIndex;\n\tGF_ISOTrackID *newRefs;\n\tu8 found;\n\tGF_ISOSample *samp;\n\tthe_trak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!the_trak) return GF_BAD_PARAM;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tif (movie->moov->iods && movie->moov->iods->descriptor) {\n\t\tGF_Descriptor *desc;\n\t\tGF_ES_ID_Inc *inc;\n\t\tGF_List *ESDs;\n\t\tdesc = movie->moov->iods->descriptor;\n\t\tif (desc->tag == GF_ODF_ISOM_IOD_TAG) {\n\t\t\tESDs = ((GF_IsomInitialObjectDescriptor *)desc)->ES_ID_IncDescriptors;\n\t\t} else if (desc->tag == GF_ODF_ISOM_OD_TAG) {\n\t\t\tESDs = ((GF_IsomObjectDescriptor *)desc)->ES_ID_IncDescriptors;\n\t\t} else {\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\n\t\t//remove the track ref from the root OD if any\n\t\ti=0;\n\t\twhile ((inc = (GF_ES_ID_Inc *)gf_list_enum(ESDs, &i))) {\n\t\t\tif (inc->trackID == the_trak->Header->trackID) {\n\t\t\t\tgf_odf_desc_del((GF_Descriptor *)inc);\n\t\t\t\ti--;\n\t\t\t\tgf_list_rem(ESDs, i);\n\t\t\t}\n\t\t}\n\t}\n\n\t//remove the track from the movie\n\tgf_list_del_item(movie->moov->trackList, the_trak);\n\n\t//rewrite any OD tracks\n\ti=0;\n\twhile ((trak = (GF_TrackBox *)gf_list_enum(movie->moov->trackList, &i))) {\n\t\tif (trak->Media->handler->handlerType != GF_ISOM_MEDIA_OD) continue;\n\n\t\t//this is an OD track...\n\t\tj = gf_isom_get_sample_count(movie, i);\n\t\tfor (k=0; k < j; k++) {\n\t\t\t//getting the sample will remove the references to the deleted track in the output OD frame\n\t\t\tsamp = gf_isom_get_sample(movie, i, k+1, &descIndex);\n\t\t\tif (!samp) break;\n\t\t\t//so let's update with the new OD frame ! If the sample is empty, remove it\n\t\t\tif (!samp->dataLength) {\n\t\t\t\te = gf_isom_remove_sample(movie, i, k+1);\n\t\t\t\tif (e) return e;\n\t\t\t} else {\n\t\t\t\te = gf_isom_update_sample(movie, i, k+1, samp, GF_TRUE);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\t\t\t//and don't forget to delete the sample\n\t\t\tgf_isom_sample_del(&samp);\n\t\t}\n\t}\n\n\t//remove the track ref from any \"tref\" box in all tracks, except the one to delete\n\t//note that we don't touch scal references, as we don't want to rewrite AVC/HEVC samples ...\n\ti=0;\n\twhile ((trak = (GF_TrackBox *)gf_list_enum(movie->moov->trackList, &i))) {\n\t\tif (! trak->References || ! gf_list_count(trak->References->child_boxes)) continue;\n\n\t\tj=0;\n\t\twhile ((tref = (GF_TrackReferenceTypeBox *)gf_list_enum(trak->References->child_boxes, &j))) {\n\t\t\tif (tref->reference_type==GF_ISOM_REF_SCAL)\n\t\t\t\tcontinue;\n\n\t\t\tfound = 0;\n\t\t\tfor (k=0; k<tref->trackIDCount; k++) {\n\t\t\t\tif (tref->trackIDs[k] == the_trak->Header->trackID) found++;\n\t\t\t}\n\t\t\tif (!found) continue;\n\t\t\t//no more refs, remove this ref_type\n\t\t\tif (found == tref->trackIDCount) {\n\t\t\t\tgf_isom_box_del_parent(&trak->References->child_boxes, (GF_Box *)tref);\n\t\t\t\tj--;\n\t\t\t} else {\n\t\t\t\tnewRefs = (GF_ISOTrackID*)gf_malloc(sizeof(GF_ISOTrackID) * (tref->trackIDCount - found));\n\t\t\t\tif (!newRefs) return GF_OUT_OF_MEM;\n\t\t\t\tfound = 0;\n\t\t\t\tfor (k = 0; k < tref->trackIDCount; k++) {\n\t\t\t\t\tif (tref->trackIDs[k] != the_trak->Header->trackID) {\n\t\t\t\t\t\tnewRefs[k-found] = tref->trackIDs[k];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfound++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgf_free(tref->trackIDs);\n\t\t\t\ttref->trackIDs = newRefs;\n\t\t\t\ttref->trackIDCount -= found;\n\t\t\t}\n\t\t}\n\t\t//a little opt: remove the ref box if empty...\n\t\tif (! gf_list_count(trak->References->child_boxes)) {\n\t\t\tgf_isom_box_del_parent(&trak->child_boxes, (GF_Box *)trak->References);\n\t\t\ttrak->References = NULL;\n\t\t}\n\t}\n\n\tgf_isom_disable_inplace_rewrite(movie);\n\n\tgf_isom_meta_track_remove(movie, the_trak, 0);\n\n\t//delete the track\n\tgf_isom_box_del_parent(&movie->moov->child_boxes, (GF_Box *)the_trak);\n\n\t/*update next track ID*/\n\tupdate_next_track_id(movie);\n\n\tif (!gf_list_count(movie->moov->trackList)) {\n\t\tgf_list_del_item(movie->TopBoxes, movie->moov);\n\t\tgf_isom_box_del((GF_Box *)movie->moov);\n\t\tmovie->moov = NULL;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_set_copyright(GF_ISOFile *movie, const char *threeCharCode, char *notice)\n{\n\tGF_Err e;\n\tGF_CopyrightBox *ptr;\n\tGF_UserDataMap *map;\n\tu32 count, i;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tif (!notice || !threeCharCode) return GF_BAD_PARAM;\n\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\n\tif (!movie->moov->udta) {\n\t\te = moov_on_child_box((GF_Box*)movie->moov, gf_isom_box_new_parent(&movie->moov->child_boxes, GF_ISOM_BOX_TYPE_UDTA), GF_FALSE);\n\t\tif (e) return e;\n\t}\n\tmap = udta_getEntry(movie->moov->udta, GF_ISOM_BOX_TYPE_CPRT, NULL);\n\n\tif (map) {\n\t\t//try to find one in our language...\n\t\tcount = gf_list_count(map->boxes);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tptr = (GF_CopyrightBox*)gf_list_get(map->boxes, i);\n\t\t\tif (!strcmp(threeCharCode, (const char *) ptr->packedLanguageCode)) {\n\t\t\t\tgf_free(ptr->notice);\n\t\t\t\tptr->notice = (char*)gf_malloc(sizeof(char) * (strlen(notice) + 1));\n\t\t\t\tif (!ptr->notice) return GF_OUT_OF_MEM;\n\t\t\t\tstrcpy(ptr->notice, notice);\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t}\n\t}\n\t//nope, create one\n\tptr = (GF_CopyrightBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_CPRT);\n\tif (!ptr) return GF_OUT_OF_MEM;\n\n\tmemcpy(ptr->packedLanguageCode, threeCharCode, 4);\n\tptr->notice = (char*)gf_malloc(sizeof(char) * (strlen(notice)+1));\n\tif (!ptr->notice) return GF_OUT_OF_MEM;\n\tstrcpy(ptr->notice, notice);\n\treturn udta_on_child_box((GF_Box *)movie->moov->udta, (GF_Box *) ptr, GF_FALSE);\n}\n\nGF_EXPORT\nGF_Err gf_isom_add_track_kind(GF_ISOFile *movie, u32 trackNumber, const char *schemeURI, const char *value)\n{\n\tGF_Err e;\n\tGF_KindBox *ptr;\n\tGF_UserDataBox *udta;\n\tGF_UserDataMap *map;\n\tu32 i, count;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\n\tif (trackNumber) {\n\t\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\tif (!trak->udta) {\n\t\t\te = trak_on_child_box((GF_Box*)trak, gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_UDTA), GF_FALSE);\n\t\t\tif (e) return e;\n\t\t}\n\t\tudta = trak->udta;\n\t} else {\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tmap = udta_getEntry(udta, GF_ISOM_BOX_TYPE_KIND, NULL);\n\tif (map) {\n\t\tcount = gf_list_count(map->boxes);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_Box *b = (GF_Box *)gf_list_get(map->boxes, i);\n\t\t\tif (b->type == GF_ISOM_BOX_TYPE_KIND) {\n\t\t\t\tGF_KindBox *kb = (GF_KindBox *)b;\n\t\t\t\tif (!strcmp(kb->schemeURI, schemeURI) &&\n\t\t\t\t        ((value && kb->value && !strcmp(value, kb->value)) || (!value && !kb->value))) {\n\t\t\t\t\t// Already there\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tptr = (GF_KindBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_KIND);\n\tif (e) return e;\n\n\tptr->schemeURI = gf_strdup(schemeURI);\n\tif (value) ptr->value = gf_strdup(value);\n\treturn udta_on_child_box((GF_Box *)udta, (GF_Box *) ptr, GF_FALSE);\n}\n\nGF_EXPORT\nGF_Err gf_isom_remove_track_kind(GF_ISOFile *movie, u32 trackNumber, const char *schemeURI, const char *value)\n{\n\tGF_Err e;\n\tGF_UserDataBox *udta;\n\tGF_UserDataMap *map;\n\tu32 i;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\n\tif (trackNumber) {\n\t\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\tif (!trak->udta) {\n\t\t\te = trak_on_child_box((GF_Box*)trak, gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_UDTA), GF_FALSE);\n\t\t\tif (e) return e;\n\t\t}\n\t\tudta = trak->udta;\n\t} else {\n\t\treturn GF_OK;\n\t}\n\tmap = udta_getEntry(udta, GF_ISOM_BOX_TYPE_KIND, NULL);\n\tif (map) {\n\t\tfor (i=0; i<gf_list_count(map->boxes); i++) {\n\t\t\tGF_Box *b = (GF_Box *)gf_list_get(map->boxes, i);\n\t\t\tif (b->type == GF_ISOM_BOX_TYPE_KIND) {\n\t\t\t\tGF_KindBox *kb = (GF_KindBox *)b;\n\t\t\t\tif (!schemeURI ||\n\t\t\t\t        (!strcmp(kb->schemeURI, schemeURI) &&\n\t\t\t\t         ((value && kb->value && !strcmp(value, kb->value)) || (!value && !kb->value)))) {\n\t\t\t\t\tgf_isom_box_del_parent(&map->boxes, b);\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_add_chapter(GF_ISOFile *movie, u32 trackNumber, u64 timestamp, char *name)\n{\n\tGF_Err e;\n\tGF_ChapterListBox *ptr;\n\tu32 i, count;\n\tGF_ChapterEntry *ce;\n\tGF_UserDataBox *udta;\n\tGF_UserDataMap *map;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\n\tif (trackNumber) {\n\t\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\tif (!trak->udta) {\n\t\t\te = trak_on_child_box((GF_Box*)trak, gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_UDTA), GF_FALSE);\n\t\t\tif (e) return e;\n\t\t}\n\t\tudta = trak->udta;\n\t} else {\n\t\tif (!movie->moov->udta) {\n\t\t\te = moov_on_child_box((GF_Box*)movie->moov, gf_isom_box_new_parent(&movie->moov->child_boxes, GF_ISOM_BOX_TYPE_UDTA), GF_FALSE);\n\t\t\tif (e) return e;\n\t\t}\n\t\tudta = movie->moov->udta;\n\t}\n\n\tptr = NULL;\n\tmap = udta_getEntry(udta, GF_ISOM_BOX_TYPE_CHPL, NULL);\n\tif (!map) {\n\t\tptr = (GF_ChapterListBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_CHPL);\n\t\te = udta_on_child_box((GF_Box *)udta, (GF_Box *) ptr, GF_FALSE);\n\t\tif (e) return e;\n\t\tmap = udta_getEntry(udta, GF_ISOM_BOX_TYPE_CHPL, NULL);\n\t} else {\n\t\tptr = (GF_ChapterListBox*)gf_list_get(map->boxes, 0);\n\t}\n\tif (!map) return GF_OUT_OF_MEM;\n\n\t/*this may happen if original MP4 is not properly formatted*/\n\tif (!ptr) {\n\t\tptr = (GF_ChapterListBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_CHPL);\n\t\tif (!ptr) return GF_OUT_OF_MEM;\n\t\tgf_list_add(map->boxes, ptr);\n\t}\n\n\tGF_SAFEALLOC(ce, GF_ChapterEntry);\n\tif (!ce) return GF_OUT_OF_MEM;\n\n\tce->start_time = timestamp * 10000L;\n\tce->name = name ? gf_strdup(name) : NULL;\n\n\t/*insert in order*/\n\tcount = gf_list_count(ptr->list);\n\tfor (i=0; i<count; i++) {\n\t\tGF_ChapterEntry *ace = (GF_ChapterEntry *)gf_list_get(ptr->list, i);\n\t\tif (ace->start_time == ce->start_time) {\n\t\t\tif (ace->name) gf_free(ace->name);\n\t\t\tace->name = ce->name;\n\t\t\tgf_free(ce);\n\t\t\treturn GF_OK;\n\t\t}\n\t\tif (ace->start_time >= ce->start_time)\n\t\t\treturn gf_list_insert(ptr->list, ce, i);\n\t}\n\treturn gf_list_add(ptr->list, ce);\n}\n\nGF_EXPORT\nGF_Err gf_isom_remove_chapter(GF_ISOFile *movie, u32 trackNumber, u32 index)\n{\n\tGF_Err e;\n\tGF_ChapterListBox *ptr;\n\tGF_ChapterEntry *ce;\n\tGF_UserDataBox *udta;\n\tGF_UserDataMap *map;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\n\tif (trackNumber) {\n\t\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\tif (!trak->udta) return GF_OK;\n\t\tudta = trak->udta;\n\t} else {\n\t\tif (!movie->moov->udta) return GF_OK;\n\t\tudta = movie->moov->udta;\n\t}\n\n\tmap = udta_getEntry(udta, GF_ISOM_BOX_TYPE_CHPL, NULL);\n\tif (!map) return GF_OK;\n\tptr = (GF_ChapterListBox*)gf_list_get(map->boxes, 0);\n\tif (!ptr) return GF_OK;\n\n\tif (index) {\n\t\tce = (GF_ChapterEntry *)gf_list_get(ptr->list, index-1);\n\t\tif (!ce) return GF_BAD_PARAM;\n\t\tif (ce->name) gf_free(ce->name);\n\t\tgf_free(ce);\n\t\tgf_list_rem(ptr->list, index-1);\n\t} else {\n\t\twhile (gf_list_count(ptr->list)) {\n\t\t\tce = (GF_ChapterEntry *)gf_list_get(ptr->list, 0);\n\t\t\tif (ce->name) gf_free(ce->name);\n\t\t\tgf_free(ce);\n\t\t\tgf_list_rem(ptr->list, 0);\n\t\t}\n\t}\n\tif (!gf_list_count(ptr->list)) {\n\t\tgf_list_del_item(udta->recordList, map);\n\t\tgf_isom_box_array_del(map->boxes);\n\t\tgf_free(map);\n\t}\n\treturn GF_OK;\n}\n\n#if 0 //unused\nGF_Err gf_isom_remove_copyright(GF_ISOFile *movie, u32 index)\n{\n\tGF_Err e;\n\tGF_CopyrightBox *ptr;\n\tGF_UserDataMap *map;\n\tu32 count;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\n\tif (!index) return GF_BAD_PARAM;\n\tif (!movie->moov->udta) return GF_OK;\n\n\tmap = udta_getEntry(movie->moov->udta, GF_ISOM_BOX_TYPE_CPRT, NULL);\n\tif (!map) return GF_OK;\n\n\tcount = gf_list_count(map->boxes);\n\tif (index>count) return GF_BAD_PARAM;\n\n\tptr = (GF_CopyrightBox*)gf_list_get(map->boxes, index-1);\n\tif (ptr) {\n\t\tgf_list_rem(map->boxes, index-1);\n\t\tif (ptr->notice) gf_free(ptr->notice);\n\t\tgf_free(ptr);\n\t}\n\t/*last copyright, remove*/\n\tif (!gf_list_count(map->boxes)) {\n\t\tgf_list_del_item(movie->moov->udta->recordList, map);\n\t\tgf_list_del(map->boxes);\n\t\tgf_free(map);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err gf_isom_set_watermark(GF_ISOFile *movie, bin128 UUID, u8* data, u32 length)\n{\n\tGF_Err e;\n\tGF_UnknownUUIDBox *ptr;\n\tGF_UserDataMap *map;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\tif (!movie->moov->udta) {\n\t\te = moov_on_child_box((GF_Box*)movie->moov, gf_isom_box_new_parent(&movie->moov->child_boxes, GF_ISOM_BOX_TYPE_UDTA));\n\t\tif (e) return e;\n\t}\n\n\tmap = udta_getEntry(movie->moov->udta, GF_ISOM_BOX_TYPE_UUID, (bin128 *) & UUID);\n\tif (map) {\n\t\tptr = (GF_UnknownUUIDBox *)gf_list_get(map->boxes, 0);\n\t\tif (ptr) {\n\t\t\tgf_free(ptr->data);\n\t\t\tptr->data = (char*)gf_malloc(length);\n\t\t\tif (!ptr->data) return GF_OUT_OF_MEM;\n\t\t\tmemcpy(ptr->data, data, length);\n\t\t\tptr->dataSize = length;\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\t//nope, create one\n\tptr = (GF_UnknownUUIDBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_UUID);\n\tif (!ptr) return GF_OUT_OF_MEM;\n\n\tmemcpy(ptr->uuid, UUID, 16);\n\tptr->data = (char*)gf_malloc(length);\n\tif (!ptr->data) return GF_OUT_OF_MEM;\n\tmemcpy(ptr->data, data, length);\n\tptr->dataSize = length;\n\treturn udta_on_child_box((GF_Box *)movie->moov->udta, (GF_Box *) ptr);\n}\n#endif\n\n//set the interleaving time of media data (INTERLEAVED mode only)\n//InterleaveTime is in MovieTimeScale\nGF_EXPORT\nGF_Err gf_isom_set_interleave_time(GF_ISOFile *movie, u32 InterleaveTime)\n{\n\tGF_Err e;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tif (!InterleaveTime || !movie->moov) return GF_OK;\n\tmovie->interleavingTime = InterleaveTime;\n\treturn GF_OK;\n}\n\n\n\n//use a compact track version for sample size. This is not usually recommended\n//except for speech codecs where the track has a lot of small samples\n//compaction is done automatically while writing based on the track's sample sizes\nGF_EXPORT\nGF_Err gf_isom_use_compact_size(GF_ISOFile *movie, u32 trackNumber, Bool CompactionOn)\n{\n\tGF_TrackBox *trak;\n\tu32 i, size;\n\tGF_SampleSizeBox *stsz;\n\tGF_Err e;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tif (!trak->Media || !trak->Media->information\n\t        || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->SampleSize)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tstsz = trak->Media->information->sampleTable->SampleSize;\n\n\t//switch to regular table\n\tif (!CompactionOn) {\n\t\tif (stsz->type == GF_ISOM_BOX_TYPE_STSZ) return GF_OK;\n\t\tstsz->type = GF_ISOM_BOX_TYPE_STSZ;\n\t\t//invalidate the sampleSize and recompute it\n\t\tstsz->sampleSize = 0;\n\t\tif (!stsz->sampleCount) return GF_OK;\n\t\t//if the table is empty we can only assume the track is empty (no size indication)\n\t\tif (!stsz->sizes) return GF_OK;\n\t\tsize = stsz->sizes[0];\n\t\t//check whether the sizes are all the same or not\n\t\tfor (i=1; i<stsz->sampleCount; i++) {\n\t\t\tif (size != stsz->sizes[i]) {\n\t\t\t\tsize = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (size) {\n\t\t\tgf_free(stsz->sizes);\n\t\t\tstsz->sizes = NULL;\n\t\t\tstsz->sampleSize = size;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\n\t//switch to compact table\n\tif (stsz->type == GF_ISOM_BOX_TYPE_STZ2) return GF_OK;\n\t//fill the table. Although it seems weird , this is needed in case of edition\n\t//after the function is called. NOte however than we force regular table\n\t//at write time if all samples are of same size\n\tif (stsz->sampleSize) {\n\t\t//this is a weird table indeed ;)\n\t\tif (stsz->sizes) gf_free(stsz->sizes);\n\t\tstsz->sizes = (u32*) gf_malloc(sizeof(u32)*stsz->sampleCount);\n\t\tif (!stsz->sizes) return GF_OUT_OF_MEM;\n\t\tmemset(stsz->sizes, stsz->sampleSize, sizeof(u32));\n\t}\n\t//set the SampleSize to 0 while the file is open\n\tstsz->sampleSize = 0;\n\tstsz->type = GF_ISOM_BOX_TYPE_STZ2;\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_disable_brand_rewrite(GF_ISOFile *movie, Bool do_disable)\n{\n\tif (!movie) return GF_BAD_PARAM;\n\tmovie->disable_brand_rewrite = do_disable ? 1: 0;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_brand_info(GF_ISOFile *movie, u32 MajorBrand, u32 MinorVersion)\n{\n\tu32 i, *p;\n\n\tif (!movie) return GF_BAD_PARAM;\n\tif (movie->disable_brand_rewrite) return GF_OK;\n\tif (!MajorBrand) return GF_BAD_PARAM;\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (! (movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY)) {\n\t\tGF_Err e = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\t\tif (e) return e;\n\n\t\te = CheckNoData(movie);\n\t\tif (e) return e;\n\t}\n#endif\n\n\tif (!movie->brand) {\n\t\tmovie->brand = (GF_FileTypeBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_FTYP);\n\t\tif (!movie->brand) return GF_OUT_OF_MEM;\n\t\tgf_list_add(movie->TopBoxes, movie->brand);\n\t}\n\n\tmovie->brand->majorBrand = MajorBrand;\n\tmovie->brand->minorVersion = MinorVersion;\n\n\tif (!movie->brand->altBrand) {\n\t\tmovie->brand->altBrand = (u32*)gf_malloc(sizeof(u32));\n\t\tif (!movie->brand->altBrand) return GF_OUT_OF_MEM;\n\t\tmovie->brand->altBrand[0] = MajorBrand;\n\t\tmovie->brand->altCount = 1;\n\t\treturn GF_OK;\n\t}\n\n\t//if brand already present don't change anything\n\tfor (i=0; i<movie->brand->altCount; i++) {\n\t\tif (movie->brand->altBrand[i] == MajorBrand) return GF_OK;\n\t}\n\tp = (u32*)gf_malloc(sizeof(u32)*(movie->brand->altCount + 1));\n\tif (!p) return GF_OUT_OF_MEM;\n\tmemcpy(p, movie->brand->altBrand, sizeof(u32)*movie->brand->altCount);\n\tp[movie->brand->altCount] = MajorBrand;\n\tmovie->brand->altCount += 1;\n\tgf_free(movie->brand->altBrand);\n\tmovie->brand->altBrand = p;\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_modify_alternate_brand(GF_ISOFile *movie, u32 Brand, Bool AddIt)\n{\n\tu32 i, k, *p;\n\n\tif (!movie) return GF_BAD_PARAM;\n\tif (movie->disable_brand_rewrite) return GF_OK;\n\tif (!Brand) return GF_BAD_PARAM;\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (! (movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY)) {\n\t\tGF_Err e = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\t\tif (e) return e;\n\n\t\te = CheckNoData(movie);\n\t\tif (e) return e;\n\t}\n#endif\n\n\tif (!movie->brand && AddIt) {\n\t\tmovie->brand = (GF_FileTypeBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_FTYP);\n\t\tif (!movie->brand) return GF_OUT_OF_MEM;\n\t\tgf_list_add(movie->TopBoxes, movie->brand);\n\t}\n\tif (!AddIt && !movie->brand) return GF_OK;\n\n\t//do not mofify major one\n\tif (!AddIt && movie->brand->majorBrand == Brand) return GF_OK;\n\n\tif (!AddIt && movie->brand->altCount == 1) {\n\t\t//fixes it in case\n\t\tmovie->brand->altBrand[0] = movie->brand->majorBrand;\n\t\treturn GF_OK;\n\t}\n\t//check for the brand\n\tfor (i=0; i<movie->brand->altCount; i++) {\n\t\tif (movie->brand->altBrand[i] == Brand) goto found;\n\t}\n\t//Not found\n\tif (!AddIt) return GF_OK;\n\t//add it\n\tp = (u32*)gf_malloc(sizeof(u32)*(movie->brand->altCount + 1));\n\tif (!p) return GF_OUT_OF_MEM;\n\tif (movie->brand->altBrand) {\n\t\tmemcpy(p, movie->brand->altBrand, sizeof(u32)*movie->brand->altCount);\n\t\tgf_free(movie->brand->altBrand);\n\t}\n\tp[movie->brand->altCount] = Brand;\n\tmovie->brand->altCount += 1;\n\tmovie->brand->altBrand = p;\n\treturn GF_OK;\n\nfound:\n\n\t//found\n\tif (AddIt) return GF_OK;\n\tassert(movie->brand->altCount>1);\n\n\t//remove it\n\tp = (u32*)gf_malloc(sizeof(u32)*(movie->brand->altCount - 1));\n\tif (!p) return GF_OUT_OF_MEM;\n\tk = 0;\n\tfor (i=0; i<movie->brand->altCount; i++) {\n\t\tif (movie->brand->altBrand[i] == Brand) continue;\n\t\telse {\n\t\t\tp[k] = movie->brand->altBrand[i];\n\t\t\tk++;\n\t\t}\n\t}\n\tmovie->brand->altCount -= 1;\n\tgf_free(movie->brand->altBrand);\n\tmovie->brand->altBrand = p;\n\treturn GF_OK;\n}\n\n\nGF_Err gf_isom_reset_alt_brands_ex(GF_ISOFile *movie, Bool leave_empty)\n{\n\tu32 *p;\n\n\tif (!movie) return GF_BAD_PARAM;\n\tif (movie->disable_brand_rewrite) return GF_OK;\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (! (movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY)) {\n\t\tGF_Err e = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\t\tif (e) return e;\n\n\t\te = CheckNoData(movie);\n\t\tif (e) return e;\n\t}\n#endif\n\n\tif (!movie->brand) {\n\t\tmovie->brand = (GF_FileTypeBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_FTYP);\n\t\tif (!movie->brand) return GF_OUT_OF_MEM;\n\t\tgf_list_add(movie->TopBoxes, movie->brand);\n\t}\n\tgf_free(movie->brand->altBrand);\n\tif (leave_empty) {\n\t\tmovie->brand->altCount = 0;\n\t\tmovie->brand->altBrand = NULL;\n\t} else {\n\t\tp = (u32*)gf_malloc(sizeof(u32));\n\t\tif (!p) return GF_OUT_OF_MEM;\n\t\tp[0] = movie->brand->majorBrand;\n\t\tmovie->brand->altCount = 1;\n\t\tmovie->brand->altBrand = p;\n\t}\n\treturn GF_OK;\n}\nGF_EXPORT\nGF_Err gf_isom_reset_alt_brands(GF_ISOFile *movie)\n{\n\treturn gf_isom_reset_alt_brands_ex(movie, GF_FALSE);\n}\n\n#if 0 //unused\nGF_Err gf_isom_set_sample_padding_bits(GF_ISOFile *movie, u32 trackNumber, u32 sampleNumber, u8 NbBits)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || NbBits > 7) return GF_BAD_PARAM;\n\n\t//set Padding info\n\treturn stbl_SetPaddingBits(trak->Media->information->sampleTable, sampleNumber, NbBits);\n}\n#endif\n\nGF_EXPORT\nGF_Err gf_isom_remove_user_data_item(GF_ISOFile *movie, u32 trackNumber, u32 UserDataType, bin128 UUID, u32 UserDataIndex)\n{\n\tGF_UserDataMap *map;\n\tGF_Box *a;\n\tu32 i;\n\tbin128 t;\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_UserDataBox *udta;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tif (UserDataType == GF_ISOM_BOX_TYPE_UUID) UserDataType = 0;\n\tmemset(t, 1, 16);\n\n\tif (trackNumber) {\n\t\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\tudta = trak->udta;\n\t} else {\n\t\tif (!movie->moov) return GF_BAD_PARAM;\n\t\tudta = movie->moov->udta;\n\t}\n\tif (!udta) return GF_BAD_PARAM;\n\tif (!UserDataIndex) return GF_BAD_PARAM;\n\n\ti=0;\n\twhile ((map = (GF_UserDataMap*)gf_list_enum(udta->recordList, &i))) {\n\t\tif ((map->boxType == GF_ISOM_BOX_TYPE_UUID)  && !memcmp(map->uuid, UUID, 16)) goto found;\n\t\telse if (map->boxType == UserDataType) goto found;\n\t}\n\t//not found\n\treturn GF_OK;\n\nfound:\n\n\tif (UserDataIndex > gf_list_count(map->boxes) ) return GF_BAD_PARAM;\n\t//delete the box\n\ta = (GF_Box*)gf_list_get(map->boxes, UserDataIndex-1);\n\tgf_isom_box_del_parent(&map->boxes, a);\n\n\t//remove the map if empty\n\tif (!gf_list_count(map->boxes)) {\n\t\tgf_list_rem(udta->recordList, i-1);\n\t\tgf_isom_box_array_del(map->boxes);\n\t\tgf_free(map);\n\t}\n\t//but we keep the UDTA no matter what\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_remove_user_data(GF_ISOFile *movie, u32 trackNumber, u32 UserDataType, bin128 UUID)\n{\n\tGF_UserDataMap *map;\n\tu32 i;\n\tGF_Err e;\n\tbin128 t;\n\tGF_TrackBox *trak;\n\tGF_UserDataBox *udta;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tif (UserDataType == GF_ISOM_BOX_TYPE_UUID) UserDataType = 0;\n\tmemset(t, 1, 16);\n\n\tif (trackNumber) {\n\t\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return GF_EOS;\n\t\tudta = trak->udta;\n\t} else {\n\t\tif (!movie->moov) return GF_BAD_PARAM;\n\t\tudta = movie->moov->udta;\n\t}\n\t//do not return any error if no udta\n\tif (!udta) return GF_EOS;\n\n\ti=0;\n\twhile ((map = (GF_UserDataMap*)gf_list_enum(udta->recordList, &i))) {\n\t\tif ((map->boxType == GF_ISOM_BOX_TYPE_UUID)  && !memcmp(map->uuid, UUID, 16)) goto found;\n\t\telse if (map->boxType == UserDataType) goto found;\n\t}\n\t//not found\n\treturn GF_OK;\n\nfound:\n\n\tgf_list_rem(udta->recordList, i-1);\n\tgf_isom_box_array_del(map->boxes);\n\tgf_free(map);\n\n\t//but we keep the UDTA no matter what\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_add_user_data(GF_ISOFile *movie, u32 trackNumber, u32 UserDataType, bin128 UUID, u8 *data, u32 DataLength)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_UserDataBox *udta;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tif (UserDataType == GF_ISOM_BOX_TYPE_UUID) UserDataType = 0;\n\n\tif (trackNumber) {\n\t\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\tif (!trak->udta) trak_on_child_box((GF_Box*)trak, gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_UDTA), GF_FALSE);\n\t\tudta = trak->udta;\n\t} else {\n\t\tif (!movie->moov) return GF_BAD_PARAM;\n\t\tif (!movie->moov->udta) moov_on_child_box((GF_Box*)movie->moov, gf_isom_box_new_parent(&movie->moov->child_boxes, GF_ISOM_BOX_TYPE_UDTA), GF_FALSE);\n\t\tudta = movie->moov->udta;\n\t}\n\tif (!udta) return GF_OUT_OF_MEM;\n\n\t//create a default box\n\tif (UserDataType) {\n\t\tGF_UnknownBox *a = (GF_UnknownBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_UNKNOWN);\n\t\tif (!a) return GF_OUT_OF_MEM;\n\t\ta->original_4cc = UserDataType;\n\t\tif (DataLength) {\n\t\t\ta->data = (char*)gf_malloc(sizeof(char)*DataLength);\n\t\t\tif (!a->data) return GF_OUT_OF_MEM;\n\t\t\tmemcpy(a->data, data, DataLength);\n\t\t\ta->dataSize = DataLength;\n\t\t}\n\t\treturn udta_on_child_box((GF_Box *)udta, (GF_Box *) a, GF_FALSE);\n\t} else if (UUID) {\n\t\tGF_UnknownUUIDBox *a = (GF_UnknownUUIDBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_UUID);\n\t\tif (!a) return GF_OUT_OF_MEM;\n\t\tmemcpy(a->uuid, UUID, 16);\n\t\tif (DataLength) {\n\t\t\ta->data = (char*)gf_malloc(sizeof(char)*DataLength);\n\t\t\tif (!a->data) return GF_OUT_OF_MEM;\n\t\t\tmemcpy(a->data, data, DataLength);\n\t\t\ta->dataSize = DataLength;\n\t\t}\n\t\treturn udta_on_child_box((GF_Box *)udta, (GF_Box *) a, GF_FALSE);\n\t} else {\n\t\treturn GF_BAD_PARAM;\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_add_user_data_boxes(GF_ISOFile *movie, u32 trackNumber, u8 *data, u32 DataLength)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_UserDataBox *udta;\n\tGF_BitStream *bs;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tif (trackNumber) {\n\t\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\tif (!trak->udta) trak_on_child_box((GF_Box*)trak, gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_UDTA), GF_FALSE);\n\t\tudta = trak->udta;\n\t} else {\n\t\tif (!movie->moov) return GF_BAD_PARAM;\n\t\tif (!movie->moov->udta) moov_on_child_box((GF_Box*)movie->moov, gf_isom_box_new_parent(&movie->moov->child_boxes, GF_ISOM_BOX_TYPE_UDTA), GF_FALSE);\n\t\tudta = movie->moov->udta;\n\t}\n\tif (!udta) return GF_OUT_OF_MEM;\n\n\tbs = gf_bs_new(data, DataLength, GF_BITSTREAM_READ);\n\twhile (gf_bs_available(bs)) {\n\t\tGF_Box *a;\n\t\te = gf_isom_box_parse(&a, bs);\n\t\tif (e) break;\n\t\te = udta_on_child_box((GF_Box *)udta, a, GF_FALSE);\n\t\tif (e) break;\n\t}\n\tgf_bs_del(bs);\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_isom_clone_pl_indications(GF_ISOFile *orig, GF_ISOFile *dest)\n{\n\tGF_IsomInitialObjectDescriptor *iod_d;\n\tif (!orig || !dest) return GF_BAD_PARAM;\n\tif (!orig->moov->iods || !orig->moov->iods->descriptor) return GF_OK;\n\tif (orig->moov->iods->descriptor->tag != GF_ODF_ISOM_IOD_TAG) return GF_OK;\n\n\tAddMovieIOD(dest->moov, 1);\n\tgf_odf_desc_del((GF_Descriptor *)dest->moov->iods->descriptor);\n\tgf_odf_desc_copy((GF_Descriptor *)orig->moov->iods->descriptor, (GF_Descriptor **)&dest->moov->iods->descriptor);\n\tiod_d = (GF_IsomInitialObjectDescriptor *) dest->moov->iods->descriptor;\n\twhile (gf_list_count(iod_d->ES_ID_IncDescriptors)) {\n\t\tGF_Descriptor *d = (GF_Descriptor *)gf_list_get(iod_d->ES_ID_IncDescriptors, 0);\n\t\tgf_list_rem(iod_d->ES_ID_IncDescriptors, 0);\n\t\tgf_odf_desc_del(d);\n\t}\n\twhile (gf_list_count(iod_d->ES_ID_RefDescriptors)) {\n\t\tGF_Descriptor *d = (GF_Descriptor *)gf_list_get(iod_d->ES_ID_RefDescriptors, 0);\n\t\tgf_list_rem(iod_d->ES_ID_RefDescriptors, 0);\n\t\tgf_odf_desc_del(d);\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_clone_box(GF_Box *src, GF_Box **dst)\n{\n\tGF_Err e;\n\tu8 *data;\n\tu32 data_size;\n\tGF_BitStream *bs;\n\n\tif (*dst) {\n\t\tgf_isom_box_del(*dst);\n\t\t*dst=NULL;\n\t}\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tif (!bs) return GF_OUT_OF_MEM;\n\te = gf_isom_box_size( (GF_Box *) src);\n\tif (!e) e = gf_isom_box_write((GF_Box *) src, bs);\n\tgf_bs_get_content(bs, &data, &data_size);\n\tgf_bs_del(bs);\n\tif (e) {\n\t\tif (data) gf_free(data);\n\t\treturn e;\n\t}\n\tbs = gf_bs_new(data, data_size, GF_BITSTREAM_READ);\n\tif (!bs) {\n\t\tif (data) gf_free(data);\n\t\treturn GF_OUT_OF_MEM;\n\t}\n\te = gf_isom_box_parse(dst, bs);\n\tgf_bs_del(bs);\n\tgf_free(data);\n\treturn e;\n}\n\n#if 0 //unused\n/*clones the entire movie file to destination. Tracks can be cloned if clone_tracks is set, in which case hint tracks can be\nkept if keep_hint_tracks is set\nif keep_pssh, all pssh boxes will be kept\nfragment information (mvex) is not kept*/\nGF_Err gf_isom_clone_movie(GF_ISOFile *orig_file, GF_ISOFile *dest_file, Bool clone_tracks, Bool keep_hint_tracks, Bool keep_pssh)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_Box *box;\n\n\te = CanAccessMovie(dest_file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tif (orig_file->brand) {\n\t\tgf_list_del_item(dest_file->TopBoxes, dest_file->brand);\n\t\tgf_isom_box_del((GF_Box *)dest_file->brand);\n\t\tdest_file->brand = NULL;\n\t\tgf_isom_clone_box((GF_Box *)orig_file->brand, (GF_Box **)&dest_file->brand);\n\t\tif (dest_file->brand) gf_list_add(dest_file->TopBoxes, dest_file->brand);\n\t}\n\n\tif (orig_file->meta) {\n\t\tgf_list_del_item(dest_file->TopBoxes, dest_file->meta);\n\t\tgf_isom_box_del((GF_Box *)dest_file->meta);\n\t\tdest_file->meta = NULL;\n\t\t/*fixme - check imports*/\n\t\tgf_isom_clone_box((GF_Box *)orig_file->meta, (GF_Box **)&dest_file->meta);\n\t\tif (dest_file->meta) gf_list_add(dest_file->TopBoxes, dest_file->meta);\n\t}\n\tif (orig_file->moov) {\n\t\tu32 i, dstTrack;\n\t\tGF_Box *iods;\n\t\tGF_List *tracks = gf_list_new();\n\t\tGF_List *old_tracks = orig_file->moov->trackList;\n\t\torig_file->moov->trackList = tracks;\n\t\tiods = (GF_Box*)orig_file->moov->iods;\n\t\torig_file->moov->iods = NULL;\n\t\te = gf_isom_clone_box((GF_Box *)orig_file->moov, (GF_Box **)&dest_file->moov);\n\t\tif (e) {\n\t\t\tgf_list_del(tracks);\n\t\t\torig_file->moov->trackList = old_tracks;\n\t\t\treturn e;\n\t\t}\n\t\torig_file->moov->trackList = old_tracks;\n\t\tgf_list_del(tracks);\n\t\torig_file->moov->iods = (GF_ObjectDescriptorBox*)iods;\n\t\tgf_list_add(dest_file->TopBoxes, dest_file->moov);\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\tif (dest_file->moov->mvex) {\n\t\t\tgf_isom_box_del_parent(&dest_file->moov->child_boxes, (GF_Box *)dest_file->moov->mvex);\n\t\t\tdest_file->moov->mvex = NULL;\n\t\t}\n#endif\n\n\t\tif (clone_tracks) {\n\t\t\tfor (i=0; i<gf_list_count(orig_file->moov->trackList); i++) {\n\t\t\t\tGF_TrackBox *trak = (GF_TrackBox*)gf_list_get( orig_file->moov->trackList, i);\n\t\t\t\tif (!trak) continue;\n\t\t\t\tif (keep_hint_tracks || (trak->Media->handler->handlerType != GF_ISOM_MEDIA_HINT)) {\n\t\t\t\t\te = gf_isom_clone_track(orig_file, i+1, dest_file, 0, &dstTrack);\n\t\t\t\t\tif (e) return e;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (iods)\n\t\t\t\tgf_isom_clone_box((GF_Box *)orig_file->moov->iods, (GF_Box **)dest_file->moov->iods);\n\t\t} else {\n\t\t\tdest_file->moov->mvhd->nextTrackID = 1;\n\t\t\tgf_isom_clone_pl_indications(orig_file, dest_file);\n\t\t}\n\t\tdest_file->moov->mov = dest_file;\n\t}\n\n\tif (!keep_pssh) {\n\t\ti=0;\n\t\twhile ((box = (GF_Box*)gf_list_get(dest_file->moov->child_boxes, i++))) {\n\t\t\tif (box->type == GF_ISOM_BOX_TYPE_PSSH) {\n\t\t\t\ti--;\n\t\t\t\tgf_isom_box_del_parent(&dest_file->moov->child_boxes, box);\n\t\t\t}\n\t\t}\n\t}\n\n\t//duplicate other boxes\n\ti=0;\n\twhile ((box = (GF_Box*)gf_list_get(orig_file->TopBoxes, i++))) {\n\t\tswitch(box->type) {\n\t\tcase GF_ISOM_BOX_TYPE_MOOV:\n\t\tcase GF_ISOM_BOX_TYPE_META:\n\t\tcase GF_ISOM_BOX_TYPE_MDAT:\n\t\tcase GF_ISOM_BOX_TYPE_FTYP:\n\t\tcase GF_ISOM_BOX_TYPE_PDIN:\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t\tcase GF_ISOM_BOX_TYPE_STYP:\n\t\tcase GF_ISOM_BOX_TYPE_SIDX:\n\t\tcase GF_ISOM_BOX_TYPE_SSIX:\n\t\tcase GF_ISOM_BOX_TYPE_MOOF:\n#endif\n\t\tcase GF_ISOM_BOX_TYPE_JP:\n\t\t\tbreak;\n\n\t\tcase GF_ISOM_BOX_TYPE_PSSH:\n\t\t\tif (!keep_pssh)\n\t\t\t\tbreak;\n\n\t\tdefault:\n\t\t{\n\t\t\tGF_Box *box2 = NULL;\n\t\t\tgf_isom_clone_box(box, &box2);\n\t\t\tgf_list_add(dest_file->TopBoxes, box2);\n\t\t}\n\t\tbreak;\n\t\t}\n\t}\n\n\treturn GF_OK;\n}\n#endif\n\n\nGF_EXPORT\nGF_Err gf_isom_get_raw_user_data(GF_ISOFile *file, u8 **output, u32 *output_size)\n{\n\tGF_BitStream *bs;\n\tGF_Err e;\n\tGF_Box *b;\n\tu32 i;\n\n\t*output = NULL;\n\t*output_size = 0;\n\tif (!file || !file->moov || (!file->moov->udta && !file->moov->child_boxes)) return GF_OK;\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\tif (file->moov->udta) {\n\t\te = gf_isom_box_size( (GF_Box *) file->moov->udta);\n\t\tif (e) goto exit;\n\t\te = gf_isom_box_write((GF_Box *) file->moov->udta, bs);\n\t\tif (e) goto exit;\n\t}\n\te = GF_OK;\n\ti=0;\n\twhile ((b = gf_list_enum(file->moov->child_boxes, &i))) {\n\t\tswitch (b->type) {\n\t\tcase GF_ISOM_BOX_TYPE_TRAK:\n\t\tcase GF_ISOM_BOX_TYPE_MVHD:\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\tcase GF_ISOM_BOX_TYPE_MVEX:\n#endif\n\t\tcase GF_ISOM_BOX_TYPE_IODS:\n\t\tcase GF_ISOM_BOX_TYPE_META:\n\t\t\tcontinue;\n\t\t}\n\t\te = gf_isom_box_size( (GF_Box *) b);\n\t\tif (e) goto exit;\n\t\te = gf_isom_box_write((GF_Box *) b, bs);\n\t\tif (e) goto exit;\n\t}\n\n\tgf_bs_get_content(bs, output, output_size);\n\nexit:\n\tgf_bs_del(bs);\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_track_template(GF_ISOFile *file, u32 track, u8 **output, u32 *output_size)\n{\n\tGF_TrackBox *trak;\n\tGF_BitStream *bs;\n\tGF_DataReferenceBox *dref;\n\tGF_SampleTableBox *stbl, *stbl_temp;\n\tGF_SampleEncryptionBox *senc;\n\tGF_List *gpac_internals = NULL;\n\tu32 i, count;\n\n\t*output = NULL;\n\t*output_size = 0;\n\t/*get orig sample desc and clone it*/\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak || !trak->Media) return GF_BAD_PARAM;\n\n\t//don't serialize dref\n\tdref = NULL;\n\tif (trak->Media->information->dataInformation) {\n\t\tdref = trak->Media->information->dataInformation->dref;\n\t\ttrak->Media->information->dataInformation->dref = NULL;\n\t\tgf_list_del_item(trak->Media->information->dataInformation->child_boxes, dref);\n\t}\n\n\t//don't serialize stbl but create a temp one\n\tstbl_temp = (GF_SampleTableBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_STBL);\n\tif (!stbl_temp->child_boxes) stbl_temp->child_boxes = gf_list_new();\n\tstbl = trak->Media->information->sampleTable;\n\tgf_list_del_item(trak->Media->information->child_boxes, stbl);\n\n\ttrak->Media->information->sampleTable = stbl_temp;\n\tgf_list_add(trak->Media->information->child_boxes, stbl_temp);\n\n\t/*do not clone sampleDescription table but create an empty one*/\n\tstbl_temp->SampleDescription = (GF_SampleDescriptionBox *) gf_isom_box_new_parent(&stbl_temp->child_boxes, GF_ISOM_BOX_TYPE_STSD);\n\n\t/*clone sampleGroups description tables if any*/\n\tstbl_temp->sampleGroupsDescription = stbl->sampleGroupsDescription;\n\tcount = gf_list_count(stbl->sampleGroupsDescription);\n\tfor (i=0;i<count; i++) {\n\t\tGF_SampleGroupDescriptionBox *b = gf_list_get(stbl->sampleGroupsDescription, i);\n\t\t//don't add our internal sample groups\n\t\tif (b->grouping_type==GF_4CC('E','M','S','G'))\n\t\t\tcontinue;\n\t\tif (b->grouping_type==GF_4CC('P','S','S','H'))\n\t\t\tcontinue;\n\t\tgf_list_add(stbl_temp->child_boxes, b);\n\t}\n\t/*clone CompositionToDecode table, we may remove it later*/\n\tstbl_temp->CompositionToDecode = stbl->CompositionToDecode;\n\tgf_list_add(stbl_temp->child_boxes, stbl->CompositionToDecode);\n\n\n\tcount = gf_list_count(trak->child_boxes);\n\tfor (i=0;i<count; i++) {\n\t\tGF_UnknownBox *b = gf_list_get(trak->child_boxes, i);\n\t\tif (b->type != GF_ISOM_BOX_TYPE_UNKNOWN) continue;\n\t\tif (b->original_4cc==GF_ISOM_BOX_TYPE_GDAT) {\n\t\t\tif (!gpac_internals) gpac_internals = gf_list_new();\n\t\t\tgf_list_add(gpac_internals, b);\n\t\t\tgf_list_rem(trak->child_boxes, i);\n\t\t\ti--;\n\t\t\tcount--;\n\t\t}\n\t}\n\n\t//don't serialize senc\n\tsenc = trak->sample_encryption;\n\tif (senc) {\n\t\tassert(trak->child_boxes);\n\t\tgf_list_del_item(trak->child_boxes, senc);\n\t\ttrak->sample_encryption = NULL;\n\t}\n\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\tgf_isom_box_size( (GF_Box *) trak);\n\tgf_isom_box_write((GF_Box *) trak, bs);\n\tgf_bs_get_content(bs, output, output_size);\n\tgf_bs_del(bs);\n\n\t//restore our pointers\n\tif (dref) {\n\t\ttrak->Media->information->dataInformation->dref = dref;\n\t\tgf_list_add(trak->Media->information->dataInformation->child_boxes, dref);\n\t}\n\ttrak->Media->information->sampleTable = stbl;\n\tgf_list_add(trak->Media->information->child_boxes, stbl);\n\tgf_list_del_item(trak->Media->information->child_boxes, stbl_temp);\n\tif (senc) {\n\t\ttrak->sample_encryption = senc;\n\t\tgf_list_add(trak->child_boxes, senc);\n\t}\n\n\tstbl_temp->sampleGroupsDescription = NULL;\n\tcount = gf_list_count(stbl->sampleGroupsDescription);\n\tfor (i=0;i<count; i++) {\n\t\tGF_Box *b = gf_list_get(stbl->sampleGroupsDescription, i);\n\t\tgf_list_del_item(stbl_temp->child_boxes, b);\n\t}\n\n\tstbl_temp->CompositionToDecode = NULL;\n\tgf_list_del_item(stbl_temp->child_boxes, stbl->CompositionToDecode);\n\tgf_isom_box_del((GF_Box *)stbl_temp);\n\n\tif (gpac_internals) {\n\t\tgf_list_transfer(trak->child_boxes, gpac_internals);\n\t\tgf_list_del(gpac_internals);\n\t}\n\treturn GF_OK;\n\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_trex_template(GF_ISOFile *file, u32 track, u8 **output, u32 *output_size)\n{\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tGF_TrackBox *trak;\n\tGF_BitStream *bs;\n\tu32 i;\n\tGF_TrackExtendsBox *trex = NULL;\n\tGF_TrackExtensionPropertiesBox *trexprop = NULL;\n\n\t*output = NULL;\n\t*output_size = 0;\n\t/*get orig sample desc and clone it*/\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak || !trak->Media) return GF_BAD_PARAM;\n\tif (!file->moov->mvex) return GF_NOT_FOUND;\n\tfor (i=0; i<gf_list_count(file->moov->mvex->TrackExList); i++) {\n\t\ttrex = gf_list_get(file->moov->mvex->TrackExList, i);\n\t\tif (trex->trackID == trak->Header->trackID) break;\n\t\ttrex = NULL;\n\t}\n\tif (!trex) return GF_NOT_FOUND;\n\n\tfor (i=0; i<gf_list_count(file->moov->mvex->TrackExPropList); i++) {\n\t\ttrexprop = gf_list_get(file->moov->mvex->TrackExPropList, i);\n\t\tif (trexprop->trackID== trak->Header->trackID) break;\n\t\ttrexprop = NULL;\n\t}\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tgf_isom_box_size( (GF_Box *) trex);\n\tgf_isom_box_write((GF_Box *) trex, bs);\n\n\tif (trexprop) {\n\t\tgf_isom_box_size( (GF_Box *) trexprop);\n\t\tgf_isom_box_write((GF_Box *) trexprop, bs);\n\t}\n\tgf_bs_get_content(bs, output, output_size);\n\tgf_bs_del(bs);\n\n#else\n\t*output = NULL;\n\t*output_size = 0;\n#endif\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_stsd_template(GF_ISOFile *file, u32 track, u32 stsd_idx, u8 **output, u32 *output_size)\n{\n\tGF_TrackBox *trak;\n\tGF_BitStream *bs;\n\tGF_Box *ent;\n\n\t*output = NULL;\n\t*output_size = 0;\n\t/*get orig sample desc and clone it*/\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->SampleDescription) return GF_BAD_PARAM;\n\n\tif (stsd_idx) {\n\t\tent = gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, stsd_idx-1);\n\t\tif (!ent) return GF_BAD_PARAM;\n\t} else {\n\t\tent = (GF_Box*) trak->Media->information->sampleTable->SampleDescription;\n\t}\n\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\tgf_isom_box_size(ent);\n\tgf_isom_box_write(ent, bs);\n\tgf_bs_get_content(bs, output, output_size);\n\tgf_bs_del(bs);\n\treturn GF_OK;\n\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_clone_track(GF_ISOFile *orig_file, u32 orig_track, GF_ISOFile *dest_file, GF_ISOTrackCloneFlags flags, u32 *dest_track)\n{\n\tGF_TrackBox *trak, *new_tk;\n\tGF_BitStream *bs;\n\tu8 *data;\n\tconst u8 *buffer;\n\tu32 data_size;\n\tu32 i, count;\n\tGF_Err e;\n\tGF_SampleTableBox *stbl, *stbl_temp;\n\tGF_SampleEncryptionBox *senc;\n\n\te = CanAccessMovie(dest_file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\te = gf_isom_insert_moov(dest_file);\n\tif (e) return e;\n\n\t/*get orig sample desc and clone it*/\n\ttrak = gf_isom_get_track_from_file(orig_file, orig_track);\n\tif (!trak || !trak->Media) return GF_BAD_PARAM;\n\n\tstbl = trak->Media->information->sampleTable;\n\tstbl_temp = (GF_SampleTableBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_STBL);\n\tif (!stbl_temp->child_boxes) stbl_temp->child_boxes = gf_list_new();\n\n\ttrak->Media->information->sampleTable = stbl_temp;\n\tgf_list_add(trak->Media->information->child_boxes, stbl_temp);\n\tgf_list_del_item(trak->Media->information->child_boxes, stbl);\n\n\tif (!stbl_temp->child_boxes) stbl_temp->child_boxes = gf_list_new();\n\n\t/*clone sampleDescription table*/\n\tstbl_temp->SampleDescription = stbl->SampleDescription;\n\tgf_list_add(stbl_temp->child_boxes, stbl->SampleDescription);\n\t/*also clone sampleGroups description tables if any*/\n\tstbl_temp->sampleGroupsDescription = stbl->sampleGroupsDescription;\n\tcount = gf_list_count(stbl->sampleGroupsDescription);\n\tfor (i=0; i<count; i++) {\n\t\tGF_Box *b = gf_list_get(stbl->sampleGroupsDescription, i);\n\t\tgf_list_add(stbl_temp->child_boxes, b);\n\t}\n\t/*clone CompositionToDecode table, we may remove it later*/\n\tstbl_temp->CompositionToDecode = stbl->CompositionToDecode;\n\tgf_list_add(stbl_temp->child_boxes, stbl->CompositionToDecode);\n\n\tsenc = trak->sample_encryption;\n\tif (senc) {\n\t\tassert(trak->child_boxes);\n\t\tgf_list_del_item(trak->child_boxes, senc);\n\t\ttrak->sample_encryption = NULL;\n\t}\n\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\tgf_isom_box_size( (GF_Box *) trak);\n\tgf_isom_box_write((GF_Box *) trak, bs);\n\tgf_bs_get_content(bs, &data, &data_size);\n\tgf_bs_del(bs);\n\tbs = gf_bs_new(data, data_size, GF_BITSTREAM_READ);\n\tif (flags & GF_ISOM_CLONE_TRACK_NO_QT)\n\t\tgf_bs_set_cookie(bs, GF_ISOM_BS_COOKIE_QT_CONV | GF_ISOM_BS_COOKIE_CLONE_TRACK);\n\telse\n\t\tgf_bs_set_cookie(bs, GF_ISOM_BS_COOKIE_CLONE_TRACK);\n\n\te = gf_isom_box_parse((GF_Box **) &new_tk, bs);\n\tgf_bs_del(bs);\n\tgf_free(data);\n\n\ttrak->Media->information->sampleTable = stbl;\n\tgf_list_del_item(trak->Media->information->child_boxes, stbl_temp);\n\tgf_list_add(trak->Media->information->child_boxes, stbl);\n\n\tif (senc) {\n\t\ttrak->sample_encryption = senc;\n\t\tgf_list_add(trak->child_boxes, senc);\n\t}\n\tgf_list_del_item(stbl_temp->child_boxes, stbl_temp->SampleDescription);\n\tstbl_temp->SampleDescription = NULL;\n\n\tcount = gf_list_count(stbl->sampleGroupsDescription);\n\tfor (i=0; i<count; i++) {\n\t\tGF_Box *b = gf_list_get(stbl->sampleGroupsDescription, i);\n\t\tgf_list_del_item(stbl_temp->child_boxes, b);\n\t}\n\tstbl_temp->sampleGroupsDescription = NULL;\n\n\tgf_list_del_item(stbl_temp->child_boxes, stbl_temp->CompositionToDecode);\n\tstbl_temp->CompositionToDecode = NULL;\n\tgf_isom_box_del((GF_Box *)stbl_temp);\n\n\tif (e) {\n\t\tif (new_tk) gf_isom_box_del((GF_Box *)new_tk);\n\t\treturn e;\n\t}\n\n\tgf_isom_disable_inplace_rewrite(dest_file);\n\n\t/*create default boxes*/\n\tstbl = new_tk->Media->information->sampleTable;\n\tstbl->ChunkOffset = gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STCO);\n\tif (!stbl->ChunkOffset) return GF_OUT_OF_MEM;\n\tstbl->SampleSize = (GF_SampleSizeBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STSZ);\n\tif (!stbl->SampleSize) return GF_OUT_OF_MEM;\n\tstbl->SampleToChunk = (GF_SampleToChunkBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STSC);\n\tif (!stbl->SampleToChunk) return GF_OUT_OF_MEM;\n\tstbl->TimeToSample = (GF_TimeToSampleBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STTS);\n\tif (!stbl->TimeToSample) return GF_OUT_OF_MEM;\n\n\tif (flags & GF_ISOM_CLONE_TRACK_DROP_ID)\n\t\tnew_tk->Header->trackID = 0;\n\n\t/*check trackID validity before adding track*/\n\tif (!new_tk->Header->trackID || gf_isom_get_track_by_id(dest_file, new_tk->Header->trackID)) {\n\t\tu32 ID = 1;\n\t\twhile (1) {\n\t\t\tif (RequestTrack(dest_file->moov, ID)) break;\n\t\t\tID += 1;\n\t\t\tif (ID == 0xFFFFFFFF) break;\n\t\t}\n\t\tnew_tk->Header->trackID = ID;\n\t}\n\tif (!dest_file->moov->child_boxes) dest_file->moov->child_boxes = gf_list_new();\n\tgf_list_add(dest_file->moov->child_boxes, new_tk);\n\tmoov_on_child_box((GF_Box*)dest_file->moov, (GF_Box *)new_tk, GF_FALSE);\n\n\t/*set originalID*/\n\tnew_tk->originalID = trak->Header->trackID;\n\t/*set originalFile*/\n\tbuffer = gf_isom_get_filename(orig_file);\n\tnew_tk->originalFile = gf_crc_32(buffer, (u32) strlen(buffer));\n\n\t/*rewrite edit list segmentDuration to new movie timescale*/\n\tif (dest_file->moov->mvhd->timeScale != orig_file->moov->mvhd->timeScale) {\n\t\tDouble ts_scale = dest_file->moov->mvhd->timeScale;\n\t\tts_scale /= orig_file->moov->mvhd->timeScale;\n\t\tnew_tk->Header->duration = (u64) (new_tk->Header->duration * ts_scale);\n\t\tif (new_tk->editBox && new_tk->editBox->editList) {\n\t\t\tcount = gf_list_count(new_tk->editBox->editList->entryList);\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tGF_EdtsEntry *ent = (GF_EdtsEntry *)gf_list_get(new_tk->editBox->editList->entryList, i);\n\t\t\t\tent->segmentDuration = (u64) (ent->segmentDuration * ts_scale);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (flags & GF_ISOM_CLONE_RESET_DURATION)\n\t\tnew_tk->Media->mediaHeader->duration = 0;\n\n\tif (!new_tk->Media->information->dataInformation->dref) return GF_BAD_PARAM;\n\n\t/*reset data ref*/\n\tif (! (flags & GF_ISOM_CLONE_TRACK_KEEP_DREF) ) {\n\t\tGF_SampleEntryBox *entry;\n\t\tBool use_alis = GF_FALSE;\n\t\tif (! (flags & GF_ISOM_CLONE_TRACK_NO_QT)) {\n\t\t\tGF_Box *b = gf_list_get(new_tk->Media->information->dataInformation->dref->child_boxes, 0);\n\t\t\tif (b && (b->type==GF_QT_BOX_TYPE_ALIS))\n\t\t\t\tuse_alis = GF_TRUE;\n\t\t}\n\t\tgf_isom_box_array_del(new_tk->Media->information->dataInformation->dref->child_boxes);\n\t\tnew_tk->Media->information->dataInformation->dref->child_boxes = gf_list_new();\n\t\t/*update data ref*/\n\t\tentry = (GF_SampleEntryBox*)gf_list_get(new_tk->Media->information->sampleTable->SampleDescription->child_boxes, 0);\n\t\tif (entry) {\n\t\t\tu32 dref;\n\t\t\tMedia_CreateDataRef(dest_file, new_tk->Media->information->dataInformation->dref, use_alis ?  \"alis\" : NULL, NULL, &dref);\n\t\t\tentry->dataReferenceIndex = dref;\n\t\t}\n\t} else {\n\t\tfor (i=0; i<gf_list_count(new_tk->Media->information->dataInformation->dref->child_boxes); i++) {\n\t\t\tGF_DataEntryBox *dref_entry = (GF_DataEntryBox *)gf_list_get(new_tk->Media->information->dataInformation->dref->child_boxes, i);\n\t\t\tif (dref_entry->flags & 1) {\n\t\t\t\tdref_entry->flags &= ~1;\n\t\t\t\te = Media_SetDrefURL((GF_DataEntryURLBox *)dref_entry, orig_file->fileName, dest_file->finalName);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\t\t}\n\t}\n\n\t//purge all 'gpac' boxes at track level\n\tfor (i=0; i<gf_list_count(new_tk->child_boxes); i++) {\n\t\tGF_UnknownBox *b = (GF_UnknownBox *)gf_list_get(new_tk->child_boxes, i);\n\t\tif (b->type != GF_ISOM_BOX_TYPE_UNKNOWN) continue;\n\t\tif (b->original_4cc==GF_ISOM_BOX_TYPE_GDAT) {\n\t\t\tgf_list_rem(new_tk->child_boxes, i);\n\t\t\ti--;\n\t\t\tgf_isom_box_del((GF_Box*)b);\n\t\t}\n\t}\n\n\t*dest_track = gf_list_count(dest_file->moov->trackList);\n\n\tif (dest_file->moov->mvhd->nextTrackID <= new_tk->Header->trackID)\n\t\tdest_file->moov->mvhd->nextTrackID = new_tk->Header->trackID+1;\n\n\treturn GF_OK;\n}\n\n#if 0\n/*clones all sampleDescription entries in new track, after an optional reset of existing entries*/\nGF_Err gf_isom_clone_sample_descriptions(GF_ISOFile *the_file, u32 trackNumber, GF_ISOFile *orig_file, u32 orig_track, Bool reset_existing)\n{\n\tu32 i;\n\tGF_TrackBox *dst_trak, *src_trak;\n\tGF_Err e = CanAccessMovie(the_file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tdst_trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!dst_trak || !dst_trak->Media) return GF_BAD_PARAM;\n\tsrc_trak = gf_isom_get_track_from_file(orig_file, orig_track);\n\tif (!src_trak || !src_trak->Media) return GF_BAD_PARAM;\n\n\tif (reset_existing) {\n\t\tgf_isom_box_array_del(dst_trak->Media->information->sampleTable->SampleDescription->child_boxes);\n\t\tdst_trak->Media->information->sampleTable->SampleDescription->child_boxes = gf_list_new();\n\t}\n\n\tfor (i=0; i<gf_list_count(src_trak->Media->information->sampleTable->SampleDescription->child_boxes); i++) {\n\t\tu32 outDesc;\n\t\te = gf_isom_clone_sample_description(the_file, trackNumber, orig_file, orig_track, i+1, NULL, NULL, &outDesc);\n\t\tif (e) break;\n\t}\n\treturn e;\n}\n#endif\n\n\nGF_EXPORT\nGF_Err gf_isom_clone_sample_description(GF_ISOFile *the_file, u32 trackNumber, GF_ISOFile *orig_file, u32 orig_track, u32 orig_desc_index, const char *URLname, const char *URNname, u32 *outDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_BitStream *bs;\n\tu8 *data;\n\tu32 data_size;\n\tGF_Box *entry;\n\tGF_Err e;\n\tu32 dataRefIndex;\n    u32 mtype;\n\tu32 internal_type;\n\n\te = CanAccessMovie(the_file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\t/*get orig sample desc and clone it*/\n\ttrak = gf_isom_get_track_from_file(orig_file, orig_track);\n\tif (!trak || !trak->Media) return GF_BAD_PARAM;\n\n\tentry = (GF_Box*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, orig_desc_index-1);\n\tif (!entry) return GF_BAD_PARAM;\n\tinternal_type = ((GF_SampleEntryBox *)entry)->internal_type;\n\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\tgf_isom_box_size(entry);\n\tgf_isom_box_write(entry, bs);\n\tgf_bs_get_content(bs, &data, &data_size);\n\tgf_bs_del(bs);\n\tbs = gf_bs_new(data, data_size, GF_BITSTREAM_READ);\n\te = gf_isom_box_parse(&entry, bs);\n\tgf_bs_del(bs);\n\tgf_free(data);\n\tif (e) return e;\n\tif (entry->type==GF_ISOM_BOX_TYPE_UNKNOWN) {\n\t\tGF_UnknownBox *ubox = (GF_UnknownBox*)entry;\n\t\tif (internal_type == GF_ISOM_SAMPLE_ENTRY_VIDEO) {\n\t\t\tGF_GenericVisualSampleEntryBox *ve = (GF_GenericVisualSampleEntryBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_GNRV);\n\t\t\tve->EntryType = ubox->type;\n\t\t\tve->data = ubox->data;\n\t\t\tve->data_size = ubox->dataSize;\n\t\t\tentry = (GF_Box *) ve;\n\t\t}\n\t\telse if (internal_type == GF_ISOM_SAMPLE_ENTRY_AUDIO) {\n\t\t\tGF_GenericAudioSampleEntryBox *ae = (GF_GenericAudioSampleEntryBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_GNRA);\n\t\t\tae->EntryType = ubox->type;\n\t\t\tae->data = ubox->data;\n\t\t\tae->data_size = ubox->dataSize;\n\t\t\tentry = (GF_Box *) ae;\n\t\t}\n\t\telse {\n\t\t\tGF_GenericSampleEntryBox *ge = (GF_GenericSampleEntryBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_GNRM);\n\t\t\tge->EntryType = ubox->type;\n\t\t\tge->data = ubox->data;\n\t\t\tge->data_size = ubox->dataSize;\n\t\t\tentry = (GF_Box *) ge;\n\t\t}\n\t\tubox->data = NULL;\n\t\tubox->dataSize = 0;\n\t\tgf_isom_box_del((GF_Box *)ubox);\n\t}\n\n\t/*get new track and insert clone*/\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media) goto exit;\n\n\t/*get or create the data ref*/\n\te = Media_FindDataRef(trak->Media->information->dataInformation->dref, (char *)URLname, (char *)URNname, &dataRefIndex);\n\tif (e) goto exit;\n\tif (!dataRefIndex) {\n\t\te = Media_CreateDataRef(the_file, trak->Media->information->dataInformation->dref, (char *)URLname, (char *)URNname, &dataRefIndex);\n\t\tif (e) goto exit;\n\t}\n\tif (!the_file->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\t/*overwrite dref*/\n\t((GF_SampleEntryBox *)entry)->dataReferenceIndex = dataRefIndex;\n\te = gf_list_add(trak->Media->information->sampleTable->SampleDescription->child_boxes, entry);\n\t*outDescriptionIndex = gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes);\n\n\t/*also clone track w/h info*/\n    mtype = gf_isom_get_media_type(the_file, trackNumber);\n\tif (gf_isom_is_video_handler_type(mtype) ) {\n\t\tgf_isom_set_visual_info(the_file, trackNumber, (*outDescriptionIndex), ((GF_VisualSampleEntryBox*)entry)->Width, ((GF_VisualSampleEntryBox*)entry)->Height);\n\t}\n\treturn e;\n\nexit:\n\tgf_isom_box_del(entry);\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_isom_new_generic_sample_description(GF_ISOFile *movie, u32 trackNumber, const char *URLname, const char *URNname, GF_GenericSampleDescription *udesc, u32 *outDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tu8 **wrap_data;\n\tu32 *wrap_size;\n\tu32 dataRefIndex;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media || !udesc) return GF_BAD_PARAM;\n\n\t//get or create the data ref\n\te = Media_FindDataRef(trak->Media->information->dataInformation->dref, (char *)URLname, (char *)URNname, &dataRefIndex);\n\tif (e) return e;\n\tif (!dataRefIndex) {\n\t\te = Media_CreateDataRef(movie, trak->Media->information->dataInformation->dref, (char *)URLname, (char *)URNname, &dataRefIndex);\n\t\tif (e) return e;\n\t}\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tif (gf_isom_is_video_handler_type(trak->Media->handler->handlerType)) {\n\t\tGF_GenericVisualSampleEntryBox *entry;\n\t\t//create a new entry\n\t\tentry = (GF_GenericVisualSampleEntryBox*) gf_isom_box_new(GF_ISOM_BOX_TYPE_GNRV);\n\t\tif (!entry) return GF_OUT_OF_MEM;\n\n\t\tif (!udesc->codec_tag) {\n\t\t\tentry->EntryType = GF_ISOM_BOX_TYPE_UUID;\n\t\t\tmemcpy(entry->uuid, udesc->UUID, sizeof(bin128));\n\t\t} else {\n\t\t\tentry->EntryType = udesc->codec_tag;\n\t\t}\n\t\tif (entry->EntryType == 0) {\n\t\t\tgf_isom_box_del((GF_Box *)entry);\n\t\t\treturn GF_NOT_SUPPORTED;\n\t\t}\n\n\t\tentry->dataReferenceIndex = dataRefIndex;\n\t\tentry->vendor = udesc->vendor_code;\n\t\tentry->version = udesc->version;\n\t\tentry->revision = udesc->revision;\n\t\tentry->temporal_quality = udesc->temporal_quality;\n\t\tentry->spatial_quality = udesc->spatial_quality;\n\t\tentry->Width = udesc->width;\n\t\tentry->Height = udesc->height;\n\t\tstrcpy(entry->compressor_name, udesc->compressor_name);\n\t\tentry->color_table_index = -1;\n\t\tentry->frames_per_sample = 1;\n\t\tentry->horiz_res = udesc->h_res ? udesc->h_res : 0x00480000;\n\t\tentry->vert_res = udesc->v_res ? udesc->v_res : 0x00480000;\n\t\tentry->bit_depth = udesc->depth ? udesc->depth : 0x18;\n\t\twrap_data = &entry->data;\n\t\twrap_size = &entry->data_size;\n\t\te = gf_list_add(trak->Media->information->sampleTable->SampleDescription->child_boxes, entry);\n\t}\n\telse if (trak->Media->handler->handlerType==GF_ISOM_MEDIA_AUDIO) {\n\t\tGF_GenericAudioSampleEntryBox *gena;\n\t\t//create a new entry\n\t\tgena = (GF_GenericAudioSampleEntryBox*) gf_isom_box_new(GF_ISOM_BOX_TYPE_GNRA);\n\t\tif (!gena) return GF_OUT_OF_MEM;\n\n\t\tif (!udesc->codec_tag) {\n\t\t\tgena->EntryType = GF_ISOM_BOX_TYPE_UUID;\n\t\t\tmemcpy(gena->uuid, udesc->UUID, sizeof(bin128));\n\t\t} else {\n\t\t\tgena->EntryType = udesc->codec_tag;\n\t\t}\n\t\tif (gena->EntryType == 0) {\n\t\t\tgf_isom_box_del((GF_Box *)gena);\n\t\t\treturn GF_NOT_SUPPORTED;\n\t\t}\n\n\t\tgena->dataReferenceIndex = dataRefIndex;\n\t\tgena->vendor = udesc->vendor_code;\n\t\tgena->version = udesc->version;\n\t\tgena->revision = udesc->revision;\n\t\tgena->bitspersample = udesc->bits_per_sample ? udesc->bits_per_sample : 16;\n\t\tgena->channel_count = udesc->nb_channels ? udesc->nb_channels : 2;\n\t\tgena->samplerate_hi = udesc->samplerate;\n\t\tgena->samplerate_lo = 0;\n\t\tgena->qtff_mode = udesc->is_qtff ? GF_ISOM_AUDIO_QTFF_ON_NOEXT : GF_ISOM_AUDIO_QTFF_NONE;\n\t\tif (gena->EntryType==GF_QT_SUBTYPE_LPCM) {\n\t\t\tgena->version = 2;\n\t\t\tgena->qtff_mode = GF_ISOM_AUDIO_QTFF_ON_EXT_VALID;\n\t\t\tGF_BitStream *bs = gf_bs_new(gena->extensions, 36, GF_BITSTREAM_WRITE);\n\t\t\tgf_bs_write_u32(bs, 72);\n\t\t\tgf_bs_write_double(bs, udesc->samplerate);\n\t\t\tgf_bs_write_u32(bs, udesc->nb_channels);\n\t\t\tgf_bs_write_u32(bs, 0x7F000000);\n\t\t\tgf_bs_write_u32(bs, gena->bitspersample);\n\t\t\tgf_bs_write_u32(bs, udesc->lpcm_flags);\n\t\t\tgf_bs_write_u32(bs, udesc->nb_channels*gena->bitspersample/8); //constBytesPerAudioPacket\n\t\t\tgf_bs_write_u32(bs, 1); //constLPCMFramesPerAudioPacket\n\t\t\tgf_bs_del(bs);\n\t\t\tgena->revision = 0;\n\t\t\tgena->vendor = 0;\n\t\t\tgena->channel_count = 3;\n\t\t\tgena->bitspersample = 16;\n\t\t\tgena->compression_id = 0xFFFE;\n\t\t\tgena->packet_size = 0;\n\t\t\tgena->samplerate_hi = 1;\n\t\t} else if (udesc->is_qtff) {\n\t\t\tGF_Box *b = gf_isom_box_new_parent(&gena->child_boxes, GF_QT_BOX_TYPE_WAVE);\n\t\t\tGF_ChromaInfoBox *enda = (GF_ChromaInfoBox*) gf_isom_box_new_parent(&b->child_boxes, GF_QT_BOX_TYPE_ENDA);\n\t\t\t((GF_ChromaInfoBox *)enda)->chroma = (udesc->lpcm_flags & (1<<1)) ? 0 : 1;\n\n\t\t\tGF_UnknownBox *term = (GF_UnknownBox*) gf_isom_box_new_parent(&b->child_boxes, GF_ISOM_BOX_TYPE_UNKNOWN);\n\t\t\tif (term) term->original_4cc = 0;\n\t\t}\n\n\t\twrap_data = &gena->data;\n\t\twrap_size = &gena->data_size;\n\t\te = gf_list_add(trak->Media->information->sampleTable->SampleDescription->child_boxes, gena);\n\t}\n\telse {\n\t\tGF_GenericSampleEntryBox *genm;\n\t\t//create a new entry\n\t\tgenm = (GF_GenericSampleEntryBox*) gf_isom_box_new(GF_ISOM_BOX_TYPE_GNRM);\n\t\tif (!genm) return GF_OUT_OF_MEM;\n\n\t\tif (!udesc->codec_tag) {\n\t\t\tgenm->EntryType = GF_ISOM_BOX_TYPE_UUID;\n\t\t\tmemcpy(genm->uuid, udesc->UUID, sizeof(bin128));\n\t\t} else {\n\t\t\tgenm->EntryType = udesc->codec_tag;\n\t\t}\n\t\tif (genm->EntryType == 0) {\n\t\t\tgf_isom_box_del((GF_Box *)genm);\n\t\t\treturn GF_NOT_SUPPORTED;\n\t\t}\n\t\tgenm->dataReferenceIndex = dataRefIndex;\n\t\twrap_data = &genm->data;\n\t\twrap_size = &genm->data_size;\n\t\te = gf_list_add(trak->Media->information->sampleTable->SampleDescription->child_boxes, genm);\n\t}\n\t*outDescriptionIndex = gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes);\n\n\tif (udesc->extension_buf && udesc->extension_buf_size) {\n\t\tGF_BitStream *bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\tif (udesc->ext_box_wrap) {\n\t\t\tgf_bs_write_u32(bs, 8+udesc->extension_buf_size);\n\t\t\tgf_bs_write_u32(bs, udesc->ext_box_wrap);\n\t\t}\n\t\tgf_bs_write_data(bs, udesc->extension_buf, udesc->extension_buf_size);\n\t\tgf_bs_get_content(bs, wrap_data, wrap_size);\n\t\tgf_bs_del(bs);\n\t}\n\treturn e;\n}\n\n//use carefully. Very useful when you made a lot of changes (IPMP, IPI, OCI, ...)\n//THIS WILL REPLACE THE WHOLE DESCRIPTOR ...\n#if 0 //unused\n/*change the data field of an unknown sample description*/\nGF_Err gf_isom_change_generic_sample_description(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, GF_GenericSampleDescription *udesc)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tGF_GenericVisualSampleEntryBox *entry;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media || !StreamDescriptionIndex) return GF_BAD_PARAM;\n\n\tentry = (GF_GenericVisualSampleEntryBox *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, StreamDescriptionIndex-1);\n\tif (!entry) return GF_BAD_PARAM;\n\tif (entry->type == GF_ISOM_BOX_TYPE_GNRV) {\n\t\tentry->vendor = udesc->vendor_code;\n\t\tentry->version = udesc->version;\n\t\tentry->revision = udesc->revision;\n\t\tentry->temporal_quality = udesc->temporal_quality;\n\t\tentry->spatial_quality = udesc->spatial_quality;\n\t\tentry->Width = udesc->width;\n\t\tentry->Height = udesc->height;\n\t\tstrcpy(entry->compressor_name, udesc->compressor_name);\n\t\tentry->color_table_index = -1;\n\t\tentry->frames_per_sample = 1;\n\t\tentry->horiz_res = udesc->h_res ? udesc->h_res : 0x00480000;\n\t\tentry->vert_res = udesc->v_res ? udesc->v_res : 0x00480000;\n\t\tentry->bit_depth = udesc->depth ? udesc->depth : 0x18;\n\t\tif (entry->data) gf_free(entry->data);\n\t\tentry->data = NULL;\n\t\tentry->data_size = 0;\n\t\tif (udesc->extension_buf && udesc->extension_buf_size) {\n\t\t\tentry->data = (char*)gf_malloc(sizeof(char) * udesc->extension_buf_size);\n\t\t\tif (!entry->data) {\n\t\t\t\tgf_isom_box_del((GF_Box *) entry);\n\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t}\n\t\t\tmemcpy(entry->data, udesc->extension_buf, udesc->extension_buf_size);\n\t\t\tentry->data_size = udesc->extension_buf_size;\n\t\t}\n\t\treturn GF_OK;\n\t} else if (entry->type == GF_ISOM_BOX_TYPE_GNRA) {\n\t\tGF_GenericAudioSampleEntryBox *gena = (GF_GenericAudioSampleEntryBox *)entry;\n\t\tgena->vendor = udesc->vendor_code;\n\t\tgena->version = udesc->version;\n\t\tgena->revision = udesc->revision;\n\t\tgena->bitspersample = udesc->bits_per_sample ? udesc->bits_per_sample : 16;\n\t\tgena->channel_count = udesc->nb_channels ? udesc->nb_channels : 2;\n\t\tgena->samplerate_hi = udesc->samplerate;\n\t\tgena->samplerate_lo = 0;\n\t\tif (gena->data) gf_free(gena->data);\n\t\tgena->data = NULL;\n\t\tgena->data_size = 0;\n\n\t\tif (udesc->extension_buf && udesc->extension_buf_size) {\n\t\t\tgena->data = (char*)gf_malloc(sizeof(char) * udesc->extension_buf_size);\n\t\t\tif (!gena->data) {\n\t\t\t\tgf_isom_box_del((GF_Box *) gena);\n\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t}\n\t\t\tmemcpy(gena->data, udesc->extension_buf, udesc->extension_buf_size);\n\t\t\tgena->data_size = udesc->extension_buf_size;\n\t\t}\n\t\treturn GF_OK;\n\t} else if (entry->type == GF_ISOM_BOX_TYPE_GNRM) {\n\t\tGF_GenericSampleEntryBox *genm = (GF_GenericSampleEntryBox *)entry;\n\t\tif (genm->data) gf_free(genm->data);\n\t\tgenm->data = NULL;\n\t\tgenm->data_size = 0;\n\n\t\tif (udesc->extension_buf && udesc->extension_buf_size) {\n\t\t\tgenm->data = (char*)gf_malloc(sizeof(char) * udesc->extension_buf_size);\n\t\t\tif (!genm->data) {\n\t\t\t\tgf_isom_box_del((GF_Box *) genm);\n\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t}\n\t\t\tmemcpy(genm->data, udesc->extension_buf, udesc->extension_buf_size);\n\t\t\tgenm->data_size = udesc->extension_buf_size;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\treturn GF_BAD_PARAM;\n}\n#endif\n\n#if 0\n/*removes given stream description*/\nGF_Err gf_isom_remove_sample_description(GF_ISOFile *movie, u32 trackNumber, u32 streamDescIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tGF_Box *entry;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media || !streamDescIndex) return GF_BAD_PARAM;\n\tentry = (GF_Box*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, streamDescIndex-1);\n\tif (!entry) return GF_BAD_PARAM;\n\tgf_list_rem(trak->Media->information->sampleTable->SampleDescription->child_boxes, streamDescIndex-1);\n\tgf_isom_box_del(entry);\n\treturn GF_OK;\n}\n#endif\n\n//sets a track reference\nGF_EXPORT\nGF_Err gf_isom_set_track_reference(GF_ISOFile *the_file, u32 trackNumber, u32 referenceType, GF_ISOTrackID ReferencedTrackID)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_TrackReferenceBox *tref;\n\tGF_TrackReferenceTypeBox *dpnd;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\t//no tref, create one\n\ttref = trak->References;\n\tif (!tref) {\n\t\ttref = (GF_TrackReferenceBox *) gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_TREF);\n\t\tif (!tref) return GF_OUT_OF_MEM;\n\t\te = trak_on_child_box((GF_Box*)trak, (GF_Box *) tref, GF_FALSE);\n\t\tif (e) return e;\n\t}\n\t//find a ref of the given type\n\te = Track_FindRef(trak, referenceType, &dpnd);\n\tif (e) return e;\n\n\tif (!dpnd) {\n\t\tdpnd = (GF_TrackReferenceTypeBox *) gf_isom_box_new_parent(&tref->child_boxes, GF_ISOM_BOX_TYPE_REFT);\n\t\tif (!dpnd) return GF_OUT_OF_MEM;\n\t\tdpnd->reference_type = referenceType;\n\t}\n\t//add the ref\n\treturn reftype_AddRefTrack(dpnd, ReferencedTrackID, NULL);\n}\n\nGF_EXPORT\nGF_Err gf_isom_purge_track_reference(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\tGF_TrackReferenceTypeBox *ref;\n\tu32 i=0;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\t//no tref, nothing to remove\n\tif (!trak->References) return GF_OK;\n\n\twhile ((ref = gf_list_enum(trak->References->child_boxes, &i))) {\n\t\tu32 k;\n\t\tif (!ref->reference_type) continue;\n\n\t\tfor (k=0; k<ref->trackIDCount; k++) {\n\t\t\tu32 tk = gf_isom_get_track_by_id(the_file, ref->trackIDs[k]);\n\t\t\tif (!tk) {\n\t\t\t\tmemmove(&ref->trackIDs[k], &ref->trackIDs[k+1], ref->trackIDCount-k-1);\n\t\t\t\tk--;\n\t\t\t\tref->trackIDCount--;\n\t\t\t}\n\t\t}\n\t\tif (!ref->trackIDCount) {\n\t\t\ti--;\n\t\t\tgf_isom_box_del_parent(&trak->References->child_boxes, (GF_Box *) ref);\n\t\t}\n\t}\n\tif (!trak->References->child_boxes || !gf_list_count(trak->References->child_boxes)) {\n\t\tgf_isom_box_del_parent(&trak->child_boxes, (GF_Box *) trak->References);\n\t\ttrak->References = NULL;\n\t}\n\treturn GF_OK;\n}\n\n//sets a track reference\nGF_EXPORT\nGF_Err gf_isom_remove_track_references(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tif (trak->References) {\n\t\tgf_isom_box_del_parent(&trak->child_boxes, (GF_Box *)trak->References);\n\t\ttrak->References = NULL;\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_remove_track_reference(GF_ISOFile *isom_file, u32 trackNumber, u32 ref_type)\n{\n\tGF_TrackBox *trak;\n\tu32 i=0;\n\tGF_TrackReferenceTypeBox *ref;\n\ttrak = gf_isom_get_track_from_file(isom_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tif (!trak->References) return GF_OK;\n\twhile ((ref = gf_list_enum(trak->References->child_boxes, &i))) {\n\t\tif (ref->reference_type == ref_type) {\n\t\t\tgf_isom_box_del_parent(&trak->References->child_boxes, (GF_Box *)ref);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!gf_list_count(trak->References->child_boxes)) {\n\t\tgf_isom_box_del_parent(&trak->child_boxes, (GF_Box *)trak->References);\n\t\ttrak->References = NULL;\n\t}\n\treturn GF_OK;\n\n}\n\n//changes track ID\nGF_EXPORT\nGF_Err gf_isom_set_track_id(GF_ISOFile *movie, u32 trackNumber, GF_ISOTrackID trackID)\n{\n\tGF_TrackReferenceTypeBox *ref;\n\tGF_TrackBox *trak, *a_trak;\n\tu32 i, j, k;\n\n\tif (!movie) return GF_BAD_PARAM;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (trak && (trak->Header->trackID==trackID)) return GF_OK;\n\ta_trak = gf_isom_get_track_from_id(movie->moov, trackID);\n\tif (!trak || a_trak) return GF_BAD_PARAM;\n\n\t/*rewrite all dependencies*/\n\ti=0;\n\twhile ((a_trak = (GF_TrackBox*)gf_list_enum(movie->moov->trackList, &i))) {\n\t\tif (!a_trak->References) continue;\n\t\tj=0;\n\t\twhile ((ref = (GF_TrackReferenceTypeBox *)gf_list_enum(a_trak->References->child_boxes, &j))) {\n\t\t\tfor (k=0; k<ref->trackIDCount; k++) {\n\t\t\t\tif (ref->trackIDs[k]==trak->Header->trackID) {\n\t\t\t\t\tref->trackIDs[k] = trackID;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/*and update IOD if any*/\n\tif (movie->moov->iods && movie->moov->iods->descriptor) {\n\t\tGF_ES_ID_Inc *inc;\n\t\tGF_IsomObjectDescriptor *od = (GF_IsomObjectDescriptor *)movie->moov->iods->descriptor;\n\n\t\ti=0;\n\t\twhile ((inc = (GF_ES_ID_Inc*)gf_list_enum(od->ES_ID_IncDescriptors, &i))) {\n\t\t\tif (inc->trackID==trak->Header->trackID) inc->trackID = trackID;\n\t\t}\n\t}\n\ttrak->Header->trackID = trackID;\n\tupdate_next_track_id(movie);\n\treturn GF_OK;\n}\n\n/*force to rewrite all dependencies when the trackID of referenced track changes*/\nGF_EXPORT\nGF_Err gf_isom_rewrite_track_dependencies(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_TrackReferenceTypeBox *ref;\n\tGF_TrackBox *trak, *a_trak;\n\tu32 i, k;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak)\n\t\treturn GF_BAD_PARAM;\n\tif (!trak->References)\n\t\treturn GF_OK;\n\n\ti=0;\n\twhile ((ref = (GF_TrackReferenceTypeBox *)gf_list_enum(trak->References->child_boxes, &i))) {\n\t\tfor (k=0; k < ref->trackIDCount; k++) {\n\t\t\ta_trak = gf_isom_get_track_from_original_id(movie->moov, ref->trackIDs[k], trak->originalFile);\n\t\t\tif (a_trak) {\n\t\t\t\tref->trackIDs[k] = a_trak->Header->trackID;\n\t\t\t} else {\n\t\t\t\ta_trak = gf_isom_get_track_from_id(movie->moov, ref->trackIDs[k]);\n\t\t\t\t/*we should have a track with no original ID (not imported) - should we rewrite the dependency ?*/\n\t\t\t\tif (! a_trak || a_trak->originalID) return GF_BAD_PARAM;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn GF_OK;\n}\n\n#if 0 //unused\n\n/*! changes the sample description index of a sample\n\\param isom_file the destination ISO file\n\\param trackNumber the destination track\n\\param sampleNum the target sample number\n\\param fnewSampleDescIndex the new sample description index to assign to the sample\n\\return error if any\n*/\nGF_EXPORT\nGF_Err gf_isom_change_sample_desc_index(GF_ISOFile *the_file, u32 trackNumber, u32 sample_number, u32 newSampleDescIndex)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !sample_number || !newSampleDescIndex) return GF_BAD_PARAM;\n\tif (!trak->is_unpacked) {\n\t\tunpack_track(trak);\n\t}\n\tif (!trak->Media->information->sampleTable->SampleToChunk) return GF_BAD_PARAM;\n\tif (trak->Media->information->sampleTable->SampleToChunk->nb_entries < sample_number) return GF_BAD_PARAM;\n\ttrak->Media->information->sampleTable->SampleToChunk->entries[sample_number-1].sampleDescriptionIndex = newSampleDescIndex;\n\treturn GF_OK;\n}\n\n/*modify CTS offset of a given sample (used for B-frames) - MUST be called in unpack mode only*/\nGF_EXPORT\nGF_Err gf_isom_modify_cts_offset(GF_ISOFile *the_file, u32 trackNumber, u32 sample_number, u32 offset)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\tif (!trak->Media->information->sampleTable->CompositionOffset) return GF_BAD_PARAM;\n\tif (!trak->Media->information->sampleTable->CompositionOffset->unpack_mode) return GF_BAD_PARAM;\n\t/*we're in unpack mode: one entry per sample*/\n\ttrak->Media->information->sampleTable->CompositionOffset->entries[sample_number - 1].decodingOffset = offset;\n\treturn GF_OK;\n}\n#endif\n\nGF_EXPORT\nGF_Err gf_isom_shift_cts_offset(GF_ISOFile *the_file, u32 trackNumber, s32 offset_shift)\n{\n\tu32 i;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\tif (!trak->Media->information->sampleTable->CompositionOffset) return GF_BAD_PARAM;\n\tif (!trak->Media->information->sampleTable->CompositionOffset->unpack_mode) return GF_BAD_PARAM;\n\n\tGF_CompositionOffsetBox *ctso = trak->Media->information->sampleTable->CompositionOffset;\n\tfor (i=0; i<ctso->nb_entries; i++) {\n\t\ts64 new_ts = ctso->entries[i].decodingOffset;\n\t\tnew_ts -= offset_shift;\n\t\t/*we're in unpack mode: one entry per sample*/\n\t\tctso->entries[i].decodingOffset = (s32) new_ts;\n\t}\n\tif (trak->Media->mediaHeader->duration >= -offset_shift) {\n\t\ts64 new_dur = trak->Media->mediaHeader->duration;\n\t\tnew_dur -= offset_shift;\n\t\tif (new_dur<0) new_dur = 0;\n\t\ttrak->Media->mediaHeader->duration = (u32) new_dur;\n\t}\n\treturn GF_OK;\n}\n\n#if 0 //unused\nGF_Err gf_isom_remove_cts_info(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_SampleTableBox *stbl;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstbl = trak->Media->information->sampleTable;\n\tif (!stbl->CompositionOffset) return GF_OK;\n\n\tgf_isom_box_del_parent(&stbl->child_boxes, (GF_Box *)stbl->CompositionOffset);\n\tstbl->CompositionOffset = NULL;\n\treturn GF_OK;\n}\n#endif\n\nGF_EXPORT\nGF_Err gf_isom_set_cts_packing(GF_ISOFile *the_file, u32 trackNumber, Bool unpack)\n{\n\tGF_Err e;\n\tGF_Err stbl_repackCTS(GF_CompositionOffsetBox *ctts);\n\tGF_Err stbl_unpackCTS(GF_SampleTableBox *stbl);\n\tGF_SampleTableBox *stbl;\n\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstbl = trak->Media->information->sampleTable;\n\tif (unpack) {\n\t\tif (!stbl->CompositionOffset) {\n\t\t\tstbl->CompositionOffset = (GF_CompositionOffsetBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_CTTS);\n\t\t\tif (!stbl->CompositionOffset) return GF_OUT_OF_MEM;\n\t\t}\n\t\te = stbl_unpackCTS(stbl);\n\t} else {\n\t\tif (!stbl->CompositionOffset) return GF_OK;\n\t\te = stbl_repackCTS(stbl->CompositionOffset);\n\t}\n\tif (e) return e;\n\treturn SetTrackDuration(trak);\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_track_matrix(GF_ISOFile *the_file, u32 trackNumber, s32 matrix[9])\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Header) return GF_BAD_PARAM;\n\tmemcpy(trak->Header->matrix, matrix, sizeof(trak->Header->matrix));\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_track_layout_info(GF_ISOFile *the_file, u32 trackNumber, u32 width, u32 height, s32 translation_x, s32 translation_y, s16 layer)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Header) return GF_BAD_PARAM;\n\ttrak->Header->width = width;\n\ttrak->Header->height = height;\n\ttrak->Header->matrix[6] = translation_x;\n\ttrak->Header->matrix[7] = translation_y;\n\ttrak->Header->layer = layer;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_media_timescale(GF_ISOFile *the_file, u32 trackNumber, u32 newTS, u32 new_tsinc, u32 force_rescale_type)\n{\n\tDouble scale;\n\tu32 old_ts_inc=0;\n\tu32 old_timescale;\n\tGF_TrackBox *trak;\n\tGF_SampleTableBox *stbl;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->mediaHeader) return GF_BAD_PARAM;\n\tif ((trak->Media->mediaHeader->timeScale==newTS) && !new_tsinc)\n\t\treturn GF_EOS;\n\n\tif (!newTS) newTS = trak->Media->mediaHeader->timeScale;\n\tscale = newTS;\n\tscale /= trak->Media->mediaHeader->timeScale;\n\told_timescale = trak->Media->mediaHeader->timeScale;\n\ttrak->Media->mediaHeader->timeScale = newTS;\n\n\tstbl = trak->Media->information->sampleTable;\n\tif (new_tsinc) {\n\t\tu32 i;\n\t\tif (!stbl->TimeToSample || !stbl->TimeToSample->nb_entries)\n\t\t\treturn GF_BAD_PARAM;\n\n\t\tfor (i=0; i<stbl->TimeToSample->nb_entries; i++) {\n\t\t\tif (!old_ts_inc)\n\t\t\t\told_ts_inc = stbl->TimeToSample->entries[i].sampleDelta;\n\t\t\telse if (old_ts_inc<stbl->TimeToSample->entries[i].sampleDelta)\n\t\t\t\told_ts_inc = stbl->TimeToSample->entries[i].sampleDelta;\n\t\t}\n\n\t\tif ((old_timescale==newTS) && (old_ts_inc==new_tsinc) && (force_rescale_type!=2) )\n\t\t\treturn GF_EOS;\n\n\t\tif (!force_rescale_type)\n\t\t\tforce_rescale_type = 1;\n\t\telse if (force_rescale_type==2) {\n\t\t\tgf_free(stbl->TimeToSample->entries);\n\t\t\tstbl->TimeToSample->alloc_size = 1;\n\t\t\tstbl->TimeToSample->nb_entries = 1;\n\t\t\tstbl->TimeToSample->entries = gf_malloc(sizeof(GF_SttsEntry));\n\t\t\tstbl->TimeToSample->entries[0].sampleDelta = new_tsinc;\n\t\t\tstbl->TimeToSample->entries[0].sampleCount = stbl->SampleSize->sampleCount;\n\t\t}\n\n\n\t\tfor (i=0; i<stbl->TimeToSample->nb_entries; i++) {\n\t\t\tstbl->TimeToSample->entries[i].sampleDelta = new_tsinc;\n\t\t}\n\n\t\tif (stbl->CompositionOffset) {\n\t\t\tfor (i=0; i<stbl->CompositionOffset->nb_entries; i++) {\n\t\t\t\tu32 old_offset = stbl->CompositionOffset->entries[i].decodingOffset;\n\t\t\t\tif (force_rescale_type==2) {\n\t\t\t\t\tu32 val = old_offset ;\n\t\t\t\t\t//get number of TS delta\n\t\t\t\t\told_offset /= old_ts_inc;\n\t\t\t\t\tif (old_offset * old_ts_inc < val)\n\t\t\t\t\t\told_offset++;\n\t\t\t\t\told_offset *= new_tsinc;\n\t\t\t\t} else {\n\t\t\t\t\told_offset *= new_tsinc;\n\t\t\t\t\told_offset /= old_ts_inc;\n\t\t\t\t}\n\t\t\t\tstbl->CompositionOffset->entries[i].decodingOffset = old_offset;\n\t\t\t}\n\t\t}\n\n#define RESCALE_TSVAL(_tsval) {\\\n\t\t\ts64 val = ((s64) _tsval) * new_tsinc;\\\n\t\t\tval /= old_ts_inc;\\\n\t\t\t_tsval = (s32) val;\\\n\t\t}\n\n\t\tif (stbl->CompositionToDecode) {\n\t\t\tRESCALE_TSVAL(stbl->CompositionToDecode->compositionEndTime)\n\t\t\tRESCALE_TSVAL(stbl->CompositionToDecode->compositionStartTime)\n\t\t\tRESCALE_TSVAL(stbl->CompositionToDecode->compositionToDTSShift)\n\t\t\tRESCALE_TSVAL(stbl->CompositionToDecode->greatestDecodeToDisplayDelta)\n\t\t\tRESCALE_TSVAL(stbl->CompositionToDecode->leastDecodeToDisplayDelta)\n\t\t}\n\t\tif (trak->editBox) {\n\t\t\tGF_EdtsEntry *ent;\n\t\t\ti=0;\n\t\t\twhile ((ent = (GF_EdtsEntry*)gf_list_enum(trak->editBox->editList->entryList, &i))) {\n\t\t\t\tRESCALE_TSVAL(ent->mediaTime)\n\t\t\t}\n\t\t}\n#undef RESCALE_TSVAL\n\t\t//force recompute of duration\n\t\ttrak->Media->mediaHeader->duration=0;\n\t\treturn SetTrackDuration(trak);\n\t}\n\n\t//rescale timings\n\tu32 i, k, idx, last_delta;\n\tu64 cur_dts;\n\tu64*DTSs = NULL;\n\ts64*CTSs = NULL;\n\n\tif (trak->editBox) {\n\t\tGF_EdtsEntry *ent;\n\t\ti=0;\n\t\twhile ((ent = (GF_EdtsEntry*)gf_list_enum(trak->editBox->editList->entryList, &i))) {\n\t\t\t//only update if media time is >=0 (neg means empty edit)\n\t\t\tif (ent->mediaTime>=0)\n\t\t\t\tent->mediaTime = (u32) (scale*ent->mediaTime);\n\t\t}\n\t}\n\tif (! stbl || !stbl->TimeToSample || !stbl->TimeToSample->nb_entries) {\n\t\treturn SetTrackDuration(trak);\n\t}\n\n\tidx = 0;\n\tcur_dts = 0;\n\t//unpack the DTSs\n\tDTSs = (u64*)gf_malloc(sizeof(u64) * (stbl->SampleSize->sampleCount) );\n\tif (!DTSs) return GF_OUT_OF_MEM;\n\n\tCTSs = NULL;\n\tif (stbl->CompositionOffset) {\n\t\tCTSs = (s64*)gf_malloc(sizeof(u64) * (stbl->SampleSize->sampleCount) );\n\t\tif (!CTSs) return GF_OUT_OF_MEM;\n\t}\n\n\tfor (i=0; i<stbl->TimeToSample->nb_entries; i++) {\n\t\tfor (k=0; k<stbl->TimeToSample->entries[i].sampleCount; k++) {\n\t\t\tcur_dts += stbl->TimeToSample->entries[i].sampleDelta;\n\t\t\tDTSs[idx] = (u64) (cur_dts * scale);\n\n\t\t\tif (stbl->CompositionOffset) {\n\t\t\t\ts32 cts_o;\n\t\t\t\tstbl_GetSampleCTS(stbl->CompositionOffset, idx+1, &cts_o);\n\t\t\t\tCTSs[idx] = (s64) ( ((s64) cur_dts + cts_o) * scale);\n\t\t\t}\n\t\t\tidx++;\n\t\t}\n\t}\n\tlast_delta = (u32) (stbl->TimeToSample->entries[stbl->TimeToSample->nb_entries-1].sampleDelta * scale);\n\n\t//repack DTS\n\tif (stbl->SampleSize->sampleCount) {\n\t\tstbl->TimeToSample->entries = gf_realloc(stbl->TimeToSample->entries, sizeof(GF_SttsEntry)*stbl->SampleSize->sampleCount);\n\t\tmemset(stbl->TimeToSample->entries, 0, sizeof(GF_SttsEntry)*stbl->SampleSize->sampleCount);\n\t\tstbl->TimeToSample->entries[0].sampleDelta = (u32) DTSs[0];\n\t\tstbl->TimeToSample->entries[0].sampleCount = 1;\n\t\tidx=0;\n\t\tfor (i=1; i< stbl->SampleSize->sampleCount - 1; i++) {\n\t\t\tif (DTSs[i+1] - DTSs[i] == stbl->TimeToSample->entries[idx].sampleDelta) {\n\t\t\t\tstbl->TimeToSample->entries[idx].sampleCount++;\n\t\t\t} else {\n\t\t\t\tidx++;\n\t\t\t\tstbl->TimeToSample->entries[idx].sampleDelta = (u32) ( DTSs[i+1] - DTSs[i] );\n\t\t\t\tstbl->TimeToSample->entries[idx].sampleCount=1;\n\t\t\t}\n\t\t}\n\t\tif (stbl->SampleSize->sampleCount > 1) {\n\t\t\t//add the sample delta for the last sample\n\t\t\tif (stbl->TimeToSample->entries[idx].sampleDelta == last_delta) {\n\t\t\t\tstbl->TimeToSample->entries[idx].sampleCount++;\n\t\t\t} else {\n\t\t\t\tidx++;\n\t\t\t\tstbl->TimeToSample->entries[idx].sampleDelta = last_delta;\n\t\t\t\tstbl->TimeToSample->entries[idx].sampleCount=1;\n\t\t\t}\n\n\t\t\tstbl->TimeToSample->nb_entries = idx+1;\n\t\t\tstbl->TimeToSample->entries = gf_realloc(stbl->TimeToSample->entries, sizeof(GF_SttsEntry)*stbl->TimeToSample->nb_entries);\n\t\t}\n\t}\n\n\tif (CTSs && stbl->SampleSize->sampleCount>0) {\n\t\t//repack CTS\n\t\tstbl->CompositionOffset->entries = gf_realloc(stbl->CompositionOffset->entries, sizeof(GF_DttsEntry)*stbl->SampleSize->sampleCount);\n\t\tmemset(stbl->CompositionOffset->entries, 0, sizeof(GF_DttsEntry)*stbl->SampleSize->sampleCount);\n\t\tstbl->CompositionOffset->entries[0].decodingOffset = (s32) (CTSs[0] - DTSs[0]);\n\t\tstbl->CompositionOffset->entries[0].sampleCount = 1;\n\t\tidx=0;\n\t\tfor (i=1; i< stbl->SampleSize->sampleCount; i++) {\n\t\t\ts32 cts_o = (s32) (CTSs[i] - DTSs[i]);\n\t\t\tif (cts_o == stbl->CompositionOffset->entries[idx].decodingOffset) {\n\t\t\t\tstbl->CompositionOffset->entries[idx].sampleCount++;\n\t\t\t} else {\n\t\t\t\tidx++;\n\t\t\t\tstbl->CompositionOffset->entries[idx].decodingOffset = cts_o;\n\t\t\t\tstbl->CompositionOffset->entries[idx].sampleCount=1;\n\t\t\t}\n\t\t}\n\t\tstbl->CompositionOffset->nb_entries = idx+1;\n\t\tstbl->CompositionOffset->entries = gf_realloc(stbl->CompositionOffset->entries, sizeof(GF_DttsEntry)*stbl->CompositionOffset->nb_entries);\n\n\t\tgf_free(CTSs);\n\t}\n\tgf_free(DTSs);\n\n\tif (stbl->CompositionToDecode) {\n\t\tstbl->CompositionToDecode->compositionEndTime = (s32) (stbl->CompositionToDecode->compositionEndTime * scale);\n\t\tstbl->CompositionToDecode->compositionStartTime = (s32)(stbl->CompositionToDecode->compositionStartTime * scale);\n\t\tstbl->CompositionToDecode->compositionToDTSShift = (s32)(stbl->CompositionToDecode->compositionToDTSShift * scale);\n\t\tstbl->CompositionToDecode->greatestDecodeToDisplayDelta = (s32)(stbl->CompositionToDecode->greatestDecodeToDisplayDelta * scale);\n\t\tstbl->CompositionToDecode->leastDecodeToDisplayDelta = (s32)(stbl->CompositionToDecode->leastDecodeToDisplayDelta * scale);\n\t}\n\n\treturn SetTrackDuration(trak);\n}\n\nGF_EXPORT\nBool gf_isom_box_equal(GF_Box *a, GF_Box *b)\n{\n\tBool ret;\n\tu8 *data1, *data2;\n\tu32 data1_size, data2_size;\n\tGF_BitStream *bs;\n\n\tif (a == b) return GF_TRUE;\n\tif (!a || !b) return GF_FALSE;\n\n\tdata1 = data2 = NULL;\n\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tgf_isom_box_size(a);\n\tgf_isom_box_write(a, bs);\n\tgf_bs_get_content(bs, &data1, &data1_size);\n\tgf_bs_del(bs);\n\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tgf_isom_box_size(b);\n\tgf_isom_box_write(b, bs);\n\tgf_bs_get_content(bs, &data2, &data2_size);\n\tgf_bs_del(bs);\n\n\tret = GF_FALSE;\n\tif (data1_size == data2_size) {\n\t\tret = (memcmp(data1, data2, sizeof(char)*data1_size) == 0) ? GF_TRUE : GF_FALSE;\n\t}\n\tgf_free(data1);\n\tgf_free(data2);\n\treturn ret;\n}\n\nstatic u32 base_sample_entry_type(u32 type)\n{\n\tif (type==GF_ISOM_SUBTYPE_DVH1) return GF_ISOM_SUBTYPE_HVC1;\n\tif (type==GF_ISOM_SUBTYPE_DVHE) return GF_ISOM_SUBTYPE_HEV1;\n\tif (type==GF_ISOM_SUBTYPE_DVA1) return GF_ISOM_SUBTYPE_AVC_H264;\n\tif (type==GF_ISOM_SUBTYPE_DVAV) return GF_ISOM_SUBTYPE_AVC3_H264;\n\tif (type==GF_ISOM_SUBTYPE_DAV1) return GF_ISOM_SUBTYPE_AV01;\n\treturn type;\n}\n\nGF_EXPORT\nBool gf_isom_is_same_sample_description(GF_ISOFile *f1, u32 tk1, u32 sdesc_index1, GF_ISOFile *f2, u32 tk2, u32 sdesc_index2)\n{\n\tu32 i, count;\n\tGF_TrackBox *trak1, *trak2;\n\tGF_ESD *esd1, *esd2;\n\tBool need_memcmp, ret;\n\tGF_Box *a, *b;\n\n\t/*get orig sample desc and clone it*/\n\ttrak1 = gf_isom_get_track_from_file(f1, tk1);\n\tif (!trak1 || !trak1->Media) return GF_FALSE;\n\ttrak2 = gf_isom_get_track_from_file(f2, tk2);\n\tif (!trak2 || !trak2->Media) return GF_FALSE;\n\n\tif (trak1->Media->handler->handlerType != trak2->Media->handler->handlerType) return GF_FALSE;\n\tcount = gf_list_count(trak1->Media->information->sampleTable->SampleDescription->child_boxes);\n\tif (count != gf_list_count(trak2->Media->information->sampleTable->SampleDescription->child_boxes)) {\n\t\tif (!sdesc_index1 && !sdesc_index2) return GF_FALSE;\n\t}\n\n\tneed_memcmp = GF_TRUE;\n\tfor (i=0; i<count; i++) {\n\t\tu32 type1, type2;\n\t\tGF_SampleEntryBox *ent1 = (GF_SampleEntryBox *)gf_list_get(trak1->Media->information->sampleTable->SampleDescription->child_boxes, i);\n\t\tGF_SampleEntryBox *ent2 = (GF_SampleEntryBox *)gf_list_get(trak2->Media->information->sampleTable->SampleDescription->child_boxes, i);\n\n\t\tif (sdesc_index1) ent1 = (GF_SampleEntryBox *)gf_list_get(trak1->Media->information->sampleTable->SampleDescription->child_boxes, sdesc_index1 - 1);\n\t\tif (sdesc_index2) ent2 = (GF_SampleEntryBox *)gf_list_get(trak2->Media->information->sampleTable->SampleDescription->child_boxes, sdesc_index2 - 1);\n\n\t\tif (!ent1 || !ent2) return GF_FALSE;\n\t\tif (ent1->internal_type != ent2->internal_type) return GF_FALSE;\n\t\ttype1 = base_sample_entry_type(ent1->type);\n\t\ttype2 = base_sample_entry_type(ent2->type);\n\t\tif (type1 != type2) return GF_FALSE;\n\n\t\tswitch (ent1->type) {\n\t\t/*for MPEG-4 streams, only compare decSpecInfo (bitrate may not be the same but that's not an issue)*/\n\t\tcase GF_ISOM_BOX_TYPE_MP4S:\n\t\tcase GF_ISOM_BOX_TYPE_MP4A:\n\t\tcase GF_ISOM_BOX_TYPE_MP4V:\n\t\tcase GF_ISOM_BOX_TYPE_ENCA:\n\t\tcase GF_ISOM_BOX_TYPE_ENCV:\n\t\tcase GF_ISOM_BOX_TYPE_RESV:\n\t\tcase GF_ISOM_BOX_TYPE_ENCS:\n\t\t\tMedia_GetESD(trak1->Media, sdesc_index1 ? sdesc_index1 : i+1, &esd1, GF_TRUE);\n\t\t\tMedia_GetESD(trak2->Media, sdesc_index2 ? sdesc_index2 : i+1, &esd2, GF_TRUE);\n\t\t\tif (!esd1 || !esd2) continue;\n\t\t\tneed_memcmp = GF_FALSE;\n\t\t\tif (esd1->decoderConfig->streamType != esd2->decoderConfig->streamType) return GF_FALSE;\n\t\t\tif (esd1->decoderConfig->objectTypeIndication != esd2->decoderConfig->objectTypeIndication) return GF_FALSE;\n\t\t\tif (!esd1->decoderConfig->decoderSpecificInfo && esd2->decoderConfig->decoderSpecificInfo) return GF_FALSE;\n\t\t\tif (esd1->decoderConfig->decoderSpecificInfo && !esd2->decoderConfig->decoderSpecificInfo) return GF_FALSE;\n\t\t\tif (!esd1->decoderConfig->decoderSpecificInfo || !esd2->decoderConfig->decoderSpecificInfo) continue;\n\t\t\tif (esd1->decoderConfig->decoderSpecificInfo->dataLength != esd2->decoderConfig->decoderSpecificInfo->dataLength)\n\t\t\t\treturn GF_FALSE;\n\t\t\tif (memcmp(esd1->decoderConfig->decoderSpecificInfo->data, esd2->decoderConfig->decoderSpecificInfo->data, sizeof(char)*esd1->decoderConfig->decoderSpecificInfo->dataLength)!=0) return GF_FALSE;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_HVT1:\n\t\t\treturn GF_TRUE;\n\t\tcase GF_ISOM_BOX_TYPE_AVC1:\n\t\tcase GF_ISOM_BOX_TYPE_AVC2:\n\t\tcase GF_ISOM_BOX_TYPE_AVC3:\n\t\tcase GF_ISOM_BOX_TYPE_AVC4:\n\t\tcase GF_ISOM_BOX_TYPE_SVC1:\n\t\tcase GF_ISOM_BOX_TYPE_MVC1:\n\t\tcase GF_ISOM_BOX_TYPE_HVC1:\n\t\tcase GF_ISOM_BOX_TYPE_HEV1:\n\t\tcase GF_ISOM_BOX_TYPE_HVC2:\n\t\tcase GF_ISOM_BOX_TYPE_HEV2:\n\t\tcase GF_ISOM_BOX_TYPE_LHE1:\n\t\tcase GF_ISOM_BOX_TYPE_LHV1:\n\t\tcase GF_ISOM_BOX_TYPE_AV01:\n\t\tcase GF_ISOM_BOX_TYPE_VVC1:\n\t\tcase GF_ISOM_BOX_TYPE_VVI1:\n\t\tcase GF_ISOM_BOX_TYPE_DVHE:\n\t\tcase GF_ISOM_BOX_TYPE_DVH1:\n\t\tcase GF_ISOM_BOX_TYPE_DVA1:\n\t\tcase GF_ISOM_BOX_TYPE_DVAV:\n\t\tcase GF_ISOM_BOX_TYPE_DAV1:\n\t\t{\n\t\t\tGF_MPEGVisualSampleEntryBox *avc1 = (GF_MPEGVisualSampleEntryBox *)ent1;\n\t\t\tGF_MPEGVisualSampleEntryBox *avc2 = (GF_MPEGVisualSampleEntryBox *)ent2;\n\n\t\t\tif (avc1->hevc_config)\n\t\t\t\ta = (GF_Box *) avc1->hevc_config;\n\t\t\telse if (avc1->lhvc_config)\n\t\t\t\ta = (GF_Box *) avc1->lhvc_config;\n\t\t\telse if (avc1->svc_config)\n\t\t\t\ta = (GF_Box *) avc1->svc_config;\n\t\t\telse if (avc1->mvc_config)\n\t\t\t\ta = (GF_Box *) avc1->mvc_config;\n\t\t\telse if (avc1->av1_config)\n\t\t\t\ta = (GF_Box *)avc1->av1_config;\n\t\t\telse\n\t\t\t\ta = (GF_Box *) avc1->avc_config;\n\n\t\t\tif (avc2->hevc_config)\n\t\t\t\tb = (GF_Box *) avc2->hevc_config;\n\t\t\telse if (avc2->lhvc_config)\n\t\t\t\tb = (GF_Box *) avc2->lhvc_config;\n\t\t\telse if (avc2->svc_config)\n\t\t\t\tb = (GF_Box *) avc2->svc_config;\n\t\t\telse if (avc2->mvc_config)\n\t\t\t\tb = (GF_Box *) avc2->mvc_config;\n\t\t\telse if (avc2->av1_config)\n\t\t\t\tb = (GF_Box *)avc2->av1_config;\n\t\t\telse\n\t\t\t\tb = (GF_Box *) avc2->avc_config;\n\n\t\t\treturn gf_isom_box_equal(a,b);\n\t\t}\n\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_LSR1:\n\t\t{\n\t\t\tGF_LASeRSampleEntryBox *lsr1 = (GF_LASeRSampleEntryBox *)ent1;\n\t\t\tGF_LASeRSampleEntryBox *lsr2 = (GF_LASeRSampleEntryBox *)ent2;\n\t\t\tif (lsr1->lsr_config && lsr2->lsr_config\n\t\t\t        && lsr1->lsr_config->hdr && lsr2->lsr_config->hdr\n\t\t\t        && (lsr1->lsr_config->hdr_size==lsr2->lsr_config->hdr_size)\n\t\t\t        && !memcmp(lsr1->lsr_config->hdr, lsr2->lsr_config->hdr, lsr2->lsr_config->hdr_size)\n\t\t\t   ) {\n\t\t\t\treturn GF_TRUE;\n\t\t\t}\n\t\t\treturn GF_FALSE;\n\t\t}\n\t\tbreak;\n#ifndef GPAC_DISABLE_VTT\n\t\tcase GF_ISOM_BOX_TYPE_WVTT:\n\t\t{\n\t\t\tGF_WebVTTSampleEntryBox *wvtt1 = (GF_WebVTTSampleEntryBox *)ent1;\n\t\t\tGF_WebVTTSampleEntryBox *wvtt2 = (GF_WebVTTSampleEntryBox *)ent2;\n\t\t\tif (wvtt1->config && wvtt2->config &&\n\t\t\t        (wvtt1->config->string && wvtt2->config->string && !strcmp(wvtt1->config->string, wvtt2->config->string))) {\n\t\t\t\treturn GF_TRUE;\n\t\t\t}\n\t\t\treturn GF_FALSE;\n\t\t}\n\t\tbreak;\n#endif\n\t\tcase GF_ISOM_BOX_TYPE_STPP:\n\t\t{\n\t\t\tGF_MetaDataSampleEntryBox *stpp1 = (GF_MetaDataSampleEntryBox *)ent1;\n\t\t\tGF_MetaDataSampleEntryBox *stpp2 = (GF_MetaDataSampleEntryBox *)ent2;\n\t\t\tif (stpp1->xml_namespace && stpp2->xml_namespace && !strcmp(stpp1->xml_namespace, stpp2->xml_namespace)) {\n\t\t\t\treturn GF_TRUE;\n\t\t\t}\n\t\t\treturn GF_FALSE;\n\t\t}\n\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_SBTT:\n\t\t{\n\t\t\treturn GF_FALSE;\n\t\t}\n\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_STXT:\n\t\t{\n\t\t\tGF_MetaDataSampleEntryBox *stxt1 = (GF_MetaDataSampleEntryBox *)ent1;\n\t\t\tGF_MetaDataSampleEntryBox *stxt2 = (GF_MetaDataSampleEntryBox *)ent2;\n\t\t\tif (stxt1->mime_type && stxt2->mime_type &&\n\t\t\t        ( (!stxt1->config && !stxt2->config) ||\n\t\t\t          (stxt1->config && stxt2->config && stxt1->config->config && stxt2->config->config &&\n\t\t\t           !strcmp(stxt1->config->config, stxt2->config->config)))) {\n\t\t\t\treturn GF_TRUE;\n\t\t\t}\n\t\t\treturn GF_FALSE;\n\t\t}\n\t\tcase GF_ISOM_BOX_TYPE_MP3:\n\t\tcase GF_QT_SUBTYPE_RAW_AUD:\n\t\tcase GF_QT_SUBTYPE_TWOS:\n\t\tcase GF_QT_SUBTYPE_SOWT:\n\t\tcase GF_QT_SUBTYPE_FL32:\n\t\tcase GF_QT_SUBTYPE_FL64:\n\t\tcase GF_QT_SUBTYPE_IN24:\n\t\tcase GF_QT_SUBTYPE_IN32:\n\t\tcase GF_QT_SUBTYPE_ULAW:\n\t\tcase GF_QT_SUBTYPE_ALAW:\n\t\tcase GF_QT_SUBTYPE_ADPCM:\n\t\tcase GF_QT_SUBTYPE_IMA_ADPCM:\n\t\tcase GF_QT_SUBTYPE_DVCA:\n\t\tcase GF_QT_SUBTYPE_QDMC:\n\t\tcase GF_QT_SUBTYPE_QDMC2:\n\t\tcase GF_QT_SUBTYPE_QCELP:\n\t\tcase GF_QT_SUBTYPE_kMP3:\n\t\tcase GF_QT_SUBTYPE_APCH:\n\t\tcase GF_QT_SUBTYPE_APCO:\n\t\tcase GF_QT_SUBTYPE_APCN:\n\t\tcase GF_QT_SUBTYPE_APCS:\n\t\tcase GF_QT_SUBTYPE_AP4X:\n\t\tcase GF_QT_SUBTYPE_AP4H:\n\t\tcase GF_QT_SUBTYPE_RAW_VID:\n\t\tcase GF_QT_SUBTYPE_YUYV:\n\t\tcase GF_QT_SUBTYPE_UYVY:\n\t\tcase GF_QT_SUBTYPE_YUV444:\n\t\tcase GF_QT_SUBTYPE_YUVA444:\n\t\tcase GF_QT_SUBTYPE_YUV422_10:\n\t\tcase GF_QT_SUBTYPE_YUV444_10:\n\t\tcase GF_QT_SUBTYPE_YUV422_16:\n\t\tcase GF_QT_SUBTYPE_YUV420:\n\t\tcase GF_QT_SUBTYPE_I420:\n\t\tcase GF_QT_SUBTYPE_IYUV:\n\t\tcase GF_QT_SUBTYPE_YV12:\n\t\tcase GF_QT_SUBTYPE_YVYU:\n\t\tcase GF_QT_SUBTYPE_RGBA:\n\t\tcase GF_QT_SUBTYPE_ABGR:\n\t\tdefault:\n\t\t\tif (ent1->internal_type == GF_ISOM_SAMPLE_ENTRY_VIDEO) {\n\t\t\t\tGF_VisualSampleEntryBox *vent1 = (GF_VisualSampleEntryBox *) ent1;\n\t\t\t\tGF_VisualSampleEntryBox *vent2 = (GF_VisualSampleEntryBox *) ent2;\n\t\t\t\tif (vent1->Width != vent2->Width) return GF_FALSE;\n\t\t\t\tif (vent1->Height != vent2->Height) return GF_FALSE;\n\t\t\t}\n\t\t\telse if (ent1->internal_type == GF_ISOM_SAMPLE_ENTRY_AUDIO) {\n\t\t\t\tGF_AudioSampleEntryBox *aent1 = (GF_AudioSampleEntryBox *) ent1;\n\t\t\t\tGF_AudioSampleEntryBox *aent2 = (GF_AudioSampleEntryBox *) ent2;\n\t\t\t\tif (aent1->samplerate_hi != aent2->samplerate_hi) return GF_FALSE;\n\t\t\t\tif (aent1->samplerate_lo != aent2->samplerate_lo) return GF_FALSE;\n\t\t\t\tif (aent1->channel_count != aent2->channel_count) return GF_FALSE;\n\t\t\t}\n\t\t\treturn GF_TRUE;\n\t\t}\n\n\t\tif (sdesc_index1 && sdesc_index2) break;\n\t}\n\tif (!need_memcmp) return GF_TRUE;\n\ta = (GF_Box *)trak1->Media->information->sampleTable->SampleDescription;\n\tb = (GF_Box *)trak2->Media->information->sampleTable->SampleDescription;\n\t//we ignore all bitrate boxes when comparing the box, disable their writing\n\tgf_isom_registry_disable(GF_ISOM_BOX_TYPE_BTRT, GF_TRUE);\n\tret = gf_isom_box_equal(a,b);\n\t//re-enable btrt writing\n\tgf_isom_registry_disable(GF_ISOM_BOX_TYPE_BTRT, GF_FALSE);\n\n\treturn ret;\n}\n\nGF_EXPORT\nu64 gf_isom_estimate_size(GF_ISOFile *movie)\n{\n\tGF_Err e;\n\tGF_Box *a;\n\tu32 i, count;\n\tu64 mdat_size;\n\tif (!movie || !movie->moov) return 0;\n\n\tmdat_size = 0;\n\tcount = gf_list_count(movie->moov->trackList);\n\tfor (i=0; i<count; i++) {\n\t\tmdat_size += gf_isom_get_media_data_size(movie, i+1);\n\t}\n\tif (mdat_size) {\n\t\tmdat_size += 8;\n\t\tif (mdat_size > 0xFFFFFFFF) mdat_size += 8;\n\t}\n\n\ti=0;\n\twhile ((a = (GF_Box*)gf_list_enum(movie->TopBoxes, &i))) {\n\t\te = gf_isom_box_size(a);\n\t\tif (e == GF_OK)\n\t\t\tmdat_size += a->size;\n\t}\n\treturn mdat_size;\n}\n\n\n//set shadowing on/off\n#if 0 //unused\nGF_Err gf_isom_remove_sync_shadows(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\tGF_SampleTableBox *stbl;\n\n\tif (movie->openMode == GF_ISOM_OPEN_READ) return GF_ISOM_INVALID_MODE;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstbl = trak->Media->information->sampleTable;\n\tif (stbl->ShadowSync) {\n\t\tgf_isom_box_del_parent(&stbl->child_boxes, (GF_Box *) stbl->ShadowSync);\n\t\tstbl->ShadowSync = NULL;\n\t}\n\treturn GF_OK;\n}\n\n/*Use this function to do the shadowing if you use shadowing.\nthe sample to be shadowed MUST be a non-sync sample (ignored if not)\nthe sample shadowing must be a Sync sample (error if not)*/\nGF_Err gf_isom_set_sync_shadow(GF_ISOFile *movie, u32 trackNumber, u32 sampleNumber, u32 syncSample)\n{\n\tGF_TrackBox *trak;\n\tGF_SampleTableBox *stbl;\n\tGF_ISOSAPType isRAP;\n\tGF_Err e;\n\n\tif (movie->openMode == GF_ISOM_OPEN_READ) return GF_ISOM_INVALID_MODE;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !sampleNumber || !syncSample) return GF_BAD_PARAM;\n\n\tstbl = trak->Media->information->sampleTable;\n\tif (!stbl->ShadowSync) {\n\t\tstbl->ShadowSync = (GF_ShadowSyncBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STSH);\n\t\tif (!stbl->ShadowSync) return GF_OUT_OF_MEM;\n\t}\n\n\t//if no sync, skip\n\tif (!stbl->SyncSample) return GF_OK;\n\t//else set the sync shadow.\n\t//if the sample is sync, ignore\n\te = stbl_GetSampleRAP(stbl->SyncSample, sampleNumber, &isRAP, NULL, NULL);\n\tif (e) return e;\n\tif (isRAP) return GF_OK;\n\t//if the shadowing sample is not sync, error\n\te = stbl_GetSampleRAP(stbl->SyncSample, syncSample, &isRAP, NULL, NULL);\n\tif (e) return e;\n\tif (!isRAP) return GF_BAD_PARAM;\n\n\treturn stbl_SetSyncShadow(stbl->ShadowSync, sampleNumber, syncSample);\n}\n#endif\n\n//set the GroupID of a track (only used for interleaving)\nGF_EXPORT\nGF_Err gf_isom_set_track_interleaving_group(GF_ISOFile *movie, u32 trackNumber, u32 GroupID)\n{\n\tGF_TrackBox *trak;\n\n\tif (movie->openMode != GF_ISOM_OPEN_EDIT) return GF_ISOM_INVALID_MODE;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !GroupID) return GF_BAD_PARAM;\n\n\ttrak->Media->information->sampleTable->groupID = GroupID;\n\treturn GF_OK;\n}\n\n\n//set the Priority of a track within a Group (only used for tight interleaving)\n//Priority ranges from 1 to 9\nGF_EXPORT\nGF_Err gf_isom_set_track_priority_in_group(GF_ISOFile *movie, u32 trackNumber, u32 Priority)\n{\n\tGF_TrackBox *trak;\n\n\tif (movie->openMode != GF_ISOM_OPEN_EDIT) return GF_ISOM_INVALID_MODE;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !Priority) return GF_BAD_PARAM;\n\n\ttrak->Media->information->sampleTable->trackPriority = Priority > 255 ? 255 : Priority;\n\treturn GF_OK;\n}\n\n//set the max SamplesPerChunk (for file optimization)\nGF_EXPORT\nGF_Err gf_isom_hint_max_chunk_size(GF_ISOFile *movie, u32 trackNumber, u32 maxChunkSize)\n{\n\tGF_TrackBox *trak;\n\n\tif (movie->openMode == GF_ISOM_OPEN_READ) return GF_ISOM_INVALID_MODE;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !maxChunkSize) return GF_BAD_PARAM;\n\n\ttrak->Media->information->sampleTable->MaxChunkSize = maxChunkSize;\n\treturn GF_OK;\n}\n\n\n//set the max SamplesPerChunk (for file optimization)\nGF_EXPORT\nGF_Err gf_isom_hint_max_chunk_duration(GF_ISOFile *movie, u32 trackNumber, u32 maxChunkDur)\n{\n\tGF_TrackBox *trak;\n\n\tif (movie->openMode == GF_ISOM_OPEN_READ) return GF_ISOM_INVALID_MODE;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\ttrak->Media->information->sampleTable->MaxChunkDur = maxChunkDur;\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_set_extraction_slc(GF_ISOFile *the_file, u32 trackNumber, u32 StreamDescriptionIndex, const GF_SLConfig *slConfig)\n{\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_Err e;\n\tGF_SLConfig **slc;\n\tGF_ESDBox *esds;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\te = Media_GetSampleDesc(trak->Media, StreamDescriptionIndex, &entry, NULL);\n\tif (e) return e;\n\n\t//we must be sure we are not using a remote ESD\n\tswitch (entry->type) {\n\tcase GF_ISOM_BOX_TYPE_MP4S:\n\t\tesds = ((GF_MPEGSampleEntryBox *)entry)->esd;\n\t\tif (!esds || !esds->desc || !esds->desc->slConfig || (esds->desc->slConfig->predefined != SLPredef_MP4))\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\tslc = & ((GF_MPEGSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4A:\n\t\tesds = ((GF_MPEGAudioSampleEntryBox *)entry)->esd;\n\t\tif (!esds || !esds->desc || !esds->desc->slConfig || (esds->desc->slConfig->predefined != SLPredef_MP4))\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\tslc = & ((GF_MPEGAudioSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4V:\n\t\tesds = ((GF_MPEGVisualSampleEntryBox *)entry)->esd;\n\t\tif (!esds || !esds->desc || !esds->desc->slConfig || (esds->desc->slConfig->predefined != SLPredef_MP4))\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\tslc = & ((GF_MPEGVisualSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_OK;\n\t}\n\n\tif (*slc) {\n\t\tgf_odf_desc_del((GF_Descriptor *)*slc);\n\t\t*slc = NULL;\n\t}\n\tif (!slConfig) return GF_OK;\n\t//finally duplicate the SL\n\treturn gf_odf_desc_copy((GF_Descriptor *) slConfig, (GF_Descriptor **) slc);\n}\n\n#if 0 //unused\nGF_Err gf_isom_get_extraction_slc(GF_ISOFile *the_file, u32 trackNumber, u32 StreamDescriptionIndex, GF_SLConfig **slConfig)\n{\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_Err e;\n\tGF_SLConfig *slc;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\te = Media_GetSampleDesc(trak->Media, StreamDescriptionIndex, &entry, NULL);\n\tif (e) return e;\n\n\t//we must be sure we are not using a remote ESD\n\tslc = NULL;\n\t*slConfig = NULL;\n\tswitch (entry->type) {\n\tcase GF_ISOM_BOX_TYPE_MP4S:\n\t\tif (((GF_MPEGSampleEntryBox *)entry)->esd->desc->slConfig->predefined != SLPredef_MP4) return GF_BAD_PARAM;\n\t\tslc = ((GF_MPEGSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4A:\n\t\tif (((GF_MPEGAudioSampleEntryBox *)entry)->esd->desc->slConfig->predefined != SLPredef_MP4) return GF_BAD_PARAM;\n\t\tslc = ((GF_MPEGAudioSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4V:\n\t\tif (((GF_MPEGVisualSampleEntryBox *)entry)->esd->desc->slConfig->predefined != SLPredef_MP4) return GF_BAD_PARAM;\n\t\tslc = ((GF_MPEGVisualSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tif (!slc) return GF_OK;\n\t//finally duplicate the SL\n\treturn gf_odf_desc_copy((GF_Descriptor *) slc, (GF_Descriptor **) slConfig);\n}\n\nu32 gf_isom_get_track_group(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 0;\n\treturn trak->Media->information->sampleTable->groupID;\n}\n\nu32 gf_isom_get_track_priority_in_group(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 0;\n\treturn trak->Media->information->sampleTable->trackPriority;\n}\n#endif\n\n\nGF_EXPORT\nGF_Err gf_isom_make_interleave_ex(GF_ISOFile *file, GF_Fraction *fTimeInSec)\n{\n\tGF_Err e;\n\tu64 itime;\n\tif (!file || !fTimeInSec->den || (fTimeInSec->num<=0)) return GF_BAD_PARAM;\n\n\titime = (u64) fTimeInSec->num;\n\titime *= gf_isom_get_timescale(file);\n\titime /= fTimeInSec->den;\n\tif (file->storageMode==GF_ISOM_STORE_FASTSTART) {\n\t\treturn gf_isom_set_interleave_time(file, (u32) itime);\n\t}\n\tif (gf_isom_get_mode(file) < GF_ISOM_OPEN_EDIT) return GF_BAD_PARAM;\n\te = gf_isom_set_storage_mode(file, GF_ISOM_STORE_DRIFT_INTERLEAVED);\n\tif (e) return e;\n\treturn gf_isom_set_interleave_time(file, (u32) itime);\n}\n\nGF_EXPORT\nGF_Err gf_isom_make_interleave(GF_ISOFile *file, Double TimeInSec)\n{\n\tGF_Fraction f;\n\tf.num = (s32) (TimeInSec * 1000);\n\tf.den = 1000;\n\treturn gf_isom_make_interleave_ex(file, &f);\n\n}\nGF_EXPORT\nGF_Err gf_isom_set_handler_name(GF_ISOFile *the_file, u32 trackNumber, const char *nameUTF8)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\tif (trak->Media->handler->nameUTF8) gf_free(trak->Media->handler->nameUTF8);\n\ttrak->Media->handler->nameUTF8 = NULL;\n\n\tif (!nameUTF8) return GF_OK;\n\n\tif (!strnicmp(nameUTF8, \"file://\", 7)) {\n\t\tu8 BOM[4];\n\t\tFILE *f = gf_fopen(nameUTF8+7, \"rb\");\n\t\tu64 size;\n\t\tif (!f) return GF_URL_ERROR;\n\t\tsize = gf_fsize(f);\n\t\tif (3!=gf_fread(BOM, 3, f)) {\n\t\t\tgf_fclose(f);\n\t\t\treturn GF_CORRUPTED_DATA;\n\t\t}\n\t\t/*skip BOM if any*/\n\t\tif ((BOM[0]==0xEF) && (BOM[1]==0xBB) && (BOM[2]==0xBF)) size -= 3;\n\t\telse if ((BOM[0]==0xEF) || (BOM[0]==0xFF)) {\n\t\t\tgf_fclose(f);\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t\telse gf_fseek(f, 0, SEEK_SET);\n\t\ttrak->Media->handler->nameUTF8 = (char*)gf_malloc(sizeof(char)*(size_t)(size+1));\n\t\tif (!trak->Media->handler->nameUTF8) {\n\t\t\tgf_fclose(f);\n\t\t\treturn GF_OUT_OF_MEM;\n\t\t}\n\t\tsize = gf_fread(trak->Media->handler->nameUTF8, (size_t)size, f);\n\t\ttrak->Media->handler->nameUTF8[size] = 0;\n\t\tgf_fclose(f);\n\t} else {\n\t\tu32 i, j, len;\n\t\tchar szOrig[1024], szLine[1024];\n\t\tstrcpy(szOrig, nameUTF8);\n\t\tj=0;\n\t\tlen = (u32) strlen(szOrig);\n\t\tfor (i=0; i<len; i++) {\n\t\t\tif (szOrig[i] & 0x80) {\n\t\t\t\t/*non UTF8 (likely some win-CP)*/\n\t\t\t\tif ( (szOrig[i+1] & 0xc0) != 0x80) {\n\t\t\t\t\tszLine[j] = 0xc0 | ( (szOrig[i] >> 6) & 0x3 );\n\t\t\t\t\tj++;\n\t\t\t\t\tszOrig[i] &= 0xbf;\n\t\t\t\t}\n\t\t\t\t/*UTF8 2 bytes char */\n\t\t\t\telse if ( (szOrig[i] & 0xe0) == 0xc0) {\n\t\t\t\t\tszLine[j] = szOrig[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\t/*UTF8 3 bytes char */\n\t\t\t\telse if ( (szOrig[i] & 0xf0) == 0xe0) {\n\t\t\t\t\tszLine[j] = szOrig[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t\tszLine[j] = szOrig[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\t/*UTF8 4 bytes char */\n\t\t\t\telse if ( (szOrig[i] & 0xf8) == 0xf0) {\n\t\t\t\t\tszLine[j] = szOrig[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t\tszLine[j] = szOrig[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t\tszLine[j] = szOrig[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tszLine[j] = szOrig[i];\n\t\t\tj++;\n\t\t}\n\t\tszLine[j] = 0;\n\t\ttrak->Media->handler->nameUTF8 = gf_strdup(szLine);\n\t}\n\treturn GF_OK;\n}\n\n#if 0 //unused\n/*clones root OD from input to output file, without copying root OD track references*/\nGF_Err gf_isom_clone_root_od(GF_ISOFile *input, GF_ISOFile *output)\n{\n\tGF_List *esds;\n\tGF_Err e;\n\tu32 i;\n\tGF_Descriptor *desc;\n\n\te = gf_isom_remove_root_od(output);\n\tif (e) return e;\n\tif (!input->moov || !input->moov->iods || !input->moov->iods->descriptor) return GF_OK;\n\te = gf_isom_insert_moov(output);\n\tif (e) return e;\n\te = AddMovieIOD(output->moov, 0);\n\tif (e) return e;\n\tif (output->moov->iods->descriptor) gf_odf_desc_del(output->moov->iods->descriptor);\n\toutput->moov->iods->descriptor = NULL;\n\tgf_odf_desc_copy(input->moov->iods->descriptor, &output->moov->iods->descriptor);\n\n\tswitch (output->moov->iods->descriptor->tag) {\n\tcase GF_ODF_ISOM_IOD_TAG:\n\t\tesds = ((GF_IsomInitialObjectDescriptor *)output->moov->iods->descriptor)->ES_ID_IncDescriptors;\n\t\tbreak;\n\tcase GF_ODF_ISOM_OD_TAG:\n\t\tesds = ((GF_IsomObjectDescriptor *)output->moov->iods->descriptor)->ES_ID_IncDescriptors;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\t//get the desc\n\ti=0;\n\twhile ((desc = (GF_Descriptor*)gf_list_enum(esds, &i))) {\n\t\tgf_odf_desc_del(desc);\n\t\tgf_list_rem(esds, i-1);\n\t}\n\treturn GF_OK;\n}\n#endif\n\nGF_EXPORT\nGF_Err gf_isom_set_media_type(GF_ISOFile *movie, u32 trackNumber, u32 new_type)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !new_type) return GF_BAD_PARAM;\n\ttrak->Media->handler->handlerType = new_type;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_media_subtype(GF_ISOFile *movie, u32 trackNumber, u32 sampleDescriptionIndex, u32 new_type)\n{\n\tGF_SampleEntryBox*entry;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !sampleDescriptionIndex || !new_type) return GF_BAD_PARAM;\n\n\tentry = (GF_SampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, sampleDescriptionIndex - 1);\n\tif (!entry) return GF_BAD_PARAM;\n\tif (entry->type==GF_ISOM_BOX_TYPE_GNRV) {\n\t\t((GF_GenericVisualSampleEntryBox *)entry)->EntryType = new_type;\n\t} else if (entry->type==GF_ISOM_BOX_TYPE_GNRA) {\n\t\t((GF_GenericAudioSampleEntryBox *)entry)->EntryType = new_type;\n\t} else if (entry->type==GF_ISOM_BOX_TYPE_GNRM) {\n\t\t((GF_GenericSampleEntryBox *)entry)->EntryType = new_type;\n\t} else {\n\t\tentry->type = new_type;\n\t}\n\treturn GF_OK;\n}\n\n\n#if 0 //unused\nGF_Err gf_isom_set_JPEG2000(GF_ISOFile *mov, Bool set_on)\n{\n\tif (!mov) return GF_BAD_PARAM;\n\tmov->is_jp2 = set_on;\n\treturn GF_OK;\n}\n#endif\n\nGF_Err gf_isom_remove_uuid(GF_ISOFile *movie, u32 trackNumber, bin128 UUID)\n{\n\tu32 i, count;\n\tGF_List *list;\n\n\tif (trackNumber==(u32) -1) {\n\t\tif (!movie) return GF_BAD_PARAM;\n\t\tlist = movie->TopBoxes;\n\t} else if (trackNumber) {\n\t\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\tlist = trak->child_boxes;\n\t} else {\n\t\tif (!movie) return GF_BAD_PARAM;\n\t\tlist = movie->moov->child_boxes;\n\t}\n\n\tcount = list ? gf_list_count(list) : 0;\n\tfor (i=0; i<count; i++) {\n\t\tGF_UnknownUUIDBox *uuid = (GF_UnknownUUIDBox *)gf_list_get(list, i);\n\t\tif (uuid->type != GF_ISOM_BOX_TYPE_UUID) continue;\n\t\tif (memcmp(UUID, uuid->uuid, sizeof(bin128))) continue;\n\t\tgf_list_rem(list, i);\n\t\ti--;\n\t\tcount--;\n\t\tgf_isom_box_del((GF_Box*)uuid);\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_add_uuid(GF_ISOFile *movie, u32 trackNumber, bin128 UUID, const u8 *data, u32 data_size)\n{\n\tGF_List *list;\n    u32 btype;\n\tGF_Box *box;\n\tGF_UnknownUUIDBox *uuidb;\n\n\tif (data_size && !data) return GF_BAD_PARAM;\n\tif (trackNumber==(u32) -1) {\n\t\tif (!movie) return GF_BAD_PARAM;\n\t\tlist = movie->TopBoxes;\n\t} else if (trackNumber) {\n\t\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\tif (!trak->child_boxes) trak->child_boxes = gf_list_new();\n\t\tlist = trak->child_boxes;\n\t} else {\n\t\tif (!movie) return GF_BAD_PARAM;\n\t\tif (!movie->moov->child_boxes) movie->moov->child_boxes = gf_list_new();\n\t\tlist = movie->moov->child_boxes;\n\t}\n    btype = gf_isom_solve_uuid_box((char *) UUID);\n    if (!btype) btype = GF_ISOM_BOX_TYPE_UUID;\n    box = gf_isom_box_new(btype);\n    if (!box) return GF_OUT_OF_MEM;\n\tuuidb = (GF_UnknownUUIDBox*)box;\n\tuuidb->internal_4cc = gf_isom_solve_uuid_box((char *) UUID);\n\tmemcpy(uuidb->uuid, UUID, sizeof(bin128));\n\tuuidb->dataSize = data_size;\n\tif (data_size) {\n\t\tuuidb->data = (char*)gf_malloc(sizeof(char)*data_size);\n\t\tif (!uuidb->data) return GF_OUT_OF_MEM;\n\t\tmemcpy(uuidb->data, data, sizeof(char)*data_size);\n\t}\n\tgf_list_add(list, uuidb);\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_apple_set_tag(GF_ISOFile *mov, GF_ISOiTunesTag tag, const u8 *data, u32 data_len, u64 int_val, u32 int_val2)\n{\n\tGF_Err e;\n\tGF_ItemListBox *ilst;\n\tGF_MetaBox *meta;\n\tGF_ListItemBox *info;\n\tu32 btype, i, itype;\n\ts32 tag_idx;\n\tu32 n=0, d=0;\n\tu8 loc_data[10];\n\tu32 int_flags = 0x15;\n\tGF_DataBox *dbox;\n\n\te = CanAccessMovie(mov, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttag_idx = gf_itags_find_by_itag(tag);\n\tif (tag_idx<0) {\n\t\titype = GF_ITAG_STR;\n\t} else {\n\t\titype = gf_itags_get_type(tag_idx);\n\t}\n\tmeta = (GF_MetaBox *) gf_isom_create_meta_extensions(mov, GF_FALSE);\n\tif (!meta) return GF_BAD_PARAM;\n\n\tilst = gf_isom_locate_box(meta->child_boxes, GF_ISOM_BOX_TYPE_ILST, NULL);\n\tif (!ilst) {\n\t\tilst = (GF_ItemListBox *) gf_isom_box_new_parent(&meta->child_boxes, GF_ISOM_BOX_TYPE_ILST);\n\t}\n\n\tif (tag==GF_ISOM_ITUNE_RESET) {\n\t\tgf_isom_box_del_parent(&meta->child_boxes, (GF_Box *) ilst);\n\t\t//if last, delete udta - we may still have a handler box remaining\n\t\tif ((gf_list_count(meta->child_boxes) <= 1) && (gf_list_count(mov->moov->udta->recordList)==1)) {\n\t\t\tgf_isom_box_del_parent(&mov->moov->child_boxes, (GF_Box *) mov->moov->udta);\n\t\t\tmov->moov->udta = NULL;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\n\tif (tag==GF_ISOM_ITUNE_GENRE) {\n\t\tif (!int_val && data) {\n\t\t\tint_val = gf_id3_get_genre_tag(data);\n\t\t\tif (int_val) {\n\t\t\t\tdata = NULL;\n\t\t\t\tdata_len = 0;\n\t\t\t\titype = GF_ITAG_INT16;\n\t\t\t\tint_flags = 0;\n\t\t\t}\n\t\t}\n\t\tbtype = data ? GF_ISOM_ITUNE_GENRE_USER : GF_ISOM_ITUNE_GENRE;\n\t} else {\n\t\tbtype = tag;\n\t}\n\t/*remove tag*/\n\ti = 0;\n\twhile ((info = (GF_ListItemBox*)gf_list_enum(ilst->child_boxes, &i))) {\n\t\tif (info->type==btype) {\n\t\t\tgf_isom_box_del_parent(&ilst->child_boxes, (GF_Box *) info);\n\t\t\tinfo = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (info->type==GF_ISOM_BOX_TYPE_UNKNOWN) {\n\t\t\tGF_UnknownBox *u = (GF_UnknownBox *) info;\n\t\t\tif (u->original_4cc==btype) {\n\t\t\t\tgf_isom_box_del_parent(&ilst->child_boxes, (GF_Box *) info);\n\t\t\t\tinfo = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!data && data_len) {\n\t\tif (!gf_list_count(ilst->child_boxes) )\n\t\t\tgf_isom_box_del_parent(&meta->child_boxes, (GF_Box *) ilst);\n\t\treturn GF_OK;\n\t}\n\n\t//watch out for cprt, we don't want to create a regular cprt box\n\tif (btype==GF_ISOM_ITUNE_COPYRIGHT) {\n\t\tinfo = (GF_ListItemBox *)gf_isom_box_new(GF_ISOM_ITUNE_TOOL);\n\t\tinfo->type = GF_ISOM_ITUNE_COPYRIGHT;\n\t} else {\n\t\tinfo = (GF_ListItemBox *)gf_isom_box_new(btype);\n\t}\n\tif (info == NULL) return GF_OUT_OF_MEM;\n\n\tdbox = (GF_DataBox *)gf_isom_box_new_parent(&info->child_boxes, GF_ISOM_BOX_TYPE_DATA);\n\tif (!dbox) {\n\t\tgf_isom_box_del((GF_Box *)info);\n\t\treturn GF_OUT_OF_MEM;\n\t}\n\tif (info->type!=GF_ISOM_BOX_TYPE_UNKNOWN) {\n\t\tinfo->data = dbox;\n\t}\n\n\tswitch (itype) {\n\tcase GF_ITAG_FRAC6:\n\tcase GF_ITAG_FRAC8:\n\t\tif (data && data_len) {\n\t\t\tif (sscanf(data, \"%u/%u\", &n, &d) != 2) {\n\t\t\t\tn = d = 0;\n\t\t\t\tif (sscanf(data, \"%u\", &n) != 1)\n\t\t\t\t\tn = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tn = (u32) int_val;\n\t\t\td = int_val2;\n\t\t}\n\t\tif (n) {\n\t\t\tmemset(loc_data, 0, sizeof(char) * 8);\n\t\t\tdata_len = (itype == GF_ITAG_FRAC6) ? 6 : 8;\n\t\t\tloc_data[3] = n;\n\t\t\tloc_data[2] = n >> 8;\n\t\t\tloc_data[5] = d;\n\t\t\tloc_data[4] = d >> 8;\n\t\t\tdata = loc_data;\n\t\t} else {\n\t\t\tdata = NULL;\n\t\t}\n\t\tdbox->flags = 0x15;\n\t\tbreak;\n\tcase GF_ITAG_BOOL:\n\t\tloc_data[0] = 0;\n\t\tif (data && data_len) {\n\t\t\tif ( !strcmp(data, \"yes\") || !strcmp(data, \"1\") || !strcmp(data, \"true\"))\n\t\t\t\tloc_data[0] = 1;\n\t\t} else {\n\t\t\tloc_data[0] = int_val ? 1 : 0;\n\t\t}\n\t\tdata = loc_data;\n\t\tdata_len = 1;\n\t\tdbox->flags = int_flags;\n\t\tbreak;\n\tcase GF_ITAG_INT8:\n\t\tloc_data[0] = 0;\n\t\tif (data && data_len) int_val = atoi(data);\n\t\tloc_data[0] = (u8) int_val;\n\t\tdata = loc_data;\n\t\tdata_len = 1;\n\t\tdbox->flags = int_flags;\n\t\tbreak;\n\tcase GF_ITAG_INT16:\n\t\tloc_data[0] = 0;\n\t\tif (data && data_len) int_val = atoi(data);\n\t\tloc_data[1] = (u8) int_val;\n\t\tloc_data[0] = (u8) (int_val>>8);\n\t\tdata = loc_data;\n\t\tdata_len = 2;\n\t\tdbox->flags = int_flags;\n\t\tbreak;\n\tcase GF_ITAG_INT32:\n\t\tloc_data[0] = 0;\n\t\tif (data && data_len) int_val = atoi(data);\n\t\tloc_data[3] = (u8) int_val;\n\t\tloc_data[2] = (u8) (int_val>>8);\n\t\tloc_data[1] = (u8) (int_val>>16);\n\t\tloc_data[0] = (u8) (int_val>>24);\n\t\tdata = loc_data;\n\t\tdata_len = 4;\n\t\tdbox->flags = int_flags;\n\t\tbreak;\n\tcase GF_ITAG_INT64:\n\t\tloc_data[0] = 0;\n\t\tif (data && data_len) sscanf(data, LLU, &int_val);\n\t\tloc_data[7] = (u8) int_val;\n\t\tloc_data[6] = (u8) (int_val>>8);\n\t\tloc_data[5] = (u8) (int_val>>16);\n\t\tloc_data[4] = (u8) (int_val>>24);\n\t\tloc_data[3] = (u8) (int_val>>32);\n\t\tloc_data[2] = (u8) (int_val>>40);\n\t\tloc_data[1] = (u8) (int_val>>48);\n\t\tloc_data[0] = (u8) (int_val>>56);\n\t\tdata = loc_data;\n\t\tdata_len = 8;\n\t\tdbox->flags = int_flags;\n\t\tbreak;\n\tdefault:\n\t\tdbox->flags = 1;\n\t\tbreak;\n\t}\n\n\tif (!data) return GF_BAD_PARAM;\n\n\n\tif (tag==GF_ISOM_ITUNE_COVER_ART) {\n\t\tinfo->data->flags = 0;\n\t\t/*check for PNG sig*/\n\t\tif ((data_len>4) && (data[0] == 0x89) && (data[1] == 0x50) && (data[2] == 0x4E) && (data[3] == 0x47) ) {\n\t\t\tinfo->data->flags = 14;\n\t\t}\n\t\t//JPG and JFIF - do not check second tag type\n\t\telse if ((data_len>4) && (data[0] == 0xFF) && (data[1] == 0xD8) && (data[2] == 0xFF) /*&& ((data[3] == 0xE0) || (data[3] == 0xDB))*/ ) {\n\t\t\tinfo->data->flags = 13;\n\t\t}\n\t\t//GIF\n\t\telse if ((data_len>3) && (data[0] == 'G') && (data[1] == 'I') && (data[2] == 'F') ) {\n\t\t\tinfo->data->flags = 12;\n\t\t}\n\t}\n\n\tdbox->dataSize = data_len;\n\tdbox->data = (char*)gf_malloc(sizeof(char)*data_len);\n\tif (!dbox->data) return GF_OUT_OF_MEM;\n\tmemcpy(dbox->data, data, sizeof(char)*data_len);\n\n\tif (!info && !gf_list_count(ilst->child_boxes) ) {\n\t\tgf_isom_box_del_parent(&meta->child_boxes, (GF_Box *) ilst);\n\t\treturn GF_OK;\n\t}\n\tif (!ilst->child_boxes) ilst->child_boxes = gf_list_new();\n\t\n\treturn gf_list_add(ilst->child_boxes, info);\n}\n\n#include <gpac/utf.h>\n\nGF_EXPORT\nGF_Err gf_isom_wma_set_tag(GF_ISOFile *mov, char *name, char *value)\n{\n\tGF_Err e;\n\tGF_XtraTag *tag=NULL;\n\tu32 count, i;\n\tGF_XtraBox *xtra;\n\n\te = CanAccessMovie(mov, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tgf_isom_create_meta_extensions(mov, GF_FALSE);\n\n\txtra = (GF_XtraBox *) gf_isom_create_meta_extensions(mov, GF_TRUE);\n\tif (!xtra) return GF_BAD_PARAM;\n\n\tcount = gf_list_count(xtra->tags);\n\tfor (i=0; i<count; i++) {\n\t\ttag = gf_list_get(xtra->tags, i);\n\t\tif (name && tag->name && !strcmp(tag->name, name)) {\n\n\t\t} else {\n\t\t\ttag = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!value) {\n\t\t\tgf_list_rem(xtra->tags, i);\n\t\t\tgf_free(tag->name);\n\t\t\tif (tag->prop_value) gf_free(tag->prop_value);\n\t\t\tgf_free(tag);\n\t\t\treturn GF_OK;\n\t\t}\n\t\tgf_free(tag->prop_value);\n\t\ttag->prop_value = 0;\n\t}\n\tif (!tag) {\n\t\tif (!name) return GF_OK;\n\n\t\tGF_SAFEALLOC(tag, GF_XtraTag);\n\t\ttag->name = gf_strdup(name);\n\t\ttag->prop_type = 0;\n\t\ttag->flags = 1;\n\t\tgf_list_add(xtra->tags, tag);\n\t}\n\n\tu32 len = (u32) strlen(value);\n\ttag->prop_value = gf_malloc(sizeof(u16) * (len+1) );\n\tmemset(tag->prop_value, 0, sizeof(u16) * (len+1) );\n\tif (len) {\n\t\tu32 _len = gf_utf8_mbstowcs((u16 *) tag->prop_value, len, (const char **) &value);\n\t\tif (_len == GF_UTF8_FAIL) _len = 0;\n\t\ttag->prop_value[2 * _len] = 0;\n\t\ttag->prop_value[2 * _len + 1] = 0;\n\t\ttag->prop_size = 2 * _len + 2;\n\t} else {\n\t\ttag->prop_size = 2;\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_qt_key(GF_ISOFile *movie, GF_QT_UDTAKey *key)\n{\n\tGF_Err e;\n\tGF_MetaBox *meta;\n\tGF_ItemListBox *ilst;\n\tGF_MetaKeysBox *keys;\n\tu32 i, nb_keys;\n\n\tif (!movie) return GF_BAD_PARAM;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) {\n\t\tgf_isom_set_last_error(movie, e);\n\t\treturn 0;\n\t}\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\n\tmeta = (GF_MetaBox *) gf_isom_create_meta_extensions(movie, 2);\n\tif (!meta) return GF_BAD_PARAM;\n\n\tkeys = (GF_MetaKeysBox *) gf_isom_locate_box(meta->child_boxes, GF_ISOM_BOX_TYPE_KEYS, NULL);\n\tif (!keys) {\n\t\tkeys = (GF_MetaKeysBox *) gf_isom_box_new_parent(&meta->child_boxes, GF_ISOM_BOX_TYPE_KEYS);\n\t\tmeta->keys = keys;\n\t}\n\tilst = (GF_ItemListBox *) gf_isom_locate_box(meta->child_boxes, GF_ISOM_BOX_TYPE_ILST, NULL);\n\tif (!ilst) {\n\t\tilst = (GF_ItemListBox *) gf_isom_box_new_parent(&meta->child_boxes, GF_ISOM_BOX_TYPE_ILST);\n\t}\n\tif (!keys || !ilst) return GF_OUT_OF_MEM;\n\n\tnb_keys = gf_list_count(keys->keys);\n\tif (!key) {\n\t\tgf_isom_box_del_parent(&meta->child_boxes, (GF_Box *) keys);\n\t\tfor (i=0; i<gf_list_count(ilst->child_boxes); i++) {\n\t\t\tGF_ListItemBox *info = gf_list_get(ilst->child_boxes, i);\n\t\t\tif (info->type <= nb_keys) {\n\t\t\t\tgf_isom_box_del_parent(&ilst->child_boxes, (GF_Box *) info);\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\t\tif (!gf_list_count(ilst->child_boxes)) {\n\t\t\tgf_isom_box_del_parent(&meta->child_boxes, (GF_Box *) ilst);\n\t\t\t//if last, delete udta - we may still have a handler box remaining\n\t\t\tif ((gf_list_count(meta->child_boxes) <= 1) && (gf_list_count(movie->moov->udta->recordList)==1)) {\n\t\t\t\tgf_isom_box_del_parent(&movie->moov->child_boxes, (GF_Box *) movie->moov->udta);\n\t\t\t\tmovie->moov->udta = NULL;\n\t\t\t}\n\t\t}\n\t\treturn GF_OK;\n\t}\n\t//locate key\n\tGF_MetaKey *o_key = NULL;\n\tu32 ksize = (u32) strlen(key->name);\n\tfor (i=0; i<nb_keys; i++) {\n\t\to_key = gf_list_get(keys->keys, i);\n\t\tif ((o_key->ns == key->ns) && (o_key->size==ksize) && !strcmp(o_key->data, key->name))\n\t\t\tbreak;\n\t\to_key = NULL;\n\t}\n\tif (!o_key) {\n\t\tif (key->type==GF_QT_KEY_REMOVE) return GF_OK;\n\t\tGF_SAFEALLOC(o_key, GF_MetaKey);\n\t\to_key->ns = key->ns;\n\t\to_key->data = gf_strdup(key->name);\n\t\to_key->size = ksize;\n\t\tgf_list_add(keys->keys, o_key);\n\t}\n\tu32 key_idx = gf_list_find(keys->keys, o_key)+1;\n\tGF_UnknownBox *info=NULL;\n\tfor (i=0; i<gf_list_count(ilst->child_boxes); i++) {\n\t\tinfo = gf_list_get(ilst->child_boxes, i);\n\t\tif (info->original_4cc == key_idx) break;\n\t\tinfo = NULL;\n\t}\n\n\tif (key->type==GF_QT_KEY_REMOVE) {\n\t\tgf_list_del_item(keys->keys, o_key);\n\t\tif (o_key->data) gf_free(o_key->data);\n\t\tgf_free(o_key);\n\t\tfor (i=0; i<gf_list_count(ilst->child_boxes); i++) {\n\t\t\tinfo = gf_list_get(ilst->child_boxes, i);\n\t\t\tif (info->type!=GF_ISOM_BOX_TYPE_UNKNOWN) continue;\n\t\t\tif (info->original_4cc==key_idx) {\n\t\t\t\tgf_isom_box_del_parent(&ilst->child_boxes, (GF_Box *)info);\n\t\t\t\ti--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (info->original_4cc>key_idx) {\n\t\t\t\tinfo->original_4cc--;\n\t\t\t}\n\t\t}\n\t\treturn GF_OK;\n\t}\n\tif (!info) {\n\t\tinfo = (GF_UnknownBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_UNKNOWN);\n\t\tif (!info) return GF_OUT_OF_MEM;\n\t\tif (!ilst->child_boxes) ilst->child_boxes = gf_list_new();\n\t\tgf_list_add(ilst->child_boxes, info);\n\t}\n\n\tGF_DataBox *dbox = (GF_DataBox *) gf_isom_box_find_child(info->child_boxes, GF_ISOM_BOX_TYPE_DATA);\n\tif (!dbox) {\n\t\tdbox = (GF_DataBox *)gf_isom_box_new_parent(&info->child_boxes, GF_ISOM_BOX_TYPE_DATA);\n\t\tif (!dbox) {\n\t\t\tgf_isom_box_del((GF_Box *)info);\n\t\t\treturn GF_OUT_OF_MEM;\n\t\t}\n\t}\n\tu32 nb_bits=0;\n\tinfo->original_4cc = key_idx;\n\tdbox->version = 0;\n\tdbox->flags = key->type;\n\t//serialize\n\tGF_BitStream *bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\tswitch (key->type) {\n\tcase GF_QT_KEY_UTF8:\n\tcase GF_QT_KEY_UTF8_SORT:\n\t\tif (key->value.string)\n\t\t\tgf_bs_write_data(bs, key->value.string, (u32) strlen(key->value.string));\n\t\tbreak;\n\n\tcase GF_QT_KEY_SIGNED_VSIZE:\n\t\tif (ABS(key->value.sint)<=0x7F) nb_bits=8;\n\t\telse if (ABS(key->value.sint)<=0x7FFF) nb_bits=16;\n\t\telse if (ABS(key->value.sint)<=0x7FFFFF) nb_bits=24;\n\t\telse nb_bits = 32;\n\t\tgf_bs_write_int(bs, (s32) key->value.sint, nb_bits);\n\t\tbreak;\n\tcase GF_QT_KEY_UNSIGNED_VSIZE:\n\t\tif (key->value.uint<=0xFF) nb_bits=8;\n\t\telse if (key->value.uint<=0xFFFF) nb_bits=16;\n\t\telse if (key->value.uint<=0xFFFFFF) nb_bits=24;\n\t\telse nb_bits = 32;\n\t\tgf_bs_write_int(bs, (u32) key->value.uint, nb_bits);\n\t\tbreak;\n\tcase GF_QT_KEY_FLOAT:\n\t\tgf_bs_write_float(bs, (Float) key->value.number);\n\t\tbreak;\n\tcase GF_QT_KEY_DOUBLE:\n\t\tgf_bs_write_double(bs, key->value.number);\n\t\tbreak;\n\tcase GF_QT_KEY_SIGNED_8:\n\t\tgf_bs_write_int(bs, (s32) key->value.sint, 8);\n\t\tbreak;\n\tcase GF_QT_KEY_SIGNED_16:\n\t\tgf_bs_write_int(bs, (s32) key->value.sint, 16);\n\t\tbreak;\n\tcase GF_QT_KEY_SIGNED_32:\n\t\tgf_bs_write_int(bs, (s32) key->value.sint, 32);\n\t\tbreak;\n\tcase GF_QT_KEY_SIGNED_64:\n\t\tgf_bs_write_long_int(bs, key->value.sint, 64);\n\t\tbreak;\n\tcase GF_QT_KEY_POINTF:\n\tcase GF_QT_KEY_SIZEF:\n\t\tgf_bs_write_float(bs, key->value.pos_size.x);\n\t\tgf_bs_write_float(bs, key->value.pos_size.y);\n\t\tbreak;\n\tcase GF_QT_KEY_RECTF:\n\t\tgf_bs_write_float(bs, key->value.rect.x);\n\t\tgf_bs_write_float(bs, key->value.rect.y);\n\t\tgf_bs_write_float(bs, key->value.rect.w);\n\t\tgf_bs_write_float(bs, key->value.rect.h);\n\t\tbreak;\n\n\tcase GF_QT_KEY_UNSIGNED_8:\n\t\tgf_bs_write_int(bs, (s32) key->value.uint, 8);\n\t\tbreak;\n\tcase GF_QT_KEY_UNSIGNED_16:\n\t\tgf_bs_write_int(bs, (s32) key->value.uint, 16);\n\t\tbreak;\n\tcase GF_QT_KEY_UNSIGNED_32:\n\t\tgf_bs_write_int(bs, (s32) key->value.uint, 32);\n\t\tbreak;\n\tcase GF_QT_KEY_UNSIGNED_64:\n\t\tgf_bs_write_long_int(bs, key->value.uint, 64);\n\t\tbreak;\n\tcase GF_QT_KEY_MATRIXF:\n\t\tfor (i=0; i<9; i++)\n\t\t\tgf_bs_write_float(bs, (Float) key->value.matrix[i] );\n\t\tbreak;\n\n\tcase GF_QT_KEY_OPAQUE:\n\tcase GF_QT_KEY_UTF16_BE:\n\tcase GF_QT_KEY_JIS:\n\tcase GF_QT_KEY_UTF16_SORT:\n\tcase GF_QT_KEY_JPEG:\n\tcase GF_QT_KEY_PNG:\n\tcase GF_QT_KEY_BMP:\n\tcase GF_QT_KEY_METABOX:\n\tdefault:\n\t\tgf_bs_write_data(bs, key->value.data.data, key->value.data.data_len);\n\t\tbreak;\n\t}\n\t//write extra 0 at end, not serialized\n\tgf_bs_write_u8(bs, 0);\n\tif (dbox->data) gf_free(dbox->data);\n\n\tgf_bs_get_content(bs, &dbox->data, &i);\n\tif (i) i--;\n\tdbox->dataSize = i;\n\tgf_bs_del(bs);\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_set_alternate_group_id(GF_ISOFile *movie, u32 trackNumber, u32 groupId)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\ttrak->Header->alternate_group = groupId;\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_set_track_switch_parameter(GF_ISOFile *movie, u32 trackNumber, u32 trackRefGroup, Bool is_switch_group, u32 *switchGroupID, u32 *criteriaList, u32 criteriaListCount)\n{\n\tGF_TrackSelectionBox *tsel;\n\tGF_TrackBox *trak;\n\tGF_UserDataMap *map;\n\tGF_Err e;\n\tu32 alternateGroupID = 0;\n\tu32 next_switch_group_id = 0;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !switchGroupID) return GF_BAD_PARAM;\n\n\n\tif (trackRefGroup) {\n\t\tGF_TrackBox *trak_ref = gf_isom_get_track_from_file(movie, trackRefGroup);\n\t\tif (trak_ref != trak) {\n\t\t\tif (!trak_ref || !trak_ref->Header->alternate_group) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"Track %d has not an alternate group - skipping\\n\", trak_ref ? trak_ref->Header->trackID : 0));\n\t\t\t\treturn GF_BAD_PARAM;\n\t\t\t}\n\t\t\talternateGroupID = trak_ref->Header->alternate_group;\n\t\t} else {\n\t\t\talternateGroupID = trak->Header->alternate_group;\n\t\t}\n\t}\n\tif (!alternateGroupID) {\n\t\t/*there is a function for this ....*/\n\t\tif (trak->Header->alternate_group) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"Track %d has already an alternate group - skipping\\n\", trak->Header->trackID));\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t\talternateGroupID = gf_isom_get_next_alternate_group_id(movie);\n\t}\n\n\tif (is_switch_group) {\n\t\tu32 i=0;\n\t\twhile (i< gf_isom_get_track_count(movie) ) {\n\t\t\t//locate first available ID\n\t\t\tGF_TrackBox *a_trak = gf_isom_get_track_from_file(movie, i+1);\n\n\t\t\tif (a_trak->udta) {\n\t\t\t\tu32 j, count;\n\t\t\t\tmap = udta_getEntry(a_trak->udta, GF_ISOM_BOX_TYPE_TSEL, NULL);\n\t\t\t\tif (map) {\n\t\t\t\t\tcount = gf_list_count(map->boxes);\n\t\t\t\t\tfor (j=0; j<count; j++) {\n\t\t\t\t\t\ttsel = (GF_TrackSelectionBox*)gf_list_get(map->boxes, j);\n\n\t\t\t\t\t\tif (*switchGroupID) {\n\t\t\t\t\t\t\tif (tsel->switchGroup==next_switch_group_id) {\n\t\t\t\t\t\t\t\tif (a_trak->Header->alternate_group != alternateGroupID) return GF_BAD_PARAM;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (tsel->switchGroup && (tsel->switchGroup>=next_switch_group_id) )\n\t\t\t\t\t\t\t\tnext_switch_group_id = tsel->switchGroup;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tif (! *switchGroupID) *switchGroupID = next_switch_group_id+1;\n\t}\n\n\n\ttrak->Header->alternate_group = alternateGroupID;\n\n\ttsel = NULL;\n\tif (*switchGroupID) {\n\t\tif (!trak->udta) {\n\t\t\te = trak_on_child_box((GF_Box*)trak, gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_UDTA), GF_FALSE);\n\t\t\tif (e) return e;\n\t\t}\n\n\t\tmap = udta_getEntry(trak->udta, GF_ISOM_BOX_TYPE_TSEL, NULL);\n\n\t\t/*locate tsel box with no switch group*/\n\t\tif (map)  {\n\t\t\tu32 j, count = gf_list_count(map->boxes);\n\t\t\tfor (j=0; j<count; j++) {\n\t\t\t\ttsel = (GF_TrackSelectionBox*)gf_list_get(map->boxes, j);\n\t\t\t\tif (tsel->switchGroup == *switchGroupID) break;\n\t\t\t\ttsel = NULL;\n\t\t\t}\n\t\t}\n\t\tif (!tsel) {\n\t\t\ttsel = (GF_TrackSelectionBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_TSEL);\n\t\t\tif (!tsel) return GF_OUT_OF_MEM;\n\t\t\te = udta_on_child_box((GF_Box *)trak->udta, (GF_Box *) tsel, GF_FALSE);\n\t\t\tif (e) return e;\n\t\t}\n\n\t\ttsel->switchGroup = *switchGroupID;\n\t\ttsel->attributeListCount = criteriaListCount;\n\t\tif (tsel->attributeList) gf_free(tsel->attributeList);\n\t\ttsel->attributeList = (u32*)gf_malloc(sizeof(u32)*criteriaListCount);\n\t\tif (!tsel->attributeList) return GF_OUT_OF_MEM;\n\t\tmemcpy(tsel->attributeList, criteriaList, sizeof(u32)*criteriaListCount);\n\t}\n\treturn GF_OK;\n}\n\nvoid reset_tsel_box(GF_TrackBox *trak)\n{\n\tGF_UserDataMap *map;\n\ttrak->Header->alternate_group = 0;\n\tmap = udta_getEntry(trak->udta, GF_ISOM_BOX_TYPE_TSEL, NULL);\n\tif (map) {\n\t\tgf_list_del_item(trak->udta->recordList, map);\n\t\tgf_isom_box_array_del(map->boxes);\n\t\tgf_free(map);\n\t}\n\n}\n\nGF_EXPORT\nGF_Err gf_isom_reset_track_switch_parameter(GF_ISOFile *movie, u32 trackNumber, Bool reset_all_group)\n{\n\tGF_TrackBox *trak;\n\tu32 alternateGroupID = 0;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\tif (!trak->Header->alternate_group) return GF_OK;\n\n\talternateGroupID = trak->Header->alternate_group;\n\tif (reset_all_group) {\n\t\tu32 i=0;\n\t\twhile (i< gf_isom_get_track_count(movie) ) {\n\t\t\t//locate first available ID\n\t\t\tGF_TrackBox *a_trak = gf_isom_get_track_from_file(movie, i+1);\n\t\t\tif (a_trak->Header->alternate_group == alternateGroupID) reset_tsel_box(a_trak);\n\t\t\ti++;\n\t\t}\n\t} else {\n\t\treset_tsel_box(trak);\n\t}\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_reset_switch_parameters(GF_ISOFile *movie)\n{\n\tu32 i=0;\n\twhile (i< gf_isom_get_track_count(movie) ) {\n\t\t//locate first available ID\n\t\tGF_TrackBox *a_trak = gf_isom_get_track_from_file(movie, i+1);\n\t\treset_tsel_box(a_trak);\n\t\ti++;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err gf_isom_add_subsample(GF_ISOFile *movie, u32 track, u32 sampleNumber, u32 flags, u32 subSampleSize, u8 priority, u32 reserved, Bool discardable)\n{\n\tu32 i, count;\n\tGF_SubSampleInformationBox *sub_samples;\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, track);\n\tif (!trak || !trak->Media || !trak->Media->information->sampleTable)\n\t\treturn GF_BAD_PARAM;\n\n\tif (!trak->Media->information->sampleTable->sub_samples) {\n\t\ttrak->Media->information->sampleTable->sub_samples=gf_list_new();\n\t}\n\n\tsub_samples = NULL;\n\tcount = gf_list_count(trak->Media->information->sampleTable->sub_samples);\n\tfor (i=0; i<count; i++) {\n\t\tsub_samples = gf_list_get(trak->Media->information->sampleTable->sub_samples, i);\n\t\tif (sub_samples->flags==flags) break;\n\t\tsub_samples = NULL;\n\t}\n\tif (!sub_samples) {\n\t\tsub_samples = (GF_SubSampleInformationBox *) gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_SUBS);\n\t\tif (!sub_samples) return GF_OUT_OF_MEM;\n\t\tgf_list_add(trak->Media->information->sampleTable->sub_samples, sub_samples);\n\t\tsub_samples->version = (subSampleSize>0xFFFF) ? 1 : 0;\n\t\tsub_samples->flags = flags;\n\t}\n\treturn gf_isom_add_subsample_info(sub_samples, sampleNumber, subSampleSize, priority, reserved, discardable);\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_set_rvc_config(GF_ISOFile *movie, u32 track, u32 sampleDescriptionIndex, u16 rvc_predefined, char *mime, u8 *data, u32 size)\n{\n\tGF_MPEGVisualSampleEntryBox *entry;\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, track);\n\tif (!trak) return GF_BAD_PARAM;\n\n\n\tentry = (GF_MPEGVisualSampleEntryBox *) gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, sampleDescriptionIndex-1);\n\tif (!entry ) return GF_BAD_PARAM;\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return GF_BAD_PARAM;\n\n\tGF_RVCConfigurationBox *rvcc = (GF_RVCConfigurationBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_RVCC);\n\tif (rvcc && rvcc->rvc_meta_idx) {\n\t\tgf_isom_remove_meta_item(movie, GF_FALSE, track, rvcc->rvc_meta_idx, GF_FALSE, NULL);\n\t\trvcc->rvc_meta_idx = 0;\n\t}\n\n\tif (!rvcc) {\n\t\trvcc = (GF_RVCConfigurationBox *) gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_RVCC);\n\t\tif (!rvcc) return GF_OUT_OF_MEM;\n\t}\n\trvcc->predefined_rvc_config = rvc_predefined;\n\tif (!rvc_predefined) {\n\t\tu32 it_id=0;\n\t\te = gf_isom_set_meta_type(movie, GF_FALSE, track, GF_META_TYPE_RVCI);\n\t\tif (e) return e;\n\t\tgf_isom_modify_alternate_brand(movie, GF_ISOM_BRAND_ISO2, GF_TRUE);\n\t\te = gf_isom_add_meta_item_memory(movie, GF_FALSE, track, \"rvcconfig.xml\", &it_id, GF_META_ITEM_TYPE_MIME, mime, NULL, NULL, data, size, NULL);\n\t\tif (e) return e;\n\t\trvcc->rvc_meta_idx = gf_isom_get_meta_item_count(movie, GF_FALSE, track);\n\t}\n\treturn GF_OK;\n}\n\n/*for now not exported*/\n/*expands sampleGroup table for the given grouping type and sample_number. If sample_number is 0, just appends an entry at the end of the table*/\nstatic GF_Err gf_isom_add_sample_group_entry(GF_List *sampleGroups, u32 sample_number, GF_SampleGroupDescriptionBox *sgdesc, u32 grouping_type_parameter, u32 sampleGroupDescriptionIndex, GF_List *parent, GF_SampleTableBox *stbl)\n{\n\tGF_SampleGroupBox *sgroup = NULL;\n\tu32 i, count, last_sample_in_entry;\n\tBool all_samples = GF_FALSE;\n\tassert(sampleGroups);\n\tif (!sgdesc) return GF_BAD_PARAM;\n\tcount = gf_list_count(sampleGroups);\n\tfor (i=0; i<count; i++) {\n\t\tsgroup = (GF_SampleGroupBox*)gf_list_get(sampleGroups, i);\n\t\tif (sgroup->grouping_type==sgdesc->grouping_type) break;\n\t\tsgroup = NULL;\n\t}\n\tif (!sgroup) {\n\t\tsgroup = (GF_SampleGroupBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_SBGP);\n\t\tif (!sgroup) return GF_OUT_OF_MEM;\n\t\tsgroup->grouping_type = sgdesc->grouping_type;\n\t\tsgroup->grouping_type_parameter = grouping_type_parameter;\n//\t\tgf_list_add(sampleGroups, sgroup);\n\t\t//crude patch to align old arch and filters\n\t\tgf_list_insert(sampleGroups, sgroup, 0);\n\t\tassert(parent);\n\t\tgf_list_add(parent, sgroup);\n\t}\n\tu32 def_insert_value = (sgdesc && (sgdesc->version==2)) ? sgdesc->default_description_index : 0;\n\n\t/*used in fragments, means we are adding the last sample*/\n\tif (!sample_number) {\n\t\tsample_number = 1;\n\t\tif (sgroup->entry_count) {\n\t\t\tfor (i=0; i<sgroup->entry_count; i++) {\n\t\t\t\tsample_number += sgroup->sample_entries[i].sample_count;\n\t\t\t}\n\t\t}\n\t} else if (sample_number==(u32) -1) {\n\t\tall_samples = GF_TRUE;\n\t\tsample_number = 1;\n\t}\n\n\tif (!sgroup->entry_count) {\n\t\tu32 idx = 0;\n\t\tsgroup->entry_count = (sample_number>1) ? 2 : 1;\n\t\tsgroup->sample_entries = (GF_SampleGroupEntry*)gf_malloc(sizeof(GF_SampleGroupEntry) * sgroup->entry_count );\n\t\tif (!sgroup->sample_entries) return GF_OUT_OF_MEM;\n\t\tif (sample_number>1) {\n\t\t\tsgroup->sample_entries[0].sample_count = sample_number-1;\n\t\t\tsgroup->sample_entries[0].group_description_index = sampleGroupDescriptionIndex ? def_insert_value : 1;\n\t\t\tidx = 1;\n\t\t}\n\t\tsgroup->sample_entries[idx].sample_count = 1;\n\t\tsgroup->sample_entries[idx].group_description_index = sampleGroupDescriptionIndex;\n\t\tif (all_samples && stbl) {\n\t\t\tsgroup->sample_entries[idx].sample_count = stbl->SampleSize->sampleCount;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\tif (all_samples && stbl) {\n\t\tsgroup->entry_count = 1;\n\t\tsgroup->sample_entries[0].group_description_index = sampleGroupDescriptionIndex;\n\t\tsgroup->sample_entries[0].sample_count = stbl->SampleSize->sampleCount;\n\t\treturn GF_OK;\n\t}\n\tlast_sample_in_entry = 0;\n\tfor (i=0; i<sgroup->entry_count; i++) {\n\t\t/*TODO*/\n\t\tif (last_sample_in_entry + sgroup->sample_entries[i].sample_count > sample_number)\n\t\t\treturn GF_NOT_SUPPORTED;\n\t\tlast_sample_in_entry += sgroup->sample_entries[i].sample_count;\n\t}\n\n\tif (last_sample_in_entry == sample_number) {\n\t\tif (sgroup->sample_entries[sgroup->entry_count-1].group_description_index==sampleGroupDescriptionIndex)\n\t\t\treturn GF_OK;\n\t\telse\n\t\t\treturn GF_NOT_SUPPORTED;\n\t}\n\n\tif ((sgroup->sample_entries[sgroup->entry_count-1].group_description_index==sampleGroupDescriptionIndex) && (last_sample_in_entry+1==sample_number)) {\n\t\tsgroup->sample_entries[sgroup->entry_count-1].sample_count++;\n\t\treturn GF_OK;\n\t}\n\t/*last entry was an empty desc (no group associated), just add the number of samples missing until new one, then add new one*/\n\tif (! sgroup->sample_entries[sgroup->entry_count-1].group_description_index) {\n\t\tsgroup->sample_entries[sgroup->entry_count-1].sample_count += sample_number - 1 - last_sample_in_entry;\n\t\tsgroup->sample_entries = (GF_SampleGroupEntry*)gf_realloc(sgroup->sample_entries, sizeof(GF_SampleGroupEntry) * (sgroup->entry_count + 1) );\n\t\tsgroup->sample_entries[sgroup->entry_count].sample_count = 1;\n\t\tsgroup->sample_entries[sgroup->entry_count].group_description_index = sampleGroupDescriptionIndex;\n\t\tsgroup->entry_count++;\n\t\treturn GF_OK;\n\t}\n\t/*we are adding a sample with no desc, add entry at the end*/\n\tif (!sampleGroupDescriptionIndex || (sample_number - 1 - last_sample_in_entry==0) ) {\n\t\tsgroup->sample_entries = (GF_SampleGroupEntry*)gf_realloc(sgroup->sample_entries, sizeof(GF_SampleGroupEntry) * (sgroup->entry_count + 1) );\n\t\tsgroup->sample_entries[sgroup->entry_count].sample_count = 1;\n\t\tsgroup->sample_entries[sgroup->entry_count].group_description_index = sampleGroupDescriptionIndex;\n\t\tsgroup->entry_count++;\n\t\treturn GF_OK;\n\t}\n\t/*need to insert two entries ...*/\n\tsgroup->sample_entries = (GF_SampleGroupEntry*)gf_realloc(sgroup->sample_entries, sizeof(GF_SampleGroupEntry) * (sgroup->entry_count + 2) );\n\n\tsgroup->sample_entries[sgroup->entry_count].sample_count = sample_number - 1 - last_sample_in_entry;\n\tsgroup->sample_entries[sgroup->entry_count].group_description_index = def_insert_value;\n\n\tsgroup->sample_entries[sgroup->entry_count+1].sample_count = 1;\n\tsgroup->sample_entries[sgroup->entry_count+1].group_description_index = sampleGroupDescriptionIndex;\n\tsgroup->entry_count+=2;\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\nstatic GF_SampleGroupDescriptionBox *get_sgdp(GF_SampleTableBox *stbl, GF_TrackFragmentBox *traf, u32 grouping_type, Bool *is_traf_sgdp)\n#else\nstatic GF_SampleGroupDescriptionBox *get_sgdp(GF_SampleTableBox *stbl, void *traf, u32 grouping_type, Bool *is_traf_sgdp)\n#endif /* GPAC_DISABLE_ISOM_FRAGMENTS */\n{\n\tGF_List *groupList=NULL;\n\tGF_List **parent=NULL;\n\tGF_SampleGroupDescriptionBox *sgdesc=NULL;\n\tu32 count, i;\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (!stbl && traf && traf->trex->track->Media->information->sampleTable)\n\t\tstbl = traf->trex->track->Media->information->sampleTable;\n#endif\n\tif (stbl) {\n\t\tif (!stbl->sampleGroupsDescription && !traf)\n\t\t\tstbl->sampleGroupsDescription = gf_list_new();\n\n\t\tgroupList = stbl->sampleGroupsDescription;\n\t\tif (is_traf_sgdp) *is_traf_sgdp = GF_FALSE;\n\t\tparent = &stbl->child_boxes;\n\n\t\tcount = gf_list_count(groupList);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tsgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(groupList, i);\n\t\t\tif (sgdesc->grouping_type==grouping_type) break;\n\t\t\tsgdesc = NULL;\n\t\t}\n\t}\n\t\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t/*look in stbl or traf for sample sampleGroupsDescription*/\n\tif (!sgdesc && traf) {\n\t\tif (!traf->sampleGroupsDescription)\n\t\t\ttraf->sampleGroupsDescription = gf_list_new();\n\t\tgroupList = traf->sampleGroupsDescription;\n\t\tparent = &traf->child_boxes;\n\t\tif (is_traf_sgdp) *is_traf_sgdp = GF_TRUE;\n\n\t\tcount = gf_list_count(groupList);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tsgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(groupList, i);\n\t\t\tif (sgdesc->grouping_type==grouping_type) break;\n\t\t\tsgdesc = NULL;\n\t\t}\n\t}\n#endif\n\n\tif (!sgdesc) {\n\t\tsgdesc = (GF_SampleGroupDescriptionBox *) gf_isom_box_new_parent(parent, GF_ISOM_BOX_TYPE_SGPD);\n\t\tif (!sgdesc) return NULL;\n\t\tsgdesc->grouping_type = grouping_type;\n\t\tassert(groupList);\n\t\tgf_list_add(groupList, sgdesc);\n\t}\n\treturn sgdesc;\n}\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\nstatic GF_Err gf_isom_set_sample_group_info_ex(GF_SampleTableBox *stbl, GF_TrackFragmentBox *traf, u32 sample_number, u32 grouping_type, u32 grouping_type_parameter, void *udta, void *(*sg_create_entry)(void *udta), Bool (*sg_compare_entry)(void *udta, void *entry))\n#else\nstatic GF_Err gf_isom_set_sample_group_info_ex(GF_SampleTableBox *stbl, void *traf, u32 sample_number, u32 grouping_type, u32 grouping_type_parameter, void *udta, void *(*sg_create_entry)(void *udta), Bool (*sg_compare_entry)(void *udta, void *entry))\n#endif /* GPAC_DISABLE_ISOM_FRAGMENTS */\n{\n\tGF_List *groupList, *parent;\n\tvoid *entry;\n\tBool is_traf_sgpd;\n\tGF_SampleGroupDescriptionBox *sgdesc = NULL;\n\tu32 i, entry_idx;\n\n\tif (!stbl && !traf) return GF_BAD_PARAM;\n\n\tsgdesc = get_sgdp(stbl, traf, grouping_type, &is_traf_sgpd);\n\tif (!sgdesc) return GF_OUT_OF_MEM;\n\n\tentry = NULL;\n\tif (sg_compare_entry) {\n\t\tfor (i=0; i<gf_list_count(sgdesc->group_descriptions); i++) {\n\t\t\tentry = gf_list_get(sgdesc->group_descriptions, i);\n\t\t\tif (sg_compare_entry(udta, entry)) break;\n\t\t\tentry = NULL;\n\t\t}\n\t}\n\tif (!entry && sg_create_entry) {\n\t\tentry = sg_create_entry(udta);\n\t\tif (!entry) return GF_IO_ERR;\n\t\tif (traf && !is_traf_sgpd) {\n\t\t\tsgdesc = get_sgdp(NULL, traf, grouping_type, &is_traf_sgpd);\n\t\t}\n\t\tgf_list_add(sgdesc->group_descriptions, entry);\n\t}\n\tif (!entry)\n\t\tentry_idx = 0;\n\telse\n\t\tentry_idx = 1 + gf_list_find(sgdesc->group_descriptions, entry);\n\n\t/*look in stbl or traf for sample sampleGroups*/\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (traf) {\n\t\tif (!traf->sampleGroups)\n\t\t\ttraf->sampleGroups = gf_list_new();\n\t\tgroupList = traf->sampleGroups;\n\t\tparent = traf->child_boxes;\n\t\tif (entry_idx && is_traf_sgpd)\n\t\t\tentry_idx |= 0x10000;\n\t} else\n#endif\n\t{\n\t\tif (!stbl->sampleGroups)\n\t\t\tstbl->sampleGroups = gf_list_new();\n\t\tgroupList = stbl->sampleGroups;\n\t\tparent = stbl->child_boxes;\n\t}\n\n\treturn gf_isom_add_sample_group_entry(groupList, sample_number, sgdesc, grouping_type_parameter, entry_idx, parent, stbl);\n}\n\nstatic GF_Err gf_isom_set_sample_group_info_internal(GF_ISOFile *movie, u32 track, u32 trafID, u32 sample_number, u32 grouping_type, u32 grouping_type_parameter, void *udta, void *(*sg_create_entry)(void *udta), Bool (*sg_compare_entry)(void *udta, void *entry))\n{\n\tGF_Err e;\n\tGF_TrackBox *trak=NULL;\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tGF_TrackFragmentBox *traf=NULL;\n#endif\n\tif (!trafID && (movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY)) {\n\t\ttrak = gf_isom_get_track_from_file(movie, track);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\ttrafID = trak->Header->trackID;\n\t}\n\n\tif (trafID) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\tif (!movie->moof || !(movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY) )\n\t\t\treturn GF_BAD_PARAM;\n\n\t\ttraf = gf_isom_get_traf(movie, trafID);\n#else\n\t\treturn GF_NOT_SUPPORTED;\n#endif\n\n\t} else if (track) {\n\t\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\t\tif (e) return e;\n\n\t\ttrak = gf_isom_get_track_from_file(movie, track);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t}\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\treturn gf_isom_set_sample_group_info_ex(trak ? trak->Media->information->sampleTable : NULL, traf, sample_number, grouping_type, grouping_type_parameter, udta, sg_create_entry, sg_compare_entry);\n#else\n\treturn gf_isom_set_sample_group_info_ex(trak->Media->information->sampleTable, NULL, sample_number, grouping_type, grouping_type_parameter, udta, sg_create_entry, sg_compare_entry);\n#endif\n\n}\n\nvoid *sgpd_parse_entry(GF_SampleGroupDescriptionBox *p, GF_BitStream *bs, s32 bytes_in_box, u32 entry_size, u32 *total_bytes);\n\nGF_Err gf_isom_add_sample_group_info_internal(GF_ISOFile *movie, u32 track, u32 grouping_type, void *data, u32 data_size, u32 sgpd_flags, u32 *sampleGroupDescriptionIndex, Bool *is_traf_sgpd, Bool check_access, Bool *use_default, GF_SampleGroupDescriptionBox **out_sgdesc)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak=NULL;\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tGF_TrackFragmentBox *traf=NULL;\n#else\n\tvoid *traf=NULL;\n#endif\n\tu32 trafID=0;\n\tGF_DefaultSampleGroupDescriptionEntry *entry=NULL;\n\tGF_SampleGroupDescriptionBox *sgdesc = NULL;\n\tBool is_default = sgpd_flags & 0x80000000;\n\n\tif (sampleGroupDescriptionIndex) *sampleGroupDescriptionIndex = 0;\n\n\tif (movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY) {\n\t\ttrak = gf_isom_get_track_from_file(movie, track);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\ttrafID = trak->Header->trackID;\n\t}\n\n\tif (trafID) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\tif (!movie->moof || !(movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY) )\n\t\t\treturn GF_BAD_PARAM;\n\n\t\ttraf = gf_isom_get_traf(movie, trafID);\n#else\n\t\treturn GF_NOT_SUPPORTED;\n#endif\n\t} else {\n\t\tif (check_access) {\n\t\t\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\t\t\tif (e) return e;\n\t\t}\n\n\t\ttrak = gf_isom_get_track_from_file(movie, track);\n\t}\n\tif (!trak) return GF_BAD_PARAM;\n\n\t//get sample group desc for this grouping type\n\tsgdesc = get_sgdp(trak->Media->information->sampleTable, traf, grouping_type, is_traf_sgpd);\n\tif (!sgdesc) return GF_OUT_OF_MEM;\n\t//first time we create the sample group description, set flags\n\tif (!gf_list_count(sgdesc->group_descriptions) && !traf) {\n\t\tif (sgpd_flags&1) sgdesc->flags |= 1;\n\t\tif (sgpd_flags&2) sgdesc->flags |= 2;\n\t\tif (sgpd_flags&0x40000000) sgdesc->version=3;\n\t}\n\n\n\tGF_BitStream *bs = gf_bs_new(data, data_size, GF_BITSTREAM_READ);\n\tu32 bytes;\n\tentry = sgpd_parse_entry(sgdesc, bs, data_size, data_size, &bytes);\n\tgf_bs_del(bs);\n\tif (!entry) return GF_NON_COMPLIANT_BITSTREAM;\n\n\tif (out_sgdesc) *out_sgdesc = sgdesc;\n\n\n\t//find the same entry\n\tu32 k;\n\tfor (k=0; k<gf_list_count(sgdesc->group_descriptions); k++) {\n\t\tvoid *sgde_dst = gf_list_get(sgdesc->group_descriptions, k);\n\t\tif (gf_isom_is_identical_sgpd(entry, sgde_dst, sgdesc->grouping_type)) {\n\t\t\tif (sampleGroupDescriptionIndex) *sampleGroupDescriptionIndex = k+1;\n\t\t\tsgpd_del_entry(sgdesc->grouping_type, entry);\n\t\t\tif (use_default) {\n\t\t\t\tu32 idx = k+1;\n\t\t\t\tif (is_traf_sgpd && *is_traf_sgpd) idx |= 0x10000;\n\t\t\t\t*use_default = (sgdesc->default_description_index==idx) ? GF_TRUE : GF_FALSE;\n\t\t\t}\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\n\tif (traf && ! *is_traf_sgpd) {\n\t\tsgdesc = get_sgdp(NULL, traf, grouping_type, is_traf_sgpd);\n\t\tif (!sgdesc) return GF_OUT_OF_MEM;\n\t}\n\tif (out_sgdesc) *out_sgdesc = sgdesc;\n\n\te = gf_list_add(sgdesc->group_descriptions, entry);\n\tif (e) {\n\t\tsgpd_del_entry(sgdesc->grouping_type, entry);\n\t\treturn e;\n\t}\n\n#if 0\n\tif (grouping_type==GF_ISOM_SAMPLE_GROUP_OINF) {\n\t\tGF_OperatingPointsInformation *ptr = gf_isom_oinf_new_entry();\n\t\tGF_BitStream *bs=gf_bs_new(data, data_size, GF_BITSTREAM_READ);\n\t\te = gf_isom_oinf_read_entry(ptr, bs);\n\t\tgf_bs_del(bs);\n\t\tif (e) {\n\t\t\tgf_isom_oinf_del_entry(ptr);\n\t\t\treturn e;\n\t\t}\n\t\t//not in track, create new sgdp\n\t\tif (traf && ! *is_traf_sgpd) {\n\t\t\tsgdesc  = get_sgdp(NULL, traf, grouping_type, is_traf_sgpd);\n\t\t\tif (!sgdesc) return GF_OUT_OF_MEM;\n\t\t}\n\t\te = gf_list_add(sgdesc->group_descriptions, ptr);\n\t\tif (e) return e;\n\t\tentry = (GF_DefaultSampleGroupDescriptionEntry *) ptr;\n\t} else if (grouping_type==GF_ISOM_SAMPLE_GROUP_LINF) {\n\t\tGF_LHVCLayerInformation *ptr = gf_isom_linf_new_entry();\n\t\tGF_BitStream *bs=gf_bs_new(data, data_size, GF_BITSTREAM_READ);\n\t\te = gf_isom_linf_read_entry(ptr, bs);\n\t\tgf_bs_del(bs);\n\t\tif (e) {\n\t\t\tgf_isom_linf_del_entry(ptr);\n\t\t\treturn e;\n\t\t}\n\n\t\tif (traf && ! *is_traf_sgpd) {\n\t\t\tsgdesc = get_sgdp(NULL, traf, grouping_type, is_traf_sgpd);\n\t\t\tif (!sgdesc) return GF_OUT_OF_MEM;\n\t\t}\n\n\t\te = gf_list_add(sgdesc->group_descriptions, ptr);\n\t\tif (e) return e;\n\t\tentry = (GF_DefaultSampleGroupDescriptionEntry *) ptr;\n\t} else {\n\t\tu32 i, count=gf_list_count(sgdesc->group_descriptions);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_DefaultSampleGroupDescriptionEntry *ent = gf_list_get(sgdesc->group_descriptions, i);\n\t\t\tif ((ent->length == data_size) && !memcmp(ent->data, data, data_size)) {\n\t\t\t\tentry = ent;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tentry=NULL;\n\t\t}\n\t\tif (!entry) {\n\t\t\tGF_SAFEALLOC(entry, GF_DefaultSampleGroupDescriptionEntry);\n\t\t\tif (!entry) return GF_OUT_OF_MEM;\n\t\t\tentry->data = (u8*)gf_malloc(sizeof(char) * data_size);\n\t\t\tif (!entry->data) {\n\t\t\t\tgf_free(entry);\n\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t}\n\t\t\tentry->length = data_size;\n\t\t\tmemcpy(entry->data, data, sizeof(char) * data_size);\n\n\t\t\tif (traf && ! *is_traf_sgpd) {\n\t\t\t\tsgdesc = get_sgdp(NULL, traf, grouping_type, is_traf_sgpd);\n\t\t\t\tif (!sgdesc) return GF_OUT_OF_MEM;\n\t\t\t}\n\n\t\t\te = gf_list_add(sgdesc->group_descriptions, entry);\n\t\t\tif (e) {\n\t\t\t\tgf_free(entry->data);\n\t\t\t\tgf_free(entry);\n\t\t\t\treturn e;\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\n\tif (is_default && !sgdesc->default_description_index) {\n\t\tsgdesc->default_description_index = 1 + gf_list_find(sgdesc->group_descriptions, entry);\n\t\tif (sgdesc->version < 2) sgdesc->version = 2;\n\t\tif (is_traf_sgpd && *is_traf_sgpd) {\n\t\t\tsgdesc->default_description_index |= 0x10000;\n\t\t}\n\t}\n\tu32 grp_idx =  1 + gf_list_find(sgdesc->group_descriptions, entry);\n\tif (sampleGroupDescriptionIndex) *sampleGroupDescriptionIndex = grp_idx;\n\tif (use_default) {\n\t\tif (*is_traf_sgpd)\n\t\t\tgrp_idx |= 0x10000;\n\t\t*use_default = (sgdesc->default_description_index==grp_idx) ? GF_TRUE : GF_FALSE;\n\t}\n\treturn GF_OK;\n}\nGF_EXPORT\nGF_Err gf_isom_add_sample_group_info(GF_ISOFile *movie, u32 track, u32 grouping_type, void *data, u32 data_size, Bool is_default, u32 *sampleGroupDescriptionIndex)\n{\n\treturn gf_isom_add_sample_group_info_internal(movie, track, grouping_type, data, data_size, is_default ? 0x80000000 : 0, sampleGroupDescriptionIndex, NULL, GF_TRUE, NULL, NULL);\n}\n\nGF_Err gf_isom_set_sample_group_description_internal(GF_ISOFile *movie, u32 track, u32 sample_number, u32 grouping_type, u32 grouping_type_parameter, void *data, u32 data_size, Bool check_access, u32 sgpd_flags)\n{\n\tu32 sampleGroupDescriptionIndex, trafID=0;\n\tGF_Err e;\n\tGF_SampleGroupDescriptionBox *sgdesc=NULL;\n\tBool is_traf_sgpd, use_default=GF_FALSE;\n\tGF_List *groupList=NULL, *parent=NULL;\n\n\te = gf_isom_add_sample_group_info_internal(movie, track, grouping_type, data, data_size, sgpd_flags, &sampleGroupDescriptionIndex, &is_traf_sgpd, check_access, &use_default, &sgdesc);\n\tif (e) return e;\n\tif (use_default) return GF_OK;\n\n\tGF_SampleTableBox *stbl=NULL;\n\tGF_TrackBox *trak=NULL;\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tGF_TrackFragmentBox *traf=NULL;\n#endif\n\tif (movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY) {\n\t\ttrak = gf_isom_get_track_from_file(movie, track);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\ttrafID = trak->Header->trackID;\n\t}\n\n\tif (trafID) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\tif (!movie->moof || !(movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY) )\n\t\t\treturn GF_BAD_PARAM;\n\n\t\ttraf = gf_isom_get_traf(movie, trafID);\n#else\n\t\treturn GF_NOT_SUPPORTED;\n#endif\n\n\t} else if (track) {\n\t\tif (check_access) {\n\t\t\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\t\t\tif (e) return e;\n\t\t}\n\n\t\ttrak = gf_isom_get_track_from_file(movie, track);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t}\n\n\t/*look in stbl or traf for sample sampleGroups*/\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (traf) {\n\t\tif (!traf->sampleGroups)\n\t\t\ttraf->sampleGroups = gf_list_new();\n\t\tgroupList = traf->sampleGroups;\n\t\tparent = traf->child_boxes;\n\t\tif (sampleGroupDescriptionIndex && is_traf_sgpd)\n\t\t\tsampleGroupDescriptionIndex |= 0x10000;\n\t} else\n#endif\n\t{\n\t\tstbl = trak->Media->information->sampleTable;\n\t\tif (!stbl->sampleGroups)\n\t\t\tstbl->sampleGroups = gf_list_new();\n\t\tgroupList = stbl->sampleGroups;\n\t\tparent = stbl->child_boxes;\n\t}\n\n\treturn gf_isom_add_sample_group_entry(groupList, sample_number, sgdesc, grouping_type_parameter, sampleGroupDescriptionIndex, parent, stbl);\n\n}\n\nGF_Err gf_isom_set_sample_group_description(GF_ISOFile *movie, u32 track, u32 sample_number, u32 grouping_type, u32 grouping_type_parameter, void *data, u32 data_size, u32 sgpd_flags)\n{\n\treturn gf_isom_set_sample_group_description_internal(movie, track, sample_number, grouping_type, grouping_type_parameter, data, data_size, GF_TRUE, sgpd_flags);\n}\n\nGF_EXPORT\nGF_Err gf_isom_remove_sample_group(GF_ISOFile *movie, u32 track, u32 grouping_type)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tu32 count, i;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, track);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tif (trak->Media->information->sampleTable->sampleGroupsDescription) {\n\t\tcount = gf_list_count(trak->Media->information->sampleTable->sampleGroupsDescription);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_SampleGroupDescriptionBox *sgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(trak->Media->information->sampleTable->sampleGroupsDescription, i);\n\t\t\tif (sgdesc->grouping_type==grouping_type) {\n\t\t\t\tgf_isom_box_del_parent(&trak->Media->information->sampleTable->child_boxes, (GF_Box*)sgdesc);\n\t\t\t\tgf_list_rem(trak->Media->information->sampleTable->sampleGroupsDescription, i);\n\t\t\t\ti--;\n\t\t\t\tcount--;\n\t\t\t}\n\t\t}\n\t}\n\tif (trak->Media->information->sampleTable->sampleGroups) {\n\t\tcount = gf_list_count(trak->Media->information->sampleTable->sampleGroups);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_SampleGroupBox *sgroup = gf_list_get(trak->Media->information->sampleTable->sampleGroups, i);\n\t\t\tif (sgroup->grouping_type==grouping_type) {\n\t\t\t\tgf_isom_box_del_parent(&trak->Media->information->sampleTable->child_boxes, (GF_Box*)sgroup);\n\t\t\t\tgf_list_rem(trak->Media->information->sampleTable->sampleGroups, i);\n\t\t\t\ti--;\n\t\t\t\tcount--;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_add_sample_info(GF_ISOFile *movie, u32 track, u32 sample_number, u32 grouping_type, u32 sampleGroupDescriptionIndex, u32 grouping_type_parameter)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_List *groupList;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, track);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tif (!trak->Media->information->sampleTable->sampleGroups)\n\t\ttrak->Media->information->sampleTable->sampleGroups = gf_list_new();\n\n\n\tGF_SampleGroupDescriptionBox *sgdesc = get_sgdp(trak->Media->information->sampleTable, NULL, grouping_type, NULL);\n\tif (!sgdesc) return GF_BAD_PARAM;\n\n\tgroupList = trak->Media->information->sampleTable->sampleGroups;\n\treturn gf_isom_add_sample_group_entry(groupList, sample_number, sgdesc, grouping_type_parameter, sampleGroupDescriptionIndex, trak->Media->information->sampleTable->child_boxes, trak->Media->information->sampleTable);\n}\n\nvoid *sg_rap_create_entry(void *udta)\n{\n\tGF_VisualRandomAccessEntry *entry;\n\tu32 *num_leading_samples = (u32 *) udta;\n\tassert(udta);\n\tGF_SAFEALLOC(entry, GF_VisualRandomAccessEntry);\n\tif (!entry) return NULL;\n\tentry->num_leading_samples = *num_leading_samples;\n\tentry->num_leading_samples_known = entry->num_leading_samples ? 1 : 0;\n\treturn entry;\n}\n\nBool sg_rap_compare_entry(void *udta, void *entry)\n{\n\tu32 *num_leading_samples = (u32 *) udta;\n\tif (*num_leading_samples == ((GF_VisualRandomAccessEntry *)entry)->num_leading_samples) return GF_TRUE;\n\treturn GF_FALSE;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_sample_rap_group(GF_ISOFile *movie, u32 track, u32 sample_number, Bool is_rap, u32 num_leading_samples)\n{\n\treturn gf_isom_set_sample_group_info_internal(movie, track, 0, sample_number, GF_ISOM_SAMPLE_GROUP_RAP, 0, &num_leading_samples, is_rap ? sg_rap_create_entry : NULL, is_rap ? sg_rap_compare_entry : NULL);\n}\n\nGF_Err gf_isom_fragment_set_sample_rap_group(GF_ISOFile *movie, GF_ISOTrackID trackID, u32 sample_number_in_frag, Bool is_rap, u32 num_leading_samples)\n{\n\treturn gf_isom_set_sample_group_info_internal(movie, 0, trackID, sample_number_in_frag, GF_ISOM_SAMPLE_GROUP_RAP, 0, &num_leading_samples, is_rap ? sg_rap_create_entry : NULL, is_rap ? sg_rap_compare_entry : NULL);\n}\n\n\n\nvoid *sg_roll_create_entry(void *udta)\n{\n\tGF_RollRecoveryEntry *entry;\n\ts16 *roll_distance = (s16 *) udta;\n\tGF_SAFEALLOC(entry, GF_RollRecoveryEntry);\n\tif (!entry) return NULL;\n\tentry->roll_distance = *roll_distance;\n\treturn entry;\n}\n\nBool sg_roll_compare_entry(void *udta, void *entry)\n{\n\ts16 *roll_distance = (s16 *) udta;\n\tif (*roll_distance == ((GF_RollRecoveryEntry *)entry)->roll_distance) return GF_TRUE;\n\treturn GF_FALSE;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_sample_roll_group(GF_ISOFile *movie, u32 track, u32 sample_number, GF_ISOSampleRollType roll_type, s16 roll_distance)\n{\n\tu32 grp_type = (roll_type>=GF_ISOM_SAMPLE_PREROLL) ? GF_ISOM_SAMPLE_GROUP_PROL : GF_ISOM_SAMPLE_GROUP_ROLL;\n\tif (roll_type==GF_ISOM_SAMPLE_PREROLL_NONE)\n\t\troll_type = 0;\n\n\treturn gf_isom_set_sample_group_info_internal(movie, track, 0, sample_number, grp_type, 0, &roll_distance, roll_type ? sg_roll_create_entry : NULL, roll_type ? sg_roll_compare_entry : NULL);\n}\n\nGF_EXPORT\nGF_Err gf_isom_fragment_set_sample_roll_group(GF_ISOFile *movie, GF_ISOTrackID trackID, u32 sample_number_in_frag, GF_ISOSampleRollType roll_type, s16 roll_distance)\n{\n\tu32 grp_type = (roll_type>=GF_ISOM_SAMPLE_PREROLL) ? GF_ISOM_SAMPLE_GROUP_PROL : GF_ISOM_SAMPLE_GROUP_ROLL;\n\tif (roll_type==GF_ISOM_SAMPLE_PREROLL_NONE)\n\t\troll_type = 0;\n\n\treturn gf_isom_set_sample_group_info_internal(movie, 0, trackID, sample_number_in_frag, grp_type, 0, &roll_distance, roll_type ? sg_roll_create_entry : NULL, roll_type ? sg_roll_compare_entry : NULL);\n}\n\n\nvoid *sg_encryption_create_entry(void *udta)\n{\n\tGF_CENCSampleEncryptionGroupEntry *entry, *from_entry;\n\tGF_SAFEALLOC(entry, GF_CENCSampleEncryptionGroupEntry);\n\tif (!entry) return NULL;\n\tfrom_entry = (GF_CENCSampleEncryptionGroupEntry *)udta;\n\tmemcpy(entry, from_entry, sizeof(GF_CENCSampleEncryptionGroupEntry) );\n\tentry->key_info = gf_malloc(sizeof(u8) * entry->key_info_size);\n\tif (!entry->key_info) {\n\t\tgf_free(entry);\n\t\treturn NULL;\n\t}\n\tmemcpy(entry->key_info, from_entry->key_info, entry->key_info_size);\n\treturn entry;\n}\n\nBool sg_encryption_compare_entry(void *udta, void *_entry)\n{\n\tGF_CENCSampleEncryptionGroupEntry *entry = (GF_CENCSampleEncryptionGroupEntry *)_entry;\n\tGF_CENCSampleEncryptionGroupEntry *with_entry = (GF_CENCSampleEncryptionGroupEntry *)udta;\n\n\tif (entry->IsProtected != with_entry->IsProtected) return GF_FALSE;\n\tif (entry->skip_byte_block != with_entry->skip_byte_block) return GF_FALSE;\n\tif (entry->crypt_byte_block != with_entry->crypt_byte_block) return GF_FALSE;\n\tif (entry->key_info_size != with_entry->key_info_size) return GF_FALSE;\n\n\tif (!memcmp(entry->key_info, with_entry->key_info, with_entry->key_info_size))\n\t\treturn GF_TRUE;\n\treturn GF_FALSE;\n}\n\n\n/*sample encryption information group can be in stbl or traf*/\nGF_EXPORT\nGF_Err gf_isom_set_sample_cenc_group(GF_ISOFile *movie, u32 track, u32 sample_number, u8 isEncrypted, u8 crypt_byte_block, u8 skip_byte_block, u8 *key_info, u32 key_info_size)\n{\n\tGF_CENCSampleEncryptionGroupEntry entry;\n\tif (!key_info || (key_info_size<19))\n\t\treturn GF_BAD_PARAM;\n\n\tmemset(&entry, 0, sizeof(GF_CENCSampleEncryptionGroupEntry));\n\tentry.crypt_byte_block = crypt_byte_block;\n\tentry.skip_byte_block = skip_byte_block;\n\tentry.IsProtected = isEncrypted;\n\tentry.key_info = key_info;\n\tentry.key_info_size = key_info_size;\n\n\treturn gf_isom_set_sample_group_info_internal(movie, track, 0, sample_number, GF_ISOM_SAMPLE_GROUP_SEIG, 0, &entry, sg_encryption_create_entry, sg_encryption_compare_entry);\n}\n\n\n\nGF_EXPORT\nGF_Err gf_isom_set_sample_cenc_default_group(GF_ISOFile *movie, u32 track, u32 sample_number)\n{\n\treturn gf_isom_set_sample_group_info_internal(movie, track, 0, sample_number, GF_ISOM_SAMPLE_GROUP_SEIG, 0, NULL, NULL, NULL);\n}\n\nGF_Err gf_isom_force_ctts(GF_ISOFile *file, u32 track)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e = CanAccessMovie(file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n \ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) return GF_BAD_PARAM;\n\tif (trak->Media->information->sampleTable->CompositionOffset) return GF_OK;\n\n\ttrak->Media->information->sampleTable->CompositionOffset = (GF_CompositionOffsetBox *) gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_CTTS);\n\tif (!trak->Media->information->sampleTable->CompositionOffset) return GF_OUT_OF_MEM;\n\ttrak->Media->information->sampleTable->CompositionOffset->nb_entries = 1;\n\ttrak->Media->information->sampleTable->CompositionOffset->entries = gf_malloc(sizeof(GF_DttsEntry));\n\ttrak->Media->information->sampleTable->CompositionOffset->entries[0].decodingOffset = 0;\n\ttrak->Media->information->sampleTable->CompositionOffset->entries[0].sampleCount = \ttrak->Media->information->sampleTable->SampleSize->sampleCount;\n\treturn GF_OK;\n}\n\nGF_Err gf_isom_set_ctts_v1(GF_ISOFile *file, u32 track, u32 ctts_shift)\n{\n\tu32 i, shift;\n\tu64 duration;\n\tGF_CompositionOffsetBox *ctts;\n\tGF_CompositionToDecodeBox *cslg;\n\ts32 leastCTTS, greatestCTTS;\n\tGF_TrackBox *trak;\n\tGF_Err e = CanAccessMovie(file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n \ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tctts = trak->Media->information->sampleTable->CompositionOffset;\n\tif (ctts->version) {\n\t\tshift = ctts_shift;\n\t} else {\n\t\tshift = ctts->nb_entries ? ctts->entries[0].decodingOffset : 0;\n\t}\n\tleastCTTS = GF_INT_MAX;\n\tgreatestCTTS = 0;\n\tfor (i=0; i<ctts->nb_entries; i++) {\n\t\tif (!ctts->version)\n\t\t\tctts->entries[i].decodingOffset -= shift;\n\n\t\tif ((s32)ctts->entries[i].decodingOffset < leastCTTS)\n\t\t\tleastCTTS = ctts->entries[i].decodingOffset;\n\t\tif ((s32)ctts->entries[i].decodingOffset > greatestCTTS)\n\t\t\tgreatestCTTS = ctts->entries[i].decodingOffset;\n\t}\n\tif (!ctts->version) {\n\t\tctts->version = 1;\n\t\t//if we had edit lists, shift all media times by the given amount\n\t\tif (trak->editBox && trak->editBox->editList) {\n\t\t\tfor (i=0; i<gf_list_count(trak->editBox->editList->entryList); i++) {\n\t\t\t\tGF_EdtsEntry *ent = (GF_EdtsEntry*)gf_list_get(trak->editBox->editList->entryList, i);\n\t\t\t\t//empty edit\n\t\t\t\tif (ent->mediaTime<0) continue;\n\t\t\t\tif (ent->mediaTime>=shift) ent->mediaTime -= shift;\n\t\t\t\telse ent->mediaTime = 0;\n\t\t\t\t//no offset and last entry, trash edit\n\t\t\t\tif (!ent->mediaTime && (gf_list_count(trak->editBox->editList->entryList)==1)) {\n\t\t\t\t\tgf_isom_box_del_parent(&trak->child_boxes, (GF_Box *)trak->editBox);\n\t\t\t\t\ttrak->editBox = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSetTrackDuration(trak);\n\t\t}\n\t}\n\n\tif (!trak->Media->information->sampleTable->CompositionToDecode) {\n\t\ttrak->Media->information->sampleTable->CompositionToDecode = (GF_CompositionToDecodeBox *) gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_CSLG);\n\t\tif (!trak->Media->information->sampleTable->CompositionToDecode)\n\t\t\treturn GF_OUT_OF_MEM;\n\t}\n\n\tcslg = trak->Media->information->sampleTable->CompositionToDecode;\n\tif (cslg) {\n\t\tcslg->compositionToDTSShift = shift;\n\t\tcslg->leastDecodeToDisplayDelta = leastCTTS;\n\t\tcslg->greatestDecodeToDisplayDelta = greatestCTTS;\n\t\tcslg->compositionStartTime = 0;\n\t\t/*for our use case (first CTS set to 0), the composition end time is the media duration if it fits on 32 bits*/\n\t\tduration = gf_isom_get_media_duration(file, track);\n\t\tcslg->compositionEndTime = (duration<0x7FFFFFFF) ? (s32) duration : 0;\n\t}\n\n\tgf_isom_modify_alternate_brand(file, GF_ISOM_BRAND_ISO4, GF_TRUE);\n\treturn GF_OK;\n}\n\nstatic GF_Err gf_isom_set_ctts_v0(GF_ISOFile *file, GF_TrackBox *trak)\n{\n\tu32 i;\n\ts32 shift;\n\tGF_CompositionOffsetBox *ctts;\n\tGF_CompositionToDecodeBox *cslg;\n\n\tctts = trak->Media->information->sampleTable->CompositionOffset;\n\n\tif (!trak->Media->information->sampleTable->CompositionToDecode)\n\t{\n\t\tshift = 0;\n\t\tfor (i=0; i<ctts->nb_entries; i++) {\n\t\t\tif (-ctts->entries[i].decodingOffset > shift)\n\t\t\t\tshift = -ctts->entries[i].decodingOffset;\n\t\t}\n\t\tif (shift > 0)\n\t\t{\n\t\t\tfor (i=0; i<ctts->nb_entries; i++) {\n\t\t\t\ts64 new_ts = ctts->entries[i].decodingOffset;\n\t\t\t\tnew_ts += shift;\n\t\t\t\tctts->entries[i].decodingOffset = (s32) new_ts;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tcslg = trak->Media->information->sampleTable->CompositionToDecode;\n\t\tshift = cslg->compositionToDTSShift;\n\t\tfor (i=0; i<ctts->nb_entries; i++) {\n\t\t\ts64 new_ts = ctts->entries[i].decodingOffset;\n\t\t\tnew_ts += shift;\n\t\t\tctts->entries[i].decodingOffset = (s32) new_ts;\n\t\t}\n\t\tgf_isom_box_del_parent(&trak->Media->information->sampleTable->child_boxes, (GF_Box *)cslg);\n\t\ttrak->Media->information->sampleTable->CompositionToDecode = NULL;\n\t}\n\tif (shift>0) {\n\t\t//no edits, insert one\n\t\tif (! trak->editBox) {\n\t\t\tu64 dur = trak->Media->mediaHeader->duration;\n\t\t\tdur *= file->moov->mvhd->timeScale;\n\t\t\tdur /= trak->Media->mediaHeader->timeScale;\n\t\t\tgf_isom_set_edit(file, gf_list_find(file->moov->trackList, trak)+1, 0, dur, shift, GF_ISOM_EDIT_NORMAL);\n\t\t} else {\n\t\t\t//otherwise shift media times in all entries\n\t\t\tfor (i=0; i<gf_list_count(trak->editBox->editList->entryList); i++) {\n\t\t\t\tGF_EdtsEntry *ent = (GF_EdtsEntry*)gf_list_get(trak->editBox->editList->entryList, i);\n\t\t\t\t//empty edit\n\t\t\t\tif (ent->mediaTime<0) continue;\n\t\t\t\tent->mediaTime += shift;\n\t\t\t}\n\t\t\tSetTrackDuration(trak);\n\t\t}\n\t}\n\tctts->version = 0;\n\tgf_isom_modify_alternate_brand(file, GF_ISOM_BRAND_ISO4, GF_FALSE);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_composition_offset_mode(GF_ISOFile *file, u32 track, Bool use_negative_offsets)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_CompositionOffsetBox *ctts;\n\n\te = CanAccessMovie(file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tctts = trak->Media->information->sampleTable->CompositionOffset;\n\tif (!ctts) {\n\t\tif (!use_negative_offsets && trak->Media->information->sampleTable->CompositionToDecode) {\n\t\t\tgf_isom_box_del_parent(&trak->Media->information->sampleTable->child_boxes, (GF_Box *)trak->Media->information->sampleTable->CompositionToDecode);\n\t\t\ttrak->Media->information->sampleTable->CompositionToDecode = NULL;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\n\tif (use_negative_offsets) {\n\t\treturn gf_isom_set_ctts_v1(file, track, 0);\n\t} else {\n\t\tif (ctts->version==0) return GF_OK;\n\t\treturn gf_isom_set_ctts_v0(file, trak);\n\t}\n}\n\n#if 0 //unused\nGF_Err gf_isom_set_sync_table(GF_ISOFile *file, u32 track)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\n\te = CanAccessMovie(file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tif (!trak->Media->information->sampleTable->SyncSample) {\n\t\ttrak->Media->information->sampleTable->SyncSample = (GF_SyncSampleBox *) gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_STSS);\n\n\t\tif (!trak->Media->information->sampleTable->SyncSample)\n\t\t\treturn GF_OUT_OF_MEM;\n\t}\n\treturn GF_OK;\n}\n#endif\n\nGF_Err gf_isom_set_sample_flags(GF_ISOFile *file, u32 track, u32 sampleNumber, u32 isLeading, u32 dependsOn, u32 dependedOn, u32 redundant)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\n\te = CanAccessMovie(file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) return GF_BAD_PARAM;\n\treturn stbl_SetDependencyType(trak->Media->information->sampleTable, sampleNumber, isLeading, dependsOn, dependedOn, redundant);\n}\n\n#if 0 //unused\nGF_Err gf_isom_sample_set_dep_info(GF_ISOFile *file, u32 track, u32 sampleNumber, u32 isLeading, u32 dependsOn, u32 dependedOn, u32 redundant)\n{\n\tGF_TrackBox *trak;\n\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) return GF_BAD_PARAM;\n\n\treturn stbl_AddDependencyType(trak->Media->information->sampleTable, sampleNumber, isLeading, dependsOn, dependedOn, redundant);\n}\n#endif\n\nGF_EXPORT\nGF_Err gf_isom_copy_sample_info(GF_ISOFile *dst, u32 dst_track, GF_ISOFile *src, u32 src_track, u32 sampleNumber)\n{\n\tu32 i, count, idx, dst_sample_num, subs_flags;\n\tGF_SubSampleInfoEntry *sub_sample;\n\tGF_Err e;\n\tGF_TrackBox *src_trak, *dst_trak;\n\n\tsrc_trak = gf_isom_get_track_from_file(src, src_track);\n\tif (!src_trak) return GF_BAD_PARAM;\n\n\tdst_trak = gf_isom_get_track_from_file(dst, dst_track);\n\tif (!dst_trak) return GF_BAD_PARAM;\n\n\tdst_sample_num = dst_trak->Media->information->sampleTable->SampleSize->sampleCount;\n\n\t/*modify depends flags*/\n\tif (src_trak->Media->information->sampleTable->SampleDep) {\n\t\tu32 isLeading, dependsOn, dependedOn, redundant;\n\n\t\tisLeading = dependsOn = dependedOn = redundant = 0;\n\n\t\te = stbl_GetSampleDepType(src_trak->Media->information->sampleTable->SampleDep, sampleNumber, &isLeading, &dependsOn, &dependedOn, &redundant);\n\t\tif (e) return e;\n\n\t\te = stbl_AppendDependencyType(dst_trak->Media->information->sampleTable, isLeading, dependsOn, dependedOn, redundant);\n\t\tif (e) return e;\n\t}\n\n\t/*copy subsample info if any*/\n\tidx=1;\n\twhile (gf_isom_get_subsample_types(src, src_track, idx, &subs_flags)) {\n\t\tGF_SubSampleInformationBox *dst_subs=NULL;\n\t\tidx++;\n\n\t\tif ( ! gf_isom_sample_get_subsample_entry(src, src_track, sampleNumber, subs_flags, &sub_sample))\n\t\t\tcontinue;\n\n\t\t/*create subsample if needed*/\n\t\tif (!dst_trak->Media->information->sampleTable->sub_samples) {\n\t\t\tdst_trak->Media->information->sampleTable->sub_samples = gf_list_new();\n\t\t}\n\t\tcount = gf_list_count(dst_trak->Media->information->sampleTable->sub_samples);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tdst_subs = gf_list_get(dst_trak->Media->information->sampleTable->sub_samples, i);\n\t\t\tif (dst_subs->flags==subs_flags) break;\n\t\t\tdst_subs=NULL;\n\t\t}\n\t\tif (!dst_subs) {\n\t\t\tdst_subs = (GF_SubSampleInformationBox *) gf_isom_box_new_parent(&dst_trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_SUBS);\n\t\t\tif (!dst_subs) return GF_OUT_OF_MEM;\n\t\t\tdst_subs->version=0;\n\t\t\tdst_subs->flags = subs_flags;\n\t\t\tgf_list_add(dst_trak->Media->information->sampleTable->sub_samples, dst_subs);\n\t\t}\n\n\t\tcount = gf_list_count(sub_sample->SubSamples);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_SubSampleEntry *entry = (GF_SubSampleEntry*)gf_list_get(sub_sample->SubSamples, i);\n\t\t\te = gf_isom_add_subsample_info(dst_subs, dst_sample_num, entry->subsample_size, entry->subsample_priority, entry->reserved, entry->discardable);\n\t\t\tif (e) return e;\n\t\t}\n\t}\n\n\t/*copy sampleToGroup info if any*/\n\tcount = 0;\n\tif (src_trak->Media->information->sampleTable->sampleGroups)\n\t\tcount = gf_list_count(src_trak->Media->information->sampleTable->sampleGroups);\n\n\tfor (i=0; i<count; i++) {\n\t\tGF_SampleGroupBox *sg;\n\t\tu32 j, k, default_index;\n\t\tu32 first_sample_in_entry, last_sample_in_entry, group_desc_index_src, group_desc_index_dst;\n\t\tfirst_sample_in_entry = 1;\n\n\t\tsg = (GF_SampleGroupBox*)gf_list_get(src_trak->Media->information->sampleTable->sampleGroups, i);\n\t\tfor (j=0; j<sg->entry_count; j++) {\n\t\t\tGF_SampleGroupDescriptionBox *sgd_dst = NULL;\n\t\t\tlast_sample_in_entry = first_sample_in_entry + sg->sample_entries[j].sample_count - 1;\n\t\t\tif ((sampleNumber<first_sample_in_entry) || (sampleNumber>last_sample_in_entry)) {\n\t\t\t\tfirst_sample_in_entry = last_sample_in_entry+1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!dst_trak->Media->information->sampleTable->sampleGroups)\n\t\t\t\tdst_trak->Media->information->sampleTable->sampleGroups = gf_list_new();\n\n\t\t\tgroup_desc_index_src = group_desc_index_dst = sg->sample_entries[j].group_description_index;\n\n\t\t\tif (group_desc_index_src) {\n\t\t\t\tGF_SampleGroupDescriptionBox *sgd_src;\n\t\t\t\tvoid *sgde_src, *sgde_dst;\n\n\t\t\t\tgroup_desc_index_dst = 0;\n\t\t\t\t//check that the sample group description exists !!\n\t\t\t\tsgde_src = gf_isom_get_sample_group_info_entry(src, src_trak, sg->grouping_type, sg->sample_entries[j].group_description_index, &default_index, &sgd_src);\n\n\t\t\t\tif (!sgde_src) break;\n\n\t\t\t\tif (!dst_trak->Media->information->sampleTable->sampleGroupsDescription)\n\t\t\t\t\tdst_trak->Media->information->sampleTable->sampleGroupsDescription = gf_list_new();\n\n\t\t\t\tsgd_dst = NULL;\n\t\t\t\tfor (k=0; k< gf_list_count(dst_trak->Media->information->sampleTable->sampleGroupsDescription); k++) {\n\t\t\t\t\tsgd_dst = gf_list_get(dst_trak->Media->information->sampleTable->sampleGroupsDescription, k);\n\t\t\t\t\tif (sgd_dst->grouping_type==sgd_src->grouping_type) break;\n\t\t\t\t\tsgd_dst = NULL;\n\t\t\t\t}\n\t\t\t\tif (!sgd_dst) {\n\t\t\t\t\tgf_isom_clone_box( (GF_Box *) sgd_src, (GF_Box **) &sgd_dst);\n\t\t\t\t\tif (!sgd_dst) return GF_OUT_OF_MEM;\n\t\t\t\t\tgf_list_add(dst_trak->Media->information->sampleTable->sampleGroupsDescription, sgd_dst);\n\t\t\t\t\tgf_list_add(dst_trak->Media->information->sampleTable->child_boxes, sgd_dst);\n\t\t\t\t}\n\n\t\t\t\t//find the same entry\n\t\t\t\tfor (k=0; k<gf_list_count(sgd_dst->group_descriptions); k++) {\n\t\t\t\t\tsgde_dst = gf_list_get(sgd_dst->group_descriptions, k);\n\t\t\t\t\tif (gf_isom_is_identical_sgpd(sgde_src, sgde_dst, sgd_src->grouping_type)) {\n\t\t\t\t\t\tgroup_desc_index_dst = k+1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!group_desc_index_dst) {\n\t\t\t\t\tGF_SampleGroupDescriptionBox *cloned=NULL;\n\t\t\t\t\tgf_isom_clone_box( (GF_Box *) sgd_src, (GF_Box **)  &cloned);\n\t\t\t\t\tif (!cloned) return GF_OUT_OF_MEM;\n\t\t\t\t\tsgde_dst = gf_list_get(cloned->group_descriptions, group_desc_index_dst);\n\t\t\t\t\tgf_list_rem(cloned->group_descriptions, group_desc_index_dst);\n\t\t\t\t\tgf_isom_box_del( (GF_Box *) cloned);\n\t\t\t\t\tgf_list_add(sgd_dst->group_descriptions, sgde_dst);\n\t\t\t\t\tgroup_desc_index_dst = gf_list_count(sgd_dst->group_descriptions);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tgf_isom_get_sample_group_info_entry(dst, dst_trak, sg->grouping_type, 1, NULL, &sgd_dst);\n\t\t\t\tif (!sgd_dst) continue;\n\t\t\t}\n\n\t\t\t/*found our sample, add it to trak->sampleGroups*/\n\t\t\te = gf_isom_add_sample_group_entry(dst_trak->Media->information->sampleTable->sampleGroups, dst_sample_num, sgd_dst, sg->grouping_type_parameter, group_desc_index_dst, dst_trak->Media->information->sampleTable->child_boxes, NULL);\n\t\t\tif (e) return e;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t//copy auxiliary info\n\tcount = gf_list_count(src_trak->Media->information->sampleTable->sai_sizes);\n\tfor (i=0; i<count; i++) {\n\t\tu32 j;\n\t\tGF_SampleAuxiliaryInfoOffsetBox *saio = NULL;\n\t\tGF_SampleAuxiliaryInfoSizeBox *saiz = gf_list_get(src_trak->Media->information->sampleTable->sai_sizes, i);\n\n\t\tswitch (saiz->aux_info_type) {\n\t\tcase GF_ISOM_CENC_SCHEME:\n\t\tcase GF_ISOM_CBC_SCHEME:\n\t\tcase GF_ISOM_CENS_SCHEME:\n\t\tcase GF_ISOM_CBCS_SCHEME:\n\t\tcase GF_ISOM_PIFF_SCHEME:\n\t\tcase 0:\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\t//no aux sample associated\n\t\tif (saiz->sample_count<sampleNumber) continue;\n\t\t//no size associated\n\t\tif (!saiz->default_sample_info_size && !saiz->sample_info_size[sampleNumber-1]) continue;\n\n\t\tfor (j=0; j<gf_list_count(src_trak->Media->information->sampleTable->sai_offsets); j++) {\n\t\t\tsaio = gf_list_get(src_trak->Media->information->sampleTable->sai_offsets, j);\n\t\t\tif ((saio->aux_info_type==saiz->aux_info_type) && (saio->aux_info_type_parameter==saiz->aux_info_type_parameter)) break;\n\t\t\tsaio=NULL;\n\t\t}\n\t\tif (!saio) continue;\n\t\tif (!saio->offsets && !saio->sai_data) continue;\n\n\t\tu64 offset = saio->offsets ? saio->offsets[0] : 0;\n\t\tu32 nb_saio = saio->entry_count;\n\t\tif ((nb_saio>1) && (saio->entry_count != saiz->sample_count)) continue;\n\n\t\tu32 size;\n\n\t\tif (nb_saio == 1) {\n\t\t\tfor (j=0; j < sampleNumber-1; j++) {\n\t\t\t\tsize = saiz->default_sample_info_size ? saiz->default_sample_info_size : saiz->sample_info_size[j];\n\t\t\t\toffset += size;\n\t\t\t}\n\t\t} else {\n\t\t\toffset = saio->offsets[sampleNumber-1];\n\t\t}\n\n\t\tsize = saiz->default_sample_info_size ? saiz->default_sample_info_size : saiz->sample_info_size[j];\n\n\t\tif (saio->sai_data) {\n\t\t\te = gf_isom_add_sample_aux_info_internal(dst_trak, NULL, j+1, saiz->aux_info_type, saiz->aux_info_type_parameter, saio->sai_data->data + offset, size);\n\t\t} else {\n\t\t\tu8 *sai = gf_malloc(size);\n\t\t\tif (!sai) return GF_OUT_OF_MEM;\n\n\t\t\tu64 cur_position = gf_bs_get_position(src_trak->moov->mov->movieFileMap->bs);\n\t\t\tgf_bs_seek(src_trak->moov->mov->movieFileMap->bs, offset);\n\n\t\t\tgf_bs_read_data(src_trak->moov->mov->movieFileMap->bs, sai, size);\n\t\t\tgf_bs_seek(src_trak->moov->mov->movieFileMap->bs, cur_position);\n\t\t\te = gf_isom_add_sample_aux_info_internal(dst_trak, NULL, j+1, saiz->aux_info_type, saiz->aux_info_type_parameter, sai, size);\n\t\t\tgf_free(sai);\n\t\t}\n\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[isobmf] Failed to clone sai data: %s\\n\", gf_error_to_string(e) ));\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_text_set_display_flags(GF_ISOFile *file, u32 track, u32 desc_index, u32 flags, GF_TextFlagsMode op_type)\n{\n\tu32 i;\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\n\te = CanAccessMovie(file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tfor (i=0; i < gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes); i++) {\n\t\tGF_Tx3gSampleEntryBox *txt;\n\t\tif (desc_index && (i+1 != desc_index)) continue;\n\n\t\ttxt = (GF_Tx3gSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, i);\n\t\tif (txt->type != GF_ISOM_BOX_TYPE_TX3G) continue;\n\n\t\tswitch (op_type) {\n\t\tcase GF_ISOM_TEXT_FLAGS_TOGGLE:\n\t\t\ttxt->displayFlags |= flags;\n\t\t\tbreak;\n\t\tcase GF_ISOM_TEXT_FLAGS_UNTOGGLE:\n\t\t\ttxt->displayFlags &= ~flags;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttxt->displayFlags = flags;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn GF_OK;\n\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_update_duration(GF_ISOFile *movie)\n{\n\tu32 i;\n\tu64 maxDur;\n\tGF_TrackBox *trak;\n\n\tif (!movie || !movie->moov) return GF_BAD_PARAM;\n\n\t//if file was open in Write or Edit mode, recompute the duration\n\t//the duration of a movie is the MaxDuration of all the tracks...\n\n\tmaxDur = 0;\n\ti=0;\n\twhile ((trak = (GF_TrackBox *)gf_list_enum(movie->moov->trackList, &i))) {\n\t\tif( (movie->LastError = SetTrackDuration(trak))\t) return movie->LastError;\n\t\tif (trak->Header && (trak->Header->duration > maxDur))\n\t\t\tmaxDur = trak->Header->duration;\n\t}\n\tmovie->moov->mvhd->duration = maxDur;\n\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_update_edit_list_duration(GF_ISOFile *file, u32 track)\n{\n\tu32 i;\n\tu64 trackDuration;\n\tGF_EdtsEntry *ent;\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\n\te = CanAccessMovie(file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) return GF_BAD_PARAM;\n\n\n\t//the total duration is the media duration: adjust it in case...\n\te = Media_SetDuration(trak);\n\tif (e) return e;\n\n\t//assert the timeScales are non-NULL\n\tif (!trak->moov->mvhd->timeScale || !trak->Media->mediaHeader->timeScale) return GF_ISOM_INVALID_FILE;\n\ttrackDuration = (trak->Media->mediaHeader->duration * trak->moov->mvhd->timeScale) / trak->Media->mediaHeader->timeScale;\n\n\t//if we have an edit list, the duration is the sum of all the editList\n\t//entries' duration (always expressed in MovieTimeScale)\n\tif (trak->editBox && trak->editBox->editList) {\n\t\tu64 editListDuration = 0;\n\t\tGF_EditListBox *elst = trak->editBox->editList;\n\t\ti=0;\n\t\twhile ((ent = (GF_EdtsEntry*)gf_list_enum(elst->entryList, &i))) {\n\t\t\tif ((ent->mediaTime>=0) && (ent->mediaRate==0x10000) && (ent->segmentDuration > trackDuration))\n\t\t\t\tent->segmentDuration = trackDuration;\n\n\t\t\tif (!ent->segmentDuration) {\n\t\t\t\tu64 diff;\n\t\t\t\tent->segmentDuration = trackDuration;\n\t\t\t\tif (ent->mediaTime>0) {\n\t\t\t\t\tdiff = ent->mediaTime;\n\t\t\t\t\tdiff *= trak->moov->mvhd->timeScale;\n\t\t\t\t\tdiff /= trak->Media->mediaHeader->timeScale;\n\t\t\t\t\tif (diff < ent->segmentDuration)\n\t\t\t\t\t\tent->segmentDuration -= diff;\n\t\t\t\t\t/*\n\t\t\t\t\telse\n\t\t\t\t\t\tdiff = 0;\n\t\t\t\t\t*/\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((ent->mediaTime>=0) && ((u64) ent->mediaTime>=trak->Media->mediaHeader->duration)) {\n\t\t\t\tent->mediaTime = trak->Media->mediaHeader->duration;\n\t\t\t}\n\t\t\teditListDuration += ent->segmentDuration;\n\t\t}\n\t\ttrackDuration = editListDuration;\n\t}\n\tif (!trackDuration) {\n\t\ttrackDuration = (trak->Media->mediaHeader->duration * trak->moov->mvhd->timeScale) / trak->Media->mediaHeader->timeScale;\n\t}\n\ttrak->Header->duration = trackDuration;\n\n\treturn GF_OK;\n\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_clone_pssh(GF_ISOFile *output, GF_ISOFile *input, Bool in_moof) {\n\tGF_Box *a;\n\tu32 i;\n\ti = 0;\n\n\twhile ((a = (GF_Box *)gf_list_enum(input->moov->child_boxes, &i))) {\n\t\tif (a->type == GF_ISOM_BOX_TYPE_PSSH) {\n\t\t\tGF_List **child_boxes = &output->moov->child_boxes;\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\tif (in_moof)\n\t\t\t\tchild_boxes = &output->moof->child_boxes;\n#endif\n\n\t\t\tGF_ProtectionSystemHeaderBox *pssh = (GF_ProtectionSystemHeaderBox *)gf_isom_box_new_parent(child_boxes, GF_ISOM_BOX_TYPE_PSSH);\n\t\t\tif (!pssh) return GF_OUT_OF_MEM;\n\t\t\tmemmove(pssh->SystemID, ((GF_ProtectionSystemHeaderBox *)a)->SystemID, 16);\n\t\t\tif (((GF_ProtectionSystemHeaderBox *)a)->KIDs && ((GF_ProtectionSystemHeaderBox *)a)->KID_count > 0) {\n\t\t\t\tpssh->KID_count = ((GF_ProtectionSystemHeaderBox *)a)->KID_count;\n\t\t\t\tpssh->KIDs = (bin128 *)gf_malloc(pssh->KID_count*sizeof(bin128));\n\t\t\t\tif (!pssh->KIDs) return GF_OUT_OF_MEM;\n\t\t\t\tmemmove(pssh->KIDs, ((GF_ProtectionSystemHeaderBox *)a)->KIDs, pssh->KID_count*sizeof(bin128));\n\t\t\t}\n\t\t\tpssh->private_data_size = ((GF_ProtectionSystemHeaderBox *)a)->private_data_size;\n\t\t\tpssh->private_data = (u8 *)gf_malloc(pssh->private_data_size*sizeof(char));\n\t\t\tif (!pssh->private_data) return GF_OUT_OF_MEM;\n\t\t\tmemmove(pssh->private_data, ((GF_ProtectionSystemHeaderBox *)a)->private_data, pssh->private_data_size);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_track_group(GF_ISOFile *file, u32 track_number, u32 track_group_id, u32 group_type, Bool do_add)\n{\n\tu32 i, j;\n\tGF_TrackGroupTypeBox *trgt;\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\n\te = CanAccessMovie(file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(file, track_number);\n\tif (!trak) return GF_BAD_PARAM;\n\tif (!trak->groups) trak->groups = (GF_TrackGroupBox*) gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_TRGR);\n\tif (!trak->groups) return GF_OUT_OF_MEM;\n\n\tfor (j=0; j<gf_list_count(file->moov->trackList); j++) {\n\t\tGF_TrackBox *a_trak = gf_list_get(file->moov->trackList, j);\n\t\tif (!a_trak->groups) continue;\n\n\t\tfor (i=0; i<gf_list_count(a_trak->groups->groups); i++) {\n\t\t\ttrgt = gf_list_get(a_trak->groups->groups, i);\n\n\t\t\tif (trgt->track_group_id==track_group_id) {\n\t\t\t\tif (trgt->group_type != group_type) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"A track with same group ID is already defined for different group type %s\\n\", gf_4cc_to_str(trgt->group_type) ));\n\t\t\t\t\treturn GF_BAD_PARAM;\n\t\t\t\t}\n\t\t\t\tif (a_trak==trak) {\n\t\t\t\t\tif (!do_add) {\n\t\t\t\t\t\tgf_list_rem(trak->groups->groups, i);\n\t\t\t\t\t\tgf_isom_box_del_parent(&trak->groups->child_boxes, (GF_Box *)trgt);\n\t\t\t\t\t}\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//not found, add new group\n\ttrgt = (GF_TrackGroupTypeBox*) gf_isom_box_new_parent(&trak->groups->child_boxes, GF_ISOM_BOX_TYPE_TRGT);\n\tif (!trgt) return GF_OUT_OF_MEM;\n\ttrgt->track_group_id = track_group_id;\n\ttrgt->group_type = group_type;\n\treturn gf_list_add(trak->groups->groups, trgt);\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_nalu_length_field(GF_ISOFile *file, u32 track, u32 StreamDescriptionIndex, u32 nalu_size_length)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_MPEGVisualSampleEntryBox *ve;\n\tGF_SampleDescriptionBox *stsd;\n\n\te = CanAccessMovie(file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd || !StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (!entry || ! gf_isom_is_nalu_based_entry(trak->Media, entry)) {\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tve = (GF_MPEGVisualSampleEntryBox*)entry;\n\tif (ve->avc_config) ve->avc_config->config->nal_unit_size = nalu_size_length;\n\tif (ve->svc_config) ve->svc_config->config->nal_unit_size = nalu_size_length;\n\tif (ve->hevc_config) ve->hevc_config->config->nal_unit_size = nalu_size_length;\n\tif (ve->lhvc_config) ve->lhvc_config->config->nal_unit_size = nalu_size_length;\n\tif (ve->vvc_config) ve->vvc_config->config->nal_unit_size = nalu_size_length;\n\treturn GF_OK;\n}\n\nGF_Err gf_isom_set_sample_group_in_traf(GF_ISOFile *file)\n{\n\tGF_Err e;\n\te = CanAccessMovie(file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tfile->sample_groups_in_traf = GF_TRUE;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nvoid gf_isom_set_progress_callback(GF_ISOFile *file, void (*progress_cbk)(void *udta, u64 nb_done, u64 nb_total), void *progress_cbk_udta)\n{\n\tif (file) {\n\t\tfile->progress_cbk = progress_cbk;\n\t\tfile->progress_cbk_udta = progress_cbk_udta;\n\n\t}\n}\n\nGF_Err gf_isom_update_video_sample_entry_fields(GF_ISOFile *file, u32 track, u32 stsd_idx, u16 revision, u32 vendor, u32 temporalQ, u32 spatialQ, u32 horiz_res, u32 vert_res, u16 frames_per_sample, const char *compressor_name, s16 color_table_index)\n{\n\n\tGF_TrackBox *trak;\n\tGF_MPEGVisualSampleEntryBox *vid_ent;\n\n\t/*get orig sample desc and clone it*/\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak || !stsd_idx) return GF_BAD_PARAM;\n\n\tif (!trak->Media || !trak->Media->handler || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->SampleDescription)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tswitch (trak->Media->handler->handlerType) {\n\tcase GF_ISOM_MEDIA_VISUAL:\n    case GF_ISOM_MEDIA_AUXV:\n    case GF_ISOM_MEDIA_PICT:\n    \tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\tvid_ent = gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, stsd_idx-1);\n\tif (!vid_ent)\n\t\treturn GF_BAD_PARAM;\n\n\tvid_ent->revision = revision;\n\tvid_ent->vendor = vendor;\n\tvid_ent->temporal_quality = temporalQ;\n\tvid_ent->spatial_quality = spatialQ;\n\tvid_ent->horiz_res = horiz_res;\n\tvid_ent->vert_res = vert_res;\n\tvid_ent->frames_per_sample = frames_per_sample;\n\tif (compressor_name)\n\t\tstrncpy(vid_ent->compressor_name, compressor_name, 32);\n\n\tvid_ent->color_table_index = color_table_index;\n\treturn GF_OK;\n}\n\n\nGF_Err gf_isom_update_sample_description_from_template(GF_ISOFile *file, u32 track, u32 sampleDescriptionIndex, u8 *data, u32 size)\n{\n\tGF_BitStream *bs;\n\tGF_TrackBox *trak;\n\tGF_Box *ent, *tpl_ent;\n\tGF_Err e;\n\t/*get orig sample desc and clone it*/\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak || !sampleDescriptionIndex) return GF_BAD_PARAM;\n\n\tif (!trak->Media || !trak->Media->handler || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->SampleDescription)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tent = gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, sampleDescriptionIndex-1);\n\tif (!ent) return GF_BAD_PARAM;\n\n\tbs = gf_bs_new(data, size, GF_BITSTREAM_READ);\n//\te = gf_isom_box_parse(&tpl_ent, bs);\n\te = gf_isom_box_parse_ex(&tpl_ent, bs, GF_ISOM_BOX_TYPE_STSD, GF_FALSE, 0);\n\tgf_bs_del(bs);\n\tif (e) return e;\n\n\twhile (gf_list_count(tpl_ent->child_boxes)) {\n\t\tu32 j=0;\n\t\tBool found = GF_FALSE;\n\t\tGF_Box *abox = gf_list_pop_front(tpl_ent->child_boxes);\n\n\t\tswitch (abox->type) {\n\t\tcase GF_ISOM_BOX_TYPE_SINF:\n\t\tcase GF_ISOM_BOX_TYPE_RINF:\n\t\tcase GF_ISOM_BOX_TYPE_BTRT:\n\t\t\tfound = GF_TRUE;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (found) {\n\t\t\tgf_isom_box_del(abox);\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif (!ent->child_boxes) ent->child_boxes = gf_list_new();\n\t\tfor (j=0; j<gf_list_count(ent->child_boxes); j++) {\n\t\t\tGF_Box *b = gf_list_get(ent->child_boxes, j);\n\t\t\tif (b->type == abox->type) {\n\t\t\t\tfound = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!found) {\n\t\t\tgf_list_add(ent->child_boxes, abox);\n\t\t} else {\n\t\t\tgf_isom_box_del(abox);\n\t\t}\n\t}\n\tgf_isom_box_del(tpl_ent);\n\n\t//patch for old export\n\tGF_Box *abox = gf_isom_box_find_child(ent->child_boxes, GF_ISOM_BOX_TYPE_SINF);\n\tif (abox) {\n\t\tgf_list_del_item(ent->child_boxes, abox);\n\t\tgf_list_add(ent->child_boxes, abox);\n\t}\n\treturn GF_OK;\n}\n\n\n#include <gpac/xml.h>\nGF_EXPORT\nGF_Err gf_isom_apply_box_patch(GF_ISOFile *file, GF_ISOTrackID globalTrackID, const char *box_patch_filename, Bool for_fragments)\n{\n\tGF_Err e;\n\tGF_DOMParser *dom;\n\tu32 i;\n\tGF_XMLNode *root;\n\tu8 *box_data=NULL;\n\tu32 box_data_size;\n\tif (!file || !box_patch_filename) return GF_BAD_PARAM;\n#ifdef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (for_fragments) return GF_NOT_SUPPORTED;\n#endif\n\tdom = gf_xml_dom_new();\n\tif (strstr(box_patch_filename, \"<?xml\")) {\n\t\te = gf_xml_dom_parse_string(dom, (char *) box_patch_filename);\n\t} else {\n\t\te = gf_xml_dom_parse(dom, box_patch_filename, NULL, NULL);\n\t}\n\tif (e) goto err_exit;\n\n\troot = gf_xml_dom_get_root(dom);\n\tif (!root || strcmp(root->name, \"GPACBOXES\")) {\n\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\tgoto err_exit;\n\t}\n\n\t//compute size of each child boxes to freeze the order\n\tif (for_fragments) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\tu32 count = file->moof ? gf_list_count(file->moof->child_boxes) : 0;\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_Box *box = gf_list_get(file->moof->child_boxes, i);\n\t\t\tif (!(box->internal_flags & GF_ISOM_ORDER_FREEZE)) {\n\t\t\t\tgf_isom_box_size(box);\n\t\t\t\tgf_isom_box_freeze_order(box);\n\t\t\t}\n\t\t}\n#endif\n\t} else {\n\t\tfor (i=0; i<gf_list_count(file->TopBoxes); i++) {\n\t\t\tGF_Box *box = gf_list_get(file->TopBoxes, i);\n\t\t\tif (!(box->internal_flags & GF_ISOM_ORDER_FREEZE)) {\n\t\t\t\tgf_isom_box_size(box);\n\t\t\t\tgf_isom_box_freeze_order(box);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i=0; i<gf_list_count(root->content); i++) {\n\t\tu32 j;\n\t\tu32 path_len;\n\t\tBool essential_prop=GF_FALSE;\n\t\tu32 trackID=globalTrackID;\n\t\tu32 item_id=trackID;\n\t\tBool is_frag_box;\n\t\tchar *box_path=NULL;\n\t\tGF_Box *parent_box = NULL;\n\t\tGF_XMLNode *box_edit = gf_list_get(root->content, i);\n\t\tif (!box_edit->name || strcmp(box_edit->name, \"Box\")) continue;\n\n\t\tfor (j=0; j<gf_list_count(box_edit->attributes);j++) {\n\t\t\tGF_XMLAttribute *att = gf_list_get(box_edit->attributes, j);\n\t\t\tif (!strcmp(att->name, \"path\")) box_path = att->value;\n\t\t\telse if (!strcmp(att->name, \"essential\")) {\n\t\t\t\tif (!strcmp(att->value, \"yes\") || !strcmp(att->value, \"true\") || !strcmp(att->value, \"1\")) {\n\t\t\t\t\tessential_prop=GF_TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!strcmp(att->name, \"itemID\"))\n\t\t\t\titem_id = atoi(att->value);\n\t\t\telse if (!globalTrackID && !strcmp(att->name, \"trackID\"))\n\t\t\t\ttrackID = atoi(att->value);\n\t\t}\n\n\t\tif (!box_path) continue;\n\t\tpath_len = (u32) strlen(box_path);\n\n\t\tis_frag_box = !strncmp(box_path, \"traf\", 4) ? GF_TRUE : GF_FALSE;\n\n\t\tif (for_fragments && !is_frag_box) continue;\n\t\telse if (!for_fragments && is_frag_box) continue;\n\n\t\tgf_xml_parse_bit_sequence(box_edit, box_patch_filename, &box_data, &box_data_size);\n\t\tif (box_data_size && (box_data_size<4) ) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[ISOBMFF] Wrong BS specification for box, shall either be empty or at least 4 bytes for box type\\n\"));\n\t\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\tgoto err_exit;\n\t\t}\n\n\t\twhile (box_path && (path_len>=4)) {\n\t\t\tu32 parent_list_box_type;\n\t\t\tGF_List **parent_list;\n\t\t\tu32 box_type = GF_4CC(box_path[0],box_path[1],box_path[2],box_path[3]);\n\t\t\tGF_Box *box=NULL;\n\t\t\tGF_BitStream *bs;\n\t\t\ts32 insert_pos = -1;\n\t\t\tbox_path+=4;\n\t\t\tpath_len-=4;\n\n\t\t\tif (!parent_box) {\n\t\t\t\tbox=gf_isom_box_find_child(file->TopBoxes, box_type);\n\t\t\t\tif (!box) {\n\t\t\t\t\tif (box_type==GF_ISOM_BOX_TYPE_TRAK) {\n\t\t\t\t\t\tif (trackID) {\n\t\t\t\t\t\t\tbox = (GF_Box *) gf_isom_get_track_from_file(file, gf_isom_get_track_by_id(file, trackID) );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!box && gf_list_count(file->moov->trackList)==1) {\n\t\t\t\t\t\t\tbox = gf_list_get(file->moov->trackList, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\t\t\telse if (box_type==GF_ISOM_BOX_TYPE_TRAF) {\n\t\t\t\t\t\tif (trackID) {\n\t\t\t\t\t\t\tbox = (GF_Box *) gf_isom_get_traf(file, trackID);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!box && file->moof && gf_list_count(file->moof->TrackList)==1) {\n\t\t\t\t\t\t\tbox = gf_list_get(file->moof->TrackList, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#endif\n\t\t\t\t}\n\t\t\t\tif (!box) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[ISOBMFF] Cannot locate box type %s at root or as track\\n\", gf_4cc_to_str(box_type) ));\n\t\t\t\t\te = GF_BAD_PARAM;\n\t\t\t\t\tgoto err_exit;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbox = gf_isom_box_find_child(parent_box->child_boxes, box_type);\n\t\t\t\tif (!box) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[ISOBMFF] Cannot locate box type %s at child of %s\\n\", gf_4cc_to_str(box_type), gf_4cc_to_str(parent_box->type)));\n\t\t\t\t\te = GF_BAD_PARAM;\n\t\t\t\t\tgoto err_exit;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// '.' is child access\n\t\t\tif (path_len && (box_path[0]=='.')) {\n\t\t\t\tbox_path += 1;\n\t\t\t\tpath_len-=1;\n\t\t\t\tparent_box = box;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (parent_box && !parent_box->child_boxes) parent_box->child_boxes = gf_list_new();\n\t\t\tparent_list = parent_box ? &parent_box->child_boxes : &file->TopBoxes;\n\t\t\tparent_list_box_type = parent_box ? parent_box->type : 0;\n\n\t\t\t// '+' is append after, '-' is insert before\n\t\t\tif (path_len && ((box_path[0]=='-') || (box_path[0]=='+')) ) {\n\t\t\t\ts32 idx = gf_list_find(*parent_list, box);\n\t\t\t\tassert(idx>=0);\n\t\t\t\tif (box_path[0]=='+') insert_pos = idx+1;\n\t\t\t\telse insert_pos = idx;\n\t\t\t}\n\t\t\telse if (path_len) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[ISOBMFF] Invalid path %s, expecting either '-', '+' or '.' as separators\\n\", box_path));\n\t\t\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\tgoto err_exit;\n\t\t\t}\n\n\t\t\tif (!box_data) {\n\t\t\t\tif (insert_pos>=0) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[ISOBMFF] Invalid path %s for box removal, ignoring position\\n\", box_path));\n\t\t\t\t}\n\t\t\t\tswitch (box->type) {\n\t\t\t\tcase GF_ISOM_BOX_TYPE_MOOV:\n\t\t\t\t\tfile->moov = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_ISOM_BOX_TYPE_MDAT:\n\t\t\t\t\tfile->mdat = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_ISOM_BOX_TYPE_PDIN:\n\t\t\t\t\tfile->pdin = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_ISOM_BOX_TYPE_FTYP:\n\t\t\t\t\tfile->brand = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_ISOM_BOX_TYPE_META:\n\t\t\t\t\tif ((GF_Box *) file->meta == box) file->meta = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (parent_box) {\n\t\t\t\t\tgf_isom_box_remove_from_parent(parent_box, box);\n\t\t\t\t}\n\t\t\t\tgf_isom_box_del_parent(parent_list, box);\n\t\t\t} else {\n\t\t\t\tu32 size;\n\n\t\t\t\tbs = gf_bs_new(box_data, box_data_size, GF_BITSTREAM_READ);\n\t\t\t\tsize = gf_bs_read_u32(bs);\n\t\t\t\tif (size != box_data_size) {\n\t\t\t\t\tGF_UnknownBox *new_box = (GF_UnknownBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_UNKNOWN);\n\t\t\t\t\tnew_box->original_4cc = size;\n\t\t\t\t\tnew_box->dataSize = (u32) gf_bs_available(bs);\n\t\t\t\t\tnew_box->data = gf_malloc(sizeof(u8)*new_box->dataSize);\n\t\t\t\t\tgf_bs_read_data(bs, new_box->data, new_box->dataSize);\n\t\t\t\t\tif (insert_pos<0) {\n\t\t\t\t\t\tgf_list_add(box->child_boxes, new_box);\n\t\t\t\t\t\tinsert_pos = gf_list_find(box->child_boxes, new_box);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgf_list_insert(*parent_list, new_box, insert_pos);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (parent_box && (parent_box->type==GF_ISOM_BOX_TYPE_IPRP)) {\n\t\t\t\t\t\tGF_ItemPropertyAssociationBox *ipma = (GF_ItemPropertyAssociationBox *) gf_isom_box_find_child(parent_box->child_boxes, GF_ISOM_BOX_TYPE_IPMA);\n\t\t\t\t\t\tif (!item_id) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[ISOBMFF] Inserting box in ipco without itemID, no association added\\n\"));\n\t\t\t\t\t\t} else if (ipma) {\n\t\t\t\t\t\t\tu32 nb_asso, k;\n\t\t\t\t\t\t\tGF_ItemPropertyAssociationEntry *entry = NULL;\n\t\t\t\t\t\t\tnb_asso = gf_list_count(ipma->entries);\n\t\t\t\t\t\t\tfor (k=0; k<nb_asso;k++) {\n\t\t\t\t\t\t\t\tentry = gf_list_get(ipma->entries, k);\n\t\t\t\t\t\t\t\tif (entry->item_id==item_id) break;\n\t\t\t\t\t\t\t\tentry = NULL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!entry) {\n\t\t\t\t\t\t\t\tGF_SAFEALLOC(entry, GF_ItemPropertyAssociationEntry);\n\t\t\t\t\t\t\t\tif (!entry) return GF_OUT_OF_MEM;\n\t\t\t\t\t\t\t\tgf_list_add(ipma->entries, entry);\n\t\t\t\t\t\t\t\tentry->item_id = item_id;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tentry->associations = gf_realloc(entry->associations, sizeof(GF_ItemPropertyAssociationSlot) * (entry->nb_associations+1));\n\t\t\t\t\t\t\tentry->associations[entry->nb_associations].essential = essential_prop;\n\t\t\t\t\t\t\tentry->associations[entry->nb_associations].index = 1+insert_pos;\n\t\t\t\t\t\t\tentry->nb_associations++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tu32 box_idx = 0;\n\n\t\t\t\t\tgf_bs_seek(bs, 0);\n\t\t\t\t\twhile (gf_bs_available(bs)) {\n\t\t\t\t\t\tGF_Box *new_box;\n\t\t\t\t\t\te = gf_isom_box_parse_ex(&new_box, bs, (insert_pos<0) ? box->type : parent_list_box_type, parent_box ? GF_FALSE : GF_TRUE, 0);\n\t\t\t\t\t\tif (e) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[ISOBMFF] failed to parse box\\n\", box_path));\n\t\t\t\t\t\t\tgf_bs_del(bs);\n\t\t\t\t\t\t\tgoto err_exit;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (insert_pos<0) {\n\t\t\t\t\t\t\tgf_list_add(box->child_boxes, new_box);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgf_list_insert(*parent_list, new_box, insert_pos+box_idx);\n\t\t\t\t\t\t\tbox_idx++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgf_bs_del(bs);\n\n\t\t\t}\n\t\t\tgf_free(box_data);\n\t\t\tbox_data = NULL;\n\t\t\tbox_path = NULL;\n\t\t}\n\t}\n\nerr_exit:\n\n\tgf_xml_dom_del(dom);\n\tif (box_data) gf_free(box_data);\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_track_magic(GF_ISOFile *movie, u32 trackNumber, u64 magic)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\ttrak->magic = magic;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_track_index(GF_ISOFile *movie, u32 trackNumber, u32 index, void (*track_num_changed)(void *udta, u32 old_track_num, u32 new_track_num), void *udta)\n{\n\tu32 i, j, count;\n\tGF_List *tracks;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !index) return GF_BAD_PARAM;\n\ttrak->index = index;\n\ttracks = gf_list_new();\n\tcount = gf_list_count(movie->moov->trackList);\n\t//sort tracks in new list\n\tfor (i=0; i<count; i++) {\n\t\tGF_TrackBox *a_tk = gf_list_get(movie->moov->trackList, i);\n\t\tif (!a_tk->index) {\n\t\t\tgf_list_insert(tracks, a_tk, 0);\n\t\t} else {\n\t\t\tfor (j=0; j<gf_list_count(tracks); j++) {\n\t\t\t\tGF_TrackBox *a_tki = gf_list_get(tracks, j);\n\t\t\t\tif (a_tki->index<a_tk->index) continue;\n\t\t\t\tgf_list_insert(tracks, a_tk, j);\n\t\t\t\ta_tk = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (a_tk)\n\t\t\t\tgf_list_add(tracks, a_tk);\n\t\t}\n\t}\n\tif (gf_list_count(tracks) != count) {\n\t\tgf_list_del(tracks);\n\t\treturn GF_OUT_OF_MEM;\n\t}\n\tif (track_num_changed) {\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_TrackBox *a_tk = gf_list_get(tracks, i);\n\t\t\ts32 old_pos = gf_list_find(movie->moov->trackList, a_tk);\n\t\t\tassert(old_pos>=0);\n\t\t\tif (old_pos != i)\n\t\t\t\ttrack_num_changed(udta, old_pos+1, i+1);\n\t\t}\n\t}\n\tgf_list_del(movie->moov->trackList);\n\tmovie->moov->trackList = tracks;\n\tfor (j=0; j<gf_list_count(tracks); j++) {\n\t\tGF_TrackBox *tki = gf_list_get(tracks, j);\n\t\ttki->index = j+1;\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_ipod_compatible(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\n\te = CanAccessMovie(the_file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media) return GF_BAD_PARAM;\n\tentry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, 0);\n\tif (!entry) return GF_OK;\n\tswitch (entry->type) {\n\tcase GF_ISOM_BOX_TYPE_AVC1:\n\tcase GF_ISOM_BOX_TYPE_AVC2:\n\tcase GF_ISOM_BOX_TYPE_AVC3:\n\tcase GF_ISOM_BOX_TYPE_AVC4:\n\tcase GF_ISOM_BOX_TYPE_SVC1:\n\tcase GF_ISOM_BOX_TYPE_MVC1:\n\tcase GF_ISOM_BOX_TYPE_HVC1:\n\tcase GF_ISOM_BOX_TYPE_HEV1:\n\tcase GF_ISOM_BOX_TYPE_HVT1:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_OK;\n\t}\n\n\tif (!entry->ipod_ext) {\n\t\tentry->ipod_ext = (GF_UnknownUUIDBox *) gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_UUID);\n\t\tif (!entry->ipod_ext) return GF_OUT_OF_MEM;\n\t}\n\tmemcpy(entry->ipod_ext->uuid, GF_ISOM_IPOD_EXT, sizeof(u8)*16);\n\tentry->ipod_ext->dataSize = 4;\n\tentry->ipod_ext->data = gf_malloc(sizeof(u8)*4);\n\tif (!entry->ipod_ext->data) return GF_OUT_OF_MEM;\n\tmemset(entry->ipod_ext->data, 0, sizeof(u8)*4);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nBool gf_isom_is_inplace_rewrite(GF_ISOFile *movie)\n{\n\tif (!movie) return GF_FALSE;\n\tif (!movie->no_inplace_rewrite) {\n\t\t//things where added to the file, no inplace rewrite\n\t\tif (movie->editFileMap && gf_bs_get_size(movie->editFileMap->bs))\n\t\t\tmovie->no_inplace_rewrite = GF_TRUE;\n\t\t//block redirect (used by mp4mx), no inplace rewrite\n\t\telse if (movie->on_block_out || !strcmp(movie->finalName, \"_gpac_isobmff_redirect\"))\n\t\t\tmovie->no_inplace_rewrite = GF_TRUE;\n\t\t//stdout redirect, no inplace rewrite\n\t\telse if (!strcmp(movie->finalName, \"std\"))\n\t\t\tmovie->no_inplace_rewrite = GF_TRUE;\n\t\t//new file, no inplace rewrite\n\t\telse if (!movie->fileName)\n\t\t\tmovie->no_inplace_rewrite = GF_TRUE;\n\t}\n\tif (movie->no_inplace_rewrite) return GF_FALSE;\n\n\treturn GF_TRUE;\n}\n\nGF_EXPORT\nvoid gf_isom_disable_inplace_rewrite(GF_ISOFile *movie)\n{\n\tif (movie)\n\t\tmovie->no_inplace_rewrite = GF_TRUE;\n}\n\n\nGF_Err gf_isom_set_y3d_info(GF_ISOFile *movie, u32 trackNumber, u32 sampleDescriptionIndex, GF_ISOM_Y3D_Info *info)\n{\n\tGF_Err e;\n\tu32 proj_type;\n\tGF_SampleEntryBox *ent;\n\tGF_TrackBox *trak;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media || !info) return GF_BAD_PARAM;\n\n\tent = gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, sampleDescriptionIndex-1);\n\tif (!ent) return GF_BAD_PARAM;\n\n\tif (info->projection_type > GF_PROJ360_EQR) return GF_NOT_SUPPORTED;\n\n\tGF_Stereo3DBox *st3d = (GF_Stereo3DBox *) gf_isom_box_find_child(ent->child_boxes, GF_ISOM_BOX_TYPE_ST3D);\n\tif (st3d) {\n\t\tif (info->stereo_type) {\n\t\t\tst3d->stereo_type = info->stereo_type;\n\t\t} else {\n\t\t\tgf_isom_box_del_parent(&ent->child_boxes, (GF_Box *) st3d);\n\t\t}\n\t} else if (info->stereo_type) {\n\t\tst3d = (GF_Stereo3DBox *) gf_isom_box_new_parent(&ent->child_boxes, GF_ISOM_BOX_TYPE_ST3D);\n\t\tif (!st3d) return GF_OUT_OF_MEM;\n\t\tst3d->stereo_type = info->stereo_type;\n\t}\n\n\n\tGF_Box *sv3d = gf_isom_box_find_child(ent->child_boxes, GF_ISOM_BOX_TYPE_SV3D);\n\tif (sv3d && !info->projection_type) {\n\t\tgf_isom_box_del_parent(&ent->child_boxes, sv3d);\n\t\treturn GF_OK;\n\t}\n\n\tif (!sv3d && !info->projection_type) {\n\t\treturn GF_OK;\n\t}\n\tif (!sv3d) {\n\t\tsv3d = gf_isom_box_new_parent(&ent->child_boxes, GF_ISOM_BOX_TYPE_SV3D);\n\t\tif (!sv3d) return GF_OUT_OF_MEM;\n\t}\n\n\t//svhd mandatory\n\tGF_SphericalVideoInfoBox *svhd = (GF_SphericalVideoInfoBox *) gf_isom_box_find_child(sv3d->child_boxes, GF_ISOM_BOX_TYPE_SVHD);\n\tif (svhd) {\n\t\tif (svhd->string) gf_free(svhd->string);\n\t} else {\n\t\tsvhd = (GF_SphericalVideoInfoBox *) gf_isom_box_new_parent(&sv3d->child_boxes, GF_ISOM_BOX_TYPE_SVHD);\n\t\tif (!svhd) return GF_OUT_OF_MEM;\n\t}\n\tsvhd->string = gf_strdup(info->meta_data ? info->meta_data : \"\");\n\n\t//proj mandatory\n\tGF_Box *proj = gf_isom_box_find_child(sv3d->child_boxes, GF_ISOM_BOX_TYPE_PROJ);\n\tif (!proj) {\n\t\tproj = gf_isom_box_new_parent(&sv3d->child_boxes, GF_ISOM_BOX_TYPE_PROJ);\n\t\tif (!proj) return GF_OUT_OF_MEM;\n\t}\n\n\tGF_ProjectionHeaderBox *projh = (GF_ProjectionHeaderBox *) gf_isom_box_find_child(proj->child_boxes, GF_ISOM_BOX_TYPE_PRHD);\n\t//prj header mandatory\n\tif (!projh) {\n\t\tprojh = (GF_ProjectionHeaderBox *) gf_isom_box_new_parent(&proj->child_boxes, GF_ISOM_BOX_TYPE_PRHD);\n\t\tif (!projh) return GF_OUT_OF_MEM;\n\t}\n\tprojh->yaw = info->yaw;\n\tprojh->pitch = info->pitch;\n\tprojh->roll = info->roll;\n\n\tproj_type = (info->projection_type==GF_PROJ360_CUBE_MAP) ? GF_ISOM_BOX_TYPE_CBMP : GF_ISOM_BOX_TYPE_EQUI;\n\n\tGF_ProjectionTypeBox *projt = (GF_ProjectionTypeBox *) gf_isom_box_find_child(proj->child_boxes, proj_type);\n\tif (!projt) {\n\t\tprojt = (GF_ProjectionTypeBox *) gf_isom_box_new_parent(&proj->child_boxes, proj_type);\n\t\tif (!projt) return GF_OUT_OF_MEM;\n\t}\n\tif (info->projection_type==GF_PROJ360_CUBE_MAP) {\n\t\tprojt->layout = info->layout;\n\t\tprojt->padding = info->padding;\n\t} else {\n\t\tprojt->bounds_top = info->top;\n\t\tprojt->bounds_bottom = info->bottom;\n\t\tprojt->bounds_left = info->left;\n\t\tprojt->bounds_right = info->right;\n\t}\n\n\t//remove other ones\n\tGF_Box *b = gf_isom_box_new_parent(&proj->child_boxes, GF_ISOM_BOX_TYPE_MSHP);\n\tif (b) gf_isom_box_del_parent(&proj->child_boxes, b);\n\tif (info->projection_type==GF_PROJ360_CUBE_MAP) {\n\t\tb = gf_isom_box_new_parent(&proj->child_boxes, GF_ISOM_BOX_TYPE_EQUI);\n\t\tif (b) gf_isom_box_del_parent(&proj->child_boxes, b);\n\t} else {\n\t\tb = gf_isom_box_new_parent(&proj->child_boxes, GF_ISOM_BOX_TYPE_EQUI);\n\t\tif (b) gf_isom_box_del_parent(&proj->child_boxes, b);\n\n\t}\n\treturn GF_OK;\n}\n\n#endif //!defined(GPAC_DISABLE_ISOM_WRITE)\n\n#ifndef GPAC_DISABLE_ISOM\n\nGF_Err gf_isom_add_sample_aux_info_internal(GF_TrackBox *trak, void *_traf, u32 sampleNumber, u32 aux_type, u32 aux_info, u8 *data, u32 size)\n{\n\tu32 i, count;\n\tGF_List **child_box_cont, **child_box_sai, **child_box_saiz, **child_box_saio;\n\tGF_UnknownBox *sai_cont = NULL;\n\n\tif (!trak && !_traf) return GF_BAD_PARAM;\n\n\tif (trak) {\n\t\tchild_box_cont = &trak->child_boxes;\n\t\tchild_box_sai = &trak->Media->information->sampleTable->child_boxes;\n\t\tchild_box_saiz = &trak->Media->information->sampleTable->sai_sizes;\n\t\tchild_box_saio = &trak->Media->information->sampleTable->sai_offsets;\n\t} else {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\tGF_TrackFragmentBox *traf = (GF_TrackFragmentBox *)_traf;\n\n\t\tchild_box_cont = &traf->child_boxes;\n\t\tchild_box_sai = &traf->child_boxes;\n\t\tchild_box_saiz = &traf->sai_sizes;\n\t\tchild_box_saio = &traf->sai_offsets;\n#endif\n\t}\n\n\tcount = gf_list_count(*child_box_cont);\n\tfor (i=0; i<count; i++) {\n\t\tGF_UnknownBox *unkn = gf_list_get(*child_box_cont, i);\n\t\tif (unkn->type != GF_ISOM_BOX_TYPE_UNKNOWN) continue;\n\t\tif (unkn->original_4cc != GF_ISOM_BOX_TYPE_GDAT) continue;\n\t\tif (unkn->sai_type != aux_type) continue;\n\t\tif (unkn->sai_aux_info != aux_info) continue;\n\t\tsai_cont = unkn;\n\t\tbreak;\n\t}\n\tif (!sai_cont) {\n\t\tsai_cont = (GF_UnknownBox *) gf_isom_box_new_parent(child_box_cont, GF_ISOM_BOX_TYPE_UNKNOWN);\n\t\tif (!sai_cont) return GF_OUT_OF_MEM;\n\t\tsai_cont->original_4cc = GF_ISOM_BOX_TYPE_GDAT;\n\t\tsai_cont->sai_type = aux_type;\n\t\tsai_cont->sai_aux_info = aux_info;\n\t}\n\tsai_cont->data = gf_realloc(sai_cont->data, (size+sai_cont->dataSize));\n\tif (!sai_cont->data) return GF_OUT_OF_MEM;\n\tmemcpy(sai_cont->data+sai_cont->dataSize, data, size);\n\tsai_cont->dataSize += size;\n\n\tGF_SampleAuxiliaryInfoSizeBox *saiz=NULL;\n\tGF_SampleAuxiliaryInfoOffsetBox *saio=NULL;\n\tcount = gf_list_count(*child_box_saiz);\n\tfor (i=0; i<count; i++) {\n\t\tsaiz = gf_list_get(*child_box_saiz, i);\n\t\tif ((saiz->aux_info_type==aux_type) && (saiz->aux_info_type_parameter==aux_info)) break;\n\t\tsaiz = NULL;\n\t}\n\tif (!saiz) {\n\t\tsaiz = (GF_SampleAuxiliaryInfoSizeBox *) gf_isom_box_new_parent(child_box_sai, GF_ISOM_BOX_TYPE_SAIZ);\n\t\tif (!saiz) return GF_OUT_OF_MEM;\n\t\tif (! *child_box_saiz) *child_box_saiz = gf_list_new();\n\t\tgf_list_add(*child_box_saiz, saiz);\n\n\t\tsaiz->aux_info_type = aux_type;\n\t\tsaiz->aux_info_type_parameter = aux_info;\n\t}\n\n\tif (saiz->sample_count >= sampleNumber)\n\t\treturn GF_BAD_PARAM;\n\n\tif ( (!saiz->sample_count && (sampleNumber==1))\n\t\t|| ((saiz->default_sample_info_size==size) && size)\n\t) {\n\t\tsaiz->sample_count ++;\n\t\tsaiz->default_sample_info_size = size;\n\t} else {\n\t\tif (sampleNumber > saiz->sample_alloc) {\n\t\t\tsaiz->sample_alloc = sampleNumber+10;\n\t\t\tsaiz->sample_info_size = (u8*)gf_realloc(saiz->sample_info_size, sizeof(u8)*(saiz->sample_alloc));\n\t\t}\n\n\t\tif (saiz->default_sample_info_size) {\n\t\t\tfor (i=0; i<saiz->sample_count; i++)\n\t\t\t\tsaiz->sample_info_size[i] = saiz->default_sample_info_size;\n\t\t\tsaiz->default_sample_info_size = 0;\n\t\t}\n\t\tfor (i=saiz->sample_count; i<sampleNumber-1; i++)\n\t\t\tsaiz->sample_info_size[i] = 0;\n\n\t\tsaiz->sample_info_size[sampleNumber-1] = size;\n\t\tsaiz->sample_count = sampleNumber;\n\t}\n\n\n\tcount = gf_list_count(*child_box_saio);\n\tfor (i=0; i<count; i++) {\n\t\tsaio = gf_list_get(*child_box_saio, i);\n\t\tif ((saio->aux_info_type==aux_type) && (saio->aux_info_type_parameter==aux_info)) break;\n\t\tsaio = NULL;\n\t}\n\tif (!saio) {\n\t\tsaio = (GF_SampleAuxiliaryInfoOffsetBox *) gf_isom_box_new_parent(child_box_sai, GF_ISOM_BOX_TYPE_SAIO);\n\t\tif (!saio) return GF_OUT_OF_MEM;\n\t\tif (! *child_box_saio) *child_box_saio = gf_list_new();\n\t\tgf_list_add(*child_box_saio, saio);\n\t\tsaio->aux_info_type = aux_type;\n\t\tsaio->aux_info_type_parameter = aux_info;\n\t}\n\tif (!saio->sai_data) saio->sai_data = sai_cont;\n\tsaio->version = 1;\n\tsaio->entry_count = 1;\n\n\treturn GF_OK;\n}\n#endif // GPAC_DISABLE_ISOM\n\n\n#if !defined(GPAC_DISABLE_ISOM_WRITE)\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\nGF_Err gf_isom_fragment_set_sample_aux_info(GF_ISOFile *movie, u32 trackID, u32 sample_number_in_frag, u32 aux_type, u32 aux_info, u8 *data, u32 size)\n{\n\tGF_TrackFragmentBox *traf;\n\tif (!movie || !movie->moof || !(movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY) ) return GF_BAD_PARAM;\n\n\ttraf = gf_isom_get_traf(movie, trackID);\n\tif (!traf) return GF_BAD_PARAM;\n\treturn gf_isom_add_sample_aux_info_internal(NULL, traf, sample_number_in_frag, aux_type, aux_info, data, size);\n}\n#endif\n\nGF_Err gf_isom_add_sample_aux_info(GF_ISOFile *file, u32 track, u32 sampleNumber, u32 aux_type, u32 aux_info, u8 *data, u32 size)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\n\te = CanAccessMovie(file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) return GF_BAD_PARAM;\n\n\treturn gf_isom_add_sample_aux_info_internal(trak, NULL, sampleNumber, aux_type, aux_info, data, size);\n}\n\n\nGF_Err gf_isom_set_meta_qt(GF_ISOFile *file)\n{\n\tu32 i, count;\n\tif (!file) return GF_BAD_PARAM;\n\tGF_Err e = CanAccessMovie(file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\tif (file->moov->meta)\n\t\tfile->moov->meta->write_qt = 1;\n\n\tcount = gf_list_count(file->moov->trackList);\n\tfor (i=0; i<count; i++) {\n\t\tGF_TrackBox *trak = gf_list_get(file->moov->trackList, i);\n\t\tif (trak->meta)\n\t\t\ttrak->meta->write_qt = 1;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_set_mpegh_compatible_profiles(GF_ISOFile *movie, u32 trackNumber, u32 sampleDescIndex, const u32 *profiles, u32 nb_compat_profiles)\n{\n\tu32 i, type;\n\tGF_SampleEntryBox *ent;\n\tGF_MHACompatibleProfilesBox *mhap;\n\tGF_TrackBox *trak;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media) return GF_BAD_PARAM;\n\tent = gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, sampleDescIndex-1);\n\tif (!ent) return GF_BAD_PARAM;\n\ttype = ent->type;\n\tif (type==GF_ISOM_BOX_TYPE_GNRA)\n\t\ttype = ((GF_GenericAudioSampleEntryBox *)ent)->EntryType;\n\n\tswitch (type) {\n\tcase GF_ISOM_BOX_TYPE_MHA1:\n\tcase GF_ISOM_BOX_TYPE_MHA2:\n\tcase GF_ISOM_BOX_TYPE_MHM1:\n\tcase GF_ISOM_BOX_TYPE_MHM2:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\tmhap = (GF_MHACompatibleProfilesBox *) gf_isom_box_find_child(ent->child_boxes, GF_ISOM_BOX_TYPE_MHAP);\n\tif (!mhap) {\n\t\tif (! profiles || !nb_compat_profiles) return GF_OK;\n\t\tmhap = (GF_MHACompatibleProfilesBox *) gf_isom_box_new_parent(&ent->child_boxes, GF_ISOM_BOX_TYPE_MHAP);\n\t} else if (! profiles || !nb_compat_profiles) {\n\t\tgf_isom_box_del_parent(&ent->child_boxes, (GF_Box*)mhap);\n\t\treturn GF_OK;\n\t}\n\tif (mhap->compat_profiles) gf_free(mhap->compat_profiles);\n\tmhap->compat_profiles = gf_malloc(sizeof(u8) * nb_compat_profiles);\n\tif (!mhap->compat_profiles) return GF_OUT_OF_MEM;\n\tfor (i=0; i<nb_compat_profiles; i++) {\n\t\tmhap->compat_profiles[i] = (u8) profiles[i];\n\t}\n\tmhap->num_profiles = nb_compat_profiles;\n\treturn GF_OK;\n}\n\nGF_Err gf_isom_set_sample_description_restricted(GF_ISOFile *movie, u32 trackNumber, u32 sampleDescIndex, u32 scheme_type)\n{\n\tu32 type;\n\tGF_SampleEntryBox *ent;\n\tGF_TrackBox *trak;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media) return GF_BAD_PARAM;\n\tent = gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, sampleDescIndex-1);\n\tif (!ent) return GF_BAD_PARAM;\n\ttype = ent->type;\n\n\tu32 original_format = type;\n\tu32 gnr_type=0;\n\tif (original_format==GF_ISOM_BOX_TYPE_GNRA) {\n\t\tgnr_type = original_format;\n\t\ttype = ((GF_GenericAudioSampleEntryBox*)ent)->EntryType;\n\t} else if (original_format==GF_ISOM_BOX_TYPE_GNRV) {\n\t\tgnr_type = original_format;\n\t\ttype = ((GF_GenericVisualSampleEntryBox*)ent)->EntryType;\n\t} else if (original_format==GF_ISOM_BOX_TYPE_GNRM) {\n\t\tgnr_type = original_format;\n\t\ttype = ((GF_GenericSampleEntryBox*)ent)->EntryType;\n\t}\n\n\tswitch (type) {\n\tcase GF_ISOM_BOX_TYPE_RESV:\n\tcase GF_ISOM_BOX_TYPE_RESA:\n\tcase GF_ISOM_BOX_TYPE_RESM:\n\tcase GF_ISOM_BOX_TYPE_REST:\n\tcase GF_ISOM_BOX_TYPE_RESU:\n\tcase GF_ISOM_BOX_TYPE_RESS:\n\tcase GF_ISOM_BOX_TYPE_RESF:\n\tcase GF_ISOM_BOX_TYPE_RESP:\n\tcase GF_ISOM_BOX_TYPE_RES3:\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_STXT:\n\t\ttype = GF_ISOM_BOX_TYPE_REST;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_STPP:\n\t\ttype = GF_ISOM_BOX_TYPE_RESU;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_METX:\n\tcase GF_ISOM_BOX_TYPE_METT:\n\tcase GF_ISOM_BOX_TYPE_URIM:\n\tcase GF_ISOM_BOX_TYPE_MEBX:\n\t\ttype = GF_ISOM_BOX_TYPE_RESM;\n\t\tbreak;\n\tdefault:\n\t\ttype=0;\n\t\tswitch (trak->Media->handler->handlerType) {\n\t\tcase GF_ISOM_MEDIA_VISUAL:\n\t\tcase GF_ISOM_MEDIA_AUXV:\n\t\tcase GF_ISOM_MEDIA_PICT:\n\t\t\ttype = GF_ISOM_BOX_TYPE_RESV;\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_AUDIO:\n\t\t\ttype = GF_ISOM_BOX_TYPE_RESA;\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_OD:\n\t\tcase GF_ISOM_MEDIA_OCR:\n\t\tcase GF_ISOM_MEDIA_SCENE:\n\t\tcase GF_ISOM_MEDIA_MPEG7:\n\t\tcase GF_ISOM_MEDIA_OCI:\n\t\tcase GF_ISOM_MEDIA_IPMP:\n\t\tcase GF_ISOM_MEDIA_MPEGJ:\n\t\t\ttype = GF_ISOM_BOX_TYPE_RESS;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\tif (!type) return GF_NOT_SUPPORTED;\n\n\tGF_ProtectionSchemeInfoBox *rinf;\n\trinf = (GF_ProtectionSchemeInfoBox *) gf_isom_box_find_child(ent->child_boxes, GF_ISOM_BOX_TYPE_RINF);\n\tif (rinf) gf_isom_box_del_parent(&ent->child_boxes, (GF_Box *)rinf);\n\n\trinf = (GF_ProtectionSchemeInfoBox *)gf_isom_box_new_parent(&ent->child_boxes, GF_ISOM_BOX_TYPE_RINF);\n\tif (!rinf) return GF_OUT_OF_MEM;\n\n\n\trinf->original_format = (GF_OriginalFormatBox *)gf_isom_box_new_parent(&rinf->child_boxes, GF_ISOM_BOX_TYPE_FRMA);\n\tif (!rinf->original_format) return GF_OUT_OF_MEM;\n\tif (gnr_type) {\n\t\trinf->original_format->data_format = gnr_type;\n\t\trinf->original_format->gnr_type = original_format;\n\t} else {\n\t\trinf->original_format->data_format = original_format;\n\t}\n\t//common to isma, cenc and oma\n\trinf->scheme_type = (GF_SchemeTypeBox *)gf_isom_box_new_parent(&rinf->child_boxes, GF_ISOM_BOX_TYPE_SCHM);\n\tif (!rinf->scheme_type) return GF_OUT_OF_MEM;\n\trinf->scheme_type->scheme_type  = scheme_type;\n\n\tent->type = type;\n\treturn GF_OK;\n}\n\n\n#endif\t/*!defined(GPAC_DISABLE_ISOM) && !defined(GPAC_DISABLE_ISOM_WRITE)*/\n\n"], "filenames": ["include/gpac/isomedia.h", "src/isomedia/box_code_base.c", "src/isomedia/isom_write.c"], "buggy_code_start_loc": [1467, 12679, 2513], "buggy_code_end_loc": [1470, 12766, 2513], "fixing_code_start_loc": [1468, 12679, 2514], "fixing_code_end_loc": [1485, 12824, 2518], "type": "CWE-125", "message": "Out-of-bounds Read in GitHub repository gpac/gpac prior to v2.2.2-DEV.", "other": {"cve": {"id": "CVE-2023-5377", "sourceIdentifier": "security@huntr.dev", "published": "2023-10-04T10:15:10.353", "lastModified": "2023-10-05T17:07:40.813", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Out-of-bounds Read in GitHub repository gpac/gpac prior to v2.2.2-DEV."}, {"lang": "es", "value": "Lectura fuera de l\u00edmites en el repositorio de GitHub gpac/gpac anterior a v2.2.2-DEV."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.2}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gpac:gpac:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.2.1", "matchCriteriaId": "047BC15F-5E51-48D9-B751-9DC9311FEBCF"}]}]}], "references": [{"url": "https://github.com/gpac/gpac/commit/8e9d6b38c036a97020c462ad48e1132e0ddc57ce", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.dev/bounties/fe778df4-3867-41d6-954b-211c81bccbbf", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/gpac/gpac/commit/8e9d6b38c036a97020c462ad48e1132e0ddc57ce"}}