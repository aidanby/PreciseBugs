{"buggy_code": ["            Memory usage improvement: Function scopes no longer stored as an array if they only contain one scope\n            Memory usage improvement: The root scope is never stored in the scope list (it's searched by default)\n            E.dumpVariables now dumps variable flags\n            Tidying up Native Function handling (now JSV_NATIVE_FUNCTION not JSV_NATIVE|JSV_FUNCTION)\n            NRF.getSecurityStatus now returns 'connected_addr' for the address of the currently-connected device\n            NRF.setAdvertising converts arrays of arrays to arrays of ArrayBuffers. Also don't update advertising when connected.\n            Memory usage improvement: Arrow functions only store value of 'this' if 'this' is used by code inside them (fix #2139)\n            Add String.prototype.concat (fix #2140)\n            Much-improved whitespace lexing code using single jumptable - 3% speed increase\n            Allow `process.memory(false)` to get memory info but skip GC\n            Graphics: fix height calculation bug in fillRect/clearRect when given an object with w/h as an argument\n\n     2v12 : nRF52840: Flow control XOFF is now sent at only 3/8th full - delays in BLE mean we can sometimes fill our 1k input buffer otherwise\n            __FILE__ is now set correctly for apps (fixes 2v11 regression)\n            Bangle.js: Ensure Bangle.getHealthStatus(\"day\") resets at midnight (fix https://github.com/espruino/BangleApps/issues/1216)\n            Bangle.js: Attempt to fix Bangle.buzz that occasionally doesn't stop\n            Bangle.js2: Lower bootloader LCD SPI bitrate (was out of spec, not all LCDs worked with it)\n            Bangle.js: Attempt to fix occasional issue where vibration gets stuck on (fix https://github.com/espruino/BangleApps/issues/1249)\n            Bangle.js: Ensure Bangle.setLCDPower only fires lcdPower event if state has changed (fix https://github.com/espruino/BangleApps/issues/1138)\n            Bangle.js2: Holding BTN at boot skips bootloader storage check, bootloader now times out if too many files\n            Bangle.js: Move position of filesystem checks to before first code is run\n            Storage.write is now explicit about not allowing zero length files, also creates exception if it fails because it can't get a data pointer\n            Bangle.js2: Only handle UBX protocol from GPS on Bangle.js 1 as it interferes with CASIC on Bangle.js 2 (fix #2124)\n            Bangle.js: GPS-raw no longer sets the FIFO_FULL message if data is lost - just passes a bool as the second argument\n            Fix for buffer overflow + segv found via fuzzing (#2121, #2122)\n            new Date(str) no longer interprets ISO 8601 UTC timestamps as local time (fix #2116)\n            Graphics: Fix clipRect checks for >1x bitmap fonts\n            Allow __proto__ to be set to a function as well as object\n            Bangle.js: Support for v2.1 barometer hardware (SPL06 vs BMP280)\n            Bangle.js: Increase step counting noise threshold 14->17 to work around pedometer fake steps (http://forum.espruino.com/conversations/371740)\n            Bangle.js: Support for v2.1 HRM hardware (VC31 vs VC31B)\n            Bangle.js: Better HRM detection (higher res filtering, better peak detection, lower median filter size, better confidence)\n            Fix E.decodeUTF8 when decoding UTF8 codes that contain all decimal digits\n            Fix for potential buffer overrun if JSON.stringify used with strangely crafted whitespace arg (fix #2114)\n            Add `NRF.setSecurity({encryptUart:true})` to force encrypted comms on BLE UART\n            Bangle.js2: Increase wait after power-on for BMP280 to fix getPressure on some devices (fix #2120)\n            Storage: Fix compaction error if a page starts with 0xff and the first write fits within that (fix #2009)\n            Add NRF.startBonding to force bonding on peripheral connection\n            nRF5x: Disable name change over BLE via 0x2A00\n            Bangle.js1/2 : Fix inconsitent scroll indicator in menus (fix #2104)\n            Bangle.js2: E.showScroller to respect widgets on bottom row (using appRect)\n            Bangle.js: Step counter - Remove hard-coded gravity value and subtract DC offset with a filter\n            Ensure jsfIsStorageValid kicks watchdog so we can't get stuck in a reboot loop if all of Storage is empty\n            Bangle.js: Add 'graphicsInternal' to make Graphics independent of JS vars. Terminal is now useful earlier, and can display softdevice errors\n            Bangle.js2: If errors do happen during Bangle.getPressure, reject the promise (fix #2137)\n\n     2v11 : Bangle.js: Enable the Bangle.on('tap') event from the accelerometer by default\n            Bangle.js: revert to (better) Kionix default thresholds for tap detect\n            Bangle.js2: When wake on touch is enabled, use a single tap on the front of the device for wakeup\n            Bangle.js: Display 'checking storage' message on first boot to alert users to slight delay\n            Bangle.js: Tweaked step count algorithm (low pass filter, 4 steps in 90s)\n            Graphics: asBMP/asURL/dump now support more bit depths\n            Graphics: Allow .setFont/.getFont to use font size in a colon after the font name\n            Graphics: .getFonts now lists 'setFont' functions however they were added (to `g`, built in, or to the prototype)\n            Graphics: When rendering fonts with a solid background, ensure the gap between is filled too\n            Flat Strings are now always aligned on a 4 byte boundary (fix #2040)\n            Graphics: add setTheme on supported devices\n            RAK5010: switch to 1.8v internal voltage (was 3.3v) to make GSM comms reliable, upgrade BG96 module\n            RAK5010: Compile in TLS/HTTPS support\n            Bangle.js: Fix issue where if non-fullscreen notification was visible and Bangle.js reset, screen was off-center\n            Fix for issue with pretokenised code not creating correct text string for reserved words, eg {undefined:1}\n            Bangle.js: Turn vibrate off every time a new app loads\n            Fix issue where ({a:0}).a in the console would create a ReferenceError (works in code)\n            Graphics: Allow setFont(\"FontName:1x2\") for scaling in 2 directions (fix #2044)\n            Graphics: Fix .asBMP for 4 bit images\n            Graphics: switch RGB order for palette in asBMP for 4/8 bit images\n            Bangle.js2: Idle power consumption down from 1.3mA to 0.9mA (pullups on HRM disabled when off)\n            Bangle.js2: Increase reported bit depth from 3->16 and perform bayer dithering when rendering\n              Makes icons/old apps way more usable (plus provides an easy way to get >3bpp)\n            Bangle.js: Fix color palette when rendering 3bpp -> 16bpp\n            nRF52840: Fix 900uA UART power draw when shut down\n            nRF52: Send XON/XOFF when buffer is less full - reduce likelihood of FIFO_FULL with big MTUs\n            Bangle.js: Fix powerSave regression (should default to 'on', but didn't since 2v10)\n            Storage test on boot only tests storage fully if the first record is empty\n            Graphics: drawString now accepts images in-line (fix #2063)\n            Graphics: added stringMetrics to get height as well as width\n            Graphics: drawString now correctly middle-aligns multi-line strings\n            Graphics: add imageMetrics to allow image width/height to be read\n            Graphics: drawImage(...,{frame:x}) can be used to draw animations\n            Graphics: fix rotated/scaled rendering of 3 bit bitmaps (fix #2049)\n            Bangle.js: fix Bangle.getLogo memory leak\n            Bangle.js2: Graphics.getBPP now returns 3\n            Bangle.js: attempt to unlock SPI flash multiple times (some devices don't unlock on the first attempt)\n            Bangle.js: Fix Bangle.tap event regression (now works again)\n            Graphics: add wrapString to wrap messages to the correct length\n            Bangle.js: update showMessage and showPrompt with correct wrapping\n            Bangle.js2: Add Bangle.compassRd, fix setCompassPower\n            Bangle.js: Add Bangle.on('health',..) event and Bangle.getHealthStatus\n            Graphics: drawImage now honours arraybuffer offsets\n            Graphics: drawImage now supports up to 4bpp palettes rendered direct from flash\n            Bangle.js2: Larger font for E.showMenu\n            Graphics: drawString(..., true) for vector fonts now clears the background\n            nRF52: swap getSerial bytes around so device ID string matches nrfjprog\n            Bangle.js2: bootloader can now flash firmware from a file in Storage\n            Bangle.js2: Add second Storage area in internal flash for fast access, memory-mapped files\n            Fix unhandled reject of a previously resolved promise (fix #1433)\n            Bangle.js: E.showMessage/showPrompt can now display images via optional img argument\n                       E.showMessage/showPrompt handle padding correctly if no widgets are displayed\n            Bangle.js2: Fix setUI clockupdown handling of 'up' \n            Bangle.js: Ensure builtin E.show* (and fake LEDs) wake the LCD up\n            Storage check now *only* happens on first boot\n            Ensure __FILE__ is set by the time bootcode runs\n            If executing from storage, work out line numbers and print filename for Errors\n            Bangle.js: Don't store line numbers in functions - no need when execing from flash\n            Bangle.js: Add E.showScroller for scrollable lists\n            Fix issue where invalid JSON stopped execution after Storage.readJSON\n            Bangle.js: Add Storage.hash for boot0 cache change checking\n            Bangle.js: A single widget load failure will now not remove all widgets\n            Bangle.js: widgets are now sorted by .sortorder\n            While and for loop conditions now use Expression, not AssignmentExpression (eg. while(0,0) is fine) (fix #2068)\n            Bangle.js2: Fix 'stuck' bottom row of pixels if scrolling downwards with g.scroll(0,1)\n            Bangle.js: Fix issue where minified E.showMenu was creating a global var called 'c'\n            Fix string formatting for \"Field or method X does not already exist\" error\n            Graphics: drawRect,fillRect,clearRect are now able to take an object as the first argument\n            Bangle.js: Add Bangle.appRect to allow apps to see how much space is available for them\n            Bangle.js: Add `Bangle.setOptions({hrmPollInterval:...});`\n            Bangle.js2: Bangle.dragHandler is now cleared by setUI (fix #2078)\n            Bangle.js2: Adjust full battery voltage\n            Avoid Watchdog reboot during compact if compacting a lot of data (fix #2075)\n            Storage: Fix issue where compacting empty storage could cause out of bounds erase (fix #2081)\n            Fix issue where pretokenised '1 - - 1' would turn to '1--1' (fix #2086)\n            Fix break scoping error in nested for loops (fix #2084)\n            Fix memory leak when rejecting pre-resolved promise (test_promise11.js)\n            Fix parser errors in arrow functions (fix #2067)\n            Bangle.js2: Add Unistroke object, and 'Bangle.stroke' event\n            Fix pretokenised '1 / /.../' and ensure jslSeek resets the previous token (ref #2086)\n            nRF52: Move neopixel LRCK pin which can't be disabled due to hardware errata, and restore state after (fix #2071)\n            Bangle.js2: Disable unboard flash bank for now (issues with erase on reboot)\n            Bangle.js1: Fix E.showScroller implementation\n            Bangle.js2: Ensure tap and twist turn LCD backlight on as well as unlocking\n            Bangle.js1: Bangle.setUI now deletes touchHandler (fix #2095)\n            Bangle.js2: Tweak battery high mark again\n            Bangle.js2: Fix E.showScroller when there are less than 3 menu items\n            Bangle.js2: Bangle.off and .softOff now turn off touchscreen if it was on \n            Bangle.js2: Ensure antialiased line routines are built in\n            Bangle.js2: Add HRM wear detection (LED no longer turns on if HRM not on skin)\n            Bangle.js2: Add a 32 entry cache to speed up finding common files - improves app load times\n            Bangle.js: Ensure locale honours 12 hour setting (https://github.com/espruino/BangleApps/issues/892)\n            Bangle.js2: Ensure EXTCOMIN time for LCD is nearer 2us (from datasheet) (ref #2097)\n            Bangle.js2: New default JS firmware\n            Bangle.js2: Minify Bangle.drawWidgets\n            Bangle.js: Bangle.appRect now copes with widgets at the bottom\n            Bangle.js2: Fix >128 ASCII codes for 12x20 font (fix #2105)\n            Bangle.js: Add SPI flash read-after-write to verify write succeeded (fix #2109)\n            Bangle.js: Fix E.showMenu clear if background color is set (https://github.com/espruino/BangleApps/issues/1024)\n            Bangle.js: Re-add E.showMenu predraw callback (fix #2108)\n            Bangle.js2: Add hrmRd/hrmWr that allow you to poke the HRM directly\n            Bangle.js: Fix for previous SPI flash write verify when <4 bytes written\n            Bangle.js2: Add write protection for bootloader and softdevice to avoid accidental bricking\n            Bangle.js2: Bootloader now attempts multiple times to initialise ext flash, and waits longer (fix fw update app issues)\n            Bangle.js: Add Bangle.getHealthStatus(\"day\") to allow automatic step counts for the current day\n            Remove for(of/in) for extremely constrained devices (Micro:bit 1 only)\n            Bangle.js: bootloader now doesn't start immediately after power off (can help with 100% flat battery)\n            \n     2v10 : Bangle.js: Improved HRM calculations - swapped autocorrelation for bandpass filter\n            Bangle.js: Significantly improved step counting algorithm using bandpass filter (fix #1846)\n            Bangle.js: Ignore touch and swipe events when the LCD is off\n            Graphics: Fix 1bpp custom fonts on 2/4/8 bpp graphics Canvas not being the right colour\n            Bangle.js: Don't reset all peripherals when loading a new app, and only\n              turn peripherals off if unused 500ms after starting new app\n            Increase max arguments for Function.apply from 64 to 256\n            NRF52840: Create new NRF_GPIO_PIN_X_FAST as Nordic's gpio functions will no longer inline!\n            Graphics: Add .blit() to allow fast blits within a single Graphics instance\n            nRF52840: workaround for SDK15 bug that stops softdevice restart when WDT enabled\n            Disallow template strings in object decls like {`hello`:1} (fix #2006)\n            Bangle.js: Add support for global colour themes which affect g.clear/g.reset (fix #499)\n            Bangle.js: Switch beep/buzz to IRQs (keeps time correct even when JS is busy)\n            Add E.decodeUTF8 to allow UTF8 to be decoded into standard 8 bit characters\n            Util timer: account for 'drift' in timer when adding new tasks if running it continuously\n            Graphics: Allow 'scroll' method to only scroll inside clipRect\n            Bangle.js: if we restart with home button held down, ignore the 'button up' event\n            Remove Graphics.drawImages from non-Bangle.js builds to free up space\n            Pico: Remove SHA512 from build to free up space\n            Storage: fix issue where functions referencing flash weren't correctly relocated during compact (#2009)\n            Add support for rendering 3 bit images to 12/16 bit destinations\n            Ensure Serial1.unsetup can be called even if it doesn't appear to have been enabled\n            Puck.js: ensure self test only happens after hardware reset (fix #2001)\n            Bangle.js: Fix issue where long-press BTN3 while holding BTN1 would reload the app but wouldn't load configuration (eg not setting timezone)\n            Graphics: add .getBPP, and allow color blending (rather than copy) when drawing 2 bit images on any BPP Graphics instance\n            nRF52: If getPrimaryServices fails with NRF_BUSY, keep retrying after a delay (fix #2008)\n            Bangle.js 2: Fix getPressure memory leak\n            Graphics: Theme now only applies for LCD, not for JS/ArrayBuffer graphics\n            Graphics: Add dark boolean to themes to allow apps to update depending on bg color\n            Bangle.js: setUI now has 'clock' modes\n            Rename SMAQ3 board to BANGLEJS2\n            nRF52840: Remove ifdef around PHY_UPDATE_REQUEST - fixes BLE5 connections\n            Graphics: Allow g.drawImage to use ArrayBuffer Graphics as an argument \n            Bangle.js: Display small 'Loading...' screen to show something is happening when loading apps\n            Promise: Fix issue with .then().then(...) on an already-resolved promise (fix #2019)\n            Bangle.js: g.flip no longer keeps the screen awake, flipTimer renamed to inactivityTimer\n            Bangle.js 2: 'factory default' set of JS now included inside firmware\n            Bangle.js: Build in ANCS support (disabled by default)\n            Bangle.js 2: Working VC31 heart rate monitoring\n            Bangle.js: Push GPS events immediately after GPGSV (more portable/resilient to config changes)\n            At first boot, fully check Storage for validity (if not full, ensure remaining pages are 0xFF)\n            Storage: Ensure jsfIsStorageValid returns true when storage is valid, but full\n            Bangle.js: Add Bangle.getGPSFix to get last GPS fix without waiting for a listener\n            Merge experimental_compact_vars branch to reduce var sixe from 16 to 13 bytes in most cases.\n            Add JSVAR_FORCE_16_BYTE to allow experimental_compact_vars changes to be removed\n            Add JSVAR_FORCE_INLINE, and don't force lock/unlock/getters to be inlined.\n              Compiler has improved enough we save 10% code space and get marginally faster\n            Add ArrayBufferView.subarray for easily making subarrays (eg a.set(a.subarray(-1)))\n            Solve case where an ArrayBuffer set using the same array could duplicate entries (`a.set(a.subarray(),1)`)\n            nRF52: Fix 2v09 regression where clearWatch reset pin state, removing pullups\n            nRF52: BLE stack errors now reports a line number\n            nRF52: 'BLE task in progress' messages now give a readable name, not task number\n            MICROBIT1: Remove hardware SPI to save space. Software SPI still works\n\n     2v09 : Bangle.js: increase default advertising interval from 375 to 200ms to ease connections\n            Fix Math.acos for negative values (fix #1950)\n            nRF5x: Add callback param to 'NRF.restart', allowing code to be called with softdevice disabled\n            Bangle.js: fix require(\"locale\").time(new Date()) for default locale\n            Now use exponents when printing doubles >= 1E21 or < 1E-6 (fix #1489)\n            Fix Regexp handling of unescaped '.' in character group: /[.]/ (fix #1948)\n            Now error if using (unsupported) RegExp backreferences\n            nRF52: Ensure SPI 1 byte DMA errata workaround isn't applied to non-52832 parts\n            nRF52: When outputting assertions, if we have an terminal device (eg LCD) use that\n            When load(filename) is used, set global variable __FILE__ to the filename\n            Util Timer no longer uses RTC - works based on estimated time from the hardware timer itself (fix #1749, ref #1444)\n            Pull in fixed SHT3C.min.js for RAK5010\n            Add support for relaying full touchscreen events in devices that support it\n            Fix flip-on-idle behaviour for non-Bangle.js smartwatch ports\n            Add support for buttonless bootloader (first boot only, times out after 5 seconds)\n            Fix emulator crash if Graphics.drawPoly used with odd number of points\n            Graphics.fillPoly now errors if >64 points (prev was 63)\n            Graphics: Support for palettes supplied in image strings\n            nRF52840: Ensure internal voltage regulator is set to 3.3v (not 1.8v default) at boot\n            Fix Array.forEach when deleting the item you're currently iterating over (fix #1962)\n            Bangle.js: StorageFile now uses 10x bigger chunks which reduces stress on Storage.list()\n            Storage.list now allows you to specifically request StorageFile, only ever reports first StorageFile chunk\n            Graphics: Allow colors to be specified as '#rgb' strings\n            Graphics: Antialiased lines now read the background color so overlap nicely\n            Graphics: Add fillPolyAA and use antialiased vector fonts (on platforms where AA is enabled) \n            Puck.js: Fix regression where IR LED was left on after transmission (fix #1969)\n            Graphics: Fix overdraw when drawing ellipses/circles\n            NRF52840: Use SPI3 by default as it's more capable/faster than SPI0\n            SMAQ3: Add support for unknown compass IC\n            Bangle.js: Make the 'home' button more configurable in code\n            Bangle.js: Add Bangle.softOff to allow the RTC to keep running\n            nRF52: Allow devices to remember the time between reboots (even if RTC is reset)\n            Microbit 2: Increase RAM from 64k to 128k\n            Bangle.js: Don't enter accelerometer power save mode if compass/barometer is in use\n            Watches: Allow streaming pressure data from Barometer\n            Graphics: Add antialias/colour blending for 24 bit buffers\n            NRF52840: Create new NRF_GPIO_PIN_X_FAST as Nordic's gpio functions will no longer inline!\n            nRF5x: reset BLE advertising after `load()/reset()` (fix #1975)\n            Bangle.js: Add accelerometer recovery for rare cases when accelerometer boots with corrupted address (fix #1972)\n            Bangle.js: Add app ID option to setXYZPower to allow apps to share devices (power is on as long as one app wants the device) (fix #1971)\n            Bangle.js: Add isXYZOn() functions\n            BLE: Allow 128-bit service data to be decoded (fix #1976)\n            Graphics: Fix 8 bit ArrayBuffer scroll not working correctly in some directions\n            Storage: Fix corruption issue with StorageFile write after a Storage compact (fix #1970)\n            Fixed dimmable backlight on non-Bangle.js watches \n            SMAQ3: Touchscreen is now powered off with Bangle.setLCDPower(0), auto-powers off after 30s\n            nRF52: Upon rebooting, reset time to 1970 if time looks corrupt\n            nRF52840: Don't use SPI3 unless ESPR_USE_SPI3 is defined (errata 195 means it draws an extra 1mA unless disabled!)\n            Bangle.js: apply g.drawImage fast path even if image goes to the edge of the screen\n            Graphics: Improve fillPolyAA for horizontalish lines, remove antialiased vector fonts (as won't work well on platforms without readback)\n            Fix invalid free caused by error inside a while loop condition (fix #1983)\n            Fix SIGFPE if using modulo with -1 (fix #1983)\n            Fix memory leak on Array.forEach/map/filter/etc caused by #1962 fix\n            Fix Espruino not sleeping when very low on free memory (fix #1986)\n            nRF52: Use 'low accuracy' GPIOTE for watches as we can shut down the high speed oscillator\n            E.getSizeOf() and trace() now don't recurse into references back to the global scope (makes sizes and traces far more useful)\n            nRF5x: Move from separate sdk_config.h to a single targets/nrf5x/app_config.h file\n            Original board: Remove Graphics.*Ellipse and StorageFile when networking enabled to allow builds\n            Update S132 Softdevice from 3.0.0 to 3.1.0 (fix #1999)\n            nRF5x: Allow Espruino builds with a configurable MTU - move Espruino boards to 53 byte (from 23) (#1998)\n            Fix issue parsing `r=>print((e=>{})(r))` (fix #1992)\n            Add DHE RSA key exchange for TLS/HTTPS (fix #1994)\n \n     2v08 : nRF52: Added option to build in I2C slave support\n            Fix Tensorflow aiGesture regression from 2v07 (re-add opcodes) (fix #1936)\n            Add support for > 1bpp custom bitmap fonts\n            Bangle.js: add drawLineAA and drawPolyAA for antialiased lines\n            Removed custom fonts for SAVE_ON_FLASH devices\n            Fixed BBC micro:bit show() regression from 2v07\n            Ensure Storage library is exposed on SAVE_ON_FLASH devices (fix micro:bit flash write)\n            nRF52: Fix issue where analogRead would stop E.getBattery from working\n            Fix setWatch debounce lastTime regression from 2v07 (fix #1902)\n            nRF52: CPU now sleeps when while UART/BLE data is waiting to be sent (fix #1938)\n            JSON.stringify now checks for potential stack overflow when stringifying (fix #1940)\n            Check for Stack overflow when Garbage Collecting giant linked list (fix #1765)\n            Added String.padStart/padEnd\n            Fix issue where JSON.stringify({ something: bool }) would output 'something' as a bool too\n            Bangle.js/Pixl.js: Ensure terminal is always the same color regardless of g.setColor()\n            Original Espruino Board: remove E.FFT in network-enabled builds (freeing up flash memory)\n            Storage compact now updates pointers stored in RAM so they still point to the correct address in Flash (fix #1881)\n            Bangle.js: Add debounce to the button used to wake Bangle.js up from sleep\n            Fix regex match with '-' that isn't a range: \"1-2_A3\".split(/[0-]/) (fix #1736)\n            Crypto: modified mbedtls SHA1 to reduce size from 3.5k to under 1k\n            Graphics: Fix for out of bounds ArrayBuffer scroll issue (fix #1946, #1947)\n\n     2v07 : Graphics.asImage() now contains buffer when bpp != 8 (fix #1863)\n            nRF52 SDK15: Fix NRF.setScan/findDevices/etc\n            nRF52: reduce input buffer space taken by advertising packets\n            Pretokenisation: reserved words can now be used as function names (fix #1868)\n            jslGetNextToken now avoids iterator clone for each token (fix #1857)\n            nRF52: fix instability when accessing ADC from IRQs and event loop at the same time (fix #1861)\n            Fix 0.0==null comparison (fix #1865)\n            WIZNet: add setHostname(), geHostname(), getStatus()\n            Fix XON not sent after reset() (fix #1872)\n            Remove USBSERIAL enum for non-USB devices\n            Shrink new vector font sizes to allow multi-line use (fix #1873)\n            Stop Object.setPrototypeOf overwriting Object.prototype sometimes (fix #1875)\n            Arrow functions now always overwrite `this` (fix #1878)\n            Implement Streaming Storage compaction to allow compact with less RAM (fix #1598,#1707,#1828)\n            jslTokenAsString now works for 'of'\n            Speed up Array.prototype.join (fix #1660)\n            Allow 'in' to be used with typed arrays (fix #1534)\n            Fix global regex issues when match may be 0 chars (fix #1888) (fix #1889)\n            Improve String.replace performance using iterator rather than repeated copy\n            Pixl.js: SDA/SCL constants should point to A4/A5, not D4/D5\n            Fix Graphics.fill/drawCircle lock leak\n            Fix issue when do..while loop condition has side effects\n            Bangle.js: Ensure SPI flash CS is disabled when sleeping/off\n            nRF5x: clear FPU interrupt before sleeping\n            micro:bit: Add support for LSM303 accelerometer/magnetometer\n            micro:bit: Add delays at first boot to wait for USB UART to init and connect vis USB\n            micro:bit: Re-added tab complete (enough space now)\n            micro:bit: Added a fake pin for LED/LED1 that uses the LED matrix\n            nRF52: Allow a cccd_handle of 0 for startNotifications\n            Bangle.js: Power down SPI flash when sleeping/off\n            nRF52: Use the best available hardware timer for PWM taking frequency into account\n            Fix delay in scheduling after initial setTimeout call (from 2v06 and later)\n            Align Tensorflow arena to 16 bytes - new Tensorflow requires this (fix #1914)\n            Fix ReferenceError when arguments[0] is used when an argument is undefined (fix #1691)\n            JSON conversion for console now removes quotes on key lengths bigger than 15 (63)\n            micro:bit: add Storage.write/etc even on space-constrained (SAVE_ON_FLASH) devices\n            Remove flash compaction code on SAVE_ON_FLASH devices to save some space\n            Fix occasional duplicate state changes when using setWatch with debounce (fix #1902)\n            JSON.stringify now outputs 'null' for non-finite numbers as the spec requires (fix #1919)\n            Update Tensorflow to latest version, fix return 0 issue on ARM release builds (fix #1918)\n            Bangle.js: Accelerometer poll handler now uses RTC app_timer, not TIMER1. 1mA->0.5mA standby current (ref #1920)\n            Bangle.js: SPI MISO is now input_pullup (shaves ~20uA)\n            Espruino WiFi: Fix startAP function when open and no password supplied\n            Bangle.js: Accelerometer now runs in low power mode (saving ~150uA)\n            Bangle.js: Peripheral polling now only fully wakes Bangle when an event requires JS processing (ref #1921)\n            Bangle.js: When not moved for 1 minute, slow down accelerometer poll interval from 80 to 800ms (fix #1921)\n            Ensure software SPI/I2C/Serial don't leak a variable when initialised\n            Fix delay in scheduling after initial setTimeout call (from 2v06 and later)\n            Espruino WiFi: Fix StorageFile on Espruino WiFi (use max storagefile size of 4k)\n            Espruino WiFi: Fix Storage compaction regression (introduced after 2v06 release)\n            Bangle.js: Fix backlight flicker regression if at part brightness (fix #1925)\n            Fix ArrayBuffer.sort with negative numbers (it's not just Array.sort!)\n            nRF52: Use the best available hardware timer for PWM taking frequency into account\n            Bangle.js: Report GPS HDOP (Horizontal Ditution of Precision => accuracy) values in 'GPS' event\n            Pixl.js: Remove SHA256 from build to free up a little extra code space\n            nRF52: Restarting softdevice no longer changes the system time by 5 mins sometimes (fix #1933)\n\n     2v06 : Allow `\"ram\"` keyword at the top of a function to allow it to be pretokenised and loaded to RAM\n            Don't store line numbers for pretokenised functions\n            Fix 1-byte overflow when using UDP (#1799)\n            Remove 1-byte padding in Graphics lib\n            Bangle.js: Make SPI flash memory map address configurable, and check end bounds (#1807)\n            Bangle.js: More SPI flash memory map address to 0x60000000 to avoid ARM/nRF52 registers\n            nRF52: Fix issue with fast Notifications causing Notification data to be duplicated\n              http://forum.espruino.com/conversations/345949\n            Bangle.js: allow custom splash screen with .splash file\n            Pixl.js: Fix E.showMessage\n            Puck.js v1: Fix regression that stopped Puck.IR(data) working - Puck.IR(data,D26,D25) required\n            Puck.js v2: Ensure FET is used for IR output, fix selfTest errors for IR and Blue LED\n            Bangle.js: Big speed improvements for 120x120 and 80x80 gfx modes\n            Enable Graphics arraybuffer optimisations on all but low-end devices\n            Add specific Graphics optimisations for 1 and 8 bit rendering\n            Bangle.js: drawImage - add fast path for non-transparent 1 or 8bpp image blit (fix #1794)\n            Graphics.drawImage docs improvements (fix #1812)\n            Fix issue where it was possible to get an address of a non-memory-mapped FlashString\n            Graphics.drawImage: Allow 8 bit palettes to be specified\n            Bangle.js: Remove dumping of hardware state - saves some flash memory\n            microbit: Remove dumping of hardware state - saves some flash memory\n            Bangle.js: fix 'short' time for built-in locale\n            Bangle.js: fix 'speed' units for built-in locale\n            Graphics.createArrayBuffer now honors `msb:true` if `bpp>8`\n            Graphics.asImage: handle >8bpp correctly (fix #1797)\n            Graphics.asImage: Allow 'string' output type, reference Graphics buffer if possible\n            STM32: Fix 2v05 regression in hardware SPI.write (RX timeout)\n            Graphics: fix lock leak in g.reset()/g.clear(1)\n            Graphics: added drawImages to allow layers of rotated/scaled images to be composited \n            Remove E.interpolate/2D (not used much, just using flash)\n            Bangle.js: use double math FFT to save a few bytes of flash\n            Storage.writeJSON (fix memory leak)\n            dump() is now aware of pretokenised code (fix #1821)\n            Merge jsvStringIteratorGetChar + jsvStringIteratorNext into jsvStringIteratorGetCharAndNext (fix #1816)\n            Fix 2v05 regression that stopped process.uncaughtException from working (had been moved to E.uncaughtException)\n            nRF52: If passkey or oob is set in setSecurity, ensure that the UART connection requires encryption (fix #1705)\n            Now report [ERASED] rather than ?[255] if we hit char code 255 while evaluating\n            Bangle.js: read `setting.json` at init and modify Bangle.beep/buzz behaviour accordingly\n            Tensorflow: remove some as-yet unused operators to free space\n            nRF52: Speed up bootloader, remove pauses on Pixl.js\n            Pixl.js: fix self-test/terminal print - write to screen immediately after newline unless in IRQ\n            Fix issue with iteration over arrays with negative entries (these should be converted to Strings)\n            Linux: improve command-line, allow recursive test directory and more than one test (eg wildcard + shell expansion)\n            Added new vector fonts supporting most of ISO8859-1\n            Graphics.fillPoly now uses 4 bit fixed point internally\n            nRF52: Fix 2v05 hardware SPI regression (chip errata when sending 1 byte)\n            Graphics.fillPoly now uses a more normal fill algorithm that doesn't attempt to fill to the top right (fix #1796)\n            Fix setTimeout/Interval accuracy when new timeouts scheduled within timeout (fix #1829)\n            nRF52: Fix 'BLE task 2 is already in progress' if disconnect called during connection process\n            Puck.js: Put accelerometer into lower power mode by default\n            Puck.js: Switch to IRQs for magnetometer (lower power consumption)\n            Improve Graphics.drawImage speed and simplify code by allowing fast path for non-rotated graphics\n            Tensorflow: updated to v2.2, removed un-needed ops (reduces size by 24k)\n            Puck.js: Fix Puck.magTemp();\n            Puck.js v1: Fix magnetometer reading after puck.magOn (2v05 regression) - use old software I2C implementation\n            I2C: Improve software I2C (now quickly forces I2C high before pullup, to help improve clock speed)\n            Bangle.js: Fix GPS-raw events to provde also u-blox UBX Protocol messages (fix #1838)\n            Bangle.js: Save RAM in GPS handling, allow arbitrary length data returned (fix #1843)\n            Tensorflow updated to current 'master' version\n            Bangle.js: Improve SPI flash speed by with specific function for reading and keeping CS asserted (fix #1849)\n            Bangle.js: Ensure BTN3 exits debug mode (fix #1842)\n            Bangle.js: Now warn if GPS data overflows (fix #1847)\n            Fix double unlock in load(filename)\n            Bangle.js: Fix occasional execution errors when executing from Flash (fix #1854)\n            Add Graphics.transformVertices()\n            Re-add Graphics.quadraticBezier for Bangle.js, move to integer math to halve fn size\n            Emscripten: (fake) Flash memory support\n\n     2v05 : Add Array.includes\n            Fix (Number.toFixed) rounding, eg (1234.505).toFixed(2)\n            nRF52: If a central is connected to Espruino but isn't reading from UART, don't block waiting to send data\n            ESP8266: reverse fix #1679\n            Added Graphics.getFont/setFont/getFonts\n            Added Graphics.getFontHeight\n            Added option to compile in 6x8 fixed-width fonts\n            Fix issue where Util Timer timers could break after a call to setTime\n            nRF52: Enable DMA for SPI send\n            Added option to build in TensorFlow Lite for AI\n            Documentation for modules now includes require('...') in the call type to be less confusing\n            ESP8266: warning: Empty loadable segment detected (fix #1690) \n            nRF52: Add NRF.nfcPair(...) and OOB pairing to allow tap to pair over BLE\n            nRF52: Add NRF.nfcAndroidApp(...) to launch an Android app on touch\n            Pixl.js remove SHA512 to make room for new NFC functionality\n            Graphics.setFont(\"4x6\",2) will now double the size of a bitmap font\n            Graphics.drawImage can now take a String of data for an image (eg. direct from Storage)\n            nRF5x: Support connection to devices with RANDOM_PRIVATE_RESOLVABLE and RANDOM_PRIVATE_NON_RESOLVABLE addresses\n            Pixl.js: Move SCK pin used during Neopixel writes to ensure it doesn't interfere with BTN3\n            nRF52: Fix alignment issue with Nordic's SDK12 code that stopped passkey pairing from working sometimes\n            Storage lib now doesn't bother reading to end of flash to ensure pages are clear\n            Allow heatshrink compress/decompress to work even if flat buffers can't be allocated\n            require(\"Flash\").write operations no longer need to be aligned\n            require(\"Storage\").open added - for appendable files\n            Pixl.js: Removed AES functionality - unfortunately we're running low on space for it\n            Original Espruino Board: Removed Vector font and don't add rotated drawImage to save flash\n            nRF5x: Add NRF.filterDevices to allow scanned devices to be easily filtered after scanning\n            nRF52: Fix 'BLE task completed that wasn't scheduled' warning regression (peripheral disconnect)\n            Can now get a data pointer even from a single JsVar string (it doesn't have to be flat)\n            Add option to specify a palette when drawing images with drawImage\n            Add XON/XOFF flow control to Bluetooth LE UART (on by default)\n            Lower thresholds for XON/XOFF to give more headroom with devices that are slow to respond\n            Add a fast path for non-rotated non-scaled Graphics.drawImage\n            Add argument check for heatshrink compress/decompress\n            nRF5x: Ensure gatt.connect silently succeeds if we're already connected to the device\n            Add E.showMenu, deprecate Pixl.menu - use a common function to ease porting between devices\n            Added E.showPrompt, E.showAlert for Bangle.js\n            Pixl.js - check '.splash' file at startup and use it for splash screen if it's there\n            Improve free list ordering when Flat Strings are freed\n            Added E.defrag to perform defragmentation - still beta!\n            nRF52: fix issue where restarting the softdevice would reset the RTC\n              - fixes Bangle.js watchdog reset\n            nRF52: fix issue where advertising flags could get out of sync after SD restart\n            Bangle.js: fix units for GPS speed (was knots, now km/h)\n            Bangle.js: Add Bangle.setLCDBrightness\n            nRF52: Fix passkey pairing if setSecurity is after setServices\n            Bangle.js: EVents for 'swipe' and 'touch' on the touchscreen\n            Added ability to compile Espruino to JavaScript with Emscripten\n            Allow g.setColor/setBgColor to take hex Strings of the form `'#00ff00'`\n            Bangle.js: Added heart rate autocorrelation, setHRMPower and 'HRM' event\n            Bangle.js: New 120x120 and 80x80 high speed buffered modes\n            Fixed REPL to allow chars with char code >=128\n            Fixed lex tokenToString for 'break'\n            Bangle.js: add fake LED/LED1/LED2 as @allObjects suggested\n            Add Graphics.toColor, and allow 4 bit Mac palette to be mapped to 8 bit web palette\n            Add Graphics.setClipRect to allow draw ops to be restricted to a certain area\n            Bangle.js: add 'null' LCD mode to stop apps from drawing\n            Bangle.js: add Bangle.getLCDMode\n            Bangle.js: skip firmware version checks to save some bytes in bootloader\n            Graphics: new g.fillPoly to handle irregular polygons\n            Bangle.js: Bangle.setLCDMode now errors if it can't allocate a flat string (also garbage collects and defrags to try and ensure it can)\n            Graphics: drawEllipse/fillEllipse now work correctly for very small ellipses\n            Fix type compare of string and flatstring\n            Allow Storage.read to make partial file reads (fix #1744)\n            Fix SyntaxError when using pretokenise + getters (fix #1745)\n            Add Graphics.reset, and ensure it (and g.clear(1)) unreference custom fonts\n            Iterator cloners now take a reference to the iterator rather than returning it\n            Flash Strings: On Bangle.js allow JS code (and other Strings) to be accessed without loading them completely from Flash\n            Added E.CRC32 for easy testing of data validity\n            Add `E.on('kill'` event for executing code before load/reset/save/etc\n            JSON.stringify now escapes using the less efficient JSON subset of escape characters (fix #1737)\n            Allow optional `load(\"filename\")` to load a JS file from Storage (was just `load()`)\n            Bangle.js: add Bangle.loadWidgets/drawWidgets\n            Bangle.js: Remove deprecated Bangle.menu\n            Ensure it's possible to get a solid background when using 4x6 font\n            Bangle.js: Add Bangle.showLauncher\n            Add append optimisation for string '+', and don't append to flat/native/etc strings (fix #1746)\n            ESP8266_4MB: add optional build flag FLASH_1MB for ESP8255  & ESP01s with 1MB flash\n            ESP8266: add optional build flag NO_FOTA to remove flash over the air functionality\n            Add Bangle.getCompass and Bangle.getAccel to get the latest compass/accelerometer readings without a callback\n            Fix `parseInt(\"0b\",16)` as well as some other non-compliant behaviour (fix #1722)\n            Bangle.js: Disable touch buttons if screen off\n            Bangle.js: Don't send 'up' event for a button that was used to wake the screen\n            Bangle.js: GPS event.time set to undefined if GPS time is not initialised\n            Fix regression that removed exception reporting in console\n            Bangle.js: speed up bootloader progress bar\n            Bangle.js: fix problems turning off via bootloader sometimes\n            Bangle.js: improve power consumption when off, now ~0.08mA (fix #1727)\n            Bangle.js: add Bangle.setOptions({wakeOn*}) for when LCD should light\n            Bangle.js: Add 'twist' event and 'wakeOnTwist' (wakeOnTwist now default true, waveOnFaceUp default false)\n            Bangle.js/Pixl.js: Updated E.showMenu\n            Bangle.js: E.showMenu now has some colour, bigger, with next/prev indicators, and works with widgets \n            Pixl.js: Add E.showPrompt/Alert/Message (fix #1747)\n            Add .toJSON handling for JSON.stringify, and add Date.toJSON (fix #1754)\n            Remove broken Graphics.drawImage centerx/y (fix #1742)\n            Add Storage.writeJSON to avoid any confusion of writing arrays/numbers/etc\n            Bangle.js: Keep widget area free when using showPrompt/Alert/etc (fix #1756)\n            Add more info about flash memory to process.env/process.memory\n            Add Graphics.quadraticBezier() \n            Allow Graphics.setFont to be used with custom fonts (fix #1762)\n            Espruino WiFi: WiFi module now makes BOOT pin open circuit when sleeping - saves ~2mA\n            Add E.setConsole/getConsole to allow console to be moved (including to 'null')\n            Bangle.js: Ensure HRM is turned off in Bangle.off() (fix #1759)\n            Increase 'Storage' library's max filename size to 24 bytes (from 8)\n            Remove header.replacement in 'Storage' lib and just zero header.name\n              - increase filename to 28 bytes, but file search now more efficient\n            Bangle.js: Increase Storage area to full 4MB of flash\n            Bangle.js: NEEDS NEW APPS - Move away from using first char as file descriptor and use file extensions instead\n            Add StorageFile.getLength() to get the current length of a StorageFile\n            StorageFile also writes files with a 'JSFF_STORAGEFILE' flag (not currently used)\n            Storage.list() can now take a RegEx/string to filter returned results \n            MDBT42Q: Remove AES encryption libs by default to free up more flash memory\n            Microbit: Add SAVE_ON_FLASH_EXTREME flag to ensure builds keep working\n            Bangle.js: Added built-in 'locale' module to handle common conversions - this can be overwritten by a Storage File to change language\n            Storage.readJSON now has optional 2nd arg that stops it from creating exceptions on bad JSON\n            Bangle.js: Tweak LCD gamma curves to provide better gradients on new watches (fix #1758)\n            Bangle.js: fix BLE UART transmit bug when compiling for SDK14 (thanks @fanoush!)\n            Add euro symbol to 6x8 and 4x6 fonts as char code 128 (ISO10646-1)\n            Bangle.js: Use 'locale' library to translate E.showMenu/Prompt/Alert/etc\n            Bangle.js: remove graphical_menu lib and inline specialised version into E.showMenu\n            Bangle.js: Modify handling of widgets to allow variable width widgets (requires new widget JS)\n            Changed 6x8 builtin font to a modified Dina_r400-6 supporting non-ASCII characters\n            Bangle.js: Modify E.showMessage/Prompt/Alert to clear the entire screen and redraw widgets (fix #1771)\n            Bangle.js: Modify Bangle.drawWidgets to only clear the areas where widgets actually are, not the whole top&bottom bar\n            Kick Watchdog when erasing flash (it can take so long on 4MB external flash that it reboots)\n            KICKSTARTER BUILD\n            Bangle.js: Add 'meridian' to locale library\n            ESP32: add environment variable COMPORT to be used with make flash \n            Puck.js: v2 Support: Accelerometer/Gyro/temp\n            Puck.js: Self test now sets Puck.js BLE name if there's an error\n            Fix bitwise rshift by 0 to be unsigned (fix #1784)\n            Bangle.js: Don't load .boot0/1/2/3 if BTN1 is pressed\n            Puck.js: Allow D21(RST) to be used as normal IO pin\n            Fix recent E.getTemperature regression (fix #1788)\n            Fix pretokenise of RegExp literals (fix #1786)\n            Add ability to turn off software I2C clock stretching (not accessible from JS)\n            Puck.js: disable clock stretching for built-in sensors\n            Bangle.js: Now clear entire top/bottom row if there are widgets in it (fix #1790)\n            Add Storage check at startup and erase everything if storage looks corrupt (fix #1766)\n            Fix restriction on StorageFile filename length (8 to 28)\n            Fix array sort when compare fn returns floats <1 (fix #1798)\n            Fix Storage.write duplicate file issue in some rare cases (fix #1801)\n            Bangle.js: fix post-kickstarter issue adding widgets in bottom of screen (#1790)\n            Bangle.js: fix magnetometer self-calibration\n            Espruino Original: Removed Debugger, Tab complete, AT command networking from WIZnet networking build to free enough Flash\n            Espruino Pico: Added a normal build that doesn't contain CC3000 or WIZnet support\n            Espruino Pico: Removed Debugger and Vector font from WIZnet/CC3000 networking versions to free enough Flash\n            HYSTM32_28: Removed from build due to lack of interest and difficulty with increased firmware size\n\n     2v04 : Allow \\1..\\9 escape codes in RegExp\n            ESP8266: reading storage is not working for boot from user2 (fix #1507)\n            Fix Array.fill crash if used to fill up all available memory (fix #1668)\n            Fix NRF.requestDevice regression (clearInterval error) (fix #1669)\n            Smartibot devices now advertise on BLE as 'Smartibot abcd'\n            nRF5x: Leave digital input disconnected for analog read (saves power)\n            nRF5x: Return 'analog' as pin mode for any pin where input is disconnected\n            If watchdog is on and automatic, ensure that `reset()` keeps the automatic kicking going\n            Ensure that a console stays locked even after \n            Ensure interpreter flags (eg echo) are cleared after a `reset()`\n            nRF5x: When watchdog is on and automatic, automatically wake up often enough to service it\n            Fix Graphics.setFontBitmap on builds with no vector font (fix #1671)\n            Graphics.asBMP now takes account of bitmap rotation (fix #1672)\n            Raspberry pi pin numbering the same if using wiringPi or filesystem GPIO (fix #1673)\n            nRF52: Peer manager init errors from Nordic libs now not fatal \n            SDK15: Writing to flash now works\n            nRF52840: USB Serial works even for big sends, and device swaps to USB automatically\n            nRF52840: Allow Serial2 to be used\n            ESP8266: optimize rename-section for ESP8266_4MB board, freeHeap +2064 byte (fix #1679)\n            Fix corruption if Function.replaceWith called manually on something not a function (fix #1684)\n            Fix bug where '.clone' on a native function didn't copy arguments (fix #1685)\n            nRF52840: Fix input/pullup/pulldown pin modes on IO bank 2\n            Added `E.memoryMap` to allow on-chip registers to be mapped direct to variables (fix #1500)\n\n     2v03 : nRF5x: Fix issue when calling NRF.setAdvertising while connected via BLE (fix #1659)\n            nRF5x: 'dump()' not outputs `NRF.setSecurity` line if it has been called.\n            Ensure that converting a valid pin to a boolean always returns true\n            clearInterval/clearTimeout/clearWatch(undefined) now throw an error asking for just clearX()\n              - this stops code accidentally clearing all timers/etc if it uses a variable that is undefined\n            Allow NRF.setAddress to work even with services defined and a connection in progress\n\n     2v02 : Fix string index calculation when using some regexes (fix #1602)\n            Ensure Function.replaceWith puts scope after parameters (fix #1601)\n            Ensure Graphics.* return the Graphics instance, to allow call chaining (fix #1580)\n            Ensure DataView.byteOffset/byteLength is always set even if not specified (fix #1567)\n            Added HttpServerResponse.setHeader\n            HttpServerResponse now automatically sends `Connection:close` unless overridden (fix #1596)\n            Fix sign of RSSI reporting with setRSSIHandler\n            nRF52: Add docs for properties that weren't documented before\n            nRF52: Add ability to connect to device with passkey authentication\n            nRF52: Allow startNotifications to use Indicate if Notify doesn't exist (as per spec)\n            nRF52: Add option for static passkey pairing with NRF.setSecurity\n\t    ESP32: update EspruinoBuildTools to esp-idf V3.1.2 - fix Wifi connect issues (multiple ssid)\n            Revert PR #1459 as it broke neopixel functionality that worked previously\n            nRF52: Disconnect RX pin after UART test at boot (saves power when in deep sleep)\n            Serial.unsetup now sets pin state to STATE_UNDEFINED, which disconnects the pins internally\n            Removed modulo on `new Date` h/m/s/ms arguments as it seems desktop JS is fine with out of range values\n            Added `active` option to NRF.setScan/findDevices/requestDevices to allow scan response packets to be requested\n            Add I2C/SPI baud rate checks (#1619)\n            STM32: Add `E.setRTCPrescaler` to allow the RTC to be calibrated on Espruino Pico (fix #1607)\n            nRF52: Fix slow Bluetooth connection if previously disconnected while using low power connection interval (fix #1605)\n            Allow `Graphics.clear(true)` to reset state (font, color, etc) to default as well as clearing the screen (fix #1615)\n            nRF52: Fix setScanResponse regression from 2v00\n            nRF5x: Execute SWI1_IRQHandler when radio turns off instead of on+off. More efficient, fixed multiple advertising.\n            Smartibot build added\n            ESP8266: add CFLAGs to shrink build size (fix #1622)\n            ESP32: update EspruinoBuildTools to esp-idf V3.1.3\n            nRF52: Add FAT Filesystem support to MDBT42Q module\n            Now save file modification time with FAT\n            Fix segfault if `.clone` is called with `this==undefined` (fix #1628)\n            Fix issue outputting char codes <8 after outputting hex char codes\n            nRF52: Don't allow NRF.updateServices while a BLE restart for setServices is queued\n            nRF5x: Don't sleep if we received any events since last sleep (fix #1572)\n            Remove limit on the number of scopes that can be searched (fix #948)\n            String.split - improve docs, split with RegExp now inserts the text after the final match\n            RegExp: Add '|' operator (fix #1503)\n            Switch ARM toolchain to gcc-arm-none-eabi-8-2018-q4-major\n            Improve handling of timeouts for RAK8212 GPS\n            nRF52: Now create exception if advertising calls fail (but ignore when in IRQ)\n            nRF52: Add setAdvertising({},{scannable:false}) for disabling scan response\n            nRF52: Add note about connectable:false requiring >=100ms intervals\n            STM32: Fix issue where occasionally STM32 would be ~0.2s late waking from light sleep\n            ESP8266: add Wifi.connect options channel and bssid for faster AP connects (fix #1595, #1640)\n            Fix index in E.mapInPlace and improve docs\n            nRF52: Add NRF.getSecurityStatus to allow devices to detect the current state of the connection\n            STM32F4: Add Filesystem module\n            STM32F3: Fix broken build\n            nRF52: Fix nRF52840 advertising and remove duplicated advertising code\n            Fix Software Serial receive when the frame has to be decoded inside the IRQ (fix #1654)\n            Raise software serial receive buffer to 64 bytes (from 7)\n            nRF5x: Add security options to NRF.setSecurity (courtesy of @vkolotov)\n            nRF5x: Allow Serial1.setup(...) with only TX or RX pins\n            Vector font removed from Espruino Original WIZnet build due to lack of spare flash\n\n     2v01 : ESP32: update to esp-idf V3.1\n            Fix issues with Class Extends\n            Improve Tab Completions for extended classes\n            Fix Storage.readJSON/readArrayBuffer memory leak (fix #1532)\n            Fix potential out of bounds Graphics.scroll\n            Serial.setConsole now warns if not used on hardware Serial\n            ESP8266: implement hw_timer (fix #1511) to make soft serial and pwm work\n            Fix Storage write error when skipping pages (fix #1539)\n            nRF5x: When scanning, only use as much of IO queue as is needed\n            nRF5x: If BLE/NFC/etc data won't fit in IO queue, drop whole packet\n            Allow `a in b` to search 'fake' objects (#1534)\n            Improve fast path when iterating over Uint8Array/ArrayBuffer\n            Allow deletion of function properties (fix #1549)\n            Add `{callback:...}` option for `.write` style functions - improve docs.\n            ESP8266: deepSleep invalid microseconds (fix #1547)\n            ESP8266: ESP_FLASH_MAX for ESP8266_4MB is wrong (fix #1551, #1553)\n            Fix buffer overflow if bytesize/stopbits used in `Serial.setup` (fix #1510)\n            Ensure jsvNewFlatStringOfLength tries twice (even if GC doesn't release memory, it reorders the free list) (#1559)\n            ESP8266: Missing variable Flash Mode (--flash_mode, -fm) in ESP8266.make files (fix #1563)\n            ESP8266: Remove hack added to get around SDK 1.4 bug (fix #1568)\n            Reduce available hardware SPI/I2C instances to 1 on nRF52 (since this is all we implement atm)\n            Add E.dumpFragmentation to show memory fragmentation (only for debug builds)\n            Fix parsing of dates from before 1970\n            nRF52: Fix some regressions in requestDevice (flagged up by asserts in debug build)\n            Allow built-in objects to be created with `new X()`\n            nRF52: Ensure Bluetooth stack doesn't do a reboot for non-fatal errors (just report them to console)\n            BluetoothRemoteGATTServer.disconnect now returns a Promise\n            nRF52: Jump out of low power mode after less BLE activity (2 reads/writes in 10 radio packets) (#1546)\n            nRF5x: Fix NRF.setConnectionInterval when there's no connection (fix #1546)\n            Explicitly mention Espruino not supporting CASE after DEFAULT in error (fix #1570)\n            Ensure scope is saved for Class constructors (fix #1576)\n            Add setNBCellOn for RAK8211-NB (fix #1581)\n            Now escape chars <8 as octal, and add escape of vertical tab \n            Add Graphics.createArrayBuffer(... {interleavex:true}) to allow faster support for P3 LED panels\n            Add Graphics.fill/drawEllipse and move fill/drawCircle to use the same code\n            CC3000-specific build removed on Original Espruino board (lack of space)\n\n     2v00 : Allow changeInterval with large (>32 bit) intervals (fix #1438)\n            changeInterval now changes the interval immediately when it's called inside the interval it is changing (fix #1440)\n            Fix parsing of try..catch when not executing (fix #1439)\n            Add extra ReferenceError checks, even if variable is not used\n            Allow Ctrl-C out of while...continue loop (fix #1441)\n            Fix bug if using an undefined member of an object for for..in (fix #1437)\n            Allow for..in to iterate over prototype chains down from Array and Object\n            Add for(var i of array) to iterate over elements\n            Added getter and setter support\n            Stop parsing blocks if not executing (fix #572)\n            Fix stack overflow if interpreting a file full of '{' (fix #1448)\n            Fix exception when performing record access on object from getter (fix #1454)\n            Switch to non-recursive StringExt copy (fix #1451)\n            Fix rounding errors in fillPoly -> improve vector font rendering\n            Fix issue that caused 'dump()' not to report variables/functions on Pixl.js\n            Add E.lookupNoCase to allow searching case-insensitively for Object keys\n            Fix HTTP Chunked transfers when the server uses lowercase headers (fix #1458)\n            Fix TypedArray.indexOf (fix #1468)\n            Allow require('Storage').write('a','',0,15) (zero length data) (fix #1465)\n            edit() now chooses the shortest way to describe the function\n            Fixed bug when RegExp.match/test called on non-strings\n            Added Global isFinite\n            Add missing ArrayBufferView.filter\n            Added Array.find and findIndex (also for ArrayBufferViews)\n            Fix unreliable ArrayBufferView.indexOf (#1468)\n            Added String.startsWith/endsWith/includes (#1302)\n            parseFloat(\".s\") now returns NaN\n            Fixed /\\S+/.test(\" \")\n            Added Storage.getFree() to return available space\n            Enable E.setTimeZone on boards with very little flash memory\n            Lower saved code area to 2k on micro:bit (from 3)\n            Remove RGB colour handling in setColor on devices with low flash\n            Reduce available variable count on STM32VL - we were too low on RAM\n            Added Graphics.asBMP/asURL/dump - allowing easy debugging of Graphics via IDE\n            Allow '.then' on already-resolved promise (fix #1476)\n            Stop atob adding trailing 0s when strings are not a multiple of 3 long\n            Reconstruct start and end newlines when dumping multi-line functions  \n            Fix regression parsing methods in classes on embedded (fix #1479)\n            nRF5x: Add options argument to NRF.connect and BluetoothDevice.gatt.connect, allowing a connection interval to be specified\n            nRF5x: Start renegotiating speed after 0.1ms, not 5s. Massively improves connect speed.\n            nRF5x: Now queue up to 5 UART TX packets per transmit interval (was 1 previously)\n            nRF52: Add Dynamic Interval Adjustment - default to 2x connection speed, but idle at 10x slower if not used for 2 minutes\n            nRF5x: Add NRF.setConnectionInterval() to allow connection speed to be set manually\n            RuuviTag: invert LED1, LED2 & BTN in software so LED.set() does what you'd expect\n            Console now doesn't print quotes around object keys if it's not needed\n            Added `E.toJS` to allow very compact JS data stringification (similar to `JSON.stringify`)\n            Output the current timer number as a comment in `dump()`\n            Don't print `=undefined` to console if line is empty\n            Added RAK8212 (and include SMS/GPRS code in RAK8211/2 builds)\n            Graphics.stringWidth now takes account of newlines\n            nRF52: NRF.requestDevice now resolves as soon as a device is found. Faster and better in congested areas\n            Replace use of obsolete 'usleep' function in Linux builds (fix #1455)\n            Add Ethernet.getIP/setIP callbacks for Wiznet to bring them in line with WiFi (fix #1482)\n            Fix Math.round for numbers > 32 bit (fix #1485)\n            Pixl.js menu now resets font alignment, and down arrow icon is fixed\n            Now check for ReferenceErrors in global scope\n            Fix Array.shift (returned a NAME, rather than the value)\n            Add sanity check for names returned from Functions and fix Array.pop\n            Stop characters getting dropped when pasting large amounts of data into Linux build\n            nRF5x increase JsSysTime accuracy to 2^-20 from 2^-16 - drastically improves Util Timer accuracy\n            Added support for Software Serial ports (for low baud rates, eg. 9600)\n            Fix JS state restoration issue (eg. Pixl.menu inside switch would cause errors)\n            Added Graphics.drawPoly\n            Add Graphics.asImage to turn a Graphics instance into an Image that can be used with drawImage\n            Add Graphics.createImage to allow creation of a 1 bit image direct from a string\n            Use 32 bit floats for E.FFT, not 64 (fix #1443)\n            Automatically shut down UART if both pin states are changed\n            Fix `setDeviceClockCmd: Unknown Device` when using `LoopbackB.setConsole()` on WiFi board\n            Fix non-UART serial regressions (after software serial additions)\n            Pixl.js: Add Pixl.setLCDPower to allow the LCD to be powered off, more than halving power consumption\n            nRF5x: Allow NRF.setScan and NRF.findDevices to take the same search filters NRF.requestDevice does (fix #1496)\n            Fix buffer overrun if we have to reallocate a pointer to argument lists when calling a function (fix #1491)\n            Fix stack overflow if executing regex full of hundreds of open brackets (fix #1487)\n            Fix issue where STM32F4 USB could lock up if TX during heavy RX\n            Improve `E.mapInPlace` docs, and allow it to work with no map (eg pass straight through)\n            Added non-standard Uint24Array, because it's very useful for RGB\n            ESP8266: add CFLAGs to shrink binaray files (fix #1499)\n            ESP8266: fully integration of analog pin A0 (fix #1495)\n            ESP32: update sdk to esp-idf 3.0.1, set Espruino build tools back to master branch\n            Allow btoa to work for arrays as well as Strings (fix #1509)\n            Allow E.mapInPlace to merge bits from multiple source elements, also add option for msb/lsb first\n            Remove Graphics.scroll/drawCircle/fillCircle on devices with low flash to allow builds to fit again\n            Remove BluetoothRemoteGATTCharacteristic.writeValue on NRF51 (accidental inclusion - it's not required)\n            Double IO buffer size to 256 (1k bytes) on boards with 96k of RAM or more (or NRF52)\n            nRF5x: allow arbirtary baud rates to be specified for UART\n            On devices with low flash, ensure atan2 uses the slower/smaller atan implementation\n            Move FFT back to 64 bit if low flash (it uses less memory!) and optimise for flash space\n            Remove new Graphics.createImage/asBML/asURL/dump on Original Espruino Board (not enough space) \n            Remove Olimexino from build (too difficult to slim down build and very low usage)\n            Remove Software Serial from boards where we're low on flash\n            Increase size of saved code area from 3*4k to 10*4k on RAK821x boards\n            Fix 'Can't extend undefined' when using Object.setPrototypeOf on a function\n            nRF52: Added NRF.HID event for two-way BLE HID communications\n            nRF5x: Remove multiple writes per connection interval (more trouble than the speed improvement is worth)\n            Fixed hang if trying to allocate Storage greater than total storage size in a fully erased Storage area.\n            Pixl.js: Fix 30s pause when closing sockets on WIZnet W5100 (fix #1306)\n            Remove HASH/hashlib from all builds as it was confusingly in some and not others. Now use 'crypto'\n            require('crypto').SHA1 is now JS in Espruino Original to cut down on the flash required\n            Added 'heatshrink' library to expose built-in heatshrink compression to users\n            Fix assert fail when calling Function.apply with an Object with non-numeric keys\n            Fix issue when AT lib has to process multiple custom line handers in one packet\n            Espruino WiFi: Fix unreliable send when receiving lots of data on another socket\n            Espruino WiFi: Only rename `EspruinoWiFi` to `WiFi` if not found (allows easier debug)\n            Check Flash Storage for modules when using `require`\n            Add 'bits' option for Software SPI\n            STM32 reset pin IRQs before storing the state - makes lost setWatches far less likely\n            Ensure that setBusyIndicator updates output state after the very first initialisation.\n            MDBT42Q: Add LED2 var in the Espruino interpreter, but don't use it for the bootloader\n            ESP8266: release heap used by logDebug(true) (fix #1508)\n            ESP8266: remove SHA256 SHA512 (fix #1517)\n            Ensure `Date.getTimezoneOffset()` returns the correct timezone offset (fix #1515)\n            Search for and execute files '.boot0'/1/2/3 in Storage at boot time if they exist\n            Pixl.js: reduce saved code area to 9 x 4kb to allow for extra features\n            ESP8266: switch to SDK 2.2.1 (fix #1207)\n            Fix Serial port path regression on Linux, and add docs\n            microbit: remove line-by-line debug capability to free up some space\n            Added ES6 String.prototype.repeat\n\n     1v99 : Increase jslMatch error buffer size to handle \"UNFINISHED TEMPLATE LITERAL\" string (#1426)\n            nRF5x: Make FlashWrite cope with flash writes > 4k\n            Increase max size of native strings on platforms that support it - 16 bit to 32 bit (#1432)\n            Fix stack size detection on Linux (fix #1427)\n            Fix strncat/cpy bounding issues (fix #1425)\n            Promises now ignore a second resolve/reject (fix #1433)\n            Fix stack overflow if void void void... is repeated many times (fix #1434)\n            Fix font rendering issue caused by signed bit field handling by GCC on non-x86 platforms (fix #1436)\n            Added E.reboot() to allow hard reboots from software (fix #1429)\n            Added 'Graphics.getInstance()' for more platform independent graphics\n            Added VT100 'erase in Display' to Terminal\n            In REPL, use x.toString() for objects if we know their name and it is available\n            Pixl.js add BLE aerial test to self-test, now also start immediately on BTN4 at boot\n\n     1v98 : Allow Crypto SHA1 without SHA256/512 (for ESP8266 where flash is scarce)\n            Add better docs for the form of Wifi callback functions\n            Modify ESP8266/ESP32 callbacks to match the node.js style used elsewhere\n            nRF52: fix pin.toggle() on software-negated pins\n            Pixl.js: Reorder pins so 0..13 are also D0..13 for better Arduino compatibility\n            Fix dump() when used with code written using E.setBootCode(..), (fix #1398)\n            Allow parseInt/parseFloat to be used on very large strings if the number doesn't extend right to the end (fix #1397)\n            nRF5x: Fix memory leak on NRF.connect\n            Fix memory leak if an exception is thrown within a rejected promise\n            ESP8266: rewrite wifi.save and restore to use the storage lib (imp #1380)\n\t    ESP8266: Add missing option ssid_hidden for Wifi.startAP() (imp #1358)\n            Fixed double-connect issue for TCP sockets\n            Pixl.js: Ensure Pixl.menu changes to bitmap fonts\n            Pixl.js: tweaked bias/contrast to improve display quality\n            ESP32: update esp-idf to v3.0. BLE support - thanks to @jumjum. Erase flash before flashing. vars now 2500\n            ESP8266: rearange rf_cal_sector (fix #1294)\n            ESP8266: Wifi.scan() now return authmode as text \n            ESP32: Fix accidental initialisation of UART3 when switching to Telnet (fix #1362)\n            nRF52: Added `NRF.setAddress` to allow the MAC address to be changed\n            Added Graphics.setFontAlign for font alignment and rotation\n            Make software I2C bitrate and waveform more accurate\n            Move default I2C bitrate to 100kbit/sec\n            Linux: don't create a espruino.flash file if we're not writing to flash\n            Add height check for Graphics.createArrayBuffer(...vertical_byte:true) (fix #1421)\n            Add sanity check for debug trace print statement (fix #1420)\n            Fix handling of exceptions in switch statements (fix #1352)\n            Fix 'return when not in function' regression when returning inside a catch block (fix #1422)\n            Don't load saved firmware images from different firmware versions - saved JS code still loaded (fix #1174)\n            Remove Graphics.setFontAlign and Graphics.getModified on devices with low flash memory\n\n     1v97 : nRF52: fix NRF.on('connect',...) issue\n            STM32: Fix setDeviceClockCmd error for USB.setConsole()\n            nRF5x: Fix getPinMode, which fixes SW I2C after save()\n            Thingy52: Don't report contents of 'Thingy' in 'dump()'\n            Thingy52: Allow multiple sounds to play at once\n            nRF5x: Ensure Waveform triggers a finished event\n            Thingy52: Enable simple bootloader, add travis build for DFU\n            Add Serial.inject to allow data to be added as if it was received from that device\n            Fix UDP handling so that it copes with packets not all being received in one go\n            STM32L496: increase variables - use full 320kB of RAM as it is contiguous\n            Add a maximum time for setTimeout/setInterval (100 years)\n            Fix Storage.write when writing partial file of the same length and initial contents\n            Fix corrupted timer channels returned by Pin.getInfo\n            Add command history to debugger\n            Remove process.env.EXPORTS (EXPTR does the same but takes less space)\n            Thingy52: Add 9 axis MPU support\n            Errors now store message in 'message', not 'msg' (fix #1366)\n            Ensure 'in' operator checks the prototype chain (fix #1365)\n            Promise.resolve now handles promises/thenables as arguments (fix #1363)\n            try..catch now creates exception in its own scope (fix #1367)\n            Thingy52,Pixl.js: add default NFC URL of the Espruino IDE \n            Add ArrayBuffer.byteLength property (fix #1374)\n            setWatch(..., {edge:\"rising\",debounce:25}) is now default for built-in buttons\n            Pixl.js: add Pixl.menu function for easy menus, build in graphical_menu.js\n            Fix regression in MDBT42Q advertised name\n            nRF52: Add E.getBattery as a more global battery percentage function, deprecate `Puck.getBatteryPercentage`\n            Fix '.buffer' regression in 'JSON.stringify(new Uint8Array([1,2,3,4]).buffer)'\n            Allow `typeof 123 .testing` without an exception (fix #1351)\n            Add crypto.AES to Puck.js and other nRF52 Espruino devices\n\n     1v96 : ESP8266: no callback if SSID is not available (fix #1297)\n            ESP8266: esp8266 wifi getStatus doesn't show savedMode (fix #752)\n            ESP8266: cleanup defines WIFI_DBG and NET_DBG for RELEASE\n            ESP8266: switch to single ld file eagle.app.v6.new.2048.ld for ESP8266_4MB board\n            Allow JS modules to be built-in by adding files to JSMODULESOURCES\n            Fix slow/hacky handling of 7 bit serial data for STM32\n            Add more stack checks so invalid code `typeof typeof typeof x100` can't break stack (fix #1310)\n            nRF5x: Fix PWM output via Waveform class\n            Fix free stack checking on ARM\n            nRF52: Make slightly more space available for stack\n            nRF5x: Move to SDK 12.3\n            Stop stack traces from being gathered in functions for Ctrl-C (fix #1313)\n            nRF5x: Fix crash if I2C is used before being initialised (fix #1301)\n            Internal printf can now pad with spaces\n            Add `E.dumpFreeList` in non-release builds to help with debugging\n            Fix mild memory leak in jsvMakeIntoVariableName that caused GC to run more often than normal\n            E.toString now tries harder to allocate a Flat String, and works with no-alloc for Uint8Array/FlatStrings\n            WIO_LTE fix SD card initialisation\n            Improve SD card reliability on all boards by trying to initialise multiple times before failing\n            Remove forced inlining in variable inspection functions (reduces flash usage by ~10k)\n            Remove un-needed DNS lookup for localhost\n            Add WIZnet UDP support\n            Tidying up build to avoid making un-needed bin, hex or lst files\n            Simplify flash save (and help debugging) by using the 'fake flash' implementation on Linux builds\n            Added Graphics.scroll command to scroll graphics contents\n            Added 'Terminal' class with built-in VT100 terminal\n            Tweak Espruino logo to be exactly 32 chars wide\n            Improved code for returning console device to the most useful place\n            Fix pinToString for devices with port A but no port B\n            Speed improvements for ArrayBuffer Graphics\n            Tidied up bootloader - devices with one LED now flash LED when button pressed\n            Simplify data returned by process.env\n            Add process.env.MODULES - to contain a list of the libraries provided in the firmware by require\n            Include WiFi and AT libraries inside Espruino WiFi builds\n            Add 'E.asm' placeholder to detect E.asm calls that haven't been replaced by the IDE\n            Add process.env.EXPTR to link to table of functions - will work better for compiled code over BLE\n            Added SAVE_ON_FLASH_EXTREME for HYSTM32_28, where we're now cutting out some Math.X functionality to keep builds going \n            Added `jshFlashGetMemMapAddress` to allow remapping of addresses for ESP8266/ESP32 without loads of code duplication\n            Remap peek8/16/32 addresses on ESP32/ESP8266 so it can be used on flash memory\n            Swapped save/load/E.setBootCode to use the flash library\n            Allow STM32LL port to write 32 bits to flash at a time to bring it in line with other ports\n            Allow flash writes *from* unaligned addresses on nRF52 and ESP8266 (previously this crashed the ESP8266)\n            Update process.ENV.EXPORTS to bring it in line with what the compiler uses\n            Now set 'this' correctly for Arrow Functions\n            Add ES6 classes and 'super'\n            nRF5x: Move all bluetooth events to event queue (removing MEMORY_BUSY issues)\n            Fix potential issue where EV_TYPE_MASK enum could be set incorrectly  \n            setWatch's edge argument can also be an integer now\n            Add 'data' option to setWatch to allow clocked data to be decoded easily\n            nRF52: Increase flash available for stored code from 12kB for 40kB\n            Now store/display appreviated commit in process.env, remove build date\n  \n     1v95 : nRF5x: Swap to UART fifo to avoid overrun errors at high baud rates\n            Ensure Exceptions/errors are reported on a blank line\n            Internal: Added initialiser argument to jsvNewStringOfLength\n            Internal: Added jsvObjectSetChildVar/jsvObjectSetChildVar/jsvObjectSetChildVar\n            Internal: Fix jsvCopy if given a NAME_INT/etc\n            Added ES6's Object.assign\n            nRF5x: NRF.setScan now reads service data automatically\n            nRF5x: NRF.findDevices aggregates data from multiple advertising packets\n            nRF5x: Remove app_uart and use nrf_drv_uart with double buffering - fix uart overflow errors (fix #1238)\n            nRF5x: Fix issue with findDevices/setScan servicedata when all digits of service are numbers (eg \"1809\")\n            Fix memory leak in tab completion code\n            Add `E.errorFlag` event to allow JS to respond to internal errors\n            Use Esc[J VT100 code when cycling through command history (much faster REPL on low bandwidth connections)\n            ESP8266: Remove debugger again as it will never work on 8266\n            ESP8266: Enable unaligned reads for ESP8266_4MB (fix #1240,#837)\n            ESP8266: move code save section to fist partition for memory mapping for ESP8266_4MB (fix #1240)\n            ESP8266: Add GPIO16 as D16 without watch (#1206) but soft PWM/I2C/SPI/etc \n            ESP8266: Remove osprintf for RELEASE=1 \n            Internal: Networkjs now forwards `socketType` - laying groundwork for UDP over AT command (#1232)\n            Added simple RegExp implemention (partial fix #256)\n            Speed up JSON.stringify for Arrays, and output non-numeric array elements in REPL (fix #64)\n            nRF5x: Bump nRF52-based boards variable count from 2000 to 2500 (fix #1215)\n            Ensure Ctrl-C doesn't redraw the input line if it's already empty\n            Added String.replace(regex, function) (fix #1256)\n            With E.setFlags({pretokenise:1}), ensure stack traces are not tokenised (fix #1258)\n            Allow digitalWrite/Read to take an object as an argument (calling .write and .read on it)\n            Add `E.getAddressOf` to allow embedded targets to get memory addresses for DMA/etc\n            nRF5x: Fix issue where doing a soft reset in the middle of some BLE ops could cause an assert in debug builds\n            nRF5x: Manufacturer Data is now decoded in advertising packets\n            Fix memory leak when allocating DataViews\n            nRF5x: Fix memory leak on BLE notifications\n            Ensure net/http .listen return the server instance (fix #1276)\n            nRF5x: Allow Manufacturer Data to be specified with setAdvertising\n            Internal: Fix memory leak in jsvArrayPushAll\n            nRF5x: jsvArrayPushAll memory leak fixes NRF.findDevices memory leak when services present\n            Internal: jsvNewIterator now has an option to iterate over sparse arrays as if they weren't sparse\n            Fixed some built-in functions that misbehaved when given sparse arrays\n            Puck.js: Allow flash memory protection to be overwridden with E.setFlags\n            Fix lexing of '/*/' as a complete block comment\n            nRF5x: Add support for negating pins in software (eg. buttons/LEDs)\n            Add `E.setFlags({unsyncFiles:1}` which doesn't sync the file to the SD card after each write - it's *much* faster\n            Filesystem API now uses flat strings (avoiding the 512 byte copy for each call)\n            Increase default internal SD card bitrate to 4MHz (from 100k)\n            nRF5x: Handle promise completions and advertising using IO queue, to avoid MEMORY_BUSY messages (#1277)\n            Allow E.HSBtoRGB to wrap 'hue' value, and allow it to return an array of [r,g,b] (fix #1283)\n            Remove spikes when changing pin state (fix #1274)\n            Changes to reduce code duplication in jswrapper.c\n            Fix `E.setBootCode` when no argument is supplied\n            Add WIZnet W5500 support to Espruino WiFi build\n\n     1v94 : Allow Espruino boards to reset straight out of the DFU Bootloader             \n            Improvements in handling errors in code running in IRQs\n             - if writing to disconnected Bluetooth device, throw data away immediately\n             - Drop chars if output buffer is full while waiting in an IRQ\n             - Handle out of memory errors in jsvCreateNewChild\n             - Do not garbage collect inside an IRQ\n            On nRF52 devices, allow button press at boot to clear out peer manager data\n            Work out length of typed array with offset correctly (fix #1204)\n            nRF5x: Add Watchdog timer handling\n            nRF52: start new connections on idle to ease memory allocation conflicts between code execution & IRQs\n            nRF52: Ignore INVALID_STATE from CONN_PARAM_UPDATE_REQUEST (it can happen if we disconnect and then SD requests an update)\n            Fix Date.toString for dates before 1970\n            STM32: Fix handling of months when setting the internal RTC\n            Move to a faster jsvNewFlatStringOfLength which avoids blocking memory allocation\n            nRF5x: If a task is in progress, report the task ID (BleTask enum)\n            nRF52: Report central mode promise errors correctly if returned by softdevice\n            Remove 'out of memory' warning messages (it's stored as a flag anyway)\n            nRF5x: Don't disable IRQs completely for some things - only disable Espruino ones\n            Fix tab complete for Pins (fix #1213)\n            ESP8266: Fix load() causes endless loops (fix #1037)\n            ESP8266: Wifi library doesn't handle {password: null} (fix #753)\n            ESP8266: make topstrings and topreadonly work on Mac OS X (fix #1210)\n            Change order of execution for init - E.on('init',...) now executed before onInit\n            Added Error flag to show if a UART overflow has occurred\n            Change more instances of jsWarn to jsException\n            Avoid printing error messages during execution, and report to console on idle when if errors were flagged (fix #766)\n            Increase HTTP server and client version from 1.0 to 1.1 (needed for Websockets on Safari)\n            Stop 'require' creating an undefined Module entry in the modules list (fix #1218)\n            Stop require dumping filesystem errors as well as 'module not found'\n            Now throw an exception when writing to a closed socket (fix #1220)\n            Set the internal 'conn' variable to false when a connection closes to avoid confusion\n            nRF5x: Fix typo so we wake every 4 min for RTC, not 0.25 sec!\n            process.memory() now reports time taken for GC and vars GC'd\n            Slightly more aggressive idle GC on most platforms (at 5% free)\n            Don't warn the user when we had to run a GC pass during execution\n            Fix issue drawing on right-hand side of rotated graphics where H>W (regression in 1v93) \n            If >1 button, set pin state correctly at boot/reset\n            Add an argument to `reset`. `reset(true)` will now cause all Flash memory to be cleared as well.\n            Puck.js: Holding down the button while booting (past the the 5 LED flashes) will now cause data saved in Flash to be cleared\n            STM32: Remove the 'utility timer' from the list of available PWM pins, fixing A0/1/2 PWM on F4 (fix #1229)\n            Disable Graphics.createCallback on devices with small amounts of flash memory - rarely used on those devices and fixes HYSTM32_28 build\n\n     1v93 : Ensure that specifying too many advertising UUIDs causes an exception, not a reboot\n            nRF5x: Fix for time jump caused by reentrancy in jshGetSystemTime\n            Fix regression causing multiple end/close callbacks when using standard TCP/IP socket client/server\n            Ensure NetworkJS reports receive errors back correctly\n            nRF5x: Fix issue where connect and immediate disconnect could in some cases trigger an error from nordic's libraries that'd cause a reboot\n            Fix regression that caused Original Espruino to have lost Filesystem/hashlib/neopixel support in 1v92\n\t    Re-add TV output to Original Espruino\n            Fix some stack overflow bugs on Linux found by fuzzing (#1147)\n            Remove un-needed code for parsing '.' in var statement (#1147)\n            Add autocomplete for pin names (fix #1124)\n            Add Array.indexOf fromIndex support (fix #162)\n            Puck.js: Add BluetoothRemoteGATTServer.startBonding to allow bonding to be initiated when Puck.js is a central\n            Fat FS: closedir after readdir, FS errors should be catchable (#1164), fs.statSync (#1163)\n            Allow hardware (CTS) flow control (fix #1165)\n            nRF52: Add AntiCat's patch to Nordic's NFC library to cope with malformed NFC requests\n            Puck.js: Fix increased battery drain after NFC usage (fix #1171)\n            Puck.js: Fix WS2811 output library that would output bad data after neopixel waveform (fix #1154)\n            nRF52: Seed random number generator at boot (fix #1166)\n            Stop trailing decimal point if there are no digits after it - which could cause issues in JSON\n            Don't enter debugger if we're in the middle of uploading (echo_off_for_line) (fix #644)\n            Added Date setters (fix #504)\n            Allow Timezone to be set for Date with E.setTimeZone(...) (fix #530)\n            Added RegEx lexing (part of #256)\n            Puck.js: fix error 8 from NRF.sleep during an active connection \n            nRF5x: Fix `NRF.updateServices` when a 128 bit service shares the same 16 bit UUID\n            Add 'errors' option when using `Serial.setup` to enable error handling (and turn it off by default as it can fill the input queue)\n            nRF52: Re-initialise services and HID after a `save()` (fix #1185)\n            nRF5x: Add NRF.getAdvertisingData\n            nRF5x: Allow array of objects in NRF.setAdvertising (fix #1188)\n            Fix internal vcbprintf JSON dumping\n            nRF5x: NRF.findDevices will now throw an exception if no callback is supplied\n            nRF52: Added BluetoothRemoteGATTServer.getSecurityStatus to check the status of the link\n            nRF52: Disable auto-whitelisting by default, add with `NRF.setWhitelist` (fix #1187)\n            nRF52: Allow secure Bluetooth LE connections\n            Don't draw font characters that are off the edge of the screen\n            Make atob and btoa use flat string for larger amounts of data (faster & more memory efficient) (fix #1192)\n            nRF52: Pull in Nordic SDK13 code to crash caused by writing large characteristic (fix #1181)\n            Puck.js: Added Puck.magTemp() function to get the magnetometer's temperature as well\n            nRF5x: Fix issue where 'NRF.sleep()' called while a connection was active could cause Espruino to go into a high power draw mode\n            Fix Object.setPrototypeOf when called on undefined (fix #1194)\n            Fix dumping of an ArrayBuffer containing data (new ArrayBuffer([1,2,3]) isn't valid)\n            Fix setAdvertising regression where name would be lost after save() (fix #1193)\n            Add `E.set/getFlags` to allow interpreter state to be controlled from one place\n            Add `E.setFlags({pretokenise:1})` to dynamically turn on pretokenisation (fix #1178)\n\n     1v92 : nRF5x: Fix issue where Espruino could crash during save() if the flash got into a strange state\n            Added Pin.toggle() function\n            Fix implicit casting to bool/number on ArrayBuffers (fix #1030)\n            Fix jstExecuteTaskChecker bug, and allow jstExecuteFn to take a userdata argument\n            Puck.js: Reduce IR LED to 10% duty cycle\n            Puck.js: Allow Puck.IR to take pins for external IR LED (fix #927)\n            nRF52: Allow arbitrary NFC data to be specified (fix #1021)\n            nRF5x: Allow multiple advertising packets to be set at once with NRF.setAdvertising\n            nRF52: Add 'properties' object to BluetoothRemoteGATTCharacteristic\n            nRF52: Perform write without response if that is what is required \n            Pico/WiFi: Allow USB HID to work on Windows (from @nailxx)\n            Allow Puck.js/nRF52 devices to drive Neopixel/WS281x/APA10x LEDs with require(\"neopixel\").write (fix #1023)\n            Fix crash in JSON.stringify for zero-length typed arrays\n            Fix precedence of 'void' keyword (fix #1079)\n            nRF52: Add BluetoothRemoteGATTCharacteristic.startNotifications (fix #959)\n            nRF52: Added BluetoothDevice.gattserverdisconnected event\n            nRF5x: Report back reason codes for BLE disconnect\n            Added DataView class\n            nRF52: char.readValue now returns DataView to be more Web Bluetooth compliant (fix #1091)\n            nRF5x: Fix explicit disconnect being able to reboot Puck (fix #1088)\n            nRF5x: Respond to conn_params update request, fix puck-puck disconnection after ~65 sec (fix #1089)\n            nRF52: Change connection params for central mode so NRF.setLowPowerConnection affects connection speed\n            Un-inlining jsvGet*AndUnLock functions to give us a little more free flash\n\t    ESP8266: RELEASE=1 sets WIFI_DBG and NET_DBG to 0 to shrink firmware size\n\t    ESP8266: Add Wifi.setAPIP() and Wifi.setIP\n\t    ESP8266: Add i2c clock stretch (#1097)\n\t    Fix E.FFT output (enable magnitude when one array specified)\n            Puck.js: Correct reading if using analogWrite to red LED and *then* using Puck.light()\n            Improved build process for all boards\n            Pin.toggle now returns a boolean (fix #1111)\n            nRF52: Now use 'high drive' mode for GPIOs\n            Puck.js: tweak IR duty cycle, with high drive GPIO range is ~3x more\n            nRF52: switch compilation to size optimisation, not speed\n            nRF5x: Allow services to be advertised (fix #996)\n            JSON.parse now throws an exception if an incorrect value type is found (fix #1117)\n            Pipe close event handlers now use 'this' arg - solves auto-closing pipe when piping from HTTP\n            nRF5x: stop app_timer NRF_ERROR_INVALID_PARAM errors (trying to sleep for too little time)\n            Added flash emulation to Linux port\n            Increase max graphics size from 1023 to 32767\n\t    Add Fat File System to boards with large Flash (ESP32)\n            nRF52: Don't get stuck in 'HID Busy' state if a HID send failed\n            Change name of socket close internal variable so it doesn't conflict with Pipe's close call\n            Stop pipe from causing errors if fields of the requested names exist but aren't functions\n            nRF52: Fix upgrade from older firmwares if saved code is in flash, reduce virtual pages to 2\n            Fix segfault detected by fuzzing (#1133)\n            Fix File.read so that end of file triggers pipe.end event\n            ESP8266: Add BOARD ESP8266_4M with 1600 vars, 64K save area and GRAPHICS (#1110)\n            ESP8266: Add ESP8266.deepSleep(micros, option) (#1102)\n\n     1v91 : Fix recent regression if no Boot Code defined at startup\n            Fix handling of return of rejected promise within a promise\n            Fix regression where HTTPS without cert/ca or key failed\n            nRF52: Making NRF.getPrimaryService/etc more robust\n            nRF5x: Add NRF.getAddress() - fix #1001\n            Fix bug that caused load() not to clear memory if only E.setBootCode was used\n            microbit: Update Espruino with pin polarity, so saved code gets loaded without BTN1 pressed\n            Fix bug that caused Bluetooth/TV/USB objects to be added in devices that didn't support them (fix #832)\n            nRF52: Increase custom UUID count from 3 to 10\n            Adding Global built-in objects like SPI1/Serial1 and Bluetooth to the docs\n            Puck.js: Tweak battery percentage calculation to try and make it more linear\n            Puck.js: Adjust Puck.light() levels based on battery percentage (and add comments)\n            nRF5x: Fix E.hwRand() (fix #1010)\n            Ensure tab complete/others include the Object proto even on functions/strings\n            nRF5x: Add NRF.restart() to force the restart of the Bluetooth Softdevice if required\n            nRF5x: Add E.setLowPowerConnection(bool) to allow continuous connections to Puck.js (fix #995)\n            Allow implicit conversion of hexadecimal strings to numbers (fix #1016)\n            Allow arrow functions inside nonexecuting functions (fix #1011)\n\n     1v90 : Fixes for Promise.all (passing in non-promises, pre-resolved, and ordering) (fix #976)\n            Fix arrow function bug when parsing multiple arguments\n            Added more helpful error messages for TLS\n            Allow `Modules.addCached` to take a function (makes module loading more memory efficient)\n            Re-add Espruino's old `rand` function (so no malloc, and ~1kB RAM, ~3kB ROM saved)\n            nRF5x: Ensure 'NRF.sleep' works even when connected\n            Fix bug when using >32 bit integers as array indices (fix #984)\n            Fix bug when parsing '.catch' while not executing (fix #989)\n            Stop PWM 'glitching' when moving from a nonzero value down to 0 (partial #991)\n            nRF5x: Add multi-channel hardware PWM (fix #991, fix #972)\n            'dump()' now outputs code written with E.setBootCode as well (fix #999)\n            nRF5x: Remember advertising information even after softdevice reboot  (fix #997)\n            nRF51: Remove heap placeholder on nRF51 as not needed since no malloc. Increase nRF51 var count (fix #985)\n            nRF5x: 'connect' event now contains address of device that has connected, and fix docs\n            nRF5x: Add a 'NRF.disconnect' function to disconnect a client that has connected to Puck.js\n            nRF5x: Fix timing accuracy problems with setWatch\n\n     1v89 : Allow entering of multi-line Templated Literals on the command-line (fix #970)\n            Make lexer fail when parsing non-templated strings with newlines in \n            Add 'let' and 'const' keywords - treat them like 'var' for now\n            Increased findDevices timeout to 2 seconds\n            Allowed 16 bit UUIDs to be specified as simply \"ABCD\" (no \"0x\")\n            Improved BLE error messages (especially from Promises)\n            Fix STM32F1 regression caused by F4 LSE fixes\n            Fix comma operator regression caused by recent arrow functions addition\n            Remove RTC changes for STM32F1\n            nRF5x: Make sure that updateServices(notify) on a non-notifyable service will just error, rather than reset (fix #973)\n            nRF5x: Ensure setWatch doesn't reset pin state\n            nRF5x: Reset pin states to default on 'reset()'\n            nRF5x: Move advertising back to 375ms (more reliable connections)\n            Puck: allow Puck.mag to work while magnetometer is on\n\n     1v88 : jshSetEventCallback callbacks now get an argument with the channel number\n            Tab complete now offers a much better set of completions (fix #926)\n            Fix emitting of events with long names (fix #906)\n            Ensure 'af_opendrain' pin mode gets remembered when saving (fix #890)\n            Add second Promise.then argument (fix #869)\n            Fix 'chained' promises (fix #894)\n            Fixed memory leak when automatically converting a simple object to a String\n            Added ES6 Template Literals\n            Initial commit of ES6 arrow functions\n            Add 'opendrain_pullup' pinMode (including emulation on STM32F1)\n            Make OneWire use opendrain_pullup (no resistor needed for short runs now)\n            Add Software I2C (with opendrain_pullup) (ref #549, fix #29)\n            Cope with new escape codes for home and end on Ubuntu 16.04 (27,91,70/72)\n            Tweak VGA output back porch to 2ms (so leftmost pixels always on screen)\n            Fix regression with 2 concurrent waveforms on different pins (fix #930)\n            nRF5x: add updateServices, and allow setServices to be called multiple times (partial #936)\n            Added Puck.getBatteryPercentage() utility function\n            nRF5x: setServices can now uninitialise SD in order to remove added services\n            Added E.lockConsole() for use with E.setPassword()\n            Calling jsvRemoveChild at end of array now updates the length (fix #946)\n            Allow padding to be specified as 3rd argument of JSON.stringify\n            JSON.stringify now dumps typed arrays as arrays (fix #489)\n            nRF52: BLE HID support and switchable Nordic UART\n            Fix STM32 regression where pinMode was set when it shouldn't have been\n            Add Third option to pinMode to allow the pin mode to be set while keeping it 'unforced'\n            Save and dump now keep track of whether pin mode had been forced or not\n            readFile (and File.read) now uses Flat Strings to allow more memory efficient reads (fix #932)\n            nRF5x: Add ability to get RSSI of current connection (fix #928)\n            More STM32 changes to LSI->LSE clock switchover to fix RTC misconfiguration on Espruino WiFi\n            Move LED + BTN definitions to Symbol Table (allows autocomplete)\n            When moving console before printing has started, move all buffer contents as well\n            Fix regression where replacing a function starting with 'return' with another would cause errors\n            Fix potential issues with Telnet server and return values from netCreateSocket/netAccept on some platforms (fix #931)\n            nRF5x: Add Puck.js self-test code, fix issue where analogRead reset pin state\n            nRF5x: Change central mode API to mirror Web Bluetooth\n            Fix switch fall-through to default (fix #964)\n            Started using jsvObjectRemoveChild to remove some internal object properties that are undefined (frees some variables)\n            Added E.dumpLockedVars() in non-release builds to help debug memory leaks in libraries\n            nRF5x: Added NRF.findDevices as a helper function to easily list BT devices in range\n            Console now prints the type of Objects if their constructor is in the root scope\n            nRF5x: setScan/findDevices now parses advertising data\n            nRF5x: Added Web Bluetooth style requestDevice function\n            Add spaces between large tab completes\n            Correct the handling of exceptions in promises\n            Ensure that exceptions have a 'stack' attribute if they can have children\n            nRF5x: Added list of free flash areas\n            Make sure Puck.js users can't overwrite bootloader/softdevice (doing so would brick the board)\n            Fix micro:bit/nRF51 ctrl-c behaviour (fix #905)\n            Simplified process.env on devices with little memory\n            nRF5x: fixed serial number reporting\n            Move button state setup to jshResetDevices\n            Had to remove 'dump()' and SW I2C on devices with very little flash memory (Olimexino/Micro:bit)\n\n     1v87 : Add support for compiling with float-abi=hard (even if it doesn't give us real-world benefits)\n            Add shortcut for quick execution of common call types\n            Fix BBC micro:bit save() regression from 1v86\n            Fix 'lock overflow' when calling methods with 'this' bound (fix #870, fix #885)\n            Fix jsvStringIteratorGetCharOrMinusOne for zero-length strings\n            Allow tab-completion straight after '.'\n            Make sure execution stops for native functions if there's an error when parsing arguments\n            NRF5x: remove setName and add functionality to setAdvertising, along with advertising interval\n            NRF5x: allow raw advertising data in setAdvertising\n            Add E.setPassword - allows Espruino console to be locked\n            Fix pin header numbering for BBC micro:bit (it changed for the production version) (fix #896)\n            Allow Magnetometer speed to be specified for Puck.js\n            Fix out of memory when appending a string to itself\n            Allow members of the same name as function arguments to be added to a function (fix #913)\n            Fix STM32F4 RTC stopping if reset during first 1 sec of boot, also fix Espruino WiFi board clock startup\n            Fix issue where native functions couldn't be replaced by non-native fns (fix #879)\n            If statements now return values (fix #909)\n            Fix >8 bit SPI when sending single elements with SPI.send (fix #897)\n            Sockets now fire 'end' events (fix #886)\n            Added Graphics.draw/fillCircle (fix #920)\n\n     1v86 : Compile Telnet server into linux by default, Add '--telnet' command-line option to enable it\n            Fix lock 'leak' in Telnet when Telnet is turned off\n            Add Telnet serial device to allow redirection\n            Create errors for unterminated expressions (fix #814)\n            Remove Espruino's built-in strcpy/etc\n            Remove Espruino's built-in maths\n            Add basic Taylor series sin and atan for when we're trying to save memory\n            Refactoring to use global var for lexer - save some memory and increase parse speed\n            Add .removeListener (fix #30)\n            Added better micro:bit `show()` that works well with Graphics\n            Add `require(\"Flash\").getFree()` as multiplatform way to find free flash pages (fix #815)\n            Add the ability to set clock frequencies on STM32F4 chips (like Pico) with E.setClock (fix #52)\n            `jsvEvaluate` now uses memory area for execution of JS strings (fix #817)\n            Add `E.setBootCode` to allow JS scripts to be run without being in RAM (fix #740)\n            'Expecting a number or something iterable, got X' changed to exception rather than warning (gives stack trace)\n            Drop '.init' and '.fini' symbols, allowing GCC 5.x compilation on STM32\n            Ensure that pinMode/digitalWrite is re-constituted properly by dump() and save() (fix #833)\n            ESP8266: add stack dump on fatal exception, ./targets/esp8266/printstack can extract a backtrace\n            ESP8266: move JswSymPtr and JswSymList to flash to free up gobs of RAM, bump jsvars to 1600\n            Fix write to flash when BLE connected on nRF51/2\n            Fix potential variable corruption issue when copying objects/arrays containing packed ints\n            Fix ESP8266 printLog memory leak (fix #852)\n            When parsing from a Native String (E.memoryArea), use Native String for function code too.\n            Added built-in Promise implementation\n            Fix broken Object.keys/getOwnPropertyNames caused by ESP8266 RAM saving tweaks\n            Add Object.g/setPrototypeOf (fix #856)\n            Fix memory leak when executing bound function with 'this'\n            Fix missing PBKDF2 & AES libs on Pico + Linux caused by an untested ESP8266 commit\n            Fix negative Date to string code (fix #854)\n            Convert type warnings to exceptions (to provide stack traces for problems)\n            Add uncaughtException event (fix #846)\n            Stop eval in a switch statement from confusing parsing (Fix #845)\n            Fix regression in 'mode' argument of SPI.setup (allows custom CC3000 pins to work)\n            Fix '.on' with long event names\n            Enable F4Discovery button pull-down. Newer boards don't seem to have one fitted\n            Add 'force' to 'Serial.setConsole' - you can force the console to stay in one place\n            Fix micro:bit compass problems (fix #864)\n            Ensure that Pico can properly enter deep sleep even if USB is never used\n            Only inline the very basic variable iterator functions (save enough space to allow Espruino board build again)\n            Don't include Promises on devices where flash memory of Scarce (fix Olimexino compile)\n            Fix glitches in PWM output when updating Software PWM quickly (fix #865)\n            Added `E.kickWatchdog()` to allow you to keep your JavaScript running - not just the interpreter (fix #859)\n            Ensure all pins set to AIN on startup\n            Fix regression where setWatch would remove pulldown from button if called after reset()\n            Reduce amount of flash available for saved code on Original Espruino (until we can get code size down)\n\n     1v85 : Ensure HttpServerResponse.writeHead actually sends the header right away\n             - enables WebSocket Server support from JS\n            Fix issue where GC'd objects referencing non-GC'd data wouldn't unreference it\n            Add E.memoryArea to allow memory addresses to be treated as variables\n            Fix STM32F4 LSI clock frequency - should make the Pico's RTC a lot more accurate (fix #776)\n            Added HeatShrink compression to saved code (instead of RLE)\n            If saving fails, delete command history and try again.\n            Make sure `reset()` resets the sleep and busy indicator pins\n            Now escape characters >=127 as well (fix #780)\n            Add decodeURIComponent (fix #779)\n            Allow reset();save() on one line\n            Fix potential issue parsing HTTP headers when more data is sent after the header (fix #783)\n            Fix broken storage of floating point values when <255 variables\n            Fix regression where DACs didn't work on Original Espruino Board\n            Improve tab complete's memopry usage\n            Added Tab complete and Debug to low-end Nordic uCs\n            Limit the number of events processed each time around the idle loop to the number that were in it at the start\n             - helps to fix issues with out of memory when receiving big files over ESP8266 serial connection\n            Allow different types of network to have different buffer sizes - enlarge JS, Linux and WIZnet buffers\n            Fix bug where clearInterval() and setWatch with debounce could cause setWatch to momentarily stop working\n            Make HTTP server only close connection after Content-Length bytes received\n            Speed up jsvNewFlatStringOfLength by combining it with updating the free var list\n            Update the free var list when garbage collecting (makes allocation at the start of memory more likely)\n            Don't zero the contents of memory when freeing - speeds up deallocation\n            Removal of un-needed zero initialisations for variables\n            Only garbage collect on idle if we're low on memory (fix #767)\n            Improve malloc behaviour for crypto lib (try and free all command history is first alloc fails)\n            Improve HTTPS error messages\n            Add READ_FLASH_UINT8, allowing ESP8266 to read&exec strings stored in Flash with E.memoryArea\n            Start the RTC up running off LSI, and switch after a few seconds if the LSE has started correctly\n            Allow JSV_GET_AS_CHAR_ARRAY to get a pointer to memory in ArrayBuffers or memoryAreas\n            Reset PinStateIsManual in reset (fix #765)\n\n     1v84 : Fix device initialisation flags not working when the device number is above 32 (fix #751, #748)\n             - this fixes broken SPI when not on standard pins\n\n     1v83 : Moved to size optimisation for Pico (needed to get HTTPS into 384kB)\n            Ensure Modules.addCached doesn't reset parse state (fix #723)\n            dump() in Espruino Pico now ignored the pull-down for the button (fix #731)\n            Warn when \"compiled\" functions gets into Espruiono (fix #707)\n            Fix lost character on Espruino Startup (fix #704)\n            Fix duplicated characters when USB+USART IRQs fire at the same time  (fix #635)\n            Fixed Serial.find(...)\n            Detect UART framing and parity errors and emit them as events on the Serial object\n            Fix [] instanceof Object (fix #737)\n            Fix regression in jsvCopyNameOnly (Object.getOwnPropertyNames when names are >8 characters long)\n            HTTP requests (and sockets) can now emit 'error' event (fix #706)\n            Add optional `ca`,`key`, and `cert` for server public key when using HTTPS or TLS (fix #736)\n\n     1v82 : Fix debugger regression (where quit/reset/etc don't exit properly)\n            Fix wakeup when setDeepSleep used at startup (fix #645)\n            Add `shiftOut` function (fix #631)\n            Store line numbers for functions (via `Esc [ 1234 d` escape code before decl) and use in debug + stack traces\n            Allow Ctrl-C to break out of tight loops with function calls in\n            Add tab -> autocomplete in Console (fix #677)\n            Fix I2C repeated start (#390)\n            Fix regression in Math.random() - now back between 0 and 1 (fix #656)\n            Fix `var a=0;typeof a -> \"undefined\"` (fix #683)\n            Don't store brackets in functions (fix #204)\n            Store functions as 'flat strings' if long enough (fix #467)\n            Move most functions out of jsvar.h header file - improves code size on devices where they're not inlined\n            Fix parse error for switch statements which meant that `switch (a,b)` caused an error\n            Fix error message when `LoopbackA.setConsole()` called\n            Move SPI/I2C/Serial initialisers to jsvReadConfigObject, will now error on invalid args (fix #413)\n            Fix issue where double-buffered waveforms would use the wrong buffer in the callback\n            Fix memory leak in tab autocomplete on objects\n            Added AES crypto library (Pico only)\n            Fix `typeof (new Uint8Array([1, 2, 3, 4]))`\n            Store `function(){return ...}` without the return (fix #700)\n            Increased simple string usage from 4 chars up to 8\n            Swap order of JsVar internals, string usage up to 10 chars\n            Add handling for uint32_t,uint64_t,uint32_t case for Raspberry Pi\n            Add startup sanity checks for jsnative.c (in non-release builds)\n            Added fix for returning floats on Raspberry Pi\n            When <1024 JsVars, `lastChild`'s top bits are stored in `flags`, and pack\n               is moved such that we get 1 extra character in StringExts\n            Allow events of >12 characters length\n            Fix regression in flash memory write (introduced via AES merge)\n            Fixed instability when resetting after using SD card on non-standard pins\n            HTTPS support on Pico (when compiled in)\n            Rename USE_HTTPS to USE_TLS, and enable by default for Pico + Linux\n            Add 'tls' module with 'connect' - for TLS Socket connections\n\n     1v81 : Fix regression on UART4/5 (bug #559)\n            Fix Serial3 on C10/C11 for F103 boards (fix #409)\n            Remove Graphics.setColorHSV, add E.HSBtoRGB (fix #554)\n            Make jsiDumpState/jsiAppendHardwareInitialisation use callbacks (fix #398)\n            Add `E.dumpStr()` to dump current state of interpreter as a string\n            Add ReferenceError, and ensure that TypeError gets converted to a string properly\n            Actually create ReferenceError for undefined variables\n            Fix Object constructor behaviour (fix #561)\n            Now remove intervals/watches if they occur within 0.1s of a Ctrl-C on a blank line\n            Fix parsing of trailing commas [,,1,,,]\n            Treat vertical tab as whitespace\n            Make sure we ReferenceError on '+='/etc\n            Allow reserved words in record access and structure definitions\n            Add Object.defineProperty/defineProperties (even if they ignore most args)\n            Fix value returned when redefining an existing function\n            Ensure Pico powers down USB in deep sleep - now down to 20uA!\n            Fix Exception throw within catch block (fix #566)\n            Fix issue where new Array(3.0) wouldn't produce a 3 element array\n            Keep track of modified area in Graphics (so modules with `.flip()` can be speeded up)\n            Fix `new Date('December 17, 1995 03:24:00')` - check only first 3 chars of month\n            Allow Software PWM via `analogWrite(..., {soft:true})`\n            Add `encodeURIComponent`\n            Make sure `typeof unknown` doesn't ReferenceError\n            Fix isNaN behaviour for 2 element array\n            Fix jshPopIOEventOfType when element is at the top of queue anyway\n            Produce more reasonable behaviour when converting very long strings to ints/floats\n            Added built-in JavaScript debugger! See espruino.com/Debugger for details (fix #37)\n            Fix crash when using E.getSizeOf() in some cases\n            Make sure a TCPIP connection closes even if no data sent\n            Make `flash.erasePage` safe if called without arguments (fix #586)\n            Add `Pin.getInfo` to see what a Pin can do (for #93)\n            Move Pin function code out of jshardware\n            Add `E.on('init', ...)` - like `onInit` but allows multiple handlers\n            Make sure `dump()` and `E.dumpStr()` dump the contents of Serial as well as events for other objects\n            `E.getSizeOf(.., 1)` can now recurse into objects showing the sizes of all their children (fix #579)\n            Fix bug when appending to a flat string (fix #614)\n            Add `Serial/SPI/I2C.find(pin)` - so we can figure out what device to use based on the pin\n            Ensure that when uploading, each command gets checked for errors (rather than right at the end)\n            Fix writes on HTTP requests after a timeout, and add chunked encoding if the header is set.\n            Added pin info for bit-banded pin addresses (and jshGetPinAddress).\n\n     1v80 : Fix SD card IO that can corrupt SD card on file append since 1v73 (fix #536)\n            Fix some potential pointer issues in hashlib\n            Make debounced setWatch output state+time information (regression fix #537)\n            Shorten some internal property names (faster/less mem is 4 chars or under)\n            Change 'internal property' prefix from '>' (fix #540)\n            Duplicate properties in an object defn. now cause second to be used (fix #495)\n            Make sure `E.unmountSD` doesn't forget custom SD card configs from `E.connectSDCard`\n            Added support for USB CK pin (fix #544)\n            ES5 parseInt behaviour - don't treat numbers beginning with 0 as octals (fix #538)\n            SPI.send now returns Uint8Array when passed an array. Also takes `{data:X, count:Y}` as argument (fix #485)\n            Fix `parseFloat(Infinity)` (fix #314)\n            Speed up jsvIterateCallback for arraybuffers\n            SPI speed improvements, esp for SPI.write (fix #547)\n            TV out tidyup, and VGA output can now do line doubling\n            Merge in USB HID support for STM32F4 (keeping old USB for the F1)\n            Add built-in 'Flash' module to allow Flash memory to be accessed from user code\n            Pulled load/save code out of jshardware into jswrap_flash.c\n            Remove jsiOneSecondAfterStartup from Linux builds (fix #551)\n            Add RLE compression when saving to flash, increase Pico RAM from 3000 to 5000 vars (fix #543)\n            Fix `JSON.parse` when not given strings (fix #546)\n            Tweak Olimexino board - 700->1k vars, but lowered code flash to 6k\n            Disable flash prefetch on Pico (~1% slower, but less power and way more accurate ADC readings) (fix #545)\n            Now throw errors when 'in' is used on an invalid datatype (fix #550)\n            Updated (inaccurate) docs for Serial.write/print and removed duplicated code\n            Changed Pico's device class to 0x02 - now works on older Mac OS 10.6.8\n            Change reported USB HID type to 0, from 2 (mouse)\n            Improve digitalWrite/etc documentation\n            Add `pin.mode` and `pin.getMode` functions (mirroring `pinMode`)\n            `Serial.setup` now remembers options if none specified (fix #557)\n\n     1v79 : Fix Mac address parsing for top nibbles\n            Make bind reference function internals not copy them. Fix scoped vars in bind (fix #533)\n            Use jsvUnlockMany to tidy up code and save some space\n            jsiExecuteEventCallback can now take an arbitrary number of arguments\n            Allow setTimeout/setInterval to take extra arguments (fix #532)\n            Ensure HTTP is closed even when no data handler (fix #535)\n            Seed random number from analog input, add W.hwRand and E.srand (fix #534)\n            Fix timing bug when setting timeouts from intervals in Deep Sleep\n            Reduce timeout for IO (eg. I2C write) on F401 and F4\n            Tweaks to keep code size low enough for Olimexino\n\n     1v78 : Fix regression where SPI2/3 weren't working on most pins (fix #525)\n            Allow MAC address to be set for WIZnet (fix #527)\n            Ensure res.on('close') is called for empty HTTP requests (fix #528)\n            Ensure that A9 is never the default pin for USART1 output (fix #526)\n\n     1v77 : Add E.mapInPlace\n            Allowed ArrayBuffer Graphics to store pixels MSB-first\n            Added faster software SPI path for simple writes\n            Make sure filesystem support gets compiled into Espruino Pico\n            Fix jsvGetFlatStringPointer to return the correct address\n            Fix I2C2/I2C3 on Pico\n            Fix issue where garbage collect of a Flat String corrupted the free variable list\n            Fix issue where Array.sort on big array with identical elements failed (#515)\n            Add 'modules' variable, and set 'this' to 'exports' when parsing a module (fix #520)\n            Fix instanceof implementation (and fix mem leak) (fix #523)\n\n     1v76 : Merged in NetworkJS library (for JS networking implementations)\n            Ensure that 'wrapped' libraries are killed before timers/watches\n            Made 'Field or method doesn't exist' report back the field that doesn't exist\n            Added quick and dirty scripts/test262.js runner script\n            Fix propogation of Errors and Exceptions through function calls\n            Allow parsing of integers > base 16\n            Now allow functions with >16 arguments (fix #490)\n            Fix assert fail for syntax error in do or while loop\n            Maths operations now call Object.valueOf if it's needed\n            Fix assert fail when jswrap_object_getOwnPropertyDescriptor called with non-string\n            Fix Array.indexOf when array contains non-basic values\n            valueOf returns a type error when called on undefined\n            Make sure analogRead doesn't overwrite pin state if it was set previously with pinMode\n            Make sure pinMode works with ADC input mode\n            Tweak event handling - events such as `Serial.on('data'` now set `this` to `Serial`\n            Add Function.bind (fix #318)\n            Fix SPI.setup memory leak (fix #496)\n            Fix assert fail on debug builds on Waveform output (fix #511)\n            Added more allowed types of whitespace\n            Added String.prototype.trim() (fix #507)\n            Allow argument lists in Function() (fix #505)\n            Propagate `this` into eval (fix #513)\n\n     1v75 : Fixed issue with Pins/Bools as Array indices\n            Fix crash when out of memory while creating built-in object\n            Fix continue statement in nested loops (fix #501)\n            On Linux, Exit nonzero when an error occurs (fix #499)\n            Ensure that pipes 'complete' if the source closes (was previously only the destination)\n            Make HTTP/Sockets throttle reads so internal buffers don't get full when piping\n            Added http statusCode, statusMessage, and httpVersion\n\n     1v74 : On Espruino Board, allow setTime to use full 64 bits so setTime(Date.parse(\"...\")/1000) works\n            Fixed issues with Waveform after 1v72 update to flat strings\n            Added 'global' built-in value\n            Fix inaccuracy of 'Date.now()' on STM32\n            Improve jsvIteratorGetIntegerValue speed for arrays (fix #493)\n            Change process.env.EXPORTS to something more useful for compiler\n            Fix issue with graphics fill on PCD8544 LCD\n            Add TypedArray.slice (from ES6) to help modules that use I2C\n\n     1v73 : Add Uint8ClampedArray, remove code duplication in ArrayBuffer (fix #486)\n            Fix regression where accessing certain member names of an undefined variable would cause a crash (fix #488)\n            Fix behaviour of char code 16 at beginning of the line (it now doesn't re-add the prompt after processing the line)\n            Added jspGetNamedVariable for use in compiled JS\n            Fix glitchy time values on the Espruino Board (fix #394)\n            Fix getTime()==0 in onInit, which could break timeouts in onInit after a reset (fix #462)\n            Refactor Software SPI code into jsspi.c\n            Allow filesystem to work on user-defined pins (fix #427)\n\n     1v72 : Stop RTC being reset by hard reset (getTime will now be time since power first applied) (fix #412)\n            Allow Function.apply to take typed arrays (fix #442)\n            Allow arrays to be passed to digitalPulse so square waves can be created easily\n            Force inlining of jsvLock/UnLock on most systems - improves performance a lot\n            Fix issues with SPI.write, CS, and out of sync receive bytes\n            Fix do..while without trailing semi-colon\n            Ensure that &,|,^,etc all have different precedences (without extra recursion)\n            Used new semi-recursive parse for expressions\n            Fix filled column when fillpoly is off the end of the screen\n            Fixed reporting of Serial RX pullup in `dump()`\n            Add input thread on Linux, and fix idle and Ctrl+C behaviour (fix #451)\n            Stop huge amounts of input events blocking Espruino's timers (fix #452)\n            Add ability to use serial ports on Linux with Serial1.setup({path:\"/dev/ttyUSB0\"})\n            Started ability to use SPI from Linux\n            Added 'net' library with support for sockets\n            Fix JSON parse of negative numbers (fix #456)\n            Only keep RTC settings if the relevant oscillator is running (fix #444)\n            Finally fixed sporadic compilation problems with '-Os'\n            Fixed issues with intervals in onInit (#462)\n            Remove libraries from root scope (fix #463)\n            Fix pin namings on Nucleo boards\n            Fix addition of stdlib's exit on Nucleo debug\n            Allow setWatch to execute native functions inside the IRQ\n            When dumping typed arrays, use the size if all elements are 0 (fix #448)\n            eval() can now access local variables and function arguments (fix #460)\n            Added 'flat strings' for typed arrays.\n              - these use a continuous chunk of memory so are much faster\n            Ensure that we only create as many Serial/I2C/etc items in Symbol table as we need (fix #453)\n            Allow modules to return whatever was assigned to exports - not just the original object\n            Allowed E.nativeCall (assembler/compiled functions) to execute directly from a flat string\n            Working F401 USB VCP bootloader\n            Make Press-poweron-release-press boot back into Espruino (this may confuse your OS)\n            Assert failures (in non-release builds) now reboot the system on ARM\n            Fix issues with freeing of variables not clearing the lock flags (fix #474)\n            Make Uint32Array actually return uints (even if they're so big they have to be represented as doubles)\n            Allow peek/poke to read and write arrays of values\n            Add Boolean constructor (fix #311)\n            Fix difference between String() and String(undefined) (fix #312)\n            Fix I2C/SPI on F401/F411-based boards (fix #470, fix #473)\n            Improved ArrayBuffer write performance\n            Massively improved ArrayBuffer Graphics fill performance for bpp<8\n            Fix issues with floating point on devices with <1024 vars (using 12 byte JsVar)\n            Add ability to change I2C bit rate from I2C.setup\n            Added VGA TV output\n            Added E.toString (for converting anything into a string)\n            Pulled Typed Array creation into its own function\n            Added E.toString and E.toUint8Array\n            Made I2C.readFrom return a Uint8Array (fix #479)\n            Allow multiple byte OneWire reads and writes\n            Fix setWatch on F3Discovery (fix #183)\n            Ensure that E.getSizeOf() works for ArrayBuffers (fix #484)\n            Don't allocate Flat Strings if we can get away with 2 normal string blocks\n              - it's actually faster to allocate and uses less memory\n\n     1v71 : Allowed WIZnet + CC3000 to be instantiated on any pins\n            Fix break inside loop inside case inside function (fix 428)\n            Added fs.stat and File.seek (fix #429, fix #430)\n            Allow use of DLE (char 16) on an empty line to turn echo off for *just that line*\n            Add XON/XOFF flow control on Serial + USB. This is enabled by default for Serial (fix #20)\n            Fix irregular timing on Espruino boards with clock crystal (inc rev 1v4)\n            Sort out 'Number()' constructor not being picky enough - parseFloat now parses 'Infinity' (Fix #325, mostly fix #322)\n            Stop iterator in FOR loop being called once more after a break\n            Fix bug allObjects found with iterating over undefined\n            Fix ArrayBuffer.sort issue with element size >1\n            Fix network de-initialisation on Linux\n            Fix reference count issue caused by removing a timer that had already been removed\n            Power up SYSCFG on F2/3/4 parts, allowing watch to work on ports other than A\n            Wait after setting the RTC time, to allow registers to update (fix #438, fix #441)\n            Now using gcc-arm-none-eabi-4_8-2014q3 for compilation - CodeSourcery stopped being supported\n\n     1v70 : Make pipe remove its drain/close listeners. Stops out of memory for repeated piping.\n            Fix parseInt for values too large to go in an int (#406)\n            Fix integer maths when result is too large for an integer\n            Fix mod operator with NaN/Infinity (fix #315)\n            Fix signed array values in PACKED_BIT devices\n            Drop JsVar size from 20 bytes to 16, increase Espruino variable count accordingly\n            Fix Array.fill on sparse arrays (fix #410)\n            Allow I2C repeated start (fixes some odd I2C devices, fix #390)\n            Refactoring to use iterators wherever possible\n            Merge fs_kill and file_kill to ensure that files always die before the filesystem\n            Add `E.unmountSD()` to allow SD cards to be removed once they have been used\n            Stop String.split(\"\") adding an empty elementy to the array\n            Tidy up linker script, allow F401 to use 3x16kB pages for storing program data\n            Fix regression in long timeouts (fix #416)\n            Use 'interval' var to specify if we're an interval or not (don't use 'recur' var)\n            Stop while/for/etc resetting exception state (fix #419)\n            Add  E.getSizeOf (fix #421)\n            Fix jsvCountJsVarsUsed for names with values\n            Make hidden names smaller to save a few JsVars\n            If there's only one function scope, don't define an array and save 2 JsVars\n            Fix setInterval on non-F1 boards (fix #415)\n            Fix issue where large doubles (> +/- 2^31) were converted to -1 rather than truncated ints\n            Fix E.getSizeOf (fix #424)\n            Fixed JSON indentation issue\n            Made 'pretty' JSON output look a bit better\n\n     1v69 : Fix 1v67's regression of digitalPulse when doing lots of pulses\n            Add configurable OneWire search command (for finding DS18B20s with alarm set)\n\n     1v68 : Fix memory leak in String.split\n            Fix references to `this` - you can now write `this[\"LED1\"]`\n            Fix memory leak when calling toString on a normal object\n            Fix memory leak in Graphics.createArrayBuffer\n            Fix memory leak when joining arrays containing null\n            Fix memory leak when syntax error while getting function arguments\n            Fix memory leak test when running on Linux\n            Fix memory leak in filesystem file open (when failure)\n            Fix memory leak on Syntax error\n            Stop multiple exceptions from being reported (eg. Syntax Errors)\n            Fix parsing of '!!' when not executing\n            Improve Error.toString, and fix bug when an exception was thrown from a function\n            Improve jsvObjectGetChild when out of memory\n            Switch native function decls from 32 bits to 16\n            Swap HY2.4 board to software LCD driver as well, work out pin mappings from PY file\n            Fix inaccuracy in setInterval, which had started since 32 bit switch in 1v65\n            Store JSWAT_EXECUTE_IMMEDIATELY in a way that will fit in 16 bit function decls\n            Allow bit-packing of refs for low memory boards (fix #145)\n            Now dump 'debounce' for setWatch\n            Make sure that dump() outputs correct JS for undefined variables\n            Allow pin counts per port of >31 on Linux-based systems\n            Fix issue with lost high-speed events when using setWatch with small debounce\n            Fix HTTP client regression\n            Fix Date constructor issue (uninitialised variable) (fix #408)\n            Fix invalid conversion of large ints to floats on ARM\n            Fix reset behaviour for non-standard default Serial ports\n\n     1v67 : Lower size of timer task array of devices with little RAM (fix #401)\n            Move hidden lists out of the root scope (fix #357)\n            Fixed exception catching\n            Fix Serial1 initialisation after 'reset()'\n            Fix parsing of try..catch when a serious error (not an exception) occurred\n            Stop the utility timer queue filling with WAKEUP tasks if Espruino gets woken up early\n            Add ability to specify default Serial TX and RX pins in BOARD.py\n            Reduce how many digits of floating point values are normally displayed\n            Fixed PWM output on B4 + B5\n            Fix regression when using pins as array indices\n            Remove negation for CHxN outputs - it seems they don't negate after all. Fixes PWM polarity on A7,B1,B13,B14,B15\n            Add pullup to USART RX. Reduces wakeups and random characters on Serial1.\n            Add error flags and E.getErrorFlags to report possible issues like buffer overflows and low memory (fix #136)\n            I2C timeouts now throw exceptions (fix #403)\n            Fix String.prototype.split with non-string args\n            Add fake digital pins D0..D7 under linux (helps with testing)\n            Rewrite ff_wtoupper and save 650 bytes \\o/ (fix #368)\n            Update Makefile to make it easier to cross-compile RPi->Espruino board\n            Fix HYSTM32_32 LCD at the expense of a bit of speed (fix #137, fix #327)\n\n     1v66 : Ensure that analogWrite(pin,1) works on negated outputs\n            Allow multiple Waveform playback on one pin (+ wave fixes)\n            Improve dump() for objects and Serial.on('data') (part of #397)\n            Fix Date.getSeconds,Milliseconds, and documentation on getMonth (#399)\n            Fix memory leak on Serial receive\n            Fix all Serial receive characters being 0 if no bytesize is specified\n\n     1v65 : SPI.send/I2C.write/Serial.write can now take variable number of arguments (fix #370)\n            Don't check for token matches where we already know what it should be (fix #280)\n            Improve file read speed for large reads\n            Waveform stability improvements\n            Fix Float32Array.set (and improve speed for non-float arrays)\n            OneWire library now uses hex strings for addresses rather than 64 bit ints\n            Fix issue with uninitialised function arguments (fix #391)\n            Fix parseURL for numeric keys in query string (fix #388)\n            When running JS files under Linux, do two parses to ensure that Functions are 'hoisted'\n            Add Object.create()\n            Add Function constructor\n            Add Object.getOwnPropertyDescriptor (although it won't return spec-compliant values)\n            Add some Stubs for inbuilt Date and Error classes\n            Added throw and try..catch..finally (see #40)\n            Fixed overriding of builtins with other Builtins\n            Added Date.valueOf\n            Stop warning about break at the end of 'default' in switch statement\n            Switch to 32 bit ints (fix #324)\n            Added Array.prototype.reverse, and also for ArrayBuffers (fix #389)\n            Swap JsVar fields around so everything is aligned on the correct boundaries\n            Merge jsvNewWithFlags and jsvNew - making variable allocation a bit faster\n            Fix changeInterval regression after int32 changes\n            Remove JSV_NAME flag - paving the way for more efficient variable storage\n            Store only 32 bit time for events (work out full 64 bits in event loop)\n            Increase event buffer size to 128 (from 64)\n            Enabled Graphics + CC3k support in the F3Discovery\n            Make `Serial.onData` call back with >1 char (#383)\n            Move `Serial.onData(...)` to `Serial.on('data',...)`\n            Add Serial.read/available/pipe (fix #383)\n            Add HTTP client/server read/available/pipe\n            Add documentation for events (and tidy it up for constructors)\n            Stop HTTP server closing before all data has been read\n            Fixed parsing of multiple shifts\n            setWatch now reports the pin back (fix #275)\n            Fixed memory leak in g.getPixel with arraybuffers\n            Fixed memory leak in \"\".indexOf(\".\")\n            Fixed ArrayBuffer Graphics where width*height*bpp&7!=0\n            Converted parse errors to throw exceptions\n            Added Date.parse and Date.toString\n            Fix parsing of integers that are too big to fit in an int32 (they're stored as doubles)\n            Fix Linux Espruino when no tty is present\n            Shave a few bytes off size of jsiDumpState using printf\n            url.parse now unescapes the query string (fix #227)\n\n     1v64 : Fix 'a=[2,3,4];delete a[1];'\n            Make sure parseInt(\"0x01\",16)==1 and parseInt(\"0x01\")==1 but parseInt(\"0b01\",16)==0\n            Fix equality check used in switch, so false !== 0\n            Improve Math.pow accuracy for small integer powers (fix #374)\n            Make Ctrl-C only interrupt code if it has been running for too long (fix Ctrl-C -> CC3000 restart issues)\n            Removed duplication in symbol lookup (fix #372, fix #323, fix #343)\n            Fix JSON.stringify with circular references (fix #378)\n            Fix String.indexOf when search string is bigger than the string being searched (fix #377)\n            Add String.prototype.slice() (fix #376)\n            Changed to more compact binary search symbol table (fix #278)\n            hasOwnProperty now doesn't check prototypes #24\n            Added Object.getOwnPropertyNames (fix #79, fix #158)\n            Move 'constructor' into the correct place, be more aware of builtins in prototypes (helps #380)\n            Handle __proto__ on builtin object types (eg. [].__proto__) (fix #381)\n            Remove indirection of __proto__ (fix #102)\n            Properly fix Object.getOwnPropertyNames (fix #380)\n            Remove jsvFindChild*Ref (fix #375)\n            Added LoopbackA/LoopbackB serial ports (fix #61)\n            Fix slowdown when lexing long strings\n            Remove Lock/UnLock in jslGetNextCh - should speed it up\n            fs.appendFile() now works even if the file doesn't exist (fix #385)\n            Support unicode escape sequence (\\uXXXX) but crop to 8 bits (fix #386)\n            Stop setInterval/etc increasing index numbers (fix #382)\n            Clear existing digitalWrites on reset() (fix #231)\n            Stop setWatch getting invalid data on load/save/reset (fix #254)\n\n     1v63 : Memory leak when defining functions (fix #359)\n            Fix Instance properties overwrite prototype (fix #360)\n            Fix `edit(functionName)` without quotes (fix #356)\n            Fix 'Uint32Array is not unsigned' (fix #330)\n            Ensure Object.keys([9,,undefined,9])==[0,2,3] (partial #349)\n            Store array length in the array root node rather than the last element (fix #351 #361)\n            Object.keys on array now returns strings (fix #348)\n            Remove jsvArrayGetLast (fix #363)\n            Fix issue parsing `function() { return }`\n            Stop jspNewObject creating a new object name if one already exists\n            startup_stm32f10x_hd.s now explicitly sets the stack pointer. Allows Espruino images to use more RAM\n            Add BusFault hander, to allow peek and poke to unmapped addresses without HardFaulting the ARM\n            Fix edit(...) so that functions themselves (not just the variable) are updated (fix #366)\n            Crop lines in errors when > 60 chars (fix #364)\n            Improve when stack traces happen for error reporting\n            Better error messages, and more efficient handler\n            Improving Util Timer rescheduling to try and avoid 64 bit divisions\n            Fix a lot of WIZnet W5500 issues (thanks @mgg1010!)\n            Add E.reverseByte\n            Add HIGH and LOW (fix #371)\n            Improve docs for SPI/I2C/Serial.setup\n            Force reconnect on CC3000 disconnect (fix #373)\n            Added cephdon's streaming file API (fix #12)\n            More WIZnet W5500 stability fixes - try and ensure that HTTP server never goes down\n            Fix HTTP client Host header when accessing ports!=80\n\n     1v62 : Added ArrayBufferView functions as per ES6 spec (fix #310)\n            Added Graphics.setRotation (fix #321)\n            Added Graphics.drawImage (fix #198)\n            Added E.toArrayBuffer for fast string->array conversion\n            Accessing an undefined array/object element now doesn't create it (fix #63)\n            Fix fs.unlink returns true if the file does not exist (fix #331)\n            Try and improve timer overlays by reordering the alternate function list\n            Ensure that PWM output doesn't enable negated/non-negated outputs when it doesn't have to\n            Improve console performance when sending long strings\n            Initialise Graphics flags Graphics.createCallback - could have caused all kinds of issues\n            Now make setInterval > 5s less accurate when setDeepSleep is on (saves ~0.5 sec of non-sleep time)\n            Fixed problem when accessing an array with a string in a variable\n            Fix issues with `\"0\" in {0:1}` (and hasOwnProperty)\n            Improved interpolate function, and moved it out of ArrayBufferView into E\n            Fix Problem with Object.keys on a string (fix #347)\n            Fix assert fail when deleting a property that doesn't exist (fix #344)\n            Ensure that dump remembers function names if they were in the root scope (fix #338)\n            Fix memory leak in fs.readdir\n            Ensure that abbreviations in console's '=...' output appear on newline if needed\n            Add String.replace (fix #334)\n            Make Graphics.drawImage draw bottom line of pixels (fix #329)\n            Add Array.shift/unshift (fix #342)\n            Fix Defining function after return causes error (fix #326)\n            Fix deleting the last element in array (fix #346)\n            More helpful I2C error messages (fix #10)\n            Fix overriding built-in functions (fix #202)\n            Add ES6 Array.prototype.fill (fix #317)\n            Modified jsiQueueObjectCallbacks (and Object.emit) to support >2 args\n            Added support for SPI LSB-first\n            WIZnet improvements (specifically on HTTP server)\n            Added WLAN.setIP for CC3000\n            Fix String.split issue with last element (fix #352)\n            Remove order warning for SPI if no order given (fix #353)\n            process.env will now contain the git commit\n            Move setInterval/Timeout implementations into jswrap_interactive (makes more sense)\n            Add setWatch warning if it's not possible (fix #337)\n\n     1v61 : Fix toString crash for large numbers\n            Support floating-point literals without a leading 0 - eg '.5' (fix #296)\n            Fix array access with booleans (fix #290)\n            Fix \"==\" issues where only one argument is an array (fix #283)\n            Make Array.join ignore null values (fix #289)\n            Callback graphics now works even without a fillRect implementation (fix #295)\n            ArrayBuffer Graphics now supports 2 and 4 bits as well as 1,8,16,24,32 (fix #301)\n            Allowed array.splice to as many arguments as needed\n            Make Array.sort() use string compare by default (fix #291, fix #292)\n            Allow [,] and [1,2,,4] - (fix #287)\n            Stop JSON.stringify using 'undefined' (fix #286)\n            function.call can now have more than 4 arguments\n            Rewrite native function caller (fix #277)\n            Fix conversion of floats to booleans (fix #307)\n            Fix parseInt of NaN/Infinity (fix #309)\n            Add extra escape codes in strings (fix #304)\n            Ensure String.charAt returns empty string for out of range (fix #305)\n            Make REPL faster when receiving large amounts of data (fix #303)\n            Improved jspeFunctionCall speed, added Named functions (fix #77)\n            Allow Array.map.forEach to be applied to Strings and ArrayBuffers (for #310)\n            Tweaks to make more Array functions work on non-arrays\n            Added Array.reduce\n            Allow commas in expressions at end of for loop - `for (;;i++,j++)`\n            Fix SPI send with a single number\n\n     1v60 : Fix unary plug on variable not working (fix #268)\n            Added DNS with eth.setIP() for W5500\n            Fix lock 'leak' when creating Graphics with callbacks\n            Small fixes for trigger/timer\n            Make dump() + console aware of built-in SPI/I2C/etc\n            Add Pin constructor for converting numbers into a pin object\n            Added getPinMode\n            Fixed I2C saving state (fix #270)\n            Add JTAG to ignore list for some boards\n            Fix LCD FSMC formatting and report if LCD is unknown\n            You can now reference built-in functions. eg. [1,2,3].map(Math.sqrt)\n            Add Object.valueOf - help with #187\n            Add Object.hasOwnProperty (although it does have some false positives) - #24\n            Add software SPI - fix #41\n            Fix issue when constructing an ArrayBuffer with a floating point length\n            Fix Math.round regression and add checks to ensure it can't happen again\n            Fix DEVICE_IS_XXX defines (fix SW SPI regression)\n            Fix hardware SPI regression (getting out of sync after ArrayBuffer write)\n            Removed non-standard Integer.valueOf - use \"A\".charCodeAt(0)\n            Fix non-standard ArrayBuffer behaviour when constructing an ArrayBuffer from an ArrayBufferView\n            Fix `1 in [2,3,4]` behaviour - it searches keys, not values\n            Make parseInt(..., >36) return NaN\n            Make Number.toString() use lowercase chars for hex\n            Fix issues with NaN, negative zero, and Math.round\n            Fix equality checks with null\n            Fix comparison of integers with empty string/whitespace+number\n            Added nativeCall, which allows C/Assembler to be called from JavaScript\n            Fix custom font memory leak\n\n     1v59 : (function(){})?1:0 should == 1 (fix #261)\n            Fix Math.pow (Fix #260)\n            Fix String.split() (Fix #259)\n            Added Array.concat (Fix #262)\n            Increase RTC/getTime reliability by ensuring overflow can't happen\n            Added Math.min/max\n            Allow jswrapper to wrap objects with a name >8 characters long (fix #264)\n            dump() now doesn't print 'var X = undefined;' - just 'var X;'\n\n     1v58 : Fix Serial.parity\n            Fix glitches in jshGetSystemTime\n            Added Graphics.setFontCustom for custom fonts\n            Added String.lastIndexOf, and made String.indexOf with fromIndex work\n            Used non-bold vector font, improve alignment, and make curves lower quality\n            I2C can now write any size (as long as it fits on the stack!)\n            Try and enlarge fillRects caused by polygons\n            Fix === issues, fix #257\n            Add Graphics.getColor/getBgColor for Juergen\n            Added E.convolve for doing fast calculations with Waveforms\n            Allow String.fromCharCode with multiple arguments\n            Add builtin_modules to board's JSON\n            Added E.FFT for Fast Fourier Transforms\n            Added 16 bit read/write to Waveform (and speed up utility timer)\n            Fix utility timer - now interrupts just in time\n\n     1v57 : Tweak IRQ priorities to try and make SPI RX more reliable\n            Make http default to port 80 if no port is specified in options\n            Try and stop issue with System Time suddenly jumping forwards\n            Fix assert fail when clearing and adding timeouts from within a timeout\n            Fix modulo (actually remainder) operator for floating point values :/\n\n     1v56 : Added atob and btoa (for base64 encode/decode) - fix #244\n            Added Array.sort() - fix #220\n            fs.writeFile/appendFile now return false if they fail for some reason\n            Move Graphics init and idle functions out of jsinterface.c\n            Add HttpServer.close\n            Ensure that Linux command-line tests keep running if there's something to do\n            Epic networking refactor - it should now be possible to support multiple network devices in a single binary\n            Now only remove the interval/timeout/watch that's causing the error - not every one\n            Change names of functions in callback-based Graphics so they don't conflict with the real ones\n            More CC300 reliability - now range check the return value from send+recv, because if there's a timeout it can be wrong\n            Fix memory leak in setWatch with debounce\n            Fix 'repeat:false' in debounced setWatch\n            Make sure 'repeat:false' disables the hardware watch\n            Initialise RTC roughly 1 sec after reset, and use external 32kHz oscillator if it exists\n            Added E.enableWatchdog (fix #252)\n            Fix negative start value for String.substr()\n            Fix problem where the RTC's full 32 bits weren't combined properly\n\n     1v55 : Add String.toUpperCase/LowerCase\n            Fix E.getAnalogVRef() regression\n            Add Math.tan()\n            Ensure Double/Integer have Number as a prototype (fixes: Number.prototype.n=function();(5.0).n() )\n            ||/&& now doesn't use booleans (fix #251)\n            More resilient parseInt behaviour\n            Allow data listener for HTTP POST (fix #226)\n            Stop JSON.parse using eval (fix #249, fix #208)\n            `.toString` is now called when a String is needed from an Object (fix #57)\n            Fixed reference count error when looking for functions in an Object's prototype\n            Fix issues with Numbers as Strings in maths (eg. '-5'|0)\n            Make sure NaN|0 == 0 (and not some huge number)\n            Ensure that [1.23]*1.0 == 1.23 (fix #91)\n            Don't pull in cos (use sin(x+PI/2))\n            Try and save flash memory on Olimexino board\n\n     1v54 : Add 4x6 font (instead of 8x8)\n            Fix occasional instability with Waveform read/write\n            Refactor JSON to improve speed and code size (using cbprintf)\n            Now print special 'short' JSON for console.log (and the REPL) (fix #47)\n            JSON.stringify now doesn't print functions (fix #207)\n            Refectoring jsparse.c to name functions after their JS Grammar names\n            IF statement now accepts commas\n            Ensure that undefined+0 == NaN (only worked for floats previously)\n            Fix assert fail (issue unlocking when executing built-in functions)\n            Fix setInterval regression in dump (and tidy up code)\n            FS lib now resets when issuing the reset() command (fix #200)\n\n     1v53 : Attempt to deal with the case where CC3000 crashes on initialization\n            Fix regression with setInterval/timeout and saving\n            Fix issue with saving Serial baud rates\n            Added ArrayBuffer.set\n            Use jswrapper.c for executing idle/init/kill events for libraries (cleans up jsinteractive.c)\n            Added beta 'Waveform' API to allow simple audio output\n            Improved non-deep-sleep power draw by allowing Espruino to wake itself on the Utility timer (rather than SysTick)\n            Allowed Waveform API to output on both DAC and PWM\n            Improve auto-generated documentation\n            Speed up ArrayBuffer.set and allow Strings to be used properly\n            Fix jsvArrayJoin if memory runs out\n            Added E.sum and E.variance array operations\n            Added Waveform Analog Input\n\n     1v52 : Fix memory leak in Array.slice\n            Fix broken Serial initialisation (partial fix for #241)\n            Add fs.unlink (for deleting files)\n            Fix url parsing when there are two slashes\n            Fix recent changeInterval regression\n            Making CC3000 recover properly in the case of repeated HTTP GET\n            Add alternate function remapping for Serial and improve Serial.setup error reporting, fix #241\n            Added preliminary WIZnet W5500 support (see http://www.espruino.com/WIZnet)\n            Alt Enter (27 + 10) now always inserts a newline: (eg. for `if (X) \\n Y`)\n            Fix digitalPulse with not a number\n            Make digitalPulse(... 0) wait until the last pulse is complete\n            Stop Espruino sending out so many carriage return characters (fix #243)\n            Added 'delete' keyword (fix #39)\n\n     1v51 : Added debounce to setWatch (fix #14)\n            Tidy up timeout/watch code and now store an integer for interval\n            Fix crash in url.parse (string free)\n            Fix Modules.addCached bug which means that Modules.removeAllModules created a memory leak\n            Fix regression introducted by fix for #199\n            Added 'Esc,[,2,K' escape sequence for clearing lines. Much safer than Ctrl+C which tends to break out of execution.\n            Fix bootloader (broken by LTO in 1v49)\n            Added Number.toFixed\n            Make number.toString(base) work for floating point (fix #232)\n            Fix Linux jshSleep so that timeouts are handled at <10ms if required (fixes test056)\n            Now use jshardware's SPI for SD filesystems - more multiplatform\n            Now ref thisVar, which stops it being repurposed into a Name for array accesses (fix #233)\n            Fix Linux halting when there is one long timeout but no other activity\n            fs.readFile returns 'undefined' if file is not found. Also make readdir return undefined on failure (fix #229)\n            Remove disk_timerproc in SD card implementation\n            Upgrade fatfs to R0.10a\n            Tweak jsinteractive.c to help reduce code size\n            Finally added Long filename support for FatFS (fix #78)\n            Epic refactor to remove JsParse (fix #17)\n            Implement faster Graphics ArrayBuffer fill (affects vector fonts + clear)\n            Stop repeated analogWrite with messing up PWM waveform (fix #56)\n            Swap open and close brackets in bitmap font (fix #191)\n            Graphics arraybuffer/callback now accepts 16bpp\n            Added ability to specify a JS function for Graphics fillRect\n            Graphics setPixel(x,y,undefined) to use foreground colour (fix #215)\n            Make sure that interruptions are handled better while drawing to graphics\n            Make sure that stack overflow errors are handled more tidily (and increase limit for warning)\n            Increase available stack on Espruino Board\n            Stop FatFS using insane amounts of RAM\n            High res timer (now to 1/2^23) using SysTick with RTC as a base (fix #168)\n            Added 'Infinity' constant\n            Fixed type equality check between int and float (should treat them as the same)\n            Fix parsing of '018' - it's not Octal after all (but 017 is)\n            More accurate values for PI and E\n            Fix charCodeAt being signed (should be unsigned)\n            When casting Strings to booleans, so s.length!=0\n            Guess initial values for average SysTick time - means that getTime is more accurate for the first 1-2 seconds after startup\n            setWatch now reports lastTime - time of last state change #238\n            analogWrite now respects pinMode (fix #234)\n            Add Open Drain support to pinMode (fix #225)\n            Fix calling Number([value]) always returns undefined (fix #186)\n            When disconnected from the net, make sure we free all HTTP clients/servers\n            Completely remove IRQs from CC3k code\n            Speed up CC3k code, try and make it automatically power cycle it on timeouts\n            Fix SPI MISO on F4 board\n            Move CC3000 to SPI3 (same pins) so SPI1 can be used for other things\n            Compile CC3000 support in for the F4 (untested)\n            Process.env now reports board serial # and current console device (se we can throttle for Bluetooth) (fix #219)\n            General bugfixing for low memory situations\n            Make string free non-recursive\n            Fix issue where fs.readFile of a big file would cause Espruino to crash\n            Fix memory test harness\n\n     1v50 : Fix broken Web IDE caused by change to printing JSON for console.log (part of #206)\n            Fix bug when trying to stringify {5:5}\n            Allow {1:2} to be parsed (fix #199)\n            Added SPI RX IRQ. Caved in and used a few bytes for buffers, made SPI significantly more reliable\n\n     1v49 : Change compiler flags to allow link-time optimisation\n            Increase buffer sizes on Linux\n            Increase buffer sizes on boards with >= 20kB RAM\n            Made Startup banner smaller\n            Less printing when loading from flash\n            Don't display startup banner if loading from flash (an easy way to fix #213)\n            Fix HTTP response code of 0 (fix #212)\n            Add timeouts to TI's CC3000 driver\n            Add timeouts for SPI, and other timeouts now interrupt execution\n            Lower USB interrupt priority, remove pesky PriorityGroupConfig that was breaking other IRQ priorities\n            Until we sort out SPI RX and IRQs, lower default SPI baud rate to stop timeouts\n            console.log and print output JSON now (part of #206)\n            Added handling of query in url.parse - still not fully compatible though (fix #205)\n\n     1v48 : Fix issue where the size of command history is being reported wrong and so process.memory().free is reported wrong too\n            We now loop without a seek to position inside the string (much faster if loop is not near the start of a fn) (fix #53)\n            Faster string iteration which doesn't involve incrementing it->index\n            Swapped to jumptable to lexer (should be a bit faster)\n            Added the 'E' class, with getAnalogVRef and getTemperature (fix #60)\n            Deprecated Math.clip (not in spec) and introduced E.clip\n            Fixed bug in common.py that meant that ifndefs in JSON were sometimes not obeyed (better mem usage on small chips)\n            Fix deep sleep breaking ADCs\n\n     1v47 : Fix issue with dump() and input_pullup not being quoted\n            Fix regression that broke OneWire in Espruino Board (#197)\n            Fix clock speed issue on SPI1 (https://github.com/espruino/EspruinoDocs/issues/18)\n            Don't interrupt on USB ESOF or ERR  - allows 'normal' sleep without interrupting every 1ms (fix #195)\n            Remove pointless KickStarter line printed on startup\n            Added bootloader hack to Python bootloader\n\n     1v46 : Fix parseFloat(\"\") not returning NaN, and parseFloat(\" \\t 5 \u00a3$%^&(*$\") returning NaN\n            Added isNaN() function (fix #184)\n            Fix parse order for 'typeof' (fix #172)\n            Added Number object (fix #165)\n            Bounded ftoa (stops crash when printing Number.MAX_VALUE) - helps with #185\n            Added Array.isArray() (fix #160)\n            Add do...while (fix #151)\n            Stop Espruino board from crashing if you try to create a web server without a connected CC3k (fix #182)\n            Remove Array.contains as it's not in the spec (use indexOf instead if you need it) (fix #161)\n            Fix nasty bug where adding/removing intervals/timeouts while in one could cause issues\n            Fix bug when printing 1.999999999 and similar (fix #190)\n            Remove need for pow for exponentiation. Not great but it fixes some tests that failed on FP inaccuracies\n            Change polarity of setSleepIndicator (fix #194)\n            Allow array.push with multiple arguments (fix #189)\n            Speed up array access by searching from the end backwards if we think the number is in the last half (fix #46)\n\n     1v45 : Fix parseFloat(\"foo\") not returning NaN (and assert) - fix #149\n            Remove Integer.parseInt\n            Fix parseInt(\"bar\") - fix #150\n            Ensure that maths ops with null do treat it as 0 rather than a string - fix #156\n            Fix digitalPulse length (properly!) - fix #154\n            Making sure that undefined gets cast to NaN\n            Fix Array.indexOf() returns undefined instead of -1 - fix #155\n            Moved memory() to process.memory() - added more info too\n            Try and improve handling of PWM timer speeds\n            Fixed varying SPI baud rates depending on device\n            Makefile changes for OSX compile\n\n     1v44 : Modified build system to store binary names in the python definition\n            Fix nasty regression involving losing code at the end of Strings\n            Fix segfault when pinMode is called on an invalid pin\n            Now disable interrupts during 4 bit SPI send - it's just too much otherwise\n            Detect unfinished block comments in console (fix #138)\n            Fix flash write on most 10XxB boards\n            Fix PWM output on all STM32 boards\n            General hardware tidy in prep for more intelligent device management\n            Run initialisation code before setWatch, to make sure pullup/down is set beforehand\n            Change 'Pin' datatype to be an unsigned char - makes tests easier\n            Now use the hardware RTC for keeping system time. Allows proper deep sleep on Espruino board\n            FINALLY - fix the USB VCP lost characters issue (#94)\n\n     1v43 : Added 'Modules' object with support for adding/removing cached modules\n            Allow product ID to be changed via Makefile\n            Fix documentation (and old-fashined Parsing style) for JSON\n            build_jswrapper now outputs errors to stderr (more compatible with default (silent) build process)\n            Fix issue when parsing quotes in strings\n            Added void operator for closure minification compatibility\n            Ensure that return takes the comma operator\n            Fix issue where printing Infinity would crash Espruino (fix #129)\n            Finally some working (extremely beta) cc3000 code\n            Added jsvObjectGet/SetChild to simplify some wrappers\n            'http' now uses JsVars for storage (so is suitable for non-linux devices)\n            Turned 'http' into a library\n            Added process.version and process.env (fix #131)\n            Changed handling of 2nd arg of << so that precedence is correct\n            Fixed handling of 'for (;;)'\n            Fix lock leak in Module handling\n            Update ST's library for the STM32F1\n            Update ST's VCP implementation\n            Added prefix operator (fix #130)\n            Allow espruino for linux to be run with '#!' in scripts\n            Fix indexOf on final element of strings (fix #133)\n            Remove JSV_PARENTINFO, as it turns out JS doesn't keep track of function scopes anyway (fix #109)\n            Make 'this' a keyword (now faster, more memory efficient)\n            Make 'Hardware' (root) the default value of 'this'\n            Add jsvArrayPushAndUnLock and modified code to use it (fix #135)\n            Now remember I2C state (partial fix for #13)\n            Replace 'pow' function with a smaller version - save ~2kb\n            Shaved another 1200 bytes off jslTokenAsString\n            Now store Pin state (fix for #13 on F1 parts, F4 still looks broken)\n            Added Graphics.stringWidth\n            Added internal Printf function\n\t           Misc speed and code size improvements\n            This version has gone to Seeed for use on the KickStarter boards\n\n     1v42 : [ebirger] allowing 'new' with no brackets\n            Allow built-in functions with variable numbers of arguments (fix #83)\n            Implement 'String' constructor in the normal way (fix #110)\n            Fix regression with parsing constructors while not executing\n            Allow multiple arguments to print and console.log (fix #92)\n            Make 'arguments' array available in functions (fix #100)\n            Fix an assert fail, and handle some potential memory leaks\n            Don't show __proto__ and constructor with for..in, keys(), or JSON.stringify\n            Make 'trace()' output more readable debug data for complex structures\n            Fix memory leak whe parsing functions iwht variable numbers of arguments - fix #115\n            Defined NaN\n            Stop 'new undefined()' crashing Espruino - fix #120\n            Get A13/A14 working on Espruino board (these were JTAG)\n            Get bootloader size direct from Python (remove hard-coding)\n\t           Fix '~' operator when acting on variables\n            Made bootloader a bit more error tolerate (CRC on write)\n            Added %=, /=, and *= operators (fix #121)\n            Allowed Object.toString() to take a radix argument for integers (fix #125)\n            Fix error message issue - broken strncat (fix #124)\n            Add comma operator (fix #122)\n            Added some basic code for STM32F429IDISCOVERY - not currently working though\n            This version is the one sent off on the Test Harness (so will probably appear on boards)\n\n     1v41 : Fix Olimexino compile (https://github.com/espruino/Espruino/issues/6)\n            [ebirger] Member constructors (eg. new a.b() )\n            [ebirger] Ensuring integers with radix specifiers can still be parsed if a radix is specified\n            Fix for tests/test_json_arraybuffer_001.js - iteration of arraybuffers of length==1\n            Add Object.keys(...)\n            More arraybuffer iteration fixes\n            On linux, use built-in stringToFloat to aid debugging. Handle exponentials, fix #31\n            'make serialflash' is now works correctly for Espruino Boards with bootloader\n            setWatch(..A0);setWatch(..A0);clearWatch(1) does not now kill the other watch, fix #25\n            One-based setTimeout/setWatch, fix #3\n            Added Function.call and Function.apply, fix #54\n            'http' and 'fs' are now libraries that need to be 'require'd, fix #8\n            Updated pin info for STM32F103xC/D/E chips, fix #84\n            Fixed linker script for STM32F4 (discovery board now works)\n            Object prototypes are now Objects, fix #101\n            Board docs now specify '3.3v' only pins fix #104\n            Add Array.forEach\n            Fix searching down >1 prototype to find functions (one more issue posted in #99)\n            Fix \"12345\"/5 type issues (fix #90)\n            'Consting' some string functions\n            Fixing arrays with string indices that are actually numbers \\o/ (fix #19)\n            Released onto website\n\n     1v40 : Ensure that LCD.prototype.setPixel = function actually works\n            Refactor LCD driver code to allow lcdInit (and start of making it non-platform-specific)\n            Built 'LCD' support into linux/raspi/carambola\n            Add initial SPI.send(ArrayBuffer) support - even if NO VALUES RETURNED\n            Start of built-in Nokia 5110 LCD support\n            Remove GPIO clock removal on sleep for now (it kills setWatch)\n            Fix (sub)ArrayBuffer problems (test100.js)\n            Added setDeepSleep - still beta put power consumption drops to 1mA\n            Fix broken name for httpCRq.write\n            Changed LCD to Graphics - added ability to render to ArrayBuffer\n            Fix 8 char built-in class names\n            Adding preliminary Sony SmartWatch support\n            Adding preliminary support for completely bare 36 pin chip\n            Fixing pin defs for Espruino board rev 1v1\n            Added proper SDL/ArrayBuffer and JS Callback graphics support\n            Added \"ifdef\" ability in build_jswrapper\n            Take JSVAR_CACHE_SIZE out of jsutils and put it in the board config file\n            Added JSV_PARENTINFO which will allow us to do things like setTimeout(foo.bar,10)\n            Fixed arrays in non-executes streams - 'if (0) print([1,2,3]);'\n            Added 'require' function loading modules from node_modules on SD card\n            Added module cache to stop modules being re-loaded\n            Renamed internal vars to start with '>' - much easier to distinguish for 'dump'/etc\n            Only use parentInfo on functions\n            Load all tests in test dir - don't do them by number\n            Added 'zigzag' ordering for ArrayBuffer Graphics\n            Added 'vertical_byte' ordering for ArrayBuffer Graphics\n            toJSON now ignores 'hidden' object elements\n            Special-case jsvArrayBufferIteratorSetIntegerValue\n            Make SPI output an ArrayBuffer\n            Use best out of 3 for DelayMicroseconds calibration - something seems flaky right after bootup\n\t           Lines now drawn from p1 to p2 inclusive\n\t           Events now use jshPushIOWatchEvent (should cut down on code) also fixed bug with watching pin #11\n\t           Now remember if pinMode was set or not\n       \t    Transform ```code``` in JSON into a code tag in the documentation\n            Graphics now supports FSMC for HY boards again\n            Drawing vector fonts is now roughly the right size and position (still not 100%)\n            Remove registration code\n            Adding MPL licence\n            Remove Arduino bit manipulation functions - nobody seems to use them anyway\n            # of flash pages/etc now comes from board info\n            [ebirger] Supply the correct arguments to Array.map\n            [ebirger] Method calls and membership evaluation should be done on all factors (ee. [1,2,3].foo())\n            [ebirger] When running multiple tests, only set up terminal once or it breaks the terminal window on exit\n            Added STM32-style USB CDC bootloader for Espruino Boards\n            Added scripts/create_espruino_image.sh to package up bootloader and espruino into one binary\n            SHIPPED on Impatient developer boards\n\n     1v39 : Added Bitwise NOT operator\n            Added Raspberry Pi version to ZIP (with HTTP support)\n            Fixed load/save on Linux Devices\n            Added pinMode function (to allow pull-ups/pull-downs to be turned on)\n            SPI.send4bit/send8bit will now not mess up the final element\n            changeInterval now clears up stored up callbacks (eg, setInterval(.., 0.01)...wait...changeInterval(...,20)\n            Ctrl-C no longer prints anything, which avoids lockups\n            No longer print \"Execution Interrupted\" if nothing was interrupted!\n            Added >>>= >>= and <<=\n            When entering text interactively, ensure that there are no trailing spaces\n\n     1v38 : Tweaks for Arduino IDE compile\n            Removed '(char #)' from stack trace, as a bit pointless now\n            Added better reporting of execution location when Ctrl-C pressed\n            Urgent fix for non-working Olimexino since 1v33\n            Fix string comparison when strings contain \"\\0\"\n            Added LED1/2/OSC/SD/etc to Olimexino Board docs\n\n     1v37 : Urgent fix - power saving code made it difficult to re-flash Espruino (now only apply this to Espruino Board)\n\n     1v36 : Fix documentation for Array.pop()\n            Added some much better board documentation\n            Fixed DAC output on F3\n            Fixed DAC output on devices where PWM is also available and the alternate function is less than the DAC's\n\n     1v35 : Attempt to reduce power consumption when sleeping by turning off GPIO, and setting GPIOs to AIN on reset\n            Fix F3 issue where ADC/DAC weren't picked up properly\n            Tidy up register text and add KickStarter mention\n            var a = {}; a[LED1]=0; - not converted to String\n            JSON (and hence dump()) now dumps ArrayBuffer correctly\n\n     1v34 : Faster jshFromDeviceString\n            Preliminary support for flow control on Serial receive\n            Speed improvements by removing jsvGetRef from jsvUnLock\n            fast 4 byte pre-check in jsvFindChildFromString\n            Skip lock/unlock in FindChildFromString to help increase speed\n            When we unplug USB, only go to the default console device IF that is the device we're currently on\n            Support for custom Espruino board\n            Added ArrayBufferView.interpolate\n            16 bit SPI send for send4bit/sevrnd8bit (better reliability on low-end chips)\n            Fix JSON dump of typed array\n            Added Math.clip(x, min, max)\n            When saving on flash, don't do jslTokenAsString properly\n            B3/B4 move from alternate fn\n            Fix incorrect reporting of analog pins\n            Fix I2C.readFrom on STM32F1/4\n            Make 1/2 == 0.5 (was being sensible before, but now follow JS spec)\n            Ctrl-C while in timer fn clears timers (but not outside it)\n            Fixed broken clearInterval from within setInterval\n            Hopefully fixed issue on SSD1289 LCD controller\n            Trigger wheel handler to use interrupts\n            2D arraybuffer interpolation\n            Added Math.wrap, fixed a lot of trigger issues\n            Fixed SysTick priority/preempt problems\n            Slowed the SysTick timer back down for everything\n            Fix Int8Array signedness on F4 boards\n            Refactored source code tree\n\n     1v33 : fix character encoding issue of \"\\16\"+\"1\" != \"\\161\"\n            Refactoring of ArrayBuffer into iterator, and addition of a general purpose iterator\n            Fancier assert for debugging\n            jsvArrayJoin to use new iterator\n            for (i in ...) to use new iterator\n            I2C and SPI use new iterator\n            Serial.write() - to allow single ints to easily be written\n            changeInterval assert fail when given a function by accident\n            added peek8/poke8/peek16/poke16\n            memory() now takes account of command history size\n            memory() on ARM reports the end address of the stack - so it can be used as a scratchpad with peek and poke\n            Try and reduce code size by not inlining several functions\n            No refs for StringExts - so we get one more byte per JsVar (~5%) more storage efficiency\n            Move from jsvIsBuiltInFunction to computer-generated jswIsBuiltInFunction\n            When creating Objects, check for built-in function BEFORE creating an Object class for it\n            Built process now checks that flash usage is under the allowed value\n            Added short compare to jswHandleFunctionCall to reduce code size\n            Added 3 byte compare (4 byte read and AND off top byte) - faster, less code\n            Auto-generate jsvGetBasicObjectName from docs\n            No longer using refs for storing whether free or not - use flags with JSV_UNUSED and get one extra var with 8 bit refs\n            Switch to using STRING_0...STRING_MAX in flags, rather than specific bits in JsVarFlags - allows more that 15 chars to be used per JsVar\n            Make ArrayBuffers actually be ArrayBufferViews - saves on extra string-handling code at expense of one var\n            Make sure Uint8Array,etc inherits from ArrayBufferView\n            Fix issue where a '\\0' coming in from serial was not put in e.data properly\n            Don't inline some functions when we're trying to save on flash\n            Re-use sin for cos, pow for sqrt to reduce code size\n\n     1v32 : Fixed embarassing issue with 0.999==\"0.A\"\n            Added and checked Pin.writeAtTime on STM32\n            Now don't allocate events array - just allocate directly, which saves memory and is faster (although slighty out of order)\n            Docs: now Alphabetically sorted, and class instances not listed by accident\n            Fix issue where Ctrl-C on ANY Serial port caused execution to be interrupted\n            Updated busy indicator to cope with recent change to not allocate events in an array\n            Fixed I2C on HY 2.4 board - I2C needed hard reset\n            Added basic ArrayBuffers/TypedArray support\n            Fix memory leak when error created with [] on a non-array/object\n            Improved hyperlinking in documentation\n            Fix I2C receive bug on F4\n            Increased VL board's input buffer size\n\n     1v31 : Fix PWM output on TIMER1/8 pins of the STM32F4\n            Fix PWM output for negated timers\n            memory() now runs a GC pass\n            Fixed multiple occurrence of functions in reference\n\n     1v30 : STM32F1: fixed AF issue meant peripherals would never return from AF mode\n            STM32F1: When given an invalid pin, now reports if pins are 'af' or not\n            Updated SPI.setup docs to mention that you can't mix AF and non-AF\n            If one SPI pin is specified but others aren't, only that pin will be set up\n            Added Olimexino hack so SPI1.setup works as expected\n            Allow using [] on a function\n            Fix precedence issue, so var a = function() { return 1; }(); works\n            Update SPI documentation\n            for (i in f) can now iterate over functions\n            Optional argument to trace() for object to start tracing from\n            Small steps towards ArrayBuffers\n            Added smart edit that checks for internal functions, and uses Function.replaceWith\n            Added Function.replaceWith to replace the internals of a function while keeping the scope\n\n     1v29 : Some hacky sysfs-based IO for running on Linux\n            HTTP Callbacks are now stored as names so they can be changed on the fly (Linux only)\n            Successful compile for Carambola\n            Filesystem support on Linux\n            Switch to variable size ref counter (marginally more efficient on very small devices, safe on Linux)\n            Linux now has unlimited memory available\n            Added linux/sysfs 'setWatch' (non-irq driven, so very noddy)\n            Checked jswrapper check from using multi-char constants to a #define\n            Improve pin suggestions for SPI/I2C/USART\n            Auto-initialise USART with default values when setConsole is used\n            Support for new Graphics LCD types\n            3.2\" VCT6 board support\n\n     1v28 : Faster LCD fillrect for HY 2.8\n            Fix for multi-byte SPI writes on HY board at 1Mhz (touchscreen control bug)\n            Fix issue with delayMicrosecond calibration on HY (and hence OneWire)\n            Fixed digitalPulse on STM32VLDISCOVERY\n\n     1v27 : Fixed problem with OneWire constructor execution\n            Added |=, &= and ^=\n            Added Array.splice()\n            Faster, more ROM-efficient built-in symbol table\n            Fix for potential issue when using field accessor on an undefined var\n\n     1v26 : I2C Support on STM32F1 and STM32F4 boards too\n            Emergency cut in variables for Olimexino with bootloader (as flash usage has got too high for save to flash!)\n\n     1v25 : http.writeHead to accept an empty header\n            Fixed issue finding methods on built in classes (0 termination)\n            make sure http server with no data still sends headers...\n            Start of MINI-HY-2.8\" support (all ok, but no SD card yet)\n            Reduce RAM usage by consting some arrays that are not modified\n            Vector fonts now use polys - 8kb less ROM, and faster rendering\n            Start of LCD 'driver' code\n            Standard way of handling events, Object.on/emit/removeAllListeners - like Node.js's EventEmitter\n            Self-calibrating Microsecond delay (for intermal OneWire/etc)\n            OneWire class\n            Correct handling of built-in class constructors\n            Fix error when parsing a zero-argument function that has been given arguments\n            I2C support - currently ONLY tested on STM32F3 board\n\n     1v24 : SDIO-based fat driver on the HY STM32 board\n            Added DAC to the HY boards (103xE-based)\n            Re-named the fileSystem functions to make them more compatible with node.js (readFile/writeFile/etc)\n            Added fs.appendFile\n            Removed HTTP from the reference until it is included in some boards\n\n     1v23 : Fix 'ERROR: INTERNAL: stmADCChannel' on STM32VLDISCOVERY/F1 boards when accessing PA0\n            Reference now mentions which Espruino version it is for\n\n     1v22 : Important fix - Events got executed in the wrong order if they got queued up\n\n     1v21 : Ensure SPI clock does not stop between bytes\n            Added SPI.send4bit and SPI.send8bit\n            Made sure the VL board's code fits into available flash\n            Smart += that can append to a string rather than cloning it\n            dump() prints functions properly, rather than 'var f = function() {}'\n            Pageup/down move the cursor to the beginning/end of input\n            LCD draw/fill with negative x and y\n\n     1v20 : Add console.log\n            Fix automatic usleep for Linux\n            Added node.js-style HTTP server for Linux version\n            Fixed null-pointer issue when accessing something that doesn't exist on an object\n            Added node.js-style HTTP client for Linux version\n            Start of bit bashing functionality\n            for (i in \"ABCD\") console.log(i) -> 0,1,2,3\n            String array access (but not for writing - doesn't work in JS anyway)\n            String String.fromCharCode / charCodeAt\n            Added SPI baud rate setting\n            Vector font chars 'a' and '4' now work ok\n            Fix numeric exception when rendering a poly that has some identical points\n            Better digitalPulse (uses timer + interrupts)\n            analogWrite can now take an object with a 'frequency' argument for PWM\n\n     1v19 : Fixed issue where var M=Math;M.random() failed\n            Fixed issue with var U=USB;U.print(\"Hello\");\n            Remove loop iteration limit\n            Fix memory leak when a syntax error is in for '(i in arr)'\n            Save state of pin on setWatch interrupt (e.state)\n            Change setWatch to allow only on rise or fall as an option\n            clearWatch() clears all watches\n\n     1v18 : DAC support on F3/F4\n            Serial.setup() can also take a second parameter of an object {tx,rx}\n            Better support for dump() with echo/setBusyIndicator/etc\n            Better dumping of prototypes on built-in vars\n            Don't add chars<32 (Except tab) to the input line\n            SPI1/2/3/4.setup() to take an object {baud,sck,miso,mosi}\n            Better hardware initialisation code (not UARTS auto-init if they are used)\n            Fix issues with prototypes\n            Peek/poke instructions\n            Start of I2C support (not usable yet)\n            Added Math. ceil/floor/exp/log\n\n     1v17 : Support for running alongside the Maple bootloader\n            Fix parsing of numbers beginning with 0 when forceRadix!=8\n            Fixed USART1 on Maple/Olimexino devices\n\n     1v16 : Inlining of jsvLock/UnLock in jsvar.h to improve speed\n            Move non-hardware-dependent stuff into jsdevices\n            Move jshardware.c into targets/stm32/jshardware.c, create 'targets/linux' and use a single makefile\n            For + While loops work without reallocating lex\n            Fix AddNativeFunction when function already exists (and tests + saved state)\n            Change jsvFindChildFromX to use JsVar* from JsVarRef - saves a lot of lock/unlock\n            Handle new Foo() as per spec (return value + init of this+prototype) - still does not cope with non-object prototype\n            Beginning of SD card support (works on Olimexino, but not very flexible)\n            Fix for parse/eval when given non-strings\n            Strings can now contain '\\0'\n            Jumptable-friendly reserved word check\n            Jumptable-friendly builtin functions (massive refactor)\n            SPI support\n            HY board support, and graphics LCD\n            Added fillPoly, and Vector fonts\n            Added Registration code\n            Fixed some undefined function/array warnings\n            Much better HTML function documentation\n            Fixed edit() function\n            STM32F3 support, and now peripheral stuff is done with a script\n            explain what pins are available if a pin is not capable of requested fn\n            power on ADCs only when needed\n            LCD fillPoly speed improvements, + drawLine\n            Add datatype for Pin, so pins written to console by pin name rather than integer value.\n            Added Pin.set/Pin.reset\n            Change warning about 'undefined.' into an error (foo.reset() had unexpected consequences!)\n            Fix parsing of '1.0/-3'!\n            Add typeof and instanceof operators\n            Ensure that Serial1/SPI1/etc are objects of type 'Serial'/'SPI' - so prototypes can be added\n\n     1v15 : Escaping JSON strings\n            Fix parsing of octal numbers in strings (so don't have to be 3 chars long)\n            Drastically improved stack usage using small stub functions (at expense of a bit of speed)\n            dump() also dumps out prototypes for functions\n\n     1v14 : Fix complaint about pins during setBusyIndicator()\n            Increase available memory on OLIMEXINO\n            Added function memory() to return memory usage\n            setWatch now links to function names (rather than just functions)\n            dump() also handles Serial.onData(...)\n            Fix issue with JSON printing functions with arguments to console\n            prefix builtin variables with '_'\n            fix ArrayIndexOf when array contains undefineds\n            move all devices into one git repository\n            USB on F4\n            call onInit function/string if it exists when Espruino powers on\n            Compile F4 with -O2 - as we have the program memory for it\n            Serial3/4/5/6 on F4\n            Serial3 on Olimexino\n            Make Serial.onData() clear onData handler\n\n     1v13 : Operations like + on Object/Array convert them to strings rather than error\n            var now doesn't error if there is no semi-colon\n            Allow new line or line delete in multi-line editing\n            add edit(functionName) - which copies function definition into inputline so it can be updated\n            When printing lines, delete current inputline and then put it back in idle loop (only if echo=1)\n            Support *,/ etc on numpad\n\n     1v12 : Issue when printing lots of data and then disconnect USB\n            Hide USB/Serial in Dump()\n            add Array.map(fn(x), thisArg)\n            For newline, count [] and () (as well as {}) - also knows about comments/strings/etc\n            Fix assert fail is setTimeout with non-function\n            If space at end of input line, enter still executes\n            Removed some hard-coded arrays in favour of JsVar strings\n            Fix confusion with jsvIsName/jsvIsString\n            Handle numpad end key\n            Add code to check stack and stop stack overflow if too much recursion\n            Ensure that setTimeout/setWatch store the link to a function, not the function\n            Fix nasty ref loop in ref loop GC issue\n            Add dotty output\n            Fix memory leak when error in jspParseSingleFunction\n            Now run Garbage collection if we're idle, and we know we have a few ms spare\n            Added setSleepIndicator\n            Fix line/col indicator in errors/warnings\n            Fix JSON parsing and printing when 'undefined' encountered\n            Rewritten object handling code to be way more standard JavaScript compliant\n            Array initialisation with 'new Array()', also for Strings\n            Added a few more built in functions\n            Nice error reporting with line + pointer\n            fixed Math.random\n            Binary style ops on doubles now work - they are just converted to ints\n            Added boolean datatype\n\n     1v11 : Add Math functions\n            Add command history (and dynamic history free if low memory)\n            Fix broken jsvArrayPop\n            Add tests for and fix Array.indexOf\n            In-line editing for commands\n            Fix bug in basicVarEquals for big strings\n            More fixes for low memory conditions\n            Multi-line edit for commands (but no newline or line delete yet)\n            Handle Home, End + reverse delete keys\n            Fix nested for loops not handling interrupts correctly\n            Fix AppendString issue when given start value greater than string\n            Add 'changeInterval' to allow things created with setInterval to have the frequency changed (eg. stepper motor control)\n            Now puts itself to sleep to save power, when it knows nothing is required and it'll be woken up by SysTick before\n            Change Math library to avoid putting constants in RAM\n\n     1v10 : Increase FIFO size for VL\n            Marginally decrease amount of F4 vars to ensure they all fit in one flash sector\n            Allow strings to be longer than the max token size\n            '\"key\" in obj' syntax\n            Detect if in FOR or WHILE loop, and if not, disallow break and continue\n            Change min setInterval time to 0.1ms - F4 can get close to this\n            Better analog pin error message\n            USB support on Olimexino/Maple\n            Start of multiple COM port support (ioEvent queue)\n            Ctrl-C now clears the input line\n            Save state of 'echo' into flash with save()\n            Add 'setBusyIndicator(pin)' to set pin high when Espruino is busy\n            Inbuilt function handling speed improvements\n            Allow Serial comms via other UARTS. Serial1/2.onData and print/println\n            now inserts elements into arrays in the correct order (GetLength can be (is) now much faster)\n            Faster code to work out pins from strings\n            Automatically convert IDs in form A#,A##,B#,B## etc into numbers.\n            Built-in constants for LED1/BTN/etc.\n\n     1v09 : Enabled 'abs' by default\n            Added flash programming to STM32F4\n            analogWrite now working!\n\n     1v08 : Add preliminary STM32F4 support\n            Allowed test cases to test timers - eg. code in jsinteractive.c\n            Fix memory leak for timer\n            Fix memory leak for digitalWrite\n\n     1v07 : Fix string charAt\n            Fix watch on different pin\n            Pass arguments to event handlers - eg. time\n            digitalWrite/Read to take arrays of pins, and int for value\n\n     1v06 : Add break + continue\n            Add switch statement\n            Handle /r, /r/n or just /n for newlines - phone compatible\n            Handle different type of delete\n\n     1v05 : Allow setWatch/setTimeout/setInterval with a string\n            Handle adding Open bracket then deleting it\n            When calling a NAMED function, zero the scopes - this stops scope table overflow\n\n     1v04 : Renamed to Espruino\n            Fixed issue with event add when out of memory\n            If out of memory happens during a timer, kill all timers\n", "/*\n * This file is part of Espruino, a JavaScript interpreter for Microcontrollers\n *\n * Copyright (C) 2013 Gordon Williams <gw@pur3.co.uk>\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n *\n * ----------------------------------------------------------------------------\n * Recursive descent parser for code execution\n * ----------------------------------------------------------------------------\n */\n#include \"jsparse.h\"\n#include \"jsinteractive.h\"\n#include \"jswrapper.h\"\n#include \"jsnative.h\"\n#include \"jswrap_object.h\" // for function_replacewith\n#include \"jswrap_functions.h\" // insane check for eval in jspeFunctionCall\n#include \"jswrap_json.h\" // for jsfPrintJSON\n#include \"jswrap_espruino.h\" // for jswrap_espruino_memoryArea\n#ifndef SAVE_ON_FLASH\n#include \"jswrap_regexp.h\" // for jswrap_regexp_constructor\n#endif\n\n/* Info about execution when Parsing - this saves passing it on the stack\n * for each call */\nJsExecInfo execInfo;\n\n// ----------------------------------------------- Forward decls\nJsVar *jspeAssignmentExpression();\nJsVar *jspeExpression();\nJsVar *jspeUnaryExpression();\nvoid jspeBlock();\nvoid jspeBlockNoBrackets();\nJsVar *jspeStatement();\nJsVar *jspeFactor();\nvoid jspEnsureIsPrototype(JsVar *instanceOf, JsVar *prototypeName);\n#ifndef SAVE_ON_FLASH\nJsVar *jspeArrowFunction(JsVar *funcVar, JsVar *a);\n#endif\n// ----------------------------------------------- Utils\n#define JSP_MATCH_WITH_CLEANUP_AND_RETURN(TOKEN, CLEANUP_CODE, RETURN_VAL) { if (!jslMatch((TOKEN))) { CLEANUP_CODE; return RETURN_VAL; } }\n#define JSP_MATCH_WITH_RETURN(TOKEN, RETURN_VAL) JSP_MATCH_WITH_CLEANUP_AND_RETURN(TOKEN, , RETURN_VAL)\n#define JSP_MATCH(TOKEN) JSP_MATCH_WITH_CLEANUP_AND_RETURN(TOKEN, , 0) // Match where the user could have given us the wrong token\n#define JSP_ASSERT_MATCH(TOKEN) { assert(lex->tk==(TOKEN));jslGetNextToken(); } // Match where if we have the wrong token, it's an internal error\n#define JSP_SHOULD_EXECUTE (((execInfo.execute)&EXEC_RUN_MASK)==EXEC_YES)\n#define JSP_SAVE_EXECUTE() JsExecFlags oldExecute = execInfo.execute\n#define JSP_RESTORE_EXECUTE() execInfo.execute = (execInfo.execute&(JsExecFlags)(~EXEC_SAVE_RESTORE_MASK)) | (oldExecute&EXEC_SAVE_RESTORE_MASK);\n#define JSP_HAS_ERROR (((execInfo.execute)&EXEC_ERROR_MASK)!=0)\n#define JSP_SHOULDNT_PARSE (((execInfo.execute)&EXEC_NO_PARSE_MASK)!=0)\n\nALWAYS_INLINE void jspDebuggerLoopIfCtrlC() {\n#ifdef USE_DEBUGGER\n  if (execInfo.execute & EXEC_CTRL_C_WAIT && JSP_SHOULD_EXECUTE)\n    jsiDebuggerLoop();\n#endif\n}\n\n/// if interrupting execution, this is set\nbool jspIsInterrupted() {\n  return (execInfo.execute & EXEC_INTERRUPTED)!=0;\n}\n\n/// if interrupting execution, this is set\nvoid jspSetInterrupted(bool interrupt) {\n  if (interrupt)\n    execInfo.execute = execInfo.execute | EXEC_INTERRUPTED;\n  else\n    execInfo.execute = execInfo.execute & (JsExecFlags)~EXEC_INTERRUPTED;\n}\n\n/// Set the error flag - set lineReported if we've already output the line number\nvoid jspSetError(bool lineReported) {\n  execInfo.execute = (execInfo.execute & (JsExecFlags)~EXEC_YES) | EXEC_ERROR;\n  if (lineReported)\n    execInfo.execute |= EXEC_ERROR_LINE_REPORTED;\n}\n\nbool jspHasError() {\n  return JSP_HAS_ERROR;\n}\nvoid jspeiClearScopes() {\n  jsvUnLock(execInfo.scopesVar);\n  execInfo.scopesVar = 0;\n}\n\nbool jspeiAddScope(JsVar *scope) {\n  if (!execInfo.scopesVar)\n    execInfo.scopesVar = jsvNewEmptyArray();\n  if (!execInfo.scopesVar) return false;\n  jsvArrayPush(execInfo.scopesVar, scope);\n  return true;\n}\n\nvoid jspeiRemoveScope() {\n  if (!execInfo.scopesVar || !jsvGetArrayLength(execInfo.scopesVar)) {\n    jsExceptionHere(JSET_INTERNALERROR, \"Too many scopes removed\");\n    jspSetError(false);\n    return;\n  }\n  jsvUnLock(jsvArrayPop(execInfo.scopesVar));\n  if (!jsvGetFirstChild(execInfo.scopesVar)) {\n    jsvUnLock(execInfo.scopesVar);\n    execInfo.scopesVar = 0;\n  }\n}\n\nJsVar *jspeiFindInScopes(const char *name) {\n  if (execInfo.scopesVar) {\n    JsVar *it = jsvLockSafe(jsvGetLastChild(execInfo.scopesVar));\n    while (it) {\n      JsVar *scope = jsvSkipName(it);\n      JsVarRef next = jsvGetPrevSibling(it);\n      JsVar *ref = jsvFindChildFromString(scope, name, false);\n      jsvUnLock2(it, scope);\n      if (ref) return ref;\n      it = jsvLockSafe(next);\n    }\n  }\n  return jsvFindChildFromString(execInfo.root, name, false);\n}\n/// Return the topmost scope (and lock it)\nJsVar *jspeiGetTopScope() {\n  if (execInfo.scopesVar) {\n    JsVar *scope = jsvGetLastArrayItem(execInfo.scopesVar);\n    if (scope) return scope;\n  }\n  return jsvLockAgain(execInfo.root);\n}\nJsVar *jspeiFindOnTop(const char *name, bool createIfNotFound) {\n  JsVar *scope = jspeiGetTopScope();\n  JsVar *result = jsvFindChildFromString(scope, name, createIfNotFound);\n  jsvUnLock(scope);\n  return result;\n}\nJsVar *jspeiFindNameOnTop(JsVar *childName, bool createIfNotFound) {\n  JsVar *scope = jspeiGetTopScope();\n  JsVar *result = jsvFindChildFromVar(scope, childName, createIfNotFound);\n  jsvUnLock(scope);\n  return result;\n}\n\nJsVar *jspFindPrototypeFor(const char *className) {\n  JsVar *obj = jsvObjectGetChild(execInfo.root, className, 0);\n  if (!obj) return 0;\n  JsVar *proto = jsvObjectGetChild(obj, JSPARSE_PROTOTYPE_VAR, 0);\n  jsvUnLock(obj);\n  return proto;\n}\n\n/** Here we assume that we have already looked in the parent itself -\n * and are now going down looking at the stuff it inherited */\nJsVar *jspeiFindChildFromStringInParents(JsVar *parent, const char *name) {\n  if (jsvIsObject(parent)) {\n    // If an object, look for an 'inherits' var\n    JsVar *inheritsFrom = jsvObjectGetChild(parent, JSPARSE_INHERITS_VAR, 0);\n\n    // if there's no inheritsFrom, just default to 'Object.prototype'\n    if (!inheritsFrom)\n      inheritsFrom = jspFindPrototypeFor(\"Object\");\n\n    if (inheritsFrom && inheritsFrom!=parent) {\n      // we have what it inherits from (this is ACTUALLY the prototype var)\n      // https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/proto\n      JsVar *child = jsvFindChildFromString(inheritsFrom, name, false);\n      if (!child)\n        child = jspeiFindChildFromStringInParents(inheritsFrom, name);\n      jsvUnLock(inheritsFrom);\n      if (child) return child;\n    } else\n      jsvUnLock(inheritsFrom);\n  } else { // Not actually an object - but might be an array/string/etc\n    const char *objectName = jswGetBasicObjectName(parent);\n    while (objectName) {\n      JsVar *objName = jsvFindChildFromString(execInfo.root, objectName, false);\n      if (objName) {\n        JsVar *result = 0;\n        JsVar *obj = jsvSkipNameAndUnLock(objName);\n        // could be something the user has made - eg. 'Array=1'\n        if (jsvHasChildren(obj)) {\n          // We have found an object with this name - search for the prototype var\n          JsVar *proto = jsvObjectGetChild(obj, JSPARSE_PROTOTYPE_VAR, 0);\n          if (proto) {\n            result = jsvFindChildFromString(proto, name, false);\n            jsvUnLock(proto);\n          }\n        }\n        jsvUnLock(obj);\n        if (result) return result;\n      }\n      /* We haven't found anything in the actual object, we should check the 'Object' itself\n        eg, we tried 'String', so now we should try 'Object'. Built-in types don't have room for\n        a prototype field, so we hard-code it */\n      objectName = jswGetBasicObjectPrototypeName(objectName);\n    }\n  }\n\n  // no luck!\n  return 0;\n}\n\nJsVar *jspeiGetScopesAsVar() {\n  if (!execInfo.scopesVar) return 0; // no scopes!\n  // If just one element, return it (no array)\n  if (jsvGetArrayLength(execInfo.scopesVar)==1) {\n    JsVar *v = jsvGetLastArrayItem(execInfo.scopesVar); // this is faster than getting by index\n    return v;\n  }\n  // Copy this - because if we just returned it, the underlying array would get altered\n  return jsvCopy(execInfo.scopesVar, true);\n}\n\nvoid jspeiLoadScopesFromVar(JsVar *arr) {\n  jsvUnLock(execInfo.scopesVar);\n  execInfo.scopesVar = 0;\n  if (arr) {\n    if (jsvIsArray(arr)) {\n      // TODO: copy on write? would make function calls faster\n      execInfo.scopesVar = jsvCopy(arr, true);\n    } else {\n      // just a single item,but we must package it in an array\n      execInfo.scopesVar = jsvNewArray(&arr, 1);\n    }\n  }\n}\n// -----------------------------------------------\n/// Check that we have enough stack to recurse. Return true if all ok, error if not.\nbool jspCheckStackPosition() {\n  if (jsuGetFreeStack() < 512) { // giving us 512 bytes leeway\n    jsExceptionHere(JSET_ERROR, \"Too much recursion - the stack is about to overflow\");\n    jspSetInterrupted(true);\n    return false;\n  }\n  return true;\n}\n\n\n// Set execFlags such that we are not executing\nvoid jspSetNoExecute() {\n  execInfo.execute = (execInfo.execute & (JsExecFlags)(int)~EXEC_RUN_MASK) | EXEC_NO;\n}\n\nvoid jspAppendStackTrace(JsVar *stackTrace) {\n  JsvStringIterator it;\n  jsvStringIteratorNew(&it, stackTrace, 0);\n  jsvStringIteratorGotoEnd(&it);\n  jslPrintPosition((vcbprintf_callback)jsvStringIteratorPrintfCallback, &it, lex->tokenLastStart);\n  jslPrintTokenLineMarker((vcbprintf_callback)jsvStringIteratorPrintfCallback, &it, lex->tokenLastStart, 0);\n  jsvStringIteratorFree(&it);\n}\n\n/// We had an exception (argument is the exception's value)\nvoid jspSetException(JsVar *value) {\n  // Add the exception itself to a variable in root scope\n  JsVar *exception = jsvFindChildFromString(execInfo.hiddenRoot, JSPARSE_EXCEPTION_VAR, true);\n  if (exception) {\n    jsvSetValueOfName(exception, value);\n    jsvUnLock(exception);\n  }\n  // Set the exception flag\n  execInfo.execute = execInfo.execute | EXEC_EXCEPTION;\n  // Try and do a stack trace\n  if (lex) {\n    JsVar *stackTrace = jsvObjectGetChild(execInfo.hiddenRoot, JSPARSE_STACKTRACE_VAR, JSV_STRING_0);\n    if (stackTrace) {\n      jsvAppendPrintf(stackTrace, \" at \");\n      jspAppendStackTrace(stackTrace);\n      jsvUnLock(stackTrace);\n      // stop us from printing the trace in the same block\n      execInfo.execute = execInfo.execute | EXEC_ERROR_LINE_REPORTED;\n    }\n  }\n\n}\n\n/** Return the reported exception if there was one (and clear it) */\nJsVar *jspGetException() {\n  JsVar *exceptionName = jsvFindChildFromString(execInfo.hiddenRoot, JSPARSE_EXCEPTION_VAR, false);\n  if (exceptionName) {\n    JsVar *exception = jsvSkipName(exceptionName);\n    jsvRemoveChild(execInfo.hiddenRoot, exceptionName);\n    jsvUnLock(exceptionName);\n\n    JsVar *stack = jspGetStackTrace();\n    if (stack && jsvHasChildren(exception)) {\n      jsvObjectSetChild(exception, \"stack\", stack);\n    }\n    jsvUnLock(stack);\n\n    return exception;\n  }\n  return 0;\n}\n\n/** Return a stack trace string if there was one (and clear it) */\nJsVar *jspGetStackTrace() {\n  JsVar *stackTraceName = jsvFindChildFromString(execInfo.hiddenRoot, JSPARSE_STACKTRACE_VAR, false);\n  if (stackTraceName) {\n    JsVar *stackTrace = jsvSkipName(stackTraceName);\n    jsvRemoveChild(execInfo.hiddenRoot, stackTraceName);\n    jsvUnLock(stackTraceName);\n    return stackTrace;\n  }\n  return 0;\n}\n\n// ----------------------------------------------\n\n// we return a value so that JSP_MATCH can return 0 if it fails (if we pass 0, we just parse all args)\nNO_INLINE bool jspeFunctionArguments(JsVar *funcVar) {\n  JSP_MATCH('(');\n  while (lex->tk!=')') {\n    if (funcVar) {\n      char buf[JSLEX_MAX_TOKEN_LENGTH+1];\n      buf[0] = '\\xFF';\n      strcpy(&buf[1], jslGetTokenValueAsString());\n      JsVar *param = jsvAddNamedChild(funcVar, 0, buf);\n      if (!param) { // out of memory\n        jspSetError(false);\n        return false;\n      }\n      jsvMakeFunctionParameter(param); // force this to be called a function parameter\n      jsvUnLock(param);\n    }\n    JSP_MATCH(LEX_ID);\n    if (lex->tk!=')') JSP_MATCH(',');\n  }\n  JSP_MATCH(')');\n  return true;\n}\n\n// Parse function, assuming we're on '{'. funcVar can be 0. returns 'true' is the function included the 'this' keyword\nNO_INLINE bool jspeFunctionDefinitionInternal(JsVar *funcVar, bool expressionOnly) {\n  bool forcePretokenise = false;\n\n  if (expressionOnly) {\n    if (funcVar)\n      funcVar->flags = (funcVar->flags & ~JSV_VARTYPEMASK) | JSV_FUNCTION_RETURN;\n  } else {\n    JSP_MATCH('{');\n  #ifndef SAVE_ON_FLASH\n    if (lex->tk==LEX_STR) {\n      if (!strcmp(jslGetTokenValueAsString(), \"compiled\"))\n        jsWarn(\"Function marked with \\\"compiled\\\" uploaded in source form\");\n      if (lex->tk==LEX_STR && !strcmp(jslGetTokenValueAsString(), \"ram\")) {\n        JSP_ASSERT_MATCH(LEX_STR);\n        forcePretokenise = true;\n      }\n    }\n  #endif\n\n    /* If the function starts with return, treat it specially -\n     * we don't want to store the 'return' part of it\n     */\n    if (funcVar && lex->tk==LEX_R_RETURN) {\n      funcVar->flags = (funcVar->flags & ~JSV_VARTYPEMASK) | JSV_FUNCTION_RETURN;\n      JSP_ASSERT_MATCH(LEX_R_RETURN);\n    }\n  }\n#ifndef ESPR_NO_LINE_NUMBERS\n  // Get the line number (if needed)\n  JsVarInt lineNumber = 0;\n  if (funcVar && lex->lineNumberOffset && !(forcePretokenise||jsfGetFlag(JSF_PRETOKENISE))) {\n    // jslGetLineNumber is slow, so we only do it if we have debug info\n    lineNumber = (JsVarInt)jslGetLineNumber() + (JsVarInt)lex->lineNumberOffset - 1;\n  }\n#endif\n  // Get the code - parse it and figure out where it stops\n  JslCharPos funcBegin;\n  jslSkipWhiteSpace();\n  jslCharPosNew(&funcBegin, lex->sourceVar, lex->tokenStart);\n  int lastTokenEnd = -1;\n  lex->hadThisKeyword = lex->tk == LEX_R_THIS;\n  if (!expressionOnly) {\n    int brackets = 0;\n    while (lex->tk && (brackets || lex->tk != '}')) {\n      if (lex->tk == '{') brackets++;\n      if (lex->tk == '}') brackets--;\n      lastTokenEnd = (int)jsvStringIteratorGetIndex(&lex->it)-1;\n      JSP_ASSERT_MATCH(lex->tk);\n    }\n    // FIXME: we might be including whitespace after the last token\n  } else {\n    JsExecFlags oldExec = execInfo.execute;\n    execInfo.execute = EXEC_NO;\n    jsvUnLock(jspeAssignmentExpression());\n    execInfo.execute = oldExec;\n    lastTokenEnd = (int)lex->tokenStart;\n  }\n  bool hadThisKeyword = lex->hadThisKeyword;\n  // Then create var and set (if there was any code!)\n  if (funcVar && lastTokenEnd>0) {\n    // code var\n    JsVar *funcCodeVar;\n    if (!forcePretokenise && jsvIsNativeString(lex->sourceVar)) {\n      /* If we're parsing from a Native String (eg. E.memoryArea, E.setBootCode) then\n      use another Native String to load function code straight from flash */\n      int s = (int)jsvStringIteratorGetIndex(&funcBegin.it) - 1;\n      funcCodeVar = jsvNewNativeString(lex->sourceVar->varData.nativeStr.ptr + s, (unsigned int)(lastTokenEnd - s));\n#ifdef SPIFLASH_BASE\n    } else if (!forcePretokenise && jsvIsFlashString(lex->sourceVar)) {\n        /* If we're parsing from a Flash String (eg. loaded from Storage on Bangle.js) then\n      use another Flash String to load function code straight from flash*/\n        int s = (int)jsvStringIteratorGetIndex(&funcBegin.it) - 1;\n        funcCodeVar = jsvNewFlashString(lex->sourceVar->varData.nativeStr.ptr + s, (unsigned int)(lastTokenEnd - s));\n#endif\n    } else {\n      if (jsfGetFlag(JSF_PRETOKENISE) || forcePretokenise) {\n        funcCodeVar = jslNewTokenisedStringFromLexer(&funcBegin, (size_t)lastTokenEnd);\n      } else {\n        funcCodeVar = jslNewStringFromLexer(&funcBegin, (size_t)lastTokenEnd);\n      }\n    }\n    jsvUnLock2(jsvAddNamedChild(funcVar, funcCodeVar, JSPARSE_FUNCTION_CODE_NAME), funcCodeVar);\n    // scope var\n    JsVar *funcScopeVar = jspeiGetScopesAsVar();\n    if (funcScopeVar) {\n      jsvUnLock2(jsvAddNamedChild(funcVar, funcScopeVar, JSPARSE_FUNCTION_SCOPE_NAME), funcScopeVar);\n    }\n#ifndef ESPR_NO_LINE_NUMBERS\n    // If we've got a line number, add a var for it\n    if (lineNumber) {\n      JsVar *funcLineNumber = jsvNewFromInteger(lineNumber);\n      if (funcLineNumber) {\n        jsvUnLock2(jsvAddNamedChild(funcVar, funcLineNumber, JSPARSE_FUNCTION_LINENUMBER_NAME), funcLineNumber);\n      }\n    }\n#endif\n  }\n\n  jslCharPosFree(&funcBegin);\n  if (!expressionOnly) JSP_MATCH('}');\n  return hadThisKeyword;\n}\n\n// Parse function (after 'function' has occurred\nNO_INLINE JsVar *jspeFunctionDefinition(bool parseNamedFunction) {\n  // actually parse a function... We assume that the LEX_FUNCTION and name\n  // have already been parsed\n  JsVar *funcVar = 0;\n\n  bool actuallyCreateFunction = JSP_SHOULD_EXECUTE;\n  if (actuallyCreateFunction)\n    funcVar = jsvNewWithFlags(JSV_FUNCTION);\n\n  JsVar *functionInternalName = 0;\n  if (parseNamedFunction && lex->tk==LEX_ID) {\n    // you can do `var a = function foo() { foo(); };` - so cope with this\n    if (funcVar) functionInternalName = jslGetTokenValueAsVar();\n    // note that we don't add it to the beginning, because it would mess up our function call code\n    JSP_ASSERT_MATCH(LEX_ID);\n  }\n\n  // Get arguments save them to the structure\n  if (!jspeFunctionArguments(funcVar)) {\n    jsvUnLock2(functionInternalName, funcVar);\n    // parse failed\n    return 0;\n  }\n\n  // Parse the actual function block\n  jspeFunctionDefinitionInternal(funcVar, false);\n\n  // if we had a function name, add it to the end (if we don't it gets confused with arguments)\n  if (funcVar && functionInternalName)\n    jsvObjectSetChildAndUnLock(funcVar, JSPARSE_FUNCTION_NAME_NAME, functionInternalName);\n\n  return funcVar;\n}\n\n/* Parse just the brackets of a function - and throw\n * everything away */\nNO_INLINE bool jspeParseFunctionCallBrackets() {\n  assert(!JSP_SHOULD_EXECUTE);\n  JSP_MATCH('(');\n  while (!JSP_SHOULDNT_PARSE && lex->tk != ')') {\n    jsvUnLock(jspeAssignmentExpression());\n#ifndef SAVE_ON_FLASH\n    if (lex->tk==LEX_ARROW_FUNCTION) {\n      jsvUnLock(jspeArrowFunction(0, 0));\n    }\n#endif\n    if (lex->tk!=')') JSP_MATCH(',');\n  }\n  if (!JSP_SHOULDNT_PARSE) JSP_MATCH(')');\n  return 0;\n}\n\n/** Handle a function call (assumes we've parsed the function name and we're\n * on the start bracket). 'thisArg' is the value of the 'this' variable when the\n * function is executed (it's usually the parent object)\n *\n *\n * NOTE: this does not set the execInfo flags - so if execInfo==EXEC_NO, it won't execute\n *\n * If !isParsing and arg0!=0, argument 0 is set to what is supplied (same with arg1)\n *\n * functionName is used only for error reporting - and can be 0\n */\nNO_INLINE JsVar *jspeFunctionCall(JsVar *function, JsVar *functionName, JsVar *thisArg, bool isParsing, int argCount, JsVar **argPtr) {\n  if (JSP_SHOULD_EXECUTE && !function) {\n    if (functionName)\n      jsExceptionHere(JSET_ERROR, \"Function %q not found!\", functionName);\n    else\n      jsExceptionHere(JSET_ERROR, \"Function not found!\", functionName);\n    return 0;\n  }\n\n  if (JSP_SHOULD_EXECUTE) if (!jspCheckStackPosition()) return 0; // try and ensure that we won't overflow our stack\n\n  if (JSP_SHOULD_EXECUTE && function) {\n    JsVar *returnVar = 0;\n\n    if (!jsvIsFunction(function)) {\n      jsExceptionHere(JSET_ERROR, \"Expecting a function to call, got %t\", function);\n      return 0;\n    }\n    JsVar *thisVar = jsvLockAgainSafe(thisArg);\n    if (isParsing) JSP_MATCH('(');\n\n    /* Ok, so we have 4 options here.\n     *\n     * 1: we're native.\n     *   a) args have been pre-parsed, which is awesome\n     *   b) we have to parse our own args into an array\n     * 2: we're not native\n     *   a) args were pre-parsed and we have to populate the function\n     *   b) we parse our own args, which is possibly better\n     */\n    if (jsvIsNativeFunction(function)) { // ------------------------------------- NATIVE\n      unsigned int argPtrSize = 0;\n      int boundArgs = 0;\n      // Add 'bound' parameters if there were any\n      JsvObjectIterator it;\n      jsvObjectIteratorNew(&it, function);\n      JsVar *param = jsvObjectIteratorGetKey(&it);\n      while (jsvIsFunctionParameter(param)) {\n        if ((unsigned)argCount>=argPtrSize) {\n          // allocate more space on stack if needed\n          unsigned int newArgPtrSize = (argPtrSize?argPtrSize:(unsigned int)argCount)*4;\n          size_t newArgPtrByteSize = sizeof(JsVar*)*newArgPtrSize;\n          if (jsuGetFreeStack() < 256+newArgPtrByteSize) {\n            jsExceptionHere(JSET_ERROR, \"Insufficient stack for this many arguments\");\n            jsvUnLock(thisVar);\n            return 0;\n          }\n          JsVar **newArgPtr = (JsVar**)alloca(newArgPtrByteSize);\n          memcpy(newArgPtr, argPtr, (unsigned)argCount*sizeof(JsVar*));\n          argPtr = newArgPtr;\n          argPtrSize = newArgPtrSize;\n        }\n        // if we already had arguments - shift them up...\n        int i;\n        for (i=argCount-1;i>=boundArgs;i--)\n          argPtr[i+1] = argPtr[i];\n        // add bound argument\n        argPtr[boundArgs] = jsvSkipName(param);\n        argCount++;\n        boundArgs++;\n        jsvUnLock(param);\n        jsvObjectIteratorNext(&it);\n        param = jsvObjectIteratorGetKey(&it);\n      }\n      // check if 'this' was defined\n      while (param) {\n        if (jsvIsStringEqual(param, JSPARSE_FUNCTION_THIS_NAME)) {\n          jsvUnLock(thisVar);\n          thisVar = jsvSkipName(param);\n          break;\n        }\n        jsvUnLock(param);\n        jsvObjectIteratorNext(&it);\n        param = jsvObjectIteratorGetKey(&it);\n      }\n      jsvUnLock(param);\n      jsvObjectIteratorFree(&it);\n\n      // Now, if we're parsing add the rest of the arguments\n      int allocatedArgCount = boundArgs;\n      if (isParsing) {\n        while (!JSP_HAS_ERROR && lex->tk!=')' && lex->tk!=LEX_EOF) {\n          if ((unsigned)argCount>=argPtrSize) {\n            // allocate more space on stack\n            unsigned int newArgPtrSize = argPtrSize?argPtrSize*4:16;\n            JsVar **newArgPtr = (JsVar**)alloca(sizeof(JsVar*)*newArgPtrSize);\n            memcpy(newArgPtr, argPtr, (unsigned)argCount*sizeof(JsVar*));\n            argPtr = newArgPtr;\n            argPtrSize = newArgPtrSize;\n          }\n          argPtr[argCount++] = jsvSkipNameAndUnLock(jspeAssignmentExpression());\n          if (lex->tk!=')') JSP_MATCH_WITH_CLEANUP_AND_RETURN(',',jsvUnLockMany((unsigned)argCount, argPtr);jsvUnLock(thisVar);, 0);\n        }\n\n        JSP_MATCH(')');\n        allocatedArgCount = argCount;\n      }\n\n      void *nativePtr = jsvGetNativeFunctionPtr(function);\n\n      JsVar *oldThisVar = execInfo.thisVar;\n      if (thisVar)\n        execInfo.thisVar = jsvRef(thisVar);\n      else {\n        if (nativePtr==jswrap_eval) { // eval gets to use the current scope\n          /* Note: proper JS has some utterly insane code that depends on whether\n           * eval is an lvalue or not:\n           *\n           * http://stackoverflow.com/questions/9107240/1-evalthis-vs-evalthis-in-javascript\n           *\n           * Doing this in Espruino is quite an upheaval for that one\n           * slightly insane case - so it's not implemented. */\n          if (execInfo.thisVar) execInfo.thisVar = jsvRef(execInfo.thisVar);\n        } else {\n          execInfo.thisVar = jsvRef(execInfo.root); // 'this' should always default to root\n        }\n      }\n\n\n\n      if (nativePtr && !JSP_HAS_ERROR) {\n        returnVar = jsnCallFunction(nativePtr, function->varData.native.argTypes, thisVar, argPtr, argCount);\n        assert(!jsvIsName(returnVar));\n      } else {\n        returnVar = 0;\n      }\n\n      // unlock values if we locked them\n      jsvUnLockMany((unsigned)allocatedArgCount, argPtr);\n\n      /* Return to old 'this' var. No need to unlock as we never locked before */\n      if (execInfo.thisVar) jsvUnRef(execInfo.thisVar);\n      execInfo.thisVar = oldThisVar;\n\n    } else { // ----------------------------------------------------- NOT NATIVE\n      // create a new symbol table entry for execution of this function\n      // OPT: can we cache this function execution environment + param variables?\n      // OPT: Probably when calling a function ONCE, use it, otherwise when recursing, make new?\n      JsVar *functionRoot = jsvNewWithFlags(JSV_FUNCTION);\n      if (!functionRoot) { // out of memory\n        jspSetError(false);\n        jsvUnLock(thisVar);\n        return 0;\n      }\n\n      JsVar *functionScope = 0;\n      JsVar *functionCode = 0;\n      JsVar *functionInternalName = 0;\n#ifndef ESPR_NO_LINE_NUMBERS\n      uint16_t functionLineNumber = 0;\n#endif\n\n      /** NOTE: We expect that the function object will have:\n       *\n       *  * Parameters\n       *  * Code/Scope/Name\n       *\n       * IN THAT ORDER.\n       */\n      JsvObjectIterator it;\n      jsvObjectIteratorNew(&it, function);\n\n      JsVar *param = jsvObjectIteratorGetKey(&it);\n      JsVar *value = jsvObjectIteratorGetValue(&it);\n      while (jsvIsFunctionParameter(param) && value) {\n        jsvAddFunctionParameter(functionRoot, jsvNewFromStringVar(param,1,JSVAPPENDSTRINGVAR_MAXLENGTH), value);\n        jsvUnLock2(value, param);\n        jsvObjectIteratorNext(&it);\n        param = jsvObjectIteratorGetKey(&it);\n        value = jsvObjectIteratorGetValue(&it);\n      }\n      jsvUnLock2(value, param);\n      if (isParsing) {\n        int hadParams = 0;\n        // grab in all parameters. We go around this loop until we've run out\n        // of named parameters AND we've parsed all the supplied arguments\n        while (!JSP_SHOULDNT_PARSE && lex->tk!=')') {\n          JsVar *param = jsvObjectIteratorGetKey(&it);\n          bool paramDefined = jsvIsFunctionParameter(param);\n          if (lex->tk!=')' || paramDefined) {\n            hadParams++;\n            JsVar *value = 0;\n            // ONLY parse this if it was supplied, otherwise leave 0 (undefined)\n            if (lex->tk!=')')\n              value = jspeAssignmentExpression();\n            // and if execute, copy it over\n            value = jsvSkipNameAndUnLock(value);\n            jsvAddFunctionParameter(functionRoot, paramDefined?jsvNewFromStringVar(param,1,JSVAPPENDSTRINGVAR_MAXLENGTH):0, value);\n            jsvUnLock(value);\n            if (lex->tk!=')') JSP_MATCH(',');\n          }\n          jsvUnLock(param);\n          if (paramDefined) jsvObjectIteratorNext(&it);\n        }\n        JSP_MATCH(')');\n      } else {  // and NOT isParsing\n        int args = 0;\n        while (args<argCount) {\n          JsVar *param = jsvObjectIteratorGetKey(&it);\n          bool paramDefined = jsvIsFunctionParameter(param);\n          jsvAddFunctionParameter(functionRoot, paramDefined?jsvNewFromStringVar(param,1,JSVAPPENDSTRINGVAR_MAXLENGTH):0, argPtr[args]);\n          args++;\n          jsvUnLock(param);\n          if (paramDefined) jsvObjectIteratorNext(&it);\n        }\n      }\n      // Now go through what's left\n      while (jsvObjectIteratorHasValue(&it)) {\n        JsVar *param = jsvObjectIteratorGetKey(&it);\n        if (jsvIsString(param)) {\n          if (jsvIsStringEqual(param, JSPARSE_FUNCTION_SCOPE_NAME)) functionScope = jsvSkipName(param);\n          else if (jsvIsStringEqual(param, JSPARSE_FUNCTION_CODE_NAME)) functionCode = jsvSkipName(param);\n          else if (jsvIsStringEqual(param, JSPARSE_FUNCTION_NAME_NAME)) functionInternalName = jsvSkipName(param);\n          else if (jsvIsStringEqual(param, JSPARSE_FUNCTION_THIS_NAME)) {\n            jsvUnLock(thisVar);\n            thisVar = jsvSkipName(param);\n          }\n#ifndef ESPR_NO_LINE_NUMBERS\n          else if (jsvIsStringEqual(param, JSPARSE_FUNCTION_LINENUMBER_NAME)) functionLineNumber = (uint16_t)jsvGetIntegerAndUnLock(jsvSkipName(param));\n#endif\n          else if (jsvIsFunctionParameter(param)) {\n            JsVar *defaultVal = jsvSkipName(param);\n            jsvAddFunctionParameter(functionRoot, jsvNewFromStringVar(param,1,JSVAPPENDSTRINGVAR_MAXLENGTH), defaultVal);\n            jsvUnLock(defaultVal);\n          }\n        }\n        jsvUnLock(param);\n        jsvObjectIteratorNext(&it);\n      }\n      jsvObjectIteratorFree(&it);\n\n      // setup a the function's name (if a named function)\n      if (functionInternalName) {\n        JsVar *name = jsvMakeIntoVariableName(jsvNewFromStringVar(functionInternalName,0,JSVAPPENDSTRINGVAR_MAXLENGTH), function);\n        jsvAddName(functionRoot, name);\n        jsvUnLock2(name, functionInternalName);\n      }\n\n      if (!JSP_HAS_ERROR) {\n        // save old scopes and reset scope list\n        JsVar *oldScopeVar = execInfo.scopesVar;\n        execInfo.scopesVar = 0;\n        // if we have a scope var, load it up. We may not have one if there were no scopes apart from root\n        if (functionScope) {\n          jspeiLoadScopesFromVar(functionScope);\n          jsvUnLock(functionScope);\n        }\n        // add the function's execute space to the symbol table so we can recurse\n        if (jspeiAddScope(functionRoot)) {\n          /* Adding scope may have failed - we may have descended too deep - so be sure\n           * not to pull somebody else's scope off\n           */\n\n          JsVar *oldThisVar = execInfo.thisVar;\n          if (thisVar)\n            execInfo.thisVar = jsvRef(thisVar);\n          else\n            execInfo.thisVar = jsvRef(execInfo.root); // 'this' should always default to root\n\n\n          /* we just want to execute the block, but something could\n           * have messed up and left us with the wrong Lexer, so\n           * we want to be careful here... */\n          if (functionCode) {\n#ifdef USE_DEBUGGER\n            bool hadDebuggerNextLineOnly = false;\n\n            if (execInfo.execute&EXEC_DEBUGGER_STEP_INTO) {\n\t      if (functionName)\n\t\tjsiConsolePrintf(\"Stepping into %v\\n\", functionName);\n\t      else\n\t\tjsiConsolePrintf(\"Stepping into function\\n\", functionName);\n            } else {\n              hadDebuggerNextLineOnly = execInfo.execute&EXEC_DEBUGGER_NEXT_LINE;\n              if (hadDebuggerNextLineOnly)\n                execInfo.execute &= (JsExecFlags)~EXEC_DEBUGGER_NEXT_LINE;\n            }\n#endif\n\n\n            JsLex newLex;\n            JsLex *oldLex = jslSetLex(&newLex);\n            jslInit(functionCode);\n#ifndef ESPR_NO_LINE_NUMBERS\n            newLex.lineNumberOffset = functionLineNumber;\n#endif\n            JSP_SAVE_EXECUTE();\n            // force execute without any previous state\n#ifdef USE_DEBUGGER\n            execInfo.execute = EXEC_YES | (execInfo.execute&(EXEC_CTRL_C_MASK|EXEC_ERROR_MASK|EXEC_DEBUGGER_NEXT_LINE));\n#else\n            execInfo.execute = EXEC_YES | (execInfo.execute&(EXEC_CTRL_C_MASK|EXEC_ERROR_MASK));\n#endif\n            if (jsvIsFunctionReturn(function)) {\n              #ifdef USE_DEBUGGER\n                // we didn't parse a statement so wouldn't trigger the debugger otherwise\n                if (execInfo.execute&EXEC_DEBUGGER_NEXT_LINE && JSP_SHOULD_EXECUTE) {\n                  lex->tokenLastStart = lex->tokenStart;\n                  jsiDebuggerLoop();\n                }\n              #endif\n              // implicit return - we just need an expression (optional)\n              if (lex->tk != ';' && lex->tk != '}')\n                returnVar = jsvSkipNameAndUnLock(jspeExpression());\n            } else {\n              // setup a return variable\n              JsVar *returnVarName = jsvAddNamedChild(functionRoot, 0, JSPARSE_RETURN_VAR);\n              // parse the whole block\n              jspeBlockNoBrackets();\n              /* get the real return var before we remove it from our function.\n               * We can unlock below because returnVarName is still part of\n               * functionRoot, so won't get freed. */\n              returnVar = jsvSkipNameAndUnLock(returnVarName);\n              if (returnVarName) // could have failed with out of memory\n                jsvSetValueOfName(returnVarName, 0); // remove return value (which helps stops circular references)\n            }\n            // Store a stack trace if we had an error\n            JsExecFlags hasError = execInfo.execute&EXEC_ERROR_MASK;\n            JSP_RESTORE_EXECUTE(); // because return will probably have set execute to false\n\n#ifdef USE_DEBUGGER\n            bool calledDebugger = false;\n            if (execInfo.execute & EXEC_DEBUGGER_MASK) {\n              jsiConsolePrint(\"Value returned is =\");\n              jsfPrintJSON(returnVar, JSON_LIMIT | JSON_SOME_NEWLINES | JSON_PRETTY | JSON_SHOW_DEVICES);\n              jsiConsolePrintChar('\\n');\n              if (execInfo.execute & EXEC_DEBUGGER_FINISH_FUNCTION) {\n                calledDebugger = true;\n                jsiDebuggerLoop();\n              }\n            }\n            if (hadDebuggerNextLineOnly && !calledDebugger)\n              execInfo.execute |= EXEC_DEBUGGER_NEXT_LINE;\n#endif\n\n            jslKill();\n            jslSetLex(oldLex);\n\n            if (hasError) {\n              execInfo.execute |= hasError; // propogate error\n              JsVar *stackTrace = jsvObjectGetChild(execInfo.hiddenRoot, JSPARSE_STACKTRACE_VAR, JSV_STRING_0);\n              if (stackTrace) {\n                jsvAppendPrintf(stackTrace, jsvIsString(functionName)?\"in function %q called from \":\n                    \"in function called from \", functionName);\n                if (lex) {\n                  jspAppendStackTrace(stackTrace);\n                } else\n                  jsvAppendPrintf(stackTrace, \"system\\n\");\n                jsvUnLock(stackTrace);\n              }\n            }\n          }\n\n          /* Return to old 'this' var. No need to unlock as we never locked before */\n          if (execInfo.thisVar) jsvUnRef(execInfo.thisVar);\n          execInfo.thisVar = oldThisVar;\n\n          jspeiRemoveScope();\n        }\n\n        // Unlock scopes and restore old ones\n        jsvUnLock(execInfo.scopesVar);\n        execInfo.scopesVar = oldScopeVar;\n      }\n      jsvUnLock(functionCode);\n      jsvUnLock(functionRoot);\n    }\n\n    jsvUnLock(thisVar);\n\n    return returnVar;\n  } else if (isParsing) { // ---------------------------------- function, but not executing - just parse args and be done\n    jspeParseFunctionCallBrackets();\n    /* Do not return function, as it will be unlocked! */\n    return 0;\n  } else return 0;\n}\n\n// Find a variable (or built-in function) based on the current scopes\nJsVar *jspGetNamedVariable(const char *tokenName) {\n  JsVar *a = JSP_SHOULD_EXECUTE ? jspeiFindInScopes(tokenName) : 0;\n  if (JSP_SHOULD_EXECUTE && !a) {\n    /* Special case! We haven't found the variable, so check out\n     * and see if it's one of our builtins...  */\n    if (jswIsBuiltInObject(tokenName)) {\n      // Check if we have a built-in function for it\n      // OPT: Could we instead have jswIsBuiltInObjectWithoutConstructor?\n      JsVar *obj = jswFindBuiltInFunction(0, tokenName);\n      // If not, make one\n      if (!obj)\n        obj = jspNewBuiltin(tokenName);\n      if (obj) { // not out of memory\n        a = jsvAddNamedChild(execInfo.root, obj, tokenName);\n        jsvUnLock(obj);\n      }\n    } else {\n      a = jswFindBuiltInFunction(0, tokenName);\n      if (!a) {\n        /* Variable doesn't exist! JavaScript says we should create it\n         * (we won't add it here. This is done in the assignment operator)*/\n        a = jsvMakeIntoVariableName(jsvNewFromString(tokenName), 0);\n      }\n    }\n  }\n  return a;\n}\n\n/// Used by jspGetNamedField / jspGetVarNamedField\nstatic NO_INLINE JsVar *jspGetNamedFieldInParents(JsVar *object, const char* name, bool returnName) {\n  // Now look in prototypes\n  JsVar * child = jspeiFindChildFromStringInParents(object, name);\n\n  /* Check for builtins via separate function\n   * This way we save on RAM for built-ins because everything comes out of program code */\n  if (!child) {\n    child = jswFindBuiltInFunction(object, name);\n  }\n\n  /* We didn't get here if we found a child in the object itself, so\n   * if we're here then we probably have the wrong name - so for example\n   * with `a.b = c;` could end up setting `a.prototype.b` (bug #360)\n   *\n   * Also we might have got a built-in, which wouldn't have a name on it\n   * anyway - so in both cases, strip the name if it is there, and create\n   * a new name that references the object we actually requested the\n   * member from..\n   */\n  if (child && returnName) {\n    // Get rid of existing name\n    if (jsvIsName(child)) {\n      JsVar *t = jsvGetValueOfName(child);\n      jsvUnLock(child);\n      child = t;\n    }\n    // create a new name\n    JsVar *nameVar = jsvNewFromString(name);\n    JsVar *newChild = jsvCreateNewChild(object, nameVar, child);\n    jsvUnLock2(nameVar, child);\n    child = newChild;\n  }\n\n  // If not found and is the prototype, create it\n  if (!child) {\n    if (jsvIsFunction(object) && strcmp(name, JSPARSE_PROTOTYPE_VAR)==0) {\n      // prototype is supposed to be an object\n      JsVar *proto = jsvNewObject();\n      // make sure it has a 'constructor' variable that points to the object it was part of\n      jsvObjectSetChild(proto, JSPARSE_CONSTRUCTOR_VAR, object);\n      child = jsvAddNamedChild(object, proto, JSPARSE_PROTOTYPE_VAR);\n      jspEnsureIsPrototype(object, child);\n      jsvUnLock(proto);\n    } else if (strcmp(name, JSPARSE_INHERITS_VAR)==0) {\n      const char *objName = jswGetBasicObjectName(object);\n      if (objName) {\n        child = jspNewPrototype(objName);\n      }\n    }\n  }\n\n  return child;\n}\n\n/** Get the named function/variable on the object - whether it's built in, or predefined.\n * If !returnName, returns the function/variable itself or undefined, but\n * if returnName, return a name (could be fake) referencing the parent.\n *\n * NOTE: ArrayBuffer/Strings are not handled here. We assume that if we're\n * passing a char* rather than a JsVar it's because we're looking up via\n * a symbol rather than a variable. To handle these use jspGetVarNamedField  */\nJsVar *jspGetNamedField(JsVar *object, const char* name, bool returnName) {\n\n  JsVar *child = 0;\n  // if we're an object (or pretending to be one)\n  if (jsvHasChildren(object))\n    child = jsvFindChildFromString(object, name, false);\n\n  if (!child) {\n    child = jspGetNamedFieldInParents(object, name, returnName);\n\n    // If not found and is the prototype, create it\n    if (!child && jsvIsFunction(object) && strcmp(name, JSPARSE_PROTOTYPE_VAR)==0) {\n      JsVar *value = jsvNewObject(); // prototype is supposed to be an object\n      child = jsvAddNamedChild(object, value, JSPARSE_PROTOTYPE_VAR);\n      jsvUnLock(value);\n    }\n  }\n\n  if (returnName) return child;\n  else return jsvSkipNameAndUnLock(child);\n}\n\n/// see jspGetNamedField - note that nameVar should have had jsvAsArrayIndex called on it first\nJsVar *jspGetVarNamedField(JsVar *object, JsVar *nameVar, bool returnName) {\n\n  JsVar *child = 0;\n  // if we're an object (or pretending to be one)\n  if (jsvHasChildren(object))\n    child = jsvFindChildFromVar(object, nameVar, false);\n\n  if (!child) {\n    if (jsvIsArrayBuffer(object) && jsvIsInt(nameVar)) {\n      // for array buffers, we actually create a NAME, and hand that back - then when we assign (or use SkipName) we pull out the correct data\n      child = jsvMakeIntoVariableName(jsvNewFromInteger(jsvGetInteger(nameVar)), object);\n      if (child) // turn into an 'array buffer name'\n        child->flags = (child->flags & ~JSV_VARTYPEMASK) | JSV_ARRAYBUFFERNAME;\n    } else if (jsvIsString(object) && jsvIsInt(nameVar)) {\n      JsVarInt idx = jsvGetInteger(nameVar);\n      if (idx>=0 && idx<(JsVarInt)jsvGetStringLength(object)) {\n        char ch = jsvGetCharInString(object, (size_t)idx);\n        child = jsvNewStringOfLength(1, &ch);\n      } else if (returnName)\n        child = jsvCreateNewChild(object, nameVar, 0); // just return *something* to show this is handled\n    } else {\n      // get the name as a string\n      char name[JSLEX_MAX_TOKEN_LENGTH];\n      jsvGetString(nameVar, name, JSLEX_MAX_TOKEN_LENGTH);\n      // try and find it in parents\n      child = jspGetNamedFieldInParents(object, name, returnName);\n\n      // If not found and is the prototype, create it\n      if (!child && jsvIsFunction(object) && jsvIsStringEqual(nameVar, JSPARSE_PROTOTYPE_VAR)) {\n        JsVar *value = jsvNewObject(); // prototype is supposed to be an object\n        child = jsvAddNamedChild(object, value, JSPARSE_PROTOTYPE_VAR);\n        jsvUnLock(value);\n      }\n    }\n  }\n\n  if (returnName) return child;\n  else return jsvSkipNameAndUnLock(child);\n}\n\n/// Call the named function on the object - whether it's built in, or predefined. Returns the return value of the function.\nJsVar *jspCallNamedFunction(JsVar *object, char* name, int argCount, JsVar **argPtr) {\n  JsVar *child = jspGetNamedField(object, name, false);\n  JsVar *r = 0;\n  if (jsvIsFunction(child))\n    r = jspeFunctionCall(child, 0, object, false, argCount, argPtr);\n  jsvUnLock(child);\n  return r;\n}\n\nNO_INLINE JsVar *jspeFactorMember(JsVar *a, JsVar **parentResult) {\n  /* The parent if we're executing a method call */\n  JsVar *parent = 0;\n\n  while (lex->tk=='.' || lex->tk=='[') {\n    if (lex->tk == '.') { // ------------------------------------- Record Access\n      JSP_ASSERT_MATCH('.');\n      if (jslIsIDOrReservedWord()) {\n        if (JSP_SHOULD_EXECUTE) {\n          // Note: name will go away when we parse something else!\n          const char *name = jslGetTokenValueAsString();\n\n          JsVar *aVar = jsvSkipNameWithParent(a,true,parent);\n          JsVar *child = 0;\n          if (aVar)\n            child = jspGetNamedField(aVar, name, true);\n          if (!child) {\n            if (!jsvIsUndefined(aVar)) {\n              // if no child found, create a pointer to where it could be\n              // as we don't want to allocate it until it's written\n              JsVar *nameVar = jslGetTokenValueAsVar();\n              child = jsvCreateNewChild(aVar, nameVar, 0);\n              jsvUnLock(nameVar);\n            } else {\n              // could have been a string...\n              jsExceptionHere(JSET_ERROR, \"Cannot read property '%s' of undefined\", name);\n            }\n          }\n          jsvUnLock(parent);\n          parent = aVar;\n          jsvUnLock(a);\n          a = child;\n        }\n        // skip over current token (we checked above that it was an ID or reserved word)\n        jslGetNextToken();\n      } else {\n        // incorrect token - force a match fail by asking for an ID\n        JSP_MATCH_WITH_RETURN(LEX_ID, a);\n      }\n    } else if (lex->tk == '[') { // ------------------------------------- Array Access\n      JsVar *index;\n      JSP_ASSERT_MATCH('[');\n      if (!jspCheckStackPosition()) return parent;\n      index = jsvSkipNameAndUnLock(jspeAssignmentExpression());\n      JSP_MATCH_WITH_CLEANUP_AND_RETURN(']', jsvUnLock2(parent, index);, a);\n      if (JSP_SHOULD_EXECUTE) {\n        index = jsvAsArrayIndexAndUnLock(index);\n        JsVar *aVar = jsvSkipNameWithParent(a,true,parent);\n        JsVar *child = 0;\n        if (aVar)\n          child = jspGetVarNamedField(aVar, index, true);\n\n        if (!child) {\n          if (jsvHasChildren(aVar)) {\n            // if no child found, create a pointer to where it could be\n            // as we don't want to allocate it until it's written\n            child = jsvCreateNewChild(aVar, index, 0);\n          } else {\n            jsExceptionHere(JSET_ERROR, \"Field or method %q does not already exist, and can't create it on %t\", index, aVar);\n          }\n        }\n        jsvUnLock(parent);\n        parent = jsvLockAgainSafe(aVar);\n        jsvUnLock(a);\n        a = child;\n        jsvUnLock(aVar);\n      }\n      jsvUnLock(index);\n    } else {\n      assert(0);\n    }\n  }\n\n  if (parentResult) *parentResult = parent;\n  else jsvUnLock(parent);\n  return a;\n}\n\nNO_INLINE JsVar *jspeConstruct(JsVar *func, JsVar *funcName, bool hasArgs) {\n  assert(JSP_SHOULD_EXECUTE);\n  if (!jsvIsFunction(func)) {\n    jsExceptionHere(JSET_ERROR, \"Constructor should be a function, but is %t\", func);\n    return 0;\n  }\n\n  JsVar *thisObj = jsvNewObject();\n  if (!thisObj) return 0; // out of memory\n  // Make sure the function has a 'prototype' var\n  JsVar *prototypeName = jsvFindChildFromString(func, JSPARSE_PROTOTYPE_VAR, true);\n  jspEnsureIsPrototype(func, prototypeName); // make sure it's an object\n  JsVar *prototypeVar = jsvSkipName(prototypeName);\n  jsvUnLock3(jsvAddNamedChild(thisObj, prototypeVar, JSPARSE_INHERITS_VAR), prototypeVar, prototypeName);\n\n  JsVar *a = jspeFunctionCall(func, funcName, thisObj, hasArgs, 0, 0);\n\n  /* FIXME: we should ignore return values that aren't objects (bug #848), but then we need\n   * to be aware of `new String()` and `new Uint8Array()`. Ideally we'd let through\n   * arrays/etc, and then String/etc should return 'boxed' values.\n   *\n   * But they don't return boxed values at the moment, so let's just\n   * pass the return value through. If you try and return a string from\n   * a function it's broken JS code anyway.\n   */\n  if (a) {\n    jsvUnLock(thisObj);\n    thisObj = a;\n  } else {\n    jsvUnLock(a);\n  }\n  return thisObj;\n}\n\nNO_INLINE JsVar *jspeFactorFunctionCall() {\n  /* The parent if we're executing a method call */\n  bool isConstructor = false;\n  if (lex->tk==LEX_R_NEW) {\n    JSP_ASSERT_MATCH(LEX_R_NEW);\n    isConstructor = true;\n\n    if (lex->tk==LEX_R_NEW) {\n      jsExceptionHere(JSET_ERROR, \"Nesting 'new' operators is unsupported\");\n      jspSetError(false);\n      return 0;\n    }\n  }\n\n  JsVar *parent = 0;\n#ifndef SAVE_ON_FLASH\n  bool wasSuper = lex->tk==LEX_R_SUPER;\n#endif\n  JsVar *a = jspeFactorMember(jspeFactor(), &parent);\n#ifndef SAVE_ON_FLASH\n  if (wasSuper) {\n    /* if this was 'super.something' then we need\n     * to overwrite the parent, because it'll be\n     * set to the prototype otherwise.\n     */\n    jsvUnLock(parent);\n    parent = jsvLockAgainSafe(execInfo.thisVar);\n  }\n#endif\n\n  while ((lex->tk=='(' || (isConstructor && JSP_SHOULD_EXECUTE)) && !jspIsInterrupted()) {\n    JsVar *funcName = a;\n    JsVar *func = jsvSkipName(funcName);\n\n    /* The constructor function doesn't change parsing, so if we're\n     * not executing, just short-cut it. */\n    if (isConstructor && JSP_SHOULD_EXECUTE) {\n      // If we have '(' parse an argument list, otherwise don't look for any args\n      bool parseArgs = lex->tk=='(';\n      a = jspeConstruct(func, funcName, parseArgs);\n      isConstructor = false; // don't treat subsequent brackets as constructors\n    } else\n      a = jspeFunctionCall(func, funcName, parent, true, 0, 0);\n\n    jsvUnLock3(funcName, func, parent);\n    parent=0;\n    a = jspeFactorMember(a, &parent);\n  }\n#ifndef SAVE_ON_FLASH\n  /* If we've got something that we care about the parent of (eg. a getter/setter)\n   * then we repackage it into a 'NewChild' name that references the parent before\n   * we leave. Note: You can't do this on everything because normally NewChild\n   * forces a new child to be blindly created. It works on Getters/Setters because\n   * we *always* run those rather than adding them.\n   */\n  if (parent && jsvIsBasicName(a) && !jsvIsNewChild(a)) {\n    JsVar *value = jsvLockSafe(jsvGetFirstChild(a));\n    if (jsvIsGetterOrSetter(value)) { // no need to do this for functions since we've just executed whatever we needed to\n      JsVar *nameVar = jsvCopyNameOnly(a,false,true);\n      JsVar *newChild = jsvCreateNewChild(parent, nameVar, value);\n      jsvUnLock2(nameVar, a);\n      a = newChild;\n    }\n    jsvUnLock(value);\n  }\n#endif\n  jsvUnLock(parent);\n  return a;\n}\n\n\nNO_INLINE JsVar *jspeFactorObject() {\n  if (JSP_SHOULD_EXECUTE) {\n    JsVar *contents = jsvNewObject();\n    if (!contents) { // out of memory\n      jspSetError(false);\n      return 0;\n    }\n    /* JSON-style object definition */\n    JSP_MATCH_WITH_RETURN('{', contents);\n    while (!JSP_SHOULDNT_PARSE && lex->tk != '}') {\n      JsVar *varName = 0;\n      // we only allow strings or IDs on the left hand side of an initialisation\n      if (jslIsIDOrReservedWord()) {\n        if (JSP_SHOULD_EXECUTE)\n          varName = jslGetTokenValueAsVar();\n        jslGetNextToken(); // skip over current token\n      } else if (\n          lex->tk==LEX_STR ||\n          lex->tk==LEX_FLOAT ||\n          lex->tk==LEX_INT ||\n          lex->tk==LEX_R_TRUE ||\n          lex->tk==LEX_R_FALSE ||\n          lex->tk==LEX_R_NULL ||\n          lex->tk==LEX_R_UNDEFINED) {\n        varName = jspeFactor();\n      } else {\n        JSP_MATCH_WITH_RETURN(LEX_ID, contents);\n      }\n#ifndef SAVE_ON_FLASH\n      if (lex->tk==LEX_ID && jsvIsString(varName)) {\n        bool isGetter = jsvIsStringEqual(varName, \"get\");\n        bool isSetter = jsvIsStringEqual(varName, \"set\");\n        if (isGetter || isSetter) {\n          jsvUnLock(varName);\n          varName = jslGetTokenValueAsVar();\n          JSP_ASSERT_MATCH(LEX_ID);\n          JsVar *method = jspeFunctionDefinition(false);\n          jsvAddGetterOrSetter(contents, varName, isGetter, method);\n          jsvUnLock(method);\n        }\n      } else\n#endif\n      {\n        JSP_MATCH_WITH_CLEANUP_AND_RETURN(':', jsvUnLock(varName), contents);\n        if (JSP_SHOULD_EXECUTE) {\n          varName = jsvAsArrayIndexAndUnLock(varName);\n          JsVar *contentsName = jsvFindChildFromVar(contents, varName, true);\n          if (contentsName) {\n            JsVar *value = jsvSkipNameAndUnLock(jspeAssignmentExpression()); // value can be 0 (could be undefined!)\n            jsvUnLock2(jsvSetValueOfName(contentsName, value), value);\n          }\n        }\n      }\n      jsvUnLock(varName);\n      // no need to clean here, as it will definitely be used\n      if (lex->tk != '}') JSP_MATCH_WITH_RETURN(',', contents);\n    }\n    JSP_MATCH_WITH_RETURN('}', contents);\n    return contents;\n  } else {\n    // Not executing so do fast skip\n    jspeBlock();\n    return 0;\n  }\n}\n\nNO_INLINE JsVar *jspeFactorArray() {\n  int idx = 0;\n  JsVar *contents = 0;\n  if (JSP_SHOULD_EXECUTE) {\n    contents = jsvNewEmptyArray();\n    if (!contents) { // out of memory\n      jspSetError(false);\n      return 0;\n    }\n  }\n  /* JSON-style array */\n  JSP_MATCH_WITH_RETURN('[', contents);\n  while (!JSP_SHOULDNT_PARSE && lex->tk != ']') {\n    if (JSP_SHOULD_EXECUTE) {\n      JsVar *aVar = 0;\n      JsVar *indexName = 0;\n      if (lex->tk != ',') { // #287 - [,] and [1,2,,4] are allowed\n        aVar = jsvSkipNameAndUnLock(jspeAssignmentExpression());\n        indexName = jsvMakeIntoVariableName(jsvNewFromInteger(idx),  aVar);\n      }\n      if (indexName) { // could be out of memory\n        jsvAddName(contents, indexName);\n        jsvUnLock(indexName);\n      }\n      jsvUnLock(aVar);\n    } else {\n      jsvUnLock(jspeAssignmentExpression());\n    }\n    // no need to clean here, as it will definitely be used\n    if (lex->tk != ']') JSP_MATCH_WITH_RETURN(',', contents);\n    idx++;\n  }\n  if (contents) jsvSetArrayLength(contents, idx, false);\n  JSP_MATCH_WITH_RETURN(']', contents);\n  return contents;\n}\n\nNO_INLINE void jspEnsureIsPrototype(JsVar *instanceOf, JsVar *prototypeName) {\n  if (!prototypeName) return;\n  JsVar *prototypeVar = jsvSkipName(prototypeName);\n  if (!(jsvIsObject(prototypeVar) || jsvIsFunction(prototypeVar))) {\n    if (!jsvIsUndefined(prototypeVar))\n      jsExceptionHere(JSET_TYPEERROR, \"Prototype should be an object, got %t\", prototypeVar);\n    jsvUnLock(prototypeVar);\n    prototypeVar = jsvNewObject(); // prototype is supposed to be an object\n    JsVar *lastName = jsvSkipToLastName(prototypeName);\n    jsvSetValueOfName(lastName, prototypeVar);\n    jsvUnLock(lastName);\n  }\n  JsVar *constructor = jsvFindChildFromString(prototypeVar, JSPARSE_CONSTRUCTOR_VAR, true);\n  if (constructor) jsvSetValueOfName(constructor, instanceOf);\n  jsvUnLock2(constructor, prototypeVar);\n}\n\nNO_INLINE JsVar *jspeFactorTypeOf() {\n  JSP_ASSERT_MATCH(LEX_R_TYPEOF);\n  JsVar *a = jspeUnaryExpression();\n  JsVar *result = 0;\n  if (JSP_SHOULD_EXECUTE) {\n    if (!jsvIsVariableDefined(a)) {\n      // so we don't get a ReferenceError when accessing an undefined var\n      result=jsvNewFromString(\"undefined\");\n    } else {\n      a = jsvSkipNameAndUnLock(a);\n      result=jsvNewFromString(jsvGetTypeOf(a));\n    }\n  }\n  jsvUnLock(a);\n  return result;\n}\n\nNO_INLINE JsVar *jspeFactorDelete() {\n  JSP_ASSERT_MATCH(LEX_R_DELETE);\n  JsVar *parent = 0;\n  JsVar *a = jspeFactorMember(jspeFactor(), &parent);\n  JsVar *result = 0;\n  if (JSP_SHOULD_EXECUTE) {\n    bool ok = false;\n    if (jsvIsName(a) && !jsvIsNewChild(a)) {\n      // if no parent, check in root?\n      if (!parent && jsvIsChild(execInfo.root, a))\n        parent = jsvLockAgain(execInfo.root);\n\n      if (jsvHasChildren(parent)) {\n        // else remove properly.\n        if (jsvIsArray(parent)) {\n          // For arrays, we must make sure we don't change the length\n          JsVarInt l = jsvGetArrayLength(parent);\n          jsvRemoveChild(parent, a);\n          jsvSetArrayLength(parent, l, false);\n        } else {\n          jsvRemoveChild(parent, a);\n        }\n        ok = true;\n      }\n    }\n\n    result = jsvNewFromBool(ok);\n  }\n  jsvUnLock2(a, parent);\n  return result;\n}\n\n#ifndef SAVE_ON_FLASH\nJsVar *jspeTemplateLiteral() {\n  JsVar *a = 0;\n  if (JSP_SHOULD_EXECUTE) {\n    JsVar *template = jslGetTokenValueAsVar();\n    a = jsvNewFromEmptyString();\n    if (a && template) {\n      JsvStringIterator it, dit;\n      jsvStringIteratorNew(&it, template, 0);\n      jsvStringIteratorNew(&dit, a, 0);\n      while (jsvStringIteratorHasChar(&it)) {\n        char ch = jsvStringIteratorGetCharAndNext(&it);\n        if (ch=='$') {\n          ch = jsvStringIteratorGetChar(&it);\n          if (ch=='{') {\n            // Now parse out the expression\n            jsvStringIteratorNext(&it);\n            int brackets = 1;\n            JsVar *expr = jsvNewFromEmptyString();\n            if (!expr) break;\n            JsvStringIterator eit;\n            jsvStringIteratorNew(&eit, expr, 0);\n            while (jsvStringIteratorHasChar(&it)) {\n              ch = jsvStringIteratorGetCharAndNext(&it);\n              if (ch=='{') brackets++;\n              if (ch=='}') {\n                brackets--;\n                if (!brackets) break;\n              }\n              jsvStringIteratorAppend(&eit, ch);\n            }\n            jsvStringIteratorFree(&eit);\n            JsVar *result = jspEvaluateExpressionVar(expr);\n            jsvUnLock(expr);\n            result = jsvAsStringAndUnLock(result);\n            jsvStringIteratorAppendString(&dit, result, 0, JSVAPPENDSTRINGVAR_MAXLENGTH);\n            jsvUnLock(result);\n          } else {\n            jsvStringIteratorAppend(&dit, '$');\n          }\n        } else {\n          jsvStringIteratorAppend(&dit, ch);\n        }\n      }\n      jsvStringIteratorFree(&it);\n      jsvStringIteratorFree(&dit);\n    }\n    jsvUnLock(template);\n  }\n  JSP_ASSERT_MATCH(LEX_TEMPLATE_LITERAL);\n  return a;\n}\n#endif\n\n\nNO_INLINE JsVar *jspeAddNamedFunctionParameter(JsVar *funcVar, JsVar *name) {\n  if (!funcVar) funcVar = jsvNewWithFlags(JSV_FUNCTION);\n  char buf[JSLEX_MAX_TOKEN_LENGTH+1];\n  buf[0] = '\\xFF';\n  size_t l = jsvGetString(name, &buf[1], JSLEX_MAX_TOKEN_LENGTH);\n  buf[l+1] = 0; // zero terminate since jsvGetString doesn't add one\n  JsVar *param = jsvAddNamedChild(funcVar, 0, buf);\n  jsvMakeFunctionParameter(param);\n  jsvUnLock(param);\n  return funcVar;\n}\n\n#ifndef SAVE_ON_FLASH\n// parse an arrow function\nNO_INLINE JsVar *jspeArrowFunction(JsVar *funcVar, JsVar *a) {\n  assert(!a || jsvIsName(a));\n  JSP_ASSERT_MATCH(LEX_ARROW_FUNCTION);\n  funcVar = jspeAddNamedFunctionParameter(funcVar, a);\n\n  bool expressionOnly = lex->tk!='{';\n  bool fnIncludesThis = jspeFunctionDefinitionInternal(funcVar, expressionOnly);\n  /* Arrow functions store the value of 'this' when they were defined. In order\n  to differentiate between normal functions we usually have to store 'this' even\n  if 'this' was just the global object.\n  Very few arrow functions actually use 'this' though - usually they are just used\n  as a shorthand, and so we end up wasting a whole extra var for every single\n  arrow function.\n  So... while parsing the function's body we check of the 'this' keyword is used.\n  If it isn't, we just don't include it.\n   */\n  if (fnIncludesThis)\n    jsvObjectSetChild(funcVar, JSPARSE_FUNCTION_THIS_NAME, execInfo.thisVar);\n\n  return funcVar;\n}\n\n// parse expressions with commas, maybe followed by an arrow function (bracket already matched)\nNO_INLINE JsVar *jspeExpressionOrArrowFunction() {\n  JsVar *a = 0;\n  JsVar *funcVar = 0;\n  bool allNames = true;\n  while (lex->tk!=')' && !JSP_SHOULDNT_PARSE) {\n    if (allNames && a) {\n      // we never get here if this isn't a name and a string\n      funcVar = jspeAddNamedFunctionParameter(funcVar, a);\n    }\n    jsvUnLock(a);\n    a = jspeAssignmentExpression();\n    /* if we're not executing, `a` will always be undefined so\n      don't do the check for allNames - just assume all is good. We'll\n      properly check when we execute. */\n    if (JSP_SHOULD_EXECUTE && !(jsvIsName(a) && jsvIsString(a))) allNames = false;\n    if (lex->tk!=')') JSP_MATCH_WITH_CLEANUP_AND_RETURN(',', jsvUnLock2(a,funcVar), 0);\n  }\n  JSP_MATCH_WITH_CLEANUP_AND_RETURN(')', jsvUnLock2(a,funcVar), 0);\n  // if all names inside brackets and an arrow is found, create a function\n  if (allNames && lex->tk==LEX_ARROW_FUNCTION) {\n    funcVar = jspeArrowFunction(funcVar, a);\n    jsvUnLock(a);\n    return funcVar;\n  } else {\n    jsvUnLock(funcVar);\n    return a;\n  }\n}\n\n/// Parse an ES6 class, expects LEX_R_CLASS already parsed\nNO_INLINE JsVar *jspeClassDefinition(bool parseNamedClass) {\n  JsVar *classFunction = 0;\n  JsVar *classPrototype = 0;\n  JsVar *classInternalName = 0;\n\n  bool actuallyCreateClass = JSP_SHOULD_EXECUTE;\n  if (actuallyCreateClass) {\n    classFunction = jsvNewWithFlags(JSV_FUNCTION);\n    JsVar *scopeVar = jspeiGetScopesAsVar();\n    if (scopeVar)\n      jsvUnLock2(jsvAddNamedChild(classFunction, scopeVar, JSPARSE_FUNCTION_SCOPE_NAME), scopeVar);\n  }\n\n  if (parseNamedClass && lex->tk==LEX_ID) {\n    if (classFunction)\n      classInternalName = jslGetTokenValueAsVar();\n    JSP_ASSERT_MATCH(LEX_ID);\n  }\n  if (classFunction) {\n    JsVar *prototypeName = jsvFindChildFromString(classFunction, JSPARSE_PROTOTYPE_VAR, true);\n    jspEnsureIsPrototype(classFunction, prototypeName); // make sure it's an object\n    classPrototype = jsvSkipName(prototypeName);\n    jsvUnLock(prototypeName);\n  }\n  if (lex->tk==LEX_R_EXTENDS) {\n    JSP_ASSERT_MATCH(LEX_R_EXTENDS);\n    JsVar *extendsFrom = actuallyCreateClass ? jsvSkipNameAndUnLock(jspGetNamedVariable(jslGetTokenValueAsString())) : 0;\n    JSP_MATCH_WITH_CLEANUP_AND_RETURN(LEX_ID,jsvUnLock4(extendsFrom,classFunction,classInternalName,classPrototype),0);\n    if (classPrototype) {\n      if (jsvIsFunction(extendsFrom)) {\n        JsVar *extendsFromProto = jsvObjectGetChild(extendsFrom, JSPARSE_PROTOTYPE_VAR, 0);\n        if (extendsFromProto) {\n          jsvObjectSetChild(classPrototype, JSPARSE_INHERITS_VAR, extendsFromProto);\n          // link in default constructor if ours isn't supplied\n          jsvObjectSetChildAndUnLock(classFunction, JSPARSE_FUNCTION_CODE_NAME, jsvNewFromString(\"if(this.__proto__.__proto__.constructor)this.__proto__.__proto__.constructor.apply(this,arguments)\"));\n          jsvUnLock(extendsFromProto);\n        }\n      } else\n        jsExceptionHere(JSET_SYNTAXERROR, \"'extends' argument should be a function, got %t\", extendsFrom);\n    }\n    jsvUnLock(extendsFrom);\n  }\n  JSP_MATCH_WITH_CLEANUP_AND_RETURN('{',jsvUnLock3(classFunction,classInternalName,classPrototype),0);\n\n  while ((lex->tk==LEX_ID || lex->tk==LEX_R_STATIC) && !jspIsInterrupted()) {\n    bool isStatic = lex->tk==LEX_R_STATIC;\n    if (isStatic) JSP_ASSERT_MATCH(LEX_R_STATIC);\n\n    JsVar *funcName = jslGetTokenValueAsVar();\n    JSP_MATCH_WITH_CLEANUP_AND_RETURN(LEX_ID,jsvUnLock4(funcName,classFunction,classInternalName,classPrototype),0);\n#ifndef SAVE_ON_FLASH\n    bool isGetter = false, isSetter = false;\n    if (lex->tk==LEX_ID) {\n      isGetter = jsvIsStringEqual(funcName, \"get\");\n      isSetter = jsvIsStringEqual(funcName, \"set\");\n      if (isGetter || isSetter) {\n        jsvUnLock(funcName);\n        funcName = jslGetTokenValueAsVar();\n        JSP_ASSERT_MATCH(LEX_ID);\n      }\n    }\n#endif\n    JsVar *method = jspeFunctionDefinition(false);\n    if (classFunction && classPrototype) {\n      JsVar *obj = isStatic ? classFunction : classPrototype;\n      if (jsvIsStringEqual(funcName, \"constructor\")) {\n        jswrap_function_replaceWith(classFunction, method);\n#ifndef SAVE_ON_FLASH\n      } else if (isGetter || isSetter) {\n        jsvAddGetterOrSetter(obj, funcName, isGetter, method);\n#endif\n      } else {\n        funcName = jsvMakeIntoVariableName(funcName, 0);\n        jsvSetValueOfName(funcName, method);\n        jsvAddName(obj, funcName);\n      }\n\n    }\n    jsvUnLock2(method,funcName);\n  }\n  jsvUnLock(classPrototype);\n  // If we had a name, add it to the end (or it gets confused with the constructor arguments)\n  if (classInternalName)\n    jsvObjectSetChildAndUnLock(classFunction, JSPARSE_FUNCTION_NAME_NAME, classInternalName);\n\n  JSP_MATCH_WITH_CLEANUP_AND_RETURN('}',jsvUnLock(classFunction),0);\n  return classFunction;\n}\n\n#endif\n\nNO_INLINE JsVar *jspeFactor() {\n  if (lex->tk==LEX_ID) {\n    JsVar *a = jspGetNamedVariable(jslGetTokenValueAsString());\n    JSP_ASSERT_MATCH(LEX_ID);\n#ifndef SAVE_ON_FLASH\n    if (lex->tk==LEX_TEMPLATE_LITERAL)\n      jsExceptionHere(JSET_SYNTAXERROR, \"Tagged template literals not supported\");\n    else if (lex->tk==LEX_ARROW_FUNCTION &&\n             (jsvIsName(a) || (a==0 && !JSP_SHOULD_EXECUTE))) {\n      // 'a' needs to be a name, *or* we're not executing so 0 gets returned anyway\n      JsVar *funcVar = jspeArrowFunction(0,a);\n      jsvUnLock(a);\n      a=funcVar;\n    }\n#endif\n    return a;\n  } else if (lex->tk==LEX_INT) {\n    JsVar *v = 0;\n    if (JSP_SHOULD_EXECUTE) {\n      v = jsvNewFromLongInteger(stringToInt(jslGetTokenValueAsString()));\n    }\n    JSP_ASSERT_MATCH(LEX_INT);\n    return v;\n  } else if (lex->tk==LEX_FLOAT) {\n    JsVar *v = 0;\n    if (JSP_SHOULD_EXECUTE) {\n      v = jsvNewFromFloat(stringToFloat(jslGetTokenValueAsString()));\n    }\n    JSP_ASSERT_MATCH(LEX_FLOAT);\n    return v;\n  } else if (lex->tk=='(') {\n    JSP_ASSERT_MATCH('(');\n    if (!jspCheckStackPosition()) return 0;\n#ifdef SAVE_ON_FLASH\n    // Just parse a normal expression (which can include commas)\n    JsVar *a = jspeExpression();\n    if (!JSP_SHOULDNT_PARSE) JSP_MATCH_WITH_RETURN(')',a);\n    return a;\n#else\n    return jspeExpressionOrArrowFunction();\n#endif\n\n  } else if (lex->tk==LEX_R_TRUE) {\n    JSP_ASSERT_MATCH(LEX_R_TRUE);\n    return JSP_SHOULD_EXECUTE ? jsvNewFromBool(true) : 0;\n  } else if (lex->tk==LEX_R_FALSE) {\n    JSP_ASSERT_MATCH(LEX_R_FALSE);\n    return JSP_SHOULD_EXECUTE ? jsvNewFromBool(false) : 0;\n  } else if (lex->tk==LEX_R_NULL) {\n    JSP_ASSERT_MATCH(LEX_R_NULL);\n    return JSP_SHOULD_EXECUTE ? jsvNewWithFlags(JSV_NULL) : 0;\n  } else if (lex->tk==LEX_R_UNDEFINED) {\n    JSP_ASSERT_MATCH(LEX_R_UNDEFINED);\n    return 0;\n  } else if (lex->tk==LEX_STR) {\n    JsVar *a = 0;\n    if (JSP_SHOULD_EXECUTE)\n      a = jslGetTokenValueAsVar();\n    JSP_ASSERT_MATCH(LEX_STR);\n    return a;\n#ifndef SAVE_ON_FLASH\n  } else if (lex->tk==LEX_TEMPLATE_LITERAL) {\n    return jspeTemplateLiteral();\n#endif\n  } else if (lex->tk==LEX_REGEX) {\n    JsVar *a = 0;\n#ifdef SAVE_ON_FLASH\n    jsExceptionHere(JSET_SYNTAXERROR, \"RegEx are not supported in this version of Espruino\\n\");\n#else\n    JsVar *regex = jslGetTokenValueAsVar();\n    size_t regexEnd = 0, regexLen = 0;\n    JsvStringIterator it;\n    jsvStringIteratorNew(&it, regex, 0);\n    while (jsvStringIteratorHasChar(&it)) {\n      regexLen++;\n      if (jsvStringIteratorGetCharAndNext(&it)=='/')\n        regexEnd = regexLen;\n    }\n    jsvStringIteratorFree(&it);\n    JsVar *flags = 0;\n    if (regexEnd < regexLen)\n      flags = jsvNewFromStringVar(regex, regexEnd, JSVAPPENDSTRINGVAR_MAXLENGTH);\n    JsVar *regexSource = jsvNewFromStringVar(regex, 1, regexEnd-2);\n    a = jswrap_regexp_constructor(regexSource, flags);\n    jsvUnLock3(regex, flags, regexSource);\n#endif\n    JSP_ASSERT_MATCH(LEX_REGEX);\n    return a;\n  } else if (lex->tk=='{') {\n    if (!jspCheckStackPosition()) return 0;\n    return jspeFactorObject();\n  } else if (lex->tk=='[') {\n    if (!jspCheckStackPosition()) return 0;\n    return jspeFactorArray();\n  } else if (lex->tk==LEX_R_FUNCTION) {\n    if (!jspCheckStackPosition()) return 0;\n    JSP_ASSERT_MATCH(LEX_R_FUNCTION);\n    return jspeFunctionDefinition(true);\n#ifndef SAVE_ON_FLASH\n  } else if (lex->tk==LEX_R_CLASS) {\n    if (!jspCheckStackPosition()) return 0;\n    JSP_ASSERT_MATCH(LEX_R_CLASS);\n    return jspeClassDefinition(true);\n  } else if (lex->tk==LEX_R_SUPER) {\n    JSP_ASSERT_MATCH(LEX_R_SUPER);\n    /* This is kind of nasty, since super appears to do\n      three different things.\n\n      * In the constructor it references the extended class's constructor\n      * in a method it references the constructor's prototype.\n      * in a static method it references the extended class's constructor (but this is different)\n     */\n\n    if (jsvIsObject(execInfo.thisVar)) {\n      // 'this' is an object - must be calling a normal method\n      JsVar *proto1 = jsvObjectGetChild(execInfo.thisVar, JSPARSE_INHERITS_VAR, 0); // if we're in a method, get __proto__ first\n      JsVar *proto2 = jsvIsObject(proto1) ? jsvObjectGetChild(proto1, JSPARSE_INHERITS_VAR, 0) : 0; // still in method, get __proto__.__proto__\n      jsvUnLock(proto1);\n      if (!proto2) {\n        jsExceptionHere(JSET_SYNTAXERROR, \"Calling 'super' outside of class\");\n        return 0;\n      }\n      // If we're doing super() we want the constructor\n      if (lex->tk=='(') {\n        JsVar *constr = jsvObjectGetChild(proto2, JSPARSE_CONSTRUCTOR_VAR, 0);\n        jsvUnLock(proto2);\n        return constr;\n      }\n      // But if we're doing something else - eg 'super.' or 'super[' then it needs to reference the prototype\n      return proto2;\n    } else if (jsvIsFunction(execInfo.thisVar)) {\n      // 'this' is a function - must be calling a static method\n      JsVar *proto1 = jsvObjectGetChild(execInfo.thisVar, JSPARSE_PROTOTYPE_VAR, 0);\n      JsVar *proto2 = jsvIsObject(proto1) ? jsvObjectGetChild(proto1, JSPARSE_INHERITS_VAR, 0) : 0;\n      jsvUnLock(proto1);\n      if (!proto2) {\n        jsExceptionHere(JSET_SYNTAXERROR, \"Calling 'super' outside of class\");\n        return 0;\n      }\n      JsVar *constr = jsvObjectGetChild(proto2, JSPARSE_CONSTRUCTOR_VAR, 0);\n      jsvUnLock(proto2);\n      return constr;\n    }\n    jsExceptionHere(JSET_SYNTAXERROR, \"Calling 'super' outside of class\");\n    return 0;\n#endif\n  } else if (lex->tk==LEX_R_THIS) {\n    JSP_ASSERT_MATCH(LEX_R_THIS);\n    return jsvLockAgain( execInfo.thisVar ? execInfo.thisVar : execInfo.root );\n  } else if (lex->tk==LEX_R_DELETE) {\n    if (!jspCheckStackPosition()) return 0;\n    return jspeFactorDelete();\n  } else if (lex->tk==LEX_R_TYPEOF) {\n    if (!jspCheckStackPosition()) return 0;\n    return jspeFactorTypeOf();\n  } else if (lex->tk==LEX_R_VOID) {\n    if (!jspCheckStackPosition()) return 0;\n    JSP_ASSERT_MATCH(LEX_R_VOID);\n    jsvUnLock(jspeUnaryExpression());\n    return 0;\n  }\n  JSP_MATCH(LEX_EOF);\n  jsExceptionHere(JSET_SYNTAXERROR, \"Unexpected end of Input\\n\");\n  return 0;\n}\n\nNO_INLINE JsVar *__jspePostfixExpression(JsVar *a) {\n  while (lex->tk==LEX_PLUSPLUS || lex->tk==LEX_MINUSMINUS) {\n    int op = lex->tk;\n    JSP_ASSERT_MATCH(op);\n    if (JSP_SHOULD_EXECUTE) {\n      JsVar *one = jsvNewFromInteger(1);\n      JsVar *oldValue = jsvAsNumberAndUnLock(jsvSkipName(a)); // keep the old value (but convert to number)\n      JsVar *res = jsvMathsOpSkipNames(oldValue, one, op==LEX_PLUSPLUS ? '+' : '-');\n      jsvUnLock(one);\n\n      // in-place add/subtract\n      jsvReplaceWith(a, res);\n      jsvUnLock(res);\n      // but then use the old value\n      jsvUnLock(a);\n      a = oldValue;\n    }\n  }\n  return a;\n}\n\nNO_INLINE JsVar *jspePostfixExpression() {\n  JsVar *a;\n  // TODO: should be in jspeUnaryExpression\n  if (lex->tk==LEX_PLUSPLUS || lex->tk==LEX_MINUSMINUS) {\n    int op = lex->tk;\n    JSP_ASSERT_MATCH(op);\n    a = jspePostfixExpression();\n    if (JSP_SHOULD_EXECUTE) {\n      JsVar *one = jsvNewFromInteger(1);\n      JsVar *res = jsvMathsOpSkipNames(a, one, op==LEX_PLUSPLUS ? '+' : '-');\n      jsvUnLock(one);\n      // in-place add/subtract\n      jsvReplaceWith(a, res);\n      jsvUnLock(res);\n    }\n  } else\n    a = jspeFactorFunctionCall();\n  return __jspePostfixExpression(a);\n}\n\nNO_INLINE JsVar *jspeUnaryExpression() {\n  if (lex->tk=='!' || lex->tk=='~' || lex->tk=='-' || lex->tk=='+') {\n    short tk = lex->tk;\n    JSP_ASSERT_MATCH(tk);\n    if (!JSP_SHOULD_EXECUTE) {\n      return jspeUnaryExpression();\n    }\n    if (tk=='!') { // logical not\n      return jsvNewFromBool(!jsvGetBoolAndUnLock(jsvSkipNameAndUnLock(jspeUnaryExpression())));\n    } else if (tk=='~') { // bitwise not\n      return jsvNewFromInteger(~jsvGetIntegerAndUnLock(jsvSkipNameAndUnLock(jspeUnaryExpression())));\n    } else if (tk=='-') { // unary minus\n      return jsvNegateAndUnLock(jspeUnaryExpression()); // names already skipped\n    }  else if (tk=='+') { // unary plus (convert to number)\n      JsVar *v = jsvSkipNameAndUnLock(jspeUnaryExpression());\n      JsVar *r = jsvAsNumber(v); // names already skipped\n      jsvUnLock(v);\n      return r;\n    }\n    assert(0);\n    return 0;\n  } else\n    return jspePostfixExpression();\n}\n\n\n// Get the precedence of a BinaryExpression - or return 0 if not one\nunsigned int jspeGetBinaryExpressionPrecedence(int op) {\n  switch (op) {\n  case LEX_OROR: return 1; break;\n  case LEX_ANDAND: return 2; break;\n  case '|' : return 3; break;\n  case '^' : return 4; break;\n  case '&' : return 5; break;\n  case LEX_EQUAL:\n  case LEX_NEQUAL:\n  case LEX_TYPEEQUAL:\n  case LEX_NTYPEEQUAL: return 6;\n  case LEX_LEQUAL:\n  case LEX_GEQUAL:\n  case '<':\n  case '>':\n  case LEX_R_INSTANCEOF: return 7;\n  case LEX_R_IN: return (execInfo.execute&EXEC_FOR_INIT)?0:7;\n  case LEX_LSHIFT:\n  case LEX_RSHIFT:\n  case LEX_RSHIFTUNSIGNED: return 8;\n  case '+':\n  case '-': return 9;\n  case '*':\n  case '/':\n  case '%': return 10;\n  default: return 0;\n  }\n}\n\nNO_INLINE JsVar *__jspeBinaryExpression(JsVar *a, unsigned int lastPrecedence) {\n  /* This one's a bit strange. Basically all the ops have their own precedence, it's not\n   * like & and | share the same precedence. We don't want to recurse for each one,\n   * so instead we do this.\n   *\n   * We deal with an expression in recursion ONLY if it's of higher precedence\n   * than the current one, otherwise we stick in the while loop.\n   */\n  unsigned int precedence = jspeGetBinaryExpressionPrecedence(lex->tk);\n  while (precedence && precedence>lastPrecedence) {\n    int op = lex->tk;\n    JSP_ASSERT_MATCH(op);\n\n    // if we have short-circuit ops, then if we know the outcome\n    // we don't bother to execute the other op. Even if not\n    // we need to tell mathsOp it's an & or |\n    if (op==LEX_ANDAND || op==LEX_OROR) {\n      bool aValue = jsvGetBoolAndUnLock(jsvSkipName(a));\n      if ((!aValue && op==LEX_ANDAND) ||\n          (aValue && op==LEX_OROR)) {\n        // use first argument (A)\n        JSP_SAVE_EXECUTE();\n        jspSetNoExecute();\n        jsvUnLock(__jspeBinaryExpression(jspeUnaryExpression(),precedence));\n        JSP_RESTORE_EXECUTE();\n      } else {\n        // use second argument (B)\n        jsvUnLock(a);\n        a = __jspeBinaryExpression(jspeUnaryExpression(),precedence);\n      }\n    } else { // else it's a more 'normal' logical expression - just use Maths\n      JsVar *b = __jspeBinaryExpression(jspeUnaryExpression(),precedence);\n      if (JSP_SHOULD_EXECUTE) {\n        if (op==LEX_R_IN) {\n          JsVar *av = jsvSkipName(a); // needle\n          JsVar *bv = jsvSkipName(b); // haystack\n          if (jsvHasChildren(bv)) { // search keys, NOT values\n            av = jsvAsArrayIndexAndUnLock(av);\n            JsVar *varFound = jspGetVarNamedField( bv, av, true);\n            jsvUnLock2(a,varFound);\n            a = jsvNewFromBool(varFound!=0);\n          } else { // else maybe it's a fake object...\n            const JswSymList *syms = jswGetSymbolListForObjectProto(bv);\n            if (syms) {\n              JsVar *varFound = 0;\n              char nameBuf[JSLEX_MAX_TOKEN_LENGTH];\n              if (jsvGetString(av, nameBuf, sizeof(nameBuf)) < sizeof(nameBuf))\n                varFound = jswBinarySearch(syms, bv, nameBuf);\n              bool found = varFound!=0;\n              jsvUnLock2(a, varFound);\n              if (!found && jsvIsArrayBuffer(bv)) {\n                JsVarFloat f = jsvGetFloat(av); // if not a number this will be NaN, f==floor(f) fails\n                if (f==floor(f) && f>=0 && f<jsvGetArrayBufferLength(bv))\n                  found = true;\n              }\n              a = jsvNewFromBool(found);\n            } else { // not built-in, just assume we can't do it\n              jsExceptionHere(JSET_ERROR, \"Cannot use 'in' operator to search a %t\", bv);\n              jsvUnLock(a);\n              a = 0;\n            }\n          }\n          jsvUnLock2(av, bv);\n        } else if (op==LEX_R_INSTANCEOF) {\n          bool inst = false;\n          JsVar *av = jsvSkipName(a);\n          JsVar *bv = jsvSkipName(b);\n          if (!jsvIsFunction(bv)) {\n            jsExceptionHere(JSET_ERROR, \"Expecting a function on RHS in instanceof check, got %t\", bv);\n          } else {\n            if (jsvIsObject(av) || jsvIsFunction(av)) {\n              JsVar *bproto = jspGetNamedField(bv, JSPARSE_PROTOTYPE_VAR, false);\n              JsVar *proto = jsvObjectGetChild(av, JSPARSE_INHERITS_VAR, 0);\n              while (proto) {\n                if (proto == bproto) inst=true;\n                // search prototype chain\n                JsVar *childProto = jsvObjectGetChild(proto, JSPARSE_INHERITS_VAR, 0);\n                jsvUnLock(proto);\n                proto = childProto;\n              }\n              if (jspIsConstructor(bv, \"Object\")) inst = true;\n              jsvUnLock(bproto);\n            }\n            if (!inst) {\n              const char *name = jswGetBasicObjectName(av);\n              if (name) {\n                inst = jspIsConstructor(bv, name);\n              }\n              // Hack for built-ins that should also be instances of Object\n              if (!inst && (jsvIsArray(av) || jsvIsArrayBuffer(av)) &&\n                  jspIsConstructor(bv, \"Object\"))\n                inst = true;\n            }\n          }\n          jsvUnLock3(av, bv, a);\n          a = jsvNewFromBool(inst);\n        } else {  // --------------------------------------------- NORMAL\n          JsVar *res = jsvMathsOpSkipNames(a, b, op);\n          jsvUnLock(a); a = res;\n        }\n      }\n      jsvUnLock(b);\n    }\n    precedence = jspeGetBinaryExpressionPrecedence(lex->tk);\n  }\n  return a;\n}\n\nJsVar *jspeBinaryExpression() {\n  return __jspeBinaryExpression(jspeUnaryExpression(),0);\n}\n\nNO_INLINE JsVar *__jspeConditionalExpression(JsVar *lhs) {\n  if (lex->tk=='?') {\n    JSP_ASSERT_MATCH('?');\n    if (!JSP_SHOULD_EXECUTE) {\n      // just let lhs pass through\n      jsvUnLock(jspeAssignmentExpression());\n      JSP_MATCH(':');\n      jsvUnLock(jspeAssignmentExpression());\n    } else {\n      bool first = jsvGetBoolAndUnLock(jsvSkipName(lhs));\n      jsvUnLock(lhs);\n      if (first) {\n        lhs = jspeAssignmentExpression();\n        JSP_MATCH(':');\n        JSP_SAVE_EXECUTE();\n        jspSetNoExecute();\n        jsvUnLock(jspeAssignmentExpression());\n        JSP_RESTORE_EXECUTE();\n      } else {\n        JSP_SAVE_EXECUTE();\n        jspSetNoExecute();\n        jsvUnLock(jspeAssignmentExpression());\n        JSP_RESTORE_EXECUTE();\n        JSP_MATCH(':');\n        lhs = jspeAssignmentExpression();\n      }\n    }\n  }\n\n  return lhs;\n}\n\nJsVar *jspeConditionalExpression() {\n  return __jspeConditionalExpression(jspeBinaryExpression());\n}\n\nNO_INLINE JsVar *__jspeAssignmentExpression(JsVar *lhs) {\n  if (lex->tk=='=' || lex->tk==LEX_PLUSEQUAL || lex->tk==LEX_MINUSEQUAL ||\n      lex->tk==LEX_MULEQUAL || lex->tk==LEX_DIVEQUAL || lex->tk==LEX_MODEQUAL ||\n      lex->tk==LEX_ANDEQUAL || lex->tk==LEX_OREQUAL ||\n      lex->tk==LEX_XOREQUAL || lex->tk==LEX_RSHIFTEQUAL ||\n      lex->tk==LEX_LSHIFTEQUAL || lex->tk==LEX_RSHIFTUNSIGNEDEQUAL) {\n    JsVar *rhs;\n\n    int op = lex->tk;\n    JSP_ASSERT_MATCH(op);\n    rhs = jspeAssignmentExpression();\n    rhs = jsvSkipNameAndUnLock(rhs); // ensure we get rid of any references on the RHS\n\n    if (JSP_SHOULD_EXECUTE && lhs) {\n      if (op=='=') {\n        jsvReplaceWithOrAddToRoot(lhs, rhs);\n      } else {\n        if (op==LEX_PLUSEQUAL) op='+';\n        else if (op==LEX_MINUSEQUAL) op='-';\n        else if (op==LEX_MULEQUAL) op='*';\n        else if (op==LEX_DIVEQUAL) op='/';\n        else if (op==LEX_MODEQUAL) op='%';\n        else if (op==LEX_ANDEQUAL) op='&';\n        else if (op==LEX_OREQUAL) op='|';\n        else if (op==LEX_XOREQUAL) op='^';\n        else if (op==LEX_RSHIFTEQUAL) op=LEX_RSHIFT;\n        else if (op==LEX_LSHIFTEQUAL) op=LEX_LSHIFT;\n        else if (op==LEX_RSHIFTUNSIGNEDEQUAL) op=LEX_RSHIFTUNSIGNED;\n        if (op=='+' && jsvIsName(lhs)) {\n          JsVar *currentValue = jsvSkipName(lhs);\n          if (jsvIsBasicString(currentValue) && jsvGetRefs(currentValue)==1 && rhs!=currentValue) {\n            /* A special case for string += where this is the only use of the string\n             * and we're not appending to ourselves. In this case we can do a\n             * simple append (rather than clone + append)*/\n            JsVar *str = jsvAsString(rhs);\n            jsvAppendStringVarComplete(currentValue, str);\n            jsvUnLock(str);\n            op = 0;\n          }\n          jsvUnLock(currentValue);\n        }\n        if (op) {\n          /* Fallback which does a proper add */\n          JsVar *res = jsvMathsOpSkipNames(lhs,rhs,op);\n          jsvReplaceWith(lhs, res);\n          jsvUnLock(res);\n        }\n      }\n    }\n    jsvUnLock(rhs);\n  }\n  return lhs;\n}\n\n\nJsVar *jspeAssignmentExpression() {\n  return __jspeAssignmentExpression(jspeConditionalExpression());\n}\n\n// ',' is allowed to add multiple expressions, this is not allowed in jspeAssignmentExpression\nNO_INLINE JsVar *jspeExpression() {\n  while (!JSP_SHOULDNT_PARSE) {\n    JsVar *a = jspeAssignmentExpression();\n    if (lex->tk!=',') return a;\n    // if we get a comma, we just forget this data and parse the next bit...\n    jsvCheckReferenceError(a);\n    jsvUnLock(a);\n    JSP_ASSERT_MATCH(',');\n  }\n  return 0;\n}\n\n/** Parse a block `{ ... }` */\nNO_INLINE void jspeSkipBlock() {\n  // fast skip of blocks\n  int brackets = 1;\n  while (lex->tk && brackets) {\n    if (lex->tk == '{') brackets++;\n    else if (lex->tk == '}') {\n      brackets--;\n      if (!brackets) return;\n    }\n    JSP_ASSERT_MATCH(lex->tk);\n  }\n}\n\n/** Parse a block `{ ... }` but assume brackets are already parsed */\nNO_INLINE void jspeBlockNoBrackets() {\n  if (JSP_SHOULD_EXECUTE) {\n    while (lex->tk && lex->tk!='}') {\n      JsVar *a = jspeStatement();\n      jsvCheckReferenceError(a);\n      jsvUnLock(a);\n      if (JSP_HAS_ERROR) {\n        if (lex && !(execInfo.execute&EXEC_ERROR_LINE_REPORTED)) {\n          execInfo.execute = (JsExecFlags)(execInfo.execute | EXEC_ERROR_LINE_REPORTED);\n          JsVar *stackTrace = jsvObjectGetChild(execInfo.hiddenRoot, JSPARSE_STACKTRACE_VAR, JSV_STRING_0);\n          if (stackTrace) {\n            jsvAppendPrintf(stackTrace, \"at \");\n            jspAppendStackTrace(stackTrace);\n            jsvUnLock(stackTrace);\n          }\n        }\n      }\n      if (JSP_SHOULDNT_PARSE)\n        return;\n      if (!JSP_SHOULD_EXECUTE) {\n        jspeSkipBlock();\n        return;\n      }\n    }\n  } else {\n    jspeSkipBlock();\n  }\n  return;\n}\n\n/** Parse a block `{ ... }` */\nNO_INLINE void jspeBlock() {\n  JSP_MATCH_WITH_RETURN('{',);\n  jspeBlockNoBrackets();\n  if (!JSP_SHOULDNT_PARSE) JSP_MATCH_WITH_RETURN('}',);\n  return;\n}\n\nNO_INLINE JsVar *jspeBlockOrStatement() {\n  if (lex->tk=='{') {\n    jspeBlock();\n    return 0;\n  } else {\n    JsVar *v = jspeStatement();\n    if (lex->tk==';') JSP_ASSERT_MATCH(';');\n    return v;\n  }\n}\n\n/** Parse using current lexer until we hit the end of\n * input or there was some problem. */\nNO_INLINE JsVar *jspParse() {\n  JsVar *v = 0;\n  while (!JSP_SHOULDNT_PARSE && lex->tk != LEX_EOF) {\n    jsvUnLock(v);\n    v = jspeBlockOrStatement();\n    jsvCheckReferenceError(v);\n  }\n  return v;\n}\n\nNO_INLINE JsVar *jspeStatementVar() {\n  JsVar *lastDefined = 0;\n  /* variable creation. TODO - we need a better way of parsing the left\n   * hand side. Maybe just have a flag called can_create_var that we\n   * set and then we parse as if we're doing a normal equals.*/\n  assert(lex->tk==LEX_R_VAR || lex->tk==LEX_R_LET || lex->tk==LEX_R_CONST);\n  jslGetNextToken();\n  ///TODO: Correctly implement CONST and LET - we just treat them like 'var' at the moment\n  bool hasComma = true; // for first time in loop\n  while (hasComma && lex->tk == LEX_ID && !jspIsInterrupted()) {\n    JsVar *a = 0;\n    if (JSP_SHOULD_EXECUTE) {\n      a = jspeiFindOnTop(jslGetTokenValueAsString(), true);\n      if (!a) { // out of memory\n        jspSetError(false);\n        return lastDefined;\n      }\n    }\n    JSP_MATCH_WITH_CLEANUP_AND_RETURN(LEX_ID, jsvUnLock(a), lastDefined);\n    // sort out initialiser\n    if (lex->tk == '=') {\n      JsVar *var;\n      JSP_MATCH_WITH_CLEANUP_AND_RETURN('=', jsvUnLock(a), lastDefined);\n      var = jsvSkipNameAndUnLock(jspeAssignmentExpression());\n      if (JSP_SHOULD_EXECUTE)\n        jsvReplaceWith(a, var);\n      jsvUnLock(var);\n    }\n    jsvUnLock(lastDefined);\n    lastDefined = a;\n    hasComma = lex->tk == ',';\n    if (hasComma) JSP_MATCH_WITH_RETURN(',', lastDefined);\n  }\n  return lastDefined;\n}\n\nNO_INLINE JsVar *jspeStatementIf() {\n  bool cond;\n  JsVar *var, *result = 0;\n  JSP_ASSERT_MATCH(LEX_R_IF);\n  JSP_MATCH('(');\n  var = jspeExpression();\n  if (JSP_SHOULDNT_PARSE) return var;\n  JSP_MATCH(')');\n  cond = JSP_SHOULD_EXECUTE && jsvGetBoolAndUnLock(jsvSkipName(var));\n  jsvUnLock(var);\n\n  JSP_SAVE_EXECUTE();\n  if (!cond) jspSetNoExecute();\n  JsExecFlags hasError = 0;\n  JsVar *a = jspeBlockOrStatement();\n  hasError |= execInfo.execute&EXEC_ERROR_MASK;\n  if (!cond) {\n    jsvUnLock(a);\n    JSP_RESTORE_EXECUTE();\n    execInfo.execute |= hasError;\n  } else {\n    result = a;\n  }\n  if (lex->tk==LEX_R_ELSE) {\n    JSP_ASSERT_MATCH(LEX_R_ELSE);\n    JSP_SAVE_EXECUTE();\n    if (cond) jspSetNoExecute();\n    JsVar *a = jspeBlockOrStatement();\n    hasError |= execInfo.execute&EXEC_ERROR_MASK;\n    if (cond) {\n      jsvUnLock(a);\n      JSP_RESTORE_EXECUTE();\n      execInfo.execute |= hasError;\n    } else {\n      result = a;\n    }\n  }\n  return result;\n}\n\nNO_INLINE JsVar *jspeStatementSwitch() {\n  JSP_ASSERT_MATCH(LEX_R_SWITCH);\n  JSP_MATCH('(');\n  JsVar *switchOn = jspeExpression();\n  JSP_SAVE_EXECUTE();\n  bool execute = JSP_SHOULD_EXECUTE;\n  JSP_MATCH_WITH_CLEANUP_AND_RETURN(')', jsvUnLock(switchOn), 0);\n  // shortcut if not executing...\n  if (!execute) { jsvUnLock(switchOn); jspeBlock(); return 0; }\n  JSP_MATCH_WITH_CLEANUP_AND_RETURN('{', jsvUnLock(switchOn), 0);\n\n  bool executeDefault = true;\n  if (execute) execInfo.execute=EXEC_NO|EXEC_IN_SWITCH;\n  while (lex->tk==LEX_R_CASE) {\n    JSP_MATCH_WITH_CLEANUP_AND_RETURN(LEX_R_CASE, jsvUnLock(switchOn), 0);\n    JsExecFlags oldFlags = execInfo.execute;\n    if (execute) execInfo.execute=EXEC_YES|EXEC_IN_SWITCH;\n    JsVar *test = jspeAssignmentExpression();\n    execInfo.execute = oldFlags|EXEC_IN_SWITCH;;\n    JSP_MATCH_WITH_CLEANUP_AND_RETURN(':', jsvUnLock2(switchOn, test), 0);\n    bool cond = false;\n    if (execute)\n      cond = jsvGetBoolAndUnLock(jsvMathsOpSkipNames(switchOn, test, LEX_TYPEEQUAL));\n    if (cond) executeDefault = false;\n    jsvUnLock(test);\n    if (cond && (execInfo.execute&EXEC_RUN_MASK)==EXEC_NO)\n      execInfo.execute=EXEC_YES|EXEC_IN_SWITCH;\n    while (!JSP_SHOULDNT_PARSE && lex->tk!=LEX_EOF && lex->tk!=LEX_R_CASE && lex->tk!=LEX_R_DEFAULT && lex->tk!='}')\n      jsvUnLock(jspeBlockOrStatement());\n    oldExecute |= execInfo.execute & (EXEC_ERROR_MASK|EXEC_RETURN); // copy across any errors/exceptions/returns\n  }\n  jsvUnLock(switchOn);\n  if (execute && (execInfo.execute&EXEC_RUN_MASK)==EXEC_BREAK) {\n    execInfo.execute=EXEC_YES|EXEC_IN_SWITCH;\n  } else {\n    executeDefault = true;\n  }\n  JSP_RESTORE_EXECUTE();\n\n  if (lex->tk==LEX_R_DEFAULT) {\n    JSP_ASSERT_MATCH(LEX_R_DEFAULT);\n    JSP_MATCH(':');\n    JSP_SAVE_EXECUTE();\n    if (!executeDefault) jspSetNoExecute();\n    else execInfo.execute |= EXEC_IN_SWITCH;\n    while (!JSP_SHOULDNT_PARSE && lex->tk!=LEX_EOF && lex->tk!='}' && lex->tk!=LEX_R_CASE)\n      jsvUnLock(jspeBlockOrStatement());\n    oldExecute |= execInfo.execute & (EXEC_ERROR_MASK|EXEC_RETURN); // copy across any errors/exceptions/returns\n    execInfo.execute = execInfo.execute & (JsExecFlags)~EXEC_BREAK;\n    JSP_RESTORE_EXECUTE();\n  }\n  if (lex->tk==LEX_R_CASE) {\n    jsExceptionHere(JSET_SYNTAXERROR, \"Espruino doesn't support CASE after DEFAULT\");\n    return 0;\n  }\n  JSP_MATCH('}');\n  return 0;\n}\n\n// Check whether we received a break/continue while parsing previously. Return true if we had a 'break;\nstatic NO_INLINE bool jspeCheckBreakContinue() {\n  if (execInfo.execute & EXEC_CONTINUE)\n    execInfo.execute = (execInfo.execute & ~EXEC_RUN_MASK) | EXEC_YES;\n  else if (execInfo.execute & EXEC_BREAK) {\n    execInfo.execute = (execInfo.execute & ~EXEC_RUN_MASK) | EXEC_YES;\n    return true;\n  }\n  return false;\n}\n\nNO_INLINE JsVar *jspeStatementDoOrWhile(bool isWhile) {\n  JsVar *cond;\n  bool loopCond = true; // true for do...while loops\n  bool hasHadBreak = false;\n  JslCharPos whileCondStart;\n  // We do repetition by pulling out the string representing our statement\n  // there's definitely some opportunity for optimisation here\n\n  bool wasInLoop = (execInfo.execute&EXEC_IN_LOOP)!=0;\n  JslCharPos whileBodyStart;\n  if (isWhile) { // while loop\n    JSP_ASSERT_MATCH(LEX_R_WHILE);\n    jslCharPosFromLex(&whileCondStart);\n    JSP_MATCH_WITH_CLEANUP_AND_RETURN('(',jslCharPosFree(&whileCondStart);,0);\n    cond = jspeExpression();\n    loopCond = JSP_SHOULD_EXECUTE && jsvGetBoolAndUnLock(jsvSkipName(cond));\n    jsvUnLock(cond);\n    jslCharPosFromLex(&whileBodyStart);\n    JSP_MATCH_WITH_CLEANUP_AND_RETURN(')',jslCharPosFree(&whileBodyStart);jslCharPosFree(&whileCondStart);,0);\n  } else {\n    jslCharPosFromLex(&whileBodyStart);\n    JSP_MATCH_WITH_CLEANUP_AND_RETURN(LEX_R_DO, jslCharPosFree(&whileBodyStart);,0);\n  }\n  JSP_SAVE_EXECUTE();\n  // actually try and execute first bit of while loop (we'll do the rest in the actual loop later)\n  if (!loopCond) jspSetNoExecute();\n  execInfo.execute |= EXEC_IN_LOOP;\n  jsvUnLock(jspeBlockOrStatement());\n  if (!wasInLoop) execInfo.execute &= (JsExecFlags)~EXEC_IN_LOOP;\n\n  hasHadBreak |= jspeCheckBreakContinue();\n  if (!loopCond) JSP_RESTORE_EXECUTE();\n\n  if (!isWhile) { // do..while loop\n    JSP_MATCH_WITH_CLEANUP_AND_RETURN(LEX_R_WHILE,jslCharPosFree(&whileBodyStart);,0);\n    jslCharPosFromLex(&whileCondStart);\n    JSP_MATCH_WITH_CLEANUP_AND_RETURN('(',jslCharPosFree(&whileBodyStart);jslCharPosFree(&whileCondStart);,0);\n    cond = jspeExpression();\n    loopCond = JSP_SHOULD_EXECUTE && jsvGetBoolAndUnLock(jsvSkipName(cond));\n    jsvUnLock(cond);\n    JSP_MATCH_WITH_CLEANUP_AND_RETURN(')',jslCharPosFree(&whileBodyStart);jslCharPosFree(&whileCondStart);,0);\n  }\n\n  JslCharPos whileBodyEnd;\n  jslCharPosNew(&whileBodyEnd, lex->sourceVar, lex->tokenStart);\n\n  int loopCount = 0;\n  while (!hasHadBreak && loopCond\n#ifdef JSPARSE_MAX_LOOP_ITERATIONS\n      && loopCount<JSPARSE_MAX_LOOP_ITERATIONS\n#endif\n  ) {\n    if (isWhile || loopCount) { // don't check the start condition a second time if we're in a do..while loop\n      jslSeekToP(&whileCondStart);\n      cond = jspeExpression();\n      loopCond = JSP_SHOULD_EXECUTE && jsvGetBoolAndUnLock(jsvSkipName(cond));\n      jsvUnLock(cond);\n    }\n    if (loopCond) {\n      jslSeekToP(&whileBodyStart);\n      execInfo.execute |= EXEC_IN_LOOP;\n      jspDebuggerLoopIfCtrlC();\n      jsvUnLock(jspeBlockOrStatement());\n      if (!wasInLoop) execInfo.execute &= (JsExecFlags)~EXEC_IN_LOOP;\n      hasHadBreak |= jspeCheckBreakContinue();\n    }\n    loopCount++;\n  }\n  jslSeekToP(&whileBodyEnd);\n  jslCharPosFree(&whileCondStart);\n  jslCharPosFree(&whileBodyStart);\n  jslCharPosFree(&whileBodyEnd);\n#ifdef JSPARSE_MAX_LOOP_ITERATIONS\n  if (loopCount > JSPARSE_MAX_LOOP_ITERATIONS) {\n    jsExceptionHere(JSET_ERROR, \"WHILE Loop exceeded the maximum number of iterations (\" STRINGIFY(JSPARSE_MAX_LOOP_ITERATIONS) \")\");\n  }\n#endif\n  return 0;\n}\n\nNO_INLINE JsVar *jspGetBuiltinPrototype(JsVar *obj) {\n  if (jsvIsArray(obj)) {\n    JsVar *v = jspFindPrototypeFor(\"Array\");\n    if (v) return v;\n  }\n  if (jsvIsObject(obj) || jsvIsArray(obj)) {\n    JsVar *v = jspFindPrototypeFor(\"Object\");\n    if (v==obj) { // don't return ourselves\n      jsvUnLock(v);\n      v = 0;\n    }\n    return v;\n  }\n  return 0;\n}\n\nNO_INLINE JsVar *jspeStatementFor() {\n  JSP_ASSERT_MATCH(LEX_R_FOR);\n  JSP_MATCH('(');\n  bool wasInLoop = (execInfo.execute&EXEC_IN_LOOP)!=0;\n  execInfo.execute |= EXEC_FOR_INIT;\n  // initialisation\n  JsVar *forStatement = 0;\n  // we could have 'for (;;)' - so don't munch up our semicolon if that's all we have\n  if (lex->tk != ';')\n    forStatement = jspeStatement();\n  if (jspIsInterrupted()) {\n    jsvUnLock(forStatement);\n    return 0;\n  }\n  execInfo.execute &= (JsExecFlags)~EXEC_FOR_INIT;\n#ifndef SAVE_ON_FLASH_EXTREME\n  if (lex->tk == LEX_R_IN || lex->tk == LEX_R_OF) {\n    bool isForOf = lex->tk == LEX_R_OF;\n    // for (i in array)  or   for (i of array)\n    // where i = forStatement\n    if (JSP_SHOULD_EXECUTE && !jsvIsName(forStatement)) {\n      jsvUnLock(forStatement);\n      jsExceptionHere(JSET_ERROR, \"for(a %s b) - 'a' must be a variable name, not %t\", isForOf?\"of\":\"in\", forStatement);\n      return 0;\n    }\n\n    JSP_ASSERT_MATCH(lex->tk); // skip over in/of\n    JsVar *array = jsvSkipNameAndUnLock(jspeExpression());\n\n    JslCharPos forBodyStart;\n    jslCharPosFromLex(&forBodyStart);\n    JSP_MATCH_WITH_CLEANUP_AND_RETURN(')', jsvUnLock2(forStatement, array);jslCharPosFree(&forBodyStart), 0);\n\n    // Simply scan over the loop the first time without executing to figure out where it ends\n    // OPT: we could skip the first parse and actually execute the first time\n    JSP_SAVE_EXECUTE();\n    jspSetNoExecute();\n    execInfo.execute |= EXEC_IN_LOOP;\n    jsvUnLock(jspeBlockOrStatement());\n    JslCharPos forBodyEnd;\n    jslCharPosNew(&forBodyEnd, lex->sourceVar, lex->tokenStart);\n    if (!wasInLoop) execInfo.execute &= (JsExecFlags)~EXEC_IN_LOOP;\n    JSP_RESTORE_EXECUTE();\n    // Now start executing properly\n    if (JSP_SHOULD_EXECUTE) {\n      if (jsvIsIterable(array)) {\n        JsvIsInternalChecker checkerFunction = jsvGetInternalFunctionCheckerFor(array);\n        JsVar *foundPrototype = 0;\n        if (!isForOf) // for..in\n          foundPrototype = jspGetBuiltinPrototype(array);\n\n        JsvIterator it;\n        jsvIteratorNew(&it, array, isForOf ?\n            /* for of */ JSIF_EVERY_ARRAY_ELEMENT :\n            /* for in */ JSIF_DEFINED_ARRAY_ElEMENTS);\n        bool hasHadBreak = false;\n        while (JSP_SHOULD_EXECUTE && jsvIteratorHasElement(&it) && !hasHadBreak) {\n          JsVar *loopIndexVar = jsvIteratorGetKey(&it);\n          bool ignore = false;\n          if (checkerFunction && checkerFunction(loopIndexVar)) {\n            ignore = true;\n            if (jsvIsString(loopIndexVar) &&\n                jsvIsStringEqual(loopIndexVar, JSPARSE_INHERITS_VAR))\n              foundPrototype = jsvSkipName(loopIndexVar);\n          }\n          if (!ignore) {\n            JsVar *iteratorValue;\n            if (isForOf) { // for (... of ...)\n              iteratorValue = jsvIteratorGetValue(&it);\n            } else { // for (... in ...)\n              iteratorValue = jsvIsName(loopIndexVar) ?\n                  jsvCopyNameOnly(loopIndexVar, false/*no copy children*/, false/*not a name*/) :\n                  loopIndexVar;\n              assert(jsvGetRefs(iteratorValue)==0);\n            }\n            if (isForOf || iteratorValue) { // could be out of memory\n              assert(!jsvIsName(iteratorValue));\n              jsvReplaceWithOrAddToRoot(forStatement, iteratorValue);\n              if (iteratorValue!=loopIndexVar) jsvUnLock(iteratorValue);\n\n              jslSeekToP(&forBodyStart);\n              execInfo.execute |= EXEC_IN_LOOP;\n              jspDebuggerLoopIfCtrlC();\n              jsvUnLock(jspeBlockOrStatement());\n              if (!wasInLoop) execInfo.execute &= (JsExecFlags)~EXEC_IN_LOOP;\n\n              hasHadBreak |= jspeCheckBreakContinue();\n            }\n          }\n          jsvIteratorNext(&it);\n          jsvUnLock(loopIndexVar);\n          // if using for..in we'll skip down the prototype chain when we reach the end of the current one\n          if (!jsvIteratorHasElement(&it) && !isForOf && foundPrototype) {\n            jsvIteratorFree(&it);\n            JsVar *iterable = foundPrototype;\n            jsvIteratorNew(&it, iterable, JSIF_DEFINED_ARRAY_ElEMENTS);\n            checkerFunction = jsvGetInternalFunctionCheckerFor(iterable);\n            foundPrototype = jspGetBuiltinPrototype(iterable);\n            jsvUnLock(iterable);\n          }\n        }\n        assert(!foundPrototype);\n        jsvIteratorFree(&it);\n      } else if (!jsvIsUndefined(array)) {\n        jsExceptionHere(JSET_ERROR, \"FOR loop can only iterate over Arrays, Strings or Objects, not %t\", array);\n      }\n    }\n    jslSeekToP(&forBodyEnd);\n    jslCharPosFree(&forBodyStart);\n    jslCharPosFree(&forBodyEnd);\n\n    jsvUnLock2(forStatement, array);\n#else // SAVE_ON_FLASH_EXTREME\n  if (false) {\n#endif // SAVE_ON_FLASH_EXTREME\n  } else { // ----------------------------------------------- NORMAL FOR LOOP\n#ifdef JSPARSE_MAX_LOOP_ITERATIONS\n    int loopCount = JSPARSE_MAX_LOOP_ITERATIONS;\n#endif\n    bool loopCond = true;\n    bool hasHadBreak = false;\n\n    jsvUnLock(forStatement);\n    JslCharPos forCondStart;\n    jslCharPosFromLex(&forCondStart);\n    JSP_MATCH_WITH_CLEANUP_AND_RETURN(';',jslCharPosFree(&forCondStart);,0);\n\n    if (lex->tk != ';') {\n      JsVar *cond = jspeExpression(); // condition\n      loopCond = JSP_SHOULD_EXECUTE && jsvGetBoolAndUnLock(jsvSkipName(cond));\n      jsvUnLock(cond);\n    }\n    JslCharPos forIterStart;\n    jslCharPosFromLex(&forIterStart);\n    JSP_MATCH_WITH_CLEANUP_AND_RETURN(';',jslCharPosFree(&forCondStart);jslCharPosFree(&forIterStart);,0);\n    if (lex->tk != ')')  { // we could have 'for (;;)'\n      JSP_SAVE_EXECUTE();\n      jspSetNoExecute();\n      jsvUnLock(jspeExpression()); // iterator\n      JSP_RESTORE_EXECUTE();\n    }\n    JslCharPos forBodyStart;\n    jslSkipWhiteSpace();\n    jslCharPosFromLex(&forBodyStart); // actual for body\n    JSP_MATCH_WITH_CLEANUP_AND_RETURN(')',jslCharPosFree(&forCondStart);jslCharPosFree(&forIterStart);jslCharPosFree(&forBodyStart);,0);\n\n    JSP_SAVE_EXECUTE();\n    if (!loopCond) jspSetNoExecute();\n    execInfo.execute |= EXEC_IN_LOOP;\n    jsvUnLock(jspeBlockOrStatement());\n    JslCharPos forBodyEnd;\n    jslSkipWhiteSpace();\n    jslCharPosNew(&forBodyEnd, lex->sourceVar, lex->tokenStart);\n    if (!wasInLoop) execInfo.execute &= (JsExecFlags)~EXEC_IN_LOOP;\n    if (loopCond || !JSP_SHOULD_EXECUTE) {\n      hasHadBreak |= jspeCheckBreakContinue();\n    }\n    if (!loopCond) JSP_RESTORE_EXECUTE();\n    if (loopCond) {\n      jslSeekToP(&forIterStart);\n      if (lex->tk != ')') jsvUnLock(jspeExpression());\n    }\n    while (!hasHadBreak && JSP_SHOULD_EXECUTE && loopCond\n#ifdef JSPARSE_MAX_LOOP_ITERATIONS\n        && loopCount-->0\n#endif\n    ) {\n      jslSeekToP(&forCondStart);\n      ;\n      if (lex->tk == ';') {\n        loopCond = true;\n      } else {\n        JsVar *cond = jspeExpression();\n        loopCond = jsvGetBoolAndUnLock(jsvSkipName(cond));\n        jsvUnLock(cond);\n      }\n      if (JSP_SHOULD_EXECUTE && loopCond) {\n        jslSeekToP(&forBodyStart);\n        execInfo.execute |= EXEC_IN_LOOP;\n        jspDebuggerLoopIfCtrlC();\n        jsvUnLock(jspeBlockOrStatement());\n        if (!wasInLoop) execInfo.execute &= (JsExecFlags)~EXEC_IN_LOOP;\n        hasHadBreak |= jspeCheckBreakContinue();\n      }\n      if (JSP_SHOULD_EXECUTE && loopCond && !hasHadBreak) {\n        jslSeekToP(&forIterStart);\n        if (lex->tk != ')') jsvUnLock(jspeExpression());\n      }\n    }\n    jslSeekToP(&forBodyEnd);\n\n    jslCharPosFree(&forCondStart);\n    jslCharPosFree(&forIterStart);\n    jslCharPosFree(&forBodyStart);\n    jslCharPosFree(&forBodyEnd);\n\n#ifdef JSPARSE_MAX_LOOP_ITERATIONS\n    if (loopCount<=0) {\n      jsExceptionHere(JSET_ERROR, \"FOR Loop exceeded the maximum number of iterations (\"STRINGIFY(JSPARSE_MAX_LOOP_ITERATIONS)\")\");\n    }\n#endif\n  }\n  return 0;\n}\n\nNO_INLINE JsVar *jspeStatementTry() {\n  // execute the try block\n  JSP_ASSERT_MATCH(LEX_R_TRY);\n  bool shouldExecuteBefore = JSP_SHOULD_EXECUTE;\n  jspeBlock();\n  bool hadException = shouldExecuteBefore && ((execInfo.execute & EXEC_EXCEPTION)!=0);\n\n  bool hadCatch = false;\n  if (lex->tk == LEX_R_CATCH) {\n    JSP_ASSERT_MATCH(LEX_R_CATCH);\n    hadCatch = true;\n    JSP_MATCH('(');\n    JsVar *scope = 0;\n    JsVar *exceptionVar = 0;\n    if (hadException) {\n      scope = jsvNewObject();\n      if (scope)\n        exceptionVar = jsvFindChildFromString(scope, jslGetTokenValueAsString(), true);\n    }\n    JSP_MATCH_WITH_CLEANUP_AND_RETURN(LEX_ID,jsvUnLock2(scope,exceptionVar),0);\n    JSP_MATCH_WITH_CLEANUP_AND_RETURN(')',jsvUnLock2(scope,exceptionVar),0);\n    if (exceptionVar) {\n      // set the exception var up properly\n      JsVar *exception = jspGetException();\n      if (exception) {\n        jsvSetValueOfName(exceptionVar, exception);\n        jsvUnLock(exception);\n      }\n      // Now clear the exception flag (it's handled - we hope!)\n      execInfo.execute = execInfo.execute & (JsExecFlags)~(EXEC_EXCEPTION|EXEC_ERROR_LINE_REPORTED);\n      jsvUnLock(exceptionVar);\n    }\n\n    if (shouldExecuteBefore && !hadException) {\n      JSP_SAVE_EXECUTE();\n      jspSetNoExecute();\n      jspeBlock();\n      JSP_RESTORE_EXECUTE();\n    } else {\n      if (!scope || jspeiAddScope(scope)) {\n        jspeBlock();\n        if (scope) jspeiRemoveScope();\n      }\n    }\n    jsvUnLock(scope);\n  }\n  if (lex->tk == LEX_R_FINALLY || (!hadCatch && ((execInfo.execute&(EXEC_ERROR|EXEC_INTERRUPTED))==0))) {\n    JSP_MATCH(LEX_R_FINALLY);\n    // clear the exception flag - but only momentarily!\n    if (hadException) execInfo.execute = execInfo.execute & (JsExecFlags)~EXEC_EXCEPTION;\n    jspeBlock();\n    // put the flag back!\n    if (hadException && !hadCatch) execInfo.execute = execInfo.execute | EXEC_EXCEPTION;\n  }\n  return 0;\n}\n\nNO_INLINE JsVar *jspeStatementReturn() {\n  JsVar *result = 0;\n  JSP_ASSERT_MATCH(LEX_R_RETURN);\n  if (lex->tk != ';' && lex->tk != '}') {\n    // we only want the value, so skip the name if there was one\n    result = jsvSkipNameAndUnLock(jspeExpression());\n  }\n  if (JSP_SHOULD_EXECUTE) {\n    JsVar *resultVar = jspeiFindInScopes(JSPARSE_RETURN_VAR);\n    if (resultVar) {\n      jsvReplaceWith(resultVar, result);\n      jsvUnLock(resultVar);\n      execInfo.execute |= EXEC_RETURN; // Stop anything else in this function executing\n    } else {\n      jsExceptionHere(JSET_SYNTAXERROR, \"RETURN statement, but not in a function.\\n\");\n    }\n  }\n  jsvUnLock(result);\n  return 0;\n}\n\nNO_INLINE JsVar *jspeStatementThrow() {\n  JsVar *result = 0;\n  JSP_ASSERT_MATCH(LEX_R_THROW);\n  result = jsvSkipNameAndUnLock(jspeExpression());\n  if (JSP_SHOULD_EXECUTE) {\n    jspSetException(result); // Stop anything else in this function executing\n  }\n  jsvUnLock(result);\n  return 0;\n}\n\nNO_INLINE JsVar *jspeStatementFunctionDecl(bool isClass) {\n  JsVar *funcName = 0;\n  JsVar *funcVar;\n\n#ifndef SAVE_ON_FLASH\n  JSP_ASSERT_MATCH(isClass ? LEX_R_CLASS : LEX_R_FUNCTION);\n#else\n  JSP_ASSERT_MATCH(LEX_R_FUNCTION);\n#endif\n\n  bool actuallyCreateFunction = JSP_SHOULD_EXECUTE;\n  if (actuallyCreateFunction) {\n    funcName = jsvMakeIntoVariableName(jslGetTokenValueAsVar(), 0);\n    if (!funcName) { // out of memory\n      return 0;\n    }\n  }\n  JSP_MATCH_WITH_CLEANUP_AND_RETURN(LEX_ID, jsvUnLock(funcName), 0);\n#ifndef SAVE_ON_FLASH\n  funcVar = isClass ? jspeClassDefinition(false) : jspeFunctionDefinition(false);\n#else\n  funcVar = jspeFunctionDefinition(false);\n#endif\n  if (actuallyCreateFunction) {\n    // find a function with the same name (or make one)\n    // OPT: can Find* use just a JsVar that is a 'name'?\n    JsVar *existingName = jspeiFindNameOnTop(funcName, true);\n    JsVar *existingFunc = jsvSkipName(existingName);\n    if (jsvIsFunction(existingFunc)) {\n      // 'proper' replace, that keeps the original function var and swaps the children\n      funcVar = jsvSkipNameAndUnLock(funcVar);\n      jswrap_function_replaceWith(existingFunc, funcVar);\n    } else {\n      jsvReplaceWith(existingName, funcVar);\n    }\n    jsvUnLock(funcName);\n    funcName = existingName;\n    jsvUnLock(existingFunc);\n    // existingName is used - don't UnLock\n  }\n  jsvUnLock(funcVar);\n  return funcName;\n}\n\nNO_INLINE JsVar *jspeStatement() {\n#ifdef USE_DEBUGGER\n  if (execInfo.execute&EXEC_DEBUGGER_NEXT_LINE &&\n      lex->tk!=';' &&\n      JSP_SHOULD_EXECUTE) {\n    lex->tokenLastStart = lex->tokenStart;\n    jsiDebuggerLoop();\n  }\n#endif\n  if (lex->tk==LEX_ID ||\n      lex->tk==LEX_INT ||\n      lex->tk==LEX_FLOAT ||\n      lex->tk==LEX_STR ||\n      lex->tk==LEX_TEMPLATE_LITERAL ||\n      lex->tk==LEX_REGEX ||\n      lex->tk==LEX_R_NEW ||\n      lex->tk==LEX_R_NULL ||\n      lex->tk==LEX_R_UNDEFINED ||\n      lex->tk==LEX_R_TRUE ||\n      lex->tk==LEX_R_FALSE ||\n      lex->tk==LEX_R_THIS ||\n      lex->tk==LEX_R_DELETE ||\n      lex->tk==LEX_R_TYPEOF ||\n      lex->tk==LEX_R_VOID ||\n      lex->tk==LEX_R_SUPER ||\n      lex->tk==LEX_PLUSPLUS ||\n      lex->tk==LEX_MINUSMINUS ||\n      lex->tk=='!' ||\n      lex->tk=='-' ||\n      lex->tk=='+' ||\n      lex->tk=='~' ||\n      lex->tk=='[' ||\n      lex->tk=='(') {\n    /* Execute a simple statement that only contains basic arithmetic... */\n    return jspeExpression();\n  } else if (lex->tk=='{') {\n    /* A block of code */\n    if (!jspCheckStackPosition()) return 0;\n    jspeBlock();\n    return 0;\n  } else if (lex->tk==';') {\n    /* Empty statement - to allow things like ;;; */\n    JSP_ASSERT_MATCH(';');\n    return 0;\n  } else if (lex->tk==LEX_R_VAR ||\n            lex->tk==LEX_R_LET ||\n            lex->tk==LEX_R_CONST) {\n    return jspeStatementVar();\n  } else if (lex->tk==LEX_R_IF) {\n    return jspeStatementIf();\n  } else if (lex->tk==LEX_R_DO) {\n    return jspeStatementDoOrWhile(false);\n  } else if (lex->tk==LEX_R_WHILE) {\n    return jspeStatementDoOrWhile(true);\n  } else if (lex->tk==LEX_R_FOR) {\n    return jspeStatementFor();\n  } else if (lex->tk==LEX_R_TRY) {\n    return jspeStatementTry();\n  } else if (lex->tk==LEX_R_RETURN) {\n    return jspeStatementReturn();\n  } else if (lex->tk==LEX_R_THROW) {\n    return jspeStatementThrow();\n  } else if (lex->tk==LEX_R_FUNCTION) {\n    return jspeStatementFunctionDecl(false/* function */);\n#ifndef SAVE_ON_FLASH\n  } else if (lex->tk==LEX_R_CLASS) {\n      return jspeStatementFunctionDecl(true/* class */);\n#endif\n  } else if (lex->tk==LEX_R_CONTINUE) {\n    JSP_ASSERT_MATCH(LEX_R_CONTINUE);\n    if (JSP_SHOULD_EXECUTE) {\n      if (!(execInfo.execute & EXEC_IN_LOOP))\n        jsExceptionHere(JSET_SYNTAXERROR, \"CONTINUE statement outside of FOR or WHILE loop\");\n      else\n        execInfo.execute = (execInfo.execute & (JsExecFlags)~EXEC_RUN_MASK) | EXEC_CONTINUE;\n    }\n  } else if (lex->tk==LEX_R_BREAK) {\n    JSP_ASSERT_MATCH(LEX_R_BREAK);\n    if (JSP_SHOULD_EXECUTE) {\n      if (!(execInfo.execute & (EXEC_IN_LOOP|EXEC_IN_SWITCH)))\n        jsExceptionHere(JSET_SYNTAXERROR, \"BREAK statement outside of SWITCH, FOR or WHILE loop\");\n      else\n        execInfo.execute = (execInfo.execute & (JsExecFlags)~EXEC_RUN_MASK) | EXEC_BREAK;\n    }\n  } else if (lex->tk==LEX_R_SWITCH) {\n    return jspeStatementSwitch();\n  } else if (lex->tk==LEX_R_DEBUGGER) {\n    JSP_ASSERT_MATCH(LEX_R_DEBUGGER);\n#ifdef USE_DEBUGGER\n    if (JSP_SHOULD_EXECUTE)\n      jsiDebuggerLoop();\n#endif\n  } else JSP_MATCH(LEX_EOF);\n  return 0;\n}\n\n// -----------------------------------------------------------------------------\n/// Create a new built-in object that jswrapper can use to check for built-in functions\nJsVar *jspNewBuiltin(const char *instanceOf) {\n  JsVar *objFunc = jswFindBuiltInFunction(0, instanceOf);\n  if (!objFunc) return 0; // out of memory\n  return objFunc;\n}\n\n/// Create a new Class of the given instance and return its prototype\nNO_INLINE JsVar *jspNewPrototype(const char *instanceOf) {\n  JsVar *objFuncName = jsvFindChildFromString(execInfo.root, instanceOf, true);\n  if (!objFuncName) // out of memory\n    return 0;\n\n  JsVar *objFunc = jsvSkipName(objFuncName);\n  if (!objFunc) {\n    objFunc = jspNewBuiltin(instanceOf);\n    if (!objFunc) { // out of memory\n      jsvUnLock(objFuncName);\n      return 0;\n    }\n\n    // set up name\n    jsvSetValueOfName(objFuncName, objFunc);\n  }\n\n  JsVar *prototypeName = jsvFindChildFromString(objFunc, JSPARSE_PROTOTYPE_VAR, true);\n  jspEnsureIsPrototype(objFunc, prototypeName); // make sure it's an object\n  jsvUnLock2(objFunc, objFuncName);\n\n  return prototypeName;\n}\n\n/** Create a new object of the given instance and add it to root with name 'name'.\n * If name!=0, added to root with name, and the name is returned\n * If name==0, not added to root and Object itself returned */\nNO_INLINE JsVar *jspNewObject(const char *name, const char *instanceOf) {\n  JsVar *prototypeName = jspNewPrototype(instanceOf);\n\n  JsVar *obj = jsvNewObject();\n  if (!obj) { // out of memory\n    jsvUnLock(prototypeName);\n    return 0;\n  }\n  if (name) {\n    // If it's a device, set the device number up as the Object data\n    // See jsiGetDeviceFromClass\n    IOEventFlags device = jshFromDeviceString(name);\n    if (device!=EV_NONE) {\n      obj->varData.str[0] = 'D';\n      obj->varData.str[1] = 'E';\n      obj->varData.str[2] = 'V';\n      obj->varData.str[3] = (char)device;\n    }\n\n  }\n  // add __proto__\n  JsVar *prototypeVar = jsvSkipName(prototypeName);\n  jsvUnLock3(jsvAddNamedChild(obj, prototypeVar, JSPARSE_INHERITS_VAR), prototypeVar, prototypeName);prototypeName=0;\n\n  if (name) {\n    JsVar *objName = jsvFindChildFromString(execInfo.root, name, true);\n    if (objName) jsvSetValueOfName(objName, obj);\n    jsvUnLock(obj);\n    if (!objName) { // out of memory\n      return 0;\n    }\n    return objName;\n  } else\n    return obj;\n}\n\n/** Returns true if the constructor function given is the same as that\n * of the object with the given name. */\nbool jspIsConstructor(JsVar *constructor, const char *constructorName) {\n  JsVar *objFunc = jsvObjectGetChild(execInfo.root, constructorName, 0);\n  if (!objFunc) return false;\n  bool isConstructor = objFunc == constructor;\n  jsvUnLock(objFunc);\n  return isConstructor;\n}\n\n/** Get the prototype of the given object, or return 0 if not found, or not an object */\nJsVar *jspGetPrototype(JsVar *object) {\n  if (!jsvIsObject(object)) return 0;\n  JsVar *proto = jsvObjectGetChild(object, JSPARSE_INHERITS_VAR, 0);\n  if (jsvIsObject(proto))\n    return proto;\n  jsvUnLock(proto);\n  return 0;\n}\n\n/** Get the constructor of the given object, or return 0 if not found, or not a function */\nJsVar *jspGetConstructor(JsVar *object) {\n  JsVar *proto = jspGetPrototype(object);\n  if (proto) {\n    JsVar *constr = jsvObjectGetChild(proto, JSPARSE_CONSTRUCTOR_VAR, 0);\n    if (jsvIsFunction(constr)) {\n      jsvUnLock(proto);\n      return constr;\n    }\n    jsvUnLock2(constr, proto);\n  }\n  return 0;\n}\n\n// -----------------------------------------------------------------------------\n\nvoid jspSoftInit() {\n  execInfo.root = jsvFindOrCreateRoot();\n  // Root now has a lock and a ref\n  execInfo.hiddenRoot = jsvObjectGetChild(execInfo.root, JS_HIDDEN_CHAR_STR, JSV_OBJECT);\n  execInfo.execute = EXEC_YES;\n}\n\nvoid jspSoftKill() {\n  jsvUnLock(execInfo.scopesVar);\n  execInfo.scopesVar = 0;\n  jsvUnLock(execInfo.hiddenRoot);\n  execInfo.hiddenRoot = 0;\n  jsvUnLock(execInfo.root);\n  execInfo.root = 0;\n  // Root is now left with just a ref\n}\n\nvoid jspInit() {\n  jspSoftInit();\n}\n\nvoid jspKill() {\n  jspSoftKill();\n  // Unreffing this should completely kill everything attached to root\n  JsVar *r = jsvFindOrCreateRoot();\n  jsvUnRef(r);\n  jsvUnLock(r);\n}\n\n/** Evaluate the given variable as an expression (in current scope) */\nJsVar *jspEvaluateExpressionVar(JsVar *str) {\n  JsLex lex;\n\n  assert(jsvIsString(str));\n  JsLex *oldLex = jslSetLex(&lex);\n  jslInit(str);\n#ifndef ESPR_NO_LINE_NUMBERS\n  lex.lineNumberOffset = oldLex->lineNumberOffset;\n#endif\n\n  // actually do the parsing\n  JsVar *v = jspeExpression();\n  jslKill();\n  jslSetLex(oldLex);\n\n  return jsvSkipNameAndUnLock(v);\n}\n\n/** Execute code form a variable and return the result. If lineNumberOffset\n * is nonzero it's added to the line numbers that get reported for errors/debug */\nJsVar *jspEvaluateVar(JsVar *str, JsVar *scope, uint16_t lineNumberOffset) {\n  JsLex lex;\n\n  assert(jsvIsString(str));\n  JsLex *oldLex = jslSetLex(&lex);\n  jslInit(str);\n#ifndef ESPR_NO_LINE_NUMBERS\n  lex.lineNumberOffset = lineNumberOffset;\n#endif\n\n\n  JsExecInfo oldExecInfo = execInfo;\n  execInfo.execute = EXEC_YES;\n  if (scope) {\n    // if we're adding a scope, make sure it's the *only* scope\n    execInfo.scopesVar = 0;\n    if (scope!=execInfo.root) jspeiAddScope(scope); // it's searched by default anyway\n  }\n\n  // actually do the parsing\n  JsVar *v = jspParse();\n  // clean up\n  if (scope) jspeiClearScopes();\n  jslKill();\n  jslSetLex(oldLex);\n\n  // restore state and execInfo (keep error flags & ctrl-c)\n  oldExecInfo.execute |= execInfo.execute & EXEC_PERSIST;\n  execInfo = oldExecInfo;\n\n  // It may have returned a reference, but we just want the value...\n  return jsvSkipNameAndUnLock(v);\n}\n\nJsVar *jspEvaluate(const char *str, bool stringIsStatic) {\n\n  /* using a memory area is more efficient, but the interpreter\n   * may use substrings from it for function code. This means that\n   * if the string goes away, everything gets corrupted - hence\n   * the option here.\n   */\n  JsVar *evCode;\n  if (stringIsStatic)\n    evCode = jsvNewNativeString((char*)str, strlen(str));\n  else\n    evCode = jsvNewFromString(str);\n  if (!evCode) return 0;\n\n  JsVar *v = 0;\n  if (!jsvIsMemoryFull())\n    v = jspEvaluateVar(evCode, 0, 0);\n  jsvUnLock(evCode);\n\n  return v;\n}\n\nJsVar *jspExecuteJSFunction(const char *jsCode, JsVar *thisArg, int argCount, JsVar **argPtr) {\n  JsVar *fn = jspEvaluate(jsCode,true);\n  JsVar *result = jspExecuteFunction(fn,thisArg,argCount,argPtr);\n  jsvUnLock(fn);\n  return result;\n}\n\nJsVar *jspExecuteFunction(JsVar *func, JsVar *thisArg, int argCount, JsVar **argPtr) {\n  JsExecInfo oldExecInfo = execInfo;\n  execInfo.scopesVar = 0;\n  execInfo.execute = EXEC_YES;\n  execInfo.thisVar = 0;\n  JsVar *result = jspeFunctionCall(func, 0, thisArg, false, argCount, argPtr);\n  // clean up\n  jspeiClearScopes();\n  // restore state and execInfo (keep error flags & ctrl-c)\n  oldExecInfo.execute |= execInfo.execute&EXEC_PERSIST;\n  jspeiClearScopes();\n  execInfo = oldExecInfo;\n\n  return result;\n}\n\n\n/// Evaluate a JavaScript module and return its exports\nJsVar *jspEvaluateModule(JsVar *moduleContents) {\n  assert(jsvIsString(moduleContents) || jsvIsFunction(moduleContents));\n  if (jsvIsFunction(moduleContents)) {\n    moduleContents = jsvObjectGetChild(moduleContents,JSPARSE_FUNCTION_CODE_NAME,0);\n    if (!jsvIsString(moduleContents)) {\n      jsvUnLock(moduleContents);\n      return 0;\n    }\n  } else\n    jsvLockAgain(moduleContents);\n  JsVar *scope = jsvNewObject();\n  JsVar *scopeExports = jsvNewObject();\n  if (!scope || !scopeExports) { // out of mem\n    jsvUnLock3(scope, scopeExports, moduleContents);\n    return 0;\n  }\n  JsVar *exportsName = jsvAddNamedChild(scope, scopeExports, \"exports\");\n  jsvUnLock2(scopeExports, jsvAddNamedChild(scope, scope, \"module\"));\n\n  JsExecFlags oldExecute = execInfo.execute;\n  JsVar *oldThisVar = execInfo.thisVar;\n  execInfo.thisVar = scopeExports; // set 'this' variable to exports\n  jsvUnLock(jspEvaluateVar(moduleContents, scope, 0));\n  execInfo.thisVar = oldThisVar;\n  execInfo.execute = oldExecute; // make sure we fully restore state after parsing a module\n\n  jsvUnLock2(moduleContents, scope);\n  return jsvSkipNameAndUnLock(exportsName);\n}\n\n/** Get the owner of the current prototype. We assume that it's\n * the first item in the array, because that's what we will\n * have added when we created it. It's safe to call this on\n * non-prototypes and non-objects.  */\nJsVar *jspGetPrototypeOwner(JsVar *proto) {\n  if (jsvIsObject(proto) || jsvIsArray(proto)) {\n    return jsvSkipNameAndUnLock(jsvObjectGetChild(proto, JSPARSE_CONSTRUCTOR_VAR, 0));\n  }\n  return 0;\n}\n", "/*\n * This file is part of Espruino, a JavaScript interpreter for Microcontrollers\n *\n * Copyright (C) 2013 Gordon Williams <gw@pur3.co.uk>\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n *\n * ----------------------------------------------------------------------------\n * Recursive descent parser for code execution\n * ----------------------------------------------------------------------------\n */\n#ifndef JSPARSE_H_\n#define JSPARSE_H_\n\n#include \"jsvar.h\"\n#include \"jslex.h\"\n\nvoid jspInit();\nvoid jspKill();\n\n// jspSoft* - 'release' or 'claim' anything we are using, but ensure that it doesn't get freed\nvoid jspSoftInit(); ///< used when recovering from or saving to flash\nvoid jspSoftKill(); ///< used when recovering from or saving to flash\n/** Returns true if the constructor function given is the same as that\n * of the object with the given name. */\nbool jspIsConstructor(JsVar *constructor, const char *constructorName);\n/** Get the prototype of the given object, or return 0 if not found, or not an object */\nJsVar *jspGetPrototype(JsVar *object);\n/** Get the constructor of the given object, or return 0 if ot found, or not a function */\nJsVar *jspGetConstructor(JsVar *object);\n\n/// Check that we have enough stack to recurse. Return true if all ok, error if not.\nbool jspCheckStackPosition();\n\n/// Create a new built-in object that jswrapper can use to check for built-in functions\nJsVar *jspNewBuiltin(const char *name);\n\n/// Create a new Class of the given instance and return its prototype\nNO_INLINE JsVar *jspNewPrototype(const char *instanceOf);\n\n/** Create a new object of the given instance and add it to root with name 'name'.\n * If name!=0, added to root with name, and the name is returned\n * If name==0, not added to root and Object itself returned */\nJsVar *jspNewObject(const char *name, const char *instanceOf);\n\n/// if interrupting execution, this is set\nbool jspIsInterrupted();\n/// if interrupting execution, this is set\nvoid jspSetInterrupted(bool interrupt);\n/// Has there been an error during parsing\nbool jspHasError();\n/// Set the error flag - set lineReported if we've already output the line number\nvoid jspSetError(bool lineReported);\n/// We had an exception (argument is the exception's value)\nvoid jspSetException(JsVar *value);\n/** Return the reported exception if there was one (and clear it) */\nJsVar *jspGetException();\n/** Return a stack trace string if there was one (and clear it) */\nJsVar *jspGetStackTrace();\n\n/** Evaluate the given variable as an expression (in current scope) */\nJsVar *jspEvaluateExpressionVar(JsVar *str);\n/** Execute code form a variable and return the result. If lineNumberOffset\n * is nonzero it's added to the line numbers that get reported for errors/debug */\nJsVar *jspEvaluateVar(JsVar *str, JsVar *scope, uint16_t lineNumberOffset);\n/** Execute code form a string and return the result.\n * You should only set stringIsStatic if the string will hang around for\n * the life of the interpreter, as then the interpreter will use a pointer\n * to this data, which could hang around inside the code. */\nJsVar *jspEvaluate(const char *str, bool stringIsStatic);\n/// Execute a JS function with the given arguments. usage: jspExecuteJSFunction(\"(function() { print('hi'); })\",0,0,0)\nJsVar *jspExecuteJSFunction(const char *jsCode, JsVar *thisArg, int argCount, JsVar **argPtr);\n/// Execute a function with the given arguments\nJsVar *jspExecuteFunction(JsVar *func, JsVar *thisArg, int argCount, JsVar **argPtr);\n\n/// Evaluate a JavaScript module and return its exports\nJsVar *jspEvaluateModule(JsVar *moduleContents);\n\n/** Get the owner of the current prototype. We assume that it's\n * the first item in the array, because that's what we will\n * have added when we created it. It's safe to call this on\n * non-prototypes and non-objects.  */\nJsVar *jspGetPrototypeOwner(JsVar *proto);\n\n/** When parsing, this enum defines whether\n we are executing or not */\ntypedef enum  {\n  EXEC_NO = 0,\n  EXEC_YES = 1,\n  EXEC_BREAK = 2,     ///< Have we had a 'break' keyword (so should skip to end of loop and exit)\n  EXEC_CONTINUE = 4,  ///< Have we had a 'continue' keywrord (so should skip to end of loop and restart)\n  EXEC_RETURN = 8,    ///< Have we had a 'return' keyword (so should skip to end of the function)\n\n  EXEC_INTERRUPTED = 16, ///< true if execution has been interrupted\n  EXEC_EXCEPTION = 32, ///< we had an exception, so don't execute until we hit a try/catch block\n  EXEC_ERROR = 64,\n  EXEC_ERROR_LINE_REPORTED = 128, ///< if an error has been reported, set this so we don't do it too much (EXEC_ERROR will STILL be set)\n\n  EXEC_FOR_INIT = 256, ///< when in for initialiser parsing - hack to avoid getting confused about multiple use for IN\n  EXEC_IN_LOOP = 512, ///< when in a loop, set this - we can then block break/continue outside it\n  EXEC_IN_SWITCH = 1024, ///< when in a switch, set this - we can then block break outside it/loops\n\n  /** If Ctrl-C is pressed, the EXEC_CTRL_C flag is set on an interrupt. The next time a SysTick\n   * happens, it sets EXEC_CTRL_C_WAIT, and if we get ANOTHER SysTick and it hasn't been handled,\n   * we go to a full-on EXEC_INTERRUPTED. That means we only interrupt code if we're actually stuck\n   * in something, and otherwise the console just clears the line. */\n  EXEC_CTRL_C = 2048, ///< If Ctrl-C was pressed, set this\n  EXEC_CTRL_C_WAIT = 4096, ///< If Ctrl-C was set and SysTick happens then this is set instead\n\n#ifdef USE_DEBUGGER\n  /** When the lexer hits a newline character, it'll then drop right\n   * into the debugger */\n  EXEC_DEBUGGER_NEXT_LINE = 8192,\n  /** Break when we execute a function */\n  EXEC_DEBUGGER_STEP_INTO = 16384,\n  /** Break when a function finishes execution */\n  EXEC_DEBUGGER_FINISH_FUNCTION = 32768,\n  EXEC_DEBUGGER_MASK = EXEC_DEBUGGER_NEXT_LINE | EXEC_DEBUGGER_STEP_INTO | EXEC_DEBUGGER_FINISH_FUNCTION,\n#endif\n\n  EXEC_RUN_MASK = EXEC_YES|EXEC_BREAK|EXEC_CONTINUE|EXEC_RETURN|EXEC_INTERRUPTED|EXEC_EXCEPTION,\n  EXEC_ERROR_MASK = EXEC_INTERRUPTED|EXEC_ERROR|EXEC_EXCEPTION, ///< here, we have an error, but unless EXEC_NO_PARSE, we should continue parsing but not executing\n  EXEC_NO_PARSE_MASK = EXEC_INTERRUPTED|EXEC_ERROR, ///< in these cases we should exit as fast as possible - skipping out of parsing\n  EXEC_SAVE_RESTORE_MASK = EXEC_YES|EXEC_BREAK|EXEC_CONTINUE|EXEC_RETURN|EXEC_IN_LOOP|EXEC_IN_SWITCH|EXEC_ERROR_MASK, ///< the things JSP_SAVE/RESTORE_EXECUTE should keep track of\n  EXEC_CTRL_C_MASK = EXEC_CTRL_C | EXEC_CTRL_C_WAIT, ///< Ctrl-C was pressed at some point\n  EXEC_PERSIST = EXEC_ERROR_MASK|EXEC_CTRL_C_MASK, ///< Things we should keep track of even after executing\n} JsExecFlags;\n\n/** This structure is used when parsing the JavaScript. It contains\n * everything that should be needed. */\ntypedef struct {\n  JsVar  *root;       //!< root of symbol table\n  JsVar  *hiddenRoot; //!< root of the symbol table that's hidden\n\n  /// JsVar array of scopes\n  JsVar *scopesVar;\n  /// Value of 'this' reserved word\n  JsVar *thisVar;\n\n  volatile JsExecFlags execute;\n} JsExecInfo;\n\n/* Info about execution when Parsing - this saves passing it on the stack\n * for each call */\nextern JsExecInfo execInfo;\n\n/// flags for jspParseFunction\ntypedef enum {\n  JSP_NOSKIP_A = 1,\n  JSP_NOSKIP_B = 2,\n  JSP_NOSKIP_C = 4,\n  JSP_NOSKIP_D = 8,\n  JSP_NOSKIP_E = 16,\n  JSP_NOSKIP_F = 32,\n  JSP_NOSKIP_G = 64,\n  JSP_NOSKIP_H = 128,\n} JspSkipFlags;\n\nbool jspParseEmptyFunction();    ///< parse function with no arguments\n\n/** Parse using current lexer until we hit the end of\n * input or there was some problem. */\nJsVar *jspParse();\n\n/** Handle a function call (assumes we've parsed the function name and we're\n * on the start bracket). 'thisArg' is the value of the 'this' variable when the\n * function is executed (it's usually the parent object).\n *\n * NOTE: this does not set the execInfo flags - so if execInfo==EXEC_NO, it won't execute\n *\n * If !isParsing and arg0!=0, argument 0 is set to what is supplied (same with arg1)\n *\n * functionName is used only for error reporting - and can be 0\n */\nJsVar *jspeFunctionCall(JsVar *function, JsVar *functionName, JsVar *thisArg, bool isParsing, int argCount, JsVar **argPtr);\n\n\n// Find a variable (or built-in function) based on the current scopes\nJsVar *jspGetNamedVariable(const char *tokenName);\n\n/** Get the named function/variable on the object - whether it's built in, or predefined.\n * If !returnName, returns the function/variable itself or undefined, but\n * if returnName, return a name (could be fake) referencing the parent.\n *\n * NOTE: ArrayBuffer/Strings are not handled here. We assume that if we're\n * passing a char* rather than a JsVar it's because we're looking up via\n * a symbol rather than a variable. To handle these use jspGetVarNamedField  */\nJsVar *jspGetNamedField(JsVar *object, const char* name, bool returnName);\nJsVar *jspGetVarNamedField(JsVar *object, JsVar *nameVar, bool returnName);\n\n/** Call the function named on the given object. For example you might call:\n *\n *  JsVar *str = jspCallNamedFunction(var, \"toString\", 0, 0);\n */\nJsVar *jspCallNamedFunction(JsVar *object, char* name, int argCount, JsVar **argPtr);\n\n\n// These are exported for the Web IDE's compiler. See exportPtrs in jswrap_process.c\nJsVar *jspeiFindInScopes(const char *name);\n\n/// Return the topmost scope (and lock it)\nJsVar *jspeiGetTopScope();\n\n#endif /* JSPARSE_H_ */\n", "/*\n * This file is part of Espruino, a JavaScript interpreter for Microcontrollers\n *\n * Copyright (C) 2013 Gordon Williams <gw@pur3.co.uk>\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n *\n * ----------------------------------------------------------------------------\n * Variables\n * ----------------------------------------------------------------------------\n */\n#include \"jsvar.h\"\n#include \"jslex.h\"\n#include \"jsparse.h\"\n#include \"jswrap_json.h\"\n#include \"jsinteractive.h\"\n#include \"jswrapper.h\"\n#include \"jswrap_math.h\" // for jswrap_math_mod\n#include \"jswrap_object.h\" // for jswrap_object_toString\n#include \"jswrap_arraybuffer.h\" // for jsvNewTypedArray\n#include \"jswrap_dataview.h\" // for jsvNewDataViewWithData\n\n#ifdef DEBUG\n  /** When freeing, clear the references (nextChild/etc) in the JsVar.\n   * This means we can assert at the end of jsvFreePtr to make sure\n   * everything really is free. */\n  #define CLEAR_MEMORY_ON_FREE\n#endif\n\n/** Basically, JsVars are stored in one big array, so save the need for\n * lots of memory allocation. On Linux, the arrays are in blocks, so that\n * more blocks can be allocated. We can't use realloc on one big block as\n * this may change the address of vars that are already locked!\n *\n */\n\n#ifdef RESIZABLE_JSVARS\nJsVar **jsVarBlocks = 0;\nunsigned int jsVarsSize = 0;\n#define JSVAR_BLOCK_SIZE 4096\n#define JSVAR_BLOCK_SHIFT 12\n#else\n#ifdef JSVAR_MALLOC\nunsigned int jsVarsSize = 0;\nJsVar *jsVars = NULL;\n#else\nJsVar jsVars[JSVAR_CACHE_SIZE] __attribute__((aligned(4)));\nunsigned int jsVarsSize = JSVAR_CACHE_SIZE;\n#endif\n#endif\n\ntypedef enum {\n  MEM_NOT_BUSY,\n  MEMBUSY_SYSTEM,\n  MEMBUSY_GC\n} MemBusyType;\n\nvolatile bool touchedFreeList = false;\nvolatile JsVarRef jsVarFirstEmpty; ///< reference of first unused variable (variables are in a linked list)\nvolatile MemBusyType isMemoryBusy; ///< Are we doing garbage collection or similar, so can't access memory?\n\n// ----------------------------------------------------------------------------\n// ----------------------------------------------------------------------------\n\nJsVarRef jsvGetFirstChild(const JsVar *v) { return v->varData.ref.firstChild; }\nJsVarRefSigned jsvGetFirstChildSigned(const JsVar *v) {\n  if (v->varData.ref.firstChild > JSVARREF_MAX)\n    return ((JsVarRefSigned)v->varData.ref.firstChild) + JSVARREF_MIN*2;\n  return (JsVarRefSigned)v->varData.ref.firstChild;\n}\nJsVarRef jsvGetLastChild(const JsVar *v) { return v->varData.ref.lastChild; }\nJsVarRef jsvGetNextSibling(const JsVar *v) { return v->varData.ref.nextSibling; }\nJsVarRef jsvGetPrevSibling(const JsVar *v) { return v->varData.ref.prevSibling; }\nvoid jsvSetFirstChild(JsVar *v, JsVarRef r) { v->varData.ref.firstChild = r; }\nvoid jsvSetLastChild(JsVar *v, JsVarRef r) { v->varData.ref.lastChild = r; }\nvoid jsvSetNextSibling(JsVar *v, JsVarRef r) { v->varData.ref.nextSibling = r; }\nvoid jsvSetPrevSibling(JsVar *v, JsVarRef r) { v->varData.ref.prevSibling = r; }\n\nJsVarRefCounter jsvGetRefs(JsVar *v) { return v->varData.ref.refs; }\nvoid jsvSetRefs(JsVar *v, JsVarRefCounter refs) { v->varData.ref.refs = refs; }\nunsigned char jsvGetLocks(JsVar *v) { return (unsigned char)((v->flags>>JSV_LOCK_SHIFT) & JSV_LOCK_MAX); }\n\nbool jsvIsRoot(const JsVar *v) { return v && (v->flags&JSV_VARTYPEMASK)==JSV_ROOT; }\nbool jsvIsPin(const JsVar *v) { return v && (v->flags&JSV_VARTYPEMASK)==JSV_PIN; }\nbool jsvIsSimpleInt(const JsVar *v) { return v && (v->flags&JSV_VARTYPEMASK)==JSV_INTEGER; } // is just a very basic integer value\nbool jsvIsInt(const JsVar *v) { return v && ((v->flags&JSV_VARTYPEMASK)==JSV_INTEGER || (v->flags&JSV_VARTYPEMASK)==JSV_PIN || (v->flags&JSV_VARTYPEMASK)==JSV_NAME_INT || (v->flags&JSV_VARTYPEMASK)==JSV_NAME_INT_INT || (v->flags&JSV_VARTYPEMASK)==JSV_NAME_INT_BOOL); }\nbool jsvIsFloat(const JsVar *v) { return v && (v->flags&JSV_VARTYPEMASK)==JSV_FLOAT; }\nbool jsvIsBoolean(const JsVar *v) { return v && ((v->flags&JSV_VARTYPEMASK)==JSV_BOOLEAN || (v->flags&JSV_VARTYPEMASK)==JSV_NAME_INT_BOOL); }\nbool jsvIsString(const JsVar *v) { return v && (v->flags&JSV_VARTYPEMASK)>=_JSV_STRING_START && (v->flags&JSV_VARTYPEMASK)<=_JSV_STRING_END; } ///< String, or a NAME too\nbool jsvIsBasicString(const JsVar *v) { return v && (v->flags&JSV_VARTYPEMASK)>=JSV_STRING_0 && (v->flags&JSV_VARTYPEMASK)<=JSV_STRING_MAX; } ///< Just a string (NOT a name/flatstr/nativestr or flashstr)\nbool jsvIsStringExt(const JsVar *v) { return v && (v->flags&JSV_VARTYPEMASK)>=JSV_STRING_EXT_0 && (v->flags&JSV_VARTYPEMASK)<=JSV_STRING_EXT_MAX; } ///< The extra bits dumped onto the end of a string to store more data\nbool jsvIsFlatString(const JsVar *v) { return v && (v->flags&JSV_VARTYPEMASK)==JSV_FLAT_STRING; }\nbool jsvIsNativeString(const JsVar *v) { return v && (v->flags&JSV_VARTYPEMASK)==JSV_NATIVE_STRING; }\nbool jsvIsFlashString(const JsVar *v) {\n#ifdef SPIFLASH_BASE\n  return v && (v->flags&JSV_VARTYPEMASK)==JSV_FLASH_STRING;\n#else\n  return false;\n#endif\n}\nbool jsvIsNumeric(const JsVar *v) { return v && (v->flags&JSV_VARTYPEMASK)>=_JSV_NUMERIC_START && (v->flags&JSV_VARTYPEMASK)<=_JSV_NUMERIC_END; }\nbool jsvIsFunction(const JsVar *v) { return v && ((v->flags&JSV_VARTYPEMASK)==JSV_FUNCTION || (v->flags&JSV_VARTYPEMASK)==JSV_FUNCTION_RETURN || (v->flags&JSV_VARTYPEMASK)==JSV_NATIVE_FUNCTION); }\nbool jsvIsFunctionReturn(const JsVar *v) { return v && ((v->flags&JSV_VARTYPEMASK)==JSV_FUNCTION_RETURN); } ///< Is this a function with an implicit 'return' at the start?\nbool jsvIsFunctionParameter(const JsVar *v) { return v && (v->flags&JSV_NATIVE) && jsvIsString(v); }\nbool jsvIsObject(const JsVar *v) { return v && (((v->flags&JSV_VARTYPEMASK)==JSV_OBJECT) || ((v->flags&JSV_VARTYPEMASK)==JSV_ROOT)); }\nbool jsvIsArray(const JsVar *v) { return v && (v->flags&JSV_VARTYPEMASK)==JSV_ARRAY; }\nbool jsvIsArrayBuffer(const JsVar *v) { return v && (v->flags&JSV_VARTYPEMASK)==JSV_ARRAYBUFFER; }\nbool jsvIsArrayBufferName(const JsVar *v) { return v && (v->flags&(JSV_VARTYPEMASK))==JSV_ARRAYBUFFERNAME; }\nbool jsvIsNativeFunction(const JsVar *v) { return v && (v->flags&(JSV_VARTYPEMASK))==JSV_NATIVE_FUNCTION; }\nbool jsvIsUndefined(const JsVar *v) { return v==0; }\nbool jsvIsNull(const JsVar *v) { return v && (v->flags&JSV_VARTYPEMASK)==JSV_NULL; }\nbool jsvIsBasic(const JsVar *v) { return jsvIsNumeric(v) || jsvIsString(v);} ///< Is this *not* an array/object/etc\nbool jsvIsName(const JsVar *v) { return v && (v->flags&JSV_VARTYPEMASK)>=_JSV_NAME_START && (v->flags&JSV_VARTYPEMASK)<=_JSV_NAME_END; } ///< NAMEs are what's used to name a variable (it is not the data itself)\nbool jsvIsBasicName(const JsVar *v) { return v && (v->flags&JSV_VARTYPEMASK)>=JSV_NAME_STRING_0 && (v->flags&JSV_VARTYPEMASK)<=JSV_NAME_STRING_MAX; } ///< Simple NAME that links to a variable via firstChild\n/// Names with values have firstChild set to a value - AND NOT A REFERENCE\nbool jsvIsNameWithValue(const JsVar *v) { return v && (v->flags&JSV_VARTYPEMASK)>=_JSV_NAME_WITH_VALUE_START && (v->flags&JSV_VARTYPEMASK)<=_JSV_NAME_WITH_VALUE_END; }\nbool jsvIsNameInt(const JsVar *v) { return v && ((v->flags&JSV_VARTYPEMASK)==JSV_NAME_INT_INT || ((v->flags&JSV_VARTYPEMASK)>=JSV_NAME_STRING_INT_0 && (v->flags&JSV_VARTYPEMASK)<=JSV_NAME_STRING_INT_MAX)); } ///< Is this a NAME pointing to an Integer value\nbool jsvIsNameIntInt(const JsVar *v) { return v && (v->flags&JSV_VARTYPEMASK)==JSV_NAME_INT_INT; }\nbool jsvIsNameIntBool(const JsVar *v) { return v && (v->flags&JSV_VARTYPEMASK)==JSV_NAME_INT_BOOL; }\n/// What happens when we access a variable that doesn't exist. We get a NAME where the next + previous siblings point to the object that may one day contain them\nbool jsvIsNewChild(const JsVar *v) { return jsvIsName(v) && jsvGetNextSibling(v) && jsvGetNextSibling(v)==jsvGetPrevSibling(v); }\n/// Returns true if v is a getter/setter\nbool jsvIsGetterOrSetter(const JsVar *v) {\n#ifdef SAVE_ON_FLASH\n  return false;\n#else\n  return v && (v->flags&JSV_VARTYPEMASK)==JSV_GET_SET;\n#endif\n}\n/// Are var.varData.ref.* (excl pad) used for data (so we expect them not to be empty)\nbool jsvIsRefUsedForData(const JsVar *v) { return jsvIsStringExt(v) || (jsvIsString(v)&&!jsvIsName(v)) ||  jsvIsFloat(v) || jsvIsNativeFunction(v) || jsvIsArrayBuffer(v) || jsvIsArrayBufferName(v); }\n\n/// Can the given variable be converted into an integer without loss of precision\nbool jsvIsIntegerish(const JsVar *v) { return jsvIsInt(v) || jsvIsPin(v) || jsvIsBoolean(v) || jsvIsNull(v); }\n\nbool jsvIsIterable(const JsVar *v) {\n  return jsvIsArray(v) || jsvIsObject(v) || jsvIsFunction(v) ||\n         jsvIsString(v) || jsvIsArrayBuffer(v);\n}\n\n// ----------------------------------------------------------------------------\n// ----------------------------------------------------------------------------\n\n\n/** Return a pointer - UNSAFE for null refs.\n * This is effectively a Lock without locking! */\nstatic ALWAYS_INLINE JsVar *jsvGetAddressOf(JsVarRef ref) {\n  assert(ref);\n#ifdef RESIZABLE_JSVARS\n  assert(ref <= jsVarsSize);\n  JsVarRef t = ref-1;\n  return &jsVarBlocks[t>>JSVAR_BLOCK_SHIFT][t&(JSVAR_BLOCK_SIZE-1)];\n#elif defined(JSVAR_MALLOC)\n  assert(ref <= jsVarsSize);\n  return &jsVars[ref-1];\n#else\n  assert(ref <= JSVAR_CACHE_SIZE);\n  return &jsVars[ref-1];\n#endif\n}\n\nJsVar *_jsvGetAddressOf(JsVarRef ref) {\n  return jsvGetAddressOf(ref);\n}\n\n// For debugging/testing ONLY - maximum # of vars we are allowed to use\nvoid jsvSetMaxVarsUsed(unsigned int size) {\n#ifdef RESIZABLE_JSVARS\n  assert(size < JSVAR_BLOCK_SIZE); // remember - this is only for DEBUGGING - as such it doesn't use multiple blocks\n#else\n  assert(size < JSVAR_CACHE_SIZE);\n#endif\n  jsVarsSize = size;\n}\n\n// maps the empty variables in...\nvoid jsvCreateEmptyVarList() {\n  assert(!isMemoryBusy);\n  isMemoryBusy = MEMBUSY_SYSTEM;\n  jsVarFirstEmpty = 0;\n  JsVar firstVar; // temporary var to simplify code in the loop below\n  jsvSetNextSibling(&firstVar, 0);\n  JsVar *lastEmpty = &firstVar;\n\n  JsVarRef i;\n  for (i=1;i<=jsVarsSize;i++) {\n    JsVar *var = jsvGetAddressOf(i);\n    if ((var->flags&JSV_VARTYPEMASK) == JSV_UNUSED) {\n      jsvSetNextSibling(lastEmpty, i);\n      lastEmpty = var;\n    } else if (jsvIsFlatString(var)) {\n      // skip over used blocks for flat strings\n      i = (JsVarRef)(i+jsvGetFlatStringBlocks(var));\n    }\n  }\n  jsvSetNextSibling(lastEmpty, 0);\n  jsVarFirstEmpty = jsvGetNextSibling(&firstVar);\n  isMemoryBusy = MEM_NOT_BUSY;\n}\n\n/* Removes the empty variable counter, cleaving clear runs of 0s\n where no data resides. This helps if compressing the variables\n for storage. */\nvoid jsvClearEmptyVarList() {\n  assert(!isMemoryBusy);\n  isMemoryBusy = MEMBUSY_SYSTEM;\n  jsVarFirstEmpty = 0;\n  JsVarRef i;\n  for (i=1;i<=jsVarsSize;i++) {\n    JsVar *var = jsvGetAddressOf(i);\n    if ((var->flags&JSV_VARTYPEMASK) == JSV_UNUSED) {\n      // completely zero it (JSV_UNUSED==0, so it still stays the same)\n      memset((void*)var,0,sizeof(JsVar));\n    } else if (jsvIsFlatString(var)) {\n      // skip over used blocks for flat strings\n      i = (JsVarRef)(i+jsvGetFlatStringBlocks(var));\n    }\n  }\n  isMemoryBusy = MEM_NOT_BUSY;\n}\n\nvoid jsvSoftInit() {\n  jsvCreateEmptyVarList();\n}\n\nvoid jsvSoftKill() {\n  jsvClearEmptyVarList();\n}\n\n/** This links all JsVars together, so we can have our nice\n * linked list of free JsVars. It returns the ref of the first\n * item - that we should set jsVarFirstEmpty to (if it is 0) */\nstatic JsVarRef jsvInitJsVars(JsVarRef start, unsigned int count) {\n  JsVarRef i;\n  for (i=start;i<start+count;i++) {\n    JsVar *v = jsvGetAddressOf(i);\n    v->flags = JSV_UNUSED;\n    // v->locks = 0; // locks is 0 anyway because it is stored in flags\n    jsvSetNextSibling(v, (JsVarRef)(i+1)); // link to next\n  }\n  jsvSetNextSibling(jsvGetAddressOf((JsVarRef)(start+count-1)), (JsVarRef)0); // set the final one to 0\n  return start;\n}\n\nvoid jsvInit(unsigned int size) {\n#ifdef RESIZABLE_JSVARS\n  assert(size==0);\n  jsVarsSize = JSVAR_BLOCK_SIZE;\n  jsVarBlocks = malloc(sizeof(JsVar*)); // just 1\n  jsVarBlocks[0] = malloc(sizeof(JsVar) * JSVAR_BLOCK_SIZE);\n#elif defined(JSVAR_MALLOC)\n  if (size) jsVarsSize = size;\n  if(!jsVars) jsVars = (JsVar *)malloc(sizeof(JsVar) * jsVarsSize);\n#else\n  assert(size==0);\n#endif\n\n  jsVarFirstEmpty = jsvInitJsVars(1/*first*/, jsVarsSize);\n  jsvSoftInit();\n}\n\nvoid jsvKill() {\n#ifdef RESIZABLE_JSVARS\n  unsigned int i;\n  for (i=0;i<jsVarsSize>>JSVAR_BLOCK_SHIFT;i++)\n    free(jsVarBlocks[i]);\n  free(jsVarBlocks);\n  jsVarBlocks = 0;\n  jsVarsSize = 0;\n#endif\n}\n\n/** Find or create the ROOT variable item - used mainly\n * if recovering from a saved state. */\nJsVar *jsvFindOrCreateRoot() {\n  JsVarRef i;\n  for (i=1;i<=jsVarsSize;i++)\n    if (jsvIsRoot(jsvGetAddressOf(i)))\n      return jsvLock(i);\n\n  return jsvRef(jsvNewWithFlags(JSV_ROOT));\n}\n\n/// Get number of memory records (JsVars) used\nunsigned int jsvGetMemoryUsage() {\n  unsigned int usage = 0;\n  for (unsigned int i=1;i<=jsVarsSize;i++) {\n    JsVar *v = jsvGetAddressOf((JsVarRef)i);\n    if ((v->flags&JSV_VARTYPEMASK) != JSV_UNUSED) {\n      usage++;\n      if (jsvIsFlatString(v)) {\n        unsigned int b = (unsigned int)jsvGetFlatStringBlocks(v);\n        i+=b;\n        usage+=b;\n      }\n    }\n  }\n  return usage;\n}\n\n/// Get total amount of memory records\nunsigned int jsvGetMemoryTotal() {\n  return jsVarsSize;\n}\n\n/// Try and allocate more memory - only works if RESIZABLE_JSVARS is defined\nvoid jsvSetMemoryTotal(unsigned int jsNewVarCount) {\n#ifdef RESIZABLE_JSVARS\n  assert(!isMemoryBusy);\n  if (jsNewVarCount <= jsVarsSize) return; // never allow us to have less!\n  isMemoryBusy = MEMBUSY_SYSTEM;\n  // When resizing, we just allocate a bunch more\n  unsigned int oldSize = jsVarsSize;\n  unsigned int oldBlockCount = jsVarsSize >> JSVAR_BLOCK_SHIFT;\n  unsigned int newBlockCount = (jsNewVarCount+JSVAR_BLOCK_SIZE-1) >> JSVAR_BLOCK_SHIFT;\n  jsVarsSize = newBlockCount << JSVAR_BLOCK_SHIFT;\n  // resize block table\n  jsVarBlocks = realloc(jsVarBlocks, sizeof(JsVar*)*newBlockCount);\n  // allocate more blocks\n  unsigned int i;\n  for (i=oldBlockCount;i<newBlockCount;i++)\n    jsVarBlocks[i] = malloc(sizeof(JsVar) * JSVAR_BLOCK_SIZE);\n  /** and now reset all the newly allocated vars. We know jsVarFirstEmpty\n   * is 0 (because jsiFreeMoreMemory returned 0) so we can just assign it.  */\n  assert(!jsVarFirstEmpty);\n  jsVarFirstEmpty = jsvInitJsVars(oldSize+1, jsVarsSize-oldSize);\n  // jsiConsolePrintf(\"Resized memory from %d blocks to %d\\n\", oldBlockCount, newBlockCount);\n  touchedFreeList = true;\n  isMemoryBusy = MEM_NOT_BUSY;\n#else\n  NOT_USED(jsNewVarCount);\n  assert(0);\n#endif\n}\n\n/// Scan memory to find any JsVar that references a specific memory range, and if so update what it points to to p[oint to the new address\nvoid jsvUpdateMemoryAddress(size_t oldAddr, size_t length, size_t newAddr) {\n  for (unsigned int i=1;i<=jsVarsSize;i++) {\n    JsVar *v = jsvGetAddressOf((JsVarRef)i);\n    if (jsvIsNativeString(v) || jsvIsFlashString(v)) {\n      size_t p = (size_t)v->varData.nativeStr.ptr;\n      if (p>=oldAddr && p<oldAddr+length)\n        v->varData.nativeStr.ptr = (char*)(p+newAddr-oldAddr);\n    } else if (jsvIsFlatString(v)) {\n      i += (unsigned int)jsvGetFlatStringBlocks(v);\n    }\n  }\n}\n\nbool jsvMoreFreeVariablesThan(unsigned int vars) {\n  if (!vars) return false;\n  JsVarRef r = jsVarFirstEmpty;\n  while (r) {\n    if (!vars--) return true;\n    r = jsvGetNextSibling(jsvGetAddressOf(r));\n  }\n  return false;\n}\n\n/// Get whether memory is full or not\nbool jsvIsMemoryFull() {\n  return !jsVarFirstEmpty;\n}\n\n// Show what is still allocated, for debugging memory problems\nvoid jsvShowAllocated() {\n  JsVarRef i;\n  for (i=1;i<=jsVarsSize;i++) {\n    if ((jsvGetAddressOf(i)->flags&JSV_VARTYPEMASK) != JSV_UNUSED) {\n      jsiConsolePrintf(\"USED VAR #%d:\",i);\n      jsvTrace(jsvGetAddressOf(i), 2);\n    }\n  }\n}\n\nbool jsvHasCharacterData(const JsVar *v) {\n  return jsvIsString(v) || jsvIsStringExt(v);\n}\n\nbool jsvHasStringExt(const JsVar *v) {\n  return jsvIsString(v) || jsvIsStringExt(v);\n}\n\nbool jsvHasChildren(const JsVar *v) {\n  return jsvIsFunction(v) || jsvIsObject(v) || jsvIsArray(v) || jsvIsRoot(v) || jsvIsGetterOrSetter(v);\n}\n\n/// Is this variable a type that uses firstChild to point to a single Variable (ie. it doesn't have multiple children)\nbool jsvHasSingleChild(const JsVar *v) {\n  return jsvIsArrayBuffer(v) ||\n      (jsvIsName(v) && !jsvIsNameWithValue(v));\n}\n\n/** Return the is the number of characters this one JsVar can contain, NOT string length (eg, a chain of JsVars)\n * This will return an invalid length when applied to Flat Strings */\nsize_t jsvGetMaxCharactersInVar(const JsVar *v) {\n  // see jsvCopy - we need to know about this in there too\n  if (jsvIsStringExt(v)) return JSVAR_DATA_STRING_MAX_LEN;\n  assert(jsvHasCharacterData(v));\n  if (jsvIsName(v)) return JSVAR_DATA_STRING_NAME_LEN;\n  return JSVAR_DATA_STRING_LEN;\n}\n\n/// This is the number of characters a JsVar can contain, NOT string length\nsize_t jsvGetCharactersInVar(const JsVar *v) {\n  unsigned int f = v->flags&JSV_VARTYPEMASK;\n  if (f == JSV_FLAT_STRING)\n    return (size_t)v->varData.integer;\n  if ((f == JSV_NATIVE_STRING)\n#ifdef SPIFLASH_BASE\n  || (f == JSV_FLASH_STRING)\n#endif\n      )\n    return (size_t)v->varData.nativeStr.len;\n\n  assert(f >= JSV_NAME_STRING_INT_0);\n  assert((JSV_NAME_STRING_INT_0 < JSV_NAME_STRING_0) &&\n         (JSV_NAME_STRING_0 < JSV_STRING_0) &&\n         (JSV_STRING_0 < JSV_STRING_EXT_0)); // this relies on ordering\n  if (f<=JSV_NAME_STRING_MAX) {\n    if (f<=JSV_NAME_STRING_INT_MAX)\n      return f-JSV_NAME_STRING_INT_0;\n    else\n      return f-JSV_NAME_STRING_0;\n  } else {\n    if (f<=JSV_STRING_MAX) return f-JSV_STRING_0;\n    assert(f <= JSV_STRING_EXT_MAX);\n    return f - JSV_STRING_EXT_0;\n  }\n}\n\n/// This is the number of characters a JsVar can contain, NOT string length\nvoid jsvSetCharactersInVar(JsVar *v, size_t chars) {\n  unsigned int f = v->flags&JSV_VARTYPEMASK;\n  assert(!(jsvIsFlatString(v) || jsvIsNativeString(v) || jsvIsFlashString(v)));\n\n  JsVarFlags m = (JsVarFlags)(v->flags&~JSV_VARTYPEMASK);\n  assert(f >= JSV_NAME_STRING_INT_0);\n  assert((JSV_NAME_STRING_INT_0 < JSV_NAME_STRING_0) &&\n         (JSV_NAME_STRING_0 < JSV_STRING_0) &&\n         (JSV_STRING_0 < JSV_STRING_EXT_0)); // this relies on ordering\n  if (f<=JSV_NAME_STRING_MAX) {\n    assert(chars <= JSVAR_DATA_STRING_NAME_LEN);\n    if (f<=JSV_NAME_STRING_INT_MAX)\n      v->flags = (JsVarFlags)(m | (JSV_NAME_STRING_INT_0+chars));\n    else\n      v->flags = (JsVarFlags)(m | (JSV_NAME_STRING_0+chars));\n  } else {\n    if (f<=JSV_STRING_MAX) {\n      assert(chars <= JSVAR_DATA_STRING_LEN);\n      v->flags = (JsVarFlags)(m | (JSV_STRING_0+chars));\n    } else {\n      assert(chars <= JSVAR_DATA_STRING_MAX_LEN);\n      assert(f <= JSV_STRING_EXT_MAX);\n      v->flags = (JsVarFlags)(m | (JSV_STRING_EXT_0+chars));\n    }\n  }\n}\n\nvoid jsvResetVariable(JsVar *v, JsVarFlags flags) {\n  assert((v->flags&JSV_VARTYPEMASK) == JSV_UNUSED);\n  // make sure we clear all data...\n  /* Force a proper zeroing of all data. We don't use\n   * memset because that'd create a function call. This\n   * should just generate a bunch of STR instructions */\n  unsigned int i;\n  if ((sizeof(JsVar)&3) == 0) {\n    for (i=0;i<sizeof(JsVar)/sizeof(uint32_t);i++)\n      ((uint32_t*)v)[i] = 0;\n  } else { // just fall back to bytes and hope it's smart enough\n    for (i=0;i<sizeof(JsVar);i++)\n      ((uint8_t*)v)[i] = 0;\n  }\n  // set flags\n  assert(!(flags & JSV_LOCK_MASK));\n  v->flags = flags | JSV_LOCK_ONE;\n}\n\nJsVar *jsvNewWithFlags(JsVarFlags flags) {\n  if (isMemoryBusy) {\n    jsErrorFlags |= JSERR_MEMORY_BUSY;\n    return 0;\n  }\n  JsVar *v = 0;\n  jshInterruptOff(); // to allow this to be used from an IRQ\n  if (jsVarFirstEmpty!=0) {\n    v = jsvGetAddressOf(jsVarFirstEmpty); // jsvResetVariable will lock\n    jsVarFirstEmpty = jsvGetNextSibling(v); // move our reference to the next in the free list\n    touchedFreeList = true;\n  }\n  jshInterruptOn();\n  if (v) {\n    assert(v->flags == JSV_UNUSED);\n    // Cope with IRQs/multi-threading when getting a new free variable\n /*   JsVarRef empty;\n    JsVarRef next;\n    JsVar *v;\n    do {\n      empty = jsVarFirstEmpty;\n      v = jsvGetAddressOf(empty); // jsvResetVariable will lock\n      next = jsvGetNextSibling(v); // move our reference to the next in the free list\n      touchedFreeList = true;\n    } while (!__sync_bool_compare_and_swap(&jsVarFirstEmpty, empty, next));\n    assert(v->flags == JSV_UNUSED);*/\n    jsvResetVariable(v, flags); // setup variable, and add one lock\n    // return pointer\n    return v;\n  }\n  jsErrorFlags |= JSERR_LOW_MEMORY;\n  /* If we're calling from an IRQ, do NOT try and do fancy\n   * stuff to free memory */\n  if (jshIsInInterrupt()) {\n    return 0;\n  }\n  /* we don't have memory - second last hope - run garbage collector */\n  if (jsvGarbageCollect()) {\n    return jsvNewWithFlags(flags); // if it freed something, continue\n  }\n  /* we don't have memory - last hope - ask jsInteractive to try and free some it\n   may have kicking around */\n  if (jsiFreeMoreMemory()) {\n    return jsvNewWithFlags(flags);\n  }\n  /* We couldn't claim any more memory by Garbage collecting... */\n#ifdef RESIZABLE_JSVARS\n  jsvSetMemoryTotal(jsVarsSize*2);\n  return jsvNewWithFlags(flags);\n#else\n  // On a micro, we're screwed.\n  jsErrorFlags |= JSERR_MEMORY;\n  jspSetInterrupted(true);\n  return 0;\n#endif\n}\n\nstatic void jsvFreePtrInternal(JsVar *var) {\n  assert(jsvGetLocks(var)==0);\n  var->flags = JSV_UNUSED;\n  // add this to our free list\n  jshInterruptOff(); // to allow this to be used from an IRQ\n  jsvSetNextSibling(var, jsVarFirstEmpty);\n  jsVarFirstEmpty = jsvGetRef(var);\n  touchedFreeList = true;\n  jshInterruptOn();\n}\n\nALWAYS_INLINE void jsvFreePtr(JsVar *var) {\n  /* To be here, we're not supposed to be part of anything else. If\n   * we were, we'd have been freed by jsvGarbageCollect */\n  assert((!jsvGetNextSibling(var) && !jsvGetPrevSibling(var)) || // check that next/prevSibling are not set\n      jsvIsRefUsedForData(var) ||  // UNLESS we're part of a string and nextSibling/prevSibling are used for string data\n      (jsvIsName(var) && (jsvGetNextSibling(var)==jsvGetPrevSibling(var)))); // UNLESS we're signalling that we're jsvild\n\n  // Names that Link to other things\n  if (jsvIsNameWithValue(var)) {\n#ifdef CLEAR_MEMORY_ON_FREE\n    jsvSetFirstChild(var, 0); // it just contained random data - zero it\n#endif // CLEAR_MEMORY_ON_FREE\n  } else if (jsvHasSingleChild(var)) {\n    if (jsvGetFirstChild(var)) {\n      JsVar *child = jsvLock(jsvGetFirstChild(var));\n      jsvUnRef(child);\n#ifdef CLEAR_MEMORY_ON_FREE\n      jsvSetFirstChild(var, 0); // unlink the child\n#endif // CLEAR_MEMORY_ON_FREE\n      jsvUnLock(child); // unlock should trigger a free\n    }\n  }\n  /* No else, because a String Name may have a single child, but\n   * also StringExts  */\n\n  /* Now, free children - see jsvar.h comments for how! */\n  if (jsvHasStringExt(var)) {\n    // Free the string without recursing\n    JsVarRef stringDataRef = jsvGetLastChild(var);\n#ifdef CLEAR_MEMORY_ON_FREE\n    jsvSetLastChild(var, 0);\n#endif // CLEAR_MEMORY_ON_FREE\n    while (stringDataRef) {\n      JsVar *child = jsvGetAddressOf(stringDataRef);\n      assert(jsvIsStringExt(child));\n      stringDataRef = jsvGetLastChild(child);\n      jsvFreePtrInternal(child);\n    }\n    // We might be a flat string\n    if (jsvIsFlatString(var)) {\n      // in which case we need to free all the blocks.\n      size_t count = jsvGetFlatStringBlocks(var);\n      JsVarRef i = (JsVarRef)(jsvGetRef(var)+count);\n      // Because this is a whole bunch of blocks, try\n      // and insert it in the right place in the free list\n      // So, iterate along free list to figure out where we\n      // need to insert the free items\n      jshInterruptOff(); // to allow this to be used from an IRQ\n      JsVarRef insertBefore = jsVarFirstEmpty;\n      JsVarRef insertAfter = 0;\n      while (insertBefore && insertBefore<i) {\n        insertAfter = insertBefore;\n        insertBefore = jsvGetNextSibling(jsvGetAddressOf(insertBefore));\n      }\n      // free in reverse, so the free list ends up in kind of the right order\n      while (count--) {\n        JsVar *p = jsvGetAddressOf(i--);\n        p->flags = JSV_UNUSED; // set locks to 0 so the assert in jsvFreePtrInternal doesn't get fed up\n        // add this to our free list\n        jsvSetNextSibling(p, insertBefore);\n        insertBefore = jsvGetRef(p);\n      }\n      // patch up jsVarFirstEmpty/rejoin the list\n      if (insertAfter)\n        jsvSetNextSibling(jsvGetAddressOf(insertAfter), insertBefore);\n      else\n        jsVarFirstEmpty = insertBefore;\n      touchedFreeList = true;\n      jshInterruptOn();\n    } else if (jsvIsBasicString(var)) {\n#ifdef CLEAR_MEMORY_ON_FREE\n      jsvSetFirstChild(var, 0); // firstchild could have had string data in\n#endif // CLEAR_MEMORY_ON_FREE\n    }\n\n  }\n  /* NO ELSE HERE - because jsvIsNewChild stuff can be for Names, which\n    can be ints or strings */\n\n  if (jsvHasChildren(var)) {\n    JsVarRef childref = jsvGetFirstChild(var);\n#ifdef CLEAR_MEMORY_ON_FREE\n    jsvSetFirstChild(var, 0);\n    jsvSetLastChild(var, 0);\n#endif // CLEAR_MEMORY_ON_FREE\n    while (childref) {\n      JsVar *child = jsvLock(childref);\n      assert(jsvIsName(child));\n      childref = jsvGetNextSibling(child);\n      jsvSetPrevSibling(child, 0);\n      jsvSetNextSibling(child, 0);\n      jsvUnRef(child);\n      jsvUnLock(child);\n    }\n  } else {\n#ifdef CLEAR_MEMORY_ON_FREE\n    assert(jsvIsFloat(var) || !jsvGetFirstChild(var));\n    assert(jsvIsFloat(var) || !jsvGetLastChild(var));\n#endif // CLEAR_MEMORY_ON_FREE\n    if (jsvIsName(var)) {\n      assert(jsvGetNextSibling(var)==jsvGetPrevSibling(var)); // the case for jsvIsNewChild\n      if (jsvGetNextSibling(var)) {\n        jsvUnRefRef(jsvGetNextSibling(var));\n        jsvUnRefRef(jsvGetPrevSibling(var));\n      }\n    }\n  }\n\n  // free!\n  jsvFreePtrInternal(var);\n}\n\n/// Get a reference from a var - SAFE for null vars\nJsVarRef jsvGetRef(JsVar *var) {\n  if (!var) return 0;\n#ifdef RESIZABLE_JSVARS\n  unsigned int i, c = jsVarsSize>>JSVAR_BLOCK_SHIFT;\n  for (i=0;i<c;i++) {\n    if (var>=jsVarBlocks[i] && var<&jsVarBlocks[i][JSVAR_BLOCK_SIZE]) {\n      JsVarRef r = (JsVarRef)(1 + (i<<JSVAR_BLOCK_SHIFT) + (var - jsVarBlocks[i]));\n      return r;\n    }\n  }\n  return 0;\n#else\n  return (JsVarRef)(1 + (var - jsVars));\n#endif\n}\n\n/// Lock this reference and return a pointer - UNSAFE for null refs\nJsVar *jsvLock(JsVarRef ref) {\n  JsVar *var = jsvGetAddressOf(ref);\n  //var->locks++;\n  assert(jsvGetLocks(var) < JSV_LOCK_MAX);\n  var->flags += JSV_LOCK_ONE;\n#ifdef DEBUG\n  if (jsvGetLocks(var)==0) {\n    jsError(\"Too many locks to Variable!\");\n    //jsPrint(\"Var #\");jsPrintInt(ref);jsPrint(\"\\n\");\n  }\n#endif\n  return var;\n}\n\n/// Lock this reference and return a pointer - UNSAFE for null refs\nJsVar *jsvLockSafe(JsVarRef ref) {\n  if (!ref) return 0;\n  return jsvLock(ref);\n}\n\n/// Lock this pointer and return a pointer - UNSAFE for null pointer\nJsVar *jsvLockAgain(JsVar *var) {\n  assert(var);\n  assert(jsvGetLocks(var) < JSV_LOCK_MAX);\n  var->flags += JSV_LOCK_ONE;\n  return var;\n}\n\n/// Lock this pointer and return a pointer - UNSAFE for null pointer\nJsVar *jsvLockAgainSafe(JsVar *var) {\n  return var ? jsvLockAgain(var) : 0;\n}\n\n// CALL ONLY FROM jsvUnlock\n// jsvGetLocks(var) must == 0\nstatic NO_INLINE void jsvUnLockFreeIfNeeded(JsVar *var) {\n  assert(jsvGetLocks(var) == 0);\n  /* if we know we're free, then we can just free this variable right now.\n   * Loops of variables are handled by the Garbage Collector.\n   * Note: we checked locks already in jsvUnLock as it is fastest to check */\n  if (jsvGetRefs(var) == 0 &&\n      jsvHasRef(var) &&\n      (var->flags&JSV_VARTYPEMASK)!=JSV_UNUSED) { // we might be in an IRQ now, with GC in the main thread. If so, don't free!\n    jsvFreePtr(var);\n  }\n}\n\n\n/// Unlock this variable - this is SAFE for null variables\nvoid jsvUnLock(JsVar *var) {\n  if (!var) return;\n  assert(jsvGetLocks(var)>0);\n  var->flags -= JSV_LOCK_ONE;\n  // Now see if we can properly free the data\n  // Note: we check locks first as they are already in a register\n  if ((var->flags & JSV_LOCK_MASK) == 0) jsvUnLockFreeIfNeeded(var);\n}\n\n/// Unlock 2 variables in one go\nvoid jsvUnLock2(JsVar *var1, JsVar *var2) {\n  jsvUnLock(var1);\n  jsvUnLock(var2);\n}\n/// Unlock 3 variables in one go\nvoid jsvUnLock3(JsVar *var1, JsVar *var2, JsVar *var3) {\n  jsvUnLock(var1);\n  jsvUnLock(var2);\n  jsvUnLock(var3);\n}\n/// Unlock 4 variables in one go\nvoid jsvUnLock4(JsVar *var1, JsVar *var2, JsVar *var3, JsVar *var4) {\n  jsvUnLock(var1);\n  jsvUnLock(var2);\n  jsvUnLock(var3);\n  jsvUnLock(var4);\n}\n\n/// Unlock an array of variables\nNO_INLINE void jsvUnLockMany(unsigned int count, JsVar **vars) {\n  while (count) jsvUnLock(vars[--count]);\n}\n\n/// Reference - set this variable as used by something\nJsVar *jsvRef(JsVar *var) {\n  assert(var && jsvHasRef(var));\n  if (jsvGetRefs(var) < JSVARREFCOUNT_MAX) // if we hit max refcounts, just keep them - GC will fix it later\n    jsvSetRefs(var, (JsVarRefCounter)(jsvGetRefs(var)+1));\n  assert(jsvGetRefs(var));\n  return var;\n}\n\n/// Unreference - set this variable as not used by anything\nvoid jsvUnRef(JsVar *var) {\n  assert(var && jsvGetRefs(var)>0 && jsvHasRef(var));\n  if (jsvGetRefs(var) < JSVARREFCOUNT_MAX) // if we hit max refcounts, just keep them - GC will fix it later\n    jsvSetRefs(var, (JsVarRefCounter)(jsvGetRefs(var)-1));\n}\n\n/// Helper fn, Reference - set this variable as used by something\nJsVarRef jsvRefRef(JsVarRef ref) {\n  JsVar *v;\n  assert(ref);\n  v = jsvLock(ref);\n  assert(!jsvIsStringExt(v));\n  jsvRef(v);\n  jsvUnLock(v);\n  return ref;\n}\n\n/// Helper fn, Unreference - set this variable as not used by anything\nJsVarRef jsvUnRefRef(JsVarRef ref) {\n  JsVar *v;\n  assert(ref);\n  v = jsvLock(ref);\n  assert(!jsvIsStringExt(v));\n  jsvUnRef(v);\n  jsvUnLock(v);\n  return 0;\n}\n\nJsVar *jsvNewFlatStringOfLength(unsigned int byteLength) {\n  bool firstRun = true;\n  // Work out how many blocks we need. One for the header, plus some for the characters\n  size_t requiredBlocks = 1 + ((byteLength+sizeof(JsVar)-1) / sizeof(JsVar));\n  JsVar *flatString = 0;\n  if (isMemoryBusy) {\n    jsErrorFlags |= JSERR_MEMORY_BUSY;\n    return 0;\n  }\n  while (true) {\n    /* Now try and find a contiguous set of 'requiredBlocks' blocks by\n    searching the free list. This can be done as long as nobody's\n    messed with the free list in the mean time (which we check for with\n    touchedFreeList). If someone has messed with it, we restart.*/\n    bool memoryTouched = true;\n    while (memoryTouched) {\n      memoryTouched = false;\n      touchedFreeList = false;\n      JsVarRef beforeStartBlock = 0;\n      JsVarRef curr = jsVarFirstEmpty;\n      JsVarRef startBlock = curr;\n      unsigned int blockCount = 0;\n      while (curr && !touchedFreeList) {\n        JsVar *currVar = jsvGetAddressOf(curr);\n        JsVarRef next = jsvGetNextSibling(currVar);\n  #ifdef RESIZABLE_JSVARS\n        if (blockCount && next && (jsvGetAddressOf(next)==currVar+1)) {\n  #else\n        if (blockCount && (next == curr+1)) {\n  #endif\n          blockCount++;\n          if (blockCount>=requiredBlocks) {\n            JsVar *nextVar = jsvGetAddressOf(next);\n            JsVarRef nextFree = jsvGetNextSibling(nextVar);\n            jshInterruptOff();\n            if (!touchedFreeList) {\n              // we're there! Quickly re-link free list\n              if (beforeStartBlock) {\n                jsvSetNextSibling(jsvGetAddressOf(beforeStartBlock),nextFree);\n              } else {\n                jsVarFirstEmpty = nextFree;\n              }\n              flatString = jsvGetAddressOf(startBlock);\n              // Set up the header block (including one lock)\n              jsvResetVariable(flatString, JSV_FLAT_STRING);\n              flatString->varData.integer = (JsVarInt)byteLength;\n            }\n            jshInterruptOn();\n            // if success, break out!\n            if (flatString) break;\n          }\n        } else {\n          // this block is not immediately after the last - restart run\n          beforeStartBlock = curr;\n          startBlock = next;\n          // Check to see if the next block is aligned on a 4 byte boundary or not\n          if (((size_t)(jsvGetAddressOf(startBlock+1)))&3)\n            blockCount = 0; // this block is not aligned\n          else\n            blockCount = 1; // all ok - start block here\n        }\n        // move to next!\n        curr = next;\n      }\n      // memory list has been touched - restart!\n      if (touchedFreeList) {\n        memoryTouched = true;\n      }\n    }\n\n    // all good\n    if (flatString || !firstRun)\n      break;\n    /* Nope... we couldn't find a free string. It could be because\n     * the free list is fragmented, so GCing might well fix it - which\n     * we'll try - but only ONCE */\n    firstRun = false;\n    jsvGarbageCollect();\n  };\n  if (!flatString) return 0;\n  /* We now have the string! All that's left is to clear it */\n  // clear data\n  memset((char*)&flatString[1], 0, sizeof(JsVar)*(requiredBlocks-1));\n  /* We did mess with the free list - set it here in case we\n  are trying to create a flat string in an IRQ while trying to\n  make one outside the IRQ too */\n  touchedFreeList = true;\n  // and we're done\n  return flatString;\n}\n\nJsVar *jsvNewFromString(const char *str) {\n  // Create a var\n  JsVar *first = jsvNewWithFlags(JSV_STRING_0);\n  if (!first) return 0; // out of memory\n  // Now we copy the string, but keep creating new jsVars if we go\n  // over the end\n  JsVar *var = jsvLockAgain(first);\n  while (*str) {\n    // copy data in\n    size_t i, l = jsvGetMaxCharactersInVar(var);\n    for (i=0;i<l && *str;i++)\n      var->varData.str[i] = *(str++);\n    // we already set the variable data to 0, so no need for adding one\n\n    // we've stopped if the string was empty\n    jsvSetCharactersInVar(var, i);\n\n    // if there is still some left, it's because we filled up our var...\n    // make a new one, link it in, and unlock the old one.\n    if (*str) {\n      JsVar *next = jsvNewWithFlags(JSV_STRING_EXT_0);\n      if (!next) {\n        // Truncating string as not enough memory\n        jsvUnLock(var);\n        return first;\n      }\n      // we don't ref, because  StringExts are never reffed as they only have one owner (and ALWAYS have an owner)\n      jsvSetLastChild(var, jsvGetRef(next));\n      jsvUnLock(var);\n      var = next;\n    }\n  }\n  jsvUnLock(var);\n  // return\n  return first;\n}\n\nJsVar *jsvNewStringOfLength(unsigned int byteLength, const char *initialData) {\n  // if string large enough, try and make a flat string instead\n  if (byteLength > JSV_FLAT_STRING_BREAK_EVEN) {\n    JsVar *v = jsvNewFlatStringOfLength(byteLength);\n    if (v) {\n      if (initialData) jsvSetString(v, initialData, byteLength);\n      return v;\n    }\n  }\n  // Create a var\n  JsVar *first = jsvNewWithFlags(JSV_STRING_0);\n  if (!first) return 0; // out of memory, will have already set flag\n  // Now keep creating enough new jsVars\n  JsVar *var = jsvLockAgain(first);\n  while (true) {\n    // copy data in\n    unsigned int l = (unsigned int)jsvGetMaxCharactersInVar(var);\n    if (l>=byteLength) {\n      if (initialData)\n        memcpy(var->varData.str, initialData, byteLength);\n      // we've got enough\n      jsvSetCharactersInVar(var, byteLength);\n      break;\n    } else {\n      if (initialData) {\n        memcpy(var->varData.str, initialData, l);\n        initialData+=l;\n      }\n      // We need more\n      jsvSetCharactersInVar(var, l);\n      byteLength -= l;\n      // Make a new one, link it in, and unlock the old one.\n      JsVar *next = jsvNewWithFlags(JSV_STRING_EXT_0);\n      if (!next) break; // out of memory, will have already set flag\n      // we don't ref, because  StringExts are never reffed as they only have one owner (and ALWAYS have an owner)\n      jsvSetLastChild(var, jsvGetRef(next));\n      jsvUnLock(var);\n      var = next;\n    }\n  }\n  jsvUnLock(var);\n  // return\n  return first;\n}\n\nJsVar *jsvNewFromInteger(JsVarInt value) {\n  JsVar *var = jsvNewWithFlags(JSV_INTEGER);\n  if (!var) return 0; // no memory\n  var->varData.integer = value;\n  return var;\n}\nJsVar *jsvNewFromBool(bool value) {\n  JsVar *var = jsvNewWithFlags(JSV_BOOLEAN);\n  if (!var) return 0; // no memory\n  var->varData.integer = value ? 1 : 0;\n  return var;\n}\nJsVar *jsvNewFromFloat(JsVarFloat value) {\n  JsVar *var = jsvNewWithFlags(JSV_FLOAT);\n  if (!var) return 0; // no memory\n  var->varData.floating = value;\n  return var;\n}\nJsVar *jsvNewFromLongInteger(long long value) {\n  if (value>=-2147483648LL && value<=2147483647LL)\n    return jsvNewFromInteger((JsVarInt)value);\n  else\n    return jsvNewFromFloat((JsVarFloat)value);\n}\n\nJsVar *jsvNewFromPin(int pin) {\n  JsVar *v = jsvNewFromInteger((JsVarInt)pin);\n  if (v) {\n    v->flags = (JsVarFlags)((v->flags & ~JSV_VARTYPEMASK) | JSV_PIN);\n  }\n  return v;\n}\n\nJsVar *jsvNewObject() {\n  return jsvNewWithFlags(JSV_OBJECT);\n}\n\nJsVar *jsvNewEmptyArray() {\n  return jsvNewWithFlags(JSV_ARRAY);\n}\n\n/// Create an array containing the given elements\nJsVar *jsvNewArray(JsVar **elements, int elementCount) {\n  JsVar *arr = jsvNewEmptyArray();\n  if (!arr) return 0;\n  int i;\n  for (i=0;i<elementCount;i++)\n    jsvArrayPush(arr, elements[i]);\n  return arr;\n}\n\nJsVar *jsvNewArrayFromBytes(uint8_t *elements, int elementCount) {\n  JsVar *arr = jsvNewEmptyArray();\n  if (!arr) return 0;\n  int i;\n  for (i=0;i<elementCount;i++)\n    jsvArrayPushAndUnLock(arr, jsvNewFromInteger(elements[i]));\n  return arr;\n}\n\nJsVar *jsvNewNativeFunction(void (*ptr)(void), unsigned short argTypes) {\n  JsVar *func = jsvNewWithFlags(JSV_NATIVE_FUNCTION);\n  if (!func) return 0;\n  func->varData.native.ptr = ptr;\n  func->varData.native.argTypes = argTypes;\n  return func;\n}\n\nJsVar *jsvNewNativeString(char *ptr, size_t len) {\n  if (len>JSV_NATIVE_STR_MAX_LENGTH) len=JSV_NATIVE_STR_MAX_LENGTH; // crop string to what we can store in nativeStr.len\n  JsVar *str = jsvNewWithFlags(JSV_NATIVE_STRING);\n  if (!str) return 0;\n  str->varData.nativeStr.ptr = ptr;\n  str->varData.nativeStr.len = len;\n  return str;\n}\n\n#ifdef SPIFLASH_BASE\nJsVar *jsvNewFlashString(char *ptr, size_t len) {\n  if (len>JSV_NATIVE_STR_MAX_LENGTH) len=JSV_NATIVE_STR_MAX_LENGTH; // crop string to what we can store in nativeStr.len\n    JsVar *str = jsvNewWithFlags(JSV_FLASH_STRING);\n    if (!str) return 0;\n    str->varData.nativeStr.ptr = ptr;\n    str->varData.nativeStr.len = len;\n    return str;\n}\n#endif\n\n/// Create a new ArrayBuffer backed by the given string. If length is not specified, it will be worked out\nJsVar *jsvNewArrayBufferFromString(JsVar *str, unsigned int lengthOrZero) {\n  JsVar *arr = jsvNewWithFlags(JSV_ARRAYBUFFER);\n  if (!arr) return 0;\n  jsvSetFirstChild(arr, jsvGetRef(jsvRef(str)));\n  arr->varData.arraybuffer.type = ARRAYBUFFERVIEW_ARRAYBUFFER;\n  assert(arr->varData.arraybuffer.byteOffset == 0);\n  if (lengthOrZero==0) lengthOrZero = (unsigned int)jsvGetStringLength(str);\n  arr->varData.arraybuffer.length = (unsigned short)lengthOrZero;\n  return arr;\n}\n\nJsVar *jsvMakeIntoVariableName(JsVar *var, JsVar *valueOrZero) {\n  if (!var) return 0;\n  assert(jsvGetRefs(var)==0); // make sure it's unused\n  assert(jsvIsSimpleInt(var) || jsvIsString(var));\n  JsVarFlags varType = (var->flags & JSV_VARTYPEMASK);\n  if (varType==JSV_INTEGER) {\n    int t = JSV_NAME_INT;\n    if ((jsvIsInt(valueOrZero) || jsvIsBoolean(valueOrZero)) && !jsvIsPin(valueOrZero)) {\n      JsVarInt v = valueOrZero->varData.integer;\n      if (v>=JSVARREF_MIN && v<=JSVARREF_MAX) {\n        t = jsvIsInt(valueOrZero) ? JSV_NAME_INT_INT : JSV_NAME_INT_BOOL;\n        jsvSetFirstChild(var, (JsVarRef)v);\n        valueOrZero = 0;\n      }\n    }\n    var->flags = (JsVarFlags)(var->flags & ~JSV_VARTYPEMASK) | t;\n  } else if (varType>=_JSV_STRING_START && varType<=_JSV_STRING_END) {\n    if (jsvGetCharactersInVar(var) > JSVAR_DATA_STRING_NAME_LEN) {\n      /* Argh. String is too large to fit in a JSV_NAME! We must chomp make\n       * new STRINGEXTs to put the data in\n       */\n      JsvStringIterator it;\n      jsvStringIteratorNew(&it, var, JSVAR_DATA_STRING_NAME_LEN);\n      JsVar *startExt = jsvNewWithFlags(JSV_STRING_EXT_0);\n      JsVar *ext = jsvLockAgainSafe(startExt);\n      size_t nChars = 0;\n      while (ext && jsvStringIteratorHasChar(&it)) {\n        if (nChars >= JSVAR_DATA_STRING_MAX_LEN) {\n          jsvSetCharactersInVar(ext, nChars);\n          JsVar *ext2 = jsvNewWithFlags(JSV_STRING_EXT_0);\n          if (ext2) {\n            jsvSetLastChild(ext, jsvGetRef(ext2));\n          }\n          jsvUnLock(ext);\n          ext = ext2;\n          nChars = 0;\n        }\n        ext->varData.str[nChars++] = jsvStringIteratorGetCharAndNext(&it);\n      }\n      jsvStringIteratorFree(&it);\n      if (ext) {\n        jsvSetCharactersInVar(ext, nChars);\n        jsvUnLock(ext);\n      }\n      jsvSetCharactersInVar(var, JSVAR_DATA_STRING_NAME_LEN);\n      // Free any old stringexts\n      JsVarRef oldRef = jsvGetLastChild(var);\n      while (oldRef) {\n        JsVar *v = jsvGetAddressOf(oldRef);\n        oldRef = jsvGetLastChild(v);\n        jsvFreePtrInternal(v);\n      }\n      // set up new stringexts\n      jsvSetLastChild(var, jsvGetRef(startExt));\n      jsvSetNextSibling(var, 0);\n      jsvSetPrevSibling(var, 0);\n      jsvSetFirstChild(var, 0);\n      jsvUnLock(startExt);\n    }\n\n    size_t t = JSV_NAME_STRING_0;\n    if (jsvIsInt(valueOrZero) && !jsvIsPin(valueOrZero)) {\n      JsVarInt v = valueOrZero->varData.integer;\n      if (v>=JSVARREF_MIN && v<=JSVARREF_MAX) {\n        t = JSV_NAME_STRING_INT_0;\n        jsvSetFirstChild(var, (JsVarRef)v);\n        valueOrZero = 0;\n      }\n    } else\n      jsvSetFirstChild(var, 0);\n    var->flags = (var->flags & (JsVarFlags)~JSV_VARTYPEMASK) | (t+jsvGetCharactersInVar(var));\n  } else assert(0);\n\n  if (valueOrZero)\n    jsvSetFirstChild(var, jsvGetRef(jsvRef(valueOrZero)));\n  return var;\n}\n\nvoid jsvMakeFunctionParameter(JsVar *v) {\n  assert(jsvIsString(v));\n  if (!jsvIsName(v)) jsvMakeIntoVariableName(v,0);\n  v->flags = (JsVarFlags)(v->flags | JSV_NATIVE);\n}\n\n/// Add a new unnamed function parameter to a function - use this when binding function arguments. This unlocks paramName if specified, but not value.\nvoid jsvAddFunctionParameter(JsVar *fn, JsVar *paramName, JsVar *value) {\n  assert(jsvIsFunction(fn));\n  if (!paramName) paramName = jsvNewFromEmptyString();\n  assert(jsvIsString(paramName));\n  if (paramName) {\n    jsvMakeFunctionParameter(paramName); // force this to be called a function parameter\n    jsvSetValueOfName(paramName, value);\n    jsvAddName(fn, paramName);\n    jsvUnLock(paramName);\n  }\n}\n\nvoid *jsvGetNativeFunctionPtr(const JsVar *function) {\n  /* see descriptions in jsvar.h. If we have a child called JSPARSE_FUNCTION_CODE_NAME\n   * then we execute code straight from that */\n  JsVar *flatString = jsvFindChildFromString((JsVar*)function, JSPARSE_FUNCTION_CODE_NAME, 0);\n  if (flatString) {\n    flatString = jsvSkipNameAndUnLock(flatString);\n    void *v = (void*)((size_t)function->varData.native.ptr + (char*)jsvGetFlatStringPointer(flatString));\n    jsvUnLock(flatString);\n    return v;\n  } else\n    return (void *)function->varData.native.ptr;\n}\n\n\nbool jsvIsBasicVarEqual(JsVar *a, JsVar *b) {\n  // quick checks\n  if (a==b) return true;\n  if (!a || !b) return false; // one of them is undefined\n  // OPT: would this be useful as compare instead?\n  assert(jsvIsBasic(a) && jsvIsBasic(b));\n  if (jsvIsNumeric(a) && jsvIsNumeric(b)) {\n    if (jsvIsIntegerish(a)) {\n      if (jsvIsIntegerish(b)) {\n        return a->varData.integer == b->varData.integer;\n      } else {\n        assert(jsvIsFloat(b));\n        return a->varData.integer == b->varData.floating;\n      }\n    } else {\n      assert(jsvIsFloat(a));\n      if (jsvIsIntegerish(b)) {\n        return a->varData.floating == b->varData.integer;\n      } else {\n        assert(jsvIsFloat(b));\n        return a->varData.floating == b->varData.floating;\n      }\n    }\n  } else if (jsvIsString(a) && jsvIsString(b)) {\n    JsvStringIterator ita, itb;\n    jsvStringIteratorNew(&ita, a, 0);\n    jsvStringIteratorNew(&itb, b, 0);\n    while (true) {\n      char a = jsvStringIteratorGetCharAndNext(&ita);\n      char b = jsvStringIteratorGetCharAndNext(&itb);\n      if (a != b) {\n        jsvStringIteratorFree(&ita);\n        jsvStringIteratorFree(&itb);\n        return false;\n      }\n      if (!a) { // equal, but end of string\n        jsvStringIteratorFree(&ita);\n        jsvStringIteratorFree(&itb);\n        return true;\n      }\n    }\n    // we never get here\n    return false; // make compiler happy\n  } else {\n    //TODO: are there any other combinations we should check here?? String v int?\n    return false;\n  }\n}\n\nbool jsvIsEqual(JsVar *a, JsVar *b) {\n  if (jsvIsBasic(a) && jsvIsBasic(b))\n    return jsvIsBasicVarEqual(a,b);\n  return jsvGetRef(a)==jsvGetRef(b);\n}\n\n/// Get a const string representing this variable - if we can. Otherwise return 0\nconst char *jsvGetConstString(const JsVar *v) {\n  if (jsvIsUndefined(v)) {\n    return \"undefined\";\n  } else if (jsvIsNull(v)) {\n    return \"null\";\n  } else if (jsvIsBoolean(v) && !jsvIsNameIntBool(v)) {\n    return jsvGetBool(v) ? \"true\" : \"false\";\n  }\n  return 0;\n}\n\n/// Return the 'type' of the JS variable (eg. JS's typeof operator)\nconst char *jsvGetTypeOf(const JsVar *v) {\n  if (jsvIsUndefined(v)) return \"undefined\";\n  if (jsvIsNull(v) || jsvIsObject(v) ||\n      jsvIsArray(v) || jsvIsArrayBuffer(v)) return \"object\";\n  if (jsvIsFunction(v)) return \"function\";\n  if (jsvIsString(v)) return \"string\";\n  if (jsvIsBoolean(v)) return \"boolean\";\n  if (jsvIsNumeric(v)) return \"number\";\n  return \"?\";\n}\n\n/// Return the JsVar, or if it's an object and has a valueOf function, call that\nJsVar *jsvGetValueOf(JsVar *v) {\n  if (!jsvIsObject(v)) return jsvLockAgainSafe(v);\n  JsVar *valueOf = jspGetNamedField(v, \"valueOf\", false);\n  if (!jsvIsFunction(valueOf)) {\n    jsvUnLock(valueOf);\n    return jsvLockAgain(v);\n  }\n  v = jspeFunctionCall(valueOf, 0, v, false, 0, 0);\n  jsvUnLock(valueOf);\n  return v;\n}\n\n/** Save this var as a string to the given buffer, and return how long it was (return val doesn't include terminating 0)\nIf the buffer length is exceeded, the returned value will == len */\nsize_t jsvGetString(const JsVar *v, char *str, size_t len) {\n  assert(len>0);\n  const char *s = jsvGetConstString(v);\n  if (s) {\n    /* don't use strncpy here because we don't\n     * want to pad the entire buffer with zeros */\n    len--;\n    size_t l = 0;\n    while (s[l] && l<len) {\n      str[l] = s[l];\n      l++;\n    }\n    str[l] = 0;\n    return l;\n  } else if (jsvIsInt(v)) {\n    itostr(v->varData.integer, str, 10);\n    return strlen(str);\n  } else if (jsvIsFloat(v)) {\n    ftoa_bounded(v->varData.floating, str, len);\n    return strlen(str);\n  } else if (jsvHasCharacterData(v)) {\n    assert(!jsvIsStringExt(v));\n    size_t l = len;\n    JsvStringIterator it;\n    jsvStringIteratorNewConst(&it, v, 0);\n    while (jsvStringIteratorHasChar(&it)) {\n      if (l--<=1) {\n        *str = 0;\n        jsvStringIteratorFree(&it);\n        return len;\n      }\n      *(str++) = jsvStringIteratorGetChar(&it);\n      jsvStringIteratorNext(&it);\n    }\n    jsvStringIteratorFree(&it);\n    *str = 0;\n    return len-l;\n  } else {\n    // Try and get as a JsVar string, and try again\n    JsVar *stringVar = jsvAsString((JsVar*)v); // we know we're casting to non-const here\n    if (stringVar) {\n      size_t l = jsvGetStringChars(stringVar, 0, str, len); // call again - but this time with converted var\n      jsvUnLock(stringVar);\n      return l;\n    } else {\n      str[0] = 0;\n      jsExceptionHere(JSET_INTERNALERROR, \"Variable type cannot be converted to string\");\n      return 0;\n    }\n  }\n}\n\n/// Get len bytes of string data from this string. Does not error if string len is not equal to len, no terminating 0\nsize_t jsvGetStringChars(const JsVar *v, size_t startChar, char *str, size_t len) {\n  assert(jsvHasCharacterData(v));\n  size_t l = len;\n  JsvStringIterator it;\n  jsvStringIteratorNewConst(&it, v, startChar);\n  while (jsvStringIteratorHasChar(&it)) {\n    if (l--<=0) {\n      jsvStringIteratorFree(&it);\n      return len;\n    }\n    *(str++) = jsvStringIteratorGetCharAndNext(&it);\n  }\n  jsvStringIteratorFree(&it);\n  return len-l;\n}\n\n/// Set the Data in this string. This must JUST overwrite - not extend or shrink\nvoid jsvSetString(JsVar *v, const char *str, size_t len) {\n  assert(jsvHasCharacterData(v));\n  // the iterator checks, so it is safe not to assert if the length is different\n  //assert(len == jsvGetStringLength(v));\n\n\n  JsvStringIterator it;\n  jsvStringIteratorNew(&it, v, 0);\n  size_t i;\n  for (i=0;i<len;i++) {\n    jsvStringIteratorSetCharAndNext(&it, str[i]);\n  }\n  jsvStringIteratorFree(&it);\n}\n\n/** If var is a string, lock and return it, else\n * create a new string. unlockVar means this will auto-unlock 'var'  */\nJsVar *jsvAsString(JsVar *v) {\n  JsVar *str = 0;\n  // If it is string-ish, but not quite a string, copy it\n  if (jsvHasCharacterData(v) && jsvIsName(v)) {\n    str = jsvNewFromStringVar(v,0,JSVAPPENDSTRINGVAR_MAXLENGTH);\n  } else if (jsvIsString(v)) { // If it is a string - just return a reference\n    str = jsvLockAgain(v);\n  } else if (jsvIsObject(v)) { // If it is an object and we can call toString on it\n    JsVar *toStringFn = jspGetNamedField(v, \"toString\", false);\n    if (toStringFn && toStringFn->varData.native.ptr != (void (*)(void))jswrap_object_toString) {\n      // Function found and it's not the default one - execute it\n      JsVar *result = jspExecuteFunction(toStringFn,v,0,0);\n      jsvUnLock(toStringFn);\n      str = jsvAsStringAndUnLock(result);\n    } else {\n      jsvUnLock(toStringFn);\n      str = jsvNewFromString(\"[object Object]\");\n    }\n  } else {\n    const char *constChar = jsvGetConstString(v);\n    assert(JS_NUMBER_BUFFER_SIZE>=10);\n    char buf[JS_NUMBER_BUFFER_SIZE];\n    if (constChar) {\n      // if we could get this as a simple const char, do that..\n      str = jsvNewFromString(constChar);\n    } else if (jsvIsPin(v)) {\n      jshGetPinString(buf, (Pin)v->varData.integer);\n      str = jsvNewFromString(buf);\n    } else if (jsvIsInt(v)) {\n      itostr(v->varData.integer, buf, 10);\n      str = jsvNewFromString(buf);\n    } else if (jsvIsFloat(v)) {\n      ftoa_bounded(v->varData.floating, buf, sizeof(buf));\n      str = jsvNewFromString(buf);\n    } else if (jsvIsArray(v) || jsvIsArrayBuffer(v)) {\n      JsVar *filler = jsvNewFromString(\",\");\n      str = jsvArrayJoin(v, filler, true/*ignoreNull*/);\n      jsvUnLock(filler);\n    } else if (jsvIsFunction(v)) {\n      str = jsvNewFromEmptyString();\n      if (str) jsfGetJSON(v, str, JSON_NONE);\n    } else {\n      jsExceptionHere(JSET_INTERNALERROR, \"Variable type cannot be converted to string\");\n    }\n  }\n  return str;\n}\n\nJsVar *jsvAsStringAndUnLock(JsVar *var) {\n  JsVar *s = jsvAsString(var);\n  jsvUnLock(var);\n  return s;\n}\n\nJsVar *jsvAsFlatString(JsVar *var) {\n  if (jsvIsFlatString(var)) return jsvLockAgain(var);\n  JsVar *str = jsvAsString(var);\n  size_t len = jsvGetStringLength(str);\n  JsVar *flat = jsvNewFlatStringOfLength((unsigned int)len);\n  if (flat) {\n    JsvStringIterator src;\n    JsvStringIterator dst;\n    jsvStringIteratorNew(&src, str, 0);\n    jsvStringIteratorNew(&dst, flat, 0);\n    while (len--) {\n      jsvStringIteratorSetCharAndNext(&dst, jsvStringIteratorGetCharAndNext(&src));\n    }\n    jsvStringIteratorFree(&src);\n    jsvStringIteratorFree(&dst);\n  }\n  jsvUnLock(str);\n  return flat;\n}\n\n/** Given a JsVar meant to be an index to an array, convert it to\n * the actual variable type we'll use to access the array. For example\n * a[\"0\"] is actually translated to a[0]\n */\nJsVar *jsvAsArrayIndex(JsVar *index) {\n  if (jsvIsSimpleInt(index) && jsvGetInteger(index)>=0) {\n    return jsvLockAgain(index); // we're ok!\n  } else if (jsvIsString(index)) {\n    /* Index filtering (bug #19) - if we have an array index A that is:\n     is_string(A) && int_to_string(string_to_int(A)) == A\n     then convert it to an integer. Shouldn't be too nasty for performance\n     as we only do this when accessing an array with a string */\n    if (jsvIsStringNumericStrict(index)) {\n      JsVar *i = jsvNewFromInteger(jsvGetInteger(index));\n      JsVar *is = jsvAsString(i);\n      if (jsvCompareString(index,is,0,0,false)==0) {\n        // two items are identical - use the integer\n        jsvUnLock(is);\n        return i;\n      } else {\n        // not identical, use as a string\n        jsvUnLock2(i,is);\n      }\n    }\n  } else if (jsvIsFloat(index)) {\n    // if it's a float that is actually integral, return an integer...\n    JsVarFloat v = jsvGetFloat(index);\n    JsVarInt vi = jsvGetInteger(index);\n    if (v == vi) return jsvNewFromInteger(vi);\n  }\n\n  // else if it's not a simple numeric type, convert it to a string\n  return jsvAsString(index);\n}\n\n/** Same as jsvAsArrayIndex, but ensures that 'index' is unlocked */\nJsVar *jsvAsArrayIndexAndUnLock(JsVar *a) {\n  JsVar *b = jsvAsArrayIndex(a);\n  jsvUnLock(a);\n  return b;\n}\n\n/// Returns true if the string is empty - faster than jsvGetStringLength(v)==0\nbool jsvIsEmptyString(JsVar *v) {\n  if (!jsvHasCharacterData(v)) return true;\n  return jsvGetCharactersInVar(v)==0;\n}\n\nsize_t jsvGetStringLength(const JsVar *v) {\n  size_t strLength = 0;\n  const JsVar *var = v;\n  JsVar *newVar = 0;\n  if (!jsvHasCharacterData(v)) return 0;\n\n  while (var) {\n    JsVarRef ref = jsvGetLastChild(var);\n    strLength += jsvGetCharactersInVar(var);\n\n    // Go to next\n    jsvUnLock(newVar); // note use of if (ref), not var\n    var = newVar = jsvLockSafe(ref);\n  }\n  jsvUnLock(newVar); // note use of if (ref), not var\n  return strLength;\n}\n\nsize_t jsvGetFlatStringBlocks(const JsVar *v) {\n  assert(jsvIsFlatString(v));\n  return ((size_t)v->varData.integer+sizeof(JsVar)-1) / sizeof(JsVar);\n}\n\nchar *jsvGetFlatStringPointer(JsVar *v) {\n  assert(jsvIsFlatString(v));\n  if (!jsvIsFlatString(v)) return 0;\n  return (char*)(v+1); // pointer to the next JsVar\n}\n\nJsVar *jsvGetFlatStringFromPointer(char *v) {\n  JsVar *secondVar = (JsVar*)v;\n  JsVar *flatStr = secondVar-1;\n  assert(jsvIsFlatString(flatStr));\n  return flatStr;\n}\n\n/// If the variable points to a *flat* area of memory, return a pointer (and set length). Otherwise return 0.\nchar *jsvGetDataPointer(JsVar *v, size_t *len) {\n  assert(len);\n  if (jsvIsArrayBuffer(v)) {\n    /* Arraybuffers generally use some kind of string to store their data.\n     * Find it, then call ourselves again to figure out if we can get a\n     * raw pointer to it.  */\n    JsVar *d = jsvGetArrayBufferBackingString(v, NULL);\n    char *r = jsvGetDataPointer(d, len);\n    jsvUnLock(d);\n    if (r) {\n      r += v->varData.arraybuffer.byteOffset;\n      *len = v->varData.arraybuffer.length;\n    }\n    return r;\n  }\n  if (jsvIsNativeString(v)) {\n    *len = v->varData.nativeStr.len;\n    return (char*)v->varData.nativeStr.ptr;\n  }\n  if (jsvIsFlatString(v)) {\n    *len = jsvGetStringLength(v);\n    return jsvGetFlatStringPointer(v);\n  }\n  if (jsvIsBasicString(v) && !jsvGetLastChild(v)) {\n    // It's a normal string but is small enough to have all the data in\n    *len = jsvGetCharactersInVar(v);\n    return (char*)v->varData.str;\n  }\n  return 0;\n}\n\n//  IN A STRING  get the number of lines in the string (min=1)\nsize_t jsvGetLinesInString(JsVar *v) {\n  size_t lines = 1;\n  JsvStringIterator it;\n  jsvStringIteratorNew(&it, v, 0);\n  while (jsvStringIteratorHasChar(&it)) {\n    if (jsvStringIteratorGetCharAndNext(&it)=='\\n') lines++;\n  }\n  jsvStringIteratorFree(&it);\n  return lines;\n}\n\n// IN A STRING Get the number of characters on a line - lines start at 1\nsize_t jsvGetCharsOnLine(JsVar *v, size_t line) {\n  size_t currentLine = 1;\n  size_t chars = 0;\n  JsvStringIterator it;\n  jsvStringIteratorNew(&it, v, 0);\n  while (jsvStringIteratorHasChar(&it)) {\n    if (jsvStringIteratorGetCharAndNext(&it)=='\\n') {\n      currentLine++;\n      if (currentLine > line) break;\n    } else if (currentLine==line) chars++;\n  }\n  jsvStringIteratorFree(&it);\n  return chars;\n}\n\n//  IN A STRING, get the 1-based line and column of the given character. Both values must be non-null\nvoid jsvGetLineAndCol(JsVar *v, size_t charIdx, size_t *line, size_t *col) {\n  size_t x = 1;\n  size_t y = 1;\n  size_t n = 0;\n  assert(line && col);\n\n  JsvStringIterator it;\n  jsvStringIteratorNew(&it, v, 0);\n  while (jsvStringIteratorHasChar(&it)) {\n    char ch = jsvStringIteratorGetCharAndNext(&it);\n    if (n==charIdx) {\n      jsvStringIteratorFree(&it);\n      *line = y;\n      *col = x;\n      return;\n    }\n    x++;\n    if (ch=='\\n') {\n      x=1; y++;\n    }\n    n++;\n  }\n  jsvStringIteratorFree(&it);\n  // uh-oh - not found\n  *line = y;\n  *col = x;\n}\n\n//  IN A STRING, get a character index from a line and column\nsize_t jsvGetIndexFromLineAndCol(JsVar *v, size_t line, size_t col) {\n  size_t x = 1;\n  size_t y = 1;\n  size_t n = 0;\n  JsvStringIterator it;\n  jsvStringIteratorNew(&it, v, 0);\n  while (jsvStringIteratorHasChar(&it)) {\n    char ch = jsvStringIteratorGetCharAndNext(&it);\n    if ((y==line && x>=col) || y>line) {\n      jsvStringIteratorFree(&it);\n      return (y>line) ? (n-1) : n;\n    }\n    x++;\n    if (ch=='\\n') {\n      x=1; y++;\n    }\n    n++;\n  }\n  jsvStringIteratorFree(&it);\n  return n;\n}\n\nvoid jsvAppendString(JsVar *var, const char *str) {\n  assert(jsvIsString(var));\n  JsvStringIterator dst;\n  jsvStringIteratorNew(&dst, var, 0);\n  jsvStringIteratorGotoEnd(&dst);\n  // now start appending\n  /* This isn't as fast as something single-purpose, but it's not that bad,\n   * and is less likely to break :) */\n  while (*str)\n    jsvStringIteratorAppend(&dst, *(str++));\n  jsvStringIteratorFree(&dst);\n}\n\n// Append the given string to this one - but does not use null-terminated strings\nvoid jsvAppendStringBuf(JsVar *var, const char *str, size_t length) {\n  assert(jsvIsString(var));\n  JsvStringIterator dst;\n  jsvStringIteratorNew(&dst, var, 0);\n  jsvStringIteratorGotoEnd(&dst);\n  // now start appending\n  /* This isn't as fast as something single-purpose, but it's not that bad,\n   * and is less likely to break :) */\n  while (length) {\n    jsvStringIteratorAppend(&dst, *(str++));\n    length--;\n  }\n  jsvStringIteratorFree(&dst);\n}\n\n/// Special version of append designed for use with vcbprintf_callback (See jsvAppendPrintf)\nvoid jsvStringIteratorPrintfCallback(const char *str, void *user_data) {\n  while (*str)\n    jsvStringIteratorAppend((JsvStringIterator *)user_data, *(str++));\n}\n\nvoid jsvAppendPrintf(JsVar *var, const char *fmt, ...) {\n  JsvStringIterator it;\n  jsvStringIteratorNew(&it, var, 0);\n  jsvStringIteratorGotoEnd(&it);\n\n  va_list argp;\n  va_start(argp, fmt);\n  vcbprintf((vcbprintf_callback)jsvStringIteratorPrintfCallback,&it, fmt, argp);\n  va_end(argp);\n\n  jsvStringIteratorFree(&it);\n}\n\nJsVar *jsvVarPrintf( const char *fmt, ...) {\n  JsVar *str = jsvNewFromEmptyString();\n  if (!str) return 0;\n  JsvStringIterator it;\n  jsvStringIteratorNew(&it, str, 0);\n  jsvStringIteratorGotoEnd(&it);\n\n  va_list argp;\n  va_start(argp, fmt);\n  vcbprintf((vcbprintf_callback)jsvStringIteratorPrintfCallback,&it, fmt, argp);\n  va_end(argp);\n\n  jsvStringIteratorFree(&it);\n  return str;\n}\n\n/** Append str to var. Both must be strings. stridx = start char or str, maxLength = max number of characters (can be JSVAPPENDSTRINGVAR_MAXLENGTH) */\nvoid jsvAppendStringVar(JsVar *var, const JsVar *str, size_t stridx, size_t maxLength) {\n  assert(jsvIsString(var));\n\n  JsvStringIterator dst;\n  jsvStringIteratorNew(&dst, var, 0);\n  jsvStringIteratorGotoEnd(&dst);\n  // now start appending\n  /* This isn't as fast as something single-purpose, but it's not that bad,\n     * and is less likely to break :) */\n  JsvStringIterator it;\n  jsvStringIteratorNewConst(&it, str, stridx);\n  while (jsvStringIteratorHasChar(&it) && (maxLength-->0)) {\n    char ch = jsvStringIteratorGetCharAndNext(&it);\n    jsvStringIteratorAppend(&dst, ch);\n  }\n  jsvStringIteratorFree(&it);\n  jsvStringIteratorFree(&dst);\n}\n\n/** Create a new variable from a substring. argument must be a string. stridx = start char or str, maxLength = max number of characters (can be JSVAPPENDSTRINGVAR_MAXLENGTH) */\nJsVar *jsvNewFromStringVar(const JsVar *str, size_t stridx, size_t maxLength) {\n  JsVar *var = jsvNewFromEmptyString();\n  if (var) jsvAppendStringVar(var, str, stridx, maxLength);\n  return var;\n}\n\n/** Append all of str to var. Both must be strings.  */\nvoid jsvAppendStringVarComplete(JsVar *var, const JsVar *str) {\n  jsvAppendStringVar(var, str, 0, JSVAPPENDSTRINGVAR_MAXLENGTH);\n}\n\nchar jsvGetCharInString(JsVar *v, size_t idx) {\n  if (!jsvIsString(v)) return 0;\n\n  JsvStringIterator it;\n  jsvStringIteratorNew(&it, v, idx);\n  char ch = jsvStringIteratorGetChar(&it);\n  jsvStringIteratorFree(&it);\n  return ch;\n}\n\nvoid jsvSetCharInString(JsVar *v, size_t idx, char ch, bool bitwiseOR) {\n  if (!jsvIsString(v)) return;\n  JsvStringIterator it;\n  jsvStringIteratorNew(&it, v, idx);\n  if (bitwiseOR) ch |= jsvStringIteratorGetChar(&it);\n  jsvStringIteratorSetChar(&it, ch);\n  jsvStringIteratorFree(&it);\n}\n\n/// Get the index of a character in a string, or -1\nint jsvGetStringIndexOf(JsVar *str, char ch) {\n  JsvStringIterator it;\n  jsvStringIteratorNew(&it, str, 0);\n  while (jsvStringIteratorHasChar(&it)) {\n    if (jsvStringIteratorGetChar(&it) == ch) {\n      int idx = (int)jsvStringIteratorGetIndex(&it);\n      jsvStringIteratorFree(&it);\n      return idx;\n    };\n    jsvStringIteratorNext(&it);\n  }\n  jsvStringIteratorFree(&it);\n  return -1;\n}\n\n/** Does this string contain only Numeric characters (with optional '-'/'+' at the front)? NOT '.'/'e' and similar (allowDecimalPoint is for '.' only) */\nbool jsvIsStringNumericInt(const JsVar *var, bool allowDecimalPoint) {\n  assert(jsvIsString(var));\n  JsvStringIterator it;\n  jsvStringIteratorNewConst(&it, var, 0); // we know it's non const\n\n  // skip whitespace\n  while (jsvStringIteratorHasChar(&it) && isWhitespace(jsvStringIteratorGetChar(&it)))\n    jsvStringIteratorNext(&it);\n\n  // skip a minus. if there was one\n  if (jsvStringIteratorGetChar(&it)=='-' || jsvStringIteratorGetChar(&it)=='+')\n    jsvStringIteratorNext(&it);\n\n  int radix = 0;\n  if (jsvStringIteratorGetChar(&it)=='0') {\n    jsvStringIteratorNext(&it);\n    char buf[3];\n    buf[0] = '0';\n    buf[1] = jsvStringIteratorGetChar(&it);\n    buf[2] = 0;\n    const char *p = buf;\n    radix = getRadix(&p,0);\n    if (p>&buf[1]) jsvStringIteratorNext(&it);\n  }\n  if (radix==0) radix=10;\n\n  // now check...\n  int chars=0;\n  while (jsvStringIteratorHasChar(&it)) {\n    chars++;\n    char ch = jsvStringIteratorGetCharAndNext(&it);\n    if (ch=='.' && allowDecimalPoint) {\n      allowDecimalPoint = false; // there can be only one\n    } else {\n      int n = chtod(ch);\n      if (n<0 || n>=radix) {\n        jsvStringIteratorFree(&it);\n        return false;\n      }\n    }\n  }\n  jsvStringIteratorFree(&it);\n  return chars>0;\n}\n\n/** Does this string contain only Numeric characters? This is for arrays\n * and makes the assertion that int_to_string(string_to_int(var))==var */\nbool jsvIsStringNumericStrict(const JsVar *var) {\n  assert(jsvIsString(var));\n  JsvStringIterator it;\n  jsvStringIteratorNewConst(&it, var, 0);  // we know it's non const\n  bool hadNonZero = false;\n  bool hasLeadingZero = false;\n  int chars = 0;\n  while (jsvStringIteratorHasChar(&it)) {\n    chars++;\n    char ch = jsvStringIteratorGetCharAndNext(&it);\n    if (!isNumeric(ch)) {\n      // test for leading zero ensures int_to_string(string_to_int(var))==var\n      jsvStringIteratorFree(&it);\n      return false;\n    }\n    if (!hadNonZero && ch=='0') hasLeadingZero=true;\n    if (ch!='0') hadNonZero=true;\n  }\n  jsvStringIteratorFree(&it);\n  return chars>0 && (!hasLeadingZero || chars==1);\n}\n\n\nJsVarInt jsvGetInteger(const JsVar *v) {\n  if (!v) return 0; // undefined\n  /* strtol understands about hex and octal */\n  if (jsvIsNull(v)) return 0;\n  if (jsvIsUndefined(v)) return 0;\n  if (jsvIsIntegerish(v) || jsvIsArrayBufferName(v)) return v->varData.integer;\n  if (jsvIsArray(v) || jsvIsArrayBuffer(v)) {\n    JsVarInt l = jsvGetLength((JsVar *)v);\n    if (l==0) return 0; // 0 length, return 0\n    if (l==1) {\n      if (jsvIsArrayBuffer(v))\n        return jsvGetIntegerAndUnLock(jsvArrayBufferGet((JsVar*)v,0));\n      return jsvGetIntegerAndUnLock(jsvSkipNameAndUnLock(jsvGetArrayItem(v,0)));\n    }\n  }\n  if (jsvIsFloat(v)) {\n    if (isfinite(v->varData.floating))\n      return (JsVarInt)(long long)v->varData.floating;\n    return 0;\n  }\n  if (jsvIsString(v) && jsvIsStringNumericInt(v, true/* allow decimal point*/)) {\n    char buf[32];\n    if (jsvGetString(v, buf, sizeof(buf))==sizeof(buf))\n      jsExceptionHere(JSET_ERROR, \"String too big to convert to integer\\n\");\n    else\n      return (JsVarInt)stringToInt(buf);\n  }\n  return 0;\n}\n\nlong long jsvGetLongInteger(const JsVar *v) {\n  if (jsvIsInt(v)) return jsvGetInteger(v);\n  return (long long)jsvGetFloat(v);\n}\n\nlong long jsvGetLongIntegerAndUnLock(JsVar *v) {\n  long long i = jsvGetLongInteger(v);\n  jsvUnLock(v);\n  return i;\n}\n\n\nvoid jsvSetInteger(JsVar *v, JsVarInt value) {\n  assert(jsvIsInt(v));\n  v->varData.integer  = value;\n}\n\n/**\n * Get the boolean value of a variable.\n * From a JavaScript variable, we determine its boolean value.  The rules\n * are:\n *\n * * If integer, true if value is not 0.\n * * If float, true if value is not 0.0.\n * * If function, array or object, always true.\n * * If string, true if length of string is greater than 0.\n */\nbool jsvGetBool(const JsVar *v) {\n  if (jsvIsString(v))\n    return jsvGetStringLength((JsVar*)v)!=0;\n  if (jsvIsPin(v))\n    return jshIsPinValid(jshGetPinFromVar((JsVar*)v));\n  if (jsvIsFunction(v) || jsvIsArray(v) || jsvIsObject(v) || jsvIsArrayBuffer(v))\n    return true;\n  if (jsvIsFloat(v)) {\n    JsVarFloat f = jsvGetFloat(v);\n    return !isnan(f) && f!=0.0;\n  }\n  return jsvGetInteger(v)!=0;\n}\n\nJsVarFloat jsvGetFloat(const JsVar *v) {\n  if (!v) return NAN; // undefined\n  if (jsvIsFloat(v)) return v->varData.floating;\n  if (jsvIsIntegerish(v)) return (JsVarFloat)v->varData.integer;\n  if (jsvIsArray(v) || jsvIsArrayBuffer(v)) {\n    JsVarInt l = jsvGetLength(v);\n    if (l==0) return 0; // zero element array==0 (not undefined)\n    if (l==1) {\n      if (jsvIsArrayBuffer(v))\n        return jsvGetFloatAndUnLock(jsvArrayBufferGet((JsVar*)v,0));\n      return jsvGetFloatAndUnLock(jsvSkipNameAndUnLock(jsvGetArrayItem(v,0)));\n    }\n  }\n  if (jsvIsString(v)) {\n    char buf[64];\n    if (jsvGetString(v, buf, sizeof(buf))==sizeof(buf)) {\n      jsExceptionHere(JSET_ERROR, \"String too big to convert to float\\n\");\n    } else {\n      if (buf[0]==0) return 0; // empty string -> 0\n      if (!strcmp(buf,\"Infinity\")) return INFINITY;\n      if (!strcmp(buf,\"-Infinity\")) return -INFINITY;\n      return stringToFloat(buf);\n    }\n  }\n  return NAN;\n}\n\n/// Convert the given variable to a number\nJsVar *jsvAsNumber(JsVar *var) {\n  // stuff that we can just keep\n  if (jsvIsInt(var) || jsvIsFloat(var)) return jsvLockAgain(var);\n  // stuff that can be converted to an int\n  if (jsvIsBoolean(var) ||\n      jsvIsPin(var) ||\n      jsvIsNull(var) ||\n      jsvIsBoolean(var) ||\n      jsvIsArrayBufferName(var))\n    return jsvNewFromInteger(jsvGetInteger(var));\n  if (jsvIsString(var) && (jsvIsEmptyString(var) || jsvIsStringNumericInt(var, false/* no decimal pt - handle that with GetFloat */))) {\n    // handle strings like this, in case they're too big for an int\n    char buf[64];\n    if (jsvGetString(var, buf, sizeof(buf))==sizeof(buf)) {\n      jsExceptionHere(JSET_ERROR, \"String too big to convert to integer\\n\");\n      return jsvNewFromFloat(NAN);\n    } else\n      return jsvNewFromLongInteger(stringToInt(buf));\n  }\n  // Else just try and get a float\n  return jsvNewFromFloat(jsvGetFloat(var));\n}\n\nJsVarInt jsvGetIntegerAndUnLock(JsVar *v) { return _jsvGetIntegerAndUnLock(v); }\nJsVarFloat jsvGetFloatAndUnLock(JsVar *v) { return _jsvGetFloatAndUnLock(v); }\nbool jsvGetBoolAndUnLock(JsVar *v) { return _jsvGetBoolAndUnLock(v); }\n\n\n#ifndef SAVE_ON_FLASH\n// Executes the given getter, or if there are problems returns undefined\nJsVar *jsvExecuteGetter(JsVar *parent, JsVar *getset) {\n  assert(jsvIsGetterOrSetter(getset));\n  if (!jsvIsGetterOrSetter(getset)) return 0; // wasn't an object?\n  JsVar *fn = jsvObjectGetChild(getset, \"get\", 0);\n  if (!jsvIsFunction(fn)) {\n    jsvUnLock(fn);\n    return 0;\n  }\n  JsVar *result = jspExecuteFunction(fn, parent, 0, NULL);\n  jsvUnLock(fn);\n  return result;\n}\n\n// Executes the given setter\nvoid jsvExecuteSetter(JsVar *parent, JsVar *getset, JsVar *value) {\n  assert(jsvIsGetterOrSetter(getset));\n  if (!jsvIsGetterOrSetter(getset)) return; // wasn't an object?\n  JsVar *fn = jsvObjectGetChild(getset, \"set\", 0);\n  if (!jsvIsFunction(fn)) {\n    jsvUnLock(fn);\n    return;\n  }\n  if (!fn) return;\n  jsvUnLock2(jspExecuteFunction(fn, parent, 1, &value), fn);\n}\n\n/// Add a named getter or setter to an object\nvoid jsvAddGetterOrSetter(JsVar *obj, JsVar *varName, bool isGetter, JsVar *method) {\n  // check for existing getter/setter, make one if needed\n  JsVar *getsetName = jsvFindChildFromVar(obj, varName, true);\n  if (jsvIsName(getsetName)) {\n    JsVar *getset = jsvGetValueOfName(getsetName);\n    if (!jsvIsGetterOrSetter(getset)) {\n      jsvUnLock(getset);\n      getset = jsvNewWithFlags(JSV_GET_SET);\n      jsvSetValueOfName(getsetName, getset);\n    }\n    if (jsvIsGetterOrSetter(getset))\n      jsvObjectSetChild(getset, isGetter?\"get\":\"set\", method);\n    jsvUnLock(getset);\n  }\n  jsvUnLock(getsetName);\n}\n#endif\n\n\n/* Set the value of the given variable. This is sort of like\n * jsvSetValueOfName except it deals with all the non-standard\n * stuff like ArrayBuffers, variables that haven't been allocated\n * yet, setters, etc.\n */\nvoid jsvReplaceWith(JsVar *dst, JsVar *src) {\n  // If this is an index in an array buffer, write directly into the array buffer\n  if (jsvIsArrayBufferName(dst)) {\n    size_t idx = (size_t)jsvGetInteger(dst);\n    JsVar *arrayBuffer = jsvLock(jsvGetFirstChild(dst));\n    jsvArrayBufferSet(arrayBuffer, idx, src);\n    jsvUnLock(arrayBuffer);\n    return;\n  }\n  // if destination isn't there, isn't a 'name', or is used, give an error\n  if (!jsvIsName(dst)) {\n    jsExceptionHere(JSET_ERROR, \"Unable to assign value to non-reference %t\", dst);\n    return;\n  }\n#ifndef SAVE_ON_FLASH\n  JsVar *v = jsvGetValueOfName(dst);\n  if (jsvIsGetterOrSetter(v)) {\n    JsVar *parent = jsvIsNewChild(dst)?jsvLock(jsvGetNextSibling(dst)):0;\n    jsvExecuteSetter(parent,v,src);\n    jsvUnLock2(v,parent);\n    return;\n  }\n  jsvUnLock(v);\n#endif\n  jsvSetValueOfName(dst, src);\n  /* If dst is flagged as a new child, it means that\n   * it was previously undefined, and we need to add it to\n   * the given object when it is set.\n   */\n  if (jsvIsNewChild(dst)) {\n    // Get what it should have been a child of\n    JsVar *parent = jsvLock(jsvGetNextSibling(dst));\n    if (!jsvIsString(parent)) {\n      // if we can't find a char in a string we still return a NewChild,\n      // but we can't add character back in\n      if (!jsvHasChildren(parent)) {\n        jsExceptionHere(JSET_ERROR, \"Field or method \\\"%v\\\" does not already exist, and can't create it on %t\", dst, parent);\n      } else {\n        // Remove the 'new child' flagging\n        jsvUnRef(parent);\n        jsvSetNextSibling(dst, 0);\n        jsvUnRef(parent);\n        jsvSetPrevSibling(dst, 0);\n        // Add to the parent\n        jsvAddName(parent, dst);\n      }\n    }\n    jsvUnLock(parent);\n  }\n}\n\n/* See jsvReplaceWith - this does the same but will\n * shove the variable in execInfo.root if it hasn't\n * been defined yet */\nvoid jsvReplaceWithOrAddToRoot(JsVar *dst, JsVar *src) {\n  /* If we're assigning to this and we don't have a parent,\n   * add it to the symbol table root */\n  if (!jsvGetRefs(dst) && jsvIsName(dst)) {\n    if (!jsvIsArrayBufferName(dst) && !jsvIsNewChild(dst))\n      jsvAddName(execInfo.root, dst);\n  }\n  jsvReplaceWith(dst, src);\n}\n\n/** Get the item at the given location in the array buffer and return the result */\nsize_t jsvGetArrayBufferLength(const JsVar *arrayBuffer) {\n  assert(jsvIsArrayBuffer(arrayBuffer));\n  return arrayBuffer->varData.arraybuffer.length;\n}\n\n/** Get the String the contains the data for this arrayBuffer. Is ok with being passed a String in the first place. Offset is the offset in the backing string of this arraybuffer. */\nJsVar *jsvGetArrayBufferBackingString(JsVar *arrayBuffer, uint32_t *offset) {\n  jsvLockAgain(arrayBuffer);\n  if (offset) *offset = 0;\n  while (jsvIsArrayBuffer(arrayBuffer)) {\n    if (offset) *offset += arrayBuffer->varData.arraybuffer.byteOffset;\n    JsVar *s = jsvLock(jsvGetFirstChild(arrayBuffer));\n    jsvUnLock(arrayBuffer);\n    arrayBuffer = s;\n  }\n  assert(jsvIsString(arrayBuffer));\n  return arrayBuffer;\n}\n\n/** Get the item at the given location in the array buffer and return the result */\nJsVar *jsvArrayBufferGet(JsVar *arrayBuffer, size_t idx) {\n  JsvArrayBufferIterator it;\n  jsvArrayBufferIteratorNew(&it, arrayBuffer, idx);\n  JsVar *v = jsvArrayBufferIteratorGetValue(&it);\n  jsvArrayBufferIteratorFree(&it);\n  return v;\n}\n\n/** Set the item at the given location in the array buffer */\nvoid jsvArrayBufferSet(JsVar *arrayBuffer, size_t idx, JsVar *value) {\n  JsvArrayBufferIterator it;\n  jsvArrayBufferIteratorNew(&it, arrayBuffer, idx);\n  jsvArrayBufferIteratorSetValue(&it, value);\n  jsvArrayBufferIteratorFree(&it);\n}\n\n\n/** Given an integer name that points to an arraybuffer or an arraybufferview, evaluate it and return the result */\nJsVar *jsvArrayBufferGetFromName(JsVar *name) {\n  assert(jsvIsArrayBufferName(name));\n  size_t idx = (size_t)jsvGetInteger(name);\n  JsVar *arrayBuffer = jsvLock(jsvGetFirstChild(name));\n  JsVar *value = jsvArrayBufferGet(arrayBuffer, idx);\n  jsvUnLock(arrayBuffer);\n  return value;\n}\n\n\nJsVar *jsvGetFunctionArgumentLength(JsVar *functionScope) {\n  JsVar *args = jsvNewEmptyArray();\n  if (!args) return 0; // out of memory\n\n  JsvObjectIterator it;\n  jsvObjectIteratorNew(&it, functionScope);\n  while (jsvObjectIteratorHasValue(&it)) {\n    JsVar *idx = jsvObjectIteratorGetKey(&it);\n    if (jsvIsFunctionParameter(idx)) {\n      JsVar *val = jsvSkipOneName(idx);\n      jsvArrayPushAndUnLock(args, val);\n    }\n    jsvUnLock(idx);\n    jsvObjectIteratorNext(&it);\n  }\n  jsvObjectIteratorFree(&it);\n\n  return args;\n}\n\n/** Is this variable actually defined? eg, can we pass it into `jsvSkipName`\n * without getting a ReferenceError? This also returns false if the variable\n * if ok, but has the value `undefined`. */\nbool jsvIsVariableDefined(JsVar *a) {\n  return !jsvIsName(a) ||\n         jsvIsNameWithValue(a) ||\n         (jsvGetFirstChild(a)!=0);\n}\n\n/* If this is a simple name (that links to another var) the\n * return that var, else 0. Unlike jsvSkipName this doesn't\n * repeatedly get the name, or evaluate getters. */\nJsVar *jsvGetValueOfName(JsVar *a) {\n  if (!a) return 0;\n  if (jsvIsArrayBufferName(a)) return jsvArrayBufferGetFromName(a);\n  if (jsvIsNameInt(a)) return jsvNewFromInteger((JsVarInt)jsvGetFirstChildSigned(a));\n  if (jsvIsNameIntBool(a)) return jsvNewFromBool(jsvGetFirstChild(a)!=0);\n  assert(!jsvIsNameWithValue(a));\n  if (jsvIsName(a))\n    return jsvLockSafe(jsvGetFirstChild(a));\n  return 0;\n}\n\n/* Check for and trigger a ReferenceError on a variable if it's a name that doesn't exist */\nvoid jsvCheckReferenceError(JsVar *a) {\n  if (jsvIsBasicName(a) && jsvGetRefs(a)==0 && !jsvIsNewChild(a) && !jsvGetFirstChild(a))\n    jsExceptionHere(JSET_REFERENCEERROR, \"%q is not defined\", a);\n}\n\n\n\n/** If a is a name skip it and go to what it points to - and so on (if repeat=true).\n * ALWAYS locks - so must unlock what it returns. It MAY\n * return 0. Throws a ReferenceError if variable is not defined,\n * but you can check if it will with jsvIsReferenceError.\n * If a 'getter' needs to be executed, 'parent' is the object that\n * gets used unless a NewChild overwrites it */\nJsVar *jsvSkipNameWithParent(JsVar *a, bool repeat, JsVar *parent) {\n  if (!a) return 0;\n  if (jsvIsArrayBufferName(a)) return jsvArrayBufferGetFromName(a);\n  if (jsvIsNameInt(a)) return jsvNewFromInteger((JsVarInt)jsvGetFirstChildSigned(a));\n  if (jsvIsNameIntBool(a)) return jsvNewFromBool(jsvGetFirstChild(a)!=0);\n  JsVar *pa = jsvLockAgain(a);\n  while (jsvIsName(pa)) {\n    JsVarRef n = jsvGetFirstChild(pa);\n    jsvUnLock(pa);\n    if (!n) {\n      // check here as it's less likely we get here (=faster)\n      if (pa==a) jsvCheckReferenceError(a);\n      return 0;\n    }\n    pa = jsvLock(n);\n    assert(pa!=a);\n    if (!repeat) break;\n  }\n#ifndef SAVE_ON_FLASH\n  if (jsvIsGetterOrSetter(pa)) {\n    JsVar *getterParent = jsvIsNewChild(a)?jsvLock(jsvGetNextSibling(a)):0;\n    JsVar *v = jsvExecuteGetter(getterParent?getterParent:parent, pa);\n    jsvUnLock2(getterParent,pa);\n    pa = v;\n  }\n#endif\n  return pa;\n}\n\n/** If a is a name skip it and go to what it points to - and so on\n * ALWAYS locks - so must unlock what it returns. It MAY\n * return 0. Throws a ReferenceError if variable is not defined,\n * but you can check if it will with jsvIsReferenceError */\nJsVar *jsvSkipName(JsVar *a) {\n  return jsvSkipNameWithParent(a, true, 0);\n}\n\n/** If a is a name skip it and go to what it points to.\n * ALWAYS locks - so must unlock what it returns. It MAY\n * return 0. Throws a ReferenceError if variable is not defined,\n * but you can check if it will with jsvIsReferenceError */\nJsVar *jsvSkipOneName(JsVar *a) {\n  return jsvSkipNameWithParent(a, false, 0);\n}\n\n/** If a is a's child is a name skip it and go to what it points to.\n * ALWAYS locks - so must unlock what it returns.  */\nJsVar *jsvSkipToLastName(JsVar *a) {\n  assert(jsvIsName(a));\n  a = jsvLockAgain(a);\n  while (true) {\n    if (!jsvGetFirstChild(a)) return a;\n    JsVar *child = jsvLock(jsvGetFirstChild(a));\n    if (jsvIsName(child)) {\n      jsvUnLock(a);\n      a = child;\n    } else {\n      jsvUnLock(child);\n      return a;\n    }\n  }\n  return 0; // not called\n}\n\n/** Same as jsvSkipName, but ensures that 'a' is unlocked */\nJsVar *jsvSkipNameAndUnLock(JsVar *a) {\n  JsVar *b = jsvSkipName(a);\n  jsvUnLock(a);\n  return b;\n}\n\n/** Same as jsvSkipOneName, but ensures that 'a' is unlocked */\nJsVar *jsvSkipOneNameAndUnLock(JsVar *a) {\n  JsVar *b = jsvSkipOneName(a);\n  jsvUnLock(a);\n  return b;\n}\n\nbool jsvIsStringEqualOrStartsWithOffset(JsVar *var, const char *str, bool isStartsWith, size_t startIdx, bool ignoreCase) {\n  if (!jsvHasCharacterData(var)) {\n    return 0; // not a string so not equal!\n  }\n\n  JsvStringIterator it;\n  jsvStringIteratorNew(&it, var, startIdx);\n  if (ignoreCase) {\n      while (jsvStringIteratorHasChar(&it) && *str &&\n          charToLowerCase(jsvStringIteratorGetChar(&it)) == charToLowerCase(*str)) {\n        str++;\n        jsvStringIteratorNext(&it);\n      }\n  } else {\n      while (jsvStringIteratorHasChar(&it) && *str &&\n             jsvStringIteratorGetChar(&it) == *str) {\n        str++;\n        jsvStringIteratorNext(&it);\n      }\n  }\n  bool eq = (isStartsWith && !*str) ||\n            jsvStringIteratorGetChar(&it)==*str; // should both be 0 if equal\n  jsvStringIteratorFree(&it);\n  return eq;\n}\n\n/*\njsvIsStringEqualOrStartsWith(A, B, false) is a proper A==B\njsvIsStringEqualOrStartsWith(A, B, true) is A.startsWith(B)\n */\nbool jsvIsStringEqualOrStartsWith(JsVar *var, const char *str, bool isStartsWith) {\n  return jsvIsStringEqualOrStartsWithOffset(var, str, isStartsWith, 0, false);\n}\n\n// Also see jsvIsBasicVarEqual\nbool jsvIsStringEqual(JsVar *var, const char *str) {\n  return jsvIsStringEqualOrStartsWith(var, str, false);\n}\n\n// Also see jsvIsBasicVarEqual\nbool jsvIsStringIEqualAndUnLock(JsVar *var, const char *str) {\n  bool b = jsvIsStringEqualOrStartsWithOffset(var, str, false, 0, true);\n  jsvUnLock(var);\n  return b;\n}\n\n\n/** Compare 2 strings, starting from the given character positions. equalAtEndOfString means that\n * if one of the strings ends (even if the other hasn't), we treat them as equal.\n * For a basic strcmp, do: jsvCompareString(a,b,0,0,false)\n *  */\nint jsvCompareString(JsVar *va, JsVar *vb, size_t starta, size_t startb, bool equalAtEndOfString) {\n  JsvStringIterator ita, itb;\n  jsvStringIteratorNew(&ita, va, starta);\n  jsvStringIteratorNew(&itb, vb, startb);\n  // step to first positions\n  while (true) {\n    int ca = jsvStringIteratorGetCharOrMinusOne(&ita);\n    int cb = jsvStringIteratorGetCharOrMinusOne(&itb);\n\n    if (ca != cb) {\n      jsvStringIteratorFree(&ita);\n      jsvStringIteratorFree(&itb);\n      if ((ca<0 || cb<0) && equalAtEndOfString) return 0;\n      return ca - cb;\n    }\n    if (ca < 0) { // both equal, but end of string\n      jsvStringIteratorFree(&ita);\n      jsvStringIteratorFree(&itb);\n      return 0;\n    }\n    jsvStringIteratorNext(&ita);\n    jsvStringIteratorNext(&itb);\n  }\n  // never get here, but the compiler warns...\n  return true;\n}\n\n/** Return a new string containing just the characters that are\n * shared between two strings. */\nJsVar *jsvGetCommonCharacters(JsVar *va, JsVar *vb) {\n  JsVar *v = jsvNewFromEmptyString();\n  if (!v) return 0;\n  JsvStringIterator ita, itb;\n  jsvStringIteratorNew(&ita, va, 0);\n  jsvStringIteratorNew(&itb, vb, 0);\n  int ca = jsvStringIteratorGetCharOrMinusOne(&ita);\n  int cb = jsvStringIteratorGetCharOrMinusOne(&itb);\n  while (ca>0 && cb>0 && ca == cb) {\n    jsvAppendCharacter(v, (char)ca);\n    jsvStringIteratorNext(&ita);\n    jsvStringIteratorNext(&itb);\n    ca = jsvStringIteratorGetCharOrMinusOne(&ita);\n    cb = jsvStringIteratorGetCharOrMinusOne(&itb);\n  }\n  jsvStringIteratorFree(&ita);\n  jsvStringIteratorFree(&itb);\n  return v;\n}\n\n\n/** Compare 2 integers, >0 if va>vb,  <0 if va<vb. If compared with a non-integer, that gets put later */\nint jsvCompareInteger(JsVar *va, JsVar *vb) {\n  if (jsvIsInt(va) && jsvIsInt(vb))\n    return (int)(jsvGetInteger(va) - jsvGetInteger(vb));\n  else if (jsvIsInt(va))\n    return -1;\n  else if (jsvIsInt(vb))\n    return 1;\n  else\n    return 0;\n}\n\n/** Copy only a name, not what it points to. ALTHOUGH the link to what it points to is maintained unless linkChildren=false\n    If keepAsName==false, this will be converted into a normal variable */\nJsVar *jsvCopyNameOnly(JsVar *src, bool linkChildren, bool keepAsName) {\n  assert(jsvIsName(src));\n  JsVarFlags flags = src->flags;\n  JsVar *dst = 0;\n  if (!keepAsName) {\n    JsVarFlags t = src->flags & JSV_VARTYPEMASK;\n    if (t>=_JSV_NAME_INT_START && t<=_JSV_NAME_INT_END) {\n      flags = (flags & ~JSV_VARTYPEMASK) | JSV_INTEGER;\n    } else {\n      assert((JSV_NAME_STRING_INT_0 < JSV_NAME_STRING_0) &&\n          (JSV_NAME_STRING_0 < JSV_STRING_0) &&\n          (JSV_STRING_0 < JSV_STRING_EXT_0)); // this relies on ordering\n      assert(t>=JSV_NAME_STRING_INT_0 && t<=JSV_NAME_STRING_MAX);\n      if (jsvGetLastChild(src)) {\n        /* it's not a simple name string - it has STRING_EXT bits on the end.\n         * Because the max length of NAME and STRING is different we must just\n         * copy */\n        dst = jsvNewFromStringVar(src, 0, JSVAPPENDSTRINGVAR_MAXLENGTH);\n        if (!dst) return 0;\n      } else {\n        flags = (flags & (JsVarFlags)~JSV_VARTYPEMASK) | (JSV_STRING_0 + jsvGetCharactersInVar(src));\n      }\n    }\n  }\n  if (!dst) {\n    dst = jsvNewWithFlags(flags & JSV_VARIABLEINFOMASK);\n    if (!dst) return 0; // out of memory\n\n    memcpy(&dst->varData, &src->varData, JSVAR_DATA_STRING_NAME_LEN);\n\n    assert(jsvGetLastChild(dst) == 0);\n    assert(jsvGetFirstChild(dst) == 0);\n    assert(jsvGetPrevSibling(dst) == 0);\n    assert(jsvGetNextSibling(dst) == 0);\n    // Copy extra string data if there was any\n    if (jsvHasStringExt(src)) {\n      // If it had extra string data it should have been handled above\n      assert(keepAsName || !jsvGetLastChild(src));\n      // copy extra bits of string if there were any\n      if (jsvGetLastChild(src)) {\n        JsVar *child = jsvLock(jsvGetLastChild(src));\n        JsVar *childCopy = jsvCopy(child, true);\n        if (childCopy) { // could be out of memory\n          jsvSetLastChild(dst, jsvGetRef(childCopy)); // no ref for stringext\n          jsvUnLock(childCopy);\n        }\n        jsvUnLock(child);\n      }\n    } else {\n      assert(jsvIsBasic(src)); // in case we missed something!\n    }\n  }\n  // Copy LINK of what it points to\n  if (linkChildren && jsvGetFirstChild(src)) {\n    if (jsvIsNameWithValue(src))\n      jsvSetFirstChild(dst, jsvGetFirstChild(src));\n    else\n      jsvSetFirstChild(dst, jsvRefRef(jsvGetFirstChild(src)));\n  }\n  return dst;\n}\n\nJsVar *jsvCopy(JsVar *src, bool copyChildren) {\n  if (jsvIsFlatString(src)) {\n    // Copy a Flat String into a non-flat string - it's just safer\n    return jsvNewFromStringVar(src, 0, JSVAPPENDSTRINGVAR_MAXLENGTH);\n  }\n  JsVar *dst = jsvNewWithFlags(src->flags & JSV_VARIABLEINFOMASK);\n  if (!dst) return 0; // out of memory\n  if (!jsvIsStringExt(src)) {\n      bool refsAsData = jsvIsBasicString(src)||jsvIsNativeString(src)||jsvIsFlashString(src)||jsvIsNativeFunction(src);\n      memcpy(&dst->varData, &src->varData, refsAsData ? JSVAR_DATA_STRING_LEN : JSVAR_DATA_STRING_NAME_LEN);\n      if (jsvIsNativeFunction(src)) {\n        jsvSetFirstChild(dst,0);\n      }\n      if (!refsAsData) {\n        assert(jsvGetPrevSibling(dst) == 0);\n        assert(jsvGetNextSibling(dst) == 0);\n        assert(jsvGetFirstChild(dst) == 0);\n      }\n      assert(jsvGetLastChild(dst) == 0);\n  } else {\n    // stringexts use the extra pointers after varData to store characters\n    // see jsvGetMaxCharactersInVar\n    memcpy(&dst->varData, &src->varData, JSVAR_DATA_STRING_MAX_LEN);\n    assert(jsvGetLastChild(dst) == 0);\n  }\n\n  // Copy what names point to\n  if (copyChildren && jsvIsName(src)) {\n    if (jsvGetFirstChild(src)) {\n      if (jsvIsNameWithValue(src)) {\n        // name_int/etc don't need references\n        jsvSetFirstChild(dst, jsvGetFirstChild(src));\n      } else {\n        JsVar *child = jsvLock(jsvGetFirstChild(src));\n        JsVar *childCopy = jsvRef(jsvCopy(child, true));\n        jsvUnLock(child);\n        if (childCopy) { // could have been out of memory\n          jsvSetFirstChild(dst, jsvGetRef(childCopy));\n          jsvUnLock(childCopy);\n        }\n      }\n    }\n  }\n\n  if (jsvHasStringExt(src)) {\n    // copy extra bits of string if there were any\n    src = jsvLockAgain(src);\n    JsVar *dstChild = jsvLockAgain(dst);\n    while (jsvGetLastChild(src)) {\n      JsVar *child = jsvLock(jsvGetLastChild(src));\n      if (jsvIsStringExt(child)) {\n        JsVar *childCopy = jsvNewWithFlags(child->flags & JSV_VARIABLEINFOMASK);\n        if (childCopy) {// could be out of memory\n          memcpy(&childCopy->varData, &child->varData, JSVAR_DATA_STRING_MAX_LEN);\n          jsvSetLastChild(dstChild, jsvGetRef(childCopy)); // no ref for stringext\n        }\n        jsvUnLock2(src,dstChild);\n        src = child;\n        dstChild = childCopy;\n      } else {\n        JsVar *childCopy = jsvCopy(child, true);\n        if (childCopy) {// could be out of memory\n          jsvSetLastChild(dstChild, jsvGetRef(childCopy)); // no ref for stringext\n          jsvUnLock(childCopy);\n        }\n        jsvUnLock2(src, dstChild);\n        return dst;\n      }\n    }\n    jsvUnLock2(src,dstChild);\n  } else if (jsvHasChildren(src)) {\n    if (copyChildren) {\n      // Copy children..\n      JsVarRef vr;\n      vr = jsvGetFirstChild(src);\n      while (vr) {\n        JsVar *name = jsvLock(vr);\n        JsVar *child = jsvCopyNameOnly(name, true/*link children*/, true/*keep as name*/); // NO DEEP COPY!\n        if (child) { // could have been out of memory\n          jsvAddName(dst, child);\n          jsvUnLock(child);\n        }\n        vr = jsvGetNextSibling(name);\n        jsvUnLock(name);\n      }\n    }\n  } else {\n    assert(jsvIsBasic(src)); // in case we missed something!\n  }\n\n  return dst;\n}\n\nvoid jsvAddName(JsVar *parent, JsVar *namedChild) {\n  namedChild = jsvRef(namedChild); // ref here VERY important as adding to structure!\n  assert(jsvIsName(namedChild));\n\n  // update array length\n  if (jsvIsArray(parent) && jsvIsInt(namedChild)) {\n    JsVarInt index = namedChild->varData.integer;\n    if (index >= jsvGetArrayLength(parent)) {\n      jsvSetArrayLength(parent, index + 1, false);\n    }\n  }\n\n  if (jsvGetLastChild(parent)) { // we have children already\n    JsVar *insertAfter = jsvLock(jsvGetLastChild(parent));\n    if (jsvIsArray(parent)) {\n      // we must insert in order - so step back until we get the right place\n      while (insertAfter && jsvCompareInteger(namedChild, insertAfter)<0) {\n        JsVarRef prev = jsvGetPrevSibling(insertAfter);\n        jsvUnLock(insertAfter);\n        insertAfter = jsvLockSafe(prev);\n      }\n    }\n\n    if (insertAfter) {\n      if (jsvGetNextSibling(insertAfter)) {\n        // great, we're in the middle...\n        JsVar *insertBefore = jsvLock(jsvGetNextSibling(insertAfter));\n        jsvSetPrevSibling(insertBefore, jsvGetRef(namedChild));\n        jsvSetNextSibling(namedChild, jsvGetRef(insertBefore));\n        jsvUnLock(insertBefore);\n      } else {\n        // We're at the end - just set up the parent\n        jsvSetLastChild(parent, jsvGetRef(namedChild));\n      }\n      jsvSetNextSibling(insertAfter, jsvGetRef(namedChild));\n      jsvSetPrevSibling(namedChild, jsvGetRef(insertAfter));\n      jsvUnLock(insertAfter);\n    } else { // Insert right at the beginning of the array\n      // Link 2 children together\n      JsVar *firstChild = jsvLock(jsvGetFirstChild(parent));\n      jsvSetPrevSibling(firstChild, jsvGetRef(namedChild));\n      jsvUnLock(firstChild);\n\n      jsvSetNextSibling(namedChild, jsvGetFirstChild(parent));\n      // finally set the new child as the first one\n      jsvSetFirstChild(parent, jsvGetRef(namedChild));\n    }\n  } else { // we have no children - just add it\n    JsVarRef r = jsvGetRef(namedChild);\n    jsvSetFirstChild(parent, r);\n    jsvSetLastChild(parent, r);\n  }\n}\n\nJsVar *jsvAddNamedChild(JsVar *parent, JsVar *child, const char *name) {\n  JsVar *namedChild = jsvMakeIntoVariableName(jsvNewFromString(name), child);\n  if (!namedChild) return 0; // Out of memory\n  jsvAddName(parent, namedChild);\n  return namedChild;\n}\n\nJsVar *jsvSetNamedChild(JsVar *parent, JsVar *child, const char *name) {\n  JsVar *namedChild = jsvFindChildFromString(parent, name, true);\n  if (namedChild) // could be out of memory\n    return jsvSetValueOfName(namedChild, child);\n  return 0;\n}\n\nJsVar *jsvSetValueOfName(JsVar *name, JsVar *src) {\n  assert(name && jsvIsName(name));\n  assert(name!=src); // no infinite loops!\n  // all is fine, so replace the existing child...\n  /* Existing child may be null in the case of Z = 0 where\n   * we create 'Z' and pass it down to '=' to have the value\n   * filled in (or it may be undefined). */\n  if (jsvIsNameWithValue(name)) {\n    if (jsvIsString(name))\n      name->flags = (name->flags & (JsVarFlags)~JSV_VARTYPEMASK) | (JSV_NAME_STRING_0 + jsvGetCharactersInVar(name));\n    else\n      name->flags = (name->flags & (JsVarFlags)~JSV_VARTYPEMASK) | JSV_NAME_INT;\n    jsvSetFirstChild(name, 0);\n  } else if (jsvGetFirstChild(name))\n    jsvUnRefRef(jsvGetFirstChild(name)); // free existing\n  if (src) {\n    if (jsvIsInt(name)) {\n      if ((jsvIsInt(src) || jsvIsBoolean(src)) && !jsvIsPin(src)) {\n        JsVarInt v = src->varData.integer;\n        if (v>=JSVARREF_MIN && v<=JSVARREF_MAX) {\n          name->flags = (name->flags & (JsVarFlags)~JSV_VARTYPEMASK) | (jsvIsInt(src) ? JSV_NAME_INT_INT : JSV_NAME_INT_BOOL);\n          jsvSetFirstChild(name, (JsVarRef)v);\n          return name;\n        }\n      }\n    } else if (jsvIsString(name)) {\n      if (jsvIsInt(src) && !jsvIsPin(src)) {\n        JsVarInt v = src->varData.integer;\n        if (v>=JSVARREF_MIN && v<=JSVARREF_MAX) {\n          name->flags = (name->flags & (JsVarFlags)~JSV_VARTYPEMASK) | (JSV_NAME_STRING_INT_0 + jsvGetCharactersInVar(name));\n          jsvSetFirstChild(name, (JsVarRef)v);\n          return name;\n        }\n      }\n    }\n    // we can link to a name if we want (so can remove the assert!)\n    jsvSetFirstChild(name, jsvGetRef(jsvRef(src)));\n  } else\n    jsvSetFirstChild(name, 0);\n  return name;\n}\n\nJsVar *jsvFindChildFromString(JsVar *parent, const char *name, bool addIfNotFound) {\n  /* Pull out first 4 bytes, and ensure that everything\n   * is 0 padded so that we can do a nice speedy check. */\n  char fastCheck[4];\n  fastCheck[0] = name[0];\n  if (name[0]) {\n    fastCheck[1] = name[1];\n    if (name[1]) {\n      fastCheck[2] = name[2];\n      if (name[2]) {\n        fastCheck[3] = name[3];\n      } else {\n        fastCheck[3] = 0;\n      }\n    } else {\n      fastCheck[2] = 0;\n      fastCheck[3] = 0;\n    }\n  } else {\n    fastCheck[1] = 0;\n    fastCheck[2] = 0;\n    fastCheck[3] = 0;\n  }\n\n  assert(jsvHasChildren(parent));\n  JsVarRef childref = jsvGetFirstChild(parent);\n  while (childref) {\n    // Don't Lock here, just use GetAddressOf - to try and speed up the finding\n    // TODO: We can do this now, but when/if we move to cacheing vars, it'll break\n    JsVar *child = jsvGetAddressOf(childref);\n    if (*(int*)fastCheck==*(int*)child->varData.str && // speedy check of first 4 bytes\n        jsvIsStringEqual(child, name)) {\n      // found it! unlock parent but leave child locked\n      return jsvLockAgain(child);\n    }\n    childref = jsvGetNextSibling(child);\n  }\n\n  JsVar *child = 0;\n  if (addIfNotFound) {\n    child = jsvMakeIntoVariableName(jsvNewFromString(name), 0);\n    if (child) // could be out of memory\n      jsvAddName(parent, child);\n  }\n  return child;\n}\n\n/// Find a child with a matching name using a case insensitive search\nJsVar *jsvFindChildFromStringI(JsVar *parent, const char *name) {\n  assert(jsvHasChildren(parent));\n  JsVarRef childref = jsvGetFirstChild(parent);\n  while (childref) {\n    // Don't Lock here, just use GetAddressOf - to try and speed up the finding\n    // TODO: We can do this now, but when/if we move to cacheing vars, it'll break\n    JsVar *child = jsvGetAddressOf(childref);\n    if (jsvHasCharacterData(child) &&\n        jsvIsStringEqualOrStartsWithOffset(child, name, false, 0, true)) {\n      // found it! unlock parent but leave child locked\n      return jsvLockAgain(child);\n    }\n    childref = jsvGetNextSibling(child);\n  }\n  return 0;\n}\n\n/// See jsvIsNewChild - for fields that don't exist yet\nJsVar *jsvCreateNewChild(JsVar *parent, JsVar *index, JsVar *child) {\n  JsVar *newChild = jsvAsName(index);\n  if (!newChild) return 0;\n  assert(!jsvGetFirstChild(newChild));\n  if (child) jsvSetValueOfName(newChild, child);\n  assert(!jsvGetNextSibling(newChild) && !jsvGetPrevSibling(newChild));\n  // by setting the siblings as the same, we signal that if set,\n  // we should be made a member of the given object\n  JsVarRef r = jsvGetRef(jsvRef(jsvRef(parent)));\n  jsvSetNextSibling(newChild, r);\n  jsvSetPrevSibling(newChild, r);\n\n  return newChild;\n}\n\n/** Try and turn the supplied variable into a name. If not, make a new one. This locks again. */\nJsVar *jsvAsName(JsVar *var) {\n  if (!var) return 0;\n  if (jsvGetRefs(var) == 0) {\n    // Not reffed - great! let's just use it\n    if (!jsvIsName(var))\n      var = jsvMakeIntoVariableName(var, 0);\n    return jsvLockAgain(var);\n  } else { // it was reffed, we must add a new one\n    return jsvMakeIntoVariableName(jsvCopy(var, false), 0);\n  }\n}\n\n/** Non-recursive finding */\nJsVar *jsvFindChildFromVar(JsVar *parent, JsVar *childName, bool addIfNotFound) {\n  JsVar *child;\n  JsVarRef childref = jsvGetFirstChild(parent);\n\n  while (childref) {\n    child = jsvLock(childref);\n    if (jsvIsBasicVarEqual(child, childName)) {\n      // found it! unlock parent but leave child locked\n      return child;\n    }\n    childref = jsvGetNextSibling(child);\n    jsvUnLock(child);\n  }\n\n  child = 0;\n  if (addIfNotFound && childName) {\n    child = jsvAsName(childName);\n    jsvAddName(parent, child);\n  }\n  return child;\n}\n\nvoid jsvRemoveChild(JsVar *parent, JsVar *child) {\n  assert(jsvHasChildren(parent));\n  assert(jsvIsName(child));\n  JsVarRef childref = jsvGetRef(child);\n  bool wasChild = false;\n  // unlink from parent\n  if (jsvGetFirstChild(parent) == childref) {\n    jsvSetFirstChild(parent, jsvGetNextSibling(child));\n    wasChild = true;\n  }\n  if (jsvGetLastChild(parent) == childref) {\n    jsvSetLastChild(parent, jsvGetPrevSibling(child));\n    wasChild = true;\n    // If this was an array and we were the last\n    // element, update the length\n    if (jsvIsArray(parent)) {\n      JsVarInt l = 0;\n      // get index of last child\n      if (jsvGetLastChild(parent))\n        l = jsvGetIntegerAndUnLock(jsvLock(jsvGetLastChild(parent)))+1;\n      // set it\n      jsvSetArrayLength(parent, l, false);\n    }\n  }\n  // unlink from child list\n  if (jsvGetPrevSibling(child)) {\n    JsVar *v = jsvLock(jsvGetPrevSibling(child));\n    assert(jsvGetNextSibling(v) == jsvGetRef(child));\n    jsvSetNextSibling(v, jsvGetNextSibling(child));\n    jsvUnLock(v);\n    wasChild = true;\n  }\n  if (jsvGetNextSibling(child)) {\n    JsVar *v = jsvLock(jsvGetNextSibling(child));\n    assert(jsvGetPrevSibling(v) == jsvGetRef(child));\n    jsvSetPrevSibling(v, jsvGetPrevSibling(child));\n    jsvUnLock(v);\n    wasChild = true;\n  }\n\n  jsvSetPrevSibling(child, 0);\n  jsvSetNextSibling(child, 0);\n  if (wasChild)\n    jsvUnRef(child);\n}\n\nvoid jsvRemoveAllChildren(JsVar *parent) {\n  assert(jsvHasChildren(parent));\n  while (jsvGetFirstChild(parent)) {\n    JsVar *v = jsvLock(jsvGetFirstChild(parent));\n    jsvRemoveChild(parent, v);\n    jsvUnLock(v);\n  }\n}\n\n/// Check if the given name is a child of the parent\nbool jsvIsChild(JsVar *parent, JsVar *child) {\n  assert(jsvIsArray(parent) || jsvIsObject(parent));\n  assert(jsvIsName(child));\n  JsVarRef childref = jsvGetRef(child);\n  JsVarRef indexref;\n  indexref = jsvGetFirstChild(parent);\n  while (indexref) {\n    if (indexref == childref) return true;\n    // get next\n    JsVar *indexVar = jsvLock(indexref);\n    indexref = jsvGetNextSibling(indexVar);\n    jsvUnLock(indexVar);\n  }\n  return false; // not found undefined\n}\n\n/// Get the named child of an object. If createChild!=0 then create the child\nJsVar *jsvObjectGetChild(JsVar *obj, const char *name, JsVarFlags createChild) {\n  if (!obj) return 0;\n  assert(jsvHasChildren(obj));\n  JsVar *childName = jsvFindChildFromString(obj, name, createChild!=0);\n  JsVar *child = jsvSkipName(childName);\n  if (!child && createChild && childName!=0/*out of memory?*/) {\n    child = jsvNewWithFlags(createChild);\n    jsvSetValueOfName(childName, child);\n    jsvUnLock(childName);\n    return child;\n  }\n  jsvUnLock(childName);\n  return child;\n}\n\n/// Get the named child of an object using a case-insensitive search\nJsVar *jsvObjectGetChildI(JsVar *obj, const char *name) {\n  if (!obj) return 0;\n  assert(jsvHasChildren(obj));\n  return jsvSkipNameAndUnLock(jsvFindChildFromStringI(obj, name));\n}\n\n/// Set the named child of an object, and return the child (so you can choose to unlock it if you want)\nJsVar *jsvObjectSetChild(JsVar *obj, const char *name, JsVar *child) {\n  assert(jsvHasChildren(obj));\n  if (!jsvHasChildren(obj)) return 0;\n  // child can actually be a name (for instance if it is a named function)\n  JsVar *childName = jsvFindChildFromString(obj, name, true);\n  if (!childName) return 0; // out of memory\n  jsvSetValueOfName(childName, child);\n  jsvUnLock(childName);\n  return child;\n}\n\n/// Set the named child of an object, and return the child (so you can choose to unlock it if you want)\nJsVar *jsvObjectSetChildVar(JsVar *obj, JsVar *name, JsVar *child) {\n  assert(jsvHasChildren(obj));\n  if (!jsvHasChildren(obj)) return 0;\n  // child can actually be a name (for instance if it is a named function)\n  JsVar *childName = jsvFindChildFromVar(obj, name, true);\n  if (!childName) return 0; // out of memory\n  jsvSetValueOfName(childName, child);\n  jsvUnLock(childName);\n  return child;\n}\n\nvoid jsvObjectSetChildAndUnLock(JsVar *obj, const char *name, JsVar *child) {\n  jsvUnLock(jsvObjectSetChild(obj, name, child));\n}\n\nvoid jsvObjectRemoveChild(JsVar *obj, const char *name) {\n  JsVar *child = jsvFindChildFromString(obj, name, false);\n  if (child) {\n    jsvRemoveChild(obj, child);\n    jsvUnLock(child);\n  }\n}\n\n/** Set the named child of an object, and return the child (so you can choose to unlock it if you want).\n * If the child is 0, the 'name' is also removed from the object */\nJsVar *jsvObjectSetOrRemoveChild(JsVar *obj, const char *name, JsVar *child) {\n  if (child)\n    jsvObjectSetChild(obj, name, child);\n  else\n    jsvObjectRemoveChild(obj, name);\n  return child;\n}\n\n/** Append all keys from the source object to the target object. Will ignore hidden/internal fields */\nvoid jsvObjectAppendAll(JsVar *target, JsVar *source) {\n  assert(jsvIsObject(target));\n  assert(jsvIsObject(source));\n  JsvObjectIterator it;\n  jsvObjectIteratorNew(&it, source);\n  while (jsvObjectIteratorHasValue(&it)) {\n    JsVar *k = jsvObjectIteratorGetKey(&it);\n    JsVar *v = jsvSkipName(k);\n    if (!jsvIsInternalObjectKey(k))\n      jsvObjectSetChildVar(target, k, v);\n    jsvUnLock2(k,v);\n    jsvObjectIteratorNext(&it);\n  }\n  jsvObjectIteratorFree(&it);\n}\n\nint jsvGetChildren(const JsVar *v) {\n  //OPT: could length be stored as the value of the array?\n  int children = 0;\n  JsVarRef childref = jsvGetFirstChild(v);\n  while (childref) {\n    JsVar *child = jsvLock(childref);\n    children++;\n    childref = jsvGetNextSibling(child);\n    jsvUnLock(child);\n  }\n  return children;\n}\n\n/// Get the first child's name from an object,array or function\nJsVar *jsvGetFirstName(JsVar *v) {\n  assert(jsvHasChildren(v));\n  if (!jsvGetFirstChild(v)) return 0;\n  return jsvLock(jsvGetFirstChild(v));\n}\n\nJsVarInt jsvGetArrayLength(const JsVar *arr) {\n  if (!arr) return 0;\n  assert(jsvIsArray(arr));\n  return arr->varData.integer;\n}\n\nJsVarInt jsvSetArrayLength(JsVar *arr, JsVarInt length, bool truncate) {\n  assert(jsvIsArray(arr));\n  if (truncate && length < arr->varData.integer) {\n    // @TODO implement truncation here\n  }\n  arr->varData.integer = length;\n  return length;\n}\n\nJsVarInt jsvGetLength(const JsVar *src) {\n  if (jsvIsArray(src)) {\n    return jsvGetArrayLength(src);\n  } else if (jsvIsArrayBuffer(src)) {\n    return (JsVarInt)jsvGetArrayBufferLength(src);\n  } else if (jsvIsString(src)) {\n    return (JsVarInt)jsvGetStringLength(src);\n  } else if (jsvIsObject(src) || jsvIsFunction(src)) {\n    return jsvGetChildren(src);\n  } else {\n    return 1;\n  }\n}\n\n/** Count the amount of JsVars used. Mostly useful for debugging */\nstatic size_t _jsvCountJsVarsUsedRecursive(JsVar *v, bool resetRecursionFlag) {\n  if (!v) return 0;\n  // Use IS_RECURSING  flag to stop recursion\n  if (resetRecursionFlag) {\n    if (!(v->flags & JSV_IS_RECURSING))\n      return 0;\n    v->flags &= ~JSV_IS_RECURSING;\n  } else {\n    if (v->flags & JSV_IS_RECURSING)\n      return 0;\n    v->flags |= JSV_IS_RECURSING;\n  }\n\n  size_t count = 1;\n  if (jsvHasSingleChild(v) || jsvHasChildren(v)) {\n    JsVarRef childref = jsvGetFirstChild(v);\n    while (childref) {\n      JsVar *child = jsvLock(childref);\n      count += _jsvCountJsVarsUsedRecursive(child, resetRecursionFlag);\n      if (jsvHasChildren(v)) childref = jsvGetNextSibling(child);\n      else childref = 0;\n      jsvUnLock(child);\n    }\n  } else if (jsvIsFlatString(v))\n    count += jsvGetFlatStringBlocks(v);\n  if (jsvHasCharacterData(v)) {\n    JsVarRef childref = jsvGetLastChild(v);\n    while (childref) {\n      JsVar *child = jsvLock(childref);\n      count++;\n      childref = jsvGetLastChild(child);\n      jsvUnLock(child);\n    }\n  }\n  if (jsvIsName(v) && !jsvIsNameWithValue(v) && jsvGetFirstChild(v)) {\n    JsVar *child = jsvLock(jsvGetFirstChild(v));\n    count += _jsvCountJsVarsUsedRecursive(child, resetRecursionFlag);\n    jsvUnLock(child);\n  }\n  return count;\n}\n\n/** Count the amount of JsVars used. Mostly useful for debugging */\nsize_t jsvCountJsVarsUsed(JsVar *v) {\n  // don't count 'root' when getting sizes\n  if ((execInfo.root) && (v != execInfo.root)) execInfo.root->flags |= JSV_IS_RECURSING;\n  // we do this so we don't count the same item twice, but don't use too much memory\n  size_t c = _jsvCountJsVarsUsedRecursive(v, false);\n  _jsvCountJsVarsUsedRecursive(v, true);\n  // restore recurse flag\n  if ((execInfo.root) && (v != execInfo.root)) execInfo.root->flags &= ~JSV_IS_RECURSING;\n  return c;\n}\n\nJsVar *jsvGetArrayIndex(const JsVar *arr, JsVarInt index) {\n  JsVarRef childref = jsvGetLastChild(arr);\n  JsVarInt lastArrayIndex = 0;\n  // Look at last non-string element!\n  while (childref) {\n    JsVar *child = jsvLock(childref);\n    if (jsvIsInt(child)) {\n      lastArrayIndex = child->varData.integer;\n      // it was the last element... sorted!\n      if (lastArrayIndex == index) {\n        return child;\n      }\n      jsvUnLock(child);\n      break;\n    }\n    // if not an int, keep going\n    childref = jsvGetPrevSibling(child);\n    jsvUnLock(child);\n  }\n  // it's not in this array - don't search the whole lot...\n  if (index > lastArrayIndex)\n    return 0;\n  // otherwise is it more than halfway through?\n  if (index > lastArrayIndex/2) {\n    // it's in the final half of the array (probably) - search backwards\n    while (childref) {\n      JsVar *child = jsvLock(childref);\n\n      assert(jsvIsInt(child));\n      if (child->varData.integer == index) {\n        return child;\n      }\n      childref = jsvGetPrevSibling(child);\n      jsvUnLock(child);\n    }\n  } else {\n    // it's in the first half of the array (probably) - search forwards\n    childref = jsvGetFirstChild(arr);\n    while (childref) {\n      JsVar *child = jsvLock(childref);\n\n      assert(jsvIsInt(child));\n      if (child->varData.integer == index) {\n        return child;\n      }\n      childref = jsvGetNextSibling(child);\n      jsvUnLock(child);\n    }\n  }\n  return 0; // undefined\n}\n\nJsVar *jsvGetArrayItem(const JsVar *arr, JsVarInt index) {\n  return jsvSkipNameAndUnLock(jsvGetArrayIndex(arr,index));\n}\n\nJsVar *jsvGetLastArrayItem(const JsVar *arr) {\n  JsVarRef childref = jsvGetLastChild(arr);\n  if (!childref) return 0;\n  return jsvSkipNameAndUnLock(jsvLock(childref));\n}\n\nvoid jsvSetArrayItem(JsVar *arr, JsVarInt index, JsVar *item) {\n  JsVar *indexVar = jsvGetArrayIndex(arr, index);\n  if (indexVar) {\n    jsvSetValueOfName(indexVar, item);\n  } else {\n    indexVar = jsvMakeIntoVariableName(jsvNewFromInteger(index), item);\n    if (indexVar) // could be out of memory\n      jsvAddName(arr, indexVar);\n  }\n  jsvUnLock(indexVar);\n}\n\n// Get all elements from arr and put them in itemPtr (unless it'd overflow).\n// Makes sure all of itemPtr either contains a JsVar or 0\nvoid jsvGetArrayItems(JsVar *arr, unsigned int itemCount, JsVar **itemPtr) {\n  JsvObjectIterator it;\n  jsvObjectIteratorNew(&it, arr);\n  unsigned int i = 0;\n  while (jsvObjectIteratorHasValue(&it)) {\n    if (i<itemCount)\n      itemPtr[i++] = jsvObjectIteratorGetValue(&it);\n    jsvObjectIteratorNext(&it);\n  }\n  jsvObjectIteratorFree(&it);\n  while (i<itemCount)\n    itemPtr[i++] = 0; // just ensure we don't end up with bad data\n}\n\n/// Get the index of the value in the iterable var (matchExact==use pointer not equality check, matchIntegerIndices = don't check non-integers)\nJsVar *jsvGetIndexOfFull(JsVar *arr, JsVar *value, bool matchExact, bool matchIntegerIndices, int startIdx) {\n  if (!jsvIsIterable(arr)) return 0;\n  JsvIterator it;\n  jsvIteratorNew(&it, arr, JSIF_DEFINED_ARRAY_ElEMENTS);\n  while (jsvIteratorHasElement(&it)) {\n    JsVar *childIndex = jsvIteratorGetKey(&it);\n    if (!matchIntegerIndices ||\n        (jsvIsInt(childIndex) && jsvGetInteger(childIndex)>=startIdx)) {\n      JsVar *childValue = jsvIteratorGetValue(&it);\n      if (childValue==value ||\n          (!matchExact && jsvMathsOpTypeEqual(childValue, value))) {\n        jsvUnLock(childValue);\n        jsvIteratorFree(&it);\n        return childIndex;\n      }\n      jsvUnLock(childValue);\n    }\n    jsvUnLock(childIndex);\n    jsvIteratorNext(&it);\n  }\n  jsvIteratorFree(&it);\n  return 0; // undefined\n}\n\n/// Get the index of the value in the array or object (matchExact==use pointer, not equality check)\nJsVar *jsvGetIndexOf(JsVar *arr, JsVar *value, bool matchExact) {\n  return jsvGetIndexOfFull(arr, value, matchExact, false, 0);\n}\n\n\n/// Adds new elements to the end of an array, and returns the new length. initialValue is the item index when no items are currently in the array.\nJsVarInt jsvArrayAddToEnd(JsVar *arr, JsVar *value, JsVarInt initialValue) {\n  assert(jsvIsArray(arr));\n  JsVarInt index = initialValue;\n  if (jsvGetLastChild(arr)) {\n    JsVar *last = jsvLock(jsvGetLastChild(arr));\n    index = jsvGetInteger(last)+1;\n    jsvUnLock(last);\n  }\n\n  JsVar *idx = jsvMakeIntoVariableName(jsvNewFromInteger(index), value);\n  if (!idx) return 0; // out of memory - error flag will have been set already\n  jsvAddName(arr, idx);\n  jsvUnLock(idx);\n  return index+1;\n}\n\n/// Adds new elements to the end of an array, and returns the new length\nJsVarInt jsvArrayPush(JsVar *arr, JsVar *value) {\n  assert(jsvIsArray(arr));\n  JsVarInt index = jsvGetArrayLength(arr);\n  JsVar *idx = jsvMakeIntoVariableName(jsvNewFromInteger(index), value);\n  if (!idx) return 0; // out of memory - error flag will have been set already\n  jsvAddName(arr, idx);\n  jsvUnLock(idx);\n  return jsvGetArrayLength(arr);\n}\n\n/// Adds a new element to the end of an array, unlocks it, and returns the new length\nJsVarInt jsvArrayPushAndUnLock(JsVar *arr, JsVar *value) {\n  JsVarInt l = jsvArrayPush(arr, value);\n  jsvUnLock(value);\n  return l;\n}\n\n// Push 2 integers onto the end of an array\nvoid jsvArrayPush2Int(JsVar *arr, JsVarInt a, JsVarInt b) {\n  jsvArrayPushAndUnLock(arr, jsvNewFromInteger(a));\n  jsvArrayPushAndUnLock(arr, jsvNewFromInteger(b));\n}\n\n/// Append all values from the source array to the target array\nvoid jsvArrayPushAll(JsVar *target, JsVar *source, bool checkDuplicates) {\n  assert(jsvIsArray(target));\n  assert(jsvIsArray(source));\n  JsvObjectIterator it;\n  jsvObjectIteratorNew(&it, source);\n  while (jsvObjectIteratorHasValue(&it)) {\n    JsVar *v = jsvObjectIteratorGetValue(&it);\n    bool add = true;\n    if (checkDuplicates) {\n      JsVar *idx = jsvGetIndexOf(target, v, false);\n      if (idx) {\n        add = false;\n        jsvUnLock(idx);\n      }\n    }\n    if (add) jsvArrayPush(target, v);\n    jsvUnLock(v);\n    jsvObjectIteratorNext(&it);\n  }\n  jsvObjectIteratorFree(&it);\n}\n\n/// Removes the last element of an array, and returns that element (or 0 if empty). includes the NAME\nJsVar *jsvArrayPop(JsVar *arr) {\n  assert(jsvIsArray(arr));\n  JsVar *child = 0;\n  JsVarInt length = jsvGetArrayLength(arr);\n  if (length > 0) {\n    length--;\n\n    if (jsvGetLastChild(arr)) {\n      // find last child with an integer key\n      JsVarRef ref = jsvGetLastChild(arr);\n      child = jsvLock(ref);\n      while (child && !jsvIsInt(child)) {\n        ref = jsvGetPrevSibling(child);\n        jsvUnLock(child);\n        if (ref) {\n          child = jsvLock(ref);\n        } else {\n          child = 0;\n        }\n      }\n      // check if the last integer key really is the last element\n      if (child) {\n        if (jsvGetInteger(child) == length) {\n          // child is the last element - remove it\n          jsvRemoveChild(arr, child);\n        } else {\n          // child is not the last element\n          jsvUnLock(child);\n          child = 0;\n        }\n      }\n    }\n    // and finally shrink the array\n    jsvSetArrayLength(arr, length, false);\n  }\n\n  return child;\n}\n\n/// Removes the first element of an array, and returns that element (or 0 if empty). DOES NOT RENUMBER.\nJsVar *jsvArrayPopFirst(JsVar *arr) {\n  assert(jsvIsArray(arr));\n  if (jsvGetFirstChild(arr)) {\n    JsVar *child = jsvLock(jsvGetFirstChild(arr));\n    if (jsvGetFirstChild(arr) == jsvGetLastChild(arr))\n      jsvSetLastChild(arr, 0); // if 1 item in array\n    jsvSetFirstChild(arr, jsvGetNextSibling(child)); // unlink from end of array\n    jsvUnRef(child); // as no longer in array\n    if (jsvGetNextSibling(child)) {\n      JsVar *v = jsvLock(jsvGetNextSibling(child));\n      jsvSetPrevSibling(v, 0);\n      jsvUnLock(v);\n    }\n    jsvSetNextSibling(child, 0);\n    return child; // and return it\n  } else {\n    // no children!\n    return 0;\n  }\n}\n\n/// Adds a new variable element to the end of an array (IF it was not already there). Return true if successful\nvoid jsvArrayAddUnique(JsVar *arr, JsVar *v) {\n  JsVar *idx = jsvGetIndexOf(arr, v, false); // did it already exist?\n  if (!idx) {\n    jsvArrayPush(arr, v); // if 0, it failed\n  } else {\n    jsvUnLock(idx);\n  }\n}\n\n/// Join all elements of an array together into a string\nJsVar *jsvArrayJoin(JsVar *arr, JsVar *filler, bool ignoreNull) {\n  JsVar *str = jsvNewFromEmptyString();\n  if (!str) return 0; // out of memory\n  assert(!filler || jsvIsString(filler));\n\n  JsvIterator it;\n  jsvIteratorNew(&it, arr, JSIF_EVERY_ARRAY_ELEMENT);\n  JsvStringIterator itdst;\n  jsvStringIteratorNew(&itdst, str, 0);\n  bool first = true;\n  while (!jspIsInterrupted() && jsvIteratorHasElement(&it)) {\n    JsVar *key = jsvIteratorGetKey(&it);\n    if (jsvIsInt(key)) {\n      // add the filler\n      if (filler && !first)\n        jsvStringIteratorAppendString(&itdst, filler, 0, JSVAPPENDSTRINGVAR_MAXLENGTH);\n      first = false;\n      // add the value\n      JsVar *value = jsvIteratorGetValue(&it);\n      if (value && (!ignoreNull || !jsvIsNull(value))) {\n        JsVar *valueStr = jsvAsString(value);\n        if (valueStr) { // could be out of memory\n          jsvStringIteratorAppendString(&itdst, valueStr, 0, JSVAPPENDSTRINGVAR_MAXLENGTH);\n          jsvUnLock(valueStr);\n        }\n      }\n      jsvUnLock(value);\n    }\n    jsvUnLock(key);\n    jsvIteratorNext(&it);\n  }\n  jsvIteratorFree(&it);\n  jsvStringIteratorFree(&itdst);\n  return str;\n}\n\n/// Insert a new element before beforeIndex, DOES NOT UPDATE INDICES\nvoid jsvArrayInsertBefore(JsVar *arr, JsVar *beforeIndex, JsVar *element) {\n  if (beforeIndex) {\n    JsVar *idxVar = jsvMakeIntoVariableName(jsvNewFromInteger(0), element);\n    if (!idxVar) return; // out of memory\n\n    JsVarRef idxRef = jsvGetRef(jsvRef(idxVar));\n    JsVarRef prev = jsvGetPrevSibling(beforeIndex);\n    if (prev) {\n      JsVar *prevVar = jsvRef(jsvLock(prev));\n      jsvSetInteger(idxVar, jsvGetInteger(prevVar)+1); // update index number\n      jsvSetNextSibling(prevVar, idxRef);\n      jsvUnLock(prevVar);\n      jsvSetPrevSibling(idxVar, prev);\n    } else {\n      jsvSetPrevSibling(idxVar, 0);\n      jsvSetFirstChild(arr, idxRef);\n    }\n    jsvSetPrevSibling(beforeIndex, idxRef);\n    jsvSetNextSibling(idxVar, jsvGetRef(jsvRef(beforeIndex)));\n    jsvUnLock(idxVar);\n  } else\n    jsvArrayPush(arr, element);\n}\n\n/** Same as jsvMathsOpPtr, but if a or b are a name, skip them\n * and go to what they point to. Also handle the case where\n * they may be objects with valueOf functions. */\nJsVar *jsvMathsOpSkipNames(JsVar *a, JsVar *b, int op) {\n  JsVar *pa = jsvSkipName(a);\n  JsVar *pb = jsvSkipName(b);\n  JsVar *oa = jsvGetValueOf(pa);\n  JsVar *ob = jsvGetValueOf(pb);\n  jsvUnLock2(pa, pb);\n  JsVar *res = jsvMathsOp(oa,ob,op);\n  jsvUnLock2(oa, ob);\n  return res;\n}\n\n\nJsVar *jsvMathsOpError(int op, const char *datatype) {\n  char opName[32];\n  jslTokenAsString(op, opName, sizeof(opName));\n  jsError(\"Operation %s not supported on the %s datatype\", opName, datatype);\n  return 0;\n}\n\nbool jsvMathsOpTypeEqual(JsVar *a, JsVar *b) {\n  // check type first, then call again to check data\n  bool eql = (a==0) == (b==0);\n  if (a && b) {\n    // Check whether both are numbers, otherwise check the variable\n    // type flags themselves\n    eql = ((jsvIsInt(a)||jsvIsFloat(a)) && (jsvIsInt(b)||jsvIsFloat(b))) ||\n          (jsvIsString(a) && jsvIsString(b)) ||\n          ((a->flags & JSV_VARTYPEMASK) == (b->flags & JSV_VARTYPEMASK));\n  }\n  if (eql) {\n    JsVar *contents = jsvMathsOp(a,b, LEX_EQUAL);\n    if (!jsvGetBool(contents)) eql = false;\n    jsvUnLock(contents);\n  } else {\n    /* Make sure we don't get in the situation where we have two equal\n     * strings with a check that fails because they were stored differently */\n    assert(!(jsvIsString(a) && jsvIsString(b) && jsvIsBasicVarEqual(a,b)));\n  }\n  return eql;\n}\n\nJsVar *jsvMathsOp(JsVar *a, JsVar *b, int op) {\n  // Type equality check\n  if (op == LEX_TYPEEQUAL || op == LEX_NTYPEEQUAL) {\n    bool eql = jsvMathsOpTypeEqual(a,b);\n    if (op == LEX_TYPEEQUAL)\n      return jsvNewFromBool(eql);\n    else\n      return jsvNewFromBool(!eql);\n  }\n\n  bool needsInt = op=='&' || op=='|' || op=='^' || op==LEX_LSHIFT || op==LEX_RSHIFT || op==LEX_RSHIFTUNSIGNED;\n  bool needsNumeric = needsInt || op=='*' || op=='/' || op=='%' || op=='-';\n  bool isCompare = op==LEX_EQUAL || op==LEX_NEQUAL || op=='<' || op==LEX_LEQUAL || op=='>'|| op==LEX_GEQUAL;\n  if (isCompare) {\n    if (jsvIsNumeric(a) && jsvIsString(b)) {\n      needsNumeric = true;\n      needsInt = jsvIsIntegerish(a) && jsvIsStringNumericInt(b, false);\n    } else if (jsvIsNumeric(b) && jsvIsString(a)) {\n      needsNumeric = true;\n      needsInt = jsvIsIntegerish(b) && jsvIsStringNumericInt(a, false);\n    }\n  }\n\n  // do maths...\n  if (jsvIsUndefined(a) && jsvIsUndefined(b)) {\n    if (op == LEX_EQUAL)\n      return jsvNewFromBool(true);\n    else if (op == LEX_NEQUAL)\n      return jsvNewFromBool(false);\n    else\n      return 0; // undefined\n  } else if (needsNumeric ||\n      ((jsvIsNumeric(a) || jsvIsUndefined(a) || jsvIsNull(a)) &&\n          (jsvIsNumeric(b) || jsvIsUndefined(b) || jsvIsNull(b)))) {\n    if (needsInt || (jsvIsIntegerish(a) && jsvIsIntegerish(b))) {\n      // note that int+undefined should be handled as a double\n      // use ints\n      JsVarInt da = jsvGetInteger(a);\n      JsVarInt db = jsvGetInteger(b);\n      switch (op) {\n      case '+': return jsvNewFromLongInteger((long long)da + (long long)db);\n      case '-': return jsvNewFromLongInteger((long long)da - (long long)db);\n      case '*': return jsvNewFromLongInteger((long long)da * (long long)db);\n      case '/': return jsvNewFromFloat((JsVarFloat)da/(JsVarFloat)db);\n      case '&': return jsvNewFromInteger(da&db);\n      case '|': return jsvNewFromInteger(da|db);\n      case '^': return jsvNewFromInteger(da^db);\n      case '%': if (db<0) db=-db; // fix SIGFPE\n                return db ? jsvNewFromInteger(da%db) : jsvNewFromFloat(NAN);\n      case LEX_LSHIFT: return jsvNewFromInteger(da << db);\n      case LEX_RSHIFT: return jsvNewFromInteger(da >> db);\n      case LEX_RSHIFTUNSIGNED: return jsvNewFromLongInteger(((JsVarIntUnsigned)da) >> db);\n      case LEX_EQUAL:     return jsvNewFromBool(da==db && jsvIsNull(a)==jsvIsNull(b));\n      case LEX_NEQUAL:    return jsvNewFromBool(da!=db || jsvIsNull(a)!=jsvIsNull(b));\n      case '<':           return jsvNewFromBool(da<db);\n      case LEX_LEQUAL:    return jsvNewFromBool(da<=db);\n      case '>':           return jsvNewFromBool(da>db);\n      case LEX_GEQUAL:    return jsvNewFromBool(da>=db);\n      default: return jsvMathsOpError(op, \"Integer\");\n      }\n    } else {\n      // use doubles\n      JsVarFloat da = jsvGetFloat(a);\n      JsVarFloat db = jsvGetFloat(b);\n      switch (op) {\n      case '+': return jsvNewFromFloat(da+db);\n      case '-': return jsvNewFromFloat(da-db);\n      case '*': return jsvNewFromFloat(da*db);\n      case '/': return jsvNewFromFloat(da/db);\n      case '%': return jsvNewFromFloat(jswrap_math_mod(da, db));\n      case LEX_EQUAL:\n      case LEX_NEQUAL:  { bool equal = da==db && jsvIsNull(a)==jsvIsNull(b);\n      if ((jsvIsNull(a) && jsvIsUndefined(b)) ||\n          (jsvIsNull(b) && jsvIsUndefined(a))) equal = true; // JS quirk :)\n      return jsvNewFromBool((op==LEX_EQUAL) ? equal : ((bool)!equal));\n      }\n      case '<':           return jsvNewFromBool(da<db);\n      case LEX_LEQUAL:    return jsvNewFromBool(da<=db);\n      case '>':           return jsvNewFromBool(da>db);\n      case LEX_GEQUAL:    return jsvNewFromBool(da>=db);\n      default: return jsvMathsOpError(op, \"Double\");\n      }\n    }\n  } else if ((jsvIsArray(a) || jsvIsObject(a) || jsvIsFunction(a) ||\n      jsvIsArray(b) || jsvIsObject(b) || jsvIsFunction(b)) &&\n      jsvIsArray(a)==jsvIsArray(b) && // Fix #283 - convert to string and test if only one is an array\n      (op == LEX_EQUAL || op==LEX_NEQUAL)) {\n    bool equal = a==b;\n\n    if (jsvIsNativeFunction(a) || jsvIsNativeFunction(b)) {\n      // even if one is not native, the contents will be different\n      equal = a && b && \n          a->varData.native.ptr == b->varData.native.ptr &&\n          a->varData.native.argTypes == b->varData.native.argTypes &&\n          jsvGetFirstChild(a) == jsvGetFirstChild(b);\n    }\n\n    /* Just check pointers */\n    switch (op) {\n    case LEX_EQUAL:  return jsvNewFromBool(equal);\n    case LEX_NEQUAL: return jsvNewFromBool(!equal);\n    default: return jsvMathsOpError(op, jsvIsArray(a)?\"Array\":\"Object\");\n    }\n  } else {\n    JsVar *da = jsvAsString(a);\n    JsVar *db = jsvAsString(b);\n    if (!da || !db) { // out of memory\n      jsvUnLock2(da, db);\n      return 0;\n    }\n    if (op=='+') {\n      JsVar *v;\n      // Don't copy 'da' if it's not used elsewhere (eg we made it in 'jsvAsString' above)\n      if (jsvIsBasicString(da) && jsvGetLocks(da)==1 && jsvGetRefs(da)==0)\n        v = jsvLockAgain(da);\n      else\n        v = jsvCopy(da, false);\n      if (v) // could be out of memory\n        jsvAppendStringVarComplete(v, db);\n      jsvUnLock2(da, db);\n      return v;\n    }\n\n    int cmp = jsvCompareString(da,db,0,0,false);\n    jsvUnLock2(da, db);\n    // use strings\n    switch (op) {\n    case LEX_EQUAL:     return jsvNewFromBool(cmp==0);\n    case LEX_NEQUAL:    return jsvNewFromBool(cmp!=0);\n    case '<':           return jsvNewFromBool(cmp<0);\n    case LEX_LEQUAL:    return jsvNewFromBool(cmp<=0);\n    case '>':           return jsvNewFromBool(cmp>0);\n    case LEX_GEQUAL:    return jsvNewFromBool(cmp>=0);\n    default: return jsvMathsOpError(op, \"String\");\n    }\n  }\n}\n\nJsVar *jsvNegateAndUnLock(JsVar *v) {\n  JsVar *zero = jsvNewFromInteger(0);\n  JsVar *res = jsvMathsOpSkipNames(zero, v, '-');\n  jsvUnLock2(zero, v);\n  return res;\n}\n\n/// see jsvGetPathTo\nstatic JsVar *jsvGetPathTo_int(JsVar *root, JsVar *element, int maxDepth, JsVar *ignoreParent, int *depth) {\n  if (maxDepth<=0) return 0;\n\n  int bestDepth = maxDepth+1;\n  JsVar *found = 0;\n\n  JsvIterator it;\n  jsvIteratorNew(&it, root, JSIF_DEFINED_ARRAY_ElEMENTS);\n  while (jsvIteratorHasElement(&it)) {\n    JsVar *el = jsvIteratorGetValue(&it);\n    if (el == element && root != ignoreParent) {\n      // if we found it - send the key name back!\n      JsVar *name = jsvAsStringAndUnLock(jsvIteratorGetKey(&it));\n      jsvIteratorFree(&it);\n      return name;\n    } else if (jsvIsObject(el) || jsvIsArray(el) || jsvIsFunction(el)) {\n      // recursively search\n      int d;\n      JsVar *n = jsvGetPathTo_int(el, element, maxDepth-1, ignoreParent, &d);\n      if (n && d<bestDepth) {\n        bestDepth = d;\n        // we found it! Append our name onto it as well\n        JsVar *keyName = jsvIteratorGetKey(&it);\n        jsvUnLock(found);\n        found = jsvVarPrintf(jsvIsObject(el) ? \"%v.%v\" : \"%v[%q]\",keyName,n);\n        jsvUnLock(keyName);\n      }\n      jsvUnLock(n);\n    }\n    jsvIteratorNext(&it);\n  }\n  jsvIteratorFree(&it);\n  *depth = bestDepth;\n  return found;\n}\n\n/** If the given element is found, return the path to it as a string of\n * the form 'foo.bar', else return 0. If we would have returned a.b and\n * ignoreParent is a, don't! */\nJsVar *jsvGetPathTo(JsVar *root, JsVar *element, int maxDepth, JsVar *ignoreParent) {\n  int depth = 0;\n  return jsvGetPathTo_int(root, element, maxDepth, ignoreParent, &depth);\n}\n\nvoid jsvTraceLockInfo(JsVar *v) {\n  jsiConsolePrintf(\"#%d[r%d,l%d] \",jsvGetRef(v),jsvGetRefs(v),jsvGetLocks(v));\n}\n\n/** Get the lowest level at which searchRef appears */\nint _jsvTraceGetLowestLevel(JsVar *var, JsVar *searchVar) {\n  if (var == searchVar) return 0;\n  int found = -1;\n\n  // Use IS_RECURSING  flag to stop recursion\n  if (var->flags & JSV_IS_RECURSING)\n    return -1;\n  var->flags |= JSV_IS_RECURSING;\n\n  if (jsvHasSingleChild(var) && jsvGetFirstChild(var)) {\n    JsVar *child = jsvLock(jsvGetFirstChild(var));\n    int f = _jsvTraceGetLowestLevel(child, searchVar);\n    jsvUnLock(child);\n    if (f>=0 && (found<0 || f<found)) found=f+1;\n  }\n  if (jsvHasChildren(var)) {\n    JsVarRef childRef = jsvGetFirstChild(var);\n    while (childRef) {\n      JsVar *child = jsvLock(childRef);\n      int f = _jsvTraceGetLowestLevel(child, searchVar);\n      if (f>=0 && (found<0 || f<found)) found=f+1;\n      childRef = jsvGetNextSibling(child);\n      jsvUnLock(child);\n    }\n  }\n\n  var->flags &= ~JSV_IS_RECURSING;\n\n  return found; // searchRef not found\n}\n\nvoid _jsvTrace(JsVar *var, int indent, JsVar *baseVar, int level) {\n#ifdef SAVE_ON_FLASH\n  jsiConsolePrint(\"Trace unimplemented in this version.\\n\");\n#else\n  int i;\n  for (i=0;i<indent;i++) jsiConsolePrint(\" \");\n\n\n  if (!var) {\n    jsiConsolePrint(\"undefined\");\n    return;\n  }\n  if (level>0 && var==execInfo.root) {\n    jsiConsolePrint(\"ROOT\");\n    return;\n  }\n\n  jsvTraceLockInfo(var);\n\n  int lowestLevel = _jsvTraceGetLowestLevel(baseVar, var);\n  if (level>16 || (lowestLevel>=0 && lowestLevel < level)) {\n    // If this data is available elsewhere in the tree (but nearer the root)\n    // then don't print it. This makes the dump significantly more readable!\n    // It also stops us getting in recursive loops ...\n    jsiConsolePrint(\"...\\n\");\n    return;\n  }\n\n  if (jsvIsNewChild(var)) {\n    jsiConsolePrint(\"NewChild PARENT:\");\n    JsVar *parent = jsvGetAddressOf(jsvGetNextSibling(var));\n    _jsvTrace(parent, indent+2, baseVar, level+1);\n    jsiConsolePrint(\"CHILD: \");\n  } else if (jsvIsName(var)) jsiConsolePrint(\"Name \");\n\n  char endBracket = ' ';\n  if (jsvIsObject(var)) { jsiConsolePrint(\"Object { \"); endBracket = '}'; }\n  else if (jsvIsGetterOrSetter(var)) { jsiConsolePrint(\"Getter/Setter { \"); endBracket = '}'; }\n  else if (jsvIsArray(var)) { jsiConsolePrintf(\"Array(%d) [ \", var->varData.integer); endBracket = ']'; }\n  else if (jsvIsNativeFunction(var)) { jsiConsolePrintf(\"NativeFunction 0x%x (%d) { \", var->varData.native.ptr, var->varData.native.argTypes); endBracket = '}'; }\n  else if (jsvIsFunction(var)) {\n    jsiConsolePrint(\"Function { \");\n    if (jsvIsFunctionReturn(var)) jsiConsolePrint(\"return \");\n    endBracket = '}';\n  } else if (jsvIsPin(var)) jsiConsolePrintf(\"Pin %d\", jsvGetInteger(var));\n  else if (jsvIsInt(var)) jsiConsolePrintf(\"Integer %d\", jsvGetInteger(var));\n  else if (jsvIsBoolean(var)) jsiConsolePrintf(\"Bool %s\", jsvGetBool(var)?\"true\":\"false\");\n  else if (jsvIsFloat(var)) jsiConsolePrintf(\"Double %f\", jsvGetFloat(var));\n  else if (jsvIsFunctionParameter(var)) jsiConsolePrintf(\"Param %q \", var);\n  else if (jsvIsArrayBufferName(var)) jsiConsolePrintf(\"ArrayBufferName[%d] \", jsvGetInteger(var));\n  else if (jsvIsArrayBuffer(var)) jsiConsolePrintf(\"%s (offs %d, len %d)\", jswGetBasicObjectName(var)?jswGetBasicObjectName(var):\"unknown ArrayBuffer\", var->varData.arraybuffer.byteOffset, var->varData.arraybuffer.length); // way to get nice name\n  else if (jsvIsString(var)) {\n    size_t blocks = 1;\n    if (jsvGetLastChild(var)) {\n      JsVar *v = jsvGetAddressOf(jsvGetLastChild(var));\n      blocks += jsvCountJsVarsUsed(v);\n    }\n    if (jsvIsFlatString(var)) {\n      blocks += jsvGetFlatStringBlocks(var);\n    }\n    const char *name = \"\";\n    if (jsvIsFlatString(var)) name=\"Flat\";\n    if (jsvIsNativeString(var)) name=\"Native\";\n    if (jsvIsFlashString(var)) name=\"Flash\";\n    jsiConsolePrintf(\"%sString [%d blocks] %q\", name, blocks, var);\n  } else {\n    jsiConsolePrintf(\"Unknown %d\", var->flags & (JsVarFlags)~(JSV_LOCK_MASK));\n  }\n\n  // print a value if it was stored in here as well...\n  if (jsvIsNameInt(var)) {\n    jsiConsolePrintf(\"= int %d\\n\", (int)jsvGetFirstChildSigned(var));\n    return;\n  } else if (jsvIsNameIntBool(var)) {\n    jsiConsolePrintf(\"= bool %s\\n\", jsvGetFirstChild(var)?\"true\":\"false\");\n    return;\n  }\n\n  if (jsvHasSingleChild(var)) {\n    JsVar *child = jsvGetFirstChild(var) ? jsvGetAddressOf(jsvGetFirstChild(var)) : 0;\n    _jsvTrace(child, indent+2, baseVar, level+1);\n  } else if (jsvHasChildren(var)) {\n    JsvIterator it;\n    jsvIteratorNew(&it, var, JSIF_DEFINED_ARRAY_ElEMENTS);\n    bool first = true;\n    while (jsvIteratorHasElement(&it) && !jspIsInterrupted()) {\n      if (first) jsiConsolePrintf(\"\\n\");\n      first = false;\n      JsVar *child = jsvIteratorGetKey(&it);\n      _jsvTrace(child, indent+2, baseVar, level+1);\n      jsvUnLock(child);\n      jsiConsolePrintf(\"\\n\");\n      jsvIteratorNext(&it);\n    }\n    jsvIteratorFree(&it);\n    if (!first)\n      for (i=0;i<indent;i++) jsiConsolePrint(\" \");\n  }\n  jsiConsolePrintf(\"%c\", endBracket);\n#endif\n}\n\n/** Write debug info for this Var out to the console */\nvoid jsvTrace(JsVar *var, int indent) {\n  /* Clear memory busy flags. If we're calling\n   * trace then we really care about getting an answer */\n  MemBusyType t = isMemoryBusy;\n  isMemoryBusy = 0;\n  _jsvTrace(var,indent,var,0);\n  isMemoryBusy = t;\n  jsiConsolePrintf(\"\\n\");\n}\n\n\n/** Recursively mark the variable. Return false if it fails due to stack. */\nstatic bool jsvGarbageCollectMarkUsed(JsVar *var) {\n  var->flags &= (JsVarFlags)~JSV_GARBAGE_COLLECT;\n  JsVarRef child;\n  JsVar *childVar;\n\n  if (jsvHasCharacterData(var)) {\n    // non-recursively scan strings\n    child = jsvGetLastChild(var);\n    while (child) {\n      childVar = jsvGetAddressOf(child);\n      childVar->flags &= (JsVarFlags)~JSV_GARBAGE_COLLECT;\n      child = jsvGetLastChild(childVar);\n    }\n  }\n  // intentionally no else\n  if (jsvHasSingleChild(var)) {\n    if (jsvGetFirstChild(var)) {\n      childVar = jsvGetAddressOf(jsvGetFirstChild(var));\n      if (childVar->flags & JSV_GARBAGE_COLLECT)\n        if (!jsvGarbageCollectMarkUsed(childVar)) return false;\n    }\n  } else if (jsvHasChildren(var)) {\n    if (jsuGetFreeStack() < 256) return false;\n\n    child = jsvGetFirstChild(var);\n    while (child) {\n      childVar = jsvGetAddressOf(child);\n      if (childVar->flags & JSV_GARBAGE_COLLECT)\n        if (!jsvGarbageCollectMarkUsed(childVar)) return false;\n      child = jsvGetNextSibling(childVar);\n    }\n  }\n\n  return true;\n}\n\n/** Run a garbage collection sweep - return nonzero if things have been freed */\nint jsvGarbageCollect() {\n  if (isMemoryBusy) return 0;\n  isMemoryBusy = MEMBUSY_GC;\n  JsVarRef i;\n  // Add GC flags to anything that is currently used\n  for (i=1;i<=jsVarsSize;i++)  {\n    JsVar *var = jsvGetAddressOf(i);\n    if ((var->flags&JSV_VARTYPEMASK) != JSV_UNUSED) { // if it is not unused\n      var->flags |= (JsVarFlags)JSV_GARBAGE_COLLECT;\n      // if we have a flat string, skip that many blocks\n      if (jsvIsFlatString(var))\n        i = (JsVarRef)(i+jsvGetFlatStringBlocks(var));\n    }\n  }\n  /* recursively remove anything that is referenced from a var that is locked. */\n  for (i=1;i<=jsVarsSize;i++)  {\n    JsVar *var = jsvGetAddressOf(i);\n    if ((var->flags & JSV_GARBAGE_COLLECT) && // not already GC'd\n        jsvGetLocks(var)>0) { // or it is locked\n      if (!jsvGarbageCollectMarkUsed(var)) {\n        // this could fail due to stack exhausted (eg big linked list)\n        // JSV_GARBAGE_COLLECT are left set, but not a big problem as next GC will clear them\n        isMemoryBusy = MEM_NOT_BUSY;\n        return 0;\n      }\n    }\n    // if we have a flat string, skip that many blocks\n    if (jsvIsFlatString(var))\n      i = (JsVarRef)(i+jsvGetFlatStringBlocks(var));\n  }\n  /* now sweep for things that we can GC!\n   * Also update the free list - this means that every new variable that\n   * gets allocated gets allocated towards the start of memory, which\n   * hopefully helps compact everything towards the start. */\n  unsigned int freedCount = 0;\n  jsVarFirstEmpty = 0;\n  JsVar *lastEmpty = 0;\n  for (i=1;i<=jsVarsSize;i++)  {\n    JsVar *var = jsvGetAddressOf(i);\n    if (var->flags & JSV_GARBAGE_COLLECT) {\n      if (jsvIsFlatString(var)) {\n        // If we're a flat string, there are more blocks to free.\n        unsigned int count = (unsigned int)jsvGetFlatStringBlocks(var);\n        freedCount+=count;\n        // Free the first block\n        var->flags = JSV_UNUSED;\n        // add this to our free list\n        if (lastEmpty) jsvSetNextSibling(lastEmpty, i);\n        else jsVarFirstEmpty = i;\n        lastEmpty = var;\n        // free subsequent blocks\n        while (count-- > 0) {\n          i++;\n          var = jsvGetAddressOf((JsVarRef)(i));\n          var->flags = JSV_UNUSED;\n          // add this to our free list\n          if (lastEmpty) jsvSetNextSibling(lastEmpty, i);\n          else jsVarFirstEmpty = i;\n          lastEmpty = var;\n        }\n      } else {\n        // otherwise just free 1 block\n        if (jsvHasSingleChild(var)) {\n          /* If this had a child that wasn't listed for GC then we need to\n           * unref it. Everything else is fine because it'll disappear anyway.\n           * We don't have to check if we should free this other variable\n           * here because we know the GC picked up it was referenced from\n           * somewhere else. */\n          JsVarRef ch = jsvGetFirstChild(var);\n          if (ch) {\n            JsVar *child = jsvGetAddressOf(ch); // not locked\n            if (child->flags!=JSV_UNUSED && // not already GC'd!\n                !(child->flags&JSV_GARBAGE_COLLECT)) // not marked for GC\n              jsvUnRef(child);\n          }\n        }\n        /* Sanity checks here. We're making sure that any variables that are\n         * linked from this one have either already been garbage collected or\n         * are marked for GC */\n        assert(!jsvHasChildren(var) || !jsvGetFirstChild(var) ||\n            jsvGetLocks(jsvGetAddressOf(jsvGetFirstChild(var))) ||\n            jsvGetAddressOf(jsvGetFirstChild(var))->flags==JSV_UNUSED ||\n            (jsvGetAddressOf(jsvGetFirstChild(var))->flags&JSV_GARBAGE_COLLECT));\n        assert(!jsvHasChildren(var) || !jsvGetLastChild(var) ||\n            jsvGetLocks(jsvGetAddressOf(jsvGetLastChild(var))) ||\n            jsvGetAddressOf(jsvGetLastChild(var))->flags==JSV_UNUSED ||\n            (jsvGetAddressOf(jsvGetLastChild(var))->flags&JSV_GARBAGE_COLLECT));\n        assert(!jsvIsName(var) || !jsvGetPrevSibling(var) ||\n            jsvGetLocks(jsvGetAddressOf(jsvGetPrevSibling(var))) ||\n            jsvGetAddressOf(jsvGetPrevSibling(var))->flags==JSV_UNUSED ||\n            (jsvGetAddressOf(jsvGetPrevSibling(var))->flags&JSV_GARBAGE_COLLECT));\n        assert(!jsvIsName(var) || !jsvGetNextSibling(var) ||\n            jsvGetLocks(jsvGetAddressOf(jsvGetNextSibling(var))) ||\n            jsvGetAddressOf(jsvGetNextSibling(var))->flags==JSV_UNUSED ||\n            (jsvGetAddressOf(jsvGetNextSibling(var))->flags&JSV_GARBAGE_COLLECT));\n        // free!\n        var->flags = JSV_UNUSED;\n        // add this to our free list\n        if (lastEmpty) jsvSetNextSibling(lastEmpty, i);\n        else jsVarFirstEmpty = i;\n        lastEmpty = var;\n        freedCount++;\n      }\n    } else if (jsvIsFlatString(var)) {\n      // if we have a flat string, skip forward that many blocks\n      i = (JsVarRef)(i+jsvGetFlatStringBlocks(var));\n    } else if (var->flags == JSV_UNUSED) {\n      // this is already free - add it to the free list\n      if (lastEmpty) jsvSetNextSibling(lastEmpty, i);\n      else jsVarFirstEmpty = i;\n      lastEmpty = var;\n    }\n  }\n  if (lastEmpty) jsvSetNextSibling(lastEmpty, 0);\n  isMemoryBusy = MEM_NOT_BUSY;\n  return (int)freedCount;\n}\n\nvoid jsvDefragment() {\n  // garbage collect - removes cruft\n  // also puts free list in order\n  jsvGarbageCollect();\n  // Fill defragVars with defraggable variables\n  jshInterruptOff();\n  const int DEFRAGVARS = 256; // POWER OF 2\n  JsVarRef defragVars[DEFRAGVARS];\n  memset(defragVars, 0, sizeof(defragVars));\n  int defragVarIdx = 0;\n  for (int i=0;i<jsvGetMemoryTotal();i++) {\n    JsVarRef vr = i+1;\n    JsVar *v = _jsvGetAddressOf(vr);\n    if ((v->flags&JSV_VARTYPEMASK)!=JSV_UNUSED) {\n      if (jsvIsFlatString(v)) {\n        i += jsvGetFlatStringBlocks(v); // skip forward\n      } else if (jsvGetLocks(v)==0) {\n        defragVars[defragVarIdx] = vr;\n        defragVarIdx = (defragVarIdx+1) & (DEFRAGVARS-1);\n      }\n    }\n  }\n  // Now go through defragVars defragging them\n  defragVarIdx--;\n  if (defragVarIdx<0) defragVarIdx+=DEFRAGVARS;\n  while (defragVars[defragVarIdx]) {\n    JsVarRef defragFromRef = defragVars[defragVarIdx];\n    JsVarRef defragToRef = jsVarFirstEmpty;\n    if (!defragToRef || defragFromRef<defragToRef) {\n      // we're done!\n      break;\n    }\n    // relocate!\n    JsVar *defragFrom = _jsvGetAddressOf(defragFromRef);\n    JsVar *defragTo = _jsvGetAddressOf(defragToRef);\n    jsVarFirstEmpty = jsvGetNextSibling(defragTo); // move our reference to the next in the free list\n    // copy data\n    *defragTo = *defragFrom;\n    defragFrom->flags = JSV_UNUSED;\n    // find references!\n    for (int i=0;i<jsvGetMemoryTotal();i++) {\n      JsVarRef vr = i+1;\n      JsVar *v = _jsvGetAddressOf(vr);\n      if ((v->flags&JSV_VARTYPEMASK)!=JSV_UNUSED) {\n        if (jsvIsFlatString(v)) {\n          i += jsvGetFlatStringBlocks(v); // skip forward\n        } else {\n          if (jsvHasSingleChild(v))\n            if (jsvGetFirstChild(v)==defragFromRef)\n              jsvSetFirstChild(v,defragToRef);\n          if (jsvHasStringExt(v))\n            if (jsvGetLastChild(v)==defragFromRef)\n              jsvSetLastChild(v,defragToRef);\n          if (jsvHasChildren(v)) {\n            if (jsvGetFirstChild(v)==defragFromRef)\n              jsvSetFirstChild(v,defragToRef);\n            if (jsvGetLastChild(v)==defragFromRef)\n              jsvSetLastChild(v,defragToRef);\n          }\n          if (jsvIsName(v)) {\n            if (jsvGetNextSibling(v)==defragFromRef)\n              jsvSetNextSibling(v,defragToRef);\n            if (jsvGetPrevSibling(v)==defragFromRef)\n              jsvSetPrevSibling(v,defragToRef);\n          }\n        }\n      }\n    }\n    // zero element and move to next...\n    defragVars[defragVarIdx] = 0;\n    defragVarIdx--;\n    if (defragVarIdx<0) defragVarIdx+=DEFRAGVARS;\n  }\n  // rebuild free var list\n  jsvCreateEmptyVarList();\n  jshInterruptOn();\n}\n\n// Dump any locked variables that aren't referenced from `global` - for debugging memory leaks\nvoid jsvDumpLockedVars() {\n  jsvGarbageCollect();\n  if (isMemoryBusy) return;\n  isMemoryBusy = MEMBUSY_SYSTEM;\n  JsVarRef i;\n  // clear garbage collect flags\n  for (i=1;i<=jsVarsSize;i++)  {\n    JsVar *var = jsvGetAddressOf(i);\n    if ((var->flags&JSV_VARTYPEMASK) != JSV_UNUSED) { // if it is not unused\n      var->flags |= (JsVarFlags)JSV_GARBAGE_COLLECT;\n      // if we have a flat string, skip that many blocks\n      if (jsvIsFlatString(var))\n        i = (JsVarRef)(i+jsvGetFlatStringBlocks(var));\n    }\n  }\n  // Add global\n  jsvGarbageCollectMarkUsed(execInfo.root);\n  // Now dump any that aren't used!\n  for (i=1;i<=jsVarsSize;i++)  {\n    JsVar *var = jsvGetAddressOf(i);\n    if ((var->flags&JSV_VARTYPEMASK) != JSV_UNUSED) {\n      if (var->flags & JSV_GARBAGE_COLLECT) {\n        jsvGarbageCollectMarkUsed(var);\n        jsvTrace(var, 0);\n      }\n    }\n  }\n  isMemoryBusy = MEM_NOT_BUSY;\n}\n\n// Dump the free list - in order\nvoid jsvDumpFreeList() {\n  JsVarRef ref = jsVarFirstEmpty;\n  int n = 0;\n  while (ref) {\n    jsiConsolePrintf(\"%5d \", (int)ref);\n    if (++n >= 16) {\n      n = 0;\n      jsiConsolePrintf(\"\\n\");\n    }\n    JsVar *v = jsvGetAddressOf(ref);\n    ref = jsvGetNextSibling(v);\n  }\n  jsiConsolePrintf(\"\\n\");\n}\n\n\n/** Remove whitespace to the right of a string - on MULTIPLE LINES */\nJsVar *jsvStringTrimRight(JsVar *srcString) {\n  JsvStringIterator src, dst;\n  JsVar *dstString = jsvNewFromEmptyString();\n  jsvStringIteratorNew(&src, srcString, 0);\n  jsvStringIteratorNew(&dst, dstString, 0);\n  int spaces = 0;\n  while (jsvStringIteratorHasChar(&src)) {\n    char ch = jsvStringIteratorGetCharAndNext(&src);\n\n    if (ch==' ') spaces++;\n    else if (ch=='\\n') {\n      spaces = 0;\n      jsvStringIteratorAppend(&dst, ch);\n    } else {\n      for (;spaces>0;spaces--)\n        jsvStringIteratorAppend(&dst, ' ');\n      jsvStringIteratorAppend(&dst, ch);\n    }\n  }\n  jsvStringIteratorFree(&src);\n  jsvStringIteratorFree(&dst);\n  return dstString;\n}\n\n/// If v is the key of a function, return true if it is internal and shouldn't be visible to the user\nbool jsvIsInternalFunctionKey(JsVar *v) {\n  return (jsvIsString(v) && (\n      v->varData.str[0]==JS_HIDDEN_CHAR)\n  ) ||\n  jsvIsFunctionParameter(v);\n}\n\n/// If v is the key of an object, return true if it is internal and shouldn't be visible to the user\nbool jsvIsInternalObjectKey(JsVar *v) {\n  return (jsvIsString(v) && (\n      v->varData.str[0]==JS_HIDDEN_CHAR ||\n      jsvIsStringEqual(v, JSPARSE_INHERITS_VAR) ||\n      jsvIsStringEqual(v, JSPARSE_CONSTRUCTOR_VAR)\n  ));\n}\n\n/// Get the correct checker function for the given variable. see jsvIsInternalFunctionKey/jsvIsInternalObjectKey\nJsvIsInternalChecker jsvGetInternalFunctionCheckerFor(JsVar *v) {\n  if (jsvIsFunction(v)) return jsvIsInternalFunctionKey;\n  if (jsvIsObject(v)) return jsvIsInternalObjectKey;\n  return 0;\n}\n\n/** Using 'configs', this reads 'object' into the given pointers, returns true on success.\n *  If object is not undefined and not an object, an error is raised.\n *  If there are fields that are not  in the list of configs, an error is raised\n */\nbool jsvReadConfigObject(JsVar *object, jsvConfigObject *configs, int nConfigs) {\n  if (jsvIsUndefined(object)) return true;\n  if (!jsvIsObject(object)) {\n    jsExceptionHere(JSET_ERROR, \"Expecting an Object, or undefined\");\n    return false;\n  }\n  // Ok, it's an object\n  JsvObjectIterator it;\n  jsvObjectIteratorNew(&it, object);\n  bool ok = true;\n  while (ok && jsvObjectIteratorHasValue(&it)) {\n    JsVar *key = jsvObjectIteratorGetKey(&it);\n    bool found = false;\n    for (int i=0;i<nConfigs;i++) {\n      if (jsvIsStringEqual(key, configs[i].name)) {\n        found = true;\n        if (configs[i].ptr) {\n          JsVar *val = jsvObjectIteratorGetValue(&it);\n          switch (configs[i].type) {\n          case 0: break;\n          case JSV_OBJECT:\n          case JSV_STRING_0:\n          case JSV_ARRAY:\n          case JSV_FUNCTION:\n            *((JsVar**)configs[i].ptr) = jsvLockAgain(val); break;\n          case JSV_PIN: *((Pin*)configs[i].ptr) = jshGetPinFromVar(val); break;\n          case JSV_BOOLEAN: *((bool*)configs[i].ptr) = jsvGetBool(val); break;\n          case JSV_INTEGER: *((JsVarInt*)configs[i].ptr) = jsvGetInteger(val); break;\n          case JSV_FLOAT: *((JsVarFloat*)configs[i].ptr) = jsvGetFloat(val); break;\n          default: assert(0); break;\n          }\n          jsvUnLock(val);\n        }\n      }\n    }\n    if (!found) {\n      jsExceptionHere(JSET_ERROR, \"Unknown option %q\", key);\n      ok = false;\n    }\n    jsvUnLock(key);\n\n    jsvObjectIteratorNext(&it);\n  }\n  jsvObjectIteratorFree(&it);\n  return ok;\n}\n\n/** Using data in the format passed to jsvReadConfigObject, reconstruct a new object  */\nJsVar *jsvCreateConfigObject(jsvConfigObject *configs, int nConfigs) {\n  JsVar *o = jsvNewObject();\n  if (!o) return 0;\n  for (int i=0;i<nConfigs;i++) {\n     if (configs[i].ptr) {\n      JsVar *v = 0;\n      switch (configs[i].type) {\n      case 0: break;\n      case JSV_OBJECT:\n      case JSV_STRING_0:\n      case JSV_ARRAY:\n      case JSV_FUNCTION:\n        v = jsvLockAgain(*((JsVar**)configs[i].ptr)); break;\n      case JSV_PIN:\n        v = jsvNewFromPin(*((Pin*)configs[i].ptr)); break;\n      case JSV_BOOLEAN:\n        v = jsvNewFromBool(*((bool*)configs[i].ptr)); break;\n      case JSV_INTEGER:\n        v = jsvNewFromInteger(*((JsVarInt*)configs[i].ptr)); break;\n      case JSV_FLOAT:\n        v = jsvNewFromFloat(*((JsVarFloat*)configs[i].ptr)); break;\n      }\n      jsvObjectSetChildAndUnLock(o, configs[i].name, v);\n    }\n  }\n  return o;\n}\n\n/// Is the variable an instance of the given class. Eg. `jsvIsInstanceOf(e, \"Error\")` - does a simple, non-recursive check that doesn't take account of builtins like String\nbool jsvIsInstanceOf(JsVar *var, const char *constructorName) {\n  bool isInst = false;\n  if (!jsvHasChildren(var)) return false;\n  JsVar *proto = jsvObjectGetChild(var, JSPARSE_INHERITS_VAR, 0);\n  if (jsvIsObject(proto)) {\n    JsVar *constr = jsvObjectGetChild(proto, JSPARSE_CONSTRUCTOR_VAR, 0);\n    if (constr)\n      isInst = jspIsConstructor(constr, constructorName);\n    jsvUnLock(constr);\n  }\n  jsvUnLock(proto);\n  return isInst;\n}\n\nJsVar *jsvNewTypedArray(JsVarDataArrayBufferViewType type, JsVarInt length) {\n  JsVar *lenVar = jsvNewFromInteger(length);\n  if (!lenVar) return 0;\n  JsVar *array = jswrap_typedarray_constructor(type, lenVar,0,0);\n  jsvUnLock(lenVar);\n  return array;\n}\n\n#ifndef NO_DATAVIEW\nJsVar *jsvNewDataViewWithData(JsVarInt length, unsigned char *data) {\n  JsVar *buf = jswrap_arraybuffer_constructor(length);\n  if (!buf) return 0;\n  JsVar *view = jswrap_dataview_constructor(buf, 0, 0);\n  if (!view) {\n    jsvUnLock(buf);\n    return 0;\n  }\n  if (data) {\n    JsVar *arrayBufferData = jsvGetArrayBufferBackingString(buf, NULL);\n    if (arrayBufferData)\n      jsvSetString(arrayBufferData, (char *)data, (size_t)length);\n    jsvUnLock(arrayBufferData);\n  }\n  jsvUnLock(buf);\n  return view;\n}\n#endif\n\nJsVar *jsvNewArrayBufferWithPtr(unsigned int length, char **ptr) {\n  assert(ptr);\n  *ptr=0;\n  JsVar *backingString = jsvNewFlatStringOfLength(length);\n  if (!backingString) return 0;\n  JsVar *arr = jsvNewArrayBufferFromString(backingString, length);\n  if (!arr) {\n    jsvUnLock(backingString);\n    return 0;\n  }\n  *ptr = jsvGetFlatStringPointer(backingString);\n  jsvUnLock(backingString);\n  return arr;\n}\n\nJsVar *jsvNewArrayBufferWithData(JsVarInt length, unsigned char *data) {\n  assert(data);\n  assert(length>0);\n  JsVar *dst = 0;\n  JsVar *arr = jsvNewArrayBufferWithPtr((unsigned int)length, (char**)&dst);\n  if (!dst) {\n    jsvUnLock(arr);\n    return 0;\n  }\n  memcpy(dst, data, (size_t)length);\n  return arr;\n}\n\nvoid *jsvMalloc(size_t size) {\n  assert(size>0);\n  /** Allocate flat string, return pointer to its first element.\n   * As we drop the pointer here, it's left locked. jsvGetFlatStringPointer\n   * is also safe if 0 is passed in.  */\n  JsVar *flatStr = jsvNewFlatStringOfLength((unsigned int)size);\n  if (!flatStr) {\n    jsErrorFlags |= JSERR_LOW_MEMORY;\n    // Not allocated - try and free any command history/etc\n    while (jsiFreeMoreMemory());\n    // Garbage collect\n    jsvGarbageCollect();\n    // Try again\n    flatStr = jsvNewFlatStringOfLength((unsigned int)size);\n  }\n  // intentionally no jsvUnLock - see above\n  void *p = (void*)jsvGetFlatStringPointer(flatStr);\n  if (p) {\n    //jsiConsolePrintf(\"jsvMalloc var %d-%d at %d (%d bytes)\\n\", jsvGetRef(flatStr), jsvGetRef(flatStr)+jsvGetFlatStringBlocks(flatStr), p, size);\n    memset(p,0,size);\n  }\n  return p;\n}\n\nvoid jsvFree(void *ptr) {\n  JsVar *flatStr = jsvGetFlatStringFromPointer((char *)ptr);\n  //jsiConsolePrintf(\"jsvFree var %d at %d (%d bytes)\\n\", jsvGetRef(flatStr), ptr, jsvGetLength(flatStr));\n\n  jsvUnLock(flatStr);\n}\n"], "fixing_code": ["            Memory usage improvement: Function scopes no longer stored as an array if they only contain one scope\n            Memory usage improvement: The root scope is never stored in the scope list (it's searched by default)\n            E.dumpVariables now dumps variable flags\n            Tidying up Native Function handling (now JSV_NATIVE_FUNCTION not JSV_NATIVE|JSV_FUNCTION)\n            NRF.getSecurityStatus now returns 'connected_addr' for the address of the currently-connected device\n            NRF.setAdvertising converts arrays of arrays to arrays of ArrayBuffers. Also don't update advertising when connected.\n            Memory usage improvement: Arrow functions only store value of 'this' if 'this' is used by code inside them (fix #2139)\n            Add String.prototype.concat (fix #2140)\n            Much-improved whitespace lexing code using single jumptable - 3% speed increase\n            Allow `process.memory(false)` to get memory info but skip GC\n            Graphics: fix height calculation bug in fillRect/clearRect when given an object with w/h as an argument\n            Fix potential corruption issue caused by `delete [].__proto__` (fix #2142)\n\n     2v12 : nRF52840: Flow control XOFF is now sent at only 3/8th full - delays in BLE mean we can sometimes fill our 1k input buffer otherwise\n            __FILE__ is now set correctly for apps (fixes 2v11 regression)\n            Bangle.js: Ensure Bangle.getHealthStatus(\"day\") resets at midnight (fix https://github.com/espruino/BangleApps/issues/1216)\n            Bangle.js: Attempt to fix Bangle.buzz that occasionally doesn't stop\n            Bangle.js2: Lower bootloader LCD SPI bitrate (was out of spec, not all LCDs worked with it)\n            Bangle.js: Attempt to fix occasional issue where vibration gets stuck on (fix https://github.com/espruino/BangleApps/issues/1249)\n            Bangle.js: Ensure Bangle.setLCDPower only fires lcdPower event if state has changed (fix https://github.com/espruino/BangleApps/issues/1138)\n            Bangle.js2: Holding BTN at boot skips bootloader storage check, bootloader now times out if too many files\n            Bangle.js: Move position of filesystem checks to before first code is run\n            Storage.write is now explicit about not allowing zero length files, also creates exception if it fails because it can't get a data pointer\n            Bangle.js2: Only handle UBX protocol from GPS on Bangle.js 1 as it interferes with CASIC on Bangle.js 2 (fix #2124)\n            Bangle.js: GPS-raw no longer sets the FIFO_FULL message if data is lost - just passes a bool as the second argument\n            Fix for buffer overflow + segv found via fuzzing (#2121, #2122)\n            new Date(str) no longer interprets ISO 8601 UTC timestamps as local time (fix #2116)\n            Graphics: Fix clipRect checks for >1x bitmap fonts\n            Allow __proto__ to be set to a function as well as object\n            Bangle.js: Support for v2.1 barometer hardware (SPL06 vs BMP280)\n            Bangle.js: Increase step counting noise threshold 14->17 to work around pedometer fake steps (http://forum.espruino.com/conversations/371740)\n            Bangle.js: Support for v2.1 HRM hardware (VC31 vs VC31B)\n            Bangle.js: Better HRM detection (higher res filtering, better peak detection, lower median filter size, better confidence)\n            Fix E.decodeUTF8 when decoding UTF8 codes that contain all decimal digits\n            Fix for potential buffer overrun if JSON.stringify used with strangely crafted whitespace arg (fix #2114)\n            Add `NRF.setSecurity({encryptUart:true})` to force encrypted comms on BLE UART\n            Bangle.js2: Increase wait after power-on for BMP280 to fix getPressure on some devices (fix #2120)\n            Storage: Fix compaction error if a page starts with 0xff and the first write fits within that (fix #2009)\n            Add NRF.startBonding to force bonding on peripheral connection\n            nRF5x: Disable name change over BLE via 0x2A00\n            Bangle.js1/2 : Fix inconsitent scroll indicator in menus (fix #2104)\n            Bangle.js2: E.showScroller to respect widgets on bottom row (using appRect)\n            Bangle.js: Step counter - Remove hard-coded gravity value and subtract DC offset with a filter\n            Ensure jsfIsStorageValid kicks watchdog so we can't get stuck in a reboot loop if all of Storage is empty\n            Bangle.js: Add 'graphicsInternal' to make Graphics independent of JS vars. Terminal is now useful earlier, and can display softdevice errors\n            Bangle.js2: If errors do happen during Bangle.getPressure, reject the promise (fix #2137)\n\n     2v11 : Bangle.js: Enable the Bangle.on('tap') event from the accelerometer by default\n            Bangle.js: revert to (better) Kionix default thresholds for tap detect\n            Bangle.js2: When wake on touch is enabled, use a single tap on the front of the device for wakeup\n            Bangle.js: Display 'checking storage' message on first boot to alert users to slight delay\n            Bangle.js: Tweaked step count algorithm (low pass filter, 4 steps in 90s)\n            Graphics: asBMP/asURL/dump now support more bit depths\n            Graphics: Allow .setFont/.getFont to use font size in a colon after the font name\n            Graphics: .getFonts now lists 'setFont' functions however they were added (to `g`, built in, or to the prototype)\n            Graphics: When rendering fonts with a solid background, ensure the gap between is filled too\n            Flat Strings are now always aligned on a 4 byte boundary (fix #2040)\n            Graphics: add setTheme on supported devices\n            RAK5010: switch to 1.8v internal voltage (was 3.3v) to make GSM comms reliable, upgrade BG96 module\n            RAK5010: Compile in TLS/HTTPS support\n            Bangle.js: Fix issue where if non-fullscreen notification was visible and Bangle.js reset, screen was off-center\n            Fix for issue with pretokenised code not creating correct text string for reserved words, eg {undefined:1}\n            Bangle.js: Turn vibrate off every time a new app loads\n            Fix issue where ({a:0}).a in the console would create a ReferenceError (works in code)\n            Graphics: Allow setFont(\"FontName:1x2\") for scaling in 2 directions (fix #2044)\n            Graphics: Fix .asBMP for 4 bit images\n            Graphics: switch RGB order for palette in asBMP for 4/8 bit images\n            Bangle.js2: Idle power consumption down from 1.3mA to 0.9mA (pullups on HRM disabled when off)\n            Bangle.js2: Increase reported bit depth from 3->16 and perform bayer dithering when rendering\n              Makes icons/old apps way more usable (plus provides an easy way to get >3bpp)\n            Bangle.js: Fix color palette when rendering 3bpp -> 16bpp\n            nRF52840: Fix 900uA UART power draw when shut down\n            nRF52: Send XON/XOFF when buffer is less full - reduce likelihood of FIFO_FULL with big MTUs\n            Bangle.js: Fix powerSave regression (should default to 'on', but didn't since 2v10)\n            Storage test on boot only tests storage fully if the first record is empty\n            Graphics: drawString now accepts images in-line (fix #2063)\n            Graphics: added stringMetrics to get height as well as width\n            Graphics: drawString now correctly middle-aligns multi-line strings\n            Graphics: add imageMetrics to allow image width/height to be read\n            Graphics: drawImage(...,{frame:x}) can be used to draw animations\n            Graphics: fix rotated/scaled rendering of 3 bit bitmaps (fix #2049)\n            Bangle.js: fix Bangle.getLogo memory leak\n            Bangle.js2: Graphics.getBPP now returns 3\n            Bangle.js: attempt to unlock SPI flash multiple times (some devices don't unlock on the first attempt)\n            Bangle.js: Fix Bangle.tap event regression (now works again)\n            Graphics: add wrapString to wrap messages to the correct length\n            Bangle.js: update showMessage and showPrompt with correct wrapping\n            Bangle.js2: Add Bangle.compassRd, fix setCompassPower\n            Bangle.js: Add Bangle.on('health',..) event and Bangle.getHealthStatus\n            Graphics: drawImage now honours arraybuffer offsets\n            Graphics: drawImage now supports up to 4bpp palettes rendered direct from flash\n            Bangle.js2: Larger font for E.showMenu\n            Graphics: drawString(..., true) for vector fonts now clears the background\n            nRF52: swap getSerial bytes around so device ID string matches nrfjprog\n            Bangle.js2: bootloader can now flash firmware from a file in Storage\n            Bangle.js2: Add second Storage area in internal flash for fast access, memory-mapped files\n            Fix unhandled reject of a previously resolved promise (fix #1433)\n            Bangle.js: E.showMessage/showPrompt can now display images via optional img argument\n                       E.showMessage/showPrompt handle padding correctly if no widgets are displayed\n            Bangle.js2: Fix setUI clockupdown handling of 'up' \n            Bangle.js: Ensure builtin E.show* (and fake LEDs) wake the LCD up\n            Storage check now *only* happens on first boot\n            Ensure __FILE__ is set by the time bootcode runs\n            If executing from storage, work out line numbers and print filename for Errors\n            Bangle.js: Don't store line numbers in functions - no need when execing from flash\n            Bangle.js: Add E.showScroller for scrollable lists\n            Fix issue where invalid JSON stopped execution after Storage.readJSON\n            Bangle.js: Add Storage.hash for boot0 cache change checking\n            Bangle.js: A single widget load failure will now not remove all widgets\n            Bangle.js: widgets are now sorted by .sortorder\n            While and for loop conditions now use Expression, not AssignmentExpression (eg. while(0,0) is fine) (fix #2068)\n            Bangle.js2: Fix 'stuck' bottom row of pixels if scrolling downwards with g.scroll(0,1)\n            Bangle.js: Fix issue where minified E.showMenu was creating a global var called 'c'\n            Fix string formatting for \"Field or method X does not already exist\" error\n            Graphics: drawRect,fillRect,clearRect are now able to take an object as the first argument\n            Bangle.js: Add Bangle.appRect to allow apps to see how much space is available for them\n            Bangle.js: Add `Bangle.setOptions({hrmPollInterval:...});`\n            Bangle.js2: Bangle.dragHandler is now cleared by setUI (fix #2078)\n            Bangle.js2: Adjust full battery voltage\n            Avoid Watchdog reboot during compact if compacting a lot of data (fix #2075)\n            Storage: Fix issue where compacting empty storage could cause out of bounds erase (fix #2081)\n            Fix issue where pretokenised '1 - - 1' would turn to '1--1' (fix #2086)\n            Fix break scoping error in nested for loops (fix #2084)\n            Fix memory leak when rejecting pre-resolved promise (test_promise11.js)\n            Fix parser errors in arrow functions (fix #2067)\n            Bangle.js2: Add Unistroke object, and 'Bangle.stroke' event\n            Fix pretokenised '1 / /.../' and ensure jslSeek resets the previous token (ref #2086)\n            nRF52: Move neopixel LRCK pin which can't be disabled due to hardware errata, and restore state after (fix #2071)\n            Bangle.js2: Disable unboard flash bank for now (issues with erase on reboot)\n            Bangle.js1: Fix E.showScroller implementation\n            Bangle.js2: Ensure tap and twist turn LCD backlight on as well as unlocking\n            Bangle.js1: Bangle.setUI now deletes touchHandler (fix #2095)\n            Bangle.js2: Tweak battery high mark again\n            Bangle.js2: Fix E.showScroller when there are less than 3 menu items\n            Bangle.js2: Bangle.off and .softOff now turn off touchscreen if it was on \n            Bangle.js2: Ensure antialiased line routines are built in\n            Bangle.js2: Add HRM wear detection (LED no longer turns on if HRM not on skin)\n            Bangle.js2: Add a 32 entry cache to speed up finding common files - improves app load times\n            Bangle.js: Ensure locale honours 12 hour setting (https://github.com/espruino/BangleApps/issues/892)\n            Bangle.js2: Ensure EXTCOMIN time for LCD is nearer 2us (from datasheet) (ref #2097)\n            Bangle.js2: New default JS firmware\n            Bangle.js2: Minify Bangle.drawWidgets\n            Bangle.js: Bangle.appRect now copes with widgets at the bottom\n            Bangle.js2: Fix >128 ASCII codes for 12x20 font (fix #2105)\n            Bangle.js: Add SPI flash read-after-write to verify write succeeded (fix #2109)\n            Bangle.js: Fix E.showMenu clear if background color is set (https://github.com/espruino/BangleApps/issues/1024)\n            Bangle.js: Re-add E.showMenu predraw callback (fix #2108)\n            Bangle.js2: Add hrmRd/hrmWr that allow you to poke the HRM directly\n            Bangle.js: Fix for previous SPI flash write verify when <4 bytes written\n            Bangle.js2: Add write protection for bootloader and softdevice to avoid accidental bricking\n            Bangle.js2: Bootloader now attempts multiple times to initialise ext flash, and waits longer (fix fw update app issues)\n            Bangle.js: Add Bangle.getHealthStatus(\"day\") to allow automatic step counts for the current day\n            Remove for(of/in) for extremely constrained devices (Micro:bit 1 only)\n            Bangle.js: bootloader now doesn't start immediately after power off (can help with 100% flat battery)\n            \n     2v10 : Bangle.js: Improved HRM calculations - swapped autocorrelation for bandpass filter\n            Bangle.js: Significantly improved step counting algorithm using bandpass filter (fix #1846)\n            Bangle.js: Ignore touch and swipe events when the LCD is off\n            Graphics: Fix 1bpp custom fonts on 2/4/8 bpp graphics Canvas not being the right colour\n            Bangle.js: Don't reset all peripherals when loading a new app, and only\n              turn peripherals off if unused 500ms after starting new app\n            Increase max arguments for Function.apply from 64 to 256\n            NRF52840: Create new NRF_GPIO_PIN_X_FAST as Nordic's gpio functions will no longer inline!\n            Graphics: Add .blit() to allow fast blits within a single Graphics instance\n            nRF52840: workaround for SDK15 bug that stops softdevice restart when WDT enabled\n            Disallow template strings in object decls like {`hello`:1} (fix #2006)\n            Bangle.js: Add support for global colour themes which affect g.clear/g.reset (fix #499)\n            Bangle.js: Switch beep/buzz to IRQs (keeps time correct even when JS is busy)\n            Add E.decodeUTF8 to allow UTF8 to be decoded into standard 8 bit characters\n            Util timer: account for 'drift' in timer when adding new tasks if running it continuously\n            Graphics: Allow 'scroll' method to only scroll inside clipRect\n            Bangle.js: if we restart with home button held down, ignore the 'button up' event\n            Remove Graphics.drawImages from non-Bangle.js builds to free up space\n            Pico: Remove SHA512 from build to free up space\n            Storage: fix issue where functions referencing flash weren't correctly relocated during compact (#2009)\n            Add support for rendering 3 bit images to 12/16 bit destinations\n            Ensure Serial1.unsetup can be called even if it doesn't appear to have been enabled\n            Puck.js: ensure self test only happens after hardware reset (fix #2001)\n            Bangle.js: Fix issue where long-press BTN3 while holding BTN1 would reload the app but wouldn't load configuration (eg not setting timezone)\n            Graphics: add .getBPP, and allow color blending (rather than copy) when drawing 2 bit images on any BPP Graphics instance\n            nRF52: If getPrimaryServices fails with NRF_BUSY, keep retrying after a delay (fix #2008)\n            Bangle.js 2: Fix getPressure memory leak\n            Graphics: Theme now only applies for LCD, not for JS/ArrayBuffer graphics\n            Graphics: Add dark boolean to themes to allow apps to update depending on bg color\n            Bangle.js: setUI now has 'clock' modes\n            Rename SMAQ3 board to BANGLEJS2\n            nRF52840: Remove ifdef around PHY_UPDATE_REQUEST - fixes BLE5 connections\n            Graphics: Allow g.drawImage to use ArrayBuffer Graphics as an argument \n            Bangle.js: Display small 'Loading...' screen to show something is happening when loading apps\n            Promise: Fix issue with .then().then(...) on an already-resolved promise (fix #2019)\n            Bangle.js: g.flip no longer keeps the screen awake, flipTimer renamed to inactivityTimer\n            Bangle.js 2: 'factory default' set of JS now included inside firmware\n            Bangle.js: Build in ANCS support (disabled by default)\n            Bangle.js 2: Working VC31 heart rate monitoring\n            Bangle.js: Push GPS events immediately after GPGSV (more portable/resilient to config changes)\n            At first boot, fully check Storage for validity (if not full, ensure remaining pages are 0xFF)\n            Storage: Ensure jsfIsStorageValid returns true when storage is valid, but full\n            Bangle.js: Add Bangle.getGPSFix to get last GPS fix without waiting for a listener\n            Merge experimental_compact_vars branch to reduce var sixe from 16 to 13 bytes in most cases.\n            Add JSVAR_FORCE_16_BYTE to allow experimental_compact_vars changes to be removed\n            Add JSVAR_FORCE_INLINE, and don't force lock/unlock/getters to be inlined.\n              Compiler has improved enough we save 10% code space and get marginally faster\n            Add ArrayBufferView.subarray for easily making subarrays (eg a.set(a.subarray(-1)))\n            Solve case where an ArrayBuffer set using the same array could duplicate entries (`a.set(a.subarray(),1)`)\n            nRF52: Fix 2v09 regression where clearWatch reset pin state, removing pullups\n            nRF52: BLE stack errors now reports a line number\n            nRF52: 'BLE task in progress' messages now give a readable name, not task number\n            MICROBIT1: Remove hardware SPI to save space. Software SPI still works\n\n     2v09 : Bangle.js: increase default advertising interval from 375 to 200ms to ease connections\n            Fix Math.acos for negative values (fix #1950)\n            nRF5x: Add callback param to 'NRF.restart', allowing code to be called with softdevice disabled\n            Bangle.js: fix require(\"locale\").time(new Date()) for default locale\n            Now use exponents when printing doubles >= 1E21 or < 1E-6 (fix #1489)\n            Fix Regexp handling of unescaped '.' in character group: /[.]/ (fix #1948)\n            Now error if using (unsupported) RegExp backreferences\n            nRF52: Ensure SPI 1 byte DMA errata workaround isn't applied to non-52832 parts\n            nRF52: When outputting assertions, if we have an terminal device (eg LCD) use that\n            When load(filename) is used, set global variable __FILE__ to the filename\n            Util Timer no longer uses RTC - works based on estimated time from the hardware timer itself (fix #1749, ref #1444)\n            Pull in fixed SHT3C.min.js for RAK5010\n            Add support for relaying full touchscreen events in devices that support it\n            Fix flip-on-idle behaviour for non-Bangle.js smartwatch ports\n            Add support for buttonless bootloader (first boot only, times out after 5 seconds)\n            Fix emulator crash if Graphics.drawPoly used with odd number of points\n            Graphics.fillPoly now errors if >64 points (prev was 63)\n            Graphics: Support for palettes supplied in image strings\n            nRF52840: Ensure internal voltage regulator is set to 3.3v (not 1.8v default) at boot\n            Fix Array.forEach when deleting the item you're currently iterating over (fix #1962)\n            Bangle.js: StorageFile now uses 10x bigger chunks which reduces stress on Storage.list()\n            Storage.list now allows you to specifically request StorageFile, only ever reports first StorageFile chunk\n            Graphics: Allow colors to be specified as '#rgb' strings\n            Graphics: Antialiased lines now read the background color so overlap nicely\n            Graphics: Add fillPolyAA and use antialiased vector fonts (on platforms where AA is enabled) \n            Puck.js: Fix regression where IR LED was left on after transmission (fix #1969)\n            Graphics: Fix overdraw when drawing ellipses/circles\n            NRF52840: Use SPI3 by default as it's more capable/faster than SPI0\n            SMAQ3: Add support for unknown compass IC\n            Bangle.js: Make the 'home' button more configurable in code\n            Bangle.js: Add Bangle.softOff to allow the RTC to keep running\n            nRF52: Allow devices to remember the time between reboots (even if RTC is reset)\n            Microbit 2: Increase RAM from 64k to 128k\n            Bangle.js: Don't enter accelerometer power save mode if compass/barometer is in use\n            Watches: Allow streaming pressure data from Barometer\n            Graphics: Add antialias/colour blending for 24 bit buffers\n            NRF52840: Create new NRF_GPIO_PIN_X_FAST as Nordic's gpio functions will no longer inline!\n            nRF5x: reset BLE advertising after `load()/reset()` (fix #1975)\n            Bangle.js: Add accelerometer recovery for rare cases when accelerometer boots with corrupted address (fix #1972)\n            Bangle.js: Add app ID option to setXYZPower to allow apps to share devices (power is on as long as one app wants the device) (fix #1971)\n            Bangle.js: Add isXYZOn() functions\n            BLE: Allow 128-bit service data to be decoded (fix #1976)\n            Graphics: Fix 8 bit ArrayBuffer scroll not working correctly in some directions\n            Storage: Fix corruption issue with StorageFile write after a Storage compact (fix #1970)\n            Fixed dimmable backlight on non-Bangle.js watches \n            SMAQ3: Touchscreen is now powered off with Bangle.setLCDPower(0), auto-powers off after 30s\n            nRF52: Upon rebooting, reset time to 1970 if time looks corrupt\n            nRF52840: Don't use SPI3 unless ESPR_USE_SPI3 is defined (errata 195 means it draws an extra 1mA unless disabled!)\n            Bangle.js: apply g.drawImage fast path even if image goes to the edge of the screen\n            Graphics: Improve fillPolyAA for horizontalish lines, remove antialiased vector fonts (as won't work well on platforms without readback)\n            Fix invalid free caused by error inside a while loop condition (fix #1983)\n            Fix SIGFPE if using modulo with -1 (fix #1983)\n            Fix memory leak on Array.forEach/map/filter/etc caused by #1962 fix\n            Fix Espruino not sleeping when very low on free memory (fix #1986)\n            nRF52: Use 'low accuracy' GPIOTE for watches as we can shut down the high speed oscillator\n            E.getSizeOf() and trace() now don't recurse into references back to the global scope (makes sizes and traces far more useful)\n            nRF5x: Move from separate sdk_config.h to a single targets/nrf5x/app_config.h file\n            Original board: Remove Graphics.*Ellipse and StorageFile when networking enabled to allow builds\n            Update S132 Softdevice from 3.0.0 to 3.1.0 (fix #1999)\n            nRF5x: Allow Espruino builds with a configurable MTU - move Espruino boards to 53 byte (from 23) (#1998)\n            Fix issue parsing `r=>print((e=>{})(r))` (fix #1992)\n            Add DHE RSA key exchange for TLS/HTTPS (fix #1994)\n \n     2v08 : nRF52: Added option to build in I2C slave support\n            Fix Tensorflow aiGesture regression from 2v07 (re-add opcodes) (fix #1936)\n            Add support for > 1bpp custom bitmap fonts\n            Bangle.js: add drawLineAA and drawPolyAA for antialiased lines\n            Removed custom fonts for SAVE_ON_FLASH devices\n            Fixed BBC micro:bit show() regression from 2v07\n            Ensure Storage library is exposed on SAVE_ON_FLASH devices (fix micro:bit flash write)\n            nRF52: Fix issue where analogRead would stop E.getBattery from working\n            Fix setWatch debounce lastTime regression from 2v07 (fix #1902)\n            nRF52: CPU now sleeps when while UART/BLE data is waiting to be sent (fix #1938)\n            JSON.stringify now checks for potential stack overflow when stringifying (fix #1940)\n            Check for Stack overflow when Garbage Collecting giant linked list (fix #1765)\n            Added String.padStart/padEnd\n            Fix issue where JSON.stringify({ something: bool }) would output 'something' as a bool too\n            Bangle.js/Pixl.js: Ensure terminal is always the same color regardless of g.setColor()\n            Original Espruino Board: remove E.FFT in network-enabled builds (freeing up flash memory)\n            Storage compact now updates pointers stored in RAM so they still point to the correct address in Flash (fix #1881)\n            Bangle.js: Add debounce to the button used to wake Bangle.js up from sleep\n            Fix regex match with '-' that isn't a range: \"1-2_A3\".split(/[0-]/) (fix #1736)\n            Crypto: modified mbedtls SHA1 to reduce size from 3.5k to under 1k\n            Graphics: Fix for out of bounds ArrayBuffer scroll issue (fix #1946, #1947)\n\n     2v07 : Graphics.asImage() now contains buffer when bpp != 8 (fix #1863)\n            nRF52 SDK15: Fix NRF.setScan/findDevices/etc\n            nRF52: reduce input buffer space taken by advertising packets\n            Pretokenisation: reserved words can now be used as function names (fix #1868)\n            jslGetNextToken now avoids iterator clone for each token (fix #1857)\n            nRF52: fix instability when accessing ADC from IRQs and event loop at the same time (fix #1861)\n            Fix 0.0==null comparison (fix #1865)\n            WIZNet: add setHostname(), geHostname(), getStatus()\n            Fix XON not sent after reset() (fix #1872)\n            Remove USBSERIAL enum for non-USB devices\n            Shrink new vector font sizes to allow multi-line use (fix #1873)\n            Stop Object.setPrototypeOf overwriting Object.prototype sometimes (fix #1875)\n            Arrow functions now always overwrite `this` (fix #1878)\n            Implement Streaming Storage compaction to allow compact with less RAM (fix #1598,#1707,#1828)\n            jslTokenAsString now works for 'of'\n            Speed up Array.prototype.join (fix #1660)\n            Allow 'in' to be used with typed arrays (fix #1534)\n            Fix global regex issues when match may be 0 chars (fix #1888) (fix #1889)\n            Improve String.replace performance using iterator rather than repeated copy\n            Pixl.js: SDA/SCL constants should point to A4/A5, not D4/D5\n            Fix Graphics.fill/drawCircle lock leak\n            Fix issue when do..while loop condition has side effects\n            Bangle.js: Ensure SPI flash CS is disabled when sleeping/off\n            nRF5x: clear FPU interrupt before sleeping\n            micro:bit: Add support for LSM303 accelerometer/magnetometer\n            micro:bit: Add delays at first boot to wait for USB UART to init and connect vis USB\n            micro:bit: Re-added tab complete (enough space now)\n            micro:bit: Added a fake pin for LED/LED1 that uses the LED matrix\n            nRF52: Allow a cccd_handle of 0 for startNotifications\n            Bangle.js: Power down SPI flash when sleeping/off\n            nRF52: Use the best available hardware timer for PWM taking frequency into account\n            Fix delay in scheduling after initial setTimeout call (from 2v06 and later)\n            Align Tensorflow arena to 16 bytes - new Tensorflow requires this (fix #1914)\n            Fix ReferenceError when arguments[0] is used when an argument is undefined (fix #1691)\n            JSON conversion for console now removes quotes on key lengths bigger than 15 (63)\n            micro:bit: add Storage.write/etc even on space-constrained (SAVE_ON_FLASH) devices\n            Remove flash compaction code on SAVE_ON_FLASH devices to save some space\n            Fix occasional duplicate state changes when using setWatch with debounce (fix #1902)\n            JSON.stringify now outputs 'null' for non-finite numbers as the spec requires (fix #1919)\n            Update Tensorflow to latest version, fix return 0 issue on ARM release builds (fix #1918)\n            Bangle.js: Accelerometer poll handler now uses RTC app_timer, not TIMER1. 1mA->0.5mA standby current (ref #1920)\n            Bangle.js: SPI MISO is now input_pullup (shaves ~20uA)\n            Espruino WiFi: Fix startAP function when open and no password supplied\n            Bangle.js: Accelerometer now runs in low power mode (saving ~150uA)\n            Bangle.js: Peripheral polling now only fully wakes Bangle when an event requires JS processing (ref #1921)\n            Bangle.js: When not moved for 1 minute, slow down accelerometer poll interval from 80 to 800ms (fix #1921)\n            Ensure software SPI/I2C/Serial don't leak a variable when initialised\n            Fix delay in scheduling after initial setTimeout call (from 2v06 and later)\n            Espruino WiFi: Fix StorageFile on Espruino WiFi (use max storagefile size of 4k)\n            Espruino WiFi: Fix Storage compaction regression (introduced after 2v06 release)\n            Bangle.js: Fix backlight flicker regression if at part brightness (fix #1925)\n            Fix ArrayBuffer.sort with negative numbers (it's not just Array.sort!)\n            nRF52: Use the best available hardware timer for PWM taking frequency into account\n            Bangle.js: Report GPS HDOP (Horizontal Ditution of Precision => accuracy) values in 'GPS' event\n            Pixl.js: Remove SHA256 from build to free up a little extra code space\n            nRF52: Restarting softdevice no longer changes the system time by 5 mins sometimes (fix #1933)\n\n     2v06 : Allow `\"ram\"` keyword at the top of a function to allow it to be pretokenised and loaded to RAM\n            Don't store line numbers for pretokenised functions\n            Fix 1-byte overflow when using UDP (#1799)\n            Remove 1-byte padding in Graphics lib\n            Bangle.js: Make SPI flash memory map address configurable, and check end bounds (#1807)\n            Bangle.js: More SPI flash memory map address to 0x60000000 to avoid ARM/nRF52 registers\n            nRF52: Fix issue with fast Notifications causing Notification data to be duplicated\n              http://forum.espruino.com/conversations/345949\n            Bangle.js: allow custom splash screen with .splash file\n            Pixl.js: Fix E.showMessage\n            Puck.js v1: Fix regression that stopped Puck.IR(data) working - Puck.IR(data,D26,D25) required\n            Puck.js v2: Ensure FET is used for IR output, fix selfTest errors for IR and Blue LED\n            Bangle.js: Big speed improvements for 120x120 and 80x80 gfx modes\n            Enable Graphics arraybuffer optimisations on all but low-end devices\n            Add specific Graphics optimisations for 1 and 8 bit rendering\n            Bangle.js: drawImage - add fast path for non-transparent 1 or 8bpp image blit (fix #1794)\n            Graphics.drawImage docs improvements (fix #1812)\n            Fix issue where it was possible to get an address of a non-memory-mapped FlashString\n            Graphics.drawImage: Allow 8 bit palettes to be specified\n            Bangle.js: Remove dumping of hardware state - saves some flash memory\n            microbit: Remove dumping of hardware state - saves some flash memory\n            Bangle.js: fix 'short' time for built-in locale\n            Bangle.js: fix 'speed' units for built-in locale\n            Graphics.createArrayBuffer now honors `msb:true` if `bpp>8`\n            Graphics.asImage: handle >8bpp correctly (fix #1797)\n            Graphics.asImage: Allow 'string' output type, reference Graphics buffer if possible\n            STM32: Fix 2v05 regression in hardware SPI.write (RX timeout)\n            Graphics: fix lock leak in g.reset()/g.clear(1)\n            Graphics: added drawImages to allow layers of rotated/scaled images to be composited \n            Remove E.interpolate/2D (not used much, just using flash)\n            Bangle.js: use double math FFT to save a few bytes of flash\n            Storage.writeJSON (fix memory leak)\n            dump() is now aware of pretokenised code (fix #1821)\n            Merge jsvStringIteratorGetChar + jsvStringIteratorNext into jsvStringIteratorGetCharAndNext (fix #1816)\n            Fix 2v05 regression that stopped process.uncaughtException from working (had been moved to E.uncaughtException)\n            nRF52: If passkey or oob is set in setSecurity, ensure that the UART connection requires encryption (fix #1705)\n            Now report [ERASED] rather than ?[255] if we hit char code 255 while evaluating\n            Bangle.js: read `setting.json` at init and modify Bangle.beep/buzz behaviour accordingly\n            Tensorflow: remove some as-yet unused operators to free space\n            nRF52: Speed up bootloader, remove pauses on Pixl.js\n            Pixl.js: fix self-test/terminal print - write to screen immediately after newline unless in IRQ\n            Fix issue with iteration over arrays with negative entries (these should be converted to Strings)\n            Linux: improve command-line, allow recursive test directory and more than one test (eg wildcard + shell expansion)\n            Added new vector fonts supporting most of ISO8859-1\n            Graphics.fillPoly now uses 4 bit fixed point internally\n            nRF52: Fix 2v05 hardware SPI regression (chip errata when sending 1 byte)\n            Graphics.fillPoly now uses a more normal fill algorithm that doesn't attempt to fill to the top right (fix #1796)\n            Fix setTimeout/Interval accuracy when new timeouts scheduled within timeout (fix #1829)\n            nRF52: Fix 'BLE task 2 is already in progress' if disconnect called during connection process\n            Puck.js: Put accelerometer into lower power mode by default\n            Puck.js: Switch to IRQs for magnetometer (lower power consumption)\n            Improve Graphics.drawImage speed and simplify code by allowing fast path for non-rotated graphics\n            Tensorflow: updated to v2.2, removed un-needed ops (reduces size by 24k)\n            Puck.js: Fix Puck.magTemp();\n            Puck.js v1: Fix magnetometer reading after puck.magOn (2v05 regression) - use old software I2C implementation\n            I2C: Improve software I2C (now quickly forces I2C high before pullup, to help improve clock speed)\n            Bangle.js: Fix GPS-raw events to provde also u-blox UBX Protocol messages (fix #1838)\n            Bangle.js: Save RAM in GPS handling, allow arbitrary length data returned (fix #1843)\n            Tensorflow updated to current 'master' version\n            Bangle.js: Improve SPI flash speed by with specific function for reading and keeping CS asserted (fix #1849)\n            Bangle.js: Ensure BTN3 exits debug mode (fix #1842)\n            Bangle.js: Now warn if GPS data overflows (fix #1847)\n            Fix double unlock in load(filename)\n            Bangle.js: Fix occasional execution errors when executing from Flash (fix #1854)\n            Add Graphics.transformVertices()\n            Re-add Graphics.quadraticBezier for Bangle.js, move to integer math to halve fn size\n            Emscripten: (fake) Flash memory support\n\n     2v05 : Add Array.includes\n            Fix (Number.toFixed) rounding, eg (1234.505).toFixed(2)\n            nRF52: If a central is connected to Espruino but isn't reading from UART, don't block waiting to send data\n            ESP8266: reverse fix #1679\n            Added Graphics.getFont/setFont/getFonts\n            Added Graphics.getFontHeight\n            Added option to compile in 6x8 fixed-width fonts\n            Fix issue where Util Timer timers could break after a call to setTime\n            nRF52: Enable DMA for SPI send\n            Added option to build in TensorFlow Lite for AI\n            Documentation for modules now includes require('...') in the call type to be less confusing\n            ESP8266: warning: Empty loadable segment detected (fix #1690) \n            nRF52: Add NRF.nfcPair(...) and OOB pairing to allow tap to pair over BLE\n            nRF52: Add NRF.nfcAndroidApp(...) to launch an Android app on touch\n            Pixl.js remove SHA512 to make room for new NFC functionality\n            Graphics.setFont(\"4x6\",2) will now double the size of a bitmap font\n            Graphics.drawImage can now take a String of data for an image (eg. direct from Storage)\n            nRF5x: Support connection to devices with RANDOM_PRIVATE_RESOLVABLE and RANDOM_PRIVATE_NON_RESOLVABLE addresses\n            Pixl.js: Move SCK pin used during Neopixel writes to ensure it doesn't interfere with BTN3\n            nRF52: Fix alignment issue with Nordic's SDK12 code that stopped passkey pairing from working sometimes\n            Storage lib now doesn't bother reading to end of flash to ensure pages are clear\n            Allow heatshrink compress/decompress to work even if flat buffers can't be allocated\n            require(\"Flash\").write operations no longer need to be aligned\n            require(\"Storage\").open added - for appendable files\n            Pixl.js: Removed AES functionality - unfortunately we're running low on space for it\n            Original Espruino Board: Removed Vector font and don't add rotated drawImage to save flash\n            nRF5x: Add NRF.filterDevices to allow scanned devices to be easily filtered after scanning\n            nRF52: Fix 'BLE task completed that wasn't scheduled' warning regression (peripheral disconnect)\n            Can now get a data pointer even from a single JsVar string (it doesn't have to be flat)\n            Add option to specify a palette when drawing images with drawImage\n            Add XON/XOFF flow control to Bluetooth LE UART (on by default)\n            Lower thresholds for XON/XOFF to give more headroom with devices that are slow to respond\n            Add a fast path for non-rotated non-scaled Graphics.drawImage\n            Add argument check for heatshrink compress/decompress\n            nRF5x: Ensure gatt.connect silently succeeds if we're already connected to the device\n            Add E.showMenu, deprecate Pixl.menu - use a common function to ease porting between devices\n            Added E.showPrompt, E.showAlert for Bangle.js\n            Pixl.js - check '.splash' file at startup and use it for splash screen if it's there\n            Improve free list ordering when Flat Strings are freed\n            Added E.defrag to perform defragmentation - still beta!\n            nRF52: fix issue where restarting the softdevice would reset the RTC\n              - fixes Bangle.js watchdog reset\n            nRF52: fix issue where advertising flags could get out of sync after SD restart\n            Bangle.js: fix units for GPS speed (was knots, now km/h)\n            Bangle.js: Add Bangle.setLCDBrightness\n            nRF52: Fix passkey pairing if setSecurity is after setServices\n            Bangle.js: EVents for 'swipe' and 'touch' on the touchscreen\n            Added ability to compile Espruino to JavaScript with Emscripten\n            Allow g.setColor/setBgColor to take hex Strings of the form `'#00ff00'`\n            Bangle.js: Added heart rate autocorrelation, setHRMPower and 'HRM' event\n            Bangle.js: New 120x120 and 80x80 high speed buffered modes\n            Fixed REPL to allow chars with char code >=128\n            Fixed lex tokenToString for 'break'\n            Bangle.js: add fake LED/LED1/LED2 as @allObjects suggested\n            Add Graphics.toColor, and allow 4 bit Mac palette to be mapped to 8 bit web palette\n            Add Graphics.setClipRect to allow draw ops to be restricted to a certain area\n            Bangle.js: add 'null' LCD mode to stop apps from drawing\n            Bangle.js: add Bangle.getLCDMode\n            Bangle.js: skip firmware version checks to save some bytes in bootloader\n            Graphics: new g.fillPoly to handle irregular polygons\n            Bangle.js: Bangle.setLCDMode now errors if it can't allocate a flat string (also garbage collects and defrags to try and ensure it can)\n            Graphics: drawEllipse/fillEllipse now work correctly for very small ellipses\n            Fix type compare of string and flatstring\n            Allow Storage.read to make partial file reads (fix #1744)\n            Fix SyntaxError when using pretokenise + getters (fix #1745)\n            Add Graphics.reset, and ensure it (and g.clear(1)) unreference custom fonts\n            Iterator cloners now take a reference to the iterator rather than returning it\n            Flash Strings: On Bangle.js allow JS code (and other Strings) to be accessed without loading them completely from Flash\n            Added E.CRC32 for easy testing of data validity\n            Add `E.on('kill'` event for executing code before load/reset/save/etc\n            JSON.stringify now escapes using the less efficient JSON subset of escape characters (fix #1737)\n            Allow optional `load(\"filename\")` to load a JS file from Storage (was just `load()`)\n            Bangle.js: add Bangle.loadWidgets/drawWidgets\n            Bangle.js: Remove deprecated Bangle.menu\n            Ensure it's possible to get a solid background when using 4x6 font\n            Bangle.js: Add Bangle.showLauncher\n            Add append optimisation for string '+', and don't append to flat/native/etc strings (fix #1746)\n            ESP8266_4MB: add optional build flag FLASH_1MB for ESP8255  & ESP01s with 1MB flash\n            ESP8266: add optional build flag NO_FOTA to remove flash over the air functionality\n            Add Bangle.getCompass and Bangle.getAccel to get the latest compass/accelerometer readings without a callback\n            Fix `parseInt(\"0b\",16)` as well as some other non-compliant behaviour (fix #1722)\n            Bangle.js: Disable touch buttons if screen off\n            Bangle.js: Don't send 'up' event for a button that was used to wake the screen\n            Bangle.js: GPS event.time set to undefined if GPS time is not initialised\n            Fix regression that removed exception reporting in console\n            Bangle.js: speed up bootloader progress bar\n            Bangle.js: fix problems turning off via bootloader sometimes\n            Bangle.js: improve power consumption when off, now ~0.08mA (fix #1727)\n            Bangle.js: add Bangle.setOptions({wakeOn*}) for when LCD should light\n            Bangle.js: Add 'twist' event and 'wakeOnTwist' (wakeOnTwist now default true, waveOnFaceUp default false)\n            Bangle.js/Pixl.js: Updated E.showMenu\n            Bangle.js: E.showMenu now has some colour, bigger, with next/prev indicators, and works with widgets \n            Pixl.js: Add E.showPrompt/Alert/Message (fix #1747)\n            Add .toJSON handling for JSON.stringify, and add Date.toJSON (fix #1754)\n            Remove broken Graphics.drawImage centerx/y (fix #1742)\n            Add Storage.writeJSON to avoid any confusion of writing arrays/numbers/etc\n            Bangle.js: Keep widget area free when using showPrompt/Alert/etc (fix #1756)\n            Add more info about flash memory to process.env/process.memory\n            Add Graphics.quadraticBezier() \n            Allow Graphics.setFont to be used with custom fonts (fix #1762)\n            Espruino WiFi: WiFi module now makes BOOT pin open circuit when sleeping - saves ~2mA\n            Add E.setConsole/getConsole to allow console to be moved (including to 'null')\n            Bangle.js: Ensure HRM is turned off in Bangle.off() (fix #1759)\n            Increase 'Storage' library's max filename size to 24 bytes (from 8)\n            Remove header.replacement in 'Storage' lib and just zero header.name\n              - increase filename to 28 bytes, but file search now more efficient\n            Bangle.js: Increase Storage area to full 4MB of flash\n            Bangle.js: NEEDS NEW APPS - Move away from using first char as file descriptor and use file extensions instead\n            Add StorageFile.getLength() to get the current length of a StorageFile\n            StorageFile also writes files with a 'JSFF_STORAGEFILE' flag (not currently used)\n            Storage.list() can now take a RegEx/string to filter returned results \n            MDBT42Q: Remove AES encryption libs by default to free up more flash memory\n            Microbit: Add SAVE_ON_FLASH_EXTREME flag to ensure builds keep working\n            Bangle.js: Added built-in 'locale' module to handle common conversions - this can be overwritten by a Storage File to change language\n            Storage.readJSON now has optional 2nd arg that stops it from creating exceptions on bad JSON\n            Bangle.js: Tweak LCD gamma curves to provide better gradients on new watches (fix #1758)\n            Bangle.js: fix BLE UART transmit bug when compiling for SDK14 (thanks @fanoush!)\n            Add euro symbol to 6x8 and 4x6 fonts as char code 128 (ISO10646-1)\n            Bangle.js: Use 'locale' library to translate E.showMenu/Prompt/Alert/etc\n            Bangle.js: remove graphical_menu lib and inline specialised version into E.showMenu\n            Bangle.js: Modify handling of widgets to allow variable width widgets (requires new widget JS)\n            Changed 6x8 builtin font to a modified Dina_r400-6 supporting non-ASCII characters\n            Bangle.js: Modify E.showMessage/Prompt/Alert to clear the entire screen and redraw widgets (fix #1771)\n            Bangle.js: Modify Bangle.drawWidgets to only clear the areas where widgets actually are, not the whole top&bottom bar\n            Kick Watchdog when erasing flash (it can take so long on 4MB external flash that it reboots)\n            KICKSTARTER BUILD\n            Bangle.js: Add 'meridian' to locale library\n            ESP32: add environment variable COMPORT to be used with make flash \n            Puck.js: v2 Support: Accelerometer/Gyro/temp\n            Puck.js: Self test now sets Puck.js BLE name if there's an error\n            Fix bitwise rshift by 0 to be unsigned (fix #1784)\n            Bangle.js: Don't load .boot0/1/2/3 if BTN1 is pressed\n            Puck.js: Allow D21(RST) to be used as normal IO pin\n            Fix recent E.getTemperature regression (fix #1788)\n            Fix pretokenise of RegExp literals (fix #1786)\n            Add ability to turn off software I2C clock stretching (not accessible from JS)\n            Puck.js: disable clock stretching for built-in sensors\n            Bangle.js: Now clear entire top/bottom row if there are widgets in it (fix #1790)\n            Add Storage check at startup and erase everything if storage looks corrupt (fix #1766)\n            Fix restriction on StorageFile filename length (8 to 28)\n            Fix array sort when compare fn returns floats <1 (fix #1798)\n            Fix Storage.write duplicate file issue in some rare cases (fix #1801)\n            Bangle.js: fix post-kickstarter issue adding widgets in bottom of screen (#1790)\n            Bangle.js: fix magnetometer self-calibration\n            Espruino Original: Removed Debugger, Tab complete, AT command networking from WIZnet networking build to free enough Flash\n            Espruino Pico: Added a normal build that doesn't contain CC3000 or WIZnet support\n            Espruino Pico: Removed Debugger and Vector font from WIZnet/CC3000 networking versions to free enough Flash\n            HYSTM32_28: Removed from build due to lack of interest and difficulty with increased firmware size\n\n     2v04 : Allow \\1..\\9 escape codes in RegExp\n            ESP8266: reading storage is not working for boot from user2 (fix #1507)\n            Fix Array.fill crash if used to fill up all available memory (fix #1668)\n            Fix NRF.requestDevice regression (clearInterval error) (fix #1669)\n            Smartibot devices now advertise on BLE as 'Smartibot abcd'\n            nRF5x: Leave digital input disconnected for analog read (saves power)\n            nRF5x: Return 'analog' as pin mode for any pin where input is disconnected\n            If watchdog is on and automatic, ensure that `reset()` keeps the automatic kicking going\n            Ensure that a console stays locked even after \n            Ensure interpreter flags (eg echo) are cleared after a `reset()`\n            nRF5x: When watchdog is on and automatic, automatically wake up often enough to service it\n            Fix Graphics.setFontBitmap on builds with no vector font (fix #1671)\n            Graphics.asBMP now takes account of bitmap rotation (fix #1672)\n            Raspberry pi pin numbering the same if using wiringPi or filesystem GPIO (fix #1673)\n            nRF52: Peer manager init errors from Nordic libs now not fatal \n            SDK15: Writing to flash now works\n            nRF52840: USB Serial works even for big sends, and device swaps to USB automatically\n            nRF52840: Allow Serial2 to be used\n            ESP8266: optimize rename-section for ESP8266_4MB board, freeHeap +2064 byte (fix #1679)\n            Fix corruption if Function.replaceWith called manually on something not a function (fix #1684)\n            Fix bug where '.clone' on a native function didn't copy arguments (fix #1685)\n            nRF52840: Fix input/pullup/pulldown pin modes on IO bank 2\n            Added `E.memoryMap` to allow on-chip registers to be mapped direct to variables (fix #1500)\n\n     2v03 : nRF5x: Fix issue when calling NRF.setAdvertising while connected via BLE (fix #1659)\n            nRF5x: 'dump()' not outputs `NRF.setSecurity` line if it has been called.\n            Ensure that converting a valid pin to a boolean always returns true\n            clearInterval/clearTimeout/clearWatch(undefined) now throw an error asking for just clearX()\n              - this stops code accidentally clearing all timers/etc if it uses a variable that is undefined\n            Allow NRF.setAddress to work even with services defined and a connection in progress\n\n     2v02 : Fix string index calculation when using some regexes (fix #1602)\n            Ensure Function.replaceWith puts scope after parameters (fix #1601)\n            Ensure Graphics.* return the Graphics instance, to allow call chaining (fix #1580)\n            Ensure DataView.byteOffset/byteLength is always set even if not specified (fix #1567)\n            Added HttpServerResponse.setHeader\n            HttpServerResponse now automatically sends `Connection:close` unless overridden (fix #1596)\n            Fix sign of RSSI reporting with setRSSIHandler\n            nRF52: Add docs for properties that weren't documented before\n            nRF52: Add ability to connect to device with passkey authentication\n            nRF52: Allow startNotifications to use Indicate if Notify doesn't exist (as per spec)\n            nRF52: Add option for static passkey pairing with NRF.setSecurity\n\t    ESP32: update EspruinoBuildTools to esp-idf V3.1.2 - fix Wifi connect issues (multiple ssid)\n            Revert PR #1459 as it broke neopixel functionality that worked previously\n            nRF52: Disconnect RX pin after UART test at boot (saves power when in deep sleep)\n            Serial.unsetup now sets pin state to STATE_UNDEFINED, which disconnects the pins internally\n            Removed modulo on `new Date` h/m/s/ms arguments as it seems desktop JS is fine with out of range values\n            Added `active` option to NRF.setScan/findDevices/requestDevices to allow scan response packets to be requested\n            Add I2C/SPI baud rate checks (#1619)\n            STM32: Add `E.setRTCPrescaler` to allow the RTC to be calibrated on Espruino Pico (fix #1607)\n            nRF52: Fix slow Bluetooth connection if previously disconnected while using low power connection interval (fix #1605)\n            Allow `Graphics.clear(true)` to reset state (font, color, etc) to default as well as clearing the screen (fix #1615)\n            nRF52: Fix setScanResponse regression from 2v00\n            nRF5x: Execute SWI1_IRQHandler when radio turns off instead of on+off. More efficient, fixed multiple advertising.\n            Smartibot build added\n            ESP8266: add CFLAGs to shrink build size (fix #1622)\n            ESP32: update EspruinoBuildTools to esp-idf V3.1.3\n            nRF52: Add FAT Filesystem support to MDBT42Q module\n            Now save file modification time with FAT\n            Fix segfault if `.clone` is called with `this==undefined` (fix #1628)\n            Fix issue outputting char codes <8 after outputting hex char codes\n            nRF52: Don't allow NRF.updateServices while a BLE restart for setServices is queued\n            nRF5x: Don't sleep if we received any events since last sleep (fix #1572)\n            Remove limit on the number of scopes that can be searched (fix #948)\n            String.split - improve docs, split with RegExp now inserts the text after the final match\n            RegExp: Add '|' operator (fix #1503)\n            Switch ARM toolchain to gcc-arm-none-eabi-8-2018-q4-major\n            Improve handling of timeouts for RAK8212 GPS\n            nRF52: Now create exception if advertising calls fail (but ignore when in IRQ)\n            nRF52: Add setAdvertising({},{scannable:false}) for disabling scan response\n            nRF52: Add note about connectable:false requiring >=100ms intervals\n            STM32: Fix issue where occasionally STM32 would be ~0.2s late waking from light sleep\n            ESP8266: add Wifi.connect options channel and bssid for faster AP connects (fix #1595, #1640)\n            Fix index in E.mapInPlace and improve docs\n            nRF52: Add NRF.getSecurityStatus to allow devices to detect the current state of the connection\n            STM32F4: Add Filesystem module\n            STM32F3: Fix broken build\n            nRF52: Fix nRF52840 advertising and remove duplicated advertising code\n            Fix Software Serial receive when the frame has to be decoded inside the IRQ (fix #1654)\n            Raise software serial receive buffer to 64 bytes (from 7)\n            nRF5x: Add security options to NRF.setSecurity (courtesy of @vkolotov)\n            nRF5x: Allow Serial1.setup(...) with only TX or RX pins\n            Vector font removed from Espruino Original WIZnet build due to lack of spare flash\n\n     2v01 : ESP32: update to esp-idf V3.1\n            Fix issues with Class Extends\n            Improve Tab Completions for extended classes\n            Fix Storage.readJSON/readArrayBuffer memory leak (fix #1532)\n            Fix potential out of bounds Graphics.scroll\n            Serial.setConsole now warns if not used on hardware Serial\n            ESP8266: implement hw_timer (fix #1511) to make soft serial and pwm work\n            Fix Storage write error when skipping pages (fix #1539)\n            nRF5x: When scanning, only use as much of IO queue as is needed\n            nRF5x: If BLE/NFC/etc data won't fit in IO queue, drop whole packet\n            Allow `a in b` to search 'fake' objects (#1534)\n            Improve fast path when iterating over Uint8Array/ArrayBuffer\n            Allow deletion of function properties (fix #1549)\n            Add `{callback:...}` option for `.write` style functions - improve docs.\n            ESP8266: deepSleep invalid microseconds (fix #1547)\n            ESP8266: ESP_FLASH_MAX for ESP8266_4MB is wrong (fix #1551, #1553)\n            Fix buffer overflow if bytesize/stopbits used in `Serial.setup` (fix #1510)\n            Ensure jsvNewFlatStringOfLength tries twice (even if GC doesn't release memory, it reorders the free list) (#1559)\n            ESP8266: Missing variable Flash Mode (--flash_mode, -fm) in ESP8266.make files (fix #1563)\n            ESP8266: Remove hack added to get around SDK 1.4 bug (fix #1568)\n            Reduce available hardware SPI/I2C instances to 1 on nRF52 (since this is all we implement atm)\n            Add E.dumpFragmentation to show memory fragmentation (only for debug builds)\n            Fix parsing of dates from before 1970\n            nRF52: Fix some regressions in requestDevice (flagged up by asserts in debug build)\n            Allow built-in objects to be created with `new X()`\n            nRF52: Ensure Bluetooth stack doesn't do a reboot for non-fatal errors (just report them to console)\n            BluetoothRemoteGATTServer.disconnect now returns a Promise\n            nRF52: Jump out of low power mode after less BLE activity (2 reads/writes in 10 radio packets) (#1546)\n            nRF5x: Fix NRF.setConnectionInterval when there's no connection (fix #1546)\n            Explicitly mention Espruino not supporting CASE after DEFAULT in error (fix #1570)\n            Ensure scope is saved for Class constructors (fix #1576)\n            Add setNBCellOn for RAK8211-NB (fix #1581)\n            Now escape chars <8 as octal, and add escape of vertical tab \n            Add Graphics.createArrayBuffer(... {interleavex:true}) to allow faster support for P3 LED panels\n            Add Graphics.fill/drawEllipse and move fill/drawCircle to use the same code\n            CC3000-specific build removed on Original Espruino board (lack of space)\n\n     2v00 : Allow changeInterval with large (>32 bit) intervals (fix #1438)\n            changeInterval now changes the interval immediately when it's called inside the interval it is changing (fix #1440)\n            Fix parsing of try..catch when not executing (fix #1439)\n            Add extra ReferenceError checks, even if variable is not used\n            Allow Ctrl-C out of while...continue loop (fix #1441)\n            Fix bug if using an undefined member of an object for for..in (fix #1437)\n            Allow for..in to iterate over prototype chains down from Array and Object\n            Add for(var i of array) to iterate over elements\n            Added getter and setter support\n            Stop parsing blocks if not executing (fix #572)\n            Fix stack overflow if interpreting a file full of '{' (fix #1448)\n            Fix exception when performing record access on object from getter (fix #1454)\n            Switch to non-recursive StringExt copy (fix #1451)\n            Fix rounding errors in fillPoly -> improve vector font rendering\n            Fix issue that caused 'dump()' not to report variables/functions on Pixl.js\n            Add E.lookupNoCase to allow searching case-insensitively for Object keys\n            Fix HTTP Chunked transfers when the server uses lowercase headers (fix #1458)\n            Fix TypedArray.indexOf (fix #1468)\n            Allow require('Storage').write('a','',0,15) (zero length data) (fix #1465)\n            edit() now chooses the shortest way to describe the function\n            Fixed bug when RegExp.match/test called on non-strings\n            Added Global isFinite\n            Add missing ArrayBufferView.filter\n            Added Array.find and findIndex (also for ArrayBufferViews)\n            Fix unreliable ArrayBufferView.indexOf (#1468)\n            Added String.startsWith/endsWith/includes (#1302)\n            parseFloat(\".s\") now returns NaN\n            Fixed /\\S+/.test(\" \")\n            Added Storage.getFree() to return available space\n            Enable E.setTimeZone on boards with very little flash memory\n            Lower saved code area to 2k on micro:bit (from 3)\n            Remove RGB colour handling in setColor on devices with low flash\n            Reduce available variable count on STM32VL - we were too low on RAM\n            Added Graphics.asBMP/asURL/dump - allowing easy debugging of Graphics via IDE\n            Allow '.then' on already-resolved promise (fix #1476)\n            Stop atob adding trailing 0s when strings are not a multiple of 3 long\n            Reconstruct start and end newlines when dumping multi-line functions  \n            Fix regression parsing methods in classes on embedded (fix #1479)\n            nRF5x: Add options argument to NRF.connect and BluetoothDevice.gatt.connect, allowing a connection interval to be specified\n            nRF5x: Start renegotiating speed after 0.1ms, not 5s. Massively improves connect speed.\n            nRF5x: Now queue up to 5 UART TX packets per transmit interval (was 1 previously)\n            nRF52: Add Dynamic Interval Adjustment - default to 2x connection speed, but idle at 10x slower if not used for 2 minutes\n            nRF5x: Add NRF.setConnectionInterval() to allow connection speed to be set manually\n            RuuviTag: invert LED1, LED2 & BTN in software so LED.set() does what you'd expect\n            Console now doesn't print quotes around object keys if it's not needed\n            Added `E.toJS` to allow very compact JS data stringification (similar to `JSON.stringify`)\n            Output the current timer number as a comment in `dump()`\n            Don't print `=undefined` to console if line is empty\n            Added RAK8212 (and include SMS/GPRS code in RAK8211/2 builds)\n            Graphics.stringWidth now takes account of newlines\n            nRF52: NRF.requestDevice now resolves as soon as a device is found. Faster and better in congested areas\n            Replace use of obsolete 'usleep' function in Linux builds (fix #1455)\n            Add Ethernet.getIP/setIP callbacks for Wiznet to bring them in line with WiFi (fix #1482)\n            Fix Math.round for numbers > 32 bit (fix #1485)\n            Pixl.js menu now resets font alignment, and down arrow icon is fixed\n            Now check for ReferenceErrors in global scope\n            Fix Array.shift (returned a NAME, rather than the value)\n            Add sanity check for names returned from Functions and fix Array.pop\n            Stop characters getting dropped when pasting large amounts of data into Linux build\n            nRF5x increase JsSysTime accuracy to 2^-20 from 2^-16 - drastically improves Util Timer accuracy\n            Added support for Software Serial ports (for low baud rates, eg. 9600)\n            Fix JS state restoration issue (eg. Pixl.menu inside switch would cause errors)\n            Added Graphics.drawPoly\n            Add Graphics.asImage to turn a Graphics instance into an Image that can be used with drawImage\n            Add Graphics.createImage to allow creation of a 1 bit image direct from a string\n            Use 32 bit floats for E.FFT, not 64 (fix #1443)\n            Automatically shut down UART if both pin states are changed\n            Fix `setDeviceClockCmd: Unknown Device` when using `LoopbackB.setConsole()` on WiFi board\n            Fix non-UART serial regressions (after software serial additions)\n            Pixl.js: Add Pixl.setLCDPower to allow the LCD to be powered off, more than halving power consumption\n            nRF5x: Allow NRF.setScan and NRF.findDevices to take the same search filters NRF.requestDevice does (fix #1496)\n            Fix buffer overrun if we have to reallocate a pointer to argument lists when calling a function (fix #1491)\n            Fix stack overflow if executing regex full of hundreds of open brackets (fix #1487)\n            Fix issue where STM32F4 USB could lock up if TX during heavy RX\n            Improve `E.mapInPlace` docs, and allow it to work with no map (eg pass straight through)\n            Added non-standard Uint24Array, because it's very useful for RGB\n            ESP8266: add CFLAGs to shrink binaray files (fix #1499)\n            ESP8266: fully integration of analog pin A0 (fix #1495)\n            ESP32: update sdk to esp-idf 3.0.1, set Espruino build tools back to master branch\n            Allow btoa to work for arrays as well as Strings (fix #1509)\n            Allow E.mapInPlace to merge bits from multiple source elements, also add option for msb/lsb first\n            Remove Graphics.scroll/drawCircle/fillCircle on devices with low flash to allow builds to fit again\n            Remove BluetoothRemoteGATTCharacteristic.writeValue on NRF51 (accidental inclusion - it's not required)\n            Double IO buffer size to 256 (1k bytes) on boards with 96k of RAM or more (or NRF52)\n            nRF5x: allow arbirtary baud rates to be specified for UART\n            On devices with low flash, ensure atan2 uses the slower/smaller atan implementation\n            Move FFT back to 64 bit if low flash (it uses less memory!) and optimise for flash space\n            Remove new Graphics.createImage/asBML/asURL/dump on Original Espruino Board (not enough space) \n            Remove Olimexino from build (too difficult to slim down build and very low usage)\n            Remove Software Serial from boards where we're low on flash\n            Increase size of saved code area from 3*4k to 10*4k on RAK821x boards\n            Fix 'Can't extend undefined' when using Object.setPrototypeOf on a function\n            nRF52: Added NRF.HID event for two-way BLE HID communications\n            nRF5x: Remove multiple writes per connection interval (more trouble than the speed improvement is worth)\n            Fixed hang if trying to allocate Storage greater than total storage size in a fully erased Storage area.\n            Pixl.js: Fix 30s pause when closing sockets on WIZnet W5100 (fix #1306)\n            Remove HASH/hashlib from all builds as it was confusingly in some and not others. Now use 'crypto'\n            require('crypto').SHA1 is now JS in Espruino Original to cut down on the flash required\n            Added 'heatshrink' library to expose built-in heatshrink compression to users\n            Fix assert fail when calling Function.apply with an Object with non-numeric keys\n            Fix issue when AT lib has to process multiple custom line handers in one packet\n            Espruino WiFi: Fix unreliable send when receiving lots of data on another socket\n            Espruino WiFi: Only rename `EspruinoWiFi` to `WiFi` if not found (allows easier debug)\n            Check Flash Storage for modules when using `require`\n            Add 'bits' option for Software SPI\n            STM32 reset pin IRQs before storing the state - makes lost setWatches far less likely\n            Ensure that setBusyIndicator updates output state after the very first initialisation.\n            MDBT42Q: Add LED2 var in the Espruino interpreter, but don't use it for the bootloader\n            ESP8266: release heap used by logDebug(true) (fix #1508)\n            ESP8266: remove SHA256 SHA512 (fix #1517)\n            Ensure `Date.getTimezoneOffset()` returns the correct timezone offset (fix #1515)\n            Search for and execute files '.boot0'/1/2/3 in Storage at boot time if they exist\n            Pixl.js: reduce saved code area to 9 x 4kb to allow for extra features\n            ESP8266: switch to SDK 2.2.1 (fix #1207)\n            Fix Serial port path regression on Linux, and add docs\n            microbit: remove line-by-line debug capability to free up some space\n            Added ES6 String.prototype.repeat\n\n     1v99 : Increase jslMatch error buffer size to handle \"UNFINISHED TEMPLATE LITERAL\" string (#1426)\n            nRF5x: Make FlashWrite cope with flash writes > 4k\n            Increase max size of native strings on platforms that support it - 16 bit to 32 bit (#1432)\n            Fix stack size detection on Linux (fix #1427)\n            Fix strncat/cpy bounding issues (fix #1425)\n            Promises now ignore a second resolve/reject (fix #1433)\n            Fix stack overflow if void void void... is repeated many times (fix #1434)\n            Fix font rendering issue caused by signed bit field handling by GCC on non-x86 platforms (fix #1436)\n            Added E.reboot() to allow hard reboots from software (fix #1429)\n            Added 'Graphics.getInstance()' for more platform independent graphics\n            Added VT100 'erase in Display' to Terminal\n            In REPL, use x.toString() for objects if we know their name and it is available\n            Pixl.js add BLE aerial test to self-test, now also start immediately on BTN4 at boot\n\n     1v98 : Allow Crypto SHA1 without SHA256/512 (for ESP8266 where flash is scarce)\n            Add better docs for the form of Wifi callback functions\n            Modify ESP8266/ESP32 callbacks to match the node.js style used elsewhere\n            nRF52: fix pin.toggle() on software-negated pins\n            Pixl.js: Reorder pins so 0..13 are also D0..13 for better Arduino compatibility\n            Fix dump() when used with code written using E.setBootCode(..), (fix #1398)\n            Allow parseInt/parseFloat to be used on very large strings if the number doesn't extend right to the end (fix #1397)\n            nRF5x: Fix memory leak on NRF.connect\n            Fix memory leak if an exception is thrown within a rejected promise\n            ESP8266: rewrite wifi.save and restore to use the storage lib (imp #1380)\n\t    ESP8266: Add missing option ssid_hidden for Wifi.startAP() (imp #1358)\n            Fixed double-connect issue for TCP sockets\n            Pixl.js: Ensure Pixl.menu changes to bitmap fonts\n            Pixl.js: tweaked bias/contrast to improve display quality\n            ESP32: update esp-idf to v3.0. BLE support - thanks to @jumjum. Erase flash before flashing. vars now 2500\n            ESP8266: rearange rf_cal_sector (fix #1294)\n            ESP8266: Wifi.scan() now return authmode as text \n            ESP32: Fix accidental initialisation of UART3 when switching to Telnet (fix #1362)\n            nRF52: Added `NRF.setAddress` to allow the MAC address to be changed\n            Added Graphics.setFontAlign for font alignment and rotation\n            Make software I2C bitrate and waveform more accurate\n            Move default I2C bitrate to 100kbit/sec\n            Linux: don't create a espruino.flash file if we're not writing to flash\n            Add height check for Graphics.createArrayBuffer(...vertical_byte:true) (fix #1421)\n            Add sanity check for debug trace print statement (fix #1420)\n            Fix handling of exceptions in switch statements (fix #1352)\n            Fix 'return when not in function' regression when returning inside a catch block (fix #1422)\n            Don't load saved firmware images from different firmware versions - saved JS code still loaded (fix #1174)\n            Remove Graphics.setFontAlign and Graphics.getModified on devices with low flash memory\n\n     1v97 : nRF52: fix NRF.on('connect',...) issue\n            STM32: Fix setDeviceClockCmd error for USB.setConsole()\n            nRF5x: Fix getPinMode, which fixes SW I2C after save()\n            Thingy52: Don't report contents of 'Thingy' in 'dump()'\n            Thingy52: Allow multiple sounds to play at once\n            nRF5x: Ensure Waveform triggers a finished event\n            Thingy52: Enable simple bootloader, add travis build for DFU\n            Add Serial.inject to allow data to be added as if it was received from that device\n            Fix UDP handling so that it copes with packets not all being received in one go\n            STM32L496: increase variables - use full 320kB of RAM as it is contiguous\n            Add a maximum time for setTimeout/setInterval (100 years)\n            Fix Storage.write when writing partial file of the same length and initial contents\n            Fix corrupted timer channels returned by Pin.getInfo\n            Add command history to debugger\n            Remove process.env.EXPORTS (EXPTR does the same but takes less space)\n            Thingy52: Add 9 axis MPU support\n            Errors now store message in 'message', not 'msg' (fix #1366)\n            Ensure 'in' operator checks the prototype chain (fix #1365)\n            Promise.resolve now handles promises/thenables as arguments (fix #1363)\n            try..catch now creates exception in its own scope (fix #1367)\n            Thingy52,Pixl.js: add default NFC URL of the Espruino IDE \n            Add ArrayBuffer.byteLength property (fix #1374)\n            setWatch(..., {edge:\"rising\",debounce:25}) is now default for built-in buttons\n            Pixl.js: add Pixl.menu function for easy menus, build in graphical_menu.js\n            Fix regression in MDBT42Q advertised name\n            nRF52: Add E.getBattery as a more global battery percentage function, deprecate `Puck.getBatteryPercentage`\n            Fix '.buffer' regression in 'JSON.stringify(new Uint8Array([1,2,3,4]).buffer)'\n            Allow `typeof 123 .testing` without an exception (fix #1351)\n            Add crypto.AES to Puck.js and other nRF52 Espruino devices\n\n     1v96 : ESP8266: no callback if SSID is not available (fix #1297)\n            ESP8266: esp8266 wifi getStatus doesn't show savedMode (fix #752)\n            ESP8266: cleanup defines WIFI_DBG and NET_DBG for RELEASE\n            ESP8266: switch to single ld file eagle.app.v6.new.2048.ld for ESP8266_4MB board\n            Allow JS modules to be built-in by adding files to JSMODULESOURCES\n            Fix slow/hacky handling of 7 bit serial data for STM32\n            Add more stack checks so invalid code `typeof typeof typeof x100` can't break stack (fix #1310)\n            nRF5x: Fix PWM output via Waveform class\n            Fix free stack checking on ARM\n            nRF52: Make slightly more space available for stack\n            nRF5x: Move to SDK 12.3\n            Stop stack traces from being gathered in functions for Ctrl-C (fix #1313)\n            nRF5x: Fix crash if I2C is used before being initialised (fix #1301)\n            Internal printf can now pad with spaces\n            Add `E.dumpFreeList` in non-release builds to help with debugging\n            Fix mild memory leak in jsvMakeIntoVariableName that caused GC to run more often than normal\n            E.toString now tries harder to allocate a Flat String, and works with no-alloc for Uint8Array/FlatStrings\n            WIO_LTE fix SD card initialisation\n            Improve SD card reliability on all boards by trying to initialise multiple times before failing\n            Remove forced inlining in variable inspection functions (reduces flash usage by ~10k)\n            Remove un-needed DNS lookup for localhost\n            Add WIZnet UDP support\n            Tidying up build to avoid making un-needed bin, hex or lst files\n            Simplify flash save (and help debugging) by using the 'fake flash' implementation on Linux builds\n            Added Graphics.scroll command to scroll graphics contents\n            Added 'Terminal' class with built-in VT100 terminal\n            Tweak Espruino logo to be exactly 32 chars wide\n            Improved code for returning console device to the most useful place\n            Fix pinToString for devices with port A but no port B\n            Speed improvements for ArrayBuffer Graphics\n            Tidied up bootloader - devices with one LED now flash LED when button pressed\n            Simplify data returned by process.env\n            Add process.env.MODULES - to contain a list of the libraries provided in the firmware by require\n            Include WiFi and AT libraries inside Espruino WiFi builds\n            Add 'E.asm' placeholder to detect E.asm calls that haven't been replaced by the IDE\n            Add process.env.EXPTR to link to table of functions - will work better for compiled code over BLE\n            Added SAVE_ON_FLASH_EXTREME for HYSTM32_28, where we're now cutting out some Math.X functionality to keep builds going \n            Added `jshFlashGetMemMapAddress` to allow remapping of addresses for ESP8266/ESP32 without loads of code duplication\n            Remap peek8/16/32 addresses on ESP32/ESP8266 so it can be used on flash memory\n            Swapped save/load/E.setBootCode to use the flash library\n            Allow STM32LL port to write 32 bits to flash at a time to bring it in line with other ports\n            Allow flash writes *from* unaligned addresses on nRF52 and ESP8266 (previously this crashed the ESP8266)\n            Update process.ENV.EXPORTS to bring it in line with what the compiler uses\n            Now set 'this' correctly for Arrow Functions\n            Add ES6 classes and 'super'\n            nRF5x: Move all bluetooth events to event queue (removing MEMORY_BUSY issues)\n            Fix potential issue where EV_TYPE_MASK enum could be set incorrectly  \n            setWatch's edge argument can also be an integer now\n            Add 'data' option to setWatch to allow clocked data to be decoded easily\n            nRF52: Increase flash available for stored code from 12kB for 40kB\n            Now store/display appreviated commit in process.env, remove build date\n  \n     1v95 : nRF5x: Swap to UART fifo to avoid overrun errors at high baud rates\n            Ensure Exceptions/errors are reported on a blank line\n            Internal: Added initialiser argument to jsvNewStringOfLength\n            Internal: Added jsvObjectSetChildVar/jsvObjectSetChildVar/jsvObjectSetChildVar\n            Internal: Fix jsvCopy if given a NAME_INT/etc\n            Added ES6's Object.assign\n            nRF5x: NRF.setScan now reads service data automatically\n            nRF5x: NRF.findDevices aggregates data from multiple advertising packets\n            nRF5x: Remove app_uart and use nrf_drv_uart with double buffering - fix uart overflow errors (fix #1238)\n            nRF5x: Fix issue with findDevices/setScan servicedata when all digits of service are numbers (eg \"1809\")\n            Fix memory leak in tab completion code\n            Add `E.errorFlag` event to allow JS to respond to internal errors\n            Use Esc[J VT100 code when cycling through command history (much faster REPL on low bandwidth connections)\n            ESP8266: Remove debugger again as it will never work on 8266\n            ESP8266: Enable unaligned reads for ESP8266_4MB (fix #1240,#837)\n            ESP8266: move code save section to fist partition for memory mapping for ESP8266_4MB (fix #1240)\n            ESP8266: Add GPIO16 as D16 without watch (#1206) but soft PWM/I2C/SPI/etc \n            ESP8266: Remove osprintf for RELEASE=1 \n            Internal: Networkjs now forwards `socketType` - laying groundwork for UDP over AT command (#1232)\n            Added simple RegExp implemention (partial fix #256)\n            Speed up JSON.stringify for Arrays, and output non-numeric array elements in REPL (fix #64)\n            nRF5x: Bump nRF52-based boards variable count from 2000 to 2500 (fix #1215)\n            Ensure Ctrl-C doesn't redraw the input line if it's already empty\n            Added String.replace(regex, function) (fix #1256)\n            With E.setFlags({pretokenise:1}), ensure stack traces are not tokenised (fix #1258)\n            Allow digitalWrite/Read to take an object as an argument (calling .write and .read on it)\n            Add `E.getAddressOf` to allow embedded targets to get memory addresses for DMA/etc\n            nRF5x: Fix issue where doing a soft reset in the middle of some BLE ops could cause an assert in debug builds\n            nRF5x: Manufacturer Data is now decoded in advertising packets\n            Fix memory leak when allocating DataViews\n            nRF5x: Fix memory leak on BLE notifications\n            Ensure net/http .listen return the server instance (fix #1276)\n            nRF5x: Allow Manufacturer Data to be specified with setAdvertising\n            Internal: Fix memory leak in jsvArrayPushAll\n            nRF5x: jsvArrayPushAll memory leak fixes NRF.findDevices memory leak when services present\n            Internal: jsvNewIterator now has an option to iterate over sparse arrays as if they weren't sparse\n            Fixed some built-in functions that misbehaved when given sparse arrays\n            Puck.js: Allow flash memory protection to be overwridden with E.setFlags\n            Fix lexing of '/*/' as a complete block comment\n            nRF5x: Add support for negating pins in software (eg. buttons/LEDs)\n            Add `E.setFlags({unsyncFiles:1}` which doesn't sync the file to the SD card after each write - it's *much* faster\n            Filesystem API now uses flat strings (avoiding the 512 byte copy for each call)\n            Increase default internal SD card bitrate to 4MHz (from 100k)\n            nRF5x: Handle promise completions and advertising using IO queue, to avoid MEMORY_BUSY messages (#1277)\n            Allow E.HSBtoRGB to wrap 'hue' value, and allow it to return an array of [r,g,b] (fix #1283)\n            Remove spikes when changing pin state (fix #1274)\n            Changes to reduce code duplication in jswrapper.c\n            Fix `E.setBootCode` when no argument is supplied\n            Add WIZnet W5500 support to Espruino WiFi build\n\n     1v94 : Allow Espruino boards to reset straight out of the DFU Bootloader             \n            Improvements in handling errors in code running in IRQs\n             - if writing to disconnected Bluetooth device, throw data away immediately\n             - Drop chars if output buffer is full while waiting in an IRQ\n             - Handle out of memory errors in jsvCreateNewChild\n             - Do not garbage collect inside an IRQ\n            On nRF52 devices, allow button press at boot to clear out peer manager data\n            Work out length of typed array with offset correctly (fix #1204)\n            nRF5x: Add Watchdog timer handling\n            nRF52: start new connections on idle to ease memory allocation conflicts between code execution & IRQs\n            nRF52: Ignore INVALID_STATE from CONN_PARAM_UPDATE_REQUEST (it can happen if we disconnect and then SD requests an update)\n            Fix Date.toString for dates before 1970\n            STM32: Fix handling of months when setting the internal RTC\n            Move to a faster jsvNewFlatStringOfLength which avoids blocking memory allocation\n            nRF5x: If a task is in progress, report the task ID (BleTask enum)\n            nRF52: Report central mode promise errors correctly if returned by softdevice\n            Remove 'out of memory' warning messages (it's stored as a flag anyway)\n            nRF5x: Don't disable IRQs completely for some things - only disable Espruino ones\n            Fix tab complete for Pins (fix #1213)\n            ESP8266: Fix load() causes endless loops (fix #1037)\n            ESP8266: Wifi library doesn't handle {password: null} (fix #753)\n            ESP8266: make topstrings and topreadonly work on Mac OS X (fix #1210)\n            Change order of execution for init - E.on('init',...) now executed before onInit\n            Added Error flag to show if a UART overflow has occurred\n            Change more instances of jsWarn to jsException\n            Avoid printing error messages during execution, and report to console on idle when if errors were flagged (fix #766)\n            Increase HTTP server and client version from 1.0 to 1.1 (needed for Websockets on Safari)\n            Stop 'require' creating an undefined Module entry in the modules list (fix #1218)\n            Stop require dumping filesystem errors as well as 'module not found'\n            Now throw an exception when writing to a closed socket (fix #1220)\n            Set the internal 'conn' variable to false when a connection closes to avoid confusion\n            nRF5x: Fix typo so we wake every 4 min for RTC, not 0.25 sec!\n            process.memory() now reports time taken for GC and vars GC'd\n            Slightly more aggressive idle GC on most platforms (at 5% free)\n            Don't warn the user when we had to run a GC pass during execution\n            Fix issue drawing on right-hand side of rotated graphics where H>W (regression in 1v93) \n            If >1 button, set pin state correctly at boot/reset\n            Add an argument to `reset`. `reset(true)` will now cause all Flash memory to be cleared as well.\n            Puck.js: Holding down the button while booting (past the the 5 LED flashes) will now cause data saved in Flash to be cleared\n            STM32: Remove the 'utility timer' from the list of available PWM pins, fixing A0/1/2 PWM on F4 (fix #1229)\n            Disable Graphics.createCallback on devices with small amounts of flash memory - rarely used on those devices and fixes HYSTM32_28 build\n\n     1v93 : Ensure that specifying too many advertising UUIDs causes an exception, not a reboot\n            nRF5x: Fix for time jump caused by reentrancy in jshGetSystemTime\n            Fix regression causing multiple end/close callbacks when using standard TCP/IP socket client/server\n            Ensure NetworkJS reports receive errors back correctly\n            nRF5x: Fix issue where connect and immediate disconnect could in some cases trigger an error from nordic's libraries that'd cause a reboot\n            Fix regression that caused Original Espruino to have lost Filesystem/hashlib/neopixel support in 1v92\n\t    Re-add TV output to Original Espruino\n            Fix some stack overflow bugs on Linux found by fuzzing (#1147)\n            Remove un-needed code for parsing '.' in var statement (#1147)\n            Add autocomplete for pin names (fix #1124)\n            Add Array.indexOf fromIndex support (fix #162)\n            Puck.js: Add BluetoothRemoteGATTServer.startBonding to allow bonding to be initiated when Puck.js is a central\n            Fat FS: closedir after readdir, FS errors should be catchable (#1164), fs.statSync (#1163)\n            Allow hardware (CTS) flow control (fix #1165)\n            nRF52: Add AntiCat's patch to Nordic's NFC library to cope with malformed NFC requests\n            Puck.js: Fix increased battery drain after NFC usage (fix #1171)\n            Puck.js: Fix WS2811 output library that would output bad data after neopixel waveform (fix #1154)\n            nRF52: Seed random number generator at boot (fix #1166)\n            Stop trailing decimal point if there are no digits after it - which could cause issues in JSON\n            Don't enter debugger if we're in the middle of uploading (echo_off_for_line) (fix #644)\n            Added Date setters (fix #504)\n            Allow Timezone to be set for Date with E.setTimeZone(...) (fix #530)\n            Added RegEx lexing (part of #256)\n            Puck.js: fix error 8 from NRF.sleep during an active connection \n            nRF5x: Fix `NRF.updateServices` when a 128 bit service shares the same 16 bit UUID\n            Add 'errors' option when using `Serial.setup` to enable error handling (and turn it off by default as it can fill the input queue)\n            nRF52: Re-initialise services and HID after a `save()` (fix #1185)\n            nRF5x: Add NRF.getAdvertisingData\n            nRF5x: Allow array of objects in NRF.setAdvertising (fix #1188)\n            Fix internal vcbprintf JSON dumping\n            nRF5x: NRF.findDevices will now throw an exception if no callback is supplied\n            nRF52: Added BluetoothRemoteGATTServer.getSecurityStatus to check the status of the link\n            nRF52: Disable auto-whitelisting by default, add with `NRF.setWhitelist` (fix #1187)\n            nRF52: Allow secure Bluetooth LE connections\n            Don't draw font characters that are off the edge of the screen\n            Make atob and btoa use flat string for larger amounts of data (faster & more memory efficient) (fix #1192)\n            nRF52: Pull in Nordic SDK13 code to crash caused by writing large characteristic (fix #1181)\n            Puck.js: Added Puck.magTemp() function to get the magnetometer's temperature as well\n            nRF5x: Fix issue where 'NRF.sleep()' called while a connection was active could cause Espruino to go into a high power draw mode\n            Fix Object.setPrototypeOf when called on undefined (fix #1194)\n            Fix dumping of an ArrayBuffer containing data (new ArrayBuffer([1,2,3]) isn't valid)\n            Fix setAdvertising regression where name would be lost after save() (fix #1193)\n            Add `E.set/getFlags` to allow interpreter state to be controlled from one place\n            Add `E.setFlags({pretokenise:1})` to dynamically turn on pretokenisation (fix #1178)\n\n     1v92 : nRF5x: Fix issue where Espruino could crash during save() if the flash got into a strange state\n            Added Pin.toggle() function\n            Fix implicit casting to bool/number on ArrayBuffers (fix #1030)\n            Fix jstExecuteTaskChecker bug, and allow jstExecuteFn to take a userdata argument\n            Puck.js: Reduce IR LED to 10% duty cycle\n            Puck.js: Allow Puck.IR to take pins for external IR LED (fix #927)\n            nRF52: Allow arbitrary NFC data to be specified (fix #1021)\n            nRF5x: Allow multiple advertising packets to be set at once with NRF.setAdvertising\n            nRF52: Add 'properties' object to BluetoothRemoteGATTCharacteristic\n            nRF52: Perform write without response if that is what is required \n            Pico/WiFi: Allow USB HID to work on Windows (from @nailxx)\n            Allow Puck.js/nRF52 devices to drive Neopixel/WS281x/APA10x LEDs with require(\"neopixel\").write (fix #1023)\n            Fix crash in JSON.stringify for zero-length typed arrays\n            Fix precedence of 'void' keyword (fix #1079)\n            nRF52: Add BluetoothRemoteGATTCharacteristic.startNotifications (fix #959)\n            nRF52: Added BluetoothDevice.gattserverdisconnected event\n            nRF5x: Report back reason codes for BLE disconnect\n            Added DataView class\n            nRF52: char.readValue now returns DataView to be more Web Bluetooth compliant (fix #1091)\n            nRF5x: Fix explicit disconnect being able to reboot Puck (fix #1088)\n            nRF5x: Respond to conn_params update request, fix puck-puck disconnection after ~65 sec (fix #1089)\n            nRF52: Change connection params for central mode so NRF.setLowPowerConnection affects connection speed\n            Un-inlining jsvGet*AndUnLock functions to give us a little more free flash\n\t    ESP8266: RELEASE=1 sets WIFI_DBG and NET_DBG to 0 to shrink firmware size\n\t    ESP8266: Add Wifi.setAPIP() and Wifi.setIP\n\t    ESP8266: Add i2c clock stretch (#1097)\n\t    Fix E.FFT output (enable magnitude when one array specified)\n            Puck.js: Correct reading if using analogWrite to red LED and *then* using Puck.light()\n            Improved build process for all boards\n            Pin.toggle now returns a boolean (fix #1111)\n            nRF52: Now use 'high drive' mode for GPIOs\n            Puck.js: tweak IR duty cycle, with high drive GPIO range is ~3x more\n            nRF52: switch compilation to size optimisation, not speed\n            nRF5x: Allow services to be advertised (fix #996)\n            JSON.parse now throws an exception if an incorrect value type is found (fix #1117)\n            Pipe close event handlers now use 'this' arg - solves auto-closing pipe when piping from HTTP\n            nRF5x: stop app_timer NRF_ERROR_INVALID_PARAM errors (trying to sleep for too little time)\n            Added flash emulation to Linux port\n            Increase max graphics size from 1023 to 32767\n\t    Add Fat File System to boards with large Flash (ESP32)\n            nRF52: Don't get stuck in 'HID Busy' state if a HID send failed\n            Change name of socket close internal variable so it doesn't conflict with Pipe's close call\n            Stop pipe from causing errors if fields of the requested names exist but aren't functions\n            nRF52: Fix upgrade from older firmwares if saved code is in flash, reduce virtual pages to 2\n            Fix segfault detected by fuzzing (#1133)\n            Fix File.read so that end of file triggers pipe.end event\n            ESP8266: Add BOARD ESP8266_4M with 1600 vars, 64K save area and GRAPHICS (#1110)\n            ESP8266: Add ESP8266.deepSleep(micros, option) (#1102)\n\n     1v91 : Fix recent regression if no Boot Code defined at startup\n            Fix handling of return of rejected promise within a promise\n            Fix regression where HTTPS without cert/ca or key failed\n            nRF52: Making NRF.getPrimaryService/etc more robust\n            nRF5x: Add NRF.getAddress() - fix #1001\n            Fix bug that caused load() not to clear memory if only E.setBootCode was used\n            microbit: Update Espruino with pin polarity, so saved code gets loaded without BTN1 pressed\n            Fix bug that caused Bluetooth/TV/USB objects to be added in devices that didn't support them (fix #832)\n            nRF52: Increase custom UUID count from 3 to 10\n            Adding Global built-in objects like SPI1/Serial1 and Bluetooth to the docs\n            Puck.js: Tweak battery percentage calculation to try and make it more linear\n            Puck.js: Adjust Puck.light() levels based on battery percentage (and add comments)\n            nRF5x: Fix E.hwRand() (fix #1010)\n            Ensure tab complete/others include the Object proto even on functions/strings\n            nRF5x: Add NRF.restart() to force the restart of the Bluetooth Softdevice if required\n            nRF5x: Add E.setLowPowerConnection(bool) to allow continuous connections to Puck.js (fix #995)\n            Allow implicit conversion of hexadecimal strings to numbers (fix #1016)\n            Allow arrow functions inside nonexecuting functions (fix #1011)\n\n     1v90 : Fixes for Promise.all (passing in non-promises, pre-resolved, and ordering) (fix #976)\n            Fix arrow function bug when parsing multiple arguments\n            Added more helpful error messages for TLS\n            Allow `Modules.addCached` to take a function (makes module loading more memory efficient)\n            Re-add Espruino's old `rand` function (so no malloc, and ~1kB RAM, ~3kB ROM saved)\n            nRF5x: Ensure 'NRF.sleep' works even when connected\n            Fix bug when using >32 bit integers as array indices (fix #984)\n            Fix bug when parsing '.catch' while not executing (fix #989)\n            Stop PWM 'glitching' when moving from a nonzero value down to 0 (partial #991)\n            nRF5x: Add multi-channel hardware PWM (fix #991, fix #972)\n            'dump()' now outputs code written with E.setBootCode as well (fix #999)\n            nRF5x: Remember advertising information even after softdevice reboot  (fix #997)\n            nRF51: Remove heap placeholder on nRF51 as not needed since no malloc. Increase nRF51 var count (fix #985)\n            nRF5x: 'connect' event now contains address of device that has connected, and fix docs\n            nRF5x: Add a 'NRF.disconnect' function to disconnect a client that has connected to Puck.js\n            nRF5x: Fix timing accuracy problems with setWatch\n\n     1v89 : Allow entering of multi-line Templated Literals on the command-line (fix #970)\n            Make lexer fail when parsing non-templated strings with newlines in \n            Add 'let' and 'const' keywords - treat them like 'var' for now\n            Increased findDevices timeout to 2 seconds\n            Allowed 16 bit UUIDs to be specified as simply \"ABCD\" (no \"0x\")\n            Improved BLE error messages (especially from Promises)\n            Fix STM32F1 regression caused by F4 LSE fixes\n            Fix comma operator regression caused by recent arrow functions addition\n            Remove RTC changes for STM32F1\n            nRF5x: Make sure that updateServices(notify) on a non-notifyable service will just error, rather than reset (fix #973)\n            nRF5x: Ensure setWatch doesn't reset pin state\n            nRF5x: Reset pin states to default on 'reset()'\n            nRF5x: Move advertising back to 375ms (more reliable connections)\n            Puck: allow Puck.mag to work while magnetometer is on\n\n     1v88 : jshSetEventCallback callbacks now get an argument with the channel number\n            Tab complete now offers a much better set of completions (fix #926)\n            Fix emitting of events with long names (fix #906)\n            Ensure 'af_opendrain' pin mode gets remembered when saving (fix #890)\n            Add second Promise.then argument (fix #869)\n            Fix 'chained' promises (fix #894)\n            Fixed memory leak when automatically converting a simple object to a String\n            Added ES6 Template Literals\n            Initial commit of ES6 arrow functions\n            Add 'opendrain_pullup' pinMode (including emulation on STM32F1)\n            Make OneWire use opendrain_pullup (no resistor needed for short runs now)\n            Add Software I2C (with opendrain_pullup) (ref #549, fix #29)\n            Cope with new escape codes for home and end on Ubuntu 16.04 (27,91,70/72)\n            Tweak VGA output back porch to 2ms (so leftmost pixels always on screen)\n            Fix regression with 2 concurrent waveforms on different pins (fix #930)\n            nRF5x: add updateServices, and allow setServices to be called multiple times (partial #936)\n            Added Puck.getBatteryPercentage() utility function\n            nRF5x: setServices can now uninitialise SD in order to remove added services\n            Added E.lockConsole() for use with E.setPassword()\n            Calling jsvRemoveChild at end of array now updates the length (fix #946)\n            Allow padding to be specified as 3rd argument of JSON.stringify\n            JSON.stringify now dumps typed arrays as arrays (fix #489)\n            nRF52: BLE HID support and switchable Nordic UART\n            Fix STM32 regression where pinMode was set when it shouldn't have been\n            Add Third option to pinMode to allow the pin mode to be set while keeping it 'unforced'\n            Save and dump now keep track of whether pin mode had been forced or not\n            readFile (and File.read) now uses Flat Strings to allow more memory efficient reads (fix #932)\n            nRF5x: Add ability to get RSSI of current connection (fix #928)\n            More STM32 changes to LSI->LSE clock switchover to fix RTC misconfiguration on Espruino WiFi\n            Move LED + BTN definitions to Symbol Table (allows autocomplete)\n            When moving console before printing has started, move all buffer contents as well\n            Fix regression where replacing a function starting with 'return' with another would cause errors\n            Fix potential issues with Telnet server and return values from netCreateSocket/netAccept on some platforms (fix #931)\n            nRF5x: Add Puck.js self-test code, fix issue where analogRead reset pin state\n            nRF5x: Change central mode API to mirror Web Bluetooth\n            Fix switch fall-through to default (fix #964)\n            Started using jsvObjectRemoveChild to remove some internal object properties that are undefined (frees some variables)\n            Added E.dumpLockedVars() in non-release builds to help debug memory leaks in libraries\n            nRF5x: Added NRF.findDevices as a helper function to easily list BT devices in range\n            Console now prints the type of Objects if their constructor is in the root scope\n            nRF5x: setScan/findDevices now parses advertising data\n            nRF5x: Added Web Bluetooth style requestDevice function\n            Add spaces between large tab completes\n            Correct the handling of exceptions in promises\n            Ensure that exceptions have a 'stack' attribute if they can have children\n            nRF5x: Added list of free flash areas\n            Make sure Puck.js users can't overwrite bootloader/softdevice (doing so would brick the board)\n            Fix micro:bit/nRF51 ctrl-c behaviour (fix #905)\n            Simplified process.env on devices with little memory\n            nRF5x: fixed serial number reporting\n            Move button state setup to jshResetDevices\n            Had to remove 'dump()' and SW I2C on devices with very little flash memory (Olimexino/Micro:bit)\n\n     1v87 : Add support for compiling with float-abi=hard (even if it doesn't give us real-world benefits)\n            Add shortcut for quick execution of common call types\n            Fix BBC micro:bit save() regression from 1v86\n            Fix 'lock overflow' when calling methods with 'this' bound (fix #870, fix #885)\n            Fix jsvStringIteratorGetCharOrMinusOne for zero-length strings\n            Allow tab-completion straight after '.'\n            Make sure execution stops for native functions if there's an error when parsing arguments\n            NRF5x: remove setName and add functionality to setAdvertising, along with advertising interval\n            NRF5x: allow raw advertising data in setAdvertising\n            Add E.setPassword - allows Espruino console to be locked\n            Fix pin header numbering for BBC micro:bit (it changed for the production version) (fix #896)\n            Allow Magnetometer speed to be specified for Puck.js\n            Fix out of memory when appending a string to itself\n            Allow members of the same name as function arguments to be added to a function (fix #913)\n            Fix STM32F4 RTC stopping if reset during first 1 sec of boot, also fix Espruino WiFi board clock startup\n            Fix issue where native functions couldn't be replaced by non-native fns (fix #879)\n            If statements now return values (fix #909)\n            Fix >8 bit SPI when sending single elements with SPI.send (fix #897)\n            Sockets now fire 'end' events (fix #886)\n            Added Graphics.draw/fillCircle (fix #920)\n\n     1v86 : Compile Telnet server into linux by default, Add '--telnet' command-line option to enable it\n            Fix lock 'leak' in Telnet when Telnet is turned off\n            Add Telnet serial device to allow redirection\n            Create errors for unterminated expressions (fix #814)\n            Remove Espruino's built-in strcpy/etc\n            Remove Espruino's built-in maths\n            Add basic Taylor series sin and atan for when we're trying to save memory\n            Refactoring to use global var for lexer - save some memory and increase parse speed\n            Add .removeListener (fix #30)\n            Added better micro:bit `show()` that works well with Graphics\n            Add `require(\"Flash\").getFree()` as multiplatform way to find free flash pages (fix #815)\n            Add the ability to set clock frequencies on STM32F4 chips (like Pico) with E.setClock (fix #52)\n            `jsvEvaluate` now uses memory area for execution of JS strings (fix #817)\n            Add `E.setBootCode` to allow JS scripts to be run without being in RAM (fix #740)\n            'Expecting a number or something iterable, got X' changed to exception rather than warning (gives stack trace)\n            Drop '.init' and '.fini' symbols, allowing GCC 5.x compilation on STM32\n            Ensure that pinMode/digitalWrite is re-constituted properly by dump() and save() (fix #833)\n            ESP8266: add stack dump on fatal exception, ./targets/esp8266/printstack can extract a backtrace\n            ESP8266: move JswSymPtr and JswSymList to flash to free up gobs of RAM, bump jsvars to 1600\n            Fix write to flash when BLE connected on nRF51/2\n            Fix potential variable corruption issue when copying objects/arrays containing packed ints\n            Fix ESP8266 printLog memory leak (fix #852)\n            When parsing from a Native String (E.memoryArea), use Native String for function code too.\n            Added built-in Promise implementation\n            Fix broken Object.keys/getOwnPropertyNames caused by ESP8266 RAM saving tweaks\n            Add Object.g/setPrototypeOf (fix #856)\n            Fix memory leak when executing bound function with 'this'\n            Fix missing PBKDF2 & AES libs on Pico + Linux caused by an untested ESP8266 commit\n            Fix negative Date to string code (fix #854)\n            Convert type warnings to exceptions (to provide stack traces for problems)\n            Add uncaughtException event (fix #846)\n            Stop eval in a switch statement from confusing parsing (Fix #845)\n            Fix regression in 'mode' argument of SPI.setup (allows custom CC3000 pins to work)\n            Fix '.on' with long event names\n            Enable F4Discovery button pull-down. Newer boards don't seem to have one fitted\n            Add 'force' to 'Serial.setConsole' - you can force the console to stay in one place\n            Fix micro:bit compass problems (fix #864)\n            Ensure that Pico can properly enter deep sleep even if USB is never used\n            Only inline the very basic variable iterator functions (save enough space to allow Espruino board build again)\n            Don't include Promises on devices where flash memory of Scarce (fix Olimexino compile)\n            Fix glitches in PWM output when updating Software PWM quickly (fix #865)\n            Added `E.kickWatchdog()` to allow you to keep your JavaScript running - not just the interpreter (fix #859)\n            Ensure all pins set to AIN on startup\n            Fix regression where setWatch would remove pulldown from button if called after reset()\n            Reduce amount of flash available for saved code on Original Espruino (until we can get code size down)\n\n     1v85 : Ensure HttpServerResponse.writeHead actually sends the header right away\n             - enables WebSocket Server support from JS\n            Fix issue where GC'd objects referencing non-GC'd data wouldn't unreference it\n            Add E.memoryArea to allow memory addresses to be treated as variables\n            Fix STM32F4 LSI clock frequency - should make the Pico's RTC a lot more accurate (fix #776)\n            Added HeatShrink compression to saved code (instead of RLE)\n            If saving fails, delete command history and try again.\n            Make sure `reset()` resets the sleep and busy indicator pins\n            Now escape characters >=127 as well (fix #780)\n            Add decodeURIComponent (fix #779)\n            Allow reset();save() on one line\n            Fix potential issue parsing HTTP headers when more data is sent after the header (fix #783)\n            Fix broken storage of floating point values when <255 variables\n            Fix regression where DACs didn't work on Original Espruino Board\n            Improve tab complete's memopry usage\n            Added Tab complete and Debug to low-end Nordic uCs\n            Limit the number of events processed each time around the idle loop to the number that were in it at the start\n             - helps to fix issues with out of memory when receiving big files over ESP8266 serial connection\n            Allow different types of network to have different buffer sizes - enlarge JS, Linux and WIZnet buffers\n            Fix bug where clearInterval() and setWatch with debounce could cause setWatch to momentarily stop working\n            Make HTTP server only close connection after Content-Length bytes received\n            Speed up jsvNewFlatStringOfLength by combining it with updating the free var list\n            Update the free var list when garbage collecting (makes allocation at the start of memory more likely)\n            Don't zero the contents of memory when freeing - speeds up deallocation\n            Removal of un-needed zero initialisations for variables\n            Only garbage collect on idle if we're low on memory (fix #767)\n            Improve malloc behaviour for crypto lib (try and free all command history is first alloc fails)\n            Improve HTTPS error messages\n            Add READ_FLASH_UINT8, allowing ESP8266 to read&exec strings stored in Flash with E.memoryArea\n            Start the RTC up running off LSI, and switch after a few seconds if the LSE has started correctly\n            Allow JSV_GET_AS_CHAR_ARRAY to get a pointer to memory in ArrayBuffers or memoryAreas\n            Reset PinStateIsManual in reset (fix #765)\n\n     1v84 : Fix device initialisation flags not working when the device number is above 32 (fix #751, #748)\n             - this fixes broken SPI when not on standard pins\n\n     1v83 : Moved to size optimisation for Pico (needed to get HTTPS into 384kB)\n            Ensure Modules.addCached doesn't reset parse state (fix #723)\n            dump() in Espruino Pico now ignored the pull-down for the button (fix #731)\n            Warn when \"compiled\" functions gets into Espruiono (fix #707)\n            Fix lost character on Espruino Startup (fix #704)\n            Fix duplicated characters when USB+USART IRQs fire at the same time  (fix #635)\n            Fixed Serial.find(...)\n            Detect UART framing and parity errors and emit them as events on the Serial object\n            Fix [] instanceof Object (fix #737)\n            Fix regression in jsvCopyNameOnly (Object.getOwnPropertyNames when names are >8 characters long)\n            HTTP requests (and sockets) can now emit 'error' event (fix #706)\n            Add optional `ca`,`key`, and `cert` for server public key when using HTTPS or TLS (fix #736)\n\n     1v82 : Fix debugger regression (where quit/reset/etc don't exit properly)\n            Fix wakeup when setDeepSleep used at startup (fix #645)\n            Add `shiftOut` function (fix #631)\n            Store line numbers for functions (via `Esc [ 1234 d` escape code before decl) and use in debug + stack traces\n            Allow Ctrl-C to break out of tight loops with function calls in\n            Add tab -> autocomplete in Console (fix #677)\n            Fix I2C repeated start (#390)\n            Fix regression in Math.random() - now back between 0 and 1 (fix #656)\n            Fix `var a=0;typeof a -> \"undefined\"` (fix #683)\n            Don't store brackets in functions (fix #204)\n            Store functions as 'flat strings' if long enough (fix #467)\n            Move most functions out of jsvar.h header file - improves code size on devices where they're not inlined\n            Fix parse error for switch statements which meant that `switch (a,b)` caused an error\n            Fix error message when `LoopbackA.setConsole()` called\n            Move SPI/I2C/Serial initialisers to jsvReadConfigObject, will now error on invalid args (fix #413)\n            Fix issue where double-buffered waveforms would use the wrong buffer in the callback\n            Fix memory leak in tab autocomplete on objects\n            Added AES crypto library (Pico only)\n            Fix `typeof (new Uint8Array([1, 2, 3, 4]))`\n            Store `function(){return ...}` without the return (fix #700)\n            Increased simple string usage from 4 chars up to 8\n            Swap order of JsVar internals, string usage up to 10 chars\n            Add handling for uint32_t,uint64_t,uint32_t case for Raspberry Pi\n            Add startup sanity checks for jsnative.c (in non-release builds)\n            Added fix for returning floats on Raspberry Pi\n            When <1024 JsVars, `lastChild`'s top bits are stored in `flags`, and pack\n               is moved such that we get 1 extra character in StringExts\n            Allow events of >12 characters length\n            Fix regression in flash memory write (introduced via AES merge)\n            Fixed instability when resetting after using SD card on non-standard pins\n            HTTPS support on Pico (when compiled in)\n            Rename USE_HTTPS to USE_TLS, and enable by default for Pico + Linux\n            Add 'tls' module with 'connect' - for TLS Socket connections\n\n     1v81 : Fix regression on UART4/5 (bug #559)\n            Fix Serial3 on C10/C11 for F103 boards (fix #409)\n            Remove Graphics.setColorHSV, add E.HSBtoRGB (fix #554)\n            Make jsiDumpState/jsiAppendHardwareInitialisation use callbacks (fix #398)\n            Add `E.dumpStr()` to dump current state of interpreter as a string\n            Add ReferenceError, and ensure that TypeError gets converted to a string properly\n            Actually create ReferenceError for undefined variables\n            Fix Object constructor behaviour (fix #561)\n            Now remove intervals/watches if they occur within 0.1s of a Ctrl-C on a blank line\n            Fix parsing of trailing commas [,,1,,,]\n            Treat vertical tab as whitespace\n            Make sure we ReferenceError on '+='/etc\n            Allow reserved words in record access and structure definitions\n            Add Object.defineProperty/defineProperties (even if they ignore most args)\n            Fix value returned when redefining an existing function\n            Ensure Pico powers down USB in deep sleep - now down to 20uA!\n            Fix Exception throw within catch block (fix #566)\n            Fix issue where new Array(3.0) wouldn't produce a 3 element array\n            Keep track of modified area in Graphics (so modules with `.flip()` can be speeded up)\n            Fix `new Date('December 17, 1995 03:24:00')` - check only first 3 chars of month\n            Allow Software PWM via `analogWrite(..., {soft:true})`\n            Add `encodeURIComponent`\n            Make sure `typeof unknown` doesn't ReferenceError\n            Fix isNaN behaviour for 2 element array\n            Fix jshPopIOEventOfType when element is at the top of queue anyway\n            Produce more reasonable behaviour when converting very long strings to ints/floats\n            Added built-in JavaScript debugger! See espruino.com/Debugger for details (fix #37)\n            Fix crash when using E.getSizeOf() in some cases\n            Make sure a TCPIP connection closes even if no data sent\n            Make `flash.erasePage` safe if called without arguments (fix #586)\n            Add `Pin.getInfo` to see what a Pin can do (for #93)\n            Move Pin function code out of jshardware\n            Add `E.on('init', ...)` - like `onInit` but allows multiple handlers\n            Make sure `dump()` and `E.dumpStr()` dump the contents of Serial as well as events for other objects\n            `E.getSizeOf(.., 1)` can now recurse into objects showing the sizes of all their children (fix #579)\n            Fix bug when appending to a flat string (fix #614)\n            Add `Serial/SPI/I2C.find(pin)` - so we can figure out what device to use based on the pin\n            Ensure that when uploading, each command gets checked for errors (rather than right at the end)\n            Fix writes on HTTP requests after a timeout, and add chunked encoding if the header is set.\n            Added pin info for bit-banded pin addresses (and jshGetPinAddress).\n\n     1v80 : Fix SD card IO that can corrupt SD card on file append since 1v73 (fix #536)\n            Fix some potential pointer issues in hashlib\n            Make debounced setWatch output state+time information (regression fix #537)\n            Shorten some internal property names (faster/less mem is 4 chars or under)\n            Change 'internal property' prefix from '>' (fix #540)\n            Duplicate properties in an object defn. now cause second to be used (fix #495)\n            Make sure `E.unmountSD` doesn't forget custom SD card configs from `E.connectSDCard`\n            Added support for USB CK pin (fix #544)\n            ES5 parseInt behaviour - don't treat numbers beginning with 0 as octals (fix #538)\n            SPI.send now returns Uint8Array when passed an array. Also takes `{data:X, count:Y}` as argument (fix #485)\n            Fix `parseFloat(Infinity)` (fix #314)\n            Speed up jsvIterateCallback for arraybuffers\n            SPI speed improvements, esp for SPI.write (fix #547)\n            TV out tidyup, and VGA output can now do line doubling\n            Merge in USB HID support for STM32F4 (keeping old USB for the F1)\n            Add built-in 'Flash' module to allow Flash memory to be accessed from user code\n            Pulled load/save code out of jshardware into jswrap_flash.c\n            Remove jsiOneSecondAfterStartup from Linux builds (fix #551)\n            Add RLE compression when saving to flash, increase Pico RAM from 3000 to 5000 vars (fix #543)\n            Fix `JSON.parse` when not given strings (fix #546)\n            Tweak Olimexino board - 700->1k vars, but lowered code flash to 6k\n            Disable flash prefetch on Pico (~1% slower, but less power and way more accurate ADC readings) (fix #545)\n            Now throw errors when 'in' is used on an invalid datatype (fix #550)\n            Updated (inaccurate) docs for Serial.write/print and removed duplicated code\n            Changed Pico's device class to 0x02 - now works on older Mac OS 10.6.8\n            Change reported USB HID type to 0, from 2 (mouse)\n            Improve digitalWrite/etc documentation\n            Add `pin.mode` and `pin.getMode` functions (mirroring `pinMode`)\n            `Serial.setup` now remembers options if none specified (fix #557)\n\n     1v79 : Fix Mac address parsing for top nibbles\n            Make bind reference function internals not copy them. Fix scoped vars in bind (fix #533)\n            Use jsvUnlockMany to tidy up code and save some space\n            jsiExecuteEventCallback can now take an arbitrary number of arguments\n            Allow setTimeout/setInterval to take extra arguments (fix #532)\n            Ensure HTTP is closed even when no data handler (fix #535)\n            Seed random number from analog input, add W.hwRand and E.srand (fix #534)\n            Fix timing bug when setting timeouts from intervals in Deep Sleep\n            Reduce timeout for IO (eg. I2C write) on F401 and F4\n            Tweaks to keep code size low enough for Olimexino\n\n     1v78 : Fix regression where SPI2/3 weren't working on most pins (fix #525)\n            Allow MAC address to be set for WIZnet (fix #527)\n            Ensure res.on('close') is called for empty HTTP requests (fix #528)\n            Ensure that A9 is never the default pin for USART1 output (fix #526)\n\n     1v77 : Add E.mapInPlace\n            Allowed ArrayBuffer Graphics to store pixels MSB-first\n            Added faster software SPI path for simple writes\n            Make sure filesystem support gets compiled into Espruino Pico\n            Fix jsvGetFlatStringPointer to return the correct address\n            Fix I2C2/I2C3 on Pico\n            Fix issue where garbage collect of a Flat String corrupted the free variable list\n            Fix issue where Array.sort on big array with identical elements failed (#515)\n            Add 'modules' variable, and set 'this' to 'exports' when parsing a module (fix #520)\n            Fix instanceof implementation (and fix mem leak) (fix #523)\n\n     1v76 : Merged in NetworkJS library (for JS networking implementations)\n            Ensure that 'wrapped' libraries are killed before timers/watches\n            Made 'Field or method doesn't exist' report back the field that doesn't exist\n            Added quick and dirty scripts/test262.js runner script\n            Fix propogation of Errors and Exceptions through function calls\n            Allow parsing of integers > base 16\n            Now allow functions with >16 arguments (fix #490)\n            Fix assert fail for syntax error in do or while loop\n            Maths operations now call Object.valueOf if it's needed\n            Fix assert fail when jswrap_object_getOwnPropertyDescriptor called with non-string\n            Fix Array.indexOf when array contains non-basic values\n            valueOf returns a type error when called on undefined\n            Make sure analogRead doesn't overwrite pin state if it was set previously with pinMode\n            Make sure pinMode works with ADC input mode\n            Tweak event handling - events such as `Serial.on('data'` now set `this` to `Serial`\n            Add Function.bind (fix #318)\n            Fix SPI.setup memory leak (fix #496)\n            Fix assert fail on debug builds on Waveform output (fix #511)\n            Added more allowed types of whitespace\n            Added String.prototype.trim() (fix #507)\n            Allow argument lists in Function() (fix #505)\n            Propagate `this` into eval (fix #513)\n\n     1v75 : Fixed issue with Pins/Bools as Array indices\n            Fix crash when out of memory while creating built-in object\n            Fix continue statement in nested loops (fix #501)\n            On Linux, Exit nonzero when an error occurs (fix #499)\n            Ensure that pipes 'complete' if the source closes (was previously only the destination)\n            Make HTTP/Sockets throttle reads so internal buffers don't get full when piping\n            Added http statusCode, statusMessage, and httpVersion\n\n     1v74 : On Espruino Board, allow setTime to use full 64 bits so setTime(Date.parse(\"...\")/1000) works\n            Fixed issues with Waveform after 1v72 update to flat strings\n            Added 'global' built-in value\n            Fix inaccuracy of 'Date.now()' on STM32\n            Improve jsvIteratorGetIntegerValue speed for arrays (fix #493)\n            Change process.env.EXPORTS to something more useful for compiler\n            Fix issue with graphics fill on PCD8544 LCD\n            Add TypedArray.slice (from ES6) to help modules that use I2C\n\n     1v73 : Add Uint8ClampedArray, remove code duplication in ArrayBuffer (fix #486)\n            Fix regression where accessing certain member names of an undefined variable would cause a crash (fix #488)\n            Fix behaviour of char code 16 at beginning of the line (it now doesn't re-add the prompt after processing the line)\n            Added jspGetNamedVariable for use in compiled JS\n            Fix glitchy time values on the Espruino Board (fix #394)\n            Fix getTime()==0 in onInit, which could break timeouts in onInit after a reset (fix #462)\n            Refactor Software SPI code into jsspi.c\n            Allow filesystem to work on user-defined pins (fix #427)\n\n     1v72 : Stop RTC being reset by hard reset (getTime will now be time since power first applied) (fix #412)\n            Allow Function.apply to take typed arrays (fix #442)\n            Allow arrays to be passed to digitalPulse so square waves can be created easily\n            Force inlining of jsvLock/UnLock on most systems - improves performance a lot\n            Fix issues with SPI.write, CS, and out of sync receive bytes\n            Fix do..while without trailing semi-colon\n            Ensure that &,|,^,etc all have different precedences (without extra recursion)\n            Used new semi-recursive parse for expressions\n            Fix filled column when fillpoly is off the end of the screen\n            Fixed reporting of Serial RX pullup in `dump()`\n            Add input thread on Linux, and fix idle and Ctrl+C behaviour (fix #451)\n            Stop huge amounts of input events blocking Espruino's timers (fix #452)\n            Add ability to use serial ports on Linux with Serial1.setup({path:\"/dev/ttyUSB0\"})\n            Started ability to use SPI from Linux\n            Added 'net' library with support for sockets\n            Fix JSON parse of negative numbers (fix #456)\n            Only keep RTC settings if the relevant oscillator is running (fix #444)\n            Finally fixed sporadic compilation problems with '-Os'\n            Fixed issues with intervals in onInit (#462)\n            Remove libraries from root scope (fix #463)\n            Fix pin namings on Nucleo boards\n            Fix addition of stdlib's exit on Nucleo debug\n            Allow setWatch to execute native functions inside the IRQ\n            When dumping typed arrays, use the size if all elements are 0 (fix #448)\n            eval() can now access local variables and function arguments (fix #460)\n            Added 'flat strings' for typed arrays.\n              - these use a continuous chunk of memory so are much faster\n            Ensure that we only create as many Serial/I2C/etc items in Symbol table as we need (fix #453)\n            Allow modules to return whatever was assigned to exports - not just the original object\n            Allowed E.nativeCall (assembler/compiled functions) to execute directly from a flat string\n            Working F401 USB VCP bootloader\n            Make Press-poweron-release-press boot back into Espruino (this may confuse your OS)\n            Assert failures (in non-release builds) now reboot the system on ARM\n            Fix issues with freeing of variables not clearing the lock flags (fix #474)\n            Make Uint32Array actually return uints (even if they're so big they have to be represented as doubles)\n            Allow peek/poke to read and write arrays of values\n            Add Boolean constructor (fix #311)\n            Fix difference between String() and String(undefined) (fix #312)\n            Fix I2C/SPI on F401/F411-based boards (fix #470, fix #473)\n            Improved ArrayBuffer write performance\n            Massively improved ArrayBuffer Graphics fill performance for bpp<8\n            Fix issues with floating point on devices with <1024 vars (using 12 byte JsVar)\n            Add ability to change I2C bit rate from I2C.setup\n            Added VGA TV output\n            Added E.toString (for converting anything into a string)\n            Pulled Typed Array creation into its own function\n            Added E.toString and E.toUint8Array\n            Made I2C.readFrom return a Uint8Array (fix #479)\n            Allow multiple byte OneWire reads and writes\n            Fix setWatch on F3Discovery (fix #183)\n            Ensure that E.getSizeOf() works for ArrayBuffers (fix #484)\n            Don't allocate Flat Strings if we can get away with 2 normal string blocks\n              - it's actually faster to allocate and uses less memory\n\n     1v71 : Allowed WIZnet + CC3000 to be instantiated on any pins\n            Fix break inside loop inside case inside function (fix 428)\n            Added fs.stat and File.seek (fix #429, fix #430)\n            Allow use of DLE (char 16) on an empty line to turn echo off for *just that line*\n            Add XON/XOFF flow control on Serial + USB. This is enabled by default for Serial (fix #20)\n            Fix irregular timing on Espruino boards with clock crystal (inc rev 1v4)\n            Sort out 'Number()' constructor not being picky enough - parseFloat now parses 'Infinity' (Fix #325, mostly fix #322)\n            Stop iterator in FOR loop being called once more after a break\n            Fix bug allObjects found with iterating over undefined\n            Fix ArrayBuffer.sort issue with element size >1\n            Fix network de-initialisation on Linux\n            Fix reference count issue caused by removing a timer that had already been removed\n            Power up SYSCFG on F2/3/4 parts, allowing watch to work on ports other than A\n            Wait after setting the RTC time, to allow registers to update (fix #438, fix #441)\n            Now using gcc-arm-none-eabi-4_8-2014q3 for compilation - CodeSourcery stopped being supported\n\n     1v70 : Make pipe remove its drain/close listeners. Stops out of memory for repeated piping.\n            Fix parseInt for values too large to go in an int (#406)\n            Fix integer maths when result is too large for an integer\n            Fix mod operator with NaN/Infinity (fix #315)\n            Fix signed array values in PACKED_BIT devices\n            Drop JsVar size from 20 bytes to 16, increase Espruino variable count accordingly\n            Fix Array.fill on sparse arrays (fix #410)\n            Allow I2C repeated start (fixes some odd I2C devices, fix #390)\n            Refactoring to use iterators wherever possible\n            Merge fs_kill and file_kill to ensure that files always die before the filesystem\n            Add `E.unmountSD()` to allow SD cards to be removed once they have been used\n            Stop String.split(\"\") adding an empty elementy to the array\n            Tidy up linker script, allow F401 to use 3x16kB pages for storing program data\n            Fix regression in long timeouts (fix #416)\n            Use 'interval' var to specify if we're an interval or not (don't use 'recur' var)\n            Stop while/for/etc resetting exception state (fix #419)\n            Add  E.getSizeOf (fix #421)\n            Fix jsvCountJsVarsUsed for names with values\n            Make hidden names smaller to save a few JsVars\n            If there's only one function scope, don't define an array and save 2 JsVars\n            Fix setInterval on non-F1 boards (fix #415)\n            Fix issue where large doubles (> +/- 2^31) were converted to -1 rather than truncated ints\n            Fix E.getSizeOf (fix #424)\n            Fixed JSON indentation issue\n            Made 'pretty' JSON output look a bit better\n\n     1v69 : Fix 1v67's regression of digitalPulse when doing lots of pulses\n            Add configurable OneWire search command (for finding DS18B20s with alarm set)\n\n     1v68 : Fix memory leak in String.split\n            Fix references to `this` - you can now write `this[\"LED1\"]`\n            Fix memory leak when calling toString on a normal object\n            Fix memory leak in Graphics.createArrayBuffer\n            Fix memory leak when joining arrays containing null\n            Fix memory leak when syntax error while getting function arguments\n            Fix memory leak test when running on Linux\n            Fix memory leak in filesystem file open (when failure)\n            Fix memory leak on Syntax error\n            Stop multiple exceptions from being reported (eg. Syntax Errors)\n            Fix parsing of '!!' when not executing\n            Improve Error.toString, and fix bug when an exception was thrown from a function\n            Improve jsvObjectGetChild when out of memory\n            Switch native function decls from 32 bits to 16\n            Swap HY2.4 board to software LCD driver as well, work out pin mappings from PY file\n            Fix inaccuracy in setInterval, which had started since 32 bit switch in 1v65\n            Store JSWAT_EXECUTE_IMMEDIATELY in a way that will fit in 16 bit function decls\n            Allow bit-packing of refs for low memory boards (fix #145)\n            Now dump 'debounce' for setWatch\n            Make sure that dump() outputs correct JS for undefined variables\n            Allow pin counts per port of >31 on Linux-based systems\n            Fix issue with lost high-speed events when using setWatch with small debounce\n            Fix HTTP client regression\n            Fix Date constructor issue (uninitialised variable) (fix #408)\n            Fix invalid conversion of large ints to floats on ARM\n            Fix reset behaviour for non-standard default Serial ports\n\n     1v67 : Lower size of timer task array of devices with little RAM (fix #401)\n            Move hidden lists out of the root scope (fix #357)\n            Fixed exception catching\n            Fix Serial1 initialisation after 'reset()'\n            Fix parsing of try..catch when a serious error (not an exception) occurred\n            Stop the utility timer queue filling with WAKEUP tasks if Espruino gets woken up early\n            Add ability to specify default Serial TX and RX pins in BOARD.py\n            Reduce how many digits of floating point values are normally displayed\n            Fixed PWM output on B4 + B5\n            Fix regression when using pins as array indices\n            Remove negation for CHxN outputs - it seems they don't negate after all. Fixes PWM polarity on A7,B1,B13,B14,B15\n            Add pullup to USART RX. Reduces wakeups and random characters on Serial1.\n            Add error flags and E.getErrorFlags to report possible issues like buffer overflows and low memory (fix #136)\n            I2C timeouts now throw exceptions (fix #403)\n            Fix String.prototype.split with non-string args\n            Add fake digital pins D0..D7 under linux (helps with testing)\n            Rewrite ff_wtoupper and save 650 bytes \\o/ (fix #368)\n            Update Makefile to make it easier to cross-compile RPi->Espruino board\n            Fix HYSTM32_32 LCD at the expense of a bit of speed (fix #137, fix #327)\n\n     1v66 : Ensure that analogWrite(pin,1) works on negated outputs\n            Allow multiple Waveform playback on one pin (+ wave fixes)\n            Improve dump() for objects and Serial.on('data') (part of #397)\n            Fix Date.getSeconds,Milliseconds, and documentation on getMonth (#399)\n            Fix memory leak on Serial receive\n            Fix all Serial receive characters being 0 if no bytesize is specified\n\n     1v65 : SPI.send/I2C.write/Serial.write can now take variable number of arguments (fix #370)\n            Don't check for token matches where we already know what it should be (fix #280)\n            Improve file read speed for large reads\n            Waveform stability improvements\n            Fix Float32Array.set (and improve speed for non-float arrays)\n            OneWire library now uses hex strings for addresses rather than 64 bit ints\n            Fix issue with uninitialised function arguments (fix #391)\n            Fix parseURL for numeric keys in query string (fix #388)\n            When running JS files under Linux, do two parses to ensure that Functions are 'hoisted'\n            Add Object.create()\n            Add Function constructor\n            Add Object.getOwnPropertyDescriptor (although it won't return spec-compliant values)\n            Add some Stubs for inbuilt Date and Error classes\n            Added throw and try..catch..finally (see #40)\n            Fixed overriding of builtins with other Builtins\n            Added Date.valueOf\n            Stop warning about break at the end of 'default' in switch statement\n            Switch to 32 bit ints (fix #324)\n            Added Array.prototype.reverse, and also for ArrayBuffers (fix #389)\n            Swap JsVar fields around so everything is aligned on the correct boundaries\n            Merge jsvNewWithFlags and jsvNew - making variable allocation a bit faster\n            Fix changeInterval regression after int32 changes\n            Remove JSV_NAME flag - paving the way for more efficient variable storage\n            Store only 32 bit time for events (work out full 64 bits in event loop)\n            Increase event buffer size to 128 (from 64)\n            Enabled Graphics + CC3k support in the F3Discovery\n            Make `Serial.onData` call back with >1 char (#383)\n            Move `Serial.onData(...)` to `Serial.on('data',...)`\n            Add Serial.read/available/pipe (fix #383)\n            Add HTTP client/server read/available/pipe\n            Add documentation for events (and tidy it up for constructors)\n            Stop HTTP server closing before all data has been read\n            Fixed parsing of multiple shifts\n            setWatch now reports the pin back (fix #275)\n            Fixed memory leak in g.getPixel with arraybuffers\n            Fixed memory leak in \"\".indexOf(\".\")\n            Fixed ArrayBuffer Graphics where width*height*bpp&7!=0\n            Converted parse errors to throw exceptions\n            Added Date.parse and Date.toString\n            Fix parsing of integers that are too big to fit in an int32 (they're stored as doubles)\n            Fix Linux Espruino when no tty is present\n            Shave a few bytes off size of jsiDumpState using printf\n            url.parse now unescapes the query string (fix #227)\n\n     1v64 : Fix 'a=[2,3,4];delete a[1];'\n            Make sure parseInt(\"0x01\",16)==1 and parseInt(\"0x01\")==1 but parseInt(\"0b01\",16)==0\n            Fix equality check used in switch, so false !== 0\n            Improve Math.pow accuracy for small integer powers (fix #374)\n            Make Ctrl-C only interrupt code if it has been running for too long (fix Ctrl-C -> CC3000 restart issues)\n            Removed duplication in symbol lookup (fix #372, fix #323, fix #343)\n            Fix JSON.stringify with circular references (fix #378)\n            Fix String.indexOf when search string is bigger than the string being searched (fix #377)\n            Add String.prototype.slice() (fix #376)\n            Changed to more compact binary search symbol table (fix #278)\n            hasOwnProperty now doesn't check prototypes #24\n            Added Object.getOwnPropertyNames (fix #79, fix #158)\n            Move 'constructor' into the correct place, be more aware of builtins in prototypes (helps #380)\n            Handle __proto__ on builtin object types (eg. [].__proto__) (fix #381)\n            Remove indirection of __proto__ (fix #102)\n            Properly fix Object.getOwnPropertyNames (fix #380)\n            Remove jsvFindChild*Ref (fix #375)\n            Added LoopbackA/LoopbackB serial ports (fix #61)\n            Fix slowdown when lexing long strings\n            Remove Lock/UnLock in jslGetNextCh - should speed it up\n            fs.appendFile() now works even if the file doesn't exist (fix #385)\n            Support unicode escape sequence (\\uXXXX) but crop to 8 bits (fix #386)\n            Stop setInterval/etc increasing index numbers (fix #382)\n            Clear existing digitalWrites on reset() (fix #231)\n            Stop setWatch getting invalid data on load/save/reset (fix #254)\n\n     1v63 : Memory leak when defining functions (fix #359)\n            Fix Instance properties overwrite prototype (fix #360)\n            Fix `edit(functionName)` without quotes (fix #356)\n            Fix 'Uint32Array is not unsigned' (fix #330)\n            Ensure Object.keys([9,,undefined,9])==[0,2,3] (partial #349)\n            Store array length in the array root node rather than the last element (fix #351 #361)\n            Object.keys on array now returns strings (fix #348)\n            Remove jsvArrayGetLast (fix #363)\n            Fix issue parsing `function() { return }`\n            Stop jspNewObject creating a new object name if one already exists\n            startup_stm32f10x_hd.s now explicitly sets the stack pointer. Allows Espruino images to use more RAM\n            Add BusFault hander, to allow peek and poke to unmapped addresses without HardFaulting the ARM\n            Fix edit(...) so that functions themselves (not just the variable) are updated (fix #366)\n            Crop lines in errors when > 60 chars (fix #364)\n            Improve when stack traces happen for error reporting\n            Better error messages, and more efficient handler\n            Improving Util Timer rescheduling to try and avoid 64 bit divisions\n            Fix a lot of WIZnet W5500 issues (thanks @mgg1010!)\n            Add E.reverseByte\n            Add HIGH and LOW (fix #371)\n            Improve docs for SPI/I2C/Serial.setup\n            Force reconnect on CC3000 disconnect (fix #373)\n            Added cephdon's streaming file API (fix #12)\n            More WIZnet W5500 stability fixes - try and ensure that HTTP server never goes down\n            Fix HTTP client Host header when accessing ports!=80\n\n     1v62 : Added ArrayBufferView functions as per ES6 spec (fix #310)\n            Added Graphics.setRotation (fix #321)\n            Added Graphics.drawImage (fix #198)\n            Added E.toArrayBuffer for fast string->array conversion\n            Accessing an undefined array/object element now doesn't create it (fix #63)\n            Fix fs.unlink returns true if the file does not exist (fix #331)\n            Try and improve timer overlays by reordering the alternate function list\n            Ensure that PWM output doesn't enable negated/non-negated outputs when it doesn't have to\n            Improve console performance when sending long strings\n            Initialise Graphics flags Graphics.createCallback - could have caused all kinds of issues\n            Now make setInterval > 5s less accurate when setDeepSleep is on (saves ~0.5 sec of non-sleep time)\n            Fixed problem when accessing an array with a string in a variable\n            Fix issues with `\"0\" in {0:1}` (and hasOwnProperty)\n            Improved interpolate function, and moved it out of ArrayBufferView into E\n            Fix Problem with Object.keys on a string (fix #347)\n            Fix assert fail when deleting a property that doesn't exist (fix #344)\n            Ensure that dump remembers function names if they were in the root scope (fix #338)\n            Fix memory leak in fs.readdir\n            Ensure that abbreviations in console's '=...' output appear on newline if needed\n            Add String.replace (fix #334)\n            Make Graphics.drawImage draw bottom line of pixels (fix #329)\n            Add Array.shift/unshift (fix #342)\n            Fix Defining function after return causes error (fix #326)\n            Fix deleting the last element in array (fix #346)\n            More helpful I2C error messages (fix #10)\n            Fix overriding built-in functions (fix #202)\n            Add ES6 Array.prototype.fill (fix #317)\n            Modified jsiQueueObjectCallbacks (and Object.emit) to support >2 args\n            Added support for SPI LSB-first\n            WIZnet improvements (specifically on HTTP server)\n            Added WLAN.setIP for CC3000\n            Fix String.split issue with last element (fix #352)\n            Remove order warning for SPI if no order given (fix #353)\n            process.env will now contain the git commit\n            Move setInterval/Timeout implementations into jswrap_interactive (makes more sense)\n            Add setWatch warning if it's not possible (fix #337)\n\n     1v61 : Fix toString crash for large numbers\n            Support floating-point literals without a leading 0 - eg '.5' (fix #296)\n            Fix array access with booleans (fix #290)\n            Fix \"==\" issues where only one argument is an array (fix #283)\n            Make Array.join ignore null values (fix #289)\n            Callback graphics now works even without a fillRect implementation (fix #295)\n            ArrayBuffer Graphics now supports 2 and 4 bits as well as 1,8,16,24,32 (fix #301)\n            Allowed array.splice to as many arguments as needed\n            Make Array.sort() use string compare by default (fix #291, fix #292)\n            Allow [,] and [1,2,,4] - (fix #287)\n            Stop JSON.stringify using 'undefined' (fix #286)\n            function.call can now have more than 4 arguments\n            Rewrite native function caller (fix #277)\n            Fix conversion of floats to booleans (fix #307)\n            Fix parseInt of NaN/Infinity (fix #309)\n            Add extra escape codes in strings (fix #304)\n            Ensure String.charAt returns empty string for out of range (fix #305)\n            Make REPL faster when receiving large amounts of data (fix #303)\n            Improved jspeFunctionCall speed, added Named functions (fix #77)\n            Allow Array.map.forEach to be applied to Strings and ArrayBuffers (for #310)\n            Tweaks to make more Array functions work on non-arrays\n            Added Array.reduce\n            Allow commas in expressions at end of for loop - `for (;;i++,j++)`\n            Fix SPI send with a single number\n\n     1v60 : Fix unary plug on variable not working (fix #268)\n            Added DNS with eth.setIP() for W5500\n            Fix lock 'leak' when creating Graphics with callbacks\n            Small fixes for trigger/timer\n            Make dump() + console aware of built-in SPI/I2C/etc\n            Add Pin constructor for converting numbers into a pin object\n            Added getPinMode\n            Fixed I2C saving state (fix #270)\n            Add JTAG to ignore list for some boards\n            Fix LCD FSMC formatting and report if LCD is unknown\n            You can now reference built-in functions. eg. [1,2,3].map(Math.sqrt)\n            Add Object.valueOf - help with #187\n            Add Object.hasOwnProperty (although it does have some false positives) - #24\n            Add software SPI - fix #41\n            Fix issue when constructing an ArrayBuffer with a floating point length\n            Fix Math.round regression and add checks to ensure it can't happen again\n            Fix DEVICE_IS_XXX defines (fix SW SPI regression)\n            Fix hardware SPI regression (getting out of sync after ArrayBuffer write)\n            Removed non-standard Integer.valueOf - use \"A\".charCodeAt(0)\n            Fix non-standard ArrayBuffer behaviour when constructing an ArrayBuffer from an ArrayBufferView\n            Fix `1 in [2,3,4]` behaviour - it searches keys, not values\n            Make parseInt(..., >36) return NaN\n            Make Number.toString() use lowercase chars for hex\n            Fix issues with NaN, negative zero, and Math.round\n            Fix equality checks with null\n            Fix comparison of integers with empty string/whitespace+number\n            Added nativeCall, which allows C/Assembler to be called from JavaScript\n            Fix custom font memory leak\n\n     1v59 : (function(){})?1:0 should == 1 (fix #261)\n            Fix Math.pow (Fix #260)\n            Fix String.split() (Fix #259)\n            Added Array.concat (Fix #262)\n            Increase RTC/getTime reliability by ensuring overflow can't happen\n            Added Math.min/max\n            Allow jswrapper to wrap objects with a name >8 characters long (fix #264)\n            dump() now doesn't print 'var X = undefined;' - just 'var X;'\n\n     1v58 : Fix Serial.parity\n            Fix glitches in jshGetSystemTime\n            Added Graphics.setFontCustom for custom fonts\n            Added String.lastIndexOf, and made String.indexOf with fromIndex work\n            Used non-bold vector font, improve alignment, and make curves lower quality\n            I2C can now write any size (as long as it fits on the stack!)\n            Try and enlarge fillRects caused by polygons\n            Fix === issues, fix #257\n            Add Graphics.getColor/getBgColor for Juergen\n            Added E.convolve for doing fast calculations with Waveforms\n            Allow String.fromCharCode with multiple arguments\n            Add builtin_modules to board's JSON\n            Added E.FFT for Fast Fourier Transforms\n            Added 16 bit read/write to Waveform (and speed up utility timer)\n            Fix utility timer - now interrupts just in time\n\n     1v57 : Tweak IRQ priorities to try and make SPI RX more reliable\n            Make http default to port 80 if no port is specified in options\n            Try and stop issue with System Time suddenly jumping forwards\n            Fix assert fail when clearing and adding timeouts from within a timeout\n            Fix modulo (actually remainder) operator for floating point values :/\n\n     1v56 : Added atob and btoa (for base64 encode/decode) - fix #244\n            Added Array.sort() - fix #220\n            fs.writeFile/appendFile now return false if they fail for some reason\n            Move Graphics init and idle functions out of jsinterface.c\n            Add HttpServer.close\n            Ensure that Linux command-line tests keep running if there's something to do\n            Epic networking refactor - it should now be possible to support multiple network devices in a single binary\n            Now only remove the interval/timeout/watch that's causing the error - not every one\n            Change names of functions in callback-based Graphics so they don't conflict with the real ones\n            More CC300 reliability - now range check the return value from send+recv, because if there's a timeout it can be wrong\n            Fix memory leak in setWatch with debounce\n            Fix 'repeat:false' in debounced setWatch\n            Make sure 'repeat:false' disables the hardware watch\n            Initialise RTC roughly 1 sec after reset, and use external 32kHz oscillator if it exists\n            Added E.enableWatchdog (fix #252)\n            Fix negative start value for String.substr()\n            Fix problem where the RTC's full 32 bits weren't combined properly\n\n     1v55 : Add String.toUpperCase/LowerCase\n            Fix E.getAnalogVRef() regression\n            Add Math.tan()\n            Ensure Double/Integer have Number as a prototype (fixes: Number.prototype.n=function();(5.0).n() )\n            ||/&& now doesn't use booleans (fix #251)\n            More resilient parseInt behaviour\n            Allow data listener for HTTP POST (fix #226)\n            Stop JSON.parse using eval (fix #249, fix #208)\n            `.toString` is now called when a String is needed from an Object (fix #57)\n            Fixed reference count error when looking for functions in an Object's prototype\n            Fix issues with Numbers as Strings in maths (eg. '-5'|0)\n            Make sure NaN|0 == 0 (and not some huge number)\n            Ensure that [1.23]*1.0 == 1.23 (fix #91)\n            Don't pull in cos (use sin(x+PI/2))\n            Try and save flash memory on Olimexino board\n\n     1v54 : Add 4x6 font (instead of 8x8)\n            Fix occasional instability with Waveform read/write\n            Refactor JSON to improve speed and code size (using cbprintf)\n            Now print special 'short' JSON for console.log (and the REPL) (fix #47)\n            JSON.stringify now doesn't print functions (fix #207)\n            Refectoring jsparse.c to name functions after their JS Grammar names\n            IF statement now accepts commas\n            Ensure that undefined+0 == NaN (only worked for floats previously)\n            Fix assert fail (issue unlocking when executing built-in functions)\n            Fix setInterval regression in dump (and tidy up code)\n            FS lib now resets when issuing the reset() command (fix #200)\n\n     1v53 : Attempt to deal with the case where CC3000 crashes on initialization\n            Fix regression with setInterval/timeout and saving\n            Fix issue with saving Serial baud rates\n            Added ArrayBuffer.set\n            Use jswrapper.c for executing idle/init/kill events for libraries (cleans up jsinteractive.c)\n            Added beta 'Waveform' API to allow simple audio output\n            Improved non-deep-sleep power draw by allowing Espruino to wake itself on the Utility timer (rather than SysTick)\n            Allowed Waveform API to output on both DAC and PWM\n            Improve auto-generated documentation\n            Speed up ArrayBuffer.set and allow Strings to be used properly\n            Fix jsvArrayJoin if memory runs out\n            Added E.sum and E.variance array operations\n            Added Waveform Analog Input\n\n     1v52 : Fix memory leak in Array.slice\n            Fix broken Serial initialisation (partial fix for #241)\n            Add fs.unlink (for deleting files)\n            Fix url parsing when there are two slashes\n            Fix recent changeInterval regression\n            Making CC3000 recover properly in the case of repeated HTTP GET\n            Add alternate function remapping for Serial and improve Serial.setup error reporting, fix #241\n            Added preliminary WIZnet W5500 support (see http://www.espruino.com/WIZnet)\n            Alt Enter (27 + 10) now always inserts a newline: (eg. for `if (X) \\n Y`)\n            Fix digitalPulse with not a number\n            Make digitalPulse(... 0) wait until the last pulse is complete\n            Stop Espruino sending out so many carriage return characters (fix #243)\n            Added 'delete' keyword (fix #39)\n\n     1v51 : Added debounce to setWatch (fix #14)\n            Tidy up timeout/watch code and now store an integer for interval\n            Fix crash in url.parse (string free)\n            Fix Modules.addCached bug which means that Modules.removeAllModules created a memory leak\n            Fix regression introducted by fix for #199\n            Added 'Esc,[,2,K' escape sequence for clearing lines. Much safer than Ctrl+C which tends to break out of execution.\n            Fix bootloader (broken by LTO in 1v49)\n            Added Number.toFixed\n            Make number.toString(base) work for floating point (fix #232)\n            Fix Linux jshSleep so that timeouts are handled at <10ms if required (fixes test056)\n            Now use jshardware's SPI for SD filesystems - more multiplatform\n            Now ref thisVar, which stops it being repurposed into a Name for array accesses (fix #233)\n            Fix Linux halting when there is one long timeout but no other activity\n            fs.readFile returns 'undefined' if file is not found. Also make readdir return undefined on failure (fix #229)\n            Remove disk_timerproc in SD card implementation\n            Upgrade fatfs to R0.10a\n            Tweak jsinteractive.c to help reduce code size\n            Finally added Long filename support for FatFS (fix #78)\n            Epic refactor to remove JsParse (fix #17)\n            Implement faster Graphics ArrayBuffer fill (affects vector fonts + clear)\n            Stop repeated analogWrite with messing up PWM waveform (fix #56)\n            Swap open and close brackets in bitmap font (fix #191)\n            Graphics arraybuffer/callback now accepts 16bpp\n            Added ability to specify a JS function for Graphics fillRect\n            Graphics setPixel(x,y,undefined) to use foreground colour (fix #215)\n            Make sure that interruptions are handled better while drawing to graphics\n            Make sure that stack overflow errors are handled more tidily (and increase limit for warning)\n            Increase available stack on Espruino Board\n            Stop FatFS using insane amounts of RAM\n            High res timer (now to 1/2^23) using SysTick with RTC as a base (fix #168)\n            Added 'Infinity' constant\n            Fixed type equality check between int and float (should treat them as the same)\n            Fix parsing of '018' - it's not Octal after all (but 017 is)\n            More accurate values for PI and E\n            Fix charCodeAt being signed (should be unsigned)\n            When casting Strings to booleans, so s.length!=0\n            Guess initial values for average SysTick time - means that getTime is more accurate for the first 1-2 seconds after startup\n            setWatch now reports lastTime - time of last state change #238\n            analogWrite now respects pinMode (fix #234)\n            Add Open Drain support to pinMode (fix #225)\n            Fix calling Number([value]) always returns undefined (fix #186)\n            When disconnected from the net, make sure we free all HTTP clients/servers\n            Completely remove IRQs from CC3k code\n            Speed up CC3k code, try and make it automatically power cycle it on timeouts\n            Fix SPI MISO on F4 board\n            Move CC3000 to SPI3 (same pins) so SPI1 can be used for other things\n            Compile CC3000 support in for the F4 (untested)\n            Process.env now reports board serial # and current console device (se we can throttle for Bluetooth) (fix #219)\n            General bugfixing for low memory situations\n            Make string free non-recursive\n            Fix issue where fs.readFile of a big file would cause Espruino to crash\n            Fix memory test harness\n\n     1v50 : Fix broken Web IDE caused by change to printing JSON for console.log (part of #206)\n            Fix bug when trying to stringify {5:5}\n            Allow {1:2} to be parsed (fix #199)\n            Added SPI RX IRQ. Caved in and used a few bytes for buffers, made SPI significantly more reliable\n\n     1v49 : Change compiler flags to allow link-time optimisation\n            Increase buffer sizes on Linux\n            Increase buffer sizes on boards with >= 20kB RAM\n            Made Startup banner smaller\n            Less printing when loading from flash\n            Don't display startup banner if loading from flash (an easy way to fix #213)\n            Fix HTTP response code of 0 (fix #212)\n            Add timeouts to TI's CC3000 driver\n            Add timeouts for SPI, and other timeouts now interrupt execution\n            Lower USB interrupt priority, remove pesky PriorityGroupConfig that was breaking other IRQ priorities\n            Until we sort out SPI RX and IRQs, lower default SPI baud rate to stop timeouts\n            console.log and print output JSON now (part of #206)\n            Added handling of query in url.parse - still not fully compatible though (fix #205)\n\n     1v48 : Fix issue where the size of command history is being reported wrong and so process.memory().free is reported wrong too\n            We now loop without a seek to position inside the string (much faster if loop is not near the start of a fn) (fix #53)\n            Faster string iteration which doesn't involve incrementing it->index\n            Swapped to jumptable to lexer (should be a bit faster)\n            Added the 'E' class, with getAnalogVRef and getTemperature (fix #60)\n            Deprecated Math.clip (not in spec) and introduced E.clip\n            Fixed bug in common.py that meant that ifndefs in JSON were sometimes not obeyed (better mem usage on small chips)\n            Fix deep sleep breaking ADCs\n\n     1v47 : Fix issue with dump() and input_pullup not being quoted\n            Fix regression that broke OneWire in Espruino Board (#197)\n            Fix clock speed issue on SPI1 (https://github.com/espruino/EspruinoDocs/issues/18)\n            Don't interrupt on USB ESOF or ERR  - allows 'normal' sleep without interrupting every 1ms (fix #195)\n            Remove pointless KickStarter line printed on startup\n            Added bootloader hack to Python bootloader\n\n     1v46 : Fix parseFloat(\"\") not returning NaN, and parseFloat(\" \\t 5 \u00a3$%^&(*$\") returning NaN\n            Added isNaN() function (fix #184)\n            Fix parse order for 'typeof' (fix #172)\n            Added Number object (fix #165)\n            Bounded ftoa (stops crash when printing Number.MAX_VALUE) - helps with #185\n            Added Array.isArray() (fix #160)\n            Add do...while (fix #151)\n            Stop Espruino board from crashing if you try to create a web server without a connected CC3k (fix #182)\n            Remove Array.contains as it's not in the spec (use indexOf instead if you need it) (fix #161)\n            Fix nasty bug where adding/removing intervals/timeouts while in one could cause issues\n            Fix bug when printing 1.999999999 and similar (fix #190)\n            Remove need for pow for exponentiation. Not great but it fixes some tests that failed on FP inaccuracies\n            Change polarity of setSleepIndicator (fix #194)\n            Allow array.push with multiple arguments (fix #189)\n            Speed up array access by searching from the end backwards if we think the number is in the last half (fix #46)\n\n     1v45 : Fix parseFloat(\"foo\") not returning NaN (and assert) - fix #149\n            Remove Integer.parseInt\n            Fix parseInt(\"bar\") - fix #150\n            Ensure that maths ops with null do treat it as 0 rather than a string - fix #156\n            Fix digitalPulse length (properly!) - fix #154\n            Making sure that undefined gets cast to NaN\n            Fix Array.indexOf() returns undefined instead of -1 - fix #155\n            Moved memory() to process.memory() - added more info too\n            Try and improve handling of PWM timer speeds\n            Fixed varying SPI baud rates depending on device\n            Makefile changes for OSX compile\n\n     1v44 : Modified build system to store binary names in the python definition\n            Fix nasty regression involving losing code at the end of Strings\n            Fix segfault when pinMode is called on an invalid pin\n            Now disable interrupts during 4 bit SPI send - it's just too much otherwise\n            Detect unfinished block comments in console (fix #138)\n            Fix flash write on most 10XxB boards\n            Fix PWM output on all STM32 boards\n            General hardware tidy in prep for more intelligent device management\n            Run initialisation code before setWatch, to make sure pullup/down is set beforehand\n            Change 'Pin' datatype to be an unsigned char - makes tests easier\n            Now use the hardware RTC for keeping system time. Allows proper deep sleep on Espruino board\n            FINALLY - fix the USB VCP lost characters issue (#94)\n\n     1v43 : Added 'Modules' object with support for adding/removing cached modules\n            Allow product ID to be changed via Makefile\n            Fix documentation (and old-fashined Parsing style) for JSON\n            build_jswrapper now outputs errors to stderr (more compatible with default (silent) build process)\n            Fix issue when parsing quotes in strings\n            Added void operator for closure minification compatibility\n            Ensure that return takes the comma operator\n            Fix issue where printing Infinity would crash Espruino (fix #129)\n            Finally some working (extremely beta) cc3000 code\n            Added jsvObjectGet/SetChild to simplify some wrappers\n            'http' now uses JsVars for storage (so is suitable for non-linux devices)\n            Turned 'http' into a library\n            Added process.version and process.env (fix #131)\n            Changed handling of 2nd arg of << so that precedence is correct\n            Fixed handling of 'for (;;)'\n            Fix lock leak in Module handling\n            Update ST's library for the STM32F1\n            Update ST's VCP implementation\n            Added prefix operator (fix #130)\n            Allow espruino for linux to be run with '#!' in scripts\n            Fix indexOf on final element of strings (fix #133)\n            Remove JSV_PARENTINFO, as it turns out JS doesn't keep track of function scopes anyway (fix #109)\n            Make 'this' a keyword (now faster, more memory efficient)\n            Make 'Hardware' (root) the default value of 'this'\n            Add jsvArrayPushAndUnLock and modified code to use it (fix #135)\n            Now remember I2C state (partial fix for #13)\n            Replace 'pow' function with a smaller version - save ~2kb\n            Shaved another 1200 bytes off jslTokenAsString\n            Now store Pin state (fix for #13 on F1 parts, F4 still looks broken)\n            Added Graphics.stringWidth\n            Added internal Printf function\n\t           Misc speed and code size improvements\n            This version has gone to Seeed for use on the KickStarter boards\n\n     1v42 : [ebirger] allowing 'new' with no brackets\n            Allow built-in functions with variable numbers of arguments (fix #83)\n            Implement 'String' constructor in the normal way (fix #110)\n            Fix regression with parsing constructors while not executing\n            Allow multiple arguments to print and console.log (fix #92)\n            Make 'arguments' array available in functions (fix #100)\n            Fix an assert fail, and handle some potential memory leaks\n            Don't show __proto__ and constructor with for..in, keys(), or JSON.stringify\n            Make 'trace()' output more readable debug data for complex structures\n            Fix memory leak whe parsing functions iwht variable numbers of arguments - fix #115\n            Defined NaN\n            Stop 'new undefined()' crashing Espruino - fix #120\n            Get A13/A14 working on Espruino board (these were JTAG)\n            Get bootloader size direct from Python (remove hard-coding)\n\t           Fix '~' operator when acting on variables\n            Made bootloader a bit more error tolerate (CRC on write)\n            Added %=, /=, and *= operators (fix #121)\n            Allowed Object.toString() to take a radix argument for integers (fix #125)\n            Fix error message issue - broken strncat (fix #124)\n            Add comma operator (fix #122)\n            Added some basic code for STM32F429IDISCOVERY - not currently working though\n            This version is the one sent off on the Test Harness (so will probably appear on boards)\n\n     1v41 : Fix Olimexino compile (https://github.com/espruino/Espruino/issues/6)\n            [ebirger] Member constructors (eg. new a.b() )\n            [ebirger] Ensuring integers with radix specifiers can still be parsed if a radix is specified\n            Fix for tests/test_json_arraybuffer_001.js - iteration of arraybuffers of length==1\n            Add Object.keys(...)\n            More arraybuffer iteration fixes\n            On linux, use built-in stringToFloat to aid debugging. Handle exponentials, fix #31\n            'make serialflash' is now works correctly for Espruino Boards with bootloader\n            setWatch(..A0);setWatch(..A0);clearWatch(1) does not now kill the other watch, fix #25\n            One-based setTimeout/setWatch, fix #3\n            Added Function.call and Function.apply, fix #54\n            'http' and 'fs' are now libraries that need to be 'require'd, fix #8\n            Updated pin info for STM32F103xC/D/E chips, fix #84\n            Fixed linker script for STM32F4 (discovery board now works)\n            Object prototypes are now Objects, fix #101\n            Board docs now specify '3.3v' only pins fix #104\n            Add Array.forEach\n            Fix searching down >1 prototype to find functions (one more issue posted in #99)\n            Fix \"12345\"/5 type issues (fix #90)\n            'Consting' some string functions\n            Fixing arrays with string indices that are actually numbers \\o/ (fix #19)\n            Released onto website\n\n     1v40 : Ensure that LCD.prototype.setPixel = function actually works\n            Refactor LCD driver code to allow lcdInit (and start of making it non-platform-specific)\n            Built 'LCD' support into linux/raspi/carambola\n            Add initial SPI.send(ArrayBuffer) support - even if NO VALUES RETURNED\n            Start of built-in Nokia 5110 LCD support\n            Remove GPIO clock removal on sleep for now (it kills setWatch)\n            Fix (sub)ArrayBuffer problems (test100.js)\n            Added setDeepSleep - still beta put power consumption drops to 1mA\n            Fix broken name for httpCRq.write\n            Changed LCD to Graphics - added ability to render to ArrayBuffer\n            Fix 8 char built-in class names\n            Adding preliminary Sony SmartWatch support\n            Adding preliminary support for completely bare 36 pin chip\n            Fixing pin defs for Espruino board rev 1v1\n            Added proper SDL/ArrayBuffer and JS Callback graphics support\n            Added \"ifdef\" ability in build_jswrapper\n            Take JSVAR_CACHE_SIZE out of jsutils and put it in the board config file\n            Added JSV_PARENTINFO which will allow us to do things like setTimeout(foo.bar,10)\n            Fixed arrays in non-executes streams - 'if (0) print([1,2,3]);'\n            Added 'require' function loading modules from node_modules on SD card\n            Added module cache to stop modules being re-loaded\n            Renamed internal vars to start with '>' - much easier to distinguish for 'dump'/etc\n            Only use parentInfo on functions\n            Load all tests in test dir - don't do them by number\n            Added 'zigzag' ordering for ArrayBuffer Graphics\n            Added 'vertical_byte' ordering for ArrayBuffer Graphics\n            toJSON now ignores 'hidden' object elements\n            Special-case jsvArrayBufferIteratorSetIntegerValue\n            Make SPI output an ArrayBuffer\n            Use best out of 3 for DelayMicroseconds calibration - something seems flaky right after bootup\n\t           Lines now drawn from p1 to p2 inclusive\n\t           Events now use jshPushIOWatchEvent (should cut down on code) also fixed bug with watching pin #11\n\t           Now remember if pinMode was set or not\n       \t    Transform ```code``` in JSON into a code tag in the documentation\n            Graphics now supports FSMC for HY boards again\n            Drawing vector fonts is now roughly the right size and position (still not 100%)\n            Remove registration code\n            Adding MPL licence\n            Remove Arduino bit manipulation functions - nobody seems to use them anyway\n            # of flash pages/etc now comes from board info\n            [ebirger] Supply the correct arguments to Array.map\n            [ebirger] Method calls and membership evaluation should be done on all factors (ee. [1,2,3].foo())\n            [ebirger] When running multiple tests, only set up terminal once or it breaks the terminal window on exit\n            Added STM32-style USB CDC bootloader for Espruino Boards\n            Added scripts/create_espruino_image.sh to package up bootloader and espruino into one binary\n            SHIPPED on Impatient developer boards\n\n     1v39 : Added Bitwise NOT operator\n            Added Raspberry Pi version to ZIP (with HTTP support)\n            Fixed load/save on Linux Devices\n            Added pinMode function (to allow pull-ups/pull-downs to be turned on)\n            SPI.send4bit/send8bit will now not mess up the final element\n            changeInterval now clears up stored up callbacks (eg, setInterval(.., 0.01)...wait...changeInterval(...,20)\n            Ctrl-C no longer prints anything, which avoids lockups\n            No longer print \"Execution Interrupted\" if nothing was interrupted!\n            Added >>>= >>= and <<=\n            When entering text interactively, ensure that there are no trailing spaces\n\n     1v38 : Tweaks for Arduino IDE compile\n            Removed '(char #)' from stack trace, as a bit pointless now\n            Added better reporting of execution location when Ctrl-C pressed\n            Urgent fix for non-working Olimexino since 1v33\n            Fix string comparison when strings contain \"\\0\"\n            Added LED1/2/OSC/SD/etc to Olimexino Board docs\n\n     1v37 : Urgent fix - power saving code made it difficult to re-flash Espruino (now only apply this to Espruino Board)\n\n     1v36 : Fix documentation for Array.pop()\n            Added some much better board documentation\n            Fixed DAC output on F3\n            Fixed DAC output on devices where PWM is also available and the alternate function is less than the DAC's\n\n     1v35 : Attempt to reduce power consumption when sleeping by turning off GPIO, and setting GPIOs to AIN on reset\n            Fix F3 issue where ADC/DAC weren't picked up properly\n            Tidy up register text and add KickStarter mention\n            var a = {}; a[LED1]=0; - not converted to String\n            JSON (and hence dump()) now dumps ArrayBuffer correctly\n\n     1v34 : Faster jshFromDeviceString\n            Preliminary support for flow control on Serial receive\n            Speed improvements by removing jsvGetRef from jsvUnLock\n            fast 4 byte pre-check in jsvFindChildFromString\n            Skip lock/unlock in FindChildFromString to help increase speed\n            When we unplug USB, only go to the default console device IF that is the device we're currently on\n            Support for custom Espruino board\n            Added ArrayBufferView.interpolate\n            16 bit SPI send for send4bit/sevrnd8bit (better reliability on low-end chips)\n            Fix JSON dump of typed array\n            Added Math.clip(x, min, max)\n            When saving on flash, don't do jslTokenAsString properly\n            B3/B4 move from alternate fn\n            Fix incorrect reporting of analog pins\n            Fix I2C.readFrom on STM32F1/4\n            Make 1/2 == 0.5 (was being sensible before, but now follow JS spec)\n            Ctrl-C while in timer fn clears timers (but not outside it)\n            Fixed broken clearInterval from within setInterval\n            Hopefully fixed issue on SSD1289 LCD controller\n            Trigger wheel handler to use interrupts\n            2D arraybuffer interpolation\n            Added Math.wrap, fixed a lot of trigger issues\n            Fixed SysTick priority/preempt problems\n            Slowed the SysTick timer back down for everything\n            Fix Int8Array signedness on F4 boards\n            Refactored source code tree\n\n     1v33 : fix character encoding issue of \"\\16\"+\"1\" != \"\\161\"\n            Refactoring of ArrayBuffer into iterator, and addition of a general purpose iterator\n            Fancier assert for debugging\n            jsvArrayJoin to use new iterator\n            for (i in ...) to use new iterator\n            I2C and SPI use new iterator\n            Serial.write() - to allow single ints to easily be written\n            changeInterval assert fail when given a function by accident\n            added peek8/poke8/peek16/poke16\n            memory() now takes account of command history size\n            memory() on ARM reports the end address of the stack - so it can be used as a scratchpad with peek and poke\n            Try and reduce code size by not inlining several functions\n            No refs for StringExts - so we get one more byte per JsVar (~5%) more storage efficiency\n            Move from jsvIsBuiltInFunction to computer-generated jswIsBuiltInFunction\n            When creating Objects, check for built-in function BEFORE creating an Object class for it\n            Built process now checks that flash usage is under the allowed value\n            Added short compare to jswHandleFunctionCall to reduce code size\n            Added 3 byte compare (4 byte read and AND off top byte) - faster, less code\n            Auto-generate jsvGetBasicObjectName from docs\n            No longer using refs for storing whether free or not - use flags with JSV_UNUSED and get one extra var with 8 bit refs\n            Switch to using STRING_0...STRING_MAX in flags, rather than specific bits in JsVarFlags - allows more that 15 chars to be used per JsVar\n            Make ArrayBuffers actually be ArrayBufferViews - saves on extra string-handling code at expense of one var\n            Make sure Uint8Array,etc inherits from ArrayBufferView\n            Fix issue where a '\\0' coming in from serial was not put in e.data properly\n            Don't inline some functions when we're trying to save on flash\n            Re-use sin for cos, pow for sqrt to reduce code size\n\n     1v32 : Fixed embarassing issue with 0.999==\"0.A\"\n            Added and checked Pin.writeAtTime on STM32\n            Now don't allocate events array - just allocate directly, which saves memory and is faster (although slighty out of order)\n            Docs: now Alphabetically sorted, and class instances not listed by accident\n            Fix issue where Ctrl-C on ANY Serial port caused execution to be interrupted\n            Updated busy indicator to cope with recent change to not allocate events in an array\n            Fixed I2C on HY 2.4 board - I2C needed hard reset\n            Added basic ArrayBuffers/TypedArray support\n            Fix memory leak when error created with [] on a non-array/object\n            Improved hyperlinking in documentation\n            Fix I2C receive bug on F4\n            Increased VL board's input buffer size\n\n     1v31 : Fix PWM output on TIMER1/8 pins of the STM32F4\n            Fix PWM output for negated timers\n            memory() now runs a GC pass\n            Fixed multiple occurrence of functions in reference\n\n     1v30 : STM32F1: fixed AF issue meant peripherals would never return from AF mode\n            STM32F1: When given an invalid pin, now reports if pins are 'af' or not\n            Updated SPI.setup docs to mention that you can't mix AF and non-AF\n            If one SPI pin is specified but others aren't, only that pin will be set up\n            Added Olimexino hack so SPI1.setup works as expected\n            Allow using [] on a function\n            Fix precedence issue, so var a = function() { return 1; }(); works\n            Update SPI documentation\n            for (i in f) can now iterate over functions\n            Optional argument to trace() for object to start tracing from\n            Small steps towards ArrayBuffers\n            Added smart edit that checks for internal functions, and uses Function.replaceWith\n            Added Function.replaceWith to replace the internals of a function while keeping the scope\n\n     1v29 : Some hacky sysfs-based IO for running on Linux\n            HTTP Callbacks are now stored as names so they can be changed on the fly (Linux only)\n            Successful compile for Carambola\n            Filesystem support on Linux\n            Switch to variable size ref counter (marginally more efficient on very small devices, safe on Linux)\n            Linux now has unlimited memory available\n            Added linux/sysfs 'setWatch' (non-irq driven, so very noddy)\n            Checked jswrapper check from using multi-char constants to a #define\n            Improve pin suggestions for SPI/I2C/USART\n            Auto-initialise USART with default values when setConsole is used\n            Support for new Graphics LCD types\n            3.2\" VCT6 board support\n\n     1v28 : Faster LCD fillrect for HY 2.8\n            Fix for multi-byte SPI writes on HY board at 1Mhz (touchscreen control bug)\n            Fix issue with delayMicrosecond calibration on HY (and hence OneWire)\n            Fixed digitalPulse on STM32VLDISCOVERY\n\n     1v27 : Fixed problem with OneWire constructor execution\n            Added |=, &= and ^=\n            Added Array.splice()\n            Faster, more ROM-efficient built-in symbol table\n            Fix for potential issue when using field accessor on an undefined var\n\n     1v26 : I2C Support on STM32F1 and STM32F4 boards too\n            Emergency cut in variables for Olimexino with bootloader (as flash usage has got too high for save to flash!)\n\n     1v25 : http.writeHead to accept an empty header\n            Fixed issue finding methods on built in classes (0 termination)\n            make sure http server with no data still sends headers...\n            Start of MINI-HY-2.8\" support (all ok, but no SD card yet)\n            Reduce RAM usage by consting some arrays that are not modified\n            Vector fonts now use polys - 8kb less ROM, and faster rendering\n            Start of LCD 'driver' code\n            Standard way of handling events, Object.on/emit/removeAllListeners - like Node.js's EventEmitter\n            Self-calibrating Microsecond delay (for intermal OneWire/etc)\n            OneWire class\n            Correct handling of built-in class constructors\n            Fix error when parsing a zero-argument function that has been given arguments\n            I2C support - currently ONLY tested on STM32F3 board\n\n     1v24 : SDIO-based fat driver on the HY STM32 board\n            Added DAC to the HY boards (103xE-based)\n            Re-named the fileSystem functions to make them more compatible with node.js (readFile/writeFile/etc)\n            Added fs.appendFile\n            Removed HTTP from the reference until it is included in some boards\n\n     1v23 : Fix 'ERROR: INTERNAL: stmADCChannel' on STM32VLDISCOVERY/F1 boards when accessing PA0\n            Reference now mentions which Espruino version it is for\n\n     1v22 : Important fix - Events got executed in the wrong order if they got queued up\n\n     1v21 : Ensure SPI clock does not stop between bytes\n            Added SPI.send4bit and SPI.send8bit\n            Made sure the VL board's code fits into available flash\n            Smart += that can append to a string rather than cloning it\n            dump() prints functions properly, rather than 'var f = function() {}'\n            Pageup/down move the cursor to the beginning/end of input\n            LCD draw/fill with negative x and y\n\n     1v20 : Add console.log\n            Fix automatic usleep for Linux\n            Added node.js-style HTTP server for Linux version\n            Fixed null-pointer issue when accessing something that doesn't exist on an object\n            Added node.js-style HTTP client for Linux version\n            Start of bit bashing functionality\n            for (i in \"ABCD\") console.log(i) -> 0,1,2,3\n            String array access (but not for writing - doesn't work in JS anyway)\n            String String.fromCharCode / charCodeAt\n            Added SPI baud rate setting\n            Vector font chars 'a' and '4' now work ok\n            Fix numeric exception when rendering a poly that has some identical points\n            Better digitalPulse (uses timer + interrupts)\n            analogWrite can now take an object with a 'frequency' argument for PWM\n\n     1v19 : Fixed issue where var M=Math;M.random() failed\n            Fixed issue with var U=USB;U.print(\"Hello\");\n            Remove loop iteration limit\n            Fix memory leak when a syntax error is in for '(i in arr)'\n            Save state of pin on setWatch interrupt (e.state)\n            Change setWatch to allow only on rise or fall as an option\n            clearWatch() clears all watches\n\n     1v18 : DAC support on F3/F4\n            Serial.setup() can also take a second parameter of an object {tx,rx}\n            Better support for dump() with echo/setBusyIndicator/etc\n            Better dumping of prototypes on built-in vars\n            Don't add chars<32 (Except tab) to the input line\n            SPI1/2/3/4.setup() to take an object {baud,sck,miso,mosi}\n            Better hardware initialisation code (not UARTS auto-init if they are used)\n            Fix issues with prototypes\n            Peek/poke instructions\n            Start of I2C support (not usable yet)\n            Added Math. ceil/floor/exp/log\n\n     1v17 : Support for running alongside the Maple bootloader\n            Fix parsing of numbers beginning with 0 when forceRadix!=8\n            Fixed USART1 on Maple/Olimexino devices\n\n     1v16 : Inlining of jsvLock/UnLock in jsvar.h to improve speed\n            Move non-hardware-dependent stuff into jsdevices\n            Move jshardware.c into targets/stm32/jshardware.c, create 'targets/linux' and use a single makefile\n            For + While loops work without reallocating lex\n            Fix AddNativeFunction when function already exists (and tests + saved state)\n            Change jsvFindChildFromX to use JsVar* from JsVarRef - saves a lot of lock/unlock\n            Handle new Foo() as per spec (return value + init of this+prototype) - still does not cope with non-object prototype\n            Beginning of SD card support (works on Olimexino, but not very flexible)\n            Fix for parse/eval when given non-strings\n            Strings can now contain '\\0'\n            Jumptable-friendly reserved word check\n            Jumptable-friendly builtin functions (massive refactor)\n            SPI support\n            HY board support, and graphics LCD\n            Added fillPoly, and Vector fonts\n            Added Registration code\n            Fixed some undefined function/array warnings\n            Much better HTML function documentation\n            Fixed edit() function\n            STM32F3 support, and now peripheral stuff is done with a script\n            explain what pins are available if a pin is not capable of requested fn\n            power on ADCs only when needed\n            LCD fillPoly speed improvements, + drawLine\n            Add datatype for Pin, so pins written to console by pin name rather than integer value.\n            Added Pin.set/Pin.reset\n            Change warning about 'undefined.' into an error (foo.reset() had unexpected consequences!)\n            Fix parsing of '1.0/-3'!\n            Add typeof and instanceof operators\n            Ensure that Serial1/SPI1/etc are objects of type 'Serial'/'SPI' - so prototypes can be added\n\n     1v15 : Escaping JSON strings\n            Fix parsing of octal numbers in strings (so don't have to be 3 chars long)\n            Drastically improved stack usage using small stub functions (at expense of a bit of speed)\n            dump() also dumps out prototypes for functions\n\n     1v14 : Fix complaint about pins during setBusyIndicator()\n            Increase available memory on OLIMEXINO\n            Added function memory() to return memory usage\n            setWatch now links to function names (rather than just functions)\n            dump() also handles Serial.onData(...)\n            Fix issue with JSON printing functions with arguments to console\n            prefix builtin variables with '_'\n            fix ArrayIndexOf when array contains undefineds\n            move all devices into one git repository\n            USB on F4\n            call onInit function/string if it exists when Espruino powers on\n            Compile F4 with -O2 - as we have the program memory for it\n            Serial3/4/5/6 on F4\n            Serial3 on Olimexino\n            Make Serial.onData() clear onData handler\n\n     1v13 : Operations like + on Object/Array convert them to strings rather than error\n            var now doesn't error if there is no semi-colon\n            Allow new line or line delete in multi-line editing\n            add edit(functionName) - which copies function definition into inputline so it can be updated\n            When printing lines, delete current inputline and then put it back in idle loop (only if echo=1)\n            Support *,/ etc on numpad\n\n     1v12 : Issue when printing lots of data and then disconnect USB\n            Hide USB/Serial in Dump()\n            add Array.map(fn(x), thisArg)\n            For newline, count [] and () (as well as {}) - also knows about comments/strings/etc\n            Fix assert fail is setTimeout with non-function\n            If space at end of input line, enter still executes\n            Removed some hard-coded arrays in favour of JsVar strings\n            Fix confusion with jsvIsName/jsvIsString\n            Handle numpad end key\n            Add code to check stack and stop stack overflow if too much recursion\n            Ensure that setTimeout/setWatch store the link to a function, not the function\n            Fix nasty ref loop in ref loop GC issue\n            Add dotty output\n            Fix memory leak when error in jspParseSingleFunction\n            Now run Garbage collection if we're idle, and we know we have a few ms spare\n            Added setSleepIndicator\n            Fix line/col indicator in errors/warnings\n            Fix JSON parsing and printing when 'undefined' encountered\n            Rewritten object handling code to be way more standard JavaScript compliant\n            Array initialisation with 'new Array()', also for Strings\n            Added a few more built in functions\n            Nice error reporting with line + pointer\n            fixed Math.random\n            Binary style ops on doubles now work - they are just converted to ints\n            Added boolean datatype\n\n     1v11 : Add Math functions\n            Add command history (and dynamic history free if low memory)\n            Fix broken jsvArrayPop\n            Add tests for and fix Array.indexOf\n            In-line editing for commands\n            Fix bug in basicVarEquals for big strings\n            More fixes for low memory conditions\n            Multi-line edit for commands (but no newline or line delete yet)\n            Handle Home, End + reverse delete keys\n            Fix nested for loops not handling interrupts correctly\n            Fix AppendString issue when given start value greater than string\n            Add 'changeInterval' to allow things created with setInterval to have the frequency changed (eg. stepper motor control)\n            Now puts itself to sleep to save power, when it knows nothing is required and it'll be woken up by SysTick before\n            Change Math library to avoid putting constants in RAM\n\n     1v10 : Increase FIFO size for VL\n            Marginally decrease amount of F4 vars to ensure they all fit in one flash sector\n            Allow strings to be longer than the max token size\n            '\"key\" in obj' syntax\n            Detect if in FOR or WHILE loop, and if not, disallow break and continue\n            Change min setInterval time to 0.1ms - F4 can get close to this\n            Better analog pin error message\n            USB support on Olimexino/Maple\n            Start of multiple COM port support (ioEvent queue)\n            Ctrl-C now clears the input line\n            Save state of 'echo' into flash with save()\n            Add 'setBusyIndicator(pin)' to set pin high when Espruino is busy\n            Inbuilt function handling speed improvements\n            Allow Serial comms via other UARTS. Serial1/2.onData and print/println\n            now inserts elements into arrays in the correct order (GetLength can be (is) now much faster)\n            Faster code to work out pins from strings\n            Automatically convert IDs in form A#,A##,B#,B## etc into numbers.\n            Built-in constants for LED1/BTN/etc.\n\n     1v09 : Enabled 'abs' by default\n            Added flash programming to STM32F4\n            analogWrite now working!\n\n     1v08 : Add preliminary STM32F4 support\n            Allowed test cases to test timers - eg. code in jsinteractive.c\n            Fix memory leak for timer\n            Fix memory leak for digitalWrite\n\n     1v07 : Fix string charAt\n            Fix watch on different pin\n            Pass arguments to event handlers - eg. time\n            digitalWrite/Read to take arrays of pins, and int for value\n\n     1v06 : Add break + continue\n            Add switch statement\n            Handle /r, /r/n or just /n for newlines - phone compatible\n            Handle different type of delete\n\n     1v05 : Allow setWatch/setTimeout/setInterval with a string\n            Handle adding Open bracket then deleting it\n            When calling a NAMED function, zero the scopes - this stops scope table overflow\n\n     1v04 : Renamed to Espruino\n            Fixed issue with event add when out of memory\n            If out of memory happens during a timer, kill all timers\n", "/*\n * This file is part of Espruino, a JavaScript interpreter for Microcontrollers\n *\n * Copyright (C) 2013 Gordon Williams <gw@pur3.co.uk>\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n *\n * ----------------------------------------------------------------------------\n * Recursive descent parser for code execution\n * ----------------------------------------------------------------------------\n */\n#include \"jsparse.h\"\n#include \"jsinteractive.h\"\n#include \"jswrapper.h\"\n#include \"jsnative.h\"\n#include \"jswrap_object.h\" // for function_replacewith\n#include \"jswrap_functions.h\" // insane check for eval in jspeFunctionCall\n#include \"jswrap_json.h\" // for jsfPrintJSON\n#include \"jswrap_espruino.h\" // for jswrap_espruino_memoryArea\n#ifndef SAVE_ON_FLASH\n#include \"jswrap_regexp.h\" // for jswrap_regexp_constructor\n#endif\n\n/* Info about execution when Parsing - this saves passing it on the stack\n * for each call */\nJsExecInfo execInfo;\n\n// ----------------------------------------------- Forward decls\nJsVar *jspeAssignmentExpression();\nJsVar *jspeExpression();\nJsVar *jspeUnaryExpression();\nvoid jspeBlock();\nvoid jspeBlockNoBrackets();\nJsVar *jspeStatement();\nJsVar *jspeFactor();\nvoid jspEnsureIsPrototype(JsVar *instanceOf, JsVar *prototypeName);\n#ifndef SAVE_ON_FLASH\nJsVar *jspeArrowFunction(JsVar *funcVar, JsVar *a);\n#endif\n// ----------------------------------------------- Utils\n#define JSP_MATCH_WITH_CLEANUP_AND_RETURN(TOKEN, CLEANUP_CODE, RETURN_VAL) { if (!jslMatch((TOKEN))) { CLEANUP_CODE; return RETURN_VAL; } }\n#define JSP_MATCH_WITH_RETURN(TOKEN, RETURN_VAL) JSP_MATCH_WITH_CLEANUP_AND_RETURN(TOKEN, , RETURN_VAL)\n#define JSP_MATCH(TOKEN) JSP_MATCH_WITH_CLEANUP_AND_RETURN(TOKEN, , 0) // Match where the user could have given us the wrong token\n#define JSP_ASSERT_MATCH(TOKEN) { assert(lex->tk==(TOKEN));jslGetNextToken(); } // Match where if we have the wrong token, it's an internal error\n#define JSP_SHOULD_EXECUTE (((execInfo.execute)&EXEC_RUN_MASK)==EXEC_YES)\n#define JSP_SAVE_EXECUTE() JsExecFlags oldExecute = execInfo.execute\n#define JSP_RESTORE_EXECUTE() execInfo.execute = (execInfo.execute&(JsExecFlags)(~EXEC_SAVE_RESTORE_MASK)) | (oldExecute&EXEC_SAVE_RESTORE_MASK);\n#define JSP_HAS_ERROR (((execInfo.execute)&EXEC_ERROR_MASK)!=0)\n#define JSP_SHOULDNT_PARSE (((execInfo.execute)&EXEC_NO_PARSE_MASK)!=0)\n\nALWAYS_INLINE void jspDebuggerLoopIfCtrlC() {\n#ifdef USE_DEBUGGER\n  if (execInfo.execute & EXEC_CTRL_C_WAIT && JSP_SHOULD_EXECUTE)\n    jsiDebuggerLoop();\n#endif\n}\n\n/// if interrupting execution, this is set\nbool jspIsInterrupted() {\n  return (execInfo.execute & EXEC_INTERRUPTED)!=0;\n}\n\n/// if interrupting execution, this is set\nvoid jspSetInterrupted(bool interrupt) {\n  if (interrupt)\n    execInfo.execute = execInfo.execute | EXEC_INTERRUPTED;\n  else\n    execInfo.execute = execInfo.execute & (JsExecFlags)~EXEC_INTERRUPTED;\n}\n\n/// Set the error flag - set lineReported if we've already output the line number\nvoid jspSetError(bool lineReported) {\n  execInfo.execute = (execInfo.execute & (JsExecFlags)~EXEC_YES) | EXEC_ERROR;\n  if (lineReported)\n    execInfo.execute |= EXEC_ERROR_LINE_REPORTED;\n}\n\nbool jspHasError() {\n  return JSP_HAS_ERROR;\n}\nvoid jspeiClearScopes() {\n  jsvUnLock(execInfo.scopesVar);\n  execInfo.scopesVar = 0;\n}\n\nbool jspeiAddScope(JsVar *scope) {\n  if (!execInfo.scopesVar)\n    execInfo.scopesVar = jsvNewEmptyArray();\n  if (!execInfo.scopesVar) return false;\n  jsvArrayPush(execInfo.scopesVar, scope);\n  return true;\n}\n\nvoid jspeiRemoveScope() {\n  if (!execInfo.scopesVar || !jsvGetArrayLength(execInfo.scopesVar)) {\n    jsExceptionHere(JSET_INTERNALERROR, \"Too many scopes removed\");\n    jspSetError(false);\n    return;\n  }\n  jsvUnLock(jsvArrayPop(execInfo.scopesVar));\n  if (!jsvGetFirstChild(execInfo.scopesVar)) {\n    jsvUnLock(execInfo.scopesVar);\n    execInfo.scopesVar = 0;\n  }\n}\n\nJsVar *jspeiFindInScopes(const char *name) {\n  if (execInfo.scopesVar) {\n    JsVar *it = jsvLockSafe(jsvGetLastChild(execInfo.scopesVar));\n    while (it) {\n      JsVar *scope = jsvSkipName(it);\n      JsVarRef next = jsvGetPrevSibling(it);\n      JsVar *ref = jsvFindChildFromString(scope, name, false);\n      jsvUnLock2(it, scope);\n      if (ref) return ref;\n      it = jsvLockSafe(next);\n    }\n  }\n  return jsvFindChildFromString(execInfo.root, name, false);\n}\n/// Return the topmost scope (and lock it)\nJsVar *jspeiGetTopScope() {\n  if (execInfo.scopesVar) {\n    JsVar *scope = jsvGetLastArrayItem(execInfo.scopesVar);\n    if (scope) return scope;\n  }\n  return jsvLockAgain(execInfo.root);\n}\nJsVar *jspeiFindOnTop(const char *name, bool createIfNotFound) {\n  JsVar *scope = jspeiGetTopScope();\n  JsVar *result = jsvFindChildFromString(scope, name, createIfNotFound);\n  jsvUnLock(scope);\n  return result;\n}\nJsVar *jspeiFindNameOnTop(JsVar *childName, bool createIfNotFound) {\n  JsVar *scope = jspeiGetTopScope();\n  JsVar *result = jsvFindChildFromVar(scope, childName, createIfNotFound);\n  jsvUnLock(scope);\n  return result;\n}\n\nJsVar *jspFindPrototypeFor(const char *className) {\n  JsVar *obj = jsvObjectGetChild(execInfo.root, className, 0);\n  if (!obj) return 0;\n  JsVar *proto = jsvObjectGetChild(obj, JSPARSE_PROTOTYPE_VAR, 0);\n  jsvUnLock(obj);\n  return proto;\n}\n\n/** Here we assume that we have already looked in the parent itself -\n * and are now going down looking at the stuff it inherited */\nJsVar *jspeiFindChildFromStringInParents(JsVar *parent, const char *name) {\n  if (jsvIsObject(parent)) {\n    // If an object, look for an 'inherits' var\n    JsVar *inheritsFrom = jsvObjectGetChild(parent, JSPARSE_INHERITS_VAR, 0);\n\n    // if there's no inheritsFrom, just default to 'Object.prototype'\n    if (!inheritsFrom)\n      inheritsFrom = jspFindPrototypeFor(\"Object\");\n\n    if (inheritsFrom && inheritsFrom!=parent) {\n      // we have what it inherits from (this is ACTUALLY the prototype var)\n      // https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/proto\n      JsVar *child = jsvFindChildFromString(inheritsFrom, name, false);\n      if (!child)\n        child = jspeiFindChildFromStringInParents(inheritsFrom, name);\n      jsvUnLock(inheritsFrom);\n      if (child) return child;\n    } else\n      jsvUnLock(inheritsFrom);\n  } else { // Not actually an object - but might be an array/string/etc\n    const char *objectName = jswGetBasicObjectName(parent);\n    while (objectName) {\n      JsVar *objName = jsvFindChildFromString(execInfo.root, objectName, false);\n      if (objName) {\n        JsVar *result = 0;\n        JsVar *obj = jsvSkipNameAndUnLock(objName);\n        // could be something the user has made - eg. 'Array=1'\n        if (jsvHasChildren(obj)) {\n          // We have found an object with this name - search for the prototype var\n          JsVar *proto = jsvObjectGetChild(obj, JSPARSE_PROTOTYPE_VAR, 0);\n          if (proto) {\n            result = jsvFindChildFromString(proto, name, false);\n            jsvUnLock(proto);\n          }\n        }\n        jsvUnLock(obj);\n        if (result) return result;\n      }\n      /* We haven't found anything in the actual object, we should check the 'Object' itself\n        eg, we tried 'String', so now we should try 'Object'. Built-in types don't have room for\n        a prototype field, so we hard-code it */\n      objectName = jswGetBasicObjectPrototypeName(objectName);\n    }\n  }\n\n  // no luck!\n  return 0;\n}\n\nJsVar *jspeiGetScopesAsVar() {\n  if (!execInfo.scopesVar) return 0; // no scopes!\n  // If just one element, return it (no array)\n  if (jsvGetArrayLength(execInfo.scopesVar)==1) {\n    JsVar *v = jsvGetLastArrayItem(execInfo.scopesVar); // this is faster than getting by index\n    return v;\n  }\n  // Copy this - because if we just returned it, the underlying array would get altered\n  return jsvCopy(execInfo.scopesVar, true);\n}\n\nvoid jspeiLoadScopesFromVar(JsVar *arr) {\n  jsvUnLock(execInfo.scopesVar);\n  execInfo.scopesVar = 0;\n  if (arr) {\n    if (jsvIsArray(arr)) {\n      // TODO: copy on write? would make function calls faster\n      execInfo.scopesVar = jsvCopy(arr, true);\n    } else {\n      // just a single item,but we must package it in an array\n      execInfo.scopesVar = jsvNewArray(&arr, 1);\n    }\n  }\n}\n// -----------------------------------------------\n/// Check that we have enough stack to recurse. Return true if all ok, error if not.\nbool jspCheckStackPosition() {\n  if (jsuGetFreeStack() < 512) { // giving us 512 bytes leeway\n    jsExceptionHere(JSET_ERROR, \"Too much recursion - the stack is about to overflow\");\n    jspSetInterrupted(true);\n    return false;\n  }\n  return true;\n}\n\n\n// Set execFlags such that we are not executing\nvoid jspSetNoExecute() {\n  execInfo.execute = (execInfo.execute & (JsExecFlags)(int)~EXEC_RUN_MASK) | EXEC_NO;\n}\n\nvoid jspAppendStackTrace(JsVar *stackTrace) {\n  JsvStringIterator it;\n  jsvStringIteratorNew(&it, stackTrace, 0);\n  jsvStringIteratorGotoEnd(&it);\n  jslPrintPosition((vcbprintf_callback)jsvStringIteratorPrintfCallback, &it, lex->tokenLastStart);\n  jslPrintTokenLineMarker((vcbprintf_callback)jsvStringIteratorPrintfCallback, &it, lex->tokenLastStart, 0);\n  jsvStringIteratorFree(&it);\n}\n\n/// We had an exception (argument is the exception's value)\nvoid jspSetException(JsVar *value) {\n  // Add the exception itself to a variable in root scope\n  JsVar *exception = jsvFindChildFromString(execInfo.hiddenRoot, JSPARSE_EXCEPTION_VAR, true);\n  if (exception) {\n    jsvSetValueOfName(exception, value);\n    jsvUnLock(exception);\n  }\n  // Set the exception flag\n  execInfo.execute = execInfo.execute | EXEC_EXCEPTION;\n  // Try and do a stack trace\n  if (lex) {\n    JsVar *stackTrace = jsvObjectGetChild(execInfo.hiddenRoot, JSPARSE_STACKTRACE_VAR, JSV_STRING_0);\n    if (stackTrace) {\n      jsvAppendPrintf(stackTrace, \" at \");\n      jspAppendStackTrace(stackTrace);\n      jsvUnLock(stackTrace);\n      // stop us from printing the trace in the same block\n      execInfo.execute = execInfo.execute | EXEC_ERROR_LINE_REPORTED;\n    }\n  }\n\n}\n\n/** Return the reported exception if there was one (and clear it) */\nJsVar *jspGetException() {\n  JsVar *exceptionName = jsvFindChildFromString(execInfo.hiddenRoot, JSPARSE_EXCEPTION_VAR, false);\n  if (exceptionName) {\n    JsVar *exception = jsvSkipName(exceptionName);\n    jsvRemoveChild(execInfo.hiddenRoot, exceptionName);\n    jsvUnLock(exceptionName);\n\n    JsVar *stack = jspGetStackTrace();\n    if (stack && jsvHasChildren(exception)) {\n      jsvObjectSetChild(exception, \"stack\", stack);\n    }\n    jsvUnLock(stack);\n\n    return exception;\n  }\n  return 0;\n}\n\n/** Return a stack trace string if there was one (and clear it) */\nJsVar *jspGetStackTrace() {\n  JsVar *stackTraceName = jsvFindChildFromString(execInfo.hiddenRoot, JSPARSE_STACKTRACE_VAR, false);\n  if (stackTraceName) {\n    JsVar *stackTrace = jsvSkipName(stackTraceName);\n    jsvRemoveChild(execInfo.hiddenRoot, stackTraceName);\n    jsvUnLock(stackTraceName);\n    return stackTrace;\n  }\n  return 0;\n}\n\n// ----------------------------------------------\n\n// we return a value so that JSP_MATCH can return 0 if it fails (if we pass 0, we just parse all args)\nNO_INLINE bool jspeFunctionArguments(JsVar *funcVar) {\n  JSP_MATCH('(');\n  while (lex->tk!=')') {\n    if (funcVar) {\n      char buf[JSLEX_MAX_TOKEN_LENGTH+1];\n      buf[0] = '\\xFF';\n      strcpy(&buf[1], jslGetTokenValueAsString());\n      JsVar *param = jsvAddNamedChild(funcVar, 0, buf);\n      if (!param) { // out of memory\n        jspSetError(false);\n        return false;\n      }\n      jsvMakeFunctionParameter(param); // force this to be called a function parameter\n      jsvUnLock(param);\n    }\n    JSP_MATCH(LEX_ID);\n    if (lex->tk!=')') JSP_MATCH(',');\n  }\n  JSP_MATCH(')');\n  return true;\n}\n\n// Parse function, assuming we're on '{'. funcVar can be 0. returns 'true' is the function included the 'this' keyword\nNO_INLINE bool jspeFunctionDefinitionInternal(JsVar *funcVar, bool expressionOnly) {\n  bool forcePretokenise = false;\n\n  if (expressionOnly) {\n    if (funcVar)\n      funcVar->flags = (funcVar->flags & ~JSV_VARTYPEMASK) | JSV_FUNCTION_RETURN;\n  } else {\n    JSP_MATCH('{');\n  #ifndef SAVE_ON_FLASH\n    if (lex->tk==LEX_STR) {\n      if (!strcmp(jslGetTokenValueAsString(), \"compiled\"))\n        jsWarn(\"Function marked with \\\"compiled\\\" uploaded in source form\");\n      if (lex->tk==LEX_STR && !strcmp(jslGetTokenValueAsString(), \"ram\")) {\n        JSP_ASSERT_MATCH(LEX_STR);\n        forcePretokenise = true;\n      }\n    }\n  #endif\n\n    /* If the function starts with return, treat it specially -\n     * we don't want to store the 'return' part of it\n     */\n    if (funcVar && lex->tk==LEX_R_RETURN) {\n      funcVar->flags = (funcVar->flags & ~JSV_VARTYPEMASK) | JSV_FUNCTION_RETURN;\n      JSP_ASSERT_MATCH(LEX_R_RETURN);\n    }\n  }\n#ifndef ESPR_NO_LINE_NUMBERS\n  // Get the line number (if needed)\n  JsVarInt lineNumber = 0;\n  if (funcVar && lex->lineNumberOffset && !(forcePretokenise||jsfGetFlag(JSF_PRETOKENISE))) {\n    // jslGetLineNumber is slow, so we only do it if we have debug info\n    lineNumber = (JsVarInt)jslGetLineNumber() + (JsVarInt)lex->lineNumberOffset - 1;\n  }\n#endif\n  // Get the code - parse it and figure out where it stops\n  JslCharPos funcBegin;\n  jslSkipWhiteSpace();\n  jslCharPosNew(&funcBegin, lex->sourceVar, lex->tokenStart);\n  int lastTokenEnd = -1;\n  lex->hadThisKeyword = lex->tk == LEX_R_THIS;\n  if (!expressionOnly) {\n    int brackets = 0;\n    while (lex->tk && (brackets || lex->tk != '}')) {\n      if (lex->tk == '{') brackets++;\n      if (lex->tk == '}') brackets--;\n      lastTokenEnd = (int)jsvStringIteratorGetIndex(&lex->it)-1;\n      JSP_ASSERT_MATCH(lex->tk);\n    }\n    // FIXME: we might be including whitespace after the last token\n  } else {\n    JsExecFlags oldExec = execInfo.execute;\n    execInfo.execute = EXEC_NO;\n    jsvUnLock(jspeAssignmentExpression());\n    execInfo.execute = oldExec;\n    lastTokenEnd = (int)lex->tokenStart;\n  }\n  bool hadThisKeyword = lex->hadThisKeyword;\n  // Then create var and set (if there was any code!)\n  if (funcVar && lastTokenEnd>0) {\n    // code var\n    JsVar *funcCodeVar;\n    if (!forcePretokenise && jsvIsNativeString(lex->sourceVar)) {\n      /* If we're parsing from a Native String (eg. E.memoryArea, E.setBootCode) then\n      use another Native String to load function code straight from flash */\n      int s = (int)jsvStringIteratorGetIndex(&funcBegin.it) - 1;\n      funcCodeVar = jsvNewNativeString(lex->sourceVar->varData.nativeStr.ptr + s, (unsigned int)(lastTokenEnd - s));\n#ifdef SPIFLASH_BASE\n    } else if (!forcePretokenise && jsvIsFlashString(lex->sourceVar)) {\n        /* If we're parsing from a Flash String (eg. loaded from Storage on Bangle.js) then\n      use another Flash String to load function code straight from flash*/\n        int s = (int)jsvStringIteratorGetIndex(&funcBegin.it) - 1;\n        funcCodeVar = jsvNewFlashString(lex->sourceVar->varData.nativeStr.ptr + s, (unsigned int)(lastTokenEnd - s));\n#endif\n    } else {\n      if (jsfGetFlag(JSF_PRETOKENISE) || forcePretokenise) {\n        funcCodeVar = jslNewTokenisedStringFromLexer(&funcBegin, (size_t)lastTokenEnd);\n      } else {\n        funcCodeVar = jslNewStringFromLexer(&funcBegin, (size_t)lastTokenEnd);\n      }\n    }\n    jsvUnLock2(jsvAddNamedChild(funcVar, funcCodeVar, JSPARSE_FUNCTION_CODE_NAME), funcCodeVar);\n    // scope var\n    JsVar *funcScopeVar = jspeiGetScopesAsVar();\n    if (funcScopeVar) {\n      jsvUnLock2(jsvAddNamedChild(funcVar, funcScopeVar, JSPARSE_FUNCTION_SCOPE_NAME), funcScopeVar);\n    }\n#ifndef ESPR_NO_LINE_NUMBERS\n    // If we've got a line number, add a var for it\n    if (lineNumber) {\n      JsVar *funcLineNumber = jsvNewFromInteger(lineNumber);\n      if (funcLineNumber) {\n        jsvUnLock2(jsvAddNamedChild(funcVar, funcLineNumber, JSPARSE_FUNCTION_LINENUMBER_NAME), funcLineNumber);\n      }\n    }\n#endif\n  }\n\n  jslCharPosFree(&funcBegin);\n  if (!expressionOnly) JSP_MATCH('}');\n  return hadThisKeyword;\n}\n\n// Parse function (after 'function' has occurred\nNO_INLINE JsVar *jspeFunctionDefinition(bool parseNamedFunction) {\n  // actually parse a function... We assume that the LEX_FUNCTION and name\n  // have already been parsed\n  JsVar *funcVar = 0;\n\n  bool actuallyCreateFunction = JSP_SHOULD_EXECUTE;\n  if (actuallyCreateFunction)\n    funcVar = jsvNewWithFlags(JSV_FUNCTION);\n\n  JsVar *functionInternalName = 0;\n  if (parseNamedFunction && lex->tk==LEX_ID) {\n    // you can do `var a = function foo() { foo(); };` - so cope with this\n    if (funcVar) functionInternalName = jslGetTokenValueAsVar();\n    // note that we don't add it to the beginning, because it would mess up our function call code\n    JSP_ASSERT_MATCH(LEX_ID);\n  }\n\n  // Get arguments save them to the structure\n  if (!jspeFunctionArguments(funcVar)) {\n    jsvUnLock2(functionInternalName, funcVar);\n    // parse failed\n    return 0;\n  }\n\n  // Parse the actual function block\n  jspeFunctionDefinitionInternal(funcVar, false);\n\n  // if we had a function name, add it to the end (if we don't it gets confused with arguments)\n  if (funcVar && functionInternalName)\n    jsvObjectSetChildAndUnLock(funcVar, JSPARSE_FUNCTION_NAME_NAME, functionInternalName);\n\n  return funcVar;\n}\n\n/* Parse just the brackets of a function - and throw\n * everything away */\nNO_INLINE bool jspeParseFunctionCallBrackets() {\n  assert(!JSP_SHOULD_EXECUTE);\n  JSP_MATCH('(');\n  while (!JSP_SHOULDNT_PARSE && lex->tk != ')') {\n    jsvUnLock(jspeAssignmentExpression());\n#ifndef SAVE_ON_FLASH\n    if (lex->tk==LEX_ARROW_FUNCTION) {\n      jsvUnLock(jspeArrowFunction(0, 0));\n    }\n#endif\n    if (lex->tk!=')') JSP_MATCH(',');\n  }\n  if (!JSP_SHOULDNT_PARSE) JSP_MATCH(')');\n  return 0;\n}\n\n/** Handle a function call (assumes we've parsed the function name and we're\n * on the start bracket). 'thisArg' is the value of the 'this' variable when the\n * function is executed (it's usually the parent object)\n *\n *\n * NOTE: this does not set the execInfo flags - so if execInfo==EXEC_NO, it won't execute\n *\n * If !isParsing and arg0!=0, argument 0 is set to what is supplied (same with arg1)\n *\n * functionName is used only for error reporting - and can be 0\n */\nNO_INLINE JsVar *jspeFunctionCall(JsVar *function, JsVar *functionName, JsVar *thisArg, bool isParsing, int argCount, JsVar **argPtr) {\n  if (JSP_SHOULD_EXECUTE && !function) {\n    if (functionName)\n      jsExceptionHere(JSET_ERROR, \"Function %q not found!\", functionName);\n    else\n      jsExceptionHere(JSET_ERROR, \"Function not found!\", functionName);\n    return 0;\n  }\n\n  if (JSP_SHOULD_EXECUTE) if (!jspCheckStackPosition()) return 0; // try and ensure that we won't overflow our stack\n\n  if (JSP_SHOULD_EXECUTE && function) {\n    JsVar *returnVar = 0;\n\n    if (!jsvIsFunction(function)) {\n      jsExceptionHere(JSET_ERROR, \"Expecting a function to call, got %t\", function);\n      return 0;\n    }\n    JsVar *thisVar = jsvLockAgainSafe(thisArg);\n    if (isParsing) JSP_MATCH('(');\n\n    /* Ok, so we have 4 options here.\n     *\n     * 1: we're native.\n     *   a) args have been pre-parsed, which is awesome\n     *   b) we have to parse our own args into an array\n     * 2: we're not native\n     *   a) args were pre-parsed and we have to populate the function\n     *   b) we parse our own args, which is possibly better\n     */\n    if (jsvIsNativeFunction(function)) { // ------------------------------------- NATIVE\n      unsigned int argPtrSize = 0;\n      int boundArgs = 0;\n      // Add 'bound' parameters if there were any\n      JsvObjectIterator it;\n      jsvObjectIteratorNew(&it, function);\n      JsVar *param = jsvObjectIteratorGetKey(&it);\n      while (jsvIsFunctionParameter(param)) {\n        if ((unsigned)argCount>=argPtrSize) {\n          // allocate more space on stack if needed\n          unsigned int newArgPtrSize = (argPtrSize?argPtrSize:(unsigned int)argCount)*4;\n          size_t newArgPtrByteSize = sizeof(JsVar*)*newArgPtrSize;\n          if (jsuGetFreeStack() < 256+newArgPtrByteSize) {\n            jsExceptionHere(JSET_ERROR, \"Insufficient stack for this many arguments\");\n            jsvUnLock(thisVar);\n            return 0;\n          }\n          JsVar **newArgPtr = (JsVar**)alloca(newArgPtrByteSize);\n          memcpy(newArgPtr, argPtr, (unsigned)argCount*sizeof(JsVar*));\n          argPtr = newArgPtr;\n          argPtrSize = newArgPtrSize;\n        }\n        // if we already had arguments - shift them up...\n        int i;\n        for (i=argCount-1;i>=boundArgs;i--)\n          argPtr[i+1] = argPtr[i];\n        // add bound argument\n        argPtr[boundArgs] = jsvSkipName(param);\n        argCount++;\n        boundArgs++;\n        jsvUnLock(param);\n        jsvObjectIteratorNext(&it);\n        param = jsvObjectIteratorGetKey(&it);\n      }\n      // check if 'this' was defined\n      while (param) {\n        if (jsvIsStringEqual(param, JSPARSE_FUNCTION_THIS_NAME)) {\n          jsvUnLock(thisVar);\n          thisVar = jsvSkipName(param);\n          break;\n        }\n        jsvUnLock(param);\n        jsvObjectIteratorNext(&it);\n        param = jsvObjectIteratorGetKey(&it);\n      }\n      jsvUnLock(param);\n      jsvObjectIteratorFree(&it);\n\n      // Now, if we're parsing add the rest of the arguments\n      int allocatedArgCount = boundArgs;\n      if (isParsing) {\n        while (!JSP_HAS_ERROR && lex->tk!=')' && lex->tk!=LEX_EOF) {\n          if ((unsigned)argCount>=argPtrSize) {\n            // allocate more space on stack\n            unsigned int newArgPtrSize = argPtrSize?argPtrSize*4:16;\n            JsVar **newArgPtr = (JsVar**)alloca(sizeof(JsVar*)*newArgPtrSize);\n            memcpy(newArgPtr, argPtr, (unsigned)argCount*sizeof(JsVar*));\n            argPtr = newArgPtr;\n            argPtrSize = newArgPtrSize;\n          }\n          argPtr[argCount++] = jsvSkipNameAndUnLock(jspeAssignmentExpression());\n          if (lex->tk!=')') JSP_MATCH_WITH_CLEANUP_AND_RETURN(',',jsvUnLockMany((unsigned)argCount, argPtr);jsvUnLock(thisVar);, 0);\n        }\n\n        JSP_MATCH(')');\n        allocatedArgCount = argCount;\n      }\n\n      void *nativePtr = jsvGetNativeFunctionPtr(function);\n\n      JsVar *oldThisVar = execInfo.thisVar;\n      if (thisVar)\n        execInfo.thisVar = jsvRef(thisVar);\n      else {\n        if (nativePtr==jswrap_eval) { // eval gets to use the current scope\n          /* Note: proper JS has some utterly insane code that depends on whether\n           * eval is an lvalue or not:\n           *\n           * http://stackoverflow.com/questions/9107240/1-evalthis-vs-evalthis-in-javascript\n           *\n           * Doing this in Espruino is quite an upheaval for that one\n           * slightly insane case - so it's not implemented. */\n          if (execInfo.thisVar) execInfo.thisVar = jsvRef(execInfo.thisVar);\n        } else {\n          execInfo.thisVar = jsvRef(execInfo.root); // 'this' should always default to root\n        }\n      }\n\n\n\n      if (nativePtr && !JSP_HAS_ERROR) {\n        returnVar = jsnCallFunction(nativePtr, function->varData.native.argTypes, thisVar, argPtr, argCount);\n        assert(!jsvIsName(returnVar));\n      } else {\n        returnVar = 0;\n      }\n\n      // unlock values if we locked them\n      jsvUnLockMany((unsigned)allocatedArgCount, argPtr);\n\n      /* Return to old 'this' var. No need to unlock as we never locked before */\n      if (execInfo.thisVar) jsvUnRef(execInfo.thisVar);\n      execInfo.thisVar = oldThisVar;\n\n    } else { // ----------------------------------------------------- NOT NATIVE\n      // create a new symbol table entry for execution of this function\n      // OPT: can we cache this function execution environment + param variables?\n      // OPT: Probably when calling a function ONCE, use it, otherwise when recursing, make new?\n      JsVar *functionRoot = jsvNewWithFlags(JSV_FUNCTION);\n      if (!functionRoot) { // out of memory\n        jspSetError(false);\n        jsvUnLock(thisVar);\n        return 0;\n      }\n\n      JsVar *functionScope = 0;\n      JsVar *functionCode = 0;\n      JsVar *functionInternalName = 0;\n#ifndef ESPR_NO_LINE_NUMBERS\n      uint16_t functionLineNumber = 0;\n#endif\n\n      /** NOTE: We expect that the function object will have:\n       *\n       *  * Parameters\n       *  * Code/Scope/Name\n       *\n       * IN THAT ORDER.\n       */\n      JsvObjectIterator it;\n      jsvObjectIteratorNew(&it, function);\n\n      JsVar *param = jsvObjectIteratorGetKey(&it);\n      JsVar *value = jsvObjectIteratorGetValue(&it);\n      while (jsvIsFunctionParameter(param) && value) {\n        jsvAddFunctionParameter(functionRoot, jsvNewFromStringVar(param,1,JSVAPPENDSTRINGVAR_MAXLENGTH), value);\n        jsvUnLock2(value, param);\n        jsvObjectIteratorNext(&it);\n        param = jsvObjectIteratorGetKey(&it);\n        value = jsvObjectIteratorGetValue(&it);\n      }\n      jsvUnLock2(value, param);\n      if (isParsing) {\n        int hadParams = 0;\n        // grab in all parameters. We go around this loop until we've run out\n        // of named parameters AND we've parsed all the supplied arguments\n        while (!JSP_SHOULDNT_PARSE && lex->tk!=')') {\n          JsVar *param = jsvObjectIteratorGetKey(&it);\n          bool paramDefined = jsvIsFunctionParameter(param);\n          if (lex->tk!=')' || paramDefined) {\n            hadParams++;\n            JsVar *value = 0;\n            // ONLY parse this if it was supplied, otherwise leave 0 (undefined)\n            if (lex->tk!=')')\n              value = jspeAssignmentExpression();\n            // and if execute, copy it over\n            value = jsvSkipNameAndUnLock(value);\n            jsvAddFunctionParameter(functionRoot, paramDefined?jsvNewFromStringVar(param,1,JSVAPPENDSTRINGVAR_MAXLENGTH):0, value);\n            jsvUnLock(value);\n            if (lex->tk!=')') JSP_MATCH(',');\n          }\n          jsvUnLock(param);\n          if (paramDefined) jsvObjectIteratorNext(&it);\n        }\n        JSP_MATCH(')');\n      } else {  // and NOT isParsing\n        int args = 0;\n        while (args<argCount) {\n          JsVar *param = jsvObjectIteratorGetKey(&it);\n          bool paramDefined = jsvIsFunctionParameter(param);\n          jsvAddFunctionParameter(functionRoot, paramDefined?jsvNewFromStringVar(param,1,JSVAPPENDSTRINGVAR_MAXLENGTH):0, argPtr[args]);\n          args++;\n          jsvUnLock(param);\n          if (paramDefined) jsvObjectIteratorNext(&it);\n        }\n      }\n      // Now go through what's left\n      while (jsvObjectIteratorHasValue(&it)) {\n        JsVar *param = jsvObjectIteratorGetKey(&it);\n        if (jsvIsString(param)) {\n          if (jsvIsStringEqual(param, JSPARSE_FUNCTION_SCOPE_NAME)) functionScope = jsvSkipName(param);\n          else if (jsvIsStringEqual(param, JSPARSE_FUNCTION_CODE_NAME)) functionCode = jsvSkipName(param);\n          else if (jsvIsStringEqual(param, JSPARSE_FUNCTION_NAME_NAME)) functionInternalName = jsvSkipName(param);\n          else if (jsvIsStringEqual(param, JSPARSE_FUNCTION_THIS_NAME)) {\n            jsvUnLock(thisVar);\n            thisVar = jsvSkipName(param);\n          }\n#ifndef ESPR_NO_LINE_NUMBERS\n          else if (jsvIsStringEqual(param, JSPARSE_FUNCTION_LINENUMBER_NAME)) functionLineNumber = (uint16_t)jsvGetIntegerAndUnLock(jsvSkipName(param));\n#endif\n          else if (jsvIsFunctionParameter(param)) {\n            JsVar *defaultVal = jsvSkipName(param);\n            jsvAddFunctionParameter(functionRoot, jsvNewFromStringVar(param,1,JSVAPPENDSTRINGVAR_MAXLENGTH), defaultVal);\n            jsvUnLock(defaultVal);\n          }\n        }\n        jsvUnLock(param);\n        jsvObjectIteratorNext(&it);\n      }\n      jsvObjectIteratorFree(&it);\n\n      // setup a the function's name (if a named function)\n      if (functionInternalName) {\n        JsVar *name = jsvMakeIntoVariableName(jsvNewFromStringVar(functionInternalName,0,JSVAPPENDSTRINGVAR_MAXLENGTH), function);\n        jsvAddName(functionRoot, name);\n        jsvUnLock2(name, functionInternalName);\n      }\n\n      if (!JSP_HAS_ERROR) {\n        // save old scopes and reset scope list\n        JsVar *oldScopeVar = execInfo.scopesVar;\n        execInfo.scopesVar = 0;\n        // if we have a scope var, load it up. We may not have one if there were no scopes apart from root\n        if (functionScope) {\n          jspeiLoadScopesFromVar(functionScope);\n          jsvUnLock(functionScope);\n        }\n        // add the function's execute space to the symbol table so we can recurse\n        if (jspeiAddScope(functionRoot)) {\n          /* Adding scope may have failed - we may have descended too deep - so be sure\n           * not to pull somebody else's scope off\n           */\n\n          JsVar *oldThisVar = execInfo.thisVar;\n          if (thisVar)\n            execInfo.thisVar = jsvRef(thisVar);\n          else\n            execInfo.thisVar = jsvRef(execInfo.root); // 'this' should always default to root\n\n\n          /* we just want to execute the block, but something could\n           * have messed up and left us with the wrong Lexer, so\n           * we want to be careful here... */\n          if (functionCode) {\n#ifdef USE_DEBUGGER\n            bool hadDebuggerNextLineOnly = false;\n\n            if (execInfo.execute&EXEC_DEBUGGER_STEP_INTO) {\n\t      if (functionName)\n\t\tjsiConsolePrintf(\"Stepping into %v\\n\", functionName);\n\t      else\n\t\tjsiConsolePrintf(\"Stepping into function\\n\", functionName);\n            } else {\n              hadDebuggerNextLineOnly = execInfo.execute&EXEC_DEBUGGER_NEXT_LINE;\n              if (hadDebuggerNextLineOnly)\n                execInfo.execute &= (JsExecFlags)~EXEC_DEBUGGER_NEXT_LINE;\n            }\n#endif\n\n\n            JsLex newLex;\n            JsLex *oldLex = jslSetLex(&newLex);\n            jslInit(functionCode);\n#ifndef ESPR_NO_LINE_NUMBERS\n            newLex.lineNumberOffset = functionLineNumber;\n#endif\n            JSP_SAVE_EXECUTE();\n            // force execute without any previous state\n#ifdef USE_DEBUGGER\n            execInfo.execute = EXEC_YES | (execInfo.execute&(EXEC_CTRL_C_MASK|EXEC_ERROR_MASK|EXEC_DEBUGGER_NEXT_LINE));\n#else\n            execInfo.execute = EXEC_YES | (execInfo.execute&(EXEC_CTRL_C_MASK|EXEC_ERROR_MASK));\n#endif\n            if (jsvIsFunctionReturn(function)) {\n              #ifdef USE_DEBUGGER\n                // we didn't parse a statement so wouldn't trigger the debugger otherwise\n                if (execInfo.execute&EXEC_DEBUGGER_NEXT_LINE && JSP_SHOULD_EXECUTE) {\n                  lex->tokenLastStart = lex->tokenStart;\n                  jsiDebuggerLoop();\n                }\n              #endif\n              // implicit return - we just need an expression (optional)\n              if (lex->tk != ';' && lex->tk != '}')\n                returnVar = jsvSkipNameAndUnLock(jspeExpression());\n            } else {\n              // setup a return variable\n              JsVar *returnVarName = jsvAddNamedChild(functionRoot, 0, JSPARSE_RETURN_VAR);\n              // parse the whole block\n              jspeBlockNoBrackets();\n              /* get the real return var before we remove it from our function.\n               * We can unlock below because returnVarName is still part of\n               * functionRoot, so won't get freed. */\n              returnVar = jsvSkipNameAndUnLock(returnVarName);\n              if (returnVarName) // could have failed with out of memory\n                jsvSetValueOfName(returnVarName, 0); // remove return value (which helps stops circular references)\n            }\n            // Store a stack trace if we had an error\n            JsExecFlags hasError = execInfo.execute&EXEC_ERROR_MASK;\n            JSP_RESTORE_EXECUTE(); // because return will probably have set execute to false\n\n#ifdef USE_DEBUGGER\n            bool calledDebugger = false;\n            if (execInfo.execute & EXEC_DEBUGGER_MASK) {\n              jsiConsolePrint(\"Value returned is =\");\n              jsfPrintJSON(returnVar, JSON_LIMIT | JSON_SOME_NEWLINES | JSON_PRETTY | JSON_SHOW_DEVICES);\n              jsiConsolePrintChar('\\n');\n              if (execInfo.execute & EXEC_DEBUGGER_FINISH_FUNCTION) {\n                calledDebugger = true;\n                jsiDebuggerLoop();\n              }\n            }\n            if (hadDebuggerNextLineOnly && !calledDebugger)\n              execInfo.execute |= EXEC_DEBUGGER_NEXT_LINE;\n#endif\n\n            jslKill();\n            jslSetLex(oldLex);\n\n            if (hasError) {\n              execInfo.execute |= hasError; // propogate error\n              JsVar *stackTrace = jsvObjectGetChild(execInfo.hiddenRoot, JSPARSE_STACKTRACE_VAR, JSV_STRING_0);\n              if (stackTrace) {\n                jsvAppendPrintf(stackTrace, jsvIsString(functionName)?\"in function %q called from \":\n                    \"in function called from \", functionName);\n                if (lex) {\n                  jspAppendStackTrace(stackTrace);\n                } else\n                  jsvAppendPrintf(stackTrace, \"system\\n\");\n                jsvUnLock(stackTrace);\n              }\n            }\n          }\n\n          /* Return to old 'this' var. No need to unlock as we never locked before */\n          if (execInfo.thisVar) jsvUnRef(execInfo.thisVar);\n          execInfo.thisVar = oldThisVar;\n\n          jspeiRemoveScope();\n        }\n\n        // Unlock scopes and restore old ones\n        jsvUnLock(execInfo.scopesVar);\n        execInfo.scopesVar = oldScopeVar;\n      }\n      jsvUnLock(functionCode);\n      jsvUnLock(functionRoot);\n    }\n\n    jsvUnLock(thisVar);\n\n    return returnVar;\n  } else if (isParsing) { // ---------------------------------- function, but not executing - just parse args and be done\n    jspeParseFunctionCallBrackets();\n    /* Do not return function, as it will be unlocked! */\n    return 0;\n  } else return 0;\n}\n\n// Find a variable (or built-in function) based on the current scopes\nJsVar *jspGetNamedVariable(const char *tokenName) {\n  JsVar *a = JSP_SHOULD_EXECUTE ? jspeiFindInScopes(tokenName) : 0;\n  if (JSP_SHOULD_EXECUTE && !a) {\n    /* Special case! We haven't found the variable, so check out\n     * and see if it's one of our builtins...  */\n    if (jswIsBuiltInObject(tokenName)) {\n      // Check if we have a built-in function for it\n      // OPT: Could we instead have jswIsBuiltInObjectWithoutConstructor?\n      JsVar *obj = jswFindBuiltInFunction(0, tokenName);\n      // If not, make one\n      if (!obj)\n        obj = jspNewBuiltin(tokenName);\n      if (obj) { // not out of memory\n        a = jsvAddNamedChild(execInfo.root, obj, tokenName);\n        jsvUnLock(obj);\n      }\n    } else {\n      a = jswFindBuiltInFunction(0, tokenName);\n      if (!a) {\n        /* Variable doesn't exist! JavaScript says we should create it\n         * (we won't add it here. This is done in the assignment operator)*/\n        a = jsvMakeIntoVariableName(jsvNewFromString(tokenName), 0);\n      }\n    }\n  }\n  return a;\n}\n\n/// Used by jspGetNamedField / jspGetVarNamedField\nstatic NO_INLINE JsVar *jspGetNamedFieldInParents(JsVar *object, const char* name, bool returnName) {\n  // Now look in prototypes\n  JsVar * child = jspeiFindChildFromStringInParents(object, name);\n\n  /* Check for builtins via separate function\n   * This way we save on RAM for built-ins because everything comes out of program code */\n  if (!child) {\n    child = jswFindBuiltInFunction(object, name);\n  }\n\n  /* We didn't get here if we found a child in the object itself, so\n   * if we're here then we probably have the wrong name - so for example\n   * with `a.b = c;` could end up setting `a.prototype.b` (bug #360)\n   *\n   * Also we might have got a built-in, which wouldn't have a name on it\n   * anyway - so in both cases, strip the name if it is there, and create\n   * a new name that references the object we actually requested the\n   * member from..\n   */\n  if (child && returnName) {\n    // Get rid of existing name\n    if (jsvIsName(child)) {\n      JsVar *t = jsvGetValueOfName(child);\n      jsvUnLock(child);\n      child = t;\n    }\n    // create a new name\n    JsVar *nameVar = jsvNewFromString(name);\n    JsVar *newChild = jsvCreateNewChild(object, nameVar, child);\n    jsvUnLock2(nameVar, child);\n    child = newChild;\n  }\n\n  // If not found and is the prototype, create it\n  if (!child) {\n    if (jsvIsFunction(object) && strcmp(name, JSPARSE_PROTOTYPE_VAR)==0) {\n      // prototype is supposed to be an object\n      JsVar *proto = jsvNewObject();\n      // make sure it has a 'constructor' variable that points to the object it was part of\n      jsvObjectSetChild(proto, JSPARSE_CONSTRUCTOR_VAR, object);\n      child = jsvAddNamedChild(object, proto, JSPARSE_PROTOTYPE_VAR);\n      jspEnsureIsPrototype(object, child);\n      jsvUnLock(proto);\n    } else if (strcmp(name, JSPARSE_INHERITS_VAR)==0) {\n      const char *objName = jswGetBasicObjectName(object);\n      if (objName) {\n        JsVar *p = jsvSkipNameAndUnLock(jspNewPrototype(objName));\n        // jspNewPrototype returns a 'prototype' name that's already a child of eg. an array\n        // Create a new 'name' called __proto__ that links to it\n        JsVar *i = jsvNewFromString(JSPARSE_INHERITS_VAR);\n        if (p) child = jsvCreateNewChild(object, i, p);\n        jsvUnLock(i);\n      }\n    }\n  }\n\n  return child;\n}\n\n/** Get the named function/variable on the object - whether it's built in, or predefined.\n * If !returnName, returns the function/variable itself or undefined, but\n * if returnName, return a name (could be fake) referencing the parent.\n *\n * NOTE: ArrayBuffer/Strings are not handled here. We assume that if we're\n * passing a char* rather than a JsVar it's because we're looking up via\n * a symbol rather than a variable. To handle these use jspGetVarNamedField  */\nJsVar *jspGetNamedField(JsVar *object, const char* name, bool returnName) {\n\n  JsVar *child = 0;\n  // if we're an object (or pretending to be one)\n  if (jsvHasChildren(object))\n    child = jsvFindChildFromString(object, name, false);\n\n  if (!child) {\n    child = jspGetNamedFieldInParents(object, name, returnName);\n\n    // If not found and is the prototype, create it\n    if (!child && jsvIsFunction(object) && strcmp(name, JSPARSE_PROTOTYPE_VAR)==0) {\n      JsVar *value = jsvNewObject(); // prototype is supposed to be an object\n      child = jsvAddNamedChild(object, value, JSPARSE_PROTOTYPE_VAR);\n      jsvUnLock(value);\n    }\n  }\n\n  if (returnName) return child;\n  else return jsvSkipNameAndUnLock(child);\n}\n\n/// see jspGetNamedField - note that nameVar should have had jsvAsArrayIndex called on it first\nJsVar *jspGetVarNamedField(JsVar *object, JsVar *nameVar, bool returnName) {\n\n  JsVar *child = 0;\n  // if we're an object (or pretending to be one)\n  if (jsvHasChildren(object))\n    child = jsvFindChildFromVar(object, nameVar, false);\n\n  if (!child) {\n    if (jsvIsArrayBuffer(object) && jsvIsInt(nameVar)) {\n      // for array buffers, we actually create a NAME, and hand that back - then when we assign (or use SkipName) we pull out the correct data\n      child = jsvMakeIntoVariableName(jsvNewFromInteger(jsvGetInteger(nameVar)), object);\n      if (child) // turn into an 'array buffer name'\n        child->flags = (child->flags & ~JSV_VARTYPEMASK) | JSV_ARRAYBUFFERNAME;\n    } else if (jsvIsString(object) && jsvIsInt(nameVar)) {\n      JsVarInt idx = jsvGetInteger(nameVar);\n      if (idx>=0 && idx<(JsVarInt)jsvGetStringLength(object)) {\n        char ch = jsvGetCharInString(object, (size_t)idx);\n        child = jsvNewStringOfLength(1, &ch);\n      } else if (returnName)\n        child = jsvCreateNewChild(object, nameVar, 0); // just return *something* to show this is handled\n    } else {\n      // get the name as a string\n      char name[JSLEX_MAX_TOKEN_LENGTH];\n      jsvGetString(nameVar, name, JSLEX_MAX_TOKEN_LENGTH);\n      // try and find it in parents\n      child = jspGetNamedFieldInParents(object, name, returnName);\n\n      // If not found and is the prototype, create it\n      if (!child && jsvIsFunction(object) && jsvIsStringEqual(nameVar, JSPARSE_PROTOTYPE_VAR)) {\n        JsVar *value = jsvNewObject(); // prototype is supposed to be an object\n        child = jsvAddNamedChild(object, value, JSPARSE_PROTOTYPE_VAR);\n        jsvUnLock(value);\n      }\n    }\n  }\n\n  if (returnName) return child;\n  else return jsvSkipNameAndUnLock(child);\n}\n\n/// Call the named function on the object - whether it's built in, or predefined. Returns the return value of the function.\nJsVar *jspCallNamedFunction(JsVar *object, char* name, int argCount, JsVar **argPtr) {\n  JsVar *child = jspGetNamedField(object, name, false);\n  JsVar *r = 0;\n  if (jsvIsFunction(child))\n    r = jspeFunctionCall(child, 0, object, false, argCount, argPtr);\n  jsvUnLock(child);\n  return r;\n}\n\nNO_INLINE JsVar *jspeFactorMember(JsVar *a, JsVar **parentResult) {\n  /* The parent if we're executing a method call */\n  JsVar *parent = 0;\n\n  while (lex->tk=='.' || lex->tk=='[') {\n    if (lex->tk == '.') { // ------------------------------------- Record Access\n      JSP_ASSERT_MATCH('.');\n      if (jslIsIDOrReservedWord()) {\n        if (JSP_SHOULD_EXECUTE) {\n          // Note: name will go away when we parse something else!\n          const char *name = jslGetTokenValueAsString();\n\n          JsVar *aVar = jsvSkipNameWithParent(a,true,parent);\n          JsVar *child = 0;\n          if (aVar)\n            child = jspGetNamedField(aVar, name, true);\n          if (!child) {\n            if (!jsvIsUndefined(aVar)) {\n              // if no child found, create a pointer to where it could be\n              // as we don't want to allocate it until it's written\n              JsVar *nameVar = jslGetTokenValueAsVar();\n              child = jsvCreateNewChild(aVar, nameVar, 0);\n              jsvUnLock(nameVar);\n            } else {\n              // could have been a string...\n              jsExceptionHere(JSET_ERROR, \"Cannot read property '%s' of undefined\", name);\n            }\n          }\n          jsvUnLock(parent);\n          parent = aVar;\n          jsvUnLock(a);\n          a = child;\n        }\n        // skip over current token (we checked above that it was an ID or reserved word)\n        jslGetNextToken();\n      } else {\n        // incorrect token - force a match fail by asking for an ID\n        JSP_MATCH_WITH_RETURN(LEX_ID, a);\n      }\n    } else if (lex->tk == '[') { // ------------------------------------- Array Access\n      JsVar *index;\n      JSP_ASSERT_MATCH('[');\n      if (!jspCheckStackPosition()) return parent;\n      index = jsvSkipNameAndUnLock(jspeAssignmentExpression());\n      JSP_MATCH_WITH_CLEANUP_AND_RETURN(']', jsvUnLock2(parent, index);, a);\n      if (JSP_SHOULD_EXECUTE) {\n        index = jsvAsArrayIndexAndUnLock(index);\n        JsVar *aVar = jsvSkipNameWithParent(a,true,parent);\n        JsVar *child = 0;\n        if (aVar)\n          child = jspGetVarNamedField(aVar, index, true);\n\n        if (!child) {\n          if (jsvHasChildren(aVar)) {\n            // if no child found, create a pointer to where it could be\n            // as we don't want to allocate it until it's written\n            child = jsvCreateNewChild(aVar, index, 0);\n          } else {\n            jsExceptionHere(JSET_ERROR, \"Field or method %q does not already exist, and can't create it on %t\", index, aVar);\n          }\n        }\n        jsvUnLock(parent);\n        parent = jsvLockAgainSafe(aVar);\n        jsvUnLock(a);\n        a = child;\n        jsvUnLock(aVar);\n      }\n      jsvUnLock(index);\n    } else {\n      assert(0);\n    }\n  }\n\n  if (parentResult) *parentResult = parent;\n  else jsvUnLock(parent);\n  return a;\n}\n\nNO_INLINE JsVar *jspeConstruct(JsVar *func, JsVar *funcName, bool hasArgs) {\n  assert(JSP_SHOULD_EXECUTE);\n  if (!jsvIsFunction(func)) {\n    jsExceptionHere(JSET_ERROR, \"Constructor should be a function, but is %t\", func);\n    return 0;\n  }\n\n  JsVar *thisObj = jsvNewObject();\n  if (!thisObj) return 0; // out of memory\n  // Make sure the function has a 'prototype' var\n  JsVar *prototypeName = jsvFindChildFromString(func, JSPARSE_PROTOTYPE_VAR, true);\n  jspEnsureIsPrototype(func, prototypeName); // make sure it's an object\n  JsVar *prototypeVar = jsvSkipName(prototypeName);\n  jsvUnLock3(jsvAddNamedChild(thisObj, prototypeVar, JSPARSE_INHERITS_VAR), prototypeVar, prototypeName);\n\n  JsVar *a = jspeFunctionCall(func, funcName, thisObj, hasArgs, 0, 0);\n\n  /* FIXME: we should ignore return values that aren't objects (bug #848), but then we need\n   * to be aware of `new String()` and `new Uint8Array()`. Ideally we'd let through\n   * arrays/etc, and then String/etc should return 'boxed' values.\n   *\n   * But they don't return boxed values at the moment, so let's just\n   * pass the return value through. If you try and return a string from\n   * a function it's broken JS code anyway.\n   */\n  if (a) {\n    jsvUnLock(thisObj);\n    thisObj = a;\n  } else {\n    jsvUnLock(a);\n  }\n  return thisObj;\n}\n\nNO_INLINE JsVar *jspeFactorFunctionCall() {\n  /* The parent if we're executing a method call */\n  bool isConstructor = false;\n  if (lex->tk==LEX_R_NEW) {\n    JSP_ASSERT_MATCH(LEX_R_NEW);\n    isConstructor = true;\n\n    if (lex->tk==LEX_R_NEW) {\n      jsExceptionHere(JSET_ERROR, \"Nesting 'new' operators is unsupported\");\n      jspSetError(false);\n      return 0;\n    }\n  }\n\n  JsVar *parent = 0;\n#ifndef SAVE_ON_FLASH\n  bool wasSuper = lex->tk==LEX_R_SUPER;\n#endif\n  JsVar *a = jspeFactorMember(jspeFactor(), &parent);\n#ifndef SAVE_ON_FLASH\n  if (wasSuper) {\n    /* if this was 'super.something' then we need\n     * to overwrite the parent, because it'll be\n     * set to the prototype otherwise.\n     */\n    jsvUnLock(parent);\n    parent = jsvLockAgainSafe(execInfo.thisVar);\n  }\n#endif\n\n  while ((lex->tk=='(' || (isConstructor && JSP_SHOULD_EXECUTE)) && !jspIsInterrupted()) {\n    JsVar *funcName = a;\n    JsVar *func = jsvSkipName(funcName);\n\n    /* The constructor function doesn't change parsing, so if we're\n     * not executing, just short-cut it. */\n    if (isConstructor && JSP_SHOULD_EXECUTE) {\n      // If we have '(' parse an argument list, otherwise don't look for any args\n      bool parseArgs = lex->tk=='(';\n      a = jspeConstruct(func, funcName, parseArgs);\n      isConstructor = false; // don't treat subsequent brackets as constructors\n    } else\n      a = jspeFunctionCall(func, funcName, parent, true, 0, 0);\n\n    jsvUnLock3(funcName, func, parent);\n    parent=0;\n    a = jspeFactorMember(a, &parent);\n  }\n#ifndef SAVE_ON_FLASH\n  /* If we've got something that we care about the parent of (eg. a getter/setter)\n   * then we repackage it into a 'NewChild' name that references the parent before\n   * we leave. Note: You can't do this on everything because normally NewChild\n   * forces a new child to be blindly created. It works on Getters/Setters because\n   * we *always* run those rather than adding them.\n   */\n  if (parent && jsvIsBasicName(a) && !jsvIsNewChild(a)) {\n    JsVar *value = jsvLockSafe(jsvGetFirstChild(a));\n    if (jsvIsGetterOrSetter(value)) { // no need to do this for functions since we've just executed whatever we needed to\n      JsVar *nameVar = jsvCopyNameOnly(a,false,true);\n      JsVar *newChild = jsvCreateNewChild(parent, nameVar, value);\n      jsvUnLock2(nameVar, a);\n      a = newChild;\n    }\n    jsvUnLock(value);\n  }\n#endif\n  jsvUnLock(parent);\n  return a;\n}\n\n\nNO_INLINE JsVar *jspeFactorObject() {\n  if (JSP_SHOULD_EXECUTE) {\n    JsVar *contents = jsvNewObject();\n    if (!contents) { // out of memory\n      jspSetError(false);\n      return 0;\n    }\n    /* JSON-style object definition */\n    JSP_MATCH_WITH_RETURN('{', contents);\n    while (!JSP_SHOULDNT_PARSE && lex->tk != '}') {\n      JsVar *varName = 0;\n      // we only allow strings or IDs on the left hand side of an initialisation\n      if (jslIsIDOrReservedWord()) {\n        if (JSP_SHOULD_EXECUTE)\n          varName = jslGetTokenValueAsVar();\n        jslGetNextToken(); // skip over current token\n      } else if (\n          lex->tk==LEX_STR ||\n          lex->tk==LEX_FLOAT ||\n          lex->tk==LEX_INT ||\n          lex->tk==LEX_R_TRUE ||\n          lex->tk==LEX_R_FALSE ||\n          lex->tk==LEX_R_NULL ||\n          lex->tk==LEX_R_UNDEFINED) {\n        varName = jspeFactor();\n      } else {\n        JSP_MATCH_WITH_RETURN(LEX_ID, contents);\n      }\n#ifndef SAVE_ON_FLASH\n      if (lex->tk==LEX_ID && jsvIsString(varName)) {\n        bool isGetter = jsvIsStringEqual(varName, \"get\");\n        bool isSetter = jsvIsStringEqual(varName, \"set\");\n        if (isGetter || isSetter) {\n          jsvUnLock(varName);\n          varName = jslGetTokenValueAsVar();\n          JSP_ASSERT_MATCH(LEX_ID);\n          JsVar *method = jspeFunctionDefinition(false);\n          jsvAddGetterOrSetter(contents, varName, isGetter, method);\n          jsvUnLock(method);\n        }\n      } else\n#endif\n      {\n        JSP_MATCH_WITH_CLEANUP_AND_RETURN(':', jsvUnLock(varName), contents);\n        if (JSP_SHOULD_EXECUTE) {\n          varName = jsvAsArrayIndexAndUnLock(varName);\n          JsVar *contentsName = jsvFindChildFromVar(contents, varName, true);\n          if (contentsName) {\n            JsVar *value = jsvSkipNameAndUnLock(jspeAssignmentExpression()); // value can be 0 (could be undefined!)\n            jsvUnLock2(jsvSetValueOfName(contentsName, value), value);\n          }\n        }\n      }\n      jsvUnLock(varName);\n      // no need to clean here, as it will definitely be used\n      if (lex->tk != '}') JSP_MATCH_WITH_RETURN(',', contents);\n    }\n    JSP_MATCH_WITH_RETURN('}', contents);\n    return contents;\n  } else {\n    // Not executing so do fast skip\n    jspeBlock();\n    return 0;\n  }\n}\n\nNO_INLINE JsVar *jspeFactorArray() {\n  int idx = 0;\n  JsVar *contents = 0;\n  if (JSP_SHOULD_EXECUTE) {\n    contents = jsvNewEmptyArray();\n    if (!contents) { // out of memory\n      jspSetError(false);\n      return 0;\n    }\n  }\n  /* JSON-style array */\n  JSP_MATCH_WITH_RETURN('[', contents);\n  while (!JSP_SHOULDNT_PARSE && lex->tk != ']') {\n    if (JSP_SHOULD_EXECUTE) {\n      JsVar *aVar = 0;\n      JsVar *indexName = 0;\n      if (lex->tk != ',') { // #287 - [,] and [1,2,,4] are allowed\n        aVar = jsvSkipNameAndUnLock(jspeAssignmentExpression());\n        indexName = jsvMakeIntoVariableName(jsvNewFromInteger(idx),  aVar);\n      }\n      if (indexName) { // could be out of memory\n        jsvAddName(contents, indexName);\n        jsvUnLock(indexName);\n      }\n      jsvUnLock(aVar);\n    } else {\n      jsvUnLock(jspeAssignmentExpression());\n    }\n    // no need to clean here, as it will definitely be used\n    if (lex->tk != ']') JSP_MATCH_WITH_RETURN(',', contents);\n    idx++;\n  }\n  if (contents) jsvSetArrayLength(contents, idx, false);\n  JSP_MATCH_WITH_RETURN(']', contents);\n  return contents;\n}\n\nNO_INLINE void jspEnsureIsPrototype(JsVar *instanceOf, JsVar *prototypeName) {\n  if (!prototypeName) return;\n  JsVar *prototypeVar = jsvSkipName(prototypeName);\n  if (!(jsvIsObject(prototypeVar) || jsvIsFunction(prototypeVar))) {\n    if (!jsvIsUndefined(prototypeVar))\n      jsExceptionHere(JSET_TYPEERROR, \"Prototype should be an object, got %t\", prototypeVar);\n    jsvUnLock(prototypeVar);\n    prototypeVar = jsvNewObject(); // prototype is supposed to be an object\n    JsVar *lastName = jsvSkipToLastName(prototypeName);\n    jsvSetValueOfName(lastName, prototypeVar);\n    jsvUnLock(lastName);\n  }\n  JsVar *constructor = jsvFindChildFromString(prototypeVar, JSPARSE_CONSTRUCTOR_VAR, true);\n  if (constructor) jsvSetValueOfName(constructor, instanceOf);\n  jsvUnLock2(constructor, prototypeVar);\n}\n\nNO_INLINE JsVar *jspeFactorTypeOf() {\n  JSP_ASSERT_MATCH(LEX_R_TYPEOF);\n  JsVar *a = jspeUnaryExpression();\n  JsVar *result = 0;\n  if (JSP_SHOULD_EXECUTE) {\n    if (!jsvIsVariableDefined(a)) {\n      // so we don't get a ReferenceError when accessing an undefined var\n      result=jsvNewFromString(\"undefined\");\n    } else {\n      a = jsvSkipNameAndUnLock(a);\n      result=jsvNewFromString(jsvGetTypeOf(a));\n    }\n  }\n  jsvUnLock(a);\n  return result;\n}\n\nNO_INLINE JsVar *jspeFactorDelete() {\n  JSP_ASSERT_MATCH(LEX_R_DELETE);\n  JsVar *parent = 0;\n  JsVar *a = jspeFactorMember(jspeFactor(), &parent);\n  JsVar *result = 0;\n  if (JSP_SHOULD_EXECUTE) {\n    bool ok = false;\n    if (jsvIsName(a) && !jsvIsNewChild(a)) {\n      // if no parent, check in root?\n      if (!parent && jsvIsChild(execInfo.root, a))\n        parent = jsvLockAgain(execInfo.root);\n\n#ifdef DEBUG\n      if (jsvHasChildren(parent)) assert(jsvIsChild(parent, a));\n#endif\n      if (jsvHasChildren(parent) && jsvIsChild(parent, a)) {\n        // else remove properly.\n        /* we use jsvIsChild here just in case. delete probably isn't called\n        that often so it pays to be safe */\n        if (jsvIsArray(parent)) {\n          // For arrays, we must make sure we don't change the length\n          JsVarInt l = jsvGetArrayLength(parent);\n          jsvRemoveChild(parent, a);\n          jsvSetArrayLength(parent, l, false);\n        } else {\n          jsvRemoveChild(parent, a);\n        }\n        ok = true;\n      }\n    }\n\n    result = jsvNewFromBool(ok);\n  }\n  jsvUnLock2(a, parent);\n  return result;\n}\n\n#ifndef SAVE_ON_FLASH\nJsVar *jspeTemplateLiteral() {\n  JsVar *a = 0;\n  if (JSP_SHOULD_EXECUTE) {\n    JsVar *template = jslGetTokenValueAsVar();\n    a = jsvNewFromEmptyString();\n    if (a && template) {\n      JsvStringIterator it, dit;\n      jsvStringIteratorNew(&it, template, 0);\n      jsvStringIteratorNew(&dit, a, 0);\n      while (jsvStringIteratorHasChar(&it)) {\n        char ch = jsvStringIteratorGetCharAndNext(&it);\n        if (ch=='$') {\n          ch = jsvStringIteratorGetChar(&it);\n          if (ch=='{') {\n            // Now parse out the expression\n            jsvStringIteratorNext(&it);\n            int brackets = 1;\n            JsVar *expr = jsvNewFromEmptyString();\n            if (!expr) break;\n            JsvStringIterator eit;\n            jsvStringIteratorNew(&eit, expr, 0);\n            while (jsvStringIteratorHasChar(&it)) {\n              ch = jsvStringIteratorGetCharAndNext(&it);\n              if (ch=='{') brackets++;\n              if (ch=='}') {\n                brackets--;\n                if (!brackets) break;\n              }\n              jsvStringIteratorAppend(&eit, ch);\n            }\n            jsvStringIteratorFree(&eit);\n            JsVar *result = jspEvaluateExpressionVar(expr);\n            jsvUnLock(expr);\n            result = jsvAsStringAndUnLock(result);\n            jsvStringIteratorAppendString(&dit, result, 0, JSVAPPENDSTRINGVAR_MAXLENGTH);\n            jsvUnLock(result);\n          } else {\n            jsvStringIteratorAppend(&dit, '$');\n          }\n        } else {\n          jsvStringIteratorAppend(&dit, ch);\n        }\n      }\n      jsvStringIteratorFree(&it);\n      jsvStringIteratorFree(&dit);\n    }\n    jsvUnLock(template);\n  }\n  JSP_ASSERT_MATCH(LEX_TEMPLATE_LITERAL);\n  return a;\n}\n#endif\n\n\nNO_INLINE JsVar *jspeAddNamedFunctionParameter(JsVar *funcVar, JsVar *name) {\n  if (!funcVar) funcVar = jsvNewWithFlags(JSV_FUNCTION);\n  char buf[JSLEX_MAX_TOKEN_LENGTH+1];\n  buf[0] = '\\xFF';\n  size_t l = jsvGetString(name, &buf[1], JSLEX_MAX_TOKEN_LENGTH);\n  buf[l+1] = 0; // zero terminate since jsvGetString doesn't add one\n  JsVar *param = jsvAddNamedChild(funcVar, 0, buf);\n  jsvMakeFunctionParameter(param);\n  jsvUnLock(param);\n  return funcVar;\n}\n\n#ifndef SAVE_ON_FLASH\n// parse an arrow function\nNO_INLINE JsVar *jspeArrowFunction(JsVar *funcVar, JsVar *a) {\n  assert(!a || jsvIsName(a));\n  JSP_ASSERT_MATCH(LEX_ARROW_FUNCTION);\n  funcVar = jspeAddNamedFunctionParameter(funcVar, a);\n\n  bool expressionOnly = lex->tk!='{';\n  bool fnIncludesThis = jspeFunctionDefinitionInternal(funcVar, expressionOnly);\n  /* Arrow functions store the value of 'this' when they were defined. In order\n  to differentiate between normal functions we usually have to store 'this' even\n  if 'this' was just the global object.\n  Very few arrow functions actually use 'this' though - usually they are just used\n  as a shorthand, and so we end up wasting a whole extra var for every single\n  arrow function.\n  So... while parsing the function's body we check of the 'this' keyword is used.\n  If it isn't, we just don't include it.\n   */\n  if (fnIncludesThis)\n    jsvObjectSetChild(funcVar, JSPARSE_FUNCTION_THIS_NAME, execInfo.thisVar);\n\n  return funcVar;\n}\n\n// parse expressions with commas, maybe followed by an arrow function (bracket already matched)\nNO_INLINE JsVar *jspeExpressionOrArrowFunction() {\n  JsVar *a = 0;\n  JsVar *funcVar = 0;\n  bool allNames = true;\n  while (lex->tk!=')' && !JSP_SHOULDNT_PARSE) {\n    if (allNames && a) {\n      // we never get here if this isn't a name and a string\n      funcVar = jspeAddNamedFunctionParameter(funcVar, a);\n    }\n    jsvUnLock(a);\n    a = jspeAssignmentExpression();\n    /* if we're not executing, `a` will always be undefined so\n      don't do the check for allNames - just assume all is good. We'll\n      properly check when we execute. */\n    if (JSP_SHOULD_EXECUTE && !(jsvIsName(a) && jsvIsString(a))) allNames = false;\n    if (lex->tk!=')') JSP_MATCH_WITH_CLEANUP_AND_RETURN(',', jsvUnLock2(a,funcVar), 0);\n  }\n  JSP_MATCH_WITH_CLEANUP_AND_RETURN(')', jsvUnLock2(a,funcVar), 0);\n  // if all names inside brackets and an arrow is found, create a function\n  if (allNames && lex->tk==LEX_ARROW_FUNCTION) {\n    funcVar = jspeArrowFunction(funcVar, a);\n    jsvUnLock(a);\n    return funcVar;\n  } else {\n    jsvUnLock(funcVar);\n    return a;\n  }\n}\n\n/// Parse an ES6 class, expects LEX_R_CLASS already parsed\nNO_INLINE JsVar *jspeClassDefinition(bool parseNamedClass) {\n  JsVar *classFunction = 0;\n  JsVar *classPrototype = 0;\n  JsVar *classInternalName = 0;\n\n  bool actuallyCreateClass = JSP_SHOULD_EXECUTE;\n  if (actuallyCreateClass) {\n    classFunction = jsvNewWithFlags(JSV_FUNCTION);\n    JsVar *scopeVar = jspeiGetScopesAsVar();\n    if (scopeVar)\n      jsvUnLock2(jsvAddNamedChild(classFunction, scopeVar, JSPARSE_FUNCTION_SCOPE_NAME), scopeVar);\n  }\n\n  if (parseNamedClass && lex->tk==LEX_ID) {\n    if (classFunction)\n      classInternalName = jslGetTokenValueAsVar();\n    JSP_ASSERT_MATCH(LEX_ID);\n  }\n  if (classFunction) {\n    JsVar *prototypeName = jsvFindChildFromString(classFunction, JSPARSE_PROTOTYPE_VAR, true);\n    jspEnsureIsPrototype(classFunction, prototypeName); // make sure it's an object\n    classPrototype = jsvSkipName(prototypeName);\n    jsvUnLock(prototypeName);\n  }\n  if (lex->tk==LEX_R_EXTENDS) {\n    JSP_ASSERT_MATCH(LEX_R_EXTENDS);\n    JsVar *extendsFrom = actuallyCreateClass ? jsvSkipNameAndUnLock(jspGetNamedVariable(jslGetTokenValueAsString())) : 0;\n    JSP_MATCH_WITH_CLEANUP_AND_RETURN(LEX_ID,jsvUnLock4(extendsFrom,classFunction,classInternalName,classPrototype),0);\n    if (classPrototype) {\n      if (jsvIsFunction(extendsFrom)) {\n        JsVar *extendsFromProto = jsvObjectGetChild(extendsFrom, JSPARSE_PROTOTYPE_VAR, 0);\n        if (extendsFromProto) {\n          jsvObjectSetChild(classPrototype, JSPARSE_INHERITS_VAR, extendsFromProto);\n          // link in default constructor if ours isn't supplied\n          jsvObjectSetChildAndUnLock(classFunction, JSPARSE_FUNCTION_CODE_NAME, jsvNewFromString(\"if(this.__proto__.__proto__.constructor)this.__proto__.__proto__.constructor.apply(this,arguments)\"));\n          jsvUnLock(extendsFromProto);\n        }\n      } else\n        jsExceptionHere(JSET_SYNTAXERROR, \"'extends' argument should be a function, got %t\", extendsFrom);\n    }\n    jsvUnLock(extendsFrom);\n  }\n  JSP_MATCH_WITH_CLEANUP_AND_RETURN('{',jsvUnLock3(classFunction,classInternalName,classPrototype),0);\n\n  while ((lex->tk==LEX_ID || lex->tk==LEX_R_STATIC) && !jspIsInterrupted()) {\n    bool isStatic = lex->tk==LEX_R_STATIC;\n    if (isStatic) JSP_ASSERT_MATCH(LEX_R_STATIC);\n\n    JsVar *funcName = jslGetTokenValueAsVar();\n    JSP_MATCH_WITH_CLEANUP_AND_RETURN(LEX_ID,jsvUnLock4(funcName,classFunction,classInternalName,classPrototype),0);\n#ifndef SAVE_ON_FLASH\n    bool isGetter = false, isSetter = false;\n    if (lex->tk==LEX_ID) {\n      isGetter = jsvIsStringEqual(funcName, \"get\");\n      isSetter = jsvIsStringEqual(funcName, \"set\");\n      if (isGetter || isSetter) {\n        jsvUnLock(funcName);\n        funcName = jslGetTokenValueAsVar();\n        JSP_ASSERT_MATCH(LEX_ID);\n      }\n    }\n#endif\n    JsVar *method = jspeFunctionDefinition(false);\n    if (classFunction && classPrototype) {\n      JsVar *obj = isStatic ? classFunction : classPrototype;\n      if (jsvIsStringEqual(funcName, \"constructor\")) {\n        jswrap_function_replaceWith(classFunction, method);\n#ifndef SAVE_ON_FLASH\n      } else if (isGetter || isSetter) {\n        jsvAddGetterOrSetter(obj, funcName, isGetter, method);\n#endif\n      } else {\n        funcName = jsvMakeIntoVariableName(funcName, 0);\n        jsvSetValueOfName(funcName, method);\n        jsvAddName(obj, funcName);\n      }\n\n    }\n    jsvUnLock2(method,funcName);\n  }\n  jsvUnLock(classPrototype);\n  // If we had a name, add it to the end (or it gets confused with the constructor arguments)\n  if (classInternalName)\n    jsvObjectSetChildAndUnLock(classFunction, JSPARSE_FUNCTION_NAME_NAME, classInternalName);\n\n  JSP_MATCH_WITH_CLEANUP_AND_RETURN('}',jsvUnLock(classFunction),0);\n  return classFunction;\n}\n\n#endif\n\nNO_INLINE JsVar *jspeFactor() {\n  if (lex->tk==LEX_ID) {\n    JsVar *a = jspGetNamedVariable(jslGetTokenValueAsString());\n    JSP_ASSERT_MATCH(LEX_ID);\n#ifndef SAVE_ON_FLASH\n    if (lex->tk==LEX_TEMPLATE_LITERAL)\n      jsExceptionHere(JSET_SYNTAXERROR, \"Tagged template literals not supported\");\n    else if (lex->tk==LEX_ARROW_FUNCTION &&\n             (jsvIsName(a) || (a==0 && !JSP_SHOULD_EXECUTE))) {\n      // 'a' needs to be a name, *or* we're not executing so 0 gets returned anyway\n      JsVar *funcVar = jspeArrowFunction(0,a);\n      jsvUnLock(a);\n      a=funcVar;\n    }\n#endif\n    return a;\n  } else if (lex->tk==LEX_INT) {\n    JsVar *v = 0;\n    if (JSP_SHOULD_EXECUTE) {\n      v = jsvNewFromLongInteger(stringToInt(jslGetTokenValueAsString()));\n    }\n    JSP_ASSERT_MATCH(LEX_INT);\n    return v;\n  } else if (lex->tk==LEX_FLOAT) {\n    JsVar *v = 0;\n    if (JSP_SHOULD_EXECUTE) {\n      v = jsvNewFromFloat(stringToFloat(jslGetTokenValueAsString()));\n    }\n    JSP_ASSERT_MATCH(LEX_FLOAT);\n    return v;\n  } else if (lex->tk=='(') {\n    JSP_ASSERT_MATCH('(');\n    if (!jspCheckStackPosition()) return 0;\n#ifdef SAVE_ON_FLASH\n    // Just parse a normal expression (which can include commas)\n    JsVar *a = jspeExpression();\n    if (!JSP_SHOULDNT_PARSE) JSP_MATCH_WITH_RETURN(')',a);\n    return a;\n#else\n    return jspeExpressionOrArrowFunction();\n#endif\n\n  } else if (lex->tk==LEX_R_TRUE) {\n    JSP_ASSERT_MATCH(LEX_R_TRUE);\n    return JSP_SHOULD_EXECUTE ? jsvNewFromBool(true) : 0;\n  } else if (lex->tk==LEX_R_FALSE) {\n    JSP_ASSERT_MATCH(LEX_R_FALSE);\n    return JSP_SHOULD_EXECUTE ? jsvNewFromBool(false) : 0;\n  } else if (lex->tk==LEX_R_NULL) {\n    JSP_ASSERT_MATCH(LEX_R_NULL);\n    return JSP_SHOULD_EXECUTE ? jsvNewWithFlags(JSV_NULL) : 0;\n  } else if (lex->tk==LEX_R_UNDEFINED) {\n    JSP_ASSERT_MATCH(LEX_R_UNDEFINED);\n    return 0;\n  } else if (lex->tk==LEX_STR) {\n    JsVar *a = 0;\n    if (JSP_SHOULD_EXECUTE)\n      a = jslGetTokenValueAsVar();\n    JSP_ASSERT_MATCH(LEX_STR);\n    return a;\n#ifndef SAVE_ON_FLASH\n  } else if (lex->tk==LEX_TEMPLATE_LITERAL) {\n    return jspeTemplateLiteral();\n#endif\n  } else if (lex->tk==LEX_REGEX) {\n    JsVar *a = 0;\n#ifdef SAVE_ON_FLASH\n    jsExceptionHere(JSET_SYNTAXERROR, \"RegEx are not supported in this version of Espruino\\n\");\n#else\n    JsVar *regex = jslGetTokenValueAsVar();\n    size_t regexEnd = 0, regexLen = 0;\n    JsvStringIterator it;\n    jsvStringIteratorNew(&it, regex, 0);\n    while (jsvStringIteratorHasChar(&it)) {\n      regexLen++;\n      if (jsvStringIteratorGetCharAndNext(&it)=='/')\n        regexEnd = regexLen;\n    }\n    jsvStringIteratorFree(&it);\n    JsVar *flags = 0;\n    if (regexEnd < regexLen)\n      flags = jsvNewFromStringVar(regex, regexEnd, JSVAPPENDSTRINGVAR_MAXLENGTH);\n    JsVar *regexSource = jsvNewFromStringVar(regex, 1, regexEnd-2);\n    a = jswrap_regexp_constructor(regexSource, flags);\n    jsvUnLock3(regex, flags, regexSource);\n#endif\n    JSP_ASSERT_MATCH(LEX_REGEX);\n    return a;\n  } else if (lex->tk=='{') {\n    if (!jspCheckStackPosition()) return 0;\n    return jspeFactorObject();\n  } else if (lex->tk=='[') {\n    if (!jspCheckStackPosition()) return 0;\n    return jspeFactorArray();\n  } else if (lex->tk==LEX_R_FUNCTION) {\n    if (!jspCheckStackPosition()) return 0;\n    JSP_ASSERT_MATCH(LEX_R_FUNCTION);\n    return jspeFunctionDefinition(true);\n#ifndef SAVE_ON_FLASH\n  } else if (lex->tk==LEX_R_CLASS) {\n    if (!jspCheckStackPosition()) return 0;\n    JSP_ASSERT_MATCH(LEX_R_CLASS);\n    return jspeClassDefinition(true);\n  } else if (lex->tk==LEX_R_SUPER) {\n    JSP_ASSERT_MATCH(LEX_R_SUPER);\n    /* This is kind of nasty, since super appears to do\n      three different things.\n\n      * In the constructor it references the extended class's constructor\n      * in a method it references the constructor's prototype.\n      * in a static method it references the extended class's constructor (but this is different)\n     */\n\n    if (jsvIsObject(execInfo.thisVar)) {\n      // 'this' is an object - must be calling a normal method\n      JsVar *proto1 = jsvObjectGetChild(execInfo.thisVar, JSPARSE_INHERITS_VAR, 0); // if we're in a method, get __proto__ first\n      JsVar *proto2 = jsvIsObject(proto1) ? jsvObjectGetChild(proto1, JSPARSE_INHERITS_VAR, 0) : 0; // still in method, get __proto__.__proto__\n      jsvUnLock(proto1);\n      if (!proto2) {\n        jsExceptionHere(JSET_SYNTAXERROR, \"Calling 'super' outside of class\");\n        return 0;\n      }\n      // If we're doing super() we want the constructor\n      if (lex->tk=='(') {\n        JsVar *constr = jsvObjectGetChild(proto2, JSPARSE_CONSTRUCTOR_VAR, 0);\n        jsvUnLock(proto2);\n        return constr;\n      }\n      // But if we're doing something else - eg 'super.' or 'super[' then it needs to reference the prototype\n      return proto2;\n    } else if (jsvIsFunction(execInfo.thisVar)) {\n      // 'this' is a function - must be calling a static method\n      JsVar *proto1 = jsvObjectGetChild(execInfo.thisVar, JSPARSE_PROTOTYPE_VAR, 0);\n      JsVar *proto2 = jsvIsObject(proto1) ? jsvObjectGetChild(proto1, JSPARSE_INHERITS_VAR, 0) : 0;\n      jsvUnLock(proto1);\n      if (!proto2) {\n        jsExceptionHere(JSET_SYNTAXERROR, \"Calling 'super' outside of class\");\n        return 0;\n      }\n      JsVar *constr = jsvObjectGetChild(proto2, JSPARSE_CONSTRUCTOR_VAR, 0);\n      jsvUnLock(proto2);\n      return constr;\n    }\n    jsExceptionHere(JSET_SYNTAXERROR, \"Calling 'super' outside of class\");\n    return 0;\n#endif\n  } else if (lex->tk==LEX_R_THIS) {\n    JSP_ASSERT_MATCH(LEX_R_THIS);\n    return jsvLockAgain( execInfo.thisVar ? execInfo.thisVar : execInfo.root );\n  } else if (lex->tk==LEX_R_DELETE) {\n    if (!jspCheckStackPosition()) return 0;\n    return jspeFactorDelete();\n  } else if (lex->tk==LEX_R_TYPEOF) {\n    if (!jspCheckStackPosition()) return 0;\n    return jspeFactorTypeOf();\n  } else if (lex->tk==LEX_R_VOID) {\n    if (!jspCheckStackPosition()) return 0;\n    JSP_ASSERT_MATCH(LEX_R_VOID);\n    jsvUnLock(jspeUnaryExpression());\n    return 0;\n  }\n  JSP_MATCH(LEX_EOF);\n  jsExceptionHere(JSET_SYNTAXERROR, \"Unexpected end of Input\\n\");\n  return 0;\n}\n\nNO_INLINE JsVar *__jspePostfixExpression(JsVar *a) {\n  while (lex->tk==LEX_PLUSPLUS || lex->tk==LEX_MINUSMINUS) {\n    int op = lex->tk;\n    JSP_ASSERT_MATCH(op);\n    if (JSP_SHOULD_EXECUTE) {\n      JsVar *one = jsvNewFromInteger(1);\n      JsVar *oldValue = jsvAsNumberAndUnLock(jsvSkipName(a)); // keep the old value (but convert to number)\n      JsVar *res = jsvMathsOpSkipNames(oldValue, one, op==LEX_PLUSPLUS ? '+' : '-');\n      jsvUnLock(one);\n\n      // in-place add/subtract\n      jsvReplaceWith(a, res);\n      jsvUnLock(res);\n      // but then use the old value\n      jsvUnLock(a);\n      a = oldValue;\n    }\n  }\n  return a;\n}\n\nNO_INLINE JsVar *jspePostfixExpression() {\n  JsVar *a;\n  // TODO: should be in jspeUnaryExpression\n  if (lex->tk==LEX_PLUSPLUS || lex->tk==LEX_MINUSMINUS) {\n    int op = lex->tk;\n    JSP_ASSERT_MATCH(op);\n    a = jspePostfixExpression();\n    if (JSP_SHOULD_EXECUTE) {\n      JsVar *one = jsvNewFromInteger(1);\n      JsVar *res = jsvMathsOpSkipNames(a, one, op==LEX_PLUSPLUS ? '+' : '-');\n      jsvUnLock(one);\n      // in-place add/subtract\n      jsvReplaceWith(a, res);\n      jsvUnLock(res);\n    }\n  } else\n    a = jspeFactorFunctionCall();\n  return __jspePostfixExpression(a);\n}\n\nNO_INLINE JsVar *jspeUnaryExpression() {\n  if (lex->tk=='!' || lex->tk=='~' || lex->tk=='-' || lex->tk=='+') {\n    short tk = lex->tk;\n    JSP_ASSERT_MATCH(tk);\n    if (!JSP_SHOULD_EXECUTE) {\n      return jspeUnaryExpression();\n    }\n    if (tk=='!') { // logical not\n      return jsvNewFromBool(!jsvGetBoolAndUnLock(jsvSkipNameAndUnLock(jspeUnaryExpression())));\n    } else if (tk=='~') { // bitwise not\n      return jsvNewFromInteger(~jsvGetIntegerAndUnLock(jsvSkipNameAndUnLock(jspeUnaryExpression())));\n    } else if (tk=='-') { // unary minus\n      return jsvNegateAndUnLock(jspeUnaryExpression()); // names already skipped\n    }  else if (tk=='+') { // unary plus (convert to number)\n      JsVar *v = jsvSkipNameAndUnLock(jspeUnaryExpression());\n      JsVar *r = jsvAsNumber(v); // names already skipped\n      jsvUnLock(v);\n      return r;\n    }\n    assert(0);\n    return 0;\n  } else\n    return jspePostfixExpression();\n}\n\n\n// Get the precedence of a BinaryExpression - or return 0 if not one\nunsigned int jspeGetBinaryExpressionPrecedence(int op) {\n  switch (op) {\n  case LEX_OROR: return 1; break;\n  case LEX_ANDAND: return 2; break;\n  case '|' : return 3; break;\n  case '^' : return 4; break;\n  case '&' : return 5; break;\n  case LEX_EQUAL:\n  case LEX_NEQUAL:\n  case LEX_TYPEEQUAL:\n  case LEX_NTYPEEQUAL: return 6;\n  case LEX_LEQUAL:\n  case LEX_GEQUAL:\n  case '<':\n  case '>':\n  case LEX_R_INSTANCEOF: return 7;\n  case LEX_R_IN: return (execInfo.execute&EXEC_FOR_INIT)?0:7;\n  case LEX_LSHIFT:\n  case LEX_RSHIFT:\n  case LEX_RSHIFTUNSIGNED: return 8;\n  case '+':\n  case '-': return 9;\n  case '*':\n  case '/':\n  case '%': return 10;\n  default: return 0;\n  }\n}\n\nNO_INLINE JsVar *__jspeBinaryExpression(JsVar *a, unsigned int lastPrecedence) {\n  /* This one's a bit strange. Basically all the ops have their own precedence, it's not\n   * like & and | share the same precedence. We don't want to recurse for each one,\n   * so instead we do this.\n   *\n   * We deal with an expression in recursion ONLY if it's of higher precedence\n   * than the current one, otherwise we stick in the while loop.\n   */\n  unsigned int precedence = jspeGetBinaryExpressionPrecedence(lex->tk);\n  while (precedence && precedence>lastPrecedence) {\n    int op = lex->tk;\n    JSP_ASSERT_MATCH(op);\n\n    // if we have short-circuit ops, then if we know the outcome\n    // we don't bother to execute the other op. Even if not\n    // we need to tell mathsOp it's an & or |\n    if (op==LEX_ANDAND || op==LEX_OROR) {\n      bool aValue = jsvGetBoolAndUnLock(jsvSkipName(a));\n      if ((!aValue && op==LEX_ANDAND) ||\n          (aValue && op==LEX_OROR)) {\n        // use first argument (A)\n        JSP_SAVE_EXECUTE();\n        jspSetNoExecute();\n        jsvUnLock(__jspeBinaryExpression(jspeUnaryExpression(),precedence));\n        JSP_RESTORE_EXECUTE();\n      } else {\n        // use second argument (B)\n        jsvUnLock(a);\n        a = __jspeBinaryExpression(jspeUnaryExpression(),precedence);\n      }\n    } else { // else it's a more 'normal' logical expression - just use Maths\n      JsVar *b = __jspeBinaryExpression(jspeUnaryExpression(),precedence);\n      if (JSP_SHOULD_EXECUTE) {\n        if (op==LEX_R_IN) {\n          JsVar *av = jsvSkipName(a); // needle\n          JsVar *bv = jsvSkipName(b); // haystack\n          if (jsvHasChildren(bv)) { // search keys, NOT values\n            av = jsvAsArrayIndexAndUnLock(av);\n            JsVar *varFound = jspGetVarNamedField( bv, av, true);\n            jsvUnLock2(a,varFound);\n            a = jsvNewFromBool(varFound!=0);\n          } else { // else maybe it's a fake object...\n            const JswSymList *syms = jswGetSymbolListForObjectProto(bv);\n            if (syms) {\n              JsVar *varFound = 0;\n              char nameBuf[JSLEX_MAX_TOKEN_LENGTH];\n              if (jsvGetString(av, nameBuf, sizeof(nameBuf)) < sizeof(nameBuf))\n                varFound = jswBinarySearch(syms, bv, nameBuf);\n              bool found = varFound!=0;\n              jsvUnLock2(a, varFound);\n              if (!found && jsvIsArrayBuffer(bv)) {\n                JsVarFloat f = jsvGetFloat(av); // if not a number this will be NaN, f==floor(f) fails\n                if (f==floor(f) && f>=0 && f<jsvGetArrayBufferLength(bv))\n                  found = true;\n              }\n              a = jsvNewFromBool(found);\n            } else { // not built-in, just assume we can't do it\n              jsExceptionHere(JSET_ERROR, \"Cannot use 'in' operator to search a %t\", bv);\n              jsvUnLock(a);\n              a = 0;\n            }\n          }\n          jsvUnLock2(av, bv);\n        } else if (op==LEX_R_INSTANCEOF) {\n          bool inst = false;\n          JsVar *av = jsvSkipName(a);\n          JsVar *bv = jsvSkipName(b);\n          if (!jsvIsFunction(bv)) {\n            jsExceptionHere(JSET_ERROR, \"Expecting a function on RHS in instanceof check, got %t\", bv);\n          } else {\n            if (jsvIsObject(av) || jsvIsFunction(av)) {\n              JsVar *bproto = jspGetNamedField(bv, JSPARSE_PROTOTYPE_VAR, false);\n              JsVar *proto = jsvObjectGetChild(av, JSPARSE_INHERITS_VAR, 0);\n              while (proto) {\n                if (proto == bproto) inst=true;\n                // search prototype chain\n                JsVar *childProto = jsvObjectGetChild(proto, JSPARSE_INHERITS_VAR, 0);\n                jsvUnLock(proto);\n                proto = childProto;\n              }\n              if (jspIsConstructor(bv, \"Object\")) inst = true;\n              jsvUnLock(bproto);\n            }\n            if (!inst) {\n              const char *name = jswGetBasicObjectName(av);\n              if (name) {\n                inst = jspIsConstructor(bv, name);\n              }\n              // Hack for built-ins that should also be instances of Object\n              if (!inst && (jsvIsArray(av) || jsvIsArrayBuffer(av)) &&\n                  jspIsConstructor(bv, \"Object\"))\n                inst = true;\n            }\n          }\n          jsvUnLock3(av, bv, a);\n          a = jsvNewFromBool(inst);\n        } else {  // --------------------------------------------- NORMAL\n          JsVar *res = jsvMathsOpSkipNames(a, b, op);\n          jsvUnLock(a); a = res;\n        }\n      }\n      jsvUnLock(b);\n    }\n    precedence = jspeGetBinaryExpressionPrecedence(lex->tk);\n  }\n  return a;\n}\n\nJsVar *jspeBinaryExpression() {\n  return __jspeBinaryExpression(jspeUnaryExpression(),0);\n}\n\nNO_INLINE JsVar *__jspeConditionalExpression(JsVar *lhs) {\n  if (lex->tk=='?') {\n    JSP_ASSERT_MATCH('?');\n    if (!JSP_SHOULD_EXECUTE) {\n      // just let lhs pass through\n      jsvUnLock(jspeAssignmentExpression());\n      JSP_MATCH(':');\n      jsvUnLock(jspeAssignmentExpression());\n    } else {\n      bool first = jsvGetBoolAndUnLock(jsvSkipName(lhs));\n      jsvUnLock(lhs);\n      if (first) {\n        lhs = jspeAssignmentExpression();\n        JSP_MATCH(':');\n        JSP_SAVE_EXECUTE();\n        jspSetNoExecute();\n        jsvUnLock(jspeAssignmentExpression());\n        JSP_RESTORE_EXECUTE();\n      } else {\n        JSP_SAVE_EXECUTE();\n        jspSetNoExecute();\n        jsvUnLock(jspeAssignmentExpression());\n        JSP_RESTORE_EXECUTE();\n        JSP_MATCH(':');\n        lhs = jspeAssignmentExpression();\n      }\n    }\n  }\n\n  return lhs;\n}\n\nJsVar *jspeConditionalExpression() {\n  return __jspeConditionalExpression(jspeBinaryExpression());\n}\n\nNO_INLINE JsVar *__jspeAssignmentExpression(JsVar *lhs) {\n  if (lex->tk=='=' || lex->tk==LEX_PLUSEQUAL || lex->tk==LEX_MINUSEQUAL ||\n      lex->tk==LEX_MULEQUAL || lex->tk==LEX_DIVEQUAL || lex->tk==LEX_MODEQUAL ||\n      lex->tk==LEX_ANDEQUAL || lex->tk==LEX_OREQUAL ||\n      lex->tk==LEX_XOREQUAL || lex->tk==LEX_RSHIFTEQUAL ||\n      lex->tk==LEX_LSHIFTEQUAL || lex->tk==LEX_RSHIFTUNSIGNEDEQUAL) {\n    JsVar *rhs;\n\n    int op = lex->tk;\n    JSP_ASSERT_MATCH(op);\n    rhs = jspeAssignmentExpression();\n    rhs = jsvSkipNameAndUnLock(rhs); // ensure we get rid of any references on the RHS\n\n    if (JSP_SHOULD_EXECUTE && lhs) {\n      if (op=='=') {\n        jsvReplaceWithOrAddToRoot(lhs, rhs);\n      } else {\n        if (op==LEX_PLUSEQUAL) op='+';\n        else if (op==LEX_MINUSEQUAL) op='-';\n        else if (op==LEX_MULEQUAL) op='*';\n        else if (op==LEX_DIVEQUAL) op='/';\n        else if (op==LEX_MODEQUAL) op='%';\n        else if (op==LEX_ANDEQUAL) op='&';\n        else if (op==LEX_OREQUAL) op='|';\n        else if (op==LEX_XOREQUAL) op='^';\n        else if (op==LEX_RSHIFTEQUAL) op=LEX_RSHIFT;\n        else if (op==LEX_LSHIFTEQUAL) op=LEX_LSHIFT;\n        else if (op==LEX_RSHIFTUNSIGNEDEQUAL) op=LEX_RSHIFTUNSIGNED;\n        if (op=='+' && jsvIsName(lhs)) {\n          JsVar *currentValue = jsvSkipName(lhs);\n          if (jsvIsBasicString(currentValue) && jsvGetRefs(currentValue)==1 && rhs!=currentValue) {\n            /* A special case for string += where this is the only use of the string\n             * and we're not appending to ourselves. In this case we can do a\n             * simple append (rather than clone + append)*/\n            JsVar *str = jsvAsString(rhs);\n            jsvAppendStringVarComplete(currentValue, str);\n            jsvUnLock(str);\n            op = 0;\n          }\n          jsvUnLock(currentValue);\n        }\n        if (op) {\n          /* Fallback which does a proper add */\n          JsVar *res = jsvMathsOpSkipNames(lhs,rhs,op);\n          jsvReplaceWith(lhs, res);\n          jsvUnLock(res);\n        }\n      }\n    }\n    jsvUnLock(rhs);\n  }\n  return lhs;\n}\n\n\nJsVar *jspeAssignmentExpression() {\n  return __jspeAssignmentExpression(jspeConditionalExpression());\n}\n\n// ',' is allowed to add multiple expressions, this is not allowed in jspeAssignmentExpression\nNO_INLINE JsVar *jspeExpression() {\n  while (!JSP_SHOULDNT_PARSE) {\n    JsVar *a = jspeAssignmentExpression();\n    if (lex->tk!=',') return a;\n    // if we get a comma, we just forget this data and parse the next bit...\n    jsvCheckReferenceError(a);\n    jsvUnLock(a);\n    JSP_ASSERT_MATCH(',');\n  }\n  return 0;\n}\n\n/** Parse a block `{ ... }` */\nNO_INLINE void jspeSkipBlock() {\n  // fast skip of blocks\n  int brackets = 1;\n  while (lex->tk && brackets) {\n    if (lex->tk == '{') brackets++;\n    else if (lex->tk == '}') {\n      brackets--;\n      if (!brackets) return;\n    }\n    JSP_ASSERT_MATCH(lex->tk);\n  }\n}\n\n/** Parse a block `{ ... }` but assume brackets are already parsed */\nNO_INLINE void jspeBlockNoBrackets() {\n  if (JSP_SHOULD_EXECUTE) {\n    while (lex->tk && lex->tk!='}') {\n      JsVar *a = jspeStatement();\n      jsvCheckReferenceError(a);\n      jsvUnLock(a);\n      if (JSP_HAS_ERROR) {\n        if (lex && !(execInfo.execute&EXEC_ERROR_LINE_REPORTED)) {\n          execInfo.execute = (JsExecFlags)(execInfo.execute | EXEC_ERROR_LINE_REPORTED);\n          JsVar *stackTrace = jsvObjectGetChild(execInfo.hiddenRoot, JSPARSE_STACKTRACE_VAR, JSV_STRING_0);\n          if (stackTrace) {\n            jsvAppendPrintf(stackTrace, \"at \");\n            jspAppendStackTrace(stackTrace);\n            jsvUnLock(stackTrace);\n          }\n        }\n      }\n      if (JSP_SHOULDNT_PARSE)\n        return;\n      if (!JSP_SHOULD_EXECUTE) {\n        jspeSkipBlock();\n        return;\n      }\n    }\n  } else {\n    jspeSkipBlock();\n  }\n  return;\n}\n\n/** Parse a block `{ ... }` */\nNO_INLINE void jspeBlock() {\n  JSP_MATCH_WITH_RETURN('{',);\n  jspeBlockNoBrackets();\n  if (!JSP_SHOULDNT_PARSE) JSP_MATCH_WITH_RETURN('}',);\n  return;\n}\n\nNO_INLINE JsVar *jspeBlockOrStatement() {\n  if (lex->tk=='{') {\n    jspeBlock();\n    return 0;\n  } else {\n    JsVar *v = jspeStatement();\n    if (lex->tk==';') JSP_ASSERT_MATCH(';');\n    return v;\n  }\n}\n\n/** Parse using current lexer until we hit the end of\n * input or there was some problem. */\nNO_INLINE JsVar *jspParse() {\n  JsVar *v = 0;\n  while (!JSP_SHOULDNT_PARSE && lex->tk != LEX_EOF) {\n    jsvUnLock(v);\n    v = jspeBlockOrStatement();\n    jsvCheckReferenceError(v);\n  }\n  return v;\n}\n\nNO_INLINE JsVar *jspeStatementVar() {\n  JsVar *lastDefined = 0;\n  /* variable creation. TODO - we need a better way of parsing the left\n   * hand side. Maybe just have a flag called can_create_var that we\n   * set and then we parse as if we're doing a normal equals.*/\n  assert(lex->tk==LEX_R_VAR || lex->tk==LEX_R_LET || lex->tk==LEX_R_CONST);\n  jslGetNextToken();\n  ///TODO: Correctly implement CONST and LET - we just treat them like 'var' at the moment\n  bool hasComma = true; // for first time in loop\n  while (hasComma && lex->tk == LEX_ID && !jspIsInterrupted()) {\n    JsVar *a = 0;\n    if (JSP_SHOULD_EXECUTE) {\n      a = jspeiFindOnTop(jslGetTokenValueAsString(), true);\n      if (!a) { // out of memory\n        jspSetError(false);\n        return lastDefined;\n      }\n    }\n    JSP_MATCH_WITH_CLEANUP_AND_RETURN(LEX_ID, jsvUnLock(a), lastDefined);\n    // sort out initialiser\n    if (lex->tk == '=') {\n      JsVar *var;\n      JSP_MATCH_WITH_CLEANUP_AND_RETURN('=', jsvUnLock(a), lastDefined);\n      var = jsvSkipNameAndUnLock(jspeAssignmentExpression());\n      if (JSP_SHOULD_EXECUTE)\n        jsvReplaceWith(a, var);\n      jsvUnLock(var);\n    }\n    jsvUnLock(lastDefined);\n    lastDefined = a;\n    hasComma = lex->tk == ',';\n    if (hasComma) JSP_MATCH_WITH_RETURN(',', lastDefined);\n  }\n  return lastDefined;\n}\n\nNO_INLINE JsVar *jspeStatementIf() {\n  bool cond;\n  JsVar *var, *result = 0;\n  JSP_ASSERT_MATCH(LEX_R_IF);\n  JSP_MATCH('(');\n  var = jspeExpression();\n  if (JSP_SHOULDNT_PARSE) return var;\n  JSP_MATCH(')');\n  cond = JSP_SHOULD_EXECUTE && jsvGetBoolAndUnLock(jsvSkipName(var));\n  jsvUnLock(var);\n\n  JSP_SAVE_EXECUTE();\n  if (!cond) jspSetNoExecute();\n  JsExecFlags hasError = 0;\n  JsVar *a = jspeBlockOrStatement();\n  hasError |= execInfo.execute&EXEC_ERROR_MASK;\n  if (!cond) {\n    jsvUnLock(a);\n    JSP_RESTORE_EXECUTE();\n    execInfo.execute |= hasError;\n  } else {\n    result = a;\n  }\n  if (lex->tk==LEX_R_ELSE) {\n    JSP_ASSERT_MATCH(LEX_R_ELSE);\n    JSP_SAVE_EXECUTE();\n    if (cond) jspSetNoExecute();\n    JsVar *a = jspeBlockOrStatement();\n    hasError |= execInfo.execute&EXEC_ERROR_MASK;\n    if (cond) {\n      jsvUnLock(a);\n      JSP_RESTORE_EXECUTE();\n      execInfo.execute |= hasError;\n    } else {\n      result = a;\n    }\n  }\n  return result;\n}\n\nNO_INLINE JsVar *jspeStatementSwitch() {\n  JSP_ASSERT_MATCH(LEX_R_SWITCH);\n  JSP_MATCH('(');\n  JsVar *switchOn = jspeExpression();\n  JSP_SAVE_EXECUTE();\n  bool execute = JSP_SHOULD_EXECUTE;\n  JSP_MATCH_WITH_CLEANUP_AND_RETURN(')', jsvUnLock(switchOn), 0);\n  // shortcut if not executing...\n  if (!execute) { jsvUnLock(switchOn); jspeBlock(); return 0; }\n  JSP_MATCH_WITH_CLEANUP_AND_RETURN('{', jsvUnLock(switchOn), 0);\n\n  bool executeDefault = true;\n  if (execute) execInfo.execute=EXEC_NO|EXEC_IN_SWITCH;\n  while (lex->tk==LEX_R_CASE) {\n    JSP_MATCH_WITH_CLEANUP_AND_RETURN(LEX_R_CASE, jsvUnLock(switchOn), 0);\n    JsExecFlags oldFlags = execInfo.execute;\n    if (execute) execInfo.execute=EXEC_YES|EXEC_IN_SWITCH;\n    JsVar *test = jspeAssignmentExpression();\n    execInfo.execute = oldFlags|EXEC_IN_SWITCH;;\n    JSP_MATCH_WITH_CLEANUP_AND_RETURN(':', jsvUnLock2(switchOn, test), 0);\n    bool cond = false;\n    if (execute)\n      cond = jsvGetBoolAndUnLock(jsvMathsOpSkipNames(switchOn, test, LEX_TYPEEQUAL));\n    if (cond) executeDefault = false;\n    jsvUnLock(test);\n    if (cond && (execInfo.execute&EXEC_RUN_MASK)==EXEC_NO)\n      execInfo.execute=EXEC_YES|EXEC_IN_SWITCH;\n    while (!JSP_SHOULDNT_PARSE && lex->tk!=LEX_EOF && lex->tk!=LEX_R_CASE && lex->tk!=LEX_R_DEFAULT && lex->tk!='}')\n      jsvUnLock(jspeBlockOrStatement());\n    oldExecute |= execInfo.execute & (EXEC_ERROR_MASK|EXEC_RETURN); // copy across any errors/exceptions/returns\n  }\n  jsvUnLock(switchOn);\n  if (execute && (execInfo.execute&EXEC_RUN_MASK)==EXEC_BREAK) {\n    execInfo.execute=EXEC_YES|EXEC_IN_SWITCH;\n  } else {\n    executeDefault = true;\n  }\n  JSP_RESTORE_EXECUTE();\n\n  if (lex->tk==LEX_R_DEFAULT) {\n    JSP_ASSERT_MATCH(LEX_R_DEFAULT);\n    JSP_MATCH(':');\n    JSP_SAVE_EXECUTE();\n    if (!executeDefault) jspSetNoExecute();\n    else execInfo.execute |= EXEC_IN_SWITCH;\n    while (!JSP_SHOULDNT_PARSE && lex->tk!=LEX_EOF && lex->tk!='}' && lex->tk!=LEX_R_CASE)\n      jsvUnLock(jspeBlockOrStatement());\n    oldExecute |= execInfo.execute & (EXEC_ERROR_MASK|EXEC_RETURN); // copy across any errors/exceptions/returns\n    execInfo.execute = execInfo.execute & (JsExecFlags)~EXEC_BREAK;\n    JSP_RESTORE_EXECUTE();\n  }\n  if (lex->tk==LEX_R_CASE) {\n    jsExceptionHere(JSET_SYNTAXERROR, \"Espruino doesn't support CASE after DEFAULT\");\n    return 0;\n  }\n  JSP_MATCH('}');\n  return 0;\n}\n\n// Check whether we received a break/continue while parsing previously. Return true if we had a 'break;\nstatic NO_INLINE bool jspeCheckBreakContinue() {\n  if (execInfo.execute & EXEC_CONTINUE)\n    execInfo.execute = (execInfo.execute & ~EXEC_RUN_MASK) | EXEC_YES;\n  else if (execInfo.execute & EXEC_BREAK) {\n    execInfo.execute = (execInfo.execute & ~EXEC_RUN_MASK) | EXEC_YES;\n    return true;\n  }\n  return false;\n}\n\nNO_INLINE JsVar *jspeStatementDoOrWhile(bool isWhile) {\n  JsVar *cond;\n  bool loopCond = true; // true for do...while loops\n  bool hasHadBreak = false;\n  JslCharPos whileCondStart;\n  // We do repetition by pulling out the string representing our statement\n  // there's definitely some opportunity for optimisation here\n\n  bool wasInLoop = (execInfo.execute&EXEC_IN_LOOP)!=0;\n  JslCharPos whileBodyStart;\n  if (isWhile) { // while loop\n    JSP_ASSERT_MATCH(LEX_R_WHILE);\n    jslCharPosFromLex(&whileCondStart);\n    JSP_MATCH_WITH_CLEANUP_AND_RETURN('(',jslCharPosFree(&whileCondStart);,0);\n    cond = jspeExpression();\n    loopCond = JSP_SHOULD_EXECUTE && jsvGetBoolAndUnLock(jsvSkipName(cond));\n    jsvUnLock(cond);\n    jslCharPosFromLex(&whileBodyStart);\n    JSP_MATCH_WITH_CLEANUP_AND_RETURN(')',jslCharPosFree(&whileBodyStart);jslCharPosFree(&whileCondStart);,0);\n  } else {\n    jslCharPosFromLex(&whileBodyStart);\n    JSP_MATCH_WITH_CLEANUP_AND_RETURN(LEX_R_DO, jslCharPosFree(&whileBodyStart);,0);\n  }\n  JSP_SAVE_EXECUTE();\n  // actually try and execute first bit of while loop (we'll do the rest in the actual loop later)\n  if (!loopCond) jspSetNoExecute();\n  execInfo.execute |= EXEC_IN_LOOP;\n  jsvUnLock(jspeBlockOrStatement());\n  if (!wasInLoop) execInfo.execute &= (JsExecFlags)~EXEC_IN_LOOP;\n\n  hasHadBreak |= jspeCheckBreakContinue();\n  if (!loopCond) JSP_RESTORE_EXECUTE();\n\n  if (!isWhile) { // do..while loop\n    JSP_MATCH_WITH_CLEANUP_AND_RETURN(LEX_R_WHILE,jslCharPosFree(&whileBodyStart);,0);\n    jslCharPosFromLex(&whileCondStart);\n    JSP_MATCH_WITH_CLEANUP_AND_RETURN('(',jslCharPosFree(&whileBodyStart);jslCharPosFree(&whileCondStart);,0);\n    cond = jspeExpression();\n    loopCond = JSP_SHOULD_EXECUTE && jsvGetBoolAndUnLock(jsvSkipName(cond));\n    jsvUnLock(cond);\n    JSP_MATCH_WITH_CLEANUP_AND_RETURN(')',jslCharPosFree(&whileBodyStart);jslCharPosFree(&whileCondStart);,0);\n  }\n\n  JslCharPos whileBodyEnd;\n  jslCharPosNew(&whileBodyEnd, lex->sourceVar, lex->tokenStart);\n\n  int loopCount = 0;\n  while (!hasHadBreak && loopCond\n#ifdef JSPARSE_MAX_LOOP_ITERATIONS\n      && loopCount<JSPARSE_MAX_LOOP_ITERATIONS\n#endif\n  ) {\n    if (isWhile || loopCount) { // don't check the start condition a second time if we're in a do..while loop\n      jslSeekToP(&whileCondStart);\n      cond = jspeExpression();\n      loopCond = JSP_SHOULD_EXECUTE && jsvGetBoolAndUnLock(jsvSkipName(cond));\n      jsvUnLock(cond);\n    }\n    if (loopCond) {\n      jslSeekToP(&whileBodyStart);\n      execInfo.execute |= EXEC_IN_LOOP;\n      jspDebuggerLoopIfCtrlC();\n      jsvUnLock(jspeBlockOrStatement());\n      if (!wasInLoop) execInfo.execute &= (JsExecFlags)~EXEC_IN_LOOP;\n      hasHadBreak |= jspeCheckBreakContinue();\n    }\n    loopCount++;\n  }\n  jslSeekToP(&whileBodyEnd);\n  jslCharPosFree(&whileCondStart);\n  jslCharPosFree(&whileBodyStart);\n  jslCharPosFree(&whileBodyEnd);\n#ifdef JSPARSE_MAX_LOOP_ITERATIONS\n  if (loopCount > JSPARSE_MAX_LOOP_ITERATIONS) {\n    jsExceptionHere(JSET_ERROR, \"WHILE Loop exceeded the maximum number of iterations (\" STRINGIFY(JSPARSE_MAX_LOOP_ITERATIONS) \")\");\n  }\n#endif\n  return 0;\n}\n\nNO_INLINE JsVar *jspGetBuiltinPrototype(JsVar *obj) {\n  if (jsvIsArray(obj)) {\n    JsVar *v = jspFindPrototypeFor(\"Array\");\n    if (v) return v;\n  }\n  if (jsvIsObject(obj) || jsvIsArray(obj)) {\n    JsVar *v = jspFindPrototypeFor(\"Object\");\n    if (v==obj) { // don't return ourselves\n      jsvUnLock(v);\n      v = 0;\n    }\n    return v;\n  }\n  return 0;\n}\n\nNO_INLINE JsVar *jspeStatementFor() {\n  JSP_ASSERT_MATCH(LEX_R_FOR);\n  JSP_MATCH('(');\n  bool wasInLoop = (execInfo.execute&EXEC_IN_LOOP)!=0;\n  execInfo.execute |= EXEC_FOR_INIT;\n  // initialisation\n  JsVar *forStatement = 0;\n  // we could have 'for (;;)' - so don't munch up our semicolon if that's all we have\n  if (lex->tk != ';')\n    forStatement = jspeStatement();\n  if (jspIsInterrupted()) {\n    jsvUnLock(forStatement);\n    return 0;\n  }\n  execInfo.execute &= (JsExecFlags)~EXEC_FOR_INIT;\n#ifndef SAVE_ON_FLASH_EXTREME\n  if (lex->tk == LEX_R_IN || lex->tk == LEX_R_OF) {\n    bool isForOf = lex->tk == LEX_R_OF;\n    // for (i in array)  or   for (i of array)\n    // where i = forStatement\n    if (JSP_SHOULD_EXECUTE && !jsvIsName(forStatement)) {\n      jsvUnLock(forStatement);\n      jsExceptionHere(JSET_ERROR, \"for(a %s b) - 'a' must be a variable name, not %t\", isForOf?\"of\":\"in\", forStatement);\n      return 0;\n    }\n\n    JSP_ASSERT_MATCH(lex->tk); // skip over in/of\n    JsVar *array = jsvSkipNameAndUnLock(jspeExpression());\n\n    JslCharPos forBodyStart;\n    jslCharPosFromLex(&forBodyStart);\n    JSP_MATCH_WITH_CLEANUP_AND_RETURN(')', jsvUnLock2(forStatement, array);jslCharPosFree(&forBodyStart), 0);\n\n    // Simply scan over the loop the first time without executing to figure out where it ends\n    // OPT: we could skip the first parse and actually execute the first time\n    JSP_SAVE_EXECUTE();\n    jspSetNoExecute();\n    execInfo.execute |= EXEC_IN_LOOP;\n    jsvUnLock(jspeBlockOrStatement());\n    JslCharPos forBodyEnd;\n    jslCharPosNew(&forBodyEnd, lex->sourceVar, lex->tokenStart);\n    if (!wasInLoop) execInfo.execute &= (JsExecFlags)~EXEC_IN_LOOP;\n    JSP_RESTORE_EXECUTE();\n    // Now start executing properly\n    if (JSP_SHOULD_EXECUTE) {\n      if (jsvIsIterable(array)) {\n        JsvIsInternalChecker checkerFunction = jsvGetInternalFunctionCheckerFor(array);\n        JsVar *foundPrototype = 0;\n        if (!isForOf) // for..in\n          foundPrototype = jspGetBuiltinPrototype(array);\n\n        JsvIterator it;\n        jsvIteratorNew(&it, array, isForOf ?\n            /* for of */ JSIF_EVERY_ARRAY_ELEMENT :\n            /* for in */ JSIF_DEFINED_ARRAY_ElEMENTS);\n        bool hasHadBreak = false;\n        while (JSP_SHOULD_EXECUTE && jsvIteratorHasElement(&it) && !hasHadBreak) {\n          JsVar *loopIndexVar = jsvIteratorGetKey(&it);\n          bool ignore = false;\n          if (checkerFunction && checkerFunction(loopIndexVar)) {\n            ignore = true;\n            if (jsvIsString(loopIndexVar) &&\n                jsvIsStringEqual(loopIndexVar, JSPARSE_INHERITS_VAR))\n              foundPrototype = jsvSkipName(loopIndexVar);\n          }\n          if (!ignore) {\n            JsVar *iteratorValue;\n            if (isForOf) { // for (... of ...)\n              iteratorValue = jsvIteratorGetValue(&it);\n            } else { // for (... in ...)\n              iteratorValue = jsvIsName(loopIndexVar) ?\n                  jsvCopyNameOnly(loopIndexVar, false/*no copy children*/, false/*not a name*/) :\n                  loopIndexVar;\n              assert(jsvGetRefs(iteratorValue)==0);\n            }\n            if (isForOf || iteratorValue) { // could be out of memory\n              assert(!jsvIsName(iteratorValue));\n              jsvReplaceWithOrAddToRoot(forStatement, iteratorValue);\n              if (iteratorValue!=loopIndexVar) jsvUnLock(iteratorValue);\n\n              jslSeekToP(&forBodyStart);\n              execInfo.execute |= EXEC_IN_LOOP;\n              jspDebuggerLoopIfCtrlC();\n              jsvUnLock(jspeBlockOrStatement());\n              if (!wasInLoop) execInfo.execute &= (JsExecFlags)~EXEC_IN_LOOP;\n\n              hasHadBreak |= jspeCheckBreakContinue();\n            }\n          }\n          jsvIteratorNext(&it);\n          jsvUnLock(loopIndexVar);\n          // if using for..in we'll skip down the prototype chain when we reach the end of the current one\n          if (!jsvIteratorHasElement(&it) && !isForOf && foundPrototype) {\n            jsvIteratorFree(&it);\n            JsVar *iterable = foundPrototype;\n            jsvIteratorNew(&it, iterable, JSIF_DEFINED_ARRAY_ElEMENTS);\n            checkerFunction = jsvGetInternalFunctionCheckerFor(iterable);\n            foundPrototype = jspGetBuiltinPrototype(iterable);\n            jsvUnLock(iterable);\n          }\n        }\n        assert(!foundPrototype);\n        jsvIteratorFree(&it);\n      } else if (!jsvIsUndefined(array)) {\n        jsExceptionHere(JSET_ERROR, \"FOR loop can only iterate over Arrays, Strings or Objects, not %t\", array);\n      }\n    }\n    jslSeekToP(&forBodyEnd);\n    jslCharPosFree(&forBodyStart);\n    jslCharPosFree(&forBodyEnd);\n\n    jsvUnLock2(forStatement, array);\n#else // SAVE_ON_FLASH_EXTREME\n  if (false) {\n#endif // SAVE_ON_FLASH_EXTREME\n  } else { // ----------------------------------------------- NORMAL FOR LOOP\n#ifdef JSPARSE_MAX_LOOP_ITERATIONS\n    int loopCount = JSPARSE_MAX_LOOP_ITERATIONS;\n#endif\n    bool loopCond = true;\n    bool hasHadBreak = false;\n\n    jsvUnLock(forStatement);\n    JslCharPos forCondStart;\n    jslCharPosFromLex(&forCondStart);\n    JSP_MATCH_WITH_CLEANUP_AND_RETURN(';',jslCharPosFree(&forCondStart);,0);\n\n    if (lex->tk != ';') {\n      JsVar *cond = jspeExpression(); // condition\n      loopCond = JSP_SHOULD_EXECUTE && jsvGetBoolAndUnLock(jsvSkipName(cond));\n      jsvUnLock(cond);\n    }\n    JslCharPos forIterStart;\n    jslCharPosFromLex(&forIterStart);\n    JSP_MATCH_WITH_CLEANUP_AND_RETURN(';',jslCharPosFree(&forCondStart);jslCharPosFree(&forIterStart);,0);\n    if (lex->tk != ')')  { // we could have 'for (;;)'\n      JSP_SAVE_EXECUTE();\n      jspSetNoExecute();\n      jsvUnLock(jspeExpression()); // iterator\n      JSP_RESTORE_EXECUTE();\n    }\n    JslCharPos forBodyStart;\n    jslSkipWhiteSpace();\n    jslCharPosFromLex(&forBodyStart); // actual for body\n    JSP_MATCH_WITH_CLEANUP_AND_RETURN(')',jslCharPosFree(&forCondStart);jslCharPosFree(&forIterStart);jslCharPosFree(&forBodyStart);,0);\n\n    JSP_SAVE_EXECUTE();\n    if (!loopCond) jspSetNoExecute();\n    execInfo.execute |= EXEC_IN_LOOP;\n    jsvUnLock(jspeBlockOrStatement());\n    JslCharPos forBodyEnd;\n    jslSkipWhiteSpace();\n    jslCharPosNew(&forBodyEnd, lex->sourceVar, lex->tokenStart);\n    if (!wasInLoop) execInfo.execute &= (JsExecFlags)~EXEC_IN_LOOP;\n    if (loopCond || !JSP_SHOULD_EXECUTE) {\n      hasHadBreak |= jspeCheckBreakContinue();\n    }\n    if (!loopCond) JSP_RESTORE_EXECUTE();\n    if (loopCond) {\n      jslSeekToP(&forIterStart);\n      if (lex->tk != ')') jsvUnLock(jspeExpression());\n    }\n    while (!hasHadBreak && JSP_SHOULD_EXECUTE && loopCond\n#ifdef JSPARSE_MAX_LOOP_ITERATIONS\n        && loopCount-->0\n#endif\n    ) {\n      jslSeekToP(&forCondStart);\n      ;\n      if (lex->tk == ';') {\n        loopCond = true;\n      } else {\n        JsVar *cond = jspeExpression();\n        loopCond = jsvGetBoolAndUnLock(jsvSkipName(cond));\n        jsvUnLock(cond);\n      }\n      if (JSP_SHOULD_EXECUTE && loopCond) {\n        jslSeekToP(&forBodyStart);\n        execInfo.execute |= EXEC_IN_LOOP;\n        jspDebuggerLoopIfCtrlC();\n        jsvUnLock(jspeBlockOrStatement());\n        if (!wasInLoop) execInfo.execute &= (JsExecFlags)~EXEC_IN_LOOP;\n        hasHadBreak |= jspeCheckBreakContinue();\n      }\n      if (JSP_SHOULD_EXECUTE && loopCond && !hasHadBreak) {\n        jslSeekToP(&forIterStart);\n        if (lex->tk != ')') jsvUnLock(jspeExpression());\n      }\n    }\n    jslSeekToP(&forBodyEnd);\n\n    jslCharPosFree(&forCondStart);\n    jslCharPosFree(&forIterStart);\n    jslCharPosFree(&forBodyStart);\n    jslCharPosFree(&forBodyEnd);\n\n#ifdef JSPARSE_MAX_LOOP_ITERATIONS\n    if (loopCount<=0) {\n      jsExceptionHere(JSET_ERROR, \"FOR Loop exceeded the maximum number of iterations (\"STRINGIFY(JSPARSE_MAX_LOOP_ITERATIONS)\")\");\n    }\n#endif\n  }\n  return 0;\n}\n\nNO_INLINE JsVar *jspeStatementTry() {\n  // execute the try block\n  JSP_ASSERT_MATCH(LEX_R_TRY);\n  bool shouldExecuteBefore = JSP_SHOULD_EXECUTE;\n  jspeBlock();\n  bool hadException = shouldExecuteBefore && ((execInfo.execute & EXEC_EXCEPTION)!=0);\n\n  bool hadCatch = false;\n  if (lex->tk == LEX_R_CATCH) {\n    JSP_ASSERT_MATCH(LEX_R_CATCH);\n    hadCatch = true;\n    JSP_MATCH('(');\n    JsVar *scope = 0;\n    JsVar *exceptionVar = 0;\n    if (hadException) {\n      scope = jsvNewObject();\n      if (scope)\n        exceptionVar = jsvFindChildFromString(scope, jslGetTokenValueAsString(), true);\n    }\n    JSP_MATCH_WITH_CLEANUP_AND_RETURN(LEX_ID,jsvUnLock2(scope,exceptionVar),0);\n    JSP_MATCH_WITH_CLEANUP_AND_RETURN(')',jsvUnLock2(scope,exceptionVar),0);\n    if (exceptionVar) {\n      // set the exception var up properly\n      JsVar *exception = jspGetException();\n      if (exception) {\n        jsvSetValueOfName(exceptionVar, exception);\n        jsvUnLock(exception);\n      }\n      // Now clear the exception flag (it's handled - we hope!)\n      execInfo.execute = execInfo.execute & (JsExecFlags)~(EXEC_EXCEPTION|EXEC_ERROR_LINE_REPORTED);\n      jsvUnLock(exceptionVar);\n    }\n\n    if (shouldExecuteBefore && !hadException) {\n      JSP_SAVE_EXECUTE();\n      jspSetNoExecute();\n      jspeBlock();\n      JSP_RESTORE_EXECUTE();\n    } else {\n      if (!scope || jspeiAddScope(scope)) {\n        jspeBlock();\n        if (scope) jspeiRemoveScope();\n      }\n    }\n    jsvUnLock(scope);\n  }\n  if (lex->tk == LEX_R_FINALLY || (!hadCatch && ((execInfo.execute&(EXEC_ERROR|EXEC_INTERRUPTED))==0))) {\n    JSP_MATCH(LEX_R_FINALLY);\n    // clear the exception flag - but only momentarily!\n    if (hadException) execInfo.execute = execInfo.execute & (JsExecFlags)~EXEC_EXCEPTION;\n    jspeBlock();\n    // put the flag back!\n    if (hadException && !hadCatch) execInfo.execute = execInfo.execute | EXEC_EXCEPTION;\n  }\n  return 0;\n}\n\nNO_INLINE JsVar *jspeStatementReturn() {\n  JsVar *result = 0;\n  JSP_ASSERT_MATCH(LEX_R_RETURN);\n  if (lex->tk != ';' && lex->tk != '}') {\n    // we only want the value, so skip the name if there was one\n    result = jsvSkipNameAndUnLock(jspeExpression());\n  }\n  if (JSP_SHOULD_EXECUTE) {\n    JsVar *resultVar = jspeiFindInScopes(JSPARSE_RETURN_VAR);\n    if (resultVar) {\n      jsvReplaceWith(resultVar, result);\n      jsvUnLock(resultVar);\n      execInfo.execute |= EXEC_RETURN; // Stop anything else in this function executing\n    } else {\n      jsExceptionHere(JSET_SYNTAXERROR, \"RETURN statement, but not in a function.\\n\");\n    }\n  }\n  jsvUnLock(result);\n  return 0;\n}\n\nNO_INLINE JsVar *jspeStatementThrow() {\n  JsVar *result = 0;\n  JSP_ASSERT_MATCH(LEX_R_THROW);\n  result = jsvSkipNameAndUnLock(jspeExpression());\n  if (JSP_SHOULD_EXECUTE) {\n    jspSetException(result); // Stop anything else in this function executing\n  }\n  jsvUnLock(result);\n  return 0;\n}\n\nNO_INLINE JsVar *jspeStatementFunctionDecl(bool isClass) {\n  JsVar *funcName = 0;\n  JsVar *funcVar;\n\n#ifndef SAVE_ON_FLASH\n  JSP_ASSERT_MATCH(isClass ? LEX_R_CLASS : LEX_R_FUNCTION);\n#else\n  JSP_ASSERT_MATCH(LEX_R_FUNCTION);\n#endif\n\n  bool actuallyCreateFunction = JSP_SHOULD_EXECUTE;\n  if (actuallyCreateFunction) {\n    funcName = jsvMakeIntoVariableName(jslGetTokenValueAsVar(), 0);\n    if (!funcName) { // out of memory\n      return 0;\n    }\n  }\n  JSP_MATCH_WITH_CLEANUP_AND_RETURN(LEX_ID, jsvUnLock(funcName), 0);\n#ifndef SAVE_ON_FLASH\n  funcVar = isClass ? jspeClassDefinition(false) : jspeFunctionDefinition(false);\n#else\n  funcVar = jspeFunctionDefinition(false);\n#endif\n  if (actuallyCreateFunction) {\n    // find a function with the same name (or make one)\n    // OPT: can Find* use just a JsVar that is a 'name'?\n    JsVar *existingName = jspeiFindNameOnTop(funcName, true);\n    JsVar *existingFunc = jsvSkipName(existingName);\n    if (jsvIsFunction(existingFunc)) {\n      // 'proper' replace, that keeps the original function var and swaps the children\n      funcVar = jsvSkipNameAndUnLock(funcVar);\n      jswrap_function_replaceWith(existingFunc, funcVar);\n    } else {\n      jsvReplaceWith(existingName, funcVar);\n    }\n    jsvUnLock(funcName);\n    funcName = existingName;\n    jsvUnLock(existingFunc);\n    // existingName is used - don't UnLock\n  }\n  jsvUnLock(funcVar);\n  return funcName;\n}\n\nNO_INLINE JsVar *jspeStatement() {\n#ifdef USE_DEBUGGER\n  if (execInfo.execute&EXEC_DEBUGGER_NEXT_LINE &&\n      lex->tk!=';' &&\n      JSP_SHOULD_EXECUTE) {\n    lex->tokenLastStart = lex->tokenStart;\n    jsiDebuggerLoop();\n  }\n#endif\n  if (lex->tk==LEX_ID ||\n      lex->tk==LEX_INT ||\n      lex->tk==LEX_FLOAT ||\n      lex->tk==LEX_STR ||\n      lex->tk==LEX_TEMPLATE_LITERAL ||\n      lex->tk==LEX_REGEX ||\n      lex->tk==LEX_R_NEW ||\n      lex->tk==LEX_R_NULL ||\n      lex->tk==LEX_R_UNDEFINED ||\n      lex->tk==LEX_R_TRUE ||\n      lex->tk==LEX_R_FALSE ||\n      lex->tk==LEX_R_THIS ||\n      lex->tk==LEX_R_DELETE ||\n      lex->tk==LEX_R_TYPEOF ||\n      lex->tk==LEX_R_VOID ||\n      lex->tk==LEX_R_SUPER ||\n      lex->tk==LEX_PLUSPLUS ||\n      lex->tk==LEX_MINUSMINUS ||\n      lex->tk=='!' ||\n      lex->tk=='-' ||\n      lex->tk=='+' ||\n      lex->tk=='~' ||\n      lex->tk=='[' ||\n      lex->tk=='(') {\n    /* Execute a simple statement that only contains basic arithmetic... */\n    return jspeExpression();\n  } else if (lex->tk=='{') {\n    /* A block of code */\n    if (!jspCheckStackPosition()) return 0;\n    jspeBlock();\n    return 0;\n  } else if (lex->tk==';') {\n    /* Empty statement - to allow things like ;;; */\n    JSP_ASSERT_MATCH(';');\n    return 0;\n  } else if (lex->tk==LEX_R_VAR ||\n            lex->tk==LEX_R_LET ||\n            lex->tk==LEX_R_CONST) {\n    return jspeStatementVar();\n  } else if (lex->tk==LEX_R_IF) {\n    return jspeStatementIf();\n  } else if (lex->tk==LEX_R_DO) {\n    return jspeStatementDoOrWhile(false);\n  } else if (lex->tk==LEX_R_WHILE) {\n    return jspeStatementDoOrWhile(true);\n  } else if (lex->tk==LEX_R_FOR) {\n    return jspeStatementFor();\n  } else if (lex->tk==LEX_R_TRY) {\n    return jspeStatementTry();\n  } else if (lex->tk==LEX_R_RETURN) {\n    return jspeStatementReturn();\n  } else if (lex->tk==LEX_R_THROW) {\n    return jspeStatementThrow();\n  } else if (lex->tk==LEX_R_FUNCTION) {\n    return jspeStatementFunctionDecl(false/* function */);\n#ifndef SAVE_ON_FLASH\n  } else if (lex->tk==LEX_R_CLASS) {\n      return jspeStatementFunctionDecl(true/* class */);\n#endif\n  } else if (lex->tk==LEX_R_CONTINUE) {\n    JSP_ASSERT_MATCH(LEX_R_CONTINUE);\n    if (JSP_SHOULD_EXECUTE) {\n      if (!(execInfo.execute & EXEC_IN_LOOP))\n        jsExceptionHere(JSET_SYNTAXERROR, \"CONTINUE statement outside of FOR or WHILE loop\");\n      else\n        execInfo.execute = (execInfo.execute & (JsExecFlags)~EXEC_RUN_MASK) | EXEC_CONTINUE;\n    }\n  } else if (lex->tk==LEX_R_BREAK) {\n    JSP_ASSERT_MATCH(LEX_R_BREAK);\n    if (JSP_SHOULD_EXECUTE) {\n      if (!(execInfo.execute & (EXEC_IN_LOOP|EXEC_IN_SWITCH)))\n        jsExceptionHere(JSET_SYNTAXERROR, \"BREAK statement outside of SWITCH, FOR or WHILE loop\");\n      else\n        execInfo.execute = (execInfo.execute & (JsExecFlags)~EXEC_RUN_MASK) | EXEC_BREAK;\n    }\n  } else if (lex->tk==LEX_R_SWITCH) {\n    return jspeStatementSwitch();\n  } else if (lex->tk==LEX_R_DEBUGGER) {\n    JSP_ASSERT_MATCH(LEX_R_DEBUGGER);\n#ifdef USE_DEBUGGER\n    if (JSP_SHOULD_EXECUTE)\n      jsiDebuggerLoop();\n#endif\n  } else JSP_MATCH(LEX_EOF);\n  return 0;\n}\n\n// -----------------------------------------------------------------------------\n/// Create a new built-in object that jswrapper can use to check for built-in functions\nJsVar *jspNewBuiltin(const char *instanceOf) {\n  JsVar *objFunc = jswFindBuiltInFunction(0, instanceOf);\n  if (!objFunc) return 0; // out of memory\n  return objFunc;\n}\n\n/// Create a new Class of the given instance and return its prototype (as a name 'prototype')\nNO_INLINE JsVar *jspNewPrototype(const char *instanceOf) {\n  JsVar *objFuncName = jsvFindChildFromString(execInfo.root, instanceOf, true);\n  if (!objFuncName) // out of memory\n    return 0;\n\n  JsVar *objFunc = jsvSkipName(objFuncName);\n  if (!objFunc) {\n    objFunc = jspNewBuiltin(instanceOf);\n    if (!objFunc) { // out of memory\n      jsvUnLock(objFuncName);\n      return 0;\n    }\n\n    // set up name\n    jsvSetValueOfName(objFuncName, objFunc);\n  }\n\n  JsVar *prototypeName = jsvFindChildFromString(objFunc, JSPARSE_PROTOTYPE_VAR, true);\n  jspEnsureIsPrototype(objFunc, prototypeName); // make sure it's an object\n  jsvUnLock2(objFunc, objFuncName);\n\n  return prototypeName;\n}\n\n/** Create a new object of the given instance and add it to root with name 'name'.\n * If name!=0, added to root with name, and the name is returned\n * If name==0, not added to root and Object itself returned */\nNO_INLINE JsVar *jspNewObject(const char *name, const char *instanceOf) {\n  JsVar *prototypeName = jspNewPrototype(instanceOf);\n\n  JsVar *obj = jsvNewObject();\n  if (!obj) { // out of memory\n    jsvUnLock(prototypeName);\n    return 0;\n  }\n  if (name) {\n    // If it's a device, set the device number up as the Object data\n    // See jsiGetDeviceFromClass\n    IOEventFlags device = jshFromDeviceString(name);\n    if (device!=EV_NONE) {\n      obj->varData.str[0] = 'D';\n      obj->varData.str[1] = 'E';\n      obj->varData.str[2] = 'V';\n      obj->varData.str[3] = (char)device;\n    }\n\n  }\n  // add __proto__\n  JsVar *prototypeVar = jsvSkipName(prototypeName);\n  jsvUnLock3(jsvAddNamedChild(obj, prototypeVar, JSPARSE_INHERITS_VAR), prototypeVar, prototypeName);prototypeName=0;\n\n  if (name) {\n    JsVar *objName = jsvFindChildFromString(execInfo.root, name, true);\n    if (objName) jsvSetValueOfName(objName, obj);\n    jsvUnLock(obj);\n    if (!objName) { // out of memory\n      return 0;\n    }\n    return objName;\n  } else\n    return obj;\n}\n\n/** Returns true if the constructor function given is the same as that\n * of the object with the given name. */\nbool jspIsConstructor(JsVar *constructor, const char *constructorName) {\n  JsVar *objFunc = jsvObjectGetChild(execInfo.root, constructorName, 0);\n  if (!objFunc) return false;\n  bool isConstructor = objFunc == constructor;\n  jsvUnLock(objFunc);\n  return isConstructor;\n}\n\n/** Get the prototype of the given object, or return 0 if not found, or not an object */\nJsVar *jspGetPrototype(JsVar *object) {\n  if (!jsvIsObject(object)) return 0;\n  JsVar *proto = jsvObjectGetChild(object, JSPARSE_INHERITS_VAR, 0);\n  if (jsvIsObject(proto))\n    return proto;\n  jsvUnLock(proto);\n  return 0;\n}\n\n/** Get the constructor of the given object, or return 0 if not found, or not a function */\nJsVar *jspGetConstructor(JsVar *object) {\n  JsVar *proto = jspGetPrototype(object);\n  if (proto) {\n    JsVar *constr = jsvObjectGetChild(proto, JSPARSE_CONSTRUCTOR_VAR, 0);\n    if (jsvIsFunction(constr)) {\n      jsvUnLock(proto);\n      return constr;\n    }\n    jsvUnLock2(constr, proto);\n  }\n  return 0;\n}\n\n// -----------------------------------------------------------------------------\n\nvoid jspSoftInit() {\n  execInfo.root = jsvFindOrCreateRoot();\n  // Root now has a lock and a ref\n  execInfo.hiddenRoot = jsvObjectGetChild(execInfo.root, JS_HIDDEN_CHAR_STR, JSV_OBJECT);\n  execInfo.execute = EXEC_YES;\n}\n\nvoid jspSoftKill() {\n  jsvUnLock(execInfo.scopesVar);\n  execInfo.scopesVar = 0;\n  jsvUnLock(execInfo.hiddenRoot);\n  execInfo.hiddenRoot = 0;\n  jsvUnLock(execInfo.root);\n  execInfo.root = 0;\n  // Root is now left with just a ref\n}\n\nvoid jspInit() {\n  jspSoftInit();\n}\n\nvoid jspKill() {\n  jspSoftKill();\n  // Unreffing this should completely kill everything attached to root\n  JsVar *r = jsvFindOrCreateRoot();\n  jsvUnRef(r);\n  jsvUnLock(r);\n}\n\n/** Evaluate the given variable as an expression (in current scope) */\nJsVar *jspEvaluateExpressionVar(JsVar *str) {\n  JsLex lex;\n\n  assert(jsvIsString(str));\n  JsLex *oldLex = jslSetLex(&lex);\n  jslInit(str);\n#ifndef ESPR_NO_LINE_NUMBERS\n  lex.lineNumberOffset = oldLex->lineNumberOffset;\n#endif\n\n  // actually do the parsing\n  JsVar *v = jspeExpression();\n  jslKill();\n  jslSetLex(oldLex);\n\n  return jsvSkipNameAndUnLock(v);\n}\n\n/** Execute code form a variable and return the result. If lineNumberOffset\n * is nonzero it's added to the line numbers that get reported for errors/debug */\nJsVar *jspEvaluateVar(JsVar *str, JsVar *scope, uint16_t lineNumberOffset) {\n  JsLex lex;\n\n  assert(jsvIsString(str));\n  JsLex *oldLex = jslSetLex(&lex);\n  jslInit(str);\n#ifndef ESPR_NO_LINE_NUMBERS\n  lex.lineNumberOffset = lineNumberOffset;\n#endif\n\n\n  JsExecInfo oldExecInfo = execInfo;\n  execInfo.execute = EXEC_YES;\n  if (scope) {\n    // if we're adding a scope, make sure it's the *only* scope\n    execInfo.scopesVar = 0;\n    if (scope!=execInfo.root) jspeiAddScope(scope); // it's searched by default anyway\n  }\n\n  // actually do the parsing\n  JsVar *v = jspParse();\n  // clean up\n  if (scope) jspeiClearScopes();\n  jslKill();\n  jslSetLex(oldLex);\n\n  // restore state and execInfo (keep error flags & ctrl-c)\n  oldExecInfo.execute |= execInfo.execute & EXEC_PERSIST;\n  execInfo = oldExecInfo;\n\n  // It may have returned a reference, but we just want the value...\n  return jsvSkipNameAndUnLock(v);\n}\n\nJsVar *jspEvaluate(const char *str, bool stringIsStatic) {\n\n  /* using a memory area is more efficient, but the interpreter\n   * may use substrings from it for function code. This means that\n   * if the string goes away, everything gets corrupted - hence\n   * the option here.\n   */\n  JsVar *evCode;\n  if (stringIsStatic)\n    evCode = jsvNewNativeString((char*)str, strlen(str));\n  else\n    evCode = jsvNewFromString(str);\n  if (!evCode) return 0;\n\n  JsVar *v = 0;\n  if (!jsvIsMemoryFull())\n    v = jspEvaluateVar(evCode, 0, 0);\n  jsvUnLock(evCode);\n\n  return v;\n}\n\nJsVar *jspExecuteJSFunction(const char *jsCode, JsVar *thisArg, int argCount, JsVar **argPtr) {\n  JsVar *fn = jspEvaluate(jsCode,true);\n  JsVar *result = jspExecuteFunction(fn,thisArg,argCount,argPtr);\n  jsvUnLock(fn);\n  return result;\n}\n\nJsVar *jspExecuteFunction(JsVar *func, JsVar *thisArg, int argCount, JsVar **argPtr) {\n  JsExecInfo oldExecInfo = execInfo;\n  execInfo.scopesVar = 0;\n  execInfo.execute = EXEC_YES;\n  execInfo.thisVar = 0;\n  JsVar *result = jspeFunctionCall(func, 0, thisArg, false, argCount, argPtr);\n  // clean up\n  jspeiClearScopes();\n  // restore state and execInfo (keep error flags & ctrl-c)\n  oldExecInfo.execute |= execInfo.execute&EXEC_PERSIST;\n  jspeiClearScopes();\n  execInfo = oldExecInfo;\n\n  return result;\n}\n\n\n/// Evaluate a JavaScript module and return its exports\nJsVar *jspEvaluateModule(JsVar *moduleContents) {\n  assert(jsvIsString(moduleContents) || jsvIsFunction(moduleContents));\n  if (jsvIsFunction(moduleContents)) {\n    moduleContents = jsvObjectGetChild(moduleContents,JSPARSE_FUNCTION_CODE_NAME,0);\n    if (!jsvIsString(moduleContents)) {\n      jsvUnLock(moduleContents);\n      return 0;\n    }\n  } else\n    jsvLockAgain(moduleContents);\n  JsVar *scope = jsvNewObject();\n  JsVar *scopeExports = jsvNewObject();\n  if (!scope || !scopeExports) { // out of mem\n    jsvUnLock3(scope, scopeExports, moduleContents);\n    return 0;\n  }\n  JsVar *exportsName = jsvAddNamedChild(scope, scopeExports, \"exports\");\n  jsvUnLock2(scopeExports, jsvAddNamedChild(scope, scope, \"module\"));\n\n  JsExecFlags oldExecute = execInfo.execute;\n  JsVar *oldThisVar = execInfo.thisVar;\n  execInfo.thisVar = scopeExports; // set 'this' variable to exports\n  jsvUnLock(jspEvaluateVar(moduleContents, scope, 0));\n  execInfo.thisVar = oldThisVar;\n  execInfo.execute = oldExecute; // make sure we fully restore state after parsing a module\n\n  jsvUnLock2(moduleContents, scope);\n  return jsvSkipNameAndUnLock(exportsName);\n}\n\n/** Get the owner of the current prototype. We assume that it's\n * the first item in the array, because that's what we will\n * have added when we created it. It's safe to call this on\n * non-prototypes and non-objects.  */\nJsVar *jspGetPrototypeOwner(JsVar *proto) {\n  if (jsvIsObject(proto) || jsvIsArray(proto)) {\n    return jsvSkipNameAndUnLock(jsvObjectGetChild(proto, JSPARSE_CONSTRUCTOR_VAR, 0));\n  }\n  return 0;\n}\n", "/*\n * This file is part of Espruino, a JavaScript interpreter for Microcontrollers\n *\n * Copyright (C) 2013 Gordon Williams <gw@pur3.co.uk>\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n *\n * ----------------------------------------------------------------------------\n * Recursive descent parser for code execution\n * ----------------------------------------------------------------------------\n */\n#ifndef JSPARSE_H_\n#define JSPARSE_H_\n\n#include \"jsvar.h\"\n#include \"jslex.h\"\n\nvoid jspInit();\nvoid jspKill();\n\n// jspSoft* - 'release' or 'claim' anything we are using, but ensure that it doesn't get freed\nvoid jspSoftInit(); ///< used when recovering from or saving to flash\nvoid jspSoftKill(); ///< used when recovering from or saving to flash\n/** Returns true if the constructor function given is the same as that\n * of the object with the given name. */\nbool jspIsConstructor(JsVar *constructor, const char *constructorName);\n/** Get the prototype of the given object, or return 0 if not found, or not an object */\nJsVar *jspGetPrototype(JsVar *object);\n/** Get the constructor of the given object, or return 0 if ot found, or not a function */\nJsVar *jspGetConstructor(JsVar *object);\n\n/// Check that we have enough stack to recurse. Return true if all ok, error if not.\nbool jspCheckStackPosition();\n\n/// Create a new built-in object that jswrapper can use to check for built-in functions\nJsVar *jspNewBuiltin(const char *name);\n\n/// Create a new Class of the given instance and return its prototype (as a name 'prototype')\nNO_INLINE JsVar *jspNewPrototype(const char *instanceOf);\n\n/** Create a new object of the given instance and add it to root with name 'name'.\n * If name!=0, added to root with name, and the name is returned\n * If name==0, not added to root and Object itself returned */\nJsVar *jspNewObject(const char *name, const char *instanceOf);\n\n/// if interrupting execution, this is set\nbool jspIsInterrupted();\n/// if interrupting execution, this is set\nvoid jspSetInterrupted(bool interrupt);\n/// Has there been an error during parsing\nbool jspHasError();\n/// Set the error flag - set lineReported if we've already output the line number\nvoid jspSetError(bool lineReported);\n/// We had an exception (argument is the exception's value)\nvoid jspSetException(JsVar *value);\n/** Return the reported exception if there was one (and clear it) */\nJsVar *jspGetException();\n/** Return a stack trace string if there was one (and clear it) */\nJsVar *jspGetStackTrace();\n\n/** Evaluate the given variable as an expression (in current scope) */\nJsVar *jspEvaluateExpressionVar(JsVar *str);\n/** Execute code form a variable and return the result. If lineNumberOffset\n * is nonzero it's added to the line numbers that get reported for errors/debug */\nJsVar *jspEvaluateVar(JsVar *str, JsVar *scope, uint16_t lineNumberOffset);\n/** Execute code form a string and return the result.\n * You should only set stringIsStatic if the string will hang around for\n * the life of the interpreter, as then the interpreter will use a pointer\n * to this data, which could hang around inside the code. */\nJsVar *jspEvaluate(const char *str, bool stringIsStatic);\n/// Execute a JS function with the given arguments. usage: jspExecuteJSFunction(\"(function() { print('hi'); })\",0,0,0)\nJsVar *jspExecuteJSFunction(const char *jsCode, JsVar *thisArg, int argCount, JsVar **argPtr);\n/// Execute a function with the given arguments\nJsVar *jspExecuteFunction(JsVar *func, JsVar *thisArg, int argCount, JsVar **argPtr);\n\n/// Evaluate a JavaScript module and return its exports\nJsVar *jspEvaluateModule(JsVar *moduleContents);\n\n/** Get the owner of the current prototype. We assume that it's\n * the first item in the array, because that's what we will\n * have added when we created it. It's safe to call this on\n * non-prototypes and non-objects.  */\nJsVar *jspGetPrototypeOwner(JsVar *proto);\n\n/** When parsing, this enum defines whether\n we are executing or not */\ntypedef enum  {\n  EXEC_NO = 0,\n  EXEC_YES = 1,\n  EXEC_BREAK = 2,     ///< Have we had a 'break' keyword (so should skip to end of loop and exit)\n  EXEC_CONTINUE = 4,  ///< Have we had a 'continue' keywrord (so should skip to end of loop and restart)\n  EXEC_RETURN = 8,    ///< Have we had a 'return' keyword (so should skip to end of the function)\n\n  EXEC_INTERRUPTED = 16, ///< true if execution has been interrupted\n  EXEC_EXCEPTION = 32, ///< we had an exception, so don't execute until we hit a try/catch block\n  EXEC_ERROR = 64,\n  EXEC_ERROR_LINE_REPORTED = 128, ///< if an error has been reported, set this so we don't do it too much (EXEC_ERROR will STILL be set)\n\n  EXEC_FOR_INIT = 256, ///< when in for initialiser parsing - hack to avoid getting confused about multiple use for IN\n  EXEC_IN_LOOP = 512, ///< when in a loop, set this - we can then block break/continue outside it\n  EXEC_IN_SWITCH = 1024, ///< when in a switch, set this - we can then block break outside it/loops\n\n  /** If Ctrl-C is pressed, the EXEC_CTRL_C flag is set on an interrupt. The next time a SysTick\n   * happens, it sets EXEC_CTRL_C_WAIT, and if we get ANOTHER SysTick and it hasn't been handled,\n   * we go to a full-on EXEC_INTERRUPTED. That means we only interrupt code if we're actually stuck\n   * in something, and otherwise the console just clears the line. */\n  EXEC_CTRL_C = 2048, ///< If Ctrl-C was pressed, set this\n  EXEC_CTRL_C_WAIT = 4096, ///< If Ctrl-C was set and SysTick happens then this is set instead\n\n#ifdef USE_DEBUGGER\n  /** When the lexer hits a newline character, it'll then drop right\n   * into the debugger */\n  EXEC_DEBUGGER_NEXT_LINE = 8192,\n  /** Break when we execute a function */\n  EXEC_DEBUGGER_STEP_INTO = 16384,\n  /** Break when a function finishes execution */\n  EXEC_DEBUGGER_FINISH_FUNCTION = 32768,\n  EXEC_DEBUGGER_MASK = EXEC_DEBUGGER_NEXT_LINE | EXEC_DEBUGGER_STEP_INTO | EXEC_DEBUGGER_FINISH_FUNCTION,\n#endif\n\n  EXEC_RUN_MASK = EXEC_YES|EXEC_BREAK|EXEC_CONTINUE|EXEC_RETURN|EXEC_INTERRUPTED|EXEC_EXCEPTION,\n  EXEC_ERROR_MASK = EXEC_INTERRUPTED|EXEC_ERROR|EXEC_EXCEPTION, ///< here, we have an error, but unless EXEC_NO_PARSE, we should continue parsing but not executing\n  EXEC_NO_PARSE_MASK = EXEC_INTERRUPTED|EXEC_ERROR, ///< in these cases we should exit as fast as possible - skipping out of parsing\n  EXEC_SAVE_RESTORE_MASK = EXEC_YES|EXEC_BREAK|EXEC_CONTINUE|EXEC_RETURN|EXEC_IN_LOOP|EXEC_IN_SWITCH|EXEC_ERROR_MASK, ///< the things JSP_SAVE/RESTORE_EXECUTE should keep track of\n  EXEC_CTRL_C_MASK = EXEC_CTRL_C | EXEC_CTRL_C_WAIT, ///< Ctrl-C was pressed at some point\n  EXEC_PERSIST = EXEC_ERROR_MASK|EXEC_CTRL_C_MASK, ///< Things we should keep track of even after executing\n} JsExecFlags;\n\n/** This structure is used when parsing the JavaScript. It contains\n * everything that should be needed. */\ntypedef struct {\n  JsVar  *root;       //!< root of symbol table\n  JsVar  *hiddenRoot; //!< root of the symbol table that's hidden\n\n  /// JsVar array of scopes\n  JsVar *scopesVar;\n  /// Value of 'this' reserved word\n  JsVar *thisVar;\n\n  volatile JsExecFlags execute;\n} JsExecInfo;\n\n/* Info about execution when Parsing - this saves passing it on the stack\n * for each call */\nextern JsExecInfo execInfo;\n\n/// flags for jspParseFunction\ntypedef enum {\n  JSP_NOSKIP_A = 1,\n  JSP_NOSKIP_B = 2,\n  JSP_NOSKIP_C = 4,\n  JSP_NOSKIP_D = 8,\n  JSP_NOSKIP_E = 16,\n  JSP_NOSKIP_F = 32,\n  JSP_NOSKIP_G = 64,\n  JSP_NOSKIP_H = 128,\n} JspSkipFlags;\n\nbool jspParseEmptyFunction();    ///< parse function with no arguments\n\n/** Parse using current lexer until we hit the end of\n * input or there was some problem. */\nJsVar *jspParse();\n\n/** Handle a function call (assumes we've parsed the function name and we're\n * on the start bracket). 'thisArg' is the value of the 'this' variable when the\n * function is executed (it's usually the parent object).\n *\n * NOTE: this does not set the execInfo flags - so if execInfo==EXEC_NO, it won't execute\n *\n * If !isParsing and arg0!=0, argument 0 is set to what is supplied (same with arg1)\n *\n * functionName is used only for error reporting - and can be 0\n */\nJsVar *jspeFunctionCall(JsVar *function, JsVar *functionName, JsVar *thisArg, bool isParsing, int argCount, JsVar **argPtr);\n\n\n// Find a variable (or built-in function) based on the current scopes\nJsVar *jspGetNamedVariable(const char *tokenName);\n\n/** Get the named function/variable on the object - whether it's built in, or predefined.\n * If !returnName, returns the function/variable itself or undefined, but\n * if returnName, return a name (could be fake) referencing the parent.\n *\n * NOTE: ArrayBuffer/Strings are not handled here. We assume that if we're\n * passing a char* rather than a JsVar it's because we're looking up via\n * a symbol rather than a variable. To handle these use jspGetVarNamedField  */\nJsVar *jspGetNamedField(JsVar *object, const char* name, bool returnName);\nJsVar *jspGetVarNamedField(JsVar *object, JsVar *nameVar, bool returnName);\n\n/** Call the function named on the given object. For example you might call:\n *\n *  JsVar *str = jspCallNamedFunction(var, \"toString\", 0, 0);\n */\nJsVar *jspCallNamedFunction(JsVar *object, char* name, int argCount, JsVar **argPtr);\n\n\n// These are exported for the Web IDE's compiler. See exportPtrs in jswrap_process.c\nJsVar *jspeiFindInScopes(const char *name);\n\n/// Return the topmost scope (and lock it)\nJsVar *jspeiGetTopScope();\n\n#endif /* JSPARSE_H_ */\n", "/*\n * This file is part of Espruino, a JavaScript interpreter for Microcontrollers\n *\n * Copyright (C) 2013 Gordon Williams <gw@pur3.co.uk>\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n *\n * ----------------------------------------------------------------------------\n * Variables\n * ----------------------------------------------------------------------------\n */\n#include \"jsvar.h\"\n#include \"jslex.h\"\n#include \"jsparse.h\"\n#include \"jswrap_json.h\"\n#include \"jsinteractive.h\"\n#include \"jswrapper.h\"\n#include \"jswrap_math.h\" // for jswrap_math_mod\n#include \"jswrap_object.h\" // for jswrap_object_toString\n#include \"jswrap_arraybuffer.h\" // for jsvNewTypedArray\n#include \"jswrap_dataview.h\" // for jsvNewDataViewWithData\n\n#ifdef DEBUG\n  /** When freeing, clear the references (nextChild/etc) in the JsVar.\n   * This means we can assert at the end of jsvFreePtr to make sure\n   * everything really is free. */\n  #define CLEAR_MEMORY_ON_FREE\n#endif\n\n/** Basically, JsVars are stored in one big array, so save the need for\n * lots of memory allocation. On Linux, the arrays are in blocks, so that\n * more blocks can be allocated. We can't use realloc on one big block as\n * this may change the address of vars that are already locked!\n *\n */\n\n#ifdef RESIZABLE_JSVARS\nJsVar **jsVarBlocks = 0;\nunsigned int jsVarsSize = 0;\n#define JSVAR_BLOCK_SIZE 4096\n#define JSVAR_BLOCK_SHIFT 12\n#else\n#ifdef JSVAR_MALLOC\nunsigned int jsVarsSize = 0;\nJsVar *jsVars = NULL;\n#else\nJsVar jsVars[JSVAR_CACHE_SIZE] __attribute__((aligned(4)));\nunsigned int jsVarsSize = JSVAR_CACHE_SIZE;\n#endif\n#endif\n\ntypedef enum {\n  MEM_NOT_BUSY,\n  MEMBUSY_SYSTEM,\n  MEMBUSY_GC\n} MemBusyType;\n\nvolatile bool touchedFreeList = false;\nvolatile JsVarRef jsVarFirstEmpty; ///< reference of first unused variable (variables are in a linked list)\nvolatile MemBusyType isMemoryBusy; ///< Are we doing garbage collection or similar, so can't access memory?\n\n// ----------------------------------------------------------------------------\n// ----------------------------------------------------------------------------\n\nJsVarRef jsvGetFirstChild(const JsVar *v) { return v->varData.ref.firstChild; }\nJsVarRefSigned jsvGetFirstChildSigned(const JsVar *v) {\n  if (v->varData.ref.firstChild > JSVARREF_MAX)\n    return ((JsVarRefSigned)v->varData.ref.firstChild) + JSVARREF_MIN*2;\n  return (JsVarRefSigned)v->varData.ref.firstChild;\n}\nJsVarRef jsvGetLastChild(const JsVar *v) { return v->varData.ref.lastChild; }\nJsVarRef jsvGetNextSibling(const JsVar *v) { return v->varData.ref.nextSibling; }\nJsVarRef jsvGetPrevSibling(const JsVar *v) { return v->varData.ref.prevSibling; }\nvoid jsvSetFirstChild(JsVar *v, JsVarRef r) { v->varData.ref.firstChild = r; }\nvoid jsvSetLastChild(JsVar *v, JsVarRef r) { v->varData.ref.lastChild = r; }\nvoid jsvSetNextSibling(JsVar *v, JsVarRef r) { v->varData.ref.nextSibling = r; }\nvoid jsvSetPrevSibling(JsVar *v, JsVarRef r) { v->varData.ref.prevSibling = r; }\n\nJsVarRefCounter jsvGetRefs(JsVar *v) { return v->varData.ref.refs; }\nvoid jsvSetRefs(JsVar *v, JsVarRefCounter refs) { v->varData.ref.refs = refs; }\nunsigned char jsvGetLocks(JsVar *v) { return (unsigned char)((v->flags>>JSV_LOCK_SHIFT) & JSV_LOCK_MAX); }\n\nbool jsvIsRoot(const JsVar *v) { return v && (v->flags&JSV_VARTYPEMASK)==JSV_ROOT; }\nbool jsvIsPin(const JsVar *v) { return v && (v->flags&JSV_VARTYPEMASK)==JSV_PIN; }\nbool jsvIsSimpleInt(const JsVar *v) { return v && (v->flags&JSV_VARTYPEMASK)==JSV_INTEGER; } // is just a very basic integer value\nbool jsvIsInt(const JsVar *v) { return v && ((v->flags&JSV_VARTYPEMASK)==JSV_INTEGER || (v->flags&JSV_VARTYPEMASK)==JSV_PIN || (v->flags&JSV_VARTYPEMASK)==JSV_NAME_INT || (v->flags&JSV_VARTYPEMASK)==JSV_NAME_INT_INT || (v->flags&JSV_VARTYPEMASK)==JSV_NAME_INT_BOOL); }\nbool jsvIsFloat(const JsVar *v) { return v && (v->flags&JSV_VARTYPEMASK)==JSV_FLOAT; }\nbool jsvIsBoolean(const JsVar *v) { return v && ((v->flags&JSV_VARTYPEMASK)==JSV_BOOLEAN || (v->flags&JSV_VARTYPEMASK)==JSV_NAME_INT_BOOL); }\nbool jsvIsString(const JsVar *v) { return v && (v->flags&JSV_VARTYPEMASK)>=_JSV_STRING_START && (v->flags&JSV_VARTYPEMASK)<=_JSV_STRING_END; } ///< String, or a NAME too\nbool jsvIsBasicString(const JsVar *v) { return v && (v->flags&JSV_VARTYPEMASK)>=JSV_STRING_0 && (v->flags&JSV_VARTYPEMASK)<=JSV_STRING_MAX; } ///< Just a string (NOT a name/flatstr/nativestr or flashstr)\nbool jsvIsStringExt(const JsVar *v) { return v && (v->flags&JSV_VARTYPEMASK)>=JSV_STRING_EXT_0 && (v->flags&JSV_VARTYPEMASK)<=JSV_STRING_EXT_MAX; } ///< The extra bits dumped onto the end of a string to store more data\nbool jsvIsFlatString(const JsVar *v) { return v && (v->flags&JSV_VARTYPEMASK)==JSV_FLAT_STRING; }\nbool jsvIsNativeString(const JsVar *v) { return v && (v->flags&JSV_VARTYPEMASK)==JSV_NATIVE_STRING; }\nbool jsvIsFlashString(const JsVar *v) {\n#ifdef SPIFLASH_BASE\n  return v && (v->flags&JSV_VARTYPEMASK)==JSV_FLASH_STRING;\n#else\n  return false;\n#endif\n}\nbool jsvIsNumeric(const JsVar *v) { return v && (v->flags&JSV_VARTYPEMASK)>=_JSV_NUMERIC_START && (v->flags&JSV_VARTYPEMASK)<=_JSV_NUMERIC_END; }\nbool jsvIsFunction(const JsVar *v) { return v && ((v->flags&JSV_VARTYPEMASK)==JSV_FUNCTION || (v->flags&JSV_VARTYPEMASK)==JSV_FUNCTION_RETURN || (v->flags&JSV_VARTYPEMASK)==JSV_NATIVE_FUNCTION); }\nbool jsvIsFunctionReturn(const JsVar *v) { return v && ((v->flags&JSV_VARTYPEMASK)==JSV_FUNCTION_RETURN); } ///< Is this a function with an implicit 'return' at the start?\nbool jsvIsFunctionParameter(const JsVar *v) { return v && (v->flags&JSV_NATIVE) && jsvIsString(v); }\nbool jsvIsObject(const JsVar *v) { return v && (((v->flags&JSV_VARTYPEMASK)==JSV_OBJECT) || ((v->flags&JSV_VARTYPEMASK)==JSV_ROOT)); }\nbool jsvIsArray(const JsVar *v) { return v && (v->flags&JSV_VARTYPEMASK)==JSV_ARRAY; }\nbool jsvIsArrayBuffer(const JsVar *v) { return v && (v->flags&JSV_VARTYPEMASK)==JSV_ARRAYBUFFER; }\nbool jsvIsArrayBufferName(const JsVar *v) { return v && (v->flags&(JSV_VARTYPEMASK))==JSV_ARRAYBUFFERNAME; }\nbool jsvIsNativeFunction(const JsVar *v) { return v && (v->flags&(JSV_VARTYPEMASK))==JSV_NATIVE_FUNCTION; }\nbool jsvIsUndefined(const JsVar *v) { return v==0; }\nbool jsvIsNull(const JsVar *v) { return v && (v->flags&JSV_VARTYPEMASK)==JSV_NULL; }\nbool jsvIsBasic(const JsVar *v) { return jsvIsNumeric(v) || jsvIsString(v);} ///< Is this *not* an array/object/etc\nbool jsvIsName(const JsVar *v) { return v && (v->flags&JSV_VARTYPEMASK)>=_JSV_NAME_START && (v->flags&JSV_VARTYPEMASK)<=_JSV_NAME_END; } ///< NAMEs are what's used to name a variable (it is not the data itself)\nbool jsvIsBasicName(const JsVar *v) { return v && (v->flags&JSV_VARTYPEMASK)>=JSV_NAME_STRING_0 && (v->flags&JSV_VARTYPEMASK)<=JSV_NAME_STRING_MAX; } ///< Simple NAME that links to a variable via firstChild\n/// Names with values have firstChild set to a value - AND NOT A REFERENCE\nbool jsvIsNameWithValue(const JsVar *v) { return v && (v->flags&JSV_VARTYPEMASK)>=_JSV_NAME_WITH_VALUE_START && (v->flags&JSV_VARTYPEMASK)<=_JSV_NAME_WITH_VALUE_END; }\nbool jsvIsNameInt(const JsVar *v) { return v && ((v->flags&JSV_VARTYPEMASK)==JSV_NAME_INT_INT || ((v->flags&JSV_VARTYPEMASK)>=JSV_NAME_STRING_INT_0 && (v->flags&JSV_VARTYPEMASK)<=JSV_NAME_STRING_INT_MAX)); } ///< Is this a NAME pointing to an Integer value\nbool jsvIsNameIntInt(const JsVar *v) { return v && (v->flags&JSV_VARTYPEMASK)==JSV_NAME_INT_INT; }\nbool jsvIsNameIntBool(const JsVar *v) { return v && (v->flags&JSV_VARTYPEMASK)==JSV_NAME_INT_BOOL; }\n/// What happens when we access a variable that doesn't exist. We get a NAME where the next + previous siblings point to the object that may one day contain them\nbool jsvIsNewChild(const JsVar *v) { return jsvIsName(v) && jsvGetNextSibling(v) && jsvGetNextSibling(v)==jsvGetPrevSibling(v); }\n/// Returns true if v is a getter/setter\nbool jsvIsGetterOrSetter(const JsVar *v) {\n#ifdef SAVE_ON_FLASH\n  return false;\n#else\n  return v && (v->flags&JSV_VARTYPEMASK)==JSV_GET_SET;\n#endif\n}\n/// Are var.varData.ref.* (excl pad) used for data (so we expect them not to be empty)\nbool jsvIsRefUsedForData(const JsVar *v) { return jsvIsStringExt(v) || (jsvIsString(v)&&!jsvIsName(v)) ||  jsvIsFloat(v) || jsvIsNativeFunction(v) || jsvIsArrayBuffer(v) || jsvIsArrayBufferName(v); }\n\n/// Can the given variable be converted into an integer without loss of precision\nbool jsvIsIntegerish(const JsVar *v) { return jsvIsInt(v) || jsvIsPin(v) || jsvIsBoolean(v) || jsvIsNull(v); }\n\nbool jsvIsIterable(const JsVar *v) {\n  return jsvIsArray(v) || jsvIsObject(v) || jsvIsFunction(v) ||\n         jsvIsString(v) || jsvIsArrayBuffer(v);\n}\n\n// ----------------------------------------------------------------------------\n// ----------------------------------------------------------------------------\n\n\n/** Return a pointer - UNSAFE for null refs.\n * This is effectively a Lock without locking! */\nstatic ALWAYS_INLINE JsVar *jsvGetAddressOf(JsVarRef ref) {\n  assert(ref);\n#ifdef RESIZABLE_JSVARS\n  assert(ref <= jsVarsSize);\n  JsVarRef t = ref-1;\n  return &jsVarBlocks[t>>JSVAR_BLOCK_SHIFT][t&(JSVAR_BLOCK_SIZE-1)];\n#elif defined(JSVAR_MALLOC)\n  assert(ref <= jsVarsSize);\n  return &jsVars[ref-1];\n#else\n  assert(ref <= JSVAR_CACHE_SIZE);\n  return &jsVars[ref-1];\n#endif\n}\n\nJsVar *_jsvGetAddressOf(JsVarRef ref) {\n  return jsvGetAddressOf(ref);\n}\n\n// For debugging/testing ONLY - maximum # of vars we are allowed to use\nvoid jsvSetMaxVarsUsed(unsigned int size) {\n#ifdef RESIZABLE_JSVARS\n  assert(size < JSVAR_BLOCK_SIZE); // remember - this is only for DEBUGGING - as such it doesn't use multiple blocks\n#else\n  assert(size < JSVAR_CACHE_SIZE);\n#endif\n  jsVarsSize = size;\n}\n\n// maps the empty variables in...\nvoid jsvCreateEmptyVarList() {\n  assert(!isMemoryBusy);\n  isMemoryBusy = MEMBUSY_SYSTEM;\n  jsVarFirstEmpty = 0;\n  JsVar firstVar; // temporary var to simplify code in the loop below\n  jsvSetNextSibling(&firstVar, 0);\n  JsVar *lastEmpty = &firstVar;\n\n  JsVarRef i;\n  for (i=1;i<=jsVarsSize;i++) {\n    JsVar *var = jsvGetAddressOf(i);\n    if ((var->flags&JSV_VARTYPEMASK) == JSV_UNUSED) {\n      jsvSetNextSibling(lastEmpty, i);\n      lastEmpty = var;\n    } else if (jsvIsFlatString(var)) {\n      // skip over used blocks for flat strings\n      i = (JsVarRef)(i+jsvGetFlatStringBlocks(var));\n    }\n  }\n  jsvSetNextSibling(lastEmpty, 0);\n  jsVarFirstEmpty = jsvGetNextSibling(&firstVar);\n  isMemoryBusy = MEM_NOT_BUSY;\n}\n\n/* Removes the empty variable counter, cleaving clear runs of 0s\n where no data resides. This helps if compressing the variables\n for storage. */\nvoid jsvClearEmptyVarList() {\n  assert(!isMemoryBusy);\n  isMemoryBusy = MEMBUSY_SYSTEM;\n  jsVarFirstEmpty = 0;\n  JsVarRef i;\n  for (i=1;i<=jsVarsSize;i++) {\n    JsVar *var = jsvGetAddressOf(i);\n    if ((var->flags&JSV_VARTYPEMASK) == JSV_UNUSED) {\n      // completely zero it (JSV_UNUSED==0, so it still stays the same)\n      memset((void*)var,0,sizeof(JsVar));\n    } else if (jsvIsFlatString(var)) {\n      // skip over used blocks for flat strings\n      i = (JsVarRef)(i+jsvGetFlatStringBlocks(var));\n    }\n  }\n  isMemoryBusy = MEM_NOT_BUSY;\n}\n\nvoid jsvSoftInit() {\n  jsvCreateEmptyVarList();\n}\n\nvoid jsvSoftKill() {\n  jsvClearEmptyVarList();\n}\n\n/** This links all JsVars together, so we can have our nice\n * linked list of free JsVars. It returns the ref of the first\n * item - that we should set jsVarFirstEmpty to (if it is 0) */\nstatic JsVarRef jsvInitJsVars(JsVarRef start, unsigned int count) {\n  JsVarRef i;\n  for (i=start;i<start+count;i++) {\n    JsVar *v = jsvGetAddressOf(i);\n    v->flags = JSV_UNUSED;\n    // v->locks = 0; // locks is 0 anyway because it is stored in flags\n    jsvSetNextSibling(v, (JsVarRef)(i+1)); // link to next\n  }\n  jsvSetNextSibling(jsvGetAddressOf((JsVarRef)(start+count-1)), (JsVarRef)0); // set the final one to 0\n  return start;\n}\n\nvoid jsvInit(unsigned int size) {\n#ifdef RESIZABLE_JSVARS\n  assert(size==0);\n  jsVarsSize = JSVAR_BLOCK_SIZE;\n  jsVarBlocks = malloc(sizeof(JsVar*)); // just 1\n  jsVarBlocks[0] = malloc(sizeof(JsVar) * JSVAR_BLOCK_SIZE);\n#elif defined(JSVAR_MALLOC)\n  if (size) jsVarsSize = size;\n  if(!jsVars) jsVars = (JsVar *)malloc(sizeof(JsVar) * jsVarsSize);\n#else\n  assert(size==0);\n#endif\n\n  jsVarFirstEmpty = jsvInitJsVars(1/*first*/, jsVarsSize);\n  jsvSoftInit();\n}\n\nvoid jsvKill() {\n#ifdef RESIZABLE_JSVARS\n  unsigned int i;\n  for (i=0;i<jsVarsSize>>JSVAR_BLOCK_SHIFT;i++)\n    free(jsVarBlocks[i]);\n  free(jsVarBlocks);\n  jsVarBlocks = 0;\n  jsVarsSize = 0;\n#endif\n}\n\n/** Find or create the ROOT variable item - used mainly\n * if recovering from a saved state. */\nJsVar *jsvFindOrCreateRoot() {\n  JsVarRef i;\n  for (i=1;i<=jsVarsSize;i++)\n    if (jsvIsRoot(jsvGetAddressOf(i)))\n      return jsvLock(i);\n\n  return jsvRef(jsvNewWithFlags(JSV_ROOT));\n}\n\n/// Get number of memory records (JsVars) used\nunsigned int jsvGetMemoryUsage() {\n  unsigned int usage = 0;\n  for (unsigned int i=1;i<=jsVarsSize;i++) {\n    JsVar *v = jsvGetAddressOf((JsVarRef)i);\n    if ((v->flags&JSV_VARTYPEMASK) != JSV_UNUSED) {\n      usage++;\n      if (jsvIsFlatString(v)) {\n        unsigned int b = (unsigned int)jsvGetFlatStringBlocks(v);\n        i+=b;\n        usage+=b;\n      }\n    }\n  }\n  return usage;\n}\n\n/// Get total amount of memory records\nunsigned int jsvGetMemoryTotal() {\n  return jsVarsSize;\n}\n\n/// Try and allocate more memory - only works if RESIZABLE_JSVARS is defined\nvoid jsvSetMemoryTotal(unsigned int jsNewVarCount) {\n#ifdef RESIZABLE_JSVARS\n  assert(!isMemoryBusy);\n  if (jsNewVarCount <= jsVarsSize) return; // never allow us to have less!\n  isMemoryBusy = MEMBUSY_SYSTEM;\n  // When resizing, we just allocate a bunch more\n  unsigned int oldSize = jsVarsSize;\n  unsigned int oldBlockCount = jsVarsSize >> JSVAR_BLOCK_SHIFT;\n  unsigned int newBlockCount = (jsNewVarCount+JSVAR_BLOCK_SIZE-1) >> JSVAR_BLOCK_SHIFT;\n  jsVarsSize = newBlockCount << JSVAR_BLOCK_SHIFT;\n  // resize block table\n  jsVarBlocks = realloc(jsVarBlocks, sizeof(JsVar*)*newBlockCount);\n  // allocate more blocks\n  unsigned int i;\n  for (i=oldBlockCount;i<newBlockCount;i++)\n    jsVarBlocks[i] = malloc(sizeof(JsVar) * JSVAR_BLOCK_SIZE);\n  /** and now reset all the newly allocated vars. We know jsVarFirstEmpty\n   * is 0 (because jsiFreeMoreMemory returned 0) so we can just assign it.  */\n  assert(!jsVarFirstEmpty);\n  jsVarFirstEmpty = jsvInitJsVars(oldSize+1, jsVarsSize-oldSize);\n  // jsiConsolePrintf(\"Resized memory from %d blocks to %d\\n\", oldBlockCount, newBlockCount);\n  touchedFreeList = true;\n  isMemoryBusy = MEM_NOT_BUSY;\n#else\n  NOT_USED(jsNewVarCount);\n  assert(0);\n#endif\n}\n\n/// Scan memory to find any JsVar that references a specific memory range, and if so update what it points to to p[oint to the new address\nvoid jsvUpdateMemoryAddress(size_t oldAddr, size_t length, size_t newAddr) {\n  for (unsigned int i=1;i<=jsVarsSize;i++) {\n    JsVar *v = jsvGetAddressOf((JsVarRef)i);\n    if (jsvIsNativeString(v) || jsvIsFlashString(v)) {\n      size_t p = (size_t)v->varData.nativeStr.ptr;\n      if (p>=oldAddr && p<oldAddr+length)\n        v->varData.nativeStr.ptr = (char*)(p+newAddr-oldAddr);\n    } else if (jsvIsFlatString(v)) {\n      i += (unsigned int)jsvGetFlatStringBlocks(v);\n    }\n  }\n}\n\nbool jsvMoreFreeVariablesThan(unsigned int vars) {\n  if (!vars) return false;\n  JsVarRef r = jsVarFirstEmpty;\n  while (r) {\n    if (!vars--) return true;\n    r = jsvGetNextSibling(jsvGetAddressOf(r));\n  }\n  return false;\n}\n\n/// Get whether memory is full or not\nbool jsvIsMemoryFull() {\n  return !jsVarFirstEmpty;\n}\n\n// Show what is still allocated, for debugging memory problems\nvoid jsvShowAllocated() {\n  JsVarRef i;\n  for (i=1;i<=jsVarsSize;i++) {\n    if ((jsvGetAddressOf(i)->flags&JSV_VARTYPEMASK) != JSV_UNUSED) {\n      jsiConsolePrintf(\"USED VAR #%d:\",i);\n      jsvTrace(jsvGetAddressOf(i), 2);\n    }\n  }\n}\n\nbool jsvHasCharacterData(const JsVar *v) {\n  return jsvIsString(v) || jsvIsStringExt(v);\n}\n\nbool jsvHasStringExt(const JsVar *v) {\n  return jsvIsString(v) || jsvIsStringExt(v);\n}\n\nbool jsvHasChildren(const JsVar *v) {\n  return jsvIsFunction(v) || jsvIsObject(v) || jsvIsArray(v) || jsvIsRoot(v) || jsvIsGetterOrSetter(v);\n}\n\n/// Is this variable a type that uses firstChild to point to a single Variable (ie. it doesn't have multiple children)\nbool jsvHasSingleChild(const JsVar *v) {\n  return jsvIsArrayBuffer(v) ||\n      (jsvIsName(v) && !jsvIsNameWithValue(v));\n}\n\n/** Return the is the number of characters this one JsVar can contain, NOT string length (eg, a chain of JsVars)\n * This will return an invalid length when applied to Flat Strings */\nsize_t jsvGetMaxCharactersInVar(const JsVar *v) {\n  // see jsvCopy - we need to know about this in there too\n  if (jsvIsStringExt(v)) return JSVAR_DATA_STRING_MAX_LEN;\n  assert(jsvHasCharacterData(v));\n  if (jsvIsName(v)) return JSVAR_DATA_STRING_NAME_LEN;\n  return JSVAR_DATA_STRING_LEN;\n}\n\n/// This is the number of characters a JsVar can contain, NOT string length\nsize_t jsvGetCharactersInVar(const JsVar *v) {\n  unsigned int f = v->flags&JSV_VARTYPEMASK;\n  if (f == JSV_FLAT_STRING)\n    return (size_t)v->varData.integer;\n  if ((f == JSV_NATIVE_STRING)\n#ifdef SPIFLASH_BASE\n  || (f == JSV_FLASH_STRING)\n#endif\n      )\n    return (size_t)v->varData.nativeStr.len;\n\n  assert(f >= JSV_NAME_STRING_INT_0);\n  assert((JSV_NAME_STRING_INT_0 < JSV_NAME_STRING_0) &&\n         (JSV_NAME_STRING_0 < JSV_STRING_0) &&\n         (JSV_STRING_0 < JSV_STRING_EXT_0)); // this relies on ordering\n  if (f<=JSV_NAME_STRING_MAX) {\n    if (f<=JSV_NAME_STRING_INT_MAX)\n      return f-JSV_NAME_STRING_INT_0;\n    else\n      return f-JSV_NAME_STRING_0;\n  } else {\n    if (f<=JSV_STRING_MAX) return f-JSV_STRING_0;\n    assert(f <= JSV_STRING_EXT_MAX);\n    return f - JSV_STRING_EXT_0;\n  }\n}\n\n/// This is the number of characters a JsVar can contain, NOT string length\nvoid jsvSetCharactersInVar(JsVar *v, size_t chars) {\n  unsigned int f = v->flags&JSV_VARTYPEMASK;\n  assert(!(jsvIsFlatString(v) || jsvIsNativeString(v) || jsvIsFlashString(v)));\n\n  JsVarFlags m = (JsVarFlags)(v->flags&~JSV_VARTYPEMASK);\n  assert(f >= JSV_NAME_STRING_INT_0);\n  assert((JSV_NAME_STRING_INT_0 < JSV_NAME_STRING_0) &&\n         (JSV_NAME_STRING_0 < JSV_STRING_0) &&\n         (JSV_STRING_0 < JSV_STRING_EXT_0)); // this relies on ordering\n  if (f<=JSV_NAME_STRING_MAX) {\n    assert(chars <= JSVAR_DATA_STRING_NAME_LEN);\n    if (f<=JSV_NAME_STRING_INT_MAX)\n      v->flags = (JsVarFlags)(m | (JSV_NAME_STRING_INT_0+chars));\n    else\n      v->flags = (JsVarFlags)(m | (JSV_NAME_STRING_0+chars));\n  } else {\n    if (f<=JSV_STRING_MAX) {\n      assert(chars <= JSVAR_DATA_STRING_LEN);\n      v->flags = (JsVarFlags)(m | (JSV_STRING_0+chars));\n    } else {\n      assert(chars <= JSVAR_DATA_STRING_MAX_LEN);\n      assert(f <= JSV_STRING_EXT_MAX);\n      v->flags = (JsVarFlags)(m | (JSV_STRING_EXT_0+chars));\n    }\n  }\n}\n\nvoid jsvResetVariable(JsVar *v, JsVarFlags flags) {\n  assert((v->flags&JSV_VARTYPEMASK) == JSV_UNUSED);\n  // make sure we clear all data...\n  /* Force a proper zeroing of all data. We don't use\n   * memset because that'd create a function call. This\n   * should just generate a bunch of STR instructions */\n  unsigned int i;\n  if ((sizeof(JsVar)&3) == 0) {\n    for (i=0;i<sizeof(JsVar)/sizeof(uint32_t);i++)\n      ((uint32_t*)v)[i] = 0;\n  } else { // just fall back to bytes and hope it's smart enough\n    for (i=0;i<sizeof(JsVar);i++)\n      ((uint8_t*)v)[i] = 0;\n  }\n  // set flags\n  assert(!(flags & JSV_LOCK_MASK));\n  v->flags = flags | JSV_LOCK_ONE;\n}\n\nJsVar *jsvNewWithFlags(JsVarFlags flags) {\n  if (isMemoryBusy) {\n    jsErrorFlags |= JSERR_MEMORY_BUSY;\n    return 0;\n  }\n  JsVar *v = 0;\n  jshInterruptOff(); // to allow this to be used from an IRQ\n  if (jsVarFirstEmpty!=0) {\n    v = jsvGetAddressOf(jsVarFirstEmpty); // jsvResetVariable will lock\n    jsVarFirstEmpty = jsvGetNextSibling(v); // move our reference to the next in the free list\n    touchedFreeList = true;\n  }\n  jshInterruptOn();\n  if (v) {\n    assert(v->flags == JSV_UNUSED);\n    // Cope with IRQs/multi-threading when getting a new free variable\n /*   JsVarRef empty;\n    JsVarRef next;\n    JsVar *v;\n    do {\n      empty = jsVarFirstEmpty;\n      v = jsvGetAddressOf(empty); // jsvResetVariable will lock\n      next = jsvGetNextSibling(v); // move our reference to the next in the free list\n      touchedFreeList = true;\n    } while (!__sync_bool_compare_and_swap(&jsVarFirstEmpty, empty, next));\n    assert(v->flags == JSV_UNUSED);*/\n    jsvResetVariable(v, flags); // setup variable, and add one lock\n    // return pointer\n    return v;\n  }\n  jsErrorFlags |= JSERR_LOW_MEMORY;\n  /* If we're calling from an IRQ, do NOT try and do fancy\n   * stuff to free memory */\n  if (jshIsInInterrupt()) {\n    return 0;\n  }\n  /* we don't have memory - second last hope - run garbage collector */\n  if (jsvGarbageCollect()) {\n    return jsvNewWithFlags(flags); // if it freed something, continue\n  }\n  /* we don't have memory - last hope - ask jsInteractive to try and free some it\n   may have kicking around */\n  if (jsiFreeMoreMemory()) {\n    return jsvNewWithFlags(flags);\n  }\n  /* We couldn't claim any more memory by Garbage collecting... */\n#ifdef RESIZABLE_JSVARS\n  jsvSetMemoryTotal(jsVarsSize*2);\n  return jsvNewWithFlags(flags);\n#else\n  // On a micro, we're screwed.\n  jsErrorFlags |= JSERR_MEMORY;\n  jspSetInterrupted(true);\n  return 0;\n#endif\n}\n\nstatic void jsvFreePtrInternal(JsVar *var) {\n  assert(jsvGetLocks(var)==0);\n  var->flags = JSV_UNUSED;\n  // add this to our free list\n  jshInterruptOff(); // to allow this to be used from an IRQ\n  jsvSetNextSibling(var, jsVarFirstEmpty);\n  jsVarFirstEmpty = jsvGetRef(var);\n  touchedFreeList = true;\n  jshInterruptOn();\n}\n\nALWAYS_INLINE void jsvFreePtr(JsVar *var) {\n  /* To be here, we're not supposed to be part of anything else. If\n   * we were, we'd have been freed by jsvGarbageCollect */\n  assert((!jsvGetNextSibling(var) && !jsvGetPrevSibling(var)) || // check that next/prevSibling are not set\n      jsvIsRefUsedForData(var) ||  // UNLESS we're part of a string and nextSibling/prevSibling are used for string data\n      (jsvIsName(var) && (jsvGetNextSibling(var)==jsvGetPrevSibling(var)))); // UNLESS we're signalling that we're jsvild\n\n  // Names that Link to other things\n  if (jsvIsNameWithValue(var)) {\n#ifdef CLEAR_MEMORY_ON_FREE\n    jsvSetFirstChild(var, 0); // it just contained random data - zero it\n#endif // CLEAR_MEMORY_ON_FREE\n  } else if (jsvHasSingleChild(var)) {\n    if (jsvGetFirstChild(var)) {\n      JsVar *child = jsvLock(jsvGetFirstChild(var));\n      jsvUnRef(child);\n#ifdef CLEAR_MEMORY_ON_FREE\n      jsvSetFirstChild(var, 0); // unlink the child\n#endif // CLEAR_MEMORY_ON_FREE\n      jsvUnLock(child); // unlock should trigger a free\n    }\n  }\n  /* No else, because a String Name may have a single child, but\n   * also StringExts  */\n\n  /* Now, free children - see jsvar.h comments for how! */\n  if (jsvHasStringExt(var)) {\n    // Free the string without recursing\n    JsVarRef stringDataRef = jsvGetLastChild(var);\n#ifdef CLEAR_MEMORY_ON_FREE\n    jsvSetLastChild(var, 0);\n#endif // CLEAR_MEMORY_ON_FREE\n    while (stringDataRef) {\n      JsVar *child = jsvGetAddressOf(stringDataRef);\n      assert(jsvIsStringExt(child));\n      stringDataRef = jsvGetLastChild(child);\n      jsvFreePtrInternal(child);\n    }\n    // We might be a flat string\n    if (jsvIsFlatString(var)) {\n      // in which case we need to free all the blocks.\n      size_t count = jsvGetFlatStringBlocks(var);\n      JsVarRef i = (JsVarRef)(jsvGetRef(var)+count);\n      // Because this is a whole bunch of blocks, try\n      // and insert it in the right place in the free list\n      // So, iterate along free list to figure out where we\n      // need to insert the free items\n      jshInterruptOff(); // to allow this to be used from an IRQ\n      JsVarRef insertBefore = jsVarFirstEmpty;\n      JsVarRef insertAfter = 0;\n      while (insertBefore && insertBefore<i) {\n        insertAfter = insertBefore;\n        insertBefore = jsvGetNextSibling(jsvGetAddressOf(insertBefore));\n      }\n      // free in reverse, so the free list ends up in kind of the right order\n      while (count--) {\n        JsVar *p = jsvGetAddressOf(i--);\n        p->flags = JSV_UNUSED; // set locks to 0 so the assert in jsvFreePtrInternal doesn't get fed up\n        // add this to our free list\n        jsvSetNextSibling(p, insertBefore);\n        insertBefore = jsvGetRef(p);\n      }\n      // patch up jsVarFirstEmpty/rejoin the list\n      if (insertAfter)\n        jsvSetNextSibling(jsvGetAddressOf(insertAfter), insertBefore);\n      else\n        jsVarFirstEmpty = insertBefore;\n      touchedFreeList = true;\n      jshInterruptOn();\n    } else if (jsvIsBasicString(var)) {\n#ifdef CLEAR_MEMORY_ON_FREE\n      jsvSetFirstChild(var, 0); // firstchild could have had string data in\n#endif // CLEAR_MEMORY_ON_FREE\n    }\n\n  }\n  /* NO ELSE HERE - because jsvIsNewChild stuff can be for Names, which\n    can be ints or strings */\n\n  if (jsvHasChildren(var)) {\n    JsVarRef childref = jsvGetFirstChild(var);\n#ifdef CLEAR_MEMORY_ON_FREE\n    jsvSetFirstChild(var, 0);\n    jsvSetLastChild(var, 0);\n#endif // CLEAR_MEMORY_ON_FREE\n    while (childref) {\n      JsVar *child = jsvLock(childref);\n      assert(jsvIsName(child));\n      childref = jsvGetNextSibling(child);\n      jsvSetPrevSibling(child, 0);\n      jsvSetNextSibling(child, 0);\n      jsvUnRef(child);\n      jsvUnLock(child);\n    }\n  } else {\n#ifdef CLEAR_MEMORY_ON_FREE\n    assert(jsvIsFloat(var) || !jsvGetFirstChild(var));\n    assert(jsvIsFloat(var) || !jsvGetLastChild(var));\n#endif // CLEAR_MEMORY_ON_FREE\n    if (jsvIsName(var)) {\n      assert(jsvGetNextSibling(var)==jsvGetPrevSibling(var)); // the case for jsvIsNewChild\n      if (jsvGetNextSibling(var)) {\n        jsvUnRefRef(jsvGetNextSibling(var));\n        jsvUnRefRef(jsvGetPrevSibling(var));\n      }\n    }\n  }\n\n  // free!\n  jsvFreePtrInternal(var);\n}\n\n/// Get a reference from a var - SAFE for null vars\nJsVarRef jsvGetRef(JsVar *var) {\n  if (!var) return 0;\n#ifdef RESIZABLE_JSVARS\n  unsigned int i, c = jsVarsSize>>JSVAR_BLOCK_SHIFT;\n  for (i=0;i<c;i++) {\n    if (var>=jsVarBlocks[i] && var<&jsVarBlocks[i][JSVAR_BLOCK_SIZE]) {\n      JsVarRef r = (JsVarRef)(1 + (i<<JSVAR_BLOCK_SHIFT) + (var - jsVarBlocks[i]));\n      return r;\n    }\n  }\n  return 0;\n#else\n  return (JsVarRef)(1 + (var - jsVars));\n#endif\n}\n\n/// Lock this reference and return a pointer - UNSAFE for null refs\nJsVar *jsvLock(JsVarRef ref) {\n  JsVar *var = jsvGetAddressOf(ref);\n  //var->locks++;\n  assert(jsvGetLocks(var) < JSV_LOCK_MAX);\n  var->flags += JSV_LOCK_ONE;\n#ifdef DEBUG\n  if (jsvGetLocks(var)==0) {\n    jsError(\"Too many locks to Variable!\");\n    //jsPrint(\"Var #\");jsPrintInt(ref);jsPrint(\"\\n\");\n  }\n#endif\n  return var;\n}\n\n/// Lock this reference and return a pointer - UNSAFE for null refs\nJsVar *jsvLockSafe(JsVarRef ref) {\n  if (!ref) return 0;\n  return jsvLock(ref);\n}\n\n/// Lock this pointer and return a pointer - UNSAFE for null pointer\nJsVar *jsvLockAgain(JsVar *var) {\n  assert(var);\n  assert(jsvGetLocks(var) < JSV_LOCK_MAX);\n  var->flags += JSV_LOCK_ONE;\n  return var;\n}\n\n/// Lock this pointer and return a pointer - UNSAFE for null pointer\nJsVar *jsvLockAgainSafe(JsVar *var) {\n  return var ? jsvLockAgain(var) : 0;\n}\n\n// CALL ONLY FROM jsvUnlock\n// jsvGetLocks(var) must == 0\nstatic NO_INLINE void jsvUnLockFreeIfNeeded(JsVar *var) {\n  assert(jsvGetLocks(var) == 0);\n  /* if we know we're free, then we can just free this variable right now.\n   * Loops of variables are handled by the Garbage Collector.\n   * Note: we checked locks already in jsvUnLock as it is fastest to check */\n  if (jsvGetRefs(var) == 0 &&\n      jsvHasRef(var) &&\n      (var->flags&JSV_VARTYPEMASK)!=JSV_UNUSED) { // we might be in an IRQ now, with GC in the main thread. If so, don't free!\n    jsvFreePtr(var);\n  }\n}\n\n\n/// Unlock this variable - this is SAFE for null variables\nvoid jsvUnLock(JsVar *var) {\n  if (!var) return;\n  assert(jsvGetLocks(var)>0);\n  var->flags -= JSV_LOCK_ONE;\n  // Now see if we can properly free the data\n  // Note: we check locks first as they are already in a register\n  if ((var->flags & JSV_LOCK_MASK) == 0) jsvUnLockFreeIfNeeded(var);\n}\n\n/// Unlock 2 variables in one go\nvoid jsvUnLock2(JsVar *var1, JsVar *var2) {\n  jsvUnLock(var1);\n  jsvUnLock(var2);\n}\n/// Unlock 3 variables in one go\nvoid jsvUnLock3(JsVar *var1, JsVar *var2, JsVar *var3) {\n  jsvUnLock(var1);\n  jsvUnLock(var2);\n  jsvUnLock(var3);\n}\n/// Unlock 4 variables in one go\nvoid jsvUnLock4(JsVar *var1, JsVar *var2, JsVar *var3, JsVar *var4) {\n  jsvUnLock(var1);\n  jsvUnLock(var2);\n  jsvUnLock(var3);\n  jsvUnLock(var4);\n}\n\n/// Unlock an array of variables\nNO_INLINE void jsvUnLockMany(unsigned int count, JsVar **vars) {\n  while (count) jsvUnLock(vars[--count]);\n}\n\n/// Reference - set this variable as used by something\nJsVar *jsvRef(JsVar *var) {\n  assert(var && jsvHasRef(var));\n  if (jsvGetRefs(var) < JSVARREFCOUNT_MAX) // if we hit max refcounts, just keep them - GC will fix it later\n    jsvSetRefs(var, (JsVarRefCounter)(jsvGetRefs(var)+1));\n  assert(jsvGetRefs(var));\n  return var;\n}\n\n/// Unreference - set this variable as not used by anything\nvoid jsvUnRef(JsVar *var) {\n  assert(var && jsvGetRefs(var)>0 && jsvHasRef(var));\n  if (jsvGetRefs(var) < JSVARREFCOUNT_MAX) // if we hit max refcounts, just keep them - GC will fix it later\n    jsvSetRefs(var, (JsVarRefCounter)(jsvGetRefs(var)-1));\n}\n\n/// Helper fn, Reference - set this variable as used by something\nJsVarRef jsvRefRef(JsVarRef ref) {\n  JsVar *v;\n  assert(ref);\n  v = jsvLock(ref);\n  assert(!jsvIsStringExt(v));\n  jsvRef(v);\n  jsvUnLock(v);\n  return ref;\n}\n\n/// Helper fn, Unreference - set this variable as not used by anything\nJsVarRef jsvUnRefRef(JsVarRef ref) {\n  JsVar *v;\n  assert(ref);\n  v = jsvLock(ref);\n  assert(!jsvIsStringExt(v));\n  jsvUnRef(v);\n  jsvUnLock(v);\n  return 0;\n}\n\nJsVar *jsvNewFlatStringOfLength(unsigned int byteLength) {\n  bool firstRun = true;\n  // Work out how many blocks we need. One for the header, plus some for the characters\n  size_t requiredBlocks = 1 + ((byteLength+sizeof(JsVar)-1) / sizeof(JsVar));\n  JsVar *flatString = 0;\n  if (isMemoryBusy) {\n    jsErrorFlags |= JSERR_MEMORY_BUSY;\n    return 0;\n  }\n  while (true) {\n    /* Now try and find a contiguous set of 'requiredBlocks' blocks by\n    searching the free list. This can be done as long as nobody's\n    messed with the free list in the mean time (which we check for with\n    touchedFreeList). If someone has messed with it, we restart.*/\n    bool memoryTouched = true;\n    while (memoryTouched) {\n      memoryTouched = false;\n      touchedFreeList = false;\n      JsVarRef beforeStartBlock = 0;\n      JsVarRef curr = jsVarFirstEmpty;\n      JsVarRef startBlock = curr;\n      unsigned int blockCount = 0;\n      while (curr && !touchedFreeList) {\n        JsVar *currVar = jsvGetAddressOf(curr);\n        JsVarRef next = jsvGetNextSibling(currVar);\n  #ifdef RESIZABLE_JSVARS\n        if (blockCount && next && (jsvGetAddressOf(next)==currVar+1)) {\n  #else\n        if (blockCount && (next == curr+1)) {\n  #endif\n          blockCount++;\n          if (blockCount>=requiredBlocks) {\n            JsVar *nextVar = jsvGetAddressOf(next);\n            JsVarRef nextFree = jsvGetNextSibling(nextVar);\n            jshInterruptOff();\n            if (!touchedFreeList) {\n              // we're there! Quickly re-link free list\n              if (beforeStartBlock) {\n                jsvSetNextSibling(jsvGetAddressOf(beforeStartBlock),nextFree);\n              } else {\n                jsVarFirstEmpty = nextFree;\n              }\n              flatString = jsvGetAddressOf(startBlock);\n              // Set up the header block (including one lock)\n              jsvResetVariable(flatString, JSV_FLAT_STRING);\n              flatString->varData.integer = (JsVarInt)byteLength;\n            }\n            jshInterruptOn();\n            // if success, break out!\n            if (flatString) break;\n          }\n        } else {\n          // this block is not immediately after the last - restart run\n          beforeStartBlock = curr;\n          startBlock = next;\n          // Check to see if the next block is aligned on a 4 byte boundary or not\n          if (((size_t)(jsvGetAddressOf(startBlock+1)))&3)\n            blockCount = 0; // this block is not aligned\n          else\n            blockCount = 1; // all ok - start block here\n        }\n        // move to next!\n        curr = next;\n      }\n      // memory list has been touched - restart!\n      if (touchedFreeList) {\n        memoryTouched = true;\n      }\n    }\n\n    // all good\n    if (flatString || !firstRun)\n      break;\n    /* Nope... we couldn't find a free string. It could be because\n     * the free list is fragmented, so GCing might well fix it - which\n     * we'll try - but only ONCE */\n    firstRun = false;\n    jsvGarbageCollect();\n  };\n  if (!flatString) return 0;\n  /* We now have the string! All that's left is to clear it */\n  // clear data\n  memset((char*)&flatString[1], 0, sizeof(JsVar)*(requiredBlocks-1));\n  /* We did mess with the free list - set it here in case we\n  are trying to create a flat string in an IRQ while trying to\n  make one outside the IRQ too */\n  touchedFreeList = true;\n  // and we're done\n  return flatString;\n}\n\nJsVar *jsvNewFromString(const char *str) {\n  // Create a var\n  JsVar *first = jsvNewWithFlags(JSV_STRING_0);\n  if (!first) return 0; // out of memory\n  // Now we copy the string, but keep creating new jsVars if we go\n  // over the end\n  JsVar *var = jsvLockAgain(first);\n  while (*str) {\n    // copy data in\n    size_t i, l = jsvGetMaxCharactersInVar(var);\n    for (i=0;i<l && *str;i++)\n      var->varData.str[i] = *(str++);\n    // we already set the variable data to 0, so no need for adding one\n\n    // we've stopped if the string was empty\n    jsvSetCharactersInVar(var, i);\n\n    // if there is still some left, it's because we filled up our var...\n    // make a new one, link it in, and unlock the old one.\n    if (*str) {\n      JsVar *next = jsvNewWithFlags(JSV_STRING_EXT_0);\n      if (!next) {\n        // Truncating string as not enough memory\n        jsvUnLock(var);\n        return first;\n      }\n      // we don't ref, because  StringExts are never reffed as they only have one owner (and ALWAYS have an owner)\n      jsvSetLastChild(var, jsvGetRef(next));\n      jsvUnLock(var);\n      var = next;\n    }\n  }\n  jsvUnLock(var);\n  // return\n  return first;\n}\n\nJsVar *jsvNewStringOfLength(unsigned int byteLength, const char *initialData) {\n  // if string large enough, try and make a flat string instead\n  if (byteLength > JSV_FLAT_STRING_BREAK_EVEN) {\n    JsVar *v = jsvNewFlatStringOfLength(byteLength);\n    if (v) {\n      if (initialData) jsvSetString(v, initialData, byteLength);\n      return v;\n    }\n  }\n  // Create a var\n  JsVar *first = jsvNewWithFlags(JSV_STRING_0);\n  if (!first) return 0; // out of memory, will have already set flag\n  // Now keep creating enough new jsVars\n  JsVar *var = jsvLockAgain(first);\n  while (true) {\n    // copy data in\n    unsigned int l = (unsigned int)jsvGetMaxCharactersInVar(var);\n    if (l>=byteLength) {\n      if (initialData)\n        memcpy(var->varData.str, initialData, byteLength);\n      // we've got enough\n      jsvSetCharactersInVar(var, byteLength);\n      break;\n    } else {\n      if (initialData) {\n        memcpy(var->varData.str, initialData, l);\n        initialData+=l;\n      }\n      // We need more\n      jsvSetCharactersInVar(var, l);\n      byteLength -= l;\n      // Make a new one, link it in, and unlock the old one.\n      JsVar *next = jsvNewWithFlags(JSV_STRING_EXT_0);\n      if (!next) break; // out of memory, will have already set flag\n      // we don't ref, because  StringExts are never reffed as they only have one owner (and ALWAYS have an owner)\n      jsvSetLastChild(var, jsvGetRef(next));\n      jsvUnLock(var);\n      var = next;\n    }\n  }\n  jsvUnLock(var);\n  // return\n  return first;\n}\n\nJsVar *jsvNewFromInteger(JsVarInt value) {\n  JsVar *var = jsvNewWithFlags(JSV_INTEGER);\n  if (!var) return 0; // no memory\n  var->varData.integer = value;\n  return var;\n}\nJsVar *jsvNewFromBool(bool value) {\n  JsVar *var = jsvNewWithFlags(JSV_BOOLEAN);\n  if (!var) return 0; // no memory\n  var->varData.integer = value ? 1 : 0;\n  return var;\n}\nJsVar *jsvNewFromFloat(JsVarFloat value) {\n  JsVar *var = jsvNewWithFlags(JSV_FLOAT);\n  if (!var) return 0; // no memory\n  var->varData.floating = value;\n  return var;\n}\nJsVar *jsvNewFromLongInteger(long long value) {\n  if (value>=-2147483648LL && value<=2147483647LL)\n    return jsvNewFromInteger((JsVarInt)value);\n  else\n    return jsvNewFromFloat((JsVarFloat)value);\n}\n\nJsVar *jsvNewFromPin(int pin) {\n  JsVar *v = jsvNewFromInteger((JsVarInt)pin);\n  if (v) {\n    v->flags = (JsVarFlags)((v->flags & ~JSV_VARTYPEMASK) | JSV_PIN);\n  }\n  return v;\n}\n\nJsVar *jsvNewObject() {\n  return jsvNewWithFlags(JSV_OBJECT);\n}\n\nJsVar *jsvNewEmptyArray() {\n  return jsvNewWithFlags(JSV_ARRAY);\n}\n\n/// Create an array containing the given elements\nJsVar *jsvNewArray(JsVar **elements, int elementCount) {\n  JsVar *arr = jsvNewEmptyArray();\n  if (!arr) return 0;\n  int i;\n  for (i=0;i<elementCount;i++)\n    jsvArrayPush(arr, elements[i]);\n  return arr;\n}\n\nJsVar *jsvNewArrayFromBytes(uint8_t *elements, int elementCount) {\n  JsVar *arr = jsvNewEmptyArray();\n  if (!arr) return 0;\n  int i;\n  for (i=0;i<elementCount;i++)\n    jsvArrayPushAndUnLock(arr, jsvNewFromInteger(elements[i]));\n  return arr;\n}\n\nJsVar *jsvNewNativeFunction(void (*ptr)(void), unsigned short argTypes) {\n  JsVar *func = jsvNewWithFlags(JSV_NATIVE_FUNCTION);\n  if (!func) return 0;\n  func->varData.native.ptr = ptr;\n  func->varData.native.argTypes = argTypes;\n  return func;\n}\n\nJsVar *jsvNewNativeString(char *ptr, size_t len) {\n  if (len>JSV_NATIVE_STR_MAX_LENGTH) len=JSV_NATIVE_STR_MAX_LENGTH; // crop string to what we can store in nativeStr.len\n  JsVar *str = jsvNewWithFlags(JSV_NATIVE_STRING);\n  if (!str) return 0;\n  str->varData.nativeStr.ptr = ptr;\n  str->varData.nativeStr.len = len;\n  return str;\n}\n\n#ifdef SPIFLASH_BASE\nJsVar *jsvNewFlashString(char *ptr, size_t len) {\n  if (len>JSV_NATIVE_STR_MAX_LENGTH) len=JSV_NATIVE_STR_MAX_LENGTH; // crop string to what we can store in nativeStr.len\n    JsVar *str = jsvNewWithFlags(JSV_FLASH_STRING);\n    if (!str) return 0;\n    str->varData.nativeStr.ptr = ptr;\n    str->varData.nativeStr.len = len;\n    return str;\n}\n#endif\n\n/// Create a new ArrayBuffer backed by the given string. If length is not specified, it will be worked out\nJsVar *jsvNewArrayBufferFromString(JsVar *str, unsigned int lengthOrZero) {\n  JsVar *arr = jsvNewWithFlags(JSV_ARRAYBUFFER);\n  if (!arr) return 0;\n  jsvSetFirstChild(arr, jsvGetRef(jsvRef(str)));\n  arr->varData.arraybuffer.type = ARRAYBUFFERVIEW_ARRAYBUFFER;\n  assert(arr->varData.arraybuffer.byteOffset == 0);\n  if (lengthOrZero==0) lengthOrZero = (unsigned int)jsvGetStringLength(str);\n  arr->varData.arraybuffer.length = (unsigned short)lengthOrZero;\n  return arr;\n}\n\nJsVar *jsvMakeIntoVariableName(JsVar *var, JsVar *valueOrZero) {\n  if (!var) return 0;\n  assert(jsvGetRefs(var)==0); // make sure it's unused\n  assert(jsvIsSimpleInt(var) || jsvIsString(var));\n  JsVarFlags varType = (var->flags & JSV_VARTYPEMASK);\n  if (varType==JSV_INTEGER) {\n    int t = JSV_NAME_INT;\n    if ((jsvIsInt(valueOrZero) || jsvIsBoolean(valueOrZero)) && !jsvIsPin(valueOrZero)) {\n      JsVarInt v = valueOrZero->varData.integer;\n      if (v>=JSVARREF_MIN && v<=JSVARREF_MAX) {\n        t = jsvIsInt(valueOrZero) ? JSV_NAME_INT_INT : JSV_NAME_INT_BOOL;\n        jsvSetFirstChild(var, (JsVarRef)v);\n        valueOrZero = 0;\n      }\n    }\n    var->flags = (JsVarFlags)(var->flags & ~JSV_VARTYPEMASK) | t;\n  } else if (varType>=_JSV_STRING_START && varType<=_JSV_STRING_END) {\n    if (jsvGetCharactersInVar(var) > JSVAR_DATA_STRING_NAME_LEN) {\n      /* Argh. String is too large to fit in a JSV_NAME! We must chomp make\n       * new STRINGEXTs to put the data in\n       */\n      JsvStringIterator it;\n      jsvStringIteratorNew(&it, var, JSVAR_DATA_STRING_NAME_LEN);\n      JsVar *startExt = jsvNewWithFlags(JSV_STRING_EXT_0);\n      JsVar *ext = jsvLockAgainSafe(startExt);\n      size_t nChars = 0;\n      while (ext && jsvStringIteratorHasChar(&it)) {\n        if (nChars >= JSVAR_DATA_STRING_MAX_LEN) {\n          jsvSetCharactersInVar(ext, nChars);\n          JsVar *ext2 = jsvNewWithFlags(JSV_STRING_EXT_0);\n          if (ext2) {\n            jsvSetLastChild(ext, jsvGetRef(ext2));\n          }\n          jsvUnLock(ext);\n          ext = ext2;\n          nChars = 0;\n        }\n        ext->varData.str[nChars++] = jsvStringIteratorGetCharAndNext(&it);\n      }\n      jsvStringIteratorFree(&it);\n      if (ext) {\n        jsvSetCharactersInVar(ext, nChars);\n        jsvUnLock(ext);\n      }\n      jsvSetCharactersInVar(var, JSVAR_DATA_STRING_NAME_LEN);\n      // Free any old stringexts\n      JsVarRef oldRef = jsvGetLastChild(var);\n      while (oldRef) {\n        JsVar *v = jsvGetAddressOf(oldRef);\n        oldRef = jsvGetLastChild(v);\n        jsvFreePtrInternal(v);\n      }\n      // set up new stringexts\n      jsvSetLastChild(var, jsvGetRef(startExt));\n      jsvSetNextSibling(var, 0);\n      jsvSetPrevSibling(var, 0);\n      jsvSetFirstChild(var, 0);\n      jsvUnLock(startExt);\n    }\n\n    size_t t = JSV_NAME_STRING_0;\n    if (jsvIsInt(valueOrZero) && !jsvIsPin(valueOrZero)) {\n      JsVarInt v = valueOrZero->varData.integer;\n      if (v>=JSVARREF_MIN && v<=JSVARREF_MAX) {\n        t = JSV_NAME_STRING_INT_0;\n        jsvSetFirstChild(var, (JsVarRef)v);\n        valueOrZero = 0;\n      }\n    } else\n      jsvSetFirstChild(var, 0);\n    var->flags = (var->flags & (JsVarFlags)~JSV_VARTYPEMASK) | (t+jsvGetCharactersInVar(var));\n  } else assert(0);\n\n  if (valueOrZero)\n    jsvSetFirstChild(var, jsvGetRef(jsvRef(valueOrZero)));\n  return var;\n}\n\nvoid jsvMakeFunctionParameter(JsVar *v) {\n  assert(jsvIsString(v));\n  if (!jsvIsName(v)) jsvMakeIntoVariableName(v,0);\n  v->flags = (JsVarFlags)(v->flags | JSV_NATIVE);\n}\n\n/// Add a new unnamed function parameter to a function - use this when binding function arguments. This unlocks paramName if specified, but not value.\nvoid jsvAddFunctionParameter(JsVar *fn, JsVar *paramName, JsVar *value) {\n  assert(jsvIsFunction(fn));\n  if (!paramName) paramName = jsvNewFromEmptyString();\n  assert(jsvIsString(paramName));\n  if (paramName) {\n    jsvMakeFunctionParameter(paramName); // force this to be called a function parameter\n    jsvSetValueOfName(paramName, value);\n    jsvAddName(fn, paramName);\n    jsvUnLock(paramName);\n  }\n}\n\nvoid *jsvGetNativeFunctionPtr(const JsVar *function) {\n  /* see descriptions in jsvar.h. If we have a child called JSPARSE_FUNCTION_CODE_NAME\n   * then we execute code straight from that */\n  JsVar *flatString = jsvFindChildFromString((JsVar*)function, JSPARSE_FUNCTION_CODE_NAME, 0);\n  if (flatString) {\n    flatString = jsvSkipNameAndUnLock(flatString);\n    void *v = (void*)((size_t)function->varData.native.ptr + (char*)jsvGetFlatStringPointer(flatString));\n    jsvUnLock(flatString);\n    return v;\n  } else\n    return (void *)function->varData.native.ptr;\n}\n\n\nbool jsvIsBasicVarEqual(JsVar *a, JsVar *b) {\n  // quick checks\n  if (a==b) return true;\n  if (!a || !b) return false; // one of them is undefined\n  // OPT: would this be useful as compare instead?\n  assert(jsvIsBasic(a) && jsvIsBasic(b));\n  if (jsvIsNumeric(a) && jsvIsNumeric(b)) {\n    if (jsvIsIntegerish(a)) {\n      if (jsvIsIntegerish(b)) {\n        return a->varData.integer == b->varData.integer;\n      } else {\n        assert(jsvIsFloat(b));\n        return a->varData.integer == b->varData.floating;\n      }\n    } else {\n      assert(jsvIsFloat(a));\n      if (jsvIsIntegerish(b)) {\n        return a->varData.floating == b->varData.integer;\n      } else {\n        assert(jsvIsFloat(b));\n        return a->varData.floating == b->varData.floating;\n      }\n    }\n  } else if (jsvIsString(a) && jsvIsString(b)) {\n    JsvStringIterator ita, itb;\n    jsvStringIteratorNew(&ita, a, 0);\n    jsvStringIteratorNew(&itb, b, 0);\n    while (true) {\n      char a = jsvStringIteratorGetCharAndNext(&ita);\n      char b = jsvStringIteratorGetCharAndNext(&itb);\n      if (a != b) {\n        jsvStringIteratorFree(&ita);\n        jsvStringIteratorFree(&itb);\n        return false;\n      }\n      if (!a) { // equal, but end of string\n        jsvStringIteratorFree(&ita);\n        jsvStringIteratorFree(&itb);\n        return true;\n      }\n    }\n    // we never get here\n    return false; // make compiler happy\n  } else {\n    //TODO: are there any other combinations we should check here?? String v int?\n    return false;\n  }\n}\n\nbool jsvIsEqual(JsVar *a, JsVar *b) {\n  if (jsvIsBasic(a) && jsvIsBasic(b))\n    return jsvIsBasicVarEqual(a,b);\n  return jsvGetRef(a)==jsvGetRef(b);\n}\n\n/// Get a const string representing this variable - if we can. Otherwise return 0\nconst char *jsvGetConstString(const JsVar *v) {\n  if (jsvIsUndefined(v)) {\n    return \"undefined\";\n  } else if (jsvIsNull(v)) {\n    return \"null\";\n  } else if (jsvIsBoolean(v) && !jsvIsNameIntBool(v)) {\n    return jsvGetBool(v) ? \"true\" : \"false\";\n  }\n  return 0;\n}\n\n/// Return the 'type' of the JS variable (eg. JS's typeof operator)\nconst char *jsvGetTypeOf(const JsVar *v) {\n  if (jsvIsUndefined(v)) return \"undefined\";\n  if (jsvIsNull(v) || jsvIsObject(v) ||\n      jsvIsArray(v) || jsvIsArrayBuffer(v)) return \"object\";\n  if (jsvIsFunction(v)) return \"function\";\n  if (jsvIsString(v)) return \"string\";\n  if (jsvIsBoolean(v)) return \"boolean\";\n  if (jsvIsNumeric(v)) return \"number\";\n  return \"?\";\n}\n\n/// Return the JsVar, or if it's an object and has a valueOf function, call that\nJsVar *jsvGetValueOf(JsVar *v) {\n  if (!jsvIsObject(v)) return jsvLockAgainSafe(v);\n  JsVar *valueOf = jspGetNamedField(v, \"valueOf\", false);\n  if (!jsvIsFunction(valueOf)) {\n    jsvUnLock(valueOf);\n    return jsvLockAgain(v);\n  }\n  v = jspeFunctionCall(valueOf, 0, v, false, 0, 0);\n  jsvUnLock(valueOf);\n  return v;\n}\n\n/** Save this var as a string to the given buffer, and return how long it was (return val doesn't include terminating 0)\nIf the buffer length is exceeded, the returned value will == len */\nsize_t jsvGetString(const JsVar *v, char *str, size_t len) {\n  assert(len>0);\n  const char *s = jsvGetConstString(v);\n  if (s) {\n    /* don't use strncpy here because we don't\n     * want to pad the entire buffer with zeros */\n    len--;\n    size_t l = 0;\n    while (s[l] && l<len) {\n      str[l] = s[l];\n      l++;\n    }\n    str[l] = 0;\n    return l;\n  } else if (jsvIsInt(v)) {\n    itostr(v->varData.integer, str, 10);\n    return strlen(str);\n  } else if (jsvIsFloat(v)) {\n    ftoa_bounded(v->varData.floating, str, len);\n    return strlen(str);\n  } else if (jsvHasCharacterData(v)) {\n    assert(!jsvIsStringExt(v));\n    size_t l = len;\n    JsvStringIterator it;\n    jsvStringIteratorNewConst(&it, v, 0);\n    while (jsvStringIteratorHasChar(&it)) {\n      if (l--<=1) {\n        *str = 0;\n        jsvStringIteratorFree(&it);\n        return len;\n      }\n      *(str++) = jsvStringIteratorGetChar(&it);\n      jsvStringIteratorNext(&it);\n    }\n    jsvStringIteratorFree(&it);\n    *str = 0;\n    return len-l;\n  } else {\n    // Try and get as a JsVar string, and try again\n    JsVar *stringVar = jsvAsString((JsVar*)v); // we know we're casting to non-const here\n    if (stringVar) {\n      size_t l = jsvGetStringChars(stringVar, 0, str, len); // call again - but this time with converted var\n      jsvUnLock(stringVar);\n      return l;\n    } else {\n      str[0] = 0;\n      jsExceptionHere(JSET_INTERNALERROR, \"Variable type cannot be converted to string\");\n      return 0;\n    }\n  }\n}\n\n/// Get len bytes of string data from this string. Does not error if string len is not equal to len, no terminating 0\nsize_t jsvGetStringChars(const JsVar *v, size_t startChar, char *str, size_t len) {\n  assert(jsvHasCharacterData(v));\n  size_t l = len;\n  JsvStringIterator it;\n  jsvStringIteratorNewConst(&it, v, startChar);\n  while (jsvStringIteratorHasChar(&it)) {\n    if (l--<=0) {\n      jsvStringIteratorFree(&it);\n      return len;\n    }\n    *(str++) = jsvStringIteratorGetCharAndNext(&it);\n  }\n  jsvStringIteratorFree(&it);\n  return len-l;\n}\n\n/// Set the Data in this string. This must JUST overwrite - not extend or shrink\nvoid jsvSetString(JsVar *v, const char *str, size_t len) {\n  assert(jsvHasCharacterData(v));\n  // the iterator checks, so it is safe not to assert if the length is different\n  //assert(len == jsvGetStringLength(v));\n\n\n  JsvStringIterator it;\n  jsvStringIteratorNew(&it, v, 0);\n  size_t i;\n  for (i=0;i<len;i++) {\n    jsvStringIteratorSetCharAndNext(&it, str[i]);\n  }\n  jsvStringIteratorFree(&it);\n}\n\n/** If var is a string, lock and return it, else\n * create a new string. unlockVar means this will auto-unlock 'var'  */\nJsVar *jsvAsString(JsVar *v) {\n  JsVar *str = 0;\n  // If it is string-ish, but not quite a string, copy it\n  if (jsvHasCharacterData(v) && jsvIsName(v)) {\n    str = jsvNewFromStringVar(v,0,JSVAPPENDSTRINGVAR_MAXLENGTH);\n  } else if (jsvIsString(v)) { // If it is a string - just return a reference\n    str = jsvLockAgain(v);\n  } else if (jsvIsObject(v)) { // If it is an object and we can call toString on it\n    JsVar *toStringFn = jspGetNamedField(v, \"toString\", false);\n    if (toStringFn && toStringFn->varData.native.ptr != (void (*)(void))jswrap_object_toString) {\n      // Function found and it's not the default one - execute it\n      JsVar *result = jspExecuteFunction(toStringFn,v,0,0);\n      jsvUnLock(toStringFn);\n      str = jsvAsStringAndUnLock(result);\n    } else {\n      jsvUnLock(toStringFn);\n      str = jsvNewFromString(\"[object Object]\");\n    }\n  } else {\n    const char *constChar = jsvGetConstString(v);\n    assert(JS_NUMBER_BUFFER_SIZE>=10);\n    char buf[JS_NUMBER_BUFFER_SIZE];\n    if (constChar) {\n      // if we could get this as a simple const char, do that..\n      str = jsvNewFromString(constChar);\n    } else if (jsvIsPin(v)) {\n      jshGetPinString(buf, (Pin)v->varData.integer);\n      str = jsvNewFromString(buf);\n    } else if (jsvIsInt(v)) {\n      itostr(v->varData.integer, buf, 10);\n      str = jsvNewFromString(buf);\n    } else if (jsvIsFloat(v)) {\n      ftoa_bounded(v->varData.floating, buf, sizeof(buf));\n      str = jsvNewFromString(buf);\n    } else if (jsvIsArray(v) || jsvIsArrayBuffer(v)) {\n      JsVar *filler = jsvNewFromString(\",\");\n      str = jsvArrayJoin(v, filler, true/*ignoreNull*/);\n      jsvUnLock(filler);\n    } else if (jsvIsFunction(v)) {\n      str = jsvNewFromEmptyString();\n      if (str) jsfGetJSON(v, str, JSON_NONE);\n    } else {\n      jsExceptionHere(JSET_INTERNALERROR, \"Variable type cannot be converted to string\");\n    }\n  }\n  return str;\n}\n\nJsVar *jsvAsStringAndUnLock(JsVar *var) {\n  JsVar *s = jsvAsString(var);\n  jsvUnLock(var);\n  return s;\n}\n\nJsVar *jsvAsFlatString(JsVar *var) {\n  if (jsvIsFlatString(var)) return jsvLockAgain(var);\n  JsVar *str = jsvAsString(var);\n  size_t len = jsvGetStringLength(str);\n  JsVar *flat = jsvNewFlatStringOfLength((unsigned int)len);\n  if (flat) {\n    JsvStringIterator src;\n    JsvStringIterator dst;\n    jsvStringIteratorNew(&src, str, 0);\n    jsvStringIteratorNew(&dst, flat, 0);\n    while (len--) {\n      jsvStringIteratorSetCharAndNext(&dst, jsvStringIteratorGetCharAndNext(&src));\n    }\n    jsvStringIteratorFree(&src);\n    jsvStringIteratorFree(&dst);\n  }\n  jsvUnLock(str);\n  return flat;\n}\n\n/** Given a JsVar meant to be an index to an array, convert it to\n * the actual variable type we'll use to access the array. For example\n * a[\"0\"] is actually translated to a[0]\n */\nJsVar *jsvAsArrayIndex(JsVar *index) {\n  if (jsvIsSimpleInt(index) && jsvGetInteger(index)>=0) {\n    return jsvLockAgain(index); // we're ok!\n  } else if (jsvIsString(index)) {\n    /* Index filtering (bug #19) - if we have an array index A that is:\n     is_string(A) && int_to_string(string_to_int(A)) == A\n     then convert it to an integer. Shouldn't be too nasty for performance\n     as we only do this when accessing an array with a string */\n    if (jsvIsStringNumericStrict(index)) {\n      JsVar *i = jsvNewFromInteger(jsvGetInteger(index));\n      JsVar *is = jsvAsString(i);\n      if (jsvCompareString(index,is,0,0,false)==0) {\n        // two items are identical - use the integer\n        jsvUnLock(is);\n        return i;\n      } else {\n        // not identical, use as a string\n        jsvUnLock2(i,is);\n      }\n    }\n  } else if (jsvIsFloat(index)) {\n    // if it's a float that is actually integral, return an integer...\n    JsVarFloat v = jsvGetFloat(index);\n    JsVarInt vi = jsvGetInteger(index);\n    if (v == vi) return jsvNewFromInteger(vi);\n  }\n\n  // else if it's not a simple numeric type, convert it to a string\n  return jsvAsString(index);\n}\n\n/** Same as jsvAsArrayIndex, but ensures that 'index' is unlocked */\nJsVar *jsvAsArrayIndexAndUnLock(JsVar *a) {\n  JsVar *b = jsvAsArrayIndex(a);\n  jsvUnLock(a);\n  return b;\n}\n\n/// Returns true if the string is empty - faster than jsvGetStringLength(v)==0\nbool jsvIsEmptyString(JsVar *v) {\n  if (!jsvHasCharacterData(v)) return true;\n  return jsvGetCharactersInVar(v)==0;\n}\n\nsize_t jsvGetStringLength(const JsVar *v) {\n  size_t strLength = 0;\n  const JsVar *var = v;\n  JsVar *newVar = 0;\n  if (!jsvHasCharacterData(v)) return 0;\n\n  while (var) {\n    JsVarRef ref = jsvGetLastChild(var);\n    strLength += jsvGetCharactersInVar(var);\n\n    // Go to next\n    jsvUnLock(newVar); // note use of if (ref), not var\n    var = newVar = jsvLockSafe(ref);\n  }\n  jsvUnLock(newVar); // note use of if (ref), not var\n  return strLength;\n}\n\nsize_t jsvGetFlatStringBlocks(const JsVar *v) {\n  assert(jsvIsFlatString(v));\n  return ((size_t)v->varData.integer+sizeof(JsVar)-1) / sizeof(JsVar);\n}\n\nchar *jsvGetFlatStringPointer(JsVar *v) {\n  assert(jsvIsFlatString(v));\n  if (!jsvIsFlatString(v)) return 0;\n  return (char*)(v+1); // pointer to the next JsVar\n}\n\nJsVar *jsvGetFlatStringFromPointer(char *v) {\n  JsVar *secondVar = (JsVar*)v;\n  JsVar *flatStr = secondVar-1;\n  assert(jsvIsFlatString(flatStr));\n  return flatStr;\n}\n\n/// If the variable points to a *flat* area of memory, return a pointer (and set length). Otherwise return 0.\nchar *jsvGetDataPointer(JsVar *v, size_t *len) {\n  assert(len);\n  if (jsvIsArrayBuffer(v)) {\n    /* Arraybuffers generally use some kind of string to store their data.\n     * Find it, then call ourselves again to figure out if we can get a\n     * raw pointer to it.  */\n    JsVar *d = jsvGetArrayBufferBackingString(v, NULL);\n    char *r = jsvGetDataPointer(d, len);\n    jsvUnLock(d);\n    if (r) {\n      r += v->varData.arraybuffer.byteOffset;\n      *len = v->varData.arraybuffer.length;\n    }\n    return r;\n  }\n  if (jsvIsNativeString(v)) {\n    *len = v->varData.nativeStr.len;\n    return (char*)v->varData.nativeStr.ptr;\n  }\n  if (jsvIsFlatString(v)) {\n    *len = jsvGetStringLength(v);\n    return jsvGetFlatStringPointer(v);\n  }\n  if (jsvIsBasicString(v) && !jsvGetLastChild(v)) {\n    // It's a normal string but is small enough to have all the data in\n    *len = jsvGetCharactersInVar(v);\n    return (char*)v->varData.str;\n  }\n  return 0;\n}\n\n//  IN A STRING  get the number of lines in the string (min=1)\nsize_t jsvGetLinesInString(JsVar *v) {\n  size_t lines = 1;\n  JsvStringIterator it;\n  jsvStringIteratorNew(&it, v, 0);\n  while (jsvStringIteratorHasChar(&it)) {\n    if (jsvStringIteratorGetCharAndNext(&it)=='\\n') lines++;\n  }\n  jsvStringIteratorFree(&it);\n  return lines;\n}\n\n// IN A STRING Get the number of characters on a line - lines start at 1\nsize_t jsvGetCharsOnLine(JsVar *v, size_t line) {\n  size_t currentLine = 1;\n  size_t chars = 0;\n  JsvStringIterator it;\n  jsvStringIteratorNew(&it, v, 0);\n  while (jsvStringIteratorHasChar(&it)) {\n    if (jsvStringIteratorGetCharAndNext(&it)=='\\n') {\n      currentLine++;\n      if (currentLine > line) break;\n    } else if (currentLine==line) chars++;\n  }\n  jsvStringIteratorFree(&it);\n  return chars;\n}\n\n//  IN A STRING, get the 1-based line and column of the given character. Both values must be non-null\nvoid jsvGetLineAndCol(JsVar *v, size_t charIdx, size_t *line, size_t *col) {\n  size_t x = 1;\n  size_t y = 1;\n  size_t n = 0;\n  assert(line && col);\n\n  JsvStringIterator it;\n  jsvStringIteratorNew(&it, v, 0);\n  while (jsvStringIteratorHasChar(&it)) {\n    char ch = jsvStringIteratorGetCharAndNext(&it);\n    if (n==charIdx) {\n      jsvStringIteratorFree(&it);\n      *line = y;\n      *col = x;\n      return;\n    }\n    x++;\n    if (ch=='\\n') {\n      x=1; y++;\n    }\n    n++;\n  }\n  jsvStringIteratorFree(&it);\n  // uh-oh - not found\n  *line = y;\n  *col = x;\n}\n\n//  IN A STRING, get a character index from a line and column\nsize_t jsvGetIndexFromLineAndCol(JsVar *v, size_t line, size_t col) {\n  size_t x = 1;\n  size_t y = 1;\n  size_t n = 0;\n  JsvStringIterator it;\n  jsvStringIteratorNew(&it, v, 0);\n  while (jsvStringIteratorHasChar(&it)) {\n    char ch = jsvStringIteratorGetCharAndNext(&it);\n    if ((y==line && x>=col) || y>line) {\n      jsvStringIteratorFree(&it);\n      return (y>line) ? (n-1) : n;\n    }\n    x++;\n    if (ch=='\\n') {\n      x=1; y++;\n    }\n    n++;\n  }\n  jsvStringIteratorFree(&it);\n  return n;\n}\n\nvoid jsvAppendString(JsVar *var, const char *str) {\n  assert(jsvIsString(var));\n  JsvStringIterator dst;\n  jsvStringIteratorNew(&dst, var, 0);\n  jsvStringIteratorGotoEnd(&dst);\n  // now start appending\n  /* This isn't as fast as something single-purpose, but it's not that bad,\n   * and is less likely to break :) */\n  while (*str)\n    jsvStringIteratorAppend(&dst, *(str++));\n  jsvStringIteratorFree(&dst);\n}\n\n// Append the given string to this one - but does not use null-terminated strings\nvoid jsvAppendStringBuf(JsVar *var, const char *str, size_t length) {\n  assert(jsvIsString(var));\n  JsvStringIterator dst;\n  jsvStringIteratorNew(&dst, var, 0);\n  jsvStringIteratorGotoEnd(&dst);\n  // now start appending\n  /* This isn't as fast as something single-purpose, but it's not that bad,\n   * and is less likely to break :) */\n  while (length) {\n    jsvStringIteratorAppend(&dst, *(str++));\n    length--;\n  }\n  jsvStringIteratorFree(&dst);\n}\n\n/// Special version of append designed for use with vcbprintf_callback (See jsvAppendPrintf)\nvoid jsvStringIteratorPrintfCallback(const char *str, void *user_data) {\n  while (*str)\n    jsvStringIteratorAppend((JsvStringIterator *)user_data, *(str++));\n}\n\nvoid jsvAppendPrintf(JsVar *var, const char *fmt, ...) {\n  JsvStringIterator it;\n  jsvStringIteratorNew(&it, var, 0);\n  jsvStringIteratorGotoEnd(&it);\n\n  va_list argp;\n  va_start(argp, fmt);\n  vcbprintf((vcbprintf_callback)jsvStringIteratorPrintfCallback,&it, fmt, argp);\n  va_end(argp);\n\n  jsvStringIteratorFree(&it);\n}\n\nJsVar *jsvVarPrintf( const char *fmt, ...) {\n  JsVar *str = jsvNewFromEmptyString();\n  if (!str) return 0;\n  JsvStringIterator it;\n  jsvStringIteratorNew(&it, str, 0);\n  jsvStringIteratorGotoEnd(&it);\n\n  va_list argp;\n  va_start(argp, fmt);\n  vcbprintf((vcbprintf_callback)jsvStringIteratorPrintfCallback,&it, fmt, argp);\n  va_end(argp);\n\n  jsvStringIteratorFree(&it);\n  return str;\n}\n\n/** Append str to var. Both must be strings. stridx = start char or str, maxLength = max number of characters (can be JSVAPPENDSTRINGVAR_MAXLENGTH) */\nvoid jsvAppendStringVar(JsVar *var, const JsVar *str, size_t stridx, size_t maxLength) {\n  assert(jsvIsString(var));\n\n  JsvStringIterator dst;\n  jsvStringIteratorNew(&dst, var, 0);\n  jsvStringIteratorGotoEnd(&dst);\n  // now start appending\n  /* This isn't as fast as something single-purpose, but it's not that bad,\n     * and is less likely to break :) */\n  JsvStringIterator it;\n  jsvStringIteratorNewConst(&it, str, stridx);\n  while (jsvStringIteratorHasChar(&it) && (maxLength-->0)) {\n    char ch = jsvStringIteratorGetCharAndNext(&it);\n    jsvStringIteratorAppend(&dst, ch);\n  }\n  jsvStringIteratorFree(&it);\n  jsvStringIteratorFree(&dst);\n}\n\n/** Create a new variable from a substring. argument must be a string. stridx = start char or str, maxLength = max number of characters (can be JSVAPPENDSTRINGVAR_MAXLENGTH) */\nJsVar *jsvNewFromStringVar(const JsVar *str, size_t stridx, size_t maxLength) {\n  JsVar *var = jsvNewFromEmptyString();\n  if (var) jsvAppendStringVar(var, str, stridx, maxLength);\n  return var;\n}\n\n/** Append all of str to var. Both must be strings.  */\nvoid jsvAppendStringVarComplete(JsVar *var, const JsVar *str) {\n  jsvAppendStringVar(var, str, 0, JSVAPPENDSTRINGVAR_MAXLENGTH);\n}\n\nchar jsvGetCharInString(JsVar *v, size_t idx) {\n  if (!jsvIsString(v)) return 0;\n\n  JsvStringIterator it;\n  jsvStringIteratorNew(&it, v, idx);\n  char ch = jsvStringIteratorGetChar(&it);\n  jsvStringIteratorFree(&it);\n  return ch;\n}\n\nvoid jsvSetCharInString(JsVar *v, size_t idx, char ch, bool bitwiseOR) {\n  if (!jsvIsString(v)) return;\n  JsvStringIterator it;\n  jsvStringIteratorNew(&it, v, idx);\n  if (bitwiseOR) ch |= jsvStringIteratorGetChar(&it);\n  jsvStringIteratorSetChar(&it, ch);\n  jsvStringIteratorFree(&it);\n}\n\n/// Get the index of a character in a string, or -1\nint jsvGetStringIndexOf(JsVar *str, char ch) {\n  JsvStringIterator it;\n  jsvStringIteratorNew(&it, str, 0);\n  while (jsvStringIteratorHasChar(&it)) {\n    if (jsvStringIteratorGetChar(&it) == ch) {\n      int idx = (int)jsvStringIteratorGetIndex(&it);\n      jsvStringIteratorFree(&it);\n      return idx;\n    };\n    jsvStringIteratorNext(&it);\n  }\n  jsvStringIteratorFree(&it);\n  return -1;\n}\n\n/** Does this string contain only Numeric characters (with optional '-'/'+' at the front)? NOT '.'/'e' and similar (allowDecimalPoint is for '.' only) */\nbool jsvIsStringNumericInt(const JsVar *var, bool allowDecimalPoint) {\n  assert(jsvIsString(var));\n  JsvStringIterator it;\n  jsvStringIteratorNewConst(&it, var, 0); // we know it's non const\n\n  // skip whitespace\n  while (jsvStringIteratorHasChar(&it) && isWhitespace(jsvStringIteratorGetChar(&it)))\n    jsvStringIteratorNext(&it);\n\n  // skip a minus. if there was one\n  if (jsvStringIteratorGetChar(&it)=='-' || jsvStringIteratorGetChar(&it)=='+')\n    jsvStringIteratorNext(&it);\n\n  int radix = 0;\n  if (jsvStringIteratorGetChar(&it)=='0') {\n    jsvStringIteratorNext(&it);\n    char buf[3];\n    buf[0] = '0';\n    buf[1] = jsvStringIteratorGetChar(&it);\n    buf[2] = 0;\n    const char *p = buf;\n    radix = getRadix(&p,0);\n    if (p>&buf[1]) jsvStringIteratorNext(&it);\n  }\n  if (radix==0) radix=10;\n\n  // now check...\n  int chars=0;\n  while (jsvStringIteratorHasChar(&it)) {\n    chars++;\n    char ch = jsvStringIteratorGetCharAndNext(&it);\n    if (ch=='.' && allowDecimalPoint) {\n      allowDecimalPoint = false; // there can be only one\n    } else {\n      int n = chtod(ch);\n      if (n<0 || n>=radix) {\n        jsvStringIteratorFree(&it);\n        return false;\n      }\n    }\n  }\n  jsvStringIteratorFree(&it);\n  return chars>0;\n}\n\n/** Does this string contain only Numeric characters? This is for arrays\n * and makes the assertion that int_to_string(string_to_int(var))==var */\nbool jsvIsStringNumericStrict(const JsVar *var) {\n  assert(jsvIsString(var));\n  JsvStringIterator it;\n  jsvStringIteratorNewConst(&it, var, 0);  // we know it's non const\n  bool hadNonZero = false;\n  bool hasLeadingZero = false;\n  int chars = 0;\n  while (jsvStringIteratorHasChar(&it)) {\n    chars++;\n    char ch = jsvStringIteratorGetCharAndNext(&it);\n    if (!isNumeric(ch)) {\n      // test for leading zero ensures int_to_string(string_to_int(var))==var\n      jsvStringIteratorFree(&it);\n      return false;\n    }\n    if (!hadNonZero && ch=='0') hasLeadingZero=true;\n    if (ch!='0') hadNonZero=true;\n  }\n  jsvStringIteratorFree(&it);\n  return chars>0 && (!hasLeadingZero || chars==1);\n}\n\n\nJsVarInt jsvGetInteger(const JsVar *v) {\n  if (!v) return 0; // undefined\n  /* strtol understands about hex and octal */\n  if (jsvIsNull(v)) return 0;\n  if (jsvIsUndefined(v)) return 0;\n  if (jsvIsIntegerish(v) || jsvIsArrayBufferName(v)) return v->varData.integer;\n  if (jsvIsArray(v) || jsvIsArrayBuffer(v)) {\n    JsVarInt l = jsvGetLength((JsVar *)v);\n    if (l==0) return 0; // 0 length, return 0\n    if (l==1) {\n      if (jsvIsArrayBuffer(v))\n        return jsvGetIntegerAndUnLock(jsvArrayBufferGet((JsVar*)v,0));\n      return jsvGetIntegerAndUnLock(jsvSkipNameAndUnLock(jsvGetArrayItem(v,0)));\n    }\n  }\n  if (jsvIsFloat(v)) {\n    if (isfinite(v->varData.floating))\n      return (JsVarInt)(long long)v->varData.floating;\n    return 0;\n  }\n  if (jsvIsString(v) && jsvIsStringNumericInt(v, true/* allow decimal point*/)) {\n    char buf[32];\n    if (jsvGetString(v, buf, sizeof(buf))==sizeof(buf))\n      jsExceptionHere(JSET_ERROR, \"String too big to convert to integer\\n\");\n    else\n      return (JsVarInt)stringToInt(buf);\n  }\n  return 0;\n}\n\nlong long jsvGetLongInteger(const JsVar *v) {\n  if (jsvIsInt(v)) return jsvGetInteger(v);\n  return (long long)jsvGetFloat(v);\n}\n\nlong long jsvGetLongIntegerAndUnLock(JsVar *v) {\n  long long i = jsvGetLongInteger(v);\n  jsvUnLock(v);\n  return i;\n}\n\n\nvoid jsvSetInteger(JsVar *v, JsVarInt value) {\n  assert(jsvIsInt(v));\n  v->varData.integer  = value;\n}\n\n/**\n * Get the boolean value of a variable.\n * From a JavaScript variable, we determine its boolean value.  The rules\n * are:\n *\n * * If integer, true if value is not 0.\n * * If float, true if value is not 0.0.\n * * If function, array or object, always true.\n * * If string, true if length of string is greater than 0.\n */\nbool jsvGetBool(const JsVar *v) {\n  if (jsvIsString(v))\n    return jsvGetStringLength((JsVar*)v)!=0;\n  if (jsvIsPin(v))\n    return jshIsPinValid(jshGetPinFromVar((JsVar*)v));\n  if (jsvIsFunction(v) || jsvIsArray(v) || jsvIsObject(v) || jsvIsArrayBuffer(v))\n    return true;\n  if (jsvIsFloat(v)) {\n    JsVarFloat f = jsvGetFloat(v);\n    return !isnan(f) && f!=0.0;\n  }\n  return jsvGetInteger(v)!=0;\n}\n\nJsVarFloat jsvGetFloat(const JsVar *v) {\n  if (!v) return NAN; // undefined\n  if (jsvIsFloat(v)) return v->varData.floating;\n  if (jsvIsIntegerish(v)) return (JsVarFloat)v->varData.integer;\n  if (jsvIsArray(v) || jsvIsArrayBuffer(v)) {\n    JsVarInt l = jsvGetLength(v);\n    if (l==0) return 0; // zero element array==0 (not undefined)\n    if (l==1) {\n      if (jsvIsArrayBuffer(v))\n        return jsvGetFloatAndUnLock(jsvArrayBufferGet((JsVar*)v,0));\n      return jsvGetFloatAndUnLock(jsvSkipNameAndUnLock(jsvGetArrayItem(v,0)));\n    }\n  }\n  if (jsvIsString(v)) {\n    char buf[64];\n    if (jsvGetString(v, buf, sizeof(buf))==sizeof(buf)) {\n      jsExceptionHere(JSET_ERROR, \"String too big to convert to float\\n\");\n    } else {\n      if (buf[0]==0) return 0; // empty string -> 0\n      if (!strcmp(buf,\"Infinity\")) return INFINITY;\n      if (!strcmp(buf,\"-Infinity\")) return -INFINITY;\n      return stringToFloat(buf);\n    }\n  }\n  return NAN;\n}\n\n/// Convert the given variable to a number\nJsVar *jsvAsNumber(JsVar *var) {\n  // stuff that we can just keep\n  if (jsvIsInt(var) || jsvIsFloat(var)) return jsvLockAgain(var);\n  // stuff that can be converted to an int\n  if (jsvIsBoolean(var) ||\n      jsvIsPin(var) ||\n      jsvIsNull(var) ||\n      jsvIsBoolean(var) ||\n      jsvIsArrayBufferName(var))\n    return jsvNewFromInteger(jsvGetInteger(var));\n  if (jsvIsString(var) && (jsvIsEmptyString(var) || jsvIsStringNumericInt(var, false/* no decimal pt - handle that with GetFloat */))) {\n    // handle strings like this, in case they're too big for an int\n    char buf[64];\n    if (jsvGetString(var, buf, sizeof(buf))==sizeof(buf)) {\n      jsExceptionHere(JSET_ERROR, \"String too big to convert to integer\\n\");\n      return jsvNewFromFloat(NAN);\n    } else\n      return jsvNewFromLongInteger(stringToInt(buf));\n  }\n  // Else just try and get a float\n  return jsvNewFromFloat(jsvGetFloat(var));\n}\n\nJsVarInt jsvGetIntegerAndUnLock(JsVar *v) { return _jsvGetIntegerAndUnLock(v); }\nJsVarFloat jsvGetFloatAndUnLock(JsVar *v) { return _jsvGetFloatAndUnLock(v); }\nbool jsvGetBoolAndUnLock(JsVar *v) { return _jsvGetBoolAndUnLock(v); }\n\n\n#ifndef SAVE_ON_FLASH\n// Executes the given getter, or if there are problems returns undefined\nJsVar *jsvExecuteGetter(JsVar *parent, JsVar *getset) {\n  assert(jsvIsGetterOrSetter(getset));\n  if (!jsvIsGetterOrSetter(getset)) return 0; // wasn't an object?\n  JsVar *fn = jsvObjectGetChild(getset, \"get\", 0);\n  if (!jsvIsFunction(fn)) {\n    jsvUnLock(fn);\n    return 0;\n  }\n  JsVar *result = jspExecuteFunction(fn, parent, 0, NULL);\n  jsvUnLock(fn);\n  return result;\n}\n\n// Executes the given setter\nvoid jsvExecuteSetter(JsVar *parent, JsVar *getset, JsVar *value) {\n  assert(jsvIsGetterOrSetter(getset));\n  if (!jsvIsGetterOrSetter(getset)) return; // wasn't an object?\n  JsVar *fn = jsvObjectGetChild(getset, \"set\", 0);\n  if (!jsvIsFunction(fn)) {\n    jsvUnLock(fn);\n    return;\n  }\n  if (!fn) return;\n  jsvUnLock2(jspExecuteFunction(fn, parent, 1, &value), fn);\n}\n\n/// Add a named getter or setter to an object\nvoid jsvAddGetterOrSetter(JsVar *obj, JsVar *varName, bool isGetter, JsVar *method) {\n  // check for existing getter/setter, make one if needed\n  JsVar *getsetName = jsvFindChildFromVar(obj, varName, true);\n  if (jsvIsName(getsetName)) {\n    JsVar *getset = jsvGetValueOfName(getsetName);\n    if (!jsvIsGetterOrSetter(getset)) {\n      jsvUnLock(getset);\n      getset = jsvNewWithFlags(JSV_GET_SET);\n      jsvSetValueOfName(getsetName, getset);\n    }\n    if (jsvIsGetterOrSetter(getset))\n      jsvObjectSetChild(getset, isGetter?\"get\":\"set\", method);\n    jsvUnLock(getset);\n  }\n  jsvUnLock(getsetName);\n}\n#endif\n\n\n/* Set the value of the given variable. This is sort of like\n * jsvSetValueOfName except it deals with all the non-standard\n * stuff like ArrayBuffers, variables that haven't been allocated\n * yet, setters, etc.\n */\nvoid jsvReplaceWith(JsVar *dst, JsVar *src) {\n  // If this is an index in an array buffer, write directly into the array buffer\n  if (jsvIsArrayBufferName(dst)) {\n    size_t idx = (size_t)jsvGetInteger(dst);\n    JsVar *arrayBuffer = jsvLock(jsvGetFirstChild(dst));\n    jsvArrayBufferSet(arrayBuffer, idx, src);\n    jsvUnLock(arrayBuffer);\n    return;\n  }\n  // if destination isn't there, isn't a 'name', or is used, give an error\n  if (!jsvIsName(dst)) {\n    jsExceptionHere(JSET_ERROR, \"Unable to assign value to non-reference %t\", dst);\n    return;\n  }\n#ifndef SAVE_ON_FLASH\n  JsVar *v = jsvGetValueOfName(dst);\n  if (jsvIsGetterOrSetter(v)) {\n    JsVar *parent = jsvIsNewChild(dst)?jsvLock(jsvGetNextSibling(dst)):0;\n    jsvExecuteSetter(parent,v,src);\n    jsvUnLock2(v,parent);\n    return;\n  }\n  jsvUnLock(v);\n#endif\n  jsvSetValueOfName(dst, src);\n  /* If dst is flagged as a new child, it means that\n   * it was previously undefined, and we need to add it to\n   * the given object when it is set.\n   */\n  if (jsvIsNewChild(dst)) {\n    // Get what it should have been a child of\n    JsVar *parent = jsvLock(jsvGetNextSibling(dst));\n    if (!jsvIsString(parent)) {\n      // if we can't find a char in a string we still return a NewChild,\n      // but we can't add character back in\n      if (!jsvHasChildren(parent)) {\n        jsExceptionHere(JSET_ERROR, \"Field or method \\\"%v\\\" does not already exist, and can't create it on %t\", dst, parent);\n      } else {\n        // Remove the 'new child' flagging\n        jsvUnRef(parent);\n        jsvSetNextSibling(dst, 0);\n        jsvUnRef(parent);\n        jsvSetPrevSibling(dst, 0);\n        // Add to the parent\n        jsvAddName(parent, dst);\n      }\n    }\n    jsvUnLock(parent);\n  }\n}\n\n/* See jsvReplaceWith - this does the same but will\n * shove the variable in execInfo.root if it hasn't\n * been defined yet */\nvoid jsvReplaceWithOrAddToRoot(JsVar *dst, JsVar *src) {\n  /* If we're assigning to this and we don't have a parent,\n   * add it to the symbol table root */\n  if (!jsvGetRefs(dst) && jsvIsName(dst)) {\n    if (!jsvIsArrayBufferName(dst) && !jsvIsNewChild(dst))\n      jsvAddName(execInfo.root, dst);\n  }\n  jsvReplaceWith(dst, src);\n}\n\n/** Get the item at the given location in the array buffer and return the result */\nsize_t jsvGetArrayBufferLength(const JsVar *arrayBuffer) {\n  assert(jsvIsArrayBuffer(arrayBuffer));\n  return arrayBuffer->varData.arraybuffer.length;\n}\n\n/** Get the String the contains the data for this arrayBuffer. Is ok with being passed a String in the first place. Offset is the offset in the backing string of this arraybuffer. */\nJsVar *jsvGetArrayBufferBackingString(JsVar *arrayBuffer, uint32_t *offset) {\n  jsvLockAgain(arrayBuffer);\n  if (offset) *offset = 0;\n  while (jsvIsArrayBuffer(arrayBuffer)) {\n    if (offset) *offset += arrayBuffer->varData.arraybuffer.byteOffset;\n    JsVar *s = jsvLock(jsvGetFirstChild(arrayBuffer));\n    jsvUnLock(arrayBuffer);\n    arrayBuffer = s;\n  }\n  assert(jsvIsString(arrayBuffer));\n  return arrayBuffer;\n}\n\n/** Get the item at the given location in the array buffer and return the result */\nJsVar *jsvArrayBufferGet(JsVar *arrayBuffer, size_t idx) {\n  JsvArrayBufferIterator it;\n  jsvArrayBufferIteratorNew(&it, arrayBuffer, idx);\n  JsVar *v = jsvArrayBufferIteratorGetValue(&it);\n  jsvArrayBufferIteratorFree(&it);\n  return v;\n}\n\n/** Set the item at the given location in the array buffer */\nvoid jsvArrayBufferSet(JsVar *arrayBuffer, size_t idx, JsVar *value) {\n  JsvArrayBufferIterator it;\n  jsvArrayBufferIteratorNew(&it, arrayBuffer, idx);\n  jsvArrayBufferIteratorSetValue(&it, value);\n  jsvArrayBufferIteratorFree(&it);\n}\n\n\n/** Given an integer name that points to an arraybuffer or an arraybufferview, evaluate it and return the result */\nJsVar *jsvArrayBufferGetFromName(JsVar *name) {\n  assert(jsvIsArrayBufferName(name));\n  size_t idx = (size_t)jsvGetInteger(name);\n  JsVar *arrayBuffer = jsvLock(jsvGetFirstChild(name));\n  JsVar *value = jsvArrayBufferGet(arrayBuffer, idx);\n  jsvUnLock(arrayBuffer);\n  return value;\n}\n\n\nJsVar *jsvGetFunctionArgumentLength(JsVar *functionScope) {\n  JsVar *args = jsvNewEmptyArray();\n  if (!args) return 0; // out of memory\n\n  JsvObjectIterator it;\n  jsvObjectIteratorNew(&it, functionScope);\n  while (jsvObjectIteratorHasValue(&it)) {\n    JsVar *idx = jsvObjectIteratorGetKey(&it);\n    if (jsvIsFunctionParameter(idx)) {\n      JsVar *val = jsvSkipOneName(idx);\n      jsvArrayPushAndUnLock(args, val);\n    }\n    jsvUnLock(idx);\n    jsvObjectIteratorNext(&it);\n  }\n  jsvObjectIteratorFree(&it);\n\n  return args;\n}\n\n/** Is this variable actually defined? eg, can we pass it into `jsvSkipName`\n * without getting a ReferenceError? This also returns false if the variable\n * if ok, but has the value `undefined`. */\nbool jsvIsVariableDefined(JsVar *a) {\n  return !jsvIsName(a) ||\n         jsvIsNameWithValue(a) ||\n         (jsvGetFirstChild(a)!=0);\n}\n\n/* If this is a simple name (that links to another var) the\n * return that var, else 0. Unlike jsvSkipName this doesn't\n * repeatedly get the name, or evaluate getters. */\nJsVar *jsvGetValueOfName(JsVar *a) {\n  if (!a) return 0;\n  if (jsvIsArrayBufferName(a)) return jsvArrayBufferGetFromName(a);\n  if (jsvIsNameInt(a)) return jsvNewFromInteger((JsVarInt)jsvGetFirstChildSigned(a));\n  if (jsvIsNameIntBool(a)) return jsvNewFromBool(jsvGetFirstChild(a)!=0);\n  assert(!jsvIsNameWithValue(a));\n  if (jsvIsName(a))\n    return jsvLockSafe(jsvGetFirstChild(a));\n  return 0;\n}\n\n/* Check for and trigger a ReferenceError on a variable if it's a name that doesn't exist */\nvoid jsvCheckReferenceError(JsVar *a) {\n  if (jsvIsBasicName(a) && jsvGetRefs(a)==0 && !jsvIsNewChild(a) && !jsvGetFirstChild(a))\n    jsExceptionHere(JSET_REFERENCEERROR, \"%q is not defined\", a);\n}\n\n\n\n/** If a is a name skip it and go to what it points to - and so on (if repeat=true).\n * ALWAYS locks - so must unlock what it returns. It MAY\n * return 0. Throws a ReferenceError if variable is not defined,\n * but you can check if it will with jsvIsReferenceError.\n * If a 'getter' needs to be executed, 'parent' is the object that\n * gets used unless a NewChild overwrites it */\nJsVar *jsvSkipNameWithParent(JsVar *a, bool repeat, JsVar *parent) {\n  if (!a) return 0;\n  if (jsvIsArrayBufferName(a)) return jsvArrayBufferGetFromName(a);\n  if (jsvIsNameInt(a)) return jsvNewFromInteger((JsVarInt)jsvGetFirstChildSigned(a));\n  if (jsvIsNameIntBool(a)) return jsvNewFromBool(jsvGetFirstChild(a)!=0);\n  JsVar *pa = jsvLockAgain(a);\n  while (jsvIsName(pa)) {\n    JsVarRef n = jsvGetFirstChild(pa);\n    jsvUnLock(pa);\n    if (!n) {\n      // check here as it's less likely we get here (=faster)\n      if (pa==a) jsvCheckReferenceError(a);\n      return 0;\n    }\n    pa = jsvLock(n);\n    assert(pa!=a);\n    if (!repeat) break;\n  }\n#ifndef SAVE_ON_FLASH\n  if (jsvIsGetterOrSetter(pa)) {\n    JsVar *getterParent = jsvIsNewChild(a)?jsvLock(jsvGetNextSibling(a)):0;\n    JsVar *v = jsvExecuteGetter(getterParent?getterParent:parent, pa);\n    jsvUnLock2(getterParent,pa);\n    pa = v;\n  }\n#endif\n  return pa;\n}\n\n/** If a is a name skip it and go to what it points to - and so on\n * ALWAYS locks - so must unlock what it returns. It MAY\n * return 0. Throws a ReferenceError if variable is not defined,\n * but you can check if it will with jsvIsReferenceError */\nJsVar *jsvSkipName(JsVar *a) {\n  return jsvSkipNameWithParent(a, true, 0);\n}\n\n/** If a is a name skip it and go to what it points to.\n * ALWAYS locks - so must unlock what it returns. It MAY\n * return 0. Throws a ReferenceError if variable is not defined,\n * but you can check if it will with jsvIsReferenceError */\nJsVar *jsvSkipOneName(JsVar *a) {\n  return jsvSkipNameWithParent(a, false, 0);\n}\n\n/** If a is a's child is a name skip it and go to what it points to.\n * ALWAYS locks - so must unlock what it returns.  */\nJsVar *jsvSkipToLastName(JsVar *a) {\n  assert(jsvIsName(a));\n  a = jsvLockAgain(a);\n  while (true) {\n    if (!jsvGetFirstChild(a)) return a;\n    JsVar *child = jsvLock(jsvGetFirstChild(a));\n    if (jsvIsName(child)) {\n      jsvUnLock(a);\n      a = child;\n    } else {\n      jsvUnLock(child);\n      return a;\n    }\n  }\n  return 0; // not called\n}\n\n/** Same as jsvSkipName, but ensures that 'a' is unlocked */\nJsVar *jsvSkipNameAndUnLock(JsVar *a) {\n  JsVar *b = jsvSkipName(a);\n  jsvUnLock(a);\n  return b;\n}\n\n/** Same as jsvSkipOneName, but ensures that 'a' is unlocked */\nJsVar *jsvSkipOneNameAndUnLock(JsVar *a) {\n  JsVar *b = jsvSkipOneName(a);\n  jsvUnLock(a);\n  return b;\n}\n\nbool jsvIsStringEqualOrStartsWithOffset(JsVar *var, const char *str, bool isStartsWith, size_t startIdx, bool ignoreCase) {\n  if (!jsvHasCharacterData(var)) {\n    return 0; // not a string so not equal!\n  }\n\n  JsvStringIterator it;\n  jsvStringIteratorNew(&it, var, startIdx);\n  if (ignoreCase) {\n      while (jsvStringIteratorHasChar(&it) && *str &&\n          charToLowerCase(jsvStringIteratorGetChar(&it)) == charToLowerCase(*str)) {\n        str++;\n        jsvStringIteratorNext(&it);\n      }\n  } else {\n      while (jsvStringIteratorHasChar(&it) && *str &&\n             jsvStringIteratorGetChar(&it) == *str) {\n        str++;\n        jsvStringIteratorNext(&it);\n      }\n  }\n  bool eq = (isStartsWith && !*str) ||\n            jsvStringIteratorGetChar(&it)==*str; // should both be 0 if equal\n  jsvStringIteratorFree(&it);\n  return eq;\n}\n\n/*\njsvIsStringEqualOrStartsWith(A, B, false) is a proper A==B\njsvIsStringEqualOrStartsWith(A, B, true) is A.startsWith(B)\n */\nbool jsvIsStringEqualOrStartsWith(JsVar *var, const char *str, bool isStartsWith) {\n  return jsvIsStringEqualOrStartsWithOffset(var, str, isStartsWith, 0, false);\n}\n\n// Also see jsvIsBasicVarEqual\nbool jsvIsStringEqual(JsVar *var, const char *str) {\n  return jsvIsStringEqualOrStartsWith(var, str, false);\n}\n\n// Also see jsvIsBasicVarEqual\nbool jsvIsStringIEqualAndUnLock(JsVar *var, const char *str) {\n  bool b = jsvIsStringEqualOrStartsWithOffset(var, str, false, 0, true);\n  jsvUnLock(var);\n  return b;\n}\n\n\n/** Compare 2 strings, starting from the given character positions. equalAtEndOfString means that\n * if one of the strings ends (even if the other hasn't), we treat them as equal.\n * For a basic strcmp, do: jsvCompareString(a,b,0,0,false)\n *  */\nint jsvCompareString(JsVar *va, JsVar *vb, size_t starta, size_t startb, bool equalAtEndOfString) {\n  JsvStringIterator ita, itb;\n  jsvStringIteratorNew(&ita, va, starta);\n  jsvStringIteratorNew(&itb, vb, startb);\n  // step to first positions\n  while (true) {\n    int ca = jsvStringIteratorGetCharOrMinusOne(&ita);\n    int cb = jsvStringIteratorGetCharOrMinusOne(&itb);\n\n    if (ca != cb) {\n      jsvStringIteratorFree(&ita);\n      jsvStringIteratorFree(&itb);\n      if ((ca<0 || cb<0) && equalAtEndOfString) return 0;\n      return ca - cb;\n    }\n    if (ca < 0) { // both equal, but end of string\n      jsvStringIteratorFree(&ita);\n      jsvStringIteratorFree(&itb);\n      return 0;\n    }\n    jsvStringIteratorNext(&ita);\n    jsvStringIteratorNext(&itb);\n  }\n  // never get here, but the compiler warns...\n  return true;\n}\n\n/** Return a new string containing just the characters that are\n * shared between two strings. */\nJsVar *jsvGetCommonCharacters(JsVar *va, JsVar *vb) {\n  JsVar *v = jsvNewFromEmptyString();\n  if (!v) return 0;\n  JsvStringIterator ita, itb;\n  jsvStringIteratorNew(&ita, va, 0);\n  jsvStringIteratorNew(&itb, vb, 0);\n  int ca = jsvStringIteratorGetCharOrMinusOne(&ita);\n  int cb = jsvStringIteratorGetCharOrMinusOne(&itb);\n  while (ca>0 && cb>0 && ca == cb) {\n    jsvAppendCharacter(v, (char)ca);\n    jsvStringIteratorNext(&ita);\n    jsvStringIteratorNext(&itb);\n    ca = jsvStringIteratorGetCharOrMinusOne(&ita);\n    cb = jsvStringIteratorGetCharOrMinusOne(&itb);\n  }\n  jsvStringIteratorFree(&ita);\n  jsvStringIteratorFree(&itb);\n  return v;\n}\n\n\n/** Compare 2 integers, >0 if va>vb,  <0 if va<vb. If compared with a non-integer, that gets put later */\nint jsvCompareInteger(JsVar *va, JsVar *vb) {\n  if (jsvIsInt(va) && jsvIsInt(vb))\n    return (int)(jsvGetInteger(va) - jsvGetInteger(vb));\n  else if (jsvIsInt(va))\n    return -1;\n  else if (jsvIsInt(vb))\n    return 1;\n  else\n    return 0;\n}\n\n/** Copy only a name, not what it points to. ALTHOUGH the link to what it points to is maintained unless linkChildren=false\n    If keepAsName==false, this will be converted into a normal variable */\nJsVar *jsvCopyNameOnly(JsVar *src, bool linkChildren, bool keepAsName) {\n  assert(jsvIsName(src));\n  JsVarFlags flags = src->flags;\n  JsVar *dst = 0;\n  if (!keepAsName) {\n    JsVarFlags t = src->flags & JSV_VARTYPEMASK;\n    if (t>=_JSV_NAME_INT_START && t<=_JSV_NAME_INT_END) {\n      flags = (flags & ~JSV_VARTYPEMASK) | JSV_INTEGER;\n    } else {\n      assert((JSV_NAME_STRING_INT_0 < JSV_NAME_STRING_0) &&\n          (JSV_NAME_STRING_0 < JSV_STRING_0) &&\n          (JSV_STRING_0 < JSV_STRING_EXT_0)); // this relies on ordering\n      assert(t>=JSV_NAME_STRING_INT_0 && t<=JSV_NAME_STRING_MAX);\n      if (jsvGetLastChild(src)) {\n        /* it's not a simple name string - it has STRING_EXT bits on the end.\n         * Because the max length of NAME and STRING is different we must just\n         * copy */\n        dst = jsvNewFromStringVar(src, 0, JSVAPPENDSTRINGVAR_MAXLENGTH);\n        if (!dst) return 0;\n      } else {\n        flags = (flags & (JsVarFlags)~JSV_VARTYPEMASK) | (JSV_STRING_0 + jsvGetCharactersInVar(src));\n      }\n    }\n  }\n  if (!dst) {\n    dst = jsvNewWithFlags(flags & JSV_VARIABLEINFOMASK);\n    if (!dst) return 0; // out of memory\n\n    memcpy(&dst->varData, &src->varData, JSVAR_DATA_STRING_NAME_LEN);\n\n    assert(jsvGetLastChild(dst) == 0);\n    assert(jsvGetFirstChild(dst) == 0);\n    assert(jsvGetPrevSibling(dst) == 0);\n    assert(jsvGetNextSibling(dst) == 0);\n    // Copy extra string data if there was any\n    if (jsvHasStringExt(src)) {\n      // If it had extra string data it should have been handled above\n      assert(keepAsName || !jsvGetLastChild(src));\n      // copy extra bits of string if there were any\n      if (jsvGetLastChild(src)) {\n        JsVar *child = jsvLock(jsvGetLastChild(src));\n        JsVar *childCopy = jsvCopy(child, true);\n        if (childCopy) { // could be out of memory\n          jsvSetLastChild(dst, jsvGetRef(childCopy)); // no ref for stringext\n          jsvUnLock(childCopy);\n        }\n        jsvUnLock(child);\n      }\n    } else {\n      assert(jsvIsBasic(src)); // in case we missed something!\n    }\n  }\n  // Copy LINK of what it points to\n  if (linkChildren && jsvGetFirstChild(src)) {\n    if (jsvIsNameWithValue(src))\n      jsvSetFirstChild(dst, jsvGetFirstChild(src));\n    else\n      jsvSetFirstChild(dst, jsvRefRef(jsvGetFirstChild(src)));\n  }\n  return dst;\n}\n\nJsVar *jsvCopy(JsVar *src, bool copyChildren) {\n  if (jsvIsFlatString(src)) {\n    // Copy a Flat String into a non-flat string - it's just safer\n    return jsvNewFromStringVar(src, 0, JSVAPPENDSTRINGVAR_MAXLENGTH);\n  }\n  JsVar *dst = jsvNewWithFlags(src->flags & JSV_VARIABLEINFOMASK);\n  if (!dst) return 0; // out of memory\n  if (!jsvIsStringExt(src)) {\n      bool refsAsData = jsvIsBasicString(src)||jsvIsNativeString(src)||jsvIsFlashString(src)||jsvIsNativeFunction(src);\n      memcpy(&dst->varData, &src->varData, refsAsData ? JSVAR_DATA_STRING_LEN : JSVAR_DATA_STRING_NAME_LEN);\n      if (jsvIsNativeFunction(src)) {\n        jsvSetFirstChild(dst,0);\n      }\n      if (!refsAsData) {\n        assert(jsvGetPrevSibling(dst) == 0);\n        assert(jsvGetNextSibling(dst) == 0);\n        assert(jsvGetFirstChild(dst) == 0);\n      }\n      assert(jsvGetLastChild(dst) == 0);\n  } else {\n    // stringexts use the extra pointers after varData to store characters\n    // see jsvGetMaxCharactersInVar\n    memcpy(&dst->varData, &src->varData, JSVAR_DATA_STRING_MAX_LEN);\n    assert(jsvGetLastChild(dst) == 0);\n  }\n\n  // Copy what names point to\n  if (copyChildren && jsvIsName(src)) {\n    if (jsvGetFirstChild(src)) {\n      if (jsvIsNameWithValue(src)) {\n        // name_int/etc don't need references\n        jsvSetFirstChild(dst, jsvGetFirstChild(src));\n      } else {\n        JsVar *child = jsvLock(jsvGetFirstChild(src));\n        JsVar *childCopy = jsvRef(jsvCopy(child, true));\n        jsvUnLock(child);\n        if (childCopy) { // could have been out of memory\n          jsvSetFirstChild(dst, jsvGetRef(childCopy));\n          jsvUnLock(childCopy);\n        }\n      }\n    }\n  }\n\n  if (jsvHasStringExt(src)) {\n    // copy extra bits of string if there were any\n    src = jsvLockAgain(src);\n    JsVar *dstChild = jsvLockAgain(dst);\n    while (jsvGetLastChild(src)) {\n      JsVar *child = jsvLock(jsvGetLastChild(src));\n      if (jsvIsStringExt(child)) {\n        JsVar *childCopy = jsvNewWithFlags(child->flags & JSV_VARIABLEINFOMASK);\n        if (childCopy) {// could be out of memory\n          memcpy(&childCopy->varData, &child->varData, JSVAR_DATA_STRING_MAX_LEN);\n          jsvSetLastChild(dstChild, jsvGetRef(childCopy)); // no ref for stringext\n        }\n        jsvUnLock2(src,dstChild);\n        src = child;\n        dstChild = childCopy;\n      } else {\n        JsVar *childCopy = jsvCopy(child, true);\n        if (childCopy) {// could be out of memory\n          jsvSetLastChild(dstChild, jsvGetRef(childCopy)); // no ref for stringext\n          jsvUnLock(childCopy);\n        }\n        jsvUnLock2(src, dstChild);\n        return dst;\n      }\n    }\n    jsvUnLock2(src,dstChild);\n  } else if (jsvHasChildren(src)) {\n    if (copyChildren) {\n      // Copy children..\n      JsVarRef vr;\n      vr = jsvGetFirstChild(src);\n      while (vr) {\n        JsVar *name = jsvLock(vr);\n        JsVar *child = jsvCopyNameOnly(name, true/*link children*/, true/*keep as name*/); // NO DEEP COPY!\n        if (child) { // could have been out of memory\n          jsvAddName(dst, child);\n          jsvUnLock(child);\n        }\n        vr = jsvGetNextSibling(name);\n        jsvUnLock(name);\n      }\n    }\n  } else {\n    assert(jsvIsBasic(src)); // in case we missed something!\n  }\n\n  return dst;\n}\n\nvoid jsvAddName(JsVar *parent, JsVar *namedChild) {\n  namedChild = jsvRef(namedChild); // ref here VERY important as adding to structure!\n  assert(jsvIsName(namedChild));\n\n  // update array length\n  if (jsvIsArray(parent) && jsvIsInt(namedChild)) {\n    JsVarInt index = namedChild->varData.integer;\n    if (index >= jsvGetArrayLength(parent)) {\n      jsvSetArrayLength(parent, index + 1, false);\n    }\n  }\n\n  if (jsvGetLastChild(parent)) { // we have children already\n    JsVar *insertAfter = jsvLock(jsvGetLastChild(parent));\n    if (jsvIsArray(parent)) {\n      // we must insert in order - so step back until we get the right place\n      while (insertAfter && jsvCompareInteger(namedChild, insertAfter)<0) {\n        JsVarRef prev = jsvGetPrevSibling(insertAfter);\n        jsvUnLock(insertAfter);\n        insertAfter = jsvLockSafe(prev);\n      }\n    }\n\n    if (insertAfter) {\n      assert(jsvIsName(insertAfter));\n      if (jsvGetNextSibling(insertAfter)) {\n        // great, we're in the middle...\n        JsVar *insertBefore = jsvLock(jsvGetNextSibling(insertAfter));\n        jsvSetPrevSibling(insertBefore, jsvGetRef(namedChild));\n        jsvSetNextSibling(namedChild, jsvGetRef(insertBefore));\n        jsvUnLock(insertBefore);\n      } else {\n        // We're at the end - just set up the parent\n        jsvSetLastChild(parent, jsvGetRef(namedChild));\n      }\n      jsvSetNextSibling(insertAfter, jsvGetRef(namedChild));\n      jsvSetPrevSibling(namedChild, jsvGetRef(insertAfter));\n      jsvUnLock(insertAfter);\n    } else { // Insert right at the beginning of the array\n      // Link 2 children together\n      JsVar *firstChild = jsvLock(jsvGetFirstChild(parent));\n      jsvSetPrevSibling(firstChild, jsvGetRef(namedChild));\n      jsvUnLock(firstChild);\n\n      jsvSetNextSibling(namedChild, jsvGetFirstChild(parent));\n      // finally set the new child as the first one\n      jsvSetFirstChild(parent, jsvGetRef(namedChild));\n    }\n  } else { // we have no children - just add it\n    JsVarRef r = jsvGetRef(namedChild);\n    jsvSetFirstChild(parent, r);\n    jsvSetLastChild(parent, r);\n  }\n}\n\nJsVar *jsvAddNamedChild(JsVar *parent, JsVar *child, const char *name) {\n  JsVar *namedChild = jsvMakeIntoVariableName(jsvNewFromString(name), child);\n  if (!namedChild) return 0; // Out of memory\n  jsvAddName(parent, namedChild);\n  return namedChild;\n}\n\nJsVar *jsvSetNamedChild(JsVar *parent, JsVar *child, const char *name) {\n  JsVar *namedChild = jsvFindChildFromString(parent, name, true);\n  if (namedChild) // could be out of memory\n    return jsvSetValueOfName(namedChild, child);\n  return 0;\n}\n\nJsVar *jsvSetValueOfName(JsVar *name, JsVar *src) {\n  assert(name && jsvIsName(name));\n  assert(name!=src); // no infinite loops!\n  // all is fine, so replace the existing child...\n  /* Existing child may be null in the case of Z = 0 where\n   * we create 'Z' and pass it down to '=' to have the value\n   * filled in (or it may be undefined). */\n  if (jsvIsNameWithValue(name)) {\n    if (jsvIsString(name))\n      name->flags = (name->flags & (JsVarFlags)~JSV_VARTYPEMASK) | (JSV_NAME_STRING_0 + jsvGetCharactersInVar(name));\n    else\n      name->flags = (name->flags & (JsVarFlags)~JSV_VARTYPEMASK) | JSV_NAME_INT;\n    jsvSetFirstChild(name, 0);\n  } else if (jsvGetFirstChild(name))\n    jsvUnRefRef(jsvGetFirstChild(name)); // free existing\n  if (src) {\n    if (jsvIsInt(name)) {\n      if ((jsvIsInt(src) || jsvIsBoolean(src)) && !jsvIsPin(src)) {\n        JsVarInt v = src->varData.integer;\n        if (v>=JSVARREF_MIN && v<=JSVARREF_MAX) {\n          name->flags = (name->flags & (JsVarFlags)~JSV_VARTYPEMASK) | (jsvIsInt(src) ? JSV_NAME_INT_INT : JSV_NAME_INT_BOOL);\n          jsvSetFirstChild(name, (JsVarRef)v);\n          return name;\n        }\n      }\n    } else if (jsvIsString(name)) {\n      if (jsvIsInt(src) && !jsvIsPin(src)) {\n        JsVarInt v = src->varData.integer;\n        if (v>=JSVARREF_MIN && v<=JSVARREF_MAX) {\n          name->flags = (name->flags & (JsVarFlags)~JSV_VARTYPEMASK) | (JSV_NAME_STRING_INT_0 + jsvGetCharactersInVar(name));\n          jsvSetFirstChild(name, (JsVarRef)v);\n          return name;\n        }\n      }\n    }\n    // we can link to a name if we want (so can remove the assert!)\n    jsvSetFirstChild(name, jsvGetRef(jsvRef(src)));\n  } else\n    jsvSetFirstChild(name, 0);\n  return name;\n}\n\nJsVar *jsvFindChildFromString(JsVar *parent, const char *name, bool addIfNotFound) {\n  /* Pull out first 4 bytes, and ensure that everything\n   * is 0 padded so that we can do a nice speedy check. */\n  char fastCheck[4];\n  fastCheck[0] = name[0];\n  if (name[0]) {\n    fastCheck[1] = name[1];\n    if (name[1]) {\n      fastCheck[2] = name[2];\n      if (name[2]) {\n        fastCheck[3] = name[3];\n      } else {\n        fastCheck[3] = 0;\n      }\n    } else {\n      fastCheck[2] = 0;\n      fastCheck[3] = 0;\n    }\n  } else {\n    fastCheck[1] = 0;\n    fastCheck[2] = 0;\n    fastCheck[3] = 0;\n  }\n\n  assert(jsvHasChildren(parent));\n  JsVarRef childref = jsvGetFirstChild(parent);\n  while (childref) {\n    // Don't Lock here, just use GetAddressOf - to try and speed up the finding\n    // TODO: We can do this now, but when/if we move to cacheing vars, it'll break\n    JsVar *child = jsvGetAddressOf(childref);\n    if (*(int*)fastCheck==*(int*)child->varData.str && // speedy check of first 4 bytes\n        jsvIsStringEqual(child, name)) {\n      // found it! unlock parent but leave child locked\n      return jsvLockAgain(child);\n    }\n    childref = jsvGetNextSibling(child);\n  }\n\n  JsVar *child = 0;\n  if (addIfNotFound) {\n    child = jsvMakeIntoVariableName(jsvNewFromString(name), 0);\n    if (child) // could be out of memory\n      jsvAddName(parent, child);\n  }\n  return child;\n}\n\n/// Find a child with a matching name using a case insensitive search\nJsVar *jsvFindChildFromStringI(JsVar *parent, const char *name) {\n  assert(jsvHasChildren(parent));\n  JsVarRef childref = jsvGetFirstChild(parent);\n  while (childref) {\n    // Don't Lock here, just use GetAddressOf - to try and speed up the finding\n    // TODO: We can do this now, but when/if we move to cacheing vars, it'll break\n    JsVar *child = jsvGetAddressOf(childref);\n    if (jsvHasCharacterData(child) &&\n        jsvIsStringEqualOrStartsWithOffset(child, name, false, 0, true)) {\n      // found it! unlock parent but leave child locked\n      return jsvLockAgain(child);\n    }\n    childref = jsvGetNextSibling(child);\n  }\n  return 0;\n}\n\n/// See jsvIsNewChild - for fields that don't exist yet\nJsVar *jsvCreateNewChild(JsVar *parent, JsVar *index, JsVar *child) {\n  JsVar *newChild = jsvAsName(index);\n  if (!newChild) return 0;\n  assert(!jsvGetFirstChild(newChild));\n  if (child) jsvSetValueOfName(newChild, child);\n  assert(!jsvGetNextSibling(newChild) && !jsvGetPrevSibling(newChild));\n  // by setting the siblings as the same, we signal that if set,\n  // we should be made a member of the given object\n  JsVarRef r = jsvGetRef(jsvRef(jsvRef(parent)));\n  jsvSetNextSibling(newChild, r);\n  jsvSetPrevSibling(newChild, r);\n\n  return newChild;\n}\n\n/** Try and turn the supplied variable into a name. If not, make a new one. This locks again. */\nJsVar *jsvAsName(JsVar *var) {\n  if (!var) return 0;\n  if (jsvGetRefs(var) == 0) {\n    // Not reffed - great! let's just use it\n    if (!jsvIsName(var))\n      var = jsvMakeIntoVariableName(var, 0);\n    return jsvLockAgain(var);\n  } else { // it was reffed, we must add a new one\n    return jsvMakeIntoVariableName(jsvCopy(var, false), 0);\n  }\n}\n\n/** Non-recursive finding */\nJsVar *jsvFindChildFromVar(JsVar *parent, JsVar *childName, bool addIfNotFound) {\n  JsVar *child;\n  JsVarRef childref = jsvGetFirstChild(parent);\n\n  while (childref) {\n    child = jsvLock(childref);\n    if (jsvIsBasicVarEqual(child, childName)) {\n      // found it! unlock parent but leave child locked\n      return child;\n    }\n    childref = jsvGetNextSibling(child);\n    jsvUnLock(child);\n  }\n\n  child = 0;\n  if (addIfNotFound && childName) {\n    child = jsvAsName(childName);\n    jsvAddName(parent, child);\n  }\n  return child;\n}\n\nvoid jsvRemoveChild(JsVar *parent, JsVar *child) {\n  assert(jsvHasChildren(parent));\n  assert(jsvIsName(child));\n#ifdef DEBUG\n  assert(jsvIsChild(parent, child));\n#endif\n  JsVarRef childref = jsvGetRef(child);\n  bool wasChild = false;\n  // unlink from parent\n  if (jsvGetFirstChild(parent) == childref) {\n    jsvSetFirstChild(parent, jsvGetNextSibling(child));\n    wasChild = true;\n  }\n  if (jsvGetLastChild(parent) == childref) {\n    jsvSetLastChild(parent, jsvGetPrevSibling(child));\n    wasChild = true;\n    // If this was an array and we were the last\n    // element, update the length\n    if (jsvIsArray(parent)) {\n      JsVarInt l = 0;\n      // get index of last child\n      if (jsvGetLastChild(parent))\n        l = jsvGetIntegerAndUnLock(jsvLock(jsvGetLastChild(parent)))+1;\n      // set it\n      jsvSetArrayLength(parent, l, false);\n    }\n  }\n  // unlink from child list\n  if (jsvGetPrevSibling(child)) {\n    JsVar *v = jsvLock(jsvGetPrevSibling(child));\n    assert(jsvGetNextSibling(v) == jsvGetRef(child));\n    jsvSetNextSibling(v, jsvGetNextSibling(child));\n    jsvUnLock(v);\n    wasChild = true;\n  }\n  if (jsvGetNextSibling(child)) {\n    JsVar *v = jsvLock(jsvGetNextSibling(child));\n    assert(jsvGetPrevSibling(v) == jsvGetRef(child));\n    jsvSetPrevSibling(v, jsvGetPrevSibling(child));\n    jsvUnLock(v);\n    wasChild = true;\n  }\n\n  jsvSetPrevSibling(child, 0);\n  jsvSetNextSibling(child, 0);\n  if (wasChild)\n    jsvUnRef(child);\n}\n\nvoid jsvRemoveAllChildren(JsVar *parent) {\n  assert(jsvHasChildren(parent));\n  while (jsvGetFirstChild(parent)) {\n    JsVar *v = jsvLock(jsvGetFirstChild(parent));\n    jsvRemoveChild(parent, v);\n    jsvUnLock(v);\n  }\n}\n\n/// Check if the given name is a child of the parent\nbool jsvIsChild(JsVar *parent, JsVar *child) {\n  assert(jsvIsArray(parent) || jsvIsObject(parent));\n  assert(jsvIsName(child));\n  JsVarRef childref = jsvGetRef(child);\n  JsVarRef indexref;\n  indexref = jsvGetFirstChild(parent);\n  while (indexref) {\n    if (indexref == childref) return true;\n    // get next\n    JsVar *indexVar = jsvLock(indexref);\n    indexref = jsvGetNextSibling(indexVar);\n    jsvUnLock(indexVar);\n  }\n  return false; // not found undefined\n}\n\n/// Get the named child of an object. If createChild!=0 then create the child\nJsVar *jsvObjectGetChild(JsVar *obj, const char *name, JsVarFlags createChild) {\n  if (!obj) return 0;\n  assert(jsvHasChildren(obj));\n  JsVar *childName = jsvFindChildFromString(obj, name, createChild!=0);\n  JsVar *child = jsvSkipName(childName);\n  if (!child && createChild && childName!=0/*out of memory?*/) {\n    child = jsvNewWithFlags(createChild);\n    jsvSetValueOfName(childName, child);\n    jsvUnLock(childName);\n    return child;\n  }\n  jsvUnLock(childName);\n  return child;\n}\n\n/// Get the named child of an object using a case-insensitive search\nJsVar *jsvObjectGetChildI(JsVar *obj, const char *name) {\n  if (!obj) return 0;\n  assert(jsvHasChildren(obj));\n  return jsvSkipNameAndUnLock(jsvFindChildFromStringI(obj, name));\n}\n\n/// Set the named child of an object, and return the child (so you can choose to unlock it if you want)\nJsVar *jsvObjectSetChild(JsVar *obj, const char *name, JsVar *child) {\n  assert(jsvHasChildren(obj));\n  if (!jsvHasChildren(obj)) return 0;\n  // child can actually be a name (for instance if it is a named function)\n  JsVar *childName = jsvFindChildFromString(obj, name, true);\n  if (!childName) return 0; // out of memory\n  jsvSetValueOfName(childName, child);\n  jsvUnLock(childName);\n  return child;\n}\n\n/// Set the named child of an object, and return the child (so you can choose to unlock it if you want)\nJsVar *jsvObjectSetChildVar(JsVar *obj, JsVar *name, JsVar *child) {\n  assert(jsvHasChildren(obj));\n  if (!jsvHasChildren(obj)) return 0;\n  // child can actually be a name (for instance if it is a named function)\n  JsVar *childName = jsvFindChildFromVar(obj, name, true);\n  if (!childName) return 0; // out of memory\n  jsvSetValueOfName(childName, child);\n  jsvUnLock(childName);\n  return child;\n}\n\nvoid jsvObjectSetChildAndUnLock(JsVar *obj, const char *name, JsVar *child) {\n  jsvUnLock(jsvObjectSetChild(obj, name, child));\n}\n\nvoid jsvObjectRemoveChild(JsVar *obj, const char *name) {\n  JsVar *child = jsvFindChildFromString(obj, name, false);\n  if (child) {\n    jsvRemoveChild(obj, child);\n    jsvUnLock(child);\n  }\n}\n\n/** Set the named child of an object, and return the child (so you can choose to unlock it if you want).\n * If the child is 0, the 'name' is also removed from the object */\nJsVar *jsvObjectSetOrRemoveChild(JsVar *obj, const char *name, JsVar *child) {\n  if (child)\n    jsvObjectSetChild(obj, name, child);\n  else\n    jsvObjectRemoveChild(obj, name);\n  return child;\n}\n\n/** Append all keys from the source object to the target object. Will ignore hidden/internal fields */\nvoid jsvObjectAppendAll(JsVar *target, JsVar *source) {\n  assert(jsvIsObject(target));\n  assert(jsvIsObject(source));\n  JsvObjectIterator it;\n  jsvObjectIteratorNew(&it, source);\n  while (jsvObjectIteratorHasValue(&it)) {\n    JsVar *k = jsvObjectIteratorGetKey(&it);\n    JsVar *v = jsvSkipName(k);\n    if (!jsvIsInternalObjectKey(k))\n      jsvObjectSetChildVar(target, k, v);\n    jsvUnLock2(k,v);\n    jsvObjectIteratorNext(&it);\n  }\n  jsvObjectIteratorFree(&it);\n}\n\nint jsvGetChildren(const JsVar *v) {\n  //OPT: could length be stored as the value of the array?\n  int children = 0;\n  JsVarRef childref = jsvGetFirstChild(v);\n  while (childref) {\n    JsVar *child = jsvLock(childref);\n    children++;\n    childref = jsvGetNextSibling(child);\n    jsvUnLock(child);\n  }\n  return children;\n}\n\n/// Get the first child's name from an object,array or function\nJsVar *jsvGetFirstName(JsVar *v) {\n  assert(jsvHasChildren(v));\n  if (!jsvGetFirstChild(v)) return 0;\n  return jsvLock(jsvGetFirstChild(v));\n}\n\nJsVarInt jsvGetArrayLength(const JsVar *arr) {\n  if (!arr) return 0;\n  assert(jsvIsArray(arr));\n  return arr->varData.integer;\n}\n\nJsVarInt jsvSetArrayLength(JsVar *arr, JsVarInt length, bool truncate) {\n  assert(jsvIsArray(arr));\n  if (truncate && length < arr->varData.integer) {\n    // @TODO implement truncation here\n  }\n  arr->varData.integer = length;\n  return length;\n}\n\nJsVarInt jsvGetLength(const JsVar *src) {\n  if (jsvIsArray(src)) {\n    return jsvGetArrayLength(src);\n  } else if (jsvIsArrayBuffer(src)) {\n    return (JsVarInt)jsvGetArrayBufferLength(src);\n  } else if (jsvIsString(src)) {\n    return (JsVarInt)jsvGetStringLength(src);\n  } else if (jsvIsObject(src) || jsvIsFunction(src)) {\n    return jsvGetChildren(src);\n  } else {\n    return 1;\n  }\n}\n\n/** Count the amount of JsVars used. Mostly useful for debugging */\nstatic size_t _jsvCountJsVarsUsedRecursive(JsVar *v, bool resetRecursionFlag) {\n  if (!v) return 0;\n  // Use IS_RECURSING  flag to stop recursion\n  if (resetRecursionFlag) {\n    if (!(v->flags & JSV_IS_RECURSING))\n      return 0;\n    v->flags &= ~JSV_IS_RECURSING;\n  } else {\n    if (v->flags & JSV_IS_RECURSING)\n      return 0;\n    v->flags |= JSV_IS_RECURSING;\n  }\n\n  size_t count = 1;\n  if (jsvHasSingleChild(v) || jsvHasChildren(v)) {\n    JsVarRef childref = jsvGetFirstChild(v);\n    while (childref) {\n      JsVar *child = jsvLock(childref);\n      count += _jsvCountJsVarsUsedRecursive(child, resetRecursionFlag);\n      if (jsvHasChildren(v)) childref = jsvGetNextSibling(child);\n      else childref = 0;\n      jsvUnLock(child);\n    }\n  } else if (jsvIsFlatString(v))\n    count += jsvGetFlatStringBlocks(v);\n  if (jsvHasCharacterData(v)) {\n    JsVarRef childref = jsvGetLastChild(v);\n    while (childref) {\n      JsVar *child = jsvLock(childref);\n      count++;\n      childref = jsvGetLastChild(child);\n      jsvUnLock(child);\n    }\n  }\n  if (jsvIsName(v) && !jsvIsNameWithValue(v) && jsvGetFirstChild(v)) {\n    JsVar *child = jsvLock(jsvGetFirstChild(v));\n    count += _jsvCountJsVarsUsedRecursive(child, resetRecursionFlag);\n    jsvUnLock(child);\n  }\n  return count;\n}\n\n/** Count the amount of JsVars used. Mostly useful for debugging */\nsize_t jsvCountJsVarsUsed(JsVar *v) {\n  // don't count 'root' when getting sizes\n  if ((execInfo.root) && (v != execInfo.root)) execInfo.root->flags |= JSV_IS_RECURSING;\n  // we do this so we don't count the same item twice, but don't use too much memory\n  size_t c = _jsvCountJsVarsUsedRecursive(v, false);\n  _jsvCountJsVarsUsedRecursive(v, true);\n  // restore recurse flag\n  if ((execInfo.root) && (v != execInfo.root)) execInfo.root->flags &= ~JSV_IS_RECURSING;\n  return c;\n}\n\nJsVar *jsvGetArrayIndex(const JsVar *arr, JsVarInt index) {\n  JsVarRef childref = jsvGetLastChild(arr);\n  JsVarInt lastArrayIndex = 0;\n  // Look at last non-string element!\n  while (childref) {\n    JsVar *child = jsvLock(childref);\n    if (jsvIsInt(child)) {\n      lastArrayIndex = child->varData.integer;\n      // it was the last element... sorted!\n      if (lastArrayIndex == index) {\n        return child;\n      }\n      jsvUnLock(child);\n      break;\n    }\n    // if not an int, keep going\n    childref = jsvGetPrevSibling(child);\n    jsvUnLock(child);\n  }\n  // it's not in this array - don't search the whole lot...\n  if (index > lastArrayIndex)\n    return 0;\n  // otherwise is it more than halfway through?\n  if (index > lastArrayIndex/2) {\n    // it's in the final half of the array (probably) - search backwards\n    while (childref) {\n      JsVar *child = jsvLock(childref);\n\n      assert(jsvIsInt(child));\n      if (child->varData.integer == index) {\n        return child;\n      }\n      childref = jsvGetPrevSibling(child);\n      jsvUnLock(child);\n    }\n  } else {\n    // it's in the first half of the array (probably) - search forwards\n    childref = jsvGetFirstChild(arr);\n    while (childref) {\n      JsVar *child = jsvLock(childref);\n\n      assert(jsvIsInt(child));\n      if (child->varData.integer == index) {\n        return child;\n      }\n      childref = jsvGetNextSibling(child);\n      jsvUnLock(child);\n    }\n  }\n  return 0; // undefined\n}\n\nJsVar *jsvGetArrayItem(const JsVar *arr, JsVarInt index) {\n  return jsvSkipNameAndUnLock(jsvGetArrayIndex(arr,index));\n}\n\nJsVar *jsvGetLastArrayItem(const JsVar *arr) {\n  JsVarRef childref = jsvGetLastChild(arr);\n  if (!childref) return 0;\n  return jsvSkipNameAndUnLock(jsvLock(childref));\n}\n\nvoid jsvSetArrayItem(JsVar *arr, JsVarInt index, JsVar *item) {\n  JsVar *indexVar = jsvGetArrayIndex(arr, index);\n  if (indexVar) {\n    jsvSetValueOfName(indexVar, item);\n  } else {\n    indexVar = jsvMakeIntoVariableName(jsvNewFromInteger(index), item);\n    if (indexVar) // could be out of memory\n      jsvAddName(arr, indexVar);\n  }\n  jsvUnLock(indexVar);\n}\n\n// Get all elements from arr and put them in itemPtr (unless it'd overflow).\n// Makes sure all of itemPtr either contains a JsVar or 0\nvoid jsvGetArrayItems(JsVar *arr, unsigned int itemCount, JsVar **itemPtr) {\n  JsvObjectIterator it;\n  jsvObjectIteratorNew(&it, arr);\n  unsigned int i = 0;\n  while (jsvObjectIteratorHasValue(&it)) {\n    if (i<itemCount)\n      itemPtr[i++] = jsvObjectIteratorGetValue(&it);\n    jsvObjectIteratorNext(&it);\n  }\n  jsvObjectIteratorFree(&it);\n  while (i<itemCount)\n    itemPtr[i++] = 0; // just ensure we don't end up with bad data\n}\n\n/// Get the index of the value in the iterable var (matchExact==use pointer not equality check, matchIntegerIndices = don't check non-integers)\nJsVar *jsvGetIndexOfFull(JsVar *arr, JsVar *value, bool matchExact, bool matchIntegerIndices, int startIdx) {\n  if (!jsvIsIterable(arr)) return 0;\n  JsvIterator it;\n  jsvIteratorNew(&it, arr, JSIF_DEFINED_ARRAY_ElEMENTS);\n  while (jsvIteratorHasElement(&it)) {\n    JsVar *childIndex = jsvIteratorGetKey(&it);\n    if (!matchIntegerIndices ||\n        (jsvIsInt(childIndex) && jsvGetInteger(childIndex)>=startIdx)) {\n      JsVar *childValue = jsvIteratorGetValue(&it);\n      if (childValue==value ||\n          (!matchExact && jsvMathsOpTypeEqual(childValue, value))) {\n        jsvUnLock(childValue);\n        jsvIteratorFree(&it);\n        return childIndex;\n      }\n      jsvUnLock(childValue);\n    }\n    jsvUnLock(childIndex);\n    jsvIteratorNext(&it);\n  }\n  jsvIteratorFree(&it);\n  return 0; // undefined\n}\n\n/// Get the index of the value in the array or object (matchExact==use pointer, not equality check)\nJsVar *jsvGetIndexOf(JsVar *arr, JsVar *value, bool matchExact) {\n  return jsvGetIndexOfFull(arr, value, matchExact, false, 0);\n}\n\n\n/// Adds new elements to the end of an array, and returns the new length. initialValue is the item index when no items are currently in the array.\nJsVarInt jsvArrayAddToEnd(JsVar *arr, JsVar *value, JsVarInt initialValue) {\n  assert(jsvIsArray(arr));\n  JsVarInt index = initialValue;\n  if (jsvGetLastChild(arr)) {\n    JsVar *last = jsvLock(jsvGetLastChild(arr));\n    index = jsvGetInteger(last)+1;\n    jsvUnLock(last);\n  }\n\n  JsVar *idx = jsvMakeIntoVariableName(jsvNewFromInteger(index), value);\n  if (!idx) return 0; // out of memory - error flag will have been set already\n  jsvAddName(arr, idx);\n  jsvUnLock(idx);\n  return index+1;\n}\n\n/// Adds new elements to the end of an array, and returns the new length\nJsVarInt jsvArrayPush(JsVar *arr, JsVar *value) {\n  assert(jsvIsArray(arr));\n  JsVarInt index = jsvGetArrayLength(arr);\n  JsVar *idx = jsvMakeIntoVariableName(jsvNewFromInteger(index), value);\n  if (!idx) return 0; // out of memory - error flag will have been set already\n  jsvAddName(arr, idx);\n  jsvUnLock(idx);\n  return jsvGetArrayLength(arr);\n}\n\n/// Adds a new element to the end of an array, unlocks it, and returns the new length\nJsVarInt jsvArrayPushAndUnLock(JsVar *arr, JsVar *value) {\n  JsVarInt l = jsvArrayPush(arr, value);\n  jsvUnLock(value);\n  return l;\n}\n\n// Push 2 integers onto the end of an array\nvoid jsvArrayPush2Int(JsVar *arr, JsVarInt a, JsVarInt b) {\n  jsvArrayPushAndUnLock(arr, jsvNewFromInteger(a));\n  jsvArrayPushAndUnLock(arr, jsvNewFromInteger(b));\n}\n\n/// Append all values from the source array to the target array\nvoid jsvArrayPushAll(JsVar *target, JsVar *source, bool checkDuplicates) {\n  assert(jsvIsArray(target));\n  assert(jsvIsArray(source));\n  JsvObjectIterator it;\n  jsvObjectIteratorNew(&it, source);\n  while (jsvObjectIteratorHasValue(&it)) {\n    JsVar *v = jsvObjectIteratorGetValue(&it);\n    bool add = true;\n    if (checkDuplicates) {\n      JsVar *idx = jsvGetIndexOf(target, v, false);\n      if (idx) {\n        add = false;\n        jsvUnLock(idx);\n      }\n    }\n    if (add) jsvArrayPush(target, v);\n    jsvUnLock(v);\n    jsvObjectIteratorNext(&it);\n  }\n  jsvObjectIteratorFree(&it);\n}\n\n/// Removes the last element of an array, and returns that element (or 0 if empty). includes the NAME\nJsVar *jsvArrayPop(JsVar *arr) {\n  assert(jsvIsArray(arr));\n  JsVar *child = 0;\n  JsVarInt length = jsvGetArrayLength(arr);\n  if (length > 0) {\n    length--;\n\n    if (jsvGetLastChild(arr)) {\n      // find last child with an integer key\n      JsVarRef ref = jsvGetLastChild(arr);\n      child = jsvLock(ref);\n      while (child && !jsvIsInt(child)) {\n        ref = jsvGetPrevSibling(child);\n        jsvUnLock(child);\n        if (ref) {\n          child = jsvLock(ref);\n        } else {\n          child = 0;\n        }\n      }\n      // check if the last integer key really is the last element\n      if (child) {\n        if (jsvGetInteger(child) == length) {\n          // child is the last element - remove it\n          jsvRemoveChild(arr, child);\n        } else {\n          // child is not the last element\n          jsvUnLock(child);\n          child = 0;\n        }\n      }\n    }\n    // and finally shrink the array\n    jsvSetArrayLength(arr, length, false);\n  }\n\n  return child;\n}\n\n/// Removes the first element of an array, and returns that element (or 0 if empty). DOES NOT RENUMBER.\nJsVar *jsvArrayPopFirst(JsVar *arr) {\n  assert(jsvIsArray(arr));\n  if (jsvGetFirstChild(arr)) {\n    JsVar *child = jsvLock(jsvGetFirstChild(arr));\n    if (jsvGetFirstChild(arr) == jsvGetLastChild(arr))\n      jsvSetLastChild(arr, 0); // if 1 item in array\n    jsvSetFirstChild(arr, jsvGetNextSibling(child)); // unlink from end of array\n    jsvUnRef(child); // as no longer in array\n    if (jsvGetNextSibling(child)) {\n      JsVar *v = jsvLock(jsvGetNextSibling(child));\n      jsvSetPrevSibling(v, 0);\n      jsvUnLock(v);\n    }\n    jsvSetNextSibling(child, 0);\n    return child; // and return it\n  } else {\n    // no children!\n    return 0;\n  }\n}\n\n/// Adds a new variable element to the end of an array (IF it was not already there). Return true if successful\nvoid jsvArrayAddUnique(JsVar *arr, JsVar *v) {\n  JsVar *idx = jsvGetIndexOf(arr, v, false); // did it already exist?\n  if (!idx) {\n    jsvArrayPush(arr, v); // if 0, it failed\n  } else {\n    jsvUnLock(idx);\n  }\n}\n\n/// Join all elements of an array together into a string\nJsVar *jsvArrayJoin(JsVar *arr, JsVar *filler, bool ignoreNull) {\n  JsVar *str = jsvNewFromEmptyString();\n  if (!str) return 0; // out of memory\n  assert(!filler || jsvIsString(filler));\n\n  JsvIterator it;\n  jsvIteratorNew(&it, arr, JSIF_EVERY_ARRAY_ELEMENT);\n  JsvStringIterator itdst;\n  jsvStringIteratorNew(&itdst, str, 0);\n  bool first = true;\n  while (!jspIsInterrupted() && jsvIteratorHasElement(&it)) {\n    JsVar *key = jsvIteratorGetKey(&it);\n    if (jsvIsInt(key)) {\n      // add the filler\n      if (filler && !first)\n        jsvStringIteratorAppendString(&itdst, filler, 0, JSVAPPENDSTRINGVAR_MAXLENGTH);\n      first = false;\n      // add the value\n      JsVar *value = jsvIteratorGetValue(&it);\n      if (value && (!ignoreNull || !jsvIsNull(value))) {\n        JsVar *valueStr = jsvAsString(value);\n        if (valueStr) { // could be out of memory\n          jsvStringIteratorAppendString(&itdst, valueStr, 0, JSVAPPENDSTRINGVAR_MAXLENGTH);\n          jsvUnLock(valueStr);\n        }\n      }\n      jsvUnLock(value);\n    }\n    jsvUnLock(key);\n    jsvIteratorNext(&it);\n  }\n  jsvIteratorFree(&it);\n  jsvStringIteratorFree(&itdst);\n  return str;\n}\n\n/// Insert a new element before beforeIndex, DOES NOT UPDATE INDICES\nvoid jsvArrayInsertBefore(JsVar *arr, JsVar *beforeIndex, JsVar *element) {\n  if (beforeIndex) {\n    JsVar *idxVar = jsvMakeIntoVariableName(jsvNewFromInteger(0), element);\n    if (!idxVar) return; // out of memory\n\n    JsVarRef idxRef = jsvGetRef(jsvRef(idxVar));\n    JsVarRef prev = jsvGetPrevSibling(beforeIndex);\n    if (prev) {\n      JsVar *prevVar = jsvRef(jsvLock(prev));\n      jsvSetInteger(idxVar, jsvGetInteger(prevVar)+1); // update index number\n      jsvSetNextSibling(prevVar, idxRef);\n      jsvUnLock(prevVar);\n      jsvSetPrevSibling(idxVar, prev);\n    } else {\n      jsvSetPrevSibling(idxVar, 0);\n      jsvSetFirstChild(arr, idxRef);\n    }\n    jsvSetPrevSibling(beforeIndex, idxRef);\n    jsvSetNextSibling(idxVar, jsvGetRef(jsvRef(beforeIndex)));\n    jsvUnLock(idxVar);\n  } else\n    jsvArrayPush(arr, element);\n}\n\n/** Same as jsvMathsOpPtr, but if a or b are a name, skip them\n * and go to what they point to. Also handle the case where\n * they may be objects with valueOf functions. */\nJsVar *jsvMathsOpSkipNames(JsVar *a, JsVar *b, int op) {\n  JsVar *pa = jsvSkipName(a);\n  JsVar *pb = jsvSkipName(b);\n  JsVar *oa = jsvGetValueOf(pa);\n  JsVar *ob = jsvGetValueOf(pb);\n  jsvUnLock2(pa, pb);\n  JsVar *res = jsvMathsOp(oa,ob,op);\n  jsvUnLock2(oa, ob);\n  return res;\n}\n\n\nJsVar *jsvMathsOpError(int op, const char *datatype) {\n  char opName[32];\n  jslTokenAsString(op, opName, sizeof(opName));\n  jsError(\"Operation %s not supported on the %s datatype\", opName, datatype);\n  return 0;\n}\n\nbool jsvMathsOpTypeEqual(JsVar *a, JsVar *b) {\n  // check type first, then call again to check data\n  bool eql = (a==0) == (b==0);\n  if (a && b) {\n    // Check whether both are numbers, otherwise check the variable\n    // type flags themselves\n    eql = ((jsvIsInt(a)||jsvIsFloat(a)) && (jsvIsInt(b)||jsvIsFloat(b))) ||\n          (jsvIsString(a) && jsvIsString(b)) ||\n          ((a->flags & JSV_VARTYPEMASK) == (b->flags & JSV_VARTYPEMASK));\n  }\n  if (eql) {\n    JsVar *contents = jsvMathsOp(a,b, LEX_EQUAL);\n    if (!jsvGetBool(contents)) eql = false;\n    jsvUnLock(contents);\n  } else {\n    /* Make sure we don't get in the situation where we have two equal\n     * strings with a check that fails because they were stored differently */\n    assert(!(jsvIsString(a) && jsvIsString(b) && jsvIsBasicVarEqual(a,b)));\n  }\n  return eql;\n}\n\nJsVar *jsvMathsOp(JsVar *a, JsVar *b, int op) {\n  // Type equality check\n  if (op == LEX_TYPEEQUAL || op == LEX_NTYPEEQUAL) {\n    bool eql = jsvMathsOpTypeEqual(a,b);\n    if (op == LEX_TYPEEQUAL)\n      return jsvNewFromBool(eql);\n    else\n      return jsvNewFromBool(!eql);\n  }\n\n  bool needsInt = op=='&' || op=='|' || op=='^' || op==LEX_LSHIFT || op==LEX_RSHIFT || op==LEX_RSHIFTUNSIGNED;\n  bool needsNumeric = needsInt || op=='*' || op=='/' || op=='%' || op=='-';\n  bool isCompare = op==LEX_EQUAL || op==LEX_NEQUAL || op=='<' || op==LEX_LEQUAL || op=='>'|| op==LEX_GEQUAL;\n  if (isCompare) {\n    if (jsvIsNumeric(a) && jsvIsString(b)) {\n      needsNumeric = true;\n      needsInt = jsvIsIntegerish(a) && jsvIsStringNumericInt(b, false);\n    } else if (jsvIsNumeric(b) && jsvIsString(a)) {\n      needsNumeric = true;\n      needsInt = jsvIsIntegerish(b) && jsvIsStringNumericInt(a, false);\n    }\n  }\n\n  // do maths...\n  if (jsvIsUndefined(a) && jsvIsUndefined(b)) {\n    if (op == LEX_EQUAL)\n      return jsvNewFromBool(true);\n    else if (op == LEX_NEQUAL)\n      return jsvNewFromBool(false);\n    else\n      return 0; // undefined\n  } else if (needsNumeric ||\n      ((jsvIsNumeric(a) || jsvIsUndefined(a) || jsvIsNull(a)) &&\n          (jsvIsNumeric(b) || jsvIsUndefined(b) || jsvIsNull(b)))) {\n    if (needsInt || (jsvIsIntegerish(a) && jsvIsIntegerish(b))) {\n      // note that int+undefined should be handled as a double\n      // use ints\n      JsVarInt da = jsvGetInteger(a);\n      JsVarInt db = jsvGetInteger(b);\n      switch (op) {\n      case '+': return jsvNewFromLongInteger((long long)da + (long long)db);\n      case '-': return jsvNewFromLongInteger((long long)da - (long long)db);\n      case '*': return jsvNewFromLongInteger((long long)da * (long long)db);\n      case '/': return jsvNewFromFloat((JsVarFloat)da/(JsVarFloat)db);\n      case '&': return jsvNewFromInteger(da&db);\n      case '|': return jsvNewFromInteger(da|db);\n      case '^': return jsvNewFromInteger(da^db);\n      case '%': if (db<0) db=-db; // fix SIGFPE\n                return db ? jsvNewFromInteger(da%db) : jsvNewFromFloat(NAN);\n      case LEX_LSHIFT: return jsvNewFromInteger(da << db);\n      case LEX_RSHIFT: return jsvNewFromInteger(da >> db);\n      case LEX_RSHIFTUNSIGNED: return jsvNewFromLongInteger(((JsVarIntUnsigned)da) >> db);\n      case LEX_EQUAL:     return jsvNewFromBool(da==db && jsvIsNull(a)==jsvIsNull(b));\n      case LEX_NEQUAL:    return jsvNewFromBool(da!=db || jsvIsNull(a)!=jsvIsNull(b));\n      case '<':           return jsvNewFromBool(da<db);\n      case LEX_LEQUAL:    return jsvNewFromBool(da<=db);\n      case '>':           return jsvNewFromBool(da>db);\n      case LEX_GEQUAL:    return jsvNewFromBool(da>=db);\n      default: return jsvMathsOpError(op, \"Integer\");\n      }\n    } else {\n      // use doubles\n      JsVarFloat da = jsvGetFloat(a);\n      JsVarFloat db = jsvGetFloat(b);\n      switch (op) {\n      case '+': return jsvNewFromFloat(da+db);\n      case '-': return jsvNewFromFloat(da-db);\n      case '*': return jsvNewFromFloat(da*db);\n      case '/': return jsvNewFromFloat(da/db);\n      case '%': return jsvNewFromFloat(jswrap_math_mod(da, db));\n      case LEX_EQUAL:\n      case LEX_NEQUAL:  { bool equal = da==db && jsvIsNull(a)==jsvIsNull(b);\n      if ((jsvIsNull(a) && jsvIsUndefined(b)) ||\n          (jsvIsNull(b) && jsvIsUndefined(a))) equal = true; // JS quirk :)\n      return jsvNewFromBool((op==LEX_EQUAL) ? equal : ((bool)!equal));\n      }\n      case '<':           return jsvNewFromBool(da<db);\n      case LEX_LEQUAL:    return jsvNewFromBool(da<=db);\n      case '>':           return jsvNewFromBool(da>db);\n      case LEX_GEQUAL:    return jsvNewFromBool(da>=db);\n      default: return jsvMathsOpError(op, \"Double\");\n      }\n    }\n  } else if ((jsvIsArray(a) || jsvIsObject(a) || jsvIsFunction(a) ||\n      jsvIsArray(b) || jsvIsObject(b) || jsvIsFunction(b)) &&\n      jsvIsArray(a)==jsvIsArray(b) && // Fix #283 - convert to string and test if only one is an array\n      (op == LEX_EQUAL || op==LEX_NEQUAL)) {\n    bool equal = a==b;\n\n    if (jsvIsNativeFunction(a) || jsvIsNativeFunction(b)) {\n      // even if one is not native, the contents will be different\n      equal = a && b && \n          a->varData.native.ptr == b->varData.native.ptr &&\n          a->varData.native.argTypes == b->varData.native.argTypes &&\n          jsvGetFirstChild(a) == jsvGetFirstChild(b);\n    }\n\n    /* Just check pointers */\n    switch (op) {\n    case LEX_EQUAL:  return jsvNewFromBool(equal);\n    case LEX_NEQUAL: return jsvNewFromBool(!equal);\n    default: return jsvMathsOpError(op, jsvIsArray(a)?\"Array\":\"Object\");\n    }\n  } else {\n    JsVar *da = jsvAsString(a);\n    JsVar *db = jsvAsString(b);\n    if (!da || !db) { // out of memory\n      jsvUnLock2(da, db);\n      return 0;\n    }\n    if (op=='+') {\n      JsVar *v;\n      // Don't copy 'da' if it's not used elsewhere (eg we made it in 'jsvAsString' above)\n      if (jsvIsBasicString(da) && jsvGetLocks(da)==1 && jsvGetRefs(da)==0)\n        v = jsvLockAgain(da);\n      else\n        v = jsvCopy(da, false);\n      if (v) // could be out of memory\n        jsvAppendStringVarComplete(v, db);\n      jsvUnLock2(da, db);\n      return v;\n    }\n\n    int cmp = jsvCompareString(da,db,0,0,false);\n    jsvUnLock2(da, db);\n    // use strings\n    switch (op) {\n    case LEX_EQUAL:     return jsvNewFromBool(cmp==0);\n    case LEX_NEQUAL:    return jsvNewFromBool(cmp!=0);\n    case '<':           return jsvNewFromBool(cmp<0);\n    case LEX_LEQUAL:    return jsvNewFromBool(cmp<=0);\n    case '>':           return jsvNewFromBool(cmp>0);\n    case LEX_GEQUAL:    return jsvNewFromBool(cmp>=0);\n    default: return jsvMathsOpError(op, \"String\");\n    }\n  }\n}\n\nJsVar *jsvNegateAndUnLock(JsVar *v) {\n  JsVar *zero = jsvNewFromInteger(0);\n  JsVar *res = jsvMathsOpSkipNames(zero, v, '-');\n  jsvUnLock2(zero, v);\n  return res;\n}\n\n/// see jsvGetPathTo\nstatic JsVar *jsvGetPathTo_int(JsVar *root, JsVar *element, int maxDepth, JsVar *ignoreParent, int *depth) {\n  if (maxDepth<=0) return 0;\n\n  int bestDepth = maxDepth+1;\n  JsVar *found = 0;\n\n  JsvIterator it;\n  jsvIteratorNew(&it, root, JSIF_DEFINED_ARRAY_ElEMENTS);\n  while (jsvIteratorHasElement(&it)) {\n    JsVar *el = jsvIteratorGetValue(&it);\n    if (el == element && root != ignoreParent) {\n      // if we found it - send the key name back!\n      JsVar *name = jsvAsStringAndUnLock(jsvIteratorGetKey(&it));\n      jsvIteratorFree(&it);\n      return name;\n    } else if (jsvIsObject(el) || jsvIsArray(el) || jsvIsFunction(el)) {\n      // recursively search\n      int d;\n      JsVar *n = jsvGetPathTo_int(el, element, maxDepth-1, ignoreParent, &d);\n      if (n && d<bestDepth) {\n        bestDepth = d;\n        // we found it! Append our name onto it as well\n        JsVar *keyName = jsvIteratorGetKey(&it);\n        jsvUnLock(found);\n        found = jsvVarPrintf(jsvIsObject(el) ? \"%v.%v\" : \"%v[%q]\",keyName,n);\n        jsvUnLock(keyName);\n      }\n      jsvUnLock(n);\n    }\n    jsvIteratorNext(&it);\n  }\n  jsvIteratorFree(&it);\n  *depth = bestDepth;\n  return found;\n}\n\n/** If the given element is found, return the path to it as a string of\n * the form 'foo.bar', else return 0. If we would have returned a.b and\n * ignoreParent is a, don't! */\nJsVar *jsvGetPathTo(JsVar *root, JsVar *element, int maxDepth, JsVar *ignoreParent) {\n  int depth = 0;\n  return jsvGetPathTo_int(root, element, maxDepth, ignoreParent, &depth);\n}\n\nvoid jsvTraceLockInfo(JsVar *v) {\n  jsiConsolePrintf(\"#%d[r%d,l%d] \",jsvGetRef(v),jsvGetRefs(v),jsvGetLocks(v));\n}\n\n/** Get the lowest level at which searchRef appears */\nint _jsvTraceGetLowestLevel(JsVar *var, JsVar *searchVar) {\n  if (var == searchVar) return 0;\n  int found = -1;\n\n  // Use IS_RECURSING  flag to stop recursion\n  if (var->flags & JSV_IS_RECURSING)\n    return -1;\n  var->flags |= JSV_IS_RECURSING;\n\n  if (jsvHasSingleChild(var) && jsvGetFirstChild(var)) {\n    JsVar *child = jsvLock(jsvGetFirstChild(var));\n    int f = _jsvTraceGetLowestLevel(child, searchVar);\n    jsvUnLock(child);\n    if (f>=0 && (found<0 || f<found)) found=f+1;\n  }\n  if (jsvHasChildren(var)) {\n    JsVarRef childRef = jsvGetFirstChild(var);\n    while (childRef) {\n      JsVar *child = jsvLock(childRef);\n      int f = _jsvTraceGetLowestLevel(child, searchVar);\n      if (f>=0 && (found<0 || f<found)) found=f+1;\n      childRef = jsvGetNextSibling(child);\n      jsvUnLock(child);\n    }\n  }\n\n  var->flags &= ~JSV_IS_RECURSING;\n\n  return found; // searchRef not found\n}\n\nvoid _jsvTrace(JsVar *var, int indent, JsVar *baseVar, int level) {\n#ifdef SAVE_ON_FLASH\n  jsiConsolePrint(\"Trace unimplemented in this version.\\n\");\n#else\n  int i;\n  for (i=0;i<indent;i++) jsiConsolePrint(\" \");\n\n\n  if (!var) {\n    jsiConsolePrint(\"undefined\");\n    return;\n  }\n  if (level>0 && var==execInfo.root) {\n    jsiConsolePrint(\"ROOT\");\n    return;\n  }\n\n  jsvTraceLockInfo(var);\n\n  int lowestLevel = _jsvTraceGetLowestLevel(baseVar, var);\n  if (level>16 || (lowestLevel>=0 && lowestLevel < level)) {\n    // If this data is available elsewhere in the tree (but nearer the root)\n    // then don't print it. This makes the dump significantly more readable!\n    // It also stops us getting in recursive loops ...\n    jsiConsolePrint(\"...\\n\");\n    return;\n  }\n\n  if (jsvIsNewChild(var)) {\n    jsiConsolePrint(\"NewChild PARENT:\");\n    JsVar *parent = jsvGetAddressOf(jsvGetNextSibling(var));\n    _jsvTrace(parent, indent+2, baseVar, level+1);\n    jsiConsolePrint(\"CHILD: \");\n  } else if (jsvIsName(var)) jsiConsolePrint(\"Name \");\n\n  char endBracket = ' ';\n  if (jsvIsObject(var)) { jsiConsolePrint(\"Object { \"); endBracket = '}'; }\n  else if (jsvIsGetterOrSetter(var)) { jsiConsolePrint(\"Getter/Setter { \"); endBracket = '}'; }\n  else if (jsvIsArray(var)) { jsiConsolePrintf(\"Array(%d) [ \", var->varData.integer); endBracket = ']'; }\n  else if (jsvIsNativeFunction(var)) { jsiConsolePrintf(\"NativeFunction 0x%x (%d) { \", var->varData.native.ptr, var->varData.native.argTypes); endBracket = '}'; }\n  else if (jsvIsFunction(var)) {\n    jsiConsolePrint(\"Function { \");\n    if (jsvIsFunctionReturn(var)) jsiConsolePrint(\"return \");\n    endBracket = '}';\n  } else if (jsvIsPin(var)) jsiConsolePrintf(\"Pin %d\", jsvGetInteger(var));\n  else if (jsvIsInt(var)) jsiConsolePrintf(\"Integer %d\", jsvGetInteger(var));\n  else if (jsvIsBoolean(var)) jsiConsolePrintf(\"Bool %s\", jsvGetBool(var)?\"true\":\"false\");\n  else if (jsvIsFloat(var)) jsiConsolePrintf(\"Double %f\", jsvGetFloat(var));\n  else if (jsvIsFunctionParameter(var)) jsiConsolePrintf(\"Param %q \", var);\n  else if (jsvIsArrayBufferName(var)) jsiConsolePrintf(\"ArrayBufferName[%d] \", jsvGetInteger(var));\n  else if (jsvIsArrayBuffer(var)) jsiConsolePrintf(\"%s (offs %d, len %d)\", jswGetBasicObjectName(var)?jswGetBasicObjectName(var):\"unknown ArrayBuffer\", var->varData.arraybuffer.byteOffset, var->varData.arraybuffer.length); // way to get nice name\n  else if (jsvIsString(var)) {\n    size_t blocks = 1;\n    if (jsvGetLastChild(var)) {\n      JsVar *v = jsvGetAddressOf(jsvGetLastChild(var));\n      blocks += jsvCountJsVarsUsed(v);\n    }\n    if (jsvIsFlatString(var)) {\n      blocks += jsvGetFlatStringBlocks(var);\n    }\n    const char *name = \"\";\n    if (jsvIsFlatString(var)) name=\"Flat\";\n    if (jsvIsNativeString(var)) name=\"Native\";\n    if (jsvIsFlashString(var)) name=\"Flash\";\n    jsiConsolePrintf(\"%sString [%d blocks] %q\", name, blocks, var);\n  } else {\n    jsiConsolePrintf(\"Unknown %d\", var->flags & (JsVarFlags)~(JSV_LOCK_MASK));\n  }\n\n  // print a value if it was stored in here as well...\n  if (jsvIsNameInt(var)) {\n    jsiConsolePrintf(\"= int %d\\n\", (int)jsvGetFirstChildSigned(var));\n    return;\n  } else if (jsvIsNameIntBool(var)) {\n    jsiConsolePrintf(\"= bool %s\\n\", jsvGetFirstChild(var)?\"true\":\"false\");\n    return;\n  }\n\n  if (jsvHasSingleChild(var)) {\n    JsVar *child = jsvGetFirstChild(var) ? jsvGetAddressOf(jsvGetFirstChild(var)) : 0;\n    _jsvTrace(child, indent+2, baseVar, level+1);\n  } else if (jsvHasChildren(var)) {\n    JsvIterator it;\n    jsvIteratorNew(&it, var, JSIF_DEFINED_ARRAY_ElEMENTS);\n    bool first = true;\n    while (jsvIteratorHasElement(&it) && !jspIsInterrupted()) {\n      if (first) jsiConsolePrintf(\"\\n\");\n      first = false;\n      JsVar *child = jsvIteratorGetKey(&it);\n      _jsvTrace(child, indent+2, baseVar, level+1);\n      jsvUnLock(child);\n      jsiConsolePrintf(\"\\n\");\n      jsvIteratorNext(&it);\n    }\n    jsvIteratorFree(&it);\n    if (!first)\n      for (i=0;i<indent;i++) jsiConsolePrint(\" \");\n  }\n  jsiConsolePrintf(\"%c\", endBracket);\n#endif\n}\n\n/** Write debug info for this Var out to the console */\nvoid jsvTrace(JsVar *var, int indent) {\n  /* Clear memory busy flags. If we're calling\n   * trace then we really care about getting an answer */\n  MemBusyType t = isMemoryBusy;\n  isMemoryBusy = 0;\n  _jsvTrace(var,indent,var,0);\n  isMemoryBusy = t;\n  jsiConsolePrintf(\"\\n\");\n}\n\n\n/** Recursively mark the variable. Return false if it fails due to stack. */\nstatic bool jsvGarbageCollectMarkUsed(JsVar *var) {\n  var->flags &= (JsVarFlags)~JSV_GARBAGE_COLLECT;\n  JsVarRef child;\n  JsVar *childVar;\n\n  if (jsvHasCharacterData(var)) {\n    // non-recursively scan strings\n    child = jsvGetLastChild(var);\n    while (child) {\n      childVar = jsvGetAddressOf(child);\n      childVar->flags &= (JsVarFlags)~JSV_GARBAGE_COLLECT;\n      child = jsvGetLastChild(childVar);\n    }\n  }\n  // intentionally no else\n  if (jsvHasSingleChild(var)) {\n    if (jsvGetFirstChild(var)) {\n      childVar = jsvGetAddressOf(jsvGetFirstChild(var));\n      if (childVar->flags & JSV_GARBAGE_COLLECT)\n        if (!jsvGarbageCollectMarkUsed(childVar)) return false;\n    }\n  } else if (jsvHasChildren(var)) {\n    if (jsuGetFreeStack() < 256) return false;\n\n    child = jsvGetFirstChild(var);\n    while (child) {\n      childVar = jsvGetAddressOf(child);\n      if (childVar->flags & JSV_GARBAGE_COLLECT)\n        if (!jsvGarbageCollectMarkUsed(childVar)) return false;\n      child = jsvGetNextSibling(childVar);\n    }\n  }\n\n  return true;\n}\n\n/** Run a garbage collection sweep - return nonzero if things have been freed */\nint jsvGarbageCollect() {\n  if (isMemoryBusy) return 0;\n  isMemoryBusy = MEMBUSY_GC;\n  JsVarRef i;\n  // Add GC flags to anything that is currently used\n  for (i=1;i<=jsVarsSize;i++)  {\n    JsVar *var = jsvGetAddressOf(i);\n    if ((var->flags&JSV_VARTYPEMASK) != JSV_UNUSED) { // if it is not unused\n      var->flags |= (JsVarFlags)JSV_GARBAGE_COLLECT;\n      // if we have a flat string, skip that many blocks\n      if (jsvIsFlatString(var))\n        i = (JsVarRef)(i+jsvGetFlatStringBlocks(var));\n    }\n  }\n  /* recursively remove anything that is referenced from a var that is locked. */\n  for (i=1;i<=jsVarsSize;i++)  {\n    JsVar *var = jsvGetAddressOf(i);\n    if ((var->flags & JSV_GARBAGE_COLLECT) && // not already GC'd\n        jsvGetLocks(var)>0) { // or it is locked\n      if (!jsvGarbageCollectMarkUsed(var)) {\n        // this could fail due to stack exhausted (eg big linked list)\n        // JSV_GARBAGE_COLLECT are left set, but not a big problem as next GC will clear them\n        isMemoryBusy = MEM_NOT_BUSY;\n        return 0;\n      }\n    }\n    // if we have a flat string, skip that many blocks\n    if (jsvIsFlatString(var))\n      i = (JsVarRef)(i+jsvGetFlatStringBlocks(var));\n  }\n  /* now sweep for things that we can GC!\n   * Also update the free list - this means that every new variable that\n   * gets allocated gets allocated towards the start of memory, which\n   * hopefully helps compact everything towards the start. */\n  unsigned int freedCount = 0;\n  jsVarFirstEmpty = 0;\n  JsVar *lastEmpty = 0;\n  for (i=1;i<=jsVarsSize;i++)  {\n    JsVar *var = jsvGetAddressOf(i);\n    if (var->flags & JSV_GARBAGE_COLLECT) {\n      if (jsvIsFlatString(var)) {\n        // If we're a flat string, there are more blocks to free.\n        unsigned int count = (unsigned int)jsvGetFlatStringBlocks(var);\n        freedCount+=count;\n        // Free the first block\n        var->flags = JSV_UNUSED;\n        // add this to our free list\n        if (lastEmpty) jsvSetNextSibling(lastEmpty, i);\n        else jsVarFirstEmpty = i;\n        lastEmpty = var;\n        // free subsequent blocks\n        while (count-- > 0) {\n          i++;\n          var = jsvGetAddressOf((JsVarRef)(i));\n          var->flags = JSV_UNUSED;\n          // add this to our free list\n          if (lastEmpty) jsvSetNextSibling(lastEmpty, i);\n          else jsVarFirstEmpty = i;\n          lastEmpty = var;\n        }\n      } else {\n        // otherwise just free 1 block\n        if (jsvHasSingleChild(var)) {\n          /* If this had a child that wasn't listed for GC then we need to\n           * unref it. Everything else is fine because it'll disappear anyway.\n           * We don't have to check if we should free this other variable\n           * here because we know the GC picked up it was referenced from\n           * somewhere else. */\n          JsVarRef ch = jsvGetFirstChild(var);\n          if (ch) {\n            JsVar *child = jsvGetAddressOf(ch); // not locked\n            if (child->flags!=JSV_UNUSED && // not already GC'd!\n                !(child->flags&JSV_GARBAGE_COLLECT)) // not marked for GC\n              jsvUnRef(child);\n          }\n        }\n        /* Sanity checks here. We're making sure that any variables that are\n         * linked from this one have either already been garbage collected or\n         * are marked for GC */\n        assert(!jsvHasChildren(var) || !jsvGetFirstChild(var) ||\n            jsvGetLocks(jsvGetAddressOf(jsvGetFirstChild(var))) ||\n            jsvGetAddressOf(jsvGetFirstChild(var))->flags==JSV_UNUSED ||\n            (jsvGetAddressOf(jsvGetFirstChild(var))->flags&JSV_GARBAGE_COLLECT));\n        assert(!jsvHasChildren(var) || !jsvGetLastChild(var) ||\n            jsvGetLocks(jsvGetAddressOf(jsvGetLastChild(var))) ||\n            jsvGetAddressOf(jsvGetLastChild(var))->flags==JSV_UNUSED ||\n            (jsvGetAddressOf(jsvGetLastChild(var))->flags&JSV_GARBAGE_COLLECT));\n        assert(!jsvIsName(var) || !jsvGetPrevSibling(var) ||\n            jsvGetLocks(jsvGetAddressOf(jsvGetPrevSibling(var))) ||\n            jsvGetAddressOf(jsvGetPrevSibling(var))->flags==JSV_UNUSED ||\n            (jsvGetAddressOf(jsvGetPrevSibling(var))->flags&JSV_GARBAGE_COLLECT));\n        assert(!jsvIsName(var) || !jsvGetNextSibling(var) ||\n            jsvGetLocks(jsvGetAddressOf(jsvGetNextSibling(var))) ||\n            jsvGetAddressOf(jsvGetNextSibling(var))->flags==JSV_UNUSED ||\n            (jsvGetAddressOf(jsvGetNextSibling(var))->flags&JSV_GARBAGE_COLLECT));\n        // free!\n        var->flags = JSV_UNUSED;\n        // add this to our free list\n        if (lastEmpty) jsvSetNextSibling(lastEmpty, i);\n        else jsVarFirstEmpty = i;\n        lastEmpty = var;\n        freedCount++;\n      }\n    } else if (jsvIsFlatString(var)) {\n      // if we have a flat string, skip forward that many blocks\n      i = (JsVarRef)(i+jsvGetFlatStringBlocks(var));\n    } else if (var->flags == JSV_UNUSED) {\n      // this is already free - add it to the free list\n      if (lastEmpty) jsvSetNextSibling(lastEmpty, i);\n      else jsVarFirstEmpty = i;\n      lastEmpty = var;\n    }\n  }\n  if (lastEmpty) jsvSetNextSibling(lastEmpty, 0);\n  isMemoryBusy = MEM_NOT_BUSY;\n  return (int)freedCount;\n}\n\nvoid jsvDefragment() {\n  // garbage collect - removes cruft\n  // also puts free list in order\n  jsvGarbageCollect();\n  // Fill defragVars with defraggable variables\n  jshInterruptOff();\n  const int DEFRAGVARS = 256; // POWER OF 2\n  JsVarRef defragVars[DEFRAGVARS];\n  memset(defragVars, 0, sizeof(defragVars));\n  int defragVarIdx = 0;\n  for (int i=0;i<jsvGetMemoryTotal();i++) {\n    JsVarRef vr = i+1;\n    JsVar *v = _jsvGetAddressOf(vr);\n    if ((v->flags&JSV_VARTYPEMASK)!=JSV_UNUSED) {\n      if (jsvIsFlatString(v)) {\n        i += jsvGetFlatStringBlocks(v); // skip forward\n      } else if (jsvGetLocks(v)==0) {\n        defragVars[defragVarIdx] = vr;\n        defragVarIdx = (defragVarIdx+1) & (DEFRAGVARS-1);\n      }\n    }\n  }\n  // Now go through defragVars defragging them\n  defragVarIdx--;\n  if (defragVarIdx<0) defragVarIdx+=DEFRAGVARS;\n  while (defragVars[defragVarIdx]) {\n    JsVarRef defragFromRef = defragVars[defragVarIdx];\n    JsVarRef defragToRef = jsVarFirstEmpty;\n    if (!defragToRef || defragFromRef<defragToRef) {\n      // we're done!\n      break;\n    }\n    // relocate!\n    JsVar *defragFrom = _jsvGetAddressOf(defragFromRef);\n    JsVar *defragTo = _jsvGetAddressOf(defragToRef);\n    jsVarFirstEmpty = jsvGetNextSibling(defragTo); // move our reference to the next in the free list\n    // copy data\n    *defragTo = *defragFrom;\n    defragFrom->flags = JSV_UNUSED;\n    // find references!\n    for (int i=0;i<jsvGetMemoryTotal();i++) {\n      JsVarRef vr = i+1;\n      JsVar *v = _jsvGetAddressOf(vr);\n      if ((v->flags&JSV_VARTYPEMASK)!=JSV_UNUSED) {\n        if (jsvIsFlatString(v)) {\n          i += jsvGetFlatStringBlocks(v); // skip forward\n        } else {\n          if (jsvHasSingleChild(v))\n            if (jsvGetFirstChild(v)==defragFromRef)\n              jsvSetFirstChild(v,defragToRef);\n          if (jsvHasStringExt(v))\n            if (jsvGetLastChild(v)==defragFromRef)\n              jsvSetLastChild(v,defragToRef);\n          if (jsvHasChildren(v)) {\n            if (jsvGetFirstChild(v)==defragFromRef)\n              jsvSetFirstChild(v,defragToRef);\n            if (jsvGetLastChild(v)==defragFromRef)\n              jsvSetLastChild(v,defragToRef);\n          }\n          if (jsvIsName(v)) {\n            if (jsvGetNextSibling(v)==defragFromRef)\n              jsvSetNextSibling(v,defragToRef);\n            if (jsvGetPrevSibling(v)==defragFromRef)\n              jsvSetPrevSibling(v,defragToRef);\n          }\n        }\n      }\n    }\n    // zero element and move to next...\n    defragVars[defragVarIdx] = 0;\n    defragVarIdx--;\n    if (defragVarIdx<0) defragVarIdx+=DEFRAGVARS;\n  }\n  // rebuild free var list\n  jsvCreateEmptyVarList();\n  jshInterruptOn();\n}\n\n// Dump any locked variables that aren't referenced from `global` - for debugging memory leaks\nvoid jsvDumpLockedVars() {\n  jsvGarbageCollect();\n  if (isMemoryBusy) return;\n  isMemoryBusy = MEMBUSY_SYSTEM;\n  JsVarRef i;\n  // clear garbage collect flags\n  for (i=1;i<=jsVarsSize;i++)  {\n    JsVar *var = jsvGetAddressOf(i);\n    if ((var->flags&JSV_VARTYPEMASK) != JSV_UNUSED) { // if it is not unused\n      var->flags |= (JsVarFlags)JSV_GARBAGE_COLLECT;\n      // if we have a flat string, skip that many blocks\n      if (jsvIsFlatString(var))\n        i = (JsVarRef)(i+jsvGetFlatStringBlocks(var));\n    }\n  }\n  // Add global\n  jsvGarbageCollectMarkUsed(execInfo.root);\n  // Now dump any that aren't used!\n  for (i=1;i<=jsVarsSize;i++)  {\n    JsVar *var = jsvGetAddressOf(i);\n    if ((var->flags&JSV_VARTYPEMASK) != JSV_UNUSED) {\n      if (var->flags & JSV_GARBAGE_COLLECT) {\n        jsvGarbageCollectMarkUsed(var);\n        jsvTrace(var, 0);\n      }\n    }\n  }\n  isMemoryBusy = MEM_NOT_BUSY;\n}\n\n// Dump the free list - in order\nvoid jsvDumpFreeList() {\n  JsVarRef ref = jsVarFirstEmpty;\n  int n = 0;\n  while (ref) {\n    jsiConsolePrintf(\"%5d \", (int)ref);\n    if (++n >= 16) {\n      n = 0;\n      jsiConsolePrintf(\"\\n\");\n    }\n    JsVar *v = jsvGetAddressOf(ref);\n    ref = jsvGetNextSibling(v);\n  }\n  jsiConsolePrintf(\"\\n\");\n}\n\n\n/** Remove whitespace to the right of a string - on MULTIPLE LINES */\nJsVar *jsvStringTrimRight(JsVar *srcString) {\n  JsvStringIterator src, dst;\n  JsVar *dstString = jsvNewFromEmptyString();\n  jsvStringIteratorNew(&src, srcString, 0);\n  jsvStringIteratorNew(&dst, dstString, 0);\n  int spaces = 0;\n  while (jsvStringIteratorHasChar(&src)) {\n    char ch = jsvStringIteratorGetCharAndNext(&src);\n\n    if (ch==' ') spaces++;\n    else if (ch=='\\n') {\n      spaces = 0;\n      jsvStringIteratorAppend(&dst, ch);\n    } else {\n      for (;spaces>0;spaces--)\n        jsvStringIteratorAppend(&dst, ' ');\n      jsvStringIteratorAppend(&dst, ch);\n    }\n  }\n  jsvStringIteratorFree(&src);\n  jsvStringIteratorFree(&dst);\n  return dstString;\n}\n\n/// If v is the key of a function, return true if it is internal and shouldn't be visible to the user\nbool jsvIsInternalFunctionKey(JsVar *v) {\n  return (jsvIsString(v) && (\n      v->varData.str[0]==JS_HIDDEN_CHAR)\n  ) ||\n  jsvIsFunctionParameter(v);\n}\n\n/// If v is the key of an object, return true if it is internal and shouldn't be visible to the user\nbool jsvIsInternalObjectKey(JsVar *v) {\n  return (jsvIsString(v) && (\n      v->varData.str[0]==JS_HIDDEN_CHAR ||\n      jsvIsStringEqual(v, JSPARSE_INHERITS_VAR) ||\n      jsvIsStringEqual(v, JSPARSE_CONSTRUCTOR_VAR)\n  ));\n}\n\n/// Get the correct checker function for the given variable. see jsvIsInternalFunctionKey/jsvIsInternalObjectKey\nJsvIsInternalChecker jsvGetInternalFunctionCheckerFor(JsVar *v) {\n  if (jsvIsFunction(v)) return jsvIsInternalFunctionKey;\n  if (jsvIsObject(v)) return jsvIsInternalObjectKey;\n  return 0;\n}\n\n/** Using 'configs', this reads 'object' into the given pointers, returns true on success.\n *  If object is not undefined and not an object, an error is raised.\n *  If there are fields that are not  in the list of configs, an error is raised\n */\nbool jsvReadConfigObject(JsVar *object, jsvConfigObject *configs, int nConfigs) {\n  if (jsvIsUndefined(object)) return true;\n  if (!jsvIsObject(object)) {\n    jsExceptionHere(JSET_ERROR, \"Expecting an Object, or undefined\");\n    return false;\n  }\n  // Ok, it's an object\n  JsvObjectIterator it;\n  jsvObjectIteratorNew(&it, object);\n  bool ok = true;\n  while (ok && jsvObjectIteratorHasValue(&it)) {\n    JsVar *key = jsvObjectIteratorGetKey(&it);\n    bool found = false;\n    for (int i=0;i<nConfigs;i++) {\n      if (jsvIsStringEqual(key, configs[i].name)) {\n        found = true;\n        if (configs[i].ptr) {\n          JsVar *val = jsvObjectIteratorGetValue(&it);\n          switch (configs[i].type) {\n          case 0: break;\n          case JSV_OBJECT:\n          case JSV_STRING_0:\n          case JSV_ARRAY:\n          case JSV_FUNCTION:\n            *((JsVar**)configs[i].ptr) = jsvLockAgain(val); break;\n          case JSV_PIN: *((Pin*)configs[i].ptr) = jshGetPinFromVar(val); break;\n          case JSV_BOOLEAN: *((bool*)configs[i].ptr) = jsvGetBool(val); break;\n          case JSV_INTEGER: *((JsVarInt*)configs[i].ptr) = jsvGetInteger(val); break;\n          case JSV_FLOAT: *((JsVarFloat*)configs[i].ptr) = jsvGetFloat(val); break;\n          default: assert(0); break;\n          }\n          jsvUnLock(val);\n        }\n      }\n    }\n    if (!found) {\n      jsExceptionHere(JSET_ERROR, \"Unknown option %q\", key);\n      ok = false;\n    }\n    jsvUnLock(key);\n\n    jsvObjectIteratorNext(&it);\n  }\n  jsvObjectIteratorFree(&it);\n  return ok;\n}\n\n/** Using data in the format passed to jsvReadConfigObject, reconstruct a new object  */\nJsVar *jsvCreateConfigObject(jsvConfigObject *configs, int nConfigs) {\n  JsVar *o = jsvNewObject();\n  if (!o) return 0;\n  for (int i=0;i<nConfigs;i++) {\n     if (configs[i].ptr) {\n      JsVar *v = 0;\n      switch (configs[i].type) {\n      case 0: break;\n      case JSV_OBJECT:\n      case JSV_STRING_0:\n      case JSV_ARRAY:\n      case JSV_FUNCTION:\n        v = jsvLockAgain(*((JsVar**)configs[i].ptr)); break;\n      case JSV_PIN:\n        v = jsvNewFromPin(*((Pin*)configs[i].ptr)); break;\n      case JSV_BOOLEAN:\n        v = jsvNewFromBool(*((bool*)configs[i].ptr)); break;\n      case JSV_INTEGER:\n        v = jsvNewFromInteger(*((JsVarInt*)configs[i].ptr)); break;\n      case JSV_FLOAT:\n        v = jsvNewFromFloat(*((JsVarFloat*)configs[i].ptr)); break;\n      }\n      jsvObjectSetChildAndUnLock(o, configs[i].name, v);\n    }\n  }\n  return o;\n}\n\n/// Is the variable an instance of the given class. Eg. `jsvIsInstanceOf(e, \"Error\")` - does a simple, non-recursive check that doesn't take account of builtins like String\nbool jsvIsInstanceOf(JsVar *var, const char *constructorName) {\n  bool isInst = false;\n  if (!jsvHasChildren(var)) return false;\n  JsVar *proto = jsvObjectGetChild(var, JSPARSE_INHERITS_VAR, 0);\n  if (jsvIsObject(proto)) {\n    JsVar *constr = jsvObjectGetChild(proto, JSPARSE_CONSTRUCTOR_VAR, 0);\n    if (constr)\n      isInst = jspIsConstructor(constr, constructorName);\n    jsvUnLock(constr);\n  }\n  jsvUnLock(proto);\n  return isInst;\n}\n\nJsVar *jsvNewTypedArray(JsVarDataArrayBufferViewType type, JsVarInt length) {\n  JsVar *lenVar = jsvNewFromInteger(length);\n  if (!lenVar) return 0;\n  JsVar *array = jswrap_typedarray_constructor(type, lenVar,0,0);\n  jsvUnLock(lenVar);\n  return array;\n}\n\n#ifndef NO_DATAVIEW\nJsVar *jsvNewDataViewWithData(JsVarInt length, unsigned char *data) {\n  JsVar *buf = jswrap_arraybuffer_constructor(length);\n  if (!buf) return 0;\n  JsVar *view = jswrap_dataview_constructor(buf, 0, 0);\n  if (!view) {\n    jsvUnLock(buf);\n    return 0;\n  }\n  if (data) {\n    JsVar *arrayBufferData = jsvGetArrayBufferBackingString(buf, NULL);\n    if (arrayBufferData)\n      jsvSetString(arrayBufferData, (char *)data, (size_t)length);\n    jsvUnLock(arrayBufferData);\n  }\n  jsvUnLock(buf);\n  return view;\n}\n#endif\n\nJsVar *jsvNewArrayBufferWithPtr(unsigned int length, char **ptr) {\n  assert(ptr);\n  *ptr=0;\n  JsVar *backingString = jsvNewFlatStringOfLength(length);\n  if (!backingString) return 0;\n  JsVar *arr = jsvNewArrayBufferFromString(backingString, length);\n  if (!arr) {\n    jsvUnLock(backingString);\n    return 0;\n  }\n  *ptr = jsvGetFlatStringPointer(backingString);\n  jsvUnLock(backingString);\n  return arr;\n}\n\nJsVar *jsvNewArrayBufferWithData(JsVarInt length, unsigned char *data) {\n  assert(data);\n  assert(length>0);\n  JsVar *dst = 0;\n  JsVar *arr = jsvNewArrayBufferWithPtr((unsigned int)length, (char**)&dst);\n  if (!dst) {\n    jsvUnLock(arr);\n    return 0;\n  }\n  memcpy(dst, data, (size_t)length);\n  return arr;\n}\n\nvoid *jsvMalloc(size_t size) {\n  assert(size>0);\n  /** Allocate flat string, return pointer to its first element.\n   * As we drop the pointer here, it's left locked. jsvGetFlatStringPointer\n   * is also safe if 0 is passed in.  */\n  JsVar *flatStr = jsvNewFlatStringOfLength((unsigned int)size);\n  if (!flatStr) {\n    jsErrorFlags |= JSERR_LOW_MEMORY;\n    // Not allocated - try and free any command history/etc\n    while (jsiFreeMoreMemory());\n    // Garbage collect\n    jsvGarbageCollect();\n    // Try again\n    flatStr = jsvNewFlatStringOfLength((unsigned int)size);\n  }\n  // intentionally no jsvUnLock - see above\n  void *p = (void*)jsvGetFlatStringPointer(flatStr);\n  if (p) {\n    //jsiConsolePrintf(\"jsvMalloc var %d-%d at %d (%d bytes)\\n\", jsvGetRef(flatStr), jsvGetRef(flatStr)+jsvGetFlatStringBlocks(flatStr), p, size);\n    memset(p,0,size);\n  }\n  return p;\n}\n\nvoid jsvFree(void *ptr) {\n  JsVar *flatStr = jsvGetFlatStringFromPointer((char *)ptr);\n  //jsiConsolePrintf(\"jsvFree var %d at %d (%d bytes)\\n\", jsvGetRef(flatStr), ptr, jsvGetLength(flatStr));\n\n  jsvUnLock(flatStr);\n}\n"], "filenames": ["ChangeLog", "src/jsparse.c", "src/jsparse.h", "src/jsvar.c"], "buggy_code_start_loc": [11, 955, 40, 2557], "buggy_code_end_loc": [11, 2852, 41, 2763], "fixing_code_start_loc": [12, 955, 40, 2558], "fixing_code_end_loc": [13, 2862, 41, 2768], "type": "CWE-787", "message": "Espruino 2v11.251 was discovered to contain a stack buffer overflow via src/jsvar.c in jsvNewFromString.", "other": {"cve": {"id": "CVE-2022-25044", "sourceIdentifier": "cve@mitre.org", "published": "2022-03-05T02:15:06.900", "lastModified": "2022-03-11T15:58:29.333", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Espruino 2v11.251 was discovered to contain a stack buffer overflow via src/jsvar.c in jsvNewFromString."}, {"lang": "es", "value": "Se ha detectado que Espruino versi\u00f3n 2v11.251, conten\u00eda un desbordamiento del b\u00fafer de la pila por medio del archivo src/jsvar.c en jsvNewFromString"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:espruino:espruino:2.11.251:*:*:*:*:*:*:*", "matchCriteriaId": "F24AA233-1A59-441A-BE52-01F1A375F437"}]}]}], "references": [{"url": "https://github.com/espruino/Espruino/commit/e069be2ecc5060ef47391716e4de94999595b260", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/espruino/Espruino/issues/2142", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/espruino/Espruino/commit/e069be2ecc5060ef47391716e4de94999595b260"}}