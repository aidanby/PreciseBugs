{"buggy_code": ["/* global host */\n/* eslint-disable block-spacing, no-multi-spaces, brace-style, no-array-constructor, new-cap, no-use-before-define */\n\n'use strict';\n\n// eslint-disable-next-line no-invalid-this, no-shadow\nconst global = this;\n\nconst local = host.Object.create(null);\nlocal.Object = Object;\nlocal.Array = Array;\nlocal.Reflect = host.Object.create(null);\nlocal.Reflect.ownKeys = Reflect.ownKeys;\nlocal.Reflect.enumerate = Reflect.enumerate;\nlocal.Reflect.getPrototypeOf = Reflect.getPrototypeOf;\nlocal.Reflect.construct = Reflect.construct;\nlocal.Reflect.apply = Reflect.apply;\nlocal.Reflect.set = Reflect.set;\nlocal.Reflect.deleteProperty = Reflect.deleteProperty;\nlocal.Reflect.has = Reflect.has;\nlocal.Reflect.defineProperty = Reflect.defineProperty;\nlocal.Reflect.setPrototypeOf = Reflect.setPrototypeOf;\nlocal.Reflect.isExtensible = Reflect.isExtensible;\nlocal.Reflect.preventExtensions = Reflect.preventExtensions;\nlocal.Reflect.getOwnPropertyDescriptor = Reflect.getOwnPropertyDescriptor;\n\nfunction curry(func) {\n\treturn (thiz, args) => local.Reflect.apply(func, thiz, args);\n}\n\nconst FunctionBind = curry(Function.prototype.bind);\n\n// global is originally prototype of host.Object so it can be used to climb up from the sandbox.\nObject.setPrototypeOf(global, Object.prototype);\n\nObject.defineProperties(global, {\n\tglobal: {value: global},\n\tGLOBAL: {value: global},\n\troot: {value: global},\n\tisVM: {value: true}\n});\n\nconst DEBUG = false;\nconst OPNA = 'Operation not allowed on contextified object.';\nconst captureStackTrace = Error.captureStackTrace;\n\nconst RETURN_FALSE = () => false;\n\nconst FROZEN_TRAPS = {\n\t__proto__: null,\n\tset(target, key, value, receiver) {\n\t\treturn local.Reflect.defineProperty(receiver, key, {\n\t\t\t__proto__: null,\n\t\t\tvalue: value,\n\t\t\twritable: true,\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true\n\t\t});\n\t},\n\tsetPrototypeOf: RETURN_FALSE,\n\tdefineProperty: RETURN_FALSE,\n\tdeleteProperty: RETURN_FALSE,\n\tisExtensible: RETURN_FALSE,\n\tpreventExtensions: RETURN_FALSE\n};\n\n// Map of contextified objects to original objects\nconst Contextified = new host.WeakMap();\nconst Decontextified = new host.WeakMap();\n\n// We can't use host's hasInstance method\nconst ObjectHasInstance = curry(local.Object[Symbol.hasInstance]);\nfunction instanceOf(value, construct) {\n\ttry {\n\t\treturn ObjectHasInstance(construct, [value]);\n\t} catch (ex) {\n\t\t// Never pass the handled exception through!\n\t\tthrow new VMError('Unable to perform instanceOf check.');\n\t\t// This exception actually never get to the user. It only instructs the caller to return null because we wasn't able to perform instanceOf check.\n\t}\n}\n\nconst SHARED_OBJECT = {__proto__: null};\nfunction SHARED_FUNCTION() {}\n\nfunction createBaseObject(obj) {\n\tlet base;\n\tif (typeof obj === 'function') {\n\t\ttry {\n\t\t\t// eslint-disable-next-line no-new\n\t\t\tnew new host.Proxy(obj, {\n\t\t\t\t__proto__: null,\n\t\t\t\tconstruct() {\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t})();\n\t\t\t// Bind the function since bound functions do not have a prototype property.\n\t\t\tbase = FunctionBind(SHARED_FUNCTION, [null]);\n\t\t} catch (e) {\n\t\t\tbase = () => {};\n\t\t}\n\t} else if (host.Array.isArray(obj)) {\n\t\tbase = [];\n\t} else {\n\t\treturn {__proto__: null};\n\t}\n\tif (!local.Reflect.setPrototypeOf(base, null)) {\n\t\t// Should not happen\n\t\treturn null;\n\t}\n\treturn base;\n}\n\n/**\n * VMError definition.\n */\n\nclass VMError extends Error {\n\tconstructor(message, code) {\n\t\tsuper(message);\n\n\t\tthis.name = 'VMError';\n\t\tthis.code = code;\n\n\t\tcaptureStackTrace(this, this.constructor);\n\t}\n}\n\nglobal.VMError = VMError;\n\n/*\n * This function will throw a TypeError for accessing properties\n * on a strict mode function\n */\nfunction throwCallerCalleeArgumentsAccess(key) {\n\t'use strict';\n\tthrowCallerCalleeArgumentsAccess[key];\n\treturn new VMError('Unreachable');\n}\n\nfunction unexpected() {\n\tthrow new VMError('Should not happen');\n}\n\nfunction doPreventExtensions(target, object, doProxy) {\n\tconst keys = local.Reflect.ownKeys(object);\n\tfor (let i = 0; i < keys.length; i++) {\n\t\tconst key = keys[i];\n\t\tlet desc = local.Reflect.getOwnPropertyDescriptor(object, key);\n\t\tif (!desc) continue;\n\t\tif (!local.Reflect.setPrototypeOf(desc, null)) unexpected();\n\t\tif (!desc.configurable) {\n\t\t\tconst current = local.Reflect.getOwnPropertyDescriptor(target, key);\n\t\t\tif (current && !current.configurable) continue;\n\t\t\tif (desc.get || desc.set) {\n\t\t\t\tdesc.get = doProxy(desc.get);\n\t\t\t\tdesc.set = doProxy(desc.set);\n\t\t\t} else {\n\t\t\t\tdesc.value = doProxy(desc.value);\n\t\t\t}\n\t\t} else {\n\t\t\tif (desc.get || desc.set) {\n\t\t\t\tdesc = {\n\t\t\t\t\t__proto__: null,\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\tenumerable: desc.enumerable,\n\t\t\t\t\twritable: true,\n\t\t\t\t\tvalue: null\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tdesc.value = null;\n\t\t\t}\n\t\t}\n\t\tif (!local.Reflect.defineProperty(target, key, desc)) unexpected();\n\t}\n\tif (!local.Reflect.preventExtensions(target)) unexpected();\n}\n\n/**\n * Decontextify.\n */\n\nconst Decontextify = host.Object.create(null);\nDecontextify.proxies = new host.WeakMap();\n\nDecontextify.arguments = args => {\n\tif (!host.Array.isArray(args)) return new host.Array();\n\n\ttry {\n\t\tconst arr = new host.Array();\n\t\tfor (let i = 0, l = args.length; i < l; i++) arr[i] = Decontextify.value(args[i]);\n\t\treturn arr;\n\t} catch (e) {\n\t\t// Never pass the handled exception through!\n\t\treturn new host.Array();\n\t}\n};\nDecontextify.instance = (instance, klass, deepTraps, flags, toStringTag) => {\n\tif (typeof instance === 'function') return Decontextify.function(instance);\n\n\t// We must not use normal object because there's a chance object already contains malicious code in the prototype\n\tconst base = host.Object.create(null);\n\n\tbase.get = (target, key, receiver) => {\n\t\ttry {\n\t\t\tif (key === 'vmProxyTarget' && DEBUG) return instance;\n\t\t\tif (key === 'isVMProxy') return true;\n\t\t\tif (key === 'constructor') return klass;\n\t\t\tif (key === '__proto__') return klass.prototype;\n\t\t} catch (e) {\n\t\t\t// Never pass the handled exception through! This block can't throw an exception under normal conditions.\n\t\t\treturn null;\n\t\t}\n\n\t\tif (key === '__defineGetter__') return host.Object.prototype.__defineGetter__;\n\t\tif (key === '__defineSetter__') return host.Object.prototype.__defineSetter__;\n\t\tif (key === '__lookupGetter__') return host.Object.prototype.__lookupGetter__;\n\t\tif (key === '__lookupSetter__') return host.Object.prototype.__lookupSetter__;\n\t\tif (key === host.Symbol.toStringTag && toStringTag) return toStringTag;\n\n\t\ttry {\n\t\t\treturn Decontextify.value(instance[key], null, deepTraps, flags);\n\t\t} catch (e) {\n\t\t\tthrow Decontextify.value(e);\n\t\t}\n\t};\n\tbase.getPrototypeOf = (target) => {\n\t\treturn klass && klass.prototype;\n\t};\n\n\treturn Decontextify.object(instance, base, deepTraps, flags);\n};\nDecontextify.function = (fnc, traps, deepTraps, flags, mock) => {\n\t// We must not use normal object because there's a chance object already contains malicious code in the prototype\n\tconst base = host.Object.create(null);\n\t// eslint-disable-next-line prefer-const\n\tlet proxy;\n\n\tbase.apply = (target, context, args) => {\n\t\tcontext = Contextify.value(context);\n\n\t\t// Set context of all arguments to vm's context.\n\t\targs = Contextify.arguments(args);\n\n\t\ttry {\n\t\t\treturn Decontextify.value(fnc.apply(context, args));\n\t\t} catch (e) {\n\t\t\tthrow Decontextify.value(e);\n\t\t}\n\t};\n\tbase.construct = (target, args, newTarget) => {\n\t\targs = Contextify.arguments(args);\n\n\t\ttry {\n\t\t\treturn Decontextify.instance(new fnc(...args), proxy, deepTraps, flags);\n\t\t} catch (e) {\n\t\t\tthrow Decontextify.value(e);\n\t\t}\n\t};\n\tbase.get = (target, key, receiver) => {\n\t\ttry {\n\t\t\tif (key === 'vmProxyTarget' && DEBUG) return fnc;\n\t\t\tif (key === 'isVMProxy') return true;\n\t\t\tif (mock && host.Object.prototype.hasOwnProperty.call(mock, key)) return mock[key];\n\t\t\tif (key === 'constructor') return host.Function;\n\t\t\tif (key === '__proto__') return host.Function.prototype;\n\t\t} catch (e) {\n\t\t\t// Never pass the handled exception through! This block can't throw an exception under normal conditions.\n\t\t\treturn null;\n\t\t}\n\n\t\tif (key === '__defineGetter__') return host.Object.prototype.__defineGetter__;\n\t\tif (key === '__defineSetter__') return host.Object.prototype.__defineSetter__;\n\t\tif (key === '__lookupGetter__') return host.Object.prototype.__lookupGetter__;\n\t\tif (key === '__lookupSetter__') return host.Object.prototype.__lookupSetter__;\n\n\t\ttry {\n\t\t\treturn Decontextify.value(fnc[key], null, deepTraps, flags);\n\t\t} catch (e) {\n\t\t\tthrow Decontextify.value(e);\n\t\t}\n\t};\n\tbase.getPrototypeOf = (target) => {\n\t\treturn host.Function.prototype;\n\t};\n\n\tproxy = Decontextify.object(fnc, host.Object.assign(base, traps), deepTraps);\n\treturn proxy;\n};\nDecontextify.object = (object, traps, deepTraps, flags, mock) => {\n\t// We must not use normal object because there's a chance object already contains malicious code in the prototype\n\tconst base = host.Object.create(null);\n\n\tbase.get = (target, key, receiver) => {\n\t\ttry {\n\t\t\tif (key === 'vmProxyTarget' && DEBUG) return object;\n\t\t\tif (key === 'isVMProxy') return true;\n\t\t\tif (mock && host.Object.prototype.hasOwnProperty.call(mock, key)) return mock[key];\n\t\t\tif (key === 'constructor') return host.Object;\n\t\t\tif (key === '__proto__') return host.Object.prototype;\n\t\t} catch (e) {\n\t\t\t// Never pass the handled exception through! This block can't throw an exception under normal conditions.\n\t\t\treturn null;\n\t\t}\n\n\t\tif (key === '__defineGetter__') return host.Object.prototype.__defineGetter__;\n\t\tif (key === '__defineSetter__') return host.Object.prototype.__defineSetter__;\n\t\tif (key === '__lookupGetter__') return host.Object.prototype.__lookupGetter__;\n\t\tif (key === '__lookupSetter__') return host.Object.prototype.__lookupSetter__;\n\n\t\ttry {\n\t\t\treturn Decontextify.value(object[key], null, deepTraps, flags);\n\t\t} catch (e) {\n\t\t\tthrow Decontextify.value(e);\n\t\t}\n\t};\n\tbase.set = (target, key, value, receiver) => {\n\t\tvalue = Contextify.value(value);\n\n\t\ttry {\n\t\t\treturn local.Reflect.set(object, key, value);\n\t\t} catch (e) {\n\t\t\tthrow Decontextify.value(e);\n\t\t}\n\t};\n\tbase.getOwnPropertyDescriptor = (target, prop) => {\n\t\tlet def;\n\n\t\ttry {\n\t\t\tdef = host.Object.getOwnPropertyDescriptor(object, prop);\n\t\t} catch (e) {\n\t\t\tthrow Decontextify.value(e);\n\t\t}\n\n\t\t// Following code prevents V8 to throw\n\t\t// TypeError: 'getOwnPropertyDescriptor' on proxy: trap reported non-configurability for property '<prop>'\n\t\t// which is either non-existant or configurable in the proxy target\n\n\t\tlet desc;\n\t\tif (!def) {\n\t\t\treturn undefined;\n\t\t} else if (def.get || def.set) {\n\t\t\tdesc = {\n\t\t\t\t__proto__: null,\n\t\t\t\tget: Decontextify.value(def.get) || undefined,\n\t\t\t\tset: Decontextify.value(def.set) || undefined,\n\t\t\t\tenumerable: def.enumerable === true,\n\t\t\t\tconfigurable: def.configurable === true\n\t\t\t};\n\t\t} else {\n\t\t\tdesc = {\n\t\t\t\t__proto__: null,\n\t\t\t\tvalue: Decontextify.value(def.value),\n\t\t\t\twritable: def.writable === true,\n\t\t\t\tenumerable: def.enumerable === true,\n\t\t\t\tconfigurable: def.configurable === true\n\t\t\t};\n\t\t}\n\t\tif (!desc.configurable) {\n\t\t\ttry {\n\t\t\t\tdef = host.Object.getOwnPropertyDescriptor(target, prop);\n\t\t\t\tif (!def || def.configurable || def.writable !== desc.writable) {\n\t\t\t\t\tlocal.Reflect.defineProperty(target, prop, desc);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t// Should not happen.\n\t\t\t}\n\t\t}\n\t\treturn desc;\n\t};\n\tbase.defineProperty = (target, key, descriptor) => {\n\t\tlet success = false;\n\t\ttry {\n\t\t\tsuccess = local.Reflect.setPrototypeOf(descriptor, null);\n\t\t} catch (e) {\n\t\t\t// Should not happen\n\t\t}\n\t\tif (!success) return false;\n\t\t// There's a chance accessing a property throws an error so we must not access them\n\t\t// in try catch to prevent contextifying local objects.\n\n\t\tconst propertyDescriptor = host.Object.create(null);\n\t\tif (descriptor.get || descriptor.set) {\n\t\t\tpropertyDescriptor.get = Contextify.value(descriptor.get, null, deepTraps, flags) || undefined;\n\t\t\tpropertyDescriptor.set = Contextify.value(descriptor.set, null, deepTraps, flags) || undefined;\n\t\t\tpropertyDescriptor.enumerable = descriptor.enumerable === true;\n\t\t\tpropertyDescriptor.configurable = descriptor.configurable === true;\n\t\t} else {\n\t\t\tpropertyDescriptor.value = Contextify.value(descriptor.value, null, deepTraps, flags);\n\t\t\tpropertyDescriptor.writable = descriptor.writable === true;\n\t\t\tpropertyDescriptor.enumerable = descriptor.enumerable === true;\n\t\t\tpropertyDescriptor.configurable = descriptor.configurable === true;\n\t\t}\n\n\t\ttry {\n\t\t\tsuccess = local.Reflect.defineProperty(object, key, propertyDescriptor);\n\t\t} catch (e) {\n\t\t\tthrow Decontextify.value(e);\n\t\t}\n\t\tif (success && !descriptor.configurable) {\n\t\t\ttry {\n\t\t\t\tlocal.Reflect.defineProperty(target, key, descriptor);\n\t\t\t} catch (e) {\n\t\t\t\t// This should not happen.\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn success;\n\t};\n\tbase.deleteProperty = (target, prop) => {\n\t\ttry {\n\t\t\treturn Decontextify.value(local.Reflect.deleteProperty(object, prop));\n\t\t} catch (e) {\n\t\t\tthrow Decontextify.value(e);\n\t\t}\n\t};\n\tbase.getPrototypeOf = (target) => {\n\t\treturn host.Object.prototype;\n\t};\n\tbase.setPrototypeOf = (target) => {\n\t\tthrow new host.Error(OPNA);\n\t};\n\tbase.has = (target, key) => {\n\t\ttry {\n\t\t\treturn Decontextify.value(local.Reflect.has(object, key));\n\t\t} catch (e) {\n\t\t\tthrow Decontextify.value(e);\n\t\t}\n\t};\n\tbase.isExtensible = target => {\n\t\tlet result;\n\t\ttry {\n\t\t\tresult = local.Reflect.isExtensible(object);\n\t\t} catch (e) {\n\t\t\tthrow Decontextify.value(e);\n\t\t}\n\t\tif (!result) {\n\t\t\ttry {\n\t\t\t\tif (local.Reflect.isExtensible(target)) {\n\t\t\t\t\tdoPreventExtensions(target, object, obj => Contextify.value(obj, null, deepTraps, flags));\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t// Should not happen\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t};\n\tbase.ownKeys = target => {\n\t\ttry {\n\t\t\treturn Decontextify.value(local.Reflect.ownKeys(object));\n\t\t} catch (e) {\n\t\t\tthrow Decontextify.value(e);\n\t\t}\n\t};\n\tbase.preventExtensions = target => {\n\t\tlet success;\n\t\ttry {\n\t\t\tsuccess = local.Reflect.preventExtensions(object);\n\t\t} catch (e) {\n\t\t\tthrow Decontextify.value(e);\n\t\t}\n\t\tif (success) {\n\t\t\ttry {\n\t\t\t\tif (local.Reflect.isExtensible(target)) {\n\t\t\t\t\tdoPreventExtensions(target, object, obj => Contextify.value(obj, null, deepTraps, flags));\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t// Should not happen\n\t\t\t}\n\t\t}\n\t\treturn success;\n\t};\n\tbase.enumerate = target => {\n\t\ttry {\n\t\t\treturn Decontextify.value(local.Reflect.enumerate(object));\n\t\t} catch (e) {\n\t\t\tthrow Decontextify.value(e);\n\t\t}\n\t};\n\n\thost.Object.assign(base, traps, deepTraps);\n\n\tlet shallow;\n\tif (host.Array.isArray(object)) {\n\t\tconst origGet = base.get;\n\t\tshallow = {\n\t\t\t__proto__: null,\n\t\t\townKeys: base.ownKeys,\n\t\t\t// TODO this get will call getOwnPropertyDescriptor of target all the time.\n\t\t\tget: origGet\n\t\t};\n\t\tbase.ownKeys = target => {\n\t\t\ttry {\n\t\t\t\tconst keys = local.Reflect.ownKeys(object);\n\t\t\t\t// Do this hack so that console.log(decontextify([1,2,3])) doesn't write the properties twice\n\t\t\t\t// a la [1,2,3,'0':1,'1':2,'2':3]\n\t\t\t\treturn Decontextify.value(keys.filter(key=>typeof key!=='string' || !key.match(/^\\d+$/)));\n\t\t\t} catch (e) {\n\t\t\t\tthrow Decontextify.value(e);\n\t\t\t}\n\t\t};\n\t\tbase.get = (target, key, receiver) => {\n\t\t\tif (key === host.Symbol.toStringTag) return;\n\t\t\treturn origGet(target, key, receiver);\n\t\t};\n\t} else {\n\t\tshallow = SHARED_OBJECT;\n\t}\n\n\tconst proxy = new host.Proxy(createBaseObject(object), base);\n\tDecontextified.set(proxy, object);\n\t// We need two proxies since nodes inspect just removes one.\n\tconst proxy2 = new host.Proxy(proxy, shallow);\n\tDecontextify.proxies.set(object, proxy2);\n\tDecontextified.set(proxy2, object);\n\treturn proxy2;\n};\nDecontextify.value = (value, traps, deepTraps, flags, mock) => {\n\ttry {\n\t\tif (Contextified.has(value)) {\n\t\t\t// Contextified object has returned back from vm\n\t\t\treturn Contextified.get(value);\n\t\t} else if (Decontextify.proxies.has(value)) {\n\t\t\t// Decontextified proxy already exists, reuse\n\t\t\treturn Decontextify.proxies.get(value);\n\t\t}\n\n\t\tswitch (typeof value) {\n\t\t\tcase 'object':\n\t\t\t\tif (value === null) {\n\t\t\t\t\treturn null;\n\t\t\t\t} else if (instanceOf(value, Number))         { return Decontextify.instance(value, host.Number, deepTraps, flags, 'Number');\n\t\t\t\t} else if (instanceOf(value, String))         { return Decontextify.instance(value, host.String, deepTraps, flags, 'String');\n\t\t\t\t} else if (instanceOf(value, Boolean))        { return Decontextify.instance(value, host.Boolean, deepTraps, flags, 'Boolean');\n\t\t\t\t} else if (instanceOf(value, Date))           { return Decontextify.instance(value, host.Date, deepTraps, flags, 'Date');\n\t\t\t\t} else if (instanceOf(value, RangeError))     { return Decontextify.instance(value, host.RangeError, deepTraps, flags, 'Error');\n\t\t\t\t} else if (instanceOf(value, ReferenceError)) { return Decontextify.instance(value, host.ReferenceError, deepTraps, flags, 'Error');\n\t\t\t\t} else if (instanceOf(value, SyntaxError))    { return Decontextify.instance(value, host.SyntaxError, deepTraps, flags, 'Error');\n\t\t\t\t} else if (instanceOf(value, TypeError))      { return Decontextify.instance(value, host.TypeError, deepTraps, flags, 'Error');\n\t\t\t\t} else if (instanceOf(value, VMError))        { return Decontextify.instance(value, host.VMError, deepTraps, flags, 'Error');\n\t\t\t\t} else if (instanceOf(value, EvalError))      { return Decontextify.instance(value, host.EvalError, deepTraps, flags, 'Error');\n\t\t\t\t} else if (instanceOf(value, URIError))       { return Decontextify.instance(value, host.URIError, deepTraps, flags, 'Error');\n\t\t\t\t} else if (instanceOf(value, Error))          { return Decontextify.instance(value, host.Error, deepTraps, flags, 'Error');\n\t\t\t\t} else if (instanceOf(value, Array))          { return Decontextify.instance(value, host.Array, deepTraps, flags, 'Array');\n\t\t\t\t} else if (instanceOf(value, RegExp))         { return Decontextify.instance(value, host.RegExp, deepTraps, flags, 'RegExp');\n\t\t\t\t} else if (instanceOf(value, Map))            { return Decontextify.instance(value, host.Map, deepTraps, flags, 'Map');\n\t\t\t\t} else if (instanceOf(value, WeakMap))        { return Decontextify.instance(value, host.WeakMap, deepTraps, flags, 'WeakMap');\n\t\t\t\t} else if (instanceOf(value, Set))            { return Decontextify.instance(value, host.Set, deepTraps, flags, 'Set');\n\t\t\t\t} else if (instanceOf(value, WeakSet))        { return Decontextify.instance(value, host.WeakSet, deepTraps, flags, 'WeakSet');\n\t\t\t\t} else if (typeof Promise === 'function' && instanceOf(value, Promise)) {\n\t\t\t\t\treturn Decontextify.instance(value, host.Promise, deepTraps, flags, 'Promise');\n\t\t\t\t} else if (local.Reflect.getPrototypeOf(value) === null) {\n\t\t\t\t\treturn Decontextify.instance(value, null, deepTraps, flags);\n\t\t\t\t} else {\n\t\t\t\t\treturn Decontextify.object(value, traps, deepTraps, flags, mock);\n\t\t\t\t}\n\t\t\tcase 'function':\n\t\t\t\treturn Decontextify.function(value, traps, deepTraps, flags, mock);\n\n\t\t\tcase 'undefined':\n\t\t\t\treturn undefined;\n\n\t\t\tdefault: // string, number, boolean, symbol\n\t\t\t\treturn value;\n\t\t}\n\t} catch (ex) {\n\t\t// Never pass the handled exception through! This block can't throw an exception under normal conditions.\n\t\treturn null;\n\t}\n};\n\n/**\n * Contextify.\n */\n\nconst Contextify = host.Object.create(null);\nContextify.proxies = new host.WeakMap();\n\nContextify.arguments = args => {\n\tif (!host.Array.isArray(args)) return new local.Array();\n\n\ttry {\n\t\tconst arr = new local.Array();\n\t\tfor (let i = 0, l = args.length; i < l; i++) arr[i] = Contextify.value(args[i]);\n\t\treturn arr;\n\t} catch (e) {\n\t\t// Never pass the handled exception through!\n\t\treturn new local.Array();\n\t}\n};\nContextify.instance = (instance, klass, deepTraps, flags, toStringTag) => {\n\tif (typeof instance === 'function') return Contextify.function(instance);\n\n\t// We must not use normal object because there's a chance object already contains malicious code in the prototype\n\tconst base = host.Object.create(null);\n\n\tbase.get = (target, key, receiver) => {\n\t\ttry {\n\t\t\tif (key === 'vmProxyTarget' && DEBUG) return instance;\n\t\t\tif (key === 'isVMProxy') return true;\n\t\t\tif (key === 'constructor') return klass;\n\t\t\tif (key === '__proto__') return klass.prototype;\n\t\t} catch (e) {\n\t\t\t// Never pass the handled exception through! This block can't throw an exception under normal conditions.\n\t\t\treturn null;\n\t\t}\n\n\t\tif (key === '__defineGetter__') return local.Object.prototype.__defineGetter__;\n\t\tif (key === '__defineSetter__') return local.Object.prototype.__defineSetter__;\n\t\tif (key === '__lookupGetter__') return local.Object.prototype.__lookupGetter__;\n\t\tif (key === '__lookupSetter__') return local.Object.prototype.__lookupSetter__;\n\t\tif (key === host.Symbol.toStringTag && toStringTag) return toStringTag;\n\n\t\ttry {\n\t\t\treturn Contextify.value(host.Reflect.get(instance, key), null, deepTraps, flags);\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\t};\n\tbase.getPrototypeOf = (target) => {\n\t\treturn klass && klass.prototype;\n\t};\n\n\treturn Contextify.object(instance, base, deepTraps, flags);\n};\nContextify.function = (fnc, traps, deepTraps, flags, mock) => {\n\t// We must not use normal object because there's a chance object already contains malicious code in the prototype\n\tconst base = host.Object.create(null);\n\t// eslint-disable-next-line prefer-const\n\tlet proxy;\n\n\tbase.apply = (target, context, args) => {\n\t\t// Fixes buffer unsafe allocation for node v6/7\n\t\tif (host.version < 8 && fnc === host.Buffer && 'number' === typeof args[0]) {\n\t\t\targs[0] = new local.Array(args[0]).fill(0);\n\t\t}\n\n\t\tcontext = Decontextify.value(context);\n\n\t\t// Set context of all arguments to host's context.\n\t\targs = Decontextify.arguments(args);\n\n\t\ttry {\n\t\t\treturn Contextify.value(fnc.apply(context, args));\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\t};\n\tbase.construct = (target, args, newTarget) => {\n\t\t// Fixes buffer unsafe allocation for node v6/7\n\t\tif (host.version < 8 && fnc === host.Buffer && 'number' === typeof args[0]) {\n\t\t\targs[0] = new local.Array(args[0]).fill(0);\n\t\t}\n\n\t\targs = Decontextify.arguments(args);\n\n\t\ttry {\n\t\t\treturn Contextify.instance(new fnc(...args), proxy, deepTraps, flags);\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\t};\n\tbase.get = (target, key, receiver) => {\n\t\ttry {\n\t\t\tif (key === 'vmProxyTarget' && DEBUG) return fnc;\n\t\t\tif (key === 'isVMProxy') return true;\n\t\t\tif (mock && host.Object.prototype.hasOwnProperty.call(mock, key)) return mock[key];\n\t\t\tif (key === 'constructor') return Function;\n\t\t\tif (key === '__proto__') return Function.prototype;\n\t\t} catch (e) {\n\t\t\t// Never pass the handled exception through! This block can't throw an exception under normal conditions.\n\t\t\treturn null;\n\t\t}\n\n\t\tif (key === '__defineGetter__') return local.Object.prototype.__defineGetter__;\n\t\tif (key === '__defineSetter__') return local.Object.prototype.__defineSetter__;\n\t\tif (key === '__lookupGetter__') return local.Object.prototype.__lookupGetter__;\n\t\tif (key === '__lookupSetter__') return local.Object.prototype.__lookupSetter__;\n\n\t\tif (key === 'caller' || key === 'callee' || key === 'arguments') throw throwCallerCalleeArgumentsAccess(key);\n\n\t\ttry {\n\t\t\treturn Contextify.value(host.Reflect.get(fnc, key), null, deepTraps, flags);\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\t};\n\tbase.getPrototypeOf = (target) => {\n\t\treturn Function.prototype;\n\t};\n\n\tproxy = Contextify.object(fnc, host.Object.assign(base, traps), deepTraps);\n\treturn proxy;\n};\nContextify.object = (object, traps, deepTraps, flags, mock) => {\n\t// We must not use normal object because there's a chance object already contains malicious code in the prototype\n\tconst base = host.Object.create(null);\n\n\tbase.get = (target, key, receiver) => {\n\t\ttry {\n\t\t\tif (key === 'vmProxyTarget' && DEBUG) return object;\n\t\t\tif (key === 'isVMProxy') return true;\n\t\t\tif (mock && host.Object.prototype.hasOwnProperty.call(mock, key)) return mock[key];\n\t\t\tif (key === 'constructor') return Object;\n\t\t\tif (key === '__proto__') return Object.prototype;\n\t\t} catch (e) {\n\t\t\t// Never pass the handled exception through! This block can't throw an exception under normal conditions.\n\t\t\treturn null;\n\t\t}\n\n\t\tif (key === '__defineGetter__') return local.Object.prototype.__defineGetter__;\n\t\tif (key === '__defineSetter__') return local.Object.prototype.__defineSetter__;\n\t\tif (key === '__lookupGetter__') return local.Object.prototype.__lookupGetter__;\n\t\tif (key === '__lookupSetter__') return local.Object.prototype.__lookupSetter__;\n\n\t\ttry {\n\t\t\treturn Contextify.value(host.Reflect.get(object, key), null, deepTraps, flags);\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\t};\n\tbase.set = (target, key, value, receiver) => {\n\t\tif (key === '__proto__') return false;\n\t\tif (flags && flags.protected && typeof value === 'function') return false;\n\n\t\tvalue = Decontextify.value(value);\n\n\t\ttry {\n\t\t\treturn host.Reflect.set(object, key, value);\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\t};\n\tbase.getOwnPropertyDescriptor = (target, prop) => {\n\t\tlet def;\n\n\t\ttry {\n\t\t\tdef = host.Object.getOwnPropertyDescriptor(object, prop);\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\n\t\t// Following code prevents V8 to throw\n\t\t// TypeError: 'getOwnPropertyDescriptor' on proxy: trap reported non-configurability for property '<prop>'\n\t\t// which is either non-existant or configurable in the proxy target\n\n\t\tlet desc;\n\t\tif (!def) {\n\t\t\treturn undefined;\n\t\t} else if (def.get || def.set) {\n\t\t\tdesc = {\n\t\t\t\t__proto__: null,\n\t\t\t\tget: Contextify.value(def.get, null, deepTraps, flags) || undefined,\n\t\t\t\tset: Contextify.value(def.set, null, deepTraps, flags) || undefined,\n\t\t\t\tenumerable: def.enumerable === true,\n\t\t\t\tconfigurable: def.configurable === true\n\t\t\t};\n\t\t} else {\n\t\t\tdesc = {\n\t\t\t\t__proto__: null,\n\t\t\t\tvalue: Contextify.value(def.value, null, deepTraps, flags),\n\t\t\t\twritable: def.writable === true,\n\t\t\t\tenumerable: def.enumerable === true,\n\t\t\t\tconfigurable: def.configurable === true\n\t\t\t};\n\t\t}\n\t\tif (!desc.configurable) {\n\t\t\ttry {\n\t\t\t\tdef = host.Object.getOwnPropertyDescriptor(target, prop);\n\t\t\t\tif (!def || def.configurable || def.writable !== desc.writable) {\n\t\t\t\t\tlocal.Reflect.defineProperty(target, prop, desc);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t// Should not happen.\n\t\t\t}\n\t\t}\n\t\treturn desc;\n\t};\n\tbase.defineProperty = (target, key, descriptor) => {\n\t\tlet success = false;\n\t\ttry {\n\t\t\tsuccess = local.Reflect.setPrototypeOf(descriptor, null);\n\t\t} catch (e) {\n\t\t\t// Should not happen\n\t\t}\n\t\tif (!success) return false;\n\t\t// There's a chance accessing a property throws an error so we must not access them\n\t\t// in try catch to prevent contextifying local objects.\n\n\t\tconst descGet = descriptor.get;\n\t\tconst descSet = descriptor.set;\n\t\tconst descValue = descriptor.value;\n\n\t\tif (flags && flags.protected) {\n\t\t\tif (descGet || descSet || typeof descValue === 'function') return false;\n\t\t}\n\n\t\tconst propertyDescriptor = host.Object.create(null);\n\t\tif (descGet || descSet) {\n\t\t\tpropertyDescriptor.get = Decontextify.value(descGet, null, deepTraps, flags) || undefined;\n\t\t\tpropertyDescriptor.set = Decontextify.value(descSet, null, deepTraps, flags) || undefined;\n\t\t\tpropertyDescriptor.enumerable = descriptor.enumerable === true;\n\t\t\tpropertyDescriptor.configurable = descriptor.configurable === true;\n\t\t} else {\n\t\t\tpropertyDescriptor.value = Decontextify.value(descValue, null, deepTraps, flags);\n\t\t\tpropertyDescriptor.writable = descriptor.writable === true;\n\t\t\tpropertyDescriptor.enumerable = descriptor.enumerable === true;\n\t\t\tpropertyDescriptor.configurable = descriptor.configurable === true;\n\t\t}\n\n\t\ttry {\n\t\t\tsuccess = host.Reflect.defineProperty(object, key, propertyDescriptor);\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\t\tif (success && !descriptor.configurable) {\n\t\t\ttry {\n\t\t\t\tlocal.Reflect.defineProperty(target, key, descriptor);\n\t\t\t} catch (e) {\n\t\t\t\t// This should not happen.\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn success;\n\t};\n\tbase.deleteProperty = (target, prop) => {\n\t\ttry {\n\t\t\treturn Contextify.value(host.Reflect.deleteProperty(object, prop));\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\t};\n\tbase.getPrototypeOf = (target) => {\n\t\treturn local.Object.prototype;\n\t};\n\tbase.setPrototypeOf = (target) => {\n\t\tthrow new VMError(OPNA);\n\t};\n\tbase.has = (target, key) => {\n\t\ttry {\n\t\t\treturn Contextify.value(host.Reflect.has(object, key));\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\t};\n\tbase.isExtensible = target => {\n\t\tlet result;\n\t\ttry {\n\t\t\tresult = host.Reflect.isExtensible(object);\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\t\tif (!result) {\n\t\t\ttry {\n\t\t\t\tif (local.Reflect.isExtensible(target)) {\n\t\t\t\t\tdoPreventExtensions(target, object, obj => Decontextify.value(obj, null, deepTraps, flags));\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t// Should not happen\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t};\n\tbase.ownKeys = target => {\n\t\ttry {\n\t\t\treturn Contextify.value(host.Reflect.ownKeys(object));\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\t};\n\tbase.preventExtensions = target => {\n\t\tlet success;\n\t\ttry {\n\t\t\tsuccess = local.Reflect.preventExtensions(object);\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\t\tif (success) {\n\t\t\ttry {\n\t\t\t\tif (local.Reflect.isExtensible(target)) {\n\t\t\t\t\tdoPreventExtensions(target, object, obj => Decontextify.value(obj, null, deepTraps, flags));\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t// Should not happen\n\t\t\t}\n\t\t}\n\t\treturn success;\n\t};\n\tbase.enumerate = target => {\n\t\ttry {\n\t\t\treturn Contextify.value(host.Reflect.enumerate(object));\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\t};\n\n\tconst proxy = new host.Proxy(createBaseObject(object), host.Object.assign(base, traps, deepTraps));\n\tContextify.proxies.set(object, proxy);\n\tContextified.set(proxy, object);\n\treturn proxy;\n};\nContextify.value = (value, traps, deepTraps, flags, mock) => {\n\ttry {\n\t\tif (Decontextified.has(value)) {\n\t\t\t// Decontextified object has returned back to vm\n\t\t\treturn Decontextified.get(value);\n\t\t} else if (Contextify.proxies.has(value)) {\n\t\t\t// Contextified proxy already exists, reuse\n\t\t\treturn Contextify.proxies.get(value);\n\t\t}\n\n\t\tswitch (typeof value) {\n\t\t\tcase 'object':\n\t\t\t\tif (value === null) {\n\t\t\t\t\treturn null;\n\t\t\t\t} else if (instanceOf(value, host.Number))         { return Contextify.instance(value, Number, deepTraps, flags, 'Number');\n\t\t\t\t} else if (instanceOf(value, host.String))         { return Contextify.instance(value, String, deepTraps, flags, 'String');\n\t\t\t\t} else if (instanceOf(value, host.Boolean))        { return Contextify.instance(value, Boolean, deepTraps, flags, 'Boolean');\n\t\t\t\t} else if (instanceOf(value, host.Date))           { return Contextify.instance(value, Date, deepTraps, flags, 'Date');\n\t\t\t\t} else if (instanceOf(value, host.RangeError))     { return Contextify.instance(value, RangeError, deepTraps, flags, 'Error');\n\t\t\t\t} else if (instanceOf(value, host.ReferenceError)) { return Contextify.instance(value, ReferenceError, deepTraps, flags, 'Error');\n\t\t\t\t} else if (instanceOf(value, host.SyntaxError))    { return Contextify.instance(value, SyntaxError, deepTraps, flags, 'Error');\n\t\t\t\t} else if (instanceOf(value, host.TypeError))      { return Contextify.instance(value, TypeError, deepTraps, flags, 'Error');\n\t\t\t\t} else if (instanceOf(value, host.VMError))        { return Contextify.instance(value, VMError, deepTraps, flags, 'Error');\n\t\t\t\t} else if (instanceOf(value, host.EvalError))      { return Contextify.instance(value, EvalError, deepTraps, flags, 'Error');\n\t\t\t\t} else if (instanceOf(value, host.URIError))       { return Contextify.instance(value, URIError, deepTraps, flags, 'Error');\n\t\t\t\t} else if (instanceOf(value, host.Error))          { return Contextify.instance(value, Error, deepTraps, flags, 'Error');\n\t\t\t\t} else if (instanceOf(value, host.Array))          { return Contextify.instance(value, Array, deepTraps, flags, 'Array');\n\t\t\t\t} else if (instanceOf(value, host.RegExp))         { return Contextify.instance(value, RegExp, deepTraps, flags, 'RegExp');\n\t\t\t\t} else if (instanceOf(value, host.Map))            { return Contextify.instance(value, Map, deepTraps, flags, 'Map');\n\t\t\t\t} else if (instanceOf(value, host.WeakMap))        { return Contextify.instance(value, WeakMap, deepTraps, flags, 'WeakMap');\n\t\t\t\t} else if (instanceOf(value, host.Set))            { return Contextify.instance(value, Set, deepTraps, flags, 'Set');\n\t\t\t\t} else if (instanceOf(value, host.WeakSet))        { return Contextify.instance(value, WeakSet, deepTraps, flags, 'WeakSet');\n\t\t\t\t} else if (typeof Promise === 'function' && instanceOf(value, host.Promise)) {\n\t\t\t\t\treturn Contextify.instance(value, Promise, deepTraps, flags, 'Promise');\n\t\t\t\t} else if (instanceOf(value, host.Buffer))         { return Contextify.instance(value, LocalBuffer, deepTraps, flags, 'Uint8Array');\n\t\t\t\t} else if (host.Reflect.getPrototypeOf(value) === null) {\n\t\t\t\t\treturn Contextify.instance(value, null, deepTraps, flags);\n\t\t\t\t} else {\n\t\t\t\t\treturn Contextify.object(value, traps, deepTraps, flags, mock);\n\t\t\t\t}\n\t\t\tcase 'function':\n\t\t\t\treturn Contextify.function(value, traps, deepTraps, flags, mock);\n\n\t\t\tcase 'undefined':\n\t\t\t\treturn undefined;\n\n\t\t\tdefault: // string, number, boolean, symbol\n\t\t\t\treturn value;\n\t\t}\n\t} catch (ex) {\n\t\t// Never pass the handled exception through! This block can't throw an exception under normal conditions.\n\t\treturn null;\n\t}\n};\nContextify.setGlobal = (name, value) => {\n\tconst prop = Contextify.value(name);\n\ttry {\n\t\tglobal[prop] = Contextify.value(value);\n\t} catch (e) {\n\t\tthrow Decontextify.value(e);\n\t}\n};\nContextify.getGlobal = (name) => {\n\tconst prop = Contextify.value(name);\n\ttry {\n\t\treturn Decontextify.value(global[prop]);\n\t} catch (e) {\n\t\tthrow Decontextify.value(e);\n\t}\n};\nContextify.readonly = (value, mock) => {\n\treturn Contextify.value(value, null, FROZEN_TRAPS, null, mock);\n};\nContextify.protected = (value, mock) => {\n\treturn Contextify.value(value, null, null, {protected: true}, mock);\n};\nContextify.connect = (outer, inner) => {\n\tDecontextified.set(outer, inner);\n\tContextified.set(inner, outer);\n};\nContextify.makeModule = ()=>({exports: {}});\nContextify.isVMProxy = (obj) => Decontextified.has(obj);\n\nconst BufferMock = host.Object.create(null);\nBufferMock.allocUnsafe = function allocUnsafe(size) {\n\treturn this.alloc(size);\n};\nBufferMock.allocUnsafeSlow = function allocUnsafeSlow(size) {\n\treturn this.alloc(size);\n};\nconst BufferOverride = host.Object.create(null);\nBufferOverride.inspect = function inspect(recurseTimes, ctx) {\n\t// Mimic old behavior, could throw but didn't pass a test.\n\tconst max = host.INSPECT_MAX_BYTES;\n\tconst actualMax = Math.min(max, this.length);\n\tconst remaining = this.length - max;\n\tlet str = this.hexSlice(0, actualMax).replace(/(.{2})/g, '$1 ').trim();\n\tif (remaining > 0) str += ` ... ${remaining} more byte${remaining > 1 ? 's' : ''}`;\n\treturn `<${this.constructor.name} ${str}>`;\n};\nconst LocalBuffer = global.Buffer = Contextify.readonly(host.Buffer, BufferMock);\nContextify.connect(host.Buffer.prototype.inspect, BufferOverride.inspect);\n\n\nconst exportsMap = host.Object.create(null);\nexportsMap.Contextify = Contextify;\nexportsMap.Decontextify = Decontextify;\nexportsMap.Buffer = LocalBuffer;\nexportsMap.sandbox = Decontextify.value(global);\nexportsMap.Function = Function;\n\nreturn exportsMap;\n", "/* eslint-disable global-require, no-use-before-define */\n\n'use strict';\n\n/**\n * This callback will be called to transform a script to JavaScript.\n *\n * @callback compileCallback\n * @param {string} code - Script code to transform to JavaScript.\n * @param {string} filename - Filename of this script.\n * @return {string} JavaScript code that represents the script code.\n */\n\n/**\n * This callback will be called to resolve a module if it couldn't be found.\n *\n * @callback resolveCallback\n * @param {string} moduleName - Name of the module to resolve.\n * @param {string} dirname - Name of the current directory.\n * @return {(string|undefined)} The file or directory to use to load the requested module.\n */\n\nconst fs = require('fs');\nconst vm = require('vm');\nconst pa = require('path');\nconst {EventEmitter} = require('events');\nconst {INSPECT_MAX_BYTES} = require('buffer');\nconst helpers = require('./helpers.js');\nconst importModuleDynamically = () => {\n\t// We can't throw an error object here because since vm.Script doesn't store a context, we can't properly contextify that error object.\n\t// eslint-disable-next-line no-throw-literal\n\tthrow 'Dynamic imports are not allowed.';\n};\n\nconst MODULE_PREFIX = '(function (exports, require, module, __filename, __dirname) { ';\nconst STRICT_MODULE_PREFIX = MODULE_PREFIX + '\"use strict\"; ';\nconst MODULE_SUFFIX = '\\n});';\n\n/**\n * Load a script from a file and compile it.\n * \n * @private\n * @param {string} filename - File to load and compile to a script.\n * @param {string} prefix - Prefix for the script.\n * @param {string} suffix - Suffix for the script.\n * @return {vm.Script} The compiled script.\n */\nfunction loadAndCompileScript(filename, prefix, suffix) {\n\tconst data = fs.readFileSync(filename, 'utf8');\n\treturn new vm.Script(prefix + data + suffix, {\n\t\tfilename,\n\t\tdisplayErrors: false,\n\t\timportModuleDynamically\n\t});\n}\n\n/**\n * Cache where we can cache some things\n * \n * @private\n * @property {?compileCallback} coffeeScriptCompiler - The coffee script compiler or null if not yet used.\n * @property {?Object} timeoutContext - The context used for the timeout functionality of null if not yet used.\n * @property {?vm.Script} timeoutScript - The compiled script used for the timeout functionality of null if not yet used.\n * @property {vm.Script} contextifyScript - The compiled script used to setup a sandbox.\n * @property {?vm.Script} sandboxScript - The compiled script used to setup the NodeVM require mechanism of null if not yet used.\n * @property {?vm.Script} hookScript - The compiled script used to setup the async hooking functionality.\n * @property {?vm.Script} getGlobalScript - The compiled script used to get the global sandbox object.\n * @property {?vm.Script} getGeneratorFunctionScript - The compiled script used to get the generator function constructor.\n * @property {?vm.Script} getAsyncFunctionScript - The compiled script used to get the async function constructor.\n * @property {?vm.Script} getAsyncGeneratorFunctionScript - The compiled script used to get the async generator function constructor.\n */\nconst CACHE = {\n\tcoffeeScriptCompiler: null,\n\ttimeoutContext: null,\n\ttimeoutScript: null,\n\tcontextifyScript: loadAndCompileScript(`${__dirname}/contextify.js`, '(function(require, host) { ', '\\n})'),\n\tsandboxScript: null,\n\thookScript: null,\n\tgetGlobalScript: null,\n\tgetGeneratorFunctionScript: null,\n\tgetAsyncFunctionScript: null,\n\tgetAsyncGeneratorFunctionScript: null,\n};\n\n/**\n * Default run options for vm.Script.runInContext\n * \n * @private\n */\nconst DEFAULT_RUN_OPTIONS = {displayErrors: false, importModuleDynamically};\n\n/**\n * Returns the cached coffee script compiler or loads it\n * if it is not found in the cache.\n * \n * @private\n * @return {compileCallback} The coffee script compiler.\n * @throws {VMError} If the coffee-script module can't be found.\n */\nfunction getCoffeeScriptCompiler() {\n\tif (!CACHE.coffeeScriptCompiler) {\n\t\ttry {\n\t\t\tconst coffeeScript = require('coffee-script');\n\t\t\tCACHE.coffeeScriptCompiler = (code, filename) => {\n\t\t\t\treturn coffeeScript.compile(code, {header: false, bare: true});\n\t\t\t};\n\t\t} catch (e) {\n\t\t\tthrow new VMError('Coffee-Script compiler is not installed.');\n\t\t}\n\t}\n\treturn CACHE.coffeeScriptCompiler;\n}\n\n/**\n * The JavaScript compiler, just a identity function.\n * \n * @private\n * @type {compileCallback}\n * @param {string} code - The JavaScript code.\n * @param {string} filename - Filename of this script.\n * @return {string} The code.\n */\nfunction jsCompiler(code, filename) {\n\treturn removeShebang(code);\n}\n\n/**\n * Look up the compiler for a specific name.\n * \n * @private\n * @param {(string|compileCallback)} compiler - A compile callback or the name of the compiler.\n * @return {compileCallback} The resolved compiler.\n * @throws {VMError} If the compiler is unknown or the coffee script module was needed and couldn't be found.\n */\nfunction lookupCompiler(compiler) {\n\tif ('function' === typeof compiler) return compiler;\n\tswitch (compiler) {\n\t\tcase 'coffeescript':\n\t\tcase 'coffee-script':\n\t\tcase 'cs':\n\t\tcase 'text/coffeescript':\n\t\t\treturn getCoffeeScriptCompiler();\n\t\tcase 'javascript':\n\t\tcase 'java-script':\n\t\tcase 'js':\n\t\tcase 'text/javascript':\n\t\t\treturn jsCompiler;\n\t\tdefault:\n\t\t\tthrow new VMError(`Unsupported compiler '${compiler}'.`);\n\t}\n}\n\n/**\n * Remove the shebang from source code.\n * \n * @private\n * @param {string} code - Code from which to remove the shebang.\n * @return {string} code without the shebang.\n */\nfunction removeShebang(code) {\n\tif (!code.startsWith('#!')) return code;\n\treturn '//' + code.substr(2);\n}\n\n/**\n * Class Script\n *\n * @public\n */\nclass VMScript {\n\n\t/**\n\t * The script code with wrapping. If set will invalidate the cache.<br>\n\t * Writable only for backwards compatibility.\n\t * \n\t * @public\n\t * @readonly\n\t * @member {string} code\n\t * @memberOf VMScript#\n\t */\n\n\t/**\n\t * The filename used for this script.\n\t * \n\t * @public\n\t * @readonly\n\t * @since v3.9.0\n\t * @member {string} filename\n\t * @memberOf VMScript#\n\t */\n\n\t/**\n\t * The line offset use for stack traces.\n\t * \n\t * @public\n\t * @readonly\n\t * @since v3.9.0\n\t * @member {number} lineOffset\n\t * @memberOf VMScript#\n\t */\n\n\t/**\n\t * The column offset use for stack traces.\n\t * \n\t * @public\n\t * @readonly\n\t * @since v3.9.0\n\t * @member {number} columnOffset\n\t * @memberOf VMScript#\n\t */\n\n\t/**\n\t * The compiler to use to get the JavaScript code.\n\t * \n\t * @public\n\t * @readonly\n\t * @since v3.9.0\n\t * @member {(string|compileCallback)} compiler\n\t * @memberOf VMScript#\n\t */\n\n\t/**\n\t * The prefix for the script.\n\t * \n\t * @private\n\t * @member {string} _prefix\n\t * @memberOf VMScript#\n\t */\n\n\t/**\n\t * The suffix for the script.\n\t * \n\t * @private\n\t * @member {string} _suffix\n\t * @memberOf VMScript#\n\t */\n\n\t/**\n\t * The compiled vm.Script for the VM or if not compiled <code>null</code>.\n\t * \n\t * @private\n\t * @member {?vm.Script} _compiledVM\n\t * @memberOf VMScript#\n\t */\n\n\t/**\n\t * The compiled vm.Script for the NodeVM or if not compiled <code>null</code>.\n\t * \n\t * @private\n\t * @member {?vm.Script} _compiledNodeVM\n\t * @memberOf VMScript#\n\t */\n\n\t/**\n\t * The compiled vm.Script for the NodeVM in strict mode or if not compiled <code>null</code>.\n\t * \n\t * @private\n\t * @member {?vm.Script} _compiledNodeVMStrict\n\t * @memberOf VMScript#\n\t */\n\n\t/**\n\t * The resolved compiler to use to get the JavaScript code.\n\t * \n\t * @private\n\t * @readonly\n\t * @member {compileCallback} _compiler\n\t * @memberOf VMScript#\n\t */\n\n\t/**\n\t * The script to run without wrapping.\n\t * \n\t * @private\n\t * @member {string} _code\n\t * @memberOf VMScript#\n\t */\n\n\t/**\n\t * Create VMScript instance.\n\t *\n\t * @public\n\t * @param {string} code - Code to run.\n\t * @param {(string|Object)} [options] - Options map or filename.\n\t * @param {string} [options.filename=\"vm.js\"] - Filename that shows up in any stack traces produced from this script.\n\t * @param {number} [options.lineOffset=0] - Passed to vm.Script options.\n\t * @param {number} [options.columnOffset=0] - Passed to vm.Script options.\n\t * @param {(string|compileCallback)} [options.compiler=\"javascript\"] - The compiler to use.\n\t * @throws {VMError} If the compiler is unknown or if coffee-script was requested but the module not found.\n\t */\n\tconstructor(code, options) {\n\t\tconst sCode = `${code}`;\n\t\tlet useFileName;\n\t\tlet useOptions;\n\t\tif (arguments.length === 2) {\n\t\t\tif (typeof options === 'object' && options.toString === Object.prototype.toString) {\n\t\t\t\tuseOptions = options || {};\n\t\t\t\tuseFileName = useOptions.filename;\n\t\t\t} else {\n\t\t\t\tuseOptions = {};\n\t\t\t\tuseFileName = options;\n\t\t\t}\n\t\t} else if (arguments.length > 2) {\n\t\t\t// We do it this way so that there are no more arguments in the function.\n\t\t\t// eslint-disable-next-line prefer-rest-params\n\t\t\tuseOptions = arguments[2] || {};\n\t\t\tuseFileName = options || useOptions.filename;\n\t\t} else {\n\t\t\tuseOptions = {};\n\t\t}\n\n\t\tconst {\n\t\t\tcompiler = 'javascript',\n\t\t\tlineOffset = 0,\n\t\t\tcolumnOffset = 0\n\t\t} = useOptions;\n\n\t\t// Throw if the compiler is unknown.\n\t\tconst resolvedCompiler = lookupCompiler(compiler);\n\n\t\tObject.defineProperties(this, {\n\t\t\tcode: {\n\t\t\t\t// Put this here so that it is enumerable, and looks like a property.\n\t\t\t\tget() {\n\t\t\t\t\treturn this._prefix + this._code + this._suffix;\n\t\t\t\t},\n\t\t\t\tset(value) {\n\t\t\t\t\tconst strNewCode = String(value);\n\t\t\t\t\tif (strNewCode === this._code && this._prefix === '' && this._suffix === '') return;\n\t\t\t\t\tthis._code = strNewCode;\n\t\t\t\t\tthis._prefix = '';\n\t\t\t\t\tthis._suffix = '';\n\t\t\t\t\tthis._compiledVM = null;\n\t\t\t\t\tthis._compiledNodeVM = null;\n\t\t\t\t\tthis._compiledCode = null;\n\t\t\t\t},\n\t\t\t\tenumerable: true\n\t\t\t},\n\t\t\tfilename: {\n\t\t\t\tvalue: useFileName || 'vm.js',\n\t\t\t\tenumerable: true\n\t\t\t},\n\t\t\tlineOffset: {\n\t\t\t\tvalue: lineOffset,\n\t\t\t\tenumerable: true\n\t\t\t},\n\t\t\tcolumnOffset: {\n\t\t\t\tvalue: columnOffset,\n\t\t\t\tenumerable: true\n\t\t\t},\n\t\t\tcompiler: {\n\t\t\t\tvalue: compiler,\n\t\t\t\tenumerable: true\n\t\t\t},\n\t\t\t_code: {\n\t\t\t\tvalue: sCode,\n\t\t\t\twritable: true\n\t\t\t},\n\t\t\t_prefix: {\n\t\t\t\tvalue: '',\n\t\t\t\twritable: true\n\t\t\t},\n\t\t\t_suffix: {\n\t\t\t\tvalue: '',\n\t\t\t\twritable: true\n\t\t\t},\n\t\t\t_compiledVM: {\n\t\t\t\tvalue: null,\n\t\t\t\twritable: true\n\t\t\t},\n\t\t\t_compiledNodeVM: {\n\t\t\t\tvalue: null,\n\t\t\t\twritable: true\n\t\t\t},\n\t\t\t_compiledNodeVMStrict: {\n\t\t\t\tvalue: null,\n\t\t\t\twritable: true\n\t\t\t},\n\t\t\t_compiledCode: {\n\t\t\t\tvalue: null,\n\t\t\t\twritable: true\n\t\t\t},\n\t\t\t_compiler: {value: resolvedCompiler}\n\t\t});\n\t}\n\n\t/**\n\t * Wraps the code.<br>\n\t * This will replace the old wrapping.<br>\n\t * Will invalidate the code cache.\n\t *\n\t * @public\n\t * @deprecated Since v3.9.0. Wrap your code before passing it into the VMScript object.\n\t * @param {string} prefix - String that will be appended before the script code.\n\t * @param {script} suffix - String that will be appended behind the script code.\n\t * @return {this} This for chaining.\n\t * @throws {TypeError} If prefix or suffix is a Symbol.\n\t */\n\twrap(prefix, suffix) {\n\t\tconst strPrefix = `${prefix}`;\n\t\tconst strSuffix = `${suffix}`;\n\t\tif (this._prefix === strPrefix && this._suffix === strSuffix) return this;\n\t\tthis._prefix = strPrefix;\n\t\tthis._suffix = strSuffix;\n\t\tthis._compiledVM = null;\n\t\tthis._compiledNodeVM = null;\n\t\tthis._compiledNodeVMStrict = null;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Compile this script. <br>\n\t * This is useful to detect syntax errors in the script.\n\t *\n\t * @public\n\t * @return {this} This for chaining.\n\t * @throws {SyntaxError} If there is a syntax error in the script.\n\t */\n\tcompile() {\n\t\tthis._compileVM();\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the compiled code.\n\t * \n\t * @private\n\t * @return {string} The code.\n\t */\n\tgetCompiledCode() {\n\t\tif (!this._compiledCode) {\n\t\t\tthis._compiledCode = this._compiler(this._prefix + removeShebang(this._code) + this._suffix, this.filename);\n\t\t}\n\t\treturn this._compiledCode;\n\t}\n\n\t/**\n\t * Compiles this script to a vm.Script.\n\t * \n\t * @private\n\t * @param {string} prefix - JavaScript code that will be used as prefix.\n\t * @param {string} suffix - JavaScript code that will be used as suffix.\n\t * @return {vm.Script} The compiled vm.Script.\n\t * @throws {SyntaxError} If there is a syntax error in the script.\n\t */\n\t_compile(prefix, suffix) {\n\t\treturn new vm.Script(prefix + this.getCompiledCode() + suffix, {\n\t\t\tfilename: this.filename,\n\t\t\tdisplayErrors: false,\n\t\t\tlineOffset: this.lineOffset,\n\t\t\tcolumnOffset: this.columnOffset,\n\t\t\timportModuleDynamically\n\t\t});\n\t}\n\n\t/**\n\t * Will return the cached version of the script intended for VM or compile it.\n\t * \n\t * @private\n\t * @return {vm.Script} The compiled script\n\t * @throws {SyntaxError} If there is a syntax error in the script.\n\t */\n\t_compileVM() {\n\t\tlet script = this._compiledVM;\n\t\tif (!script) {\n\t\t\tthis._compiledVM = script = this._compile('', '');\n\t\t}\n\t\treturn script;\n\t}\n\n\t/**\n\t * Will return the cached version of the script intended for NodeVM or compile it.\n\t * \n\t * @private\n\t * @return {vm.Script} The compiled script\n\t * @throws {SyntaxError} If there is a syntax error in the script.\n\t */\n\t_compileNodeVM() {\n\t\tlet script = this._compiledNodeVM;\n\t\tif (!script) {\n\t\t\tthis._compiledNodeVM = script = this._compile(MODULE_PREFIX, MODULE_SUFFIX);\n\t\t}\n\t\treturn script;\n\t}\n\n\t/**\n\t * Will return the cached version of the script intended for NodeVM in strict mode or compile it.\n\t * \n\t * @private\n\t * @return {vm.Script} The compiled script\n\t * @throws {SyntaxError} If there is a syntax error in the script.\n\t */\n\t_compileNodeVMStrict() {\n\t\tlet script = this._compiledNodeVMStrict;\n\t\tif (!script) {\n\t\t\tthis._compiledNodeVMStrict = script = this._compile(STRICT_MODULE_PREFIX, MODULE_SUFFIX);\n\t\t}\n\t\treturn script;\n\t}\n\n}\n\n/**\n * \n * This callback will be called and has a specific time to finish.<br>\n * No parameters will be supplied.<br>\n * If parameters are required, use a closure.\n * \n * @private\n * @callback runWithTimeout\n * @return {*} \n * \n */\n\n/**\n * Run a function with a specific timeout.\n * \n * @private\n * @param {runWithTimeout} fn - Function to run with the specific timeout.\n * @param {number} timeout - The amount of time to give the function to finish.\n * @return {*} The value returned by the function.\n * @throws {Error} If the function took to long.\n */\nfunction doWithTimeout(fn, timeout) {\n\tlet ctx = CACHE.timeoutContext;\n\tlet script = CACHE.timeoutScript;\n\tif (!ctx) {\n\t\tCACHE.timeoutContext = ctx = vm.createContext();\n\t\tCACHE.timeoutScript = script = new vm.Script('fn()', {\n\t\t\tfilename: 'timeout_bridge.js',\n\t\t\tdisplayErrors: false,\n\t\t\timportModuleDynamically\n\t\t});\n\t}\n\tctx.fn = fn;\n\ttry {\n\t\treturn script.runInContext(ctx, {\n\t\t\tdisplayErrors: false,\n\t\t\timportModuleDynamically,\n\t\t\ttimeout\n\t\t});\n\t} finally {\n\t\tctx.fn = null;\n\t}\n}\n\n/**\n * Creates the hook to check for the use of async.\n * \n * @private\n * @param {*} internal - The internal vm object.\n * @return {*} The hook function\n */\nfunction makeCheckAsync(internal) {\n\treturn (hook, args) => {\n\t\tif (hook === 'function' || hook === 'generator_function' || hook === 'eval' || hook === 'run') {\n\t\t\tconst funcConstructor = internal.Function;\n\t\t\tif (hook === 'eval') {\n\t\t\t\tconst script = args[0];\n\t\t\t\targs = [script];\n\t\t\t\tif (typeof(script) !== 'string') return args;\n\t\t\t} else {\n\t\t\t\t// Next line throws on Symbol, this is the same behavior as function constructor calls\n\t\t\t\targs = args.map(arg => `${arg}`);\n\t\t\t}\n\t\t\tif (args.findIndex(arg => /\\basync\\b/.test(arg)) === -1) return args;\n\t\t\tconst asyncMapped = args.map(arg => arg.replace(/async/g, 'a\\\\u0073ync'));\n\t\t\ttry {\n\t\t\t\t// Note: funcConstructor is a Sandbox object, however, asyncMapped are only strings.\n\t\t\t\tfuncConstructor(...asyncMapped);\n\t\t\t} catch (u) {\n\t\t\t\t// u is a sandbox object\n\t\t\t\t// Some random syntax error or error because of async.\n\n\t\t\t\t// First report real syntax errors\n\t\t\t\ttry {\n\t\t\t\t\t// Note: funcConstructor is a Sandbox object, however, args are only strings.\n\t\t\t\t\tfuncConstructor(...args);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tthrow internal.Decontextify.value(e);\n\t\t\t\t}\n\t\t\t\t// Then async error\n\t\t\t\tthrow new VMError('Async not available');\n\t\t\t}\n\t\t\treturn args;\n\t\t}\n\t\tthrow new VMError('Async not available');\n\t};\n}\n\n/**\n * Class VM.\n *\n * @public\n */\nclass VM extends EventEmitter {\n\n\t/**\n\t * The timeout for {@link VM#run} calls.\n\t *\n\t * @public\n\t * @since v3.9.0\n\t * @member {number} timeout\n\t * @memberOf VM#\n\t */\n\n\t/**\n\t * Get the global sandbox object.\n\t *\n\t * @public\n\t * @readonly\n\t * @since v3.9.0\n\t * @member {Object} sandbox\n\t * @memberOf VM#\n\t */\n\n\t/**\n\t * The compiler to use to get the JavaScript code.\n\t * \n\t * @public\n\t * @readonly\n\t * @since v3.9.0\n\t * @member {(string|compileCallback)} compiler\n\t * @memberOf VM#\n\t */\n\n\t/**\n\t * The context for this sandbox.\n\t * \n\t * @private\n\t * @readonly\n\t * @member {Object} _context\n\t * @memberOf VM#\n\t */\n\n\t/**\n\t * The internal methods for this sandbox.\n\t * \n\t * @private\n\t * @readonly\n\t * @member {{Contextify: Object, Decontextify: Object, Buffer: Object, sandbox:Object}} _internal\n\t * @memberOf VM#\n\t */\n\n\t/**\n\t * The resolved compiler to use to get the JavaScript code.\n\t * \n\t * @private\n\t * @readonly\n\t * @member {compileCallback} _compiler\n\t * @memberOf VM#\n\t */\n\n\t/**\n\t * The hook called when some events occurs.\n\t * \n\t * @private\n\t * @readonly\n\t * @since v3.9.2\n\t * @member {Function} _hook\n\t * @memberOf VM#\n\t */\n\n\t/**\n\t * Create a new VM instance.\n\t *\n\t * @public\n\t * @param {Object} [options] - VM options.\n\t * @param {number} [options.timeout] - The amount of time until a call to {@link VM#run} will timeout.\n\t * @param {Object} [options.sandbox] - Objects that will be copied into the global object of the sandbox.\n\t * @param {(string|compileCallback)} [options.compiler=\"javascript\"] - The compiler to use.\n\t * @param {boolean} [options.eval=true] - Allow the dynamic evaluation of code via eval(code) or Function(code)().<br>\n\t * Only available for node v10+.\n\t * @param {boolean} [options.wasm=true] - Allow to run wasm code.<br>\n\t * Only available for node v10+.\n\t * @param {boolean} [options.fixAsync=false] - Filters for async functions.\n\t * @throws {VMError} If the compiler is unknown.\n\t */\n\tconstructor(options = {}) {\n\t\tsuper();\n\n\t\t// Read all options\n\t\tconst {\n\t\t\ttimeout,\n\t\t\tsandbox,\n\t\t\tcompiler = 'javascript'\n\t\t} = options;\n\t\tconst allowEval = options.eval !== false;\n\t\tconst allowWasm = options.wasm !== false;\n\t\tconst fixAsync = !!options.fixAsync;\n\n\t\t// Early error if sandbox is not an object.\n\t\tif (sandbox && 'object' !== typeof sandbox) {\n\t\t\tthrow new VMError('Sandbox must be object.');\n\t\t}\n\n\t\t// Early error if compiler can't be found.\n\t\tconst resolvedCompiler = lookupCompiler(compiler);\n\n\t\t// Create a new context for this vm.\n\t\tconst _context = vm.createContext(undefined, {\n\t\t\tcodeGeneration: {\n\t\t\t\tstrings: allowEval,\n\t\t\t\twasm: allowWasm\n\t\t\t}\n\t\t});\n\n\t\t// Create the bridge between the host and the sandbox.\n\t\tconst _internal = CACHE.contextifyScript.runInContext(_context, DEFAULT_RUN_OPTIONS).call(_context, require, HOST);\n\n\t\tconst hook = fixAsync ? makeCheckAsync(_internal) : null;\n\n\t\t// Define the properties of this object.\n\t\t// Use Object.defineProperties here to be able to\n\t\t// hide and set properties write only.\n\t\tObject.defineProperties(this, {\n\t\t\ttimeout: {\n\t\t\t\tvalue: timeout,\n\t\t\t\twritable: true,\n\t\t\t\tenumerable: true\n\t\t\t},\n\t\t\tcompiler: {\n\t\t\t\tvalue: compiler,\n\t\t\t\tenumerable: true\n\t\t\t},\n\t\t\tsandbox: {\n\t\t\t\tvalue: _internal.sandbox,\n\t\t\t\tenumerable: true\n\t\t\t},\n\t\t\t_context: {value: _context},\n\t\t\t_internal: {value: _internal},\n\t\t\t_compiler: {value: resolvedCompiler},\n\t\t\t_hook: {value: hook}\n\t\t});\n\n\t\tif (hook) {\n\t\t\tif (!CACHE.hookScript) {\n\t\t\t\tCACHE.hookScript = loadAndCompileScript(`${__dirname}/fixasync.js`, '(function() { ', '\\n})');\n\t\t\t\tCACHE.getGlobalScript = new vm.Script('this', {\n\t\t\t\t\tfilename: 'get_global.js',\n\t\t\t\t\tdisplayErrors: false,\n\t\t\t\t\timportModuleDynamically\n\t\t\t\t});\n\t\t\t\ttry {\n\t\t\t\t\tCACHE.getGeneratorFunctionScript = new vm.Script('(function*(){}).constructor', {\n\t\t\t\t\t\tfilename: 'get_generator_function.js',\n\t\t\t\t\t\tdisplayErrors: false,\n\t\t\t\t\t\timportModuleDynamically\n\t\t\t\t\t});\n\t\t\t\t} catch (ex) {}\n\t\t\t\ttry {\n\t\t\t\t\tCACHE.getAsyncFunctionScript = new vm.Script('(async function(){}).constructor', {\n\t\t\t\t\t\tfilename: 'get_async_function.js',\n\t\t\t\t\t\tdisplayErrors: false,\n\t\t\t\t\t\timportModuleDynamically\n\t\t\t\t\t});\n\t\t\t\t} catch (ex) {}\n\t\t\t\ttry {\n\t\t\t\t\tCACHE.getAsyncGeneratorFunctionScript = new vm.Script('(async function*(){}).constructor', {\n\t\t\t\t\t\tfilename: 'get_async_generator_function.js',\n\t\t\t\t\t\tdisplayErrors: false,\n\t\t\t\t\t\timportModuleDynamically\n\t\t\t\t\t});\n\t\t\t\t} catch (ex) {}\n\t\t\t}\n\t\t\tconst internal = {\n\t\t\t\t__proto__: null,\n\t\t\t\tglobal: CACHE.getGlobalScript.runInContext(_context, DEFAULT_RUN_OPTIONS),\n\t\t\t\tinternal: _internal,\n\t\t\t\thost: HOST,\n\t\t\t\thook\n\t\t\t};\n\t\t\tif (CACHE.getGeneratorFunctionScript) {\n\t\t\t\ttry {\n\t\t\t\t\tinternal.GeneratorFunction = CACHE.getGeneratorFunctionScript.runInContext(_context, DEFAULT_RUN_OPTIONS);\n\t\t\t\t} catch (ex) {}\n\t\t\t}\n\t\t\tif (CACHE.getAsyncFunctionScript) {\n\t\t\t\ttry {\n\t\t\t\t\tinternal.AsyncFunction = CACHE.getAsyncFunctionScript.runInContext(_context, DEFAULT_RUN_OPTIONS);\n\t\t\t\t} catch (ex) {}\n\t\t\t}\n\t\t\tif (CACHE.getAsyncGeneratorFunctionScript) {\n\t\t\t\ttry {\n\t\t\t\t\tinternal.AsyncGeneratorFunction = CACHE.getAsyncGeneratorFunctionScript.runInContext(_context, DEFAULT_RUN_OPTIONS);\n\t\t\t\t} catch (ex) {}\n\t\t\t}\n\t\t\tCACHE.hookScript.runInContext(_context, DEFAULT_RUN_OPTIONS).call(internal);\n\t\t}\n\n\t\t// prepare global sandbox\n\t\tif (sandbox) {\n\t\t\tthis.setGlobals(sandbox);\n\t\t}\n\t}\n\n\t/**\n\t * Adds all the values to the globals.\n\t * \n\t * @public\n\t * @since v3.9.0\n\t * @param {Object} values - All values that will be added to the globals.\n\t * @return {this} This for chaining.\n\t * @throws {*} If the setter of a global throws an exception it is propagated. And the remaining globals will not be written.\n\t */\n\tsetGlobals(values) {\n\t\tfor (const name in values) {\n\t\t\tif (Object.prototype.hasOwnProperty.call(values, name)) {\n\t\t\t\tthis._internal.Contextify.setGlobal(name, values[name]);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set a global value.\n\t * \n\t * @public\n\t * @since v3.9.0\n\t * @param {string} name - The name of the global.\n\t * @param {*} value - The value of the global.\n\t * @return {this} This for chaining.\n\t * @throws {*} If the setter of the global throws an exception it is propagated.\n\t */\n\tsetGlobal(name, value) {\n\t\tthis._internal.Contextify.setGlobal(name, value);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get a global value.\n\t * \n\t * @public\n\t * @since v3.9.0\n\t * @param {string} name - The name of the global.\n\t * @return {*} The value of the global.\n\t * @throws {*} If the getter of the global throws an exception it is propagated.\n\t */\n\tgetGlobal(name) {\n\t\treturn this._internal.Contextify.getGlobal(name);\n\t}\n\n\t/**\n\t * Freezes the object inside VM making it read-only. Not available for primitive values.\n\t *\n\t * @public\n\t * @param {*} value - Object to freeze.\n\t * @param {string} [globalName] - Whether to add the object to global.\n\t * @return {*} Object to freeze.\n\t * @throws {*} If the setter of the global throws an exception it is propagated.\n\t */\n\tfreeze(value, globalName) {\n\t\tthis._internal.Contextify.readonly(value);\n\t\tif (globalName) this._internal.Contextify.setGlobal(globalName, value);\n\t\treturn value;\n\t}\n\n\t/**\n\t * Protects the object inside VM making impossible to set functions as it's properties. Not available for primitive values.\n\t *\n\t * @public\n\t * @param {*} value - Object to protect.\n\t * @param {string} [globalName] - Whether to add the object to global.\n\t * @return {*} Object to protect.\n\t * @throws {*} If the setter of the global throws an exception it is propagated.\n\t */\n\tprotect(value, globalName) {\n\t\tthis._internal.Contextify.protected(value);\n\t\tif (globalName) this._internal.Contextify.setGlobal(globalName, value);\n\t\treturn value;\n\t}\n\n\t/**\n\t * Run the code in VM.\n\t *\n\t * @public\n\t * @param {(string|VMScript)} code - Code to run.\n\t * @param {string} [filename=\"vm.js\"] - Filename that shows up in any stack traces produced from this script.<br>\n\t * This is only used if code is a String.\n\t * @return {*} Result of executed code.\n\t * @throws {SyntaxError} If there is a syntax error in the script.\n\t * @throws {Error} An error is thrown when the script took to long and there is a timeout.\n\t * @throws {*} If the script execution terminated with an exception it is propagated.\n\t */\n\trun(code, filename) {\n\t\tlet script;\n\t\tif (code instanceof VMScript) {\n\t\t\tif (this._hook) {\n\t\t\t\tconst scriptCode = code.getCompiledCode();\n\t\t\t\tconst changed = this._hook('run', [scriptCode])[0];\n\t\t\t\tif (changed === scriptCode) {\n\t\t\t\t\tscript = code._compileVM();\n\t\t\t\t} else {\n\t\t\t\t\tscript = new vm.Script(changed, {\n\t\t\t\t\t\tfilename: code.filename,\n\t\t\t\t\t\tdisplayErrors: false,\n\t\t\t\t\t\timportModuleDynamically\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tscript = code._compileVM();\n\t\t\t}\n\t\t} else {\n\t\t\tconst useFileName = filename || 'vm.js';\n\t\t\tlet scriptCode = this._compiler(code, useFileName);\n\t\t\tif (this._hook) {\n\t\t\t\tscriptCode = this._hook('run', [scriptCode])[0];\n\t\t\t}\n\t\t\t// Compile the script here so that we don't need to create a instance of VMScript.\n\t\t\tscript = new vm.Script(scriptCode, {\n\t\t\t\tfilename: useFileName,\n\t\t\t\tdisplayErrors: false,\n\t\t\t\timportModuleDynamically\n\t\t\t});\n\t\t}\n\n\t\tif (!this.timeout) {\n\t\t\t// If no timeout is given, directly run the script.\n\t\t\ttry {\n\t\t\t\treturn this._internal.Decontextify.value(script.runInContext(this._context, DEFAULT_RUN_OPTIONS));\n\t\t\t} catch (e) {\n\t\t\t\tthrow this._internal.Decontextify.value(e);\n\t\t\t}\n\t\t}\n\n\t\treturn doWithTimeout(()=>{\n\t\t\ttry {\n\t\t\t\treturn this._internal.Decontextify.value(script.runInContext(this._context, DEFAULT_RUN_OPTIONS));\n\t\t\t} catch (e) {\n\t\t\t\tthrow this._internal.Decontextify.value(e);\n\t\t\t}\n\t\t}, this.timeout);\n\t}\n\n\t/**\n\t * Run the code in VM.\n\t *\n\t * @public\n\t * @since v3.9.0\n\t * @param {string} filename - Filename of file to load and execute in a NodeVM.\n\t * @return {*} Result of executed code.\n\t * @throws {Error} If filename is not a valid filename.\n\t * @throws {SyntaxError} If there is a syntax error in the script.\n\t * @throws {Error} An error is thrown when the script took to long and there is a timeout.\n\t * @throws {*} If the script execution terminated with an exception it is propagated.\n\t */\n\trunFile(filename) {\n\t\tconst resolvedFilename = pa.resolve(filename);\n\n\t\tif (!fs.existsSync(resolvedFilename)) {\n\t\t\tthrow new VMError(`Script '${filename}' not found.`);\n\t\t}\n\n\t\tif (fs.statSync(resolvedFilename).isDirectory()) {\n\t\t\tthrow new VMError('Script must be file, got directory.');\n\t\t}\n\n\t\treturn this.run(fs.readFileSync(resolvedFilename, 'utf8'), resolvedFilename);\n\t}\n\n}\n\n/**\n * Event caused by a <code>console.debug</code> call if <code>options.console=\"redirect\"</code> is specified.\n *\n * @public\n * @event NodeVM.\"console.debug\"\n * @type {...*}\n */\n\n/**\n * Event caused by a <code>console.log</code> call if <code>options.console=\"redirect\"</code> is specified.\n *\n * @public\n * @event NodeVM.\"console.log\"\n * @type {...*}\n */\n\n/**\n * Event caused by a <code>console.info</code> call if <code>options.console=\"redirect\"</code> is specified.\n *\n * @public\n * @event NodeVM.\"console.info\"\n * @type {...*}\n */\n\n/**\n * Event caused by a <code>console.warn</code> call if <code>options.console=\"redirect\"</code> is specified.\n *\n * @public\n * @event NodeVM.\"console.warn\"\n * @type {...*}\n */\n\n/**\n * Event caused by a <code>console.error</code> call if <code>options.console=\"redirect\"</code> is specified.\n *\n * @public\n * @event NodeVM.\"console.error\"\n * @type {...*}\n */\n\n/**\n * Event caused by a <code>console.dir</code> call if <code>options.console=\"redirect\"</code> is specified.\n *\n * @public\n * @event NodeVM.\"console.dir\"\n * @type {...*}\n */\n\n/**\n * Event caused by a <code>console.trace</code> call if <code>options.console=\"redirect\"</code> is specified.\n *\n * @public\n * @event NodeVM.\"console.trace\"\n * @type {...*}\n */\n\n/**\n * Class NodeVM.\n *\n * @public\n * @extends {VM}\n * @extends {EventEmitter}\n */\nclass NodeVM extends VM {\n\n\t/**\n\t * Create a new NodeVM instance.<br>\n\t *\n\t * Unlike VM, NodeVM lets you use require same way like in regular node.<br>\n\t * \n\t * However, it does not use the timeout.\n\t *\n\t * @public\n\t * @param {Object} [options] - VM options.\n\t * @param {Object} [options.sandbox] - Objects that will be copied into the global object of the sandbox.\n\t * @param {(string|compileCallback)} [options.compiler=\"javascript\"] - The compiler to use.\n\t * @param {boolean} [options.eval=true] - Allow the dynamic evaluation of code via eval(code) or Function(code)().<br>\n\t * Only available for node v10+.\n\t * @param {boolean} [options.wasm=true] - Allow to run wasm code.<br>\n\t * Only available for node v10+.\n\t * @param {(\"inherit\"|\"redirect\"|\"off\")} [options.console=\"inherit\"] - Sets the behavior of the console in the sandbox.\n\t * <code>inherit</code> to enable console, <code>redirect</code> to redirect to events, <code>off</code> to disable console.\n\t * @param {Object|boolean} [options.require=false] - Allow require inside the sandbox.\n\t * @param {(boolean|string[]|Object)} [options.require.external=false] - true, an array of allowed external modules or an object.\n\t * @param {(string[])} [options.require.external.modules] - Array of allowed external modules. Also supports wildcards, so specifying ['@scope/*-ver-??], \n\t * for instance, will allow using all modules having a name of the form @scope/something-ver-aa, @scope/other-ver-11, etc.\n\t * @param {boolean} [options.require.external.transitive=false] - Boolean which indicates if transitive dependencies of external modules are allowed.\n\t * @param {string[]} [options.require.builtin=[]] - Array of allowed builtin modules, accepts [\"*\"] for all.\n\t * @param {(string|string[])} [options.require.root] - Restricted path(s) where local modules can be required. If omitted every path is allowed.\n\t * @param {Object} [options.require.mock] - Collection of mock modules (both external or builtin).\n\t * @param {(\"host\"|\"sandbox\")} [options.require.context=\"host\"] - <code>host</code> to require modules in host and proxy them to sandbox.\n\t * <code>sandbox</code> to load, compile and require modules in sandbox.\n\t * Builtin modules except <code>events</code> always required in host and proxied to sandbox.\n\t * @param {string[]} [options.require.import] - Array of modules to be loaded into NodeVM on start.\n\t * @param {resolveCallback} [options.require.resolve] - An additional lookup function in case a module wasn't\n\t * found in one of the traditional node lookup paths.\n\t * @param {boolean} [options.nesting=false] - Allow nesting of VMs.\n\t * @param {(\"commonjs\"|\"none\")} [options.wrapper=\"commonjs\"] - <code>commonjs</code> to wrap script into CommonJS wrapper, \n\t * <code>none</code> to retrieve value returned by the script.\n\t * @param {string[]} [options.sourceExtensions=[\"js\"]] - Array of file extensions to treat as source code.\n\t * @param {string[]} [options.argv=[]] - Array of arguments passed to <code>process.argv</code>. \n\t * This object will not be copied and the script can change this object.\n\t * @param {Object} [options.env={}] - Environment map passed to <code>process.env</code>. \n\t * This object will not be copied and the script can change this object.\n\t * @param {boolean} [options.strict=false] - If modules should be loaded in strict mode.\n\t * @throws {VMError} If the compiler is unknown.\n\t */\n\tconstructor(options = {}) {\n\t\tconst sandbox = options.sandbox;\n\n\t\t// Throw this early\n\t\tif (sandbox && 'object' !== typeof sandbox) {\n\t\t\tthrow new VMError('Sandbox must be object.');\n\t\t}\n\n\t\tsuper({compiler: options.compiler, eval: options.eval, wasm: options.wasm});\n\n\t\t// defaults\n\t\tObject.defineProperty(this, 'options', {value: {\n\t\t\tconsole: options.console || 'inherit',\n\t\t\trequire: options.require || false,\n\t\t\tnesting: options.nesting || false,\n\t\t\twrapper: options.wrapper || 'commonjs',\n\t\t\tsourceExtensions: options.sourceExtensions || ['js'],\n\t\t\tstrict: options.strict || false\n\t\t}});\n\n\t\tlet sandboxScript = CACHE.sandboxScript;\n\t\tif (!sandboxScript) {\n\t\t\tCACHE.sandboxScript = sandboxScript = loadAndCompileScript(`${__dirname}/sandbox.js`,\n\t\t\t\t'(function (vm, host, Contextify, Decontextify, Buffer, options) { ', '\\n})');\n\t\t}\n\n\t\tconst closure = sandboxScript.runInContext(this._context, DEFAULT_RUN_OPTIONS);\n\n\t\tObject.defineProperty(this, '_prepareRequire', {\n\t\t\tvalue: closure.call(this._context, this, HOST, this._internal.Contextify, this._internal.Decontextify, this._internal.Buffer, options)\n\t\t});\n\n\t\t// prepare global sandbox\n\t\tif (sandbox) {\n\t\t\tthis.setGlobals(sandbox);\n\t\t}\n\n\t\tif (this.options.require && this.options.require.import) {\n\t\t\tif (Array.isArray(this.options.require.import)) {\n\t\t\t\tfor (let i = 0, l = this.options.require.import.length; i < l; i++) {\n\t\t\t\t\tthis.require(this.options.require.import[i]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.require(this.options.require.import);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @ignore\n\t * @deprecated Just call the method yourself like <code>method(args);</code>\n\t * @param {function} method - Function to invoke.\n\t * @param {...*} args - Arguments to pass to the function.\n\t * @return {*} Return value of the function.\n\t * @todo Can we remove this function? It even had a bug that would use args as this parameter.\n\t * @throws {*} Rethrows anything the method throws.\n\t * @throws {VMError} If method is not a function.\n\t * @throws {Error} If method is a class.\n\t */\n\tcall(method, ...args) {\n\t\tif ('function' === typeof method) {\n\t\t\treturn method(...args);\n\t\t} else {\n\t\t\tthrow new VMError('Unrecognized method type.');\n\t\t}\n\t}\n\n\t/**\n\t * Require a module in VM and return it's exports.\n\t *\n\t * @public\n\t * @param {string} module - Module name.\n\t * @return {*} Exported module.\n\t * @throws {*} If the module couldn't be found or loading it threw an error.\n\t */\n\trequire(module) {\n\t\treturn this.run(`module.exports = require('${module}');`, 'vm.js');\n\t}\n\n\t/**\n\t * Run the code in NodeVM.\n\t *\n\t * First time you run this method, code is executed same way like in node's regular `require` - it's executed with\n\t * `module`, `require`, `exports`, `__dirname`, `__filename` variables and expect result in `module.exports'.\n\t *\n\t * @param {(string|VMScript)} code - Code to run.\n\t * @param {string} [filename] - Filename that shows up in any stack traces produced from this script.<br>\n\t * This is only used if code is a String.\n\t * @return {*} Result of executed code.\n\t * @throws {SyntaxError} If there is a syntax error in the script.\n\t * @throws {*} If the script execution terminated with an exception it is propagated.\n\t * @fires NodeVM.\"console.debug\"\n\t * @fires NodeVM.\"console.log\"\n\t * @fires NodeVM.\"console.info\"\n\t * @fires NodeVM.\"console.warn\"\n\t * @fires NodeVM.\"console.error\"\n\t * @fires NodeVM.\"console.dir\"\n\t * @fires NodeVM.\"console.trace\"\n\t */\n\trun(code, filename) {\n\t\tlet dirname;\n\t\tlet resolvedFilename;\n\t\tlet script;\n\n\t\tif (code instanceof VMScript) {\n\t\t\tscript = this.options.strict ? code._compileNodeVMStrict() : code._compileNodeVM();\n\t\t\tresolvedFilename = pa.resolve(code.filename);\n\t\t\tdirname = pa.dirname(resolvedFilename);\n\t\t} else {\n\t\t\tconst unresolvedFilename = filename || 'vm.js';\n\t\t\tif (filename) {\n\t\t\t\tresolvedFilename = pa.resolve(filename);\n\t\t\t\tdirname = pa.dirname(resolvedFilename);\n\t\t\t} else {\n\t\t\t\tresolvedFilename = null;\n\t\t\t\tdirname = null;\n\t\t\t}\n\t\t\tconst prefix = this.options.strict ? STRICT_MODULE_PREFIX : MODULE_PREFIX;\n\t\t\tscript = new vm.Script(prefix +\n\t\t\t\t\tthis._compiler(code, unresolvedFilename) + MODULE_SUFFIX, {\n\t\t\t\tfilename: unresolvedFilename,\n\t\t\t\tdisplayErrors: false,\n\t\t\t\timportModuleDynamically\n\t\t\t});\n\t\t}\n\n\t\tconst wrapper = this.options.wrapper;\n\t\tconst module = this._internal.Contextify.makeModule();\n\n\t\ttry {\n\t\t\tconst closure = script.runInContext(this._context, DEFAULT_RUN_OPTIONS);\n\n\t\t\tconst returned = closure.call(this._context, module.exports, this._prepareRequire(dirname), module, resolvedFilename, dirname);\n\n\t\t\treturn this._internal.Decontextify.value(wrapper === 'commonjs' ? module.exports : returned);\n\t\t} catch (e) {\n\t\t\tthrow this._internal.Decontextify.value(e);\n\t\t}\n\n\t}\n\n\t/**\n\t * Create NodeVM and run code inside it.\n\t *\n\t * @public\n\t * @static\n\t * @param {string} script - Code to execute.\n\t * @param {string} [filename] - File name (used in stack traces only).\n\t * @param {Object} [options] - VM options.\n\t * @param {string} [options.filename] - File name (used in stack traces only). Used if <code>filename</code> is omitted.\n\t * @return {*} Result of executed code.\n\t * @see {@link NodeVM} for the options.\n\t * @throws {SyntaxError} If there is a syntax error in the script.\n\t * @throws {*} If the script execution terminated with an exception it is propagated.\n\t */\n\tstatic code(script, filename, options) {\n\t\tlet unresolvedFilename;\n\t\tif (filename != null) {\n\t\t\tif ('object' === typeof filename) {\n\t\t\t\toptions = filename;\n\t\t\t\tunresolvedFilename = options.filename;\n\t\t\t} else if ('string' === typeof filename) {\n\t\t\t\tunresolvedFilename = filename;\n\t\t\t} else {\n\t\t\t\tthrow new VMError('Invalid arguments.');\n\t\t\t}\n\t\t} else if ('object' === typeof options) {\n\t\t\tunresolvedFilename = options.filename;\n\t\t}\n\n\t\tif (arguments.length > 3) {\n\t\t\tthrow new VMError('Invalid number of arguments.');\n\t\t}\n\n\t\tconst resolvedFilename = typeof unresolvedFilename === 'string' ? pa.resolve(unresolvedFilename) : undefined;\n\n\t\treturn new NodeVM(options).run(script, resolvedFilename);\n\t}\n\n\t/**\n\t * Create NodeVM and run script from file inside it.\n\t *\n\t * @public\n\t * @static\n\t * @param {string} filename - Filename of file to load and execute in a NodeVM.\n\t * @param {Object} [options] - NodeVM options.\n\t * @return {*} Result of executed code.\n\t * @see {@link NodeVM} for the options.\n\t * @throws {Error} If filename is not a valid filename.\n\t * @throws {SyntaxError} If there is a syntax error in the script.\n\t * @throws {*} If the script execution terminated with an exception it is propagated.\n\t */\n\tstatic file(filename, options) {\n\t\tconst resolvedFilename = pa.resolve(filename);\n\n\t\tif (!fs.existsSync(resolvedFilename)) {\n\t\t\tthrow new VMError(`Script '${filename}' not found.`);\n\t\t}\n\n\t\tif (fs.statSync(resolvedFilename).isDirectory()) {\n\t\t\tthrow new VMError('Script must be file, got directory.');\n\t\t}\n\n\t\treturn new NodeVM(options).run(fs.readFileSync(resolvedFilename, 'utf8'), resolvedFilename);\n\t}\n}\n\n/**\n * VMError.\n *\n * @public\n * @extends {Error}\n */\nclass VMError extends Error {\n\n\t/**\n\t * Create VMError instance.\n\t *\n\t * @public\n\t * @param {string} message - Error message.\n\t */\n\tconstructor(message) {\n\t\tsuper(message);\n\n\t\tthis.name = 'VMError';\n\n\t\tError.captureStackTrace(this, this.constructor);\n\t}\n}\n\n/**\n * Host objects\n * \n * @private\n */\nconst HOST = {\n\tversion: parseInt(process.versions.node.split('.')[0]),\n\trequire,\n\tprocess,\n\tconsole,\n\tsetTimeout,\n\tsetInterval,\n\tsetImmediate,\n\tclearTimeout,\n\tclearInterval,\n\tclearImmediate,\n\tString,\n\tNumber,\n\tBuffer,\n\tBoolean,\n\tArray,\n\tDate,\n\tError,\n\tEvalError,\n\tRangeError,\n\tReferenceError,\n\tSyntaxError,\n\tTypeError,\n\tURIError,\n\tRegExp,\n\tFunction,\n\tObject,\n\tVMError,\n\tProxy,\n\tReflect,\n\tMap,\n\tWeakMap,\n\tSet,\n\tWeakSet,\n\tPromise,\n\tSymbol,\n\tINSPECT_MAX_BYTES,\n\tVM,\n\tNodeVM,\n\thelpers,\n\tMODULE_PREFIX,\n\tSTRICT_MODULE_PREFIX,\n\tMODULE_SUFFIX\n};\n\nexports.VMError = VMError;\nexports.NodeVM = NodeVM;\nexports.VM = VM;\nexports.VMScript = VMScript;\n", "/* eslint-disable no-shadow, no-invalid-this */\n/* global vm, host, Contextify, Decontextify, VMError, options */\n\n'use strict';\n\nconst {Script} = host.require('vm');\nconst fs = host.require('fs');\nconst pa = host.require('path');\n\nconst BUILTIN_MODULES = host.process.binding('natives');\nconst parseJSON = JSON.parse;\nconst importModuleDynamically = () => {\n\t// We can't throw an error object here because since vm.Script doesn't store a context, we can't properly contextify that error object.\n\t// eslint-disable-next-line no-throw-literal\n\tthrow 'Dynamic imports are not allowed.';\n};\n\n/**\n * @param {Object} host Hosts's internal objects.\n */\n\nreturn ((vm, host) => {\n\t'use strict';\n\n\tconst global = this;\n\n\tconst TIMERS = new host.WeakMap(); // Contains map of timers created inside sandbox\n\tconst BUILTINS = {__proto__: null};\n\tconst CACHE = {__proto__: null};\n\tconst EXTENSIONS = {\n\t\t__proto__: null,\n\t\t['.json'](module, filename) {\n\t\t\ttry {\n\t\t\t\tconst code = fs.readFileSync(filename, 'utf8');\n\t\t\t\tmodule.exports = parseJSON(code);\n\t\t\t} catch (e) {\n\t\t\t\tthrow Contextify.value(e);\n\t\t\t}\n\t\t},\n\t\t['.node'](module, filename) {\n\t\t\tif (vm.options.require.context === 'sandbox') throw new VMError('Native modules can be required only with context set to \\'host\\'.');\n\n\t\t\ttry {\n\t\t\t\tmodule.exports = Contextify.readonly(host.require(filename));\n\t\t\t} catch (e) {\n\t\t\t\tthrow Contextify.value(e);\n\t\t\t}\n\t\t}\n\t};\n\n\tfor (let i = 0; i < vm.options.sourceExtensions.length; i++) {\n\t\tconst ext = vm.options.sourceExtensions[i];\n\n\t\tEXTENSIONS['.' + ext] = (module, filename, dirname) => {\n\t\t\tif (vm.options.require.context !== 'sandbox') {\n\t\t\t\ttry {\n\t\t\t\t\tmodule.exports = Contextify.readonly(host.require(filename));\n\t\t\t\t} catch (e) {\n\t\t\t\t\tthrow Contextify.value(e);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlet script;\n\n\t\t\t\ttry {\n\t\t\t\t\t// Load module\n\t\t\t\t\tlet contents = fs.readFileSync(filename, 'utf8');\n\t\t\t\t\tcontents = vm._compiler(contents, filename);\n\n\t\t\t\t\tconst code = host.STRICT_MODULE_PREFIX + contents + host.MODULE_SUFFIX;\n\n\t\t\t\t\t// Precompile script\n\t\t\t\t\tscript = new Script(code, {\n\t\t\t\t\t\t__proto__: null,\n\t\t\t\t\t\tfilename: filename || 'vm.js',\n\t\t\t\t\t\tdisplayErrors: false,\n\t\t\t\t\t\timportModuleDynamically\n\t\t\t\t\t});\n\n\t\t\t\t} catch (ex) {\n\t\t\t\t\tthrow Contextify.value(ex);\n\t\t\t\t}\n\n\t\t\t\tconst closure = script.runInContext(global, {\n\t\t\t\t\t__proto__: null,\n\t\t\t\t\tfilename: filename || 'vm.js',\n\t\t\t\t\tdisplayErrors: false,\n\t\t\t\t\timportModuleDynamically\n\t\t\t\t});\n\n\t\t\t\t// run the script\n\t\t\t\tclosure(module.exports, module.require, module, filename, dirname);\n\t\t\t}\n\t\t};\n\t}\n\n\tconst _parseExternalOptions = (options) => {\n\t\tif (host.Array.isArray(options)) {\n\t\t\treturn {\n\t\t\t\t__proto__: null,\n\t\t\t\texternal: options,\n\t\t\t\ttransitive: false\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\t__proto__: null,\n\t\t\texternal: options.modules,\n\t\t\ttransitive: options.transitive\n\t\t};\n\t};\n\n\t/**\n\t * Resolve filename.\n\t */\n\n\tconst _resolveFilename = (path) => {\n\t\tif (!path) return null;\n\t\tlet hasPackageJson;\n\t\ttry {\n\t\t\tpath = pa.resolve(path);\n\n\t\t\tconst exists = fs.existsSync(path);\n\t\t\tconst isdir = exists ? fs.statSync(path).isDirectory() : false;\n\n\t\t\t// direct file match\n\t\t\tif (exists && !isdir) return path;\n\n\t\t\t// load as file\n\n\t\t\tfor (let i = 0; i < vm.options.sourceExtensions.length; i++) {\n\t\t\t\tconst ext = vm.options.sourceExtensions[i];\n\t\t\t\tif (fs.existsSync(`${path}.${ext}`)) return `${path}.${ext}`;\n\t\t\t}\n\t\t\tif (fs.existsSync(`${path}.json`)) return `${path}.json`;\n\t\t\tif (fs.existsSync(`${path}.node`)) return `${path}.node`;\n\n\t\t\t// load as module\n\n\t\t\thasPackageJson = fs.existsSync(`${path}/package.json`);\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\n\t\tif (hasPackageJson) {\n\t\t\tlet pkg;\n\t\t\ttry {\n\t\t\t\tpkg = fs.readFileSync(`${path}/package.json`, 'utf8');\n\t\t\t} catch (e) {\n\t\t\t\tthrow Contextify.value(e);\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tpkg = parseJSON(pkg);\n\t\t\t} catch (ex) {\n\t\t\t\tthrow new VMError(`Module '${path}' has invalid package.json`, 'EMODULEINVALID');\n\t\t\t}\n\n\t\t\tlet main;\n\t\t\tif (pkg && pkg.main) {\n\t\t\t\tmain = _resolveFilename(`${path}/${pkg.main}`);\n\t\t\t\tif (!main) main = _resolveFilename(`${path}/index`);\n\t\t\t} else {\n\t\t\t\tmain = _resolveFilename(`${path}/index`);\n\t\t\t}\n\n\t\t\treturn main;\n\t\t}\n\n\t\t// load as directory\n\n\t\ttry {\n\t\t\tfor (let i = 0; i < vm.options.sourceExtensions.length; i++) {\n\t\t\t\tconst ext = vm.options.sourceExtensions[i];\n\t\t\t\tif (fs.existsSync(`${path}/index.${ext}`)) return `${path}/index.${ext}`;\n\t\t\t}\n\n\t\t\tif (fs.existsSync(`${path}/index.json`)) return `${path}/index.json`;\n\t\t\tif (fs.existsSync(`${path}/index.node`)) return `${path}/index.node`;\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\n\t\treturn null;\n\t};\n\n\t/**\n\t * Builtin require.\n\t */\n\n\tconst _requireBuiltin = (moduleName) => {\n\t\tif (moduleName === 'buffer') return ({Buffer});\n\t\tif (BUILTINS[moduleName]) return BUILTINS[moduleName].exports; // Only compiled builtins are stored here\n\n\t\tif (moduleName === 'util') {\n\t\t\treturn Contextify.readonly(host.require(moduleName), {\n\t\t\t\t// Allows VM context to use util.inherits\n\t\t\t\t__proto__: null,\n\t\t\t\tinherits: (ctor, superCtor) => {\n\t\t\t\t\tctor.super_ = superCtor;\n\t\t\t\t\tObject.setPrototypeOf(ctor.prototype, superCtor.prototype);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tif (moduleName === 'events' || moduleName === 'internal/errors') {\n\t\t\tlet script;\n\t\t\ttry {\n\t\t\t\tscript = new Script(`(function (exports, require, module, process, internalBinding) {\n\t\t\t\t\t\t'use strict';\n\t\t\t\t\t\tconst primordials = global;\n\t\t\t\t\t\t${BUILTIN_MODULES[moduleName]}\n\t\t\t\t\t\t\\n\n\t\t\t\t\t});`, {\n\t\t\t\t\tfilename: `${moduleName}.vm.js`\n\t\t\t\t});\n\n\t\t\t} catch (e) {\n\t\t\t\tthrow Contextify.value(e);\n\t\t\t}\n\n\t\t\t// setup module scope\n\t\t\tconst module = BUILTINS[moduleName] = {\n\t\t\t\texports: {},\n\t\t\t\trequire: _requireBuiltin\n\t\t\t};\n\n\t\t\t// run script\n\t\t\ttry {\n\t\t\t\t// FIXME binding should be contextified\n\t\t\t\tscript.runInContext(global)(module.exports, module.require, module, host.process, host.process.binding);\n\t\t\t} catch (e) {\n\t\t\t\t// e could be from inside or outside of sandbox\n\t\t\t\tthrow new VMError(`Error loading '${moduleName}'`);\n\t\t\t}\n\t\t\treturn module.exports;\n\t\t}\n\n\t\treturn Contextify.readonly(host.require(moduleName));\n\t};\n\n\t/**\n\t * Prepare require.\n\t */\n\n\tconst _prepareRequire = (currentDirname, parentAllowsTransitive = false) => {\n\t\tconst _require = moduleName => {\n\t\t\tlet requireObj;\n\t\t\ttry {\n\t\t\t\tconst optionsObj = vm.options;\n\t\t\t\tif (optionsObj.nesting && moduleName === 'vm2') return {VM: Contextify.readonly(host.VM), NodeVM: Contextify.readonly(host.NodeVM)};\n\t\t\t\trequireObj = optionsObj.require;\n\t\t\t} catch (e) {\n\t\t\t\tthrow Contextify.value(e);\n\t\t\t}\n\n\t\t\tif (!requireObj) throw new VMError(`Access denied to require '${moduleName}'`, 'EDENIED');\n\t\t\tif (moduleName == null) throw new VMError(\"Module '' not found.\", 'ENOTFOUND');\n\t\t\tif (typeof moduleName !== 'string') throw new VMError(`Invalid module name '${moduleName}'`, 'EINVALIDNAME');\n\n\t\t\tlet filename;\n\t\t\tlet allowRequireTransitive = false;\n\n\t\t\t// Mock?\n\n\t\t\ttry {\n\t\t\t\tconst {mock} = requireObj;\n\t\t\t\tif (mock) {\n\t\t\t\t\tconst mockModule = mock[moduleName];\n\t\t\t\t\tif (mockModule) {\n\t\t\t\t\t\treturn Contextify.readonly(mockModule);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tthrow Contextify.value(e);\n\t\t\t}\n\n\t\t\t// Builtin?\n\n\t\t\tif (BUILTIN_MODULES[moduleName]) {\n\t\t\t\tlet allowed;\n\t\t\t\ttry {\n\t\t\t\t\tconst builtinObj = requireObj.builtin;\n\t\t\t\t\tif (host.Array.isArray(builtinObj)) {\n\t\t\t\t\t\tif (builtinObj.indexOf('*') >= 0) {\n\t\t\t\t\t\t\tallowed = builtinObj.indexOf(`-${moduleName}`) === -1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tallowed = builtinObj.indexOf(moduleName) >= 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (builtinObj) {\n\t\t\t\t\t\tallowed = builtinObj[moduleName];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tallowed = false;\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {\n\t\t\t\t\tthrow Contextify.value(e);\n\t\t\t\t}\n\t\t\t\tif (!allowed) throw new VMError(`Access denied to require '${moduleName}'`, 'EDENIED');\n\n\t\t\t\treturn _requireBuiltin(moduleName);\n\t\t\t}\n\n\t\t\t// External?\n\n\t\t\tlet externalObj;\n\t\t\ttry {\n\t\t\t\texternalObj = requireObj.external;\n\t\t\t} catch (e) {\n\t\t\t\tthrow Contextify.value(e);\n\t\t\t}\n\n\t\t\tif (!externalObj) throw new VMError(`Access denied to require '${moduleName}'`, 'EDENIED');\n\n\t\t\tif (/^(\\.|\\.\\/|\\.\\.\\/)/.exec(moduleName)) {\n\t\t\t\t// Module is relative file, e.g. ./script.js or ../script.js\n\n\t\t\t\tif (!currentDirname) throw new VMError('You must specify script path to load relative modules.', 'ENOPATH');\n\n\t\t\t\tfilename = _resolveFilename(`${currentDirname}/${moduleName}`);\n\t\t\t} else if (/^(\\/|\\\\|[a-zA-Z]:\\\\)/.exec(moduleName)) {\n\t\t\t\t// Module is absolute file, e.g. /script.js or //server/script.js or C:\\script.js\n\n\t\t\t\tfilename = _resolveFilename(moduleName);\n\t\t\t} else {\n\t\t\t\t// Check node_modules in path\n\n\t\t\t\tif (!currentDirname) throw new VMError('You must specify script path to load relative modules.', 'ENOPATH');\n\n\t\t\t\tif (typeof externalObj === 'object') {\n\t\t\t\t\tlet isWhitelisted;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst { external, transitive } = _parseExternalOptions(externalObj);\n\n\t\t\t\t\t\tisWhitelisted = external.some(ext => host.helpers.match(ext, moduleName)) || (transitive && parentAllowsTransitive);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tthrow Contextify.value(e);\n\t\t\t\t\t}\n\t\t\t\t\tif (!isWhitelisted) {\n\t\t\t\t\t\tthrow new VMError(`The module '${moduleName}' is not whitelisted in VM.`, 'EDENIED');\n\t\t\t\t\t}\n\n\t\t\t\t\tallowRequireTransitive = true;\n\t\t\t\t}\n\n\t\t\t\t// FIXME the paths array has side effects\n\t\t\t\tconst paths = currentDirname.split(pa.sep);\n\n\t\t\t\twhile (paths.length) {\n\t\t\t\t\tconst path = paths.join(pa.sep);\n\n\t\t\t\t\t// console.log moduleName, \"#{path}#{pa.sep}node_modules#{pa.sep}#{moduleName}\"\n\n\t\t\t\t\tfilename = _resolveFilename(`${path}${pa.sep}node_modules${pa.sep}${moduleName}`);\n\t\t\t\t\tif (filename) break;\n\n\t\t\t\t\tpaths.pop();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!filename) {\n\t\t\t\tlet resolveFunc;\n\t\t\t\ttry {\n\t\t\t\t\tresolveFunc = requireObj.resolve;\n\t\t\t\t} catch (e) {\n\t\t\t\t\tthrow Contextify.value(e);\n\t\t\t\t}\n\t\t\t\tif (resolveFunc) {\n\t\t\t\t\tlet resolved;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tresolved = requireObj.resolve(moduleName, currentDirname);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tthrow Contextify.value(e);\n\t\t\t\t\t}\n\t\t\t\t\tfilename = _resolveFilename(resolved);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!filename) throw new VMError(`Cannot find module '${moduleName}'`, 'ENOTFOUND');\n\n\t\t\t// return cache whenever possible\n\t\t\tif (CACHE[filename]) return CACHE[filename].exports;\n\n\t\t\tconst dirname = pa.dirname(filename);\n\t\t\tconst extname = pa.extname(filename);\n\n\t\t\tlet allowedModule = true;\n\t\t\ttry {\n\t\t\t\tconst rootObj = requireObj.root;\n\t\t\t\tif (rootObj) {\n\t\t\t\t\tconst rootPaths = host.Array.isArray(rootObj) ? rootObj : host.Array.of(rootObj);\n\t\t\t\t\tallowedModule = rootPaths.some(path => host.String.prototype.startsWith.call(dirname, pa.resolve(path)));\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tthrow Contextify.value(e);\n\t\t\t}\n\n\t\t\tif (!allowedModule) {\n\t\t\t\tthrow new VMError(`Module '${moduleName}' is not allowed to be required. The path is outside the border!`, 'EDENIED');\n\t\t\t}\n\n\t\t\tconst module = CACHE[filename] = {\n\t\t\t\tfilename,\n\t\t\t\texports: {},\n\t\t\t\trequire: _prepareRequire(dirname, allowRequireTransitive)\n\t\t\t};\n\n\t\t\t// lookup extensions\n\t\t\tif (EXTENSIONS[extname]) {\n\t\t\t\tEXTENSIONS[extname](module, filename, dirname);\n\t\t\t\treturn module.exports;\n\t\t\t}\n\n\t\t\tthrow new VMError(`Failed to load '${moduleName}': Unknown type.`, 'ELOADFAIL');\n\t\t};\n\n\t\treturn _require;\n\t};\n\n\t/**\n\t * Prepare sandbox.\n\t */\n\n\t// This is a function and not an arrow function, since the original is also a function\n\tglobal.setTimeout = function setTimeout(callback, delay, ...args) {\n\t\tif (typeof callback !== 'function') throw new TypeError('\"callback\" argument must be a function');\n\t\tlet tmr;\n\t\ttry {\n\t\t\ttmr = host.setTimeout(Decontextify.value(() => {\n\t\t\t\t// FIXME ...args has side effects\n\t\t\t\tcallback(...args);\n\t\t\t}), Decontextify.value(delay));\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\t\tconst local = Contextify.value(tmr);\n\n\t\tTIMERS.set(local, tmr);\n\t\treturn local;\n\t};\n\n\tglobal.setInterval = function setInterval(callback, interval, ...args) {\n\t\tif (typeof callback !== 'function') throw new TypeError('\"callback\" argument must be a function');\n\t\tlet tmr;\n\t\ttry {\n\t\t\ttmr = host.setInterval(Decontextify.value(() => {\n\t\t\t\t// FIXME ...args has side effects\n\t\t\t\tcallback(...args);\n\t\t\t}), Decontextify.value(interval));\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\n\t\tconst local = Contextify.value(tmr);\n\n\t\tTIMERS.set(local, tmr);\n\t\treturn local;\n\t};\n\n\tglobal.setImmediate = function setImmediate(callback, ...args) {\n\t\tif (typeof callback !== 'function') throw new TypeError('\"callback\" argument must be a function');\n\t\tlet tmr;\n\t\ttry {\n\t\t\ttmr = host.setImmediate(Decontextify.value(() => {\n\t\t\t\t// FIXME ...args has side effects\n\t\t\t\tcallback(...args);\n\t\t\t}));\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\n\t\tconst local = Contextify.value(tmr);\n\n\t\tTIMERS.set(local, tmr);\n\t\treturn local;\n\t};\n\n\tglobal.clearTimeout = function clearTimeout(local) {\n\t\ttry {\n\t\t\thost.clearTimeout(TIMERS.get(local));\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\t};\n\n\tglobal.clearInterval = function clearInterval(local) {\n\t\ttry {\n\t\t\thost.clearInterval(TIMERS.get(local));\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\t};\n\n\tglobal.clearImmediate = function clearImmediate(local) {\n\t\ttry {\n\t\t\thost.clearImmediate(TIMERS.get(local));\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\t};\n\n\tfunction addListener(name, handler) {\n\t\tif (name !== 'beforeExit' && name !== 'exit') {\n\t\t\tthrow new Error(`Access denied to listen for '${name}' event.`);\n\t\t}\n\n\t\ttry {\n\t\t\thost.process.on(name, Decontextify.value(handler));\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tconst {argv: optionArgv, env: optionsEnv} = options;\n\n\t// FIXME wrong class structure\n\tglobal.process = {\n\t\targv: optionArgv !== undefined ? Contextify.value(optionArgv) : [],\n\t\ttitle: host.process.title,\n\t\tversion: host.process.version,\n\t\tversions: Contextify.readonly(host.process.versions),\n\t\tarch: host.process.arch,\n\t\tplatform: host.process.platform,\n\t\tenv: optionsEnv !== undefined ? Contextify.value(optionsEnv) : {},\n\t\tpid: host.process.pid,\n\t\tfeatures: Contextify.readonly(host.process.features),\n\t\tnextTick: function nextTick(callback, ...args) {\n\t\t\tif (typeof callback !== 'function') {\n\t\t\t\tthrow new Error('Callback must be a function.');\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\thost.process.nextTick(Decontextify.value(() => {\n\t\t\t\t\t// FIXME ...args has side effects\n\t\t\t\t\tcallback(...args);\n\t\t\t\t}));\n\t\t\t} catch (e) {\n\t\t\t\tthrow Contextify.value(e);\n\t\t\t}\n\t\t},\n\t\thrtime: function hrtime(time) {\n\t\t\ttry {\n\t\t\t\treturn Contextify.value(host.process.hrtime(Decontextify.value(time)));\n\t\t\t} catch (e) {\n\t\t\t\tthrow Contextify.value(e);\n\t\t\t}\n\t\t},\n\t\tcwd: function cwd() {\n\t\t\ttry {\n\t\t\t\treturn Contextify.value(host.process.cwd());\n\t\t\t} catch (e) {\n\t\t\t\tthrow Contextify.value(e);\n\t\t\t}\n\t\t},\n\t\taddListener,\n\t\ton: addListener,\n\n\t\tonce: function once(name, handler) {\n\t\t\tif (name !== 'beforeExit' && name !== 'exit') {\n\t\t\t\tthrow new Error(`Access denied to listen for '${name}' event.`);\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\thost.process.once(name, Decontextify.value(handler));\n\t\t\t} catch (e) {\n\t\t\t\tthrow Contextify.value(e);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\n\t\tlisteners: function listeners(name) {\n\t\t\tif (name !== 'beforeExit' && name !== 'exit') {\n\t\t\t\t// Maybe add ({__proto__:null})[name] to throw when name fails in https://tc39.es/ecma262/#sec-topropertykey.\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\t// Filter out listeners, which were not created in this sandbox\n\t\t\ttry {\n\t\t\t\treturn Contextify.value(host.process.listeners(name).filter(listener => Contextify.isVMProxy(listener)));\n\t\t\t} catch (e) {\n\t\t\t\tthrow Contextify.value(e);\n\t\t\t}\n\t\t},\n\n\t\tremoveListener: function removeListener(name, handler) {\n\t\t\tif (name !== 'beforeExit' && name !== 'exit') {\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\thost.process.removeListener(name, Decontextify.value(handler));\n\t\t\t} catch (e) {\n\t\t\t\tthrow Contextify.value(e);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\n\t\tumask: function umask() {\n\t\t\tif (arguments.length) {\n\t\t\t\tthrow new Error('Access denied to set umask.');\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\treturn Contextify.value(host.process.umask());\n\t\t\t} catch (e) {\n\t\t\t\tthrow Contextify.value(e);\n\t\t\t}\n\t\t}\n\t};\n\n\tif (vm.options.console === 'inherit') {\n\t\tglobal.console = Contextify.readonly(host.console);\n\t} else if (vm.options.console === 'redirect') {\n\t\tglobal.console = {\n\t\t\tdebug(...args) {\n\t\t\t\ttry {\n\t\t\t\t\t// FIXME ...args has side effects\n\t\t\t\t\tvm.emit('console.debug', ...Decontextify.arguments(args));\n\t\t\t\t} catch (e) {\n\t\t\t\t\tthrow Contextify.value(e);\n\t\t\t\t}\n\t\t\t},\n\t\t\tlog(...args) {\n\t\t\t\ttry {\n\t\t\t\t\t// FIXME ...args has side effects\n\t\t\t\t\tvm.emit('console.log', ...Decontextify.arguments(args));\n\t\t\t\t} catch (e) {\n\t\t\t\t\tthrow Contextify.value(e);\n\t\t\t\t}\n\t\t\t},\n\t\t\tinfo(...args) {\n\t\t\t\ttry {\n\t\t\t\t\t// FIXME ...args has side effects\n\t\t\t\t\tvm.emit('console.info', ...Decontextify.arguments(args));\n\t\t\t\t} catch (e) {\n\t\t\t\t\tthrow Contextify.value(e);\n\t\t\t\t}\n\t\t\t},\n\t\t\twarn(...args) {\n\t\t\t\ttry {\n\t\t\t\t\t// FIXME ...args has side effects\n\t\t\t\t\tvm.emit('console.warn', ...Decontextify.arguments(args));\n\t\t\t\t} catch (e) {\n\t\t\t\t\tthrow Contextify.value(e);\n\t\t\t\t}\n\t\t\t},\n\t\t\terror(...args) {\n\t\t\t\ttry {\n\t\t\t\t\t// FIXME ...args has side effects\n\t\t\t\t\tvm.emit('console.error', ...Decontextify.arguments(args));\n\t\t\t\t} catch (e) {\n\t\t\t\t\tthrow Contextify.value(e);\n\t\t\t\t}\n\t\t\t},\n\t\t\tdir(...args) {\n\t\t\t\ttry {\n\t\t\t\t\tvm.emit('console.dir', ...Decontextify.arguments(args));\n\t\t\t\t} catch (e) {\n\t\t\t\t\tthrow Contextify.value(e);\n\t\t\t\t}\n\t\t\t},\n\t\t\ttime() {},\n\t\t\ttimeEnd() {},\n\t\t\ttrace(...args) {\n\t\t\t\ttry {\n\t\t\t\t\t// FIXME ...args has side effects\n\t\t\t\t\tvm.emit('console.trace', ...Decontextify.arguments(args));\n\t\t\t\t} catch (e) {\n\t\t\t\t\tthrow Contextify.value(e);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\t/*\n\tReturn contextified require.\n\t*/\n\n\treturn _prepareRequire;\n})(vm, host);\n", "/* eslint-env mocha */\n/* eslint-disable no-new-wrappers, max-len */\n\n'use strict';\n\nconst assert = require('assert');\nconst {VM, VMScript} = require('..');\nconst NODE_VERSION = parseInt(process.versions.node.split('.')[0]);\nconst {inspect} = require('util');\n\nglobal.isVM = false;\n\ndescribe('node', () => {\n\tlet vm;\n\n\tconst doubleProxy = new Proxy(new Proxy({x: 1}, {get() {\n\t\tthrow new Error('Expected');\n\t}}), {});\n\n\tbefore(() => {\n\t\tvm = new VM();\n\t});\n\tit('inspect', () => {\n\t\tassert.throws(() => inspect(doubleProxy), /Expected/);\n\t\tif (NODE_VERSION !== 10) {\n\t\t\t// This failes on node 10 since they do not unwrap proxys.\n\t\t\t// And the hack to fix this is only in the inner proxy.\n\t\t\t// We could add another hack, but that one would require\n\t\t\t// to look if the caller is from a special node function and\n\t\t\t// then remove all the integer keys. To get the caller we\n\t\t\t// would need to get the stack trace which is slow and\n\t\t\t// the probability of this call is so low that I don't do\n\t\t\t// this right now.\n\t\t\tassert.strictEqual(inspect(vm.run('[1, 2, 3]')), inspect([1, 2, 3]), true);\n\t\t}\n\t});\n\tafter(() => {\n\t\tvm = null;\n\t});\n});\n\ndescribe('contextify', () => {\n\tlet vm;\n\n\tclass TestClass {\n\t\tconstructor() {\n\t\t\tthis.greeting = 'hello';\n\t\t}\n\n\t\tgreet(name) {\n\t\t\treturn `${this.greeting} ${name}`;\n\t\t}\n\t}\n\n\tconst sandbox = {\n\t\tassert,\n\t\ttest: {\n\t\t\tstring: 'text',\n\t\t\tstringO: new String('text'),\n\t\t\tnumber: 1,\n\t\t\tnumberO: new Number(1),\n\t\t\tboolean: true,\n\t\t\tbooleanO: new Boolean(true),\n\t\t\tdate: new Date(),\n\t\t\tregexp: /xxx/,\n\t\t\tbuffer: Buffer.from([0x00, 0x01]),\n\t\t\t'function'() {\n\t\t\t\treturn () => ({});\n\t\t\t},\n\t\t\tobject: {\n\t\t\t\tx: 1,\n\t\t\t\ty() {\n\t\t\t\t\treturn i => i instanceof Object;\n\t\t\t\t},\n\t\t\t\tz(i) {\n\t\t\t\t\tif (!(i instanceof Object)) throw new Error('Not instanceof parent Object.');\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t},\n\t\t\tnil: null,\n\t\t\tundef: void 0,\n\t\t\tklass: TestClass,\n\t\t\tsymbol1: Symbol('foo'),\n\t\t\tsymbol2: Symbol.for('foo'),\n\t\t\tsymbol3: Symbol.iterator,\n\t\t\terror: new Error('test')\n\t\t}\n\t};\n\n\tbefore(() => {\n\t\tvm = new VM({sandbox});\n\t});\n\n\tit('common', () => {\n\t\tassert.ok(vm.run(`global.__proto__ === Object.prototype`));\n\t\tassert.ok(vm.run(`global.__proto__.constructor === Object`));\n\t\tassert.ok(vm.run(`Object.__proto__ === Function.prototype`));\n\t\tassert.ok(vm.run(`Object.__proto__.constructor === Function`));\n\t\tassert.ok(vm.run(`Object.prototype.__proto__ === null`));\n\t\tassert.ok(vm.run(`Function.__proto__ === Function.prototype`));\n\t\tassert.ok(vm.run(`Function.__proto__.constructor === Function`));\n\t\tassert.ok(vm.run(`Function.prototype.__proto__ === Object.prototype`));\n\t\tassert.ok(vm.run(`Array.__proto__ === Function.prototype`));\n\t\tassert.ok(vm.run(`Array.__proto__.constructor === Function`));\n\t\tassert.ok(vm.run(`Array.prototype.__proto__ === Object.prototype`));\n\n\t\tassert.strictEqual(sandbox.test.object.y === sandbox.test.object.y.valueOf(), true);\n\t\tassert.strictEqual(vm.run('test.object.y instanceof Function'), true);\n\t\tassert.strictEqual(vm.run('test.object.y.valueOf() instanceof Function'), true);\n\t\tassert.strictEqual(vm.run('test.object.y').isVMProxy, void 0);\n\t\tassert.strictEqual(vm.run('test.object.y.valueOf()').isVMProxy, void 0);\n\t\tassert.strictEqual(vm.run('test.object.y') === vm.run('test.object.y.valueOf()'), true);\n\t\tassert.strictEqual(vm.run('test.object.y === test.object.y.valueOf()'), true);\n\t\tassert.strictEqual(vm.run('test.object').y instanceof Function, true);\n\t\tassert.strictEqual(vm.run('test.object').y.valueOf() instanceof Function, true);\n\t\tassert.strictEqual(vm.run('test.object').y.isVMProxy, void 0);\n\t\tassert.strictEqual(vm.run('test.object').y.valueOf().isVMProxy, void 0);\n\t\tassert.strictEqual(vm.run('test.object').y === vm.run('test.object').y.valueOf(), true);\n\t\tassert.strictEqual(vm.run('test.valueOf()') === vm.run('test').valueOf(), true);\n\t\tassert.strictEqual(vm.run('test.object.y.constructor instanceof Function'), true);\n\t\tassert.strictEqual(vm.run(\"test.object.y.constructor('return (function(){return this})().isVM')()\"), true);\n\t\tassert.strictEqual(vm.run('test.object.valueOf() instanceof Object'), true);\n\t\tassert.strictEqual(vm.run('test.object.valueOf().y instanceof Function'), true);\n\t\tassert.strictEqual(vm.run('test.object.valueOf().y.constructor instanceof Function'), true);\n\t\tassert.strictEqual(vm.run(\"test.object.valueOf().y.constructor('return (function(){return this})().isVM')()\"), true);\n\n\t\tassert.strictEqual(Object.prototype.toString.call(vm.run(`[]`)), '[object Array]');\n\t\tassert.strictEqual(Object.prototype.toString.call(vm.run(`new Date`)), '[object Date]');\n\t\tassert.strictEqual(Object.prototype.toString.call(vm.run(`new RangeError`)), '[object Error]');\n\t\tassert.strictEqual(Object.prototype.toString.call(vm.run(`/a/g`)), '[object RegExp]');\n\t\tassert.strictEqual(Object.prototype.toString.call(vm.run(`new String`)), '[object String]');\n\t\tassert.strictEqual(Object.prototype.toString.call(vm.run(`new Number`)), '[object Number]');\n\t\tassert.strictEqual(Object.prototype.toString.call(vm.run(`new Boolean`)), '[object Boolean]');\n\n\t\tassert.strictEqual(vm.run(`((obj) => Object.prototype.toString.call(obj))`)([]), '[object Array]');\n\t\tassert.strictEqual(vm.run(`((obj) => Object.prototype.toString.call(obj))`)(new Date), '[object Date]');\n\t\tassert.strictEqual(vm.run(`((obj) => Object.prototype.toString.call(obj))`)(new RangeError), '[object Error]');\n\t\tassert.strictEqual(vm.run(`((obj) => Object.prototype.toString.call(obj))`)(/a/g), '[object RegExp]');\n\t\tassert.strictEqual(vm.run(`((obj) => Object.prototype.toString.call(obj))`)(new String), '[object String]');\n\t\tassert.strictEqual(vm.run(`((obj) => Object.prototype.toString.call(obj))`)(new Number), '[object Number]');\n\t\tassert.strictEqual(vm.run(`((obj) => Object.prototype.toString.call(obj))`)(new Boolean), '[object Boolean]');\n\n\t\tassert.strictEqual(typeof vm.run(`new String`), 'object');\n\t\tassert.strictEqual(typeof vm.run(`new Number`), 'object');\n\t\tassert.strictEqual(typeof vm.run(`new Boolean`), 'object');\n\t\tassert.strictEqual(vm.run(`((obj) => typeof obj)`)(new String), 'object');\n\t\tassert.strictEqual(vm.run(`((obj) => typeof obj)`)(new Number), 'object');\n\t\tassert.strictEqual(vm.run(`((obj) => typeof obj)`)(new Boolean), 'object');\n\n\t\tlet o = vm.run('let x = {a: test.date, b: test.date};x');\n\t\tassert.strictEqual(vm.run('x.valueOf().a instanceof Date'), true);\n\t\tassert.strictEqual(o instanceof Object, true);\n\t\tassert.strictEqual(o.a instanceof Date, true);\n\t\tassert.strictEqual(o.b instanceof Date, true);\n\t\tassert.strictEqual(o.a === o.b, true);\n\t\tassert.strictEqual(o.a === sandbox.test.date, true);\n\n\t\to = vm.run('let y = new Date(); let z = {a: y, b: y};z');\n\t\tassert.strictEqual(o.isVMProxy, true);\n\t\tassert.strictEqual(o instanceof Object, true);\n\t\tassert.strictEqual(o.a instanceof Date, true);\n\t\tassert.strictEqual(o.b instanceof Date, true);\n\t\tassert.strictEqual(o.a === o.b, true);\n\t});\n\n\tit('class', () => {\n\t\tassert.strictEqual(vm.run('new test.klass()').isVMProxy, undefined);\n\t\tassert.strictEqual(vm.run('new test.klass()').greet('friend'), 'hello friend');\n\t\tassert.strictEqual(vm.run('new test.klass()') instanceof TestClass, true);\n\n\t\t// vm.run(\"class LocalClass extends test.klass {}\");\n\t});\n\n\tit('string', () => {\n\t\tassert.strictEqual(vm.run('(test.string).constructor === String'), true);\n\t\tassert.strictEqual(vm.run(\"typeof(test.string) === 'string' && test.string.valueOf instanceof Object\"), true);\n\t});\n\n\tit('number', () => {\n\t\tassert.strictEqual(vm.run(\"typeof(test.number) === 'number' && test.number.valueOf instanceof Object\"), true);\n\t});\n\n\tit('boolean', () => {\n\t\tassert.strictEqual(vm.run(\"typeof(test.boolean) === 'boolean' && test.boolean.valueOf instanceof Object\"), true);\n\t});\n\n\tit('date', () => {\n\t\tassert.strictEqual(vm.run('test.date instanceof Date'), true);\n\t\tassert.strictEqual(vm.run('test.date') instanceof Date, true);\n\t\tassert.strictEqual(vm.run('test.date'), sandbox.test.date);\n\t});\n\n\tit('regexp', () => {\n\t\tassert.strictEqual(vm.run('test.regexp instanceof RegExp'), true);\n\t});\n\n\tit('buffer', () => {\n\t\tassert.strictEqual(vm.run('test.buffer.inspect()'), '<Buffer 00 01>', '#1');\n\t\tassert.strictEqual(vm.run('test.buffer instanceof Buffer'), true, '#2');\n\t\tassert.strictEqual(vm.run('test.buffer') instanceof Buffer, true, '#3');\n\t\tassert.strictEqual(vm.run('test.buffer'), sandbox.test.buffer, '#4');\n\t\tassert.strictEqual(vm.run('class Buffer2 extends Buffer {};Buffer2.alloc(5)').fill(1).inspect(), '<Buffer 01 01 01 01 01>');\n\n\t\tconst {a, b, c, d} = vm.run(`\n\t\t\tlet a = Buffer.from([0x01, 0x02]);\n\t\t\tlet b = Buffer.alloc(3, 0x03);\n\t\t\tlet c = Buffer.from(a);\n\t\t\tlet d = Buffer.concat([a, b, c]);\n\n\t\t\tassert.ok(a instanceof Buffer, '#1');\n\t\t\tassert.ok(b instanceof Buffer, '#2');\n\t\t\tassert.ok(c instanceof Buffer, '#3');\n\t\t\tassert.ok(d instanceof Buffer, '#4');\n\t\t\tassert.ok(a.constructor === Buffer, '#5');\n\t\t\tassert.ok(b.constructor === Buffer, '#6');\n\t\t\tassert.ok(c.constructor === Buffer, '#7');\n\t\t\tassert.ok(d.constructor === Buffer, '#8');\n\t\t\tassert.ok(a.constructor.constructor === Function, '#9');\n\t\t\tassert.ok(b.constructor.constructor === Function, '#10');\n\t\t\tassert.ok(c.constructor.constructor === Function, '#11');\n\t\t\tassert.ok(d.constructor.constructor === Function, '#12');\n\n\t\t\t({a: a, b: b, c: c, d: d})\n\t\t`);\n\n\t\tassert.ok(a instanceof Buffer);\n\t\tassert.ok(b instanceof Buffer);\n\t\tassert.ok(c instanceof Buffer);\n\t\tassert.ok(d instanceof Buffer);\n\t\tassert.ok(a.constructor === Buffer);\n\t\tassert.ok(b.constructor === Buffer);\n\t\tassert.ok(c.constructor === Buffer);\n\t\tassert.ok(d.constructor === Buffer);\n\t\tassert.ok(a.constructor.constructor === Function);\n\t\tassert.ok(b.constructor.constructor === Function);\n\t\tassert.ok(c.constructor.constructor === Function);\n\t\tassert.ok(d.constructor.constructor === Function);\n\t});\n\n\tit('function', () => {\n\t\tassert.strictEqual(vm.run('test.function instanceof Function'), true, '#1');\n\t\tassert.strictEqual(vm.run('test.function() instanceof Function'), true, '#2');\n\t\tassert.strictEqual(vm.run('test.function()() instanceof Object'), true, '#3');\n\t});\n\n\tit('object', () => {\n\t\tassert.strictEqual(vm.run('test.object instanceof Object && test.object.x === 1'), true, '#1');\n\t\tassert.strictEqual(vm.run('test.object.y instanceof Function'), true, '#2');\n\t\tassert.strictEqual(vm.run('test.object.y() instanceof Function'), true, '#3');\n\t\tassert.strictEqual(vm.run('test.object.y()({})'), true, '#4');\n\t\tassert.strictEqual(vm.run('test.object.z({}) instanceof Object'), true, '#5');\n\t\tassert.strictEqual(vm.run(\"Object.getOwnPropertyDescriptor(test.object, 'y').hasOwnProperty instanceof Function\"), true, '#6');\n\t\tassert.strictEqual(vm.run(\"Object.getOwnPropertyDescriptor(test.object, 'y').hasOwnProperty.constructor('return (function(){return this})().isVM')()\"), true, '#7');\n\t});\n\n\tit('null', () => {\n\t\tassert.strictEqual(vm.run('test.nil === null'), true);\n\t});\n\n\tit('undefined', () => {\n\t\tassert.strictEqual(vm.run('test.undef === undefined'), true);\n\t});\n\n\tit('symbol', () => {\n\t\tassert.strictEqual(vm.run(\"Symbol.for('foo') === test.symbol2\"), true);\n\t\tassert.strictEqual(vm.run('test.symbol1.constructor.constructor === Function'), true);\n\t\tassert.strictEqual(vm.run('test.symbol2.constructor.constructor === Function'), true);\n\t\tassert.strictEqual(vm.run('test.symbol3.constructor.constructor === Function'), true);\n\t\tassert.strictEqual(vm.run(\"Symbol('foo').constructor.constructor === Function\"), true);\n\t\tassert.strictEqual(vm.run(\"Symbol('foobar').constructor.constructor === Function\"), true);\n\t\tassert.strictEqual(vm.run('Symbol.keyFor(test.symbol2)'), 'foo');\n\t});\n\n\tit('error', () => {\n\t\tassert.strictEqual(vm.run('test.error.constructor.constructor === Function;'), true);\n\t});\n\n\tafter(() => {\n\t\tvm = null;\n\t});\n});\n\ndescribe('VM', () => {\n\tlet vm;\n\n\tconst sandbox = {\n\t\tround(number) {\n\t\t\treturn Math.round(number);\n\t\t},\n\t\tsub: {}\n\t};\n\n\tObject.defineProperty(sandbox.sub, 'getter', {\n\t\tget() {\n\t\t\tconst results = [];\n\t\t\twhile (true) {\n\t\t\t\tresults.push(1);\n\t\t\t}\n\t\t\treturn results;\n\t\t}\n\t});\n\n\tbefore(() => {\n\t\tvm = new VM({\n\t\t\tsandbox\n\t\t});\n\t});\n\n\tit('globals', () => {\n\t\tconst dyn = {};\n\t\tvm.setGlobal('dyn', dyn);\n\t\tvm.setGlobals({dyns: dyn});\n\t\tassert.equal(vm.run('round(1.5)'), 2);\n\t\tassert.equal(vm.getGlobal('dyn'), dyn);\n\t\tassert.equal(vm.sandbox.dyn, dyn);\n\t\tassert.equal(vm.sandbox.dyns, dyn);\n\t});\n\n\tit('errors', () => {\n\t\tassert.throws(() => vm.run('notdefined'), /notdefined is not defined/);\n\t\tassert.throws(() => vm.run('Object.setPrototypeOf(sub, {})'), err => {\n\t\t\tassert.ok(err instanceof Error);\n\t\t\tassert.equal(err.name, 'VMError');\n\t\t\tassert.equal(err.message, 'Operation not allowed on contextified object.');\n\t\t\treturn true;\n\t\t});\n\n\t\tif (NODE_VERSION > 6) {\n\t\t\t// async/await was not there in Node 6\n\t\t\tassert.throws(() => vm.run('function test(){ return await Promise.resolve(); };'), err => {\n\t\t\t\tassert.ok(err instanceof Error);\n\t\t\t\tassert.equal(err.name, 'SyntaxError');\n\t\t\t\tassert.equal(err.message, 'await is only valid in async function');\n\t\t\t\treturn true;\n\t\t\t});\n\t\t}\n\t\tassert.throws(() => new VM({compiler: 'nonexistant'}), /Unsupported compiler/);\n\t\tassert.throws(() => new VMScript('', '', {compiler: 'nonexistant'}), /Unsupported compiler/);\n\t});\n\n\tit('timeout', () => {\n\t\tconst message = NODE_VERSION >= 11 ? /Script execution timed out after 10ms/ : /Script execution timed out\\./;\n\n\t\tassert.throws(() => new VM({\n\t\t\ttimeout: 10\n\t\t}).run('while (true) {}'), message);\n\t\tassert.throws(() => new VM({timeout: 10, sandbox}).run('sub.getter'), message);\n\t});\n\n\tit('timers', () => {\n\t\tassert.equal(vm.run('global.setTimeout'), void 0);\n\t\tassert.equal(vm.run('global.setInterval'), void 0);\n\t\tassert.equal(vm.run('global.setImmediate'), void 0);\n\t});\n\n\tif (NODE_VERSION >= 10) {\n\t\tit('eval/wasm', () => {\n\t\t\tassert.equal(vm.run('eval(\"1\")'), 1);\n\n\t\t\tconst vm2 = new VM({eval: false});\n\t\t\tassert.throws(() => vm2.run('eval(\"1\")'), /Code generation from strings disallowed for this context/);\n\t\t});\n\t}\n\n\tif (NODE_VERSION > 7) {\n\t\t// Node until 7 had no async, see https://node.green/\n\t\tit('async', () => {\n\t\t\tconst vm2 = new VM({fixAsync: true});\n\t\t\tassert.throws(() => vm2.run('(async function(){})'), /Async not available/, '#1');\n\t\t\tassert.strictEqual(vm2.run('Object.getPrototypeOf((function*(){}).constructor)'), vm2.run('Function'), '#2');\n\t\t\tassert.throws(() => vm2.run('new Function(\"(as\"+\"ync function(){})\")'), /Async not available/, '#3');\n\t\t\tassert.throws(() => vm2.run('new (function*(){}).constructor(\"(as\"+\"ync function(){})\")'), /Async not available/, '#4');\n\t\t\tassert.throws(() => vm2.run('Promise.resolve().then(function(){})'), /Async not available/, '#5');\n\t\t\tif (Promise.prototype.finally) assert.throws(() => vm2.run('Promise.resolve().finally(function(){})'), /Async not available/, '#6');\n\t\t\tif (Promise.prototype.catch) assert.throws(() => vm2.run('Promise.resolve().catch(function(){})'), /Async not available/, '#7');\n\t\t\tassert.throws(() => vm2.run('eval(\"(as\"+\"ync function(){})\")'), /Async not available/, '#8');\n\t\t\tassert.throws(() => vm2.run('Function')('(async function(){})'), /Async not available/, '#9');\n\t\t});\n\t}\n\n\tit('proxy trap errors', () => {\n\t\tconst vm2 = new VM();\n\t\tassert.doesNotThrow(() => {\n\t\t\tReflect.ownKeys(vm2.run('(function(){}).bind(null)'));\n\t\t});\n\t});\n\n\tit('frozen unconfigurable access', () => {\n\t\tconst vm2 = new VM();\n\t\tconst obj = {};\n\n\t\tassert.doesNotThrow(()=>{\n\t\t\tvm2.run('x => x.prop')(Object.freeze({prop: {}}));\n\t\t});\n\n\t\tassert.doesNotThrow(()=>{\n\t\t\tvm2.run('x => Object.getOwnPropertyDescriptor(x, \"prop\")')(Object.freeze({prop: {}}));\n\t\t});\n\n\t\tassert.doesNotThrow(()=>{\n\t\t\tvm2.run('x => x.prop')(Object.defineProperty({}, 'prop', {value: {}}));\n\t\t});\n\n\t\tassert.doesNotThrow(()=>{\n\t\t\tvm2.run('x => Object.isExtensible(x)')(Object.freeze({prop: {}}));\n\t\t});\n\n\t\tassert.doesNotThrow(()=>{\n\t\t\tvm2.run('x => {Object.preventExtensions(x); Object.getOwnPropertyDescriptor(x, \"prop\")}')({prop: {}});\n\t\t});\n\n\t\tassert.strictEqual(vm2.run('x => {Object.preventExtensions(x); return Object.getOwnPropertyDescriptor(x, \"prop\").value}')({prop: obj}), obj);\n\n\t});\n\n\tit('various attacks #1', () => {\n\t\tconst vm2 = new VM({sandbox: {log: console.log, boom: () => {\n\t\t\tthrow new Error();\n\t\t}}});\n\n\t\tassert.strictEqual(vm2.run(\"this.constructor.constructor('return Function(\\\\'return Function\\\\')')()() === this.constructor.constructor('return Function')()\"), true);\n\n\t\tassert.throws(() => vm2.run(`\n\t\t\tconst ForeignFunction = global.constructor.constructor;\n\t\t\tconst process1 = ForeignFunction(\"return process\")();\n\t\t`), /process is not defined/, '#1');\n\n\t\tassert.throws(() => vm2.run(`\n\t\t    try {\n\t\t        boom();\n\t\t    }\n\t\t    catch (e) {\n\t\t        const foreignFunction = e.constructor.constructor;\n\t\t        const process = foreignFunction(\"return process\")();\n\t\t    }\n\t\t`), /process is not defined/, '#2');\n\n\t\tassert.doesNotThrow(() => vm2.run(`\n\t\t\tfunction exploit(o) {\n\t\t\t\tthrow new Error('Shouldnt be there.');\n\t\t\t}\n\n\t\t\tReflect.construct = exploit;\n\t\t\tBuffer.from([0]);\n\t\t`), '#3');\n\n\t\tassert.doesNotThrow(() => vm2.run(`\n\t\t\tglobal.Proxy = function() {\n\t\t\t\tthrow new Error('Shouldnt be there.');\n\t\t\t}\n\t\t`), '#4');\n\n\t\tassert.doesNotThrow(() => vm2.run(`\n\t\t\tglobal.String = function(text) {\n\t\t\t\tthrow new Error('Shouldnt be there.');\n\t\t\t};(function(text) {})\n\t\t`)('asdf'), '#5');\n\n\t\tassert.doesNotThrow(() => vm2.run(`\n\t\t\tglobal.String = function(text) {\n\t\t\t\tthrow new Error('Shouldnt be there.');\n\t\t\t};(function(text) {})\n\t\t`)(new String('asdf')), '#6');\n\n\t\tassert.doesNotThrow(() => vm2.run(`\n\t\t\tglobal.Buffer = function(value) {\n\t\t\t\tthrow new Error('Shouldnt be there.');\n\t\t\t};(function(value) {})\n\t\t`)(Buffer.alloc(1)), '#7');\n\t});\n\n\tit('various attacks #2', () => {\n\t\tconst vm2 = new VM({\n\t\t\tsandbox: {\n\t\t\t\tboom: () => {},\n\t\t\t\terror: new Error('test')\n\t\t\t}\n\t\t});\n\n\t\tassert.doesNotThrow(() => vm2.run(`\n\t\t\tObject.assign = function (o) {\n\t\t\t\tthrow new Error('Shouldnt be there.');\n\t\t\t};\n\t\t\tBuffer.from([0]);\n\t\t`), '#1');\n\n\t\tassert.doesNotThrow(() => vm2.run(`\n\t\t\ttry {\n\t\t\t\tBuffer.alloc(0);\n\t\t\t} catch (e) {\n\t\t\t\tif (e.constructor.constructor !== Function) throw new Error('Shouldnt be there.');\n\t\t\t}\n\t\t`), '#2');\n\n\t\tassert.doesNotThrow(() => vm2.run(`\n\t\t\tlet o;\n\t\t\tArray.prototype.map = function(callback) {\n\t\t\t\to = callback(boom);\n\t\t\t\treturn [];\n\t\t\t};\n\t\t\tboom(boom);\n\t\t\tif (o && o.constructor !== Function) throw new Error('Shouldnt be there.');\n\t\t`), '#3');\n\n\t\tassert.doesNotThrow(() => vm2.run(`\n\t\t\tlet method = () => {};\n\t\t\tlet proxy = new Proxy(method, {\n\t\t\t\tapply: (target, context, args) => {\n\t\t\t\t\tif (target.constructor.constructor !== Function) throw new Error('Shouldnt be there.');\n\t\t\t\t\tif (args.constructor.constructor !== Function) throw new Error('Shouldnt be there.');\n\t\t\t\t}\n\t\t\t});\n\t\t\tproxy\n\t\t`)('asdf'), '#4');\n\n\t\tassert.doesNotThrow(() => vm2.run(`\n\t\t\tlet proxy2 = new Proxy(function() {}, {\n\t\t\t\tapply: (target, context, args) => {\n\t\t\t\t\tif (args.constructor.constructor !== Function) throw new Error('Shouldnt be there.');\n\t\t\t\t}\n\t\t\t});\n\t\t\tproxy2\n\t\t`)('asdf'), '#5');\n\n\t\tassert.strictEqual(vm2.run(`\n\t\t\tglobal.DEBUG = true;\n\t\t\tboom.vmProxyTarget\n\t\t`), undefined, '#6');\n\n\t\tassert.throws(() => vm2.run(`\n\t\t\tglobal.constructor.constructor('return this')().constructor.constructor('return process')()\n\t\t`), /process is not defined/, '#7');\n\n\t\tassert.throws(() => vm2.run(`\n\t\t\tglobal.__proto__.constructor.constructor('return this')().constructor.constructor('return process')()\n\t\t`), /process is not defined/, '#8');\n\n\t\tassert.doesNotThrow(() => vm2.run(`\n\t\t\tif (!(Object.keys(boom) instanceof Array)) throw new Error('Shouldnt be there.');\n\t\t\tif (!(Reflect.ownKeys(boom) instanceof Array)) throw new Error('Shouldnt be there.');\n\t\t`));\n\t});\n\n\tit('buffer attack', () => {\n\t\tconst vm2 = new VM();\n\n\t\tassert.strictEqual(vm2.run(`\n\t\t\tBuffer.alloc(100).toString('hex');\n\t\t`), '00'.repeat(100), '#1');\n\n\t\tassert.strictEqual(vm2.run(`\n\t\t\tBuffer.allocUnsafe(100).constructor.constructor === Function;\n\t\t`), true, '#2');\n\n\t\tassert.strictEqual(vm2.run(`\n\t\t\tBuffer.allocUnsafe(100).toString('hex');\n\t\t`), '00'.repeat(100), '#3');\n\n\t\tassert.strictEqual(vm2.run(`\n\t\t\tclass MyBuffer extends Buffer {}; MyBuffer.alloc(100).toString('hex');\n\t\t`), '00'.repeat(100), '#4');\n\n\t\tassert.strictEqual(vm2.run(`\n\t\t\tnew Buffer(100).toString('hex');\n\t\t`), '00'.repeat(100), '#5');\n\n\t\tif (NODE_VERSION < 8) {\n\t\t\tassert.strictEqual(vm2.run(`\n\t\t\t\tBuffer(100).toString('hex');\n\t\t\t`), '00'.repeat(100), '#6');\n\t\t}\n\n\t\tassert.strictEqual(vm2.run(`\n\t\t\tclass MyBuffer2 extends Buffer {}; new MyBuffer2(100).toString('hex');\n\t\t`), '00'.repeat(100), '#7');\n\n\t});\n\n\tit('instanceof attack', () => {\n\t\t// https://github.com/patriksimek/vm2/issues/174\n\n\t\tconst vm2 = new VM({\n\t\t\tsandbox: {\n\t\t\t\tfunc: cb => cb()\n\t\t\t}\n\t\t});\n\n\t\ttry {\n\t\t\tvm2.run(`\n\t\t\t\tfunc(() => {\n\t\t\t\t\tthrow new Proxy({}, {\n\t\t\t\t\t\tgetPrototypeOf: () => {\n\t\t\t\t\t\t\tthrow x => x.constructor.constructor(\"return process;\")();\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t});\n\t\t\t`);\n\t\t} catch (ex) {\n\t\t\tassert.strictEqual(ex, null);\n\t\t}\n\t});\n\n\tit('__defineGetter__ / __defineSetter__ attack', () => {\n\t\t// https://github.com/patriksimek/vm2/issues/176\n\n\t\tconst vm2 = new VM();\n\n\t\tassert.strictEqual(vm2.run(`\n\t\t\tBuffer.prototype.__defineGetter__ === {}.__defineGetter__;\n\t\t`), true, '#1');\n\n\t\tif (NODE_VERSION > 6) {\n\t\t\tassert.throws(() => vm2.run(`\n\t\t\t\tBuffer.prototype.__defineGetter__(\"toString\", () => {});\n\t\t\t`), /'defineProperty' on proxy: trap returned falsish for property 'toString'/, '#2');\n\t\t} else {\n\t\t\tassert.strictEqual(vm2.run(`\n\t\t\t\tBuffer.prototype.__defineGetter__(\"xxx\", () => 4);\n\t\t\t\tBuffer.prototype.xxx;\n\t\t\t`), undefined, '#2');\n\t\t}\n\n\t\tassert.strictEqual(vm2.run(`\n\t\t\tglobal.__defineGetter__(\"test\", () => 123); global.test;\n\t\t`), 123, '#3');\n\t});\n\n\tit('__lookupGetter__ / __lookupSetter__ attack', () => {\n\t\t// https://github.com/patriksimek/vm2/issues/184\n\n\t\tconst vm2 = new VM();\n\n\t\tassert.strictEqual(vm2.run(`\n\t\t\tBuffer.from.__lookupGetter__(\"__proto__\") === Object.prototype.__lookupGetter__.call(Buffer.from, \"__proto__\");\n\t\t`), true, '#1');\n\t});\n\n\tit('contextifying a contextified value attack', () => {\n\t\t// https://github.com/patriksimek/vm2/issues/175\n\t\t// https://github.com/patriksimek/vm2/issues/177\n\t\t// https://github.com/patriksimek/vm2/issues/186\n\n\t\tlet vm2 = new VM();\n\n\t\t// The Buffer.from(\"\") is only used to get instance of object contextified from the host\n\t\tassert.doesNotThrow(() => vm2.run(`\n\t\t\tObject.defineProperty(Buffer.from(\"\"), \"x\", {\n\t\t\t\tget set() {\n\t\t\t\t\tObject.defineProperty(Object.prototype, \"get\", {\n\t\t\t\t\t\tget() {\n\t\t\t\t\t\t\tthrow new Error();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\treturn ()=>{};\n\t\t\t\t}\n\t\t\t});\n\t\t`), '#1');\n\n\t\tvm2 = new VM({\n\t\t\tsandbox: {\n\t\t\t\tctor: X => new X(),\n\t\t\t\tcall: x => x()\n\t\t\t}\n\t\t});\n\n\t\tassert.throws(() => vm2.run(`\n\t\t\tcall(ctor(new Proxy(class A {}, {\n\t\t\t\tconstruct(){\n\t\t\t\t\treturn () => x => x.constructor(\"return process\")();\n\t\t\t\t}\n\t\t\t})))(()=>{}).mainModule.require(\"child_process\").execSync(\"id\").toString()\n\t\t`), /process is not defined/, '#2');\n\n\t\tvm2 = new VM();\n\n\t\tassert.throws(() => vm2.run(`\n\t\t\tvar process;\n\t\t\ttry {\n\t\t\t\tObject.defineProperty(Buffer.from(\"\"), \"y\", {\n\t\t\t\t\twritable: true,\n\t\t\t\t\tvalue: new Proxy({}, {\n\t\t\t\t\t\tgetPrototypeOf(target) {\n\t\t\t\t\t\t\tdelete this.getPrototypeOf;\n\t\t\t\n\t\t\t\t\t\t\tObject.defineProperty(Object.prototype, \"get\", {\n\t\t\t\t\t\t\t\tget() {\n\t\t\t\t\t\t\t\t\tdelete Object.prototype.get;\n\t\t\t\t\t\t\t\t\tFunction.prototype.__proto__ = null;\n\t\t\t\t\t\t\t\t\tthrow f=>f.constructor(\"return process\")();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\n\t\t\t\t\t\t\treturn Object.getPrototypeOf(target);\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t});\n\t\t\t} catch(e) {\n\t\t\t\tprocess = e(() => {});\n\t\t\t}\n\t\t\tprocess.mainModule.require(\"child_process\").execSync(\"whoami\").toString()\n\t\t`), /Cannot read property 'mainModule' of undefined/, '#3');\n\n\t\tvm2 = new VM();\n\n\t\tassert.doesNotThrow(() => vm2.run(`\n\t\t\tObject.defineProperty(Buffer.from(\"\"), \"\", {\n\t\t\t\tvalue: new Proxy({}, {\n\t\t\t\t\tgetPrototypeOf(target) {\n\t\t\t\t\t\tif(this.t) {\n\t\t\t\t\t\t\tthrow Buffer.from;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis.t=true;\n\t\t\t\t\t\treturn Object.getPrototypeOf(target);\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t});\n\t\t`), '#4');\n\n\t\tvm2 = new VM();\n\n\t\tassert.throws(() => vm2.run(`\n\t\t\tFunction.prototype.__proto__ = null;\n\t\t\tvar process;\n\t\t\ttry {\n\t\t\t\tBuffer.from(new Proxy({}, {\n\t\t\t\t\tgetPrototypeOf() {\n\t\t\t\t\t\tif (this.t) {\n\t\t\t\t\t\t\tthrow x => x.constructor(\"return process\")();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.t = true;\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t}));\n\t\t\t} catch(e) {\n\t\t\t\tprocess = e(() => {});\n\t\t\t}\n\t\t\tprocess.mainModule.require(\"child_process\").execSync(\"whoami\").toString()\n\t\t`), /e is not a function/, '#5');\n\n\t\tvm2 = new VM();\n\n\t\tassert.throws(() => vm2.run(`\n\t\t\tFunction.prototype.__proto__ = null;\n\t\t\tvar map = {\n\t\t\t\tvalueOf(){\n\t\t\t\t\tthrow new Proxy({},{\n\t\t\t\t\t\tgetPrototypeOf(){\n\t\t\t\t\t\t\tif(this.t) {\n\t\t\t\t\t\t\t\tthrow x=>x.constructor(\"return process\")();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis.t = true;\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t};\n\t\t\tvar process;\n\t\t\ttry{\n\t\t\t\tBuffer.from(map);\n\t\t\t}catch(e){\n\t\t\t\tprocess = e(x=>x);\n\t\t\t}\n\t\t\tprocess.mainModule.require(\"child_process\").execSync(\"whoami\").toString()\n\t\t`), /e is not a function/, '#6');\n\n\t\tvm2 = new VM();\n\n\t\tassert.throws(() => vm2.run(`\n\t\t\tvar map = {valueOf(){}};\n\t\t\tvar arrayBackup = Array;\n\t\t\tArray = function(){\n\t\t\t\tArray = arrayBackup;\n\t\t\t\tthrow x=>x.constructor(\"return process\")();\n\t\t\t};\n\t\t\tvar process;\n\t\t\ttry{\n\t\t\t\tBuffer.from(map);\n\t\t\t}catch(e){\n\t\t\t\tprocess = e(x=>x);\n\t\t\t}\n\t\t\tprocess\n\t\t`), /e is not a function/, '#7');\n\t});\n\n\tit('proxy trap via Object.prototype attack', () => {\n\t\t// https://github.com/patriksimek/vm2/issues/178\n\n\t\tconst vm2 = new VM();\n\n\t\tassert.throws(() => vm2.run(`\n\t\t\tlet process;\n\t\t\tObject.prototype.has = (t, k) => {\n\t\t\t\tprocess = t.constructor(\"return process\")();\n\t\t\t}\n\t\t\t\"\" in Buffer.from;\n\t\t\tprocess.mainModule;\n\t\t`), /Cannot read property 'mainModule' of undefined/, '#1');\n\n\t\tconst vm22 = new VM();\n\n\t\tassert.throws(() => vm22.run(`\n\t\t\tObject.defineProperty(Object.prototype, \"apply\", {set:function(o,v){\n\t\t\t\tdelete Object.prototype.apply;\n\t\t\t}});\n\t\t\tBuffer.from(\"\").constructor.constructor(\"return process\")().mainModule;\n\t\t`), /process is not defined/, '#2');\n\t});\n\n\tit('Object.create attack', () => {\n\t\t// https://github.com/patriksimek/vm2/issues/178\n\n\t\tconst vm2 = new VM();\n\n\t\tassert.throws(() => vm2.run(`\n\t\t\tvar oc = Object.create;\n\t\t\tObject.create = (p,x)=> Object.defineProperty(oc(p,x),\"get\",{set(){},get:()=>(t,k,r)=>t.constructor(\"return process\")()});\n\t\t\tvar process = Buffer.from.process;\n\t\t\tObject.create = oc;\n\t\t\tprocess.mainModule\n\t\t`), /Cannot read property 'mainModule' of undefined/, '#1');\n\t});\n\n\tit('function returned from construct attack', () => {\n\t\t// https://github.com/patriksimek/vm2/issues/179\n\n\t\tconst vm2 = new VM({\n\t\t\tsandbox: {\n\t\t\t\tcall: x => x.a(),\n\t\t\t\tctor: X => new X()\n\t\t\t}\n\t\t});\n\n\t\tassert.throws(() => vm2.run(`\n\t\t\tcall({a:ctor(new Proxy(class A{},{\n\t\t\t\tconstruct(){\n\t\t\t\t\treturn function(){\n\t\t\t\t\t\treturn Object.getPrototypeOf(this).constructor.constructor(\"return process\")();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}))}).mainModule.require(\"child_process\").execSync(\"id\").toString()\n\t\t`), /process is not defined/, '#1');\n\t});\n\n\tit('throw while accessing propertyDescriptor properties', () => {\n\t\t// https://github.com/patriksimek/vm2/issues/178#issuecomment-450904979\n\n\t\tconst vm2 = new VM();\n\n\t\tassert.strictEqual(vm2.run(`(function(){\n\t\t\tvar process;\n\t\t\tObject.defineProperty(Object.prototype, \"set\", {get(){\n\t\t\t\tdelete Object.prototype.set;\n\t\t\t\tObject.defineProperty(Object.prototype, \"get\", {get(){\n\t\t\t\t\tdelete Object.prototype.get;\n\t\t\t\t\tthrow new Proxy(Object.create(null),{\n\t\t\t\t\t\tset(t,k,v){\n\t\t\t\t\t\t\tprocess = v.constructor(\"return process\")();\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t},configurable:true});\n\t\t\t\treturn ()=>{};\n\t\t\t},configurable:true});\n\t\t\ttry{\n\t\t\t\tObject.defineProperty(Buffer.from(\"\"),\"\",{});\n\t\t\t}catch(e){\n\t\t\t\te.x = Buffer.from;\n\t\t\t}\n\t\t\treturn process;})()\n\t\t`), undefined, '#1');\n\t});\n\n\tit('Symbol.hasInstance attack', () => {\n\t\t// https://github.com/patriksimek/vm2/issues/178#issuecomment-450978210\n\n\t\tlet vm2 = new VM();\n\n\t\tassert.throws(() => vm2.run(`\n\t\t\tObject.__defineGetter__(Symbol.hasInstance,()=>()=>true);\n\t\t\tBuffer.from.constructor(\"return process\")().mainModule.require(\"child_process\").execSync(\"id\").toString()\n\t\t`), /process is not defined/, '#1');\n\n\t\tvm2 = new VM();\n\n\t\tassert.throws(() => vm2.run(`\n\t\t\tObject[Symbol.hasInstance].call = ()=>true;\n\t\t\tBuffer.from.constructor(\"return process\")().mainModule.require(\"child_process\").execSync(\"whoami\").toString()\n\t\t`), /process is not defined/, '#2');\n\t});\n\n\tit('Proxy::getOwnPropertyDescriptor attack', () => {\n\t\t// https://github.com/patriksimek/vm2/issues/178#issuecomment-450978210\n\n\t\tconst vm2 = new VM();\n\n\t\tassert.throws(() => vm2.run(`\n\t\t\t(function(){\n\t\t\t\ttry{\n\t\t\t\t\tBuffer.from(new Proxy({}, {\n\t\t\t\t\t\tgetOwnPropertyDescriptor(){\n\t\t\t\t\t\t\tthrow f=>f.constructor(\"return process\")();\n\t\t\t\t\t\t}\n\t\t\t\t\t}));\n\t\t\t\t}catch(e){\n\t\t\t\t\treturn e(()=>{}).mainModule.require(\"child_process\").execSync(\"whoami\").toString();\n\t\t\t\t}\n\t\t\t})()\n\t\t`), /e is not a function/);\n\t});\n\n\tif (NODE_VERSION >= 10) {\n\t\tit('Dynamic import attack', (done) => {\n\t\t\tprocess.once('unhandledRejection', (reason) => {\n\t\t\t\tassert.strictEqual(reason.message, 'process is not defined');\n\t\t\t\tdone();\n\t\t\t});\n\n\t\t\tconst vm2 = new VM();\n\n\t\t\tvm2.run(`\n\t\t\t\t(async () => {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tawait import('oops!');\n\t\t\t\t\t} catch (ex) {\n\t\t\t\t\t\t// ex is an instance of NodeError which is not proxied;\n\t\t\t\t\t\tconst process = ex.constructor.constructor('return process')();\n\t\t\t\t\t\tconst require = process.mainModule.require;\n\t\t\t\t\t\tconst child_process = require('child_process');\n\t\t\t\t\t\tconst output = child_process.execSync('id');\n\t\t\t\t\t\tprocess.stdout.write(output);\n\t\t\t\t\t}\n\t\t\t\t})();\n\t\t\t`);\n\t\t});\n\t}\n\n\tafter(() => {\n\t\tvm = null;\n\t});\n});\n\ndescribe('precompiled scripts', () => {\n\tit('VM', () => {\n\t\tconst vm = new VM();\n\t\tconst script = new VMScript('global.i=global.i||0;global.i++');\n\t\tconst val1 = vm.run(script);\n\t\tconst val2 = vm.run(script);\n\t\tconst failScript = new VMScript('(');\n\t\tassert.ok('number' === typeof val1 && 'number' === typeof val2);\n\t\tassert.ok( val1 === 0 && val2 === 1);\n\t\tassert.throws(() => failScript.compile(), /SyntaxError/);\n\t\tassert.ok(Object.keys(failScript).includes('code'));\n\t\tassert.ok(Object.keys(failScript).includes('filename'));\n\t\tassert.ok(Object.keys(failScript).includes('compiler'));\n\t\tassert.ok(!Object.keys(failScript).includes('_code'));\n\t});\n});\n\ndescribe('freeze, protect', () => {\n\tit('without freeze', () => {\n\t\tconst x = {\n\t\t\ta: () => 'a',\n\t\t\tb: () => 'b',\n\t\t\tc: {\n\t\t\t\td: () => 'd'\n\t\t\t}\n\t\t};\n\n\t\tconst vm = new VM({\n\t\t\tsandbox: {x}\n\t\t});\n\t\tvm.run('x.a = () => { return `-` }; x.c.d = () => { return `---` }; (y) => { y.b = () => { return `--` } }')(x);\n\n\t\tassert.strictEqual(x.a(), '-');\n\t\tassert.strictEqual(x.b(), '--');\n\t\tassert.strictEqual(x.c.d(), '---');\n\t});\n\n\tit('with freeze', () => {\n\t\tconst x = {\n\t\t\ta: () => 'a',\n\t\t\tb: () => 'b',\n\t\t\tc: {\n\t\t\t\td: () => 'd'\n\t\t\t}\n\t\t};\n\n\t\tconst vm = new VM();\n\t\tvm.freeze(x, 'x');\n\n\t\tassert.throws(() => {\n\t\t\tvm.run('\"use strict\"; x.a = () => { return `-` };');\n\t\t}, /'set' on proxy: trap returned falsish for property 'a'/);\n\n\t\tassert.throws(() => {\n\t\t\tvm.run('\"use strict\"; (y) => { y.b = () => { return `--` } }')(x);\n\t\t}, /'set' on proxy: trap returned falsish for property 'b'/);\n\n\t\tassert.throws(() => {\n\t\t\tvm.run('\"use strict\"; x.c.d = () => { return `---` };');\n\t\t}, /'set' on proxy: trap returned falsish for property 'd'/);\n\n\t\tvm.run('x.a = () => { return `-` };');\n\t\tassert.strictEqual(x.a(), 'a');\n\n\t\tvm.run('(y) => { y.b = () => { return `--` } }')(x);\n\t\tassert.strictEqual(x.b(), 'b');\n\n\t\tvm.run('x.c.d = () => { return `---` };');\n\t\tassert.strictEqual(x.c.d(), 'd');\n\n\t\t// Extension of frozen objects should be writeable.\n\t\tassert.strictEqual(vm.run('y = Object.create(x); y.f = 1; y.f'), 1);\n\t});\n\n\tit('without protect', () => {\n\t\tconst vm = new VM(); const obj = {};\n\t\tvm.run('(i) => { i.text = \"test\" }')(obj);\n\t\tvm.run('(i) => { i.func = () => {} }')(obj);\n\t\tvm.run('(i) => { delete i.func }')(obj);\n\t});\n\n\tit('with protect', () => {\n\t\tconst vm = new VM(); const obj = {\n\t\t\tdate: new Date(),\n\t\t\tarray: [{}, {}]\n\t\t};\n\n\t\tvm.protect(obj);\n\n\t\tvm.run('(i) => { i.func = () => {} }')(obj);\n\t\tassert.strictEqual(typeof obj.func, 'undefined');\n\n\t\tassert.throws(() => {\n\t\t\tvm.run('\"use strict\"; (i) => { i.func = () => {} }')(obj);\n\t\t});\n\n\t\tvm.run('(i) => { i.array.func = () => {} }')(obj);\n\t\tassert.strictEqual(typeof obj.array.func, 'undefined');\n\n\t\tassert.throws(() => {\n\t\t\tvm.run('\"use strict\"; (i) => { i.array.func = () => {} }')(obj);\n\t\t});\n\n\t\tvm.run('(i) => { i.array[0].func = () => {} }')(obj);\n\t\tassert.strictEqual(typeof obj.array[0].func, 'undefined');\n\n\t\tassert.throws(() => {\n\t\t\tvm.run('\"use strict\"; (i) => { i.array[0].func = () => {} }')(obj);\n\t\t});\n\n\t\tassert.throws(() => {\n\t\t\tvm.run('\"use strict\"; (i) => { Object.defineProperty(i, \"toString\", { get(){ return () => \\'Not protected\\'; } }) }')(obj);\n\t\t});\n\n\t\tassert.strictEqual(vm.run('(i) => i.array.map(item => 1).join(\",\")')(obj), '1,1');\n\t\tassert.strictEqual(vm.run('(i) => /x/.test(i.date)')(obj), false);\n\t});\n});\n"], "fixing_code": ["/* global host */\n/* eslint-disable block-spacing, no-multi-spaces, brace-style, no-array-constructor, new-cap, no-use-before-define */\n\n'use strict';\n\n// eslint-disable-next-line no-invalid-this, no-shadow\nconst global = this;\n\nconst local = host.Object.create(null);\nlocal.Object = Object;\nlocal.Array = Array;\nlocal.Reflect = host.Object.create(null);\nlocal.Reflect.ownKeys = Reflect.ownKeys;\nlocal.Reflect.enumerate = Reflect.enumerate;\nlocal.Reflect.getPrototypeOf = Reflect.getPrototypeOf;\nlocal.Reflect.construct = Reflect.construct;\nlocal.Reflect.apply = Reflect.apply;\nlocal.Reflect.set = Reflect.set;\nlocal.Reflect.deleteProperty = Reflect.deleteProperty;\nlocal.Reflect.has = Reflect.has;\nlocal.Reflect.defineProperty = Reflect.defineProperty;\nlocal.Reflect.setPrototypeOf = Reflect.setPrototypeOf;\nlocal.Reflect.isExtensible = Reflect.isExtensible;\nlocal.Reflect.preventExtensions = Reflect.preventExtensions;\nlocal.Reflect.getOwnPropertyDescriptor = Reflect.getOwnPropertyDescriptor;\n\nfunction uncurryThis(func) {\n\treturn (thiz, args) => local.Reflect.apply(func, thiz, args);\n}\n\nconst FunctionBind = uncurryThis(Function.prototype.bind);\n\n// global is originally prototype of host.Object so it can be used to climb up from the sandbox.\nObject.setPrototypeOf(global, Object.prototype);\n\nObject.defineProperties(global, {\n\tglobal: {value: global},\n\tGLOBAL: {value: global},\n\troot: {value: global},\n\tisVM: {value: true}\n});\n\nconst DEBUG = false;\nconst OPNA = 'Operation not allowed on contextified object.';\nconst captureStackTrace = Error.captureStackTrace;\n\nconst RETURN_FALSE = () => false;\n\nconst FROZEN_TRAPS = {\n\t__proto__: null,\n\tset(target, key, value, receiver) {\n\t\treturn local.Reflect.defineProperty(receiver, key, {\n\t\t\t__proto__: null,\n\t\t\tvalue: value,\n\t\t\twritable: true,\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true\n\t\t});\n\t},\n\tsetPrototypeOf: RETURN_FALSE,\n\tdefineProperty: RETURN_FALSE,\n\tdeleteProperty: RETURN_FALSE,\n\tisExtensible: RETURN_FALSE,\n\tpreventExtensions: RETURN_FALSE\n};\n\n// Map of contextified objects to original objects\nconst Contextified = new host.WeakMap();\nconst Decontextified = new host.WeakMap();\n\n// We can't use host's hasInstance method\nconst ObjectHasInstance = uncurryThis(local.Object[Symbol.hasInstance]);\nfunction instanceOf(value, construct) {\n\ttry {\n\t\treturn ObjectHasInstance(construct, [value]);\n\t} catch (ex) {\n\t\t// Never pass the handled exception through!\n\t\tthrow new VMError('Unable to perform instanceOf check.');\n\t\t// This exception actually never get to the user. It only instructs the caller to return null because we wasn't able to perform instanceOf check.\n\t}\n}\n\nconst SHARED_OBJECT = {__proto__: null};\nfunction SHARED_FUNCTION() {}\n\nfunction createBaseObject(obj) {\n\tlet base;\n\tif (typeof obj === 'function') {\n\t\ttry {\n\t\t\t// eslint-disable-next-line no-new\n\t\t\tnew new host.Proxy(obj, {\n\t\t\t\t__proto__: null,\n\t\t\t\tconstruct() {\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t})();\n\t\t\t// Bind the function since bound functions do not have a prototype property.\n\t\t\tbase = FunctionBind(SHARED_FUNCTION, [null]);\n\t\t} catch (e) {\n\t\t\tbase = () => {};\n\t\t}\n\t} else if (host.Array.isArray(obj)) {\n\t\tbase = [];\n\t} else {\n\t\treturn {__proto__: null};\n\t}\n\tif (!local.Reflect.setPrototypeOf(base, null)) {\n\t\t// Should not happen\n\t\treturn null;\n\t}\n\treturn base;\n}\n\n/**\n * VMError definition.\n */\n\nclass VMError extends Error {\n\tconstructor(message, code) {\n\t\tsuper(message);\n\n\t\tthis.name = 'VMError';\n\t\tthis.code = code;\n\n\t\tcaptureStackTrace(this, this.constructor);\n\t}\n}\n\nglobal.VMError = VMError;\n\n/*\n * This function will throw a TypeError for accessing properties\n * on a strict mode function\n */\nfunction throwCallerCalleeArgumentsAccess(key) {\n\t'use strict';\n\tthrowCallerCalleeArgumentsAccess[key];\n\treturn new VMError('Unreachable');\n}\n\nfunction unexpected() {\n\tthrow new VMError('Should not happen');\n}\n\nfunction doPreventExtensions(target, object, doProxy) {\n\tconst keys = local.Reflect.ownKeys(object);\n\tfor (let i = 0; i < keys.length; i++) {\n\t\tconst key = keys[i];\n\t\tlet desc = local.Reflect.getOwnPropertyDescriptor(object, key);\n\t\tif (!desc) continue;\n\t\tif (!local.Reflect.setPrototypeOf(desc, null)) unexpected();\n\t\tif (!desc.configurable) {\n\t\t\tconst current = local.Reflect.getOwnPropertyDescriptor(target, key);\n\t\t\tif (current && !current.configurable) continue;\n\t\t\tif (desc.get || desc.set) {\n\t\t\t\tdesc.get = doProxy(desc.get);\n\t\t\t\tdesc.set = doProxy(desc.set);\n\t\t\t} else {\n\t\t\t\tdesc.value = doProxy(desc.value);\n\t\t\t}\n\t\t} else {\n\t\t\tif (desc.get || desc.set) {\n\t\t\t\tdesc = {\n\t\t\t\t\t__proto__: null,\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\tenumerable: desc.enumerable,\n\t\t\t\t\twritable: true,\n\t\t\t\t\tvalue: null\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tdesc.value = null;\n\t\t\t}\n\t\t}\n\t\tif (!local.Reflect.defineProperty(target, key, desc)) unexpected();\n\t}\n\tif (!local.Reflect.preventExtensions(target)) unexpected();\n}\n\n/**\n * Decontextify.\n */\n\nconst Decontextify = host.Object.create(null);\nDecontextify.proxies = new host.WeakMap();\n\nDecontextify.arguments = args => {\n\tif (!host.Array.isArray(args)) return new host.Array();\n\n\ttry {\n\t\tconst arr = new host.Array();\n\t\tfor (let i = 0, l = args.length; i < l; i++) arr[i] = Decontextify.value(args[i]);\n\t\treturn arr;\n\t} catch (e) {\n\t\t// Never pass the handled exception through!\n\t\treturn new host.Array();\n\t}\n};\nDecontextify.instance = (instance, klass, deepTraps, flags, toStringTag) => {\n\tif (typeof instance === 'function') return Decontextify.function(instance);\n\n\t// We must not use normal object because there's a chance object already contains malicious code in the prototype\n\tconst base = host.Object.create(null);\n\n\tbase.get = (target, key, receiver) => {\n\t\ttry {\n\t\t\tif (key === 'vmProxyTarget' && DEBUG) return instance;\n\t\t\tif (key === 'isVMProxy') return true;\n\t\t\tif (key === 'constructor') return klass;\n\t\t\tif (key === '__proto__') return klass.prototype;\n\t\t} catch (e) {\n\t\t\t// Never pass the handled exception through! This block can't throw an exception under normal conditions.\n\t\t\treturn null;\n\t\t}\n\n\t\tif (key === '__defineGetter__') return host.Object.prototype.__defineGetter__;\n\t\tif (key === '__defineSetter__') return host.Object.prototype.__defineSetter__;\n\t\tif (key === '__lookupGetter__') return host.Object.prototype.__lookupGetter__;\n\t\tif (key === '__lookupSetter__') return host.Object.prototype.__lookupSetter__;\n\t\tif (key === host.Symbol.toStringTag && toStringTag) return toStringTag;\n\n\t\ttry {\n\t\t\treturn Decontextify.value(instance[key], null, deepTraps, flags);\n\t\t} catch (e) {\n\t\t\tthrow Decontextify.value(e);\n\t\t}\n\t};\n\tbase.getPrototypeOf = (target) => {\n\t\treturn klass && klass.prototype;\n\t};\n\n\treturn Decontextify.object(instance, base, deepTraps, flags);\n};\nDecontextify.function = (fnc, traps, deepTraps, flags, mock) => {\n\t// We must not use normal object because there's a chance object already contains malicious code in the prototype\n\tconst base = host.Object.create(null);\n\t// eslint-disable-next-line prefer-const\n\tlet proxy;\n\n\tbase.apply = (target, context, args) => {\n\t\tcontext = Contextify.value(context);\n\n\t\t// Set context of all arguments to vm's context.\n\t\targs = Contextify.arguments(args);\n\n\t\ttry {\n\t\t\treturn Decontextify.value(fnc.apply(context, args));\n\t\t} catch (e) {\n\t\t\tthrow Decontextify.value(e);\n\t\t}\n\t};\n\tbase.construct = (target, args, newTarget) => {\n\t\targs = Contextify.arguments(args);\n\n\t\ttry {\n\t\t\treturn Decontextify.instance(new fnc(...args), proxy, deepTraps, flags);\n\t\t} catch (e) {\n\t\t\tthrow Decontextify.value(e);\n\t\t}\n\t};\n\tbase.get = (target, key, receiver) => {\n\t\ttry {\n\t\t\tif (key === 'vmProxyTarget' && DEBUG) return fnc;\n\t\t\tif (key === 'isVMProxy') return true;\n\t\t\tif (mock && host.Object.prototype.hasOwnProperty.call(mock, key)) return mock[key];\n\t\t\tif (key === 'constructor') return host.Function;\n\t\t\tif (key === '__proto__') return host.Function.prototype;\n\t\t} catch (e) {\n\t\t\t// Never pass the handled exception through! This block can't throw an exception under normal conditions.\n\t\t\treturn null;\n\t\t}\n\n\t\tif (key === '__defineGetter__') return host.Object.prototype.__defineGetter__;\n\t\tif (key === '__defineSetter__') return host.Object.prototype.__defineSetter__;\n\t\tif (key === '__lookupGetter__') return host.Object.prototype.__lookupGetter__;\n\t\tif (key === '__lookupSetter__') return host.Object.prototype.__lookupSetter__;\n\n\t\ttry {\n\t\t\treturn Decontextify.value(fnc[key], null, deepTraps, flags);\n\t\t} catch (e) {\n\t\t\tthrow Decontextify.value(e);\n\t\t}\n\t};\n\tbase.getPrototypeOf = (target) => {\n\t\treturn host.Function.prototype;\n\t};\n\n\tproxy = Decontextify.object(fnc, host.Object.assign(base, traps), deepTraps);\n\treturn proxy;\n};\nDecontextify.object = (object, traps, deepTraps, flags, mock) => {\n\t// We must not use normal object because there's a chance object already contains malicious code in the prototype\n\tconst base = host.Object.create(null);\n\n\tbase.get = (target, key, receiver) => {\n\t\ttry {\n\t\t\tif (key === 'vmProxyTarget' && DEBUG) return object;\n\t\t\tif (key === 'isVMProxy') return true;\n\t\t\tif (mock && host.Object.prototype.hasOwnProperty.call(mock, key)) return mock[key];\n\t\t\tif (key === 'constructor') return host.Object;\n\t\t\tif (key === '__proto__') return host.Object.prototype;\n\t\t} catch (e) {\n\t\t\t// Never pass the handled exception through! This block can't throw an exception under normal conditions.\n\t\t\treturn null;\n\t\t}\n\n\t\tif (key === '__defineGetter__') return host.Object.prototype.__defineGetter__;\n\t\tif (key === '__defineSetter__') return host.Object.prototype.__defineSetter__;\n\t\tif (key === '__lookupGetter__') return host.Object.prototype.__lookupGetter__;\n\t\tif (key === '__lookupSetter__') return host.Object.prototype.__lookupSetter__;\n\n\t\ttry {\n\t\t\treturn Decontextify.value(object[key], null, deepTraps, flags);\n\t\t} catch (e) {\n\t\t\tthrow Decontextify.value(e);\n\t\t}\n\t};\n\tbase.set = (target, key, value, receiver) => {\n\t\tvalue = Contextify.value(value);\n\n\t\ttry {\n\t\t\treturn local.Reflect.set(object, key, value);\n\t\t} catch (e) {\n\t\t\tthrow Decontextify.value(e);\n\t\t}\n\t};\n\tbase.getOwnPropertyDescriptor = (target, prop) => {\n\t\tlet def;\n\n\t\ttry {\n\t\t\tdef = host.Object.getOwnPropertyDescriptor(object, prop);\n\t\t} catch (e) {\n\t\t\tthrow Decontextify.value(e);\n\t\t}\n\n\t\t// Following code prevents V8 to throw\n\t\t// TypeError: 'getOwnPropertyDescriptor' on proxy: trap reported non-configurability for property '<prop>'\n\t\t// which is either non-existant or configurable in the proxy target\n\n\t\tlet desc;\n\t\tif (!def) {\n\t\t\treturn undefined;\n\t\t} else if (def.get || def.set) {\n\t\t\tdesc = {\n\t\t\t\t__proto__: null,\n\t\t\t\tget: Decontextify.value(def.get) || undefined,\n\t\t\t\tset: Decontextify.value(def.set) || undefined,\n\t\t\t\tenumerable: def.enumerable === true,\n\t\t\t\tconfigurable: def.configurable === true\n\t\t\t};\n\t\t} else {\n\t\t\tdesc = {\n\t\t\t\t__proto__: null,\n\t\t\t\tvalue: Decontextify.value(def.value),\n\t\t\t\twritable: def.writable === true,\n\t\t\t\tenumerable: def.enumerable === true,\n\t\t\t\tconfigurable: def.configurable === true\n\t\t\t};\n\t\t}\n\t\tif (!desc.configurable) {\n\t\t\ttry {\n\t\t\t\tdef = host.Object.getOwnPropertyDescriptor(target, prop);\n\t\t\t\tif (!def || def.configurable || def.writable !== desc.writable) {\n\t\t\t\t\tlocal.Reflect.defineProperty(target, prop, desc);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t// Should not happen.\n\t\t\t}\n\t\t}\n\t\treturn desc;\n\t};\n\tbase.defineProperty = (target, key, descriptor) => {\n\t\tlet success = false;\n\t\ttry {\n\t\t\tsuccess = local.Reflect.setPrototypeOf(descriptor, null);\n\t\t} catch (e) {\n\t\t\t// Should not happen\n\t\t}\n\t\tif (!success) return false;\n\t\t// There's a chance accessing a property throws an error so we must not access them\n\t\t// in try catch to prevent contextifying local objects.\n\n\t\tconst propertyDescriptor = host.Object.create(null);\n\t\tif (descriptor.get || descriptor.set) {\n\t\t\tpropertyDescriptor.get = Contextify.value(descriptor.get, null, deepTraps, flags) || undefined;\n\t\t\tpropertyDescriptor.set = Contextify.value(descriptor.set, null, deepTraps, flags) || undefined;\n\t\t\tpropertyDescriptor.enumerable = descriptor.enumerable === true;\n\t\t\tpropertyDescriptor.configurable = descriptor.configurable === true;\n\t\t} else {\n\t\t\tpropertyDescriptor.value = Contextify.value(descriptor.value, null, deepTraps, flags);\n\t\t\tpropertyDescriptor.writable = descriptor.writable === true;\n\t\t\tpropertyDescriptor.enumerable = descriptor.enumerable === true;\n\t\t\tpropertyDescriptor.configurable = descriptor.configurable === true;\n\t\t}\n\n\t\ttry {\n\t\t\tsuccess = local.Reflect.defineProperty(object, key, propertyDescriptor);\n\t\t} catch (e) {\n\t\t\tthrow Decontextify.value(e);\n\t\t}\n\t\tif (success && !descriptor.configurable) {\n\t\t\ttry {\n\t\t\t\tlocal.Reflect.defineProperty(target, key, descriptor);\n\t\t\t} catch (e) {\n\t\t\t\t// This should not happen.\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn success;\n\t};\n\tbase.deleteProperty = (target, prop) => {\n\t\ttry {\n\t\t\treturn Decontextify.value(local.Reflect.deleteProperty(object, prop));\n\t\t} catch (e) {\n\t\t\tthrow Decontextify.value(e);\n\t\t}\n\t};\n\tbase.getPrototypeOf = (target) => {\n\t\treturn host.Object.prototype;\n\t};\n\tbase.setPrototypeOf = (target) => {\n\t\tthrow new host.Error(OPNA);\n\t};\n\tbase.has = (target, key) => {\n\t\ttry {\n\t\t\treturn Decontextify.value(local.Reflect.has(object, key));\n\t\t} catch (e) {\n\t\t\tthrow Decontextify.value(e);\n\t\t}\n\t};\n\tbase.isExtensible = target => {\n\t\tlet result;\n\t\ttry {\n\t\t\tresult = local.Reflect.isExtensible(object);\n\t\t} catch (e) {\n\t\t\tthrow Decontextify.value(e);\n\t\t}\n\t\tif (!result) {\n\t\t\ttry {\n\t\t\t\tif (local.Reflect.isExtensible(target)) {\n\t\t\t\t\tdoPreventExtensions(target, object, obj => Contextify.value(obj, null, deepTraps, flags));\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t// Should not happen\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t};\n\tbase.ownKeys = target => {\n\t\ttry {\n\t\t\treturn Decontextify.value(local.Reflect.ownKeys(object));\n\t\t} catch (e) {\n\t\t\tthrow Decontextify.value(e);\n\t\t}\n\t};\n\tbase.preventExtensions = target => {\n\t\tlet success;\n\t\ttry {\n\t\t\tsuccess = local.Reflect.preventExtensions(object);\n\t\t} catch (e) {\n\t\t\tthrow Decontextify.value(e);\n\t\t}\n\t\tif (success) {\n\t\t\ttry {\n\t\t\t\tif (local.Reflect.isExtensible(target)) {\n\t\t\t\t\tdoPreventExtensions(target, object, obj => Contextify.value(obj, null, deepTraps, flags));\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t// Should not happen\n\t\t\t}\n\t\t}\n\t\treturn success;\n\t};\n\tbase.enumerate = target => {\n\t\ttry {\n\t\t\treturn Decontextify.value(local.Reflect.enumerate(object));\n\t\t} catch (e) {\n\t\t\tthrow Decontextify.value(e);\n\t\t}\n\t};\n\n\thost.Object.assign(base, traps, deepTraps);\n\n\tlet shallow;\n\tif (host.Array.isArray(object)) {\n\t\tconst origGet = base.get;\n\t\tshallow = {\n\t\t\t__proto__: null,\n\t\t\townKeys: base.ownKeys,\n\t\t\t// TODO this get will call getOwnPropertyDescriptor of target all the time.\n\t\t\tget: origGet\n\t\t};\n\t\tbase.ownKeys = target => {\n\t\t\ttry {\n\t\t\t\tconst keys = local.Reflect.ownKeys(object);\n\t\t\t\t// Do this hack so that console.log(decontextify([1,2,3])) doesn't write the properties twice\n\t\t\t\t// a la [1,2,3,'0':1,'1':2,'2':3]\n\t\t\t\treturn Decontextify.value(keys.filter(key=>typeof key!=='string' || !key.match(/^\\d+$/)));\n\t\t\t} catch (e) {\n\t\t\t\tthrow Decontextify.value(e);\n\t\t\t}\n\t\t};\n\t\tbase.get = (target, key, receiver) => {\n\t\t\tif (key === host.Symbol.toStringTag) return;\n\t\t\treturn origGet(target, key, receiver);\n\t\t};\n\t} else {\n\t\tshallow = SHARED_OBJECT;\n\t}\n\n\tconst proxy = new host.Proxy(createBaseObject(object), base);\n\tDecontextified.set(proxy, object);\n\t// We need two proxies since nodes inspect just removes one.\n\tconst proxy2 = new host.Proxy(proxy, shallow);\n\tDecontextify.proxies.set(object, proxy2);\n\tDecontextified.set(proxy2, object);\n\treturn proxy2;\n};\nDecontextify.value = (value, traps, deepTraps, flags, mock) => {\n\ttry {\n\t\tif (Contextified.has(value)) {\n\t\t\t// Contextified object has returned back from vm\n\t\t\treturn Contextified.get(value);\n\t\t} else if (Decontextify.proxies.has(value)) {\n\t\t\t// Decontextified proxy already exists, reuse\n\t\t\treturn Decontextify.proxies.get(value);\n\t\t}\n\n\t\tswitch (typeof value) {\n\t\t\tcase 'object':\n\t\t\t\tif (value === null) {\n\t\t\t\t\treturn null;\n\t\t\t\t} else if (instanceOf(value, Number))         { return Decontextify.instance(value, host.Number, deepTraps, flags, 'Number');\n\t\t\t\t} else if (instanceOf(value, String))         { return Decontextify.instance(value, host.String, deepTraps, flags, 'String');\n\t\t\t\t} else if (instanceOf(value, Boolean))        { return Decontextify.instance(value, host.Boolean, deepTraps, flags, 'Boolean');\n\t\t\t\t} else if (instanceOf(value, Date))           { return Decontextify.instance(value, host.Date, deepTraps, flags, 'Date');\n\t\t\t\t} else if (instanceOf(value, RangeError))     { return Decontextify.instance(value, host.RangeError, deepTraps, flags, 'Error');\n\t\t\t\t} else if (instanceOf(value, ReferenceError)) { return Decontextify.instance(value, host.ReferenceError, deepTraps, flags, 'Error');\n\t\t\t\t} else if (instanceOf(value, SyntaxError))    { return Decontextify.instance(value, host.SyntaxError, deepTraps, flags, 'Error');\n\t\t\t\t} else if (instanceOf(value, TypeError))      { return Decontextify.instance(value, host.TypeError, deepTraps, flags, 'Error');\n\t\t\t\t} else if (instanceOf(value, VMError))        { return Decontextify.instance(value, host.VMError, deepTraps, flags, 'Error');\n\t\t\t\t} else if (instanceOf(value, EvalError))      { return Decontextify.instance(value, host.EvalError, deepTraps, flags, 'Error');\n\t\t\t\t} else if (instanceOf(value, URIError))       { return Decontextify.instance(value, host.URIError, deepTraps, flags, 'Error');\n\t\t\t\t} else if (instanceOf(value, Error))          { return Decontextify.instance(value, host.Error, deepTraps, flags, 'Error');\n\t\t\t\t} else if (instanceOf(value, Array))          { return Decontextify.instance(value, host.Array, deepTraps, flags, 'Array');\n\t\t\t\t} else if (instanceOf(value, RegExp))         { return Decontextify.instance(value, host.RegExp, deepTraps, flags, 'RegExp');\n\t\t\t\t} else if (instanceOf(value, Map))            { return Decontextify.instance(value, host.Map, deepTraps, flags, 'Map');\n\t\t\t\t} else if (instanceOf(value, WeakMap))        { return Decontextify.instance(value, host.WeakMap, deepTraps, flags, 'WeakMap');\n\t\t\t\t} else if (instanceOf(value, Set))            { return Decontextify.instance(value, host.Set, deepTraps, flags, 'Set');\n\t\t\t\t} else if (instanceOf(value, WeakSet))        { return Decontextify.instance(value, host.WeakSet, deepTraps, flags, 'WeakSet');\n\t\t\t\t} else if (typeof Promise === 'function' && instanceOf(value, Promise)) {\n\t\t\t\t\treturn Decontextify.instance(value, host.Promise, deepTraps, flags, 'Promise');\n\t\t\t\t} else if (local.Reflect.getPrototypeOf(value) === null) {\n\t\t\t\t\treturn Decontextify.instance(value, null, deepTraps, flags);\n\t\t\t\t} else {\n\t\t\t\t\treturn Decontextify.object(value, traps, deepTraps, flags, mock);\n\t\t\t\t}\n\t\t\tcase 'function':\n\t\t\t\treturn Decontextify.function(value, traps, deepTraps, flags, mock);\n\n\t\t\tcase 'undefined':\n\t\t\t\treturn undefined;\n\n\t\t\tdefault: // string, number, boolean, symbol\n\t\t\t\treturn value;\n\t\t}\n\t} catch (ex) {\n\t\t// Never pass the handled exception through! This block can't throw an exception under normal conditions.\n\t\treturn null;\n\t}\n};\n\n/**\n * Contextify.\n */\n\nconst Contextify = host.Object.create(null);\nContextify.proxies = new host.WeakMap();\n\nContextify.arguments = args => {\n\tif (!host.Array.isArray(args)) return new local.Array();\n\n\ttry {\n\t\tconst arr = new local.Array();\n\t\tfor (let i = 0, l = args.length; i < l; i++) arr[i] = Contextify.value(args[i]);\n\t\treturn arr;\n\t} catch (e) {\n\t\t// Never pass the handled exception through!\n\t\treturn new local.Array();\n\t}\n};\nContextify.instance = (instance, klass, deepTraps, flags, toStringTag) => {\n\tif (typeof instance === 'function') return Contextify.function(instance);\n\n\t// We must not use normal object because there's a chance object already contains malicious code in the prototype\n\tconst base = host.Object.create(null);\n\n\tbase.get = (target, key, receiver) => {\n\t\ttry {\n\t\t\tif (key === 'vmProxyTarget' && DEBUG) return instance;\n\t\t\tif (key === 'isVMProxy') return true;\n\t\t\tif (key === 'constructor') return klass;\n\t\t\tif (key === '__proto__') return klass.prototype;\n\t\t} catch (e) {\n\t\t\t// Never pass the handled exception through! This block can't throw an exception under normal conditions.\n\t\t\treturn null;\n\t\t}\n\n\t\tif (key === '__defineGetter__') return local.Object.prototype.__defineGetter__;\n\t\tif (key === '__defineSetter__') return local.Object.prototype.__defineSetter__;\n\t\tif (key === '__lookupGetter__') return local.Object.prototype.__lookupGetter__;\n\t\tif (key === '__lookupSetter__') return local.Object.prototype.__lookupSetter__;\n\t\tif (key === host.Symbol.toStringTag && toStringTag) return toStringTag;\n\n\t\ttry {\n\t\t\treturn Contextify.value(host.Reflect.get(instance, key), null, deepTraps, flags);\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\t};\n\tbase.getPrototypeOf = (target) => {\n\t\treturn klass && klass.prototype;\n\t};\n\n\treturn Contextify.object(instance, base, deepTraps, flags);\n};\nContextify.function = (fnc, traps, deepTraps, flags, mock) => {\n\t// We must not use normal object because there's a chance object already contains malicious code in the prototype\n\tconst base = host.Object.create(null);\n\t// eslint-disable-next-line prefer-const\n\tlet proxy;\n\n\tbase.apply = (target, context, args) => {\n\t\t// Fixes buffer unsafe allocation for node v6/7\n\t\tif (host.version < 8 && fnc === host.Buffer && 'number' === typeof args[0]) {\n\t\t\targs[0] = new local.Array(args[0]).fill(0);\n\t\t}\n\n\t\tcontext = Decontextify.value(context);\n\n\t\t// Set context of all arguments to host's context.\n\t\targs = Decontextify.arguments(args);\n\n\t\ttry {\n\t\t\treturn Contextify.value(fnc.apply(context, args));\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\t};\n\tbase.construct = (target, args, newTarget) => {\n\t\t// Fixes buffer unsafe allocation for node v6/7\n\t\tif (host.version < 8 && fnc === host.Buffer && 'number' === typeof args[0]) {\n\t\t\targs[0] = new local.Array(args[0]).fill(0);\n\t\t}\n\n\t\targs = Decontextify.arguments(args);\n\n\t\ttry {\n\t\t\treturn Contextify.instance(new fnc(...args), proxy, deepTraps, flags);\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\t};\n\tbase.get = (target, key, receiver) => {\n\t\ttry {\n\t\t\tif (key === 'vmProxyTarget' && DEBUG) return fnc;\n\t\t\tif (key === 'isVMProxy') return true;\n\t\t\tif (mock && host.Object.prototype.hasOwnProperty.call(mock, key)) return mock[key];\n\t\t\tif (key === 'constructor') return Function;\n\t\t\tif (key === '__proto__') return Function.prototype;\n\t\t} catch (e) {\n\t\t\t// Never pass the handled exception through! This block can't throw an exception under normal conditions.\n\t\t\treturn null;\n\t\t}\n\n\t\tif (key === '__defineGetter__') return local.Object.prototype.__defineGetter__;\n\t\tif (key === '__defineSetter__') return local.Object.prototype.__defineSetter__;\n\t\tif (key === '__lookupGetter__') return local.Object.prototype.__lookupGetter__;\n\t\tif (key === '__lookupSetter__') return local.Object.prototype.__lookupSetter__;\n\n\t\tif (key === 'caller' || key === 'callee' || key === 'arguments') throw throwCallerCalleeArgumentsAccess(key);\n\n\t\ttry {\n\t\t\treturn Contextify.value(host.Reflect.get(fnc, key), null, deepTraps, flags);\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\t};\n\tbase.getPrototypeOf = (target) => {\n\t\treturn Function.prototype;\n\t};\n\n\tproxy = Contextify.object(fnc, host.Object.assign(base, traps), deepTraps);\n\treturn proxy;\n};\nContextify.object = (object, traps, deepTraps, flags, mock) => {\n\t// We must not use normal object because there's a chance object already contains malicious code in the prototype\n\tconst base = host.Object.create(null);\n\n\tbase.get = (target, key, receiver) => {\n\t\ttry {\n\t\t\tif (key === 'vmProxyTarget' && DEBUG) return object;\n\t\t\tif (key === 'isVMProxy') return true;\n\t\t\tif (mock && host.Object.prototype.hasOwnProperty.call(mock, key)) return mock[key];\n\t\t\tif (key === 'constructor') return Object;\n\t\t\tif (key === '__proto__') return Object.prototype;\n\t\t} catch (e) {\n\t\t\t// Never pass the handled exception through! This block can't throw an exception under normal conditions.\n\t\t\treturn null;\n\t\t}\n\n\t\tif (key === '__defineGetter__') return local.Object.prototype.__defineGetter__;\n\t\tif (key === '__defineSetter__') return local.Object.prototype.__defineSetter__;\n\t\tif (key === '__lookupGetter__') return local.Object.prototype.__lookupGetter__;\n\t\tif (key === '__lookupSetter__') return local.Object.prototype.__lookupSetter__;\n\n\t\ttry {\n\t\t\treturn Contextify.value(host.Reflect.get(object, key), null, deepTraps, flags);\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\t};\n\tbase.set = (target, key, value, receiver) => {\n\t\tif (key === '__proto__') return false;\n\t\tif (flags && flags.protected && typeof value === 'function') return false;\n\n\t\tvalue = Decontextify.value(value);\n\n\t\ttry {\n\t\t\treturn host.Reflect.set(object, key, value);\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\t};\n\tbase.getOwnPropertyDescriptor = (target, prop) => {\n\t\tlet def;\n\n\t\ttry {\n\t\t\tdef = host.Object.getOwnPropertyDescriptor(object, prop);\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\n\t\t// Following code prevents V8 to throw\n\t\t// TypeError: 'getOwnPropertyDescriptor' on proxy: trap reported non-configurability for property '<prop>'\n\t\t// which is either non-existant or configurable in the proxy target\n\n\t\tlet desc;\n\t\tif (!def) {\n\t\t\treturn undefined;\n\t\t} else if (def.get || def.set) {\n\t\t\tdesc = {\n\t\t\t\t__proto__: null,\n\t\t\t\tget: Contextify.value(def.get, null, deepTraps, flags) || undefined,\n\t\t\t\tset: Contextify.value(def.set, null, deepTraps, flags) || undefined,\n\t\t\t\tenumerable: def.enumerable === true,\n\t\t\t\tconfigurable: def.configurable === true\n\t\t\t};\n\t\t} else {\n\t\t\tdesc = {\n\t\t\t\t__proto__: null,\n\t\t\t\tvalue: Contextify.value(def.value, null, deepTraps, flags),\n\t\t\t\twritable: def.writable === true,\n\t\t\t\tenumerable: def.enumerable === true,\n\t\t\t\tconfigurable: def.configurable === true\n\t\t\t};\n\t\t}\n\t\tif (!desc.configurable) {\n\t\t\ttry {\n\t\t\t\tdef = host.Object.getOwnPropertyDescriptor(target, prop);\n\t\t\t\tif (!def || def.configurable || def.writable !== desc.writable) {\n\t\t\t\t\tlocal.Reflect.defineProperty(target, prop, desc);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t// Should not happen.\n\t\t\t}\n\t\t}\n\t\treturn desc;\n\t};\n\tbase.defineProperty = (target, key, descriptor) => {\n\t\tlet success = false;\n\t\ttry {\n\t\t\tsuccess = local.Reflect.setPrototypeOf(descriptor, null);\n\t\t} catch (e) {\n\t\t\t// Should not happen\n\t\t}\n\t\tif (!success) return false;\n\t\t// There's a chance accessing a property throws an error so we must not access them\n\t\t// in try catch to prevent contextifying local objects.\n\n\t\tconst descGet = descriptor.get;\n\t\tconst descSet = descriptor.set;\n\t\tconst descValue = descriptor.value;\n\n\t\tif (flags && flags.protected) {\n\t\t\tif (descGet || descSet || typeof descValue === 'function') return false;\n\t\t}\n\n\t\tconst propertyDescriptor = host.Object.create(null);\n\t\tif (descGet || descSet) {\n\t\t\tpropertyDescriptor.get = Decontextify.value(descGet, null, deepTraps, flags) || undefined;\n\t\t\tpropertyDescriptor.set = Decontextify.value(descSet, null, deepTraps, flags) || undefined;\n\t\t\tpropertyDescriptor.enumerable = descriptor.enumerable === true;\n\t\t\tpropertyDescriptor.configurable = descriptor.configurable === true;\n\t\t} else {\n\t\t\tpropertyDescriptor.value = Decontextify.value(descValue, null, deepTraps, flags);\n\t\t\tpropertyDescriptor.writable = descriptor.writable === true;\n\t\t\tpropertyDescriptor.enumerable = descriptor.enumerable === true;\n\t\t\tpropertyDescriptor.configurable = descriptor.configurable === true;\n\t\t}\n\n\t\ttry {\n\t\t\tsuccess = host.Reflect.defineProperty(object, key, propertyDescriptor);\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\t\tif (success && !descriptor.configurable) {\n\t\t\ttry {\n\t\t\t\tlocal.Reflect.defineProperty(target, key, descriptor);\n\t\t\t} catch (e) {\n\t\t\t\t// This should not happen.\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn success;\n\t};\n\tbase.deleteProperty = (target, prop) => {\n\t\ttry {\n\t\t\treturn Contextify.value(host.Reflect.deleteProperty(object, prop));\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\t};\n\tbase.getPrototypeOf = (target) => {\n\t\treturn local.Object.prototype;\n\t};\n\tbase.setPrototypeOf = (target) => {\n\t\tthrow new VMError(OPNA);\n\t};\n\tbase.has = (target, key) => {\n\t\ttry {\n\t\t\treturn Contextify.value(host.Reflect.has(object, key));\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\t};\n\tbase.isExtensible = target => {\n\t\tlet result;\n\t\ttry {\n\t\t\tresult = host.Reflect.isExtensible(object);\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\t\tif (!result) {\n\t\t\ttry {\n\t\t\t\tif (local.Reflect.isExtensible(target)) {\n\t\t\t\t\tdoPreventExtensions(target, object, obj => Decontextify.value(obj, null, deepTraps, flags));\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t// Should not happen\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t};\n\tbase.ownKeys = target => {\n\t\ttry {\n\t\t\treturn Contextify.value(host.Reflect.ownKeys(object));\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\t};\n\tbase.preventExtensions = target => {\n\t\tlet success;\n\t\ttry {\n\t\t\tsuccess = local.Reflect.preventExtensions(object);\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\t\tif (success) {\n\t\t\ttry {\n\t\t\t\tif (local.Reflect.isExtensible(target)) {\n\t\t\t\t\tdoPreventExtensions(target, object, obj => Decontextify.value(obj, null, deepTraps, flags));\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t// Should not happen\n\t\t\t}\n\t\t}\n\t\treturn success;\n\t};\n\tbase.enumerate = target => {\n\t\ttry {\n\t\t\treturn Contextify.value(host.Reflect.enumerate(object));\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\t};\n\n\tconst proxy = new host.Proxy(createBaseObject(object), host.Object.assign(base, traps, deepTraps));\n\tContextify.proxies.set(object, proxy);\n\tContextified.set(proxy, object);\n\treturn proxy;\n};\nContextify.value = (value, traps, deepTraps, flags, mock) => {\n\ttry {\n\t\tif (Decontextified.has(value)) {\n\t\t\t// Decontextified object has returned back to vm\n\t\t\treturn Decontextified.get(value);\n\t\t} else if (Contextify.proxies.has(value)) {\n\t\t\t// Contextified proxy already exists, reuse\n\t\t\treturn Contextify.proxies.get(value);\n\t\t}\n\n\t\tswitch (typeof value) {\n\t\t\tcase 'object':\n\t\t\t\tif (value === null) {\n\t\t\t\t\treturn null;\n\t\t\t\t} else if (instanceOf(value, host.Number))         { return Contextify.instance(value, Number, deepTraps, flags, 'Number');\n\t\t\t\t} else if (instanceOf(value, host.String))         { return Contextify.instance(value, String, deepTraps, flags, 'String');\n\t\t\t\t} else if (instanceOf(value, host.Boolean))        { return Contextify.instance(value, Boolean, deepTraps, flags, 'Boolean');\n\t\t\t\t} else if (instanceOf(value, host.Date))           { return Contextify.instance(value, Date, deepTraps, flags, 'Date');\n\t\t\t\t} else if (instanceOf(value, host.RangeError))     { return Contextify.instance(value, RangeError, deepTraps, flags, 'Error');\n\t\t\t\t} else if (instanceOf(value, host.ReferenceError)) { return Contextify.instance(value, ReferenceError, deepTraps, flags, 'Error');\n\t\t\t\t} else if (instanceOf(value, host.SyntaxError))    { return Contextify.instance(value, SyntaxError, deepTraps, flags, 'Error');\n\t\t\t\t} else if (instanceOf(value, host.TypeError))      { return Contextify.instance(value, TypeError, deepTraps, flags, 'Error');\n\t\t\t\t} else if (instanceOf(value, host.VMError))        { return Contextify.instance(value, VMError, deepTraps, flags, 'Error');\n\t\t\t\t} else if (instanceOf(value, host.EvalError))      { return Contextify.instance(value, EvalError, deepTraps, flags, 'Error');\n\t\t\t\t} else if (instanceOf(value, host.URIError))       { return Contextify.instance(value, URIError, deepTraps, flags, 'Error');\n\t\t\t\t} else if (instanceOf(value, host.Error))          { return Contextify.instance(value, Error, deepTraps, flags, 'Error');\n\t\t\t\t} else if (instanceOf(value, host.Array))          { return Contextify.instance(value, Array, deepTraps, flags, 'Array');\n\t\t\t\t} else if (instanceOf(value, host.RegExp))         { return Contextify.instance(value, RegExp, deepTraps, flags, 'RegExp');\n\t\t\t\t} else if (instanceOf(value, host.Map))            { return Contextify.instance(value, Map, deepTraps, flags, 'Map');\n\t\t\t\t} else if (instanceOf(value, host.WeakMap))        { return Contextify.instance(value, WeakMap, deepTraps, flags, 'WeakMap');\n\t\t\t\t} else if (instanceOf(value, host.Set))            { return Contextify.instance(value, Set, deepTraps, flags, 'Set');\n\t\t\t\t} else if (instanceOf(value, host.WeakSet))        { return Contextify.instance(value, WeakSet, deepTraps, flags, 'WeakSet');\n\t\t\t\t} else if (typeof Promise === 'function' && instanceOf(value, host.Promise)) {\n\t\t\t\t\treturn Contextify.instance(value, Promise, deepTraps, flags, 'Promise');\n\t\t\t\t} else if (instanceOf(value, host.Buffer))         { return Contextify.instance(value, LocalBuffer, deepTraps, flags, 'Uint8Array');\n\t\t\t\t} else if (host.Reflect.getPrototypeOf(value) === null) {\n\t\t\t\t\treturn Contextify.instance(value, null, deepTraps, flags);\n\t\t\t\t} else {\n\t\t\t\t\treturn Contextify.object(value, traps, deepTraps, flags, mock);\n\t\t\t\t}\n\t\t\tcase 'function':\n\t\t\t\treturn Contextify.function(value, traps, deepTraps, flags, mock);\n\n\t\t\tcase 'undefined':\n\t\t\t\treturn undefined;\n\n\t\t\tdefault: // string, number, boolean, symbol\n\t\t\t\treturn value;\n\t\t}\n\t} catch (ex) {\n\t\t// Never pass the handled exception through! This block can't throw an exception under normal conditions.\n\t\treturn null;\n\t}\n};\nContextify.setGlobal = (name, value) => {\n\tconst prop = Contextify.value(name);\n\ttry {\n\t\tglobal[prop] = Contextify.value(value);\n\t} catch (e) {\n\t\tthrow Decontextify.value(e);\n\t}\n};\nContextify.getGlobal = (name) => {\n\tconst prop = Contextify.value(name);\n\ttry {\n\t\treturn Decontextify.value(global[prop]);\n\t} catch (e) {\n\t\tthrow Decontextify.value(e);\n\t}\n};\nContextify.readonly = (value, mock) => {\n\treturn Contextify.value(value, null, FROZEN_TRAPS, null, mock);\n};\nContextify.protected = (value, mock) => {\n\treturn Contextify.value(value, null, null, {protected: true}, mock);\n};\nContextify.connect = (outer, inner) => {\n\tDecontextified.set(outer, inner);\n\tContextified.set(inner, outer);\n};\nContextify.makeModule = ()=>({exports: {}});\nContextify.isVMProxy = (obj) => Decontextified.has(obj);\n\nconst BufferMock = host.Object.create(null);\nBufferMock.allocUnsafe = function allocUnsafe(size) {\n\treturn this.alloc(size);\n};\nBufferMock.allocUnsafeSlow = function allocUnsafeSlow(size) {\n\treturn this.alloc(size);\n};\nconst BufferOverride = host.Object.create(null);\nBufferOverride.inspect = function inspect(recurseTimes, ctx) {\n\t// Mimic old behavior, could throw but didn't pass a test.\n\tconst max = host.INSPECT_MAX_BYTES;\n\tconst actualMax = Math.min(max, this.length);\n\tconst remaining = this.length - max;\n\tlet str = this.hexSlice(0, actualMax).replace(/(.{2})/g, '$1 ').trim();\n\tif (remaining > 0) str += ` ... ${remaining} more byte${remaining > 1 ? 's' : ''}`;\n\treturn `<${this.constructor.name} ${str}>`;\n};\nconst LocalBuffer = global.Buffer = Contextify.readonly(host.Buffer, BufferMock);\nContextify.connect(host.Buffer.prototype.inspect, BufferOverride.inspect);\nContextify.connect(host.Function.prototype.bind, Function.prototype.bind);\n\nconst oldPrepareStackTraceDesc = Reflect.getOwnPropertyDescriptor(Error, 'prepareStackTrace');\n\nlet currentPrepareStackTrace = Error.prepareStackTrace;\nconst wrappedPrepareStackTrace = new host.WeakMap();\nif (typeof currentPrepareStackTrace === 'function') {\n\twrappedPrepareStackTrace.set(currentPrepareStackTrace, currentPrepareStackTrace);\n}\n\nlet OriginalCallSite;\nError.prepareStackTrace = (e, sst) => {\n\tOriginalCallSite = sst[0].constructor;\n};\nnew Error().stack;\nif (typeof OriginalCallSite === 'function') {\n\tError.prepareStackTrace = undefined;\n\n\tfunction makeCallSiteGetters(list) {\n\t\tconst callSiteGetters = [];\n\t\tfor (let i=0; i<list.length; i++) {\n\t\t\tconst name = list[i];\n\t\t\tconst func = OriginalCallSite.prototype[name];\n\t\t\tcallSiteGetters[i] = {__proto__: null,\n\t\t\t\tname,\n\t\t\t\tpropName: '_' + name,\n\t\t\t\tfunc: (thiz) => {\n\t\t\t\t\treturn local.Reflect.apply(func, thiz, []);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\treturn callSiteGetters;\n\t}\n\n\tfunction applyCallSiteGetters(callSite, getters) {\n\t\tconst properties = {__proto__: null};\n\t\tfor (let i=0; i<getters.length; i++) {\n\t\t\tconst getter = getters[i];\n\t\t\tproperties[getter.propName] = {\n\t\t\t\t__proto__: null,\n\t\t\t\tvalue: getter.func(callSite)\n\t\t\t};\n\t\t}\n\t\treturn properties;\n\t}\n\n\tconst callSiteGetters = makeCallSiteGetters([\n\t\t'getTypeName',\n\t\t'getFunctionName',\n\t\t'getMethodName',\n\t\t'getFileName',\n\t\t'getLineNumber',\n\t\t'getColumnNumber',\n\t\t'getEvalOrigin',\n\t\t'isToplevel',\n\t\t'isEval',\n\t\t'isNative',\n\t\t'isConstructor',\n\t\t'isAsync',\n\t\t'isPromiseAll',\n\t\t'getPromiseIndex'\n\t]);\n\n\tclass CallSite {\n\t\tconstructor(callSite) {\n\t\t\tObject.defineProperties(this, applyCallSiteGetters(callSite, callSiteGetters));\n\t\t}\n\t\tgetThis() {return undefined;}\n\t\tgetFunction() {return undefined;}\n\t\ttoString() {return 'CallSite {}';}\n\t}\n\n\t(function setupCallSite() {\n\t\tfor (let i=0; i<callSiteGetters.length; i++) {\n\t\t\tconst name = callSiteGetters[i].name;\n\t\t\tconst propertyName = callSiteGetters[i].propName;\n\t\t\tconst func = {func() {\n\t\t\t\treturn this[propertyName];\n\t\t\t}}.func;\n\t\t\tconst nameProp = Object.getOwnPropertyDescriptor(func, 'name');\n\t\t\tnameProp.value = name;\n\t\t\tObject.defineProperty(func, 'name', nameProp);\n\t\t\tconst funcProp = Object.getOwnPropertyDescriptor(OriginalCallSite.prototype, name);\n\t\t\tfuncProp.value = func;\n\t\t\tObject.defineProperty(CallSite.prototype, name, funcProp);\n\t\t}\n\t})();\n\n\tObject.defineProperty(Error, 'prepareStackTrace', {\n\t\tconfigurable: false,\n\t\tenumerable: false,\n\t\tget() {\n\t\t\treturn currentPrepareStackTrace;\n\t\t},\n\t\tset(value) {\n\t\t\tif (typeof(value) !== 'function') {\n\t\t\t\tcurrentPrepareStackTrace = value;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst wrapped = wrappedPrepareStackTrace.get(value);\n\t\t\tif (wrapped) {\n\t\t\t\tcurrentPrepareStackTrace = wrapped;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst newWrapped = (error, sst) => {\n\t\t\t\tif (host.Array.isArray(sst)) {\n\t\t\t\t\tfor (let i=0; i<sst.length; i++) {\n\t\t\t\t\t\tconst cs = sst[i];\n\t\t\t\t\t\tif (typeof cs === 'object' && local.Reflect.getPrototypeOf(cs) === OriginalCallSite.prototype) {\n\t\t\t\t\t\t\tsst[i] = new CallSite(cs);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn value(error, sst);\n\t\t\t};\n\t\t\twrappedPrepareStackTrace.set(value, newWrapped);\n\t\t\twrappedPrepareStackTrace.set(newWrapped, newWrapped);\n\t\t\tcurrentPrepareStackTrace = newWrapped;\n\t\t}\n\t});\n} else if (oldPrepareStackTraceDesc) {\n\tReflect.defineProperty(Error, 'prepareStackTrace', oldPrepareStackTraceDesc);\n} else {\n\tReflect.deleteProperty(Error, 'prepareStackTrace');\n}\n\n\nconst exportsMap = host.Object.create(null);\nexportsMap.Contextify = Contextify;\nexportsMap.Decontextify = Decontextify;\nexportsMap.Buffer = LocalBuffer;\nexportsMap.sandbox = Decontextify.value(global);\nexportsMap.Function = Function;\n\nreturn exportsMap;\n", "/* eslint-disable global-require, no-use-before-define */\n\n'use strict';\n\n/**\n * This callback will be called to transform a script to JavaScript.\n *\n * @callback compileCallback\n * @param {string} code - Script code to transform to JavaScript.\n * @param {string} filename - Filename of this script.\n * @return {string} JavaScript code that represents the script code.\n */\n\n/**\n * This callback will be called to resolve a module if it couldn't be found.\n *\n * @callback resolveCallback\n * @param {string} moduleName - Name of the module to resolve.\n * @param {string} dirname - Name of the current directory.\n * @return {(string|undefined)} The file or directory to use to load the requested module.\n */\n\nconst fs = require('fs');\nconst vm = require('vm');\nconst pa = require('path');\nconst {EventEmitter} = require('events');\nconst {INSPECT_MAX_BYTES} = require('buffer');\nconst helpers = require('./helpers.js');\nconst importModuleDynamically = () => {\n\t// We can't throw an error object here because since vm.Script doesn't store a context, we can't properly contextify that error object.\n\t// eslint-disable-next-line no-throw-literal\n\tthrow 'Dynamic imports are not allowed.';\n};\n\nconst MODULE_PREFIX = '(function (exports, require, module, __filename, __dirname) { ';\nconst STRICT_MODULE_PREFIX = MODULE_PREFIX + '\"use strict\"; ';\nconst MODULE_SUFFIX = '\\n});';\n\n/**\n * Load a script from a file and compile it.\n * \n * @private\n * @param {string} filename - File to load and compile to a script.\n * @param {string} prefix - Prefix for the script.\n * @param {string} suffix - Suffix for the script.\n * @return {vm.Script} The compiled script.\n */\nfunction loadAndCompileScript(filename, prefix, suffix) {\n\tconst data = fs.readFileSync(filename, 'utf8');\n\treturn new vm.Script(prefix + data + suffix, {\n\t\tfilename,\n\t\tdisplayErrors: false,\n\t\timportModuleDynamically\n\t});\n}\n\n/**\n * Cache where we can cache some things\n * \n * @private\n * @property {?compileCallback} coffeeScriptCompiler - The coffee script compiler or null if not yet used.\n * @property {?Object} timeoutContext - The context used for the timeout functionality of null if not yet used.\n * @property {?vm.Script} timeoutScript - The compiled script used for the timeout functionality of null if not yet used.\n * @property {vm.Script} contextifyScript - The compiled script used to setup a sandbox.\n * @property {?vm.Script} sandboxScript - The compiled script used to setup the NodeVM require mechanism of null if not yet used.\n * @property {?vm.Script} hookScript - The compiled script used to setup the async hooking functionality.\n * @property {?vm.Script} getGlobalScript - The compiled script used to get the global sandbox object.\n * @property {?vm.Script} getGeneratorFunctionScript - The compiled script used to get the generator function constructor.\n * @property {?vm.Script} getAsyncFunctionScript - The compiled script used to get the async function constructor.\n * @property {?vm.Script} getAsyncGeneratorFunctionScript - The compiled script used to get the async generator function constructor.\n */\nconst CACHE = {\n\tcoffeeScriptCompiler: null,\n\ttimeoutContext: null,\n\ttimeoutScript: null,\n\tcontextifyScript: loadAndCompileScript(`${__dirname}/contextify.js`, '(function(require, host) { ', '\\n})'),\n\tsandboxScript: null,\n\thookScript: null,\n\tgetGlobalScript: null,\n\tgetGeneratorFunctionScript: null,\n\tgetAsyncFunctionScript: null,\n\tgetAsyncGeneratorFunctionScript: null,\n};\n\n/**\n * Default run options for vm.Script.runInContext\n * \n * @private\n */\nconst DEFAULT_RUN_OPTIONS = {displayErrors: false, importModuleDynamically};\n\n/**\n * Returns the cached coffee script compiler or loads it\n * if it is not found in the cache.\n * \n * @private\n * @return {compileCallback} The coffee script compiler.\n * @throws {VMError} If the coffee-script module can't be found.\n */\nfunction getCoffeeScriptCompiler() {\n\tif (!CACHE.coffeeScriptCompiler) {\n\t\ttry {\n\t\t\tconst coffeeScript = require('coffee-script');\n\t\t\tCACHE.coffeeScriptCompiler = (code, filename) => {\n\t\t\t\treturn coffeeScript.compile(code, {header: false, bare: true});\n\t\t\t};\n\t\t} catch (e) {\n\t\t\tthrow new VMError('Coffee-Script compiler is not installed.');\n\t\t}\n\t}\n\treturn CACHE.coffeeScriptCompiler;\n}\n\n/**\n * The JavaScript compiler, just a identity function.\n * \n * @private\n * @type {compileCallback}\n * @param {string} code - The JavaScript code.\n * @param {string} filename - Filename of this script.\n * @return {string} The code.\n */\nfunction jsCompiler(code, filename) {\n\treturn removeShebang(code);\n}\n\n/**\n * Look up the compiler for a specific name.\n * \n * @private\n * @param {(string|compileCallback)} compiler - A compile callback or the name of the compiler.\n * @return {compileCallback} The resolved compiler.\n * @throws {VMError} If the compiler is unknown or the coffee script module was needed and couldn't be found.\n */\nfunction lookupCompiler(compiler) {\n\tif ('function' === typeof compiler) return compiler;\n\tswitch (compiler) {\n\t\tcase 'coffeescript':\n\t\tcase 'coffee-script':\n\t\tcase 'cs':\n\t\tcase 'text/coffeescript':\n\t\t\treturn getCoffeeScriptCompiler();\n\t\tcase 'javascript':\n\t\tcase 'java-script':\n\t\tcase 'js':\n\t\tcase 'text/javascript':\n\t\t\treturn jsCompiler;\n\t\tdefault:\n\t\t\tthrow new VMError(`Unsupported compiler '${compiler}'.`);\n\t}\n}\n\n/**\n * Remove the shebang from source code.\n * \n * @private\n * @param {string} code - Code from which to remove the shebang.\n * @return {string} code without the shebang.\n */\nfunction removeShebang(code) {\n\tif (!code.startsWith('#!')) return code;\n\treturn '//' + code.substr(2);\n}\n\n/**\n * Class Script\n *\n * @public\n */\nclass VMScript {\n\n\t/**\n\t * The script code with wrapping. If set will invalidate the cache.<br>\n\t * Writable only for backwards compatibility.\n\t * \n\t * @public\n\t * @readonly\n\t * @member {string} code\n\t * @memberOf VMScript#\n\t */\n\n\t/**\n\t * The filename used for this script.\n\t * \n\t * @public\n\t * @readonly\n\t * @since v3.9.0\n\t * @member {string} filename\n\t * @memberOf VMScript#\n\t */\n\n\t/**\n\t * The line offset use for stack traces.\n\t * \n\t * @public\n\t * @readonly\n\t * @since v3.9.0\n\t * @member {number} lineOffset\n\t * @memberOf VMScript#\n\t */\n\n\t/**\n\t * The column offset use for stack traces.\n\t * \n\t * @public\n\t * @readonly\n\t * @since v3.9.0\n\t * @member {number} columnOffset\n\t * @memberOf VMScript#\n\t */\n\n\t/**\n\t * The compiler to use to get the JavaScript code.\n\t * \n\t * @public\n\t * @readonly\n\t * @since v3.9.0\n\t * @member {(string|compileCallback)} compiler\n\t * @memberOf VMScript#\n\t */\n\n\t/**\n\t * The prefix for the script.\n\t * \n\t * @private\n\t * @member {string} _prefix\n\t * @memberOf VMScript#\n\t */\n\n\t/**\n\t * The suffix for the script.\n\t * \n\t * @private\n\t * @member {string} _suffix\n\t * @memberOf VMScript#\n\t */\n\n\t/**\n\t * The compiled vm.Script for the VM or if not compiled <code>null</code>.\n\t * \n\t * @private\n\t * @member {?vm.Script} _compiledVM\n\t * @memberOf VMScript#\n\t */\n\n\t/**\n\t * The compiled vm.Script for the NodeVM or if not compiled <code>null</code>.\n\t * \n\t * @private\n\t * @member {?vm.Script} _compiledNodeVM\n\t * @memberOf VMScript#\n\t */\n\n\t/**\n\t * The compiled vm.Script for the NodeVM in strict mode or if not compiled <code>null</code>.\n\t * \n\t * @private\n\t * @member {?vm.Script} _compiledNodeVMStrict\n\t * @memberOf VMScript#\n\t */\n\n\t/**\n\t * The resolved compiler to use to get the JavaScript code.\n\t * \n\t * @private\n\t * @readonly\n\t * @member {compileCallback} _compiler\n\t * @memberOf VMScript#\n\t */\n\n\t/**\n\t * The script to run without wrapping.\n\t * \n\t * @private\n\t * @member {string} _code\n\t * @memberOf VMScript#\n\t */\n\n\t/**\n\t * Create VMScript instance.\n\t *\n\t * @public\n\t * @param {string} code - Code to run.\n\t * @param {(string|Object)} [options] - Options map or filename.\n\t * @param {string} [options.filename=\"vm.js\"] - Filename that shows up in any stack traces produced from this script.\n\t * @param {number} [options.lineOffset=0] - Passed to vm.Script options.\n\t * @param {number} [options.columnOffset=0] - Passed to vm.Script options.\n\t * @param {(string|compileCallback)} [options.compiler=\"javascript\"] - The compiler to use.\n\t * @throws {VMError} If the compiler is unknown or if coffee-script was requested but the module not found.\n\t */\n\tconstructor(code, options) {\n\t\tconst sCode = `${code}`;\n\t\tlet useFileName;\n\t\tlet useOptions;\n\t\tif (arguments.length === 2) {\n\t\t\tif (typeof options === 'object' && options.toString === Object.prototype.toString) {\n\t\t\t\tuseOptions = options || {};\n\t\t\t\tuseFileName = useOptions.filename;\n\t\t\t} else {\n\t\t\t\tuseOptions = {};\n\t\t\t\tuseFileName = options;\n\t\t\t}\n\t\t} else if (arguments.length > 2) {\n\t\t\t// We do it this way so that there are no more arguments in the function.\n\t\t\t// eslint-disable-next-line prefer-rest-params\n\t\t\tuseOptions = arguments[2] || {};\n\t\t\tuseFileName = options || useOptions.filename;\n\t\t} else {\n\t\t\tuseOptions = {};\n\t\t}\n\n\t\tconst {\n\t\t\tcompiler = 'javascript',\n\t\t\tlineOffset = 0,\n\t\t\tcolumnOffset = 0\n\t\t} = useOptions;\n\n\t\t// Throw if the compiler is unknown.\n\t\tconst resolvedCompiler = lookupCompiler(compiler);\n\n\t\tObject.defineProperties(this, {\n\t\t\tcode: {\n\t\t\t\t// Put this here so that it is enumerable, and looks like a property.\n\t\t\t\tget() {\n\t\t\t\t\treturn this._prefix + this._code + this._suffix;\n\t\t\t\t},\n\t\t\t\tset(value) {\n\t\t\t\t\tconst strNewCode = String(value);\n\t\t\t\t\tif (strNewCode === this._code && this._prefix === '' && this._suffix === '') return;\n\t\t\t\t\tthis._code = strNewCode;\n\t\t\t\t\tthis._prefix = '';\n\t\t\t\t\tthis._suffix = '';\n\t\t\t\t\tthis._compiledVM = null;\n\t\t\t\t\tthis._compiledNodeVM = null;\n\t\t\t\t\tthis._compiledCode = null;\n\t\t\t\t},\n\t\t\t\tenumerable: true\n\t\t\t},\n\t\t\tfilename: {\n\t\t\t\tvalue: useFileName || 'vm.js',\n\t\t\t\tenumerable: true\n\t\t\t},\n\t\t\tlineOffset: {\n\t\t\t\tvalue: lineOffset,\n\t\t\t\tenumerable: true\n\t\t\t},\n\t\t\tcolumnOffset: {\n\t\t\t\tvalue: columnOffset,\n\t\t\t\tenumerable: true\n\t\t\t},\n\t\t\tcompiler: {\n\t\t\t\tvalue: compiler,\n\t\t\t\tenumerable: true\n\t\t\t},\n\t\t\t_code: {\n\t\t\t\tvalue: sCode,\n\t\t\t\twritable: true\n\t\t\t},\n\t\t\t_prefix: {\n\t\t\t\tvalue: '',\n\t\t\t\twritable: true\n\t\t\t},\n\t\t\t_suffix: {\n\t\t\t\tvalue: '',\n\t\t\t\twritable: true\n\t\t\t},\n\t\t\t_compiledVM: {\n\t\t\t\tvalue: null,\n\t\t\t\twritable: true\n\t\t\t},\n\t\t\t_compiledNodeVM: {\n\t\t\t\tvalue: null,\n\t\t\t\twritable: true\n\t\t\t},\n\t\t\t_compiledNodeVMStrict: {\n\t\t\t\tvalue: null,\n\t\t\t\twritable: true\n\t\t\t},\n\t\t\t_compiledCode: {\n\t\t\t\tvalue: null,\n\t\t\t\twritable: true\n\t\t\t},\n\t\t\t_compiler: {value: resolvedCompiler}\n\t\t});\n\t}\n\n\t/**\n\t * Wraps the code.<br>\n\t * This will replace the old wrapping.<br>\n\t * Will invalidate the code cache.\n\t *\n\t * @public\n\t * @deprecated Since v3.9.0. Wrap your code before passing it into the VMScript object.\n\t * @param {string} prefix - String that will be appended before the script code.\n\t * @param {script} suffix - String that will be appended behind the script code.\n\t * @return {this} This for chaining.\n\t * @throws {TypeError} If prefix or suffix is a Symbol.\n\t */\n\twrap(prefix, suffix) {\n\t\tconst strPrefix = `${prefix}`;\n\t\tconst strSuffix = `${suffix}`;\n\t\tif (this._prefix === strPrefix && this._suffix === strSuffix) return this;\n\t\tthis._prefix = strPrefix;\n\t\tthis._suffix = strSuffix;\n\t\tthis._compiledVM = null;\n\t\tthis._compiledNodeVM = null;\n\t\tthis._compiledNodeVMStrict = null;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Compile this script. <br>\n\t * This is useful to detect syntax errors in the script.\n\t *\n\t * @public\n\t * @return {this} This for chaining.\n\t * @throws {SyntaxError} If there is a syntax error in the script.\n\t */\n\tcompile() {\n\t\tthis._compileVM();\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the compiled code.\n\t * \n\t * @private\n\t * @return {string} The code.\n\t */\n\tgetCompiledCode() {\n\t\tif (!this._compiledCode) {\n\t\t\tthis._compiledCode = this._compiler(this._prefix + removeShebang(this._code) + this._suffix, this.filename);\n\t\t}\n\t\treturn this._compiledCode;\n\t}\n\n\t/**\n\t * Compiles this script to a vm.Script.\n\t * \n\t * @private\n\t * @param {string} prefix - JavaScript code that will be used as prefix.\n\t * @param {string} suffix - JavaScript code that will be used as suffix.\n\t * @return {vm.Script} The compiled vm.Script.\n\t * @throws {SyntaxError} If there is a syntax error in the script.\n\t */\n\t_compile(prefix, suffix) {\n\t\treturn new vm.Script(prefix + this.getCompiledCode() + suffix, {\n\t\t\tfilename: this.filename,\n\t\t\tdisplayErrors: false,\n\t\t\tlineOffset: this.lineOffset,\n\t\t\tcolumnOffset: this.columnOffset,\n\t\t\timportModuleDynamically\n\t\t});\n\t}\n\n\t/**\n\t * Will return the cached version of the script intended for VM or compile it.\n\t * \n\t * @private\n\t * @return {vm.Script} The compiled script\n\t * @throws {SyntaxError} If there is a syntax error in the script.\n\t */\n\t_compileVM() {\n\t\tlet script = this._compiledVM;\n\t\tif (!script) {\n\t\t\tthis._compiledVM = script = this._compile('', '');\n\t\t}\n\t\treturn script;\n\t}\n\n\t/**\n\t * Will return the cached version of the script intended for NodeVM or compile it.\n\t * \n\t * @private\n\t * @return {vm.Script} The compiled script\n\t * @throws {SyntaxError} If there is a syntax error in the script.\n\t */\n\t_compileNodeVM() {\n\t\tlet script = this._compiledNodeVM;\n\t\tif (!script) {\n\t\t\tthis._compiledNodeVM = script = this._compile(MODULE_PREFIX, MODULE_SUFFIX);\n\t\t}\n\t\treturn script;\n\t}\n\n\t/**\n\t * Will return the cached version of the script intended for NodeVM in strict mode or compile it.\n\t * \n\t * @private\n\t * @return {vm.Script} The compiled script\n\t * @throws {SyntaxError} If there is a syntax error in the script.\n\t */\n\t_compileNodeVMStrict() {\n\t\tlet script = this._compiledNodeVMStrict;\n\t\tif (!script) {\n\t\t\tthis._compiledNodeVMStrict = script = this._compile(STRICT_MODULE_PREFIX, MODULE_SUFFIX);\n\t\t}\n\t\treturn script;\n\t}\n\n}\n\n/**\n * \n * This callback will be called and has a specific time to finish.<br>\n * No parameters will be supplied.<br>\n * If parameters are required, use a closure.\n * \n * @private\n * @callback runWithTimeout\n * @return {*} \n * \n */\n\n/**\n * Run a function with a specific timeout.\n * \n * @private\n * @param {runWithTimeout} fn - Function to run with the specific timeout.\n * @param {number} timeout - The amount of time to give the function to finish.\n * @return {*} The value returned by the function.\n * @throws {Error} If the function took to long.\n */\nfunction doWithTimeout(fn, timeout) {\n\tlet ctx = CACHE.timeoutContext;\n\tlet script = CACHE.timeoutScript;\n\tif (!ctx) {\n\t\tCACHE.timeoutContext = ctx = vm.createContext();\n\t\tCACHE.timeoutScript = script = new vm.Script('fn()', {\n\t\t\tfilename: 'timeout_bridge.js',\n\t\t\tdisplayErrors: false,\n\t\t\timportModuleDynamically\n\t\t});\n\t}\n\tctx.fn = fn;\n\ttry {\n\t\treturn script.runInContext(ctx, {\n\t\t\tdisplayErrors: false,\n\t\t\timportModuleDynamically,\n\t\t\ttimeout\n\t\t});\n\t} finally {\n\t\tctx.fn = null;\n\t}\n}\n\nfunction tryCompile(args) {\n\tconst code = args[args.length - 1];\n\tconst params = args.slice(0, -1);\n\tvm.compileFunction(code, params);\n}\n\nfunction makeCheckHook(checkAsync, checkImport) {\n\tif (!checkAsync && !checkImport) return null;\n\treturn (hook, args) => {\n\t\tif (hook === 'function' || hook === 'generator_function' || hook === 'eval' || hook === 'run' ||\n\t\t\t(!checkAsync && (hook === 'async_function' || hook === 'async_generator_function'))) {\n\t\t\tif (hook === 'eval') {\n\t\t\t\tconst script = args[0];\n\t\t\t\targs = [script];\n\t\t\t\tif (typeof(script) !== 'string') return args;\n\t\t\t} else {\n\t\t\t\t// Next line throws on Symbol, this is the same behavior as function constructor calls\n\t\t\t\targs = args.map(arg => `${arg}`);\n\t\t\t}\n\t\t\tconst hasAsync = checkAsync && args.findIndex(arg => /\\basync\\b/.test(arg)) !== -1;\n\t\t\tconst hasImport = checkImport && args.findIndex(arg => /\\bimport\\b/.test(arg)) !== -1;\n\t\t\tif (!hasAsync && !hasImport) return args;\n\t\t\tconst mapped = args.map(arg => {\n\t\t\t\tif (hasAsync) arg = arg.replace(/async/g, 'a\\\\u0073ync');\n\t\t\t\tif (hasImport) arg = arg.replace(/import/g, 'i\\\\u006dport');\n\t\t\t\treturn arg;\n\t\t\t});\n\t\t\ttry {\n\t\t\t\ttryCompile(mapped);\n\t\t\t} catch (u) {\n\t\t\t\t// Some random syntax error or error because of async or import.\n\n\t\t\t\t// First report real syntax errors\n\t\t\t\ttryCompile(args);\n\n\t\t\t\tif (hasAsync && hasImport) {\n\t\t\t\t\tconst mapped2 = args.map(arg => arg.replace(/async/g, 'a\\\\u0073ync'));\n\t\t\t\t\ttry {\n\t\t\t\t\t\ttryCompile(mapped2);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tthrow new VMError('Async not available');\n\t\t\t\t\t}\n\t\t\t\t\tthrow new VMError('Dynamic Import not supported');\n\t\t\t\t}\n\t\t\t\tif (hasAsync) {\n\t\t\t\t\t// Then async error\n\t\t\t\t\tthrow new VMError('Async not available');\n\t\t\t\t}\n\t\t\t\tthrow new VMError('Dynamic Import not supported');\n\t\t\t}\n\t\t\treturn args;\n\t\t}\n\t\tif (checkAsync) throw new VMError('Async not available');\n\t\treturn args;\n\t};\n}\n\n/**\n * Class VM.\n *\n * @public\n */\nclass VM extends EventEmitter {\n\n\t/**\n\t * The timeout for {@link VM#run} calls.\n\t *\n\t * @public\n\t * @since v3.9.0\n\t * @member {number} timeout\n\t * @memberOf VM#\n\t */\n\n\t/**\n\t * Get the global sandbox object.\n\t *\n\t * @public\n\t * @readonly\n\t * @since v3.9.0\n\t * @member {Object} sandbox\n\t * @memberOf VM#\n\t */\n\n\t/**\n\t * The compiler to use to get the JavaScript code.\n\t * \n\t * @public\n\t * @readonly\n\t * @since v3.9.0\n\t * @member {(string|compileCallback)} compiler\n\t * @memberOf VM#\n\t */\n\n\t/**\n\t * The context for this sandbox.\n\t * \n\t * @private\n\t * @readonly\n\t * @member {Object} _context\n\t * @memberOf VM#\n\t */\n\n\t/**\n\t * The internal methods for this sandbox.\n\t * \n\t * @private\n\t * @readonly\n\t * @member {{Contextify: Object, Decontextify: Object, Buffer: Object, sandbox:Object}} _internal\n\t * @memberOf VM#\n\t */\n\n\t/**\n\t * The resolved compiler to use to get the JavaScript code.\n\t * \n\t * @private\n\t * @readonly\n\t * @member {compileCallback} _compiler\n\t * @memberOf VM#\n\t */\n\n\t/**\n\t * The hook called when some events occurs.\n\t * \n\t * @private\n\t * @readonly\n\t * @since v3.9.2\n\t * @member {Function} _hook\n\t * @memberOf VM#\n\t */\n\n\t/**\n\t * Create a new VM instance.\n\t *\n\t * @public\n\t * @param {Object} [options] - VM options.\n\t * @param {number} [options.timeout] - The amount of time until a call to {@link VM#run} will timeout.\n\t * @param {Object} [options.sandbox] - Objects that will be copied into the global object of the sandbox.\n\t * @param {(string|compileCallback)} [options.compiler=\"javascript\"] - The compiler to use.\n\t * @param {boolean} [options.eval=true] - Allow the dynamic evaluation of code via eval(code) or Function(code)().<br>\n\t * Only available for node v10+.\n\t * @param {boolean} [options.wasm=true] - Allow to run wasm code.<br>\n\t * Only available for node v10+.\n\t * @param {boolean} [options.fixAsync=false] - Filters for async functions.\n\t * @throws {VMError} If the compiler is unknown.\n\t */\n\tconstructor(options = {}) {\n\t\tsuper();\n\n\t\t// Read all options\n\t\tconst {\n\t\t\ttimeout,\n\t\t\tsandbox,\n\t\t\tcompiler = 'javascript'\n\t\t} = options;\n\t\tconst allowEval = options.eval !== false;\n\t\tconst allowWasm = options.wasm !== false;\n\t\tconst fixAsync = !!options.fixAsync;\n\n\t\t// Early error if sandbox is not an object.\n\t\tif (sandbox && 'object' !== typeof sandbox) {\n\t\t\tthrow new VMError('Sandbox must be object.');\n\t\t}\n\n\t\t// Early error if compiler can't be found.\n\t\tconst resolvedCompiler = lookupCompiler(compiler);\n\n\t\t// Create a new context for this vm.\n\t\tconst _context = vm.createContext(undefined, {\n\t\t\tcodeGeneration: {\n\t\t\t\tstrings: allowEval,\n\t\t\t\twasm: allowWasm\n\t\t\t}\n\t\t});\n\n\t\t// Create the bridge between the host and the sandbox.\n\t\tconst _internal = CACHE.contextifyScript.runInContext(_context, DEFAULT_RUN_OPTIONS).call(_context, require, HOST);\n\n\t\tconst hook = makeCheckHook(fixAsync, true);\n\n\t\t// Define the properties of this object.\n\t\t// Use Object.defineProperties here to be able to\n\t\t// hide and set properties write only.\n\t\tObject.defineProperties(this, {\n\t\t\ttimeout: {\n\t\t\t\tvalue: timeout,\n\t\t\t\twritable: true,\n\t\t\t\tenumerable: true\n\t\t\t},\n\t\t\tcompiler: {\n\t\t\t\tvalue: compiler,\n\t\t\t\tenumerable: true\n\t\t\t},\n\t\t\tsandbox: {\n\t\t\t\tvalue: _internal.sandbox,\n\t\t\t\tenumerable: true\n\t\t\t},\n\t\t\t_context: {value: _context},\n\t\t\t_internal: {value: _internal},\n\t\t\t_compiler: {value: resolvedCompiler},\n\t\t\t_hook: {value: hook}\n\t\t});\n\n\t\tif (hook) {\n\t\t\tif (!CACHE.hookScript) {\n\t\t\t\tCACHE.hookScript = loadAndCompileScript(`${__dirname}/fixasync.js`, '(function() { ', '\\n})');\n\t\t\t\tCACHE.getGlobalScript = new vm.Script('this', {\n\t\t\t\t\tfilename: 'get_global.js',\n\t\t\t\t\tdisplayErrors: false,\n\t\t\t\t\timportModuleDynamically\n\t\t\t\t});\n\t\t\t\ttry {\n\t\t\t\t\tCACHE.getGeneratorFunctionScript = new vm.Script('(function*(){}).constructor', {\n\t\t\t\t\t\tfilename: 'get_generator_function.js',\n\t\t\t\t\t\tdisplayErrors: false,\n\t\t\t\t\t\timportModuleDynamically\n\t\t\t\t\t});\n\t\t\t\t} catch (ex) {}\n\t\t\t\ttry {\n\t\t\t\t\tCACHE.getAsyncFunctionScript = new vm.Script('(async function(){}).constructor', {\n\t\t\t\t\t\tfilename: 'get_async_function.js',\n\t\t\t\t\t\tdisplayErrors: false,\n\t\t\t\t\t\timportModuleDynamically\n\t\t\t\t\t});\n\t\t\t\t} catch (ex) {}\n\t\t\t\ttry {\n\t\t\t\t\tCACHE.getAsyncGeneratorFunctionScript = new vm.Script('(async function*(){}).constructor', {\n\t\t\t\t\t\tfilename: 'get_async_generator_function.js',\n\t\t\t\t\t\tdisplayErrors: false,\n\t\t\t\t\t\timportModuleDynamically\n\t\t\t\t\t});\n\t\t\t\t} catch (ex) {}\n\t\t\t}\n\t\t\tconst internal = {\n\t\t\t\t__proto__: null,\n\t\t\t\tglobal: CACHE.getGlobalScript.runInContext(_context, DEFAULT_RUN_OPTIONS),\n\t\t\t\tinternal: _internal,\n\t\t\t\thost: HOST,\n\t\t\t\thook\n\t\t\t};\n\t\t\tif (CACHE.getGeneratorFunctionScript) {\n\t\t\t\ttry {\n\t\t\t\t\tinternal.GeneratorFunction = CACHE.getGeneratorFunctionScript.runInContext(_context, DEFAULT_RUN_OPTIONS);\n\t\t\t\t} catch (ex) {}\n\t\t\t}\n\t\t\tif (CACHE.getAsyncFunctionScript) {\n\t\t\t\ttry {\n\t\t\t\t\tinternal.AsyncFunction = CACHE.getAsyncFunctionScript.runInContext(_context, DEFAULT_RUN_OPTIONS);\n\t\t\t\t} catch (ex) {}\n\t\t\t}\n\t\t\tif (CACHE.getAsyncGeneratorFunctionScript) {\n\t\t\t\ttry {\n\t\t\t\t\tinternal.AsyncGeneratorFunction = CACHE.getAsyncGeneratorFunctionScript.runInContext(_context, DEFAULT_RUN_OPTIONS);\n\t\t\t\t} catch (ex) {}\n\t\t\t}\n\t\t\tCACHE.hookScript.runInContext(_context, DEFAULT_RUN_OPTIONS).call(internal);\n\t\t}\n\n\t\t// prepare global sandbox\n\t\tif (sandbox) {\n\t\t\tthis.setGlobals(sandbox);\n\t\t}\n\t}\n\n\t/**\n\t * Adds all the values to the globals.\n\t * \n\t * @public\n\t * @since v3.9.0\n\t * @param {Object} values - All values that will be added to the globals.\n\t * @return {this} This for chaining.\n\t * @throws {*} If the setter of a global throws an exception it is propagated. And the remaining globals will not be written.\n\t */\n\tsetGlobals(values) {\n\t\tfor (const name in values) {\n\t\t\tif (Object.prototype.hasOwnProperty.call(values, name)) {\n\t\t\t\tthis._internal.Contextify.setGlobal(name, values[name]);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set a global value.\n\t * \n\t * @public\n\t * @since v3.9.0\n\t * @param {string} name - The name of the global.\n\t * @param {*} value - The value of the global.\n\t * @return {this} This for chaining.\n\t * @throws {*} If the setter of the global throws an exception it is propagated.\n\t */\n\tsetGlobal(name, value) {\n\t\tthis._internal.Contextify.setGlobal(name, value);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get a global value.\n\t * \n\t * @public\n\t * @since v3.9.0\n\t * @param {string} name - The name of the global.\n\t * @return {*} The value of the global.\n\t * @throws {*} If the getter of the global throws an exception it is propagated.\n\t */\n\tgetGlobal(name) {\n\t\treturn this._internal.Contextify.getGlobal(name);\n\t}\n\n\t/**\n\t * Freezes the object inside VM making it read-only. Not available for primitive values.\n\t *\n\t * @public\n\t * @param {*} value - Object to freeze.\n\t * @param {string} [globalName] - Whether to add the object to global.\n\t * @return {*} Object to freeze.\n\t * @throws {*} If the setter of the global throws an exception it is propagated.\n\t */\n\tfreeze(value, globalName) {\n\t\tthis._internal.Contextify.readonly(value);\n\t\tif (globalName) this._internal.Contextify.setGlobal(globalName, value);\n\t\treturn value;\n\t}\n\n\t/**\n\t * Protects the object inside VM making impossible to set functions as it's properties. Not available for primitive values.\n\t *\n\t * @public\n\t * @param {*} value - Object to protect.\n\t * @param {string} [globalName] - Whether to add the object to global.\n\t * @return {*} Object to protect.\n\t * @throws {*} If the setter of the global throws an exception it is propagated.\n\t */\n\tprotect(value, globalName) {\n\t\tthis._internal.Contextify.protected(value);\n\t\tif (globalName) this._internal.Contextify.setGlobal(globalName, value);\n\t\treturn value;\n\t}\n\n\t/**\n\t * Run the code in VM.\n\t *\n\t * @public\n\t * @param {(string|VMScript)} code - Code to run.\n\t * @param {string} [filename=\"vm.js\"] - Filename that shows up in any stack traces produced from this script.<br>\n\t * This is only used if code is a String.\n\t * @return {*} Result of executed code.\n\t * @throws {SyntaxError} If there is a syntax error in the script.\n\t * @throws {Error} An error is thrown when the script took to long and there is a timeout.\n\t * @throws {*} If the script execution terminated with an exception it is propagated.\n\t */\n\trun(code, filename) {\n\t\tlet script;\n\t\tif (code instanceof VMScript) {\n\t\t\tif (this._hook) {\n\t\t\t\tconst scriptCode = code.getCompiledCode();\n\t\t\t\tconst changed = this._hook('run', [scriptCode])[0];\n\t\t\t\tif (changed === scriptCode) {\n\t\t\t\t\tscript = code._compileVM();\n\t\t\t\t} else {\n\t\t\t\t\tscript = new vm.Script(changed, {\n\t\t\t\t\t\tfilename: code.filename,\n\t\t\t\t\t\tdisplayErrors: false,\n\t\t\t\t\t\timportModuleDynamically\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tscript = code._compileVM();\n\t\t\t}\n\t\t} else {\n\t\t\tconst useFileName = filename || 'vm.js';\n\t\t\tlet scriptCode = this._compiler(code, useFileName);\n\t\t\tif (this._hook) {\n\t\t\t\tscriptCode = this._hook('run', [scriptCode])[0];\n\t\t\t}\n\t\t\t// Compile the script here so that we don't need to create a instance of VMScript.\n\t\t\tscript = new vm.Script(scriptCode, {\n\t\t\t\tfilename: useFileName,\n\t\t\t\tdisplayErrors: false,\n\t\t\t\timportModuleDynamically\n\t\t\t});\n\t\t}\n\n\t\tif (!this.timeout) {\n\t\t\t// If no timeout is given, directly run the script.\n\t\t\ttry {\n\t\t\t\treturn this._internal.Decontextify.value(script.runInContext(this._context, DEFAULT_RUN_OPTIONS));\n\t\t\t} catch (e) {\n\t\t\t\tthrow this._internal.Decontextify.value(e);\n\t\t\t}\n\t\t}\n\n\t\treturn doWithTimeout(()=>{\n\t\t\ttry {\n\t\t\t\treturn this._internal.Decontextify.value(script.runInContext(this._context, DEFAULT_RUN_OPTIONS));\n\t\t\t} catch (e) {\n\t\t\t\tthrow this._internal.Decontextify.value(e);\n\t\t\t}\n\t\t}, this.timeout);\n\t}\n\n\t/**\n\t * Run the code in VM.\n\t *\n\t * @public\n\t * @since v3.9.0\n\t * @param {string} filename - Filename of file to load and execute in a NodeVM.\n\t * @return {*} Result of executed code.\n\t * @throws {Error} If filename is not a valid filename.\n\t * @throws {SyntaxError} If there is a syntax error in the script.\n\t * @throws {Error} An error is thrown when the script took to long and there is a timeout.\n\t * @throws {*} If the script execution terminated with an exception it is propagated.\n\t */\n\trunFile(filename) {\n\t\tconst resolvedFilename = pa.resolve(filename);\n\n\t\tif (!fs.existsSync(resolvedFilename)) {\n\t\t\tthrow new VMError(`Script '${filename}' not found.`);\n\t\t}\n\n\t\tif (fs.statSync(resolvedFilename).isDirectory()) {\n\t\t\tthrow new VMError('Script must be file, got directory.');\n\t\t}\n\n\t\treturn this.run(fs.readFileSync(resolvedFilename, 'utf8'), resolvedFilename);\n\t}\n\n}\n\n/**\n * Event caused by a <code>console.debug</code> call if <code>options.console=\"redirect\"</code> is specified.\n *\n * @public\n * @event NodeVM.\"console.debug\"\n * @type {...*}\n */\n\n/**\n * Event caused by a <code>console.log</code> call if <code>options.console=\"redirect\"</code> is specified.\n *\n * @public\n * @event NodeVM.\"console.log\"\n * @type {...*}\n */\n\n/**\n * Event caused by a <code>console.info</code> call if <code>options.console=\"redirect\"</code> is specified.\n *\n * @public\n * @event NodeVM.\"console.info\"\n * @type {...*}\n */\n\n/**\n * Event caused by a <code>console.warn</code> call if <code>options.console=\"redirect\"</code> is specified.\n *\n * @public\n * @event NodeVM.\"console.warn\"\n * @type {...*}\n */\n\n/**\n * Event caused by a <code>console.error</code> call if <code>options.console=\"redirect\"</code> is specified.\n *\n * @public\n * @event NodeVM.\"console.error\"\n * @type {...*}\n */\n\n/**\n * Event caused by a <code>console.dir</code> call if <code>options.console=\"redirect\"</code> is specified.\n *\n * @public\n * @event NodeVM.\"console.dir\"\n * @type {...*}\n */\n\n/**\n * Event caused by a <code>console.trace</code> call if <code>options.console=\"redirect\"</code> is specified.\n *\n * @public\n * @event NodeVM.\"console.trace\"\n * @type {...*}\n */\n\n/**\n * Class NodeVM.\n *\n * @public\n * @extends {VM}\n * @extends {EventEmitter}\n */\nclass NodeVM extends VM {\n\n\t/**\n\t * Create a new NodeVM instance.<br>\n\t *\n\t * Unlike VM, NodeVM lets you use require same way like in regular node.<br>\n\t * \n\t * However, it does not use the timeout.\n\t *\n\t * @public\n\t * @param {Object} [options] - VM options.\n\t * @param {Object} [options.sandbox] - Objects that will be copied into the global object of the sandbox.\n\t * @param {(string|compileCallback)} [options.compiler=\"javascript\"] - The compiler to use.\n\t * @param {boolean} [options.eval=true] - Allow the dynamic evaluation of code via eval(code) or Function(code)().<br>\n\t * Only available for node v10+.\n\t * @param {boolean} [options.wasm=true] - Allow to run wasm code.<br>\n\t * Only available for node v10+.\n\t * @param {(\"inherit\"|\"redirect\"|\"off\")} [options.console=\"inherit\"] - Sets the behavior of the console in the sandbox.\n\t * <code>inherit</code> to enable console, <code>redirect</code> to redirect to events, <code>off</code> to disable console.\n\t * @param {Object|boolean} [options.require=false] - Allow require inside the sandbox.\n\t * @param {(boolean|string[]|Object)} [options.require.external=false] - true, an array of allowed external modules or an object.\n\t * @param {(string[])} [options.require.external.modules] - Array of allowed external modules. Also supports wildcards, so specifying ['@scope/*-ver-??], \n\t * for instance, will allow using all modules having a name of the form @scope/something-ver-aa, @scope/other-ver-11, etc.\n\t * @param {boolean} [options.require.external.transitive=false] - Boolean which indicates if transitive dependencies of external modules are allowed.\n\t * @param {string[]} [options.require.builtin=[]] - Array of allowed builtin modules, accepts [\"*\"] for all.\n\t * @param {(string|string[])} [options.require.root] - Restricted path(s) where local modules can be required. If omitted every path is allowed.\n\t * @param {Object} [options.require.mock] - Collection of mock modules (both external or builtin).\n\t * @param {(\"host\"|\"sandbox\")} [options.require.context=\"host\"] - <code>host</code> to require modules in host and proxy them to sandbox.\n\t * <code>sandbox</code> to load, compile and require modules in sandbox.\n\t * Builtin modules except <code>events</code> always required in host and proxied to sandbox.\n\t * @param {string[]} [options.require.import] - Array of modules to be loaded into NodeVM on start.\n\t * @param {resolveCallback} [options.require.resolve] - An additional lookup function in case a module wasn't\n\t * found in one of the traditional node lookup paths.\n\t * @param {boolean} [options.nesting=false] - Allow nesting of VMs.\n\t * @param {(\"commonjs\"|\"none\")} [options.wrapper=\"commonjs\"] - <code>commonjs</code> to wrap script into CommonJS wrapper, \n\t * <code>none</code> to retrieve value returned by the script.\n\t * @param {string[]} [options.sourceExtensions=[\"js\"]] - Array of file extensions to treat as source code.\n\t * @param {string[]} [options.argv=[]] - Array of arguments passed to <code>process.argv</code>. \n\t * This object will not be copied and the script can change this object.\n\t * @param {Object} [options.env={}] - Environment map passed to <code>process.env</code>. \n\t * This object will not be copied and the script can change this object.\n\t * @param {boolean} [options.strict=false] - If modules should be loaded in strict mode.\n\t * @throws {VMError} If the compiler is unknown.\n\t */\n\tconstructor(options = {}) {\n\t\tconst sandbox = options.sandbox;\n\n\t\t// Throw this early\n\t\tif (sandbox && 'object' !== typeof sandbox) {\n\t\t\tthrow new VMError('Sandbox must be object.');\n\t\t}\n\n\t\tsuper({compiler: options.compiler, eval: options.eval, wasm: options.wasm});\n\n\t\t// defaults\n\t\tObject.defineProperty(this, 'options', {value: {\n\t\t\tconsole: options.console || 'inherit',\n\t\t\trequire: options.require || false,\n\t\t\tnesting: options.nesting || false,\n\t\t\twrapper: options.wrapper || 'commonjs',\n\t\t\tsourceExtensions: options.sourceExtensions || ['js'],\n\t\t\tstrict: options.strict || false\n\t\t}});\n\n\t\tlet sandboxScript = CACHE.sandboxScript;\n\t\tif (!sandboxScript) {\n\t\t\tCACHE.sandboxScript = sandboxScript = loadAndCompileScript(`${__dirname}/sandbox.js`,\n\t\t\t\t'(function (vm, host, Contextify, Decontextify, Buffer, options) { ', '\\n})');\n\t\t}\n\n\t\tconst closure = sandboxScript.runInContext(this._context, DEFAULT_RUN_OPTIONS);\n\n\t\tObject.defineProperty(this, '_prepareRequire', {\n\t\t\tvalue: closure.call(this._context, this, HOST, this._internal.Contextify, this._internal.Decontextify, this._internal.Buffer, options)\n\t\t});\n\n\t\t// prepare global sandbox\n\t\tif (sandbox) {\n\t\t\tthis.setGlobals(sandbox);\n\t\t}\n\n\t\tif (this.options.require && this.options.require.import) {\n\t\t\tif (Array.isArray(this.options.require.import)) {\n\t\t\t\tfor (let i = 0, l = this.options.require.import.length; i < l; i++) {\n\t\t\t\t\tthis.require(this.options.require.import[i]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.require(this.options.require.import);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @ignore\n\t * @deprecated Just call the method yourself like <code>method(args);</code>\n\t * @param {function} method - Function to invoke.\n\t * @param {...*} args - Arguments to pass to the function.\n\t * @return {*} Return value of the function.\n\t * @todo Can we remove this function? It even had a bug that would use args as this parameter.\n\t * @throws {*} Rethrows anything the method throws.\n\t * @throws {VMError} If method is not a function.\n\t * @throws {Error} If method is a class.\n\t */\n\tcall(method, ...args) {\n\t\tif ('function' === typeof method) {\n\t\t\treturn method(...args);\n\t\t} else {\n\t\t\tthrow new VMError('Unrecognized method type.');\n\t\t}\n\t}\n\n\t/**\n\t * Require a module in VM and return it's exports.\n\t *\n\t * @public\n\t * @param {string} module - Module name.\n\t * @return {*} Exported module.\n\t * @throws {*} If the module couldn't be found or loading it threw an error.\n\t */\n\trequire(module) {\n\t\treturn this.run(`module.exports = require('${module}');`, 'vm.js');\n\t}\n\n\t/**\n\t * Run the code in NodeVM.\n\t *\n\t * First time you run this method, code is executed same way like in node's regular `require` - it's executed with\n\t * `module`, `require`, `exports`, `__dirname`, `__filename` variables and expect result in `module.exports'.\n\t *\n\t * @param {(string|VMScript)} code - Code to run.\n\t * @param {string} [filename] - Filename that shows up in any stack traces produced from this script.<br>\n\t * This is only used if code is a String.\n\t * @return {*} Result of executed code.\n\t * @throws {SyntaxError} If there is a syntax error in the script.\n\t * @throws {*} If the script execution terminated with an exception it is propagated.\n\t * @fires NodeVM.\"console.debug\"\n\t * @fires NodeVM.\"console.log\"\n\t * @fires NodeVM.\"console.info\"\n\t * @fires NodeVM.\"console.warn\"\n\t * @fires NodeVM.\"console.error\"\n\t * @fires NodeVM.\"console.dir\"\n\t * @fires NodeVM.\"console.trace\"\n\t */\n\trun(code, filename) {\n\t\tlet dirname;\n\t\tlet resolvedFilename;\n\t\tlet script;\n\n\t\tif (code instanceof VMScript) {\n\t\t\tif (this._hook) {\n\t\t\t\tconst prefix = this.options.strict ? STRICT_MODULE_PREFIX : MODULE_PREFIX;\n\t\t\t\tconst scriptCode = prefix + code.getCompiledCode() + MODULE_SUFFIX;\n\t\t\t\tconst changed = this._hook('run', [scriptCode])[0];\n\t\t\t\tif (changed === scriptCode) {\n\t\t\t\t\tscript = this.options.strict ? code._compileNodeVMStrict() : code._compileNodeVM();\n\t\t\t\t} else {\n\t\t\t\t\tscript = new vm.Script(changed, {\n\t\t\t\t\t\tfilename: code.filename,\n\t\t\t\t\t\tdisplayErrors: false,\n\t\t\t\t\t\timportModuleDynamically\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tscript = this.options.strict ? code._compileNodeVMStrict() : code._compileNodeVM();\n\t\t\t}\n\t\t\tresolvedFilename = pa.resolve(code.filename);\n\t\t\tdirname = pa.dirname(resolvedFilename);\n\t\t} else {\n\t\t\tconst unresolvedFilename = filename || 'vm.js';\n\t\t\tif (filename) {\n\t\t\t\tresolvedFilename = pa.resolve(filename);\n\t\t\t\tdirname = pa.dirname(resolvedFilename);\n\t\t\t} else {\n\t\t\t\tresolvedFilename = null;\n\t\t\t\tdirname = null;\n\t\t\t}\n\t\t\tconst prefix = this.options.strict ? STRICT_MODULE_PREFIX : MODULE_PREFIX;\n\t\t\tlet scriptCode = prefix + this._compiler(code, unresolvedFilename) + MODULE_SUFFIX;\n\t\t\tif (this._hook) {\n\t\t\t\tscriptCode = this._hook('run', [scriptCode])[0];\n\t\t\t}\n\t\t\tscript = new vm.Script(scriptCode, {\n\t\t\t\tfilename: unresolvedFilename,\n\t\t\t\tdisplayErrors: false,\n\t\t\t\timportModuleDynamically\n\t\t\t});\n\t\t}\n\n\t\tconst wrapper = this.options.wrapper;\n\t\tconst module = this._internal.Contextify.makeModule();\n\n\t\ttry {\n\t\t\tconst closure = script.runInContext(this._context, DEFAULT_RUN_OPTIONS);\n\n\t\t\tconst returned = closure.call(this._context, module.exports, this._prepareRequire(dirname), module, resolvedFilename, dirname);\n\n\t\t\treturn this._internal.Decontextify.value(wrapper === 'commonjs' ? module.exports : returned);\n\t\t} catch (e) {\n\t\t\tthrow this._internal.Decontextify.value(e);\n\t\t}\n\n\t}\n\n\t/**\n\t * Create NodeVM and run code inside it.\n\t *\n\t * @public\n\t * @static\n\t * @param {string} script - Code to execute.\n\t * @param {string} [filename] - File name (used in stack traces only).\n\t * @param {Object} [options] - VM options.\n\t * @param {string} [options.filename] - File name (used in stack traces only). Used if <code>filename</code> is omitted.\n\t * @return {*} Result of executed code.\n\t * @see {@link NodeVM} for the options.\n\t * @throws {SyntaxError} If there is a syntax error in the script.\n\t * @throws {*} If the script execution terminated with an exception it is propagated.\n\t */\n\tstatic code(script, filename, options) {\n\t\tlet unresolvedFilename;\n\t\tif (filename != null) {\n\t\t\tif ('object' === typeof filename) {\n\t\t\t\toptions = filename;\n\t\t\t\tunresolvedFilename = options.filename;\n\t\t\t} else if ('string' === typeof filename) {\n\t\t\t\tunresolvedFilename = filename;\n\t\t\t} else {\n\t\t\t\tthrow new VMError('Invalid arguments.');\n\t\t\t}\n\t\t} else if ('object' === typeof options) {\n\t\t\tunresolvedFilename = options.filename;\n\t\t}\n\n\t\tif (arguments.length > 3) {\n\t\t\tthrow new VMError('Invalid number of arguments.');\n\t\t}\n\n\t\tconst resolvedFilename = typeof unresolvedFilename === 'string' ? pa.resolve(unresolvedFilename) : undefined;\n\n\t\treturn new NodeVM(options).run(script, resolvedFilename);\n\t}\n\n\t/**\n\t * Create NodeVM and run script from file inside it.\n\t *\n\t * @public\n\t * @static\n\t * @param {string} filename - Filename of file to load and execute in a NodeVM.\n\t * @param {Object} [options] - NodeVM options.\n\t * @return {*} Result of executed code.\n\t * @see {@link NodeVM} for the options.\n\t * @throws {Error} If filename is not a valid filename.\n\t * @throws {SyntaxError} If there is a syntax error in the script.\n\t * @throws {*} If the script execution terminated with an exception it is propagated.\n\t */\n\tstatic file(filename, options) {\n\t\tconst resolvedFilename = pa.resolve(filename);\n\n\t\tif (!fs.existsSync(resolvedFilename)) {\n\t\t\tthrow new VMError(`Script '${filename}' not found.`);\n\t\t}\n\n\t\tif (fs.statSync(resolvedFilename).isDirectory()) {\n\t\t\tthrow new VMError('Script must be file, got directory.');\n\t\t}\n\n\t\treturn new NodeVM(options).run(fs.readFileSync(resolvedFilename, 'utf8'), resolvedFilename);\n\t}\n}\n\n/**\n * VMError.\n *\n * @public\n * @extends {Error}\n */\nclass VMError extends Error {\n\n\t/**\n\t * Create VMError instance.\n\t *\n\t * @public\n\t * @param {string} message - Error message.\n\t */\n\tconstructor(message) {\n\t\tsuper(message);\n\n\t\tthis.name = 'VMError';\n\n\t\tError.captureStackTrace(this, this.constructor);\n\t}\n}\n\n/**\n * Host objects\n * \n * @private\n */\nconst HOST = {\n\tversion: parseInt(process.versions.node.split('.')[0]),\n\trequire,\n\tprocess,\n\tconsole,\n\tsetTimeout,\n\tsetInterval,\n\tsetImmediate,\n\tclearTimeout,\n\tclearInterval,\n\tclearImmediate,\n\tString,\n\tNumber,\n\tBuffer,\n\tBoolean,\n\tArray,\n\tDate,\n\tError,\n\tEvalError,\n\tRangeError,\n\tReferenceError,\n\tSyntaxError,\n\tTypeError,\n\tURIError,\n\tRegExp,\n\tFunction,\n\tObject,\n\tVMError,\n\tProxy,\n\tReflect,\n\tMap,\n\tWeakMap,\n\tSet,\n\tWeakSet,\n\tPromise,\n\tSymbol,\n\tINSPECT_MAX_BYTES,\n\tVM,\n\tNodeVM,\n\thelpers,\n\tMODULE_PREFIX,\n\tSTRICT_MODULE_PREFIX,\n\tMODULE_SUFFIX\n};\n\nexports.VMError = VMError;\nexports.NodeVM = NodeVM;\nexports.VM = VM;\nexports.VMScript = VMScript;\n", "/* eslint-disable no-shadow, no-invalid-this */\n/* global vm, host, Contextify, Decontextify, VMError, options */\n\n'use strict';\n\nconst {Script} = host.require('vm');\nconst fs = host.require('fs');\nconst pa = host.require('path');\n\nconst BUILTIN_MODULES = host.process.binding('natives');\nconst parseJSON = JSON.parse;\nconst importModuleDynamically = () => {\n\t// We can't throw an error object here because since vm.Script doesn't store a context, we can't properly contextify that error object.\n\t// eslint-disable-next-line no-throw-literal\n\tthrow 'Dynamic imports are not allowed.';\n};\n\n/**\n * @param {Object} host Hosts's internal objects.\n */\n\nreturn ((vm, host) => {\n\t'use strict';\n\n\tconst global = this;\n\n\tconst TIMERS = new host.WeakMap(); // Contains map of timers created inside sandbox\n\tconst BUILTINS = {__proto__: null};\n\tconst CACHE = {__proto__: null};\n\tconst EXTENSIONS = {\n\t\t__proto__: null,\n\t\t['.json'](module, filename) {\n\t\t\ttry {\n\t\t\t\tconst code = fs.readFileSync(filename, 'utf8');\n\t\t\t\tmodule.exports = parseJSON(code);\n\t\t\t} catch (e) {\n\t\t\t\tthrow Contextify.value(e);\n\t\t\t}\n\t\t},\n\t\t['.node'](module, filename) {\n\t\t\tif (vm.options.require.context === 'sandbox') throw new VMError('Native modules can be required only with context set to \\'host\\'.');\n\n\t\t\ttry {\n\t\t\t\tmodule.exports = Contextify.readonly(host.require(filename));\n\t\t\t} catch (e) {\n\t\t\t\tthrow Contextify.value(e);\n\t\t\t}\n\t\t}\n\t};\n\n\tfor (let i = 0; i < vm.options.sourceExtensions.length; i++) {\n\t\tconst ext = vm.options.sourceExtensions[i];\n\n\t\tEXTENSIONS['.' + ext] = (module, filename, dirname) => {\n\t\t\tif (vm.options.require.context !== 'sandbox') {\n\t\t\t\ttry {\n\t\t\t\t\tmodule.exports = Contextify.readonly(host.require(filename));\n\t\t\t\t} catch (e) {\n\t\t\t\t\tthrow Contextify.value(e);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlet script;\n\n\t\t\t\ttry {\n\t\t\t\t\t// Load module\n\t\t\t\t\tlet contents = fs.readFileSync(filename, 'utf8');\n\t\t\t\t\tcontents = vm._compiler(contents, filename);\n\n\t\t\t\t\tconst code = host.STRICT_MODULE_PREFIX + contents + host.MODULE_SUFFIX;\n\n\t\t\t\t\tconst ccode = vm._hook('run', [code]);\n\n\t\t\t\t\t// Precompile script\n\t\t\t\t\tscript = new Script(ccode, {\n\t\t\t\t\t\t__proto__: null,\n\t\t\t\t\t\tfilename: filename || 'vm.js',\n\t\t\t\t\t\tdisplayErrors: false,\n\t\t\t\t\t\timportModuleDynamically\n\t\t\t\t\t});\n\n\t\t\t\t} catch (ex) {\n\t\t\t\t\tthrow Contextify.value(ex);\n\t\t\t\t}\n\n\t\t\t\tconst closure = script.runInContext(global, {\n\t\t\t\t\t__proto__: null,\n\t\t\t\t\tfilename: filename || 'vm.js',\n\t\t\t\t\tdisplayErrors: false,\n\t\t\t\t\timportModuleDynamically\n\t\t\t\t});\n\n\t\t\t\t// run the script\n\t\t\t\tclosure(module.exports, module.require, module, filename, dirname);\n\t\t\t}\n\t\t};\n\t}\n\n\tconst _parseExternalOptions = (options) => {\n\t\tif (host.Array.isArray(options)) {\n\t\t\treturn {\n\t\t\t\t__proto__: null,\n\t\t\t\texternal: options,\n\t\t\t\ttransitive: false\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\t__proto__: null,\n\t\t\texternal: options.modules,\n\t\t\ttransitive: options.transitive\n\t\t};\n\t};\n\n\t/**\n\t * Resolve filename.\n\t */\n\n\tconst _resolveFilename = (path) => {\n\t\tif (!path) return null;\n\t\tlet hasPackageJson;\n\t\ttry {\n\t\t\tpath = pa.resolve(path);\n\n\t\t\tconst exists = fs.existsSync(path);\n\t\t\tconst isdir = exists ? fs.statSync(path).isDirectory() : false;\n\n\t\t\t// direct file match\n\t\t\tif (exists && !isdir) return path;\n\n\t\t\t// load as file\n\n\t\t\tfor (let i = 0; i < vm.options.sourceExtensions.length; i++) {\n\t\t\t\tconst ext = vm.options.sourceExtensions[i];\n\t\t\t\tif (fs.existsSync(`${path}.${ext}`)) return `${path}.${ext}`;\n\t\t\t}\n\t\t\tif (fs.existsSync(`${path}.json`)) return `${path}.json`;\n\t\t\tif (fs.existsSync(`${path}.node`)) return `${path}.node`;\n\n\t\t\t// load as module\n\n\t\t\thasPackageJson = fs.existsSync(`${path}/package.json`);\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\n\t\tif (hasPackageJson) {\n\t\t\tlet pkg;\n\t\t\ttry {\n\t\t\t\tpkg = fs.readFileSync(`${path}/package.json`, 'utf8');\n\t\t\t} catch (e) {\n\t\t\t\tthrow Contextify.value(e);\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tpkg = parseJSON(pkg);\n\t\t\t} catch (ex) {\n\t\t\t\tthrow new VMError(`Module '${path}' has invalid package.json`, 'EMODULEINVALID');\n\t\t\t}\n\n\t\t\tlet main;\n\t\t\tif (pkg && pkg.main) {\n\t\t\t\tmain = _resolveFilename(`${path}/${pkg.main}`);\n\t\t\t\tif (!main) main = _resolveFilename(`${path}/index`);\n\t\t\t} else {\n\t\t\t\tmain = _resolveFilename(`${path}/index`);\n\t\t\t}\n\n\t\t\treturn main;\n\t\t}\n\n\t\t// load as directory\n\n\t\ttry {\n\t\t\tfor (let i = 0; i < vm.options.sourceExtensions.length; i++) {\n\t\t\t\tconst ext = vm.options.sourceExtensions[i];\n\t\t\t\tif (fs.existsSync(`${path}/index.${ext}`)) return `${path}/index.${ext}`;\n\t\t\t}\n\n\t\t\tif (fs.existsSync(`${path}/index.json`)) return `${path}/index.json`;\n\t\t\tif (fs.existsSync(`${path}/index.node`)) return `${path}/index.node`;\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\n\t\treturn null;\n\t};\n\n\t/**\n\t * Builtin require.\n\t */\n\n\tconst _requireBuiltin = (moduleName) => {\n\t\tif (moduleName === 'buffer') return ({Buffer});\n\t\tif (BUILTINS[moduleName]) return BUILTINS[moduleName].exports; // Only compiled builtins are stored here\n\n\t\tif (moduleName === 'util') {\n\t\t\treturn Contextify.readonly(host.require(moduleName), {\n\t\t\t\t// Allows VM context to use util.inherits\n\t\t\t\t__proto__: null,\n\t\t\t\tinherits: (ctor, superCtor) => {\n\t\t\t\t\tctor.super_ = superCtor;\n\t\t\t\t\tObject.setPrototypeOf(ctor.prototype, superCtor.prototype);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tif (moduleName === 'events' || moduleName === 'internal/errors') {\n\t\t\tlet script;\n\t\t\ttry {\n\t\t\t\tscript = new Script(`(function (exports, require, module, process, internalBinding) {\n\t\t\t\t\t\t'use strict';\n\t\t\t\t\t\tconst primordials = global;\n\t\t\t\t\t\t${BUILTIN_MODULES[moduleName]}\n\t\t\t\t\t\t\\n\n\t\t\t\t\t});`, {\n\t\t\t\t\tfilename: `${moduleName}.vm.js`\n\t\t\t\t});\n\n\t\t\t} catch (e) {\n\t\t\t\tthrow Contextify.value(e);\n\t\t\t}\n\n\t\t\t// setup module scope\n\t\t\tconst module = BUILTINS[moduleName] = {\n\t\t\t\texports: {},\n\t\t\t\trequire: _requireBuiltin\n\t\t\t};\n\n\t\t\t// run script\n\t\t\ttry {\n\t\t\t\t// FIXME binding should be contextified\n\t\t\t\tscript.runInContext(global)(module.exports, module.require, module, host.process, host.process.binding);\n\t\t\t} catch (e) {\n\t\t\t\t// e could be from inside or outside of sandbox\n\t\t\t\tthrow new VMError(`Error loading '${moduleName}'`);\n\t\t\t}\n\t\t\treturn module.exports;\n\t\t}\n\n\t\treturn Contextify.readonly(host.require(moduleName));\n\t};\n\n\t/**\n\t * Prepare require.\n\t */\n\n\tconst _prepareRequire = (currentDirname, parentAllowsTransitive = false) => {\n\t\tconst _require = moduleName => {\n\t\t\tlet requireObj;\n\t\t\ttry {\n\t\t\t\tconst optionsObj = vm.options;\n\t\t\t\tif (optionsObj.nesting && moduleName === 'vm2') return {VM: Contextify.readonly(host.VM), NodeVM: Contextify.readonly(host.NodeVM)};\n\t\t\t\trequireObj = optionsObj.require;\n\t\t\t} catch (e) {\n\t\t\t\tthrow Contextify.value(e);\n\t\t\t}\n\n\t\t\tif (!requireObj) throw new VMError(`Access denied to require '${moduleName}'`, 'EDENIED');\n\t\t\tif (moduleName == null) throw new VMError(\"Module '' not found.\", 'ENOTFOUND');\n\t\t\tif (typeof moduleName !== 'string') throw new VMError(`Invalid module name '${moduleName}'`, 'EINVALIDNAME');\n\n\t\t\tlet filename;\n\t\t\tlet allowRequireTransitive = false;\n\n\t\t\t// Mock?\n\n\t\t\ttry {\n\t\t\t\tconst {mock} = requireObj;\n\t\t\t\tif (mock) {\n\t\t\t\t\tconst mockModule = mock[moduleName];\n\t\t\t\t\tif (mockModule) {\n\t\t\t\t\t\treturn Contextify.readonly(mockModule);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tthrow Contextify.value(e);\n\t\t\t}\n\n\t\t\t// Builtin?\n\n\t\t\tif (BUILTIN_MODULES[moduleName]) {\n\t\t\t\tlet allowed;\n\t\t\t\ttry {\n\t\t\t\t\tconst builtinObj = requireObj.builtin;\n\t\t\t\t\tif (host.Array.isArray(builtinObj)) {\n\t\t\t\t\t\tif (builtinObj.indexOf('*') >= 0) {\n\t\t\t\t\t\t\tallowed = builtinObj.indexOf(`-${moduleName}`) === -1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tallowed = builtinObj.indexOf(moduleName) >= 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (builtinObj) {\n\t\t\t\t\t\tallowed = builtinObj[moduleName];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tallowed = false;\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {\n\t\t\t\t\tthrow Contextify.value(e);\n\t\t\t\t}\n\t\t\t\tif (!allowed) throw new VMError(`Access denied to require '${moduleName}'`, 'EDENIED');\n\n\t\t\t\treturn _requireBuiltin(moduleName);\n\t\t\t}\n\n\t\t\t// External?\n\n\t\t\tlet externalObj;\n\t\t\ttry {\n\t\t\t\texternalObj = requireObj.external;\n\t\t\t} catch (e) {\n\t\t\t\tthrow Contextify.value(e);\n\t\t\t}\n\n\t\t\tif (!externalObj) throw new VMError(`Access denied to require '${moduleName}'`, 'EDENIED');\n\n\t\t\tif (/^(\\.|\\.\\/|\\.\\.\\/)/.exec(moduleName)) {\n\t\t\t\t// Module is relative file, e.g. ./script.js or ../script.js\n\n\t\t\t\tif (!currentDirname) throw new VMError('You must specify script path to load relative modules.', 'ENOPATH');\n\n\t\t\t\tfilename = _resolveFilename(`${currentDirname}/${moduleName}`);\n\t\t\t} else if (/^(\\/|\\\\|[a-zA-Z]:\\\\)/.exec(moduleName)) {\n\t\t\t\t// Module is absolute file, e.g. /script.js or //server/script.js or C:\\script.js\n\n\t\t\t\tfilename = _resolveFilename(moduleName);\n\t\t\t} else {\n\t\t\t\t// Check node_modules in path\n\n\t\t\t\tif (!currentDirname) throw new VMError('You must specify script path to load relative modules.', 'ENOPATH');\n\n\t\t\t\tif (typeof externalObj === 'object') {\n\t\t\t\t\tlet isWhitelisted;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst { external, transitive } = _parseExternalOptions(externalObj);\n\n\t\t\t\t\t\tisWhitelisted = external.some(ext => host.helpers.match(ext, moduleName)) || (transitive && parentAllowsTransitive);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tthrow Contextify.value(e);\n\t\t\t\t\t}\n\t\t\t\t\tif (!isWhitelisted) {\n\t\t\t\t\t\tthrow new VMError(`The module '${moduleName}' is not whitelisted in VM.`, 'EDENIED');\n\t\t\t\t\t}\n\n\t\t\t\t\tallowRequireTransitive = true;\n\t\t\t\t}\n\n\t\t\t\t// FIXME the paths array has side effects\n\t\t\t\tconst paths = currentDirname.split(pa.sep);\n\n\t\t\t\twhile (paths.length) {\n\t\t\t\t\tconst path = paths.join(pa.sep);\n\n\t\t\t\t\t// console.log moduleName, \"#{path}#{pa.sep}node_modules#{pa.sep}#{moduleName}\"\n\n\t\t\t\t\tfilename = _resolveFilename(`${path}${pa.sep}node_modules${pa.sep}${moduleName}`);\n\t\t\t\t\tif (filename) break;\n\n\t\t\t\t\tpaths.pop();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!filename) {\n\t\t\t\tlet resolveFunc;\n\t\t\t\ttry {\n\t\t\t\t\tresolveFunc = requireObj.resolve;\n\t\t\t\t} catch (e) {\n\t\t\t\t\tthrow Contextify.value(e);\n\t\t\t\t}\n\t\t\t\tif (resolveFunc) {\n\t\t\t\t\tlet resolved;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tresolved = requireObj.resolve(moduleName, currentDirname);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tthrow Contextify.value(e);\n\t\t\t\t\t}\n\t\t\t\t\tfilename = _resolveFilename(resolved);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!filename) throw new VMError(`Cannot find module '${moduleName}'`, 'ENOTFOUND');\n\n\t\t\t// return cache whenever possible\n\t\t\tif (CACHE[filename]) return CACHE[filename].exports;\n\n\t\t\tconst dirname = pa.dirname(filename);\n\t\t\tconst extname = pa.extname(filename);\n\n\t\t\tlet allowedModule = true;\n\t\t\ttry {\n\t\t\t\tconst rootObj = requireObj.root;\n\t\t\t\tif (rootObj) {\n\t\t\t\t\tconst rootPaths = host.Array.isArray(rootObj) ? rootObj : host.Array.of(rootObj);\n\t\t\t\t\tallowedModule = rootPaths.some(path => host.String.prototype.startsWith.call(dirname, pa.resolve(path)));\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tthrow Contextify.value(e);\n\t\t\t}\n\n\t\t\tif (!allowedModule) {\n\t\t\t\tthrow new VMError(`Module '${moduleName}' is not allowed to be required. The path is outside the border!`, 'EDENIED');\n\t\t\t}\n\n\t\t\tconst module = CACHE[filename] = {\n\t\t\t\tfilename,\n\t\t\t\texports: {},\n\t\t\t\trequire: _prepareRequire(dirname, allowRequireTransitive)\n\t\t\t};\n\n\t\t\t// lookup extensions\n\t\t\tif (EXTENSIONS[extname]) {\n\t\t\t\tEXTENSIONS[extname](module, filename, dirname);\n\t\t\t\treturn module.exports;\n\t\t\t}\n\n\t\t\tthrow new VMError(`Failed to load '${moduleName}': Unknown type.`, 'ELOADFAIL');\n\t\t};\n\n\t\treturn _require;\n\t};\n\n\t/**\n\t * Prepare sandbox.\n\t */\n\n\t// This is a function and not an arrow function, since the original is also a function\n\tglobal.setTimeout = function setTimeout(callback, delay, ...args) {\n\t\tif (typeof callback !== 'function') throw new TypeError('\"callback\" argument must be a function');\n\t\tlet tmr;\n\t\ttry {\n\t\t\ttmr = host.setTimeout(Decontextify.value(() => {\n\t\t\t\t// FIXME ...args has side effects\n\t\t\t\tcallback(...args);\n\t\t\t}), Decontextify.value(delay));\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\t\tconst local = Contextify.value(tmr);\n\n\t\tTIMERS.set(local, tmr);\n\t\treturn local;\n\t};\n\n\tglobal.setInterval = function setInterval(callback, interval, ...args) {\n\t\tif (typeof callback !== 'function') throw new TypeError('\"callback\" argument must be a function');\n\t\tlet tmr;\n\t\ttry {\n\t\t\ttmr = host.setInterval(Decontextify.value(() => {\n\t\t\t\t// FIXME ...args has side effects\n\t\t\t\tcallback(...args);\n\t\t\t}), Decontextify.value(interval));\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\n\t\tconst local = Contextify.value(tmr);\n\n\t\tTIMERS.set(local, tmr);\n\t\treturn local;\n\t};\n\n\tglobal.setImmediate = function setImmediate(callback, ...args) {\n\t\tif (typeof callback !== 'function') throw new TypeError('\"callback\" argument must be a function');\n\t\tlet tmr;\n\t\ttry {\n\t\t\ttmr = host.setImmediate(Decontextify.value(() => {\n\t\t\t\t// FIXME ...args has side effects\n\t\t\t\tcallback(...args);\n\t\t\t}));\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\n\t\tconst local = Contextify.value(tmr);\n\n\t\tTIMERS.set(local, tmr);\n\t\treturn local;\n\t};\n\n\tglobal.clearTimeout = function clearTimeout(local) {\n\t\ttry {\n\t\t\thost.clearTimeout(TIMERS.get(local));\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\t};\n\n\tglobal.clearInterval = function clearInterval(local) {\n\t\ttry {\n\t\t\thost.clearInterval(TIMERS.get(local));\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\t};\n\n\tglobal.clearImmediate = function clearImmediate(local) {\n\t\ttry {\n\t\t\thost.clearImmediate(TIMERS.get(local));\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\t};\n\n\tfunction addListener(name, handler) {\n\t\tif (name !== 'beforeExit' && name !== 'exit') {\n\t\t\tthrow new Error(`Access denied to listen for '${name}' event.`);\n\t\t}\n\n\t\ttry {\n\t\t\thost.process.on(name, Decontextify.value(handler));\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tconst {argv: optionArgv, env: optionsEnv} = options;\n\n\t// FIXME wrong class structure\n\tglobal.process = {\n\t\targv: optionArgv !== undefined ? Contextify.value(optionArgv) : [],\n\t\ttitle: host.process.title,\n\t\tversion: host.process.version,\n\t\tversions: Contextify.readonly(host.process.versions),\n\t\tarch: host.process.arch,\n\t\tplatform: host.process.platform,\n\t\tenv: optionsEnv !== undefined ? Contextify.value(optionsEnv) : {},\n\t\tpid: host.process.pid,\n\t\tfeatures: Contextify.readonly(host.process.features),\n\t\tnextTick: function nextTick(callback, ...args) {\n\t\t\tif (typeof callback !== 'function') {\n\t\t\t\tthrow new Error('Callback must be a function.');\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\thost.process.nextTick(Decontextify.value(() => {\n\t\t\t\t\t// FIXME ...args has side effects\n\t\t\t\t\tcallback(...args);\n\t\t\t\t}));\n\t\t\t} catch (e) {\n\t\t\t\tthrow Contextify.value(e);\n\t\t\t}\n\t\t},\n\t\thrtime: function hrtime(time) {\n\t\t\ttry {\n\t\t\t\treturn Contextify.value(host.process.hrtime(Decontextify.value(time)));\n\t\t\t} catch (e) {\n\t\t\t\tthrow Contextify.value(e);\n\t\t\t}\n\t\t},\n\t\tcwd: function cwd() {\n\t\t\ttry {\n\t\t\t\treturn Contextify.value(host.process.cwd());\n\t\t\t} catch (e) {\n\t\t\t\tthrow Contextify.value(e);\n\t\t\t}\n\t\t},\n\t\taddListener,\n\t\ton: addListener,\n\n\t\tonce: function once(name, handler) {\n\t\t\tif (name !== 'beforeExit' && name !== 'exit') {\n\t\t\t\tthrow new Error(`Access denied to listen for '${name}' event.`);\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\thost.process.once(name, Decontextify.value(handler));\n\t\t\t} catch (e) {\n\t\t\t\tthrow Contextify.value(e);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\n\t\tlisteners: function listeners(name) {\n\t\t\tif (name !== 'beforeExit' && name !== 'exit') {\n\t\t\t\t// Maybe add ({__proto__:null})[name] to throw when name fails in https://tc39.es/ecma262/#sec-topropertykey.\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\t// Filter out listeners, which were not created in this sandbox\n\t\t\ttry {\n\t\t\t\treturn Contextify.value(host.process.listeners(name).filter(listener => Contextify.isVMProxy(listener)));\n\t\t\t} catch (e) {\n\t\t\t\tthrow Contextify.value(e);\n\t\t\t}\n\t\t},\n\n\t\tremoveListener: function removeListener(name, handler) {\n\t\t\tif (name !== 'beforeExit' && name !== 'exit') {\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\thost.process.removeListener(name, Decontextify.value(handler));\n\t\t\t} catch (e) {\n\t\t\t\tthrow Contextify.value(e);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\n\t\tumask: function umask() {\n\t\t\tif (arguments.length) {\n\t\t\t\tthrow new Error('Access denied to set umask.');\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\treturn Contextify.value(host.process.umask());\n\t\t\t} catch (e) {\n\t\t\t\tthrow Contextify.value(e);\n\t\t\t}\n\t\t}\n\t};\n\n\tif (vm.options.console === 'inherit') {\n\t\tglobal.console = Contextify.readonly(host.console);\n\t} else if (vm.options.console === 'redirect') {\n\t\tglobal.console = {\n\t\t\tdebug(...args) {\n\t\t\t\ttry {\n\t\t\t\t\t// FIXME ...args has side effects\n\t\t\t\t\tvm.emit('console.debug', ...Decontextify.arguments(args));\n\t\t\t\t} catch (e) {\n\t\t\t\t\tthrow Contextify.value(e);\n\t\t\t\t}\n\t\t\t},\n\t\t\tlog(...args) {\n\t\t\t\ttry {\n\t\t\t\t\t// FIXME ...args has side effects\n\t\t\t\t\tvm.emit('console.log', ...Decontextify.arguments(args));\n\t\t\t\t} catch (e) {\n\t\t\t\t\tthrow Contextify.value(e);\n\t\t\t\t}\n\t\t\t},\n\t\t\tinfo(...args) {\n\t\t\t\ttry {\n\t\t\t\t\t// FIXME ...args has side effects\n\t\t\t\t\tvm.emit('console.info', ...Decontextify.arguments(args));\n\t\t\t\t} catch (e) {\n\t\t\t\t\tthrow Contextify.value(e);\n\t\t\t\t}\n\t\t\t},\n\t\t\twarn(...args) {\n\t\t\t\ttry {\n\t\t\t\t\t// FIXME ...args has side effects\n\t\t\t\t\tvm.emit('console.warn', ...Decontextify.arguments(args));\n\t\t\t\t} catch (e) {\n\t\t\t\t\tthrow Contextify.value(e);\n\t\t\t\t}\n\t\t\t},\n\t\t\terror(...args) {\n\t\t\t\ttry {\n\t\t\t\t\t// FIXME ...args has side effects\n\t\t\t\t\tvm.emit('console.error', ...Decontextify.arguments(args));\n\t\t\t\t} catch (e) {\n\t\t\t\t\tthrow Contextify.value(e);\n\t\t\t\t}\n\t\t\t},\n\t\t\tdir(...args) {\n\t\t\t\ttry {\n\t\t\t\t\tvm.emit('console.dir', ...Decontextify.arguments(args));\n\t\t\t\t} catch (e) {\n\t\t\t\t\tthrow Contextify.value(e);\n\t\t\t\t}\n\t\t\t},\n\t\t\ttime() {},\n\t\t\ttimeEnd() {},\n\t\t\ttrace(...args) {\n\t\t\t\ttry {\n\t\t\t\t\t// FIXME ...args has side effects\n\t\t\t\t\tvm.emit('console.trace', ...Decontextify.arguments(args));\n\t\t\t\t} catch (e) {\n\t\t\t\t\tthrow Contextify.value(e);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\t/*\n\tReturn contextified require.\n\t*/\n\n\treturn _prepareRequire;\n})(vm, host);\n", "/* eslint-env mocha */\n/* eslint-disable no-new-wrappers, max-len */\n\n'use strict';\n\nconst assert = require('assert');\nconst {VM, VMScript} = require('..');\nconst NODE_VERSION = parseInt(process.versions.node.split('.')[0]);\nconst {inspect} = require('util');\n\nglobal.isVM = false;\n\ndescribe('node', () => {\n\tlet vm;\n\n\tconst doubleProxy = new Proxy(new Proxy({x: 1}, {get() {\n\t\tthrow new Error('Expected');\n\t}}), {});\n\n\tbefore(() => {\n\t\tvm = new VM();\n\t});\n\tit('inspect', () => {\n\t\tassert.throws(() => inspect(doubleProxy), /Expected/);\n\t\tif (NODE_VERSION !== 10) {\n\t\t\t// This failes on node 10 since they do not unwrap proxys.\n\t\t\t// And the hack to fix this is only in the inner proxy.\n\t\t\t// We could add another hack, but that one would require\n\t\t\t// to look if the caller is from a special node function and\n\t\t\t// then remove all the integer keys. To get the caller we\n\t\t\t// would need to get the stack trace which is slow and\n\t\t\t// the probability of this call is so low that I don't do\n\t\t\t// this right now.\n\t\t\tassert.strictEqual(inspect(vm.run('[1, 2, 3]')), inspect([1, 2, 3]), true);\n\t\t}\n\t});\n\tafter(() => {\n\t\tvm = null;\n\t});\n});\n\ndescribe('contextify', () => {\n\tlet vm;\n\n\tclass TestClass {\n\t\tconstructor() {\n\t\t\tthis.greeting = 'hello';\n\t\t}\n\n\t\tgreet(name) {\n\t\t\treturn `${this.greeting} ${name}`;\n\t\t}\n\t}\n\n\tconst sandbox = {\n\t\tassert,\n\t\ttest: {\n\t\t\tstring: 'text',\n\t\t\tstringO: new String('text'),\n\t\t\tnumber: 1,\n\t\t\tnumberO: new Number(1),\n\t\t\tboolean: true,\n\t\t\tbooleanO: new Boolean(true),\n\t\t\tdate: new Date(),\n\t\t\tregexp: /xxx/,\n\t\t\tbuffer: Buffer.from([0x00, 0x01]),\n\t\t\t'function'() {\n\t\t\t\treturn () => ({});\n\t\t\t},\n\t\t\tobject: {\n\t\t\t\tx: 1,\n\t\t\t\ty() {\n\t\t\t\t\treturn i => i instanceof Object;\n\t\t\t\t},\n\t\t\t\tz(i) {\n\t\t\t\t\tif (!(i instanceof Object)) throw new Error('Not instanceof parent Object.');\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t},\n\t\t\tnil: null,\n\t\t\tundef: void 0,\n\t\t\tklass: TestClass,\n\t\t\tsymbol1: Symbol('foo'),\n\t\t\tsymbol2: Symbol.for('foo'),\n\t\t\tsymbol3: Symbol.iterator,\n\t\t\terror: new Error('test')\n\t\t}\n\t};\n\n\tbefore(() => {\n\t\tvm = new VM({sandbox});\n\t});\n\n\tit('common', () => {\n\t\tassert.ok(vm.run(`global.__proto__ === Object.prototype`));\n\t\tassert.ok(vm.run(`global.__proto__.constructor === Object`));\n\t\tassert.ok(vm.run(`Object.__proto__ === Function.prototype`));\n\t\tassert.ok(vm.run(`Object.__proto__.constructor === Function`));\n\t\tassert.ok(vm.run(`Object.prototype.__proto__ === null`));\n\t\tassert.ok(vm.run(`Function.__proto__ === Function.prototype`));\n\t\tassert.ok(vm.run(`Function.__proto__.constructor === Function`));\n\t\tassert.ok(vm.run(`Function.prototype.__proto__ === Object.prototype`));\n\t\tassert.ok(vm.run(`Array.__proto__ === Function.prototype`));\n\t\tassert.ok(vm.run(`Array.__proto__.constructor === Function`));\n\t\tassert.ok(vm.run(`Array.prototype.__proto__ === Object.prototype`));\n\n\t\tassert.strictEqual(sandbox.test.object.y === sandbox.test.object.y.valueOf(), true);\n\t\tassert.strictEqual(vm.run('test.object.y instanceof Function'), true);\n\t\tassert.strictEqual(vm.run('test.object.y.valueOf() instanceof Function'), true);\n\t\tassert.strictEqual(vm.run('test.object.y').isVMProxy, void 0);\n\t\tassert.strictEqual(vm.run('test.object.y.valueOf()').isVMProxy, void 0);\n\t\tassert.strictEqual(vm.run('test.object.y') === vm.run('test.object.y.valueOf()'), true);\n\t\tassert.strictEqual(vm.run('test.object.y === test.object.y.valueOf()'), true);\n\t\tassert.strictEqual(vm.run('test.object').y instanceof Function, true);\n\t\tassert.strictEqual(vm.run('test.object').y.valueOf() instanceof Function, true);\n\t\tassert.strictEqual(vm.run('test.object').y.isVMProxy, void 0);\n\t\tassert.strictEqual(vm.run('test.object').y.valueOf().isVMProxy, void 0);\n\t\tassert.strictEqual(vm.run('test.object').y === vm.run('test.object').y.valueOf(), true);\n\t\tassert.strictEqual(vm.run('test.valueOf()') === vm.run('test').valueOf(), true);\n\t\tassert.strictEqual(vm.run('test.object.y.constructor instanceof Function'), true);\n\t\tassert.strictEqual(vm.run(\"test.object.y.constructor('return (function(){return this})().isVM')()\"), true);\n\t\tassert.strictEqual(vm.run('test.object.valueOf() instanceof Object'), true);\n\t\tassert.strictEqual(vm.run('test.object.valueOf().y instanceof Function'), true);\n\t\tassert.strictEqual(vm.run('test.object.valueOf().y.constructor instanceof Function'), true);\n\t\tassert.strictEqual(vm.run(\"test.object.valueOf().y.constructor('return (function(){return this})().isVM')()\"), true);\n\n\t\tassert.strictEqual(Object.prototype.toString.call(vm.run(`[]`)), '[object Array]');\n\t\tassert.strictEqual(Object.prototype.toString.call(vm.run(`new Date`)), '[object Date]');\n\t\tassert.strictEqual(Object.prototype.toString.call(vm.run(`new RangeError`)), '[object Error]');\n\t\tassert.strictEqual(Object.prototype.toString.call(vm.run(`/a/g`)), '[object RegExp]');\n\t\tassert.strictEqual(Object.prototype.toString.call(vm.run(`new String`)), '[object String]');\n\t\tassert.strictEqual(Object.prototype.toString.call(vm.run(`new Number`)), '[object Number]');\n\t\tassert.strictEqual(Object.prototype.toString.call(vm.run(`new Boolean`)), '[object Boolean]');\n\n\t\tassert.strictEqual(vm.run(`((obj) => Object.prototype.toString.call(obj))`)([]), '[object Array]');\n\t\tassert.strictEqual(vm.run(`((obj) => Object.prototype.toString.call(obj))`)(new Date), '[object Date]');\n\t\tassert.strictEqual(vm.run(`((obj) => Object.prototype.toString.call(obj))`)(new RangeError), '[object Error]');\n\t\tassert.strictEqual(vm.run(`((obj) => Object.prototype.toString.call(obj))`)(/a/g), '[object RegExp]');\n\t\tassert.strictEqual(vm.run(`((obj) => Object.prototype.toString.call(obj))`)(new String), '[object String]');\n\t\tassert.strictEqual(vm.run(`((obj) => Object.prototype.toString.call(obj))`)(new Number), '[object Number]');\n\t\tassert.strictEqual(vm.run(`((obj) => Object.prototype.toString.call(obj))`)(new Boolean), '[object Boolean]');\n\n\t\tassert.strictEqual(typeof vm.run(`new String`), 'object');\n\t\tassert.strictEqual(typeof vm.run(`new Number`), 'object');\n\t\tassert.strictEqual(typeof vm.run(`new Boolean`), 'object');\n\t\tassert.strictEqual(vm.run(`((obj) => typeof obj)`)(new String), 'object');\n\t\tassert.strictEqual(vm.run(`((obj) => typeof obj)`)(new Number), 'object');\n\t\tassert.strictEqual(vm.run(`((obj) => typeof obj)`)(new Boolean), 'object');\n\n\t\tlet o = vm.run('let x = {a: test.date, b: test.date};x');\n\t\tassert.strictEqual(vm.run('x.valueOf().a instanceof Date'), true);\n\t\tassert.strictEqual(o instanceof Object, true);\n\t\tassert.strictEqual(o.a instanceof Date, true);\n\t\tassert.strictEqual(o.b instanceof Date, true);\n\t\tassert.strictEqual(o.a === o.b, true);\n\t\tassert.strictEqual(o.a === sandbox.test.date, true);\n\n\t\to = vm.run('let y = new Date(); let z = {a: y, b: y};z');\n\t\tassert.strictEqual(o.isVMProxy, true);\n\t\tassert.strictEqual(o instanceof Object, true);\n\t\tassert.strictEqual(o.a instanceof Date, true);\n\t\tassert.strictEqual(o.b instanceof Date, true);\n\t\tassert.strictEqual(o.a === o.b, true);\n\t});\n\n\tit('class', () => {\n\t\tassert.strictEqual(vm.run('new test.klass()').isVMProxy, undefined);\n\t\tassert.strictEqual(vm.run('new test.klass()').greet('friend'), 'hello friend');\n\t\tassert.strictEqual(vm.run('new test.klass()') instanceof TestClass, true);\n\n\t\t// vm.run(\"class LocalClass extends test.klass {}\");\n\t});\n\n\tit('string', () => {\n\t\tassert.strictEqual(vm.run('(test.string).constructor === String'), true);\n\t\tassert.strictEqual(vm.run(\"typeof(test.string) === 'string' && test.string.valueOf instanceof Object\"), true);\n\t});\n\n\tit('number', () => {\n\t\tassert.strictEqual(vm.run(\"typeof(test.number) === 'number' && test.number.valueOf instanceof Object\"), true);\n\t});\n\n\tit('boolean', () => {\n\t\tassert.strictEqual(vm.run(\"typeof(test.boolean) === 'boolean' && test.boolean.valueOf instanceof Object\"), true);\n\t});\n\n\tit('date', () => {\n\t\tassert.strictEqual(vm.run('test.date instanceof Date'), true);\n\t\tassert.strictEqual(vm.run('test.date') instanceof Date, true);\n\t\tassert.strictEqual(vm.run('test.date'), sandbox.test.date);\n\t});\n\n\tit('regexp', () => {\n\t\tassert.strictEqual(vm.run('test.regexp instanceof RegExp'), true);\n\t});\n\n\tit('buffer', () => {\n\t\tassert.strictEqual(vm.run('test.buffer.inspect()'), '<Buffer 00 01>', '#1');\n\t\tassert.strictEqual(vm.run('test.buffer instanceof Buffer'), true, '#2');\n\t\tassert.strictEqual(vm.run('test.buffer') instanceof Buffer, true, '#3');\n\t\tassert.strictEqual(vm.run('test.buffer'), sandbox.test.buffer, '#4');\n\t\tassert.strictEqual(vm.run('class Buffer2 extends Buffer {};Buffer2.alloc(5)').fill(1).inspect(), '<Buffer 01 01 01 01 01>');\n\n\t\tconst {a, b, c, d} = vm.run(`\n\t\t\tlet a = Buffer.from([0x01, 0x02]);\n\t\t\tlet b = Buffer.alloc(3, 0x03);\n\t\t\tlet c = Buffer.from(a);\n\t\t\tlet d = Buffer.concat([a, b, c]);\n\n\t\t\tassert.ok(a instanceof Buffer, '#1');\n\t\t\tassert.ok(b instanceof Buffer, '#2');\n\t\t\tassert.ok(c instanceof Buffer, '#3');\n\t\t\tassert.ok(d instanceof Buffer, '#4');\n\t\t\tassert.ok(a.constructor === Buffer, '#5');\n\t\t\tassert.ok(b.constructor === Buffer, '#6');\n\t\t\tassert.ok(c.constructor === Buffer, '#7');\n\t\t\tassert.ok(d.constructor === Buffer, '#8');\n\t\t\tassert.ok(a.constructor.constructor === Function, '#9');\n\t\t\tassert.ok(b.constructor.constructor === Function, '#10');\n\t\t\tassert.ok(c.constructor.constructor === Function, '#11');\n\t\t\tassert.ok(d.constructor.constructor === Function, '#12');\n\n\t\t\t({a: a, b: b, c: c, d: d})\n\t\t`);\n\n\t\tassert.ok(a instanceof Buffer);\n\t\tassert.ok(b instanceof Buffer);\n\t\tassert.ok(c instanceof Buffer);\n\t\tassert.ok(d instanceof Buffer);\n\t\tassert.ok(a.constructor === Buffer);\n\t\tassert.ok(b.constructor === Buffer);\n\t\tassert.ok(c.constructor === Buffer);\n\t\tassert.ok(d.constructor === Buffer);\n\t\tassert.ok(a.constructor.constructor === Function);\n\t\tassert.ok(b.constructor.constructor === Function);\n\t\tassert.ok(c.constructor.constructor === Function);\n\t\tassert.ok(d.constructor.constructor === Function);\n\t});\n\n\tit('function', () => {\n\t\tassert.strictEqual(vm.run('test.function instanceof Function'), true, '#1');\n\t\tassert.strictEqual(vm.run('test.function() instanceof Function'), true, '#2');\n\t\tassert.strictEqual(vm.run('test.function()() instanceof Object'), true, '#3');\n\t});\n\n\tit('object', () => {\n\t\tassert.strictEqual(vm.run('test.object instanceof Object && test.object.x === 1'), true, '#1');\n\t\tassert.strictEqual(vm.run('test.object.y instanceof Function'), true, '#2');\n\t\tassert.strictEqual(vm.run('test.object.y() instanceof Function'), true, '#3');\n\t\tassert.strictEqual(vm.run('test.object.y()({})'), true, '#4');\n\t\tassert.strictEqual(vm.run('test.object.z({}) instanceof Object'), true, '#5');\n\t\tassert.strictEqual(vm.run(\"Object.getOwnPropertyDescriptor(test.object, 'y').hasOwnProperty instanceof Function\"), true, '#6');\n\t\tassert.strictEqual(vm.run(\"Object.getOwnPropertyDescriptor(test.object, 'y').hasOwnProperty.constructor('return (function(){return this})().isVM')()\"), true, '#7');\n\t});\n\n\tit('null', () => {\n\t\tassert.strictEqual(vm.run('test.nil === null'), true);\n\t});\n\n\tit('undefined', () => {\n\t\tassert.strictEqual(vm.run('test.undef === undefined'), true);\n\t});\n\n\tit('symbol', () => {\n\t\tassert.strictEqual(vm.run(\"Symbol.for('foo') === test.symbol2\"), true);\n\t\tassert.strictEqual(vm.run('test.symbol1.constructor.constructor === Function'), true);\n\t\tassert.strictEqual(vm.run('test.symbol2.constructor.constructor === Function'), true);\n\t\tassert.strictEqual(vm.run('test.symbol3.constructor.constructor === Function'), true);\n\t\tassert.strictEqual(vm.run(\"Symbol('foo').constructor.constructor === Function\"), true);\n\t\tassert.strictEqual(vm.run(\"Symbol('foobar').constructor.constructor === Function\"), true);\n\t\tassert.strictEqual(vm.run('Symbol.keyFor(test.symbol2)'), 'foo');\n\t});\n\n\tit('error', () => {\n\t\tassert.strictEqual(vm.run('test.error.constructor.constructor === Function;'), true);\n\t});\n\n\tafter(() => {\n\t\tvm = null;\n\t});\n});\n\ndescribe('VM', () => {\n\tlet vm;\n\n\tconst sandbox = {\n\t\tround(number) {\n\t\t\treturn Math.round(number);\n\t\t},\n\t\tsub: {}\n\t};\n\n\tObject.defineProperty(sandbox.sub, 'getter', {\n\t\tget() {\n\t\t\tconst results = [];\n\t\t\twhile (true) {\n\t\t\t\tresults.push(1);\n\t\t\t}\n\t\t\treturn results;\n\t\t}\n\t});\n\n\tbefore(() => {\n\t\tvm = new VM({\n\t\t\tsandbox\n\t\t});\n\t});\n\n\tit('globals', () => {\n\t\tconst dyn = {};\n\t\tvm.setGlobal('dyn', dyn);\n\t\tvm.setGlobals({dyns: dyn});\n\t\tassert.equal(vm.run('round(1.5)'), 2);\n\t\tassert.equal(vm.getGlobal('dyn'), dyn);\n\t\tassert.equal(vm.sandbox.dyn, dyn);\n\t\tassert.equal(vm.sandbox.dyns, dyn);\n\t});\n\n\tit('errors', () => {\n\t\tassert.throws(() => vm.run('notdefined'), /notdefined is not defined/);\n\t\tassert.throws(() => vm.run('Object.setPrototypeOf(sub, {})'), err => {\n\t\t\tassert.ok(err instanceof Error);\n\t\t\tassert.equal(err.name, 'VMError');\n\t\t\tassert.equal(err.message, 'Operation not allowed on contextified object.');\n\t\t\treturn true;\n\t\t});\n\n\t\tif (NODE_VERSION > 6) {\n\t\t\t// async/await was not there in Node 6\n\t\t\tassert.throws(() => vm.run('function test(){ return await Promise.resolve(); };'), err => {\n\t\t\t\tassert.ok(err instanceof Error);\n\t\t\t\tassert.equal(err.name, 'SyntaxError');\n\t\t\t\tassert.equal(err.message, 'await is only valid in async function');\n\t\t\t\treturn true;\n\t\t\t});\n\t\t}\n\t\tassert.throws(() => new VM({compiler: 'nonexistant'}), /Unsupported compiler/);\n\t\tassert.throws(() => new VMScript('', '', {compiler: 'nonexistant'}), /Unsupported compiler/);\n\t});\n\n\tit('timeout', () => {\n\t\tconst message = NODE_VERSION >= 11 ? /Script execution timed out after 10ms/ : /Script execution timed out\\./;\n\n\t\tassert.throws(() => new VM({\n\t\t\ttimeout: 10\n\t\t}).run('while (true) {}'), message);\n\t\tassert.throws(() => new VM({timeout: 10, sandbox}).run('sub.getter'), message);\n\t});\n\n\tit('timers', () => {\n\t\tassert.equal(vm.run('global.setTimeout'), void 0);\n\t\tassert.equal(vm.run('global.setInterval'), void 0);\n\t\tassert.equal(vm.run('global.setImmediate'), void 0);\n\t});\n\n\tif (NODE_VERSION >= 10) {\n\t\tit('eval/wasm', () => {\n\t\t\tassert.equal(vm.run('eval(\"1\")'), 1);\n\n\t\t\tconst vm2 = new VM({eval: false});\n\t\t\tassert.throws(() => vm2.run('eval(\"1\")'), /Code generation from strings disallowed for this context/);\n\t\t});\n\t}\n\n\tif (NODE_VERSION > 7) {\n\t\t// Node until 7 had no async, see https://node.green/\n\t\tit('async', () => {\n\t\t\tconst vm2 = new VM({fixAsync: true});\n\t\t\tassert.throws(() => vm2.run('(async function(){})'), /Async not available/, '#1');\n\t\t\tassert.strictEqual(vm2.run('Object.getPrototypeOf((function*(){}).constructor)'), vm2.run('Function'), '#2');\n\t\t\tassert.throws(() => vm2.run('new Function(\"(as\"+\"ync function(){})\")'), /Async not available/, '#3');\n\t\t\tassert.throws(() => vm2.run('new (function*(){}).constructor(\"(as\"+\"ync function(){})\")'), /Async not available/, '#4');\n\t\t\tassert.throws(() => vm2.run('Promise.resolve().then(function(){})'), /Async not available/, '#5');\n\t\t\tif (Promise.prototype.finally) assert.throws(() => vm2.run('Promise.resolve().finally(function(){})'), /Async not available/, '#6');\n\t\t\tif (Promise.prototype.catch) assert.throws(() => vm2.run('Promise.resolve().catch(function(){})'), /Async not available/, '#7');\n\t\t\tassert.throws(() => vm2.run('eval(\"(as\"+\"ync function(){})\")'), /Async not available/, '#8');\n\t\t\tassert.throws(() => vm2.run('Function')('(async function(){})'), /Async not available/, '#9');\n\t\t});\n\t}\n\n\tit('proxy trap errors', () => {\n\t\tconst vm2 = new VM();\n\t\tassert.doesNotThrow(() => {\n\t\t\tReflect.ownKeys(vm2.run('(function(){}).bind(null)'));\n\t\t});\n\t});\n\n\tit('frozen unconfigurable access', () => {\n\t\tconst vm2 = new VM();\n\t\tconst obj = {};\n\n\t\tassert.doesNotThrow(()=>{\n\t\t\tvm2.run('x => x.prop')(Object.freeze({prop: {}}));\n\t\t});\n\n\t\tassert.doesNotThrow(()=>{\n\t\t\tvm2.run('x => Object.getOwnPropertyDescriptor(x, \"prop\")')(Object.freeze({prop: {}}));\n\t\t});\n\n\t\tassert.doesNotThrow(()=>{\n\t\t\tvm2.run('x => x.prop')(Object.defineProperty({}, 'prop', {value: {}}));\n\t\t});\n\n\t\tassert.doesNotThrow(()=>{\n\t\t\tvm2.run('x => Object.isExtensible(x)')(Object.freeze({prop: {}}));\n\t\t});\n\n\t\tassert.doesNotThrow(()=>{\n\t\t\tvm2.run('x => {Object.preventExtensions(x); Object.getOwnPropertyDescriptor(x, \"prop\")}')({prop: {}});\n\t\t});\n\n\t\tassert.strictEqual(vm2.run('x => {Object.preventExtensions(x); return Object.getOwnPropertyDescriptor(x, \"prop\").value}')({prop: obj}), obj);\n\n\t});\n\n\tit('various attacks #1', () => {\n\t\tconst vm2 = new VM({sandbox: {log: console.log, boom: () => {\n\t\t\tthrow new Error();\n\t\t}}});\n\n\t\tassert.strictEqual(vm2.run(\"this.constructor.constructor('return Function(\\\\'return Function\\\\')')()() === this.constructor.constructor('return Function')()\"), true);\n\n\t\tassert.throws(() => vm2.run(`\n\t\t\tconst ForeignFunction = global.constructor.constructor;\n\t\t\tconst process1 = ForeignFunction(\"return process\")();\n\t\t`), /process is not defined/, '#1');\n\n\t\tassert.throws(() => vm2.run(`\n\t\t    try {\n\t\t        boom();\n\t\t    }\n\t\t    catch (e) {\n\t\t        const foreignFunction = e.constructor.constructor;\n\t\t        const process = foreignFunction(\"return process\")();\n\t\t    }\n\t\t`), /process is not defined/, '#2');\n\n\t\tassert.doesNotThrow(() => vm2.run(`\n\t\t\tfunction exploit(o) {\n\t\t\t\tthrow new Error('Shouldnt be there.');\n\t\t\t}\n\n\t\t\tReflect.construct = exploit;\n\t\t\tBuffer.from([0]);\n\t\t`), '#3');\n\n\t\tassert.doesNotThrow(() => vm2.run(`\n\t\t\tglobal.Proxy = function() {\n\t\t\t\tthrow new Error('Shouldnt be there.');\n\t\t\t}\n\t\t`), '#4');\n\n\t\tassert.doesNotThrow(() => vm2.run(`\n\t\t\tglobal.String = function(text) {\n\t\t\t\tthrow new Error('Shouldnt be there.');\n\t\t\t};(function(text) {})\n\t\t`)('asdf'), '#5');\n\n\t\tassert.doesNotThrow(() => vm2.run(`\n\t\t\tglobal.String = function(text) {\n\t\t\t\tthrow new Error('Shouldnt be there.');\n\t\t\t};(function(text) {})\n\t\t`)(new String('asdf')), '#6');\n\n\t\tassert.doesNotThrow(() => vm2.run(`\n\t\t\tglobal.Buffer = function(value) {\n\t\t\t\tthrow new Error('Shouldnt be there.');\n\t\t\t};(function(value) {})\n\t\t`)(Buffer.alloc(1)), '#7');\n\t});\n\n\tit('various attacks #2', () => {\n\t\tconst vm2 = new VM({\n\t\t\tsandbox: {\n\t\t\t\tboom: () => {},\n\t\t\t\terror: new Error('test')\n\t\t\t}\n\t\t});\n\n\t\tassert.doesNotThrow(() => vm2.run(`\n\t\t\tObject.assign = function (o) {\n\t\t\t\tthrow new Error('Shouldnt be there.');\n\t\t\t};\n\t\t\tBuffer.from([0]);\n\t\t`), '#1');\n\n\t\tassert.doesNotThrow(() => vm2.run(`\n\t\t\ttry {\n\t\t\t\tBuffer.alloc(0);\n\t\t\t} catch (e) {\n\t\t\t\tif (e.constructor.constructor !== Function) throw new Error('Shouldnt be there.');\n\t\t\t}\n\t\t`), '#2');\n\n\t\tassert.doesNotThrow(() => vm2.run(`\n\t\t\tlet o;\n\t\t\tArray.prototype.map = function(callback) {\n\t\t\t\to = callback(boom);\n\t\t\t\treturn [];\n\t\t\t};\n\t\t\tboom(boom);\n\t\t\tif (o && o.constructor !== Function) throw new Error('Shouldnt be there.');\n\t\t`), '#3');\n\n\t\tassert.doesNotThrow(() => vm2.run(`\n\t\t\tlet method = () => {};\n\t\t\tlet proxy = new Proxy(method, {\n\t\t\t\tapply: (target, context, args) => {\n\t\t\t\t\tif (target.constructor.constructor !== Function) throw new Error('Shouldnt be there.');\n\t\t\t\t\tif (args.constructor.constructor !== Function) throw new Error('Shouldnt be there.');\n\t\t\t\t}\n\t\t\t});\n\t\t\tproxy\n\t\t`)('asdf'), '#4');\n\n\t\tassert.doesNotThrow(() => vm2.run(`\n\t\t\tlet proxy2 = new Proxy(function() {}, {\n\t\t\t\tapply: (target, context, args) => {\n\t\t\t\t\tif (args.constructor.constructor !== Function) throw new Error('Shouldnt be there.');\n\t\t\t\t}\n\t\t\t});\n\t\t\tproxy2\n\t\t`)('asdf'), '#5');\n\n\t\tassert.strictEqual(vm2.run(`\n\t\t\tglobal.DEBUG = true;\n\t\t\tboom.vmProxyTarget\n\t\t`), undefined, '#6');\n\n\t\tassert.throws(() => vm2.run(`\n\t\t\tglobal.constructor.constructor('return this')().constructor.constructor('return process')()\n\t\t`), /process is not defined/, '#7');\n\n\t\tassert.throws(() => vm2.run(`\n\t\t\tglobal.__proto__.constructor.constructor('return this')().constructor.constructor('return process')()\n\t\t`), /process is not defined/, '#8');\n\n\t\tassert.doesNotThrow(() => vm2.run(`\n\t\t\tif (!(Object.keys(boom) instanceof Array)) throw new Error('Shouldnt be there.');\n\t\t\tif (!(Reflect.ownKeys(boom) instanceof Array)) throw new Error('Shouldnt be there.');\n\t\t`));\n\t});\n\n\tit('buffer attack', () => {\n\t\tconst vm2 = new VM();\n\n\t\tassert.strictEqual(vm2.run(`\n\t\t\tBuffer.alloc(100).toString('hex');\n\t\t`), '00'.repeat(100), '#1');\n\n\t\tassert.strictEqual(vm2.run(`\n\t\t\tBuffer.allocUnsafe(100).constructor.constructor === Function;\n\t\t`), true, '#2');\n\n\t\tassert.strictEqual(vm2.run(`\n\t\t\tBuffer.allocUnsafe(100).toString('hex');\n\t\t`), '00'.repeat(100), '#3');\n\n\t\tassert.strictEqual(vm2.run(`\n\t\t\tclass MyBuffer extends Buffer {}; MyBuffer.alloc(100).toString('hex');\n\t\t`), '00'.repeat(100), '#4');\n\n\t\tassert.strictEqual(vm2.run(`\n\t\t\tnew Buffer(100).toString('hex');\n\t\t`), '00'.repeat(100), '#5');\n\n\t\tif (NODE_VERSION < 8) {\n\t\t\tassert.strictEqual(vm2.run(`\n\t\t\t\tBuffer(100).toString('hex');\n\t\t\t`), '00'.repeat(100), '#6');\n\t\t}\n\n\t\tassert.strictEqual(vm2.run(`\n\t\t\tclass MyBuffer2 extends Buffer {}; new MyBuffer2(100).toString('hex');\n\t\t`), '00'.repeat(100), '#7');\n\n\t});\n\n\tit('instanceof attack', () => {\n\t\t// https://github.com/patriksimek/vm2/issues/174\n\n\t\tconst vm2 = new VM({\n\t\t\tsandbox: {\n\t\t\t\tfunc: cb => cb()\n\t\t\t}\n\t\t});\n\n\t\ttry {\n\t\t\tvm2.run(`\n\t\t\t\tfunc(() => {\n\t\t\t\t\tthrow new Proxy({}, {\n\t\t\t\t\t\tgetPrototypeOf: () => {\n\t\t\t\t\t\t\tthrow x => x.constructor.constructor(\"return process;\")();\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t});\n\t\t\t`);\n\t\t} catch (ex) {\n\t\t\tassert.strictEqual(ex, null);\n\t\t}\n\t});\n\n\tit('__defineGetter__ / __defineSetter__ attack', () => {\n\t\t// https://github.com/patriksimek/vm2/issues/176\n\n\t\tconst vm2 = new VM();\n\n\t\tassert.strictEqual(vm2.run(`\n\t\t\tBuffer.prototype.__defineGetter__ === {}.__defineGetter__;\n\t\t`), true, '#1');\n\n\t\tif (NODE_VERSION > 6) {\n\t\t\tassert.throws(() => vm2.run(`\n\t\t\t\tBuffer.prototype.__defineGetter__(\"toString\", () => {});\n\t\t\t`), /'defineProperty' on proxy: trap returned falsish for property 'toString'/, '#2');\n\t\t} else {\n\t\t\tassert.strictEqual(vm2.run(`\n\t\t\t\tBuffer.prototype.__defineGetter__(\"xxx\", () => 4);\n\t\t\t\tBuffer.prototype.xxx;\n\t\t\t`), undefined, '#2');\n\t\t}\n\n\t\tassert.strictEqual(vm2.run(`\n\t\t\tglobal.__defineGetter__(\"test\", () => 123); global.test;\n\t\t`), 123, '#3');\n\t});\n\n\tit('__lookupGetter__ / __lookupSetter__ attack', () => {\n\t\t// https://github.com/patriksimek/vm2/issues/184\n\n\t\tconst vm2 = new VM();\n\n\t\tassert.strictEqual(vm2.run(`\n\t\t\tBuffer.from.__lookupGetter__(\"__proto__\") === Object.prototype.__lookupGetter__.call(Buffer.from, \"__proto__\");\n\t\t`), true, '#1');\n\t});\n\n\tit('contextifying a contextified value attack', () => {\n\t\t// https://github.com/patriksimek/vm2/issues/175\n\t\t// https://github.com/patriksimek/vm2/issues/177\n\t\t// https://github.com/patriksimek/vm2/issues/186\n\n\t\tlet vm2 = new VM();\n\n\t\t// The Buffer.from(\"\") is only used to get instance of object contextified from the host\n\t\tassert.doesNotThrow(() => vm2.run(`\n\t\t\tObject.defineProperty(Buffer.from(\"\"), \"x\", {\n\t\t\t\tget set() {\n\t\t\t\t\tObject.defineProperty(Object.prototype, \"get\", {\n\t\t\t\t\t\tget() {\n\t\t\t\t\t\t\tthrow new Error();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\treturn ()=>{};\n\t\t\t\t}\n\t\t\t});\n\t\t`), '#1');\n\n\t\tvm2 = new VM({\n\t\t\tsandbox: {\n\t\t\t\tctor: X => new X(),\n\t\t\t\tcall: x => x()\n\t\t\t}\n\t\t});\n\n\t\tassert.throws(() => vm2.run(`\n\t\t\tcall(ctor(new Proxy(class A {}, {\n\t\t\t\tconstruct(){\n\t\t\t\t\treturn () => x => x.constructor(\"return process\")();\n\t\t\t\t}\n\t\t\t})))(()=>{}).mainModule.require(\"child_process\").execSync(\"id\").toString()\n\t\t`), /process is not defined/, '#2');\n\n\t\tvm2 = new VM();\n\n\t\tassert.throws(() => vm2.run(`\n\t\t\tvar process;\n\t\t\ttry {\n\t\t\t\tObject.defineProperty(Buffer.from(\"\"), \"y\", {\n\t\t\t\t\twritable: true,\n\t\t\t\t\tvalue: new Proxy({}, {\n\t\t\t\t\t\tgetPrototypeOf(target) {\n\t\t\t\t\t\t\tdelete this.getPrototypeOf;\n\t\t\t\n\t\t\t\t\t\t\tObject.defineProperty(Object.prototype, \"get\", {\n\t\t\t\t\t\t\t\tget() {\n\t\t\t\t\t\t\t\t\tdelete Object.prototype.get;\n\t\t\t\t\t\t\t\t\tFunction.prototype.__proto__ = null;\n\t\t\t\t\t\t\t\t\tthrow f=>f.constructor(\"return process\")();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\n\t\t\t\t\t\t\treturn Object.getPrototypeOf(target);\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t});\n\t\t\t} catch(e) {\n\t\t\t\tprocess = e(() => {});\n\t\t\t}\n\t\t\tprocess.mainModule.require(\"child_process\").execSync(\"whoami\").toString()\n\t\t`), /Cannot read property 'mainModule' of undefined/, '#3');\n\n\t\tvm2 = new VM();\n\n\t\tassert.doesNotThrow(() => vm2.run(`\n\t\t\tObject.defineProperty(Buffer.from(\"\"), \"\", {\n\t\t\t\tvalue: new Proxy({}, {\n\t\t\t\t\tgetPrototypeOf(target) {\n\t\t\t\t\t\tif(this.t) {\n\t\t\t\t\t\t\tthrow Buffer.from;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis.t=true;\n\t\t\t\t\t\treturn Object.getPrototypeOf(target);\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t});\n\t\t`), '#4');\n\n\t\tvm2 = new VM();\n\n\t\tassert.throws(() => vm2.run(`\n\t\t\tFunction.prototype.__proto__ = null;\n\t\t\tvar process;\n\t\t\ttry {\n\t\t\t\tBuffer.from(new Proxy({}, {\n\t\t\t\t\tgetPrototypeOf() {\n\t\t\t\t\t\tif (this.t) {\n\t\t\t\t\t\t\tthrow x => x.constructor(\"return process\")();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.t = true;\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t}));\n\t\t\t} catch(e) {\n\t\t\t\tprocess = e(() => {});\n\t\t\t}\n\t\t\tprocess.mainModule.require(\"child_process\").execSync(\"whoami\").toString()\n\t\t`), /e is not a function/, '#5');\n\n\t\tvm2 = new VM();\n\n\t\tassert.throws(() => vm2.run(`\n\t\t\tFunction.prototype.__proto__ = null;\n\t\t\tvar map = {\n\t\t\t\tvalueOf(){\n\t\t\t\t\tthrow new Proxy({},{\n\t\t\t\t\t\tgetPrototypeOf(){\n\t\t\t\t\t\t\tif(this.t) {\n\t\t\t\t\t\t\t\tthrow x=>x.constructor(\"return process\")();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis.t = true;\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t};\n\t\t\tvar process;\n\t\t\ttry{\n\t\t\t\tBuffer.from(map);\n\t\t\t}catch(e){\n\t\t\t\tprocess = e(x=>x);\n\t\t\t}\n\t\t\tprocess.mainModule.require(\"child_process\").execSync(\"whoami\").toString()\n\t\t`), /e is not a function/, '#6');\n\n\t\tvm2 = new VM();\n\n\t\tassert.throws(() => vm2.run(`\n\t\t\tvar map = {valueOf(){}};\n\t\t\tvar arrayBackup = Array;\n\t\t\tArray = function(){\n\t\t\t\tArray = arrayBackup;\n\t\t\t\tthrow x=>x.constructor(\"return process\")();\n\t\t\t};\n\t\t\tvar process;\n\t\t\ttry{\n\t\t\t\tBuffer.from(map);\n\t\t\t}catch(e){\n\t\t\t\tprocess = e(x=>x);\n\t\t\t}\n\t\t\tprocess\n\t\t`), /e is not a function/, '#7');\n\t});\n\n\tit('proxy trap via Object.prototype attack', () => {\n\t\t// https://github.com/patriksimek/vm2/issues/178\n\n\t\tconst vm2 = new VM();\n\n\t\tassert.throws(() => vm2.run(`\n\t\t\tlet process;\n\t\t\tObject.prototype.has = (t, k) => {\n\t\t\t\tprocess = t.constructor(\"return process\")();\n\t\t\t}\n\t\t\t\"\" in Buffer.from;\n\t\t\tprocess.mainModule;\n\t\t`), /Cannot read property 'mainModule' of undefined/, '#1');\n\n\t\tconst vm22 = new VM();\n\n\t\tassert.throws(() => vm22.run(`\n\t\t\tObject.defineProperty(Object.prototype, \"apply\", {set:function(o,v){\n\t\t\t\tdelete Object.prototype.apply;\n\t\t\t}});\n\t\t\tBuffer.from(\"\").constructor.constructor(\"return process\")().mainModule;\n\t\t`), /process is not defined/, '#2');\n\t});\n\n\tit('Object.create attack', () => {\n\t\t// https://github.com/patriksimek/vm2/issues/178\n\n\t\tconst vm2 = new VM();\n\n\t\tassert.throws(() => vm2.run(`\n\t\t\tvar oc = Object.create;\n\t\t\tObject.create = (p,x)=> Object.defineProperty(oc(p,x),\"get\",{set(){},get:()=>(t,k,r)=>t.constructor(\"return process\")()});\n\t\t\tvar process = Buffer.from.process;\n\t\t\tObject.create = oc;\n\t\t\tprocess.mainModule\n\t\t`), /Cannot read property 'mainModule' of undefined/, '#1');\n\t});\n\n\tit('function returned from construct attack', () => {\n\t\t// https://github.com/patriksimek/vm2/issues/179\n\n\t\tconst vm2 = new VM({\n\t\t\tsandbox: {\n\t\t\t\tcall: x => x.a(),\n\t\t\t\tctor: X => new X()\n\t\t\t}\n\t\t});\n\n\t\tassert.throws(() => vm2.run(`\n\t\t\tcall({a:ctor(new Proxy(class A{},{\n\t\t\t\tconstruct(){\n\t\t\t\t\treturn function(){\n\t\t\t\t\t\treturn Object.getPrototypeOf(this).constructor.constructor(\"return process\")();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}))}).mainModule.require(\"child_process\").execSync(\"id\").toString()\n\t\t`), /process is not defined/, '#1');\n\t});\n\n\tit('throw while accessing propertyDescriptor properties', () => {\n\t\t// https://github.com/patriksimek/vm2/issues/178#issuecomment-450904979\n\n\t\tconst vm2 = new VM();\n\n\t\tassert.strictEqual(vm2.run(`(function(){\n\t\t\tvar process;\n\t\t\tObject.defineProperty(Object.prototype, \"set\", {get(){\n\t\t\t\tdelete Object.prototype.set;\n\t\t\t\tObject.defineProperty(Object.prototype, \"get\", {get(){\n\t\t\t\t\tdelete Object.prototype.get;\n\t\t\t\t\tthrow new Proxy(Object.create(null),{\n\t\t\t\t\t\tset(t,k,v){\n\t\t\t\t\t\t\tprocess = v.constructor(\"return process\")();\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t},configurable:true});\n\t\t\t\treturn ()=>{};\n\t\t\t},configurable:true});\n\t\t\ttry{\n\t\t\t\tObject.defineProperty(Buffer.from(\"\"),\"\",{});\n\t\t\t}catch(e){\n\t\t\t\te.x = Buffer.from;\n\t\t\t}\n\t\t\treturn process;})()\n\t\t`), undefined, '#1');\n\t});\n\n\tit('Symbol.hasInstance attack', () => {\n\t\t// https://github.com/patriksimek/vm2/issues/178#issuecomment-450978210\n\n\t\tlet vm2 = new VM();\n\n\t\tassert.throws(() => vm2.run(`\n\t\t\tObject.__defineGetter__(Symbol.hasInstance,()=>()=>true);\n\t\t\tBuffer.from.constructor(\"return process\")().mainModule.require(\"child_process\").execSync(\"id\").toString()\n\t\t`), /process is not defined/, '#1');\n\n\t\tvm2 = new VM();\n\n\t\tassert.throws(() => vm2.run(`\n\t\t\tObject[Symbol.hasInstance].call = ()=>true;\n\t\t\tBuffer.from.constructor(\"return process\")().mainModule.require(\"child_process\").execSync(\"whoami\").toString()\n\t\t`), /process is not defined/, '#2');\n\t});\n\n\tit('Proxy::getOwnPropertyDescriptor attack', () => {\n\t\t// https://github.com/patriksimek/vm2/issues/178#issuecomment-450978210\n\n\t\tconst vm2 = new VM();\n\n\t\tassert.throws(() => vm2.run(`\n\t\t\t(function(){\n\t\t\t\ttry{\n\t\t\t\t\tBuffer.from(new Proxy({}, {\n\t\t\t\t\t\tgetOwnPropertyDescriptor(){\n\t\t\t\t\t\t\tthrow f=>f.constructor(\"return process\")();\n\t\t\t\t\t\t}\n\t\t\t\t\t}));\n\t\t\t\t}catch(e){\n\t\t\t\t\treturn e(()=>{}).mainModule.require(\"child_process\").execSync(\"whoami\").toString();\n\t\t\t\t}\n\t\t\t})()\n\t\t`), /e is not a function/);\n\t});\n\n\tif (NODE_VERSION >= 10) {\n\t\tit('Dynamic import attack', () => {\n\n\t\t\tconst vm2 = new VM();\n\n\t\t\tassert.throws(()=>vm2.run(`\n\t\t\t\tconst process = import('oops!').constructor.constructor('return process')();\n\t\t\t`), /VMError: Dynamic Import not supported/);\n\t\t});\n\t}\n\n\tit('Error.prepareStackTrace attack', () => {\n\t\tconst vm2 = new VM();\n\t\tconst sst = vm2.run('Error.prepareStackTrace = (e,sst)=>sst;const sst = new Error().stack;Error.prepareStackTrace = undefined;sst');\n\t\tassert.strictEqual(vm2.run('sst=>Object.getPrototypeOf(sst)')(sst), vm2.run('Array.prototype'));\n\t\tassert.throws(()=>vm2.run('sst=>sst[0].getThis().constructor.constructor')(sst), /TypeError: Cannot read property 'constructor' of undefined/);\n\t});\n\n\tafter(() => {\n\t\tvm = null;\n\t});\n});\n\ndescribe('precompiled scripts', () => {\n\tit('VM', () => {\n\t\tconst vm = new VM();\n\t\tconst script = new VMScript('global.i=global.i||0;global.i++');\n\t\tconst val1 = vm.run(script);\n\t\tconst val2 = vm.run(script);\n\t\tconst failScript = new VMScript('(');\n\t\tassert.ok('number' === typeof val1 && 'number' === typeof val2);\n\t\tassert.ok( val1 === 0 && val2 === 1);\n\t\tassert.throws(() => failScript.compile(), /SyntaxError/);\n\t\tassert.ok(Object.keys(failScript).includes('code'));\n\t\tassert.ok(Object.keys(failScript).includes('filename'));\n\t\tassert.ok(Object.keys(failScript).includes('compiler'));\n\t\tassert.ok(!Object.keys(failScript).includes('_code'));\n\t});\n});\n\ndescribe('freeze, protect', () => {\n\tit('without freeze', () => {\n\t\tconst x = {\n\t\t\ta: () => 'a',\n\t\t\tb: () => 'b',\n\t\t\tc: {\n\t\t\t\td: () => 'd'\n\t\t\t}\n\t\t};\n\n\t\tconst vm = new VM({\n\t\t\tsandbox: {x}\n\t\t});\n\t\tvm.run('x.a = () => { return `-` }; x.c.d = () => { return `---` }; (y) => { y.b = () => { return `--` } }')(x);\n\n\t\tassert.strictEqual(x.a(), '-');\n\t\tassert.strictEqual(x.b(), '--');\n\t\tassert.strictEqual(x.c.d(), '---');\n\t});\n\n\tit('with freeze', () => {\n\t\tconst x = {\n\t\t\ta: () => 'a',\n\t\t\tb: () => 'b',\n\t\t\tc: {\n\t\t\t\td: () => 'd'\n\t\t\t}\n\t\t};\n\n\t\tconst vm = new VM();\n\t\tvm.freeze(x, 'x');\n\n\t\tassert.throws(() => {\n\t\t\tvm.run('\"use strict\"; x.a = () => { return `-` };');\n\t\t}, /'set' on proxy: trap returned falsish for property 'a'/);\n\n\t\tassert.throws(() => {\n\t\t\tvm.run('\"use strict\"; (y) => { y.b = () => { return `--` } }')(x);\n\t\t}, /'set' on proxy: trap returned falsish for property 'b'/);\n\n\t\tassert.throws(() => {\n\t\t\tvm.run('\"use strict\"; x.c.d = () => { return `---` };');\n\t\t}, /'set' on proxy: trap returned falsish for property 'd'/);\n\n\t\tvm.run('x.a = () => { return `-` };');\n\t\tassert.strictEqual(x.a(), 'a');\n\n\t\tvm.run('(y) => { y.b = () => { return `--` } }')(x);\n\t\tassert.strictEqual(x.b(), 'b');\n\n\t\tvm.run('x.c.d = () => { return `---` };');\n\t\tassert.strictEqual(x.c.d(), 'd');\n\n\t\t// Extension of frozen objects should be writeable.\n\t\tassert.strictEqual(vm.run('y = Object.create(x); y.f = 1; y.f'), 1);\n\t});\n\n\tit('without protect', () => {\n\t\tconst vm = new VM(); const obj = {};\n\t\tvm.run('(i) => { i.text = \"test\" }')(obj);\n\t\tvm.run('(i) => { i.func = () => {} }')(obj);\n\t\tvm.run('(i) => { delete i.func }')(obj);\n\t});\n\n\tit('with protect', () => {\n\t\tconst vm = new VM(); const obj = {\n\t\t\tdate: new Date(),\n\t\t\tarray: [{}, {}]\n\t\t};\n\n\t\tvm.protect(obj);\n\n\t\tvm.run('(i) => { i.func = () => {} }')(obj);\n\t\tassert.strictEqual(typeof obj.func, 'undefined');\n\n\t\tassert.throws(() => {\n\t\t\tvm.run('\"use strict\"; (i) => { i.func = () => {} }')(obj);\n\t\t});\n\n\t\tvm.run('(i) => { i.array.func = () => {} }')(obj);\n\t\tassert.strictEqual(typeof obj.array.func, 'undefined');\n\n\t\tassert.throws(() => {\n\t\t\tvm.run('\"use strict\"; (i) => { i.array.func = () => {} }')(obj);\n\t\t});\n\n\t\tvm.run('(i) => { i.array[0].func = () => {} }')(obj);\n\t\tassert.strictEqual(typeof obj.array[0].func, 'undefined');\n\n\t\tassert.throws(() => {\n\t\t\tvm.run('\"use strict\"; (i) => { i.array[0].func = () => {} }')(obj);\n\t\t});\n\n\t\tassert.throws(() => {\n\t\t\tvm.run('\"use strict\"; (i) => { Object.defineProperty(i, \"toString\", { get(){ return () => \\'Not protected\\'; } }) }')(obj);\n\t\t});\n\n\t\tassert.strictEqual(vm.run('(i) => i.array.map(item => 1).join(\",\")')(obj), '1,1');\n\t\tassert.strictEqual(vm.run('(i) => /x/.test(i.date)')(obj), false);\n\t});\n});\n"], "filenames": ["lib/contextify.js", "lib/main.js", "lib/sandbox.js", "test/vm.js"], "buggy_code_start_loc": [27, 547, 70, 913], "buggy_code_end_loc": [1003, 1190, 73, 936], "fixing_code_start_loc": [27, 547, 71, 913], "fixing_code_end_loc": [1129, 1221, 75, 929], "type": "CWE-1321", "message": "This affects the package vm2 before 3.9.4 via a Prototype Pollution attack vector, which can lead to execution of arbitrary code on the host machine.", "other": {"cve": {"id": "CVE-2021-23449", "sourceIdentifier": "report@snyk.io", "published": "2021-10-18T17:15:07.790", "lastModified": "2022-06-28T14:11:45.273", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "This affects the package vm2 before 3.9.4 via a Prototype Pollution attack vector, which can lead to execution of arbitrary code on the host machine."}, {"lang": "es", "value": "Esto afecta al paquete vm2 antes de la versi\u00f3n 3.9.4 a trav\u00e9s de un vector de ataque de Prototipo de Contaminaci\u00f3n, que puede llevar a la ejecuci\u00f3n de c\u00f3digo arbitrario en la m\u00e1quina anfitriona"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 10.0, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 6.0}, {"source": "report@snyk.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-1321"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vm2_project:vm2:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "3.9.4", "matchCriteriaId": "22C0E167-6242-41C5-9937-A435AE42AD3E"}]}]}], "references": [{"url": "https://github.com/patriksimek/vm2/commit/b4f6e2bd2c4a1ef52fc4483d8e35f28bc4481886", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/patriksimek/vm2/issues/363", "source": "report@snyk.io", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/patriksimek/vm2/releases/tag/3.9.4", "source": "report@snyk.io", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20211029-0010/", "source": "report@snyk.io", "tags": ["Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-JS-VM2-1585918", "source": "report@snyk.io", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/patriksimek/vm2/commit/b4f6e2bd2c4a1ef52fc4483d8e35f28bc4481886"}}