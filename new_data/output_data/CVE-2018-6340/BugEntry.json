{"buggy_code": ["/*\n   +----------------------------------------------------------------------+\n   | HipHop for PHP                                                       |\n   +----------------------------------------------------------------------+\n   | Copyright (c) 2010-present Facebook, Inc. (http://www.facebook.com)  |\n   | Copyright (c) 1997-2010 The PHP Group                                |\n   +----------------------------------------------------------------------+\n   | This source file is subject to version 3.01 of the PHP license,      |\n   | that is bundled with this package in the file LICENSE, and is        |\n   | available through the world-wide-web at the following url:           |\n   | http://www.php.net/license/3_01.txt                                  |\n   | If you did not receive a copy of the PHP license and are unable to   |\n   | obtain it through the world-wide-web, please send a note to          |\n   | license@php.net so we can mail you a copy immediately.               |\n   +----------------------------------------------------------------------+\n*/\n\n#include \"hphp/runtime/ext/extension.h\"\n#include \"hphp/runtime/base/builtin-functions.h\"\n#include \"hphp/runtime/base/execution-context.h\"\n#include \"hphp/runtime/vm/native-data.h\"\n#include \"hphp/runtime/ext/memcached/libmemcached_portability.h\"\n#include \"hphp/runtime/ext/sockets/ext_sockets.h\"\n#include \"hphp/runtime/base/rds-local.h\"\n#include \"hphp/runtime/base/ini-setting.h\"\n#include \"hphp/runtime/base/zend-string.h\"\n#include <vector>\n\n// MMC values must match pecl-memcache for compatibility\n#define MMC_SERIALIZED  0x0001\n#define MMC_COMPRESSED  0x0002\n\n#define MMC_TYPE_STRING 0x0000\n#define MMC_TYPE_BOOL   0x0100\n#define MMC_TYPE_LONG   0x0300\n#define MMC_TYPE_DOUBLE 0x0700\n\n#define MMC_TYPE_MASK   0x0F00\n\nnamespace HPHP {\n\nconst int64_t k_MEMCACHE_COMPRESSED = MMC_COMPRESSED;\n\nstatic bool ini_on_update_hash_strategy(const std::string& value);\nstatic bool ini_on_update_hash_function(const std::string& value);\n\nstruct MEMCACHEGlobals final {\n  std::string hash_strategy;\n  std::string hash_function;\n};\n\nstatic __thread MEMCACHEGlobals* s_memcache_globals;\n#define MEMCACHEG(name) s_memcache_globals->name\n\nconst StaticString s_MemcacheData(\"MemcacheData\");\n\nstruct MemcacheData {\n  memcached_st m_memcache;\n  TYPE_SCAN_IGNORE_FIELD(m_memcache);\n  int m_compress_threshold;\n  double m_min_compress_savings;\n\n  MemcacheData(): m_memcache(), m_compress_threshold(0),\n    m_min_compress_savings(0.2) {\n    memcached_create(&m_memcache);\n\n    if (MEMCACHEG(hash_strategy) == \"consistent\") {\n      // need to hook up a global variable to set this\n      memcached_behavior_set(&m_memcache, MEMCACHED_BEHAVIOR_DISTRIBUTION,\n                             MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA);\n    } else {\n      memcached_behavior_set(&m_memcache, MEMCACHED_BEHAVIOR_DISTRIBUTION,\n                             MEMCACHED_DISTRIBUTION_MODULA);\n    }\n\n    if (MEMCACHEG(hash_function) == \"fnv\") {\n      memcached_behavior_set(&m_memcache, MEMCACHED_BEHAVIOR_HASH,\n                             MEMCACHED_HASH_FNV1A_32);\n    } else {\n      memcached_behavior_set(&m_memcache, MEMCACHED_BEHAVIOR_HASH,\n                             MEMCACHED_HASH_CRC);\n    }\n  };\n  ~MemcacheData() {\n    memcached_free(&m_memcache);\n  };\n};\n\nstatic bool ini_on_update_hash_strategy(const std::string& value) {\n  if (!strncasecmp(value.data(), \"standard\", sizeof(\"standard\"))) {\n    MEMCACHEG(hash_strategy) = \"standard\";\n  } else if (!strncasecmp(value.data(), \"consistent\", sizeof(\"consistent\"))) {\n    MEMCACHEG(hash_strategy) = \"consistent\";\n  }\n  return false;\n}\n\nstatic bool ini_on_update_hash_function(const std::string& value) {\n  if (!strncasecmp(value.data(), \"crc32\", sizeof(\"crc32\"))) {\n    MEMCACHEG(hash_function) = \"crc32\";\n  } else if (!strncasecmp(value.data(), \"fnv\", sizeof(\"fnv\"))) {\n    MEMCACHEG(hash_function) = \"fnv\";\n  }\n  return false;\n}\n\nstatic bool hasAvailableServers(const MemcacheData* data) {\n  if (memcached_server_count(&data->m_memcache) == 0) {\n    raise_warning(\"Memcache: No servers added to memcache connection\");\n    return false;\n  }\n  return true;\n}\n\nstatic bool isServerReachable(const String& host, int port /*= 0*/) {\n  auto hostInfo = HHVM_FN(getaddrinfo)(host, port);\n  if (hostInfo.isBoolean() && !hostInfo.toBoolean()) {\n    raise_warning(\"Memcache: Can't connect to %s:%d\", host.c_str(), port);\n    return false;\n  }\n  return true;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// methods\n\nstatic bool HHVM_METHOD(Memcache, connect, const String& host, int port /*= 0*/,\n                        int /*timeout*/ /*= 0*/, int /*timeoutms*/ /*= 0*/) {\n  auto data = Native::data<MemcacheData>(this_);\n  memcached_return_t ret;\n\n  if (!host.empty() &&\n      !strncmp(host.c_str(), \"unix://\", sizeof(\"unix://\") - 1)) {\n    const char *socket_path = host.substr(sizeof(\"unix://\") - 1).c_str();\n    ret = memcached_server_add_unix_socket(&data->m_memcache, socket_path);\n  } else {\n    if (!isServerReachable(host, port)) {\n      return false;\n    }\n    ret = memcached_server_add(&data->m_memcache, host.c_str(), port);\n  }\n\n  return (ret == MEMCACHED_SUCCESS);\n}\n\nstatic uint32_t memcache_get_flag_for_type(const Variant& var) {\n  switch (var.getType()) {\n    case KindOfBoolean:\n      return MMC_TYPE_BOOL;\n    case KindOfInt64:\n      return MMC_TYPE_LONG;\n    case KindOfDouble:\n      return MMC_TYPE_DOUBLE;\n\n    case KindOfUninit:\n    case KindOfNull:\n    case KindOfPersistentString:\n    case KindOfString:\n    case KindOfPersistentVec:\n    case KindOfVec:\n    case KindOfPersistentDict:\n    case KindOfDict:\n    case KindOfPersistentKeyset:\n    case KindOfKeyset:\n    case KindOfPersistentShape:\n    case KindOfShape:\n    case KindOfPersistentArray:\n    case KindOfArray:\n    case KindOfObject:\n    case KindOfResource:\n    case KindOfRef:\n    case KindOfFunc:\n    case KindOfClass:\n      return MMC_TYPE_STRING;\n  }\n  not_reached();\n}\n\nstatic void memcache_set_type_from_flag(Variant& var, uint32_t flags) {\n  switch (flags & MMC_TYPE_MASK) {\n  case MMC_TYPE_BOOL:\n    var = var.toBoolean();\n    break;\n  case MMC_TYPE_LONG:\n    var = var.toInt64();\n    break;\n  case MMC_TYPE_DOUBLE:\n    var = var.toDouble();\n    break;\n  }\n}\n\nstatic std::vector<char> memcache_prepare_for_storage(const MemcacheData* data,\n                                                      const Variant& var,\n                                                      int &flag) {\n  String v;\n  if (var.isString()) {\n    v = var.toString();\n  } else if (var.isNumeric() || var.isBoolean()) {\n    flag &= ~MMC_COMPRESSED;\n    v = var.toString();\n  } else {\n    flag |= MMC_SERIALIZED;\n    v = f_serialize(var);\n  }\n  std::vector<char> payload;\n  size_t value_len = v.length();\n\n  if (!var.isNumeric() && !var.isBoolean() &&\n    data->m_compress_threshold && value_len >= data->m_compress_threshold) {\n    flag |= MMC_COMPRESSED;\n  }\n  if (flag & MMC_COMPRESSED) {\n    size_t payload_len = compressBound(value_len);\n    payload.resize(payload_len);\n    if (compress((Bytef*)payload.data(), &payload_len,\n                 (const Bytef*)v.data(), value_len) == Z_OK) {\n      payload.resize(payload_len);\n      if (payload_len >= value_len * (1 - data->m_min_compress_savings)) {\n        flag &= ~MMC_COMPRESSED;\n      }\n    } else {\n      flag &= ~MMC_COMPRESSED;\n      raise_warning(\"could not compress value\");\n    }\n  }\n  if (!(flag & MMC_COMPRESSED)) {\n    payload.resize(0);\n    payload.insert(payload.end(), v.data(), v.data() + value_len);\n   }\n  flag |= memcache_get_flag_for_type(var);\n\n  return payload;\n}\n\nstatic String memcache_prepare_key(const String& var) {\n  String var_mutable(var, CopyString);\n  auto data = var_mutable.get()->mutableData();\n  for (int i = 0; i < var.length(); i++) {\n    // This is a stupid encoding since it causes collisions but it matches php5\n    if (data[i] <= ' ') {\n      data[i] = '_';\n    }\n  }\n  return data;\n}\n\nstatic Variant unserialize_if_serialized(const char *payload,\n                                         size_t payload_len,\n                                         uint32_t flags) {\n  Variant ret = uninit_null();\n  if (flags & MMC_SERIALIZED) {\n    ret = unserialize_from_buffer(\n      payload,\n      payload_len,\n      VariableUnserializer::Type::Serialize\n    );\n  } else {\n    if (payload_len == 0) {\n      ret = empty_string();\n    } else {\n      ret = String(payload, payload_len, CopyString);\n    }\n  }\n  return ret;\n }\n\nstatic Variant memcache_fetch_from_storage(const char *payload,\n                                           size_t payload_len,\n                                           uint32_t flags) {\n  Variant ret = uninit_null();\n\n  if (flags & MMC_COMPRESSED) {\n    bool done = false;\n    std::vector<char> buffer;\n    size_t buffer_len;\n    for (int factor = 1; !done && factor <= 16; ++factor) {\n      if (payload_len >=\n          std::numeric_limits<unsigned long>::max() / (1 << factor)) {\n        break;\n      }\n      buffer_len = payload_len * (1 << factor) + 1;\n      buffer.resize(buffer_len);\n      if (uncompress((Bytef*)buffer.data(), &buffer_len,\n                     (const Bytef*)payload, (uLong)payload_len) == Z_OK) {\n        done = true;\n      }\n    }\n    if (!done) {\n      raise_warning(\"could not uncompress value\");\n      return init_null();\n    }\n    ret = unserialize_if_serialized(buffer.data(), buffer_len, flags);\n  } else {\n    ret = unserialize_if_serialized(payload, payload_len, flags);\n  }\n  memcache_set_type_from_flag(ret, flags);\n\n  return ret;\n}\n\nstatic bool HHVM_METHOD(Memcache, add, const String& key, const Variant& var,\n                                       int flag /*= 0*/, int expire /*= 0*/) {\n  if (key.empty()) {\n    raise_warning(\"Key cannot be empty\");\n    return false;\n  }\n\n  auto data = Native::data<MemcacheData>(this_);\n\n  if (!hasAvailableServers(data)) {\n    return false;\n  }\n\n  std::vector<char> serialized = memcache_prepare_for_storage(data, var, flag);\n\n  String serializedKey = memcache_prepare_key(key);\n  memcached_return_t ret = memcached_add(&data->m_memcache,\n                                        serializedKey.c_str(),\n                                        serializedKey.length(),\n                                        serialized.data(),\n                                        serialized.size(),\n                                        expire, flag);\n\n  return (ret == MEMCACHED_SUCCESS);\n}\n\nstatic bool HHVM_METHOD(Memcache, set, const String& key, const Variant& var,\n                                       int flag /*= 0*/, int expire /*= 0*/) {\n  if (key.empty()) {\n    raise_warning(\"Key cannot be empty\");\n    return false;\n  }\n\n  auto data = Native::data<MemcacheData>(this_);\n\n  if (!hasAvailableServers(data)) {\n    return false;\n  }\n\n  String serializedKey = memcache_prepare_key(key);\n  std::vector<char> serializedVar =\n    memcache_prepare_for_storage(data, var, flag);\n\n  memcached_return_t ret = memcached_set(&data->m_memcache,\n                                         serializedKey.c_str(),\n                                         serializedKey.length(),\n                                         serializedVar.data(),\n                                         serializedVar.size(), expire, flag);\n\n  if (ret == MEMCACHED_SUCCESS) {\n    return true;\n  }\n\n  return false;\n}\n\nstatic bool HHVM_METHOD(Memcache, replace, const String& key,\n                                           const Variant& var, int flag /*= 0*/,\n                                           int expire /*= 0*/) {\n  if (key.empty()) {\n    raise_warning(\"Key cannot be empty\");\n    return false;\n  }\n\n  auto data = Native::data<MemcacheData>(this_);\n\n  if (!hasAvailableServers(data)) {\n    return false;\n  }\n\n  String serializedKey = memcache_prepare_key(key);\n  std::vector<char> serialized = memcache_prepare_for_storage(data, var, flag);\n\n  memcached_return_t ret = memcached_replace(&data->m_memcache,\n                                             serializedKey.c_str(),\n                                             serializedKey.length(),\n                                             serialized.data(),\n                                             serialized.size(),\n                                             expire, flag);\n  return (ret == MEMCACHED_SUCCESS);\n}\n\nstatic Variant\nHHVM_METHOD(Memcache, get, const Variant& key, VRefParam /*flags*/ /*= null*/) {\n  auto data = Native::data<MemcacheData>(this_);\n\n  if (!hasAvailableServers(data)) {\n    return false;\n  }\n\n  if (key.isArray()) {\n    std::vector<const char *> real_keys;\n    std::vector<size_t> key_len;\n    Array keyArr = key.toArray();\n\n    real_keys.reserve(keyArr.size());\n    key_len.reserve(keyArr.size());\n\n    for (ArrayIter iter(keyArr); iter; ++iter) {\n      auto key = iter.second().toString();\n      String serializedKey = memcache_prepare_key(key);\n      char *k = new char[serializedKey.length()+1];\n      memcpy(k, serializedKey.c_str(), serializedKey.length() + 1);\n      real_keys.push_back(k);\n      key_len.push_back(serializedKey.length());\n    }\n\n    if (!real_keys.empty()) {\n      const char *payload = nullptr;\n      size_t payload_len = 0;\n      uint32_t flags = 0;\n      const char *res_key = nullptr;\n      size_t res_key_len = 0;\n\n      memcached_result_st result;\n\n      memcached_return_t ret = memcached_mget(&data->m_memcache, &real_keys[0],\n                                              &key_len[0], real_keys.size());\n      memcached_result_create(&data->m_memcache, &result);\n\n      // To mimic PHP5 should return empty array at failure.\n      Array return_val = Array::Create();\n\n      while ((memcached_fetch_result(&data->m_memcache, &result, &ret))\n             != nullptr) {\n        if (ret != MEMCACHED_SUCCESS) {\n          // should probably notify about errors\n          continue;\n        }\n\n        payload     = memcached_result_value(&result);\n        payload_len = memcached_result_length(&result);\n        flags       = memcached_result_flags(&result);\n        res_key     = memcached_result_key_value(&result);\n        res_key_len = memcached_result_key_length(&result);\n\n        return_val.set(String(res_key, res_key_len, CopyString),\n                       memcache_fetch_from_storage(payload,\n                                                   payload_len, flags));\n      }\n      memcached_result_free(&result);\n      for ( size_t i = 0 ; i < real_keys.size() ; i++ ) {\n        delete [] real_keys[i];\n      }\n\n      return return_val;\n    }\n  } else {\n    char *payload = nullptr;\n    size_t payload_len = 0;\n    uint32_t flags = 0;\n\n    memcached_return_t ret;\n    String serializedKey = memcache_prepare_key(key.toString());\n\n    if (serializedKey.length() == 0) {\n      return false;\n    }\n\n    payload = memcached_get(&data->m_memcache, serializedKey.c_str(),\n                            serializedKey.length(), &payload_len, &flags, &ret);\n\n    /* This is for historical reasons from libmemcached*/\n    if (ret == MEMCACHED_END) {\n      ret = MEMCACHED_NOTFOUND;\n    }\n\n    if (ret == MEMCACHED_NOTFOUND) {\n      return false;\n    }\n\n    if (ret != MEMCACHED_SUCCESS) {\n      return false;\n    }\n\n    Variant retval = memcache_fetch_from_storage(payload, payload_len, flags);\n    free(payload);\n\n    return retval;\n  }\n  return false;\n}\n\nstatic bool HHVM_METHOD(Memcache, delete, const String& key,\n                                          int expire /*= 0*/) {\n  if (key.empty()) {\n    raise_warning(\"Key cannot be empty\");\n    return false;\n  }\n\n  auto data = Native::data<MemcacheData>(this_);\n\n  if (!hasAvailableServers(data)) {\n    return false;\n  }\n\n  String serializedKey = memcache_prepare_key(key);\n  memcached_return_t ret = memcached_delete(&data->m_memcache,\n                                            serializedKey.c_str(),\n                                            serializedKey.length(),\n                                            expire);\n  return (ret == MEMCACHED_SUCCESS);\n}\n\nstatic Variant HHVM_METHOD(Memcache, increment, const String& key,\n                                                int offset /*= 1*/) {\n  if (key.empty()) {\n    raise_warning(\"Key cannot be empty\");\n    return false;\n  }\n\n  auto data = Native::data<MemcacheData>(this_);\n\n  if (!hasAvailableServers(data)) {\n    return false;\n  }\n\n  uint64_t value;\n  String serializedKey = memcache_prepare_key(key);\n  memcached_return_t ret = memcached_increment(&data->m_memcache,\n                                               serializedKey.c_str(),\n                                               serializedKey.length(), offset,\n                                               &value);\n\n  if (ret == MEMCACHED_SUCCESS) {\n    return (int64_t)value;\n  }\n\n  return false;\n}\n\nstatic Variant HHVM_METHOD(Memcache, decrement, const String& key,\n                                                int offset /*= 1*/) {\n  if (key.empty()) {\n    raise_warning(\"Key cannot be empty\");\n    return false;\n  }\n\n  auto data = Native::data<MemcacheData>(this_);\n\n  if (!hasAvailableServers(data)) {\n    return false;\n  }\n\n  uint64_t value;\n  String serializedKey = memcache_prepare_key(key);\n  memcached_return_t ret = memcached_decrement(&data->m_memcache,\n                                               serializedKey.c_str(),\n                                               serializedKey.length(), offset,\n                                               &value);\n\n  if (ret == MEMCACHED_SUCCESS) {\n    return (int64_t)value;\n  }\n\n  return false;\n}\n\nstatic bool HHVM_METHOD(Memcache, close) {\n  auto data = Native::data<MemcacheData>(this_);\n  memcached_quit(&data->m_memcache);\n  return true;\n}\n\nstatic Variant HHVM_METHOD(Memcache, getversion) {\n  auto data = Native::data<MemcacheData>(this_);\n  int server_count = memcached_server_count(&data->m_memcache);\n  char version[16];\n  int version_len = 0;\n\n  if (memcached_version(&data->m_memcache) != MEMCACHED_SUCCESS) {\n    return false;\n  }\n\n  for (int x = 0; x < server_count; x++) {\n    LMCD_SERVER_POSITION_INSTANCE_TYPE instance =\n      memcached_server_instance_by_position(&data->m_memcache, x);\n    uint8_t majorVersion = LMCD_SERVER_MAJOR_VERSION(instance);\n    uint8_t minorVersion = LMCD_SERVER_MINOR_VERSION(instance);\n    uint8_t microVersion = LMCD_SERVER_MICRO_VERSION(instance);\n\n    if (!majorVersion) {\n      continue;\n    }\n\n    version_len = snprintf(version, sizeof(version),\n        \"%\" PRIu8 \".%\" PRIu8 \".%\" PRIu8,\n        majorVersion, minorVersion, microVersion);\n    return String(version, version_len, CopyString);\n  }\n\n  return false;\n}\n\nstatic bool HHVM_METHOD(Memcache, flush, int expire /*= 0*/) {\n  auto data = Native::data<MemcacheData>(this_);\n  return memcached_flush(&data->m_memcache, expire) == MEMCACHED_SUCCESS;\n}\n\nstatic bool HHVM_METHOD(Memcache, setcompressthreshold, int threshold,\n                                        double min_savings /* = 0.2 */) {\n  if (threshold < 0) {\n    raise_warning(\"threshold must be a positive integer\");\n    return false;\n  }\n\n  if (min_savings < 0 || min_savings > 1) {\n    raise_warning(\"min_savings must be a float in the 0..1 range\");\n    return false;\n  }\n\n  auto data = Native::data<MemcacheData>(this_);\n\n  data->m_compress_threshold = threshold;\n  data->m_min_compress_savings = min_savings;\n\n  return true;\n}\n\nstatic Array memcache_build_stats(const memcached_st *ptr,\n                                memcached_stat_st *memc_stat,\n                                memcached_return_t *ret) {\n  char **curr_key;\n  char **stat_keys = memcached_stat_get_keys(const_cast<memcached_st*>(ptr),\n                                             memc_stat, ret);\n\n  if (*ret != MEMCACHED_SUCCESS) {\n    if (stat_keys) {\n      free(stat_keys);\n    }\n    return Array();\n  }\n\n  Array return_val = Array::Create();\n\n  for (curr_key = stat_keys; *curr_key; curr_key++) {\n    char *mc_val;\n    mc_val = memcached_stat_get_value(ptr, memc_stat, *curr_key, ret);\n    if (*ret != MEMCACHED_SUCCESS) {\n      break;\n    }\n    return_val.set(String(*curr_key, CopyString),\n                   String(mc_val, CopyString));\n    free(mc_val);\n  }\n\n  free(stat_keys);\n  return return_val;\n}\n\n\nstatic Array HHVM_METHOD(Memcache, getstats,\n                         const String& type /* = null_string */,\n                         int slabid /* = 0 */, int limit /* = 100 */) {\n  auto data = Native::data<MemcacheData>(this_);\n  if (!memcached_server_count(&data->m_memcache)) {\n    return Array();\n  }\n\n  char extra_args[30] = {0};\n\n  if (slabid) {\n    snprintf(extra_args, sizeof(extra_args), \"%s %d %d\", type.c_str(),\n             slabid, limit);\n  } else if (!type.empty()) {\n    snprintf(extra_args, sizeof(extra_args), \"%s\", type.c_str());\n  }\n\n  LMCD_SERVER_POSITION_INSTANCE_TYPE instance =\n    memcached_server_instance_by_position(&data->m_memcache, 0);\n  const char *hostname = LMCD_SERVER_HOSTNAME(instance);\n  in_port_t port = LMCD_SERVER_PORT(instance);\n\n  memcached_stat_st stats;\n  if (memcached_stat_servername(&stats, extra_args, hostname,\n                                port) != MEMCACHED_SUCCESS) {\n    return Array();\n  }\n\n  memcached_return_t ret;\n  return memcache_build_stats(&data->m_memcache, &stats, &ret);\n}\n\nstatic Array HHVM_METHOD(Memcache, getextendedstats,\n                         const String& /*type*/ /* = null_string */,\n                         int /*slabid*/ /* = 0 */, int /*limit*/ /* = 100 */) {\n  auto data = Native::data<MemcacheData>(this_);\n  memcached_return_t ret;\n  memcached_stat_st *stats;\n\n  stats = memcached_stat(&data->m_memcache, nullptr, &ret);\n  if (ret != MEMCACHED_SUCCESS) {\n    return Array();\n  }\n\n  int server_count = memcached_server_count(&data->m_memcache);\n\n  Array return_val;\n\n  for (int server_id = 0; server_id < server_count; server_id++) {\n    memcached_stat_st *stat;\n    char stats_key[30] = {0};\n    size_t key_len;\n\n    LMCD_SERVER_POSITION_INSTANCE_TYPE instance =\n      memcached_server_instance_by_position(&data->m_memcache, server_id);\n    const char *hostname = LMCD_SERVER_HOSTNAME(instance);\n    in_port_t port = LMCD_SERVER_PORT(instance);\n\n    stat = stats + server_id;\n\n    Array server_stats = memcache_build_stats(&data->m_memcache, stat, &ret);\n    if (ret != MEMCACHED_SUCCESS) {\n      continue;\n    }\n\n    key_len = snprintf(stats_key, sizeof(stats_key), \"%s:%d\", hostname, port);\n\n    return_val.set(String(stats_key, key_len, CopyString), server_stats);\n  }\n\n  free(stats);\n  return return_val;\n}\n\nstatic bool\nHHVM_METHOD(Memcache, addserver, const String& host, int port /* = 11211 */,\n            bool /*persistent*/ /* = false */, int weight /* = 0 */,\n            int /*timeout*/ /* = 0 */, int /*retry_interval*/ /* = 0 */,\n            bool /*status*/ /* = true */,\n            const Variant& /*failure_callback*/ /* = uninit_variant */,\n            int /*timeoutms*/ /* = 0 */) {\n  auto data = Native::data<MemcacheData>(this_);\n  memcached_return_t ret;\n\n  if (!host.empty() &&\n      !strncmp(host.c_str(), \"unix://\", sizeof(\"unix://\") - 1)) {\n    const char *socket_path = host.substr(sizeof(\"unix://\") - 1).c_str();\n    ret = memcached_server_add_unix_socket_with_weight(&data->m_memcache,\n                                                       socket_path, weight);\n  } else {\n    ret = memcached_server_add_with_weight(&data->m_memcache, host.c_str(),\n                                           port, weight);\n  }\n\n  if (ret == MEMCACHED_SUCCESS) {\n    return true;\n  }\n\n  return false;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\nstruct MemcacheExtension final : Extension {\n    MemcacheExtension() : Extension(\"memcache\", \"3.0.8\") {};\n    void threadInit() override {\n      assertx(!s_memcache_globals);\n      s_memcache_globals = new MEMCACHEGlobals;\n      IniSetting::Bind(this, IniSetting::PHP_INI_ALL,\n                       \"memcache.hash_strategy\", \"standard\",\n                       IniSetting::SetAndGet<std::string>(\n                         ini_on_update_hash_strategy,\n                         nullptr\n                       ),\n                       &MEMCACHEG(hash_strategy));\n      IniSetting::Bind(this, IniSetting::PHP_INI_ALL,\n                       \"memcache.hash_function\", \"crc32\",\n                       IniSetting::SetAndGet<std::string>(\n                         ini_on_update_hash_function,\n                         nullptr\n                       ),\n                       &MEMCACHEG(hash_function));\n    }\n    void threadShutdown() override {\n      delete s_memcache_globals;\n      s_memcache_globals = nullptr;\n    }\n\n    void moduleInit() override {\n      HHVM_RC_INT(MEMCACHE_COMPRESSED, k_MEMCACHE_COMPRESSED);\n      HHVM_RC_BOOL(MEMCACHE_HAVE_SESSION, true);\n      HHVM_ME(Memcache, connect);\n      HHVM_ME(Memcache, add);\n      HHVM_ME(Memcache, set);\n      HHVM_ME(Memcache, replace);\n      HHVM_ME(Memcache, get);\n      HHVM_ME(Memcache, delete);\n      HHVM_ME(Memcache, increment);\n      HHVM_ME(Memcache, decrement);\n      HHVM_ME(Memcache, close);\n      HHVM_ME(Memcache, getversion);\n      HHVM_ME(Memcache, flush);\n      HHVM_ME(Memcache, setcompressthreshold);\n      HHVM_ME(Memcache, getstats);\n      HHVM_ME(Memcache, getextendedstats);\n      HHVM_ME(Memcache, addserver);\n\n      Native::registerNativeDataInfo<MemcacheData>(s_MemcacheData.get());\n\n      loadSystemlib();\n    }\n} s_memcache_extension;;\n\n}\n"], "fixing_code": ["/*\n   +----------------------------------------------------------------------+\n   | HipHop for PHP                                                       |\n   +----------------------------------------------------------------------+\n   | Copyright (c) 2010-present Facebook, Inc. (http://www.facebook.com)  |\n   | Copyright (c) 1997-2010 The PHP Group                                |\n   +----------------------------------------------------------------------+\n   | This source file is subject to version 3.01 of the PHP license,      |\n   | that is bundled with this package in the file LICENSE, and is        |\n   | available through the world-wide-web at the following url:           |\n   | http://www.php.net/license/3_01.txt                                  |\n   | If you did not receive a copy of the PHP license and are unable to   |\n   | obtain it through the world-wide-web, please send a note to          |\n   | license@php.net so we can mail you a copy immediately.               |\n   +----------------------------------------------------------------------+\n*/\n\n#include \"hphp/runtime/ext/extension.h\"\n#include \"hphp/runtime/base/builtin-functions.h\"\n#include \"hphp/runtime/base/execution-context.h\"\n#include \"hphp/runtime/vm/native-data.h\"\n#include \"hphp/runtime/ext/memcached/libmemcached_portability.h\"\n#include \"hphp/runtime/ext/sockets/ext_sockets.h\"\n#include \"hphp/runtime/base/rds-local.h\"\n#include \"hphp/runtime/base/ini-setting.h\"\n#include \"hphp/runtime/base/zend-string.h\"\n#include <vector>\n\n// MMC values must match pecl-memcache for compatibility\n#define MMC_SERIALIZED  0x0001\n#define MMC_COMPRESSED  0x0002\n\n#define MMC_TYPE_STRING 0x0000\n#define MMC_TYPE_BOOL   0x0100\n#define MMC_TYPE_LONG   0x0300\n#define MMC_TYPE_DOUBLE 0x0700\n\n#define MMC_TYPE_MASK   0x0F00\n\nnamespace HPHP {\n\nconst int64_t k_MEMCACHE_COMPRESSED = MMC_COMPRESSED;\n\nstatic bool ini_on_update_hash_strategy(const std::string& value);\nstatic bool ini_on_update_hash_function(const std::string& value);\n\nstruct MEMCACHEGlobals final {\n  std::string hash_strategy;\n  std::string hash_function;\n};\n\nstatic __thread MEMCACHEGlobals* s_memcache_globals;\n#define MEMCACHEG(name) s_memcache_globals->name\n\nconst StaticString s_MemcacheData(\"MemcacheData\");\n\nstruct MemcacheData {\n  memcached_st m_memcache;\n  TYPE_SCAN_IGNORE_FIELD(m_memcache);\n  int m_compress_threshold;\n  double m_min_compress_savings;\n\n  MemcacheData(): m_memcache(), m_compress_threshold(0),\n    m_min_compress_savings(0.2) {\n    memcached_create(&m_memcache);\n\n    if (MEMCACHEG(hash_strategy) == \"consistent\") {\n      // need to hook up a global variable to set this\n      memcached_behavior_set(&m_memcache, MEMCACHED_BEHAVIOR_DISTRIBUTION,\n                             MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA);\n    } else {\n      memcached_behavior_set(&m_memcache, MEMCACHED_BEHAVIOR_DISTRIBUTION,\n                             MEMCACHED_DISTRIBUTION_MODULA);\n    }\n\n    if (MEMCACHEG(hash_function) == \"fnv\") {\n      memcached_behavior_set(&m_memcache, MEMCACHED_BEHAVIOR_HASH,\n                             MEMCACHED_HASH_FNV1A_32);\n    } else {\n      memcached_behavior_set(&m_memcache, MEMCACHED_BEHAVIOR_HASH,\n                             MEMCACHED_HASH_CRC);\n    }\n  };\n  ~MemcacheData() {\n    memcached_free(&m_memcache);\n  };\n};\n\nstatic bool ini_on_update_hash_strategy(const std::string& value) {\n  if (!strncasecmp(value.data(), \"standard\", sizeof(\"standard\"))) {\n    MEMCACHEG(hash_strategy) = \"standard\";\n  } else if (!strncasecmp(value.data(), \"consistent\", sizeof(\"consistent\"))) {\n    MEMCACHEG(hash_strategy) = \"consistent\";\n  }\n  return false;\n}\n\nstatic bool ini_on_update_hash_function(const std::string& value) {\n  if (!strncasecmp(value.data(), \"crc32\", sizeof(\"crc32\"))) {\n    MEMCACHEG(hash_function) = \"crc32\";\n  } else if (!strncasecmp(value.data(), \"fnv\", sizeof(\"fnv\"))) {\n    MEMCACHEG(hash_function) = \"fnv\";\n  }\n  return false;\n}\n\nstatic bool hasAvailableServers(const MemcacheData* data) {\n  if (memcached_server_count(&data->m_memcache) == 0) {\n    raise_warning(\"Memcache: No servers added to memcache connection\");\n    return false;\n  }\n  return true;\n}\n\nstatic bool isServerReachable(const String& host, int port /*= 0*/) {\n  auto hostInfo = HHVM_FN(getaddrinfo)(host, port);\n  if (hostInfo.isBoolean() && !hostInfo.toBoolean()) {\n    raise_warning(\"Memcache: Can't connect to %s:%d\", host.c_str(), port);\n    return false;\n  }\n  return true;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// methods\n\nstatic bool HHVM_METHOD(Memcache, connect, const String& host, int port /*= 0*/,\n                        int /*timeout*/ /*= 0*/, int /*timeoutms*/ /*= 0*/) {\n  auto data = Native::data<MemcacheData>(this_);\n  memcached_return_t ret;\n\n  if (!host.empty() &&\n      !strncmp(host.c_str(), \"unix://\", sizeof(\"unix://\") - 1)) {\n    const char *socket_path = host.substr(sizeof(\"unix://\") - 1).c_str();\n    ret = memcached_server_add_unix_socket(&data->m_memcache, socket_path);\n  } else {\n    if (!isServerReachable(host, port)) {\n      return false;\n    }\n    ret = memcached_server_add(&data->m_memcache, host.c_str(), port);\n  }\n\n  return (ret == MEMCACHED_SUCCESS);\n}\n\nstatic uint32_t memcache_get_flag_for_type(const Variant& var) {\n  switch (var.getType()) {\n    case KindOfBoolean:\n      return MMC_TYPE_BOOL;\n    case KindOfInt64:\n      return MMC_TYPE_LONG;\n    case KindOfDouble:\n      return MMC_TYPE_DOUBLE;\n\n    case KindOfUninit:\n    case KindOfNull:\n    case KindOfPersistentString:\n    case KindOfString:\n    case KindOfPersistentVec:\n    case KindOfVec:\n    case KindOfPersistentDict:\n    case KindOfDict:\n    case KindOfPersistentKeyset:\n    case KindOfKeyset:\n    case KindOfPersistentShape:\n    case KindOfShape:\n    case KindOfPersistentArray:\n    case KindOfArray:\n    case KindOfObject:\n    case KindOfResource:\n    case KindOfRef:\n    case KindOfFunc:\n    case KindOfClass:\n      return MMC_TYPE_STRING;\n  }\n  not_reached();\n}\n\nstatic void memcache_set_type_from_flag(Variant& var, uint32_t flags) {\n  switch (flags & MMC_TYPE_MASK) {\n  case MMC_TYPE_BOOL:\n    var = var.toBoolean();\n    break;\n  case MMC_TYPE_LONG:\n    var = var.toInt64();\n    break;\n  case MMC_TYPE_DOUBLE:\n    var = var.toDouble();\n    break;\n  }\n}\n\nstatic std::vector<char> memcache_prepare_for_storage(const MemcacheData* data,\n                                                      const Variant& var,\n                                                      int &flag) {\n  String v;\n  if (var.isString()) {\n    v = var.toString();\n  } else if (var.isNumeric() || var.isBoolean()) {\n    flag &= ~MMC_COMPRESSED;\n    v = var.toString();\n  } else {\n    flag |= MMC_SERIALIZED;\n    v = f_serialize(var);\n  }\n  std::vector<char> payload;\n  size_t value_len = v.length();\n\n  if (!var.isNumeric() && !var.isBoolean() &&\n    data->m_compress_threshold && value_len >= data->m_compress_threshold) {\n    flag |= MMC_COMPRESSED;\n  }\n  if (flag & MMC_COMPRESSED) {\n    size_t payload_len = compressBound(value_len);\n    payload.resize(payload_len);\n    if (compress((Bytef*)payload.data(), &payload_len,\n                 (const Bytef*)v.data(), value_len) == Z_OK) {\n      payload.resize(payload_len);\n      if (payload_len >= value_len * (1 - data->m_min_compress_savings)) {\n        flag &= ~MMC_COMPRESSED;\n      }\n    } else {\n      flag &= ~MMC_COMPRESSED;\n      raise_warning(\"could not compress value\");\n    }\n  }\n  if (!(flag & MMC_COMPRESSED)) {\n    payload.resize(0);\n    payload.insert(payload.end(), v.data(), v.data() + value_len);\n   }\n  flag |= memcache_get_flag_for_type(var);\n\n  return payload;\n}\n\nstatic String memcache_prepare_key(const String& var) {\n  String var_mutable(var, CopyString);\n  auto data = var_mutable.get()->mutableData();\n  for (int i = 0; i < var.length(); i++) {\n    // This is a stupid encoding since it causes collisions but it matches php5\n    if (data[i] <= ' ') {\n      data[i] = '_';\n    }\n  }\n  return data;\n}\n\nstatic Variant unserialize_if_serialized(const char *payload,\n                                         size_t payload_len,\n                                         uint32_t flags) {\n  Variant ret = uninit_null();\n  if (flags & MMC_SERIALIZED) {\n    ret = unserialize_from_buffer(\n      payload,\n      payload_len,\n      VariableUnserializer::Type::Serialize\n    );\n  } else {\n    if (payload_len == 0) {\n      ret = empty_string();\n    } else {\n      ret = String(payload, payload_len, CopyString);\n    }\n  }\n  return ret;\n }\n\nstatic Variant memcache_fetch_from_storage(const char *payload,\n                                           size_t payload_len,\n                                           uint32_t flags) {\n  Variant ret = uninit_null();\n\n  if (flags & MMC_COMPRESSED) {\n    bool done = false;\n    std::vector<char> buffer;\n    size_t buffer_len;\n    for (int factor = 1; !done && factor <= 16; ++factor) {\n      if (payload_len >=\n          std::numeric_limits<unsigned long>::max() / (1 << factor)) {\n        break;\n      }\n      buffer_len = payload_len * (1 << factor) + 1;\n      buffer.resize(buffer_len);\n      if (uncompress((Bytef*)buffer.data(), &buffer_len,\n                     (const Bytef*)payload, (uLong)payload_len) == Z_OK) {\n        done = true;\n      }\n    }\n    if (!done) {\n      raise_warning(\"could not uncompress value\");\n      return init_null();\n    }\n    ret = unserialize_if_serialized(buffer.data(), buffer_len, flags);\n  } else {\n    ret = unserialize_if_serialized(payload, payload_len, flags);\n  }\n  memcache_set_type_from_flag(ret, flags);\n\n  return ret;\n}\n\nstatic bool HHVM_METHOD(Memcache, add, const String& key, const Variant& var,\n                                       int flag /*= 0*/, int expire /*= 0*/) {\n  if (key.empty()) {\n    raise_warning(\"Key cannot be empty\");\n    return false;\n  }\n\n  auto data = Native::data<MemcacheData>(this_);\n\n  if (!hasAvailableServers(data)) {\n    return false;\n  }\n\n  std::vector<char> serialized = memcache_prepare_for_storage(data, var, flag);\n\n  String serializedKey = memcache_prepare_key(key);\n  memcached_return_t ret = memcached_add(&data->m_memcache,\n                                        serializedKey.c_str(),\n                                        serializedKey.length(),\n                                        serialized.data(),\n                                        serialized.size(),\n                                        expire, flag);\n\n  return (ret == MEMCACHED_SUCCESS);\n}\n\nstatic bool HHVM_METHOD(Memcache, set, const String& key, const Variant& var,\n                                       int flag /*= 0*/, int expire /*= 0*/) {\n  if (key.empty()) {\n    raise_warning(\"Key cannot be empty\");\n    return false;\n  }\n\n  auto data = Native::data<MemcacheData>(this_);\n\n  if (!hasAvailableServers(data)) {\n    return false;\n  }\n\n  String serializedKey = memcache_prepare_key(key);\n  std::vector<char> serializedVar =\n    memcache_prepare_for_storage(data, var, flag);\n\n  memcached_return_t ret = memcached_set(&data->m_memcache,\n                                         serializedKey.c_str(),\n                                         serializedKey.length(),\n                                         serializedVar.data(),\n                                         serializedVar.size(), expire, flag);\n\n  if (ret == MEMCACHED_SUCCESS) {\n    return true;\n  }\n\n  return false;\n}\n\nstatic bool HHVM_METHOD(Memcache, replace, const String& key,\n                                           const Variant& var, int flag /*= 0*/,\n                                           int expire /*= 0*/) {\n  if (key.empty()) {\n    raise_warning(\"Key cannot be empty\");\n    return false;\n  }\n\n  auto data = Native::data<MemcacheData>(this_);\n\n  if (!hasAvailableServers(data)) {\n    return false;\n  }\n\n  String serializedKey = memcache_prepare_key(key);\n  std::vector<char> serialized = memcache_prepare_for_storage(data, var, flag);\n\n  memcached_return_t ret = memcached_replace(&data->m_memcache,\n                                             serializedKey.c_str(),\n                                             serializedKey.length(),\n                                             serialized.data(),\n                                             serialized.size(),\n                                             expire, flag);\n  return (ret == MEMCACHED_SUCCESS);\n}\n\nstatic Variant\nHHVM_METHOD(Memcache, get, const Variant& key, VRefParam /*flags*/ /*= null*/) {\n  auto data = Native::data<MemcacheData>(this_);\n\n  if (!hasAvailableServers(data)) {\n    return false;\n  }\n\n  if (key.isArray()) {\n    std::vector<const char *> real_keys;\n    std::vector<size_t> key_len;\n    Array keyArr = key.toArray();\n\n    real_keys.reserve(keyArr.size());\n    key_len.reserve(keyArr.size());\n\n    for (ArrayIter iter(keyArr); iter; ++iter) {\n      auto key = iter.second().toString();\n      String serializedKey = memcache_prepare_key(key);\n      char *k = new char[serializedKey.length()+1];\n      memcpy(k, serializedKey.c_str(), serializedKey.length() + 1);\n      real_keys.push_back(k);\n      key_len.push_back(serializedKey.length());\n    }\n\n    if (!real_keys.empty()) {\n      const char *payload = nullptr;\n      size_t payload_len = 0;\n      uint32_t flags = 0;\n      const char *res_key = nullptr;\n      size_t res_key_len = 0;\n\n      memcached_result_st result;\n\n      memcached_return_t ret = memcached_mget(&data->m_memcache, &real_keys[0],\n                                              &key_len[0], real_keys.size());\n      memcached_result_create(&data->m_memcache, &result);\n\n      // To mimic PHP5 should return empty array at failure.\n      Array return_val = Array::Create();\n\n      while ((memcached_fetch_result(&data->m_memcache, &result, &ret))\n             != nullptr) {\n        if (ret != MEMCACHED_SUCCESS) {\n          // should probably notify about errors\n          continue;\n        }\n\n        payload     = memcached_result_value(&result);\n        payload_len = memcached_result_length(&result);\n        flags       = memcached_result_flags(&result);\n        res_key     = memcached_result_key_value(&result);\n        res_key_len = memcached_result_key_length(&result);\n\n        return_val.set(String(res_key, res_key_len, CopyString),\n                       memcache_fetch_from_storage(payload,\n                                                   payload_len, flags));\n      }\n      memcached_result_free(&result);\n      for ( size_t i = 0 ; i < real_keys.size() ; i++ ) {\n        delete [] real_keys[i];\n      }\n\n      return return_val;\n    }\n  } else {\n    char *payload = nullptr;\n    size_t payload_len = 0;\n    uint32_t flags = 0;\n\n    memcached_return_t ret;\n    String serializedKey = memcache_prepare_key(key.toString());\n\n    if (serializedKey.length() == 0) {\n      return false;\n    }\n\n    payload = memcached_get(&data->m_memcache, serializedKey.c_str(),\n                            serializedKey.length(), &payload_len, &flags, &ret);\n\n    /* This is for historical reasons from libmemcached*/\n    if (ret == MEMCACHED_END) {\n      ret = MEMCACHED_NOTFOUND;\n    }\n\n    if (ret == MEMCACHED_NOTFOUND) {\n      return false;\n    }\n\n    if (ret != MEMCACHED_SUCCESS) {\n      return false;\n    }\n\n    Variant retval = memcache_fetch_from_storage(payload, payload_len, flags);\n    free(payload);\n\n    return retval;\n  }\n  return false;\n}\n\nstatic bool HHVM_METHOD(Memcache, delete, const String& key,\n                                          int expire /*= 0*/) {\n  if (key.empty()) {\n    raise_warning(\"Key cannot be empty\");\n    return false;\n  }\n\n  auto data = Native::data<MemcacheData>(this_);\n\n  if (!hasAvailableServers(data)) {\n    return false;\n  }\n\n  String serializedKey = memcache_prepare_key(key);\n  memcached_return_t ret = memcached_delete(&data->m_memcache,\n                                            serializedKey.c_str(),\n                                            serializedKey.length(),\n                                            expire);\n  return (ret == MEMCACHED_SUCCESS);\n}\n\nstatic Variant HHVM_METHOD(Memcache, increment, const String& key,\n                                                int offset /*= 1*/) {\n  if (key.empty()) {\n    raise_warning(\"Key cannot be empty\");\n    return false;\n  }\n\n  auto data = Native::data<MemcacheData>(this_);\n\n  if (!hasAvailableServers(data)) {\n    return false;\n  }\n\n  uint64_t value;\n  String serializedKey = memcache_prepare_key(key);\n  memcached_return_t ret = memcached_increment(&data->m_memcache,\n                                               serializedKey.c_str(),\n                                               serializedKey.length(), offset,\n                                               &value);\n\n  if (ret == MEMCACHED_SUCCESS) {\n    return (int64_t)value;\n  }\n\n  return false;\n}\n\nstatic Variant HHVM_METHOD(Memcache, decrement, const String& key,\n                                                int offset /*= 1*/) {\n  if (key.empty()) {\n    raise_warning(\"Key cannot be empty\");\n    return false;\n  }\n\n  auto data = Native::data<MemcacheData>(this_);\n\n  if (!hasAvailableServers(data)) {\n    return false;\n  }\n\n  uint64_t value;\n  String serializedKey = memcache_prepare_key(key);\n  memcached_return_t ret = memcached_decrement(&data->m_memcache,\n                                               serializedKey.c_str(),\n                                               serializedKey.length(), offset,\n                                               &value);\n\n  if (ret == MEMCACHED_SUCCESS) {\n    return (int64_t)value;\n  }\n\n  return false;\n}\n\nstatic bool HHVM_METHOD(Memcache, close) {\n  auto data = Native::data<MemcacheData>(this_);\n  memcached_quit(&data->m_memcache);\n  return true;\n}\n\nstatic Variant HHVM_METHOD(Memcache, getversion) {\n  auto data = Native::data<MemcacheData>(this_);\n  int server_count = memcached_server_count(&data->m_memcache);\n  char version[16];\n  int version_len = 0;\n\n  if (memcached_version(&data->m_memcache) != MEMCACHED_SUCCESS) {\n    return false;\n  }\n\n  for (int x = 0; x < server_count; x++) {\n    LMCD_SERVER_POSITION_INSTANCE_TYPE instance =\n      memcached_server_instance_by_position(&data->m_memcache, x);\n    uint8_t majorVersion = LMCD_SERVER_MAJOR_VERSION(instance);\n    uint8_t minorVersion = LMCD_SERVER_MINOR_VERSION(instance);\n    uint8_t microVersion = LMCD_SERVER_MICRO_VERSION(instance);\n\n    if (!majorVersion) {\n      continue;\n    }\n\n    version_len = snprintf(version, sizeof(version),\n        \"%\" PRIu8 \".%\" PRIu8 \".%\" PRIu8,\n        majorVersion, minorVersion, microVersion);\n    return String(version, version_len, CopyString);\n  }\n\n  return false;\n}\n\nstatic bool HHVM_METHOD(Memcache, flush, int expire /*= 0*/) {\n  auto data = Native::data<MemcacheData>(this_);\n  return memcached_flush(&data->m_memcache, expire) == MEMCACHED_SUCCESS;\n}\n\nstatic bool HHVM_METHOD(Memcache, setcompressthreshold, int threshold,\n                                        double min_savings /* = 0.2 */) {\n  if (threshold < 0) {\n    raise_warning(\"threshold must be a positive integer\");\n    return false;\n  }\n\n  if (min_savings < 0 || min_savings > 1) {\n    raise_warning(\"min_savings must be a float in the 0..1 range\");\n    return false;\n  }\n\n  auto data = Native::data<MemcacheData>(this_);\n\n  data->m_compress_threshold = threshold;\n  data->m_min_compress_savings = min_savings;\n\n  return true;\n}\n\nstatic Array memcache_build_stats(const memcached_st *ptr,\n                                memcached_stat_st *memc_stat,\n                                memcached_return_t *ret) {\n  char **curr_key;\n  char **stat_keys = memcached_stat_get_keys(const_cast<memcached_st*>(ptr),\n                                             memc_stat, ret);\n\n  if (*ret != MEMCACHED_SUCCESS) {\n    if (stat_keys) {\n      free(stat_keys);\n    }\n    return Array();\n  }\n\n  Array return_val = Array::Create();\n\n  for (curr_key = stat_keys; *curr_key; curr_key++) {\n    char *mc_val;\n    mc_val = memcached_stat_get_value(ptr, memc_stat, *curr_key, ret);\n    if (*ret != MEMCACHED_SUCCESS) {\n      break;\n    }\n    return_val.set(String(*curr_key, CopyString),\n                   String(mc_val, CopyString));\n    free(mc_val);\n  }\n\n  free(stat_keys);\n  return return_val;\n}\n\n\nstatic Array HHVM_METHOD(Memcache, getstats,\n                         const String& type /* = null_string */,\n                         int slabid /* = 0 */, int limit /* = 100 */) {\n  auto data = Native::data<MemcacheData>(this_);\n  if (!memcached_server_count(&data->m_memcache)) {\n    return Array();\n  }\n\n  char extra_args[30] = {0};\n\n  if (slabid) {\n    snprintf(extra_args, sizeof(extra_args), \"%s %d %d\", type.c_str(),\n             slabid, limit);\n  } else if (!type.empty()) {\n    snprintf(extra_args, sizeof(extra_args), \"%s\", type.c_str());\n  }\n\n  LMCD_SERVER_POSITION_INSTANCE_TYPE instance =\n    memcached_server_instance_by_position(&data->m_memcache, 0);\n  const char *hostname = LMCD_SERVER_HOSTNAME(instance);\n  in_port_t port = LMCD_SERVER_PORT(instance);\n\n  memcached_stat_st stats;\n  if (memcached_stat_servername(&stats, extra_args, hostname,\n                                port) != MEMCACHED_SUCCESS) {\n    return Array();\n  }\n\n  memcached_return_t ret;\n  return memcache_build_stats(&data->m_memcache, &stats, &ret);\n}\n\nstatic Array HHVM_METHOD(Memcache, getextendedstats,\n                         const String& /*type*/ /* = null_string */,\n                         int /*slabid*/ /* = 0 */, int /*limit*/ /* = 100 */) {\n  auto data = Native::data<MemcacheData>(this_);\n  memcached_return_t ret;\n  memcached_stat_st *stats;\n\n  stats = memcached_stat(&data->m_memcache, nullptr, &ret);\n  if (ret != MEMCACHED_SUCCESS) {\n    return Array();\n  }\n\n  int server_count = memcached_server_count(&data->m_memcache);\n\n  Array return_val;\n\n  for (int server_id = 0; server_id < server_count; server_id++) {\n    memcached_stat_st *stat;\n    LMCD_SERVER_POSITION_INSTANCE_TYPE instance =\n      memcached_server_instance_by_position(&data->m_memcache, server_id);\n    const char *hostname = LMCD_SERVER_HOSTNAME(instance);\n    in_port_t port = LMCD_SERVER_PORT(instance);\n\n    stat = stats + server_id;\n\n    Array server_stats = memcache_build_stats(&data->m_memcache, stat, &ret);\n    if (ret != MEMCACHED_SUCCESS) {\n      continue;\n    }\n\n    auto const port_str = folly::to<std::string>(port);\n    auto const key_len = strlen(hostname) + 1 + port_str.length();\n    auto key = String(key_len, ReserveString);\n    key += hostname;\n    key += \":\";\n    key += port_str;\n    return_val.set(key, server_stats);\n  }\n\n  free(stats);\n  return return_val;\n}\n\nstatic bool\nHHVM_METHOD(Memcache, addserver, const String& host, int port /* = 11211 */,\n            bool /*persistent*/ /* = false */, int weight /* = 0 */,\n            int /*timeout*/ /* = 0 */, int /*retry_interval*/ /* = 0 */,\n            bool /*status*/ /* = true */,\n            const Variant& /*failure_callback*/ /* = uninit_variant */,\n            int /*timeoutms*/ /* = 0 */) {\n  auto data = Native::data<MemcacheData>(this_);\n  memcached_return_t ret;\n\n  if (!host.empty() &&\n      !strncmp(host.c_str(), \"unix://\", sizeof(\"unix://\") - 1)) {\n    const char *socket_path = host.substr(sizeof(\"unix://\") - 1).c_str();\n    ret = memcached_server_add_unix_socket_with_weight(&data->m_memcache,\n                                                       socket_path, weight);\n  } else {\n    ret = memcached_server_add_with_weight(&data->m_memcache, host.c_str(),\n                                           port, weight);\n  }\n\n  if (ret == MEMCACHED_SUCCESS) {\n    return true;\n  }\n\n  return false;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\nstruct MemcacheExtension final : Extension {\n    MemcacheExtension() : Extension(\"memcache\", \"3.0.8\") {};\n    void threadInit() override {\n      assertx(!s_memcache_globals);\n      s_memcache_globals = new MEMCACHEGlobals;\n      IniSetting::Bind(this, IniSetting::PHP_INI_ALL,\n                       \"memcache.hash_strategy\", \"standard\",\n                       IniSetting::SetAndGet<std::string>(\n                         ini_on_update_hash_strategy,\n                         nullptr\n                       ),\n                       &MEMCACHEG(hash_strategy));\n      IniSetting::Bind(this, IniSetting::PHP_INI_ALL,\n                       \"memcache.hash_function\", \"crc32\",\n                       IniSetting::SetAndGet<std::string>(\n                         ini_on_update_hash_function,\n                         nullptr\n                       ),\n                       &MEMCACHEG(hash_function));\n    }\n    void threadShutdown() override {\n      delete s_memcache_globals;\n      s_memcache_globals = nullptr;\n    }\n\n    void moduleInit() override {\n      HHVM_RC_INT(MEMCACHE_COMPRESSED, k_MEMCACHE_COMPRESSED);\n      HHVM_RC_BOOL(MEMCACHE_HAVE_SESSION, true);\n      HHVM_ME(Memcache, connect);\n      HHVM_ME(Memcache, add);\n      HHVM_ME(Memcache, set);\n      HHVM_ME(Memcache, replace);\n      HHVM_ME(Memcache, get);\n      HHVM_ME(Memcache, delete);\n      HHVM_ME(Memcache, increment);\n      HHVM_ME(Memcache, decrement);\n      HHVM_ME(Memcache, close);\n      HHVM_ME(Memcache, getversion);\n      HHVM_ME(Memcache, flush);\n      HHVM_ME(Memcache, setcompressthreshold);\n      HHVM_ME(Memcache, getstats);\n      HHVM_ME(Memcache, getextendedstats);\n      HHVM_ME(Memcache, addserver);\n\n      Native::registerNativeDataInfo<MemcacheData>(s_MemcacheData.get());\n\n      loadSystemlib();\n    }\n} s_memcache_extension;;\n\n}\n"], "filenames": ["hphp/runtime/ext/memcache/ext_memcache.cpp"], "buggy_code_start_loc": [703], "buggy_code_end_loc": [721], "fixing_code_start_loc": [702], "fixing_code_end_loc": [722], "type": "CWE-125", "message": "The Memcache::getextendedstats function can be used to trigger an out-of-bounds read. Exploiting this issue requires control over memcached server hostnames and/or ports. This affects all supported versions of HHVM (3.30 and 3.27.4 and below).", "other": {"cve": {"id": "CVE-2018-6340", "sourceIdentifier": "cve-assign@fb.com", "published": "2018-12-31T22:29:00.327", "lastModified": "2019-10-09T23:41:46.970", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The Memcache::getextendedstats function can be used to trigger an out-of-bounds read. Exploiting this issue requires control over memcached server hostnames and/or ports. This affects all supported versions of HHVM (3.30 and 3.27.4 and below)."}, {"lang": "es", "value": "La funci\u00f3n Memcache::getextendedstats puede utilizarse para provocar una lectura fuera de l\u00edmites. La explotaci\u00f3n de este problema requiere control sobre nombres y/o puertos del servidor \"memcatched\". Esto afecta a todas las versiones soportadas de HVVM (en versiones anteriores a las 3.30 y 3.27.4)."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.2, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}, {"source": "cve-assign@fb.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:facebook:hhvm:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.27.4", "matchCriteriaId": "20625917-395C-4FE6-B681-8C8C2078549E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:facebook:hhvm:3.30:*:*:*:*:*:*:*", "matchCriteriaId": "902E260E-9611-4217-A38A-4143F6C5A165"}]}]}], "references": [{"url": "https://github.com/facebook/hhvm/commit/4bff3bfbe90d10451e4638c2118d1ad1117bb3e3", "source": "cve-assign@fb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://hhvm.com/blog/2018/12/18/hhvm-3.30.1.html", "source": "cve-assign@fb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/facebook/hhvm/commit/4bff3bfbe90d10451e4638c2118d1ad1117bb3e3"}}