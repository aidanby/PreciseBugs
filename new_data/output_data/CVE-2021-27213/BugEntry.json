{"buggy_code": ["import logging.handlers\nimport yaml\nimport importlib\nimport threading\n\ntry:\n    from queue import Queue\nexcept ImportError:\n    from Queue import Queue\n\nfrom pystemon.sendmail import PystemonSendmail\nfrom pystemon.storage import PastieStorage\nfrom pystemon.proxy import ProxyList\nfrom pystemon.pastiesearch import PastieSearch\nfrom pystemon.exception import PystemonConfigException\n\nlogger = logging.getLogger('pystemon')\n\nclass SiteConfig():\n    def __init__(self, name, config):\n        self.name = name\n        self._queue = None\n        self.download_url = config['download-url']\n        self.archive_url = config['archive-url']\n        self.archive_regex = config['archive-regex']\n        self.throttling = config.get('throttling', 0)\n        self.public_url= config.get('public-url')\n        self.metadata_url = config.get('metadata-url')\n        self.update_min = config.get('update-min', 10)\n        self.update_max = config.get('update-max', 30)\n        self.pastie_classname = config.get('pastie-classname')\n\n    @property\n    def queue(self):\n        if self._queue is None:\n            logger.debug(\"{}: initializing with empty Queue\".format(repr(self)))\n            self._queue = Queue()\n        return self._queue\n\n    @queue.setter\n    def queue(self, q):\n        logger.debug(\"{}: inheriting queue of size={}\".format(repr(self), q.qsize()))\n        self._queue = q\n\n    def __str__(self):\n        return '''SiteConfig[{}]:\n        download url: {}\n        archive url:  {}\n        public url:   {}\n        metadata url: {}\n        pastie class: {}\n        '''.format(self.name, self.download_url, self.archive_url,\n                self.public_url, self.metadata_url, self.pastie_classname)\n\n    def __repr__(self):\n        return \"SiteConfig[{}]\".format(self.name)\n\n    def __eq__(self, other):\n        res = False\n        try:\n            res = ( isinstance(other, SiteConfig) and (self.download_url == other.download_url)\n                    and\n                    (self.archive_url == other.archive_url)\n                    and\n                    (self.public_url == other.public_url)\n                    and\n                    (self.metadata_url == other.metadata_url)\n                    and\n                    (self.pastie_classname == other.pastie_classname) )\n        except Exception as e:\n            logger.error(\"Unable to compare SiteConfig instances: {}\".format(e))\n            pass\n        return res\n\n    def __hash(self):\n        return self.name.__hash__()\n\n# TODO verify validity of all config parameters\nclass PystemonConfig():\n    def __init__(self, configfile, debug):\n        self.debug = debug\n        self.lock = threading.Lock()\n        self._configfile = configfile\n        self._yamlconfig = None\n        self._pidfile = None\n        self._ip_addr = None\n        self._sendmail = None\n        self._user_agents_list = None\n        self._storage_engines = None\n        self._proxies_list = None\n        self._re_module = None\n        self._save_thread = False\n        self._patterns = []\n        self._threads = 1\n        self._sites = []\n        self._save_dir = None\n        self._archive_dir = None\n        self._compress = False\n        self._reload_count = 0\n        self._max_throttling = 0\n        self._preload()\n\n    def is_same_as(self, other):\n        # TODO check if config changed\n        res = False\n        try:\n            res = self._configfile == other._configfile\n        except Exception as e:\n            pass\n        return res\n\n    @property\n    def pidfile(self):\n        with self.lock:\n            return self._pidfile\n\n    @property\n    def save_thread(self):\n        with self.lock:\n            return self._save_thread\n\n    @property\n    def save_dir(self):\n        with self.lock:\n            return self._save_dir\n\n    @property\n    def archive_dir(self):\n        with self.lock:\n            return self._archive_dir\n\n    @property\n    def compress(self):\n        with self.lock:\n            return self._compress\n\n    @property\n    def threads(self):\n        with self.lock:\n            return self._threads\n\n    @property\n    def ip_addr(self):\n        with self.lock:\n            return self._ip_addr\n\n    @property\n    def sendmail(self):\n        with self.lock:\n            return self._sendmail\n\n    @property\n    def user_agents_list(self):\n        with self.lock:\n            return self._user_agents_list\n\n    @property\n    def storage_engines(self):\n        with self.lock:\n            return self._storage_engines\n\n    @property\n    def proxies_list(self):\n        with self.lock:\n            return self._proxies_list\n\n    @property\n    def configfile(self):\n        with self.lock:\n            return self._configfile\n\n    @property\n    def re_module(self):\n        with self.lock:\n            return self._re_module\n\n    @property\n    def patterns(self):\n        with self.lock:\n            return self._patterns\n\n    @property\n    def sites(self):\n        with self.lock:\n            return self._sites\n\n    @property\n    def max_throttling(self):\n        with self.lock:\n            return self._max_throttling\n\n    def reload(self):\n        try:\n            with self.lock:\n                if self._reload_count:\n                    logger.debug(\"reloading configuration file '{0}'\".format(self._configfile))\n                    self._yamlconfig = None\n                else:\n                    logger.debug(\"loading configuration file '{0}'\".format(self._configfile))\n                self._reload_count = self._reload_count + 1\n                self._preload()\n                config = self._reload()\n                self._ip_addr = config.get('ip_addr')\n                self._sendmail = config.get('sendmail')\n                self._save_thread = config.get('save_thread')\n                self._user_agents_list = config.get('user_agents_list')\n                self._storage_engines = config.get('storage_engines')\n                self._save_dir = config.get('save_dir')\n                self._archive_dir = config.get('archive_dir')\n                self._compress = config.get('compress')\n                self._proxies_list = config.get('proxies_list')\n                self._re_module = config.get('re_module')\n                self._patterns = config.get('patterns')\n                self._sites = config.get('sites')\n                self._threads = config.get('threads')\n                self._pidfile = config.get('pidfile')\n                self._max_throttling = 0\n                for site in self._sites:\n                    if self._max_throttling < site.throttling:\n                        self._max_throttling = site.throttling\n        except PystemonConfigException:\n            raise\n        except Exception as e:\n            raise PystemonConfigException('Unable to parse configuration: {}'.format(e))\n        logger.debug(\"configuration loaded\")\n        return True\n\n    def _preload(self):\n        if self._yamlconfig is None:\n            logger.debug(\"pre-loading config file '{}'\".format(self._configfile))\n            self._yamlconfig = self._load_yamlconfig(self._configfile)\n            try:\n                self._pidfile = self._yamlconfig['pid']['filename']\n            except KeyError:\n                pass\n\n    def _reload(self):\n        logger.debug(\"parsing yaml configuration from file '{}'\".format(self._configfile))\n        config = {}\n        yamlconfig = self._yamlconfig\n        try:\n            if yamlconfig['proxy']['random']:\n                config['proxies_list'] = ProxyList(yamlconfig['proxy']['file'])\n        except KeyError:\n            pass\n\n        config['save_thread'] = yamlconfig.get('save-thread', False)\n\n        uaconfig = yamlconfig.get('user-agent', {})\n        if uaconfig.get('random', False):\n            try:\n                config['user_agents_list'] = self._load_user_agents_from_file(yamlconfig['user-agent']['file'])\n            except KeyError:\n                raise PystemonConfigException('random user-agent requested but no file provided')\n\n        try:\n            ip_addr = yamlconfig['network']['ip']\n        except KeyError:\n            logger.debug(\"Using default IP address\")\n            pass\n\n        config['sendmail'] = self._load_email(yamlconfig)\n        res = self._load_storage_engines(yamlconfig)\n        config['storage_engines'] = res['engines']\n        config['save_dir'] = res['save_dir']\n        config['archive_dir'] = res['archive_dir']\n        config['compress'] = res['compress']\n        config['re_module'] = self._load_regex_engine(yamlconfig)\n        config['patterns'] = self._compile_regex(yamlconfig, config['re_module'])\n        try:\n            config['threads'] = int(yamlconfig.get('threads', 1))\n            if config['threads'] < 1:\n                raise Exception(\"minimum acceptable value is 1\")\n        except Exception as e:\n            logger.error(\"invalid threads value specified: {0}\".format(e))\n            config['threads'] = 1\n            pass\n\n        config['sites'] = self._load_sites(yamlconfig)\n\n        if not self.debug and 'logging-level' in yamlconfig:\n            if yamlconfig['logging-level'] in ['NOTSET', 'DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL']:\n                logger.setLevel(logging.getLevelName(yamlconfig['logging-level']))\n            else:\n                logger.error(\"logging level \\\"%s\\\" is invalid\" % (yamlconfig['logging-level']))\n\n        logger.debug(\"yaml configuration parsed\")\n        return config\n\n    def _recent_pyyaml(self):\n        res = False\n        try:\n            version = yaml.__version__.split('.')\n            if int(version[0]) >= 5:\n                if int(version[1]) >= 1:\n                    res = True\n        except Exception as e:\n            logger.debug(\"unable to parse PyYaml version: {}\".format(e))\n        return res\n\n    def _load_yamlconfig(self, configfile):\n        yamlconfig = None\n        try:\n            if self._recent_pyyaml():\n                # https://github.com/yaml/pyyaml/wiki/PyYAML-yaml.load(input)-Deprecation\n                # only for 5.1+\n                yamlconfig = yaml.load(open(configfile), Loader=yaml.FullLoader)\n            else:\n                yamlconfig = yaml.load(open(configfile))\n        except yaml.YAMLError as exc:\n            logger.error(\"Error in configuration file {0}:\".format(configfile))\n            if hasattr(exc, 'problem_mark'):\n                mark = exc.problem_mark\n                raise PystemonConfigException(\"error position: (%s:%s)\" % (mark.line + 1, mark.column + 1))\n        for includes in yamlconfig.get(\"includes\", []):\n            try:\n                logger.debug(\"loading include '{0}'\".format(includes))\n                yamlconfig.update(yaml.load(open(includes)))\n            except Exception as e:\n                raise PystemonConfigException(\"failed to load '{0}': {1}\".format(includes, e))\n        return yamlconfig\n\n\n    def _load_user_agents_from_file(self, filename):\n        user_agents_list = []\n        logger.debug('Loading user-agent from file \"{file}\" ...'.format(file=filename))\n        with open(filename) as f:\n            for line in f:\n                line = line.strip()\n                if line:\n                    user_agents_list.append(line)\n        if not len(user_agents_list) > 0:\n            raise PystemonConfigException(\"found zero valid UserAgents\")\n        logger.debug(\"Found {count} UserAgents in file '{file}'\".format(file=filename, count=len(user_agents_list)))\n        return user_agents_list\n\n    def _load_email(self, yamlconfig):\n        sendmail = None\n        email=yamlconfig.get('email', {})\n        if email.get('alert'):\n            logger.debug('loading email configuration')\n            sendmail = PystemonSendmail(email['from'], email['to'], email['subject'],\n                    server=email.get('server', '127.0.0.1'),\n                    port=email.get('port', 25),\n                    tls=email.get('tls', False),\n                    username=email.get('username'),\n                    password=email.get('password'),\n                    size_limit=email.get('size-limit', 1024*1024))\n            logger.debug(\"alert emails will be sent to '{0}' from '{1}' via '{2}'\".format(sendmail.mailto, sendmail.mailfrom, sendmail.server))\n        return sendmail\n\n    def _load_storage_engines(self, yamlconfig):\n        # initialize storage backends\n        storage_engines = []\n        storage_yamlconfig = yamlconfig.get('storage', {})\n        save_dir = None\n        archive_dir = None\n        storage_file = None\n        compress = False\n        # file storage is the default and should be initialized first to set save_dir and archive_dir\n        try:\n            storage_file = PastieStorage.load_storage('archive', **storage_yamlconfig.pop('archive'))\n            if storage_file is not None:\n                save_dir = storage_file.save_dir\n                archive_dir = storage_file.archive_dir\n                compress = storage_file.compress\n                storage_engines.append(storage_file)\n        except KeyError as e:\n            raise PystemonConfigException('archive was not found under storage, old pystemon.yaml config?')\n\n        for storage in storage_yamlconfig.keys():\n            engine = PastieStorage.load_storage(storage, save_dir=save_dir, archive_dir=archive_dir,\n                    **storage_yamlconfig[storage])\n            if engine is not None:\n                storage_engines.append(engine)\n        return {'save_dir': save_dir, 'archive_dir': archive_dir, 'compress': compress, 'engines': storage_engines}\n\n    def _load_regex_engine(self, yamlconfig):\n        # load the regular expression engine\n        engine = yamlconfig.get('engine', 're')\n        re_module = None\n        if not engine in ['re', 'regex']:\n            raise PystemonConfigException(\"only 're' or 'regex' supported, not '{0}'\".format(engine))\n        try:\n            logger.debug(\"Loading regular expression engine '{0}'\".format(engine))\n            re_module=importlib.import_module(engine)\n            if engine == 'regex':\n                logger.debug(\"Setting regex DEFAULT_VERSION to VERSION1\")\n                re_module.DEFAULT_VERSION = re.VERSION1\n        except ImportError as e:\n            raise PystemonConfigException(\"unable to import module '{0}'\".format(engine))\n        return re_module\n\n    def _compile_regex(self, yamlconfig, re_module):\n        patterns = []\n        # compile all search patterns\n        strict = yamlconfig.get('strict_regex', False)\n        regexes = yamlconfig['search']\n        logger.debug(\"compiling {} regexes ...\".format(len(regexes)))\n        for regex in regexes:\n            try:\n                search = regex['search']\n                ps = PastieSearch(re_module, regex)\n                patterns.append(ps)\n            except KeyError:\n                if strict:\n                    raise PystemonConfigException(\"Missing search pattern\")\n                else:\n                    logger.error(\"Error: skipping empty search pattern entry\")\n            except Exception as e:\n                if strict:\n                    raise PystemonConfigException(\"Unable to parse regex '%s': %s\" % (search, e))\n                else:\n                    logger.error(\"Error: Unable to parse regex '%s': %s\" % (search, e))\n        logger.debug(\"successfully compiled {0}/{1} regexes\".format(len(patterns), len(regexes)))\n        return patterns\n\n    def _load_sites(self, yamlconfig):\n        # Build array of enabled sites.\n        sites_enabled = []\n        count_enabled = 0\n        sites = yamlconfig['site']\n        logger.debug(\"loading {} sites ...\".format(len(sites)))\n        for site in sites:\n            if yamlconfig['site'][site].get('enable'):\n                logger.info(\"Site: {} is enabled, adding to pool...\".format(site))\n                new_site = None\n                try:\n                    count_enabled = count_enabled + 1\n                    new_site = SiteConfig(site, yamlconfig['site'][site])\n                    if new_site in self._sites:\n                        i = self._sites.index(new_site)\n                        logger.debug(\"found {} in running configuration\".format(repr(new_site)))\n                        current_site = self._sites[i]\n                        logger.debug(\"matching running site: {}\".format(current_site))\n                        q = current_site.queue\n                        logger.debug(\"running queue size: {}\".format(q.qsize()))\n                        new_site.queue = q\n                    sites_enabled.append(new_site)\n                except Exception as e:\n                    logger.error(\"Unable to add site '{0}': {1}\".format(site, e))\n            elif yamlconfig['site'][site].get('enable') is False:\n                logger.info(\"Site: {} is disabled.\".format(site))\n            else:\n                logger.warning(\"Site: {} is not enabled or disabled in config file. We just assume it disabled.\".format(site))\n        logger.debug(\"successfully loaded {0}/{1} enabled site(s)\".format(len(sites_enabled), count_enabled))\n        return sites_enabled\n\n"], "fixing_code": ["import logging.handlers\nimport yaml\nimport importlib\nimport threading\n\ntry:\n    from queue import Queue\nexcept ImportError:\n    from Queue import Queue\n\nfrom pystemon.sendmail import PystemonSendmail\nfrom pystemon.storage import PastieStorage\nfrom pystemon.proxy import ProxyList\nfrom pystemon.pastiesearch import PastieSearch\nfrom pystemon.exception import PystemonConfigException\n\nlogger = logging.getLogger('pystemon')\n\nclass SiteConfig():\n    def __init__(self, name, config):\n        self.name = name\n        self._queue = None\n        self.download_url = config['download-url']\n        self.archive_url = config['archive-url']\n        self.archive_regex = config['archive-regex']\n        self.throttling = config.get('throttling', 0)\n        self.public_url= config.get('public-url')\n        self.metadata_url = config.get('metadata-url')\n        self.update_min = config.get('update-min', 10)\n        self.update_max = config.get('update-max', 30)\n        self.pastie_classname = config.get('pastie-classname')\n\n    @property\n    def queue(self):\n        if self._queue is None:\n            logger.debug(\"{}: initializing with empty Queue\".format(repr(self)))\n            self._queue = Queue()\n        return self._queue\n\n    @queue.setter\n    def queue(self, q):\n        logger.debug(\"{}: inheriting queue of size={}\".format(repr(self), q.qsize()))\n        self._queue = q\n\n    def __str__(self):\n        return '''SiteConfig[{}]:\n        download url: {}\n        archive url:  {}\n        public url:   {}\n        metadata url: {}\n        pastie class: {}\n        '''.format(self.name, self.download_url, self.archive_url,\n                self.public_url, self.metadata_url, self.pastie_classname)\n\n    def __repr__(self):\n        return \"SiteConfig[{}]\".format(self.name)\n\n    def __eq__(self, other):\n        res = False\n        try:\n            res = ( isinstance(other, SiteConfig) and (self.download_url == other.download_url)\n                    and\n                    (self.archive_url == other.archive_url)\n                    and\n                    (self.public_url == other.public_url)\n                    and\n                    (self.metadata_url == other.metadata_url)\n                    and\n                    (self.pastie_classname == other.pastie_classname) )\n        except Exception as e:\n            logger.error(\"Unable to compare SiteConfig instances: {}\".format(e))\n            pass\n        return res\n\n    def __hash(self):\n        return self.name.__hash__()\n\n# TODO verify validity of all config parameters\nclass PystemonConfig():\n    def __init__(self, configfile, debug):\n        self.debug = debug\n        self.lock = threading.Lock()\n        self._configfile = configfile\n        self._yamlconfig = None\n        self._pidfile = None\n        self._ip_addr = None\n        self._sendmail = None\n        self._user_agents_list = None\n        self._storage_engines = None\n        self._proxies_list = None\n        self._re_module = None\n        self._save_thread = False\n        self._patterns = []\n        self._threads = 1\n        self._sites = []\n        self._save_dir = None\n        self._archive_dir = None\n        self._compress = False\n        self._reload_count = 0\n        self._max_throttling = 0\n        self._preload()\n\n    def is_same_as(self, other):\n        # TODO check if config changed\n        res = False\n        try:\n            res = self._configfile == other._configfile\n        except Exception as e:\n            pass\n        return res\n\n    @property\n    def pidfile(self):\n        with self.lock:\n            return self._pidfile\n\n    @property\n    def save_thread(self):\n        with self.lock:\n            return self._save_thread\n\n    @property\n    def save_dir(self):\n        with self.lock:\n            return self._save_dir\n\n    @property\n    def archive_dir(self):\n        with self.lock:\n            return self._archive_dir\n\n    @property\n    def compress(self):\n        with self.lock:\n            return self._compress\n\n    @property\n    def threads(self):\n        with self.lock:\n            return self._threads\n\n    @property\n    def ip_addr(self):\n        with self.lock:\n            return self._ip_addr\n\n    @property\n    def sendmail(self):\n        with self.lock:\n            return self._sendmail\n\n    @property\n    def user_agents_list(self):\n        with self.lock:\n            return self._user_agents_list\n\n    @property\n    def storage_engines(self):\n        with self.lock:\n            return self._storage_engines\n\n    @property\n    def proxies_list(self):\n        with self.lock:\n            return self._proxies_list\n\n    @property\n    def configfile(self):\n        with self.lock:\n            return self._configfile\n\n    @property\n    def re_module(self):\n        with self.lock:\n            return self._re_module\n\n    @property\n    def patterns(self):\n        with self.lock:\n            return self._patterns\n\n    @property\n    def sites(self):\n        with self.lock:\n            return self._sites\n\n    @property\n    def max_throttling(self):\n        with self.lock:\n            return self._max_throttling\n\n    def reload(self):\n        try:\n            with self.lock:\n                if self._reload_count:\n                    logger.debug(\"reloading configuration file '{0}'\".format(self._configfile))\n                    self._yamlconfig = None\n                else:\n                    logger.debug(\"loading configuration file '{0}'\".format(self._configfile))\n                self._reload_count = self._reload_count + 1\n                self._preload()\n                config = self._reload()\n                self._ip_addr = config.get('ip_addr')\n                self._sendmail = config.get('sendmail')\n                self._save_thread = config.get('save_thread')\n                self._user_agents_list = config.get('user_agents_list')\n                self._storage_engines = config.get('storage_engines')\n                self._save_dir = config.get('save_dir')\n                self._archive_dir = config.get('archive_dir')\n                self._compress = config.get('compress')\n                self._proxies_list = config.get('proxies_list')\n                self._re_module = config.get('re_module')\n                self._patterns = config.get('patterns')\n                self._sites = config.get('sites')\n                self._threads = config.get('threads')\n                self._pidfile = config.get('pidfile')\n                self._max_throttling = 0\n                for site in self._sites:\n                    if self._max_throttling < site.throttling:\n                        self._max_throttling = site.throttling\n        except PystemonConfigException:\n            raise\n        except Exception as e:\n            raise PystemonConfigException('Unable to parse configuration: {}'.format(e))\n        logger.debug(\"configuration loaded\")\n        return True\n\n    def _preload(self):\n        if self._yamlconfig is None:\n            logger.debug(\"pre-loading config file '{}'\".format(self._configfile))\n            self._yamlconfig = self._load_yamlconfig(self._configfile)\n            try:\n                self._pidfile = self._yamlconfig['pid']['filename']\n            except KeyError:\n                pass\n\n    def _reload(self):\n        logger.debug(\"parsing yaml configuration from file '{}'\".format(self._configfile))\n        config = {}\n        yamlconfig = self._yamlconfig\n        try:\n            if yamlconfig['proxy']['random']:\n                config['proxies_list'] = ProxyList(yamlconfig['proxy']['file'])\n        except KeyError:\n            pass\n\n        config['save_thread'] = yamlconfig.get('save-thread', False)\n\n        uaconfig = yamlconfig.get('user-agent', {})\n        if uaconfig.get('random', False):\n            try:\n                config['user_agents_list'] = self._load_user_agents_from_file(yamlconfig['user-agent']['file'])\n            except KeyError:\n                raise PystemonConfigException('random user-agent requested but no file provided')\n\n        try:\n            ip_addr = yamlconfig['network']['ip']\n        except KeyError:\n            logger.debug(\"Using default IP address\")\n            pass\n\n        config['sendmail'] = self._load_email(yamlconfig)\n        res = self._load_storage_engines(yamlconfig)\n        config['storage_engines'] = res['engines']\n        config['save_dir'] = res['save_dir']\n        config['archive_dir'] = res['archive_dir']\n        config['compress'] = res['compress']\n        config['re_module'] = self._load_regex_engine(yamlconfig)\n        config['patterns'] = self._compile_regex(yamlconfig, config['re_module'])\n        try:\n            config['threads'] = int(yamlconfig.get('threads', 1))\n            if config['threads'] < 1:\n                raise Exception(\"minimum acceptable value is 1\")\n        except Exception as e:\n            logger.error(\"invalid threads value specified: {0}\".format(e))\n            config['threads'] = 1\n            pass\n\n        config['sites'] = self._load_sites(yamlconfig)\n\n        if not self.debug and 'logging-level' in yamlconfig:\n            if yamlconfig['logging-level'] in ['NOTSET', 'DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL']:\n                logger.setLevel(logging.getLevelName(yamlconfig['logging-level']))\n            else:\n                logger.error(\"logging level \\\"%s\\\" is invalid\" % (yamlconfig['logging-level']))\n\n        logger.debug(\"yaml configuration parsed\")\n        return config\n\n    def _recent_pyyaml(self):\n        res = False\n        try:\n            version = yaml.__version__.split('.')\n            if int(version[0]) >= 5:\n                if int(version[1]) >= 1:\n                    res = True\n        except Exception as e:\n            logger.debug(\"unable to parse PyYaml version: {}\".format(e))\n        return res\n\n    def _load_yamlconfig(self, configfile):\n        yamlconfig = None\n        try:\n            if self._recent_pyyaml():\n                # https://github.com/yaml/pyyaml/wiki/PyYAML-yaml.load(input)-Deprecation\n                # only for 5.1+\n                yamlconfig = yaml.load(open(configfile), Loader=yaml.SafeLoader)\n            else:\n                yamlconfig = yaml.safe_load(open(configfile))\n        except yaml.YAMLError as exc:\n            logger.error(\"Error in configuration file {0}:\".format(configfile))\n            if hasattr(exc, 'problem_mark'):\n                mark = exc.problem_mark\n                raise PystemonConfigException(\"error position: (%s:%s)\" % (mark.line + 1, mark.column + 1))\n        for includes in yamlconfig.get(\"includes\", []):\n            try:\n                logger.debug(\"loading include '{0}'\".format(includes))\n                yamlconfig.update(yaml.safe_load(open(includes)))\n            except Exception as e:\n                raise PystemonConfigException(\"failed to load '{0}': {1}\".format(includes, e))\n        return yamlconfig\n\n\n    def _load_user_agents_from_file(self, filename):\n        user_agents_list = []\n        logger.debug('Loading user-agent from file \"{file}\" ...'.format(file=filename))\n        with open(filename) as f:\n            for line in f:\n                line = line.strip()\n                if line:\n                    user_agents_list.append(line)\n        if not len(user_agents_list) > 0:\n            raise PystemonConfigException(\"found zero valid UserAgents\")\n        logger.debug(\"Found {count} UserAgents in file '{file}'\".format(file=filename, count=len(user_agents_list)))\n        return user_agents_list\n\n    def _load_email(self, yamlconfig):\n        sendmail = None\n        email=yamlconfig.get('email', {})\n        if email.get('alert'):\n            logger.debug('loading email configuration')\n            sendmail = PystemonSendmail(email['from'], email['to'], email['subject'],\n                    server=email.get('server', '127.0.0.1'),\n                    port=email.get('port', 25),\n                    tls=email.get('tls', False),\n                    username=email.get('username'),\n                    password=email.get('password'),\n                    size_limit=email.get('size-limit', 1024*1024))\n            logger.debug(\"alert emails will be sent to '{0}' from '{1}' via '{2}'\".format(sendmail.mailto, sendmail.mailfrom, sendmail.server))\n        return sendmail\n\n    def _load_storage_engines(self, yamlconfig):\n        # initialize storage backends\n        storage_engines = []\n        storage_yamlconfig = yamlconfig.get('storage', {})\n        save_dir = None\n        archive_dir = None\n        storage_file = None\n        compress = False\n        # file storage is the default and should be initialized first to set save_dir and archive_dir\n        try:\n            storage_file = PastieStorage.load_storage('archive', **storage_yamlconfig.pop('archive'))\n            if storage_file is not None:\n                save_dir = storage_file.save_dir\n                archive_dir = storage_file.archive_dir\n                compress = storage_file.compress\n                storage_engines.append(storage_file)\n        except KeyError as e:\n            raise PystemonConfigException('archive was not found under storage, old pystemon.yaml config?')\n\n        for storage in storage_yamlconfig.keys():\n            engine = PastieStorage.load_storage(storage, save_dir=save_dir, archive_dir=archive_dir,\n                    **storage_yamlconfig[storage])\n            if engine is not None:\n                storage_engines.append(engine)\n        return {'save_dir': save_dir, 'archive_dir': archive_dir, 'compress': compress, 'engines': storage_engines}\n\n    def _load_regex_engine(self, yamlconfig):\n        # load the regular expression engine\n        engine = yamlconfig.get('engine', 're')\n        re_module = None\n        if not engine in ['re', 'regex']:\n            raise PystemonConfigException(\"only 're' or 'regex' supported, not '{0}'\".format(engine))\n        try:\n            logger.debug(\"Loading regular expression engine '{0}'\".format(engine))\n            re_module=importlib.import_module(engine)\n            if engine == 'regex':\n                logger.debug(\"Setting regex DEFAULT_VERSION to VERSION1\")\n                re_module.DEFAULT_VERSION = re.VERSION1\n        except ImportError as e:\n            raise PystemonConfigException(\"unable to import module '{0}'\".format(engine))\n        return re_module\n\n    def _compile_regex(self, yamlconfig, re_module):\n        patterns = []\n        # compile all search patterns\n        strict = yamlconfig.get('strict_regex', False)\n        regexes = yamlconfig['search']\n        logger.debug(\"compiling {} regexes ...\".format(len(regexes)))\n        for regex in regexes:\n            try:\n                search = regex['search']\n                ps = PastieSearch(re_module, regex)\n                patterns.append(ps)\n            except KeyError:\n                if strict:\n                    raise PystemonConfigException(\"Missing search pattern\")\n                else:\n                    logger.error(\"Error: skipping empty search pattern entry\")\n            except Exception as e:\n                if strict:\n                    raise PystemonConfigException(\"Unable to parse regex '%s': %s\" % (search, e))\n                else:\n                    logger.error(\"Error: Unable to parse regex '%s': %s\" % (search, e))\n        logger.debug(\"successfully compiled {0}/{1} regexes\".format(len(patterns), len(regexes)))\n        return patterns\n\n    def _load_sites(self, yamlconfig):\n        # Build array of enabled sites.\n        sites_enabled = []\n        count_enabled = 0\n        sites = yamlconfig['site']\n        logger.debug(\"loading {} sites ...\".format(len(sites)))\n        for site in sites:\n            if yamlconfig['site'][site].get('enable'):\n                logger.info(\"Site: {} is enabled, adding to pool...\".format(site))\n                new_site = None\n                try:\n                    count_enabled = count_enabled + 1\n                    new_site = SiteConfig(site, yamlconfig['site'][site])\n                    if new_site in self._sites:\n                        i = self._sites.index(new_site)\n                        logger.debug(\"found {} in running configuration\".format(repr(new_site)))\n                        current_site = self._sites[i]\n                        logger.debug(\"matching running site: {}\".format(current_site))\n                        q = current_site.queue\n                        logger.debug(\"running queue size: {}\".format(q.qsize()))\n                        new_site.queue = q\n                    sites_enabled.append(new_site)\n                except Exception as e:\n                    logger.error(\"Unable to add site '{0}': {1}\".format(site, e))\n            elif yamlconfig['site'][site].get('enable') is False:\n                logger.info(\"Site: {} is disabled.\".format(site))\n            else:\n                logger.warning(\"Site: {} is not enabled or disabled in config file. We just assume it disabled.\".format(site))\n        logger.debug(\"successfully loaded {0}/{1} enabled site(s)\".format(len(sites_enabled), count_enabled))\n        return sites_enabled\n\n"], "filenames": ["pystemon/config.py"], "buggy_code_start_loc": [307], "buggy_code_end_loc": [319], "fixing_code_start_loc": [307], "fixing_code_end_loc": [319], "type": "CWE-502", "message": "config.py in pystemon before 2021-02-13 allows code execution via YAML deserialization because SafeLoader and safe_load are not used.", "other": {"cve": {"id": "CVE-2021-27213", "sourceIdentifier": "cve@mitre.org", "published": "2021-02-14T04:15:12.837", "lastModified": "2021-02-18T02:14:58.090", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "config.py in pystemon before 2021-02-13 allows code execution via YAML deserialization because SafeLoader and safe_load are not used."}, {"lang": "es", "value": "El archivo config.py en pystemon antes del 13-02-2021, permite una ejecuci\u00f3n de c\u00f3digo por medio de la deserializaci\u00f3n YAML porque las funciones SafeLoader y safe_load no son usadas"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-502"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:pystemon_project:pystemon:*:*:*:*:*:*:*:*", "versionEndExcluding": "2021-02-13", "matchCriteriaId": "BC93F6B1-1E40-4ED3-ADD8-231CD5BF114C"}]}]}], "references": [{"url": "https://github.com/cvandeplas/pystemon/commit/dbeb87afefdb63de2f4cff69b6f10c5965d14b54", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.huntr.dev/bounties/1-other-pystemon/", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/cvandeplas/pystemon/commit/dbeb87afefdb63de2f4cff69b6f10c5965d14b54"}}