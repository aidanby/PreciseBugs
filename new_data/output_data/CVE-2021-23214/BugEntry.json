{"buggy_code": ["/*-------------------------------------------------------------------------\n *\n * pqcomm.c\n *\t  Communication functions between the Frontend and the Backend\n *\n * These routines handle the low-level details of communication between\n * frontend and backend.  They just shove data across the communication\n * channel, and are ignorant of the semantics of the data.\n *\n * To emit an outgoing message, use the routines in pqformat.c to construct\n * the message in a buffer and then emit it in one call to pq_putmessage.\n * There are no functions to send raw bytes or partial messages; this\n * ensures that the channel will not be clogged by an incomplete message if\n * execution is aborted by ereport(ERROR) partway through the message.\n *\n * At one time, libpq was shared between frontend and backend, but now\n * the backend's \"backend/libpq\" is quite separate from \"interfaces/libpq\".\n * All that remains is similarities of names to trap the unwary...\n *\n * Portions Copyright (c) 1996-2021, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n *\tsrc/backend/libpq/pqcomm.c\n *\n *-------------------------------------------------------------------------\n */\n\n/*------------------------\n * INTERFACE ROUTINES\n *\n * setup/teardown:\n *\t\tStreamServerPort\t- Open postmaster's server port\n *\t\tStreamConnection\t- Create new connection with client\n *\t\tStreamClose\t\t\t- Close a client/backend connection\n *\t\tTouchSocketFiles\t- Protect socket files against /tmp cleaners\n *\t\tpq_init\t\t\t- initialize libpq at backend startup\n *\t\tsocket_comm_reset\t- reset libpq during error recovery\n *\t\tsocket_close\t\t- shutdown libpq at backend exit\n *\n * low-level I/O:\n *\t\tpq_getbytes\t\t- get a known number of bytes from connection\n *\t\tpq_getmessage\t- get a message with length word from connection\n *\t\tpq_getbyte\t\t- get next byte from connection\n *\t\tpq_peekbyte\t\t- peek at next byte from connection\n *\t\tpq_flush\t\t- flush pending output\n *\t\tpq_flush_if_writable - flush pending output if writable without blocking\n *\t\tpq_getbyte_if_available - get a byte if available without blocking\n *\n * message-level I/O\n *\t\tpq_putmessage\t- send a normal message (suppressed in COPY OUT mode)\n *\t\tpq_putmessage_noblock - buffer a normal message (suppressed in COPY OUT)\n *\n *------------------------\n */\n#include \"postgres.h\"\n\n#ifdef HAVE_POLL_H\n#include <poll.h>\n#endif\n#include <signal.h>\n#include <fcntl.h>\n#include <grp.h>\n#include <unistd.h>\n#include <sys/file.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#ifdef HAVE_NETINET_TCP_H\n#include <netinet/tcp.h>\n#endif\n#include <utime.h>\n#ifdef _MSC_VER\t\t\t\t\t/* mstcpip.h is missing on mingw */\n#include <mstcpip.h>\n#endif\n\n#include \"common/ip.h\"\n#include \"libpq/libpq.h\"\n#include \"miscadmin.h\"\n#include \"port/pg_bswap.h\"\n#include \"storage/ipc.h\"\n#include \"utils/guc.h\"\n#include \"utils/memutils.h\"\n\n/*\n * Cope with the various platform-specific ways to spell TCP keepalive socket\n * options.  This doesn't cover Windows, which as usual does its own thing.\n */\n#if defined(TCP_KEEPIDLE)\n/* TCP_KEEPIDLE is the name of this option on Linux and *BSD */\n#define PG_TCP_KEEPALIVE_IDLE TCP_KEEPIDLE\n#define PG_TCP_KEEPALIVE_IDLE_STR \"TCP_KEEPIDLE\"\n#elif defined(TCP_KEEPALIVE_THRESHOLD)\n/* TCP_KEEPALIVE_THRESHOLD is the name of this option on Solaris >= 11 */\n#define PG_TCP_KEEPALIVE_IDLE TCP_KEEPALIVE_THRESHOLD\n#define PG_TCP_KEEPALIVE_IDLE_STR \"TCP_KEEPALIVE_THRESHOLD\"\n#elif defined(TCP_KEEPALIVE) && defined(__darwin__)\n/* TCP_KEEPALIVE is the name of this option on macOS */\n/* Caution: Solaris has this symbol but it means something different */\n#define PG_TCP_KEEPALIVE_IDLE TCP_KEEPALIVE\n#define PG_TCP_KEEPALIVE_IDLE_STR \"TCP_KEEPALIVE\"\n#endif\n\n/*\n * Configuration options\n */\nint\t\t\tUnix_socket_permissions;\nchar\t   *Unix_socket_group;\n\n/* Where the Unix socket files are (list of palloc'd strings) */\nstatic List *sock_paths = NIL;\n\n/*\n * Buffers for low-level I/O.\n *\n * The receive buffer is fixed size. Send buffer is usually 8k, but can be\n * enlarged by pq_putmessage_noblock() if the message doesn't fit otherwise.\n */\n\n#define PQ_SEND_BUFFER_SIZE 8192\n#define PQ_RECV_BUFFER_SIZE 8192\n\nstatic char *PqSendBuffer;\nstatic int\tPqSendBufferSize;\t/* Size send buffer */\nstatic int\tPqSendPointer;\t\t/* Next index to store a byte in PqSendBuffer */\nstatic int\tPqSendStart;\t\t/* Next index to send a byte in PqSendBuffer */\n\nstatic char PqRecvBuffer[PQ_RECV_BUFFER_SIZE];\nstatic int\tPqRecvPointer;\t\t/* Next index to read a byte from PqRecvBuffer */\nstatic int\tPqRecvLength;\t\t/* End of data available in PqRecvBuffer */\n\n/*\n * Message status\n */\nstatic bool PqCommBusy;\t\t\t/* busy sending data to the client */\nstatic bool PqCommReadingMsg;\t/* in the middle of reading a message */\n\n\n/* Internal functions */\nstatic void socket_comm_reset(void);\nstatic void socket_close(int code, Datum arg);\nstatic void socket_set_nonblocking(bool nonblocking);\nstatic int\tsocket_flush(void);\nstatic int\tsocket_flush_if_writable(void);\nstatic bool socket_is_send_pending(void);\nstatic int\tsocket_putmessage(char msgtype, const char *s, size_t len);\nstatic void socket_putmessage_noblock(char msgtype, const char *s, size_t len);\nstatic int\tinternal_putbytes(const char *s, size_t len);\nstatic int\tinternal_flush(void);\n\n#ifdef HAVE_UNIX_SOCKETS\nstatic int\tLock_AF_UNIX(const char *unixSocketDir, const char *unixSocketPath);\nstatic int\tSetup_AF_UNIX(const char *sock_path);\n#endif\t\t\t\t\t\t\t/* HAVE_UNIX_SOCKETS */\n\nstatic const PQcommMethods PqCommSocketMethods = {\n\tsocket_comm_reset,\n\tsocket_flush,\n\tsocket_flush_if_writable,\n\tsocket_is_send_pending,\n\tsocket_putmessage,\n\tsocket_putmessage_noblock\n};\n\nconst PQcommMethods *PqCommMethods = &PqCommSocketMethods;\n\nWaitEventSet *FeBeWaitSet;\n\n\n/* --------------------------------\n *\t\tpq_init - initialize libpq at backend startup\n * --------------------------------\n */\nvoid\npq_init(void)\n{\n\tint\t\t\tsocket_pos PG_USED_FOR_ASSERTS_ONLY;\n\tint\t\t\tlatch_pos PG_USED_FOR_ASSERTS_ONLY;\n\n\t/* initialize state variables */\n\tPqSendBufferSize = PQ_SEND_BUFFER_SIZE;\n\tPqSendBuffer = MemoryContextAlloc(TopMemoryContext, PqSendBufferSize);\n\tPqSendPointer = PqSendStart = PqRecvPointer = PqRecvLength = 0;\n\tPqCommBusy = false;\n\tPqCommReadingMsg = false;\n\n\t/* set up process-exit hook to close the socket */\n\ton_proc_exit(socket_close, 0);\n\n\t/*\n\t * In backends (as soon as forked) we operate the underlying socket in\n\t * nonblocking mode and use latches to implement blocking semantics if\n\t * needed. That allows us to provide safely interruptible reads and\n\t * writes.\n\t *\n\t * Use COMMERROR on failure, because ERROR would try to send the error to\n\t * the client, which might require changing the mode again, leading to\n\t * infinite recursion.\n\t */\n#ifndef WIN32\n\tif (!pg_set_noblock(MyProcPort->sock))\n\t\tereport(COMMERROR,\n\t\t\t\t(errmsg(\"could not set socket to nonblocking mode: %m\")));\n#endif\n\n\tFeBeWaitSet = CreateWaitEventSet(TopMemoryContext, 3);\n\tsocket_pos = AddWaitEventToSet(FeBeWaitSet, WL_SOCKET_WRITEABLE,\n\t\t\t\t\t\t\t\t   MyProcPort->sock, NULL, NULL);\n\tlatch_pos = AddWaitEventToSet(FeBeWaitSet, WL_LATCH_SET, PGINVALID_SOCKET,\n\t\t\t\t\t\t\t\t  MyLatch, NULL);\n\tAddWaitEventToSet(FeBeWaitSet, WL_POSTMASTER_DEATH, PGINVALID_SOCKET,\n\t\t\t\t\t  NULL, NULL);\n\n\t/*\n\t * The event positions match the order we added them, but let's sanity\n\t * check them to be sure.\n\t */\n\tAssert(socket_pos == FeBeWaitSetSocketPos);\n\tAssert(latch_pos == FeBeWaitSetLatchPos);\n}\n\n/* --------------------------------\n *\t\tsocket_comm_reset - reset libpq during error recovery\n *\n * This is called from error recovery at the outer idle loop.  It's\n * just to get us out of trouble if we somehow manage to elog() from\n * inside a pqcomm.c routine (which ideally will never happen, but...)\n * --------------------------------\n */\nstatic void\nsocket_comm_reset(void)\n{\n\t/* Do not throw away pending data, but do reset the busy flag */\n\tPqCommBusy = false;\n}\n\n/* --------------------------------\n *\t\tsocket_close - shutdown libpq at backend exit\n *\n * This is the one pg_on_exit_callback in place during BackendInitialize().\n * That function's unusual signal handling constrains that this callback be\n * safe to run at any instant.\n * --------------------------------\n */\nstatic void\nsocket_close(int code, Datum arg)\n{\n\t/* Nothing to do in a standalone backend, where MyProcPort is NULL. */\n\tif (MyProcPort != NULL)\n\t{\n#ifdef ENABLE_GSS\n\t\t/*\n\t\t * Shutdown GSSAPI layer.  This section does nothing when interrupting\n\t\t * BackendInitialize(), because pg_GSS_recvauth() makes first use of\n\t\t * \"ctx\" and \"cred\".\n\t\t *\n\t\t * Note that we don't bother to free MyProcPort->gss, since we're\n\t\t * about to exit anyway.\n\t\t */\n\t\tif (MyProcPort->gss)\n\t\t{\n\t\t\tOM_uint32\tmin_s;\n\n\t\t\tif (MyProcPort->gss->ctx != GSS_C_NO_CONTEXT)\n\t\t\t\tgss_delete_sec_context(&min_s, &MyProcPort->gss->ctx, NULL);\n\n\t\t\tif (MyProcPort->gss->cred != GSS_C_NO_CREDENTIAL)\n\t\t\t\tgss_release_cred(&min_s, &MyProcPort->gss->cred);\n\t\t}\n#endif\t\t\t\t\t\t\t/* ENABLE_GSS */\n\n\t\t/*\n\t\t * Cleanly shut down SSL layer.  Nowhere else does a postmaster child\n\t\t * call this, so this is safe when interrupting BackendInitialize().\n\t\t */\n\t\tsecure_close(MyProcPort);\n\n\t\t/*\n\t\t * Formerly we did an explicit close() here, but it seems better to\n\t\t * leave the socket open until the process dies.  This allows clients\n\t\t * to perform a \"synchronous close\" if they care --- wait till the\n\t\t * transport layer reports connection closure, and you can be sure the\n\t\t * backend has exited.\n\t\t *\n\t\t * We do set sock to PGINVALID_SOCKET to prevent any further I/O,\n\t\t * though.\n\t\t */\n\t\tMyProcPort->sock = PGINVALID_SOCKET;\n\t}\n}\n\n\n\n/*\n * Streams -- wrapper around Unix socket system calls\n *\n *\n *\t\tStream functions are used for vanilla TCP connection protocol.\n */\n\n\n/*\n * StreamServerPort -- open a \"listening\" port to accept connections.\n *\n * family should be AF_UNIX or AF_UNSPEC; portNumber is the port number.\n * For AF_UNIX ports, hostName should be NULL and unixSocketDir must be\n * specified.  For TCP ports, hostName is either NULL for all interfaces or\n * the interface to listen on, and unixSocketDir is ignored (can be NULL).\n *\n * Successfully opened sockets are added to the ListenSocket[] array (of\n * length MaxListen), at the first position that isn't PGINVALID_SOCKET.\n *\n * RETURNS: STATUS_OK or STATUS_ERROR\n */\n\nint\nStreamServerPort(int family, const char *hostName, unsigned short portNumber,\n\t\t\t\t const char *unixSocketDir,\n\t\t\t\t pgsocket ListenSocket[], int MaxListen)\n{\n\tpgsocket\tfd;\n\tint\t\t\terr;\n\tint\t\t\tmaxconn;\n\tint\t\t\tret;\n\tchar\t\tportNumberStr[32];\n\tconst char *familyDesc;\n\tchar\t\tfamilyDescBuf[64];\n\tconst char *addrDesc;\n\tchar\t\taddrBuf[NI_MAXHOST];\n\tchar\t   *service;\n\tstruct addrinfo *addrs = NULL,\n\t\t\t   *addr;\n\tstruct addrinfo hint;\n\tint\t\t\tlisten_index = 0;\n\tint\t\t\tadded = 0;\n\n#ifdef HAVE_UNIX_SOCKETS\n\tchar\t\tunixSocketPath[MAXPGPATH];\n#endif\n#if !defined(WIN32) || defined(IPV6_V6ONLY)\n\tint\t\t\tone = 1;\n#endif\n\n\t/* Initialize hint structure */\n\tMemSet(&hint, 0, sizeof(hint));\n\thint.ai_family = family;\n\thint.ai_flags = AI_PASSIVE;\n\thint.ai_socktype = SOCK_STREAM;\n\n#ifdef HAVE_UNIX_SOCKETS\n\tif (family == AF_UNIX)\n\t{\n\t\t/*\n\t\t * Create unixSocketPath from portNumber and unixSocketDir and lock\n\t\t * that file path\n\t\t */\n\t\tUNIXSOCK_PATH(unixSocketPath, portNumber, unixSocketDir);\n\t\tif (strlen(unixSocketPath) >= UNIXSOCK_PATH_BUFLEN)\n\t\t{\n\t\t\tereport(LOG,\n\t\t\t\t\t(errmsg(\"Unix-domain socket path \\\"%s\\\" is too long (maximum %d bytes)\",\n\t\t\t\t\t\t\tunixSocketPath,\n\t\t\t\t\t\t\t(int) (UNIXSOCK_PATH_BUFLEN - 1))));\n\t\t\treturn STATUS_ERROR;\n\t\t}\n\t\tif (Lock_AF_UNIX(unixSocketDir, unixSocketPath) != STATUS_OK)\n\t\t\treturn STATUS_ERROR;\n\t\tservice = unixSocketPath;\n\t}\n\telse\n#endif\t\t\t\t\t\t\t/* HAVE_UNIX_SOCKETS */\n\t{\n\t\tsnprintf(portNumberStr, sizeof(portNumberStr), \"%d\", portNumber);\n\t\tservice = portNumberStr;\n\t}\n\n\tret = pg_getaddrinfo_all(hostName, service, &hint, &addrs);\n\tif (ret || !addrs)\n\t{\n\t\tif (hostName)\n\t\t\tereport(LOG,\n\t\t\t\t\t(errmsg(\"could not translate host name \\\"%s\\\", service \\\"%s\\\" to address: %s\",\n\t\t\t\t\t\t\thostName, service, gai_strerror(ret))));\n\t\telse\n\t\t\tereport(LOG,\n\t\t\t\t\t(errmsg(\"could not translate service \\\"%s\\\" to address: %s\",\n\t\t\t\t\t\t\tservice, gai_strerror(ret))));\n\t\tif (addrs)\n\t\t\tpg_freeaddrinfo_all(hint.ai_family, addrs);\n\t\treturn STATUS_ERROR;\n\t}\n\n\tfor (addr = addrs; addr; addr = addr->ai_next)\n\t{\n\t\tif (!IS_AF_UNIX(family) && IS_AF_UNIX(addr->ai_family))\n\t\t{\n\t\t\t/*\n\t\t\t * Only set up a unix domain socket when they really asked for it.\n\t\t\t * The service/port is different in that case.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* See if there is still room to add 1 more socket. */\n\t\tfor (; listen_index < MaxListen; listen_index++)\n\t\t{\n\t\t\tif (ListenSocket[listen_index] == PGINVALID_SOCKET)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (listen_index >= MaxListen)\n\t\t{\n\t\t\tereport(LOG,\n\t\t\t\t\t(errmsg(\"could not bind to all requested addresses: MAXLISTEN (%d) exceeded\",\n\t\t\t\t\t\t\tMaxListen)));\n\t\t\tbreak;\n\t\t}\n\n\t\t/* set up address family name for log messages */\n\t\tswitch (addr->ai_family)\n\t\t{\n\t\t\tcase AF_INET:\n\t\t\t\tfamilyDesc = _(\"IPv4\");\n\t\t\t\tbreak;\n#ifdef HAVE_IPV6\n\t\t\tcase AF_INET6:\n\t\t\t\tfamilyDesc = _(\"IPv6\");\n\t\t\t\tbreak;\n#endif\n#ifdef HAVE_UNIX_SOCKETS\n\t\t\tcase AF_UNIX:\n\t\t\t\tfamilyDesc = _(\"Unix\");\n\t\t\t\tbreak;\n#endif\n\t\t\tdefault:\n\t\t\t\tsnprintf(familyDescBuf, sizeof(familyDescBuf),\n\t\t\t\t\t\t _(\"unrecognized address family %d\"),\n\t\t\t\t\t\t addr->ai_family);\n\t\t\t\tfamilyDesc = familyDescBuf;\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* set up text form of address for log messages */\n#ifdef HAVE_UNIX_SOCKETS\n\t\tif (addr->ai_family == AF_UNIX)\n\t\t\taddrDesc = unixSocketPath;\n\t\telse\n#endif\n\t\t{\n\t\t\tpg_getnameinfo_all((const struct sockaddr_storage *) addr->ai_addr,\n\t\t\t\t\t\t\t   addr->ai_addrlen,\n\t\t\t\t\t\t\t   addrBuf, sizeof(addrBuf),\n\t\t\t\t\t\t\t   NULL, 0,\n\t\t\t\t\t\t\t   NI_NUMERICHOST);\n\t\t\taddrDesc = addrBuf;\n\t\t}\n\n\t\tif ((fd = socket(addr->ai_family, SOCK_STREAM, 0)) == PGINVALID_SOCKET)\n\t\t{\n\t\t\tereport(LOG,\n\t\t\t\t\t(errcode_for_socket_access(),\n\t\t\t/* translator: first %s is IPv4, IPv6, or Unix */\n\t\t\t\t\t errmsg(\"could not create %s socket for address \\\"%s\\\": %m\",\n\t\t\t\t\t\t\tfamilyDesc, addrDesc)));\n\t\t\tcontinue;\n\t\t}\n\n#ifndef WIN32\n\n\t\t/*\n\t\t * Without the SO_REUSEADDR flag, a new postmaster can't be started\n\t\t * right away after a stop or crash, giving \"address already in use\"\n\t\t * error on TCP ports.\n\t\t *\n\t\t * On win32, however, this behavior only happens if the\n\t\t * SO_EXCLUSIVEADDRUSE is set. With SO_REUSEADDR, win32 allows\n\t\t * multiple servers to listen on the same address, resulting in\n\t\t * unpredictable behavior. With no flags at all, win32 behaves as Unix\n\t\t * with SO_REUSEADDR.\n\t\t */\n\t\tif (!IS_AF_UNIX(addr->ai_family))\n\t\t{\n\t\t\tif ((setsockopt(fd, SOL_SOCKET, SO_REUSEADDR,\n\t\t\t\t\t\t\t(char *) &one, sizeof(one))) == -1)\n\t\t\t{\n\t\t\t\tereport(LOG,\n\t\t\t\t\t\t(errcode_for_socket_access(),\n\t\t\t\t/* translator: third %s is IPv4, IPv6, or Unix */\n\t\t\t\t\t\t errmsg(\"%s(%s) failed for %s address \\\"%s\\\": %m\",\n\t\t\t\t\t\t\t\t\"setsockopt\", \"SO_REUSEADDR\",\n\t\t\t\t\t\t\t\tfamilyDesc, addrDesc)));\n\t\t\t\tclosesocket(fd);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n#endif\n\n#ifdef IPV6_V6ONLY\n\t\tif (addr->ai_family == AF_INET6)\n\t\t{\n\t\t\tif (setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY,\n\t\t\t\t\t\t   (char *) &one, sizeof(one)) == -1)\n\t\t\t{\n\t\t\t\tereport(LOG,\n\t\t\t\t\t\t(errcode_for_socket_access(),\n\t\t\t\t/* translator: third %s is IPv4, IPv6, or Unix */\n\t\t\t\t\t\t errmsg(\"%s(%s) failed for %s address \\\"%s\\\": %m\",\n\t\t\t\t\t\t\t\t\"setsockopt\", \"IPV6_V6ONLY\",\n\t\t\t\t\t\t\t\tfamilyDesc, addrDesc)));\n\t\t\t\tclosesocket(fd);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n#endif\n\n\t\t/*\n\t\t * Note: This might fail on some OS's, like Linux older than\n\t\t * 2.4.21-pre3, that don't have the IPV6_V6ONLY socket option, and map\n\t\t * ipv4 addresses to ipv6.  It will show ::ffff:ipv4 for all ipv4\n\t\t * connections.\n\t\t */\n\t\terr = bind(fd, addr->ai_addr, addr->ai_addrlen);\n\t\tif (err < 0)\n\t\t{\n\t\t\tint\t\t\tsaved_errno = errno;\n\n\t\t\tereport(LOG,\n\t\t\t\t\t(errcode_for_socket_access(),\n\t\t\t/* translator: first %s is IPv4, IPv6, or Unix */\n\t\t\t\t\t errmsg(\"could not bind %s address \\\"%s\\\": %m\",\n\t\t\t\t\t\t\tfamilyDesc, addrDesc),\n\t\t\t\t\t saved_errno == EADDRINUSE ?\n\t\t\t\t\t (IS_AF_UNIX(addr->ai_family) ?\n\t\t\t\t\t  errhint(\"Is another postmaster already running on port %d?\",\n\t\t\t\t\t\t\t  (int) portNumber) :\n\t\t\t\t\t  errhint(\"Is another postmaster already running on port %d?\"\n\t\t\t\t\t\t\t  \" If not, wait a few seconds and retry.\",\n\t\t\t\t\t\t\t  (int) portNumber)) : 0));\n\t\t\tclosesocket(fd);\n\t\t\tcontinue;\n\t\t}\n\n#ifdef HAVE_UNIX_SOCKETS\n\t\tif (addr->ai_family == AF_UNIX)\n\t\t{\n\t\t\tif (Setup_AF_UNIX(service) != STATUS_OK)\n\t\t\t{\n\t\t\t\tclosesocket(fd);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n#endif\n\n\t\t/*\n\t\t * Select appropriate accept-queue length limit.  PG_SOMAXCONN is only\n\t\t * intended to provide a clamp on the request on platforms where an\n\t\t * overly large request provokes a kernel error (are there any?).\n\t\t */\n\t\tmaxconn = MaxBackends * 2;\n\t\tif (maxconn > PG_SOMAXCONN)\n\t\t\tmaxconn = PG_SOMAXCONN;\n\n\t\terr = listen(fd, maxconn);\n\t\tif (err < 0)\n\t\t{\n\t\t\tereport(LOG,\n\t\t\t\t\t(errcode_for_socket_access(),\n\t\t\t/* translator: first %s is IPv4, IPv6, or Unix */\n\t\t\t\t\t errmsg(\"could not listen on %s address \\\"%s\\\": %m\",\n\t\t\t\t\t\t\tfamilyDesc, addrDesc)));\n\t\t\tclosesocket(fd);\n\t\t\tcontinue;\n\t\t}\n\n#ifdef HAVE_UNIX_SOCKETS\n\t\tif (addr->ai_family == AF_UNIX)\n\t\t\tereport(LOG,\n\t\t\t\t\t(errmsg(\"listening on Unix socket \\\"%s\\\"\",\n\t\t\t\t\t\t\taddrDesc)));\n\t\telse\n#endif\n\t\t\tereport(LOG,\n\t\t\t/* translator: first %s is IPv4 or IPv6 */\n\t\t\t\t\t(errmsg(\"listening on %s address \\\"%s\\\", port %d\",\n\t\t\t\t\t\t\tfamilyDesc, addrDesc, (int) portNumber)));\n\n\t\tListenSocket[listen_index] = fd;\n\t\tadded++;\n\t}\n\n\tpg_freeaddrinfo_all(hint.ai_family, addrs);\n\n\tif (!added)\n\t\treturn STATUS_ERROR;\n\n\treturn STATUS_OK;\n}\n\n\n#ifdef HAVE_UNIX_SOCKETS\n\n/*\n * Lock_AF_UNIX -- configure unix socket file path\n */\nstatic int\nLock_AF_UNIX(const char *unixSocketDir, const char *unixSocketPath)\n{\n\t/* no lock file for abstract sockets */\n\tif (unixSocketPath[0] == '@')\n\t\treturn STATUS_OK;\n\n\t/*\n\t * Grab an interlock file associated with the socket file.\n\t *\n\t * Note: there are two reasons for using a socket lock file, rather than\n\t * trying to interlock directly on the socket itself.  First, it's a lot\n\t * more portable, and second, it lets us remove any pre-existing socket\n\t * file without race conditions.\n\t */\n\tCreateSocketLockFile(unixSocketPath, true, unixSocketDir);\n\n\t/*\n\t * Once we have the interlock, we can safely delete any pre-existing\n\t * socket file to avoid failure at bind() time.\n\t */\n\t(void) unlink(unixSocketPath);\n\n\t/*\n\t * Remember socket file pathnames for later maintenance.\n\t */\n\tsock_paths = lappend(sock_paths, pstrdup(unixSocketPath));\n\n\treturn STATUS_OK;\n}\n\n\n/*\n * Setup_AF_UNIX -- configure unix socket permissions\n */\nstatic int\nSetup_AF_UNIX(const char *sock_path)\n{\n\t/* no file system permissions for abstract sockets */\n\tif (sock_path[0] == '@')\n\t\treturn STATUS_OK;\n\n\t/*\n\t * Fix socket ownership/permission if requested.  Note we must do this\n\t * before we listen() to avoid a window where unwanted connections could\n\t * get accepted.\n\t */\n\tAssert(Unix_socket_group);\n\tif (Unix_socket_group[0] != '\\0')\n\t{\n#ifdef WIN32\n\t\telog(WARNING, \"configuration item unix_socket_group is not supported on this platform\");\n#else\n\t\tchar\t   *endptr;\n\t\tunsigned long val;\n\t\tgid_t\t\tgid;\n\n\t\tval = strtoul(Unix_socket_group, &endptr, 10);\n\t\tif (*endptr == '\\0')\n\t\t{\t\t\t\t\t\t/* numeric group id */\n\t\t\tgid = val;\n\t\t}\n\t\telse\n\t\t{\t\t\t\t\t\t/* convert group name to id */\n\t\t\tstruct group *gr;\n\n\t\t\tgr = getgrnam(Unix_socket_group);\n\t\t\tif (!gr)\n\t\t\t{\n\t\t\t\tereport(LOG,\n\t\t\t\t\t\t(errmsg(\"group \\\"%s\\\" does not exist\",\n\t\t\t\t\t\t\t\tUnix_socket_group)));\n\t\t\t\treturn STATUS_ERROR;\n\t\t\t}\n\t\t\tgid = gr->gr_gid;\n\t\t}\n\t\tif (chown(sock_path, -1, gid) == -1)\n\t\t{\n\t\t\tereport(LOG,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not set group of file \\\"%s\\\": %m\",\n\t\t\t\t\t\t\tsock_path)));\n\t\t\treturn STATUS_ERROR;\n\t\t}\n#endif\n\t}\n\n\tif (chmod(sock_path, Unix_socket_permissions) == -1)\n\t{\n\t\tereport(LOG,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not set permissions of file \\\"%s\\\": %m\",\n\t\t\t\t\t\tsock_path)));\n\t\treturn STATUS_ERROR;\n\t}\n\treturn STATUS_OK;\n}\n#endif\t\t\t\t\t\t\t/* HAVE_UNIX_SOCKETS */\n\n\n/*\n * StreamConnection -- create a new connection with client using\n *\t\tserver port.  Set port->sock to the FD of the new connection.\n *\n * ASSUME: that this doesn't need to be non-blocking because\n *\t\tthe Postmaster uses select() to tell when the socket is ready for\n *\t\taccept().\n *\n * RETURNS: STATUS_OK or STATUS_ERROR\n */\nint\nStreamConnection(pgsocket server_fd, Port *port)\n{\n\t/* accept connection and fill in the client (remote) address */\n\tport->raddr.salen = sizeof(port->raddr.addr);\n\tif ((port->sock = accept(server_fd,\n\t\t\t\t\t\t\t (struct sockaddr *) &port->raddr.addr,\n\t\t\t\t\t\t\t &port->raddr.salen)) == PGINVALID_SOCKET)\n\t{\n\t\tereport(LOG,\n\t\t\t\t(errcode_for_socket_access(),\n\t\t\t\t errmsg(\"could not accept new connection: %m\")));\n\n\t\t/*\n\t\t * If accept() fails then postmaster.c will still see the server\n\t\t * socket as read-ready, and will immediately try again.  To avoid\n\t\t * uselessly sucking lots of CPU, delay a bit before trying again.\n\t\t * (The most likely reason for failure is being out of kernel file\n\t\t * table slots; we can do little except hope some will get freed up.)\n\t\t */\n\t\tpg_usleep(100000L);\t\t/* wait 0.1 sec */\n\t\treturn STATUS_ERROR;\n\t}\n\n\t/* fill in the server (local) address */\n\tport->laddr.salen = sizeof(port->laddr.addr);\n\tif (getsockname(port->sock,\n\t\t\t\t\t(struct sockaddr *) &port->laddr.addr,\n\t\t\t\t\t&port->laddr.salen) < 0)\n\t{\n\t\tereport(LOG,\n\t\t\t\t(errmsg(\"%s() failed: %m\", \"getsockname\")));\n\t\treturn STATUS_ERROR;\n\t}\n\n\t/* select NODELAY and KEEPALIVE options if it's a TCP connection */\n\tif (!IS_AF_UNIX(port->laddr.addr.ss_family))\n\t{\n\t\tint\t\t\ton;\n#ifdef WIN32\n\t\tint\t\t\toldopt;\n\t\tint\t\t\toptlen;\n\t\tint\t\t\tnewopt;\n#endif\n\n#ifdef\tTCP_NODELAY\n\t\ton = 1;\n\t\tif (setsockopt(port->sock, IPPROTO_TCP, TCP_NODELAY,\n\t\t\t\t\t   (char *) &on, sizeof(on)) < 0)\n\t\t{\n\t\t\tereport(LOG,\n\t\t\t\t\t(errmsg(\"%s(%s) failed: %m\", \"setsockopt\", \"TCP_NODELAY\")));\n\t\t\treturn STATUS_ERROR;\n\t\t}\n#endif\n\t\ton = 1;\n\t\tif (setsockopt(port->sock, SOL_SOCKET, SO_KEEPALIVE,\n\t\t\t\t\t   (char *) &on, sizeof(on)) < 0)\n\t\t{\n\t\t\tereport(LOG,\n\t\t\t\t\t(errmsg(\"%s(%s) failed: %m\", \"setsockopt\", \"SO_KEEPALIVE\")));\n\t\t\treturn STATUS_ERROR;\n\t\t}\n\n#ifdef WIN32\n\n\t\t/*\n\t\t * This is a Win32 socket optimization.  The OS send buffer should be\n\t\t * large enough to send the whole Postgres send buffer in one go, or\n\t\t * performance suffers.  The Postgres send buffer can be enlarged if a\n\t\t * very large message needs to be sent, but we won't attempt to\n\t\t * enlarge the OS buffer if that happens, so somewhat arbitrarily\n\t\t * ensure that the OS buffer is at least PQ_SEND_BUFFER_SIZE * 4.\n\t\t * (That's 32kB with the current default).\n\t\t *\n\t\t * The default OS buffer size used to be 8kB in earlier Windows\n\t\t * versions, but was raised to 64kB in Windows 2012.  So it shouldn't\n\t\t * be necessary to change it in later versions anymore.  Changing it\n\t\t * unnecessarily can even reduce performance, because setting\n\t\t * SO_SNDBUF in the application disables the \"dynamic send buffering\"\n\t\t * feature that was introduced in Windows 7.  So before fiddling with\n\t\t * SO_SNDBUF, check if the current buffer size is already large enough\n\t\t * and only increase it if necessary.\n\t\t *\n\t\t * See https://support.microsoft.com/kb/823764/EN-US/ and\n\t\t * https://msdn.microsoft.com/en-us/library/bb736549%28v=vs.85%29.aspx\n\t\t */\n\t\toptlen = sizeof(oldopt);\n\t\tif (getsockopt(port->sock, SOL_SOCKET, SO_SNDBUF, (char *) &oldopt,\n\t\t\t\t\t   &optlen) < 0)\n\t\t{\n\t\t\tereport(LOG,\n\t\t\t\t\t(errmsg(\"%s(%s) failed: %m\", \"getsockopt\", \"SO_SNDBUF\")));\n\t\t\treturn STATUS_ERROR;\n\t\t}\n\t\tnewopt = PQ_SEND_BUFFER_SIZE * 4;\n\t\tif (oldopt < newopt)\n\t\t{\n\t\t\tif (setsockopt(port->sock, SOL_SOCKET, SO_SNDBUF, (char *) &newopt,\n\t\t\t\t\t\t   sizeof(newopt)) < 0)\n\t\t\t{\n\t\t\t\tereport(LOG,\n\t\t\t\t\t\t(errmsg(\"%s(%s) failed: %m\", \"setsockopt\", \"SO_SNDBUF\")));\n\t\t\t\treturn STATUS_ERROR;\n\t\t\t}\n\t\t}\n#endif\n\n\t\t/*\n\t\t * Also apply the current keepalive parameters.  If we fail to set a\n\t\t * parameter, don't error out, because these aren't universally\n\t\t * supported.  (Note: you might think we need to reset the GUC\n\t\t * variables to 0 in such a case, but it's not necessary because the\n\t\t * show hooks for these variables report the truth anyway.)\n\t\t */\n\t\t(void) pq_setkeepalivesidle(tcp_keepalives_idle, port);\n\t\t(void) pq_setkeepalivesinterval(tcp_keepalives_interval, port);\n\t\t(void) pq_setkeepalivescount(tcp_keepalives_count, port);\n\t\t(void) pq_settcpusertimeout(tcp_user_timeout, port);\n\t}\n\n\treturn STATUS_OK;\n}\n\n/*\n * StreamClose -- close a client/backend connection\n *\n * NOTE: this is NOT used to terminate a session; it is just used to release\n * the file descriptor in a process that should no longer have the socket\n * open.  (For example, the postmaster calls this after passing ownership\n * of the connection to a child process.)  It is expected that someone else\n * still has the socket open.  So, we only want to close the descriptor,\n * we do NOT want to send anything to the far end.\n */\nvoid\nStreamClose(pgsocket sock)\n{\n\tclosesocket(sock);\n}\n\n/*\n * TouchSocketFiles -- mark socket files as recently accessed\n *\n * This routine should be called every so often to ensure that the socket\n * files have a recent mod date (ordinary operations on sockets usually won't\n * change the mod date).  That saves them from being removed by\n * overenthusiastic /tmp-directory-cleaner daemons.  (Another reason we should\n * never have put the socket file in /tmp...)\n */\nvoid\nTouchSocketFiles(void)\n{\n\tListCell   *l;\n\n\t/* Loop through all created sockets... */\n\tforeach(l, sock_paths)\n\t{\n\t\tchar\t   *sock_path = (char *) lfirst(l);\n\n\t\t/* Ignore errors; there's no point in complaining */\n\t\t(void) utime(sock_path, NULL);\n\t}\n}\n\n/*\n * RemoveSocketFiles -- unlink socket files at postmaster shutdown\n */\nvoid\nRemoveSocketFiles(void)\n{\n\tListCell   *l;\n\n\t/* Loop through all created sockets... */\n\tforeach(l, sock_paths)\n\t{\n\t\tchar\t   *sock_path = (char *) lfirst(l);\n\n\t\t/* Ignore any error. */\n\t\t(void) unlink(sock_path);\n\t}\n\t/* Since we're about to exit, no need to reclaim storage */\n\tsock_paths = NIL;\n}\n\n\n/* --------------------------------\n * Low-level I/O routines begin here.\n *\n * These routines communicate with a frontend client across a connection\n * already established by the preceding routines.\n * --------------------------------\n */\n\n/* --------------------------------\n *\t\t\t  socket_set_nonblocking - set socket blocking/non-blocking\n *\n * Sets the socket non-blocking if nonblocking is true, or sets it\n * blocking otherwise.\n * --------------------------------\n */\nstatic void\nsocket_set_nonblocking(bool nonblocking)\n{\n\tif (MyProcPort == NULL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_CONNECTION_DOES_NOT_EXIST),\n\t\t\t\t errmsg(\"there is no client connection\")));\n\n\tMyProcPort->noblock = nonblocking;\n}\n\n/* --------------------------------\n *\t\tpq_recvbuf - load some bytes into the input buffer\n *\n *\t\treturns 0 if OK, EOF if trouble\n * --------------------------------\n */\nstatic int\npq_recvbuf(void)\n{\n\tif (PqRecvPointer > 0)\n\t{\n\t\tif (PqRecvLength > PqRecvPointer)\n\t\t{\n\t\t\t/* still some unread data, left-justify it in the buffer */\n\t\t\tmemmove(PqRecvBuffer, PqRecvBuffer + PqRecvPointer,\n\t\t\t\t\tPqRecvLength - PqRecvPointer);\n\t\t\tPqRecvLength -= PqRecvPointer;\n\t\t\tPqRecvPointer = 0;\n\t\t}\n\t\telse\n\t\t\tPqRecvLength = PqRecvPointer = 0;\n\t}\n\n\t/* Ensure that we're in blocking mode */\n\tsocket_set_nonblocking(false);\n\n\t/* Can fill buffer from PqRecvLength and upwards */\n\tfor (;;)\n\t{\n\t\tint\t\t\tr;\n\n\t\tr = secure_read(MyProcPort, PqRecvBuffer + PqRecvLength,\n\t\t\t\t\t\tPQ_RECV_BUFFER_SIZE - PqRecvLength);\n\n\t\tif (r < 0)\n\t\t{\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\t\t/* Ok if interrupted */\n\n\t\t\t/*\n\t\t\t * Careful: an ereport() that tries to write to the client would\n\t\t\t * cause recursion to here, leading to stack overflow and core\n\t\t\t * dump!  This message must go *only* to the postmaster log.\n\t\t\t */\n\t\t\tereport(COMMERROR,\n\t\t\t\t\t(errcode_for_socket_access(),\n\t\t\t\t\t errmsg(\"could not receive data from client: %m\")));\n\t\t\treturn EOF;\n\t\t}\n\t\tif (r == 0)\n\t\t{\n\t\t\t/*\n\t\t\t * EOF detected.  We used to write a log message here, but it's\n\t\t\t * better to expect the ultimate caller to do that.\n\t\t\t */\n\t\t\treturn EOF;\n\t\t}\n\t\t/* r contains number of bytes read, so just incr length */\n\t\tPqRecvLength += r;\n\t\treturn 0;\n\t}\n}\n\n/* --------------------------------\n *\t\tpq_getbyte\t- get a single byte from connection, or return EOF\n * --------------------------------\n */\nint\npq_getbyte(void)\n{\n\tAssert(PqCommReadingMsg);\n\n\twhile (PqRecvPointer >= PqRecvLength)\n\t{\n\t\tif (pq_recvbuf())\t\t/* If nothing in buffer, then recv some */\n\t\t\treturn EOF;\t\t\t/* Failed to recv data */\n\t}\n\treturn (unsigned char) PqRecvBuffer[PqRecvPointer++];\n}\n\n/* --------------------------------\n *\t\tpq_peekbyte\t\t- peek at next byte from connection\n *\n *\t Same as pq_getbyte() except we don't advance the pointer.\n * --------------------------------\n */\nint\npq_peekbyte(void)\n{\n\tAssert(PqCommReadingMsg);\n\n\twhile (PqRecvPointer >= PqRecvLength)\n\t{\n\t\tif (pq_recvbuf())\t\t/* If nothing in buffer, then recv some */\n\t\t\treturn EOF;\t\t\t/* Failed to recv data */\n\t}\n\treturn (unsigned char) PqRecvBuffer[PqRecvPointer];\n}\n\n/* --------------------------------\n *\t\tpq_getbyte_if_available - get a single byte from connection,\n *\t\t\tif available\n *\n * The received byte is stored in *c. Returns 1 if a byte was read,\n * 0 if no data was available, or EOF if trouble.\n * --------------------------------\n */\nint\npq_getbyte_if_available(unsigned char *c)\n{\n\tint\t\t\tr;\n\n\tAssert(PqCommReadingMsg);\n\n\tif (PqRecvPointer < PqRecvLength)\n\t{\n\t\t*c = PqRecvBuffer[PqRecvPointer++];\n\t\treturn 1;\n\t}\n\n\t/* Put the socket into non-blocking mode */\n\tsocket_set_nonblocking(true);\n\n\tr = secure_read(MyProcPort, c, 1);\n\tif (r < 0)\n\t{\n\t\t/*\n\t\t * Ok if no data available without blocking or interrupted (though\n\t\t * EINTR really shouldn't happen with a non-blocking socket). Report\n\t\t * other errors.\n\t\t */\n\t\tif (errno == EAGAIN || errno == EWOULDBLOCK || errno == EINTR)\n\t\t\tr = 0;\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Careful: an ereport() that tries to write to the client would\n\t\t\t * cause recursion to here, leading to stack overflow and core\n\t\t\t * dump!  This message must go *only* to the postmaster log.\n\t\t\t */\n\t\t\tereport(COMMERROR,\n\t\t\t\t\t(errcode_for_socket_access(),\n\t\t\t\t\t errmsg(\"could not receive data from client: %m\")));\n\t\t\tr = EOF;\n\t\t}\n\t}\n\telse if (r == 0)\n\t{\n\t\t/* EOF detected */\n\t\tr = EOF;\n\t}\n\n\treturn r;\n}\n\n/* --------------------------------\n *\t\tpq_getbytes\t\t- get a known number of bytes from connection\n *\n *\t\treturns 0 if OK, EOF if trouble\n * --------------------------------\n */\nint\npq_getbytes(char *s, size_t len)\n{\n\tsize_t\t\tamount;\n\n\tAssert(PqCommReadingMsg);\n\n\twhile (len > 0)\n\t{\n\t\twhile (PqRecvPointer >= PqRecvLength)\n\t\t{\n\t\t\tif (pq_recvbuf())\t/* If nothing in buffer, then recv some */\n\t\t\t\treturn EOF;\t\t/* Failed to recv data */\n\t\t}\n\t\tamount = PqRecvLength - PqRecvPointer;\n\t\tif (amount > len)\n\t\t\tamount = len;\n\t\tmemcpy(s, PqRecvBuffer + PqRecvPointer, amount);\n\t\tPqRecvPointer += amount;\n\t\ts += amount;\n\t\tlen -= amount;\n\t}\n\treturn 0;\n}\n\n/* --------------------------------\n *\t\tpq_discardbytes\t\t- throw away a known number of bytes\n *\n *\t\tsame as pq_getbytes except we do not copy the data to anyplace.\n *\t\tthis is used for resynchronizing after read errors.\n *\n *\t\treturns 0 if OK, EOF if trouble\n * --------------------------------\n */\nstatic int\npq_discardbytes(size_t len)\n{\n\tsize_t\t\tamount;\n\n\tAssert(PqCommReadingMsg);\n\n\twhile (len > 0)\n\t{\n\t\twhile (PqRecvPointer >= PqRecvLength)\n\t\t{\n\t\t\tif (pq_recvbuf())\t/* If nothing in buffer, then recv some */\n\t\t\t\treturn EOF;\t\t/* Failed to recv data */\n\t\t}\n\t\tamount = PqRecvLength - PqRecvPointer;\n\t\tif (amount > len)\n\t\t\tamount = len;\n\t\tPqRecvPointer += amount;\n\t\tlen -= amount;\n\t}\n\treturn 0;\n}\n\n\n/* --------------------------------\n *\t\tpq_startmsgread - begin reading a message from the client.\n *\n *\t\tThis must be called before any of the pq_get* functions.\n * --------------------------------\n */\nvoid\npq_startmsgread(void)\n{\n\t/*\n\t * There shouldn't be a read active already, but let's check just to be\n\t * sure.\n\t */\n\tif (PqCommReadingMsg)\n\t\tereport(FATAL,\n\t\t\t\t(errcode(ERRCODE_PROTOCOL_VIOLATION),\n\t\t\t\t errmsg(\"terminating connection because protocol synchronization was lost\")));\n\n\tPqCommReadingMsg = true;\n}\n\n\n/* --------------------------------\n *\t\tpq_endmsgread\t- finish reading message.\n *\n *\t\tThis must be called after reading a message with pq_getbytes()\n *\t\tand friends, to indicate that we have read the whole message.\n *\t\tpq_getmessage() does this implicitly.\n * --------------------------------\n */\nvoid\npq_endmsgread(void)\n{\n\tAssert(PqCommReadingMsg);\n\n\tPqCommReadingMsg = false;\n}\n\n/* --------------------------------\n *\t\tpq_is_reading_msg - are we currently reading a message?\n *\n * This is used in error recovery at the outer idle loop to detect if we have\n * lost protocol sync, and need to terminate the connection. pq_startmsgread()\n * will check for that too, but it's nicer to detect it earlier.\n * --------------------------------\n */\nbool\npq_is_reading_msg(void)\n{\n\treturn PqCommReadingMsg;\n}\n\n/* --------------------------------\n *\t\tpq_getmessage\t- get a message with length word from connection\n *\n *\t\tThe return value is placed in an expansible StringInfo, which has\n *\t\talready been initialized by the caller.\n *\t\tOnly the message body is placed in the StringInfo; the length word\n *\t\tis removed.  Also, s->cursor is initialized to zero for convenience\n *\t\tin scanning the message contents.\n *\n *\t\tmaxlen is the upper limit on the length of the\n *\t\tmessage we are willing to accept.  We abort the connection (by\n *\t\treturning EOF) if client tries to send more than that.\n *\n *\t\treturns 0 if OK, EOF if trouble\n * --------------------------------\n */\nint\npq_getmessage(StringInfo s, int maxlen)\n{\n\tint32\t\tlen;\n\n\tAssert(PqCommReadingMsg);\n\n\tresetStringInfo(s);\n\n\t/* Read message length word */\n\tif (pq_getbytes((char *) &len, 4) == EOF)\n\t{\n\t\tereport(COMMERROR,\n\t\t\t\t(errcode(ERRCODE_PROTOCOL_VIOLATION),\n\t\t\t\t errmsg(\"unexpected EOF within message length word\")));\n\t\treturn EOF;\n\t}\n\n\tlen = pg_ntoh32(len);\n\n\tif (len < 4 || len > maxlen)\n\t{\n\t\tereport(COMMERROR,\n\t\t\t\t(errcode(ERRCODE_PROTOCOL_VIOLATION),\n\t\t\t\t errmsg(\"invalid message length\")));\n\t\treturn EOF;\n\t}\n\n\tlen -= 4;\t\t\t\t\t/* discount length itself */\n\n\tif (len > 0)\n\t{\n\t\t/*\n\t\t * Allocate space for message.  If we run out of room (ridiculously\n\t\t * large message), we will elog(ERROR), but we want to discard the\n\t\t * message body so as not to lose communication sync.\n\t\t */\n\t\tPG_TRY();\n\t\t{\n\t\t\tenlargeStringInfo(s, len);\n\t\t}\n\t\tPG_CATCH();\n\t\t{\n\t\t\tif (pq_discardbytes(len) == EOF)\n\t\t\t\tereport(COMMERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_PROTOCOL_VIOLATION),\n\t\t\t\t\t\t errmsg(\"incomplete message from client\")));\n\n\t\t\t/* we discarded the rest of the message so we're back in sync. */\n\t\t\tPqCommReadingMsg = false;\n\t\t\tPG_RE_THROW();\n\t\t}\n\t\tPG_END_TRY();\n\n\t\t/* And grab the message */\n\t\tif (pq_getbytes(s->data, len) == EOF)\n\t\t{\n\t\t\tereport(COMMERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROTOCOL_VIOLATION),\n\t\t\t\t\t errmsg(\"incomplete message from client\")));\n\t\t\treturn EOF;\n\t\t}\n\t\ts->len = len;\n\t\t/* Place a trailing null per StringInfo convention */\n\t\ts->data[len] = '\\0';\n\t}\n\n\t/* finished reading the message. */\n\tPqCommReadingMsg = false;\n\n\treturn 0;\n}\n\n\nstatic int\ninternal_putbytes(const char *s, size_t len)\n{\n\tsize_t\t\tamount;\n\n\twhile (len > 0)\n\t{\n\t\t/* If buffer is full, then flush it out */\n\t\tif (PqSendPointer >= PqSendBufferSize)\n\t\t{\n\t\t\tsocket_set_nonblocking(false);\n\t\t\tif (internal_flush())\n\t\t\t\treturn EOF;\n\t\t}\n\t\tamount = PqSendBufferSize - PqSendPointer;\n\t\tif (amount > len)\n\t\t\tamount = len;\n\t\tmemcpy(PqSendBuffer + PqSendPointer, s, amount);\n\t\tPqSendPointer += amount;\n\t\ts += amount;\n\t\tlen -= amount;\n\t}\n\treturn 0;\n}\n\n/* --------------------------------\n *\t\tsocket_flush\t\t- flush pending output\n *\n *\t\treturns 0 if OK, EOF if trouble\n * --------------------------------\n */\nstatic int\nsocket_flush(void)\n{\n\tint\t\t\tres;\n\n\t/* No-op if reentrant call */\n\tif (PqCommBusy)\n\t\treturn 0;\n\tPqCommBusy = true;\n\tsocket_set_nonblocking(false);\n\tres = internal_flush();\n\tPqCommBusy = false;\n\treturn res;\n}\n\n/* --------------------------------\n *\t\tinternal_flush - flush pending output\n *\n * Returns 0 if OK (meaning everything was sent, or operation would block\n * and the socket is in non-blocking mode), or EOF if trouble.\n * --------------------------------\n */\nstatic int\ninternal_flush(void)\n{\n\tstatic int\tlast_reported_send_errno = 0;\n\n\tchar\t   *bufptr = PqSendBuffer + PqSendStart;\n\tchar\t   *bufend = PqSendBuffer + PqSendPointer;\n\n\twhile (bufptr < bufend)\n\t{\n\t\tint\t\t\tr;\n\n\t\tr = secure_write(MyProcPort, bufptr, bufend - bufptr);\n\n\t\tif (r <= 0)\n\t\t{\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\t\t/* Ok if we were interrupted */\n\n\t\t\t/*\n\t\t\t * Ok if no data writable without blocking, and the socket is in\n\t\t\t * non-blocking mode.\n\t\t\t */\n\t\t\tif (errno == EAGAIN ||\n\t\t\t\terrno == EWOULDBLOCK)\n\t\t\t{\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Careful: an ereport() that tries to write to the client would\n\t\t\t * cause recursion to here, leading to stack overflow and core\n\t\t\t * dump!  This message must go *only* to the postmaster log.\n\t\t\t *\n\t\t\t * If a client disconnects while we're in the midst of output, we\n\t\t\t * might write quite a bit of data before we get to a safe query\n\t\t\t * abort point.  So, suppress duplicate log messages.\n\t\t\t */\n\t\t\tif (errno != last_reported_send_errno)\n\t\t\t{\n\t\t\t\tlast_reported_send_errno = errno;\n\t\t\t\tereport(COMMERROR,\n\t\t\t\t\t\t(errcode_for_socket_access(),\n\t\t\t\t\t\t errmsg(\"could not send data to client: %m\")));\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We drop the buffered data anyway so that processing can\n\t\t\t * continue, even though we'll probably quit soon. We also set a\n\t\t\t * flag that'll cause the next CHECK_FOR_INTERRUPTS to terminate\n\t\t\t * the connection.\n\t\t\t */\n\t\t\tPqSendStart = PqSendPointer = 0;\n\t\t\tClientConnectionLost = 1;\n\t\t\tInterruptPending = 1;\n\t\t\treturn EOF;\n\t\t}\n\n\t\tlast_reported_send_errno = 0;\t/* reset after any successful send */\n\t\tbufptr += r;\n\t\tPqSendStart += r;\n\t}\n\n\tPqSendStart = PqSendPointer = 0;\n\treturn 0;\n}\n\n/* --------------------------------\n *\t\tpq_flush_if_writable - flush pending output if writable without blocking\n *\n * Returns 0 if OK, or EOF if trouble.\n * --------------------------------\n */\nstatic int\nsocket_flush_if_writable(void)\n{\n\tint\t\t\tres;\n\n\t/* Quick exit if nothing to do */\n\tif (PqSendPointer == PqSendStart)\n\t\treturn 0;\n\n\t/* No-op if reentrant call */\n\tif (PqCommBusy)\n\t\treturn 0;\n\n\t/* Temporarily put the socket into non-blocking mode */\n\tsocket_set_nonblocking(true);\n\n\tPqCommBusy = true;\n\tres = internal_flush();\n\tPqCommBusy = false;\n\treturn res;\n}\n\n/* --------------------------------\n *\tsocket_is_send_pending\t- is there any pending data in the output buffer?\n * --------------------------------\n */\nstatic bool\nsocket_is_send_pending(void)\n{\n\treturn (PqSendStart < PqSendPointer);\n}\n\n/* --------------------------------\n * Message-level I/O routines begin here.\n * --------------------------------\n */\n\n\n/* --------------------------------\n *\t\tsocket_putmessage - send a normal message (suppressed in COPY OUT mode)\n *\n *\t\tmsgtype is a message type code to place before the message body.\n *\n *\t\tlen is the length of the message body data at *s.  A message length\n *\t\tword (equal to len+4 because it counts itself too) is inserted by this\n *\t\troutine.\n *\n *\t\tWe suppress messages generated while pqcomm.c is busy.  This\n *\t\tavoids any possibility of messages being inserted within other\n *\t\tmessages.  The only known trouble case arises if SIGQUIT occurs\n *\t\tduring a pqcomm.c routine --- quickdie() will try to send a warning\n *\t\tmessage, and the most reasonable approach seems to be to drop it.\n *\n *\t\treturns 0 if OK, EOF if trouble\n * --------------------------------\n */\nstatic int\nsocket_putmessage(char msgtype, const char *s, size_t len)\n{\n\tuint32\t\tn32;\n\n\tAssert(msgtype != 0);\n\n\tif (PqCommBusy)\n\t\treturn 0;\n\tPqCommBusy = true;\n\tif (internal_putbytes(&msgtype, 1))\n\t\tgoto fail;\n\n\tn32 = pg_hton32((uint32) (len + 4));\n\tif (internal_putbytes((char *) &n32, 4))\n\t\tgoto fail;\n\n\tif (internal_putbytes(s, len))\n\t\tgoto fail;\n\tPqCommBusy = false;\n\treturn 0;\n\nfail:\n\tPqCommBusy = false;\n\treturn EOF;\n}\n\n/* --------------------------------\n *\t\tpq_putmessage_noblock\t- like pq_putmessage, but never blocks\n *\n *\t\tIf the output buffer is too small to hold the message, the buffer\n *\t\tis enlarged.\n */\nstatic void\nsocket_putmessage_noblock(char msgtype, const char *s, size_t len)\n{\n\tint\t\t\tres PG_USED_FOR_ASSERTS_ONLY;\n\tint\t\t\trequired;\n\n\t/*\n\t * Ensure we have enough space in the output buffer for the message header\n\t * as well as the message itself.\n\t */\n\trequired = PqSendPointer + 1 + 4 + len;\n\tif (required > PqSendBufferSize)\n\t{\n\t\tPqSendBuffer = repalloc(PqSendBuffer, required);\n\t\tPqSendBufferSize = required;\n\t}\n\tres = pq_putmessage(msgtype, s, len);\n\tAssert(res == 0);\t\t\t/* should not fail when the message fits in\n\t\t\t\t\t\t\t\t * buffer */\n}\n\n/* --------------------------------\n *\t\tpq_putmessage_v2 - send a message in protocol version 2\n *\n *\t\tmsgtype is a message type code to place before the message body.\n *\n *\t\tWe no longer support protocol version 2, but we have kept this\n *\t\tfunction so that if a client tries to connect with protocol version 2,\n *\t\tas a courtesy we can still send the \"unsupported protocol version\"\n *\t\terror to the client in the old format.\n *\n *\t\tLike in pq_putmessage(), we suppress messages generated while\n *\t\tpqcomm.c is busy.\n *\n *\t\treturns 0 if OK, EOF if trouble\n * --------------------------------\n */\nint\npq_putmessage_v2(char msgtype, const char *s, size_t len)\n{\n\tAssert(msgtype != 0);\n\n\tif (PqCommBusy)\n\t\treturn 0;\n\tPqCommBusy = true;\n\tif (internal_putbytes(&msgtype, 1))\n\t\tgoto fail;\n\n\tif (internal_putbytes(s, len))\n\t\tgoto fail;\n\tPqCommBusy = false;\n\treturn 0;\n\nfail:\n\tPqCommBusy = false;\n\treturn EOF;\n}\n\n/*\n * Support for TCP Keepalive parameters\n */\n\n/*\n * On Windows, we need to set both idle and interval at the same time.\n * We also cannot reset them to the default (setting to zero will\n * actually set them to zero, not default), therefore we fallback to\n * the out-of-the-box default instead.\n */\n#if defined(WIN32) && defined(SIO_KEEPALIVE_VALS)\nstatic int\npq_setkeepaliveswin32(Port *port, int idle, int interval)\n{\n\tstruct tcp_keepalive ka;\n\tDWORD\t\tretsize;\n\n\tif (idle <= 0)\n\t\tidle = 2 * 60 * 60;\t\t/* default = 2 hours */\n\tif (interval <= 0)\n\t\tinterval = 1;\t\t\t/* default = 1 second */\n\n\tka.onoff = 1;\n\tka.keepalivetime = idle * 1000;\n\tka.keepaliveinterval = interval * 1000;\n\n\tif (WSAIoctl(port->sock,\n\t\t\t\t SIO_KEEPALIVE_VALS,\n\t\t\t\t (LPVOID) &ka,\n\t\t\t\t sizeof(ka),\n\t\t\t\t NULL,\n\t\t\t\t 0,\n\t\t\t\t &retsize,\n\t\t\t\t NULL,\n\t\t\t\t NULL)\n\t\t!= 0)\n\t{\n\t\tereport(LOG,\n\t\t\t\t(errmsg(\"%s(%s) failed: error code %d\",\n\t\t\t\t\t\t\"WSAIoctl\", \"SIO_KEEPALIVE_VALS\", WSAGetLastError())));\n\t\treturn STATUS_ERROR;\n\t}\n\tif (port->keepalives_idle != idle)\n\t\tport->keepalives_idle = idle;\n\tif (port->keepalives_interval != interval)\n\t\tport->keepalives_interval = interval;\n\treturn STATUS_OK;\n}\n#endif\n\nint\npq_getkeepalivesidle(Port *port)\n{\n#if defined(PG_TCP_KEEPALIVE_IDLE) || defined(SIO_KEEPALIVE_VALS)\n\tif (port == NULL || IS_AF_UNIX(port->laddr.addr.ss_family))\n\t\treturn 0;\n\n\tif (port->keepalives_idle != 0)\n\t\treturn port->keepalives_idle;\n\n\tif (port->default_keepalives_idle == 0)\n\t{\n#ifndef WIN32\n\t\tACCEPT_TYPE_ARG3 size = sizeof(port->default_keepalives_idle);\n\n\t\tif (getsockopt(port->sock, IPPROTO_TCP, PG_TCP_KEEPALIVE_IDLE,\n\t\t\t\t\t   (char *) &port->default_keepalives_idle,\n\t\t\t\t\t   &size) < 0)\n\t\t{\n\t\t\tereport(LOG,\n\t\t\t\t\t(errmsg(\"%s(%s) failed: %m\", \"getsockopt\", PG_TCP_KEEPALIVE_IDLE_STR)));\n\t\t\tport->default_keepalives_idle = -1; /* don't know */\n\t\t}\n#else\t\t\t\t\t\t\t/* WIN32 */\n\t\t/* We can't get the defaults on Windows, so return \"don't know\" */\n\t\tport->default_keepalives_idle = -1;\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\t}\n\n\treturn port->default_keepalives_idle;\n#else\n\treturn 0;\n#endif\n}\n\nint\npq_setkeepalivesidle(int idle, Port *port)\n{\n\tif (port == NULL || IS_AF_UNIX(port->laddr.addr.ss_family))\n\t\treturn STATUS_OK;\n\n/* check SIO_KEEPALIVE_VALS here, not just WIN32, as some toolchains lack it */\n#if defined(PG_TCP_KEEPALIVE_IDLE) || defined(SIO_KEEPALIVE_VALS)\n\tif (idle == port->keepalives_idle)\n\t\treturn STATUS_OK;\n\n#ifndef WIN32\n\tif (port->default_keepalives_idle <= 0)\n\t{\n\t\tif (pq_getkeepalivesidle(port) < 0)\n\t\t{\n\t\t\tif (idle == 0)\n\t\t\t\treturn STATUS_OK;\t/* default is set but unknown */\n\t\t\telse\n\t\t\t\treturn STATUS_ERROR;\n\t\t}\n\t}\n\n\tif (idle == 0)\n\t\tidle = port->default_keepalives_idle;\n\n\tif (setsockopt(port->sock, IPPROTO_TCP, PG_TCP_KEEPALIVE_IDLE,\n\t\t\t\t   (char *) &idle, sizeof(idle)) < 0)\n\t{\n\t\tereport(LOG,\n\t\t\t\t(errmsg(\"%s(%s) failed: %m\", \"setsockopt\", PG_TCP_KEEPALIVE_IDLE_STR)));\n\t\treturn STATUS_ERROR;\n\t}\n\n\tport->keepalives_idle = idle;\n#else\t\t\t\t\t\t\t/* WIN32 */\n\treturn pq_setkeepaliveswin32(port, idle, port->keepalives_interval);\n#endif\n#else\n\tif (idle != 0)\n\t{\n\t\tereport(LOG,\n\t\t\t\t(errmsg(\"setting the keepalive idle time is not supported\")));\n\t\treturn STATUS_ERROR;\n\t}\n#endif\n\n\treturn STATUS_OK;\n}\n\nint\npq_getkeepalivesinterval(Port *port)\n{\n#if defined(TCP_KEEPINTVL) || defined(SIO_KEEPALIVE_VALS)\n\tif (port == NULL || IS_AF_UNIX(port->laddr.addr.ss_family))\n\t\treturn 0;\n\n\tif (port->keepalives_interval != 0)\n\t\treturn port->keepalives_interval;\n\n\tif (port->default_keepalives_interval == 0)\n\t{\n#ifndef WIN32\n\t\tACCEPT_TYPE_ARG3 size = sizeof(port->default_keepalives_interval);\n\n\t\tif (getsockopt(port->sock, IPPROTO_TCP, TCP_KEEPINTVL,\n\t\t\t\t\t   (char *) &port->default_keepalives_interval,\n\t\t\t\t\t   &size) < 0)\n\t\t{\n\t\t\tereport(LOG,\n\t\t\t\t\t(errmsg(\"%s(%s) failed: %m\", \"getsockopt\", \"TCP_KEEPINTVL\")));\n\t\t\tport->default_keepalives_interval = -1; /* don't know */\n\t\t}\n#else\n\t\t/* We can't get the defaults on Windows, so return \"don't know\" */\n\t\tport->default_keepalives_interval = -1;\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\t}\n\n\treturn port->default_keepalives_interval;\n#else\n\treturn 0;\n#endif\n}\n\nint\npq_setkeepalivesinterval(int interval, Port *port)\n{\n\tif (port == NULL || IS_AF_UNIX(port->laddr.addr.ss_family))\n\t\treturn STATUS_OK;\n\n#if defined(TCP_KEEPINTVL) || defined(SIO_KEEPALIVE_VALS)\n\tif (interval == port->keepalives_interval)\n\t\treturn STATUS_OK;\n\n#ifndef WIN32\n\tif (port->default_keepalives_interval <= 0)\n\t{\n\t\tif (pq_getkeepalivesinterval(port) < 0)\n\t\t{\n\t\t\tif (interval == 0)\n\t\t\t\treturn STATUS_OK;\t/* default is set but unknown */\n\t\t\telse\n\t\t\t\treturn STATUS_ERROR;\n\t\t}\n\t}\n\n\tif (interval == 0)\n\t\tinterval = port->default_keepalives_interval;\n\n\tif (setsockopt(port->sock, IPPROTO_TCP, TCP_KEEPINTVL,\n\t\t\t\t   (char *) &interval, sizeof(interval)) < 0)\n\t{\n\t\tereport(LOG,\n\t\t\t\t(errmsg(\"%s(%s) failed: %m\", \"setsockopt\", \"TCP_KEEPINTVL\")));\n\t\treturn STATUS_ERROR;\n\t}\n\n\tport->keepalives_interval = interval;\n#else\t\t\t\t\t\t\t/* WIN32 */\n\treturn pq_setkeepaliveswin32(port, port->keepalives_idle, interval);\n#endif\n#else\n\tif (interval != 0)\n\t{\n\t\tereport(LOG,\n\t\t\t\t(errmsg(\"%s(%s) not supported\", \"setsockopt\", \"TCP_KEEPINTVL\")));\n\t\treturn STATUS_ERROR;\n\t}\n#endif\n\n\treturn STATUS_OK;\n}\n\nint\npq_getkeepalivescount(Port *port)\n{\n#ifdef TCP_KEEPCNT\n\tif (port == NULL || IS_AF_UNIX(port->laddr.addr.ss_family))\n\t\treturn 0;\n\n\tif (port->keepalives_count != 0)\n\t\treturn port->keepalives_count;\n\n\tif (port->default_keepalives_count == 0)\n\t{\n\t\tACCEPT_TYPE_ARG3 size = sizeof(port->default_keepalives_count);\n\n\t\tif (getsockopt(port->sock, IPPROTO_TCP, TCP_KEEPCNT,\n\t\t\t\t\t   (char *) &port->default_keepalives_count,\n\t\t\t\t\t   &size) < 0)\n\t\t{\n\t\t\tereport(LOG,\n\t\t\t\t\t(errmsg(\"%s(%s) failed: %m\", \"getsockopt\", \"TCP_KEEPCNT\")));\n\t\t\tport->default_keepalives_count = -1;\t/* don't know */\n\t\t}\n\t}\n\n\treturn port->default_keepalives_count;\n#else\n\treturn 0;\n#endif\n}\n\nint\npq_setkeepalivescount(int count, Port *port)\n{\n\tif (port == NULL || IS_AF_UNIX(port->laddr.addr.ss_family))\n\t\treturn STATUS_OK;\n\n#ifdef TCP_KEEPCNT\n\tif (count == port->keepalives_count)\n\t\treturn STATUS_OK;\n\n\tif (port->default_keepalives_count <= 0)\n\t{\n\t\tif (pq_getkeepalivescount(port) < 0)\n\t\t{\n\t\t\tif (count == 0)\n\t\t\t\treturn STATUS_OK;\t/* default is set but unknown */\n\t\t\telse\n\t\t\t\treturn STATUS_ERROR;\n\t\t}\n\t}\n\n\tif (count == 0)\n\t\tcount = port->default_keepalives_count;\n\n\tif (setsockopt(port->sock, IPPROTO_TCP, TCP_KEEPCNT,\n\t\t\t\t   (char *) &count, sizeof(count)) < 0)\n\t{\n\t\tereport(LOG,\n\t\t\t\t(errmsg(\"%s(%s) failed: %m\", \"setsockopt\", \"TCP_KEEPCNT\")));\n\t\treturn STATUS_ERROR;\n\t}\n\n\tport->keepalives_count = count;\n#else\n\tif (count != 0)\n\t{\n\t\tereport(LOG,\n\t\t\t\t(errmsg(\"%s(%s) not supported\", \"setsockopt\", \"TCP_KEEPCNT\")));\n\t\treturn STATUS_ERROR;\n\t}\n#endif\n\n\treturn STATUS_OK;\n}\n\nint\npq_gettcpusertimeout(Port *port)\n{\n#ifdef TCP_USER_TIMEOUT\n\tif (port == NULL || IS_AF_UNIX(port->laddr.addr.ss_family))\n\t\treturn 0;\n\n\tif (port->tcp_user_timeout != 0)\n\t\treturn port->tcp_user_timeout;\n\n\tif (port->default_tcp_user_timeout == 0)\n\t{\n\t\tACCEPT_TYPE_ARG3 size = sizeof(port->default_tcp_user_timeout);\n\n\t\tif (getsockopt(port->sock, IPPROTO_TCP, TCP_USER_TIMEOUT,\n\t\t\t\t\t   (char *) &port->default_tcp_user_timeout,\n\t\t\t\t\t   &size) < 0)\n\t\t{\n\t\t\tereport(LOG,\n\t\t\t\t\t(errmsg(\"%s(%s) failed: %m\", \"getsockopt\", \"TCP_USER_TIMEOUT\")));\n\t\t\tport->default_tcp_user_timeout = -1;\t/* don't know */\n\t\t}\n\t}\n\n\treturn port->default_tcp_user_timeout;\n#else\n\treturn 0;\n#endif\n}\n\nint\npq_settcpusertimeout(int timeout, Port *port)\n{\n\tif (port == NULL || IS_AF_UNIX(port->laddr.addr.ss_family))\n\t\treturn STATUS_OK;\n\n#ifdef TCP_USER_TIMEOUT\n\tif (timeout == port->tcp_user_timeout)\n\t\treturn STATUS_OK;\n\n\tif (port->default_tcp_user_timeout <= 0)\n\t{\n\t\tif (pq_gettcpusertimeout(port) < 0)\n\t\t{\n\t\t\tif (timeout == 0)\n\t\t\t\treturn STATUS_OK;\t/* default is set but unknown */\n\t\t\telse\n\t\t\t\treturn STATUS_ERROR;\n\t\t}\n\t}\n\n\tif (timeout == 0)\n\t\ttimeout = port->default_tcp_user_timeout;\n\n\tif (setsockopt(port->sock, IPPROTO_TCP, TCP_USER_TIMEOUT,\n\t\t\t\t   (char *) &timeout, sizeof(timeout)) < 0)\n\t{\n\t\tereport(LOG,\n\t\t\t\t(errmsg(\"%s(%s) failed: %m\", \"setsockopt\", \"TCP_USER_TIMEOUT\")));\n\t\treturn STATUS_ERROR;\n\t}\n\n\tport->tcp_user_timeout = timeout;\n#else\n\tif (timeout != 0)\n\t{\n\t\tereport(LOG,\n\t\t\t\t(errmsg(\"%s(%s) not supported\", \"setsockopt\", \"TCP_USER_TIMEOUT\")));\n\t\treturn STATUS_ERROR;\n\t}\n#endif\n\n\treturn STATUS_OK;\n}\n\n/*\n * Check if the client is still connected.\n */\nbool\npq_check_connection(void)\n{\n#if defined(POLLRDHUP)\n\t/*\n\t * POLLRDHUP is a Linux extension to poll(2) to detect sockets closed by\n\t * the other end.  We don't have a portable way to do that without\n\t * actually trying to read or write data on other systems.  We don't want\n\t * to read because that would be confused by pipelined queries and COPY\n\t * data. Perhaps in future we'll try to write a heartbeat message instead.\n\t */\n\tstruct pollfd pollfd;\n\tint\t\t\trc;\n\n\tpollfd.fd = MyProcPort->sock;\n\tpollfd.events = POLLOUT | POLLIN | POLLRDHUP;\n\tpollfd.revents = 0;\n\n\trc = poll(&pollfd, 1, 0);\n\n\tif (rc < 0)\n\t{\n\t\tereport(COMMERROR,\n\t\t\t\t(errcode_for_socket_access(),\n\t\t\t\t errmsg(\"could not poll socket: %m\")));\n\t\treturn false;\n\t}\n\telse if (rc == 1 && (pollfd.revents & (POLLHUP | POLLRDHUP)))\n\t\treturn false;\n#endif\n\n\treturn true;\n}\n", "/*-------------------------------------------------------------------------\n *\n * postmaster.c\n *\t  This program acts as a clearing house for requests to the\n *\t  POSTGRES system.  Frontend programs send a startup message\n *\t  to the Postmaster and the postmaster uses the info in the\n *\t  message to setup a backend process.\n *\n *\t  The postmaster also manages system-wide operations such as\n *\t  startup and shutdown. The postmaster itself doesn't do those\n *\t  operations, mind you --- it just forks off a subprocess to do them\n *\t  at the right times.  It also takes care of resetting the system\n *\t  if a backend crashes.\n *\n *\t  The postmaster process creates the shared memory and semaphore\n *\t  pools during startup, but as a rule does not touch them itself.\n *\t  In particular, it is not a member of the PGPROC array of backends\n *\t  and so it cannot participate in lock-manager operations.  Keeping\n *\t  the postmaster away from shared memory operations makes it simpler\n *\t  and more reliable.  The postmaster is almost always able to recover\n *\t  from crashes of individual backends by resetting shared memory;\n *\t  if it did much with shared memory then it would be prone to crashing\n *\t  along with the backends.\n *\n *\t  When a request message is received, we now fork() immediately.\n *\t  The child process performs authentication of the request, and\n *\t  then becomes a backend if successful.  This allows the auth code\n *\t  to be written in a simple single-threaded style (as opposed to the\n *\t  crufty \"poor man's multitasking\" code that used to be needed).\n *\t  More importantly, it ensures that blockages in non-multithreaded\n *\t  libraries like SSL or PAM cannot cause denial of service to other\n *\t  clients.\n *\n *\n * Portions Copyright (c) 1996-2021, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n *\n * IDENTIFICATION\n *\t  src/backend/postmaster/postmaster.c\n *\n * NOTES\n *\n * Initialization:\n *\t\tThe Postmaster sets up shared memory data structures\n *\t\tfor the backends.\n *\n * Synchronization:\n *\t\tThe Postmaster shares memory with the backends but should avoid\n *\t\ttouching shared memory, so as not to become stuck if a crashing\n *\t\tbackend screws up locks or shared memory.  Likewise, the Postmaster\n *\t\tshould never block on messages from frontend clients.\n *\n * Garbage Collection:\n *\t\tThe Postmaster cleans up after backends if they have an emergency\n *\t\texit and/or core dump.\n *\n * Error Reporting:\n *\t\tUse write_stderr() only for reporting \"interactive\" errors\n *\t\t(essentially, bogus arguments on the command line).  Once the\n *\t\tpostmaster is launched, use ereport().\n *\n *-------------------------------------------------------------------------\n */\n\n#include \"postgres.h\"\n\n#include <unistd.h>\n#include <signal.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <ctype.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <fcntl.h>\n#include <sys/param.h>\n#include <netdb.h>\n#include <limits.h>\n\n#ifdef HAVE_SYS_SELECT_H\n#include <sys/select.h>\n#endif\n\n#ifdef USE_BONJOUR\n#include <dns_sd.h>\n#endif\n\n#ifdef USE_SYSTEMD\n#include <systemd/sd-daemon.h>\n#endif\n\n#ifdef HAVE_PTHREAD_IS_THREADED_NP\n#include <pthread.h>\n#endif\n\n#include \"access/transam.h\"\n#include \"access/xlog.h\"\n#include \"catalog/pg_control.h\"\n#include \"common/file_perm.h\"\n#include \"common/ip.h\"\n#include \"common/string.h\"\n#include \"lib/ilist.h\"\n#include \"libpq/auth.h\"\n#include \"libpq/libpq.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/pqsignal.h\"\n#include \"pg_getopt.h\"\n#include \"pgstat.h\"\n#include \"port/pg_bswap.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"postmaster/auxprocess.h\"\n#include \"postmaster/bgworker_internals.h\"\n#include \"postmaster/fork_process.h\"\n#include \"postmaster/interrupt.h\"\n#include \"postmaster/pgarch.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/syslogger.h\"\n#include \"replication/logicallauncher.h\"\n#include \"replication/walsender.h\"\n#include \"storage/fd.h\"\n#include \"storage/ipc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/pmsignal.h\"\n#include \"storage/proc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"utils/builtins.h\"\n#include \"utils/datetime.h\"\n#include \"utils/memutils.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/ps_status.h\"\n#include \"utils/queryjumble.h\"\n#include \"utils/timeout.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/varlena.h\"\n\n#ifdef EXEC_BACKEND\n#include \"storage/spin.h\"\n#endif\n\n\n/*\n * Possible types of a backend. Beyond being the possible bkend_type values in\n * struct bkend, these are OR-able request flag bits for SignalSomeChildren()\n * and CountChildren().\n */\n#define BACKEND_TYPE_NORMAL\t\t0x0001\t/* normal backend */\n#define BACKEND_TYPE_AUTOVAC\t0x0002\t/* autovacuum worker process */\n#define BACKEND_TYPE_WALSND\t\t0x0004\t/* walsender process */\n#define BACKEND_TYPE_BGWORKER\t0x0008\t/* bgworker process */\n#define BACKEND_TYPE_ALL\t\t0x000F\t/* OR of all the above */\n\n/*\n * List of active backends (or child processes anyway; we don't actually\n * know whether a given child has become a backend or is still in the\n * authorization phase).  This is used mainly to keep track of how many\n * children we have and send them appropriate signals when necessary.\n *\n * As shown in the above set of backend types, this list includes not only\n * \"normal\" client sessions, but also autovacuum workers, walsenders, and\n * background workers.  (Note that at the time of launch, walsenders are\n * labeled BACKEND_TYPE_NORMAL; we relabel them to BACKEND_TYPE_WALSND\n * upon noticing they've changed their PMChildFlags entry.  Hence that check\n * must be done before any operation that needs to distinguish walsenders\n * from normal backends.)\n *\n * Also, \"dead_end\" children are in it: these are children launched just for\n * the purpose of sending a friendly rejection message to a would-be client.\n * We must track them because they are attached to shared memory, but we know\n * they will never become live backends.  dead_end children are not assigned a\n * PMChildSlot.  dead_end children have bkend_type NORMAL.\n *\n * \"Special\" children such as the startup, bgwriter and autovacuum launcher\n * tasks are not in this list.  They are tracked via StartupPID and other\n * pid_t variables below.  (Thus, there can't be more than one of any given\n * \"special\" child process type.  We use BackendList entries for any child\n * process there can be more than one of.)\n */\ntypedef struct bkend\n{\n\tpid_t\t\tpid;\t\t\t/* process id of backend */\n\tint32\t\tcancel_key;\t\t/* cancel key for cancels for this backend */\n\tint\t\t\tchild_slot;\t\t/* PMChildSlot for this backend, if any */\n\tint\t\t\tbkend_type;\t\t/* child process flavor, see above */\n\tbool\t\tdead_end;\t\t/* is it going to send an error and quit? */\n\tbool\t\tbgworker_notify;\t/* gets bgworker start/stop notifications */\n\tdlist_node\telem;\t\t\t/* list link in BackendList */\n} Backend;\n\nstatic dlist_head BackendList = DLIST_STATIC_INIT(BackendList);\n\n#ifdef EXEC_BACKEND\nstatic Backend *ShmemBackendArray;\n#endif\n\nBackgroundWorker *MyBgworkerEntry = NULL;\n\n\n\n/* The socket number we are listening for connections on */\nint\t\t\tPostPortNumber;\n\n/* The directory names for Unix socket(s) */\nchar\t   *Unix_socket_directories;\n\n/* The TCP listen address(es) */\nchar\t   *ListenAddresses;\n\n/*\n * ReservedBackends is the number of backends reserved for superuser use.\n * This number is taken out of the pool size given by MaxConnections so\n * number of backend slots available to non-superusers is\n * (MaxConnections - ReservedBackends).  Note what this really means is\n * \"if there are <= ReservedBackends connections available, only superusers\n * can make new connections\" --- pre-existing superuser connections don't\n * count against the limit.\n */\nint\t\t\tReservedBackends;\n\n/* The socket(s) we're listening to. */\n#define MAXLISTEN\t64\nstatic pgsocket ListenSocket[MAXLISTEN];\n\n/*\n * These globals control the behavior of the postmaster in case some\n * backend dumps core.  Normally, it kills all peers of the dead backend\n * and reinitializes shared memory.  By specifying -s or -n, we can have\n * the postmaster stop (rather than kill) peers and not reinitialize\n * shared data structures.  (Reinit is currently dead code, though.)\n */\nstatic bool Reinit = true;\nstatic int\tSendStop = false;\n\n/* still more option variables */\nbool\t\tEnableSSL = false;\n\nint\t\t\tPreAuthDelay = 0;\nint\t\t\tAuthenticationTimeout = 60;\n\nbool\t\tlog_hostname;\t\t/* for ps display and logging */\nbool\t\tLog_connections = false;\nbool\t\tDb_user_namespace = false;\n\nbool\t\tenable_bonjour = false;\nchar\t   *bonjour_name;\nbool\t\trestart_after_crash = true;\nbool\t\tremove_temp_files_after_crash = true;\n\n/* PIDs of special child processes; 0 when not running */\nstatic pid_t StartupPID = 0,\n\t\t\tBgWriterPID = 0,\n\t\t\tCheckpointerPID = 0,\n\t\t\tWalWriterPID = 0,\n\t\t\tWalReceiverPID = 0,\n\t\t\tAutoVacPID = 0,\n\t\t\tPgArchPID = 0,\n\t\t\tPgStatPID = 0,\n\t\t\tSysLoggerPID = 0;\n\n/* Startup process's status */\ntypedef enum\n{\n\tSTARTUP_NOT_RUNNING,\n\tSTARTUP_RUNNING,\n\tSTARTUP_SIGNALED,\t\t\t/* we sent it a SIGQUIT or SIGKILL */\n\tSTARTUP_CRASHED\n} StartupStatusEnum;\n\nstatic StartupStatusEnum StartupStatus = STARTUP_NOT_RUNNING;\n\n/* Startup/shutdown state */\n#define\t\t\tNoShutdown\t\t0\n#define\t\t\tSmartShutdown\t1\n#define\t\t\tFastShutdown\t2\n#define\t\t\tImmediateShutdown\t3\n\nstatic int\tShutdown = NoShutdown;\n\nstatic bool FatalError = false; /* T if recovering from backend crash */\n\n/*\n * We use a simple state machine to control startup, shutdown, and\n * crash recovery (which is rather like shutdown followed by startup).\n *\n * After doing all the postmaster initialization work, we enter PM_STARTUP\n * state and the startup process is launched. The startup process begins by\n * reading the control file and other preliminary initialization steps.\n * In a normal startup, or after crash recovery, the startup process exits\n * with exit code 0 and we switch to PM_RUN state.  However, archive recovery\n * is handled specially since it takes much longer and we would like to support\n * hot standby during archive recovery.\n *\n * When the startup process is ready to start archive recovery, it signals the\n * postmaster, and we switch to PM_RECOVERY state. The background writer and\n * checkpointer are launched, while the startup process continues applying WAL.\n * If Hot Standby is enabled, then, after reaching a consistent point in WAL\n * redo, startup process signals us again, and we switch to PM_HOT_STANDBY\n * state and begin accepting connections to perform read-only queries.  When\n * archive recovery is finished, the startup process exits with exit code 0\n * and we switch to PM_RUN state.\n *\n * Normal child backends can only be launched when we are in PM_RUN or\n * PM_HOT_STANDBY state.  (connsAllowed can also restrict launching.)\n * In other states we handle connection requests by launching \"dead_end\"\n * child processes, which will simply send the client an error message and\n * quit.  (We track these in the BackendList so that we can know when they\n * are all gone; this is important because they're still connected to shared\n * memory, and would interfere with an attempt to destroy the shmem segment,\n * possibly leading to SHMALL failure when we try to make a new one.)\n * In PM_WAIT_DEAD_END state we are waiting for all the dead_end children\n * to drain out of the system, and therefore stop accepting connection\n * requests at all until the last existing child has quit (which hopefully\n * will not be very long).\n *\n * Notice that this state variable does not distinguish *why* we entered\n * states later than PM_RUN --- Shutdown and FatalError must be consulted\n * to find that out.  FatalError is never true in PM_RECOVERY, PM_HOT_STANDBY,\n * or PM_RUN states, nor in PM_SHUTDOWN states (because we don't enter those\n * states when trying to recover from a crash).  It can be true in PM_STARTUP\n * state, because we don't clear it until we've successfully started WAL redo.\n */\ntypedef enum\n{\n\tPM_INIT,\t\t\t\t\t/* postmaster starting */\n\tPM_STARTUP,\t\t\t\t\t/* waiting for startup subprocess */\n\tPM_RECOVERY,\t\t\t\t/* in archive recovery mode */\n\tPM_HOT_STANDBY,\t\t\t\t/* in hot standby mode */\n\tPM_RUN,\t\t\t\t\t\t/* normal \"database is alive\" state */\n\tPM_STOP_BACKENDS,\t\t\t/* need to stop remaining backends */\n\tPM_WAIT_BACKENDS,\t\t\t/* waiting for live backends to exit */\n\tPM_SHUTDOWN,\t\t\t\t/* waiting for checkpointer to do shutdown\n\t\t\t\t\t\t\t\t * ckpt */\n\tPM_SHUTDOWN_2,\t\t\t\t/* waiting for archiver and walsenders to\n\t\t\t\t\t\t\t\t * finish */\n\tPM_WAIT_DEAD_END,\t\t\t/* waiting for dead_end children to exit */\n\tPM_NO_CHILDREN\t\t\t\t/* all important children have exited */\n} PMState;\n\nstatic PMState pmState = PM_INIT;\n\n/*\n * While performing a \"smart shutdown\", we restrict new connections but stay\n * in PM_RUN or PM_HOT_STANDBY state until all the client backends are gone.\n * connsAllowed is a sub-state indicator showing the active restriction.\n * It is of no interest unless pmState is PM_RUN or PM_HOT_STANDBY.\n */\ntypedef enum\n{\n\tALLOW_ALL_CONNS,\t\t\t/* normal not-shutting-down state */\n\tALLOW_SUPERUSER_CONNS,\t\t/* only superusers can connect */\n\tALLOW_NO_CONNS\t\t\t\t/* no new connections allowed, period */\n} ConnsAllowedState;\n\nstatic ConnsAllowedState connsAllowed = ALLOW_ALL_CONNS;\n\n/* Start time of SIGKILL timeout during immediate shutdown or child crash */\n/* Zero means timeout is not running */\nstatic time_t AbortStartTime = 0;\n\n/* Length of said timeout */\n#define SIGKILL_CHILDREN_AFTER_SECS\t\t5\n\nstatic bool ReachedNormalRunning = false;\t/* T if we've reached PM_RUN */\n\nbool\t\tClientAuthInProgress = false;\t/* T during new-client\n\t\t\t\t\t\t\t\t\t\t\t * authentication */\n\nbool\t\tredirection_done = false;\t/* stderr redirected for syslogger? */\n\n/* received START_AUTOVAC_LAUNCHER signal */\nstatic volatile sig_atomic_t start_autovac_launcher = false;\n\n/* the launcher needs to be signaled to communicate some condition */\nstatic volatile bool avlauncher_needs_signal = false;\n\n/* received START_WALRECEIVER signal */\nstatic volatile sig_atomic_t WalReceiverRequested = false;\n\n/* set when there's a worker that needs to be started up */\nstatic volatile bool StartWorkerNeeded = true;\nstatic volatile bool HaveCrashedWorker = false;\n\n#ifdef USE_SSL\n/* Set when and if SSL has been initialized properly */\nstatic bool LoadedSSL = false;\n#endif\n\n#ifdef USE_BONJOUR\nstatic DNSServiceRef bonjour_sdref = NULL;\n#endif\n\n/*\n * postmaster.c - function prototypes\n */\nstatic void CloseServerPorts(int status, Datum arg);\nstatic void unlink_external_pid_file(int status, Datum arg);\nstatic void getInstallationPaths(const char *argv0);\nstatic void checkControlFile(void);\nstatic Port *ConnCreate(int serverFd);\nstatic void ConnFree(Port *port);\nstatic void reset_shared(void);\nstatic void SIGHUP_handler(SIGNAL_ARGS);\nstatic void pmdie(SIGNAL_ARGS);\nstatic void reaper(SIGNAL_ARGS);\nstatic void sigusr1_handler(SIGNAL_ARGS);\nstatic void process_startup_packet_die(SIGNAL_ARGS);\nstatic void dummy_handler(SIGNAL_ARGS);\nstatic void StartupPacketTimeoutHandler(void);\nstatic void CleanupBackend(int pid, int exitstatus);\nstatic bool CleanupBackgroundWorker(int pid, int exitstatus);\nstatic void HandleChildCrash(int pid, int exitstatus, const char *procname);\nstatic void LogChildExit(int lev, const char *procname,\n\t\t\t\t\t\t int pid, int exitstatus);\nstatic void PostmasterStateMachine(void);\nstatic void BackendInitialize(Port *port);\nstatic void BackendRun(Port *port) pg_attribute_noreturn();\nstatic void ExitPostmaster(int status) pg_attribute_noreturn();\nstatic int\tServerLoop(void);\nstatic int\tBackendStartup(Port *port);\nstatic int\tProcessStartupPacket(Port *port, bool ssl_done, bool gss_done);\nstatic void SendNegotiateProtocolVersion(List *unrecognized_protocol_options);\nstatic void processCancelRequest(Port *port, void *pkt);\nstatic int\tinitMasks(fd_set *rmask);\nstatic void report_fork_failure_to_client(Port *port, int errnum);\nstatic CAC_state canAcceptConnections(int backend_type);\nstatic bool RandomCancelKey(int32 *cancel_key);\nstatic void signal_child(pid_t pid, int signal);\nstatic bool SignalSomeChildren(int signal, int targets);\nstatic void TerminateChildren(int signal);\n\n#define SignalChildren(sig)\t\t\t   SignalSomeChildren(sig, BACKEND_TYPE_ALL)\n\nstatic int\tCountChildren(int target);\nstatic bool assign_backendlist_entry(RegisteredBgWorker *rw);\nstatic void maybe_start_bgworkers(void);\nstatic bool CreateOptsFile(int argc, char *argv[], char *fullprogname);\nstatic pid_t StartChildProcess(AuxProcType type);\nstatic void StartAutovacuumWorker(void);\nstatic void MaybeStartWalReceiver(void);\nstatic void InitPostmasterDeathWatchHandle(void);\n\n/*\n * Archiver is allowed to start up at the current postmaster state?\n *\n * If WAL archiving is enabled always, we are allowed to start archiver\n * even during recovery.\n */\n#define PgArchStartupAllowed()\t\\\n\t(((XLogArchivingActive() && pmState == PM_RUN) ||\t\t\t\\\n\t  (XLogArchivingAlways() &&\t\t\t\t\t\t\t\t\t  \\\n\t   (pmState == PM_RECOVERY || pmState == PM_HOT_STANDBY))) && \\\n\t PgArchCanRestart())\n\n#ifdef EXEC_BACKEND\n\n#ifdef WIN32\n#define WNOHANG 0\t\t\t\t/* ignored, so any integer value will do */\n\nstatic pid_t waitpid(pid_t pid, int *exitstatus, int options);\nstatic void WINAPI pgwin32_deadchild_callback(PVOID lpParameter, BOOLEAN TimerOrWaitFired);\n\nstatic HANDLE win32ChildQueue;\n\ntypedef struct\n{\n\tHANDLE\t\twaitHandle;\n\tHANDLE\t\tprocHandle;\n\tDWORD\t\tprocId;\n} win32_deadchild_waitinfo;\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\nstatic pid_t backend_forkexec(Port *port);\nstatic pid_t internal_forkexec(int argc, char *argv[], Port *port);\n\n/* Type for a socket that can be inherited to a client process */\n#ifdef WIN32\ntypedef struct\n{\n\tSOCKET\t\torigsocket;\t\t/* Original socket value, or PGINVALID_SOCKET\n\t\t\t\t\t\t\t\t * if not a socket */\n\tWSAPROTOCOL_INFO wsainfo;\n} InheritableSocket;\n#else\ntypedef int InheritableSocket;\n#endif\n\n/*\n * Structure contains all variables passed to exec:ed backends\n */\ntypedef struct\n{\n\tPort\t\tport;\n\tInheritableSocket portsocket;\n\tchar\t\tDataDir[MAXPGPATH];\n\tpgsocket\tListenSocket[MAXLISTEN];\n\tint32\t\tMyCancelKey;\n\tint\t\t\tMyPMChildSlot;\n#ifndef WIN32\n\tunsigned long UsedShmemSegID;\n#else\n\tvoid\t   *ShmemProtectiveRegion;\n\tHANDLE\t\tUsedShmemSegID;\n#endif\n\tvoid\t   *UsedShmemSegAddr;\n\tslock_t    *ShmemLock;\n\tVariableCache ShmemVariableCache;\n\tBackend    *ShmemBackendArray;\n#ifndef HAVE_SPINLOCKS\n\tPGSemaphore *SpinlockSemaArray;\n#endif\n\tint\t\t\tNamedLWLockTrancheRequests;\n\tNamedLWLockTranche *NamedLWLockTrancheArray;\n\tLWLockPadded *MainLWLockArray;\n\tslock_t    *ProcStructLock;\n\tPROC_HDR   *ProcGlobal;\n\tPGPROC\t   *AuxiliaryProcs;\n\tPGPROC\t   *PreparedXactProcs;\n\tPMSignalData *PMSignalState;\n\tInheritableSocket pgStatSock;\n\tpid_t\t\tPostmasterPid;\n\tTimestampTz PgStartTime;\n\tTimestampTz PgReloadTime;\n\tpg_time_t\tfirst_syslogger_file_time;\n\tbool\t\tredirection_done;\n\tbool\t\tIsBinaryUpgrade;\n\tbool\t\tquery_id_enabled;\n\tint\t\t\tmax_safe_fds;\n\tint\t\t\tMaxBackends;\n#ifdef WIN32\n\tHANDLE\t\tPostmasterHandle;\n\tHANDLE\t\tinitial_signal_pipe;\n\tHANDLE\t\tsyslogPipe[2];\n#else\n\tint\t\t\tpostmaster_alive_fds[2];\n\tint\t\t\tsyslogPipe[2];\n#endif\n\tchar\t\tmy_exec_path[MAXPGPATH];\n\tchar\t\tpkglib_path[MAXPGPATH];\n} BackendParameters;\n\nstatic void read_backend_variables(char *id, Port *port);\nstatic void restore_backend_variables(BackendParameters *param, Port *port);\n\n#ifndef WIN32\nstatic bool save_backend_variables(BackendParameters *param, Port *port);\n#else\nstatic bool save_backend_variables(BackendParameters *param, Port *port,\n\t\t\t\t\t\t\t\t   HANDLE childProcess, pid_t childPid);\n#endif\n\nstatic void ShmemBackendArrayAdd(Backend *bn);\nstatic void ShmemBackendArrayRemove(Backend *bn);\n#endif\t\t\t\t\t\t\t/* EXEC_BACKEND */\n\n#define StartupDataBase()\t\tStartChildProcess(StartupProcess)\n#define StartArchiver()\t\t\tStartChildProcess(ArchiverProcess)\n#define StartBackgroundWriter() StartChildProcess(BgWriterProcess)\n#define StartCheckpointer()\t\tStartChildProcess(CheckpointerProcess)\n#define StartWalWriter()\t\tStartChildProcess(WalWriterProcess)\n#define StartWalReceiver()\t\tStartChildProcess(WalReceiverProcess)\n\n/* Macros to check exit status of a child process */\n#define EXIT_STATUS_0(st)  ((st) == 0)\n#define EXIT_STATUS_1(st)  (WIFEXITED(st) && WEXITSTATUS(st) == 1)\n#define EXIT_STATUS_3(st)  (WIFEXITED(st) && WEXITSTATUS(st) == 3)\n\n#ifndef WIN32\n/*\n * File descriptors for pipe used to monitor if postmaster is alive.\n * First is POSTMASTER_FD_WATCH, second is POSTMASTER_FD_OWN.\n */\nint\t\t\tpostmaster_alive_fds[2] = {-1, -1};\n#else\n/* Process handle of postmaster used for the same purpose on Windows */\nHANDLE\t\tPostmasterHandle;\n#endif\n\n/*\n * Postmaster main entry point\n */\nvoid\nPostmasterMain(int argc, char *argv[])\n{\n\tint\t\t\topt;\n\tint\t\t\tstatus;\n\tchar\t   *userDoption = NULL;\n\tbool\t\tlisten_addr_saved = false;\n\tint\t\t\ti;\n\tchar\t   *output_config_variable = NULL;\n\n\tInitProcessGlobals();\n\n\tPostmasterPid = MyProcPid;\n\n\tIsPostmasterEnvironment = true;\n\n\t/*\n\t * Start our win32 signal implementation\n\t */\n#ifdef WIN32\n\tpgwin32_signal_initialize();\n#endif\n\n\t/*\n\t * We should not be creating any files or directories before we check the\n\t * data directory (see checkDataDir()), but just in case set the umask to\n\t * the most restrictive (owner-only) permissions.\n\t *\n\t * checkDataDir() will reset the umask based on the data directory\n\t * permissions.\n\t */\n\tumask(PG_MODE_MASK_OWNER);\n\n\t/*\n\t * By default, palloc() requests in the postmaster will be allocated in\n\t * the PostmasterContext, which is space that can be recycled by backends.\n\t * Allocated data that needs to be available to backends should be\n\t * allocated in TopMemoryContext.\n\t */\n\tPostmasterContext = AllocSetContextCreate(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t  \"Postmaster\",\n\t\t\t\t\t\t\t\t\t\t\t  ALLOCSET_DEFAULT_SIZES);\n\tMemoryContextSwitchTo(PostmasterContext);\n\n\t/* Initialize paths to installation files */\n\tgetInstallationPaths(argv[0]);\n\n\t/*\n\t * Set up signal handlers for the postmaster process.\n\t *\n\t * In the postmaster, we use pqsignal_pm() rather than pqsignal() (which\n\t * is used by all child processes and client processes).  That has a\n\t * couple of special behaviors:\n\t *\n\t * 1. Except on Windows, we tell sigaction() to block all signals for the\n\t * duration of the signal handler.  This is faster than our old approach\n\t * of blocking/unblocking explicitly in the signal handler, and it should\n\t * also prevent excessive stack consumption if signals arrive quickly.\n\t *\n\t * 2. We do not set the SA_RESTART flag.  This is because signals will be\n\t * blocked at all times except when ServerLoop is waiting for something to\n\t * happen, and during that window, we want signals to exit the select(2)\n\t * wait so that ServerLoop can respond if anything interesting happened.\n\t * On some platforms, signals marked SA_RESTART would not cause the\n\t * select() wait to end.\n\t *\n\t * Child processes will generally want SA_RESTART, so pqsignal() sets that\n\t * flag.  We expect children to set up their own handlers before\n\t * unblocking signals.\n\t *\n\t * CAUTION: when changing this list, check for side-effects on the signal\n\t * handling setup of child processes.  See tcop/postgres.c,\n\t * bootstrap/bootstrap.c, postmaster/bgwriter.c, postmaster/walwriter.c,\n\t * postmaster/autovacuum.c, postmaster/pgarch.c, postmaster/pgstat.c,\n\t * postmaster/syslogger.c, postmaster/bgworker.c and\n\t * postmaster/checkpointer.c.\n\t */\n\tpqinitmask();\n\tPG_SETMASK(&BlockSig);\n\n\tpqsignal_pm(SIGHUP, SIGHUP_handler);\t/* reread config file and have\n\t\t\t\t\t\t\t\t\t\t\t * children do same */\n\tpqsignal_pm(SIGINT, pmdie); /* send SIGTERM and shut down */\n\tpqsignal_pm(SIGQUIT, pmdie);\t/* send SIGQUIT and die */\n\tpqsignal_pm(SIGTERM, pmdie);\t/* wait for children and shut down */\n\tpqsignal_pm(SIGALRM, SIG_IGN);\t/* ignored */\n\tpqsignal_pm(SIGPIPE, SIG_IGN);\t/* ignored */\n\tpqsignal_pm(SIGUSR1, sigusr1_handler);\t/* message from child process */\n\tpqsignal_pm(SIGUSR2, dummy_handler);\t/* unused, reserve for children */\n\tpqsignal_pm(SIGCHLD, reaper);\t/* handle child termination */\n\n#ifdef SIGURG\n\n\t/*\n\t * Ignore SIGURG for now.  Child processes may change this (see\n\t * InitializeLatchSupport), but they will not receive any such signals\n\t * until they wait on a latch.\n\t */\n\tpqsignal_pm(SIGURG, SIG_IGN);\t/* ignored */\n#endif\n\n\t/*\n\t * No other place in Postgres should touch SIGTTIN/SIGTTOU handling.  We\n\t * ignore those signals in a postmaster environment, so that there is no\n\t * risk of a child process freezing up due to writing to stderr.  But for\n\t * a standalone backend, their default handling is reasonable.  Hence, all\n\t * child processes should just allow the inherited settings to stand.\n\t */\n#ifdef SIGTTIN\n\tpqsignal_pm(SIGTTIN, SIG_IGN);\t/* ignored */\n#endif\n#ifdef SIGTTOU\n\tpqsignal_pm(SIGTTOU, SIG_IGN);\t/* ignored */\n#endif\n\n\t/* ignore SIGXFSZ, so that ulimit violations work like disk full */\n#ifdef SIGXFSZ\n\tpqsignal_pm(SIGXFSZ, SIG_IGN);\t/* ignored */\n#endif\n\n\t/*\n\t * Options setup\n\t */\n\tInitializeGUCOptions();\n\n\topterr = 1;\n\n\t/*\n\t * Parse command-line options.  CAUTION: keep this in sync with\n\t * tcop/postgres.c (the option sets should not conflict) and with the\n\t * common help() function in main/main.c.\n\t */\n\twhile ((opt = getopt(argc, argv, \"B:bc:C:D:d:EeFf:h:ijk:lN:nOPp:r:S:sTt:W:-:\")) != -1)\n\t{\n\t\tswitch (opt)\n\t\t{\n\t\t\tcase 'B':\n\t\t\t\tSetConfigOption(\"shared_buffers\", optarg, PGC_POSTMASTER, PGC_S_ARGV);\n\t\t\t\tbreak;\n\n\t\t\tcase 'b':\n\t\t\t\t/* Undocumented flag used for binary upgrades */\n\t\t\t\tIsBinaryUpgrade = true;\n\t\t\t\tbreak;\n\n\t\t\tcase 'C':\n\t\t\t\toutput_config_variable = strdup(optarg);\n\t\t\t\tbreak;\n\n\t\t\tcase 'D':\n\t\t\t\tuserDoption = strdup(optarg);\n\t\t\t\tbreak;\n\n\t\t\tcase 'd':\n\t\t\t\tset_debug_options(atoi(optarg), PGC_POSTMASTER, PGC_S_ARGV);\n\t\t\t\tbreak;\n\n\t\t\tcase 'E':\n\t\t\t\tSetConfigOption(\"log_statement\", \"all\", PGC_POSTMASTER, PGC_S_ARGV);\n\t\t\t\tbreak;\n\n\t\t\tcase 'e':\n\t\t\t\tSetConfigOption(\"datestyle\", \"euro\", PGC_POSTMASTER, PGC_S_ARGV);\n\t\t\t\tbreak;\n\n\t\t\tcase 'F':\n\t\t\t\tSetConfigOption(\"fsync\", \"false\", PGC_POSTMASTER, PGC_S_ARGV);\n\t\t\t\tbreak;\n\n\t\t\tcase 'f':\n\t\t\t\tif (!set_plan_disabling_options(optarg, PGC_POSTMASTER, PGC_S_ARGV))\n\t\t\t\t{\n\t\t\t\t\twrite_stderr(\"%s: invalid argument for option -f: \\\"%s\\\"\\n\",\n\t\t\t\t\t\t\t\t progname, optarg);\n\t\t\t\t\tExitPostmaster(1);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'h':\n\t\t\t\tSetConfigOption(\"listen_addresses\", optarg, PGC_POSTMASTER, PGC_S_ARGV);\n\t\t\t\tbreak;\n\n\t\t\tcase 'i':\n\t\t\t\tSetConfigOption(\"listen_addresses\", \"*\", PGC_POSTMASTER, PGC_S_ARGV);\n\t\t\t\tbreak;\n\n\t\t\tcase 'j':\n\t\t\t\t/* only used by interactive backend */\n\t\t\t\tbreak;\n\n\t\t\tcase 'k':\n\t\t\t\tSetConfigOption(\"unix_socket_directories\", optarg, PGC_POSTMASTER, PGC_S_ARGV);\n\t\t\t\tbreak;\n\n\t\t\tcase 'l':\n\t\t\t\tSetConfigOption(\"ssl\", \"true\", PGC_POSTMASTER, PGC_S_ARGV);\n\t\t\t\tbreak;\n\n\t\t\tcase 'N':\n\t\t\t\tSetConfigOption(\"max_connections\", optarg, PGC_POSTMASTER, PGC_S_ARGV);\n\t\t\t\tbreak;\n\n\t\t\tcase 'n':\n\t\t\t\t/* Don't reinit shared mem after abnormal exit */\n\t\t\t\tReinit = false;\n\t\t\t\tbreak;\n\n\t\t\tcase 'O':\n\t\t\t\tSetConfigOption(\"allow_system_table_mods\", \"true\", PGC_POSTMASTER, PGC_S_ARGV);\n\t\t\t\tbreak;\n\n\t\t\tcase 'P':\n\t\t\t\tSetConfigOption(\"ignore_system_indexes\", \"true\", PGC_POSTMASTER, PGC_S_ARGV);\n\t\t\t\tbreak;\n\n\t\t\tcase 'p':\n\t\t\t\tSetConfigOption(\"port\", optarg, PGC_POSTMASTER, PGC_S_ARGV);\n\t\t\t\tbreak;\n\n\t\t\tcase 'r':\n\t\t\t\t/* only used by single-user backend */\n\t\t\t\tbreak;\n\n\t\t\tcase 'S':\n\t\t\t\tSetConfigOption(\"work_mem\", optarg, PGC_POSTMASTER, PGC_S_ARGV);\n\t\t\t\tbreak;\n\n\t\t\tcase 's':\n\t\t\t\tSetConfigOption(\"log_statement_stats\", \"true\", PGC_POSTMASTER, PGC_S_ARGV);\n\t\t\t\tbreak;\n\n\t\t\tcase 'T':\n\n\t\t\t\t/*\n\t\t\t\t * In the event that some backend dumps core, send SIGSTOP,\n\t\t\t\t * rather than SIGQUIT, to all its peers.  This lets the wily\n\t\t\t\t * post_hacker collect core dumps from everyone.\n\t\t\t\t */\n\t\t\t\tSendStop = true;\n\t\t\t\tbreak;\n\n\t\t\tcase 't':\n\t\t\t\t{\n\t\t\t\t\tconst char *tmp = get_stats_option_name(optarg);\n\n\t\t\t\t\tif (tmp)\n\t\t\t\t\t{\n\t\t\t\t\t\tSetConfigOption(tmp, \"true\", PGC_POSTMASTER, PGC_S_ARGV);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\twrite_stderr(\"%s: invalid argument for option -t: \\\"%s\\\"\\n\",\n\t\t\t\t\t\t\t\t\t progname, optarg);\n\t\t\t\t\t\tExitPostmaster(1);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tcase 'W':\n\t\t\t\tSetConfigOption(\"post_auth_delay\", optarg, PGC_POSTMASTER, PGC_S_ARGV);\n\t\t\t\tbreak;\n\n\t\t\tcase 'c':\n\t\t\tcase '-':\n\t\t\t\t{\n\t\t\t\t\tchar\t   *name,\n\t\t\t\t\t\t\t   *value;\n\n\t\t\t\t\tParseLongOption(optarg, &name, &value);\n\t\t\t\t\tif (!value)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (opt == '-')\n\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t\t\t\t errmsg(\"--%s requires a value\",\n\t\t\t\t\t\t\t\t\t\t\toptarg)));\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t\t\t\t errmsg(\"-c %s requires a value\",\n\t\t\t\t\t\t\t\t\t\t\toptarg)));\n\t\t\t\t\t}\n\n\t\t\t\t\tSetConfigOption(name, value, PGC_POSTMASTER, PGC_S_ARGV);\n\t\t\t\t\tfree(name);\n\t\t\t\t\tif (value)\n\t\t\t\t\t\tfree(value);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tdefault:\n\t\t\t\twrite_stderr(\"Try \\\"%s --help\\\" for more information.\\n\",\n\t\t\t\t\t\t\t progname);\n\t\t\t\tExitPostmaster(1);\n\t\t}\n\t}\n\n\t/*\n\t * Postmaster accepts no non-option switch arguments.\n\t */\n\tif (optind < argc)\n\t{\n\t\twrite_stderr(\"%s: invalid argument: \\\"%s\\\"\\n\",\n\t\t\t\t\t progname, argv[optind]);\n\t\twrite_stderr(\"Try \\\"%s --help\\\" for more information.\\n\",\n\t\t\t\t\t progname);\n\t\tExitPostmaster(1);\n\t}\n\n\t/*\n\t * Locate the proper configuration files and data directory, and read\n\t * postgresql.conf for the first time.\n\t */\n\tif (!SelectConfigFiles(userDoption, progname))\n\t\tExitPostmaster(2);\n\n\tif (output_config_variable != NULL)\n\t{\n\t\t/*\n\t\t * If this is a runtime-computed GUC, it hasn't yet been initialized,\n\t\t * and the present value is not useful.  However, this is a convenient\n\t\t * place to print the value for most GUCs because it is safe to run\n\t\t * postmaster startup to this point even if the server is already\n\t\t * running.  For the handful of runtime-computed GUCs that we cannot\n\t\t * provide meaningful values for yet, we wait until later in\n\t\t * postmaster startup to print the value.  We won't be able to use -C\n\t\t * on running servers for those GUCs, but using this option now would\n\t\t * lead to incorrect results for them.\n\t\t */\n\t\tint\t\t\tflags = GetConfigOptionFlags(output_config_variable, true);\n\n\t\tif ((flags & GUC_RUNTIME_COMPUTED) == 0)\n\t\t{\n\t\t\t/*\n\t\t\t * \"-C guc\" was specified, so print GUC's value and exit.  No\n\t\t\t * extra permission check is needed because the user is reading\n\t\t\t * inside the data dir.\n\t\t\t */\n\t\t\tconst char *config_val = GetConfigOption(output_config_variable,\n\t\t\t\t\t\t\t\t\t\t\t\t\t false, false);\n\n\t\t\tputs(config_val ? config_val : \"\");\n\t\t\tExitPostmaster(0);\n\t\t}\n\t}\n\n\t/* Verify that DataDir looks reasonable */\n\tcheckDataDir();\n\n\t/* Check that pg_control exists */\n\tcheckControlFile();\n\n\t/* And switch working directory into it */\n\tChangeToDataDir();\n\n\t/*\n\t * Check for invalid combinations of GUC settings.\n\t */\n\tif (ReservedBackends >= MaxConnections)\n\t{\n\t\twrite_stderr(\"%s: superuser_reserved_connections (%d) must be less than max_connections (%d)\\n\",\n\t\t\t\t\t progname,\n\t\t\t\t\t ReservedBackends, MaxConnections);\n\t\tExitPostmaster(1);\n\t}\n\tif (XLogArchiveMode > ARCHIVE_MODE_OFF && wal_level == WAL_LEVEL_MINIMAL)\n\t\tereport(ERROR,\n\t\t\t\t(errmsg(\"WAL archival cannot be enabled when wal_level is \\\"minimal\\\"\")));\n\tif (max_wal_senders > 0 && wal_level == WAL_LEVEL_MINIMAL)\n\t\tereport(ERROR,\n\t\t\t\t(errmsg(\"WAL streaming (max_wal_senders > 0) requires wal_level \\\"replica\\\" or \\\"logical\\\"\")));\n\n\t/*\n\t * Other one-time internal sanity checks can go here, if they are fast.\n\t * (Put any slow processing further down, after postmaster.pid creation.)\n\t */\n\tif (!CheckDateTokenTables())\n\t{\n\t\twrite_stderr(\"%s: invalid datetoken tables, please fix\\n\", progname);\n\t\tExitPostmaster(1);\n\t}\n\n\t/*\n\t * Now that we are done processing the postmaster arguments, reset\n\t * getopt(3) library so that it will work correctly in subprocesses.\n\t */\n\toptind = 1;\n#ifdef HAVE_INT_OPTRESET\n\toptreset = 1;\t\t\t\t/* some systems need this too */\n#endif\n\n\t/* For debugging: display postmaster environment */\n\t{\n\t\textern char **environ;\n\t\tchar\t  **p;\n\n\t\tereport(DEBUG3,\n\t\t\t\t(errmsg_internal(\"%s: PostmasterMain: initial environment dump:\",\n\t\t\t\t\t\t\t\t progname)));\n\t\tereport(DEBUG3,\n\t\t\t\t(errmsg_internal(\"-----------------------------------------\")));\n\t\tfor (p = environ; *p; ++p)\n\t\t\tereport(DEBUG3,\n\t\t\t\t\t(errmsg_internal(\"\\t%s\", *p)));\n\t\tereport(DEBUG3,\n\t\t\t\t(errmsg_internal(\"-----------------------------------------\")));\n\t}\n\n\t/*\n\t * Create lockfile for data directory.\n\t *\n\t * We want to do this before we try to grab the input sockets, because the\n\t * data directory interlock is more reliable than the socket-file\n\t * interlock (thanks to whoever decided to put socket files in /tmp :-().\n\t * For the same reason, it's best to grab the TCP socket(s) before the\n\t * Unix socket(s).\n\t *\n\t * Also note that this internally sets up the on_proc_exit function that\n\t * is responsible for removing both data directory and socket lockfiles;\n\t * so it must happen before opening sockets so that at exit, the socket\n\t * lockfiles go away after CloseServerPorts runs.\n\t */\n\tCreateDataDirLockFile(true);\n\n\t/*\n\t * Read the control file (for error checking and config info).\n\t *\n\t * Since we verify the control file's CRC, this has a useful side effect\n\t * on machines where we need a run-time test for CRC support instructions.\n\t * The postmaster will do the test once at startup, and then its child\n\t * processes will inherit the correct function pointer and not need to\n\t * repeat the test.\n\t */\n\tLocalProcessControlFile(false);\n\n\t/*\n\t * Register the apply launcher.  Since it registers a background worker,\n\t * it needs to be called before InitializeMaxBackends(), and it's probably\n\t * a good idea to call it before any modules had chance to take the\n\t * background worker slots.\n\t */\n\tApplyLauncherRegister();\n\n\t/*\n\t * process any libraries that should be preloaded at postmaster start\n\t */\n\tprocess_shared_preload_libraries();\n\n\t/*\n\t * Initialize SSL library, if specified.\n\t */\n#ifdef USE_SSL\n\tif (EnableSSL)\n\t{\n\t\t(void) secure_initialize(true);\n\t\tLoadedSSL = true;\n\t}\n#endif\n\n\t/*\n\t * Now that loadable modules have had their chance to register background\n\t * workers, calculate MaxBackends.\n\t */\n\tInitializeMaxBackends();\n\n\t/*\n\t * Now that loadable modules have had their chance to request additional\n\t * shared memory, determine the value of any runtime-computed GUCs that\n\t * depend on the amount of shared memory required.\n\t */\n\tInitializeShmemGUCs();\n\n\t/*\n\t * If -C was specified with a runtime-computed GUC, we held off printing\n\t * the value earlier, as the GUC was not yet initialized.  We handle -C\n\t * for most GUCs before we lock the data directory so that the option may\n\t * be used on a running server.  However, a handful of GUCs are runtime-\n\t * computed and do not have meaningful values until after locking the data\n\t * directory, and we cannot safely calculate their values earlier on a\n\t * running server.  At this point, such GUCs should be properly\n\t * initialized, and we haven't yet set up shared memory, so this is a good\n\t * time to handle the -C option for these special GUCs.\n\t */\n\tif (output_config_variable != NULL)\n\t{\n\t\tconst char *config_val = GetConfigOption(output_config_variable,\n\t\t\t\t\t\t\t\t\t\t\t\t false, false);\n\n\t\tputs(config_val ? config_val : \"\");\n\t\tExitPostmaster(0);\n\t}\n\n\t/*\n\t * Set up shared memory and semaphores.\n\t */\n\treset_shared();\n\n\t/*\n\t * Estimate number of openable files.  This must happen after setting up\n\t * semaphores, because on some platforms semaphores count as open files.\n\t */\n\tset_max_safe_fds();\n\n\t/*\n\t * Set reference point for stack-depth checking.\n\t */\n\tset_stack_base();\n\n\t/*\n\t * Initialize pipe (or process handle on Windows) that allows children to\n\t * wake up from sleep on postmaster death.\n\t */\n\tInitPostmasterDeathWatchHandle();\n\n#ifdef WIN32\n\n\t/*\n\t * Initialize I/O completion port used to deliver list of dead children.\n\t */\n\twin32ChildQueue = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0, 1);\n\tif (win32ChildQueue == NULL)\n\t\tereport(FATAL,\n\t\t\t\t(errmsg(\"could not create I/O completion port for child queue\")));\n#endif\n\n#ifdef EXEC_BACKEND\n\t/* Write out nondefault GUC settings for child processes to use */\n\twrite_nondefault_variables(PGC_POSTMASTER);\n\n\t/*\n\t * Clean out the temp directory used to transmit parameters to child\n\t * processes (see internal_forkexec, below).  We must do this before\n\t * launching any child processes, else we have a race condition: we could\n\t * remove a parameter file before the child can read it.  It should be\n\t * safe to do so now, because we verified earlier that there are no\n\t * conflicting Postgres processes in this data directory.\n\t */\n\tRemovePgTempFilesInDir(PG_TEMP_FILES_DIR, true, false);\n#endif\n\n\t/*\n\t * Forcibly remove the files signaling a standby promotion request.\n\t * Otherwise, the existence of those files triggers a promotion too early,\n\t * whether a user wants that or not.\n\t *\n\t * This removal of files is usually unnecessary because they can exist\n\t * only during a few moments during a standby promotion. However there is\n\t * a race condition: if pg_ctl promote is executed and creates the files\n\t * during a promotion, the files can stay around even after the server is\n\t * brought up to be the primary.  Then, if a new standby starts by using\n\t * the backup taken from the new primary, the files can exist at server\n\t * startup and must be removed in order to avoid an unexpected promotion.\n\t *\n\t * Note that promotion signal files need to be removed before the startup\n\t * process is invoked. Because, after that, they can be used by\n\t * postmaster's SIGUSR1 signal handler.\n\t */\n\tRemovePromoteSignalFiles();\n\n\t/* Do the same for logrotate signal file */\n\tRemoveLogrotateSignalFiles();\n\n\t/* Remove any outdated file holding the current log filenames. */\n\tif (unlink(LOG_METAINFO_DATAFILE) < 0 && errno != ENOENT)\n\t\tereport(LOG,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not remove file \\\"%s\\\": %m\",\n\t\t\t\t\t\tLOG_METAINFO_DATAFILE)));\n\n\t/*\n\t * If enabled, start up syslogger collection subprocess\n\t */\n\tSysLoggerPID = SysLogger_Start();\n\n\t/*\n\t * Reset whereToSendOutput from DestDebug (its starting state) to\n\t * DestNone. This stops ereport from sending log messages to stderr unless\n\t * Log_destination permits.  We don't do this until the postmaster is\n\t * fully launched, since startup failures may as well be reported to\n\t * stderr.\n\t *\n\t * If we are in fact disabling logging to stderr, first emit a log message\n\t * saying so, to provide a breadcrumb trail for users who may not remember\n\t * that their logging is configured to go somewhere else.\n\t */\n\tif (!(Log_destination & LOG_DESTINATION_STDERR))\n\t\tereport(LOG,\n\t\t\t\t(errmsg(\"ending log output to stderr\"),\n\t\t\t\t errhint(\"Future log output will go to log destination \\\"%s\\\".\",\n\t\t\t\t\t\t Log_destination_string)));\n\n\twhereToSendOutput = DestNone;\n\n\t/*\n\t * Report server startup in log.  While we could emit this much earlier,\n\t * it seems best to do so after starting the log collector, if we intend\n\t * to use one.\n\t */\n\tereport(LOG,\n\t\t\t(errmsg(\"starting %s\", PG_VERSION_STR)));\n\n\t/*\n\t * Establish input sockets.\n\t *\n\t * First, mark them all closed, and set up an on_proc_exit function that's\n\t * charged with closing the sockets again at postmaster shutdown.\n\t */\n\tfor (i = 0; i < MAXLISTEN; i++)\n\t\tListenSocket[i] = PGINVALID_SOCKET;\n\n\ton_proc_exit(CloseServerPorts, 0);\n\n\tif (ListenAddresses)\n\t{\n\t\tchar\t   *rawstring;\n\t\tList\t   *elemlist;\n\t\tListCell   *l;\n\t\tint\t\t\tsuccess = 0;\n\n\t\t/* Need a modifiable copy of ListenAddresses */\n\t\trawstring = pstrdup(ListenAddresses);\n\n\t\t/* Parse string into list of hostnames */\n\t\tif (!SplitGUCList(rawstring, ',', &elemlist))\n\t\t{\n\t\t\t/* syntax error in list */\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"invalid list syntax in parameter \\\"%s\\\"\",\n\t\t\t\t\t\t\t\"listen_addresses\")));\n\t\t}\n\n\t\tforeach(l, elemlist)\n\t\t{\n\t\t\tchar\t   *curhost = (char *) lfirst(l);\n\n\t\t\tif (strcmp(curhost, \"*\") == 0)\n\t\t\t\tstatus = StreamServerPort(AF_UNSPEC, NULL,\n\t\t\t\t\t\t\t\t\t\t  (unsigned short) PostPortNumber,\n\t\t\t\t\t\t\t\t\t\t  NULL,\n\t\t\t\t\t\t\t\t\t\t  ListenSocket, MAXLISTEN);\n\t\t\telse\n\t\t\t\tstatus = StreamServerPort(AF_UNSPEC, curhost,\n\t\t\t\t\t\t\t\t\t\t  (unsigned short) PostPortNumber,\n\t\t\t\t\t\t\t\t\t\t  NULL,\n\t\t\t\t\t\t\t\t\t\t  ListenSocket, MAXLISTEN);\n\n\t\t\tif (status == STATUS_OK)\n\t\t\t{\n\t\t\t\tsuccess++;\n\t\t\t\t/* record the first successful host addr in lockfile */\n\t\t\t\tif (!listen_addr_saved)\n\t\t\t\t{\n\t\t\t\t\tAddToDataDirLockFile(LOCK_FILE_LINE_LISTEN_ADDR, curhost);\n\t\t\t\t\tlisten_addr_saved = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\tereport(WARNING,\n\t\t\t\t\t\t(errmsg(\"could not create listen socket for \\\"%s\\\"\",\n\t\t\t\t\t\t\t\tcurhost)));\n\t\t}\n\n\t\tif (!success && elemlist != NIL)\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errmsg(\"could not create any TCP/IP sockets\")));\n\n\t\tlist_free(elemlist);\n\t\tpfree(rawstring);\n\t}\n\n#ifdef USE_BONJOUR\n\t/* Register for Bonjour only if we opened TCP socket(s) */\n\tif (enable_bonjour && ListenSocket[0] != PGINVALID_SOCKET)\n\t{\n\t\tDNSServiceErrorType err;\n\n\t\t/*\n\t\t * We pass 0 for interface_index, which will result in registering on\n\t\t * all \"applicable\" interfaces.  It's not entirely clear from the\n\t\t * DNS-SD docs whether this would be appropriate if we have bound to\n\t\t * just a subset of the available network interfaces.\n\t\t */\n\t\terr = DNSServiceRegister(&bonjour_sdref,\n\t\t\t\t\t\t\t\t 0,\n\t\t\t\t\t\t\t\t 0,\n\t\t\t\t\t\t\t\t bonjour_name,\n\t\t\t\t\t\t\t\t \"_postgresql._tcp.\",\n\t\t\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t\t\t pg_hton16(PostPortNumber),\n\t\t\t\t\t\t\t\t 0,\n\t\t\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t\t\t NULL);\n\t\tif (err != kDNSServiceErr_NoError)\n\t\t\tereport(LOG,\n\t\t\t\t\t(errmsg(\"DNSServiceRegister() failed: error code %ld\",\n\t\t\t\t\t\t\t(long) err)));\n\n\t\t/*\n\t\t * We don't bother to read the mDNS daemon's reply, and we expect that\n\t\t * it will automatically terminate our registration when the socket is\n\t\t * closed at postmaster termination.  So there's nothing more to be\n\t\t * done here.  However, the bonjour_sdref is kept around so that\n\t\t * forked children can close their copies of the socket.\n\t\t */\n\t}\n#endif\n\n#ifdef HAVE_UNIX_SOCKETS\n\tif (Unix_socket_directories)\n\t{\n\t\tchar\t   *rawstring;\n\t\tList\t   *elemlist;\n\t\tListCell   *l;\n\t\tint\t\t\tsuccess = 0;\n\n\t\t/* Need a modifiable copy of Unix_socket_directories */\n\t\trawstring = pstrdup(Unix_socket_directories);\n\n\t\t/* Parse string into list of directories */\n\t\tif (!SplitDirectoriesString(rawstring, ',', &elemlist))\n\t\t{\n\t\t\t/* syntax error in list */\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"invalid list syntax in parameter \\\"%s\\\"\",\n\t\t\t\t\t\t\t\"unix_socket_directories\")));\n\t\t}\n\n\t\tforeach(l, elemlist)\n\t\t{\n\t\t\tchar\t   *socketdir = (char *) lfirst(l);\n\n\t\t\tstatus = StreamServerPort(AF_UNIX, NULL,\n\t\t\t\t\t\t\t\t\t  (unsigned short) PostPortNumber,\n\t\t\t\t\t\t\t\t\t  socketdir,\n\t\t\t\t\t\t\t\t\t  ListenSocket, MAXLISTEN);\n\n\t\t\tif (status == STATUS_OK)\n\t\t\t{\n\t\t\t\tsuccess++;\n\t\t\t\t/* record the first successful Unix socket in lockfile */\n\t\t\t\tif (success == 1)\n\t\t\t\t\tAddToDataDirLockFile(LOCK_FILE_LINE_SOCKET_DIR, socketdir);\n\t\t\t}\n\t\t\telse\n\t\t\t\tereport(WARNING,\n\t\t\t\t\t\t(errmsg(\"could not create Unix-domain socket in directory \\\"%s\\\"\",\n\t\t\t\t\t\t\t\tsocketdir)));\n\t\t}\n\n\t\tif (!success && elemlist != NIL)\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errmsg(\"could not create any Unix-domain sockets\")));\n\n\t\tlist_free_deep(elemlist);\n\t\tpfree(rawstring);\n\t}\n#endif\n\n\t/*\n\t * check that we have some socket to listen on\n\t */\n\tif (ListenSocket[0] == PGINVALID_SOCKET)\n\t\tereport(FATAL,\n\t\t\t\t(errmsg(\"no socket created for listening\")));\n\n\t/*\n\t * If no valid TCP ports, write an empty line for listen address,\n\t * indicating the Unix socket must be used.  Note that this line is not\n\t * added to the lock file until there is a socket backing it.\n\t */\n\tif (!listen_addr_saved)\n\t\tAddToDataDirLockFile(LOCK_FILE_LINE_LISTEN_ADDR, \"\");\n\n\t/*\n\t * Record postmaster options.  We delay this till now to avoid recording\n\t * bogus options (eg, unusable port number).\n\t */\n\tif (!CreateOptsFile(argc, argv, my_exec_path))\n\t\tExitPostmaster(1);\n\n\t/*\n\t * Write the external PID file if requested\n\t */\n\tif (external_pid_file)\n\t{\n\t\tFILE\t   *fpidfile = fopen(external_pid_file, \"w\");\n\n\t\tif (fpidfile)\n\t\t{\n\t\t\tfprintf(fpidfile, \"%d\\n\", MyProcPid);\n\t\t\tfclose(fpidfile);\n\n\t\t\t/* Make PID file world readable */\n\t\t\tif (chmod(external_pid_file, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH) != 0)\n\t\t\t\twrite_stderr(\"%s: could not change permissions of external PID file \\\"%s\\\": %s\\n\",\n\t\t\t\t\t\t\t progname, external_pid_file, strerror(errno));\n\t\t}\n\t\telse\n\t\t\twrite_stderr(\"%s: could not write external PID file \\\"%s\\\": %s\\n\",\n\t\t\t\t\t\t progname, external_pid_file, strerror(errno));\n\n\t\ton_proc_exit(unlink_external_pid_file, 0);\n\t}\n\n\t/*\n\t * Remove old temporary files.  At this point there can be no other\n\t * Postgres processes running in this directory, so this should be safe.\n\t */\n\tRemovePgTempFiles();\n\n\t/*\n\t * Initialize stats collection subsystem (this does NOT start the\n\t * collector process!)\n\t */\n\tpgstat_init();\n\n\t/*\n\t * Initialize the autovacuum subsystem (again, no process start yet)\n\t */\n\tautovac_init();\n\n\t/*\n\t * Load configuration files for client authentication.\n\t */\n\tif (!load_hba())\n\t{\n\t\t/*\n\t\t * It makes no sense to continue if we fail to load the HBA file,\n\t\t * since there is no way to connect to the database in this case.\n\t\t */\n\t\tereport(FATAL,\n\t\t\t\t(errmsg(\"could not load pg_hba.conf\")));\n\t}\n\tif (!load_ident())\n\t{\n\t\t/*\n\t\t * We can start up without the IDENT file, although it means that you\n\t\t * cannot log in using any of the authentication methods that need a\n\t\t * user name mapping. load_ident() already logged the details of error\n\t\t * to the log.\n\t\t */\n\t}\n\n#ifdef HAVE_PTHREAD_IS_THREADED_NP\n\n\t/*\n\t * On macOS, libintl replaces setlocale() with a version that calls\n\t * CFLocaleCopyCurrent() when its second argument is \"\" and every relevant\n\t * environment variable is unset or empty.  CFLocaleCopyCurrent() makes\n\t * the process multithreaded.  The postmaster calls sigprocmask() and\n\t * calls fork() without an immediate exec(), both of which have undefined\n\t * behavior in a multithreaded program.  A multithreaded postmaster is the\n\t * normal case on Windows, which offers neither fork() nor sigprocmask().\n\t */\n\tif (pthread_is_threaded_np() != 0)\n\t\tereport(FATAL,\n\t\t\t\t(errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),\n\t\t\t\t errmsg(\"postmaster became multithreaded during startup\"),\n\t\t\t\t errhint(\"Set the LC_ALL environment variable to a valid locale.\")));\n#endif\n\n\t/*\n\t * Remember postmaster startup time\n\t */\n\tPgStartTime = GetCurrentTimestamp();\n\n\t/*\n\t * Report postmaster status in the postmaster.pid file, to allow pg_ctl to\n\t * see what's happening.\n\t */\n\tAddToDataDirLockFile(LOCK_FILE_LINE_PM_STATUS, PM_STATUS_STARTING);\n\n\t/* Start bgwriter and checkpointer so they can help with recovery */\n\tif (CheckpointerPID == 0)\n\t\tCheckpointerPID = StartCheckpointer();\n\tif (BgWriterPID == 0)\n\t\tBgWriterPID = StartBackgroundWriter();\n\n\t/*\n\t * We're ready to rock and roll...\n\t */\n\tStartupPID = StartupDataBase();\n\tAssert(StartupPID != 0);\n\tStartupStatus = STARTUP_RUNNING;\n\tpmState = PM_STARTUP;\n\n\t/* Some workers may be scheduled to start now */\n\tmaybe_start_bgworkers();\n\n\tstatus = ServerLoop();\n\n\t/*\n\t * ServerLoop probably shouldn't ever return, but if it does, close down.\n\t */\n\tExitPostmaster(status != STATUS_OK);\n\n\tabort();\t\t\t\t\t/* not reached */\n}\n\n\n/*\n * on_proc_exit callback to close server's listen sockets\n */\nstatic void\nCloseServerPorts(int status, Datum arg)\n{\n\tint\t\t\ti;\n\n\t/*\n\t * First, explicitly close all the socket FDs.  We used to just let this\n\t * happen implicitly at postmaster exit, but it's better to close them\n\t * before we remove the postmaster.pid lockfile; otherwise there's a race\n\t * condition if a new postmaster wants to re-use the TCP port number.\n\t */\n\tfor (i = 0; i < MAXLISTEN; i++)\n\t{\n\t\tif (ListenSocket[i] != PGINVALID_SOCKET)\n\t\t{\n\t\t\tStreamClose(ListenSocket[i]);\n\t\t\tListenSocket[i] = PGINVALID_SOCKET;\n\t\t}\n\t}\n\n\t/*\n\t * Next, remove any filesystem entries for Unix sockets.  To avoid race\n\t * conditions against incoming postmasters, this must happen after closing\n\t * the sockets and before removing lock files.\n\t */\n\tRemoveSocketFiles();\n\n\t/*\n\t * We don't do anything about socket lock files here; those will be\n\t * removed in a later on_proc_exit callback.\n\t */\n}\n\n/*\n * on_proc_exit callback to delete external_pid_file\n */\nstatic void\nunlink_external_pid_file(int status, Datum arg)\n{\n\tif (external_pid_file)\n\t\tunlink(external_pid_file);\n}\n\n\n/*\n * Compute and check the directory paths to files that are part of the\n * installation (as deduced from the postgres executable's own location)\n */\nstatic void\ngetInstallationPaths(const char *argv0)\n{\n\tDIR\t\t   *pdir;\n\n\t/* Locate the postgres executable itself */\n\tif (find_my_exec(argv0, my_exec_path) < 0)\n\t\tereport(FATAL,\n\t\t\t\t(errmsg(\"%s: could not locate my own executable path\", argv0)));\n\n#ifdef EXEC_BACKEND\n\t/* Locate executable backend before we change working directory */\n\tif (find_other_exec(argv0, \"postgres\", PG_BACKEND_VERSIONSTR,\n\t\t\t\t\t\tpostgres_exec_path) < 0)\n\t\tereport(FATAL,\n\t\t\t\t(errmsg(\"%s: could not locate matching postgres executable\",\n\t\t\t\t\t\targv0)));\n#endif\n\n\t/*\n\t * Locate the pkglib directory --- this has to be set early in case we try\n\t * to load any modules from it in response to postgresql.conf entries.\n\t */\n\tget_pkglib_path(my_exec_path, pkglib_path);\n\n\t/*\n\t * Verify that there's a readable directory there; otherwise the Postgres\n\t * installation is incomplete or corrupt.  (A typical cause of this\n\t * failure is that the postgres executable has been moved or hardlinked to\n\t * some directory that's not a sibling of the installation lib/\n\t * directory.)\n\t */\n\tpdir = AllocateDir(pkglib_path);\n\tif (pdir == NULL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not open directory \\\"%s\\\": %m\",\n\t\t\t\t\t\tpkglib_path),\n\t\t\t\t errhint(\"This may indicate an incomplete PostgreSQL installation, or that the file \\\"%s\\\" has been moved away from its proper location.\",\n\t\t\t\t\t\t my_exec_path)));\n\tFreeDir(pdir);\n\n\t/*\n\t * XXX is it worth similarly checking the share/ directory?  If the lib/\n\t * directory is there, then share/ probably is too.\n\t */\n}\n\n/*\n * Check that pg_control exists in the correct location in the data directory.\n *\n * No attempt is made to validate the contents of pg_control here.  This is\n * just a sanity check to see if we are looking at a real data directory.\n */\nstatic void\ncheckControlFile(void)\n{\n\tchar\t\tpath[MAXPGPATH];\n\tFILE\t   *fp;\n\n\tsnprintf(path, sizeof(path), \"%s/global/pg_control\", DataDir);\n\n\tfp = AllocateFile(path, PG_BINARY_R);\n\tif (fp == NULL)\n\t{\n\t\twrite_stderr(\"%s: could not find the database system\\n\"\n\t\t\t\t\t \"Expected to find it in the directory \\\"%s\\\",\\n\"\n\t\t\t\t\t \"but could not open file \\\"%s\\\": %s\\n\",\n\t\t\t\t\t progname, DataDir, path, strerror(errno));\n\t\tExitPostmaster(2);\n\t}\n\tFreeFile(fp);\n}\n\n/*\n * Determine how long should we let ServerLoop sleep.\n *\n * In normal conditions we wait at most one minute, to ensure that the other\n * background tasks handled by ServerLoop get done even when no requests are\n * arriving.  However, if there are background workers waiting to be started,\n * we don't actually sleep so that they are quickly serviced.  Other exception\n * cases are as shown in the code.\n */\nstatic void\nDetermineSleepTime(struct timeval *timeout)\n{\n\tTimestampTz next_wakeup = 0;\n\n\t/*\n\t * Normal case: either there are no background workers at all, or we're in\n\t * a shutdown sequence (during which we ignore bgworkers altogether).\n\t */\n\tif (Shutdown > NoShutdown ||\n\t\t(!StartWorkerNeeded && !HaveCrashedWorker))\n\t{\n\t\tif (AbortStartTime != 0)\n\t\t{\n\t\t\t/* time left to abort; clamp to 0 in case it already expired */\n\t\t\ttimeout->tv_sec = SIGKILL_CHILDREN_AFTER_SECS -\n\t\t\t\t(time(NULL) - AbortStartTime);\n\t\t\ttimeout->tv_sec = Max(timeout->tv_sec, 0);\n\t\t\ttimeout->tv_usec = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttimeout->tv_sec = 60;\n\t\t\ttimeout->tv_usec = 0;\n\t\t}\n\t\treturn;\n\t}\n\n\tif (StartWorkerNeeded)\n\t{\n\t\ttimeout->tv_sec = 0;\n\t\ttimeout->tv_usec = 0;\n\t\treturn;\n\t}\n\n\tif (HaveCrashedWorker)\n\t{\n\t\tslist_mutable_iter siter;\n\n\t\t/*\n\t\t * When there are crashed bgworkers, we sleep just long enough that\n\t\t * they are restarted when they request to be.  Scan the list to\n\t\t * determine the minimum of all wakeup times according to most recent\n\t\t * crash time and requested restart interval.\n\t\t */\n\t\tslist_foreach_modify(siter, &BackgroundWorkerList)\n\t\t{\n\t\t\tRegisteredBgWorker *rw;\n\t\t\tTimestampTz this_wakeup;\n\n\t\t\trw = slist_container(RegisteredBgWorker, rw_lnode, siter.cur);\n\n\t\t\tif (rw->rw_crashed_at == 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (rw->rw_worker.bgw_restart_time == BGW_NEVER_RESTART\n\t\t\t\t|| rw->rw_terminate)\n\t\t\t{\n\t\t\t\tForgetBackgroundWorker(&siter);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthis_wakeup = TimestampTzPlusMilliseconds(rw->rw_crashed_at,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  1000L * rw->rw_worker.bgw_restart_time);\n\t\t\tif (next_wakeup == 0 || this_wakeup < next_wakeup)\n\t\t\t\tnext_wakeup = this_wakeup;\n\t\t}\n\t}\n\n\tif (next_wakeup != 0)\n\t{\n\t\tlong\t\tsecs;\n\t\tint\t\t\tmicrosecs;\n\n\t\tTimestampDifference(GetCurrentTimestamp(), next_wakeup,\n\t\t\t\t\t\t\t&secs, &microsecs);\n\t\ttimeout->tv_sec = secs;\n\t\ttimeout->tv_usec = microsecs;\n\n\t\t/* Ensure we don't exceed one minute */\n\t\tif (timeout->tv_sec > 60)\n\t\t{\n\t\t\ttimeout->tv_sec = 60;\n\t\t\ttimeout->tv_usec = 0;\n\t\t}\n\t}\n\telse\n\t{\n\t\ttimeout->tv_sec = 60;\n\t\ttimeout->tv_usec = 0;\n\t}\n}\n\n/*\n * Main idle loop of postmaster\n *\n * NB: Needs to be called with signals blocked\n */\nstatic int\nServerLoop(void)\n{\n\tfd_set\t\treadmask;\n\tint\t\t\tnSockets;\n\ttime_t\t\tlast_lockfile_recheck_time,\n\t\t\t\tlast_touch_time;\n\n\tlast_lockfile_recheck_time = last_touch_time = time(NULL);\n\n\tnSockets = initMasks(&readmask);\n\n\tfor (;;)\n\t{\n\t\tfd_set\t\trmask;\n\t\tint\t\t\tselres;\n\t\ttime_t\t\tnow;\n\n\t\t/*\n\t\t * Wait for a connection request to arrive.\n\t\t *\n\t\t * We block all signals except while sleeping. That makes it safe for\n\t\t * signal handlers, which again block all signals while executing, to\n\t\t * do nontrivial work.\n\t\t *\n\t\t * If we are in PM_WAIT_DEAD_END state, then we don't want to accept\n\t\t * any new connections, so we don't call select(), and just sleep.\n\t\t */\n\t\tmemcpy((char *) &rmask, (char *) &readmask, sizeof(fd_set));\n\n\t\tif (pmState == PM_WAIT_DEAD_END)\n\t\t{\n\t\t\tPG_SETMASK(&UnBlockSig);\n\n\t\t\tpg_usleep(100000L); /* 100 msec seems reasonable */\n\t\t\tselres = 0;\n\n\t\t\tPG_SETMASK(&BlockSig);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* must set timeout each time; some OSes change it! */\n\t\t\tstruct timeval timeout;\n\n\t\t\t/* Needs to run with blocked signals! */\n\t\t\tDetermineSleepTime(&timeout);\n\n\t\t\tPG_SETMASK(&UnBlockSig);\n\n\t\t\tselres = select(nSockets, &rmask, NULL, NULL, &timeout);\n\n\t\t\tPG_SETMASK(&BlockSig);\n\t\t}\n\n\t\t/* Now check the select() result */\n\t\tif (selres < 0)\n\t\t{\n\t\t\tif (errno != EINTR && errno != EWOULDBLOCK)\n\t\t\t{\n\t\t\t\tereport(LOG,\n\t\t\t\t\t\t(errcode_for_socket_access(),\n\t\t\t\t\t\t errmsg(\"select() failed in postmaster: %m\")));\n\t\t\t\treturn STATUS_ERROR;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * New connection pending on any of our sockets? If so, fork a child\n\t\t * process to deal with it.\n\t\t */\n\t\tif (selres > 0)\n\t\t{\n\t\t\tint\t\t\ti;\n\n\t\t\tfor (i = 0; i < MAXLISTEN; i++)\n\t\t\t{\n\t\t\t\tif (ListenSocket[i] == PGINVALID_SOCKET)\n\t\t\t\t\tbreak;\n\t\t\t\tif (FD_ISSET(ListenSocket[i], &rmask))\n\t\t\t\t{\n\t\t\t\t\tPort\t   *port;\n\n\t\t\t\t\tport = ConnCreate(ListenSocket[i]);\n\t\t\t\t\tif (port)\n\t\t\t\t\t{\n\t\t\t\t\t\tBackendStartup(port);\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * We no longer need the open socket or port structure\n\t\t\t\t\t\t * in this process\n\t\t\t\t\t\t */\n\t\t\t\t\t\tStreamClose(port->sock);\n\t\t\t\t\t\tConnFree(port);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* If we have lost the log collector, try to start a new one */\n\t\tif (SysLoggerPID == 0 && Logging_collector)\n\t\t\tSysLoggerPID = SysLogger_Start();\n\n\t\t/*\n\t\t * If no background writer process is running, and we are not in a\n\t\t * state that prevents it, start one.  It doesn't matter if this\n\t\t * fails, we'll just try again later.  Likewise for the checkpointer.\n\t\t */\n\t\tif (pmState == PM_RUN || pmState == PM_RECOVERY ||\n\t\t\tpmState == PM_HOT_STANDBY || pmState == PM_STARTUP)\n\t\t{\n\t\t\tif (CheckpointerPID == 0)\n\t\t\t\tCheckpointerPID = StartCheckpointer();\n\t\t\tif (BgWriterPID == 0)\n\t\t\t\tBgWriterPID = StartBackgroundWriter();\n\t\t}\n\n\t\t/*\n\t\t * Likewise, if we have lost the walwriter process, try to start a new\n\t\t * one.  But this is needed only in normal operation (else we cannot\n\t\t * be writing any new WAL).\n\t\t */\n\t\tif (WalWriterPID == 0 && pmState == PM_RUN)\n\t\t\tWalWriterPID = StartWalWriter();\n\n\t\t/*\n\t\t * If we have lost the autovacuum launcher, try to start a new one. We\n\t\t * don't want autovacuum to run in binary upgrade mode because\n\t\t * autovacuum might update relfrozenxid for empty tables before the\n\t\t * physical files are put in place.\n\t\t */\n\t\tif (!IsBinaryUpgrade && AutoVacPID == 0 &&\n\t\t\t(AutoVacuumingActive() || start_autovac_launcher) &&\n\t\t\tpmState == PM_RUN)\n\t\t{\n\t\t\tAutoVacPID = StartAutoVacLauncher();\n\t\t\tif (AutoVacPID != 0)\n\t\t\t\tstart_autovac_launcher = false; /* signal processed */\n\t\t}\n\n\t\t/* If we have lost the stats collector, try to start a new one */\n\t\tif (PgStatPID == 0 &&\n\t\t\t(pmState == PM_RUN || pmState == PM_HOT_STANDBY))\n\t\t\tPgStatPID = pgstat_start();\n\n\t\t/* If we have lost the archiver, try to start a new one. */\n\t\tif (PgArchPID == 0 && PgArchStartupAllowed())\n\t\t\tPgArchPID = StartArchiver();\n\n\t\t/* If we need to signal the autovacuum launcher, do so now */\n\t\tif (avlauncher_needs_signal)\n\t\t{\n\t\t\tavlauncher_needs_signal = false;\n\t\t\tif (AutoVacPID != 0)\n\t\t\t\tkill(AutoVacPID, SIGUSR2);\n\t\t}\n\n\t\t/* If we need to start a WAL receiver, try to do that now */\n\t\tif (WalReceiverRequested)\n\t\t\tMaybeStartWalReceiver();\n\n\t\t/* Get other worker processes running, if needed */\n\t\tif (StartWorkerNeeded || HaveCrashedWorker)\n\t\t\tmaybe_start_bgworkers();\n\n#ifdef HAVE_PTHREAD_IS_THREADED_NP\n\n\t\t/*\n\t\t * With assertions enabled, check regularly for appearance of\n\t\t * additional threads.  All builds check at start and exit.\n\t\t */\n\t\tAssert(pthread_is_threaded_np() == 0);\n#endif\n\n\t\t/*\n\t\t * Lastly, check to see if it's time to do some things that we don't\n\t\t * want to do every single time through the loop, because they're a\n\t\t * bit expensive.  Note that there's up to a minute of slop in when\n\t\t * these tasks will be performed, since DetermineSleepTime() will let\n\t\t * us sleep at most that long; except for SIGKILL timeout which has\n\t\t * special-case logic there.\n\t\t */\n\t\tnow = time(NULL);\n\n\t\t/*\n\t\t * If we already sent SIGQUIT to children and they are slow to shut\n\t\t * down, it's time to send them SIGKILL.  This doesn't happen\n\t\t * normally, but under certain conditions backends can get stuck while\n\t\t * shutting down.  This is a last measure to get them unwedged.\n\t\t *\n\t\t * Note we also do this during recovery from a process crash.\n\t\t */\n\t\tif ((Shutdown >= ImmediateShutdown || (FatalError && !SendStop)) &&\n\t\t\tAbortStartTime != 0 &&\n\t\t\t(now - AbortStartTime) >= SIGKILL_CHILDREN_AFTER_SECS)\n\t\t{\n\t\t\t/* We were gentle with them before. Not anymore */\n\t\t\tereport(LOG,\n\t\t\t\t\t(errmsg(\"issuing SIGKILL to recalcitrant children\")));\n\t\t\tTerminateChildren(SIGKILL);\n\t\t\t/* reset flag so we don't SIGKILL again */\n\t\t\tAbortStartTime = 0;\n\t\t}\n\n\t\t/*\n\t\t * Once a minute, verify that postmaster.pid hasn't been removed or\n\t\t * overwritten.  If it has, we force a shutdown.  This avoids having\n\t\t * postmasters and child processes hanging around after their database\n\t\t * is gone, and maybe causing problems if a new database cluster is\n\t\t * created in the same place.  It also provides some protection\n\t\t * against a DBA foolishly removing postmaster.pid and manually\n\t\t * starting a new postmaster.  Data corruption is likely to ensue from\n\t\t * that anyway, but we can minimize the damage by aborting ASAP.\n\t\t */\n\t\tif (now - last_lockfile_recheck_time >= 1 * SECS_PER_MINUTE)\n\t\t{\n\t\t\tif (!RecheckDataDirLockFile())\n\t\t\t{\n\t\t\t\tereport(LOG,\n\t\t\t\t\t\t(errmsg(\"performing immediate shutdown because data directory lock file is invalid\")));\n\t\t\t\tkill(MyProcPid, SIGQUIT);\n\t\t\t}\n\t\t\tlast_lockfile_recheck_time = now;\n\t\t}\n\n\t\t/*\n\t\t * Touch Unix socket and lock files every 58 minutes, to ensure that\n\t\t * they are not removed by overzealous /tmp-cleaning tasks.  We assume\n\t\t * no one runs cleaners with cutoff times of less than an hour ...\n\t\t */\n\t\tif (now - last_touch_time >= 58 * SECS_PER_MINUTE)\n\t\t{\n\t\t\tTouchSocketFiles();\n\t\t\tTouchSocketLockFiles();\n\t\t\tlast_touch_time = now;\n\t\t}\n\t}\n}\n\n/*\n * Initialise the masks for select() for the ports we are listening on.\n * Return the number of sockets to listen on.\n */\nstatic int\ninitMasks(fd_set *rmask)\n{\n\tint\t\t\tmaxsock = -1;\n\tint\t\t\ti;\n\n\tFD_ZERO(rmask);\n\n\tfor (i = 0; i < MAXLISTEN; i++)\n\t{\n\t\tint\t\t\tfd = ListenSocket[i];\n\n\t\tif (fd == PGINVALID_SOCKET)\n\t\t\tbreak;\n\t\tFD_SET(fd, rmask);\n\n\t\tif (fd > maxsock)\n\t\t\tmaxsock = fd;\n\t}\n\n\treturn maxsock + 1;\n}\n\n\n/*\n * Read a client's startup packet and do something according to it.\n *\n * Returns STATUS_OK or STATUS_ERROR, or might call ereport(FATAL) and\n * not return at all.\n *\n * (Note that ereport(FATAL) stuff is sent to the client, so only use it\n * if that's what you want.  Return STATUS_ERROR if you don't want to\n * send anything to the client, which would typically be appropriate\n * if we detect a communications failure.)\n *\n * Set ssl_done and/or gss_done when negotiation of an encrypted layer\n * (currently, TLS or GSSAPI) is completed. A successful negotiation of either\n * encryption layer sets both flags, but a rejected negotiation sets only the\n * flag for that layer, since the client may wish to try the other one. We\n * should make no assumption here about the order in which the client may make\n * requests.\n */\nstatic int\nProcessStartupPacket(Port *port, bool ssl_done, bool gss_done)\n{\n\tint32\t\tlen;\n\tchar\t   *buf;\n\tProtocolVersion proto;\n\tMemoryContext oldcontext;\n\n\tpq_startmsgread();\n\n\t/*\n\t * Grab the first byte of the length word separately, so that we can tell\n\t * whether we have no data at all or an incomplete packet.  (This might\n\t * sound inefficient, but it's not really, because of buffering in\n\t * pqcomm.c.)\n\t */\n\tif (pq_getbytes((char *) &len, 1) == EOF)\n\t{\n\t\t/*\n\t\t * If we get no data at all, don't clutter the log with a complaint;\n\t\t * such cases often occur for legitimate reasons.  An example is that\n\t\t * we might be here after responding to NEGOTIATE_SSL_CODE, and if the\n\t\t * client didn't like our response, it'll probably just drop the\n\t\t * connection.  Service-monitoring software also often just opens and\n\t\t * closes a connection without sending anything.  (So do port\n\t\t * scanners, which may be less benign, but it's not really our job to\n\t\t * notice those.)\n\t\t */\n\t\treturn STATUS_ERROR;\n\t}\n\n\tif (pq_getbytes(((char *) &len) + 1, 3) == EOF)\n\t{\n\t\t/* Got a partial length word, so bleat about that */\n\t\tif (!ssl_done && !gss_done)\n\t\t\tereport(COMMERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROTOCOL_VIOLATION),\n\t\t\t\t\t errmsg(\"incomplete startup packet\")));\n\t\treturn STATUS_ERROR;\n\t}\n\n\tlen = pg_ntoh32(len);\n\tlen -= 4;\n\n\tif (len < (int32) sizeof(ProtocolVersion) ||\n\t\tlen > MAX_STARTUP_PACKET_LENGTH)\n\t{\n\t\tereport(COMMERROR,\n\t\t\t\t(errcode(ERRCODE_PROTOCOL_VIOLATION),\n\t\t\t\t errmsg(\"invalid length of startup packet\")));\n\t\treturn STATUS_ERROR;\n\t}\n\n\t/*\n\t * Allocate space to hold the startup packet, plus one extra byte that's\n\t * initialized to be zero.  This ensures we will have null termination of\n\t * all strings inside the packet.\n\t */\n\tbuf = palloc(len + 1);\n\tbuf[len] = '\\0';\n\n\tif (pq_getbytes(buf, len) == EOF)\n\t{\n\t\tereport(COMMERROR,\n\t\t\t\t(errcode(ERRCODE_PROTOCOL_VIOLATION),\n\t\t\t\t errmsg(\"incomplete startup packet\")));\n\t\treturn STATUS_ERROR;\n\t}\n\tpq_endmsgread();\n\n\t/*\n\t * The first field is either a protocol version number or a special\n\t * request code.\n\t */\n\tport->proto = proto = pg_ntoh32(*((ProtocolVersion *) buf));\n\n\tif (proto == CANCEL_REQUEST_CODE)\n\t{\n\t\tprocessCancelRequest(port, buf);\n\t\t/* Not really an error, but we don't want to proceed further */\n\t\treturn STATUS_ERROR;\n\t}\n\n\tif (proto == NEGOTIATE_SSL_CODE && !ssl_done)\n\t{\n\t\tchar\t\tSSLok;\n\n#ifdef USE_SSL\n\t\t/* No SSL when disabled or on Unix sockets */\n\t\tif (!LoadedSSL || IS_AF_UNIX(port->laddr.addr.ss_family))\n\t\t\tSSLok = 'N';\n\t\telse\n\t\t\tSSLok = 'S';\t\t/* Support for SSL */\n#else\n\t\tSSLok = 'N';\t\t\t/* No support for SSL */\n#endif\n\nretry1:\n\t\tif (send(port->sock, &SSLok, 1, 0) != 1)\n\t\t{\n\t\t\tif (errno == EINTR)\n\t\t\t\tgoto retry1;\t/* if interrupted, just retry */\n\t\t\tereport(COMMERROR,\n\t\t\t\t\t(errcode_for_socket_access(),\n\t\t\t\t\t errmsg(\"failed to send SSL negotiation response: %m\")));\n\t\t\treturn STATUS_ERROR;\t/* close the connection */\n\t\t}\n\n#ifdef USE_SSL\n\t\tif (SSLok == 'S' && secure_open_server(port) == -1)\n\t\t\treturn STATUS_ERROR;\n#endif\n\n\t\t/*\n\t\t * regular startup packet, cancel, etc packet should follow, but not\n\t\t * another SSL negotiation request, and a GSS request should only\n\t\t * follow if SSL was rejected (client may negotiate in either order)\n\t\t */\n\t\treturn ProcessStartupPacket(port, true, SSLok == 'S');\n\t}\n\telse if (proto == NEGOTIATE_GSS_CODE && !gss_done)\n\t{\n\t\tchar\t\tGSSok = 'N';\n\n#ifdef ENABLE_GSS\n\t\t/* No GSSAPI encryption when on Unix socket */\n\t\tif (!IS_AF_UNIX(port->laddr.addr.ss_family))\n\t\t\tGSSok = 'G';\n#endif\n\n\t\twhile (send(port->sock, &GSSok, 1, 0) != 1)\n\t\t{\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tereport(COMMERROR,\n\t\t\t\t\t(errcode_for_socket_access(),\n\t\t\t\t\t errmsg(\"failed to send GSSAPI negotiation response: %m\")));\n\t\t\treturn STATUS_ERROR;\t/* close the connection */\n\t\t}\n\n#ifdef ENABLE_GSS\n\t\tif (GSSok == 'G' && secure_open_gssapi(port) == -1)\n\t\t\treturn STATUS_ERROR;\n#endif\n\n\t\t/*\n\t\t * regular startup packet, cancel, etc packet should follow, but not\n\t\t * another GSS negotiation request, and an SSL request should only\n\t\t * follow if GSS was rejected (client may negotiate in either order)\n\t\t */\n\t\treturn ProcessStartupPacket(port, GSSok == 'G', true);\n\t}\n\n\t/* Could add additional special packet types here */\n\n\t/*\n\t * Set FrontendProtocol now so that ereport() knows what format to send if\n\t * we fail during startup.\n\t */\n\tFrontendProtocol = proto;\n\n\t/* Check that the major protocol version is in range. */\n\tif (PG_PROTOCOL_MAJOR(proto) < PG_PROTOCOL_MAJOR(PG_PROTOCOL_EARLIEST) ||\n\t\tPG_PROTOCOL_MAJOR(proto) > PG_PROTOCOL_MAJOR(PG_PROTOCOL_LATEST))\n\t\tereport(FATAL,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"unsupported frontend protocol %u.%u: server supports %u.0 to %u.%u\",\n\t\t\t\t\t\tPG_PROTOCOL_MAJOR(proto), PG_PROTOCOL_MINOR(proto),\n\t\t\t\t\t\tPG_PROTOCOL_MAJOR(PG_PROTOCOL_EARLIEST),\n\t\t\t\t\t\tPG_PROTOCOL_MAJOR(PG_PROTOCOL_LATEST),\n\t\t\t\t\t\tPG_PROTOCOL_MINOR(PG_PROTOCOL_LATEST))));\n\n\t/*\n\t * Now fetch parameters out of startup packet and save them into the Port\n\t * structure.  All data structures attached to the Port struct must be\n\t * allocated in TopMemoryContext so that they will remain available in a\n\t * running backend (even after PostmasterContext is destroyed).  We need\n\t * not worry about leaking this storage on failure, since we aren't in the\n\t * postmaster process anymore.\n\t */\n\toldcontext = MemoryContextSwitchTo(TopMemoryContext);\n\n\t/* Handle protocol version 3 startup packet */\n\t{\n\t\tint32\t\toffset = sizeof(ProtocolVersion);\n\t\tList\t   *unrecognized_protocol_options = NIL;\n\n\t\t/*\n\t\t * Scan packet body for name/option pairs.  We can assume any string\n\t\t * beginning within the packet body is null-terminated, thanks to\n\t\t * zeroing extra byte above.\n\t\t */\n\t\tport->guc_options = NIL;\n\n\t\twhile (offset < len)\n\t\t{\n\t\t\tchar\t   *nameptr = buf + offset;\n\t\t\tint32\t\tvaloffset;\n\t\t\tchar\t   *valptr;\n\n\t\t\tif (*nameptr == '\\0')\n\t\t\t\tbreak;\t\t\t/* found packet terminator */\n\t\t\tvaloffset = offset + strlen(nameptr) + 1;\n\t\t\tif (valoffset >= len)\n\t\t\t\tbreak;\t\t\t/* missing value, will complain below */\n\t\t\tvalptr = buf + valoffset;\n\n\t\t\tif (strcmp(nameptr, \"database\") == 0)\n\t\t\t\tport->database_name = pstrdup(valptr);\n\t\t\telse if (strcmp(nameptr, \"user\") == 0)\n\t\t\t\tport->user_name = pstrdup(valptr);\n\t\t\telse if (strcmp(nameptr, \"options\") == 0)\n\t\t\t\tport->cmdline_options = pstrdup(valptr);\n\t\t\telse if (strcmp(nameptr, \"replication\") == 0)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Due to backward compatibility concerns the replication\n\t\t\t\t * parameter is a hybrid beast which allows the value to be\n\t\t\t\t * either boolean or the string 'database'. The latter\n\t\t\t\t * connects to a specific database which is e.g. required for\n\t\t\t\t * logical decoding while.\n\t\t\t\t */\n\t\t\t\tif (strcmp(valptr, \"database\") == 0)\n\t\t\t\t{\n\t\t\t\t\tam_walsender = true;\n\t\t\t\t\tam_db_walsender = true;\n\t\t\t\t}\n\t\t\t\telse if (!parse_bool(valptr, &am_walsender))\n\t\t\t\t\tereport(FATAL,\n\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t\t errmsg(\"invalid value for parameter \\\"%s\\\": \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t\t\"replication\",\n\t\t\t\t\t\t\t\t\tvalptr),\n\t\t\t\t\t\t\t errhint(\"Valid values are: \\\"false\\\", 0, \\\"true\\\", 1, \\\"database\\\".\")));\n\t\t\t}\n\t\t\telse if (strncmp(nameptr, \"_pq_.\", 5) == 0)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Any option beginning with _pq_. is reserved for use as a\n\t\t\t\t * protocol-level option, but at present no such options are\n\t\t\t\t * defined.\n\t\t\t\t */\n\t\t\t\tunrecognized_protocol_options =\n\t\t\t\t\tlappend(unrecognized_protocol_options, pstrdup(nameptr));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Assume it's a generic GUC option */\n\t\t\t\tport->guc_options = lappend(port->guc_options,\n\t\t\t\t\t\t\t\t\t\t\tpstrdup(nameptr));\n\t\t\t\tport->guc_options = lappend(port->guc_options,\n\t\t\t\t\t\t\t\t\t\t\tpstrdup(valptr));\n\n\t\t\t\t/*\n\t\t\t\t * Copy application_name to port if we come across it.  This\n\t\t\t\t * is done so we can log the application_name in the\n\t\t\t\t * connection authorization message.  Note that the GUC would\n\t\t\t\t * be used but we haven't gone through GUC setup yet.\n\t\t\t\t */\n\t\t\t\tif (strcmp(nameptr, \"application_name\") == 0)\n\t\t\t\t{\n\t\t\t\t\tchar\t   *tmp_app_name = pstrdup(valptr);\n\n\t\t\t\t\tpg_clean_ascii(tmp_app_name);\n\n\t\t\t\t\tport->application_name = tmp_app_name;\n\t\t\t\t}\n\t\t\t}\n\t\t\toffset = valoffset + strlen(valptr) + 1;\n\t\t}\n\n\t\t/*\n\t\t * If we didn't find a packet terminator exactly at the end of the\n\t\t * given packet length, complain.\n\t\t */\n\t\tif (offset != len - 1)\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_PROTOCOL_VIOLATION),\n\t\t\t\t\t errmsg(\"invalid startup packet layout: expected terminator as last byte\")));\n\n\t\t/*\n\t\t * If the client requested a newer protocol version or if the client\n\t\t * requested any protocol options we didn't recognize, let them know\n\t\t * the newest minor protocol version we do support and the names of\n\t\t * any unrecognized options.\n\t\t */\n\t\tif (PG_PROTOCOL_MINOR(proto) > PG_PROTOCOL_MINOR(PG_PROTOCOL_LATEST) ||\n\t\t\tunrecognized_protocol_options != NIL)\n\t\t\tSendNegotiateProtocolVersion(unrecognized_protocol_options);\n\t}\n\n\t/* Check a user name was given. */\n\tif (port->user_name == NULL || port->user_name[0] == '\\0')\n\t\tereport(FATAL,\n\t\t\t\t(errcode(ERRCODE_INVALID_AUTHORIZATION_SPECIFICATION),\n\t\t\t\t errmsg(\"no PostgreSQL user name specified in startup packet\")));\n\n\t/* The database defaults to the user name. */\n\tif (port->database_name == NULL || port->database_name[0] == '\\0')\n\t\tport->database_name = pstrdup(port->user_name);\n\n\tif (Db_user_namespace)\n\t{\n\t\t/*\n\t\t * If user@, it is a global user, remove '@'. We only want to do this\n\t\t * if there is an '@' at the end and no earlier in the user string or\n\t\t * they may fake as a local user of another database attaching to this\n\t\t * database.\n\t\t */\n\t\tif (strchr(port->user_name, '@') ==\n\t\t\tport->user_name + strlen(port->user_name) - 1)\n\t\t\t*strchr(port->user_name, '@') = '\\0';\n\t\telse\n\t\t{\n\t\t\t/* Append '@' and dbname */\n\t\t\tport->user_name = psprintf(\"%s@%s\", port->user_name, port->database_name);\n\t\t}\n\t}\n\n\t/*\n\t * Truncate given database and user names to length of a Postgres name.\n\t * This avoids lookup failures when overlength names are given.\n\t */\n\tif (strlen(port->database_name) >= NAMEDATALEN)\n\t\tport->database_name[NAMEDATALEN - 1] = '\\0';\n\tif (strlen(port->user_name) >= NAMEDATALEN)\n\t\tport->user_name[NAMEDATALEN - 1] = '\\0';\n\n\tif (am_walsender)\n\t\tMyBackendType = B_WAL_SENDER;\n\telse\n\t\tMyBackendType = B_BACKEND;\n\n\t/*\n\t * Normal walsender backends, e.g. for streaming replication, are not\n\t * connected to a particular database. But walsenders used for logical\n\t * replication need to connect to a specific database. We allow streaming\n\t * replication commands to be issued even if connected to a database as it\n\t * can make sense to first make a basebackup and then stream changes\n\t * starting from that.\n\t */\n\tif (am_walsender && !am_db_walsender)\n\t\tport->database_name[0] = '\\0';\n\n\t/*\n\t * Done putting stuff in TopMemoryContext.\n\t */\n\tMemoryContextSwitchTo(oldcontext);\n\n\t/*\n\t * If we're going to reject the connection due to database state, say so\n\t * now instead of wasting cycles on an authentication exchange. (This also\n\t * allows a pg_ping utility to be written.)\n\t */\n\tswitch (port->canAcceptConnections)\n\t{\n\t\tcase CAC_STARTUP:\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_CANNOT_CONNECT_NOW),\n\t\t\t\t\t errmsg(\"the database system is starting up\")));\n\t\t\tbreak;\n\t\tcase CAC_NOTCONSISTENT:\n\t\t\tif (EnableHotStandby)\n\t\t\t\tereport(FATAL,\n\t\t\t\t\t\t(errcode(ERRCODE_CANNOT_CONNECT_NOW),\n\t\t\t\t\t\t errmsg(\"the database system is not yet accepting connections\"),\n\t\t\t\t\t\t errdetail(\"Consistent recovery state has not been yet reached.\")));\n\t\t\telse\n\t\t\t\tereport(FATAL,\n\t\t\t\t\t\t(errcode(ERRCODE_CANNOT_CONNECT_NOW),\n\t\t\t\t\t\t errmsg(\"the database system is not accepting connections\"),\n\t\t\t\t\t\t errdetail(\"Hot standby mode is disabled.\")));\n\t\t\tbreak;\n\t\tcase CAC_SHUTDOWN:\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_CANNOT_CONNECT_NOW),\n\t\t\t\t\t errmsg(\"the database system is shutting down\")));\n\t\t\tbreak;\n\t\tcase CAC_RECOVERY:\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_CANNOT_CONNECT_NOW),\n\t\t\t\t\t errmsg(\"the database system is in recovery mode\")));\n\t\t\tbreak;\n\t\tcase CAC_TOOMANY:\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_TOO_MANY_CONNECTIONS),\n\t\t\t\t\t errmsg(\"sorry, too many clients already\")));\n\t\t\tbreak;\n\t\tcase CAC_SUPERUSER:\n\t\t\t/* OK for now, will check in InitPostgres */\n\t\t\tbreak;\n\t\tcase CAC_OK:\n\t\t\tbreak;\n\t}\n\n\treturn STATUS_OK;\n}\n\n/*\n * Send a NegotiateProtocolVersion to the client.  This lets the client know\n * that they have requested a newer minor protocol version than we are able\n * to speak.  We'll speak the highest version we know about; the client can,\n * of course, abandon the connection if that's a problem.\n *\n * We also include in the response a list of protocol options we didn't\n * understand.  This allows clients to include optional parameters that might\n * be present either in newer protocol versions or third-party protocol\n * extensions without fear of having to reconnect if those options are not\n * understood, while at the same time making certain that the client is aware\n * of which options were actually accepted.\n */\nstatic void\nSendNegotiateProtocolVersion(List *unrecognized_protocol_options)\n{\n\tStringInfoData buf;\n\tListCell   *lc;\n\n\tpq_beginmessage(&buf, 'v'); /* NegotiateProtocolVersion */\n\tpq_sendint32(&buf, PG_PROTOCOL_LATEST);\n\tpq_sendint32(&buf, list_length(unrecognized_protocol_options));\n\tforeach(lc, unrecognized_protocol_options)\n\t\tpq_sendstring(&buf, lfirst(lc));\n\tpq_endmessage(&buf);\n\n\t/* no need to flush, some other message will follow */\n}\n\n/*\n * The client has sent a cancel request packet, not a normal\n * start-a-new-connection packet.  Perform the necessary processing.\n * Nothing is sent back to the client.\n */\nstatic void\nprocessCancelRequest(Port *port, void *pkt)\n{\n\tCancelRequestPacket *canc = (CancelRequestPacket *) pkt;\n\tint\t\t\tbackendPID;\n\tint32\t\tcancelAuthCode;\n\tBackend    *bp;\n\n#ifndef EXEC_BACKEND\n\tdlist_iter\titer;\n#else\n\tint\t\t\ti;\n#endif\n\n\tbackendPID = (int) pg_ntoh32(canc->backendPID);\n\tcancelAuthCode = (int32) pg_ntoh32(canc->cancelAuthCode);\n\n\t/*\n\t * See if we have a matching backend.  In the EXEC_BACKEND case, we can no\n\t * longer access the postmaster's own backend list, and must rely on the\n\t * duplicate array in shared memory.\n\t */\n#ifndef EXEC_BACKEND\n\tdlist_foreach(iter, &BackendList)\n\t{\n\t\tbp = dlist_container(Backend, elem, iter.cur);\n#else\n\tfor (i = MaxLivePostmasterChildren() - 1; i >= 0; i--)\n\t{\n\t\tbp = (Backend *) &ShmemBackendArray[i];\n#endif\n\t\tif (bp->pid == backendPID)\n\t\t{\n\t\t\tif (bp->cancel_key == cancelAuthCode)\n\t\t\t{\n\t\t\t\t/* Found a match; signal that backend to cancel current op */\n\t\t\t\tereport(DEBUG2,\n\t\t\t\t\t\t(errmsg_internal(\"processing cancel request: sending SIGINT to process %d\",\n\t\t\t\t\t\t\t\t\t\t backendPID)));\n\t\t\t\tsignal_child(bp->pid, SIGINT);\n\t\t\t}\n\t\t\telse\n\t\t\t\t/* Right PID, wrong key: no way, Jose */\n\t\t\t\tereport(LOG,\n\t\t\t\t\t\t(errmsg(\"wrong key in cancel request for process %d\",\n\t\t\t\t\t\t\t\tbackendPID)));\n\t\t\treturn;\n\t\t}\n#ifndef EXEC_BACKEND\t\t\t/* make GNU Emacs 26.1 see brace balance */\n\t}\n#else\n\t}\n#endif\n\n\t/* No matching backend */\n\tereport(LOG,\n\t\t\t(errmsg(\"PID %d in cancel request did not match any process\",\n\t\t\t\t\tbackendPID)));\n}\n\n/*\n * canAcceptConnections --- check to see if database state allows connections\n * of the specified type.  backend_type can be BACKEND_TYPE_NORMAL,\n * BACKEND_TYPE_AUTOVAC, or BACKEND_TYPE_BGWORKER.  (Note that we don't yet\n * know whether a NORMAL connection might turn into a walsender.)\n */\nstatic CAC_state\ncanAcceptConnections(int backend_type)\n{\n\tCAC_state\tresult = CAC_OK;\n\n\t/*\n\t * Can't start backends when in startup/shutdown/inconsistent recovery\n\t * state.  We treat autovac workers the same as user backends for this\n\t * purpose.  However, bgworkers are excluded from this test; we expect\n\t * bgworker_should_start_now() decided whether the DB state allows them.\n\t */\n\tif (pmState != PM_RUN && pmState != PM_HOT_STANDBY &&\n\t\tbackend_type != BACKEND_TYPE_BGWORKER)\n\t{\n\t\tif (Shutdown > NoShutdown)\n\t\t\treturn CAC_SHUTDOWN;\t/* shutdown is pending */\n\t\telse if (!FatalError && pmState == PM_STARTUP)\n\t\t\treturn CAC_STARTUP; /* normal startup */\n\t\telse if (!FatalError && pmState == PM_RECOVERY)\n\t\t\treturn CAC_NOTCONSISTENT;\t/* not yet at consistent recovery\n\t\t\t\t\t\t\t\t\t\t * state */\n\t\telse\n\t\t\treturn CAC_RECOVERY;\t/* else must be crash recovery */\n\t}\n\n\t/*\n\t * \"Smart shutdown\" restrictions are applied only to normal connections,\n\t * not to autovac workers or bgworkers.  When only superusers can connect,\n\t * we return CAC_SUPERUSER to indicate that superuserness must be checked\n\t * later.  Note that neither CAC_OK nor CAC_SUPERUSER can safely be\n\t * returned until we have checked for too many children.\n\t */\n\tif (connsAllowed != ALLOW_ALL_CONNS &&\n\t\tbackend_type == BACKEND_TYPE_NORMAL)\n\t{\n\t\tif (connsAllowed == ALLOW_SUPERUSER_CONNS)\n\t\t\tresult = CAC_SUPERUSER; /* allow superusers only */\n\t\telse\n\t\t\treturn CAC_SHUTDOWN;\t/* shutdown is pending */\n\t}\n\n\t/*\n\t * Don't start too many children.\n\t *\n\t * We allow more connections here than we can have backends because some\n\t * might still be authenticating; they might fail auth, or some existing\n\t * backend might exit before the auth cycle is completed.  The exact\n\t * MaxBackends limit is enforced when a new backend tries to join the\n\t * shared-inval backend array.\n\t *\n\t * The limit here must match the sizes of the per-child-process arrays;\n\t * see comments for MaxLivePostmasterChildren().\n\t */\n\tif (CountChildren(BACKEND_TYPE_ALL) >= MaxLivePostmasterChildren())\n\t\tresult = CAC_TOOMANY;\n\n\treturn result;\n}\n\n\n/*\n * ConnCreate -- create a local connection data structure\n *\n * Returns NULL on failure, other than out-of-memory which is fatal.\n */\nstatic Port *\nConnCreate(int serverFd)\n{\n\tPort\t   *port;\n\n\tif (!(port = (Port *) calloc(1, sizeof(Port))))\n\t{\n\t\tereport(LOG,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\")));\n\t\tExitPostmaster(1);\n\t}\n\n\tif (StreamConnection(serverFd, port) != STATUS_OK)\n\t{\n\t\tif (port->sock != PGINVALID_SOCKET)\n\t\t\tStreamClose(port->sock);\n\t\tConnFree(port);\n\t\treturn NULL;\n\t}\n\n\treturn port;\n}\n\n\n/*\n * ConnFree -- free a local connection data structure\n *\n * Caller has already closed the socket if any, so there's not much\n * to do here.\n */\nstatic void\nConnFree(Port *conn)\n{\n\tfree(conn);\n}\n\n\n/*\n * ClosePostmasterPorts -- close all the postmaster's open sockets\n *\n * This is called during child process startup to release file descriptors\n * that are not needed by that child process.  The postmaster still has\n * them open, of course.\n *\n * Note: we pass am_syslogger as a boolean because we don't want to set\n * the global variable yet when this is called.\n */\nvoid\nClosePostmasterPorts(bool am_syslogger)\n{\n\tint\t\t\ti;\n\n#ifndef WIN32\n\n\t/*\n\t * Close the write end of postmaster death watch pipe. It's important to\n\t * do this as early as possible, so that if postmaster dies, others won't\n\t * think that it's still running because we're holding the pipe open.\n\t */\n\tif (close(postmaster_alive_fds[POSTMASTER_FD_OWN]) != 0)\n\t\tereport(FATAL,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg_internal(\"could not close postmaster death monitoring pipe in child process: %m\")));\n\tpostmaster_alive_fds[POSTMASTER_FD_OWN] = -1;\n\t/* Notify fd.c that we released one pipe FD. */\n\tReleaseExternalFD();\n#endif\n\n\t/*\n\t * Close the postmaster's listen sockets.  These aren't tracked by fd.c,\n\t * so we don't call ReleaseExternalFD() here.\n\t */\n\tfor (i = 0; i < MAXLISTEN; i++)\n\t{\n\t\tif (ListenSocket[i] != PGINVALID_SOCKET)\n\t\t{\n\t\t\tStreamClose(ListenSocket[i]);\n\t\t\tListenSocket[i] = PGINVALID_SOCKET;\n\t\t}\n\t}\n\n\t/*\n\t * If using syslogger, close the read side of the pipe.  We don't bother\n\t * tracking this in fd.c, either.\n\t */\n\tif (!am_syslogger)\n\t{\n#ifndef WIN32\n\t\tif (syslogPipe[0] >= 0)\n\t\t\tclose(syslogPipe[0]);\n\t\tsyslogPipe[0] = -1;\n#else\n\t\tif (syslogPipe[0])\n\t\t\tCloseHandle(syslogPipe[0]);\n\t\tsyslogPipe[0] = 0;\n#endif\n\t}\n\n#ifdef USE_BONJOUR\n\t/* If using Bonjour, close the connection to the mDNS daemon */\n\tif (bonjour_sdref)\n\t\tclose(DNSServiceRefSockFD(bonjour_sdref));\n#endif\n}\n\n\n/*\n * InitProcessGlobals -- set MyProcPid, MyStartTime[stamp], random seeds\n *\n * Called early in the postmaster and every backend.\n */\nvoid\nInitProcessGlobals(void)\n{\n\tunsigned int rseed;\n\n\tMyProcPid = getpid();\n\tMyStartTimestamp = GetCurrentTimestamp();\n\tMyStartTime = timestamptz_to_time_t(MyStartTimestamp);\n\n\t/*\n\t * Set a different seed for random() in every process.  We want something\n\t * unpredictable, so if possible, use high-quality random bits for the\n\t * seed.  Otherwise, fall back to a seed based on timestamp and PID.\n\t */\n\tif (!pg_strong_random(&rseed, sizeof(rseed)))\n\t{\n\t\t/*\n\t\t * Since PIDs and timestamps tend to change more frequently in their\n\t\t * least significant bits, shift the timestamp left to allow a larger\n\t\t * total number of seeds in a given time period.  Since that would\n\t\t * leave only 20 bits of the timestamp that cycle every ~1 second,\n\t\t * also mix in some higher bits.\n\t\t */\n\t\trseed = ((uint64) MyProcPid) ^\n\t\t\t((uint64) MyStartTimestamp << 12) ^\n\t\t\t((uint64) MyStartTimestamp >> 20);\n\t}\n\tsrandom(rseed);\n}\n\n\n/*\n * reset_shared -- reset shared memory and semaphores\n */\nstatic void\nreset_shared(void)\n{\n\t/*\n\t * Create or re-create shared memory and semaphores.\n\t *\n\t * Note: in each \"cycle of life\" we will normally assign the same IPC keys\n\t * (if using SysV shmem and/or semas).  This helps ensure that we will\n\t * clean up dead IPC objects if the postmaster crashes and is restarted.\n\t */\n\tCreateSharedMemoryAndSemaphores();\n}\n\n\n/*\n * SIGHUP -- reread config files, and tell children to do same\n */\nstatic void\nSIGHUP_handler(SIGNAL_ARGS)\n{\n\tint\t\t\tsave_errno = errno;\n\n\t/*\n\t * We rely on the signal mechanism to have blocked all signals ... except\n\t * on Windows, which lacks sigaction(), so we have to do it manually.\n\t */\n#ifdef WIN32\n\tPG_SETMASK(&BlockSig);\n#endif\n\n\tif (Shutdown <= SmartShutdown)\n\t{\n\t\tereport(LOG,\n\t\t\t\t(errmsg(\"received SIGHUP, reloading configuration files\")));\n\t\tProcessConfigFile(PGC_SIGHUP);\n\t\tSignalChildren(SIGHUP);\n\t\tif (StartupPID != 0)\n\t\t\tsignal_child(StartupPID, SIGHUP);\n\t\tif (BgWriterPID != 0)\n\t\t\tsignal_child(BgWriterPID, SIGHUP);\n\t\tif (CheckpointerPID != 0)\n\t\t\tsignal_child(CheckpointerPID, SIGHUP);\n\t\tif (WalWriterPID != 0)\n\t\t\tsignal_child(WalWriterPID, SIGHUP);\n\t\tif (WalReceiverPID != 0)\n\t\t\tsignal_child(WalReceiverPID, SIGHUP);\n\t\tif (AutoVacPID != 0)\n\t\t\tsignal_child(AutoVacPID, SIGHUP);\n\t\tif (PgArchPID != 0)\n\t\t\tsignal_child(PgArchPID, SIGHUP);\n\t\tif (SysLoggerPID != 0)\n\t\t\tsignal_child(SysLoggerPID, SIGHUP);\n\t\tif (PgStatPID != 0)\n\t\t\tsignal_child(PgStatPID, SIGHUP);\n\n\t\t/* Reload authentication config files too */\n\t\tif (!load_hba())\n\t\t\tereport(LOG,\n\t\t\t/* translator: %s is a configuration file */\n\t\t\t\t\t(errmsg(\"%s was not reloaded\", \"pg_hba.conf\")));\n\n\t\tif (!load_ident())\n\t\t\tereport(LOG,\n\t\t\t\t\t(errmsg(\"%s was not reloaded\", \"pg_ident.conf\")));\n\n#ifdef USE_SSL\n\t\t/* Reload SSL configuration as well */\n\t\tif (EnableSSL)\n\t\t{\n\t\t\tif (secure_initialize(false) == 0)\n\t\t\t\tLoadedSSL = true;\n\t\t\telse\n\t\t\t\tereport(LOG,\n\t\t\t\t\t\t(errmsg(\"SSL configuration was not reloaded\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsecure_destroy();\n\t\t\tLoadedSSL = false;\n\t\t}\n#endif\n\n#ifdef EXEC_BACKEND\n\t\t/* Update the starting-point file for future children */\n\t\twrite_nondefault_variables(PGC_SIGHUP);\n#endif\n\t}\n\n#ifdef WIN32\n\tPG_SETMASK(&UnBlockSig);\n#endif\n\n\terrno = save_errno;\n}\n\n\n/*\n * pmdie -- signal handler for processing various postmaster signals.\n */\nstatic void\npmdie(SIGNAL_ARGS)\n{\n\tint\t\t\tsave_errno = errno;\n\n\t/*\n\t * We rely on the signal mechanism to have blocked all signals ... except\n\t * on Windows, which lacks sigaction(), so we have to do it manually.\n\t */\n#ifdef WIN32\n\tPG_SETMASK(&BlockSig);\n#endif\n\n\tereport(DEBUG2,\n\t\t\t(errmsg_internal(\"postmaster received signal %d\",\n\t\t\t\t\t\t\t postgres_signal_arg)));\n\n\tswitch (postgres_signal_arg)\n\t{\n\t\tcase SIGTERM:\n\n\t\t\t/*\n\t\t\t * Smart Shutdown:\n\t\t\t *\n\t\t\t * Wait for children to end their work, then shut down.\n\t\t\t */\n\t\t\tif (Shutdown >= SmartShutdown)\n\t\t\t\tbreak;\n\t\t\tShutdown = SmartShutdown;\n\t\t\tereport(LOG,\n\t\t\t\t\t(errmsg(\"received smart shutdown request\")));\n\n\t\t\t/* Report status */\n\t\t\tAddToDataDirLockFile(LOCK_FILE_LINE_PM_STATUS, PM_STATUS_STOPPING);\n#ifdef USE_SYSTEMD\n\t\t\tsd_notify(0, \"STOPPING=1\");\n#endif\n\n\t\t\t/*\n\t\t\t * If we reached normal running, we have to wait for any online\n\t\t\t * backup mode to end; otherwise go straight to waiting for client\n\t\t\t * backends to exit.  (The difference is that in the former state,\n\t\t\t * we'll still let in new superuser clients, so that somebody can\n\t\t\t * end the online backup mode.)  If already in PM_STOP_BACKENDS or\n\t\t\t * a later state, do not change it.\n\t\t\t */\n\t\t\tif (pmState == PM_RUN)\n\t\t\t\tconnsAllowed = ALLOW_SUPERUSER_CONNS;\n\t\t\telse if (pmState == PM_HOT_STANDBY)\n\t\t\t\tconnsAllowed = ALLOW_NO_CONNS;\n\t\t\telse if (pmState == PM_STARTUP || pmState == PM_RECOVERY)\n\t\t\t{\n\t\t\t\t/* There should be no clients, so proceed to stop children */\n\t\t\t\tpmState = PM_STOP_BACKENDS;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Now wait for online backup mode to end and backends to exit. If\n\t\t\t * that is already the case, PostmasterStateMachine will take the\n\t\t\t * next step.\n\t\t\t */\n\t\t\tPostmasterStateMachine();\n\t\t\tbreak;\n\n\t\tcase SIGINT:\n\n\t\t\t/*\n\t\t\t * Fast Shutdown:\n\t\t\t *\n\t\t\t * Abort all children with SIGTERM (rollback active transactions\n\t\t\t * and exit) and shut down when they are gone.\n\t\t\t */\n\t\t\tif (Shutdown >= FastShutdown)\n\t\t\t\tbreak;\n\t\t\tShutdown = FastShutdown;\n\t\t\tereport(LOG,\n\t\t\t\t\t(errmsg(\"received fast shutdown request\")));\n\n\t\t\t/* Report status */\n\t\t\tAddToDataDirLockFile(LOCK_FILE_LINE_PM_STATUS, PM_STATUS_STOPPING);\n#ifdef USE_SYSTEMD\n\t\t\tsd_notify(0, \"STOPPING=1\");\n#endif\n\n\t\t\tif (pmState == PM_STARTUP || pmState == PM_RECOVERY)\n\t\t\t{\n\t\t\t\t/* Just shut down background processes silently */\n\t\t\t\tpmState = PM_STOP_BACKENDS;\n\t\t\t}\n\t\t\telse if (pmState == PM_RUN ||\n\t\t\t\t\t pmState == PM_HOT_STANDBY)\n\t\t\t{\n\t\t\t\t/* Report that we're about to zap live client sessions */\n\t\t\t\tereport(LOG,\n\t\t\t\t\t\t(errmsg(\"aborting any active transactions\")));\n\t\t\t\tpmState = PM_STOP_BACKENDS;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * PostmasterStateMachine will issue any necessary signals, or\n\t\t\t * take the next step if no child processes need to be killed.\n\t\t\t */\n\t\t\tPostmasterStateMachine();\n\t\t\tbreak;\n\n\t\tcase SIGQUIT:\n\n\t\t\t/*\n\t\t\t * Immediate Shutdown:\n\t\t\t *\n\t\t\t * abort all children with SIGQUIT, wait for them to exit,\n\t\t\t * terminate remaining ones with SIGKILL, then exit without\n\t\t\t * attempt to properly shut down the data base system.\n\t\t\t */\n\t\t\tif (Shutdown >= ImmediateShutdown)\n\t\t\t\tbreak;\n\t\t\tShutdown = ImmediateShutdown;\n\t\t\tereport(LOG,\n\t\t\t\t\t(errmsg(\"received immediate shutdown request\")));\n\n\t\t\t/* Report status */\n\t\t\tAddToDataDirLockFile(LOCK_FILE_LINE_PM_STATUS, PM_STATUS_STOPPING);\n#ifdef USE_SYSTEMD\n\t\t\tsd_notify(0, \"STOPPING=1\");\n#endif\n\n\t\t\t/* tell children to shut down ASAP */\n\t\t\tSetQuitSignalReason(PMQUIT_FOR_STOP);\n\t\t\tTerminateChildren(SIGQUIT);\n\t\t\tpmState = PM_WAIT_BACKENDS;\n\n\t\t\t/* set stopwatch for them to die */\n\t\t\tAbortStartTime = time(NULL);\n\n\t\t\t/*\n\t\t\t * Now wait for backends to exit.  If there are none,\n\t\t\t * PostmasterStateMachine will take the next step.\n\t\t\t */\n\t\t\tPostmasterStateMachine();\n\t\t\tbreak;\n\t}\n\n#ifdef WIN32\n\tPG_SETMASK(&UnBlockSig);\n#endif\n\n\terrno = save_errno;\n}\n\n/*\n * Reaper -- signal handler to cleanup after a child process dies.\n */\nstatic void\nreaper(SIGNAL_ARGS)\n{\n\tint\t\t\tsave_errno = errno;\n\tint\t\t\tpid;\t\t\t/* process id of dead child process */\n\tint\t\t\texitstatus;\t\t/* its exit status */\n\n\t/*\n\t * We rely on the signal mechanism to have blocked all signals ... except\n\t * on Windows, which lacks sigaction(), so we have to do it manually.\n\t */\n#ifdef WIN32\n\tPG_SETMASK(&BlockSig);\n#endif\n\n\tereport(DEBUG4,\n\t\t\t(errmsg_internal(\"reaping dead processes\")));\n\n\twhile ((pid = waitpid(-1, &exitstatus, WNOHANG)) > 0)\n\t{\n\t\t/*\n\t\t * Check if this child was a startup process.\n\t\t */\n\t\tif (pid == StartupPID)\n\t\t{\n\t\t\tStartupPID = 0;\n\n\t\t\t/*\n\t\t\t * Startup process exited in response to a shutdown request (or it\n\t\t\t * completed normally regardless of the shutdown request).\n\t\t\t */\n\t\t\tif (Shutdown > NoShutdown &&\n\t\t\t\t(EXIT_STATUS_0(exitstatus) || EXIT_STATUS_1(exitstatus)))\n\t\t\t{\n\t\t\t\tStartupStatus = STARTUP_NOT_RUNNING;\n\t\t\t\tpmState = PM_WAIT_BACKENDS;\n\t\t\t\t/* PostmasterStateMachine logic does the rest */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (EXIT_STATUS_3(exitstatus))\n\t\t\t{\n\t\t\t\tereport(LOG,\n\t\t\t\t\t\t(errmsg(\"shutdown at recovery target\")));\n\t\t\t\tStartupStatus = STARTUP_NOT_RUNNING;\n\t\t\t\tShutdown = Max(Shutdown, SmartShutdown);\n\t\t\t\tTerminateChildren(SIGTERM);\n\t\t\t\tpmState = PM_WAIT_BACKENDS;\n\t\t\t\t/* PostmasterStateMachine logic does the rest */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Unexpected exit of startup process (including FATAL exit)\n\t\t\t * during PM_STARTUP is treated as catastrophic. There are no\n\t\t\t * other processes running yet, so we can just exit.\n\t\t\t */\n\t\t\tif (pmState == PM_STARTUP &&\n\t\t\t\tStartupStatus != STARTUP_SIGNALED &&\n\t\t\t\t!EXIT_STATUS_0(exitstatus))\n\t\t\t{\n\t\t\t\tLogChildExit(LOG, _(\"startup process\"),\n\t\t\t\t\t\t\t pid, exitstatus);\n\t\t\t\tereport(LOG,\n\t\t\t\t\t\t(errmsg(\"aborting startup due to startup process failure\")));\n\t\t\t\tExitPostmaster(1);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * After PM_STARTUP, any unexpected exit (including FATAL exit) of\n\t\t\t * the startup process is catastrophic, so kill other children,\n\t\t\t * and set StartupStatus so we don't try to reinitialize after\n\t\t\t * they're gone.  Exception: if StartupStatus is STARTUP_SIGNALED,\n\t\t\t * then we previously sent the startup process a SIGQUIT; so\n\t\t\t * that's probably the reason it died, and we do want to try to\n\t\t\t * restart in that case.\n\t\t\t *\n\t\t\t * This stanza also handles the case where we sent a SIGQUIT\n\t\t\t * during PM_STARTUP due to some dead_end child crashing: in that\n\t\t\t * situation, if the startup process dies on the SIGQUIT, we need\n\t\t\t * to transition to PM_WAIT_BACKENDS state which will allow\n\t\t\t * PostmasterStateMachine to restart the startup process.  (On the\n\t\t\t * other hand, the startup process might complete normally, if we\n\t\t\t * were too late with the SIGQUIT.  In that case we'll fall\n\t\t\t * through and commence normal operations.)\n\t\t\t */\n\t\t\tif (!EXIT_STATUS_0(exitstatus))\n\t\t\t{\n\t\t\t\tif (StartupStatus == STARTUP_SIGNALED)\n\t\t\t\t{\n\t\t\t\t\tStartupStatus = STARTUP_NOT_RUNNING;\n\t\t\t\t\tif (pmState == PM_STARTUP)\n\t\t\t\t\t\tpmState = PM_WAIT_BACKENDS;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tStartupStatus = STARTUP_CRASHED;\n\t\t\t\tHandleChildCrash(pid, exitstatus,\n\t\t\t\t\t\t\t\t _(\"startup process\"));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Startup succeeded, commence normal operations\n\t\t\t */\n\t\t\tStartupStatus = STARTUP_NOT_RUNNING;\n\t\t\tFatalError = false;\n\t\t\tAbortStartTime = 0;\n\t\t\tReachedNormalRunning = true;\n\t\t\tpmState = PM_RUN;\n\t\t\tconnsAllowed = ALLOW_ALL_CONNS;\n\n\t\t\t/*\n\t\t\t * Crank up the background tasks, if we didn't do that already\n\t\t\t * when we entered consistent recovery state.  It doesn't matter\n\t\t\t * if this fails, we'll just try again later.\n\t\t\t */\n\t\t\tif (CheckpointerPID == 0)\n\t\t\t\tCheckpointerPID = StartCheckpointer();\n\t\t\tif (BgWriterPID == 0)\n\t\t\t\tBgWriterPID = StartBackgroundWriter();\n\t\t\tif (WalWriterPID == 0)\n\t\t\t\tWalWriterPID = StartWalWriter();\n\n\t\t\t/*\n\t\t\t * Likewise, start other special children as needed.  In a restart\n\t\t\t * situation, some of them may be alive already.\n\t\t\t */\n\t\t\tif (!IsBinaryUpgrade && AutoVacuumingActive() && AutoVacPID == 0)\n\t\t\t\tAutoVacPID = StartAutoVacLauncher();\n\t\t\tif (PgArchStartupAllowed() && PgArchPID == 0)\n\t\t\t\tPgArchPID = StartArchiver();\n\t\t\tif (PgStatPID == 0)\n\t\t\t\tPgStatPID = pgstat_start();\n\n\t\t\t/* workers may be scheduled to start now */\n\t\t\tmaybe_start_bgworkers();\n\n\t\t\t/* at this point we are really open for business */\n\t\t\tereport(LOG,\n\t\t\t\t\t(errmsg(\"database system is ready to accept connections\")));\n\n\t\t\t/* Report status */\n\t\t\tAddToDataDirLockFile(LOCK_FILE_LINE_PM_STATUS, PM_STATUS_READY);\n#ifdef USE_SYSTEMD\n\t\t\tsd_notify(0, \"READY=1\");\n#endif\n\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Was it the bgwriter?  Normal exit can be ignored; we'll start a new\n\t\t * one at the next iteration of the postmaster's main loop, if\n\t\t * necessary.  Any other exit condition is treated as a crash.\n\t\t */\n\t\tif (pid == BgWriterPID)\n\t\t{\n\t\t\tBgWriterPID = 0;\n\t\t\tif (!EXIT_STATUS_0(exitstatus))\n\t\t\t\tHandleChildCrash(pid, exitstatus,\n\t\t\t\t\t\t\t\t _(\"background writer process\"));\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Was it the checkpointer?\n\t\t */\n\t\tif (pid == CheckpointerPID)\n\t\t{\n\t\t\tCheckpointerPID = 0;\n\t\t\tif (EXIT_STATUS_0(exitstatus) && pmState == PM_SHUTDOWN)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * OK, we saw normal exit of the checkpointer after it's been\n\t\t\t\t * told to shut down.  We expect that it wrote a shutdown\n\t\t\t\t * checkpoint.  (If for some reason it didn't, recovery will\n\t\t\t\t * occur on next postmaster start.)\n\t\t\t\t *\n\t\t\t\t * At this point we should have no normal backend children\n\t\t\t\t * left (else we'd not be in PM_SHUTDOWN state) but we might\n\t\t\t\t * have dead_end children to wait for.\n\t\t\t\t *\n\t\t\t\t * If we have an archiver subprocess, tell it to do a last\n\t\t\t\t * archive cycle and quit. Likewise, if we have walsender\n\t\t\t\t * processes, tell them to send any remaining WAL and quit.\n\t\t\t\t */\n\t\t\t\tAssert(Shutdown > NoShutdown);\n\n\t\t\t\t/* Waken archiver for the last time */\n\t\t\t\tif (PgArchPID != 0)\n\t\t\t\t\tsignal_child(PgArchPID, SIGUSR2);\n\n\t\t\t\t/*\n\t\t\t\t * Waken walsenders for the last time. No regular backends\n\t\t\t\t * should be around anymore.\n\t\t\t\t */\n\t\t\t\tSignalChildren(SIGUSR2);\n\n\t\t\t\tpmState = PM_SHUTDOWN_2;\n\n\t\t\t\t/*\n\t\t\t\t * We can also shut down the stats collector now; there's\n\t\t\t\t * nothing left for it to do.\n\t\t\t\t */\n\t\t\t\tif (PgStatPID != 0)\n\t\t\t\t\tsignal_child(PgStatPID, SIGQUIT);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Any unexpected exit of the checkpointer (including FATAL\n\t\t\t\t * exit) is treated as a crash.\n\t\t\t\t */\n\t\t\t\tHandleChildCrash(pid, exitstatus,\n\t\t\t\t\t\t\t\t _(\"checkpointer process\"));\n\t\t\t}\n\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Was it the wal writer?  Normal exit can be ignored; we'll start a\n\t\t * new one at the next iteration of the postmaster's main loop, if\n\t\t * necessary.  Any other exit condition is treated as a crash.\n\t\t */\n\t\tif (pid == WalWriterPID)\n\t\t{\n\t\t\tWalWriterPID = 0;\n\t\t\tif (!EXIT_STATUS_0(exitstatus))\n\t\t\t\tHandleChildCrash(pid, exitstatus,\n\t\t\t\t\t\t\t\t _(\"WAL writer process\"));\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Was it the wal receiver?  If exit status is zero (normal) or one\n\t\t * (FATAL exit), we assume everything is all right just like normal\n\t\t * backends.  (If we need a new wal receiver, we'll start one at the\n\t\t * next iteration of the postmaster's main loop.)\n\t\t */\n\t\tif (pid == WalReceiverPID)\n\t\t{\n\t\t\tWalReceiverPID = 0;\n\t\t\tif (!EXIT_STATUS_0(exitstatus) && !EXIT_STATUS_1(exitstatus))\n\t\t\t\tHandleChildCrash(pid, exitstatus,\n\t\t\t\t\t\t\t\t _(\"WAL receiver process\"));\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Was it the autovacuum launcher?\tNormal exit can be ignored; we'll\n\t\t * start a new one at the next iteration of the postmaster's main\n\t\t * loop, if necessary.  Any other exit condition is treated as a\n\t\t * crash.\n\t\t */\n\t\tif (pid == AutoVacPID)\n\t\t{\n\t\t\tAutoVacPID = 0;\n\t\t\tif (!EXIT_STATUS_0(exitstatus))\n\t\t\t\tHandleChildCrash(pid, exitstatus,\n\t\t\t\t\t\t\t\t _(\"autovacuum launcher process\"));\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Was it the archiver?  If exit status is zero (normal) or one (FATAL\n\t\t * exit), we assume everything is all right just like normal backends\n\t\t * and just try to restart a new one so that we immediately retry\n\t\t * archiving remaining files. (If fail, we'll try again in future\n\t\t * cycles of the postmaster's main loop.) Unless we were waiting for\n\t\t * it to shut down; don't restart it in that case, and\n\t\t * PostmasterStateMachine() will advance to the next shutdown step.\n\t\t */\n\t\tif (pid == PgArchPID)\n\t\t{\n\t\t\tPgArchPID = 0;\n\t\t\tif (!EXIT_STATUS_0(exitstatus) && !EXIT_STATUS_1(exitstatus))\n\t\t\t\tHandleChildCrash(pid, exitstatus,\n\t\t\t\t\t\t\t\t _(\"archiver process\"));\n\t\t\tif (PgArchStartupAllowed())\n\t\t\t\tPgArchPID = StartArchiver();\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Was it the statistics collector?  If so, just try to start a new\n\t\t * one; no need to force reset of the rest of the system.  (If fail,\n\t\t * we'll try again in future cycles of the main loop.)\n\t\t */\n\t\tif (pid == PgStatPID)\n\t\t{\n\t\t\tPgStatPID = 0;\n\t\t\tif (!EXIT_STATUS_0(exitstatus))\n\t\t\t\tLogChildExit(LOG, _(\"statistics collector process\"),\n\t\t\t\t\t\t\t pid, exitstatus);\n\t\t\tif (pmState == PM_RUN || pmState == PM_HOT_STANDBY)\n\t\t\t\tPgStatPID = pgstat_start();\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Was it the system logger?  If so, try to start a new one */\n\t\tif (pid == SysLoggerPID)\n\t\t{\n\t\t\tSysLoggerPID = 0;\n\t\t\t/* for safety's sake, launch new logger *first* */\n\t\t\tSysLoggerPID = SysLogger_Start();\n\t\t\tif (!EXIT_STATUS_0(exitstatus))\n\t\t\t\tLogChildExit(LOG, _(\"system logger process\"),\n\t\t\t\t\t\t\t pid, exitstatus);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Was it one of our background workers? */\n\t\tif (CleanupBackgroundWorker(pid, exitstatus))\n\t\t{\n\t\t\t/* have it be restarted */\n\t\t\tHaveCrashedWorker = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Else do standard backend child cleanup.\n\t\t */\n\t\tCleanupBackend(pid, exitstatus);\n\t}\t\t\t\t\t\t\t/* loop over pending child-death reports */\n\n\t/*\n\t * After cleaning out the SIGCHLD queue, see if we have any state changes\n\t * or actions to make.\n\t */\n\tPostmasterStateMachine();\n\n\t/* Done with signal handler */\n#ifdef WIN32\n\tPG_SETMASK(&UnBlockSig);\n#endif\n\n\terrno = save_errno;\n}\n\n/*\n * Scan the bgworkers list and see if the given PID (which has just stopped\n * or crashed) is in it.  Handle its shutdown if so, and return true.  If not a\n * bgworker, return false.\n *\n * This is heavily based on CleanupBackend.  One important difference is that\n * we don't know yet that the dying process is a bgworker, so we must be silent\n * until we're sure it is.\n */\nstatic bool\nCleanupBackgroundWorker(int pid,\n\t\t\t\t\t\tint exitstatus) /* child's exit status */\n{\n\tchar\t\tnamebuf[MAXPGPATH];\n\tslist_mutable_iter iter;\n\n\tslist_foreach_modify(iter, &BackgroundWorkerList)\n\t{\n\t\tRegisteredBgWorker *rw;\n\n\t\trw = slist_container(RegisteredBgWorker, rw_lnode, iter.cur);\n\n\t\tif (rw->rw_pid != pid)\n\t\t\tcontinue;\n\n#ifdef WIN32\n\t\t/* see CleanupBackend */\n\t\tif (exitstatus == ERROR_WAIT_NO_CHILDREN)\n\t\t\texitstatus = 0;\n#endif\n\n\t\tsnprintf(namebuf, MAXPGPATH, _(\"background worker \\\"%s\\\"\"),\n\t\t\t\t rw->rw_worker.bgw_type);\n\n\n\t\tif (!EXIT_STATUS_0(exitstatus))\n\t\t{\n\t\t\t/* Record timestamp, so we know when to restart the worker. */\n\t\t\trw->rw_crashed_at = GetCurrentTimestamp();\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Zero exit status means terminate */\n\t\t\trw->rw_crashed_at = 0;\n\t\t\trw->rw_terminate = true;\n\t\t}\n\n\t\t/*\n\t\t * Additionally, just like a backend, any exit status other than 0 or\n\t\t * 1 is considered a crash and causes a system-wide restart.\n\t\t */\n\t\tif (!EXIT_STATUS_0(exitstatus) && !EXIT_STATUS_1(exitstatus))\n\t\t{\n\t\t\tHandleChildCrash(pid, exitstatus, namebuf);\n\t\t\treturn true;\n\t\t}\n\n\t\t/*\n\t\t * We must release the postmaster child slot. If the worker failed to\n\t\t * do so, it did not clean up after itself, requiring a crash-restart\n\t\t * cycle.\n\t\t */\n\t\tif (!ReleasePostmasterChildSlot(rw->rw_child_slot))\n\t\t{\n\t\t\tHandleChildCrash(pid, exitstatus, namebuf);\n\t\t\treturn true;\n\t\t}\n\n\t\t/* Get it out of the BackendList and clear out remaining data */\n\t\tdlist_delete(&rw->rw_backend->elem);\n#ifdef EXEC_BACKEND\n\t\tShmemBackendArrayRemove(rw->rw_backend);\n#endif\n\n\t\t/*\n\t\t * It's possible that this background worker started some OTHER\n\t\t * background worker and asked to be notified when that worker started\n\t\t * or stopped.  If so, cancel any notifications destined for the\n\t\t * now-dead backend.\n\t\t */\n\t\tif (rw->rw_backend->bgworker_notify)\n\t\t\tBackgroundWorkerStopNotifications(rw->rw_pid);\n\t\tfree(rw->rw_backend);\n\t\trw->rw_backend = NULL;\n\t\trw->rw_pid = 0;\n\t\trw->rw_child_slot = 0;\n\t\tReportBackgroundWorkerExit(&iter);\t/* report child death */\n\n\t\tLogChildExit(EXIT_STATUS_0(exitstatus) ? DEBUG1 : LOG,\n\t\t\t\t\t namebuf, pid, exitstatus);\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n/*\n * CleanupBackend -- cleanup after terminated backend.\n *\n * Remove all local state associated with backend.\n *\n * If you change this, see also CleanupBackgroundWorker.\n */\nstatic void\nCleanupBackend(int pid,\n\t\t\t   int exitstatus)\t/* child's exit status. */\n{\n\tdlist_mutable_iter iter;\n\n\tLogChildExit(DEBUG2, _(\"server process\"), pid, exitstatus);\n\n\t/*\n\t * If a backend dies in an ugly way then we must signal all other backends\n\t * to quickdie.  If exit status is zero (normal) or one (FATAL exit), we\n\t * assume everything is all right and proceed to remove the backend from\n\t * the active backend list.\n\t */\n\n#ifdef WIN32\n\n\t/*\n\t * On win32, also treat ERROR_WAIT_NO_CHILDREN (128) as nonfatal case,\n\t * since that sometimes happens under load when the process fails to start\n\t * properly (long before it starts using shared memory). Microsoft reports\n\t * it is related to mutex failure:\n\t * http://archives.postgresql.org/pgsql-hackers/2010-09/msg00790.php\n\t */\n\tif (exitstatus == ERROR_WAIT_NO_CHILDREN)\n\t{\n\t\tLogChildExit(LOG, _(\"server process\"), pid, exitstatus);\n\t\texitstatus = 0;\n\t}\n#endif\n\n\tif (!EXIT_STATUS_0(exitstatus) && !EXIT_STATUS_1(exitstatus))\n\t{\n\t\tHandleChildCrash(pid, exitstatus, _(\"server process\"));\n\t\treturn;\n\t}\n\n\tdlist_foreach_modify(iter, &BackendList)\n\t{\n\t\tBackend    *bp = dlist_container(Backend, elem, iter.cur);\n\n\t\tif (bp->pid == pid)\n\t\t{\n\t\t\tif (!bp->dead_end)\n\t\t\t{\n\t\t\t\tif (!ReleasePostmasterChildSlot(bp->child_slot))\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * Uh-oh, the child failed to clean itself up.  Treat as a\n\t\t\t\t\t * crash after all.\n\t\t\t\t\t */\n\t\t\t\t\tHandleChildCrash(pid, exitstatus, _(\"server process\"));\n\t\t\t\t\treturn;\n\t\t\t\t}\n#ifdef EXEC_BACKEND\n\t\t\t\tShmemBackendArrayRemove(bp);\n#endif\n\t\t\t}\n\t\t\tif (bp->bgworker_notify)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * This backend may have been slated to receive SIGUSR1 when\n\t\t\t\t * some background worker started or stopped.  Cancel those\n\t\t\t\t * notifications, as we don't want to signal PIDs that are not\n\t\t\t\t * PostgreSQL backends.  This gets skipped in the (probably\n\t\t\t\t * very common) case where the backend has never requested any\n\t\t\t\t * such notifications.\n\t\t\t\t */\n\t\t\t\tBackgroundWorkerStopNotifications(bp->pid);\n\t\t\t}\n\t\t\tdlist_delete(iter.cur);\n\t\t\tfree(bp);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/*\n * HandleChildCrash -- cleanup after failed backend, bgwriter, checkpointer,\n * walwriter, autovacuum, archiver or background worker.\n *\n * The objectives here are to clean up our local state about the child\n * process, and to signal all other remaining children to quickdie.\n */\nstatic void\nHandleChildCrash(int pid, int exitstatus, const char *procname)\n{\n\tdlist_mutable_iter iter;\n\tslist_iter\tsiter;\n\tBackend    *bp;\n\tbool\t\ttake_action;\n\n\t/*\n\t * We only log messages and send signals if this is the first process\n\t * crash and we're not doing an immediate shutdown; otherwise, we're only\n\t * here to update postmaster's idea of live processes.  If we have already\n\t * signaled children, nonzero exit status is to be expected, so don't\n\t * clutter log.\n\t */\n\ttake_action = !FatalError && Shutdown != ImmediateShutdown;\n\n\tif (take_action)\n\t{\n\t\tLogChildExit(LOG, procname, pid, exitstatus);\n\t\tereport(LOG,\n\t\t\t\t(errmsg(\"terminating any other active server processes\")));\n\t\tSetQuitSignalReason(PMQUIT_FOR_CRASH);\n\t}\n\n\t/* Process background workers. */\n\tslist_foreach(siter, &BackgroundWorkerList)\n\t{\n\t\tRegisteredBgWorker *rw;\n\n\t\trw = slist_container(RegisteredBgWorker, rw_lnode, siter.cur);\n\t\tif (rw->rw_pid == 0)\n\t\t\tcontinue;\t\t\t/* not running */\n\t\tif (rw->rw_pid == pid)\n\t\t{\n\t\t\t/*\n\t\t\t * Found entry for freshly-dead worker, so remove it.\n\t\t\t */\n\t\t\t(void) ReleasePostmasterChildSlot(rw->rw_child_slot);\n\t\t\tdlist_delete(&rw->rw_backend->elem);\n#ifdef EXEC_BACKEND\n\t\t\tShmemBackendArrayRemove(rw->rw_backend);\n#endif\n\t\t\tfree(rw->rw_backend);\n\t\t\trw->rw_backend = NULL;\n\t\t\trw->rw_pid = 0;\n\t\t\trw->rw_child_slot = 0;\n\t\t\t/* don't reset crashed_at */\n\t\t\t/* don't report child stop, either */\n\t\t\t/* Keep looping so we can signal remaining workers */\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * This worker is still alive.  Unless we did so already, tell it\n\t\t\t * to commit hara-kiri.\n\t\t\t *\n\t\t\t * SIGQUIT is the special signal that says exit without proc_exit\n\t\t\t * and let the user know what's going on. But if SendStop is set\n\t\t\t * (-T on command line), then we send SIGSTOP instead, so that we\n\t\t\t * can get core dumps from all backends by hand.\n\t\t\t */\n\t\t\tif (take_action)\n\t\t\t{\n\t\t\t\tereport(DEBUG2,\n\t\t\t\t\t\t(errmsg_internal(\"sending %s to process %d\",\n\t\t\t\t\t\t\t\t\t\t (SendStop ? \"SIGSTOP\" : \"SIGQUIT\"),\n\t\t\t\t\t\t\t\t\t\t (int) rw->rw_pid)));\n\t\t\t\tsignal_child(rw->rw_pid, (SendStop ? SIGSTOP : SIGQUIT));\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Process regular backends */\n\tdlist_foreach_modify(iter, &BackendList)\n\t{\n\t\tbp = dlist_container(Backend, elem, iter.cur);\n\n\t\tif (bp->pid == pid)\n\t\t{\n\t\t\t/*\n\t\t\t * Found entry for freshly-dead backend, so remove it.\n\t\t\t */\n\t\t\tif (!bp->dead_end)\n\t\t\t{\n\t\t\t\t(void) ReleasePostmasterChildSlot(bp->child_slot);\n#ifdef EXEC_BACKEND\n\t\t\t\tShmemBackendArrayRemove(bp);\n#endif\n\t\t\t}\n\t\t\tdlist_delete(iter.cur);\n\t\t\tfree(bp);\n\t\t\t/* Keep looping so we can signal remaining backends */\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * This backend is still alive.  Unless we did so already, tell it\n\t\t\t * to commit hara-kiri.\n\t\t\t *\n\t\t\t * SIGQUIT is the special signal that says exit without proc_exit\n\t\t\t * and let the user know what's going on. But if SendStop is set\n\t\t\t * (-T on command line), then we send SIGSTOP instead, so that we\n\t\t\t * can get core dumps from all backends by hand.\n\t\t\t *\n\t\t\t * We could exclude dead_end children here, but at least in the\n\t\t\t * SIGSTOP case it seems better to include them.\n\t\t\t *\n\t\t\t * Background workers were already processed above; ignore them\n\t\t\t * here.\n\t\t\t */\n\t\t\tif (bp->bkend_type == BACKEND_TYPE_BGWORKER)\n\t\t\t\tcontinue;\n\n\t\t\tif (take_action)\n\t\t\t{\n\t\t\t\tereport(DEBUG2,\n\t\t\t\t\t\t(errmsg_internal(\"sending %s to process %d\",\n\t\t\t\t\t\t\t\t\t\t (SendStop ? \"SIGSTOP\" : \"SIGQUIT\"),\n\t\t\t\t\t\t\t\t\t\t (int) bp->pid)));\n\t\t\t\tsignal_child(bp->pid, (SendStop ? SIGSTOP : SIGQUIT));\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Take care of the startup process too */\n\tif (pid == StartupPID)\n\t{\n\t\tStartupPID = 0;\n\t\t/* Caller adjusts StartupStatus, so don't touch it here */\n\t}\n\telse if (StartupPID != 0 && take_action)\n\t{\n\t\tereport(DEBUG2,\n\t\t\t\t(errmsg_internal(\"sending %s to process %d\",\n\t\t\t\t\t\t\t\t (SendStop ? \"SIGSTOP\" : \"SIGQUIT\"),\n\t\t\t\t\t\t\t\t (int) StartupPID)));\n\t\tsignal_child(StartupPID, (SendStop ? SIGSTOP : SIGQUIT));\n\t\tStartupStatus = STARTUP_SIGNALED;\n\t}\n\n\t/* Take care of the bgwriter too */\n\tif (pid == BgWriterPID)\n\t\tBgWriterPID = 0;\n\telse if (BgWriterPID != 0 && take_action)\n\t{\n\t\tereport(DEBUG2,\n\t\t\t\t(errmsg_internal(\"sending %s to process %d\",\n\t\t\t\t\t\t\t\t (SendStop ? \"SIGSTOP\" : \"SIGQUIT\"),\n\t\t\t\t\t\t\t\t (int) BgWriterPID)));\n\t\tsignal_child(BgWriterPID, (SendStop ? SIGSTOP : SIGQUIT));\n\t}\n\n\t/* Take care of the checkpointer too */\n\tif (pid == CheckpointerPID)\n\t\tCheckpointerPID = 0;\n\telse if (CheckpointerPID != 0 && take_action)\n\t{\n\t\tereport(DEBUG2,\n\t\t\t\t(errmsg_internal(\"sending %s to process %d\",\n\t\t\t\t\t\t\t\t (SendStop ? \"SIGSTOP\" : \"SIGQUIT\"),\n\t\t\t\t\t\t\t\t (int) CheckpointerPID)));\n\t\tsignal_child(CheckpointerPID, (SendStop ? SIGSTOP : SIGQUIT));\n\t}\n\n\t/* Take care of the walwriter too */\n\tif (pid == WalWriterPID)\n\t\tWalWriterPID = 0;\n\telse if (WalWriterPID != 0 && take_action)\n\t{\n\t\tereport(DEBUG2,\n\t\t\t\t(errmsg_internal(\"sending %s to process %d\",\n\t\t\t\t\t\t\t\t (SendStop ? \"SIGSTOP\" : \"SIGQUIT\"),\n\t\t\t\t\t\t\t\t (int) WalWriterPID)));\n\t\tsignal_child(WalWriterPID, (SendStop ? SIGSTOP : SIGQUIT));\n\t}\n\n\t/* Take care of the walreceiver too */\n\tif (pid == WalReceiverPID)\n\t\tWalReceiverPID = 0;\n\telse if (WalReceiverPID != 0 && take_action)\n\t{\n\t\tereport(DEBUG2,\n\t\t\t\t(errmsg_internal(\"sending %s to process %d\",\n\t\t\t\t\t\t\t\t (SendStop ? \"SIGSTOP\" : \"SIGQUIT\"),\n\t\t\t\t\t\t\t\t (int) WalReceiverPID)));\n\t\tsignal_child(WalReceiverPID, (SendStop ? SIGSTOP : SIGQUIT));\n\t}\n\n\t/* Take care of the autovacuum launcher too */\n\tif (pid == AutoVacPID)\n\t\tAutoVacPID = 0;\n\telse if (AutoVacPID != 0 && take_action)\n\t{\n\t\tereport(DEBUG2,\n\t\t\t\t(errmsg_internal(\"sending %s to process %d\",\n\t\t\t\t\t\t\t\t (SendStop ? \"SIGSTOP\" : \"SIGQUIT\"),\n\t\t\t\t\t\t\t\t (int) AutoVacPID)));\n\t\tsignal_child(AutoVacPID, (SendStop ? SIGSTOP : SIGQUIT));\n\t}\n\n\t/* Take care of the archiver too */\n\tif (pid == PgArchPID)\n\t\tPgArchPID = 0;\n\telse if (PgArchPID != 0 && take_action)\n\t{\n\t\tereport(DEBUG2,\n\t\t\t\t(errmsg_internal(\"sending %s to process %d\",\n\t\t\t\t\t\t\t\t (SendStop ? \"SIGSTOP\" : \"SIGQUIT\"),\n\t\t\t\t\t\t\t\t (int) PgArchPID)));\n\t\tsignal_child(PgArchPID, (SendStop ? SIGSTOP : SIGQUIT));\n\t}\n\n\t/*\n\t * Force a power-cycle of the pgstat process too.  (This isn't absolutely\n\t * necessary, but it seems like a good idea for robustness, and it\n\t * simplifies the state-machine logic in the case where a shutdown request\n\t * arrives during crash processing.)\n\t */\n\tif (PgStatPID != 0 && take_action)\n\t{\n\t\tereport(DEBUG2,\n\t\t\t\t(errmsg_internal(\"sending %s to process %d\",\n\t\t\t\t\t\t\t\t \"SIGQUIT\",\n\t\t\t\t\t\t\t\t (int) PgStatPID)));\n\t\tsignal_child(PgStatPID, SIGQUIT);\n\t\tallow_immediate_pgstat_restart();\n\t}\n\n\t/* We do NOT restart the syslogger */\n\n\tif (Shutdown != ImmediateShutdown)\n\t\tFatalError = true;\n\n\t/* We now transit into a state of waiting for children to die */\n\tif (pmState == PM_RECOVERY ||\n\t\tpmState == PM_HOT_STANDBY ||\n\t\tpmState == PM_RUN ||\n\t\tpmState == PM_STOP_BACKENDS ||\n\t\tpmState == PM_SHUTDOWN)\n\t\tpmState = PM_WAIT_BACKENDS;\n\n\t/*\n\t * .. and if this doesn't happen quickly enough, now the clock is ticking\n\t * for us to kill them without mercy.\n\t */\n\tif (AbortStartTime == 0)\n\t\tAbortStartTime = time(NULL);\n}\n\n/*\n * Log the death of a child process.\n */\nstatic void\nLogChildExit(int lev, const char *procname, int pid, int exitstatus)\n{\n\t/*\n\t * size of activity_buffer is arbitrary, but set equal to default\n\t * track_activity_query_size\n\t */\n\tchar\t\tactivity_buffer[1024];\n\tconst char *activity = NULL;\n\n\tif (!EXIT_STATUS_0(exitstatus))\n\t\tactivity = pgstat_get_crashed_backend_activity(pid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   activity_buffer,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   sizeof(activity_buffer));\n\n\tif (WIFEXITED(exitstatus))\n\t\tereport(lev,\n\n\t\t/*------\n\t\t  translator: %s is a noun phrase describing a child process, such as\n\t\t  \"server process\" */\n\t\t\t\t(errmsg(\"%s (PID %d) exited with exit code %d\",\n\t\t\t\t\t\tprocname, pid, WEXITSTATUS(exitstatus)),\n\t\t\t\t activity ? errdetail(\"Failed process was running: %s\", activity) : 0));\n\telse if (WIFSIGNALED(exitstatus))\n\t{\n#if defined(WIN32)\n\t\tereport(lev,\n\n\t\t/*------\n\t\t  translator: %s is a noun phrase describing a child process, such as\n\t\t  \"server process\" */\n\t\t\t\t(errmsg(\"%s (PID %d) was terminated by exception 0x%X\",\n\t\t\t\t\t\tprocname, pid, WTERMSIG(exitstatus)),\n\t\t\t\t errhint(\"See C include file \\\"ntstatus.h\\\" for a description of the hexadecimal value.\"),\n\t\t\t\t activity ? errdetail(\"Failed process was running: %s\", activity) : 0));\n#else\n\t\tereport(lev,\n\n\t\t/*------\n\t\t  translator: %s is a noun phrase describing a child process, such as\n\t\t  \"server process\" */\n\t\t\t\t(errmsg(\"%s (PID %d) was terminated by signal %d: %s\",\n\t\t\t\t\t\tprocname, pid, WTERMSIG(exitstatus),\n\t\t\t\t\t\tpg_strsignal(WTERMSIG(exitstatus))),\n\t\t\t\t activity ? errdetail(\"Failed process was running: %s\", activity) : 0));\n#endif\n\t}\n\telse\n\t\tereport(lev,\n\n\t\t/*------\n\t\t  translator: %s is a noun phrase describing a child process, such as\n\t\t  \"server process\" */\n\t\t\t\t(errmsg(\"%s (PID %d) exited with unrecognized status %d\",\n\t\t\t\t\t\tprocname, pid, exitstatus),\n\t\t\t\t activity ? errdetail(\"Failed process was running: %s\", activity) : 0));\n}\n\n/*\n * Advance the postmaster's state machine and take actions as appropriate\n *\n * This is common code for pmdie(), reaper() and sigusr1_handler(), which\n * receive the signals that might mean we need to change state.\n */\nstatic void\nPostmasterStateMachine(void)\n{\n\t/* If we're doing a smart shutdown, try to advance that state. */\n\tif (pmState == PM_RUN || pmState == PM_HOT_STANDBY)\n\t{\n\t\tif (connsAllowed == ALLOW_SUPERUSER_CONNS)\n\t\t{\n\t\t\t/*\n\t\t\t * ALLOW_SUPERUSER_CONNS state ends as soon as online backup mode\n\t\t\t * is not active.\n\t\t\t */\n\t\t\tif (!BackupInProgress())\n\t\t\t\tconnsAllowed = ALLOW_NO_CONNS;\n\t\t}\n\n\t\tif (connsAllowed == ALLOW_NO_CONNS)\n\t\t{\n\t\t\t/*\n\t\t\t * ALLOW_NO_CONNS state ends when we have no normal client\n\t\t\t * backends running.  Then we're ready to stop other children.\n\t\t\t */\n\t\t\tif (CountChildren(BACKEND_TYPE_NORMAL) == 0)\n\t\t\t\tpmState = PM_STOP_BACKENDS;\n\t\t}\n\t}\n\n\t/*\n\t * If we're ready to do so, signal child processes to shut down.  (This\n\t * isn't a persistent state, but treating it as a distinct pmState allows\n\t * us to share this code across multiple shutdown code paths.)\n\t */\n\tif (pmState == PM_STOP_BACKENDS)\n\t{\n\t\t/*\n\t\t * Forget any pending requests for background workers, since we're no\n\t\t * longer willing to launch any new workers.  (If additional requests\n\t\t * arrive, BackgroundWorkerStateChange will reject them.)\n\t\t */\n\t\tForgetUnstartedBackgroundWorkers();\n\n\t\t/* Signal all backend children except walsenders */\n\t\tSignalSomeChildren(SIGTERM,\n\t\t\t\t\t\t   BACKEND_TYPE_ALL - BACKEND_TYPE_WALSND);\n\t\t/* and the autovac launcher too */\n\t\tif (AutoVacPID != 0)\n\t\t\tsignal_child(AutoVacPID, SIGTERM);\n\t\t/* and the bgwriter too */\n\t\tif (BgWriterPID != 0)\n\t\t\tsignal_child(BgWriterPID, SIGTERM);\n\t\t/* and the walwriter too */\n\t\tif (WalWriterPID != 0)\n\t\t\tsignal_child(WalWriterPID, SIGTERM);\n\t\t/* If we're in recovery, also stop startup and walreceiver procs */\n\t\tif (StartupPID != 0)\n\t\t\tsignal_child(StartupPID, SIGTERM);\n\t\tif (WalReceiverPID != 0)\n\t\t\tsignal_child(WalReceiverPID, SIGTERM);\n\t\t/* checkpointer, archiver, stats, and syslogger may continue for now */\n\n\t\t/* Now transition to PM_WAIT_BACKENDS state to wait for them to die */\n\t\tpmState = PM_WAIT_BACKENDS;\n\t}\n\n\t/*\n\t * If we are in a state-machine state that implies waiting for backends to\n\t * exit, see if they're all gone, and change state if so.\n\t */\n\tif (pmState == PM_WAIT_BACKENDS)\n\t{\n\t\t/*\n\t\t * PM_WAIT_BACKENDS state ends when we have no regular backends\n\t\t * (including autovac workers), no bgworkers (including unconnected\n\t\t * ones), and no walwriter, autovac launcher or bgwriter.  If we are\n\t\t * doing crash recovery or an immediate shutdown then we expect the\n\t\t * checkpointer to exit as well, otherwise not. The stats and\n\t\t * syslogger processes are disregarded since they are not connected to\n\t\t * shared memory; we also disregard dead_end children here. Walsenders\n\t\t * and archiver are also disregarded, they will be terminated later\n\t\t * after writing the checkpoint record.\n\t\t */\n\t\tif (CountChildren(BACKEND_TYPE_ALL - BACKEND_TYPE_WALSND) == 0 &&\n\t\t\tStartupPID == 0 &&\n\t\t\tWalReceiverPID == 0 &&\n\t\t\tBgWriterPID == 0 &&\n\t\t\t(CheckpointerPID == 0 ||\n\t\t\t (!FatalError && Shutdown < ImmediateShutdown)) &&\n\t\t\tWalWriterPID == 0 &&\n\t\t\tAutoVacPID == 0)\n\t\t{\n\t\t\tif (Shutdown >= ImmediateShutdown || FatalError)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Start waiting for dead_end children to die.  This state\n\t\t\t\t * change causes ServerLoop to stop creating new ones.\n\t\t\t\t */\n\t\t\t\tpmState = PM_WAIT_DEAD_END;\n\n\t\t\t\t/*\n\t\t\t\t * We already SIGQUIT'd the archiver and stats processes, if\n\t\t\t\t * any, when we started immediate shutdown or entered\n\t\t\t\t * FatalError state.\n\t\t\t\t */\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * If we get here, we are proceeding with normal shutdown. All\n\t\t\t\t * the regular children are gone, and it's time to tell the\n\t\t\t\t * checkpointer to do a shutdown checkpoint.\n\t\t\t\t */\n\t\t\t\tAssert(Shutdown > NoShutdown);\n\t\t\t\t/* Start the checkpointer if not running */\n\t\t\t\tif (CheckpointerPID == 0)\n\t\t\t\t\tCheckpointerPID = StartCheckpointer();\n\t\t\t\t/* And tell it to shut down */\n\t\t\t\tif (CheckpointerPID != 0)\n\t\t\t\t{\n\t\t\t\t\tsignal_child(CheckpointerPID, SIGUSR2);\n\t\t\t\t\tpmState = PM_SHUTDOWN;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * If we failed to fork a checkpointer, just shut down.\n\t\t\t\t\t * Any required cleanup will happen at next restart. We\n\t\t\t\t\t * set FatalError so that an \"abnormal shutdown\" message\n\t\t\t\t\t * gets logged when we exit.\n\t\t\t\t\t */\n\t\t\t\t\tFatalError = true;\n\t\t\t\t\tpmState = PM_WAIT_DEAD_END;\n\n\t\t\t\t\t/* Kill the walsenders, archiver and stats collector too */\n\t\t\t\t\tSignalChildren(SIGQUIT);\n\t\t\t\t\tif (PgArchPID != 0)\n\t\t\t\t\t\tsignal_child(PgArchPID, SIGQUIT);\n\t\t\t\t\tif (PgStatPID != 0)\n\t\t\t\t\t\tsignal_child(PgStatPID, SIGQUIT);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (pmState == PM_SHUTDOWN_2)\n\t{\n\t\t/*\n\t\t * PM_SHUTDOWN_2 state ends when there's no other children than\n\t\t * dead_end children left. There shouldn't be any regular backends\n\t\t * left by now anyway; what we're really waiting for is walsenders and\n\t\t * archiver.\n\t\t */\n\t\tif (PgArchPID == 0 && CountChildren(BACKEND_TYPE_ALL) == 0)\n\t\t{\n\t\t\tpmState = PM_WAIT_DEAD_END;\n\t\t}\n\t}\n\n\tif (pmState == PM_WAIT_DEAD_END)\n\t{\n\t\t/*\n\t\t * PM_WAIT_DEAD_END state ends when the BackendList is entirely empty\n\t\t * (ie, no dead_end children remain), and the archiver and stats\n\t\t * collector are gone too.\n\t\t *\n\t\t * The reason we wait for those two is to protect them against a new\n\t\t * postmaster starting conflicting subprocesses; this isn't an\n\t\t * ironclad protection, but it at least helps in the\n\t\t * shutdown-and-immediately-restart scenario.  Note that they have\n\t\t * already been sent appropriate shutdown signals, either during a\n\t\t * normal state transition leading up to PM_WAIT_DEAD_END, or during\n\t\t * FatalError processing.\n\t\t */\n\t\tif (dlist_is_empty(&BackendList) &&\n\t\t\tPgArchPID == 0 && PgStatPID == 0)\n\t\t{\n\t\t\t/* These other guys should be dead already */\n\t\t\tAssert(StartupPID == 0);\n\t\t\tAssert(WalReceiverPID == 0);\n\t\t\tAssert(BgWriterPID == 0);\n\t\t\tAssert(CheckpointerPID == 0);\n\t\t\tAssert(WalWriterPID == 0);\n\t\t\tAssert(AutoVacPID == 0);\n\t\t\t/* syslogger is not considered here */\n\t\t\tpmState = PM_NO_CHILDREN;\n\t\t}\n\t}\n\n\t/*\n\t * If we've been told to shut down, we exit as soon as there are no\n\t * remaining children.  If there was a crash, cleanup will occur at the\n\t * next startup.  (Before PostgreSQL 8.3, we tried to recover from the\n\t * crash before exiting, but that seems unwise if we are quitting because\n\t * we got SIGTERM from init --- there may well not be time for recovery\n\t * before init decides to SIGKILL us.)\n\t *\n\t * Note that the syslogger continues to run.  It will exit when it sees\n\t * EOF on its input pipe, which happens when there are no more upstream\n\t * processes.\n\t */\n\tif (Shutdown > NoShutdown && pmState == PM_NO_CHILDREN)\n\t{\n\t\tif (FatalError)\n\t\t{\n\t\t\tereport(LOG, (errmsg(\"abnormal database system shutdown\")));\n\t\t\tExitPostmaster(1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Terminate exclusive backup mode to avoid recovery after a clean\n\t\t\t * fast shutdown.  Since an exclusive backup can only be taken\n\t\t\t * during normal running (and not, for example, while running\n\t\t\t * under Hot Standby) it only makes sense to do this if we reached\n\t\t\t * normal running. If we're still in recovery, the backup file is\n\t\t\t * one we're recovering *from*, and we must keep it around so that\n\t\t\t * recovery restarts from the right place.\n\t\t\t */\n\t\t\tif (ReachedNormalRunning)\n\t\t\t\tCancelBackup();\n\n\t\t\t/*\n\t\t\t * Normal exit from the postmaster is here.  We don't need to log\n\t\t\t * anything here, since the UnlinkLockFiles proc_exit callback\n\t\t\t * will do so, and that should be the last user-visible action.\n\t\t\t */\n\t\t\tExitPostmaster(0);\n\t\t}\n\t}\n\n\t/*\n\t * If the startup process failed, or the user does not want an automatic\n\t * restart after backend crashes, wait for all non-syslogger children to\n\t * exit, and then exit postmaster.  We don't try to reinitialize when the\n\t * startup process fails, because more than likely it will just fail again\n\t * and we will keep trying forever.\n\t */\n\tif (pmState == PM_NO_CHILDREN)\n\t{\n\t\tif (StartupStatus == STARTUP_CRASHED)\n\t\t{\n\t\t\tereport(LOG,\n\t\t\t\t\t(errmsg(\"shutting down due to startup process failure\")));\n\t\t\tExitPostmaster(1);\n\t\t}\n\t\tif (!restart_after_crash)\n\t\t{\n\t\t\tereport(LOG,\n\t\t\t\t\t(errmsg(\"shutting down because restart_after_crash is off\")));\n\t\t\tExitPostmaster(1);\n\t\t}\n\t}\n\n\t/*\n\t * If we need to recover from a crash, wait for all non-syslogger children\n\t * to exit, then reset shmem and StartupDataBase.\n\t */\n\tif (FatalError && pmState == PM_NO_CHILDREN)\n\t{\n\t\tereport(LOG,\n\t\t\t\t(errmsg(\"all server processes terminated; reinitializing\")));\n\n\t\t/* remove leftover temporary files after a crash */\n\t\tif (remove_temp_files_after_crash)\n\t\t\tRemovePgTempFiles();\n\n\t\t/* allow background workers to immediately restart */\n\t\tResetBackgroundWorkerCrashTimes();\n\n\t\tshmem_exit(1);\n\n\t\t/* re-read control file into local memory */\n\t\tLocalProcessControlFile(true);\n\n\t\treset_shared();\n\n\t\tStartupPID = StartupDataBase();\n\t\tAssert(StartupPID != 0);\n\t\tStartupStatus = STARTUP_RUNNING;\n\t\tpmState = PM_STARTUP;\n\t\t/* crash recovery started, reset SIGKILL flag */\n\t\tAbortStartTime = 0;\n\t}\n}\n\n\n/*\n * Send a signal to a postmaster child process\n *\n * On systems that have setsid(), each child process sets itself up as a\n * process group leader.  For signals that are generally interpreted in the\n * appropriate fashion, we signal the entire process group not just the\n * direct child process.  This allows us to, for example, SIGQUIT a blocked\n * archive_recovery script, or SIGINT a script being run by a backend via\n * system().\n *\n * There is a race condition for recently-forked children: they might not\n * have executed setsid() yet.  So we signal the child directly as well as\n * the group.  We assume such a child will handle the signal before trying\n * to spawn any grandchild processes.  We also assume that signaling the\n * child twice will not cause any problems.\n */\nstatic void\nsignal_child(pid_t pid, int signal)\n{\n\tif (kill(pid, signal) < 0)\n\t\telog(DEBUG3, \"kill(%ld,%d) failed: %m\", (long) pid, signal);\n#ifdef HAVE_SETSID\n\tswitch (signal)\n\t{\n\t\tcase SIGINT:\n\t\tcase SIGTERM:\n\t\tcase SIGQUIT:\n\t\tcase SIGSTOP:\n\t\tcase SIGKILL:\n\t\t\tif (kill(-pid, signal) < 0)\n\t\t\t\telog(DEBUG3, \"kill(%ld,%d) failed: %m\", (long) (-pid), signal);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n#endif\n}\n\n/*\n * Send a signal to the targeted children (but NOT special children;\n * dead_end children are never signaled, either).\n */\nstatic bool\nSignalSomeChildren(int signal, int target)\n{\n\tdlist_iter\titer;\n\tbool\t\tsignaled = false;\n\n\tdlist_foreach(iter, &BackendList)\n\t{\n\t\tBackend    *bp = dlist_container(Backend, elem, iter.cur);\n\n\t\tif (bp->dead_end)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Since target == BACKEND_TYPE_ALL is the most common case, we test\n\t\t * it first and avoid touching shared memory for every child.\n\t\t */\n\t\tif (target != BACKEND_TYPE_ALL)\n\t\t{\n\t\t\t/*\n\t\t\t * Assign bkend_type for any recently announced WAL Sender\n\t\t\t * processes.\n\t\t\t */\n\t\t\tif (bp->bkend_type == BACKEND_TYPE_NORMAL &&\n\t\t\t\tIsPostmasterChildWalSender(bp->child_slot))\n\t\t\t\tbp->bkend_type = BACKEND_TYPE_WALSND;\n\n\t\t\tif (!(target & bp->bkend_type))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tereport(DEBUG4,\n\t\t\t\t(errmsg_internal(\"sending signal %d to process %d\",\n\t\t\t\t\t\t\t\t signal, (int) bp->pid)));\n\t\tsignal_child(bp->pid, signal);\n\t\tsignaled = true;\n\t}\n\treturn signaled;\n}\n\n/*\n * Send a termination signal to children.  This considers all of our children\n * processes, except syslogger and dead_end backends.\n */\nstatic void\nTerminateChildren(int signal)\n{\n\tSignalChildren(signal);\n\tif (StartupPID != 0)\n\t{\n\t\tsignal_child(StartupPID, signal);\n\t\tif (signal == SIGQUIT || signal == SIGKILL)\n\t\t\tStartupStatus = STARTUP_SIGNALED;\n\t}\n\tif (BgWriterPID != 0)\n\t\tsignal_child(BgWriterPID, signal);\n\tif (CheckpointerPID != 0)\n\t\tsignal_child(CheckpointerPID, signal);\n\tif (WalWriterPID != 0)\n\t\tsignal_child(WalWriterPID, signal);\n\tif (WalReceiverPID != 0)\n\t\tsignal_child(WalReceiverPID, signal);\n\tif (AutoVacPID != 0)\n\t\tsignal_child(AutoVacPID, signal);\n\tif (PgArchPID != 0)\n\t\tsignal_child(PgArchPID, signal);\n\tif (PgStatPID != 0)\n\t\tsignal_child(PgStatPID, signal);\n}\n\n/*\n * BackendStartup -- start backend process\n *\n * returns: STATUS_ERROR if the fork failed, STATUS_OK otherwise.\n *\n * Note: if you change this code, also consider StartAutovacuumWorker.\n */\nstatic int\nBackendStartup(Port *port)\n{\n\tBackend    *bn;\t\t\t\t/* for backend cleanup */\n\tpid_t\t\tpid;\n\n\t/*\n\t * Create backend data structure.  Better before the fork() so we can\n\t * handle failure cleanly.\n\t */\n\tbn = (Backend *) malloc(sizeof(Backend));\n\tif (!bn)\n\t{\n\t\tereport(LOG,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\")));\n\t\treturn STATUS_ERROR;\n\t}\n\n\t/*\n\t * Compute the cancel key that will be assigned to this backend. The\n\t * backend will have its own copy in the forked-off process' value of\n\t * MyCancelKey, so that it can transmit the key to the frontend.\n\t */\n\tif (!RandomCancelKey(&MyCancelKey))\n\t{\n\t\tfree(bn);\n\t\tereport(LOG,\n\t\t\t\t(errcode(ERRCODE_INTERNAL_ERROR),\n\t\t\t\t errmsg(\"could not generate random cancel key\")));\n\t\treturn STATUS_ERROR;\n\t}\n\n\tbn->cancel_key = MyCancelKey;\n\n\t/* Pass down canAcceptConnections state */\n\tport->canAcceptConnections = canAcceptConnections(BACKEND_TYPE_NORMAL);\n\tbn->dead_end = (port->canAcceptConnections != CAC_OK &&\n\t\t\t\t\tport->canAcceptConnections != CAC_SUPERUSER);\n\n\t/*\n\t * Unless it's a dead_end child, assign it a child slot number\n\t */\n\tif (!bn->dead_end)\n\t\tbn->child_slot = MyPMChildSlot = AssignPostmasterChildSlot();\n\telse\n\t\tbn->child_slot = 0;\n\n\t/* Hasn't asked to be notified about any bgworkers yet */\n\tbn->bgworker_notify = false;\n\n#ifdef EXEC_BACKEND\n\tpid = backend_forkexec(port);\n#else\t\t\t\t\t\t\t/* !EXEC_BACKEND */\n\tpid = fork_process();\n\tif (pid == 0)\t\t\t\t/* child */\n\t{\n\t\tfree(bn);\n\n\t\t/* Detangle from postmaster */\n\t\tInitPostmasterChild();\n\n\t\t/* Close the postmaster's sockets */\n\t\tClosePostmasterPorts(false);\n\n\t\t/* Perform additional initialization and collect startup packet */\n\t\tBackendInitialize(port);\n\n\t\t/*\n\t\t * Create a per-backend PGPROC struct in shared memory. We must do\n\t\t * this before we can use LWLocks. In the !EXEC_BACKEND case (here)\n\t\t * this could be delayed a bit further, but EXEC_BACKEND needs to do\n\t\t * stuff with LWLocks before PostgresMain(), so we do it here as well\n\t\t * for symmetry.\n\t\t */\n\t\tInitProcess();\n\n\t\t/* And run the backend */\n\t\tBackendRun(port);\n\t}\n#endif\t\t\t\t\t\t\t/* EXEC_BACKEND */\n\n\tif (pid < 0)\n\t{\n\t\t/* in parent, fork failed */\n\t\tint\t\t\tsave_errno = errno;\n\n\t\tif (!bn->dead_end)\n\t\t\t(void) ReleasePostmasterChildSlot(bn->child_slot);\n\t\tfree(bn);\n\t\terrno = save_errno;\n\t\tereport(LOG,\n\t\t\t\t(errmsg(\"could not fork new process for connection: %m\")));\n\t\treport_fork_failure_to_client(port, save_errno);\n\t\treturn STATUS_ERROR;\n\t}\n\n\t/* in parent, successful fork */\n\tereport(DEBUG2,\n\t\t\t(errmsg_internal(\"forked new backend, pid=%d socket=%d\",\n\t\t\t\t\t\t\t (int) pid, (int) port->sock)));\n\n\t/*\n\t * Everything's been successful, it's safe to add this backend to our list\n\t * of backends.\n\t */\n\tbn->pid = pid;\n\tbn->bkend_type = BACKEND_TYPE_NORMAL;\t/* Can change later to WALSND */\n\tdlist_push_head(&BackendList, &bn->elem);\n\n#ifdef EXEC_BACKEND\n\tif (!bn->dead_end)\n\t\tShmemBackendArrayAdd(bn);\n#endif\n\n\treturn STATUS_OK;\n}\n\n/*\n * Try to report backend fork() failure to client before we close the\n * connection.  Since we do not care to risk blocking the postmaster on\n * this connection, we set the connection to non-blocking and try only once.\n *\n * This is grungy special-purpose code; we cannot use backend libpq since\n * it's not up and running.\n */\nstatic void\nreport_fork_failure_to_client(Port *port, int errnum)\n{\n\tchar\t\tbuffer[1000];\n\tint\t\t\trc;\n\n\t/* Format the error message packet (always V2 protocol) */\n\tsnprintf(buffer, sizeof(buffer), \"E%s%s\\n\",\n\t\t\t _(\"could not fork new process for connection: \"),\n\t\t\t strerror(errnum));\n\n\t/* Set port to non-blocking.  Don't do send() if this fails */\n\tif (!pg_set_noblock(port->sock))\n\t\treturn;\n\n\t/* We'll retry after EINTR, but ignore all other failures */\n\tdo\n\t{\n\t\trc = send(port->sock, buffer, strlen(buffer) + 1, 0);\n\t} while (rc < 0 && errno == EINTR);\n}\n\n\n/*\n * BackendInitialize -- initialize an interactive (postmaster-child)\n *\t\t\t\tbackend process, and collect the client's startup packet.\n *\n * returns: nothing.  Will not return at all if there's any failure.\n *\n * Note: this code does not depend on having any access to shared memory.\n * Indeed, our approach to SIGTERM/timeout handling *requires* that\n * shared memory not have been touched yet; see comments within.\n * In the EXEC_BACKEND case, we are physically attached to shared memory\n * but have not yet set up most of our local pointers to shmem structures.\n */\nstatic void\nBackendInitialize(Port *port)\n{\n\tint\t\t\tstatus;\n\tint\t\t\tret;\n\tchar\t\tremote_host[NI_MAXHOST];\n\tchar\t\tremote_port[NI_MAXSERV];\n\tStringInfoData ps_data;\n\n\t/* Save port etc. for ps status */\n\tMyProcPort = port;\n\n\t/* Tell fd.c about the long-lived FD associated with the port */\n\tReserveExternalFD();\n\n\t/*\n\t * PreAuthDelay is a debugging aid for investigating problems in the\n\t * authentication cycle: it can be set in postgresql.conf to allow time to\n\t * attach to the newly-forked backend with a debugger.  (See also\n\t * PostAuthDelay, which we allow clients to pass through PGOPTIONS, but it\n\t * is not honored until after authentication.)\n\t */\n\tif (PreAuthDelay > 0)\n\t\tpg_usleep(PreAuthDelay * 1000000L);\n\n\t/* This flag will remain set until InitPostgres finishes authentication */\n\tClientAuthInProgress = true;\t/* limit visibility of log messages */\n\n\t/* set these to empty in case they are needed before we set them up */\n\tport->remote_host = \"\";\n\tport->remote_port = \"\";\n\n\t/*\n\t * Initialize libpq and enable reporting of ereport errors to the client.\n\t * Must do this now because authentication uses libpq to send messages.\n\t */\n\tpq_init();\t\t\t\t\t/* initialize libpq to talk to client */\n\twhereToSendOutput = DestRemote; /* now safe to ereport to client */\n\n\t/*\n\t * We arrange to do _exit(1) if we receive SIGTERM or timeout while trying\n\t * to collect the startup packet; while SIGQUIT results in _exit(2).\n\t * Otherwise the postmaster cannot shutdown the database FAST or IMMED\n\t * cleanly if a buggy client fails to send the packet promptly.\n\t *\n\t * Exiting with _exit(1) is only possible because we have not yet touched\n\t * shared memory; therefore no outside-the-process state needs to get\n\t * cleaned up.\n\t */\n\tpqsignal(SIGTERM, process_startup_packet_die);\n\t/* SIGQUIT handler was already set up by InitPostmasterChild */\n\tInitializeTimeouts();\t\t/* establishes SIGALRM handler */\n\tPG_SETMASK(&StartupBlockSig);\n\n\t/*\n\t * Get the remote host name and port for logging and status display.\n\t */\n\tremote_host[0] = '\\0';\n\tremote_port[0] = '\\0';\n\tif ((ret = pg_getnameinfo_all(&port->raddr.addr, port->raddr.salen,\n\t\t\t\t\t\t\t\t  remote_host, sizeof(remote_host),\n\t\t\t\t\t\t\t\t  remote_port, sizeof(remote_port),\n\t\t\t\t\t\t\t\t  (log_hostname ? 0 : NI_NUMERICHOST) | NI_NUMERICSERV)) != 0)\n\t\tereport(WARNING,\n\t\t\t\t(errmsg_internal(\"pg_getnameinfo_all() failed: %s\",\n\t\t\t\t\t\t\t\t gai_strerror(ret))));\n\n\t/*\n\t * Save remote_host and remote_port in port structure (after this, they\n\t * will appear in log_line_prefix data for log messages).\n\t */\n\tport->remote_host = strdup(remote_host);\n\tport->remote_port = strdup(remote_port);\n\n\t/* And now we can issue the Log_connections message, if wanted */\n\tif (Log_connections)\n\t{\n\t\tif (remote_port[0])\n\t\t\tereport(LOG,\n\t\t\t\t\t(errmsg(\"connection received: host=%s port=%s\",\n\t\t\t\t\t\t\tremote_host,\n\t\t\t\t\t\t\tremote_port)));\n\t\telse\n\t\t\tereport(LOG,\n\t\t\t\t\t(errmsg(\"connection received: host=%s\",\n\t\t\t\t\t\t\tremote_host)));\n\t}\n\n\t/*\n\t * If we did a reverse lookup to name, we might as well save the results\n\t * rather than possibly repeating the lookup during authentication.\n\t *\n\t * Note that we don't want to specify NI_NAMEREQD above, because then we'd\n\t * get nothing useful for a client without an rDNS entry.  Therefore, we\n\t * must check whether we got a numeric IPv4 or IPv6 address, and not save\n\t * it into remote_hostname if so.  (This test is conservative and might\n\t * sometimes classify a hostname as numeric, but an error in that\n\t * direction is safe; it only results in a possible extra lookup.)\n\t */\n\tif (log_hostname &&\n\t\tret == 0 &&\n\t\tstrspn(remote_host, \"0123456789.\") < strlen(remote_host) &&\n\t\tstrspn(remote_host, \"0123456789ABCDEFabcdef:\") < strlen(remote_host))\n\t\tport->remote_hostname = strdup(remote_host);\n\n\t/*\n\t * Ready to begin client interaction.  We will give up and _exit(1) after\n\t * a time delay, so that a broken client can't hog a connection\n\t * indefinitely.  PreAuthDelay and any DNS interactions above don't count\n\t * against the time limit.\n\t *\n\t * Note: AuthenticationTimeout is applied here while waiting for the\n\t * startup packet, and then again in InitPostgres for the duration of any\n\t * authentication operations.  So a hostile client could tie up the\n\t * process for nearly twice AuthenticationTimeout before we kick him off.\n\t *\n\t * Note: because PostgresMain will call InitializeTimeouts again, the\n\t * registration of STARTUP_PACKET_TIMEOUT will be lost.  This is okay\n\t * since we never use it again after this function.\n\t */\n\tRegisterTimeout(STARTUP_PACKET_TIMEOUT, StartupPacketTimeoutHandler);\n\tenable_timeout_after(STARTUP_PACKET_TIMEOUT, AuthenticationTimeout * 1000);\n\n\t/*\n\t * Receive the startup packet (which might turn out to be a cancel request\n\t * packet).\n\t */\n\tstatus = ProcessStartupPacket(port, false, false);\n\n\t/*\n\t * Disable the timeout, and prevent SIGTERM again.\n\t */\n\tdisable_timeout(STARTUP_PACKET_TIMEOUT, false);\n\tPG_SETMASK(&BlockSig);\n\n\t/*\n\t * As a safety check that nothing in startup has yet performed\n\t * shared-memory modifications that would need to be undone if we had\n\t * exited through SIGTERM or timeout above, check that no on_shmem_exit\n\t * handlers have been registered yet.  (This isn't terribly bulletproof,\n\t * since someone might misuse an on_proc_exit handler for shmem cleanup,\n\t * but it's a cheap and helpful check.  We cannot disallow on_proc_exit\n\t * handlers unfortunately, since pq_init() already registered one.)\n\t */\n\tcheck_on_shmem_exit_lists_are_empty();\n\n\t/*\n\t * Stop here if it was bad or a cancel packet.  ProcessStartupPacket\n\t * already did any appropriate error reporting.\n\t */\n\tif (status != STATUS_OK)\n\t\tproc_exit(0);\n\n\t/*\n\t * Now that we have the user and database name, we can set the process\n\t * title for ps.  It's good to do this as early as possible in startup.\n\t */\n\tinitStringInfo(&ps_data);\n\tif (am_walsender)\n\t\tappendStringInfo(&ps_data, \"%s \", GetBackendTypeDesc(B_WAL_SENDER));\n\tappendStringInfo(&ps_data, \"%s \", port->user_name);\n\tif (!am_walsender)\n\t\tappendStringInfo(&ps_data, \"%s \", port->database_name);\n\tappendStringInfo(&ps_data, \"%s\", port->remote_host);\n\tif (port->remote_port[0] != '\\0')\n\t\tappendStringInfo(&ps_data, \"(%s)\", port->remote_port);\n\n\tinit_ps_display(ps_data.data);\n\tpfree(ps_data.data);\n\n\tset_ps_display(\"initializing\");\n}\n\n\n/*\n * BackendRun -- set up the backend's argument list and invoke PostgresMain()\n *\n * returns:\n *\t\tDoesn't return at all.\n */\nstatic void\nBackendRun(Port *port)\n{\n\t/*\n\t * Make sure we aren't in PostmasterContext anymore.  (We can't delete it\n\t * just yet, though, because InitPostgres will need the HBA data.)\n\t */\n\tMemoryContextSwitchTo(TopMemoryContext);\n\n\tPostgresMain(port->database_name, port->user_name);\n}\n\n\n#ifdef EXEC_BACKEND\n\n/*\n * postmaster_forkexec -- fork and exec a postmaster subprocess\n *\n * The caller must have set up the argv array already, except for argv[2]\n * which will be filled with the name of the temp variable file.\n *\n * Returns the child process PID, or -1 on fork failure (a suitable error\n * message has been logged on failure).\n *\n * All uses of this routine will dispatch to SubPostmasterMain in the\n * child process.\n */\npid_t\npostmaster_forkexec(int argc, char *argv[])\n{\n\tPort\t\tport;\n\n\t/* This entry point passes dummy values for the Port variables */\n\tmemset(&port, 0, sizeof(port));\n\treturn internal_forkexec(argc, argv, &port);\n}\n\n/*\n * backend_forkexec -- fork/exec off a backend process\n *\n * Some operating systems (WIN32) don't have fork() so we have to simulate\n * it by storing parameters that need to be passed to the child and\n * then create a new child process.\n *\n * returns the pid of the fork/exec'd process, or -1 on failure\n */\nstatic pid_t\nbackend_forkexec(Port *port)\n{\n\tchar\t   *av[4];\n\tint\t\t\tac = 0;\n\n\tav[ac++] = \"postgres\";\n\tav[ac++] = \"--forkbackend\";\n\tav[ac++] = NULL;\t\t\t/* filled in by internal_forkexec */\n\n\tav[ac] = NULL;\n\tAssert(ac < lengthof(av));\n\n\treturn internal_forkexec(ac, av, port);\n}\n\n#ifndef WIN32\n\n/*\n * internal_forkexec non-win32 implementation\n *\n * - writes out backend variables to the parameter file\n * - fork():s, and then exec():s the child process\n */\nstatic pid_t\ninternal_forkexec(int argc, char *argv[], Port *port)\n{\n\tstatic unsigned long tmpBackendFileNum = 0;\n\tpid_t\t\tpid;\n\tchar\t\ttmpfilename[MAXPGPATH];\n\tBackendParameters param;\n\tFILE\t   *fp;\n\n\tif (!save_backend_variables(&param, port))\n\t\treturn -1;\t\t\t\t/* log made by save_backend_variables */\n\n\t/* Calculate name for temp file */\n\tsnprintf(tmpfilename, MAXPGPATH, \"%s/%s.backend_var.%d.%lu\",\n\t\t\t PG_TEMP_FILES_DIR, PG_TEMP_FILE_PREFIX,\n\t\t\t MyProcPid, ++tmpBackendFileNum);\n\n\t/* Open file */\n\tfp = AllocateFile(tmpfilename, PG_BINARY_W);\n\tif (!fp)\n\t{\n\t\t/*\n\t\t * As in OpenTemporaryFileInTablespace, try to make the temp-file\n\t\t * directory, ignoring errors.\n\t\t */\n\t\t(void) MakePGDirectory(PG_TEMP_FILES_DIR);\n\n\t\tfp = AllocateFile(tmpfilename, PG_BINARY_W);\n\t\tif (!fp)\n\t\t{\n\t\t\tereport(LOG,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not create file \\\"%s\\\": %m\",\n\t\t\t\t\t\t\ttmpfilename)));\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (fwrite(&param, sizeof(param), 1, fp) != 1)\n\t{\n\t\tereport(LOG,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write to file \\\"%s\\\": %m\", tmpfilename)));\n\t\tFreeFile(fp);\n\t\treturn -1;\n\t}\n\n\t/* Release file */\n\tif (FreeFile(fp))\n\t{\n\t\tereport(LOG,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write to file \\\"%s\\\": %m\", tmpfilename)));\n\t\treturn -1;\n\t}\n\n\t/* Make sure caller set up argv properly */\n\tAssert(argc >= 3);\n\tAssert(argv[argc] == NULL);\n\tAssert(strncmp(argv[1], \"--fork\", 6) == 0);\n\tAssert(argv[2] == NULL);\n\n\t/* Insert temp file name after --fork argument */\n\targv[2] = tmpfilename;\n\n\t/* Fire off execv in child */\n\tif ((pid = fork_process()) == 0)\n\t{\n\t\tif (execv(postgres_exec_path, argv) < 0)\n\t\t{\n\t\t\tereport(LOG,\n\t\t\t\t\t(errmsg(\"could not execute server process \\\"%s\\\": %m\",\n\t\t\t\t\t\t\tpostgres_exec_path)));\n\t\t\t/* We're already in the child process here, can't return */\n\t\t\texit(1);\n\t\t}\n\t}\n\n\treturn pid;\t\t\t\t\t/* Parent returns pid, or -1 on fork failure */\n}\n#else\t\t\t\t\t\t\t/* WIN32 */\n\n/*\n * internal_forkexec win32 implementation\n *\n * - starts backend using CreateProcess(), in suspended state\n * - writes out backend variables to the parameter file\n *\t- during this, duplicates handles and sockets required for\n *\t  inheritance into the new process\n * - resumes execution of the new process once the backend parameter\n *\t file is complete.\n */\nstatic pid_t\ninternal_forkexec(int argc, char *argv[], Port *port)\n{\n\tint\t\t\tretry_count = 0;\n\tSTARTUPINFO si;\n\tPROCESS_INFORMATION pi;\n\tint\t\t\ti;\n\tint\t\t\tj;\n\tchar\t\tcmdLine[MAXPGPATH * 2];\n\tHANDLE\t\tparamHandle;\n\tBackendParameters *param;\n\tSECURITY_ATTRIBUTES sa;\n\tchar\t\tparamHandleStr[32];\n\twin32_deadchild_waitinfo *childinfo;\n\n\t/* Make sure caller set up argv properly */\n\tAssert(argc >= 3);\n\tAssert(argv[argc] == NULL);\n\tAssert(strncmp(argv[1], \"--fork\", 6) == 0);\n\tAssert(argv[2] == NULL);\n\n\t/* Resume here if we need to retry */\nretry:\n\n\t/* Set up shared memory for parameter passing */\n\tZeroMemory(&sa, sizeof(sa));\n\tsa.nLength = sizeof(sa);\n\tsa.bInheritHandle = TRUE;\n\tparamHandle = CreateFileMapping(INVALID_HANDLE_VALUE,\n\t\t\t\t\t\t\t\t\t&sa,\n\t\t\t\t\t\t\t\t\tPAGE_READWRITE,\n\t\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t\tsizeof(BackendParameters),\n\t\t\t\t\t\t\t\t\tNULL);\n\tif (paramHandle == INVALID_HANDLE_VALUE)\n\t{\n\t\tereport(LOG,\n\t\t\t\t(errmsg(\"could not create backend parameter file mapping: error code %lu\",\n\t\t\t\t\t\tGetLastError())));\n\t\treturn -1;\n\t}\n\n\tparam = MapViewOfFile(paramHandle, FILE_MAP_WRITE, 0, 0, sizeof(BackendParameters));\n\tif (!param)\n\t{\n\t\tereport(LOG,\n\t\t\t\t(errmsg(\"could not map backend parameter memory: error code %lu\",\n\t\t\t\t\t\tGetLastError())));\n\t\tCloseHandle(paramHandle);\n\t\treturn -1;\n\t}\n\n\t/* Insert temp file name after --fork argument */\n#ifdef _WIN64\n\tsprintf(paramHandleStr, \"%llu\", (LONG_PTR) paramHandle);\n#else\n\tsprintf(paramHandleStr, \"%lu\", (DWORD) paramHandle);\n#endif\n\targv[2] = paramHandleStr;\n\n\t/* Format the cmd line */\n\tcmdLine[sizeof(cmdLine) - 1] = '\\0';\n\tcmdLine[sizeof(cmdLine) - 2] = '\\0';\n\tsnprintf(cmdLine, sizeof(cmdLine) - 1, \"\\\"%s\\\"\", postgres_exec_path);\n\ti = 0;\n\twhile (argv[++i] != NULL)\n\t{\n\t\tj = strlen(cmdLine);\n\t\tsnprintf(cmdLine + j, sizeof(cmdLine) - 1 - j, \" \\\"%s\\\"\", argv[i]);\n\t}\n\tif (cmdLine[sizeof(cmdLine) - 2] != '\\0')\n\t{\n\t\tereport(LOG,\n\t\t\t\t(errmsg(\"subprocess command line too long\")));\n\t\tUnmapViewOfFile(param);\n\t\tCloseHandle(paramHandle);\n\t\treturn -1;\n\t}\n\n\tmemset(&pi, 0, sizeof(pi));\n\tmemset(&si, 0, sizeof(si));\n\tsi.cb = sizeof(si);\n\n\t/*\n\t * Create the subprocess in a suspended state. This will be resumed later,\n\t * once we have written out the parameter file.\n\t */\n\tif (!CreateProcess(NULL, cmdLine, NULL, NULL, TRUE, CREATE_SUSPENDED,\n\t\t\t\t\t   NULL, NULL, &si, &pi))\n\t{\n\t\tereport(LOG,\n\t\t\t\t(errmsg(\"CreateProcess() call failed: %m (error code %lu)\",\n\t\t\t\t\t\tGetLastError())));\n\t\tUnmapViewOfFile(param);\n\t\tCloseHandle(paramHandle);\n\t\treturn -1;\n\t}\n\n\tif (!save_backend_variables(param, port, pi.hProcess, pi.dwProcessId))\n\t{\n\t\t/*\n\t\t * log made by save_backend_variables, but we have to clean up the\n\t\t * mess with the half-started process\n\t\t */\n\t\tif (!TerminateProcess(pi.hProcess, 255))\n\t\t\tereport(LOG,\n\t\t\t\t\t(errmsg_internal(\"could not terminate unstarted process: error code %lu\",\n\t\t\t\t\t\t\t\t\t GetLastError())));\n\t\tCloseHandle(pi.hProcess);\n\t\tCloseHandle(pi.hThread);\n\t\tUnmapViewOfFile(param);\n\t\tCloseHandle(paramHandle);\n\t\treturn -1;\t\t\t\t/* log made by save_backend_variables */\n\t}\n\n\t/* Drop the parameter shared memory that is now inherited to the backend */\n\tif (!UnmapViewOfFile(param))\n\t\tereport(LOG,\n\t\t\t\t(errmsg(\"could not unmap view of backend parameter file: error code %lu\",\n\t\t\t\t\t\tGetLastError())));\n\tif (!CloseHandle(paramHandle))\n\t\tereport(LOG,\n\t\t\t\t(errmsg(\"could not close handle to backend parameter file: error code %lu\",\n\t\t\t\t\t\tGetLastError())));\n\n\t/*\n\t * Reserve the memory region used by our main shared memory segment before\n\t * we resume the child process.  Normally this should succeed, but if ASLR\n\t * is active then it might sometimes fail due to the stack or heap having\n\t * gotten mapped into that range.  In that case, just terminate the\n\t * process and retry.\n\t */\n\tif (!pgwin32_ReserveSharedMemoryRegion(pi.hProcess))\n\t{\n\t\t/* pgwin32_ReserveSharedMemoryRegion already made a log entry */\n\t\tif (!TerminateProcess(pi.hProcess, 255))\n\t\t\tereport(LOG,\n\t\t\t\t\t(errmsg_internal(\"could not terminate process that failed to reserve memory: error code %lu\",\n\t\t\t\t\t\t\t\t\t GetLastError())));\n\t\tCloseHandle(pi.hProcess);\n\t\tCloseHandle(pi.hThread);\n\t\tif (++retry_count < 100)\n\t\t\tgoto retry;\n\t\tereport(LOG,\n\t\t\t\t(errmsg(\"giving up after too many tries to reserve shared memory\"),\n\t\t\t\t errhint(\"This might be caused by ASLR or antivirus software.\")));\n\t\treturn -1;\n\t}\n\n\t/*\n\t * Now that the backend variables are written out, we start the child\n\t * thread so it can start initializing while we set up the rest of the\n\t * parent state.\n\t */\n\tif (ResumeThread(pi.hThread) == -1)\n\t{\n\t\tif (!TerminateProcess(pi.hProcess, 255))\n\t\t{\n\t\t\tereport(LOG,\n\t\t\t\t\t(errmsg_internal(\"could not terminate unstartable process: error code %lu\",\n\t\t\t\t\t\t\t\t\t GetLastError())));\n\t\t\tCloseHandle(pi.hProcess);\n\t\t\tCloseHandle(pi.hThread);\n\t\t\treturn -1;\n\t\t}\n\t\tCloseHandle(pi.hProcess);\n\t\tCloseHandle(pi.hThread);\n\t\tereport(LOG,\n\t\t\t\t(errmsg_internal(\"could not resume thread of unstarted process: error code %lu\",\n\t\t\t\t\t\t\t\t GetLastError())));\n\t\treturn -1;\n\t}\n\n\t/*\n\t * Queue a waiter to signal when this child dies. The wait will be handled\n\t * automatically by an operating system thread pool.\n\t *\n\t * Note: use malloc instead of palloc, since it needs to be thread-safe.\n\t * Struct will be free():d from the callback function that runs on a\n\t * different thread.\n\t */\n\tchildinfo = malloc(sizeof(win32_deadchild_waitinfo));\n\tif (!childinfo)\n\t\tereport(FATAL,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\")));\n\n\tchildinfo->procHandle = pi.hProcess;\n\tchildinfo->procId = pi.dwProcessId;\n\n\tif (!RegisterWaitForSingleObject(&childinfo->waitHandle,\n\t\t\t\t\t\t\t\t\t pi.hProcess,\n\t\t\t\t\t\t\t\t\t pgwin32_deadchild_callback,\n\t\t\t\t\t\t\t\t\t childinfo,\n\t\t\t\t\t\t\t\t\t INFINITE,\n\t\t\t\t\t\t\t\t\t WT_EXECUTEONLYONCE | WT_EXECUTEINWAITTHREAD))\n\t\tereport(FATAL,\n\t\t\t\t(errmsg_internal(\"could not register process for wait: error code %lu\",\n\t\t\t\t\t\t\t\t GetLastError())));\n\n\t/* Don't close pi.hProcess here - the wait thread needs access to it */\n\n\tCloseHandle(pi.hThread);\n\n\treturn pi.dwProcessId;\n}\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\n\n/*\n * SubPostmasterMain -- Get the fork/exec'd process into a state equivalent\n *\t\t\tto what it would be if we'd simply forked on Unix, and then\n *\t\t\tdispatch to the appropriate place.\n *\n * The first two command line arguments are expected to be \"--forkFOO\"\n * (where FOO indicates which postmaster child we are to become), and\n * the name of a variables file that we can read to load data that would\n * have been inherited by fork() on Unix.  Remaining arguments go to the\n * subprocess FooMain() routine.\n */\nvoid\nSubPostmasterMain(int argc, char *argv[])\n{\n\tPort\t\tport;\n\n\t/* In EXEC_BACKEND case we will not have inherited these settings */\n\tIsPostmasterEnvironment = true;\n\twhereToSendOutput = DestNone;\n\n\t/* Setup essential subsystems (to ensure elog() behaves sanely) */\n\tInitializeGUCOptions();\n\n\t/* Check we got appropriate args */\n\tif (argc < 3)\n\t\telog(FATAL, \"invalid subpostmaster invocation\");\n\n\t/* Read in the variables file */\n\tmemset(&port, 0, sizeof(Port));\n\tread_backend_variables(argv[2], &port);\n\n\t/* Close the postmaster's sockets (as soon as we know them) */\n\tClosePostmasterPorts(strcmp(argv[1], \"--forklog\") == 0);\n\n\t/* Setup as postmaster child */\n\tInitPostmasterChild();\n\n\t/*\n\t * If appropriate, physically re-attach to shared memory segment. We want\n\t * to do this before going any further to ensure that we can attach at the\n\t * same address the postmaster used.  On the other hand, if we choose not\n\t * to re-attach, we may have other cleanup to do.\n\t *\n\t * If testing EXEC_BACKEND on Linux, you should run this as root before\n\t * starting the postmaster:\n\t *\n\t * echo 0 >/proc/sys/kernel/randomize_va_space\n\t *\n\t * This prevents using randomized stack and code addresses that cause the\n\t * child process's memory map to be different from the parent's, making it\n\t * sometimes impossible to attach to shared memory at the desired address.\n\t * Return the setting to its old value (usually '1' or '2') when finished.\n\t */\n\tif (strcmp(argv[1], \"--forkbackend\") == 0 ||\n\t\tstrcmp(argv[1], \"--forkavlauncher\") == 0 ||\n\t\tstrcmp(argv[1], \"--forkavworker\") == 0 ||\n\t\tstrcmp(argv[1], \"--forkaux\") == 0 ||\n\t\tstrncmp(argv[1], \"--forkbgworker=\", 15) == 0)\n\t\tPGSharedMemoryReAttach();\n\telse\n\t\tPGSharedMemoryNoReAttach();\n\n\t/* autovacuum needs this set before calling InitProcess */\n\tif (strcmp(argv[1], \"--forkavlauncher\") == 0)\n\t\tAutovacuumLauncherIAm();\n\tif (strcmp(argv[1], \"--forkavworker\") == 0)\n\t\tAutovacuumWorkerIAm();\n\n\t/* Read in remaining GUC variables */\n\tread_nondefault_variables();\n\n\t/*\n\t * Check that the data directory looks valid, which will also check the\n\t * privileges on the data directory and update our umask and file/group\n\t * variables for creating files later.  Note: this should really be done\n\t * before we create any files or directories.\n\t */\n\tcheckDataDir();\n\n\t/*\n\t * (re-)read control file, as it contains config. The postmaster will\n\t * already have read this, but this process doesn't know about that.\n\t */\n\tLocalProcessControlFile(false);\n\n\t/*\n\t * Reload any libraries that were preloaded by the postmaster.  Since we\n\t * exec'd this process, those libraries didn't come along with us; but we\n\t * should load them into all child processes to be consistent with the\n\t * non-EXEC_BACKEND behavior.\n\t */\n\tprocess_shared_preload_libraries();\n\n\t/* Run backend or appropriate child */\n\tif (strcmp(argv[1], \"--forkbackend\") == 0)\n\t{\n\t\tAssert(argc == 3);\t\t/* shouldn't be any more args */\n\n\t\t/*\n\t\t * Need to reinitialize the SSL library in the backend, since the\n\t\t * context structures contain function pointers and cannot be passed\n\t\t * through the parameter file.\n\t\t *\n\t\t * If for some reason reload fails (maybe the user installed broken\n\t\t * key files), soldier on without SSL; that's better than all\n\t\t * connections becoming impossible.\n\t\t *\n\t\t * XXX should we do this in all child processes?  For the moment it's\n\t\t * enough to do it in backend children.\n\t\t */\n#ifdef USE_SSL\n\t\tif (EnableSSL)\n\t\t{\n\t\t\tif (secure_initialize(false) == 0)\n\t\t\t\tLoadedSSL = true;\n\t\t\telse\n\t\t\t\tereport(LOG,\n\t\t\t\t\t\t(errmsg(\"SSL configuration could not be loaded in child process\")));\n\t\t}\n#endif\n\n\t\t/*\n\t\t * Perform additional initialization and collect startup packet.\n\t\t *\n\t\t * We want to do this before InitProcess() for a couple of reasons: 1.\n\t\t * so that we aren't eating up a PGPROC slot while waiting on the\n\t\t * client. 2. so that if InitProcess() fails due to being out of\n\t\t * PGPROC slots, we have already initialized libpq and are able to\n\t\t * report the error to the client.\n\t\t */\n\t\tBackendInitialize(&port);\n\n\t\t/* Restore basic shared memory pointers */\n\t\tInitShmemAccess(UsedShmemSegAddr);\n\n\t\t/* Need a PGPROC to run CreateSharedMemoryAndSemaphores */\n\t\tInitProcess();\n\n\t\t/* Attach process to shared data structures */\n\t\tCreateSharedMemoryAndSemaphores();\n\n\t\t/* And run the backend */\n\t\tBackendRun(&port);\t\t/* does not return */\n\t}\n\tif (strcmp(argv[1], \"--forkaux\") == 0)\n\t{\n\t\tAuxProcType auxtype;\n\n\t\tAssert(argc == 4);\n\n\t\t/* Restore basic shared memory pointers */\n\t\tInitShmemAccess(UsedShmemSegAddr);\n\n\t\t/* Need a PGPROC to run CreateSharedMemoryAndSemaphores */\n\t\tInitAuxiliaryProcess();\n\n\t\t/* Attach process to shared data structures */\n\t\tCreateSharedMemoryAndSemaphores();\n\n\t\tauxtype = atoi(argv[3]);\n\t\tAuxiliaryProcessMain(auxtype);\t/* does not return */\n\t}\n\tif (strcmp(argv[1], \"--forkavlauncher\") == 0)\n\t{\n\t\t/* Restore basic shared memory pointers */\n\t\tInitShmemAccess(UsedShmemSegAddr);\n\n\t\t/* Need a PGPROC to run CreateSharedMemoryAndSemaphores */\n\t\tInitProcess();\n\n\t\t/* Attach process to shared data structures */\n\t\tCreateSharedMemoryAndSemaphores();\n\n\t\tAutoVacLauncherMain(argc - 2, argv + 2);\t/* does not return */\n\t}\n\tif (strcmp(argv[1], \"--forkavworker\") == 0)\n\t{\n\t\t/* Restore basic shared memory pointers */\n\t\tInitShmemAccess(UsedShmemSegAddr);\n\n\t\t/* Need a PGPROC to run CreateSharedMemoryAndSemaphores */\n\t\tInitProcess();\n\n\t\t/* Attach process to shared data structures */\n\t\tCreateSharedMemoryAndSemaphores();\n\n\t\tAutoVacWorkerMain(argc - 2, argv + 2);\t/* does not return */\n\t}\n\tif (strncmp(argv[1], \"--forkbgworker=\", 15) == 0)\n\t{\n\t\tint\t\t\tshmem_slot;\n\n\t\t/* do this as early as possible; in particular, before InitProcess() */\n\t\tIsBackgroundWorker = true;\n\n\t\t/* Restore basic shared memory pointers */\n\t\tInitShmemAccess(UsedShmemSegAddr);\n\n\t\t/* Need a PGPROC to run CreateSharedMemoryAndSemaphores */\n\t\tInitProcess();\n\n\t\t/* Attach process to shared data structures */\n\t\tCreateSharedMemoryAndSemaphores();\n\n\t\t/* Fetch MyBgworkerEntry from shared memory */\n\t\tshmem_slot = atoi(argv[1] + 15);\n\t\tMyBgworkerEntry = BackgroundWorkerEntry(shmem_slot);\n\n\t\tStartBackgroundWorker();\n\t}\n\tif (strcmp(argv[1], \"--forkcol\") == 0)\n\t{\n\t\t/* Do not want to attach to shared memory */\n\n\t\tPgstatCollectorMain(argc, argv);\t/* does not return */\n\t}\n\tif (strcmp(argv[1], \"--forklog\") == 0)\n\t{\n\t\t/* Do not want to attach to shared memory */\n\n\t\tSysLoggerMain(argc, argv);\t/* does not return */\n\t}\n\n\tabort();\t\t\t\t\t/* shouldn't get here */\n}\n#endif\t\t\t\t\t\t\t/* EXEC_BACKEND */\n\n\n/*\n * ExitPostmaster -- cleanup\n *\n * Do NOT call exit() directly --- always go through here!\n */\nstatic void\nExitPostmaster(int status)\n{\n#ifdef HAVE_PTHREAD_IS_THREADED_NP\n\n\t/*\n\t * There is no known cause for a postmaster to become multithreaded after\n\t * startup.  Recheck to account for the possibility of unknown causes.\n\t * This message uses LOG level, because an unclean shutdown at this point\n\t * would usually not look much different from a clean shutdown.\n\t */\n\tif (pthread_is_threaded_np() != 0)\n\t\tereport(LOG,\n\t\t\t\t(errcode(ERRCODE_INTERNAL_ERROR),\n\t\t\t\t errmsg_internal(\"postmaster became multithreaded\"),\n\t\t\t\t errdetail(\"Please report this to <%s>.\", PACKAGE_BUGREPORT)));\n#endif\n\n\t/* should cleanup shared memory and kill all backends */\n\n\t/*\n\t * Not sure of the semantics here.  When the Postmaster dies, should the\n\t * backends all be killed? probably not.\n\t *\n\t * MUST\t\t-- vadim 05-10-1999\n\t */\n\n\tproc_exit(status);\n}\n\n/*\n * sigusr1_handler - handle signal conditions from child processes\n */\nstatic void\nsigusr1_handler(SIGNAL_ARGS)\n{\n\tint\t\t\tsave_errno = errno;\n\n\t/*\n\t * We rely on the signal mechanism to have blocked all signals ... except\n\t * on Windows, which lacks sigaction(), so we have to do it manually.\n\t */\n#ifdef WIN32\n\tPG_SETMASK(&BlockSig);\n#endif\n\n\t/*\n\t * RECOVERY_STARTED and BEGIN_HOT_STANDBY signals are ignored in\n\t * unexpected states. If the startup process quickly starts up, completes\n\t * recovery, exits, we might process the death of the startup process\n\t * first. We don't want to go back to recovery in that case.\n\t */\n\tif (CheckPostmasterSignal(PMSIGNAL_RECOVERY_STARTED) &&\n\t\tpmState == PM_STARTUP && Shutdown == NoShutdown)\n\t{\n\t\t/* WAL redo has started. We're out of reinitialization. */\n\t\tFatalError = false;\n\t\tAbortStartTime = 0;\n\n\t\t/*\n\t\t * Start the archiver if we're responsible for (re-)archiving received\n\t\t * files.\n\t\t */\n\t\tAssert(PgArchPID == 0);\n\t\tif (XLogArchivingAlways())\n\t\t\tPgArchPID = StartArchiver();\n\n\t\t/*\n\t\t * If we aren't planning to enter hot standby mode later, treat\n\t\t * RECOVERY_STARTED as meaning we're out of startup, and report status\n\t\t * accordingly.\n\t\t */\n\t\tif (!EnableHotStandby)\n\t\t{\n\t\t\tAddToDataDirLockFile(LOCK_FILE_LINE_PM_STATUS, PM_STATUS_STANDBY);\n#ifdef USE_SYSTEMD\n\t\t\tsd_notify(0, \"READY=1\");\n#endif\n\t\t}\n\n\t\tpmState = PM_RECOVERY;\n\t}\n\n\tif (CheckPostmasterSignal(PMSIGNAL_BEGIN_HOT_STANDBY) &&\n\t\tpmState == PM_RECOVERY && Shutdown == NoShutdown)\n\t{\n\t\t/*\n\t\t * Likewise, start other special children as needed.\n\t\t */\n\t\tAssert(PgStatPID == 0);\n\t\tPgStatPID = pgstat_start();\n\n\t\tereport(LOG,\n\t\t\t\t(errmsg(\"database system is ready to accept read-only connections\")));\n\n\t\t/* Report status */\n\t\tAddToDataDirLockFile(LOCK_FILE_LINE_PM_STATUS, PM_STATUS_READY);\n#ifdef USE_SYSTEMD\n\t\tsd_notify(0, \"READY=1\");\n#endif\n\n\t\tpmState = PM_HOT_STANDBY;\n\t\tconnsAllowed = ALLOW_ALL_CONNS;\n\n\t\t/* Some workers may be scheduled to start now */\n\t\tStartWorkerNeeded = true;\n\t}\n\n\t/* Process background worker state changes. */\n\tif (CheckPostmasterSignal(PMSIGNAL_BACKGROUND_WORKER_CHANGE))\n\t{\n\t\t/* Accept new worker requests only if not stopping. */\n\t\tBackgroundWorkerStateChange(pmState < PM_STOP_BACKENDS);\n\t\tStartWorkerNeeded = true;\n\t}\n\n\tif (StartWorkerNeeded || HaveCrashedWorker)\n\t\tmaybe_start_bgworkers();\n\n\t/* Tell syslogger to rotate logfile if requested */\n\tif (SysLoggerPID != 0)\n\t{\n\t\tif (CheckLogrotateSignal())\n\t\t{\n\t\t\tsignal_child(SysLoggerPID, SIGUSR1);\n\t\t\tRemoveLogrotateSignalFiles();\n\t\t}\n\t\telse if (CheckPostmasterSignal(PMSIGNAL_ROTATE_LOGFILE))\n\t\t{\n\t\t\tsignal_child(SysLoggerPID, SIGUSR1);\n\t\t}\n\t}\n\n\tif (CheckPostmasterSignal(PMSIGNAL_START_AUTOVAC_LAUNCHER) &&\n\t\tShutdown <= SmartShutdown && pmState < PM_STOP_BACKENDS)\n\t{\n\t\t/*\n\t\t * Start one iteration of the autovacuum daemon, even if autovacuuming\n\t\t * is nominally not enabled.  This is so we can have an active defense\n\t\t * against transaction ID wraparound.  We set a flag for the main loop\n\t\t * to do it rather than trying to do it here --- this is because the\n\t\t * autovac process itself may send the signal, and we want to handle\n\t\t * that by launching another iteration as soon as the current one\n\t\t * completes.\n\t\t */\n\t\tstart_autovac_launcher = true;\n\t}\n\n\tif (CheckPostmasterSignal(PMSIGNAL_START_AUTOVAC_WORKER) &&\n\t\tShutdown <= SmartShutdown && pmState < PM_STOP_BACKENDS)\n\t{\n\t\t/* The autovacuum launcher wants us to start a worker process. */\n\t\tStartAutovacuumWorker();\n\t}\n\n\tif (CheckPostmasterSignal(PMSIGNAL_START_WALRECEIVER))\n\t{\n\t\t/* Startup Process wants us to start the walreceiver process. */\n\t\t/* Start immediately if possible, else remember request for later. */\n\t\tWalReceiverRequested = true;\n\t\tMaybeStartWalReceiver();\n\t}\n\n\t/*\n\t * Try to advance postmaster's state machine, if a child requests it.\n\t *\n\t * Be careful about the order of this action relative to sigusr1_handler's\n\t * other actions.  Generally, this should be after other actions, in case\n\t * they have effects PostmasterStateMachine would need to know about.\n\t * However, we should do it before the CheckPromoteSignal step, which\n\t * cannot have any (immediate) effect on the state machine, but does\n\t * depend on what state we're in now.\n\t */\n\tif (CheckPostmasterSignal(PMSIGNAL_ADVANCE_STATE_MACHINE))\n\t{\n\t\tPostmasterStateMachine();\n\t}\n\n\tif (StartupPID != 0 &&\n\t\t(pmState == PM_STARTUP || pmState == PM_RECOVERY ||\n\t\t pmState == PM_HOT_STANDBY) &&\n\t\tCheckPromoteSignal())\n\t{\n\t\t/*\n\t\t * Tell startup process to finish recovery.\n\t\t *\n\t\t * Leave the promote signal file in place and let the Startup process\n\t\t * do the unlink.\n\t\t */\n\t\tsignal_child(StartupPID, SIGUSR2);\n\t}\n\n#ifdef WIN32\n\tPG_SETMASK(&UnBlockSig);\n#endif\n\n\terrno = save_errno;\n}\n\n/*\n * SIGTERM while processing startup packet.\n *\n * Running proc_exit() from a signal handler would be quite unsafe.\n * However, since we have not yet touched shared memory, we can just\n * pull the plug and exit without running any atexit handlers.\n *\n * One might be tempted to try to send a message, or log one, indicating\n * why we are disconnecting.  However, that would be quite unsafe in itself.\n * Also, it seems undesirable to provide clues about the database's state\n * to a client that has not yet completed authentication, or even sent us\n * a startup packet.\n */\nstatic void\nprocess_startup_packet_die(SIGNAL_ARGS)\n{\n\t_exit(1);\n}\n\n/*\n * Dummy signal handler\n *\n * We use this for signals that we don't actually use in the postmaster,\n * but we do use in backends.  If we were to SIG_IGN such signals in the\n * postmaster, then a newly started backend might drop a signal that arrives\n * before it's able to reconfigure its signal processing.  (See notes in\n * tcop/postgres.c.)\n */\nstatic void\ndummy_handler(SIGNAL_ARGS)\n{\n}\n\n/*\n * Timeout while processing startup packet.\n * As for process_startup_packet_die(), we exit via _exit(1).\n */\nstatic void\nStartupPacketTimeoutHandler(void)\n{\n\t_exit(1);\n}\n\n\n/*\n * Generate a random cancel key.\n */\nstatic bool\nRandomCancelKey(int32 *cancel_key)\n{\n\treturn pg_strong_random(cancel_key, sizeof(int32));\n}\n\n/*\n * Count up number of child processes of specified types (dead_end children\n * are always excluded).\n */\nstatic int\nCountChildren(int target)\n{\n\tdlist_iter\titer;\n\tint\t\t\tcnt = 0;\n\n\tdlist_foreach(iter, &BackendList)\n\t{\n\t\tBackend    *bp = dlist_container(Backend, elem, iter.cur);\n\n\t\tif (bp->dead_end)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Since target == BACKEND_TYPE_ALL is the most common case, we test\n\t\t * it first and avoid touching shared memory for every child.\n\t\t */\n\t\tif (target != BACKEND_TYPE_ALL)\n\t\t{\n\t\t\t/*\n\t\t\t * Assign bkend_type for any recently announced WAL Sender\n\t\t\t * processes.\n\t\t\t */\n\t\t\tif (bp->bkend_type == BACKEND_TYPE_NORMAL &&\n\t\t\t\tIsPostmasterChildWalSender(bp->child_slot))\n\t\t\t\tbp->bkend_type = BACKEND_TYPE_WALSND;\n\n\t\t\tif (!(target & bp->bkend_type))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tcnt++;\n\t}\n\treturn cnt;\n}\n\n\n/*\n * StartChildProcess -- start an auxiliary process for the postmaster\n *\n * \"type\" determines what kind of child will be started.  All child types\n * initially go to AuxiliaryProcessMain, which will handle common setup.\n *\n * Return value of StartChildProcess is subprocess' PID, or 0 if failed\n * to start subprocess.\n */\nstatic pid_t\nStartChildProcess(AuxProcType type)\n{\n\tpid_t\t\tpid;\n\n#ifdef EXEC_BACKEND\n\t{\n\t\tchar\t   *av[10];\n\t\tint\t\t\tac = 0;\n\t\tchar\t\ttypebuf[32];\n\n\t\t/*\n\t\t * Set up command-line arguments for subprocess\n\t\t */\n\t\tav[ac++] = \"postgres\";\n\t\tav[ac++] = \"--forkaux\";\n\t\tav[ac++] = NULL;\t\t/* filled in by postmaster_forkexec */\n\n\t\tsnprintf(typebuf, sizeof(typebuf), \"%d\", type);\n\t\tav[ac++] = typebuf;\n\n\t\tav[ac] = NULL;\n\t\tAssert(ac < lengthof(av));\n\n\t\tpid = postmaster_forkexec(ac, av);\n\t}\n#else\t\t\t\t\t\t\t/* !EXEC_BACKEND */\n\tpid = fork_process();\n\n\tif (pid == 0)\t\t\t\t/* child */\n\t{\n\t\tInitPostmasterChild();\n\n\t\t/* Close the postmaster's sockets */\n\t\tClosePostmasterPorts(false);\n\n\t\t/* Release postmaster's working memory context */\n\t\tMemoryContextSwitchTo(TopMemoryContext);\n\t\tMemoryContextDelete(PostmasterContext);\n\t\tPostmasterContext = NULL;\n\n\t\tAuxiliaryProcessMain(type); /* does not return */\n\t}\n#endif\t\t\t\t\t\t\t/* EXEC_BACKEND */\n\n\tif (pid < 0)\n\t{\n\t\t/* in parent, fork failed */\n\t\tint\t\t\tsave_errno = errno;\n\n\t\terrno = save_errno;\n\t\tswitch (type)\n\t\t{\n\t\t\tcase StartupProcess:\n\t\t\t\tereport(LOG,\n\t\t\t\t\t\t(errmsg(\"could not fork startup process: %m\")));\n\t\t\t\tbreak;\n\t\t\tcase ArchiverProcess:\n\t\t\t\tereport(LOG,\n\t\t\t\t\t\t(errmsg(\"could not fork archiver process: %m\")));\n\t\t\t\tbreak;\n\t\t\tcase BgWriterProcess:\n\t\t\t\tereport(LOG,\n\t\t\t\t\t\t(errmsg(\"could not fork background writer process: %m\")));\n\t\t\t\tbreak;\n\t\t\tcase CheckpointerProcess:\n\t\t\t\tereport(LOG,\n\t\t\t\t\t\t(errmsg(\"could not fork checkpointer process: %m\")));\n\t\t\t\tbreak;\n\t\t\tcase WalWriterProcess:\n\t\t\t\tereport(LOG,\n\t\t\t\t\t\t(errmsg(\"could not fork WAL writer process: %m\")));\n\t\t\t\tbreak;\n\t\t\tcase WalReceiverProcess:\n\t\t\t\tereport(LOG,\n\t\t\t\t\t\t(errmsg(\"could not fork WAL receiver process: %m\")));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tereport(LOG,\n\t\t\t\t\t\t(errmsg(\"could not fork process: %m\")));\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * fork failure is fatal during startup, but there's no need to choke\n\t\t * immediately if starting other child types fails.\n\t\t */\n\t\tif (type == StartupProcess)\n\t\t\tExitPostmaster(1);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * in parent, successful fork\n\t */\n\treturn pid;\n}\n\n/*\n * StartAutovacuumWorker\n *\t\tStart an autovac worker process.\n *\n * This function is here because it enters the resulting PID into the\n * postmaster's private backends list.\n *\n * NB -- this code very roughly matches BackendStartup.\n */\nstatic void\nStartAutovacuumWorker(void)\n{\n\tBackend    *bn;\n\n\t/*\n\t * If not in condition to run a process, don't try, but handle it like a\n\t * fork failure.  This does not normally happen, since the signal is only\n\t * supposed to be sent by autovacuum launcher when it's OK to do it, but\n\t * we have to check to avoid race-condition problems during DB state\n\t * changes.\n\t */\n\tif (canAcceptConnections(BACKEND_TYPE_AUTOVAC) == CAC_OK)\n\t{\n\t\t/*\n\t\t * Compute the cancel key that will be assigned to this session. We\n\t\t * probably don't need cancel keys for autovac workers, but we'd\n\t\t * better have something random in the field to prevent unfriendly\n\t\t * people from sending cancels to them.\n\t\t */\n\t\tif (!RandomCancelKey(&MyCancelKey))\n\t\t{\n\t\t\tereport(LOG,\n\t\t\t\t\t(errcode(ERRCODE_INTERNAL_ERROR),\n\t\t\t\t\t errmsg(\"could not generate random cancel key\")));\n\t\t\treturn;\n\t\t}\n\n\t\tbn = (Backend *) malloc(sizeof(Backend));\n\t\tif (bn)\n\t\t{\n\t\t\tbn->cancel_key = MyCancelKey;\n\n\t\t\t/* Autovac workers are not dead_end and need a child slot */\n\t\t\tbn->dead_end = false;\n\t\t\tbn->child_slot = MyPMChildSlot = AssignPostmasterChildSlot();\n\t\t\tbn->bgworker_notify = false;\n\n\t\t\tbn->pid = StartAutoVacWorker();\n\t\t\tif (bn->pid > 0)\n\t\t\t{\n\t\t\t\tbn->bkend_type = BACKEND_TYPE_AUTOVAC;\n\t\t\t\tdlist_push_head(&BackendList, &bn->elem);\n#ifdef EXEC_BACKEND\n\t\t\t\tShmemBackendArrayAdd(bn);\n#endif\n\t\t\t\t/* all OK */\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * fork failed, fall through to report -- actual error message was\n\t\t\t * logged by StartAutoVacWorker\n\t\t\t */\n\t\t\t(void) ReleasePostmasterChildSlot(bn->child_slot);\n\t\t\tfree(bn);\n\t\t}\n\t\telse\n\t\t\tereport(LOG,\n\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t errmsg(\"out of memory\")));\n\t}\n\n\t/*\n\t * Report the failure to the launcher, if it's running.  (If it's not, we\n\t * might not even be connected to shared memory, so don't try to call\n\t * AutoVacWorkerFailed.)  Note that we also need to signal it so that it\n\t * responds to the condition, but we don't do that here, instead waiting\n\t * for ServerLoop to do it.  This way we avoid a ping-pong signaling in\n\t * quick succession between the autovac launcher and postmaster in case\n\t * things get ugly.\n\t */\n\tif (AutoVacPID != 0)\n\t{\n\t\tAutoVacWorkerFailed();\n\t\tavlauncher_needs_signal = true;\n\t}\n}\n\n/*\n * MaybeStartWalReceiver\n *\t\tStart the WAL receiver process, if not running and our state allows.\n *\n * Note: if WalReceiverPID is already nonzero, it might seem that we should\n * clear WalReceiverRequested.  However, there's a race condition if the\n * walreceiver terminates and the startup process immediately requests a new\n * one: it's quite possible to get the signal for the request before reaping\n * the dead walreceiver process.  Better to risk launching an extra\n * walreceiver than to miss launching one we need.  (The walreceiver code\n * has logic to recognize that it should go away if not needed.)\n */\nstatic void\nMaybeStartWalReceiver(void)\n{\n\tif (WalReceiverPID == 0 &&\n\t\t(pmState == PM_STARTUP || pmState == PM_RECOVERY ||\n\t\t pmState == PM_HOT_STANDBY) &&\n\t\tShutdown <= SmartShutdown)\n\t{\n\t\tWalReceiverPID = StartWalReceiver();\n\t\tif (WalReceiverPID != 0)\n\t\t\tWalReceiverRequested = false;\n\t\t/* else leave the flag set, so we'll try again later */\n\t}\n}\n\n\n/*\n * Create the opts file\n */\nstatic bool\nCreateOptsFile(int argc, char *argv[], char *fullprogname)\n{\n\tFILE\t   *fp;\n\tint\t\t\ti;\n\n#define OPTS_FILE\t\"postmaster.opts\"\n\n\tif ((fp = fopen(OPTS_FILE, \"w\")) == NULL)\n\t{\n\t\tereport(LOG,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not create file \\\"%s\\\": %m\", OPTS_FILE)));\n\t\treturn false;\n\t}\n\n\tfprintf(fp, \"%s\", fullprogname);\n\tfor (i = 1; i < argc; i++)\n\t\tfprintf(fp, \" \\\"%s\\\"\", argv[i]);\n\tfputs(\"\\n\", fp);\n\n\tif (fclose(fp))\n\t{\n\t\tereport(LOG,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write file \\\"%s\\\": %m\", OPTS_FILE)));\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n\n/*\n * MaxLivePostmasterChildren\n *\n * This reports the number of entries needed in per-child-process arrays\n * (the PMChildFlags array, and if EXEC_BACKEND the ShmemBackendArray).\n * These arrays include regular backends, autovac workers, walsenders\n * and background workers, but not special children nor dead_end children.\n * This allows the arrays to have a fixed maximum size, to wit the same\n * too-many-children limit enforced by canAcceptConnections().  The exact value\n * isn't too critical as long as it's more than MaxBackends.\n */\nint\nMaxLivePostmasterChildren(void)\n{\n\treturn 2 * (MaxConnections + autovacuum_max_workers + 1 +\n\t\t\t\tmax_wal_senders + max_worker_processes);\n}\n\n/*\n * Connect background worker to a database.\n */\nvoid\nBackgroundWorkerInitializeConnection(const char *dbname, const char *username, uint32 flags)\n{\n\tBackgroundWorker *worker = MyBgworkerEntry;\n\n\t/* XXX is this the right errcode? */\n\tif (!(worker->bgw_flags & BGWORKER_BACKEND_DATABASE_CONNECTION))\n\t\tereport(FATAL,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"database connection requirement not indicated during registration\")));\n\n\tInitPostgres(dbname, InvalidOid, username, InvalidOid, NULL, (flags & BGWORKER_BYPASS_ALLOWCONN) != 0);\n\n\t/* it had better not gotten out of \"init\" mode yet */\n\tif (!IsInitProcessingMode())\n\t\tereport(ERROR,\n\t\t\t\t(errmsg(\"invalid processing mode in background worker\")));\n\tSetProcessingMode(NormalProcessing);\n}\n\n/*\n * Connect background worker to a database using OIDs.\n */\nvoid\nBackgroundWorkerInitializeConnectionByOid(Oid dboid, Oid useroid, uint32 flags)\n{\n\tBackgroundWorker *worker = MyBgworkerEntry;\n\n\t/* XXX is this the right errcode? */\n\tif (!(worker->bgw_flags & BGWORKER_BACKEND_DATABASE_CONNECTION))\n\t\tereport(FATAL,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"database connection requirement not indicated during registration\")));\n\n\tInitPostgres(NULL, dboid, NULL, useroid, NULL, (flags & BGWORKER_BYPASS_ALLOWCONN) != 0);\n\n\t/* it had better not gotten out of \"init\" mode yet */\n\tif (!IsInitProcessingMode())\n\t\tereport(ERROR,\n\t\t\t\t(errmsg(\"invalid processing mode in background worker\")));\n\tSetProcessingMode(NormalProcessing);\n}\n\n/*\n * Block/unblock signals in a background worker\n */\nvoid\nBackgroundWorkerBlockSignals(void)\n{\n\tPG_SETMASK(&BlockSig);\n}\n\nvoid\nBackgroundWorkerUnblockSignals(void)\n{\n\tPG_SETMASK(&UnBlockSig);\n}\n\n#ifdef EXEC_BACKEND\nstatic pid_t\nbgworker_forkexec(int shmem_slot)\n{\n\tchar\t   *av[10];\n\tint\t\t\tac = 0;\n\tchar\t\tforkav[MAXPGPATH];\n\n\tsnprintf(forkav, MAXPGPATH, \"--forkbgworker=%d\", shmem_slot);\n\n\tav[ac++] = \"postgres\";\n\tav[ac++] = forkav;\n\tav[ac++] = NULL;\t\t\t/* filled in by postmaster_forkexec */\n\tav[ac] = NULL;\n\n\tAssert(ac < lengthof(av));\n\n\treturn postmaster_forkexec(ac, av);\n}\n#endif\n\n/*\n * Start a new bgworker.\n * Starting time conditions must have been checked already.\n *\n * Returns true on success, false on failure.\n * In either case, update the RegisteredBgWorker's state appropriately.\n *\n * This code is heavily based on autovacuum.c, q.v.\n */\nstatic bool\ndo_start_bgworker(RegisteredBgWorker *rw)\n{\n\tpid_t\t\tworker_pid;\n\n\tAssert(rw->rw_pid == 0);\n\n\t/*\n\t * Allocate and assign the Backend element.  Note we must do this before\n\t * forking, so that we can handle failures (out of memory or child-process\n\t * slots) cleanly.\n\t *\n\t * Treat failure as though the worker had crashed.  That way, the\n\t * postmaster will wait a bit before attempting to start it again; if we\n\t * tried again right away, most likely we'd find ourselves hitting the\n\t * same resource-exhaustion condition.\n\t */\n\tif (!assign_backendlist_entry(rw))\n\t{\n\t\trw->rw_crashed_at = GetCurrentTimestamp();\n\t\treturn false;\n\t}\n\n\tereport(DEBUG1,\n\t\t\t(errmsg_internal(\"starting background worker process \\\"%s\\\"\",\n\t\t\t\t\t\t\t rw->rw_worker.bgw_name)));\n\n#ifdef EXEC_BACKEND\n\tswitch ((worker_pid = bgworker_forkexec(rw->rw_shmem_slot)))\n#else\n\tswitch ((worker_pid = fork_process()))\n#endif\n\t{\n\t\tcase -1:\n\t\t\t/* in postmaster, fork failed ... */\n\t\t\tereport(LOG,\n\t\t\t\t\t(errmsg(\"could not fork worker process: %m\")));\n\t\t\t/* undo what assign_backendlist_entry did */\n\t\t\tReleasePostmasterChildSlot(rw->rw_child_slot);\n\t\t\trw->rw_child_slot = 0;\n\t\t\tfree(rw->rw_backend);\n\t\t\trw->rw_backend = NULL;\n\t\t\t/* mark entry as crashed, so we'll try again later */\n\t\t\trw->rw_crashed_at = GetCurrentTimestamp();\n\t\t\tbreak;\n\n#ifndef EXEC_BACKEND\n\t\tcase 0:\n\t\t\t/* in postmaster child ... */\n\t\t\tInitPostmasterChild();\n\n\t\t\t/* Close the postmaster's sockets */\n\t\t\tClosePostmasterPorts(false);\n\n\t\t\t/*\n\t\t\t * Before blowing away PostmasterContext, save this bgworker's\n\t\t\t * data where it can find it.\n\t\t\t */\n\t\t\tMyBgworkerEntry = (BackgroundWorker *)\n\t\t\t\tMemoryContextAlloc(TopMemoryContext, sizeof(BackgroundWorker));\n\t\t\tmemcpy(MyBgworkerEntry, &rw->rw_worker, sizeof(BackgroundWorker));\n\n\t\t\t/* Release postmaster's working memory context */\n\t\t\tMemoryContextSwitchTo(TopMemoryContext);\n\t\t\tMemoryContextDelete(PostmasterContext);\n\t\t\tPostmasterContext = NULL;\n\n\t\t\tStartBackgroundWorker();\n\n\t\t\texit(1);\t\t\t/* should not get here */\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\t/* in postmaster, fork successful ... */\n\t\t\trw->rw_pid = worker_pid;\n\t\t\trw->rw_backend->pid = rw->rw_pid;\n\t\t\tReportBackgroundWorkerPID(rw);\n\t\t\t/* add new worker to lists of backends */\n\t\t\tdlist_push_head(&BackendList, &rw->rw_backend->elem);\n#ifdef EXEC_BACKEND\n\t\t\tShmemBackendArrayAdd(rw->rw_backend);\n#endif\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n/*\n * Does the current postmaster state require starting a worker with the\n * specified start_time?\n */\nstatic bool\nbgworker_should_start_now(BgWorkerStartTime start_time)\n{\n\tswitch (pmState)\n\t{\n\t\tcase PM_NO_CHILDREN:\n\t\tcase PM_WAIT_DEAD_END:\n\t\tcase PM_SHUTDOWN_2:\n\t\tcase PM_SHUTDOWN:\n\t\tcase PM_WAIT_BACKENDS:\n\t\tcase PM_STOP_BACKENDS:\n\t\t\tbreak;\n\n\t\tcase PM_RUN:\n\t\t\tif (start_time == BgWorkerStart_RecoveryFinished)\n\t\t\t\treturn true;\n\t\t\t/* fall through */\n\n\t\tcase PM_HOT_STANDBY:\n\t\t\tif (start_time == BgWorkerStart_ConsistentState)\n\t\t\t\treturn true;\n\t\t\t/* fall through */\n\n\t\tcase PM_RECOVERY:\n\t\tcase PM_STARTUP:\n\t\tcase PM_INIT:\n\t\t\tif (start_time == BgWorkerStart_PostmasterStart)\n\t\t\t\treturn true;\n\t\t\t/* fall through */\n\n\t}\n\n\treturn false;\n}\n\n/*\n * Allocate the Backend struct for a connected background worker, but don't\n * add it to the list of backends just yet.\n *\n * On failure, return false without changing any worker state.\n *\n * Some info from the Backend is copied into the passed rw.\n */\nstatic bool\nassign_backendlist_entry(RegisteredBgWorker *rw)\n{\n\tBackend    *bn;\n\n\t/*\n\t * Check that database state allows another connection.  Currently the\n\t * only possible failure is CAC_TOOMANY, so we just log an error message\n\t * based on that rather than checking the error code precisely.\n\t */\n\tif (canAcceptConnections(BACKEND_TYPE_BGWORKER) != CAC_OK)\n\t{\n\t\tereport(LOG,\n\t\t\t\t(errcode(ERRCODE_CONFIGURATION_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"no slot available for new worker process\")));\n\t\treturn false;\n\t}\n\n\t/*\n\t * Compute the cancel key that will be assigned to this session. We\n\t * probably don't need cancel keys for background workers, but we'd better\n\t * have something random in the field to prevent unfriendly people from\n\t * sending cancels to them.\n\t */\n\tif (!RandomCancelKey(&MyCancelKey))\n\t{\n\t\tereport(LOG,\n\t\t\t\t(errcode(ERRCODE_INTERNAL_ERROR),\n\t\t\t\t errmsg(\"could not generate random cancel key\")));\n\t\treturn false;\n\t}\n\n\tbn = malloc(sizeof(Backend));\n\tif (bn == NULL)\n\t{\n\t\tereport(LOG,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\")));\n\t\treturn false;\n\t}\n\n\tbn->cancel_key = MyCancelKey;\n\tbn->child_slot = MyPMChildSlot = AssignPostmasterChildSlot();\n\tbn->bkend_type = BACKEND_TYPE_BGWORKER;\n\tbn->dead_end = false;\n\tbn->bgworker_notify = false;\n\n\trw->rw_backend = bn;\n\trw->rw_child_slot = bn->child_slot;\n\n\treturn true;\n}\n\n/*\n * If the time is right, start background worker(s).\n *\n * As a side effect, the bgworker control variables are set or reset\n * depending on whether more workers may need to be started.\n *\n * We limit the number of workers started per call, to avoid consuming the\n * postmaster's attention for too long when many such requests are pending.\n * As long as StartWorkerNeeded is true, ServerLoop will not block and will\n * call this function again after dealing with any other issues.\n */\nstatic void\nmaybe_start_bgworkers(void)\n{\n#define MAX_BGWORKERS_TO_LAUNCH 100\n\tint\t\t\tnum_launched = 0;\n\tTimestampTz now = 0;\n\tslist_mutable_iter iter;\n\n\t/*\n\t * During crash recovery, we have no need to be called until the state\n\t * transition out of recovery.\n\t */\n\tif (FatalError)\n\t{\n\t\tStartWorkerNeeded = false;\n\t\tHaveCrashedWorker = false;\n\t\treturn;\n\t}\n\n\t/* Don't need to be called again unless we find a reason for it below */\n\tStartWorkerNeeded = false;\n\tHaveCrashedWorker = false;\n\n\tslist_foreach_modify(iter, &BackgroundWorkerList)\n\t{\n\t\tRegisteredBgWorker *rw;\n\n\t\trw = slist_container(RegisteredBgWorker, rw_lnode, iter.cur);\n\n\t\t/* ignore if already running */\n\t\tif (rw->rw_pid != 0)\n\t\t\tcontinue;\n\n\t\t/* if marked for death, clean up and remove from list */\n\t\tif (rw->rw_terminate)\n\t\t{\n\t\t\tForgetBackgroundWorker(&iter);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If this worker has crashed previously, maybe it needs to be\n\t\t * restarted (unless on registration it specified it doesn't want to\n\t\t * be restarted at all).  Check how long ago did a crash last happen.\n\t\t * If the last crash is too recent, don't start it right away; let it\n\t\t * be restarted once enough time has passed.\n\t\t */\n\t\tif (rw->rw_crashed_at != 0)\n\t\t{\n\t\t\tif (rw->rw_worker.bgw_restart_time == BGW_NEVER_RESTART)\n\t\t\t{\n\t\t\t\tint\t\t\tnotify_pid;\n\n\t\t\t\tnotify_pid = rw->rw_worker.bgw_notify_pid;\n\n\t\t\t\tForgetBackgroundWorker(&iter);\n\n\t\t\t\t/* Report worker is gone now. */\n\t\t\t\tif (notify_pid != 0)\n\t\t\t\t\tkill(notify_pid, SIGUSR1);\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* read system time only when needed */\n\t\t\tif (now == 0)\n\t\t\t\tnow = GetCurrentTimestamp();\n\n\t\t\tif (!TimestampDifferenceExceeds(rw->rw_crashed_at, now,\n\t\t\t\t\t\t\t\t\t\t\trw->rw_worker.bgw_restart_time * 1000))\n\t\t\t{\n\t\t\t\t/* Set flag to remember that we have workers to start later */\n\t\t\t\tHaveCrashedWorker = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (bgworker_should_start_now(rw->rw_worker.bgw_start_time))\n\t\t{\n\t\t\t/* reset crash time before trying to start worker */\n\t\t\trw->rw_crashed_at = 0;\n\n\t\t\t/*\n\t\t\t * Try to start the worker.\n\t\t\t *\n\t\t\t * On failure, give up processing workers for now, but set\n\t\t\t * StartWorkerNeeded so we'll come back here on the next iteration\n\t\t\t * of ServerLoop to try again.  (We don't want to wait, because\n\t\t\t * there might be additional ready-to-run workers.)  We could set\n\t\t\t * HaveCrashedWorker as well, since this worker is now marked\n\t\t\t * crashed, but there's no need because the next run of this\n\t\t\t * function will do that.\n\t\t\t */\n\t\t\tif (!do_start_bgworker(rw))\n\t\t\t{\n\t\t\t\tStartWorkerNeeded = true;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If we've launched as many workers as allowed, quit, but have\n\t\t\t * ServerLoop call us again to look for additional ready-to-run\n\t\t\t * workers.  There might not be any, but we'll find out the next\n\t\t\t * time we run.\n\t\t\t */\n\t\t\tif (++num_launched >= MAX_BGWORKERS_TO_LAUNCH)\n\t\t\t{\n\t\t\t\tStartWorkerNeeded = true;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/*\n * When a backend asks to be notified about worker state changes, we\n * set a flag in its backend entry.  The background worker machinery needs\n * to know when such backends exit.\n */\nbool\nPostmasterMarkPIDForWorkerNotify(int pid)\n{\n\tdlist_iter\titer;\n\tBackend    *bp;\n\n\tdlist_foreach(iter, &BackendList)\n\t{\n\t\tbp = dlist_container(Backend, elem, iter.cur);\n\t\tif (bp->pid == pid)\n\t\t{\n\t\t\tbp->bgworker_notify = true;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n#ifdef EXEC_BACKEND\n\n/*\n * The following need to be available to the save/restore_backend_variables\n * functions.  They are marked NON_EXEC_STATIC in their home modules.\n */\nextern slock_t *ShmemLock;\nextern slock_t *ProcStructLock;\nextern PGPROC *AuxiliaryProcs;\nextern PMSignalData *PMSignalState;\nextern pgsocket pgStatSock;\nextern pg_time_t first_syslogger_file_time;\n\n#ifndef WIN32\n#define write_inheritable_socket(dest, src, childpid) ((*(dest) = (src)), true)\n#define read_inheritable_socket(dest, src) (*(dest) = *(src))\n#else\nstatic bool write_duplicated_handle(HANDLE *dest, HANDLE src, HANDLE child);\nstatic bool write_inheritable_socket(InheritableSocket *dest, SOCKET src,\n\t\t\t\t\t\t\t\t\t pid_t childPid);\nstatic void read_inheritable_socket(SOCKET *dest, InheritableSocket *src);\n#endif\n\n\n/* Save critical backend variables into the BackendParameters struct */\n#ifndef WIN32\nstatic bool\nsave_backend_variables(BackendParameters *param, Port *port)\n#else\nstatic bool\nsave_backend_variables(BackendParameters *param, Port *port,\n\t\t\t\t\t   HANDLE childProcess, pid_t childPid)\n#endif\n{\n\tmemcpy(&param->port, port, sizeof(Port));\n\tif (!write_inheritable_socket(&param->portsocket, port->sock, childPid))\n\t\treturn false;\n\n\tstrlcpy(param->DataDir, DataDir, MAXPGPATH);\n\n\tmemcpy(&param->ListenSocket, &ListenSocket, sizeof(ListenSocket));\n\n\tparam->MyCancelKey = MyCancelKey;\n\tparam->MyPMChildSlot = MyPMChildSlot;\n\n#ifdef WIN32\n\tparam->ShmemProtectiveRegion = ShmemProtectiveRegion;\n#endif\n\tparam->UsedShmemSegID = UsedShmemSegID;\n\tparam->UsedShmemSegAddr = UsedShmemSegAddr;\n\n\tparam->ShmemLock = ShmemLock;\n\tparam->ShmemVariableCache = ShmemVariableCache;\n\tparam->ShmemBackendArray = ShmemBackendArray;\n\n#ifndef HAVE_SPINLOCKS\n\tparam->SpinlockSemaArray = SpinlockSemaArray;\n#endif\n\tparam->NamedLWLockTrancheRequests = NamedLWLockTrancheRequests;\n\tparam->NamedLWLockTrancheArray = NamedLWLockTrancheArray;\n\tparam->MainLWLockArray = MainLWLockArray;\n\tparam->ProcStructLock = ProcStructLock;\n\tparam->ProcGlobal = ProcGlobal;\n\tparam->AuxiliaryProcs = AuxiliaryProcs;\n\tparam->PreparedXactProcs = PreparedXactProcs;\n\tparam->PMSignalState = PMSignalState;\n\tif (!write_inheritable_socket(&param->pgStatSock, pgStatSock, childPid))\n\t\treturn false;\n\n\tparam->PostmasterPid = PostmasterPid;\n\tparam->PgStartTime = PgStartTime;\n\tparam->PgReloadTime = PgReloadTime;\n\tparam->first_syslogger_file_time = first_syslogger_file_time;\n\n\tparam->redirection_done = redirection_done;\n\tparam->IsBinaryUpgrade = IsBinaryUpgrade;\n\tparam->query_id_enabled = query_id_enabled;\n\tparam->max_safe_fds = max_safe_fds;\n\n\tparam->MaxBackends = MaxBackends;\n\n#ifdef WIN32\n\tparam->PostmasterHandle = PostmasterHandle;\n\tif (!write_duplicated_handle(&param->initial_signal_pipe,\n\t\t\t\t\t\t\t\t pgwin32_create_signal_listener(childPid),\n\t\t\t\t\t\t\t\t childProcess))\n\t\treturn false;\n#else\n\tmemcpy(&param->postmaster_alive_fds, &postmaster_alive_fds,\n\t\t   sizeof(postmaster_alive_fds));\n#endif\n\n\tmemcpy(&param->syslogPipe, &syslogPipe, sizeof(syslogPipe));\n\n\tstrlcpy(param->my_exec_path, my_exec_path, MAXPGPATH);\n\n\tstrlcpy(param->pkglib_path, pkglib_path, MAXPGPATH);\n\n\treturn true;\n}\n\n\n#ifdef WIN32\n/*\n * Duplicate a handle for usage in a child process, and write the child\n * process instance of the handle to the parameter file.\n */\nstatic bool\nwrite_duplicated_handle(HANDLE *dest, HANDLE src, HANDLE childProcess)\n{\n\tHANDLE\t\thChild = INVALID_HANDLE_VALUE;\n\n\tif (!DuplicateHandle(GetCurrentProcess(),\n\t\t\t\t\t\t src,\n\t\t\t\t\t\t childProcess,\n\t\t\t\t\t\t &hChild,\n\t\t\t\t\t\t 0,\n\t\t\t\t\t\t TRUE,\n\t\t\t\t\t\t DUPLICATE_CLOSE_SOURCE | DUPLICATE_SAME_ACCESS))\n\t{\n\t\tereport(LOG,\n\t\t\t\t(errmsg_internal(\"could not duplicate handle to be written to backend parameter file: error code %lu\",\n\t\t\t\t\t\t\t\t GetLastError())));\n\t\treturn false;\n\t}\n\n\t*dest = hChild;\n\treturn true;\n}\n\n/*\n * Duplicate a socket for usage in a child process, and write the resulting\n * structure to the parameter file.\n * This is required because a number of LSPs (Layered Service Providers) very\n * common on Windows (antivirus, firewalls, download managers etc) break\n * straight socket inheritance.\n */\nstatic bool\nwrite_inheritable_socket(InheritableSocket *dest, SOCKET src, pid_t childpid)\n{\n\tdest->origsocket = src;\n\tif (src != 0 && src != PGINVALID_SOCKET)\n\t{\n\t\t/* Actual socket */\n\t\tif (WSADuplicateSocket(src, childpid, &dest->wsainfo) != 0)\n\t\t{\n\t\t\tereport(LOG,\n\t\t\t\t\t(errmsg(\"could not duplicate socket %d for use in backend: error code %d\",\n\t\t\t\t\t\t\t(int) src, WSAGetLastError())));\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n/*\n * Read a duplicate socket structure back, and get the socket descriptor.\n */\nstatic void\nread_inheritable_socket(SOCKET *dest, InheritableSocket *src)\n{\n\tSOCKET\t\ts;\n\n\tif (src->origsocket == PGINVALID_SOCKET || src->origsocket == 0)\n\t{\n\t\t/* Not a real socket! */\n\t\t*dest = src->origsocket;\n\t}\n\telse\n\t{\n\t\t/* Actual socket, so create from structure */\n\t\ts = WSASocket(FROM_PROTOCOL_INFO,\n\t\t\t\t\t  FROM_PROTOCOL_INFO,\n\t\t\t\t\t  FROM_PROTOCOL_INFO,\n\t\t\t\t\t  &src->wsainfo,\n\t\t\t\t\t  0,\n\t\t\t\t\t  0);\n\t\tif (s == INVALID_SOCKET)\n\t\t{\n\t\t\twrite_stderr(\"could not create inherited socket: error code %d\\n\",\n\t\t\t\t\t\t WSAGetLastError());\n\t\t\texit(1);\n\t\t}\n\t\t*dest = s;\n\n\t\t/*\n\t\t * To make sure we don't get two references to the same socket, close\n\t\t * the original one. (This would happen when inheritance actually\n\t\t * works..\n\t\t */\n\t\tclosesocket(src->origsocket);\n\t}\n}\n#endif\n\nstatic void\nread_backend_variables(char *id, Port *port)\n{\n\tBackendParameters param;\n\n#ifndef WIN32\n\t/* Non-win32 implementation reads from file */\n\tFILE\t   *fp;\n\n\t/* Open file */\n\tfp = AllocateFile(id, PG_BINARY_R);\n\tif (!fp)\n\t{\n\t\twrite_stderr(\"could not open backend variables file \\\"%s\\\": %s\\n\",\n\t\t\t\t\t id, strerror(errno));\n\t\texit(1);\n\t}\n\n\tif (fread(&param, sizeof(param), 1, fp) != 1)\n\t{\n\t\twrite_stderr(\"could not read from backend variables file \\\"%s\\\": %s\\n\",\n\t\t\t\t\t id, strerror(errno));\n\t\texit(1);\n\t}\n\n\t/* Release file */\n\tFreeFile(fp);\n\tif (unlink(id) != 0)\n\t{\n\t\twrite_stderr(\"could not remove file \\\"%s\\\": %s\\n\",\n\t\t\t\t\t id, strerror(errno));\n\t\texit(1);\n\t}\n#else\n\t/* Win32 version uses mapped file */\n\tHANDLE\t\tparamHandle;\n\tBackendParameters *paramp;\n\n#ifdef _WIN64\n\tparamHandle = (HANDLE) _atoi64(id);\n#else\n\tparamHandle = (HANDLE) atol(id);\n#endif\n\tparamp = MapViewOfFile(paramHandle, FILE_MAP_READ, 0, 0, 0);\n\tif (!paramp)\n\t{\n\t\twrite_stderr(\"could not map view of backend variables: error code %lu\\n\",\n\t\t\t\t\t GetLastError());\n\t\texit(1);\n\t}\n\n\tmemcpy(&param, paramp, sizeof(BackendParameters));\n\n\tif (!UnmapViewOfFile(paramp))\n\t{\n\t\twrite_stderr(\"could not unmap view of backend variables: error code %lu\\n\",\n\t\t\t\t\t GetLastError());\n\t\texit(1);\n\t}\n\n\tif (!CloseHandle(paramHandle))\n\t{\n\t\twrite_stderr(\"could not close handle to backend parameter variables: error code %lu\\n\",\n\t\t\t\t\t GetLastError());\n\t\texit(1);\n\t}\n#endif\n\n\trestore_backend_variables(&param, port);\n}\n\n/* Restore critical backend variables from the BackendParameters struct */\nstatic void\nrestore_backend_variables(BackendParameters *param, Port *port)\n{\n\tmemcpy(port, &param->port, sizeof(Port));\n\tread_inheritable_socket(&port->sock, &param->portsocket);\n\n\tSetDataDir(param->DataDir);\n\n\tmemcpy(&ListenSocket, &param->ListenSocket, sizeof(ListenSocket));\n\n\tMyCancelKey = param->MyCancelKey;\n\tMyPMChildSlot = param->MyPMChildSlot;\n\n#ifdef WIN32\n\tShmemProtectiveRegion = param->ShmemProtectiveRegion;\n#endif\n\tUsedShmemSegID = param->UsedShmemSegID;\n\tUsedShmemSegAddr = param->UsedShmemSegAddr;\n\n\tShmemLock = param->ShmemLock;\n\tShmemVariableCache = param->ShmemVariableCache;\n\tShmemBackendArray = param->ShmemBackendArray;\n\n#ifndef HAVE_SPINLOCKS\n\tSpinlockSemaArray = param->SpinlockSemaArray;\n#endif\n\tNamedLWLockTrancheRequests = param->NamedLWLockTrancheRequests;\n\tNamedLWLockTrancheArray = param->NamedLWLockTrancheArray;\n\tMainLWLockArray = param->MainLWLockArray;\n\tProcStructLock = param->ProcStructLock;\n\tProcGlobal = param->ProcGlobal;\n\tAuxiliaryProcs = param->AuxiliaryProcs;\n\tPreparedXactProcs = param->PreparedXactProcs;\n\tPMSignalState = param->PMSignalState;\n\tread_inheritable_socket(&pgStatSock, &param->pgStatSock);\n\n\tPostmasterPid = param->PostmasterPid;\n\tPgStartTime = param->PgStartTime;\n\tPgReloadTime = param->PgReloadTime;\n\tfirst_syslogger_file_time = param->first_syslogger_file_time;\n\n\tredirection_done = param->redirection_done;\n\tIsBinaryUpgrade = param->IsBinaryUpgrade;\n\tquery_id_enabled = param->query_id_enabled;\n\tmax_safe_fds = param->max_safe_fds;\n\n\tMaxBackends = param->MaxBackends;\n\n#ifdef WIN32\n\tPostmasterHandle = param->PostmasterHandle;\n\tpgwin32_initial_signal_pipe = param->initial_signal_pipe;\n#else\n\tmemcpy(&postmaster_alive_fds, &param->postmaster_alive_fds,\n\t\t   sizeof(postmaster_alive_fds));\n#endif\n\n\tmemcpy(&syslogPipe, &param->syslogPipe, sizeof(syslogPipe));\n\n\tstrlcpy(my_exec_path, param->my_exec_path, MAXPGPATH);\n\n\tstrlcpy(pkglib_path, param->pkglib_path, MAXPGPATH);\n\n\t/*\n\t * We need to restore fd.c's counts of externally-opened FDs; to avoid\n\t * confusion, be sure to do this after restoring max_safe_fds.  (Note:\n\t * BackendInitialize will handle this for port->sock.)\n\t */\n#ifndef WIN32\n\tif (postmaster_alive_fds[0] >= 0)\n\t\tReserveExternalFD();\n\tif (postmaster_alive_fds[1] >= 0)\n\t\tReserveExternalFD();\n#endif\n\tif (pgStatSock != PGINVALID_SOCKET)\n\t\tReserveExternalFD();\n}\n\n\nSize\nShmemBackendArraySize(void)\n{\n\treturn mul_size(MaxLivePostmasterChildren(), sizeof(Backend));\n}\n\nvoid\nShmemBackendArrayAllocation(void)\n{\n\tSize\t\tsize = ShmemBackendArraySize();\n\n\tShmemBackendArray = (Backend *) ShmemAlloc(size);\n\t/* Mark all slots as empty */\n\tmemset(ShmemBackendArray, 0, size);\n}\n\nstatic void\nShmemBackendArrayAdd(Backend *bn)\n{\n\t/* The array slot corresponding to my PMChildSlot should be free */\n\tint\t\t\ti = bn->child_slot - 1;\n\n\tAssert(ShmemBackendArray[i].pid == 0);\n\tShmemBackendArray[i] = *bn;\n}\n\nstatic void\nShmemBackendArrayRemove(Backend *bn)\n{\n\tint\t\t\ti = bn->child_slot - 1;\n\n\tAssert(ShmemBackendArray[i].pid == bn->pid);\n\t/* Mark the slot as empty */\n\tShmemBackendArray[i].pid = 0;\n}\n#endif\t\t\t\t\t\t\t/* EXEC_BACKEND */\n\n\n#ifdef WIN32\n\n/*\n * Subset implementation of waitpid() for Windows.  We assume pid is -1\n * (that is, check all child processes) and options is WNOHANG (don't wait).\n */\nstatic pid_t\nwaitpid(pid_t pid, int *exitstatus, int options)\n{\n\tDWORD\t\tdwd;\n\tULONG_PTR\tkey;\n\tOVERLAPPED *ovl;\n\n\t/*\n\t * Check if there are any dead children. If there are, return the pid of\n\t * the first one that died.\n\t */\n\tif (GetQueuedCompletionStatus(win32ChildQueue, &dwd, &key, &ovl, 0))\n\t{\n\t\t*exitstatus = (int) key;\n\t\treturn dwd;\n\t}\n\n\treturn -1;\n}\n\n/*\n * Note! Code below executes on a thread pool! All operations must\n * be thread safe! Note that elog() and friends must *not* be used.\n */\nstatic void WINAPI\npgwin32_deadchild_callback(PVOID lpParameter, BOOLEAN TimerOrWaitFired)\n{\n\twin32_deadchild_waitinfo *childinfo = (win32_deadchild_waitinfo *) lpParameter;\n\tDWORD\t\texitcode;\n\n\tif (TimerOrWaitFired)\n\t\treturn;\t\t\t\t\t/* timeout. Should never happen, since we use\n\t\t\t\t\t\t\t\t * INFINITE as timeout value. */\n\n\t/*\n\t * Remove handle from wait - required even though it's set to wait only\n\t * once\n\t */\n\tUnregisterWaitEx(childinfo->waitHandle, NULL);\n\n\tif (!GetExitCodeProcess(childinfo->procHandle, &exitcode))\n\t{\n\t\t/*\n\t\t * Should never happen. Inform user and set a fixed exitcode.\n\t\t */\n\t\twrite_stderr(\"could not read exit code for process\\n\");\n\t\texitcode = 255;\n\t}\n\n\tif (!PostQueuedCompletionStatus(win32ChildQueue, childinfo->procId, (ULONG_PTR) exitcode, NULL))\n\t\twrite_stderr(\"could not post child completion status\\n\");\n\n\t/*\n\t * Handle is per-process, so we close it here instead of in the\n\t * originating thread\n\t */\n\tCloseHandle(childinfo->procHandle);\n\n\t/*\n\t * Free struct that was allocated before the call to\n\t * RegisterWaitForSingleObject()\n\t */\n\tfree(childinfo);\n\n\t/* Queue SIGCHLD signal */\n\tpg_queue_signal(SIGCHLD);\n}\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\n/*\n * Initialize one and only handle for monitoring postmaster death.\n *\n * Called once in the postmaster, so that child processes can subsequently\n * monitor if their parent is dead.\n */\nstatic void\nInitPostmasterDeathWatchHandle(void)\n{\n#ifndef WIN32\n\n\t/*\n\t * Create a pipe. Postmaster holds the write end of the pipe open\n\t * (POSTMASTER_FD_OWN), and children hold the read end. Children can pass\n\t * the read file descriptor to select() to wake up in case postmaster\n\t * dies, or check for postmaster death with a (read() == 0). Children must\n\t * close the write end as soon as possible after forking, because EOF\n\t * won't be signaled in the read end until all processes have closed the\n\t * write fd. That is taken care of in ClosePostmasterPorts().\n\t */\n\tAssert(MyProcPid == PostmasterPid);\n\tif (pipe(postmaster_alive_fds) < 0)\n\t\tereport(FATAL,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg_internal(\"could not create pipe to monitor postmaster death: %m\")));\n\n\t/* Notify fd.c that we've eaten two FDs for the pipe. */\n\tReserveExternalFD();\n\tReserveExternalFD();\n\n\t/*\n\t * Set O_NONBLOCK to allow testing for the fd's presence with a read()\n\t * call.\n\t */\n\tif (fcntl(postmaster_alive_fds[POSTMASTER_FD_WATCH], F_SETFL, O_NONBLOCK) == -1)\n\t\tereport(FATAL,\n\t\t\t\t(errcode_for_socket_access(),\n\t\t\t\t errmsg_internal(\"could not set postmaster death monitoring pipe to nonblocking mode: %m\")));\n#else\n\n\t/*\n\t * On Windows, we use a process handle for the same purpose.\n\t */\n\tif (DuplicateHandle(GetCurrentProcess(),\n\t\t\t\t\t\tGetCurrentProcess(),\n\t\t\t\t\t\tGetCurrentProcess(),\n\t\t\t\t\t\t&PostmasterHandle,\n\t\t\t\t\t\t0,\n\t\t\t\t\t\tTRUE,\n\t\t\t\t\t\tDUPLICATE_SAME_ACCESS) == 0)\n\t\tereport(FATAL,\n\t\t\t\t(errmsg_internal(\"could not duplicate postmaster handle: error code %lu\",\n\t\t\t\t\t\t\t\t GetLastError())));\n#endif\t\t\t\t\t\t\t/* WIN32 */\n}\n", "/*-------------------------------------------------------------------------\n *\n * libpq.h\n *\t  POSTGRES LIBPQ buffer structure definitions.\n *\n *\n * Portions Copyright (c) 1996-2021, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n * src/include/libpq/libpq.h\n *\n *-------------------------------------------------------------------------\n */\n#ifndef LIBPQ_H\n#define LIBPQ_H\n\n#include <netinet/in.h>\n\n#include \"lib/stringinfo.h\"\n#include \"libpq/libpq-be.h\"\n#include \"storage/latch.h\"\n\n\n/*\n * Callers of pq_getmessage() must supply a maximum expected message size.\n * By convention, if there's not any specific reason to use another value,\n * use PQ_SMALL_MESSAGE_LIMIT for messages that shouldn't be too long, and\n * PQ_LARGE_MESSAGE_LIMIT for messages that can be long.\n */\n#define PQ_SMALL_MESSAGE_LIMIT\t10000\n#define PQ_LARGE_MESSAGE_LIMIT\t(MaxAllocSize - 1)\n\ntypedef struct\n{\n\tvoid\t\t(*comm_reset) (void);\n\tint\t\t\t(*flush) (void);\n\tint\t\t\t(*flush_if_writable) (void);\n\tbool\t\t(*is_send_pending) (void);\n\tint\t\t\t(*putmessage) (char msgtype, const char *s, size_t len);\n\tvoid\t\t(*putmessage_noblock) (char msgtype, const char *s, size_t len);\n} PQcommMethods;\n\nextern const PGDLLIMPORT PQcommMethods *PqCommMethods;\n\n#define pq_comm_reset() (PqCommMethods->comm_reset())\n#define pq_flush() (PqCommMethods->flush())\n#define pq_flush_if_writable() (PqCommMethods->flush_if_writable())\n#define pq_is_send_pending() (PqCommMethods->is_send_pending())\n#define pq_putmessage(msgtype, s, len) \\\n\t(PqCommMethods->putmessage(msgtype, s, len))\n#define pq_putmessage_noblock(msgtype, s, len) \\\n\t(PqCommMethods->putmessage_noblock(msgtype, s, len))\n\n/*\n * External functions.\n */\n\n/*\n * prototypes for functions in pqcomm.c\n */\nextern WaitEventSet *FeBeWaitSet;\n\n#define FeBeWaitSetSocketPos 0\n#define FeBeWaitSetLatchPos 1\n\nextern int\tStreamServerPort(int family, const char *hostName,\n\t\t\t\t\t\t\t unsigned short portNumber, const char *unixSocketDir,\n\t\t\t\t\t\t\t pgsocket ListenSocket[], int MaxListen);\nextern int\tStreamConnection(pgsocket server_fd, Port *port);\nextern void StreamClose(pgsocket sock);\nextern void TouchSocketFiles(void);\nextern void RemoveSocketFiles(void);\nextern void pq_init(void);\nextern int\tpq_getbytes(char *s, size_t len);\nextern void pq_startmsgread(void);\nextern void pq_endmsgread(void);\nextern bool pq_is_reading_msg(void);\nextern int\tpq_getmessage(StringInfo s, int maxlen);\nextern int\tpq_getbyte(void);\nextern int\tpq_peekbyte(void);\nextern int\tpq_getbyte_if_available(unsigned char *c);\nextern int\tpq_putmessage_v2(char msgtype, const char *s, size_t len);\nextern bool pq_check_connection(void);\n\n/*\n * prototypes for functions in be-secure.c\n */\nextern char *ssl_library;\nextern char *ssl_cert_file;\nextern char *ssl_key_file;\nextern char *ssl_ca_file;\nextern char *ssl_crl_file;\nextern char *ssl_crl_dir;\nextern char *ssl_dh_params_file;\nextern PGDLLIMPORT char *ssl_passphrase_command;\nextern PGDLLIMPORT bool ssl_passphrase_command_supports_reload;\n#ifdef USE_SSL\nextern bool ssl_loaded_verify_locations;\n#endif\n\nextern int\tsecure_initialize(bool isServerStart);\nextern bool secure_loaded_verify_locations(void);\nextern void secure_destroy(void);\nextern int\tsecure_open_server(Port *port);\nextern void secure_close(Port *port);\nextern ssize_t secure_read(Port *port, void *ptr, size_t len);\nextern ssize_t secure_write(Port *port, void *ptr, size_t len);\nextern ssize_t secure_raw_read(Port *port, void *ptr, size_t len);\nextern ssize_t secure_raw_write(Port *port, const void *ptr, size_t len);\n\n/*\n * prototypes for functions in be-secure-gssapi.c\n */\n#ifdef ENABLE_GSS\nextern ssize_t secure_open_gssapi(Port *port);\n#endif\n\n/* GUCs */\nextern char *SSLCipherSuites;\nextern char *SSLECDHCurve;\nextern bool SSLPreferServerCiphers;\nextern int\tssl_min_protocol_version;\nextern int\tssl_max_protocol_version;\n\nenum ssl_protocol_versions\n{\n\tPG_TLS_ANY = 0,\n\tPG_TLS1_VERSION,\n\tPG_TLS1_1_VERSION,\n\tPG_TLS1_2_VERSION,\n\tPG_TLS1_3_VERSION,\n};\n\n/*\n * prototypes for functions in be-secure-common.c\n */\nextern int\trun_ssl_passphrase_command(const char *prompt, bool is_server_start,\n\t\t\t\t\t\t\t\t\t   char *buf, int size);\nextern bool check_ssl_key_file_permissions(const char *ssl_key_file,\n\t\t\t\t\t\t\t\t\t\t   bool isServerStart);\n\n#endif\t\t\t\t\t\t\t/* LIBPQ_H */\n"], "fixing_code": ["/*-------------------------------------------------------------------------\n *\n * pqcomm.c\n *\t  Communication functions between the Frontend and the Backend\n *\n * These routines handle the low-level details of communication between\n * frontend and backend.  They just shove data across the communication\n * channel, and are ignorant of the semantics of the data.\n *\n * To emit an outgoing message, use the routines in pqformat.c to construct\n * the message in a buffer and then emit it in one call to pq_putmessage.\n * There are no functions to send raw bytes or partial messages; this\n * ensures that the channel will not be clogged by an incomplete message if\n * execution is aborted by ereport(ERROR) partway through the message.\n *\n * At one time, libpq was shared between frontend and backend, but now\n * the backend's \"backend/libpq\" is quite separate from \"interfaces/libpq\".\n * All that remains is similarities of names to trap the unwary...\n *\n * Portions Copyright (c) 1996-2021, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n *\tsrc/backend/libpq/pqcomm.c\n *\n *-------------------------------------------------------------------------\n */\n\n/*------------------------\n * INTERFACE ROUTINES\n *\n * setup/teardown:\n *\t\tStreamServerPort\t- Open postmaster's server port\n *\t\tStreamConnection\t- Create new connection with client\n *\t\tStreamClose\t\t\t- Close a client/backend connection\n *\t\tTouchSocketFiles\t- Protect socket files against /tmp cleaners\n *\t\tpq_init\t\t\t- initialize libpq at backend startup\n *\t\tsocket_comm_reset\t- reset libpq during error recovery\n *\t\tsocket_close\t\t- shutdown libpq at backend exit\n *\n * low-level I/O:\n *\t\tpq_getbytes\t\t- get a known number of bytes from connection\n *\t\tpq_getmessage\t- get a message with length word from connection\n *\t\tpq_getbyte\t\t- get next byte from connection\n *\t\tpq_peekbyte\t\t- peek at next byte from connection\n *\t\tpq_flush\t\t- flush pending output\n *\t\tpq_flush_if_writable - flush pending output if writable without blocking\n *\t\tpq_getbyte_if_available - get a byte if available without blocking\n *\n * message-level I/O\n *\t\tpq_putmessage\t- send a normal message (suppressed in COPY OUT mode)\n *\t\tpq_putmessage_noblock - buffer a normal message (suppressed in COPY OUT)\n *\n *------------------------\n */\n#include \"postgres.h\"\n\n#ifdef HAVE_POLL_H\n#include <poll.h>\n#endif\n#include <signal.h>\n#include <fcntl.h>\n#include <grp.h>\n#include <unistd.h>\n#include <sys/file.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#ifdef HAVE_NETINET_TCP_H\n#include <netinet/tcp.h>\n#endif\n#include <utime.h>\n#ifdef _MSC_VER\t\t\t\t\t/* mstcpip.h is missing on mingw */\n#include <mstcpip.h>\n#endif\n\n#include \"common/ip.h\"\n#include \"libpq/libpq.h\"\n#include \"miscadmin.h\"\n#include \"port/pg_bswap.h\"\n#include \"storage/ipc.h\"\n#include \"utils/guc.h\"\n#include \"utils/memutils.h\"\n\n/*\n * Cope with the various platform-specific ways to spell TCP keepalive socket\n * options.  This doesn't cover Windows, which as usual does its own thing.\n */\n#if defined(TCP_KEEPIDLE)\n/* TCP_KEEPIDLE is the name of this option on Linux and *BSD */\n#define PG_TCP_KEEPALIVE_IDLE TCP_KEEPIDLE\n#define PG_TCP_KEEPALIVE_IDLE_STR \"TCP_KEEPIDLE\"\n#elif defined(TCP_KEEPALIVE_THRESHOLD)\n/* TCP_KEEPALIVE_THRESHOLD is the name of this option on Solaris >= 11 */\n#define PG_TCP_KEEPALIVE_IDLE TCP_KEEPALIVE_THRESHOLD\n#define PG_TCP_KEEPALIVE_IDLE_STR \"TCP_KEEPALIVE_THRESHOLD\"\n#elif defined(TCP_KEEPALIVE) && defined(__darwin__)\n/* TCP_KEEPALIVE is the name of this option on macOS */\n/* Caution: Solaris has this symbol but it means something different */\n#define PG_TCP_KEEPALIVE_IDLE TCP_KEEPALIVE\n#define PG_TCP_KEEPALIVE_IDLE_STR \"TCP_KEEPALIVE\"\n#endif\n\n/*\n * Configuration options\n */\nint\t\t\tUnix_socket_permissions;\nchar\t   *Unix_socket_group;\n\n/* Where the Unix socket files are (list of palloc'd strings) */\nstatic List *sock_paths = NIL;\n\n/*\n * Buffers for low-level I/O.\n *\n * The receive buffer is fixed size. Send buffer is usually 8k, but can be\n * enlarged by pq_putmessage_noblock() if the message doesn't fit otherwise.\n */\n\n#define PQ_SEND_BUFFER_SIZE 8192\n#define PQ_RECV_BUFFER_SIZE 8192\n\nstatic char *PqSendBuffer;\nstatic int\tPqSendBufferSize;\t/* Size send buffer */\nstatic int\tPqSendPointer;\t\t/* Next index to store a byte in PqSendBuffer */\nstatic int\tPqSendStart;\t\t/* Next index to send a byte in PqSendBuffer */\n\nstatic char PqRecvBuffer[PQ_RECV_BUFFER_SIZE];\nstatic int\tPqRecvPointer;\t\t/* Next index to read a byte from PqRecvBuffer */\nstatic int\tPqRecvLength;\t\t/* End of data available in PqRecvBuffer */\n\n/*\n * Message status\n */\nstatic bool PqCommBusy;\t\t\t/* busy sending data to the client */\nstatic bool PqCommReadingMsg;\t/* in the middle of reading a message */\n\n\n/* Internal functions */\nstatic void socket_comm_reset(void);\nstatic void socket_close(int code, Datum arg);\nstatic void socket_set_nonblocking(bool nonblocking);\nstatic int\tsocket_flush(void);\nstatic int\tsocket_flush_if_writable(void);\nstatic bool socket_is_send_pending(void);\nstatic int\tsocket_putmessage(char msgtype, const char *s, size_t len);\nstatic void socket_putmessage_noblock(char msgtype, const char *s, size_t len);\nstatic int\tinternal_putbytes(const char *s, size_t len);\nstatic int\tinternal_flush(void);\n\n#ifdef HAVE_UNIX_SOCKETS\nstatic int\tLock_AF_UNIX(const char *unixSocketDir, const char *unixSocketPath);\nstatic int\tSetup_AF_UNIX(const char *sock_path);\n#endif\t\t\t\t\t\t\t/* HAVE_UNIX_SOCKETS */\n\nstatic const PQcommMethods PqCommSocketMethods = {\n\tsocket_comm_reset,\n\tsocket_flush,\n\tsocket_flush_if_writable,\n\tsocket_is_send_pending,\n\tsocket_putmessage,\n\tsocket_putmessage_noblock\n};\n\nconst PQcommMethods *PqCommMethods = &PqCommSocketMethods;\n\nWaitEventSet *FeBeWaitSet;\n\n\n/* --------------------------------\n *\t\tpq_init - initialize libpq at backend startup\n * --------------------------------\n */\nvoid\npq_init(void)\n{\n\tint\t\t\tsocket_pos PG_USED_FOR_ASSERTS_ONLY;\n\tint\t\t\tlatch_pos PG_USED_FOR_ASSERTS_ONLY;\n\n\t/* initialize state variables */\n\tPqSendBufferSize = PQ_SEND_BUFFER_SIZE;\n\tPqSendBuffer = MemoryContextAlloc(TopMemoryContext, PqSendBufferSize);\n\tPqSendPointer = PqSendStart = PqRecvPointer = PqRecvLength = 0;\n\tPqCommBusy = false;\n\tPqCommReadingMsg = false;\n\n\t/* set up process-exit hook to close the socket */\n\ton_proc_exit(socket_close, 0);\n\n\t/*\n\t * In backends (as soon as forked) we operate the underlying socket in\n\t * nonblocking mode and use latches to implement blocking semantics if\n\t * needed. That allows us to provide safely interruptible reads and\n\t * writes.\n\t *\n\t * Use COMMERROR on failure, because ERROR would try to send the error to\n\t * the client, which might require changing the mode again, leading to\n\t * infinite recursion.\n\t */\n#ifndef WIN32\n\tif (!pg_set_noblock(MyProcPort->sock))\n\t\tereport(COMMERROR,\n\t\t\t\t(errmsg(\"could not set socket to nonblocking mode: %m\")));\n#endif\n\n\tFeBeWaitSet = CreateWaitEventSet(TopMemoryContext, 3);\n\tsocket_pos = AddWaitEventToSet(FeBeWaitSet, WL_SOCKET_WRITEABLE,\n\t\t\t\t\t\t\t\t   MyProcPort->sock, NULL, NULL);\n\tlatch_pos = AddWaitEventToSet(FeBeWaitSet, WL_LATCH_SET, PGINVALID_SOCKET,\n\t\t\t\t\t\t\t\t  MyLatch, NULL);\n\tAddWaitEventToSet(FeBeWaitSet, WL_POSTMASTER_DEATH, PGINVALID_SOCKET,\n\t\t\t\t\t  NULL, NULL);\n\n\t/*\n\t * The event positions match the order we added them, but let's sanity\n\t * check them to be sure.\n\t */\n\tAssert(socket_pos == FeBeWaitSetSocketPos);\n\tAssert(latch_pos == FeBeWaitSetLatchPos);\n}\n\n/* --------------------------------\n *\t\tsocket_comm_reset - reset libpq during error recovery\n *\n * This is called from error recovery at the outer idle loop.  It's\n * just to get us out of trouble if we somehow manage to elog() from\n * inside a pqcomm.c routine (which ideally will never happen, but...)\n * --------------------------------\n */\nstatic void\nsocket_comm_reset(void)\n{\n\t/* Do not throw away pending data, but do reset the busy flag */\n\tPqCommBusy = false;\n}\n\n/* --------------------------------\n *\t\tsocket_close - shutdown libpq at backend exit\n *\n * This is the one pg_on_exit_callback in place during BackendInitialize().\n * That function's unusual signal handling constrains that this callback be\n * safe to run at any instant.\n * --------------------------------\n */\nstatic void\nsocket_close(int code, Datum arg)\n{\n\t/* Nothing to do in a standalone backend, where MyProcPort is NULL. */\n\tif (MyProcPort != NULL)\n\t{\n#ifdef ENABLE_GSS\n\t\t/*\n\t\t * Shutdown GSSAPI layer.  This section does nothing when interrupting\n\t\t * BackendInitialize(), because pg_GSS_recvauth() makes first use of\n\t\t * \"ctx\" and \"cred\".\n\t\t *\n\t\t * Note that we don't bother to free MyProcPort->gss, since we're\n\t\t * about to exit anyway.\n\t\t */\n\t\tif (MyProcPort->gss)\n\t\t{\n\t\t\tOM_uint32\tmin_s;\n\n\t\t\tif (MyProcPort->gss->ctx != GSS_C_NO_CONTEXT)\n\t\t\t\tgss_delete_sec_context(&min_s, &MyProcPort->gss->ctx, NULL);\n\n\t\t\tif (MyProcPort->gss->cred != GSS_C_NO_CREDENTIAL)\n\t\t\t\tgss_release_cred(&min_s, &MyProcPort->gss->cred);\n\t\t}\n#endif\t\t\t\t\t\t\t/* ENABLE_GSS */\n\n\t\t/*\n\t\t * Cleanly shut down SSL layer.  Nowhere else does a postmaster child\n\t\t * call this, so this is safe when interrupting BackendInitialize().\n\t\t */\n\t\tsecure_close(MyProcPort);\n\n\t\t/*\n\t\t * Formerly we did an explicit close() here, but it seems better to\n\t\t * leave the socket open until the process dies.  This allows clients\n\t\t * to perform a \"synchronous close\" if they care --- wait till the\n\t\t * transport layer reports connection closure, and you can be sure the\n\t\t * backend has exited.\n\t\t *\n\t\t * We do set sock to PGINVALID_SOCKET to prevent any further I/O,\n\t\t * though.\n\t\t */\n\t\tMyProcPort->sock = PGINVALID_SOCKET;\n\t}\n}\n\n\n\n/*\n * Streams -- wrapper around Unix socket system calls\n *\n *\n *\t\tStream functions are used for vanilla TCP connection protocol.\n */\n\n\n/*\n * StreamServerPort -- open a \"listening\" port to accept connections.\n *\n * family should be AF_UNIX or AF_UNSPEC; portNumber is the port number.\n * For AF_UNIX ports, hostName should be NULL and unixSocketDir must be\n * specified.  For TCP ports, hostName is either NULL for all interfaces or\n * the interface to listen on, and unixSocketDir is ignored (can be NULL).\n *\n * Successfully opened sockets are added to the ListenSocket[] array (of\n * length MaxListen), at the first position that isn't PGINVALID_SOCKET.\n *\n * RETURNS: STATUS_OK or STATUS_ERROR\n */\n\nint\nStreamServerPort(int family, const char *hostName, unsigned short portNumber,\n\t\t\t\t const char *unixSocketDir,\n\t\t\t\t pgsocket ListenSocket[], int MaxListen)\n{\n\tpgsocket\tfd;\n\tint\t\t\terr;\n\tint\t\t\tmaxconn;\n\tint\t\t\tret;\n\tchar\t\tportNumberStr[32];\n\tconst char *familyDesc;\n\tchar\t\tfamilyDescBuf[64];\n\tconst char *addrDesc;\n\tchar\t\taddrBuf[NI_MAXHOST];\n\tchar\t   *service;\n\tstruct addrinfo *addrs = NULL,\n\t\t\t   *addr;\n\tstruct addrinfo hint;\n\tint\t\t\tlisten_index = 0;\n\tint\t\t\tadded = 0;\n\n#ifdef HAVE_UNIX_SOCKETS\n\tchar\t\tunixSocketPath[MAXPGPATH];\n#endif\n#if !defined(WIN32) || defined(IPV6_V6ONLY)\n\tint\t\t\tone = 1;\n#endif\n\n\t/* Initialize hint structure */\n\tMemSet(&hint, 0, sizeof(hint));\n\thint.ai_family = family;\n\thint.ai_flags = AI_PASSIVE;\n\thint.ai_socktype = SOCK_STREAM;\n\n#ifdef HAVE_UNIX_SOCKETS\n\tif (family == AF_UNIX)\n\t{\n\t\t/*\n\t\t * Create unixSocketPath from portNumber and unixSocketDir and lock\n\t\t * that file path\n\t\t */\n\t\tUNIXSOCK_PATH(unixSocketPath, portNumber, unixSocketDir);\n\t\tif (strlen(unixSocketPath) >= UNIXSOCK_PATH_BUFLEN)\n\t\t{\n\t\t\tereport(LOG,\n\t\t\t\t\t(errmsg(\"Unix-domain socket path \\\"%s\\\" is too long (maximum %d bytes)\",\n\t\t\t\t\t\t\tunixSocketPath,\n\t\t\t\t\t\t\t(int) (UNIXSOCK_PATH_BUFLEN - 1))));\n\t\t\treturn STATUS_ERROR;\n\t\t}\n\t\tif (Lock_AF_UNIX(unixSocketDir, unixSocketPath) != STATUS_OK)\n\t\t\treturn STATUS_ERROR;\n\t\tservice = unixSocketPath;\n\t}\n\telse\n#endif\t\t\t\t\t\t\t/* HAVE_UNIX_SOCKETS */\n\t{\n\t\tsnprintf(portNumberStr, sizeof(portNumberStr), \"%d\", portNumber);\n\t\tservice = portNumberStr;\n\t}\n\n\tret = pg_getaddrinfo_all(hostName, service, &hint, &addrs);\n\tif (ret || !addrs)\n\t{\n\t\tif (hostName)\n\t\t\tereport(LOG,\n\t\t\t\t\t(errmsg(\"could not translate host name \\\"%s\\\", service \\\"%s\\\" to address: %s\",\n\t\t\t\t\t\t\thostName, service, gai_strerror(ret))));\n\t\telse\n\t\t\tereport(LOG,\n\t\t\t\t\t(errmsg(\"could not translate service \\\"%s\\\" to address: %s\",\n\t\t\t\t\t\t\tservice, gai_strerror(ret))));\n\t\tif (addrs)\n\t\t\tpg_freeaddrinfo_all(hint.ai_family, addrs);\n\t\treturn STATUS_ERROR;\n\t}\n\n\tfor (addr = addrs; addr; addr = addr->ai_next)\n\t{\n\t\tif (!IS_AF_UNIX(family) && IS_AF_UNIX(addr->ai_family))\n\t\t{\n\t\t\t/*\n\t\t\t * Only set up a unix domain socket when they really asked for it.\n\t\t\t * The service/port is different in that case.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* See if there is still room to add 1 more socket. */\n\t\tfor (; listen_index < MaxListen; listen_index++)\n\t\t{\n\t\t\tif (ListenSocket[listen_index] == PGINVALID_SOCKET)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (listen_index >= MaxListen)\n\t\t{\n\t\t\tereport(LOG,\n\t\t\t\t\t(errmsg(\"could not bind to all requested addresses: MAXLISTEN (%d) exceeded\",\n\t\t\t\t\t\t\tMaxListen)));\n\t\t\tbreak;\n\t\t}\n\n\t\t/* set up address family name for log messages */\n\t\tswitch (addr->ai_family)\n\t\t{\n\t\t\tcase AF_INET:\n\t\t\t\tfamilyDesc = _(\"IPv4\");\n\t\t\t\tbreak;\n#ifdef HAVE_IPV6\n\t\t\tcase AF_INET6:\n\t\t\t\tfamilyDesc = _(\"IPv6\");\n\t\t\t\tbreak;\n#endif\n#ifdef HAVE_UNIX_SOCKETS\n\t\t\tcase AF_UNIX:\n\t\t\t\tfamilyDesc = _(\"Unix\");\n\t\t\t\tbreak;\n#endif\n\t\t\tdefault:\n\t\t\t\tsnprintf(familyDescBuf, sizeof(familyDescBuf),\n\t\t\t\t\t\t _(\"unrecognized address family %d\"),\n\t\t\t\t\t\t addr->ai_family);\n\t\t\t\tfamilyDesc = familyDescBuf;\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* set up text form of address for log messages */\n#ifdef HAVE_UNIX_SOCKETS\n\t\tif (addr->ai_family == AF_UNIX)\n\t\t\taddrDesc = unixSocketPath;\n\t\telse\n#endif\n\t\t{\n\t\t\tpg_getnameinfo_all((const struct sockaddr_storage *) addr->ai_addr,\n\t\t\t\t\t\t\t   addr->ai_addrlen,\n\t\t\t\t\t\t\t   addrBuf, sizeof(addrBuf),\n\t\t\t\t\t\t\t   NULL, 0,\n\t\t\t\t\t\t\t   NI_NUMERICHOST);\n\t\t\taddrDesc = addrBuf;\n\t\t}\n\n\t\tif ((fd = socket(addr->ai_family, SOCK_STREAM, 0)) == PGINVALID_SOCKET)\n\t\t{\n\t\t\tereport(LOG,\n\t\t\t\t\t(errcode_for_socket_access(),\n\t\t\t/* translator: first %s is IPv4, IPv6, or Unix */\n\t\t\t\t\t errmsg(\"could not create %s socket for address \\\"%s\\\": %m\",\n\t\t\t\t\t\t\tfamilyDesc, addrDesc)));\n\t\t\tcontinue;\n\t\t}\n\n#ifndef WIN32\n\n\t\t/*\n\t\t * Without the SO_REUSEADDR flag, a new postmaster can't be started\n\t\t * right away after a stop or crash, giving \"address already in use\"\n\t\t * error on TCP ports.\n\t\t *\n\t\t * On win32, however, this behavior only happens if the\n\t\t * SO_EXCLUSIVEADDRUSE is set. With SO_REUSEADDR, win32 allows\n\t\t * multiple servers to listen on the same address, resulting in\n\t\t * unpredictable behavior. With no flags at all, win32 behaves as Unix\n\t\t * with SO_REUSEADDR.\n\t\t */\n\t\tif (!IS_AF_UNIX(addr->ai_family))\n\t\t{\n\t\t\tif ((setsockopt(fd, SOL_SOCKET, SO_REUSEADDR,\n\t\t\t\t\t\t\t(char *) &one, sizeof(one))) == -1)\n\t\t\t{\n\t\t\t\tereport(LOG,\n\t\t\t\t\t\t(errcode_for_socket_access(),\n\t\t\t\t/* translator: third %s is IPv4, IPv6, or Unix */\n\t\t\t\t\t\t errmsg(\"%s(%s) failed for %s address \\\"%s\\\": %m\",\n\t\t\t\t\t\t\t\t\"setsockopt\", \"SO_REUSEADDR\",\n\t\t\t\t\t\t\t\tfamilyDesc, addrDesc)));\n\t\t\t\tclosesocket(fd);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n#endif\n\n#ifdef IPV6_V6ONLY\n\t\tif (addr->ai_family == AF_INET6)\n\t\t{\n\t\t\tif (setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY,\n\t\t\t\t\t\t   (char *) &one, sizeof(one)) == -1)\n\t\t\t{\n\t\t\t\tereport(LOG,\n\t\t\t\t\t\t(errcode_for_socket_access(),\n\t\t\t\t/* translator: third %s is IPv4, IPv6, or Unix */\n\t\t\t\t\t\t errmsg(\"%s(%s) failed for %s address \\\"%s\\\": %m\",\n\t\t\t\t\t\t\t\t\"setsockopt\", \"IPV6_V6ONLY\",\n\t\t\t\t\t\t\t\tfamilyDesc, addrDesc)));\n\t\t\t\tclosesocket(fd);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n#endif\n\n\t\t/*\n\t\t * Note: This might fail on some OS's, like Linux older than\n\t\t * 2.4.21-pre3, that don't have the IPV6_V6ONLY socket option, and map\n\t\t * ipv4 addresses to ipv6.  It will show ::ffff:ipv4 for all ipv4\n\t\t * connections.\n\t\t */\n\t\terr = bind(fd, addr->ai_addr, addr->ai_addrlen);\n\t\tif (err < 0)\n\t\t{\n\t\t\tint\t\t\tsaved_errno = errno;\n\n\t\t\tereport(LOG,\n\t\t\t\t\t(errcode_for_socket_access(),\n\t\t\t/* translator: first %s is IPv4, IPv6, or Unix */\n\t\t\t\t\t errmsg(\"could not bind %s address \\\"%s\\\": %m\",\n\t\t\t\t\t\t\tfamilyDesc, addrDesc),\n\t\t\t\t\t saved_errno == EADDRINUSE ?\n\t\t\t\t\t (IS_AF_UNIX(addr->ai_family) ?\n\t\t\t\t\t  errhint(\"Is another postmaster already running on port %d?\",\n\t\t\t\t\t\t\t  (int) portNumber) :\n\t\t\t\t\t  errhint(\"Is another postmaster already running on port %d?\"\n\t\t\t\t\t\t\t  \" If not, wait a few seconds and retry.\",\n\t\t\t\t\t\t\t  (int) portNumber)) : 0));\n\t\t\tclosesocket(fd);\n\t\t\tcontinue;\n\t\t}\n\n#ifdef HAVE_UNIX_SOCKETS\n\t\tif (addr->ai_family == AF_UNIX)\n\t\t{\n\t\t\tif (Setup_AF_UNIX(service) != STATUS_OK)\n\t\t\t{\n\t\t\t\tclosesocket(fd);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n#endif\n\n\t\t/*\n\t\t * Select appropriate accept-queue length limit.  PG_SOMAXCONN is only\n\t\t * intended to provide a clamp on the request on platforms where an\n\t\t * overly large request provokes a kernel error (are there any?).\n\t\t */\n\t\tmaxconn = MaxBackends * 2;\n\t\tif (maxconn > PG_SOMAXCONN)\n\t\t\tmaxconn = PG_SOMAXCONN;\n\n\t\terr = listen(fd, maxconn);\n\t\tif (err < 0)\n\t\t{\n\t\t\tereport(LOG,\n\t\t\t\t\t(errcode_for_socket_access(),\n\t\t\t/* translator: first %s is IPv4, IPv6, or Unix */\n\t\t\t\t\t errmsg(\"could not listen on %s address \\\"%s\\\": %m\",\n\t\t\t\t\t\t\tfamilyDesc, addrDesc)));\n\t\t\tclosesocket(fd);\n\t\t\tcontinue;\n\t\t}\n\n#ifdef HAVE_UNIX_SOCKETS\n\t\tif (addr->ai_family == AF_UNIX)\n\t\t\tereport(LOG,\n\t\t\t\t\t(errmsg(\"listening on Unix socket \\\"%s\\\"\",\n\t\t\t\t\t\t\taddrDesc)));\n\t\telse\n#endif\n\t\t\tereport(LOG,\n\t\t\t/* translator: first %s is IPv4 or IPv6 */\n\t\t\t\t\t(errmsg(\"listening on %s address \\\"%s\\\", port %d\",\n\t\t\t\t\t\t\tfamilyDesc, addrDesc, (int) portNumber)));\n\n\t\tListenSocket[listen_index] = fd;\n\t\tadded++;\n\t}\n\n\tpg_freeaddrinfo_all(hint.ai_family, addrs);\n\n\tif (!added)\n\t\treturn STATUS_ERROR;\n\n\treturn STATUS_OK;\n}\n\n\n#ifdef HAVE_UNIX_SOCKETS\n\n/*\n * Lock_AF_UNIX -- configure unix socket file path\n */\nstatic int\nLock_AF_UNIX(const char *unixSocketDir, const char *unixSocketPath)\n{\n\t/* no lock file for abstract sockets */\n\tif (unixSocketPath[0] == '@')\n\t\treturn STATUS_OK;\n\n\t/*\n\t * Grab an interlock file associated with the socket file.\n\t *\n\t * Note: there are two reasons for using a socket lock file, rather than\n\t * trying to interlock directly on the socket itself.  First, it's a lot\n\t * more portable, and second, it lets us remove any pre-existing socket\n\t * file without race conditions.\n\t */\n\tCreateSocketLockFile(unixSocketPath, true, unixSocketDir);\n\n\t/*\n\t * Once we have the interlock, we can safely delete any pre-existing\n\t * socket file to avoid failure at bind() time.\n\t */\n\t(void) unlink(unixSocketPath);\n\n\t/*\n\t * Remember socket file pathnames for later maintenance.\n\t */\n\tsock_paths = lappend(sock_paths, pstrdup(unixSocketPath));\n\n\treturn STATUS_OK;\n}\n\n\n/*\n * Setup_AF_UNIX -- configure unix socket permissions\n */\nstatic int\nSetup_AF_UNIX(const char *sock_path)\n{\n\t/* no file system permissions for abstract sockets */\n\tif (sock_path[0] == '@')\n\t\treturn STATUS_OK;\n\n\t/*\n\t * Fix socket ownership/permission if requested.  Note we must do this\n\t * before we listen() to avoid a window where unwanted connections could\n\t * get accepted.\n\t */\n\tAssert(Unix_socket_group);\n\tif (Unix_socket_group[0] != '\\0')\n\t{\n#ifdef WIN32\n\t\telog(WARNING, \"configuration item unix_socket_group is not supported on this platform\");\n#else\n\t\tchar\t   *endptr;\n\t\tunsigned long val;\n\t\tgid_t\t\tgid;\n\n\t\tval = strtoul(Unix_socket_group, &endptr, 10);\n\t\tif (*endptr == '\\0')\n\t\t{\t\t\t\t\t\t/* numeric group id */\n\t\t\tgid = val;\n\t\t}\n\t\telse\n\t\t{\t\t\t\t\t\t/* convert group name to id */\n\t\t\tstruct group *gr;\n\n\t\t\tgr = getgrnam(Unix_socket_group);\n\t\t\tif (!gr)\n\t\t\t{\n\t\t\t\tereport(LOG,\n\t\t\t\t\t\t(errmsg(\"group \\\"%s\\\" does not exist\",\n\t\t\t\t\t\t\t\tUnix_socket_group)));\n\t\t\t\treturn STATUS_ERROR;\n\t\t\t}\n\t\t\tgid = gr->gr_gid;\n\t\t}\n\t\tif (chown(sock_path, -1, gid) == -1)\n\t\t{\n\t\t\tereport(LOG,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not set group of file \\\"%s\\\": %m\",\n\t\t\t\t\t\t\tsock_path)));\n\t\t\treturn STATUS_ERROR;\n\t\t}\n#endif\n\t}\n\n\tif (chmod(sock_path, Unix_socket_permissions) == -1)\n\t{\n\t\tereport(LOG,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not set permissions of file \\\"%s\\\": %m\",\n\t\t\t\t\t\tsock_path)));\n\t\treturn STATUS_ERROR;\n\t}\n\treturn STATUS_OK;\n}\n#endif\t\t\t\t\t\t\t/* HAVE_UNIX_SOCKETS */\n\n\n/*\n * StreamConnection -- create a new connection with client using\n *\t\tserver port.  Set port->sock to the FD of the new connection.\n *\n * ASSUME: that this doesn't need to be non-blocking because\n *\t\tthe Postmaster uses select() to tell when the socket is ready for\n *\t\taccept().\n *\n * RETURNS: STATUS_OK or STATUS_ERROR\n */\nint\nStreamConnection(pgsocket server_fd, Port *port)\n{\n\t/* accept connection and fill in the client (remote) address */\n\tport->raddr.salen = sizeof(port->raddr.addr);\n\tif ((port->sock = accept(server_fd,\n\t\t\t\t\t\t\t (struct sockaddr *) &port->raddr.addr,\n\t\t\t\t\t\t\t &port->raddr.salen)) == PGINVALID_SOCKET)\n\t{\n\t\tereport(LOG,\n\t\t\t\t(errcode_for_socket_access(),\n\t\t\t\t errmsg(\"could not accept new connection: %m\")));\n\n\t\t/*\n\t\t * If accept() fails then postmaster.c will still see the server\n\t\t * socket as read-ready, and will immediately try again.  To avoid\n\t\t * uselessly sucking lots of CPU, delay a bit before trying again.\n\t\t * (The most likely reason for failure is being out of kernel file\n\t\t * table slots; we can do little except hope some will get freed up.)\n\t\t */\n\t\tpg_usleep(100000L);\t\t/* wait 0.1 sec */\n\t\treturn STATUS_ERROR;\n\t}\n\n\t/* fill in the server (local) address */\n\tport->laddr.salen = sizeof(port->laddr.addr);\n\tif (getsockname(port->sock,\n\t\t\t\t\t(struct sockaddr *) &port->laddr.addr,\n\t\t\t\t\t&port->laddr.salen) < 0)\n\t{\n\t\tereport(LOG,\n\t\t\t\t(errmsg(\"%s() failed: %m\", \"getsockname\")));\n\t\treturn STATUS_ERROR;\n\t}\n\n\t/* select NODELAY and KEEPALIVE options if it's a TCP connection */\n\tif (!IS_AF_UNIX(port->laddr.addr.ss_family))\n\t{\n\t\tint\t\t\ton;\n#ifdef WIN32\n\t\tint\t\t\toldopt;\n\t\tint\t\t\toptlen;\n\t\tint\t\t\tnewopt;\n#endif\n\n#ifdef\tTCP_NODELAY\n\t\ton = 1;\n\t\tif (setsockopt(port->sock, IPPROTO_TCP, TCP_NODELAY,\n\t\t\t\t\t   (char *) &on, sizeof(on)) < 0)\n\t\t{\n\t\t\tereport(LOG,\n\t\t\t\t\t(errmsg(\"%s(%s) failed: %m\", \"setsockopt\", \"TCP_NODELAY\")));\n\t\t\treturn STATUS_ERROR;\n\t\t}\n#endif\n\t\ton = 1;\n\t\tif (setsockopt(port->sock, SOL_SOCKET, SO_KEEPALIVE,\n\t\t\t\t\t   (char *) &on, sizeof(on)) < 0)\n\t\t{\n\t\t\tereport(LOG,\n\t\t\t\t\t(errmsg(\"%s(%s) failed: %m\", \"setsockopt\", \"SO_KEEPALIVE\")));\n\t\t\treturn STATUS_ERROR;\n\t\t}\n\n#ifdef WIN32\n\n\t\t/*\n\t\t * This is a Win32 socket optimization.  The OS send buffer should be\n\t\t * large enough to send the whole Postgres send buffer in one go, or\n\t\t * performance suffers.  The Postgres send buffer can be enlarged if a\n\t\t * very large message needs to be sent, but we won't attempt to\n\t\t * enlarge the OS buffer if that happens, so somewhat arbitrarily\n\t\t * ensure that the OS buffer is at least PQ_SEND_BUFFER_SIZE * 4.\n\t\t * (That's 32kB with the current default).\n\t\t *\n\t\t * The default OS buffer size used to be 8kB in earlier Windows\n\t\t * versions, but was raised to 64kB in Windows 2012.  So it shouldn't\n\t\t * be necessary to change it in later versions anymore.  Changing it\n\t\t * unnecessarily can even reduce performance, because setting\n\t\t * SO_SNDBUF in the application disables the \"dynamic send buffering\"\n\t\t * feature that was introduced in Windows 7.  So before fiddling with\n\t\t * SO_SNDBUF, check if the current buffer size is already large enough\n\t\t * and only increase it if necessary.\n\t\t *\n\t\t * See https://support.microsoft.com/kb/823764/EN-US/ and\n\t\t * https://msdn.microsoft.com/en-us/library/bb736549%28v=vs.85%29.aspx\n\t\t */\n\t\toptlen = sizeof(oldopt);\n\t\tif (getsockopt(port->sock, SOL_SOCKET, SO_SNDBUF, (char *) &oldopt,\n\t\t\t\t\t   &optlen) < 0)\n\t\t{\n\t\t\tereport(LOG,\n\t\t\t\t\t(errmsg(\"%s(%s) failed: %m\", \"getsockopt\", \"SO_SNDBUF\")));\n\t\t\treturn STATUS_ERROR;\n\t\t}\n\t\tnewopt = PQ_SEND_BUFFER_SIZE * 4;\n\t\tif (oldopt < newopt)\n\t\t{\n\t\t\tif (setsockopt(port->sock, SOL_SOCKET, SO_SNDBUF, (char *) &newopt,\n\t\t\t\t\t\t   sizeof(newopt)) < 0)\n\t\t\t{\n\t\t\t\tereport(LOG,\n\t\t\t\t\t\t(errmsg(\"%s(%s) failed: %m\", \"setsockopt\", \"SO_SNDBUF\")));\n\t\t\t\treturn STATUS_ERROR;\n\t\t\t}\n\t\t}\n#endif\n\n\t\t/*\n\t\t * Also apply the current keepalive parameters.  If we fail to set a\n\t\t * parameter, don't error out, because these aren't universally\n\t\t * supported.  (Note: you might think we need to reset the GUC\n\t\t * variables to 0 in such a case, but it's not necessary because the\n\t\t * show hooks for these variables report the truth anyway.)\n\t\t */\n\t\t(void) pq_setkeepalivesidle(tcp_keepalives_idle, port);\n\t\t(void) pq_setkeepalivesinterval(tcp_keepalives_interval, port);\n\t\t(void) pq_setkeepalivescount(tcp_keepalives_count, port);\n\t\t(void) pq_settcpusertimeout(tcp_user_timeout, port);\n\t}\n\n\treturn STATUS_OK;\n}\n\n/*\n * StreamClose -- close a client/backend connection\n *\n * NOTE: this is NOT used to terminate a session; it is just used to release\n * the file descriptor in a process that should no longer have the socket\n * open.  (For example, the postmaster calls this after passing ownership\n * of the connection to a child process.)  It is expected that someone else\n * still has the socket open.  So, we only want to close the descriptor,\n * we do NOT want to send anything to the far end.\n */\nvoid\nStreamClose(pgsocket sock)\n{\n\tclosesocket(sock);\n}\n\n/*\n * TouchSocketFiles -- mark socket files as recently accessed\n *\n * This routine should be called every so often to ensure that the socket\n * files have a recent mod date (ordinary operations on sockets usually won't\n * change the mod date).  That saves them from being removed by\n * overenthusiastic /tmp-directory-cleaner daemons.  (Another reason we should\n * never have put the socket file in /tmp...)\n */\nvoid\nTouchSocketFiles(void)\n{\n\tListCell   *l;\n\n\t/* Loop through all created sockets... */\n\tforeach(l, sock_paths)\n\t{\n\t\tchar\t   *sock_path = (char *) lfirst(l);\n\n\t\t/* Ignore errors; there's no point in complaining */\n\t\t(void) utime(sock_path, NULL);\n\t}\n}\n\n/*\n * RemoveSocketFiles -- unlink socket files at postmaster shutdown\n */\nvoid\nRemoveSocketFiles(void)\n{\n\tListCell   *l;\n\n\t/* Loop through all created sockets... */\n\tforeach(l, sock_paths)\n\t{\n\t\tchar\t   *sock_path = (char *) lfirst(l);\n\n\t\t/* Ignore any error. */\n\t\t(void) unlink(sock_path);\n\t}\n\t/* Since we're about to exit, no need to reclaim storage */\n\tsock_paths = NIL;\n}\n\n\n/* --------------------------------\n * Low-level I/O routines begin here.\n *\n * These routines communicate with a frontend client across a connection\n * already established by the preceding routines.\n * --------------------------------\n */\n\n/* --------------------------------\n *\t\t\t  socket_set_nonblocking - set socket blocking/non-blocking\n *\n * Sets the socket non-blocking if nonblocking is true, or sets it\n * blocking otherwise.\n * --------------------------------\n */\nstatic void\nsocket_set_nonblocking(bool nonblocking)\n{\n\tif (MyProcPort == NULL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_CONNECTION_DOES_NOT_EXIST),\n\t\t\t\t errmsg(\"there is no client connection\")));\n\n\tMyProcPort->noblock = nonblocking;\n}\n\n/* --------------------------------\n *\t\tpq_recvbuf - load some bytes into the input buffer\n *\n *\t\treturns 0 if OK, EOF if trouble\n * --------------------------------\n */\nstatic int\npq_recvbuf(void)\n{\n\tif (PqRecvPointer > 0)\n\t{\n\t\tif (PqRecvLength > PqRecvPointer)\n\t\t{\n\t\t\t/* still some unread data, left-justify it in the buffer */\n\t\t\tmemmove(PqRecvBuffer, PqRecvBuffer + PqRecvPointer,\n\t\t\t\t\tPqRecvLength - PqRecvPointer);\n\t\t\tPqRecvLength -= PqRecvPointer;\n\t\t\tPqRecvPointer = 0;\n\t\t}\n\t\telse\n\t\t\tPqRecvLength = PqRecvPointer = 0;\n\t}\n\n\t/* Ensure that we're in blocking mode */\n\tsocket_set_nonblocking(false);\n\n\t/* Can fill buffer from PqRecvLength and upwards */\n\tfor (;;)\n\t{\n\t\tint\t\t\tr;\n\n\t\tr = secure_read(MyProcPort, PqRecvBuffer + PqRecvLength,\n\t\t\t\t\t\tPQ_RECV_BUFFER_SIZE - PqRecvLength);\n\n\t\tif (r < 0)\n\t\t{\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\t\t/* Ok if interrupted */\n\n\t\t\t/*\n\t\t\t * Careful: an ereport() that tries to write to the client would\n\t\t\t * cause recursion to here, leading to stack overflow and core\n\t\t\t * dump!  This message must go *only* to the postmaster log.\n\t\t\t */\n\t\t\tereport(COMMERROR,\n\t\t\t\t\t(errcode_for_socket_access(),\n\t\t\t\t\t errmsg(\"could not receive data from client: %m\")));\n\t\t\treturn EOF;\n\t\t}\n\t\tif (r == 0)\n\t\t{\n\t\t\t/*\n\t\t\t * EOF detected.  We used to write a log message here, but it's\n\t\t\t * better to expect the ultimate caller to do that.\n\t\t\t */\n\t\t\treturn EOF;\n\t\t}\n\t\t/* r contains number of bytes read, so just incr length */\n\t\tPqRecvLength += r;\n\t\treturn 0;\n\t}\n}\n\n/* --------------------------------\n *\t\tpq_getbyte\t- get a single byte from connection, or return EOF\n * --------------------------------\n */\nint\npq_getbyte(void)\n{\n\tAssert(PqCommReadingMsg);\n\n\twhile (PqRecvPointer >= PqRecvLength)\n\t{\n\t\tif (pq_recvbuf())\t\t/* If nothing in buffer, then recv some */\n\t\t\treturn EOF;\t\t\t/* Failed to recv data */\n\t}\n\treturn (unsigned char) PqRecvBuffer[PqRecvPointer++];\n}\n\n/* --------------------------------\n *\t\tpq_peekbyte\t\t- peek at next byte from connection\n *\n *\t Same as pq_getbyte() except we don't advance the pointer.\n * --------------------------------\n */\nint\npq_peekbyte(void)\n{\n\tAssert(PqCommReadingMsg);\n\n\twhile (PqRecvPointer >= PqRecvLength)\n\t{\n\t\tif (pq_recvbuf())\t\t/* If nothing in buffer, then recv some */\n\t\t\treturn EOF;\t\t\t/* Failed to recv data */\n\t}\n\treturn (unsigned char) PqRecvBuffer[PqRecvPointer];\n}\n\n/* --------------------------------\n *\t\tpq_getbyte_if_available - get a single byte from connection,\n *\t\t\tif available\n *\n * The received byte is stored in *c. Returns 1 if a byte was read,\n * 0 if no data was available, or EOF if trouble.\n * --------------------------------\n */\nint\npq_getbyte_if_available(unsigned char *c)\n{\n\tint\t\t\tr;\n\n\tAssert(PqCommReadingMsg);\n\n\tif (PqRecvPointer < PqRecvLength)\n\t{\n\t\t*c = PqRecvBuffer[PqRecvPointer++];\n\t\treturn 1;\n\t}\n\n\t/* Put the socket into non-blocking mode */\n\tsocket_set_nonblocking(true);\n\n\tr = secure_read(MyProcPort, c, 1);\n\tif (r < 0)\n\t{\n\t\t/*\n\t\t * Ok if no data available without blocking or interrupted (though\n\t\t * EINTR really shouldn't happen with a non-blocking socket). Report\n\t\t * other errors.\n\t\t */\n\t\tif (errno == EAGAIN || errno == EWOULDBLOCK || errno == EINTR)\n\t\t\tr = 0;\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Careful: an ereport() that tries to write to the client would\n\t\t\t * cause recursion to here, leading to stack overflow and core\n\t\t\t * dump!  This message must go *only* to the postmaster log.\n\t\t\t */\n\t\t\tereport(COMMERROR,\n\t\t\t\t\t(errcode_for_socket_access(),\n\t\t\t\t\t errmsg(\"could not receive data from client: %m\")));\n\t\t\tr = EOF;\n\t\t}\n\t}\n\telse if (r == 0)\n\t{\n\t\t/* EOF detected */\n\t\tr = EOF;\n\t}\n\n\treturn r;\n}\n\n/* --------------------------------\n *\t\tpq_getbytes\t\t- get a known number of bytes from connection\n *\n *\t\treturns 0 if OK, EOF if trouble\n * --------------------------------\n */\nint\npq_getbytes(char *s, size_t len)\n{\n\tsize_t\t\tamount;\n\n\tAssert(PqCommReadingMsg);\n\n\twhile (len > 0)\n\t{\n\t\twhile (PqRecvPointer >= PqRecvLength)\n\t\t{\n\t\t\tif (pq_recvbuf())\t/* If nothing in buffer, then recv some */\n\t\t\t\treturn EOF;\t\t/* Failed to recv data */\n\t\t}\n\t\tamount = PqRecvLength - PqRecvPointer;\n\t\tif (amount > len)\n\t\t\tamount = len;\n\t\tmemcpy(s, PqRecvBuffer + PqRecvPointer, amount);\n\t\tPqRecvPointer += amount;\n\t\ts += amount;\n\t\tlen -= amount;\n\t}\n\treturn 0;\n}\n\n/* --------------------------------\n *\t\tpq_discardbytes\t\t- throw away a known number of bytes\n *\n *\t\tsame as pq_getbytes except we do not copy the data to anyplace.\n *\t\tthis is used for resynchronizing after read errors.\n *\n *\t\treturns 0 if OK, EOF if trouble\n * --------------------------------\n */\nstatic int\npq_discardbytes(size_t len)\n{\n\tsize_t\t\tamount;\n\n\tAssert(PqCommReadingMsg);\n\n\twhile (len > 0)\n\t{\n\t\twhile (PqRecvPointer >= PqRecvLength)\n\t\t{\n\t\t\tif (pq_recvbuf())\t/* If nothing in buffer, then recv some */\n\t\t\t\treturn EOF;\t\t/* Failed to recv data */\n\t\t}\n\t\tamount = PqRecvLength - PqRecvPointer;\n\t\tif (amount > len)\n\t\t\tamount = len;\n\t\tPqRecvPointer += amount;\n\t\tlen -= amount;\n\t}\n\treturn 0;\n}\n\n/* --------------------------------\n *\t\tpq_buffer_has_data\t\t- is any buffered data available to read?\n *\n * This will *not* attempt to read more data.\n * --------------------------------\n */\nbool\npq_buffer_has_data(void)\n{\n\treturn (PqRecvPointer < PqRecvLength);\n}\n\n\n/* --------------------------------\n *\t\tpq_startmsgread - begin reading a message from the client.\n *\n *\t\tThis must be called before any of the pq_get* functions.\n * --------------------------------\n */\nvoid\npq_startmsgread(void)\n{\n\t/*\n\t * There shouldn't be a read active already, but let's check just to be\n\t * sure.\n\t */\n\tif (PqCommReadingMsg)\n\t\tereport(FATAL,\n\t\t\t\t(errcode(ERRCODE_PROTOCOL_VIOLATION),\n\t\t\t\t errmsg(\"terminating connection because protocol synchronization was lost\")));\n\n\tPqCommReadingMsg = true;\n}\n\n\n/* --------------------------------\n *\t\tpq_endmsgread\t- finish reading message.\n *\n *\t\tThis must be called after reading a message with pq_getbytes()\n *\t\tand friends, to indicate that we have read the whole message.\n *\t\tpq_getmessage() does this implicitly.\n * --------------------------------\n */\nvoid\npq_endmsgread(void)\n{\n\tAssert(PqCommReadingMsg);\n\n\tPqCommReadingMsg = false;\n}\n\n/* --------------------------------\n *\t\tpq_is_reading_msg - are we currently reading a message?\n *\n * This is used in error recovery at the outer idle loop to detect if we have\n * lost protocol sync, and need to terminate the connection. pq_startmsgread()\n * will check for that too, but it's nicer to detect it earlier.\n * --------------------------------\n */\nbool\npq_is_reading_msg(void)\n{\n\treturn PqCommReadingMsg;\n}\n\n/* --------------------------------\n *\t\tpq_getmessage\t- get a message with length word from connection\n *\n *\t\tThe return value is placed in an expansible StringInfo, which has\n *\t\talready been initialized by the caller.\n *\t\tOnly the message body is placed in the StringInfo; the length word\n *\t\tis removed.  Also, s->cursor is initialized to zero for convenience\n *\t\tin scanning the message contents.\n *\n *\t\tmaxlen is the upper limit on the length of the\n *\t\tmessage we are willing to accept.  We abort the connection (by\n *\t\treturning EOF) if client tries to send more than that.\n *\n *\t\treturns 0 if OK, EOF if trouble\n * --------------------------------\n */\nint\npq_getmessage(StringInfo s, int maxlen)\n{\n\tint32\t\tlen;\n\n\tAssert(PqCommReadingMsg);\n\n\tresetStringInfo(s);\n\n\t/* Read message length word */\n\tif (pq_getbytes((char *) &len, 4) == EOF)\n\t{\n\t\tereport(COMMERROR,\n\t\t\t\t(errcode(ERRCODE_PROTOCOL_VIOLATION),\n\t\t\t\t errmsg(\"unexpected EOF within message length word\")));\n\t\treturn EOF;\n\t}\n\n\tlen = pg_ntoh32(len);\n\n\tif (len < 4 || len > maxlen)\n\t{\n\t\tereport(COMMERROR,\n\t\t\t\t(errcode(ERRCODE_PROTOCOL_VIOLATION),\n\t\t\t\t errmsg(\"invalid message length\")));\n\t\treturn EOF;\n\t}\n\n\tlen -= 4;\t\t\t\t\t/* discount length itself */\n\n\tif (len > 0)\n\t{\n\t\t/*\n\t\t * Allocate space for message.  If we run out of room (ridiculously\n\t\t * large message), we will elog(ERROR), but we want to discard the\n\t\t * message body so as not to lose communication sync.\n\t\t */\n\t\tPG_TRY();\n\t\t{\n\t\t\tenlargeStringInfo(s, len);\n\t\t}\n\t\tPG_CATCH();\n\t\t{\n\t\t\tif (pq_discardbytes(len) == EOF)\n\t\t\t\tereport(COMMERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_PROTOCOL_VIOLATION),\n\t\t\t\t\t\t errmsg(\"incomplete message from client\")));\n\n\t\t\t/* we discarded the rest of the message so we're back in sync. */\n\t\t\tPqCommReadingMsg = false;\n\t\t\tPG_RE_THROW();\n\t\t}\n\t\tPG_END_TRY();\n\n\t\t/* And grab the message */\n\t\tif (pq_getbytes(s->data, len) == EOF)\n\t\t{\n\t\t\tereport(COMMERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROTOCOL_VIOLATION),\n\t\t\t\t\t errmsg(\"incomplete message from client\")));\n\t\t\treturn EOF;\n\t\t}\n\t\ts->len = len;\n\t\t/* Place a trailing null per StringInfo convention */\n\t\ts->data[len] = '\\0';\n\t}\n\n\t/* finished reading the message. */\n\tPqCommReadingMsg = false;\n\n\treturn 0;\n}\n\n\nstatic int\ninternal_putbytes(const char *s, size_t len)\n{\n\tsize_t\t\tamount;\n\n\twhile (len > 0)\n\t{\n\t\t/* If buffer is full, then flush it out */\n\t\tif (PqSendPointer >= PqSendBufferSize)\n\t\t{\n\t\t\tsocket_set_nonblocking(false);\n\t\t\tif (internal_flush())\n\t\t\t\treturn EOF;\n\t\t}\n\t\tamount = PqSendBufferSize - PqSendPointer;\n\t\tif (amount > len)\n\t\t\tamount = len;\n\t\tmemcpy(PqSendBuffer + PqSendPointer, s, amount);\n\t\tPqSendPointer += amount;\n\t\ts += amount;\n\t\tlen -= amount;\n\t}\n\treturn 0;\n}\n\n/* --------------------------------\n *\t\tsocket_flush\t\t- flush pending output\n *\n *\t\treturns 0 if OK, EOF if trouble\n * --------------------------------\n */\nstatic int\nsocket_flush(void)\n{\n\tint\t\t\tres;\n\n\t/* No-op if reentrant call */\n\tif (PqCommBusy)\n\t\treturn 0;\n\tPqCommBusy = true;\n\tsocket_set_nonblocking(false);\n\tres = internal_flush();\n\tPqCommBusy = false;\n\treturn res;\n}\n\n/* --------------------------------\n *\t\tinternal_flush - flush pending output\n *\n * Returns 0 if OK (meaning everything was sent, or operation would block\n * and the socket is in non-blocking mode), or EOF if trouble.\n * --------------------------------\n */\nstatic int\ninternal_flush(void)\n{\n\tstatic int\tlast_reported_send_errno = 0;\n\n\tchar\t   *bufptr = PqSendBuffer + PqSendStart;\n\tchar\t   *bufend = PqSendBuffer + PqSendPointer;\n\n\twhile (bufptr < bufend)\n\t{\n\t\tint\t\t\tr;\n\n\t\tr = secure_write(MyProcPort, bufptr, bufend - bufptr);\n\n\t\tif (r <= 0)\n\t\t{\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\t\t/* Ok if we were interrupted */\n\n\t\t\t/*\n\t\t\t * Ok if no data writable without blocking, and the socket is in\n\t\t\t * non-blocking mode.\n\t\t\t */\n\t\t\tif (errno == EAGAIN ||\n\t\t\t\terrno == EWOULDBLOCK)\n\t\t\t{\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Careful: an ereport() that tries to write to the client would\n\t\t\t * cause recursion to here, leading to stack overflow and core\n\t\t\t * dump!  This message must go *only* to the postmaster log.\n\t\t\t *\n\t\t\t * If a client disconnects while we're in the midst of output, we\n\t\t\t * might write quite a bit of data before we get to a safe query\n\t\t\t * abort point.  So, suppress duplicate log messages.\n\t\t\t */\n\t\t\tif (errno != last_reported_send_errno)\n\t\t\t{\n\t\t\t\tlast_reported_send_errno = errno;\n\t\t\t\tereport(COMMERROR,\n\t\t\t\t\t\t(errcode_for_socket_access(),\n\t\t\t\t\t\t errmsg(\"could not send data to client: %m\")));\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We drop the buffered data anyway so that processing can\n\t\t\t * continue, even though we'll probably quit soon. We also set a\n\t\t\t * flag that'll cause the next CHECK_FOR_INTERRUPTS to terminate\n\t\t\t * the connection.\n\t\t\t */\n\t\t\tPqSendStart = PqSendPointer = 0;\n\t\t\tClientConnectionLost = 1;\n\t\t\tInterruptPending = 1;\n\t\t\treturn EOF;\n\t\t}\n\n\t\tlast_reported_send_errno = 0;\t/* reset after any successful send */\n\t\tbufptr += r;\n\t\tPqSendStart += r;\n\t}\n\n\tPqSendStart = PqSendPointer = 0;\n\treturn 0;\n}\n\n/* --------------------------------\n *\t\tpq_flush_if_writable - flush pending output if writable without blocking\n *\n * Returns 0 if OK, or EOF if trouble.\n * --------------------------------\n */\nstatic int\nsocket_flush_if_writable(void)\n{\n\tint\t\t\tres;\n\n\t/* Quick exit if nothing to do */\n\tif (PqSendPointer == PqSendStart)\n\t\treturn 0;\n\n\t/* No-op if reentrant call */\n\tif (PqCommBusy)\n\t\treturn 0;\n\n\t/* Temporarily put the socket into non-blocking mode */\n\tsocket_set_nonblocking(true);\n\n\tPqCommBusy = true;\n\tres = internal_flush();\n\tPqCommBusy = false;\n\treturn res;\n}\n\n/* --------------------------------\n *\tsocket_is_send_pending\t- is there any pending data in the output buffer?\n * --------------------------------\n */\nstatic bool\nsocket_is_send_pending(void)\n{\n\treturn (PqSendStart < PqSendPointer);\n}\n\n/* --------------------------------\n * Message-level I/O routines begin here.\n * --------------------------------\n */\n\n\n/* --------------------------------\n *\t\tsocket_putmessage - send a normal message (suppressed in COPY OUT mode)\n *\n *\t\tmsgtype is a message type code to place before the message body.\n *\n *\t\tlen is the length of the message body data at *s.  A message length\n *\t\tword (equal to len+4 because it counts itself too) is inserted by this\n *\t\troutine.\n *\n *\t\tWe suppress messages generated while pqcomm.c is busy.  This\n *\t\tavoids any possibility of messages being inserted within other\n *\t\tmessages.  The only known trouble case arises if SIGQUIT occurs\n *\t\tduring a pqcomm.c routine --- quickdie() will try to send a warning\n *\t\tmessage, and the most reasonable approach seems to be to drop it.\n *\n *\t\treturns 0 if OK, EOF if trouble\n * --------------------------------\n */\nstatic int\nsocket_putmessage(char msgtype, const char *s, size_t len)\n{\n\tuint32\t\tn32;\n\n\tAssert(msgtype != 0);\n\n\tif (PqCommBusy)\n\t\treturn 0;\n\tPqCommBusy = true;\n\tif (internal_putbytes(&msgtype, 1))\n\t\tgoto fail;\n\n\tn32 = pg_hton32((uint32) (len + 4));\n\tif (internal_putbytes((char *) &n32, 4))\n\t\tgoto fail;\n\n\tif (internal_putbytes(s, len))\n\t\tgoto fail;\n\tPqCommBusy = false;\n\treturn 0;\n\nfail:\n\tPqCommBusy = false;\n\treturn EOF;\n}\n\n/* --------------------------------\n *\t\tpq_putmessage_noblock\t- like pq_putmessage, but never blocks\n *\n *\t\tIf the output buffer is too small to hold the message, the buffer\n *\t\tis enlarged.\n */\nstatic void\nsocket_putmessage_noblock(char msgtype, const char *s, size_t len)\n{\n\tint\t\t\tres PG_USED_FOR_ASSERTS_ONLY;\n\tint\t\t\trequired;\n\n\t/*\n\t * Ensure we have enough space in the output buffer for the message header\n\t * as well as the message itself.\n\t */\n\trequired = PqSendPointer + 1 + 4 + len;\n\tif (required > PqSendBufferSize)\n\t{\n\t\tPqSendBuffer = repalloc(PqSendBuffer, required);\n\t\tPqSendBufferSize = required;\n\t}\n\tres = pq_putmessage(msgtype, s, len);\n\tAssert(res == 0);\t\t\t/* should not fail when the message fits in\n\t\t\t\t\t\t\t\t * buffer */\n}\n\n/* --------------------------------\n *\t\tpq_putmessage_v2 - send a message in protocol version 2\n *\n *\t\tmsgtype is a message type code to place before the message body.\n *\n *\t\tWe no longer support protocol version 2, but we have kept this\n *\t\tfunction so that if a client tries to connect with protocol version 2,\n *\t\tas a courtesy we can still send the \"unsupported protocol version\"\n *\t\terror to the client in the old format.\n *\n *\t\tLike in pq_putmessage(), we suppress messages generated while\n *\t\tpqcomm.c is busy.\n *\n *\t\treturns 0 if OK, EOF if trouble\n * --------------------------------\n */\nint\npq_putmessage_v2(char msgtype, const char *s, size_t len)\n{\n\tAssert(msgtype != 0);\n\n\tif (PqCommBusy)\n\t\treturn 0;\n\tPqCommBusy = true;\n\tif (internal_putbytes(&msgtype, 1))\n\t\tgoto fail;\n\n\tif (internal_putbytes(s, len))\n\t\tgoto fail;\n\tPqCommBusy = false;\n\treturn 0;\n\nfail:\n\tPqCommBusy = false;\n\treturn EOF;\n}\n\n/*\n * Support for TCP Keepalive parameters\n */\n\n/*\n * On Windows, we need to set both idle and interval at the same time.\n * We also cannot reset them to the default (setting to zero will\n * actually set them to zero, not default), therefore we fallback to\n * the out-of-the-box default instead.\n */\n#if defined(WIN32) && defined(SIO_KEEPALIVE_VALS)\nstatic int\npq_setkeepaliveswin32(Port *port, int idle, int interval)\n{\n\tstruct tcp_keepalive ka;\n\tDWORD\t\tretsize;\n\n\tif (idle <= 0)\n\t\tidle = 2 * 60 * 60;\t\t/* default = 2 hours */\n\tif (interval <= 0)\n\t\tinterval = 1;\t\t\t/* default = 1 second */\n\n\tka.onoff = 1;\n\tka.keepalivetime = idle * 1000;\n\tka.keepaliveinterval = interval * 1000;\n\n\tif (WSAIoctl(port->sock,\n\t\t\t\t SIO_KEEPALIVE_VALS,\n\t\t\t\t (LPVOID) &ka,\n\t\t\t\t sizeof(ka),\n\t\t\t\t NULL,\n\t\t\t\t 0,\n\t\t\t\t &retsize,\n\t\t\t\t NULL,\n\t\t\t\t NULL)\n\t\t!= 0)\n\t{\n\t\tereport(LOG,\n\t\t\t\t(errmsg(\"%s(%s) failed: error code %d\",\n\t\t\t\t\t\t\"WSAIoctl\", \"SIO_KEEPALIVE_VALS\", WSAGetLastError())));\n\t\treturn STATUS_ERROR;\n\t}\n\tif (port->keepalives_idle != idle)\n\t\tport->keepalives_idle = idle;\n\tif (port->keepalives_interval != interval)\n\t\tport->keepalives_interval = interval;\n\treturn STATUS_OK;\n}\n#endif\n\nint\npq_getkeepalivesidle(Port *port)\n{\n#if defined(PG_TCP_KEEPALIVE_IDLE) || defined(SIO_KEEPALIVE_VALS)\n\tif (port == NULL || IS_AF_UNIX(port->laddr.addr.ss_family))\n\t\treturn 0;\n\n\tif (port->keepalives_idle != 0)\n\t\treturn port->keepalives_idle;\n\n\tif (port->default_keepalives_idle == 0)\n\t{\n#ifndef WIN32\n\t\tACCEPT_TYPE_ARG3 size = sizeof(port->default_keepalives_idle);\n\n\t\tif (getsockopt(port->sock, IPPROTO_TCP, PG_TCP_KEEPALIVE_IDLE,\n\t\t\t\t\t   (char *) &port->default_keepalives_idle,\n\t\t\t\t\t   &size) < 0)\n\t\t{\n\t\t\tereport(LOG,\n\t\t\t\t\t(errmsg(\"%s(%s) failed: %m\", \"getsockopt\", PG_TCP_KEEPALIVE_IDLE_STR)));\n\t\t\tport->default_keepalives_idle = -1; /* don't know */\n\t\t}\n#else\t\t\t\t\t\t\t/* WIN32 */\n\t\t/* We can't get the defaults on Windows, so return \"don't know\" */\n\t\tport->default_keepalives_idle = -1;\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\t}\n\n\treturn port->default_keepalives_idle;\n#else\n\treturn 0;\n#endif\n}\n\nint\npq_setkeepalivesidle(int idle, Port *port)\n{\n\tif (port == NULL || IS_AF_UNIX(port->laddr.addr.ss_family))\n\t\treturn STATUS_OK;\n\n/* check SIO_KEEPALIVE_VALS here, not just WIN32, as some toolchains lack it */\n#if defined(PG_TCP_KEEPALIVE_IDLE) || defined(SIO_KEEPALIVE_VALS)\n\tif (idle == port->keepalives_idle)\n\t\treturn STATUS_OK;\n\n#ifndef WIN32\n\tif (port->default_keepalives_idle <= 0)\n\t{\n\t\tif (pq_getkeepalivesidle(port) < 0)\n\t\t{\n\t\t\tif (idle == 0)\n\t\t\t\treturn STATUS_OK;\t/* default is set but unknown */\n\t\t\telse\n\t\t\t\treturn STATUS_ERROR;\n\t\t}\n\t}\n\n\tif (idle == 0)\n\t\tidle = port->default_keepalives_idle;\n\n\tif (setsockopt(port->sock, IPPROTO_TCP, PG_TCP_KEEPALIVE_IDLE,\n\t\t\t\t   (char *) &idle, sizeof(idle)) < 0)\n\t{\n\t\tereport(LOG,\n\t\t\t\t(errmsg(\"%s(%s) failed: %m\", \"setsockopt\", PG_TCP_KEEPALIVE_IDLE_STR)));\n\t\treturn STATUS_ERROR;\n\t}\n\n\tport->keepalives_idle = idle;\n#else\t\t\t\t\t\t\t/* WIN32 */\n\treturn pq_setkeepaliveswin32(port, idle, port->keepalives_interval);\n#endif\n#else\n\tif (idle != 0)\n\t{\n\t\tereport(LOG,\n\t\t\t\t(errmsg(\"setting the keepalive idle time is not supported\")));\n\t\treturn STATUS_ERROR;\n\t}\n#endif\n\n\treturn STATUS_OK;\n}\n\nint\npq_getkeepalivesinterval(Port *port)\n{\n#if defined(TCP_KEEPINTVL) || defined(SIO_KEEPALIVE_VALS)\n\tif (port == NULL || IS_AF_UNIX(port->laddr.addr.ss_family))\n\t\treturn 0;\n\n\tif (port->keepalives_interval != 0)\n\t\treturn port->keepalives_interval;\n\n\tif (port->default_keepalives_interval == 0)\n\t{\n#ifndef WIN32\n\t\tACCEPT_TYPE_ARG3 size = sizeof(port->default_keepalives_interval);\n\n\t\tif (getsockopt(port->sock, IPPROTO_TCP, TCP_KEEPINTVL,\n\t\t\t\t\t   (char *) &port->default_keepalives_interval,\n\t\t\t\t\t   &size) < 0)\n\t\t{\n\t\t\tereport(LOG,\n\t\t\t\t\t(errmsg(\"%s(%s) failed: %m\", \"getsockopt\", \"TCP_KEEPINTVL\")));\n\t\t\tport->default_keepalives_interval = -1; /* don't know */\n\t\t}\n#else\n\t\t/* We can't get the defaults on Windows, so return \"don't know\" */\n\t\tport->default_keepalives_interval = -1;\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\t}\n\n\treturn port->default_keepalives_interval;\n#else\n\treturn 0;\n#endif\n}\n\nint\npq_setkeepalivesinterval(int interval, Port *port)\n{\n\tif (port == NULL || IS_AF_UNIX(port->laddr.addr.ss_family))\n\t\treturn STATUS_OK;\n\n#if defined(TCP_KEEPINTVL) || defined(SIO_KEEPALIVE_VALS)\n\tif (interval == port->keepalives_interval)\n\t\treturn STATUS_OK;\n\n#ifndef WIN32\n\tif (port->default_keepalives_interval <= 0)\n\t{\n\t\tif (pq_getkeepalivesinterval(port) < 0)\n\t\t{\n\t\t\tif (interval == 0)\n\t\t\t\treturn STATUS_OK;\t/* default is set but unknown */\n\t\t\telse\n\t\t\t\treturn STATUS_ERROR;\n\t\t}\n\t}\n\n\tif (interval == 0)\n\t\tinterval = port->default_keepalives_interval;\n\n\tif (setsockopt(port->sock, IPPROTO_TCP, TCP_KEEPINTVL,\n\t\t\t\t   (char *) &interval, sizeof(interval)) < 0)\n\t{\n\t\tereport(LOG,\n\t\t\t\t(errmsg(\"%s(%s) failed: %m\", \"setsockopt\", \"TCP_KEEPINTVL\")));\n\t\treturn STATUS_ERROR;\n\t}\n\n\tport->keepalives_interval = interval;\n#else\t\t\t\t\t\t\t/* WIN32 */\n\treturn pq_setkeepaliveswin32(port, port->keepalives_idle, interval);\n#endif\n#else\n\tif (interval != 0)\n\t{\n\t\tereport(LOG,\n\t\t\t\t(errmsg(\"%s(%s) not supported\", \"setsockopt\", \"TCP_KEEPINTVL\")));\n\t\treturn STATUS_ERROR;\n\t}\n#endif\n\n\treturn STATUS_OK;\n}\n\nint\npq_getkeepalivescount(Port *port)\n{\n#ifdef TCP_KEEPCNT\n\tif (port == NULL || IS_AF_UNIX(port->laddr.addr.ss_family))\n\t\treturn 0;\n\n\tif (port->keepalives_count != 0)\n\t\treturn port->keepalives_count;\n\n\tif (port->default_keepalives_count == 0)\n\t{\n\t\tACCEPT_TYPE_ARG3 size = sizeof(port->default_keepalives_count);\n\n\t\tif (getsockopt(port->sock, IPPROTO_TCP, TCP_KEEPCNT,\n\t\t\t\t\t   (char *) &port->default_keepalives_count,\n\t\t\t\t\t   &size) < 0)\n\t\t{\n\t\t\tereport(LOG,\n\t\t\t\t\t(errmsg(\"%s(%s) failed: %m\", \"getsockopt\", \"TCP_KEEPCNT\")));\n\t\t\tport->default_keepalives_count = -1;\t/* don't know */\n\t\t}\n\t}\n\n\treturn port->default_keepalives_count;\n#else\n\treturn 0;\n#endif\n}\n\nint\npq_setkeepalivescount(int count, Port *port)\n{\n\tif (port == NULL || IS_AF_UNIX(port->laddr.addr.ss_family))\n\t\treturn STATUS_OK;\n\n#ifdef TCP_KEEPCNT\n\tif (count == port->keepalives_count)\n\t\treturn STATUS_OK;\n\n\tif (port->default_keepalives_count <= 0)\n\t{\n\t\tif (pq_getkeepalivescount(port) < 0)\n\t\t{\n\t\t\tif (count == 0)\n\t\t\t\treturn STATUS_OK;\t/* default is set but unknown */\n\t\t\telse\n\t\t\t\treturn STATUS_ERROR;\n\t\t}\n\t}\n\n\tif (count == 0)\n\t\tcount = port->default_keepalives_count;\n\n\tif (setsockopt(port->sock, IPPROTO_TCP, TCP_KEEPCNT,\n\t\t\t\t   (char *) &count, sizeof(count)) < 0)\n\t{\n\t\tereport(LOG,\n\t\t\t\t(errmsg(\"%s(%s) failed: %m\", \"setsockopt\", \"TCP_KEEPCNT\")));\n\t\treturn STATUS_ERROR;\n\t}\n\n\tport->keepalives_count = count;\n#else\n\tif (count != 0)\n\t{\n\t\tereport(LOG,\n\t\t\t\t(errmsg(\"%s(%s) not supported\", \"setsockopt\", \"TCP_KEEPCNT\")));\n\t\treturn STATUS_ERROR;\n\t}\n#endif\n\n\treturn STATUS_OK;\n}\n\nint\npq_gettcpusertimeout(Port *port)\n{\n#ifdef TCP_USER_TIMEOUT\n\tif (port == NULL || IS_AF_UNIX(port->laddr.addr.ss_family))\n\t\treturn 0;\n\n\tif (port->tcp_user_timeout != 0)\n\t\treturn port->tcp_user_timeout;\n\n\tif (port->default_tcp_user_timeout == 0)\n\t{\n\t\tACCEPT_TYPE_ARG3 size = sizeof(port->default_tcp_user_timeout);\n\n\t\tif (getsockopt(port->sock, IPPROTO_TCP, TCP_USER_TIMEOUT,\n\t\t\t\t\t   (char *) &port->default_tcp_user_timeout,\n\t\t\t\t\t   &size) < 0)\n\t\t{\n\t\t\tereport(LOG,\n\t\t\t\t\t(errmsg(\"%s(%s) failed: %m\", \"getsockopt\", \"TCP_USER_TIMEOUT\")));\n\t\t\tport->default_tcp_user_timeout = -1;\t/* don't know */\n\t\t}\n\t}\n\n\treturn port->default_tcp_user_timeout;\n#else\n\treturn 0;\n#endif\n}\n\nint\npq_settcpusertimeout(int timeout, Port *port)\n{\n\tif (port == NULL || IS_AF_UNIX(port->laddr.addr.ss_family))\n\t\treturn STATUS_OK;\n\n#ifdef TCP_USER_TIMEOUT\n\tif (timeout == port->tcp_user_timeout)\n\t\treturn STATUS_OK;\n\n\tif (port->default_tcp_user_timeout <= 0)\n\t{\n\t\tif (pq_gettcpusertimeout(port) < 0)\n\t\t{\n\t\t\tif (timeout == 0)\n\t\t\t\treturn STATUS_OK;\t/* default is set but unknown */\n\t\t\telse\n\t\t\t\treturn STATUS_ERROR;\n\t\t}\n\t}\n\n\tif (timeout == 0)\n\t\ttimeout = port->default_tcp_user_timeout;\n\n\tif (setsockopt(port->sock, IPPROTO_TCP, TCP_USER_TIMEOUT,\n\t\t\t\t   (char *) &timeout, sizeof(timeout)) < 0)\n\t{\n\t\tereport(LOG,\n\t\t\t\t(errmsg(\"%s(%s) failed: %m\", \"setsockopt\", \"TCP_USER_TIMEOUT\")));\n\t\treturn STATUS_ERROR;\n\t}\n\n\tport->tcp_user_timeout = timeout;\n#else\n\tif (timeout != 0)\n\t{\n\t\tereport(LOG,\n\t\t\t\t(errmsg(\"%s(%s) not supported\", \"setsockopt\", \"TCP_USER_TIMEOUT\")));\n\t\treturn STATUS_ERROR;\n\t}\n#endif\n\n\treturn STATUS_OK;\n}\n\n/*\n * Check if the client is still connected.\n */\nbool\npq_check_connection(void)\n{\n#if defined(POLLRDHUP)\n\t/*\n\t * POLLRDHUP is a Linux extension to poll(2) to detect sockets closed by\n\t * the other end.  We don't have a portable way to do that without\n\t * actually trying to read or write data on other systems.  We don't want\n\t * to read because that would be confused by pipelined queries and COPY\n\t * data. Perhaps in future we'll try to write a heartbeat message instead.\n\t */\n\tstruct pollfd pollfd;\n\tint\t\t\trc;\n\n\tpollfd.fd = MyProcPort->sock;\n\tpollfd.events = POLLOUT | POLLIN | POLLRDHUP;\n\tpollfd.revents = 0;\n\n\trc = poll(&pollfd, 1, 0);\n\n\tif (rc < 0)\n\t{\n\t\tereport(COMMERROR,\n\t\t\t\t(errcode_for_socket_access(),\n\t\t\t\t errmsg(\"could not poll socket: %m\")));\n\t\treturn false;\n\t}\n\telse if (rc == 1 && (pollfd.revents & (POLLHUP | POLLRDHUP)))\n\t\treturn false;\n#endif\n\n\treturn true;\n}\n", "/*-------------------------------------------------------------------------\n *\n * postmaster.c\n *\t  This program acts as a clearing house for requests to the\n *\t  POSTGRES system.  Frontend programs send a startup message\n *\t  to the Postmaster and the postmaster uses the info in the\n *\t  message to setup a backend process.\n *\n *\t  The postmaster also manages system-wide operations such as\n *\t  startup and shutdown. The postmaster itself doesn't do those\n *\t  operations, mind you --- it just forks off a subprocess to do them\n *\t  at the right times.  It also takes care of resetting the system\n *\t  if a backend crashes.\n *\n *\t  The postmaster process creates the shared memory and semaphore\n *\t  pools during startup, but as a rule does not touch them itself.\n *\t  In particular, it is not a member of the PGPROC array of backends\n *\t  and so it cannot participate in lock-manager operations.  Keeping\n *\t  the postmaster away from shared memory operations makes it simpler\n *\t  and more reliable.  The postmaster is almost always able to recover\n *\t  from crashes of individual backends by resetting shared memory;\n *\t  if it did much with shared memory then it would be prone to crashing\n *\t  along with the backends.\n *\n *\t  When a request message is received, we now fork() immediately.\n *\t  The child process performs authentication of the request, and\n *\t  then becomes a backend if successful.  This allows the auth code\n *\t  to be written in a simple single-threaded style (as opposed to the\n *\t  crufty \"poor man's multitasking\" code that used to be needed).\n *\t  More importantly, it ensures that blockages in non-multithreaded\n *\t  libraries like SSL or PAM cannot cause denial of service to other\n *\t  clients.\n *\n *\n * Portions Copyright (c) 1996-2021, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n *\n * IDENTIFICATION\n *\t  src/backend/postmaster/postmaster.c\n *\n * NOTES\n *\n * Initialization:\n *\t\tThe Postmaster sets up shared memory data structures\n *\t\tfor the backends.\n *\n * Synchronization:\n *\t\tThe Postmaster shares memory with the backends but should avoid\n *\t\ttouching shared memory, so as not to become stuck if a crashing\n *\t\tbackend screws up locks or shared memory.  Likewise, the Postmaster\n *\t\tshould never block on messages from frontend clients.\n *\n * Garbage Collection:\n *\t\tThe Postmaster cleans up after backends if they have an emergency\n *\t\texit and/or core dump.\n *\n * Error Reporting:\n *\t\tUse write_stderr() only for reporting \"interactive\" errors\n *\t\t(essentially, bogus arguments on the command line).  Once the\n *\t\tpostmaster is launched, use ereport().\n *\n *-------------------------------------------------------------------------\n */\n\n#include \"postgres.h\"\n\n#include <unistd.h>\n#include <signal.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <ctype.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <fcntl.h>\n#include <sys/param.h>\n#include <netdb.h>\n#include <limits.h>\n\n#ifdef HAVE_SYS_SELECT_H\n#include <sys/select.h>\n#endif\n\n#ifdef USE_BONJOUR\n#include <dns_sd.h>\n#endif\n\n#ifdef USE_SYSTEMD\n#include <systemd/sd-daemon.h>\n#endif\n\n#ifdef HAVE_PTHREAD_IS_THREADED_NP\n#include <pthread.h>\n#endif\n\n#include \"access/transam.h\"\n#include \"access/xlog.h\"\n#include \"catalog/pg_control.h\"\n#include \"common/file_perm.h\"\n#include \"common/ip.h\"\n#include \"common/string.h\"\n#include \"lib/ilist.h\"\n#include \"libpq/auth.h\"\n#include \"libpq/libpq.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/pqsignal.h\"\n#include \"pg_getopt.h\"\n#include \"pgstat.h\"\n#include \"port/pg_bswap.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"postmaster/auxprocess.h\"\n#include \"postmaster/bgworker_internals.h\"\n#include \"postmaster/fork_process.h\"\n#include \"postmaster/interrupt.h\"\n#include \"postmaster/pgarch.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/syslogger.h\"\n#include \"replication/logicallauncher.h\"\n#include \"replication/walsender.h\"\n#include \"storage/fd.h\"\n#include \"storage/ipc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/pmsignal.h\"\n#include \"storage/proc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"utils/builtins.h\"\n#include \"utils/datetime.h\"\n#include \"utils/memutils.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/ps_status.h\"\n#include \"utils/queryjumble.h\"\n#include \"utils/timeout.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/varlena.h\"\n\n#ifdef EXEC_BACKEND\n#include \"storage/spin.h\"\n#endif\n\n\n/*\n * Possible types of a backend. Beyond being the possible bkend_type values in\n * struct bkend, these are OR-able request flag bits for SignalSomeChildren()\n * and CountChildren().\n */\n#define BACKEND_TYPE_NORMAL\t\t0x0001\t/* normal backend */\n#define BACKEND_TYPE_AUTOVAC\t0x0002\t/* autovacuum worker process */\n#define BACKEND_TYPE_WALSND\t\t0x0004\t/* walsender process */\n#define BACKEND_TYPE_BGWORKER\t0x0008\t/* bgworker process */\n#define BACKEND_TYPE_ALL\t\t0x000F\t/* OR of all the above */\n\n/*\n * List of active backends (or child processes anyway; we don't actually\n * know whether a given child has become a backend or is still in the\n * authorization phase).  This is used mainly to keep track of how many\n * children we have and send them appropriate signals when necessary.\n *\n * As shown in the above set of backend types, this list includes not only\n * \"normal\" client sessions, but also autovacuum workers, walsenders, and\n * background workers.  (Note that at the time of launch, walsenders are\n * labeled BACKEND_TYPE_NORMAL; we relabel them to BACKEND_TYPE_WALSND\n * upon noticing they've changed their PMChildFlags entry.  Hence that check\n * must be done before any operation that needs to distinguish walsenders\n * from normal backends.)\n *\n * Also, \"dead_end\" children are in it: these are children launched just for\n * the purpose of sending a friendly rejection message to a would-be client.\n * We must track them because they are attached to shared memory, but we know\n * they will never become live backends.  dead_end children are not assigned a\n * PMChildSlot.  dead_end children have bkend_type NORMAL.\n *\n * \"Special\" children such as the startup, bgwriter and autovacuum launcher\n * tasks are not in this list.  They are tracked via StartupPID and other\n * pid_t variables below.  (Thus, there can't be more than one of any given\n * \"special\" child process type.  We use BackendList entries for any child\n * process there can be more than one of.)\n */\ntypedef struct bkend\n{\n\tpid_t\t\tpid;\t\t\t/* process id of backend */\n\tint32\t\tcancel_key;\t\t/* cancel key for cancels for this backend */\n\tint\t\t\tchild_slot;\t\t/* PMChildSlot for this backend, if any */\n\tint\t\t\tbkend_type;\t\t/* child process flavor, see above */\n\tbool\t\tdead_end;\t\t/* is it going to send an error and quit? */\n\tbool\t\tbgworker_notify;\t/* gets bgworker start/stop notifications */\n\tdlist_node\telem;\t\t\t/* list link in BackendList */\n} Backend;\n\nstatic dlist_head BackendList = DLIST_STATIC_INIT(BackendList);\n\n#ifdef EXEC_BACKEND\nstatic Backend *ShmemBackendArray;\n#endif\n\nBackgroundWorker *MyBgworkerEntry = NULL;\n\n\n\n/* The socket number we are listening for connections on */\nint\t\t\tPostPortNumber;\n\n/* The directory names for Unix socket(s) */\nchar\t   *Unix_socket_directories;\n\n/* The TCP listen address(es) */\nchar\t   *ListenAddresses;\n\n/*\n * ReservedBackends is the number of backends reserved for superuser use.\n * This number is taken out of the pool size given by MaxConnections so\n * number of backend slots available to non-superusers is\n * (MaxConnections - ReservedBackends).  Note what this really means is\n * \"if there are <= ReservedBackends connections available, only superusers\n * can make new connections\" --- pre-existing superuser connections don't\n * count against the limit.\n */\nint\t\t\tReservedBackends;\n\n/* The socket(s) we're listening to. */\n#define MAXLISTEN\t64\nstatic pgsocket ListenSocket[MAXLISTEN];\n\n/*\n * These globals control the behavior of the postmaster in case some\n * backend dumps core.  Normally, it kills all peers of the dead backend\n * and reinitializes shared memory.  By specifying -s or -n, we can have\n * the postmaster stop (rather than kill) peers and not reinitialize\n * shared data structures.  (Reinit is currently dead code, though.)\n */\nstatic bool Reinit = true;\nstatic int\tSendStop = false;\n\n/* still more option variables */\nbool\t\tEnableSSL = false;\n\nint\t\t\tPreAuthDelay = 0;\nint\t\t\tAuthenticationTimeout = 60;\n\nbool\t\tlog_hostname;\t\t/* for ps display and logging */\nbool\t\tLog_connections = false;\nbool\t\tDb_user_namespace = false;\n\nbool\t\tenable_bonjour = false;\nchar\t   *bonjour_name;\nbool\t\trestart_after_crash = true;\nbool\t\tremove_temp_files_after_crash = true;\n\n/* PIDs of special child processes; 0 when not running */\nstatic pid_t StartupPID = 0,\n\t\t\tBgWriterPID = 0,\n\t\t\tCheckpointerPID = 0,\n\t\t\tWalWriterPID = 0,\n\t\t\tWalReceiverPID = 0,\n\t\t\tAutoVacPID = 0,\n\t\t\tPgArchPID = 0,\n\t\t\tPgStatPID = 0,\n\t\t\tSysLoggerPID = 0;\n\n/* Startup process's status */\ntypedef enum\n{\n\tSTARTUP_NOT_RUNNING,\n\tSTARTUP_RUNNING,\n\tSTARTUP_SIGNALED,\t\t\t/* we sent it a SIGQUIT or SIGKILL */\n\tSTARTUP_CRASHED\n} StartupStatusEnum;\n\nstatic StartupStatusEnum StartupStatus = STARTUP_NOT_RUNNING;\n\n/* Startup/shutdown state */\n#define\t\t\tNoShutdown\t\t0\n#define\t\t\tSmartShutdown\t1\n#define\t\t\tFastShutdown\t2\n#define\t\t\tImmediateShutdown\t3\n\nstatic int\tShutdown = NoShutdown;\n\nstatic bool FatalError = false; /* T if recovering from backend crash */\n\n/*\n * We use a simple state machine to control startup, shutdown, and\n * crash recovery (which is rather like shutdown followed by startup).\n *\n * After doing all the postmaster initialization work, we enter PM_STARTUP\n * state and the startup process is launched. The startup process begins by\n * reading the control file and other preliminary initialization steps.\n * In a normal startup, or after crash recovery, the startup process exits\n * with exit code 0 and we switch to PM_RUN state.  However, archive recovery\n * is handled specially since it takes much longer and we would like to support\n * hot standby during archive recovery.\n *\n * When the startup process is ready to start archive recovery, it signals the\n * postmaster, and we switch to PM_RECOVERY state. The background writer and\n * checkpointer are launched, while the startup process continues applying WAL.\n * If Hot Standby is enabled, then, after reaching a consistent point in WAL\n * redo, startup process signals us again, and we switch to PM_HOT_STANDBY\n * state and begin accepting connections to perform read-only queries.  When\n * archive recovery is finished, the startup process exits with exit code 0\n * and we switch to PM_RUN state.\n *\n * Normal child backends can only be launched when we are in PM_RUN or\n * PM_HOT_STANDBY state.  (connsAllowed can also restrict launching.)\n * In other states we handle connection requests by launching \"dead_end\"\n * child processes, which will simply send the client an error message and\n * quit.  (We track these in the BackendList so that we can know when they\n * are all gone; this is important because they're still connected to shared\n * memory, and would interfere with an attempt to destroy the shmem segment,\n * possibly leading to SHMALL failure when we try to make a new one.)\n * In PM_WAIT_DEAD_END state we are waiting for all the dead_end children\n * to drain out of the system, and therefore stop accepting connection\n * requests at all until the last existing child has quit (which hopefully\n * will not be very long).\n *\n * Notice that this state variable does not distinguish *why* we entered\n * states later than PM_RUN --- Shutdown and FatalError must be consulted\n * to find that out.  FatalError is never true in PM_RECOVERY, PM_HOT_STANDBY,\n * or PM_RUN states, nor in PM_SHUTDOWN states (because we don't enter those\n * states when trying to recover from a crash).  It can be true in PM_STARTUP\n * state, because we don't clear it until we've successfully started WAL redo.\n */\ntypedef enum\n{\n\tPM_INIT,\t\t\t\t\t/* postmaster starting */\n\tPM_STARTUP,\t\t\t\t\t/* waiting for startup subprocess */\n\tPM_RECOVERY,\t\t\t\t/* in archive recovery mode */\n\tPM_HOT_STANDBY,\t\t\t\t/* in hot standby mode */\n\tPM_RUN,\t\t\t\t\t\t/* normal \"database is alive\" state */\n\tPM_STOP_BACKENDS,\t\t\t/* need to stop remaining backends */\n\tPM_WAIT_BACKENDS,\t\t\t/* waiting for live backends to exit */\n\tPM_SHUTDOWN,\t\t\t\t/* waiting for checkpointer to do shutdown\n\t\t\t\t\t\t\t\t * ckpt */\n\tPM_SHUTDOWN_2,\t\t\t\t/* waiting for archiver and walsenders to\n\t\t\t\t\t\t\t\t * finish */\n\tPM_WAIT_DEAD_END,\t\t\t/* waiting for dead_end children to exit */\n\tPM_NO_CHILDREN\t\t\t\t/* all important children have exited */\n} PMState;\n\nstatic PMState pmState = PM_INIT;\n\n/*\n * While performing a \"smart shutdown\", we restrict new connections but stay\n * in PM_RUN or PM_HOT_STANDBY state until all the client backends are gone.\n * connsAllowed is a sub-state indicator showing the active restriction.\n * It is of no interest unless pmState is PM_RUN or PM_HOT_STANDBY.\n */\ntypedef enum\n{\n\tALLOW_ALL_CONNS,\t\t\t/* normal not-shutting-down state */\n\tALLOW_SUPERUSER_CONNS,\t\t/* only superusers can connect */\n\tALLOW_NO_CONNS\t\t\t\t/* no new connections allowed, period */\n} ConnsAllowedState;\n\nstatic ConnsAllowedState connsAllowed = ALLOW_ALL_CONNS;\n\n/* Start time of SIGKILL timeout during immediate shutdown or child crash */\n/* Zero means timeout is not running */\nstatic time_t AbortStartTime = 0;\n\n/* Length of said timeout */\n#define SIGKILL_CHILDREN_AFTER_SECS\t\t5\n\nstatic bool ReachedNormalRunning = false;\t/* T if we've reached PM_RUN */\n\nbool\t\tClientAuthInProgress = false;\t/* T during new-client\n\t\t\t\t\t\t\t\t\t\t\t * authentication */\n\nbool\t\tredirection_done = false;\t/* stderr redirected for syslogger? */\n\n/* received START_AUTOVAC_LAUNCHER signal */\nstatic volatile sig_atomic_t start_autovac_launcher = false;\n\n/* the launcher needs to be signaled to communicate some condition */\nstatic volatile bool avlauncher_needs_signal = false;\n\n/* received START_WALRECEIVER signal */\nstatic volatile sig_atomic_t WalReceiverRequested = false;\n\n/* set when there's a worker that needs to be started up */\nstatic volatile bool StartWorkerNeeded = true;\nstatic volatile bool HaveCrashedWorker = false;\n\n#ifdef USE_SSL\n/* Set when and if SSL has been initialized properly */\nstatic bool LoadedSSL = false;\n#endif\n\n#ifdef USE_BONJOUR\nstatic DNSServiceRef bonjour_sdref = NULL;\n#endif\n\n/*\n * postmaster.c - function prototypes\n */\nstatic void CloseServerPorts(int status, Datum arg);\nstatic void unlink_external_pid_file(int status, Datum arg);\nstatic void getInstallationPaths(const char *argv0);\nstatic void checkControlFile(void);\nstatic Port *ConnCreate(int serverFd);\nstatic void ConnFree(Port *port);\nstatic void reset_shared(void);\nstatic void SIGHUP_handler(SIGNAL_ARGS);\nstatic void pmdie(SIGNAL_ARGS);\nstatic void reaper(SIGNAL_ARGS);\nstatic void sigusr1_handler(SIGNAL_ARGS);\nstatic void process_startup_packet_die(SIGNAL_ARGS);\nstatic void dummy_handler(SIGNAL_ARGS);\nstatic void StartupPacketTimeoutHandler(void);\nstatic void CleanupBackend(int pid, int exitstatus);\nstatic bool CleanupBackgroundWorker(int pid, int exitstatus);\nstatic void HandleChildCrash(int pid, int exitstatus, const char *procname);\nstatic void LogChildExit(int lev, const char *procname,\n\t\t\t\t\t\t int pid, int exitstatus);\nstatic void PostmasterStateMachine(void);\nstatic void BackendInitialize(Port *port);\nstatic void BackendRun(Port *port) pg_attribute_noreturn();\nstatic void ExitPostmaster(int status) pg_attribute_noreturn();\nstatic int\tServerLoop(void);\nstatic int\tBackendStartup(Port *port);\nstatic int\tProcessStartupPacket(Port *port, bool ssl_done, bool gss_done);\nstatic void SendNegotiateProtocolVersion(List *unrecognized_protocol_options);\nstatic void processCancelRequest(Port *port, void *pkt);\nstatic int\tinitMasks(fd_set *rmask);\nstatic void report_fork_failure_to_client(Port *port, int errnum);\nstatic CAC_state canAcceptConnections(int backend_type);\nstatic bool RandomCancelKey(int32 *cancel_key);\nstatic void signal_child(pid_t pid, int signal);\nstatic bool SignalSomeChildren(int signal, int targets);\nstatic void TerminateChildren(int signal);\n\n#define SignalChildren(sig)\t\t\t   SignalSomeChildren(sig, BACKEND_TYPE_ALL)\n\nstatic int\tCountChildren(int target);\nstatic bool assign_backendlist_entry(RegisteredBgWorker *rw);\nstatic void maybe_start_bgworkers(void);\nstatic bool CreateOptsFile(int argc, char *argv[], char *fullprogname);\nstatic pid_t StartChildProcess(AuxProcType type);\nstatic void StartAutovacuumWorker(void);\nstatic void MaybeStartWalReceiver(void);\nstatic void InitPostmasterDeathWatchHandle(void);\n\n/*\n * Archiver is allowed to start up at the current postmaster state?\n *\n * If WAL archiving is enabled always, we are allowed to start archiver\n * even during recovery.\n */\n#define PgArchStartupAllowed()\t\\\n\t(((XLogArchivingActive() && pmState == PM_RUN) ||\t\t\t\\\n\t  (XLogArchivingAlways() &&\t\t\t\t\t\t\t\t\t  \\\n\t   (pmState == PM_RECOVERY || pmState == PM_HOT_STANDBY))) && \\\n\t PgArchCanRestart())\n\n#ifdef EXEC_BACKEND\n\n#ifdef WIN32\n#define WNOHANG 0\t\t\t\t/* ignored, so any integer value will do */\n\nstatic pid_t waitpid(pid_t pid, int *exitstatus, int options);\nstatic void WINAPI pgwin32_deadchild_callback(PVOID lpParameter, BOOLEAN TimerOrWaitFired);\n\nstatic HANDLE win32ChildQueue;\n\ntypedef struct\n{\n\tHANDLE\t\twaitHandle;\n\tHANDLE\t\tprocHandle;\n\tDWORD\t\tprocId;\n} win32_deadchild_waitinfo;\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\nstatic pid_t backend_forkexec(Port *port);\nstatic pid_t internal_forkexec(int argc, char *argv[], Port *port);\n\n/* Type for a socket that can be inherited to a client process */\n#ifdef WIN32\ntypedef struct\n{\n\tSOCKET\t\torigsocket;\t\t/* Original socket value, or PGINVALID_SOCKET\n\t\t\t\t\t\t\t\t * if not a socket */\n\tWSAPROTOCOL_INFO wsainfo;\n} InheritableSocket;\n#else\ntypedef int InheritableSocket;\n#endif\n\n/*\n * Structure contains all variables passed to exec:ed backends\n */\ntypedef struct\n{\n\tPort\t\tport;\n\tInheritableSocket portsocket;\n\tchar\t\tDataDir[MAXPGPATH];\n\tpgsocket\tListenSocket[MAXLISTEN];\n\tint32\t\tMyCancelKey;\n\tint\t\t\tMyPMChildSlot;\n#ifndef WIN32\n\tunsigned long UsedShmemSegID;\n#else\n\tvoid\t   *ShmemProtectiveRegion;\n\tHANDLE\t\tUsedShmemSegID;\n#endif\n\tvoid\t   *UsedShmemSegAddr;\n\tslock_t    *ShmemLock;\n\tVariableCache ShmemVariableCache;\n\tBackend    *ShmemBackendArray;\n#ifndef HAVE_SPINLOCKS\n\tPGSemaphore *SpinlockSemaArray;\n#endif\n\tint\t\t\tNamedLWLockTrancheRequests;\n\tNamedLWLockTranche *NamedLWLockTrancheArray;\n\tLWLockPadded *MainLWLockArray;\n\tslock_t    *ProcStructLock;\n\tPROC_HDR   *ProcGlobal;\n\tPGPROC\t   *AuxiliaryProcs;\n\tPGPROC\t   *PreparedXactProcs;\n\tPMSignalData *PMSignalState;\n\tInheritableSocket pgStatSock;\n\tpid_t\t\tPostmasterPid;\n\tTimestampTz PgStartTime;\n\tTimestampTz PgReloadTime;\n\tpg_time_t\tfirst_syslogger_file_time;\n\tbool\t\tredirection_done;\n\tbool\t\tIsBinaryUpgrade;\n\tbool\t\tquery_id_enabled;\n\tint\t\t\tmax_safe_fds;\n\tint\t\t\tMaxBackends;\n#ifdef WIN32\n\tHANDLE\t\tPostmasterHandle;\n\tHANDLE\t\tinitial_signal_pipe;\n\tHANDLE\t\tsyslogPipe[2];\n#else\n\tint\t\t\tpostmaster_alive_fds[2];\n\tint\t\t\tsyslogPipe[2];\n#endif\n\tchar\t\tmy_exec_path[MAXPGPATH];\n\tchar\t\tpkglib_path[MAXPGPATH];\n} BackendParameters;\n\nstatic void read_backend_variables(char *id, Port *port);\nstatic void restore_backend_variables(BackendParameters *param, Port *port);\n\n#ifndef WIN32\nstatic bool save_backend_variables(BackendParameters *param, Port *port);\n#else\nstatic bool save_backend_variables(BackendParameters *param, Port *port,\n\t\t\t\t\t\t\t\t   HANDLE childProcess, pid_t childPid);\n#endif\n\nstatic void ShmemBackendArrayAdd(Backend *bn);\nstatic void ShmemBackendArrayRemove(Backend *bn);\n#endif\t\t\t\t\t\t\t/* EXEC_BACKEND */\n\n#define StartupDataBase()\t\tStartChildProcess(StartupProcess)\n#define StartArchiver()\t\t\tStartChildProcess(ArchiverProcess)\n#define StartBackgroundWriter() StartChildProcess(BgWriterProcess)\n#define StartCheckpointer()\t\tStartChildProcess(CheckpointerProcess)\n#define StartWalWriter()\t\tStartChildProcess(WalWriterProcess)\n#define StartWalReceiver()\t\tStartChildProcess(WalReceiverProcess)\n\n/* Macros to check exit status of a child process */\n#define EXIT_STATUS_0(st)  ((st) == 0)\n#define EXIT_STATUS_1(st)  (WIFEXITED(st) && WEXITSTATUS(st) == 1)\n#define EXIT_STATUS_3(st)  (WIFEXITED(st) && WEXITSTATUS(st) == 3)\n\n#ifndef WIN32\n/*\n * File descriptors for pipe used to monitor if postmaster is alive.\n * First is POSTMASTER_FD_WATCH, second is POSTMASTER_FD_OWN.\n */\nint\t\t\tpostmaster_alive_fds[2] = {-1, -1};\n#else\n/* Process handle of postmaster used for the same purpose on Windows */\nHANDLE\t\tPostmasterHandle;\n#endif\n\n/*\n * Postmaster main entry point\n */\nvoid\nPostmasterMain(int argc, char *argv[])\n{\n\tint\t\t\topt;\n\tint\t\t\tstatus;\n\tchar\t   *userDoption = NULL;\n\tbool\t\tlisten_addr_saved = false;\n\tint\t\t\ti;\n\tchar\t   *output_config_variable = NULL;\n\n\tInitProcessGlobals();\n\n\tPostmasterPid = MyProcPid;\n\n\tIsPostmasterEnvironment = true;\n\n\t/*\n\t * Start our win32 signal implementation\n\t */\n#ifdef WIN32\n\tpgwin32_signal_initialize();\n#endif\n\n\t/*\n\t * We should not be creating any files or directories before we check the\n\t * data directory (see checkDataDir()), but just in case set the umask to\n\t * the most restrictive (owner-only) permissions.\n\t *\n\t * checkDataDir() will reset the umask based on the data directory\n\t * permissions.\n\t */\n\tumask(PG_MODE_MASK_OWNER);\n\n\t/*\n\t * By default, palloc() requests in the postmaster will be allocated in\n\t * the PostmasterContext, which is space that can be recycled by backends.\n\t * Allocated data that needs to be available to backends should be\n\t * allocated in TopMemoryContext.\n\t */\n\tPostmasterContext = AllocSetContextCreate(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t  \"Postmaster\",\n\t\t\t\t\t\t\t\t\t\t\t  ALLOCSET_DEFAULT_SIZES);\n\tMemoryContextSwitchTo(PostmasterContext);\n\n\t/* Initialize paths to installation files */\n\tgetInstallationPaths(argv[0]);\n\n\t/*\n\t * Set up signal handlers for the postmaster process.\n\t *\n\t * In the postmaster, we use pqsignal_pm() rather than pqsignal() (which\n\t * is used by all child processes and client processes).  That has a\n\t * couple of special behaviors:\n\t *\n\t * 1. Except on Windows, we tell sigaction() to block all signals for the\n\t * duration of the signal handler.  This is faster than our old approach\n\t * of blocking/unblocking explicitly in the signal handler, and it should\n\t * also prevent excessive stack consumption if signals arrive quickly.\n\t *\n\t * 2. We do not set the SA_RESTART flag.  This is because signals will be\n\t * blocked at all times except when ServerLoop is waiting for something to\n\t * happen, and during that window, we want signals to exit the select(2)\n\t * wait so that ServerLoop can respond if anything interesting happened.\n\t * On some platforms, signals marked SA_RESTART would not cause the\n\t * select() wait to end.\n\t *\n\t * Child processes will generally want SA_RESTART, so pqsignal() sets that\n\t * flag.  We expect children to set up their own handlers before\n\t * unblocking signals.\n\t *\n\t * CAUTION: when changing this list, check for side-effects on the signal\n\t * handling setup of child processes.  See tcop/postgres.c,\n\t * bootstrap/bootstrap.c, postmaster/bgwriter.c, postmaster/walwriter.c,\n\t * postmaster/autovacuum.c, postmaster/pgarch.c, postmaster/pgstat.c,\n\t * postmaster/syslogger.c, postmaster/bgworker.c and\n\t * postmaster/checkpointer.c.\n\t */\n\tpqinitmask();\n\tPG_SETMASK(&BlockSig);\n\n\tpqsignal_pm(SIGHUP, SIGHUP_handler);\t/* reread config file and have\n\t\t\t\t\t\t\t\t\t\t\t * children do same */\n\tpqsignal_pm(SIGINT, pmdie); /* send SIGTERM and shut down */\n\tpqsignal_pm(SIGQUIT, pmdie);\t/* send SIGQUIT and die */\n\tpqsignal_pm(SIGTERM, pmdie);\t/* wait for children and shut down */\n\tpqsignal_pm(SIGALRM, SIG_IGN);\t/* ignored */\n\tpqsignal_pm(SIGPIPE, SIG_IGN);\t/* ignored */\n\tpqsignal_pm(SIGUSR1, sigusr1_handler);\t/* message from child process */\n\tpqsignal_pm(SIGUSR2, dummy_handler);\t/* unused, reserve for children */\n\tpqsignal_pm(SIGCHLD, reaper);\t/* handle child termination */\n\n#ifdef SIGURG\n\n\t/*\n\t * Ignore SIGURG for now.  Child processes may change this (see\n\t * InitializeLatchSupport), but they will not receive any such signals\n\t * until they wait on a latch.\n\t */\n\tpqsignal_pm(SIGURG, SIG_IGN);\t/* ignored */\n#endif\n\n\t/*\n\t * No other place in Postgres should touch SIGTTIN/SIGTTOU handling.  We\n\t * ignore those signals in a postmaster environment, so that there is no\n\t * risk of a child process freezing up due to writing to stderr.  But for\n\t * a standalone backend, their default handling is reasonable.  Hence, all\n\t * child processes should just allow the inherited settings to stand.\n\t */\n#ifdef SIGTTIN\n\tpqsignal_pm(SIGTTIN, SIG_IGN);\t/* ignored */\n#endif\n#ifdef SIGTTOU\n\tpqsignal_pm(SIGTTOU, SIG_IGN);\t/* ignored */\n#endif\n\n\t/* ignore SIGXFSZ, so that ulimit violations work like disk full */\n#ifdef SIGXFSZ\n\tpqsignal_pm(SIGXFSZ, SIG_IGN);\t/* ignored */\n#endif\n\n\t/*\n\t * Options setup\n\t */\n\tInitializeGUCOptions();\n\n\topterr = 1;\n\n\t/*\n\t * Parse command-line options.  CAUTION: keep this in sync with\n\t * tcop/postgres.c (the option sets should not conflict) and with the\n\t * common help() function in main/main.c.\n\t */\n\twhile ((opt = getopt(argc, argv, \"B:bc:C:D:d:EeFf:h:ijk:lN:nOPp:r:S:sTt:W:-:\")) != -1)\n\t{\n\t\tswitch (opt)\n\t\t{\n\t\t\tcase 'B':\n\t\t\t\tSetConfigOption(\"shared_buffers\", optarg, PGC_POSTMASTER, PGC_S_ARGV);\n\t\t\t\tbreak;\n\n\t\t\tcase 'b':\n\t\t\t\t/* Undocumented flag used for binary upgrades */\n\t\t\t\tIsBinaryUpgrade = true;\n\t\t\t\tbreak;\n\n\t\t\tcase 'C':\n\t\t\t\toutput_config_variable = strdup(optarg);\n\t\t\t\tbreak;\n\n\t\t\tcase 'D':\n\t\t\t\tuserDoption = strdup(optarg);\n\t\t\t\tbreak;\n\n\t\t\tcase 'd':\n\t\t\t\tset_debug_options(atoi(optarg), PGC_POSTMASTER, PGC_S_ARGV);\n\t\t\t\tbreak;\n\n\t\t\tcase 'E':\n\t\t\t\tSetConfigOption(\"log_statement\", \"all\", PGC_POSTMASTER, PGC_S_ARGV);\n\t\t\t\tbreak;\n\n\t\t\tcase 'e':\n\t\t\t\tSetConfigOption(\"datestyle\", \"euro\", PGC_POSTMASTER, PGC_S_ARGV);\n\t\t\t\tbreak;\n\n\t\t\tcase 'F':\n\t\t\t\tSetConfigOption(\"fsync\", \"false\", PGC_POSTMASTER, PGC_S_ARGV);\n\t\t\t\tbreak;\n\n\t\t\tcase 'f':\n\t\t\t\tif (!set_plan_disabling_options(optarg, PGC_POSTMASTER, PGC_S_ARGV))\n\t\t\t\t{\n\t\t\t\t\twrite_stderr(\"%s: invalid argument for option -f: \\\"%s\\\"\\n\",\n\t\t\t\t\t\t\t\t progname, optarg);\n\t\t\t\t\tExitPostmaster(1);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'h':\n\t\t\t\tSetConfigOption(\"listen_addresses\", optarg, PGC_POSTMASTER, PGC_S_ARGV);\n\t\t\t\tbreak;\n\n\t\t\tcase 'i':\n\t\t\t\tSetConfigOption(\"listen_addresses\", \"*\", PGC_POSTMASTER, PGC_S_ARGV);\n\t\t\t\tbreak;\n\n\t\t\tcase 'j':\n\t\t\t\t/* only used by interactive backend */\n\t\t\t\tbreak;\n\n\t\t\tcase 'k':\n\t\t\t\tSetConfigOption(\"unix_socket_directories\", optarg, PGC_POSTMASTER, PGC_S_ARGV);\n\t\t\t\tbreak;\n\n\t\t\tcase 'l':\n\t\t\t\tSetConfigOption(\"ssl\", \"true\", PGC_POSTMASTER, PGC_S_ARGV);\n\t\t\t\tbreak;\n\n\t\t\tcase 'N':\n\t\t\t\tSetConfigOption(\"max_connections\", optarg, PGC_POSTMASTER, PGC_S_ARGV);\n\t\t\t\tbreak;\n\n\t\t\tcase 'n':\n\t\t\t\t/* Don't reinit shared mem after abnormal exit */\n\t\t\t\tReinit = false;\n\t\t\t\tbreak;\n\n\t\t\tcase 'O':\n\t\t\t\tSetConfigOption(\"allow_system_table_mods\", \"true\", PGC_POSTMASTER, PGC_S_ARGV);\n\t\t\t\tbreak;\n\n\t\t\tcase 'P':\n\t\t\t\tSetConfigOption(\"ignore_system_indexes\", \"true\", PGC_POSTMASTER, PGC_S_ARGV);\n\t\t\t\tbreak;\n\n\t\t\tcase 'p':\n\t\t\t\tSetConfigOption(\"port\", optarg, PGC_POSTMASTER, PGC_S_ARGV);\n\t\t\t\tbreak;\n\n\t\t\tcase 'r':\n\t\t\t\t/* only used by single-user backend */\n\t\t\t\tbreak;\n\n\t\t\tcase 'S':\n\t\t\t\tSetConfigOption(\"work_mem\", optarg, PGC_POSTMASTER, PGC_S_ARGV);\n\t\t\t\tbreak;\n\n\t\t\tcase 's':\n\t\t\t\tSetConfigOption(\"log_statement_stats\", \"true\", PGC_POSTMASTER, PGC_S_ARGV);\n\t\t\t\tbreak;\n\n\t\t\tcase 'T':\n\n\t\t\t\t/*\n\t\t\t\t * In the event that some backend dumps core, send SIGSTOP,\n\t\t\t\t * rather than SIGQUIT, to all its peers.  This lets the wily\n\t\t\t\t * post_hacker collect core dumps from everyone.\n\t\t\t\t */\n\t\t\t\tSendStop = true;\n\t\t\t\tbreak;\n\n\t\t\tcase 't':\n\t\t\t\t{\n\t\t\t\t\tconst char *tmp = get_stats_option_name(optarg);\n\n\t\t\t\t\tif (tmp)\n\t\t\t\t\t{\n\t\t\t\t\t\tSetConfigOption(tmp, \"true\", PGC_POSTMASTER, PGC_S_ARGV);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\twrite_stderr(\"%s: invalid argument for option -t: \\\"%s\\\"\\n\",\n\t\t\t\t\t\t\t\t\t progname, optarg);\n\t\t\t\t\t\tExitPostmaster(1);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tcase 'W':\n\t\t\t\tSetConfigOption(\"post_auth_delay\", optarg, PGC_POSTMASTER, PGC_S_ARGV);\n\t\t\t\tbreak;\n\n\t\t\tcase 'c':\n\t\t\tcase '-':\n\t\t\t\t{\n\t\t\t\t\tchar\t   *name,\n\t\t\t\t\t\t\t   *value;\n\n\t\t\t\t\tParseLongOption(optarg, &name, &value);\n\t\t\t\t\tif (!value)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (opt == '-')\n\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t\t\t\t errmsg(\"--%s requires a value\",\n\t\t\t\t\t\t\t\t\t\t\toptarg)));\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t\t\t\t errmsg(\"-c %s requires a value\",\n\t\t\t\t\t\t\t\t\t\t\toptarg)));\n\t\t\t\t\t}\n\n\t\t\t\t\tSetConfigOption(name, value, PGC_POSTMASTER, PGC_S_ARGV);\n\t\t\t\t\tfree(name);\n\t\t\t\t\tif (value)\n\t\t\t\t\t\tfree(value);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tdefault:\n\t\t\t\twrite_stderr(\"Try \\\"%s --help\\\" for more information.\\n\",\n\t\t\t\t\t\t\t progname);\n\t\t\t\tExitPostmaster(1);\n\t\t}\n\t}\n\n\t/*\n\t * Postmaster accepts no non-option switch arguments.\n\t */\n\tif (optind < argc)\n\t{\n\t\twrite_stderr(\"%s: invalid argument: \\\"%s\\\"\\n\",\n\t\t\t\t\t progname, argv[optind]);\n\t\twrite_stderr(\"Try \\\"%s --help\\\" for more information.\\n\",\n\t\t\t\t\t progname);\n\t\tExitPostmaster(1);\n\t}\n\n\t/*\n\t * Locate the proper configuration files and data directory, and read\n\t * postgresql.conf for the first time.\n\t */\n\tif (!SelectConfigFiles(userDoption, progname))\n\t\tExitPostmaster(2);\n\n\tif (output_config_variable != NULL)\n\t{\n\t\t/*\n\t\t * If this is a runtime-computed GUC, it hasn't yet been initialized,\n\t\t * and the present value is not useful.  However, this is a convenient\n\t\t * place to print the value for most GUCs because it is safe to run\n\t\t * postmaster startup to this point even if the server is already\n\t\t * running.  For the handful of runtime-computed GUCs that we cannot\n\t\t * provide meaningful values for yet, we wait until later in\n\t\t * postmaster startup to print the value.  We won't be able to use -C\n\t\t * on running servers for those GUCs, but using this option now would\n\t\t * lead to incorrect results for them.\n\t\t */\n\t\tint\t\t\tflags = GetConfigOptionFlags(output_config_variable, true);\n\n\t\tif ((flags & GUC_RUNTIME_COMPUTED) == 0)\n\t\t{\n\t\t\t/*\n\t\t\t * \"-C guc\" was specified, so print GUC's value and exit.  No\n\t\t\t * extra permission check is needed because the user is reading\n\t\t\t * inside the data dir.\n\t\t\t */\n\t\t\tconst char *config_val = GetConfigOption(output_config_variable,\n\t\t\t\t\t\t\t\t\t\t\t\t\t false, false);\n\n\t\t\tputs(config_val ? config_val : \"\");\n\t\t\tExitPostmaster(0);\n\t\t}\n\t}\n\n\t/* Verify that DataDir looks reasonable */\n\tcheckDataDir();\n\n\t/* Check that pg_control exists */\n\tcheckControlFile();\n\n\t/* And switch working directory into it */\n\tChangeToDataDir();\n\n\t/*\n\t * Check for invalid combinations of GUC settings.\n\t */\n\tif (ReservedBackends >= MaxConnections)\n\t{\n\t\twrite_stderr(\"%s: superuser_reserved_connections (%d) must be less than max_connections (%d)\\n\",\n\t\t\t\t\t progname,\n\t\t\t\t\t ReservedBackends, MaxConnections);\n\t\tExitPostmaster(1);\n\t}\n\tif (XLogArchiveMode > ARCHIVE_MODE_OFF && wal_level == WAL_LEVEL_MINIMAL)\n\t\tereport(ERROR,\n\t\t\t\t(errmsg(\"WAL archival cannot be enabled when wal_level is \\\"minimal\\\"\")));\n\tif (max_wal_senders > 0 && wal_level == WAL_LEVEL_MINIMAL)\n\t\tereport(ERROR,\n\t\t\t\t(errmsg(\"WAL streaming (max_wal_senders > 0) requires wal_level \\\"replica\\\" or \\\"logical\\\"\")));\n\n\t/*\n\t * Other one-time internal sanity checks can go here, if they are fast.\n\t * (Put any slow processing further down, after postmaster.pid creation.)\n\t */\n\tif (!CheckDateTokenTables())\n\t{\n\t\twrite_stderr(\"%s: invalid datetoken tables, please fix\\n\", progname);\n\t\tExitPostmaster(1);\n\t}\n\n\t/*\n\t * Now that we are done processing the postmaster arguments, reset\n\t * getopt(3) library so that it will work correctly in subprocesses.\n\t */\n\toptind = 1;\n#ifdef HAVE_INT_OPTRESET\n\toptreset = 1;\t\t\t\t/* some systems need this too */\n#endif\n\n\t/* For debugging: display postmaster environment */\n\t{\n\t\textern char **environ;\n\t\tchar\t  **p;\n\n\t\tereport(DEBUG3,\n\t\t\t\t(errmsg_internal(\"%s: PostmasterMain: initial environment dump:\",\n\t\t\t\t\t\t\t\t progname)));\n\t\tereport(DEBUG3,\n\t\t\t\t(errmsg_internal(\"-----------------------------------------\")));\n\t\tfor (p = environ; *p; ++p)\n\t\t\tereport(DEBUG3,\n\t\t\t\t\t(errmsg_internal(\"\\t%s\", *p)));\n\t\tereport(DEBUG3,\n\t\t\t\t(errmsg_internal(\"-----------------------------------------\")));\n\t}\n\n\t/*\n\t * Create lockfile for data directory.\n\t *\n\t * We want to do this before we try to grab the input sockets, because the\n\t * data directory interlock is more reliable than the socket-file\n\t * interlock (thanks to whoever decided to put socket files in /tmp :-().\n\t * For the same reason, it's best to grab the TCP socket(s) before the\n\t * Unix socket(s).\n\t *\n\t * Also note that this internally sets up the on_proc_exit function that\n\t * is responsible for removing both data directory and socket lockfiles;\n\t * so it must happen before opening sockets so that at exit, the socket\n\t * lockfiles go away after CloseServerPorts runs.\n\t */\n\tCreateDataDirLockFile(true);\n\n\t/*\n\t * Read the control file (for error checking and config info).\n\t *\n\t * Since we verify the control file's CRC, this has a useful side effect\n\t * on machines where we need a run-time test for CRC support instructions.\n\t * The postmaster will do the test once at startup, and then its child\n\t * processes will inherit the correct function pointer and not need to\n\t * repeat the test.\n\t */\n\tLocalProcessControlFile(false);\n\n\t/*\n\t * Register the apply launcher.  Since it registers a background worker,\n\t * it needs to be called before InitializeMaxBackends(), and it's probably\n\t * a good idea to call it before any modules had chance to take the\n\t * background worker slots.\n\t */\n\tApplyLauncherRegister();\n\n\t/*\n\t * process any libraries that should be preloaded at postmaster start\n\t */\n\tprocess_shared_preload_libraries();\n\n\t/*\n\t * Initialize SSL library, if specified.\n\t */\n#ifdef USE_SSL\n\tif (EnableSSL)\n\t{\n\t\t(void) secure_initialize(true);\n\t\tLoadedSSL = true;\n\t}\n#endif\n\n\t/*\n\t * Now that loadable modules have had their chance to register background\n\t * workers, calculate MaxBackends.\n\t */\n\tInitializeMaxBackends();\n\n\t/*\n\t * Now that loadable modules have had their chance to request additional\n\t * shared memory, determine the value of any runtime-computed GUCs that\n\t * depend on the amount of shared memory required.\n\t */\n\tInitializeShmemGUCs();\n\n\t/*\n\t * If -C was specified with a runtime-computed GUC, we held off printing\n\t * the value earlier, as the GUC was not yet initialized.  We handle -C\n\t * for most GUCs before we lock the data directory so that the option may\n\t * be used on a running server.  However, a handful of GUCs are runtime-\n\t * computed and do not have meaningful values until after locking the data\n\t * directory, and we cannot safely calculate their values earlier on a\n\t * running server.  At this point, such GUCs should be properly\n\t * initialized, and we haven't yet set up shared memory, so this is a good\n\t * time to handle the -C option for these special GUCs.\n\t */\n\tif (output_config_variable != NULL)\n\t{\n\t\tconst char *config_val = GetConfigOption(output_config_variable,\n\t\t\t\t\t\t\t\t\t\t\t\t false, false);\n\n\t\tputs(config_val ? config_val : \"\");\n\t\tExitPostmaster(0);\n\t}\n\n\t/*\n\t * Set up shared memory and semaphores.\n\t */\n\treset_shared();\n\n\t/*\n\t * Estimate number of openable files.  This must happen after setting up\n\t * semaphores, because on some platforms semaphores count as open files.\n\t */\n\tset_max_safe_fds();\n\n\t/*\n\t * Set reference point for stack-depth checking.\n\t */\n\tset_stack_base();\n\n\t/*\n\t * Initialize pipe (or process handle on Windows) that allows children to\n\t * wake up from sleep on postmaster death.\n\t */\n\tInitPostmasterDeathWatchHandle();\n\n#ifdef WIN32\n\n\t/*\n\t * Initialize I/O completion port used to deliver list of dead children.\n\t */\n\twin32ChildQueue = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0, 1);\n\tif (win32ChildQueue == NULL)\n\t\tereport(FATAL,\n\t\t\t\t(errmsg(\"could not create I/O completion port for child queue\")));\n#endif\n\n#ifdef EXEC_BACKEND\n\t/* Write out nondefault GUC settings for child processes to use */\n\twrite_nondefault_variables(PGC_POSTMASTER);\n\n\t/*\n\t * Clean out the temp directory used to transmit parameters to child\n\t * processes (see internal_forkexec, below).  We must do this before\n\t * launching any child processes, else we have a race condition: we could\n\t * remove a parameter file before the child can read it.  It should be\n\t * safe to do so now, because we verified earlier that there are no\n\t * conflicting Postgres processes in this data directory.\n\t */\n\tRemovePgTempFilesInDir(PG_TEMP_FILES_DIR, true, false);\n#endif\n\n\t/*\n\t * Forcibly remove the files signaling a standby promotion request.\n\t * Otherwise, the existence of those files triggers a promotion too early,\n\t * whether a user wants that or not.\n\t *\n\t * This removal of files is usually unnecessary because they can exist\n\t * only during a few moments during a standby promotion. However there is\n\t * a race condition: if pg_ctl promote is executed and creates the files\n\t * during a promotion, the files can stay around even after the server is\n\t * brought up to be the primary.  Then, if a new standby starts by using\n\t * the backup taken from the new primary, the files can exist at server\n\t * startup and must be removed in order to avoid an unexpected promotion.\n\t *\n\t * Note that promotion signal files need to be removed before the startup\n\t * process is invoked. Because, after that, they can be used by\n\t * postmaster's SIGUSR1 signal handler.\n\t */\n\tRemovePromoteSignalFiles();\n\n\t/* Do the same for logrotate signal file */\n\tRemoveLogrotateSignalFiles();\n\n\t/* Remove any outdated file holding the current log filenames. */\n\tif (unlink(LOG_METAINFO_DATAFILE) < 0 && errno != ENOENT)\n\t\tereport(LOG,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not remove file \\\"%s\\\": %m\",\n\t\t\t\t\t\tLOG_METAINFO_DATAFILE)));\n\n\t/*\n\t * If enabled, start up syslogger collection subprocess\n\t */\n\tSysLoggerPID = SysLogger_Start();\n\n\t/*\n\t * Reset whereToSendOutput from DestDebug (its starting state) to\n\t * DestNone. This stops ereport from sending log messages to stderr unless\n\t * Log_destination permits.  We don't do this until the postmaster is\n\t * fully launched, since startup failures may as well be reported to\n\t * stderr.\n\t *\n\t * If we are in fact disabling logging to stderr, first emit a log message\n\t * saying so, to provide a breadcrumb trail for users who may not remember\n\t * that their logging is configured to go somewhere else.\n\t */\n\tif (!(Log_destination & LOG_DESTINATION_STDERR))\n\t\tereport(LOG,\n\t\t\t\t(errmsg(\"ending log output to stderr\"),\n\t\t\t\t errhint(\"Future log output will go to log destination \\\"%s\\\".\",\n\t\t\t\t\t\t Log_destination_string)));\n\n\twhereToSendOutput = DestNone;\n\n\t/*\n\t * Report server startup in log.  While we could emit this much earlier,\n\t * it seems best to do so after starting the log collector, if we intend\n\t * to use one.\n\t */\n\tereport(LOG,\n\t\t\t(errmsg(\"starting %s\", PG_VERSION_STR)));\n\n\t/*\n\t * Establish input sockets.\n\t *\n\t * First, mark them all closed, and set up an on_proc_exit function that's\n\t * charged with closing the sockets again at postmaster shutdown.\n\t */\n\tfor (i = 0; i < MAXLISTEN; i++)\n\t\tListenSocket[i] = PGINVALID_SOCKET;\n\n\ton_proc_exit(CloseServerPorts, 0);\n\n\tif (ListenAddresses)\n\t{\n\t\tchar\t   *rawstring;\n\t\tList\t   *elemlist;\n\t\tListCell   *l;\n\t\tint\t\t\tsuccess = 0;\n\n\t\t/* Need a modifiable copy of ListenAddresses */\n\t\trawstring = pstrdup(ListenAddresses);\n\n\t\t/* Parse string into list of hostnames */\n\t\tif (!SplitGUCList(rawstring, ',', &elemlist))\n\t\t{\n\t\t\t/* syntax error in list */\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"invalid list syntax in parameter \\\"%s\\\"\",\n\t\t\t\t\t\t\t\"listen_addresses\")));\n\t\t}\n\n\t\tforeach(l, elemlist)\n\t\t{\n\t\t\tchar\t   *curhost = (char *) lfirst(l);\n\n\t\t\tif (strcmp(curhost, \"*\") == 0)\n\t\t\t\tstatus = StreamServerPort(AF_UNSPEC, NULL,\n\t\t\t\t\t\t\t\t\t\t  (unsigned short) PostPortNumber,\n\t\t\t\t\t\t\t\t\t\t  NULL,\n\t\t\t\t\t\t\t\t\t\t  ListenSocket, MAXLISTEN);\n\t\t\telse\n\t\t\t\tstatus = StreamServerPort(AF_UNSPEC, curhost,\n\t\t\t\t\t\t\t\t\t\t  (unsigned short) PostPortNumber,\n\t\t\t\t\t\t\t\t\t\t  NULL,\n\t\t\t\t\t\t\t\t\t\t  ListenSocket, MAXLISTEN);\n\n\t\t\tif (status == STATUS_OK)\n\t\t\t{\n\t\t\t\tsuccess++;\n\t\t\t\t/* record the first successful host addr in lockfile */\n\t\t\t\tif (!listen_addr_saved)\n\t\t\t\t{\n\t\t\t\t\tAddToDataDirLockFile(LOCK_FILE_LINE_LISTEN_ADDR, curhost);\n\t\t\t\t\tlisten_addr_saved = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\tereport(WARNING,\n\t\t\t\t\t\t(errmsg(\"could not create listen socket for \\\"%s\\\"\",\n\t\t\t\t\t\t\t\tcurhost)));\n\t\t}\n\n\t\tif (!success && elemlist != NIL)\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errmsg(\"could not create any TCP/IP sockets\")));\n\n\t\tlist_free(elemlist);\n\t\tpfree(rawstring);\n\t}\n\n#ifdef USE_BONJOUR\n\t/* Register for Bonjour only if we opened TCP socket(s) */\n\tif (enable_bonjour && ListenSocket[0] != PGINVALID_SOCKET)\n\t{\n\t\tDNSServiceErrorType err;\n\n\t\t/*\n\t\t * We pass 0 for interface_index, which will result in registering on\n\t\t * all \"applicable\" interfaces.  It's not entirely clear from the\n\t\t * DNS-SD docs whether this would be appropriate if we have bound to\n\t\t * just a subset of the available network interfaces.\n\t\t */\n\t\terr = DNSServiceRegister(&bonjour_sdref,\n\t\t\t\t\t\t\t\t 0,\n\t\t\t\t\t\t\t\t 0,\n\t\t\t\t\t\t\t\t bonjour_name,\n\t\t\t\t\t\t\t\t \"_postgresql._tcp.\",\n\t\t\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t\t\t pg_hton16(PostPortNumber),\n\t\t\t\t\t\t\t\t 0,\n\t\t\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t\t\t NULL);\n\t\tif (err != kDNSServiceErr_NoError)\n\t\t\tereport(LOG,\n\t\t\t\t\t(errmsg(\"DNSServiceRegister() failed: error code %ld\",\n\t\t\t\t\t\t\t(long) err)));\n\n\t\t/*\n\t\t * We don't bother to read the mDNS daemon's reply, and we expect that\n\t\t * it will automatically terminate our registration when the socket is\n\t\t * closed at postmaster termination.  So there's nothing more to be\n\t\t * done here.  However, the bonjour_sdref is kept around so that\n\t\t * forked children can close their copies of the socket.\n\t\t */\n\t}\n#endif\n\n#ifdef HAVE_UNIX_SOCKETS\n\tif (Unix_socket_directories)\n\t{\n\t\tchar\t   *rawstring;\n\t\tList\t   *elemlist;\n\t\tListCell   *l;\n\t\tint\t\t\tsuccess = 0;\n\n\t\t/* Need a modifiable copy of Unix_socket_directories */\n\t\trawstring = pstrdup(Unix_socket_directories);\n\n\t\t/* Parse string into list of directories */\n\t\tif (!SplitDirectoriesString(rawstring, ',', &elemlist))\n\t\t{\n\t\t\t/* syntax error in list */\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"invalid list syntax in parameter \\\"%s\\\"\",\n\t\t\t\t\t\t\t\"unix_socket_directories\")));\n\t\t}\n\n\t\tforeach(l, elemlist)\n\t\t{\n\t\t\tchar\t   *socketdir = (char *) lfirst(l);\n\n\t\t\tstatus = StreamServerPort(AF_UNIX, NULL,\n\t\t\t\t\t\t\t\t\t  (unsigned short) PostPortNumber,\n\t\t\t\t\t\t\t\t\t  socketdir,\n\t\t\t\t\t\t\t\t\t  ListenSocket, MAXLISTEN);\n\n\t\t\tif (status == STATUS_OK)\n\t\t\t{\n\t\t\t\tsuccess++;\n\t\t\t\t/* record the first successful Unix socket in lockfile */\n\t\t\t\tif (success == 1)\n\t\t\t\t\tAddToDataDirLockFile(LOCK_FILE_LINE_SOCKET_DIR, socketdir);\n\t\t\t}\n\t\t\telse\n\t\t\t\tereport(WARNING,\n\t\t\t\t\t\t(errmsg(\"could not create Unix-domain socket in directory \\\"%s\\\"\",\n\t\t\t\t\t\t\t\tsocketdir)));\n\t\t}\n\n\t\tif (!success && elemlist != NIL)\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errmsg(\"could not create any Unix-domain sockets\")));\n\n\t\tlist_free_deep(elemlist);\n\t\tpfree(rawstring);\n\t}\n#endif\n\n\t/*\n\t * check that we have some socket to listen on\n\t */\n\tif (ListenSocket[0] == PGINVALID_SOCKET)\n\t\tereport(FATAL,\n\t\t\t\t(errmsg(\"no socket created for listening\")));\n\n\t/*\n\t * If no valid TCP ports, write an empty line for listen address,\n\t * indicating the Unix socket must be used.  Note that this line is not\n\t * added to the lock file until there is a socket backing it.\n\t */\n\tif (!listen_addr_saved)\n\t\tAddToDataDirLockFile(LOCK_FILE_LINE_LISTEN_ADDR, \"\");\n\n\t/*\n\t * Record postmaster options.  We delay this till now to avoid recording\n\t * bogus options (eg, unusable port number).\n\t */\n\tif (!CreateOptsFile(argc, argv, my_exec_path))\n\t\tExitPostmaster(1);\n\n\t/*\n\t * Write the external PID file if requested\n\t */\n\tif (external_pid_file)\n\t{\n\t\tFILE\t   *fpidfile = fopen(external_pid_file, \"w\");\n\n\t\tif (fpidfile)\n\t\t{\n\t\t\tfprintf(fpidfile, \"%d\\n\", MyProcPid);\n\t\t\tfclose(fpidfile);\n\n\t\t\t/* Make PID file world readable */\n\t\t\tif (chmod(external_pid_file, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH) != 0)\n\t\t\t\twrite_stderr(\"%s: could not change permissions of external PID file \\\"%s\\\": %s\\n\",\n\t\t\t\t\t\t\t progname, external_pid_file, strerror(errno));\n\t\t}\n\t\telse\n\t\t\twrite_stderr(\"%s: could not write external PID file \\\"%s\\\": %s\\n\",\n\t\t\t\t\t\t progname, external_pid_file, strerror(errno));\n\n\t\ton_proc_exit(unlink_external_pid_file, 0);\n\t}\n\n\t/*\n\t * Remove old temporary files.  At this point there can be no other\n\t * Postgres processes running in this directory, so this should be safe.\n\t */\n\tRemovePgTempFiles();\n\n\t/*\n\t * Initialize stats collection subsystem (this does NOT start the\n\t * collector process!)\n\t */\n\tpgstat_init();\n\n\t/*\n\t * Initialize the autovacuum subsystem (again, no process start yet)\n\t */\n\tautovac_init();\n\n\t/*\n\t * Load configuration files for client authentication.\n\t */\n\tif (!load_hba())\n\t{\n\t\t/*\n\t\t * It makes no sense to continue if we fail to load the HBA file,\n\t\t * since there is no way to connect to the database in this case.\n\t\t */\n\t\tereport(FATAL,\n\t\t\t\t(errmsg(\"could not load pg_hba.conf\")));\n\t}\n\tif (!load_ident())\n\t{\n\t\t/*\n\t\t * We can start up without the IDENT file, although it means that you\n\t\t * cannot log in using any of the authentication methods that need a\n\t\t * user name mapping. load_ident() already logged the details of error\n\t\t * to the log.\n\t\t */\n\t}\n\n#ifdef HAVE_PTHREAD_IS_THREADED_NP\n\n\t/*\n\t * On macOS, libintl replaces setlocale() with a version that calls\n\t * CFLocaleCopyCurrent() when its second argument is \"\" and every relevant\n\t * environment variable is unset or empty.  CFLocaleCopyCurrent() makes\n\t * the process multithreaded.  The postmaster calls sigprocmask() and\n\t * calls fork() without an immediate exec(), both of which have undefined\n\t * behavior in a multithreaded program.  A multithreaded postmaster is the\n\t * normal case on Windows, which offers neither fork() nor sigprocmask().\n\t */\n\tif (pthread_is_threaded_np() != 0)\n\t\tereport(FATAL,\n\t\t\t\t(errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),\n\t\t\t\t errmsg(\"postmaster became multithreaded during startup\"),\n\t\t\t\t errhint(\"Set the LC_ALL environment variable to a valid locale.\")));\n#endif\n\n\t/*\n\t * Remember postmaster startup time\n\t */\n\tPgStartTime = GetCurrentTimestamp();\n\n\t/*\n\t * Report postmaster status in the postmaster.pid file, to allow pg_ctl to\n\t * see what's happening.\n\t */\n\tAddToDataDirLockFile(LOCK_FILE_LINE_PM_STATUS, PM_STATUS_STARTING);\n\n\t/* Start bgwriter and checkpointer so they can help with recovery */\n\tif (CheckpointerPID == 0)\n\t\tCheckpointerPID = StartCheckpointer();\n\tif (BgWriterPID == 0)\n\t\tBgWriterPID = StartBackgroundWriter();\n\n\t/*\n\t * We're ready to rock and roll...\n\t */\n\tStartupPID = StartupDataBase();\n\tAssert(StartupPID != 0);\n\tStartupStatus = STARTUP_RUNNING;\n\tpmState = PM_STARTUP;\n\n\t/* Some workers may be scheduled to start now */\n\tmaybe_start_bgworkers();\n\n\tstatus = ServerLoop();\n\n\t/*\n\t * ServerLoop probably shouldn't ever return, but if it does, close down.\n\t */\n\tExitPostmaster(status != STATUS_OK);\n\n\tabort();\t\t\t\t\t/* not reached */\n}\n\n\n/*\n * on_proc_exit callback to close server's listen sockets\n */\nstatic void\nCloseServerPorts(int status, Datum arg)\n{\n\tint\t\t\ti;\n\n\t/*\n\t * First, explicitly close all the socket FDs.  We used to just let this\n\t * happen implicitly at postmaster exit, but it's better to close them\n\t * before we remove the postmaster.pid lockfile; otherwise there's a race\n\t * condition if a new postmaster wants to re-use the TCP port number.\n\t */\n\tfor (i = 0; i < MAXLISTEN; i++)\n\t{\n\t\tif (ListenSocket[i] != PGINVALID_SOCKET)\n\t\t{\n\t\t\tStreamClose(ListenSocket[i]);\n\t\t\tListenSocket[i] = PGINVALID_SOCKET;\n\t\t}\n\t}\n\n\t/*\n\t * Next, remove any filesystem entries for Unix sockets.  To avoid race\n\t * conditions against incoming postmasters, this must happen after closing\n\t * the sockets and before removing lock files.\n\t */\n\tRemoveSocketFiles();\n\n\t/*\n\t * We don't do anything about socket lock files here; those will be\n\t * removed in a later on_proc_exit callback.\n\t */\n}\n\n/*\n * on_proc_exit callback to delete external_pid_file\n */\nstatic void\nunlink_external_pid_file(int status, Datum arg)\n{\n\tif (external_pid_file)\n\t\tunlink(external_pid_file);\n}\n\n\n/*\n * Compute and check the directory paths to files that are part of the\n * installation (as deduced from the postgres executable's own location)\n */\nstatic void\ngetInstallationPaths(const char *argv0)\n{\n\tDIR\t\t   *pdir;\n\n\t/* Locate the postgres executable itself */\n\tif (find_my_exec(argv0, my_exec_path) < 0)\n\t\tereport(FATAL,\n\t\t\t\t(errmsg(\"%s: could not locate my own executable path\", argv0)));\n\n#ifdef EXEC_BACKEND\n\t/* Locate executable backend before we change working directory */\n\tif (find_other_exec(argv0, \"postgres\", PG_BACKEND_VERSIONSTR,\n\t\t\t\t\t\tpostgres_exec_path) < 0)\n\t\tereport(FATAL,\n\t\t\t\t(errmsg(\"%s: could not locate matching postgres executable\",\n\t\t\t\t\t\targv0)));\n#endif\n\n\t/*\n\t * Locate the pkglib directory --- this has to be set early in case we try\n\t * to load any modules from it in response to postgresql.conf entries.\n\t */\n\tget_pkglib_path(my_exec_path, pkglib_path);\n\n\t/*\n\t * Verify that there's a readable directory there; otherwise the Postgres\n\t * installation is incomplete or corrupt.  (A typical cause of this\n\t * failure is that the postgres executable has been moved or hardlinked to\n\t * some directory that's not a sibling of the installation lib/\n\t * directory.)\n\t */\n\tpdir = AllocateDir(pkglib_path);\n\tif (pdir == NULL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not open directory \\\"%s\\\": %m\",\n\t\t\t\t\t\tpkglib_path),\n\t\t\t\t errhint(\"This may indicate an incomplete PostgreSQL installation, or that the file \\\"%s\\\" has been moved away from its proper location.\",\n\t\t\t\t\t\t my_exec_path)));\n\tFreeDir(pdir);\n\n\t/*\n\t * XXX is it worth similarly checking the share/ directory?  If the lib/\n\t * directory is there, then share/ probably is too.\n\t */\n}\n\n/*\n * Check that pg_control exists in the correct location in the data directory.\n *\n * No attempt is made to validate the contents of pg_control here.  This is\n * just a sanity check to see if we are looking at a real data directory.\n */\nstatic void\ncheckControlFile(void)\n{\n\tchar\t\tpath[MAXPGPATH];\n\tFILE\t   *fp;\n\n\tsnprintf(path, sizeof(path), \"%s/global/pg_control\", DataDir);\n\n\tfp = AllocateFile(path, PG_BINARY_R);\n\tif (fp == NULL)\n\t{\n\t\twrite_stderr(\"%s: could not find the database system\\n\"\n\t\t\t\t\t \"Expected to find it in the directory \\\"%s\\\",\\n\"\n\t\t\t\t\t \"but could not open file \\\"%s\\\": %s\\n\",\n\t\t\t\t\t progname, DataDir, path, strerror(errno));\n\t\tExitPostmaster(2);\n\t}\n\tFreeFile(fp);\n}\n\n/*\n * Determine how long should we let ServerLoop sleep.\n *\n * In normal conditions we wait at most one minute, to ensure that the other\n * background tasks handled by ServerLoop get done even when no requests are\n * arriving.  However, if there are background workers waiting to be started,\n * we don't actually sleep so that they are quickly serviced.  Other exception\n * cases are as shown in the code.\n */\nstatic void\nDetermineSleepTime(struct timeval *timeout)\n{\n\tTimestampTz next_wakeup = 0;\n\n\t/*\n\t * Normal case: either there are no background workers at all, or we're in\n\t * a shutdown sequence (during which we ignore bgworkers altogether).\n\t */\n\tif (Shutdown > NoShutdown ||\n\t\t(!StartWorkerNeeded && !HaveCrashedWorker))\n\t{\n\t\tif (AbortStartTime != 0)\n\t\t{\n\t\t\t/* time left to abort; clamp to 0 in case it already expired */\n\t\t\ttimeout->tv_sec = SIGKILL_CHILDREN_AFTER_SECS -\n\t\t\t\t(time(NULL) - AbortStartTime);\n\t\t\ttimeout->tv_sec = Max(timeout->tv_sec, 0);\n\t\t\ttimeout->tv_usec = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttimeout->tv_sec = 60;\n\t\t\ttimeout->tv_usec = 0;\n\t\t}\n\t\treturn;\n\t}\n\n\tif (StartWorkerNeeded)\n\t{\n\t\ttimeout->tv_sec = 0;\n\t\ttimeout->tv_usec = 0;\n\t\treturn;\n\t}\n\n\tif (HaveCrashedWorker)\n\t{\n\t\tslist_mutable_iter siter;\n\n\t\t/*\n\t\t * When there are crashed bgworkers, we sleep just long enough that\n\t\t * they are restarted when they request to be.  Scan the list to\n\t\t * determine the minimum of all wakeup times according to most recent\n\t\t * crash time and requested restart interval.\n\t\t */\n\t\tslist_foreach_modify(siter, &BackgroundWorkerList)\n\t\t{\n\t\t\tRegisteredBgWorker *rw;\n\t\t\tTimestampTz this_wakeup;\n\n\t\t\trw = slist_container(RegisteredBgWorker, rw_lnode, siter.cur);\n\n\t\t\tif (rw->rw_crashed_at == 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (rw->rw_worker.bgw_restart_time == BGW_NEVER_RESTART\n\t\t\t\t|| rw->rw_terminate)\n\t\t\t{\n\t\t\t\tForgetBackgroundWorker(&siter);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthis_wakeup = TimestampTzPlusMilliseconds(rw->rw_crashed_at,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  1000L * rw->rw_worker.bgw_restart_time);\n\t\t\tif (next_wakeup == 0 || this_wakeup < next_wakeup)\n\t\t\t\tnext_wakeup = this_wakeup;\n\t\t}\n\t}\n\n\tif (next_wakeup != 0)\n\t{\n\t\tlong\t\tsecs;\n\t\tint\t\t\tmicrosecs;\n\n\t\tTimestampDifference(GetCurrentTimestamp(), next_wakeup,\n\t\t\t\t\t\t\t&secs, &microsecs);\n\t\ttimeout->tv_sec = secs;\n\t\ttimeout->tv_usec = microsecs;\n\n\t\t/* Ensure we don't exceed one minute */\n\t\tif (timeout->tv_sec > 60)\n\t\t{\n\t\t\ttimeout->tv_sec = 60;\n\t\t\ttimeout->tv_usec = 0;\n\t\t}\n\t}\n\telse\n\t{\n\t\ttimeout->tv_sec = 60;\n\t\ttimeout->tv_usec = 0;\n\t}\n}\n\n/*\n * Main idle loop of postmaster\n *\n * NB: Needs to be called with signals blocked\n */\nstatic int\nServerLoop(void)\n{\n\tfd_set\t\treadmask;\n\tint\t\t\tnSockets;\n\ttime_t\t\tlast_lockfile_recheck_time,\n\t\t\t\tlast_touch_time;\n\n\tlast_lockfile_recheck_time = last_touch_time = time(NULL);\n\n\tnSockets = initMasks(&readmask);\n\n\tfor (;;)\n\t{\n\t\tfd_set\t\trmask;\n\t\tint\t\t\tselres;\n\t\ttime_t\t\tnow;\n\n\t\t/*\n\t\t * Wait for a connection request to arrive.\n\t\t *\n\t\t * We block all signals except while sleeping. That makes it safe for\n\t\t * signal handlers, which again block all signals while executing, to\n\t\t * do nontrivial work.\n\t\t *\n\t\t * If we are in PM_WAIT_DEAD_END state, then we don't want to accept\n\t\t * any new connections, so we don't call select(), and just sleep.\n\t\t */\n\t\tmemcpy((char *) &rmask, (char *) &readmask, sizeof(fd_set));\n\n\t\tif (pmState == PM_WAIT_DEAD_END)\n\t\t{\n\t\t\tPG_SETMASK(&UnBlockSig);\n\n\t\t\tpg_usleep(100000L); /* 100 msec seems reasonable */\n\t\t\tselres = 0;\n\n\t\t\tPG_SETMASK(&BlockSig);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* must set timeout each time; some OSes change it! */\n\t\t\tstruct timeval timeout;\n\n\t\t\t/* Needs to run with blocked signals! */\n\t\t\tDetermineSleepTime(&timeout);\n\n\t\t\tPG_SETMASK(&UnBlockSig);\n\n\t\t\tselres = select(nSockets, &rmask, NULL, NULL, &timeout);\n\n\t\t\tPG_SETMASK(&BlockSig);\n\t\t}\n\n\t\t/* Now check the select() result */\n\t\tif (selres < 0)\n\t\t{\n\t\t\tif (errno != EINTR && errno != EWOULDBLOCK)\n\t\t\t{\n\t\t\t\tereport(LOG,\n\t\t\t\t\t\t(errcode_for_socket_access(),\n\t\t\t\t\t\t errmsg(\"select() failed in postmaster: %m\")));\n\t\t\t\treturn STATUS_ERROR;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * New connection pending on any of our sockets? If so, fork a child\n\t\t * process to deal with it.\n\t\t */\n\t\tif (selres > 0)\n\t\t{\n\t\t\tint\t\t\ti;\n\n\t\t\tfor (i = 0; i < MAXLISTEN; i++)\n\t\t\t{\n\t\t\t\tif (ListenSocket[i] == PGINVALID_SOCKET)\n\t\t\t\t\tbreak;\n\t\t\t\tif (FD_ISSET(ListenSocket[i], &rmask))\n\t\t\t\t{\n\t\t\t\t\tPort\t   *port;\n\n\t\t\t\t\tport = ConnCreate(ListenSocket[i]);\n\t\t\t\t\tif (port)\n\t\t\t\t\t{\n\t\t\t\t\t\tBackendStartup(port);\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * We no longer need the open socket or port structure\n\t\t\t\t\t\t * in this process\n\t\t\t\t\t\t */\n\t\t\t\t\t\tStreamClose(port->sock);\n\t\t\t\t\t\tConnFree(port);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* If we have lost the log collector, try to start a new one */\n\t\tif (SysLoggerPID == 0 && Logging_collector)\n\t\t\tSysLoggerPID = SysLogger_Start();\n\n\t\t/*\n\t\t * If no background writer process is running, and we are not in a\n\t\t * state that prevents it, start one.  It doesn't matter if this\n\t\t * fails, we'll just try again later.  Likewise for the checkpointer.\n\t\t */\n\t\tif (pmState == PM_RUN || pmState == PM_RECOVERY ||\n\t\t\tpmState == PM_HOT_STANDBY || pmState == PM_STARTUP)\n\t\t{\n\t\t\tif (CheckpointerPID == 0)\n\t\t\t\tCheckpointerPID = StartCheckpointer();\n\t\t\tif (BgWriterPID == 0)\n\t\t\t\tBgWriterPID = StartBackgroundWriter();\n\t\t}\n\n\t\t/*\n\t\t * Likewise, if we have lost the walwriter process, try to start a new\n\t\t * one.  But this is needed only in normal operation (else we cannot\n\t\t * be writing any new WAL).\n\t\t */\n\t\tif (WalWriterPID == 0 && pmState == PM_RUN)\n\t\t\tWalWriterPID = StartWalWriter();\n\n\t\t/*\n\t\t * If we have lost the autovacuum launcher, try to start a new one. We\n\t\t * don't want autovacuum to run in binary upgrade mode because\n\t\t * autovacuum might update relfrozenxid for empty tables before the\n\t\t * physical files are put in place.\n\t\t */\n\t\tif (!IsBinaryUpgrade && AutoVacPID == 0 &&\n\t\t\t(AutoVacuumingActive() || start_autovac_launcher) &&\n\t\t\tpmState == PM_RUN)\n\t\t{\n\t\t\tAutoVacPID = StartAutoVacLauncher();\n\t\t\tif (AutoVacPID != 0)\n\t\t\t\tstart_autovac_launcher = false; /* signal processed */\n\t\t}\n\n\t\t/* If we have lost the stats collector, try to start a new one */\n\t\tif (PgStatPID == 0 &&\n\t\t\t(pmState == PM_RUN || pmState == PM_HOT_STANDBY))\n\t\t\tPgStatPID = pgstat_start();\n\n\t\t/* If we have lost the archiver, try to start a new one. */\n\t\tif (PgArchPID == 0 && PgArchStartupAllowed())\n\t\t\tPgArchPID = StartArchiver();\n\n\t\t/* If we need to signal the autovacuum launcher, do so now */\n\t\tif (avlauncher_needs_signal)\n\t\t{\n\t\t\tavlauncher_needs_signal = false;\n\t\t\tif (AutoVacPID != 0)\n\t\t\t\tkill(AutoVacPID, SIGUSR2);\n\t\t}\n\n\t\t/* If we need to start a WAL receiver, try to do that now */\n\t\tif (WalReceiverRequested)\n\t\t\tMaybeStartWalReceiver();\n\n\t\t/* Get other worker processes running, if needed */\n\t\tif (StartWorkerNeeded || HaveCrashedWorker)\n\t\t\tmaybe_start_bgworkers();\n\n#ifdef HAVE_PTHREAD_IS_THREADED_NP\n\n\t\t/*\n\t\t * With assertions enabled, check regularly for appearance of\n\t\t * additional threads.  All builds check at start and exit.\n\t\t */\n\t\tAssert(pthread_is_threaded_np() == 0);\n#endif\n\n\t\t/*\n\t\t * Lastly, check to see if it's time to do some things that we don't\n\t\t * want to do every single time through the loop, because they're a\n\t\t * bit expensive.  Note that there's up to a minute of slop in when\n\t\t * these tasks will be performed, since DetermineSleepTime() will let\n\t\t * us sleep at most that long; except for SIGKILL timeout which has\n\t\t * special-case logic there.\n\t\t */\n\t\tnow = time(NULL);\n\n\t\t/*\n\t\t * If we already sent SIGQUIT to children and they are slow to shut\n\t\t * down, it's time to send them SIGKILL.  This doesn't happen\n\t\t * normally, but under certain conditions backends can get stuck while\n\t\t * shutting down.  This is a last measure to get them unwedged.\n\t\t *\n\t\t * Note we also do this during recovery from a process crash.\n\t\t */\n\t\tif ((Shutdown >= ImmediateShutdown || (FatalError && !SendStop)) &&\n\t\t\tAbortStartTime != 0 &&\n\t\t\t(now - AbortStartTime) >= SIGKILL_CHILDREN_AFTER_SECS)\n\t\t{\n\t\t\t/* We were gentle with them before. Not anymore */\n\t\t\tereport(LOG,\n\t\t\t\t\t(errmsg(\"issuing SIGKILL to recalcitrant children\")));\n\t\t\tTerminateChildren(SIGKILL);\n\t\t\t/* reset flag so we don't SIGKILL again */\n\t\t\tAbortStartTime = 0;\n\t\t}\n\n\t\t/*\n\t\t * Once a minute, verify that postmaster.pid hasn't been removed or\n\t\t * overwritten.  If it has, we force a shutdown.  This avoids having\n\t\t * postmasters and child processes hanging around after their database\n\t\t * is gone, and maybe causing problems if a new database cluster is\n\t\t * created in the same place.  It also provides some protection\n\t\t * against a DBA foolishly removing postmaster.pid and manually\n\t\t * starting a new postmaster.  Data corruption is likely to ensue from\n\t\t * that anyway, but we can minimize the damage by aborting ASAP.\n\t\t */\n\t\tif (now - last_lockfile_recheck_time >= 1 * SECS_PER_MINUTE)\n\t\t{\n\t\t\tif (!RecheckDataDirLockFile())\n\t\t\t{\n\t\t\t\tereport(LOG,\n\t\t\t\t\t\t(errmsg(\"performing immediate shutdown because data directory lock file is invalid\")));\n\t\t\t\tkill(MyProcPid, SIGQUIT);\n\t\t\t}\n\t\t\tlast_lockfile_recheck_time = now;\n\t\t}\n\n\t\t/*\n\t\t * Touch Unix socket and lock files every 58 minutes, to ensure that\n\t\t * they are not removed by overzealous /tmp-cleaning tasks.  We assume\n\t\t * no one runs cleaners with cutoff times of less than an hour ...\n\t\t */\n\t\tif (now - last_touch_time >= 58 * SECS_PER_MINUTE)\n\t\t{\n\t\t\tTouchSocketFiles();\n\t\t\tTouchSocketLockFiles();\n\t\t\tlast_touch_time = now;\n\t\t}\n\t}\n}\n\n/*\n * Initialise the masks for select() for the ports we are listening on.\n * Return the number of sockets to listen on.\n */\nstatic int\ninitMasks(fd_set *rmask)\n{\n\tint\t\t\tmaxsock = -1;\n\tint\t\t\ti;\n\n\tFD_ZERO(rmask);\n\n\tfor (i = 0; i < MAXLISTEN; i++)\n\t{\n\t\tint\t\t\tfd = ListenSocket[i];\n\n\t\tif (fd == PGINVALID_SOCKET)\n\t\t\tbreak;\n\t\tFD_SET(fd, rmask);\n\n\t\tif (fd > maxsock)\n\t\t\tmaxsock = fd;\n\t}\n\n\treturn maxsock + 1;\n}\n\n\n/*\n * Read a client's startup packet and do something according to it.\n *\n * Returns STATUS_OK or STATUS_ERROR, or might call ereport(FATAL) and\n * not return at all.\n *\n * (Note that ereport(FATAL) stuff is sent to the client, so only use it\n * if that's what you want.  Return STATUS_ERROR if you don't want to\n * send anything to the client, which would typically be appropriate\n * if we detect a communications failure.)\n *\n * Set ssl_done and/or gss_done when negotiation of an encrypted layer\n * (currently, TLS or GSSAPI) is completed. A successful negotiation of either\n * encryption layer sets both flags, but a rejected negotiation sets only the\n * flag for that layer, since the client may wish to try the other one. We\n * should make no assumption here about the order in which the client may make\n * requests.\n */\nstatic int\nProcessStartupPacket(Port *port, bool ssl_done, bool gss_done)\n{\n\tint32\t\tlen;\n\tchar\t   *buf;\n\tProtocolVersion proto;\n\tMemoryContext oldcontext;\n\n\tpq_startmsgread();\n\n\t/*\n\t * Grab the first byte of the length word separately, so that we can tell\n\t * whether we have no data at all or an incomplete packet.  (This might\n\t * sound inefficient, but it's not really, because of buffering in\n\t * pqcomm.c.)\n\t */\n\tif (pq_getbytes((char *) &len, 1) == EOF)\n\t{\n\t\t/*\n\t\t * If we get no data at all, don't clutter the log with a complaint;\n\t\t * such cases often occur for legitimate reasons.  An example is that\n\t\t * we might be here after responding to NEGOTIATE_SSL_CODE, and if the\n\t\t * client didn't like our response, it'll probably just drop the\n\t\t * connection.  Service-monitoring software also often just opens and\n\t\t * closes a connection without sending anything.  (So do port\n\t\t * scanners, which may be less benign, but it's not really our job to\n\t\t * notice those.)\n\t\t */\n\t\treturn STATUS_ERROR;\n\t}\n\n\tif (pq_getbytes(((char *) &len) + 1, 3) == EOF)\n\t{\n\t\t/* Got a partial length word, so bleat about that */\n\t\tif (!ssl_done && !gss_done)\n\t\t\tereport(COMMERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROTOCOL_VIOLATION),\n\t\t\t\t\t errmsg(\"incomplete startup packet\")));\n\t\treturn STATUS_ERROR;\n\t}\n\n\tlen = pg_ntoh32(len);\n\tlen -= 4;\n\n\tif (len < (int32) sizeof(ProtocolVersion) ||\n\t\tlen > MAX_STARTUP_PACKET_LENGTH)\n\t{\n\t\tereport(COMMERROR,\n\t\t\t\t(errcode(ERRCODE_PROTOCOL_VIOLATION),\n\t\t\t\t errmsg(\"invalid length of startup packet\")));\n\t\treturn STATUS_ERROR;\n\t}\n\n\t/*\n\t * Allocate space to hold the startup packet, plus one extra byte that's\n\t * initialized to be zero.  This ensures we will have null termination of\n\t * all strings inside the packet.\n\t */\n\tbuf = palloc(len + 1);\n\tbuf[len] = '\\0';\n\n\tif (pq_getbytes(buf, len) == EOF)\n\t{\n\t\tereport(COMMERROR,\n\t\t\t\t(errcode(ERRCODE_PROTOCOL_VIOLATION),\n\t\t\t\t errmsg(\"incomplete startup packet\")));\n\t\treturn STATUS_ERROR;\n\t}\n\tpq_endmsgread();\n\n\t/*\n\t * The first field is either a protocol version number or a special\n\t * request code.\n\t */\n\tport->proto = proto = pg_ntoh32(*((ProtocolVersion *) buf));\n\n\tif (proto == CANCEL_REQUEST_CODE)\n\t{\n\t\tprocessCancelRequest(port, buf);\n\t\t/* Not really an error, but we don't want to proceed further */\n\t\treturn STATUS_ERROR;\n\t}\n\n\tif (proto == NEGOTIATE_SSL_CODE && !ssl_done)\n\t{\n\t\tchar\t\tSSLok;\n\n#ifdef USE_SSL\n\t\t/* No SSL when disabled or on Unix sockets */\n\t\tif (!LoadedSSL || IS_AF_UNIX(port->laddr.addr.ss_family))\n\t\t\tSSLok = 'N';\n\t\telse\n\t\t\tSSLok = 'S';\t\t/* Support for SSL */\n#else\n\t\tSSLok = 'N';\t\t\t/* No support for SSL */\n#endif\n\nretry1:\n\t\tif (send(port->sock, &SSLok, 1, 0) != 1)\n\t\t{\n\t\t\tif (errno == EINTR)\n\t\t\t\tgoto retry1;\t/* if interrupted, just retry */\n\t\t\tereport(COMMERROR,\n\t\t\t\t\t(errcode_for_socket_access(),\n\t\t\t\t\t errmsg(\"failed to send SSL negotiation response: %m\")));\n\t\t\treturn STATUS_ERROR;\t/* close the connection */\n\t\t}\n\n#ifdef USE_SSL\n\t\tif (SSLok == 'S' && secure_open_server(port) == -1)\n\t\t\treturn STATUS_ERROR;\n#endif\n\n\t\t/*\n\t\t * At this point we should have no data already buffered.  If we do,\n\t\t * it was received before we performed the SSL handshake, so it wasn't\n\t\t * encrypted and indeed may have been injected by a man-in-the-middle.\n\t\t * We report this case to the client.\n\t\t */\n\t\tif (pq_buffer_has_data())\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_PROTOCOL_VIOLATION),\n\t\t\t\t\t errmsg(\"received unencrypted data after SSL request\"),\n\t\t\t\t\t errdetail(\"This could be either a client-software bug or evidence of an attempted man-in-the-middle attack.\")));\n\n\t\t/*\n\t\t * regular startup packet, cancel, etc packet should follow, but not\n\t\t * another SSL negotiation request, and a GSS request should only\n\t\t * follow if SSL was rejected (client may negotiate in either order)\n\t\t */\n\t\treturn ProcessStartupPacket(port, true, SSLok == 'S');\n\t}\n\telse if (proto == NEGOTIATE_GSS_CODE && !gss_done)\n\t{\n\t\tchar\t\tGSSok = 'N';\n\n#ifdef ENABLE_GSS\n\t\t/* No GSSAPI encryption when on Unix socket */\n\t\tif (!IS_AF_UNIX(port->laddr.addr.ss_family))\n\t\t\tGSSok = 'G';\n#endif\n\n\t\twhile (send(port->sock, &GSSok, 1, 0) != 1)\n\t\t{\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tereport(COMMERROR,\n\t\t\t\t\t(errcode_for_socket_access(),\n\t\t\t\t\t errmsg(\"failed to send GSSAPI negotiation response: %m\")));\n\t\t\treturn STATUS_ERROR;\t/* close the connection */\n\t\t}\n\n#ifdef ENABLE_GSS\n\t\tif (GSSok == 'G' && secure_open_gssapi(port) == -1)\n\t\t\treturn STATUS_ERROR;\n#endif\n\n\t\t/*\n\t\t * At this point we should have no data already buffered.  If we do,\n\t\t * it was received before we performed the GSS handshake, so it wasn't\n\t\t * encrypted and indeed may have been injected by a man-in-the-middle.\n\t\t * We report this case to the client.\n\t\t */\n\t\tif (pq_buffer_has_data())\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_PROTOCOL_VIOLATION),\n\t\t\t\t\t errmsg(\"received unencrypted data after GSSAPI encryption request\"),\n\t\t\t\t\t errdetail(\"This could be either a client-software bug or evidence of an attempted man-in-the-middle attack.\")));\n\n\t\t/*\n\t\t * regular startup packet, cancel, etc packet should follow, but not\n\t\t * another GSS negotiation request, and an SSL request should only\n\t\t * follow if GSS was rejected (client may negotiate in either order)\n\t\t */\n\t\treturn ProcessStartupPacket(port, GSSok == 'G', true);\n\t}\n\n\t/* Could add additional special packet types here */\n\n\t/*\n\t * Set FrontendProtocol now so that ereport() knows what format to send if\n\t * we fail during startup.\n\t */\n\tFrontendProtocol = proto;\n\n\t/* Check that the major protocol version is in range. */\n\tif (PG_PROTOCOL_MAJOR(proto) < PG_PROTOCOL_MAJOR(PG_PROTOCOL_EARLIEST) ||\n\t\tPG_PROTOCOL_MAJOR(proto) > PG_PROTOCOL_MAJOR(PG_PROTOCOL_LATEST))\n\t\tereport(FATAL,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"unsupported frontend protocol %u.%u: server supports %u.0 to %u.%u\",\n\t\t\t\t\t\tPG_PROTOCOL_MAJOR(proto), PG_PROTOCOL_MINOR(proto),\n\t\t\t\t\t\tPG_PROTOCOL_MAJOR(PG_PROTOCOL_EARLIEST),\n\t\t\t\t\t\tPG_PROTOCOL_MAJOR(PG_PROTOCOL_LATEST),\n\t\t\t\t\t\tPG_PROTOCOL_MINOR(PG_PROTOCOL_LATEST))));\n\n\t/*\n\t * Now fetch parameters out of startup packet and save them into the Port\n\t * structure.  All data structures attached to the Port struct must be\n\t * allocated in TopMemoryContext so that they will remain available in a\n\t * running backend (even after PostmasterContext is destroyed).  We need\n\t * not worry about leaking this storage on failure, since we aren't in the\n\t * postmaster process anymore.\n\t */\n\toldcontext = MemoryContextSwitchTo(TopMemoryContext);\n\n\t/* Handle protocol version 3 startup packet */\n\t{\n\t\tint32\t\toffset = sizeof(ProtocolVersion);\n\t\tList\t   *unrecognized_protocol_options = NIL;\n\n\t\t/*\n\t\t * Scan packet body for name/option pairs.  We can assume any string\n\t\t * beginning within the packet body is null-terminated, thanks to\n\t\t * zeroing extra byte above.\n\t\t */\n\t\tport->guc_options = NIL;\n\n\t\twhile (offset < len)\n\t\t{\n\t\t\tchar\t   *nameptr = buf + offset;\n\t\t\tint32\t\tvaloffset;\n\t\t\tchar\t   *valptr;\n\n\t\t\tif (*nameptr == '\\0')\n\t\t\t\tbreak;\t\t\t/* found packet terminator */\n\t\t\tvaloffset = offset + strlen(nameptr) + 1;\n\t\t\tif (valoffset >= len)\n\t\t\t\tbreak;\t\t\t/* missing value, will complain below */\n\t\t\tvalptr = buf + valoffset;\n\n\t\t\tif (strcmp(nameptr, \"database\") == 0)\n\t\t\t\tport->database_name = pstrdup(valptr);\n\t\t\telse if (strcmp(nameptr, \"user\") == 0)\n\t\t\t\tport->user_name = pstrdup(valptr);\n\t\t\telse if (strcmp(nameptr, \"options\") == 0)\n\t\t\t\tport->cmdline_options = pstrdup(valptr);\n\t\t\telse if (strcmp(nameptr, \"replication\") == 0)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Due to backward compatibility concerns the replication\n\t\t\t\t * parameter is a hybrid beast which allows the value to be\n\t\t\t\t * either boolean or the string 'database'. The latter\n\t\t\t\t * connects to a specific database which is e.g. required for\n\t\t\t\t * logical decoding while.\n\t\t\t\t */\n\t\t\t\tif (strcmp(valptr, \"database\") == 0)\n\t\t\t\t{\n\t\t\t\t\tam_walsender = true;\n\t\t\t\t\tam_db_walsender = true;\n\t\t\t\t}\n\t\t\t\telse if (!parse_bool(valptr, &am_walsender))\n\t\t\t\t\tereport(FATAL,\n\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t\t errmsg(\"invalid value for parameter \\\"%s\\\": \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t\t\"replication\",\n\t\t\t\t\t\t\t\t\tvalptr),\n\t\t\t\t\t\t\t errhint(\"Valid values are: \\\"false\\\", 0, \\\"true\\\", 1, \\\"database\\\".\")));\n\t\t\t}\n\t\t\telse if (strncmp(nameptr, \"_pq_.\", 5) == 0)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Any option beginning with _pq_. is reserved for use as a\n\t\t\t\t * protocol-level option, but at present no such options are\n\t\t\t\t * defined.\n\t\t\t\t */\n\t\t\t\tunrecognized_protocol_options =\n\t\t\t\t\tlappend(unrecognized_protocol_options, pstrdup(nameptr));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Assume it's a generic GUC option */\n\t\t\t\tport->guc_options = lappend(port->guc_options,\n\t\t\t\t\t\t\t\t\t\t\tpstrdup(nameptr));\n\t\t\t\tport->guc_options = lappend(port->guc_options,\n\t\t\t\t\t\t\t\t\t\t\tpstrdup(valptr));\n\n\t\t\t\t/*\n\t\t\t\t * Copy application_name to port if we come across it.  This\n\t\t\t\t * is done so we can log the application_name in the\n\t\t\t\t * connection authorization message.  Note that the GUC would\n\t\t\t\t * be used but we haven't gone through GUC setup yet.\n\t\t\t\t */\n\t\t\t\tif (strcmp(nameptr, \"application_name\") == 0)\n\t\t\t\t{\n\t\t\t\t\tchar\t   *tmp_app_name = pstrdup(valptr);\n\n\t\t\t\t\tpg_clean_ascii(tmp_app_name);\n\n\t\t\t\t\tport->application_name = tmp_app_name;\n\t\t\t\t}\n\t\t\t}\n\t\t\toffset = valoffset + strlen(valptr) + 1;\n\t\t}\n\n\t\t/*\n\t\t * If we didn't find a packet terminator exactly at the end of the\n\t\t * given packet length, complain.\n\t\t */\n\t\tif (offset != len - 1)\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_PROTOCOL_VIOLATION),\n\t\t\t\t\t errmsg(\"invalid startup packet layout: expected terminator as last byte\")));\n\n\t\t/*\n\t\t * If the client requested a newer protocol version or if the client\n\t\t * requested any protocol options we didn't recognize, let them know\n\t\t * the newest minor protocol version we do support and the names of\n\t\t * any unrecognized options.\n\t\t */\n\t\tif (PG_PROTOCOL_MINOR(proto) > PG_PROTOCOL_MINOR(PG_PROTOCOL_LATEST) ||\n\t\t\tunrecognized_protocol_options != NIL)\n\t\t\tSendNegotiateProtocolVersion(unrecognized_protocol_options);\n\t}\n\n\t/* Check a user name was given. */\n\tif (port->user_name == NULL || port->user_name[0] == '\\0')\n\t\tereport(FATAL,\n\t\t\t\t(errcode(ERRCODE_INVALID_AUTHORIZATION_SPECIFICATION),\n\t\t\t\t errmsg(\"no PostgreSQL user name specified in startup packet\")));\n\n\t/* The database defaults to the user name. */\n\tif (port->database_name == NULL || port->database_name[0] == '\\0')\n\t\tport->database_name = pstrdup(port->user_name);\n\n\tif (Db_user_namespace)\n\t{\n\t\t/*\n\t\t * If user@, it is a global user, remove '@'. We only want to do this\n\t\t * if there is an '@' at the end and no earlier in the user string or\n\t\t * they may fake as a local user of another database attaching to this\n\t\t * database.\n\t\t */\n\t\tif (strchr(port->user_name, '@') ==\n\t\t\tport->user_name + strlen(port->user_name) - 1)\n\t\t\t*strchr(port->user_name, '@') = '\\0';\n\t\telse\n\t\t{\n\t\t\t/* Append '@' and dbname */\n\t\t\tport->user_name = psprintf(\"%s@%s\", port->user_name, port->database_name);\n\t\t}\n\t}\n\n\t/*\n\t * Truncate given database and user names to length of a Postgres name.\n\t * This avoids lookup failures when overlength names are given.\n\t */\n\tif (strlen(port->database_name) >= NAMEDATALEN)\n\t\tport->database_name[NAMEDATALEN - 1] = '\\0';\n\tif (strlen(port->user_name) >= NAMEDATALEN)\n\t\tport->user_name[NAMEDATALEN - 1] = '\\0';\n\n\tif (am_walsender)\n\t\tMyBackendType = B_WAL_SENDER;\n\telse\n\t\tMyBackendType = B_BACKEND;\n\n\t/*\n\t * Normal walsender backends, e.g. for streaming replication, are not\n\t * connected to a particular database. But walsenders used for logical\n\t * replication need to connect to a specific database. We allow streaming\n\t * replication commands to be issued even if connected to a database as it\n\t * can make sense to first make a basebackup and then stream changes\n\t * starting from that.\n\t */\n\tif (am_walsender && !am_db_walsender)\n\t\tport->database_name[0] = '\\0';\n\n\t/*\n\t * Done putting stuff in TopMemoryContext.\n\t */\n\tMemoryContextSwitchTo(oldcontext);\n\n\t/*\n\t * If we're going to reject the connection due to database state, say so\n\t * now instead of wasting cycles on an authentication exchange. (This also\n\t * allows a pg_ping utility to be written.)\n\t */\n\tswitch (port->canAcceptConnections)\n\t{\n\t\tcase CAC_STARTUP:\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_CANNOT_CONNECT_NOW),\n\t\t\t\t\t errmsg(\"the database system is starting up\")));\n\t\t\tbreak;\n\t\tcase CAC_NOTCONSISTENT:\n\t\t\tif (EnableHotStandby)\n\t\t\t\tereport(FATAL,\n\t\t\t\t\t\t(errcode(ERRCODE_CANNOT_CONNECT_NOW),\n\t\t\t\t\t\t errmsg(\"the database system is not yet accepting connections\"),\n\t\t\t\t\t\t errdetail(\"Consistent recovery state has not been yet reached.\")));\n\t\t\telse\n\t\t\t\tereport(FATAL,\n\t\t\t\t\t\t(errcode(ERRCODE_CANNOT_CONNECT_NOW),\n\t\t\t\t\t\t errmsg(\"the database system is not accepting connections\"),\n\t\t\t\t\t\t errdetail(\"Hot standby mode is disabled.\")));\n\t\t\tbreak;\n\t\tcase CAC_SHUTDOWN:\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_CANNOT_CONNECT_NOW),\n\t\t\t\t\t errmsg(\"the database system is shutting down\")));\n\t\t\tbreak;\n\t\tcase CAC_RECOVERY:\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_CANNOT_CONNECT_NOW),\n\t\t\t\t\t errmsg(\"the database system is in recovery mode\")));\n\t\t\tbreak;\n\t\tcase CAC_TOOMANY:\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_TOO_MANY_CONNECTIONS),\n\t\t\t\t\t errmsg(\"sorry, too many clients already\")));\n\t\t\tbreak;\n\t\tcase CAC_SUPERUSER:\n\t\t\t/* OK for now, will check in InitPostgres */\n\t\t\tbreak;\n\t\tcase CAC_OK:\n\t\t\tbreak;\n\t}\n\n\treturn STATUS_OK;\n}\n\n/*\n * Send a NegotiateProtocolVersion to the client.  This lets the client know\n * that they have requested a newer minor protocol version than we are able\n * to speak.  We'll speak the highest version we know about; the client can,\n * of course, abandon the connection if that's a problem.\n *\n * We also include in the response a list of protocol options we didn't\n * understand.  This allows clients to include optional parameters that might\n * be present either in newer protocol versions or third-party protocol\n * extensions without fear of having to reconnect if those options are not\n * understood, while at the same time making certain that the client is aware\n * of which options were actually accepted.\n */\nstatic void\nSendNegotiateProtocolVersion(List *unrecognized_protocol_options)\n{\n\tStringInfoData buf;\n\tListCell   *lc;\n\n\tpq_beginmessage(&buf, 'v'); /* NegotiateProtocolVersion */\n\tpq_sendint32(&buf, PG_PROTOCOL_LATEST);\n\tpq_sendint32(&buf, list_length(unrecognized_protocol_options));\n\tforeach(lc, unrecognized_protocol_options)\n\t\tpq_sendstring(&buf, lfirst(lc));\n\tpq_endmessage(&buf);\n\n\t/* no need to flush, some other message will follow */\n}\n\n/*\n * The client has sent a cancel request packet, not a normal\n * start-a-new-connection packet.  Perform the necessary processing.\n * Nothing is sent back to the client.\n */\nstatic void\nprocessCancelRequest(Port *port, void *pkt)\n{\n\tCancelRequestPacket *canc = (CancelRequestPacket *) pkt;\n\tint\t\t\tbackendPID;\n\tint32\t\tcancelAuthCode;\n\tBackend    *bp;\n\n#ifndef EXEC_BACKEND\n\tdlist_iter\titer;\n#else\n\tint\t\t\ti;\n#endif\n\n\tbackendPID = (int) pg_ntoh32(canc->backendPID);\n\tcancelAuthCode = (int32) pg_ntoh32(canc->cancelAuthCode);\n\n\t/*\n\t * See if we have a matching backend.  In the EXEC_BACKEND case, we can no\n\t * longer access the postmaster's own backend list, and must rely on the\n\t * duplicate array in shared memory.\n\t */\n#ifndef EXEC_BACKEND\n\tdlist_foreach(iter, &BackendList)\n\t{\n\t\tbp = dlist_container(Backend, elem, iter.cur);\n#else\n\tfor (i = MaxLivePostmasterChildren() - 1; i >= 0; i--)\n\t{\n\t\tbp = (Backend *) &ShmemBackendArray[i];\n#endif\n\t\tif (bp->pid == backendPID)\n\t\t{\n\t\t\tif (bp->cancel_key == cancelAuthCode)\n\t\t\t{\n\t\t\t\t/* Found a match; signal that backend to cancel current op */\n\t\t\t\tereport(DEBUG2,\n\t\t\t\t\t\t(errmsg_internal(\"processing cancel request: sending SIGINT to process %d\",\n\t\t\t\t\t\t\t\t\t\t backendPID)));\n\t\t\t\tsignal_child(bp->pid, SIGINT);\n\t\t\t}\n\t\t\telse\n\t\t\t\t/* Right PID, wrong key: no way, Jose */\n\t\t\t\tereport(LOG,\n\t\t\t\t\t\t(errmsg(\"wrong key in cancel request for process %d\",\n\t\t\t\t\t\t\t\tbackendPID)));\n\t\t\treturn;\n\t\t}\n#ifndef EXEC_BACKEND\t\t\t/* make GNU Emacs 26.1 see brace balance */\n\t}\n#else\n\t}\n#endif\n\n\t/* No matching backend */\n\tereport(LOG,\n\t\t\t(errmsg(\"PID %d in cancel request did not match any process\",\n\t\t\t\t\tbackendPID)));\n}\n\n/*\n * canAcceptConnections --- check to see if database state allows connections\n * of the specified type.  backend_type can be BACKEND_TYPE_NORMAL,\n * BACKEND_TYPE_AUTOVAC, or BACKEND_TYPE_BGWORKER.  (Note that we don't yet\n * know whether a NORMAL connection might turn into a walsender.)\n */\nstatic CAC_state\ncanAcceptConnections(int backend_type)\n{\n\tCAC_state\tresult = CAC_OK;\n\n\t/*\n\t * Can't start backends when in startup/shutdown/inconsistent recovery\n\t * state.  We treat autovac workers the same as user backends for this\n\t * purpose.  However, bgworkers are excluded from this test; we expect\n\t * bgworker_should_start_now() decided whether the DB state allows them.\n\t */\n\tif (pmState != PM_RUN && pmState != PM_HOT_STANDBY &&\n\t\tbackend_type != BACKEND_TYPE_BGWORKER)\n\t{\n\t\tif (Shutdown > NoShutdown)\n\t\t\treturn CAC_SHUTDOWN;\t/* shutdown is pending */\n\t\telse if (!FatalError && pmState == PM_STARTUP)\n\t\t\treturn CAC_STARTUP; /* normal startup */\n\t\telse if (!FatalError && pmState == PM_RECOVERY)\n\t\t\treturn CAC_NOTCONSISTENT;\t/* not yet at consistent recovery\n\t\t\t\t\t\t\t\t\t\t * state */\n\t\telse\n\t\t\treturn CAC_RECOVERY;\t/* else must be crash recovery */\n\t}\n\n\t/*\n\t * \"Smart shutdown\" restrictions are applied only to normal connections,\n\t * not to autovac workers or bgworkers.  When only superusers can connect,\n\t * we return CAC_SUPERUSER to indicate that superuserness must be checked\n\t * later.  Note that neither CAC_OK nor CAC_SUPERUSER can safely be\n\t * returned until we have checked for too many children.\n\t */\n\tif (connsAllowed != ALLOW_ALL_CONNS &&\n\t\tbackend_type == BACKEND_TYPE_NORMAL)\n\t{\n\t\tif (connsAllowed == ALLOW_SUPERUSER_CONNS)\n\t\t\tresult = CAC_SUPERUSER; /* allow superusers only */\n\t\telse\n\t\t\treturn CAC_SHUTDOWN;\t/* shutdown is pending */\n\t}\n\n\t/*\n\t * Don't start too many children.\n\t *\n\t * We allow more connections here than we can have backends because some\n\t * might still be authenticating; they might fail auth, or some existing\n\t * backend might exit before the auth cycle is completed.  The exact\n\t * MaxBackends limit is enforced when a new backend tries to join the\n\t * shared-inval backend array.\n\t *\n\t * The limit here must match the sizes of the per-child-process arrays;\n\t * see comments for MaxLivePostmasterChildren().\n\t */\n\tif (CountChildren(BACKEND_TYPE_ALL) >= MaxLivePostmasterChildren())\n\t\tresult = CAC_TOOMANY;\n\n\treturn result;\n}\n\n\n/*\n * ConnCreate -- create a local connection data structure\n *\n * Returns NULL on failure, other than out-of-memory which is fatal.\n */\nstatic Port *\nConnCreate(int serverFd)\n{\n\tPort\t   *port;\n\n\tif (!(port = (Port *) calloc(1, sizeof(Port))))\n\t{\n\t\tereport(LOG,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\")));\n\t\tExitPostmaster(1);\n\t}\n\n\tif (StreamConnection(serverFd, port) != STATUS_OK)\n\t{\n\t\tif (port->sock != PGINVALID_SOCKET)\n\t\t\tStreamClose(port->sock);\n\t\tConnFree(port);\n\t\treturn NULL;\n\t}\n\n\treturn port;\n}\n\n\n/*\n * ConnFree -- free a local connection data structure\n *\n * Caller has already closed the socket if any, so there's not much\n * to do here.\n */\nstatic void\nConnFree(Port *conn)\n{\n\tfree(conn);\n}\n\n\n/*\n * ClosePostmasterPorts -- close all the postmaster's open sockets\n *\n * This is called during child process startup to release file descriptors\n * that are not needed by that child process.  The postmaster still has\n * them open, of course.\n *\n * Note: we pass am_syslogger as a boolean because we don't want to set\n * the global variable yet when this is called.\n */\nvoid\nClosePostmasterPorts(bool am_syslogger)\n{\n\tint\t\t\ti;\n\n#ifndef WIN32\n\n\t/*\n\t * Close the write end of postmaster death watch pipe. It's important to\n\t * do this as early as possible, so that if postmaster dies, others won't\n\t * think that it's still running because we're holding the pipe open.\n\t */\n\tif (close(postmaster_alive_fds[POSTMASTER_FD_OWN]) != 0)\n\t\tereport(FATAL,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg_internal(\"could not close postmaster death monitoring pipe in child process: %m\")));\n\tpostmaster_alive_fds[POSTMASTER_FD_OWN] = -1;\n\t/* Notify fd.c that we released one pipe FD. */\n\tReleaseExternalFD();\n#endif\n\n\t/*\n\t * Close the postmaster's listen sockets.  These aren't tracked by fd.c,\n\t * so we don't call ReleaseExternalFD() here.\n\t */\n\tfor (i = 0; i < MAXLISTEN; i++)\n\t{\n\t\tif (ListenSocket[i] != PGINVALID_SOCKET)\n\t\t{\n\t\t\tStreamClose(ListenSocket[i]);\n\t\t\tListenSocket[i] = PGINVALID_SOCKET;\n\t\t}\n\t}\n\n\t/*\n\t * If using syslogger, close the read side of the pipe.  We don't bother\n\t * tracking this in fd.c, either.\n\t */\n\tif (!am_syslogger)\n\t{\n#ifndef WIN32\n\t\tif (syslogPipe[0] >= 0)\n\t\t\tclose(syslogPipe[0]);\n\t\tsyslogPipe[0] = -1;\n#else\n\t\tif (syslogPipe[0])\n\t\t\tCloseHandle(syslogPipe[0]);\n\t\tsyslogPipe[0] = 0;\n#endif\n\t}\n\n#ifdef USE_BONJOUR\n\t/* If using Bonjour, close the connection to the mDNS daemon */\n\tif (bonjour_sdref)\n\t\tclose(DNSServiceRefSockFD(bonjour_sdref));\n#endif\n}\n\n\n/*\n * InitProcessGlobals -- set MyProcPid, MyStartTime[stamp], random seeds\n *\n * Called early in the postmaster and every backend.\n */\nvoid\nInitProcessGlobals(void)\n{\n\tunsigned int rseed;\n\n\tMyProcPid = getpid();\n\tMyStartTimestamp = GetCurrentTimestamp();\n\tMyStartTime = timestamptz_to_time_t(MyStartTimestamp);\n\n\t/*\n\t * Set a different seed for random() in every process.  We want something\n\t * unpredictable, so if possible, use high-quality random bits for the\n\t * seed.  Otherwise, fall back to a seed based on timestamp and PID.\n\t */\n\tif (!pg_strong_random(&rseed, sizeof(rseed)))\n\t{\n\t\t/*\n\t\t * Since PIDs and timestamps tend to change more frequently in their\n\t\t * least significant bits, shift the timestamp left to allow a larger\n\t\t * total number of seeds in a given time period.  Since that would\n\t\t * leave only 20 bits of the timestamp that cycle every ~1 second,\n\t\t * also mix in some higher bits.\n\t\t */\n\t\trseed = ((uint64) MyProcPid) ^\n\t\t\t((uint64) MyStartTimestamp << 12) ^\n\t\t\t((uint64) MyStartTimestamp >> 20);\n\t}\n\tsrandom(rseed);\n}\n\n\n/*\n * reset_shared -- reset shared memory and semaphores\n */\nstatic void\nreset_shared(void)\n{\n\t/*\n\t * Create or re-create shared memory and semaphores.\n\t *\n\t * Note: in each \"cycle of life\" we will normally assign the same IPC keys\n\t * (if using SysV shmem and/or semas).  This helps ensure that we will\n\t * clean up dead IPC objects if the postmaster crashes and is restarted.\n\t */\n\tCreateSharedMemoryAndSemaphores();\n}\n\n\n/*\n * SIGHUP -- reread config files, and tell children to do same\n */\nstatic void\nSIGHUP_handler(SIGNAL_ARGS)\n{\n\tint\t\t\tsave_errno = errno;\n\n\t/*\n\t * We rely on the signal mechanism to have blocked all signals ... except\n\t * on Windows, which lacks sigaction(), so we have to do it manually.\n\t */\n#ifdef WIN32\n\tPG_SETMASK(&BlockSig);\n#endif\n\n\tif (Shutdown <= SmartShutdown)\n\t{\n\t\tereport(LOG,\n\t\t\t\t(errmsg(\"received SIGHUP, reloading configuration files\")));\n\t\tProcessConfigFile(PGC_SIGHUP);\n\t\tSignalChildren(SIGHUP);\n\t\tif (StartupPID != 0)\n\t\t\tsignal_child(StartupPID, SIGHUP);\n\t\tif (BgWriterPID != 0)\n\t\t\tsignal_child(BgWriterPID, SIGHUP);\n\t\tif (CheckpointerPID != 0)\n\t\t\tsignal_child(CheckpointerPID, SIGHUP);\n\t\tif (WalWriterPID != 0)\n\t\t\tsignal_child(WalWriterPID, SIGHUP);\n\t\tif (WalReceiverPID != 0)\n\t\t\tsignal_child(WalReceiverPID, SIGHUP);\n\t\tif (AutoVacPID != 0)\n\t\t\tsignal_child(AutoVacPID, SIGHUP);\n\t\tif (PgArchPID != 0)\n\t\t\tsignal_child(PgArchPID, SIGHUP);\n\t\tif (SysLoggerPID != 0)\n\t\t\tsignal_child(SysLoggerPID, SIGHUP);\n\t\tif (PgStatPID != 0)\n\t\t\tsignal_child(PgStatPID, SIGHUP);\n\n\t\t/* Reload authentication config files too */\n\t\tif (!load_hba())\n\t\t\tereport(LOG,\n\t\t\t/* translator: %s is a configuration file */\n\t\t\t\t\t(errmsg(\"%s was not reloaded\", \"pg_hba.conf\")));\n\n\t\tif (!load_ident())\n\t\t\tereport(LOG,\n\t\t\t\t\t(errmsg(\"%s was not reloaded\", \"pg_ident.conf\")));\n\n#ifdef USE_SSL\n\t\t/* Reload SSL configuration as well */\n\t\tif (EnableSSL)\n\t\t{\n\t\t\tif (secure_initialize(false) == 0)\n\t\t\t\tLoadedSSL = true;\n\t\t\telse\n\t\t\t\tereport(LOG,\n\t\t\t\t\t\t(errmsg(\"SSL configuration was not reloaded\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsecure_destroy();\n\t\t\tLoadedSSL = false;\n\t\t}\n#endif\n\n#ifdef EXEC_BACKEND\n\t\t/* Update the starting-point file for future children */\n\t\twrite_nondefault_variables(PGC_SIGHUP);\n#endif\n\t}\n\n#ifdef WIN32\n\tPG_SETMASK(&UnBlockSig);\n#endif\n\n\terrno = save_errno;\n}\n\n\n/*\n * pmdie -- signal handler for processing various postmaster signals.\n */\nstatic void\npmdie(SIGNAL_ARGS)\n{\n\tint\t\t\tsave_errno = errno;\n\n\t/*\n\t * We rely on the signal mechanism to have blocked all signals ... except\n\t * on Windows, which lacks sigaction(), so we have to do it manually.\n\t */\n#ifdef WIN32\n\tPG_SETMASK(&BlockSig);\n#endif\n\n\tereport(DEBUG2,\n\t\t\t(errmsg_internal(\"postmaster received signal %d\",\n\t\t\t\t\t\t\t postgres_signal_arg)));\n\n\tswitch (postgres_signal_arg)\n\t{\n\t\tcase SIGTERM:\n\n\t\t\t/*\n\t\t\t * Smart Shutdown:\n\t\t\t *\n\t\t\t * Wait for children to end their work, then shut down.\n\t\t\t */\n\t\t\tif (Shutdown >= SmartShutdown)\n\t\t\t\tbreak;\n\t\t\tShutdown = SmartShutdown;\n\t\t\tereport(LOG,\n\t\t\t\t\t(errmsg(\"received smart shutdown request\")));\n\n\t\t\t/* Report status */\n\t\t\tAddToDataDirLockFile(LOCK_FILE_LINE_PM_STATUS, PM_STATUS_STOPPING);\n#ifdef USE_SYSTEMD\n\t\t\tsd_notify(0, \"STOPPING=1\");\n#endif\n\n\t\t\t/*\n\t\t\t * If we reached normal running, we have to wait for any online\n\t\t\t * backup mode to end; otherwise go straight to waiting for client\n\t\t\t * backends to exit.  (The difference is that in the former state,\n\t\t\t * we'll still let in new superuser clients, so that somebody can\n\t\t\t * end the online backup mode.)  If already in PM_STOP_BACKENDS or\n\t\t\t * a later state, do not change it.\n\t\t\t */\n\t\t\tif (pmState == PM_RUN)\n\t\t\t\tconnsAllowed = ALLOW_SUPERUSER_CONNS;\n\t\t\telse if (pmState == PM_HOT_STANDBY)\n\t\t\t\tconnsAllowed = ALLOW_NO_CONNS;\n\t\t\telse if (pmState == PM_STARTUP || pmState == PM_RECOVERY)\n\t\t\t{\n\t\t\t\t/* There should be no clients, so proceed to stop children */\n\t\t\t\tpmState = PM_STOP_BACKENDS;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Now wait for online backup mode to end and backends to exit. If\n\t\t\t * that is already the case, PostmasterStateMachine will take the\n\t\t\t * next step.\n\t\t\t */\n\t\t\tPostmasterStateMachine();\n\t\t\tbreak;\n\n\t\tcase SIGINT:\n\n\t\t\t/*\n\t\t\t * Fast Shutdown:\n\t\t\t *\n\t\t\t * Abort all children with SIGTERM (rollback active transactions\n\t\t\t * and exit) and shut down when they are gone.\n\t\t\t */\n\t\t\tif (Shutdown >= FastShutdown)\n\t\t\t\tbreak;\n\t\t\tShutdown = FastShutdown;\n\t\t\tereport(LOG,\n\t\t\t\t\t(errmsg(\"received fast shutdown request\")));\n\n\t\t\t/* Report status */\n\t\t\tAddToDataDirLockFile(LOCK_FILE_LINE_PM_STATUS, PM_STATUS_STOPPING);\n#ifdef USE_SYSTEMD\n\t\t\tsd_notify(0, \"STOPPING=1\");\n#endif\n\n\t\t\tif (pmState == PM_STARTUP || pmState == PM_RECOVERY)\n\t\t\t{\n\t\t\t\t/* Just shut down background processes silently */\n\t\t\t\tpmState = PM_STOP_BACKENDS;\n\t\t\t}\n\t\t\telse if (pmState == PM_RUN ||\n\t\t\t\t\t pmState == PM_HOT_STANDBY)\n\t\t\t{\n\t\t\t\t/* Report that we're about to zap live client sessions */\n\t\t\t\tereport(LOG,\n\t\t\t\t\t\t(errmsg(\"aborting any active transactions\")));\n\t\t\t\tpmState = PM_STOP_BACKENDS;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * PostmasterStateMachine will issue any necessary signals, or\n\t\t\t * take the next step if no child processes need to be killed.\n\t\t\t */\n\t\t\tPostmasterStateMachine();\n\t\t\tbreak;\n\n\t\tcase SIGQUIT:\n\n\t\t\t/*\n\t\t\t * Immediate Shutdown:\n\t\t\t *\n\t\t\t * abort all children with SIGQUIT, wait for them to exit,\n\t\t\t * terminate remaining ones with SIGKILL, then exit without\n\t\t\t * attempt to properly shut down the data base system.\n\t\t\t */\n\t\t\tif (Shutdown >= ImmediateShutdown)\n\t\t\t\tbreak;\n\t\t\tShutdown = ImmediateShutdown;\n\t\t\tereport(LOG,\n\t\t\t\t\t(errmsg(\"received immediate shutdown request\")));\n\n\t\t\t/* Report status */\n\t\t\tAddToDataDirLockFile(LOCK_FILE_LINE_PM_STATUS, PM_STATUS_STOPPING);\n#ifdef USE_SYSTEMD\n\t\t\tsd_notify(0, \"STOPPING=1\");\n#endif\n\n\t\t\t/* tell children to shut down ASAP */\n\t\t\tSetQuitSignalReason(PMQUIT_FOR_STOP);\n\t\t\tTerminateChildren(SIGQUIT);\n\t\t\tpmState = PM_WAIT_BACKENDS;\n\n\t\t\t/* set stopwatch for them to die */\n\t\t\tAbortStartTime = time(NULL);\n\n\t\t\t/*\n\t\t\t * Now wait for backends to exit.  If there are none,\n\t\t\t * PostmasterStateMachine will take the next step.\n\t\t\t */\n\t\t\tPostmasterStateMachine();\n\t\t\tbreak;\n\t}\n\n#ifdef WIN32\n\tPG_SETMASK(&UnBlockSig);\n#endif\n\n\terrno = save_errno;\n}\n\n/*\n * Reaper -- signal handler to cleanup after a child process dies.\n */\nstatic void\nreaper(SIGNAL_ARGS)\n{\n\tint\t\t\tsave_errno = errno;\n\tint\t\t\tpid;\t\t\t/* process id of dead child process */\n\tint\t\t\texitstatus;\t\t/* its exit status */\n\n\t/*\n\t * We rely on the signal mechanism to have blocked all signals ... except\n\t * on Windows, which lacks sigaction(), so we have to do it manually.\n\t */\n#ifdef WIN32\n\tPG_SETMASK(&BlockSig);\n#endif\n\n\tereport(DEBUG4,\n\t\t\t(errmsg_internal(\"reaping dead processes\")));\n\n\twhile ((pid = waitpid(-1, &exitstatus, WNOHANG)) > 0)\n\t{\n\t\t/*\n\t\t * Check if this child was a startup process.\n\t\t */\n\t\tif (pid == StartupPID)\n\t\t{\n\t\t\tStartupPID = 0;\n\n\t\t\t/*\n\t\t\t * Startup process exited in response to a shutdown request (or it\n\t\t\t * completed normally regardless of the shutdown request).\n\t\t\t */\n\t\t\tif (Shutdown > NoShutdown &&\n\t\t\t\t(EXIT_STATUS_0(exitstatus) || EXIT_STATUS_1(exitstatus)))\n\t\t\t{\n\t\t\t\tStartupStatus = STARTUP_NOT_RUNNING;\n\t\t\t\tpmState = PM_WAIT_BACKENDS;\n\t\t\t\t/* PostmasterStateMachine logic does the rest */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (EXIT_STATUS_3(exitstatus))\n\t\t\t{\n\t\t\t\tereport(LOG,\n\t\t\t\t\t\t(errmsg(\"shutdown at recovery target\")));\n\t\t\t\tStartupStatus = STARTUP_NOT_RUNNING;\n\t\t\t\tShutdown = Max(Shutdown, SmartShutdown);\n\t\t\t\tTerminateChildren(SIGTERM);\n\t\t\t\tpmState = PM_WAIT_BACKENDS;\n\t\t\t\t/* PostmasterStateMachine logic does the rest */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Unexpected exit of startup process (including FATAL exit)\n\t\t\t * during PM_STARTUP is treated as catastrophic. There are no\n\t\t\t * other processes running yet, so we can just exit.\n\t\t\t */\n\t\t\tif (pmState == PM_STARTUP &&\n\t\t\t\tStartupStatus != STARTUP_SIGNALED &&\n\t\t\t\t!EXIT_STATUS_0(exitstatus))\n\t\t\t{\n\t\t\t\tLogChildExit(LOG, _(\"startup process\"),\n\t\t\t\t\t\t\t pid, exitstatus);\n\t\t\t\tereport(LOG,\n\t\t\t\t\t\t(errmsg(\"aborting startup due to startup process failure\")));\n\t\t\t\tExitPostmaster(1);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * After PM_STARTUP, any unexpected exit (including FATAL exit) of\n\t\t\t * the startup process is catastrophic, so kill other children,\n\t\t\t * and set StartupStatus so we don't try to reinitialize after\n\t\t\t * they're gone.  Exception: if StartupStatus is STARTUP_SIGNALED,\n\t\t\t * then we previously sent the startup process a SIGQUIT; so\n\t\t\t * that's probably the reason it died, and we do want to try to\n\t\t\t * restart in that case.\n\t\t\t *\n\t\t\t * This stanza also handles the case where we sent a SIGQUIT\n\t\t\t * during PM_STARTUP due to some dead_end child crashing: in that\n\t\t\t * situation, if the startup process dies on the SIGQUIT, we need\n\t\t\t * to transition to PM_WAIT_BACKENDS state which will allow\n\t\t\t * PostmasterStateMachine to restart the startup process.  (On the\n\t\t\t * other hand, the startup process might complete normally, if we\n\t\t\t * were too late with the SIGQUIT.  In that case we'll fall\n\t\t\t * through and commence normal operations.)\n\t\t\t */\n\t\t\tif (!EXIT_STATUS_0(exitstatus))\n\t\t\t{\n\t\t\t\tif (StartupStatus == STARTUP_SIGNALED)\n\t\t\t\t{\n\t\t\t\t\tStartupStatus = STARTUP_NOT_RUNNING;\n\t\t\t\t\tif (pmState == PM_STARTUP)\n\t\t\t\t\t\tpmState = PM_WAIT_BACKENDS;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tStartupStatus = STARTUP_CRASHED;\n\t\t\t\tHandleChildCrash(pid, exitstatus,\n\t\t\t\t\t\t\t\t _(\"startup process\"));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Startup succeeded, commence normal operations\n\t\t\t */\n\t\t\tStartupStatus = STARTUP_NOT_RUNNING;\n\t\t\tFatalError = false;\n\t\t\tAbortStartTime = 0;\n\t\t\tReachedNormalRunning = true;\n\t\t\tpmState = PM_RUN;\n\t\t\tconnsAllowed = ALLOW_ALL_CONNS;\n\n\t\t\t/*\n\t\t\t * Crank up the background tasks, if we didn't do that already\n\t\t\t * when we entered consistent recovery state.  It doesn't matter\n\t\t\t * if this fails, we'll just try again later.\n\t\t\t */\n\t\t\tif (CheckpointerPID == 0)\n\t\t\t\tCheckpointerPID = StartCheckpointer();\n\t\t\tif (BgWriterPID == 0)\n\t\t\t\tBgWriterPID = StartBackgroundWriter();\n\t\t\tif (WalWriterPID == 0)\n\t\t\t\tWalWriterPID = StartWalWriter();\n\n\t\t\t/*\n\t\t\t * Likewise, start other special children as needed.  In a restart\n\t\t\t * situation, some of them may be alive already.\n\t\t\t */\n\t\t\tif (!IsBinaryUpgrade && AutoVacuumingActive() && AutoVacPID == 0)\n\t\t\t\tAutoVacPID = StartAutoVacLauncher();\n\t\t\tif (PgArchStartupAllowed() && PgArchPID == 0)\n\t\t\t\tPgArchPID = StartArchiver();\n\t\t\tif (PgStatPID == 0)\n\t\t\t\tPgStatPID = pgstat_start();\n\n\t\t\t/* workers may be scheduled to start now */\n\t\t\tmaybe_start_bgworkers();\n\n\t\t\t/* at this point we are really open for business */\n\t\t\tereport(LOG,\n\t\t\t\t\t(errmsg(\"database system is ready to accept connections\")));\n\n\t\t\t/* Report status */\n\t\t\tAddToDataDirLockFile(LOCK_FILE_LINE_PM_STATUS, PM_STATUS_READY);\n#ifdef USE_SYSTEMD\n\t\t\tsd_notify(0, \"READY=1\");\n#endif\n\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Was it the bgwriter?  Normal exit can be ignored; we'll start a new\n\t\t * one at the next iteration of the postmaster's main loop, if\n\t\t * necessary.  Any other exit condition is treated as a crash.\n\t\t */\n\t\tif (pid == BgWriterPID)\n\t\t{\n\t\t\tBgWriterPID = 0;\n\t\t\tif (!EXIT_STATUS_0(exitstatus))\n\t\t\t\tHandleChildCrash(pid, exitstatus,\n\t\t\t\t\t\t\t\t _(\"background writer process\"));\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Was it the checkpointer?\n\t\t */\n\t\tif (pid == CheckpointerPID)\n\t\t{\n\t\t\tCheckpointerPID = 0;\n\t\t\tif (EXIT_STATUS_0(exitstatus) && pmState == PM_SHUTDOWN)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * OK, we saw normal exit of the checkpointer after it's been\n\t\t\t\t * told to shut down.  We expect that it wrote a shutdown\n\t\t\t\t * checkpoint.  (If for some reason it didn't, recovery will\n\t\t\t\t * occur on next postmaster start.)\n\t\t\t\t *\n\t\t\t\t * At this point we should have no normal backend children\n\t\t\t\t * left (else we'd not be in PM_SHUTDOWN state) but we might\n\t\t\t\t * have dead_end children to wait for.\n\t\t\t\t *\n\t\t\t\t * If we have an archiver subprocess, tell it to do a last\n\t\t\t\t * archive cycle and quit. Likewise, if we have walsender\n\t\t\t\t * processes, tell them to send any remaining WAL and quit.\n\t\t\t\t */\n\t\t\t\tAssert(Shutdown > NoShutdown);\n\n\t\t\t\t/* Waken archiver for the last time */\n\t\t\t\tif (PgArchPID != 0)\n\t\t\t\t\tsignal_child(PgArchPID, SIGUSR2);\n\n\t\t\t\t/*\n\t\t\t\t * Waken walsenders for the last time. No regular backends\n\t\t\t\t * should be around anymore.\n\t\t\t\t */\n\t\t\t\tSignalChildren(SIGUSR2);\n\n\t\t\t\tpmState = PM_SHUTDOWN_2;\n\n\t\t\t\t/*\n\t\t\t\t * We can also shut down the stats collector now; there's\n\t\t\t\t * nothing left for it to do.\n\t\t\t\t */\n\t\t\t\tif (PgStatPID != 0)\n\t\t\t\t\tsignal_child(PgStatPID, SIGQUIT);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Any unexpected exit of the checkpointer (including FATAL\n\t\t\t\t * exit) is treated as a crash.\n\t\t\t\t */\n\t\t\t\tHandleChildCrash(pid, exitstatus,\n\t\t\t\t\t\t\t\t _(\"checkpointer process\"));\n\t\t\t}\n\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Was it the wal writer?  Normal exit can be ignored; we'll start a\n\t\t * new one at the next iteration of the postmaster's main loop, if\n\t\t * necessary.  Any other exit condition is treated as a crash.\n\t\t */\n\t\tif (pid == WalWriterPID)\n\t\t{\n\t\t\tWalWriterPID = 0;\n\t\t\tif (!EXIT_STATUS_0(exitstatus))\n\t\t\t\tHandleChildCrash(pid, exitstatus,\n\t\t\t\t\t\t\t\t _(\"WAL writer process\"));\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Was it the wal receiver?  If exit status is zero (normal) or one\n\t\t * (FATAL exit), we assume everything is all right just like normal\n\t\t * backends.  (If we need a new wal receiver, we'll start one at the\n\t\t * next iteration of the postmaster's main loop.)\n\t\t */\n\t\tif (pid == WalReceiverPID)\n\t\t{\n\t\t\tWalReceiverPID = 0;\n\t\t\tif (!EXIT_STATUS_0(exitstatus) && !EXIT_STATUS_1(exitstatus))\n\t\t\t\tHandleChildCrash(pid, exitstatus,\n\t\t\t\t\t\t\t\t _(\"WAL receiver process\"));\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Was it the autovacuum launcher?\tNormal exit can be ignored; we'll\n\t\t * start a new one at the next iteration of the postmaster's main\n\t\t * loop, if necessary.  Any other exit condition is treated as a\n\t\t * crash.\n\t\t */\n\t\tif (pid == AutoVacPID)\n\t\t{\n\t\t\tAutoVacPID = 0;\n\t\t\tif (!EXIT_STATUS_0(exitstatus))\n\t\t\t\tHandleChildCrash(pid, exitstatus,\n\t\t\t\t\t\t\t\t _(\"autovacuum launcher process\"));\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Was it the archiver?  If exit status is zero (normal) or one (FATAL\n\t\t * exit), we assume everything is all right just like normal backends\n\t\t * and just try to restart a new one so that we immediately retry\n\t\t * archiving remaining files. (If fail, we'll try again in future\n\t\t * cycles of the postmaster's main loop.) Unless we were waiting for\n\t\t * it to shut down; don't restart it in that case, and\n\t\t * PostmasterStateMachine() will advance to the next shutdown step.\n\t\t */\n\t\tif (pid == PgArchPID)\n\t\t{\n\t\t\tPgArchPID = 0;\n\t\t\tif (!EXIT_STATUS_0(exitstatus) && !EXIT_STATUS_1(exitstatus))\n\t\t\t\tHandleChildCrash(pid, exitstatus,\n\t\t\t\t\t\t\t\t _(\"archiver process\"));\n\t\t\tif (PgArchStartupAllowed())\n\t\t\t\tPgArchPID = StartArchiver();\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Was it the statistics collector?  If so, just try to start a new\n\t\t * one; no need to force reset of the rest of the system.  (If fail,\n\t\t * we'll try again in future cycles of the main loop.)\n\t\t */\n\t\tif (pid == PgStatPID)\n\t\t{\n\t\t\tPgStatPID = 0;\n\t\t\tif (!EXIT_STATUS_0(exitstatus))\n\t\t\t\tLogChildExit(LOG, _(\"statistics collector process\"),\n\t\t\t\t\t\t\t pid, exitstatus);\n\t\t\tif (pmState == PM_RUN || pmState == PM_HOT_STANDBY)\n\t\t\t\tPgStatPID = pgstat_start();\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Was it the system logger?  If so, try to start a new one */\n\t\tif (pid == SysLoggerPID)\n\t\t{\n\t\t\tSysLoggerPID = 0;\n\t\t\t/* for safety's sake, launch new logger *first* */\n\t\t\tSysLoggerPID = SysLogger_Start();\n\t\t\tif (!EXIT_STATUS_0(exitstatus))\n\t\t\t\tLogChildExit(LOG, _(\"system logger process\"),\n\t\t\t\t\t\t\t pid, exitstatus);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Was it one of our background workers? */\n\t\tif (CleanupBackgroundWorker(pid, exitstatus))\n\t\t{\n\t\t\t/* have it be restarted */\n\t\t\tHaveCrashedWorker = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Else do standard backend child cleanup.\n\t\t */\n\t\tCleanupBackend(pid, exitstatus);\n\t}\t\t\t\t\t\t\t/* loop over pending child-death reports */\n\n\t/*\n\t * After cleaning out the SIGCHLD queue, see if we have any state changes\n\t * or actions to make.\n\t */\n\tPostmasterStateMachine();\n\n\t/* Done with signal handler */\n#ifdef WIN32\n\tPG_SETMASK(&UnBlockSig);\n#endif\n\n\terrno = save_errno;\n}\n\n/*\n * Scan the bgworkers list and see if the given PID (which has just stopped\n * or crashed) is in it.  Handle its shutdown if so, and return true.  If not a\n * bgworker, return false.\n *\n * This is heavily based on CleanupBackend.  One important difference is that\n * we don't know yet that the dying process is a bgworker, so we must be silent\n * until we're sure it is.\n */\nstatic bool\nCleanupBackgroundWorker(int pid,\n\t\t\t\t\t\tint exitstatus) /* child's exit status */\n{\n\tchar\t\tnamebuf[MAXPGPATH];\n\tslist_mutable_iter iter;\n\n\tslist_foreach_modify(iter, &BackgroundWorkerList)\n\t{\n\t\tRegisteredBgWorker *rw;\n\n\t\trw = slist_container(RegisteredBgWorker, rw_lnode, iter.cur);\n\n\t\tif (rw->rw_pid != pid)\n\t\t\tcontinue;\n\n#ifdef WIN32\n\t\t/* see CleanupBackend */\n\t\tif (exitstatus == ERROR_WAIT_NO_CHILDREN)\n\t\t\texitstatus = 0;\n#endif\n\n\t\tsnprintf(namebuf, MAXPGPATH, _(\"background worker \\\"%s\\\"\"),\n\t\t\t\t rw->rw_worker.bgw_type);\n\n\n\t\tif (!EXIT_STATUS_0(exitstatus))\n\t\t{\n\t\t\t/* Record timestamp, so we know when to restart the worker. */\n\t\t\trw->rw_crashed_at = GetCurrentTimestamp();\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Zero exit status means terminate */\n\t\t\trw->rw_crashed_at = 0;\n\t\t\trw->rw_terminate = true;\n\t\t}\n\n\t\t/*\n\t\t * Additionally, just like a backend, any exit status other than 0 or\n\t\t * 1 is considered a crash and causes a system-wide restart.\n\t\t */\n\t\tif (!EXIT_STATUS_0(exitstatus) && !EXIT_STATUS_1(exitstatus))\n\t\t{\n\t\t\tHandleChildCrash(pid, exitstatus, namebuf);\n\t\t\treturn true;\n\t\t}\n\n\t\t/*\n\t\t * We must release the postmaster child slot. If the worker failed to\n\t\t * do so, it did not clean up after itself, requiring a crash-restart\n\t\t * cycle.\n\t\t */\n\t\tif (!ReleasePostmasterChildSlot(rw->rw_child_slot))\n\t\t{\n\t\t\tHandleChildCrash(pid, exitstatus, namebuf);\n\t\t\treturn true;\n\t\t}\n\n\t\t/* Get it out of the BackendList and clear out remaining data */\n\t\tdlist_delete(&rw->rw_backend->elem);\n#ifdef EXEC_BACKEND\n\t\tShmemBackendArrayRemove(rw->rw_backend);\n#endif\n\n\t\t/*\n\t\t * It's possible that this background worker started some OTHER\n\t\t * background worker and asked to be notified when that worker started\n\t\t * or stopped.  If so, cancel any notifications destined for the\n\t\t * now-dead backend.\n\t\t */\n\t\tif (rw->rw_backend->bgworker_notify)\n\t\t\tBackgroundWorkerStopNotifications(rw->rw_pid);\n\t\tfree(rw->rw_backend);\n\t\trw->rw_backend = NULL;\n\t\trw->rw_pid = 0;\n\t\trw->rw_child_slot = 0;\n\t\tReportBackgroundWorkerExit(&iter);\t/* report child death */\n\n\t\tLogChildExit(EXIT_STATUS_0(exitstatus) ? DEBUG1 : LOG,\n\t\t\t\t\t namebuf, pid, exitstatus);\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n/*\n * CleanupBackend -- cleanup after terminated backend.\n *\n * Remove all local state associated with backend.\n *\n * If you change this, see also CleanupBackgroundWorker.\n */\nstatic void\nCleanupBackend(int pid,\n\t\t\t   int exitstatus)\t/* child's exit status. */\n{\n\tdlist_mutable_iter iter;\n\n\tLogChildExit(DEBUG2, _(\"server process\"), pid, exitstatus);\n\n\t/*\n\t * If a backend dies in an ugly way then we must signal all other backends\n\t * to quickdie.  If exit status is zero (normal) or one (FATAL exit), we\n\t * assume everything is all right and proceed to remove the backend from\n\t * the active backend list.\n\t */\n\n#ifdef WIN32\n\n\t/*\n\t * On win32, also treat ERROR_WAIT_NO_CHILDREN (128) as nonfatal case,\n\t * since that sometimes happens under load when the process fails to start\n\t * properly (long before it starts using shared memory). Microsoft reports\n\t * it is related to mutex failure:\n\t * http://archives.postgresql.org/pgsql-hackers/2010-09/msg00790.php\n\t */\n\tif (exitstatus == ERROR_WAIT_NO_CHILDREN)\n\t{\n\t\tLogChildExit(LOG, _(\"server process\"), pid, exitstatus);\n\t\texitstatus = 0;\n\t}\n#endif\n\n\tif (!EXIT_STATUS_0(exitstatus) && !EXIT_STATUS_1(exitstatus))\n\t{\n\t\tHandleChildCrash(pid, exitstatus, _(\"server process\"));\n\t\treturn;\n\t}\n\n\tdlist_foreach_modify(iter, &BackendList)\n\t{\n\t\tBackend    *bp = dlist_container(Backend, elem, iter.cur);\n\n\t\tif (bp->pid == pid)\n\t\t{\n\t\t\tif (!bp->dead_end)\n\t\t\t{\n\t\t\t\tif (!ReleasePostmasterChildSlot(bp->child_slot))\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * Uh-oh, the child failed to clean itself up.  Treat as a\n\t\t\t\t\t * crash after all.\n\t\t\t\t\t */\n\t\t\t\t\tHandleChildCrash(pid, exitstatus, _(\"server process\"));\n\t\t\t\t\treturn;\n\t\t\t\t}\n#ifdef EXEC_BACKEND\n\t\t\t\tShmemBackendArrayRemove(bp);\n#endif\n\t\t\t}\n\t\t\tif (bp->bgworker_notify)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * This backend may have been slated to receive SIGUSR1 when\n\t\t\t\t * some background worker started or stopped.  Cancel those\n\t\t\t\t * notifications, as we don't want to signal PIDs that are not\n\t\t\t\t * PostgreSQL backends.  This gets skipped in the (probably\n\t\t\t\t * very common) case where the backend has never requested any\n\t\t\t\t * such notifications.\n\t\t\t\t */\n\t\t\t\tBackgroundWorkerStopNotifications(bp->pid);\n\t\t\t}\n\t\t\tdlist_delete(iter.cur);\n\t\t\tfree(bp);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/*\n * HandleChildCrash -- cleanup after failed backend, bgwriter, checkpointer,\n * walwriter, autovacuum, archiver or background worker.\n *\n * The objectives here are to clean up our local state about the child\n * process, and to signal all other remaining children to quickdie.\n */\nstatic void\nHandleChildCrash(int pid, int exitstatus, const char *procname)\n{\n\tdlist_mutable_iter iter;\n\tslist_iter\tsiter;\n\tBackend    *bp;\n\tbool\t\ttake_action;\n\n\t/*\n\t * We only log messages and send signals if this is the first process\n\t * crash and we're not doing an immediate shutdown; otherwise, we're only\n\t * here to update postmaster's idea of live processes.  If we have already\n\t * signaled children, nonzero exit status is to be expected, so don't\n\t * clutter log.\n\t */\n\ttake_action = !FatalError && Shutdown != ImmediateShutdown;\n\n\tif (take_action)\n\t{\n\t\tLogChildExit(LOG, procname, pid, exitstatus);\n\t\tereport(LOG,\n\t\t\t\t(errmsg(\"terminating any other active server processes\")));\n\t\tSetQuitSignalReason(PMQUIT_FOR_CRASH);\n\t}\n\n\t/* Process background workers. */\n\tslist_foreach(siter, &BackgroundWorkerList)\n\t{\n\t\tRegisteredBgWorker *rw;\n\n\t\trw = slist_container(RegisteredBgWorker, rw_lnode, siter.cur);\n\t\tif (rw->rw_pid == 0)\n\t\t\tcontinue;\t\t\t/* not running */\n\t\tif (rw->rw_pid == pid)\n\t\t{\n\t\t\t/*\n\t\t\t * Found entry for freshly-dead worker, so remove it.\n\t\t\t */\n\t\t\t(void) ReleasePostmasterChildSlot(rw->rw_child_slot);\n\t\t\tdlist_delete(&rw->rw_backend->elem);\n#ifdef EXEC_BACKEND\n\t\t\tShmemBackendArrayRemove(rw->rw_backend);\n#endif\n\t\t\tfree(rw->rw_backend);\n\t\t\trw->rw_backend = NULL;\n\t\t\trw->rw_pid = 0;\n\t\t\trw->rw_child_slot = 0;\n\t\t\t/* don't reset crashed_at */\n\t\t\t/* don't report child stop, either */\n\t\t\t/* Keep looping so we can signal remaining workers */\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * This worker is still alive.  Unless we did so already, tell it\n\t\t\t * to commit hara-kiri.\n\t\t\t *\n\t\t\t * SIGQUIT is the special signal that says exit without proc_exit\n\t\t\t * and let the user know what's going on. But if SendStop is set\n\t\t\t * (-T on command line), then we send SIGSTOP instead, so that we\n\t\t\t * can get core dumps from all backends by hand.\n\t\t\t */\n\t\t\tif (take_action)\n\t\t\t{\n\t\t\t\tereport(DEBUG2,\n\t\t\t\t\t\t(errmsg_internal(\"sending %s to process %d\",\n\t\t\t\t\t\t\t\t\t\t (SendStop ? \"SIGSTOP\" : \"SIGQUIT\"),\n\t\t\t\t\t\t\t\t\t\t (int) rw->rw_pid)));\n\t\t\t\tsignal_child(rw->rw_pid, (SendStop ? SIGSTOP : SIGQUIT));\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Process regular backends */\n\tdlist_foreach_modify(iter, &BackendList)\n\t{\n\t\tbp = dlist_container(Backend, elem, iter.cur);\n\n\t\tif (bp->pid == pid)\n\t\t{\n\t\t\t/*\n\t\t\t * Found entry for freshly-dead backend, so remove it.\n\t\t\t */\n\t\t\tif (!bp->dead_end)\n\t\t\t{\n\t\t\t\t(void) ReleasePostmasterChildSlot(bp->child_slot);\n#ifdef EXEC_BACKEND\n\t\t\t\tShmemBackendArrayRemove(bp);\n#endif\n\t\t\t}\n\t\t\tdlist_delete(iter.cur);\n\t\t\tfree(bp);\n\t\t\t/* Keep looping so we can signal remaining backends */\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * This backend is still alive.  Unless we did so already, tell it\n\t\t\t * to commit hara-kiri.\n\t\t\t *\n\t\t\t * SIGQUIT is the special signal that says exit without proc_exit\n\t\t\t * and let the user know what's going on. But if SendStop is set\n\t\t\t * (-T on command line), then we send SIGSTOP instead, so that we\n\t\t\t * can get core dumps from all backends by hand.\n\t\t\t *\n\t\t\t * We could exclude dead_end children here, but at least in the\n\t\t\t * SIGSTOP case it seems better to include them.\n\t\t\t *\n\t\t\t * Background workers were already processed above; ignore them\n\t\t\t * here.\n\t\t\t */\n\t\t\tif (bp->bkend_type == BACKEND_TYPE_BGWORKER)\n\t\t\t\tcontinue;\n\n\t\t\tif (take_action)\n\t\t\t{\n\t\t\t\tereport(DEBUG2,\n\t\t\t\t\t\t(errmsg_internal(\"sending %s to process %d\",\n\t\t\t\t\t\t\t\t\t\t (SendStop ? \"SIGSTOP\" : \"SIGQUIT\"),\n\t\t\t\t\t\t\t\t\t\t (int) bp->pid)));\n\t\t\t\tsignal_child(bp->pid, (SendStop ? SIGSTOP : SIGQUIT));\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Take care of the startup process too */\n\tif (pid == StartupPID)\n\t{\n\t\tStartupPID = 0;\n\t\t/* Caller adjusts StartupStatus, so don't touch it here */\n\t}\n\telse if (StartupPID != 0 && take_action)\n\t{\n\t\tereport(DEBUG2,\n\t\t\t\t(errmsg_internal(\"sending %s to process %d\",\n\t\t\t\t\t\t\t\t (SendStop ? \"SIGSTOP\" : \"SIGQUIT\"),\n\t\t\t\t\t\t\t\t (int) StartupPID)));\n\t\tsignal_child(StartupPID, (SendStop ? SIGSTOP : SIGQUIT));\n\t\tStartupStatus = STARTUP_SIGNALED;\n\t}\n\n\t/* Take care of the bgwriter too */\n\tif (pid == BgWriterPID)\n\t\tBgWriterPID = 0;\n\telse if (BgWriterPID != 0 && take_action)\n\t{\n\t\tereport(DEBUG2,\n\t\t\t\t(errmsg_internal(\"sending %s to process %d\",\n\t\t\t\t\t\t\t\t (SendStop ? \"SIGSTOP\" : \"SIGQUIT\"),\n\t\t\t\t\t\t\t\t (int) BgWriterPID)));\n\t\tsignal_child(BgWriterPID, (SendStop ? SIGSTOP : SIGQUIT));\n\t}\n\n\t/* Take care of the checkpointer too */\n\tif (pid == CheckpointerPID)\n\t\tCheckpointerPID = 0;\n\telse if (CheckpointerPID != 0 && take_action)\n\t{\n\t\tereport(DEBUG2,\n\t\t\t\t(errmsg_internal(\"sending %s to process %d\",\n\t\t\t\t\t\t\t\t (SendStop ? \"SIGSTOP\" : \"SIGQUIT\"),\n\t\t\t\t\t\t\t\t (int) CheckpointerPID)));\n\t\tsignal_child(CheckpointerPID, (SendStop ? SIGSTOP : SIGQUIT));\n\t}\n\n\t/* Take care of the walwriter too */\n\tif (pid == WalWriterPID)\n\t\tWalWriterPID = 0;\n\telse if (WalWriterPID != 0 && take_action)\n\t{\n\t\tereport(DEBUG2,\n\t\t\t\t(errmsg_internal(\"sending %s to process %d\",\n\t\t\t\t\t\t\t\t (SendStop ? \"SIGSTOP\" : \"SIGQUIT\"),\n\t\t\t\t\t\t\t\t (int) WalWriterPID)));\n\t\tsignal_child(WalWriterPID, (SendStop ? SIGSTOP : SIGQUIT));\n\t}\n\n\t/* Take care of the walreceiver too */\n\tif (pid == WalReceiverPID)\n\t\tWalReceiverPID = 0;\n\telse if (WalReceiverPID != 0 && take_action)\n\t{\n\t\tereport(DEBUG2,\n\t\t\t\t(errmsg_internal(\"sending %s to process %d\",\n\t\t\t\t\t\t\t\t (SendStop ? \"SIGSTOP\" : \"SIGQUIT\"),\n\t\t\t\t\t\t\t\t (int) WalReceiverPID)));\n\t\tsignal_child(WalReceiverPID, (SendStop ? SIGSTOP : SIGQUIT));\n\t}\n\n\t/* Take care of the autovacuum launcher too */\n\tif (pid == AutoVacPID)\n\t\tAutoVacPID = 0;\n\telse if (AutoVacPID != 0 && take_action)\n\t{\n\t\tereport(DEBUG2,\n\t\t\t\t(errmsg_internal(\"sending %s to process %d\",\n\t\t\t\t\t\t\t\t (SendStop ? \"SIGSTOP\" : \"SIGQUIT\"),\n\t\t\t\t\t\t\t\t (int) AutoVacPID)));\n\t\tsignal_child(AutoVacPID, (SendStop ? SIGSTOP : SIGQUIT));\n\t}\n\n\t/* Take care of the archiver too */\n\tif (pid == PgArchPID)\n\t\tPgArchPID = 0;\n\telse if (PgArchPID != 0 && take_action)\n\t{\n\t\tereport(DEBUG2,\n\t\t\t\t(errmsg_internal(\"sending %s to process %d\",\n\t\t\t\t\t\t\t\t (SendStop ? \"SIGSTOP\" : \"SIGQUIT\"),\n\t\t\t\t\t\t\t\t (int) PgArchPID)));\n\t\tsignal_child(PgArchPID, (SendStop ? SIGSTOP : SIGQUIT));\n\t}\n\n\t/*\n\t * Force a power-cycle of the pgstat process too.  (This isn't absolutely\n\t * necessary, but it seems like a good idea for robustness, and it\n\t * simplifies the state-machine logic in the case where a shutdown request\n\t * arrives during crash processing.)\n\t */\n\tif (PgStatPID != 0 && take_action)\n\t{\n\t\tereport(DEBUG2,\n\t\t\t\t(errmsg_internal(\"sending %s to process %d\",\n\t\t\t\t\t\t\t\t \"SIGQUIT\",\n\t\t\t\t\t\t\t\t (int) PgStatPID)));\n\t\tsignal_child(PgStatPID, SIGQUIT);\n\t\tallow_immediate_pgstat_restart();\n\t}\n\n\t/* We do NOT restart the syslogger */\n\n\tif (Shutdown != ImmediateShutdown)\n\t\tFatalError = true;\n\n\t/* We now transit into a state of waiting for children to die */\n\tif (pmState == PM_RECOVERY ||\n\t\tpmState == PM_HOT_STANDBY ||\n\t\tpmState == PM_RUN ||\n\t\tpmState == PM_STOP_BACKENDS ||\n\t\tpmState == PM_SHUTDOWN)\n\t\tpmState = PM_WAIT_BACKENDS;\n\n\t/*\n\t * .. and if this doesn't happen quickly enough, now the clock is ticking\n\t * for us to kill them without mercy.\n\t */\n\tif (AbortStartTime == 0)\n\t\tAbortStartTime = time(NULL);\n}\n\n/*\n * Log the death of a child process.\n */\nstatic void\nLogChildExit(int lev, const char *procname, int pid, int exitstatus)\n{\n\t/*\n\t * size of activity_buffer is arbitrary, but set equal to default\n\t * track_activity_query_size\n\t */\n\tchar\t\tactivity_buffer[1024];\n\tconst char *activity = NULL;\n\n\tif (!EXIT_STATUS_0(exitstatus))\n\t\tactivity = pgstat_get_crashed_backend_activity(pid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   activity_buffer,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   sizeof(activity_buffer));\n\n\tif (WIFEXITED(exitstatus))\n\t\tereport(lev,\n\n\t\t/*------\n\t\t  translator: %s is a noun phrase describing a child process, such as\n\t\t  \"server process\" */\n\t\t\t\t(errmsg(\"%s (PID %d) exited with exit code %d\",\n\t\t\t\t\t\tprocname, pid, WEXITSTATUS(exitstatus)),\n\t\t\t\t activity ? errdetail(\"Failed process was running: %s\", activity) : 0));\n\telse if (WIFSIGNALED(exitstatus))\n\t{\n#if defined(WIN32)\n\t\tereport(lev,\n\n\t\t/*------\n\t\t  translator: %s is a noun phrase describing a child process, such as\n\t\t  \"server process\" */\n\t\t\t\t(errmsg(\"%s (PID %d) was terminated by exception 0x%X\",\n\t\t\t\t\t\tprocname, pid, WTERMSIG(exitstatus)),\n\t\t\t\t errhint(\"See C include file \\\"ntstatus.h\\\" for a description of the hexadecimal value.\"),\n\t\t\t\t activity ? errdetail(\"Failed process was running: %s\", activity) : 0));\n#else\n\t\tereport(lev,\n\n\t\t/*------\n\t\t  translator: %s is a noun phrase describing a child process, such as\n\t\t  \"server process\" */\n\t\t\t\t(errmsg(\"%s (PID %d) was terminated by signal %d: %s\",\n\t\t\t\t\t\tprocname, pid, WTERMSIG(exitstatus),\n\t\t\t\t\t\tpg_strsignal(WTERMSIG(exitstatus))),\n\t\t\t\t activity ? errdetail(\"Failed process was running: %s\", activity) : 0));\n#endif\n\t}\n\telse\n\t\tereport(lev,\n\n\t\t/*------\n\t\t  translator: %s is a noun phrase describing a child process, such as\n\t\t  \"server process\" */\n\t\t\t\t(errmsg(\"%s (PID %d) exited with unrecognized status %d\",\n\t\t\t\t\t\tprocname, pid, exitstatus),\n\t\t\t\t activity ? errdetail(\"Failed process was running: %s\", activity) : 0));\n}\n\n/*\n * Advance the postmaster's state machine and take actions as appropriate\n *\n * This is common code for pmdie(), reaper() and sigusr1_handler(), which\n * receive the signals that might mean we need to change state.\n */\nstatic void\nPostmasterStateMachine(void)\n{\n\t/* If we're doing a smart shutdown, try to advance that state. */\n\tif (pmState == PM_RUN || pmState == PM_HOT_STANDBY)\n\t{\n\t\tif (connsAllowed == ALLOW_SUPERUSER_CONNS)\n\t\t{\n\t\t\t/*\n\t\t\t * ALLOW_SUPERUSER_CONNS state ends as soon as online backup mode\n\t\t\t * is not active.\n\t\t\t */\n\t\t\tif (!BackupInProgress())\n\t\t\t\tconnsAllowed = ALLOW_NO_CONNS;\n\t\t}\n\n\t\tif (connsAllowed == ALLOW_NO_CONNS)\n\t\t{\n\t\t\t/*\n\t\t\t * ALLOW_NO_CONNS state ends when we have no normal client\n\t\t\t * backends running.  Then we're ready to stop other children.\n\t\t\t */\n\t\t\tif (CountChildren(BACKEND_TYPE_NORMAL) == 0)\n\t\t\t\tpmState = PM_STOP_BACKENDS;\n\t\t}\n\t}\n\n\t/*\n\t * If we're ready to do so, signal child processes to shut down.  (This\n\t * isn't a persistent state, but treating it as a distinct pmState allows\n\t * us to share this code across multiple shutdown code paths.)\n\t */\n\tif (pmState == PM_STOP_BACKENDS)\n\t{\n\t\t/*\n\t\t * Forget any pending requests for background workers, since we're no\n\t\t * longer willing to launch any new workers.  (If additional requests\n\t\t * arrive, BackgroundWorkerStateChange will reject them.)\n\t\t */\n\t\tForgetUnstartedBackgroundWorkers();\n\n\t\t/* Signal all backend children except walsenders */\n\t\tSignalSomeChildren(SIGTERM,\n\t\t\t\t\t\t   BACKEND_TYPE_ALL - BACKEND_TYPE_WALSND);\n\t\t/* and the autovac launcher too */\n\t\tif (AutoVacPID != 0)\n\t\t\tsignal_child(AutoVacPID, SIGTERM);\n\t\t/* and the bgwriter too */\n\t\tif (BgWriterPID != 0)\n\t\t\tsignal_child(BgWriterPID, SIGTERM);\n\t\t/* and the walwriter too */\n\t\tif (WalWriterPID != 0)\n\t\t\tsignal_child(WalWriterPID, SIGTERM);\n\t\t/* If we're in recovery, also stop startup and walreceiver procs */\n\t\tif (StartupPID != 0)\n\t\t\tsignal_child(StartupPID, SIGTERM);\n\t\tif (WalReceiverPID != 0)\n\t\t\tsignal_child(WalReceiverPID, SIGTERM);\n\t\t/* checkpointer, archiver, stats, and syslogger may continue for now */\n\n\t\t/* Now transition to PM_WAIT_BACKENDS state to wait for them to die */\n\t\tpmState = PM_WAIT_BACKENDS;\n\t}\n\n\t/*\n\t * If we are in a state-machine state that implies waiting for backends to\n\t * exit, see if they're all gone, and change state if so.\n\t */\n\tif (pmState == PM_WAIT_BACKENDS)\n\t{\n\t\t/*\n\t\t * PM_WAIT_BACKENDS state ends when we have no regular backends\n\t\t * (including autovac workers), no bgworkers (including unconnected\n\t\t * ones), and no walwriter, autovac launcher or bgwriter.  If we are\n\t\t * doing crash recovery or an immediate shutdown then we expect the\n\t\t * checkpointer to exit as well, otherwise not. The stats and\n\t\t * syslogger processes are disregarded since they are not connected to\n\t\t * shared memory; we also disregard dead_end children here. Walsenders\n\t\t * and archiver are also disregarded, they will be terminated later\n\t\t * after writing the checkpoint record.\n\t\t */\n\t\tif (CountChildren(BACKEND_TYPE_ALL - BACKEND_TYPE_WALSND) == 0 &&\n\t\t\tStartupPID == 0 &&\n\t\t\tWalReceiverPID == 0 &&\n\t\t\tBgWriterPID == 0 &&\n\t\t\t(CheckpointerPID == 0 ||\n\t\t\t (!FatalError && Shutdown < ImmediateShutdown)) &&\n\t\t\tWalWriterPID == 0 &&\n\t\t\tAutoVacPID == 0)\n\t\t{\n\t\t\tif (Shutdown >= ImmediateShutdown || FatalError)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Start waiting for dead_end children to die.  This state\n\t\t\t\t * change causes ServerLoop to stop creating new ones.\n\t\t\t\t */\n\t\t\t\tpmState = PM_WAIT_DEAD_END;\n\n\t\t\t\t/*\n\t\t\t\t * We already SIGQUIT'd the archiver and stats processes, if\n\t\t\t\t * any, when we started immediate shutdown or entered\n\t\t\t\t * FatalError state.\n\t\t\t\t */\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * If we get here, we are proceeding with normal shutdown. All\n\t\t\t\t * the regular children are gone, and it's time to tell the\n\t\t\t\t * checkpointer to do a shutdown checkpoint.\n\t\t\t\t */\n\t\t\t\tAssert(Shutdown > NoShutdown);\n\t\t\t\t/* Start the checkpointer if not running */\n\t\t\t\tif (CheckpointerPID == 0)\n\t\t\t\t\tCheckpointerPID = StartCheckpointer();\n\t\t\t\t/* And tell it to shut down */\n\t\t\t\tif (CheckpointerPID != 0)\n\t\t\t\t{\n\t\t\t\t\tsignal_child(CheckpointerPID, SIGUSR2);\n\t\t\t\t\tpmState = PM_SHUTDOWN;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * If we failed to fork a checkpointer, just shut down.\n\t\t\t\t\t * Any required cleanup will happen at next restart. We\n\t\t\t\t\t * set FatalError so that an \"abnormal shutdown\" message\n\t\t\t\t\t * gets logged when we exit.\n\t\t\t\t\t */\n\t\t\t\t\tFatalError = true;\n\t\t\t\t\tpmState = PM_WAIT_DEAD_END;\n\n\t\t\t\t\t/* Kill the walsenders, archiver and stats collector too */\n\t\t\t\t\tSignalChildren(SIGQUIT);\n\t\t\t\t\tif (PgArchPID != 0)\n\t\t\t\t\t\tsignal_child(PgArchPID, SIGQUIT);\n\t\t\t\t\tif (PgStatPID != 0)\n\t\t\t\t\t\tsignal_child(PgStatPID, SIGQUIT);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (pmState == PM_SHUTDOWN_2)\n\t{\n\t\t/*\n\t\t * PM_SHUTDOWN_2 state ends when there's no other children than\n\t\t * dead_end children left. There shouldn't be any regular backends\n\t\t * left by now anyway; what we're really waiting for is walsenders and\n\t\t * archiver.\n\t\t */\n\t\tif (PgArchPID == 0 && CountChildren(BACKEND_TYPE_ALL) == 0)\n\t\t{\n\t\t\tpmState = PM_WAIT_DEAD_END;\n\t\t}\n\t}\n\n\tif (pmState == PM_WAIT_DEAD_END)\n\t{\n\t\t/*\n\t\t * PM_WAIT_DEAD_END state ends when the BackendList is entirely empty\n\t\t * (ie, no dead_end children remain), and the archiver and stats\n\t\t * collector are gone too.\n\t\t *\n\t\t * The reason we wait for those two is to protect them against a new\n\t\t * postmaster starting conflicting subprocesses; this isn't an\n\t\t * ironclad protection, but it at least helps in the\n\t\t * shutdown-and-immediately-restart scenario.  Note that they have\n\t\t * already been sent appropriate shutdown signals, either during a\n\t\t * normal state transition leading up to PM_WAIT_DEAD_END, or during\n\t\t * FatalError processing.\n\t\t */\n\t\tif (dlist_is_empty(&BackendList) &&\n\t\t\tPgArchPID == 0 && PgStatPID == 0)\n\t\t{\n\t\t\t/* These other guys should be dead already */\n\t\t\tAssert(StartupPID == 0);\n\t\t\tAssert(WalReceiverPID == 0);\n\t\t\tAssert(BgWriterPID == 0);\n\t\t\tAssert(CheckpointerPID == 0);\n\t\t\tAssert(WalWriterPID == 0);\n\t\t\tAssert(AutoVacPID == 0);\n\t\t\t/* syslogger is not considered here */\n\t\t\tpmState = PM_NO_CHILDREN;\n\t\t}\n\t}\n\n\t/*\n\t * If we've been told to shut down, we exit as soon as there are no\n\t * remaining children.  If there was a crash, cleanup will occur at the\n\t * next startup.  (Before PostgreSQL 8.3, we tried to recover from the\n\t * crash before exiting, but that seems unwise if we are quitting because\n\t * we got SIGTERM from init --- there may well not be time for recovery\n\t * before init decides to SIGKILL us.)\n\t *\n\t * Note that the syslogger continues to run.  It will exit when it sees\n\t * EOF on its input pipe, which happens when there are no more upstream\n\t * processes.\n\t */\n\tif (Shutdown > NoShutdown && pmState == PM_NO_CHILDREN)\n\t{\n\t\tif (FatalError)\n\t\t{\n\t\t\tereport(LOG, (errmsg(\"abnormal database system shutdown\")));\n\t\t\tExitPostmaster(1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Terminate exclusive backup mode to avoid recovery after a clean\n\t\t\t * fast shutdown.  Since an exclusive backup can only be taken\n\t\t\t * during normal running (and not, for example, while running\n\t\t\t * under Hot Standby) it only makes sense to do this if we reached\n\t\t\t * normal running. If we're still in recovery, the backup file is\n\t\t\t * one we're recovering *from*, and we must keep it around so that\n\t\t\t * recovery restarts from the right place.\n\t\t\t */\n\t\t\tif (ReachedNormalRunning)\n\t\t\t\tCancelBackup();\n\n\t\t\t/*\n\t\t\t * Normal exit from the postmaster is here.  We don't need to log\n\t\t\t * anything here, since the UnlinkLockFiles proc_exit callback\n\t\t\t * will do so, and that should be the last user-visible action.\n\t\t\t */\n\t\t\tExitPostmaster(0);\n\t\t}\n\t}\n\n\t/*\n\t * If the startup process failed, or the user does not want an automatic\n\t * restart after backend crashes, wait for all non-syslogger children to\n\t * exit, and then exit postmaster.  We don't try to reinitialize when the\n\t * startup process fails, because more than likely it will just fail again\n\t * and we will keep trying forever.\n\t */\n\tif (pmState == PM_NO_CHILDREN)\n\t{\n\t\tif (StartupStatus == STARTUP_CRASHED)\n\t\t{\n\t\t\tereport(LOG,\n\t\t\t\t\t(errmsg(\"shutting down due to startup process failure\")));\n\t\t\tExitPostmaster(1);\n\t\t}\n\t\tif (!restart_after_crash)\n\t\t{\n\t\t\tereport(LOG,\n\t\t\t\t\t(errmsg(\"shutting down because restart_after_crash is off\")));\n\t\t\tExitPostmaster(1);\n\t\t}\n\t}\n\n\t/*\n\t * If we need to recover from a crash, wait for all non-syslogger children\n\t * to exit, then reset shmem and StartupDataBase.\n\t */\n\tif (FatalError && pmState == PM_NO_CHILDREN)\n\t{\n\t\tereport(LOG,\n\t\t\t\t(errmsg(\"all server processes terminated; reinitializing\")));\n\n\t\t/* remove leftover temporary files after a crash */\n\t\tif (remove_temp_files_after_crash)\n\t\t\tRemovePgTempFiles();\n\n\t\t/* allow background workers to immediately restart */\n\t\tResetBackgroundWorkerCrashTimes();\n\n\t\tshmem_exit(1);\n\n\t\t/* re-read control file into local memory */\n\t\tLocalProcessControlFile(true);\n\n\t\treset_shared();\n\n\t\tStartupPID = StartupDataBase();\n\t\tAssert(StartupPID != 0);\n\t\tStartupStatus = STARTUP_RUNNING;\n\t\tpmState = PM_STARTUP;\n\t\t/* crash recovery started, reset SIGKILL flag */\n\t\tAbortStartTime = 0;\n\t}\n}\n\n\n/*\n * Send a signal to a postmaster child process\n *\n * On systems that have setsid(), each child process sets itself up as a\n * process group leader.  For signals that are generally interpreted in the\n * appropriate fashion, we signal the entire process group not just the\n * direct child process.  This allows us to, for example, SIGQUIT a blocked\n * archive_recovery script, or SIGINT a script being run by a backend via\n * system().\n *\n * There is a race condition for recently-forked children: they might not\n * have executed setsid() yet.  So we signal the child directly as well as\n * the group.  We assume such a child will handle the signal before trying\n * to spawn any grandchild processes.  We also assume that signaling the\n * child twice will not cause any problems.\n */\nstatic void\nsignal_child(pid_t pid, int signal)\n{\n\tif (kill(pid, signal) < 0)\n\t\telog(DEBUG3, \"kill(%ld,%d) failed: %m\", (long) pid, signal);\n#ifdef HAVE_SETSID\n\tswitch (signal)\n\t{\n\t\tcase SIGINT:\n\t\tcase SIGTERM:\n\t\tcase SIGQUIT:\n\t\tcase SIGSTOP:\n\t\tcase SIGKILL:\n\t\t\tif (kill(-pid, signal) < 0)\n\t\t\t\telog(DEBUG3, \"kill(%ld,%d) failed: %m\", (long) (-pid), signal);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n#endif\n}\n\n/*\n * Send a signal to the targeted children (but NOT special children;\n * dead_end children are never signaled, either).\n */\nstatic bool\nSignalSomeChildren(int signal, int target)\n{\n\tdlist_iter\titer;\n\tbool\t\tsignaled = false;\n\n\tdlist_foreach(iter, &BackendList)\n\t{\n\t\tBackend    *bp = dlist_container(Backend, elem, iter.cur);\n\n\t\tif (bp->dead_end)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Since target == BACKEND_TYPE_ALL is the most common case, we test\n\t\t * it first and avoid touching shared memory for every child.\n\t\t */\n\t\tif (target != BACKEND_TYPE_ALL)\n\t\t{\n\t\t\t/*\n\t\t\t * Assign bkend_type for any recently announced WAL Sender\n\t\t\t * processes.\n\t\t\t */\n\t\t\tif (bp->bkend_type == BACKEND_TYPE_NORMAL &&\n\t\t\t\tIsPostmasterChildWalSender(bp->child_slot))\n\t\t\t\tbp->bkend_type = BACKEND_TYPE_WALSND;\n\n\t\t\tif (!(target & bp->bkend_type))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tereport(DEBUG4,\n\t\t\t\t(errmsg_internal(\"sending signal %d to process %d\",\n\t\t\t\t\t\t\t\t signal, (int) bp->pid)));\n\t\tsignal_child(bp->pid, signal);\n\t\tsignaled = true;\n\t}\n\treturn signaled;\n}\n\n/*\n * Send a termination signal to children.  This considers all of our children\n * processes, except syslogger and dead_end backends.\n */\nstatic void\nTerminateChildren(int signal)\n{\n\tSignalChildren(signal);\n\tif (StartupPID != 0)\n\t{\n\t\tsignal_child(StartupPID, signal);\n\t\tif (signal == SIGQUIT || signal == SIGKILL)\n\t\t\tStartupStatus = STARTUP_SIGNALED;\n\t}\n\tif (BgWriterPID != 0)\n\t\tsignal_child(BgWriterPID, signal);\n\tif (CheckpointerPID != 0)\n\t\tsignal_child(CheckpointerPID, signal);\n\tif (WalWriterPID != 0)\n\t\tsignal_child(WalWriterPID, signal);\n\tif (WalReceiverPID != 0)\n\t\tsignal_child(WalReceiverPID, signal);\n\tif (AutoVacPID != 0)\n\t\tsignal_child(AutoVacPID, signal);\n\tif (PgArchPID != 0)\n\t\tsignal_child(PgArchPID, signal);\n\tif (PgStatPID != 0)\n\t\tsignal_child(PgStatPID, signal);\n}\n\n/*\n * BackendStartup -- start backend process\n *\n * returns: STATUS_ERROR if the fork failed, STATUS_OK otherwise.\n *\n * Note: if you change this code, also consider StartAutovacuumWorker.\n */\nstatic int\nBackendStartup(Port *port)\n{\n\tBackend    *bn;\t\t\t\t/* for backend cleanup */\n\tpid_t\t\tpid;\n\n\t/*\n\t * Create backend data structure.  Better before the fork() so we can\n\t * handle failure cleanly.\n\t */\n\tbn = (Backend *) malloc(sizeof(Backend));\n\tif (!bn)\n\t{\n\t\tereport(LOG,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\")));\n\t\treturn STATUS_ERROR;\n\t}\n\n\t/*\n\t * Compute the cancel key that will be assigned to this backend. The\n\t * backend will have its own copy in the forked-off process' value of\n\t * MyCancelKey, so that it can transmit the key to the frontend.\n\t */\n\tif (!RandomCancelKey(&MyCancelKey))\n\t{\n\t\tfree(bn);\n\t\tereport(LOG,\n\t\t\t\t(errcode(ERRCODE_INTERNAL_ERROR),\n\t\t\t\t errmsg(\"could not generate random cancel key\")));\n\t\treturn STATUS_ERROR;\n\t}\n\n\tbn->cancel_key = MyCancelKey;\n\n\t/* Pass down canAcceptConnections state */\n\tport->canAcceptConnections = canAcceptConnections(BACKEND_TYPE_NORMAL);\n\tbn->dead_end = (port->canAcceptConnections != CAC_OK &&\n\t\t\t\t\tport->canAcceptConnections != CAC_SUPERUSER);\n\n\t/*\n\t * Unless it's a dead_end child, assign it a child slot number\n\t */\n\tif (!bn->dead_end)\n\t\tbn->child_slot = MyPMChildSlot = AssignPostmasterChildSlot();\n\telse\n\t\tbn->child_slot = 0;\n\n\t/* Hasn't asked to be notified about any bgworkers yet */\n\tbn->bgworker_notify = false;\n\n#ifdef EXEC_BACKEND\n\tpid = backend_forkexec(port);\n#else\t\t\t\t\t\t\t/* !EXEC_BACKEND */\n\tpid = fork_process();\n\tif (pid == 0)\t\t\t\t/* child */\n\t{\n\t\tfree(bn);\n\n\t\t/* Detangle from postmaster */\n\t\tInitPostmasterChild();\n\n\t\t/* Close the postmaster's sockets */\n\t\tClosePostmasterPorts(false);\n\n\t\t/* Perform additional initialization and collect startup packet */\n\t\tBackendInitialize(port);\n\n\t\t/*\n\t\t * Create a per-backend PGPROC struct in shared memory. We must do\n\t\t * this before we can use LWLocks. In the !EXEC_BACKEND case (here)\n\t\t * this could be delayed a bit further, but EXEC_BACKEND needs to do\n\t\t * stuff with LWLocks before PostgresMain(), so we do it here as well\n\t\t * for symmetry.\n\t\t */\n\t\tInitProcess();\n\n\t\t/* And run the backend */\n\t\tBackendRun(port);\n\t}\n#endif\t\t\t\t\t\t\t/* EXEC_BACKEND */\n\n\tif (pid < 0)\n\t{\n\t\t/* in parent, fork failed */\n\t\tint\t\t\tsave_errno = errno;\n\n\t\tif (!bn->dead_end)\n\t\t\t(void) ReleasePostmasterChildSlot(bn->child_slot);\n\t\tfree(bn);\n\t\terrno = save_errno;\n\t\tereport(LOG,\n\t\t\t\t(errmsg(\"could not fork new process for connection: %m\")));\n\t\treport_fork_failure_to_client(port, save_errno);\n\t\treturn STATUS_ERROR;\n\t}\n\n\t/* in parent, successful fork */\n\tereport(DEBUG2,\n\t\t\t(errmsg_internal(\"forked new backend, pid=%d socket=%d\",\n\t\t\t\t\t\t\t (int) pid, (int) port->sock)));\n\n\t/*\n\t * Everything's been successful, it's safe to add this backend to our list\n\t * of backends.\n\t */\n\tbn->pid = pid;\n\tbn->bkend_type = BACKEND_TYPE_NORMAL;\t/* Can change later to WALSND */\n\tdlist_push_head(&BackendList, &bn->elem);\n\n#ifdef EXEC_BACKEND\n\tif (!bn->dead_end)\n\t\tShmemBackendArrayAdd(bn);\n#endif\n\n\treturn STATUS_OK;\n}\n\n/*\n * Try to report backend fork() failure to client before we close the\n * connection.  Since we do not care to risk blocking the postmaster on\n * this connection, we set the connection to non-blocking and try only once.\n *\n * This is grungy special-purpose code; we cannot use backend libpq since\n * it's not up and running.\n */\nstatic void\nreport_fork_failure_to_client(Port *port, int errnum)\n{\n\tchar\t\tbuffer[1000];\n\tint\t\t\trc;\n\n\t/* Format the error message packet (always V2 protocol) */\n\tsnprintf(buffer, sizeof(buffer), \"E%s%s\\n\",\n\t\t\t _(\"could not fork new process for connection: \"),\n\t\t\t strerror(errnum));\n\n\t/* Set port to non-blocking.  Don't do send() if this fails */\n\tif (!pg_set_noblock(port->sock))\n\t\treturn;\n\n\t/* We'll retry after EINTR, but ignore all other failures */\n\tdo\n\t{\n\t\trc = send(port->sock, buffer, strlen(buffer) + 1, 0);\n\t} while (rc < 0 && errno == EINTR);\n}\n\n\n/*\n * BackendInitialize -- initialize an interactive (postmaster-child)\n *\t\t\t\tbackend process, and collect the client's startup packet.\n *\n * returns: nothing.  Will not return at all if there's any failure.\n *\n * Note: this code does not depend on having any access to shared memory.\n * Indeed, our approach to SIGTERM/timeout handling *requires* that\n * shared memory not have been touched yet; see comments within.\n * In the EXEC_BACKEND case, we are physically attached to shared memory\n * but have not yet set up most of our local pointers to shmem structures.\n */\nstatic void\nBackendInitialize(Port *port)\n{\n\tint\t\t\tstatus;\n\tint\t\t\tret;\n\tchar\t\tremote_host[NI_MAXHOST];\n\tchar\t\tremote_port[NI_MAXSERV];\n\tStringInfoData ps_data;\n\n\t/* Save port etc. for ps status */\n\tMyProcPort = port;\n\n\t/* Tell fd.c about the long-lived FD associated with the port */\n\tReserveExternalFD();\n\n\t/*\n\t * PreAuthDelay is a debugging aid for investigating problems in the\n\t * authentication cycle: it can be set in postgresql.conf to allow time to\n\t * attach to the newly-forked backend with a debugger.  (See also\n\t * PostAuthDelay, which we allow clients to pass through PGOPTIONS, but it\n\t * is not honored until after authentication.)\n\t */\n\tif (PreAuthDelay > 0)\n\t\tpg_usleep(PreAuthDelay * 1000000L);\n\n\t/* This flag will remain set until InitPostgres finishes authentication */\n\tClientAuthInProgress = true;\t/* limit visibility of log messages */\n\n\t/* set these to empty in case they are needed before we set them up */\n\tport->remote_host = \"\";\n\tport->remote_port = \"\";\n\n\t/*\n\t * Initialize libpq and enable reporting of ereport errors to the client.\n\t * Must do this now because authentication uses libpq to send messages.\n\t */\n\tpq_init();\t\t\t\t\t/* initialize libpq to talk to client */\n\twhereToSendOutput = DestRemote; /* now safe to ereport to client */\n\n\t/*\n\t * We arrange to do _exit(1) if we receive SIGTERM or timeout while trying\n\t * to collect the startup packet; while SIGQUIT results in _exit(2).\n\t * Otherwise the postmaster cannot shutdown the database FAST or IMMED\n\t * cleanly if a buggy client fails to send the packet promptly.\n\t *\n\t * Exiting with _exit(1) is only possible because we have not yet touched\n\t * shared memory; therefore no outside-the-process state needs to get\n\t * cleaned up.\n\t */\n\tpqsignal(SIGTERM, process_startup_packet_die);\n\t/* SIGQUIT handler was already set up by InitPostmasterChild */\n\tInitializeTimeouts();\t\t/* establishes SIGALRM handler */\n\tPG_SETMASK(&StartupBlockSig);\n\n\t/*\n\t * Get the remote host name and port for logging and status display.\n\t */\n\tremote_host[0] = '\\0';\n\tremote_port[0] = '\\0';\n\tif ((ret = pg_getnameinfo_all(&port->raddr.addr, port->raddr.salen,\n\t\t\t\t\t\t\t\t  remote_host, sizeof(remote_host),\n\t\t\t\t\t\t\t\t  remote_port, sizeof(remote_port),\n\t\t\t\t\t\t\t\t  (log_hostname ? 0 : NI_NUMERICHOST) | NI_NUMERICSERV)) != 0)\n\t\tereport(WARNING,\n\t\t\t\t(errmsg_internal(\"pg_getnameinfo_all() failed: %s\",\n\t\t\t\t\t\t\t\t gai_strerror(ret))));\n\n\t/*\n\t * Save remote_host and remote_port in port structure (after this, they\n\t * will appear in log_line_prefix data for log messages).\n\t */\n\tport->remote_host = strdup(remote_host);\n\tport->remote_port = strdup(remote_port);\n\n\t/* And now we can issue the Log_connections message, if wanted */\n\tif (Log_connections)\n\t{\n\t\tif (remote_port[0])\n\t\t\tereport(LOG,\n\t\t\t\t\t(errmsg(\"connection received: host=%s port=%s\",\n\t\t\t\t\t\t\tremote_host,\n\t\t\t\t\t\t\tremote_port)));\n\t\telse\n\t\t\tereport(LOG,\n\t\t\t\t\t(errmsg(\"connection received: host=%s\",\n\t\t\t\t\t\t\tremote_host)));\n\t}\n\n\t/*\n\t * If we did a reverse lookup to name, we might as well save the results\n\t * rather than possibly repeating the lookup during authentication.\n\t *\n\t * Note that we don't want to specify NI_NAMEREQD above, because then we'd\n\t * get nothing useful for a client without an rDNS entry.  Therefore, we\n\t * must check whether we got a numeric IPv4 or IPv6 address, and not save\n\t * it into remote_hostname if so.  (This test is conservative and might\n\t * sometimes classify a hostname as numeric, but an error in that\n\t * direction is safe; it only results in a possible extra lookup.)\n\t */\n\tif (log_hostname &&\n\t\tret == 0 &&\n\t\tstrspn(remote_host, \"0123456789.\") < strlen(remote_host) &&\n\t\tstrspn(remote_host, \"0123456789ABCDEFabcdef:\") < strlen(remote_host))\n\t\tport->remote_hostname = strdup(remote_host);\n\n\t/*\n\t * Ready to begin client interaction.  We will give up and _exit(1) after\n\t * a time delay, so that a broken client can't hog a connection\n\t * indefinitely.  PreAuthDelay and any DNS interactions above don't count\n\t * against the time limit.\n\t *\n\t * Note: AuthenticationTimeout is applied here while waiting for the\n\t * startup packet, and then again in InitPostgres for the duration of any\n\t * authentication operations.  So a hostile client could tie up the\n\t * process for nearly twice AuthenticationTimeout before we kick him off.\n\t *\n\t * Note: because PostgresMain will call InitializeTimeouts again, the\n\t * registration of STARTUP_PACKET_TIMEOUT will be lost.  This is okay\n\t * since we never use it again after this function.\n\t */\n\tRegisterTimeout(STARTUP_PACKET_TIMEOUT, StartupPacketTimeoutHandler);\n\tenable_timeout_after(STARTUP_PACKET_TIMEOUT, AuthenticationTimeout * 1000);\n\n\t/*\n\t * Receive the startup packet (which might turn out to be a cancel request\n\t * packet).\n\t */\n\tstatus = ProcessStartupPacket(port, false, false);\n\n\t/*\n\t * Disable the timeout, and prevent SIGTERM again.\n\t */\n\tdisable_timeout(STARTUP_PACKET_TIMEOUT, false);\n\tPG_SETMASK(&BlockSig);\n\n\t/*\n\t * As a safety check that nothing in startup has yet performed\n\t * shared-memory modifications that would need to be undone if we had\n\t * exited through SIGTERM or timeout above, check that no on_shmem_exit\n\t * handlers have been registered yet.  (This isn't terribly bulletproof,\n\t * since someone might misuse an on_proc_exit handler for shmem cleanup,\n\t * but it's a cheap and helpful check.  We cannot disallow on_proc_exit\n\t * handlers unfortunately, since pq_init() already registered one.)\n\t */\n\tcheck_on_shmem_exit_lists_are_empty();\n\n\t/*\n\t * Stop here if it was bad or a cancel packet.  ProcessStartupPacket\n\t * already did any appropriate error reporting.\n\t */\n\tif (status != STATUS_OK)\n\t\tproc_exit(0);\n\n\t/*\n\t * Now that we have the user and database name, we can set the process\n\t * title for ps.  It's good to do this as early as possible in startup.\n\t */\n\tinitStringInfo(&ps_data);\n\tif (am_walsender)\n\t\tappendStringInfo(&ps_data, \"%s \", GetBackendTypeDesc(B_WAL_SENDER));\n\tappendStringInfo(&ps_data, \"%s \", port->user_name);\n\tif (!am_walsender)\n\t\tappendStringInfo(&ps_data, \"%s \", port->database_name);\n\tappendStringInfo(&ps_data, \"%s\", port->remote_host);\n\tif (port->remote_port[0] != '\\0')\n\t\tappendStringInfo(&ps_data, \"(%s)\", port->remote_port);\n\n\tinit_ps_display(ps_data.data);\n\tpfree(ps_data.data);\n\n\tset_ps_display(\"initializing\");\n}\n\n\n/*\n * BackendRun -- set up the backend's argument list and invoke PostgresMain()\n *\n * returns:\n *\t\tDoesn't return at all.\n */\nstatic void\nBackendRun(Port *port)\n{\n\t/*\n\t * Make sure we aren't in PostmasterContext anymore.  (We can't delete it\n\t * just yet, though, because InitPostgres will need the HBA data.)\n\t */\n\tMemoryContextSwitchTo(TopMemoryContext);\n\n\tPostgresMain(port->database_name, port->user_name);\n}\n\n\n#ifdef EXEC_BACKEND\n\n/*\n * postmaster_forkexec -- fork and exec a postmaster subprocess\n *\n * The caller must have set up the argv array already, except for argv[2]\n * which will be filled with the name of the temp variable file.\n *\n * Returns the child process PID, or -1 on fork failure (a suitable error\n * message has been logged on failure).\n *\n * All uses of this routine will dispatch to SubPostmasterMain in the\n * child process.\n */\npid_t\npostmaster_forkexec(int argc, char *argv[])\n{\n\tPort\t\tport;\n\n\t/* This entry point passes dummy values for the Port variables */\n\tmemset(&port, 0, sizeof(port));\n\treturn internal_forkexec(argc, argv, &port);\n}\n\n/*\n * backend_forkexec -- fork/exec off a backend process\n *\n * Some operating systems (WIN32) don't have fork() so we have to simulate\n * it by storing parameters that need to be passed to the child and\n * then create a new child process.\n *\n * returns the pid of the fork/exec'd process, or -1 on failure\n */\nstatic pid_t\nbackend_forkexec(Port *port)\n{\n\tchar\t   *av[4];\n\tint\t\t\tac = 0;\n\n\tav[ac++] = \"postgres\";\n\tav[ac++] = \"--forkbackend\";\n\tav[ac++] = NULL;\t\t\t/* filled in by internal_forkexec */\n\n\tav[ac] = NULL;\n\tAssert(ac < lengthof(av));\n\n\treturn internal_forkexec(ac, av, port);\n}\n\n#ifndef WIN32\n\n/*\n * internal_forkexec non-win32 implementation\n *\n * - writes out backend variables to the parameter file\n * - fork():s, and then exec():s the child process\n */\nstatic pid_t\ninternal_forkexec(int argc, char *argv[], Port *port)\n{\n\tstatic unsigned long tmpBackendFileNum = 0;\n\tpid_t\t\tpid;\n\tchar\t\ttmpfilename[MAXPGPATH];\n\tBackendParameters param;\n\tFILE\t   *fp;\n\n\tif (!save_backend_variables(&param, port))\n\t\treturn -1;\t\t\t\t/* log made by save_backend_variables */\n\n\t/* Calculate name for temp file */\n\tsnprintf(tmpfilename, MAXPGPATH, \"%s/%s.backend_var.%d.%lu\",\n\t\t\t PG_TEMP_FILES_DIR, PG_TEMP_FILE_PREFIX,\n\t\t\t MyProcPid, ++tmpBackendFileNum);\n\n\t/* Open file */\n\tfp = AllocateFile(tmpfilename, PG_BINARY_W);\n\tif (!fp)\n\t{\n\t\t/*\n\t\t * As in OpenTemporaryFileInTablespace, try to make the temp-file\n\t\t * directory, ignoring errors.\n\t\t */\n\t\t(void) MakePGDirectory(PG_TEMP_FILES_DIR);\n\n\t\tfp = AllocateFile(tmpfilename, PG_BINARY_W);\n\t\tif (!fp)\n\t\t{\n\t\t\tereport(LOG,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not create file \\\"%s\\\": %m\",\n\t\t\t\t\t\t\ttmpfilename)));\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (fwrite(&param, sizeof(param), 1, fp) != 1)\n\t{\n\t\tereport(LOG,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write to file \\\"%s\\\": %m\", tmpfilename)));\n\t\tFreeFile(fp);\n\t\treturn -1;\n\t}\n\n\t/* Release file */\n\tif (FreeFile(fp))\n\t{\n\t\tereport(LOG,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write to file \\\"%s\\\": %m\", tmpfilename)));\n\t\treturn -1;\n\t}\n\n\t/* Make sure caller set up argv properly */\n\tAssert(argc >= 3);\n\tAssert(argv[argc] == NULL);\n\tAssert(strncmp(argv[1], \"--fork\", 6) == 0);\n\tAssert(argv[2] == NULL);\n\n\t/* Insert temp file name after --fork argument */\n\targv[2] = tmpfilename;\n\n\t/* Fire off execv in child */\n\tif ((pid = fork_process()) == 0)\n\t{\n\t\tif (execv(postgres_exec_path, argv) < 0)\n\t\t{\n\t\t\tereport(LOG,\n\t\t\t\t\t(errmsg(\"could not execute server process \\\"%s\\\": %m\",\n\t\t\t\t\t\t\tpostgres_exec_path)));\n\t\t\t/* We're already in the child process here, can't return */\n\t\t\texit(1);\n\t\t}\n\t}\n\n\treturn pid;\t\t\t\t\t/* Parent returns pid, or -1 on fork failure */\n}\n#else\t\t\t\t\t\t\t/* WIN32 */\n\n/*\n * internal_forkexec win32 implementation\n *\n * - starts backend using CreateProcess(), in suspended state\n * - writes out backend variables to the parameter file\n *\t- during this, duplicates handles and sockets required for\n *\t  inheritance into the new process\n * - resumes execution of the new process once the backend parameter\n *\t file is complete.\n */\nstatic pid_t\ninternal_forkexec(int argc, char *argv[], Port *port)\n{\n\tint\t\t\tretry_count = 0;\n\tSTARTUPINFO si;\n\tPROCESS_INFORMATION pi;\n\tint\t\t\ti;\n\tint\t\t\tj;\n\tchar\t\tcmdLine[MAXPGPATH * 2];\n\tHANDLE\t\tparamHandle;\n\tBackendParameters *param;\n\tSECURITY_ATTRIBUTES sa;\n\tchar\t\tparamHandleStr[32];\n\twin32_deadchild_waitinfo *childinfo;\n\n\t/* Make sure caller set up argv properly */\n\tAssert(argc >= 3);\n\tAssert(argv[argc] == NULL);\n\tAssert(strncmp(argv[1], \"--fork\", 6) == 0);\n\tAssert(argv[2] == NULL);\n\n\t/* Resume here if we need to retry */\nretry:\n\n\t/* Set up shared memory for parameter passing */\n\tZeroMemory(&sa, sizeof(sa));\n\tsa.nLength = sizeof(sa);\n\tsa.bInheritHandle = TRUE;\n\tparamHandle = CreateFileMapping(INVALID_HANDLE_VALUE,\n\t\t\t\t\t\t\t\t\t&sa,\n\t\t\t\t\t\t\t\t\tPAGE_READWRITE,\n\t\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t\tsizeof(BackendParameters),\n\t\t\t\t\t\t\t\t\tNULL);\n\tif (paramHandle == INVALID_HANDLE_VALUE)\n\t{\n\t\tereport(LOG,\n\t\t\t\t(errmsg(\"could not create backend parameter file mapping: error code %lu\",\n\t\t\t\t\t\tGetLastError())));\n\t\treturn -1;\n\t}\n\n\tparam = MapViewOfFile(paramHandle, FILE_MAP_WRITE, 0, 0, sizeof(BackendParameters));\n\tif (!param)\n\t{\n\t\tereport(LOG,\n\t\t\t\t(errmsg(\"could not map backend parameter memory: error code %lu\",\n\t\t\t\t\t\tGetLastError())));\n\t\tCloseHandle(paramHandle);\n\t\treturn -1;\n\t}\n\n\t/* Insert temp file name after --fork argument */\n#ifdef _WIN64\n\tsprintf(paramHandleStr, \"%llu\", (LONG_PTR) paramHandle);\n#else\n\tsprintf(paramHandleStr, \"%lu\", (DWORD) paramHandle);\n#endif\n\targv[2] = paramHandleStr;\n\n\t/* Format the cmd line */\n\tcmdLine[sizeof(cmdLine) - 1] = '\\0';\n\tcmdLine[sizeof(cmdLine) - 2] = '\\0';\n\tsnprintf(cmdLine, sizeof(cmdLine) - 1, \"\\\"%s\\\"\", postgres_exec_path);\n\ti = 0;\n\twhile (argv[++i] != NULL)\n\t{\n\t\tj = strlen(cmdLine);\n\t\tsnprintf(cmdLine + j, sizeof(cmdLine) - 1 - j, \" \\\"%s\\\"\", argv[i]);\n\t}\n\tif (cmdLine[sizeof(cmdLine) - 2] != '\\0')\n\t{\n\t\tereport(LOG,\n\t\t\t\t(errmsg(\"subprocess command line too long\")));\n\t\tUnmapViewOfFile(param);\n\t\tCloseHandle(paramHandle);\n\t\treturn -1;\n\t}\n\n\tmemset(&pi, 0, sizeof(pi));\n\tmemset(&si, 0, sizeof(si));\n\tsi.cb = sizeof(si);\n\n\t/*\n\t * Create the subprocess in a suspended state. This will be resumed later,\n\t * once we have written out the parameter file.\n\t */\n\tif (!CreateProcess(NULL, cmdLine, NULL, NULL, TRUE, CREATE_SUSPENDED,\n\t\t\t\t\t   NULL, NULL, &si, &pi))\n\t{\n\t\tereport(LOG,\n\t\t\t\t(errmsg(\"CreateProcess() call failed: %m (error code %lu)\",\n\t\t\t\t\t\tGetLastError())));\n\t\tUnmapViewOfFile(param);\n\t\tCloseHandle(paramHandle);\n\t\treturn -1;\n\t}\n\n\tif (!save_backend_variables(param, port, pi.hProcess, pi.dwProcessId))\n\t{\n\t\t/*\n\t\t * log made by save_backend_variables, but we have to clean up the\n\t\t * mess with the half-started process\n\t\t */\n\t\tif (!TerminateProcess(pi.hProcess, 255))\n\t\t\tereport(LOG,\n\t\t\t\t\t(errmsg_internal(\"could not terminate unstarted process: error code %lu\",\n\t\t\t\t\t\t\t\t\t GetLastError())));\n\t\tCloseHandle(pi.hProcess);\n\t\tCloseHandle(pi.hThread);\n\t\tUnmapViewOfFile(param);\n\t\tCloseHandle(paramHandle);\n\t\treturn -1;\t\t\t\t/* log made by save_backend_variables */\n\t}\n\n\t/* Drop the parameter shared memory that is now inherited to the backend */\n\tif (!UnmapViewOfFile(param))\n\t\tereport(LOG,\n\t\t\t\t(errmsg(\"could not unmap view of backend parameter file: error code %lu\",\n\t\t\t\t\t\tGetLastError())));\n\tif (!CloseHandle(paramHandle))\n\t\tereport(LOG,\n\t\t\t\t(errmsg(\"could not close handle to backend parameter file: error code %lu\",\n\t\t\t\t\t\tGetLastError())));\n\n\t/*\n\t * Reserve the memory region used by our main shared memory segment before\n\t * we resume the child process.  Normally this should succeed, but if ASLR\n\t * is active then it might sometimes fail due to the stack or heap having\n\t * gotten mapped into that range.  In that case, just terminate the\n\t * process and retry.\n\t */\n\tif (!pgwin32_ReserveSharedMemoryRegion(pi.hProcess))\n\t{\n\t\t/* pgwin32_ReserveSharedMemoryRegion already made a log entry */\n\t\tif (!TerminateProcess(pi.hProcess, 255))\n\t\t\tereport(LOG,\n\t\t\t\t\t(errmsg_internal(\"could not terminate process that failed to reserve memory: error code %lu\",\n\t\t\t\t\t\t\t\t\t GetLastError())));\n\t\tCloseHandle(pi.hProcess);\n\t\tCloseHandle(pi.hThread);\n\t\tif (++retry_count < 100)\n\t\t\tgoto retry;\n\t\tereport(LOG,\n\t\t\t\t(errmsg(\"giving up after too many tries to reserve shared memory\"),\n\t\t\t\t errhint(\"This might be caused by ASLR or antivirus software.\")));\n\t\treturn -1;\n\t}\n\n\t/*\n\t * Now that the backend variables are written out, we start the child\n\t * thread so it can start initializing while we set up the rest of the\n\t * parent state.\n\t */\n\tif (ResumeThread(pi.hThread) == -1)\n\t{\n\t\tif (!TerminateProcess(pi.hProcess, 255))\n\t\t{\n\t\t\tereport(LOG,\n\t\t\t\t\t(errmsg_internal(\"could not terminate unstartable process: error code %lu\",\n\t\t\t\t\t\t\t\t\t GetLastError())));\n\t\t\tCloseHandle(pi.hProcess);\n\t\t\tCloseHandle(pi.hThread);\n\t\t\treturn -1;\n\t\t}\n\t\tCloseHandle(pi.hProcess);\n\t\tCloseHandle(pi.hThread);\n\t\tereport(LOG,\n\t\t\t\t(errmsg_internal(\"could not resume thread of unstarted process: error code %lu\",\n\t\t\t\t\t\t\t\t GetLastError())));\n\t\treturn -1;\n\t}\n\n\t/*\n\t * Queue a waiter to signal when this child dies. The wait will be handled\n\t * automatically by an operating system thread pool.\n\t *\n\t * Note: use malloc instead of palloc, since it needs to be thread-safe.\n\t * Struct will be free():d from the callback function that runs on a\n\t * different thread.\n\t */\n\tchildinfo = malloc(sizeof(win32_deadchild_waitinfo));\n\tif (!childinfo)\n\t\tereport(FATAL,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\")));\n\n\tchildinfo->procHandle = pi.hProcess;\n\tchildinfo->procId = pi.dwProcessId;\n\n\tif (!RegisterWaitForSingleObject(&childinfo->waitHandle,\n\t\t\t\t\t\t\t\t\t pi.hProcess,\n\t\t\t\t\t\t\t\t\t pgwin32_deadchild_callback,\n\t\t\t\t\t\t\t\t\t childinfo,\n\t\t\t\t\t\t\t\t\t INFINITE,\n\t\t\t\t\t\t\t\t\t WT_EXECUTEONLYONCE | WT_EXECUTEINWAITTHREAD))\n\t\tereport(FATAL,\n\t\t\t\t(errmsg_internal(\"could not register process for wait: error code %lu\",\n\t\t\t\t\t\t\t\t GetLastError())));\n\n\t/* Don't close pi.hProcess here - the wait thread needs access to it */\n\n\tCloseHandle(pi.hThread);\n\n\treturn pi.dwProcessId;\n}\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\n\n/*\n * SubPostmasterMain -- Get the fork/exec'd process into a state equivalent\n *\t\t\tto what it would be if we'd simply forked on Unix, and then\n *\t\t\tdispatch to the appropriate place.\n *\n * The first two command line arguments are expected to be \"--forkFOO\"\n * (where FOO indicates which postmaster child we are to become), and\n * the name of a variables file that we can read to load data that would\n * have been inherited by fork() on Unix.  Remaining arguments go to the\n * subprocess FooMain() routine.\n */\nvoid\nSubPostmasterMain(int argc, char *argv[])\n{\n\tPort\t\tport;\n\n\t/* In EXEC_BACKEND case we will not have inherited these settings */\n\tIsPostmasterEnvironment = true;\n\twhereToSendOutput = DestNone;\n\n\t/* Setup essential subsystems (to ensure elog() behaves sanely) */\n\tInitializeGUCOptions();\n\n\t/* Check we got appropriate args */\n\tif (argc < 3)\n\t\telog(FATAL, \"invalid subpostmaster invocation\");\n\n\t/* Read in the variables file */\n\tmemset(&port, 0, sizeof(Port));\n\tread_backend_variables(argv[2], &port);\n\n\t/* Close the postmaster's sockets (as soon as we know them) */\n\tClosePostmasterPorts(strcmp(argv[1], \"--forklog\") == 0);\n\n\t/* Setup as postmaster child */\n\tInitPostmasterChild();\n\n\t/*\n\t * If appropriate, physically re-attach to shared memory segment. We want\n\t * to do this before going any further to ensure that we can attach at the\n\t * same address the postmaster used.  On the other hand, if we choose not\n\t * to re-attach, we may have other cleanup to do.\n\t *\n\t * If testing EXEC_BACKEND on Linux, you should run this as root before\n\t * starting the postmaster:\n\t *\n\t * echo 0 >/proc/sys/kernel/randomize_va_space\n\t *\n\t * This prevents using randomized stack and code addresses that cause the\n\t * child process's memory map to be different from the parent's, making it\n\t * sometimes impossible to attach to shared memory at the desired address.\n\t * Return the setting to its old value (usually '1' or '2') when finished.\n\t */\n\tif (strcmp(argv[1], \"--forkbackend\") == 0 ||\n\t\tstrcmp(argv[1], \"--forkavlauncher\") == 0 ||\n\t\tstrcmp(argv[1], \"--forkavworker\") == 0 ||\n\t\tstrcmp(argv[1], \"--forkaux\") == 0 ||\n\t\tstrncmp(argv[1], \"--forkbgworker=\", 15) == 0)\n\t\tPGSharedMemoryReAttach();\n\telse\n\t\tPGSharedMemoryNoReAttach();\n\n\t/* autovacuum needs this set before calling InitProcess */\n\tif (strcmp(argv[1], \"--forkavlauncher\") == 0)\n\t\tAutovacuumLauncherIAm();\n\tif (strcmp(argv[1], \"--forkavworker\") == 0)\n\t\tAutovacuumWorkerIAm();\n\n\t/* Read in remaining GUC variables */\n\tread_nondefault_variables();\n\n\t/*\n\t * Check that the data directory looks valid, which will also check the\n\t * privileges on the data directory and update our umask and file/group\n\t * variables for creating files later.  Note: this should really be done\n\t * before we create any files or directories.\n\t */\n\tcheckDataDir();\n\n\t/*\n\t * (re-)read control file, as it contains config. The postmaster will\n\t * already have read this, but this process doesn't know about that.\n\t */\n\tLocalProcessControlFile(false);\n\n\t/*\n\t * Reload any libraries that were preloaded by the postmaster.  Since we\n\t * exec'd this process, those libraries didn't come along with us; but we\n\t * should load them into all child processes to be consistent with the\n\t * non-EXEC_BACKEND behavior.\n\t */\n\tprocess_shared_preload_libraries();\n\n\t/* Run backend or appropriate child */\n\tif (strcmp(argv[1], \"--forkbackend\") == 0)\n\t{\n\t\tAssert(argc == 3);\t\t/* shouldn't be any more args */\n\n\t\t/*\n\t\t * Need to reinitialize the SSL library in the backend, since the\n\t\t * context structures contain function pointers and cannot be passed\n\t\t * through the parameter file.\n\t\t *\n\t\t * If for some reason reload fails (maybe the user installed broken\n\t\t * key files), soldier on without SSL; that's better than all\n\t\t * connections becoming impossible.\n\t\t *\n\t\t * XXX should we do this in all child processes?  For the moment it's\n\t\t * enough to do it in backend children.\n\t\t */\n#ifdef USE_SSL\n\t\tif (EnableSSL)\n\t\t{\n\t\t\tif (secure_initialize(false) == 0)\n\t\t\t\tLoadedSSL = true;\n\t\t\telse\n\t\t\t\tereport(LOG,\n\t\t\t\t\t\t(errmsg(\"SSL configuration could not be loaded in child process\")));\n\t\t}\n#endif\n\n\t\t/*\n\t\t * Perform additional initialization and collect startup packet.\n\t\t *\n\t\t * We want to do this before InitProcess() for a couple of reasons: 1.\n\t\t * so that we aren't eating up a PGPROC slot while waiting on the\n\t\t * client. 2. so that if InitProcess() fails due to being out of\n\t\t * PGPROC slots, we have already initialized libpq and are able to\n\t\t * report the error to the client.\n\t\t */\n\t\tBackendInitialize(&port);\n\n\t\t/* Restore basic shared memory pointers */\n\t\tInitShmemAccess(UsedShmemSegAddr);\n\n\t\t/* Need a PGPROC to run CreateSharedMemoryAndSemaphores */\n\t\tInitProcess();\n\n\t\t/* Attach process to shared data structures */\n\t\tCreateSharedMemoryAndSemaphores();\n\n\t\t/* And run the backend */\n\t\tBackendRun(&port);\t\t/* does not return */\n\t}\n\tif (strcmp(argv[1], \"--forkaux\") == 0)\n\t{\n\t\tAuxProcType auxtype;\n\n\t\tAssert(argc == 4);\n\n\t\t/* Restore basic shared memory pointers */\n\t\tInitShmemAccess(UsedShmemSegAddr);\n\n\t\t/* Need a PGPROC to run CreateSharedMemoryAndSemaphores */\n\t\tInitAuxiliaryProcess();\n\n\t\t/* Attach process to shared data structures */\n\t\tCreateSharedMemoryAndSemaphores();\n\n\t\tauxtype = atoi(argv[3]);\n\t\tAuxiliaryProcessMain(auxtype);\t/* does not return */\n\t}\n\tif (strcmp(argv[1], \"--forkavlauncher\") == 0)\n\t{\n\t\t/* Restore basic shared memory pointers */\n\t\tInitShmemAccess(UsedShmemSegAddr);\n\n\t\t/* Need a PGPROC to run CreateSharedMemoryAndSemaphores */\n\t\tInitProcess();\n\n\t\t/* Attach process to shared data structures */\n\t\tCreateSharedMemoryAndSemaphores();\n\n\t\tAutoVacLauncherMain(argc - 2, argv + 2);\t/* does not return */\n\t}\n\tif (strcmp(argv[1], \"--forkavworker\") == 0)\n\t{\n\t\t/* Restore basic shared memory pointers */\n\t\tInitShmemAccess(UsedShmemSegAddr);\n\n\t\t/* Need a PGPROC to run CreateSharedMemoryAndSemaphores */\n\t\tInitProcess();\n\n\t\t/* Attach process to shared data structures */\n\t\tCreateSharedMemoryAndSemaphores();\n\n\t\tAutoVacWorkerMain(argc - 2, argv + 2);\t/* does not return */\n\t}\n\tif (strncmp(argv[1], \"--forkbgworker=\", 15) == 0)\n\t{\n\t\tint\t\t\tshmem_slot;\n\n\t\t/* do this as early as possible; in particular, before InitProcess() */\n\t\tIsBackgroundWorker = true;\n\n\t\t/* Restore basic shared memory pointers */\n\t\tInitShmemAccess(UsedShmemSegAddr);\n\n\t\t/* Need a PGPROC to run CreateSharedMemoryAndSemaphores */\n\t\tInitProcess();\n\n\t\t/* Attach process to shared data structures */\n\t\tCreateSharedMemoryAndSemaphores();\n\n\t\t/* Fetch MyBgworkerEntry from shared memory */\n\t\tshmem_slot = atoi(argv[1] + 15);\n\t\tMyBgworkerEntry = BackgroundWorkerEntry(shmem_slot);\n\n\t\tStartBackgroundWorker();\n\t}\n\tif (strcmp(argv[1], \"--forkcol\") == 0)\n\t{\n\t\t/* Do not want to attach to shared memory */\n\n\t\tPgstatCollectorMain(argc, argv);\t/* does not return */\n\t}\n\tif (strcmp(argv[1], \"--forklog\") == 0)\n\t{\n\t\t/* Do not want to attach to shared memory */\n\n\t\tSysLoggerMain(argc, argv);\t/* does not return */\n\t}\n\n\tabort();\t\t\t\t\t/* shouldn't get here */\n}\n#endif\t\t\t\t\t\t\t/* EXEC_BACKEND */\n\n\n/*\n * ExitPostmaster -- cleanup\n *\n * Do NOT call exit() directly --- always go through here!\n */\nstatic void\nExitPostmaster(int status)\n{\n#ifdef HAVE_PTHREAD_IS_THREADED_NP\n\n\t/*\n\t * There is no known cause for a postmaster to become multithreaded after\n\t * startup.  Recheck to account for the possibility of unknown causes.\n\t * This message uses LOG level, because an unclean shutdown at this point\n\t * would usually not look much different from a clean shutdown.\n\t */\n\tif (pthread_is_threaded_np() != 0)\n\t\tereport(LOG,\n\t\t\t\t(errcode(ERRCODE_INTERNAL_ERROR),\n\t\t\t\t errmsg_internal(\"postmaster became multithreaded\"),\n\t\t\t\t errdetail(\"Please report this to <%s>.\", PACKAGE_BUGREPORT)));\n#endif\n\n\t/* should cleanup shared memory and kill all backends */\n\n\t/*\n\t * Not sure of the semantics here.  When the Postmaster dies, should the\n\t * backends all be killed? probably not.\n\t *\n\t * MUST\t\t-- vadim 05-10-1999\n\t */\n\n\tproc_exit(status);\n}\n\n/*\n * sigusr1_handler - handle signal conditions from child processes\n */\nstatic void\nsigusr1_handler(SIGNAL_ARGS)\n{\n\tint\t\t\tsave_errno = errno;\n\n\t/*\n\t * We rely on the signal mechanism to have blocked all signals ... except\n\t * on Windows, which lacks sigaction(), so we have to do it manually.\n\t */\n#ifdef WIN32\n\tPG_SETMASK(&BlockSig);\n#endif\n\n\t/*\n\t * RECOVERY_STARTED and BEGIN_HOT_STANDBY signals are ignored in\n\t * unexpected states. If the startup process quickly starts up, completes\n\t * recovery, exits, we might process the death of the startup process\n\t * first. We don't want to go back to recovery in that case.\n\t */\n\tif (CheckPostmasterSignal(PMSIGNAL_RECOVERY_STARTED) &&\n\t\tpmState == PM_STARTUP && Shutdown == NoShutdown)\n\t{\n\t\t/* WAL redo has started. We're out of reinitialization. */\n\t\tFatalError = false;\n\t\tAbortStartTime = 0;\n\n\t\t/*\n\t\t * Start the archiver if we're responsible for (re-)archiving received\n\t\t * files.\n\t\t */\n\t\tAssert(PgArchPID == 0);\n\t\tif (XLogArchivingAlways())\n\t\t\tPgArchPID = StartArchiver();\n\n\t\t/*\n\t\t * If we aren't planning to enter hot standby mode later, treat\n\t\t * RECOVERY_STARTED as meaning we're out of startup, and report status\n\t\t * accordingly.\n\t\t */\n\t\tif (!EnableHotStandby)\n\t\t{\n\t\t\tAddToDataDirLockFile(LOCK_FILE_LINE_PM_STATUS, PM_STATUS_STANDBY);\n#ifdef USE_SYSTEMD\n\t\t\tsd_notify(0, \"READY=1\");\n#endif\n\t\t}\n\n\t\tpmState = PM_RECOVERY;\n\t}\n\n\tif (CheckPostmasterSignal(PMSIGNAL_BEGIN_HOT_STANDBY) &&\n\t\tpmState == PM_RECOVERY && Shutdown == NoShutdown)\n\t{\n\t\t/*\n\t\t * Likewise, start other special children as needed.\n\t\t */\n\t\tAssert(PgStatPID == 0);\n\t\tPgStatPID = pgstat_start();\n\n\t\tereport(LOG,\n\t\t\t\t(errmsg(\"database system is ready to accept read-only connections\")));\n\n\t\t/* Report status */\n\t\tAddToDataDirLockFile(LOCK_FILE_LINE_PM_STATUS, PM_STATUS_READY);\n#ifdef USE_SYSTEMD\n\t\tsd_notify(0, \"READY=1\");\n#endif\n\n\t\tpmState = PM_HOT_STANDBY;\n\t\tconnsAllowed = ALLOW_ALL_CONNS;\n\n\t\t/* Some workers may be scheduled to start now */\n\t\tStartWorkerNeeded = true;\n\t}\n\n\t/* Process background worker state changes. */\n\tif (CheckPostmasterSignal(PMSIGNAL_BACKGROUND_WORKER_CHANGE))\n\t{\n\t\t/* Accept new worker requests only if not stopping. */\n\t\tBackgroundWorkerStateChange(pmState < PM_STOP_BACKENDS);\n\t\tStartWorkerNeeded = true;\n\t}\n\n\tif (StartWorkerNeeded || HaveCrashedWorker)\n\t\tmaybe_start_bgworkers();\n\n\t/* Tell syslogger to rotate logfile if requested */\n\tif (SysLoggerPID != 0)\n\t{\n\t\tif (CheckLogrotateSignal())\n\t\t{\n\t\t\tsignal_child(SysLoggerPID, SIGUSR1);\n\t\t\tRemoveLogrotateSignalFiles();\n\t\t}\n\t\telse if (CheckPostmasterSignal(PMSIGNAL_ROTATE_LOGFILE))\n\t\t{\n\t\t\tsignal_child(SysLoggerPID, SIGUSR1);\n\t\t}\n\t}\n\n\tif (CheckPostmasterSignal(PMSIGNAL_START_AUTOVAC_LAUNCHER) &&\n\t\tShutdown <= SmartShutdown && pmState < PM_STOP_BACKENDS)\n\t{\n\t\t/*\n\t\t * Start one iteration of the autovacuum daemon, even if autovacuuming\n\t\t * is nominally not enabled.  This is so we can have an active defense\n\t\t * against transaction ID wraparound.  We set a flag for the main loop\n\t\t * to do it rather than trying to do it here --- this is because the\n\t\t * autovac process itself may send the signal, and we want to handle\n\t\t * that by launching another iteration as soon as the current one\n\t\t * completes.\n\t\t */\n\t\tstart_autovac_launcher = true;\n\t}\n\n\tif (CheckPostmasterSignal(PMSIGNAL_START_AUTOVAC_WORKER) &&\n\t\tShutdown <= SmartShutdown && pmState < PM_STOP_BACKENDS)\n\t{\n\t\t/* The autovacuum launcher wants us to start a worker process. */\n\t\tStartAutovacuumWorker();\n\t}\n\n\tif (CheckPostmasterSignal(PMSIGNAL_START_WALRECEIVER))\n\t{\n\t\t/* Startup Process wants us to start the walreceiver process. */\n\t\t/* Start immediately if possible, else remember request for later. */\n\t\tWalReceiverRequested = true;\n\t\tMaybeStartWalReceiver();\n\t}\n\n\t/*\n\t * Try to advance postmaster's state machine, if a child requests it.\n\t *\n\t * Be careful about the order of this action relative to sigusr1_handler's\n\t * other actions.  Generally, this should be after other actions, in case\n\t * they have effects PostmasterStateMachine would need to know about.\n\t * However, we should do it before the CheckPromoteSignal step, which\n\t * cannot have any (immediate) effect on the state machine, but does\n\t * depend on what state we're in now.\n\t */\n\tif (CheckPostmasterSignal(PMSIGNAL_ADVANCE_STATE_MACHINE))\n\t{\n\t\tPostmasterStateMachine();\n\t}\n\n\tif (StartupPID != 0 &&\n\t\t(pmState == PM_STARTUP || pmState == PM_RECOVERY ||\n\t\t pmState == PM_HOT_STANDBY) &&\n\t\tCheckPromoteSignal())\n\t{\n\t\t/*\n\t\t * Tell startup process to finish recovery.\n\t\t *\n\t\t * Leave the promote signal file in place and let the Startup process\n\t\t * do the unlink.\n\t\t */\n\t\tsignal_child(StartupPID, SIGUSR2);\n\t}\n\n#ifdef WIN32\n\tPG_SETMASK(&UnBlockSig);\n#endif\n\n\terrno = save_errno;\n}\n\n/*\n * SIGTERM while processing startup packet.\n *\n * Running proc_exit() from a signal handler would be quite unsafe.\n * However, since we have not yet touched shared memory, we can just\n * pull the plug and exit without running any atexit handlers.\n *\n * One might be tempted to try to send a message, or log one, indicating\n * why we are disconnecting.  However, that would be quite unsafe in itself.\n * Also, it seems undesirable to provide clues about the database's state\n * to a client that has not yet completed authentication, or even sent us\n * a startup packet.\n */\nstatic void\nprocess_startup_packet_die(SIGNAL_ARGS)\n{\n\t_exit(1);\n}\n\n/*\n * Dummy signal handler\n *\n * We use this for signals that we don't actually use in the postmaster,\n * but we do use in backends.  If we were to SIG_IGN such signals in the\n * postmaster, then a newly started backend might drop a signal that arrives\n * before it's able to reconfigure its signal processing.  (See notes in\n * tcop/postgres.c.)\n */\nstatic void\ndummy_handler(SIGNAL_ARGS)\n{\n}\n\n/*\n * Timeout while processing startup packet.\n * As for process_startup_packet_die(), we exit via _exit(1).\n */\nstatic void\nStartupPacketTimeoutHandler(void)\n{\n\t_exit(1);\n}\n\n\n/*\n * Generate a random cancel key.\n */\nstatic bool\nRandomCancelKey(int32 *cancel_key)\n{\n\treturn pg_strong_random(cancel_key, sizeof(int32));\n}\n\n/*\n * Count up number of child processes of specified types (dead_end children\n * are always excluded).\n */\nstatic int\nCountChildren(int target)\n{\n\tdlist_iter\titer;\n\tint\t\t\tcnt = 0;\n\n\tdlist_foreach(iter, &BackendList)\n\t{\n\t\tBackend    *bp = dlist_container(Backend, elem, iter.cur);\n\n\t\tif (bp->dead_end)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Since target == BACKEND_TYPE_ALL is the most common case, we test\n\t\t * it first and avoid touching shared memory for every child.\n\t\t */\n\t\tif (target != BACKEND_TYPE_ALL)\n\t\t{\n\t\t\t/*\n\t\t\t * Assign bkend_type for any recently announced WAL Sender\n\t\t\t * processes.\n\t\t\t */\n\t\t\tif (bp->bkend_type == BACKEND_TYPE_NORMAL &&\n\t\t\t\tIsPostmasterChildWalSender(bp->child_slot))\n\t\t\t\tbp->bkend_type = BACKEND_TYPE_WALSND;\n\n\t\t\tif (!(target & bp->bkend_type))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tcnt++;\n\t}\n\treturn cnt;\n}\n\n\n/*\n * StartChildProcess -- start an auxiliary process for the postmaster\n *\n * \"type\" determines what kind of child will be started.  All child types\n * initially go to AuxiliaryProcessMain, which will handle common setup.\n *\n * Return value of StartChildProcess is subprocess' PID, or 0 if failed\n * to start subprocess.\n */\nstatic pid_t\nStartChildProcess(AuxProcType type)\n{\n\tpid_t\t\tpid;\n\n#ifdef EXEC_BACKEND\n\t{\n\t\tchar\t   *av[10];\n\t\tint\t\t\tac = 0;\n\t\tchar\t\ttypebuf[32];\n\n\t\t/*\n\t\t * Set up command-line arguments for subprocess\n\t\t */\n\t\tav[ac++] = \"postgres\";\n\t\tav[ac++] = \"--forkaux\";\n\t\tav[ac++] = NULL;\t\t/* filled in by postmaster_forkexec */\n\n\t\tsnprintf(typebuf, sizeof(typebuf), \"%d\", type);\n\t\tav[ac++] = typebuf;\n\n\t\tav[ac] = NULL;\n\t\tAssert(ac < lengthof(av));\n\n\t\tpid = postmaster_forkexec(ac, av);\n\t}\n#else\t\t\t\t\t\t\t/* !EXEC_BACKEND */\n\tpid = fork_process();\n\n\tif (pid == 0)\t\t\t\t/* child */\n\t{\n\t\tInitPostmasterChild();\n\n\t\t/* Close the postmaster's sockets */\n\t\tClosePostmasterPorts(false);\n\n\t\t/* Release postmaster's working memory context */\n\t\tMemoryContextSwitchTo(TopMemoryContext);\n\t\tMemoryContextDelete(PostmasterContext);\n\t\tPostmasterContext = NULL;\n\n\t\tAuxiliaryProcessMain(type); /* does not return */\n\t}\n#endif\t\t\t\t\t\t\t/* EXEC_BACKEND */\n\n\tif (pid < 0)\n\t{\n\t\t/* in parent, fork failed */\n\t\tint\t\t\tsave_errno = errno;\n\n\t\terrno = save_errno;\n\t\tswitch (type)\n\t\t{\n\t\t\tcase StartupProcess:\n\t\t\t\tereport(LOG,\n\t\t\t\t\t\t(errmsg(\"could not fork startup process: %m\")));\n\t\t\t\tbreak;\n\t\t\tcase ArchiverProcess:\n\t\t\t\tereport(LOG,\n\t\t\t\t\t\t(errmsg(\"could not fork archiver process: %m\")));\n\t\t\t\tbreak;\n\t\t\tcase BgWriterProcess:\n\t\t\t\tereport(LOG,\n\t\t\t\t\t\t(errmsg(\"could not fork background writer process: %m\")));\n\t\t\t\tbreak;\n\t\t\tcase CheckpointerProcess:\n\t\t\t\tereport(LOG,\n\t\t\t\t\t\t(errmsg(\"could not fork checkpointer process: %m\")));\n\t\t\t\tbreak;\n\t\t\tcase WalWriterProcess:\n\t\t\t\tereport(LOG,\n\t\t\t\t\t\t(errmsg(\"could not fork WAL writer process: %m\")));\n\t\t\t\tbreak;\n\t\t\tcase WalReceiverProcess:\n\t\t\t\tereport(LOG,\n\t\t\t\t\t\t(errmsg(\"could not fork WAL receiver process: %m\")));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tereport(LOG,\n\t\t\t\t\t\t(errmsg(\"could not fork process: %m\")));\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * fork failure is fatal during startup, but there's no need to choke\n\t\t * immediately if starting other child types fails.\n\t\t */\n\t\tif (type == StartupProcess)\n\t\t\tExitPostmaster(1);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * in parent, successful fork\n\t */\n\treturn pid;\n}\n\n/*\n * StartAutovacuumWorker\n *\t\tStart an autovac worker process.\n *\n * This function is here because it enters the resulting PID into the\n * postmaster's private backends list.\n *\n * NB -- this code very roughly matches BackendStartup.\n */\nstatic void\nStartAutovacuumWorker(void)\n{\n\tBackend    *bn;\n\n\t/*\n\t * If not in condition to run a process, don't try, but handle it like a\n\t * fork failure.  This does not normally happen, since the signal is only\n\t * supposed to be sent by autovacuum launcher when it's OK to do it, but\n\t * we have to check to avoid race-condition problems during DB state\n\t * changes.\n\t */\n\tif (canAcceptConnections(BACKEND_TYPE_AUTOVAC) == CAC_OK)\n\t{\n\t\t/*\n\t\t * Compute the cancel key that will be assigned to this session. We\n\t\t * probably don't need cancel keys for autovac workers, but we'd\n\t\t * better have something random in the field to prevent unfriendly\n\t\t * people from sending cancels to them.\n\t\t */\n\t\tif (!RandomCancelKey(&MyCancelKey))\n\t\t{\n\t\t\tereport(LOG,\n\t\t\t\t\t(errcode(ERRCODE_INTERNAL_ERROR),\n\t\t\t\t\t errmsg(\"could not generate random cancel key\")));\n\t\t\treturn;\n\t\t}\n\n\t\tbn = (Backend *) malloc(sizeof(Backend));\n\t\tif (bn)\n\t\t{\n\t\t\tbn->cancel_key = MyCancelKey;\n\n\t\t\t/* Autovac workers are not dead_end and need a child slot */\n\t\t\tbn->dead_end = false;\n\t\t\tbn->child_slot = MyPMChildSlot = AssignPostmasterChildSlot();\n\t\t\tbn->bgworker_notify = false;\n\n\t\t\tbn->pid = StartAutoVacWorker();\n\t\t\tif (bn->pid > 0)\n\t\t\t{\n\t\t\t\tbn->bkend_type = BACKEND_TYPE_AUTOVAC;\n\t\t\t\tdlist_push_head(&BackendList, &bn->elem);\n#ifdef EXEC_BACKEND\n\t\t\t\tShmemBackendArrayAdd(bn);\n#endif\n\t\t\t\t/* all OK */\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * fork failed, fall through to report -- actual error message was\n\t\t\t * logged by StartAutoVacWorker\n\t\t\t */\n\t\t\t(void) ReleasePostmasterChildSlot(bn->child_slot);\n\t\t\tfree(bn);\n\t\t}\n\t\telse\n\t\t\tereport(LOG,\n\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t errmsg(\"out of memory\")));\n\t}\n\n\t/*\n\t * Report the failure to the launcher, if it's running.  (If it's not, we\n\t * might not even be connected to shared memory, so don't try to call\n\t * AutoVacWorkerFailed.)  Note that we also need to signal it so that it\n\t * responds to the condition, but we don't do that here, instead waiting\n\t * for ServerLoop to do it.  This way we avoid a ping-pong signaling in\n\t * quick succession between the autovac launcher and postmaster in case\n\t * things get ugly.\n\t */\n\tif (AutoVacPID != 0)\n\t{\n\t\tAutoVacWorkerFailed();\n\t\tavlauncher_needs_signal = true;\n\t}\n}\n\n/*\n * MaybeStartWalReceiver\n *\t\tStart the WAL receiver process, if not running and our state allows.\n *\n * Note: if WalReceiverPID is already nonzero, it might seem that we should\n * clear WalReceiverRequested.  However, there's a race condition if the\n * walreceiver terminates and the startup process immediately requests a new\n * one: it's quite possible to get the signal for the request before reaping\n * the dead walreceiver process.  Better to risk launching an extra\n * walreceiver than to miss launching one we need.  (The walreceiver code\n * has logic to recognize that it should go away if not needed.)\n */\nstatic void\nMaybeStartWalReceiver(void)\n{\n\tif (WalReceiverPID == 0 &&\n\t\t(pmState == PM_STARTUP || pmState == PM_RECOVERY ||\n\t\t pmState == PM_HOT_STANDBY) &&\n\t\tShutdown <= SmartShutdown)\n\t{\n\t\tWalReceiverPID = StartWalReceiver();\n\t\tif (WalReceiverPID != 0)\n\t\t\tWalReceiverRequested = false;\n\t\t/* else leave the flag set, so we'll try again later */\n\t}\n}\n\n\n/*\n * Create the opts file\n */\nstatic bool\nCreateOptsFile(int argc, char *argv[], char *fullprogname)\n{\n\tFILE\t   *fp;\n\tint\t\t\ti;\n\n#define OPTS_FILE\t\"postmaster.opts\"\n\n\tif ((fp = fopen(OPTS_FILE, \"w\")) == NULL)\n\t{\n\t\tereport(LOG,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not create file \\\"%s\\\": %m\", OPTS_FILE)));\n\t\treturn false;\n\t}\n\n\tfprintf(fp, \"%s\", fullprogname);\n\tfor (i = 1; i < argc; i++)\n\t\tfprintf(fp, \" \\\"%s\\\"\", argv[i]);\n\tfputs(\"\\n\", fp);\n\n\tif (fclose(fp))\n\t{\n\t\tereport(LOG,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write file \\\"%s\\\": %m\", OPTS_FILE)));\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n\n/*\n * MaxLivePostmasterChildren\n *\n * This reports the number of entries needed in per-child-process arrays\n * (the PMChildFlags array, and if EXEC_BACKEND the ShmemBackendArray).\n * These arrays include regular backends, autovac workers, walsenders\n * and background workers, but not special children nor dead_end children.\n * This allows the arrays to have a fixed maximum size, to wit the same\n * too-many-children limit enforced by canAcceptConnections().  The exact value\n * isn't too critical as long as it's more than MaxBackends.\n */\nint\nMaxLivePostmasterChildren(void)\n{\n\treturn 2 * (MaxConnections + autovacuum_max_workers + 1 +\n\t\t\t\tmax_wal_senders + max_worker_processes);\n}\n\n/*\n * Connect background worker to a database.\n */\nvoid\nBackgroundWorkerInitializeConnection(const char *dbname, const char *username, uint32 flags)\n{\n\tBackgroundWorker *worker = MyBgworkerEntry;\n\n\t/* XXX is this the right errcode? */\n\tif (!(worker->bgw_flags & BGWORKER_BACKEND_DATABASE_CONNECTION))\n\t\tereport(FATAL,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"database connection requirement not indicated during registration\")));\n\n\tInitPostgres(dbname, InvalidOid, username, InvalidOid, NULL, (flags & BGWORKER_BYPASS_ALLOWCONN) != 0);\n\n\t/* it had better not gotten out of \"init\" mode yet */\n\tif (!IsInitProcessingMode())\n\t\tereport(ERROR,\n\t\t\t\t(errmsg(\"invalid processing mode in background worker\")));\n\tSetProcessingMode(NormalProcessing);\n}\n\n/*\n * Connect background worker to a database using OIDs.\n */\nvoid\nBackgroundWorkerInitializeConnectionByOid(Oid dboid, Oid useroid, uint32 flags)\n{\n\tBackgroundWorker *worker = MyBgworkerEntry;\n\n\t/* XXX is this the right errcode? */\n\tif (!(worker->bgw_flags & BGWORKER_BACKEND_DATABASE_CONNECTION))\n\t\tereport(FATAL,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"database connection requirement not indicated during registration\")));\n\n\tInitPostgres(NULL, dboid, NULL, useroid, NULL, (flags & BGWORKER_BYPASS_ALLOWCONN) != 0);\n\n\t/* it had better not gotten out of \"init\" mode yet */\n\tif (!IsInitProcessingMode())\n\t\tereport(ERROR,\n\t\t\t\t(errmsg(\"invalid processing mode in background worker\")));\n\tSetProcessingMode(NormalProcessing);\n}\n\n/*\n * Block/unblock signals in a background worker\n */\nvoid\nBackgroundWorkerBlockSignals(void)\n{\n\tPG_SETMASK(&BlockSig);\n}\n\nvoid\nBackgroundWorkerUnblockSignals(void)\n{\n\tPG_SETMASK(&UnBlockSig);\n}\n\n#ifdef EXEC_BACKEND\nstatic pid_t\nbgworker_forkexec(int shmem_slot)\n{\n\tchar\t   *av[10];\n\tint\t\t\tac = 0;\n\tchar\t\tforkav[MAXPGPATH];\n\n\tsnprintf(forkav, MAXPGPATH, \"--forkbgworker=%d\", shmem_slot);\n\n\tav[ac++] = \"postgres\";\n\tav[ac++] = forkav;\n\tav[ac++] = NULL;\t\t\t/* filled in by postmaster_forkexec */\n\tav[ac] = NULL;\n\n\tAssert(ac < lengthof(av));\n\n\treturn postmaster_forkexec(ac, av);\n}\n#endif\n\n/*\n * Start a new bgworker.\n * Starting time conditions must have been checked already.\n *\n * Returns true on success, false on failure.\n * In either case, update the RegisteredBgWorker's state appropriately.\n *\n * This code is heavily based on autovacuum.c, q.v.\n */\nstatic bool\ndo_start_bgworker(RegisteredBgWorker *rw)\n{\n\tpid_t\t\tworker_pid;\n\n\tAssert(rw->rw_pid == 0);\n\n\t/*\n\t * Allocate and assign the Backend element.  Note we must do this before\n\t * forking, so that we can handle failures (out of memory or child-process\n\t * slots) cleanly.\n\t *\n\t * Treat failure as though the worker had crashed.  That way, the\n\t * postmaster will wait a bit before attempting to start it again; if we\n\t * tried again right away, most likely we'd find ourselves hitting the\n\t * same resource-exhaustion condition.\n\t */\n\tif (!assign_backendlist_entry(rw))\n\t{\n\t\trw->rw_crashed_at = GetCurrentTimestamp();\n\t\treturn false;\n\t}\n\n\tereport(DEBUG1,\n\t\t\t(errmsg_internal(\"starting background worker process \\\"%s\\\"\",\n\t\t\t\t\t\t\t rw->rw_worker.bgw_name)));\n\n#ifdef EXEC_BACKEND\n\tswitch ((worker_pid = bgworker_forkexec(rw->rw_shmem_slot)))\n#else\n\tswitch ((worker_pid = fork_process()))\n#endif\n\t{\n\t\tcase -1:\n\t\t\t/* in postmaster, fork failed ... */\n\t\t\tereport(LOG,\n\t\t\t\t\t(errmsg(\"could not fork worker process: %m\")));\n\t\t\t/* undo what assign_backendlist_entry did */\n\t\t\tReleasePostmasterChildSlot(rw->rw_child_slot);\n\t\t\trw->rw_child_slot = 0;\n\t\t\tfree(rw->rw_backend);\n\t\t\trw->rw_backend = NULL;\n\t\t\t/* mark entry as crashed, so we'll try again later */\n\t\t\trw->rw_crashed_at = GetCurrentTimestamp();\n\t\t\tbreak;\n\n#ifndef EXEC_BACKEND\n\t\tcase 0:\n\t\t\t/* in postmaster child ... */\n\t\t\tInitPostmasterChild();\n\n\t\t\t/* Close the postmaster's sockets */\n\t\t\tClosePostmasterPorts(false);\n\n\t\t\t/*\n\t\t\t * Before blowing away PostmasterContext, save this bgworker's\n\t\t\t * data where it can find it.\n\t\t\t */\n\t\t\tMyBgworkerEntry = (BackgroundWorker *)\n\t\t\t\tMemoryContextAlloc(TopMemoryContext, sizeof(BackgroundWorker));\n\t\t\tmemcpy(MyBgworkerEntry, &rw->rw_worker, sizeof(BackgroundWorker));\n\n\t\t\t/* Release postmaster's working memory context */\n\t\t\tMemoryContextSwitchTo(TopMemoryContext);\n\t\t\tMemoryContextDelete(PostmasterContext);\n\t\t\tPostmasterContext = NULL;\n\n\t\t\tStartBackgroundWorker();\n\n\t\t\texit(1);\t\t\t/* should not get here */\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\t/* in postmaster, fork successful ... */\n\t\t\trw->rw_pid = worker_pid;\n\t\t\trw->rw_backend->pid = rw->rw_pid;\n\t\t\tReportBackgroundWorkerPID(rw);\n\t\t\t/* add new worker to lists of backends */\n\t\t\tdlist_push_head(&BackendList, &rw->rw_backend->elem);\n#ifdef EXEC_BACKEND\n\t\t\tShmemBackendArrayAdd(rw->rw_backend);\n#endif\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n/*\n * Does the current postmaster state require starting a worker with the\n * specified start_time?\n */\nstatic bool\nbgworker_should_start_now(BgWorkerStartTime start_time)\n{\n\tswitch (pmState)\n\t{\n\t\tcase PM_NO_CHILDREN:\n\t\tcase PM_WAIT_DEAD_END:\n\t\tcase PM_SHUTDOWN_2:\n\t\tcase PM_SHUTDOWN:\n\t\tcase PM_WAIT_BACKENDS:\n\t\tcase PM_STOP_BACKENDS:\n\t\t\tbreak;\n\n\t\tcase PM_RUN:\n\t\t\tif (start_time == BgWorkerStart_RecoveryFinished)\n\t\t\t\treturn true;\n\t\t\t/* fall through */\n\n\t\tcase PM_HOT_STANDBY:\n\t\t\tif (start_time == BgWorkerStart_ConsistentState)\n\t\t\t\treturn true;\n\t\t\t/* fall through */\n\n\t\tcase PM_RECOVERY:\n\t\tcase PM_STARTUP:\n\t\tcase PM_INIT:\n\t\t\tif (start_time == BgWorkerStart_PostmasterStart)\n\t\t\t\treturn true;\n\t\t\t/* fall through */\n\n\t}\n\n\treturn false;\n}\n\n/*\n * Allocate the Backend struct for a connected background worker, but don't\n * add it to the list of backends just yet.\n *\n * On failure, return false without changing any worker state.\n *\n * Some info from the Backend is copied into the passed rw.\n */\nstatic bool\nassign_backendlist_entry(RegisteredBgWorker *rw)\n{\n\tBackend    *bn;\n\n\t/*\n\t * Check that database state allows another connection.  Currently the\n\t * only possible failure is CAC_TOOMANY, so we just log an error message\n\t * based on that rather than checking the error code precisely.\n\t */\n\tif (canAcceptConnections(BACKEND_TYPE_BGWORKER) != CAC_OK)\n\t{\n\t\tereport(LOG,\n\t\t\t\t(errcode(ERRCODE_CONFIGURATION_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"no slot available for new worker process\")));\n\t\treturn false;\n\t}\n\n\t/*\n\t * Compute the cancel key that will be assigned to this session. We\n\t * probably don't need cancel keys for background workers, but we'd better\n\t * have something random in the field to prevent unfriendly people from\n\t * sending cancels to them.\n\t */\n\tif (!RandomCancelKey(&MyCancelKey))\n\t{\n\t\tereport(LOG,\n\t\t\t\t(errcode(ERRCODE_INTERNAL_ERROR),\n\t\t\t\t errmsg(\"could not generate random cancel key\")));\n\t\treturn false;\n\t}\n\n\tbn = malloc(sizeof(Backend));\n\tif (bn == NULL)\n\t{\n\t\tereport(LOG,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\")));\n\t\treturn false;\n\t}\n\n\tbn->cancel_key = MyCancelKey;\n\tbn->child_slot = MyPMChildSlot = AssignPostmasterChildSlot();\n\tbn->bkend_type = BACKEND_TYPE_BGWORKER;\n\tbn->dead_end = false;\n\tbn->bgworker_notify = false;\n\n\trw->rw_backend = bn;\n\trw->rw_child_slot = bn->child_slot;\n\n\treturn true;\n}\n\n/*\n * If the time is right, start background worker(s).\n *\n * As a side effect, the bgworker control variables are set or reset\n * depending on whether more workers may need to be started.\n *\n * We limit the number of workers started per call, to avoid consuming the\n * postmaster's attention for too long when many such requests are pending.\n * As long as StartWorkerNeeded is true, ServerLoop will not block and will\n * call this function again after dealing with any other issues.\n */\nstatic void\nmaybe_start_bgworkers(void)\n{\n#define MAX_BGWORKERS_TO_LAUNCH 100\n\tint\t\t\tnum_launched = 0;\n\tTimestampTz now = 0;\n\tslist_mutable_iter iter;\n\n\t/*\n\t * During crash recovery, we have no need to be called until the state\n\t * transition out of recovery.\n\t */\n\tif (FatalError)\n\t{\n\t\tStartWorkerNeeded = false;\n\t\tHaveCrashedWorker = false;\n\t\treturn;\n\t}\n\n\t/* Don't need to be called again unless we find a reason for it below */\n\tStartWorkerNeeded = false;\n\tHaveCrashedWorker = false;\n\n\tslist_foreach_modify(iter, &BackgroundWorkerList)\n\t{\n\t\tRegisteredBgWorker *rw;\n\n\t\trw = slist_container(RegisteredBgWorker, rw_lnode, iter.cur);\n\n\t\t/* ignore if already running */\n\t\tif (rw->rw_pid != 0)\n\t\t\tcontinue;\n\n\t\t/* if marked for death, clean up and remove from list */\n\t\tif (rw->rw_terminate)\n\t\t{\n\t\t\tForgetBackgroundWorker(&iter);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If this worker has crashed previously, maybe it needs to be\n\t\t * restarted (unless on registration it specified it doesn't want to\n\t\t * be restarted at all).  Check how long ago did a crash last happen.\n\t\t * If the last crash is too recent, don't start it right away; let it\n\t\t * be restarted once enough time has passed.\n\t\t */\n\t\tif (rw->rw_crashed_at != 0)\n\t\t{\n\t\t\tif (rw->rw_worker.bgw_restart_time == BGW_NEVER_RESTART)\n\t\t\t{\n\t\t\t\tint\t\t\tnotify_pid;\n\n\t\t\t\tnotify_pid = rw->rw_worker.bgw_notify_pid;\n\n\t\t\t\tForgetBackgroundWorker(&iter);\n\n\t\t\t\t/* Report worker is gone now. */\n\t\t\t\tif (notify_pid != 0)\n\t\t\t\t\tkill(notify_pid, SIGUSR1);\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* read system time only when needed */\n\t\t\tif (now == 0)\n\t\t\t\tnow = GetCurrentTimestamp();\n\n\t\t\tif (!TimestampDifferenceExceeds(rw->rw_crashed_at, now,\n\t\t\t\t\t\t\t\t\t\t\trw->rw_worker.bgw_restart_time * 1000))\n\t\t\t{\n\t\t\t\t/* Set flag to remember that we have workers to start later */\n\t\t\t\tHaveCrashedWorker = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (bgworker_should_start_now(rw->rw_worker.bgw_start_time))\n\t\t{\n\t\t\t/* reset crash time before trying to start worker */\n\t\t\trw->rw_crashed_at = 0;\n\n\t\t\t/*\n\t\t\t * Try to start the worker.\n\t\t\t *\n\t\t\t * On failure, give up processing workers for now, but set\n\t\t\t * StartWorkerNeeded so we'll come back here on the next iteration\n\t\t\t * of ServerLoop to try again.  (We don't want to wait, because\n\t\t\t * there might be additional ready-to-run workers.)  We could set\n\t\t\t * HaveCrashedWorker as well, since this worker is now marked\n\t\t\t * crashed, but there's no need because the next run of this\n\t\t\t * function will do that.\n\t\t\t */\n\t\t\tif (!do_start_bgworker(rw))\n\t\t\t{\n\t\t\t\tStartWorkerNeeded = true;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If we've launched as many workers as allowed, quit, but have\n\t\t\t * ServerLoop call us again to look for additional ready-to-run\n\t\t\t * workers.  There might not be any, but we'll find out the next\n\t\t\t * time we run.\n\t\t\t */\n\t\t\tif (++num_launched >= MAX_BGWORKERS_TO_LAUNCH)\n\t\t\t{\n\t\t\t\tStartWorkerNeeded = true;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/*\n * When a backend asks to be notified about worker state changes, we\n * set a flag in its backend entry.  The background worker machinery needs\n * to know when such backends exit.\n */\nbool\nPostmasterMarkPIDForWorkerNotify(int pid)\n{\n\tdlist_iter\titer;\n\tBackend    *bp;\n\n\tdlist_foreach(iter, &BackendList)\n\t{\n\t\tbp = dlist_container(Backend, elem, iter.cur);\n\t\tif (bp->pid == pid)\n\t\t{\n\t\t\tbp->bgworker_notify = true;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n#ifdef EXEC_BACKEND\n\n/*\n * The following need to be available to the save/restore_backend_variables\n * functions.  They are marked NON_EXEC_STATIC in their home modules.\n */\nextern slock_t *ShmemLock;\nextern slock_t *ProcStructLock;\nextern PGPROC *AuxiliaryProcs;\nextern PMSignalData *PMSignalState;\nextern pgsocket pgStatSock;\nextern pg_time_t first_syslogger_file_time;\n\n#ifndef WIN32\n#define write_inheritable_socket(dest, src, childpid) ((*(dest) = (src)), true)\n#define read_inheritable_socket(dest, src) (*(dest) = *(src))\n#else\nstatic bool write_duplicated_handle(HANDLE *dest, HANDLE src, HANDLE child);\nstatic bool write_inheritable_socket(InheritableSocket *dest, SOCKET src,\n\t\t\t\t\t\t\t\t\t pid_t childPid);\nstatic void read_inheritable_socket(SOCKET *dest, InheritableSocket *src);\n#endif\n\n\n/* Save critical backend variables into the BackendParameters struct */\n#ifndef WIN32\nstatic bool\nsave_backend_variables(BackendParameters *param, Port *port)\n#else\nstatic bool\nsave_backend_variables(BackendParameters *param, Port *port,\n\t\t\t\t\t   HANDLE childProcess, pid_t childPid)\n#endif\n{\n\tmemcpy(&param->port, port, sizeof(Port));\n\tif (!write_inheritable_socket(&param->portsocket, port->sock, childPid))\n\t\treturn false;\n\n\tstrlcpy(param->DataDir, DataDir, MAXPGPATH);\n\n\tmemcpy(&param->ListenSocket, &ListenSocket, sizeof(ListenSocket));\n\n\tparam->MyCancelKey = MyCancelKey;\n\tparam->MyPMChildSlot = MyPMChildSlot;\n\n#ifdef WIN32\n\tparam->ShmemProtectiveRegion = ShmemProtectiveRegion;\n#endif\n\tparam->UsedShmemSegID = UsedShmemSegID;\n\tparam->UsedShmemSegAddr = UsedShmemSegAddr;\n\n\tparam->ShmemLock = ShmemLock;\n\tparam->ShmemVariableCache = ShmemVariableCache;\n\tparam->ShmemBackendArray = ShmemBackendArray;\n\n#ifndef HAVE_SPINLOCKS\n\tparam->SpinlockSemaArray = SpinlockSemaArray;\n#endif\n\tparam->NamedLWLockTrancheRequests = NamedLWLockTrancheRequests;\n\tparam->NamedLWLockTrancheArray = NamedLWLockTrancheArray;\n\tparam->MainLWLockArray = MainLWLockArray;\n\tparam->ProcStructLock = ProcStructLock;\n\tparam->ProcGlobal = ProcGlobal;\n\tparam->AuxiliaryProcs = AuxiliaryProcs;\n\tparam->PreparedXactProcs = PreparedXactProcs;\n\tparam->PMSignalState = PMSignalState;\n\tif (!write_inheritable_socket(&param->pgStatSock, pgStatSock, childPid))\n\t\treturn false;\n\n\tparam->PostmasterPid = PostmasterPid;\n\tparam->PgStartTime = PgStartTime;\n\tparam->PgReloadTime = PgReloadTime;\n\tparam->first_syslogger_file_time = first_syslogger_file_time;\n\n\tparam->redirection_done = redirection_done;\n\tparam->IsBinaryUpgrade = IsBinaryUpgrade;\n\tparam->query_id_enabled = query_id_enabled;\n\tparam->max_safe_fds = max_safe_fds;\n\n\tparam->MaxBackends = MaxBackends;\n\n#ifdef WIN32\n\tparam->PostmasterHandle = PostmasterHandle;\n\tif (!write_duplicated_handle(&param->initial_signal_pipe,\n\t\t\t\t\t\t\t\t pgwin32_create_signal_listener(childPid),\n\t\t\t\t\t\t\t\t childProcess))\n\t\treturn false;\n#else\n\tmemcpy(&param->postmaster_alive_fds, &postmaster_alive_fds,\n\t\t   sizeof(postmaster_alive_fds));\n#endif\n\n\tmemcpy(&param->syslogPipe, &syslogPipe, sizeof(syslogPipe));\n\n\tstrlcpy(param->my_exec_path, my_exec_path, MAXPGPATH);\n\n\tstrlcpy(param->pkglib_path, pkglib_path, MAXPGPATH);\n\n\treturn true;\n}\n\n\n#ifdef WIN32\n/*\n * Duplicate a handle for usage in a child process, and write the child\n * process instance of the handle to the parameter file.\n */\nstatic bool\nwrite_duplicated_handle(HANDLE *dest, HANDLE src, HANDLE childProcess)\n{\n\tHANDLE\t\thChild = INVALID_HANDLE_VALUE;\n\n\tif (!DuplicateHandle(GetCurrentProcess(),\n\t\t\t\t\t\t src,\n\t\t\t\t\t\t childProcess,\n\t\t\t\t\t\t &hChild,\n\t\t\t\t\t\t 0,\n\t\t\t\t\t\t TRUE,\n\t\t\t\t\t\t DUPLICATE_CLOSE_SOURCE | DUPLICATE_SAME_ACCESS))\n\t{\n\t\tereport(LOG,\n\t\t\t\t(errmsg_internal(\"could not duplicate handle to be written to backend parameter file: error code %lu\",\n\t\t\t\t\t\t\t\t GetLastError())));\n\t\treturn false;\n\t}\n\n\t*dest = hChild;\n\treturn true;\n}\n\n/*\n * Duplicate a socket for usage in a child process, and write the resulting\n * structure to the parameter file.\n * This is required because a number of LSPs (Layered Service Providers) very\n * common on Windows (antivirus, firewalls, download managers etc) break\n * straight socket inheritance.\n */\nstatic bool\nwrite_inheritable_socket(InheritableSocket *dest, SOCKET src, pid_t childpid)\n{\n\tdest->origsocket = src;\n\tif (src != 0 && src != PGINVALID_SOCKET)\n\t{\n\t\t/* Actual socket */\n\t\tif (WSADuplicateSocket(src, childpid, &dest->wsainfo) != 0)\n\t\t{\n\t\t\tereport(LOG,\n\t\t\t\t\t(errmsg(\"could not duplicate socket %d for use in backend: error code %d\",\n\t\t\t\t\t\t\t(int) src, WSAGetLastError())));\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n/*\n * Read a duplicate socket structure back, and get the socket descriptor.\n */\nstatic void\nread_inheritable_socket(SOCKET *dest, InheritableSocket *src)\n{\n\tSOCKET\t\ts;\n\n\tif (src->origsocket == PGINVALID_SOCKET || src->origsocket == 0)\n\t{\n\t\t/* Not a real socket! */\n\t\t*dest = src->origsocket;\n\t}\n\telse\n\t{\n\t\t/* Actual socket, so create from structure */\n\t\ts = WSASocket(FROM_PROTOCOL_INFO,\n\t\t\t\t\t  FROM_PROTOCOL_INFO,\n\t\t\t\t\t  FROM_PROTOCOL_INFO,\n\t\t\t\t\t  &src->wsainfo,\n\t\t\t\t\t  0,\n\t\t\t\t\t  0);\n\t\tif (s == INVALID_SOCKET)\n\t\t{\n\t\t\twrite_stderr(\"could not create inherited socket: error code %d\\n\",\n\t\t\t\t\t\t WSAGetLastError());\n\t\t\texit(1);\n\t\t}\n\t\t*dest = s;\n\n\t\t/*\n\t\t * To make sure we don't get two references to the same socket, close\n\t\t * the original one. (This would happen when inheritance actually\n\t\t * works..\n\t\t */\n\t\tclosesocket(src->origsocket);\n\t}\n}\n#endif\n\nstatic void\nread_backend_variables(char *id, Port *port)\n{\n\tBackendParameters param;\n\n#ifndef WIN32\n\t/* Non-win32 implementation reads from file */\n\tFILE\t   *fp;\n\n\t/* Open file */\n\tfp = AllocateFile(id, PG_BINARY_R);\n\tif (!fp)\n\t{\n\t\twrite_stderr(\"could not open backend variables file \\\"%s\\\": %s\\n\",\n\t\t\t\t\t id, strerror(errno));\n\t\texit(1);\n\t}\n\n\tif (fread(&param, sizeof(param), 1, fp) != 1)\n\t{\n\t\twrite_stderr(\"could not read from backend variables file \\\"%s\\\": %s\\n\",\n\t\t\t\t\t id, strerror(errno));\n\t\texit(1);\n\t}\n\n\t/* Release file */\n\tFreeFile(fp);\n\tif (unlink(id) != 0)\n\t{\n\t\twrite_stderr(\"could not remove file \\\"%s\\\": %s\\n\",\n\t\t\t\t\t id, strerror(errno));\n\t\texit(1);\n\t}\n#else\n\t/* Win32 version uses mapped file */\n\tHANDLE\t\tparamHandle;\n\tBackendParameters *paramp;\n\n#ifdef _WIN64\n\tparamHandle = (HANDLE) _atoi64(id);\n#else\n\tparamHandle = (HANDLE) atol(id);\n#endif\n\tparamp = MapViewOfFile(paramHandle, FILE_MAP_READ, 0, 0, 0);\n\tif (!paramp)\n\t{\n\t\twrite_stderr(\"could not map view of backend variables: error code %lu\\n\",\n\t\t\t\t\t GetLastError());\n\t\texit(1);\n\t}\n\n\tmemcpy(&param, paramp, sizeof(BackendParameters));\n\n\tif (!UnmapViewOfFile(paramp))\n\t{\n\t\twrite_stderr(\"could not unmap view of backend variables: error code %lu\\n\",\n\t\t\t\t\t GetLastError());\n\t\texit(1);\n\t}\n\n\tif (!CloseHandle(paramHandle))\n\t{\n\t\twrite_stderr(\"could not close handle to backend parameter variables: error code %lu\\n\",\n\t\t\t\t\t GetLastError());\n\t\texit(1);\n\t}\n#endif\n\n\trestore_backend_variables(&param, port);\n}\n\n/* Restore critical backend variables from the BackendParameters struct */\nstatic void\nrestore_backend_variables(BackendParameters *param, Port *port)\n{\n\tmemcpy(port, &param->port, sizeof(Port));\n\tread_inheritable_socket(&port->sock, &param->portsocket);\n\n\tSetDataDir(param->DataDir);\n\n\tmemcpy(&ListenSocket, &param->ListenSocket, sizeof(ListenSocket));\n\n\tMyCancelKey = param->MyCancelKey;\n\tMyPMChildSlot = param->MyPMChildSlot;\n\n#ifdef WIN32\n\tShmemProtectiveRegion = param->ShmemProtectiveRegion;\n#endif\n\tUsedShmemSegID = param->UsedShmemSegID;\n\tUsedShmemSegAddr = param->UsedShmemSegAddr;\n\n\tShmemLock = param->ShmemLock;\n\tShmemVariableCache = param->ShmemVariableCache;\n\tShmemBackendArray = param->ShmemBackendArray;\n\n#ifndef HAVE_SPINLOCKS\n\tSpinlockSemaArray = param->SpinlockSemaArray;\n#endif\n\tNamedLWLockTrancheRequests = param->NamedLWLockTrancheRequests;\n\tNamedLWLockTrancheArray = param->NamedLWLockTrancheArray;\n\tMainLWLockArray = param->MainLWLockArray;\n\tProcStructLock = param->ProcStructLock;\n\tProcGlobal = param->ProcGlobal;\n\tAuxiliaryProcs = param->AuxiliaryProcs;\n\tPreparedXactProcs = param->PreparedXactProcs;\n\tPMSignalState = param->PMSignalState;\n\tread_inheritable_socket(&pgStatSock, &param->pgStatSock);\n\n\tPostmasterPid = param->PostmasterPid;\n\tPgStartTime = param->PgStartTime;\n\tPgReloadTime = param->PgReloadTime;\n\tfirst_syslogger_file_time = param->first_syslogger_file_time;\n\n\tredirection_done = param->redirection_done;\n\tIsBinaryUpgrade = param->IsBinaryUpgrade;\n\tquery_id_enabled = param->query_id_enabled;\n\tmax_safe_fds = param->max_safe_fds;\n\n\tMaxBackends = param->MaxBackends;\n\n#ifdef WIN32\n\tPostmasterHandle = param->PostmasterHandle;\n\tpgwin32_initial_signal_pipe = param->initial_signal_pipe;\n#else\n\tmemcpy(&postmaster_alive_fds, &param->postmaster_alive_fds,\n\t\t   sizeof(postmaster_alive_fds));\n#endif\n\n\tmemcpy(&syslogPipe, &param->syslogPipe, sizeof(syslogPipe));\n\n\tstrlcpy(my_exec_path, param->my_exec_path, MAXPGPATH);\n\n\tstrlcpy(pkglib_path, param->pkglib_path, MAXPGPATH);\n\n\t/*\n\t * We need to restore fd.c's counts of externally-opened FDs; to avoid\n\t * confusion, be sure to do this after restoring max_safe_fds.  (Note:\n\t * BackendInitialize will handle this for port->sock.)\n\t */\n#ifndef WIN32\n\tif (postmaster_alive_fds[0] >= 0)\n\t\tReserveExternalFD();\n\tif (postmaster_alive_fds[1] >= 0)\n\t\tReserveExternalFD();\n#endif\n\tif (pgStatSock != PGINVALID_SOCKET)\n\t\tReserveExternalFD();\n}\n\n\nSize\nShmemBackendArraySize(void)\n{\n\treturn mul_size(MaxLivePostmasterChildren(), sizeof(Backend));\n}\n\nvoid\nShmemBackendArrayAllocation(void)\n{\n\tSize\t\tsize = ShmemBackendArraySize();\n\n\tShmemBackendArray = (Backend *) ShmemAlloc(size);\n\t/* Mark all slots as empty */\n\tmemset(ShmemBackendArray, 0, size);\n}\n\nstatic void\nShmemBackendArrayAdd(Backend *bn)\n{\n\t/* The array slot corresponding to my PMChildSlot should be free */\n\tint\t\t\ti = bn->child_slot - 1;\n\n\tAssert(ShmemBackendArray[i].pid == 0);\n\tShmemBackendArray[i] = *bn;\n}\n\nstatic void\nShmemBackendArrayRemove(Backend *bn)\n{\n\tint\t\t\ti = bn->child_slot - 1;\n\n\tAssert(ShmemBackendArray[i].pid == bn->pid);\n\t/* Mark the slot as empty */\n\tShmemBackendArray[i].pid = 0;\n}\n#endif\t\t\t\t\t\t\t/* EXEC_BACKEND */\n\n\n#ifdef WIN32\n\n/*\n * Subset implementation of waitpid() for Windows.  We assume pid is -1\n * (that is, check all child processes) and options is WNOHANG (don't wait).\n */\nstatic pid_t\nwaitpid(pid_t pid, int *exitstatus, int options)\n{\n\tDWORD\t\tdwd;\n\tULONG_PTR\tkey;\n\tOVERLAPPED *ovl;\n\n\t/*\n\t * Check if there are any dead children. If there are, return the pid of\n\t * the first one that died.\n\t */\n\tif (GetQueuedCompletionStatus(win32ChildQueue, &dwd, &key, &ovl, 0))\n\t{\n\t\t*exitstatus = (int) key;\n\t\treturn dwd;\n\t}\n\n\treturn -1;\n}\n\n/*\n * Note! Code below executes on a thread pool! All operations must\n * be thread safe! Note that elog() and friends must *not* be used.\n */\nstatic void WINAPI\npgwin32_deadchild_callback(PVOID lpParameter, BOOLEAN TimerOrWaitFired)\n{\n\twin32_deadchild_waitinfo *childinfo = (win32_deadchild_waitinfo *) lpParameter;\n\tDWORD\t\texitcode;\n\n\tif (TimerOrWaitFired)\n\t\treturn;\t\t\t\t\t/* timeout. Should never happen, since we use\n\t\t\t\t\t\t\t\t * INFINITE as timeout value. */\n\n\t/*\n\t * Remove handle from wait - required even though it's set to wait only\n\t * once\n\t */\n\tUnregisterWaitEx(childinfo->waitHandle, NULL);\n\n\tif (!GetExitCodeProcess(childinfo->procHandle, &exitcode))\n\t{\n\t\t/*\n\t\t * Should never happen. Inform user and set a fixed exitcode.\n\t\t */\n\t\twrite_stderr(\"could not read exit code for process\\n\");\n\t\texitcode = 255;\n\t}\n\n\tif (!PostQueuedCompletionStatus(win32ChildQueue, childinfo->procId, (ULONG_PTR) exitcode, NULL))\n\t\twrite_stderr(\"could not post child completion status\\n\");\n\n\t/*\n\t * Handle is per-process, so we close it here instead of in the\n\t * originating thread\n\t */\n\tCloseHandle(childinfo->procHandle);\n\n\t/*\n\t * Free struct that was allocated before the call to\n\t * RegisterWaitForSingleObject()\n\t */\n\tfree(childinfo);\n\n\t/* Queue SIGCHLD signal */\n\tpg_queue_signal(SIGCHLD);\n}\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\n/*\n * Initialize one and only handle for monitoring postmaster death.\n *\n * Called once in the postmaster, so that child processes can subsequently\n * monitor if their parent is dead.\n */\nstatic void\nInitPostmasterDeathWatchHandle(void)\n{\n#ifndef WIN32\n\n\t/*\n\t * Create a pipe. Postmaster holds the write end of the pipe open\n\t * (POSTMASTER_FD_OWN), and children hold the read end. Children can pass\n\t * the read file descriptor to select() to wake up in case postmaster\n\t * dies, or check for postmaster death with a (read() == 0). Children must\n\t * close the write end as soon as possible after forking, because EOF\n\t * won't be signaled in the read end until all processes have closed the\n\t * write fd. That is taken care of in ClosePostmasterPorts().\n\t */\n\tAssert(MyProcPid == PostmasterPid);\n\tif (pipe(postmaster_alive_fds) < 0)\n\t\tereport(FATAL,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg_internal(\"could not create pipe to monitor postmaster death: %m\")));\n\n\t/* Notify fd.c that we've eaten two FDs for the pipe. */\n\tReserveExternalFD();\n\tReserveExternalFD();\n\n\t/*\n\t * Set O_NONBLOCK to allow testing for the fd's presence with a read()\n\t * call.\n\t */\n\tif (fcntl(postmaster_alive_fds[POSTMASTER_FD_WATCH], F_SETFL, O_NONBLOCK) == -1)\n\t\tereport(FATAL,\n\t\t\t\t(errcode_for_socket_access(),\n\t\t\t\t errmsg_internal(\"could not set postmaster death monitoring pipe to nonblocking mode: %m\")));\n#else\n\n\t/*\n\t * On Windows, we use a process handle for the same purpose.\n\t */\n\tif (DuplicateHandle(GetCurrentProcess(),\n\t\t\t\t\t\tGetCurrentProcess(),\n\t\t\t\t\t\tGetCurrentProcess(),\n\t\t\t\t\t\t&PostmasterHandle,\n\t\t\t\t\t\t0,\n\t\t\t\t\t\tTRUE,\n\t\t\t\t\t\tDUPLICATE_SAME_ACCESS) == 0)\n\t\tereport(FATAL,\n\t\t\t\t(errmsg_internal(\"could not duplicate postmaster handle: error code %lu\",\n\t\t\t\t\t\t\t\t GetLastError())));\n#endif\t\t\t\t\t\t\t/* WIN32 */\n}\n", "/*-------------------------------------------------------------------------\n *\n * libpq.h\n *\t  POSTGRES LIBPQ buffer structure definitions.\n *\n *\n * Portions Copyright (c) 1996-2021, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n * src/include/libpq/libpq.h\n *\n *-------------------------------------------------------------------------\n */\n#ifndef LIBPQ_H\n#define LIBPQ_H\n\n#include <netinet/in.h>\n\n#include \"lib/stringinfo.h\"\n#include \"libpq/libpq-be.h\"\n#include \"storage/latch.h\"\n\n\n/*\n * Callers of pq_getmessage() must supply a maximum expected message size.\n * By convention, if there's not any specific reason to use another value,\n * use PQ_SMALL_MESSAGE_LIMIT for messages that shouldn't be too long, and\n * PQ_LARGE_MESSAGE_LIMIT for messages that can be long.\n */\n#define PQ_SMALL_MESSAGE_LIMIT\t10000\n#define PQ_LARGE_MESSAGE_LIMIT\t(MaxAllocSize - 1)\n\ntypedef struct\n{\n\tvoid\t\t(*comm_reset) (void);\n\tint\t\t\t(*flush) (void);\n\tint\t\t\t(*flush_if_writable) (void);\n\tbool\t\t(*is_send_pending) (void);\n\tint\t\t\t(*putmessage) (char msgtype, const char *s, size_t len);\n\tvoid\t\t(*putmessage_noblock) (char msgtype, const char *s, size_t len);\n} PQcommMethods;\n\nextern const PGDLLIMPORT PQcommMethods *PqCommMethods;\n\n#define pq_comm_reset() (PqCommMethods->comm_reset())\n#define pq_flush() (PqCommMethods->flush())\n#define pq_flush_if_writable() (PqCommMethods->flush_if_writable())\n#define pq_is_send_pending() (PqCommMethods->is_send_pending())\n#define pq_putmessage(msgtype, s, len) \\\n\t(PqCommMethods->putmessage(msgtype, s, len))\n#define pq_putmessage_noblock(msgtype, s, len) \\\n\t(PqCommMethods->putmessage_noblock(msgtype, s, len))\n\n/*\n * External functions.\n */\n\n/*\n * prototypes for functions in pqcomm.c\n */\nextern WaitEventSet *FeBeWaitSet;\n\n#define FeBeWaitSetSocketPos 0\n#define FeBeWaitSetLatchPos 1\n\nextern int\tStreamServerPort(int family, const char *hostName,\n\t\t\t\t\t\t\t unsigned short portNumber, const char *unixSocketDir,\n\t\t\t\t\t\t\t pgsocket ListenSocket[], int MaxListen);\nextern int\tStreamConnection(pgsocket server_fd, Port *port);\nextern void StreamClose(pgsocket sock);\nextern void TouchSocketFiles(void);\nextern void RemoveSocketFiles(void);\nextern void pq_init(void);\nextern int\tpq_getbytes(char *s, size_t len);\nextern void pq_startmsgread(void);\nextern void pq_endmsgread(void);\nextern bool pq_is_reading_msg(void);\nextern int\tpq_getmessage(StringInfo s, int maxlen);\nextern int\tpq_getbyte(void);\nextern int\tpq_peekbyte(void);\nextern int\tpq_getbyte_if_available(unsigned char *c);\nextern bool pq_buffer_has_data(void);\nextern int\tpq_putmessage_v2(char msgtype, const char *s, size_t len);\nextern bool pq_check_connection(void);\n\n/*\n * prototypes for functions in be-secure.c\n */\nextern char *ssl_library;\nextern char *ssl_cert_file;\nextern char *ssl_key_file;\nextern char *ssl_ca_file;\nextern char *ssl_crl_file;\nextern char *ssl_crl_dir;\nextern char *ssl_dh_params_file;\nextern PGDLLIMPORT char *ssl_passphrase_command;\nextern PGDLLIMPORT bool ssl_passphrase_command_supports_reload;\n#ifdef USE_SSL\nextern bool ssl_loaded_verify_locations;\n#endif\n\nextern int\tsecure_initialize(bool isServerStart);\nextern bool secure_loaded_verify_locations(void);\nextern void secure_destroy(void);\nextern int\tsecure_open_server(Port *port);\nextern void secure_close(Port *port);\nextern ssize_t secure_read(Port *port, void *ptr, size_t len);\nextern ssize_t secure_write(Port *port, void *ptr, size_t len);\nextern ssize_t secure_raw_read(Port *port, void *ptr, size_t len);\nextern ssize_t secure_raw_write(Port *port, const void *ptr, size_t len);\n\n/*\n * prototypes for functions in be-secure-gssapi.c\n */\n#ifdef ENABLE_GSS\nextern ssize_t secure_open_gssapi(Port *port);\n#endif\n\n/* GUCs */\nextern char *SSLCipherSuites;\nextern char *SSLECDHCurve;\nextern bool SSLPreferServerCiphers;\nextern int\tssl_min_protocol_version;\nextern int\tssl_max_protocol_version;\n\nenum ssl_protocol_versions\n{\n\tPG_TLS_ANY = 0,\n\tPG_TLS1_VERSION,\n\tPG_TLS1_1_VERSION,\n\tPG_TLS1_2_VERSION,\n\tPG_TLS1_3_VERSION,\n};\n\n/*\n * prototypes for functions in be-secure-common.c\n */\nextern int\trun_ssl_passphrase_command(const char *prompt, bool is_server_start,\n\t\t\t\t\t\t\t\t\t   char *buf, int size);\nextern bool check_ssl_key_file_permissions(const char *ssl_key_file,\n\t\t\t\t\t\t\t\t\t\t   bool isServerStart);\n\n#endif\t\t\t\t\t\t\t/* LIBPQ_H */\n"], "filenames": ["src/backend/libpq/pqcomm.c", "src/backend/postmaster/postmaster.c", "src/include/libpq/libpq.h"], "buggy_code_start_loc": [1143, 2113, 81], "buggy_code_end_loc": [1143, 2143, 81], "fixing_code_start_loc": [1144, 2114, 82], "fixing_code_end_loc": [1156, 2168, 83], "type": "CWE-89", "message": "When the server is configured to use trust authentication with a clientcert requirement or to use cert authentication, a man-in-the-middle attacker can inject arbitrary SQL queries when a connection is first established, despite the use of SSL certificate verification and encryption.", "other": {"cve": {"id": "CVE-2021-23214", "sourceIdentifier": "secalert@redhat.com", "published": "2022-03-04T16:15:08.293", "lastModified": "2023-01-31T17:29:32.620", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "When the server is configured to use trust authentication with a clientcert requirement or to use cert authentication, a man-in-the-middle attacker can inject arbitrary SQL queries when a connection is first established, despite the use of SSL certificate verification and encryption."}, {"lang": "es", "value": "Cuando el servidor est\u00e1 configurado para usar la autenticaci\u00f3n confiable con un requisito de clientcert o para usar la autenticaci\u00f3n de cert, un atacante de tipo man-in-the-middle puede inyectar consultas SQL arbitrarias cuando es establecida una conexi\u00f3n por primera vez, a pesar del uso de la verificaci\u00f3n y el cifrado del certificado SSL"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.2, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:H/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "HIGH", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 5.1}, "baseSeverity": "MEDIUM", "exploitabilityScore": 4.9, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "secalert@redhat.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-89"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-89"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:postgresql:postgresql:*:*:*:*:*:*:*:*", "versionEndExcluding": "9.6.24", "matchCriteriaId": "2F4E17B9-1197-45D3-A22C-34D7DEE947AA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:postgresql:postgresql:*:*:*:*:*:*:*:*", "versionStartIncluding": "10.0", "versionEndExcluding": "10.19", "matchCriteriaId": "C495B1CF-63CD-4E10-A9B2-6FD773AD5243"}, {"vulnerable": true, "criteria": "cpe:2.3:a:postgresql:postgresql:*:*:*:*:*:*:*:*", "versionStartIncluding": "11.0", "versionEndExcluding": "11.14", "matchCriteriaId": "121A1F97-8480-4C15-AAA6-256CB1C0DD47"}, {"vulnerable": true, "criteria": "cpe:2.3:a:postgresql:postgresql:*:*:*:*:*:*:*:*", "versionStartIncluding": "12.0", "versionEndExcluding": "12.9", "matchCriteriaId": "1E585815-7CA4-4B66-B222-28064F4600C7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:postgresql:postgresql:*:*:*:*:*:*:*:*", "versionStartIncluding": "13.0", "versionEndExcluding": "13.5", "matchCriteriaId": "D4F8E475-7A26-4157-8E42-91D37845436C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:postgresql:postgresql:14.0:*:*:*:*:*:*:*", "matchCriteriaId": "B7DAB70A-574C-45E0-BC26-0C980E58907B"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:software_collections:1.0:*:*:*:*:*:*:*", "matchCriteriaId": "9D7EE4B6-A6EC-4B9B-91DF-79615796673F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "F4CFF558-3C47-480D-A2F0-BABF26042943"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_for_ibm_z_systems:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "87C21FE1-EA5C-498F-9C6C-D05F91A88217"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_for_power_little_endian:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "47811209-5CE5-4375-8391-B0A7F6A0E420"}]}]}], "references": [{"url": "https://bugzilla.redhat.com/show_bug.cgi?id=2022666", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://git.postgresql.org/gitweb/?p=postgresql.git;a=commit;h=28e24125541545483093819efae9bca603441951", "source": "secalert@redhat.com", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/postgres/postgres/commit/28e24125541545483093819efae9bca603441951", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202211-04", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.postgresql.org/support/security/CVE-2021-23214/", "source": "secalert@redhat.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/postgres/postgres/commit/28e24125541545483093819efae9bca603441951"}}