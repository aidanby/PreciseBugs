{"buggy_code": ["/* $Id$ */\n/* \n * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)\n * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n#ifndef __PJSIP_SIP_DIALOG_H__\n#define __PJSIP_SIP_DIALOG_H__\n\n\n/**\n * @file sip_dialog.h\n * @brief SIP Dialog abstraction\n */\n\n#include <pjsip/sip_msg.h>\n#include <pjsip/sip_auth.h>\n#include <pjsip/sip_errno.h>\n#include <pjsip/sip_transport.h>\n#include <pjsip/sip_util.h>\n#include <pj/sock.h>\n#include <pj/assert.h>\n\n\n/**\n * @defgroup PJSIP_DIALOG Base Dialog\n * @ingroup PJSIP_UA\n * @brief The base dialog framework to support dialog usages.\n * @{\n *\n * The base dialog framework provides management for base dialog\n * properties such as <b>From</b> header, <b>To</b> header, <b>CSeq</b>\n * sequencing, <b>Call-ID</b> header, <b>Contact</b> header management, \n * dialog <b>route-set</b> management, and common <b>authentication</b>. \n * This basic dialog functionality will be shared by all <b>dialog\n * usages</b> of a particular dialog.\n *\n * More detailed information is explained in\n * <A HREF=\"/docs.htm\">PJSIP Developer's Guide</A>\n * PDF document, and readers are encouraged to read the document to\n * get the concept behind dialog, dialog usages, and INVITE sessions.\n *\n * Application MUST initialize the user agent layer module by calling\n * #pjsip_ua_init_module() before using any of the dialog API, and link\n * the application with with <b>pjsip-core</b> library.\n */\n\nPJ_BEGIN_DECL\n\n\n/* Deprecated API pjsip_dlg_create_uas() due to a fatal bug of possible\n * premature dialog destroy. Application should not change this setting,\n * unless it uses single worker thread.\n * See also https://trac.pjsip.org/repos/ticket/1902.\n */\n#ifndef DEPRECATED_FOR_TICKET_1902\n#  define DEPRECATED_FOR_TICKET_1902      1\n#endif\n\n/**\n * This structure is used to describe dialog's participants, which in this\n * case is local party (i.e. us) and remote party.\n */\ntypedef struct pjsip_dlg_party\n{\n    pjsip_fromto_hdr\t*info;\t    /**< From/To header, inc tag.\t*/\n    pj_str_t\t\t info_str;  /**< String rep of info header.\t*/\n    pj_uint32_t\t\t tag_hval;  /**< Hashed value of the tag.\t*/\n    pjsip_contact_hdr\t*contact;   /**< Contact header.\t\t*/\n    pj_int32_t\t\t first_cseq;/**< First CSeq seen.\t\t*/\n    pj_int32_t\t\t cseq;\t    /**< Next sequence number.\t\t*/\n} pjsip_dlg_party;\n\n\n/**\n * Dialog state.\n */\ntypedef enum pjsip_dialog_state\n{\n    /** Dialog is not established. */\n    PJSIP_DIALOG_STATE_NULL,\n\n    /** Dialog has been established (probably early) */\n    PJSIP_DIALOG_STATE_ESTABLISHED\n} pjsip_dialog_state;\n\n\n/**\n * Dialog capability status.\n */\ntypedef enum pjsip_dialog_cap_status\n{\n    /** Capability is unsupported. */\n    PJSIP_DIALOG_CAP_UNSUPPORTED    = 0,\n\n    /** Capability is supported */\n    PJSIP_DIALOG_CAP_SUPPORTED\t    = 1,\n\n    /** \n     *  Unknown capability status. This is usually because we lack the \n     *  capability info which is retrieved from capability header specified\n     *  in the dialog messages.\n     */\n    PJSIP_DIALOG_CAP_UNKNOWN\t    = 2\n} pjsip_dialog_cap_status;\n\n\n/**\n * This structure describes the dialog structure. Application MUST NOT\n * try to SET the values here directly, but instead it MUST use the\n * appropriate dialog API. The dialog declaration only needs to be made \n * visible because other PJSIP modules need to see it (e.g. INVITE session,\n * the event framework, etc.).\n *\n * Application MAY READ the dialog contents directly after it acquires\n * dialog lock.\n *\n * To acquire dialog lock, use #pjsip_dlg_inc_lock(), and to release it,\n * use #pjsip_dlg_dec_lock(). DO NOT USE pj_mutex_lock()/pj_mutex_unlock()\n * on the dialog's mutex directly, because this will not protect against\n * dialog being destroyed.\n */\nstruct pjsip_dialog\n{\n    /** The dialog set list. */\n    PJ_DECL_LIST_MEMBER(pjsip_dialog);\n\n    /* Dialog's system properties. */\n    char\t\tobj_name[PJ_MAX_OBJ_NAME];  /**< Standard id.\t    */\n    pj_pool_t\t       *pool;\t    /**< Dialog's pool.\t\t\t    */\n    pjsip_user_agent   *ua;\t    /**< User agent instance.\t\t    */\n    pjsip_endpoint     *endpt;\t    /**< Endpoint instance.\t\t    */\n    pj_grp_lock_t      *grp_lock_;  /**< Dialog's grp lock. Do not call!!\n\t\t\t\t\t Use pjsip_dlg_inc_lock() instead!  */\n\n    /** The dialog set which this dialog belongs (opaque type). */\n    void\t       *dlg_set;\n\n    /* Dialog's session properties. */\n    pjsip_dialog_state\tstate;\t    /**< Dialog state.\t\t\t    */\n    pjsip_uri\t       *target;\t    /**< Current target.\t\t    */\n    pjsip_target_set\ttarget_set; /**< Target set, for UAC only.\t    */\n    pjsip_hdr\t        inv_hdr;    /**< Headers from hparam in dest URL    */\n    pjsip_dlg_party     local;\t    /**< Local party info.\t\t    */\n    pjsip_dlg_party     remote;\t    /**< Remote party info.\t\t    */\n    pjsip_hdr\t\trem_cap_hdr;/**< List of remote capability header.  */\n    pjsip_role_e\trole;\t    /**< Initial role.\t\t\t    */\n    pj_bool_t\t\tuac_has_2xx;/**< UAC has received 2xx response?\t    */\n    pj_bool_t\t\tsecure;\t    /**< Use secure transport?\t\t    */\n    pj_bool_t\t\tadd_allow;  /**< Add Allow header in requests?\t    */\n    pjsip_cid_hdr      *call_id;    /**< Call-ID header.\t\t    */\n    pjsip_route_hdr\troute_set;  /**< Route set.\t\t\t    */\n    pj_bool_t\t\troute_set_frozen; /**< Route set has been set.\t    */\n    pjsip_auth_clt_sess\tauth_sess;  /**< Client authentication session.\t    */\n\n    /** Session counter. */\n    int\t\t\tsess_count; /**< Number of sessions.\t\t    */\n\n    /** Transaction counter. */\n    int\t\t\ttsx_count;  /**< Number of pending transactions.    */\n\n    /** Transport selector. */\n    pjsip_tpselector\ttp_sel;\n\n    /* Dialog usages. */\n    unsigned\t\tusage_cnt;  /**< Number of registered usages.\t    */\n    pjsip_module       *usage[PJSIP_MAX_MODULE]; /**< Array of usages, \n\t\t\t\t\t priority sorted\t\t    */\n\n    /** Module specific data. */\n    void\t       *mod_data[PJSIP_MAX_MODULE]; /**< Module data.\t    */\n\n    /**\n     * If via_addr is set, it will be used as the \"sent-by\" field of the\n     * Via header for outgoing requests as long as the request uses via_tp\n     * transport. Normally application should not use or access these fields.\n     */\n    pjsip_host_port     via_addr;   /**< Via address.\t                    */\n    const void         *via_tp;     /**< Via transport.\t                    */\n};\n\n/**\n * The parameter for \\a pjsip_dlg_create_uac2().\n */\ntypedef struct pjsip_dlg_create_uac_param {\n    /**\n     * The user agent module instance.\n     */\n    pjsip_user_agent *ua;\n\n    /**\n     * Dialog local URI (i.e. From header).\n     */\n    pj_str_t local_uri;\n\n    /**\n     * Optional dialog local Contact to be put as Contact header value,\n     * hence the format must follow RFC 3261 Section 20.10:\n     * When the header field value contains a display name, the URI including\n     * all URI parameters is enclosed in \"<\" and \">\".  If no \"<\" and \">\" are\n     * present, all parameters after the URI are header parameters, not\n     * URI parameters.  The display name can be tokens, or a quoted string,\n     * if a larger character set is desired. If this argument is NULL,\n     * the Contact will be taken from the local URI.\n     */\n    pj_str_t local_contact;\n\n    /**\n     * Dialog remote URI (i.e. To header).\n     */\n    pj_str_t remote_uri;\n\n    /**\n     * Optional initial remote target. If this argument is NULL, the initial \n     * target will be set to remote URI.\n     */\n    pj_str_t target;\n\n    /**\n     * Optional group lock to use by this dialog. If the value is NULL, \n     * the dialog will create its own group lock.\n     */\n    pj_grp_lock_t *grp_lock;\n\n} pjsip_dlg_create_uac_param;\n\n\n/**\n * This utility function returns PJ_TRUE if the specified method is a\n * dialog creating request. This method property is used to determine\n * whether Contact header should be included in outgoing request.\n *\n * @param m\t\tThe SIP method.\n *\n * @return\t\tPJ_TRUE if the method creates a dialog.\n */\nPJ_DECL(pj_bool_t) pjsip_method_creates_dialog(const pjsip_method *m);\n\n/**\n * Create a new dialog and return the instance in p_dlg parameter. \n * After creating  the dialog, application can add modules as dialog usages\n * by calling  #pjsip_dlg_add_usage(). \n *\n * If the request has To tag parameter, dialog's local tag will be initialized \n * from this value. Otherwise a globally unique id generator will be invoked to\n * create dialog's local tag.\n *\n * This function also initializes the dialog's route set based on the \n * Record-Route headers in the request, if present.\n *\n * Note that initially, the session count in the dialog will be initialized \n * to zero.\n *\n * @param ua\t\t    The user agent module instance.\n * @param local_uri\t    Dialog local URI (i.e. From header).\n * @param local_contact\t    Optional dialog local Contact to be put as Contact\n *\t\t\t    header value, hence the format must follow\n *\t\t\t    RFC 3261 Section 20.10:\n *\t\t\t    When the header field value contains a display \n *\t\t\t    name, the URI including all URI parameters is \n *\t\t\t    enclosed in \"<\" and \">\".  If no \"<\" and \">\" are \n *\t\t\t    present, all parameters after the URI are header\n *\t\t\t    parameters, not URI parameters.  The display name \n *\t\t\t    can be tokens, or a quoted string, if a larger \n *\t\t\t    character set is desired.\n *\t\t\t    If this argument is NULL, the Contact will be taken\n *\t\t\t    from the local URI.\n * @param remote_uri\t    Dialog remote URI (i.e. To header).\n * @param target\t    Optional initial remote target. If this argument\n *\t\t\t    is NULL, the initial target will be set to\n *\t\t\t    remote URI.\n * @param p_dlg\t\t    Pointer to receive the dialog.\n *\n * @return\t\t    PJ_SUCCESS on success.\n */\nPJ_DECL(pj_status_t) pjsip_dlg_create_uac( pjsip_user_agent *ua,\n\t\t\t\t\t   const pj_str_t *local_uri,\n\t\t\t\t\t   const pj_str_t *local_contact,\n\t\t\t\t\t   const pj_str_t *remote_uri,\n\t\t\t\t\t   const pj_str_t *target,\n\t\t\t\t\t   pjsip_dialog **p_dlg);\n\n/**\n * Variant of pjsip_dlg_create_uac() with additional parameter to specify\n * the group lock to use. Group lock can be used to synchronize locking\n * among several objects to prevent deadlock, and to synchronize the\n * lifetime of objects sharing the same group lock.\n *\n * See \\a pjsip_dlg_create_uac() for general info about this function.\n *\n * @param param\t\t    The parameter, refer to\n *\t\t\t    \\a pjsip_dlg_create_uac_param\n * @param p_dlg\t\t    Pointer to receive the dialog.\n *\n * @return\t\t    PJ_SUCCESS on success.\n */\nPJ_DECL(pj_status_t) pjsip_dlg_create_uac2(\n\t\t\t\tconst pjsip_dlg_create_uac_param *create_param,\n\t\t\t\tpjsip_dialog **p_dlg);\n\n\n#if !DEPRECATED_FOR_TICKET_1902\n/**\n * Initialize UAS dialog from the information found in the incoming request \n * that creates a dialog (such as INVITE, REFER, or SUBSCRIBE), and set the \n * local Contact to contact. If contact is not specified, the local contact \n * is initialized from the URI in the To header in the request. \n *\n * This function will also create UAS transaction for the incoming request,\n * and associate the transaction to the rdata. Application can query the\n * transaction used to handle this request by calling #pjsip_rdata_get_tsx()\n * after this function returns.\n *\n * Note that initially, the session count in the dialog will be initialized \n * to zero.\n *\n *\n * @param ua\t\t    The user agent module instance.\n * @param rdata\t\t    The incoming request that creates the dialog,\n *\t\t\t    such as INVITE, SUBSCRIBE, or REFER.\n * @param contact\t    Optional dialog local Contact to be put as Contact\n *\t\t\t    header value, hence the format must follow\n *\t\t\t    RFC 3261 Section 20.10:\n *\t\t\t    When the header field value contains a display \n *\t\t\t    name, the URI including all URI parameters is \n *\t\t\t    enclosed in \"<\" and \">\".  If no \"<\" and \">\" are \n *\t\t\t    present, all parameters after the URI are header\n *\t\t\t    parameters, not URI parameters.  The display name \n *\t\t\t    can be tokens, or a quoted string, if a larger \n *\t\t\t    character set is desired.\n *\t\t\t    If this argument is NULL, the local contact will be\n *\t\t\t    initialized from the value of To header in the\n *\t\t\t    request.\n * @param p_dlg\t\t    Pointer to receive the dialog.\n *\n * @return\t\t    PJ_SUCCESS on success.\n */\nPJ_DECL(pj_status_t) pjsip_dlg_create_uas(  pjsip_user_agent *ua,\n\t\t\t\t\t    pjsip_rx_data *rdata,\n\t\t\t\t\t    const pj_str_t *contact,\n\t\t\t\t\t    pjsip_dialog **p_dlg);\n#endif\n\n\n/**\n * Initialize UAS dialog from the information found in the incoming request \n * that creates a dialog (such as INVITE, REFER, or SUBSCRIBE), and set the \n * local Contact to contact. If contact is not specified, the local contact \n * is initialized from the URI in the To header in the request. \n *\n * This function will also create UAS transaction for the incoming request,\n * and associate the transaction to the rdata. Application can query the\n * transaction used to handle this request by calling #pjsip_rdata_get_tsx()\n * after this function returns.\n *\n * Note that initially, the session count in the dialog will be initialized \n * to 1 (one), and the dialog is locked. Application needs to explicitly call\n * #pjsip_dlg_dec_lock() to release the lock and decrease the session count.\n *\n *\n * @param ua\t\t    The user agent module instance.\n * @param rdata\t\t    The incoming request that creates the dialog,\n *\t\t\t    such as INVITE, SUBSCRIBE, or REFER.\n * @param contact\t    Optional dialog local Contact to be put as Contact\n *\t\t\t    header value, hence the format must follow\n *\t\t\t    RFC 3261 Section 20.10:\n *\t\t\t    When the header field value contains a display \n *\t\t\t    name, the URI including all URI parameters is \n *\t\t\t    enclosed in \"<\" and \">\".  If no \"<\" and \">\" are \n *\t\t\t    present, all parameters after the URI are header\n *\t\t\t    parameters, not URI parameters.  The display name \n *\t\t\t    can be tokens, or a quoted string, if a larger \n *\t\t\t    character set is desired.\n *\t\t\t    If this argument is NULL, the local contact will be\n *\t\t\t    initialized from the value of To header in the\n *\t\t\t    request.\n * @param p_dlg\t\t    Pointer to receive the dialog.\n *\n * @return\t\t    PJ_SUCCESS on success.\n */\nPJ_DECL(pj_status_t)\npjsip_dlg_create_uas_and_inc_lock(    pjsip_user_agent *ua,\n\t\t\t\t      pjsip_rx_data *rdata,\n\t\t\t\t      const pj_str_t *contact,\n\t\t\t\t      pjsip_dialog **p_dlg);\n\n\n/**\n * Lock/bind dialog to a specific transport/listener. This is optional,\n * as normally transport will be selected automatically based on the \n * destination of messages upon resolver completion. When the dialog is \n * explicitly bound to the specific transport/listener, all transactions\n * originated by this dialog will use the specified transport/listener\n * when sending outgoing requests.\n *\n * Note that this doesn't affect the Contact header generated by this\n * dialog. Application must manually update the Contact header if\n * necessary, to adjust the address according to the transport being\n * selected.\n *\n * @param dlg\t    The dialog instance.\n * @param sel\t    Transport selector containing the specification of\n *\t\t    transport or listener to be used by this dialog\n *\t\t    to send requests.\n *\n * @return\t    PJ_SUCCESS on success, or the appropriate error code.\n */\nPJ_DECL(pj_status_t) pjsip_dlg_set_transport(pjsip_dialog *dlg,\n\t\t\t\t\t     const pjsip_tpselector *sel);\n\n\n/**\n * Set the \"sent-by\" field of the Via header for outgoing requests.\n *\n * @param dlg\t    The dialog instance.\n * @param via_addr  Set via_addr to use for the Via header or NULL to use\n *                  the transport's published name.\n * @param via_tp    via_addr will only be used if we are using via_tp\n *                  transport.\n *\n * @return\t    PJ_SUCCESS on success.\n */\nPJ_DECL(pj_status_t) pjsip_dlg_set_via_sent_by(pjsip_dialog *dlg,\n\t\t\t\t               pjsip_host_port *via_addr,\n                                               pjsip_transport *via_tp);\n\n\n/**\n * Create a new (forked) dialog on receipt on forked response in rdata. \n * The new dialog will be created from original_dlg, except that it will have\n * new remote tag as copied from the To header in the response. Upon return, \n * the new_dlg will have been registered to the user agent. Applications just \n * need to add modules as dialog's usages.\n *\n * Note that initially, the session count in the dialog will be initialized \n * to zero.\n *\n * @param original_dlg\t    The original UAC dialog.\n * @param rdata\t\t    The incoming forked response message.\n * @param new_dlg\t    Pointer to receive the new dialog.\n *\n * @return\t\t    PJ_SUCCESS on success.\n */\nPJ_DECL(pj_status_t) pjsip_dlg_fork(const pjsip_dialog *original_dlg,\n\t\t\t\t    const pjsip_rx_data *rdata,\n\t\t\t\t    pjsip_dialog **new_dlg );\n\n/**\n * Forcefully terminate the dialog. Application can only call this function\n * when there is no session associated to the dialog. If there are sessions\n * that use this dialog, this function will refuse to terminate the dialog.\n * For this case, application MUST call the appropriate termination function \n * for each dialog session (e.g. #pjsip_inv_terminate() to terminate INVITE\n * session).\n *\n * @param dlg\t\t    The dialog.\n *\n * @return\t\t    PJ_SUCCESS if dialog has been terminated.\n */\nPJ_DECL(pj_status_t) pjsip_dlg_terminate( pjsip_dialog *dlg );\n\n\n/**\n * Set dialog's initial route set to route_set list. This can only be called\n * for UAC dialog, before any request is sent. After dialog has been \n * established, the route set can not be changed.\n *\n * For UAS dialog, the route set will be initialized in\n * pjsip_dlg_create_uas_and_inc_lock() from the Record-Route headers in\n * the incoming request.\n *\n * The route_set argument is standard list of Route headers (i.e. with \n * sentinel).\n *\n * @param dlg\t\t    The UAC dialog.\n * @param route_set\t    List of Route header.\n *\n * @return\t\t    PJ_SUCCESS on success.\n */\nPJ_DECL(pj_status_t) pjsip_dlg_set_route_set( pjsip_dialog *dlg,\n\t\t\t\t\t      const pjsip_route_hdr *route_set );\n\n/**\n * Increment the number of sessions in the dialog. Note that initially \n * (after created) the dialog has the session counter set to zero.\n *\n * @param dlg\t\t    The dialog.\n * @param mod\t\t    The module that increments the session counter.\n *\n * @return\t\t    PJ_SUCCESS on success.\n */\nPJ_DECL(pj_status_t) pjsip_dlg_inc_session( pjsip_dialog *dlg,\n\t\t\t\t\t    pjsip_module *mod);\n\n\n/**\n * Decrement the number of sessions in the dialog. Once the session counter \n * reach zero and there is no pending transaction, the dialog will be \n * destroyed. Note that this function may destroy the dialog immediately \n * if there is no pending transaction when this function is called.\n *\n * @param dlg\t\t    The dialog.\n * @param mod\t\t    The module that decrements the session counter.\n *\n * @return\t\t    PJ_SUCCESS on success.\n */\nPJ_DECL(pj_status_t) pjsip_dlg_dec_session( pjsip_dialog *dlg,\n\t\t\t\t\t    pjsip_module *mod);\n\n/**\n * Add a module as dialog usage, and optionally set the module specific data.\n *\n * @param dlg\t\t    The dialog.\n * @param module\t    The module to be registered as dialog usage.\n * @param mod_data\t    Optional arbitrary data to be attached to dialog's\n *\t\t\t    mod_data array at the module's index.\n *\n * @return\t\t    PJ_SUCCESS on success.\n */\nPJ_DECL(pj_status_t) pjsip_dlg_add_usage( pjsip_dialog *dlg,\n\t\t\t\t\t  pjsip_module *module,\n\t\t\t\t\t  void *mod_data );\n\n/**\n * Check if the specified module has been registered as usage to the dialog.\n *\n * @param dlg\t\t    The dialog.\n * @param module\t    The module.\n *\n * @return\t\t    PJ_TRUE if the specified module is currently\n * \t\t\t    registered as a usage to the dialog.\n */\nPJ_DECL(pj_bool_t) pjsip_dlg_has_usage(pjsip_dialog *dlg,\n\t\t\t\t       pjsip_module *module);\n\n/**\n * Attach module specific data to the dialog. Application can also set \n * the value directly by accessing dlg->mod_data[module_id].\n *\n * @param dlg\t\t    The dialog\n * @param mod_id\t    The ID of the module from which the data is to be\n *\t\t\t    set to the dialog.\n * @param data\t\t    Arbitrary data.\n *\n * @return\t\t    PJ_SUCCESS on success.\n */\nPJ_DECL(pj_status_t) pjsip_dlg_set_mod_data( pjsip_dialog *dlg,\n\t\t\t\t\t     int mod_id,\n\t\t\t\t\t     void *data );\n\n/**\n * Get module specific data previously attached to the dialog. Application\n * can also get value directly by accessing dlg->mod_data[module_id].\n *\n * @param dlg\t\t    The dialog\n * @param mod_id\t    The ID of the module from which the data is to be\n *\t\t\t    retrieved from the dialog.\n *\n * @return\t\t    The data that was previously set, or NULL.\n */\nPJ_DECL(void*) pjsip_dlg_get_mod_data( pjsip_dialog *dlg,\n\t\t\t\t       int mod_id);\n\n\n/**\n * Lock dialog and increment session counter termporarily, to prevent it \n * from being destroyed.\n *\n * @param dlg\t\t    The dialog.\n */\nPJ_DECL(void) pjsip_dlg_inc_lock( pjsip_dialog *dlg );\n\n/**\n * Try to acquire dialog's lock, but return immediately if lock can not\n * be acquired.\n *\n * @param dlg\t\t    The dialog.\n *\n * @return\t\t    PJ_SUCCESS if lock has been acquired.\n */\nPJ_DECL(pj_status_t) pjsip_dlg_try_inc_lock( pjsip_dialog *dlg );\n\n/**\n * Unlock dialog and decrement temporary session counter. After this function\n * is called, dialog may be destroyed.\n *\n * @param dlg\t\t    The dialog.\n */\nPJ_DECL(void) pjsip_dlg_dec_lock( pjsip_dialog *dlg );\n\n/**\n * Get the group lock for the SIP dialog. Note that prior to calling this\n * method, it is recommended to hold reference to the dialog\n * (e.g: call #pjsip_dlg_inc_session() or #pjsip_dlg_inc_lock()).\n *\n * @param dlg\t\t    The dialog.\n *\n * @return\t\t    The group lock.\n */\nPJ_DECL(pj_grp_lock_t *) pjsip_dlg_get_lock( pjsip_dialog *dlg );\n\n\n/**\n * Get the dialog instance in the incoming rdata. If an incoming message \n * matches an existing dialog, the user agent must have put the matching \n * dialog instance in the rdata, or otherwise this function will return \n * NULL if the message didn't match any existing dialog.\n *\n * This function can only be called after endpoint distributes the message\n * to the transaction layer or UA layer. In other words, application can\n * only call this function in the context of module that runs in priority\n * number higher than PJSIP_MOD_PRIORITY_UA_PROXY_LAYER.\n *\n * @param rdata\t\t    Incoming message buffer.\n *\n * @return\t\t    The dialog instance that \"owns\" the message.\n */\nPJ_DECL(pjsip_dialog*) pjsip_rdata_get_dlg( pjsip_rx_data *rdata );\n\n/**\n * Get the dialog instance for the outgoing tdata. Returns NULL if the message\n * wasn't sent from a dialog.\n *\n * @param tdata\t\t    Outgoing message buffer.\n *\n * @return\t\t    The dialog instance that \"owns\" the message.\n */\nPJ_DECL(pjsip_dialog*) pjsip_tdata_get_dlg( pjsip_tx_data *tdata );\n\n/**\n * Get the associated dialog for the specified transaction, if any.\n *\n * @param tsx\t\t    The transaction.\n *\n * @return\t\t    The dialog instance which has been registered\n *\t\t\t    to the transaction as transaction user, or\n *\t\t\t    NULL if the transaction is outside any dialogs.\n */\nPJ_DECL(pjsip_dialog*) pjsip_tsx_get_dlg( pjsip_transaction *tsx );\n\n\n/**\n * Create a basic/generic request with the specified method and optionally\n * specify the cseq. Use value -1 for cseq to have the dialog automatically\n * put next cseq number for the request. Otherwise for some requests, \n * e.q. CANCEL and ACK, application must put the CSeq in the original \n * INVITE request as the parameter. \n *\n * This function will also put Contact header where appropriate.\n *\n * @param dlg\t\t    The dialog instance.\n * @param method\t    The method of the request.\n * @param cseq\t\t    Optional CSeq, which only needs to be specified\n *\t\t\t    when creating ACK and CANCEL. For other requests,\n *\t\t\t    specify -1 to use dialog's internal counter.\n * @param tdata\t\t    Pointer to receive the request's transmit\n *\t\t\t    data buffer.\n *\n * @return\t\t    PJ_SUCCESS on success.\n */\nPJ_DECL(pj_status_t) pjsip_dlg_create_request(\tpjsip_dialog *dlg,\n\t\t\t\t\t\tconst pjsip_method *method,\n\t\t\t\t\t\tint cseq,\n\t\t\t\t\t\tpjsip_tx_data **tdata);\n\n\n/**\n * Send request message to remote peer. If the request is not an ACK request, \n * the dialog will send the request statefully, by creating an UAC transaction\n * and send the request with the transaction. \n *\n * Also when the request is not ACK or CANCEL, the dialog will increment its\n * local cseq number and update the cseq in the request according to dialog's \n * cseq.\n *\n * If p_tsx is not null, this argument will be set with the transaction \n * instance that was used to send the request.\n *\n * This function will decrement the transmit data's reference counter\n * regardless the status of the operation.\n *\n * @param dlg\t\t    The dialog.\n * @param tdata\t\t    The request message to be sent.\n * @param mod_data_id\t    Optional module data index to put an optional data\n *\t\t\t    into the transaction. If no module data is to be\n *\t\t\t    attached, this value should be -1.\n * @param mod_data\t    Optional module data to be attached to the \n *\t\t\t    transaction at mod_data_id index.\n *\n * @return\t\t    PJ_SUCCESS on success.\n */\nPJ_DECL(pj_status_t) pjsip_dlg_send_request (\tpjsip_dialog *dlg,\n\t\t\t\t\t\tpjsip_tx_data *tdata,\n\t\t\t\t\t\tint mod_data_id,\n\t\t\t\t\t\tvoid *mod_data);\n\n\n/**\n * Create a response message for the incoming request in rdata with status\n * code st_code and optional status text st_text. This function is different\n * than endpoint's API #pjsip_endpt_create_response() in that the dialog \n * function adds Contact header and Record-Routes headers in the response \n * where appropriate.\n *\n * @param dlg\t\t    The dialog.\n * @param rdata\t\t    The incoming request message for which the\n *\t\t\t    response will be created.\n * @param st_code\t    Status code.\n * @param st_text\t    Optional string for custom status reason text.\n * @param tdata\t\t    Pointer to receive the response message transmit\n *\t\t\t    data buffer.\n *\n * @return\t\t    PJ_SUCCESS on success.\n */\nPJ_DECL(pj_status_t) pjsip_dlg_create_response(\tpjsip_dialog *dlg,\n\t\t\t\t\t\tpjsip_rx_data *rdata,\n\t\t\t\t\t\tint st_code,\n\t\t\t\t\t\tconst pj_str_t *st_text,\n\t\t\t\t\t\tpjsip_tx_data **tdata);\n\n\n/**\n * Modify previously sent response with other status code. Contact header \n * will be added when appropriate.\n *\n * @param dlg\t\t    The dialog.\n * @param tdata\t\t    The transmit data buffer containing response\n *\t\t\t    message to be modified.\n * @param st_code\t    New status code to be set.\n * @param st_text\t    Optional string for custom status reason text.\n *\n * @return\t\t    PJ_SUCCESS on success.\n */\nPJ_DECL(pj_status_t) pjsip_dlg_modify_response(\tpjsip_dialog *dlg,\n\t\t\t\t\t\tpjsip_tx_data *tdata,\n\t\t\t\t\t\tint st_code,\n\t\t\t\t\t\tconst pj_str_t *st_text);\n\n\n/**\n * Send response message statefully. The transaction instance MUST be the \n * transaction that was reported on on_rx_request() callback.\n *\n * This function decrements the transmit data's reference counter regardless\n * the status of the operation.\n *\n * @param dlg\t\t    The dialog.\n * @param tsx\t\t    The UAS transaction associated with the incoming\n *\t\t\t    request. If the request is within a dialog, or\n *\t\t\t    a dialog has been created for the request that\n *\t\t\t    creates the dialog, application can get the\n *\t\t\t    transaction instance for the request by calling\n *\t\t\t    #pjsip_rdata_get_tsx().\n * @param tdata\t\t    Response message to be sent.\n *\n * @return\t\t    PJ_SUCCESS on success.\n */\nPJ_DECL(pj_status_t) pjsip_dlg_send_response(\tpjsip_dialog *dlg,\n\t\t\t\t\t\tpjsip_transaction *tsx,\n\t\t\t\t\t\tpjsip_tx_data *tdata);\n\n\n/**\n * This composite function sends response message statefully to an incoming\n * request message inside dialog.\n *\n * @param dlg\t    The endpoint instance.\n * @param rdata\t    The incoming request message.\n * @param st_code   Status code of the response.\n * @param st_text   Optional status text of the response.\n * @param hdr_list  Optional header list to be added to the response.\n * @param body\t    Optional message body to be added to the response.\n *\n * @return\t    PJ_SUCCESS if response message has successfully been\n *\t\t    sent.\n */\nPJ_DECL(pj_status_t) pjsip_dlg_respond( pjsip_dialog *dlg,\n\t\t\t\t\tpjsip_rx_data *rdata,\n\t\t\t\t\tint st_code,\n\t\t\t\t\tconst pj_str_t *st_text,\n\t\t\t\t\tconst pjsip_hdr *hdr_list,\n\t\t\t\t\tconst pjsip_msg_body *body );\n\n\n/**\n * Check if remote peer have the specified capability as published\n * in the dialog messages from remote peer.\n *\n * Notes:\n * - The capability \\a token lookup will apply exact match, but not \n *   case-sensitive, for example: <tt>\"text/html\"</tt> will not match \n *   <tt>\"text / html\"</tt> (notice the spaces).\n *\n * @param dlg\t    The dialog.\n * @param htype\t    The header type to be checked, which value may be:\n *\t\t    - PJSIP_H_ACCEPT\n *\t\t    - PJSIP_H_ALLOW\n *\t\t    - PJSIP_H_SUPPORTED\n * @param hname\t    If htype specifies PJSIP_H_OTHER, then the header name\n *\t\t    must be supplied in this argument. Otherwise the value\n *\t\t    must be set to NULL.\n * @param token\t    The capability token to check. For example, if \\a htype\n *\t\t    is PJSIP_H_ALLOW, then \\a token specifies the method\n *\t\t    names; if \\a htype is PJSIP_H_SUPPORTED, then \\a token\n *\t\t    specifies the extension names such as \"100rel\".\n *\n * @return\t    PJSIP_DIALOG_CAP_SUPPORTED if the specified capability\n *\t\t    is explicitly supported, see @pjsip_dialog_cap_status\n *\t\t    for more info.\n */\nPJ_DECL(pjsip_dialog_cap_status) pjsip_dlg_remote_has_cap(\n\t\t\t\t\t\t    pjsip_dialog *dlg,\n\t\t\t\t\t\t    int htype,\n\t\t\t\t\t\t    const pj_str_t *hname,\n\t\t\t\t\t\t    const pj_str_t *token);\n\n/**\n * Get the specified capability header from the remote capability headers\n * stored in the dialog.\n *\n * @param dlg\t    The dialog.\n * @param htype\t    The header type to be retrieved, which value may be:\n *\t\t    - PJSIP_H_ACCEPT\n *\t\t    - PJSIP_H_ALLOW\n *\t\t    - PJSIP_H_SUPPORTED\n * @param hname\t    If htype specifies PJSIP_H_OTHER, then the header name\n *\t\t    must be supplied in this argument. Otherwise the value\n *\t\t    must be set to NULL.\n *\n * @return\t    The appropriate header, or NULL if the header is not\n *\t\t    available.\n */\nPJ_DECL(const pjsip_hdr*) pjsip_dlg_get_remote_cap_hdr(pjsip_dialog *dlg,\n\t\t\t\t\t\t       int htype,\n\t\t\t\t\t\t       const pj_str_t *hname);\n\n/**\n * Set remote capability from a SIP header containing array of capability \n * tags/values.\n *\n * @param dlg\t    The dialog.\n * @param cap_hdr   The SIP header.\n *\n * @return\t    PJ_SUCCESS when successful, otherwise the appropriate\n *\t\t    error code will be returned.\n */\nPJ_DECL(pj_status_t) pjsip_dlg_set_remote_cap_hdr(\n\t\t\t\t    pjsip_dialog *dlg,\n\t\t\t\t    const pjsip_generic_array_hdr *cap_hdr);\n\n/**\n * Remove a remote capability header.\n *\n * @param dlg\t    The dialog.\n * @param htype\t    The header type to be removed, which value may be:\n *\t\t    - PJSIP_H_ACCEPT\n *\t\t    - PJSIP_H_ALLOW\n *\t\t    - PJSIP_H_SUPPORTED\n * @param hname\t    If htype specifies PJSIP_H_OTHER, then the header name\n *\t\t    must be supplied in this argument. Otherwise the value\n *\t\t    must be set to NULL.\n *\n * @return\t    PJ_SUCCESS when successful, otherwise the appropriate\n *\t\t    error code will be returned.\n */\nPJ_DECL(pj_status_t) pjsip_dlg_remove_remote_cap_hdr(pjsip_dialog *dlg,\n\t\t\t\t\t\t     int htype,\n\t\t\t\t\t\t     const pj_str_t *hname);\n\n/**\n * Update remote capabilities from a received message. The header types\n * to be updated from the message will only be \\a PJSIP_H_ACCEPT, \n * \\a PJSIP_H_ALLOW, and \\a PJSIP_H_SUPPORTED.\n *\n * @param dlg\t    The dialog.\n * @param msg\t    The received message.\n * @param strict    If this is set to PJ_TRUE, any header types missing\n *\t\t    from the message will cause removal of existing\n *\t\t    header types in the capability list. Otherwise, the \n *\t\t    capability list will not be modified when any header\n *                  type is missing.\n *\n * @return\t    PJ_SUCCESS when successful, otherwise the appropriate\n *\t\t    error code will be returned.\n */\nPJ_DECL(pj_status_t) pjsip_dlg_update_remote_cap(pjsip_dialog *dlg,\n\t\t\t\t\t         const pjsip_msg *msg,\n\t\t\t\t\t\t pj_bool_t strict);\n\n\n\n/**\n * @}\n */\n\n/* \n * Internal (called by sip_ua_layer.c)\n */\n\n/* Receives transaction event (called by user_agent module) */\nvoid pjsip_dlg_on_tsx_state( pjsip_dialog *dlg,\n\t\t\t     pjsip_transaction *tsx,\n\t\t\t     pjsip_event *e );\n\nvoid pjsip_dlg_on_rx_request( pjsip_dialog *dlg,\n\t\t\t      pjsip_rx_data *rdata );\n\nvoid pjsip_dlg_on_rx_response( pjsip_dialog *dlg,\n\t\t\t       pjsip_rx_data *rdata );\n\n\n\nPJ_END_DECL\n\n\n#endif\t/* __PJSIP_SIP_DIALOG_H__ */\n\n", "/* $Id$ */\n/*\n * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)\n * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n#include <pjsip/sip_dialog.h>\n#include <pjsip/sip_ua_layer.h>\n#include <pjsip/sip_errno.h>\n#include <pjsip/sip_endpoint.h>\n#include <pjsip/sip_parser.h>\n#include <pjsip/sip_module.h>\n#include <pjsip/sip_util.h>\n#include <pjsip/sip_transaction.h>\n#include <pj/assert.h>\n#include <pj/os.h>\n#include <pj/string.h>\n#include <pj/pool.h>\n#include <pj/guid.h>\n#include <pj/rand.h>\n#include <pj/array.h>\n#include <pj/except.h>\n#include <pj/hash.h>\n#include <pj/log.h>\n\n#define THIS_FILE\t\"sip_dialog.c\"\n\nlong pjsip_dlg_lock_tls_id;\n\n/* Config */\npj_bool_t pjsip_include_allow_hdr_in_dlg = PJSIP_INCLUDE_ALLOW_HDR_IN_DLG;\n\n/* Contact header string */\nstatic const pj_str_t HCONTACT = { \"Contact\", 7 };\n\n\nPJ_DEF(pj_bool_t) pjsip_method_creates_dialog(const pjsip_method *m)\n{\n    const pjsip_method subscribe = { PJSIP_OTHER_METHOD, {\"SUBSCRIBE\", 9}};\n    const pjsip_method refer = { PJSIP_OTHER_METHOD, {\"REFER\", 5}};\n    const pjsip_method notify = { PJSIP_OTHER_METHOD, {\"NOTIFY\", 6}};\n    const pjsip_method update = { PJSIP_OTHER_METHOD, {\"UPDATE\", 6}};\n\n    return m->id == PJSIP_INVITE_METHOD ||\n\t   (pjsip_method_cmp(m, &subscribe)==0) ||\n\t   (pjsip_method_cmp(m, &refer)==0) ||\n\t   (pjsip_method_cmp(m, &notify)==0) ||\n\t   (pjsip_method_cmp(m, &update)==0);\n}\n\nstatic void dlg_on_destroy( void *arg )\n{\n    pjsip_dialog *dlg = (pjsip_dialog *)arg;\n\n    PJ_LOG(5,(dlg->obj_name, \"Dialog destroyed!\"));\n\n    pjsip_endpt_release_pool(dlg->endpt, dlg->pool);\n}\n\nstatic pj_status_t create_dialog( pjsip_user_agent *ua,\n\t\t\t\t  pj_grp_lock_t *grp_lock,\n\t\t\t\t  pjsip_dialog **p_dlg)\n{\n    pjsip_endpoint *endpt;\n    pj_pool_t *pool;\n    pjsip_dialog *dlg;\n    pj_status_t status;\n\n    endpt = pjsip_ua_get_endpt(ua);\n    if (!endpt)\n\treturn PJ_EINVALIDOP;\n\n    pool = pjsip_endpt_create_pool(endpt, \"dlg%p\",\n\t\t\t\t   PJSIP_POOL_LEN_DIALOG,\n\t\t\t\t   PJSIP_POOL_INC_DIALOG);\n    if (!pool)\n\treturn PJ_ENOMEM;\n\n    dlg = PJ_POOL_ZALLOC_T(pool, pjsip_dialog);\n    PJ_ASSERT_RETURN(dlg != NULL, PJ_ENOMEM);\n\n    dlg->pool = pool;\n    pj_ansi_snprintf(dlg->obj_name, sizeof(dlg->obj_name), \"dlg%p\", dlg);\n    dlg->ua = ua;\n    dlg->endpt = endpt;\n    dlg->state = PJSIP_DIALOG_STATE_NULL;\n    dlg->add_allow = pjsip_include_allow_hdr_in_dlg;\n\n    pj_list_init(&dlg->inv_hdr);\n    pj_list_init(&dlg->rem_cap_hdr);\n\n    /* Init client authentication session. */\n    status = pjsip_auth_clt_init(&dlg->auth_sess, dlg->endpt,\n\t\t\t\t dlg->pool, 0);\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n\n    if (grp_lock) {\n\tdlg->grp_lock_ = grp_lock;\n    } else {\n \tstatus = pj_grp_lock_create(pool, NULL, &dlg->grp_lock_);\n \tif (status != PJ_SUCCESS) {\n\t    goto on_error;\n \t}\n    }\n\n    pj_grp_lock_add_ref(dlg->grp_lock_);\n    pj_grp_lock_add_handler(dlg->grp_lock_, pool, dlg, &dlg_on_destroy);\n\n    pjsip_target_set_init(&dlg->target_set);\n\n    *p_dlg = dlg;\n    return PJ_SUCCESS;\n\non_error:\n    pjsip_endpt_release_pool(endpt, pool);\n    return status;\n}\n\nstatic void destroy_dialog( pjsip_dialog *dlg, pj_bool_t unlock_mutex )\n{\n    if (dlg->tp_sel.type != PJSIP_TPSELECTOR_NONE) {\n\tpjsip_tpselector_dec_ref(&dlg->tp_sel);\n\tpj_bzero(&dlg->tp_sel, sizeof(pjsip_tpselector));\n    }\n    pjsip_auth_clt_deinit(&dlg->auth_sess);\n\n    pj_grp_lock_dec_ref(dlg->grp_lock_);\n\n    if (unlock_mutex)\n\tpj_grp_lock_release(dlg->grp_lock_);\n}\n\n/*\n * Create an UAC dialog.\n */\nPJ_DEF(pj_status_t) pjsip_dlg_create_uac( pjsip_user_agent *ua,\n\t\t\t\t\t  const pj_str_t *local_uri,\n\t\t\t\t\t  const pj_str_t *local_contact,\n\t\t\t\t\t  const pj_str_t *remote_uri,\n\t\t\t\t\t  const pj_str_t *target,\n\t\t\t\t\t  pjsip_dialog **p_dlg)\n{\n    pjsip_dlg_create_uac_param create_param;\n\n    PJ_ASSERT_RETURN(ua && local_uri && remote_uri && p_dlg, PJ_EINVAL);\n\n    pj_bzero(&create_param, sizeof(create_param));\n    create_param.ua = ua;\n    create_param.local_uri = *local_uri;\n    create_param.remote_uri = *remote_uri;\n    if (local_contact)\n\tcreate_param.local_contact = *local_contact;\n\n    if (target)\n\tcreate_param.target = *target;\n\n    return pjsip_dlg_create_uac2(&create_param, p_dlg);\n}\n\nPJ_DEF(pj_status_t) pjsip_dlg_create_uac2(\n\t\t\t\tconst pjsip_dlg_create_uac_param *create_param,\n\t\t\t\tpjsip_dialog **p_dlg)\n{\n    pj_status_t status;\n    pj_str_t tmp;\n    pjsip_dialog *dlg;\n\n    /* Check arguments. */\n    PJ_ASSERT_RETURN(create_param->ua && create_param->local_uri.slen &&\n\t\t     create_param->remote_uri.slen && p_dlg, PJ_EINVAL);\n\n    /* Create dialog instance. */\n    status = create_dialog(create_param->ua, create_param->grp_lock, &dlg);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Parse target. */\n    pj_strdup_with_null(dlg->pool, &tmp, create_param->target.slen ?\n\t\t\t&create_param->target : &create_param->remote_uri);\n    dlg->target = pjsip_parse_uri(dlg->pool, tmp.ptr, tmp.slen, 0);\n    if (!dlg->target) {\n\tstatus = PJSIP_EINVALIDURI;\n\tgoto on_error;\n    }\n\n    /* Put any header param in the target URI into INVITE header list. */\n    if (PJSIP_URI_SCHEME_IS_SIP(dlg->target) ||\n\tPJSIP_URI_SCHEME_IS_SIPS(dlg->target))\n    {\n\tpjsip_param *param;\n\tpjsip_sip_uri *uri = (pjsip_sip_uri*)pjsip_uri_get_uri(dlg->target);\n\n\tparam = uri->header_param.next;\n\twhile (param != &uri->header_param) {\n\t    if (param->value.ptr) {\n\t\tpjsip_hdr *hdr;\n\t\tint c;\n\n\t\tc = param->value.ptr[param->value.slen];\n\t\tparam->value.ptr[param->value.slen] = '\\0';\n\n\t\thdr = (pjsip_hdr*)\n\t\t    pjsip_parse_hdr(dlg->pool, &param->name, param->value.ptr,\n\t\t\t\t    param->value.slen, NULL);\n\n\t\tparam->value.ptr[param->value.slen] = (char)c;\n\n\t\tif (hdr == NULL) {\n\t\t    status = PJSIP_EINVALIDURI;\n\t\t    goto on_error;\n\t\t}\n\t\tpj_list_push_back(&dlg->inv_hdr, hdr);\n\t    }\n\n\t    param = param->next;\n\t}\n\n\t/* Now must remove any header params from URL, since that would\n\t * create another header in pjsip_endpt_create_request().\n\t */\n\tpj_list_init(&uri->header_param);\n    }\n\n    /* Add target to the target set */\n    pjsip_target_set_add_uri(&dlg->target_set, dlg->pool, dlg->target, 0);\n\n    /* Init local info. */\n    dlg->local.info = pjsip_from_hdr_create(dlg->pool);\n    pj_strdup_with_null(dlg->pool, &dlg->local.info_str,\n\t\t\t&create_param->local_uri);\n    dlg->local.info->uri = pjsip_parse_uri(dlg->pool,\n\t\t\t\t\t   dlg->local.info_str.ptr,\n\t\t\t\t\t   dlg->local.info_str.slen, 0);\n    if (!dlg->local.info->uri) {\n\tstatus = PJSIP_EINVALIDURI;\n\tgoto on_error;\n    }\n\n    /* Generate local tag. */\n    pj_create_unique_string(dlg->pool, &dlg->local.info->tag);\n\n    /* Calculate hash value of local tag. */\n    dlg->local.tag_hval = pj_hash_calc_tolower(0, NULL,\n                                               &dlg->local.info->tag);\n\n    /* Randomize local CSeq. */\n    dlg->local.first_cseq = pj_rand() & 0x7FFF;\n    dlg->local.cseq = dlg->local.first_cseq;\n\n    /* Init local contact. */\n    pj_strdup_with_null(dlg->pool, &tmp,\n\t\t    create_param->local_contact.slen ?\n\t\t    &create_param->local_contact : &create_param->local_uri);\n    dlg->local.contact = (pjsip_contact_hdr*)\n\t\t\t pjsip_parse_hdr(dlg->pool, &HCONTACT, tmp.ptr,\n\t\t\t\t\t tmp.slen, NULL);\n    if (!dlg->local.contact) {\n\tstatus = PJSIP_EINVALIDURI;\n\tgoto on_error;\n    }\n\n    /* Init remote info. */\n    dlg->remote.info = pjsip_to_hdr_create(dlg->pool);\n    pj_strdup_with_null(dlg->pool, &dlg->remote.info_str,\n\t\t\t&create_param->remote_uri);\n    dlg->remote.info->uri = pjsip_parse_uri(dlg->pool,\n\t\t\t\t\t    dlg->remote.info_str.ptr,\n\t\t\t\t\t    dlg->remote.info_str.slen, 0);\n    if (!dlg->remote.info->uri) {\n\tstatus = PJSIP_EINVALIDURI;\n\tgoto on_error;\n    }\n\n    /* Remove header param from remote.info_str, if any */\n    if (PJSIP_URI_SCHEME_IS_SIP(dlg->remote.info->uri) ||\n\tPJSIP_URI_SCHEME_IS_SIPS(dlg->remote.info->uri))\n    {\n\tpjsip_sip_uri *sip_uri = (pjsip_sip_uri *)\n\t\t\t\t pjsip_uri_get_uri(dlg->remote.info->uri);\n\tif (!pj_list_empty(&sip_uri->header_param)) {\n\t    pj_str_t tmp2;\n\n\t    /* Remove all header param */\n\t    pj_list_init(&sip_uri->header_param);\n\n\t    /* Print URI */\n\t    tmp2.ptr = (char*) pj_pool_alloc(dlg->pool,\n\t    \t\t\t\t    dlg->remote.info_str.slen);\n\t    tmp2.slen = pjsip_uri_print(PJSIP_URI_IN_FROMTO_HDR,\n\t\t\t\t       sip_uri, tmp2.ptr,\n\t\t\t\t       dlg->remote.info_str.slen);\n\n\t    if (tmp2.slen < 1) {\n\t\tstatus = PJSIP_EURITOOLONG;\n\t\tgoto on_error;\n\t    }\n\n\t    /* Assign remote.info_str */\n\t    dlg->remote.info_str = tmp2;\n\t}\n    }\n\n\n    /* Initialize remote's CSeq to -1. */\n    dlg->remote.cseq = dlg->remote.first_cseq = -1;\n\n    /* Initial role is UAC. */\n    dlg->role = PJSIP_ROLE_UAC;\n\n    /* Secure? */\n    dlg->secure = PJSIP_URI_SCHEME_IS_SIPS(dlg->target);\n\n    /* Generate Call-ID header. */\n    dlg->call_id = pjsip_cid_hdr_create(dlg->pool);\n    pj_create_unique_string(dlg->pool, &dlg->call_id->id);\n\n    /* Initial route set is empty. */\n    pj_list_init(&dlg->route_set);\n\n    /* Register this dialog to user agent. */\n    status = pjsip_ua_register_dlg( create_param->ua, dlg );\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n\n    /* Done! */\n    *p_dlg = dlg;\n\n    PJ_LOG(5,(dlg->obj_name, \"UAC dialog created\"));\n\n    return PJ_SUCCESS;\n\non_error:\n    destroy_dialog(dlg, PJ_FALSE);\n    return status;\n}\n\n\n/*\n * Create UAS dialog.\n */\npj_status_t create_uas_dialog( pjsip_user_agent *ua,\n\t\t\t       pjsip_rx_data *rdata,\n\t\t\t       const pj_str_t *contact,\n\t\t\t       pj_bool_t inc_lock,\n\t\t\t       pjsip_dialog **p_dlg)\n{\n    pj_status_t status;\n    pjsip_hdr *pos = NULL;\n    pjsip_contact_hdr *contact_hdr;\n    pjsip_rr_hdr *rr;\n    pjsip_transaction *tsx = NULL;\n    pj_str_t tmp;\n    enum { TMP_LEN=PJSIP_MAX_URL_SIZE };\n    pj_ssize_t len;\n    pjsip_dialog *dlg;\n    pj_bool_t lock_incremented = PJ_FALSE;\n\n    /* Check arguments. */\n    PJ_ASSERT_RETURN(ua && rdata && p_dlg, PJ_EINVAL);\n\n    /* rdata must have request message. */\n    PJ_ASSERT_RETURN(rdata->msg_info.msg->type == PJSIP_REQUEST_MSG,\n\t\t     PJSIP_ENOTREQUESTMSG);\n\n    /* Request must not have To tag.\n     * This should have been checked in the user agent (or application?).\n     */\n    PJ_ASSERT_RETURN(rdata->msg_info.to->tag.slen == 0, PJ_EINVALIDOP);\n\n    /* The request must be a dialog establishing request. */\n    PJ_ASSERT_RETURN(\n\tpjsip_method_creates_dialog(&rdata->msg_info.msg->line.req.method),\n\tPJ_EINVALIDOP);\n\n    /* Create dialog instance. */\n    status = create_dialog(ua, NULL, &dlg);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Temprary string for getting the string representation of\n     * both local and remote URI.\n     */\n    tmp.ptr = (char*) pj_pool_alloc(rdata->tp_info.pool, TMP_LEN);\n\n    /* Init local info from the To header. */\n    dlg->local.info = (pjsip_fromto_hdr*)\n    \t\t      pjsip_hdr_clone(dlg->pool, rdata->msg_info.to);\n    pjsip_fromto_hdr_set_from(dlg->local.info);\n\n    /* Generate local tag. */\n    pj_create_unique_string(dlg->pool, &dlg->local.info->tag);\n\n\n    /* Print the local info. */\n    len = pjsip_uri_print(PJSIP_URI_IN_FROMTO_HDR,\n\t\t\t  dlg->local.info->uri, tmp.ptr, TMP_LEN);\n    if (len < 1) {\n\tpj_ansi_strcpy(tmp.ptr, \"<-error: uri too long->\");\n\ttmp.slen = pj_ansi_strlen(tmp.ptr);\n    } else\n\ttmp.slen = len;\n\n    /* Save the local info. */\n    pj_strdup(dlg->pool, &dlg->local.info_str, &tmp);\n\n    /* Calculate hash value of local tag. */\n    dlg->local.tag_hval = pj_hash_calc_tolower(0, NULL, &dlg->local.info->tag);\n\n\n    /* Randomize local cseq */\n    dlg->local.first_cseq = pj_rand() & 0x7FFF;\n    dlg->local.cseq = dlg->local.first_cseq;\n\n    /* Init local contact. */\n    /* TODO:\n     *  Section 12.1.1, paragraph about using SIPS URI in Contact.\n     *  If the request that initiated the dialog contained a SIPS URI\n     *  in the Request-URI or in the top Record-Route header field value,\n     *  if there was any, or the Contact header field if there was no\n     *  Record-Route header field, the Contact header field in the response\n     *  MUST be a SIPS URI.\n     */\n    if (contact) {\n\tpj_str_t tmp2;\n\n\tpj_strdup_with_null(dlg->pool, &tmp2, contact);\n\tdlg->local.contact = (pjsip_contact_hdr*)\n\t\t\t     pjsip_parse_hdr(dlg->pool, &HCONTACT, tmp2.ptr,\n\t\t\t\t\t     tmp2.slen, NULL);\n\tif (!dlg->local.contact) {\n\t    status = PJSIP_EINVALIDURI;\n\t    goto on_error;\n\t}\n\n    } else {\n\tdlg->local.contact = pjsip_contact_hdr_create(dlg->pool);\n\tdlg->local.contact->uri = dlg->local.info->uri;\n    }\n\n    /* Init remote info from the From header. */\n    dlg->remote.info = (pjsip_fromto_hdr*)\n    \t\t       pjsip_hdr_clone(dlg->pool, rdata->msg_info.from);\n    pjsip_fromto_hdr_set_to(dlg->remote.info);\n\n    /* Print the remote info. */\n    len = pjsip_uri_print(PJSIP_URI_IN_FROMTO_HDR,\n\t\t\t  dlg->remote.info->uri, tmp.ptr, TMP_LEN);\n    if (len < 1) {\n\tpj_ansi_strcpy(tmp.ptr, \"<-error: uri too long->\");\n\ttmp.slen = pj_ansi_strlen(tmp.ptr);\n    } else\n\ttmp.slen = len;\n\n    /* Save the remote info. */\n    pj_strdup(dlg->pool, &dlg->remote.info_str, &tmp);\n\n\n    /* Init remote's contact from Contact header.\n     * Iterate the Contact URI until we find sip: or sips: scheme.\n     */\n    do {\n\tcontact_hdr = (pjsip_contact_hdr*)\n\t\t      pjsip_msg_find_hdr(rdata->msg_info.msg, PJSIP_H_CONTACT,\n\t\t\t\t         pos);\n\tif (contact_hdr) {\n\t    if (!contact_hdr->uri ||\n\t\t(!PJSIP_URI_SCHEME_IS_SIP(contact_hdr->uri) &&\n\t\t !PJSIP_URI_SCHEME_IS_SIPS(contact_hdr->uri)))\n\t    {\n\t\tpos = (pjsip_hdr*)contact_hdr->next;\n\t\tif (pos == &rdata->msg_info.msg->hdr)\n\t\t    contact_hdr = NULL;\n\t    } else {\n\t\tbreak;\n\t    }\n\t}\n    } while (contact_hdr);\n\n    if (!contact_hdr) {\n\tstatus = PJSIP_ERRNO_FROM_SIP_STATUS(PJSIP_SC_BAD_REQUEST);\n\tgoto on_error;\n    }\n\n    dlg->remote.contact = (pjsip_contact_hdr*)\n    \t\t\t  pjsip_hdr_clone(dlg->pool, (pjsip_hdr*)contact_hdr);\n\n    /* Init remote's CSeq from CSeq header */\n    dlg->remote.cseq = dlg->remote.first_cseq = rdata->msg_info.cseq->cseq;\n\n    /* Set initial target to remote's Contact. */\n    dlg->target = dlg->remote.contact->uri;\n\n    /* Initial role is UAS */\n    dlg->role = PJSIP_ROLE_UAS;\n\n    /* Secure?\n     *  RFC 3261 Section 12.1.1:\n     *  If the request arrived over TLS, and the Request-URI contained a\n     *  SIPS URI, the 'secure' flag is set to TRUE.\n     */\n    dlg->secure = PJSIP_TRANSPORT_IS_SECURE(rdata->tp_info.transport) &&\n\t\t  PJSIP_URI_SCHEME_IS_SIPS(rdata->msg_info.msg->line.req.uri);\n\n    /* Call-ID */\n    dlg->call_id = (pjsip_cid_hdr*)\n    \t\t   pjsip_hdr_clone(dlg->pool, rdata->msg_info.cid);\n\n    /* Route set.\n     *  RFC 3261 Section 12.1.1:\n     *  The route set MUST be set to the list of URIs in the Record-Route\n     *  header field from the request, taken in order and preserving all URI\n     *  parameters. If no Record-Route header field is present in the request,\n     * the route set MUST be set to the empty set.\n     */\n    pj_list_init(&dlg->route_set);\n    rr = rdata->msg_info.record_route;\n    while (rr != NULL) {\n\tpjsip_route_hdr *route;\n\n\t/* Clone the Record-Route, change the type to Route header. */\n\troute = (pjsip_route_hdr*) pjsip_hdr_clone(dlg->pool, rr);\n\tpjsip_routing_hdr_set_route(route);\n\n\t/* Add to route set. */\n\tpj_list_push_back(&dlg->route_set, route);\n\n\t/* Find next Record-Route header. */\n\trr = rr->next;\n\tif (rr == (void*)&rdata->msg_info.msg->hdr)\n\t    break;\n\trr = (pjsip_route_hdr*) pjsip_msg_find_hdr(rdata->msg_info.msg,\n\t\t\t\t\t\t   PJSIP_H_RECORD_ROUTE, rr);\n    }\n    dlg->route_set_frozen = PJ_TRUE;\n\n    /* Increment the dialog's lock since tsx may cause the dialog to be\n     * destroyed prematurely (such as in case of transport error).\n     */\n    if (inc_lock) {\n        pjsip_dlg_inc_lock(dlg);\n        lock_incremented = PJ_TRUE;\n    }\n\n    /* Create UAS transaction for this request. */\n    status = pjsip_tsx_create_uas(dlg->ua, rdata, &tsx);\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n\n    /* Associate this dialog to the transaction. */\n    tsx->mod_data[dlg->ua->id] = dlg;\n\n    /* Increment tsx counter */\n    ++dlg->tsx_count;\n\n    /* Calculate hash value of remote tag. */\n    dlg->remote.tag_hval = pj_hash_calc_tolower(0, NULL, &dlg->remote.info->tag);\n\n    /* Update remote capabilities info */\n    pjsip_dlg_update_remote_cap(dlg, rdata->msg_info.msg, PJ_TRUE);\n\n    /* Register this dialog to user agent. */\n    status = pjsip_ua_register_dlg( ua, dlg );\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n\n    /* Put this dialog in rdata's mod_data */\n    rdata->endpt_info.mod_data[ua->id] = dlg;\n\n    PJ_TODO(DIALOG_APP_TIMER);\n\n    /* Feed the first request to the transaction. */\n    pjsip_tsx_recv_msg(tsx, rdata);\n\n    /* Done. */\n    *p_dlg = dlg;\n    PJ_LOG(5,(dlg->obj_name, \"UAS dialog created\"));\n    return PJ_SUCCESS;\n\non_error:\n    if (tsx) {\n\tpjsip_tsx_terminate(tsx, 500);\n\tpj_assert(dlg->tsx_count>0);\n\t--dlg->tsx_count;\n    }\n\n    if (lock_incremented) {\n        pjsip_dlg_dec_lock(dlg);\n    } else {\n        destroy_dialog(dlg, PJ_FALSE);\n    }\n\n    return status;\n}\n\n\n#if !DEPRECATED_FOR_TICKET_1902\n/*\n * Create UAS dialog.\n */\nPJ_DEF(pj_status_t) pjsip_dlg_create_uas(   pjsip_user_agent *ua,\n\t\t\t\t\t    pjsip_rx_data *rdata,\n\t\t\t\t\t    const pj_str_t *contact,\n\t\t\t\t\t    pjsip_dialog **p_dlg)\n{\n    return create_uas_dialog(ua, rdata, contact, PJ_FALSE, p_dlg);\n}\n#endif\n\n\n/*\n * Create UAS dialog and increase its session count.\n */\nPJ_DEF(pj_status_t)\npjsip_dlg_create_uas_and_inc_lock(    pjsip_user_agent *ua,\n\t\t\t\t      pjsip_rx_data *rdata,\n\t\t\t\t      const pj_str_t *contact,\n\t\t\t\t      pjsip_dialog **p_dlg)\n{\n    return create_uas_dialog(ua, rdata, contact, PJ_TRUE, p_dlg);\n}\n\n\n/*\n * Bind dialog to a specific transport/listener.\n */\nPJ_DEF(pj_status_t) pjsip_dlg_set_transport( pjsip_dialog *dlg,\n\t\t\t\t\t     const pjsip_tpselector *sel)\n{\n    /* Validate */\n    PJ_ASSERT_RETURN(dlg && sel, PJ_EINVAL);\n\n    /* Start locking the dialog. */\n    pjsip_dlg_inc_lock(dlg);\n\n    /* Decrement reference counter of previous transport selector */\n    pjsip_tpselector_dec_ref(&dlg->tp_sel);\n\n    /* Copy transport selector structure .*/\n    pj_memcpy(&dlg->tp_sel, sel, sizeof(*sel));\n\n    /* Increment reference counter */\n    pjsip_tpselector_add_ref(&dlg->tp_sel);\n\n    /* Unlock dialog. */\n    pjsip_dlg_dec_lock(dlg);\n\n    return PJ_SUCCESS;\n}\n\n/*\n * Set \"sent-by\" field of Via header.\n */\nPJ_DEF(pj_status_t) pjsip_dlg_set_via_sent_by( pjsip_dialog *dlg,\n\t\t\t\t               pjsip_host_port *via_addr,\n                                               pjsip_transport *via_tp)\n{\n    PJ_ASSERT_RETURN(dlg, PJ_EINVAL);\n\n    if (!via_addr)\n        pj_bzero(&dlg->via_addr, sizeof(dlg->via_addr));\n    else {\n        if (pj_strcmp(&dlg->via_addr.host, &via_addr->host))\n            pj_strdup(dlg->pool, &dlg->via_addr.host, &via_addr->host);\n        dlg->via_addr.port = via_addr->port;\n    }\n    dlg->via_tp = via_tp;\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Create forked dialog from a response.\n */\nPJ_DEF(pj_status_t) pjsip_dlg_fork( const pjsip_dialog *first_dlg,\n\t\t\t\t    const pjsip_rx_data *rdata,\n\t\t\t\t    pjsip_dialog **new_dlg )\n{\n    pjsip_dialog *dlg;\n    const pjsip_msg *msg = rdata->msg_info.msg;\n    const pjsip_hdr *end_hdr, *hdr;\n    const pjsip_contact_hdr *contact;\n    pj_status_t status;\n\n    /* Check arguments. */\n    PJ_ASSERT_RETURN(first_dlg && rdata && new_dlg, PJ_EINVAL);\n\n    /* rdata must be response message. */\n    PJ_ASSERT_RETURN(msg->type == PJSIP_RESPONSE_MSG,\n\t\t     PJSIP_ENOTRESPONSEMSG);\n\n    /* Status code MUST be 1xx (but not 100), or 2xx */\n    status = msg->line.status.code;\n    PJ_ASSERT_RETURN( (status/100==1 && status!=100) ||\n\t\t      (status/100==2), PJ_EBUG);\n\n    /* To tag must present in the response. */\n    PJ_ASSERT_RETURN(rdata->msg_info.to->tag.slen != 0, PJSIP_EMISSINGTAG);\n\n    /* Find Contact header in the response */\n    contact = (const pjsip_contact_hdr*)\n\t      pjsip_msg_find_hdr(msg, PJSIP_H_CONTACT, NULL);\n    if (contact == NULL || contact->uri == NULL)\n\treturn PJSIP_EMISSINGHDR;\n\n    /* Create the dialog. */\n    status = create_dialog((pjsip_user_agent*)first_dlg->ua, NULL, &dlg);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Set remote target from the response. */\n    dlg->target = (pjsip_uri*) pjsip_uri_clone(dlg->pool, contact->uri);\n\n    /* Clone local info. */\n    dlg->local.info = (pjsip_fromto_hdr*)\n    \t\t      pjsip_hdr_clone(dlg->pool, first_dlg->local.info);\n\n    /* Clone local tag. */\n    pj_strdup(dlg->pool, &dlg->local.info->tag, &first_dlg->local.info->tag);\n    dlg->local.tag_hval = first_dlg->local.tag_hval;\n\n    /* Clone local CSeq. */\n    dlg->local.first_cseq = first_dlg->local.first_cseq;\n    dlg->local.cseq = first_dlg->local.cseq;\n\n    /* Clone local Contact. */\n    dlg->local.contact = (pjsip_contact_hdr*)\n    \t\t\t pjsip_hdr_clone(dlg->pool, first_dlg->local.contact);\n\n    /* Clone remote info. */\n    dlg->remote.info = (pjsip_fromto_hdr*)\n    \t\t       pjsip_hdr_clone(dlg->pool, first_dlg->remote.info);\n\n    /* Set remote tag from the response. */\n    pj_strdup(dlg->pool, &dlg->remote.info->tag, &rdata->msg_info.to->tag);\n\n    /* Initialize remote's CSeq to -1. */\n    dlg->remote.cseq = dlg->remote.first_cseq = -1;\n\n    /* Initial role is UAC. */\n    dlg->role = PJSIP_ROLE_UAC;\n\n    /* Dialog state depends on the response. */\n    status = msg->line.status.code/100;\n    if (status == 1 || status == 2)\n\tdlg->state = PJSIP_DIALOG_STATE_ESTABLISHED;\n    else {\n\tpj_assert(!\"Invalid status code\");\n\tdlg->state = PJSIP_DIALOG_STATE_NULL;\n    }\n\n    /* Secure? */\n    dlg->secure = PJSIP_URI_SCHEME_IS_SIPS(dlg->target);\n\n    /* Clone Call-ID header. */\n    dlg->call_id = (pjsip_cid_hdr*)\n    \t\t   pjsip_hdr_clone(dlg->pool, first_dlg->call_id);\n\n    /* Get route-set from the response. */\n    pj_list_init(&dlg->route_set);\n    end_hdr = &msg->hdr;\n    for (hdr=msg->hdr.prev; hdr!=end_hdr; hdr=hdr->prev) {\n\tif (hdr->type == PJSIP_H_RECORD_ROUTE) {\n\t    pjsip_route_hdr *r;\n\t    r = (pjsip_route_hdr*) pjsip_hdr_clone(dlg->pool, hdr);\n\t    pjsip_routing_hdr_set_route(r);\n\t    pj_list_push_back(&dlg->route_set, r);\n\t}\n    }\n\n    //dlg->route_set_frozen = PJ_TRUE;\n\n    /* Clone client authentication session. */\n    status = pjsip_auth_clt_clone(dlg->pool, &dlg->auth_sess,\n\t\t\t\t  &first_dlg->auth_sess);\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n\n    /* Register this dialog to user agent. */\n    status = pjsip_ua_register_dlg(dlg->ua, dlg );\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n\n\n    /* Done! */\n    *new_dlg = dlg;\n\n    PJ_LOG(5,(dlg->obj_name, \"Forked dialog created\"));\n    return PJ_SUCCESS;\n\non_error:\n    destroy_dialog(dlg, PJ_FALSE);\n    return status;\n}\n\n\n/*\n * Unregister and destroy dialog.\n */\nstatic pj_status_t unregister_and_destroy_dialog( pjsip_dialog *dlg,\n\t\t\t\t\t\t  pj_bool_t unlock_mutex )\n{\n    pj_status_t status;\n\n    /* Lock must have been held. */\n\n    /* Check dialog state. */\n    /* Number of sessions must be zero. */\n    PJ_ASSERT_RETURN(dlg->sess_count==0, PJ_EINVALIDOP);\n\n    /* MUST not have pending transactions. */\n    PJ_ASSERT_RETURN(dlg->tsx_count==0, PJ_EINVALIDOP);\n\n    /* Unregister from user agent, if it has been registered (see #1924) */\n    if (dlg->dlg_set) {\n\tstatus = pjsip_ua_unregister_dlg(dlg->ua, dlg);\n\tif (status != PJ_SUCCESS) {\n\t    pj_assert(!\"Unexpected failed unregistration!\");\n\t    return status;\n\t}\n    }\n\n    /* Destroy this dialog. */\n    destroy_dialog(dlg, unlock_mutex);\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Forcefully terminate dialog.\n */\nPJ_DEF(pj_status_t) pjsip_dlg_terminate( pjsip_dialog *dlg )\n{\n    /* Number of sessions must be zero. */\n    PJ_ASSERT_RETURN(dlg->sess_count==0, PJ_EINVALIDOP);\n\n    /* MUST not have pending transactions. */\n    PJ_ASSERT_RETURN(dlg->tsx_count==0, PJ_EINVALIDOP);\n\n    return unregister_and_destroy_dialog(dlg, PJ_FALSE);\n}\n\n\n/*\n * Set route_set\n */\nPJ_DEF(pj_status_t) pjsip_dlg_set_route_set( pjsip_dialog *dlg,\n\t\t\t\t\t     const pjsip_route_hdr *route_set )\n{\n    pjsip_route_hdr *r;\n\n    PJ_ASSERT_RETURN(dlg, PJ_EINVAL);\n\n    pjsip_dlg_inc_lock(dlg);\n\n    /* Clear route set. */\n    pj_list_init(&dlg->route_set);\n\n    if (!route_set) {\n\tpjsip_dlg_dec_lock(dlg);\n\treturn PJ_SUCCESS;\n    }\n\n    r = route_set->next;\n    while (r != route_set) {\n\tpjsip_route_hdr *new_r;\n\n\tnew_r = (pjsip_route_hdr*) pjsip_hdr_clone(dlg->pool, r);\n\tpj_list_push_back(&dlg->route_set, new_r);\n\n\tr = r->next;\n    }\n\n    pjsip_dlg_dec_lock(dlg);\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Increment session counter.\n */\nPJ_DEF(pj_status_t) pjsip_dlg_inc_session( pjsip_dialog *dlg,\n\t\t\t\t\t   pjsip_module *mod )\n{\n    PJ_ASSERT_RETURN(dlg && mod, PJ_EINVAL);\n\n    pj_log_push_indent();\n\n    pjsip_dlg_inc_lock(dlg);\n    ++dlg->sess_count;\n    pjsip_dlg_dec_lock(dlg);\n\n    PJ_LOG(5,(dlg->obj_name, \"Session count inc to %d by %.*s\",\n\t      dlg->sess_count, (int)mod->name.slen, mod->name.ptr));\n\n    pj_log_pop_indent();\n    return PJ_SUCCESS;\n}\n\n/*\n * Lock dialog and increment session count temporarily\n * to prevent it from being deleted. In addition, it must lock\n * the user agent's dialog table first, to prevent deadlock.\n */\nPJ_DEF(void) pjsip_dlg_inc_lock(pjsip_dialog *dlg)\n{\n    PJ_LOG(6,(dlg->obj_name, \"Entering pjsip_dlg_inc_lock(), sess_count=%d\",\n\t      dlg->sess_count));\n\n    pj_grp_lock_acquire(dlg->grp_lock_);\n    dlg->sess_count++;\n\n    PJ_LOG(6,(dlg->obj_name, \"Leaving pjsip_dlg_inc_lock(), sess_count=%d\",\n\t      dlg->sess_count));\n}\n\n/* Try to acquire dialog's group lock, but bail out if group lock can not be\n * acquired immediately.\n */\nPJ_DEF(pj_status_t) pjsip_dlg_try_inc_lock(pjsip_dialog *dlg)\n{\n    pj_status_t status;\n\n    PJ_LOG(6,(dlg->obj_name,\"Entering pjsip_dlg_try_inc_lock(), sess_count=%d\",\n\t      dlg->sess_count));\n\n    status = pj_grp_lock_tryacquire(dlg->grp_lock_);\n    if (status != PJ_SUCCESS) {\n\tPJ_LOG(6,(dlg->obj_name, \"pjsip_dlg_try_inc_lock() failed\"));\n\treturn status;\n    }\n\n    dlg->sess_count++;\n\n    PJ_LOG(6,(dlg->obj_name, \"Leaving pjsip_dlg_try_inc_lock(), sess_count=%d\",\n\t      dlg->sess_count));\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Unlock dialog and decrement reference counter.\n * It may delete the dialog!\n */\nPJ_DEF(void) pjsip_dlg_dec_lock(pjsip_dialog *dlg)\n{\n    PJ_ASSERT_ON_FAIL(dlg!=NULL, return);\n\n    PJ_LOG(6,(dlg->obj_name, \"Entering pjsip_dlg_dec_lock(), sess_count=%d\",\n\t      dlg->sess_count));\n\n    pj_assert(dlg->sess_count > 0);\n    --dlg->sess_count;\n\n    if (dlg->sess_count==0 && dlg->tsx_count==0) {\n\tpj_grp_lock_release(dlg->grp_lock_);\n\tpj_grp_lock_acquire(dlg->grp_lock_);\n\t/* We are holding the dialog group lock here, so before we destroy\n\t * the dialog, make sure that we unlock it first to avoid\n\t * undefined behaviour on some platforms. See ticket #1886.\n\t */\n\tunregister_and_destroy_dialog(dlg, PJ_TRUE);\n    } else {\n\tpj_grp_lock_release(dlg->grp_lock_);\n    }\n\n    PJ_LOG(6,(THIS_FILE, \"Leaving pjsip_dlg_dec_lock() (dlg=%p)\", dlg));\n}\n\n\n/*\n * Decrement session count.\n */\nPJ_DEF(pj_status_t) pjsip_dlg_dec_session( pjsip_dialog *dlg,\n\t\t\t\t\t   pjsip_module *mod)\n{\n    PJ_ASSERT_RETURN(dlg, PJ_EINVAL);\n\n    pj_log_push_indent();\n\n    PJ_LOG(5,(dlg->obj_name, \"Session count dec to %d by %.*s\",\n\t      dlg->sess_count-1, (int)mod->name.slen, mod->name.ptr));\n\n    pjsip_dlg_inc_lock(dlg);\n    --dlg->sess_count;\n    pjsip_dlg_dec_lock(dlg);\n\n    pj_log_pop_indent();\n    return PJ_SUCCESS;\n}\n\nPJ_DEF(pj_grp_lock_t *) pjsip_dlg_get_lock(pjsip_dialog *dlg)\n{\n    PJ_ASSERT_RETURN(dlg, NULL);\n    return dlg->grp_lock_;\n}\n\n/*\n * Check if the module is registered as a usage\n */\nPJ_DEF(pj_bool_t) pjsip_dlg_has_usage( pjsip_dialog *dlg,\n\t\t\t\t\t  pjsip_module *mod)\n{\n    unsigned index;\n    pj_bool_t found = PJ_FALSE;\n\n    pjsip_dlg_inc_lock(dlg);\n    for (index=0; index<dlg->usage_cnt; ++index) {\n    \tif (dlg->usage[index] == mod) {\n    \t    found = PJ_TRUE;\n    \t    break;\n    \t}\n    }\n    pjsip_dlg_dec_lock(dlg);\n\n    return found;\n}\n\n/*\n * Add usage.\n */\nPJ_DEF(pj_status_t) pjsip_dlg_add_usage( pjsip_dialog *dlg,\n\t\t\t\t\t pjsip_module *mod,\n\t\t\t\t\t void *mod_data )\n{\n    unsigned index;\n\n    PJ_ASSERT_RETURN(dlg && mod, PJ_EINVAL);\n    PJ_ASSERT_RETURN(mod->id >= 0 && mod->id < PJSIP_MAX_MODULE,\n\t\t     PJ_EINVAL);\n    PJ_ASSERT_RETURN(dlg->usage_cnt < PJSIP_MAX_MODULE, PJ_EBUG);\n\n    PJ_LOG(5,(dlg->obj_name,\n\t      \"Module %.*s added as dialog usage, data=%p\",\n\t      (int)mod->name.slen, mod->name.ptr, mod_data));\n\n    pjsip_dlg_inc_lock(dlg);\n\n    /* Usages are sorted on priority, lowest number first.\n     * Find position to put the new module, also makes sure that\n     * this module has not been registered before.\n     */\n    for (index=0; index<dlg->usage_cnt; ++index) {\n\tif (dlg->usage[index] == mod) {\n\t    /* Module may be registered more than once in the same dialog.\n\t     * For example, when call transfer fails, application may retry\n\t     * call transfer on the same dialog.\n\t     * So return PJ_SUCCESS here.\n\t     */\n\t    PJ_LOG(4,(dlg->obj_name,\n\t\t      \"Module %.*s already registered as dialog usage, \"\n\t\t      \"updating the data %p\",\n\t\t      (int)mod->name.slen, mod->name.ptr, mod_data));\n\t    dlg->mod_data[mod->id] = mod_data;\n\n\t    pjsip_dlg_dec_lock(dlg);\n\t    return PJ_SUCCESS;\n\n\t    //pj_assert(!\"This module is already registered\");\n\t    //pjsip_dlg_dec_lock(dlg);\n\t    //return PJSIP_ETYPEEXISTS;\n\t}\n\n\tif (dlg->usage[index]->priority > mod->priority)\n\t    break;\n    }\n\n    /* index holds position to put the module.\n     * Insert module at this index.\n     */\n    pj_array_insert(dlg->usage, sizeof(dlg->usage[0]), dlg->usage_cnt,\n\t\t    index, &mod);\n\n    /* Set module data. */\n    dlg->mod_data[mod->id] = mod_data;\n\n    /* Increment count. */\n    ++dlg->usage_cnt;\n\n    pjsip_dlg_dec_lock(dlg);\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Attach module specific data to the dialog. Application can also set\n * the value directly by accessing dlg->mod_data[module_id].\n */\nPJ_DEF(pj_status_t) pjsip_dlg_set_mod_data( pjsip_dialog *dlg,\n\t\t\t\t\t    int mod_id,\n\t\t\t\t\t    void *data )\n{\n    PJ_ASSERT_RETURN(dlg, PJ_EINVAL);\n    PJ_ASSERT_RETURN(mod_id >= 0 && mod_id < PJSIP_MAX_MODULE,\n\t\t     PJ_EINVAL);\n    dlg->mod_data[mod_id] = data;\n    return PJ_SUCCESS;\n}\n\n/**\n * Get module specific data previously attached to the dialog. Application\n * can also get value directly by accessing dlg->mod_data[module_id].\n */\nPJ_DEF(void*) pjsip_dlg_get_mod_data( pjsip_dialog *dlg,\n\t\t\t\t      int mod_id)\n{\n    PJ_ASSERT_RETURN(dlg, NULL);\n    PJ_ASSERT_RETURN(mod_id >= 0 && mod_id < PJSIP_MAX_MODULE,\n\t\t     NULL);\n    return dlg->mod_data[mod_id];\n}\n\n\n/*\n * Create a new request within dialog (i.e. after the dialog session has been\n * established). The construction of such requests follows the rule in\n * RFC3261 section 12.2.1.\n */\nstatic pj_status_t dlg_create_request_throw( pjsip_dialog *dlg,\n\t\t\t\t\t     const pjsip_method *method,\n\t\t\t\t\t     int cseq,\n\t\t\t\t\t     pjsip_tx_data **p_tdata )\n{\n    pjsip_tx_data *tdata;\n    pjsip_contact_hdr *contact;\n    pjsip_route_hdr *route, *end_list;\n    pj_status_t status;\n\n    /* Contact Header field.\n     * Contact can only be present in requests that establish dialog (in the\n     * core SIP spec, only INVITE).\n     */\n    if (pjsip_method_creates_dialog(method))\n\tcontact = dlg->local.contact;\n    else\n\tcontact = NULL;\n\n    /*\n     * Create the request by cloning from the headers in the\n     * dialog.\n     */\n    status = pjsip_endpt_create_request_from_hdr(dlg->endpt,\n\t\t\t\t\t\t method,\n\t\t\t\t\t\t dlg->target,\n\t\t\t\t\t\t dlg->local.info,\n\t\t\t\t\t\t dlg->remote.info,\n\t\t\t\t\t\t contact,\n\t\t\t\t\t\t dlg->call_id,\n\t\t\t\t\t\t cseq,\n\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t &tdata);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Put this dialog in tdata's mod_data */\n    tdata->mod_data[dlg->ua->id] = dlg;\n\n    /* Just copy dialog route-set to Route header.\n     * The transaction will do the processing as specified in Section 12.2.1\n     * of RFC 3261 in function tsx_process_route() in sip_transaction.c.\n     */\n    route = dlg->route_set.next;\n    end_list = &dlg->route_set;\n    for (; route != end_list; route = route->next ) {\n\tpjsip_route_hdr *r;\n\tr = (pjsip_route_hdr*) pjsip_hdr_shallow_clone( tdata->pool, route );\n\tpjsip_routing_hdr_set_route(r);\n\tpjsip_msg_add_hdr(tdata->msg, (pjsip_hdr*)r);\n    }\n\n    /* Copy authorization headers, if request is not ACK or CANCEL. */\n    if (method->id != PJSIP_ACK_METHOD && method->id != PJSIP_CANCEL_METHOD) {\n\tstatus = pjsip_auth_clt_init_req( &dlg->auth_sess, tdata );\n\tif (status != PJ_SUCCESS)\n\t    return status;\n    }\n\n    /* Done. */\n    *p_tdata = tdata;\n\n    return PJ_SUCCESS;\n}\n\n\n\n/*\n * Create outgoing request.\n */\nPJ_DEF(pj_status_t) pjsip_dlg_create_request( pjsip_dialog *dlg,\n\t\t\t\t\t      const pjsip_method *method,\n\t\t\t\t\t      int cseq,\n\t\t\t\t\t      pjsip_tx_data **p_tdata)\n{\n    pj_status_t status;\n    pjsip_tx_data *tdata = NULL;\n    PJ_USE_EXCEPTION;\n\n    PJ_ASSERT_RETURN(dlg && method && p_tdata, PJ_EINVAL);\n\n    /* Lock dialog. */\n    pjsip_dlg_inc_lock(dlg);\n\n    /* Use outgoing CSeq and increment it by one. */\n    if (cseq < 0)\n\tcseq = dlg->local.cseq + 1;\n\n    /* Keep compiler happy */\n    status = PJ_EBUG;\n\n    /* Create the request. */\n    PJ_TRY {\n\tstatus = dlg_create_request_throw(dlg, method, cseq, &tdata);\n    }\n    PJ_CATCH_ANY {\n\tstatus = PJ_ENOMEM;\n    }\n    PJ_END;\n\n    /* Failed! Delete transmit data. */\n    if (status != PJ_SUCCESS && tdata) {\n\tpjsip_tx_data_dec_ref( tdata );\n\ttdata = NULL;\n    }\n\n    /* Unlock dialog. */\n    pjsip_dlg_dec_lock(dlg);\n\n    *p_tdata = tdata;\n\n    return status;\n}\n\n/* Callback for send ACK, providing send callback will allow stack to try\n * next server upon failure.\n */\nstatic void send_ack_callback( pjsip_send_state *send_state,\n\t\t\t       pj_ssize_t sent, pj_bool_t *cont )\n{\n    if (sent > 0)\n\treturn;\n\n    if (*cont) {\n\tPJ_PERROR(3,(THIS_FILE, (pj_status_t)-sent,\n\t\t     \"Temporary failure in sending %s, \"\n\t\t     \"will try next server\",\n\t\t     pjsip_tx_data_get_info(send_state->tdata)));\n    } else {\n\tPJ_PERROR(3,(THIS_FILE, (pj_status_t)-sent,\n\t\t     \"Failed to send %s!\",\n\t\t     pjsip_tx_data_get_info(send_state->tdata)));\n    }\n}\n\n/*\n * Send request statefully, and update dialog'c CSeq.\n */\nPJ_DEF(pj_status_t) pjsip_dlg_send_request( pjsip_dialog *dlg,\n\t\t\t\t\t    pjsip_tx_data *tdata,\n\t\t\t\t\t    int mod_data_id,\n\t\t\t\t\t    void *mod_data)\n{\n    pjsip_transaction *tsx;\n    pjsip_msg *msg = tdata->msg;\n    pj_status_t status;\n\n    /* Check arguments. */\n    PJ_ASSERT_RETURN(dlg && tdata && tdata->msg, PJ_EINVAL);\n    PJ_ASSERT_RETURN(tdata->msg->type == PJSIP_REQUEST_MSG,\n\t\t     PJSIP_ENOTREQUESTMSG);\n\n    pj_log_push_indent();\n    PJ_LOG(5,(dlg->obj_name, \"Sending %s\",\n\t      pjsip_tx_data_get_info(tdata)));\n\n    /* Lock and increment session */\n    pjsip_dlg_inc_lock(dlg);\n\n    /* Put this dialog in tdata's mod_data */\n    tdata->mod_data[dlg->ua->id] = dlg;\n\n    /* If via_addr is set, use this address for the Via header. */\n    if (dlg->via_addr.host.slen > 0) {\n        tdata->via_addr = dlg->via_addr;\n        tdata->via_tp = dlg->via_tp;\n    }\n\n    /* Update dialog's CSeq and message's CSeq if request is not\n     * ACK nor CANCEL.\n     */\n    if (msg->line.req.method.id != PJSIP_CANCEL_METHOD &&\n\tmsg->line.req.method.id != PJSIP_ACK_METHOD)\n    {\n\tpjsip_cseq_hdr *ch;\n\n\tch = PJSIP_MSG_CSEQ_HDR(msg);\n\tPJ_ASSERT_RETURN(ch!=NULL, PJ_EBUG);\n\n\tch->cseq = dlg->local.cseq++;\n\n\t/* Force the whole message to be re-printed. */\n\tpjsip_tx_data_invalidate_msg( tdata );\n    }\n\n    /* Create a new transaction if method is not ACK.\n     * The transaction user is the user agent module.\n     */\n    if (msg->line.req.method.id != PJSIP_ACK_METHOD) {\n\tint tsx_count;\n\n\tstatus = pjsip_tsx_create_uac(dlg->ua, tdata, &tsx);\n\tif (status != PJ_SUCCESS)\n\t    goto on_error;\n\n\t/* Set transport selector */\n\tstatus = pjsip_tsx_set_transport(tsx, &dlg->tp_sel);\n\tpj_assert(status == PJ_SUCCESS);\n\n\t/* Attach this dialog to the transaction, so that user agent\n\t * will dispatch events to this dialog.\n\t */\n\ttsx->mod_data[dlg->ua->id] = dlg;\n\n\t/* Copy optional caller's mod_data, if present */\n\tif (mod_data_id >= 0 && mod_data_id < PJSIP_MAX_MODULE)\n\t    tsx->mod_data[mod_data_id] = mod_data;\n\n\t/* Increment transaction counter. */\n\ttsx_count = ++dlg->tsx_count;\n\n\t/* Send the message. */\n\tstatus = pjsip_tsx_send_msg(tsx, tdata);\n\tif (status != PJ_SUCCESS) {\n\t    if (dlg->tsx_count == tsx_count)\n\t\tpjsip_tsx_terminate(tsx, tsx->status_code);\n\t    goto on_error;\n\t}\n\n    } else {\n\t/* Set transport selector */\n\tpjsip_tx_data_set_transport(tdata, &dlg->tp_sel);\n\n\t/* Send request */\n\tstatus = pjsip_endpt_send_request_stateless(dlg->endpt, tdata,\n\t\t\t\t\t\t    NULL, &send_ack_callback);\n\tif (status != PJ_SUCCESS)\n\t    goto on_error;\n\n    }\n\n    /* Unlock dialog, may destroy dialog. */\n    pjsip_dlg_dec_lock(dlg);\n    pj_log_pop_indent();\n    return PJ_SUCCESS;\n\non_error:\n    /* Unlock dialog, may destroy dialog. */\n    pjsip_dlg_dec_lock(dlg);\n\n    /* Whatever happen delete the message. */\n    pjsip_tx_data_dec_ref( tdata );\n    pj_log_pop_indent();\n    return status;\n}\n\n/* Add standard headers for certain types of response */\nstatic void dlg_beautify_response(pjsip_dialog *dlg,\n\t\t\t\t  pj_bool_t add_headers,\n\t\t\t\t  int st_code,\n\t\t\t\t  pjsip_tx_data *tdata)\n{\n    pjsip_cseq_hdr *cseq;\n    int st_class;\n    const pjsip_hdr *c_hdr;\n    pjsip_hdr *hdr;\n\n    cseq = PJSIP_MSG_CSEQ_HDR(tdata->msg);\n    pj_assert(cseq != NULL);\n\n    st_class = st_code / 100;\n\n    /* Contact, Allow, Supported header. */\n    if (add_headers && pjsip_method_creates_dialog(&cseq->method)) {\n\t/* Add Contact header for 1xx, 2xx, 3xx and 485 response. */\n\tif (st_class==2 || st_class==3 || (st_class==1 && st_code != 100) ||\n\t    st_code==485)\n\t{\n\t    /* Add contact header only if one is not present. */\n\t    if (pjsip_msg_find_hdr(tdata->msg, PJSIP_H_CONTACT, NULL) == 0 &&\n\t\tpjsip_msg_find_hdr_by_name(tdata->msg, &HCONTACT, NULL) == 0)\n\t    {\n\t\thdr = (pjsip_hdr*) pjsip_hdr_clone(tdata->pool,\n\t\t\t\t\t\t   dlg->local.contact);\n\t\tpjsip_msg_add_hdr(tdata->msg, hdr);\n\t    }\n\t}\n\n\t/* Add Allow header in 18x, 2xx and 405 response. */\n\tif ((((st_code/10==18 || st_class==2) && dlg->add_allow)\n\t     || st_code==405) &&\n\t    pjsip_msg_find_hdr(tdata->msg, PJSIP_H_ALLOW, NULL)==NULL)\n\t{\n\t    c_hdr = pjsip_endpt_get_capability(dlg->endpt,\n\t\t\t\t\t       PJSIP_H_ALLOW, NULL);\n\t    if (c_hdr) {\n\t\thdr = (pjsip_hdr*) pjsip_hdr_clone(tdata->pool, c_hdr);\n\t\tpjsip_msg_add_hdr(tdata->msg, hdr);\n\t    }\n\t}\n\n\t/* Add Supported header in 2xx response. */\n\tif (st_class==2 &&\n\t    pjsip_msg_find_hdr(tdata->msg, PJSIP_H_SUPPORTED, NULL)==NULL)\n\t{\n\t    c_hdr = pjsip_endpt_get_capability(dlg->endpt,\n\t\t\t\t\t       PJSIP_H_SUPPORTED, NULL);\n\t    if (c_hdr) {\n\t\thdr = (pjsip_hdr*) pjsip_hdr_clone(tdata->pool, c_hdr);\n\t\tpjsip_msg_add_hdr(tdata->msg, hdr);\n\t    }\n\t}\n\n    }\n\n    /* Add To tag in all responses except 100 */\n    if (st_code != 100) {\n\tpjsip_to_hdr *to;\n\n\tto = PJSIP_MSG_TO_HDR(tdata->msg);\n\tpj_assert(to != NULL);\n\n\tto->tag = dlg->local.info->tag;\n\n\tif (dlg->state == PJSIP_DIALOG_STATE_NULL)\n\t    dlg->state = PJSIP_DIALOG_STATE_ESTABLISHED;\n    }\n}\n\n\n/*\n * Create response.\n */\nPJ_DEF(pj_status_t) pjsip_dlg_create_response(\tpjsip_dialog *dlg,\n\t\t\t\t\t\tpjsip_rx_data *rdata,\n\t\t\t\t\t\tint st_code,\n\t\t\t\t\t\tconst pj_str_t *st_text,\n\t\t\t\t\t\tpjsip_tx_data **p_tdata)\n{\n    pj_status_t status;\n    pjsip_tx_data *tdata;\n\n    /* Create generic response.\n     * This will initialize response's Via, To, From, Call-ID, CSeq\n     * and Record-Route headers from the request.\n     */\n    status = pjsip_endpt_create_response(dlg->endpt,\n\t\t\t\t\t rdata, st_code, st_text, &tdata);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Lock the dialog. */\n    pjsip_dlg_inc_lock(dlg);\n\n    /* Put this dialog in tdata's mod_data */\n    tdata->mod_data[dlg->ua->id] = dlg;\n\n    dlg_beautify_response(dlg, PJ_FALSE, st_code, tdata);\n\n    /* Unlock the dialog. */\n    pjsip_dlg_dec_lock(dlg);\n\n    /* Done. */\n    *p_tdata = tdata;\n    return PJ_SUCCESS;\n}\n\n/*\n * Modify response.\n */\nPJ_DEF(pj_status_t) pjsip_dlg_modify_response(\tpjsip_dialog *dlg,\n\t\t\t\t\t\tpjsip_tx_data *tdata,\n\t\t\t\t\t\tint st_code,\n\t\t\t\t\t\tconst pj_str_t *st_text)\n{\n    pjsip_hdr *hdr;\n\n    PJ_ASSERT_RETURN(dlg && tdata && tdata->msg, PJ_EINVAL);\n    PJ_ASSERT_RETURN(tdata->msg->type == PJSIP_RESPONSE_MSG,\n\t\t     PJSIP_ENOTRESPONSEMSG);\n    PJ_ASSERT_RETURN(st_code >= 100 && st_code <= 699, PJ_EINVAL);\n\n    /* Lock and increment session */\n    pjsip_dlg_inc_lock(dlg);\n\n    /* Replace status code and reason */\n    tdata->msg->line.status.code = st_code;\n    if (st_text) {\n\tpj_strdup(tdata->pool, &tdata->msg->line.status.reason, st_text);\n    } else {\n\ttdata->msg->line.status.reason = *pjsip_get_status_text(st_code);\n    }\n\n    /* Remove existing Contact header (without this, when dialog sent\n     * 180 and then 302, the Contact in 302 will not get updated).\n     */\n    hdr = (pjsip_hdr*) pjsip_msg_find_hdr(tdata->msg, PJSIP_H_CONTACT, NULL);\n    if (hdr)\n\tpj_list_erase(hdr);\n\n    /* Add tag etc. if necessary */\n    dlg_beautify_response(dlg, st_code/100 <= 2, st_code, tdata);\n\n\n    /* Must add reference counter, since tsx_send_msg() will decrement it */\n    pjsip_tx_data_add_ref(tdata);\n\n    /* Force to re-print message. */\n    pjsip_tx_data_invalidate_msg(tdata);\n\n    /* Unlock dialog and dec session, may destroy dialog. */\n    pjsip_dlg_dec_lock(dlg);\n\n    return PJ_SUCCESS;\n}\n\n/*\n * Send response statefully.\n */\nPJ_DEF(pj_status_t) pjsip_dlg_send_response( pjsip_dialog *dlg,\n\t\t\t\t\t     pjsip_transaction *tsx,\n\t\t\t\t\t     pjsip_tx_data *tdata)\n{\n    pj_status_t status;\n\n    /* Sanity check. */\n    PJ_ASSERT_RETURN(dlg && tsx && tdata && tdata->msg, PJ_EINVAL);\n    PJ_ASSERT_RETURN(tdata->msg->type == PJSIP_RESPONSE_MSG,\n\t\t     PJSIP_ENOTRESPONSEMSG);\n\n    /* The transaction must belong to this dialog.  */\n    PJ_ASSERT_RETURN(tsx->mod_data[dlg->ua->id] == dlg, PJ_EINVALIDOP);\n\n    pj_log_push_indent();\n\n    PJ_LOG(5,(dlg->obj_name, \"Sending %s\",\n\t      pjsip_tx_data_get_info(tdata)));\n\n    /* Check that transaction method and cseq match the response.\n     * This operation is sloooww (search CSeq header twice), that's why\n     * we only do it in debug mode.\n     */\n#if defined(PJ_DEBUG) && PJ_DEBUG!=0\n    PJ_ASSERT_RETURN( PJSIP_MSG_CSEQ_HDR(tdata->msg)->cseq == tsx->cseq &&\n\t\t      pjsip_method_cmp(&PJSIP_MSG_CSEQ_HDR(tdata->msg)->method,\n\t\t\t\t       &tsx->method)==0,\n\t\t      PJ_EINVALIDOP);\n#endif\n\n    /* Must acquire dialog first, to prevent deadlock */\n    pjsip_dlg_inc_lock(dlg);\n\n    /* Last chance to add mandatory headers before the response is\n     * sent.\n     */\n    dlg_beautify_response(dlg, PJ_TRUE, tdata->msg->line.status.code, tdata);\n\n    /* If the dialog is locked to transport, make sure that transaction\n     * is locked to the same transport too.\n     */\n    if (dlg->tp_sel.type != tsx->tp_sel.type ||\n\tdlg->tp_sel.u.ptr != tsx->tp_sel.u.ptr)\n    {\n\tstatus = pjsip_tsx_set_transport(tsx, &dlg->tp_sel);\n\tpj_assert(status == PJ_SUCCESS);\n    }\n\n    /* Ask transaction to send the response */\n    status = pjsip_tsx_send_msg(tsx, tdata);\n\n    /* This function must decrement transmit data request counter\n     * regardless of the operation status. The transaction only\n     * decrements the counter if the operation is successful.\n     */\n    if (status != PJ_SUCCESS) {\n\tpjsip_tx_data_dec_ref(tdata);\n    }\n\n    pjsip_dlg_dec_lock(dlg);\n    pj_log_pop_indent();\n\n    return status;\n}\n\n\n/*\n * Combo function to create and send response statefully.\n */\nPJ_DEF(pj_status_t) pjsip_dlg_respond(  pjsip_dialog *dlg,\n\t\t\t\t\tpjsip_rx_data *rdata,\n\t\t\t\t\tint st_code,\n\t\t\t\t\tconst pj_str_t *st_text,\n\t\t\t\t\tconst pjsip_hdr *hdr_list,\n\t\t\t\t\tconst pjsip_msg_body *body )\n{\n    pj_status_t status;\n    pjsip_tx_data *tdata;\n\n    /* Sanity check. */\n    PJ_ASSERT_RETURN(dlg && rdata && rdata->msg_info.msg, PJ_EINVAL);\n    PJ_ASSERT_RETURN(rdata->msg_info.msg->type == PJSIP_REQUEST_MSG,\n\t\t     PJSIP_ENOTREQUESTMSG);\n\n    /* The transaction must belong to this dialog.  */\n    PJ_ASSERT_RETURN(pjsip_rdata_get_tsx(rdata) &&\n\t\t     pjsip_rdata_get_tsx(rdata)->mod_data[dlg->ua->id] == dlg,\n\t\t     PJ_EINVALIDOP);\n\n    /* Create the response. */\n    status = pjsip_dlg_create_response(dlg, rdata, st_code, st_text, &tdata);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Add additional header, if any */\n    if (hdr_list) {\n\tconst pjsip_hdr *hdr;\n\n\thdr = hdr_list->next;\n\twhile (hdr != hdr_list) {\n\t    pjsip_msg_add_hdr(tdata->msg,\n\t\t\t      (pjsip_hdr*)pjsip_hdr_clone(tdata->pool, hdr));\n\t    hdr = hdr->next;\n\t}\n    }\n\n    /* Add the message body, if any. */\n    if (body) {\n\ttdata->msg->body = pjsip_msg_body_clone( tdata->pool, body);\n    }\n\n    /* Send the response. */\n    return pjsip_dlg_send_response(dlg, pjsip_rdata_get_tsx(rdata), tdata);\n}\n\n\n/* This function is called by user agent upon receiving incoming request\n * message.\n */\nvoid pjsip_dlg_on_rx_request( pjsip_dialog *dlg, pjsip_rx_data *rdata )\n{\n    pj_status_t status;\n    pjsip_transaction *tsx = NULL;\n    pj_bool_t processed = PJ_FALSE;\n    unsigned i;\n\n    PJ_LOG(5,(dlg->obj_name, \"Received %s\",\n\t      pjsip_rx_data_get_info(rdata)));\n    pj_log_push_indent();\n\n    /* Lock dialog and increment session. */\n    pjsip_dlg_inc_lock(dlg);\n\n    /* Check CSeq */\n    if (rdata->msg_info.cseq->cseq <= dlg->remote.cseq &&\n\trdata->msg_info.msg->line.req.method.id != PJSIP_ACK_METHOD &&\n\trdata->msg_info.msg->line.req.method.id != PJSIP_CANCEL_METHOD)\n    {\n\t/* Invalid CSeq.\n\t * Respond statelessly with 500 (Internal Server Error)\n\t */\n\tpj_str_t warn_text;\n\n\t/* Unlock dialog and dec session, may destroy dialog. */\n\tpjsip_dlg_dec_lock(dlg);\n\n\tpj_assert(pjsip_rdata_get_tsx(rdata) == NULL);\n\twarn_text = pj_str(\"Invalid CSeq\");\n\tpjsip_endpt_respond_stateless(dlg->endpt,\n\t\t\t\t      rdata, 500, &warn_text, NULL, NULL);\n\tpj_log_pop_indent();\n\treturn;\n    }\n\n    /* Update CSeq. */\n    dlg->remote.cseq = rdata->msg_info.cseq->cseq;\n\n    /* Update To tag if necessary.\n     * This only happens if UAS sends a new request before answering\n     * our request (e.g. UAS sends NOTIFY before answering our\n     * SUBSCRIBE request).\n     */\n    if (dlg->remote.info->tag.slen == 0) {\n\tpj_strdup(dlg->pool, &dlg->remote.info->tag,\n\t\t  &rdata->msg_info.from->tag);\n    }\n\n    /* Create UAS transaction for this request. */\n    if (pjsip_rdata_get_tsx(rdata) == NULL &&\n\trdata->msg_info.msg->line.req.method.id != PJSIP_ACK_METHOD)\n    {\n\tstatus = pjsip_tsx_create_uas(dlg->ua, rdata, &tsx);\n\tif (status != PJ_SUCCESS) {\n\t    /* Once case for this is when re-INVITE contains same\n\t     * Via branch value as previous INVITE (ticket #965).\n\t     */\n\t    char errmsg[PJ_ERR_MSG_SIZE];\n\t    pj_str_t reason;\n\n\t    reason = pj_strerror(status, errmsg, sizeof(errmsg));\n\t    pjsip_endpt_respond_stateless(dlg->endpt, rdata, 500, &reason,\n\t\t\t\t\t  NULL, NULL);\n\t    goto on_return;\n\t}\n\n\t/* Put this dialog in the transaction data. */\n\ttsx->mod_data[dlg->ua->id] = dlg;\n\n\t/* Add transaction count. */\n\t++dlg->tsx_count;\n    }\n\n    /* Update the target URI if this is a target refresh request.\n     * We have passed the basic checking for the request, I think we\n     * should update the target URI regardless of whether the request\n     * is accepted or not (e.g. when re-INVITE is answered with 488,\n     * we would still need to update the target URI, otherwise our\n     * target URI would be wrong, wouldn't it).\n     */\n    if (pjsip_method_creates_dialog(&rdata->msg_info.cseq->method)) {\n\tpjsip_contact_hdr *contact;\n\n\tcontact = (pjsip_contact_hdr*)\n\t\t  pjsip_msg_find_hdr(rdata->msg_info.msg, PJSIP_H_CONTACT,\n\t\t\t\t     NULL);\n\tif (contact && contact->uri &&\n\t    (dlg->remote.contact==NULL ||\n \t     pjsip_uri_cmp(PJSIP_URI_IN_REQ_URI,\n\t\t\t   dlg->remote.contact->uri,\n\t\t\t   contact->uri)))\n\t{\n\t    dlg->remote.contact = (pjsip_contact_hdr*)\n\t    \t\t\t  pjsip_hdr_clone(dlg->pool, contact);\n\t    dlg->target = dlg->remote.contact->uri;\n\t}\n    }\n\n    /* Report the request to dialog usages. */\n    for (i=0; i<dlg->usage_cnt; ++i) {\n\n\tif (!dlg->usage[i]->on_rx_request)\n\t    continue;\n\n\tprocessed = (*dlg->usage[i]->on_rx_request)(rdata);\n\n\tif (processed)\n\t    break;\n    }\n\n    /* Feed the first request to the transaction. */\n    if (tsx)\n\tpjsip_tsx_recv_msg(tsx, rdata);\n\n    /* If no dialog usages has claimed the processing of the transaction,\n     * and if transaction has not sent final response, respond with\n     * 500/Internal Server Error.\n     */\n    if (!processed && tsx && tsx->status_code < 200) {\n\tpjsip_tx_data *tdata;\n\tconst pj_str_t reason = { \"Unhandled by dialog usages\", 26};\n\n\tPJ_LOG(4,(tsx->obj_name, \"%s was unhandled by \"\n\t\t\t\t \"dialog usages, sending 500 response\",\n\t\t\t\t pjsip_rx_data_get_info(rdata)));\n\n\tstatus = pjsip_dlg_create_response(dlg, rdata, 500, &reason, &tdata);\n\tif (status == PJ_SUCCESS) {\n\t    status = pjsip_dlg_send_response(dlg, tsx, tdata);\n\t}\n    }\n\non_return:\n    /* Unlock dialog and dec session, may destroy dialog. */\n    pjsip_dlg_dec_lock(dlg);\n    pj_log_pop_indent();\n}\n\n/* Update route-set from incoming message */\nstatic void dlg_update_routeset(pjsip_dialog *dlg, const pjsip_rx_data *rdata)\n{\n    const pjsip_hdr *hdr, *end_hdr;\n    //pj_int32_t msg_cseq;\n    const pjsip_msg *msg;\n    const pjsip_method update = { PJSIP_OTHER_METHOD, {\"UPDATE\", 6}};\n\n    msg = rdata->msg_info.msg;\n    //msg_cseq = rdata->msg_info.cseq->cseq;\n\n    /* Ignore if route set has been frozen */\n    if (dlg->route_set_frozen)\n\treturn;\n\n    /* Ignore if the message is an UPDATE response (see ticket #1781) */\n    if (pjsip_method_cmp(&rdata->msg_info.cseq->method, &update) == 0)\n\treturn;\n\n    /* Only update route set if this message belongs to the same\n     * transaction as the initial transaction that establishes dialog.\n     */\n    if (dlg->role == PJSIP_ROLE_UAC) {\n\n\t/* Ignore subsequent request from remote */\n\tif (msg->type != PJSIP_RESPONSE_MSG)\n\t    return;\n\n\t/* Ignore subsequent responses with higher CSeq than initial CSeq.\n\t * Unfortunately this would be broken when the first request is\n\t * challenged!\n\t */\n\t//if (msg_cseq != dlg->local.first_cseq)\n\t//    return;\n\n    } else {\n\n\t/* For callee dialog, route set should have been set by initial\n\t * request and it will have been rejected by dlg->route_set_frozen\n\t * check above.\n\t */\n\tpj_assert(!\"Should not happen\");\n\n    }\n\n    /* Based on the checks above, we should only get response message here */\n    pj_assert(msg->type == PJSIP_RESPONSE_MSG);\n\n    /* Ignore if this is not 1xx or 2xx response */\n    if (msg->line.status.code >= 300)\n\treturn;\n\n    /* Reset route set */\n    pj_list_init(&dlg->route_set);\n\n    /* Update route set */\n    end_hdr = &msg->hdr;\n    for (hdr=msg->hdr.prev; hdr!=end_hdr; hdr=hdr->prev) {\n\tif (hdr->type == PJSIP_H_RECORD_ROUTE) {\n\t    pjsip_route_hdr *r;\n\t    r = (pjsip_route_hdr*) pjsip_hdr_clone(dlg->pool, hdr);\n\t    pjsip_routing_hdr_set_route(r);\n\t    pj_list_push_back(&dlg->route_set, r);\n\t}\n    }\n\n    PJ_LOG(5,(dlg->obj_name, \"Route-set updated\"));\n\n    /* Freeze the route set only when the route set comes in 2xx response.\n     * If it is in 1xx response, prepare to recompute the route set when\n     * the 2xx response comes in.\n     *\n     * There is a debate whether route set should be frozen when the dialog\n     * is established with reliable provisional response, but I think\n     * it is safer to not freeze the route set (thus recompute the route set\n     * upon receiving 2xx response). Also RFC 3261 says so in 13.2.2.4.\n     *\n     * The pjsip_method_creates_dialog() check protects from wrongly\n     * freezing the route set upon receiving 200/OK response for PRACK.\n     */\n    if (pjsip_method_creates_dialog(&rdata->msg_info.cseq->method) &&\n\tPJSIP_IS_STATUS_IN_CLASS(msg->line.status.code, 200))\n    {\n\tdlg->route_set_frozen = PJ_TRUE;\n\tPJ_LOG(5,(dlg->obj_name, \"Route-set frozen\"));\n    }\n}\n\n\n/* This function is called by user agent upon receiving incoming response\n * message.\n */\nvoid pjsip_dlg_on_rx_response( pjsip_dialog *dlg, pjsip_rx_data *rdata )\n{\n    unsigned i;\n    int res_code;\n\n    PJ_LOG(5,(dlg->obj_name, \"Received %s\",\n\t      pjsip_rx_data_get_info(rdata)));\n    pj_log_push_indent();\n\n    /* Lock the dialog and inc session. */\n    pjsip_dlg_inc_lock(dlg);\n\n    /* Check that rdata already has dialog in mod_data. */\n    pj_assert(pjsip_rdata_get_dlg(rdata) == dlg);\n\n    /* Keep the response's status code */\n    res_code = rdata->msg_info.msg->line.status.code;\n\n    /* When we receive response that establishes dialog, update To tag,\n     * route set and dialog target.\n     *\n     * The second condition of the \"if\" is a workaround for forking.\n     * Originally, the dialog takes the first To tag seen and set it as\n     * the remote tag. If the tag in 2xx response is different than this\n     * tag, ACK will be sent with wrong To tag and incoming request with\n     * this tag will be rejected with 481.\n     *\n     * The workaround for this is to take the To tag received in the\n     * 2xx response and set it as remote tag.\n     *\n     * New update:\n     * We also need to update the dialog for 1xx responses, to handle the\n     * case when 100rel is used, otherwise PRACK will be sent to the\n     * wrong target.\n     */\n    if ((dlg->state == PJSIP_DIALOG_STATE_NULL &&\n\t pjsip_method_creates_dialog(&rdata->msg_info.cseq->method) &&\n\t (res_code > 100 && res_code < 300) &&\n\t rdata->msg_info.to->tag.slen)\n\t ||\n\t(dlg->role==PJSIP_ROLE_UAC &&\n\t !dlg->uac_has_2xx &&\n\t res_code > 100 &&\n\t res_code/100 <= 2 &&\n\t pjsip_method_creates_dialog(&rdata->msg_info.cseq->method) &&\n\t pj_stricmp(&dlg->remote.info->tag, &rdata->msg_info.to->tag)))\n    {\n\tpjsip_contact_hdr *contact;\n\n\t/* Update remote capability info, when To tags in the dialog remote\n\t * info and the incoming response are different, e.g: first response\n\t * with To-tag or forking, apply strict update.\n\t */\n\tpjsip_dlg_update_remote_cap(dlg, rdata->msg_info.msg,\n\t\t\t\t    pj_stricmp(&dlg->remote.info->tag,\n\t\t\t\t\t      &rdata->msg_info.to->tag));\n\n\t/* Update To tag. */\n\tpj_strdup(dlg->pool, &dlg->remote.info->tag, &rdata->msg_info.to->tag);\n\t/* No need to update remote's tag_hval since its never used. */\n\n\t/* RFC 3271 Section 12.1.2:\n\t * The route set MUST be set to the list of URIs in the Record-Route\n\t * header field from the response, taken in reverse order and\n\t * preserving all URI parameters. If no Record-Route header field\n\t * is present in the response, the route set MUST be set to the\n\t * empty set. This route set, even if empty, overrides any pre-existing\n\t * route set for future requests in this dialog.\n\t */\n\tdlg_update_routeset(dlg, rdata);\n\n\t/* The remote target MUST be set to the URI from the Contact header\n\t * field of the response.\n\t */\n\tcontact = (pjsip_contact_hdr*)\n\t\t  pjsip_msg_find_hdr(rdata->msg_info.msg, PJSIP_H_CONTACT,\n\t\t\t\t     NULL);\n\tif (contact && contact->uri &&\n\t    (dlg->remote.contact==NULL ||\n\t     pjsip_uri_cmp(PJSIP_URI_IN_REQ_URI,\n\t\t\t   dlg->remote.contact->uri,\n\t\t\t   contact->uri)))\n\t{\n\t    dlg->remote.contact = (pjsip_contact_hdr*)\n\t    \t\t\t  pjsip_hdr_clone(dlg->pool, contact);\n\t    dlg->target = dlg->remote.contact->uri;\n\t}\n\n\tdlg->state = PJSIP_DIALOG_STATE_ESTABLISHED;\n\n\t/* Prevent dialog from being updated just in case more 2xx\n\t * gets through this dialog (it shouldn't happen).\n\t */\n\tif (dlg->role==PJSIP_ROLE_UAC && !dlg->uac_has_2xx &&\n\t    res_code/100==2)\n\t{\n\t    dlg->uac_has_2xx = PJ_TRUE;\n\t}\n    }\n\n    /* Update remote target (again) when receiving 2xx response messages\n     * that's defined as target refresh.\n     *\n     * Also upon receiving 2xx response, recheck again the route set.\n     * This is for compatibility with RFC 2543, as described in Section\n     * 13.2.2.4 of RFC 3261:\n\n\tIf the dialog identifier in the 2xx response matches the dialog\n\tidentifier of an existing dialog, the dialog MUST be transitioned to\n\tthe \"confirmed\" state, and the route set for the dialog MUST be\n\trecomputed based on the 2xx response using the procedures of Section\n\t12.2.1.2.\n\n\tNote that the only piece of state that is recomputed is the route\n\tset.  Other pieces of state such as the highest sequence numbers\n\t(remote and local) sent within the dialog are not recomputed.  The\n\troute set only is recomputed for backwards compatibility.  RFC\n\t2543 did not mandate mirroring of the Record-Route header field in\n\ta 1xx, only 2xx.\n     */\n    if (pjsip_method_creates_dialog(&rdata->msg_info.cseq->method) &&\n\tres_code/100 == 2)\n    {\n\tpjsip_contact_hdr *contact;\n\n\tcontact = (pjsip_contact_hdr*) pjsip_msg_find_hdr(rdata->msg_info.msg,\n\t\t\t\t\t\t\t  PJSIP_H_CONTACT,\n\t\t\t\t     \t\t\t  NULL);\n\tif (contact && contact->uri &&\n\t    (dlg->remote.contact==NULL ||\n\t     pjsip_uri_cmp(PJSIP_URI_IN_REQ_URI,\n\t\t\t   dlg->remote.contact->uri,\n\t\t\t   contact->uri)))\n\t{\n\t    dlg->remote.contact = (pjsip_contact_hdr*)\n\t    \t\t\t  pjsip_hdr_clone(dlg->pool, contact);\n\t    dlg->target = dlg->remote.contact->uri;\n\t}\n\n\tdlg_update_routeset(dlg, rdata);\n\n\t/* Update remote capability info after the first 2xx response\n\t * (ticket #1539). Note that the remote capability retrieved here\n\t * will be assumed to remain unchanged for the duration of the dialog.\n\t */\n\tif (dlg->role==PJSIP_ROLE_UAC && !dlg->uac_has_2xx) {\n\t    pjsip_dlg_update_remote_cap(dlg, rdata->msg_info.msg, PJ_FALSE);\n\t    dlg->uac_has_2xx = PJ_TRUE;\n\t}\n    }\n\n    /* Pass to dialog usages. */\n    for (i=0; i<dlg->usage_cnt; ++i) {\n\tpj_bool_t processed;\n\n\tif (!dlg->usage[i]->on_rx_response)\n\t    continue;\n\n\tprocessed = (*dlg->usage[i]->on_rx_response)(rdata);\n\n\tif (processed)\n\t    break;\n    }\n\n    /* Handle the case of forked response, when the application creates\n     * the forked dialog but not the invite session. In this case, the\n     * forked 200/OK response will be unhandled, and we must send ACK\n     * here.\n     */\n    if (dlg->usage_cnt==0) {\n\tpj_status_t status;\n\n\tif (rdata->msg_info.cseq->method.id==PJSIP_INVITE_METHOD &&\n\t    rdata->msg_info.msg->line.status.code/100 == 2)\n\t{\n\t    pjsip_tx_data *ack;\n\n\t    status = pjsip_dlg_create_request(dlg, &pjsip_ack_method,\n\t\t\t\t\t      rdata->msg_info.cseq->cseq,\n\t\t\t\t\t      &ack);\n\t    if (status == PJ_SUCCESS)\n\t\tstatus = pjsip_dlg_send_request(dlg, ack, -1, NULL);\n\t} else if (rdata->msg_info.msg->line.status.code==401 ||\n\t\t   rdata->msg_info.msg->line.status.code==407)\n\t{\n\t    pjsip_transaction *tsx = pjsip_rdata_get_tsx(rdata);\n\t    pjsip_tx_data *tdata;\n\n\t    status = pjsip_auth_clt_reinit_req( &dlg->auth_sess,\n\t\t\t\t\t\trdata, tsx->last_tx,\n\t\t\t\t\t\t&tdata);\n\n\t    if (status == PJ_SUCCESS) {\n\t\t/* Re-send request. */\n\t\tstatus = pjsip_dlg_send_request(dlg, tdata, -1, NULL);\n\t    }\n\t}\n    }\n\n    /* Unhandled response does not necessarily mean error because\n       dialog usages may choose to process the transaction state instead.\n    if (i==dlg->usage_cnt) {\n\tPJ_LOG(4,(dlg->obj_name, \"%s was not claimed by any dialog usages\",\n\t\t  pjsip_rx_data_get_info(rdata)));\n    }\n    */\n\n    /* Unlock dialog and dec session, may destroy dialog. */\n    pjsip_dlg_dec_lock(dlg);\n\n    pj_log_pop_indent();\n}\n\n/* This function is called by user agent upon receiving transaction\n * state notification.\n */\nvoid pjsip_dlg_on_tsx_state( pjsip_dialog *dlg,\n\t\t\t     pjsip_transaction *tsx,\n\t\t\t     pjsip_event *e )\n{\n    unsigned i;\n\n    PJ_LOG(5,(dlg->obj_name, \"Transaction %s state changed to %s\",\n\t      tsx->obj_name, pjsip_tsx_state_str(tsx->state)));\n    pj_log_push_indent();\n\n    /* Lock the dialog and increment session. */\n    pjsip_dlg_inc_lock(dlg);\n\n    /* Pass to dialog usages. */\n    for (i=0; i<dlg->usage_cnt; ++i) {\n\n\tif (!dlg->usage[i]->on_tsx_state)\n\t    continue;\n\n\t(*dlg->usage[i]->on_tsx_state)(tsx, e);\n    }\n\n\n    /* It is possible that the transaction is terminated and this function\n     * is called while we're calling on_tsx_state(). So only decrement\n     * the tsx_count if we're still attached to the transaction.\n     */\n    if (tsx->state == PJSIP_TSX_STATE_TERMINATED &&\n\ttsx->mod_data[dlg->ua->id] == dlg)\n    {\n\tpj_assert(dlg->tsx_count>0);\n\t--dlg->tsx_count;\n\ttsx->mod_data[dlg->ua->id] = NULL;\n    }\n\n    /* Unlock dialog and dec session, may destroy dialog. */\n    pjsip_dlg_dec_lock(dlg);\n    pj_log_pop_indent();\n}\n\n\n/*\n * Check if the specified capability is supported by remote.\n */\nPJ_DEF(pjsip_dialog_cap_status) pjsip_dlg_remote_has_cap(\n\t\t\t\t\t\t    pjsip_dialog *dlg,\n\t\t\t\t\t\t    int htype,\n\t\t\t\t\t\t    const pj_str_t *hname,\n\t\t\t\t\t\t    const pj_str_t *token)\n{\n    const pjsip_generic_array_hdr *hdr;\n    pjsip_dialog_cap_status cap_status = PJSIP_DIALOG_CAP_UNSUPPORTED;\n    unsigned i;\n\n    PJ_ASSERT_RETURN(dlg && token, PJSIP_DIALOG_CAP_UNKNOWN);\n\n    pjsip_dlg_inc_lock(dlg);\n\n    hdr = (const pjsip_generic_array_hdr*)\n\t   pjsip_dlg_get_remote_cap_hdr(dlg, htype, hname);\n    if (!hdr) {\n\tcap_status = PJSIP_DIALOG_CAP_UNKNOWN;\n    } else {\n\tfor (i=0; i<hdr->count; ++i) {\n\t    if (!pj_stricmp(&hdr->values[i], token)) {\n\t\tcap_status = PJSIP_DIALOG_CAP_SUPPORTED;\n\t\tbreak;\n\t    }\n\t}\n    }\n\n    pjsip_dlg_dec_lock(dlg);\n\n    return cap_status;\n}\n\n\n/*\n * Update remote capability of ACCEPT, ALLOW, and SUPPORTED from\n * the received message.\n */\nPJ_DEF(pj_status_t) pjsip_dlg_update_remote_cap(pjsip_dialog *dlg,\n\t\t\t\t\t        const pjsip_msg *msg,\n\t\t\t\t\t\tpj_bool_t strict)\n{\n    pjsip_hdr_e htypes[] =\n\t{ PJSIP_H_ACCEPT, PJSIP_H_ALLOW, PJSIP_H_SUPPORTED };\n    unsigned i;\n\n    PJ_ASSERT_RETURN(dlg && msg, PJ_EINVAL);\n\n    pjsip_dlg_inc_lock(dlg);\n\n    /* Retrieve all specified capability header types */\n    for (i = 0; i < PJ_ARRAY_SIZE(htypes); ++i) {\n\tconst pjsip_generic_array_hdr *hdr;\n\tpj_status_t status;\n\n\t/* Find this capability type in the message */\n\thdr = (const pjsip_generic_array_hdr*)\n\t      pjsip_msg_find_hdr(msg, htypes[i], NULL);\n\tif (!hdr) {\n\t    /* Not found.\n\t     * If strict update is specified, remote this capability type\n\t     * from the capability list.\n\t     */\n\t    if (strict)\n\t\tpjsip_dlg_remove_remote_cap_hdr(dlg, htypes[i], NULL);\n\t} else {\n\t    /* Found, a capability type may be specified in multiple headers,\n\t     * so combine all the capability tags/values into a temporary\n\t     * header.\n\t     */\n\t    pjsip_generic_array_hdr tmp_hdr;\n\n\t    /* Init temporary header */\n\t    pjsip_generic_array_hdr_init(dlg->pool, &tmp_hdr, NULL);\n\t    pj_memcpy(&tmp_hdr, hdr, sizeof(pjsip_hdr));\n\n\t    while (hdr) {\n\t\tunsigned j;\n\n\t\t/* Append the header content to temporary header */\n\t\tfor(j=0; j<hdr->count &&\n\t\t\t tmp_hdr.count<PJSIP_GENERIC_ARRAY_MAX_COUNT; ++j)\n\t\t{\n\t\t    tmp_hdr.values[tmp_hdr.count++] = hdr->values[j];\n\t\t}\n\n\t\t/* Get the next header for this capability */\n\t\thdr = (const pjsip_generic_array_hdr*)\n\t\t      pjsip_msg_find_hdr(msg, htypes[i], hdr->next);\n\t    }\n\n\t    /* Save this capability */\n\t    status = pjsip_dlg_set_remote_cap_hdr(dlg, &tmp_hdr);\n\t    if (status != PJ_SUCCESS) {\n\t\tpjsip_dlg_dec_lock(dlg);\n\t\treturn status;\n\t    }\n\t}\n    }\n\n    pjsip_dlg_dec_lock(dlg);\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Get the value of the specified capability header field of remote.\n */\nPJ_DEF(const pjsip_hdr*) pjsip_dlg_get_remote_cap_hdr(pjsip_dialog *dlg,\n\t\t\t\t\t\t      int htype,\n\t\t\t\t\t\t      const pj_str_t *hname)\n{\n    pjsip_hdr *hdr;\n\n    /* Check arguments. */\n    PJ_ASSERT_RETURN(dlg, NULL);\n    PJ_ASSERT_RETURN((htype != PJSIP_H_OTHER) || (hname && hname->slen),\n\t\t     NULL);\n\n    pjsip_dlg_inc_lock(dlg);\n\n    hdr = dlg->rem_cap_hdr.next;\n    while (hdr != &dlg->rem_cap_hdr) {\n\tif ((htype != PJSIP_H_OTHER && htype == hdr->type) ||\n\t    (htype == PJSIP_H_OTHER && pj_stricmp(&hdr->name, hname) == 0))\n\t{\n\t    pjsip_dlg_dec_lock(dlg);\n\t    return hdr;\n\t}\n\thdr = hdr->next;\n    }\n\n    pjsip_dlg_dec_lock(dlg);\n\n    return NULL;\n}\n\n\n/*\n * Set remote capability header from a SIP header containing array\n * of capability tags/values.\n */\nPJ_DEF(pj_status_t) pjsip_dlg_set_remote_cap_hdr(\n\t\t\t\t    pjsip_dialog *dlg,\n\t\t\t\t    const pjsip_generic_array_hdr *cap_hdr)\n{\n    pjsip_generic_array_hdr *hdr;\n\n    /* Check arguments. */\n    PJ_ASSERT_RETURN(dlg && cap_hdr, PJ_EINVAL);\n\n    pjsip_dlg_inc_lock(dlg);\n\n    /* Find the header. */\n    hdr = (pjsip_generic_array_hdr*)\n\t  pjsip_dlg_get_remote_cap_hdr(dlg, cap_hdr->type, &cap_hdr->name);\n\n    /* Quick compare if the capability is up to date */\n    if (hdr && hdr->count == cap_hdr->count) {\n\tunsigned i;\n\tpj_bool_t uptodate = PJ_TRUE;\n\n\tfor (i=0; i<hdr->count; ++i) {\n\t    if (pj_stricmp(&hdr->values[i], &cap_hdr->values[i]))\n\t\tuptodate = PJ_FALSE;\n\t}\n\n\t/* Capability is up to date, just return PJ_SUCCESS */\n\tif (uptodate) {\n\t    pjsip_dlg_dec_lock(dlg);\n\t    return PJ_SUCCESS;\n\t}\n    }\n\n    /* Remove existing capability header if any */\n    if (hdr)\n\tpj_list_erase(hdr);\n\n    /* Add the new capability header */\n    hdr = (pjsip_generic_array_hdr*) pjsip_hdr_clone(dlg->pool, cap_hdr);\n    hdr->type = cap_hdr->type;\n    pj_strdup(dlg->pool, &hdr->name, &cap_hdr->name);\n    pj_list_push_back(&dlg->rem_cap_hdr, hdr);\n\n    pjsip_dlg_dec_lock(dlg);\n\n    /* Done. */\n    return PJ_SUCCESS;\n}\n\n/*\n * Remove a remote capability header.\n */\nPJ_DEF(pj_status_t) pjsip_dlg_remove_remote_cap_hdr(pjsip_dialog *dlg,\n\t\t\t\t\t\t    int htype,\n\t\t\t\t\t\t    const pj_str_t *hname)\n{\n    pjsip_generic_array_hdr *hdr;\n\n    /* Check arguments. */\n    PJ_ASSERT_RETURN(dlg, PJ_EINVAL);\n    PJ_ASSERT_RETURN((htype != PJSIP_H_OTHER) || (hname && hname->slen),\n\t\t     PJ_EINVAL);\n\n    pjsip_dlg_inc_lock(dlg);\n\n    hdr = (pjsip_generic_array_hdr*)\n\t  pjsip_dlg_get_remote_cap_hdr(dlg, htype, hname);\n    if (!hdr) {\n\tpjsip_dlg_dec_lock(dlg);\n\treturn PJ_ENOTFOUND;\n    }\n\n    pj_list_erase(hdr);\n\n    pjsip_dlg_dec_lock(dlg);\n\n    return PJ_SUCCESS;\n}\n", "/* $Id$ */\n/* \n * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)\n * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n#include <pjsip/sip_transport.h>\n#include <pjsip/sip_endpoint.h>\n#include <pjsip/sip_parser.h>\n#include <pjsip/sip_msg.h>\n#include <pjsip/sip_private.h>\n#include <pjsip/sip_errno.h>\n#include <pjsip/sip_module.h>\n#include <pj/addr_resolv.h>\n#include <pj/except.h>\n#include <pj/os.h>\n#include <pj/log.h>\n#include <pj/ioqueue.h>\n#include <pj/hash.h>\n#include <pj/string.h>\n#include <pj/pool.h>\n#include <pj/assert.h>\n#include <pj/lock.h>\n#include <pj/list.h>\n\n\n#define THIS_FILE    \"sip_transport.c\"\n\n#if 0\n#   define TRACE_(x)\tPJ_LOG(5,x)\n\nstatic const char *addr_string(const pj_sockaddr_t *addr)\n{\n    static char str[PJ_INET6_ADDRSTRLEN];\n    pj_inet_ntop(((const pj_sockaddr*)addr)->addr.sa_family, \n\t\t pj_sockaddr_get_addr(addr),\n\t\t str, sizeof(str));\n    return str;\n}\nstatic const char* print_tpsel_info(const pjsip_tpselector *sel)\n{\n    static char tpsel_info_buf[80];\n    if (!sel) return \"(null)\";\n    if (sel->type==PJSIP_TPSELECTOR_LISTENER)\n\tpj_ansi_snprintf(tpsel_info_buf, sizeof(tpsel_info_buf),\n\t\t\t \"listener[%s], reuse=%d\", sel->u.listener->obj_name,\n\t\t\t !sel->disable_connection_reuse);\n    else if (sel->type==PJSIP_TPSELECTOR_TRANSPORT)\n\tpj_ansi_snprintf(tpsel_info_buf, sizeof(tpsel_info_buf),\n\t\t\t \"transport[%s], reuse=%d\", sel->u.transport->info,\n\t\t\t !sel->disable_connection_reuse);\n    else\n\tpj_ansi_snprintf(tpsel_info_buf, sizeof(tpsel_info_buf),\n\t\t\t \"unknown[%p], reuse=%d\", sel->u.ptr,\n\t\t\t !sel->disable_connection_reuse);\n    return tpsel_info_buf;\n}\n#else\n#   define TRACE_(x)\n#endif\n\n/* Specify the initial size of the transport manager's pool. */\n#ifndef  TPMGR_POOL_INIT_SIZE\n#   define TPMGR_POOL_INIT_SIZE\t64\n#endif\n\n/* Specify the increment size of the transport manager's pool. */\n#ifndef TPMGR_POOL_INC_SIZE\n    #define TPMGR_POOL_INC_SIZE\t64\n#endif\n\n/* Specify transport entry allocation count. When registering a new transport,\n * a new entry will be picked from a free list. This setting will determine\n * the size of the free list size. If all entry is used, then the same number\n * of entry will be allocated.\n */\n#ifndef PJSIP_TRANSPORT_ENTRY_ALLOC_CNT\n#   define PJSIP_TRANSPORT_ENTRY_ALLOC_CNT  16\n#endif\n\n/* Prototype. */\nstatic pj_status_t mod_on_tx_msg(pjsip_tx_data *tdata);\n\n/* This module has sole purpose to print transmit data to contigous buffer\n * before actually transmitted to the wire. \n */\nstatic pjsip_module mod_msg_print = \n{\n    NULL, NULL,\t\t\t\t/* prev and next\t\t    */\n    { \"mod-msg-print\", 13},\t\t/* Name.\t\t\t    */\n    -1,\t\t\t\t\t/* Id\t\t\t\t    */\n    PJSIP_MOD_PRIORITY_TRANSPORT_LAYER,\t/* Priority\t\t\t    */\n    NULL,\t\t\t\t/* load()\t\t\t    */\n    NULL,\t\t\t\t/* start()\t\t\t    */\n    NULL,\t\t\t\t/* stop()\t\t\t    */\n    NULL,\t\t\t\t/* unload()\t\t\t    */\n    NULL,\t\t\t\t/* on_rx_request()\t\t    */\n    NULL,\t\t\t\t/* on_rx_response()\t\t    */\n    &mod_on_tx_msg,\t\t\t/* on_tx_request()\t\t    */\n    &mod_on_tx_msg,\t\t\t/* on_tx_response()\t\t    */\n    NULL,\t\t\t\t/* on_tsx_state()\t\t    */\n};\n\n/* Transport list item */\ntypedef struct transport\n{\n    PJ_DECL_LIST_MEMBER(struct transport);\n    pj_hash_entry_buf tp_buf;\n    pjsip_transport *tp;\n} transport;\n\n/*\n * Transport manager.\n */\nstruct pjsip_tpmgr \n{\n    pj_hash_table_t *table;\n    pj_lock_t\t    *lock;\n    pjsip_endpoint  *endpt;\n    pjsip_tpfactory  factory_list;\n    pj_pool_t\t    *pool;\n#if defined(PJ_DEBUG) && PJ_DEBUG!=0\n    pj_atomic_t\t    *tdata_counter;\n#endif\n    void           (*on_rx_msg)(pjsip_endpoint*, pj_status_t, pjsip_rx_data*);\n    pj_status_t\t   (*on_tx_msg)(pjsip_endpoint*, pjsip_tx_data*);\n    pjsip_tp_state_callback tp_state_cb;\n    pjsip_tp_on_rx_dropped_cb tp_drop_data_cb;\n\n    /* Transmit data list, for transmit data cleanup when transport manager\n     * is destroyed.\n     */\n    pjsip_tx_data    tdata_list;\n\n    /* List of free transport entry. */\n    transport\t     tp_entry_freelist;\n};\n\n\n/* Transport state listener list type */\ntypedef struct tp_state_listener\n{\n    PJ_DECL_LIST_MEMBER(struct tp_state_listener);\n\n    pjsip_tp_state_callback  cb;\n    void *user_data;\n} tp_state_listener;\n\n\n/*\n * Transport data.\n */\ntypedef struct transport_data\n{\n    /* Transport listeners */\n    tp_state_listener\t    st_listeners;\n    tp_state_listener\t    st_listeners_empty;\n} transport_data;\n\n\n/*****************************************************************************\n *\n * GENERAL TRANSPORT (NAMES, TYPES, ETC.)\n *\n *****************************************************************************/\n\n/*\n * Transport names.\n */\nstatic struct transport_names_t\n{\n    pjsip_transport_type_e type;\t    /* Transport type\t    */\n    pj_uint16_t\t\t   port;\t    /* Default port number  */\n    pj_str_t\t\t   name;\t    /* Id tag\t\t    */\n    const char\t\t  *description;\t    /* Longer description   */\n    unsigned\t\t   flag;\t    /* Flags\t\t    */\n    char\t\t   name_buf[16];    /* For user's transport */\n} transport_names[16] = \n{\n    { \n\tPJSIP_TRANSPORT_UNSPECIFIED, \n\t0, \n\t{\"Unspecified\", 11}, \n\t\"Unspecified\", \n\t0\n    },\n    { \n\tPJSIP_TRANSPORT_UDP, \n\t5060, \n\t{\"UDP\", 3}, \n\t\"UDP transport\", \n\tPJSIP_TRANSPORT_DATAGRAM\n    },\n    { \n\tPJSIP_TRANSPORT_TCP, \n\t5060, \n\t{\"TCP\", 3}, \n\t\"TCP transport\", \n\tPJSIP_TRANSPORT_RELIABLE\n    },\n    { \n\tPJSIP_TRANSPORT_TLS, \n\t5061, \n\t{\"TLS\", 3}, \n\t\"TLS transport\", \n\tPJSIP_TRANSPORT_RELIABLE | PJSIP_TRANSPORT_SECURE\n    },\n    { \n\tPJSIP_TRANSPORT_DTLS,\n\t5061, \n\t{\"DTLS\", 4}, \n\t\"DTLS transport\", \n\tPJSIP_TRANSPORT_SECURE\n    },\n    { \n\tPJSIP_TRANSPORT_SCTP, \n\t5060, \n\t{\"SCTP\", 4}, \n\t\"SCTP transport\", \n\tPJSIP_TRANSPORT_RELIABLE\n    },\n    { \n\tPJSIP_TRANSPORT_LOOP, \n\t15060, \n\t{\"LOOP\", 4}, \n\t\"Loopback transport\", \n\tPJSIP_TRANSPORT_RELIABLE\n    }, \n    { \n\tPJSIP_TRANSPORT_LOOP_DGRAM, \n\t15060, \n\t{\"LOOP-DGRAM\", 10}, \n\t\"Loopback datagram transport\", \n\tPJSIP_TRANSPORT_DATAGRAM\n    },\n    { \n\tPJSIP_TRANSPORT_UDP6, \n\t5060, \n\t{\"UDP\", 3}, \n\t\"UDP IPv6 transport\", \n\tPJSIP_TRANSPORT_DATAGRAM\n    },\n    { \n\tPJSIP_TRANSPORT_TCP6, \n\t5060, \n\t{\"TCP\", 3}, \n\t\"TCP IPv6 transport\", \n\tPJSIP_TRANSPORT_RELIABLE\n    },\n    {\n\tPJSIP_TRANSPORT_TLS6,\n\t5061,\n\t{\"TLS\", 3},\n\t\"TLS IPv6 transport\",\n\tPJSIP_TRANSPORT_RELIABLE | PJSIP_TRANSPORT_SECURE\n    },\n    {\n\tPJSIP_TRANSPORT_DTLS6,\n\t5061,\n\t{\"DTLS\", 4},\n\t\"DTLS IPv6 transport\",\n\tPJSIP_TRANSPORT_SECURE\n    },\n};\n\nstatic void tp_state_callback(pjsip_transport *tp,\n\t\t\t      pjsip_transport_state state,\n\t\t\t      const pjsip_transport_state_info *info);\n\n\nstatic struct transport_names_t *get_tpname(pjsip_transport_type_e type)\n{\n    unsigned i;\n    for (i=0; i<PJ_ARRAY_SIZE(transport_names); ++i) {\n\tif (transport_names[i].type == type)\n\t    return &transport_names[i];\n    }\n    pj_assert(!\"Invalid transport type!\");\n    return NULL;\n}\n\n\n\n/*\n * Register new transport type to PJSIP.\n */\nPJ_DEF(pj_status_t) pjsip_transport_register_type( unsigned tp_flag,\n\t\t\t\t\t\t   const char *tp_name,\n\t\t\t\t\t\t   int def_port,\n\t\t\t\t\t\t   int *p_tp_type)\n{\n    unsigned i;\n    pjsip_transport_type_e parent = 0;\n\n    PJ_ASSERT_RETURN(tp_flag && tp_name && def_port, PJ_EINVAL);\n    PJ_ASSERT_RETURN(pj_ansi_strlen(tp_name) < \n\t\t\tPJ_ARRAY_SIZE(transport_names[0].name_buf), \n\t\t     PJ_ENAMETOOLONG);\n\n    for (i=1; i<PJ_ARRAY_SIZE(transport_names); ++i) {\n        if (tp_flag & PJSIP_TRANSPORT_IPV6 && \n            pj_stricmp2(&transport_names[i].name, tp_name) == 0)\n        {\n\t    parent = transport_names[i].type;\n        }\n\tif (transport_names[i].type == 0)\n\t    break;\n    }\n\n    if (i == PJ_ARRAY_SIZE(transport_names))\n\treturn PJ_ETOOMANY;\n\n    if (tp_flag & PJSIP_TRANSPORT_IPV6 && parent) {\n        transport_names[i].type = parent | PJSIP_TRANSPORT_IPV6;\n    } else {\n        transport_names[i].type = (pjsip_transport_type_e)i;\n    }\n\n    transport_names[i].port = (pj_uint16_t)def_port;\n    pj_ansi_strcpy(transport_names[i].name_buf, tp_name);\n    transport_names[i].name = pj_str(transport_names[i].name_buf);\n    transport_names[i].flag = tp_flag;\n\n    if (p_tp_type)\n\t*p_tp_type = transport_names[i].type;\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Get transport type from name.\n */\nPJ_DEF(pjsip_transport_type_e) pjsip_transport_get_type_from_name(const pj_str_t *name)\n{\n    unsigned i;\n\n    if (name->slen == 0)\n\treturn PJSIP_TRANSPORT_UNSPECIFIED;\n\n    /* Get transport type from name. */\n    for (i=0; i<PJ_ARRAY_SIZE(transport_names); ++i) {\n\tif (pj_stricmp(name, &transport_names[i].name) == 0) {\n\t    return transport_names[i].type;\n\t}\n    }\n\n    pj_assert(!\"Invalid transport name\");\n    return PJSIP_TRANSPORT_UNSPECIFIED;\n}\n\n\n/*\n * Get the transport type for the specified flags.\n */\nPJ_DEF(pjsip_transport_type_e) pjsip_transport_get_type_from_flag(unsigned flag)\n{\n    unsigned i;\n\n    /* Get the transport type for the specified flags. */\n    for (i=0; i<PJ_ARRAY_SIZE(transport_names); ++i) {\n\tif (transport_names[i].flag == flag) {\n\t    return transport_names[i].type;\n\t}\n    }\n\n    pj_assert(!\"Invalid transport type\");\n    return PJSIP_TRANSPORT_UNSPECIFIED;\n}\n\n/*\n * Get the socket address family of a given transport type.\n */\nPJ_DEF(int) pjsip_transport_type_get_af(pjsip_transport_type_e type)\n{\n    if (type & PJSIP_TRANSPORT_IPV6)\n\treturn pj_AF_INET6();\n    else\n\treturn pj_AF_INET();\n}\n\nPJ_DEF(unsigned) pjsip_transport_get_flag_from_type(pjsip_transport_type_e type)\n{\n    /* Return transport flag. */\n    return get_tpname(type)->flag;\n}\n\n/*\n * Get the default SIP port number for the specified type.\n */\nPJ_DEF(int) pjsip_transport_get_default_port_for_type(pjsip_transport_type_e type)\n{\n    /* Return the port. */\n    return get_tpname(type)->port;\n}\n\n/*\n * Get transport name.\n */\nPJ_DEF(const char*) pjsip_transport_get_type_name(pjsip_transport_type_e type)\n{\n    /* Return the name. */\n    return get_tpname(type)->name.ptr;\n}\n\n/*\n * Get transport description.\n */\nPJ_DEF(const char*) pjsip_transport_get_type_desc(pjsip_transport_type_e type)\n{\n    /* Return the description. */\n    return get_tpname(type)->description;\n}\n\n\n/*****************************************************************************\n *\n * TRANSPORT SELECTOR\n *\n *****************************************************************************/\n\n/*\n * Add transport/listener reference in the selector.\n */\nPJ_DEF(void) pjsip_tpselector_add_ref(pjsip_tpselector *sel)\n{\n    if (sel->type == PJSIP_TPSELECTOR_TRANSPORT && sel->u.transport != NULL)\n\tpjsip_transport_add_ref(sel->u.transport);\n    else if (sel->type == PJSIP_TPSELECTOR_LISTENER && sel->u.listener != NULL)\n\t; /* Hmm.. looks like we don't have reference counter for listener */\n}\n\n\n/*\n * Decrement transport/listener reference in the selector.\n */\nPJ_DEF(void) pjsip_tpselector_dec_ref(pjsip_tpselector *sel)\n{\n    if (sel->type == PJSIP_TPSELECTOR_TRANSPORT && sel->u.transport != NULL)\n\tpjsip_transport_dec_ref(sel->u.transport);\n    else if (sel->type == PJSIP_TPSELECTOR_LISTENER && sel->u.listener != NULL)\n\t; /* Hmm.. looks like we don't have reference counter for listener */\n}\n\n\n/*****************************************************************************\n *\n * TRANSMIT DATA BUFFER MANIPULATION.\n *\n *****************************************************************************/\n\n/*\n * Create new transmit buffer.\n */\nPJ_DEF(pj_status_t) pjsip_tx_data_create( pjsip_tpmgr *mgr,\n\t\t\t\t\t  pjsip_tx_data **p_tdata )\n{\n    pj_pool_t *pool;\n    pjsip_tx_data *tdata;\n    pj_status_t status;\n\n    PJ_ASSERT_RETURN(mgr && p_tdata, PJ_EINVAL);\n\n    pool = pjsip_endpt_create_pool( mgr->endpt, \"tdta%p\",\n\t\t\t\t    PJSIP_POOL_LEN_TDATA,\n\t\t\t\t    PJSIP_POOL_INC_TDATA );\n    if (!pool)\n\treturn PJ_ENOMEM;\n\n    tdata = PJ_POOL_ZALLOC_T(pool, pjsip_tx_data);\n    tdata->pool = pool;\n    tdata->mgr = mgr;\n    pj_ansi_snprintf(tdata->obj_name, sizeof(tdata->obj_name), \"tdta%p\", tdata);\n    pj_memcpy(pool->obj_name, tdata->obj_name, sizeof(pool->obj_name));\n\n    status = pj_atomic_create(tdata->pool, 0, &tdata->ref_cnt);\n    if (status != PJ_SUCCESS) {\n\tpjsip_endpt_release_pool( mgr->endpt, tdata->pool );\n\treturn status;\n    }\n    \n    //status = pj_lock_create_simple_mutex(pool, \"tdta%p\", &tdata->lock);\n    status = pj_lock_create_null_mutex(pool, \"tdta%p\", &tdata->lock);\n    if (status != PJ_SUCCESS) {\n\tpjsip_endpt_release_pool( mgr->endpt, tdata->pool );\n\treturn status;\n    }\n\n    pj_ioqueue_op_key_init(&tdata->op_key.key, sizeof(tdata->op_key.key));\n    pj_list_init(tdata);\n\n#if defined(PJSIP_HAS_TX_DATA_LIST) && PJSIP_HAS_TX_DATA_LIST!=0\n    /* Append this just created tdata to transmit buffer list */\n    pj_lock_acquire(mgr->lock);\n    pj_list_push_back(&mgr->tdata_list, tdata);\n    pj_lock_release(mgr->lock);\n#endif\n\n#if defined(PJ_DEBUG) && PJ_DEBUG!=0\n    pj_atomic_inc( tdata->mgr->tdata_counter );\n#endif\n\n    *p_tdata = tdata;\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Add reference to tx buffer.\n */\nPJ_DEF(void) pjsip_tx_data_add_ref( pjsip_tx_data *tdata )\n{\n    pj_atomic_inc(tdata->ref_cnt);\n}\n\nstatic void tx_data_destroy(pjsip_tx_data *tdata)\n{\n    PJ_LOG(5,(tdata->obj_name, \"Destroying txdata %s\",\n\t      pjsip_tx_data_get_info(tdata)));\n    pjsip_tpselector_dec_ref(&tdata->tp_sel);\n#if defined(PJ_DEBUG) && PJ_DEBUG!=0\n    pj_atomic_dec( tdata->mgr->tdata_counter );\n#endif\n\n#if defined(PJSIP_HAS_TX_DATA_LIST) && PJSIP_HAS_TX_DATA_LIST!=0\n    /* Remove this tdata from transmit buffer list */\n    pj_lock_acquire(tdata->mgr->lock);\n    pj_list_erase(tdata);\n    pj_lock_release(tdata->mgr->lock);\n#endif\n\n    pj_atomic_destroy( tdata->ref_cnt );\n    pj_lock_destroy( tdata->lock );\n    pjsip_endpt_release_pool( tdata->mgr->endpt, tdata->pool );\n}\n\n/*\n * Decrease transport data reference, destroy it when the reference count\n * reaches zero.\n */\nPJ_DEF(pj_status_t) pjsip_tx_data_dec_ref( pjsip_tx_data *tdata )\n{\n    pj_atomic_value_t ref_cnt;\n    \n    PJ_ASSERT_RETURN(tdata && tdata->ref_cnt, PJ_EINVAL);\n\n    ref_cnt = pj_atomic_dec_and_get(tdata->ref_cnt);\n    pj_assert( ref_cnt >= 0);\n    if (ref_cnt == 0) {\n\ttx_data_destroy(tdata);\n\treturn PJSIP_EBUFDESTROYED;\n    } else {\n\treturn PJ_SUCCESS;\n    }\n}\n\n/*\n * Invalidate the content of the print buffer to force the message to be\n * re-printed when sent.\n */\nPJ_DEF(void) pjsip_tx_data_invalidate_msg( pjsip_tx_data *tdata )\n{\n    tdata->buf.cur = tdata->buf.start;\n    tdata->info = NULL;\n}\n\n/*\n * Print the SIP message to transmit data buffer's internal buffer.\n */\nPJ_DEF(pj_status_t) pjsip_tx_data_encode(pjsip_tx_data *tdata)\n{\n    /* Allocate buffer if necessary. */\n    if (tdata->buf.start == NULL) {\n\tPJ_USE_EXCEPTION;\n\n\tPJ_TRY {\n\t    tdata->buf.start = (char*) \n\t\t\t       pj_pool_alloc(tdata->pool, PJSIP_MAX_PKT_LEN);\n\t}\n\tPJ_CATCH_ANY {\n\t    return PJ_ENOMEM;\n\t}\n\tPJ_END\n\n\ttdata->buf.cur = tdata->buf.start;\n\ttdata->buf.end = tdata->buf.start + PJSIP_MAX_PKT_LEN;\n    }\n\n    /* Do we need to reprint? */\n    if (!pjsip_tx_data_is_valid(tdata)) {\n\tpj_ssize_t size;\n\n\tsize = pjsip_msg_print( tdata->msg, tdata->buf.start, \n\t\t\t        tdata->buf.end - tdata->buf.start);\n\tif (size < 0) {\n\t    return PJSIP_EMSGTOOLONG;\n\t}\n\tpj_assert(size != 0);\n\ttdata->buf.cur[size] = '\\0';\n\ttdata->buf.cur += size;\n    }\n\n    return PJ_SUCCESS;\n}\n\nPJ_DEF(pj_bool_t) pjsip_tx_data_is_valid( pjsip_tx_data *tdata )\n{\n    return tdata->buf.cur != tdata->buf.start;\n}\n\nstatic char *get_msg_info(pj_pool_t *pool, const char *obj_name,\n\t\t\t  const pjsip_msg *msg)\n{\n    char info_buf[128], *info;\n    const pjsip_cseq_hdr *cseq;\n    int len;\n\n    cseq = (const pjsip_cseq_hdr*) pjsip_msg_find_hdr(msg, PJSIP_H_CSEQ, NULL);\n    PJ_ASSERT_RETURN(cseq != NULL, \"INVALID MSG\");\n\n    if (msg->type == PJSIP_REQUEST_MSG) {\n\tlen = pj_ansi_snprintf(info_buf, sizeof(info_buf), \n\t\t\t       \"Request msg %.*s/cseq=%d (%s)\",\n\t\t\t       (int)msg->line.req.method.name.slen,\n\t\t\t       msg->line.req.method.name.ptr,\n\t\t\t       cseq->cseq, obj_name);\n    } else {\n\tlen = pj_ansi_snprintf(info_buf, sizeof(info_buf),\n\t\t\t       \"Response msg %d/%.*s/cseq=%d (%s)\",\n\t\t\t       msg->line.status.code,\n\t\t\t       (int)cseq->method.name.slen,\n\t\t\t       cseq->method.name.ptr,\n\t\t\t       cseq->cseq, obj_name);\n    }\n\n    if (len < 1 || len >= (int)sizeof(info_buf)) {\n\treturn (char*)obj_name;\n    }\n\n    info = (char*) pj_pool_alloc(pool, len+1);\n    pj_memcpy(info, info_buf, len+1);\n\n    return info;\n}\n\nPJ_DEF(char*) pjsip_tx_data_get_info( pjsip_tx_data *tdata )\n{\n    PJ_ASSERT_RETURN(tdata, \"NULL\");\n\n    /* tdata->info may be assigned by application so if it exists\n     * just return it.\n     */\n    if (tdata->info)\n\treturn tdata->info;\n\n    if (tdata->msg==NULL)\n\treturn \"NULL\";\n\n    pj_lock_acquire(tdata->lock);\n    tdata->info = get_msg_info(tdata->pool, tdata->obj_name, tdata->msg);\n    pj_lock_release(tdata->lock);\n\n    return tdata->info;\n}\n\nPJ_DEF(pj_status_t) pjsip_tx_data_set_transport(pjsip_tx_data *tdata,\n\t\t\t\t\t\tconst pjsip_tpselector *sel)\n{\n    PJ_ASSERT_RETURN(tdata && sel, PJ_EINVAL);\n\n    pj_lock_acquire(tdata->lock);\n\n    pjsip_tpselector_dec_ref(&tdata->tp_sel);\n\n    pj_memcpy(&tdata->tp_sel, sel, sizeof(*sel));\n    pjsip_tpselector_add_ref(&tdata->tp_sel);\n\n    pj_lock_release(tdata->lock);\n\n    return PJ_SUCCESS;\n}\n\n/* Clone pjsip_tx_data. */\nPJ_DEF(pj_status_t) pjsip_tx_data_clone(const pjsip_tx_data *src,\n                                        unsigned flags,\n\t\t\t\t  \tpjsip_tx_data ** p_tdata)\n{\n    pjsip_tx_data *dst;\n    const pjsip_hdr *hsrc;\n    pjsip_msg *msg;\n    pj_status_t status;\n\n    PJ_UNUSED_ARG(flags);\n\n    status = pjsip_tx_data_create(src->mgr, p_tdata);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    dst = *p_tdata;\n\n    msg = pjsip_msg_create(dst->pool, PJSIP_RESPONSE_MSG);\n    dst->msg = msg;\n    pjsip_tx_data_add_ref(dst);\n\n    /* Duplicate status line */\n    msg->line.status.code = src->msg->line.status.code;\n    pj_strdup(dst->pool, &msg->line.status.reason,\n\t      &src->msg->line.status.reason);\n\n    /* Duplicate all headers */\n    hsrc = src->msg->hdr.next;\n    while (hsrc != &src->msg->hdr) {\n\tpjsip_hdr *h = (pjsip_hdr*) pjsip_hdr_clone(dst->pool, hsrc);\n\tpjsip_msg_add_hdr(msg, h);\n\thsrc = hsrc->next;\n    }\n\n    /* Duplicate message body */\n    if (src->msg->body)\n\tmsg->body = pjsip_msg_body_clone(dst->pool, src->msg->body);\n\n    /* We shouldn't copy is_pending since it's src's internal state,\n     * indicating that it's currently being sent by the transport.\n     * While the cloned tdata is of course not.\n     */\n    //dst->is_pending = src->is_pending;\n\n    PJ_LOG(5,(THIS_FILE,\n\t     \"Tx data %s cloned\",\n\t     pjsip_tx_data_get_info(dst)));\n\n    return PJ_SUCCESS;\n}\n\nPJ_DEF(char*) pjsip_rx_data_get_info(pjsip_rx_data *rdata)\n{\n    char obj_name[PJ_MAX_OBJ_NAME];\n\n    PJ_ASSERT_RETURN(rdata->msg_info.msg, \"INVALID MSG\");\n\n    if (rdata->msg_info.info)\n\treturn rdata->msg_info.info;\n\n    pj_ansi_strcpy(obj_name, \"rdata\");\n    pj_ansi_snprintf(obj_name+5, sizeof(obj_name)-5, \"%p\", rdata);\n\n    rdata->msg_info.info = get_msg_info(rdata->tp_info.pool, obj_name,\n\t\t\t\t\trdata->msg_info.msg);\n    return rdata->msg_info.info;\n}\n\n/* Clone pjsip_rx_data. */\nPJ_DEF(pj_status_t) pjsip_rx_data_clone( const pjsip_rx_data *src,\n                                         unsigned flags,\n                                         pjsip_rx_data **p_rdata)\n{\n    pj_pool_t *pool;\n    pjsip_rx_data *dst;\n    pjsip_hdr *hdr;\n\n    PJ_ASSERT_RETURN(src && flags==0 && p_rdata, PJ_EINVAL);\n\n    pool = pj_pool_create(src->tp_info.pool->factory,\n                          \"rtd%p\",\n                          PJSIP_POOL_RDATA_LEN,\n                          PJSIP_POOL_RDATA_INC,\n                          NULL);\n    if (!pool)\n\treturn PJ_ENOMEM;\n\n    dst = PJ_POOL_ZALLOC_T(pool, pjsip_rx_data);\n\n    /* Parts of tp_info */\n    dst->tp_info.pool = pool;\n    dst->tp_info.transport = (pjsip_transport*)src->tp_info.transport;\n\n    /* pkt_info can be memcopied */\n    pj_memcpy(&dst->pkt_info, &src->pkt_info, sizeof(src->pkt_info));\n\n    /* msg_info needs deep clone */\n    dst->msg_info.msg_buf = dst->pkt_info.packet +\n\t\t\t    (src->msg_info.msg_buf - src->pkt_info.packet);\n    dst->msg_info.len = src->msg_info.len;\n    dst->msg_info.msg = pjsip_msg_clone(pool, src->msg_info.msg);\n    pj_list_init(&dst->msg_info.parse_err);\n\n#define GET_MSG_HDR2(TYPE, type, var)\t\\\n\t\t\tcase PJSIP_H_##TYPE: \\\n\t\t\t    if (!dst->msg_info.var) { \\\n\t\t\t\tdst->msg_info.var = (pjsip_##type##_hdr*)hdr; \\\n\t\t\t    } \\\n\t\t\t    break\n#define GET_MSG_HDR(TYPE, var_type)\tGET_MSG_HDR2(TYPE, var_type, var_type)\n\n    hdr = dst->msg_info.msg->hdr.next;\n    while (hdr != &dst->msg_info.msg->hdr) {\n\tswitch (hdr->type) {\n\tGET_MSG_HDR(CALL_ID, cid);\n\tGET_MSG_HDR(FROM, from);\n\tGET_MSG_HDR(TO, to);\n\tGET_MSG_HDR(VIA, via);\n\tGET_MSG_HDR(CSEQ, cseq);\n\tGET_MSG_HDR(MAX_FORWARDS, max_fwd);\n\tGET_MSG_HDR(ROUTE, route);\n\tGET_MSG_HDR2(RECORD_ROUTE, rr, record_route);\n\tGET_MSG_HDR(CONTENT_TYPE, ctype);\n\tGET_MSG_HDR(CONTENT_LENGTH, clen);\n\tGET_MSG_HDR(REQUIRE, require);\n\tGET_MSG_HDR(SUPPORTED, supported);\n\tdefault:\n\t    break;\n\t}\n\thdr = hdr->next;\n    }\n\n#undef GET_MSG_HDR\n#undef GET_MSG_HDR2\n\n    *p_rdata = dst;\n\n    /* Finally add transport ref */\n    return pjsip_transport_add_ref(dst->tp_info.transport);\n}\n\n/* Free previously cloned pjsip_rx_data. */\nPJ_DEF(pj_status_t) pjsip_rx_data_free_cloned(pjsip_rx_data *rdata)\n{\n    PJ_ASSERT_RETURN(rdata, PJ_EINVAL);\n\n    pjsip_transport_dec_ref(rdata->tp_info.transport);\n    pj_pool_release(rdata->tp_info.pool);\n\n    return PJ_SUCCESS;\n}\n\n/*****************************************************************************\n *\n * TRANSPORT KEY\n *\n *****************************************************************************/\n\n\n/*****************************************************************************\n *\n * TRANSPORT\n *\n *****************************************************************************/\n\nstatic void transport_send_callback(pjsip_transport *transport,\n\t\t\t\t    void *token,\n\t\t\t\t    pj_ssize_t size)\n{\n    pjsip_tx_data *tdata = (pjsip_tx_data*) token;\n\n    PJ_UNUSED_ARG(transport);\n\n    /* Mark pending off so that app can resend/reuse txdata from inside\n     * the callback.\n     */\n    tdata->is_pending = 0;\n\n    /* Call callback, if any. */\n    if (tdata->cb) {\n\t(*tdata->cb)(tdata->token, tdata, size);\n    }\n\n    /* Decrement reference count. */\n    pjsip_tx_data_dec_ref(tdata);\n}\n\n/* This function is called by endpoint for on_tx_request() and on_tx_response()\n * notification.\n */\nstatic pj_status_t mod_on_tx_msg(pjsip_tx_data *tdata)\n{\n    return pjsip_tx_data_encode(tdata);\n}\n\n/*\n * Send a SIP message using the specified transport.\n */\nPJ_DEF(pj_status_t) pjsip_transport_send(  pjsip_transport *tr, \n\t\t\t\t\t   pjsip_tx_data *tdata,\n\t\t\t\t\t   const pj_sockaddr_t *addr,\n\t\t\t\t\t   int addr_len,\n\t\t\t\t\t   void *token,\n\t\t\t\t\t   pjsip_tp_send_callback cb)\n{\n    pj_status_t status;\n\n    PJ_ASSERT_RETURN(tr && tdata && addr, PJ_EINVAL);\n\n    /* Is it currently being sent? */\n    if (tdata->is_pending) {\n\tpj_assert(!\"Invalid operation step!\");\n\tPJ_LOG(2,(THIS_FILE, \"Unable to send %s: message is pending\", \n\t\t\t     pjsip_tx_data_get_info(tdata)));\n\treturn PJSIP_EPENDINGTX;\n    }\n\n    /* Add reference to prevent deletion, and to cancel idle timer if\n     * it's running.\n     */\n    pjsip_transport_add_ref(tr);\n\n    /* Fill in tp_info. */\n    tdata->tp_info.transport = tr;\n    pj_memcpy(&tdata->tp_info.dst_addr, addr, addr_len);\n    tdata->tp_info.dst_addr_len = addr_len;\n\n    pj_inet_ntop(((pj_sockaddr*)addr)->addr.sa_family,\n\t\t pj_sockaddr_get_addr(addr),\n\t\t tdata->tp_info.dst_name,\n\t\t sizeof(tdata->tp_info.dst_name));\n    tdata->tp_info.dst_port = pj_sockaddr_get_port(addr);\n\n    /* Distribute to modules. \n     * When the message reach mod_msg_print, the contents of the message will\n     * be \"printed\" to contiguous buffer.\n     */\n    if (tr->tpmgr->on_tx_msg) {\n\tstatus = (*tr->tpmgr->on_tx_msg)(tr->endpt, tdata);\n\tif (status != PJ_SUCCESS) {\n\t    pjsip_transport_dec_ref(tr);\n\t    return status;\n\t}\n    }\n\n    /* Save callback data. */\n    tdata->token = token;\n    tdata->cb = cb;\n\n    /* Add reference counter. */\n    pjsip_tx_data_add_ref(tdata);\n\n    /* Mark as pending. */\n    tdata->is_pending = 1;\n\n    /* Send to transport. */\n    status = (*tr->send_msg)(tr, tdata,  addr, addr_len, (void*)tdata, \n\t\t\t     &transport_send_callback);\n\n    if (status != PJ_EPENDING) {\n\ttdata->is_pending = 0;\n\tpjsip_tx_data_dec_ref(tdata);\n    }\n\n    pjsip_transport_dec_ref(tr);\n    return status;\n}\n\n\n/* send_raw() callback */\nstatic void send_raw_callback(pjsip_transport *transport,\n\t\t\t      void *token,\n\t\t\t      pj_ssize_t size)\n{\n    pjsip_tx_data *tdata = (pjsip_tx_data*) token;\n\n    /* Mark pending off so that app can resend/reuse txdata from inside\n     * the callback.\n     */\n    tdata->is_pending = 0;\n\n    /* Call callback, if any. */\n    if (tdata->cb) {\n\t(*tdata->cb)(tdata->token, tdata, size);\n    }\n\n    /* Decrement tdata reference count. */\n    pjsip_tx_data_dec_ref(tdata);\n\n    /* Decrement transport reference count */\n    pjsip_transport_dec_ref(transport);\n}\n\n\n/* Send raw data */\nPJ_DEF(pj_status_t) pjsip_tpmgr_send_raw(pjsip_tpmgr *mgr,\n\t\t\t\t\t pjsip_transport_type_e tp_type,\n\t\t\t\t\t const pjsip_tpselector *sel,\n\t\t\t\t\t pjsip_tx_data *tdata,\n\t\t\t\t\t const void *raw_data,\n\t\t\t\t\t pj_size_t data_len,\n\t\t\t\t\t const pj_sockaddr_t *addr,\n\t\t\t\t\t int addr_len,\n\t\t\t\t\t void *token,\n\t\t\t\t\t pjsip_tp_send_callback cb)\n{\n    pjsip_transport *tr;\n    pj_status_t status;\n \n    /* Acquire the transport */\n    status = pjsip_tpmgr_acquire_transport(mgr, tp_type, addr, addr_len,\n\t\t\t\t\t   sel, &tr);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Create transmit data buffer if one is not specified */\n    if (tdata == NULL) {\n\tstatus = pjsip_endpt_create_tdata(tr->endpt, &tdata);\n\tif (status != PJ_SUCCESS) {\n\t    pjsip_transport_dec_ref(tr);\n\t    return status;\n\t}\n\n\ttdata->info = \"raw\";\n\n\t/* Add reference counter. */\n\tpjsip_tx_data_add_ref(tdata);\n    }\n\n    /* Allocate buffer */\n    if (tdata->buf.start == NULL ||\n\t(tdata->buf.end - tdata->buf.start) < (int)data_len)\n    {\n\t/* Note: data_len may be zero, so allocate +1 */\n\ttdata->buf.start = (char*) pj_pool_alloc(tdata->pool, data_len+1);\n\ttdata->buf.end = tdata->buf.start + data_len + 1;\n    }\n \n    /* Copy data, if any! (application may send zero len packet) */\n    if (data_len) {\n\tpj_memcpy(tdata->buf.start, raw_data, data_len);\n    }\n    tdata->buf.cur = tdata->buf.start + data_len;\n \n    /* Save callback data. */\n    tdata->token = token;\n    tdata->cb = cb;\n\n    /* Mark as pending. */\n    tdata->is_pending = 1;\n\n    /* Send to transport */\n    status = tr->send_msg(tr, tdata, addr, addr_len,\n\t\t\t  tdata, &send_raw_callback);\n \n    if (status != PJ_EPENDING) {\n\t/* callback will not be called, so destroy tdata now. */\n\tpjsip_tx_data_dec_ref(tdata);\n\tpjsip_transport_dec_ref(tr);\n    }\n\n    return status;\n}\n\n\nstatic void transport_idle_callback(pj_timer_heap_t *timer_heap,\n\t\t\t\t    struct pj_timer_entry *entry)\n{\n    pjsip_transport *tp = (pjsip_transport*) entry->user_data;\n    pj_assert(tp != NULL);\n\n    PJ_UNUSED_ARG(timer_heap);\n\n    if (entry->id == PJ_FALSE)\n\treturn;\n\n    entry->id = PJ_FALSE;\n\n    /* Set is_destroying flag under transport manager mutex to avoid\n     * race condition with pjsip_tpmgr_acquire_transport2().\n     */\n    pj_lock_acquire(tp->tpmgr->lock);\n    if (pj_atomic_get(tp->ref_cnt) == 0) {\n\ttp->is_destroying = PJ_TRUE;\n    } else {\n\tpj_lock_release(tp->tpmgr->lock);\n\treturn;\n    }\n    pj_lock_release(tp->tpmgr->lock);\n\n    pjsip_transport_destroy(tp);\n}\n\n\nstatic pj_bool_t is_transport_valid(pjsip_transport *tp, pjsip_tpmgr *tpmgr,\n\t\t\t\t    const pjsip_transport_key *key,\n\t\t\t\t    int key_len)\n{\n    transport *tp_entry;\n\n    tp_entry = (transport *)pj_hash_get(tpmgr->table, key, key_len, NULL);\n    if (tp_entry != NULL) {\n\n\ttransport *tp_iter = tp_entry;\n\tdo {\n\t    if (tp_iter->tp == tp) {\n\t\treturn PJ_TRUE;\n\t    }\n\t    tp_iter = tp_iter->next;\n\t} while (tp_iter != tp_entry);\n    }\n\n    return PJ_FALSE;\n}\n\n/*\n * Add ref.\n */\nPJ_DEF(pj_status_t) pjsip_transport_add_ref( pjsip_transport *tp )\n{\n    pjsip_tpmgr *tpmgr;\n    pjsip_transport_key key;\n    int key_len;\n\n    PJ_ASSERT_RETURN(tp != NULL, PJ_EINVAL);\n\n    /* Add ref transport group lock, if any */\n    if (tp->grp_lock)\n\tpj_grp_lock_add_ref(tp->grp_lock);\n\n    /* Cache some vars for checking transport validity later */\n    tpmgr = tp->tpmgr;\n    key_len = sizeof(tp->key.type) + tp->addr_len;\n    pj_memcpy(&key, &tp->key, key_len);\n\n    if (pj_atomic_inc_and_get(tp->ref_cnt) == 1) {\n\tpj_lock_acquire(tpmgr->lock);\n\t/* Verify again. But first, make sure transport is still valid\n\t * (see #1883).\n\t */\n\tif (is_transport_valid(tp, tpmgr, &key, key_len) &&\n\t    pj_atomic_get(tp->ref_cnt) == 1)\n\t{\n\t    if (tp->idle_timer.id != PJ_FALSE) {\n\t\ttp->idle_timer.id = PJ_FALSE;\n\t\tpjsip_endpt_cancel_timer(tp->tpmgr->endpt, &tp->idle_timer);\n\t    }\n\t}\n\tpj_lock_release(tpmgr->lock);\n    }\n\n    return PJ_SUCCESS;\n}\n\n/*\n * Dec ref.\n */\nPJ_DEF(pj_status_t) pjsip_transport_dec_ref( pjsip_transport *tp )\n{\n    pjsip_tpmgr *tpmgr;\n    pjsip_transport_key key;\n    int key_len;\n\n    PJ_ASSERT_RETURN(tp != NULL, PJ_EINVAL);\n    pj_assert(pj_atomic_get(tp->ref_cnt) > 0);\n\n    /* Cache some vars for checking transport validity later */\n    tpmgr = tp->tpmgr;\n    key_len = sizeof(tp->key.type) + tp->addr_len;\n    pj_memcpy(&key, &tp->key, key_len);\n\n    if (pj_atomic_dec_and_get(tp->ref_cnt) == 0) {\n\tpj_lock_acquire(tpmgr->lock);\n\t/* Verify again. Do not register timer if the transport is\n\t * being destroyed. But first, make sure transport is still valid\n\t * (see #1883).\n\t */\n\tif (is_transport_valid(tp, tpmgr, &key, key_len) &&\n\t    !tp->is_destroying && pj_atomic_get(tp->ref_cnt) == 0)\n\t{\n\t    pj_time_val delay;\n\t    \n\t    /* If transport is in graceful shutdown, then this is the\n\t     * last user who uses the transport. Schedule to destroy the\n\t     * transport immediately. Otherwise schedule idle timer.\n\t     */\n\t    if (tp->is_shutdown) {\n\t\tdelay.sec = delay.msec = 0;\n\t    } else {\n\t\tdelay.sec = (tp->dir==PJSIP_TP_DIR_OUTGOING) ?\n\t\t\t\tPJSIP_TRANSPORT_IDLE_TIME :\n\t\t\t\tPJSIP_TRANSPORT_SERVER_IDLE_TIME;\n\t\tdelay.msec = 0;\n\t    }\n\n\t    /* Avoid double timer entry scheduling */\n\t    if (pj_timer_entry_running(&tp->idle_timer))\n\t\tpjsip_endpt_cancel_timer(tp->tpmgr->endpt, &tp->idle_timer);\n\n\t    pjsip_endpt_schedule_timer_w_grp_lock(tp->tpmgr->endpt,\n\t\t\t\t\t\t  &tp->idle_timer,\n\t\t\t\t\t\t  &delay,\n\t\t\t\t\t\t  PJ_TRUE,\n\t\t\t\t\t\t  tp->grp_lock);\n\t}\n\tpj_lock_release(tpmgr->lock);\n    }\n\n    /* Dec ref transport group lock, if any */\n    if (tp->grp_lock) {\n\tpj_grp_lock_dec_ref(tp->grp_lock);\n    }\n\n    return PJ_SUCCESS;\n}\n\n\n/**\n * Register a transport.\n */\nPJ_DEF(pj_status_t) pjsip_transport_register( pjsip_tpmgr *mgr,\n\t\t\t\t\t      pjsip_transport *tp )\n{\n    int key_len;\n    pj_uint32_t hval;\n    transport *tp_ref = NULL;\n    transport *tp_add = NULL;\n\n    /* Init. */\n    tp->tpmgr = mgr;\n    pj_bzero(&tp->idle_timer, sizeof(tp->idle_timer));\n    tp->idle_timer.user_data = tp;\n    tp->idle_timer.cb = &transport_idle_callback;\n\n    /*\n     * Register to hash table (see Trac ticket #42).\n     */\n    key_len = sizeof(tp->key.type) + tp->addr_len;\n    pj_lock_acquire(mgr->lock);\n\n    hval = 0;\n    tp_ref = (transport *)pj_hash_get(mgr->table, &tp->key, key_len, &hval);\n\n    /* Get an empty entry from the freelist. */\n    if (pj_list_empty(&mgr->tp_entry_freelist)) {\n\tunsigned i = 0;\n\n\tTRACE_((THIS_FILE, \"Transport list is full, allocate new entry\"));\n\t/* Allocate new entry for the freelist. */\n\tfor (; i < PJSIP_TRANSPORT_ENTRY_ALLOC_CNT; ++i) {\n\t    tp_add = PJ_POOL_ZALLOC_T(mgr->pool, transport);\n\t    if (!tp_add)\n\t\treturn PJ_ENOMEM;\n\t    pj_list_init(tp_add);\n\t    pj_list_push_back(&mgr->tp_entry_freelist, tp_add);\n\t}\n    }\n    tp_add = mgr->tp_entry_freelist.next;\n    tp_add->tp = tp;\n    pj_list_erase(tp_add);\n\n    if (tp_ref) {\n\t/* There'a already a transport list from the hash table. Add the \n\t * new transport to the list.\n\t */\n\tpj_list_push_back(tp_ref, tp_add);\n\tTRACE_((THIS_FILE, \"Remote address already registered, \"\n\t\t\t   \"appended the transport to the list\"));\n    } else {\n\t/* Transport list not found, add it to the hash table. */\n\tpj_hash_set_np(mgr->table, &tp->key, key_len, hval, tp_add->tp_buf,\n\t\t       tp_add);\n\tTRACE_((THIS_FILE, \"Remote address not registered, \"\n\t\t\t   \"added the transport to the hash\"));\n    }\n\n    /* Add ref transport group lock, if any */\n    if (tp->grp_lock)\n\tpj_grp_lock_add_ref(tp->grp_lock);\n\n    pj_lock_release(mgr->lock);\n\n    TRACE_((THIS_FILE, \"Transport %s registered: type=%s, remote=%s:%d\",\n\t    tp->obj_name,\n\t    pjsip_transport_get_type_name(tp->key.type),\n\t    pj_sockaddr_has_addr(&tp->key.rem_addr)?\n\t\t\t\taddr_string(&tp->key.rem_addr):\"\",\n\t    pj_sockaddr_has_addr(&tp->key.rem_addr)?\n\t\t\t\tpj_sockaddr_get_port(&tp->key.rem_addr):0));\n\n    return PJ_SUCCESS;\n}\n\n/* Force destroy transport (e.g. during transport manager shutdown. */\nstatic pj_status_t destroy_transport( pjsip_tpmgr *mgr,\n\t\t\t\t      pjsip_transport *tp )\n{\n    int key_len;\n    pj_uint32_t hval;\n    void *entry;\n\n    tp->is_destroying = PJ_TRUE;\n\n    TRACE_((THIS_FILE, \"Transport %s is being destroyed\", tp->obj_name));\n\n    pj_lock_acquire(tp->lock);\n    pj_lock_acquire(mgr->lock);\n\n    /*\n     * Unregister timer, if any.\n     */\n    //pj_assert(tp->idle_timer.id == PJ_FALSE);\n    if (tp->idle_timer.id != PJ_FALSE) {\n\ttp->idle_timer.id = PJ_FALSE;\n\tpjsip_endpt_cancel_timer(mgr->endpt, &tp->idle_timer);\n    }\n\n    /*\n     * Unregister from hash table (see Trac ticket #42).\n     */\n    key_len = sizeof(tp->key.type) + tp->addr_len;\n    hval = 0;\n    entry = pj_hash_get(mgr->table, &tp->key, key_len, &hval);\n    if (entry) {\n\ttransport *tp_ref = (transport *)entry;\n\ttransport *tp_iter = tp_ref;\n\t/* Search the matching entry from the transport list. */\n\tdo {\n\t    if (tp_iter->tp == tp) {\n\t\ttransport *tp_next = tp_iter->next;\n\n\t\t/* Update hash table :\n\t\t * - transport list only contain single element, or\n\t\t * - the entry is the first element of the transport list.\n\t\t */\n\t\tif (tp_iter == tp_ref) {\n\t\t    pj_hash_set(NULL, mgr->table, &tp->key, key_len, hval,\n\t\t\t\tNULL);\n\n\t\t    if (tp_ref->next != tp_ref) {\n\t\t\t/* The transport list has multiple entry. */\n\t\t\tpj_hash_set_np(mgr->table, &tp_next->tp->key, key_len,\n\t\t\t\t       hval, tp_next->tp_buf, tp_next);\n\t\t\tTRACE_((THIS_FILE, \"Hash entry updated after \"\n\t\t\t\t\t   \"transport %d being destroyed\",\n\t\t\t\t\t   tp->obj_name));\n\t\t    } else {\n\t\t\tTRACE_((THIS_FILE, \"Hash entry deleted after \"\n\t\t\t\t\t   \"transport %d being destroyed\",\n\t\t\t\t\t   tp->obj_name));\n\t\t    }\n\t\t}\n\n\t\tpj_list_erase(tp_iter);\n\t\t/* Put back to the transport freelist. */\n\t\tpj_list_push_back(&mgr->tp_entry_freelist, tp_iter);\n\n\t\tbreak;\n\t    }\n\t    tp_iter = tp_iter->next;\n\t} while (tp_iter != tp_ref);\n\n\tif (tp_iter->tp != tp) {\n\t    PJ_LOG(3, (THIS_FILE, \"Warning: transport %s being destroyed is \"\n\t\t\t\t  \"not registered\", tp->obj_name));\n\t}\n    } else {\n\tPJ_LOG(3, (THIS_FILE, \"Warning: transport %s being destroyed is \"\n\t\t\t      \"not found in the hash table\", tp->obj_name));\n    }\n\n    pj_lock_release(mgr->lock);\n    pj_lock_release(tp->lock);\n\n    /* Dec ref transport group lock, if any */\n    if (tp->grp_lock) {\n\tpj_grp_lock_dec_ref(tp->grp_lock);\n    }\n\n    /* Destroy. */\n    return tp->destroy(tp);\n}\n\n\n/*\n * Start graceful shutdown procedure for this transport. \n */\nPJ_DEF(pj_status_t) pjsip_transport_shutdown(pjsip_transport *tp)\n{\n    return pjsip_transport_shutdown2(tp, PJ_FALSE);\n}\n\n\n/*\n * Start shutdown procedure for this transport. \n */\nPJ_DEF(pj_status_t) pjsip_transport_shutdown2(pjsip_transport *tp,\n\t\t\t\t\t      pj_bool_t force)\n{\n    pjsip_tpmgr *mgr;\n    pj_status_t status;\n    pjsip_tp_state_callback state_cb;\n\n    PJ_LOG(4, (THIS_FILE, \"Transport %s shutting down, force=%d\",\n\t\t\t  tp->obj_name, force));\n\n    pj_lock_acquire(tp->lock);\n\n    mgr = tp->tpmgr;\n    pj_lock_acquire(mgr->lock);\n\n    /* Do nothing if transport is being shutdown/destroyed already */\n    if (tp->is_shutdown || tp->is_destroying) {\n\tpj_lock_release(mgr->lock);\n\tpj_lock_release(tp->lock);\n\treturn PJ_SUCCESS;\n    }\n\n    status = PJ_SUCCESS;\n\n    /* Instruct transport to shutdown itself */\n    if (tp->do_shutdown)\n\tstatus = tp->do_shutdown(tp);\n\n    if (status == PJ_SUCCESS)\n\ttp->is_shutdown = PJ_TRUE;\n\n    /* Notify application of transport shutdown */\n    state_cb = pjsip_tpmgr_get_state_cb(tp->tpmgr);\n    if (state_cb) {\n\tpjsip_transport_state_info state_info;\n\n\tpj_bzero(&state_info, sizeof(state_info));\n\tstate_info.status = PJ_ECANCELLED;\n\t(*state_cb)(tp, (force? PJSIP_TP_STATE_DISCONNECTED:\n\t\t    PJSIP_TP_STATE_SHUTDOWN), &state_info);\n    }\n\n    /* If transport reference count is zero, start timer count-down */\n    if (pj_atomic_get(tp->ref_cnt) == 0) {\n\tpjsip_transport_add_ref(tp);\n\tpjsip_transport_dec_ref(tp);\n    }\n\n    pj_lock_release(mgr->lock);\n    pj_lock_release(tp->lock);\n\n    return status;\n}\n\n\n/**\n * Unregister transport.\n */\nPJ_DEF(pj_status_t) pjsip_transport_destroy( pjsip_transport *tp)\n{\n    pjsip_tp_state_callback state_cb;\n\n    /* Must have no user. */\n    PJ_ASSERT_RETURN(pj_atomic_get(tp->ref_cnt) == 0, PJSIP_EBUSY);\n\n    /* Notify application of transport destroy */\n    state_cb = pjsip_tpmgr_get_state_cb(tp->tpmgr);\n    if (state_cb) {\n\tpjsip_transport_state_info state_info;\n\n\tpj_bzero(&state_info, sizeof(state_info));\n        (*state_cb)(tp, PJSIP_TP_STATE_DESTROY, &state_info);\n    }\n\n    /* Destroy. */\n    return destroy_transport(tp->tpmgr, tp);\n}\n\n\n\n/*****************************************************************************\n *\n * TRANSPORT FACTORY\n *\n *****************************************************************************/\n\n\nPJ_DEF(pj_status_t) pjsip_tpmgr_register_tpfactory( pjsip_tpmgr *mgr,\n\t\t\t\t\t\t    pjsip_tpfactory *tpf)\n{\n    pjsip_tpfactory *p;\n    pj_status_t status;\n\n    pj_lock_acquire(mgr->lock);\n\n    /* Check that no same factory has been registered. */\n    status = PJ_SUCCESS;\n    for (p=mgr->factory_list.next; p!=&mgr->factory_list; p=p->next) {\n\tif (p == tpf) {\n\t    status = PJ_EEXISTS;\n\t    break;\n\t}\n    }\n\n    if (status != PJ_SUCCESS) {\n\tpj_lock_release(mgr->lock);\n\treturn status;\n    }\n\n    pj_list_insert_before(&mgr->factory_list, tpf);\n\n    pj_lock_release(mgr->lock);\n\n    return PJ_SUCCESS;\n}\n\n\n/**\n * Unregister factory.\n */\nPJ_DEF(pj_status_t) pjsip_tpmgr_unregister_tpfactory( pjsip_tpmgr *mgr,\n\t\t\t\t\t\t      pjsip_tpfactory *tpf)\n{\n    pj_lock_acquire(mgr->lock);\n\n    pj_assert(pj_list_find_node(&mgr->factory_list, tpf) == tpf);\n    pj_list_erase(tpf);\n\n    pj_lock_release(mgr->lock);\n\n    return PJ_SUCCESS;\n}\n\nPJ_DECL(void) pjsip_tpmgr_fla2_param_default(pjsip_tpmgr_fla2_param *prm)\n{\n    pj_bzero(prm, sizeof(*prm));\n}\n\nstatic pj_bool_t pjsip_tpmgr_is_tpfactory_valid(pjsip_tpmgr *mgr,\n\t\t\t\t\t\tpjsip_tpfactory *tpf)\n{\n    pjsip_tpfactory *p;\n\n    pj_lock_acquire(mgr->lock);\n    for (p=mgr->factory_list.next; p!=&mgr->factory_list; p=p->next) {\n\tif (p == tpf) {\n\t    pj_lock_release(mgr->lock);\n\t    return PJ_TRUE;\n\t}\n    }\n    pj_lock_release(mgr->lock);\n\n    return PJ_FALSE;\n}\n\n/*****************************************************************************\n *\n * TRANSPORT MANAGER\n *\n *****************************************************************************/\n\n/*\n * Create a new transport manager.\n */\nPJ_DEF(pj_status_t) pjsip_tpmgr_create( pj_pool_t *pool,\n\t\t\t\t\tpjsip_endpoint *endpt,\n\t\t\t\t\tpjsip_rx_callback rx_cb,\n\t\t\t\t\tpjsip_tx_callback tx_cb,\n\t\t\t\t\tpjsip_tpmgr **p_mgr)\n{\n    pjsip_tpmgr *mgr;\n    pj_status_t status;\n    unsigned i = 0;\n    pj_pool_t *mgr_pool;\n\n    PJ_ASSERT_RETURN(pool && endpt && rx_cb && p_mgr, PJ_EINVAL);\n\n    /* Register mod_msg_print module. */\n    status = pjsip_endpt_register_module(endpt, &mod_msg_print);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Create and initialize transport manager. */\n    mgr_pool = pjsip_endpt_create_pool(endpt, \"tpmgr\",\n\t\t\t\t       TPMGR_POOL_INIT_SIZE,\n\t\t\t\t       TPMGR_POOL_INC_SIZE);\n    mgr = PJ_POOL_ZALLOC_T(mgr_pool, pjsip_tpmgr);\n    mgr->endpt = endpt;\n    mgr->on_rx_msg = rx_cb;\n    mgr->on_tx_msg = tx_cb;\n    mgr->pool = mgr_pool;\n\n    if (!mgr->pool)\n\treturn PJ_ENOMEM;\n\n    pj_list_init(&mgr->factory_list);\n    pj_list_init(&mgr->tdata_list);\n    pj_list_init(&mgr->tp_entry_freelist);\n\n    mgr->table = pj_hash_create(mgr->pool, PJSIP_TPMGR_HTABLE_SIZE);\n    if (!mgr->table)\n\treturn PJ_ENOMEM;\n\n    status = pj_lock_create_recursive_mutex(mgr->pool, \"tmgr%p\", &mgr->lock);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    for (; i < PJSIP_TRANSPORT_ENTRY_ALLOC_CNT; ++i) {\n\ttransport *tp_add = NULL;\n\n\ttp_add = PJ_POOL_ZALLOC_T(mgr->pool, transport);\n\tif (!tp_add)\n\t    return PJ_ENOMEM;\n\tpj_list_init(tp_add);\n\tpj_list_push_back(&mgr->tp_entry_freelist, tp_add);\n    }\n\n#if defined(PJ_DEBUG) && PJ_DEBUG!=0\n    status = pj_atomic_create(mgr->pool, 0, &mgr->tdata_counter);\n    if (status != PJ_SUCCESS) {\n    \tpj_lock_destroy(mgr->lock);\n    \treturn status;\n    }\n#endif\n\n    /* Set transport state callback */\n    pjsip_tpmgr_set_state_cb(mgr, &tp_state_callback);\n\n    PJ_LOG(5, (THIS_FILE, \"Transport manager created.\"));\n\n    *p_mgr = mgr;\n    return PJ_SUCCESS;\n}\n\n/* Get the interface to send packet to the specified address */\nstatic pj_status_t get_net_interface(pjsip_transport_type_e tp_type,\n\t\t\t\t     const pj_str_t *dst,\n                                     pj_str_t *itf_str_addr)\n{\n    int af;\n    pj_sockaddr itf_addr;\n    pj_status_t status = -1;\n\n    af = (tp_type & PJSIP_TRANSPORT_IPV6)? pj_AF_INET6() : pj_AF_INET();\n\n    if (pjsip_cfg()->endpt.resolve_hostname_to_get_interface) {\n\tstatus = pj_getipinterface(af, dst, &itf_addr, PJ_TRUE, NULL);\n    }\n\n    if (status != PJ_SUCCESS) { \n\tstatus = pj_getipinterface(af, dst, &itf_addr, PJ_FALSE, NULL);\n\tif (status != PJ_SUCCESS) {\n\t    /* If it fails, e.g: on WM6(http://support.microsoft.com/kb/129065),\n\t     * just fallback using pj_gethostip(), see ticket #1660.\n\t     */\n\t    PJ_PERROR(5,(THIS_FILE, status,\n\t\t\t \"Warning: unable to determine local interface, \"\n\t\t\t \"fallback to default interface!\"));\n\t    status = pj_gethostip(af, &itf_addr);\n\t    if (status != PJ_SUCCESS)\n\t\treturn status;\n\t}\n    }\n\n    /* Print address */\n    pj_sockaddr_print(&itf_addr, itf_str_addr->ptr,\n\t\t      PJ_INET6_ADDRSTRLEN, 0);\n    itf_str_addr->slen = pj_ansi_strlen(itf_str_addr->ptr);\n\n    return PJ_SUCCESS;\n}\n\n/*\n * Find out the appropriate local address info (IP address and port) to\n * advertise in Contact header based on the remote address to be \n * contacted. The local address info would be the address name of the\n * transport or listener which will be used to send the request.\n *\n * In this implementation, it will only select the transport based on\n * the transport type in the request.\n */\nPJ_DEF(pj_status_t) pjsip_tpmgr_find_local_addr2(pjsip_tpmgr *tpmgr,\n\t\t\t\t\t\t pj_pool_t *pool,\n\t\t\t\t\t\t pjsip_tpmgr_fla2_param *prm)\n{\n    char tmp_buf[PJ_INET6_ADDRSTRLEN+10];\n    pj_str_t tmp_str;\n    pj_status_t status = PJSIP_EUNSUPTRANSPORT;\n    unsigned flag;\n\n    /* Sanity checks */\n    PJ_ASSERT_RETURN(tpmgr && pool && prm, PJ_EINVAL);\n\n    pj_strset(&tmp_str, tmp_buf, 0);\n    prm->ret_addr.slen = 0;\n    prm->ret_port = 0;\n    prm->ret_tp = NULL;\n\n    flag = pjsip_transport_get_flag_from_type(prm->tp_type);\n\n    if (prm->tp_sel && prm->tp_sel->type == PJSIP_TPSELECTOR_TRANSPORT &&\n\tprm->tp_sel->u.transport)\n    {\n\tconst pjsip_transport *tp = prm->tp_sel->u.transport;\n\tif (prm->local_if) {\n\t    status = get_net_interface((pjsip_transport_type_e)tp->key.type,\n\t\t\t\t       &prm->dst_host, &tmp_str);\n\t    if (status != PJ_SUCCESS)\n\t\tgoto on_return;\n\t    pj_strdup(pool, &prm->ret_addr, &tmp_str);\n\t    prm->ret_port = pj_sockaddr_get_port(&tp->local_addr);\n\t    prm->ret_tp = tp;\n\t} else {\n\t    pj_strdup(pool, &prm->ret_addr, &tp->local_name.host);\n\t    prm->ret_port = (pj_uint16_t)tp->local_name.port;\n\t}\n\tstatus = PJ_SUCCESS;\n\n    } else if (prm->tp_sel && prm->tp_sel->type == PJSIP_TPSELECTOR_LISTENER &&\n\t       prm->tp_sel->u.listener)\n    {\n\tif (prm->local_if) {\n\t    status = get_net_interface(prm->tp_sel->u.listener->type,\n\t                               &prm->dst_host, &tmp_str);\n\t    if (status != PJ_SUCCESS)\n\t\tgoto on_return;\n\t    pj_strdup(pool, &prm->ret_addr, &tmp_str);\n\t} else {\n\t    pj_strdup(pool, &prm->ret_addr,\n\t\t      &prm->tp_sel->u.listener->addr_name.host);\n\t}\n\tprm->ret_port = (pj_uint16_t)prm->tp_sel->u.listener->addr_name.port;\n\tstatus = PJ_SUCCESS;\n\n    } else if ((flag & PJSIP_TRANSPORT_DATAGRAM) != 0) {\n\tpj_sockaddr remote;\n\tint addr_len;\n\tpjsip_transport *tp;\n\n\tpj_bzero(&remote, sizeof(remote));\n\tif (prm->tp_type & PJSIP_TRANSPORT_IPV6) {\n\t    addr_len = sizeof(pj_sockaddr_in6);\n\t    remote.addr.sa_family = pj_AF_INET6();\n\t} else {\n\t    addr_len = sizeof(pj_sockaddr_in);\n\t    remote.addr.sa_family = pj_AF_INET();\n\t}\n\n\tstatus = pjsip_tpmgr_acquire_transport(tpmgr, prm->tp_type, &remote,\n\t\t\t\t\t       addr_len, NULL, &tp);\n\n\tif (status == PJ_SUCCESS) {\n\t    if (prm->local_if) {\n\t\tstatus = get_net_interface((pjsip_transport_type_e)\n\t\t\t\t\t   tp->key.type,\n\t\t\t\t\t   &prm->dst_host, &tmp_str);\n\t\tif (status != PJ_SUCCESS)\n\t\t    goto on_return;\n\t\tpj_strdup(pool, &prm->ret_addr, &tmp_str);\n\t\tprm->ret_port = pj_sockaddr_get_port(&tp->local_addr);\n\t\tprm->ret_tp = tp;\n\t    } else {\n\t\tpj_strdup(pool, &prm->ret_addr, &tp->local_name.host);\n\t\tprm->ret_port = (pj_uint16_t)tp->local_name.port;\n\t    }\n\n\t    pjsip_transport_dec_ref(tp);\n\t}\n\n    } else {\n\t/* For connection oriented transport, enum the factories */\n\tpjsip_tpfactory *f;\n\n\tpj_lock_acquire(tpmgr->lock);\n\n\tf = tpmgr->factory_list.next;\n\twhile (f != &tpmgr->factory_list) {\n\t    if (f->type == prm->tp_type)\n\t\tbreak;\n\t    f = f->next;\n\t}\n\n\tif (f != &tpmgr->factory_list) {\n\t    if (prm->local_if) {\n\t\tstatus = get_net_interface(f->type, &prm->dst_host,\n\t\t\t\t\t   &tmp_str);\n\t\tif (status == PJ_SUCCESS) {\n\t\t    pj_strdup(pool, &prm->ret_addr, &tmp_str);\n\t\t} else {\n\t\t    /* It could fail \"normally\" on certain cases, e.g.\n\t\t     * when connecting to IPv6 link local address, it\n\t\t     * will wail with EINVAL.\n\t\t     * In this case, fallback to use the default interface\n\t\t     * rather than failing the call.\n\t\t     */\n\t\t    PJ_PERROR(5,(THIS_FILE, status, \"Warning: unable to \"\n\t\t\t         \"determine local interface\"));\n\t\t    pj_strdup(pool, &prm->ret_addr, &f->addr_name.host);\n\t\t    status = PJ_SUCCESS;\n\t\t}\n\t    } else {\n\t\tpj_strdup(pool, &prm->ret_addr, &f->addr_name.host);\n\t    }\n\t    prm->ret_port = (pj_uint16_t)f->addr_name.port;\n\t    status = PJ_SUCCESS;\n\t}\n\tpj_lock_release(tpmgr->lock);\n    }\n\non_return:\n    return status;\n}\n\nPJ_DEF(pj_status_t) pjsip_tpmgr_find_local_addr( pjsip_tpmgr *tpmgr,\n\t\t\t\t\t\t pj_pool_t *pool,\n\t\t\t\t\t\t pjsip_transport_type_e type,\n\t\t\t\t\t\t const pjsip_tpselector *sel,\n\t\t\t\t\t\t pj_str_t *ip_addr,\n\t\t\t\t\t\t int *port)\n{\n    pjsip_tpmgr_fla2_param prm;\n    pj_status_t status;\n\n    pjsip_tpmgr_fla2_param_default(&prm);\n    prm.tp_type = type;\n    prm.tp_sel = sel;\n\n    status = pjsip_tpmgr_find_local_addr2(tpmgr, pool, &prm);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    *ip_addr = prm.ret_addr;\n    *port = prm.ret_port;\n\n    return PJ_SUCCESS;\n}\n\n/*\n * Return number of transports currently registered to the transport\n * manager.\n */\nPJ_DEF(unsigned) pjsip_tpmgr_get_transport_count(pjsip_tpmgr *mgr)\n{\n    pj_hash_iterator_t itr_val;\n    pj_hash_iterator_t *itr;\n    int nr_of_transports = 0;\n\n    pj_lock_acquire(mgr->lock);\n\n    itr = pj_hash_first(mgr->table, &itr_val);\n    while (itr) {\n\ttransport *tp_entry = (transport *)pj_hash_this(mgr->table, itr);\n\tnr_of_transports += pj_list_size(tp_entry);\n\titr = pj_hash_next(mgr->table, itr);\n    }\n\n    pj_lock_release(mgr->lock);\n\n    return nr_of_transports;\n}\n\n/*\n * pjsip_tpmgr_destroy()\n *\n * Destroy transport manager.\n */\nPJ_DEF(pj_status_t) pjsip_tpmgr_destroy( pjsip_tpmgr *mgr )\n{\n    pj_hash_iterator_t itr_val;\n    pj_hash_iterator_t *itr;\n    pjsip_tpfactory *factory;\n    pjsip_endpoint *endpt = mgr->endpt;\n\n    PJ_LOG(5, (THIS_FILE, \"Destroying transport manager\"));\n\n    pj_lock_acquire(mgr->lock);\n\n    /*\n     * Destroy all transports in the hash table.\n     */\n    for (itr = pj_hash_first(mgr->table, &itr_val); itr;\n\t itr = pj_hash_first(mgr->table, &itr_val))\n    {\n\ttransport *tp_ref;\n\ttp_ref = pj_hash_this(mgr->table, itr);\n\tdestroy_transport(mgr, tp_ref->tp);\n    }\n\n    /*\n     * Destroy all factories/listeners.\n     */\n    factory = mgr->factory_list.next;\n    while (factory != &mgr->factory_list) {\n\tpjsip_tpfactory *next = factory->next;\n\n\tfactory->destroy(factory);\n\n\tfactory = next;\n    }\n\n    pj_lock_release(mgr->lock);\n\n#if defined(PJ_DEBUG) && PJ_DEBUG!=0\n    /* If you encounter assert error on this line, it means there are\n     * leakings in transmit data (i.e. some transmit data have not been\n     * destroyed).\n     */\n    //pj_assert(pj_atomic_get(mgr->tdata_counter) == 0);\n    if (pj_atomic_get(mgr->tdata_counter) != 0) {\n\tPJ_LOG(3,(THIS_FILE, \"Warning: %d transmit buffer(s) not freed!\",\n\t\t  pj_atomic_get(mgr->tdata_counter)));\n    }\n#endif\n\n    /*\n     * Destroy any dangling transmit buffer.\n     */\n    if (!pj_list_empty(&mgr->tdata_list)) {\n\tpjsip_tx_data *tdata = mgr->tdata_list.next;\n\twhile (tdata != &mgr->tdata_list) {\n\t    pjsip_tx_data *next = tdata->next;\n\t    tx_data_destroy(tdata);\n\t    tdata = next;\n\t}\n\tPJ_LOG(3,(THIS_FILE, \"Cleaned up dangling transmit buffer(s).\"));\n    }\n\n#if defined(PJ_DEBUG) && PJ_DEBUG!=0\n    pj_atomic_destroy(mgr->tdata_counter);\n#endif\n\n    pj_lock_destroy(mgr->lock);\n\n    /* Unregister mod_msg_print. */\n    if (mod_msg_print.id != -1) {\n\tpjsip_endpt_unregister_module(endpt, &mod_msg_print);\n    }\n\n    if (mgr->pool) {\n\tpjsip_endpt_release_pool( mgr->endpt, mgr->pool );\n    }\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * pjsip_tpmgr_receive_packet()\n *\n * Called by tranports when they receive a new packet.\n */\nPJ_DEF(pj_ssize_t) pjsip_tpmgr_receive_packet( pjsip_tpmgr *mgr,\n\t\t\t\t\t       pjsip_rx_data *rdata)\n{\n    pjsip_transport *tr = rdata->tp_info.transport;\n\n    char *current_pkt;\n    pj_size_t remaining_len;\n    pj_size_t total_processed = 0;\n\n    /* Check size. */\n    pj_assert(rdata->pkt_info.len > 0);\n    if (rdata->pkt_info.len <= 0)\n\treturn -1;\n\n    current_pkt = rdata->pkt_info.packet;\n    remaining_len = rdata->pkt_info.len;\n\n    tr->last_recv_len = rdata->pkt_info.len;\n    pj_get_timestamp(&tr->last_recv_ts);\n    \n    /* Must NULL terminate buffer. This is the requirement of the \n     * parser etc. \n     */\n    current_pkt[remaining_len] = '\\0';\n\n    /* Process all message fragments. */\n    while (remaining_len > 0) {\n\n\tpjsip_msg *msg;\n\tchar *p, *end;\n\tchar saved;\n\tpj_size_t msg_fragment_size;\n\n\t/* Skip leading newlines as pjsip_find_msg() currently can't\n\t * handle leading newlines.\n\t */\n\tfor (p=current_pkt, end=p+remaining_len; p!=end; ++p) {\n\t    if (*p != '\\r' && *p != '\\n')\n\t\tbreak;\n\t}\n\tif (p!=current_pkt) {\n\t    remaining_len -= (p - current_pkt);\n\t    total_processed += (p - current_pkt);\n\n\t    /* Notify application about the dropped newlines */\n\t    if (mgr->tp_drop_data_cb) {\n\t\tpjsip_tp_dropped_data dd;\n\t\tpj_bzero(&dd, sizeof(dd));\n\t\tdd.tp = tr;\n\t\tdd.data = current_pkt;\n\t\tdd.len = p - current_pkt;\n\t\tdd.status = PJ_EIGNORED;\n\t\t(*mgr->tp_drop_data_cb)(&dd);\n\t    }\n\n\t    current_pkt = p;\n\t    if (remaining_len == 0) {\n\t\treturn total_processed;\n\t    }\n\t}\n\n\t/* Initialize default fragment size. */\n\tmsg_fragment_size = remaining_len;\n\n\t/* Clear and init msg_info in rdata. \n\t * Endpoint might inspect the values there when we call the callback\n\t * to report some errors.\n\t */\n\tpj_bzero(&rdata->msg_info, sizeof(rdata->msg_info));\n\tpj_list_init(&rdata->msg_info.parse_err);\n\trdata->msg_info.msg_buf = current_pkt;\n\trdata->msg_info.len = (int)remaining_len;\n\n\t/* For TCP transport, check if the whole message has been received. */\n\tif ((tr->flag & PJSIP_TRANSPORT_DATAGRAM) == 0) {\n\t    pj_status_t msg_status;\n\t    msg_status = pjsip_find_msg(current_pkt, remaining_len, PJ_FALSE, \n                                        &msg_fragment_size);\n\t    if (msg_status != PJ_SUCCESS) {\n\t\tif (remaining_len == PJSIP_MAX_PKT_LEN) {\n\t\t    mgr->on_rx_msg(mgr->endpt, PJSIP_ERXOVERFLOW, rdata);\n\t\t    \n\t\t    /* Notify application about the message overflow */\n\t    \t    if (mgr->tp_drop_data_cb) {\n\t\t\tpjsip_tp_dropped_data dd;\n\t\t\tpj_bzero(&dd, sizeof(dd));\n\t\t\tdd.tp = tr;\n\t\t\tdd.data = current_pkt;\n\t\t\tdd.len = msg_fragment_size;\n\t\t\tdd.status = PJSIP_ERXOVERFLOW;\n\t\t\t(*mgr->tp_drop_data_cb)(&dd);\n\t    \t    }\n\t\t    \n\t\t    /* Exhaust all data. */\n\t\t    return rdata->pkt_info.len;\n\t\t} else {\n\t\t    /* Not enough data in packet. */\n\t\t    return total_processed;\n\t\t}\n\t    }\n\t}\n\n\t/* Update msg_info. */\n\trdata->msg_info.len = (int)msg_fragment_size;\n\n\t/* Null terminate packet */\n\tsaved = current_pkt[msg_fragment_size];\n\tcurrent_pkt[msg_fragment_size] = '\\0';\n\n\t/* Parse the message. */\n\trdata->msg_info.msg = msg = \n\t    pjsip_parse_rdata( current_pkt, msg_fragment_size, rdata);\n\n\t/* Restore null termination */\n\tcurrent_pkt[msg_fragment_size] = saved;\n\n\t/* Check for parsing syntax error */\n\tif (msg==NULL || !pj_list_empty(&rdata->msg_info.parse_err)) {\n\t    pjsip_parser_err_report *err;\n\t    char buf[256];\n\t    pj_str_t tmp;\n\n\t    /* Gather syntax error information */\n\t    tmp.ptr = buf; tmp.slen = 0;\n\t    err = rdata->msg_info.parse_err.next;\n\t    while (err != &rdata->msg_info.parse_err) {\n\t\tint len;\n\t\tlen = pj_ansi_snprintf(tmp.ptr+tmp.slen, sizeof(buf)-tmp.slen,\n\t\t\t\t       \": %s exception when parsing '%.*s' \"\n\t\t\t\t       \"header on line %d col %d\",\n\t\t\t\t       pj_exception_id_name(err->except_code),\n\t\t\t\t       (int)err->hname.slen, err->hname.ptr,\n\t\t\t\t       err->line, err->col);\n\t\tif (len >= (int)sizeof(buf)-tmp.slen) {\n\t\t    len = (int)sizeof(buf)-tmp.slen;\n\t\t}\n\t\tif (len > 0) {\n\t\t    tmp.slen += len;\n\t\t}\n\t\terr = err->next;\n\t    }\n\n\t    /* Only print error message if there's error.\n\t     * Sometimes we receive blank packets (packets with only CRLF)\n\t     * which were sent to keep NAT bindings.\n\t     */\n\t    if (tmp.slen) {\n\t\tPJ_LOG(1, (THIS_FILE, \n\t\t      \"Error processing %d bytes packet from %s %s:%d %.*s:\\n\"\n\t\t      \"%.*s\\n\"\n\t\t      \"-- end of packet.\",\n\t\t      msg_fragment_size,\n\t\t      rdata->tp_info.transport->type_name,\n\t\t      rdata->pkt_info.src_name, \n\t\t      rdata->pkt_info.src_port,\n\t\t      (int)tmp.slen, tmp.ptr,\n\t\t      (int)msg_fragment_size,\n\t\t      rdata->msg_info.msg_buf));\n\t    }\n\n\t    /* Notify application about the dropped data (syntax error) */\n\t    if (tmp.slen && mgr->tp_drop_data_cb) {\n\t\tpjsip_tp_dropped_data dd;\n\t\tpj_bzero(&dd, sizeof(dd));\n\t\tdd.tp = tr;\n\t\tdd.data = current_pkt;\n\t\tdd.len = msg_fragment_size;\n\t\tdd.status = PJSIP_EINVALIDMSG;\n\t\t(*mgr->tp_drop_data_cb)(&dd);\n\t\t\n\t\tif (dd.len > 0 && dd.len < msg_fragment_size)\n\t\t    msg_fragment_size = dd.len;\n\t    }\n\n\t    goto finish_process_fragment;\n\t}\n\n\t/* Perform basic header checking. */\n\tif (rdata->msg_info.cid == NULL ||\n\t    rdata->msg_info.cid->id.slen == 0 || \n\t    rdata->msg_info.from == NULL || \n\t    rdata->msg_info.to == NULL || \n\t    rdata->msg_info.via == NULL || \n\t    rdata->msg_info.cseq == NULL) \n\t{\n\t    mgr->on_rx_msg(mgr->endpt, PJSIP_EMISSINGHDR, rdata);\n\n\t    /* Notify application about the missing header. */\n\t    if (mgr->tp_drop_data_cb) {\n\t\tpjsip_tp_dropped_data dd;\n\t\tpj_bzero(&dd, sizeof(dd));\n\t\tdd.tp = tr;\n\t\tdd.data = current_pkt;\n\t\tdd.len = msg_fragment_size;\n\t\tdd.status = PJSIP_EMISSINGHDR;\n\t\t(*mgr->tp_drop_data_cb)(&dd);\t    \n\t    }\n\t    goto finish_process_fragment;\n\t}\n\n\t/* For request: */\n\tif (rdata->msg_info.msg->type == PJSIP_REQUEST_MSG) {\n\t    /* always add received parameter to the via. */\n\t    pj_strdup2(rdata->tp_info.pool, \n\t\t       &rdata->msg_info.via->recvd_param, \n\t\t       rdata->pkt_info.src_name);\n\n\t    /* RFC 3581:\n\t     * If message contains \"rport\" param, put the received port there.\n\t     */\n\t    if (rdata->msg_info.via->rport_param == 0) {\n\t\trdata->msg_info.via->rport_param = rdata->pkt_info.src_port;\n\t    }\n\t} else {\n\t    /* Drop malformed responses */\n\t    if (rdata->msg_info.msg->line.status.code < 100 ||\n\t\trdata->msg_info.msg->line.status.code >= 700)\n\t    {\n\t\tmgr->on_rx_msg(mgr->endpt, PJSIP_EINVALIDSTATUS, rdata);\n\n\t\t/* Notify application about the invalid status. */\n\t\tif (mgr->tp_drop_data_cb) {\n\t\t    pjsip_tp_dropped_data dd;\n\t\t    pj_bzero(&dd, sizeof(dd));\n\t\t    dd.tp = tr;\n\t\t    dd.data = current_pkt;\n\t\t    dd.len = msg_fragment_size;\n\t\t    dd.status = PJSIP_EINVALIDSTATUS;\n\t\t    (*mgr->tp_drop_data_cb)(&dd);\t    \n\t\t}\n\t\tgoto finish_process_fragment;\n\t    }\n\t}\n\n\t/* Drop response message if it has more than one Via.\n\t*/\n\t/* This is wrong. Proxy DOES receive responses with multiple\n\t * Via headers! Thanks Aldo <acampi at deis.unibo.it> for pointing\n\t * this out.\n\n\tif (msg->type == PJSIP_RESPONSE_MSG) {\n\t    pjsip_hdr *hdr;\n\t    hdr = (pjsip_hdr*)rdata->msg_info.via->next;\n\t    if (hdr != &msg->hdr) {\n\t\thdr = pjsip_msg_find_hdr(msg, PJSIP_H_VIA, hdr);\n\t\tif (hdr) {\n\t\t    mgr->on_rx_msg(mgr->endpt, PJSIP_EMULTIPLEVIA, rdata);\n\t\t    goto finish_process_fragment;\n\t\t}\n\t    }\n\t}\n\t*/\n\n\t/* Call the transport manager's upstream message callback.\n\t */\n\tmgr->on_rx_msg(mgr->endpt, PJ_SUCCESS, rdata);\n\n\nfinish_process_fragment:\n\ttotal_processed += msg_fragment_size;\n\tcurrent_pkt += msg_fragment_size;\n\tremaining_len -= msg_fragment_size;\n\n    }\t/* while (rdata->pkt_info.len > 0) */\n\n\n    return total_processed;\n}\n\n\n/*\n * pjsip_tpmgr_acquire_transport()\n *\n * Get transport suitable to communicate to remote. Create a new one\n * if necessary.\n */\nPJ_DEF(pj_status_t) pjsip_tpmgr_acquire_transport(pjsip_tpmgr *mgr,\n\t\t\t\t\t\t  pjsip_transport_type_e type,\n\t\t\t\t\t\t  const pj_sockaddr_t *remote,\n\t\t\t\t\t\t  int addr_len,\n\t\t\t\t\t\t  const pjsip_tpselector *sel,\n\t\t\t\t\t\t  pjsip_transport **tp)\n{\n    return pjsip_tpmgr_acquire_transport2(mgr, type, remote, addr_len, sel,\n\t\t\t\t\t  NULL, tp);\n}\n\n\n/*\n * pjsip_tpmgr_acquire_transport2()\n *\n * Get transport suitable to communicate to remote. Create a new one\n * if necessary.\n */\nPJ_DEF(pj_status_t) pjsip_tpmgr_acquire_transport2(pjsip_tpmgr *mgr,\n\t\t\t\t\t\t   pjsip_transport_type_e type,\n\t\t\t\t\t\t   const pj_sockaddr_t *remote,\n\t\t\t\t\t\t   int addr_len,\n\t\t\t\t\t\t   const pjsip_tpselector *sel,\n\t\t\t\t\t\t   pjsip_tx_data *tdata,\n\t\t\t\t\t\t   pjsip_transport **tp)\n{\n    pjsip_tpfactory *factory;\n    pj_status_t status;\n\n    TRACE_((THIS_FILE,\"Acquiring transport type=%s, sel=%s remote=%s:%d\",\n\t\t       pjsip_transport_get_type_name(type),\n\t\t       print_tpsel_info(sel),\n\t\t       addr_string(remote),\n\t\t       pj_sockaddr_get_port(remote)));\n\n    pj_lock_acquire(mgr->lock);\n\n    /* If transport is specified, then just use it if it is suitable\n     * for the destination.\n     */\n    if (sel && sel->type == PJSIP_TPSELECTOR_TRANSPORT &&\n\tsel->u.transport) \n    {\n\tpjsip_transport *seltp = sel->u.transport;\n\n\t/* See if the transport is (not) suitable */\n\tif (seltp->key.type != type) {\n\t    pj_lock_release(mgr->lock);\n\t    TRACE_((THIS_FILE, \"Transport type in tpsel not matched\"));\n\t    return PJSIP_ETPNOTSUITABLE;\n\t}\n\n\t/* Make sure the transport is not being destroyed */\n\tif (seltp->is_destroying) {\n\t    pj_lock_release(mgr->lock);\n\t    TRACE_((THIS_FILE,\"Transport to be acquired is being destroyed\"));\n\t    return PJ_ENOTFOUND;\n\t}\n\n\t/* We could also verify that the destination address is reachable\n\t * from this transport (i.e. both are equal), but if application\n\t * has requested a specific transport to be used, assume that\n\t * it knows what to do.\n\t *\n\t * In other words, I don't think destination verification is a good\n\t * idea for now.\n\t */\n\n\t/* Transport looks to be suitable to use, so just use it. */\n\tpjsip_transport_add_ref(seltp);\n\tpj_lock_release(mgr->lock);\n\t*tp = seltp;\n\n\tTRACE_((THIS_FILE, \"Transport %s acquired\", seltp->obj_name));\n\treturn PJ_SUCCESS;\n\n    } else {\n\n\t/*\n\t * This is the \"normal\" flow, where application doesn't specify\n\t * specific transport to be used to send message to.\n\t * In this case, lookup the transport from the hash table.\n\t */\n\tpjsip_transport_key key;\n\tint key_len;\n\tpjsip_transport *tp_ref = NULL;\n\ttransport *tp_entry = NULL;\n\n\n\t/* If listener is specified, verify that the listener type matches\n\t * the destination type.\n\t */\n\tif (sel && sel->type == PJSIP_TPSELECTOR_LISTENER && sel->u.listener)\n\t{\n\t    if (sel->u.listener->type != type) {\n\t\tpj_lock_release(mgr->lock);\n\t\tTRACE_((THIS_FILE, \"Listener type in tpsel not matched\"));\n\t\treturn PJSIP_ETPNOTSUITABLE;\n\t    }\n\t}\n\n\tif (!sel || sel->disable_connection_reuse == PJ_FALSE) {\n\t    pj_bzero(&key, sizeof(key));\n\t    key_len = sizeof(key.type) + addr_len;\n\n\t    /* First try to get exact destination. */\n\t    key.type = type;\n\t    pj_memcpy(&key.rem_addr, remote, addr_len);\n\n\t    tp_entry = (transport *)pj_hash_get(mgr->table, &key, key_len,\n\t\t\t\t\t\tNULL);\n\t    if (tp_entry) {\n\t\ttransport *tp_iter = tp_entry;\n\t\tdo {\n\t\t    /* Don't use transport being shutdown/destroyed */\n\t\t    if (!tp_iter->tp->is_shutdown &&\n\t\t\t!tp_iter->tp->is_destroying)\n\t\t    {\n\t\t\tif (sel && sel->type == PJSIP_TPSELECTOR_LISTENER &&\n\t\t\t    sel->u.listener)\n\t\t\t{\n\t\t\t    /* Match listener if selector is set */\n\t\t\t    if (tp_iter->tp->factory == sel->u.listener) {\n\t\t\t\ttp_ref = tp_iter->tp;\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t} else {\n\t\t\t    tp_ref = tp_iter->tp;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t    tp_iter = tp_iter->next;\n\t\t} while (tp_iter != tp_entry);\n\t    }\n\t}\n\n\tif (tp_ref == NULL &&\n\t    (!sel || sel->disable_connection_reuse == PJ_FALSE))\n\t{\n\t    unsigned flag = pjsip_transport_get_flag_from_type(type);\n\t    const pj_sockaddr *remote_addr = (const pj_sockaddr*)remote;\n\n\n\t    /* Ignore address for loop transports. */\n\t    if (type == PJSIP_TRANSPORT_LOOP ||\n\t\ttype == PJSIP_TRANSPORT_LOOP_DGRAM)\n\t    {\n\t\tpj_sockaddr *addr = &key.rem_addr;\n\n\t\tpj_bzero(addr, addr_len);\n\t\tkey_len = sizeof(key.type) + addr_len;\n\t\ttp_entry = (transport *) pj_hash_get(mgr->table, &key,\n\t\t\t\t\t\t     key_len, NULL);\n\t\tif (tp_entry) {\n\t\t    tp_ref = tp_entry->tp;\n\t\t}\n\t    }\n\t    /* For datagram transports, try lookup with zero address.\n\t     */\n\t    else if (flag & PJSIP_TRANSPORT_DATAGRAM)\n\t    {\n\t\tpj_sockaddr *addr = &key.rem_addr;\n\n\t\tpj_bzero(addr, addr_len);\n\t\taddr->addr.sa_family = remote_addr->addr.sa_family;\n\n\t\tkey_len = sizeof(key.type) + addr_len;\n\t\ttp_entry = (transport *) pj_hash_get(mgr->table, &key,\n\t\t\t\t\t\t     key_len, NULL);\n\t\tif (tp_entry) {\n\t\t    tp_ref = tp_entry->tp;\n\t\t}\n\t    }\n\t}\n\n\t/* If transport is found and listener is specified, verify listener */\n\telse if (sel && sel->type == PJSIP_TPSELECTOR_LISTENER &&\n\t\t sel->u.listener && tp_ref->factory != sel->u.listener)\n\t{\n\t    tp_ref = NULL;\n\t    /* This will cause a new transport to be created which will be a\n\t     * 'duplicate' of the existing transport (same type & remote addr,\n\t     * but different factory).\n\t     */\n\t    TRACE_((THIS_FILE, \"Transport found but from different listener\"));\n\t}\n\n\tif (tp_ref!=NULL && !tp_ref->is_shutdown && !tp_ref->is_destroying) {\n\t    /*\n\t     * Transport found!\n\t     */\n\t    pjsip_transport_add_ref(tp_ref);\n\t    pj_lock_release(mgr->lock);\n\t    *tp = tp_ref;\n\n\t    TRACE_((THIS_FILE, \"Transport %s acquired\", tp_ref->obj_name));\n\t    return PJ_SUCCESS;\n\t}\n\n\n\t/*\n\t * Either transport not found, or we don't want to use the existing\n\t * transport (such as in the case of different factory or\n\t * if connection reuse is disabled). So we need to create one,\n\t * find factory that can create such transport.\n\t *\n\t * If there's an existing transport, its place in the hash table\n\t * will be replaced by this new one. And eventually the existing\n\t * transport will still be freed (by application or #1774).\n\t */\n\tif (sel && sel->type == PJSIP_TPSELECTOR_LISTENER && sel->u.listener)\n\t{\n\t    /* Application has requested that a specific listener is to\n\t     * be used.\n\t     */\n\n\t    /* Verify that the listener type matches the destination type */\n\t    /* Already checked above. */\n\t    /*\n\t    if (sel->u.listener->type != type) {\n\t\tpj_lock_release(mgr->lock);\n\t\treturn PJSIP_ETPNOTSUITABLE;\n\t    }\n\t    */\n\n\t    /* We'll use this listener to create transport */\n\t    factory = sel->u.listener;\n\n\t    /* Verify if listener is still valid */\n\t    if (!pjsip_tpmgr_is_tpfactory_valid(mgr, factory)) {\n\t\tpj_lock_release(mgr->lock);\n\t\tPJ_LOG(3,(THIS_FILE, \"Specified factory for creating \"\n\t\t\t\t     \"transport is not found\"));\n\t\treturn PJ_ENOTFOUND;\n\t    }\n\n\t} else {\n\n\t    /* Find factory with type matches the destination type */\n\t    factory = mgr->factory_list.next;\n\t    while (factory != &mgr->factory_list) {\n\t\tif (factory->type == type)\n\t\t    break;\n\t\tfactory = factory->next;\n\t    }\n\n\t    if (factory == &mgr->factory_list) {\n\t\t/* No factory can create the transport! */\n\t\tpj_lock_release(mgr->lock);\n\t\tTRACE_((THIS_FILE, \"No suitable factory was found either\"));\n\t\treturn PJSIP_EUNSUPTRANSPORT;\n\t    }\n\t}\n    }\n\n    TRACE_((THIS_FILE, \"Creating new transport from factory\"));\n\n    /* Request factory to create transport. */\n    if (factory->create_transport2) {\n\tstatus = factory->create_transport2(factory, mgr, mgr->endpt,\n\t\t\t\t\t    (const pj_sockaddr*) remote,\n\t\t\t\t\t    addr_len, tdata, tp);\n    } else {\n\tstatus = factory->create_transport(factory, mgr, mgr->endpt,\n\t\t\t\t\t   (const pj_sockaddr*) remote,\n\t\t\t\t\t   addr_len, tp);\n    }\n    if (status == PJ_SUCCESS) {\n\tPJ_ASSERT_ON_FAIL(tp!=NULL,\n\t    {pj_lock_release(mgr->lock); return PJ_EBUG;});\n\tpjsip_transport_add_ref(*tp);\n\t(*tp)->factory = factory;\n    }\n    pj_lock_release(mgr->lock);\n    return status;\n}\n\n/**\n * Dump transport info.\n */\nPJ_DEF(void) pjsip_tpmgr_dump_transports(pjsip_tpmgr *mgr)\n{\n#if PJ_LOG_MAX_LEVEL >= 3\n    pj_hash_iterator_t itr_val;\n    pj_hash_iterator_t *itr;\n    pjsip_tpfactory *factory;\n\n    pj_lock_acquire(mgr->lock);\n\n#if defined(PJ_DEBUG) && PJ_DEBUG!=0\n    PJ_LOG(3,(THIS_FILE, \" Outstanding transmit buffers: %d\",\n\t      pj_atomic_get(mgr->tdata_counter)));\n#endif\n\n    PJ_LOG(3, (THIS_FILE, \" Dumping listeners:\"));\n    factory = mgr->factory_list.next;\n    while (factory != &mgr->factory_list) {\n\tPJ_LOG(3, (THIS_FILE, \"  %s %s:%.*s:%d\", \n\t\t   factory->obj_name,\n\t\t   factory->type_name,\n\t\t   (int)factory->addr_name.host.slen,\n\t\t   factory->addr_name.host.ptr,\n\t\t   (int)factory->addr_name.port));\n\tfactory = factory->next;\n    }\n\n    itr = pj_hash_first(mgr->table, &itr_val);\n    if (itr) {\n\tPJ_LOG(3, (THIS_FILE, \" Dumping transports:\"));\n\n\tdo {\n\t    transport *tp_entry = (transport *) pj_hash_this(mgr->table, itr);\n\t    if (tp_entry) {\n\t\ttransport *tp_iter = tp_entry;\n\n\t\tdo {\n\t\t    pjsip_transport *tp_ref = tp_iter->tp;\n\n\t\t    PJ_LOG(3, (THIS_FILE, \"  %s %s%s%s%s(refcnt=%d%s)\",\n\t\t\t       tp_ref->obj_name,\n\t\t\t       tp_ref->info,\n\t\t\t       (tp_ref->factory)?\" listener[\":\"\",\n\t\t\t       (tp_ref->factory)?tp_ref->factory->obj_name:\"\",\n\t\t\t       (tp_ref->factory)?\"]\":\"\",\n\t\t\t       pj_atomic_get(tp_ref->ref_cnt),\n\t\t\t       (tp_ref->idle_timer.id ? \" [idle]\" : \"\")));\n\n\t\t    tp_iter = tp_iter->next;\n\t\t} while (tp_iter != tp_entry);\n\t    }\n\t    itr = pj_hash_next(mgr->table, itr);\n\t} while (itr);\n    }\n\n    pj_lock_release(mgr->lock);\n#else\n    PJ_UNUSED_ARG(mgr);\n#endif\n}\n\n/**\n * Set callback of global transport state notification.\n */\nPJ_DEF(pj_status_t) pjsip_tpmgr_set_state_cb(pjsip_tpmgr *mgr,\n\t\t\t\t\t     pjsip_tp_state_callback cb)\n{\n    PJ_ASSERT_RETURN(mgr, PJ_EINVAL);\n\n    mgr->tp_state_cb = cb;\n\n    return PJ_SUCCESS;\n}\n\n/**\n * Get callback of global transport state notification.\n */\nPJ_DEF(pjsip_tp_state_callback) pjsip_tpmgr_get_state_cb(\n\t\t\t\t\t     const pjsip_tpmgr *mgr)\n{\n    PJ_ASSERT_RETURN(mgr, NULL);\n\n    return mgr->tp_state_cb;\n}\n\n\n/**\n * Allocate and init transport data.\n */\nstatic void init_tp_data(pjsip_transport *tp)\n{\n    transport_data *tp_data;\n\n    pj_assert(tp && !tp->data);\n\n    tp_data = PJ_POOL_ZALLOC_T(tp->pool, transport_data);\n    pj_list_init(&tp_data->st_listeners);\n    pj_list_init(&tp_data->st_listeners_empty);\n    tp->data = tp_data;\n}\n\n\nstatic void tp_state_callback(pjsip_transport *tp,\n\t\t\t      pjsip_transport_state state,\n\t\t\t      const pjsip_transport_state_info *info)\n{\n    transport_data *tp_data;\n\n    pj_lock_acquire(tp->lock);\n\n    tp_data = (transport_data*)tp->data;\n\n    /* Notify the transport state listeners, if any. */\n    if (!tp_data || pj_list_empty(&tp_data->st_listeners)) {\n\tgoto on_return;\n    } else {\n\tpjsip_transport_state_info st_info;\n\ttp_state_listener *st_listener = tp_data->st_listeners.next;\n\n\t/* As we need to put the user data into the transport state info,\n\t * let's use a copy of transport state info.\n\t */\n\tpj_memcpy(&st_info, info, sizeof(st_info));\n\twhile (st_listener != &tp_data->st_listeners) {\n\t    st_info.user_data = st_listener->user_data;\n\t    (*st_listener->cb)(tp, state, &st_info);\n\n\t    st_listener = st_listener->next;\n\t}\n    }\n\non_return:\n    pj_lock_release(tp->lock);\n}\n\n\n/**\n * Add a listener to the specified transport for transport state notification.\n */\nPJ_DEF(pj_status_t) pjsip_transport_add_state_listener (\n\t\t\t\t\t    pjsip_transport *tp,\n\t\t\t\t\t    pjsip_tp_state_callback cb,\n\t\t\t\t\t    void *user_data,\n\t\t\t\t\t    pjsip_tp_state_listener_key **key)\n{\n    transport_data *tp_data;\n    tp_state_listener *entry;\n\n    PJ_ASSERT_RETURN(tp && cb && key, PJ_EINVAL);\n\n    if (tp->is_shutdown || tp->is_destroying) {\n\t*key = NULL;\n\treturn PJ_EINVALIDOP;\n    }\n\n    pj_lock_acquire(tp->lock);\n\n    /* Init transport data, if it hasn't */\n    if (!tp->data)\n\tinit_tp_data(tp);\n\n    tp_data = (transport_data*)tp->data;\n\n    /* Init the new listener entry. Use available empty slot, if any,\n     * otherwise allocate it using the transport pool.\n     */\n    if (!pj_list_empty(&tp_data->st_listeners_empty)) {\n\tentry = tp_data->st_listeners_empty.next;\n\tpj_list_erase(entry);\n    } else {\n\tentry = PJ_POOL_ZALLOC_T(tp->pool, tp_state_listener);\n    }\n    entry->cb = cb;\n    entry->user_data = user_data;\n\n    /* Add the new listener entry to the listeners list */\n    pj_list_push_back(&tp_data->st_listeners, entry);\n\n    *key = entry;\n\n    pj_lock_release(tp->lock);\n\n    return PJ_SUCCESS;\n}\n\n/**\n * Remove a listener from the specified transport for transport state \n * notification.\n */\nPJ_DEF(pj_status_t) pjsip_transport_remove_state_listener (\n\t\t\t\t    pjsip_transport *tp,\n\t\t\t\t    pjsip_tp_state_listener_key *key,\n\t\t\t\t    const void *user_data)\n{\n    transport_data *tp_data;\n    tp_state_listener *entry;\n\n    PJ_ASSERT_RETURN(tp && key, PJ_EINVAL);\n\n    pj_lock_acquire(tp->lock);\n\n    tp_data = (transport_data*)tp->data;\n\n    /* Transport data is NULL or no registered listener? */\n    if (!tp_data || pj_list_empty(&tp_data->st_listeners)) {\n\tpj_lock_release(tp->lock);\n\treturn PJ_ENOTFOUND;\n    }\n\n    entry = (tp_state_listener*)key;\n\n    /* Validate the user data */\n    if (entry->user_data != user_data) {\n\tpj_assert(!\"Invalid transport state listener key\");\n\tpj_lock_release(tp->lock);\n\treturn PJ_EBUG;\n    }\n\n    /* Reset the entry and move it to the empty list */\n    entry->cb = NULL;\n    entry->user_data = NULL;\n    pj_list_erase(entry);\n    pj_list_push_back(&tp_data->st_listeners_empty, entry);\n\n    pj_lock_release(tp->lock);\n\n    return PJ_SUCCESS;\n}\n\n/*\n * Set callback of data dropping.\n */\nPJ_DEF(pj_status_t) pjsip_tpmgr_set_drop_data_cb(pjsip_tpmgr *mgr,\n\t\t\t\t\t\t pjsip_tp_on_rx_dropped_cb cb)\n{\n    PJ_ASSERT_RETURN(mgr, PJ_EINVAL);\n\n    mgr->tp_drop_data_cb = cb;\n\n    return PJ_SUCCESS;\n}\n", "/* $Id$ */\n/* \n * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)\n * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n#include <pjsip/sip_util.h>\n#include <pjsip/sip_transport.h>\n#include <pjsip/sip_msg.h>\n#include <pjsip/sip_endpoint.h>\n#include <pjsip/sip_event.h>\n#include <pjsip/sip_transaction.h>\n#include <pjsip/sip_module.h>\n#include <pjsip/sip_errno.h>\n#include <pj/log.h>\n#include <pj/string.h>\n#include <pj/guid.h>\n#include <pj/pool.h>\n#include <pj/except.h>\n#include <pj/rand.h>\n#include <pj/assert.h>\n#include <pj/errno.h>\n\n#define THIS_FILE    \"endpoint\"\n\nstatic const char *event_str[] = \n{\n    \"UNIDENTIFIED\",\n    \"TIMER\",\n    \"TX_MSG\",\n    \"RX_MSG\",\n    \"TRANSPORT_ERROR\",\n    \"TSX_STATE\",\n    \"USER\",\n};\n\nstatic pj_str_t str_TEXT = { \"text\", 4},\n\t\tstr_PLAIN = { \"plain\", 5 };\n\n/* Add URI to target-set */\nPJ_DEF(pj_status_t) pjsip_target_set_add_uri( pjsip_target_set *tset,\n\t\t\t\t\t      pj_pool_t *pool,\n\t\t\t\t\t      const pjsip_uri *uri,\n\t\t\t\t\t      int q1000)\n{\n    pjsip_target *t, *pos = NULL;\n\n    PJ_ASSERT_RETURN(tset && pool && uri, PJ_EINVAL);\n\n    /* Set q-value to 1 if it is not set */\n    if (q1000 <= 0)\n\tq1000 = 1000;\n\n    /* Scan all the elements to see for duplicates, and at the same time\n     * get the position where the new element should be inserted to\n     * based on the q-value.\n     */\n    t = tset->head.next;\n    while (t != &tset->head) {\n\tif (pjsip_uri_cmp(PJSIP_URI_IN_REQ_URI, t->uri, uri)==PJ_SUCCESS)\n\t    return PJ_EEXISTS;\n\tif (pos==NULL && t->q1000 < q1000)\n\t    pos = t;\n\tt = t->next;\n    }\n\n    /* Create new element */\n    t = PJ_POOL_ZALLOC_T(pool, pjsip_target);\n    t->uri = (pjsip_uri*)pjsip_uri_clone(pool, uri);\n    t->q1000 = q1000;\n\n    /* Insert */\n    if (pos == NULL)\n\tpj_list_push_back(&tset->head, t);\n    else\n\tpj_list_insert_before(pos, t);\n\n    /* Set current target if this is the first URI */\n    if (tset->current == NULL)\n\ttset->current = t;\n\n    return PJ_SUCCESS;\n}\n\n/* Add URI's in the Contact header in the message to target-set */\nPJ_DEF(pj_status_t) pjsip_target_set_add_from_msg( pjsip_target_set *tset,\n\t\t\t\t\t\t   pj_pool_t *pool,\n\t\t\t\t\t\t   const pjsip_msg *msg)\n{\n    const pjsip_hdr *hdr;\n    unsigned added = 0;\n\n    PJ_ASSERT_RETURN(tset && pool && msg, PJ_EINVAL);\n\n    /* Scan for Contact headers and add the URI */\n    hdr = msg->hdr.next;\n    while (hdr != &msg->hdr) {\n\tif (hdr->type == PJSIP_H_CONTACT) {\n\t    const pjsip_contact_hdr *cn_hdr = (const pjsip_contact_hdr*)hdr;\n\n\t    if (!cn_hdr->star) {\n\t\tpj_status_t rc;\n\t\trc = pjsip_target_set_add_uri(tset, pool, cn_hdr->uri, \n\t\t\t\t\t      cn_hdr->q1000);\n\t\tif (rc == PJ_SUCCESS)\n\t\t    ++added;\n\t    }\n\t}\n\thdr = hdr->next;\n    }\n\n    return added ? PJ_SUCCESS : PJ_EEXISTS;\n}\n\n\n/* Get next target, if any */\nPJ_DEF(pjsip_target*) pjsip_target_set_get_next(const pjsip_target_set *tset)\n{\n    const pjsip_target *t, *next = NULL;\n\n    t = tset->head.next;\n    while (t != &tset->head) {\n\tif (PJSIP_IS_STATUS_IN_CLASS(t->code, 200)) {\n\t    /* No more target since one target has been successful */\n\t    return NULL;\n\t}\n\tif (PJSIP_IS_STATUS_IN_CLASS(t->code, 600)) {\n\t    /* No more target since one target returned global error */\n\t    return NULL;\n\t}\n\tif (t->code==0 && next==NULL) {\n\t    /* This would be the next target as long as we don't find\n\t     * targets with 2xx or 6xx status after this.\n\t     */\n\t    next = t;\n\t}\n\tt = t->next;\n    }\n\n    return (pjsip_target*)next;\n}\n\n\n/* Set current target */\nPJ_DEF(pj_status_t) pjsip_target_set_set_current( pjsip_target_set *tset,\n\t\t\t\t\t\t  pjsip_target *target)\n{\n    PJ_ASSERT_RETURN(tset && target, PJ_EINVAL);\n    PJ_ASSERT_RETURN(pj_list_find_node(tset, target) != NULL, PJ_ENOTFOUND);\n\n    tset->current = target;\n\n    return PJ_SUCCESS;\n}\n\n\n/* Assign status to a target */\nPJ_DEF(pj_status_t) pjsip_target_assign_status( pjsip_target *target,\n\t\t\t\t\t        pj_pool_t *pool,\n\t\t\t\t\t        int status_code,\n\t\t\t\t\t        const pj_str_t *reason)\n{\n    PJ_ASSERT_RETURN(target && pool && status_code && reason, PJ_EINVAL);\n\n    target->code = (pjsip_status_code)status_code;\n    pj_strdup(pool, &target->reason, reason);\n\n    return PJ_SUCCESS;\n}\n\n\n\n/*\n * Initialize transmit data (msg) with the headers and optional body.\n * This will just put the headers in the message as it is. Be carefull\n * when calling this function because once a header is put in a message, \n * it CAN NOT be put in other message until the first message is deleted, \n * because the way the header is put in the list.\n * That's why the session will shallow_clone it's headers before calling\n * this function.\n */\nstatic void init_request_throw( pjsip_endpoint *endpt,\n                                pjsip_tx_data *tdata, \n\t\t\t\tpjsip_method *method,\n\t\t\t\tpjsip_uri *param_target,\n\t\t\t\tpjsip_from_hdr *param_from,\n\t\t\t\tpjsip_to_hdr *param_to, \n\t\t\t\tpjsip_contact_hdr *param_contact,\n\t\t\t\tpjsip_cid_hdr *param_call_id,\n\t\t\t\tpjsip_cseq_hdr *param_cseq, \n\t\t\t\tconst pj_str_t *param_text)\n{\n    pjsip_msg *msg;\n    pjsip_msg_body *body;\n    pjsip_via_hdr *via;\n    const pjsip_hdr *endpt_hdr;\n\n    /* Create the message. */\n    msg = tdata->msg = pjsip_msg_create(tdata->pool, PJSIP_REQUEST_MSG);\n\n    /* Init request URI. */\n    pj_memcpy(&msg->line.req.method, method, sizeof(*method));\n    msg->line.req.uri = param_target;\n\n    /* Add additional request headers from endpoint. */\n    endpt_hdr = pjsip_endpt_get_request_headers(endpt)->next;\n    while (endpt_hdr != pjsip_endpt_get_request_headers(endpt)) {\n\tpjsip_hdr *hdr = (pjsip_hdr*) \n\t\t\t pjsip_hdr_shallow_clone(tdata->pool, endpt_hdr);\n\tpjsip_msg_add_hdr( tdata->msg, hdr );\n\tendpt_hdr = endpt_hdr->next;\n    }\n\n    /* Add From header. */\n    if (param_from->tag.slen == 0)\n\tpj_create_unique_string(tdata->pool, &param_from->tag);\n    pjsip_msg_add_hdr(msg, (pjsip_hdr*)param_from);\n\n    /* Add To header. */\n    pjsip_msg_add_hdr(msg, (pjsip_hdr*)param_to);\n\n    /* Add Contact header. */\n    if (param_contact) {\n\tpjsip_msg_add_hdr(msg, (pjsip_hdr*)param_contact);\n    }\n\n    /* Add Call-ID header. */\n    pjsip_msg_add_hdr(msg, (pjsip_hdr*)param_call_id);\n\n    /* Add CSeq header. */\n    pjsip_msg_add_hdr(msg, (pjsip_hdr*)param_cseq);\n\n    /* Add a blank Via header in the front of the message. */\n    via = pjsip_via_hdr_create(tdata->pool);\n    via->rport_param = pjsip_cfg()->endpt.disable_rport ? -1 : 0;\n    pjsip_msg_insert_first_hdr(msg, (pjsip_hdr*)via);\n\n    /* Add header params as request headers */\n    if (PJSIP_URI_SCHEME_IS_SIP(param_target) || \n\tPJSIP_URI_SCHEME_IS_SIPS(param_target)) \n    {\n\tpjsip_sip_uri *uri = (pjsip_sip_uri*) pjsip_uri_get_uri(param_target);\n\tpjsip_param *hparam;\n\n\thparam = uri->header_param.next;\n\twhile (hparam != &uri->header_param) {\n\t    pjsip_generic_string_hdr *hdr;\n\n\t    hdr = pjsip_generic_string_hdr_create(tdata->pool, \n\t\t\t\t\t\t  &hparam->name,\n\t\t\t\t\t\t  &hparam->value);\n\t    pjsip_msg_add_hdr(msg, (pjsip_hdr*)hdr);\n\t    hparam = hparam->next;\n\t}\n    }\n\n    /* Create message body. */\n    if (param_text) {\n\tbody = PJ_POOL_ZALLOC_T(tdata->pool, pjsip_msg_body);\n\tbody->content_type.type = str_TEXT;\n\tbody->content_type.subtype = str_PLAIN;\n\tbody->data = pj_pool_alloc(tdata->pool, param_text->slen );\n\tpj_memcpy(body->data, param_text->ptr, param_text->slen);\n\tbody->len = (unsigned)param_text->slen;\n\tbody->print_body = &pjsip_print_text_body;\n\tmsg->body = body;\n    }\n\n    PJ_LOG(5,(THIS_FILE, \"%s created.\", \n\t\t\t pjsip_tx_data_get_info(tdata)));\n\n}\n\n/*\n * Create arbitrary request.\n */\nPJ_DEF(pj_status_t) pjsip_endpt_create_request(  pjsip_endpoint *endpt, \n\t\t\t\t\t\t const pjsip_method *method,\n\t\t\t\t\t\t const pj_str_t *param_target,\n\t\t\t\t\t\t const pj_str_t *param_from,\n\t\t\t\t\t\t const pj_str_t *param_to, \n\t\t\t\t\t\t const pj_str_t *param_contact,\n\t\t\t\t\t\t const pj_str_t *param_call_id,\n\t\t\t\t\t\t int param_cseq, \n\t\t\t\t\t\t const pj_str_t *param_text,\n\t\t\t\t\t\t pjsip_tx_data **p_tdata)\n{\n    pjsip_uri *target;\n    pjsip_tx_data *tdata;\n    pjsip_from_hdr *from;\n    pjsip_to_hdr *to;\n    pjsip_contact_hdr *contact;\n    pjsip_cseq_hdr *cseq = NULL;    /* = NULL, warning in VC6 */\n    pjsip_cid_hdr *call_id;\n    pj_str_t tmp;\n    pj_status_t status;\n    const pj_str_t STR_CONTACT = { \"Contact\", 7 };\n    PJ_USE_EXCEPTION;\n\n    status = pjsip_endpt_create_tdata(endpt, &tdata);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Init reference counter to 1. */\n    pjsip_tx_data_add_ref(tdata);\n\n    PJ_TRY {\n\t/* Request target. */\n\tpj_strdup_with_null(tdata->pool, &tmp, param_target);\n\ttarget = pjsip_parse_uri( tdata->pool, tmp.ptr, tmp.slen, 0);\n\tif (target == NULL) {\n\t    status = PJSIP_EINVALIDREQURI;\n\t    goto on_error;\n\t}\n\n\t/* From */\n\tfrom = pjsip_from_hdr_create(tdata->pool);\n\tpj_strdup_with_null(tdata->pool, &tmp, param_from);\n\tfrom->uri = pjsip_parse_uri( tdata->pool, tmp.ptr, tmp.slen, \n\t\t\t\t     PJSIP_PARSE_URI_AS_NAMEADDR);\n\tif (from->uri == NULL) {\n\t    status = PJSIP_EINVALIDHDR;\n\t    goto on_error;\n\t}\n\tpj_create_unique_string(tdata->pool, &from->tag);\n\n\t/* To */\n\tto = pjsip_to_hdr_create(tdata->pool);\n\tpj_strdup_with_null(tdata->pool, &tmp, param_to);\n\tto->uri = pjsip_parse_uri( tdata->pool, tmp.ptr, tmp.slen, \n\t\t\t\t   PJSIP_PARSE_URI_AS_NAMEADDR);\n\tif (to->uri == NULL) {\n\t    status = PJSIP_EINVALIDHDR;\n\t    goto on_error;\n\t}\n\n\t/* Contact. */\n\tif (param_contact) {\n\t    pj_strdup_with_null(tdata->pool, &tmp, param_contact);\n\t    contact = (pjsip_contact_hdr*)\n\t\t      pjsip_parse_hdr(tdata->pool, &STR_CONTACT, tmp.ptr, \n\t\t\t\t      tmp.slen, NULL);\n\t    if (contact == NULL) {\n\t\tstatus = PJSIP_EINVALIDHDR;\n\t\tgoto on_error;\n\t    }\n\t} else {\n\t    contact = NULL;\n\t}\n\n\t/* Call-ID */\n\tcall_id = pjsip_cid_hdr_create(tdata->pool);\n\tif (param_call_id != NULL && param_call_id->slen)\n\t    pj_strdup(tdata->pool, &call_id->id, param_call_id);\n\telse\n\t    pj_create_unique_string(tdata->pool, &call_id->id);\n\n\t/* CSeq */\n\tcseq = pjsip_cseq_hdr_create(tdata->pool);\n\tif (param_cseq >= 0)\n\t    cseq->cseq = param_cseq;\n\telse\n\t    cseq->cseq = pj_rand() & 0xFFFF;\n\n\t/* Method */\n\tpjsip_method_copy(tdata->pool, &cseq->method, method);\n\n\t/* Create the request. */\n\tinit_request_throw( endpt, tdata, &cseq->method, target, from, to, \n                            contact, call_id, cseq, param_text);\n    }\n    PJ_CATCH_ANY {\n\tstatus = PJ_ENOMEM;\n\tgoto on_error;\n    }\n    PJ_END\n\n    *p_tdata = tdata;\n    return PJ_SUCCESS;\n\non_error:\n    pjsip_tx_data_dec_ref(tdata);\n    return status;\n}\n\nPJ_DEF(pj_status_t) pjsip_endpt_create_request_from_hdr( pjsip_endpoint *endpt,\n\t\t\t\t     const pjsip_method *method,\n\t\t\t\t     const pjsip_uri *param_target,\n\t\t\t\t     const pjsip_from_hdr *param_from,\n\t\t\t\t     const pjsip_to_hdr *param_to,\n\t\t\t\t     const pjsip_contact_hdr *param_contact,\n\t\t\t\t     const pjsip_cid_hdr *param_call_id,\n\t\t\t\t     int param_cseq,\n\t\t\t\t     const pj_str_t *param_text,\n\t\t\t\t     pjsip_tx_data **p_tdata)\n{\n    pjsip_uri *target;\n    pjsip_tx_data *tdata;\n    pjsip_from_hdr *from;\n    pjsip_to_hdr *to;\n    pjsip_contact_hdr *contact;\n    pjsip_cid_hdr *call_id;\n    pjsip_cseq_hdr *cseq = NULL; /* The NULL because warning in VC6 */\n    pj_status_t status;\n    PJ_USE_EXCEPTION;\n\n    /* Check arguments. */\n    PJ_ASSERT_RETURN(endpt && method && param_target && param_from &&\n\t\t     param_to && p_tdata, PJ_EINVAL);\n\n    /* Create new transmit data. */\n    status = pjsip_endpt_create_tdata(endpt, &tdata);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Set initial reference counter to 1. */\n    pjsip_tx_data_add_ref(tdata);\n\n    PJ_TRY {\n\t/* Duplicate target URI and headers. */\n\ttarget = (pjsip_uri*) pjsip_uri_clone(tdata->pool, param_target);\n\tfrom = (pjsip_from_hdr*) pjsip_hdr_clone(tdata->pool, param_from);\n\tpjsip_fromto_hdr_set_from(from);\n\tto = (pjsip_to_hdr*) pjsip_hdr_clone(tdata->pool, param_to);\n\tpjsip_fromto_hdr_set_to(to);\n\tif (param_contact) {\n\t    contact = (pjsip_contact_hdr*) \n\t    \t      pjsip_hdr_clone(tdata->pool, param_contact);\n\t} else {\n\t    contact = NULL;\n\t}\n\tcall_id = pjsip_cid_hdr_create(tdata->pool);\n\tif (param_call_id != NULL && param_call_id->id.slen)\n\t    pj_strdup(tdata->pool, &call_id->id, &param_call_id->id);\n\telse\n\t    pj_create_unique_string(tdata->pool, &call_id->id);\n\n\tcseq = pjsip_cseq_hdr_create(tdata->pool);\n\tif (param_cseq >= 0)\n\t    cseq->cseq = param_cseq;\n\telse\n\t    cseq->cseq = pj_rand() % 0xFFFF;\n\tpjsip_method_copy(tdata->pool, &cseq->method, method);\n\n\t/* Copy headers to the request. */\n\tinit_request_throw(endpt, tdata, &cseq->method, target, from, to, \n                           contact, call_id, cseq, param_text);\n    }\n    PJ_CATCH_ANY {\n\tstatus = PJ_ENOMEM;\n\tgoto on_error;\n    }\n    PJ_END;\n\n    *p_tdata = tdata;\n    return PJ_SUCCESS;\n\non_error:\n    pjsip_tx_data_dec_ref(tdata);\n    return status;\n}\n\n/*\n * Construct a minimal response message for the received request.\n */\nPJ_DEF(pj_status_t) pjsip_endpt_create_response( pjsip_endpoint *endpt,\n\t\t\t\t\t\t const pjsip_rx_data *rdata,\n\t\t\t\t\t\t int st_code,\n\t\t\t\t\t\t const pj_str_t *st_text,\n\t\t\t\t\t\t pjsip_tx_data **p_tdata)\n{\n    pjsip_tx_data *tdata;\n    pjsip_msg *msg, *req_msg;\n    pjsip_hdr *hdr;\n    pjsip_to_hdr *to_hdr;\n    pjsip_via_hdr *top_via = NULL, *via;\n    pjsip_rr_hdr *rr;\n    pj_status_t status;\n\n    /* Check arguments. */\n    PJ_ASSERT_RETURN(endpt && rdata && p_tdata, PJ_EINVAL);\n\n    /* Check status code. */\n    PJ_ASSERT_RETURN(st_code >= 100 && st_code <= 699, PJ_EINVAL);\n\n    /* rdata must be a request message. */\n    req_msg = rdata->msg_info.msg;\n    pj_assert(req_msg->type == PJSIP_REQUEST_MSG);\n\n    /* Request MUST NOT be ACK request! */\n    PJ_ASSERT_RETURN(req_msg->line.req.method.id != PJSIP_ACK_METHOD,\n\t\t     PJ_EINVALIDOP);\n\n    /* Create a new transmit buffer. */\n    status = pjsip_endpt_create_tdata( endpt, &tdata);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Set initial reference count to 1. */\n    pjsip_tx_data_add_ref(tdata);\n\n    /* Create new response message. */\n    tdata->msg = msg = pjsip_msg_create(tdata->pool, PJSIP_RESPONSE_MSG);\n\n    /* Set status code and reason text. */\n    msg->line.status.code = st_code;\n    if (st_text)\n\tpj_strdup(tdata->pool, &msg->line.status.reason, st_text);\n    else\n\tmsg->line.status.reason = *pjsip_get_status_text(st_code);\n\n    /* Set TX data attributes. */\n    tdata->rx_timestamp = rdata->pkt_info.timestamp;\n\n    /* Copy all the via headers, in order. */\n    via = rdata->msg_info.via;\n    while (via) {\n\tpjsip_via_hdr *new_via;\n\n\tnew_via = (pjsip_via_hdr*)pjsip_hdr_clone(tdata->pool, via);\n\tif (top_via == NULL)\n\t    top_via = new_via;\n\n\tpjsip_msg_add_hdr( msg, (pjsip_hdr*)new_via);\n\tvia = via->next;\n\tif (via != (void*)&req_msg->hdr)\n\t    via = (pjsip_via_hdr*) \n\t    \t  pjsip_msg_find_hdr(req_msg, PJSIP_H_VIA, via);\n\telse\n\t    break;\n    }\n\n    /* Copy all Record-Route headers, in order. */\n    rr = (pjsip_rr_hdr*) \n    \t pjsip_msg_find_hdr(req_msg, PJSIP_H_RECORD_ROUTE, NULL);\n    while (rr) {\n\tpjsip_msg_add_hdr(msg, (pjsip_hdr*) pjsip_hdr_clone(tdata->pool, rr));\n\trr = rr->next;\n\tif (rr != (void*)&req_msg->hdr)\n\t    rr = (pjsip_rr_hdr*) pjsip_msg_find_hdr(req_msg, \n\t    \t\t\t\t\t    PJSIP_H_RECORD_ROUTE, rr);\n\telse\n\t    break;\n    }\n\n    /* Copy Call-ID header. */\n    hdr = (pjsip_hdr*) pjsip_msg_find_hdr( req_msg, PJSIP_H_CALL_ID, NULL);\n    pjsip_msg_add_hdr(msg, (pjsip_hdr*) pjsip_hdr_clone(tdata->pool, hdr));\n\n    /* Copy From header. */\n    hdr = (pjsip_hdr*) pjsip_hdr_clone(tdata->pool, rdata->msg_info.from);\n    pjsip_msg_add_hdr( msg, hdr);\n\n    /* Copy To header. */\n    to_hdr = (pjsip_to_hdr*) pjsip_hdr_clone(tdata->pool, rdata->msg_info.to);\n    pjsip_msg_add_hdr( msg, (pjsip_hdr*)to_hdr);\n\n    /* Must add To tag in the response (Section 8.2.6.2), except if this is\n     * 100 (Trying) response. Same tag must be created for the same request\n     * (e.g. same tag in provisional and final response). The easiest way\n     * to do this is to derive the tag from Via branch parameter (or to\n     * use it directly).\n     */\n    if (to_hdr->tag.slen==0 && st_code > 100 && top_via) {\n\tto_hdr->tag = top_via->branch_param;\n    }\n\n    /* Copy CSeq header. */\n    hdr = (pjsip_hdr*) pjsip_hdr_clone(tdata->pool, rdata->msg_info.cseq);\n    pjsip_msg_add_hdr( msg, hdr);\n\n    /* All done. */\n    *p_tdata = tdata;\n\n    PJ_LOG(5,(THIS_FILE, \"%s created\", pjsip_tx_data_get_info(tdata)));\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Construct ACK for 3xx-6xx final response (according to chapter 17.1.1 of\n * RFC3261). Note that the generation of ACK for 2xx response is different,\n * and one must not use this function to generate such ACK.\n */\nPJ_DEF(pj_status_t) pjsip_endpt_create_ack( pjsip_endpoint *endpt,\n\t\t\t\t\t    const pjsip_tx_data *tdata,\n\t\t\t\t\t    const pjsip_rx_data *rdata,\n\t\t\t\t\t    pjsip_tx_data **ack_tdata)\n{\n    pjsip_tx_data *ack = NULL;\n    const pjsip_msg *invite_msg;\n    const pjsip_from_hdr *from_hdr;\n    const pjsip_to_hdr *to_hdr;\n    const pjsip_cid_hdr *cid_hdr;\n    const pjsip_cseq_hdr *cseq_hdr;\n    const pjsip_hdr *hdr;\n    pjsip_hdr *via;\n    pjsip_to_hdr *to;\n    pj_status_t status;\n\n    /* rdata must be a non-2xx final response. */\n    pj_assert(rdata->msg_info.msg->type==PJSIP_RESPONSE_MSG &&\n\t      rdata->msg_info.msg->line.status.code >= 300);\n\n    /* Initialize return value to NULL. */\n    *ack_tdata = NULL;\n\n    /* The original INVITE message. */\n    invite_msg = tdata->msg;\n\n    /* Get the headers from original INVITE request. */\n#   define FIND_HDR(m,HNAME) pjsip_msg_find_hdr(m, PJSIP_H_##HNAME, NULL)\n\n    from_hdr = (const pjsip_from_hdr*) FIND_HDR(invite_msg, FROM);\n    PJ_ASSERT_ON_FAIL(from_hdr != NULL, goto on_missing_hdr);\n\n    to_hdr = (const pjsip_to_hdr*) FIND_HDR(invite_msg, TO);\n    PJ_ASSERT_ON_FAIL(to_hdr != NULL, goto on_missing_hdr);\n\n    cid_hdr = (const pjsip_cid_hdr*) FIND_HDR(invite_msg, CALL_ID);\n    PJ_ASSERT_ON_FAIL(to_hdr != NULL, goto on_missing_hdr);\n\n    cseq_hdr = (const pjsip_cseq_hdr*) FIND_HDR(invite_msg, CSEQ);\n    PJ_ASSERT_ON_FAIL(to_hdr != NULL, goto on_missing_hdr);\n\n#   undef FIND_HDR\n\n    /* Create new request message from the headers. */\n    status = pjsip_endpt_create_request_from_hdr(endpt, \n\t\t\t\t\t\t pjsip_get_ack_method(),\n\t\t\t\t\t\t tdata->msg->line.req.uri,\n\t\t\t\t\t\t from_hdr, to_hdr,\n\t\t\t\t\t\t NULL, cid_hdr,\n\t\t\t\t\t\t cseq_hdr->cseq, NULL,\n\t\t\t\t\t\t &ack);\n\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Update tag in To header with the one from the response (if any). */\n    to = (pjsip_to_hdr*) pjsip_msg_find_hdr(ack->msg, PJSIP_H_TO, NULL);\n    pj_strdup(ack->pool, &to->tag, &rdata->msg_info.to->tag);\n\n\n    /* Clear Via headers in the new request. */\n    while ((via=(pjsip_hdr*)pjsip_msg_find_hdr(ack->msg, PJSIP_H_VIA, NULL)) != NULL)\n\tpj_list_erase(via);\n\n    /* Must contain single Via, just as the original INVITE. */\n    hdr = (pjsip_hdr*) pjsip_msg_find_hdr( invite_msg, PJSIP_H_VIA, NULL);\n    pjsip_msg_insert_first_hdr( ack->msg, \n    \t\t\t        (pjsip_hdr*) pjsip_hdr_clone(ack->pool,hdr) );\n\n    /* If the original INVITE has Route headers, those header fields MUST \n     * appear in the ACK.\n     */\n    hdr = (pjsip_hdr*) pjsip_msg_find_hdr( invite_msg, PJSIP_H_ROUTE, NULL);\n    while (hdr != NULL) {\n\tpjsip_msg_add_hdr( ack->msg, \n\t\t\t   (pjsip_hdr*) pjsip_hdr_clone(ack->pool, hdr) );\n\thdr = hdr->next;\n\tif (hdr == &invite_msg->hdr)\n\t    break;\n\thdr = (pjsip_hdr*) pjsip_msg_find_hdr( invite_msg, PJSIP_H_ROUTE, hdr);\n    }\n\n    /* We're done.\n     * \"tdata\" parameter now contains the ACK message.\n     */\n    *ack_tdata = ack;\n    return PJ_SUCCESS;\n\non_missing_hdr:\n    if (ack)\n\tpjsip_tx_data_dec_ref(ack);\n    return PJSIP_EMISSINGHDR;\n}\n\n\n/*\n * Construct CANCEL request for the previously sent request, according to\n * chapter 9.1 of RFC3261.\n */\nPJ_DEF(pj_status_t) pjsip_endpt_create_cancel( pjsip_endpoint *endpt,\n\t\t\t\t\t       const pjsip_tx_data *req_tdata,\n\t\t\t\t\t       pjsip_tx_data **p_tdata)\n{\n    pjsip_tx_data *cancel_tdata = NULL;\n    const pjsip_from_hdr *from_hdr;\n    const pjsip_to_hdr *to_hdr;\n    const pjsip_cid_hdr *cid_hdr;\n    const pjsip_cseq_hdr *cseq_hdr;\n    const pjsip_hdr *hdr;\n    pjsip_hdr *via;\n    pj_status_t status;\n\n    /* The transmit buffer must INVITE request. */\n    PJ_ASSERT_RETURN(req_tdata->msg->type == PJSIP_REQUEST_MSG &&\n\t\t     req_tdata->msg->line.req.method.id == PJSIP_INVITE_METHOD,\n\t\t     PJ_EINVAL);\n\n    /* Get the headers from original INVITE request. */\n#   define FIND_HDR(m,HNAME) pjsip_msg_find_hdr(m, PJSIP_H_##HNAME, NULL)\n\n    from_hdr = (const pjsip_from_hdr*) FIND_HDR(req_tdata->msg, FROM);\n    PJ_ASSERT_ON_FAIL(from_hdr != NULL, goto on_missing_hdr);\n\n    to_hdr = (const pjsip_to_hdr*) FIND_HDR(req_tdata->msg, TO);\n    PJ_ASSERT_ON_FAIL(to_hdr != NULL, goto on_missing_hdr);\n\n    cid_hdr = (const pjsip_cid_hdr*) FIND_HDR(req_tdata->msg, CALL_ID);\n    PJ_ASSERT_ON_FAIL(to_hdr != NULL, goto on_missing_hdr);\n\n    cseq_hdr = (const pjsip_cseq_hdr*) FIND_HDR(req_tdata->msg, CSEQ);\n    PJ_ASSERT_ON_FAIL(to_hdr != NULL, goto on_missing_hdr);\n\n#   undef FIND_HDR\n\n    /* Create new request message from the headers. */\n    status = pjsip_endpt_create_request_from_hdr(endpt, \n\t\t\t\t\t\t pjsip_get_cancel_method(),\n\t\t\t\t\t\t req_tdata->msg->line.req.uri,\n\t\t\t\t\t\t from_hdr, to_hdr,\n\t\t\t\t\t\t NULL, cid_hdr,\n\t\t\t\t\t\t cseq_hdr->cseq, NULL,\n\t\t\t\t\t\t &cancel_tdata);\n\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Clear Via headers in the new request. */\n    while ((via=(pjsip_hdr*)pjsip_msg_find_hdr(cancel_tdata->msg, PJSIP_H_VIA, NULL)) != NULL)\n\tpj_list_erase(via);\n\n\n    /* Must only have single Via which matches the top-most Via in the \n     * request being cancelled. \n     */\n    hdr = (pjsip_hdr*) pjsip_msg_find_hdr(req_tdata->msg, PJSIP_H_VIA, NULL);\n    if (hdr) {\n\tpjsip_msg_insert_first_hdr(cancel_tdata->msg, \n\t\t\t\t   (pjsip_hdr*)pjsip_hdr_clone(cancel_tdata->pool, hdr));\n    }\n\n    /* If the original request has Route header, the CANCEL request must also\n     * has exactly the same.\n     * Copy \"Route\" header from the request.\n     */\n    hdr = (pjsip_hdr*) pjsip_msg_find_hdr(req_tdata->msg, PJSIP_H_ROUTE, NULL);\n    while (hdr != NULL) {\n\tpjsip_msg_add_hdr(cancel_tdata->msg, \n\t\t\t  (pjsip_hdr*) pjsip_hdr_clone(cancel_tdata->pool, hdr));\n\thdr = hdr->next;\n\tif (hdr != &req_tdata->msg->hdr)\n\t    hdr = (pjsip_hdr*) pjsip_msg_find_hdr(req_tdata->msg, \n\t    \t\t\t\t\t  PJSIP_H_ROUTE, hdr);\n\telse\n\t    break;\n    }\n\n    /* Must also copy the saved strict route header, otherwise CANCEL will be\n     * sent with swapped Route and request URI!\n     */\n    if (req_tdata->saved_strict_route) {\n\tcancel_tdata->saved_strict_route = (pjsip_route_hdr*)\n\t    pjsip_hdr_clone(cancel_tdata->pool, req_tdata->saved_strict_route);\n    }\n\n    /* Copy the destination info from the original request */\n    pj_memcpy(&cancel_tdata->dest_info, &req_tdata->dest_info,\n\t      sizeof(req_tdata->dest_info));\n\n    /* Finally, copy the destination host name from the original request */\n    pj_strdup(cancel_tdata->pool, &cancel_tdata->dest_info.name,\n\t      &req_tdata->dest_info.name);\n\n    /* Done.\n     * Return the transmit buffer containing the CANCEL request.\n     */\n    *p_tdata = cancel_tdata;\n    return PJ_SUCCESS;\n\non_missing_hdr:\n    if (cancel_tdata)\n\tpjsip_tx_data_dec_ref(cancel_tdata);\n    return PJSIP_EMISSINGHDR;\n}\n\n\n/* Fill-up destination information from a target URI */\nPJ_DEF(pj_status_t) pjsip_get_dest_info(const pjsip_uri *target_uri,\n\t\t\t\t \tconst pjsip_uri *request_uri,\n\t\t\t\t \tpj_pool_t *pool,\n\t\t\t\t \tpjsip_host_info *dest_info)\n{\n    /* The target URI must be a SIP/SIPS URL so we can resolve it's address.\n     * Otherwise we're in trouble (i.e. there's no host part in tel: URL).\n     */\n    pj_bzero(dest_info, sizeof(*dest_info));\n\n    /* When request URI uses sips scheme, TLS must always be used regardless\n     * of the target scheme or transport type (see ticket #1740).\n     */\n    if (PJSIP_URI_SCHEME_IS_SIPS(target_uri) || \n\t(pjsip_cfg()->endpt.disable_tls_switch == 0 && request_uri &&\n\t PJSIP_URI_SCHEME_IS_SIPS(request_uri)))\n    {\n\tpjsip_uri *uri = (pjsip_uri*) target_uri;\n\tconst pjsip_sip_uri *url=(const pjsip_sip_uri*)pjsip_uri_get_uri(uri);\n\tunsigned flag;\n\n\tif (!PJSIP_URI_SCHEME_IS_SIPS(target_uri)) {\n\t    PJ_LOG(4,(THIS_FILE, \"Automatic switch to TLS transport as \"\n\t\t\t\t \"request-URI uses \"\"sips\"\" scheme.\"));\n\t}\n\n\tdest_info->flag |= (PJSIP_TRANSPORT_SECURE | PJSIP_TRANSPORT_RELIABLE);\n\tif (url->maddr_param.slen)\n\t    pj_strdup(pool, &dest_info->addr.host, &url->maddr_param);\n\telse\n\t    pj_strdup(pool, &dest_info->addr.host, &url->host);\n        dest_info->addr.port = url->port;\n\tdest_info->type = \n            pjsip_transport_get_type_from_name(&url->transport_param);\n\t/* Double-check that the transport parameter match.\n\t * Sample case:     sips:host;transport=tcp\n\t * See https://trac.pjsip.org/repos/ticket/1319\n\t */\n\tflag = pjsip_transport_get_flag_from_type(dest_info->type);\n\tif ((flag & dest_info->flag) != dest_info->flag) {\n\t    pjsip_transport_type_e t;\n\n\t    t = pjsip_transport_get_type_from_flag(dest_info->flag);\n\t    if (t != PJSIP_TRANSPORT_UNSPECIFIED)\n\t\tdest_info->type = t;\n\t}\n\n    } else if (PJSIP_URI_SCHEME_IS_SIP(target_uri)) {\n\tpjsip_uri *uri = (pjsip_uri*) target_uri;\n\tconst pjsip_sip_uri *url=(const pjsip_sip_uri*)pjsip_uri_get_uri(uri);\n\tif (url->maddr_param.slen)\n\t    pj_strdup(pool, &dest_info->addr.host, &url->maddr_param);\n\telse\n\t    pj_strdup(pool, &dest_info->addr.host, &url->host);\n\tdest_info->addr.port = url->port;\n\tdest_info->type = \n            pjsip_transport_get_type_from_name(&url->transport_param);\n\tdest_info->flag = \n\t    pjsip_transport_get_flag_from_type(dest_info->type);\n    } else {\n\t/* Should have never reached here; app should have configured route\n\t * set when sending to tel: URI\n        pj_assert(!\"Unsupported URI scheme!\");\n\t */\n\tPJ_TODO(SUPPORT_REQUEST_ADDR_RESOLUTION_FOR_TEL_URI);\n\treturn PJSIP_ENOROUTESET;\n    }\n\n    /* Handle IPv6 (http://trac.pjsip.org/repos/ticket/861) */\n    if (dest_info->type != PJSIP_TRANSPORT_UNSPECIFIED && \n\tpj_strchr(&dest_info->addr.host, ':'))\n    {\n\tdest_info->type = (pjsip_transport_type_e)\n\t\t\t  ((int)dest_info->type | PJSIP_TRANSPORT_IPV6);\n    }\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Find which destination to be used to send the request message, based\n * on the request URI and Route headers in the message. The procedure\n * used here follows the guidelines on sending the request in RFC 3261\n * chapter 8.1.2.\n */\nPJ_DEF(pj_status_t) pjsip_get_request_dest(const pjsip_tx_data *tdata,\n\t\t\t\t\t   pjsip_host_info *dest_info )\n{\n    const pjsip_uri *target_uri;\n    const pjsip_route_hdr *first_route_hdr;\n    \n    PJ_ASSERT_RETURN(tdata->msg->type == PJSIP_REQUEST_MSG, \n\t\t     PJSIP_ENOTREQUESTMSG);\n    PJ_ASSERT_RETURN(dest_info != NULL, PJ_EINVAL);\n\n    /* Get the first \"Route\" header from the message.\n     */\n    first_route_hdr = (const pjsip_route_hdr*) \n    \t\t      pjsip_msg_find_hdr(tdata->msg, PJSIP_H_ROUTE, NULL);\n    if (first_route_hdr) {\n\ttarget_uri = first_route_hdr->name_addr.uri;\n    } else {\n\ttarget_uri = tdata->msg->line.req.uri;\n    }\n\n    return pjsip_get_dest_info(target_uri, tdata->msg->line.req.uri,\n\t\t\t       (pj_pool_t*)tdata->pool, dest_info);\n}\n\n\n/*\n * Process route-set found in the request and calculate\n * the destination to be used to send the request message, based\n * on the request URI and Route headers in the message. The procedure\n * used here follows the guidelines on sending the request in RFC 3261\n * chapter 8.1.2.\n */\nPJ_DEF(pj_status_t) pjsip_process_route_set(pjsip_tx_data *tdata,\n\t\t\t\t\t    pjsip_host_info *dest_info )\n{\n    const pjsip_uri *new_request_uri, *target_uri;\n    const pjsip_name_addr *topmost_route_uri;\n    pjsip_route_hdr *first_route_hdr, *last_route_hdr;\n    pj_status_t status;\n    \n    PJ_ASSERT_RETURN(tdata->msg->type == PJSIP_REQUEST_MSG, \n\t\t     PJSIP_ENOTREQUESTMSG);\n    PJ_ASSERT_RETURN(dest_info != NULL, PJ_EINVAL);\n\n    /* If the request contains strict route, check that the strict route\n     * has been restored to its original values before processing the\n     * route set. The strict route is restored to the original values\n     * with pjsip_restore_strict_route_set(). If caller did not restore\n     * the strict route before calling this function, we need to call it\n     * here, or otherwise the strict-route and Request-URI will be swapped\n     * twice!\n     */\n    if (tdata->saved_strict_route != NULL) {\n\tpjsip_restore_strict_route_set(tdata);\n    }\n    PJ_ASSERT_RETURN(tdata->saved_strict_route==NULL, PJ_EBUG);\n\n    /* Find the first and last \"Route\" headers from the message. */\n    last_route_hdr = first_route_hdr = (pjsip_route_hdr*)\n\tpjsip_msg_find_hdr(tdata->msg, PJSIP_H_ROUTE, NULL);\n    if (first_route_hdr) {\n\ttopmost_route_uri = &first_route_hdr->name_addr;\n\twhile (last_route_hdr->next != (void*)&tdata->msg->hdr) {\n\t    pjsip_route_hdr *hdr;\n\t    hdr = (pjsip_route_hdr*)\n\t    \t  pjsip_msg_find_hdr(tdata->msg, PJSIP_H_ROUTE, \n                                     last_route_hdr->next);\n\t    if (!hdr)\n\t\tbreak;\n\t    last_route_hdr = hdr;\n\t}\n    } else {\n\ttopmost_route_uri = NULL;\n    }\n\n    /* If Route headers exist, and the first element indicates loose-route,\n     * the URI is taken from the Request-URI, and we keep all existing Route\n     * headers intact.\n     * If Route headers exist, and the first element DOESN'T indicate loose\n     * route, the URI is taken from the first Route header, and remove the\n     * first Route header from the message.\n     * Otherwise if there's no Route headers, the URI is taken from the\n     * Request-URI.\n     */\n    if (topmost_route_uri) {\n\tpj_bool_t has_lr_param;\n\n\tif (PJSIP_URI_SCHEME_IS_SIP(topmost_route_uri) ||\n\t    PJSIP_URI_SCHEME_IS_SIPS(topmost_route_uri))\n\t{\n\t    const pjsip_sip_uri *url = (const pjsip_sip_uri*)\n\t\tpjsip_uri_get_uri((const void*)topmost_route_uri);\n\t    has_lr_param = url->lr_param;\n\t} else {\n\t    has_lr_param = 0;\n\t}\n\n\tif (has_lr_param) {\n\t    new_request_uri = tdata->msg->line.req.uri;\n\t    /* We shouldn't need to delete topmost Route if it has lr param.\n\t     * But seems like it breaks some proxy implementation, so we\n\t     * delete it anyway.\n\t     */\n\t    /*\n\t    pj_list_erase(first_route_hdr);\n\t    if (first_route_hdr == last_route_hdr)\n\t\tlast_route_hdr = NULL;\n\t    */\n\t} else {\n\t    new_request_uri = (const pjsip_uri*) \n\t    \t\t      pjsip_uri_get_uri((pjsip_uri*)topmost_route_uri);\n\t    pj_list_erase(first_route_hdr);\n\t    tdata->saved_strict_route = first_route_hdr;\n\t    if (first_route_hdr == last_route_hdr)\n\t\tfirst_route_hdr = last_route_hdr = NULL;\n\t}\n\n\ttarget_uri = (pjsip_uri*)topmost_route_uri;\n\n    } else {\n\ttarget_uri = new_request_uri = tdata->msg->line.req.uri;\n    }\n\n    /* Fill up the destination host/port from the URI. */\n    status = pjsip_get_dest_info(target_uri, new_request_uri, tdata->pool,\n\t\t\t   \t dest_info);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* If transport selector is set, set destination type accordingly */\n    if (tdata->tp_sel.type != PJSIP_TPSELECTOR_NONE && tdata->tp_sel.u.ptr) {\n\tif (tdata->tp_sel.type == PJSIP_TPSELECTOR_TRANSPORT)\n\t    dest_info->type = tdata->tp_sel.u.transport->key.type;\n\telse if (tdata->tp_sel.type == PJSIP_TPSELECTOR_LISTENER)\n\t    dest_info->type = tdata->tp_sel.u.listener->type;\n    }\n\n    /* If target URI is different than request URI, replace \n     * request URI add put the original URI in the last Route header.\n     */\n    if (new_request_uri && new_request_uri!=tdata->msg->line.req.uri) {\n\tpjsip_route_hdr *route = pjsip_route_hdr_create(tdata->pool);\n\troute->name_addr.uri = (pjsip_uri*) \n\t\t\t       pjsip_uri_get_uri(tdata->msg->line.req.uri);\n\tif (last_route_hdr)\n\t    pj_list_insert_after(last_route_hdr, route);\n\telse\n\t    pjsip_msg_add_hdr(tdata->msg, (pjsip_hdr*)route);\n\ttdata->msg->line.req.uri = (pjsip_uri*)new_request_uri;\n    }\n\n    /* Success. */\n    return PJ_SUCCESS;  \n}\n\n\n/*\n * Swap the request URI and strict route back to the original position\n * before #pjsip_process_route_set() function is called. This function\n * should only used internally by PJSIP client authentication module.\n */\nPJ_DEF(void) pjsip_restore_strict_route_set(pjsip_tx_data *tdata)\n{\n    pjsip_route_hdr *first_route_hdr, *last_route_hdr;\n\n    /* Check if we have found strict route before */\n    if (tdata->saved_strict_route == NULL) {\n\t/* This request doesn't contain strict route */\n\treturn;\n    }\n\n    /* Find the first \"Route\" headers from the message. */\n    first_route_hdr = (pjsip_route_hdr*)\n\t\t      pjsip_msg_find_hdr(tdata->msg, PJSIP_H_ROUTE, NULL);\n\n    if (first_route_hdr == NULL) {\n\t/* User has modified message route? We don't expect this! */\n\tpj_assert(!\"Message route was modified?\");\n\ttdata->saved_strict_route = NULL;\n\treturn;\n    }\n\n    /* Find last Route header */\n    last_route_hdr = first_route_hdr;\n    while (last_route_hdr->next != (void*)&tdata->msg->hdr) {\n\tpjsip_route_hdr *hdr;\n\thdr = (pjsip_route_hdr*)\n\t      pjsip_msg_find_hdr(tdata->msg, PJSIP_H_ROUTE, \n                                 last_route_hdr->next);\n\tif (!hdr)\n\t    break;\n\tlast_route_hdr = hdr;\n    }\n\n    /* Put the last Route header as request URI, delete last Route\n     * header, and insert the saved strict route as the first Route.\n     */\n    tdata->msg->line.req.uri = last_route_hdr->name_addr.uri;\n    pj_list_insert_before(first_route_hdr, tdata->saved_strict_route);\n    pj_list_erase(last_route_hdr);\n\n    /* Reset */\n    tdata->saved_strict_route = NULL;\n}\n\n\n/* Transport callback for sending stateless request. \n * This is one of the most bizzare function in pjsip, so\n * good luck if you happen to debug this function!!\n */\nstatic void stateless_send_transport_cb( void *token,\n\t\t\t\t\t pjsip_tx_data *tdata,\n\t\t\t\t\t pj_ssize_t sent )\n{\n    pjsip_send_state *stateless_data = (pjsip_send_state*) token;\n    pj_status_t need_update_via = PJ_TRUE;\n\n    PJ_UNUSED_ARG(tdata);\n    pj_assert(tdata == stateless_data->tdata);\n\n    for (;;) {\n\tpj_status_t status;\n\tpj_bool_t cont;\n\n\tpj_sockaddr_t *cur_addr;\n\tpjsip_transport_type_e cur_addr_type;\n\tint cur_addr_len;\n\n\tpjsip_via_hdr *via;\n\n\tif (sent == -PJ_EPENDING) {\n\t    /* This is the initial process.\n\t     * When the process started, this function will be called by\n\t     * stateless_send_resolver_callback() with sent argument set to\n\t     * -PJ_EPENDING.\n\t     */\n\t    cont = PJ_TRUE;\n\t} else {\n\t    /* There are two conditions here:\n\t     * (1) Message is sent (i.e. sent > 0),\n\t     * (2) Failure (i.e. sent <= 0)\n\t     */\n\t    cont = (sent > 0) ? PJ_FALSE :\n\t\t   (tdata->dest_info.cur_addr<tdata->dest_info.addr.count-1);\n\t    if (stateless_data->app_cb) {\n\t\t(*stateless_data->app_cb)(stateless_data, sent, &cont);\n\t    } else {\n\t\t/* Doesn't have application callback.\n\t\t * Terminate the process.\n\t\t */\n\t\tcont = PJ_FALSE;\n\t    }\n\t}\n\n\t/* Finished with this transport. */\n\tif (stateless_data->cur_transport) {\n\t    pjsip_transport_dec_ref(stateless_data->cur_transport);\n\t    stateless_data->cur_transport = NULL;\n\t}\n\n\t/* Done if application doesn't want to continue. */\n\tif (sent > 0 || !cont) {\n\t    pjsip_tx_data_dec_ref(tdata);\n\t    return;\n\t}\n\n\t/* Try next address, if any, and only when this is not the \n\t * first invocation. \n\t */\n\tif (sent != -PJ_EPENDING) {\n\t    tdata->dest_info.cur_addr++;\n\t}\n\n\t/* Have next address? */\n\tif (tdata->dest_info.cur_addr >= tdata->dest_info.addr.count) {\n\t    /* This only happens when a rather buggy application has\n\t     * sent 'cont' to PJ_TRUE when the initial value was PJ_FALSE.\n\t     * In this case just stop the processing; we don't need to\n\t     * call the callback again as application has been informed\n\t     * before.\n\t     */\n\t    pjsip_tx_data_dec_ref(tdata);\n\t    return;\n\t}\n\n\t/* Keep current server address information handy. */\n\tcur_addr = &tdata->dest_info.addr.entry[tdata->dest_info.cur_addr].addr;\n\tcur_addr_type = tdata->dest_info.addr.entry[tdata->dest_info.cur_addr].type;\n\tcur_addr_len = tdata->dest_info.addr.entry[tdata->dest_info.cur_addr].addr_len;\n\n\t/* Acquire transport. */\n\tstatus = pjsip_endpt_acquire_transport2(stateless_data->endpt,\n\t\t\t\t\t\tcur_addr_type,\n\t\t\t\t\t\tcur_addr,\n\t\t\t\t\t\tcur_addr_len,\n\t\t\t\t\t\t&tdata->tp_sel,\n\t\t\t\t\t\ttdata,\n\t\t\t\t\t\t&stateless_data->cur_transport);\n\tif (status != PJ_SUCCESS) {\n\t    sent = -status;\n\t    continue;\n\t}\n\n\t/* Modify Via header. */\n\tvia = (pjsip_via_hdr*) pjsip_msg_find_hdr( tdata->msg,\n\t\t\t\t\t\t   PJSIP_H_VIA, NULL);\n\tif (!via) {\n\t    /* Shouldn't happen if request was created with PJSIP API! \n\t     * But we handle the case anyway for robustness.\n\t     */\n\t    pj_assert(!\"Via header not found!\");\n\t    via = pjsip_via_hdr_create(tdata->pool);\n\t    pjsip_msg_insert_first_hdr(tdata->msg, (pjsip_hdr*)via);\n\t}\n\n\tif (tdata->msg->line.req.method.id == PJSIP_CANCEL_METHOD) {\n\t    if (via->sent_by.host.slen > 0) {\n\t\t/* Don't update Via header on a CANCEL request if the sent-by\n\t\t * parameter is already set since it needs to match the \n\t\t * original request. */\n\t\tneed_update_via = PJ_FALSE;\n\t    }\n\t}\n\n\tif (via->branch_param.slen == 0) {\n\t    pj_str_t tmp;\n\t    via->branch_param.ptr = (char*)pj_pool_alloc(tdata->pool,\n\t\t\t\t\t\t  \t PJSIP_MAX_BRANCH_LEN);\n\t    via->branch_param.slen = PJSIP_MAX_BRANCH_LEN;\n\t    pj_memcpy(via->branch_param.ptr, PJSIP_RFC3261_BRANCH_ID,\n\t\t      PJSIP_RFC3261_BRANCH_LEN);\n\t    tmp.ptr = via->branch_param.ptr + PJSIP_RFC3261_BRANCH_LEN + 2;\n\t    *(tmp.ptr-2) = 80; *(tmp.ptr-1) = 106;\n\t    pj_generate_unique_string(&tmp);\n\t}\n\n\tif (need_update_via) {\n\t    via->transport = pj_str(stateless_data->cur_transport->type_name);\n\n\t    if (tdata->via_addr.host.slen > 0 &&\n\t\t(!tdata->via_tp ||\n\t\t tdata->via_tp == (void *)stateless_data->cur_transport))\n\t    {\n\t\tvia->sent_by = tdata->via_addr;\n\n\t\t/* Better also update tdata via_tp, e.g: CANCEL may need to\n\t\t * refer to original INVITE tdata.\n\t\t */\n\t\ttdata->via_tp = stateless_data->cur_transport;\n\t    } else {\n\t\tvia->sent_by = stateless_data->cur_transport->local_name;\n\n\t\t/* Better also update tdata via_tp & via_addr, e.g: CANCEL\n\t\t * may need to refer to original INVITE tdata.\n\t\t */\n\t\ttdata->via_tp = stateless_data->cur_transport;\n\t\ttdata->via_addr = via->sent_by;\n\t    }\n\t    \n\t    via->rport_param = pjsip_cfg()->endpt.disable_rport ? -1 : 0;\n\n\t    /* Add/remove \"alias\" param to/from Via header on connection \n\t     * oriented/less transport, if configured.\n\t     */\n\t    if (pjsip_cfg()->endpt.req_has_via_alias &&\n\t\ttdata->msg->type == PJSIP_REQUEST_MSG)\n\t    {\n\t\tconst pj_str_t ALIAS_STR = {\"alias\", 5};\n\t\tpjsip_param *alias_param;\n\t\tpj_bool_t is_datagram;\n\n\t\talias_param = pjsip_param_find(&via->other_param, &ALIAS_STR);\n\t\tis_datagram = (stateless_data->cur_transport->flag & \n\t\t\t       PJSIP_TRANSPORT_DATAGRAM);\n\t\tif (!is_datagram && !alias_param) {\n\t\t    alias_param = PJ_POOL_ZALLOC_T(tdata->pool, pjsip_param);\n\t\t    alias_param->name = ALIAS_STR;\n\t\t    pj_list_push_back(&via->other_param, alias_param);\n\t\t} else if (is_datagram && alias_param) {\n\t\t    pj_list_erase(alias_param);\n\t\t}\n\t    }\n\t}\n\n\tpjsip_tx_data_invalidate_msg(tdata);\n\n\t/* Send message using this transport. */\n\tstatus = pjsip_transport_send( stateless_data->cur_transport,\n\t\t\t\t       tdata,\n\t\t\t\t       cur_addr,\n\t\t\t\t       cur_addr_len,\n\t\t\t\t       stateless_data,\n\t\t\t\t       &stateless_send_transport_cb);\n\tif (status == PJ_SUCCESS) {\n\t    /* Recursively call this function. */\n\t    sent = tdata->buf.cur - tdata->buf.start;\n\t    stateless_send_transport_cb( stateless_data, tdata, sent );\n\t    return;\n\t} else if (status == PJ_EPENDING) {\n\t    /* This callback will be called later. */\n\t    return;\n\t} else {\n\t    /* Recursively call this function. */\n\t    sent = -status;\n\t    stateless_send_transport_cb( stateless_data, tdata, sent );\n\t    return;\n\t}\n    }\n\n}\n\n/* Resolver callback for sending stateless request. */\nstatic void \nstateless_send_resolver_callback( pj_status_t status,\n\t\t\t\t  void *token,\n\t\t\t\t  const struct pjsip_server_addresses *addr)\n{\n    pjsip_send_state *stateless_data = (pjsip_send_state*) token;\n    pjsip_tx_data *tdata = stateless_data->tdata;\n\n    /* Fail on server resolution. */\n    if (status != PJ_SUCCESS) {\n\tif (stateless_data->app_cb) {\n\t    pj_bool_t cont = PJ_FALSE;\n\t    (*stateless_data->app_cb)(stateless_data, -status, &cont);\n\t}\n\tpjsip_tx_data_dec_ref(tdata);\n\treturn;\n    }\n\n    /* Copy server addresses */\n    if (addr && addr != &tdata->dest_info.addr) {\n\tpj_memcpy( &tdata->dest_info.addr, addr, \n\t           sizeof(pjsip_server_addresses));\n    }\n    pj_assert(tdata->dest_info.addr.count != 0);\n\n    /* RFC 3261 section 18.1.1:\n     * If a request is within 200 bytes of the path MTU, or if it is larger\n     * than 1300 bytes and the path MTU is unknown, the request MUST be sent\n     * using an RFC 2914 [43] congestion controlled transport protocol, such\n     * as TCP.\n     */\n    if (pjsip_cfg()->endpt.disable_tcp_switch==0 &&\n\ttdata->msg->type == PJSIP_REQUEST_MSG &&\n\ttdata->dest_info.addr.count > 0 && \n\ttdata->dest_info.addr.entry[0].type == PJSIP_TRANSPORT_UDP)\n    {\n\tint len;\n\n\t/* Encode the request */\n\tstatus = pjsip_tx_data_encode(tdata);\n\tif (status != PJ_SUCCESS) {\n\t    if (stateless_data->app_cb) {\n\t\tpj_bool_t cont = PJ_FALSE;\n\t\t(*stateless_data->app_cb)(stateless_data, -status, &cont);\n\t    }\n\t    pjsip_tx_data_dec_ref(tdata);\n\t    return;\n\t}\n\n\t/* Check if request message is larger than 1300 bytes. */\n\tlen = (int)(tdata->buf.cur - tdata->buf.start);\n\tif (len >= PJSIP_UDP_SIZE_THRESHOLD) {\n\t    int i;\n\t    int count = tdata->dest_info.addr.count;\n\n\t    PJ_LOG(5,(THIS_FILE, \"%s exceeds UDP size threshold (%u), \"\n\t\t\t\t \"sending with TCP\",\n\t\t\t\t pjsip_tx_data_get_info(tdata),\n\t\t\t\t PJSIP_UDP_SIZE_THRESHOLD));\n\n\t    /* Insert \"TCP version\" of resolved UDP addresses at the\n\t     * beginning.\n\t     */\n\t    if (count * 2 > PJSIP_MAX_RESOLVED_ADDRESSES)\n\t\tcount = PJSIP_MAX_RESOLVED_ADDRESSES / 2;\n\t    for (i = 0; i < count; ++i) {\n\t\tpj_memcpy(&tdata->dest_info.addr.entry[i+count],\n\t\t\t  &tdata->dest_info.addr.entry[i],\n\t\t\t  sizeof(tdata->dest_info.addr.entry[0]));\n\t\ttdata->dest_info.addr.entry[i].type = PJSIP_TRANSPORT_TCP;\n\t    }\n\t    tdata->dest_info.addr.count = count * 2;\n\t}\n    }\n\n    /* Process the addresses. */\n    stateless_send_transport_cb( stateless_data, tdata, -PJ_EPENDING);\n}\n\n/*\n * Send stateless request.\n * The sending process consists of several stages:\n *  - determine which host to contact (#pjsip_get_request_addr).\n *  - resolve the host (#pjsip_endpt_resolve)\n *  - establish transport (#pjsip_endpt_acquire_transport)\n *  - send the message (#pjsip_transport_send)\n */\nPJ_DEF(pj_status_t) pjsip_endpt_send_request_stateless(pjsip_endpoint *endpt, \n\t\t\t\t   pjsip_tx_data *tdata,\n\t\t\t\t   void *token,\n\t\t\t\t   pjsip_send_callback cb)\n{\n    pjsip_host_info dest_info;\n    pjsip_send_state *stateless_data;\n    pj_status_t status;\n\n    PJ_ASSERT_RETURN(endpt && tdata, PJ_EINVAL);\n\n    /* Get destination name to contact. */\n    status = pjsip_process_route_set(tdata, &dest_info);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Keep stateless data. */\n    stateless_data = PJ_POOL_ZALLOC_T(tdata->pool, pjsip_send_state);\n    stateless_data->token = token;\n    stateless_data->endpt = endpt;\n    stateless_data->tdata = tdata;\n    stateless_data->app_cb = cb;\n\n    /* If destination info has not been initialized (this applies for most\n     * all requests except CANCEL), resolve destination host. The processing\n     * then resumed when the resolving callback is called. For CANCEL, the\n     * destination info must have been copied from the original INVITE so\n     * proceed to sending the request directly.\n     */\n    if (tdata->dest_info.addr.count == 0) {\n\t/* Copy the destination host name to TX data */\n\tpj_strdup(tdata->pool, &tdata->dest_info.name, &dest_info.addr.host);\n\n\tpjsip_endpt_resolve( endpt, tdata->pool, &dest_info, stateless_data,\n\t\t\t     &stateless_send_resolver_callback);\n    } else {\n\tPJ_LOG(5,(THIS_FILE, \"%s: skipping target resolution because \"\n\t                     \"address is already set\",\n\t\t\t     pjsip_tx_data_get_info(tdata)));\n\tstateless_send_resolver_callback(PJ_SUCCESS, stateless_data,\n\t\t\t\t\t &tdata->dest_info.addr);\n    }\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Send raw data to a destination.\n */\nPJ_DEF(pj_status_t) pjsip_endpt_send_raw( pjsip_endpoint *endpt,\n\t\t\t\t\t  pjsip_transport_type_e tp_type,\n\t\t\t\t\t  const pjsip_tpselector *sel,\n\t\t\t\t\t  const void *raw_data,\n\t\t\t\t\t  pj_size_t data_len,\n\t\t\t\t\t  const pj_sockaddr_t *addr,\n\t\t\t\t\t  int addr_len,\n\t\t\t\t\t  void *token,\n\t\t\t\t\t  pjsip_tp_send_callback cb)\n{\n    return pjsip_tpmgr_send_raw(pjsip_endpt_get_tpmgr(endpt), tp_type, sel,\n\t\t\t\tNULL, raw_data, data_len, addr, addr_len,\n\t\t\t\ttoken, cb);\n}\n\n\n/* Callback data for sending raw data */\nstruct send_raw_data\n{\n    pjsip_endpoint\t    *endpt;\n    pjsip_tx_data\t    *tdata;\n    pjsip_tpselector\t    *sel;\n    void\t\t    *app_token;\n    pjsip_tp_send_callback   app_cb;\n};\n\n\n/* Resolver callback for sending raw data. */\nstatic void send_raw_resolver_callback( pj_status_t status,\n    \t\t\t\t\tvoid *token,\n\t\t\t\t\tconst pjsip_server_addresses *addr)\n{\n    struct send_raw_data *sraw_data = (struct send_raw_data*) token;\n\n    if (status != PJ_SUCCESS) {\n\tif (sraw_data->app_cb) {\n\t    (*sraw_data->app_cb)(sraw_data->app_token, sraw_data->tdata,\n\t\t\t\t -status);\n\t}\n    } else {\n\tpj_size_t data_len;\n\n\tpj_assert(addr->count != 0);\n\n\t/* Avoid tdata destroyed by pjsip_tpmgr_send_raw(). */\n\tpjsip_tx_data_add_ref(sraw_data->tdata);\n\n\tdata_len = sraw_data->tdata->buf.cur - sraw_data->tdata->buf.start;\n\tstatus = pjsip_tpmgr_send_raw(pjsip_endpt_get_tpmgr(sraw_data->endpt),\n\t\t\t\t      addr->entry[0].type,\n\t\t\t\t      sraw_data->sel, sraw_data->tdata,\n\t\t\t\t      sraw_data->tdata->buf.start, data_len,\n\t\t\t\t      &addr->entry[0].addr, \n\t\t\t\t      addr->entry[0].addr_len, \n\t\t\t\t      sraw_data->app_token,\n\t\t\t\t      sraw_data->app_cb);\n\tif (status == PJ_SUCCESS) {\n\t    (*sraw_data->app_cb)(sraw_data->app_token, sraw_data->tdata,\n\t\t\t\t data_len);\n\t} else if (status != PJ_EPENDING) {\n\t    (*sraw_data->app_cb)(sraw_data->app_token, sraw_data->tdata,\n\t\t\t\t -status);\n\t}\n    }\n\n    if (sraw_data->sel) {\n\tpjsip_tpselector_dec_ref(sraw_data->sel);\n    }\n    pjsip_tx_data_dec_ref(sraw_data->tdata);\n}\n\n\n/*\n * Send raw data to the specified destination URI. \n */\nPJ_DEF(pj_status_t) pjsip_endpt_send_raw_to_uri(pjsip_endpoint *endpt,\n\t\t\t\t\t\tconst pj_str_t *p_dst_uri,\n\t\t\t\t\t\tconst pjsip_tpselector *sel,\n\t\t\t\t\t\tconst void *raw_data,\n\t\t\t\t\t\tpj_size_t data_len,\n\t\t\t\t\t\tvoid *token,\n\t\t\t\t\t\tpjsip_tp_send_callback cb)\n{\n    pjsip_tx_data *tdata;\n    struct send_raw_data *sraw_data;\n    pj_str_t dst_uri;\n    pjsip_uri *uri;\n    pjsip_host_info dest_info;\n    pj_status_t status;\n\n    /* Allocate buffer */\n    status = pjsip_endpt_create_tdata(endpt, &tdata);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    pjsip_tx_data_add_ref(tdata);\n\n    /* Duplicate URI since parser requires URI to be NULL terminated */\n    pj_strdup_with_null(tdata->pool, &dst_uri, p_dst_uri);\n\n    /* Parse URI */\n    uri = pjsip_parse_uri(tdata->pool, dst_uri.ptr, dst_uri.slen, 0);\n    if (uri == NULL) {\n\tpjsip_tx_data_dec_ref(tdata);\n\treturn PJSIP_EINVALIDURI;\n    }\n\n    /* Build destination info. */\n    status = pjsip_get_dest_info(uri, NULL, tdata->pool, &dest_info);\n    if (status != PJ_SUCCESS) {\n\tpjsip_tx_data_dec_ref(tdata);\n\treturn status;\n    }\n\n    /* Copy data (note: data_len may be zero!) */\n    tdata->buf.start = (char*) pj_pool_alloc(tdata->pool, data_len+1);\n    tdata->buf.end = tdata->buf.start + data_len + 1;\n    if (data_len)\n\tpj_memcpy(tdata->buf.start, raw_data, data_len);\n    tdata->buf.cur = tdata->buf.start + data_len;\n\n    /* Init send_raw_data */\n    sraw_data = PJ_POOL_ZALLOC_T(tdata->pool, struct send_raw_data);\n    sraw_data->endpt = endpt;\n    sraw_data->tdata = tdata;\n    sraw_data->app_token = token;\n    sraw_data->app_cb = cb;\n\n    if (sel) {\n\tsraw_data->sel = PJ_POOL_ALLOC_T(tdata->pool, pjsip_tpselector);\n\tpj_memcpy(sraw_data->sel, sel, sizeof(pjsip_tpselector));\n\tpjsip_tpselector_add_ref(sraw_data->sel);\n    }\n\n    /* Copy the destination host name to TX data */\n    pj_strdup(tdata->pool, &tdata->dest_info.name, &dest_info.addr.host);\n\n    /* Resolve destination host.\n     * The processing then resumed when the resolving callback is called.\n     */\n    pjsip_endpt_resolve( endpt, tdata->pool, &dest_info, sraw_data,\n\t\t\t &send_raw_resolver_callback);\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Determine which address (and transport) to use to send response message\n * based on the received request. This function follows the specification\n * in section 18.2.2 of RFC 3261 and RFC 3581 for calculating the destination\n * address and transport.\n */\nPJ_DEF(pj_status_t) pjsip_get_response_addr( pj_pool_t *pool,\n\t\t\t\t\t     pjsip_rx_data *rdata,\n\t\t\t\t\t     pjsip_response_addr *res_addr )\n{\n    pjsip_transport *src_transport = rdata->tp_info.transport;\n\n    /* Check arguments. */\n    PJ_ASSERT_RETURN(pool && rdata && res_addr, PJ_EINVAL);\n\n    /* rdata must be a request message! */\n    PJ_ASSERT_RETURN(rdata->msg_info.msg->type == PJSIP_REQUEST_MSG,\n\t\t     PJ_EINVAL);\n\n    /* All requests must have \"received\" parameter.\n     * This must always be done in transport layer.\n     */\n    pj_assert(rdata->msg_info.via->recvd_param.slen != 0);\n\n    /* Do the calculation based on RFC 3261 Section 18.2.2 and RFC 3581 */\n\n    if (PJSIP_TRANSPORT_IS_RELIABLE(src_transport)) {\n\t/* For reliable protocol such as TCP or SCTP, or TLS over those, the\n\t * response MUST be sent using the existing connection to the source\n\t * of the original request that created the transaction, if that \n\t * connection is still open. \n\t * If that connection is no longer open, the server SHOULD open a \n\t * connection to the IP address in the received parameter, if present,\n\t * using the port in the sent-by value, or the default port for that \n\t * transport, if no port is specified. \n\t * If that connection attempt fails, the server SHOULD use the \n\t * procedures in [4] for servers in order to determine the IP address\n\t * and port to open the connection and send the response to.\n\t */\n\tres_addr->transport = rdata->tp_info.transport;\n\tpj_memcpy(&res_addr->addr, &rdata->pkt_info.src_addr,\n\t\t  rdata->pkt_info.src_addr_len);\n\tres_addr->addr_len = rdata->pkt_info.src_addr_len;\n\tres_addr->dst_host.type=(pjsip_transport_type_e)src_transport->key.type;\n\tres_addr->dst_host.flag = src_transport->flag;\n\tpj_strdup( pool, &res_addr->dst_host.addr.host, \n\t\t   &rdata->msg_info.via->recvd_param);\n\tres_addr->dst_host.addr.port = rdata->msg_info.via->sent_by.port;\n\tif (res_addr->dst_host.addr.port == 0) {\n\t    res_addr->dst_host.addr.port = \n\t\tpjsip_transport_get_default_port_for_type(res_addr->dst_host.type);\n\t}\n\n    } else if (rdata->msg_info.via->maddr_param.slen) {\n\t/* Otherwise, if the Via header field value contains a maddr parameter,\n\t * the response MUST be forwarded to the address listed there, using \n\t * the port indicated in sent-by, or port 5060 if none is present. \n\t * If the address is a multicast address, the response SHOULD be sent \n\t * using the TTL indicated in the ttl parameter, or with a TTL of 1 if\n\t * that parameter is not present. \n\t */\n\tres_addr->transport = NULL;\n\tres_addr->dst_host.type=(pjsip_transport_type_e)src_transport->key.type;\n\tres_addr->dst_host.flag = src_transport->flag;\n\tpj_strdup( pool, &res_addr->dst_host.addr.host, \n\t\t   &rdata->msg_info.via->maddr_param);\n\tres_addr->dst_host.addr.port = rdata->msg_info.via->sent_by.port;\n\tif (res_addr->dst_host.addr.port == 0)\n\t    res_addr->dst_host.addr.port = 5060;\n\n    } else if (rdata->msg_info.via->rport_param >= 0) {\n\t/* There is both a \"received\" parameter and an \"rport\" parameter, \n\t * the response MUST be sent to the IP address listed in the \"received\"\n\t * parameter, and the port in the \"rport\" parameter. \n\t * The response MUST be sent from the same address and port that the \n\t * corresponding request was received on.\n\t */\n\tres_addr->transport = rdata->tp_info.transport;\n\tpj_memcpy(&res_addr->addr, &rdata->pkt_info.src_addr,\n\t\t  rdata->pkt_info.src_addr_len);\n\tres_addr->addr_len = rdata->pkt_info.src_addr_len;\n\tres_addr->dst_host.type=(pjsip_transport_type_e)src_transport->key.type;\n\tres_addr->dst_host.flag = src_transport->flag;\n\tpj_strdup( pool, &res_addr->dst_host.addr.host, \n\t\t   &rdata->msg_info.via->recvd_param);\n\tres_addr->dst_host.addr.port = rdata->msg_info.via->sent_by.port;\n\tif (res_addr->dst_host.addr.port == 0) {\n\t    res_addr->dst_host.addr.port = \n\t\tpjsip_transport_get_default_port_for_type(res_addr->dst_host.type);\n\t}\n\n    } else {\n\tres_addr->transport = NULL;\n\tres_addr->dst_host.type=(pjsip_transport_type_e)src_transport->key.type;\n\tres_addr->dst_host.flag = src_transport->flag;\n\tpj_strdup( pool, &res_addr->dst_host.addr.host, \n\t\t   &rdata->msg_info.via->recvd_param);\n\tres_addr->dst_host.addr.port = rdata->msg_info.via->sent_by.port;\n\tif (res_addr->dst_host.addr.port == 0) {\n\t    res_addr->dst_host.addr.port = \n\t\tpjsip_transport_get_default_port_for_type(res_addr->dst_host.type);\n\t}\n    }\n\n    return PJ_SUCCESS;\n}\n\n/*\n * Callback called by transport during send_response.\n */\nstatic void send_response_transport_cb(void *token, pjsip_tx_data *tdata,\n\t\t\t\t       pj_ssize_t sent)\n{\n    pjsip_send_state *send_state = (pjsip_send_state*) token;\n    pj_bool_t cont = PJ_FALSE;\n\n    /* Call callback, if any. */\n    if (send_state->app_cb)\n\t(*send_state->app_cb)(send_state, sent, &cont);\n\n    /* Decrement transport reference counter. */\n    pjsip_transport_dec_ref(send_state->cur_transport);\n\n    /* Decrement transmit data ref counter. */\n    pjsip_tx_data_dec_ref(tdata);\n}\n\n/*\n * Resolver calback during send_response.\n */\nstatic void send_response_resolver_cb( pj_status_t status, void *token,\n\t\t\t\t       const pjsip_server_addresses *addr )\n{\n    pjsip_send_state *send_state = (pjsip_send_state*) token;\n\n    if (status != PJ_SUCCESS) {\n\tif (send_state->app_cb) {\n\t    pj_bool_t cont = PJ_FALSE;\n\t    (*send_state->app_cb)(send_state, -status, &cont);\n\t}\n\tpjsip_tx_data_dec_ref(send_state->tdata);\n\treturn;\n    }\n\n    /* Only handle the first address resolved. */\n\n    /* Acquire transport. */\n    status = pjsip_endpt_acquire_transport2(send_state->endpt, \n\t\t\t\t\t    addr->entry[0].type,\n\t\t\t\t\t    &addr->entry[0].addr,\n\t\t\t\t\t    addr->entry[0].addr_len,\n\t\t\t\t\t    &send_state->tdata->tp_sel,\n\t\t\t\t\t    send_state->tdata,\n\t\t\t\t\t    &send_state->cur_transport);\n    if (status != PJ_SUCCESS) {\n\tif (send_state->app_cb) {\n\t    pj_bool_t cont = PJ_FALSE;\n\t    (*send_state->app_cb)(send_state, -status, &cont);\n\t}\n\tpjsip_tx_data_dec_ref(send_state->tdata);\n\treturn;\n    }\n\n    /* Update address in send_state. */\n    pj_memcpy(&send_state->tdata->dest_info.addr, addr, sizeof(*addr));\n\n    /* Send response using the transoprt. */\n    status = pjsip_transport_send( send_state->cur_transport, \n\t\t\t\t   send_state->tdata,\n\t\t\t\t   &addr->entry[0].addr,\n\t\t\t\t   addr->entry[0].addr_len,\n\t\t\t\t   send_state,\n\t\t\t\t   &send_response_transport_cb);\n    if (status == PJ_SUCCESS) {\n\tpj_ssize_t sent = send_state->tdata->buf.cur - \n\t\t\t  send_state->tdata->buf.start;\n\tsend_response_transport_cb(send_state, send_state->tdata, sent);\n\n    } else if (status == PJ_EPENDING) {\n\t/* Transport callback will be called later. */\n    } else {\n\tsend_response_transport_cb(send_state, send_state->tdata, -status);\n    }\n}\n\n/*\n * Send response.\n */\nPJ_DEF(pj_status_t) pjsip_endpt_send_response( pjsip_endpoint *endpt,\n\t\t\t\t\t       pjsip_response_addr *res_addr,\n\t\t\t\t\t       pjsip_tx_data *tdata,\n\t\t\t\t\t       void *token,\n\t\t\t\t\t       pjsip_send_callback cb)\n{\n    /* Determine which transports and addresses to send the response,\n     * based on Section 18.2.2 of RFC 3261.\n     */\n    pjsip_send_state *send_state;\n    pj_status_t status;\n\n    /* Create structure to keep the sending state. */\n    send_state = PJ_POOL_ZALLOC_T(tdata->pool, pjsip_send_state);\n    send_state->endpt = endpt;\n    send_state->tdata = tdata;\n    send_state->token = token;\n    send_state->app_cb = cb;\n\n    if (res_addr->transport != NULL) {\n\tsend_state->cur_transport = res_addr->transport;\n\tpjsip_transport_add_ref(send_state->cur_transport);\n\n\tstatus = pjsip_transport_send( send_state->cur_transport, tdata, \n\t\t\t\t       &res_addr->addr,\n\t\t\t\t       res_addr->addr_len,\n\t\t\t\t       send_state,\n\t\t\t\t       &send_response_transport_cb );\n\tif (status == PJ_SUCCESS) {\n\t    pj_ssize_t sent = tdata->buf.cur - tdata->buf.start;\n\t    send_response_transport_cb(send_state, tdata, sent);\n\t    return PJ_SUCCESS;\n\t} else if (status == PJ_EPENDING) {\n\t    /* Callback will be called later. */\n\t    return PJ_SUCCESS;\n\t} else {\n\t    pjsip_transport_dec_ref(send_state->cur_transport);\n\t    return status;\n\t}\n    } else {\n\t/* Copy the destination host name to TX data */\n\tpj_strdup(tdata->pool, &tdata->dest_info.name, \n\t\t  &res_addr->dst_host.addr.host);\n\n\tpjsip_endpt_resolve(endpt, tdata->pool, &res_addr->dst_host, \n\t\t\t    send_state, &send_response_resolver_cb);\n\treturn PJ_SUCCESS;\n    }\n}\n\n/*\n * Send response combo\n */\nPJ_DEF(pj_status_t) pjsip_endpt_send_response2( pjsip_endpoint *endpt,\n\t\t\t\t\t        pjsip_rx_data *rdata,\n\t\t\t\t\t        pjsip_tx_data *tdata,\n\t\t\t\t\t\tvoid *token,\n\t\t\t\t\t\tpjsip_send_callback cb)\n{\n    pjsip_response_addr res_addr;\n    pj_status_t status;\n\n    status = pjsip_get_response_addr(tdata->pool, rdata, &res_addr);\n    if (status != PJ_SUCCESS) {\n\tpjsip_tx_data_dec_ref(tdata);\n\treturn PJ_SUCCESS;\n    }\n\n    status = pjsip_endpt_send_response(endpt, &res_addr, tdata, token, cb);\n    return status;\n}\n\n\n/*\n * Send response\n */\nPJ_DEF(pj_status_t) pjsip_endpt_respond_stateless( pjsip_endpoint *endpt,\n\t\t\t\t\t\t   pjsip_rx_data *rdata,\n\t\t\t\t\t\t   int st_code,\n\t\t\t\t\t\t   const pj_str_t *st_text,\n\t\t\t\t\t\t   const pjsip_hdr *hdr_list,\n\t\t\t\t\t\t   const pjsip_msg_body *body)\n{\n    pj_status_t status;\n    pjsip_response_addr res_addr;\n    pjsip_tx_data *tdata;\n\n    /* Verify arguments. */\n    PJ_ASSERT_RETURN(endpt && rdata, PJ_EINVAL);\n    PJ_ASSERT_RETURN(rdata->msg_info.msg->type == PJSIP_REQUEST_MSG,\n\t\t     PJSIP_ENOTREQUESTMSG);\n\n    /* Check that no UAS transaction has been created for this request. \n     * If UAS transaction has been created for this request, application\n     * MUST send the response statefully using that transaction.\n     */\n    PJ_ASSERT_RETURN(pjsip_rdata_get_tsx(rdata)==NULL, PJ_EINVALIDOP);\n\n    /* Create response message */\n    status = pjsip_endpt_create_response( endpt, rdata, st_code, st_text, \n\t\t\t\t\t  &tdata);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Add the message headers, if any */\n    if (hdr_list) {\n\tconst pjsip_hdr *hdr = hdr_list->next;\n\twhile (hdr != hdr_list) {\n\t    pjsip_msg_add_hdr(tdata->msg, \n\t    \t\t      (pjsip_hdr*) pjsip_hdr_clone(tdata->pool, hdr) );\n\t    hdr = hdr->next;\n\t}\n    }\n\n    /* Add the message body, if any. */\n    if (body) {\n\ttdata->msg->body = pjsip_msg_body_clone( tdata->pool, body );\n\tif (tdata->msg->body == NULL) {\n\t    pjsip_tx_data_dec_ref(tdata);\n\t    return status;\n\t}\n    }\n\n    /* Get where to send request. */\n    status = pjsip_get_response_addr( tdata->pool, rdata, &res_addr );\n    if (status != PJ_SUCCESS) {\n\tpjsip_tx_data_dec_ref(tdata);\n\treturn status;\n    }\n\n    /* Send! */\n    status = pjsip_endpt_send_response( endpt, &res_addr, tdata, NULL, NULL );\n    if (status != PJ_SUCCESS) {\n\tpjsip_tx_data_dec_ref(tdata);\n\treturn status;\n    }\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Get the event string from the event ID.\n */\nPJ_DEF(const char *) pjsip_event_str(pjsip_event_id_e e)\n{\n    return event_str[e];\n}\n\n"], "fixing_code": ["/* $Id$ */\n/* \n * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)\n * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n#ifndef __PJSIP_SIP_DIALOG_H__\n#define __PJSIP_SIP_DIALOG_H__\n\n\n/**\n * @file sip_dialog.h\n * @brief SIP Dialog abstraction\n */\n\n#include <pjsip/sip_msg.h>\n#include <pjsip/sip_auth.h>\n#include <pjsip/sip_errno.h>\n#include <pjsip/sip_transport.h>\n#include <pjsip/sip_util.h>\n#include <pj/sock.h>\n#include <pj/assert.h>\n\n\n/**\n * @defgroup PJSIP_DIALOG Base Dialog\n * @ingroup PJSIP_UA\n * @brief The base dialog framework to support dialog usages.\n * @{\n *\n * The base dialog framework provides management for base dialog\n * properties such as <b>From</b> header, <b>To</b> header, <b>CSeq</b>\n * sequencing, <b>Call-ID</b> header, <b>Contact</b> header management, \n * dialog <b>route-set</b> management, and common <b>authentication</b>. \n * This basic dialog functionality will be shared by all <b>dialog\n * usages</b> of a particular dialog.\n *\n * More detailed information is explained in\n * <A HREF=\"/docs.htm\">PJSIP Developer's Guide</A>\n * PDF document, and readers are encouraged to read the document to\n * get the concept behind dialog, dialog usages, and INVITE sessions.\n *\n * Application MUST initialize the user agent layer module by calling\n * #pjsip_ua_init_module() before using any of the dialog API, and link\n * the application with with <b>pjsip-core</b> library.\n */\n\nPJ_BEGIN_DECL\n\n\n/* Deprecated API pjsip_dlg_create_uas() due to a fatal bug of possible\n * premature dialog destroy. Application should not change this setting,\n * unless it uses single worker thread.\n * See also https://trac.pjsip.org/repos/ticket/1902.\n */\n#ifndef DEPRECATED_FOR_TICKET_1902\n#  define DEPRECATED_FOR_TICKET_1902      1\n#endif\n\n/**\n * This structure is used to describe dialog's participants, which in this\n * case is local party (i.e. us) and remote party.\n */\ntypedef struct pjsip_dlg_party\n{\n    pjsip_fromto_hdr\t*info;\t    /**< From/To header, inc tag.\t*/\n    pj_str_t\t\t info_str;  /**< String rep of info header.\t*/\n    pj_uint32_t\t\t tag_hval;  /**< Hashed value of the tag.\t*/\n    pjsip_contact_hdr\t*contact;   /**< Contact header.\t\t*/\n    pj_int32_t\t\t first_cseq;/**< First CSeq seen.\t\t*/\n    pj_int32_t\t\t cseq;\t    /**< Next sequence number.\t\t*/\n} pjsip_dlg_party;\n\n\n/**\n * Dialog state.\n */\ntypedef enum pjsip_dialog_state\n{\n    /** Dialog is not established. */\n    PJSIP_DIALOG_STATE_NULL,\n\n    /** Dialog has been established (probably early) */\n    PJSIP_DIALOG_STATE_ESTABLISHED\n} pjsip_dialog_state;\n\n\n/**\n * Dialog capability status.\n */\ntypedef enum pjsip_dialog_cap_status\n{\n    /** Capability is unsupported. */\n    PJSIP_DIALOG_CAP_UNSUPPORTED    = 0,\n\n    /** Capability is supported */\n    PJSIP_DIALOG_CAP_SUPPORTED\t    = 1,\n\n    /** \n     *  Unknown capability status. This is usually because we lack the \n     *  capability info which is retrieved from capability header specified\n     *  in the dialog messages.\n     */\n    PJSIP_DIALOG_CAP_UNKNOWN\t    = 2\n} pjsip_dialog_cap_status;\n\n\n/**\n * This structure describes the dialog structure. Application MUST NOT\n * try to SET the values here directly, but instead it MUST use the\n * appropriate dialog API. The dialog declaration only needs to be made \n * visible because other PJSIP modules need to see it (e.g. INVITE session,\n * the event framework, etc.).\n *\n * Application MAY READ the dialog contents directly after it acquires\n * dialog lock.\n *\n * To acquire dialog lock, use #pjsip_dlg_inc_lock(), and to release it,\n * use #pjsip_dlg_dec_lock(). DO NOT USE pj_mutex_lock()/pj_mutex_unlock()\n * on the dialog's mutex directly, because this will not protect against\n * dialog being destroyed.\n */\nstruct pjsip_dialog\n{\n    /** The dialog set list. */\n    PJ_DECL_LIST_MEMBER(pjsip_dialog);\n\n    /* Dialog's system properties. */\n    char\t\tobj_name[PJ_MAX_OBJ_NAME];  /**< Standard id.\t    */\n    pj_pool_t\t       *pool;\t    /**< Dialog's pool.\t\t\t    */\n    pjsip_user_agent   *ua;\t    /**< User agent instance.\t\t    */\n    pjsip_endpoint     *endpt;\t    /**< Endpoint instance.\t\t    */\n    pj_grp_lock_t      *grp_lock_;  /**< Dialog's grp lock. Do not call!!\n\t\t\t\t\t Use pjsip_dlg_inc_lock() instead!  */\n\n    /** The dialog set which this dialog belongs (opaque type). */\n    void\t       *dlg_set;\n\n    /* Dialog's session properties. */\n    pjsip_dialog_state\tstate;\t    /**< Dialog state.\t\t\t    */\n    pjsip_uri\t       *target;\t    /**< Current target.\t\t    */\n    pjsip_target_set\ttarget_set; /**< Target set, for UAC only.\t    */\n    pjsip_hdr\t        inv_hdr;    /**< Headers from hparam in dest URL    */\n    pjsip_dlg_party     local;\t    /**< Local party info.\t\t    */\n    pjsip_dlg_party     remote;\t    /**< Remote party info.\t\t    */\n    pjsip_hdr\t\trem_cap_hdr;/**< List of remote capability header.  */\n    pjsip_role_e\trole;\t    /**< Initial role.\t\t\t    */\n    pj_bool_t\t\tuac_has_2xx;/**< UAC has received 2xx response?\t    */\n    pj_bool_t\t\tsecure;\t    /**< Use secure transport?\t\t    */\n    pj_bool_t\t\tadd_allow;  /**< Add Allow header in requests?\t    */\n    pjsip_cid_hdr      *call_id;    /**< Call-ID header.\t\t    */\n    pjsip_route_hdr\troute_set;  /**< Route set.\t\t\t    */\n    pj_bool_t\t\troute_set_frozen; /**< Route set has been set.\t    */\n    pjsip_auth_clt_sess\tauth_sess;  /**< Client authentication session.\t    */\n    pj_str_t\t\tinitial_dest;/**< Initial destination host.  \t    */\n\n    /** Session counter. */\n    int\t\t\tsess_count; /**< Number of sessions.\t\t    */\n\n    /** Transaction counter. */\n    int\t\t\ttsx_count;  /**< Number of pending transactions.    */\n\n    /** Transport selector. */\n    pjsip_tpselector\ttp_sel;\n\n    /* Dialog usages. */\n    unsigned\t\tusage_cnt;  /**< Number of registered usages.\t    */\n    pjsip_module       *usage[PJSIP_MAX_MODULE]; /**< Array of usages, \n\t\t\t\t\t priority sorted\t\t    */\n\n    /** Module specific data. */\n    void\t       *mod_data[PJSIP_MAX_MODULE]; /**< Module data.\t    */\n\n    /**\n     * If via_addr is set, it will be used as the \"sent-by\" field of the\n     * Via header for outgoing requests as long as the request uses via_tp\n     * transport. Normally application should not use or access these fields.\n     */\n    pjsip_host_port     via_addr;   /**< Via address.\t                    */\n    const void         *via_tp;     /**< Via transport.\t                    */\n};\n\n/**\n * The parameter for \\a pjsip_dlg_create_uac2().\n */\ntypedef struct pjsip_dlg_create_uac_param {\n    /**\n     * The user agent module instance.\n     */\n    pjsip_user_agent *ua;\n\n    /**\n     * Dialog local URI (i.e. From header).\n     */\n    pj_str_t local_uri;\n\n    /**\n     * Optional dialog local Contact to be put as Contact header value,\n     * hence the format must follow RFC 3261 Section 20.10:\n     * When the header field value contains a display name, the URI including\n     * all URI parameters is enclosed in \"<\" and \">\".  If no \"<\" and \">\" are\n     * present, all parameters after the URI are header parameters, not\n     * URI parameters.  The display name can be tokens, or a quoted string,\n     * if a larger character set is desired. If this argument is NULL,\n     * the Contact will be taken from the local URI.\n     */\n    pj_str_t local_contact;\n\n    /**\n     * Dialog remote URI (i.e. To header).\n     */\n    pj_str_t remote_uri;\n\n    /**\n     * Optional initial remote target. If this argument is NULL, the initial \n     * target will be set to remote URI.\n     */\n    pj_str_t target;\n\n    /**\n     * Optional group lock to use by this dialog. If the value is NULL, \n     * the dialog will create its own group lock.\n     */\n    pj_grp_lock_t *grp_lock;\n\n} pjsip_dlg_create_uac_param;\n\n\n/**\n * This utility function returns PJ_TRUE if the specified method is a\n * dialog creating request. This method property is used to determine\n * whether Contact header should be included in outgoing request.\n *\n * @param m\t\tThe SIP method.\n *\n * @return\t\tPJ_TRUE if the method creates a dialog.\n */\nPJ_DECL(pj_bool_t) pjsip_method_creates_dialog(const pjsip_method *m);\n\n/**\n * Create a new dialog and return the instance in p_dlg parameter. \n * After creating  the dialog, application can add modules as dialog usages\n * by calling  #pjsip_dlg_add_usage(). \n *\n * If the request has To tag parameter, dialog's local tag will be initialized \n * from this value. Otherwise a globally unique id generator will be invoked to\n * create dialog's local tag.\n *\n * This function also initializes the dialog's route set based on the \n * Record-Route headers in the request, if present.\n *\n * Note that initially, the session count in the dialog will be initialized \n * to zero.\n *\n * @param ua\t\t    The user agent module instance.\n * @param local_uri\t    Dialog local URI (i.e. From header).\n * @param local_contact\t    Optional dialog local Contact to be put as Contact\n *\t\t\t    header value, hence the format must follow\n *\t\t\t    RFC 3261 Section 20.10:\n *\t\t\t    When the header field value contains a display \n *\t\t\t    name, the URI including all URI parameters is \n *\t\t\t    enclosed in \"<\" and \">\".  If no \"<\" and \">\" are \n *\t\t\t    present, all parameters after the URI are header\n *\t\t\t    parameters, not URI parameters.  The display name \n *\t\t\t    can be tokens, or a quoted string, if a larger \n *\t\t\t    character set is desired.\n *\t\t\t    If this argument is NULL, the Contact will be taken\n *\t\t\t    from the local URI.\n * @param remote_uri\t    Dialog remote URI (i.e. To header).\n * @param target\t    Optional initial remote target. If this argument\n *\t\t\t    is NULL, the initial target will be set to\n *\t\t\t    remote URI.\n * @param p_dlg\t\t    Pointer to receive the dialog.\n *\n * @return\t\t    PJ_SUCCESS on success.\n */\nPJ_DECL(pj_status_t) pjsip_dlg_create_uac( pjsip_user_agent *ua,\n\t\t\t\t\t   const pj_str_t *local_uri,\n\t\t\t\t\t   const pj_str_t *local_contact,\n\t\t\t\t\t   const pj_str_t *remote_uri,\n\t\t\t\t\t   const pj_str_t *target,\n\t\t\t\t\t   pjsip_dialog **p_dlg);\n\n/**\n * Variant of pjsip_dlg_create_uac() with additional parameter to specify\n * the group lock to use. Group lock can be used to synchronize locking\n * among several objects to prevent deadlock, and to synchronize the\n * lifetime of objects sharing the same group lock.\n *\n * See \\a pjsip_dlg_create_uac() for general info about this function.\n *\n * @param param\t\t    The parameter, refer to\n *\t\t\t    \\a pjsip_dlg_create_uac_param\n * @param p_dlg\t\t    Pointer to receive the dialog.\n *\n * @return\t\t    PJ_SUCCESS on success.\n */\nPJ_DECL(pj_status_t) pjsip_dlg_create_uac2(\n\t\t\t\tconst pjsip_dlg_create_uac_param *create_param,\n\t\t\t\tpjsip_dialog **p_dlg);\n\n\n#if !DEPRECATED_FOR_TICKET_1902\n/**\n * Initialize UAS dialog from the information found in the incoming request \n * that creates a dialog (such as INVITE, REFER, or SUBSCRIBE), and set the \n * local Contact to contact. If contact is not specified, the local contact \n * is initialized from the URI in the To header in the request. \n *\n * This function will also create UAS transaction for the incoming request,\n * and associate the transaction to the rdata. Application can query the\n * transaction used to handle this request by calling #pjsip_rdata_get_tsx()\n * after this function returns.\n *\n * Note that initially, the session count in the dialog will be initialized \n * to zero.\n *\n *\n * @param ua\t\t    The user agent module instance.\n * @param rdata\t\t    The incoming request that creates the dialog,\n *\t\t\t    such as INVITE, SUBSCRIBE, or REFER.\n * @param contact\t    Optional dialog local Contact to be put as Contact\n *\t\t\t    header value, hence the format must follow\n *\t\t\t    RFC 3261 Section 20.10:\n *\t\t\t    When the header field value contains a display \n *\t\t\t    name, the URI including all URI parameters is \n *\t\t\t    enclosed in \"<\" and \">\".  If no \"<\" and \">\" are \n *\t\t\t    present, all parameters after the URI are header\n *\t\t\t    parameters, not URI parameters.  The display name \n *\t\t\t    can be tokens, or a quoted string, if a larger \n *\t\t\t    character set is desired.\n *\t\t\t    If this argument is NULL, the local contact will be\n *\t\t\t    initialized from the value of To header in the\n *\t\t\t    request.\n * @param p_dlg\t\t    Pointer to receive the dialog.\n *\n * @return\t\t    PJ_SUCCESS on success.\n */\nPJ_DECL(pj_status_t) pjsip_dlg_create_uas(  pjsip_user_agent *ua,\n\t\t\t\t\t    pjsip_rx_data *rdata,\n\t\t\t\t\t    const pj_str_t *contact,\n\t\t\t\t\t    pjsip_dialog **p_dlg);\n#endif\n\n\n/**\n * Initialize UAS dialog from the information found in the incoming request \n * that creates a dialog (such as INVITE, REFER, or SUBSCRIBE), and set the \n * local Contact to contact. If contact is not specified, the local contact \n * is initialized from the URI in the To header in the request. \n *\n * This function will also create UAS transaction for the incoming request,\n * and associate the transaction to the rdata. Application can query the\n * transaction used to handle this request by calling #pjsip_rdata_get_tsx()\n * after this function returns.\n *\n * Note that initially, the session count in the dialog will be initialized \n * to 1 (one), and the dialog is locked. Application needs to explicitly call\n * #pjsip_dlg_dec_lock() to release the lock and decrease the session count.\n *\n *\n * @param ua\t\t    The user agent module instance.\n * @param rdata\t\t    The incoming request that creates the dialog,\n *\t\t\t    such as INVITE, SUBSCRIBE, or REFER.\n * @param contact\t    Optional dialog local Contact to be put as Contact\n *\t\t\t    header value, hence the format must follow\n *\t\t\t    RFC 3261 Section 20.10:\n *\t\t\t    When the header field value contains a display \n *\t\t\t    name, the URI including all URI parameters is \n *\t\t\t    enclosed in \"<\" and \">\".  If no \"<\" and \">\" are \n *\t\t\t    present, all parameters after the URI are header\n *\t\t\t    parameters, not URI parameters.  The display name \n *\t\t\t    can be tokens, or a quoted string, if a larger \n *\t\t\t    character set is desired.\n *\t\t\t    If this argument is NULL, the local contact will be\n *\t\t\t    initialized from the value of To header in the\n *\t\t\t    request.\n * @param p_dlg\t\t    Pointer to receive the dialog.\n *\n * @return\t\t    PJ_SUCCESS on success.\n */\nPJ_DECL(pj_status_t)\npjsip_dlg_create_uas_and_inc_lock(    pjsip_user_agent *ua,\n\t\t\t\t      pjsip_rx_data *rdata,\n\t\t\t\t      const pj_str_t *contact,\n\t\t\t\t      pjsip_dialog **p_dlg);\n\n\n/**\n * Lock/bind dialog to a specific transport/listener. This is optional,\n * as normally transport will be selected automatically based on the \n * destination of messages upon resolver completion. When the dialog is \n * explicitly bound to the specific transport/listener, all transactions\n * originated by this dialog will use the specified transport/listener\n * when sending outgoing requests.\n *\n * Note that this doesn't affect the Contact header generated by this\n * dialog. Application must manually update the Contact header if\n * necessary, to adjust the address according to the transport being\n * selected.\n *\n * @param dlg\t    The dialog instance.\n * @param sel\t    Transport selector containing the specification of\n *\t\t    transport or listener to be used by this dialog\n *\t\t    to send requests.\n *\n * @return\t    PJ_SUCCESS on success, or the appropriate error code.\n */\nPJ_DECL(pj_status_t) pjsip_dlg_set_transport(pjsip_dialog *dlg,\n\t\t\t\t\t     const pjsip_tpselector *sel);\n\n\n/**\n * Set the \"sent-by\" field of the Via header for outgoing requests.\n *\n * @param dlg\t    The dialog instance.\n * @param via_addr  Set via_addr to use for the Via header or NULL to use\n *                  the transport's published name.\n * @param via_tp    via_addr will only be used if we are using via_tp\n *                  transport.\n *\n * @return\t    PJ_SUCCESS on success.\n */\nPJ_DECL(pj_status_t) pjsip_dlg_set_via_sent_by(pjsip_dialog *dlg,\n\t\t\t\t               pjsip_host_port *via_addr,\n                                               pjsip_transport *via_tp);\n\n\n/**\n * Create a new (forked) dialog on receipt on forked response in rdata. \n * The new dialog will be created from original_dlg, except that it will have\n * new remote tag as copied from the To header in the response. Upon return, \n * the new_dlg will have been registered to the user agent. Applications just \n * need to add modules as dialog's usages.\n *\n * Note that initially, the session count in the dialog will be initialized \n * to zero.\n *\n * @param original_dlg\t    The original UAC dialog.\n * @param rdata\t\t    The incoming forked response message.\n * @param new_dlg\t    Pointer to receive the new dialog.\n *\n * @return\t\t    PJ_SUCCESS on success.\n */\nPJ_DECL(pj_status_t) pjsip_dlg_fork(const pjsip_dialog *original_dlg,\n\t\t\t\t    const pjsip_rx_data *rdata,\n\t\t\t\t    pjsip_dialog **new_dlg );\n\n/**\n * Forcefully terminate the dialog. Application can only call this function\n * when there is no session associated to the dialog. If there are sessions\n * that use this dialog, this function will refuse to terminate the dialog.\n * For this case, application MUST call the appropriate termination function \n * for each dialog session (e.g. #pjsip_inv_terminate() to terminate INVITE\n * session).\n *\n * @param dlg\t\t    The dialog.\n *\n * @return\t\t    PJ_SUCCESS if dialog has been terminated.\n */\nPJ_DECL(pj_status_t) pjsip_dlg_terminate( pjsip_dialog *dlg );\n\n\n/**\n * Set dialog's initial route set to route_set list. This can only be called\n * for UAC dialog, before any request is sent. After dialog has been \n * established, the route set can not be changed.\n *\n * For UAS dialog, the route set will be initialized in\n * pjsip_dlg_create_uas_and_inc_lock() from the Record-Route headers in\n * the incoming request.\n *\n * The route_set argument is standard list of Route headers (i.e. with \n * sentinel).\n *\n * @param dlg\t\t    The UAC dialog.\n * @param route_set\t    List of Route header.\n *\n * @return\t\t    PJ_SUCCESS on success.\n */\nPJ_DECL(pj_status_t) pjsip_dlg_set_route_set( pjsip_dialog *dlg,\n\t\t\t\t\t      const pjsip_route_hdr *route_set );\n\n/**\n * Increment the number of sessions in the dialog. Note that initially \n * (after created) the dialog has the session counter set to zero.\n *\n * @param dlg\t\t    The dialog.\n * @param mod\t\t    The module that increments the session counter.\n *\n * @return\t\t    PJ_SUCCESS on success.\n */\nPJ_DECL(pj_status_t) pjsip_dlg_inc_session( pjsip_dialog *dlg,\n\t\t\t\t\t    pjsip_module *mod);\n\n\n/**\n * Decrement the number of sessions in the dialog. Once the session counter \n * reach zero and there is no pending transaction, the dialog will be \n * destroyed. Note that this function may destroy the dialog immediately \n * if there is no pending transaction when this function is called.\n *\n * @param dlg\t\t    The dialog.\n * @param mod\t\t    The module that decrements the session counter.\n *\n * @return\t\t    PJ_SUCCESS on success.\n */\nPJ_DECL(pj_status_t) pjsip_dlg_dec_session( pjsip_dialog *dlg,\n\t\t\t\t\t    pjsip_module *mod);\n\n/**\n * Add a module as dialog usage, and optionally set the module specific data.\n *\n * @param dlg\t\t    The dialog.\n * @param module\t    The module to be registered as dialog usage.\n * @param mod_data\t    Optional arbitrary data to be attached to dialog's\n *\t\t\t    mod_data array at the module's index.\n *\n * @return\t\t    PJ_SUCCESS on success.\n */\nPJ_DECL(pj_status_t) pjsip_dlg_add_usage( pjsip_dialog *dlg,\n\t\t\t\t\t  pjsip_module *module,\n\t\t\t\t\t  void *mod_data );\n\n/**\n * Check if the specified module has been registered as usage to the dialog.\n *\n * @param dlg\t\t    The dialog.\n * @param module\t    The module.\n *\n * @return\t\t    PJ_TRUE if the specified module is currently\n * \t\t\t    registered as a usage to the dialog.\n */\nPJ_DECL(pj_bool_t) pjsip_dlg_has_usage(pjsip_dialog *dlg,\n\t\t\t\t       pjsip_module *module);\n\n/**\n * Attach module specific data to the dialog. Application can also set \n * the value directly by accessing dlg->mod_data[module_id].\n *\n * @param dlg\t\t    The dialog\n * @param mod_id\t    The ID of the module from which the data is to be\n *\t\t\t    set to the dialog.\n * @param data\t\t    Arbitrary data.\n *\n * @return\t\t    PJ_SUCCESS on success.\n */\nPJ_DECL(pj_status_t) pjsip_dlg_set_mod_data( pjsip_dialog *dlg,\n\t\t\t\t\t     int mod_id,\n\t\t\t\t\t     void *data );\n\n/**\n * Get module specific data previously attached to the dialog. Application\n * can also get value directly by accessing dlg->mod_data[module_id].\n *\n * @param dlg\t\t    The dialog\n * @param mod_id\t    The ID of the module from which the data is to be\n *\t\t\t    retrieved from the dialog.\n *\n * @return\t\t    The data that was previously set, or NULL.\n */\nPJ_DECL(void*) pjsip_dlg_get_mod_data( pjsip_dialog *dlg,\n\t\t\t\t       int mod_id);\n\n\n/**\n * Lock dialog and increment session counter termporarily, to prevent it \n * from being destroyed.\n *\n * @param dlg\t\t    The dialog.\n */\nPJ_DECL(void) pjsip_dlg_inc_lock( pjsip_dialog *dlg );\n\n/**\n * Try to acquire dialog's lock, but return immediately if lock can not\n * be acquired.\n *\n * @param dlg\t\t    The dialog.\n *\n * @return\t\t    PJ_SUCCESS if lock has been acquired.\n */\nPJ_DECL(pj_status_t) pjsip_dlg_try_inc_lock( pjsip_dialog *dlg );\n\n/**\n * Unlock dialog and decrement temporary session counter. After this function\n * is called, dialog may be destroyed.\n *\n * @param dlg\t\t    The dialog.\n */\nPJ_DECL(void) pjsip_dlg_dec_lock( pjsip_dialog *dlg );\n\n/**\n * Get the group lock for the SIP dialog. Note that prior to calling this\n * method, it is recommended to hold reference to the dialog\n * (e.g: call #pjsip_dlg_inc_session() or #pjsip_dlg_inc_lock()).\n *\n * @param dlg\t\t    The dialog.\n *\n * @return\t\t    The group lock.\n */\nPJ_DECL(pj_grp_lock_t *) pjsip_dlg_get_lock( pjsip_dialog *dlg );\n\n\n/**\n * Get the dialog instance in the incoming rdata. If an incoming message \n * matches an existing dialog, the user agent must have put the matching \n * dialog instance in the rdata, or otherwise this function will return \n * NULL if the message didn't match any existing dialog.\n *\n * This function can only be called after endpoint distributes the message\n * to the transaction layer or UA layer. In other words, application can\n * only call this function in the context of module that runs in priority\n * number higher than PJSIP_MOD_PRIORITY_UA_PROXY_LAYER.\n *\n * @param rdata\t\t    Incoming message buffer.\n *\n * @return\t\t    The dialog instance that \"owns\" the message.\n */\nPJ_DECL(pjsip_dialog*) pjsip_rdata_get_dlg( pjsip_rx_data *rdata );\n\n/**\n * Get the dialog instance for the outgoing tdata. Returns NULL if the message\n * wasn't sent from a dialog.\n *\n * @param tdata\t\t    Outgoing message buffer.\n *\n * @return\t\t    The dialog instance that \"owns\" the message.\n */\nPJ_DECL(pjsip_dialog*) pjsip_tdata_get_dlg( pjsip_tx_data *tdata );\n\n/**\n * Get the associated dialog for the specified transaction, if any.\n *\n * @param tsx\t\t    The transaction.\n *\n * @return\t\t    The dialog instance which has been registered\n *\t\t\t    to the transaction as transaction user, or\n *\t\t\t    NULL if the transaction is outside any dialogs.\n */\nPJ_DECL(pjsip_dialog*) pjsip_tsx_get_dlg( pjsip_transaction *tsx );\n\n\n/**\n * Create a basic/generic request with the specified method and optionally\n * specify the cseq. Use value -1 for cseq to have the dialog automatically\n * put next cseq number for the request. Otherwise for some requests, \n * e.q. CANCEL and ACK, application must put the CSeq in the original \n * INVITE request as the parameter. \n *\n * This function will also put Contact header where appropriate.\n *\n * @param dlg\t\t    The dialog instance.\n * @param method\t    The method of the request.\n * @param cseq\t\t    Optional CSeq, which only needs to be specified\n *\t\t\t    when creating ACK and CANCEL. For other requests,\n *\t\t\t    specify -1 to use dialog's internal counter.\n * @param tdata\t\t    Pointer to receive the request's transmit\n *\t\t\t    data buffer.\n *\n * @return\t\t    PJ_SUCCESS on success.\n */\nPJ_DECL(pj_status_t) pjsip_dlg_create_request(\tpjsip_dialog *dlg,\n\t\t\t\t\t\tconst pjsip_method *method,\n\t\t\t\t\t\tint cseq,\n\t\t\t\t\t\tpjsip_tx_data **tdata);\n\n\n/**\n * Send request message to remote peer. If the request is not an ACK request, \n * the dialog will send the request statefully, by creating an UAC transaction\n * and send the request with the transaction. \n *\n * Also when the request is not ACK or CANCEL, the dialog will increment its\n * local cseq number and update the cseq in the request according to dialog's \n * cseq.\n *\n * If p_tsx is not null, this argument will be set with the transaction \n * instance that was used to send the request.\n *\n * This function will decrement the transmit data's reference counter\n * regardless the status of the operation.\n *\n * @param dlg\t\t    The dialog.\n * @param tdata\t\t    The request message to be sent.\n * @param mod_data_id\t    Optional module data index to put an optional data\n *\t\t\t    into the transaction. If no module data is to be\n *\t\t\t    attached, this value should be -1.\n * @param mod_data\t    Optional module data to be attached to the \n *\t\t\t    transaction at mod_data_id index.\n *\n * @return\t\t    PJ_SUCCESS on success.\n */\nPJ_DECL(pj_status_t) pjsip_dlg_send_request (\tpjsip_dialog *dlg,\n\t\t\t\t\t\tpjsip_tx_data *tdata,\n\t\t\t\t\t\tint mod_data_id,\n\t\t\t\t\t\tvoid *mod_data);\n\n\n/**\n * Create a response message for the incoming request in rdata with status\n * code st_code and optional status text st_text. This function is different\n * than endpoint's API #pjsip_endpt_create_response() in that the dialog \n * function adds Contact header and Record-Routes headers in the response \n * where appropriate.\n *\n * @param dlg\t\t    The dialog.\n * @param rdata\t\t    The incoming request message for which the\n *\t\t\t    response will be created.\n * @param st_code\t    Status code.\n * @param st_text\t    Optional string for custom status reason text.\n * @param tdata\t\t    Pointer to receive the response message transmit\n *\t\t\t    data buffer.\n *\n * @return\t\t    PJ_SUCCESS on success.\n */\nPJ_DECL(pj_status_t) pjsip_dlg_create_response(\tpjsip_dialog *dlg,\n\t\t\t\t\t\tpjsip_rx_data *rdata,\n\t\t\t\t\t\tint st_code,\n\t\t\t\t\t\tconst pj_str_t *st_text,\n\t\t\t\t\t\tpjsip_tx_data **tdata);\n\n\n/**\n * Modify previously sent response with other status code. Contact header \n * will be added when appropriate.\n *\n * @param dlg\t\t    The dialog.\n * @param tdata\t\t    The transmit data buffer containing response\n *\t\t\t    message to be modified.\n * @param st_code\t    New status code to be set.\n * @param st_text\t    Optional string for custom status reason text.\n *\n * @return\t\t    PJ_SUCCESS on success.\n */\nPJ_DECL(pj_status_t) pjsip_dlg_modify_response(\tpjsip_dialog *dlg,\n\t\t\t\t\t\tpjsip_tx_data *tdata,\n\t\t\t\t\t\tint st_code,\n\t\t\t\t\t\tconst pj_str_t *st_text);\n\n\n/**\n * Send response message statefully. The transaction instance MUST be the \n * transaction that was reported on on_rx_request() callback.\n *\n * This function decrements the transmit data's reference counter regardless\n * the status of the operation.\n *\n * @param dlg\t\t    The dialog.\n * @param tsx\t\t    The UAS transaction associated with the incoming\n *\t\t\t    request. If the request is within a dialog, or\n *\t\t\t    a dialog has been created for the request that\n *\t\t\t    creates the dialog, application can get the\n *\t\t\t    transaction instance for the request by calling\n *\t\t\t    #pjsip_rdata_get_tsx().\n * @param tdata\t\t    Response message to be sent.\n *\n * @return\t\t    PJ_SUCCESS on success.\n */\nPJ_DECL(pj_status_t) pjsip_dlg_send_response(\tpjsip_dialog *dlg,\n\t\t\t\t\t\tpjsip_transaction *tsx,\n\t\t\t\t\t\tpjsip_tx_data *tdata);\n\n\n/**\n * This composite function sends response message statefully to an incoming\n * request message inside dialog.\n *\n * @param dlg\t    The endpoint instance.\n * @param rdata\t    The incoming request message.\n * @param st_code   Status code of the response.\n * @param st_text   Optional status text of the response.\n * @param hdr_list  Optional header list to be added to the response.\n * @param body\t    Optional message body to be added to the response.\n *\n * @return\t    PJ_SUCCESS if response message has successfully been\n *\t\t    sent.\n */\nPJ_DECL(pj_status_t) pjsip_dlg_respond( pjsip_dialog *dlg,\n\t\t\t\t\tpjsip_rx_data *rdata,\n\t\t\t\t\tint st_code,\n\t\t\t\t\tconst pj_str_t *st_text,\n\t\t\t\t\tconst pjsip_hdr *hdr_list,\n\t\t\t\t\tconst pjsip_msg_body *body );\n\n\n/**\n * Check if remote peer have the specified capability as published\n * in the dialog messages from remote peer.\n *\n * Notes:\n * - The capability \\a token lookup will apply exact match, but not \n *   case-sensitive, for example: <tt>\"text/html\"</tt> will not match \n *   <tt>\"text / html\"</tt> (notice the spaces).\n *\n * @param dlg\t    The dialog.\n * @param htype\t    The header type to be checked, which value may be:\n *\t\t    - PJSIP_H_ACCEPT\n *\t\t    - PJSIP_H_ALLOW\n *\t\t    - PJSIP_H_SUPPORTED\n * @param hname\t    If htype specifies PJSIP_H_OTHER, then the header name\n *\t\t    must be supplied in this argument. Otherwise the value\n *\t\t    must be set to NULL.\n * @param token\t    The capability token to check. For example, if \\a htype\n *\t\t    is PJSIP_H_ALLOW, then \\a token specifies the method\n *\t\t    names; if \\a htype is PJSIP_H_SUPPORTED, then \\a token\n *\t\t    specifies the extension names such as \"100rel\".\n *\n * @return\t    PJSIP_DIALOG_CAP_SUPPORTED if the specified capability\n *\t\t    is explicitly supported, see @pjsip_dialog_cap_status\n *\t\t    for more info.\n */\nPJ_DECL(pjsip_dialog_cap_status) pjsip_dlg_remote_has_cap(\n\t\t\t\t\t\t    pjsip_dialog *dlg,\n\t\t\t\t\t\t    int htype,\n\t\t\t\t\t\t    const pj_str_t *hname,\n\t\t\t\t\t\t    const pj_str_t *token);\n\n/**\n * Get the specified capability header from the remote capability headers\n * stored in the dialog.\n *\n * @param dlg\t    The dialog.\n * @param htype\t    The header type to be retrieved, which value may be:\n *\t\t    - PJSIP_H_ACCEPT\n *\t\t    - PJSIP_H_ALLOW\n *\t\t    - PJSIP_H_SUPPORTED\n * @param hname\t    If htype specifies PJSIP_H_OTHER, then the header name\n *\t\t    must be supplied in this argument. Otherwise the value\n *\t\t    must be set to NULL.\n *\n * @return\t    The appropriate header, or NULL if the header is not\n *\t\t    available.\n */\nPJ_DECL(const pjsip_hdr*) pjsip_dlg_get_remote_cap_hdr(pjsip_dialog *dlg,\n\t\t\t\t\t\t       int htype,\n\t\t\t\t\t\t       const pj_str_t *hname);\n\n/**\n * Set remote capability from a SIP header containing array of capability \n * tags/values.\n *\n * @param dlg\t    The dialog.\n * @param cap_hdr   The SIP header.\n *\n * @return\t    PJ_SUCCESS when successful, otherwise the appropriate\n *\t\t    error code will be returned.\n */\nPJ_DECL(pj_status_t) pjsip_dlg_set_remote_cap_hdr(\n\t\t\t\t    pjsip_dialog *dlg,\n\t\t\t\t    const pjsip_generic_array_hdr *cap_hdr);\n\n/**\n * Remove a remote capability header.\n *\n * @param dlg\t    The dialog.\n * @param htype\t    The header type to be removed, which value may be:\n *\t\t    - PJSIP_H_ACCEPT\n *\t\t    - PJSIP_H_ALLOW\n *\t\t    - PJSIP_H_SUPPORTED\n * @param hname\t    If htype specifies PJSIP_H_OTHER, then the header name\n *\t\t    must be supplied in this argument. Otherwise the value\n *\t\t    must be set to NULL.\n *\n * @return\t    PJ_SUCCESS when successful, otherwise the appropriate\n *\t\t    error code will be returned.\n */\nPJ_DECL(pj_status_t) pjsip_dlg_remove_remote_cap_hdr(pjsip_dialog *dlg,\n\t\t\t\t\t\t     int htype,\n\t\t\t\t\t\t     const pj_str_t *hname);\n\n/**\n * Update remote capabilities from a received message. The header types\n * to be updated from the message will only be \\a PJSIP_H_ACCEPT, \n * \\a PJSIP_H_ALLOW, and \\a PJSIP_H_SUPPORTED.\n *\n * @param dlg\t    The dialog.\n * @param msg\t    The received message.\n * @param strict    If this is set to PJ_TRUE, any header types missing\n *\t\t    from the message will cause removal of existing\n *\t\t    header types in the capability list. Otherwise, the \n *\t\t    capability list will not be modified when any header\n *                  type is missing.\n *\n * @return\t    PJ_SUCCESS when successful, otherwise the appropriate\n *\t\t    error code will be returned.\n */\nPJ_DECL(pj_status_t) pjsip_dlg_update_remote_cap(pjsip_dialog *dlg,\n\t\t\t\t\t         const pjsip_msg *msg,\n\t\t\t\t\t\t pj_bool_t strict);\n\n\n\n/**\n * @}\n */\n\n/* \n * Internal (called by sip_ua_layer.c)\n */\n\n/* Receives transaction event (called by user_agent module) */\nvoid pjsip_dlg_on_tsx_state( pjsip_dialog *dlg,\n\t\t\t     pjsip_transaction *tsx,\n\t\t\t     pjsip_event *e );\n\nvoid pjsip_dlg_on_rx_request( pjsip_dialog *dlg,\n\t\t\t      pjsip_rx_data *rdata );\n\nvoid pjsip_dlg_on_rx_response( pjsip_dialog *dlg,\n\t\t\t       pjsip_rx_data *rdata );\n\n\n\nPJ_END_DECL\n\n\n#endif\t/* __PJSIP_SIP_DIALOG_H__ */\n\n", "/* $Id$ */\n/*\n * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)\n * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n#include <pjsip/sip_dialog.h>\n#include <pjsip/sip_ua_layer.h>\n#include <pjsip/sip_errno.h>\n#include <pjsip/sip_endpoint.h>\n#include <pjsip/sip_parser.h>\n#include <pjsip/sip_module.h>\n#include <pjsip/sip_util.h>\n#include <pjsip/sip_transaction.h>\n#include <pj/assert.h>\n#include <pj/os.h>\n#include <pj/string.h>\n#include <pj/pool.h>\n#include <pj/guid.h>\n#include <pj/rand.h>\n#include <pj/array.h>\n#include <pj/except.h>\n#include <pj/hash.h>\n#include <pj/log.h>\n\n#define THIS_FILE\t\"sip_dialog.c\"\n\nlong pjsip_dlg_lock_tls_id;\n\n/* Config */\npj_bool_t pjsip_include_allow_hdr_in_dlg = PJSIP_INCLUDE_ALLOW_HDR_IN_DLG;\n\n/* Contact header string */\nstatic const pj_str_t HCONTACT = { \"Contact\", 7 };\n\n\nPJ_DEF(pj_bool_t) pjsip_method_creates_dialog(const pjsip_method *m)\n{\n    const pjsip_method subscribe = { PJSIP_OTHER_METHOD, {\"SUBSCRIBE\", 9}};\n    const pjsip_method refer = { PJSIP_OTHER_METHOD, {\"REFER\", 5}};\n    const pjsip_method notify = { PJSIP_OTHER_METHOD, {\"NOTIFY\", 6}};\n    const pjsip_method update = { PJSIP_OTHER_METHOD, {\"UPDATE\", 6}};\n\n    return m->id == PJSIP_INVITE_METHOD ||\n\t   (pjsip_method_cmp(m, &subscribe)==0) ||\n\t   (pjsip_method_cmp(m, &refer)==0) ||\n\t   (pjsip_method_cmp(m, &notify)==0) ||\n\t   (pjsip_method_cmp(m, &update)==0);\n}\n\nstatic void dlg_on_destroy( void *arg )\n{\n    pjsip_dialog *dlg = (pjsip_dialog *)arg;\n\n    PJ_LOG(5,(dlg->obj_name, \"Dialog destroyed!\"));\n\n    pjsip_endpt_release_pool(dlg->endpt, dlg->pool);\n}\n\nstatic pj_status_t create_dialog( pjsip_user_agent *ua,\n\t\t\t\t  pj_grp_lock_t *grp_lock,\n\t\t\t\t  pjsip_dialog **p_dlg)\n{\n    pjsip_endpoint *endpt;\n    pj_pool_t *pool;\n    pjsip_dialog *dlg;\n    pj_status_t status;\n\n    endpt = pjsip_ua_get_endpt(ua);\n    if (!endpt)\n\treturn PJ_EINVALIDOP;\n\n    pool = pjsip_endpt_create_pool(endpt, \"dlg%p\",\n\t\t\t\t   PJSIP_POOL_LEN_DIALOG,\n\t\t\t\t   PJSIP_POOL_INC_DIALOG);\n    if (!pool)\n\treturn PJ_ENOMEM;\n\n    dlg = PJ_POOL_ZALLOC_T(pool, pjsip_dialog);\n    PJ_ASSERT_RETURN(dlg != NULL, PJ_ENOMEM);\n\n    dlg->pool = pool;\n    pj_ansi_snprintf(dlg->obj_name, sizeof(dlg->obj_name), \"dlg%p\", dlg);\n    dlg->ua = ua;\n    dlg->endpt = endpt;\n    dlg->state = PJSIP_DIALOG_STATE_NULL;\n    dlg->add_allow = pjsip_include_allow_hdr_in_dlg;\n\n    pj_list_init(&dlg->inv_hdr);\n    pj_list_init(&dlg->rem_cap_hdr);\n\n    /* Init client authentication session. */\n    status = pjsip_auth_clt_init(&dlg->auth_sess, dlg->endpt,\n\t\t\t\t dlg->pool, 0);\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n\n    if (grp_lock) {\n\tdlg->grp_lock_ = grp_lock;\n    } else {\n \tstatus = pj_grp_lock_create(pool, NULL, &dlg->grp_lock_);\n \tif (status != PJ_SUCCESS) {\n\t    goto on_error;\n \t}\n    }\n\n    pj_grp_lock_add_ref(dlg->grp_lock_);\n    pj_grp_lock_add_handler(dlg->grp_lock_, pool, dlg, &dlg_on_destroy);\n\n    pjsip_target_set_init(&dlg->target_set);\n\n    *p_dlg = dlg;\n    return PJ_SUCCESS;\n\non_error:\n    pjsip_endpt_release_pool(endpt, pool);\n    return status;\n}\n\nstatic void destroy_dialog( pjsip_dialog *dlg, pj_bool_t unlock_mutex )\n{\n    if (dlg->tp_sel.type != PJSIP_TPSELECTOR_NONE) {\n\tpjsip_tpselector_dec_ref(&dlg->tp_sel);\n\tpj_bzero(&dlg->tp_sel, sizeof(pjsip_tpselector));\n    }\n    pjsip_auth_clt_deinit(&dlg->auth_sess);\n\n    pj_grp_lock_dec_ref(dlg->grp_lock_);\n\n    if (unlock_mutex)\n\tpj_grp_lock_release(dlg->grp_lock_);\n}\n\n/*\n * Create an UAC dialog.\n */\nPJ_DEF(pj_status_t) pjsip_dlg_create_uac( pjsip_user_agent *ua,\n\t\t\t\t\t  const pj_str_t *local_uri,\n\t\t\t\t\t  const pj_str_t *local_contact,\n\t\t\t\t\t  const pj_str_t *remote_uri,\n\t\t\t\t\t  const pj_str_t *target,\n\t\t\t\t\t  pjsip_dialog **p_dlg)\n{\n    pjsip_dlg_create_uac_param create_param;\n\n    PJ_ASSERT_RETURN(ua && local_uri && remote_uri && p_dlg, PJ_EINVAL);\n\n    pj_bzero(&create_param, sizeof(create_param));\n    create_param.ua = ua;\n    create_param.local_uri = *local_uri;\n    create_param.remote_uri = *remote_uri;\n    if (local_contact)\n\tcreate_param.local_contact = *local_contact;\n\n    if (target)\n\tcreate_param.target = *target;\n\n    return pjsip_dlg_create_uac2(&create_param, p_dlg);\n}\n\nPJ_DEF(pj_status_t) pjsip_dlg_create_uac2(\n\t\t\t\tconst pjsip_dlg_create_uac_param *create_param,\n\t\t\t\tpjsip_dialog **p_dlg)\n{\n    pj_status_t status;\n    pj_str_t tmp;\n    pjsip_dialog *dlg;\n\n    /* Check arguments. */\n    PJ_ASSERT_RETURN(create_param->ua && create_param->local_uri.slen &&\n\t\t     create_param->remote_uri.slen && p_dlg, PJ_EINVAL);\n\n    /* Create dialog instance. */\n    status = create_dialog(create_param->ua, create_param->grp_lock, &dlg);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Parse target. */\n    pj_strdup_with_null(dlg->pool, &tmp, create_param->target.slen ?\n\t\t\t&create_param->target : &create_param->remote_uri);\n    dlg->target = pjsip_parse_uri(dlg->pool, tmp.ptr, tmp.slen, 0);\n    if (!dlg->target) {\n\tstatus = PJSIP_EINVALIDURI;\n\tgoto on_error;\n    }\n\n    /* Put any header param in the target URI into INVITE header list. */\n    if (PJSIP_URI_SCHEME_IS_SIP(dlg->target) ||\n\tPJSIP_URI_SCHEME_IS_SIPS(dlg->target))\n    {\n\tpjsip_param *param;\n\tpjsip_sip_uri *uri = (pjsip_sip_uri*)pjsip_uri_get_uri(dlg->target);\n\n\tparam = uri->header_param.next;\n\twhile (param != &uri->header_param) {\n\t    if (param->value.ptr) {\n\t\tpjsip_hdr *hdr;\n\t\tint c;\n\n\t\tc = param->value.ptr[param->value.slen];\n\t\tparam->value.ptr[param->value.slen] = '\\0';\n\n\t\thdr = (pjsip_hdr*)\n\t\t    pjsip_parse_hdr(dlg->pool, &param->name, param->value.ptr,\n\t\t\t\t    param->value.slen, NULL);\n\n\t\tparam->value.ptr[param->value.slen] = (char)c;\n\n\t\tif (hdr == NULL) {\n\t\t    status = PJSIP_EINVALIDURI;\n\t\t    goto on_error;\n\t\t}\n\t\tpj_list_push_back(&dlg->inv_hdr, hdr);\n\t    }\n\n\t    param = param->next;\n\t}\n\n\t/* Now must remove any header params from URL, since that would\n\t * create another header in pjsip_endpt_create_request().\n\t */\n\tpj_list_init(&uri->header_param);\n    }\n\n    /* Add target to the target set */\n    pjsip_target_set_add_uri(&dlg->target_set, dlg->pool, dlg->target, 0);\n\n    /* Init local info. */\n    dlg->local.info = pjsip_from_hdr_create(dlg->pool);\n    pj_strdup_with_null(dlg->pool, &dlg->local.info_str,\n\t\t\t&create_param->local_uri);\n    dlg->local.info->uri = pjsip_parse_uri(dlg->pool,\n\t\t\t\t\t   dlg->local.info_str.ptr,\n\t\t\t\t\t   dlg->local.info_str.slen, 0);\n    if (!dlg->local.info->uri) {\n\tstatus = PJSIP_EINVALIDURI;\n\tgoto on_error;\n    }\n\n    /* Generate local tag. */\n    pj_create_unique_string(dlg->pool, &dlg->local.info->tag);\n\n    /* Calculate hash value of local tag. */\n    dlg->local.tag_hval = pj_hash_calc_tolower(0, NULL,\n                                               &dlg->local.info->tag);\n\n    /* Randomize local CSeq. */\n    dlg->local.first_cseq = pj_rand() & 0x7FFF;\n    dlg->local.cseq = dlg->local.first_cseq;\n\n    /* Init local contact. */\n    pj_strdup_with_null(dlg->pool, &tmp,\n\t\t    create_param->local_contact.slen ?\n\t\t    &create_param->local_contact : &create_param->local_uri);\n    dlg->local.contact = (pjsip_contact_hdr*)\n\t\t\t pjsip_parse_hdr(dlg->pool, &HCONTACT, tmp.ptr,\n\t\t\t\t\t tmp.slen, NULL);\n    if (!dlg->local.contact) {\n\tstatus = PJSIP_EINVALIDURI;\n\tgoto on_error;\n    }\n\n    /* Init remote info. */\n    dlg->remote.info = pjsip_to_hdr_create(dlg->pool);\n    pj_strdup_with_null(dlg->pool, &dlg->remote.info_str,\n\t\t\t&create_param->remote_uri);\n    dlg->remote.info->uri = pjsip_parse_uri(dlg->pool,\n\t\t\t\t\t    dlg->remote.info_str.ptr,\n\t\t\t\t\t    dlg->remote.info_str.slen, 0);\n    if (!dlg->remote.info->uri) {\n\tstatus = PJSIP_EINVALIDURI;\n\tgoto on_error;\n    }\n\n    /* Remove header param from remote.info_str, if any */\n    if (PJSIP_URI_SCHEME_IS_SIP(dlg->remote.info->uri) ||\n\tPJSIP_URI_SCHEME_IS_SIPS(dlg->remote.info->uri))\n    {\n\tpjsip_sip_uri *sip_uri = (pjsip_sip_uri *)\n\t\t\t\t pjsip_uri_get_uri(dlg->remote.info->uri);\n\tif (!pj_list_empty(&sip_uri->header_param)) {\n\t    pj_str_t tmp2;\n\n\t    /* Remove all header param */\n\t    pj_list_init(&sip_uri->header_param);\n\n\t    /* Print URI */\n\t    tmp2.ptr = (char*) pj_pool_alloc(dlg->pool,\n\t    \t\t\t\t    dlg->remote.info_str.slen);\n\t    tmp2.slen = pjsip_uri_print(PJSIP_URI_IN_FROMTO_HDR,\n\t\t\t\t       sip_uri, tmp2.ptr,\n\t\t\t\t       dlg->remote.info_str.slen);\n\n\t    if (tmp2.slen < 1) {\n\t\tstatus = PJSIP_EURITOOLONG;\n\t\tgoto on_error;\n\t    }\n\n\t    /* Assign remote.info_str */\n\t    dlg->remote.info_str = tmp2;\n\t}\n    }\n\n\n    /* Initialize remote's CSeq to -1. */\n    dlg->remote.cseq = dlg->remote.first_cseq = -1;\n\n    /* Initial role is UAC. */\n    dlg->role = PJSIP_ROLE_UAC;\n\n    /* Secure? */\n    dlg->secure = PJSIP_URI_SCHEME_IS_SIPS(dlg->target);\n\n    /* Generate Call-ID header. */\n    dlg->call_id = pjsip_cid_hdr_create(dlg->pool);\n    pj_create_unique_string(dlg->pool, &dlg->call_id->id);\n\n    /* Initial route set is empty. */\n    pj_list_init(&dlg->route_set);\n\n    /* Register this dialog to user agent. */\n    status = pjsip_ua_register_dlg( create_param->ua, dlg );\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n\n    /* Done! */\n    *p_dlg = dlg;\n\n    PJ_LOG(5,(dlg->obj_name, \"UAC dialog created\"));\n\n    return PJ_SUCCESS;\n\non_error:\n    destroy_dialog(dlg, PJ_FALSE);\n    return status;\n}\n\n\n/*\n * Create UAS dialog.\n */\npj_status_t create_uas_dialog( pjsip_user_agent *ua,\n\t\t\t       pjsip_rx_data *rdata,\n\t\t\t       const pj_str_t *contact,\n\t\t\t       pj_bool_t inc_lock,\n\t\t\t       pjsip_dialog **p_dlg)\n{\n    pj_status_t status;\n    pjsip_hdr *pos = NULL;\n    pjsip_contact_hdr *contact_hdr;\n    pjsip_rr_hdr *rr;\n    pjsip_transaction *tsx = NULL;\n    pj_str_t tmp;\n    enum { TMP_LEN=PJSIP_MAX_URL_SIZE };\n    pj_ssize_t len;\n    pjsip_dialog *dlg;\n    pj_bool_t lock_incremented = PJ_FALSE;\n\n    /* Check arguments. */\n    PJ_ASSERT_RETURN(ua && rdata && p_dlg, PJ_EINVAL);\n\n    /* rdata must have request message. */\n    PJ_ASSERT_RETURN(rdata->msg_info.msg->type == PJSIP_REQUEST_MSG,\n\t\t     PJSIP_ENOTREQUESTMSG);\n\n    /* Request must not have To tag.\n     * This should have been checked in the user agent (or application?).\n     */\n    PJ_ASSERT_RETURN(rdata->msg_info.to->tag.slen == 0, PJ_EINVALIDOP);\n\n    /* The request must be a dialog establishing request. */\n    PJ_ASSERT_RETURN(\n\tpjsip_method_creates_dialog(&rdata->msg_info.msg->line.req.method),\n\tPJ_EINVALIDOP);\n\n    /* Create dialog instance. */\n    status = create_dialog(ua, NULL, &dlg);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Temprary string for getting the string representation of\n     * both local and remote URI.\n     */\n    tmp.ptr = (char*) pj_pool_alloc(rdata->tp_info.pool, TMP_LEN);\n\n    /* Init local info from the To header. */\n    dlg->local.info = (pjsip_fromto_hdr*)\n    \t\t      pjsip_hdr_clone(dlg->pool, rdata->msg_info.to);\n    pjsip_fromto_hdr_set_from(dlg->local.info);\n\n    /* Generate local tag. */\n    pj_create_unique_string(dlg->pool, &dlg->local.info->tag);\n\n\n    /* Print the local info. */\n    len = pjsip_uri_print(PJSIP_URI_IN_FROMTO_HDR,\n\t\t\t  dlg->local.info->uri, tmp.ptr, TMP_LEN);\n    if (len < 1) {\n\tpj_ansi_strcpy(tmp.ptr, \"<-error: uri too long->\");\n\ttmp.slen = pj_ansi_strlen(tmp.ptr);\n    } else\n\ttmp.slen = len;\n\n    /* Save the local info. */\n    pj_strdup(dlg->pool, &dlg->local.info_str, &tmp);\n\n    /* Calculate hash value of local tag. */\n    dlg->local.tag_hval = pj_hash_calc_tolower(0, NULL, &dlg->local.info->tag);\n\n\n    /* Randomize local cseq */\n    dlg->local.first_cseq = pj_rand() & 0x7FFF;\n    dlg->local.cseq = dlg->local.first_cseq;\n\n    /* Init local contact. */\n    /* TODO:\n     *  Section 12.1.1, paragraph about using SIPS URI in Contact.\n     *  If the request that initiated the dialog contained a SIPS URI\n     *  in the Request-URI or in the top Record-Route header field value,\n     *  if there was any, or the Contact header field if there was no\n     *  Record-Route header field, the Contact header field in the response\n     *  MUST be a SIPS URI.\n     */\n    if (contact) {\n\tpj_str_t tmp2;\n\n\tpj_strdup_with_null(dlg->pool, &tmp2, contact);\n\tdlg->local.contact = (pjsip_contact_hdr*)\n\t\t\t     pjsip_parse_hdr(dlg->pool, &HCONTACT, tmp2.ptr,\n\t\t\t\t\t     tmp2.slen, NULL);\n\tif (!dlg->local.contact) {\n\t    status = PJSIP_EINVALIDURI;\n\t    goto on_error;\n\t}\n\n    } else {\n\tdlg->local.contact = pjsip_contact_hdr_create(dlg->pool);\n\tdlg->local.contact->uri = dlg->local.info->uri;\n    }\n\n    /* Init remote info from the From header. */\n    dlg->remote.info = (pjsip_fromto_hdr*)\n    \t\t       pjsip_hdr_clone(dlg->pool, rdata->msg_info.from);\n    pjsip_fromto_hdr_set_to(dlg->remote.info);\n\n    /* Print the remote info. */\n    len = pjsip_uri_print(PJSIP_URI_IN_FROMTO_HDR,\n\t\t\t  dlg->remote.info->uri, tmp.ptr, TMP_LEN);\n    if (len < 1) {\n\tpj_ansi_strcpy(tmp.ptr, \"<-error: uri too long->\");\n\ttmp.slen = pj_ansi_strlen(tmp.ptr);\n    } else\n\ttmp.slen = len;\n\n    /* Save the remote info. */\n    pj_strdup(dlg->pool, &dlg->remote.info_str, &tmp);\n    \n    /* Save initial destination host from transport's info */\n    pj_strdup(dlg->pool, &dlg->initial_dest,\n    \t      &rdata->tp_info.transport->remote_name.host);\n\n\n    /* Init remote's contact from Contact header.\n     * Iterate the Contact URI until we find sip: or sips: scheme.\n     */\n    do {\n\tcontact_hdr = (pjsip_contact_hdr*)\n\t\t      pjsip_msg_find_hdr(rdata->msg_info.msg, PJSIP_H_CONTACT,\n\t\t\t\t         pos);\n\tif (contact_hdr) {\n\t    if (!contact_hdr->uri ||\n\t\t(!PJSIP_URI_SCHEME_IS_SIP(contact_hdr->uri) &&\n\t\t !PJSIP_URI_SCHEME_IS_SIPS(contact_hdr->uri)))\n\t    {\n\t\tpos = (pjsip_hdr*)contact_hdr->next;\n\t\tif (pos == &rdata->msg_info.msg->hdr)\n\t\t    contact_hdr = NULL;\n\t    } else {\n\t\tbreak;\n\t    }\n\t}\n    } while (contact_hdr);\n\n    if (!contact_hdr) {\n\tstatus = PJSIP_ERRNO_FROM_SIP_STATUS(PJSIP_SC_BAD_REQUEST);\n\tgoto on_error;\n    }\n\n    dlg->remote.contact = (pjsip_contact_hdr*)\n    \t\t\t  pjsip_hdr_clone(dlg->pool, (pjsip_hdr*)contact_hdr);\n\n    /* Init remote's CSeq from CSeq header */\n    dlg->remote.cseq = dlg->remote.first_cseq = rdata->msg_info.cseq->cseq;\n\n    /* Set initial target to remote's Contact. */\n    dlg->target = dlg->remote.contact->uri;\n\n    /* Initial role is UAS */\n    dlg->role = PJSIP_ROLE_UAS;\n\n    /* Secure?\n     *  RFC 3261 Section 12.1.1:\n     *  If the request arrived over TLS, and the Request-URI contained a\n     *  SIPS URI, the 'secure' flag is set to TRUE.\n     */\n    dlg->secure = PJSIP_TRANSPORT_IS_SECURE(rdata->tp_info.transport) &&\n\t\t  PJSIP_URI_SCHEME_IS_SIPS(rdata->msg_info.msg->line.req.uri);\n\n    /* Call-ID */\n    dlg->call_id = (pjsip_cid_hdr*)\n    \t\t   pjsip_hdr_clone(dlg->pool, rdata->msg_info.cid);\n\n    /* Route set.\n     *  RFC 3261 Section 12.1.1:\n     *  The route set MUST be set to the list of URIs in the Record-Route\n     *  header field from the request, taken in order and preserving all URI\n     *  parameters. If no Record-Route header field is present in the request,\n     * the route set MUST be set to the empty set.\n     */\n    pj_list_init(&dlg->route_set);\n    rr = rdata->msg_info.record_route;\n    while (rr != NULL) {\n\tpjsip_route_hdr *route;\n\n\t/* Clone the Record-Route, change the type to Route header. */\n\troute = (pjsip_route_hdr*) pjsip_hdr_clone(dlg->pool, rr);\n\tpjsip_routing_hdr_set_route(route);\n\n\t/* Add to route set. */\n\tpj_list_push_back(&dlg->route_set, route);\n\n\t/* Find next Record-Route header. */\n\trr = rr->next;\n\tif (rr == (void*)&rdata->msg_info.msg->hdr)\n\t    break;\n\trr = (pjsip_route_hdr*) pjsip_msg_find_hdr(rdata->msg_info.msg,\n\t\t\t\t\t\t   PJSIP_H_RECORD_ROUTE, rr);\n    }\n    dlg->route_set_frozen = PJ_TRUE;\n\n    /* Increment the dialog's lock since tsx may cause the dialog to be\n     * destroyed prematurely (such as in case of transport error).\n     */\n    if (inc_lock) {\n        pjsip_dlg_inc_lock(dlg);\n        lock_incremented = PJ_TRUE;\n    }\n\n    /* Create UAS transaction for this request. */\n    status = pjsip_tsx_create_uas(dlg->ua, rdata, &tsx);\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n\n    /* Associate this dialog to the transaction. */\n    tsx->mod_data[dlg->ua->id] = dlg;\n\n    /* Increment tsx counter */\n    ++dlg->tsx_count;\n\n    /* Calculate hash value of remote tag. */\n    dlg->remote.tag_hval = pj_hash_calc_tolower(0, NULL, &dlg->remote.info->tag);\n\n    /* Update remote capabilities info */\n    pjsip_dlg_update_remote_cap(dlg, rdata->msg_info.msg, PJ_TRUE);\n\n    /* Register this dialog to user agent. */\n    status = pjsip_ua_register_dlg( ua, dlg );\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n\n    /* Put this dialog in rdata's mod_data */\n    rdata->endpt_info.mod_data[ua->id] = dlg;\n\n    PJ_TODO(DIALOG_APP_TIMER);\n\n    /* Feed the first request to the transaction. */\n    pjsip_tsx_recv_msg(tsx, rdata);\n\n    /* Done. */\n    *p_dlg = dlg;\n    PJ_LOG(5,(dlg->obj_name, \"UAS dialog created\"));\n    return PJ_SUCCESS;\n\non_error:\n    if (tsx) {\n\tpjsip_tsx_terminate(tsx, 500);\n\tpj_assert(dlg->tsx_count>0);\n\t--dlg->tsx_count;\n    }\n\n    if (lock_incremented) {\n        pjsip_dlg_dec_lock(dlg);\n    } else {\n        destroy_dialog(dlg, PJ_FALSE);\n    }\n\n    return status;\n}\n\n\n#if !DEPRECATED_FOR_TICKET_1902\n/*\n * Create UAS dialog.\n */\nPJ_DEF(pj_status_t) pjsip_dlg_create_uas(   pjsip_user_agent *ua,\n\t\t\t\t\t    pjsip_rx_data *rdata,\n\t\t\t\t\t    const pj_str_t *contact,\n\t\t\t\t\t    pjsip_dialog **p_dlg)\n{\n    return create_uas_dialog(ua, rdata, contact, PJ_FALSE, p_dlg);\n}\n#endif\n\n\n/*\n * Create UAS dialog and increase its session count.\n */\nPJ_DEF(pj_status_t)\npjsip_dlg_create_uas_and_inc_lock(    pjsip_user_agent *ua,\n\t\t\t\t      pjsip_rx_data *rdata,\n\t\t\t\t      const pj_str_t *contact,\n\t\t\t\t      pjsip_dialog **p_dlg)\n{\n    return create_uas_dialog(ua, rdata, contact, PJ_TRUE, p_dlg);\n}\n\n\n/*\n * Bind dialog to a specific transport/listener.\n */\nPJ_DEF(pj_status_t) pjsip_dlg_set_transport( pjsip_dialog *dlg,\n\t\t\t\t\t     const pjsip_tpselector *sel)\n{\n    /* Validate */\n    PJ_ASSERT_RETURN(dlg && sel, PJ_EINVAL);\n\n    /* Start locking the dialog. */\n    pjsip_dlg_inc_lock(dlg);\n\n    /* Decrement reference counter of previous transport selector */\n    pjsip_tpselector_dec_ref(&dlg->tp_sel);\n\n    /* Copy transport selector structure .*/\n    pj_memcpy(&dlg->tp_sel, sel, sizeof(*sel));\n\n    /* Increment reference counter */\n    pjsip_tpselector_add_ref(&dlg->tp_sel);\n\n    /* Unlock dialog. */\n    pjsip_dlg_dec_lock(dlg);\n\n    return PJ_SUCCESS;\n}\n\n/*\n * Set \"sent-by\" field of Via header.\n */\nPJ_DEF(pj_status_t) pjsip_dlg_set_via_sent_by( pjsip_dialog *dlg,\n\t\t\t\t               pjsip_host_port *via_addr,\n                                               pjsip_transport *via_tp)\n{\n    PJ_ASSERT_RETURN(dlg, PJ_EINVAL);\n\n    if (!via_addr)\n        pj_bzero(&dlg->via_addr, sizeof(dlg->via_addr));\n    else {\n        if (pj_strcmp(&dlg->via_addr.host, &via_addr->host))\n            pj_strdup(dlg->pool, &dlg->via_addr.host, &via_addr->host);\n        dlg->via_addr.port = via_addr->port;\n    }\n    dlg->via_tp = via_tp;\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Create forked dialog from a response.\n */\nPJ_DEF(pj_status_t) pjsip_dlg_fork( const pjsip_dialog *first_dlg,\n\t\t\t\t    const pjsip_rx_data *rdata,\n\t\t\t\t    pjsip_dialog **new_dlg )\n{\n    pjsip_dialog *dlg;\n    const pjsip_msg *msg = rdata->msg_info.msg;\n    const pjsip_hdr *end_hdr, *hdr;\n    const pjsip_contact_hdr *contact;\n    pj_status_t status;\n\n    /* Check arguments. */\n    PJ_ASSERT_RETURN(first_dlg && rdata && new_dlg, PJ_EINVAL);\n\n    /* rdata must be response message. */\n    PJ_ASSERT_RETURN(msg->type == PJSIP_RESPONSE_MSG,\n\t\t     PJSIP_ENOTRESPONSEMSG);\n\n    /* Status code MUST be 1xx (but not 100), or 2xx */\n    status = msg->line.status.code;\n    PJ_ASSERT_RETURN( (status/100==1 && status!=100) ||\n\t\t      (status/100==2), PJ_EBUG);\n\n    /* To tag must present in the response. */\n    PJ_ASSERT_RETURN(rdata->msg_info.to->tag.slen != 0, PJSIP_EMISSINGTAG);\n\n    /* Find Contact header in the response */\n    contact = (const pjsip_contact_hdr*)\n\t      pjsip_msg_find_hdr(msg, PJSIP_H_CONTACT, NULL);\n    if (contact == NULL || contact->uri == NULL)\n\treturn PJSIP_EMISSINGHDR;\n\n    /* Create the dialog. */\n    status = create_dialog((pjsip_user_agent*)first_dlg->ua, NULL, &dlg);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Set remote target from the response. */\n    dlg->target = (pjsip_uri*) pjsip_uri_clone(dlg->pool, contact->uri);\n\n    /* Clone local info. */\n    dlg->local.info = (pjsip_fromto_hdr*)\n    \t\t      pjsip_hdr_clone(dlg->pool, first_dlg->local.info);\n\n    /* Clone local tag. */\n    pj_strdup(dlg->pool, &dlg->local.info->tag, &first_dlg->local.info->tag);\n    dlg->local.tag_hval = first_dlg->local.tag_hval;\n\n    /* Clone local CSeq. */\n    dlg->local.first_cseq = first_dlg->local.first_cseq;\n    dlg->local.cseq = first_dlg->local.cseq;\n\n    /* Clone local Contact. */\n    dlg->local.contact = (pjsip_contact_hdr*)\n    \t\t\t pjsip_hdr_clone(dlg->pool, first_dlg->local.contact);\n\n    /* Clone remote info. */\n    dlg->remote.info = (pjsip_fromto_hdr*)\n    \t\t       pjsip_hdr_clone(dlg->pool, first_dlg->remote.info);\n\n    /* Set remote tag from the response. */\n    pj_strdup(dlg->pool, &dlg->remote.info->tag, &rdata->msg_info.to->tag);\n\n    /* Initialize remote's CSeq to -1. */\n    dlg->remote.cseq = dlg->remote.first_cseq = -1;\n\n    /* Initial role is UAC. */\n    dlg->role = PJSIP_ROLE_UAC;\n\n    /* Dialog state depends on the response. */\n    status = msg->line.status.code/100;\n    if (status == 1 || status == 2)\n\tdlg->state = PJSIP_DIALOG_STATE_ESTABLISHED;\n    else {\n\tpj_assert(!\"Invalid status code\");\n\tdlg->state = PJSIP_DIALOG_STATE_NULL;\n    }\n\n    /* Secure? */\n    dlg->secure = PJSIP_URI_SCHEME_IS_SIPS(dlg->target);\n\n    /* Clone Call-ID header. */\n    dlg->call_id = (pjsip_cid_hdr*)\n    \t\t   pjsip_hdr_clone(dlg->pool, first_dlg->call_id);\n\n    /* Get route-set from the response. */\n    pj_list_init(&dlg->route_set);\n    end_hdr = &msg->hdr;\n    for (hdr=msg->hdr.prev; hdr!=end_hdr; hdr=hdr->prev) {\n\tif (hdr->type == PJSIP_H_RECORD_ROUTE) {\n\t    pjsip_route_hdr *r;\n\t    r = (pjsip_route_hdr*) pjsip_hdr_clone(dlg->pool, hdr);\n\t    pjsip_routing_hdr_set_route(r);\n\t    pj_list_push_back(&dlg->route_set, r);\n\t}\n    }\n\n    //dlg->route_set_frozen = PJ_TRUE;\n\n    /* Clone client authentication session. */\n    status = pjsip_auth_clt_clone(dlg->pool, &dlg->auth_sess,\n\t\t\t\t  &first_dlg->auth_sess);\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n\n    /* Register this dialog to user agent. */\n    status = pjsip_ua_register_dlg(dlg->ua, dlg );\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n\n\n    /* Done! */\n    *new_dlg = dlg;\n\n    PJ_LOG(5,(dlg->obj_name, \"Forked dialog created\"));\n    return PJ_SUCCESS;\n\non_error:\n    destroy_dialog(dlg, PJ_FALSE);\n    return status;\n}\n\n\n/*\n * Unregister and destroy dialog.\n */\nstatic pj_status_t unregister_and_destroy_dialog( pjsip_dialog *dlg,\n\t\t\t\t\t\t  pj_bool_t unlock_mutex )\n{\n    pj_status_t status;\n\n    /* Lock must have been held. */\n\n    /* Check dialog state. */\n    /* Number of sessions must be zero. */\n    PJ_ASSERT_RETURN(dlg->sess_count==0, PJ_EINVALIDOP);\n\n    /* MUST not have pending transactions. */\n    PJ_ASSERT_RETURN(dlg->tsx_count==0, PJ_EINVALIDOP);\n\n    /* Unregister from user agent, if it has been registered (see #1924) */\n    if (dlg->dlg_set) {\n\tstatus = pjsip_ua_unregister_dlg(dlg->ua, dlg);\n\tif (status != PJ_SUCCESS) {\n\t    pj_assert(!\"Unexpected failed unregistration!\");\n\t    return status;\n\t}\n    }\n\n    /* Destroy this dialog. */\n    destroy_dialog(dlg, unlock_mutex);\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Forcefully terminate dialog.\n */\nPJ_DEF(pj_status_t) pjsip_dlg_terminate( pjsip_dialog *dlg )\n{\n    /* Number of sessions must be zero. */\n    PJ_ASSERT_RETURN(dlg->sess_count==0, PJ_EINVALIDOP);\n\n    /* MUST not have pending transactions. */\n    PJ_ASSERT_RETURN(dlg->tsx_count==0, PJ_EINVALIDOP);\n\n    return unregister_and_destroy_dialog(dlg, PJ_FALSE);\n}\n\n\n/*\n * Set route_set\n */\nPJ_DEF(pj_status_t) pjsip_dlg_set_route_set( pjsip_dialog *dlg,\n\t\t\t\t\t     const pjsip_route_hdr *route_set )\n{\n    pjsip_route_hdr *r;\n\n    PJ_ASSERT_RETURN(dlg, PJ_EINVAL);\n\n    pjsip_dlg_inc_lock(dlg);\n\n    /* Clear route set. */\n    pj_list_init(&dlg->route_set);\n\n    if (!route_set) {\n\tpjsip_dlg_dec_lock(dlg);\n\treturn PJ_SUCCESS;\n    }\n\n    r = route_set->next;\n    while (r != route_set) {\n\tpjsip_route_hdr *new_r;\n\n\tnew_r = (pjsip_route_hdr*) pjsip_hdr_clone(dlg->pool, r);\n\tpj_list_push_back(&dlg->route_set, new_r);\n\n\tr = r->next;\n    }\n\n    pjsip_dlg_dec_lock(dlg);\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Increment session counter.\n */\nPJ_DEF(pj_status_t) pjsip_dlg_inc_session( pjsip_dialog *dlg,\n\t\t\t\t\t   pjsip_module *mod )\n{\n    PJ_ASSERT_RETURN(dlg && mod, PJ_EINVAL);\n\n    pj_log_push_indent();\n\n    pjsip_dlg_inc_lock(dlg);\n    ++dlg->sess_count;\n    pjsip_dlg_dec_lock(dlg);\n\n    PJ_LOG(5,(dlg->obj_name, \"Session count inc to %d by %.*s\",\n\t      dlg->sess_count, (int)mod->name.slen, mod->name.ptr));\n\n    pj_log_pop_indent();\n    return PJ_SUCCESS;\n}\n\n/*\n * Lock dialog and increment session count temporarily\n * to prevent it from being deleted. In addition, it must lock\n * the user agent's dialog table first, to prevent deadlock.\n */\nPJ_DEF(void) pjsip_dlg_inc_lock(pjsip_dialog *dlg)\n{\n    PJ_LOG(6,(dlg->obj_name, \"Entering pjsip_dlg_inc_lock(), sess_count=%d\",\n\t      dlg->sess_count));\n\n    pj_grp_lock_acquire(dlg->grp_lock_);\n    dlg->sess_count++;\n\n    PJ_LOG(6,(dlg->obj_name, \"Leaving pjsip_dlg_inc_lock(), sess_count=%d\",\n\t      dlg->sess_count));\n}\n\n/* Try to acquire dialog's group lock, but bail out if group lock can not be\n * acquired immediately.\n */\nPJ_DEF(pj_status_t) pjsip_dlg_try_inc_lock(pjsip_dialog *dlg)\n{\n    pj_status_t status;\n\n    PJ_LOG(6,(dlg->obj_name,\"Entering pjsip_dlg_try_inc_lock(), sess_count=%d\",\n\t      dlg->sess_count));\n\n    status = pj_grp_lock_tryacquire(dlg->grp_lock_);\n    if (status != PJ_SUCCESS) {\n\tPJ_LOG(6,(dlg->obj_name, \"pjsip_dlg_try_inc_lock() failed\"));\n\treturn status;\n    }\n\n    dlg->sess_count++;\n\n    PJ_LOG(6,(dlg->obj_name, \"Leaving pjsip_dlg_try_inc_lock(), sess_count=%d\",\n\t      dlg->sess_count));\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Unlock dialog and decrement reference counter.\n * It may delete the dialog!\n */\nPJ_DEF(void) pjsip_dlg_dec_lock(pjsip_dialog *dlg)\n{\n    PJ_ASSERT_ON_FAIL(dlg!=NULL, return);\n\n    PJ_LOG(6,(dlg->obj_name, \"Entering pjsip_dlg_dec_lock(), sess_count=%d\",\n\t      dlg->sess_count));\n\n    pj_assert(dlg->sess_count > 0);\n    --dlg->sess_count;\n\n    if (dlg->sess_count==0 && dlg->tsx_count==0) {\n\tpj_grp_lock_release(dlg->grp_lock_);\n\tpj_grp_lock_acquire(dlg->grp_lock_);\n\t/* We are holding the dialog group lock here, so before we destroy\n\t * the dialog, make sure that we unlock it first to avoid\n\t * undefined behaviour on some platforms. See ticket #1886.\n\t */\n\tunregister_and_destroy_dialog(dlg, PJ_TRUE);\n    } else {\n\tpj_grp_lock_release(dlg->grp_lock_);\n    }\n\n    PJ_LOG(6,(THIS_FILE, \"Leaving pjsip_dlg_dec_lock() (dlg=%p)\", dlg));\n}\n\n\n/*\n * Decrement session count.\n */\nPJ_DEF(pj_status_t) pjsip_dlg_dec_session( pjsip_dialog *dlg,\n\t\t\t\t\t   pjsip_module *mod)\n{\n    PJ_ASSERT_RETURN(dlg, PJ_EINVAL);\n\n    pj_log_push_indent();\n\n    PJ_LOG(5,(dlg->obj_name, \"Session count dec to %d by %.*s\",\n\t      dlg->sess_count-1, (int)mod->name.slen, mod->name.ptr));\n\n    pjsip_dlg_inc_lock(dlg);\n    --dlg->sess_count;\n    pjsip_dlg_dec_lock(dlg);\n\n    pj_log_pop_indent();\n    return PJ_SUCCESS;\n}\n\nPJ_DEF(pj_grp_lock_t *) pjsip_dlg_get_lock(pjsip_dialog *dlg)\n{\n    PJ_ASSERT_RETURN(dlg, NULL);\n    return dlg->grp_lock_;\n}\n\n/*\n * Check if the module is registered as a usage\n */\nPJ_DEF(pj_bool_t) pjsip_dlg_has_usage( pjsip_dialog *dlg,\n\t\t\t\t\t  pjsip_module *mod)\n{\n    unsigned index;\n    pj_bool_t found = PJ_FALSE;\n\n    pjsip_dlg_inc_lock(dlg);\n    for (index=0; index<dlg->usage_cnt; ++index) {\n    \tif (dlg->usage[index] == mod) {\n    \t    found = PJ_TRUE;\n    \t    break;\n    \t}\n    }\n    pjsip_dlg_dec_lock(dlg);\n\n    return found;\n}\n\n/*\n * Add usage.\n */\nPJ_DEF(pj_status_t) pjsip_dlg_add_usage( pjsip_dialog *dlg,\n\t\t\t\t\t pjsip_module *mod,\n\t\t\t\t\t void *mod_data )\n{\n    unsigned index;\n\n    PJ_ASSERT_RETURN(dlg && mod, PJ_EINVAL);\n    PJ_ASSERT_RETURN(mod->id >= 0 && mod->id < PJSIP_MAX_MODULE,\n\t\t     PJ_EINVAL);\n    PJ_ASSERT_RETURN(dlg->usage_cnt < PJSIP_MAX_MODULE, PJ_EBUG);\n\n    PJ_LOG(5,(dlg->obj_name,\n\t      \"Module %.*s added as dialog usage, data=%p\",\n\t      (int)mod->name.slen, mod->name.ptr, mod_data));\n\n    pjsip_dlg_inc_lock(dlg);\n\n    /* Usages are sorted on priority, lowest number first.\n     * Find position to put the new module, also makes sure that\n     * this module has not been registered before.\n     */\n    for (index=0; index<dlg->usage_cnt; ++index) {\n\tif (dlg->usage[index] == mod) {\n\t    /* Module may be registered more than once in the same dialog.\n\t     * For example, when call transfer fails, application may retry\n\t     * call transfer on the same dialog.\n\t     * So return PJ_SUCCESS here.\n\t     */\n\t    PJ_LOG(4,(dlg->obj_name,\n\t\t      \"Module %.*s already registered as dialog usage, \"\n\t\t      \"updating the data %p\",\n\t\t      (int)mod->name.slen, mod->name.ptr, mod_data));\n\t    dlg->mod_data[mod->id] = mod_data;\n\n\t    pjsip_dlg_dec_lock(dlg);\n\t    return PJ_SUCCESS;\n\n\t    //pj_assert(!\"This module is already registered\");\n\t    //pjsip_dlg_dec_lock(dlg);\n\t    //return PJSIP_ETYPEEXISTS;\n\t}\n\n\tif (dlg->usage[index]->priority > mod->priority)\n\t    break;\n    }\n\n    /* index holds position to put the module.\n     * Insert module at this index.\n     */\n    pj_array_insert(dlg->usage, sizeof(dlg->usage[0]), dlg->usage_cnt,\n\t\t    index, &mod);\n\n    /* Set module data. */\n    dlg->mod_data[mod->id] = mod_data;\n\n    /* Increment count. */\n    ++dlg->usage_cnt;\n\n    pjsip_dlg_dec_lock(dlg);\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Attach module specific data to the dialog. Application can also set\n * the value directly by accessing dlg->mod_data[module_id].\n */\nPJ_DEF(pj_status_t) pjsip_dlg_set_mod_data( pjsip_dialog *dlg,\n\t\t\t\t\t    int mod_id,\n\t\t\t\t\t    void *data )\n{\n    PJ_ASSERT_RETURN(dlg, PJ_EINVAL);\n    PJ_ASSERT_RETURN(mod_id >= 0 && mod_id < PJSIP_MAX_MODULE,\n\t\t     PJ_EINVAL);\n    dlg->mod_data[mod_id] = data;\n    return PJ_SUCCESS;\n}\n\n/**\n * Get module specific data previously attached to the dialog. Application\n * can also get value directly by accessing dlg->mod_data[module_id].\n */\nPJ_DEF(void*) pjsip_dlg_get_mod_data( pjsip_dialog *dlg,\n\t\t\t\t      int mod_id)\n{\n    PJ_ASSERT_RETURN(dlg, NULL);\n    PJ_ASSERT_RETURN(mod_id >= 0 && mod_id < PJSIP_MAX_MODULE,\n\t\t     NULL);\n    return dlg->mod_data[mod_id];\n}\n\n\n/*\n * Create a new request within dialog (i.e. after the dialog session has been\n * established). The construction of such requests follows the rule in\n * RFC3261 section 12.2.1.\n */\nstatic pj_status_t dlg_create_request_throw( pjsip_dialog *dlg,\n\t\t\t\t\t     const pjsip_method *method,\n\t\t\t\t\t     int cseq,\n\t\t\t\t\t     pjsip_tx_data **p_tdata )\n{\n    pjsip_tx_data *tdata;\n    pjsip_contact_hdr *contact;\n    pjsip_route_hdr *route, *end_list;\n    pj_status_t status;\n\n    /* Contact Header field.\n     * Contact can only be present in requests that establish dialog (in the\n     * core SIP spec, only INVITE).\n     */\n    if (pjsip_method_creates_dialog(method))\n\tcontact = dlg->local.contact;\n    else\n\tcontact = NULL;\n\n    /*\n     * Create the request by cloning from the headers in the\n     * dialog.\n     */\n    status = pjsip_endpt_create_request_from_hdr(dlg->endpt,\n\t\t\t\t\t\t method,\n\t\t\t\t\t\t dlg->target,\n\t\t\t\t\t\t dlg->local.info,\n\t\t\t\t\t\t dlg->remote.info,\n\t\t\t\t\t\t contact,\n\t\t\t\t\t\t dlg->call_id,\n\t\t\t\t\t\t cseq,\n\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t &tdata);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Put this dialog in tdata's mod_data */\n    tdata->mod_data[dlg->ua->id] = dlg;\n\n    /* Just copy dialog route-set to Route header.\n     * The transaction will do the processing as specified in Section 12.2.1\n     * of RFC 3261 in function tsx_process_route() in sip_transaction.c.\n     */\n    route = dlg->route_set.next;\n    end_list = &dlg->route_set;\n    for (; route != end_list; route = route->next ) {\n\tpjsip_route_hdr *r;\n\tr = (pjsip_route_hdr*) pjsip_hdr_shallow_clone( tdata->pool, route );\n\tpjsip_routing_hdr_set_route(r);\n\tpjsip_msg_add_hdr(tdata->msg, (pjsip_hdr*)r);\n    }\n\n    /* Copy authorization headers, if request is not ACK or CANCEL. */\n    if (method->id != PJSIP_ACK_METHOD && method->id != PJSIP_CANCEL_METHOD) {\n\tstatus = pjsip_auth_clt_init_req( &dlg->auth_sess, tdata );\n\tif (status != PJ_SUCCESS)\n\t    return status;\n    }\n\n    /* Copy the initial destination host to tdata. This information can be\n     * used later by transport for transport selection.\n     */\n    if (dlg->initial_dest.slen)\n    \tpj_strdup(tdata->pool, &tdata->dest_info.name, &dlg->initial_dest);\n\n    /* Done. */\n    *p_tdata = tdata;\n\n    return PJ_SUCCESS;\n}\n\n\n\n/*\n * Create outgoing request.\n */\nPJ_DEF(pj_status_t) pjsip_dlg_create_request( pjsip_dialog *dlg,\n\t\t\t\t\t      const pjsip_method *method,\n\t\t\t\t\t      int cseq,\n\t\t\t\t\t      pjsip_tx_data **p_tdata)\n{\n    pj_status_t status;\n    pjsip_tx_data *tdata = NULL;\n    PJ_USE_EXCEPTION;\n\n    PJ_ASSERT_RETURN(dlg && method && p_tdata, PJ_EINVAL);\n\n    /* Lock dialog. */\n    pjsip_dlg_inc_lock(dlg);\n\n    /* Use outgoing CSeq and increment it by one. */\n    if (cseq < 0)\n\tcseq = dlg->local.cseq + 1;\n\n    /* Keep compiler happy */\n    status = PJ_EBUG;\n\n    /* Create the request. */\n    PJ_TRY {\n\tstatus = dlg_create_request_throw(dlg, method, cseq, &tdata);\n    }\n    PJ_CATCH_ANY {\n\tstatus = PJ_ENOMEM;\n    }\n    PJ_END;\n\n    /* Failed! Delete transmit data. */\n    if (status != PJ_SUCCESS && tdata) {\n\tpjsip_tx_data_dec_ref( tdata );\n\ttdata = NULL;\n    }\n\n    /* Unlock dialog. */\n    pjsip_dlg_dec_lock(dlg);\n\n    *p_tdata = tdata;\n\n    return status;\n}\n\n/* Callback for send ACK, providing send callback will allow stack to try\n * next server upon failure.\n */\nstatic void send_ack_callback( pjsip_send_state *send_state,\n\t\t\t       pj_ssize_t sent, pj_bool_t *cont )\n{\n    if (sent > 0)\n\treturn;\n\n    if (*cont) {\n\tPJ_PERROR(3,(THIS_FILE, (pj_status_t)-sent,\n\t\t     \"Temporary failure in sending %s, \"\n\t\t     \"will try next server\",\n\t\t     pjsip_tx_data_get_info(send_state->tdata)));\n    } else {\n\tPJ_PERROR(3,(THIS_FILE, (pj_status_t)-sent,\n\t\t     \"Failed to send %s!\",\n\t\t     pjsip_tx_data_get_info(send_state->tdata)));\n    }\n}\n\n/*\n * Send request statefully, and update dialog'c CSeq.\n */\nPJ_DEF(pj_status_t) pjsip_dlg_send_request( pjsip_dialog *dlg,\n\t\t\t\t\t    pjsip_tx_data *tdata,\n\t\t\t\t\t    int mod_data_id,\n\t\t\t\t\t    void *mod_data)\n{\n    pjsip_transaction *tsx;\n    pjsip_msg *msg = tdata->msg;\n    pj_status_t status;\n\n    /* Check arguments. */\n    PJ_ASSERT_RETURN(dlg && tdata && tdata->msg, PJ_EINVAL);\n    PJ_ASSERT_RETURN(tdata->msg->type == PJSIP_REQUEST_MSG,\n\t\t     PJSIP_ENOTREQUESTMSG);\n\n    pj_log_push_indent();\n    PJ_LOG(5,(dlg->obj_name, \"Sending %s\",\n\t      pjsip_tx_data_get_info(tdata)));\n\n    /* Lock and increment session */\n    pjsip_dlg_inc_lock(dlg);\n\n    /* Put this dialog in tdata's mod_data */\n    tdata->mod_data[dlg->ua->id] = dlg;\n\n    /* If via_addr is set, use this address for the Via header. */\n    if (dlg->via_addr.host.slen > 0) {\n        tdata->via_addr = dlg->via_addr;\n        tdata->via_tp = dlg->via_tp;\n    }\n\n    /* Update dialog's CSeq and message's CSeq if request is not\n     * ACK nor CANCEL.\n     */\n    if (msg->line.req.method.id != PJSIP_CANCEL_METHOD &&\n\tmsg->line.req.method.id != PJSIP_ACK_METHOD)\n    {\n\tpjsip_cseq_hdr *ch;\n\n\tch = PJSIP_MSG_CSEQ_HDR(msg);\n\tPJ_ASSERT_RETURN(ch!=NULL, PJ_EBUG);\n\n\tch->cseq = dlg->local.cseq++;\n\n\t/* Force the whole message to be re-printed. */\n\tpjsip_tx_data_invalidate_msg( tdata );\n    }\n\n    /* Create a new transaction if method is not ACK.\n     * The transaction user is the user agent module.\n     */\n    if (msg->line.req.method.id != PJSIP_ACK_METHOD) {\n\tint tsx_count;\n\n\tstatus = pjsip_tsx_create_uac(dlg->ua, tdata, &tsx);\n\tif (status != PJ_SUCCESS)\n\t    goto on_error;\n\n\t/* Set transport selector */\n\tstatus = pjsip_tsx_set_transport(tsx, &dlg->tp_sel);\n\tpj_assert(status == PJ_SUCCESS);\n\n\t/* Attach this dialog to the transaction, so that user agent\n\t * will dispatch events to this dialog.\n\t */\n\ttsx->mod_data[dlg->ua->id] = dlg;\n\n\t/* Copy optional caller's mod_data, if present */\n\tif (mod_data_id >= 0 && mod_data_id < PJSIP_MAX_MODULE)\n\t    tsx->mod_data[mod_data_id] = mod_data;\n\n\t/* Increment transaction counter. */\n\ttsx_count = ++dlg->tsx_count;\n\n\t/* Send the message. */\n\tstatus = pjsip_tsx_send_msg(tsx, tdata);\n\tif (status != PJ_SUCCESS) {\n\t    if (dlg->tsx_count == tsx_count)\n\t\tpjsip_tsx_terminate(tsx, tsx->status_code);\n\t    goto on_error;\n\t}\n\n    } else {\n\t/* Set transport selector */\n\tpjsip_tx_data_set_transport(tdata, &dlg->tp_sel);\n\n\t/* Send request */\n\tstatus = pjsip_endpt_send_request_stateless(dlg->endpt, tdata,\n\t\t\t\t\t\t    NULL, &send_ack_callback);\n\tif (status != PJ_SUCCESS)\n\t    goto on_error;\n\n    }\n\n    /* Unlock dialog, may destroy dialog. */\n    pjsip_dlg_dec_lock(dlg);\n    pj_log_pop_indent();\n    return PJ_SUCCESS;\n\non_error:\n    /* Unlock dialog, may destroy dialog. */\n    pjsip_dlg_dec_lock(dlg);\n\n    /* Whatever happen delete the message. */\n    pjsip_tx_data_dec_ref( tdata );\n    pj_log_pop_indent();\n    return status;\n}\n\n/* Add standard headers for certain types of response */\nstatic void dlg_beautify_response(pjsip_dialog *dlg,\n\t\t\t\t  pj_bool_t add_headers,\n\t\t\t\t  int st_code,\n\t\t\t\t  pjsip_tx_data *tdata)\n{\n    pjsip_cseq_hdr *cseq;\n    int st_class;\n    const pjsip_hdr *c_hdr;\n    pjsip_hdr *hdr;\n\n    cseq = PJSIP_MSG_CSEQ_HDR(tdata->msg);\n    pj_assert(cseq != NULL);\n\n    st_class = st_code / 100;\n\n    /* Contact, Allow, Supported header. */\n    if (add_headers && pjsip_method_creates_dialog(&cseq->method)) {\n\t/* Add Contact header for 1xx, 2xx, 3xx and 485 response. */\n\tif (st_class==2 || st_class==3 || (st_class==1 && st_code != 100) ||\n\t    st_code==485)\n\t{\n\t    /* Add contact header only if one is not present. */\n\t    if (pjsip_msg_find_hdr(tdata->msg, PJSIP_H_CONTACT, NULL) == 0 &&\n\t\tpjsip_msg_find_hdr_by_name(tdata->msg, &HCONTACT, NULL) == 0)\n\t    {\n\t\thdr = (pjsip_hdr*) pjsip_hdr_clone(tdata->pool,\n\t\t\t\t\t\t   dlg->local.contact);\n\t\tpjsip_msg_add_hdr(tdata->msg, hdr);\n\t    }\n\t}\n\n\t/* Add Allow header in 18x, 2xx and 405 response. */\n\tif ((((st_code/10==18 || st_class==2) && dlg->add_allow)\n\t     || st_code==405) &&\n\t    pjsip_msg_find_hdr(tdata->msg, PJSIP_H_ALLOW, NULL)==NULL)\n\t{\n\t    c_hdr = pjsip_endpt_get_capability(dlg->endpt,\n\t\t\t\t\t       PJSIP_H_ALLOW, NULL);\n\t    if (c_hdr) {\n\t\thdr = (pjsip_hdr*) pjsip_hdr_clone(tdata->pool, c_hdr);\n\t\tpjsip_msg_add_hdr(tdata->msg, hdr);\n\t    }\n\t}\n\n\t/* Add Supported header in 2xx response. */\n\tif (st_class==2 &&\n\t    pjsip_msg_find_hdr(tdata->msg, PJSIP_H_SUPPORTED, NULL)==NULL)\n\t{\n\t    c_hdr = pjsip_endpt_get_capability(dlg->endpt,\n\t\t\t\t\t       PJSIP_H_SUPPORTED, NULL);\n\t    if (c_hdr) {\n\t\thdr = (pjsip_hdr*) pjsip_hdr_clone(tdata->pool, c_hdr);\n\t\tpjsip_msg_add_hdr(tdata->msg, hdr);\n\t    }\n\t}\n\n    }\n\n    /* Add To tag in all responses except 100 */\n    if (st_code != 100) {\n\tpjsip_to_hdr *to;\n\n\tto = PJSIP_MSG_TO_HDR(tdata->msg);\n\tpj_assert(to != NULL);\n\n\tto->tag = dlg->local.info->tag;\n\n\tif (dlg->state == PJSIP_DIALOG_STATE_NULL)\n\t    dlg->state = PJSIP_DIALOG_STATE_ESTABLISHED;\n    }\n}\n\n\n/*\n * Create response.\n */\nPJ_DEF(pj_status_t) pjsip_dlg_create_response(\tpjsip_dialog *dlg,\n\t\t\t\t\t\tpjsip_rx_data *rdata,\n\t\t\t\t\t\tint st_code,\n\t\t\t\t\t\tconst pj_str_t *st_text,\n\t\t\t\t\t\tpjsip_tx_data **p_tdata)\n{\n    pj_status_t status;\n    pjsip_tx_data *tdata;\n\n    /* Create generic response.\n     * This will initialize response's Via, To, From, Call-ID, CSeq\n     * and Record-Route headers from the request.\n     */\n    status = pjsip_endpt_create_response(dlg->endpt,\n\t\t\t\t\t rdata, st_code, st_text, &tdata);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Lock the dialog. */\n    pjsip_dlg_inc_lock(dlg);\n\n    /* Put this dialog in tdata's mod_data */\n    tdata->mod_data[dlg->ua->id] = dlg;\n\n    dlg_beautify_response(dlg, PJ_FALSE, st_code, tdata);\n\n    /* Unlock the dialog. */\n    pjsip_dlg_dec_lock(dlg);\n\n    /* Done. */\n    *p_tdata = tdata;\n    return PJ_SUCCESS;\n}\n\n/*\n * Modify response.\n */\nPJ_DEF(pj_status_t) pjsip_dlg_modify_response(\tpjsip_dialog *dlg,\n\t\t\t\t\t\tpjsip_tx_data *tdata,\n\t\t\t\t\t\tint st_code,\n\t\t\t\t\t\tconst pj_str_t *st_text)\n{\n    pjsip_hdr *hdr;\n\n    PJ_ASSERT_RETURN(dlg && tdata && tdata->msg, PJ_EINVAL);\n    PJ_ASSERT_RETURN(tdata->msg->type == PJSIP_RESPONSE_MSG,\n\t\t     PJSIP_ENOTRESPONSEMSG);\n    PJ_ASSERT_RETURN(st_code >= 100 && st_code <= 699, PJ_EINVAL);\n\n    /* Lock and increment session */\n    pjsip_dlg_inc_lock(dlg);\n\n    /* Replace status code and reason */\n    tdata->msg->line.status.code = st_code;\n    if (st_text) {\n\tpj_strdup(tdata->pool, &tdata->msg->line.status.reason, st_text);\n    } else {\n\ttdata->msg->line.status.reason = *pjsip_get_status_text(st_code);\n    }\n\n    /* Remove existing Contact header (without this, when dialog sent\n     * 180 and then 302, the Contact in 302 will not get updated).\n     */\n    hdr = (pjsip_hdr*) pjsip_msg_find_hdr(tdata->msg, PJSIP_H_CONTACT, NULL);\n    if (hdr)\n\tpj_list_erase(hdr);\n\n    /* Add tag etc. if necessary */\n    dlg_beautify_response(dlg, st_code/100 <= 2, st_code, tdata);\n\n\n    /* Must add reference counter, since tsx_send_msg() will decrement it */\n    pjsip_tx_data_add_ref(tdata);\n\n    /* Force to re-print message. */\n    pjsip_tx_data_invalidate_msg(tdata);\n\n    /* Unlock dialog and dec session, may destroy dialog. */\n    pjsip_dlg_dec_lock(dlg);\n\n    return PJ_SUCCESS;\n}\n\n/*\n * Send response statefully.\n */\nPJ_DEF(pj_status_t) pjsip_dlg_send_response( pjsip_dialog *dlg,\n\t\t\t\t\t     pjsip_transaction *tsx,\n\t\t\t\t\t     pjsip_tx_data *tdata)\n{\n    pj_status_t status;\n\n    /* Sanity check. */\n    PJ_ASSERT_RETURN(dlg && tsx && tdata && tdata->msg, PJ_EINVAL);\n    PJ_ASSERT_RETURN(tdata->msg->type == PJSIP_RESPONSE_MSG,\n\t\t     PJSIP_ENOTRESPONSEMSG);\n\n    /* The transaction must belong to this dialog.  */\n    PJ_ASSERT_RETURN(tsx->mod_data[dlg->ua->id] == dlg, PJ_EINVALIDOP);\n\n    pj_log_push_indent();\n\n    PJ_LOG(5,(dlg->obj_name, \"Sending %s\",\n\t      pjsip_tx_data_get_info(tdata)));\n\n    /* Check that transaction method and cseq match the response.\n     * This operation is sloooww (search CSeq header twice), that's why\n     * we only do it in debug mode.\n     */\n#if defined(PJ_DEBUG) && PJ_DEBUG!=0\n    PJ_ASSERT_RETURN( PJSIP_MSG_CSEQ_HDR(tdata->msg)->cseq == tsx->cseq &&\n\t\t      pjsip_method_cmp(&PJSIP_MSG_CSEQ_HDR(tdata->msg)->method,\n\t\t\t\t       &tsx->method)==0,\n\t\t      PJ_EINVALIDOP);\n#endif\n\n    /* Must acquire dialog first, to prevent deadlock */\n    pjsip_dlg_inc_lock(dlg);\n\n    /* Last chance to add mandatory headers before the response is\n     * sent.\n     */\n    dlg_beautify_response(dlg, PJ_TRUE, tdata->msg->line.status.code, tdata);\n\n    /* If the dialog is locked to transport, make sure that transaction\n     * is locked to the same transport too.\n     */\n    if (dlg->tp_sel.type != tsx->tp_sel.type ||\n\tdlg->tp_sel.u.ptr != tsx->tp_sel.u.ptr)\n    {\n\tstatus = pjsip_tsx_set_transport(tsx, &dlg->tp_sel);\n\tpj_assert(status == PJ_SUCCESS);\n    }\n\n    /* Ask transaction to send the response */\n    status = pjsip_tsx_send_msg(tsx, tdata);\n\n    /* This function must decrement transmit data request counter\n     * regardless of the operation status. The transaction only\n     * decrements the counter if the operation is successful.\n     */\n    if (status != PJ_SUCCESS) {\n\tpjsip_tx_data_dec_ref(tdata);\n    }\n\n    pjsip_dlg_dec_lock(dlg);\n    pj_log_pop_indent();\n\n    return status;\n}\n\n\n/*\n * Combo function to create and send response statefully.\n */\nPJ_DEF(pj_status_t) pjsip_dlg_respond(  pjsip_dialog *dlg,\n\t\t\t\t\tpjsip_rx_data *rdata,\n\t\t\t\t\tint st_code,\n\t\t\t\t\tconst pj_str_t *st_text,\n\t\t\t\t\tconst pjsip_hdr *hdr_list,\n\t\t\t\t\tconst pjsip_msg_body *body )\n{\n    pj_status_t status;\n    pjsip_tx_data *tdata;\n\n    /* Sanity check. */\n    PJ_ASSERT_RETURN(dlg && rdata && rdata->msg_info.msg, PJ_EINVAL);\n    PJ_ASSERT_RETURN(rdata->msg_info.msg->type == PJSIP_REQUEST_MSG,\n\t\t     PJSIP_ENOTREQUESTMSG);\n\n    /* The transaction must belong to this dialog.  */\n    PJ_ASSERT_RETURN(pjsip_rdata_get_tsx(rdata) &&\n\t\t     pjsip_rdata_get_tsx(rdata)->mod_data[dlg->ua->id] == dlg,\n\t\t     PJ_EINVALIDOP);\n\n    /* Create the response. */\n    status = pjsip_dlg_create_response(dlg, rdata, st_code, st_text, &tdata);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Add additional header, if any */\n    if (hdr_list) {\n\tconst pjsip_hdr *hdr;\n\n\thdr = hdr_list->next;\n\twhile (hdr != hdr_list) {\n\t    pjsip_msg_add_hdr(tdata->msg,\n\t\t\t      (pjsip_hdr*)pjsip_hdr_clone(tdata->pool, hdr));\n\t    hdr = hdr->next;\n\t}\n    }\n\n    /* Add the message body, if any. */\n    if (body) {\n\ttdata->msg->body = pjsip_msg_body_clone( tdata->pool, body);\n    }\n\n    /* Send the response. */\n    return pjsip_dlg_send_response(dlg, pjsip_rdata_get_tsx(rdata), tdata);\n}\n\n\n/* This function is called by user agent upon receiving incoming request\n * message.\n */\nvoid pjsip_dlg_on_rx_request( pjsip_dialog *dlg, pjsip_rx_data *rdata )\n{\n    pj_status_t status;\n    pjsip_transaction *tsx = NULL;\n    pj_bool_t processed = PJ_FALSE;\n    unsigned i;\n\n    PJ_LOG(5,(dlg->obj_name, \"Received %s\",\n\t      pjsip_rx_data_get_info(rdata)));\n    pj_log_push_indent();\n\n    /* Lock dialog and increment session. */\n    pjsip_dlg_inc_lock(dlg);\n\n    /* Check CSeq */\n    if (rdata->msg_info.cseq->cseq <= dlg->remote.cseq &&\n\trdata->msg_info.msg->line.req.method.id != PJSIP_ACK_METHOD &&\n\trdata->msg_info.msg->line.req.method.id != PJSIP_CANCEL_METHOD)\n    {\n\t/* Invalid CSeq.\n\t * Respond statelessly with 500 (Internal Server Error)\n\t */\n\tpj_str_t warn_text;\n\n\t/* Unlock dialog and dec session, may destroy dialog. */\n\tpjsip_dlg_dec_lock(dlg);\n\n\tpj_assert(pjsip_rdata_get_tsx(rdata) == NULL);\n\twarn_text = pj_str(\"Invalid CSeq\");\n\tpjsip_endpt_respond_stateless(dlg->endpt,\n\t\t\t\t      rdata, 500, &warn_text, NULL, NULL);\n\tpj_log_pop_indent();\n\treturn;\n    }\n\n    /* Update CSeq. */\n    dlg->remote.cseq = rdata->msg_info.cseq->cseq;\n\n    /* Update To tag if necessary.\n     * This only happens if UAS sends a new request before answering\n     * our request (e.g. UAS sends NOTIFY before answering our\n     * SUBSCRIBE request).\n     */\n    if (dlg->remote.info->tag.slen == 0) {\n\tpj_strdup(dlg->pool, &dlg->remote.info->tag,\n\t\t  &rdata->msg_info.from->tag);\n    }\n\n    /* Create UAS transaction for this request. */\n    if (pjsip_rdata_get_tsx(rdata) == NULL &&\n\trdata->msg_info.msg->line.req.method.id != PJSIP_ACK_METHOD)\n    {\n\tstatus = pjsip_tsx_create_uas(dlg->ua, rdata, &tsx);\n\tif (status != PJ_SUCCESS) {\n\t    /* Once case for this is when re-INVITE contains same\n\t     * Via branch value as previous INVITE (ticket #965).\n\t     */\n\t    char errmsg[PJ_ERR_MSG_SIZE];\n\t    pj_str_t reason;\n\n\t    reason = pj_strerror(status, errmsg, sizeof(errmsg));\n\t    pjsip_endpt_respond_stateless(dlg->endpt, rdata, 500, &reason,\n\t\t\t\t\t  NULL, NULL);\n\t    goto on_return;\n\t}\n\n\t/* Put this dialog in the transaction data. */\n\ttsx->mod_data[dlg->ua->id] = dlg;\n\n\t/* Add transaction count. */\n\t++dlg->tsx_count;\n    }\n\n    /* Update the target URI if this is a target refresh request.\n     * We have passed the basic checking for the request, I think we\n     * should update the target URI regardless of whether the request\n     * is accepted or not (e.g. when re-INVITE is answered with 488,\n     * we would still need to update the target URI, otherwise our\n     * target URI would be wrong, wouldn't it).\n     */\n    if (pjsip_method_creates_dialog(&rdata->msg_info.cseq->method)) {\n\tpjsip_contact_hdr *contact;\n\n\tcontact = (pjsip_contact_hdr*)\n\t\t  pjsip_msg_find_hdr(rdata->msg_info.msg, PJSIP_H_CONTACT,\n\t\t\t\t     NULL);\n\tif (contact && contact->uri &&\n\t    (dlg->remote.contact==NULL ||\n \t     pjsip_uri_cmp(PJSIP_URI_IN_REQ_URI,\n\t\t\t   dlg->remote.contact->uri,\n\t\t\t   contact->uri)))\n\t{\n\t    dlg->remote.contact = (pjsip_contact_hdr*)\n\t    \t\t\t  pjsip_hdr_clone(dlg->pool, contact);\n\t    dlg->target = dlg->remote.contact->uri;\n\t}\n    }\n\n    /* Report the request to dialog usages. */\n    for (i=0; i<dlg->usage_cnt; ++i) {\n\n\tif (!dlg->usage[i]->on_rx_request)\n\t    continue;\n\n\tprocessed = (*dlg->usage[i]->on_rx_request)(rdata);\n\n\tif (processed)\n\t    break;\n    }\n\n    /* Feed the first request to the transaction. */\n    if (tsx)\n\tpjsip_tsx_recv_msg(tsx, rdata);\n\n    /* If no dialog usages has claimed the processing of the transaction,\n     * and if transaction has not sent final response, respond with\n     * 500/Internal Server Error.\n     */\n    if (!processed && tsx && tsx->status_code < 200) {\n\tpjsip_tx_data *tdata;\n\tconst pj_str_t reason = { \"Unhandled by dialog usages\", 26};\n\n\tPJ_LOG(4,(tsx->obj_name, \"%s was unhandled by \"\n\t\t\t\t \"dialog usages, sending 500 response\",\n\t\t\t\t pjsip_rx_data_get_info(rdata)));\n\n\tstatus = pjsip_dlg_create_response(dlg, rdata, 500, &reason, &tdata);\n\tif (status == PJ_SUCCESS) {\n\t    status = pjsip_dlg_send_response(dlg, tsx, tdata);\n\t}\n    }\n\non_return:\n    /* Unlock dialog and dec session, may destroy dialog. */\n    pjsip_dlg_dec_lock(dlg);\n    pj_log_pop_indent();\n}\n\n/* Update route-set from incoming message */\nstatic void dlg_update_routeset(pjsip_dialog *dlg, const pjsip_rx_data *rdata)\n{\n    const pjsip_hdr *hdr, *end_hdr;\n    //pj_int32_t msg_cseq;\n    const pjsip_msg *msg;\n    const pjsip_method update = { PJSIP_OTHER_METHOD, {\"UPDATE\", 6}};\n\n    msg = rdata->msg_info.msg;\n    //msg_cseq = rdata->msg_info.cseq->cseq;\n\n    /* Ignore if route set has been frozen */\n    if (dlg->route_set_frozen)\n\treturn;\n\n    /* Ignore if the message is an UPDATE response (see ticket #1781) */\n    if (pjsip_method_cmp(&rdata->msg_info.cseq->method, &update) == 0)\n\treturn;\n\n    /* Only update route set if this message belongs to the same\n     * transaction as the initial transaction that establishes dialog.\n     */\n    if (dlg->role == PJSIP_ROLE_UAC) {\n    \t/* Save initial destination host from transport's info. */\n    \tif (!dlg->initial_dest.slen) {\n    \t    pj_strdup(dlg->pool, &dlg->initial_dest,\n    \t      \t      &rdata->tp_info.transport->remote_name.host);\n    \t}\n\n\t/* Ignore subsequent request from remote */\n\tif (msg->type != PJSIP_RESPONSE_MSG)\n\t    return;\n\n\t/* Ignore subsequent responses with higher CSeq than initial CSeq.\n\t * Unfortunately this would be broken when the first request is\n\t * challenged!\n\t */\n\t//if (msg_cseq != dlg->local.first_cseq)\n\t//    return;\n\n    } else {\n\n\t/* For callee dialog, route set should have been set by initial\n\t * request and it will have been rejected by dlg->route_set_frozen\n\t * check above.\n\t */\n\tpj_assert(!\"Should not happen\");\n\n    }\n\n    /* Based on the checks above, we should only get response message here */\n    pj_assert(msg->type == PJSIP_RESPONSE_MSG);\n\n    /* Ignore if this is not 1xx or 2xx response */\n    if (msg->line.status.code >= 300)\n\treturn;\n\n    /* Reset route set */\n    pj_list_init(&dlg->route_set);\n\n    /* Update route set */\n    end_hdr = &msg->hdr;\n    for (hdr=msg->hdr.prev; hdr!=end_hdr; hdr=hdr->prev) {\n\tif (hdr->type == PJSIP_H_RECORD_ROUTE) {\n\t    pjsip_route_hdr *r;\n\t    r = (pjsip_route_hdr*) pjsip_hdr_clone(dlg->pool, hdr);\n\t    pjsip_routing_hdr_set_route(r);\n\t    pj_list_push_back(&dlg->route_set, r);\n\t}\n    }\n\n    PJ_LOG(5,(dlg->obj_name, \"Route-set updated\"));\n\n    /* Freeze the route set only when the route set comes in 2xx response.\n     * If it is in 1xx response, prepare to recompute the route set when\n     * the 2xx response comes in.\n     *\n     * There is a debate whether route set should be frozen when the dialog\n     * is established with reliable provisional response, but I think\n     * it is safer to not freeze the route set (thus recompute the route set\n     * upon receiving 2xx response). Also RFC 3261 says so in 13.2.2.4.\n     *\n     * The pjsip_method_creates_dialog() check protects from wrongly\n     * freezing the route set upon receiving 200/OK response for PRACK.\n     */\n    if (pjsip_method_creates_dialog(&rdata->msg_info.cseq->method) &&\n\tPJSIP_IS_STATUS_IN_CLASS(msg->line.status.code, 200))\n    {\n\tdlg->route_set_frozen = PJ_TRUE;\n\tPJ_LOG(5,(dlg->obj_name, \"Route-set frozen\"));\n    }\n}\n\n\n/* This function is called by user agent upon receiving incoming response\n * message.\n */\nvoid pjsip_dlg_on_rx_response( pjsip_dialog *dlg, pjsip_rx_data *rdata )\n{\n    unsigned i;\n    int res_code;\n\n    PJ_LOG(5,(dlg->obj_name, \"Received %s\",\n\t      pjsip_rx_data_get_info(rdata)));\n    pj_log_push_indent();\n\n    /* Lock the dialog and inc session. */\n    pjsip_dlg_inc_lock(dlg);\n\n    /* Check that rdata already has dialog in mod_data. */\n    pj_assert(pjsip_rdata_get_dlg(rdata) == dlg);\n\n    /* Keep the response's status code */\n    res_code = rdata->msg_info.msg->line.status.code;\n\n    /* When we receive response that establishes dialog, update To tag,\n     * route set and dialog target.\n     *\n     * The second condition of the \"if\" is a workaround for forking.\n     * Originally, the dialog takes the first To tag seen and set it as\n     * the remote tag. If the tag in 2xx response is different than this\n     * tag, ACK will be sent with wrong To tag and incoming request with\n     * this tag will be rejected with 481.\n     *\n     * The workaround for this is to take the To tag received in the\n     * 2xx response and set it as remote tag.\n     *\n     * New update:\n     * We also need to update the dialog for 1xx responses, to handle the\n     * case when 100rel is used, otherwise PRACK will be sent to the\n     * wrong target.\n     */\n    if ((dlg->state == PJSIP_DIALOG_STATE_NULL &&\n\t pjsip_method_creates_dialog(&rdata->msg_info.cseq->method) &&\n\t (res_code > 100 && res_code < 300) &&\n\t rdata->msg_info.to->tag.slen)\n\t ||\n\t(dlg->role==PJSIP_ROLE_UAC &&\n\t !dlg->uac_has_2xx &&\n\t res_code > 100 &&\n\t res_code/100 <= 2 &&\n\t pjsip_method_creates_dialog(&rdata->msg_info.cseq->method) &&\n\t pj_stricmp(&dlg->remote.info->tag, &rdata->msg_info.to->tag)))\n    {\n\tpjsip_contact_hdr *contact;\n\n\t/* Update remote capability info, when To tags in the dialog remote\n\t * info and the incoming response are different, e.g: first response\n\t * with To-tag or forking, apply strict update.\n\t */\n\tpjsip_dlg_update_remote_cap(dlg, rdata->msg_info.msg,\n\t\t\t\t    pj_stricmp(&dlg->remote.info->tag,\n\t\t\t\t\t      &rdata->msg_info.to->tag));\n\n\t/* Update To tag. */\n\tpj_strdup(dlg->pool, &dlg->remote.info->tag, &rdata->msg_info.to->tag);\n\t/* No need to update remote's tag_hval since its never used. */\n\n\t/* RFC 3271 Section 12.1.2:\n\t * The route set MUST be set to the list of URIs in the Record-Route\n\t * header field from the response, taken in reverse order and\n\t * preserving all URI parameters. If no Record-Route header field\n\t * is present in the response, the route set MUST be set to the\n\t * empty set. This route set, even if empty, overrides any pre-existing\n\t * route set for future requests in this dialog.\n\t */\n\tdlg_update_routeset(dlg, rdata);\n\n\t/* The remote target MUST be set to the URI from the Contact header\n\t * field of the response.\n\t */\n\tcontact = (pjsip_contact_hdr*)\n\t\t  pjsip_msg_find_hdr(rdata->msg_info.msg, PJSIP_H_CONTACT,\n\t\t\t\t     NULL);\n\tif (contact && contact->uri &&\n\t    (dlg->remote.contact==NULL ||\n\t     pjsip_uri_cmp(PJSIP_URI_IN_REQ_URI,\n\t\t\t   dlg->remote.contact->uri,\n\t\t\t   contact->uri)))\n\t{\n\t    dlg->remote.contact = (pjsip_contact_hdr*)\n\t    \t\t\t  pjsip_hdr_clone(dlg->pool, contact);\n\t    dlg->target = dlg->remote.contact->uri;\n\t}\n\n\tdlg->state = PJSIP_DIALOG_STATE_ESTABLISHED;\n\n\t/* Prevent dialog from being updated just in case more 2xx\n\t * gets through this dialog (it shouldn't happen).\n\t */\n\tif (dlg->role==PJSIP_ROLE_UAC && !dlg->uac_has_2xx &&\n\t    res_code/100==2)\n\t{\n\t    dlg->uac_has_2xx = PJ_TRUE;\n\t}\n    }\n\n    /* Update remote target (again) when receiving 2xx response messages\n     * that's defined as target refresh.\n     *\n     * Also upon receiving 2xx response, recheck again the route set.\n     * This is for compatibility with RFC 2543, as described in Section\n     * 13.2.2.4 of RFC 3261:\n\n\tIf the dialog identifier in the 2xx response matches the dialog\n\tidentifier of an existing dialog, the dialog MUST be transitioned to\n\tthe \"confirmed\" state, and the route set for the dialog MUST be\n\trecomputed based on the 2xx response using the procedures of Section\n\t12.2.1.2.\n\n\tNote that the only piece of state that is recomputed is the route\n\tset.  Other pieces of state such as the highest sequence numbers\n\t(remote and local) sent within the dialog are not recomputed.  The\n\troute set only is recomputed for backwards compatibility.  RFC\n\t2543 did not mandate mirroring of the Record-Route header field in\n\ta 1xx, only 2xx.\n     */\n    if (pjsip_method_creates_dialog(&rdata->msg_info.cseq->method) &&\n\tres_code/100 == 2)\n    {\n\tpjsip_contact_hdr *contact;\n\n\tcontact = (pjsip_contact_hdr*) pjsip_msg_find_hdr(rdata->msg_info.msg,\n\t\t\t\t\t\t\t  PJSIP_H_CONTACT,\n\t\t\t\t     \t\t\t  NULL);\n\tif (contact && contact->uri &&\n\t    (dlg->remote.contact==NULL ||\n\t     pjsip_uri_cmp(PJSIP_URI_IN_REQ_URI,\n\t\t\t   dlg->remote.contact->uri,\n\t\t\t   contact->uri)))\n\t{\n\t    dlg->remote.contact = (pjsip_contact_hdr*)\n\t    \t\t\t  pjsip_hdr_clone(dlg->pool, contact);\n\t    dlg->target = dlg->remote.contact->uri;\n\t}\n\n\tdlg_update_routeset(dlg, rdata);\n\n\t/* Update remote capability info after the first 2xx response\n\t * (ticket #1539). Note that the remote capability retrieved here\n\t * will be assumed to remain unchanged for the duration of the dialog.\n\t */\n\tif (dlg->role==PJSIP_ROLE_UAC && !dlg->uac_has_2xx) {\n\t    pjsip_dlg_update_remote_cap(dlg, rdata->msg_info.msg, PJ_FALSE);\n\t    dlg->uac_has_2xx = PJ_TRUE;\n\t}\n    }\n\n    /* Pass to dialog usages. */\n    for (i=0; i<dlg->usage_cnt; ++i) {\n\tpj_bool_t processed;\n\n\tif (!dlg->usage[i]->on_rx_response)\n\t    continue;\n\n\tprocessed = (*dlg->usage[i]->on_rx_response)(rdata);\n\n\tif (processed)\n\t    break;\n    }\n\n    /* Handle the case of forked response, when the application creates\n     * the forked dialog but not the invite session. In this case, the\n     * forked 200/OK response will be unhandled, and we must send ACK\n     * here.\n     */\n    if (dlg->usage_cnt==0) {\n\tpj_status_t status;\n\n\tif (rdata->msg_info.cseq->method.id==PJSIP_INVITE_METHOD &&\n\t    rdata->msg_info.msg->line.status.code/100 == 2)\n\t{\n\t    pjsip_tx_data *ack;\n\n\t    status = pjsip_dlg_create_request(dlg, &pjsip_ack_method,\n\t\t\t\t\t      rdata->msg_info.cseq->cseq,\n\t\t\t\t\t      &ack);\n\t    if (status == PJ_SUCCESS)\n\t\tstatus = pjsip_dlg_send_request(dlg, ack, -1, NULL);\n\t} else if (rdata->msg_info.msg->line.status.code==401 ||\n\t\t   rdata->msg_info.msg->line.status.code==407)\n\t{\n\t    pjsip_transaction *tsx = pjsip_rdata_get_tsx(rdata);\n\t    pjsip_tx_data *tdata;\n\n\t    status = pjsip_auth_clt_reinit_req( &dlg->auth_sess,\n\t\t\t\t\t\trdata, tsx->last_tx,\n\t\t\t\t\t\t&tdata);\n\n\t    if (status == PJ_SUCCESS) {\n\t\t/* Re-send request. */\n\t\tstatus = pjsip_dlg_send_request(dlg, tdata, -1, NULL);\n\t    }\n\t}\n    }\n\n    /* Unhandled response does not necessarily mean error because\n       dialog usages may choose to process the transaction state instead.\n    if (i==dlg->usage_cnt) {\n\tPJ_LOG(4,(dlg->obj_name, \"%s was not claimed by any dialog usages\",\n\t\t  pjsip_rx_data_get_info(rdata)));\n    }\n    */\n\n    /* Unlock dialog and dec session, may destroy dialog. */\n    pjsip_dlg_dec_lock(dlg);\n\n    pj_log_pop_indent();\n}\n\n/* This function is called by user agent upon receiving transaction\n * state notification.\n */\nvoid pjsip_dlg_on_tsx_state( pjsip_dialog *dlg,\n\t\t\t     pjsip_transaction *tsx,\n\t\t\t     pjsip_event *e )\n{\n    unsigned i;\n\n    PJ_LOG(5,(dlg->obj_name, \"Transaction %s state changed to %s\",\n\t      tsx->obj_name, pjsip_tsx_state_str(tsx->state)));\n    pj_log_push_indent();\n\n    /* Lock the dialog and increment session. */\n    pjsip_dlg_inc_lock(dlg);\n\n    /* Pass to dialog usages. */\n    for (i=0; i<dlg->usage_cnt; ++i) {\n\n\tif (!dlg->usage[i]->on_tsx_state)\n\t    continue;\n\n\t(*dlg->usage[i]->on_tsx_state)(tsx, e);\n    }\n\n\n    /* It is possible that the transaction is terminated and this function\n     * is called while we're calling on_tsx_state(). So only decrement\n     * the tsx_count if we're still attached to the transaction.\n     */\n    if (tsx->state == PJSIP_TSX_STATE_TERMINATED &&\n\ttsx->mod_data[dlg->ua->id] == dlg)\n    {\n\tpj_assert(dlg->tsx_count>0);\n\t--dlg->tsx_count;\n\ttsx->mod_data[dlg->ua->id] = NULL;\n    }\n\n    /* Unlock dialog and dec session, may destroy dialog. */\n    pjsip_dlg_dec_lock(dlg);\n    pj_log_pop_indent();\n}\n\n\n/*\n * Check if the specified capability is supported by remote.\n */\nPJ_DEF(pjsip_dialog_cap_status) pjsip_dlg_remote_has_cap(\n\t\t\t\t\t\t    pjsip_dialog *dlg,\n\t\t\t\t\t\t    int htype,\n\t\t\t\t\t\t    const pj_str_t *hname,\n\t\t\t\t\t\t    const pj_str_t *token)\n{\n    const pjsip_generic_array_hdr *hdr;\n    pjsip_dialog_cap_status cap_status = PJSIP_DIALOG_CAP_UNSUPPORTED;\n    unsigned i;\n\n    PJ_ASSERT_RETURN(dlg && token, PJSIP_DIALOG_CAP_UNKNOWN);\n\n    pjsip_dlg_inc_lock(dlg);\n\n    hdr = (const pjsip_generic_array_hdr*)\n\t   pjsip_dlg_get_remote_cap_hdr(dlg, htype, hname);\n    if (!hdr) {\n\tcap_status = PJSIP_DIALOG_CAP_UNKNOWN;\n    } else {\n\tfor (i=0; i<hdr->count; ++i) {\n\t    if (!pj_stricmp(&hdr->values[i], token)) {\n\t\tcap_status = PJSIP_DIALOG_CAP_SUPPORTED;\n\t\tbreak;\n\t    }\n\t}\n    }\n\n    pjsip_dlg_dec_lock(dlg);\n\n    return cap_status;\n}\n\n\n/*\n * Update remote capability of ACCEPT, ALLOW, and SUPPORTED from\n * the received message.\n */\nPJ_DEF(pj_status_t) pjsip_dlg_update_remote_cap(pjsip_dialog *dlg,\n\t\t\t\t\t        const pjsip_msg *msg,\n\t\t\t\t\t\tpj_bool_t strict)\n{\n    pjsip_hdr_e htypes[] =\n\t{ PJSIP_H_ACCEPT, PJSIP_H_ALLOW, PJSIP_H_SUPPORTED };\n    unsigned i;\n\n    PJ_ASSERT_RETURN(dlg && msg, PJ_EINVAL);\n\n    pjsip_dlg_inc_lock(dlg);\n\n    /* Retrieve all specified capability header types */\n    for (i = 0; i < PJ_ARRAY_SIZE(htypes); ++i) {\n\tconst pjsip_generic_array_hdr *hdr;\n\tpj_status_t status;\n\n\t/* Find this capability type in the message */\n\thdr = (const pjsip_generic_array_hdr*)\n\t      pjsip_msg_find_hdr(msg, htypes[i], NULL);\n\tif (!hdr) {\n\t    /* Not found.\n\t     * If strict update is specified, remote this capability type\n\t     * from the capability list.\n\t     */\n\t    if (strict)\n\t\tpjsip_dlg_remove_remote_cap_hdr(dlg, htypes[i], NULL);\n\t} else {\n\t    /* Found, a capability type may be specified in multiple headers,\n\t     * so combine all the capability tags/values into a temporary\n\t     * header.\n\t     */\n\t    pjsip_generic_array_hdr tmp_hdr;\n\n\t    /* Init temporary header */\n\t    pjsip_generic_array_hdr_init(dlg->pool, &tmp_hdr, NULL);\n\t    pj_memcpy(&tmp_hdr, hdr, sizeof(pjsip_hdr));\n\n\t    while (hdr) {\n\t\tunsigned j;\n\n\t\t/* Append the header content to temporary header */\n\t\tfor(j=0; j<hdr->count &&\n\t\t\t tmp_hdr.count<PJSIP_GENERIC_ARRAY_MAX_COUNT; ++j)\n\t\t{\n\t\t    tmp_hdr.values[tmp_hdr.count++] = hdr->values[j];\n\t\t}\n\n\t\t/* Get the next header for this capability */\n\t\thdr = (const pjsip_generic_array_hdr*)\n\t\t      pjsip_msg_find_hdr(msg, htypes[i], hdr->next);\n\t    }\n\n\t    /* Save this capability */\n\t    status = pjsip_dlg_set_remote_cap_hdr(dlg, &tmp_hdr);\n\t    if (status != PJ_SUCCESS) {\n\t\tpjsip_dlg_dec_lock(dlg);\n\t\treturn status;\n\t    }\n\t}\n    }\n\n    pjsip_dlg_dec_lock(dlg);\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Get the value of the specified capability header field of remote.\n */\nPJ_DEF(const pjsip_hdr*) pjsip_dlg_get_remote_cap_hdr(pjsip_dialog *dlg,\n\t\t\t\t\t\t      int htype,\n\t\t\t\t\t\t      const pj_str_t *hname)\n{\n    pjsip_hdr *hdr;\n\n    /* Check arguments. */\n    PJ_ASSERT_RETURN(dlg, NULL);\n    PJ_ASSERT_RETURN((htype != PJSIP_H_OTHER) || (hname && hname->slen),\n\t\t     NULL);\n\n    pjsip_dlg_inc_lock(dlg);\n\n    hdr = dlg->rem_cap_hdr.next;\n    while (hdr != &dlg->rem_cap_hdr) {\n\tif ((htype != PJSIP_H_OTHER && htype == hdr->type) ||\n\t    (htype == PJSIP_H_OTHER && pj_stricmp(&hdr->name, hname) == 0))\n\t{\n\t    pjsip_dlg_dec_lock(dlg);\n\t    return hdr;\n\t}\n\thdr = hdr->next;\n    }\n\n    pjsip_dlg_dec_lock(dlg);\n\n    return NULL;\n}\n\n\n/*\n * Set remote capability header from a SIP header containing array\n * of capability tags/values.\n */\nPJ_DEF(pj_status_t) pjsip_dlg_set_remote_cap_hdr(\n\t\t\t\t    pjsip_dialog *dlg,\n\t\t\t\t    const pjsip_generic_array_hdr *cap_hdr)\n{\n    pjsip_generic_array_hdr *hdr;\n\n    /* Check arguments. */\n    PJ_ASSERT_RETURN(dlg && cap_hdr, PJ_EINVAL);\n\n    pjsip_dlg_inc_lock(dlg);\n\n    /* Find the header. */\n    hdr = (pjsip_generic_array_hdr*)\n\t  pjsip_dlg_get_remote_cap_hdr(dlg, cap_hdr->type, &cap_hdr->name);\n\n    /* Quick compare if the capability is up to date */\n    if (hdr && hdr->count == cap_hdr->count) {\n\tunsigned i;\n\tpj_bool_t uptodate = PJ_TRUE;\n\n\tfor (i=0; i<hdr->count; ++i) {\n\t    if (pj_stricmp(&hdr->values[i], &cap_hdr->values[i]))\n\t\tuptodate = PJ_FALSE;\n\t}\n\n\t/* Capability is up to date, just return PJ_SUCCESS */\n\tif (uptodate) {\n\t    pjsip_dlg_dec_lock(dlg);\n\t    return PJ_SUCCESS;\n\t}\n    }\n\n    /* Remove existing capability header if any */\n    if (hdr)\n\tpj_list_erase(hdr);\n\n    /* Add the new capability header */\n    hdr = (pjsip_generic_array_hdr*) pjsip_hdr_clone(dlg->pool, cap_hdr);\n    hdr->type = cap_hdr->type;\n    pj_strdup(dlg->pool, &hdr->name, &cap_hdr->name);\n    pj_list_push_back(&dlg->rem_cap_hdr, hdr);\n\n    pjsip_dlg_dec_lock(dlg);\n\n    /* Done. */\n    return PJ_SUCCESS;\n}\n\n/*\n * Remove a remote capability header.\n */\nPJ_DEF(pj_status_t) pjsip_dlg_remove_remote_cap_hdr(pjsip_dialog *dlg,\n\t\t\t\t\t\t    int htype,\n\t\t\t\t\t\t    const pj_str_t *hname)\n{\n    pjsip_generic_array_hdr *hdr;\n\n    /* Check arguments. */\n    PJ_ASSERT_RETURN(dlg, PJ_EINVAL);\n    PJ_ASSERT_RETURN((htype != PJSIP_H_OTHER) || (hname && hname->slen),\n\t\t     PJ_EINVAL);\n\n    pjsip_dlg_inc_lock(dlg);\n\n    hdr = (pjsip_generic_array_hdr*)\n\t  pjsip_dlg_get_remote_cap_hdr(dlg, htype, hname);\n    if (!hdr) {\n\tpjsip_dlg_dec_lock(dlg);\n\treturn PJ_ENOTFOUND;\n    }\n\n    pj_list_erase(hdr);\n\n    pjsip_dlg_dec_lock(dlg);\n\n    return PJ_SUCCESS;\n}\n", "/* $Id$ */\n/* \n * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)\n * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n#include <pjsip/sip_transport.h>\n#include <pjsip/sip_endpoint.h>\n#include <pjsip/sip_parser.h>\n#include <pjsip/sip_msg.h>\n#include <pjsip/sip_private.h>\n#include <pjsip/sip_errno.h>\n#include <pjsip/sip_module.h>\n#include <pj/addr_resolv.h>\n#include <pj/except.h>\n#include <pj/os.h>\n#include <pj/log.h>\n#include <pj/ioqueue.h>\n#include <pj/hash.h>\n#include <pj/string.h>\n#include <pj/pool.h>\n#include <pj/assert.h>\n#include <pj/lock.h>\n#include <pj/list.h>\n\n\n#define THIS_FILE    \"sip_transport.c\"\n\n#if 0\n#   define TRACE_(x)\tPJ_LOG(5,x)\n\nstatic const char *addr_string(const pj_sockaddr_t *addr)\n{\n    static char str[PJ_INET6_ADDRSTRLEN];\n    pj_inet_ntop(((const pj_sockaddr*)addr)->addr.sa_family, \n\t\t pj_sockaddr_get_addr(addr),\n\t\t str, sizeof(str));\n    return str;\n}\nstatic const char* print_tpsel_info(const pjsip_tpselector *sel)\n{\n    static char tpsel_info_buf[80];\n    if (!sel) return \"(null)\";\n    if (sel->type==PJSIP_TPSELECTOR_LISTENER)\n\tpj_ansi_snprintf(tpsel_info_buf, sizeof(tpsel_info_buf),\n\t\t\t \"listener[%s], reuse=%d\", sel->u.listener->obj_name,\n\t\t\t !sel->disable_connection_reuse);\n    else if (sel->type==PJSIP_TPSELECTOR_TRANSPORT)\n\tpj_ansi_snprintf(tpsel_info_buf, sizeof(tpsel_info_buf),\n\t\t\t \"transport[%s], reuse=%d\", sel->u.transport->info,\n\t\t\t !sel->disable_connection_reuse);\n    else\n\tpj_ansi_snprintf(tpsel_info_buf, sizeof(tpsel_info_buf),\n\t\t\t \"unknown[%p], reuse=%d\", sel->u.ptr,\n\t\t\t !sel->disable_connection_reuse);\n    return tpsel_info_buf;\n}\n#else\n#   define TRACE_(x)\n#endif\n\n/* Specify the initial size of the transport manager's pool. */\n#ifndef  TPMGR_POOL_INIT_SIZE\n#   define TPMGR_POOL_INIT_SIZE\t64\n#endif\n\n/* Specify the increment size of the transport manager's pool. */\n#ifndef TPMGR_POOL_INC_SIZE\n    #define TPMGR_POOL_INC_SIZE\t64\n#endif\n\n/* Specify transport entry allocation count. When registering a new transport,\n * a new entry will be picked from a free list. This setting will determine\n * the size of the free list size. If all entry is used, then the same number\n * of entry will be allocated.\n */\n#ifndef PJSIP_TRANSPORT_ENTRY_ALLOC_CNT\n#   define PJSIP_TRANSPORT_ENTRY_ALLOC_CNT  16\n#endif\n\n/* Prototype. */\nstatic pj_status_t mod_on_tx_msg(pjsip_tx_data *tdata);\n\n/* This module has sole purpose to print transmit data to contigous buffer\n * before actually transmitted to the wire. \n */\nstatic pjsip_module mod_msg_print = \n{\n    NULL, NULL,\t\t\t\t/* prev and next\t\t    */\n    { \"mod-msg-print\", 13},\t\t/* Name.\t\t\t    */\n    -1,\t\t\t\t\t/* Id\t\t\t\t    */\n    PJSIP_MOD_PRIORITY_TRANSPORT_LAYER,\t/* Priority\t\t\t    */\n    NULL,\t\t\t\t/* load()\t\t\t    */\n    NULL,\t\t\t\t/* start()\t\t\t    */\n    NULL,\t\t\t\t/* stop()\t\t\t    */\n    NULL,\t\t\t\t/* unload()\t\t\t    */\n    NULL,\t\t\t\t/* on_rx_request()\t\t    */\n    NULL,\t\t\t\t/* on_rx_response()\t\t    */\n    &mod_on_tx_msg,\t\t\t/* on_tx_request()\t\t    */\n    &mod_on_tx_msg,\t\t\t/* on_tx_response()\t\t    */\n    NULL,\t\t\t\t/* on_tsx_state()\t\t    */\n};\n\n/* Transport list item */\ntypedef struct transport\n{\n    PJ_DECL_LIST_MEMBER(struct transport);\n    pj_hash_entry_buf tp_buf;\n    pjsip_transport *tp;\n} transport;\n\n/*\n * Transport manager.\n */\nstruct pjsip_tpmgr \n{\n    pj_hash_table_t *table;\n    pj_lock_t\t    *lock;\n    pjsip_endpoint  *endpt;\n    pjsip_tpfactory  factory_list;\n    pj_pool_t\t    *pool;\n#if defined(PJ_DEBUG) && PJ_DEBUG!=0\n    pj_atomic_t\t    *tdata_counter;\n#endif\n    void           (*on_rx_msg)(pjsip_endpoint*, pj_status_t, pjsip_rx_data*);\n    pj_status_t\t   (*on_tx_msg)(pjsip_endpoint*, pjsip_tx_data*);\n    pjsip_tp_state_callback tp_state_cb;\n    pjsip_tp_on_rx_dropped_cb tp_drop_data_cb;\n\n    /* Transmit data list, for transmit data cleanup when transport manager\n     * is destroyed.\n     */\n    pjsip_tx_data    tdata_list;\n\n    /* List of free transport entry. */\n    transport\t     tp_entry_freelist;\n};\n\n\n/* Transport state listener list type */\ntypedef struct tp_state_listener\n{\n    PJ_DECL_LIST_MEMBER(struct tp_state_listener);\n\n    pjsip_tp_state_callback  cb;\n    void *user_data;\n} tp_state_listener;\n\n\n/*\n * Transport data.\n */\ntypedef struct transport_data\n{\n    /* Transport listeners */\n    tp_state_listener\t    st_listeners;\n    tp_state_listener\t    st_listeners_empty;\n} transport_data;\n\n\n/*****************************************************************************\n *\n * GENERAL TRANSPORT (NAMES, TYPES, ETC.)\n *\n *****************************************************************************/\n\n/*\n * Transport names.\n */\nstatic struct transport_names_t\n{\n    pjsip_transport_type_e type;\t    /* Transport type\t    */\n    pj_uint16_t\t\t   port;\t    /* Default port number  */\n    pj_str_t\t\t   name;\t    /* Id tag\t\t    */\n    const char\t\t  *description;\t    /* Longer description   */\n    unsigned\t\t   flag;\t    /* Flags\t\t    */\n    char\t\t   name_buf[16];    /* For user's transport */\n} transport_names[16] = \n{\n    { \n\tPJSIP_TRANSPORT_UNSPECIFIED, \n\t0, \n\t{\"Unspecified\", 11}, \n\t\"Unspecified\", \n\t0\n    },\n    { \n\tPJSIP_TRANSPORT_UDP, \n\t5060, \n\t{\"UDP\", 3}, \n\t\"UDP transport\", \n\tPJSIP_TRANSPORT_DATAGRAM\n    },\n    { \n\tPJSIP_TRANSPORT_TCP, \n\t5060, \n\t{\"TCP\", 3}, \n\t\"TCP transport\", \n\tPJSIP_TRANSPORT_RELIABLE\n    },\n    { \n\tPJSIP_TRANSPORT_TLS, \n\t5061, \n\t{\"TLS\", 3}, \n\t\"TLS transport\", \n\tPJSIP_TRANSPORT_RELIABLE | PJSIP_TRANSPORT_SECURE\n    },\n    { \n\tPJSIP_TRANSPORT_DTLS,\n\t5061, \n\t{\"DTLS\", 4}, \n\t\"DTLS transport\", \n\tPJSIP_TRANSPORT_SECURE\n    },\n    { \n\tPJSIP_TRANSPORT_SCTP, \n\t5060, \n\t{\"SCTP\", 4}, \n\t\"SCTP transport\", \n\tPJSIP_TRANSPORT_RELIABLE\n    },\n    { \n\tPJSIP_TRANSPORT_LOOP, \n\t15060, \n\t{\"LOOP\", 4}, \n\t\"Loopback transport\", \n\tPJSIP_TRANSPORT_RELIABLE\n    }, \n    { \n\tPJSIP_TRANSPORT_LOOP_DGRAM, \n\t15060, \n\t{\"LOOP-DGRAM\", 10}, \n\t\"Loopback datagram transport\", \n\tPJSIP_TRANSPORT_DATAGRAM\n    },\n    { \n\tPJSIP_TRANSPORT_UDP6, \n\t5060, \n\t{\"UDP\", 3}, \n\t\"UDP IPv6 transport\", \n\tPJSIP_TRANSPORT_DATAGRAM\n    },\n    { \n\tPJSIP_TRANSPORT_TCP6, \n\t5060, \n\t{\"TCP\", 3}, \n\t\"TCP IPv6 transport\", \n\tPJSIP_TRANSPORT_RELIABLE\n    },\n    {\n\tPJSIP_TRANSPORT_TLS6,\n\t5061,\n\t{\"TLS\", 3},\n\t\"TLS IPv6 transport\",\n\tPJSIP_TRANSPORT_RELIABLE | PJSIP_TRANSPORT_SECURE\n    },\n    {\n\tPJSIP_TRANSPORT_DTLS6,\n\t5061,\n\t{\"DTLS\", 4},\n\t\"DTLS IPv6 transport\",\n\tPJSIP_TRANSPORT_SECURE\n    },\n};\n\nstatic void tp_state_callback(pjsip_transport *tp,\n\t\t\t      pjsip_transport_state state,\n\t\t\t      const pjsip_transport_state_info *info);\n\n\nstatic struct transport_names_t *get_tpname(pjsip_transport_type_e type)\n{\n    unsigned i;\n    for (i=0; i<PJ_ARRAY_SIZE(transport_names); ++i) {\n\tif (transport_names[i].type == type)\n\t    return &transport_names[i];\n    }\n    pj_assert(!\"Invalid transport type!\");\n    return NULL;\n}\n\n\n\n/*\n * Register new transport type to PJSIP.\n */\nPJ_DEF(pj_status_t) pjsip_transport_register_type( unsigned tp_flag,\n\t\t\t\t\t\t   const char *tp_name,\n\t\t\t\t\t\t   int def_port,\n\t\t\t\t\t\t   int *p_tp_type)\n{\n    unsigned i;\n    pjsip_transport_type_e parent = 0;\n\n    PJ_ASSERT_RETURN(tp_flag && tp_name && def_port, PJ_EINVAL);\n    PJ_ASSERT_RETURN(pj_ansi_strlen(tp_name) < \n\t\t\tPJ_ARRAY_SIZE(transport_names[0].name_buf), \n\t\t     PJ_ENAMETOOLONG);\n\n    for (i=1; i<PJ_ARRAY_SIZE(transport_names); ++i) {\n        if (tp_flag & PJSIP_TRANSPORT_IPV6 && \n            pj_stricmp2(&transport_names[i].name, tp_name) == 0)\n        {\n\t    parent = transport_names[i].type;\n        }\n\tif (transport_names[i].type == 0)\n\t    break;\n    }\n\n    if (i == PJ_ARRAY_SIZE(transport_names))\n\treturn PJ_ETOOMANY;\n\n    if (tp_flag & PJSIP_TRANSPORT_IPV6 && parent) {\n        transport_names[i].type = parent | PJSIP_TRANSPORT_IPV6;\n    } else {\n        transport_names[i].type = (pjsip_transport_type_e)i;\n    }\n\n    transport_names[i].port = (pj_uint16_t)def_port;\n    pj_ansi_strcpy(transport_names[i].name_buf, tp_name);\n    transport_names[i].name = pj_str(transport_names[i].name_buf);\n    transport_names[i].flag = tp_flag;\n\n    if (p_tp_type)\n\t*p_tp_type = transport_names[i].type;\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Get transport type from name.\n */\nPJ_DEF(pjsip_transport_type_e) pjsip_transport_get_type_from_name(const pj_str_t *name)\n{\n    unsigned i;\n\n    if (name->slen == 0)\n\treturn PJSIP_TRANSPORT_UNSPECIFIED;\n\n    /* Get transport type from name. */\n    for (i=0; i<PJ_ARRAY_SIZE(transport_names); ++i) {\n\tif (pj_stricmp(name, &transport_names[i].name) == 0) {\n\t    return transport_names[i].type;\n\t}\n    }\n\n    pj_assert(!\"Invalid transport name\");\n    return PJSIP_TRANSPORT_UNSPECIFIED;\n}\n\n\n/*\n * Get the transport type for the specified flags.\n */\nPJ_DEF(pjsip_transport_type_e) pjsip_transport_get_type_from_flag(unsigned flag)\n{\n    unsigned i;\n\n    /* Get the transport type for the specified flags. */\n    for (i=0; i<PJ_ARRAY_SIZE(transport_names); ++i) {\n\tif (transport_names[i].flag == flag) {\n\t    return transport_names[i].type;\n\t}\n    }\n\n    pj_assert(!\"Invalid transport type\");\n    return PJSIP_TRANSPORT_UNSPECIFIED;\n}\n\n/*\n * Get the socket address family of a given transport type.\n */\nPJ_DEF(int) pjsip_transport_type_get_af(pjsip_transport_type_e type)\n{\n    if (type & PJSIP_TRANSPORT_IPV6)\n\treturn pj_AF_INET6();\n    else\n\treturn pj_AF_INET();\n}\n\nPJ_DEF(unsigned) pjsip_transport_get_flag_from_type(pjsip_transport_type_e type)\n{\n    /* Return transport flag. */\n    return get_tpname(type)->flag;\n}\n\n/*\n * Get the default SIP port number for the specified type.\n */\nPJ_DEF(int) pjsip_transport_get_default_port_for_type(pjsip_transport_type_e type)\n{\n    /* Return the port. */\n    return get_tpname(type)->port;\n}\n\n/*\n * Get transport name.\n */\nPJ_DEF(const char*) pjsip_transport_get_type_name(pjsip_transport_type_e type)\n{\n    /* Return the name. */\n    return get_tpname(type)->name.ptr;\n}\n\n/*\n * Get transport description.\n */\nPJ_DEF(const char*) pjsip_transport_get_type_desc(pjsip_transport_type_e type)\n{\n    /* Return the description. */\n    return get_tpname(type)->description;\n}\n\n\n/*****************************************************************************\n *\n * TRANSPORT SELECTOR\n *\n *****************************************************************************/\n\n/*\n * Add transport/listener reference in the selector.\n */\nPJ_DEF(void) pjsip_tpselector_add_ref(pjsip_tpselector *sel)\n{\n    if (sel->type == PJSIP_TPSELECTOR_TRANSPORT && sel->u.transport != NULL)\n\tpjsip_transport_add_ref(sel->u.transport);\n    else if (sel->type == PJSIP_TPSELECTOR_LISTENER && sel->u.listener != NULL)\n\t; /* Hmm.. looks like we don't have reference counter for listener */\n}\n\n\n/*\n * Decrement transport/listener reference in the selector.\n */\nPJ_DEF(void) pjsip_tpselector_dec_ref(pjsip_tpselector *sel)\n{\n    if (sel->type == PJSIP_TPSELECTOR_TRANSPORT && sel->u.transport != NULL)\n\tpjsip_transport_dec_ref(sel->u.transport);\n    else if (sel->type == PJSIP_TPSELECTOR_LISTENER && sel->u.listener != NULL)\n\t; /* Hmm.. looks like we don't have reference counter for listener */\n}\n\n\n/*****************************************************************************\n *\n * TRANSMIT DATA BUFFER MANIPULATION.\n *\n *****************************************************************************/\n\n/*\n * Create new transmit buffer.\n */\nPJ_DEF(pj_status_t) pjsip_tx_data_create( pjsip_tpmgr *mgr,\n\t\t\t\t\t  pjsip_tx_data **p_tdata )\n{\n    pj_pool_t *pool;\n    pjsip_tx_data *tdata;\n    pj_status_t status;\n\n    PJ_ASSERT_RETURN(mgr && p_tdata, PJ_EINVAL);\n\n    pool = pjsip_endpt_create_pool( mgr->endpt, \"tdta%p\",\n\t\t\t\t    PJSIP_POOL_LEN_TDATA,\n\t\t\t\t    PJSIP_POOL_INC_TDATA );\n    if (!pool)\n\treturn PJ_ENOMEM;\n\n    tdata = PJ_POOL_ZALLOC_T(pool, pjsip_tx_data);\n    tdata->pool = pool;\n    tdata->mgr = mgr;\n    pj_ansi_snprintf(tdata->obj_name, sizeof(tdata->obj_name), \"tdta%p\", tdata);\n    pj_memcpy(pool->obj_name, tdata->obj_name, sizeof(pool->obj_name));\n\n    status = pj_atomic_create(tdata->pool, 0, &tdata->ref_cnt);\n    if (status != PJ_SUCCESS) {\n\tpjsip_endpt_release_pool( mgr->endpt, tdata->pool );\n\treturn status;\n    }\n    \n    //status = pj_lock_create_simple_mutex(pool, \"tdta%p\", &tdata->lock);\n    status = pj_lock_create_null_mutex(pool, \"tdta%p\", &tdata->lock);\n    if (status != PJ_SUCCESS) {\n\tpjsip_endpt_release_pool( mgr->endpt, tdata->pool );\n\treturn status;\n    }\n\n    pj_ioqueue_op_key_init(&tdata->op_key.key, sizeof(tdata->op_key.key));\n    pj_list_init(tdata);\n\n#if defined(PJSIP_HAS_TX_DATA_LIST) && PJSIP_HAS_TX_DATA_LIST!=0\n    /* Append this just created tdata to transmit buffer list */\n    pj_lock_acquire(mgr->lock);\n    pj_list_push_back(&mgr->tdata_list, tdata);\n    pj_lock_release(mgr->lock);\n#endif\n\n#if defined(PJ_DEBUG) && PJ_DEBUG!=0\n    pj_atomic_inc( tdata->mgr->tdata_counter );\n#endif\n\n    *p_tdata = tdata;\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Add reference to tx buffer.\n */\nPJ_DEF(void) pjsip_tx_data_add_ref( pjsip_tx_data *tdata )\n{\n    pj_atomic_inc(tdata->ref_cnt);\n}\n\nstatic void tx_data_destroy(pjsip_tx_data *tdata)\n{\n    PJ_LOG(5,(tdata->obj_name, \"Destroying txdata %s\",\n\t      pjsip_tx_data_get_info(tdata)));\n    pjsip_tpselector_dec_ref(&tdata->tp_sel);\n#if defined(PJ_DEBUG) && PJ_DEBUG!=0\n    pj_atomic_dec( tdata->mgr->tdata_counter );\n#endif\n\n#if defined(PJSIP_HAS_TX_DATA_LIST) && PJSIP_HAS_TX_DATA_LIST!=0\n    /* Remove this tdata from transmit buffer list */\n    pj_lock_acquire(tdata->mgr->lock);\n    pj_list_erase(tdata);\n    pj_lock_release(tdata->mgr->lock);\n#endif\n\n    pj_atomic_destroy( tdata->ref_cnt );\n    pj_lock_destroy( tdata->lock );\n    pjsip_endpt_release_pool( tdata->mgr->endpt, tdata->pool );\n}\n\n/*\n * Decrease transport data reference, destroy it when the reference count\n * reaches zero.\n */\nPJ_DEF(pj_status_t) pjsip_tx_data_dec_ref( pjsip_tx_data *tdata )\n{\n    pj_atomic_value_t ref_cnt;\n    \n    PJ_ASSERT_RETURN(tdata && tdata->ref_cnt, PJ_EINVAL);\n\n    ref_cnt = pj_atomic_dec_and_get(tdata->ref_cnt);\n    pj_assert( ref_cnt >= 0);\n    if (ref_cnt == 0) {\n\ttx_data_destroy(tdata);\n\treturn PJSIP_EBUFDESTROYED;\n    } else {\n\treturn PJ_SUCCESS;\n    }\n}\n\n/*\n * Invalidate the content of the print buffer to force the message to be\n * re-printed when sent.\n */\nPJ_DEF(void) pjsip_tx_data_invalidate_msg( pjsip_tx_data *tdata )\n{\n    tdata->buf.cur = tdata->buf.start;\n    tdata->info = NULL;\n}\n\n/*\n * Print the SIP message to transmit data buffer's internal buffer.\n */\nPJ_DEF(pj_status_t) pjsip_tx_data_encode(pjsip_tx_data *tdata)\n{\n    /* Allocate buffer if necessary. */\n    if (tdata->buf.start == NULL) {\n\tPJ_USE_EXCEPTION;\n\n\tPJ_TRY {\n\t    tdata->buf.start = (char*) \n\t\t\t       pj_pool_alloc(tdata->pool, PJSIP_MAX_PKT_LEN);\n\t}\n\tPJ_CATCH_ANY {\n\t    return PJ_ENOMEM;\n\t}\n\tPJ_END\n\n\ttdata->buf.cur = tdata->buf.start;\n\ttdata->buf.end = tdata->buf.start + PJSIP_MAX_PKT_LEN;\n    }\n\n    /* Do we need to reprint? */\n    if (!pjsip_tx_data_is_valid(tdata)) {\n\tpj_ssize_t size;\n\n\tsize = pjsip_msg_print( tdata->msg, tdata->buf.start, \n\t\t\t        tdata->buf.end - tdata->buf.start);\n\tif (size < 0) {\n\t    return PJSIP_EMSGTOOLONG;\n\t}\n\tpj_assert(size != 0);\n\ttdata->buf.cur[size] = '\\0';\n\ttdata->buf.cur += size;\n    }\n\n    return PJ_SUCCESS;\n}\n\nPJ_DEF(pj_bool_t) pjsip_tx_data_is_valid( pjsip_tx_data *tdata )\n{\n    return tdata->buf.cur != tdata->buf.start;\n}\n\nstatic char *get_msg_info(pj_pool_t *pool, const char *obj_name,\n\t\t\t  const pjsip_msg *msg)\n{\n    char info_buf[128], *info;\n    const pjsip_cseq_hdr *cseq;\n    int len;\n\n    cseq = (const pjsip_cseq_hdr*) pjsip_msg_find_hdr(msg, PJSIP_H_CSEQ, NULL);\n    PJ_ASSERT_RETURN(cseq != NULL, \"INVALID MSG\");\n\n    if (msg->type == PJSIP_REQUEST_MSG) {\n\tlen = pj_ansi_snprintf(info_buf, sizeof(info_buf), \n\t\t\t       \"Request msg %.*s/cseq=%d (%s)\",\n\t\t\t       (int)msg->line.req.method.name.slen,\n\t\t\t       msg->line.req.method.name.ptr,\n\t\t\t       cseq->cseq, obj_name);\n    } else {\n\tlen = pj_ansi_snprintf(info_buf, sizeof(info_buf),\n\t\t\t       \"Response msg %d/%.*s/cseq=%d (%s)\",\n\t\t\t       msg->line.status.code,\n\t\t\t       (int)cseq->method.name.slen,\n\t\t\t       cseq->method.name.ptr,\n\t\t\t       cseq->cseq, obj_name);\n    }\n\n    if (len < 1 || len >= (int)sizeof(info_buf)) {\n\treturn (char*)obj_name;\n    }\n\n    info = (char*) pj_pool_alloc(pool, len+1);\n    pj_memcpy(info, info_buf, len+1);\n\n    return info;\n}\n\nPJ_DEF(char*) pjsip_tx_data_get_info( pjsip_tx_data *tdata )\n{\n    PJ_ASSERT_RETURN(tdata, \"NULL\");\n\n    /* tdata->info may be assigned by application so if it exists\n     * just return it.\n     */\n    if (tdata->info)\n\treturn tdata->info;\n\n    if (tdata->msg==NULL)\n\treturn \"NULL\";\n\n    pj_lock_acquire(tdata->lock);\n    tdata->info = get_msg_info(tdata->pool, tdata->obj_name, tdata->msg);\n    pj_lock_release(tdata->lock);\n\n    return tdata->info;\n}\n\nPJ_DEF(pj_status_t) pjsip_tx_data_set_transport(pjsip_tx_data *tdata,\n\t\t\t\t\t\tconst pjsip_tpselector *sel)\n{\n    PJ_ASSERT_RETURN(tdata && sel, PJ_EINVAL);\n\n    pj_lock_acquire(tdata->lock);\n\n    pjsip_tpselector_dec_ref(&tdata->tp_sel);\n\n    pj_memcpy(&tdata->tp_sel, sel, sizeof(*sel));\n    pjsip_tpselector_add_ref(&tdata->tp_sel);\n\n    pj_lock_release(tdata->lock);\n\n    return PJ_SUCCESS;\n}\n\n/* Clone pjsip_tx_data. */\nPJ_DEF(pj_status_t) pjsip_tx_data_clone(const pjsip_tx_data *src,\n                                        unsigned flags,\n\t\t\t\t  \tpjsip_tx_data ** p_tdata)\n{\n    pjsip_tx_data *dst;\n    const pjsip_hdr *hsrc;\n    pjsip_msg *msg;\n    pj_status_t status;\n\n    PJ_UNUSED_ARG(flags);\n\n    status = pjsip_tx_data_create(src->mgr, p_tdata);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    dst = *p_tdata;\n\n    msg = pjsip_msg_create(dst->pool, PJSIP_RESPONSE_MSG);\n    dst->msg = msg;\n    pjsip_tx_data_add_ref(dst);\n\n    /* Duplicate status line */\n    msg->line.status.code = src->msg->line.status.code;\n    pj_strdup(dst->pool, &msg->line.status.reason,\n\t      &src->msg->line.status.reason);\n\n    /* Duplicate all headers */\n    hsrc = src->msg->hdr.next;\n    while (hsrc != &src->msg->hdr) {\n\tpjsip_hdr *h = (pjsip_hdr*) pjsip_hdr_clone(dst->pool, hsrc);\n\tpjsip_msg_add_hdr(msg, h);\n\thsrc = hsrc->next;\n    }\n\n    /* Duplicate message body */\n    if (src->msg->body)\n\tmsg->body = pjsip_msg_body_clone(dst->pool, src->msg->body);\n\n    /* We shouldn't copy is_pending since it's src's internal state,\n     * indicating that it's currently being sent by the transport.\n     * While the cloned tdata is of course not.\n     */\n    //dst->is_pending = src->is_pending;\n\n    PJ_LOG(5,(THIS_FILE,\n\t     \"Tx data %s cloned\",\n\t     pjsip_tx_data_get_info(dst)));\n\n    return PJ_SUCCESS;\n}\n\nPJ_DEF(char*) pjsip_rx_data_get_info(pjsip_rx_data *rdata)\n{\n    char obj_name[PJ_MAX_OBJ_NAME];\n\n    PJ_ASSERT_RETURN(rdata->msg_info.msg, \"INVALID MSG\");\n\n    if (rdata->msg_info.info)\n\treturn rdata->msg_info.info;\n\n    pj_ansi_strcpy(obj_name, \"rdata\");\n    pj_ansi_snprintf(obj_name+5, sizeof(obj_name)-5, \"%p\", rdata);\n\n    rdata->msg_info.info = get_msg_info(rdata->tp_info.pool, obj_name,\n\t\t\t\t\trdata->msg_info.msg);\n    return rdata->msg_info.info;\n}\n\n/* Clone pjsip_rx_data. */\nPJ_DEF(pj_status_t) pjsip_rx_data_clone( const pjsip_rx_data *src,\n                                         unsigned flags,\n                                         pjsip_rx_data **p_rdata)\n{\n    pj_pool_t *pool;\n    pjsip_rx_data *dst;\n    pjsip_hdr *hdr;\n\n    PJ_ASSERT_RETURN(src && flags==0 && p_rdata, PJ_EINVAL);\n\n    pool = pj_pool_create(src->tp_info.pool->factory,\n                          \"rtd%p\",\n                          PJSIP_POOL_RDATA_LEN,\n                          PJSIP_POOL_RDATA_INC,\n                          NULL);\n    if (!pool)\n\treturn PJ_ENOMEM;\n\n    dst = PJ_POOL_ZALLOC_T(pool, pjsip_rx_data);\n\n    /* Parts of tp_info */\n    dst->tp_info.pool = pool;\n    dst->tp_info.transport = (pjsip_transport*)src->tp_info.transport;\n\n    /* pkt_info can be memcopied */\n    pj_memcpy(&dst->pkt_info, &src->pkt_info, sizeof(src->pkt_info));\n\n    /* msg_info needs deep clone */\n    dst->msg_info.msg_buf = dst->pkt_info.packet +\n\t\t\t    (src->msg_info.msg_buf - src->pkt_info.packet);\n    dst->msg_info.len = src->msg_info.len;\n    dst->msg_info.msg = pjsip_msg_clone(pool, src->msg_info.msg);\n    pj_list_init(&dst->msg_info.parse_err);\n\n#define GET_MSG_HDR2(TYPE, type, var)\t\\\n\t\t\tcase PJSIP_H_##TYPE: \\\n\t\t\t    if (!dst->msg_info.var) { \\\n\t\t\t\tdst->msg_info.var = (pjsip_##type##_hdr*)hdr; \\\n\t\t\t    } \\\n\t\t\t    break\n#define GET_MSG_HDR(TYPE, var_type)\tGET_MSG_HDR2(TYPE, var_type, var_type)\n\n    hdr = dst->msg_info.msg->hdr.next;\n    while (hdr != &dst->msg_info.msg->hdr) {\n\tswitch (hdr->type) {\n\tGET_MSG_HDR(CALL_ID, cid);\n\tGET_MSG_HDR(FROM, from);\n\tGET_MSG_HDR(TO, to);\n\tGET_MSG_HDR(VIA, via);\n\tGET_MSG_HDR(CSEQ, cseq);\n\tGET_MSG_HDR(MAX_FORWARDS, max_fwd);\n\tGET_MSG_HDR(ROUTE, route);\n\tGET_MSG_HDR2(RECORD_ROUTE, rr, record_route);\n\tGET_MSG_HDR(CONTENT_TYPE, ctype);\n\tGET_MSG_HDR(CONTENT_LENGTH, clen);\n\tGET_MSG_HDR(REQUIRE, require);\n\tGET_MSG_HDR(SUPPORTED, supported);\n\tdefault:\n\t    break;\n\t}\n\thdr = hdr->next;\n    }\n\n#undef GET_MSG_HDR\n#undef GET_MSG_HDR2\n\n    *p_rdata = dst;\n\n    /* Finally add transport ref */\n    return pjsip_transport_add_ref(dst->tp_info.transport);\n}\n\n/* Free previously cloned pjsip_rx_data. */\nPJ_DEF(pj_status_t) pjsip_rx_data_free_cloned(pjsip_rx_data *rdata)\n{\n    PJ_ASSERT_RETURN(rdata, PJ_EINVAL);\n\n    pjsip_transport_dec_ref(rdata->tp_info.transport);\n    pj_pool_release(rdata->tp_info.pool);\n\n    return PJ_SUCCESS;\n}\n\n/*****************************************************************************\n *\n * TRANSPORT KEY\n *\n *****************************************************************************/\n\n\n/*****************************************************************************\n *\n * TRANSPORT\n *\n *****************************************************************************/\n\nstatic void transport_send_callback(pjsip_transport *transport,\n\t\t\t\t    void *token,\n\t\t\t\t    pj_ssize_t size)\n{\n    pjsip_tx_data *tdata = (pjsip_tx_data*) token;\n\n    PJ_UNUSED_ARG(transport);\n\n    /* Mark pending off so that app can resend/reuse txdata from inside\n     * the callback.\n     */\n    tdata->is_pending = 0;\n\n    /* Call callback, if any. */\n    if (tdata->cb) {\n\t(*tdata->cb)(tdata->token, tdata, size);\n    }\n\n    /* Decrement reference count. */\n    pjsip_tx_data_dec_ref(tdata);\n}\n\n/* This function is called by endpoint for on_tx_request() and on_tx_response()\n * notification.\n */\nstatic pj_status_t mod_on_tx_msg(pjsip_tx_data *tdata)\n{\n    return pjsip_tx_data_encode(tdata);\n}\n\n/*\n * Send a SIP message using the specified transport.\n */\nPJ_DEF(pj_status_t) pjsip_transport_send(  pjsip_transport *tr, \n\t\t\t\t\t   pjsip_tx_data *tdata,\n\t\t\t\t\t   const pj_sockaddr_t *addr,\n\t\t\t\t\t   int addr_len,\n\t\t\t\t\t   void *token,\n\t\t\t\t\t   pjsip_tp_send_callback cb)\n{\n    pj_status_t status;\n\n    PJ_ASSERT_RETURN(tr && tdata && addr, PJ_EINVAL);\n\n    /* Is it currently being sent? */\n    if (tdata->is_pending) {\n\tpj_assert(!\"Invalid operation step!\");\n\tPJ_LOG(2,(THIS_FILE, \"Unable to send %s: message is pending\", \n\t\t\t     pjsip_tx_data_get_info(tdata)));\n\treturn PJSIP_EPENDINGTX;\n    }\n\n    /* Add reference to prevent deletion, and to cancel idle timer if\n     * it's running.\n     */\n    pjsip_transport_add_ref(tr);\n\n    /* Fill in tp_info. */\n    tdata->tp_info.transport = tr;\n    pj_memcpy(&tdata->tp_info.dst_addr, addr, addr_len);\n    tdata->tp_info.dst_addr_len = addr_len;\n\n    pj_inet_ntop(((pj_sockaddr*)addr)->addr.sa_family,\n\t\t pj_sockaddr_get_addr(addr),\n\t\t tdata->tp_info.dst_name,\n\t\t sizeof(tdata->tp_info.dst_name));\n    tdata->tp_info.dst_port = pj_sockaddr_get_port(addr);\n\n    /* Distribute to modules. \n     * When the message reach mod_msg_print, the contents of the message will\n     * be \"printed\" to contiguous buffer.\n     */\n    if (tr->tpmgr->on_tx_msg) {\n\tstatus = (*tr->tpmgr->on_tx_msg)(tr->endpt, tdata);\n\tif (status != PJ_SUCCESS) {\n\t    pjsip_transport_dec_ref(tr);\n\t    return status;\n\t}\n    }\n\n    /* Save callback data. */\n    tdata->token = token;\n    tdata->cb = cb;\n\n    /* Add reference counter. */\n    pjsip_tx_data_add_ref(tdata);\n\n    /* Mark as pending. */\n    tdata->is_pending = 1;\n\n    /* Send to transport. */\n    status = (*tr->send_msg)(tr, tdata,  addr, addr_len, (void*)tdata, \n\t\t\t     &transport_send_callback);\n\n    if (status != PJ_EPENDING) {\n\ttdata->is_pending = 0;\n\tpjsip_tx_data_dec_ref(tdata);\n    }\n\n    pjsip_transport_dec_ref(tr);\n    return status;\n}\n\n\n/* send_raw() callback */\nstatic void send_raw_callback(pjsip_transport *transport,\n\t\t\t      void *token,\n\t\t\t      pj_ssize_t size)\n{\n    pjsip_tx_data *tdata = (pjsip_tx_data*) token;\n\n    /* Mark pending off so that app can resend/reuse txdata from inside\n     * the callback.\n     */\n    tdata->is_pending = 0;\n\n    /* Call callback, if any. */\n    if (tdata->cb) {\n\t(*tdata->cb)(tdata->token, tdata, size);\n    }\n\n    /* Decrement tdata reference count. */\n    pjsip_tx_data_dec_ref(tdata);\n\n    /* Decrement transport reference count */\n    pjsip_transport_dec_ref(transport);\n}\n\n\n/* Send raw data */\nPJ_DEF(pj_status_t) pjsip_tpmgr_send_raw(pjsip_tpmgr *mgr,\n\t\t\t\t\t pjsip_transport_type_e tp_type,\n\t\t\t\t\t const pjsip_tpselector *sel,\n\t\t\t\t\t pjsip_tx_data *tdata,\n\t\t\t\t\t const void *raw_data,\n\t\t\t\t\t pj_size_t data_len,\n\t\t\t\t\t const pj_sockaddr_t *addr,\n\t\t\t\t\t int addr_len,\n\t\t\t\t\t void *token,\n\t\t\t\t\t pjsip_tp_send_callback cb)\n{\n    pjsip_transport *tr;\n    pj_status_t status;\n \n    /* Acquire the transport */\n    status = pjsip_tpmgr_acquire_transport(mgr, tp_type, addr, addr_len,\n\t\t\t\t\t   sel, &tr);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Create transmit data buffer if one is not specified */\n    if (tdata == NULL) {\n\tstatus = pjsip_endpt_create_tdata(tr->endpt, &tdata);\n\tif (status != PJ_SUCCESS) {\n\t    pjsip_transport_dec_ref(tr);\n\t    return status;\n\t}\n\n\ttdata->info = \"raw\";\n\n\t/* Add reference counter. */\n\tpjsip_tx_data_add_ref(tdata);\n    }\n\n    /* Allocate buffer */\n    if (tdata->buf.start == NULL ||\n\t(tdata->buf.end - tdata->buf.start) < (int)data_len)\n    {\n\t/* Note: data_len may be zero, so allocate +1 */\n\ttdata->buf.start = (char*) pj_pool_alloc(tdata->pool, data_len+1);\n\ttdata->buf.end = tdata->buf.start + data_len + 1;\n    }\n \n    /* Copy data, if any! (application may send zero len packet) */\n    if (data_len) {\n\tpj_memcpy(tdata->buf.start, raw_data, data_len);\n    }\n    tdata->buf.cur = tdata->buf.start + data_len;\n \n    /* Save callback data. */\n    tdata->token = token;\n    tdata->cb = cb;\n\n    /* Mark as pending. */\n    tdata->is_pending = 1;\n\n    /* Send to transport */\n    status = tr->send_msg(tr, tdata, addr, addr_len,\n\t\t\t  tdata, &send_raw_callback);\n \n    if (status != PJ_EPENDING) {\n\t/* callback will not be called, so destroy tdata now. */\n\tpjsip_tx_data_dec_ref(tdata);\n\tpjsip_transport_dec_ref(tr);\n    }\n\n    return status;\n}\n\n\nstatic void transport_idle_callback(pj_timer_heap_t *timer_heap,\n\t\t\t\t    struct pj_timer_entry *entry)\n{\n    pjsip_transport *tp = (pjsip_transport*) entry->user_data;\n    pj_assert(tp != NULL);\n\n    PJ_UNUSED_ARG(timer_heap);\n\n    if (entry->id == PJ_FALSE)\n\treturn;\n\n    entry->id = PJ_FALSE;\n\n    /* Set is_destroying flag under transport manager mutex to avoid\n     * race condition with pjsip_tpmgr_acquire_transport2().\n     */\n    pj_lock_acquire(tp->tpmgr->lock);\n    if (pj_atomic_get(tp->ref_cnt) == 0) {\n\ttp->is_destroying = PJ_TRUE;\n    } else {\n\tpj_lock_release(tp->tpmgr->lock);\n\treturn;\n    }\n    pj_lock_release(tp->tpmgr->lock);\n\n    pjsip_transport_destroy(tp);\n}\n\n\nstatic pj_bool_t is_transport_valid(pjsip_transport *tp, pjsip_tpmgr *tpmgr,\n\t\t\t\t    const pjsip_transport_key *key,\n\t\t\t\t    int key_len)\n{\n    transport *tp_entry;\n\n    tp_entry = (transport *)pj_hash_get(tpmgr->table, key, key_len, NULL);\n    if (tp_entry != NULL) {\n\n\ttransport *tp_iter = tp_entry;\n\tdo {\n\t    if (tp_iter->tp == tp) {\n\t\treturn PJ_TRUE;\n\t    }\n\t    tp_iter = tp_iter->next;\n\t} while (tp_iter != tp_entry);\n    }\n\n    return PJ_FALSE;\n}\n\n/*\n * Add ref.\n */\nPJ_DEF(pj_status_t) pjsip_transport_add_ref( pjsip_transport *tp )\n{\n    pjsip_tpmgr *tpmgr;\n    pjsip_transport_key key;\n    int key_len;\n\n    PJ_ASSERT_RETURN(tp != NULL, PJ_EINVAL);\n\n    /* Add ref transport group lock, if any */\n    if (tp->grp_lock)\n\tpj_grp_lock_add_ref(tp->grp_lock);\n\n    /* Cache some vars for checking transport validity later */\n    tpmgr = tp->tpmgr;\n    key_len = sizeof(tp->key.type) + tp->addr_len;\n    pj_memcpy(&key, &tp->key, key_len);\n\n    if (pj_atomic_inc_and_get(tp->ref_cnt) == 1) {\n\tpj_lock_acquire(tpmgr->lock);\n\t/* Verify again. But first, make sure transport is still valid\n\t * (see #1883).\n\t */\n\tif (is_transport_valid(tp, tpmgr, &key, key_len) &&\n\t    pj_atomic_get(tp->ref_cnt) == 1)\n\t{\n\t    if (tp->idle_timer.id != PJ_FALSE) {\n\t\ttp->idle_timer.id = PJ_FALSE;\n\t\tpjsip_endpt_cancel_timer(tp->tpmgr->endpt, &tp->idle_timer);\n\t    }\n\t}\n\tpj_lock_release(tpmgr->lock);\n    }\n\n    return PJ_SUCCESS;\n}\n\n/*\n * Dec ref.\n */\nPJ_DEF(pj_status_t) pjsip_transport_dec_ref( pjsip_transport *tp )\n{\n    pjsip_tpmgr *tpmgr;\n    pjsip_transport_key key;\n    int key_len;\n\n    PJ_ASSERT_RETURN(tp != NULL, PJ_EINVAL);\n    pj_assert(pj_atomic_get(tp->ref_cnt) > 0);\n\n    /* Cache some vars for checking transport validity later */\n    tpmgr = tp->tpmgr;\n    key_len = sizeof(tp->key.type) + tp->addr_len;\n    pj_memcpy(&key, &tp->key, key_len);\n\n    if (pj_atomic_dec_and_get(tp->ref_cnt) == 0) {\n\tpj_lock_acquire(tpmgr->lock);\n\t/* Verify again. Do not register timer if the transport is\n\t * being destroyed. But first, make sure transport is still valid\n\t * (see #1883).\n\t */\n\tif (is_transport_valid(tp, tpmgr, &key, key_len) &&\n\t    !tp->is_destroying && pj_atomic_get(tp->ref_cnt) == 0)\n\t{\n\t    pj_time_val delay;\n\t    \n\t    /* If transport is in graceful shutdown, then this is the\n\t     * last user who uses the transport. Schedule to destroy the\n\t     * transport immediately. Otherwise schedule idle timer.\n\t     */\n\t    if (tp->is_shutdown) {\n\t\tdelay.sec = delay.msec = 0;\n\t    } else {\n\t\tdelay.sec = (tp->dir==PJSIP_TP_DIR_OUTGOING) ?\n\t\t\t\tPJSIP_TRANSPORT_IDLE_TIME :\n\t\t\t\tPJSIP_TRANSPORT_SERVER_IDLE_TIME;\n\t\tdelay.msec = 0;\n\t    }\n\n\t    /* Avoid double timer entry scheduling */\n\t    if (pj_timer_entry_running(&tp->idle_timer))\n\t\tpjsip_endpt_cancel_timer(tp->tpmgr->endpt, &tp->idle_timer);\n\n\t    pjsip_endpt_schedule_timer_w_grp_lock(tp->tpmgr->endpt,\n\t\t\t\t\t\t  &tp->idle_timer,\n\t\t\t\t\t\t  &delay,\n\t\t\t\t\t\t  PJ_TRUE,\n\t\t\t\t\t\t  tp->grp_lock);\n\t}\n\tpj_lock_release(tpmgr->lock);\n    }\n\n    /* Dec ref transport group lock, if any */\n    if (tp->grp_lock) {\n\tpj_grp_lock_dec_ref(tp->grp_lock);\n    }\n\n    return PJ_SUCCESS;\n}\n\n\n/**\n * Register a transport.\n */\nPJ_DEF(pj_status_t) pjsip_transport_register( pjsip_tpmgr *mgr,\n\t\t\t\t\t      pjsip_transport *tp )\n{\n    int key_len;\n    pj_uint32_t hval;\n    transport *tp_ref = NULL;\n    transport *tp_add = NULL;\n\n    /* Init. */\n    tp->tpmgr = mgr;\n    pj_bzero(&tp->idle_timer, sizeof(tp->idle_timer));\n    tp->idle_timer.user_data = tp;\n    tp->idle_timer.cb = &transport_idle_callback;\n\n    /*\n     * Register to hash table (see Trac ticket #42).\n     */\n    key_len = sizeof(tp->key.type) + tp->addr_len;\n    pj_lock_acquire(mgr->lock);\n\n    hval = 0;\n    tp_ref = (transport *)pj_hash_get(mgr->table, &tp->key, key_len, &hval);\n\n    /* Get an empty entry from the freelist. */\n    if (pj_list_empty(&mgr->tp_entry_freelist)) {\n\tunsigned i = 0;\n\n\tTRACE_((THIS_FILE, \"Transport list is full, allocate new entry\"));\n\t/* Allocate new entry for the freelist. */\n\tfor (; i < PJSIP_TRANSPORT_ENTRY_ALLOC_CNT; ++i) {\n\t    tp_add = PJ_POOL_ZALLOC_T(mgr->pool, transport);\n\t    if (!tp_add)\n\t\treturn PJ_ENOMEM;\n\t    pj_list_init(tp_add);\n\t    pj_list_push_back(&mgr->tp_entry_freelist, tp_add);\n\t}\n    }\n    tp_add = mgr->tp_entry_freelist.next;\n    tp_add->tp = tp;\n    pj_list_erase(tp_add);\n\n    if (tp_ref) {\n\t/* There'a already a transport list from the hash table. Add the \n\t * new transport to the list.\n\t */\n\tpj_list_push_back(tp_ref, tp_add);\n\tTRACE_((THIS_FILE, \"Remote address already registered, \"\n\t\t\t   \"appended the transport to the list\"));\n    } else {\n\t/* Transport list not found, add it to the hash table. */\n\tpj_hash_set_np(mgr->table, &tp->key, key_len, hval, tp_add->tp_buf,\n\t\t       tp_add);\n\tTRACE_((THIS_FILE, \"Remote address not registered, \"\n\t\t\t   \"added the transport to the hash\"));\n    }\n\n    /* Add ref transport group lock, if any */\n    if (tp->grp_lock)\n\tpj_grp_lock_add_ref(tp->grp_lock);\n\n    pj_lock_release(mgr->lock);\n\n    TRACE_((THIS_FILE, \"Transport %s registered: type=%s, remote=%s:%d\",\n\t    tp->obj_name,\n\t    pjsip_transport_get_type_name(tp->key.type),\n\t    pj_sockaddr_has_addr(&tp->key.rem_addr)?\n\t\t\t\taddr_string(&tp->key.rem_addr):\"\",\n\t    pj_sockaddr_has_addr(&tp->key.rem_addr)?\n\t\t\t\tpj_sockaddr_get_port(&tp->key.rem_addr):0));\n\n    return PJ_SUCCESS;\n}\n\n/* Force destroy transport (e.g. during transport manager shutdown. */\nstatic pj_status_t destroy_transport( pjsip_tpmgr *mgr,\n\t\t\t\t      pjsip_transport *tp )\n{\n    int key_len;\n    pj_uint32_t hval;\n    void *entry;\n\n    tp->is_destroying = PJ_TRUE;\n\n    TRACE_((THIS_FILE, \"Transport %s is being destroyed\", tp->obj_name));\n\n    pj_lock_acquire(tp->lock);\n    pj_lock_acquire(mgr->lock);\n\n    /*\n     * Unregister timer, if any.\n     */\n    //pj_assert(tp->idle_timer.id == PJ_FALSE);\n    if (tp->idle_timer.id != PJ_FALSE) {\n\ttp->idle_timer.id = PJ_FALSE;\n\tpjsip_endpt_cancel_timer(mgr->endpt, &tp->idle_timer);\n    }\n\n    /*\n     * Unregister from hash table (see Trac ticket #42).\n     */\n    key_len = sizeof(tp->key.type) + tp->addr_len;\n    hval = 0;\n    entry = pj_hash_get(mgr->table, &tp->key, key_len, &hval);\n    if (entry) {\n\ttransport *tp_ref = (transport *)entry;\n\ttransport *tp_iter = tp_ref;\n\t/* Search the matching entry from the transport list. */\n\tdo {\n\t    if (tp_iter->tp == tp) {\n\t\ttransport *tp_next = tp_iter->next;\n\n\t\t/* Update hash table :\n\t\t * - transport list only contain single element, or\n\t\t * - the entry is the first element of the transport list.\n\t\t */\n\t\tif (tp_iter == tp_ref) {\n\t\t    pj_hash_set(NULL, mgr->table, &tp->key, key_len, hval,\n\t\t\t\tNULL);\n\n\t\t    if (tp_ref->next != tp_ref) {\n\t\t\t/* The transport list has multiple entry. */\n\t\t\tpj_hash_set_np(mgr->table, &tp_next->tp->key, key_len,\n\t\t\t\t       hval, tp_next->tp_buf, tp_next);\n\t\t\tTRACE_((THIS_FILE, \"Hash entry updated after \"\n\t\t\t\t\t   \"transport %d being destroyed\",\n\t\t\t\t\t   tp->obj_name));\n\t\t    } else {\n\t\t\tTRACE_((THIS_FILE, \"Hash entry deleted after \"\n\t\t\t\t\t   \"transport %d being destroyed\",\n\t\t\t\t\t   tp->obj_name));\n\t\t    }\n\t\t}\n\n\t\tpj_list_erase(tp_iter);\n\t\t/* Put back to the transport freelist. */\n\t\tpj_list_push_back(&mgr->tp_entry_freelist, tp_iter);\n\n\t\tbreak;\n\t    }\n\t    tp_iter = tp_iter->next;\n\t} while (tp_iter != tp_ref);\n\n\tif (tp_iter->tp != tp) {\n\t    PJ_LOG(3, (THIS_FILE, \"Warning: transport %s being destroyed is \"\n\t\t\t\t  \"not registered\", tp->obj_name));\n\t}\n    } else {\n\tPJ_LOG(3, (THIS_FILE, \"Warning: transport %s being destroyed is \"\n\t\t\t      \"not found in the hash table\", tp->obj_name));\n    }\n\n    pj_lock_release(mgr->lock);\n    pj_lock_release(tp->lock);\n\n    /* Dec ref transport group lock, if any */\n    if (tp->grp_lock) {\n\tpj_grp_lock_dec_ref(tp->grp_lock);\n    }\n\n    /* Destroy. */\n    return tp->destroy(tp);\n}\n\n\n/*\n * Start graceful shutdown procedure for this transport. \n */\nPJ_DEF(pj_status_t) pjsip_transport_shutdown(pjsip_transport *tp)\n{\n    return pjsip_transport_shutdown2(tp, PJ_FALSE);\n}\n\n\n/*\n * Start shutdown procedure for this transport. \n */\nPJ_DEF(pj_status_t) pjsip_transport_shutdown2(pjsip_transport *tp,\n\t\t\t\t\t      pj_bool_t force)\n{\n    pjsip_tpmgr *mgr;\n    pj_status_t status;\n    pjsip_tp_state_callback state_cb;\n\n    PJ_LOG(4, (THIS_FILE, \"Transport %s shutting down, force=%d\",\n\t\t\t  tp->obj_name, force));\n\n    pj_lock_acquire(tp->lock);\n\n    mgr = tp->tpmgr;\n    pj_lock_acquire(mgr->lock);\n\n    /* Do nothing if transport is being shutdown/destroyed already */\n    if (tp->is_shutdown || tp->is_destroying) {\n\tpj_lock_release(mgr->lock);\n\tpj_lock_release(tp->lock);\n\treturn PJ_SUCCESS;\n    }\n\n    status = PJ_SUCCESS;\n\n    /* Instruct transport to shutdown itself */\n    if (tp->do_shutdown)\n\tstatus = tp->do_shutdown(tp);\n\n    if (status == PJ_SUCCESS)\n\ttp->is_shutdown = PJ_TRUE;\n\n    /* Notify application of transport shutdown */\n    state_cb = pjsip_tpmgr_get_state_cb(tp->tpmgr);\n    if (state_cb) {\n\tpjsip_transport_state_info state_info;\n\n\tpj_bzero(&state_info, sizeof(state_info));\n\tstate_info.status = PJ_ECANCELLED;\n\t(*state_cb)(tp, (force? PJSIP_TP_STATE_DISCONNECTED:\n\t\t    PJSIP_TP_STATE_SHUTDOWN), &state_info);\n    }\n\n    /* If transport reference count is zero, start timer count-down */\n    if (pj_atomic_get(tp->ref_cnt) == 0) {\n\tpjsip_transport_add_ref(tp);\n\tpjsip_transport_dec_ref(tp);\n    }\n\n    pj_lock_release(mgr->lock);\n    pj_lock_release(tp->lock);\n\n    return status;\n}\n\n\n/**\n * Unregister transport.\n */\nPJ_DEF(pj_status_t) pjsip_transport_destroy( pjsip_transport *tp)\n{\n    pjsip_tp_state_callback state_cb;\n\n    /* Must have no user. */\n    PJ_ASSERT_RETURN(pj_atomic_get(tp->ref_cnt) == 0, PJSIP_EBUSY);\n\n    /* Notify application of transport destroy */\n    state_cb = pjsip_tpmgr_get_state_cb(tp->tpmgr);\n    if (state_cb) {\n\tpjsip_transport_state_info state_info;\n\n\tpj_bzero(&state_info, sizeof(state_info));\n        (*state_cb)(tp, PJSIP_TP_STATE_DESTROY, &state_info);\n    }\n\n    /* Destroy. */\n    return destroy_transport(tp->tpmgr, tp);\n}\n\n\n\n/*****************************************************************************\n *\n * TRANSPORT FACTORY\n *\n *****************************************************************************/\n\n\nPJ_DEF(pj_status_t) pjsip_tpmgr_register_tpfactory( pjsip_tpmgr *mgr,\n\t\t\t\t\t\t    pjsip_tpfactory *tpf)\n{\n    pjsip_tpfactory *p;\n    pj_status_t status;\n\n    pj_lock_acquire(mgr->lock);\n\n    /* Check that no same factory has been registered. */\n    status = PJ_SUCCESS;\n    for (p=mgr->factory_list.next; p!=&mgr->factory_list; p=p->next) {\n\tif (p == tpf) {\n\t    status = PJ_EEXISTS;\n\t    break;\n\t}\n    }\n\n    if (status != PJ_SUCCESS) {\n\tpj_lock_release(mgr->lock);\n\treturn status;\n    }\n\n    pj_list_insert_before(&mgr->factory_list, tpf);\n\n    pj_lock_release(mgr->lock);\n\n    return PJ_SUCCESS;\n}\n\n\n/**\n * Unregister factory.\n */\nPJ_DEF(pj_status_t) pjsip_tpmgr_unregister_tpfactory( pjsip_tpmgr *mgr,\n\t\t\t\t\t\t      pjsip_tpfactory *tpf)\n{\n    pj_lock_acquire(mgr->lock);\n\n    pj_assert(pj_list_find_node(&mgr->factory_list, tpf) == tpf);\n    pj_list_erase(tpf);\n\n    pj_lock_release(mgr->lock);\n\n    return PJ_SUCCESS;\n}\n\nPJ_DECL(void) pjsip_tpmgr_fla2_param_default(pjsip_tpmgr_fla2_param *prm)\n{\n    pj_bzero(prm, sizeof(*prm));\n}\n\nstatic pj_bool_t pjsip_tpmgr_is_tpfactory_valid(pjsip_tpmgr *mgr,\n\t\t\t\t\t\tpjsip_tpfactory *tpf)\n{\n    pjsip_tpfactory *p;\n\n    pj_lock_acquire(mgr->lock);\n    for (p=mgr->factory_list.next; p!=&mgr->factory_list; p=p->next) {\n\tif (p == tpf) {\n\t    pj_lock_release(mgr->lock);\n\t    return PJ_TRUE;\n\t}\n    }\n    pj_lock_release(mgr->lock);\n\n    return PJ_FALSE;\n}\n\n/*****************************************************************************\n *\n * TRANSPORT MANAGER\n *\n *****************************************************************************/\n\n/*\n * Create a new transport manager.\n */\nPJ_DEF(pj_status_t) pjsip_tpmgr_create( pj_pool_t *pool,\n\t\t\t\t\tpjsip_endpoint *endpt,\n\t\t\t\t\tpjsip_rx_callback rx_cb,\n\t\t\t\t\tpjsip_tx_callback tx_cb,\n\t\t\t\t\tpjsip_tpmgr **p_mgr)\n{\n    pjsip_tpmgr *mgr;\n    pj_status_t status;\n    unsigned i = 0;\n    pj_pool_t *mgr_pool;\n\n    PJ_ASSERT_RETURN(pool && endpt && rx_cb && p_mgr, PJ_EINVAL);\n\n    /* Register mod_msg_print module. */\n    status = pjsip_endpt_register_module(endpt, &mod_msg_print);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Create and initialize transport manager. */\n    mgr_pool = pjsip_endpt_create_pool(endpt, \"tpmgr\",\n\t\t\t\t       TPMGR_POOL_INIT_SIZE,\n\t\t\t\t       TPMGR_POOL_INC_SIZE);\n    mgr = PJ_POOL_ZALLOC_T(mgr_pool, pjsip_tpmgr);\n    mgr->endpt = endpt;\n    mgr->on_rx_msg = rx_cb;\n    mgr->on_tx_msg = tx_cb;\n    mgr->pool = mgr_pool;\n\n    if (!mgr->pool)\n\treturn PJ_ENOMEM;\n\n    pj_list_init(&mgr->factory_list);\n    pj_list_init(&mgr->tdata_list);\n    pj_list_init(&mgr->tp_entry_freelist);\n\n    mgr->table = pj_hash_create(mgr->pool, PJSIP_TPMGR_HTABLE_SIZE);\n    if (!mgr->table)\n\treturn PJ_ENOMEM;\n\n    status = pj_lock_create_recursive_mutex(mgr->pool, \"tmgr%p\", &mgr->lock);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    for (; i < PJSIP_TRANSPORT_ENTRY_ALLOC_CNT; ++i) {\n\ttransport *tp_add = NULL;\n\n\ttp_add = PJ_POOL_ZALLOC_T(mgr->pool, transport);\n\tif (!tp_add)\n\t    return PJ_ENOMEM;\n\tpj_list_init(tp_add);\n\tpj_list_push_back(&mgr->tp_entry_freelist, tp_add);\n    }\n\n#if defined(PJ_DEBUG) && PJ_DEBUG!=0\n    status = pj_atomic_create(mgr->pool, 0, &mgr->tdata_counter);\n    if (status != PJ_SUCCESS) {\n    \tpj_lock_destroy(mgr->lock);\n    \treturn status;\n    }\n#endif\n\n    /* Set transport state callback */\n    pjsip_tpmgr_set_state_cb(mgr, &tp_state_callback);\n\n    PJ_LOG(5, (THIS_FILE, \"Transport manager created.\"));\n\n    *p_mgr = mgr;\n    return PJ_SUCCESS;\n}\n\n/* Get the interface to send packet to the specified address */\nstatic pj_status_t get_net_interface(pjsip_transport_type_e tp_type,\n\t\t\t\t     const pj_str_t *dst,\n                                     pj_str_t *itf_str_addr)\n{\n    int af;\n    pj_sockaddr itf_addr;\n    pj_status_t status = -1;\n\n    af = (tp_type & PJSIP_TRANSPORT_IPV6)? pj_AF_INET6() : pj_AF_INET();\n\n    if (pjsip_cfg()->endpt.resolve_hostname_to_get_interface) {\n\tstatus = pj_getipinterface(af, dst, &itf_addr, PJ_TRUE, NULL);\n    }\n\n    if (status != PJ_SUCCESS) { \n\tstatus = pj_getipinterface(af, dst, &itf_addr, PJ_FALSE, NULL);\n\tif (status != PJ_SUCCESS) {\n\t    /* If it fails, e.g: on WM6(http://support.microsoft.com/kb/129065),\n\t     * just fallback using pj_gethostip(), see ticket #1660.\n\t     */\n\t    PJ_PERROR(5,(THIS_FILE, status,\n\t\t\t \"Warning: unable to determine local interface, \"\n\t\t\t \"fallback to default interface!\"));\n\t    status = pj_gethostip(af, &itf_addr);\n\t    if (status != PJ_SUCCESS)\n\t\treturn status;\n\t}\n    }\n\n    /* Print address */\n    pj_sockaddr_print(&itf_addr, itf_str_addr->ptr,\n\t\t      PJ_INET6_ADDRSTRLEN, 0);\n    itf_str_addr->slen = pj_ansi_strlen(itf_str_addr->ptr);\n\n    return PJ_SUCCESS;\n}\n\n/*\n * Find out the appropriate local address info (IP address and port) to\n * advertise in Contact header based on the remote address to be \n * contacted. The local address info would be the address name of the\n * transport or listener which will be used to send the request.\n *\n * In this implementation, it will only select the transport based on\n * the transport type in the request.\n */\nPJ_DEF(pj_status_t) pjsip_tpmgr_find_local_addr2(pjsip_tpmgr *tpmgr,\n\t\t\t\t\t\t pj_pool_t *pool,\n\t\t\t\t\t\t pjsip_tpmgr_fla2_param *prm)\n{\n    char tmp_buf[PJ_INET6_ADDRSTRLEN+10];\n    pj_str_t tmp_str;\n    pj_status_t status = PJSIP_EUNSUPTRANSPORT;\n    unsigned flag;\n\n    /* Sanity checks */\n    PJ_ASSERT_RETURN(tpmgr && pool && prm, PJ_EINVAL);\n\n    pj_strset(&tmp_str, tmp_buf, 0);\n    prm->ret_addr.slen = 0;\n    prm->ret_port = 0;\n    prm->ret_tp = NULL;\n\n    flag = pjsip_transport_get_flag_from_type(prm->tp_type);\n\n    if (prm->tp_sel && prm->tp_sel->type == PJSIP_TPSELECTOR_TRANSPORT &&\n\tprm->tp_sel->u.transport)\n    {\n\tconst pjsip_transport *tp = prm->tp_sel->u.transport;\n\tif (prm->local_if) {\n\t    status = get_net_interface((pjsip_transport_type_e)tp->key.type,\n\t\t\t\t       &prm->dst_host, &tmp_str);\n\t    if (status != PJ_SUCCESS)\n\t\tgoto on_return;\n\t    pj_strdup(pool, &prm->ret_addr, &tmp_str);\n\t    prm->ret_port = pj_sockaddr_get_port(&tp->local_addr);\n\t    prm->ret_tp = tp;\n\t} else {\n\t    pj_strdup(pool, &prm->ret_addr, &tp->local_name.host);\n\t    prm->ret_port = (pj_uint16_t)tp->local_name.port;\n\t}\n\tstatus = PJ_SUCCESS;\n\n    } else if (prm->tp_sel && prm->tp_sel->type == PJSIP_TPSELECTOR_LISTENER &&\n\t       prm->tp_sel->u.listener)\n    {\n\tif (prm->local_if) {\n\t    status = get_net_interface(prm->tp_sel->u.listener->type,\n\t                               &prm->dst_host, &tmp_str);\n\t    if (status != PJ_SUCCESS)\n\t\tgoto on_return;\n\t    pj_strdup(pool, &prm->ret_addr, &tmp_str);\n\t} else {\n\t    pj_strdup(pool, &prm->ret_addr,\n\t\t      &prm->tp_sel->u.listener->addr_name.host);\n\t}\n\tprm->ret_port = (pj_uint16_t)prm->tp_sel->u.listener->addr_name.port;\n\tstatus = PJ_SUCCESS;\n\n    } else if ((flag & PJSIP_TRANSPORT_DATAGRAM) != 0) {\n\tpj_sockaddr remote;\n\tint addr_len;\n\tpjsip_transport *tp;\n\n\tpj_bzero(&remote, sizeof(remote));\n\tif (prm->tp_type & PJSIP_TRANSPORT_IPV6) {\n\t    addr_len = sizeof(pj_sockaddr_in6);\n\t    remote.addr.sa_family = pj_AF_INET6();\n\t} else {\n\t    addr_len = sizeof(pj_sockaddr_in);\n\t    remote.addr.sa_family = pj_AF_INET();\n\t}\n\n\tstatus = pjsip_tpmgr_acquire_transport(tpmgr, prm->tp_type, &remote,\n\t\t\t\t\t       addr_len, NULL, &tp);\n\n\tif (status == PJ_SUCCESS) {\n\t    if (prm->local_if) {\n\t\tstatus = get_net_interface((pjsip_transport_type_e)\n\t\t\t\t\t   tp->key.type,\n\t\t\t\t\t   &prm->dst_host, &tmp_str);\n\t\tif (status != PJ_SUCCESS)\n\t\t    goto on_return;\n\t\tpj_strdup(pool, &prm->ret_addr, &tmp_str);\n\t\tprm->ret_port = pj_sockaddr_get_port(&tp->local_addr);\n\t\tprm->ret_tp = tp;\n\t    } else {\n\t\tpj_strdup(pool, &prm->ret_addr, &tp->local_name.host);\n\t\tprm->ret_port = (pj_uint16_t)tp->local_name.port;\n\t    }\n\n\t    pjsip_transport_dec_ref(tp);\n\t}\n\n    } else {\n\t/* For connection oriented transport, enum the factories */\n\tpjsip_tpfactory *f;\n\n\tpj_lock_acquire(tpmgr->lock);\n\n\tf = tpmgr->factory_list.next;\n\twhile (f != &tpmgr->factory_list) {\n\t    if (f->type == prm->tp_type)\n\t\tbreak;\n\t    f = f->next;\n\t}\n\n\tif (f != &tpmgr->factory_list) {\n\t    if (prm->local_if) {\n\t\tstatus = get_net_interface(f->type, &prm->dst_host,\n\t\t\t\t\t   &tmp_str);\n\t\tif (status == PJ_SUCCESS) {\n\t\t    pj_strdup(pool, &prm->ret_addr, &tmp_str);\n\t\t} else {\n\t\t    /* It could fail \"normally\" on certain cases, e.g.\n\t\t     * when connecting to IPv6 link local address, it\n\t\t     * will wail with EINVAL.\n\t\t     * In this case, fallback to use the default interface\n\t\t     * rather than failing the call.\n\t\t     */\n\t\t    PJ_PERROR(5,(THIS_FILE, status, \"Warning: unable to \"\n\t\t\t         \"determine local interface\"));\n\t\t    pj_strdup(pool, &prm->ret_addr, &f->addr_name.host);\n\t\t    status = PJ_SUCCESS;\n\t\t}\n\t    } else {\n\t\tpj_strdup(pool, &prm->ret_addr, &f->addr_name.host);\n\t    }\n\t    prm->ret_port = (pj_uint16_t)f->addr_name.port;\n\t    status = PJ_SUCCESS;\n\t}\n\tpj_lock_release(tpmgr->lock);\n    }\n\non_return:\n    return status;\n}\n\nPJ_DEF(pj_status_t) pjsip_tpmgr_find_local_addr( pjsip_tpmgr *tpmgr,\n\t\t\t\t\t\t pj_pool_t *pool,\n\t\t\t\t\t\t pjsip_transport_type_e type,\n\t\t\t\t\t\t const pjsip_tpselector *sel,\n\t\t\t\t\t\t pj_str_t *ip_addr,\n\t\t\t\t\t\t int *port)\n{\n    pjsip_tpmgr_fla2_param prm;\n    pj_status_t status;\n\n    pjsip_tpmgr_fla2_param_default(&prm);\n    prm.tp_type = type;\n    prm.tp_sel = sel;\n\n    status = pjsip_tpmgr_find_local_addr2(tpmgr, pool, &prm);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    *ip_addr = prm.ret_addr;\n    *port = prm.ret_port;\n\n    return PJ_SUCCESS;\n}\n\n/*\n * Return number of transports currently registered to the transport\n * manager.\n */\nPJ_DEF(unsigned) pjsip_tpmgr_get_transport_count(pjsip_tpmgr *mgr)\n{\n    pj_hash_iterator_t itr_val;\n    pj_hash_iterator_t *itr;\n    int nr_of_transports = 0;\n\n    pj_lock_acquire(mgr->lock);\n\n    itr = pj_hash_first(mgr->table, &itr_val);\n    while (itr) {\n\ttransport *tp_entry = (transport *)pj_hash_this(mgr->table, itr);\n\tnr_of_transports += pj_list_size(tp_entry);\n\titr = pj_hash_next(mgr->table, itr);\n    }\n\n    pj_lock_release(mgr->lock);\n\n    return nr_of_transports;\n}\n\n/*\n * pjsip_tpmgr_destroy()\n *\n * Destroy transport manager.\n */\nPJ_DEF(pj_status_t) pjsip_tpmgr_destroy( pjsip_tpmgr *mgr )\n{\n    pj_hash_iterator_t itr_val;\n    pj_hash_iterator_t *itr;\n    pjsip_tpfactory *factory;\n    pjsip_endpoint *endpt = mgr->endpt;\n\n    PJ_LOG(5, (THIS_FILE, \"Destroying transport manager\"));\n\n    pj_lock_acquire(mgr->lock);\n\n    /*\n     * Destroy all transports in the hash table.\n     */\n    for (itr = pj_hash_first(mgr->table, &itr_val); itr;\n\t itr = pj_hash_first(mgr->table, &itr_val))\n    {\n\ttransport *tp_ref;\n\ttp_ref = pj_hash_this(mgr->table, itr);\n\tdestroy_transport(mgr, tp_ref->tp);\n    }\n\n    /*\n     * Destroy all factories/listeners.\n     */\n    factory = mgr->factory_list.next;\n    while (factory != &mgr->factory_list) {\n\tpjsip_tpfactory *next = factory->next;\n\n\tfactory->destroy(factory);\n\n\tfactory = next;\n    }\n\n    pj_lock_release(mgr->lock);\n\n#if defined(PJ_DEBUG) && PJ_DEBUG!=0\n    /* If you encounter assert error on this line, it means there are\n     * leakings in transmit data (i.e. some transmit data have not been\n     * destroyed).\n     */\n    //pj_assert(pj_atomic_get(mgr->tdata_counter) == 0);\n    if (pj_atomic_get(mgr->tdata_counter) != 0) {\n\tPJ_LOG(3,(THIS_FILE, \"Warning: %d transmit buffer(s) not freed!\",\n\t\t  pj_atomic_get(mgr->tdata_counter)));\n    }\n#endif\n\n    /*\n     * Destroy any dangling transmit buffer.\n     */\n    if (!pj_list_empty(&mgr->tdata_list)) {\n\tpjsip_tx_data *tdata = mgr->tdata_list.next;\n\twhile (tdata != &mgr->tdata_list) {\n\t    pjsip_tx_data *next = tdata->next;\n\t    tx_data_destroy(tdata);\n\t    tdata = next;\n\t}\n\tPJ_LOG(3,(THIS_FILE, \"Cleaned up dangling transmit buffer(s).\"));\n    }\n\n#if defined(PJ_DEBUG) && PJ_DEBUG!=0\n    pj_atomic_destroy(mgr->tdata_counter);\n#endif\n\n    pj_lock_destroy(mgr->lock);\n\n    /* Unregister mod_msg_print. */\n    if (mod_msg_print.id != -1) {\n\tpjsip_endpt_unregister_module(endpt, &mod_msg_print);\n    }\n\n    if (mgr->pool) {\n\tpjsip_endpt_release_pool( mgr->endpt, mgr->pool );\n    }\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * pjsip_tpmgr_receive_packet()\n *\n * Called by tranports when they receive a new packet.\n */\nPJ_DEF(pj_ssize_t) pjsip_tpmgr_receive_packet( pjsip_tpmgr *mgr,\n\t\t\t\t\t       pjsip_rx_data *rdata)\n{\n    pjsip_transport *tr = rdata->tp_info.transport;\n\n    char *current_pkt;\n    pj_size_t remaining_len;\n    pj_size_t total_processed = 0;\n\n    /* Check size. */\n    pj_assert(rdata->pkt_info.len > 0);\n    if (rdata->pkt_info.len <= 0)\n\treturn -1;\n\n    current_pkt = rdata->pkt_info.packet;\n    remaining_len = rdata->pkt_info.len;\n\n    tr->last_recv_len = rdata->pkt_info.len;\n    pj_get_timestamp(&tr->last_recv_ts);\n    \n    /* Must NULL terminate buffer. This is the requirement of the \n     * parser etc. \n     */\n    current_pkt[remaining_len] = '\\0';\n\n    /* Process all message fragments. */\n    while (remaining_len > 0) {\n\n\tpjsip_msg *msg;\n\tchar *p, *end;\n\tchar saved;\n\tpj_size_t msg_fragment_size;\n\n\t/* Skip leading newlines as pjsip_find_msg() currently can't\n\t * handle leading newlines.\n\t */\n\tfor (p=current_pkt, end=p+remaining_len; p!=end; ++p) {\n\t    if (*p != '\\r' && *p != '\\n')\n\t\tbreak;\n\t}\n\tif (p!=current_pkt) {\n\t    remaining_len -= (p - current_pkt);\n\t    total_processed += (p - current_pkt);\n\n\t    /* Notify application about the dropped newlines */\n\t    if (mgr->tp_drop_data_cb) {\n\t\tpjsip_tp_dropped_data dd;\n\t\tpj_bzero(&dd, sizeof(dd));\n\t\tdd.tp = tr;\n\t\tdd.data = current_pkt;\n\t\tdd.len = p - current_pkt;\n\t\tdd.status = PJ_EIGNORED;\n\t\t(*mgr->tp_drop_data_cb)(&dd);\n\t    }\n\n\t    current_pkt = p;\n\t    if (remaining_len == 0) {\n\t\treturn total_processed;\n\t    }\n\t}\n\n\t/* Initialize default fragment size. */\n\tmsg_fragment_size = remaining_len;\n\n\t/* Clear and init msg_info in rdata. \n\t * Endpoint might inspect the values there when we call the callback\n\t * to report some errors.\n\t */\n\tpj_bzero(&rdata->msg_info, sizeof(rdata->msg_info));\n\tpj_list_init(&rdata->msg_info.parse_err);\n\trdata->msg_info.msg_buf = current_pkt;\n\trdata->msg_info.len = (int)remaining_len;\n\n\t/* For TCP transport, check if the whole message has been received. */\n\tif ((tr->flag & PJSIP_TRANSPORT_DATAGRAM) == 0) {\n\t    pj_status_t msg_status;\n\t    msg_status = pjsip_find_msg(current_pkt, remaining_len, PJ_FALSE, \n                                        &msg_fragment_size);\n\t    if (msg_status != PJ_SUCCESS) {\n\t\tif (remaining_len == PJSIP_MAX_PKT_LEN) {\n\t\t    mgr->on_rx_msg(mgr->endpt, PJSIP_ERXOVERFLOW, rdata);\n\t\t    \n\t\t    /* Notify application about the message overflow */\n\t    \t    if (mgr->tp_drop_data_cb) {\n\t\t\tpjsip_tp_dropped_data dd;\n\t\t\tpj_bzero(&dd, sizeof(dd));\n\t\t\tdd.tp = tr;\n\t\t\tdd.data = current_pkt;\n\t\t\tdd.len = msg_fragment_size;\n\t\t\tdd.status = PJSIP_ERXOVERFLOW;\n\t\t\t(*mgr->tp_drop_data_cb)(&dd);\n\t    \t    }\n\t\t    \n\t\t    /* Exhaust all data. */\n\t\t    return rdata->pkt_info.len;\n\t\t} else {\n\t\t    /* Not enough data in packet. */\n\t\t    return total_processed;\n\t\t}\n\t    }\n\t}\n\n\t/* Update msg_info. */\n\trdata->msg_info.len = (int)msg_fragment_size;\n\n\t/* Null terminate packet */\n\tsaved = current_pkt[msg_fragment_size];\n\tcurrent_pkt[msg_fragment_size] = '\\0';\n\n\t/* Parse the message. */\n\trdata->msg_info.msg = msg = \n\t    pjsip_parse_rdata( current_pkt, msg_fragment_size, rdata);\n\n\t/* Restore null termination */\n\tcurrent_pkt[msg_fragment_size] = saved;\n\n\t/* Check for parsing syntax error */\n\tif (msg==NULL || !pj_list_empty(&rdata->msg_info.parse_err)) {\n\t    pjsip_parser_err_report *err;\n\t    char buf[256];\n\t    pj_str_t tmp;\n\n\t    /* Gather syntax error information */\n\t    tmp.ptr = buf; tmp.slen = 0;\n\t    err = rdata->msg_info.parse_err.next;\n\t    while (err != &rdata->msg_info.parse_err) {\n\t\tint len;\n\t\tlen = pj_ansi_snprintf(tmp.ptr+tmp.slen, sizeof(buf)-tmp.slen,\n\t\t\t\t       \": %s exception when parsing '%.*s' \"\n\t\t\t\t       \"header on line %d col %d\",\n\t\t\t\t       pj_exception_id_name(err->except_code),\n\t\t\t\t       (int)err->hname.slen, err->hname.ptr,\n\t\t\t\t       err->line, err->col);\n\t\tif (len >= (int)sizeof(buf)-tmp.slen) {\n\t\t    len = (int)sizeof(buf)-tmp.slen;\n\t\t}\n\t\tif (len > 0) {\n\t\t    tmp.slen += len;\n\t\t}\n\t\terr = err->next;\n\t    }\n\n\t    /* Only print error message if there's error.\n\t     * Sometimes we receive blank packets (packets with only CRLF)\n\t     * which were sent to keep NAT bindings.\n\t     */\n\t    if (tmp.slen) {\n\t\tPJ_LOG(1, (THIS_FILE, \n\t\t      \"Error processing %d bytes packet from %s %s:%d %.*s:\\n\"\n\t\t      \"%.*s\\n\"\n\t\t      \"-- end of packet.\",\n\t\t      msg_fragment_size,\n\t\t      rdata->tp_info.transport->type_name,\n\t\t      rdata->pkt_info.src_name, \n\t\t      rdata->pkt_info.src_port,\n\t\t      (int)tmp.slen, tmp.ptr,\n\t\t      (int)msg_fragment_size,\n\t\t      rdata->msg_info.msg_buf));\n\t    }\n\n\t    /* Notify application about the dropped data (syntax error) */\n\t    if (tmp.slen && mgr->tp_drop_data_cb) {\n\t\tpjsip_tp_dropped_data dd;\n\t\tpj_bzero(&dd, sizeof(dd));\n\t\tdd.tp = tr;\n\t\tdd.data = current_pkt;\n\t\tdd.len = msg_fragment_size;\n\t\tdd.status = PJSIP_EINVALIDMSG;\n\t\t(*mgr->tp_drop_data_cb)(&dd);\n\t\t\n\t\tif (dd.len > 0 && dd.len < msg_fragment_size)\n\t\t    msg_fragment_size = dd.len;\n\t    }\n\n\t    goto finish_process_fragment;\n\t}\n\n\t/* Perform basic header checking. */\n\tif (rdata->msg_info.cid == NULL ||\n\t    rdata->msg_info.cid->id.slen == 0 || \n\t    rdata->msg_info.from == NULL || \n\t    rdata->msg_info.to == NULL || \n\t    rdata->msg_info.via == NULL || \n\t    rdata->msg_info.cseq == NULL) \n\t{\n\t    mgr->on_rx_msg(mgr->endpt, PJSIP_EMISSINGHDR, rdata);\n\n\t    /* Notify application about the missing header. */\n\t    if (mgr->tp_drop_data_cb) {\n\t\tpjsip_tp_dropped_data dd;\n\t\tpj_bzero(&dd, sizeof(dd));\n\t\tdd.tp = tr;\n\t\tdd.data = current_pkt;\n\t\tdd.len = msg_fragment_size;\n\t\tdd.status = PJSIP_EMISSINGHDR;\n\t\t(*mgr->tp_drop_data_cb)(&dd);\t    \n\t    }\n\t    goto finish_process_fragment;\n\t}\n\n\t/* For request: */\n\tif (rdata->msg_info.msg->type == PJSIP_REQUEST_MSG) {\n\t    /* always add received parameter to the via. */\n\t    pj_strdup2(rdata->tp_info.pool, \n\t\t       &rdata->msg_info.via->recvd_param, \n\t\t       rdata->pkt_info.src_name);\n\n\t    /* RFC 3581:\n\t     * If message contains \"rport\" param, put the received port there.\n\t     */\n\t    if (rdata->msg_info.via->rport_param == 0) {\n\t\trdata->msg_info.via->rport_param = rdata->pkt_info.src_port;\n\t    }\n\t} else {\n\t    /* Drop malformed responses */\n\t    if (rdata->msg_info.msg->line.status.code < 100 ||\n\t\trdata->msg_info.msg->line.status.code >= 700)\n\t    {\n\t\tmgr->on_rx_msg(mgr->endpt, PJSIP_EINVALIDSTATUS, rdata);\n\n\t\t/* Notify application about the invalid status. */\n\t\tif (mgr->tp_drop_data_cb) {\n\t\t    pjsip_tp_dropped_data dd;\n\t\t    pj_bzero(&dd, sizeof(dd));\n\t\t    dd.tp = tr;\n\t\t    dd.data = current_pkt;\n\t\t    dd.len = msg_fragment_size;\n\t\t    dd.status = PJSIP_EINVALIDSTATUS;\n\t\t    (*mgr->tp_drop_data_cb)(&dd);\t    \n\t\t}\n\t\tgoto finish_process_fragment;\n\t    }\n\t}\n\n\t/* Drop response message if it has more than one Via.\n\t*/\n\t/* This is wrong. Proxy DOES receive responses with multiple\n\t * Via headers! Thanks Aldo <acampi at deis.unibo.it> for pointing\n\t * this out.\n\n\tif (msg->type == PJSIP_RESPONSE_MSG) {\n\t    pjsip_hdr *hdr;\n\t    hdr = (pjsip_hdr*)rdata->msg_info.via->next;\n\t    if (hdr != &msg->hdr) {\n\t\thdr = pjsip_msg_find_hdr(msg, PJSIP_H_VIA, hdr);\n\t\tif (hdr) {\n\t\t    mgr->on_rx_msg(mgr->endpt, PJSIP_EMULTIPLEVIA, rdata);\n\t\t    goto finish_process_fragment;\n\t\t}\n\t    }\n\t}\n\t*/\n\n\t/* Call the transport manager's upstream message callback.\n\t */\n\tmgr->on_rx_msg(mgr->endpt, PJ_SUCCESS, rdata);\n\n\nfinish_process_fragment:\n\ttotal_processed += msg_fragment_size;\n\tcurrent_pkt += msg_fragment_size;\n\tremaining_len -= msg_fragment_size;\n\n    }\t/* while (rdata->pkt_info.len > 0) */\n\n\n    return total_processed;\n}\n\n\n/*\n * pjsip_tpmgr_acquire_transport()\n *\n * Get transport suitable to communicate to remote. Create a new one\n * if necessary.\n */\nPJ_DEF(pj_status_t) pjsip_tpmgr_acquire_transport(pjsip_tpmgr *mgr,\n\t\t\t\t\t\t  pjsip_transport_type_e type,\n\t\t\t\t\t\t  const pj_sockaddr_t *remote,\n\t\t\t\t\t\t  int addr_len,\n\t\t\t\t\t\t  const pjsip_tpselector *sel,\n\t\t\t\t\t\t  pjsip_transport **tp)\n{\n    return pjsip_tpmgr_acquire_transport2(mgr, type, remote, addr_len, sel,\n\t\t\t\t\t  NULL, tp);\n}\n\n\n/*\n * pjsip_tpmgr_acquire_transport2()\n *\n * Get transport suitable to communicate to remote. Create a new one\n * if necessary.\n */\nPJ_DEF(pj_status_t) pjsip_tpmgr_acquire_transport2(pjsip_tpmgr *mgr,\n\t\t\t\t\t\t   pjsip_transport_type_e type,\n\t\t\t\t\t\t   const pj_sockaddr_t *remote,\n\t\t\t\t\t\t   int addr_len,\n\t\t\t\t\t\t   const pjsip_tpselector *sel,\n\t\t\t\t\t\t   pjsip_tx_data *tdata,\n\t\t\t\t\t\t   pjsip_transport **tp)\n{\n    pjsip_tpfactory *factory;\n    pj_status_t status;\n\n    TRACE_((THIS_FILE,\"Acquiring transport type=%s, sel=%s remote=%s:%d\",\n\t\t       pjsip_transport_get_type_name(type),\n\t\t       print_tpsel_info(sel),\n\t\t       addr_string(remote),\n\t\t       pj_sockaddr_get_port(remote)));\n\n    pj_lock_acquire(mgr->lock);\n\n    /* If transport is specified, then just use it if it is suitable\n     * for the destination.\n     */\n    if (sel && sel->type == PJSIP_TPSELECTOR_TRANSPORT &&\n\tsel->u.transport) \n    {\n\tpjsip_transport *seltp = sel->u.transport;\n\n\t/* See if the transport is (not) suitable */\n\tif (seltp->key.type != type) {\n\t    pj_lock_release(mgr->lock);\n\t    TRACE_((THIS_FILE, \"Transport type in tpsel not matched\"));\n\t    return PJSIP_ETPNOTSUITABLE;\n\t}\n\n\t/* Make sure the transport is not being destroyed */\n\tif (seltp->is_destroying) {\n\t    pj_lock_release(mgr->lock);\n\t    TRACE_((THIS_FILE,\"Transport to be acquired is being destroyed\"));\n\t    return PJ_ENOTFOUND;\n\t}\n\n\t/* We could also verify that the destination address is reachable\n\t * from this transport (i.e. both are equal), but if application\n\t * has requested a specific transport to be used, assume that\n\t * it knows what to do.\n\t *\n\t * In other words, I don't think destination verification is a good\n\t * idea for now.\n\t */\n\n\t/* Transport looks to be suitable to use, so just use it. */\n\tpjsip_transport_add_ref(seltp);\n\tpj_lock_release(mgr->lock);\n\t*tp = seltp;\n\n\tTRACE_((THIS_FILE, \"Transport %s acquired\", seltp->obj_name));\n\treturn PJ_SUCCESS;\n\n    } else {\n\n\t/*\n\t * This is the \"normal\" flow, where application doesn't specify\n\t * specific transport to be used to send message to.\n\t * In this case, lookup the transport from the hash table.\n\t */\n\tpjsip_transport_key key;\n\tint key_len;\n\tpjsip_transport *tp_ref = NULL;\n\ttransport *tp_entry = NULL;\n\n\n\t/* If listener is specified, verify that the listener type matches\n\t * the destination type.\n\t */\n\tif (sel && sel->type == PJSIP_TPSELECTOR_LISTENER && sel->u.listener)\n\t{\n\t    if (sel->u.listener->type != type) {\n\t\tpj_lock_release(mgr->lock);\n\t\tTRACE_((THIS_FILE, \"Listener type in tpsel not matched\"));\n\t\treturn PJSIP_ETPNOTSUITABLE;\n\t    }\n\t}\n\n\tif (!sel || sel->disable_connection_reuse == PJ_FALSE) {\n\t    pj_bzero(&key, sizeof(key));\n\t    key_len = sizeof(key.type) + addr_len;\n\n\t    /* First try to get exact destination. */\n\t    key.type = type;\n\t    pj_memcpy(&key.rem_addr, remote, addr_len);\n\n\t    tp_entry = (transport *)pj_hash_get(mgr->table, &key, key_len,\n\t\t\t\t\t\tNULL);\n\t    if (tp_entry) {\n\t\ttransport *tp_iter = tp_entry;\n\t\tdo {\n\t\t    /* Don't use transport being shutdown/destroyed */\n\t\t    if (!tp_iter->tp->is_shutdown &&\n\t\t\t!tp_iter->tp->is_destroying)\n\t\t    {\n\t\t\tif ((type & PJSIP_TRANSPORT_SECURE) && tdata) {\n\t\t\t    /* For secure transport, make sure tdata's\n\t\t\t     * destination host matches the transport's\n\t\t\t     * remote host.\n\t\t\t     */\n\t\t\t    if (pj_stricmp(&tdata->dest_info.name,\n\t\t\t\t  \t   &tp_iter->tp->remote_name.host))\n\t\t\t    {\n\t\t\t    \ttp_iter = tp_iter->next;\n\t\t\t    \tcontinue;\n\t\t\t    }\n\t\t\t}\n\n\t\t\tif (sel && sel->type == PJSIP_TPSELECTOR_LISTENER &&\n\t\t\t    sel->u.listener)\n\t\t\t{\n\t\t\t    /* Match listener if selector is set */\n\t\t\t    if (tp_iter->tp->factory == sel->u.listener) {\n\t\t\t\ttp_ref = tp_iter->tp;\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t} else {\n\t\t\t    tp_ref = tp_iter->tp;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t    tp_iter = tp_iter->next;\n\t\t} while (tp_iter != tp_entry);\n\t    }\n\t}\n\n\tif (tp_ref == NULL &&\n\t    (!sel || sel->disable_connection_reuse == PJ_FALSE))\n\t{\n\t    unsigned flag = pjsip_transport_get_flag_from_type(type);\n\t    const pj_sockaddr *remote_addr = (const pj_sockaddr*)remote;\n\n\n\t    /* Ignore address for loop transports. */\n\t    if (type == PJSIP_TRANSPORT_LOOP ||\n\t\ttype == PJSIP_TRANSPORT_LOOP_DGRAM)\n\t    {\n\t\tpj_sockaddr *addr = &key.rem_addr;\n\n\t\tpj_bzero(addr, addr_len);\n\t\tkey_len = sizeof(key.type) + addr_len;\n\t\ttp_entry = (transport *) pj_hash_get(mgr->table, &key,\n\t\t\t\t\t\t     key_len, NULL);\n\t\tif (tp_entry) {\n\t\t    tp_ref = tp_entry->tp;\n\t\t}\n\t    }\n\t    /* For datagram transports, try lookup with zero address.\n\t     */\n\t    else if (flag & PJSIP_TRANSPORT_DATAGRAM)\n\t    {\n\t\tpj_sockaddr *addr = &key.rem_addr;\n\n\t\tpj_bzero(addr, addr_len);\n\t\taddr->addr.sa_family = remote_addr->addr.sa_family;\n\n\t\tkey_len = sizeof(key.type) + addr_len;\n\t\ttp_entry = (transport *) pj_hash_get(mgr->table, &key,\n\t\t\t\t\t\t     key_len, NULL);\n\t\tif (tp_entry) {\n\t\t    tp_ref = tp_entry->tp;\n\t\t}\n\t    }\n\t}\n\n\t/* If transport is found and listener is specified, verify listener */\n\telse if (sel && sel->type == PJSIP_TPSELECTOR_LISTENER &&\n\t\t sel->u.listener && tp_ref->factory != sel->u.listener)\n\t{\n\t    tp_ref = NULL;\n\t    /* This will cause a new transport to be created which will be a\n\t     * 'duplicate' of the existing transport (same type & remote addr,\n\t     * but different factory).\n\t     */\n\t    TRACE_((THIS_FILE, \"Transport found but from different listener\"));\n\t}\n\n\tif (tp_ref!=NULL && !tp_ref->is_shutdown && !tp_ref->is_destroying) {\n\t    /*\n\t     * Transport found!\n\t     */\n\t    pjsip_transport_add_ref(tp_ref);\n\t    pj_lock_release(mgr->lock);\n\t    *tp = tp_ref;\n\n\t    TRACE_((THIS_FILE, \"Transport %s acquired\", tp_ref->obj_name));\n\t    return PJ_SUCCESS;\n\t}\n\n\n\t/*\n\t * Either transport not found, or we don't want to use the existing\n\t * transport (such as in the case of different factory or\n\t * if connection reuse is disabled). So we need to create one,\n\t * find factory that can create such transport.\n\t *\n\t * If there's an existing transport, its place in the hash table\n\t * will be replaced by this new one. And eventually the existing\n\t * transport will still be freed (by application or #1774).\n\t */\n\tif (sel && sel->type == PJSIP_TPSELECTOR_LISTENER && sel->u.listener)\n\t{\n\t    /* Application has requested that a specific listener is to\n\t     * be used.\n\t     */\n\n\t    /* Verify that the listener type matches the destination type */\n\t    /* Already checked above. */\n\t    /*\n\t    if (sel->u.listener->type != type) {\n\t\tpj_lock_release(mgr->lock);\n\t\treturn PJSIP_ETPNOTSUITABLE;\n\t    }\n\t    */\n\n\t    /* We'll use this listener to create transport */\n\t    factory = sel->u.listener;\n\n\t    /* Verify if listener is still valid */\n\t    if (!pjsip_tpmgr_is_tpfactory_valid(mgr, factory)) {\n\t\tpj_lock_release(mgr->lock);\n\t\tPJ_LOG(3,(THIS_FILE, \"Specified factory for creating \"\n\t\t\t\t     \"transport is not found\"));\n\t\treturn PJ_ENOTFOUND;\n\t    }\n\n\t} else {\n\n\t    /* Find factory with type matches the destination type */\n\t    factory = mgr->factory_list.next;\n\t    while (factory != &mgr->factory_list) {\n\t\tif (factory->type == type)\n\t\t    break;\n\t\tfactory = factory->next;\n\t    }\n\n\t    if (factory == &mgr->factory_list) {\n\t\t/* No factory can create the transport! */\n\t\tpj_lock_release(mgr->lock);\n\t\tTRACE_((THIS_FILE, \"No suitable factory was found either\"));\n\t\treturn PJSIP_EUNSUPTRANSPORT;\n\t    }\n\t}\n    }\n\n    TRACE_((THIS_FILE, \"Creating new transport from factory\"));\n\n    /* Request factory to create transport. */\n    if (factory->create_transport2) {\n\tstatus = factory->create_transport2(factory, mgr, mgr->endpt,\n\t\t\t\t\t    (const pj_sockaddr*) remote,\n\t\t\t\t\t    addr_len, tdata, tp);\n    } else {\n\tstatus = factory->create_transport(factory, mgr, mgr->endpt,\n\t\t\t\t\t   (const pj_sockaddr*) remote,\n\t\t\t\t\t   addr_len, tp);\n    }\n    if (status == PJ_SUCCESS) {\n\tPJ_ASSERT_ON_FAIL(tp!=NULL,\n\t    {pj_lock_release(mgr->lock); return PJ_EBUG;});\n\tpjsip_transport_add_ref(*tp);\n\t(*tp)->factory = factory;\n    }\n    pj_lock_release(mgr->lock);\n    return status;\n}\n\n/**\n * Dump transport info.\n */\nPJ_DEF(void) pjsip_tpmgr_dump_transports(pjsip_tpmgr *mgr)\n{\n#if PJ_LOG_MAX_LEVEL >= 3\n    pj_hash_iterator_t itr_val;\n    pj_hash_iterator_t *itr;\n    pjsip_tpfactory *factory;\n\n    pj_lock_acquire(mgr->lock);\n\n#if defined(PJ_DEBUG) && PJ_DEBUG!=0\n    PJ_LOG(3,(THIS_FILE, \" Outstanding transmit buffers: %d\",\n\t      pj_atomic_get(mgr->tdata_counter)));\n#endif\n\n    PJ_LOG(3, (THIS_FILE, \" Dumping listeners:\"));\n    factory = mgr->factory_list.next;\n    while (factory != &mgr->factory_list) {\n\tPJ_LOG(3, (THIS_FILE, \"  %s %s:%.*s:%d\", \n\t\t   factory->obj_name,\n\t\t   factory->type_name,\n\t\t   (int)factory->addr_name.host.slen,\n\t\t   factory->addr_name.host.ptr,\n\t\t   (int)factory->addr_name.port));\n\tfactory = factory->next;\n    }\n\n    itr = pj_hash_first(mgr->table, &itr_val);\n    if (itr) {\n\tPJ_LOG(3, (THIS_FILE, \" Dumping transports:\"));\n\n\tdo {\n\t    transport *tp_entry = (transport *) pj_hash_this(mgr->table, itr);\n\t    if (tp_entry) {\n\t\ttransport *tp_iter = tp_entry;\n\n\t\tdo {\n\t\t    pjsip_transport *tp_ref = tp_iter->tp;\n\n\t\t    PJ_LOG(3, (THIS_FILE, \"  %s %s%s%s%s(refcnt=%d%s)\",\n\t\t\t       tp_ref->obj_name,\n\t\t\t       tp_ref->info,\n\t\t\t       (tp_ref->factory)?\" listener[\":\"\",\n\t\t\t       (tp_ref->factory)?tp_ref->factory->obj_name:\"\",\n\t\t\t       (tp_ref->factory)?\"]\":\"\",\n\t\t\t       pj_atomic_get(tp_ref->ref_cnt),\n\t\t\t       (tp_ref->idle_timer.id ? \" [idle]\" : \"\")));\n\n\t\t    tp_iter = tp_iter->next;\n\t\t} while (tp_iter != tp_entry);\n\t    }\n\t    itr = pj_hash_next(mgr->table, itr);\n\t} while (itr);\n    }\n\n    pj_lock_release(mgr->lock);\n#else\n    PJ_UNUSED_ARG(mgr);\n#endif\n}\n\n/**\n * Set callback of global transport state notification.\n */\nPJ_DEF(pj_status_t) pjsip_tpmgr_set_state_cb(pjsip_tpmgr *mgr,\n\t\t\t\t\t     pjsip_tp_state_callback cb)\n{\n    PJ_ASSERT_RETURN(mgr, PJ_EINVAL);\n\n    mgr->tp_state_cb = cb;\n\n    return PJ_SUCCESS;\n}\n\n/**\n * Get callback of global transport state notification.\n */\nPJ_DEF(pjsip_tp_state_callback) pjsip_tpmgr_get_state_cb(\n\t\t\t\t\t     const pjsip_tpmgr *mgr)\n{\n    PJ_ASSERT_RETURN(mgr, NULL);\n\n    return mgr->tp_state_cb;\n}\n\n\n/**\n * Allocate and init transport data.\n */\nstatic void init_tp_data(pjsip_transport *tp)\n{\n    transport_data *tp_data;\n\n    pj_assert(tp && !tp->data);\n\n    tp_data = PJ_POOL_ZALLOC_T(tp->pool, transport_data);\n    pj_list_init(&tp_data->st_listeners);\n    pj_list_init(&tp_data->st_listeners_empty);\n    tp->data = tp_data;\n}\n\n\nstatic void tp_state_callback(pjsip_transport *tp,\n\t\t\t      pjsip_transport_state state,\n\t\t\t      const pjsip_transport_state_info *info)\n{\n    transport_data *tp_data;\n\n    pj_lock_acquire(tp->lock);\n\n    tp_data = (transport_data*)tp->data;\n\n    /* Notify the transport state listeners, if any. */\n    if (!tp_data || pj_list_empty(&tp_data->st_listeners)) {\n\tgoto on_return;\n    } else {\n\tpjsip_transport_state_info st_info;\n\ttp_state_listener *st_listener = tp_data->st_listeners.next;\n\n\t/* As we need to put the user data into the transport state info,\n\t * let's use a copy of transport state info.\n\t */\n\tpj_memcpy(&st_info, info, sizeof(st_info));\n\twhile (st_listener != &tp_data->st_listeners) {\n\t    st_info.user_data = st_listener->user_data;\n\t    (*st_listener->cb)(tp, state, &st_info);\n\n\t    st_listener = st_listener->next;\n\t}\n    }\n\non_return:\n    pj_lock_release(tp->lock);\n}\n\n\n/**\n * Add a listener to the specified transport for transport state notification.\n */\nPJ_DEF(pj_status_t) pjsip_transport_add_state_listener (\n\t\t\t\t\t    pjsip_transport *tp,\n\t\t\t\t\t    pjsip_tp_state_callback cb,\n\t\t\t\t\t    void *user_data,\n\t\t\t\t\t    pjsip_tp_state_listener_key **key)\n{\n    transport_data *tp_data;\n    tp_state_listener *entry;\n\n    PJ_ASSERT_RETURN(tp && cb && key, PJ_EINVAL);\n\n    if (tp->is_shutdown || tp->is_destroying) {\n\t*key = NULL;\n\treturn PJ_EINVALIDOP;\n    }\n\n    pj_lock_acquire(tp->lock);\n\n    /* Init transport data, if it hasn't */\n    if (!tp->data)\n\tinit_tp_data(tp);\n\n    tp_data = (transport_data*)tp->data;\n\n    /* Init the new listener entry. Use available empty slot, if any,\n     * otherwise allocate it using the transport pool.\n     */\n    if (!pj_list_empty(&tp_data->st_listeners_empty)) {\n\tentry = tp_data->st_listeners_empty.next;\n\tpj_list_erase(entry);\n    } else {\n\tentry = PJ_POOL_ZALLOC_T(tp->pool, tp_state_listener);\n    }\n    entry->cb = cb;\n    entry->user_data = user_data;\n\n    /* Add the new listener entry to the listeners list */\n    pj_list_push_back(&tp_data->st_listeners, entry);\n\n    *key = entry;\n\n    pj_lock_release(tp->lock);\n\n    return PJ_SUCCESS;\n}\n\n/**\n * Remove a listener from the specified transport for transport state \n * notification.\n */\nPJ_DEF(pj_status_t) pjsip_transport_remove_state_listener (\n\t\t\t\t    pjsip_transport *tp,\n\t\t\t\t    pjsip_tp_state_listener_key *key,\n\t\t\t\t    const void *user_data)\n{\n    transport_data *tp_data;\n    tp_state_listener *entry;\n\n    PJ_ASSERT_RETURN(tp && key, PJ_EINVAL);\n\n    pj_lock_acquire(tp->lock);\n\n    tp_data = (transport_data*)tp->data;\n\n    /* Transport data is NULL or no registered listener? */\n    if (!tp_data || pj_list_empty(&tp_data->st_listeners)) {\n\tpj_lock_release(tp->lock);\n\treturn PJ_ENOTFOUND;\n    }\n\n    entry = (tp_state_listener*)key;\n\n    /* Validate the user data */\n    if (entry->user_data != user_data) {\n\tpj_assert(!\"Invalid transport state listener key\");\n\tpj_lock_release(tp->lock);\n\treturn PJ_EBUG;\n    }\n\n    /* Reset the entry and move it to the empty list */\n    entry->cb = NULL;\n    entry->user_data = NULL;\n    pj_list_erase(entry);\n    pj_list_push_back(&tp_data->st_listeners_empty, entry);\n\n    pj_lock_release(tp->lock);\n\n    return PJ_SUCCESS;\n}\n\n/*\n * Set callback of data dropping.\n */\nPJ_DEF(pj_status_t) pjsip_tpmgr_set_drop_data_cb(pjsip_tpmgr *mgr,\n\t\t\t\t\t\t pjsip_tp_on_rx_dropped_cb cb)\n{\n    PJ_ASSERT_RETURN(mgr, PJ_EINVAL);\n\n    mgr->tp_drop_data_cb = cb;\n\n    return PJ_SUCCESS;\n}\n", "/* $Id$ */\n/* \n * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)\n * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n#include <pjsip/sip_util.h>\n#include <pjsip/sip_transport.h>\n#include <pjsip/sip_msg.h>\n#include <pjsip/sip_endpoint.h>\n#include <pjsip/sip_event.h>\n#include <pjsip/sip_transaction.h>\n#include <pjsip/sip_module.h>\n#include <pjsip/sip_errno.h>\n#include <pj/log.h>\n#include <pj/string.h>\n#include <pj/guid.h>\n#include <pj/pool.h>\n#include <pj/except.h>\n#include <pj/rand.h>\n#include <pj/assert.h>\n#include <pj/errno.h>\n\n#define THIS_FILE    \"endpoint\"\n\nstatic const char *event_str[] = \n{\n    \"UNIDENTIFIED\",\n    \"TIMER\",\n    \"TX_MSG\",\n    \"RX_MSG\",\n    \"TRANSPORT_ERROR\",\n    \"TSX_STATE\",\n    \"USER\",\n};\n\nstatic pj_str_t str_TEXT = { \"text\", 4},\n\t\tstr_PLAIN = { \"plain\", 5 };\n\n/* Add URI to target-set */\nPJ_DEF(pj_status_t) pjsip_target_set_add_uri( pjsip_target_set *tset,\n\t\t\t\t\t      pj_pool_t *pool,\n\t\t\t\t\t      const pjsip_uri *uri,\n\t\t\t\t\t      int q1000)\n{\n    pjsip_target *t, *pos = NULL;\n\n    PJ_ASSERT_RETURN(tset && pool && uri, PJ_EINVAL);\n\n    /* Set q-value to 1 if it is not set */\n    if (q1000 <= 0)\n\tq1000 = 1000;\n\n    /* Scan all the elements to see for duplicates, and at the same time\n     * get the position where the new element should be inserted to\n     * based on the q-value.\n     */\n    t = tset->head.next;\n    while (t != &tset->head) {\n\tif (pjsip_uri_cmp(PJSIP_URI_IN_REQ_URI, t->uri, uri)==PJ_SUCCESS)\n\t    return PJ_EEXISTS;\n\tif (pos==NULL && t->q1000 < q1000)\n\t    pos = t;\n\tt = t->next;\n    }\n\n    /* Create new element */\n    t = PJ_POOL_ZALLOC_T(pool, pjsip_target);\n    t->uri = (pjsip_uri*)pjsip_uri_clone(pool, uri);\n    t->q1000 = q1000;\n\n    /* Insert */\n    if (pos == NULL)\n\tpj_list_push_back(&tset->head, t);\n    else\n\tpj_list_insert_before(pos, t);\n\n    /* Set current target if this is the first URI */\n    if (tset->current == NULL)\n\ttset->current = t;\n\n    return PJ_SUCCESS;\n}\n\n/* Add URI's in the Contact header in the message to target-set */\nPJ_DEF(pj_status_t) pjsip_target_set_add_from_msg( pjsip_target_set *tset,\n\t\t\t\t\t\t   pj_pool_t *pool,\n\t\t\t\t\t\t   const pjsip_msg *msg)\n{\n    const pjsip_hdr *hdr;\n    unsigned added = 0;\n\n    PJ_ASSERT_RETURN(tset && pool && msg, PJ_EINVAL);\n\n    /* Scan for Contact headers and add the URI */\n    hdr = msg->hdr.next;\n    while (hdr != &msg->hdr) {\n\tif (hdr->type == PJSIP_H_CONTACT) {\n\t    const pjsip_contact_hdr *cn_hdr = (const pjsip_contact_hdr*)hdr;\n\n\t    if (!cn_hdr->star) {\n\t\tpj_status_t rc;\n\t\trc = pjsip_target_set_add_uri(tset, pool, cn_hdr->uri, \n\t\t\t\t\t      cn_hdr->q1000);\n\t\tif (rc == PJ_SUCCESS)\n\t\t    ++added;\n\t    }\n\t}\n\thdr = hdr->next;\n    }\n\n    return added ? PJ_SUCCESS : PJ_EEXISTS;\n}\n\n\n/* Get next target, if any */\nPJ_DEF(pjsip_target*) pjsip_target_set_get_next(const pjsip_target_set *tset)\n{\n    const pjsip_target *t, *next = NULL;\n\n    t = tset->head.next;\n    while (t != &tset->head) {\n\tif (PJSIP_IS_STATUS_IN_CLASS(t->code, 200)) {\n\t    /* No more target since one target has been successful */\n\t    return NULL;\n\t}\n\tif (PJSIP_IS_STATUS_IN_CLASS(t->code, 600)) {\n\t    /* No more target since one target returned global error */\n\t    return NULL;\n\t}\n\tif (t->code==0 && next==NULL) {\n\t    /* This would be the next target as long as we don't find\n\t     * targets with 2xx or 6xx status after this.\n\t     */\n\t    next = t;\n\t}\n\tt = t->next;\n    }\n\n    return (pjsip_target*)next;\n}\n\n\n/* Set current target */\nPJ_DEF(pj_status_t) pjsip_target_set_set_current( pjsip_target_set *tset,\n\t\t\t\t\t\t  pjsip_target *target)\n{\n    PJ_ASSERT_RETURN(tset && target, PJ_EINVAL);\n    PJ_ASSERT_RETURN(pj_list_find_node(tset, target) != NULL, PJ_ENOTFOUND);\n\n    tset->current = target;\n\n    return PJ_SUCCESS;\n}\n\n\n/* Assign status to a target */\nPJ_DEF(pj_status_t) pjsip_target_assign_status( pjsip_target *target,\n\t\t\t\t\t        pj_pool_t *pool,\n\t\t\t\t\t        int status_code,\n\t\t\t\t\t        const pj_str_t *reason)\n{\n    PJ_ASSERT_RETURN(target && pool && status_code && reason, PJ_EINVAL);\n\n    target->code = (pjsip_status_code)status_code;\n    pj_strdup(pool, &target->reason, reason);\n\n    return PJ_SUCCESS;\n}\n\n\n\n/*\n * Initialize transmit data (msg) with the headers and optional body.\n * This will just put the headers in the message as it is. Be carefull\n * when calling this function because once a header is put in a message, \n * it CAN NOT be put in other message until the first message is deleted, \n * because the way the header is put in the list.\n * That's why the session will shallow_clone it's headers before calling\n * this function.\n */\nstatic void init_request_throw( pjsip_endpoint *endpt,\n                                pjsip_tx_data *tdata, \n\t\t\t\tpjsip_method *method,\n\t\t\t\tpjsip_uri *param_target,\n\t\t\t\tpjsip_from_hdr *param_from,\n\t\t\t\tpjsip_to_hdr *param_to, \n\t\t\t\tpjsip_contact_hdr *param_contact,\n\t\t\t\tpjsip_cid_hdr *param_call_id,\n\t\t\t\tpjsip_cseq_hdr *param_cseq, \n\t\t\t\tconst pj_str_t *param_text)\n{\n    pjsip_msg *msg;\n    pjsip_msg_body *body;\n    pjsip_via_hdr *via;\n    const pjsip_hdr *endpt_hdr;\n\n    /* Create the message. */\n    msg = tdata->msg = pjsip_msg_create(tdata->pool, PJSIP_REQUEST_MSG);\n\n    /* Init request URI. */\n    pj_memcpy(&msg->line.req.method, method, sizeof(*method));\n    msg->line.req.uri = param_target;\n\n    /* Add additional request headers from endpoint. */\n    endpt_hdr = pjsip_endpt_get_request_headers(endpt)->next;\n    while (endpt_hdr != pjsip_endpt_get_request_headers(endpt)) {\n\tpjsip_hdr *hdr = (pjsip_hdr*) \n\t\t\t pjsip_hdr_shallow_clone(tdata->pool, endpt_hdr);\n\tpjsip_msg_add_hdr( tdata->msg, hdr );\n\tendpt_hdr = endpt_hdr->next;\n    }\n\n    /* Add From header. */\n    if (param_from->tag.slen == 0)\n\tpj_create_unique_string(tdata->pool, &param_from->tag);\n    pjsip_msg_add_hdr(msg, (pjsip_hdr*)param_from);\n\n    /* Add To header. */\n    pjsip_msg_add_hdr(msg, (pjsip_hdr*)param_to);\n\n    /* Add Contact header. */\n    if (param_contact) {\n\tpjsip_msg_add_hdr(msg, (pjsip_hdr*)param_contact);\n    }\n\n    /* Add Call-ID header. */\n    pjsip_msg_add_hdr(msg, (pjsip_hdr*)param_call_id);\n\n    /* Add CSeq header. */\n    pjsip_msg_add_hdr(msg, (pjsip_hdr*)param_cseq);\n\n    /* Add a blank Via header in the front of the message. */\n    via = pjsip_via_hdr_create(tdata->pool);\n    via->rport_param = pjsip_cfg()->endpt.disable_rport ? -1 : 0;\n    pjsip_msg_insert_first_hdr(msg, (pjsip_hdr*)via);\n\n    /* Add header params as request headers */\n    if (PJSIP_URI_SCHEME_IS_SIP(param_target) || \n\tPJSIP_URI_SCHEME_IS_SIPS(param_target)) \n    {\n\tpjsip_sip_uri *uri = (pjsip_sip_uri*) pjsip_uri_get_uri(param_target);\n\tpjsip_param *hparam;\n\n\thparam = uri->header_param.next;\n\twhile (hparam != &uri->header_param) {\n\t    pjsip_generic_string_hdr *hdr;\n\n\t    hdr = pjsip_generic_string_hdr_create(tdata->pool, \n\t\t\t\t\t\t  &hparam->name,\n\t\t\t\t\t\t  &hparam->value);\n\t    pjsip_msg_add_hdr(msg, (pjsip_hdr*)hdr);\n\t    hparam = hparam->next;\n\t}\n    }\n\n    /* Create message body. */\n    if (param_text) {\n\tbody = PJ_POOL_ZALLOC_T(tdata->pool, pjsip_msg_body);\n\tbody->content_type.type = str_TEXT;\n\tbody->content_type.subtype = str_PLAIN;\n\tbody->data = pj_pool_alloc(tdata->pool, param_text->slen );\n\tpj_memcpy(body->data, param_text->ptr, param_text->slen);\n\tbody->len = (unsigned)param_text->slen;\n\tbody->print_body = &pjsip_print_text_body;\n\tmsg->body = body;\n    }\n\n    PJ_LOG(5,(THIS_FILE, \"%s created.\", \n\t\t\t pjsip_tx_data_get_info(tdata)));\n\n}\n\n/*\n * Create arbitrary request.\n */\nPJ_DEF(pj_status_t) pjsip_endpt_create_request(  pjsip_endpoint *endpt, \n\t\t\t\t\t\t const pjsip_method *method,\n\t\t\t\t\t\t const pj_str_t *param_target,\n\t\t\t\t\t\t const pj_str_t *param_from,\n\t\t\t\t\t\t const pj_str_t *param_to, \n\t\t\t\t\t\t const pj_str_t *param_contact,\n\t\t\t\t\t\t const pj_str_t *param_call_id,\n\t\t\t\t\t\t int param_cseq, \n\t\t\t\t\t\t const pj_str_t *param_text,\n\t\t\t\t\t\t pjsip_tx_data **p_tdata)\n{\n    pjsip_uri *target;\n    pjsip_tx_data *tdata;\n    pjsip_from_hdr *from;\n    pjsip_to_hdr *to;\n    pjsip_contact_hdr *contact;\n    pjsip_cseq_hdr *cseq = NULL;    /* = NULL, warning in VC6 */\n    pjsip_cid_hdr *call_id;\n    pj_str_t tmp;\n    pj_status_t status;\n    const pj_str_t STR_CONTACT = { \"Contact\", 7 };\n    PJ_USE_EXCEPTION;\n\n    status = pjsip_endpt_create_tdata(endpt, &tdata);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Init reference counter to 1. */\n    pjsip_tx_data_add_ref(tdata);\n\n    PJ_TRY {\n\t/* Request target. */\n\tpj_strdup_with_null(tdata->pool, &tmp, param_target);\n\ttarget = pjsip_parse_uri( tdata->pool, tmp.ptr, tmp.slen, 0);\n\tif (target == NULL) {\n\t    status = PJSIP_EINVALIDREQURI;\n\t    goto on_error;\n\t}\n\n\t/* From */\n\tfrom = pjsip_from_hdr_create(tdata->pool);\n\tpj_strdup_with_null(tdata->pool, &tmp, param_from);\n\tfrom->uri = pjsip_parse_uri( tdata->pool, tmp.ptr, tmp.slen, \n\t\t\t\t     PJSIP_PARSE_URI_AS_NAMEADDR);\n\tif (from->uri == NULL) {\n\t    status = PJSIP_EINVALIDHDR;\n\t    goto on_error;\n\t}\n\tpj_create_unique_string(tdata->pool, &from->tag);\n\n\t/* To */\n\tto = pjsip_to_hdr_create(tdata->pool);\n\tpj_strdup_with_null(tdata->pool, &tmp, param_to);\n\tto->uri = pjsip_parse_uri( tdata->pool, tmp.ptr, tmp.slen, \n\t\t\t\t   PJSIP_PARSE_URI_AS_NAMEADDR);\n\tif (to->uri == NULL) {\n\t    status = PJSIP_EINVALIDHDR;\n\t    goto on_error;\n\t}\n\n\t/* Contact. */\n\tif (param_contact) {\n\t    pj_strdup_with_null(tdata->pool, &tmp, param_contact);\n\t    contact = (pjsip_contact_hdr*)\n\t\t      pjsip_parse_hdr(tdata->pool, &STR_CONTACT, tmp.ptr, \n\t\t\t\t      tmp.slen, NULL);\n\t    if (contact == NULL) {\n\t\tstatus = PJSIP_EINVALIDHDR;\n\t\tgoto on_error;\n\t    }\n\t} else {\n\t    contact = NULL;\n\t}\n\n\t/* Call-ID */\n\tcall_id = pjsip_cid_hdr_create(tdata->pool);\n\tif (param_call_id != NULL && param_call_id->slen)\n\t    pj_strdup(tdata->pool, &call_id->id, param_call_id);\n\telse\n\t    pj_create_unique_string(tdata->pool, &call_id->id);\n\n\t/* CSeq */\n\tcseq = pjsip_cseq_hdr_create(tdata->pool);\n\tif (param_cseq >= 0)\n\t    cseq->cseq = param_cseq;\n\telse\n\t    cseq->cseq = pj_rand() & 0xFFFF;\n\n\t/* Method */\n\tpjsip_method_copy(tdata->pool, &cseq->method, method);\n\n\t/* Create the request. */\n\tinit_request_throw( endpt, tdata, &cseq->method, target, from, to, \n                            contact, call_id, cseq, param_text);\n    }\n    PJ_CATCH_ANY {\n\tstatus = PJ_ENOMEM;\n\tgoto on_error;\n    }\n    PJ_END\n\n    *p_tdata = tdata;\n    return PJ_SUCCESS;\n\non_error:\n    pjsip_tx_data_dec_ref(tdata);\n    return status;\n}\n\nPJ_DEF(pj_status_t) pjsip_endpt_create_request_from_hdr( pjsip_endpoint *endpt,\n\t\t\t\t     const pjsip_method *method,\n\t\t\t\t     const pjsip_uri *param_target,\n\t\t\t\t     const pjsip_from_hdr *param_from,\n\t\t\t\t     const pjsip_to_hdr *param_to,\n\t\t\t\t     const pjsip_contact_hdr *param_contact,\n\t\t\t\t     const pjsip_cid_hdr *param_call_id,\n\t\t\t\t     int param_cseq,\n\t\t\t\t     const pj_str_t *param_text,\n\t\t\t\t     pjsip_tx_data **p_tdata)\n{\n    pjsip_uri *target;\n    pjsip_tx_data *tdata;\n    pjsip_from_hdr *from;\n    pjsip_to_hdr *to;\n    pjsip_contact_hdr *contact;\n    pjsip_cid_hdr *call_id;\n    pjsip_cseq_hdr *cseq = NULL; /* The NULL because warning in VC6 */\n    pj_status_t status;\n    PJ_USE_EXCEPTION;\n\n    /* Check arguments. */\n    PJ_ASSERT_RETURN(endpt && method && param_target && param_from &&\n\t\t     param_to && p_tdata, PJ_EINVAL);\n\n    /* Create new transmit data. */\n    status = pjsip_endpt_create_tdata(endpt, &tdata);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Set initial reference counter to 1. */\n    pjsip_tx_data_add_ref(tdata);\n\n    PJ_TRY {\n\t/* Duplicate target URI and headers. */\n\ttarget = (pjsip_uri*) pjsip_uri_clone(tdata->pool, param_target);\n\tfrom = (pjsip_from_hdr*) pjsip_hdr_clone(tdata->pool, param_from);\n\tpjsip_fromto_hdr_set_from(from);\n\tto = (pjsip_to_hdr*) pjsip_hdr_clone(tdata->pool, param_to);\n\tpjsip_fromto_hdr_set_to(to);\n\tif (param_contact) {\n\t    contact = (pjsip_contact_hdr*) \n\t    \t      pjsip_hdr_clone(tdata->pool, param_contact);\n\t} else {\n\t    contact = NULL;\n\t}\n\tcall_id = pjsip_cid_hdr_create(tdata->pool);\n\tif (param_call_id != NULL && param_call_id->id.slen)\n\t    pj_strdup(tdata->pool, &call_id->id, &param_call_id->id);\n\telse\n\t    pj_create_unique_string(tdata->pool, &call_id->id);\n\n\tcseq = pjsip_cseq_hdr_create(tdata->pool);\n\tif (param_cseq >= 0)\n\t    cseq->cseq = param_cseq;\n\telse\n\t    cseq->cseq = pj_rand() % 0xFFFF;\n\tpjsip_method_copy(tdata->pool, &cseq->method, method);\n\n\t/* Copy headers to the request. */\n\tinit_request_throw(endpt, tdata, &cseq->method, target, from, to, \n                           contact, call_id, cseq, param_text);\n    }\n    PJ_CATCH_ANY {\n\tstatus = PJ_ENOMEM;\n\tgoto on_error;\n    }\n    PJ_END;\n\n    *p_tdata = tdata;\n    return PJ_SUCCESS;\n\non_error:\n    pjsip_tx_data_dec_ref(tdata);\n    return status;\n}\n\n/*\n * Construct a minimal response message for the received request.\n */\nPJ_DEF(pj_status_t) pjsip_endpt_create_response( pjsip_endpoint *endpt,\n\t\t\t\t\t\t const pjsip_rx_data *rdata,\n\t\t\t\t\t\t int st_code,\n\t\t\t\t\t\t const pj_str_t *st_text,\n\t\t\t\t\t\t pjsip_tx_data **p_tdata)\n{\n    pjsip_tx_data *tdata;\n    pjsip_msg *msg, *req_msg;\n    pjsip_hdr *hdr;\n    pjsip_to_hdr *to_hdr;\n    pjsip_via_hdr *top_via = NULL, *via;\n    pjsip_rr_hdr *rr;\n    pj_status_t status;\n\n    /* Check arguments. */\n    PJ_ASSERT_RETURN(endpt && rdata && p_tdata, PJ_EINVAL);\n\n    /* Check status code. */\n    PJ_ASSERT_RETURN(st_code >= 100 && st_code <= 699, PJ_EINVAL);\n\n    /* rdata must be a request message. */\n    req_msg = rdata->msg_info.msg;\n    pj_assert(req_msg->type == PJSIP_REQUEST_MSG);\n\n    /* Request MUST NOT be ACK request! */\n    PJ_ASSERT_RETURN(req_msg->line.req.method.id != PJSIP_ACK_METHOD,\n\t\t     PJ_EINVALIDOP);\n\n    /* Create a new transmit buffer. */\n    status = pjsip_endpt_create_tdata( endpt, &tdata);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Set initial reference count to 1. */\n    pjsip_tx_data_add_ref(tdata);\n\n    /* Create new response message. */\n    tdata->msg = msg = pjsip_msg_create(tdata->pool, PJSIP_RESPONSE_MSG);\n\n    /* Set status code and reason text. */\n    msg->line.status.code = st_code;\n    if (st_text)\n\tpj_strdup(tdata->pool, &msg->line.status.reason, st_text);\n    else\n\tmsg->line.status.reason = *pjsip_get_status_text(st_code);\n\n    /* Set TX data attributes. */\n    tdata->rx_timestamp = rdata->pkt_info.timestamp;\n\n    /* Copy all the via headers, in order. */\n    via = rdata->msg_info.via;\n    while (via) {\n\tpjsip_via_hdr *new_via;\n\n\tnew_via = (pjsip_via_hdr*)pjsip_hdr_clone(tdata->pool, via);\n\tif (top_via == NULL)\n\t    top_via = new_via;\n\n\tpjsip_msg_add_hdr( msg, (pjsip_hdr*)new_via);\n\tvia = via->next;\n\tif (via != (void*)&req_msg->hdr)\n\t    via = (pjsip_via_hdr*) \n\t    \t  pjsip_msg_find_hdr(req_msg, PJSIP_H_VIA, via);\n\telse\n\t    break;\n    }\n\n    /* Copy all Record-Route headers, in order. */\n    rr = (pjsip_rr_hdr*) \n    \t pjsip_msg_find_hdr(req_msg, PJSIP_H_RECORD_ROUTE, NULL);\n    while (rr) {\n\tpjsip_msg_add_hdr(msg, (pjsip_hdr*) pjsip_hdr_clone(tdata->pool, rr));\n\trr = rr->next;\n\tif (rr != (void*)&req_msg->hdr)\n\t    rr = (pjsip_rr_hdr*) pjsip_msg_find_hdr(req_msg, \n\t    \t\t\t\t\t    PJSIP_H_RECORD_ROUTE, rr);\n\telse\n\t    break;\n    }\n\n    /* Copy Call-ID header. */\n    hdr = (pjsip_hdr*) pjsip_msg_find_hdr( req_msg, PJSIP_H_CALL_ID, NULL);\n    pjsip_msg_add_hdr(msg, (pjsip_hdr*) pjsip_hdr_clone(tdata->pool, hdr));\n\n    /* Copy From header. */\n    hdr = (pjsip_hdr*) pjsip_hdr_clone(tdata->pool, rdata->msg_info.from);\n    pjsip_msg_add_hdr( msg, hdr);\n\n    /* Copy To header. */\n    to_hdr = (pjsip_to_hdr*) pjsip_hdr_clone(tdata->pool, rdata->msg_info.to);\n    pjsip_msg_add_hdr( msg, (pjsip_hdr*)to_hdr);\n\n    /* Must add To tag in the response (Section 8.2.6.2), except if this is\n     * 100 (Trying) response. Same tag must be created for the same request\n     * (e.g. same tag in provisional and final response). The easiest way\n     * to do this is to derive the tag from Via branch parameter (or to\n     * use it directly).\n     */\n    if (to_hdr->tag.slen==0 && st_code > 100 && top_via) {\n\tto_hdr->tag = top_via->branch_param;\n    }\n\n    /* Copy CSeq header. */\n    hdr = (pjsip_hdr*) pjsip_hdr_clone(tdata->pool, rdata->msg_info.cseq);\n    pjsip_msg_add_hdr( msg, hdr);\n\n    /* All done. */\n    *p_tdata = tdata;\n\n    PJ_LOG(5,(THIS_FILE, \"%s created\", pjsip_tx_data_get_info(tdata)));\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Construct ACK for 3xx-6xx final response (according to chapter 17.1.1 of\n * RFC3261). Note that the generation of ACK for 2xx response is different,\n * and one must not use this function to generate such ACK.\n */\nPJ_DEF(pj_status_t) pjsip_endpt_create_ack( pjsip_endpoint *endpt,\n\t\t\t\t\t    const pjsip_tx_data *tdata,\n\t\t\t\t\t    const pjsip_rx_data *rdata,\n\t\t\t\t\t    pjsip_tx_data **ack_tdata)\n{\n    pjsip_tx_data *ack = NULL;\n    const pjsip_msg *invite_msg;\n    const pjsip_from_hdr *from_hdr;\n    const pjsip_to_hdr *to_hdr;\n    const pjsip_cid_hdr *cid_hdr;\n    const pjsip_cseq_hdr *cseq_hdr;\n    const pjsip_hdr *hdr;\n    pjsip_hdr *via;\n    pjsip_to_hdr *to;\n    pj_status_t status;\n\n    /* rdata must be a non-2xx final response. */\n    pj_assert(rdata->msg_info.msg->type==PJSIP_RESPONSE_MSG &&\n\t      rdata->msg_info.msg->line.status.code >= 300);\n\n    /* Initialize return value to NULL. */\n    *ack_tdata = NULL;\n\n    /* The original INVITE message. */\n    invite_msg = tdata->msg;\n\n    /* Get the headers from original INVITE request. */\n#   define FIND_HDR(m,HNAME) pjsip_msg_find_hdr(m, PJSIP_H_##HNAME, NULL)\n\n    from_hdr = (const pjsip_from_hdr*) FIND_HDR(invite_msg, FROM);\n    PJ_ASSERT_ON_FAIL(from_hdr != NULL, goto on_missing_hdr);\n\n    to_hdr = (const pjsip_to_hdr*) FIND_HDR(invite_msg, TO);\n    PJ_ASSERT_ON_FAIL(to_hdr != NULL, goto on_missing_hdr);\n\n    cid_hdr = (const pjsip_cid_hdr*) FIND_HDR(invite_msg, CALL_ID);\n    PJ_ASSERT_ON_FAIL(to_hdr != NULL, goto on_missing_hdr);\n\n    cseq_hdr = (const pjsip_cseq_hdr*) FIND_HDR(invite_msg, CSEQ);\n    PJ_ASSERT_ON_FAIL(to_hdr != NULL, goto on_missing_hdr);\n\n#   undef FIND_HDR\n\n    /* Create new request message from the headers. */\n    status = pjsip_endpt_create_request_from_hdr(endpt, \n\t\t\t\t\t\t pjsip_get_ack_method(),\n\t\t\t\t\t\t tdata->msg->line.req.uri,\n\t\t\t\t\t\t from_hdr, to_hdr,\n\t\t\t\t\t\t NULL, cid_hdr,\n\t\t\t\t\t\t cseq_hdr->cseq, NULL,\n\t\t\t\t\t\t &ack);\n\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Update tag in To header with the one from the response (if any). */\n    to = (pjsip_to_hdr*) pjsip_msg_find_hdr(ack->msg, PJSIP_H_TO, NULL);\n    pj_strdup(ack->pool, &to->tag, &rdata->msg_info.to->tag);\n\n\n    /* Clear Via headers in the new request. */\n    while ((via=(pjsip_hdr*)pjsip_msg_find_hdr(ack->msg, PJSIP_H_VIA, NULL)) != NULL)\n\tpj_list_erase(via);\n\n    /* Must contain single Via, just as the original INVITE. */\n    hdr = (pjsip_hdr*) pjsip_msg_find_hdr( invite_msg, PJSIP_H_VIA, NULL);\n    pjsip_msg_insert_first_hdr( ack->msg, \n    \t\t\t        (pjsip_hdr*) pjsip_hdr_clone(ack->pool,hdr) );\n\n    /* If the original INVITE has Route headers, those header fields MUST \n     * appear in the ACK.\n     */\n    hdr = (pjsip_hdr*) pjsip_msg_find_hdr( invite_msg, PJSIP_H_ROUTE, NULL);\n    while (hdr != NULL) {\n\tpjsip_msg_add_hdr( ack->msg, \n\t\t\t   (pjsip_hdr*) pjsip_hdr_clone(ack->pool, hdr) );\n\thdr = hdr->next;\n\tif (hdr == &invite_msg->hdr)\n\t    break;\n\thdr = (pjsip_hdr*) pjsip_msg_find_hdr( invite_msg, PJSIP_H_ROUTE, hdr);\n    }\n\n    /* We're done.\n     * \"tdata\" parameter now contains the ACK message.\n     */\n    *ack_tdata = ack;\n    return PJ_SUCCESS;\n\non_missing_hdr:\n    if (ack)\n\tpjsip_tx_data_dec_ref(ack);\n    return PJSIP_EMISSINGHDR;\n}\n\n\n/*\n * Construct CANCEL request for the previously sent request, according to\n * chapter 9.1 of RFC3261.\n */\nPJ_DEF(pj_status_t) pjsip_endpt_create_cancel( pjsip_endpoint *endpt,\n\t\t\t\t\t       const pjsip_tx_data *req_tdata,\n\t\t\t\t\t       pjsip_tx_data **p_tdata)\n{\n    pjsip_tx_data *cancel_tdata = NULL;\n    const pjsip_from_hdr *from_hdr;\n    const pjsip_to_hdr *to_hdr;\n    const pjsip_cid_hdr *cid_hdr;\n    const pjsip_cseq_hdr *cseq_hdr;\n    const pjsip_hdr *hdr;\n    pjsip_hdr *via;\n    pj_status_t status;\n\n    /* The transmit buffer must INVITE request. */\n    PJ_ASSERT_RETURN(req_tdata->msg->type == PJSIP_REQUEST_MSG &&\n\t\t     req_tdata->msg->line.req.method.id == PJSIP_INVITE_METHOD,\n\t\t     PJ_EINVAL);\n\n    /* Get the headers from original INVITE request. */\n#   define FIND_HDR(m,HNAME) pjsip_msg_find_hdr(m, PJSIP_H_##HNAME, NULL)\n\n    from_hdr = (const pjsip_from_hdr*) FIND_HDR(req_tdata->msg, FROM);\n    PJ_ASSERT_ON_FAIL(from_hdr != NULL, goto on_missing_hdr);\n\n    to_hdr = (const pjsip_to_hdr*) FIND_HDR(req_tdata->msg, TO);\n    PJ_ASSERT_ON_FAIL(to_hdr != NULL, goto on_missing_hdr);\n\n    cid_hdr = (const pjsip_cid_hdr*) FIND_HDR(req_tdata->msg, CALL_ID);\n    PJ_ASSERT_ON_FAIL(to_hdr != NULL, goto on_missing_hdr);\n\n    cseq_hdr = (const pjsip_cseq_hdr*) FIND_HDR(req_tdata->msg, CSEQ);\n    PJ_ASSERT_ON_FAIL(to_hdr != NULL, goto on_missing_hdr);\n\n#   undef FIND_HDR\n\n    /* Create new request message from the headers. */\n    status = pjsip_endpt_create_request_from_hdr(endpt, \n\t\t\t\t\t\t pjsip_get_cancel_method(),\n\t\t\t\t\t\t req_tdata->msg->line.req.uri,\n\t\t\t\t\t\t from_hdr, to_hdr,\n\t\t\t\t\t\t NULL, cid_hdr,\n\t\t\t\t\t\t cseq_hdr->cseq, NULL,\n\t\t\t\t\t\t &cancel_tdata);\n\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Clear Via headers in the new request. */\n    while ((via=(pjsip_hdr*)pjsip_msg_find_hdr(cancel_tdata->msg, PJSIP_H_VIA, NULL)) != NULL)\n\tpj_list_erase(via);\n\n\n    /* Must only have single Via which matches the top-most Via in the \n     * request being cancelled. \n     */\n    hdr = (pjsip_hdr*) pjsip_msg_find_hdr(req_tdata->msg, PJSIP_H_VIA, NULL);\n    if (hdr) {\n\tpjsip_msg_insert_first_hdr(cancel_tdata->msg, \n\t\t\t\t   (pjsip_hdr*)pjsip_hdr_clone(cancel_tdata->pool, hdr));\n    }\n\n    /* If the original request has Route header, the CANCEL request must also\n     * has exactly the same.\n     * Copy \"Route\" header from the request.\n     */\n    hdr = (pjsip_hdr*) pjsip_msg_find_hdr(req_tdata->msg, PJSIP_H_ROUTE, NULL);\n    while (hdr != NULL) {\n\tpjsip_msg_add_hdr(cancel_tdata->msg, \n\t\t\t  (pjsip_hdr*) pjsip_hdr_clone(cancel_tdata->pool, hdr));\n\thdr = hdr->next;\n\tif (hdr != &req_tdata->msg->hdr)\n\t    hdr = (pjsip_hdr*) pjsip_msg_find_hdr(req_tdata->msg, \n\t    \t\t\t\t\t  PJSIP_H_ROUTE, hdr);\n\telse\n\t    break;\n    }\n\n    /* Must also copy the saved strict route header, otherwise CANCEL will be\n     * sent with swapped Route and request URI!\n     */\n    if (req_tdata->saved_strict_route) {\n\tcancel_tdata->saved_strict_route = (pjsip_route_hdr*)\n\t    pjsip_hdr_clone(cancel_tdata->pool, req_tdata->saved_strict_route);\n    }\n\n    /* Copy the destination info from the original request */\n    pj_memcpy(&cancel_tdata->dest_info, &req_tdata->dest_info,\n\t      sizeof(req_tdata->dest_info));\n\n    /* Finally, copy the destination host name from the original request */\n    pj_strdup(cancel_tdata->pool, &cancel_tdata->dest_info.name,\n\t      &req_tdata->dest_info.name);\n\n    /* Done.\n     * Return the transmit buffer containing the CANCEL request.\n     */\n    *p_tdata = cancel_tdata;\n    return PJ_SUCCESS;\n\non_missing_hdr:\n    if (cancel_tdata)\n\tpjsip_tx_data_dec_ref(cancel_tdata);\n    return PJSIP_EMISSINGHDR;\n}\n\n\n/* Fill-up destination information from a target URI */\nPJ_DEF(pj_status_t) pjsip_get_dest_info(const pjsip_uri *target_uri,\n\t\t\t\t \tconst pjsip_uri *request_uri,\n\t\t\t\t \tpj_pool_t *pool,\n\t\t\t\t \tpjsip_host_info *dest_info)\n{\n    /* The target URI must be a SIP/SIPS URL so we can resolve it's address.\n     * Otherwise we're in trouble (i.e. there's no host part in tel: URL).\n     */\n    pj_bzero(dest_info, sizeof(*dest_info));\n\n    /* When request URI uses sips scheme, TLS must always be used regardless\n     * of the target scheme or transport type (see ticket #1740).\n     */\n    if (PJSIP_URI_SCHEME_IS_SIPS(target_uri) || \n\t(pjsip_cfg()->endpt.disable_tls_switch == 0 && request_uri &&\n\t PJSIP_URI_SCHEME_IS_SIPS(request_uri)))\n    {\n\tpjsip_uri *uri = (pjsip_uri*) target_uri;\n\tconst pjsip_sip_uri *url=(const pjsip_sip_uri*)pjsip_uri_get_uri(uri);\n\tunsigned flag;\n\n\tif (!PJSIP_URI_SCHEME_IS_SIPS(target_uri)) {\n\t    PJ_LOG(4,(THIS_FILE, \"Automatic switch to TLS transport as \"\n\t\t\t\t \"request-URI uses \"\"sips\"\" scheme.\"));\n\t}\n\n\tdest_info->flag |= (PJSIP_TRANSPORT_SECURE | PJSIP_TRANSPORT_RELIABLE);\n\tif (url->maddr_param.slen)\n\t    pj_strdup(pool, &dest_info->addr.host, &url->maddr_param);\n\telse\n\t    pj_strdup(pool, &dest_info->addr.host, &url->host);\n        dest_info->addr.port = url->port;\n\tdest_info->type = \n            pjsip_transport_get_type_from_name(&url->transport_param);\n\t/* Double-check that the transport parameter match.\n\t * Sample case:     sips:host;transport=tcp\n\t * See https://trac.pjsip.org/repos/ticket/1319\n\t */\n\tflag = pjsip_transport_get_flag_from_type(dest_info->type);\n\tif ((flag & dest_info->flag) != dest_info->flag) {\n\t    pjsip_transport_type_e t;\n\n\t    t = pjsip_transport_get_type_from_flag(dest_info->flag);\n\t    if (t != PJSIP_TRANSPORT_UNSPECIFIED)\n\t\tdest_info->type = t;\n\t}\n\n    } else if (PJSIP_URI_SCHEME_IS_SIP(target_uri)) {\n\tpjsip_uri *uri = (pjsip_uri*) target_uri;\n\tconst pjsip_sip_uri *url=(const pjsip_sip_uri*)pjsip_uri_get_uri(uri);\n\tif (url->maddr_param.slen)\n\t    pj_strdup(pool, &dest_info->addr.host, &url->maddr_param);\n\telse\n\t    pj_strdup(pool, &dest_info->addr.host, &url->host);\n\tdest_info->addr.port = url->port;\n\tdest_info->type = \n            pjsip_transport_get_type_from_name(&url->transport_param);\n\tdest_info->flag = \n\t    pjsip_transport_get_flag_from_type(dest_info->type);\n    } else {\n\t/* Should have never reached here; app should have configured route\n\t * set when sending to tel: URI\n        pj_assert(!\"Unsupported URI scheme!\");\n\t */\n\tPJ_TODO(SUPPORT_REQUEST_ADDR_RESOLUTION_FOR_TEL_URI);\n\treturn PJSIP_ENOROUTESET;\n    }\n\n    /* Handle IPv6 (http://trac.pjsip.org/repos/ticket/861) */\n    if (dest_info->type != PJSIP_TRANSPORT_UNSPECIFIED && \n\tpj_strchr(&dest_info->addr.host, ':'))\n    {\n\tdest_info->type = (pjsip_transport_type_e)\n\t\t\t  ((int)dest_info->type | PJSIP_TRANSPORT_IPV6);\n    }\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Find which destination to be used to send the request message, based\n * on the request URI and Route headers in the message. The procedure\n * used here follows the guidelines on sending the request in RFC 3261\n * chapter 8.1.2.\n */\nPJ_DEF(pj_status_t) pjsip_get_request_dest(const pjsip_tx_data *tdata,\n\t\t\t\t\t   pjsip_host_info *dest_info )\n{\n    const pjsip_uri *target_uri;\n    const pjsip_route_hdr *first_route_hdr;\n    \n    PJ_ASSERT_RETURN(tdata->msg->type == PJSIP_REQUEST_MSG, \n\t\t     PJSIP_ENOTREQUESTMSG);\n    PJ_ASSERT_RETURN(dest_info != NULL, PJ_EINVAL);\n\n    /* Get the first \"Route\" header from the message.\n     */\n    first_route_hdr = (const pjsip_route_hdr*) \n    \t\t      pjsip_msg_find_hdr(tdata->msg, PJSIP_H_ROUTE, NULL);\n    if (first_route_hdr) {\n\ttarget_uri = first_route_hdr->name_addr.uri;\n    } else {\n\ttarget_uri = tdata->msg->line.req.uri;\n    }\n\n    return pjsip_get_dest_info(target_uri, tdata->msg->line.req.uri,\n\t\t\t       (pj_pool_t*)tdata->pool, dest_info);\n}\n\n\n/*\n * Process route-set found in the request and calculate\n * the destination to be used to send the request message, based\n * on the request URI and Route headers in the message. The procedure\n * used here follows the guidelines on sending the request in RFC 3261\n * chapter 8.1.2.\n */\nPJ_DEF(pj_status_t) pjsip_process_route_set(pjsip_tx_data *tdata,\n\t\t\t\t\t    pjsip_host_info *dest_info )\n{\n    const pjsip_uri *new_request_uri, *target_uri;\n    const pjsip_name_addr *topmost_route_uri;\n    pjsip_route_hdr *first_route_hdr, *last_route_hdr;\n    pj_status_t status;\n    \n    PJ_ASSERT_RETURN(tdata->msg->type == PJSIP_REQUEST_MSG, \n\t\t     PJSIP_ENOTREQUESTMSG);\n    PJ_ASSERT_RETURN(dest_info != NULL, PJ_EINVAL);\n\n    /* If the request contains strict route, check that the strict route\n     * has been restored to its original values before processing the\n     * route set. The strict route is restored to the original values\n     * with pjsip_restore_strict_route_set(). If caller did not restore\n     * the strict route before calling this function, we need to call it\n     * here, or otherwise the strict-route and Request-URI will be swapped\n     * twice!\n     */\n    if (tdata->saved_strict_route != NULL) {\n\tpjsip_restore_strict_route_set(tdata);\n    }\n    PJ_ASSERT_RETURN(tdata->saved_strict_route==NULL, PJ_EBUG);\n\n    /* Find the first and last \"Route\" headers from the message. */\n    last_route_hdr = first_route_hdr = (pjsip_route_hdr*)\n\tpjsip_msg_find_hdr(tdata->msg, PJSIP_H_ROUTE, NULL);\n    if (first_route_hdr) {\n\ttopmost_route_uri = &first_route_hdr->name_addr;\n\twhile (last_route_hdr->next != (void*)&tdata->msg->hdr) {\n\t    pjsip_route_hdr *hdr;\n\t    hdr = (pjsip_route_hdr*)\n\t    \t  pjsip_msg_find_hdr(tdata->msg, PJSIP_H_ROUTE, \n                                     last_route_hdr->next);\n\t    if (!hdr)\n\t\tbreak;\n\t    last_route_hdr = hdr;\n\t}\n    } else {\n\ttopmost_route_uri = NULL;\n    }\n\n    /* If Route headers exist, and the first element indicates loose-route,\n     * the URI is taken from the Request-URI, and we keep all existing Route\n     * headers intact.\n     * If Route headers exist, and the first element DOESN'T indicate loose\n     * route, the URI is taken from the first Route header, and remove the\n     * first Route header from the message.\n     * Otherwise if there's no Route headers, the URI is taken from the\n     * Request-URI.\n     */\n    if (topmost_route_uri) {\n\tpj_bool_t has_lr_param;\n\n\tif (PJSIP_URI_SCHEME_IS_SIP(topmost_route_uri) ||\n\t    PJSIP_URI_SCHEME_IS_SIPS(topmost_route_uri))\n\t{\n\t    const pjsip_sip_uri *url = (const pjsip_sip_uri*)\n\t\tpjsip_uri_get_uri((const void*)topmost_route_uri);\n\t    has_lr_param = url->lr_param;\n\t} else {\n\t    has_lr_param = 0;\n\t}\n\n\tif (has_lr_param) {\n\t    new_request_uri = tdata->msg->line.req.uri;\n\t    /* We shouldn't need to delete topmost Route if it has lr param.\n\t     * But seems like it breaks some proxy implementation, so we\n\t     * delete it anyway.\n\t     */\n\t    /*\n\t    pj_list_erase(first_route_hdr);\n\t    if (first_route_hdr == last_route_hdr)\n\t\tlast_route_hdr = NULL;\n\t    */\n\t} else {\n\t    new_request_uri = (const pjsip_uri*) \n\t    \t\t      pjsip_uri_get_uri((pjsip_uri*)topmost_route_uri);\n\t    pj_list_erase(first_route_hdr);\n\t    tdata->saved_strict_route = first_route_hdr;\n\t    if (first_route_hdr == last_route_hdr)\n\t\tfirst_route_hdr = last_route_hdr = NULL;\n\t}\n\n\ttarget_uri = (pjsip_uri*)topmost_route_uri;\n\n    } else {\n\ttarget_uri = new_request_uri = tdata->msg->line.req.uri;\n    }\n\n    /* Fill up the destination host/port from the URI. */\n    status = pjsip_get_dest_info(target_uri, new_request_uri, tdata->pool,\n\t\t\t   \t dest_info);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* If transport selector is set, set destination type accordingly */\n    if (tdata->tp_sel.type != PJSIP_TPSELECTOR_NONE && tdata->tp_sel.u.ptr) {\n\tif (tdata->tp_sel.type == PJSIP_TPSELECTOR_TRANSPORT)\n\t    dest_info->type = tdata->tp_sel.u.transport->key.type;\n\telse if (tdata->tp_sel.type == PJSIP_TPSELECTOR_LISTENER)\n\t    dest_info->type = tdata->tp_sel.u.listener->type;\n    }\n\n    /* If target URI is different than request URI, replace \n     * request URI add put the original URI in the last Route header.\n     */\n    if (new_request_uri && new_request_uri!=tdata->msg->line.req.uri) {\n\tpjsip_route_hdr *route = pjsip_route_hdr_create(tdata->pool);\n\troute->name_addr.uri = (pjsip_uri*) \n\t\t\t       pjsip_uri_get_uri(tdata->msg->line.req.uri);\n\tif (last_route_hdr)\n\t    pj_list_insert_after(last_route_hdr, route);\n\telse\n\t    pjsip_msg_add_hdr(tdata->msg, (pjsip_hdr*)route);\n\ttdata->msg->line.req.uri = (pjsip_uri*)new_request_uri;\n    }\n\n    /* Success. */\n    return PJ_SUCCESS;  \n}\n\n\n/*\n * Swap the request URI and strict route back to the original position\n * before #pjsip_process_route_set() function is called. This function\n * should only used internally by PJSIP client authentication module.\n */\nPJ_DEF(void) pjsip_restore_strict_route_set(pjsip_tx_data *tdata)\n{\n    pjsip_route_hdr *first_route_hdr, *last_route_hdr;\n\n    /* Check if we have found strict route before */\n    if (tdata->saved_strict_route == NULL) {\n\t/* This request doesn't contain strict route */\n\treturn;\n    }\n\n    /* Find the first \"Route\" headers from the message. */\n    first_route_hdr = (pjsip_route_hdr*)\n\t\t      pjsip_msg_find_hdr(tdata->msg, PJSIP_H_ROUTE, NULL);\n\n    if (first_route_hdr == NULL) {\n\t/* User has modified message route? We don't expect this! */\n\tpj_assert(!\"Message route was modified?\");\n\ttdata->saved_strict_route = NULL;\n\treturn;\n    }\n\n    /* Find last Route header */\n    last_route_hdr = first_route_hdr;\n    while (last_route_hdr->next != (void*)&tdata->msg->hdr) {\n\tpjsip_route_hdr *hdr;\n\thdr = (pjsip_route_hdr*)\n\t      pjsip_msg_find_hdr(tdata->msg, PJSIP_H_ROUTE, \n                                 last_route_hdr->next);\n\tif (!hdr)\n\t    break;\n\tlast_route_hdr = hdr;\n    }\n\n    /* Put the last Route header as request URI, delete last Route\n     * header, and insert the saved strict route as the first Route.\n     */\n    tdata->msg->line.req.uri = last_route_hdr->name_addr.uri;\n    pj_list_insert_before(first_route_hdr, tdata->saved_strict_route);\n    pj_list_erase(last_route_hdr);\n\n    /* Reset */\n    tdata->saved_strict_route = NULL;\n}\n\n\n/* Transport callback for sending stateless request. \n * This is one of the most bizzare function in pjsip, so\n * good luck if you happen to debug this function!!\n */\nstatic void stateless_send_transport_cb( void *token,\n\t\t\t\t\t pjsip_tx_data *tdata,\n\t\t\t\t\t pj_ssize_t sent )\n{\n    pjsip_send_state *stateless_data = (pjsip_send_state*) token;\n    pj_status_t need_update_via = PJ_TRUE;\n\n    PJ_UNUSED_ARG(tdata);\n    pj_assert(tdata == stateless_data->tdata);\n\n    for (;;) {\n\tpj_status_t status;\n\tpj_bool_t cont;\n\n\tpj_sockaddr_t *cur_addr;\n\tpjsip_transport_type_e cur_addr_type;\n\tint cur_addr_len;\n\n\tpjsip_via_hdr *via;\n\n\tif (sent == -PJ_EPENDING) {\n\t    /* This is the initial process.\n\t     * When the process started, this function will be called by\n\t     * stateless_send_resolver_callback() with sent argument set to\n\t     * -PJ_EPENDING.\n\t     */\n\t    cont = PJ_TRUE;\n\t} else {\n\t    /* There are two conditions here:\n\t     * (1) Message is sent (i.e. sent > 0),\n\t     * (2) Failure (i.e. sent <= 0)\n\t     */\n\t    cont = (sent > 0) ? PJ_FALSE :\n\t\t   (tdata->dest_info.cur_addr<tdata->dest_info.addr.count-1);\n\t    if (stateless_data->app_cb) {\n\t\t(*stateless_data->app_cb)(stateless_data, sent, &cont);\n\t    } else {\n\t\t/* Doesn't have application callback.\n\t\t * Terminate the process.\n\t\t */\n\t\tcont = PJ_FALSE;\n\t    }\n\t}\n\n\t/* Finished with this transport. */\n\tif (stateless_data->cur_transport) {\n\t    pjsip_transport_dec_ref(stateless_data->cur_transport);\n\t    stateless_data->cur_transport = NULL;\n\t}\n\n\t/* Done if application doesn't want to continue. */\n\tif (sent > 0 || !cont) {\n\t    pjsip_tx_data_dec_ref(tdata);\n\t    return;\n\t}\n\n\t/* Try next address, if any, and only when this is not the \n\t * first invocation. \n\t */\n\tif (sent != -PJ_EPENDING) {\n\t    tdata->dest_info.cur_addr++;\n\t}\n\n\t/* Have next address? */\n\tif (tdata->dest_info.cur_addr >= tdata->dest_info.addr.count) {\n\t    /* This only happens when a rather buggy application has\n\t     * sent 'cont' to PJ_TRUE when the initial value was PJ_FALSE.\n\t     * In this case just stop the processing; we don't need to\n\t     * call the callback again as application has been informed\n\t     * before.\n\t     */\n\t    pjsip_tx_data_dec_ref(tdata);\n\t    return;\n\t}\n\n\t/* Keep current server address information handy. */\n\tcur_addr = &tdata->dest_info.addr.entry[tdata->dest_info.cur_addr].addr;\n\tcur_addr_type = tdata->dest_info.addr.entry[tdata->dest_info.cur_addr].type;\n\tcur_addr_len = tdata->dest_info.addr.entry[tdata->dest_info.cur_addr].addr_len;\n\n\t/* Acquire transport. */\n\tstatus = pjsip_endpt_acquire_transport2(stateless_data->endpt,\n\t\t\t\t\t\tcur_addr_type,\n\t\t\t\t\t\tcur_addr,\n\t\t\t\t\t\tcur_addr_len,\n\t\t\t\t\t\t&tdata->tp_sel,\n\t\t\t\t\t\ttdata,\n\t\t\t\t\t\t&stateless_data->cur_transport);\n\tif (status != PJ_SUCCESS) {\n\t    sent = -status;\n\t    continue;\n\t}\n\n\t/* Modify Via header. */\n\tvia = (pjsip_via_hdr*) pjsip_msg_find_hdr( tdata->msg,\n\t\t\t\t\t\t   PJSIP_H_VIA, NULL);\n\tif (!via) {\n\t    /* Shouldn't happen if request was created with PJSIP API! \n\t     * But we handle the case anyway for robustness.\n\t     */\n\t    pj_assert(!\"Via header not found!\");\n\t    via = pjsip_via_hdr_create(tdata->pool);\n\t    pjsip_msg_insert_first_hdr(tdata->msg, (pjsip_hdr*)via);\n\t}\n\n\tif (tdata->msg->line.req.method.id == PJSIP_CANCEL_METHOD) {\n\t    if (via->sent_by.host.slen > 0) {\n\t\t/* Don't update Via header on a CANCEL request if the sent-by\n\t\t * parameter is already set since it needs to match the \n\t\t * original request. */\n\t\tneed_update_via = PJ_FALSE;\n\t    }\n\t}\n\n\tif (via->branch_param.slen == 0) {\n\t    pj_str_t tmp;\n\t    via->branch_param.ptr = (char*)pj_pool_alloc(tdata->pool,\n\t\t\t\t\t\t  \t PJSIP_MAX_BRANCH_LEN);\n\t    via->branch_param.slen = PJSIP_MAX_BRANCH_LEN;\n\t    pj_memcpy(via->branch_param.ptr, PJSIP_RFC3261_BRANCH_ID,\n\t\t      PJSIP_RFC3261_BRANCH_LEN);\n\t    tmp.ptr = via->branch_param.ptr + PJSIP_RFC3261_BRANCH_LEN + 2;\n\t    *(tmp.ptr-2) = 80; *(tmp.ptr-1) = 106;\n\t    pj_generate_unique_string(&tmp);\n\t}\n\n\tif (need_update_via) {\n\t    via->transport = pj_str(stateless_data->cur_transport->type_name);\n\n\t    if (tdata->via_addr.host.slen > 0 &&\n\t\t(!tdata->via_tp ||\n\t\t tdata->via_tp == (void *)stateless_data->cur_transport))\n\t    {\n\t\tvia->sent_by = tdata->via_addr;\n\n\t\t/* Better also update tdata via_tp, e.g: CANCEL may need to\n\t\t * refer to original INVITE tdata.\n\t\t */\n\t\ttdata->via_tp = stateless_data->cur_transport;\n\t    } else {\n\t\tvia->sent_by = stateless_data->cur_transport->local_name;\n\n\t\t/* Better also update tdata via_tp & via_addr, e.g: CANCEL\n\t\t * may need to refer to original INVITE tdata.\n\t\t */\n\t\ttdata->via_tp = stateless_data->cur_transport;\n\t\ttdata->via_addr = via->sent_by;\n\t    }\n\t    \n\t    via->rport_param = pjsip_cfg()->endpt.disable_rport ? -1 : 0;\n\n\t    /* Add/remove \"alias\" param to/from Via header on connection \n\t     * oriented/less transport, if configured.\n\t     */\n\t    if (pjsip_cfg()->endpt.req_has_via_alias &&\n\t\ttdata->msg->type == PJSIP_REQUEST_MSG)\n\t    {\n\t\tconst pj_str_t ALIAS_STR = {\"alias\", 5};\n\t\tpjsip_param *alias_param;\n\t\tpj_bool_t is_datagram;\n\n\t\talias_param = pjsip_param_find(&via->other_param, &ALIAS_STR);\n\t\tis_datagram = (stateless_data->cur_transport->flag & \n\t\t\t       PJSIP_TRANSPORT_DATAGRAM);\n\t\tif (!is_datagram && !alias_param) {\n\t\t    alias_param = PJ_POOL_ZALLOC_T(tdata->pool, pjsip_param);\n\t\t    alias_param->name = ALIAS_STR;\n\t\t    pj_list_push_back(&via->other_param, alias_param);\n\t\t} else if (is_datagram && alias_param) {\n\t\t    pj_list_erase(alias_param);\n\t\t}\n\t    }\n\t}\n\n\tpjsip_tx_data_invalidate_msg(tdata);\n\n\t/* Send message using this transport. */\n\tstatus = pjsip_transport_send( stateless_data->cur_transport,\n\t\t\t\t       tdata,\n\t\t\t\t       cur_addr,\n\t\t\t\t       cur_addr_len,\n\t\t\t\t       stateless_data,\n\t\t\t\t       &stateless_send_transport_cb);\n\tif (status == PJ_SUCCESS) {\n\t    /* Recursively call this function. */\n\t    sent = tdata->buf.cur - tdata->buf.start;\n\t    stateless_send_transport_cb( stateless_data, tdata, sent );\n\t    return;\n\t} else if (status == PJ_EPENDING) {\n\t    /* This callback will be called later. */\n\t    return;\n\t} else {\n\t    /* Recursively call this function. */\n\t    sent = -status;\n\t    stateless_send_transport_cb( stateless_data, tdata, sent );\n\t    return;\n\t}\n    }\n\n}\n\n/* Resolver callback for sending stateless request. */\nstatic void \nstateless_send_resolver_callback( pj_status_t status,\n\t\t\t\t  void *token,\n\t\t\t\t  const struct pjsip_server_addresses *addr)\n{\n    pjsip_send_state *stateless_data = (pjsip_send_state*) token;\n    pjsip_tx_data *tdata = stateless_data->tdata;\n\n    /* Fail on server resolution. */\n    if (status != PJ_SUCCESS) {\n\tif (stateless_data->app_cb) {\n\t    pj_bool_t cont = PJ_FALSE;\n\t    (*stateless_data->app_cb)(stateless_data, -status, &cont);\n\t}\n\tpjsip_tx_data_dec_ref(tdata);\n\treturn;\n    }\n\n    /* Copy server addresses */\n    if (addr && addr != &tdata->dest_info.addr) {\n\tpj_memcpy( &tdata->dest_info.addr, addr, \n\t           sizeof(pjsip_server_addresses));\n    }\n    pj_assert(tdata->dest_info.addr.count != 0);\n\n    /* RFC 3261 section 18.1.1:\n     * If a request is within 200 bytes of the path MTU, or if it is larger\n     * than 1300 bytes and the path MTU is unknown, the request MUST be sent\n     * using an RFC 2914 [43] congestion controlled transport protocol, such\n     * as TCP.\n     */\n    if (pjsip_cfg()->endpt.disable_tcp_switch==0 &&\n\ttdata->msg->type == PJSIP_REQUEST_MSG &&\n\ttdata->dest_info.addr.count > 0 && \n\ttdata->dest_info.addr.entry[0].type == PJSIP_TRANSPORT_UDP)\n    {\n\tint len;\n\n\t/* Encode the request */\n\tstatus = pjsip_tx_data_encode(tdata);\n\tif (status != PJ_SUCCESS) {\n\t    if (stateless_data->app_cb) {\n\t\tpj_bool_t cont = PJ_FALSE;\n\t\t(*stateless_data->app_cb)(stateless_data, -status, &cont);\n\t    }\n\t    pjsip_tx_data_dec_ref(tdata);\n\t    return;\n\t}\n\n\t/* Check if request message is larger than 1300 bytes. */\n\tlen = (int)(tdata->buf.cur - tdata->buf.start);\n\tif (len >= PJSIP_UDP_SIZE_THRESHOLD) {\n\t    int i;\n\t    int count = tdata->dest_info.addr.count;\n\n\t    PJ_LOG(5,(THIS_FILE, \"%s exceeds UDP size threshold (%u), \"\n\t\t\t\t \"sending with TCP\",\n\t\t\t\t pjsip_tx_data_get_info(tdata),\n\t\t\t\t PJSIP_UDP_SIZE_THRESHOLD));\n\n\t    /* Insert \"TCP version\" of resolved UDP addresses at the\n\t     * beginning.\n\t     */\n\t    if (count * 2 > PJSIP_MAX_RESOLVED_ADDRESSES)\n\t\tcount = PJSIP_MAX_RESOLVED_ADDRESSES / 2;\n\t    for (i = 0; i < count; ++i) {\n\t\tpj_memcpy(&tdata->dest_info.addr.entry[i+count],\n\t\t\t  &tdata->dest_info.addr.entry[i],\n\t\t\t  sizeof(tdata->dest_info.addr.entry[0]));\n\t\ttdata->dest_info.addr.entry[i].type = PJSIP_TRANSPORT_TCP;\n\t    }\n\t    tdata->dest_info.addr.count = count * 2;\n\t}\n    }\n\n    /* Process the addresses. */\n    stateless_send_transport_cb( stateless_data, tdata, -PJ_EPENDING);\n}\n\n/*\n * Send stateless request.\n * The sending process consists of several stages:\n *  - determine which host to contact (#pjsip_get_request_addr).\n *  - resolve the host (#pjsip_endpt_resolve)\n *  - establish transport (#pjsip_endpt_acquire_transport)\n *  - send the message (#pjsip_transport_send)\n */\nPJ_DEF(pj_status_t) pjsip_endpt_send_request_stateless(pjsip_endpoint *endpt, \n\t\t\t\t   pjsip_tx_data *tdata,\n\t\t\t\t   void *token,\n\t\t\t\t   pjsip_send_callback cb)\n{\n    pjsip_host_info dest_info;\n    pjsip_send_state *stateless_data;\n    pj_status_t status;\n\n    PJ_ASSERT_RETURN(endpt && tdata, PJ_EINVAL);\n\n    /* Get destination name to contact. */\n    status = pjsip_process_route_set(tdata, &dest_info);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Keep stateless data. */\n    stateless_data = PJ_POOL_ZALLOC_T(tdata->pool, pjsip_send_state);\n    stateless_data->token = token;\n    stateless_data->endpt = endpt;\n    stateless_data->tdata = tdata;\n    stateless_data->app_cb = cb;\n\n    /* If destination info has not been initialized (this applies for most\n     * all requests except CANCEL), resolve destination host. The processing\n     * then resumed when the resolving callback is called. For CANCEL, the\n     * destination info must have been copied from the original INVITE so\n     * proceed to sending the request directly.\n     */\n    if (tdata->dest_info.addr.count == 0) {\n\t/* Copy the destination host name to TX data */\n\tif (!tdata->dest_info.name.slen) {\n\t    pj_strdup(tdata->pool, &tdata->dest_info.name,\n\t    \t      &dest_info.addr.host);\n\t}\n\n\tpjsip_endpt_resolve( endpt, tdata->pool, &dest_info, stateless_data,\n\t\t\t     &stateless_send_resolver_callback);\n    } else {\n\tPJ_LOG(5,(THIS_FILE, \"%s: skipping target resolution because \"\n\t                     \"address is already set\",\n\t\t\t     pjsip_tx_data_get_info(tdata)));\n\tstateless_send_resolver_callback(PJ_SUCCESS, stateless_data,\n\t\t\t\t\t &tdata->dest_info.addr);\n    }\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Send raw data to a destination.\n */\nPJ_DEF(pj_status_t) pjsip_endpt_send_raw( pjsip_endpoint *endpt,\n\t\t\t\t\t  pjsip_transport_type_e tp_type,\n\t\t\t\t\t  const pjsip_tpselector *sel,\n\t\t\t\t\t  const void *raw_data,\n\t\t\t\t\t  pj_size_t data_len,\n\t\t\t\t\t  const pj_sockaddr_t *addr,\n\t\t\t\t\t  int addr_len,\n\t\t\t\t\t  void *token,\n\t\t\t\t\t  pjsip_tp_send_callback cb)\n{\n    return pjsip_tpmgr_send_raw(pjsip_endpt_get_tpmgr(endpt), tp_type, sel,\n\t\t\t\tNULL, raw_data, data_len, addr, addr_len,\n\t\t\t\ttoken, cb);\n}\n\n\n/* Callback data for sending raw data */\nstruct send_raw_data\n{\n    pjsip_endpoint\t    *endpt;\n    pjsip_tx_data\t    *tdata;\n    pjsip_tpselector\t    *sel;\n    void\t\t    *app_token;\n    pjsip_tp_send_callback   app_cb;\n};\n\n\n/* Resolver callback for sending raw data. */\nstatic void send_raw_resolver_callback( pj_status_t status,\n    \t\t\t\t\tvoid *token,\n\t\t\t\t\tconst pjsip_server_addresses *addr)\n{\n    struct send_raw_data *sraw_data = (struct send_raw_data*) token;\n\n    if (status != PJ_SUCCESS) {\n\tif (sraw_data->app_cb) {\n\t    (*sraw_data->app_cb)(sraw_data->app_token, sraw_data->tdata,\n\t\t\t\t -status);\n\t}\n    } else {\n\tpj_size_t data_len;\n\n\tpj_assert(addr->count != 0);\n\n\t/* Avoid tdata destroyed by pjsip_tpmgr_send_raw(). */\n\tpjsip_tx_data_add_ref(sraw_data->tdata);\n\n\tdata_len = sraw_data->tdata->buf.cur - sraw_data->tdata->buf.start;\n\tstatus = pjsip_tpmgr_send_raw(pjsip_endpt_get_tpmgr(sraw_data->endpt),\n\t\t\t\t      addr->entry[0].type,\n\t\t\t\t      sraw_data->sel, sraw_data->tdata,\n\t\t\t\t      sraw_data->tdata->buf.start, data_len,\n\t\t\t\t      &addr->entry[0].addr, \n\t\t\t\t      addr->entry[0].addr_len, \n\t\t\t\t      sraw_data->app_token,\n\t\t\t\t      sraw_data->app_cb);\n\tif (status == PJ_SUCCESS) {\n\t    (*sraw_data->app_cb)(sraw_data->app_token, sraw_data->tdata,\n\t\t\t\t data_len);\n\t} else if (status != PJ_EPENDING) {\n\t    (*sraw_data->app_cb)(sraw_data->app_token, sraw_data->tdata,\n\t\t\t\t -status);\n\t}\n    }\n\n    if (sraw_data->sel) {\n\tpjsip_tpselector_dec_ref(sraw_data->sel);\n    }\n    pjsip_tx_data_dec_ref(sraw_data->tdata);\n}\n\n\n/*\n * Send raw data to the specified destination URI. \n */\nPJ_DEF(pj_status_t) pjsip_endpt_send_raw_to_uri(pjsip_endpoint *endpt,\n\t\t\t\t\t\tconst pj_str_t *p_dst_uri,\n\t\t\t\t\t\tconst pjsip_tpselector *sel,\n\t\t\t\t\t\tconst void *raw_data,\n\t\t\t\t\t\tpj_size_t data_len,\n\t\t\t\t\t\tvoid *token,\n\t\t\t\t\t\tpjsip_tp_send_callback cb)\n{\n    pjsip_tx_data *tdata;\n    struct send_raw_data *sraw_data;\n    pj_str_t dst_uri;\n    pjsip_uri *uri;\n    pjsip_host_info dest_info;\n    pj_status_t status;\n\n    /* Allocate buffer */\n    status = pjsip_endpt_create_tdata(endpt, &tdata);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    pjsip_tx_data_add_ref(tdata);\n\n    /* Duplicate URI since parser requires URI to be NULL terminated */\n    pj_strdup_with_null(tdata->pool, &dst_uri, p_dst_uri);\n\n    /* Parse URI */\n    uri = pjsip_parse_uri(tdata->pool, dst_uri.ptr, dst_uri.slen, 0);\n    if (uri == NULL) {\n\tpjsip_tx_data_dec_ref(tdata);\n\treturn PJSIP_EINVALIDURI;\n    }\n\n    /* Build destination info. */\n    status = pjsip_get_dest_info(uri, NULL, tdata->pool, &dest_info);\n    if (status != PJ_SUCCESS) {\n\tpjsip_tx_data_dec_ref(tdata);\n\treturn status;\n    }\n\n    /* Copy data (note: data_len may be zero!) */\n    tdata->buf.start = (char*) pj_pool_alloc(tdata->pool, data_len+1);\n    tdata->buf.end = tdata->buf.start + data_len + 1;\n    if (data_len)\n\tpj_memcpy(tdata->buf.start, raw_data, data_len);\n    tdata->buf.cur = tdata->buf.start + data_len;\n\n    /* Init send_raw_data */\n    sraw_data = PJ_POOL_ZALLOC_T(tdata->pool, struct send_raw_data);\n    sraw_data->endpt = endpt;\n    sraw_data->tdata = tdata;\n    sraw_data->app_token = token;\n    sraw_data->app_cb = cb;\n\n    if (sel) {\n\tsraw_data->sel = PJ_POOL_ALLOC_T(tdata->pool, pjsip_tpselector);\n\tpj_memcpy(sraw_data->sel, sel, sizeof(pjsip_tpselector));\n\tpjsip_tpselector_add_ref(sraw_data->sel);\n    }\n\n    /* Copy the destination host name to TX data */\n    pj_strdup(tdata->pool, &tdata->dest_info.name, &dest_info.addr.host);\n\n    /* Resolve destination host.\n     * The processing then resumed when the resolving callback is called.\n     */\n    pjsip_endpt_resolve( endpt, tdata->pool, &dest_info, sraw_data,\n\t\t\t &send_raw_resolver_callback);\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Determine which address (and transport) to use to send response message\n * based on the received request. This function follows the specification\n * in section 18.2.2 of RFC 3261 and RFC 3581 for calculating the destination\n * address and transport.\n */\nPJ_DEF(pj_status_t) pjsip_get_response_addr( pj_pool_t *pool,\n\t\t\t\t\t     pjsip_rx_data *rdata,\n\t\t\t\t\t     pjsip_response_addr *res_addr )\n{\n    pjsip_transport *src_transport = rdata->tp_info.transport;\n\n    /* Check arguments. */\n    PJ_ASSERT_RETURN(pool && rdata && res_addr, PJ_EINVAL);\n\n    /* rdata must be a request message! */\n    PJ_ASSERT_RETURN(rdata->msg_info.msg->type == PJSIP_REQUEST_MSG,\n\t\t     PJ_EINVAL);\n\n    /* All requests must have \"received\" parameter.\n     * This must always be done in transport layer.\n     */\n    pj_assert(rdata->msg_info.via->recvd_param.slen != 0);\n\n    /* Do the calculation based on RFC 3261 Section 18.2.2 and RFC 3581 */\n\n    if (PJSIP_TRANSPORT_IS_RELIABLE(src_transport)) {\n\t/* For reliable protocol such as TCP or SCTP, or TLS over those, the\n\t * response MUST be sent using the existing connection to the source\n\t * of the original request that created the transaction, if that \n\t * connection is still open. \n\t * If that connection is no longer open, the server SHOULD open a \n\t * connection to the IP address in the received parameter, if present,\n\t * using the port in the sent-by value, or the default port for that \n\t * transport, if no port is specified. \n\t * If that connection attempt fails, the server SHOULD use the \n\t * procedures in [4] for servers in order to determine the IP address\n\t * and port to open the connection and send the response to.\n\t */\n\tres_addr->transport = rdata->tp_info.transport;\n\tpj_memcpy(&res_addr->addr, &rdata->pkt_info.src_addr,\n\t\t  rdata->pkt_info.src_addr_len);\n\tres_addr->addr_len = rdata->pkt_info.src_addr_len;\n\tres_addr->dst_host.type=(pjsip_transport_type_e)src_transport->key.type;\n\tres_addr->dst_host.flag = src_transport->flag;\n\tpj_strdup( pool, &res_addr->dst_host.addr.host, \n\t\t   &rdata->msg_info.via->recvd_param);\n\tres_addr->dst_host.addr.port = rdata->msg_info.via->sent_by.port;\n\tif (res_addr->dst_host.addr.port == 0) {\n\t    res_addr->dst_host.addr.port = \n\t\tpjsip_transport_get_default_port_for_type(res_addr->dst_host.type);\n\t}\n\n    } else if (rdata->msg_info.via->maddr_param.slen) {\n\t/* Otherwise, if the Via header field value contains a maddr parameter,\n\t * the response MUST be forwarded to the address listed there, using \n\t * the port indicated in sent-by, or port 5060 if none is present. \n\t * If the address is a multicast address, the response SHOULD be sent \n\t * using the TTL indicated in the ttl parameter, or with a TTL of 1 if\n\t * that parameter is not present. \n\t */\n\tres_addr->transport = NULL;\n\tres_addr->dst_host.type=(pjsip_transport_type_e)src_transport->key.type;\n\tres_addr->dst_host.flag = src_transport->flag;\n\tpj_strdup( pool, &res_addr->dst_host.addr.host, \n\t\t   &rdata->msg_info.via->maddr_param);\n\tres_addr->dst_host.addr.port = rdata->msg_info.via->sent_by.port;\n\tif (res_addr->dst_host.addr.port == 0)\n\t    res_addr->dst_host.addr.port = 5060;\n\n    } else if (rdata->msg_info.via->rport_param >= 0) {\n\t/* There is both a \"received\" parameter and an \"rport\" parameter, \n\t * the response MUST be sent to the IP address listed in the \"received\"\n\t * parameter, and the port in the \"rport\" parameter. \n\t * The response MUST be sent from the same address and port that the \n\t * corresponding request was received on.\n\t */\n\tres_addr->transport = rdata->tp_info.transport;\n\tpj_memcpy(&res_addr->addr, &rdata->pkt_info.src_addr,\n\t\t  rdata->pkt_info.src_addr_len);\n\tres_addr->addr_len = rdata->pkt_info.src_addr_len;\n\tres_addr->dst_host.type=(pjsip_transport_type_e)src_transport->key.type;\n\tres_addr->dst_host.flag = src_transport->flag;\n\tpj_strdup( pool, &res_addr->dst_host.addr.host, \n\t\t   &rdata->msg_info.via->recvd_param);\n\tres_addr->dst_host.addr.port = rdata->msg_info.via->sent_by.port;\n\tif (res_addr->dst_host.addr.port == 0) {\n\t    res_addr->dst_host.addr.port = \n\t\tpjsip_transport_get_default_port_for_type(res_addr->dst_host.type);\n\t}\n\n    } else {\n\tres_addr->transport = NULL;\n\tres_addr->dst_host.type=(pjsip_transport_type_e)src_transport->key.type;\n\tres_addr->dst_host.flag = src_transport->flag;\n\tpj_strdup( pool, &res_addr->dst_host.addr.host, \n\t\t   &rdata->msg_info.via->recvd_param);\n\tres_addr->dst_host.addr.port = rdata->msg_info.via->sent_by.port;\n\tif (res_addr->dst_host.addr.port == 0) {\n\t    res_addr->dst_host.addr.port = \n\t\tpjsip_transport_get_default_port_for_type(res_addr->dst_host.type);\n\t}\n    }\n\n    return PJ_SUCCESS;\n}\n\n/*\n * Callback called by transport during send_response.\n */\nstatic void send_response_transport_cb(void *token, pjsip_tx_data *tdata,\n\t\t\t\t       pj_ssize_t sent)\n{\n    pjsip_send_state *send_state = (pjsip_send_state*) token;\n    pj_bool_t cont = PJ_FALSE;\n\n    /* Call callback, if any. */\n    if (send_state->app_cb)\n\t(*send_state->app_cb)(send_state, sent, &cont);\n\n    /* Decrement transport reference counter. */\n    pjsip_transport_dec_ref(send_state->cur_transport);\n\n    /* Decrement transmit data ref counter. */\n    pjsip_tx_data_dec_ref(tdata);\n}\n\n/*\n * Resolver calback during send_response.\n */\nstatic void send_response_resolver_cb( pj_status_t status, void *token,\n\t\t\t\t       const pjsip_server_addresses *addr )\n{\n    pjsip_send_state *send_state = (pjsip_send_state*) token;\n\n    if (status != PJ_SUCCESS) {\n\tif (send_state->app_cb) {\n\t    pj_bool_t cont = PJ_FALSE;\n\t    (*send_state->app_cb)(send_state, -status, &cont);\n\t}\n\tpjsip_tx_data_dec_ref(send_state->tdata);\n\treturn;\n    }\n\n    /* Only handle the first address resolved. */\n\n    /* Acquire transport. */\n    status = pjsip_endpt_acquire_transport2(send_state->endpt, \n\t\t\t\t\t    addr->entry[0].type,\n\t\t\t\t\t    &addr->entry[0].addr,\n\t\t\t\t\t    addr->entry[0].addr_len,\n\t\t\t\t\t    &send_state->tdata->tp_sel,\n\t\t\t\t\t    send_state->tdata,\n\t\t\t\t\t    &send_state->cur_transport);\n    if (status != PJ_SUCCESS) {\n\tif (send_state->app_cb) {\n\t    pj_bool_t cont = PJ_FALSE;\n\t    (*send_state->app_cb)(send_state, -status, &cont);\n\t}\n\tpjsip_tx_data_dec_ref(send_state->tdata);\n\treturn;\n    }\n\n    /* Update address in send_state. */\n    pj_memcpy(&send_state->tdata->dest_info.addr, addr, sizeof(*addr));\n\n    /* Send response using the transoprt. */\n    status = pjsip_transport_send( send_state->cur_transport, \n\t\t\t\t   send_state->tdata,\n\t\t\t\t   &addr->entry[0].addr,\n\t\t\t\t   addr->entry[0].addr_len,\n\t\t\t\t   send_state,\n\t\t\t\t   &send_response_transport_cb);\n    if (status == PJ_SUCCESS) {\n\tpj_ssize_t sent = send_state->tdata->buf.cur - \n\t\t\t  send_state->tdata->buf.start;\n\tsend_response_transport_cb(send_state, send_state->tdata, sent);\n\n    } else if (status == PJ_EPENDING) {\n\t/* Transport callback will be called later. */\n    } else {\n\tsend_response_transport_cb(send_state, send_state->tdata, -status);\n    }\n}\n\n/*\n * Send response.\n */\nPJ_DEF(pj_status_t) pjsip_endpt_send_response( pjsip_endpoint *endpt,\n\t\t\t\t\t       pjsip_response_addr *res_addr,\n\t\t\t\t\t       pjsip_tx_data *tdata,\n\t\t\t\t\t       void *token,\n\t\t\t\t\t       pjsip_send_callback cb)\n{\n    /* Determine which transports and addresses to send the response,\n     * based on Section 18.2.2 of RFC 3261.\n     */\n    pjsip_send_state *send_state;\n    pj_status_t status;\n\n    /* Create structure to keep the sending state. */\n    send_state = PJ_POOL_ZALLOC_T(tdata->pool, pjsip_send_state);\n    send_state->endpt = endpt;\n    send_state->tdata = tdata;\n    send_state->token = token;\n    send_state->app_cb = cb;\n\n    if (res_addr->transport != NULL) {\n\tsend_state->cur_transport = res_addr->transport;\n\tpjsip_transport_add_ref(send_state->cur_transport);\n\n\tstatus = pjsip_transport_send( send_state->cur_transport, tdata, \n\t\t\t\t       &res_addr->addr,\n\t\t\t\t       res_addr->addr_len,\n\t\t\t\t       send_state,\n\t\t\t\t       &send_response_transport_cb );\n\tif (status == PJ_SUCCESS) {\n\t    pj_ssize_t sent = tdata->buf.cur - tdata->buf.start;\n\t    send_response_transport_cb(send_state, tdata, sent);\n\t    return PJ_SUCCESS;\n\t} else if (status == PJ_EPENDING) {\n\t    /* Callback will be called later. */\n\t    return PJ_SUCCESS;\n\t} else {\n\t    pjsip_transport_dec_ref(send_state->cur_transport);\n\t    return status;\n\t}\n    } else {\n\t/* Copy the destination host name to TX data */\n\tif (!tdata->dest_info.name.slen) {\n\t    pj_strdup(tdata->pool, &tdata->dest_info.name, \n\t\t      &res_addr->dst_host.addr.host);\n\t}\n\n\tpjsip_endpt_resolve(endpt, tdata->pool, &res_addr->dst_host, \n\t\t\t    send_state, &send_response_resolver_cb);\n\treturn PJ_SUCCESS;\n    }\n}\n\n/*\n * Send response combo\n */\nPJ_DEF(pj_status_t) pjsip_endpt_send_response2( pjsip_endpoint *endpt,\n\t\t\t\t\t        pjsip_rx_data *rdata,\n\t\t\t\t\t        pjsip_tx_data *tdata,\n\t\t\t\t\t\tvoid *token,\n\t\t\t\t\t\tpjsip_send_callback cb)\n{\n    pjsip_response_addr res_addr;\n    pj_status_t status;\n\n    status = pjsip_get_response_addr(tdata->pool, rdata, &res_addr);\n    if (status != PJ_SUCCESS) {\n\tpjsip_tx_data_dec_ref(tdata);\n\treturn PJ_SUCCESS;\n    }\n\n    status = pjsip_endpt_send_response(endpt, &res_addr, tdata, token, cb);\n    return status;\n}\n\n\n/*\n * Send response\n */\nPJ_DEF(pj_status_t) pjsip_endpt_respond_stateless( pjsip_endpoint *endpt,\n\t\t\t\t\t\t   pjsip_rx_data *rdata,\n\t\t\t\t\t\t   int st_code,\n\t\t\t\t\t\t   const pj_str_t *st_text,\n\t\t\t\t\t\t   const pjsip_hdr *hdr_list,\n\t\t\t\t\t\t   const pjsip_msg_body *body)\n{\n    pj_status_t status;\n    pjsip_response_addr res_addr;\n    pjsip_tx_data *tdata;\n\n    /* Verify arguments. */\n    PJ_ASSERT_RETURN(endpt && rdata, PJ_EINVAL);\n    PJ_ASSERT_RETURN(rdata->msg_info.msg->type == PJSIP_REQUEST_MSG,\n\t\t     PJSIP_ENOTREQUESTMSG);\n\n    /* Check that no UAS transaction has been created for this request. \n     * If UAS transaction has been created for this request, application\n     * MUST send the response statefully using that transaction.\n     */\n    PJ_ASSERT_RETURN(pjsip_rdata_get_tsx(rdata)==NULL, PJ_EINVALIDOP);\n\n    /* Create response message */\n    status = pjsip_endpt_create_response( endpt, rdata, st_code, st_text, \n\t\t\t\t\t  &tdata);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Add the message headers, if any */\n    if (hdr_list) {\n\tconst pjsip_hdr *hdr = hdr_list->next;\n\twhile (hdr != hdr_list) {\n\t    pjsip_msg_add_hdr(tdata->msg, \n\t    \t\t      (pjsip_hdr*) pjsip_hdr_clone(tdata->pool, hdr) );\n\t    hdr = hdr->next;\n\t}\n    }\n\n    /* Add the message body, if any. */\n    if (body) {\n\ttdata->msg->body = pjsip_msg_body_clone( tdata->pool, body );\n\tif (tdata->msg->body == NULL) {\n\t    pjsip_tx_data_dec_ref(tdata);\n\t    return status;\n\t}\n    }\n\n    /* Get where to send request. */\n    status = pjsip_get_response_addr( tdata->pool, rdata, &res_addr );\n    if (status != PJ_SUCCESS) {\n\tpjsip_tx_data_dec_ref(tdata);\n\treturn status;\n    }\n\n    /* Send! */\n    status = pjsip_endpt_send_response( endpt, &res_addr, tdata, NULL, NULL );\n    if (status != PJ_SUCCESS) {\n\tpjsip_tx_data_dec_ref(tdata);\n\treturn status;\n    }\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Get the event string from the event ID.\n */\nPJ_DEF(const char *) pjsip_event_str(pjsip_event_id_e e)\n{\n    return event_str[e];\n}\n\n"], "filenames": ["pjsip/include/pjsip/sip_dialog.h", "pjsip/src/pjsip/sip_dialog.c", "pjsip/src/pjsip/sip_transport.c", "pjsip/src/pjsip/sip_util.c"], "buggy_code_start_loc": [167, 469, 2337, 1420], "buggy_code_end_loc": [167, 1824, 2337, 1815], "fixing_code_start_loc": [168, 470, 2338, 1420], "fixing_code_end_loc": [169, 1840, 2351, 1820], "type": "CWE-295", "message": "PJSIP is a free and open source multimedia communication library written in C language implementing standard based protocols such as SIP, SDP, RTP, STUN, TURN, and ICE. In version 2.10 and earlier, PJSIP transport can be reused if they have the same IP address + port + protocol. However, this is insufficient for secure transport since it lacks remote hostname authentication. Suppose we have created a TLS connection to `sip.foo.com`, which has an IP address `100.1.1.1`. If we want to create a TLS connection to another hostname, say `sip.bar.com`, which has the same IP address, then it will reuse that existing connection, even though `100.1.1.1` does not have certificate to authenticate as `sip.bar.com`. The vulnerability allows for an insecure interaction without user awareness. It affects users who need access to connections to different destinations that translate to the same address, and allows man-in-the-middle attack if attacker can route a connection to another destination such as in the case of DNS spoofing.", "other": {"cve": {"id": "CVE-2020-15260", "sourceIdentifier": "security-advisories@github.com", "published": "2021-03-10T23:15:12.300", "lastModified": "2022-07-22T12:49:27.930", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "PJSIP is a free and open source multimedia communication library written in C language implementing standard based protocols such as SIP, SDP, RTP, STUN, TURN, and ICE. In version 2.10 and earlier, PJSIP transport can be reused if they have the same IP address + port + protocol. However, this is insufficient for secure transport since it lacks remote hostname authentication. Suppose we have created a TLS connection to `sip.foo.com`, which has an IP address `100.1.1.1`. If we want to create a TLS connection to another hostname, say `sip.bar.com`, which has the same IP address, then it will reuse that existing connection, even though `100.1.1.1` does not have certificate to authenticate as `sip.bar.com`. The vulnerability allows for an insecure interaction without user awareness. It affects users who need access to connections to different destinations that translate to the same address, and allows man-in-the-middle attack if attacker can route a connection to another destination such as in the case of DNS spoofing."}, {"lang": "es", "value": "PJSIP es una biblioteca de comunicaci\u00f3n multimedia de c\u00f3digo abierto y gratuita escrita en lenguaje C que implementa protocolos basados ??en est\u00e1ndares como SIP, SDP, RTP, STUN, TURN e ICE.&#xa0;En la versi\u00f3n 2.10 y anteriores, el transporte de PJSIP puede ser reutilizado si presentan la misma direcci\u00f3n IP + puerto + protocolo.&#xa0;Sin embargo, esto es insuficiente para un transporte seguro, ya que carece de autenticaci\u00f3n de nombre de host remoto.&#xa0;Supongamos que hemos creado una conexi\u00f3n TLS a \"sip.foo.com\", que presenta una direcci\u00f3n IP \"100.1.1.1\".&#xa0;Si queremos crear una conexi\u00f3n TLS para otro nombre de host, digamos \"sip.bar.com\", que presenta la misma direcci\u00f3n IP, entonces reutilizar\u00e1 esa conexi\u00f3n existente, aunque \"100.1.1.1\" no tenga certificado para autenticarse como \"sip.bar.com\".&#xa0;La vulnerabilidad permite una interacci\u00f3n no segura sin que el usuario se d\u00e9 cuenta. Afecta a usuarios que necesitan acceso a conexiones a diferentes destinos que se traducen en la misma direcci\u00f3n y permite un ataque de tipo man-in-the-middle si el atacante puede enrutar una conexi\u00f3n a otro destino, como en el caso de la suplantaci\u00f3n de DNS"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:C/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 6.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 4.0}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:C/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 6.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 4.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-295"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-297"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:teluu:pjsip:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.10", "matchCriteriaId": "107D71AA-CD87-4682-B600-D583CB865E6F"}]}]}], "references": [{"url": "https://github.com/pjsip/pjproject/commit/67e46c1ac45ad784db5b9080f5ed8b133c122872", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/pjsip/pjproject/pull/2663", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/pjsip/pjproject/security/advisories/GHSA-8hcp-hm38-mfph", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202107-42", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/pjsip/pjproject/commit/67e46c1ac45ad784db5b9080f5ed8b133c122872"}}