{"buggy_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2023\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISO Media File Format sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/internal/isomedia_dev.h>\n\n#ifndef GPAC_DISABLE_ISOM\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\nGF_TrackExtendsBox *GetTrex(GF_MovieBox *moov, GF_ISOTrackID TrackID)\n{\n\tu32 i;\n\tGF_TrackExtendsBox *trex;\n\ti=0;\n\twhile ((trex = (GF_TrackExtendsBox *)gf_list_enum(moov->mvex->TrackExList, &i))) {\n\t\tif (trex->trackID == TrackID) return trex;\n\t}\n\treturn NULL;\n}\n\n\nGF_TrackFragmentBox *gf_isom_get_traf(GF_ISOFile *mov, GF_ISOTrackID TrackID)\n{\n\tu32 i;\n\tif (!mov->moof) return NULL;\n\n\t//reverse browse the TRAFs, as there may be more than one per track ...\n\tfor (i=gf_list_count(mov->moof->TrackList); i>0; i--) {\n\t\tGF_TrackFragmentBox *traf = (GF_TrackFragmentBox *)gf_list_get(mov->moof->TrackList, i-1);\n\t\tif (traf->tfhd->trackID == TrackID) return traf;\n\t}\n\treturn NULL;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err gf_isom_set_movie_duration(GF_ISOFile *movie, u64 duration, Bool remove_mehd)\n{\n\tif (!movie || !movie->moov || !movie->moov->mvex) return GF_BAD_PARAM;\n\n\tif (remove_mehd) {\n\t\tif (!movie->moov->mvex->mehd) {\n\t\t\tgf_isom_box_del_parent(&movie->moov->mvex->child_boxes, (GF_Box*)movie->moov->mvex->mehd);\n\t\t\tmovie->moov->mvex->mehd = NULL;\n\t\t}\n\t} else {\n\t\tif (!movie->moov->mvex->mehd) {\n\t\t\tmovie->moov->mvex->mehd = (GF_MovieExtendsHeaderBox *) gf_isom_box_new_parent(&movie->moov->mvex->child_boxes, GF_ISOM_BOX_TYPE_MEHD);\n\t\t\tif (!movie->moov->mvex->mehd) return GF_OUT_OF_MEM;\n\t\t}\n\t\tmovie->moov->mvex->mehd->fragment_duration = duration;\n\t}\n\tmovie->moov->mvhd->duration = 0;\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_finalize_for_fragment(GF_ISOFile *movie, u32 media_segment_type, Bool mvex_after_tracks)\n{\n\tGF_Err e;\n\tu32 i;\n\tBool store_file = GF_TRUE;\n\tGF_TrackExtendsBox *trex;\n\tif (!movie || !movie->moov) return GF_BAD_PARAM;\n\n#if 0\n\tif (movie->openMode==GF_ISOM_OPEN_CAT_FRAGMENTS) {\n\t\t/*from now on we are in write mode*/\n\t\tmovie->openMode = GF_ISOM_OPEN_WRITE;\n\t\tstore_file = GF_FALSE;\n\t\tmovie->append_segment = GF_TRUE;\n\t} else\n#endif\n\t{\n\t\tmovie->NextMoofNumber = 1;\n\t}\n\tmovie->moov->mvex_after_traks = mvex_after_tracks;\n\t\n\t//this is only allowed in write mode\n\tif (movie->openMode != GF_ISOM_OPEN_WRITE) return GF_ISOM_INVALID_MODE;\n\n\tif (movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY) return GF_OK;\n\tmovie->FragmentsFlags = 0;\n\n\tif (store_file) {\n\t\t/* add DASH brand if requested*/\n\t\tif (media_segment_type)\n\t\t\tgf_isom_modify_alternate_brand(movie, GF_ISOM_BRAND_DASH, GF_TRUE);\n\n\t\tif (!movie->moov->mvex->mehd || !movie->moov->mvex->mehd->fragment_duration) {\n\t\t\t//update durations\n\t\t\tgf_isom_get_duration(movie);\n\t\t}\n\n\t\ti=0;\n\t\twhile ((trex = (GF_TrackExtendsBox *)gf_list_enum(movie->moov->mvex->TrackExList, &i))) {\n\t\t\tif (trex->type != GF_ISOM_BOX_TYPE_TREX) continue;\n\t\t\tif (trex->track->Media->information->sampleTable->CompositionToDecode) {\n\t\t\t\tu32 k=0;\n\t\t\t\tGF_TrackExtensionPropertiesBox *trep;\n\t\t\t\twhile ((trep = (GF_TrackExtensionPropertiesBox*) gf_list_enum(movie->moov->mvex->TrackExPropList, &k))) {\n\t\t\t\t\tif (trep->trackID == trex->trackID) break;\n\t\t\t\t}\n\n\t\t\t\tif (!trep) {\n\t\t\t\t\ttrep = (GF_TrackExtensionPropertiesBox*) gf_isom_box_new_parent(&movie->moov->mvex->child_boxes, GF_ISOM_BOX_TYPE_TREP);\n\t\t\t\t\tif (!trep) return GF_OUT_OF_MEM;\n\t\t\t\t\ttrep->trackID = trex->trackID;\n\t\t\t\t\tgf_list_add(movie->moov->mvex->TrackExPropList, trep);\n\t\t\t\t}\n\n\t\t\t\tif (!trex->track->Media->information->sampleTable->SampleSize || ! trex->track->Media->information->sampleTable->SampleSize->sampleCount) {\n\t\t\t\t\tgf_list_add(trep->child_boxes, trex->track->Media->information->sampleTable->CompositionToDecode);\n\t\t\t\t\ttrex->track->Media->information->sampleTable->CompositionToDecode = NULL;\n\t\t\t\t} else {\n\t\t\t\t\tGF_CompositionToDecodeBox *cslg;\n\n\t\t\t\t\t//clone it!\n\t\t\t\t\tGF_SAFEALLOC(cslg, GF_CompositionToDecodeBox);\n\t\t\t\t\tif (!cslg) return GF_OUT_OF_MEM;\n\t\t\t\t\tmemcpy(cslg, trex->track->Media->information->sampleTable->CompositionToDecode, sizeof(GF_CompositionToDecodeBox) );\n\t\t\t\t\tcslg->child_boxes = gf_list_new();\n\t\t\t\t\tgf_list_add(trep->child_boxes, trex->track->Media->information->sampleTable->CompositionToDecode);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (movie->moov->mvex->mehd && movie->moov->mvex->mehd->fragment_duration) {\n\t\t\t\ttrex->track->Header->duration = 0;\n\t\t\t\tMedia_SetDuration(trex->track);\n\t\t\t\tif (trex->track->editBox && trex->track->editBox->editList) {\n\t\t\t\t\tGF_EdtsEntry *edts = gf_list_last(trex->track->editBox->editList->entryList);\n\t\t\t\t\tedts->segmentDuration = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//write movie\n\t\te = WriteToFile(movie, GF_TRUE);\n\t\tif (e) return e;\n\n\t\tif (movie->on_block_out) {\n\t\t\tgf_bs_seek(movie->editFileMap->bs, 0);\n\t\t\tgf_bs_truncate(movie->editFileMap->bs);\n\t\t}\n\t}\n\n\t//make sure we do have all we need. If not this is not an error, just consider\n\t//the file closed\n\tif (!movie->moov->mvex || !gf_list_count(movie->moov->mvex->TrackExList)) return GF_OK;\n\n\ti=0;\n\twhile ((trex = (GF_TrackExtendsBox *)gf_list_enum(movie->moov->mvex->TrackExList, &i))) {\n\t\tif (!trex->trackID || !gf_isom_get_track_from_id(movie->moov, trex->trackID)) return GF_IO_ERR;\n\t\t//we could also check all our data refs are local but we'll do that at run time\n\t\t//in order to allow a mix of both (remote refs in MOOV and local in MVEX)\n\n\t\t//one thing that MUST be done is OD cross-dependencies. The movie fragment spec\n\t\t//is broken here, since it cannot allow dynamic insertion of new ESD and their\n\t\t//dependancies\n\t}\n\n\t//ok we are fine - note the data map is created at the beginning\n\tif (i) movie->FragmentsFlags |= GF_ISOM_FRAG_WRITE_READY;\n\n\tif (media_segment_type) {\n\t\tmovie->use_segments = GF_TRUE;\n\t\tmovie->moof_list = gf_list_new();\n\t} else if (movie->on_block_out) {\n\t\tmovie->moof_list = gf_list_new();\n\t}\n\n\t/*set brands for segment*/\n\n\t/*\"msdh\": it's a media segment */\n\tgf_isom_set_brand_info(movie, GF_ISOM_BRAND_MSDH, 0);\n\t/*remove all brands\t*/\n\tgf_isom_reset_alt_brands(movie);\n\t/*\n\t\tmsdh: it's a media segment\n\t\tsims: it's a media segment with an SSIX\n\t\tmsix: it's a media segment with an index\n\t\tlmsg: it's the last media segment\n\t*/\n\n\treturn GF_OK;\n}\n\nGF_Err gf_isom_change_track_fragment_defaults(GF_ISOFile *movie, GF_ISOTrackID TrackID,\n        u32 DefaultSampleDescriptionIndex,\n        u32 DefaultSampleDuration,\n        u32 DefaultSampleSize,\n        u8 DefaultSampleIsSync,\n        u8 DefaultSamplePadding,\n        u16 DefaultDegradationPriority,\n        u8 force_traf_flags)\n{\n\tGF_MovieExtendsBox *mvex;\n\tGF_TrackExtendsBox *trex;\n\tGF_TrackBox *trak;\n\n\tif (!movie || !movie->moov) return GF_BAD_PARAM;\n\t//this is only allowed in write mode\n\tif (movie->openMode != GF_ISOM_OPEN_WRITE) return GF_ISOM_INVALID_MODE;\n\n\ttrak = gf_isom_get_track_from_id(movie->moov, TrackID);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tmvex = movie->moov->mvex;\n\tif (!mvex) return GF_BAD_PARAM;\n\n\ttrex = GetTrex(movie->moov, TrackID);\n\tif (!trex)  return GF_BAD_PARAM;\n\n\ttrex->def_sample_desc_index = DefaultSampleDescriptionIndex;\n\ttrex->def_sample_duration = DefaultSampleDuration;\n\ttrex->def_sample_size = DefaultSampleSize;\n\ttrex->def_sample_flags = GF_ISOM_FORMAT_FRAG_FLAGS(DefaultSamplePadding, DefaultSampleIsSync, DefaultDegradationPriority);\n\t//if sample is sync by default, set sample_depends_on flags to 2 (does not depend on other samples)\n\tif (DefaultSampleIsSync) {\n\t\ttrex->def_sample_flags |= (2<<24);\n\t}\n\ttrex->cannot_use_default = GF_FALSE;\n\n\tif (force_traf_flags) {\n\t\ttrex->cannot_use_default = GF_TRUE;\n\t} else if (DefaultSampleDescriptionIndex == 0 && DefaultSampleDuration == 0 && DefaultSampleSize == 0\n\t\t&& DefaultSampleIsSync == 0 && DefaultSamplePadding == 0 && DefaultDegradationPriority == 0) {\n\t\ttrex->cannot_use_default = GF_TRUE;\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_setup_track_fragment(GF_ISOFile *movie, GF_ISOTrackID TrackID,\n                                    u32 DefaultSampleDescriptionIndex,\n                                    u32 DefaultSampleDuration,\n                                    u32 DefaultSampleSize,\n                                    u8 DefaultSampleSyncFlags,\n                                    u8 DefaultSamplePadding,\n                                    u16 DefaultDegradationPriority,\n                                    Bool force_traf_flags)\n{\n\tGF_MovieExtendsBox *mvex;\n\tGF_TrackExtendsBox *trex;\n\tGF_TrackBox *trak;\n\n\tif (!movie || !movie->moov) return GF_BAD_PARAM;\n\t//this is only allowed in write mode\n\tif (movie->openMode != GF_ISOM_OPEN_WRITE) return GF_ISOM_INVALID_MODE;\n\t//and only at setup\n\tif (movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY) return GF_BAD_PARAM;\n\n\n\ttrak = gf_isom_get_track_from_id(movie->moov, TrackID);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tif (DefaultSampleSyncFlags & GF_ISOM_FRAG_USE_SYNC_TABLE) {\n\t\tDefaultSampleSyncFlags &= ~GF_ISOM_FRAG_USE_SYNC_TABLE;\n\t\tif (!trak->Media->information->sampleTable->SyncSample) {\n\t\t\ttrak->Media->information->sampleTable->SyncSample = (GF_SyncSampleBox *) gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_STSS);\n\t\t}\n\t}\n\n\t//create MVEX if needed\n\tif (!movie->moov->mvex) {\n\t\tmvex = (GF_MovieExtendsBox *) gf_isom_box_new_parent(&movie->moov->child_boxes, GF_ISOM_BOX_TYPE_MVEX);\n\t\tif (!mvex) return GF_OUT_OF_MEM;\n\t\tmoov_on_child_box((GF_Box*)movie->moov, (GF_Box *) mvex, GF_FALSE);\n\t} else {\n\t\tmvex = movie->moov->mvex;\n\t}\n\tif (!mvex->mehd) {\n\t\tmvex->mehd = (GF_MovieExtendsHeaderBox *) gf_isom_box_new_parent(&mvex->child_boxes, GF_ISOM_BOX_TYPE_MEHD);\n\t\tif (!mvex->mehd) return GF_OUT_OF_MEM;\n\t}\n\n\ttrex = GetTrex(movie->moov, TrackID);\n\tif (!trex) {\n\t\ttrex = (GF_TrackExtendsBox *) gf_isom_box_new_parent(&mvex->child_boxes, GF_ISOM_BOX_TYPE_TREX);\n\t\tif (!trex) return GF_OUT_OF_MEM;\n\t\ttrex->trackID = TrackID;\n\t\tmvex_on_child_box((GF_Box*)mvex, (GF_Box *) trex, GF_FALSE);\n\t}\n\ttrex->track = trak;\n\treturn gf_isom_change_track_fragment_defaults(movie, TrackID, DefaultSampleDescriptionIndex, DefaultSampleDuration, DefaultSampleSize, DefaultSampleSyncFlags, DefaultSamplePadding, DefaultDegradationPriority, force_traf_flags);\n}\n\n#ifdef GF_ENABLE_CTRN\nGF_EXPORT\nGF_Err gf_isom_enable_traf_inherit(GF_ISOFile *movie, GF_ISOTrackID TrackID, GF_ISOTrackID BaseTrackID)\n{\n\tGF_TrackBox *trak;\n\tGF_TrackExtendsBox *trex;\n\tGF_Err e=GF_OK;\n\tu32 track_num;\n\tif (!movie || !TrackID || !BaseTrackID)\n\t\treturn GF_BAD_PARAM;\n\ttrak = gf_isom_get_track_from_id(movie->moov, TrackID);\n\tif (!trak) return GF_BAD_PARAM;\n\ttrack_num = 1 + gf_list_find(movie->moov->trackList, trak);\n\n\te = gf_isom_set_track_reference(movie, track_num, GF_ISOM_REF_TRIN, BaseTrackID);\n\tif (e) return e;\n\n\ttrex = GetTrex(movie->moov, TrackID);\n\tif (!trex) return GF_BAD_PARAM;\n\ttrex->inherit_from_traf_id = BaseTrackID;\n\treturn GF_OK;\n}\n#endif\n\nGF_EXPORT\nGF_Err gf_isom_setup_track_fragment_template(GF_ISOFile *movie, GF_ISOTrackID TrackID, u8 *boxes, u32 boxes_size, u8 force_traf_flags)\n{\n\tGF_MovieExtendsBox *mvex;\n\tGF_TrackBox *trak;\n\tGF_BitStream *bs;\n\tGF_Err e=GF_OK;\n\ttrak = gf_isom_get_track_from_id(movie->moov, TrackID);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tbs = gf_bs_new(boxes, boxes_size, GF_BITSTREAM_READ);\n\twhile (gf_bs_available(bs)) {\n\t\tGF_Box *box=NULL;\n\t\tgf_isom_box_parse(&box, bs);\n\t\tif (!box) {\n\t\t\te = GF_BAD_PARAM;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (box->type==GF_ISOM_BOX_TYPE_TREX) {\n\t\t\tGF_TrackExtendsBox *trex_o=NULL;\n\t\t\tGF_TrackExtendsBox *trex = (GF_TrackExtendsBox *) box;\n\n\t\t\t//create MVEX if needed\n\t\t\tif (!movie->moov->mvex) {\n\t\t\t\tmvex = (GF_MovieExtendsBox *) gf_isom_box_new_parent(&movie->moov->child_boxes, GF_ISOM_BOX_TYPE_MVEX);\n\t\t\t\tmoov_on_child_box((GF_Box*)movie->moov, (GF_Box *) mvex, GF_FALSE);\n\t\t\t} else {\n\t\t\t\tmvex = movie->moov->mvex;\n\t\t\t}\n\t\t\tif (!mvex->mehd) {\n\t\t\t\tmvex->mehd = (GF_MovieExtendsHeaderBox *) gf_isom_box_new_parent(&mvex->child_boxes, GF_ISOM_BOX_TYPE_MEHD);\n\t\t\t}\n\n\t\t\ttrex_o = GetTrex(movie->moov, TrackID);\n\t\t\tif (trex_o) {\n\t\t\t\tgf_list_del_item(movie->moov->mvex->TrackExList, trex_o);\n\t\t\t\tgf_isom_box_del_parent(&movie->moov->mvex->child_boxes, (GF_Box *)trex_o);\n\t\t\t}\n\t\t\ttrex->trackID = TrackID;\n\t\t\ttrex->track = trak;\n\t\t\tif (force_traf_flags) trex->cannot_use_default = GF_TRUE;\n\t\t\tgf_list_add(mvex->child_boxes, trex);\n\t\t\tmvex_on_child_box((GF_Box*)mvex, (GF_Box *) trex, GF_FALSE);\n\t\t}\n\t}\n\tgf_bs_del(bs);\n\treturn e;\n}\n\n\nu32 GetNumUsedValues(GF_TrackFragmentBox *traf, u32 value, u32 index)\n{\n\tu32 i, j, NumValue = 0;\n\tGF_TrackFragmentRunBox *trun;\n\n\ti=0;\n\twhile ((trun = (GF_TrackFragmentRunBox *)gf_list_enum(traf->TrackRuns, &i))) {\n\t\tfor (j=0; j<trun->nb_samples; j++) {\n\t\t\tGF_TrunEntry *ent = &trun->samples[j];\n\t\t\tswitch (index) {\n\t\t\tcase 1:\n\t\t\t\tif (value == ent->Duration) NumValue ++;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tif (value == ent->size) NumValue ++;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tif (value == ent->flags) NumValue ++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn NumValue;\n}\n\n\nvoid ComputeFragmentDefaults(GF_TrackFragmentBox *traf)\n{\n\tu32 i, j;\n\tGF_TrackFragmentRunBox *trun;\n\tGF_TrunEntry *ent, *first_ent=NULL;\n\n\t//Duration default\n\tu32 def_dur=0;\n\tu32 def_size=0;\n\tu32 def_flags=0;\n\tu32 nb_samp=0;\n\n\ti=0;\n\twhile ((trun = (GF_TrackFragmentRunBox *)gf_list_enum(traf->TrackRuns, &i))) {\n\t\tfor (j=0; j<trun->nb_samples; j++) {\n\t\t\tent = &trun->samples[j];\n\t\t\tnb_samp++;\n\n\t\t\tif (!first_ent) {\n\t\t\t\tfirst_ent = ent;\n\t\t\t\tdef_dur = ent->Duration;\n\t\t\t\tdef_size = ent->size;\n\t\t\t\tif (ent->nb_pack>1)\n\t\t\t\t\tdef_size /= ent->nb_pack;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t//if more than 2 dur, we need the flag\n\t\t\tif (def_dur && (ent->Duration != def_dur)) def_dur=0;\n\t\t\t//if more than 2 size, we need the flag\n\t\t\tif (def_size) {\n\t\t\t\tu32 size = ent->size;\n\t\t\t\tif (ent->nb_pack>1)\n\t\t\t\t\tsize /= ent->nb_pack;\n\t\t\t\tif (size != def_size) def_size=0;\n\t\t\t}\n\t\t\t//only check sample flags after first sample (first one uses first sample flags)\n\t\t\tif (nb_samp==2) def_flags = ent->flags;\n\t\t\t//if more than 2 sets of flags, we need one entry each\n\t\t\telse if (def_flags && (ent->flags != def_flags)) def_flags = 0;\n\n\t\t\t//no default possible\n\t\t\tif ((def_dur|def_size|def_flags) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (nb_samp==1) def_flags = first_ent->flags;\n\n\tif (def_dur && ((def_dur != traf->trex->def_sample_duration) || traf->trex->cannot_use_default ) ) {\n\t\ttraf->tfhd->def_sample_duration = def_dur;\n\t}\n\tif (def_size && (def_size != traf->trex->def_sample_size)) {\n\t\ttraf->tfhd->def_sample_size = def_size;\n\t}\n\tif (traf->trex->cannot_use_default || (def_flags && (def_flags != traf->trex->def_sample_flags))) {\n\t\ttraf->tfhd->def_sample_flags = def_flags;\n\t}\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_fragment_option(GF_ISOFile *movie, GF_ISOTrackID TrackID, GF_ISOTrackFragmentOption Code, u32 Param)\n{\n\tGF_TrackFragmentBox *traf;\n\tif (!movie || !movie->moov) return GF_BAD_PARAM;\n\t//this is only allowed in write mode\n\tif (movie->openMode != GF_ISOM_OPEN_WRITE) return GF_ISOM_INVALID_MODE;\n\n\tswitch (Code) {\n\tcase GF_ISOM_TRAF_EMPTY:\n\t\ttraf = gf_isom_get_traf(movie, TrackID);\n\t\tif (!traf) return GF_BAD_PARAM;\n\t\ttraf->tfhd->EmptyDuration = Param;\n\t\tbreak;\n\tcase GF_ISOM_TRAF_RANDOM_ACCESS:\n\t\ttraf = gf_isom_get_traf(movie, TrackID);\n\t\tif (!traf) return GF_BAD_PARAM;\n\t\ttraf->IFrameSwitching = Param;\n\t\tbreak;\n\tcase GF_ISOM_TRAF_DATA_CACHE:\n\t\ttraf = gf_isom_get_traf(movie, TrackID);\n\t\tif (!traf) return GF_BAD_PARAM;\n\t\t//don't cache only one sample ...\n\t\ttraf->DataCache = Param > 1 ? Param : 0;\n\t\tbreak;\n\tcase GF_ISOM_TFHD_FORCE_MOOF_BASE_OFFSET:\n\t\tmovie->force_moof_base_offset = Param;\n\t\tbreak;\n\tcase GF_ISOM_TRAF_USE_SAMPLE_DEPS_BOX:\n\t\ttraf = gf_isom_get_traf(movie, TrackID);\n\t\tif (!traf) return GF_BAD_PARAM;\n\t\ttraf->use_sdtp = (u8) Param;\n\t\tbreak;\n\tcase GF_ISOM_TRUN_FORCE:\n\t\ttraf = gf_isom_get_traf(movie, TrackID);\n\t\tif (!traf) return GF_BAD_PARAM;\n\t\ttraf->force_new_trun = 1;\n\t\tbreak;\n\tcase GF_ISOM_TRUN_SET_INTERLEAVE_ID:\n\t\ttraf = gf_isom_get_traf(movie, TrackID);\n\t\tif (!traf) return GF_BAD_PARAM;\n\t\ttraf->DataCache = 1;\n\t\ttraf->use_sample_interleave = 1;\n\t\tif (traf->interleave_id != Param) {\n\t\t\ttraf->force_new_trun = 1;\n\t\t\ttraf->interleave_id = Param;\n\t\t}\n\t\tbreak;\n\tcase GF_ISOM_TRAF_TRUNS_FIRST:\n\t\ttraf = gf_isom_get_traf(movie, TrackID);\n\t\tif (!traf) return GF_BAD_PARAM;\n\t\ttraf->truns_first = Param;\n\t\tbreak;\n\tcase GF_ISOM_TRAF_TRUN_V1:\n\t\ttraf = gf_isom_get_traf(movie, TrackID);\n\t\tif (!traf) return GF_BAD_PARAM;\n\t\ttraf->truns_v1 = Param;\n\t\tbreak;\n\tcase GF_ISOM_TRAF_USE_LARGE_TFDT:\n\t\ttraf = gf_isom_get_traf(movie, TrackID);\n\t\tif (!traf) return GF_BAD_PARAM;\n\t\ttraf->large_tfdt = Param;\n\t\tmovie->force_sidx_v1 = Param ? GF_TRUE : GF_FALSE;\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\n//#define USE_BASE_DATA_OFFSET\n\nvoid update_trun_offsets(GF_ISOFile *movie, s32 offset)\n{\n#ifndef USE_BASE_DATA_OFFSET\n\tu32 i, j;\n\tGF_TrackFragmentBox *traf;\n\ti=0;\n\twhile ((traf = (GF_TrackFragmentBox*)gf_list_enum(movie->moof->TrackList, &i))) {\n\t\tGF_TrackFragmentRunBox *trun;\n\t\t/*remove base data*/\n\t\ttraf->tfhd->base_data_offset = 0;\n\t\tj=0;\n\t\twhile ((trun = (GF_TrackFragmentRunBox*)gf_list_enum(traf->TrackRuns, &j))) {\n\t\t\tif ((j==1) || traf->use_sample_interleave) {\n\t\t\t\ttrun->data_offset += offset;\n\t\t\t} else {\n\t\t\t\ttrun->data_offset = 0;\n\t\t\t}\n\t\t}\n\t}\n#endif\n}\n\nstatic\nu32 UpdateRuns(GF_ISOFile *movie, GF_TrackFragmentBox *traf)\n{\n\tu32 sampleCount, i, j, RunSize, RunDur, RunFlags, NeedFlags, UseCTS;\n\t/* enum:\n\t   0 - use values per sample in the trun box\n\t   1 - use default values from track fragment header\n\t   2 - use default values from track extends header */\n\tu32 UseDefaultSize, UseDefaultDur, UseDefaultFlag;\n\tGF_TrackFragmentRunBox *trun;\n\tGF_TrunEntry *ent;\n\n\tsampleCount = 0;\n\n#ifndef USE_BASE_DATA_OFFSET\n\tif (movie->use_segments) {\n\t\ttraf->tfhd->flags = GF_ISOM_MOOF_BASE_OFFSET;\n\t} else\n#endif\n\t{\n\t\tif (movie->force_moof_base_offset) {\n\t\t\ttraf->tfhd->flags = GF_ISOM_MOOF_BASE_OFFSET;\n\t\t} else {\n\t\t\ttraf->tfhd->flags = GF_ISOM_TRAF_BASE_OFFSET;\n\t\t}\n\t}\n\n\t//empty runs\n\tif (traf->tfhd->EmptyDuration) {\n\t\twhile (gf_list_count(traf->TrackRuns)) {\n\t\t\ttrun = (GF_TrackFragmentRunBox *)gf_list_get(traf->TrackRuns, 0);\n\t\t\tgf_list_rem(traf->TrackRuns, 0);\n\t\t\tgf_isom_box_del_parent(&traf->child_boxes, (GF_Box *)trun);\n\t\t}\n\t\ttraf->tfhd->flags |= GF_ISOM_TRAF_DUR_EMPTY;\n\t\tif (traf->tfhd->EmptyDuration != traf->trex->def_sample_duration) {\n\t\t\ttraf->tfhd->def_sample_duration = traf->tfhd->EmptyDuration;\n\t\t\ttraf->tfhd->flags |= GF_ISOM_TRAF_SAMPLE_DUR;\n\t\t}\n\t\treturn 0;\n\t}\n\n\n\tUseDefaultSize = 0;\n\tUseDefaultDur = 0;\n\tUseDefaultFlag = 0;\n\n\ti=0;\n\twhile ((trun = (GF_TrackFragmentRunBox *)gf_list_enum(traf->TrackRuns, &i))) {\n\t\tGF_TrunEntry *first_ent = NULL;\n\t\tRunSize = 0;\n\t\tRunDur = 0;\n\t\tRunFlags = 0;\n\t\tUseCTS = 0;\n\t\tNeedFlags = 0;\n\n\t\t//process all samples in run\n\t\tfor (j=0; j<trun->nb_samples; j++) {\n\t\t\tent = &trun->samples[j];\n\t\t\tif (!j) {\n\t\t\t\tfirst_ent = ent;\n\t\t\t\tRunSize = ent->size;\n\t\t\t\tif (ent->nb_pack) RunSize /= ent->nb_pack;\n\t\t\t\tRunDur = ent->Duration;\n\t\t\t}\n\t\t\t//we may have one entry only ...\n\t\t\tif (j || (trun->nb_samples==1)) {\n\t\t\t\tu32 ssize = ent->size;\n\t\t\t\tif (ent->nb_pack) ssize /= ent->nb_pack;\n\n\t\t\t\t//flags are only after first entry\n\t\t\t\tif (j==1 || (trun->nb_samples==1) ) RunFlags = ent->flags;\n\n\t\t\t\tif (ssize != RunSize) RunSize = 0;\n\t\t\t\tif (RunDur && (ent->Duration != RunDur))\n\t\t\t\t\tRunDur = 0;\n\t\t\t\tif (j && (RunFlags != ent->flags)) NeedFlags = 1;\n\t\t\t}\n\t\t\tif (ent->CTS_Offset) UseCTS = 1;\n\t\t}\n\t\t//empty list\n\t\tif (!first_ent) {\n\t\t\ti--;\n\t\t\tgf_list_rem(traf->TrackRuns, i);\n\t\t\tcontinue;\n\t\t}\n\t\ttrun->flags = 0;\n\n\t\t//size checking\n\t\t//constant size, check if this is from current fragment default or global default\n\t\tif (RunSize && (traf->trex->def_sample_size == RunSize) && !traf->trex->cannot_use_default) {\n\t\t\tif (!UseDefaultSize) UseDefaultSize = 2;\n\t\t\telse if (UseDefaultSize==1) RunSize = 0;\n\t\t} else if (RunSize && (traf->tfhd->def_sample_size == RunSize)) {\n\t\t\tif (!UseDefaultSize) UseDefaultSize = 1;\n\t\t\telse if (UseDefaultSize==2) RunSize = 0;\n\t\t}\n\t\t//we could check for single entry runs and set the default size in the tfhd but\n\t\t//that's no bit saving...\n\t\telse {\n\t\t\tRunSize=0;\n\t\t}\n\n\t\tif (!RunSize) trun->flags |= GF_ISOM_TRUN_SIZE;\n\n\t\t//duration checking\n\t\tif (RunDur && (traf->trex->def_sample_duration == RunDur) && !traf->trex->cannot_use_default) {\n\t\t\tif (!UseDefaultDur) UseDefaultDur = 2;\n\t\t\telse if (UseDefaultDur==1) RunDur = 0;\n\t\t} else if (RunDur && (traf->tfhd->def_sample_duration == RunDur)) {\n\t\t\tif (!UseDefaultDur) UseDefaultDur = 1;\n\t\t\telse if (UseDefaultDur==2) RunDur = 0;\n\t\t}\n\t\tif (!RunDur) trun->flags |= GF_ISOM_TRUN_DURATION;\n\n\t\t//flag checking\n\t\tif (!NeedFlags) {\n\t\t\t// all samples flags are the same after the 2nd entry\n\t\t\tif (RunFlags == traf->trex->def_sample_flags && !traf->trex->cannot_use_default) {\n\t\t\t\t/* this run can use trex flags */\n\t\t\t\tif (!UseDefaultFlag) {\n\t\t\t\t\t/* if all previous runs used explicit flags per sample, we can still use trex flags for this run */\n\t\t\t\t\tUseDefaultFlag = 2;\n\t\t\t\t} else if (UseDefaultFlag==1) {\n\t\t\t\t\t/* otherwise if one of the previous runs did use tfhd flags,\n\t\t\t\t\twe have no choice but to explicitly use flags per sample for this run */\n\t\t\t\t\tNeedFlags = GF_TRUE;\n\t\t\t\t}\n\t\t\t} else if (RunFlags == traf->tfhd->def_sample_flags) {\n\t\t\t\t/* this run can use tfhd flags */\n\t\t\t\tif (!UseDefaultFlag) {\n\t\t\t\t\t/* if all previous runs used explicit flags per sample, we can still use tfhd flags for this run */\n\t\t\t\t\tUseDefaultFlag = 1;\n\t\t\t\t} else if(UseDefaultFlag==2) {\n\t\t\t\t\t/* otherwise if one of the previous runs did use trex flags,\n\t\t\t\t\twe have no choice but to explicitly use flags per sample for this run */\n\t\t\t\t\tNeedFlags = GF_TRUE;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* the flags for the 2nd and following entries are different from trex and tfhd default values\n\t\t\t\t   (possible case: 2 samples in trun, and first sample was used to set default flags) */\n\t\t\t\tNeedFlags = GF_TRUE;\n\t\t\t}\n\t\t}\n\t\tif (NeedFlags) {\n\t\t\t//one flags entry per sample only\n\t\t\ttrun->flags |= GF_ISOM_TRUN_FLAGS;\n\t\t} else {\n\t\t\t/* this run can use default flags for the 2nd and following entries,\n\t\t\t   we just need to check if the first entry flags need to be singled out*/\n\t\t\tif (first_ent->flags != RunFlags) {\n\t\t\t\ttrun->flags |= GF_ISOM_TRUN_FIRST_FLAG;\n\t\t\t\t//if not old arch write the flags\n\t\t\t\t//in old arch we write 0, which means all deps unknown and sync sample set\n\t\t\t\tif (!traf->no_sdtp_first_flags)\n\t\t\t\t\ttrun->first_sample_flags = first_ent->flags;\n\t\t\t}\n\t\t}\n\n\t\t//CTS flag\n\t\tif (UseCTS) trun->flags |= GF_ISOM_TRUN_CTS_OFFSET;\n\n\t\t//run data offset if the offset indicated is 0 (first sample in this MDAT) don't\n\t\t//indicate it\n\t\tif (trun->data_offset)\n\t\t\ttrun->flags |= GF_ISOM_TRUN_DATA_OFFSET;\n\n\t\tsampleCount += trun->sample_count;\n\t}\n\n\t//after all runs in the traf are processed, update TRAF flags\n\tif (UseDefaultSize==1)\n\t\ttraf->tfhd->flags |= GF_ISOM_TRAF_SAMPLE_SIZE;\n\tif (UseDefaultDur==1)\n\t\ttraf->tfhd->flags |= GF_ISOM_TRAF_SAMPLE_DUR;\n\tif (UseDefaultFlag==1)\n\t\ttraf->tfhd->flags |= GF_ISOM_TRAF_SAMPLE_FLAGS;\n\tif (traf->trex->cannot_use_default || (traf->tfhd->sample_desc_index != traf->trex->def_sample_desc_index))\n\t\ttraf->tfhd->flags |= GF_ISOM_TRAF_SAMPLE_DESC;\n\n\n\treturn sampleCount;\n}\n\nstatic s32 get_earliest_cts_following(GF_TrackFragmentBox *traf, u32 trun_idx, u32 samp_idx)\n{\n\tGF_TrackFragmentRunBox *trun;\n\tGF_TrunEntry *ent;\n\ts32 earliest_cts = 0;\n\ts32 delta = 0;\n\tu32 j;\n\tu32 i=trun_idx;\n\twhile ((trun = (GF_TrackFragmentRunBox*)gf_list_enum(traf->TrackRuns, &i))) {\n\t\tj=samp_idx;\n\t\tsamp_idx=0;\n\t\tfor (; j<trun->nb_samples; j++) {\n\t\t\tent = &trun->samples[j];\n\t\t\tif (!j && (i==1)) {\n\t\t\t\tearliest_cts = ent->CTS_Offset;\n\t\t\t} else {\n\t\t\t\ts32 cts = ent->CTS_Offset+delta;\n\t\t\t\tif (earliest_cts > cts)\n\t\t\t\t\tearliest_cts = cts;\n\t\t\t}\n\t\t\tdelta += ent->Duration;\n\t\t}\n\t}\n\treturn earliest_cts;\n}\n\nstatic u32 moof_get_sap_info(GF_MovieFragmentBox *moof, GF_ISOTrackID refTrackID, u32 *sap_delta, Bool *starts_with_sap)\n{\n\tu32 i, j, count, sap_type, sap_sample_num, cur_sample;\n\ts32 delta, earliest_cts;\n\tBool first = GF_TRUE;\n\tGF_TrunEntry *ent;\n\tGF_TrackFragmentBox *traf=NULL;\n\tGF_TrackFragmentRunBox *trun;\n\tsap_type = 0;\n\t*sap_delta = 0;\n\t*starts_with_sap = GF_FALSE;\n\tfor (i=0; i<gf_list_count(moof->TrackList); i++) {\n\t\ttraf = (GF_TrackFragmentBox*)gf_list_get(moof->TrackList, i);\n\t\tif (traf->tfhd->trackID==refTrackID) break;\n\t\ttraf=NULL;\n\t}\n\tif (!traf) return sap_type;\n\tearliest_cts = 0;\n\n\t/*first check if we have a roll/rap sample in this traf, and mark its sample count*/\n\tsap_type = 0;\n\tsap_sample_num = 0;\n\t/*check RAP and ROLL*/\n\tcount = traf->sampleGroups ? gf_list_count(traf->sampleGroups) : 0;\n\tfor (i=0; i<count; i++) {\n\t\tGF_SampleGroupBox *sg;\n\t\tu32 first_sample;\n\t\tBool rap_type = GF_FALSE;\n\t\tsg = (GF_SampleGroupBox*)gf_list_get(traf->sampleGroups, i);\n\n\t\tswitch (sg->grouping_type) {\n\t\tcase GF_ISOM_SAMPLE_GROUP_RAP:\n\t\tcase GF_ISOM_SAMPLE_GROUP_SYNC:\n\t\t\trap_type = GF_TRUE;\n\t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_ROLL:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t\t/*first entry is SAP*/\n\t\tfirst_sample = 1;\n\t\tfor (j=0; j<sg->entry_count; j++) {\n\t\t\tif (! sg->sample_entries[j].group_description_index) {\n\t\t\t\tfirst_sample += sg->sample_entries[j].sample_count;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!j) {\n\t\t\t\t*starts_with_sap = GF_TRUE;\n\t\t\t\tsap_sample_num = 0;\n\t\t\t}\n\t\t\tif (!sap_sample_num || (sap_sample_num>first_sample)) {\n\t\t\t\tsap_type = rap_type ? 3 : 4;\n\t\t\t\tsap_sample_num = first_sample;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\t//compute earliest cts in segment\n\tearliest_cts = get_earliest_cts_following(traf, 0, 0);\n\n\t/*then browse all samples, looking for SYNC flag or sap_sample_num*/\n\tcur_sample = 1;\n\tdelta = 0;\n\ti=0;\n\twhile ((trun = (GF_TrackFragmentRunBox*)gf_list_enum(traf->TrackRuns, &i))) {\n\t\tif (trun->flags & GF_ISOM_TRUN_FIRST_FLAG) {\n\t\t\tif (GF_ISOM_GET_FRAG_SYNC(trun->flags)) {\n\t\t\t\tent = &trun->samples[0];\n\t\t\t\ts32 earliest_at_or_after_sap = get_earliest_cts_following(traf, i-1, 0);\n\t\t\t\t*sap_delta = (u32) (earliest_at_or_after_sap - earliest_cts);\n\n\t\t\t\t*starts_with_sap = first;\n\t\t\t\tsap_type = ent->SAP_type;\n\t\t\t\treturn sap_type;\n\t\t\t}\n\t\t}\n\t\tfor (j=0; j<trun->nb_samples; j++) {\n\t\t\tent = &trun->samples[j];\n\n\t\t\tif (GF_ISOM_GET_FRAG_SYNC(ent->flags)) {\n\t\t\t\ts32 earliest_at_or_after_sap = get_earliest_cts_following(traf, i-1, j);\n\t\t\t\t*sap_delta = (u32) (earliest_at_or_after_sap - earliest_cts);\n\t\t\t\t*starts_with_sap = first;\n\t\t\t\tsap_type = ent->SAP_type;\n\t\t\t\treturn sap_type;\n\t\t\t}\n\t\t\t/*we found our roll or rap sample*/\n\t\t\tif (cur_sample==sap_sample_num) {\n\t\t\t\t*sap_delta = (u32) (delta + ent->CTS_Offset - earliest_cts);\n\t\t\t\treturn sap_type;\n\t\t\t}\n\t\t\tdelta += ent->Duration;\n\t\t\tfirst = GF_FALSE;\n\t\t\tcur_sample++;\n\t\t}\n\t}\n\t/*not found*/\n\treturn 0;\n}\n\nu32 moof_get_duration(GF_MovieFragmentBox *moof, GF_ISOTrackID refTrackID)\n{\n\tu32 i, j, duration;\n\tGF_TrackFragmentBox *traf = NULL;\n\tGF_TrackFragmentRunBox *trun;\n\tfor (i=0; i<gf_list_count(moof->TrackList); i++) {\n\t\ttraf = (GF_TrackFragmentBox*)gf_list_get(moof->TrackList, i);\n\t\tif (traf->tfhd->trackID==refTrackID) break;\n\t\ttraf=NULL;\n\t}\n\tif (!traf) return 0;\n\n\tduration = 0;\n\ti=0;\n\twhile ((trun = (GF_TrackFragmentRunBox*)gf_list_enum(traf->TrackRuns, &i))) {\n\t\tfor (j=0; j<trun->nb_samples; j++) {\n\t\t\tGF_TrunEntry *ent = &trun->samples[j];\n\t\t\tif (ent->flags & GF_ISOM_TRAF_SAMPLE_DUR)\n\t\t\t\tduration += ent->Duration;\n\t\t\telse\n\t\t\t\tduration += traf->trex->def_sample_duration;\n\t\t}\n\t}\n\treturn duration;\n}\n\nstatic u64 moof_get_earliest_cts(GF_MovieFragmentBox *moof, GF_ISOTrackID refTrackID)\n{\n\tu32 i, j;\n\tu64 cts, duration;\n\tGF_TrackFragmentBox *traf=NULL;\n\tGF_TrackFragmentRunBox *trun;\n\tfor (i=0; i<gf_list_count(moof->TrackList); i++) {\n\t\ttraf = (GF_TrackFragmentBox*)gf_list_get(moof->TrackList, i);\n\t\tif (traf->tfhd->trackID==refTrackID) break;\n\t\ttraf=NULL;\n\t}\n\tif (!traf) return 0;\n\n\tduration = 0;\n\tcts = (u64) -1;\n\ti=0;\n\twhile ((trun = (GF_TrackFragmentRunBox*)gf_list_enum(traf->TrackRuns, &i))) {\n\t\tfor (j=0; j<trun->nb_samples; j++) {\n\t\t\tGF_TrunEntry *ent = &trun->samples[j];\n\t\t\tif (duration + ent->CTS_Offset < cts)\n\t\t\t\tcts = duration + ent->CTS_Offset;\n\t\t\tduration += ent->Duration;\n\t\t}\n\t}\n\treturn cts;\n}\n\n\nGF_Err gf_isom_write_compressed_box(GF_ISOFile *mov, GF_Box *root_box, u32 repl_type, GF_BitStream *bs, u32 *box_csize);\n\nvoid flush_ref_samples(GF_ISOFile *movie, u64 *out_seg_size, Bool use_seg_marker)\n{\n\tu32 i=0;\n\tu32 traf_count = movie->in_sidx_write ? 0 : gf_list_count(movie->moof->TrackList);\n\tfor (i=0; i<traf_count; i++) {\n\t\tGF_TrackFragmentBox *traf = gf_list_get(movie->moof->TrackList, i);\n\t\tu32 j, run_count = gf_list_count(traf->TrackRuns);\n\t\tif (!run_count) continue;\n\t\tfor (j=0; j<run_count; j++) {\n\t\t\tGF_TrackFragmentRunBox *trun = (GF_TrackFragmentRunBox *)gf_list_get(traf->TrackRuns, j);\n\t\t\tu32 s_count = gf_list_count(trun->sample_refs);\n\t\t\twhile (s_count) {\n\t\t\t\tif (!use_seg_marker && movie->on_last_block_start && (i+1==traf_count) && (j+1==run_count) && (s_count==1)) {\n\t\t\t\t\tmovie->on_last_block_start(movie->on_block_out_usr_data);\n\t\t\t\t}\n\t\t\t\tGF_TrafSampleRef *sref = gf_list_pop_front(trun->sample_refs);\n\t\t\t\tmovie->on_block_out(movie->on_block_out_usr_data, sref->data, sref->len, sref->ref, sref->ref_offset);\n\t\t\t\tif (out_seg_size) *out_seg_size += sref->len;\n\t\t\t\tif (!sref->ref) gf_free(sref->data);\n\t\t\t\tgf_free(sref);\n\t\t\t\ts_count--;\n\t\t\t}\n\t\t}\n\t}\n}\n\nGF_Err gf_bs_grow(GF_BitStream *bs, u32 addSize);\n\nstatic GF_Err StoreFragment(GF_ISOFile *movie, Bool load_mdat_only, s32 data_offset_diff, u32 *moof_size, Bool reassign_bs)\n{\n\tGF_Err e;\n\tu64 moof_start, pos, trun_ref_size=0;\n\tu32 size, i, s_count, mdat_size;\n\ts32 offset;\n\tu8 *buffer;\n\tGF_TrackFragmentBox *traf;\n\tGF_TrackFragmentRunBox *trun;\n\tGF_BitStream *bs, *bs_orig;\n\tif (!movie->moof) return GF_OK;\n\n\tbs = movie->editFileMap->bs;\n\tif (!movie->moof_first) {\n\t\tload_mdat_only = GF_FALSE;\n\t\tmovie->force_moof_base_offset = GF_FALSE;\n\t}\n\n\tmdat_size = 0;\n\t//1 - flush all caches\n\ti=0;\n\twhile ((traf = (GF_TrackFragmentBox*)gf_list_enum(movie->moof->TrackList, &i))) {\n\t\tu32 j, nb_written, last_gid, cur_sample_idx;\n\t\t/*do not write empty senc*/\n\t\tif (traf->sample_encryption && !gf_list_count(traf->sample_encryption->samp_aux_info)) {\n\t\t\tgf_list_del_item(traf->child_boxes, traf->sample_encryption);\n\t\t\tgf_isom_box_del((GF_Box *) traf->sample_encryption);\n\t\t\ttraf->sample_encryption = NULL;\n\t\t\t/*remove saiz and saio (todo, check if other saiz/saio types are used*/\n\t\t\tfor (j=0; j<gf_list_count(traf->sai_sizes); j++) {\n\t\t\t\tGF_SampleAuxiliaryInfoSizeBox *saiz = gf_list_get(traf->sai_sizes, j);\n\t\t\t\tswitch (saiz->aux_info_type) {\n\t\t\t\tcase GF_ISOM_CENC_SCHEME:\n\t\t\t\tcase GF_ISOM_CBC_SCHEME:\n\t\t\t\tcase GF_ISOM_CENS_SCHEME:\n\t\t\t\tcase GF_ISOM_CBCS_SCHEME:\n\t\t\t\tcase 0:\n\t\t\t\t\tgf_list_rem(traf->sai_sizes, j);\n\t\t\t\t\tgf_list_del_item(traf->child_boxes, saiz);\n\t\t\t\t\tgf_isom_box_del((GF_Box *)saiz);\n\t\t\t\t\tj--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (j=0; j<gf_list_count(traf->sai_offsets); j++) {\n\t\t\t\tGF_SampleAuxiliaryInfoOffsetBox *saio = gf_list_get(traf->sai_offsets, j);\n\t\t\t\tswitch (saio->aux_info_type) {\n\t\t\t\tcase GF_ISOM_CENC_SCHEME:\n\t\t\t\tcase GF_ISOM_CBC_SCHEME:\n\t\t\t\tcase GF_ISOM_CENS_SCHEME:\n\t\t\t\tcase GF_ISOM_CBCS_SCHEME:\n\t\t\t\tcase 0:\n\t\t\t\t\tgf_list_rem(traf->sai_offsets, j);\n\t\t\t\t\tgf_list_del_item(traf->child_boxes, saio);\n\t\t\t\t\tgf_isom_box_del((GF_Box *)saio);\n\t\t\t\t\tj--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttrun_ref_size += traf->trun_ref_size;\n\t\tif (!traf->DataCache) continue;\n\n\t\ts_count = gf_list_count(traf->TrackRuns);\n\t\tif (!s_count) continue;\n\n\t\t//store all cached truns - there may be more than one when using sample interleaving in truns\n\t\tnb_written = 0;\n\t\tlast_gid = 0;\n\t\tcur_sample_idx = 0;\n\t\twhile (nb_written<s_count) {\n\t\t\tu32 min_next_gid = 0xFFFFFFFF;\n\n\t\t\tfor (j=0; j<s_count; j++) {\n\t\t\t\ttrun = (GF_TrackFragmentRunBox *)gf_list_get(traf->TrackRuns, j);\n\t\t\t\t//done\n\t\t\t\tif (!trun->cache || !trun->sample_count) continue;\n\n\t\t\t\tif (!traf->use_sample_interleave || (last_gid!=trun->interleave_id)) {\n\t\t\t\t\tif (trun->interleave_id < min_next_gid)\n\t\t\t\t\t\tmin_next_gid = trun->interleave_id;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t//update offset\n\t\t\t\ttrun->data_offset = (u32) (gf_bs_get_position(bs) - movie->moof->fragment_offset - 8);\n\t\t\t\t//write cache\n\t\t\t\tgf_bs_get_content(trun->cache, &buffer, &size);\n\t\t\t\tgf_bs_write_data(bs, buffer, size);\n\t\t\t\tgf_bs_del(trun->cache);\n\t\t\t\tgf_free(buffer);\n\t\t\t\ttrun->cache = NULL;\n\t\t\t\ttrun->first_sample_idx = cur_sample_idx;\n\t\t\t\tcur_sample_idx += trun->sample_count;\n\n\t\t\t\tnb_written++;\n\t\t\t}\n\t\t\tlast_gid = min_next_gid;\n\t\t}\n\n\t\ttraf->DataCache=0;\n\t}\n\n\tif (load_mdat_only) {\n\t\tpos = trun_ref_size ? (trun_ref_size+8) : gf_bs_get_position(bs);\n\t\tif (movie->moof->fragment_offset > pos)\n\t\t\treturn GF_CORRUPTED_DATA;\n\n\t\t//we assume we never write large MDATs in fragment mode which should always be true\n\t\tmovie->moof->mdat_size = (u32) (pos - movie->moof->fragment_offset);\n\n\t\tif (trun_ref_size) {\n\t\t\tgf_bs_seek(movie->editFileMap->bs, 0);\n\t\t\treturn GF_OK;\n\t\t}\n\t\tif (movie->segment_bs) {\n\t\t\te = gf_bs_seek(bs, 0);\n\t\t\tif (e) return e;\n\t\t\t/*write mdat size*/\n\t\t\tgf_bs_write_u32(bs, (u32) movie->moof->mdat_size);\n\t\t\t/*and get internal buffer*/\n\t\t\te = gf_bs_seek(bs, movie->moof->mdat_size);\n\t\t\tif (e) return e;\n\t\t\tgf_bs_get_content(bs, &movie->moof->mdat, &movie->moof->mdat_size);\n\n\t\t\tgf_bs_del(bs);\n\t\t\tmovie->editFileMap->bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\t} else {\n\t\t\tu64 frag_offset = movie->segment_start;\n\t\t\te = gf_bs_seek(bs, frag_offset);\n\t\t\tif (e) return e;\n\t\t\t/*write mdat size*/\n\t\t\tgf_bs_write_u32(bs, (u32) movie->moof->mdat_size);\n\n\t\t\tmovie->moof->mdat = (char*)gf_malloc(sizeof(char) * movie->moof->mdat_size);\n\t\t\tif (!movie->moof->mdat) return GF_OUT_OF_MEM;\n\n\t\t\te = gf_bs_seek(bs, frag_offset);\n\t\t\tif (e) return e;\n\t\t\tgf_bs_read_data(bs, movie->moof->mdat, movie->moof->mdat_size);\n\n\t\t\te = gf_bs_seek(bs, frag_offset);\n\t\t\tif (e) return e;\n\t\t\tgf_bs_truncate(bs);\n\t\t}\n\n\t\treturn GF_OK;\n\t}\n\n\tmoof_start = gf_bs_get_position(bs);\n\n\tif (movie->moof->ntp) {\n\t\tmoof_start += 8*4;\n\t}\n\n\t//2- update MOOF MDAT header\n\tif (!movie->moof->mdat && !trun_ref_size) {\n\t\te = gf_bs_seek(bs, movie->moof->fragment_offset);\n\t\tif (e) return e;\n\t\t//we assume we never write large MDATs in fragment mode which should always be true\n\t\tmdat_size = (u32) (moof_start - movie->moof->fragment_offset);\n\t\tgf_bs_write_u32(bs, (u32) mdat_size);\n\t\tgf_bs_write_u32(bs, GF_ISOM_BOX_TYPE_MDAT);\n\t\te = gf_bs_seek(bs, moof_start);\n\t\tif (e) return e;\n\t}\n\n\t/*estimate moof size and shift trun offsets*/\n#ifndef USE_BASE_DATA_OFFSET\n\toffset = 0;\n\tif (movie->use_segments || movie->force_moof_base_offset) {\n\t\te = gf_isom_box_size((GF_Box *) movie->moof);\n\t\tif (e) return e;\n\t\toffset = (s32) movie->moof->size;\n\t\t/*mdat size & type*/\n\t\toffset += 8;\n\t\tupdate_trun_offsets(movie, offset);\n\t}\n#endif\n\n\t//3- clean our traf's\n\ti=0;\n\twhile ((traf = (GF_TrackFragmentBox*) gf_list_enum(movie->moof->TrackList, &i))) {\n\t\t//compute default settings for the TRAF\n\t\tComputeFragmentDefaults(traf);\n\t\t//updates all trun and set all flags, INCLUDING TRAF FLAGS (durations, ...)\n\t\ts_count = UpdateRuns(movie, traf);\n\t\t//empty fragment destroy it\n\t\tif (!traf->tfhd->EmptyDuration && !s_count) {\n\t\t\ti--;\n\t\t\tgf_list_rem(movie->moof->TrackList, i);\n\t\t\tgf_isom_box_del_parent(&movie->moof->child_boxes, (GF_Box *) traf);\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tbuffer = NULL;\n\t/*rewind bitstream and load mdat in memory */\n\tif (movie->moof_first && !movie->moof->mdat && !trun_ref_size) {\n\t\tbuffer = (char*)gf_malloc(sizeof(char)*mdat_size);\n\t\tif (!buffer) return GF_OUT_OF_MEM;\n\t\te = gf_bs_seek(bs, movie->moof->fragment_offset);\n\t\tif (e) return e;\n\t\tgf_bs_read_data(bs, buffer, mdat_size);\n\t\t/*back to mdat start and erase with moov*/\n\t\te = gf_bs_seek(bs, movie->moof->fragment_offset);\n\t\tif (e) return e;\n\t\tgf_bs_truncate(bs);\n\t}\n\n\t//4- Write moof\n\te = gf_isom_box_size((GF_Box *) movie->moof);\n\tif (e) return e;\n\t/*moof first, update traf headers - THIS WILL IMPACT THE MOOF SIZE IF WE\n\tDECIDE NOT TO USE THE DATA-OFFSET FLAG*/\n\tif (movie->moof_first\n#ifndef USE_BASE_DATA_OFFSET\n\t        && !(movie->use_segments || movie->force_moof_base_offset)\n#endif\n\t   ) {\n\t\ti=0;\n\t\twhile ((traf = (GF_TrackFragmentBox*)gf_list_enum(movie->moof->TrackList, &i))) {\n\t\t\t/*offset increases by moof size*/\n\t\t\ttraf->tfhd->base_data_offset += movie->moof->size;\n\t\t\ttraf->tfhd->base_data_offset += data_offset_diff;\n\t\t\tif (movie->on_block_out) {\n\t\t\t\ttraf->tfhd->base_data_offset += movie->fragmented_file_pos;\n\t\t\t}\n\t\t}\n\t}\n#ifndef USE_BASE_DATA_OFFSET\n\telse if (movie->use_segments || movie->force_moof_base_offset) {\n\t\tif (offset != (movie->moof->size+8)) {\n\t\t\toffset = (s32) (movie->moof->size + 8 - offset);\n\t\t\tupdate_trun_offsets(movie, offset);\n\t\t\te = gf_isom_box_size((GF_Box *) movie->moof);\n\t\t\tif (e) return e;\n\t\t}\n\t}\n#endif\n\n\tif (!movie->moof_first && !movie->force_moof_base_offset) {\n\t\ti=0;\n\t\twhile ((traf = (GF_TrackFragmentBox*)gf_list_enum(movie->moof->TrackList, &i))) {\n\t\t\t/*offset increases by moof size*/\n\t\t\tif (movie->on_block_out) {\n\t\t\t\ttraf->tfhd->base_data_offset += movie->fragmented_file_pos;\n\t\t\t}\n\t\t}\n\t}\n\n\tbs_orig = bs;\n\tif (reassign_bs && movie->on_block_out) {\n\t\tbs = gf_bs_new_cbk(isom_on_block_out, movie, movie->on_block_out_block_size);\n\t}\n\n\tif (trun_ref_size && movie->in_sidx_write) {\n\t\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t}\n\n\tif (movie->moof->ntp) {\n\t\tgf_bs_write_u32(bs, 8*4);\n\t\tgf_bs_write_u32(bs, GF_ISOM_BOX_TYPE_PRFT );\n\t\tgf_bs_write_u8(bs, 1);\n\t\tgf_bs_write_u24(bs, 0);\n\t\tgf_bs_write_u32(bs, movie->moof->reference_track_ID);\n\t\tgf_bs_write_u64(bs, movie->moof->ntp);\n\t\tgf_bs_write_u64(bs, movie->moof->timestamp);\n\t}\n\tif (movie->moof->emsgs) {\n\t\twhile (1) {\n\t\t\tGF_Box *emsg = gf_list_pop_front(movie->moof->emsgs);\n\t\t\tif (!emsg) break;\n\t\t\tgf_isom_box_size(emsg);\n\t\t\tgf_isom_box_write(emsg, bs);\n\t\t\tgf_isom_box_del(emsg);\n\t\t}\n\t\tgf_list_del(movie->moof->emsgs);\n\t\tmovie->moof->emsgs = NULL;\n\t}\n\n\tif (moof_size) *moof_size = (u32) movie->moof->size;\n\n\tpos = gf_bs_get_position(bs);\n\t//graw buffer to hold moof, speeds up writes\n\tgf_bs_grow(bs, (u32) movie->moof->size + (trun_ref_size ? 8 : 0));\n\n\ti=0;\n\twhile ((traf = (GF_TrackFragmentBox*)gf_list_enum(movie->moof->TrackList, &i))) {\n\t\ttraf->moof_start_in_bs = pos;\n\t}\n\n\t/*we don't want to dispatch any block until done writing the moof*/\n\tif (movie->on_block_out)\n\t\tgf_bs_prevent_dispatch(bs, GF_TRUE);\n\n\tif (movie->compress_mode>GF_ISOM_COMP_MOOV) {\n\t\te = gf_isom_write_compressed_box(movie, (GF_Box *) movie->moof, GF_4CC('!', 'm', 'o', 'f'), bs, moof_size);\n\t} else {\n\t\te = gf_isom_box_write((GF_Box *) movie->moof, bs);\n\t}\n\n\tif (trun_ref_size) {\n\t\tgf_bs_write_u32(bs, movie->moof->mdat_size);\n\t\tgf_bs_write_u32(bs, GF_ISOM_BOX_TYPE_MDAT);\n\t}\n\n\tif (movie->on_block_out)\n\t\tgf_bs_prevent_dispatch(bs, GF_FALSE);\n\n\tif (e) return e;\n\n\tif (trun_ref_size) {\n\t\tflush_ref_samples(movie, NULL, GF_FALSE);\n\t} else {\n\t\tif (movie->on_last_block_start && !gf_list_count(movie->moof_list))\n\t\t\tmovie->on_last_block_start(movie->on_block_out_usr_data);\n\n\t\t//rewrite mdat after moof\n\t\tif (movie->moof->mdat) {\n\t\t\tgf_bs_write_data(bs, movie->moof->mdat, movie->moof->mdat_size);\n\t\t\tgf_free(movie->moof->mdat);\n\t\t\tmovie->moof->mdat = NULL;\n\t\t} else if (buffer) {\n\t\t\tgf_bs_write_data(bs, buffer, mdat_size);\n\t\t\tgf_free(buffer);\n\t\t}\n\t}\n\n\tif (trun_ref_size && movie->in_sidx_write) {\n\t\tgf_bs_get_content(bs, &movie->moof->moof_data, &movie->moof->moof_data_len);\n\t\tgf_bs_del(bs);\n\t\tmovie->fragmented_file_pos += movie->moof->moof_data_len + trun_ref_size;\n\t\tmovie->moof->trun_ref_size = (u32) trun_ref_size;\n\t}\n\telse if (bs != bs_orig) {\n\t\tu64 frag_size = gf_bs_get_position(bs);\n\t\tgf_bs_del(bs);\n\t\tmovie->fragmented_file_pos += frag_size + trun_ref_size;\n\t\tgf_bs_seek(bs_orig, 0);\n\t\tgf_bs_truncate(bs_orig);\n\t}\n\telse if (movie->on_block_out) {\n\t\tu64 frag_size = gf_bs_get_position(bs);\n\t\tmovie->fragmented_file_pos += frag_size + trun_ref_size;\n\t}\n\n\tif (!movie->use_segments) {\n\t\t//remove from moof list (may happen in regular fragmentation when single traf per moof is used)\n\t\tgf_list_del_item(movie->moof_list, movie->moof);\n\t\tgf_isom_box_del((GF_Box *) movie->moof);\n\t\tmovie->moof = NULL;\n\t}\n\treturn GF_OK;\n}\n\nstatic GF_Err sidx_rewrite(GF_SegmentIndexBox *sidx, GF_BitStream *bs, u64 start_pos, GF_SubsegmentIndexBox *ssix)\n{\n\tGF_Err e = GF_OK;\n\tu64 pos = gf_bs_get_position(bs);\n\tif (ssix) {\n\t\te = gf_isom_box_size((GF_Box *)ssix);\n\t\tsidx->first_offset = ssix->size;\n\t}\n\t/*write sidx*/\n\tgf_bs_seek(bs, start_pos);\n\tif (!e) e = gf_isom_box_write((GF_Box *) sidx, bs);\n\tif (!e && ssix) {\n\t\te = gf_isom_box_write((GF_Box *) ssix, bs);\n\t}\n\tgf_bs_seek(bs, pos);\n\treturn e;\n}\n\nGF_Err gf_isom_allocate_sidx(GF_ISOFile *movie, s32 subsegs_per_sidx, Bool daisy_chain_sidx, u32 nb_segs, u32 *frags_per_segment, u32 *start_range, u32 *end_range, Bool use_ssix)\n{\n\tGF_BitStream *bs;\n\tGF_Err e;\n\tu32 i;\n\n\t//and only at setup\n\tif (!movie || !(movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY) ) return GF_BAD_PARAM;\n\tif (movie->openMode != GF_ISOM_OPEN_WRITE) return GF_ISOM_INVALID_MODE;\n\tif (movie->root_sidx) return GF_BAD_PARAM;\n\tif (movie->root_ssix) return GF_BAD_PARAM;\n\tif (movie->moof) return GF_BAD_PARAM;\n\tif (gf_list_count(movie->moof_list)) return GF_BAD_PARAM;\n\n\tmovie->root_sidx = (GF_SegmentIndexBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_SIDX);\n\tif (!movie->root_sidx) return GF_OUT_OF_MEM;\n\t/*we don't write anything between sidx and following moov*/\n\tmovie->root_sidx->first_offset = 0;\n\n\t/*for now we only store one ref per subsegment and don't support daisy-chaining*/\n\tmovie->root_sidx->nb_refs = nb_segs;\n\n\tif (use_ssix) {\n\t\tmovie->root_ssix = (GF_SubsegmentIndexBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_SSIX);\n\t\tmovie->root_ssix->subsegment_count = nb_segs;\n\t\tmovie->root_ssix->subsegment_alloc = movie->root_ssix->subsegment_count;\n\t}\n\n\t//dynamic mode\n\tif (!nb_segs) {\n\t\tmovie->dyn_root_sidx = GF_TRUE;\n\t\treturn GF_OK;\n\t}\n\n\tmovie->root_sidx->refs = (GF_SIDXReference*)gf_malloc(sizeof(GF_SIDXReference) * movie->root_sidx->nb_refs);\n\tif (!movie->root_sidx->refs) return GF_OUT_OF_MEM;\n\tmemset(movie->root_sidx->refs, 0, sizeof(GF_SIDXReference) * movie->root_sidx->nb_refs);\n\n\tmovie->root_sidx_index = 0;\n\n\tif (use_ssix) {\n\t\tmovie->root_ssix->subsegments = gf_malloc(sizeof(GF_SubsegmentInfo) * nb_segs);\n\t\tif (!movie->root_ssix->subsegments) return GF_OUT_OF_MEM;\n\t\tfor (i=0; i<nb_segs; i++) {\n\t\t\tmovie->root_ssix->subsegments[i].range_count = 2;\n\t\t\tmovie->root_ssix->subsegments[i].ranges = gf_malloc(sizeof(GF_SubsegmentRangeInfo)*2);\n\t\t\tif (!movie->root_ssix->subsegments[i].ranges) return GF_OUT_OF_MEM;\n\t\t\tmovie->root_ssix->subsegments[i].ranges[0].level = 0;\n\t\t\tmovie->root_ssix->subsegments[i].ranges[0].range_size = 0;\n\t\t\tmovie->root_ssix->subsegments[i].ranges[1].level = 1;\n\t\t\tmovie->root_ssix->subsegments[i].ranges[1].range_size = 0;\n\t\t}\n\t}\n\t\n\t/*remember start of sidx*/\n\tmovie->root_sidx_offset = gf_bs_get_position(movie->editFileMap->bs);\n\n\tbs = movie->editFileMap->bs;\n\n\te = gf_isom_box_size((GF_Box *) movie->root_sidx);\n\tif (e) return e;\n\te = gf_isom_box_write((GF_Box *) movie->root_sidx, bs);\n\tif (e) return e;\n\n\tif (movie->root_ssix) {\n\t\te = gf_isom_box_size((GF_Box *) movie->root_ssix);\n\t\tif (e) return e;\n\t\te = gf_isom_box_write((GF_Box *) movie->root_ssix, bs);\n\t\tif (e) return e;\n\t}\n\n\t//include ssix in index range - spec is not clear whether this is forbidden\n\tif (start_range) *start_range = (u32) movie->root_sidx_offset;\n\tif (end_range) *end_range = (u32) gf_bs_get_position(bs)-1;\n\n\treturn GF_OK;\n}\n\n\nstatic GF_Err gf_isom_write_styp(GF_ISOFile *movie, Bool last_segment)\n{\n\t/*write STYP if we write to a different file or if we write the last segment*/\n\tif (movie->use_segments && !movie->append_segment && !movie->segment_start && movie->write_styp) {\n\t\tGF_Err e;\n\n\t\t/*modify brands STYP*/\n\t\tif (movie->write_styp==1) {\n\t\t\t/*\"msix\" brand: this is a DASH Initialization Segment*/\n\t\t\tgf_isom_modify_alternate_brand(movie, GF_ISOM_BRAND_MSIX, GF_TRUE);\n\t\t\tif (last_segment) {\n\t\t\t\t/*\"lmsg\" brand: this is the last DASH Segment*/\n\t\t\t\tgf_isom_modify_alternate_brand(movie, GF_ISOM_BRAND_LMSG, GF_TRUE);\n\t\t\t}\n\t\t}\n\t\tmovie->brand->type = GF_ISOM_BOX_TYPE_STYP;\n\t\te = gf_isom_box_size((GF_Box *) movie->brand);\n\t\tif (e) return e;\n\t\te = gf_isom_box_write((GF_Box *) movie->brand, movie->editFileMap->bs);\n\t\tif (e) return e;\n\n\t\tmovie->write_styp = 0;\n\t}\n\n\tif (movie->emsgs) {\n\t\twhile (1) {\n\t\t\tGF_Box *b = gf_list_pop_front(movie->emsgs);\n\t\t\tif (!b) break;\n\t\t\tgf_isom_box_size(b);\n\t\t\tgf_isom_box_write(b, movie->editFileMap->bs);\n\t\t\tgf_isom_box_del(b);\n\t\t}\n\t\tgf_list_del(movie->emsgs);\n\t\tmovie->emsgs = NULL;\n\t}\n\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_flush_fragments(GF_ISOFile *movie, Bool last_segment)\n{\n\tGF_BitStream *temp_bs = NULL, *orig_bs;\n\tGF_Err e;\n\n\tif (!movie || !(movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY) ) return GF_BAD_PARAM;\n\tif (movie->openMode != GF_ISOM_OPEN_WRITE) return GF_ISOM_INVALID_MODE;\n\n\t/*flush our fragment (store in mem)*/\n\tif (movie->moof) {\n\t\te = StoreFragment(movie, GF_TRUE, 0, NULL, GF_FALSE);\n\t\tif (e) return e;\n\t}\n\n\tif (movie->segment_bs) {\n\t\ttemp_bs = movie->editFileMap->bs;\n\t\tmovie->editFileMap->bs = movie->segment_bs;\n\t}\n\n\tif (movie->moof_first) {\n\t\tgf_bs_seek(movie->editFileMap->bs, movie->segment_start);\n\t\tgf_bs_truncate(movie->editFileMap->bs);\n\t}\n\n\torig_bs = movie->editFileMap->bs;\n\tif (movie->on_block_out) {\n\t\tif (!movie->block_buffer) movie->block_buffer_size = movie->on_block_out_block_size;\n\t\tmovie->editFileMap->bs = gf_bs_new_cbk_buffer(isom_on_block_out, movie, movie->block_buffer, movie->block_buffer_size);\n\t}\n\n\t/*write styp to file if needed*/\n\te = gf_isom_write_styp(movie, last_segment);\n\tif (e) goto exit;\n\n\t/*write all pending fragments to file*/\n\twhile (gf_list_count(movie->moof_list)) {\n\t\ts32 offset_diff;\n\t\tu32 moof_size;\n\n\t\tmovie->moof = (GF_MovieFragmentBox*)gf_list_get(movie->moof_list, 0);\n\t\tgf_list_rem(movie->moof_list, 0);\n\n\t\toffset_diff = (s32) (gf_bs_get_position(movie->editFileMap->bs) - movie->moof->fragment_offset);\n\t\tmovie->moof->fragment_offset = gf_bs_get_position(movie->editFileMap->bs);\n\n\t\te = StoreFragment(movie, GF_FALSE, offset_diff, &moof_size, GF_FALSE);\n\t\tif (e) goto exit;\n\n\t\tgf_isom_box_del((GF_Box *) movie->moof);\n\t\tmovie->moof = NULL;\n\t}\n\n\t/*append mode: store fragment at the end of the regular movie bitstream, and delete the temp bitstream*/\n\tif (movie->append_segment) {\n\t\tchar bloc[1024];\n\t\tu32 seg_size = (u32) gf_bs_get_size(movie->editFileMap->bs);\n\t\tgf_bs_seek(movie->editFileMap->bs, 0);\n\t\twhile (seg_size) {\n\t\t\tu32 size = gf_bs_read_data(movie->editFileMap->bs, bloc, (seg_size>1024) ? 1024 : seg_size);\n\t\t\tgf_bs_write_data(movie->movieFileMap->bs, bloc, size);\n\t\t\tseg_size -= size;\n\t\t}\n\t\tgf_isom_datamap_flush(movie->movieFileMap);\n\n\t\tgf_isom_datamap_del(movie->editFileMap);\n\t\tmovie->editFileMap = gf_isom_fdm_new_temp(NULL);\n\t} else {\n\t\tgf_isom_datamap_flush(movie->editFileMap);\n\t}\n\tmovie->segment_start = gf_bs_get_position(movie->editFileMap->bs);\n\n\tif (temp_bs) {\n\t\tmovie->segment_bs = movie->editFileMap->bs;\n\t\tmovie->editFileMap->bs = temp_bs;\n\t}\n\n\tif (orig_bs != movie->editFileMap->bs) {\n\t\tu32 tmpsize;\n\t\tif (!movie->moof_first) {\n\t\t\tgf_bs_transfer(movie->editFileMap->bs, orig_bs, GF_TRUE);\n\t\t\tgf_bs_seek(orig_bs, 0);\n\t\t}\n\t\tgf_bs_get_content_no_truncate(movie->editFileMap->bs, &movie->block_buffer, &tmpsize, &movie->block_buffer_size);\n\t\tgf_bs_del(movie->editFileMap->bs);\n\t\tmovie->editFileMap->bs = orig_bs;\n\t\t//we are dispatching through callbacks, the movie segment start is always 0\n\t\tmovie->segment_start = 0;\n\t}\nexit:\n\treturn e;\n}\n\ntypedef struct\n{\n\tGF_SegmentIndexBox *sidx;\n\tu64 start_offset, end_offset;\n} SIDXEntry;\n\nstatic u64 get_presentation_time(u64 media_time, s32 ts_shift)\n{\n\tif ((ts_shift<0) && (media_time < -ts_shift)) {\n\t\tmedia_time = 0;\n\t} else {\n\t\tmedia_time += ts_shift;\n\t}\n\treturn media_time ;\n}\n\n\n#if 0 //unused\n/*! gets name of current segment (or last segment if called between close_segment and start_segment)\n\\param isom_file the target ISO file\n\\return associated file name of the segment\n*/\nGF_EXPORT\nconst char *gf_isom_get_segment_name(GF_ISOFile *movie)\n{\n\tif (!movie) return NULL;\n\tif (movie->append_segment) return movie->movieFileMap->szName;\n\treturn movie->editFileMap->szName;\n}\n#endif\n\nstatic void compute_seg_size(GF_ISOFile *movie, u64 *out_seg_size)\n{\n\tu64 final_size = 0;\n\tif (out_seg_size) {\n\t\tif (movie->append_segment) {\n\t\t\tfinal_size = gf_bs_get_position(movie->movieFileMap->bs);\n\t\t\tfinal_size -= movie->segment_start;\n\t\t} else if (movie->editFileMap) {\n\t\t\tfinal_size = gf_bs_get_position(movie->editFileMap->bs);\n\t\t}\n\t\t*out_seg_size = final_size;\n\t}\n}\n\nstatic u32 moof_get_first_sap_end(GF_MovieFragmentBox *moof)\n{\n\tu32 i, count = gf_list_count(moof->TrackList);\n\tfor (i=0; i<count; i++) {\n\t\tu32 j, nb_trun;\n\t\tGF_TrackFragmentBox *traf = gf_list_get(moof->TrackList, i);\n\t\tu32 base_offset = (u32) traf->tfhd->base_data_offset;\n\n\t\tnb_trun = gf_list_count(traf->TrackRuns);\n\t\tfor (j=0; j<nb_trun; j++) {\n\t\t\tu32 k;\n\t\t\tGF_TrackFragmentRunBox *trun = gf_list_get(traf->TrackRuns, j);\n\t\t\tu32 offset = base_offset + trun->data_offset;\n\t\t\tfor (k=0; k<trun->nb_samples; k++) {\n\t\t\t\tGF_TrunEntry *ent = &trun->samples[k];\n\t\t\t\tif (ent->SAP_type) return offset + ent->size;\n\n\t\t\t\toffset += ent->size;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic u64 estimate_next_moof_earliest_presentation_time(u64 ref_track_decode_time, s32 ts_shift, u32 refTrackID, GF_ISOFile *movie)\n{\n\tu32 i, j, nb_aus, nb_ctso, nb_moof;\n\tu64 duration;\n\tGF_TrunEntry *ent;\n\tGF_TrackFragmentBox *traf=NULL;\n\tGF_TrackFragmentRunBox *trun;\n\tu32 timescale;\n\tu64 min_next_cts = -1;\n\n\tGF_MovieFragmentBox *moof = gf_list_get(movie->moof_list, 0);\n\n\tfor (i=0; i<gf_list_count(moof->TrackList); i++) {\n\t\ttraf = (GF_TrackFragmentBox*)gf_list_get(moof->TrackList, i);\n\t\tif (traf->tfhd->trackID==refTrackID) break;\n\t\ttraf = NULL;\n\t}\n\t//no ref track, nothing to estimate\n\tif (!traf) return -1;\n\ttimescale = traf->trex->track->Media->mediaHeader->timeScale;\n\n\tnb_aus = 0;\n\tduration = 0;\n\tnb_ctso = 0;\n\tnb_moof = 0;\n\n\twhile ((moof = (GF_MovieFragmentBox*)gf_list_enum(movie->moof_list, &nb_moof))) {\n\n\t\tfor (i=0; i<gf_list_count(moof->TrackList); i++) {\n\t\t\ttraf = (GF_TrackFragmentBox*)gf_list_get(moof->TrackList, i);\n\t\t\tif (traf->tfhd->trackID==refTrackID) break;\n\t\t\ttraf = NULL;\n\t\t}\n\t\tif (!traf) continue;\n\n\t\ti=0;\n\t\twhile ((trun = (GF_TrackFragmentRunBox*)gf_list_enum(traf->TrackRuns, &i))) {\n\t\t\tfor (j=0; j<trun->nb_samples; j++) {\n\t\t\t\tent = &trun->samples[j];\n\t\t\t\tif (nb_aus + 1 + movie->sidx_pts_store_count > movie->sidx_pts_store_alloc) {\n\t\t\t\t\tmovie->sidx_pts_store_alloc = movie->sidx_pts_store_count+nb_aus+1;\n\t\t\t\t\tmovie->sidx_pts_store = gf_realloc(movie->sidx_pts_store, sizeof(u64) * movie->sidx_pts_store_alloc);\n\t\t\t\t\tmovie->sidx_pts_next_store = gf_realloc(movie->sidx_pts_next_store, sizeof(u64) * movie->sidx_pts_store_alloc);\n\t\t\t\t}\n\t\t\t\t//get PTS for this AU, push to regular list\n\t\t\t\tmovie->sidx_pts_store[movie->sidx_pts_store_count + nb_aus] = get_presentation_time( ref_track_decode_time + duration + ent->CTS_Offset, ts_shift);\n\t\t\t\t//get PTS for this AU shifted by its presentation duration, push to shifted list\n\t\t\t\tmovie->sidx_pts_next_store[movie->sidx_pts_store_count + nb_aus] = get_presentation_time( ref_track_decode_time + duration + ent->CTS_Offset + ent->Duration, ts_shift);\n\t\t\t\tduration += ent->Duration;\n\t\t\t\tif (ent->CTS_Offset)\n\t\t\t\t\tnb_ctso++;\n\n\t\t\t\tnb_aus++;\n\t\t\t}\n\t\t}\n\t}\n\n\tmovie->sidx_pts_store_count += nb_aus;\n\n\t//no AUs, nothing to estimate\n\tif (!nb_aus) {\n\t\tmovie->sidx_pts_store_count = 0;\n\t\treturn -1;\n\t}\n\t//no cts offset, assume earliest PTS in next segment is last PTS in this segment + duration\n\tif (!nb_ctso) {\n\t\tmin_next_cts = movie->sidx_pts_next_store[movie->sidx_pts_store_count - 1];\n\t\tmovie->sidx_pts_store_count = 0;\n\t\treturn min_next_cts;\n\t}\n\n\t//look for all shifted PTS of this segment in the regular list. If found in the shifted list, the AU is in this segment\n\t//remove from both list\n\tfor (i=0; i<movie->sidx_pts_store_count; i++) {\n\t\tfor (j=i; j<movie->sidx_pts_store_count; j++) {\n\t\t\t/*\n\n \t\t\tif (movie->sidx_pts_next_store[i] == movie->sidx_pts_store[j]) {\n \t\t\t\n\t\t\ttake care of misaligned timescale eg 24fps but 10000 timescale), we may not find exactly\n\t\t\tthe same sample - if diff below N ms consider it a match\n\t\t\tnot doing so would accumulate PTSs in the list, slowing down the muxing\n\n\t\t\tusing N=1ms strict would not be enough to take into account sources with approximate timing - cf issue #2436\n\t\t\twe use N=2ms max to handle sources with high jitter in cts\n\t\t\t*/\n\t\t\ts64 diff = movie->sidx_pts_next_store[i];\n\t\t\tdiff -= (s64) movie->sidx_pts_store[j];\n\t\t\tif (diff && (timescale>1000)) {\n\t\t\t\tif (ABS(diff) * 1000 < 2 * timescale)\n\t\t\t\t\tdiff = 0;\n\t\t\t}\n\t\t\tif (diff==0) {\n\t\t\t\tif (movie->sidx_pts_store_count >= i + 1)\n\t\t\t\t\tmemmove(&movie->sidx_pts_next_store[i], &movie->sidx_pts_next_store[i+1], sizeof(u64) * (movie->sidx_pts_store_count - i - 1) );\n\t\t\t\tif (movie->sidx_pts_store_count >= j + 1)\n\t\t\t\t\tmemmove(&movie->sidx_pts_store[j], &movie->sidx_pts_store[j+1], sizeof(u64) * (movie->sidx_pts_store_count - j - 1) );\n\t\t\t\tmovie->sidx_pts_store_count--;\n\t\t\t\ti--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t//the shifted list contain all AUs not yet in this segment, keep the smallest to compute the earliest PTS in next seg\n\t//note that we assume the durations were correctly set\n\tfor (i=0; i<movie->sidx_pts_store_count; i++) {\n\t\tif (min_next_cts > movie->sidx_pts_next_store[i])\n\t\t\tmin_next_cts = movie->sidx_pts_next_store[i];\n\t}\n\treturn min_next_cts;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_close_segment(GF_ISOFile *movie, s32 subsegments_per_sidx, GF_ISOTrackID referenceTrackID, u64 ref_track_decode_time, s32 ts_shift, u64 ref_track_next_cts, Bool daisy_chain_sidx, Bool use_ssix, Bool last_segment, Bool close_segment_handle, u32 segment_marker_4cc, u64 *index_start_range, u64 *index_end_range, u64 *out_seg_size)\n{\n\tGF_SegmentIndexBox *sidx=NULL;\n\tGF_SegmentIndexBox *root_sidx=NULL;\n\tGF_SubsegmentIndexBox *ssix=NULL;\n\tGF_List *daisy_sidx = NULL;\n\tGF_List *defer_moofs = NULL;\n\tGF_BitStream *orig_bs;\n\tu64 sidx_start, sidx_end;\n\tBool first_frag_in_subseg;\n\tBool no_sidx = GF_FALSE;\n\tu32 count, cur_idx, cur_dur, sidx_dur, sidx_idx, idx_offset, frag_count;\n\tu64 last_top_box_pos, root_prev_offset, local_sidx_start, local_sidx_end, prev_earliest_cts, next_earliest_cts;\n\tGF_TrackBox *trak = NULL;\n\tGF_Err e;\n\t/*number of subsegment in this segment (eg nb references in the first SIDX found)*/\n\tu32 nb_subsegs=0;\n\t/*number of subsegment per sidx (eg number of references of any sub-SIDX*/\n\tu32 subseg_per_sidx;\n\t/*number of fragments per subsegment*/\n\tu32 frags_per_subseg;\n\t/*number of fragments per subsidx*/\n\tu32 frags_per_subsidx;\n\n\tsidx_start = sidx_end = 0;\n\n\tif (index_start_range) *index_start_range = 0;\n\tif (index_end_range) *index_end_range = 0;\n\n\t//and only at setup\n\tif (!movie || !(movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY) ) return GF_BAD_PARAM;\n\tif (movie->openMode != GF_ISOM_OPEN_WRITE) return GF_ISOM_INVALID_MODE;\n\n\tcount = gf_list_count(movie->moov->mvex->TrackExList);\n\tif (!count) return GF_BAD_PARAM;\n\n\t/*store fragment*/\n\tif (movie->moof) {\n\t\te = StoreFragment(movie, GF_TRUE, 0, NULL, GF_FALSE);\n\t\tif (e) return e;\n\t}\n\t/*restore final bitstream*/\n\tif (movie->segment_bs) {\n\t\tgf_bs_del(movie->editFileMap->bs);\n\t\tmovie->editFileMap->bs = movie->segment_bs;\n\t\tmovie->segment_bs = NULL;\n\t}\n\n\tcount = gf_list_count(movie->moof_list);\n\tif (!count) {\n\t\t/*append segment marker box*/\n\t\tif (segment_marker_4cc) {\n\t\t\tif (movie->append_segment) {\n\t\t\t\tgf_bs_write_u32(movie->movieFileMap->bs, 8);\t//write size field\n\t\t\t\tgf_bs_write_u32(movie->movieFileMap->bs, segment_marker_4cc); //write box type field\n\t\t\t} else {\n\t\t\t\tgf_bs_write_u32(movie->editFileMap->bs, 8);\t//write size field\n\t\t\t\tgf_bs_write_u32(movie->editFileMap->bs, segment_marker_4cc); //write box type field\n\t\t\t}\n\t\t}\n\n\t\tcompute_seg_size(movie, out_seg_size);\n\n\t\tif (close_segment_handle) {\n\t\t\tgf_isom_datamap_del(movie->editFileMap);\n\t\t\tmovie->editFileMap = NULL;\n\t\t}\n\n\t\treturn GF_OK;\n\t}\n\n\tgf_bs_seek(movie->editFileMap->bs, movie->segment_start);\n\tgf_bs_truncate(movie->editFileMap->bs);\n\n\tidx_offset = 0;\n\n\tif (referenceTrackID) {\n\t\ttrak = gf_isom_get_track_from_id(movie->moov, referenceTrackID);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t}\n\n\tif (subsegments_per_sidx < 0) {\n\t\treferenceTrackID = 0;\n\t\tsubsegments_per_sidx = 0;\n\t}\n\tif (!subsegments_per_sidx && !referenceTrackID) {\n\t\tno_sidx = GF_TRUE;\n\t}\n\n\torig_bs = movie->editFileMap->bs;\n\tif (movie->on_block_out) {\n\t\tif (!movie->block_buffer) movie->block_buffer_size = movie->on_block_out_block_size;\n\t\tmovie->editFileMap->bs = gf_bs_new_cbk_buffer(isom_on_block_out, movie, movie->block_buffer, movie->block_buffer_size);\n\t\tif (referenceTrackID) gf_bs_prevent_dispatch(movie->editFileMap->bs, GF_TRUE);\n\t}\n\n\te = gf_isom_write_styp(movie, last_segment);\n\tif (e) goto exit;\n\n\tfrags_per_subseg = 0;\n\tsubseg_per_sidx = 0;\n\tfrags_per_subsidx = 0;\n\n\tprev_earliest_cts = 0;\n\tnext_earliest_cts = 0;\n\n\tif (daisy_chain_sidx)\n\t\tdaisy_sidx = gf_list_new();\n\n\t/*prepare SIDX: we write a blank SIDX box with the right number of entries, and will rewrite it later on*/\n\tif (referenceTrackID) {\n\t\tBool is_root_sidx = GF_FALSE;\n\n\t\tprev_earliest_cts = get_presentation_time( ref_track_decode_time + moof_get_earliest_cts((GF_MovieFragmentBox*)gf_list_get(movie->moof_list, 0), referenceTrackID), ts_shift);\n\n\t\t//we don't trust ref_track_next_cts to be the earliest in the following segment\n\t\tnext_earliest_cts = estimate_next_moof_earliest_presentation_time(ref_track_decode_time, ts_shift, referenceTrackID, movie);\n\n\t\tif (movie->root_sidx) {\n\t\t\tsidx = movie->root_sidx;\n\t\t} else {\n\t\t\tsidx = (GF_SegmentIndexBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_SIDX);\n\t\t\tif (!sidx) return GF_OUT_OF_MEM;\n\t\t\tif (movie->force_sidx_v1)\n\t\t\t\tsidx->version = 1;\n\t\t}\n\t\tsidx->reference_ID = referenceTrackID;\n\t\tsidx->timescale = trak->Media->mediaHeader->timeScale;\n\t\t/*we don't write anything between sidx and following moov*/\n\t\tsidx->first_offset = 0;\n\n\t\t/*we allocated our sidx to have one ref per \"segment\" (eg per call to close_segment)*/\n\t\tif (movie->root_sidx) {\n\t\t\tif (!movie->root_sidx_index) {\n\t\t\t\tsidx->earliest_presentation_time = prev_earliest_cts;\n\t\t\t}\n\t\t\tnb_subsegs = 1;\n\t\t\tfrags_per_subseg = count;\n\t\t\tfrags_per_subsidx = count;\n\t\t\tsubseg_per_sidx = 1;\n\t\t\tdaisy_chain_sidx = GF_FALSE;\n\n\t\t\tidx_offset = movie->root_sidx_index;\n\t\t\tsidx_end = gf_bs_get_position(movie->editFileMap->bs);\n\t\t} else {\n\t\t\tsidx->earliest_presentation_time = prev_earliest_cts;\n\n\t\t\t/*if more subsegments requested than fragments available, make a single sidx*/\n\t\t\tif ((s32) count <= subsegments_per_sidx)\n\t\t\t\tsubsegments_per_sidx = 0;\n\n\t\t\tif (daisy_chain_sidx && (subsegments_per_sidx<2))\n\t\t\t\tsubsegments_per_sidx = 2;\n\n\t\t\t/*single SIDX, each fragment is a subsegment and we reference all subsegments*/\n\t\t\tif (!subsegments_per_sidx) {\n\t\t\t\tnb_subsegs = count;\n\t\t\t\t/*we consider that each fragment is a subsegment - this could be controled by another parameter*/\n\t\t\t\tfrags_per_subseg = 1;\n\t\t\t\tfrags_per_subsidx = count;\n\t\t\t\tsubseg_per_sidx = count;\n\n\t\t\t\tsidx->nb_refs = nb_subsegs;\n\t\t\t\tdaisy_chain_sidx = GF_FALSE;\n\t\t\t}\n\t\t\t/*daisy-chain SIDX: each SIDX describes a subsegment made of frags_per_subseg fragments plus next */\n\t\t\telse if (daisy_chain_sidx) {\n\t\t\t\tfrags_per_subsidx = count/subsegments_per_sidx;\n\t\t\t\tif (frags_per_subsidx * subsegments_per_sidx < count) frags_per_subsidx++;\n\n\t\t\t\tnb_subsegs = subsegments_per_sidx;\n\n\t\t\t\t/*we consider that each fragment is a subsegment - this could be controled by another parameter*/\n\t\t\t\tfrags_per_subseg = 1;\n\t\t\t\tsubseg_per_sidx = frags_per_subsidx / frags_per_subseg;\n\t\t\t\tif (subseg_per_sidx * frags_per_subseg < frags_per_subsidx) subseg_per_sidx++;\n\n\t\t\t\tsidx->nb_refs = subseg_per_sidx + 1;\n\t\t\t}\n\t\t\t/*hierarchical SIDX*/\n\t\t\telse {\n\t\t\t\tfrags_per_subsidx = count/subsegments_per_sidx;\n\t\t\t\tif (frags_per_subsidx * subsegments_per_sidx < count) frags_per_subsidx++;\n\n\t\t\t\tnb_subsegs = subsegments_per_sidx;\n\n\t\t\t\t/*we consider that each fragment is a subsegment - this could be controled by another parameter*/\n\t\t\t\tfrags_per_subseg = 1;\n\t\t\t\tsubseg_per_sidx = frags_per_subsidx / frags_per_subseg;\n\t\t\t\tif (subseg_per_sidx * frags_per_subseg < frags_per_subsidx) subseg_per_sidx++;\n\n\t\t\t\tsidx->nb_refs = nb_subsegs;\n\t\t\t\tis_root_sidx = GF_TRUE;\n\t\t\t}\n\n\t\t\tsidx->refs = (GF_SIDXReference*)gf_malloc(sizeof(GF_SIDXReference)*sidx->nb_refs);\n\t\t\tif (!sidx->refs) return GF_OUT_OF_MEM;\n\t\t\tmemset(sidx->refs, 0, sizeof(GF_SIDXReference)*sidx->nb_refs);\n\n\t\t\t/*remember start of sidx*/\n\t\t\tsidx_start = gf_bs_get_position(movie->editFileMap->bs);\n\n\t\t\te = gf_isom_box_size((GF_Box *) sidx);\n\t\t\tif (e) goto exit;\n\t\t\te = gf_isom_box_write((GF_Box *) sidx, movie->editFileMap->bs);\n\t\t\tif (e) goto exit;\n\n\t\t\tif (use_ssix && !ssix && !movie->root_ssix) {\n\t\t\t\tu32 k;\n\t\t\t\tssix = (GF_SubsegmentIndexBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_SSIX);\n\t\t\t\tif (!ssix) return GF_OUT_OF_MEM;\n\t\t\t\tssix->subsegments = gf_malloc(sizeof(GF_SubsegmentInfo) * sidx->nb_refs);\n\t\t\t\tif (!ssix->subsegments) return GF_OUT_OF_MEM;\n\t\t\t\tssix->subsegment_count = sidx->nb_refs;\n\t\t\t\tssix->subsegment_alloc = ssix->subsegment_count;\n\t\t\t\tfor (k=0; k<sidx->nb_refs; k++) {\n\t\t\t\t\tGF_SubsegmentInfo *subs = &ssix->subsegments[k];\n\t\t\t\t\tsubs->range_count = 2;\n\t\t\t\t\tsubs->ranges = gf_malloc(sizeof(GF_SubsegmentRangeInfo)*2);\n\t\t\t\t\tif (!subs->ranges) return GF_OUT_OF_MEM;\n\t\t\t\t\tsubs->ranges[0].level = 1;\n\t\t\t\t\tsubs->ranges[1].level = 2;\n\t\t\t\t\tsubs->ranges[0].range_size = subs->ranges[1].range_size = 0;\n\t\t\t\t}\n\n\t\t\t\te = gf_isom_box_size((GF_Box *) ssix);\n\t\t\t\tif (e) return e;\n\t\t\t\te = gf_isom_box_write((GF_Box *) ssix, movie->editFileMap->bs);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\n\t\t\tsidx_end = gf_bs_get_position(movie->editFileMap->bs);\n\n\t\t\tif (daisy_sidx) {\n\t\t\t\tSIDXEntry *entry;\n\t\t\t\tGF_SAFEALLOC(entry, SIDXEntry);\n\t\t\t\tif (!entry) {\n\t\t\t\t\te = GF_OUT_OF_MEM;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t\tentry->sidx = sidx;\n\t\t\t\tentry->start_offset = sidx_start;\n\t\t\t\tgf_list_add(daisy_sidx, entry);\n\t\t\t}\n\t\t}\n\n\t\tif (is_root_sidx) {\n\t\t\troot_sidx = sidx;\n\t\t\tsidx = NULL;\n\t\t}\n\t\tcount = cur_idx = 0;\n\t}\n\n\n\tlast_top_box_pos = root_prev_offset = sidx_end;\n\tsidx_idx = 0;\n\tsidx_dur = 0;\n\tlocal_sidx_start = local_sidx_end = 0;\n\n\t/*cumulated segments duration since start of the sidx */\n\tfrag_count = frags_per_subsidx;\n\tcur_dur = 0;\n\tcur_idx = 0;\n\tfirst_frag_in_subseg = GF_TRUE;\n\te = GF_OK;\n\tu64 cumulated_ref_size=0;\n\twhile (gf_list_count(movie->moof_list)) {\n\t\ts32 offset_diff;\n\t\tu32 moof_size;\n\n\t\tmovie->moof = (GF_MovieFragmentBox*)gf_list_get(movie->moof_list, 0);\n\t\tgf_list_rem(movie->moof_list, 0);\n\t\tmovie->in_sidx_write = GF_TRUE;\n\t\tmovie->moof->trun_ref_size=0;\n\n\t\t/*hierarchical or daisy-chain SIDXs*/\n\t\tif (!no_sidx && !sidx && (root_sidx || daisy_chain_sidx) ) {\n\t\t\tu32 subsegments_remaining;\n\t\t\tsidx = (GF_SegmentIndexBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_SIDX);\n\t\t\tif (!sidx) return GF_OUT_OF_MEM;\n\t\t\tsidx->reference_ID = referenceTrackID;\n\t\t\tsidx->timescale = trak ? trak->Media->mediaHeader->timeScale : 1000;\n\t\t\tsidx->earliest_presentation_time = get_presentation_time( ref_track_decode_time + sidx_dur + moof_get_earliest_cts(movie->moof, referenceTrackID), ts_shift);\n\n\t\t\tfrag_count = frags_per_subsidx;\n\n\t\t\t/*last segment, add only one ref*/\n\t\t\tsubsegments_remaining = 1 + gf_list_count(movie->moof_list);\n\t\t\tif (subseg_per_sidx*frags_per_subseg > subsegments_remaining) {\n\t\t\t\tsubseg_per_sidx = subsegments_remaining / frags_per_subseg;\n\t\t\t\tif (subseg_per_sidx * frags_per_subseg < subsegments_remaining) subseg_per_sidx++;\n\t\t\t}\n\t\t\t/*we don't write anything between sidx and following moov*/\n\t\t\tsidx->first_offset = 0;\n\t\t\tsidx->nb_refs = subseg_per_sidx;\n\t\t\tif (daisy_chain_sidx && (nb_subsegs>1)) {\n\t\t\t\tsidx->nb_refs += 1;\n\t\t\t}\n\t\t\tsidx->refs = (GF_SIDXReference*)gf_malloc(sizeof(GF_SIDXReference)*sidx->nb_refs);\n\t\t\tif (!sidx->refs) return GF_OUT_OF_MEM;\n\t\t\tmemset(sidx->refs, 0, sizeof(GF_SIDXReference)*sidx->nb_refs);\n\n\t\t\tif (root_sidx)\n\t\t\t\troot_sidx->refs[sidx_idx].reference_type = GF_TRUE;\n\n\t\t\t/*remember start of sidx*/\n\t\t\tlocal_sidx_start = gf_bs_get_position(movie->editFileMap->bs);\n\n\t\t\t/*write it*/\n\t\t\te = gf_isom_box_size((GF_Box *) sidx);\n\t\t\tif (e) goto exit;\n\t\t\te = gf_isom_box_write((GF_Box *) sidx, movie->editFileMap->bs);\n\t\t\tif (e) goto exit;\n\n\t\t\tlocal_sidx_end = gf_bs_get_position(movie->editFileMap->bs);\n\n\t\t\t/*adjust prev offset*/\n\t\t\tlast_top_box_pos = local_sidx_end;\n\n\t\t\tif (daisy_sidx) {\n\t\t\t\tSIDXEntry *entry;\n\t\t\t\tGF_SAFEALLOC(entry, SIDXEntry);\n\t\t\t\tif (!entry) {\n\t\t\t\t\te = GF_OUT_OF_MEM;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t\tentry->sidx = sidx;\n\t\t\t\tentry->start_offset = local_sidx_start;\n\t\t\t\tgf_list_add(daisy_sidx, entry);\n\t\t\t}\n\t\t}\n\n\t\toffset_diff = (s32) (gf_bs_get_position(movie->editFileMap->bs) - movie->moof->fragment_offset);\n\t\tmovie->moof->fragment_offset = gf_bs_get_position(movie->editFileMap->bs);\n\n\t\tif (!e) {\n\t\t\tBool generate_ssix = GF_FALSE;\n\t\t\tif (movie->root_ssix) generate_ssix = GF_TRUE;\n\t\t\telse if (use_ssix && ssix) generate_ssix = GF_TRUE;\n\n\t\t\te = StoreFragment(movie, GF_FALSE, offset_diff, &moof_size, GF_FALSE);\n\t\t\tif (e) {\n\t\t\t\te = GF_OUT_OF_MEM;\n\t\t\t\tgoto exit;\n\t\t\t}\n\n\t\t\tif (sidx) {\n\t\t\t\tu32 cur_index = idx_offset + cur_idx;\n\n\t\t\t\t/*do not compute earliest CTS if single segment sidx since we only have set the info for one subsegment*/\n\t\t\t\tif (!movie->root_sidx && first_frag_in_subseg) {\n\t\t\t\t\tu64 first_cts = get_presentation_time( ref_track_decode_time + sidx_dur + cur_dur +  moof_get_earliest_cts(movie->moof, referenceTrackID), ts_shift);\n\t\t\t\t\tif (cur_index) {\n\t\t\t\t\t\tu32 subseg_dur = (u32) (first_cts - prev_earliest_cts);\n\t\t\t\t\t\tsidx->refs[cur_index-1].subsegment_duration = subseg_dur;\n\t\t\t\t\t\tif (root_sidx) root_sidx->refs[sidx_idx].subsegment_duration += subseg_dur;\n\t\t\t\t\t}\n\t\t\t\t\tprev_earliest_cts = first_cts;\n\t\t\t\t\tfirst_frag_in_subseg = GF_FALSE;\n\t\t\t\t}\n\n\t\t\t\tif (sidx->nb_refs<=cur_index) {\n\t\t\t\t\tsidx->nb_refs = cur_index+1;\n\t\t\t\t\tsidx->refs = gf_realloc(sidx->refs, sizeof(GF_SIDXReference)*sidx->nb_refs);\n\t\t\t\t\tmemset(&sidx->refs[cur_index], 0, sizeof(GF_SIDXReference));\n\t\t\t\t}\n\n\t\t\t\t/*we refer to next moof*/\n\t\t\t\tsidx->refs[cur_index].reference_type = GF_FALSE;\n\t\t\t\tif (!sidx->refs[cur_index].SAP_type) {\n\t\t\t\t\tsidx->refs[cur_index].SAP_type = moof_get_sap_info(movie->moof, referenceTrackID, & sidx->refs[cur_index].SAP_delta_time, & sidx->refs[cur_index].starts_with_SAP);\n\t\t\t\t\tif (sidx->refs[cur_index].SAP_type) {\n\t\t\t\t\t\tif (root_sidx && !root_sidx->refs[sidx_idx].SAP_type) {\n\t\t\t\t\t\t\troot_sidx->refs[sidx_idx].SAP_type = sidx->refs[cur_index].SAP_type;\n\t\t\t\t\t\t\troot_sidx->refs[sidx_idx].SAP_delta_time = sidx->refs[cur_index].SAP_delta_time;\n\t\t\t\t\t\t\troot_sidx->refs[sidx_idx].starts_with_SAP = sidx->refs[cur_index].starts_with_SAP;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcur_dur += moof_get_duration(movie->moof, referenceTrackID);\n\n\t\t\t\t/*reference size is end of the moof we just wrote minus last_box_pos*/\n\t\t\t\tu64 last_pos = gf_bs_get_position(movie->editFileMap->bs);\n\t\t\t\tif (movie->moof->moof_data_len) {\n\t\t\t\t\tcumulated_ref_size += movie->moof->moof_data_len + movie->moof->trun_ref_size;\n\t\t\t\t\tlast_pos += cumulated_ref_size;\n\t\t\t\t}\n\t\t\t\tsidx->refs[cur_index].reference_size += (u32) ( last_pos - last_top_box_pos) ;\n\t\t\t\tlast_top_box_pos = last_pos;\n\n\t\t\t\tcount++;\n\n\t\t\t\tif (generate_ssix) {\n\t\t\t\t\tu32 last_sseg_range0_size, remain_size;\n\t\t\t\t\tif (movie->root_ssix) {\n\t\t\t\t\t\tssix = movie->root_ssix;\n\t\t\t\t\t\tif (ssix->subsegment_count <= cur_index) {\n\t\t\t\t\t\t\tassert(ssix->subsegment_count == cur_index);\n\t\t\t\t\t\t\tssix->subsegment_count = cur_index+1;\n\t\t\t\t\t\t\tssix->subsegment_alloc = ssix->subsegment_count;\n\t\t\t\t\t\t\tssix->subsegments = gf_realloc(ssix->subsegments, ssix->subsegment_count * sizeof(GF_SubsegmentInfo));\n\t\t\t\t\t\t\tssix->subsegments[cur_index].range_count = 2;\n\t\t\t\t\t\t\tssix->subsegments[cur_index].ranges = gf_malloc(sizeof(GF_SubsegmentRangeInfo)*2);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tassert(ssix);\n\t\t\t\t\tssix->subsegments[cur_index].ranges[0].level = 1;\n\t\t\t\t\tssix->subsegments[cur_index].ranges[0].range_size = moof_get_first_sap_end(movie->moof);\n\n\t\t\t\t\tlast_sseg_range0_size = (cur_index < ssix->subsegment_count) ? ssix->subsegments[cur_index].ranges[0].range_size : 0;\n\t\t\t\t\tssix->subsegments[cur_index].ranges[1].level = 2;\n\n\t\t\t\t\tremain_size = sidx->refs[cur_index].reference_size - last_sseg_range0_size;\n\t\t\t\t\tssix->subsegments[cur_index].ranges[1].range_size = remain_size;\n\t\t\t\t\tif (remain_size>0xFFFFFF) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso fragment] Remaining subsegment size %d larger than max ssix range size 0xFFFFFF, file might be broken\\n\", remain_size));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (movie->root_ssix)\n\t\t\t\t\t\tssix = NULL;\n\t\t\t\t}\n\n\t\t\t\t/*we are switching subsegment*/\n\t\t\t\tfrag_count--;\n\n\t\t\t\tif (count==frags_per_subseg) {\n\t\t\t\t\tcount = 0;\n\t\t\t\t\tfirst_frag_in_subseg = GF_TRUE;\n\t\t\t\t\tcur_idx++;\n\t\t\t\t}\n\n\t\t\t\t/*switching to next SIDX*/\n\t\t\t\tif ((cur_idx==subseg_per_sidx) || !frag_count) {\n\t\t\t\t\tu32 subseg_dur;\n\t\t\t\t\t/*update last ref duration*/\n\n\t\t\t\t\t//get next segment earliest cts - if estimation failed, use ref_track_next_cts\n\t\t\t\t\tif ((next_earliest_cts==-1) || (next_earliest_cts < prev_earliest_cts))  {\n\t\t\t\t\t\tu64 next_cts;\n\t\t\t\t\t\tif (gf_list_count(movie->moof_list)) {\n\t\t\t\t\t\t\tnext_cts = get_presentation_time( ref_track_decode_time + sidx_dur + cur_dur + moof_get_earliest_cts((GF_MovieFragmentBox*)gf_list_get(movie->moof_list, 0), referenceTrackID), ts_shift);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnext_cts = get_presentation_time( ref_track_next_cts, ts_shift);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsubseg_dur = (u32) (next_cts - prev_earliest_cts);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsubseg_dur = (u32) (next_earliest_cts - prev_earliest_cts);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (movie->root_sidx) {\n\t\t\t\t\t\tsidx->refs[idx_offset].subsegment_duration = subseg_dur;\n\t\t\t\t\t}\n\t\t\t\t\t/*if daisy chain and not the last sidx, we have an extra entry at the end*/\n\t\t\t\t\telse if (daisy_chain_sidx && (nb_subsegs>1)) {\n\t\t\t\t\t\tsidx->refs[sidx->nb_refs - 2].subsegment_duration = subseg_dur;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsidx->refs[sidx->nb_refs-1].subsegment_duration = subseg_dur;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (root_sidx) {\n\n\t\t\t\t\t\troot_sidx->refs[sidx_idx].subsegment_duration += subseg_dur;\n\n\t\t\t\t\t\troot_sidx->refs[sidx_idx].reference_size = (u32) (last_pos - local_sidx_start);\n\t\t\t\t\t\tif (!sidx_idx) {\n\t\t\t\t\t\t\troot_sidx->earliest_presentation_time = sidx->earliest_presentation_time;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsidx_rewrite(sidx, movie->editFileMap->bs, local_sidx_start, ssix);\n\t\t\t\t\t\tgf_isom_box_del((GF_Box*)sidx);\n\t\t\t\t\t\tsidx = NULL;\n\t\t\t\t\t} else if (daisy_chain_sidx) {\n\t\t\t\t\t\tSIDXEntry *entry = (SIDXEntry*)gf_list_last(daisy_sidx);\n\t\t\t\t\t\tentry->end_offset = last_pos;\n\t\t\t\t\t\tnb_subsegs--;\n\t\t\t\t\t\tsidx = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tsidx_dur += cur_dur;\n\t\t\t\t\tcur_dur = 0;\n\t\t\t\t\tcount = 0;\n\t\t\t\t\tcur_idx=0;\n\t\t\t\t\tif (movie->root_sidx)\n\t\t\t\t\t\tmovie->root_sidx_index++;\n\t\t\t\t\tsidx_idx++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (movie->moof->moof_data_len) {\n\t\t\tif (!defer_moofs) defer_moofs = gf_list_new();\n\t\t\tgf_list_add(defer_moofs, movie->moof);\n\t\t} else {\n\t\t\tgf_isom_box_del((GF_Box *) movie->moof);\n\t\t}\n\t\tmovie->moof = NULL;\n\t}\n\tmovie->in_sidx_write = GF_FALSE;\n\n\t/*append segment marker box*/\n\tif (!defer_moofs && segment_marker_4cc) {\n\t\tgf_bs_write_u32(movie->editFileMap->bs, 8);\t//write size field\n\t\tgf_bs_write_u32(movie->editFileMap->bs, segment_marker_4cc); //write box type field\n\t}\n\n\tif (movie->root_sidx) {\n\t\tif (last_segment && !movie->dyn_root_sidx) {\n\t\t\tassert(movie->root_sidx_index == movie->root_sidx->nb_refs);\n\n\t\t\tsidx_rewrite(movie->root_sidx, movie->editFileMap->bs, movie->root_sidx_offset, movie->root_ssix);\n\t\t\tgf_isom_box_del((GF_Box*) movie->root_sidx);\n\t\t\tmovie->root_sidx = NULL;\n\n\t\t\tif (movie->root_ssix) {\n\t\t\t\tgf_isom_box_del((GF_Box*)movie->root_ssix);\n\t\t\t\tmovie->root_ssix = NULL;\n\t\t\t}\n\t\t}\n\t\tif (ssix)\n\t\t\tgf_isom_box_del((GF_Box*)ssix);\n\n\t\tcompute_seg_size(movie, out_seg_size);\n\t\tgoto exit;\n\t}\n\n\tif (sidx) {\n\t\tassert(!root_sidx);\n\t\tsidx_rewrite(sidx, movie->editFileMap->bs, sidx_start, ssix);\n\t\tgf_isom_box_del((GF_Box*)sidx);\n\t}\n\tif (ssix) {\n\t\tgf_isom_box_del((GF_Box*)ssix);\n\t\tssix = NULL;\n\t}\n\n\tif (daisy_sidx) {\n\t\tu32 i, j;\n\t\tu64 last_entry_end_offset = 0;\n\n\t\tcount = gf_list_count(daisy_sidx);\n\t\tfor (i=count; i>1; i--) {\n\t\t\tSIDXEntry *entry = (SIDXEntry*)gf_list_get(daisy_sidx, i-2);\n\t\t\tSIDXEntry *next_entry = (SIDXEntry*)gf_list_get(daisy_sidx, i-1);\n\n\t\t\tif (!last_entry_end_offset) {\n\t\t\t\tlast_entry_end_offset = next_entry->end_offset;\n\t\t\t\t/*rewrite last sidx*/\n\t\t\t\tsidx_rewrite(next_entry->sidx, movie->editFileMap->bs, next_entry->start_offset, NULL);\n\t\t\t}\n\t\t\t/*copy over SAP info for last item (which points to next item !)*/\n\t\t\tentry->sidx->refs[entry->sidx->nb_refs-1] = next_entry->sidx->refs[0];\n\t\t\t/*and rewrite reference type, size and dur*/\n\t\t\tentry->sidx->refs[entry->sidx->nb_refs-1].reference_type = GF_TRUE;\n\t\t\tentry->sidx->refs[entry->sidx->nb_refs-1].reference_size = (u32) (last_entry_end_offset - next_entry->start_offset);\n\t\t\tentry->sidx->refs[entry->sidx->nb_refs-1].subsegment_duration = 0;\n\t\t\tfor (j=0; j<next_entry->sidx->nb_refs; j++) {\n\t\t\t\tentry->sidx->refs[entry->sidx->nb_refs-1].subsegment_duration += next_entry->sidx->refs[j].subsegment_duration;\n\t\t\t}\n\t\t\tsidx_rewrite(entry->sidx, movie->editFileMap->bs, entry->start_offset, NULL);\n\t\t}\n\t\twhile (gf_list_count(daisy_sidx)) {\n\t\t\tSIDXEntry *entry = (SIDXEntry*)gf_list_last(daisy_sidx);\n\t\t\tgf_isom_box_del((GF_Box*)entry->sidx);\n\t\t\tgf_free(entry);\n\t\t\tgf_list_rem_last(daisy_sidx);\n\t\t}\n\t\tgf_list_del(daisy_sidx);\n\t}\n\tif (root_sidx) {\n\t\tsidx_rewrite(root_sidx, movie->editFileMap->bs, sidx_start, NULL);\n\t\tgf_isom_box_del((GF_Box*)root_sidx);\n\t}\n\n\tif ((root_sidx || sidx) && !daisy_chain_sidx) {\n\t\tif (index_start_range) *index_start_range = sidx_start;\n\t\tif (index_end_range) *index_end_range = sidx_end - 1;\n\t}\n\n\tif (movie->append_segment) {\n\t\tchar bloc[1024];\n\t\tu32 seg_size = (u32) gf_bs_get_size(movie->editFileMap->bs);\n\t\tgf_bs_seek(movie->editFileMap->bs, 0);\n\t\twhile (seg_size) {\n\t\t\tu32 size = gf_bs_read_data(movie->editFileMap->bs, bloc, (seg_size>1024) ? 1024 : seg_size);\n\t\t\tgf_bs_write_data(movie->movieFileMap->bs, bloc, size);\n\t\t\tseg_size -= size;\n\t\t}\n\t\tgf_isom_datamap_del(movie->editFileMap);\n\t\tmovie->editFileMap = gf_isom_fdm_new_temp(NULL);\n\t} else if (close_segment_handle == GF_TRUE) {\n\t\tgf_isom_datamap_del(movie->editFileMap);\n\t\tmovie->editFileMap = NULL;\n\t}\n\tcompute_seg_size(movie, out_seg_size);\n\nexit:\n\tif (movie->editFileMap && (orig_bs != movie->editFileMap->bs)) {\n\t\tu32 tmpsize;\n\t\tgf_bs_get_content_no_truncate(movie->editFileMap->bs, &movie->block_buffer, &tmpsize, &movie->block_buffer_size);\n\t\tgf_bs_del(movie->editFileMap->bs);\n\t\tmovie->editFileMap->bs = orig_bs;\n\t}\n\t//flush all defered\n\tif (defer_moofs) {\n\t\twhile (gf_list_count(defer_moofs)) {\n\t\t\tmovie->moof = gf_list_pop_front(defer_moofs);\n\t\t\tmovie->on_block_out(movie->on_block_out_usr_data, movie->moof->moof_data, movie->moof->moof_data_len, NULL, 0);\n\t\t\tif (out_seg_size) *out_seg_size += movie->moof->moof_data_len;\n\n\t\t\tflush_ref_samples(movie, out_seg_size, segment_marker_4cc ? GF_TRUE : GF_FALSE);\n\n\t\t\tgf_free(movie->moof->moof_data);\n\t\t\tgf_isom_box_del((GF_Box *) movie->moof);\n\t\t\tmovie->moof = NULL;\n\t\t}\n\t\tgf_list_del(defer_moofs);\n\n\t\tif (segment_marker_4cc) {\n\t\t\tchar seg[8];\n\t\t\tif (movie->on_last_block_start)\n\t\t\t\tmovie->on_last_block_start(movie->on_block_out_usr_data);\n\n\t\t\tseg[0] = seg[1] = seg[2] = 0;\n\t\t\tseg[3] = 9;\n\t\t\tseg[4] = (segment_marker_4cc>>24) & 0xFF;\n\t\t\tseg[5] = (segment_marker_4cc>>16) & 0xFF;\n\t\t\tseg[6] = (segment_marker_4cc>>8) & 0xFF;\n\t\t\tseg[7] = (segment_marker_4cc) & 0xFF;\n\t\t\tmovie->on_block_out(movie->on_block_out_usr_data, seg, 8, NULL, 0);\n\t\t\tif (out_seg_size)\n\t\t\t\t*out_seg_size += 8;\n\t\t}\n\t\tgf_bs_seek(movie->editFileMap->bs, 0);\n\t}\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_isom_flush_sidx(GF_ISOFile *movie, u32 sidx_max_size, Bool force_v1)\n{\n\tGF_BitStream *bs;\n\tGF_Err e;\n\tu32 size;\n\t//and only at setup\n\tif (!movie || !(movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY) ) return GF_BAD_PARAM;\n\tif (movie->openMode != GF_ISOM_OPEN_WRITE) return GF_ISOM_INVALID_MODE;\n\n\tif (! movie->on_block_out) return GF_BAD_PARAM;\n\tif (! movie->root_sidx) return GF_BAD_PARAM;\n\n\tif (!movie->block_buffer_size) movie->block_buffer_size = movie->on_block_out_block_size;\n\tbs = gf_bs_new_cbk_buffer(isom_on_block_out, movie, movie->block_buffer, movie->block_buffer_size);\n\tgf_bs_prevent_dispatch(bs, GF_TRUE);\n\t\n\tassert(movie->root_sidx_index == movie->root_sidx->nb_refs);\n\n\tif (force_v1)\n\t\tmovie->root_sidx->version = 1;\n\t\t\n\te = gf_isom_box_size((GF_Box*)movie->root_sidx);\n\tsize = (u32) movie->root_sidx->size;\n\tif (movie->root_ssix) {\n\t\te = gf_isom_box_size((GF_Box*)movie->root_ssix);\n\t\tsize += (u32) movie->root_ssix->size;\n\t\tmovie->root_sidx->first_offset = (u32) movie->root_ssix->size;\n\t}\n\n\tif (sidx_max_size && (size > sidx_max_size) ) {\n#ifndef GPAC_DISABLE_LOG\n\t\tu32 orig_seg_count = movie->root_sidx->nb_refs;\n#endif\n\t\t//trash 8 bytes to be able to write a free box before\n\t\tsidx_max_size -= 8;\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso fragment] SIDX size %d is larger than allocated SIDX block %d, merging final segments\\n\", movie->root_sidx->size, sidx_max_size));\n\t\twhile (movie->root_sidx->nb_refs>2) {\n\t\t\tmovie->root_sidx->refs[movie->root_sidx->nb_refs-2].subsegment_duration += movie->root_sidx->refs[movie->root_sidx->nb_refs-1].subsegment_duration;\n\t\t\tmovie->root_sidx->refs[movie->root_sidx->nb_refs-2].reference_size += movie->root_sidx->refs[movie->root_sidx->nb_refs-1].reference_size;\n\t\t\tmovie->root_sidx->nb_refs--;\n\t\t\tif (movie->root_ssix) {\n\t\t\t\tmovie->root_ssix->subsegments[movie->root_ssix->subsegment_count-2].ranges[1].range_size += movie->root_ssix->subsegments[movie->root_ssix->subsegment_count-1].ranges[0].range_size;\n\t\t\t\tmovie->root_ssix->subsegments[movie->root_ssix->subsegment_count-2].ranges[1].range_size += movie->root_ssix->subsegments[movie->root_ssix->subsegment_count-1].ranges[1].range_size;\n\t\t\t\tmovie->root_ssix->subsegment_count--;\n\t\t\t}\n\n\t\t\te = gf_isom_box_size((GF_Box*)movie->root_sidx);\n\t\t\tsize = (u32) movie->root_sidx->size;\n\t\t\tif (movie->root_ssix) {\n\t\t\t\te = gf_isom_box_size((GF_Box*)movie->root_ssix);\n\t\t\t\tsize += (u32) movie->root_ssix->size;\n\t\t\t\tmovie->root_sidx->first_offset = (u32) movie->root_ssix->size;\n\t\t\t}\n\n\t\t\tif (size < sidx_max_size) break;\n\t\t}\n\t\tif (size > sidx_max_size) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso fragment] SIDX size %d is larger than allocated SIDX block and no more segments to merge\\n\", size, sidx_max_size));\n\t\t\treturn GF_IO_ERR;\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso fragment] Merged %d segments in SIDX to fit allocated block, remaining segments %d\\n\", orig_seg_count - movie->root_sidx->nb_refs, movie->root_sidx->nb_refs));\n\t\t}\n\t}\n\tif (!e) {\n\t\tif (movie->root_ssix) {\n\t\t\tgf_isom_box_size((GF_Box *) movie->root_ssix);\n\n\t\t\tif (movie->compress_mode>=GF_ISOM_COMP_MOOF_SSIX) {\n\t\t\t\tu32 ssix_comp_size;\n\t\t\t\t//compute ssix compressed size by using NULL destination bitstream\n\t\t\t\t//not really optimum since we compress twice the ssix, to optimize ...\n\t\t\t\te = gf_isom_write_compressed_box(movie, (GF_Box *) movie->root_ssix, GF_4CC('!', 's', 's', 'x'), NULL, &ssix_comp_size);\n\t\t\t\tmovie->root_sidx->first_offset = ssix_comp_size;\n\t\t\t} else {\n\t\t\t\tmovie->root_sidx->first_offset = (u32) movie->root_ssix->size;\n\t\t\t}\n\t\t}\n\t\tif (!e) {\n\t\t\tif (movie->compress_mode>=GF_ISOM_COMP_MOOF_SIDX) {\n\t\t\t\te = gf_isom_write_compressed_box(movie, (GF_Box *) movie->root_sidx, GF_4CC('!', 's', 'i', 'x'), bs, NULL);\n\t\t\t} else {\n\t\t\t\te = gf_isom_box_write((GF_Box *) movie->root_sidx, bs);\n\t\t\t}\n\t\t}\n\n\t\tif (!e && movie->root_ssix) {\n\t\t\tif (movie->compress_mode>=GF_ISOM_COMP_MOOF_SSIX) {\n\t\t\t\te = gf_isom_write_compressed_box(movie, (GF_Box *) movie->root_ssix, GF_4CC('!', 's', 's', 'x'), bs, NULL);\n\t\t\t} else {\n\t\t\t\te = gf_isom_box_write((GF_Box *) movie->root_ssix, bs);\n\t\t\t}\n\t\t}\n\t}\n\n\tgf_isom_box_del((GF_Box*) movie->root_sidx);\n\tmovie->root_sidx = NULL;\n\tif (movie->root_ssix) {\n\t\tgf_isom_box_del((GF_Box*) movie->root_ssix);\n\t\tmovie->root_ssix = NULL;\n\t}\n\n\tgf_bs_get_content_no_truncate(bs, &movie->block_buffer, &size, &movie->block_buffer_size);\n\tgf_bs_del(bs);\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_isom_close_fragments(GF_ISOFile *movie)\n{\n\tif (movie->use_segments) {\n\t\treturn gf_isom_close_segment(movie, 0, 0, 0, 0, 0, 0, GF_FALSE, GF_FALSE, 1, 0, NULL, NULL, NULL);\n\t} else {\n\t\treturn StoreFragment(movie, GF_FALSE, 0, NULL, GF_TRUE);\n\t}\n}\n\nGF_EXPORT\nGF_Err gf_isom_start_segment(GF_ISOFile *movie, const char *SegName, Bool memory_mode)\n{\n\tGF_Err e;\n\t//and only at setup\n\tif (!movie || !(movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY) ) return GF_BAD_PARAM;\n\tif (movie->openMode != GF_ISOM_OPEN_WRITE) return GF_ISOM_INVALID_MODE;\n\n\tif (gf_list_count(movie->moof_list))\n\t\treturn GF_BAD_PARAM;\n\n\tmovie->segment_bs = NULL;\n\tmovie->append_segment = GF_FALSE;\n\t/*update segment file*/\n\tif (SegName || !gf_isom_get_filename(movie)) {\n\t\tif (movie->editFileMap) gf_isom_datamap_del(movie->editFileMap);\n\t\te = gf_isom_datamap_new(SegName, NULL, GF_ISOM_DATA_MAP_WRITE, &movie->editFileMap);\n\t\tmovie->segment_start = 0;\n\t\tmovie->write_styp = 1;\n\t\tif (e) return e;\n\t} else {\n\t\tassert(gf_list_count(movie->moof_list) == 0);\n\t\tmovie->segment_start = gf_bs_get_position(movie->editFileMap->bs);\n\t\t/*if movieFileMap is not null, we are concatenating segments to the original movie, force a copy*/\n\t\tif (movie->movieFileMap)\n\t\t\tmovie->append_segment = GF_TRUE;\n\t\tmovie->write_styp = 0;\n\t}\n\n\t/*create a memory bitstream for all file IO until final flush*/\n\tif (memory_mode) {\n\t\tmovie->segment_bs = movie->editFileMap->bs;\n\t\tmovie->editFileMap->bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_fragment_reference_time(GF_ISOFile *movie, GF_ISOTrackID reference_track_ID, u64 ntp, u64 timestamp)\n{\n\tif (!movie || !movie->moof) return GF_BAD_PARAM;\n\tmovie->moof->reference_track_ID = reference_track_ID;\n\tmovie->moof->ntp = ntp;\n\tmovie->moof->timestamp = timestamp;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_traf_mss_timeext(GF_ISOFile *movie, GF_ISOTrackID reference_track_ID, u64 ntp_in_track_timescale, u64 traf_duration_in_track_timescale)\n{\n\tu32 i;\n\tif (!movie || !movie->moof)\n\t\treturn GF_BAD_PARAM;\n\tfor (i=0; i<gf_list_count(movie->moof->TrackList); i++) {\n\t\tGF_TrackFragmentBox *traf = (GF_TrackFragmentBox*)gf_list_get(movie->moof->TrackList, i);\n\t\tif (!traf)\n\t\t\treturn GF_BAD_PARAM;\n\t\tif (traf->tfxd)\n\t\t\tgf_isom_box_del_parent(&traf->child_boxes, (GF_Box*)traf->tfxd);\n\t\ttraf->tfxd = (GF_MSSTimeExtBox *)gf_isom_box_new_parent(&traf->child_boxes, GF_ISOM_BOX_UUID_TFXD);\n\t\tif (!traf->tfxd) return GF_OUT_OF_MEM;\n\t\ttraf->tfxd->absolute_time_in_track_timescale = ntp_in_track_timescale;\n\t\ttraf->tfxd->fragment_duration_in_track_timescale = traf_duration_in_track_timescale;\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_start_fragment(GF_ISOFile *movie, GF_ISOStartFragmentFlags flags)\n{\n\tu32 i, count;\n\tGF_TrackExtendsBox *trex;\n\tGF_TrackFragmentBox *traf;\n\tGF_Err e;\n\tBool moof_first = (flags & GF_ISOM_FRAG_MOOF_FIRST) ? GF_TRUE : GF_FALSE;\n#ifdef GF_ENABLE_CTRN\n\tBool use_ctrn = (flags & GF_ISOM_FRAG_USE_COMPACT) ? GF_TRUE : GF_FALSE;\n#endif\n\n\t//and only at setup\n\tif (!movie || !(movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY) )\n\t\treturn GF_BAD_PARAM;\n\tif (movie->openMode != GF_ISOM_OPEN_WRITE) return GF_ISOM_INVALID_MODE;\n\n\tcount = gf_list_count(movie->moov->mvex->TrackExList);\n\tif (!count)\n\t\treturn GF_BAD_PARAM;\n\n\t/*always force cached mode when writing movie segments*/\n\tif (movie->use_segments) moof_first = GF_TRUE;\n\tmovie->moof_first = moof_first;\n\n\t//store existing fragment\n\tif (movie->moof) {\n\t\te = StoreFragment(movie, movie->use_segments ? GF_TRUE : GF_FALSE, 0, NULL, movie->use_segments ? GF_TRUE : (movie->on_block_out ? GF_TRUE : GF_FALSE));\n\t\tif (e) return e;\n\t}\n\n\t//create new fragment\n\tmovie->moof = (GF_MovieFragmentBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_MOOF);\n\tif (!movie->moof) return GF_OUT_OF_MEM;\n\tmovie->moof->mfhd = (GF_MovieFragmentHeaderBox *) gf_isom_box_new_parent(&movie->moof->child_boxes, GF_ISOM_BOX_TYPE_MFHD);\n\tif (!movie->moof->mfhd) return GF_OUT_OF_MEM;\n\tmovie->moof->mfhd->sequence_number = movie->NextMoofNumber;\n\tmovie->NextMoofNumber ++;\n\tif (movie->use_segments || movie->on_block_out)\n\t\tgf_list_add(movie->moof_list, movie->moof);\n\n\n\t/*remember segment offset*/\n\tmovie->moof->fragment_offset = gf_bs_get_position(movie->editFileMap->bs);\n\n\t/*prepare MDAT*/\n\tgf_bs_write_u32(movie->editFileMap->bs, 0);\n\tgf_bs_write_u32(movie->editFileMap->bs, GF_ISOM_BOX_TYPE_MDAT);\n\n\t//we create a TRAF for each setup track, unused ones will be removed at store time\n\tfor (i=0; i<count; i++) {\n\t\ttrex = (GF_TrackExtendsBox*)gf_list_get(movie->moov->mvex->TrackExList, i);\n\t\ttraf = (GF_TrackFragmentBox *) gf_isom_box_new_parent(&movie->moof->child_boxes, GF_ISOM_BOX_TYPE_TRAF);\n\t\tif (!traf) return GF_OUT_OF_MEM;\n\t\ttraf->trex = trex;\n\t\ttraf->tfhd = (GF_TrackFragmentHeaderBox *) gf_isom_box_new_parent(&traf->child_boxes, GF_ISOM_BOX_TYPE_TFHD);\n\t\tif (!traf->tfhd) return GF_OUT_OF_MEM;\n\t\ttraf->tfhd->trackID = trex->trackID;\n\t\t//add 8 bytes (MDAT size+type) to avoid the data_offset in the first trun\n\t\ttraf->tfhd->base_data_offset = movie->moof->fragment_offset + 8;\n#ifdef GF_ENABLE_CTRN\n\t\ttraf->use_ctrn = use_ctrn;\n\t\tif (trex->inherit_from_traf_id)\n\t\t\ttraf->use_inherit = GF_TRUE;\n#endif\n\t\tgf_list_add(movie->moof->TrackList, traf);\n\n\t\tif (movie->mfra) {\n\t\t\tGF_TrackFragmentRandomAccessBox *tfra;\n\t\t\tGF_RandomAccessEntry *raf;\n\t\t\tif (!traf->trex->tfra) {\n\t\t\t\ttfra = (GF_TrackFragmentRandomAccessBox *)gf_isom_box_new_parent(&movie->mfra->child_boxes, GF_ISOM_BOX_TYPE_TFRA);\n\t\t\t\tif (!tfra) return GF_OUT_OF_MEM;\n\t\t\t\ttfra->track_id = traf->trex->trackID;\n\t\t\t\ttfra->traf_bits = 8;\n\t\t\t\ttfra->trun_bits = 8;\n\t\t\t\ttfra->sample_bits = 8;\n\t\t\t\tgf_list_add(movie->mfra->tfra_list, tfra);\n\t\t\t\ttraf->trex->tfra = tfra;\n\t\t\t}\n\t\t\ttfra = traf->trex->tfra;\n\t\t\ttfra->entries = (GF_RandomAccessEntry *)gf_realloc(tfra->entries, (tfra->nb_entries+1)*sizeof(GF_RandomAccessEntry));\n\t\t\ttfra->nb_entries++;\n\t\t\traf = &tfra->entries[tfra->nb_entries-1];\n\t\t\traf->sample_number = 1;\n\t\t\traf->time = 0;\n\t\t\traf->traf_number = i+1;\n\t\t\t//trun number is set once we fond a sync\n\t\t\traf->trun_number = 0;\n\t\t\tif (!strcmp(movie->fileName, \"_gpac_isobmff_redirect\")) {\n\t\t\t\traf->moof_offset = movie->fragmented_file_pos;\n\t\t\t} else {\n\t\t\t\traf->moof_offset = movie->moof->fragment_offset;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err gf_isom_set_fragment_template(GF_ISOFile *movie, u8 *tpl_data, u32 tpl_size, Bool *has_tfdt, GF_SegmentIndexBox **out_sidx)\n{\n\tGF_BitStream *bs;\n\tGF_Err e=GF_OK;\n\tif (out_sidx) *out_sidx = NULL;\n\tif (!movie->moof) return GF_BAD_PARAM;\n\n\tbs = gf_bs_new(tpl_data, tpl_size, GF_BITSTREAM_READ);\n\twhile (gf_bs_available(bs)) {\n\t\tGF_Box *a;\n\t\te = gf_isom_box_parse(&a, bs);\n\t\tif (e) break;\n\t\tif (a->type==GF_ISOM_BOX_TYPE_STYP) {\n\t\t\tif (movie->brand) {\n\t\t\t\tgf_list_del_item(movie->TopBoxes, movie->brand);\n\t\t\t\tgf_isom_box_del((GF_Box *)movie->brand);\n\t\t\t}\n\t\t\tmovie->brand = (GF_FileTypeBox *) a;\n\t\t\tgf_list_add(movie->TopBoxes, movie->brand);\n\t\t\tmovie->write_styp = 2;\n\t\t\tcontinue;\n\t\t}\n\t\tif (a->type==GF_ISOM_BOX_TYPE_OTYP) {\n\t\t\tif (movie->otyp) {\n\t\t\t\tgf_list_del_item(movie->TopBoxes, movie->otyp);\n\t\t\t\tgf_isom_box_del(movie->otyp);\n\t\t\t}\n\t\t\tmovie->otyp = (GF_Box *) a;\n\t\t\tgf_list_add(movie->TopBoxes, movie->otyp);\n\t\t\tcontinue;\n\t\t}\n\t\tif (a->type==GF_ISOM_BOX_TYPE_MOOF) {\n\t\t\tu32 i, count, j, nb_trex;\n\t\t\ts32 idx;\n\t\t\tBool single_track=GF_FALSE;\n\t\t\tGF_MovieFragmentBox *moof = (GF_MovieFragmentBox *)a;\n\n\t\t\tmoof->fragment_offset = movie->moof->fragment_offset;\n\t\t\tnb_trex = gf_list_count(movie->moov->mvex->TrackExList);\n\t\t\tcount = gf_list_count(moof->TrackList);\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tGF_TrackFragmentBox *traf = gf_list_get(moof->TrackList, i);\n\t\t\t\tGF_TrackBox *trak = traf->tfhd ? gf_isom_get_track_from_id(movie->moov, traf->tfhd->trackID) : NULL;\n\t\t\t\tif (traf->tfhd && !trak && !single_track && (gf_list_count(movie->moov->trackList)==1)) {\n\t\t\t\t\ttrak = gf_list_get(movie->moov->trackList, 0);\n\t\t\t\t\tsingle_track = GF_TRUE;\n\t\t\t\t\ttraf->tfhd->trackID = trak->Header->trackID;\n\t\t\t\t}\n\t\t\t\tfor (j=0; j<nb_trex && trak; j++) {\n\t\t\t\t\tGF_TrackExtendsBox *trex = gf_list_get(movie->moov->mvex->TrackExList, j);\n\t\t\t\t\tif (trex->trackID == traf->tfhd->trackID) {\n\t\t\t\t\t\ttraf->trex = trex;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!trak || !traf->trex) {\n\t\t\t\t\tgf_list_rem(moof->TrackList, i);\n\t\t\t\t\ti--;\n\t\t\t\t\tcount--;\n\t\t\t\t\tgf_isom_box_del((GF_Box*)traf);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\ttraf->tfhd->base_data_offset = movie->moof->fragment_offset + 8;\n\t\t\t\tif (traf->tfdt && has_tfdt)\n\t\t\t\t\t*has_tfdt = GF_TRUE;\n\t\t\t}\n\t\t\t//remove old moof and switch with this one\n\t\t\tidx = gf_list_find(movie->moof_list, movie->moof);\n\t\t\tif (idx>=0) {\n\t\t\t\tgf_list_rem(movie->moof_list, idx);\n\t\t\t\tgf_list_add(movie->moof_list, moof);\n\t\t\t}\n\t\t\tgf_isom_box_del((GF_Box *)movie->moof);\n\t\t\tmovie->moof = moof;\n\t\t\tcontinue;\n\t\t}\n\t\tif (a->type==GF_ISOM_BOX_TYPE_SIDX) {\n\t\t\tif (out_sidx && !*out_sidx) {\n\t\t\t\t*out_sidx = (GF_SegmentIndexBox *) a;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tgf_isom_box_del(a);\n\t}\n\tgf_bs_del(bs);\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_isom_fragment_add_sample_ex(GF_ISOFile *movie, GF_ISOTrackID TrackID, const GF_ISOSample *sample, u32 DescIndex,\n                                   u32 Duration, u8 PaddingBits, u16 DegradationPriority, Bool redundant_coding, void **ref, u32 ref_offset)\n{\n\tu32 count, buffer_size;\n\tu8 *buffer;\n\tu64 pos;\n\tGF_ISOSample *od_sample = NULL;\n\tGF_TrunEntry ent, *prev_ent;\n\tGF_TrackFragmentBox *traf, *traf_2;\n\tGF_TrackFragmentRunBox *trun;\n\n\tif (!movie->moof || !(movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY) || !sample)\n\t\treturn GF_BAD_PARAM;\n\n\ttraf = gf_isom_get_traf(movie, TrackID);\n\tif (!traf)\n\t\treturn GF_BAD_PARAM;\n\n\tif (!traf->tfhd->sample_desc_index)\n\t\ttraf->tfhd->sample_desc_index = DescIndex ? DescIndex : traf->trex->def_sample_desc_index;\n\n\tpos = gf_bs_get_position(movie->editFileMap->bs);\n\n\n\t//WARNING: we change stream description, create a new TRAF\n\tif ( DescIndex && (traf->tfhd->sample_desc_index != DescIndex)) {\n\t\t//if we're caching flush the current run\n\t\tif (traf->DataCache && !traf->use_sample_interleave) {\n\t\t\tcount = gf_list_count(traf->TrackRuns);\n\t\t\tif (count) {\n\t\t\t\ttrun = (GF_TrackFragmentRunBox *)gf_list_get(traf->TrackRuns, count-1);\n\t\t\t\ttrun->data_offset = (u32) (pos - movie->moof->fragment_offset - 8);\n\t\t\t\tgf_bs_get_content(trun->cache, &buffer, &buffer_size);\n\t\t\t\tgf_bs_write_data(movie->editFileMap->bs, buffer, buffer_size);\n\t\t\t\tgf_bs_del(trun->cache);\n\t\t\t\ttrun->cache = NULL;\n\t\t\t\tgf_free(buffer);\n\t\t\t}\n\t\t}\n\t\ttraf_2 = (GF_TrackFragmentBox *) gf_isom_box_new_parent(&movie->moof->child_boxes, GF_ISOM_BOX_TYPE_TRAF);\n\t\tif (!traf_2) return GF_OUT_OF_MEM;\n\t\ttraf_2->trex = traf->trex;\n\t\ttraf_2->tfhd = (GF_TrackFragmentHeaderBox *) gf_isom_box_new_parent(&traf_2->child_boxes, GF_ISOM_BOX_TYPE_TFHD);\n\t\tif (!traf_2->tfhd) return GF_OUT_OF_MEM;\n\t\ttraf_2->tfhd->trackID = traf->tfhd->trackID;\n\t\t//keep the same offset\n\t\ttraf_2->tfhd->base_data_offset = movie->moof->fragment_offset + 8;\n\t\tgf_list_add(movie->moof->TrackList, traf_2);\n\n\t\t//duplicate infos\n\t\ttraf_2->IFrameSwitching = traf->IFrameSwitching;\n\t\ttraf_2->use_sample_interleave = traf->use_sample_interleave;\n\t\ttraf_2->interleave_id = traf->interleave_id;\n\t\ttraf_2->truns_first = traf->truns_first;\n\t\ttraf_2->truns_v1 = traf->truns_v1;\n\t\ttraf_2->large_tfdt = traf->large_tfdt;\n\t\ttraf_2->DataCache  = traf->DataCache;\n\t\ttraf_2->tfhd->sample_desc_index  = DescIndex;\n\n\t\t//switch them ...\n\t\ttraf = traf_2;\n\t}\n\n\tpos = movie->moof->trun_ref_size ? (8+movie->moof->trun_ref_size) : gf_bs_get_position(movie->editFileMap->bs);\n\n\t//check if we need a new trun entry\n\tcount = (traf->use_sample_interleave && traf->force_new_trun) ? 0 : gf_list_count(traf->TrackRuns);\n\tif (count) {\n\t\ttrun = (GF_TrackFragmentRunBox *)gf_list_get(traf->TrackRuns, count-1);\n\t\t//check data offset when no caching as trun entries shall ALWAYS be contiguous samples\n\t\tif (!traf->DataCache && (movie->moof->fragment_offset + 8 + trun->data_offset + trun->run_size != pos) )\n\t\t\tcount = 0;\n\n\t\t//check I-frame detection\n\t\tif (traf->IFrameSwitching && sample->IsRAP)\n\t\t\tcount = 0;\n\n\t\tif (traf->DataCache && (traf->DataCache==trun->sample_count) && !traf->use_sample_interleave)\n\t\t\tcount = 0;\n\n\t\tif (traf->force_new_trun)\n\t\t\tcount = 0;\n\n\t\t//if data cache is on and we're changing TRUN, store the cache and update data offset\n\t\tif (!count && traf->DataCache && !traf->use_sample_interleave) {\n\t\t\ttrun->data_offset = (u32) (pos - movie->moof->fragment_offset - 8);\n\t\t\tgf_bs_get_content(trun->cache, &buffer, &buffer_size);\n\t\t\tgf_bs_write_data(movie->editFileMap->bs, buffer, buffer_size);\n\t\t\tgf_bs_del(trun->cache);\n\t\t\ttrun->cache = NULL;\n\t\t\tgf_free(buffer);\n\t\t}\n\t}\n\ttraf->force_new_trun = 0;\n\n\t//new run\n\tif (!count) {\n\t\ttrun = (GF_TrackFragmentRunBox *) gf_isom_box_new_parent(&traf->child_boxes, GF_ISOM_BOX_TYPE_TRUN);\n\t\tif (!trun) return GF_OUT_OF_MEM;\n\t\t//store data offset (we have the 8 btyes offset of the MDAT)\n\t\ttrun->data_offset = (u32) (pos - movie->moof->fragment_offset - 8);\n\t\tgf_list_add(traf->TrackRuns, trun);\n#ifdef GF_ENABLE_CTRN\n\t\ttrun->use_ctrn = traf->use_ctrn;\n\t\ttrun->use_inherit = traf->use_inherit;\n\t\ttrun->ctso_multiplier = traf->trex->def_sample_duration;\n#endif\n\t\ttrun->interleave_id = traf->interleave_id;\n\t\tif (traf->truns_v1)\n\t\t\ttrun->version = 1;\n\n\t\t//if we use data caching, create a bitstream\n\t\tif (traf->DataCache)\n\t\t\ttrun->cache = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t}\n\n\tmemset(&ent, 0, sizeof(GF_TrunEntry));\n\tent.CTS_Offset = sample->CTS_Offset;\n\tent.Duration = Duration;\n\tent.dts = sample->DTS;\n\tent.nb_pack = sample->nb_pack;\n\tent.flags = GF_ISOM_FORMAT_FRAG_FLAGS(PaddingBits, sample->IsRAP, DegradationPriority);\n\tif (sample->IsRAP) {\n\t\tent.flags |= GF_ISOM_GET_FRAG_DEPEND_FLAGS(0, 2, 0, (redundant_coding ? 1 : 0) );\n\t\tent.SAP_type = sample->IsRAP;\n\t}\n\tif (trun->nb_samples) {\n\t\tprev_ent = &trun->samples[trun->nb_samples-1];\n\t} else {\n\t\tprev_ent = NULL;\n\t}\n\n\tif (prev_ent && (prev_ent->dts || !prev_ent->Duration) && sample->DTS) {\n\t\tu32 nsamp = prev_ent->nb_pack ? prev_ent->nb_pack : 1;\n\t\tif (nsamp*prev_ent->Duration != sample->DTS - prev_ent->dts)\n\t\t\tprev_ent->Duration = (u32) (sample->DTS - prev_ent->dts) / nsamp;\n\t}\n\tif (trun->nb_samples >= trun->sample_alloc) {\n\t\ttrun->sample_alloc += 50;\n\t\tif (trun->nb_samples >= trun->sample_alloc) trun->sample_alloc = trun->nb_samples+1;\n\t\ttrun->samples = gf_realloc(trun->samples, sizeof(GF_TrunEntry)*trun->sample_alloc);\n\t\tif (!trun->samples) return GF_OUT_OF_MEM;\n\t}\n\n\t//rewrite OD frames\n\tif (traf->trex->track->Media->handler->handlerType == GF_ISOM_MEDIA_OD) {\n\t\t//this may fail if dependencies are not well done ...\n\t\tMedia_ParseODFrame(traf->trex->track->Media, sample, &od_sample);\n\t\tsample = od_sample;\n\t}\n\n\tent.size = sample->dataLength;\n\ttrun->samples[trun->nb_samples] = ent;\n\ttrun->nb_samples ++;\n\ttrun->run_size += ent.size;\n\n\tif (sample->CTS_Offset<0) {\n\t\ttrun->version = 1;\n\t}\n\ttrun->sample_count += sample->nb_pack ? sample->nb_pack : 1;\n\n\t//finally write the data\n\tif (sample->dataLength) {\n\t\tu32 res = 0;\n\t\tif (!traf->DataCache) {\n\t\t\tif (movie->moof_first && movie->on_block_out && (ref || trun->sample_refs)) {\n\t\t\t\tGF_TrafSampleRef *sref;\n\t\t\t\tif (!trun->sample_refs) trun->sample_refs = gf_list_new();\n\t\t\t\tGF_SAFEALLOC(sref, GF_TrafSampleRef);\n\t\t\t\tif (!sref) return GF_OUT_OF_MEM;\n\t\t\t\tif (ref && *ref && !od_sample) {\n\t\t\t\t\tsref->data = sample->data;\n\t\t\t\t\tsref->len = sample->dataLength;\n\t\t\t\t\tsref->ref = *ref;\n\t\t\t\t\tsref->ref_offset = ref_offset;\n\t\t\t\t\t*ref = NULL;\n\t\t\t\t} else {\n\t\t\t\t\tsref->data = gf_malloc(sample->dataLength);\n\t\t\t\t\tif (!sref->data) {\n\t\t\t\t\t\tgf_free(sref);\n\t\t\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t\t\t}\n\t\t\t\t\tmemcpy(sref->data, sample->data, sample->dataLength);\n\t\t\t\t\tsref->len = sample->dataLength;\n\t\t\t\t}\n\t\t\t\tres = sref->len;\n\t\t\t\ttraf->trun_ref_size += res;\n\t\t\t\tmovie->moof->trun_ref_size += res;\n\t\t\t\tgf_list_add(trun->sample_refs, sref);\n\t\t\t} else {\n\t\t\t\tres = gf_bs_write_data(movie->editFileMap->bs, sample->data, sample->dataLength);\n\t\t\t}\n\t\t} else if (trun->cache) {\n\t\t\tres = gf_bs_write_data(trun->cache, sample->data, sample->dataLength);\n\t\t} else {\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t\tif (res!=sample->dataLength) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso fragment] Could not add a sample with a size of %u bytes\\n\", sample->dataLength));\n\t\t\treturn GF_OUT_OF_MEM;\n\t\t}\n\n\t}\n\tif (od_sample) gf_isom_sample_del(&od_sample);\n\n\tif (traf->trex->tfra) {\n\t\tGF_RandomAccessEntry *raf;\n\t\traf = &traf->trex->tfra->entries[traf->trex->tfra->nb_entries-1];\n\t\t//if sample is sync, store its time and trun number\n\t\tif (!raf->trun_number && sample->IsRAP) {\n\t\t\traf->time = sample->DTS + sample->CTS_Offset;\n\t\t\traf->trun_number = gf_list_count(traf->TrackRuns);\n\t\t\traf->sample_number = trun->sample_count;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_fragment_add_sample(GF_ISOFile *movie, GF_ISOTrackID TrackID, const GF_ISOSample *sample, u32 DescIndex,\n                                   u32 Duration, u8 PaddingBits, u16 DegradationPriority, Bool redundant_coding)\n{\n\treturn gf_isom_fragment_add_sample_ex(movie, TrackID, sample, DescIndex, Duration, PaddingBits, DegradationPriority, redundant_coding, NULL, 0);\n\n}\nGF_EXPORT\nGF_Err gf_isom_fragment_set_cenc_sai(GF_ISOFile *output, GF_ISOTrackID TrackID, u8 *sai_b, u32 sai_b_size, Bool use_subsamples, Bool use_saio_32bit, Bool use_multikey)\n{\n\tGF_CENCSampleAuxInfo *sai;\n\tGF_TrackFragmentBox  *traf = gf_isom_get_traf(output, TrackID);\n\tGF_SampleEncryptionBox *senc;\n\n\tif (!traf)  return GF_BAD_PARAM;\n\n\tif (!traf->sample_encryption) {\n\t\tif (!traf->trex->track->sample_encryption) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[isofile] trying to add CENC SAI without storage box allocated\\n\" ));\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t\tif (traf->trex->track->sample_encryption->type == GF_ISOM_BOX_TYPE_SENC) {\n\t\t\ttraf->sample_encryption = gf_isom_create_samp_enc_box(0, 0);\n\t\t} else {\n\t\t\tGF_SampleEncryptionBox *psec = (GF_SampleEncryptionBox *) traf->trex->track->sample_encryption;\n\t\t\tif (!psec) return GF_ISOM_INVALID_FILE;\n\t\t\ttraf->sample_encryption = gf_isom_create_piff_psec_box(1, 0, psec->AlgorithmID, psec->IV_size, psec->KID);\n\t\t}\n\t\tif (!traf->sample_encryption) return GF_OUT_OF_MEM;\n\t\ttraf->sample_encryption->traf = traf;\n\n\t\tif (!traf->child_boxes) traf->child_boxes = gf_list_new();\n\t\tgf_list_add(traf->child_boxes, traf->sample_encryption);\n\t}\n\tsenc = (GF_SampleEncryptionBox *) traf->sample_encryption;\n\n\tif (!sai_b_size && !sai_b) {\n\t\tgf_isom_cenc_set_saiz_saio(senc, NULL, traf, 0, use_saio_32bit, use_multikey);\n\t\treturn GF_OK;\n\t}\n\n\tGF_SAFEALLOC(sai, GF_CENCSampleAuxInfo);\n\tif (!sai) return GF_OUT_OF_MEM;\n\n\tif (sai_b && sai_b_size) {\n\t\tsai->cenc_data_size = sai_b_size;\n\t\tsai->cenc_data = gf_malloc(sizeof(u8) * sai_b_size);\n\t\tif (!sai->cenc_data) {\n\t\t\tgf_free(sai);\n\t\t\treturn GF_OUT_OF_MEM;\n\t\t}\n\t\tmemcpy(sai->cenc_data, sai_b, sai_b_size);\n\t} else {\n\t\tsai->isNotProtected = 1;\n\t}\n\n\tgf_list_add(senc->samp_aux_info, sai);\n\tif (use_subsamples)\n\t\tsenc->flags = 0x00000002;\n\tif (use_multikey)\n\t\tsenc->version = 1;\n\n\tgf_isom_cenc_set_saiz_saio(senc, NULL, traf, sai->cenc_data_size, use_saio_32bit, use_multikey);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_fragment_append_data_ex(GF_ISOFile *movie, GF_ISOTrackID TrackID, u8 *data, u32 data_size, u8 PaddingBits, void **ref, u32 ref_offset)\n{\n\tu32 count;\n\tu8 rap;\n\tu16 degp;\n\tGF_TrunEntry *ent;\n\tGF_TrackFragmentBox *traf;\n\tGF_TrackFragmentRunBox *trun;\n\tif (!movie->moof || !(movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY) ) return GF_BAD_PARAM;\n\n\ttraf = gf_isom_get_traf(movie, TrackID);\n\tif (!traf || !traf->tfhd->sample_desc_index) return GF_BAD_PARAM;\n\n\t//add TRUN entry\n\tcount = gf_list_count(traf->TrackRuns);\n\tif (!count) return GF_BAD_PARAM;\n\n\ttrun = (GF_TrackFragmentRunBox *)gf_list_get(traf->TrackRuns, count-1);\n\tif (!trun->nb_samples) return GF_BAD_PARAM;\n\tent = &trun->samples[trun->nb_samples-1];\n\tent->size += data_size;\n\ttrun->run_size += data_size;\n\n\trap = GF_ISOM_GET_FRAG_SYNC(ent->flags);\n\tdegp = GF_ISOM_GET_FRAG_DEG(ent->flags);\n\tent->flags = GF_ISOM_FORMAT_FRAG_FLAGS(PaddingBits, rap, degp);\n\n\t//finally write the data\n\tif (!traf->DataCache) {\n\t\tif (movie->moof_first && movie->on_block_out && (ref || trun->sample_refs)) {\n\t\t\tGF_TrafSampleRef *sref;\n\t\t\tif (!trun->sample_refs) trun->sample_refs = gf_list_new();\n\t\t\tGF_SAFEALLOC(sref, GF_TrafSampleRef);\n\t\t\tif (!sref) return GF_OUT_OF_MEM;\n\t\t\tif (ref && *ref) {\n\t\t\t\tsref->data = data;\n\t\t\t\tsref->len = data_size;\n\t\t\t\tsref->ref = *ref;\n\t\t\t\tsref->ref_offset = ref_offset;\n\t\t\t\t*ref = NULL;\n\t\t\t} else {\n\t\t\t\tsref->data = gf_malloc(data_size);\n\t\t\t\tif (!sref->data) {\n\t\t\t\t\tgf_free(sref);\n\t\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t\t}\n\t\t\t\tmemcpy(sref->data, data, data_size);\n\t\t\t\tsref->len = data_size;\n\t\t\t}\n\t\t\ttraf->trun_ref_size += sref->len;\n\t\t\tmovie->moof->trun_ref_size += sref->len;\n\t\t\tgf_list_add(trun->sample_refs, sref);\n\t\t} else {\n\t\t\tgf_bs_write_data(movie->editFileMap->bs, data, data_size);\n\t\t}\n\t} else if (trun->cache) {\n\t\tgf_bs_write_data(trun->cache, data, data_size);\n\t} else {\n\t\treturn GF_BAD_PARAM;\n\t}\n\treturn GF_OK;\n}\nGF_EXPORT\nGF_Err gf_isom_fragment_append_data(GF_ISOFile *movie, GF_ISOTrackID TrackID, u8 *data, u32 data_size, u8 PaddingBits)\n{\n\treturn gf_isom_fragment_append_data_ex(movie, TrackID, data, data_size, PaddingBits, NULL, 0);\n\n}\n\nGF_Err gf_isom_fragment_add_subsample(GF_ISOFile *movie, GF_ISOTrackID TrackID, u32 flags, u32 subSampleSize, u8 priority, u32 reserved, Bool discardable)\n{\n\tu32 i, count, last_sample;\n\tGF_TrackFragmentBox *traf;\n\tGF_SubSampleInformationBox *subs = NULL;\n\tif (!movie->moof || !(movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY) ) return GF_BAD_PARAM;\n\n\ttraf = gf_isom_get_traf(movie, TrackID);\n\tif (!traf || !traf->tfhd->sample_desc_index) return GF_BAD_PARAM;\n\n\t/*compute last sample number in traf*/\n\tlast_sample = 0;\n\tcount = gf_list_count(traf->TrackRuns);\n\tfor (i=0; i<count; i++) {\n\t\tGF_TrackFragmentRunBox *trun = (GF_TrackFragmentRunBox*)gf_list_get(traf->TrackRuns, i);\n\t\tlast_sample += trun->sample_count;\n\t}\n\n\tif (!traf->sub_samples) {\n\t\ttraf->sub_samples = gf_list_new();\n\t}\n\tcount = gf_list_count(traf->sub_samples);\n\tfor (i=0; i<count;i++) {\n\t\tsubs = gf_list_get(traf->sub_samples, i);\n\t\tif (subs->flags==flags) break;\n\t\tsubs=NULL;\n\t}\n\tif (!subs) {\n\t\tsubs = (GF_SubSampleInformationBox *) gf_isom_box_new_parent(&traf->child_boxes, GF_ISOM_BOX_TYPE_SUBS);\n\t\tif (!subs) return GF_OUT_OF_MEM;\n\t\tsubs->version = (subSampleSize>0xFFFF) ? 1 : 0;\n\t\tsubs->flags = flags;\n\t\tgf_list_add(traf->sub_samples, subs);\n\t}\n\treturn gf_isom_add_subsample_info(subs, last_sample, subSampleSize, priority, reserved, discardable);\n}\n\n#if 0 //unused\nstatic GF_Err gf_isom_copy_sample_group_entry_to_traf(GF_TrackFragmentBox *traf, GF_SampleTableBox *stbl, u32 grouping_type, u32 grouping_type_parameter, u32 sampleGroupDescriptionIndex, Bool sgpd_in_traf)\n{\n\tif (sgpd_in_traf) {\n\t\tvoid *entry = NULL;\n\t\tu32 i, count;\n\t\tGF_SampleGroupDescriptionBox *sgdesc = NULL;\n\t\tGF_BitStream *bs;\n\n\t\tcount = gf_list_count(stbl->sampleGroupsDescription);\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tsgdesc = (GF_SampleGroupDescriptionBox *)gf_list_get(stbl->sampleGroupsDescription, i);\n\t\t\tif (sgdesc->grouping_type == grouping_type)\n\t\t\t\tbreak;\n\t\t\tsgdesc = NULL;\n\t\t}\n\t\tif (!sgdesc)\n\t\t\treturn GF_BAD_PARAM;\n\n\t\tentry = gf_list_get(sgdesc->group_descriptions, sampleGroupDescriptionIndex-1);\n\t\tif (!entry)\n\t\t\treturn GF_BAD_PARAM;\n\n\t\tswitch (grouping_type) {\n\t\tcase GF_ISOM_SAMPLE_GROUP_RAP:\n\t\t{\n\t\t\tchar udta[2];\n\t\t\tbs = gf_bs_new(udta, 2*sizeof(char), GF_BITSTREAM_WRITE);\n\t\t\tgf_bs_write_u8(bs, ((GF_VisualRandomAccessEntry *)entry)->num_leading_samples_known);\n\t\t\tgf_bs_write_u8(bs, ((GF_VisualRandomAccessEntry *)entry)->num_leading_samples);\n\t\t\tgf_bs_del(bs);\n\t\t\treturn gf_isom_set_sample_group_info_ex(NULL, traf, 0, grouping_type, 0, udta, sg_rap_create_entry, sg_rap_compare_entry);\n\t\t}\n\t\tcase GF_ISOM_SAMPLE_GROUP_SYNC:\n\t\t{\n\t\t\tchar udta[1];\n\t\t\tbs = gf_bs_new(udta, 1*sizeof(char), GF_BITSTREAM_WRITE);\n\t\t\tgf_bs_write_int(bs, 0, 2);\n\t\t\tgf_bs_write_int(bs, ((GF_SYNCEntry *)entry)->NALU_type, 6);\n\t\t\tgf_bs_del(bs);\n\t\t\treturn gf_isom_set_sample_group_info_ex(NULL, traf, 0, grouping_type, 0, udta, sg_rap_create_entry, sg_rap_compare_entry);\n\t\t}\n\t\tcase GF_ISOM_SAMPLE_GROUP_ROLL:\n\t\t{\n\t\t\tchar udta[2];\n\t\t\tbs = gf_bs_new(udta, 2*sizeof(char), GF_BITSTREAM_WRITE);\n\t\t\tgf_bs_write_u16(bs, ((GF_RollRecoveryEntry *)entry)->roll_distance);\n\t\t\tgf_bs_del(bs);\n\t\t\treturn gf_isom_set_sample_group_info_ex(NULL, traf, 0, grouping_type, 0, udta, sg_roll_create_entry, sg_roll_compare_entry);\n\t\t}\n\t\tcase GF_ISOM_SAMPLE_GROUP_SEIG:\n\t\t{\n\t\t\treturn gf_isom_set_sample_group_info_ex(NULL, traf, 0, grouping_type, 0, entry, sg_encryption_create_entry, sg_encryption_compare_entry);\n\t\t}\n\t\tdefault:\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t}\n\n\treturn gf_isom_add_sample_group_entry(traf->sampleGroups, 0, grouping_type, grouping_type_parameter, sampleGroupDescriptionIndex, NULL);\n}\n/*copy over the subsample and sampleToGroup information of the given sample from the source track/file to the last sample added to the current track fragment of the destination file*/\nGF_Err gf_isom_fragment_copy_subsample(GF_ISOFile *dest, GF_ISOTrackID TrackID, GF_ISOFile *orig, u32 track, u32 sampleNumber, Bool sgpd_in_traf)\n{\n\tu32 i, count, last_sample, idx, subs_flags;\n\tGF_SubSampleInfoEntry *sub_sample;\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_TrackFragmentBox *traf;\n\tGF_TrunEntry *ent;\n\tGF_TrackFragmentRunBox *trun;\n\tif (!dest->moof || !(dest->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY) ) return GF_BAD_PARAM;\n\n\ttraf = gf_isom_get_traf(dest, TrackID);\n\tif (!traf || !traf->tfhd->sample_desc_index) return GF_BAD_PARAM;\n\n\ttrak = gf_isom_get_track_from_file(orig, track);\n\tif (!trak) return GF_BAD_PARAM;\n\n\t/*modify depends flags*/\n\tif (trak->Media->information->sampleTable->SampleDep) {\n\t\tu32 isLeading, dependsOn, dependedOn, redundant;\n\n\t\tisLeading = dependsOn = dependedOn = redundant = 0;\n\t\tcount = gf_list_count(traf->TrackRuns);\n\t\tif (!count) return GF_BAD_PARAM;\n\t\ttrun = (GF_TrackFragmentRunBox *)gf_list_get(traf->TrackRuns, count-1);\n\t\tcount = gf_list_count(trun->entries);\n\t\tif (!count) return GF_BAD_PARAM;\n\n\t\tent = (GF_TrunEntry *)gf_list_get(trun->entries, count-1);\n\t\te = stbl_GetSampleDepType(trak->Media->information->sampleTable->SampleDep, sampleNumber, &isLeading, &dependsOn, &dependedOn, &redundant);\n\t\tif (e) return e;\n\n\t\tGF_ISOM_RESET_FRAG_DEPEND_FLAGS(ent->flags);\n\n\t\tif (traf->use_sdtp) {\n\t\t\tu8 sflags=0;\n\t\t\tif (!traf->sdtp) {\n\t\t\t\ttraf->sdtp = (GF_SampleDependencyTypeBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_SDTP);\n\t\t\t\tif (!traf->sdtp) return GF_OUT_OF_MEM;\n\t\t\t}\n\t\t\tsflags |= isLeading << 6;\n\t\t\tsflags |= dependsOn << 4;\n\t\t\tsflags |= dependedOn << 2;\n\t\t\tsflags |= redundant;\n\n\t\t\ttraf->sdtp->sample_info = gf_realloc(traf->sdtp->sample_info, sizeof(u8)*(traf->sdtp->sampleCount+1));\n\t\t\ttraf->sdtp->sample_info[traf->sdtp->sampleCount] = (u8) sflags;\n\t\t\ttraf->sdtp->sampleCount++;\n\t\t\ttraf->sdtp->sample_alloc = traf->sdtp->sampleCount+1;\n\n\n\t\t\tif (traf->use_sdtp==2) {\n\t\t\t\tent->flags |= GF_ISOM_GET_FRAG_DEPEND_FLAGS(isLeading, dependsOn, dependedOn, redundant);\n\t\t\t}\n\t\t} else {\n\t\t\tent->flags |= GF_ISOM_GET_FRAG_DEPEND_FLAGS(isLeading, dependsOn, dependedOn, redundant);\n\t\t}\n\t}\n\n\t/*copy subsample info if any*/\n\tidx=1;\n\twhile (gf_isom_get_subsample_types(orig, track, idx, &subs_flags)) {\n\t\tGF_SubSampleInformationBox *subs_traf=NULL;\n\t\tidx++;\n\t\tif (! gf_isom_sample_get_subsample_entry(orig, track, sampleNumber, subs_flags, &sub_sample))\n\t\t\tcontinue;\n\n\t\tif (!traf || !traf->tfhd->sample_desc_index) return GF_BAD_PARAM;\n\n\t\t/*compute last sample number in traf*/\n\t\tlast_sample = 0;\n\t\tcount = gf_list_count(traf->TrackRuns);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_TrackFragmentRunBox *trun = (GF_TrackFragmentRunBox*)gf_list_get(traf->TrackRuns, i);\n\t\t\tlast_sample += trun->sample_count;\n\t\t}\n\n\t\t/*create subsample if needed*/\n\t\tif (!traf->sub_samples) {\n\t\t\ttraf->sub_samples = gf_list_new();\n\t\t}\n\t\tcount = gf_list_count(traf->sub_samples);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tsubs_traf = gf_list_get(traf->sub_samples, i);\n\t\t\tif (subs_traf->flags==subs_flags) break;\n\t\t\tsubs_traf = NULL;\n\t\t}\n\t\tif (!subs_traf) {\n\t\t\tsubs_traf = (GF_SubSampleInformationBox *) gf_isom_box_new_parent(&traf->child_boxes, GF_ISOM_BOX_TYPE_SUBS);\n\t\t\tif (!subs_traf) return GF_OUT_OF_MEM;\n\t\t\tsubs_traf->version = 0;\n\t\t\tsubs_traf->flags = subs_flags;\n\t\t\tgf_list_add(traf->sub_samples, subs_traf);\n\t\t}\n\n\t\tcount = gf_list_count(sub_sample->SubSamples);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_SubSampleEntry *entry = (GF_SubSampleEntry*)gf_list_get(sub_sample->SubSamples, i);\n\t\t\te = gf_isom_add_subsample_info(subs_traf, last_sample, entry->subsample_size, entry->subsample_priority, entry->reserved, entry->discardable);\n\t\t\tif (e) return e;\n\t\t}\n\t}\n\t/*copy sampleToGroup info if any*/\n\tif (trak->Media->information->sampleTable->sampleGroups) {\n\t\tcount = gf_list_count(trak->Media->information->sampleTable->sampleGroups);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_SampleGroupBox *sg;\n\t\t\tBool found = GF_FALSE;\n\t\t\tu32 j;\n\t\t\tu32 first_sample_in_entry, last_sample_in_entry;\n\t\t\tfirst_sample_in_entry = 1;\n\n\t\t\tsg = (GF_SampleGroupBox*)gf_list_get(trak->Media->information->sampleTable->sampleGroups, i);\n\t\t\tfor (j=0; j<sg->entry_count; j++) {\n\t\t\t\tlast_sample_in_entry = first_sample_in_entry + sg->sample_entries[j].sample_count - 1;\n\t\t\t\tif ((sampleNumber<first_sample_in_entry) || (sampleNumber>last_sample_in_entry)) {\n\t\t\t\t\tfirst_sample_in_entry = last_sample_in_entry+1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (!traf->sampleGroups)\n\t\t\t\t\ttraf->sampleGroups = gf_list_new();\n\n\t\t\t\t/*found our sample, add it to trak->sampleGroups*/\n\t\t\t\te = gf_isom_copy_sample_group_entry_to_traf(traf, trak->Media->information->sampleTable, sg->grouping_type, sg->grouping_type_parameter,  sg->sample_entries[j].group_description_index, sgpd_in_traf);\n\t\t\t\tif (e) return e;\n\n\t\t\t\tfound = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t//unmapped sample\n\t\t\tif (!found) {\n\t\t\t\tif (!traf->sampleGroups)\n\t\t\t\t\ttraf->sampleGroups = gf_list_new();\n\n\t\t\t\te = gf_isom_copy_sample_group_entry_to_traf(traf, trak->Media->information->sampleTable, sg->grouping_type, sg->grouping_type_parameter,  0, sgpd_in_traf);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n#endif\n\n\nGF_Err gf_isom_fragment_set_sample_flags(GF_ISOFile *movie, GF_ISOTrackID trackID, u32 is_leading, u32 dependsOn, u32 dependedOn, u32 redundant)\n{\n\tu32 count;\n\tGF_TrackFragmentBox *traf;\n\tGF_TrunEntry *ent;\n\tGF_TrackFragmentRunBox *trun;\n\tif (!movie || !movie->moof || !(movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY) ) return GF_BAD_PARAM;\n\n\ttraf = gf_isom_get_traf(movie, trackID);\n\tif (!traf->tfhd->sample_desc_index) return GF_BAD_PARAM;\n\n\tcount = gf_list_count(traf->TrackRuns);\n\tif (!count) return GF_BAD_PARAM;\n\ttrun = (GF_TrackFragmentRunBox *)gf_list_get(traf->TrackRuns, count-1);\n\tif (!trun->nb_samples) return GF_BAD_PARAM;\n\tent = &trun->samples[trun->nb_samples-1];\n\n\tGF_ISOM_RESET_FRAG_DEPEND_FLAGS(ent->flags);\n\n\tif (traf->use_sdtp) {\n\t\tu8 sflags=0;\n\t\tif (!traf->sdtp) {\n\t\t\ttraf->sdtp = (GF_SampleDependencyTypeBox *) gf_isom_box_new_parent(&traf->child_boxes, GF_ISOM_BOX_TYPE_SDTP);\n\t\t\tif (!traf->sdtp) return GF_OUT_OF_MEM;\n\t\t}\n\t\tsflags |= is_leading << 6;\n\t\tsflags |= dependsOn << 4;\n\t\tsflags |= dependedOn << 2;\n\t\tsflags |= redundant;\n\n\t\ttraf->sdtp->sample_info = gf_realloc(traf->sdtp->sample_info, sizeof(u8)*(traf->sdtp->sampleCount+1));\n\t\ttraf->sdtp->sample_info[traf->sdtp->sampleCount] = (u8) sflags;\n\t\ttraf->sdtp->sampleCount++;\n\t\ttraf->sdtp->sample_alloc = traf->sdtp->sampleCount;\n\t\tif (traf->use_sdtp==2) {\n\t\t\tent->flags |= GF_ISOM_GET_FRAG_DEPEND_FLAGS(is_leading, dependsOn, dependedOn, redundant);\n\t\t}\n\t} else {\n\t\tent->flags |= GF_ISOM_GET_FRAG_DEPEND_FLAGS(is_leading, dependsOn, dependedOn, redundant);\n\t}\n\treturn GF_OK;\n}\n\n\n#endif\t/*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_EXPORT\nGF_Err gf_isom_set_traf_base_media_decode_time(GF_ISOFile *movie, GF_ISOTrackID TrackID, u64 decode_time)\n{\n\tGF_TrackFragmentBox *traf;\n\tif (!movie || !movie->moof || !(movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY) ) return GF_BAD_PARAM;\n\n\ttraf = gf_isom_get_traf(movie, TrackID);\n\tif (!traf) return GF_BAD_PARAM;\n\n\tif (!traf->tfdt) {\n\t\ttraf->tfdt = (GF_TFBaseMediaDecodeTimeBox *) gf_isom_box_new_parent(&traf->child_boxes, GF_ISOM_BOX_TYPE_TFDT);\n\t\tif (!traf->tfdt) return GF_OUT_OF_MEM;\n\t}\n\ttraf->tfdt->baseMediaDecodeTime = decode_time;\n\tif (traf->large_tfdt)\n\t\ttraf->tfdt->version = 1;\n\treturn GF_OK;\n}\n\nGF_Err gf_isom_enable_mfra(GF_ISOFile *file)\n{\n\tif (!file) return GF_BAD_PARAM;\n\tfile->mfra = (GF_MovieFragmentRandomAccessBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_MFRA);\n\tif (!file->mfra) return GF_OUT_OF_MEM;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_FRAGMENTS)*/\n\n\nGF_EXPORT\nvoid gf_isom_set_next_moof_number(GF_ISOFile *movie, u32 value)\n{\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (movie) movie->NextMoofNumber = value;\n#endif\n}\n\nGF_EXPORT\nu32 gf_isom_get_next_moof_number(GF_ISOFile *movie)\n{\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (movie) return movie->NextMoofNumber;\n#endif\n\treturn 0;\n}\n\nGF_Err gf_isom_set_emsg(GF_ISOFile *movie, u8 *data, u32 size)\n{\n\tif (!movie || !data) return GF_BAD_PARAM;\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (!movie->moof) return GF_BAD_PARAM;\n\n\tGF_BitStream *bs = gf_bs_new(data, size, GF_BITSTREAM_READ);\n\twhile (gf_bs_available(bs)) {\n\t\tGF_Box *emsg;\n\t\tGF_Err e = gf_isom_box_parse(&emsg, bs);\n\t\tif (e) break;\n\n\t\tif (!movie->moof->emsgs) movie->moof->emsgs = gf_list_new();\n\t\tgf_list_add(movie->moof->emsgs, emsg);\n\t}\n\tgf_bs_del(bs);\n#endif\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nBool gf_isom_is_track_fragmented(GF_ISOFile *movie, GF_ISOTrackID TrackID)\n{\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (!movie || !movie->moov || !movie->moov->mvex) return GF_FALSE;\n\treturn (GetTrex(movie->moov, TrackID) != NULL) ? GF_TRUE : GF_FALSE;\n#else\n\treturn GF_FALSE;\n#endif\n}\n\nGF_EXPORT\nBool gf_isom_is_fragmented(GF_ISOFile *movie)\n{\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (!movie || !movie->moov) return GF_FALSE;\n\t/* By default if the Moov has an mvex, the file is fragmented */\n\tif (movie->moov->mvex) return GF_TRUE;\n#endif\n\treturn GF_FALSE;\n}\n\n#endif /*GPAC_DISABLE_ISOM*/\n"], "fixing_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2023\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISO Media File Format sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/internal/isomedia_dev.h>\n\n#ifndef GPAC_DISABLE_ISOM\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\nGF_TrackExtendsBox *GetTrex(GF_MovieBox *moov, GF_ISOTrackID TrackID)\n{\n\tu32 i;\n\tGF_TrackExtendsBox *trex;\n\ti=0;\n\twhile ((trex = (GF_TrackExtendsBox *)gf_list_enum(moov->mvex->TrackExList, &i))) {\n\t\tif (trex->trackID == TrackID) return trex;\n\t}\n\treturn NULL;\n}\n\n\nGF_TrackFragmentBox *gf_isom_get_traf(GF_ISOFile *mov, GF_ISOTrackID TrackID)\n{\n\tu32 i;\n\tif (!mov->moof) return NULL;\n\n\t//reverse browse the TRAFs, as there may be more than one per track ...\n\tfor (i=gf_list_count(mov->moof->TrackList); i>0; i--) {\n\t\tGF_TrackFragmentBox *traf = (GF_TrackFragmentBox *)gf_list_get(mov->moof->TrackList, i-1);\n\t\tif (traf->tfhd->trackID == TrackID) return traf;\n\t}\n\treturn NULL;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err gf_isom_set_movie_duration(GF_ISOFile *movie, u64 duration, Bool remove_mehd)\n{\n\tif (!movie || !movie->moov || !movie->moov->mvex) return GF_BAD_PARAM;\n\n\tif (remove_mehd) {\n\t\tif (!movie->moov->mvex->mehd) {\n\t\t\tgf_isom_box_del_parent(&movie->moov->mvex->child_boxes, (GF_Box*)movie->moov->mvex->mehd);\n\t\t\tmovie->moov->mvex->mehd = NULL;\n\t\t}\n\t} else {\n\t\tif (!movie->moov->mvex->mehd) {\n\t\t\tmovie->moov->mvex->mehd = (GF_MovieExtendsHeaderBox *) gf_isom_box_new_parent(&movie->moov->mvex->child_boxes, GF_ISOM_BOX_TYPE_MEHD);\n\t\t\tif (!movie->moov->mvex->mehd) return GF_OUT_OF_MEM;\n\t\t}\n\t\tmovie->moov->mvex->mehd->fragment_duration = duration;\n\t}\n\tmovie->moov->mvhd->duration = 0;\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_finalize_for_fragment(GF_ISOFile *movie, u32 media_segment_type, Bool mvex_after_tracks)\n{\n\tGF_Err e;\n\tu32 i;\n\tBool store_file = GF_TRUE;\n\tGF_TrackExtendsBox *trex;\n\tif (!movie || !movie->moov) return GF_BAD_PARAM;\n\n#if 0\n\tif (movie->openMode==GF_ISOM_OPEN_CAT_FRAGMENTS) {\n\t\t/*from now on we are in write mode*/\n\t\tmovie->openMode = GF_ISOM_OPEN_WRITE;\n\t\tstore_file = GF_FALSE;\n\t\tmovie->append_segment = GF_TRUE;\n\t} else\n#endif\n\t{\n\t\tmovie->NextMoofNumber = 1;\n\t}\n\tmovie->moov->mvex_after_traks = mvex_after_tracks;\n\t\n\t//this is only allowed in write mode\n\tif (movie->openMode != GF_ISOM_OPEN_WRITE) return GF_ISOM_INVALID_MODE;\n\n\tif (movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY) return GF_OK;\n\tmovie->FragmentsFlags = 0;\n\n\tif (store_file) {\n\t\t/* add DASH brand if requested*/\n\t\tif (media_segment_type)\n\t\t\tgf_isom_modify_alternate_brand(movie, GF_ISOM_BRAND_DASH, GF_TRUE);\n\n\t\tif (!movie->moov->mvex->mehd || !movie->moov->mvex->mehd->fragment_duration) {\n\t\t\t//update durations\n\t\t\tgf_isom_get_duration(movie);\n\t\t}\n\n\t\ti=0;\n\t\twhile ((trex = (GF_TrackExtendsBox *)gf_list_enum(movie->moov->mvex->TrackExList, &i))) {\n\t\t\tif (trex->type != GF_ISOM_BOX_TYPE_TREX) continue;\n\t\t\tif (trex->track->Media->information->sampleTable->CompositionToDecode) {\n\t\t\t\tu32 k=0;\n\t\t\t\tGF_TrackExtensionPropertiesBox *trep;\n\t\t\t\twhile ((trep = (GF_TrackExtensionPropertiesBox*) gf_list_enum(movie->moov->mvex->TrackExPropList, &k))) {\n\t\t\t\t\tif (trep->trackID == trex->trackID) break;\n\t\t\t\t}\n\n\t\t\t\tif (!trep) {\n\t\t\t\t\ttrep = (GF_TrackExtensionPropertiesBox*) gf_isom_box_new_parent(&movie->moov->mvex->child_boxes, GF_ISOM_BOX_TYPE_TREP);\n\t\t\t\t\tif (!trep) return GF_OUT_OF_MEM;\n\t\t\t\t\ttrep->trackID = trex->trackID;\n\t\t\t\t\tgf_list_add(movie->moov->mvex->TrackExPropList, trep);\n\t\t\t\t}\n\n\t\t\t\tif (!trex->track->Media->information->sampleTable->SampleSize || ! trex->track->Media->information->sampleTable->SampleSize->sampleCount) {\n\t\t\t\t\tgf_list_add(trep->child_boxes, trex->track->Media->information->sampleTable->CompositionToDecode);\n\t\t\t\t\ttrex->track->Media->information->sampleTable->CompositionToDecode = NULL;\n\t\t\t\t} else {\n\t\t\t\t\tGF_CompositionToDecodeBox *cslg;\n\n\t\t\t\t\t//clone it!\n\t\t\t\t\tGF_SAFEALLOC(cslg, GF_CompositionToDecodeBox);\n\t\t\t\t\tif (!cslg) return GF_OUT_OF_MEM;\n\t\t\t\t\tmemcpy(cslg, trex->track->Media->information->sampleTable->CompositionToDecode, sizeof(GF_CompositionToDecodeBox) );\n\t\t\t\t\tcslg->child_boxes = gf_list_new();\n\t\t\t\t\tgf_list_add(trep->child_boxes, trex->track->Media->information->sampleTable->CompositionToDecode);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (movie->moov->mvex->mehd && movie->moov->mvex->mehd->fragment_duration) {\n\t\t\t\ttrex->track->Header->duration = 0;\n\t\t\t\tMedia_SetDuration(trex->track);\n\t\t\t\tif (trex->track->editBox && trex->track->editBox->editList) {\n\t\t\t\t\tGF_EdtsEntry *edts = gf_list_last(trex->track->editBox->editList->entryList);\n\t\t\t\t\tedts->segmentDuration = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//write movie\n\t\te = WriteToFile(movie, GF_TRUE);\n\t\tif (e) return e;\n\n\t\tif (movie->on_block_out) {\n\t\t\tgf_bs_seek(movie->editFileMap->bs, 0);\n\t\t\tgf_bs_truncate(movie->editFileMap->bs);\n\t\t}\n\t}\n\n\t//make sure we do have all we need. If not this is not an error, just consider\n\t//the file closed\n\tif (!movie->moov->mvex || !gf_list_count(movie->moov->mvex->TrackExList)) return GF_OK;\n\n\ti=0;\n\twhile ((trex = (GF_TrackExtendsBox *)gf_list_enum(movie->moov->mvex->TrackExList, &i))) {\n\t\tif (!trex->trackID || !gf_isom_get_track_from_id(movie->moov, trex->trackID)) return GF_IO_ERR;\n\t\t//we could also check all our data refs are local but we'll do that at run time\n\t\t//in order to allow a mix of both (remote refs in MOOV and local in MVEX)\n\n\t\t//one thing that MUST be done is OD cross-dependencies. The movie fragment spec\n\t\t//is broken here, since it cannot allow dynamic insertion of new ESD and their\n\t\t//dependancies\n\t}\n\n\t//ok we are fine - note the data map is created at the beginning\n\tif (i) movie->FragmentsFlags |= GF_ISOM_FRAG_WRITE_READY;\n\n\tif (media_segment_type) {\n\t\tmovie->use_segments = GF_TRUE;\n\t\tmovie->moof_list = gf_list_new();\n\t} else if (movie->on_block_out) {\n\t\tmovie->moof_list = gf_list_new();\n\t}\n\n\t/*set brands for segment*/\n\n\t/*\"msdh\": it's a media segment */\n\tgf_isom_set_brand_info(movie, GF_ISOM_BRAND_MSDH, 0);\n\t/*remove all brands\t*/\n\tgf_isom_reset_alt_brands(movie);\n\t/*\n\t\tmsdh: it's a media segment\n\t\tsims: it's a media segment with an SSIX\n\t\tmsix: it's a media segment with an index\n\t\tlmsg: it's the last media segment\n\t*/\n\n\treturn GF_OK;\n}\n\nGF_Err gf_isom_change_track_fragment_defaults(GF_ISOFile *movie, GF_ISOTrackID TrackID,\n        u32 DefaultSampleDescriptionIndex,\n        u32 DefaultSampleDuration,\n        u32 DefaultSampleSize,\n        u8 DefaultSampleIsSync,\n        u8 DefaultSamplePadding,\n        u16 DefaultDegradationPriority,\n        u8 force_traf_flags)\n{\n\tGF_MovieExtendsBox *mvex;\n\tGF_TrackExtendsBox *trex;\n\tGF_TrackBox *trak;\n\n\tif (!movie || !movie->moov) return GF_BAD_PARAM;\n\t//this is only allowed in write mode\n\tif (movie->openMode != GF_ISOM_OPEN_WRITE) return GF_ISOM_INVALID_MODE;\n\n\ttrak = gf_isom_get_track_from_id(movie->moov, TrackID);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tmvex = movie->moov->mvex;\n\tif (!mvex) return GF_BAD_PARAM;\n\n\ttrex = GetTrex(movie->moov, TrackID);\n\tif (!trex)  return GF_BAD_PARAM;\n\n\ttrex->def_sample_desc_index = DefaultSampleDescriptionIndex;\n\ttrex->def_sample_duration = DefaultSampleDuration;\n\ttrex->def_sample_size = DefaultSampleSize;\n\ttrex->def_sample_flags = GF_ISOM_FORMAT_FRAG_FLAGS(DefaultSamplePadding, DefaultSampleIsSync, DefaultDegradationPriority);\n\t//if sample is sync by default, set sample_depends_on flags to 2 (does not depend on other samples)\n\tif (DefaultSampleIsSync) {\n\t\ttrex->def_sample_flags |= (2<<24);\n\t}\n\ttrex->cannot_use_default = GF_FALSE;\n\n\tif (force_traf_flags) {\n\t\ttrex->cannot_use_default = GF_TRUE;\n\t} else if (DefaultSampleDescriptionIndex == 0 && DefaultSampleDuration == 0 && DefaultSampleSize == 0\n\t\t&& DefaultSampleIsSync == 0 && DefaultSamplePadding == 0 && DefaultDegradationPriority == 0) {\n\t\ttrex->cannot_use_default = GF_TRUE;\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_setup_track_fragment(GF_ISOFile *movie, GF_ISOTrackID TrackID,\n                                    u32 DefaultSampleDescriptionIndex,\n                                    u32 DefaultSampleDuration,\n                                    u32 DefaultSampleSize,\n                                    u8 DefaultSampleSyncFlags,\n                                    u8 DefaultSamplePadding,\n                                    u16 DefaultDegradationPriority,\n                                    Bool force_traf_flags)\n{\n\tGF_MovieExtendsBox *mvex;\n\tGF_TrackExtendsBox *trex;\n\tGF_TrackBox *trak;\n\n\tif (!movie || !movie->moov) return GF_BAD_PARAM;\n\t//this is only allowed in write mode\n\tif (movie->openMode != GF_ISOM_OPEN_WRITE) return GF_ISOM_INVALID_MODE;\n\t//and only at setup\n\tif (movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY) return GF_BAD_PARAM;\n\n\n\ttrak = gf_isom_get_track_from_id(movie->moov, TrackID);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tif (DefaultSampleSyncFlags & GF_ISOM_FRAG_USE_SYNC_TABLE) {\n\t\tDefaultSampleSyncFlags &= ~GF_ISOM_FRAG_USE_SYNC_TABLE;\n\t\tif (!trak->Media->information->sampleTable->SyncSample) {\n\t\t\ttrak->Media->information->sampleTable->SyncSample = (GF_SyncSampleBox *) gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_STSS);\n\t\t}\n\t}\n\n\t//create MVEX if needed\n\tif (!movie->moov->mvex) {\n\t\tmvex = (GF_MovieExtendsBox *) gf_isom_box_new_parent(&movie->moov->child_boxes, GF_ISOM_BOX_TYPE_MVEX);\n\t\tif (!mvex) return GF_OUT_OF_MEM;\n\t\tmoov_on_child_box((GF_Box*)movie->moov, (GF_Box *) mvex, GF_FALSE);\n\t} else {\n\t\tmvex = movie->moov->mvex;\n\t}\n\tif (!mvex->mehd) {\n\t\tmvex->mehd = (GF_MovieExtendsHeaderBox *) gf_isom_box_new_parent(&mvex->child_boxes, GF_ISOM_BOX_TYPE_MEHD);\n\t\tif (!mvex->mehd) return GF_OUT_OF_MEM;\n\t}\n\n\ttrex = GetTrex(movie->moov, TrackID);\n\tif (!trex) {\n\t\ttrex = (GF_TrackExtendsBox *) gf_isom_box_new_parent(&mvex->child_boxes, GF_ISOM_BOX_TYPE_TREX);\n\t\tif (!trex) return GF_OUT_OF_MEM;\n\t\ttrex->trackID = TrackID;\n\t\tmvex_on_child_box((GF_Box*)mvex, (GF_Box *) trex, GF_FALSE);\n\t}\n\ttrex->track = trak;\n\treturn gf_isom_change_track_fragment_defaults(movie, TrackID, DefaultSampleDescriptionIndex, DefaultSampleDuration, DefaultSampleSize, DefaultSampleSyncFlags, DefaultSamplePadding, DefaultDegradationPriority, force_traf_flags);\n}\n\n#ifdef GF_ENABLE_CTRN\nGF_EXPORT\nGF_Err gf_isom_enable_traf_inherit(GF_ISOFile *movie, GF_ISOTrackID TrackID, GF_ISOTrackID BaseTrackID)\n{\n\tGF_TrackBox *trak;\n\tGF_TrackExtendsBox *trex;\n\tGF_Err e=GF_OK;\n\tu32 track_num;\n\tif (!movie || !TrackID || !BaseTrackID)\n\t\treturn GF_BAD_PARAM;\n\ttrak = gf_isom_get_track_from_id(movie->moov, TrackID);\n\tif (!trak) return GF_BAD_PARAM;\n\ttrack_num = 1 + gf_list_find(movie->moov->trackList, trak);\n\n\te = gf_isom_set_track_reference(movie, track_num, GF_ISOM_REF_TRIN, BaseTrackID);\n\tif (e) return e;\n\n\ttrex = GetTrex(movie->moov, TrackID);\n\tif (!trex) return GF_BAD_PARAM;\n\ttrex->inherit_from_traf_id = BaseTrackID;\n\treturn GF_OK;\n}\n#endif\n\nGF_EXPORT\nGF_Err gf_isom_setup_track_fragment_template(GF_ISOFile *movie, GF_ISOTrackID TrackID, u8 *boxes, u32 boxes_size, u8 force_traf_flags)\n{\n\tGF_MovieExtendsBox *mvex;\n\tGF_TrackBox *trak;\n\tGF_BitStream *bs;\n\tGF_Err e=GF_OK;\n\ttrak = gf_isom_get_track_from_id(movie->moov, TrackID);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tbs = gf_bs_new(boxes, boxes_size, GF_BITSTREAM_READ);\n\twhile (gf_bs_available(bs)) {\n\t\tGF_Box *box=NULL;\n\t\tgf_isom_box_parse(&box, bs);\n\t\tif (!box) {\n\t\t\te = GF_BAD_PARAM;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (box->type==GF_ISOM_BOX_TYPE_TREX) {\n\t\t\tGF_TrackExtendsBox *trex_o=NULL;\n\t\t\tGF_TrackExtendsBox *trex = (GF_TrackExtendsBox *) box;\n\n\t\t\t//create MVEX if needed\n\t\t\tif (!movie->moov->mvex) {\n\t\t\t\tmvex = (GF_MovieExtendsBox *) gf_isom_box_new_parent(&movie->moov->child_boxes, GF_ISOM_BOX_TYPE_MVEX);\n\t\t\t\tmoov_on_child_box((GF_Box*)movie->moov, (GF_Box *) mvex, GF_FALSE);\n\t\t\t} else {\n\t\t\t\tmvex = movie->moov->mvex;\n\t\t\t}\n\t\t\tif (!mvex->mehd) {\n\t\t\t\tmvex->mehd = (GF_MovieExtendsHeaderBox *) gf_isom_box_new_parent(&mvex->child_boxes, GF_ISOM_BOX_TYPE_MEHD);\n\t\t\t}\n\n\t\t\ttrex_o = GetTrex(movie->moov, TrackID);\n\t\t\tif (trex_o) {\n\t\t\t\tgf_list_del_item(movie->moov->mvex->TrackExList, trex_o);\n\t\t\t\tgf_isom_box_del_parent(&movie->moov->mvex->child_boxes, (GF_Box *)trex_o);\n\t\t\t}\n\t\t\ttrex->trackID = TrackID;\n\t\t\ttrex->track = trak;\n\t\t\tif (force_traf_flags) trex->cannot_use_default = GF_TRUE;\n\t\t\tgf_list_add(mvex->child_boxes, trex);\n\t\t\tmvex_on_child_box((GF_Box*)mvex, (GF_Box *) trex, GF_FALSE);\n\t\t}\n\t}\n\tgf_bs_del(bs);\n\treturn e;\n}\n\n\nu32 GetNumUsedValues(GF_TrackFragmentBox *traf, u32 value, u32 index)\n{\n\tu32 i, j, NumValue = 0;\n\tGF_TrackFragmentRunBox *trun;\n\n\ti=0;\n\twhile ((trun = (GF_TrackFragmentRunBox *)gf_list_enum(traf->TrackRuns, &i))) {\n\t\tfor (j=0; j<trun->nb_samples; j++) {\n\t\t\tGF_TrunEntry *ent = &trun->samples[j];\n\t\t\tswitch (index) {\n\t\t\tcase 1:\n\t\t\t\tif (value == ent->Duration) NumValue ++;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tif (value == ent->size) NumValue ++;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tif (value == ent->flags) NumValue ++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn NumValue;\n}\n\n\nvoid ComputeFragmentDefaults(GF_TrackFragmentBox *traf)\n{\n\tu32 i, j;\n\tGF_TrackFragmentRunBox *trun;\n\tGF_TrunEntry *ent, *first_ent=NULL;\n\n\t//Duration default\n\tu32 def_dur=0;\n\tu32 def_size=0;\n\tu32 def_flags=0;\n\tu32 nb_samp=0;\n\n\ti=0;\n\twhile ((trun = (GF_TrackFragmentRunBox *)gf_list_enum(traf->TrackRuns, &i))) {\n\t\tfor (j=0; j<trun->nb_samples; j++) {\n\t\t\tent = &trun->samples[j];\n\t\t\tnb_samp++;\n\n\t\t\tif (!first_ent) {\n\t\t\t\tfirst_ent = ent;\n\t\t\t\tdef_dur = ent->Duration;\n\t\t\t\tdef_size = ent->size;\n\t\t\t\tif (ent->nb_pack>1)\n\t\t\t\t\tdef_size /= ent->nb_pack;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t//if more than 2 dur, we need the flag\n\t\t\tif (def_dur && (ent->Duration != def_dur)) def_dur=0;\n\t\t\t//if more than 2 size, we need the flag\n\t\t\tif (def_size) {\n\t\t\t\tu32 size = ent->size;\n\t\t\t\tif (ent->nb_pack>1)\n\t\t\t\t\tsize /= ent->nb_pack;\n\t\t\t\tif (size != def_size) def_size=0;\n\t\t\t}\n\t\t\t//only check sample flags after first sample (first one uses first sample flags)\n\t\t\tif (nb_samp==2) def_flags = ent->flags;\n\t\t\t//if more than 2 sets of flags, we need one entry each\n\t\t\telse if (def_flags && (ent->flags != def_flags)) def_flags = 0;\n\n\t\t\t//no default possible\n\t\t\tif ((def_dur|def_size|def_flags) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (nb_samp==1) def_flags = first_ent->flags;\n\n\tif (def_dur && ((def_dur != traf->trex->def_sample_duration) || traf->trex->cannot_use_default ) ) {\n\t\ttraf->tfhd->def_sample_duration = def_dur;\n\t}\n\tif (def_size && (def_size != traf->trex->def_sample_size)) {\n\t\ttraf->tfhd->def_sample_size = def_size;\n\t}\n\tif (traf->trex->cannot_use_default || (def_flags && (def_flags != traf->trex->def_sample_flags))) {\n\t\ttraf->tfhd->def_sample_flags = def_flags;\n\t}\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_fragment_option(GF_ISOFile *movie, GF_ISOTrackID TrackID, GF_ISOTrackFragmentOption Code, u32 Param)\n{\n\tGF_TrackFragmentBox *traf;\n\tif (!movie || !movie->moov) return GF_BAD_PARAM;\n\t//this is only allowed in write mode\n\tif (movie->openMode != GF_ISOM_OPEN_WRITE) return GF_ISOM_INVALID_MODE;\n\n\tswitch (Code) {\n\tcase GF_ISOM_TRAF_EMPTY:\n\t\ttraf = gf_isom_get_traf(movie, TrackID);\n\t\tif (!traf) return GF_BAD_PARAM;\n\t\ttraf->tfhd->EmptyDuration = Param;\n\t\tbreak;\n\tcase GF_ISOM_TRAF_RANDOM_ACCESS:\n\t\ttraf = gf_isom_get_traf(movie, TrackID);\n\t\tif (!traf) return GF_BAD_PARAM;\n\t\ttraf->IFrameSwitching = Param;\n\t\tbreak;\n\tcase GF_ISOM_TRAF_DATA_CACHE:\n\t\ttraf = gf_isom_get_traf(movie, TrackID);\n\t\tif (!traf) return GF_BAD_PARAM;\n\t\t//don't cache only one sample ...\n\t\ttraf->DataCache = Param > 1 ? Param : 0;\n\t\tbreak;\n\tcase GF_ISOM_TFHD_FORCE_MOOF_BASE_OFFSET:\n\t\tmovie->force_moof_base_offset = Param;\n\t\tbreak;\n\tcase GF_ISOM_TRAF_USE_SAMPLE_DEPS_BOX:\n\t\ttraf = gf_isom_get_traf(movie, TrackID);\n\t\tif (!traf) return GF_BAD_PARAM;\n\t\ttraf->use_sdtp = (u8) Param;\n\t\tbreak;\n\tcase GF_ISOM_TRUN_FORCE:\n\t\ttraf = gf_isom_get_traf(movie, TrackID);\n\t\tif (!traf) return GF_BAD_PARAM;\n\t\ttraf->force_new_trun = 1;\n\t\tbreak;\n\tcase GF_ISOM_TRUN_SET_INTERLEAVE_ID:\n\t\ttraf = gf_isom_get_traf(movie, TrackID);\n\t\tif (!traf) return GF_BAD_PARAM;\n\t\ttraf->DataCache = 1;\n\t\ttraf->use_sample_interleave = 1;\n\t\tif (traf->interleave_id != Param) {\n\t\t\ttraf->force_new_trun = 1;\n\t\t\ttraf->interleave_id = Param;\n\t\t}\n\t\tbreak;\n\tcase GF_ISOM_TRAF_TRUNS_FIRST:\n\t\ttraf = gf_isom_get_traf(movie, TrackID);\n\t\tif (!traf) return GF_BAD_PARAM;\n\t\ttraf->truns_first = Param;\n\t\tbreak;\n\tcase GF_ISOM_TRAF_TRUN_V1:\n\t\ttraf = gf_isom_get_traf(movie, TrackID);\n\t\tif (!traf) return GF_BAD_PARAM;\n\t\ttraf->truns_v1 = Param;\n\t\tbreak;\n\tcase GF_ISOM_TRAF_USE_LARGE_TFDT:\n\t\ttraf = gf_isom_get_traf(movie, TrackID);\n\t\tif (!traf) return GF_BAD_PARAM;\n\t\ttraf->large_tfdt = Param;\n\t\tmovie->force_sidx_v1 = Param ? GF_TRUE : GF_FALSE;\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\n//#define USE_BASE_DATA_OFFSET\n\nvoid update_trun_offsets(GF_ISOFile *movie, s32 offset)\n{\n#ifndef USE_BASE_DATA_OFFSET\n\tu32 i, j;\n\tGF_TrackFragmentBox *traf;\n\ti=0;\n\twhile ((traf = (GF_TrackFragmentBox*)gf_list_enum(movie->moof->TrackList, &i))) {\n\t\tGF_TrackFragmentRunBox *trun;\n\t\t/*remove base data*/\n\t\ttraf->tfhd->base_data_offset = 0;\n\t\tj=0;\n\t\twhile ((trun = (GF_TrackFragmentRunBox*)gf_list_enum(traf->TrackRuns, &j))) {\n\t\t\tif ((j==1) || traf->use_sample_interleave) {\n\t\t\t\ttrun->data_offset += offset;\n\t\t\t} else {\n\t\t\t\ttrun->data_offset = 0;\n\t\t\t}\n\t\t}\n\t}\n#endif\n}\n\nstatic\nu32 UpdateRuns(GF_ISOFile *movie, GF_TrackFragmentBox *traf)\n{\n\tu32 sampleCount, i, j, RunSize, RunDur, RunFlags, NeedFlags, UseCTS;\n\t/* enum:\n\t   0 - use values per sample in the trun box\n\t   1 - use default values from track fragment header\n\t   2 - use default values from track extends header */\n\tu32 UseDefaultSize, UseDefaultDur, UseDefaultFlag;\n\tGF_TrackFragmentRunBox *trun;\n\tGF_TrunEntry *ent;\n\n\tsampleCount = 0;\n\n#ifndef USE_BASE_DATA_OFFSET\n\tif (movie->use_segments) {\n\t\ttraf->tfhd->flags = GF_ISOM_MOOF_BASE_OFFSET;\n\t} else\n#endif\n\t{\n\t\tif (movie->force_moof_base_offset) {\n\t\t\ttraf->tfhd->flags = GF_ISOM_MOOF_BASE_OFFSET;\n\t\t} else {\n\t\t\ttraf->tfhd->flags = GF_ISOM_TRAF_BASE_OFFSET;\n\t\t}\n\t}\n\n\t//empty runs\n\tif (traf->tfhd->EmptyDuration) {\n\t\twhile (gf_list_count(traf->TrackRuns)) {\n\t\t\ttrun = (GF_TrackFragmentRunBox *)gf_list_get(traf->TrackRuns, 0);\n\t\t\tgf_list_rem(traf->TrackRuns, 0);\n\t\t\tgf_isom_box_del_parent(&traf->child_boxes, (GF_Box *)trun);\n\t\t}\n\t\ttraf->tfhd->flags |= GF_ISOM_TRAF_DUR_EMPTY;\n\t\tif (traf->tfhd->EmptyDuration != traf->trex->def_sample_duration) {\n\t\t\ttraf->tfhd->def_sample_duration = traf->tfhd->EmptyDuration;\n\t\t\ttraf->tfhd->flags |= GF_ISOM_TRAF_SAMPLE_DUR;\n\t\t}\n\t\treturn 0;\n\t}\n\n\n\tUseDefaultSize = 0;\n\tUseDefaultDur = 0;\n\tUseDefaultFlag = 0;\n\n\ti=0;\n\twhile ((trun = (GF_TrackFragmentRunBox *)gf_list_enum(traf->TrackRuns, &i))) {\n\t\tGF_TrunEntry *first_ent = NULL;\n\t\tRunSize = 0;\n\t\tRunDur = 0;\n\t\tRunFlags = 0;\n\t\tUseCTS = 0;\n\t\tNeedFlags = 0;\n\n\t\t//process all samples in run\n\t\tfor (j=0; j<trun->nb_samples; j++) {\n\t\t\tent = &trun->samples[j];\n\t\t\tif (!j) {\n\t\t\t\tfirst_ent = ent;\n\t\t\t\tRunSize = ent->size;\n\t\t\t\tif (ent->nb_pack) RunSize /= ent->nb_pack;\n\t\t\t\tRunDur = ent->Duration;\n\t\t\t}\n\t\t\t//we may have one entry only ...\n\t\t\tif (j || (trun->nb_samples==1)) {\n\t\t\t\tu32 ssize = ent->size;\n\t\t\t\tif (ent->nb_pack) ssize /= ent->nb_pack;\n\n\t\t\t\t//flags are only after first entry\n\t\t\t\tif (j==1 || (trun->nb_samples==1) ) RunFlags = ent->flags;\n\n\t\t\t\tif (ssize != RunSize) RunSize = 0;\n\t\t\t\tif (RunDur && (ent->Duration != RunDur))\n\t\t\t\t\tRunDur = 0;\n\t\t\t\tif (j && (RunFlags != ent->flags)) NeedFlags = 1;\n\t\t\t}\n\t\t\tif (ent->CTS_Offset) UseCTS = 1;\n\t\t}\n\t\t//empty list\n\t\tif (!first_ent) {\n\t\t\ti--;\n\t\t\tgf_list_rem(traf->TrackRuns, i);\n\t\t\tcontinue;\n\t\t}\n\t\ttrun->flags = 0;\n\n\t\t//size checking\n\t\t//constant size, check if this is from current fragment default or global default\n\t\tif (RunSize && (traf->trex->def_sample_size == RunSize) && !traf->trex->cannot_use_default) {\n\t\t\tif (!UseDefaultSize) UseDefaultSize = 2;\n\t\t\telse if (UseDefaultSize==1) RunSize = 0;\n\t\t} else if (RunSize && (traf->tfhd->def_sample_size == RunSize)) {\n\t\t\tif (!UseDefaultSize) UseDefaultSize = 1;\n\t\t\telse if (UseDefaultSize==2) RunSize = 0;\n\t\t}\n\t\t//we could check for single entry runs and set the default size in the tfhd but\n\t\t//that's no bit saving...\n\t\telse {\n\t\t\tRunSize=0;\n\t\t}\n\n\t\tif (!RunSize) trun->flags |= GF_ISOM_TRUN_SIZE;\n\n\t\t//duration checking\n\t\tif (RunDur && (traf->trex->def_sample_duration == RunDur) && !traf->trex->cannot_use_default) {\n\t\t\tif (!UseDefaultDur) UseDefaultDur = 2;\n\t\t\telse if (UseDefaultDur==1) RunDur = 0;\n\t\t} else if (RunDur && (traf->tfhd->def_sample_duration == RunDur)) {\n\t\t\tif (!UseDefaultDur) UseDefaultDur = 1;\n\t\t\telse if (UseDefaultDur==2) RunDur = 0;\n\t\t}\n\t\tif (!RunDur) trun->flags |= GF_ISOM_TRUN_DURATION;\n\n\t\t//flag checking\n\t\tif (!NeedFlags) {\n\t\t\t// all samples flags are the same after the 2nd entry\n\t\t\tif (RunFlags == traf->trex->def_sample_flags && !traf->trex->cannot_use_default) {\n\t\t\t\t/* this run can use trex flags */\n\t\t\t\tif (!UseDefaultFlag) {\n\t\t\t\t\t/* if all previous runs used explicit flags per sample, we can still use trex flags for this run */\n\t\t\t\t\tUseDefaultFlag = 2;\n\t\t\t\t} else if (UseDefaultFlag==1) {\n\t\t\t\t\t/* otherwise if one of the previous runs did use tfhd flags,\n\t\t\t\t\twe have no choice but to explicitly use flags per sample for this run */\n\t\t\t\t\tNeedFlags = GF_TRUE;\n\t\t\t\t}\n\t\t\t} else if (RunFlags == traf->tfhd->def_sample_flags) {\n\t\t\t\t/* this run can use tfhd flags */\n\t\t\t\tif (!UseDefaultFlag) {\n\t\t\t\t\t/* if all previous runs used explicit flags per sample, we can still use tfhd flags for this run */\n\t\t\t\t\tUseDefaultFlag = 1;\n\t\t\t\t} else if(UseDefaultFlag==2) {\n\t\t\t\t\t/* otherwise if one of the previous runs did use trex flags,\n\t\t\t\t\twe have no choice but to explicitly use flags per sample for this run */\n\t\t\t\t\tNeedFlags = GF_TRUE;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* the flags for the 2nd and following entries are different from trex and tfhd default values\n\t\t\t\t   (possible case: 2 samples in trun, and first sample was used to set default flags) */\n\t\t\t\tNeedFlags = GF_TRUE;\n\t\t\t}\n\t\t}\n\t\tif (NeedFlags) {\n\t\t\t//one flags entry per sample only\n\t\t\ttrun->flags |= GF_ISOM_TRUN_FLAGS;\n\t\t} else {\n\t\t\t/* this run can use default flags for the 2nd and following entries,\n\t\t\t   we just need to check if the first entry flags need to be singled out*/\n\t\t\tif (first_ent->flags != RunFlags) {\n\t\t\t\ttrun->flags |= GF_ISOM_TRUN_FIRST_FLAG;\n\t\t\t\t//if not old arch write the flags\n\t\t\t\t//in old arch we write 0, which means all deps unknown and sync sample set\n\t\t\t\tif (!traf->no_sdtp_first_flags)\n\t\t\t\t\ttrun->first_sample_flags = first_ent->flags;\n\t\t\t}\n\t\t}\n\n\t\t//CTS flag\n\t\tif (UseCTS) trun->flags |= GF_ISOM_TRUN_CTS_OFFSET;\n\n\t\t//run data offset if the offset indicated is 0 (first sample in this MDAT) don't\n\t\t//indicate it\n\t\tif (trun->data_offset)\n\t\t\ttrun->flags |= GF_ISOM_TRUN_DATA_OFFSET;\n\n\t\tsampleCount += trun->sample_count;\n\t}\n\n\t//after all runs in the traf are processed, update TRAF flags\n\tif (UseDefaultSize==1)\n\t\ttraf->tfhd->flags |= GF_ISOM_TRAF_SAMPLE_SIZE;\n\tif (UseDefaultDur==1)\n\t\ttraf->tfhd->flags |= GF_ISOM_TRAF_SAMPLE_DUR;\n\tif (UseDefaultFlag==1)\n\t\ttraf->tfhd->flags |= GF_ISOM_TRAF_SAMPLE_FLAGS;\n\tif (traf->trex->cannot_use_default || (traf->tfhd->sample_desc_index != traf->trex->def_sample_desc_index))\n\t\ttraf->tfhd->flags |= GF_ISOM_TRAF_SAMPLE_DESC;\n\n\n\treturn sampleCount;\n}\n\nstatic s32 get_earliest_cts_following(GF_TrackFragmentBox *traf, u32 trun_idx, u32 samp_idx)\n{\n\tGF_TrackFragmentRunBox *trun;\n\tGF_TrunEntry *ent;\n\ts32 earliest_cts = 0;\n\ts32 delta = 0;\n\tu32 j;\n\tu32 i=trun_idx;\n\twhile ((trun = (GF_TrackFragmentRunBox*)gf_list_enum(traf->TrackRuns, &i))) {\n\t\tj=samp_idx;\n\t\tsamp_idx=0;\n\t\tfor (; j<trun->nb_samples; j++) {\n\t\t\tent = &trun->samples[j];\n\t\t\tif (!j && (i==1)) {\n\t\t\t\tearliest_cts = ent->CTS_Offset;\n\t\t\t} else {\n\t\t\t\ts32 cts = ent->CTS_Offset+delta;\n\t\t\t\tif (earliest_cts > cts)\n\t\t\t\t\tearliest_cts = cts;\n\t\t\t}\n\t\t\tdelta += ent->Duration;\n\t\t}\n\t}\n\treturn earliest_cts;\n}\n\nstatic u32 moof_get_sap_info(GF_MovieFragmentBox *moof, GF_ISOTrackID refTrackID, u32 *sap_delta, Bool *starts_with_sap)\n{\n\tu32 i, j, count, sap_type, sap_sample_num, cur_sample;\n\ts32 delta, earliest_cts;\n\tBool first = GF_TRUE;\n\tGF_TrunEntry *ent;\n\tGF_TrackFragmentBox *traf=NULL;\n\tGF_TrackFragmentRunBox *trun;\n\tsap_type = 0;\n\t*sap_delta = 0;\n\t*starts_with_sap = GF_FALSE;\n\tfor (i=0; i<gf_list_count(moof->TrackList); i++) {\n\t\ttraf = (GF_TrackFragmentBox*)gf_list_get(moof->TrackList, i);\n\t\tif (traf->tfhd->trackID==refTrackID) break;\n\t\ttraf=NULL;\n\t}\n\tif (!traf) return sap_type;\n\tearliest_cts = 0;\n\n\t/*first check if we have a roll/rap sample in this traf, and mark its sample count*/\n\tsap_type = 0;\n\tsap_sample_num = 0;\n\t/*check RAP and ROLL*/\n\tcount = traf->sampleGroups ? gf_list_count(traf->sampleGroups) : 0;\n\tfor (i=0; i<count; i++) {\n\t\tGF_SampleGroupBox *sg;\n\t\tu32 first_sample;\n\t\tBool rap_type = GF_FALSE;\n\t\tsg = (GF_SampleGroupBox*)gf_list_get(traf->sampleGroups, i);\n\n\t\tswitch (sg->grouping_type) {\n\t\tcase GF_ISOM_SAMPLE_GROUP_RAP:\n\t\tcase GF_ISOM_SAMPLE_GROUP_SYNC:\n\t\t\trap_type = GF_TRUE;\n\t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_ROLL:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t\t/*first entry is SAP*/\n\t\tfirst_sample = 1;\n\t\tfor (j=0; j<sg->entry_count; j++) {\n\t\t\tif (! sg->sample_entries[j].group_description_index) {\n\t\t\t\tfirst_sample += sg->sample_entries[j].sample_count;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!j) {\n\t\t\t\t*starts_with_sap = GF_TRUE;\n\t\t\t\tsap_sample_num = 0;\n\t\t\t}\n\t\t\tif (!sap_sample_num || (sap_sample_num>first_sample)) {\n\t\t\t\tsap_type = rap_type ? 3 : 4;\n\t\t\t\tsap_sample_num = first_sample;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\t//compute earliest cts in segment\n\tearliest_cts = get_earliest_cts_following(traf, 0, 0);\n\n\t/*then browse all samples, looking for SYNC flag or sap_sample_num*/\n\tcur_sample = 1;\n\tdelta = 0;\n\ti=0;\n\twhile ((trun = (GF_TrackFragmentRunBox*)gf_list_enum(traf->TrackRuns, &i))) {\n\t\tif (trun->flags & GF_ISOM_TRUN_FIRST_FLAG) {\n\t\t\tif (GF_ISOM_GET_FRAG_SYNC(trun->flags)) {\n\t\t\t\tent = &trun->samples[0];\n\t\t\t\ts32 earliest_at_or_after_sap = get_earliest_cts_following(traf, i-1, 0);\n\t\t\t\t*sap_delta = (u32) (earliest_at_or_after_sap - earliest_cts);\n\n\t\t\t\t*starts_with_sap = first;\n\t\t\t\tsap_type = ent->SAP_type;\n\t\t\t\treturn sap_type;\n\t\t\t}\n\t\t}\n\t\tfor (j=0; j<trun->nb_samples; j++) {\n\t\t\tent = &trun->samples[j];\n\n\t\t\tif (GF_ISOM_GET_FRAG_SYNC(ent->flags)) {\n\t\t\t\ts32 earliest_at_or_after_sap = get_earliest_cts_following(traf, i-1, j);\n\t\t\t\t*sap_delta = (u32) (earliest_at_or_after_sap - earliest_cts);\n\t\t\t\t*starts_with_sap = first;\n\t\t\t\tsap_type = ent->SAP_type;\n\t\t\t\treturn sap_type;\n\t\t\t}\n\t\t\t/*we found our roll or rap sample*/\n\t\t\tif (cur_sample==sap_sample_num) {\n\t\t\t\t*sap_delta = (u32) (delta + ent->CTS_Offset - earliest_cts);\n\t\t\t\treturn sap_type;\n\t\t\t}\n\t\t\tdelta += ent->Duration;\n\t\t\tfirst = GF_FALSE;\n\t\t\tcur_sample++;\n\t\t}\n\t}\n\t/*not found*/\n\treturn 0;\n}\n\nu32 moof_get_duration(GF_MovieFragmentBox *moof, GF_ISOTrackID refTrackID)\n{\n\tu32 i, j, duration;\n\tGF_TrackFragmentBox *traf = NULL;\n\tGF_TrackFragmentRunBox *trun;\n\tfor (i=0; i<gf_list_count(moof->TrackList); i++) {\n\t\ttraf = (GF_TrackFragmentBox*)gf_list_get(moof->TrackList, i);\n\t\tif (traf->tfhd->trackID==refTrackID) break;\n\t\ttraf=NULL;\n\t}\n\tif (!traf) return 0;\n\n\tduration = 0;\n\ti=0;\n\twhile ((trun = (GF_TrackFragmentRunBox*)gf_list_enum(traf->TrackRuns, &i))) {\n\t\tfor (j=0; j<trun->nb_samples; j++) {\n\t\t\tGF_TrunEntry *ent = &trun->samples[j];\n\t\t\tif (ent->flags & GF_ISOM_TRAF_SAMPLE_DUR)\n\t\t\t\tduration += ent->Duration;\n\t\t\telse\n\t\t\t\tduration += traf->trex->def_sample_duration;\n\t\t}\n\t}\n\treturn duration;\n}\n\nstatic u64 moof_get_earliest_cts(GF_MovieFragmentBox *moof, GF_ISOTrackID refTrackID)\n{\n\tu32 i, j;\n\tu64 cts, duration;\n\tGF_TrackFragmentBox *traf=NULL;\n\tGF_TrackFragmentRunBox *trun;\n\tfor (i=0; i<gf_list_count(moof->TrackList); i++) {\n\t\ttraf = (GF_TrackFragmentBox*)gf_list_get(moof->TrackList, i);\n\t\tif (traf->tfhd->trackID==refTrackID) break;\n\t\ttraf=NULL;\n\t}\n\tif (!traf) return 0;\n\n\tduration = 0;\n\tcts = (u64) -1;\n\ti=0;\n\twhile ((trun = (GF_TrackFragmentRunBox*)gf_list_enum(traf->TrackRuns, &i))) {\n\t\tfor (j=0; j<trun->nb_samples; j++) {\n\t\t\tGF_TrunEntry *ent = &trun->samples[j];\n\t\t\tif (duration + ent->CTS_Offset < cts)\n\t\t\t\tcts = duration + ent->CTS_Offset;\n\t\t\tduration += ent->Duration;\n\t\t}\n\t}\n\treturn cts;\n}\n\n\nGF_Err gf_isom_write_compressed_box(GF_ISOFile *mov, GF_Box *root_box, u32 repl_type, GF_BitStream *bs, u32 *box_csize);\n\nvoid flush_ref_samples(GF_ISOFile *movie, u64 *out_seg_size, Bool use_seg_marker)\n{\n\tu32 i=0;\n\tu32 traf_count = movie->in_sidx_write ? 0 : gf_list_count(movie->moof->TrackList);\n\tfor (i=0; i<traf_count; i++) {\n\t\tGF_TrackFragmentBox *traf = gf_list_get(movie->moof->TrackList, i);\n\t\tu32 j, run_count = gf_list_count(traf->TrackRuns);\n\t\tif (!run_count) continue;\n\t\tfor (j=0; j<run_count; j++) {\n\t\t\tGF_TrackFragmentRunBox *trun = (GF_TrackFragmentRunBox *)gf_list_get(traf->TrackRuns, j);\n\t\t\tu32 s_count = gf_list_count(trun->sample_refs);\n\t\t\twhile (s_count) {\n\t\t\t\tif (!use_seg_marker && movie->on_last_block_start && (i+1==traf_count) && (j+1==run_count) && (s_count==1)) {\n\t\t\t\t\tmovie->on_last_block_start(movie->on_block_out_usr_data);\n\t\t\t\t}\n\t\t\t\tGF_TrafSampleRef *sref = gf_list_pop_front(trun->sample_refs);\n\t\t\t\tmovie->on_block_out(movie->on_block_out_usr_data, sref->data, sref->len, sref->ref, sref->ref_offset);\n\t\t\t\tif (out_seg_size) *out_seg_size += sref->len;\n\t\t\t\tif (!sref->ref) gf_free(sref->data);\n\t\t\t\tgf_free(sref);\n\t\t\t\ts_count--;\n\t\t\t}\n\t\t}\n\t}\n}\n\nGF_Err gf_bs_grow(GF_BitStream *bs, u32 addSize);\n\nstatic GF_Err StoreFragment(GF_ISOFile *movie, Bool load_mdat_only, s32 data_offset_diff, u32 *moof_size, Bool reassign_bs)\n{\n\tGF_Err e;\n\tu64 moof_start, pos, trun_ref_size=0;\n\tu32 size, i, s_count, mdat_size;\n\ts32 offset;\n\tu8 *buffer;\n\tGF_TrackFragmentBox *traf;\n\tGF_TrackFragmentRunBox *trun;\n\tGF_BitStream *bs, *bs_orig;\n\tif (!movie->moof) return GF_OK;\n\n\tbs = movie->editFileMap->bs;\n\tif (!movie->moof_first) {\n\t\tload_mdat_only = GF_FALSE;\n\t\tmovie->force_moof_base_offset = GF_FALSE;\n\t}\n\n\tmdat_size = 0;\n\t//1 - flush all caches\n\ti=0;\n\twhile ((traf = (GF_TrackFragmentBox*)gf_list_enum(movie->moof->TrackList, &i))) {\n\t\tu32 j, nb_written, last_gid, cur_sample_idx;\n\t\t/*do not write empty senc*/\n\t\tif (traf->sample_encryption && !gf_list_count(traf->sample_encryption->samp_aux_info)) {\n\t\t\tgf_list_del_item(traf->child_boxes, traf->sample_encryption);\n\t\t\tgf_isom_box_del((GF_Box *) traf->sample_encryption);\n\t\t\ttraf->sample_encryption = NULL;\n\t\t\t/*remove saiz and saio (todo, check if other saiz/saio types are used*/\n\t\t\tfor (j=0; j<gf_list_count(traf->sai_sizes); j++) {\n\t\t\t\tGF_SampleAuxiliaryInfoSizeBox *saiz = gf_list_get(traf->sai_sizes, j);\n\t\t\t\tswitch (saiz->aux_info_type) {\n\t\t\t\tcase GF_ISOM_CENC_SCHEME:\n\t\t\t\tcase GF_ISOM_CBC_SCHEME:\n\t\t\t\tcase GF_ISOM_CENS_SCHEME:\n\t\t\t\tcase GF_ISOM_CBCS_SCHEME:\n\t\t\t\tcase 0:\n\t\t\t\t\tgf_list_rem(traf->sai_sizes, j);\n\t\t\t\t\tgf_list_del_item(traf->child_boxes, saiz);\n\t\t\t\t\tgf_isom_box_del((GF_Box *)saiz);\n\t\t\t\t\tj--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (j=0; j<gf_list_count(traf->sai_offsets); j++) {\n\t\t\t\tGF_SampleAuxiliaryInfoOffsetBox *saio = gf_list_get(traf->sai_offsets, j);\n\t\t\t\tswitch (saio->aux_info_type) {\n\t\t\t\tcase GF_ISOM_CENC_SCHEME:\n\t\t\t\tcase GF_ISOM_CBC_SCHEME:\n\t\t\t\tcase GF_ISOM_CENS_SCHEME:\n\t\t\t\tcase GF_ISOM_CBCS_SCHEME:\n\t\t\t\tcase 0:\n\t\t\t\t\tgf_list_rem(traf->sai_offsets, j);\n\t\t\t\t\tgf_list_del_item(traf->child_boxes, saio);\n\t\t\t\t\tgf_isom_box_del((GF_Box *)saio);\n\t\t\t\t\tj--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttrun_ref_size += traf->trun_ref_size;\n\t\tif (!traf->DataCache) continue;\n\n\t\ts_count = gf_list_count(traf->TrackRuns);\n\t\tif (!s_count) continue;\n\n\t\t//store all cached truns - there may be more than one when using sample interleaving in truns\n\t\tnb_written = 0;\n\t\tlast_gid = 0;\n\t\tcur_sample_idx = 0;\n\t\twhile (nb_written<s_count) {\n\t\t\tu32 min_next_gid = 0xFFFFFFFF;\n\n\t\t\tfor (j=0; j<s_count; j++) {\n\t\t\t\ttrun = (GF_TrackFragmentRunBox *)gf_list_get(traf->TrackRuns, j);\n\t\t\t\t//done\n\t\t\t\tif (!trun->cache || !trun->sample_count) continue;\n\n\t\t\t\tif (!traf->use_sample_interleave || (last_gid!=trun->interleave_id)) {\n\t\t\t\t\tif (trun->interleave_id < min_next_gid)\n\t\t\t\t\t\tmin_next_gid = trun->interleave_id;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t//update offset\n\t\t\t\ttrun->data_offset = (u32) (gf_bs_get_position(bs) - movie->moof->fragment_offset - 8);\n\t\t\t\t//write cache\n\t\t\t\tgf_bs_get_content(trun->cache, &buffer, &size);\n\t\t\t\tgf_bs_write_data(bs, buffer, size);\n\t\t\t\tgf_bs_del(trun->cache);\n\t\t\t\tgf_free(buffer);\n\t\t\t\ttrun->cache = NULL;\n\t\t\t\ttrun->first_sample_idx = cur_sample_idx;\n\t\t\t\tcur_sample_idx += trun->sample_count;\n\n\t\t\t\tnb_written++;\n\t\t\t}\n\t\t\tlast_gid = min_next_gid;\n\t\t}\n\n\t\ttraf->DataCache=0;\n\t}\n\n\tif (load_mdat_only) {\n\t\tpos = trun_ref_size ? (trun_ref_size+8) : gf_bs_get_position(bs);\n\t\tif (movie->moof->fragment_offset > pos)\n\t\t\treturn GF_CORRUPTED_DATA;\n\n\t\t//we assume we never write large MDATs in fragment mode which should always be true\n\t\tmovie->moof->mdat_size = (u32) (pos - movie->moof->fragment_offset);\n\n\t\tif (trun_ref_size) {\n\t\t\tgf_bs_seek(movie->editFileMap->bs, 0);\n\t\t\treturn GF_OK;\n\t\t}\n\t\tif (movie->segment_bs) {\n\t\t\te = gf_bs_seek(bs, 0);\n\t\t\tif (e) return e;\n\t\t\t/*write mdat size*/\n\t\t\tgf_bs_write_u32(bs, (u32) movie->moof->mdat_size);\n\t\t\t/*and get internal buffer*/\n\t\t\te = gf_bs_seek(bs, movie->moof->mdat_size);\n\t\t\tif (e) return e;\n\t\t\tgf_bs_get_content(bs, &movie->moof->mdat, &movie->moof->mdat_size);\n\n\t\t\tgf_bs_del(bs);\n\t\t\tmovie->editFileMap->bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\t} else {\n\t\t\tu64 frag_offset = movie->segment_start;\n\t\t\te = gf_bs_seek(bs, frag_offset);\n\t\t\tif (e) return e;\n\t\t\t/*write mdat size*/\n\t\t\tgf_bs_write_u32(bs, (u32) movie->moof->mdat_size);\n\n\t\t\tmovie->moof->mdat = (char*)gf_malloc(sizeof(char) * movie->moof->mdat_size);\n\t\t\tif (!movie->moof->mdat) return GF_OUT_OF_MEM;\n\n\t\t\te = gf_bs_seek(bs, frag_offset);\n\t\t\tif (e) return e;\n\t\t\tgf_bs_read_data(bs, movie->moof->mdat, movie->moof->mdat_size);\n\n\t\t\te = gf_bs_seek(bs, frag_offset);\n\t\t\tif (e) return e;\n\t\t\tgf_bs_truncate(bs);\n\t\t}\n\n\t\treturn GF_OK;\n\t}\n\n\tmoof_start = gf_bs_get_position(bs);\n\n\tif (movie->moof->ntp) {\n\t\tmoof_start += 8*4;\n\t}\n\n\t//2- update MOOF MDAT header\n\tif (!movie->moof->mdat && !trun_ref_size) {\n\t\te = gf_bs_seek(bs, movie->moof->fragment_offset);\n\t\tif (e) return e;\n\t\t//we assume we never write large MDATs in fragment mode which should always be true\n\t\tmdat_size = (u32) (moof_start - movie->moof->fragment_offset);\n\t\tgf_bs_write_u32(bs, (u32) mdat_size);\n\t\tgf_bs_write_u32(bs, GF_ISOM_BOX_TYPE_MDAT);\n\t\te = gf_bs_seek(bs, moof_start);\n\t\tif (e) return e;\n\t}\n\n\t/*estimate moof size and shift trun offsets*/\n#ifndef USE_BASE_DATA_OFFSET\n\toffset = 0;\n\tif (movie->use_segments || movie->force_moof_base_offset) {\n\t\te = gf_isom_box_size((GF_Box *) movie->moof);\n\t\tif (e) return e;\n\t\toffset = (s32) movie->moof->size;\n\t\t/*mdat size & type*/\n\t\toffset += 8;\n\t\tupdate_trun_offsets(movie, offset);\n\t}\n#endif\n\n\t//3- clean our traf's\n\ti=0;\n\twhile ((traf = (GF_TrackFragmentBox*) gf_list_enum(movie->moof->TrackList, &i))) {\n\t\t//compute default settings for the TRAF\n\t\tComputeFragmentDefaults(traf);\n\t\t//updates all trun and set all flags, INCLUDING TRAF FLAGS (durations, ...)\n\t\ts_count = UpdateRuns(movie, traf);\n\t\t//empty fragment destroy it\n\t\tif (!traf->tfhd->EmptyDuration && !s_count) {\n\t\t\ti--;\n\t\t\tgf_list_rem(movie->moof->TrackList, i);\n\t\t\tgf_isom_box_del_parent(&movie->moof->child_boxes, (GF_Box *) traf);\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tbuffer = NULL;\n\t/*rewind bitstream and load mdat in memory */\n\tif (movie->moof_first && !movie->moof->mdat && !trun_ref_size) {\n\t\tbuffer = (char*)gf_malloc(sizeof(char)*mdat_size);\n\t\tif (!buffer) return GF_OUT_OF_MEM;\n\t\te = gf_bs_seek(bs, movie->moof->fragment_offset);\n\t\tif (e) return e;\n\t\tgf_bs_read_data(bs, buffer, mdat_size);\n\t\t/*back to mdat start and erase with moov*/\n\t\te = gf_bs_seek(bs, movie->moof->fragment_offset);\n\t\tif (e) return e;\n\t\tgf_bs_truncate(bs);\n\t}\n\n\t//4- Write moof\n\te = gf_isom_box_size((GF_Box *) movie->moof);\n\tif (e) return e;\n\t/*moof first, update traf headers - THIS WILL IMPACT THE MOOF SIZE IF WE\n\tDECIDE NOT TO USE THE DATA-OFFSET FLAG*/\n\tif (movie->moof_first\n#ifndef USE_BASE_DATA_OFFSET\n\t        && !(movie->use_segments || movie->force_moof_base_offset)\n#endif\n\t   ) {\n\t\ti=0;\n\t\twhile ((traf = (GF_TrackFragmentBox*)gf_list_enum(movie->moof->TrackList, &i))) {\n\t\t\t/*offset increases by moof size*/\n\t\t\ttraf->tfhd->base_data_offset += movie->moof->size;\n\t\t\ttraf->tfhd->base_data_offset += data_offset_diff;\n\t\t\tif (movie->on_block_out) {\n\t\t\t\ttraf->tfhd->base_data_offset += movie->fragmented_file_pos;\n\t\t\t}\n\t\t}\n\t}\n#ifndef USE_BASE_DATA_OFFSET\n\telse if (movie->use_segments || movie->force_moof_base_offset) {\n\t\tif (offset != (movie->moof->size+8)) {\n\t\t\toffset = (s32) (movie->moof->size + 8 - offset);\n\t\t\tupdate_trun_offsets(movie, offset);\n\t\t\te = gf_isom_box_size((GF_Box *) movie->moof);\n\t\t\tif (e) return e;\n\t\t}\n\t}\n#endif\n\n\tif (!movie->moof_first && !movie->force_moof_base_offset) {\n\t\ti=0;\n\t\twhile ((traf = (GF_TrackFragmentBox*)gf_list_enum(movie->moof->TrackList, &i))) {\n\t\t\t/*offset increases by moof size*/\n\t\t\tif (movie->on_block_out) {\n\t\t\t\ttraf->tfhd->base_data_offset += movie->fragmented_file_pos;\n\t\t\t}\n\t\t}\n\t}\n\n\tbs_orig = bs;\n\tif (reassign_bs && movie->on_block_out) {\n\t\tbs = gf_bs_new_cbk(isom_on_block_out, movie, movie->on_block_out_block_size);\n\t}\n\n\tif (trun_ref_size && movie->in_sidx_write) {\n\t\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t}\n\n\tif (movie->moof->ntp) {\n\t\tgf_bs_write_u32(bs, 8*4);\n\t\tgf_bs_write_u32(bs, GF_ISOM_BOX_TYPE_PRFT );\n\t\tgf_bs_write_u8(bs, 1);\n\t\tgf_bs_write_u24(bs, 0);\n\t\tgf_bs_write_u32(bs, movie->moof->reference_track_ID);\n\t\tgf_bs_write_u64(bs, movie->moof->ntp);\n\t\tgf_bs_write_u64(bs, movie->moof->timestamp);\n\t}\n\tif (movie->moof->emsgs) {\n\t\twhile (1) {\n\t\t\tGF_Box *emsg = gf_list_pop_front(movie->moof->emsgs);\n\t\t\tif (!emsg) break;\n\t\t\tgf_isom_box_size(emsg);\n\t\t\tgf_isom_box_write(emsg, bs);\n\t\t\tgf_isom_box_del(emsg);\n\t\t}\n\t\tgf_list_del(movie->moof->emsgs);\n\t\tmovie->moof->emsgs = NULL;\n\t}\n\n\tif (moof_size) *moof_size = (u32) movie->moof->size;\n\n\tpos = gf_bs_get_position(bs);\n\t//graw buffer to hold moof, speeds up writes\n\tgf_bs_grow(bs, (u32) movie->moof->size + (trun_ref_size ? 8 : 0));\n\n\ti=0;\n\twhile ((traf = (GF_TrackFragmentBox*)gf_list_enum(movie->moof->TrackList, &i))) {\n\t\ttraf->moof_start_in_bs = pos;\n\t}\n\n\t/*we don't want to dispatch any block until done writing the moof*/\n\tif (movie->on_block_out)\n\t\tgf_bs_prevent_dispatch(bs, GF_TRUE);\n\n\tif (movie->compress_mode>GF_ISOM_COMP_MOOV) {\n\t\te = gf_isom_write_compressed_box(movie, (GF_Box *) movie->moof, GF_4CC('!', 'm', 'o', 'f'), bs, moof_size);\n\t} else {\n\t\te = gf_isom_box_write((GF_Box *) movie->moof, bs);\n\t}\n\n\tif (trun_ref_size) {\n\t\tgf_bs_write_u32(bs, movie->moof->mdat_size);\n\t\tgf_bs_write_u32(bs, GF_ISOM_BOX_TYPE_MDAT);\n\t}\n\n\tif (movie->on_block_out)\n\t\tgf_bs_prevent_dispatch(bs, GF_FALSE);\n\n\tif (e) return e;\n\n\tif (trun_ref_size) {\n\t\tflush_ref_samples(movie, NULL, GF_FALSE);\n\t} else {\n\t\tif (movie->on_last_block_start && !gf_list_count(movie->moof_list))\n\t\t\tmovie->on_last_block_start(movie->on_block_out_usr_data);\n\n\t\t//rewrite mdat after moof\n\t\tif (movie->moof->mdat) {\n\t\t\tgf_bs_write_data(bs, movie->moof->mdat, movie->moof->mdat_size);\n\t\t\tgf_free(movie->moof->mdat);\n\t\t\tmovie->moof->mdat = NULL;\n\t\t} else if (buffer) {\n\t\t\tgf_bs_write_data(bs, buffer, mdat_size);\n\t\t\tgf_free(buffer);\n\t\t}\n\t}\n\n\tif (trun_ref_size && movie->in_sidx_write) {\n\t\tgf_bs_get_content(bs, &movie->moof->moof_data, &movie->moof->moof_data_len);\n\t\tgf_bs_del(bs);\n\t\tmovie->fragmented_file_pos += movie->moof->moof_data_len + trun_ref_size;\n\t\tmovie->moof->trun_ref_size = (u32) trun_ref_size;\n\t}\n\telse if (bs != bs_orig) {\n\t\tu64 frag_size = gf_bs_get_position(bs);\n\t\tgf_bs_del(bs);\n\t\tmovie->fragmented_file_pos += frag_size + trun_ref_size;\n\t\tgf_bs_seek(bs_orig, 0);\n\t\tgf_bs_truncate(bs_orig);\n\t}\n\telse if (movie->on_block_out) {\n\t\tu64 frag_size = gf_bs_get_position(bs);\n\t\tmovie->fragmented_file_pos += frag_size + trun_ref_size;\n\t}\n\n\tif (!movie->use_segments) {\n\t\t//remove from moof list (may happen in regular fragmentation when single traf per moof is used)\n\t\tgf_list_del_item(movie->moof_list, movie->moof);\n\t\tgf_isom_box_del((GF_Box *) movie->moof);\n\t\tmovie->moof = NULL;\n\t}\n\treturn GF_OK;\n}\n\nstatic GF_Err sidx_rewrite(GF_SegmentIndexBox *sidx, GF_BitStream *bs, u64 start_pos, GF_SubsegmentIndexBox *ssix)\n{\n\tGF_Err e = GF_OK;\n\tu64 pos = gf_bs_get_position(bs);\n\tif (ssix) {\n\t\te = gf_isom_box_size((GF_Box *)ssix);\n\t\tsidx->first_offset = ssix->size;\n\t}\n\t/*write sidx*/\n\tgf_bs_seek(bs, start_pos);\n\tif (!e) e = gf_isom_box_write((GF_Box *) sidx, bs);\n\tif (!e && ssix) {\n\t\te = gf_isom_box_write((GF_Box *) ssix, bs);\n\t}\n\tgf_bs_seek(bs, pos);\n\treturn e;\n}\n\nGF_Err gf_isom_allocate_sidx(GF_ISOFile *movie, s32 subsegs_per_sidx, Bool daisy_chain_sidx, u32 nb_segs, u32 *frags_per_segment, u32 *start_range, u32 *end_range, Bool use_ssix)\n{\n\tGF_BitStream *bs;\n\tGF_Err e;\n\tu32 i;\n\n\t//and only at setup\n\tif (!movie || !(movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY) ) return GF_BAD_PARAM;\n\tif (movie->openMode != GF_ISOM_OPEN_WRITE) return GF_ISOM_INVALID_MODE;\n\tif (movie->root_sidx) return GF_BAD_PARAM;\n\tif (movie->root_ssix) return GF_BAD_PARAM;\n\tif (movie->moof) return GF_BAD_PARAM;\n\tif (gf_list_count(movie->moof_list)) return GF_BAD_PARAM;\n\n\tmovie->root_sidx = (GF_SegmentIndexBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_SIDX);\n\tif (!movie->root_sidx) return GF_OUT_OF_MEM;\n\t/*we don't write anything between sidx and following moov*/\n\tmovie->root_sidx->first_offset = 0;\n\n\t/*for now we only store one ref per subsegment and don't support daisy-chaining*/\n\tmovie->root_sidx->nb_refs = nb_segs;\n\n\tif (use_ssix) {\n\t\tmovie->root_ssix = (GF_SubsegmentIndexBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_SSIX);\n\t\tmovie->root_ssix->subsegment_count = nb_segs;\n\t\tmovie->root_ssix->subsegment_alloc = movie->root_ssix->subsegment_count;\n\t}\n\n\t//dynamic mode\n\tif (!nb_segs) {\n\t\tmovie->dyn_root_sidx = GF_TRUE;\n\t\treturn GF_OK;\n\t}\n\n\tmovie->root_sidx->refs = (GF_SIDXReference*)gf_malloc(sizeof(GF_SIDXReference) * movie->root_sidx->nb_refs);\n\tif (!movie->root_sidx->refs) return GF_OUT_OF_MEM;\n\tmemset(movie->root_sidx->refs, 0, sizeof(GF_SIDXReference) * movie->root_sidx->nb_refs);\n\n\tmovie->root_sidx_index = 0;\n\n\tif (use_ssix) {\n\t\tmovie->root_ssix->subsegments = gf_malloc(sizeof(GF_SubsegmentInfo) * nb_segs);\n\t\tif (!movie->root_ssix->subsegments) return GF_OUT_OF_MEM;\n\t\tfor (i=0; i<nb_segs; i++) {\n\t\t\tmovie->root_ssix->subsegments[i].range_count = 2;\n\t\t\tmovie->root_ssix->subsegments[i].ranges = gf_malloc(sizeof(GF_SubsegmentRangeInfo)*2);\n\t\t\tif (!movie->root_ssix->subsegments[i].ranges) return GF_OUT_OF_MEM;\n\t\t\tmovie->root_ssix->subsegments[i].ranges[0].level = 0;\n\t\t\tmovie->root_ssix->subsegments[i].ranges[0].range_size = 0;\n\t\t\tmovie->root_ssix->subsegments[i].ranges[1].level = 1;\n\t\t\tmovie->root_ssix->subsegments[i].ranges[1].range_size = 0;\n\t\t}\n\t}\n\t\n\t/*remember start of sidx*/\n\tmovie->root_sidx_offset = gf_bs_get_position(movie->editFileMap->bs);\n\n\tbs = movie->editFileMap->bs;\n\n\te = gf_isom_box_size((GF_Box *) movie->root_sidx);\n\tif (e) return e;\n\te = gf_isom_box_write((GF_Box *) movie->root_sidx, bs);\n\tif (e) return e;\n\n\tif (movie->root_ssix) {\n\t\te = gf_isom_box_size((GF_Box *) movie->root_ssix);\n\t\tif (e) return e;\n\t\te = gf_isom_box_write((GF_Box *) movie->root_ssix, bs);\n\t\tif (e) return e;\n\t}\n\n\t//include ssix in index range - spec is not clear whether this is forbidden\n\tif (start_range) *start_range = (u32) movie->root_sidx_offset;\n\tif (end_range) *end_range = (u32) gf_bs_get_position(bs)-1;\n\n\treturn GF_OK;\n}\n\n\nstatic GF_Err gf_isom_write_styp(GF_ISOFile *movie, Bool last_segment)\n{\n\t/*write STYP if we write to a different file or if we write the last segment*/\n\tif (movie->use_segments && !movie->append_segment && !movie->segment_start && movie->write_styp) {\n\t\tGF_Err e;\n\n\t\t/*modify brands STYP*/\n\t\tif (movie->write_styp==1) {\n\t\t\t/*\"msix\" brand: this is a DASH Initialization Segment*/\n\t\t\tgf_isom_modify_alternate_brand(movie, GF_ISOM_BRAND_MSIX, GF_TRUE);\n\t\t\tif (last_segment) {\n\t\t\t\t/*\"lmsg\" brand: this is the last DASH Segment*/\n\t\t\t\tgf_isom_modify_alternate_brand(movie, GF_ISOM_BRAND_LMSG, GF_TRUE);\n\t\t\t}\n\t\t}\n\t\tmovie->brand->type = GF_ISOM_BOX_TYPE_STYP;\n\t\te = gf_isom_box_size((GF_Box *) movie->brand);\n\t\tif (e) return e;\n\t\te = gf_isom_box_write((GF_Box *) movie->brand, movie->editFileMap->bs);\n\t\tif (e) return e;\n\n\t\tmovie->write_styp = 0;\n\t}\n\n\tif (movie->emsgs) {\n\t\twhile (1) {\n\t\t\tGF_Box *b = gf_list_pop_front(movie->emsgs);\n\t\t\tif (!b) break;\n\t\t\tgf_isom_box_size(b);\n\t\t\tgf_isom_box_write(b, movie->editFileMap->bs);\n\t\t\tgf_isom_box_del(b);\n\t\t}\n\t\tgf_list_del(movie->emsgs);\n\t\tmovie->emsgs = NULL;\n\t}\n\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_flush_fragments(GF_ISOFile *movie, Bool last_segment)\n{\n\tGF_BitStream *temp_bs = NULL, *orig_bs;\n\tGF_Err e;\n\n\tif (!movie || !(movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY) ) return GF_BAD_PARAM;\n\tif (movie->openMode != GF_ISOM_OPEN_WRITE) return GF_ISOM_INVALID_MODE;\n\n\t/*flush our fragment (store in mem)*/\n\tif (movie->moof) {\n\t\te = StoreFragment(movie, GF_TRUE, 0, NULL, GF_FALSE);\n\t\tif (e) return e;\n\t}\n\n\tif (movie->segment_bs) {\n\t\ttemp_bs = movie->editFileMap->bs;\n\t\tmovie->editFileMap->bs = movie->segment_bs;\n\t}\n\n\tif (movie->moof_first) {\n\t\tgf_bs_seek(movie->editFileMap->bs, movie->segment_start);\n\t\tgf_bs_truncate(movie->editFileMap->bs);\n\t}\n\n\torig_bs = movie->editFileMap->bs;\n\tif (movie->on_block_out) {\n\t\tif (!movie->block_buffer) movie->block_buffer_size = movie->on_block_out_block_size;\n\t\tmovie->editFileMap->bs = gf_bs_new_cbk_buffer(isom_on_block_out, movie, movie->block_buffer, movie->block_buffer_size);\n\t}\n\n\t/*write styp to file if needed*/\n\te = gf_isom_write_styp(movie, last_segment);\n\tif (e) goto exit;\n\n\t/*write all pending fragments to file*/\n\twhile (gf_list_count(movie->moof_list)) {\n\t\ts32 offset_diff;\n\t\tu32 moof_size;\n\n\t\tmovie->moof = (GF_MovieFragmentBox*)gf_list_get(movie->moof_list, 0);\n\t\tgf_list_rem(movie->moof_list, 0);\n\n\t\toffset_diff = (s32) (gf_bs_get_position(movie->editFileMap->bs) - movie->moof->fragment_offset);\n\t\tmovie->moof->fragment_offset = gf_bs_get_position(movie->editFileMap->bs);\n\n\t\te = StoreFragment(movie, GF_FALSE, offset_diff, &moof_size, GF_FALSE);\n\t\tif (e) goto exit;\n\n\t\tgf_isom_box_del((GF_Box *) movie->moof);\n\t\tmovie->moof = NULL;\n\t}\n\n\t/*append mode: store fragment at the end of the regular movie bitstream, and delete the temp bitstream*/\n\tif (movie->append_segment) {\n\t\tchar bloc[1024];\n\t\tu32 seg_size = (u32) gf_bs_get_size(movie->editFileMap->bs);\n\t\tgf_bs_seek(movie->editFileMap->bs, 0);\n\t\twhile (seg_size) {\n\t\t\tu32 size = gf_bs_read_data(movie->editFileMap->bs, bloc, (seg_size>1024) ? 1024 : seg_size);\n\t\t\tgf_bs_write_data(movie->movieFileMap->bs, bloc, size);\n\t\t\tseg_size -= size;\n\t\t}\n\t\tgf_isom_datamap_flush(movie->movieFileMap);\n\n\t\tgf_isom_datamap_del(movie->editFileMap);\n\t\tmovie->editFileMap = gf_isom_fdm_new_temp(NULL);\n\t} else {\n\t\tgf_isom_datamap_flush(movie->editFileMap);\n\t}\n\tmovie->segment_start = gf_bs_get_position(movie->editFileMap->bs);\n\n\tif (temp_bs) {\n\t\tmovie->segment_bs = movie->editFileMap->bs;\n\t\tmovie->editFileMap->bs = temp_bs;\n\t}\n\n\tif (orig_bs != movie->editFileMap->bs) {\n\t\tu32 tmpsize;\n\t\tif (!movie->moof_first) {\n\t\t\tgf_bs_transfer(movie->editFileMap->bs, orig_bs, GF_TRUE);\n\t\t\tgf_bs_seek(orig_bs, 0);\n\t\t}\n\t\tgf_bs_get_content_no_truncate(movie->editFileMap->bs, &movie->block_buffer, &tmpsize, &movie->block_buffer_size);\n\t\tgf_bs_del(movie->editFileMap->bs);\n\t\tmovie->editFileMap->bs = orig_bs;\n\t\t//we are dispatching through callbacks, the movie segment start is always 0\n\t\tmovie->segment_start = 0;\n\t}\nexit:\n\treturn e;\n}\n\ntypedef struct\n{\n\tGF_SegmentIndexBox *sidx;\n\tu64 start_offset, end_offset;\n} SIDXEntry;\n\nstatic u64 get_presentation_time(u64 media_time, s32 ts_shift)\n{\n\tif ((ts_shift<0) && (media_time < -ts_shift)) {\n\t\tmedia_time = 0;\n\t} else {\n\t\tmedia_time += ts_shift;\n\t}\n\treturn media_time ;\n}\n\n\n#if 0 //unused\n/*! gets name of current segment (or last segment if called between close_segment and start_segment)\n\\param isom_file the target ISO file\n\\return associated file name of the segment\n*/\nGF_EXPORT\nconst char *gf_isom_get_segment_name(GF_ISOFile *movie)\n{\n\tif (!movie) return NULL;\n\tif (movie->append_segment) return movie->movieFileMap->szName;\n\treturn movie->editFileMap->szName;\n}\n#endif\n\nstatic void compute_seg_size(GF_ISOFile *movie, u64 *out_seg_size)\n{\n\tu64 final_size = 0;\n\tif (out_seg_size) {\n\t\tif (movie->append_segment) {\n\t\t\tfinal_size = gf_bs_get_position(movie->movieFileMap->bs);\n\t\t\tfinal_size -= movie->segment_start;\n\t\t} else if (movie->editFileMap) {\n\t\t\tfinal_size = gf_bs_get_position(movie->editFileMap->bs);\n\t\t}\n\t\t*out_seg_size = final_size;\n\t}\n}\n\nstatic u32 moof_get_first_sap_end(GF_MovieFragmentBox *moof)\n{\n\tu32 i, count = gf_list_count(moof->TrackList);\n\tfor (i=0; i<count; i++) {\n\t\tu32 j, nb_trun;\n\t\tGF_TrackFragmentBox *traf = gf_list_get(moof->TrackList, i);\n\t\tu32 base_offset = (u32) traf->tfhd->base_data_offset;\n\n\t\tnb_trun = gf_list_count(traf->TrackRuns);\n\t\tfor (j=0; j<nb_trun; j++) {\n\t\t\tu32 k;\n\t\t\tGF_TrackFragmentRunBox *trun = gf_list_get(traf->TrackRuns, j);\n\t\t\tu32 offset = base_offset + trun->data_offset;\n\t\t\tfor (k=0; k<trun->nb_samples; k++) {\n\t\t\t\tGF_TrunEntry *ent = &trun->samples[k];\n\t\t\t\tif (ent->SAP_type) return offset + ent->size;\n\n\t\t\t\toffset += ent->size;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic u64 estimate_next_moof_earliest_presentation_time(u64 ref_track_decode_time, s32 ts_shift, u32 refTrackID, GF_ISOFile *movie)\n{\n\tu32 i, j, nb_aus, nb_ctso, nb_moof;\n\tu64 duration;\n\tGF_TrunEntry *ent;\n\tGF_TrackFragmentBox *traf=NULL;\n\tGF_TrackFragmentRunBox *trun;\n\tu32 timescale;\n\tu64 min_next_cts = -1;\n\n\tGF_MovieFragmentBox *moof = gf_list_get(movie->moof_list, 0);\n\n\tfor (i=0; i<gf_list_count(moof->TrackList); i++) {\n\t\ttraf = (GF_TrackFragmentBox*)gf_list_get(moof->TrackList, i);\n\t\tif (traf->tfhd->trackID==refTrackID) break;\n\t\ttraf = NULL;\n\t}\n\t//no ref track, nothing to estimate\n\tif (!traf) return -1;\n\ttimescale = traf->trex->track->Media->mediaHeader->timeScale;\n\n\tnb_aus = 0;\n\tduration = 0;\n\tnb_ctso = 0;\n\tnb_moof = 0;\n\n\twhile ((moof = (GF_MovieFragmentBox*)gf_list_enum(movie->moof_list, &nb_moof))) {\n\n\t\tfor (i=0; i<gf_list_count(moof->TrackList); i++) {\n\t\t\ttraf = (GF_TrackFragmentBox*)gf_list_get(moof->TrackList, i);\n\t\t\tif (traf->tfhd->trackID==refTrackID) break;\n\t\t\ttraf = NULL;\n\t\t}\n\t\tif (!traf) continue;\n\n\t\ti=0;\n\t\twhile ((trun = (GF_TrackFragmentRunBox*)gf_list_enum(traf->TrackRuns, &i))) {\n\t\t\tfor (j=0; j<trun->nb_samples; j++) {\n\t\t\t\tent = &trun->samples[j];\n\t\t\t\tif (nb_aus + 1 + movie->sidx_pts_store_count > movie->sidx_pts_store_alloc) {\n\t\t\t\t\tmovie->sidx_pts_store_alloc = movie->sidx_pts_store_count+nb_aus+1;\n\t\t\t\t\tmovie->sidx_pts_store = gf_realloc(movie->sidx_pts_store, sizeof(u64) * movie->sidx_pts_store_alloc);\n\t\t\t\t\tmovie->sidx_pts_next_store = gf_realloc(movie->sidx_pts_next_store, sizeof(u64) * movie->sidx_pts_store_alloc);\n\t\t\t\t}\n\t\t\t\t//get PTS for this AU, push to regular list\n\t\t\t\tmovie->sidx_pts_store[movie->sidx_pts_store_count + nb_aus] = get_presentation_time( ref_track_decode_time + duration + ent->CTS_Offset, ts_shift);\n\t\t\t\t//get PTS for this AU shifted by its presentation duration, push to shifted list\n\t\t\t\tmovie->sidx_pts_next_store[movie->sidx_pts_store_count + nb_aus] = get_presentation_time( ref_track_decode_time + duration + ent->CTS_Offset + ent->Duration, ts_shift);\n\t\t\t\tduration += ent->Duration;\n\t\t\t\tif (ent->CTS_Offset)\n\t\t\t\t\tnb_ctso++;\n\n\t\t\t\tnb_aus++;\n\t\t\t}\n\t\t}\n\t}\n\n\tmovie->sidx_pts_store_count += nb_aus;\n\n\t//no AUs, nothing to estimate\n\tif (!nb_aus) {\n\t\tmovie->sidx_pts_store_count = 0;\n\t\treturn -1;\n\t}\n\t//no cts offset, assume earliest PTS in next segment is last PTS in this segment + duration\n\tif (!nb_ctso) {\n\t\tmin_next_cts = movie->sidx_pts_next_store[movie->sidx_pts_store_count - 1];\n\t\tmovie->sidx_pts_store_count = 0;\n\t\treturn min_next_cts;\n\t}\n\n\t//look for all shifted PTS of this segment in the regular list. If found in the shifted list, the AU is in this segment\n\t//remove from both list\n\tfor (i=0; i<movie->sidx_pts_store_count; i++) {\n\t\tfor (j=i; j<movie->sidx_pts_store_count; j++) {\n\t\t\t/*\n\n \t\t\tif (movie->sidx_pts_next_store[i] == movie->sidx_pts_store[j]) {\n \t\t\t\n\t\t\ttake care of misaligned timescale eg 24fps but 10000 timescale), we may not find exactly\n\t\t\tthe same sample - if diff below N ms consider it a match\n\t\t\tnot doing so would accumulate PTSs in the list, slowing down the muxing\n\n\t\t\tusing N=1ms strict would not be enough to take into account sources with approximate timing - cf issue #2436\n\t\t\twe use N=2ms max to handle sources with high jitter in cts\n\t\t\t*/\n\t\t\ts64 diff = movie->sidx_pts_next_store[i];\n\t\t\tdiff -= (s64) movie->sidx_pts_store[j];\n\t\t\tif (diff && (timescale>1000)) {\n\t\t\t\tif (ABS(diff) * 1000 < 2 * timescale)\n\t\t\t\t\tdiff = 0;\n\t\t\t}\n\t\t\tif (diff==0) {\n\t\t\t\tif (movie->sidx_pts_store_count >= i + 1)\n\t\t\t\t\tmemmove(&movie->sidx_pts_next_store[i], &movie->sidx_pts_next_store[i+1], sizeof(u64) * (movie->sidx_pts_store_count - i - 1) );\n\t\t\t\tif (movie->sidx_pts_store_count >= j + 1)\n\t\t\t\t\tmemmove(&movie->sidx_pts_store[j], &movie->sidx_pts_store[j+1], sizeof(u64) * (movie->sidx_pts_store_count - j - 1) );\n\t\t\t\tmovie->sidx_pts_store_count--;\n\t\t\t\ti--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t//the shifted list contain all AUs not yet in this segment, keep the smallest to compute the earliest PTS in next seg\n\t//note that we assume the durations were correctly set\n\tfor (i=0; i<movie->sidx_pts_store_count; i++) {\n\t\tif (min_next_cts > movie->sidx_pts_next_store[i])\n\t\t\tmin_next_cts = movie->sidx_pts_next_store[i];\n\t}\n\treturn min_next_cts;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_close_segment(GF_ISOFile *movie, s32 subsegments_per_sidx, GF_ISOTrackID referenceTrackID, u64 ref_track_decode_time, s32 ts_shift, u64 ref_track_next_cts, Bool daisy_chain_sidx, Bool use_ssix, Bool last_segment, Bool close_segment_handle, u32 segment_marker_4cc, u64 *index_start_range, u64 *index_end_range, u64 *out_seg_size)\n{\n\tGF_SegmentIndexBox *sidx=NULL;\n\tGF_SegmentIndexBox *root_sidx=NULL;\n\tGF_SubsegmentIndexBox *ssix=NULL;\n\tGF_List *daisy_sidx = NULL;\n\tGF_List *defer_moofs = NULL;\n\tGF_BitStream *orig_bs;\n\tu64 sidx_start, sidx_end;\n\tBool first_frag_in_subseg;\n\tBool no_sidx = GF_FALSE;\n\tu32 count, cur_idx, cur_dur, sidx_dur, sidx_idx, idx_offset, frag_count;\n\tu64 last_top_box_pos, root_prev_offset, local_sidx_start, local_sidx_end, prev_earliest_cts, next_earliest_cts;\n\tGF_TrackBox *trak = NULL;\n\tGF_Err e;\n\t/*number of subsegment in this segment (eg nb references in the first SIDX found)*/\n\tu32 nb_subsegs=0;\n\t/*number of subsegment per sidx (eg number of references of any sub-SIDX*/\n\tu32 subseg_per_sidx;\n\t/*number of fragments per subsegment*/\n\tu32 frags_per_subseg;\n\t/*number of fragments per subsidx*/\n\tu32 frags_per_subsidx;\n\n\tsidx_start = sidx_end = 0;\n\n\tif (index_start_range) *index_start_range = 0;\n\tif (index_end_range) *index_end_range = 0;\n\n\t//and only at setup\n\tif (!movie || !(movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY) ) return GF_BAD_PARAM;\n\tif (movie->openMode != GF_ISOM_OPEN_WRITE) return GF_ISOM_INVALID_MODE;\n\n\tcount = gf_list_count(movie->moov->mvex->TrackExList);\n\tif (!count) return GF_BAD_PARAM;\n\n\t/*store fragment*/\n\tif (movie->moof) {\n\t\te = StoreFragment(movie, GF_TRUE, 0, NULL, GF_FALSE);\n\t\tif (e) return e;\n\t}\n\t/*restore final bitstream*/\n\tif (movie->segment_bs) {\n\t\tgf_bs_del(movie->editFileMap->bs);\n\t\tmovie->editFileMap->bs = movie->segment_bs;\n\t\tmovie->segment_bs = NULL;\n\t}\n\n\tcount = gf_list_count(movie->moof_list);\n\tif (!count) {\n\t\t/*append segment marker box*/\n\t\tif (segment_marker_4cc) {\n\t\t\tif (movie->append_segment) {\n\t\t\t\tgf_bs_write_u32(movie->movieFileMap->bs, 8);\t//write size field\n\t\t\t\tgf_bs_write_u32(movie->movieFileMap->bs, segment_marker_4cc); //write box type field\n\t\t\t} else {\n\t\t\t\tgf_bs_write_u32(movie->editFileMap->bs, 8);\t//write size field\n\t\t\t\tgf_bs_write_u32(movie->editFileMap->bs, segment_marker_4cc); //write box type field\n\t\t\t}\n\t\t}\n\n\t\tcompute_seg_size(movie, out_seg_size);\n\n\t\tif (close_segment_handle) {\n\t\t\tgf_isom_datamap_del(movie->editFileMap);\n\t\t\tmovie->editFileMap = NULL;\n\t\t}\n\n\t\treturn GF_OK;\n\t}\n\n\tgf_bs_seek(movie->editFileMap->bs, movie->segment_start);\n\tgf_bs_truncate(movie->editFileMap->bs);\n\n\tidx_offset = 0;\n\n\tif (referenceTrackID) {\n\t\ttrak = gf_isom_get_track_from_id(movie->moov, referenceTrackID);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t}\n\n\tif (subsegments_per_sidx < 0) {\n\t\treferenceTrackID = 0;\n\t\tsubsegments_per_sidx = 0;\n\t}\n\tif (!subsegments_per_sidx && !referenceTrackID) {\n\t\tno_sidx = GF_TRUE;\n\t}\n\n\torig_bs = movie->editFileMap->bs;\n\tif (movie->on_block_out) {\n\t\tif (!movie->block_buffer) movie->block_buffer_size = movie->on_block_out_block_size;\n\t\tmovie->editFileMap->bs = gf_bs_new_cbk_buffer(isom_on_block_out, movie, movie->block_buffer, movie->block_buffer_size);\n\t\tif (referenceTrackID) gf_bs_prevent_dispatch(movie->editFileMap->bs, GF_TRUE);\n\t}\n\n\te = gf_isom_write_styp(movie, last_segment);\n\tif (e) goto exit;\n\n\tfrags_per_subseg = 0;\n\tsubseg_per_sidx = 0;\n\tfrags_per_subsidx = 0;\n\n\tprev_earliest_cts = 0;\n\tnext_earliest_cts = 0;\n\n\tif (daisy_chain_sidx)\n\t\tdaisy_sidx = gf_list_new();\n\n\t/*prepare SIDX: we write a blank SIDX box with the right number of entries, and will rewrite it later on*/\n\tif (referenceTrackID) {\n\t\tBool is_root_sidx = GF_FALSE;\n\n\t\tprev_earliest_cts = get_presentation_time( ref_track_decode_time + moof_get_earliest_cts((GF_MovieFragmentBox*)gf_list_get(movie->moof_list, 0), referenceTrackID), ts_shift);\n\n\t\t//we don't trust ref_track_next_cts to be the earliest in the following segment\n\t\tnext_earliest_cts = estimate_next_moof_earliest_presentation_time(ref_track_decode_time, ts_shift, referenceTrackID, movie);\n\n\t\tif (movie->root_sidx) {\n\t\t\tsidx = movie->root_sidx;\n\t\t} else {\n\t\t\tsidx = (GF_SegmentIndexBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_SIDX);\n\t\t\tif (!sidx) return GF_OUT_OF_MEM;\n\t\t\tif (movie->force_sidx_v1)\n\t\t\t\tsidx->version = 1;\n\t\t}\n\t\tsidx->reference_ID = referenceTrackID;\n\t\tsidx->timescale = trak->Media->mediaHeader->timeScale;\n\t\t/*we don't write anything between sidx and following moov*/\n\t\tsidx->first_offset = 0;\n\n\t\t/*we allocated our sidx to have one ref per \"segment\" (eg per call to close_segment)*/\n\t\tif (movie->root_sidx) {\n\t\t\tif (!movie->root_sidx_index) {\n\t\t\t\tsidx->earliest_presentation_time = prev_earliest_cts;\n\t\t\t}\n\t\t\tnb_subsegs = 1;\n\t\t\tfrags_per_subseg = count;\n\t\t\tfrags_per_subsidx = count;\n\t\t\tsubseg_per_sidx = 1;\n\t\t\tdaisy_chain_sidx = GF_FALSE;\n\n\t\t\tidx_offset = movie->root_sidx_index;\n\t\t\tsidx_end = gf_bs_get_position(movie->editFileMap->bs);\n\t\t} else {\n\t\t\tsidx->earliest_presentation_time = prev_earliest_cts;\n\n\t\t\t/*if more subsegments requested than fragments available, make a single sidx*/\n\t\t\tif ((s32) count <= subsegments_per_sidx)\n\t\t\t\tsubsegments_per_sidx = 0;\n\n\t\t\tif (daisy_chain_sidx && (subsegments_per_sidx<2))\n\t\t\t\tsubsegments_per_sidx = 2;\n\n\t\t\t/*single SIDX, each fragment is a subsegment and we reference all subsegments*/\n\t\t\tif (!subsegments_per_sidx) {\n\t\t\t\tnb_subsegs = count;\n\t\t\t\t/*we consider that each fragment is a subsegment - this could be controled by another parameter*/\n\t\t\t\tfrags_per_subseg = 1;\n\t\t\t\tfrags_per_subsidx = count;\n\t\t\t\tsubseg_per_sidx = count;\n\n\t\t\t\tsidx->nb_refs = nb_subsegs;\n\t\t\t\tdaisy_chain_sidx = GF_FALSE;\n\t\t\t}\n\t\t\t/*daisy-chain SIDX: each SIDX describes a subsegment made of frags_per_subseg fragments plus next */\n\t\t\telse if (daisy_chain_sidx) {\n\t\t\t\tfrags_per_subsidx = count/subsegments_per_sidx;\n\t\t\t\tif (frags_per_subsidx * subsegments_per_sidx < count) frags_per_subsidx++;\n\n\t\t\t\tnb_subsegs = subsegments_per_sidx;\n\n\t\t\t\t/*we consider that each fragment is a subsegment - this could be controled by another parameter*/\n\t\t\t\tfrags_per_subseg = 1;\n\t\t\t\tsubseg_per_sidx = frags_per_subsidx / frags_per_subseg;\n\t\t\t\tif (subseg_per_sidx * frags_per_subseg < frags_per_subsidx) subseg_per_sidx++;\n\n\t\t\t\tsidx->nb_refs = subseg_per_sidx + 1;\n\t\t\t}\n\t\t\t/*hierarchical SIDX*/\n\t\t\telse {\n\t\t\t\tfrags_per_subsidx = count/subsegments_per_sidx;\n\t\t\t\tif (frags_per_subsidx * subsegments_per_sidx < count) frags_per_subsidx++;\n\n\t\t\t\tnb_subsegs = subsegments_per_sidx;\n\n\t\t\t\t/*we consider that each fragment is a subsegment - this could be controled by another parameter*/\n\t\t\t\tfrags_per_subseg = 1;\n\t\t\t\tsubseg_per_sidx = frags_per_subsidx / frags_per_subseg;\n\t\t\t\tif (subseg_per_sidx * frags_per_subseg < frags_per_subsidx) subseg_per_sidx++;\n\n\t\t\t\tsidx->nb_refs = nb_subsegs;\n\t\t\t\tis_root_sidx = GF_TRUE;\n\t\t\t}\n\n\t\t\tsidx->refs = (GF_SIDXReference*)gf_malloc(sizeof(GF_SIDXReference)*sidx->nb_refs);\n\t\t\tif (!sidx->refs) return GF_OUT_OF_MEM;\n\t\t\tmemset(sidx->refs, 0, sizeof(GF_SIDXReference)*sidx->nb_refs);\n\n\t\t\t/*remember start of sidx*/\n\t\t\tsidx_start = gf_bs_get_position(movie->editFileMap->bs);\n\n\t\t\te = gf_isom_box_size((GF_Box *) sidx);\n\t\t\tif (e) goto exit;\n\t\t\te = gf_isom_box_write((GF_Box *) sidx, movie->editFileMap->bs);\n\t\t\tif (e) goto exit;\n\n\t\t\tif (use_ssix && !ssix && !movie->root_ssix) {\n\t\t\t\tu32 k;\n\t\t\t\tssix = (GF_SubsegmentIndexBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_SSIX);\n\t\t\t\tif (!ssix) return GF_OUT_OF_MEM;\n\t\t\t\tssix->subsegments = gf_malloc(sizeof(GF_SubsegmentInfo) * sidx->nb_refs);\n\t\t\t\tif (!ssix->subsegments) return GF_OUT_OF_MEM;\n\t\t\t\tssix->subsegment_count = sidx->nb_refs;\n\t\t\t\tssix->subsegment_alloc = ssix->subsegment_count;\n\t\t\t\tfor (k=0; k<sidx->nb_refs; k++) {\n\t\t\t\t\tGF_SubsegmentInfo *subs = &ssix->subsegments[k];\n\t\t\t\t\tsubs->range_count = 2;\n\t\t\t\t\tsubs->ranges = gf_malloc(sizeof(GF_SubsegmentRangeInfo)*2);\n\t\t\t\t\tif (!subs->ranges) return GF_OUT_OF_MEM;\n\t\t\t\t\tsubs->ranges[0].level = 1;\n\t\t\t\t\tsubs->ranges[1].level = 2;\n\t\t\t\t\tsubs->ranges[0].range_size = subs->ranges[1].range_size = 0;\n\t\t\t\t}\n\n\t\t\t\te = gf_isom_box_size((GF_Box *) ssix);\n\t\t\t\tif (e) return e;\n\t\t\t\te = gf_isom_box_write((GF_Box *) ssix, movie->editFileMap->bs);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\n\t\t\tsidx_end = gf_bs_get_position(movie->editFileMap->bs);\n\n\t\t\tif (daisy_sidx) {\n\t\t\t\tSIDXEntry *entry;\n\t\t\t\tGF_SAFEALLOC(entry, SIDXEntry);\n\t\t\t\tif (!entry) {\n\t\t\t\t\te = GF_OUT_OF_MEM;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t\tentry->sidx = sidx;\n\t\t\t\tentry->start_offset = sidx_start;\n\t\t\t\tgf_list_add(daisy_sidx, entry);\n\t\t\t}\n\t\t}\n\n\t\tif (is_root_sidx) {\n\t\t\troot_sidx = sidx;\n\t\t\tsidx = NULL;\n\t\t}\n\t\tcount = cur_idx = 0;\n\t}\n\n\n\tlast_top_box_pos = root_prev_offset = sidx_end;\n\tsidx_idx = 0;\n\tsidx_dur = 0;\n\tlocal_sidx_start = local_sidx_end = 0;\n\n\t/*cumulated segments duration since start of the sidx */\n\tfrag_count = frags_per_subsidx;\n\tcur_dur = 0;\n\tcur_idx = 0;\n\tfirst_frag_in_subseg = GF_TRUE;\n\te = GF_OK;\n\tu64 cumulated_ref_size=0;\n\twhile (gf_list_count(movie->moof_list)) {\n\t\ts32 offset_diff;\n\t\tu32 moof_size;\n\n\t\tmovie->moof = (GF_MovieFragmentBox*)gf_list_get(movie->moof_list, 0);\n\t\tgf_list_rem(movie->moof_list, 0);\n\t\tmovie->in_sidx_write = GF_TRUE;\n\t\tmovie->moof->trun_ref_size=0;\n\n\t\t/*hierarchical or daisy-chain SIDXs*/\n\t\tif (!no_sidx && !sidx && (root_sidx || daisy_chain_sidx) ) {\n\t\t\tu32 subsegments_remaining;\n\t\t\tsidx = (GF_SegmentIndexBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_SIDX);\n\t\t\tif (!sidx) return GF_OUT_OF_MEM;\n\t\t\tsidx->reference_ID = referenceTrackID;\n\t\t\tsidx->timescale = trak ? trak->Media->mediaHeader->timeScale : 1000;\n\t\t\tsidx->earliest_presentation_time = get_presentation_time( ref_track_decode_time + sidx_dur + moof_get_earliest_cts(movie->moof, referenceTrackID), ts_shift);\n\n\t\t\tfrag_count = frags_per_subsidx;\n\n\t\t\t/*last segment, add only one ref*/\n\t\t\tsubsegments_remaining = 1 + gf_list_count(movie->moof_list);\n\t\t\tif (subseg_per_sidx*frags_per_subseg > subsegments_remaining) {\n\t\t\t\tsubseg_per_sidx = subsegments_remaining / frags_per_subseg;\n\t\t\t\tif (subseg_per_sidx * frags_per_subseg < subsegments_remaining) subseg_per_sidx++;\n\t\t\t}\n\t\t\t/*we don't write anything between sidx and following moov*/\n\t\t\tsidx->first_offset = 0;\n\t\t\tsidx->nb_refs = subseg_per_sidx;\n\t\t\tif (daisy_chain_sidx && (nb_subsegs>1)) {\n\t\t\t\tsidx->nb_refs += 1;\n\t\t\t}\n\t\t\tsidx->refs = (GF_SIDXReference*)gf_malloc(sizeof(GF_SIDXReference)*sidx->nb_refs);\n\t\t\tif (!sidx->refs) return GF_OUT_OF_MEM;\n\t\t\tmemset(sidx->refs, 0, sizeof(GF_SIDXReference)*sidx->nb_refs);\n\n\t\t\tif (root_sidx)\n\t\t\t\troot_sidx->refs[sidx_idx].reference_type = GF_TRUE;\n\n\t\t\t/*remember start of sidx*/\n\t\t\tlocal_sidx_start = gf_bs_get_position(movie->editFileMap->bs);\n\n\t\t\t/*write it*/\n\t\t\te = gf_isom_box_size((GF_Box *) sidx);\n\t\t\tif (e) goto exit;\n\t\t\te = gf_isom_box_write((GF_Box *) sidx, movie->editFileMap->bs);\n\t\t\tif (e) goto exit;\n\n\t\t\tlocal_sidx_end = gf_bs_get_position(movie->editFileMap->bs);\n\n\t\t\t/*adjust prev offset*/\n\t\t\tlast_top_box_pos = local_sidx_end;\n\n\t\t\tif (daisy_sidx) {\n\t\t\t\tSIDXEntry *entry;\n\t\t\t\tGF_SAFEALLOC(entry, SIDXEntry);\n\t\t\t\tif (!entry) {\n\t\t\t\t\te = GF_OUT_OF_MEM;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t\tentry->sidx = sidx;\n\t\t\t\tentry->start_offset = local_sidx_start;\n\t\t\t\tgf_list_add(daisy_sidx, entry);\n\t\t\t}\n\t\t}\n\n\t\toffset_diff = (s32) (gf_bs_get_position(movie->editFileMap->bs) - movie->moof->fragment_offset);\n\t\tmovie->moof->fragment_offset = gf_bs_get_position(movie->editFileMap->bs);\n\n\t\tif (!e) {\n\t\t\tBool generate_ssix = GF_FALSE;\n\t\t\tif (movie->root_ssix) generate_ssix = GF_TRUE;\n\t\t\telse if (use_ssix && ssix) generate_ssix = GF_TRUE;\n\n\t\t\te = StoreFragment(movie, GF_FALSE, offset_diff, &moof_size, GF_FALSE);\n\t\t\tif (e) {\n\t\t\t\te = GF_OUT_OF_MEM;\n\t\t\t\tgoto exit;\n\t\t\t}\n\n\t\t\tif (sidx) {\n\t\t\t\tu32 cur_index = idx_offset + cur_idx;\n\n\t\t\t\t/*do not compute earliest CTS if single segment sidx since we only have set the info for one subsegment*/\n\t\t\t\tif (!movie->root_sidx && first_frag_in_subseg) {\n\t\t\t\t\tu64 first_cts = get_presentation_time( ref_track_decode_time + sidx_dur + cur_dur +  moof_get_earliest_cts(movie->moof, referenceTrackID), ts_shift);\n\t\t\t\t\tif (cur_index) {\n\t\t\t\t\t\tu32 subseg_dur = (u32) (first_cts - prev_earliest_cts);\n\t\t\t\t\t\tsidx->refs[cur_index-1].subsegment_duration = subseg_dur;\n\t\t\t\t\t\tif (root_sidx) root_sidx->refs[sidx_idx].subsegment_duration += subseg_dur;\n\t\t\t\t\t}\n\t\t\t\t\tprev_earliest_cts = first_cts;\n\t\t\t\t\tfirst_frag_in_subseg = GF_FALSE;\n\t\t\t\t}\n\n\t\t\t\tif (sidx->nb_refs<=cur_index) {\n\t\t\t\t\tsidx->nb_refs = cur_index+1;\n\t\t\t\t\tsidx->refs = gf_realloc(sidx->refs, sizeof(GF_SIDXReference)*sidx->nb_refs);\n\t\t\t\t\tmemset(&sidx->refs[cur_index], 0, sizeof(GF_SIDXReference));\n\t\t\t\t}\n\n\t\t\t\t/*we refer to next moof*/\n\t\t\t\tsidx->refs[cur_index].reference_type = GF_FALSE;\n\t\t\t\tif (!sidx->refs[cur_index].SAP_type) {\n\t\t\t\t\tsidx->refs[cur_index].SAP_type = moof_get_sap_info(movie->moof, referenceTrackID, & sidx->refs[cur_index].SAP_delta_time, & sidx->refs[cur_index].starts_with_SAP);\n\t\t\t\t\tif (sidx->refs[cur_index].SAP_type) {\n\t\t\t\t\t\tif (root_sidx && !root_sidx->refs[sidx_idx].SAP_type) {\n\t\t\t\t\t\t\troot_sidx->refs[sidx_idx].SAP_type = sidx->refs[cur_index].SAP_type;\n\t\t\t\t\t\t\troot_sidx->refs[sidx_idx].SAP_delta_time = sidx->refs[cur_index].SAP_delta_time;\n\t\t\t\t\t\t\troot_sidx->refs[sidx_idx].starts_with_SAP = sidx->refs[cur_index].starts_with_SAP;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcur_dur += moof_get_duration(movie->moof, referenceTrackID);\n\n\t\t\t\t/*reference size is end of the moof we just wrote minus last_box_pos*/\n\t\t\t\tu64 last_pos = gf_bs_get_position(movie->editFileMap->bs);\n\t\t\t\tif (movie->moof->moof_data_len) {\n\t\t\t\t\tcumulated_ref_size += movie->moof->moof_data_len + movie->moof->trun_ref_size;\n\t\t\t\t\tlast_pos += cumulated_ref_size;\n\t\t\t\t}\n\t\t\t\tsidx->refs[cur_index].reference_size += (u32) ( last_pos - last_top_box_pos) ;\n\t\t\t\tlast_top_box_pos = last_pos;\n\n\t\t\t\tcount++;\n\n\t\t\t\tif (generate_ssix) {\n\t\t\t\t\tu32 last_sseg_range0_size, remain_size;\n\t\t\t\t\tif (movie->root_ssix) {\n\t\t\t\t\t\tssix = movie->root_ssix;\n\t\t\t\t\t\tif (ssix->subsegment_count <= cur_index) {\n\t\t\t\t\t\t\tassert(ssix->subsegment_count == cur_index);\n\t\t\t\t\t\t\tssix->subsegment_count = cur_index+1;\n\t\t\t\t\t\t\tssix->subsegment_alloc = ssix->subsegment_count;\n\t\t\t\t\t\t\tssix->subsegments = gf_realloc(ssix->subsegments, ssix->subsegment_count * sizeof(GF_SubsegmentInfo));\n\t\t\t\t\t\t\tssix->subsegments[cur_index].range_count = 2;\n\t\t\t\t\t\t\tssix->subsegments[cur_index].ranges = gf_malloc(sizeof(GF_SubsegmentRangeInfo)*2);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tassert(ssix);\n\t\t\t\t\tssix->subsegments[cur_index].ranges[0].level = 1;\n\t\t\t\t\tssix->subsegments[cur_index].ranges[0].range_size = moof_get_first_sap_end(movie->moof);\n\n\t\t\t\t\tlast_sseg_range0_size = (cur_index < ssix->subsegment_count) ? ssix->subsegments[cur_index].ranges[0].range_size : 0;\n\t\t\t\t\tssix->subsegments[cur_index].ranges[1].level = 2;\n\n\t\t\t\t\tremain_size = sidx->refs[cur_index].reference_size - last_sseg_range0_size;\n\t\t\t\t\tssix->subsegments[cur_index].ranges[1].range_size = remain_size;\n\t\t\t\t\tif (remain_size>0xFFFFFF) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso fragment] Remaining subsegment size %d larger than max ssix range size 0xFFFFFF, file might be broken\\n\", remain_size));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (movie->root_ssix)\n\t\t\t\t\t\tssix = NULL;\n\t\t\t\t}\n\n\t\t\t\t/*we are switching subsegment*/\n\t\t\t\tfrag_count--;\n\n\t\t\t\tif (count==frags_per_subseg) {\n\t\t\t\t\tcount = 0;\n\t\t\t\t\tfirst_frag_in_subseg = GF_TRUE;\n\t\t\t\t\tcur_idx++;\n\t\t\t\t}\n\n\t\t\t\t/*switching to next SIDX*/\n\t\t\t\tif ((cur_idx==subseg_per_sidx) || !frag_count) {\n\t\t\t\t\tu32 subseg_dur;\n\t\t\t\t\t/*update last ref duration*/\n\n\t\t\t\t\t//get next segment earliest cts - if estimation failed, use ref_track_next_cts\n\t\t\t\t\tif ((next_earliest_cts==-1) || (next_earliest_cts < prev_earliest_cts))  {\n\t\t\t\t\t\tu64 next_cts;\n\t\t\t\t\t\tif (gf_list_count(movie->moof_list)) {\n\t\t\t\t\t\t\tnext_cts = get_presentation_time( ref_track_decode_time + sidx_dur + cur_dur + moof_get_earliest_cts((GF_MovieFragmentBox*)gf_list_get(movie->moof_list, 0), referenceTrackID), ts_shift);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnext_cts = get_presentation_time( ref_track_next_cts, ts_shift);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsubseg_dur = (u32) (next_cts - prev_earliest_cts);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsubseg_dur = (u32) (next_earliest_cts - prev_earliest_cts);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (movie->root_sidx) {\n\t\t\t\t\t\tsidx->refs[idx_offset].subsegment_duration = subseg_dur;\n\t\t\t\t\t}\n\t\t\t\t\t/*if daisy chain and not the last sidx, we have an extra entry at the end*/\n\t\t\t\t\telse if (daisy_chain_sidx && (nb_subsegs>1)) {\n\t\t\t\t\t\tsidx->refs[sidx->nb_refs - 2].subsegment_duration = subseg_dur;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsidx->refs[sidx->nb_refs-1].subsegment_duration = subseg_dur;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (root_sidx) {\n\n\t\t\t\t\t\troot_sidx->refs[sidx_idx].subsegment_duration += subseg_dur;\n\n\t\t\t\t\t\troot_sidx->refs[sidx_idx].reference_size = (u32) (last_pos - local_sidx_start);\n\t\t\t\t\t\tif (!sidx_idx) {\n\t\t\t\t\t\t\troot_sidx->earliest_presentation_time = sidx->earliest_presentation_time;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsidx_rewrite(sidx, movie->editFileMap->bs, local_sidx_start, ssix);\n\t\t\t\t\t\tgf_isom_box_del((GF_Box*)sidx);\n\t\t\t\t\t\tsidx = NULL;\n\t\t\t\t\t} else if (daisy_chain_sidx) {\n\t\t\t\t\t\tSIDXEntry *entry = (SIDXEntry*)gf_list_last(daisy_sidx);\n\t\t\t\t\t\tentry->end_offset = last_pos;\n\t\t\t\t\t\tnb_subsegs--;\n\t\t\t\t\t\tsidx = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tsidx_dur += cur_dur;\n\t\t\t\t\tcur_dur = 0;\n\t\t\t\t\tcount = 0;\n\t\t\t\t\tcur_idx=0;\n\t\t\t\t\tif (movie->root_sidx)\n\t\t\t\t\t\tmovie->root_sidx_index++;\n\t\t\t\t\tsidx_idx++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (movie->moof->moof_data_len) {\n\t\t\tif (!defer_moofs) defer_moofs = gf_list_new();\n\t\t\tgf_list_add(defer_moofs, movie->moof);\n\t\t} else {\n\t\t\tgf_isom_box_del((GF_Box *) movie->moof);\n\t\t}\n\t\tmovie->moof = NULL;\n\t}\n\tmovie->in_sidx_write = GF_FALSE;\n\n\t/*append segment marker box*/\n\tif (!defer_moofs && segment_marker_4cc) {\n\t\tgf_bs_write_u32(movie->editFileMap->bs, 8);\t//write size field\n\t\tgf_bs_write_u32(movie->editFileMap->bs, segment_marker_4cc); //write box type field\n\t}\n\n\tif (movie->root_sidx) {\n\t\tif (last_segment && !movie->dyn_root_sidx) {\n\t\t\tassert(movie->root_sidx_index == movie->root_sidx->nb_refs);\n\n\t\t\tsidx_rewrite(movie->root_sidx, movie->editFileMap->bs, movie->root_sidx_offset, movie->root_ssix);\n\t\t\tgf_isom_box_del((GF_Box*) movie->root_sidx);\n\t\t\tmovie->root_sidx = NULL;\n\n\t\t\tif (movie->root_ssix) {\n\t\t\t\tgf_isom_box_del((GF_Box*)movie->root_ssix);\n\t\t\t\tmovie->root_ssix = NULL;\n\t\t\t}\n\t\t}\n\t\tif (ssix)\n\t\t\tgf_isom_box_del((GF_Box*)ssix);\n\n\t\tcompute_seg_size(movie, out_seg_size);\n\t\tgoto exit;\n\t}\n\n\tif (sidx) {\n\t\tassert(!root_sidx);\n\t\tsidx_rewrite(sidx, movie->editFileMap->bs, sidx_start, ssix);\n\t\tgf_isom_box_del((GF_Box*)sidx);\n\t}\n\tif (ssix) {\n\t\tgf_isom_box_del((GF_Box*)ssix);\n\t\tssix = NULL;\n\t}\n\n\tif (daisy_sidx) {\n\t\tu32 i, j;\n\t\tu64 last_entry_end_offset = 0;\n\n\t\tcount = gf_list_count(daisy_sidx);\n\t\tfor (i=count; i>1; i--) {\n\t\t\tSIDXEntry *entry = (SIDXEntry*)gf_list_get(daisy_sidx, i-2);\n\t\t\tSIDXEntry *next_entry = (SIDXEntry*)gf_list_get(daisy_sidx, i-1);\n\n\t\t\tif (!last_entry_end_offset) {\n\t\t\t\tlast_entry_end_offset = next_entry->end_offset;\n\t\t\t\t/*rewrite last sidx*/\n\t\t\t\tsidx_rewrite(next_entry->sidx, movie->editFileMap->bs, next_entry->start_offset, NULL);\n\t\t\t}\n\t\t\t/*copy over SAP info for last item (which points to next item !)*/\n\t\t\tentry->sidx->refs[entry->sidx->nb_refs-1] = next_entry->sidx->refs[0];\n\t\t\t/*and rewrite reference type, size and dur*/\n\t\t\tentry->sidx->refs[entry->sidx->nb_refs-1].reference_type = GF_TRUE;\n\t\t\tentry->sidx->refs[entry->sidx->nb_refs-1].reference_size = (u32) (last_entry_end_offset - next_entry->start_offset);\n\t\t\tentry->sidx->refs[entry->sidx->nb_refs-1].subsegment_duration = 0;\n\t\t\tfor (j=0; j<next_entry->sidx->nb_refs; j++) {\n\t\t\t\tentry->sidx->refs[entry->sidx->nb_refs-1].subsegment_duration += next_entry->sidx->refs[j].subsegment_duration;\n\t\t\t}\n\t\t\tsidx_rewrite(entry->sidx, movie->editFileMap->bs, entry->start_offset, NULL);\n\t\t}\n\t\twhile (gf_list_count(daisy_sidx)) {\n\t\t\tSIDXEntry *entry = (SIDXEntry*)gf_list_last(daisy_sidx);\n\t\t\tgf_isom_box_del((GF_Box*)entry->sidx);\n\t\t\tgf_free(entry);\n\t\t\tgf_list_rem_last(daisy_sidx);\n\t\t}\n\t\tgf_list_del(daisy_sidx);\n\t}\n\tif (root_sidx) {\n\t\tsidx_rewrite(root_sidx, movie->editFileMap->bs, sidx_start, NULL);\n\t\tgf_isom_box_del((GF_Box*)root_sidx);\n\t}\n\n\tif ((root_sidx || sidx) && !daisy_chain_sidx) {\n\t\tif (index_start_range) *index_start_range = sidx_start;\n\t\tif (index_end_range) *index_end_range = sidx_end - 1;\n\t}\n\n\tif (movie->append_segment) {\n\t\tchar bloc[1024];\n\t\tu32 seg_size = (u32) gf_bs_get_size(movie->editFileMap->bs);\n\t\tgf_bs_seek(movie->editFileMap->bs, 0);\n\t\twhile (seg_size) {\n\t\t\tu32 size = gf_bs_read_data(movie->editFileMap->bs, bloc, (seg_size>1024) ? 1024 : seg_size);\n\t\t\tgf_bs_write_data(movie->movieFileMap->bs, bloc, size);\n\t\t\tseg_size -= size;\n\t\t}\n\t\tgf_isom_datamap_del(movie->editFileMap);\n\t\tmovie->editFileMap = gf_isom_fdm_new_temp(NULL);\n\t} else if (close_segment_handle == GF_TRUE) {\n\t\tgf_isom_datamap_del(movie->editFileMap);\n\t\tmovie->editFileMap = NULL;\n\t}\n\tcompute_seg_size(movie, out_seg_size);\n\nexit:\n\tif (movie->editFileMap && (orig_bs != movie->editFileMap->bs)) {\n\t\tu32 tmpsize;\n\t\tgf_bs_get_content_no_truncate(movie->editFileMap->bs, &movie->block_buffer, &tmpsize, &movie->block_buffer_size);\n\t\tgf_bs_del(movie->editFileMap->bs);\n\t\tmovie->editFileMap->bs = orig_bs;\n\t}\n\t//flush all defered\n\tif (defer_moofs) {\n\t\twhile (gf_list_count(defer_moofs)) {\n\t\t\tmovie->moof = gf_list_pop_front(defer_moofs);\n\t\t\tmovie->on_block_out(movie->on_block_out_usr_data, movie->moof->moof_data, movie->moof->moof_data_len, NULL, 0);\n\t\t\tif (out_seg_size) *out_seg_size += movie->moof->moof_data_len;\n\n\t\t\tflush_ref_samples(movie, out_seg_size, segment_marker_4cc ? GF_TRUE : GF_FALSE);\n\n\t\t\tgf_free(movie->moof->moof_data);\n\t\t\tgf_isom_box_del((GF_Box *) movie->moof);\n\t\t\tmovie->moof = NULL;\n\t\t}\n\t\tgf_list_del(defer_moofs);\n\n\t\tif (segment_marker_4cc) {\n\t\t\tchar seg[8];\n\t\t\tif (movie->on_last_block_start)\n\t\t\t\tmovie->on_last_block_start(movie->on_block_out_usr_data);\n\n\t\t\tseg[0] = seg[1] = seg[2] = 0;\n\t\t\tseg[3] = 9;\n\t\t\tseg[4] = (segment_marker_4cc>>24) & 0xFF;\n\t\t\tseg[5] = (segment_marker_4cc>>16) & 0xFF;\n\t\t\tseg[6] = (segment_marker_4cc>>8) & 0xFF;\n\t\t\tseg[7] = (segment_marker_4cc) & 0xFF;\n\t\t\tmovie->on_block_out(movie->on_block_out_usr_data, seg, 8, NULL, 0);\n\t\t\tif (out_seg_size)\n\t\t\t\t*out_seg_size += 8;\n\t\t}\n\t\tgf_bs_seek(movie->editFileMap->bs, 0);\n\t}\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_isom_flush_sidx(GF_ISOFile *movie, u32 sidx_max_size, Bool force_v1)\n{\n\tGF_BitStream *bs;\n\tGF_Err e;\n\tu32 size;\n\t//and only at setup\n\tif (!movie || !(movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY) ) return GF_BAD_PARAM;\n\tif (movie->openMode != GF_ISOM_OPEN_WRITE) return GF_ISOM_INVALID_MODE;\n\n\tif (! movie->on_block_out) return GF_BAD_PARAM;\n\tif (! movie->root_sidx) return GF_BAD_PARAM;\n\n\tif (!movie->block_buffer_size) movie->block_buffer_size = movie->on_block_out_block_size;\n\tbs = gf_bs_new_cbk_buffer(isom_on_block_out, movie, movie->block_buffer, movie->block_buffer_size);\n\tgf_bs_prevent_dispatch(bs, GF_TRUE);\n\t\n\tassert(movie->root_sidx_index == movie->root_sidx->nb_refs);\n\n\tif (force_v1)\n\t\tmovie->root_sidx->version = 1;\n\t\t\n\te = gf_isom_box_size((GF_Box*)movie->root_sidx);\n\tsize = (u32) movie->root_sidx->size;\n\tif (movie->root_ssix) {\n\t\te = gf_isom_box_size((GF_Box*)movie->root_ssix);\n\t\tsize += (u32) movie->root_ssix->size;\n\t\tmovie->root_sidx->first_offset = (u32) movie->root_ssix->size;\n\t}\n\n\tif (sidx_max_size && (size > sidx_max_size) ) {\n#ifndef GPAC_DISABLE_LOG\n\t\tu32 orig_seg_count = movie->root_sidx->nb_refs;\n#endif\n\t\t//trash 8 bytes to be able to write a free box before\n\t\tsidx_max_size -= 8;\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso fragment] SIDX size %d is larger than allocated SIDX block %d, merging final segments\\n\", movie->root_sidx->size, sidx_max_size));\n\t\twhile (movie->root_sidx->nb_refs>2) {\n\t\t\tmovie->root_sidx->refs[movie->root_sidx->nb_refs-2].subsegment_duration += movie->root_sidx->refs[movie->root_sidx->nb_refs-1].subsegment_duration;\n\t\t\tmovie->root_sidx->refs[movie->root_sidx->nb_refs-2].reference_size += movie->root_sidx->refs[movie->root_sidx->nb_refs-1].reference_size;\n\t\t\tmovie->root_sidx->nb_refs--;\n\t\t\tif (movie->root_ssix) {\n\t\t\t\tmovie->root_ssix->subsegments[movie->root_ssix->subsegment_count-2].ranges[1].range_size += movie->root_ssix->subsegments[movie->root_ssix->subsegment_count-1].ranges[0].range_size;\n\t\t\t\tmovie->root_ssix->subsegments[movie->root_ssix->subsegment_count-2].ranges[1].range_size += movie->root_ssix->subsegments[movie->root_ssix->subsegment_count-1].ranges[1].range_size;\n\t\t\t\tmovie->root_ssix->subsegment_count--;\n\t\t\t}\n\n\t\t\te = gf_isom_box_size((GF_Box*)movie->root_sidx);\n\t\t\tsize = (u32) movie->root_sidx->size;\n\t\t\tif (movie->root_ssix) {\n\t\t\t\te = gf_isom_box_size((GF_Box*)movie->root_ssix);\n\t\t\t\tsize += (u32) movie->root_ssix->size;\n\t\t\t\tmovie->root_sidx->first_offset = (u32) movie->root_ssix->size;\n\t\t\t}\n\n\t\t\tif (size < sidx_max_size) break;\n\t\t}\n\t\tif (size > sidx_max_size) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso fragment] SIDX size %d is larger than allocated SIDX block and no more segments to merge\\n\", size, sidx_max_size));\n\t\t\treturn GF_IO_ERR;\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso fragment] Merged %d segments in SIDX to fit allocated block, remaining segments %d\\n\", orig_seg_count - movie->root_sidx->nb_refs, movie->root_sidx->nb_refs));\n\t\t}\n\t}\n\tif (!e) {\n\t\tif (movie->root_ssix) {\n\t\t\tgf_isom_box_size((GF_Box *) movie->root_ssix);\n\n\t\t\tif (movie->compress_mode>=GF_ISOM_COMP_MOOF_SSIX) {\n\t\t\t\tu32 ssix_comp_size;\n\t\t\t\t//compute ssix compressed size by using NULL destination bitstream\n\t\t\t\t//not really optimum since we compress twice the ssix, to optimize ...\n\t\t\t\te = gf_isom_write_compressed_box(movie, (GF_Box *) movie->root_ssix, GF_4CC('!', 's', 's', 'x'), NULL, &ssix_comp_size);\n\t\t\t\tmovie->root_sidx->first_offset = ssix_comp_size;\n\t\t\t} else {\n\t\t\t\tmovie->root_sidx->first_offset = (u32) movie->root_ssix->size;\n\t\t\t}\n\t\t}\n\t\tif (!e) {\n\t\t\tif (movie->compress_mode>=GF_ISOM_COMP_MOOF_SIDX) {\n\t\t\t\te = gf_isom_write_compressed_box(movie, (GF_Box *) movie->root_sidx, GF_4CC('!', 's', 'i', 'x'), bs, NULL);\n\t\t\t} else {\n\t\t\t\te = gf_isom_box_write((GF_Box *) movie->root_sidx, bs);\n\t\t\t}\n\t\t}\n\n\t\tif (!e && movie->root_ssix) {\n\t\t\tif (movie->compress_mode>=GF_ISOM_COMP_MOOF_SSIX) {\n\t\t\t\te = gf_isom_write_compressed_box(movie, (GF_Box *) movie->root_ssix, GF_4CC('!', 's', 's', 'x'), bs, NULL);\n\t\t\t} else {\n\t\t\t\te = gf_isom_box_write((GF_Box *) movie->root_ssix, bs);\n\t\t\t}\n\t\t}\n\t}\n\n\tgf_isom_box_del((GF_Box*) movie->root_sidx);\n\tmovie->root_sidx = NULL;\n\tif (movie->root_ssix) {\n\t\tgf_isom_box_del((GF_Box*) movie->root_ssix);\n\t\tmovie->root_ssix = NULL;\n\t}\n\n\tgf_bs_get_content_no_truncate(bs, &movie->block_buffer, &size, &movie->block_buffer_size);\n\tgf_bs_del(bs);\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_isom_close_fragments(GF_ISOFile *movie)\n{\n\tif (movie->use_segments) {\n\t\treturn gf_isom_close_segment(movie, 0, 0, 0, 0, 0, 0, GF_FALSE, GF_FALSE, 1, 0, NULL, NULL, NULL);\n\t} else {\n\t\treturn StoreFragment(movie, GF_FALSE, 0, NULL, GF_TRUE);\n\t}\n}\n\nGF_EXPORT\nGF_Err gf_isom_start_segment(GF_ISOFile *movie, const char *SegName, Bool memory_mode)\n{\n\tGF_Err e;\n\t//and only at setup\n\tif (!movie || !(movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY) ) return GF_BAD_PARAM;\n\tif (movie->openMode != GF_ISOM_OPEN_WRITE) return GF_ISOM_INVALID_MODE;\n\n\tif (gf_list_count(movie->moof_list))\n\t\treturn GF_BAD_PARAM;\n\n\tmovie->segment_bs = NULL;\n\tmovie->append_segment = GF_FALSE;\n\t/*update segment file*/\n\tif (SegName || !gf_isom_get_filename(movie)) {\n\t\tif (movie->editFileMap) gf_isom_datamap_del(movie->editFileMap);\n\t\te = gf_isom_datamap_new(SegName, NULL, GF_ISOM_DATA_MAP_WRITE, &movie->editFileMap);\n\t\tmovie->segment_start = 0;\n\t\tmovie->write_styp = 1;\n\t\tif (e) return e;\n\t} else {\n\t\tassert(gf_list_count(movie->moof_list) == 0);\n\t\tmovie->segment_start = gf_bs_get_position(movie->editFileMap->bs);\n\t\t/*if movieFileMap is not null, we are concatenating segments to the original movie, force a copy*/\n\t\tif (movie->movieFileMap)\n\t\t\tmovie->append_segment = GF_TRUE;\n\t\tmovie->write_styp = 0;\n\t}\n\n\t/*create a memory bitstream for all file IO until final flush*/\n\tif (memory_mode) {\n\t\tmovie->segment_bs = movie->editFileMap->bs;\n\t\tmovie->editFileMap->bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_fragment_reference_time(GF_ISOFile *movie, GF_ISOTrackID reference_track_ID, u64 ntp, u64 timestamp)\n{\n\tif (!movie || !movie->moof) return GF_BAD_PARAM;\n\tmovie->moof->reference_track_ID = reference_track_ID;\n\tmovie->moof->ntp = ntp;\n\tmovie->moof->timestamp = timestamp;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_traf_mss_timeext(GF_ISOFile *movie, GF_ISOTrackID reference_track_ID, u64 ntp_in_track_timescale, u64 traf_duration_in_track_timescale)\n{\n\tu32 i;\n\tif (!movie || !movie->moof)\n\t\treturn GF_BAD_PARAM;\n\tfor (i=0; i<gf_list_count(movie->moof->TrackList); i++) {\n\t\tGF_TrackFragmentBox *traf = (GF_TrackFragmentBox*)gf_list_get(movie->moof->TrackList, i);\n\t\tif (!traf)\n\t\t\treturn GF_BAD_PARAM;\n\t\tif (traf->tfxd)\n\t\t\tgf_isom_box_del_parent(&traf->child_boxes, (GF_Box*)traf->tfxd);\n\t\ttraf->tfxd = (GF_MSSTimeExtBox *)gf_isom_box_new_parent(&traf->child_boxes, GF_ISOM_BOX_UUID_TFXD);\n\t\tif (!traf->tfxd) return GF_OUT_OF_MEM;\n\t\ttraf->tfxd->absolute_time_in_track_timescale = ntp_in_track_timescale;\n\t\ttraf->tfxd->fragment_duration_in_track_timescale = traf_duration_in_track_timescale;\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_start_fragment(GF_ISOFile *movie, GF_ISOStartFragmentFlags flags)\n{\n\tu32 i, count;\n\tGF_TrackExtendsBox *trex;\n\tGF_TrackFragmentBox *traf;\n\tGF_Err e;\n\tBool moof_first = (flags & GF_ISOM_FRAG_MOOF_FIRST) ? GF_TRUE : GF_FALSE;\n#ifdef GF_ENABLE_CTRN\n\tBool use_ctrn = (flags & GF_ISOM_FRAG_USE_COMPACT) ? GF_TRUE : GF_FALSE;\n#endif\n\n\t//and only at setup\n\tif (!movie || !(movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY) )\n\t\treturn GF_BAD_PARAM;\n\tif (movie->openMode != GF_ISOM_OPEN_WRITE) return GF_ISOM_INVALID_MODE;\n\n\tcount = gf_list_count(movie->moov->mvex->TrackExList);\n\tif (!count)\n\t\treturn GF_BAD_PARAM;\n\n\t/*always force cached mode when writing movie segments*/\n\tif (movie->use_segments) moof_first = GF_TRUE;\n\tmovie->moof_first = moof_first;\n\n\t//store existing fragment\n\tif (movie->moof) {\n\t\te = StoreFragment(movie, movie->use_segments ? GF_TRUE : GF_FALSE, 0, NULL, movie->use_segments ? GF_TRUE : (movie->on_block_out ? GF_TRUE : GF_FALSE));\n\t\tif (e) return e;\n\t}\n\n\t//create new fragment\n\tmovie->moof = (GF_MovieFragmentBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_MOOF);\n\tif (!movie->moof) return GF_OUT_OF_MEM;\n\tmovie->moof->mfhd = (GF_MovieFragmentHeaderBox *) gf_isom_box_new_parent(&movie->moof->child_boxes, GF_ISOM_BOX_TYPE_MFHD);\n\tif (!movie->moof->mfhd) return GF_OUT_OF_MEM;\n\tmovie->moof->mfhd->sequence_number = movie->NextMoofNumber;\n\tmovie->NextMoofNumber ++;\n\tif (movie->use_segments || movie->on_block_out)\n\t\tgf_list_add(movie->moof_list, movie->moof);\n\n\n\t/*remember segment offset*/\n\tmovie->moof->fragment_offset = gf_bs_get_position(movie->editFileMap->bs);\n\n\t/*prepare MDAT*/\n\tgf_bs_write_u32(movie->editFileMap->bs, 0);\n\tgf_bs_write_u32(movie->editFileMap->bs, GF_ISOM_BOX_TYPE_MDAT);\n\n\t//we create a TRAF for each setup track, unused ones will be removed at store time\n\tfor (i=0; i<count; i++) {\n\t\ttrex = (GF_TrackExtendsBox*)gf_list_get(movie->moov->mvex->TrackExList, i);\n\t\ttraf = (GF_TrackFragmentBox *) gf_isom_box_new_parent(&movie->moof->child_boxes, GF_ISOM_BOX_TYPE_TRAF);\n\t\tif (!traf) return GF_OUT_OF_MEM;\n\t\ttraf->trex = trex;\n\t\ttraf->tfhd = (GF_TrackFragmentHeaderBox *) gf_isom_box_new_parent(&traf->child_boxes, GF_ISOM_BOX_TYPE_TFHD);\n\t\tif (!traf->tfhd) return GF_OUT_OF_MEM;\n\t\ttraf->tfhd->trackID = trex->trackID;\n\t\t//add 8 bytes (MDAT size+type) to avoid the data_offset in the first trun\n\t\ttraf->tfhd->base_data_offset = movie->moof->fragment_offset + 8;\n#ifdef GF_ENABLE_CTRN\n\t\ttraf->use_ctrn = use_ctrn;\n\t\tif (trex->inherit_from_traf_id)\n\t\t\ttraf->use_inherit = GF_TRUE;\n#endif\n\t\tgf_list_add(movie->moof->TrackList, traf);\n\n\t\tif (movie->mfra) {\n\t\t\tGF_TrackFragmentRandomAccessBox *tfra;\n\t\t\tGF_RandomAccessEntry *raf;\n\t\t\tif (!traf->trex->tfra) {\n\t\t\t\ttfra = (GF_TrackFragmentRandomAccessBox *)gf_isom_box_new_parent(&movie->mfra->child_boxes, GF_ISOM_BOX_TYPE_TFRA);\n\t\t\t\tif (!tfra) return GF_OUT_OF_MEM;\n\t\t\t\ttfra->track_id = traf->trex->trackID;\n\t\t\t\ttfra->traf_bits = 8;\n\t\t\t\ttfra->trun_bits = 8;\n\t\t\t\ttfra->sample_bits = 8;\n\t\t\t\tgf_list_add(movie->mfra->tfra_list, tfra);\n\t\t\t\ttraf->trex->tfra = tfra;\n\t\t\t}\n\t\t\ttfra = traf->trex->tfra;\n\t\t\ttfra->entries = (GF_RandomAccessEntry *)gf_realloc(tfra->entries, (tfra->nb_entries+1)*sizeof(GF_RandomAccessEntry));\n\t\t\ttfra->nb_entries++;\n\t\t\traf = &tfra->entries[tfra->nb_entries-1];\n\t\t\traf->sample_number = 1;\n\t\t\traf->time = 0;\n\t\t\traf->traf_number = i+1;\n\t\t\t//trun number is set once we fond a sync\n\t\t\traf->trun_number = 0;\n\t\t\tif (!strcmp(movie->fileName, \"_gpac_isobmff_redirect\")) {\n\t\t\t\traf->moof_offset = movie->fragmented_file_pos;\n\t\t\t} else {\n\t\t\t\traf->moof_offset = movie->moof->fragment_offset;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err gf_isom_set_fragment_template(GF_ISOFile *movie, u8 *tpl_data, u32 tpl_size, Bool *has_tfdt, GF_SegmentIndexBox **out_sidx)\n{\n\tGF_BitStream *bs;\n\tGF_Err e=GF_OK;\n\tif (out_sidx) *out_sidx = NULL;\n\tif (!movie->moof) return GF_BAD_PARAM;\n\n\tbs = gf_bs_new(tpl_data, tpl_size, GF_BITSTREAM_READ);\n\twhile (gf_bs_available(bs)) {\n\t\tGF_Box *a;\n\t\te = gf_isom_box_parse(&a, bs);\n\t\tif (e) break;\n\t\tif (a->type==GF_ISOM_BOX_TYPE_STYP) {\n\t\t\tif (movie->brand) {\n\t\t\t\tgf_list_del_item(movie->TopBoxes, movie->brand);\n\t\t\t\tgf_isom_box_del((GF_Box *)movie->brand);\n\t\t\t}\n\t\t\tmovie->brand = (GF_FileTypeBox *) a;\n\t\t\tgf_list_add(movie->TopBoxes, movie->brand);\n\t\t\tmovie->write_styp = 2;\n\t\t\tcontinue;\n\t\t}\n\t\tif (a->type==GF_ISOM_BOX_TYPE_OTYP) {\n\t\t\tif (movie->otyp) {\n\t\t\t\tgf_list_del_item(movie->TopBoxes, movie->otyp);\n\t\t\t\tgf_isom_box_del(movie->otyp);\n\t\t\t}\n\t\t\tmovie->otyp = (GF_Box *) a;\n\t\t\tgf_list_add(movie->TopBoxes, movie->otyp);\n\t\t\tcontinue;\n\t\t}\n\t\tif (a->type==GF_ISOM_BOX_TYPE_MOOF) {\n\t\t\tu32 i, count, j, nb_trex;\n\t\t\ts32 idx;\n\t\t\tBool single_track=GF_FALSE;\n\t\t\tGF_MovieFragmentBox *moof = (GF_MovieFragmentBox *)a;\n\n\t\t\tmoof->fragment_offset = movie->moof->fragment_offset;\n\t\t\tnb_trex = gf_list_count(movie->moov->mvex->TrackExList);\n\t\t\tcount = gf_list_count(moof->TrackList);\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tGF_TrackFragmentBox *traf = gf_list_get(moof->TrackList, i);\n\t\t\t\tGF_TrackBox *trak = traf->tfhd ? gf_isom_get_track_from_id(movie->moov, traf->tfhd->trackID) : NULL;\n\t\t\t\tif (traf->tfhd && !trak && !single_track && (gf_list_count(movie->moov->trackList)==1)) {\n\t\t\t\t\ttrak = gf_list_get(movie->moov->trackList, 0);\n\t\t\t\t\tsingle_track = GF_TRUE;\n\t\t\t\t\ttraf->tfhd->trackID = trak->Header->trackID;\n\t\t\t\t}\n\t\t\t\tfor (j=0; j<nb_trex && trak; j++) {\n\t\t\t\t\tGF_TrackExtendsBox *trex = gf_list_get(movie->moov->mvex->TrackExList, j);\n\t\t\t\t\tif (trex->trackID == traf->tfhd->trackID) {\n\t\t\t\t\t\ttraf->trex = trex;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!trak || !traf->trex) {\n\t\t\t\t\tgf_list_rem(moof->TrackList, i);\n\t\t\t\t\ti--;\n\t\t\t\t\tcount--;\n\t\t\t\t\tgf_isom_box_del((GF_Box*)traf);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\ttraf->tfhd->base_data_offset = movie->moof->fragment_offset + 8;\n\t\t\t\tif (traf->tfdt && has_tfdt)\n\t\t\t\t\t*has_tfdt = GF_TRUE;\n\t\t\t}\n\t\t\t//remove old moof and switch with this one\n\t\t\tidx = gf_list_find(movie->moof_list, movie->moof);\n\t\t\tif (idx>=0) {\n\t\t\t\tgf_list_rem(movie->moof_list, idx);\n\t\t\t\tgf_list_add(movie->moof_list, moof);\n\t\t\t}\n\t\t\tgf_isom_box_del((GF_Box *)movie->moof);\n\t\t\tmovie->moof = moof;\n\t\t\tcontinue;\n\t\t}\n\t\tif (a->type==GF_ISOM_BOX_TYPE_SIDX) {\n\t\t\tif (out_sidx && !*out_sidx) {\n\t\t\t\t*out_sidx = (GF_SegmentIndexBox *) a;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tgf_isom_box_del(a);\n\t}\n\tgf_bs_del(bs);\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_isom_fragment_add_sample_ex(GF_ISOFile *movie, GF_ISOTrackID TrackID, const GF_ISOSample *sample, u32 DescIndex,\n                                   u32 Duration, u8 PaddingBits, u16 DegradationPriority, Bool redundant_coding, void **ref, u32 ref_offset)\n{\n\tu32 count, buffer_size;\n\tu8 *buffer;\n\tu64 pos;\n\tGF_ISOSample *od_sample = NULL;\n\tGF_TrunEntry ent, *prev_ent;\n\tGF_TrackFragmentBox *traf, *traf_2;\n\tGF_TrackFragmentRunBox *trun;\n\n\tif (!movie->moof || !(movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY) || !sample)\n\t\treturn GF_BAD_PARAM;\n\n\ttraf = gf_isom_get_traf(movie, TrackID);\n\tif (!traf)\n\t\treturn GF_BAD_PARAM;\n\n\tif (!traf->tfhd->sample_desc_index)\n\t\ttraf->tfhd->sample_desc_index = DescIndex ? DescIndex : traf->trex->def_sample_desc_index;\n\n\tpos = gf_bs_get_position(movie->editFileMap->bs);\n\n\n\t//WARNING: we change stream description, create a new TRAF\n\tif ( DescIndex && (traf->tfhd->sample_desc_index != DescIndex)) {\n\t\t//if we're caching flush the current run\n\t\tif (traf->DataCache && !traf->use_sample_interleave) {\n\t\t\tcount = gf_list_count(traf->TrackRuns);\n\t\t\tif (count) {\n\t\t\t\ttrun = (GF_TrackFragmentRunBox *)gf_list_get(traf->TrackRuns, count-1);\n\t\t\t\ttrun->data_offset = (u32) (pos - movie->moof->fragment_offset - 8);\n\t\t\t\tgf_bs_get_content(trun->cache, &buffer, &buffer_size);\n\t\t\t\tgf_bs_write_data(movie->editFileMap->bs, buffer, buffer_size);\n\t\t\t\tgf_bs_del(trun->cache);\n\t\t\t\ttrun->cache = NULL;\n\t\t\t\tgf_free(buffer);\n\t\t\t}\n\t\t}\n\t\ttraf_2 = (GF_TrackFragmentBox *) gf_isom_box_new_parent(&movie->moof->child_boxes, GF_ISOM_BOX_TYPE_TRAF);\n\t\tif (!traf_2) return GF_OUT_OF_MEM;\n\t\ttraf_2->trex = traf->trex;\n\t\ttraf_2->tfhd = (GF_TrackFragmentHeaderBox *) gf_isom_box_new_parent(&traf_2->child_boxes, GF_ISOM_BOX_TYPE_TFHD);\n\t\tif (!traf_2->tfhd) return GF_OUT_OF_MEM;\n\t\ttraf_2->tfhd->trackID = traf->tfhd->trackID;\n\t\t//keep the same offset\n\t\ttraf_2->tfhd->base_data_offset = movie->moof->fragment_offset + 8;\n\t\tgf_list_add(movie->moof->TrackList, traf_2);\n\n\t\t//duplicate infos\n\t\ttraf_2->IFrameSwitching = traf->IFrameSwitching;\n\t\ttraf_2->use_sample_interleave = traf->use_sample_interleave;\n\t\ttraf_2->interleave_id = traf->interleave_id;\n\t\ttraf_2->truns_first = traf->truns_first;\n\t\ttraf_2->truns_v1 = traf->truns_v1;\n\t\ttraf_2->large_tfdt = traf->large_tfdt;\n\t\ttraf_2->DataCache  = traf->DataCache;\n\t\ttraf_2->tfhd->sample_desc_index  = DescIndex;\n\n\t\t//switch them ...\n\t\ttraf = traf_2;\n\t}\n\n\tpos = movie->moof->trun_ref_size ? (8+movie->moof->trun_ref_size) : gf_bs_get_position(movie->editFileMap->bs);\n\n\t//check if we need a new trun entry\n\tcount = (traf->use_sample_interleave && traf->force_new_trun) ? 0 : gf_list_count(traf->TrackRuns);\n\tif (count) {\n\t\ttrun = (GF_TrackFragmentRunBox *)gf_list_get(traf->TrackRuns, count-1);\n\t\t//check data offset when no caching as trun entries shall ALWAYS be contiguous samples\n\t\tif (!traf->DataCache && (movie->moof->fragment_offset + 8 + trun->data_offset + trun->run_size != pos) )\n\t\t\tcount = 0;\n\n\t\t//check I-frame detection\n\t\tif (traf->IFrameSwitching && sample->IsRAP)\n\t\t\tcount = 0;\n\n\t\tif (traf->DataCache && (traf->DataCache==trun->sample_count) && !traf->use_sample_interleave)\n\t\t\tcount = 0;\n\n\t\tif (traf->force_new_trun)\n\t\t\tcount = 0;\n\n\t\t//if data cache is on and we're changing TRUN, store the cache and update data offset\n\t\tif (!count && traf->DataCache && !traf->use_sample_interleave) {\n\t\t\ttrun->data_offset = (u32) (pos - movie->moof->fragment_offset - 8);\n\t\t\tgf_bs_get_content(trun->cache, &buffer, &buffer_size);\n\t\t\tgf_bs_write_data(movie->editFileMap->bs, buffer, buffer_size);\n\t\t\tgf_bs_del(trun->cache);\n\t\t\ttrun->cache = NULL;\n\t\t\tgf_free(buffer);\n\t\t}\n\t}\n\ttraf->force_new_trun = 0;\n\n\t//new run\n\tif (!count) {\n\t\ttrun = (GF_TrackFragmentRunBox *) gf_isom_box_new_parent(&traf->child_boxes, GF_ISOM_BOX_TYPE_TRUN);\n\t\tif (!trun) return GF_OUT_OF_MEM;\n\t\t//store data offset (we have the 8 btyes offset of the MDAT)\n\t\ttrun->data_offset = (u32) (pos - movie->moof->fragment_offset - 8);\n\t\tgf_list_add(traf->TrackRuns, trun);\n#ifdef GF_ENABLE_CTRN\n\t\ttrun->use_ctrn = traf->use_ctrn;\n\t\ttrun->use_inherit = traf->use_inherit;\n\t\ttrun->ctso_multiplier = traf->trex->def_sample_duration;\n#endif\n\t\ttrun->interleave_id = traf->interleave_id;\n\t\tif (traf->truns_v1)\n\t\t\ttrun->version = 1;\n\n\t\t//if we use data caching, create a bitstream\n\t\tif (traf->DataCache)\n\t\t\ttrun->cache = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t}\n\n\tmemset(&ent, 0, sizeof(GF_TrunEntry));\n\tent.CTS_Offset = sample->CTS_Offset;\n\tent.Duration = Duration;\n\tent.dts = sample->DTS;\n\tent.nb_pack = sample->nb_pack;\n\tent.flags = GF_ISOM_FORMAT_FRAG_FLAGS(PaddingBits, sample->IsRAP, DegradationPriority);\n\tif (sample->IsRAP) {\n\t\tent.flags |= GF_ISOM_GET_FRAG_DEPEND_FLAGS(0, 2, 0, (redundant_coding ? 1 : 0) );\n\t\tent.SAP_type = sample->IsRAP;\n\t}\n\tif (trun->nb_samples) {\n\t\tprev_ent = &trun->samples[trun->nb_samples-1];\n\t} else {\n\t\tprev_ent = NULL;\n\t}\n\n\tif (prev_ent && (prev_ent->dts || !prev_ent->Duration) && sample->DTS) {\n\t\tu32 nsamp = prev_ent->nb_pack ? prev_ent->nb_pack : 1;\n\t\tif (nsamp*prev_ent->Duration != sample->DTS - prev_ent->dts)\n\t\t\tprev_ent->Duration = (u32) (sample->DTS - prev_ent->dts) / nsamp;\n\t}\n\tif (trun->nb_samples >= trun->sample_alloc) {\n\t\ttrun->sample_alloc += 50;\n\t\tif (trun->nb_samples >= trun->sample_alloc) trun->sample_alloc = trun->nb_samples+1;\n\t\ttrun->samples = gf_realloc(trun->samples, sizeof(GF_TrunEntry)*trun->sample_alloc);\n\t\tif (!trun->samples) return GF_OUT_OF_MEM;\n\t}\n\n\t//rewrite OD frames\n\tif (traf->trex->track->Media->handler->handlerType == GF_ISOM_MEDIA_OD) {\n\t\t//this may fail if dependencies are not well done ...\n\t\tGF_Err e = Media_ParseODFrame(traf->trex->track->Media, sample, &od_sample);\n\t\tif (!od_sample) return e;\n\t\tsample = od_sample;\n\t}\n\n\tent.size = sample->dataLength;\n\ttrun->samples[trun->nb_samples] = ent;\n\ttrun->nb_samples ++;\n\ttrun->run_size += ent.size;\n\n\tif (sample->CTS_Offset<0) {\n\t\ttrun->version = 1;\n\t}\n\ttrun->sample_count += sample->nb_pack ? sample->nb_pack : 1;\n\n\t//finally write the data\n\tif (sample->dataLength) {\n\t\tu32 res = 0;\n\t\tif (!traf->DataCache) {\n\t\t\tif (movie->moof_first && movie->on_block_out && (ref || trun->sample_refs)) {\n\t\t\t\tGF_TrafSampleRef *sref;\n\t\t\t\tif (!trun->sample_refs) trun->sample_refs = gf_list_new();\n\t\t\t\tGF_SAFEALLOC(sref, GF_TrafSampleRef);\n\t\t\t\tif (!sref) return GF_OUT_OF_MEM;\n\t\t\t\tif (ref && *ref && !od_sample) {\n\t\t\t\t\tsref->data = sample->data;\n\t\t\t\t\tsref->len = sample->dataLength;\n\t\t\t\t\tsref->ref = *ref;\n\t\t\t\t\tsref->ref_offset = ref_offset;\n\t\t\t\t\t*ref = NULL;\n\t\t\t\t} else {\n\t\t\t\t\tsref->data = gf_malloc(sample->dataLength);\n\t\t\t\t\tif (!sref->data) {\n\t\t\t\t\t\tgf_free(sref);\n\t\t\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t\t\t}\n\t\t\t\t\tmemcpy(sref->data, sample->data, sample->dataLength);\n\t\t\t\t\tsref->len = sample->dataLength;\n\t\t\t\t}\n\t\t\t\tres = sref->len;\n\t\t\t\ttraf->trun_ref_size += res;\n\t\t\t\tmovie->moof->trun_ref_size += res;\n\t\t\t\tgf_list_add(trun->sample_refs, sref);\n\t\t\t} else {\n\t\t\t\tres = gf_bs_write_data(movie->editFileMap->bs, sample->data, sample->dataLength);\n\t\t\t}\n\t\t} else if (trun->cache) {\n\t\t\tres = gf_bs_write_data(trun->cache, sample->data, sample->dataLength);\n\t\t} else {\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t\tif (res!=sample->dataLength) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso fragment] Could not add a sample with a size of %u bytes\\n\", sample->dataLength));\n\t\t\treturn GF_OUT_OF_MEM;\n\t\t}\n\n\t}\n\tif (od_sample) gf_isom_sample_del(&od_sample);\n\n\tif (traf->trex->tfra) {\n\t\tGF_RandomAccessEntry *raf;\n\t\traf = &traf->trex->tfra->entries[traf->trex->tfra->nb_entries-1];\n\t\t//if sample is sync, store its time and trun number\n\t\tif (!raf->trun_number && sample->IsRAP) {\n\t\t\traf->time = sample->DTS + sample->CTS_Offset;\n\t\t\traf->trun_number = gf_list_count(traf->TrackRuns);\n\t\t\traf->sample_number = trun->sample_count;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_fragment_add_sample(GF_ISOFile *movie, GF_ISOTrackID TrackID, const GF_ISOSample *sample, u32 DescIndex,\n                                   u32 Duration, u8 PaddingBits, u16 DegradationPriority, Bool redundant_coding)\n{\n\treturn gf_isom_fragment_add_sample_ex(movie, TrackID, sample, DescIndex, Duration, PaddingBits, DegradationPriority, redundant_coding, NULL, 0);\n\n}\nGF_EXPORT\nGF_Err gf_isom_fragment_set_cenc_sai(GF_ISOFile *output, GF_ISOTrackID TrackID, u8 *sai_b, u32 sai_b_size, Bool use_subsamples, Bool use_saio_32bit, Bool use_multikey)\n{\n\tGF_CENCSampleAuxInfo *sai;\n\tGF_TrackFragmentBox  *traf = gf_isom_get_traf(output, TrackID);\n\tGF_SampleEncryptionBox *senc;\n\n\tif (!traf)  return GF_BAD_PARAM;\n\n\tif (!traf->sample_encryption) {\n\t\tif (!traf->trex->track->sample_encryption) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[isofile] trying to add CENC SAI without storage box allocated\\n\" ));\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t\tif (traf->trex->track->sample_encryption->type == GF_ISOM_BOX_TYPE_SENC) {\n\t\t\ttraf->sample_encryption = gf_isom_create_samp_enc_box(0, 0);\n\t\t} else {\n\t\t\tGF_SampleEncryptionBox *psec = (GF_SampleEncryptionBox *) traf->trex->track->sample_encryption;\n\t\t\tif (!psec) return GF_ISOM_INVALID_FILE;\n\t\t\ttraf->sample_encryption = gf_isom_create_piff_psec_box(1, 0, psec->AlgorithmID, psec->IV_size, psec->KID);\n\t\t}\n\t\tif (!traf->sample_encryption) return GF_OUT_OF_MEM;\n\t\ttraf->sample_encryption->traf = traf;\n\n\t\tif (!traf->child_boxes) traf->child_boxes = gf_list_new();\n\t\tgf_list_add(traf->child_boxes, traf->sample_encryption);\n\t}\n\tsenc = (GF_SampleEncryptionBox *) traf->sample_encryption;\n\n\tif (!sai_b_size && !sai_b) {\n\t\tgf_isom_cenc_set_saiz_saio(senc, NULL, traf, 0, use_saio_32bit, use_multikey);\n\t\treturn GF_OK;\n\t}\n\n\tGF_SAFEALLOC(sai, GF_CENCSampleAuxInfo);\n\tif (!sai) return GF_OUT_OF_MEM;\n\n\tif (sai_b && sai_b_size) {\n\t\tsai->cenc_data_size = sai_b_size;\n\t\tsai->cenc_data = gf_malloc(sizeof(u8) * sai_b_size);\n\t\tif (!sai->cenc_data) {\n\t\t\tgf_free(sai);\n\t\t\treturn GF_OUT_OF_MEM;\n\t\t}\n\t\tmemcpy(sai->cenc_data, sai_b, sai_b_size);\n\t} else {\n\t\tsai->isNotProtected = 1;\n\t}\n\n\tgf_list_add(senc->samp_aux_info, sai);\n\tif (use_subsamples)\n\t\tsenc->flags = 0x00000002;\n\tif (use_multikey)\n\t\tsenc->version = 1;\n\n\tgf_isom_cenc_set_saiz_saio(senc, NULL, traf, sai->cenc_data_size, use_saio_32bit, use_multikey);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_fragment_append_data_ex(GF_ISOFile *movie, GF_ISOTrackID TrackID, u8 *data, u32 data_size, u8 PaddingBits, void **ref, u32 ref_offset)\n{\n\tu32 count;\n\tu8 rap;\n\tu16 degp;\n\tGF_TrunEntry *ent;\n\tGF_TrackFragmentBox *traf;\n\tGF_TrackFragmentRunBox *trun;\n\tif (!movie->moof || !(movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY) ) return GF_BAD_PARAM;\n\n\ttraf = gf_isom_get_traf(movie, TrackID);\n\tif (!traf || !traf->tfhd->sample_desc_index) return GF_BAD_PARAM;\n\n\t//add TRUN entry\n\tcount = gf_list_count(traf->TrackRuns);\n\tif (!count) return GF_BAD_PARAM;\n\n\ttrun = (GF_TrackFragmentRunBox *)gf_list_get(traf->TrackRuns, count-1);\n\tif (!trun->nb_samples) return GF_BAD_PARAM;\n\tent = &trun->samples[trun->nb_samples-1];\n\tent->size += data_size;\n\ttrun->run_size += data_size;\n\n\trap = GF_ISOM_GET_FRAG_SYNC(ent->flags);\n\tdegp = GF_ISOM_GET_FRAG_DEG(ent->flags);\n\tent->flags = GF_ISOM_FORMAT_FRAG_FLAGS(PaddingBits, rap, degp);\n\n\t//finally write the data\n\tif (!traf->DataCache) {\n\t\tif (movie->moof_first && movie->on_block_out && (ref || trun->sample_refs)) {\n\t\t\tGF_TrafSampleRef *sref;\n\t\t\tif (!trun->sample_refs) trun->sample_refs = gf_list_new();\n\t\t\tGF_SAFEALLOC(sref, GF_TrafSampleRef);\n\t\t\tif (!sref) return GF_OUT_OF_MEM;\n\t\t\tif (ref && *ref) {\n\t\t\t\tsref->data = data;\n\t\t\t\tsref->len = data_size;\n\t\t\t\tsref->ref = *ref;\n\t\t\t\tsref->ref_offset = ref_offset;\n\t\t\t\t*ref = NULL;\n\t\t\t} else {\n\t\t\t\tsref->data = gf_malloc(data_size);\n\t\t\t\tif (!sref->data) {\n\t\t\t\t\tgf_free(sref);\n\t\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t\t}\n\t\t\t\tmemcpy(sref->data, data, data_size);\n\t\t\t\tsref->len = data_size;\n\t\t\t}\n\t\t\ttraf->trun_ref_size += sref->len;\n\t\t\tmovie->moof->trun_ref_size += sref->len;\n\t\t\tgf_list_add(trun->sample_refs, sref);\n\t\t} else {\n\t\t\tgf_bs_write_data(movie->editFileMap->bs, data, data_size);\n\t\t}\n\t} else if (trun->cache) {\n\t\tgf_bs_write_data(trun->cache, data, data_size);\n\t} else {\n\t\treturn GF_BAD_PARAM;\n\t}\n\treturn GF_OK;\n}\nGF_EXPORT\nGF_Err gf_isom_fragment_append_data(GF_ISOFile *movie, GF_ISOTrackID TrackID, u8 *data, u32 data_size, u8 PaddingBits)\n{\n\treturn gf_isom_fragment_append_data_ex(movie, TrackID, data, data_size, PaddingBits, NULL, 0);\n\n}\n\nGF_Err gf_isom_fragment_add_subsample(GF_ISOFile *movie, GF_ISOTrackID TrackID, u32 flags, u32 subSampleSize, u8 priority, u32 reserved, Bool discardable)\n{\n\tu32 i, count, last_sample;\n\tGF_TrackFragmentBox *traf;\n\tGF_SubSampleInformationBox *subs = NULL;\n\tif (!movie->moof || !(movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY) ) return GF_BAD_PARAM;\n\n\ttraf = gf_isom_get_traf(movie, TrackID);\n\tif (!traf || !traf->tfhd->sample_desc_index) return GF_BAD_PARAM;\n\n\t/*compute last sample number in traf*/\n\tlast_sample = 0;\n\tcount = gf_list_count(traf->TrackRuns);\n\tfor (i=0; i<count; i++) {\n\t\tGF_TrackFragmentRunBox *trun = (GF_TrackFragmentRunBox*)gf_list_get(traf->TrackRuns, i);\n\t\tlast_sample += trun->sample_count;\n\t}\n\n\tif (!traf->sub_samples) {\n\t\ttraf->sub_samples = gf_list_new();\n\t}\n\tcount = gf_list_count(traf->sub_samples);\n\tfor (i=0; i<count;i++) {\n\t\tsubs = gf_list_get(traf->sub_samples, i);\n\t\tif (subs->flags==flags) break;\n\t\tsubs=NULL;\n\t}\n\tif (!subs) {\n\t\tsubs = (GF_SubSampleInformationBox *) gf_isom_box_new_parent(&traf->child_boxes, GF_ISOM_BOX_TYPE_SUBS);\n\t\tif (!subs) return GF_OUT_OF_MEM;\n\t\tsubs->version = (subSampleSize>0xFFFF) ? 1 : 0;\n\t\tsubs->flags = flags;\n\t\tgf_list_add(traf->sub_samples, subs);\n\t}\n\treturn gf_isom_add_subsample_info(subs, last_sample, subSampleSize, priority, reserved, discardable);\n}\n\n#if 0 //unused\nstatic GF_Err gf_isom_copy_sample_group_entry_to_traf(GF_TrackFragmentBox *traf, GF_SampleTableBox *stbl, u32 grouping_type, u32 grouping_type_parameter, u32 sampleGroupDescriptionIndex, Bool sgpd_in_traf)\n{\n\tif (sgpd_in_traf) {\n\t\tvoid *entry = NULL;\n\t\tu32 i, count;\n\t\tGF_SampleGroupDescriptionBox *sgdesc = NULL;\n\t\tGF_BitStream *bs;\n\n\t\tcount = gf_list_count(stbl->sampleGroupsDescription);\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tsgdesc = (GF_SampleGroupDescriptionBox *)gf_list_get(stbl->sampleGroupsDescription, i);\n\t\t\tif (sgdesc->grouping_type == grouping_type)\n\t\t\t\tbreak;\n\t\t\tsgdesc = NULL;\n\t\t}\n\t\tif (!sgdesc)\n\t\t\treturn GF_BAD_PARAM;\n\n\t\tentry = gf_list_get(sgdesc->group_descriptions, sampleGroupDescriptionIndex-1);\n\t\tif (!entry)\n\t\t\treturn GF_BAD_PARAM;\n\n\t\tswitch (grouping_type) {\n\t\tcase GF_ISOM_SAMPLE_GROUP_RAP:\n\t\t{\n\t\t\tchar udta[2];\n\t\t\tbs = gf_bs_new(udta, 2*sizeof(char), GF_BITSTREAM_WRITE);\n\t\t\tgf_bs_write_u8(bs, ((GF_VisualRandomAccessEntry *)entry)->num_leading_samples_known);\n\t\t\tgf_bs_write_u8(bs, ((GF_VisualRandomAccessEntry *)entry)->num_leading_samples);\n\t\t\tgf_bs_del(bs);\n\t\t\treturn gf_isom_set_sample_group_info_ex(NULL, traf, 0, grouping_type, 0, udta, sg_rap_create_entry, sg_rap_compare_entry);\n\t\t}\n\t\tcase GF_ISOM_SAMPLE_GROUP_SYNC:\n\t\t{\n\t\t\tchar udta[1];\n\t\t\tbs = gf_bs_new(udta, 1*sizeof(char), GF_BITSTREAM_WRITE);\n\t\t\tgf_bs_write_int(bs, 0, 2);\n\t\t\tgf_bs_write_int(bs, ((GF_SYNCEntry *)entry)->NALU_type, 6);\n\t\t\tgf_bs_del(bs);\n\t\t\treturn gf_isom_set_sample_group_info_ex(NULL, traf, 0, grouping_type, 0, udta, sg_rap_create_entry, sg_rap_compare_entry);\n\t\t}\n\t\tcase GF_ISOM_SAMPLE_GROUP_ROLL:\n\t\t{\n\t\t\tchar udta[2];\n\t\t\tbs = gf_bs_new(udta, 2*sizeof(char), GF_BITSTREAM_WRITE);\n\t\t\tgf_bs_write_u16(bs, ((GF_RollRecoveryEntry *)entry)->roll_distance);\n\t\t\tgf_bs_del(bs);\n\t\t\treturn gf_isom_set_sample_group_info_ex(NULL, traf, 0, grouping_type, 0, udta, sg_roll_create_entry, sg_roll_compare_entry);\n\t\t}\n\t\tcase GF_ISOM_SAMPLE_GROUP_SEIG:\n\t\t{\n\t\t\treturn gf_isom_set_sample_group_info_ex(NULL, traf, 0, grouping_type, 0, entry, sg_encryption_create_entry, sg_encryption_compare_entry);\n\t\t}\n\t\tdefault:\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t}\n\n\treturn gf_isom_add_sample_group_entry(traf->sampleGroups, 0, grouping_type, grouping_type_parameter, sampleGroupDescriptionIndex, NULL);\n}\n/*copy over the subsample and sampleToGroup information of the given sample from the source track/file to the last sample added to the current track fragment of the destination file*/\nGF_Err gf_isom_fragment_copy_subsample(GF_ISOFile *dest, GF_ISOTrackID TrackID, GF_ISOFile *orig, u32 track, u32 sampleNumber, Bool sgpd_in_traf)\n{\n\tu32 i, count, last_sample, idx, subs_flags;\n\tGF_SubSampleInfoEntry *sub_sample;\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_TrackFragmentBox *traf;\n\tGF_TrunEntry *ent;\n\tGF_TrackFragmentRunBox *trun;\n\tif (!dest->moof || !(dest->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY) ) return GF_BAD_PARAM;\n\n\ttraf = gf_isom_get_traf(dest, TrackID);\n\tif (!traf || !traf->tfhd->sample_desc_index) return GF_BAD_PARAM;\n\n\ttrak = gf_isom_get_track_from_file(orig, track);\n\tif (!trak) return GF_BAD_PARAM;\n\n\t/*modify depends flags*/\n\tif (trak->Media->information->sampleTable->SampleDep) {\n\t\tu32 isLeading, dependsOn, dependedOn, redundant;\n\n\t\tisLeading = dependsOn = dependedOn = redundant = 0;\n\t\tcount = gf_list_count(traf->TrackRuns);\n\t\tif (!count) return GF_BAD_PARAM;\n\t\ttrun = (GF_TrackFragmentRunBox *)gf_list_get(traf->TrackRuns, count-1);\n\t\tcount = gf_list_count(trun->entries);\n\t\tif (!count) return GF_BAD_PARAM;\n\n\t\tent = (GF_TrunEntry *)gf_list_get(trun->entries, count-1);\n\t\te = stbl_GetSampleDepType(trak->Media->information->sampleTable->SampleDep, sampleNumber, &isLeading, &dependsOn, &dependedOn, &redundant);\n\t\tif (e) return e;\n\n\t\tGF_ISOM_RESET_FRAG_DEPEND_FLAGS(ent->flags);\n\n\t\tif (traf->use_sdtp) {\n\t\t\tu8 sflags=0;\n\t\t\tif (!traf->sdtp) {\n\t\t\t\ttraf->sdtp = (GF_SampleDependencyTypeBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_SDTP);\n\t\t\t\tif (!traf->sdtp) return GF_OUT_OF_MEM;\n\t\t\t}\n\t\t\tsflags |= isLeading << 6;\n\t\t\tsflags |= dependsOn << 4;\n\t\t\tsflags |= dependedOn << 2;\n\t\t\tsflags |= redundant;\n\n\t\t\ttraf->sdtp->sample_info = gf_realloc(traf->sdtp->sample_info, sizeof(u8)*(traf->sdtp->sampleCount+1));\n\t\t\ttraf->sdtp->sample_info[traf->sdtp->sampleCount] = (u8) sflags;\n\t\t\ttraf->sdtp->sampleCount++;\n\t\t\ttraf->sdtp->sample_alloc = traf->sdtp->sampleCount+1;\n\n\n\t\t\tif (traf->use_sdtp==2) {\n\t\t\t\tent->flags |= GF_ISOM_GET_FRAG_DEPEND_FLAGS(isLeading, dependsOn, dependedOn, redundant);\n\t\t\t}\n\t\t} else {\n\t\t\tent->flags |= GF_ISOM_GET_FRAG_DEPEND_FLAGS(isLeading, dependsOn, dependedOn, redundant);\n\t\t}\n\t}\n\n\t/*copy subsample info if any*/\n\tidx=1;\n\twhile (gf_isom_get_subsample_types(orig, track, idx, &subs_flags)) {\n\t\tGF_SubSampleInformationBox *subs_traf=NULL;\n\t\tidx++;\n\t\tif (! gf_isom_sample_get_subsample_entry(orig, track, sampleNumber, subs_flags, &sub_sample))\n\t\t\tcontinue;\n\n\t\tif (!traf || !traf->tfhd->sample_desc_index) return GF_BAD_PARAM;\n\n\t\t/*compute last sample number in traf*/\n\t\tlast_sample = 0;\n\t\tcount = gf_list_count(traf->TrackRuns);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_TrackFragmentRunBox *trun = (GF_TrackFragmentRunBox*)gf_list_get(traf->TrackRuns, i);\n\t\t\tlast_sample += trun->sample_count;\n\t\t}\n\n\t\t/*create subsample if needed*/\n\t\tif (!traf->sub_samples) {\n\t\t\ttraf->sub_samples = gf_list_new();\n\t\t}\n\t\tcount = gf_list_count(traf->sub_samples);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tsubs_traf = gf_list_get(traf->sub_samples, i);\n\t\t\tif (subs_traf->flags==subs_flags) break;\n\t\t\tsubs_traf = NULL;\n\t\t}\n\t\tif (!subs_traf) {\n\t\t\tsubs_traf = (GF_SubSampleInformationBox *) gf_isom_box_new_parent(&traf->child_boxes, GF_ISOM_BOX_TYPE_SUBS);\n\t\t\tif (!subs_traf) return GF_OUT_OF_MEM;\n\t\t\tsubs_traf->version = 0;\n\t\t\tsubs_traf->flags = subs_flags;\n\t\t\tgf_list_add(traf->sub_samples, subs_traf);\n\t\t}\n\n\t\tcount = gf_list_count(sub_sample->SubSamples);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_SubSampleEntry *entry = (GF_SubSampleEntry*)gf_list_get(sub_sample->SubSamples, i);\n\t\t\te = gf_isom_add_subsample_info(subs_traf, last_sample, entry->subsample_size, entry->subsample_priority, entry->reserved, entry->discardable);\n\t\t\tif (e) return e;\n\t\t}\n\t}\n\t/*copy sampleToGroup info if any*/\n\tif (trak->Media->information->sampleTable->sampleGroups) {\n\t\tcount = gf_list_count(trak->Media->information->sampleTable->sampleGroups);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_SampleGroupBox *sg;\n\t\t\tBool found = GF_FALSE;\n\t\t\tu32 j;\n\t\t\tu32 first_sample_in_entry, last_sample_in_entry;\n\t\t\tfirst_sample_in_entry = 1;\n\n\t\t\tsg = (GF_SampleGroupBox*)gf_list_get(trak->Media->information->sampleTable->sampleGroups, i);\n\t\t\tfor (j=0; j<sg->entry_count; j++) {\n\t\t\t\tlast_sample_in_entry = first_sample_in_entry + sg->sample_entries[j].sample_count - 1;\n\t\t\t\tif ((sampleNumber<first_sample_in_entry) || (sampleNumber>last_sample_in_entry)) {\n\t\t\t\t\tfirst_sample_in_entry = last_sample_in_entry+1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (!traf->sampleGroups)\n\t\t\t\t\ttraf->sampleGroups = gf_list_new();\n\n\t\t\t\t/*found our sample, add it to trak->sampleGroups*/\n\t\t\t\te = gf_isom_copy_sample_group_entry_to_traf(traf, trak->Media->information->sampleTable, sg->grouping_type, sg->grouping_type_parameter,  sg->sample_entries[j].group_description_index, sgpd_in_traf);\n\t\t\t\tif (e) return e;\n\n\t\t\t\tfound = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t//unmapped sample\n\t\t\tif (!found) {\n\t\t\t\tif (!traf->sampleGroups)\n\t\t\t\t\ttraf->sampleGroups = gf_list_new();\n\n\t\t\t\te = gf_isom_copy_sample_group_entry_to_traf(traf, trak->Media->information->sampleTable, sg->grouping_type, sg->grouping_type_parameter,  0, sgpd_in_traf);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n#endif\n\n\nGF_Err gf_isom_fragment_set_sample_flags(GF_ISOFile *movie, GF_ISOTrackID trackID, u32 is_leading, u32 dependsOn, u32 dependedOn, u32 redundant)\n{\n\tu32 count;\n\tGF_TrackFragmentBox *traf;\n\tGF_TrunEntry *ent;\n\tGF_TrackFragmentRunBox *trun;\n\tif (!movie || !movie->moof || !(movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY) ) return GF_BAD_PARAM;\n\n\ttraf = gf_isom_get_traf(movie, trackID);\n\tif (!traf->tfhd->sample_desc_index) return GF_BAD_PARAM;\n\n\tcount = gf_list_count(traf->TrackRuns);\n\tif (!count) return GF_BAD_PARAM;\n\ttrun = (GF_TrackFragmentRunBox *)gf_list_get(traf->TrackRuns, count-1);\n\tif (!trun->nb_samples) return GF_BAD_PARAM;\n\tent = &trun->samples[trun->nb_samples-1];\n\n\tGF_ISOM_RESET_FRAG_DEPEND_FLAGS(ent->flags);\n\n\tif (traf->use_sdtp) {\n\t\tu8 sflags=0;\n\t\tif (!traf->sdtp) {\n\t\t\ttraf->sdtp = (GF_SampleDependencyTypeBox *) gf_isom_box_new_parent(&traf->child_boxes, GF_ISOM_BOX_TYPE_SDTP);\n\t\t\tif (!traf->sdtp) return GF_OUT_OF_MEM;\n\t\t}\n\t\tsflags |= is_leading << 6;\n\t\tsflags |= dependsOn << 4;\n\t\tsflags |= dependedOn << 2;\n\t\tsflags |= redundant;\n\n\t\ttraf->sdtp->sample_info = gf_realloc(traf->sdtp->sample_info, sizeof(u8)*(traf->sdtp->sampleCount+1));\n\t\ttraf->sdtp->sample_info[traf->sdtp->sampleCount] = (u8) sflags;\n\t\ttraf->sdtp->sampleCount++;\n\t\ttraf->sdtp->sample_alloc = traf->sdtp->sampleCount;\n\t\tif (traf->use_sdtp==2) {\n\t\t\tent->flags |= GF_ISOM_GET_FRAG_DEPEND_FLAGS(is_leading, dependsOn, dependedOn, redundant);\n\t\t}\n\t} else {\n\t\tent->flags |= GF_ISOM_GET_FRAG_DEPEND_FLAGS(is_leading, dependsOn, dependedOn, redundant);\n\t}\n\treturn GF_OK;\n}\n\n\n#endif\t/*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_EXPORT\nGF_Err gf_isom_set_traf_base_media_decode_time(GF_ISOFile *movie, GF_ISOTrackID TrackID, u64 decode_time)\n{\n\tGF_TrackFragmentBox *traf;\n\tif (!movie || !movie->moof || !(movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY) ) return GF_BAD_PARAM;\n\n\ttraf = gf_isom_get_traf(movie, TrackID);\n\tif (!traf) return GF_BAD_PARAM;\n\n\tif (!traf->tfdt) {\n\t\ttraf->tfdt = (GF_TFBaseMediaDecodeTimeBox *) gf_isom_box_new_parent(&traf->child_boxes, GF_ISOM_BOX_TYPE_TFDT);\n\t\tif (!traf->tfdt) return GF_OUT_OF_MEM;\n\t}\n\ttraf->tfdt->baseMediaDecodeTime = decode_time;\n\tif (traf->large_tfdt)\n\t\ttraf->tfdt->version = 1;\n\treturn GF_OK;\n}\n\nGF_Err gf_isom_enable_mfra(GF_ISOFile *file)\n{\n\tif (!file) return GF_BAD_PARAM;\n\tfile->mfra = (GF_MovieFragmentRandomAccessBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_MFRA);\n\tif (!file->mfra) return GF_OUT_OF_MEM;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_FRAGMENTS)*/\n\n\nGF_EXPORT\nvoid gf_isom_set_next_moof_number(GF_ISOFile *movie, u32 value)\n{\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (movie) movie->NextMoofNumber = value;\n#endif\n}\n\nGF_EXPORT\nu32 gf_isom_get_next_moof_number(GF_ISOFile *movie)\n{\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (movie) return movie->NextMoofNumber;\n#endif\n\treturn 0;\n}\n\nGF_Err gf_isom_set_emsg(GF_ISOFile *movie, u8 *data, u32 size)\n{\n\tif (!movie || !data) return GF_BAD_PARAM;\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (!movie->moof) return GF_BAD_PARAM;\n\n\tGF_BitStream *bs = gf_bs_new(data, size, GF_BITSTREAM_READ);\n\twhile (gf_bs_available(bs)) {\n\t\tGF_Box *emsg;\n\t\tGF_Err e = gf_isom_box_parse(&emsg, bs);\n\t\tif (e) break;\n\n\t\tif (!movie->moof->emsgs) movie->moof->emsgs = gf_list_new();\n\t\tgf_list_add(movie->moof->emsgs, emsg);\n\t}\n\tgf_bs_del(bs);\n#endif\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nBool gf_isom_is_track_fragmented(GF_ISOFile *movie, GF_ISOTrackID TrackID)\n{\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (!movie || !movie->moov || !movie->moov->mvex) return GF_FALSE;\n\treturn (GetTrex(movie->moov, TrackID) != NULL) ? GF_TRUE : GF_FALSE;\n#else\n\treturn GF_FALSE;\n#endif\n}\n\nGF_EXPORT\nBool gf_isom_is_fragmented(GF_ISOFile *movie)\n{\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (!movie || !movie->moov) return GF_FALSE;\n\t/* By default if the Moov has an mvex, the file is fragmented */\n\tif (movie->moov->mvex) return GF_TRUE;\n#endif\n\treturn GF_FALSE;\n}\n\n#endif /*GPAC_DISABLE_ISOM*/\n"], "filenames": ["src/isomedia/movie_fragments.c"], "buggy_code_start_loc": [2879], "buggy_code_end_loc": [2880], "fixing_code_start_loc": [2879], "fixing_code_end_loc": [2881], "type": "CWE-476", "message": "NULL Pointer Dereference in GitHub repository gpac/gpac prior to 2.2.2.", "other": {"cve": {"id": "CVE-2023-2840", "sourceIdentifier": "security@huntr.dev", "published": "2023-05-22T18:15:09.423", "lastModified": "2023-05-27T04:15:25.250", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "NULL Pointer Dereference in GitHub repository gpac/gpac prior to 2.2.2."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.4}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gpac:gpac:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.2.1", "matchCriteriaId": "3494E20D-63BD-424C-88EF-B28F0BF57D1D"}]}]}], "references": [{"url": "https://github.com/gpac/gpac/commit/ba59206b3225f0e8e95a27eff41cb1c49ddf9a37", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.dev/bounties/21926fc2-6eb1-4e24-8a36-e60f487d0257", "source": "security@huntr.dev", "tags": ["Exploit", "Patch"]}, {"url": "https://www.debian.org/security/2023/dsa-5411", "source": "security@huntr.dev"}]}, "github_commit_url": "https://github.com/gpac/gpac/commit/ba59206b3225f0e8e95a27eff41cb1c49ddf9a37"}}