{"buggy_code": ["/**********************************************************************\n *                        gost_ec_keyx.c                              *\n *                                                                    *\n *             Copyright (c) 2005-2013 Cryptocom LTD                  *\n *   Copyright (c) 2018,2020 Dmitry Belyavskiy <beldmit@gmail.com>    *\n *   Copyright (c) 2020 Billy Brumley <bbrumley@gmail.com>            *\n *                                                                    *\n *         This file is distributed under the same license as OpenSSL *\n *                                                                    *\n *   VK0 R 50.1.113-2016 / RFC 7836                                   *\n *   KEG R 1323565.1.020-2018                                         *\n *   VK0 34.10-2001 key exchange and GOST R 34.10-2001 (RFC 4357)     *\n *   based PKCS7/SMIME support                                        *\n *          Requires OpenSSL 0.9.9 for compilation                    *\n **********************************************************************/\n#include <openssl/evp.h>\n#include <openssl/err.h>\n#include <openssl/rand.h>\n#include <string.h>\n#include <openssl/objects.h>\n#include \"gost89.h\"\n#include \"e_gost_err.h\"\n#include \"gost_keywrap.h\"\n#include \"gost_lcl.h\"\n\n/* Implementation of CryptoPro VKO 34.10-2001/2012 algorithm */\nint VKO_compute_key(unsigned char *shared_key,\n                    const EC_POINT *pub_key, const EC_KEY *priv_key,\n                    const unsigned char *ukm, const size_t ukm_size,\n                    const int vko_dgst_nid)\n{\n    unsigned char *databuf = NULL;\n    BIGNUM *scalar = NULL, *X = NULL, *Y = NULL;\n    const EC_GROUP *grp = NULL;\n    EC_POINT *pnt = NULL;\n    BN_CTX *ctx = NULL;\n    EVP_MD_CTX *mdctx = NULL;\n    const EVP_MD *md = NULL;\n    int buf_len, half_len;\n    int ret = 0;\n\n    if ((ctx = BN_CTX_secure_new()) == NULL) {\n        GOSTerr(GOST_F_VKO_COMPUTE_KEY, ERR_R_MALLOC_FAILURE);\n        return 0;\n    }\n    BN_CTX_start(ctx);\n\n    md = EVP_get_digestbynid(vko_dgst_nid);\n    if (!md) {\n        GOSTerr(GOST_F_VKO_COMPUTE_KEY, GOST_R_INVALID_DIGEST_TYPE);\n        goto err;\n    }\n\n    grp = EC_KEY_get0_group(priv_key);\n    scalar = BN_CTX_get(ctx);\n    X = BN_CTX_get(ctx);\n\n    if ((Y = BN_CTX_get(ctx)) == NULL\n        || (pnt = EC_POINT_new(grp)) == NULL\n        || BN_lebin2bn(ukm, ukm_size, scalar) == NULL\n        || !BN_mod_mul(scalar, scalar, EC_KEY_get0_private_key(priv_key),\n                       EC_GROUP_get0_order(grp), ctx))\n        goto err;\n\n#if 0\n    /*-\n     * These two curves have cofactor 4; the rest have cofactor 1.\n     * But currently gost_ec_point_mul takes care of the cofactor clearing,\n     * hence this code is not needed.\n     */\n    switch (EC_GROUP_get_curve_name(grp)) {\n        case NID_id_tc26_gost_3410_2012_256_paramSetA:\n        case NID_id_tc26_gost_3410_2012_512_paramSetC:\n            if (!BN_lshift(scalar, scalar, 2))\n                goto err;\n            break;\n    }\n#endif\n\n    if (!gost_ec_point_mul(grp, pnt, NULL, pub_key, scalar, ctx)) {\n        GOSTerr(GOST_F_VKO_COMPUTE_KEY, GOST_R_ERROR_POINT_MUL);\n        goto err;\n    }\n    if (!EC_POINT_get_affine_coordinates(grp, pnt, X, Y, ctx)) {\n        GOSTerr(GOST_F_VKO_COMPUTE_KEY, ERR_R_EC_LIB);\n        goto err;\n    }\n\n    half_len = BN_num_bytes(EC_GROUP_get0_field(grp));\n    buf_len = 2 * half_len;\n    if ((databuf = OPENSSL_malloc(buf_len)) == NULL) {\n        GOSTerr(GOST_F_VKO_COMPUTE_KEY, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    /*\n     * Serialize elliptic curve point same way as we do it when saving key\n     */\n    if (BN_bn2lebinpad(X, databuf, half_len) != half_len\n        || BN_bn2lebinpad(Y, databuf + half_len, half_len) != half_len)\n        goto err;\n\n    if ((mdctx = EVP_MD_CTX_new()) == NULL) {\n        GOSTerr(GOST_F_VKO_COMPUTE_KEY, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    if (EVP_MD_CTX_init(mdctx) == 0\n        || EVP_DigestInit_ex(mdctx, md, NULL) == 0\n        || EVP_DigestUpdate(mdctx, databuf, buf_len) == 0\n        || EVP_DigestFinal_ex(mdctx, shared_key, NULL) == 0) {\n        GOSTerr(GOST_F_VKO_COMPUTE_KEY, ERR_R_EVP_LIB);\n        goto err;\n    }\n\n    ret = (EVP_MD_size(md) > 0) ? EVP_MD_size(md) : 0;\n\n err:\n    BN_CTX_end(ctx);\n    BN_CTX_free(ctx);\n    EC_POINT_free(pnt);\n    EVP_MD_CTX_free(mdctx);\n    OPENSSL_free(databuf);\n\n    return ret;\n}\n\n/*\n * KEG Algorithm described in R 1323565.1.020-2018 6.4.5.1.\n * keyout expected to be 64 bytes\n * */\nstatic int gost_keg(const unsigned char *ukm_source, int pkey_nid,\n                    const EC_POINT *pub_key, const EC_KEY *priv_key,\n                    unsigned char *keyout)\n{\n/* Adjust UKM */\n    unsigned char real_ukm[16];\n    size_t keylen = 0;\n\n    memset(real_ukm, 0, 16);\n    if (memcmp(ukm_source, real_ukm, 16) == 0)\n        real_ukm[15] = 1;\n    else {\n        memcpy(real_ukm, ukm_source, 16);\n        BUF_reverse(real_ukm, NULL, 16);\n    }\n\n    switch (pkey_nid) {\n    case NID_id_GostR3410_2012_512:\n        keylen =\n            VKO_compute_key(keyout, pub_key, priv_key, real_ukm, 16,\n                            NID_id_GostR3411_2012_512);\n        return (keylen) ? keylen : 0;\n        break;\n\n    case NID_id_GostR3410_2012_256:\n        {\n            unsigned char tmpkey[32];\n            keylen =\n              VKO_compute_key(tmpkey, pub_key, priv_key, real_ukm, 16,\n                  NID_id_GostR3411_2012_256);\n\n            if (keylen == 0)\n                return 0;\n\n            if (gost_kdftree2012_256\n                (keyout, 64, tmpkey, 32, (const unsigned char *)\"kdf tree\", 8,\n                 ukm_source + 16, 8, 1) > 0)\n                keylen = 64;\n            else\n                keylen = 0;\n\n            OPENSSL_cleanse(tmpkey, 32);\n            return (keylen) ? keylen : 0;\n        }\n    default:\n        return 0;\n    }\n}\n\n/*\n * EVP_PKEY_METHOD callback derive.\n * Implements VKO R 34.10-2001/2012 algorithms\n */\n/*\n * Backend for EVP_PKEY_derive()\n * It have KEG mode (default) and VKO mode (enable by EVP_PKEY_CTRL_SET_VKO).\n */\nint pkey_gost_ec_derive(EVP_PKEY_CTX *ctx, unsigned char *key, size_t *keylen)\n{\n    /*\n     * Public key of peer in the ctx field peerkey\n     * Our private key in the ctx pkey\n     * ukm is in the algorithm specific context data\n     */\n    EVP_PKEY *my_key = EVP_PKEY_CTX_get0_pkey(ctx);\n    EVP_PKEY *peer_key = EVP_PKEY_CTX_get0_peerkey(ctx);\n    struct gost_pmeth_data *data = EVP_PKEY_CTX_get_data(ctx);\n    int dgst_nid = NID_undef;\n\n    if (!data || data->shared_ukm_size == 0) {\n        GOSTerr(GOST_F_PKEY_GOST_EC_DERIVE, GOST_R_UKM_NOT_SET);\n        return 0;\n    }\n\n    /* VKO */\n    if (data->vko_dgst_nid) {\n        if (!key) {\n            *keylen = data->vko_dgst_nid == NID_id_GostR3411_2012_256? 32 : 64;\n            return 1;\n        }\n        *keylen = VKO_compute_key(key,\n                                  EC_KEY_get0_public_key(EVP_PKEY_get0(peer_key)),\n                                  (EC_KEY *)EVP_PKEY_get0(my_key),\n                                  data->shared_ukm, data->shared_ukm_size,\n                                  data->vko_dgst_nid);\n        return (*keylen) ? 1 : 0;\n    }\n\n    /*\n     * shared_ukm_size = 8 stands for pre-2018 cipher suites\n     * It means 32 bytes of key length, 8 byte UKM, 32-bytes hash\n     *\n     * shared_ukm_size = 32 stands for post-2018 cipher suites\n     * It means 64 bytes of shared_key, 16 bytes of UKM and either\n     * 64 bytes of hash or 64 bytes of TLSTREE output\n     * */\n\n    switch (data->shared_ukm_size) {\n    case 8:\n        {\n            if (key == NULL) {\n                *keylen = 32;\n                return 1;\n            }\n            EVP_PKEY_get_default_digest_nid(my_key, &dgst_nid);\n            if (dgst_nid == NID_id_GostR3411_2012_512)\n                dgst_nid = NID_id_GostR3411_2012_256;\n\n            *keylen =\n                VKO_compute_key(key,\n                                EC_KEY_get0_public_key(EVP_PKEY_get0(peer_key)),\n                                (EC_KEY *)EVP_PKEY_get0(my_key),\n                                data->shared_ukm, 8, dgst_nid);\n            return (*keylen) ? 1 : 0;\n        }\n        break;\n    case 32:\n        {\n            if (key == NULL) {\n                *keylen = 64;\n                return 1;\n            }\n\n            *keylen = gost_keg(data->shared_ukm, EVP_PKEY_id(my_key),\n                               EC_KEY_get0_public_key(EVP_PKEY_get0(peer_key)),\n                               (EC_KEY *)EVP_PKEY_get0(my_key), key);\n            return (*keylen) ? 1 : 0;\n        }\n\n        break;\n    default:\n        return 0;\n    }\n}\n\n/*\n * Generates ephemeral key based on pubk algorithm computes shared key using\n * VKO and returns filled up GOST_KEY_TRANSPORT structure\n */\n\n/*\n * EVP_PKEY_METHOD callback encrypt\n * Implementation of GOST2001/12 key transport, cryptopro variation\n */\n\nstatic int pkey_GOST_ECcp_encrypt(EVP_PKEY_CTX *pctx, unsigned char *out,\n                           size_t *out_len, const unsigned char *key,\n                           size_t key_len)\n{\n    GOST_KEY_TRANSPORT *gkt = NULL;\n    EVP_PKEY *pubk = EVP_PKEY_CTX_get0_pkey(pctx);\n    struct gost_pmeth_data *data = EVP_PKEY_CTX_get_data(pctx);\n    int pkey_nid = EVP_PKEY_base_id(pubk);\n    ASN1_OBJECT *crypt_params_obj = (pkey_nid == NID_id_GostR3410_2001 || pkey_nid == NID_id_GostR3410_2001DH) ?\n        OBJ_nid2obj(NID_id_Gost28147_89_CryptoPro_A_ParamSet) :\n        OBJ_nid2obj(NID_id_tc26_gost_28147_param_Z);\n    const struct gost_cipher_info *param =\n        get_encryption_params(crypt_params_obj);\n    unsigned char ukm[8], shared_key[32], crypted_key[44];\n    int ret = 0;\n    int key_is_ephemeral = 1;\n    gost_ctx cctx;\n    EVP_PKEY *sec_key = EVP_PKEY_CTX_get0_peerkey(pctx);\n    if (data->shared_ukm_size) {\n        memcpy(ukm, data->shared_ukm, 8);\n    } else {\n        if (RAND_bytes(ukm, 8) <= 0) {\n            GOSTerr(GOST_F_PKEY_GOST_ECCP_ENCRYPT, GOST_R_RNG_ERROR);\n            return 0;\n        }\n    }\n    if (!param)\n        goto err;\n    /* Check for private key in the peer_key of context */\n    if (sec_key) {\n        key_is_ephemeral = 0;\n        if (!gost_get0_priv_key(sec_key)) {\n            GOSTerr(GOST_F_PKEY_GOST_ECCP_ENCRYPT,\n                    GOST_R_NO_PRIVATE_PART_OF_NON_EPHEMERAL_KEYPAIR);\n            goto err;\n        }\n    } else {\n        key_is_ephemeral = 1;\n        if (out) {\n            sec_key = EVP_PKEY_new();\n            if (!EVP_PKEY_assign(sec_key, EVP_PKEY_base_id(pubk), EC_KEY_new())\n                || !EVP_PKEY_copy_parameters(sec_key, pubk)\n                || !gost_ec_keygen(EVP_PKEY_get0(sec_key))) {\n                GOSTerr(GOST_F_PKEY_GOST_ECCP_ENCRYPT,\n                        GOST_R_ERROR_COMPUTING_SHARED_KEY);\n                goto err;\n            }\n        }\n    }\n    if (out) {\n        int dgst_nid = NID_undef;\n        EVP_PKEY_get_default_digest_nid(pubk, &dgst_nid);\n        if (dgst_nid == NID_id_GostR3411_2012_512)\n            dgst_nid = NID_id_GostR3411_2012_256;\n\n        if (!VKO_compute_key(shared_key,\n                             EC_KEY_get0_public_key(EVP_PKEY_get0(pubk)),\n                             EVP_PKEY_get0(sec_key), ukm, 8, dgst_nid)) {\n            GOSTerr(GOST_F_PKEY_GOST_ECCP_ENCRYPT,\n                    GOST_R_ERROR_COMPUTING_SHARED_KEY);\n            goto err;\n        }\n        gost_init(&cctx, param->sblock);\n        keyWrapCryptoPro(&cctx, shared_key, ukm, key, crypted_key);\n    }\n    gkt = GOST_KEY_TRANSPORT_new();\n    if (!gkt) {\n        goto err;\n    }\n    if (!ASN1_OCTET_STRING_set(gkt->key_agreement_info->eph_iv, ukm, 8)) {\n        goto err;\n    }\n    if (!ASN1_OCTET_STRING_set(gkt->key_info->imit, crypted_key + 40, 4)) {\n        goto err;\n    }\n    if (!ASN1_OCTET_STRING_set\n        (gkt->key_info->encrypted_key, crypted_key + 8, 32)) {\n        goto err;\n    }\n    if (key_is_ephemeral) {\n        if (!X509_PUBKEY_set\n            (&gkt->key_agreement_info->ephem_key, out ? sec_key : pubk)) {\n            GOSTerr(GOST_F_PKEY_GOST_ECCP_ENCRYPT,\n                    GOST_R_CANNOT_PACK_EPHEMERAL_KEY);\n            goto err;\n        }\n    }\n    ASN1_OBJECT_free(gkt->key_agreement_info->cipher);\n    gkt->key_agreement_info->cipher = OBJ_nid2obj(param->nid);\n    if (key_is_ephemeral)\n        EVP_PKEY_free(sec_key);\n    if (!key_is_ephemeral) {\n        /* Set control \"public key from client certificate used\" */\n        if (EVP_PKEY_CTX_ctrl(pctx, -1, -1, EVP_PKEY_CTRL_PEER_KEY, 3, NULL)\n            <= 0) {\n            GOSTerr(GOST_F_PKEY_GOST_ECCP_ENCRYPT, GOST_R_CTRL_CALL_FAILED);\n            goto err;\n        }\n    }\n    if ((*out_len = i2d_GOST_KEY_TRANSPORT(gkt, out ? &out : NULL)) > 0)\n        ret = 1;\n    OPENSSL_cleanse(shared_key, sizeof(shared_key));\n    GOST_KEY_TRANSPORT_free(gkt);\n    return ret;\n err:\n    OPENSSL_cleanse(shared_key, sizeof(shared_key));\n    if (key_is_ephemeral)\n        EVP_PKEY_free(sec_key);\n    GOST_KEY_TRANSPORT_free(gkt);\n    return -1;\n}\n\n/*\n * EVP_PKEY_METHOD callback decrypt\n * Implementation of GOST2018 key transport\n */\nstatic int pkey_gost2018_encrypt(EVP_PKEY_CTX *pctx, unsigned char *out,\n                          size_t *out_len, const unsigned char *key,\n                          size_t key_len)\n{\n    PSKeyTransport_gost *pst = NULL;\n    EVP_PKEY *pubk = EVP_PKEY_CTX_get0_pkey(pctx);\n    struct gost_pmeth_data *data = EVP_PKEY_CTX_get_data(pctx);\n    int pkey_nid = EVP_PKEY_base_id(pubk);\n    unsigned char expkeys[64];\n    EVP_PKEY *sec_key = NULL;\n    int ret = 0;\n    int mac_nid = NID_undef;\n    size_t mac_len = 0;\n    int exp_len = 0, iv_len = 0;\n    unsigned char *exp_buf = NULL;\n    int key_is_ephemeral = 0;\n    int res_len = 0;\n\n    switch (data->cipher_nid) {\n    case NID_magma_ctr:\n        mac_nid = NID_magma_mac;\n        mac_len = 8;\n        iv_len = 4;\n        break;\n    case NID_grasshopper_ctr:\n        mac_nid = NID_grasshopper_mac;\n        mac_len = 16;\n        iv_len = 8;\n        break;\n    default:\n        GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, GOST_R_INVALID_CIPHER);\n        return -1;\n        break;\n    }\n    exp_len = key_len + mac_len;\n    exp_buf = OPENSSL_malloc(exp_len);\n    if (!exp_buf) {\n        GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, ERR_R_MALLOC_FAILURE);\n        return -1;\n    }\n\n    sec_key = EVP_PKEY_CTX_get0_peerkey(pctx);\n    if (!sec_key)\n    {\n      sec_key = EVP_PKEY_new();\n      if (sec_key == NULL) {\n        GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, ERR_R_MALLOC_FAILURE );\n        goto err;\n      }\n\n      if (!EVP_PKEY_assign(sec_key, EVP_PKEY_base_id(pubk), EC_KEY_new())\n          || !EVP_PKEY_copy_parameters(sec_key, pubk)\n          || !gost_ec_keygen(EVP_PKEY_get0(sec_key))) {\n        GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT,\n            GOST_R_ERROR_COMPUTING_SHARED_KEY);\n        goto err;\n      }\n      key_is_ephemeral = 1;\n    }\n\n    if (data->shared_ukm_size == 0) {\n        if (RAND_bytes(data->shared_ukm, 32) <= 0) {\n            GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, ERR_R_INTERNAL_ERROR);\n            goto err;\n        }\n        data->shared_ukm_size = 32;\n    }\n\n    if (gost_keg(data->shared_ukm, pkey_nid,\n                 EC_KEY_get0_public_key(EVP_PKEY_get0(pubk)),\n                 EVP_PKEY_get0(sec_key), expkeys) <= 0) {\n        GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT,\n                GOST_R_ERROR_COMPUTING_EXPORT_KEYS);\n        goto err;\n    }\n\n    if (gost_kexp15(key, key_len, data->cipher_nid, expkeys + 32,\n                    mac_nid, expkeys + 0, data->shared_ukm + 24, iv_len,\n                    exp_buf, &exp_len) <= 0) {\n        GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, GOST_R_CANNOT_PACK_EPHEMERAL_KEY);\n        goto err;\n    }\n\n    pst = PSKeyTransport_gost_new();\n    if (!pst) {\n        GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    pst->ukm = ASN1_OCTET_STRING_new();\n    if (pst->ukm == NULL) {\n        GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    if (!ASN1_OCTET_STRING_set(pst->ukm, data->shared_ukm, data->shared_ukm_size)) {\n        GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    if (!ASN1_OCTET_STRING_set(pst->psexp, exp_buf, exp_len)) {\n        GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    if (!X509_PUBKEY_set(&pst->ephem_key, out ? sec_key : pubk)) {\n        GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, GOST_R_CANNOT_PACK_EPHEMERAL_KEY);\n        goto err;\n    }\n\n    res_len = i2d_PSKeyTransport_gost(pst, NULL);\n    if (res_len <= 0) {\n        GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, ERR_R_ASN1_LIB);\n        goto err;\n    }\n\n    if (out == NULL) {\n        *out_len = res_len;\n        ret = 1;\n    } else {\n        if ((size_t)res_len > *out_len) {\n            GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, GOST_R_INVALID_BUFFER_SIZE);\n            goto err;\n        }\n        if ((*out_len = i2d_PSKeyTransport_gost(pst, &out)) > 0)\n            ret = 1;\n        else\n            GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, ERR_R_ASN1_LIB);\n    }\n\n err:\n    OPENSSL_cleanse(expkeys, sizeof(expkeys));\n    if (key_is_ephemeral)\n        EVP_PKEY_free(sec_key);\n\n    PSKeyTransport_gost_free(pst);\n    OPENSSL_free(exp_buf);\n    return ret;\n}\n\nint pkey_gost_encrypt(EVP_PKEY_CTX *pctx, unsigned char *out,\n                      size_t *out_len, const unsigned char *key, size_t key_len)\n{\n  struct gost_pmeth_data *gctx = EVP_PKEY_CTX_get_data(pctx);\n  switch (gctx->cipher_nid)\n  {\n    case NID_id_Gost28147_89:\n    case NID_undef: /* FIXME */\n      return pkey_GOST_ECcp_encrypt(pctx, out, out_len, key, key_len);\n      break;\n    case NID_kuznyechik_ctr:\n    case NID_magma_ctr:\n      return pkey_gost2018_encrypt(pctx, out, out_len, key, key_len);\n      break;\n    default:\n      GOSTerr(GOST_F_PKEY_GOST_ENCRYPT, ERR_R_INTERNAL_ERROR);\n      return -1;\n  }\n}\n\n/*\n * EVP_PKEY_METHOD callback decrypt\n * Implementation of GOST2001/12 key transport, cryptopro variation\n */\nstatic int pkey_GOST_ECcp_decrypt(EVP_PKEY_CTX *pctx, unsigned char *key,\n                           size_t *key_len, const unsigned char *in,\n                           size_t in_len)\n{\n    const unsigned char *p = in;\n    EVP_PKEY *priv = EVP_PKEY_CTX_get0_pkey(pctx);\n    GOST_KEY_TRANSPORT *gkt = NULL;\n    int ret = 0;\n    unsigned char wrappedKey[44];\n    unsigned char sharedKey[32];\n    gost_ctx ctx;\n    const struct gost_cipher_info *param = NULL;\n    EVP_PKEY *eph_key = NULL, *peerkey = NULL;\n    int dgst_nid = NID_undef;\n\n    if (!key) {\n        *key_len = 32;\n        return 1;\n    }\n    gkt = d2i_GOST_KEY_TRANSPORT(NULL, (const unsigned char **)&p, in_len);\n    if (!gkt) {\n        GOSTerr(GOST_F_PKEY_GOST_ECCP_DECRYPT,\n                GOST_R_ERROR_PARSING_KEY_TRANSPORT_INFO);\n        return -1;\n    }\n\n    /* If key transport structure contains public key, use it */\n    eph_key = X509_PUBKEY_get(gkt->key_agreement_info->ephem_key);\n    if (eph_key) {\n        if (EVP_PKEY_derive_set_peer(pctx, eph_key) <= 0) {\n            GOSTerr(GOST_F_PKEY_GOST_ECCP_DECRYPT,\n                    GOST_R_INCOMPATIBLE_PEER_KEY);\n            goto err;\n        }\n    } else {\n        /* Set control \"public key from client certificate used\" */\n        if (EVP_PKEY_CTX_ctrl(pctx, -1, -1, EVP_PKEY_CTRL_PEER_KEY, 3, NULL)\n            <= 0) {\n            GOSTerr(GOST_F_PKEY_GOST_ECCP_DECRYPT, GOST_R_CTRL_CALL_FAILED);\n            goto err;\n        }\n    }\n    peerkey = EVP_PKEY_CTX_get0_peerkey(pctx);\n    if (!peerkey) {\n        GOSTerr(GOST_F_PKEY_GOST_ECCP_DECRYPT, GOST_R_NO_PEER_KEY);\n        goto err;\n    }\n\n    param = get_encryption_params(gkt->key_agreement_info->cipher);\n    if (!param) {\n        goto err;\n    }\n\n    gost_init(&ctx, param->sblock);\n    OPENSSL_assert(gkt->key_agreement_info->eph_iv->length == 8);\n    memcpy(wrappedKey, gkt->key_agreement_info->eph_iv->data, 8);\n    OPENSSL_assert(gkt->key_info->encrypted_key->length == 32);\n    memcpy(wrappedKey + 8, gkt->key_info->encrypted_key->data, 32);\n    OPENSSL_assert(gkt->key_info->imit->length == 4);\n    memcpy(wrappedKey + 40, gkt->key_info->imit->data, 4);\n\n    EVP_PKEY_get_default_digest_nid(priv, &dgst_nid);\n    if (dgst_nid == NID_id_GostR3411_2012_512)\n        dgst_nid = NID_id_GostR3411_2012_256;\n\n    if (!VKO_compute_key(sharedKey,\n                         EC_KEY_get0_public_key(EVP_PKEY_get0(peerkey)),\n                         EVP_PKEY_get0(priv), wrappedKey, 8, dgst_nid)) {\n        GOSTerr(GOST_F_PKEY_GOST_ECCP_DECRYPT,\n                GOST_R_ERROR_COMPUTING_SHARED_KEY);\n        goto err;\n    }\n    if (!keyUnwrapCryptoPro(&ctx, sharedKey, wrappedKey, key)) {\n        GOSTerr(GOST_F_PKEY_GOST_ECCP_DECRYPT,\n                GOST_R_ERROR_COMPUTING_SHARED_KEY);\n        goto err;\n    }\n\n    ret = 1;\n err:\n    OPENSSL_cleanse(sharedKey, sizeof(sharedKey));\n    EVP_PKEY_free(eph_key);\n    GOST_KEY_TRANSPORT_free(gkt);\n    return ret;\n}\n\n/*\n * EVP_PKEY_METHOD callback decrypt\n * Implementation of GOST2018 key transport\n */\nstatic int pkey_gost2018_decrypt(EVP_PKEY_CTX *pctx, unsigned char *key,\n                          size_t *key_len, const unsigned char *in,\n                          size_t in_len)\n{\n    const unsigned char *p = in;\n    struct gost_pmeth_data *data;\n    EVP_PKEY *priv;\n    PSKeyTransport_gost *pst = NULL;\n    int ret = 0;\n    unsigned char expkeys[64];\n    EVP_PKEY *eph_key = NULL;\n    int pkey_nid;\n    int mac_nid = NID_undef;\n    int iv_len = 0;\n\n    if (!(data = EVP_PKEY_CTX_get_data(pctx)) ||\n        !(priv = EVP_PKEY_CTX_get0_pkey(pctx))) {\n       GOSTerr(GOST_F_PKEY_GOST2018_DECRYPT, GOST_R_ERROR_COMPUTING_EXPORT_KEYS);\n       ret = 0;\n       goto err;\n    }\n    pkey_nid = EVP_PKEY_base_id(priv);\n\n    switch (data->cipher_nid) {\n    case NID_magma_ctr:\n        mac_nid = NID_magma_mac;\n        iv_len = 4;\n        break;\n    case NID_grasshopper_ctr:\n        mac_nid = NID_grasshopper_mac;\n        iv_len = 8;\n        break;\n    default:\n        GOSTerr(GOST_F_PKEY_GOST2018_DECRYPT, GOST_R_INVALID_CIPHER);\n        return -1;\n        break;\n    }\n    if (!key) {\n        *key_len = 32;\n        return 1;\n    }\n\n    pst = d2i_PSKeyTransport_gost(NULL, (const unsigned char **)&p, in_len);\n    if (!pst) {\n        GOSTerr(GOST_F_PKEY_GOST2018_DECRYPT,\n                GOST_R_ERROR_PARSING_KEY_TRANSPORT_INFO);\n        return -1;\n    }\n\n    eph_key = X509_PUBKEY_get(pst->ephem_key);\n/*\n * TODO beldmit\n   1.  Checks the next three conditions fulfilling and terminates the\n   connection with fatal error if not.\n\n   o  Q_eph is on the same curve as server public key;\n\n   o  Q_eph is not equal to zero point;\n\n   o  q * Q_eph is not equal to zero point.\n*/\n    if (eph_key == NULL) {\n       GOSTerr(GOST_F_PKEY_GOST2018_DECRYPT,\n               GOST_R_ERROR_COMPUTING_EXPORT_KEYS);\n       ret = 0;\n       goto err;\n    }\n  \n    if (data->shared_ukm_size == 0 && pst->ukm != NULL) {\n        if (EVP_PKEY_CTX_ctrl(pctx, -1, -1, EVP_PKEY_CTRL_SET_IV,\n        ASN1_STRING_length(pst->ukm), (void *)ASN1_STRING_get0_data(pst->ukm)) < 0) {\n            GOSTerr(GOST_F_PKEY_GOST2018_DECRYPT, GOST_R_UKM_NOT_SET);\n            goto err;\n        }\n    }\n\n    if (gost_keg(data->shared_ukm, pkey_nid,\n                 EC_KEY_get0_public_key(EVP_PKEY_get0(eph_key)),\n                 EVP_PKEY_get0(priv), expkeys) <= 0) {\n        GOSTerr(GOST_F_PKEY_GOST2018_DECRYPT,\n                GOST_R_ERROR_COMPUTING_EXPORT_KEYS);\n        goto err;\n    }\n\n    if (gost_kimp15(ASN1_STRING_get0_data(pst->psexp),\n                    ASN1_STRING_length(pst->psexp), data->cipher_nid,\n                    expkeys + 32, mac_nid, expkeys + 0, data->shared_ukm + 24,\n                    iv_len, key) <= 0) {\n        GOSTerr(GOST_F_PKEY_GOST2018_DECRYPT, GOST_R_CANNOT_UNPACK_EPHEMERAL_KEY);\n        goto err;\n    }\n\n    ret = 1;\n err:\n    OPENSSL_cleanse(expkeys, sizeof(expkeys));\n    EVP_PKEY_free(eph_key);\n    PSKeyTransport_gost_free(pst);\n    return ret;\n}\n\nint pkey_gost_decrypt(EVP_PKEY_CTX *pctx, unsigned char *key,\n                      size_t *key_len, const unsigned char *in, size_t in_len)\n{\n    struct gost_pmeth_data *gctx = EVP_PKEY_CTX_get_data(pctx);\n    switch (gctx->cipher_nid)\n    {\n        case NID_id_Gost28147_89:\n        case NID_undef: /* FIXME */\n            return pkey_GOST_ECcp_decrypt(pctx, key, key_len, in, in_len);\n        case NID_kuznyechik_ctr:\n        case NID_magma_ctr:\n            return pkey_gost2018_decrypt(pctx, key, key_len, in, in_len);\n        default:\n      GOSTerr(GOST_F_PKEY_GOST_DECRYPT, ERR_R_INTERNAL_ERROR);\n      return -1;\n    }\n}\n/* vim: set expandtab cinoptions=\\:0,l1,t0,g0,(0 sw=4 : */\n"], "fixing_code": ["/**********************************************************************\n *                        gost_ec_keyx.c                              *\n *                                                                    *\n *             Copyright (c) 2005-2013 Cryptocom LTD                  *\n *   Copyright (c) 2018,2020 Dmitry Belyavskiy <beldmit@gmail.com>    *\n *   Copyright (c) 2020 Billy Brumley <bbrumley@gmail.com>            *\n *                                                                    *\n *         This file is distributed under the same license as OpenSSL *\n *                                                                    *\n *   VK0 R 50.1.113-2016 / RFC 7836                                   *\n *   KEG R 1323565.1.020-2018                                         *\n *   VK0 34.10-2001 key exchange and GOST R 34.10-2001 (RFC 4357)     *\n *   based PKCS7/SMIME support                                        *\n *          Requires OpenSSL 0.9.9 for compilation                    *\n **********************************************************************/\n#include <openssl/evp.h>\n#include <openssl/err.h>\n#include <openssl/rand.h>\n#include <string.h>\n#include <openssl/objects.h>\n#include \"gost89.h\"\n#include \"e_gost_err.h\"\n#include \"gost_keywrap.h\"\n#include \"gost_lcl.h\"\n\n/* Implementation of CryptoPro VKO 34.10-2001/2012 algorithm */\nint VKO_compute_key(unsigned char *shared_key,\n                    const EC_POINT *pub_key, const EC_KEY *priv_key,\n                    const unsigned char *ukm, const size_t ukm_size,\n                    const int vko_dgst_nid)\n{\n    unsigned char *databuf = NULL;\n    BIGNUM *scalar = NULL, *X = NULL, *Y = NULL;\n    const EC_GROUP *grp = NULL;\n    EC_POINT *pnt = NULL;\n    BN_CTX *ctx = NULL;\n    EVP_MD_CTX *mdctx = NULL;\n    const EVP_MD *md = NULL;\n    int buf_len, half_len;\n    int ret = 0;\n\n    if ((ctx = BN_CTX_secure_new()) == NULL) {\n        GOSTerr(GOST_F_VKO_COMPUTE_KEY, ERR_R_MALLOC_FAILURE);\n        return 0;\n    }\n    BN_CTX_start(ctx);\n\n    md = EVP_get_digestbynid(vko_dgst_nid);\n    if (!md) {\n        GOSTerr(GOST_F_VKO_COMPUTE_KEY, GOST_R_INVALID_DIGEST_TYPE);\n        goto err;\n    }\n\n    grp = EC_KEY_get0_group(priv_key);\n    scalar = BN_CTX_get(ctx);\n    X = BN_CTX_get(ctx);\n\n    if ((Y = BN_CTX_get(ctx)) == NULL\n        || (pnt = EC_POINT_new(grp)) == NULL\n        || BN_lebin2bn(ukm, ukm_size, scalar) == NULL\n        || !BN_mod_mul(scalar, scalar, EC_KEY_get0_private_key(priv_key),\n                       EC_GROUP_get0_order(grp), ctx))\n        goto err;\n\n#if 0\n    /*-\n     * These two curves have cofactor 4; the rest have cofactor 1.\n     * But currently gost_ec_point_mul takes care of the cofactor clearing,\n     * hence this code is not needed.\n     */\n    switch (EC_GROUP_get_curve_name(grp)) {\n        case NID_id_tc26_gost_3410_2012_256_paramSetA:\n        case NID_id_tc26_gost_3410_2012_512_paramSetC:\n            if (!BN_lshift(scalar, scalar, 2))\n                goto err;\n            break;\n    }\n#endif\n\n    if (!gost_ec_point_mul(grp, pnt, NULL, pub_key, scalar, ctx)) {\n        GOSTerr(GOST_F_VKO_COMPUTE_KEY, GOST_R_ERROR_POINT_MUL);\n        goto err;\n    }\n    if (!EC_POINT_get_affine_coordinates(grp, pnt, X, Y, ctx)) {\n        GOSTerr(GOST_F_VKO_COMPUTE_KEY, ERR_R_EC_LIB);\n        goto err;\n    }\n\n    half_len = BN_num_bytes(EC_GROUP_get0_field(grp));\n    buf_len = 2 * half_len;\n    if ((databuf = OPENSSL_malloc(buf_len)) == NULL) {\n        GOSTerr(GOST_F_VKO_COMPUTE_KEY, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    /*\n     * Serialize elliptic curve point same way as we do it when saving key\n     */\n    if (BN_bn2lebinpad(X, databuf, half_len) != half_len\n        || BN_bn2lebinpad(Y, databuf + half_len, half_len) != half_len)\n        goto err;\n\n    if ((mdctx = EVP_MD_CTX_new()) == NULL) {\n        GOSTerr(GOST_F_VKO_COMPUTE_KEY, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    if (EVP_MD_CTX_init(mdctx) == 0\n        || EVP_DigestInit_ex(mdctx, md, NULL) == 0\n        || EVP_DigestUpdate(mdctx, databuf, buf_len) == 0\n        || EVP_DigestFinal_ex(mdctx, shared_key, NULL) == 0) {\n        GOSTerr(GOST_F_VKO_COMPUTE_KEY, ERR_R_EVP_LIB);\n        goto err;\n    }\n\n    ret = (EVP_MD_size(md) > 0) ? EVP_MD_size(md) : 0;\n\n err:\n    BN_CTX_end(ctx);\n    BN_CTX_free(ctx);\n    EC_POINT_free(pnt);\n    EVP_MD_CTX_free(mdctx);\n    OPENSSL_free(databuf);\n\n    return ret;\n}\n\n/*\n * KEG Algorithm described in R 1323565.1.020-2018 6.4.5.1.\n * keyout expected to be 64 bytes\n * */\nstatic int gost_keg(const unsigned char *ukm_source, int pkey_nid,\n                    const EC_POINT *pub_key, const EC_KEY *priv_key,\n                    unsigned char *keyout)\n{\n/* Adjust UKM */\n    unsigned char real_ukm[16];\n    size_t keylen = 0;\n\n    memset(real_ukm, 0, 16);\n    if (memcmp(ukm_source, real_ukm, 16) == 0)\n        real_ukm[15] = 1;\n    else {\n        memcpy(real_ukm, ukm_source, 16);\n        BUF_reverse(real_ukm, NULL, 16);\n    }\n\n    switch (pkey_nid) {\n    case NID_id_GostR3410_2012_512:\n        keylen =\n            VKO_compute_key(keyout, pub_key, priv_key, real_ukm, 16,\n                            NID_id_GostR3411_2012_512);\n        return (keylen) ? keylen : 0;\n        break;\n\n    case NID_id_GostR3410_2012_256:\n        {\n            unsigned char tmpkey[32];\n            keylen =\n              VKO_compute_key(tmpkey, pub_key, priv_key, real_ukm, 16,\n                  NID_id_GostR3411_2012_256);\n\n            if (keylen == 0)\n                return 0;\n\n            if (gost_kdftree2012_256\n                (keyout, 64, tmpkey, 32, (const unsigned char *)\"kdf tree\", 8,\n                 ukm_source + 16, 8, 1) > 0)\n                keylen = 64;\n            else\n                keylen = 0;\n\n            OPENSSL_cleanse(tmpkey, 32);\n            return (keylen) ? keylen : 0;\n        }\n    default:\n        return 0;\n    }\n}\n\n/*\n * EVP_PKEY_METHOD callback derive.\n * Implements VKO R 34.10-2001/2012 algorithms\n */\n/*\n * Backend for EVP_PKEY_derive()\n * It have KEG mode (default) and VKO mode (enable by EVP_PKEY_CTRL_SET_VKO).\n */\nint pkey_gost_ec_derive(EVP_PKEY_CTX *ctx, unsigned char *key, size_t *keylen)\n{\n    /*\n     * Public key of peer in the ctx field peerkey\n     * Our private key in the ctx pkey\n     * ukm is in the algorithm specific context data\n     */\n    EVP_PKEY *my_key = EVP_PKEY_CTX_get0_pkey(ctx);\n    EVP_PKEY *peer_key = EVP_PKEY_CTX_get0_peerkey(ctx);\n    struct gost_pmeth_data *data = EVP_PKEY_CTX_get_data(ctx);\n    int dgst_nid = NID_undef;\n\n    if (!data || data->shared_ukm_size == 0) {\n        GOSTerr(GOST_F_PKEY_GOST_EC_DERIVE, GOST_R_UKM_NOT_SET);\n        return 0;\n    }\n\n    /* VKO */\n    if (data->vko_dgst_nid) {\n        if (!key) {\n            *keylen = data->vko_dgst_nid == NID_id_GostR3411_2012_256? 32 : 64;\n            return 1;\n        }\n        *keylen = VKO_compute_key(key,\n                                  EC_KEY_get0_public_key(EVP_PKEY_get0(peer_key)),\n                                  (EC_KEY *)EVP_PKEY_get0(my_key),\n                                  data->shared_ukm, data->shared_ukm_size,\n                                  data->vko_dgst_nid);\n        return (*keylen) ? 1 : 0;\n    }\n\n    /*\n     * shared_ukm_size = 8 stands for pre-2018 cipher suites\n     * It means 32 bytes of key length, 8 byte UKM, 32-bytes hash\n     *\n     * shared_ukm_size = 32 stands for post-2018 cipher suites\n     * It means 64 bytes of shared_key, 16 bytes of UKM and either\n     * 64 bytes of hash or 64 bytes of TLSTREE output\n     * */\n\n    switch (data->shared_ukm_size) {\n    case 8:\n        {\n            if (key == NULL) {\n                *keylen = 32;\n                return 1;\n            }\n            EVP_PKEY_get_default_digest_nid(my_key, &dgst_nid);\n            if (dgst_nid == NID_id_GostR3411_2012_512)\n                dgst_nid = NID_id_GostR3411_2012_256;\n\n            *keylen =\n                VKO_compute_key(key,\n                                EC_KEY_get0_public_key(EVP_PKEY_get0(peer_key)),\n                                (EC_KEY *)EVP_PKEY_get0(my_key),\n                                data->shared_ukm, 8, dgst_nid);\n            return (*keylen) ? 1 : 0;\n        }\n        break;\n    case 32:\n        {\n            if (key == NULL) {\n                *keylen = 64;\n                return 1;\n            }\n\n            *keylen = gost_keg(data->shared_ukm, EVP_PKEY_id(my_key),\n                               EC_KEY_get0_public_key(EVP_PKEY_get0(peer_key)),\n                               (EC_KEY *)EVP_PKEY_get0(my_key), key);\n            return (*keylen) ? 1 : 0;\n        }\n\n        break;\n    default:\n        return 0;\n    }\n}\n\n/*\n * Generates ephemeral key based on pubk algorithm computes shared key using\n * VKO and returns filled up GOST_KEY_TRANSPORT structure\n */\n\n/*\n * EVP_PKEY_METHOD callback encrypt\n * Implementation of GOST2001/12 key transport, cryptopro variation\n */\n\nstatic int pkey_GOST_ECcp_encrypt(EVP_PKEY_CTX *pctx, unsigned char *out,\n                           size_t *out_len, const unsigned char *key,\n                           size_t key_len)\n{\n    GOST_KEY_TRANSPORT *gkt = NULL;\n    EVP_PKEY *pubk = EVP_PKEY_CTX_get0_pkey(pctx);\n    struct gost_pmeth_data *data = EVP_PKEY_CTX_get_data(pctx);\n    int pkey_nid = EVP_PKEY_base_id(pubk);\n    ASN1_OBJECT *crypt_params_obj = (pkey_nid == NID_id_GostR3410_2001 || pkey_nid == NID_id_GostR3410_2001DH) ?\n        OBJ_nid2obj(NID_id_Gost28147_89_CryptoPro_A_ParamSet) :\n        OBJ_nid2obj(NID_id_tc26_gost_28147_param_Z);\n    const struct gost_cipher_info *param =\n        get_encryption_params(crypt_params_obj);\n    unsigned char ukm[8], shared_key[32], crypted_key[44];\n    int ret = 0;\n    int key_is_ephemeral = 1;\n    gost_ctx cctx;\n    EVP_PKEY *sec_key = EVP_PKEY_CTX_get0_peerkey(pctx);\n    int res_len = 0;\n\n    if (data->shared_ukm_size) {\n        memcpy(ukm, data->shared_ukm, 8);\n    } else {\n        if (RAND_bytes(ukm, 8) <= 0) {\n            GOSTerr(GOST_F_PKEY_GOST_ECCP_ENCRYPT, GOST_R_RNG_ERROR);\n            return 0;\n        }\n    }\n    if (!param)\n        goto err;\n    /* Check for private key in the peer_key of context */\n    if (sec_key) {\n        key_is_ephemeral = 0;\n        if (!gost_get0_priv_key(sec_key)) {\n            GOSTerr(GOST_F_PKEY_GOST_ECCP_ENCRYPT,\n                    GOST_R_NO_PRIVATE_PART_OF_NON_EPHEMERAL_KEYPAIR);\n            goto err;\n        }\n    } else {\n        key_is_ephemeral = 1;\n        if (out) {\n            sec_key = EVP_PKEY_new();\n            if (!EVP_PKEY_assign(sec_key, EVP_PKEY_base_id(pubk), EC_KEY_new())\n                || !EVP_PKEY_copy_parameters(sec_key, pubk)\n                || !gost_ec_keygen(EVP_PKEY_get0(sec_key))) {\n                GOSTerr(GOST_F_PKEY_GOST_ECCP_ENCRYPT,\n                        GOST_R_ERROR_COMPUTING_SHARED_KEY);\n                goto err;\n            }\n        }\n    }\n    if (out) {\n        int dgst_nid = NID_undef;\n        EVP_PKEY_get_default_digest_nid(pubk, &dgst_nid);\n        if (dgst_nid == NID_id_GostR3411_2012_512)\n            dgst_nid = NID_id_GostR3411_2012_256;\n\n        if (!VKO_compute_key(shared_key,\n                             EC_KEY_get0_public_key(EVP_PKEY_get0(pubk)),\n                             EVP_PKEY_get0(sec_key), ukm, 8, dgst_nid)) {\n            GOSTerr(GOST_F_PKEY_GOST_ECCP_ENCRYPT,\n                    GOST_R_ERROR_COMPUTING_SHARED_KEY);\n            goto err;\n        }\n        gost_init(&cctx, param->sblock);\n        keyWrapCryptoPro(&cctx, shared_key, ukm, key, crypted_key);\n    }\n    gkt = GOST_KEY_TRANSPORT_new();\n    if (!gkt) {\n        goto err;\n    }\n    if (!ASN1_OCTET_STRING_set(gkt->key_agreement_info->eph_iv, ukm, 8)) {\n        goto err;\n    }\n    if (!ASN1_OCTET_STRING_set(gkt->key_info->imit, crypted_key + 40, 4)) {\n        goto err;\n    }\n    if (!ASN1_OCTET_STRING_set\n        (gkt->key_info->encrypted_key, crypted_key + 8, 32)) {\n        goto err;\n    }\n    if (key_is_ephemeral) {\n        if (!X509_PUBKEY_set\n            (&gkt->key_agreement_info->ephem_key, out ? sec_key : pubk)) {\n            GOSTerr(GOST_F_PKEY_GOST_ECCP_ENCRYPT,\n                    GOST_R_CANNOT_PACK_EPHEMERAL_KEY);\n            goto err;\n        }\n    }\n    ASN1_OBJECT_free(gkt->key_agreement_info->cipher);\n    gkt->key_agreement_info->cipher = OBJ_nid2obj(param->nid);\n    if (key_is_ephemeral)\n        EVP_PKEY_free(sec_key);\n    if (!key_is_ephemeral) {\n        /* Set control \"public key from client certificate used\" */\n        if (EVP_PKEY_CTX_ctrl(pctx, -1, -1, EVP_PKEY_CTRL_PEER_KEY, 3, NULL)\n            <= 0) {\n            GOSTerr(GOST_F_PKEY_GOST_ECCP_ENCRYPT, GOST_R_CTRL_CALL_FAILED);\n            goto err;\n        }\n    }\n    res_len = i2d_GOST_KEY_TRANSPORT(gkt, NULL);\n    if (res_len <= 0) {\n        GOSTerr(GOST_F_PKEY_GOST_ECCP_ENCRYPT, ERR_R_ASN1_LIB);\n        goto err;\n    }\n\n    if (out == NULL) {\n        *out_len = res_len;\n        ret = 1;\n    } else {\n        if ((size_t)res_len > *out_len) {\n            GOSTerr(GOST_F_PKEY_GOST_ECCP_ENCRYPT, GOST_R_INVALID_BUFFER_SIZE);\n            goto err;\n        }\n        if ((*out_len = i2d_GOST_KEY_TRANSPORT(gkt, &out)) > 0)\n            ret = 1;\n        else\n            GOSTerr(GOST_F_PKEY_GOST_ECCP_ENCRYPT, ERR_R_ASN1_LIB);\n    }\n\n    OPENSSL_cleanse(shared_key, sizeof(shared_key));\n    GOST_KEY_TRANSPORT_free(gkt);\n    return ret;\n err:\n    OPENSSL_cleanse(shared_key, sizeof(shared_key));\n    if (key_is_ephemeral)\n        EVP_PKEY_free(sec_key);\n    GOST_KEY_TRANSPORT_free(gkt);\n    return -1;\n}\n\n/*\n * EVP_PKEY_METHOD callback decrypt\n * Implementation of GOST2018 key transport\n */\nstatic int pkey_gost2018_encrypt(EVP_PKEY_CTX *pctx, unsigned char *out,\n                          size_t *out_len, const unsigned char *key,\n                          size_t key_len)\n{\n    PSKeyTransport_gost *pst = NULL;\n    EVP_PKEY *pubk = EVP_PKEY_CTX_get0_pkey(pctx);\n    struct gost_pmeth_data *data = EVP_PKEY_CTX_get_data(pctx);\n    int pkey_nid = EVP_PKEY_base_id(pubk);\n    unsigned char expkeys[64];\n    EVP_PKEY *sec_key = NULL;\n    int ret = 0;\n    int mac_nid = NID_undef;\n    size_t mac_len = 0;\n    int exp_len = 0, iv_len = 0;\n    unsigned char *exp_buf = NULL;\n    int key_is_ephemeral = 0;\n    int res_len = 0;\n\n    switch (data->cipher_nid) {\n    case NID_magma_ctr:\n        mac_nid = NID_magma_mac;\n        mac_len = 8;\n        iv_len = 4;\n        break;\n    case NID_grasshopper_ctr:\n        mac_nid = NID_grasshopper_mac;\n        mac_len = 16;\n        iv_len = 8;\n        break;\n    default:\n        GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, GOST_R_INVALID_CIPHER);\n        return -1;\n        break;\n    }\n    exp_len = key_len + mac_len;\n    exp_buf = OPENSSL_malloc(exp_len);\n    if (!exp_buf) {\n        GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, ERR_R_MALLOC_FAILURE);\n        return -1;\n    }\n\n    sec_key = EVP_PKEY_CTX_get0_peerkey(pctx);\n    if (!sec_key)\n    {\n      sec_key = EVP_PKEY_new();\n      if (sec_key == NULL) {\n        GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, ERR_R_MALLOC_FAILURE );\n        goto err;\n      }\n\n      if (!EVP_PKEY_assign(sec_key, EVP_PKEY_base_id(pubk), EC_KEY_new())\n          || !EVP_PKEY_copy_parameters(sec_key, pubk)\n          || !gost_ec_keygen(EVP_PKEY_get0(sec_key))) {\n        GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT,\n            GOST_R_ERROR_COMPUTING_SHARED_KEY);\n        goto err;\n      }\n      key_is_ephemeral = 1;\n    }\n\n    if (data->shared_ukm_size == 0) {\n        if (RAND_bytes(data->shared_ukm, 32) <= 0) {\n            GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, ERR_R_INTERNAL_ERROR);\n            goto err;\n        }\n        data->shared_ukm_size = 32;\n    }\n\n    if (gost_keg(data->shared_ukm, pkey_nid,\n                 EC_KEY_get0_public_key(EVP_PKEY_get0(pubk)),\n                 EVP_PKEY_get0(sec_key), expkeys) <= 0) {\n        GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT,\n                GOST_R_ERROR_COMPUTING_EXPORT_KEYS);\n        goto err;\n    }\n\n    if (gost_kexp15(key, key_len, data->cipher_nid, expkeys + 32,\n                    mac_nid, expkeys + 0, data->shared_ukm + 24, iv_len,\n                    exp_buf, &exp_len) <= 0) {\n        GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, GOST_R_CANNOT_PACK_EPHEMERAL_KEY);\n        goto err;\n    }\n\n    pst = PSKeyTransport_gost_new();\n    if (!pst) {\n        GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    pst->ukm = ASN1_OCTET_STRING_new();\n    if (pst->ukm == NULL) {\n        GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    if (!ASN1_OCTET_STRING_set(pst->ukm, data->shared_ukm, data->shared_ukm_size)) {\n        GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    if (!ASN1_OCTET_STRING_set(pst->psexp, exp_buf, exp_len)) {\n        GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    if (!X509_PUBKEY_set(&pst->ephem_key, out ? sec_key : pubk)) {\n        GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, GOST_R_CANNOT_PACK_EPHEMERAL_KEY);\n        goto err;\n    }\n\n    res_len = i2d_PSKeyTransport_gost(pst, NULL);\n    if (res_len <= 0) {\n        GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, ERR_R_ASN1_LIB);\n        goto err;\n    }\n\n    if (out == NULL) {\n        *out_len = res_len;\n        ret = 1;\n    } else {\n        if ((size_t)res_len > *out_len) {\n            GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, GOST_R_INVALID_BUFFER_SIZE);\n            goto err;\n        }\n        if ((*out_len = i2d_PSKeyTransport_gost(pst, &out)) > 0)\n            ret = 1;\n        else\n            GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, ERR_R_ASN1_LIB);\n    }\n\n err:\n    OPENSSL_cleanse(expkeys, sizeof(expkeys));\n    if (key_is_ephemeral)\n        EVP_PKEY_free(sec_key);\n\n    PSKeyTransport_gost_free(pst);\n    OPENSSL_free(exp_buf);\n    return ret;\n}\n\nint pkey_gost_encrypt(EVP_PKEY_CTX *pctx, unsigned char *out,\n                      size_t *out_len, const unsigned char *key, size_t key_len)\n{\n  struct gost_pmeth_data *gctx = EVP_PKEY_CTX_get_data(pctx);\n  switch (gctx->cipher_nid)\n  {\n    case NID_id_Gost28147_89:\n    case NID_undef: /* FIXME */\n      return pkey_GOST_ECcp_encrypt(pctx, out, out_len, key, key_len);\n      break;\n    case NID_kuznyechik_ctr:\n    case NID_magma_ctr:\n      return pkey_gost2018_encrypt(pctx, out, out_len, key, key_len);\n      break;\n    default:\n      GOSTerr(GOST_F_PKEY_GOST_ENCRYPT, ERR_R_INTERNAL_ERROR);\n      return -1;\n  }\n}\n\n/*\n * EVP_PKEY_METHOD callback decrypt\n * Implementation of GOST2001/12 key transport, cryptopro variation\n */\nstatic int pkey_GOST_ECcp_decrypt(EVP_PKEY_CTX *pctx, unsigned char *key,\n                           size_t *key_len, const unsigned char *in,\n                           size_t in_len)\n{\n    const unsigned char *p = in;\n    EVP_PKEY *priv = EVP_PKEY_CTX_get0_pkey(pctx);\n    GOST_KEY_TRANSPORT *gkt = NULL;\n    int ret = 0;\n    unsigned char wrappedKey[44];\n    unsigned char sharedKey[32];\n    gost_ctx ctx;\n    const struct gost_cipher_info *param = NULL;\n    EVP_PKEY *eph_key = NULL, *peerkey = NULL;\n    int dgst_nid = NID_undef;\n\n    if (!key) {\n        *key_len = 32;\n        return 1;\n    }\n    gkt = d2i_GOST_KEY_TRANSPORT(NULL, (const unsigned char **)&p, in_len);\n    if (!gkt) {\n        GOSTerr(GOST_F_PKEY_GOST_ECCP_DECRYPT,\n                GOST_R_ERROR_PARSING_KEY_TRANSPORT_INFO);\n        return -1;\n    }\n\n    /* If key transport structure contains public key, use it */\n    eph_key = X509_PUBKEY_get(gkt->key_agreement_info->ephem_key);\n    if (eph_key) {\n        if (EVP_PKEY_derive_set_peer(pctx, eph_key) <= 0) {\n            GOSTerr(GOST_F_PKEY_GOST_ECCP_DECRYPT,\n                    GOST_R_INCOMPATIBLE_PEER_KEY);\n            goto err;\n        }\n    } else {\n        /* Set control \"public key from client certificate used\" */\n        if (EVP_PKEY_CTX_ctrl(pctx, -1, -1, EVP_PKEY_CTRL_PEER_KEY, 3, NULL)\n            <= 0) {\n            GOSTerr(GOST_F_PKEY_GOST_ECCP_DECRYPT, GOST_R_CTRL_CALL_FAILED);\n            goto err;\n        }\n    }\n    peerkey = EVP_PKEY_CTX_get0_peerkey(pctx);\n    if (!peerkey) {\n        GOSTerr(GOST_F_PKEY_GOST_ECCP_DECRYPT, GOST_R_NO_PEER_KEY);\n        goto err;\n    }\n\n    param = get_encryption_params(gkt->key_agreement_info->cipher);\n    if (!param) {\n        goto err;\n    }\n\n    gost_init(&ctx, param->sblock);\n    OPENSSL_assert(gkt->key_agreement_info->eph_iv->length == 8);\n    memcpy(wrappedKey, gkt->key_agreement_info->eph_iv->data, 8);\n    OPENSSL_assert(gkt->key_info->encrypted_key->length == 32);\n    memcpy(wrappedKey + 8, gkt->key_info->encrypted_key->data, 32);\n    OPENSSL_assert(gkt->key_info->imit->length == 4);\n    memcpy(wrappedKey + 40, gkt->key_info->imit->data, 4);\n\n    EVP_PKEY_get_default_digest_nid(priv, &dgst_nid);\n    if (dgst_nid == NID_id_GostR3411_2012_512)\n        dgst_nid = NID_id_GostR3411_2012_256;\n\n    if (!VKO_compute_key(sharedKey,\n                         EC_KEY_get0_public_key(EVP_PKEY_get0(peerkey)),\n                         EVP_PKEY_get0(priv), wrappedKey, 8, dgst_nid)) {\n        GOSTerr(GOST_F_PKEY_GOST_ECCP_DECRYPT,\n                GOST_R_ERROR_COMPUTING_SHARED_KEY);\n        goto err;\n    }\n    if (!keyUnwrapCryptoPro(&ctx, sharedKey, wrappedKey, key)) {\n        GOSTerr(GOST_F_PKEY_GOST_ECCP_DECRYPT,\n                GOST_R_ERROR_COMPUTING_SHARED_KEY);\n        goto err;\n    }\n\n    ret = 1;\n err:\n    OPENSSL_cleanse(sharedKey, sizeof(sharedKey));\n    EVP_PKEY_free(eph_key);\n    GOST_KEY_TRANSPORT_free(gkt);\n    return ret;\n}\n\n/*\n * EVP_PKEY_METHOD callback decrypt\n * Implementation of GOST2018 key transport\n */\nstatic int pkey_gost2018_decrypt(EVP_PKEY_CTX *pctx, unsigned char *key,\n                          size_t *key_len, const unsigned char *in,\n                          size_t in_len)\n{\n    const unsigned char *p = in;\n    struct gost_pmeth_data *data;\n    EVP_PKEY *priv;\n    PSKeyTransport_gost *pst = NULL;\n    int ret = 0;\n    unsigned char expkeys[64];\n    EVP_PKEY *eph_key = NULL;\n    int pkey_nid;\n    int mac_nid = NID_undef;\n    int iv_len = 0;\n\n    if (!(data = EVP_PKEY_CTX_get_data(pctx)) ||\n        !(priv = EVP_PKEY_CTX_get0_pkey(pctx))) {\n       GOSTerr(GOST_F_PKEY_GOST2018_DECRYPT, GOST_R_ERROR_COMPUTING_EXPORT_KEYS);\n       ret = 0;\n       goto err;\n    }\n    pkey_nid = EVP_PKEY_base_id(priv);\n\n    switch (data->cipher_nid) {\n    case NID_magma_ctr:\n        mac_nid = NID_magma_mac;\n        iv_len = 4;\n        break;\n    case NID_grasshopper_ctr:\n        mac_nid = NID_grasshopper_mac;\n        iv_len = 8;\n        break;\n    default:\n        GOSTerr(GOST_F_PKEY_GOST2018_DECRYPT, GOST_R_INVALID_CIPHER);\n        return -1;\n        break;\n    }\n    if (!key) {\n        *key_len = 32;\n        return 1;\n    }\n\n    pst = d2i_PSKeyTransport_gost(NULL, (const unsigned char **)&p, in_len);\n    if (!pst) {\n        GOSTerr(GOST_F_PKEY_GOST2018_DECRYPT,\n                GOST_R_ERROR_PARSING_KEY_TRANSPORT_INFO);\n        return -1;\n    }\n\n    eph_key = X509_PUBKEY_get(pst->ephem_key);\n/*\n * TODO beldmit\n   1.  Checks the next three conditions fulfilling and terminates the\n   connection with fatal error if not.\n\n   o  Q_eph is on the same curve as server public key;\n\n   o  Q_eph is not equal to zero point;\n\n   o  q * Q_eph is not equal to zero point.\n*/\n    if (eph_key == NULL) {\n       GOSTerr(GOST_F_PKEY_GOST2018_DECRYPT,\n               GOST_R_ERROR_COMPUTING_EXPORT_KEYS);\n       ret = 0;\n       goto err;\n    }\n  \n    if (data->shared_ukm_size == 0 && pst->ukm != NULL) {\n        if (EVP_PKEY_CTX_ctrl(pctx, -1, -1, EVP_PKEY_CTRL_SET_IV,\n        ASN1_STRING_length(pst->ukm), (void *)ASN1_STRING_get0_data(pst->ukm)) < 0) {\n            GOSTerr(GOST_F_PKEY_GOST2018_DECRYPT, GOST_R_UKM_NOT_SET);\n            goto err;\n        }\n    }\n\n    if (gost_keg(data->shared_ukm, pkey_nid,\n                 EC_KEY_get0_public_key(EVP_PKEY_get0(eph_key)),\n                 EVP_PKEY_get0(priv), expkeys) <= 0) {\n        GOSTerr(GOST_F_PKEY_GOST2018_DECRYPT,\n                GOST_R_ERROR_COMPUTING_EXPORT_KEYS);\n        goto err;\n    }\n\n    if (gost_kimp15(ASN1_STRING_get0_data(pst->psexp),\n                    ASN1_STRING_length(pst->psexp), data->cipher_nid,\n                    expkeys + 32, mac_nid, expkeys + 0, data->shared_ukm + 24,\n                    iv_len, key) <= 0) {\n        GOSTerr(GOST_F_PKEY_GOST2018_DECRYPT, GOST_R_CANNOT_UNPACK_EPHEMERAL_KEY);\n        goto err;\n    }\n\n    ret = 1;\n err:\n    OPENSSL_cleanse(expkeys, sizeof(expkeys));\n    EVP_PKEY_free(eph_key);\n    PSKeyTransport_gost_free(pst);\n    return ret;\n}\n\nint pkey_gost_decrypt(EVP_PKEY_CTX *pctx, unsigned char *key,\n                      size_t *key_len, const unsigned char *in, size_t in_len)\n{\n    struct gost_pmeth_data *gctx = EVP_PKEY_CTX_get_data(pctx);\n    switch (gctx->cipher_nid)\n    {\n        case NID_id_Gost28147_89:\n        case NID_undef: /* FIXME */\n            return pkey_GOST_ECcp_decrypt(pctx, key, key_len, in, in_len);\n        case NID_kuznyechik_ctr:\n        case NID_magma_ctr:\n            return pkey_gost2018_decrypt(pctx, key, key_len, in, in_len);\n        default:\n      GOSTerr(GOST_F_PKEY_GOST_DECRYPT, ERR_R_INTERNAL_ERROR);\n      return -1;\n    }\n}\n/* vim: set expandtab cinoptions=\\:0,l1,t0,g0,(0 sw=4 : */\n"], "filenames": ["gost_ec_keyx.c"], "buggy_code_start_loc": [294], "buggy_code_end_loc": [377], "fixing_code_start_loc": [295], "fixing_code_end_loc": [398], "type": "CWE-120", "message": "GOST engine is a reference implementation of the Russian GOST crypto algorithms for OpenSSL. TLS clients using GOST engine when ciphersuite `TLS_GOSTR341112_256_WITH_KUZNYECHIK_CTR_OMAC` is agreed and the server uses 512 bit GOST secret keys are vulnerable to buffer overflow. GOST engine version 3.0.1 contains a patch for this issue. Disabling ciphersuite `TLS_GOSTR341112_256_WITH_KUZNYECHIK_CTR_OMAC` is a possible workaround.", "other": {"cve": {"id": "CVE-2022-29242", "sourceIdentifier": "security-advisories@github.com", "published": "2022-05-24T15:15:08.097", "lastModified": "2022-06-07T16:54:00.617", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "GOST engine is a reference implementation of the Russian GOST crypto algorithms for OpenSSL. TLS clients using GOST engine when ciphersuite `TLS_GOSTR341112_256_WITH_KUZNYECHIK_CTR_OMAC` is agreed and the server uses 512 bit GOST secret keys are vulnerable to buffer overflow. GOST engine version 3.0.1 contains a patch for this issue. Disabling ciphersuite `TLS_GOSTR341112_256_WITH_KUZNYECHIK_CTR_OMAC` is a possible workaround."}, {"lang": "es", "value": "GOST engine es una implementaci\u00f3n de referencia de los algoritmos criptogr\u00e1ficos rusos GOST para OpenSSL. Los clientes TLS usando el motor GOST cuando el cifrado \"TLS_GOSTR341112_256_WITH_KUZNYECHIK_CTR_OMAC\" est\u00e1 acordado y el servidor usa claves secretas GOST de 512 bits son vulnerables a un desbordamiento del b\u00fafer. GOST engine versi\u00f3n 3.0.1 contiene un parche para este problema. Deshabilitar el cifrado \"TLS_GOSTR341112_256_WITH_KUZNYECHIK_CTR_OMAC\" es una posible mitigaci\u00f3n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-120"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gost_engine_project:gost_engine:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.0.1", "matchCriteriaId": "CF53F170-E02E-4150-9041-7F91E35CD437"}]}]}], "references": [{"url": "https://github.com/gost-engine/engine/commit/7df766124f87768b43b9e8947c5a01e17545772c", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/gost-engine/engine/commit/b2b4d629f100eaee9f5942a106b1ccefe85b8808", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/gost-engine/engine/commit/c6655a0b620a3e31f085cc906f8073fe81b2fad3", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/gost-engine/engine/releases/tag/v3.0.1", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/gost-engine/engine/security/advisories/GHSA-2rmw-8wpg-vgw5", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/gost-engine/engine/commit/7df766124f87768b43b9e8947c5a01e17545772c"}}