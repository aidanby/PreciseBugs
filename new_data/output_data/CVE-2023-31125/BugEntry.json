{"buggy_code": ["import * as qs from \"querystring\";\nimport { parse } from \"url\";\nimport * as base64id from \"base64id\";\nimport transports from \"./transports\";\nimport { EventEmitter } from \"events\";\nimport { Socket } from \"./socket\";\nimport debugModule from \"debug\";\nimport { serialize } from \"cookie\";\nimport { Server as DEFAULT_WS_ENGINE } from \"ws\";\nimport type {\n  IncomingMessage,\n  Server as HttpServer,\n  ServerResponse,\n} from \"http\";\nimport type { CookieSerializeOptions } from \"cookie\";\nimport type { CorsOptions, CorsOptionsDelegate } from \"cors\";\nimport type { Duplex } from \"stream\";\n\nconst debug = debugModule(\"engine\");\n\nconst kResponseHeaders = Symbol(\"responseHeaders\");\n\ntype Transport = \"polling\" | \"websocket\";\n\nexport interface AttachOptions {\n  /**\n   * name of the path to capture\n   * @default \"/engine.io\"\n   */\n  path?: string;\n  /**\n   * destroy unhandled upgrade requests\n   * @default true\n   */\n  destroyUpgrade?: boolean;\n  /**\n   * milliseconds after which unhandled requests are ended\n   * @default 1000\n   */\n  destroyUpgradeTimeout?: number;\n\n  /**\n   * Whether we should add a trailing slash to the request path.\n   * @default true\n   */\n  addTrailingSlash?: boolean;\n}\n\nexport interface ServerOptions {\n  /**\n   * how many ms without a pong packet to consider the connection closed\n   * @default 20000\n   */\n  pingTimeout?: number;\n  /**\n   * how many ms before sending a new ping packet\n   * @default 25000\n   */\n  pingInterval?: number;\n  /**\n   * how many ms before an uncompleted transport upgrade is cancelled\n   * @default 10000\n   */\n  upgradeTimeout?: number;\n  /**\n   * how many bytes or characters a message can be, before closing the session (to avoid DoS).\n   * @default 1e5 (100 KB)\n   */\n  maxHttpBufferSize?: number;\n  /**\n   * A function that receives a given handshake or upgrade request as its first parameter,\n   * and can decide whether to continue or not. The second argument is a function that needs\n   * to be called with the decided information: fn(err, success), where success is a boolean\n   * value where false means that the request is rejected, and err is an error code.\n   */\n  allowRequest?: (\n    req: IncomingMessage,\n    fn: (err: string | null | undefined, success: boolean) => void\n  ) => void;\n  /**\n   * the low-level transports that are enabled\n   * @default [\"polling\", \"websocket\"]\n   */\n  transports?: Transport[];\n  /**\n   * whether to allow transport upgrades\n   * @default true\n   */\n  allowUpgrades?: boolean;\n  /**\n   * parameters of the WebSocket permessage-deflate extension (see ws module api docs). Set to false to disable.\n   * @default false\n   */\n  perMessageDeflate?: boolean | object;\n  /**\n   * parameters of the http compression for the polling transports (see zlib api docs). Set to false to disable.\n   * @default true\n   */\n  httpCompression?: boolean | object;\n  /**\n   * what WebSocket server implementation to use. Specified module must\n   * conform to the ws interface (see ws module api docs).\n   * An alternative c++ addon is also available by installing eiows module.\n   *\n   * @default `require(\"ws\").Server`\n   */\n  wsEngine?: any;\n  /**\n   * an optional packet which will be concatenated to the handshake packet emitted by Engine.IO.\n   */\n  initialPacket?: any;\n  /**\n   * configuration of the cookie that contains the client sid to send as part of handshake response headers. This cookie\n   * might be used for sticky-session. Defaults to not sending any cookie.\n   * @default false\n   */\n  cookie?: (CookieSerializeOptions & { name: string }) | boolean;\n  /**\n   * the options that will be forwarded to the cors module\n   */\n  cors?: CorsOptions | CorsOptionsDelegate;\n  /**\n   * whether to enable compatibility with Socket.IO v2 clients\n   * @default false\n   */\n  allowEIO3?: boolean;\n}\n\n/**\n * An Express-compatible middleware.\n *\n * Middleware functions are functions that have access to the request object (req), the response object (res), and the\n * next middleware function in the application\u2019s request-response cycle.\n *\n * @see https://expressjs.com/en/guide/using-middleware.html\n */\ntype Middleware = (\n  req: IncomingMessage,\n  res: ServerResponse,\n  next: (err?: any) => void\n) => void;\n\nexport abstract class BaseServer extends EventEmitter {\n  public opts: ServerOptions;\n\n  protected clients: any;\n  public clientsCount: number;\n  protected middlewares: Middleware[] = [];\n\n  /**\n   * Server constructor.\n   *\n   * @param {Object} opts - options\n   * @api public\n   */\n  constructor(opts: ServerOptions = {}) {\n    super();\n\n    this.clients = {};\n    this.clientsCount = 0;\n\n    this.opts = Object.assign(\n      {\n        wsEngine: DEFAULT_WS_ENGINE,\n        pingTimeout: 20000,\n        pingInterval: 25000,\n        upgradeTimeout: 10000,\n        maxHttpBufferSize: 1e6,\n        transports: Object.keys(transports),\n        allowUpgrades: true,\n        httpCompression: {\n          threshold: 1024,\n        },\n        cors: false,\n        allowEIO3: false,\n      },\n      opts\n    );\n\n    if (opts.cookie) {\n      this.opts.cookie = Object.assign(\n        {\n          name: \"io\",\n          path: \"/\",\n          // @ts-ignore\n          httpOnly: opts.cookie.path !== false,\n          sameSite: \"lax\",\n        },\n        opts.cookie\n      );\n    }\n\n    if (this.opts.cors) {\n      this.use(require(\"cors\")(this.opts.cors));\n    }\n\n    if (opts.perMessageDeflate) {\n      this.opts.perMessageDeflate = Object.assign(\n        {\n          threshold: 1024,\n        },\n        opts.perMessageDeflate\n      );\n    }\n\n    this.init();\n  }\n\n  protected abstract init();\n\n  /**\n   * Compute the pathname of the requests that are handled by the server\n   * @param options\n   * @protected\n   */\n  protected _computePath(options: AttachOptions) {\n    let path = (options.path || \"/engine.io\").replace(/\\/$/, \"\");\n\n    if (options.addTrailingSlash !== false) {\n      // normalize path\n      path += \"/\";\n    }\n\n    return path;\n  }\n\n  /**\n   * Returns a list of available transports for upgrade given a certain transport.\n   *\n   * @return {Array}\n   * @api public\n   */\n  public upgrades(transport) {\n    if (!this.opts.allowUpgrades) return [];\n    return transports[transport].upgradesTo || [];\n  }\n\n  /**\n   * Verifies a request.\n   *\n   * @param {http.IncomingMessage}\n   * @return {Boolean} whether the request is valid\n   * @api private\n   */\n  protected verify(req, upgrade, fn) {\n    // transport check\n    const transport = req._query.transport;\n    if (!~this.opts.transports.indexOf(transport)) {\n      debug('unknown transport \"%s\"', transport);\n      return fn(Server.errors.UNKNOWN_TRANSPORT, { transport });\n    }\n\n    // 'Origin' header check\n    const isOriginInvalid = checkInvalidHeaderChar(req.headers.origin);\n    if (isOriginInvalid) {\n      const origin = req.headers.origin;\n      req.headers.origin = null;\n      debug(\"origin header invalid\");\n      return fn(Server.errors.BAD_REQUEST, {\n        name: \"INVALID_ORIGIN\",\n        origin,\n      });\n    }\n\n    // sid check\n    const sid = req._query.sid;\n    if (sid) {\n      if (!this.clients.hasOwnProperty(sid)) {\n        debug('unknown sid \"%s\"', sid);\n        return fn(Server.errors.UNKNOWN_SID, {\n          sid,\n        });\n      }\n      const previousTransport = this.clients[sid].transport.name;\n      if (!upgrade && previousTransport !== transport) {\n        debug(\"bad request: unexpected transport without upgrade\");\n        return fn(Server.errors.BAD_REQUEST, {\n          name: \"TRANSPORT_MISMATCH\",\n          transport,\n          previousTransport,\n        });\n      }\n    } else {\n      // handshake is GET only\n      if (\"GET\" !== req.method) {\n        return fn(Server.errors.BAD_HANDSHAKE_METHOD, {\n          method: req.method,\n        });\n      }\n\n      if (transport === \"websocket\" && !upgrade) {\n        debug(\"invalid transport upgrade\");\n        return fn(Server.errors.BAD_REQUEST, {\n          name: \"TRANSPORT_HANDSHAKE_ERROR\",\n        });\n      }\n\n      if (!this.opts.allowRequest) return fn();\n\n      return this.opts.allowRequest(req, (message, success) => {\n        if (!success) {\n          return fn(Server.errors.FORBIDDEN, {\n            message,\n          });\n        }\n        fn();\n      });\n    }\n\n    fn();\n  }\n\n  /**\n   * Adds a new middleware.\n   *\n   * @example\n   * import helmet from \"helmet\";\n   *\n   * engine.use(helmet());\n   *\n   * @param fn\n   */\n  public use(fn: any) {\n    this.middlewares.push(fn);\n  }\n\n  /**\n   * Apply the middlewares to the request.\n   *\n   * @param req\n   * @param res\n   * @param callback\n   * @protected\n   */\n  protected _applyMiddlewares(\n    req: IncomingMessage,\n    res: ServerResponse,\n    callback: (err?: any) => void\n  ) {\n    if (this.middlewares.length === 0) {\n      debug(\"no middleware to apply, skipping\");\n      return callback();\n    }\n\n    const apply = (i) => {\n      debug(\"applying middleware n\u00b0%d\", i + 1);\n      this.middlewares[i](req, res, (err?: any) => {\n        if (err) {\n          return callback(err);\n        }\n\n        if (i + 1 < this.middlewares.length) {\n          apply(i + 1);\n        } else {\n          callback();\n        }\n      });\n    };\n\n    apply(0);\n  }\n\n  /**\n   * Closes all clients.\n   *\n   * @api public\n   */\n  public close() {\n    debug(\"closing all open clients\");\n    for (let i in this.clients) {\n      if (this.clients.hasOwnProperty(i)) {\n        this.clients[i].close(true);\n      }\n    }\n    this.cleanup();\n    return this;\n  }\n\n  protected abstract cleanup();\n\n  /**\n   * generate a socket id.\n   * Overwrite this method to generate your custom socket id\n   *\n   * @param {Object} request object\n   * @api public\n   */\n  public generateId(req) {\n    return base64id.generateId();\n  }\n\n  /**\n   * Handshakes a new client.\n   *\n   * @param {String} transport name\n   * @param {Object} request object\n   * @param {Function} closeConnection\n   *\n   * @api protected\n   */\n  protected async handshake(transportName, req, closeConnection) {\n    const protocol = req._query.EIO === \"4\" ? 4 : 3; // 3rd revision by default\n    if (protocol === 3 && !this.opts.allowEIO3) {\n      debug(\"unsupported protocol version\");\n      this.emit(\"connection_error\", {\n        req,\n        code: Server.errors.UNSUPPORTED_PROTOCOL_VERSION,\n        message:\n          Server.errorMessages[Server.errors.UNSUPPORTED_PROTOCOL_VERSION],\n        context: {\n          protocol,\n        },\n      });\n      closeConnection(Server.errors.UNSUPPORTED_PROTOCOL_VERSION);\n      return;\n    }\n\n    let id;\n    try {\n      id = await this.generateId(req);\n    } catch (e) {\n      debug(\"error while generating an id\");\n      this.emit(\"connection_error\", {\n        req,\n        code: Server.errors.BAD_REQUEST,\n        message: Server.errorMessages[Server.errors.BAD_REQUEST],\n        context: {\n          name: \"ID_GENERATION_ERROR\",\n          error: e,\n        },\n      });\n      closeConnection(Server.errors.BAD_REQUEST);\n      return;\n    }\n\n    debug('handshaking client \"%s\"', id);\n\n    try {\n      var transport = this.createTransport(transportName, req);\n      if (\"polling\" === transportName) {\n        transport.maxHttpBufferSize = this.opts.maxHttpBufferSize;\n        transport.httpCompression = this.opts.httpCompression;\n      } else if (\"websocket\" === transportName) {\n        transport.perMessageDeflate = this.opts.perMessageDeflate;\n      }\n\n      if (req._query && req._query.b64) {\n        transport.supportsBinary = false;\n      } else {\n        transport.supportsBinary = true;\n      }\n    } catch (e) {\n      debug('error handshaking to transport \"%s\"', transportName);\n      this.emit(\"connection_error\", {\n        req,\n        code: Server.errors.BAD_REQUEST,\n        message: Server.errorMessages[Server.errors.BAD_REQUEST],\n        context: {\n          name: \"TRANSPORT_HANDSHAKE_ERROR\",\n          error: e,\n        },\n      });\n      closeConnection(Server.errors.BAD_REQUEST);\n      return;\n    }\n    const socket = new Socket(id, this, transport, req, protocol);\n\n    transport.on(\"headers\", (headers, req) => {\n      const isInitialRequest = !req._query.sid;\n\n      if (isInitialRequest) {\n        if (this.opts.cookie) {\n          headers[\"Set-Cookie\"] = [\n            // @ts-ignore\n            serialize(this.opts.cookie.name, id, this.opts.cookie),\n          ];\n        }\n        this.emit(\"initial_headers\", headers, req);\n      }\n      this.emit(\"headers\", headers, req);\n    });\n\n    transport.onRequest(req);\n\n    this.clients[id] = socket;\n    this.clientsCount++;\n\n    socket.once(\"close\", () => {\n      delete this.clients[id];\n      this.clientsCount--;\n    });\n\n    this.emit(\"connection\", socket);\n\n    return transport;\n  }\n\n  protected abstract createTransport(transportName, req);\n\n  /**\n   * Protocol errors mappings.\n   */\n\n  static errors = {\n    UNKNOWN_TRANSPORT: 0,\n    UNKNOWN_SID: 1,\n    BAD_HANDSHAKE_METHOD: 2,\n    BAD_REQUEST: 3,\n    FORBIDDEN: 4,\n    UNSUPPORTED_PROTOCOL_VERSION: 5,\n  };\n\n  static errorMessages = {\n    0: \"Transport unknown\",\n    1: \"Session ID unknown\",\n    2: \"Bad handshake method\",\n    3: \"Bad request\",\n    4: \"Forbidden\",\n    5: \"Unsupported protocol version\",\n  };\n}\n\n/**\n * Exposes a subset of the http.ServerResponse interface, in order to be able to apply the middlewares to an upgrade\n * request.\n *\n * @see https://nodejs.org/api/http.html#class-httpserverresponse\n */\nclass WebSocketResponse {\n  constructor(readonly req, readonly socket: Duplex) {\n    // temporarily store the response headers on the req object (see the \"headers\" event)\n    req[kResponseHeaders] = {};\n  }\n\n  public setHeader(name: string, value: any) {\n    this.req[kResponseHeaders][name] = value;\n  }\n\n  public getHeader(name: string) {\n    return this.req[kResponseHeaders][name];\n  }\n\n  public removeHeader(name: string) {\n    delete this.req[kResponseHeaders][name];\n  }\n\n  public write() {}\n\n  public writeHead() {}\n\n  public end() {\n    // we could return a proper error code, but the WebSocket client will emit an \"error\" event anyway.\n    this.socket.destroy();\n  }\n}\n\nexport class Server extends BaseServer {\n  public httpServer?: HttpServer;\n  private ws: any;\n\n  /**\n   * Initialize websocket server\n   *\n   * @api protected\n   */\n  protected init() {\n    if (!~this.opts.transports.indexOf(\"websocket\")) return;\n\n    if (this.ws) this.ws.close();\n\n    this.ws = new this.opts.wsEngine({\n      noServer: true,\n      clientTracking: false,\n      perMessageDeflate: this.opts.perMessageDeflate,\n      maxPayload: this.opts.maxHttpBufferSize,\n    });\n\n    if (typeof this.ws.on === \"function\") {\n      this.ws.on(\"headers\", (headersArray, req) => {\n        // note: 'ws' uses an array of headers, while Engine.IO uses an object (response.writeHead() accepts both formats)\n        // we could also try to parse the array and then sync the values, but that will be error-prone\n        const additionalHeaders = req[kResponseHeaders] || {};\n        delete req[kResponseHeaders];\n\n        const isInitialRequest = !req._query.sid;\n        if (isInitialRequest) {\n          this.emit(\"initial_headers\", additionalHeaders, req);\n        }\n\n        this.emit(\"headers\", additionalHeaders, req);\n\n        debug(\"writing headers: %j\", additionalHeaders);\n        Object.keys(additionalHeaders).forEach((key) => {\n          headersArray.push(`${key}: ${additionalHeaders[key]}`);\n        });\n      });\n    }\n  }\n\n  protected cleanup() {\n    if (this.ws) {\n      debug(\"closing webSocketServer\");\n      this.ws.close();\n      // don't delete this.ws because it can be used again if the http server starts listening again\n    }\n  }\n\n  /**\n   * Prepares a request by processing the query string.\n   *\n   * @api private\n   */\n  private prepare(req) {\n    // try to leverage pre-existing `req._query` (e.g: from connect)\n    if (!req._query) {\n      req._query = ~req.url.indexOf(\"?\") ? qs.parse(parse(req.url).query) : {};\n    }\n  }\n\n  protected createTransport(transportName, req) {\n    return new transports[transportName](req);\n  }\n\n  /**\n   * Handles an Engine.IO HTTP request.\n   *\n   * @param {IncomingMessage} req\n   * @param {ServerResponse} res\n   * @api public\n   */\n  public handleRequest(req: IncomingMessage, res: ServerResponse) {\n    debug('handling \"%s\" http request \"%s\"', req.method, req.url);\n    this.prepare(req);\n    // @ts-ignore\n    req.res = res;\n\n    const callback = (errorCode, errorContext) => {\n      if (errorCode !== undefined) {\n        this.emit(\"connection_error\", {\n          req,\n          code: errorCode,\n          message: Server.errorMessages[errorCode],\n          context: errorContext,\n        });\n        abortRequest(res, errorCode, errorContext);\n        return;\n      }\n\n      // @ts-ignore\n      if (req._query.sid) {\n        debug(\"setting new request for existing client\");\n        // @ts-ignore\n        this.clients[req._query.sid].transport.onRequest(req);\n      } else {\n        const closeConnection = (errorCode, errorContext) =>\n          abortRequest(res, errorCode, errorContext);\n        // @ts-ignore\n        this.handshake(req._query.transport, req, closeConnection);\n      }\n    };\n\n    this._applyMiddlewares(req, res, (err) => {\n      if (err) {\n        callback(Server.errors.BAD_REQUEST, { name: \"MIDDLEWARE_FAILURE\" });\n      } else {\n        this.verify(req, false, callback);\n      }\n    });\n  }\n\n  /**\n   * Handles an Engine.IO HTTP Upgrade.\n   *\n   * @api public\n   */\n  public handleUpgrade(\n    req: IncomingMessage,\n    socket: Duplex,\n    upgradeHead: Buffer\n  ) {\n    this.prepare(req);\n\n    const res = new WebSocketResponse(req, socket);\n    const callback = (errorCode, errorContext) => {\n      if (errorCode) {\n        this.emit(\"connection_error\", {\n          req,\n          code: errorCode,\n          message: Server.errorMessages[errorCode],\n          context: errorContext,\n        });\n        abortUpgrade(socket, errorCode, errorContext);\n        return;\n      }\n\n      const head = Buffer.from(upgradeHead);\n      upgradeHead = null;\n\n      // some middlewares (like express-session) wait for the writeHead() call to flush their headers\n      // see https://github.com/expressjs/session/blob/1010fadc2f071ddf2add94235d72224cf65159c6/index.js#L220-L244\n      res.writeHead();\n\n      // delegate to ws\n      this.ws.handleUpgrade(req, socket, head, (websocket) => {\n        this.onWebSocket(req, socket, websocket);\n      });\n    };\n\n    this._applyMiddlewares(req, res as unknown as ServerResponse, (err) => {\n      if (err) {\n        callback(Server.errors.BAD_REQUEST, { name: \"MIDDLEWARE_FAILURE\" });\n      } else {\n        this.verify(req, true, callback);\n      }\n    });\n  }\n\n  /**\n   * Called upon a ws.io connection.\n   *\n   * @param {ws.Socket} websocket\n   * @api private\n   */\n  private onWebSocket(req, socket, websocket) {\n    websocket.on(\"error\", onUpgradeError);\n\n    if (\n      transports[req._query.transport] !== undefined &&\n      !transports[req._query.transport].prototype.handlesUpgrades\n    ) {\n      debug(\"transport doesnt handle upgraded requests\");\n      websocket.close();\n      return;\n    }\n\n    // get client id\n    const id = req._query.sid;\n\n    // keep a reference to the ws.Socket\n    req.websocket = websocket;\n\n    if (id) {\n      const client = this.clients[id];\n      if (!client) {\n        debug(\"upgrade attempt for closed client\");\n        websocket.close();\n      } else if (client.upgrading) {\n        debug(\"transport has already been trying to upgrade\");\n        websocket.close();\n      } else if (client.upgraded) {\n        debug(\"transport had already been upgraded\");\n        websocket.close();\n      } else {\n        debug(\"upgrading existing transport\");\n\n        // transport error handling takes over\n        websocket.removeListener(\"error\", onUpgradeError);\n\n        const transport = this.createTransport(req._query.transport, req);\n        if (req._query && req._query.b64) {\n          transport.supportsBinary = false;\n        } else {\n          transport.supportsBinary = true;\n        }\n        transport.perMessageDeflate = this.opts.perMessageDeflate;\n        client.maybeUpgrade(transport);\n      }\n    } else {\n      const closeConnection = (errorCode, errorContext) =>\n        abortUpgrade(socket, errorCode, errorContext);\n      this.handshake(req._query.transport, req, closeConnection);\n    }\n\n    function onUpgradeError() {\n      debug(\"websocket error before upgrade\");\n      // websocket.close() not needed\n    }\n  }\n\n  /**\n   * Captures upgrade requests for a http.Server.\n   *\n   * @param {http.Server} server\n   * @param {Object} options\n   * @api public\n   */\n  public attach(server: HttpServer, options: AttachOptions = {}) {\n    const path = this._computePath(options);\n    const destroyUpgradeTimeout = options.destroyUpgradeTimeout || 1000;\n\n    function check(req) {\n      // TODO use `path === new URL(...).pathname` in the next major release (ref: https://nodejs.org/api/url.html)\n      return path === req.url.slice(0, path.length);\n    }\n\n    // cache and clean up listeners\n    const listeners = server.listeners(\"request\").slice(0);\n    server.removeAllListeners(\"request\");\n    server.on(\"close\", this.close.bind(this));\n    server.on(\"listening\", this.init.bind(this));\n\n    // add request handler\n    server.on(\"request\", (req, res) => {\n      if (check(req)) {\n        debug('intercepting request for path \"%s\"', path);\n        this.handleRequest(req, res);\n      } else {\n        let i = 0;\n        const l = listeners.length;\n        for (; i < l; i++) {\n          listeners[i].call(server, req, res);\n        }\n      }\n    });\n\n    if (~this.opts.transports.indexOf(\"websocket\")) {\n      server.on(\"upgrade\", (req, socket, head) => {\n        if (check(req)) {\n          this.handleUpgrade(req, socket, head);\n        } else if (false !== options.destroyUpgrade) {\n          // default node behavior is to disconnect when no handlers\n          // but by adding a handler, we prevent that\n          // and if no eio thing handles the upgrade\n          // then the socket needs to die!\n          setTimeout(function () {\n            // @ts-ignore\n            if (socket.writable && socket.bytesWritten <= 0) {\n              socket.on(\"error\", (e) => {\n                debug(\"error while destroying upgrade: %s\", e.message);\n              });\n              return socket.end();\n            }\n          }, destroyUpgradeTimeout);\n        }\n      });\n    }\n  }\n}\n\n/**\n * Close the HTTP long-polling request\n *\n * @param res - the response object\n * @param errorCode - the error code\n * @param errorContext - additional error context\n *\n * @api private\n */\n\nfunction abortRequest(res, errorCode, errorContext) {\n  const statusCode = errorCode === Server.errors.FORBIDDEN ? 403 : 400;\n  const message =\n    errorContext && errorContext.message\n      ? errorContext.message\n      : Server.errorMessages[errorCode];\n\n  res.writeHead(statusCode, { \"Content-Type\": \"application/json\" });\n  res.end(\n    JSON.stringify({\n      code: errorCode,\n      message,\n    })\n  );\n}\n\n/**\n * Close the WebSocket connection\n *\n * @param {net.Socket} socket\n * @param {string} errorCode - the error code\n * @param {object} errorContext - additional error context\n *\n * @api private\n */\n\nfunction abortUpgrade(\n  socket,\n  errorCode,\n  errorContext: { message?: string } = {}\n) {\n  socket.on(\"error\", () => {\n    debug(\"ignoring error from closed connection\");\n  });\n  if (socket.writable) {\n    const message = errorContext.message || Server.errorMessages[errorCode];\n    const length = Buffer.byteLength(message);\n    socket.write(\n      \"HTTP/1.1 400 Bad Request\\r\\n\" +\n        \"Connection: close\\r\\n\" +\n        \"Content-type: text/html\\r\\n\" +\n        \"Content-Length: \" +\n        length +\n        \"\\r\\n\" +\n        \"\\r\\n\" +\n        message\n    );\n  }\n  socket.destroy();\n}\n\n/* eslint-disable */\n\n/**\n * From https://github.com/nodejs/node/blob/v8.4.0/lib/_http_common.js#L303-L354\n *\n * True if val contains an invalid field-vchar\n *  field-value    = *( field-content / obs-fold )\n *  field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]\n *  field-vchar    = VCHAR / obs-text\n *\n * checkInvalidHeaderChar() is currently designed to be inlinable by v8,\n * so take care when making changes to the implementation so that the source\n * code size does not exceed v8's default max_inlined_source_size setting.\n **/\n// prettier-ignore\nconst validHdrChars = [\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, // 0 - 15\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 32 - 47\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 48 - 63\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 80 - 95\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, // 112 - 127\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 128 ...\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1  // ... 255\n]\n\nfunction checkInvalidHeaderChar(val) {\n  val += \"\";\n  if (val.length < 1) return false;\n  if (!validHdrChars[val.charCodeAt(0)]) {\n    debug('invalid header, index 0, char \"%s\"', val.charCodeAt(0));\n    return true;\n  }\n  if (val.length < 2) return false;\n  if (!validHdrChars[val.charCodeAt(1)]) {\n    debug('invalid header, index 1, char \"%s\"', val.charCodeAt(1));\n    return true;\n  }\n  if (val.length < 3) return false;\n  if (!validHdrChars[val.charCodeAt(2)]) {\n    debug('invalid header, index 2, char \"%s\"', val.charCodeAt(2));\n    return true;\n  }\n  if (val.length < 4) return false;\n  if (!validHdrChars[val.charCodeAt(3)]) {\n    debug('invalid header, index 3, char \"%s\"', val.charCodeAt(3));\n    return true;\n  }\n  for (let i = 4; i < val.length; ++i) {\n    if (!validHdrChars[val.charCodeAt(i)]) {\n      debug('invalid header, index \"%i\", char \"%s\"', i, val.charCodeAt(i));\n      return true;\n    }\n  }\n  return false;\n}\n", "import debugModule from \"debug\";\nimport { AttachOptions, BaseServer, Server } from \"./server\";\nimport { HttpRequest, HttpResponse, TemplatedApp } from \"uWebSockets.js\";\nimport transports from \"./transports-uws\";\n\nconst debug = debugModule(\"engine:uws\");\n\nexport interface uOptions {\n  /**\n   * What permessage-deflate compression to use. uWS.DISABLED, uWS.SHARED_COMPRESSOR or any of the uWS.DEDICATED_COMPRESSOR_xxxKB.\n   * @default uWS.DISABLED\n   */\n  compression?: number;\n  /**\n   * Maximum amount of seconds that may pass without sending or getting a message. Connection is closed if this timeout passes. Resolution (granularity) for timeouts are typically 4 seconds, rounded to closest. Disable by using 0.\n   * @default 120\n   */\n  idleTimeout?: number;\n  /**\n   * Maximum length of allowed backpressure per socket when publishing or sending messages. Slow receivers with too high backpressure will be skipped until they catch up or timeout.\n   * @default 1024 * 1024\n   */\n  maxBackpressure?: number;\n}\n\nexport class uServer extends BaseServer {\n  protected init() {}\n  protected cleanup() {}\n\n  /**\n   * Prepares a request by processing the query string.\n   *\n   * @api private\n   */\n  private prepare(req, res: HttpResponse) {\n    req.method = req.getMethod().toUpperCase();\n    req.url = req.getUrl();\n\n    const params = new URLSearchParams(req.getQuery());\n    req._query = Object.fromEntries(params.entries());\n\n    req.headers = {};\n    req.forEach((key, value) => {\n      req.headers[key] = value;\n    });\n\n    req.connection = {\n      remoteAddress: Buffer.from(res.getRemoteAddressAsText()).toString(),\n    };\n\n    res.onAborted(() => {\n      debug(\"response has been aborted\");\n    });\n  }\n\n  protected createTransport(transportName, req) {\n    return new transports[transportName](req);\n  }\n\n  /**\n   * Attach the engine to a \u00b5WebSockets.js server\n   * @param app\n   * @param options\n   */\n  public attach(\n    app /* : TemplatedApp */,\n    options: AttachOptions & uOptions = {}\n  ) {\n    const path = this._computePath(options);\n    (app as TemplatedApp)\n      .any(path, this.handleRequest.bind(this))\n      //\n      .ws(path, {\n        compression: options.compression,\n        idleTimeout: options.idleTimeout,\n        maxBackpressure: options.maxBackpressure,\n        maxPayloadLength: this.opts.maxHttpBufferSize,\n        upgrade: this.handleUpgrade.bind(this),\n        open: (ws) => {\n          ws.transport.socket = ws;\n          ws.transport.writable = true;\n          ws.transport.emit(\"drain\");\n        },\n        message: (ws, message, isBinary) => {\n          ws.transport.onData(\n            isBinary ? message : Buffer.from(message).toString()\n          );\n        },\n        close: (ws, code, message) => {\n          ws.transport.onClose(code, message);\n        },\n      });\n  }\n\n  override _applyMiddlewares(\n    req: any,\n    res: any,\n    callback: (err?: any) => void\n  ): void {\n    if (this.middlewares.length === 0) {\n      return callback();\n    }\n\n    // needed to buffer headers until the status is computed\n    req.res = new ResponseWrapper(res);\n\n    super._applyMiddlewares(req, req.res, (err) => {\n      // some middlewares (like express-session) wait for the writeHead() call to flush their headers\n      // see https://github.com/expressjs/session/blob/1010fadc2f071ddf2add94235d72224cf65159c6/index.js#L220-L244\n      req.res.writeHead();\n\n      callback(err);\n    });\n  }\n\n  private handleRequest(\n    res: HttpResponse,\n    req: HttpRequest & { res: any; _query: any }\n  ) {\n    debug('handling \"%s\" http request \"%s\"', req.getMethod(), req.getUrl());\n    this.prepare(req, res);\n\n    req.res = res;\n\n    const callback = (errorCode, errorContext) => {\n      if (errorCode !== undefined) {\n        this.emit(\"connection_error\", {\n          req,\n          code: errorCode,\n          message: Server.errorMessages[errorCode],\n          context: errorContext,\n        });\n        this.abortRequest(req.res, errorCode, errorContext);\n        return;\n      }\n\n      if (req._query.sid) {\n        debug(\"setting new request for existing client\");\n        this.clients[req._query.sid].transport.onRequest(req);\n      } else {\n        const closeConnection = (errorCode, errorContext) =>\n          this.abortRequest(res, errorCode, errorContext);\n        this.handshake(req._query.transport, req, closeConnection);\n      }\n    };\n\n    this._applyMiddlewares(req, res, (err) => {\n      if (err) {\n        callback(Server.errors.BAD_REQUEST, { name: \"MIDDLEWARE_FAILURE\" });\n      } else {\n        this.verify(req, false, callback);\n      }\n    });\n  }\n\n  private handleUpgrade(\n    res: HttpResponse,\n    req: HttpRequest & { res: any; _query: any },\n    context\n  ) {\n    debug(\"on upgrade\");\n\n    this.prepare(req, res);\n\n    req.res = res;\n\n    const callback = async (errorCode, errorContext) => {\n      if (errorCode) {\n        this.emit(\"connection_error\", {\n          req,\n          code: errorCode,\n          message: Server.errorMessages[errorCode],\n          context: errorContext,\n        });\n        this.abortRequest(res, errorCode, errorContext);\n        return;\n      }\n\n      const id = req._query.sid;\n      let transport;\n\n      if (id) {\n        const client = this.clients[id];\n        if (!client) {\n          debug(\"upgrade attempt for closed client\");\n          res.close();\n        } else if (client.upgrading) {\n          debug(\"transport has already been trying to upgrade\");\n          res.close();\n        } else if (client.upgraded) {\n          debug(\"transport had already been upgraded\");\n          res.close();\n        } else {\n          debug(\"upgrading existing transport\");\n          transport = this.createTransport(req._query.transport, req);\n          client.maybeUpgrade(transport);\n        }\n      } else {\n        transport = await this.handshake(\n          req._query.transport,\n          req,\n          (errorCode, errorContext) =>\n            this.abortRequest(res, errorCode, errorContext)\n        );\n        if (!transport) {\n          return;\n        }\n      }\n\n      // calling writeStatus() triggers the flushing of any header added in a middleware\n      req.res.writeStatus(\"101 Switching Protocols\");\n\n      res.upgrade(\n        {\n          transport,\n        },\n        req.getHeader(\"sec-websocket-key\"),\n        req.getHeader(\"sec-websocket-protocol\"),\n        req.getHeader(\"sec-websocket-extensions\"),\n        context\n      );\n    };\n\n    this._applyMiddlewares(req, res, (err) => {\n      if (err) {\n        callback(Server.errors.BAD_REQUEST, { name: \"MIDDLEWARE_FAILURE\" });\n      } else {\n        this.verify(req, true, callback);\n      }\n    });\n  }\n\n  private abortRequest(\n    res: HttpResponse | ResponseWrapper,\n    errorCode,\n    errorContext\n  ) {\n    const statusCode =\n      errorCode === Server.errors.FORBIDDEN\n        ? \"403 Forbidden\"\n        : \"400 Bad Request\";\n    const message =\n      errorContext && errorContext.message\n        ? errorContext.message\n        : Server.errorMessages[errorCode];\n\n    res.writeStatus(statusCode);\n    res.writeHeader(\"Content-Type\", \"application/json\");\n    res.end(\n      JSON.stringify({\n        code: errorCode,\n        message,\n      })\n    );\n  }\n}\n\nclass ResponseWrapper {\n  private statusWritten: boolean = false;\n  private headers = [];\n\n  constructor(readonly res: HttpResponse) {}\n\n  public set statusCode(status: number) {\n    if (!status) {\n      return;\n    }\n    // FIXME: handle all status codes?\n    this.writeStatus(status === 200 ? \"200 OK\" : \"204 No Content\");\n  }\n\n  public writeHead(status: number) {\n    this.statusCode = status;\n  }\n\n  public setHeader(key, value) {\n    if (Array.isArray(value)) {\n      value.forEach((val) => {\n        this.writeHeader(key, val);\n      });\n    } else {\n      this.writeHeader(key, value);\n    }\n  }\n\n  public removeHeader() {\n    // FIXME: not implemented\n  }\n\n  // needed by vary: https://github.com/jshttp/vary/blob/5d725d059b3871025cf753e9dfa08924d0bcfa8f/index.js#L134\n  public getHeader() {}\n\n  public writeStatus(status: string) {\n    this.res.writeStatus(status);\n    this.statusWritten = true;\n    this.writeBufferedHeaders();\n    return this;\n  }\n\n  public writeHeader(key: string, value: string) {\n    if (key === \"Content-Length\") {\n      // the content length is automatically added by uWebSockets.js\n      return;\n    }\n    if (this.statusWritten) {\n      this.res.writeHeader(key, value);\n    } else {\n      this.headers.push([key, value]);\n    }\n  }\n\n  private writeBufferedHeaders() {\n    this.headers.forEach(([key, value]) => {\n      this.res.writeHeader(key, value);\n    });\n  }\n\n  public end(data) {\n    if (!this.statusWritten) {\n      // status will be inferred as \"200 OK\"\n      this.writeBufferedHeaders();\n    }\n    this.res.end(data);\n  }\n\n  public onData(fn) {\n    this.res.onData(fn);\n  }\n\n  public onAborted(fn) {\n    this.res.onAborted(fn);\n  }\n}\n", "/* eslint-disable standard/no-callback-literal */\n\nconst http = require(\"http\");\nconst https = require(\"https\");\nconst fs = require(\"fs\");\nconst path = require(\"path\");\nconst exec = require(\"child_process\").exec;\nconst zlib = require(\"zlib\");\nconst { Server, Socket, attach } = require(\"..\");\nconst { ClientSocket, listen, createPartialDone } = require(\"./common\");\nconst expect = require(\"expect.js\");\nconst request = require(\"superagent\");\nconst cookieMod = require(\"cookie\");\n\n/**\n * Tests.\n */\n\ndescribe(\"server\", () => {\n  let engine, client;\n\n  afterEach(() => {\n    if (engine && engine.httpServer) {\n      engine.httpServer.close();\n    }\n    if (client) {\n      client.close();\n    }\n  });\n\n  describe(\"verification\", () => {\n    it(\"should disallow non-existent transports\", (done) => {\n      const partialDone = createPartialDone(done, 2);\n\n      engine = listen((port) => {\n        engine.on(\"connection_error\", (err) => {\n          expect(err.req).to.be.ok();\n          expect(err.code).to.be(0);\n          expect(err.message).to.be(\"Transport unknown\");\n          expect(err.context.transport).to.be(\"tobi\");\n          partialDone();\n        });\n\n        request\n          .get(`http://localhost:${port}/engine.io/`)\n          .query({ transport: \"tobi\" }) // no tobi transport - outrageous\n          .end((err, res) => {\n            expect(err).to.be.an(Error);\n            expect(res.status).to.be(400);\n            expect(res.body.code).to.be(0);\n            expect(res.body.message).to.be(\"Transport unknown\");\n            partialDone();\n          });\n      });\n    });\n\n    it(\"should disallow `constructor` as transports\", (done) => {\n      const partialDone = createPartialDone(done, 2);\n\n      // make sure we check for actual properties - not those present on every {}\n      engine = listen((port) => {\n        engine.on(\"connection_error\", (err) => {\n          expect(err.req).to.be.ok();\n          expect(err.code).to.be(0);\n          expect(err.message).to.be(\"Transport unknown\");\n          expect(err.context.transport).to.be(\"constructor\");\n          partialDone();\n        });\n\n        request\n          .get(`http://localhost:${port}/engine.io/`)\n          .set(\"Origin\", \"http://engine.io\")\n          .query({ transport: \"constructor\" })\n          .end((err, res) => {\n            expect(err).to.be.an(Error);\n            expect(res.status).to.be(400);\n            expect(res.body.code).to.be(0);\n            expect(res.body.message).to.be(\"Transport unknown\");\n            partialDone();\n          });\n      });\n    });\n\n    it(\"should disallow non-existent sids\", (done) => {\n      const partialDone = createPartialDone(done, 2);\n\n      engine = listen((port) => {\n        engine.on(\"connection_error\", (err) => {\n          expect(err.req).to.be.ok();\n          expect(err.code).to.be(1);\n          expect(err.message).to.be(\"Session ID unknown\");\n          expect(err.context.sid).to.be(\"test\");\n          partialDone();\n        });\n\n        request\n          .get(`http://localhost:${port}/engine.io/`)\n          .set(\"Origin\", \"http://engine.io\")\n          .query({ transport: \"polling\", sid: \"test\" })\n          .end((err, res) => {\n            expect(err).to.be.an(Error);\n            expect(res.status).to.be(400);\n            expect(res.body.code).to.be(1);\n            expect(res.body.message).to.be(\"Session ID unknown\");\n            partialDone();\n          });\n      });\n    });\n\n    it(\"should disallow requests that are rejected by `allowRequest`\", (done) => {\n      const partialDone = createPartialDone(done, 2);\n\n      engine = listen(\n        {\n          allowRequest: (req, fn) => {\n            fn(\"Thou shall not pass\", false);\n          },\n        },\n        (port) => {\n          engine.on(\"connection_error\", (err) => {\n            expect(err.req).to.be.ok();\n            expect(err.code).to.be(4);\n            expect(err.message).to.be(\"Forbidden\");\n            expect(err.context.message).to.be(\"Thou shall not pass\");\n            partialDone();\n          });\n\n          request\n            .get(`http://localhost:${port}/engine.io/`)\n            .set(\"Origin\", \"http://engine.io\")\n            .query({ transport: \"polling\" })\n            .end((err, res) => {\n              expect(err).to.be.an(Error);\n              expect(res.status).to.be(403);\n              expect(res.body.code).to.be(4);\n              expect(res.body.message).to.be(\"Thou shall not pass\");\n              partialDone();\n            });\n        }\n      );\n    });\n\n    it(\"should disallow connection that are rejected by `allowRequest` (ws)\", (done) => {\n      listen(\n        {\n          allowRequest: (req, fn) => {\n            fn(null, false);\n          },\n        },\n        (port) => {\n          const client = new ClientSocket(`ws://localhost:${port}`, {\n            transports: [\"websocket\"],\n          });\n          client.on(\"error\", () => {\n            done();\n          });\n        }\n      );\n    });\n\n    it(\"should not throw when the client sends invalid data during the handshake (ws only)\", (done) => {\n      listen((port) => {\n        // will throw \"RangeError: Invalid WebSocket frame: RSV2 and RSV3 must be clear\"\n        request\n          .get(`http://localhost:${port}/engine.io/`)\n          .set(\"connection\", \"upgrade\")\n          .set(\"upgrade\", \"websocket\")\n          .set(\"Sec-WebSocket-Version\", \"13\")\n          .set(\"Sec-WebSocket-Key\", \"DXR4dX615eRds8nRmlhqtw==\")\n          .query({ transport: \"websocket\", EIO: 4 })\n          .send(\"test\")\n          .end(() => {});\n\n        setTimeout(done, 50);\n      });\n    });\n\n    it(\"should not throw when the client sends invalid data during the handshake (upgrade)\", (done) => {\n      listen((port) => {\n        request\n          .get(`http://localhost:${port}/engine.io/`)\n          .query({ transport: \"polling\", EIO: 4 })\n          .end((err, res) => {\n            const sid = JSON.parse(res.text.slice(1)).sid;\n\n            request\n              .get(`http://localhost:${port}/engine.io/`)\n              .set(\"connection\", \"upgrade\")\n              .set(\"upgrade\", \"websocket\")\n              .set(\"Sec-WebSocket-Version\", \"13\")\n              .set(\"Sec-WebSocket-Key\", \"DXR4dX615eRds8nRmlhqtw==\")\n              .query({ transport: \"websocket\", EIO: 4, sid })\n              .send(\"test\")\n              .end(() => {});\n\n            setTimeout(done, 50);\n          });\n      });\n    });\n  });\n\n  describe(\"handshake\", () => {\n    it(\"should send the io cookie\", (done) => {\n      listen({ cookie: true }, (port) => {\n        request\n          .get(`http://localhost:${port}/engine.io/`)\n          .query({ transport: \"polling\", EIO: 4 })\n          .end((err, res) => {\n            expect(err).to.be(null);\n            // hack-obtain sid\n            const sid = res.text.match(/\"sid\":\"([^\"]+)\"/)[1];\n            expect(res.headers[\"set-cookie\"][0]).to.be(\n              `io=${sid}; Path=/; HttpOnly; SameSite=Lax`\n            );\n            done();\n          });\n      });\n    });\n\n    it(\"should send the io cookie custom name\", (done) => {\n      listen({ cookie: { name: \"woot\" } }, (port) => {\n        request\n          .get(`http://localhost:${port}/engine.io/`)\n          .query({ transport: \"polling\", b64: 1 })\n          .end((err, res) => {\n            expect(err).to.be(null);\n            const sid = res.text.match(/\"sid\":\"([^\"]+)\"/)[1];\n            expect(res.headers[\"set-cookie\"][0]).to.be(\n              `woot=${sid}; Path=/; HttpOnly; SameSite=Lax`\n            );\n            done();\n          });\n      });\n    });\n\n    it(\"should send the cookie with custom path\", (done) => {\n      listen({ cookie: { path: \"/custom\" } }, (port) => {\n        request\n          .get(`http://localhost:${port}/engine.io/`)\n          .query({ transport: \"polling\", b64: 1 })\n          .end((err, res) => {\n            expect(err).to.be(null);\n            const sid = res.text.match(/\"sid\":\"([^\"]+)\"/)[1];\n            expect(res.headers[\"set-cookie\"][0]).to.be(\n              `io=${sid}; Path=/custom; HttpOnly; SameSite=Lax`\n            );\n            done();\n          });\n      });\n    });\n\n    it(\"should send the cookie with path=false\", (done) => {\n      listen({ cookie: { path: false } }, (port) => {\n        request\n          .get(`http://localhost:${port}/engine.io/`)\n          .query({ transport: \"polling\", b64: 1 })\n          .end((err, res) => {\n            expect(err).to.be(null);\n            const sid = res.text.match(/\"sid\":\"([^\"]+)\"/)[1];\n            expect(res.headers[\"set-cookie\"][0]).to.be(\n              `io=${sid}; SameSite=Lax`\n            );\n            done();\n          });\n      });\n    });\n\n    it(\"should send the io cookie with httpOnly=true\", (done) => {\n      listen({ cookie: { httpOnly: true } }, (port) => {\n        request\n          .get(`http://localhost:${port}/engine.io/`)\n          .query({ transport: \"polling\", b64: 1 })\n          .end((err, res) => {\n            expect(err).to.be(null);\n            const sid = res.text.match(/\"sid\":\"([^\"]+)\"/)[1];\n            expect(res.headers[\"set-cookie\"][0]).to.be(\n              `io=${sid}; Path=/; HttpOnly; SameSite=Lax`\n            );\n            done();\n          });\n      });\n    });\n\n    it(\"should send the io cookie with sameSite=strict\", (done) => {\n      listen({ cookie: { sameSite: \"strict\" } }, (port) => {\n        request\n          .get(`http://localhost:${port}/engine.io/`)\n          .query({ transport: \"polling\", b64: 1 })\n          .end((err, res) => {\n            expect(err).to.be(null);\n            const sid = res.text.match(/\"sid\":\"([^\"]+)\"/)[1];\n            expect(res.headers[\"set-cookie\"][0]).to.be(\n              `io=${sid}; Path=/; HttpOnly; SameSite=Strict`\n            );\n            done();\n          });\n      });\n    });\n\n    it(\"should send the io cookie with httpOnly=false\", (done) => {\n      listen({ cookie: { httpOnly: false } }, (port) => {\n        request\n          .get(`http://localhost:${port}/engine.io/`)\n          .query({ transport: \"polling\", b64: 1 })\n          .end((err, res) => {\n            expect(err).to.be(null);\n            const sid = res.text.match(/\"sid\":\"([^\"]+)\"/)[1];\n            expect(res.headers[\"set-cookie\"][0]).to.be(\n              `io=${sid}; Path=/; SameSite=Lax`\n            );\n            done();\n          });\n      });\n    });\n\n    it(\"should send the io cookie with httpOnly not boolean\", (done) => {\n      listen({ cookie: { httpOnly: \"no\" } }, (port) => {\n        request\n          .get(`http://localhost:${port}/engine.io/`)\n          .query({ transport: \"polling\", b64: 1 })\n          .end((err, res) => {\n            expect(err).to.be(null);\n            const sid = res.text.match(/\"sid\":\"([^\"]+)\"/)[1];\n            expect(res.headers[\"set-cookie\"][0]).to.be(\n              `io=${sid}; Path=/; HttpOnly; SameSite=Lax`\n            );\n            done();\n          });\n      });\n    });\n\n    it(\"should not send the io cookie\", (done) => {\n      listen({ cookie: false }, (port) => {\n        request\n          .get(`http://localhost:${port}/engine.io/`)\n          .query({ transport: \"polling\" })\n          .end((err, res) => {\n            expect(err).to.be(null);\n            expect(res.headers[\"set-cookie\"]).to.be(undefined);\n            done();\n          });\n      });\n    });\n\n    it(\"should register a new client\", (done) => {\n      const engine = listen({ allowUpgrades: false }, (port) => {\n        expect(Object.keys(engine.clients)).to.have.length(0);\n        expect(engine.clientsCount).to.be(0);\n\n        const socket = new ClientSocket(`ws://localhost:${port}`);\n        socket.on(\"open\", () => {\n          expect(Object.keys(engine.clients)).to.have.length(1);\n          expect(engine.clientsCount).to.be(1);\n          done();\n        });\n      });\n    });\n\n    it(\"should register a new client with custom id\", (done) => {\n      const engine = listen({ allowUpgrades: false }, (port) => {\n        expect(Object.keys(engine.clients)).to.have.length(0);\n        expect(engine.clientsCount).to.be(0);\n\n        const customId = \"CustomId\" + Date.now();\n\n        engine.generateId = (req) => customId;\n\n        const socket = new ClientSocket(`ws://localhost:${port}`);\n        socket.once(\"open\", () => {\n          expect(Object.keys(engine.clients)).to.have.length(1);\n          expect(engine.clientsCount).to.be(1);\n          expect(socket.id).to.be(customId);\n          expect(engine.clients[customId].id).to.be(customId);\n          done();\n        });\n      });\n    });\n\n    it(\"should register a new client with custom id (with a Promise)\", (done) => {\n      const engine = listen({ allowUpgrades: false }, (port) => {\n        const customId = \"CustomId\" + Date.now();\n\n        engine.generateId = () => Promise.resolve(customId);\n\n        const socket = new ClientSocket(`ws://localhost:${port}`);\n        socket.once(\"open\", () => {\n          expect(socket.id).to.be(customId);\n          expect(engine.clients[customId].id).to.be(customId);\n          done();\n        });\n      });\n    });\n\n    it(\"should disallow connection that are rejected by `generateId`\", (done) => {\n      const partialDone = createPartialDone(done, 2);\n\n      engine = listen({ allowUpgrades: false }, (port) => {\n        engine.generateId = () => {\n          return Promise.reject(new Error(\"nope\"));\n        };\n\n        engine.on(\"connection_error\", (err) => {\n          expect(err.req).to.be.ok();\n          expect(err.code).to.be(3);\n          expect(err.message).to.be(\"Bad request\");\n          expect(err.context.name).to.be(\"ID_GENERATION_ERROR\");\n          partialDone();\n        });\n\n        const socket = new ClientSocket(`ws://localhost:${port}`);\n        socket.on(\"error\", () => {\n          partialDone();\n        });\n      });\n    });\n\n    it(\"should disallow connection that are rejected by `generateId` (websocket only)\", function (done) {\n      if (process.env.EIO_WS_ENGINE === \"eiows\") {\n        return this.skip();\n      }\n      const partialDone = createPartialDone(done, 2);\n\n      engine = listen({ allowUpgrades: false }, (port) => {\n        engine.generateId = () => {\n          return Promise.reject(new Error(\"nope\"));\n        };\n\n        engine.on(\"connection_error\", (err) => {\n          expect(err.req).to.be.ok();\n          expect(err.code).to.be(3);\n          expect(err.message).to.be(\"Bad request\");\n          expect(err.context.name).to.be(\"ID_GENERATION_ERROR\");\n          partialDone();\n        });\n\n        const socket = new ClientSocket(`ws://localhost:${port}`, {\n          transports: [\"websocket\"],\n        });\n        socket.on(\"error\", () => {\n          partialDone();\n        });\n      });\n    });\n\n    it(\"should exchange handshake data\", (done) => {\n      listen({ allowUpgrades: false }, (port) => {\n        const socket = new ClientSocket(`ws://localhost:${port}`);\n        socket.on(\"handshake\", (obj) => {\n          expect(obj.sid).to.be.a(\"string\");\n          expect(obj.pingTimeout).to.be.a(\"number\");\n          expect(obj.upgrades).to.be.an(\"array\");\n          expect(obj.maxPayload).to.eql(1000000);\n          done();\n        });\n      });\n    });\n\n    it(\"should allow custom ping timeouts\", (done) => {\n      listen({ allowUpgrades: false, pingTimeout: 123 }, (port) => {\n        const socket = new ClientSocket(`http://localhost:${port}`);\n        socket.on(\"handshake\", (obj) => {\n          expect(obj.pingTimeout).to.be(123);\n          done();\n        });\n      });\n    });\n\n    it(\"should trigger a connection event with a Socket\", (done) => {\n      const engine = listen({ allowUpgrades: false }, (port) => {\n        new ClientSocket(`ws://localhost:${port}`);\n        engine.on(\"connection\", (socket) => {\n          expect(socket).to.be.an(Socket);\n          done();\n        });\n      });\n    });\n\n    it(\"should open with polling by default\", (done) => {\n      const engine = listen({ allowUpgrades: false }, (port) => {\n        new ClientSocket(`ws://localhost:${port}`);\n        engine.on(\"connection\", (socket) => {\n          expect(socket.transport.name).to.be(\"polling\");\n          done();\n        });\n      });\n    });\n\n    it(\"should be able to open with ws directly\", (done) => {\n      const engine = listen({ transports: [\"websocket\"] }, (port) => {\n        new ClientSocket(`ws://localhost:${port}`, {\n          transports: [\"websocket\"],\n        });\n        engine.on(\"connection\", (socket) => {\n          expect(socket.transport.name).to.be(\"websocket\");\n          done();\n        });\n      });\n    });\n\n    it(\"should not suggest any upgrades for websocket\", (done) => {\n      listen({ transports: [\"websocket\"] }, (port) => {\n        const socket = new ClientSocket(`ws://localhost:${port}`, {\n          transports: [\"websocket\"],\n        });\n        socket.on(\"handshake\", (obj) => {\n          expect(obj.upgrades).to.have.length(0);\n          done();\n        });\n      });\n    });\n\n    it(\"should not suggest upgrades when none are availble\", (done) => {\n      listen({ transports: [\"polling\"] }, (port) => {\n        const socket = new ClientSocket(`ws://localhost:${port}`, {});\n        socket.on(\"handshake\", (obj) => {\n          expect(obj.upgrades).to.have.length(0);\n          done();\n        });\n      });\n    });\n\n    it(\"should only suggest available upgrades\", (done) => {\n      listen({ transports: [\"polling\"] }, (port) => {\n        const socket = new ClientSocket(`ws://localhost:${port}`, {});\n        socket.on(\"handshake\", (obj) => {\n          expect(obj.upgrades).to.have.length(0);\n          done();\n        });\n      });\n    });\n\n    it(\"should suggest all upgrades when no transports are disabled\", (done) => {\n      listen({}, (port) => {\n        const socket = new ClientSocket(`ws://localhost:${port}`, {});\n        socket.on(\"handshake\", (obj) => {\n          expect(obj.upgrades).to.have.length(1);\n          expect(obj.upgrades).to.have.contain(\"websocket\");\n          done();\n        });\n      });\n    });\n\n    it(\"default to polling when proxy doesn't support websocket\", (done) => {\n      const partialDone = createPartialDone(done, 2);\n\n      engine = listen({ allowUpgrades: false }, (port) => {\n        engine.on(\"connection\", (socket) => {\n          socket.on(\"message\", (msg) => {\n            if (\"echo\" === msg) socket.send(msg);\n          });\n        });\n\n        engine.on(\"connection_error\", (err) => {\n          expect(err.req).to.be.ok();\n          expect(err.code).to.be(3);\n          expect(err.message).to.be(\"Bad request\");\n          expect(err.context.name).to.be(\"TRANSPORT_MISMATCH\");\n          expect(err.context.transport).to.be(\"websocket\");\n          expect(err.context.previousTransport).to.be(\"polling\");\n          partialDone();\n        });\n\n        var socket = new ClientSocket(`ws://localhost:${port}`);\n        socket.on(\"open\", () => {\n          request\n            .get(`http://localhost:${port}/engine.io/`)\n            .set({ connection: \"close\" })\n            .query({ transport: \"websocket\", sid: socket.id })\n            .end((err, res) => {\n              expect(err).to.be.an(Error);\n              expect(res.status).to.be(400);\n              expect(res.body.code).to.be(3);\n              socket.send(\"echo\");\n              socket.on(\"message\", (msg) => {\n                expect(msg).to.be(\"echo\");\n                partialDone();\n              });\n            });\n        });\n      });\n    });\n\n    it(\"should allow arbitrary data through query string\", (done) => {\n      const engine = listen({ allowUpgrades: false }, (port) => {\n        new ClientSocket(`ws://localhost:${port}`, { query: { a: \"b\" } });\n        engine.on(\"connection\", (conn) => {\n          expect(conn.request._query).to.have.keys(\"transport\", \"a\");\n          expect(conn.request._query.a).to.be(\"b\");\n          done();\n        });\n      });\n    });\n\n    it(\"should allow data through query string in uri\", (done) => {\n      const engine = listen({ allowUpgrades: false }, (port) => {\n        new ClientSocket(`ws://localhost:${port}?a=b&c=d`);\n        engine.on(\"connection\", (conn) => {\n          expect(conn.request._query.EIO).to.be.a(\"string\");\n          expect(conn.request._query.a).to.be(\"b\");\n          expect(conn.request._query.c).to.be(\"d\");\n          done();\n        });\n      });\n    });\n\n    it(\"should disallow bad requests (handshake error)\", function (done) {\n      const partialDone = createPartialDone(done, 2);\n\n      engine = listen(\n        {\n          cors: { credentials: true, origin: \"http://engine.io\" },\n        },\n        (port) => {\n          engine.on(\"connection_error\", (err) => {\n            expect(err.req).to.be.ok();\n            expect(err.code).to.be(3);\n            expect(err.message).to.be(\"Bad request\");\n            expect(err.context.name).to.be(\"TRANSPORT_HANDSHAKE_ERROR\");\n            partialDone();\n          });\n\n          request\n            .get(`http://localhost:${port}/engine.io/`)\n            .set(\"Origin\", \"http://engine.io\")\n            .query({ transport: \"websocket\" })\n            .end((err, res) => {\n              expect(err).to.be.an(Error);\n              expect(res.status).to.be(400);\n              expect(res.body.code).to.be(3);\n              expect(res.body.message).to.be(\"Bad request\");\n              expect(res.header[\"access-control-allow-credentials\"]).to.be(\n                \"true\"\n              );\n              expect(res.header[\"access-control-allow-origin\"]).to.be(\n                \"http://engine.io\"\n              );\n              partialDone();\n            });\n        }\n      );\n    });\n\n    it(\"should disallow invalid origin header\", function (done) {\n      if (process.env.EIO_WS_ENGINE === \"uws\") {\n        return this.skip();\n      }\n      const partialDone = createPartialDone(done, 2);\n\n      engine = listen((port) => {\n        // we can't send an invalid header through request.get\n        // so add an invalid char here\n        engine.prepare = function (req) {\n          Server.prototype.prepare.call(engine, req);\n          req.headers.origin += \"\\n\";\n        };\n\n        engine.on(\"connection_error\", (err) => {\n          expect(err.req).to.be.ok();\n          expect(err.code).to.be(3);\n          expect(err.message).to.be(\"Bad request\");\n          expect(err.context.name).to.be(\"INVALID_ORIGIN\");\n          expect(err.context.origin).to.be(\"http://engine.io/\\n\");\n          partialDone();\n        });\n\n        request\n          .get(`http://localhost:${port}/engine.io/`)\n          .set(\"Origin\", \"http://engine.io/\")\n          .query({ transport: \"websocket\" })\n          .end((err, res) => {\n            expect(err).to.be.an(Error);\n            expect(res.status).to.be(400);\n            expect(res.body.code).to.be(3);\n            expect(res.body.message).to.be(\"Bad request\");\n            partialDone();\n          });\n      });\n    });\n\n    it(\"should disallow invalid handshake method\", (done) => {\n      const partialDone = createPartialDone(done, 2);\n\n      engine = listen((port) => {\n        engine.on(\"connection_error\", (err) => {\n          expect(err.req).to.be.ok();\n          expect(err.code).to.be(2);\n          expect(err.message).to.be(\"Bad handshake method\");\n          expect(err.context.method).to.be(\"OPTIONS\");\n          partialDone();\n        });\n\n        request\n          .options(`http://localhost:${port}/engine.io/`)\n          .query({ transport: \"polling\" })\n          .end((err, res) => {\n            expect(err).to.be.an(Error);\n            expect(res.status).to.be(400);\n            expect(res.body.code).to.be(2);\n            expect(res.body.message).to.be(\"Bad handshake method\");\n            partialDone();\n          });\n      });\n    });\n\n    it(\"should disallow unsupported protocol versions\", (done) => {\n      const partialDone = createPartialDone(done, 2);\n\n      const httpServer = http.createServer();\n      const engine = new Server({ allowEIO3: false });\n      engine.attach(httpServer);\n      httpServer.listen(() => {\n        const port = httpServer.address().port;\n\n        engine.on(\"connection_error\", (err) => {\n          expect(err.req).to.be.ok();\n          expect(err.code).to.be(5);\n          expect(err.message).to.be(\"Unsupported protocol version\");\n          expect(err.context.protocol).to.be(3);\n\n          httpServer.close();\n          partialDone();\n        });\n\n        request\n          .get(`http://localhost:${port}/engine.io/`)\n          .query({ transport: \"polling\", EIO: 3 })\n          .end((err, res) => {\n            expect(err).to.be.an(Error);\n            expect(res.status).to.be(400);\n            expect(res.body.code).to.be(5);\n            expect(res.body.message).to.be(\"Unsupported protocol version\");\n            partialDone();\n          });\n      });\n    });\n\n    it(\"should send a packet along with the handshake\", (done) => {\n      listen({ initialPacket: \"faster!\" }, (port) => {\n        const socket = new ClientSocket(`ws://localhost:${port}`);\n        socket.on(\"open\", () => {\n          socket.on(\"message\", (msg) => {\n            expect(msg).to.be(\"faster!\");\n            done();\n          });\n        });\n      });\n    });\n\n    it(\"should support requests without trailing slash\", (done) => {\n      listen({ addTrailingSlash: false }, (port) => {\n        const partialDone = createPartialDone(done, 2);\n\n        request\n          .get(`http://localhost:${port}/engine.io`)\n          .query({ transport: \"polling\" })\n          .end((err, res) => {\n            expect(err).to.be(null);\n            expect(res.status).to.be(200);\n            partialDone();\n          });\n\n        request\n          .get(`http://localhost:${port}/engine.io/foo/bar/`)\n          .query({ transport: \"polling\" })\n          .end((err, res) => {\n            if (process.env.EIO_WS_ENGINE === \"uws\") {\n              expect(err).to.not.be(null);\n              expect(err.message).to.be(\"socket hang up\");\n            } else {\n              expect(err).to.be(null);\n              // this should not work, but it is kept for backward-compatibility\n              expect(res.status).to.be(200);\n            }\n            partialDone();\n          });\n      });\n    });\n  });\n\n  describe(\"close\", () => {\n    it(\"should be able to access non-empty writeBuffer at closing (server)\", (done) => {\n      const opts = { allowUpgrades: false };\n      const engine = listen(opts, (port) => {\n        new ClientSocket(`http://localhost:${port}`);\n        engine.on(\"connection\", (conn) => {\n          conn.on(\"close\", (reason) => {\n            expect(conn.writeBuffer.length).to.be(1);\n            setTimeout(() => {\n              expect(conn.writeBuffer.length).to.be(0); // writeBuffer has been cleared\n            }, 10);\n            done();\n          });\n          conn.writeBuffer.push({ type: \"message\", data: \"foo\" });\n          conn.onError(\"\");\n        });\n      });\n    });\n\n    it(\"should be able to access non-empty writeBuffer at closing (client)\", (done) => {\n      const opts = { allowUpgrades: false };\n      listen(opts, (port) => {\n        const socket = new ClientSocket(`http://localhost:${port}`);\n        socket.on(\"open\", () => {\n          socket.on(\"close\", (reason) => {\n            expect(socket.writeBuffer.length).to.be(1);\n            setTimeout(() => {\n              expect(socket.writeBuffer.length).to.be(0);\n            }, 10);\n            done();\n          });\n          socket.writeBuffer.push({ type: \"message\", data: \"foo\" });\n          socket.onError(\"\");\n        });\n      });\n    });\n\n    it(\"should trigger on server if the client does not pong\", (done) => {\n      const opts = { allowUpgrades: false, pingInterval: 5, pingTimeout: 5 };\n      const engine = listen(opts, (port) => {\n        const socket = new ClientSocket(`http://localhost:${port}`);\n        socket.sendPacket = () => {};\n        engine.on(\"connection\", (conn) => {\n          conn.on(\"close\", (reason) => {\n            expect(reason).to.be(\"ping timeout\");\n            done();\n          });\n        });\n      });\n    });\n\n    it(\"should trigger on server even when there is no outstanding polling request (GH-198)\", (done) => {\n      const opts = {\n        allowUpgrades: false,\n        pingInterval: 500,\n        pingTimeout: 500,\n      };\n      const engine = listen(opts, (port) => {\n        const socket = new ClientSocket(`http://localhost:${port}`);\n        engine.on(\"connection\", (conn) => {\n          conn.on(\"close\", (reason) => {\n            expect(reason).to.be(\"ping timeout\");\n            done();\n          });\n          // client abruptly disconnects, no polling request on this tick since we've just connected\n          socket.sendPacket = () => {};\n          socket.transport.removeListener(\"packet\");\n          socket.close();\n          // then server app tries to close the socket, since client disappeared\n          conn.close();\n        });\n      });\n    });\n\n    it(\"should trigger on client if server does not meet ping timeout\", (done) => {\n      const opts = { allowUpgrades: false, pingInterval: 50, pingTimeout: 30 };\n      listen(opts, (port) => {\n        const socket = new ClientSocket(`ws://localhost:${port}`);\n        socket.on(\"open\", () => {\n          // override onPacket and Transport#onClose to simulate an inactive server after handshake\n          socket.transport.removeListener(\"packet\");\n          socket.transport.removeListener(\"close\");\n          socket.on(\"close\", (reason, err) => {\n            expect(reason).to.be(\"ping timeout\");\n            done();\n          });\n        });\n      });\n    });\n\n    it(\"should trigger on both ends upon ping timeout\", (done) => {\n      const opts = { allowUpgrades: false, pingTimeout: 50, pingInterval: 50 };\n      const engine = listen(opts, (port) => {\n        const socket = new ClientSocket(`ws://localhost:${port}`);\n        let total = 2;\n\n        function onClose(reason, err) {\n          expect(reason).to.be(\"ping timeout\");\n          --total || done();\n        }\n\n        engine.on(\"connection\", (conn) => {\n          conn.on(\"close\", onClose);\n        });\n\n        socket.on(\"open\", () => {\n          // override onPacket and Transport#onClose to simulate an inactive server after handshake\n          socket.sendPacket = () => {};\n          socket.transport.removeListener(\"packet\");\n          socket.transport.removeListener(\"close\");\n          socket.on(\"close\", onClose);\n        });\n      });\n    });\n\n    it(\"should trigger when server closes a client\", (done) => {\n      const engine = listen({ allowUpgrades: false }, (port) => {\n        const socket = new ClientSocket(`ws://localhost:${port}`);\n        let total = 2;\n\n        engine.on(\"connection\", (conn) => {\n          conn.on(\"close\", (reason) => {\n            expect(reason).to.be(\"forced close\");\n            --total || done();\n          });\n          setTimeout(() => {\n            conn.close();\n          }, 10);\n        });\n\n        socket.on(\"open\", () => {\n          socket.on(\"close\", (reason) => {\n            expect(reason).to.be(\"transport close\");\n            --total || done();\n          });\n        });\n      });\n    });\n\n    it(\"should trigger when server closes a client (ws)\", (done) => {\n      const opts = { allowUpgrades: false, transports: [\"websocket\"] };\n      const engine = listen(opts, (port) => {\n        const socket = new ClientSocket(`ws://localhost:${port}`, {\n          transports: [\"websocket\"],\n        });\n        let total = 2;\n\n        engine.on(\"connection\", (conn) => {\n          conn.on(\"close\", (reason) => {\n            expect(reason).to.be(\"forced close\");\n            --total || done();\n          });\n          setTimeout(() => {\n            conn.close();\n          }, 10);\n        });\n\n        socket.on(\"open\", () => {\n          socket.on(\"close\", (reason) => {\n            expect(reason).to.be(\"transport close\");\n            --total || done();\n          });\n        });\n      });\n    });\n\n    it(\"should allow client reconnect after restarting (ws)\", function (done) {\n      if (process.env.EIO_WS_ENGINE === \"uws\") {\n        return this.skip();\n      }\n      const opts = { transports: [\"websocket\"] };\n      const engine = listen(opts, (port) => {\n        engine.httpServer.close();\n        engine.httpServer.listen(port);\n\n        const socket = new ClientSocket(`ws://localhost:${port}`, {\n          transports: [\"websocket\"],\n        });\n\n        engine.once(\"connection\", (conn) => {\n          setTimeout(() => {\n            conn.close();\n          }, 10);\n        });\n\n        socket.once(\"close\", (reason) => {\n          expect(reason).to.be(\"transport close\");\n          done();\n        });\n      });\n    });\n\n    it(\"should trigger when client closes\", (done) => {\n      const engine = listen({ allowUpgrades: false }, (port) => {\n        const socket = new ClientSocket(`ws://localhost:${port}`);\n        let total = 2;\n\n        engine.on(\"connection\", (conn) => {\n          conn.on(\"close\", (reason) => {\n            expect(reason).to.be(\"transport close\");\n            --total || done();\n          });\n        });\n\n        socket.on(\"open\", () => {\n          socket.on(\"close\", (reason) => {\n            expect(reason).to.be(\"forced close\");\n            --total || done();\n          });\n\n          setTimeout(() => {\n            socket.close();\n          }, 10);\n        });\n      });\n    });\n\n    it(\"should trigger when client closes (ws)\", (done) => {\n      const opts = { allowUpgrades: false, transports: [\"websocket\"] };\n      const engine = listen(opts, (port) => {\n        const socket = new ClientSocket(`ws://localhost:${port}`, {\n          transports: [\"websocket\"],\n        });\n        let total = 2;\n\n        engine.on(\"connection\", (conn) => {\n          conn.on(\"close\", (reason) => {\n            expect(reason).to.be(\"transport close\");\n            --total || done();\n          });\n        });\n\n        socket.on(\"open\", () => {\n          socket.on(\"close\", (reason) => {\n            expect(reason).to.be(\"forced close\");\n            --total || done();\n          });\n\n          setTimeout(() => {\n            socket.close();\n          }, 10);\n        });\n      });\n    });\n\n    it(\"should trigger when calling socket.close() in payload\", (done) => {\n      const engine = listen({ allowUpgrades: false }, (port) => {\n        const socket = new ClientSocket(`ws://localhost:${port}`);\n\n        engine.on(\"connection\", (conn) => {\n          conn.send(null, () => {\n            socket.close();\n          });\n          conn.send(\"this should not be handled\");\n\n          conn.on(\"close\", (reason) => {\n            expect(reason).to.be(\"transport close\");\n            done();\n          });\n        });\n\n        socket.on(\"open\", () => {\n          socket.on(\"message\", (msg) => {\n            expect(msg).to.not.be(\"this should not be handled\");\n          });\n\n          socket.on(\"close\", (reason) => {\n            expect(reason).to.be(\"forced close\");\n          });\n        });\n      });\n    });\n\n    it(\"should abort upgrade if socket is closed (GH-35)\", (done) => {\n      listen({ allowUpgrades: true }, (port) => {\n        const socket = new ClientSocket(`ws://localhost:${port}`);\n        socket.on(\"open\", () => {\n          socket.close();\n          // we wait until complete to see if we get an uncaught EPIPE\n          setTimeout(() => {\n            done();\n          }, 100);\n        });\n      });\n    });\n\n    it(\"should abort connection when upgrade fails\", (done) => {\n      listen({ allowUpgrades: true }, (port) => {\n        const req = http.request(\n          {\n            port,\n            path: \"/engine.io/\",\n            headers: {\n              connection: \"Upgrade\",\n              upgrade: \"websocket\",\n            },\n          },\n          (res) => {\n            expect(res.statusCode).to.eql(400);\n            res.resume();\n            res.on(\"end\", done);\n          }\n        );\n        req.end();\n      });\n    });\n\n    it(\n      \"should trigger if a poll request is ongoing and the underlying \" +\n        \"socket closes, as in a browser tab close\",\n      ($done) => {\n        const engine = listen({ allowUpgrades: false }, (port) => {\n          // hack to access the sockets created by node-xmlhttprequest\n          // see: https://github.com/driverdan/node-XMLHttpRequest/issues/44\n          const request = require(\"http\").request;\n          const sockets = [];\n          http.request = function (opts) {\n            const req = request.apply(null, arguments);\n            req.on(\"socket\", (socket) => {\n              sockets.push(socket);\n            });\n            return req;\n          };\n\n          function done() {\n            http.request = request;\n            $done();\n          }\n\n          var socket = new ClientSocket(`ws://localhost:${port}`);\n          let serverSocket;\n\n          engine.on(\"connection\", (s) => {\n            serverSocket = s;\n          });\n\n          socket.transport.on(\"poll\", () => {\n            // we set a timer to wait for the request to actually reach\n            setTimeout(() => {\n              // at this time server's `connection` should have been fired\n              expect(serverSocket).to.be.an(\"object\");\n\n              // OPENED readyState is expected - we are actually polling\n              expect(socket.transport.pollXhr.xhr.readyState).to.be(1);\n\n              // 2 requests sent to the server over an unique port means\n              // we should have been assigned 2 sockets\n              expect(sockets.length).to.be(2);\n\n              // expect the socket to be open at this point\n              expect(serverSocket.readyState).to.be(\"open\");\n\n              // kill the underlying connection\n              sockets[1].end();\n              serverSocket.on(\"close\", (reason, err) => {\n                expect(reason).to.be(\"transport error\");\n                expect(err.message).to.be(\"poll connection closed prematurely\");\n                done();\n              });\n            }, 50);\n          });\n        });\n      }\n    );\n\n    it(\"should not trigger with connection: close header\", ($done) => {\n      const engine = listen({ allowUpgrades: false }, (port) => {\n        // intercept requests to add connection: close\n        const request = http.request;\n        http.request = function () {\n          const opts = arguments[0];\n          opts.headers = opts.headers || {};\n          opts.headers.Connection = \"close\";\n          return request.apply(this, arguments);\n        };\n\n        function done() {\n          http.request = request;\n          $done();\n        }\n\n        engine.on(\"connection\", (socket) => {\n          socket.on(\"message\", (msg) => {\n            expect(msg).to.equal(\"test\");\n            socket.send(\"woot\");\n          });\n        });\n\n        var socket = new ClientSocket(`ws://localhost:${port}`);\n        socket.on(\"open\", () => {\n          socket.send(\"test\");\n        });\n        socket.on(\"message\", (msg) => {\n          expect(msg).to.be(\"woot\");\n          done();\n        });\n      });\n    });\n\n    it(\n      \"should not trigger early with connection `ping timeout`\" +\n        \"after post handshake timeout\",\n      (done) => {\n        // first timeout should trigger after `pingInterval + pingTimeout`,\n        // not just `pingTimeout`.\n        const opts = {\n          allowUpgrades: false,\n          pingInterval: 300,\n          pingTimeout: 100,\n        };\n        listen(opts, (port) => {\n          const socket = new ClientSocket(`ws://localhost:${port}`);\n          let clientCloseReason = null;\n\n          socket.on(\"handshake\", () => {\n            socket.transport.removeListener(\"packet\");\n          });\n          socket.on(\"open\", () => {\n            socket.on(\"close\", (reason) => {\n              clientCloseReason = reason;\n            });\n          });\n\n          setTimeout(() => {\n            expect(clientCloseReason).to.be(null);\n            done();\n          }, 200);\n        });\n      }\n    );\n\n    it(\n      \"should not trigger early with connection `ping timeout` \" +\n        \"after post ping timeout\",\n      (done) => {\n        // ping timeout should trigger after `pingInterval + pingTimeout`,\n        // not just `pingTimeout`.\n        const opts = {\n          allowUpgrades: false,\n          pingInterval: 80,\n          pingTimeout: 50,\n        };\n        const engine = listen(opts, (port) => {\n          const socket = new ClientSocket(`ws://localhost:${port}`);\n          let clientCloseReason = null;\n\n          engine.on(\"connection\", (conn) => {\n            conn.on(\"heartbeat\", () => {\n              conn.onPacket = () => {};\n            });\n          });\n\n          socket.on(\"open\", () => {\n            socket.on(\"close\", (reason) => {\n              clientCloseReason = reason;\n            });\n          });\n\n          setTimeout(() => {\n            expect(clientCloseReason).to.be(null);\n            done();\n          }, 100);\n        });\n      }\n    );\n\n    it(\n      \"should trigger early with connection `transport close` \" +\n        \"after missing pong\",\n      (done) => {\n        // ping timeout should trigger after `pingInterval + pingTimeout`,\n        // not just `pingTimeout`.\n        const opts = {\n          allowUpgrades: false,\n          pingInterval: 80,\n          pingTimeout: 50,\n        };\n        const engine = listen(opts, (port) => {\n          const socket = new ClientSocket(`ws://localhost:${port}`);\n          let clientCloseReason = null;\n\n          socket.on(\"open\", () => {\n            socket.on(\"close\", (reason) => {\n              clientCloseReason = reason;\n            });\n          });\n\n          engine.on(\"connection\", (conn) => {\n            conn.on(\"heartbeat\", () => {\n              setTimeout(() => {\n                conn.close();\n              }, 20);\n              setTimeout(() => {\n                expect(clientCloseReason).to.be(\"transport close\");\n                done();\n              }, 100);\n            });\n          });\n        });\n      }\n    );\n\n    if (process.env.EIO_CLIENT === \"3\") {\n      it(\n        \"should trigger with connection `ping timeout` \" +\n          \"after `pingInterval + pingTimeout`\",\n        (done) => {\n          const opts = {\n            allowUpgrades: false,\n            pingInterval: 300,\n            pingTimeout: 100,\n          };\n          const engine = listen(opts, (port) => {\n            const socket = new ClientSocket(`ws://localhost:${port}`);\n            let clientCloseReason = null;\n\n            socket.on(\"open\", () => {\n              socket.on(\"close\", (reason) => {\n                clientCloseReason = reason;\n              });\n            });\n\n            engine.on(\"connection\", (conn) => {\n              conn.once(\"heartbeat\", () => {\n                setTimeout(() => {\n                  socket.transport.removeListener(\"packet\");\n                  expect(clientCloseReason).to.be(null);\n                }, 150);\n                setTimeout(() => {\n                  expect(clientCloseReason).to.be(null);\n                }, 350);\n                setTimeout(() => {\n                  expect(clientCloseReason).to.be(\"ping timeout\");\n                  done();\n                }, 500);\n              });\n            });\n          });\n        }\n      );\n    } else {\n      it(\n        \"should trigger with connection `ping timeout` \" +\n          \"after `pingInterval + pingTimeout`\",\n        (done) => {\n          const opts = {\n            allowUpgrades: false,\n            pingInterval: 300,\n            pingTimeout: 100,\n          };\n          const engine = listen(opts, (port) => {\n            const socket = new ClientSocket(`ws://localhost:${port}`);\n            let clientCloseReason = null;\n\n            socket.on(\"open\", () => {\n              socket.on(\"close\", (reason) => {\n                clientCloseReason = reason;\n              });\n            });\n\n            engine.on(\"connection\", (conn) => {\n              conn.once(\"heartbeat\", () => {\n                socket.transport.removeListener(\"packet\");\n                setTimeout(() => {\n                  expect(clientCloseReason).to.be(null);\n                }, 150);\n                setTimeout(() => {\n                  expect(clientCloseReason).to.be(null);\n                }, 350);\n                setTimeout(() => {\n                  expect(clientCloseReason).to.be(\"ping timeout\");\n                  done();\n                }, 500);\n              });\n            });\n          });\n        }\n      );\n    }\n\n    it(\n      \"should abort the polling data request if it is \" + \"in progress\",\n      function (done) {\n        if (process.env.EIO_WS_ENGINE === \"uws\") {\n          return this.skip();\n        }\n        const engine = listen({ transports: [\"polling\"] }, (port) => {\n          const socket = new ClientSocket(`http://localhost:${port}`);\n\n          engine.on(\"connection\", (conn) => {\n            const onDataRequest = conn.transport.onDataRequest;\n            conn.transport.onDataRequest = (req, res) => {\n              engine.httpServer.close(done);\n              onDataRequest.call(conn.transport, req, res);\n              req.removeAllListeners();\n              conn.close();\n            };\n          });\n\n          socket.on(\"open\", () => {\n            socket.send(\"test\");\n          });\n        });\n      }\n    );\n\n    // tests https://github.com/LearnBoost/engine.io-client/issues/207\n    // websocket test, transport error\n    it(\"should trigger transport close before open for ws\", (done) => {\n      const opts = { transports: [\"websocket\"] };\n      listen(opts, (port) => {\n        const url = `ws://0.0.0.0:${port}`;\n        const socket = new ClientSocket(url);\n        socket.on(\"open\", () => {\n          done(new Error(\"Test invalidation\"));\n        });\n        socket.on(\"close\", (reason) => {\n          expect(reason).to.be(\"transport error\");\n          done();\n        });\n      });\n    });\n\n    // tests https://github.com/LearnBoost/engine.io-client/issues/207\n    // polling test, transport error\n    it(\"should trigger transport close before open for xhr\", (done) => {\n      const opts = { transports: [\"polling\"] };\n      listen(opts, (port) => {\n        const socket = new ClientSocket(`http://invalidserver:${port}`);\n        socket.on(\"open\", () => {\n          done(new Error(\"Test invalidation\"));\n        });\n        socket.on(\"close\", (reason) => {\n          expect(reason).to.be(\"transport error\");\n          done();\n        });\n      });\n    });\n\n    // tests https://github.com/LearnBoost/engine.io-client/issues/207\n    // websocket test, force close\n    it(\"should trigger force close before open for ws\", (done) => {\n      const opts = { transports: [\"websocket\"] };\n      listen(opts, (port) => {\n        const socket = new ClientSocket(`ws://localhost:${port}`);\n        socket.on(\"open\", () => {\n          done(new Error(\"Test invalidation\"));\n        });\n        socket.on(\"close\", (reason) => {\n          expect(reason).to.be(\"forced close\");\n          done();\n        });\n        socket.close();\n      });\n    });\n\n    // tests https://github.com/LearnBoost/engine.io-client/issues/207\n    // polling test, force close\n    it(\"should trigger force close before open for xhr\", (done) => {\n      const opts = { transports: [\"polling\"] };\n      listen(opts, (port) => {\n        const socket = new ClientSocket(`http://localhost:${port}`);\n        socket.on(\"open\", () => {\n          done(new Error(\"Test invalidation\"));\n        });\n        socket.on(\"close\", (reason) => {\n          expect(reason).to.be(\"forced close\");\n          done();\n        });\n        socket.close();\n      });\n    });\n\n    it(\"should close transport upon ping timeout (ws)\", (done) => {\n      const opts = {\n        allowUpgrades: false,\n        transports: [\"websocket\"],\n        pingInterval: 50,\n        pingTimeout: 30,\n      };\n      const engine = listen(opts, (port) => {\n        engine.on(\"connection\", (conn) => {\n          conn.transport.on(\"close\", done);\n        });\n        const socket = new ClientSocket(`ws://localhost:${port}`, {\n          transports: [\"websocket\"],\n        });\n        // override to simulate an inactive client\n        socket.sendPacket = socket.onHeartbeat = () => {};\n      });\n    });\n\n    it(\"should close transport upon ping timeout (polling)\", (done) => {\n      const opts = {\n        allowUpgrades: false,\n        transports: [\"polling\"],\n        pingInterval: 50,\n        pingTimeout: 30,\n      };\n      const engine = listen(opts, (port) => {\n        engine.on(\"connection\", (conn) => {\n          conn.transport.on(\"close\", done);\n        });\n        const socket = new ClientSocket(`ws://localhost:${port}`, {\n          transports: [\"polling\"],\n        });\n        // override to simulate an inactive client\n        socket.sendPacket = socket.onHeartbeat = () => {};\n      });\n    });\n\n    it(\"should close transport upon parse error (ws)\", (done) => {\n      const opts = { allowUpgrades: false, transports: [\"websocket\"] };\n      const engine = listen(opts, (port) => {\n        engine.on(\"connection\", (conn) => {\n          conn.transport.on(\"close\", done);\n        });\n        const socket = new ClientSocket(`ws://localhost:${port}`, {\n          transports: [\"websocket\"],\n        });\n        socket.on(\"open\", () => {\n          socket.transport.ws.send(\"invalid\");\n        });\n      });\n    });\n\n    it(\"should close transport upon parse error (polling)\", (done) => {\n      const opts = { allowUpgrades: false, transports: [\"polling\"] };\n      const engine = listen(opts, (port) => {\n        engine.on(\"connection\", (conn) => {\n          conn.transport.closeTimeout = 100;\n          conn.transport.on(\"close\", done);\n        });\n        const socket = new ClientSocket(`ws://localhost:${port}`, {\n          transports: [\"polling\"],\n        });\n        socket.on(\"open\", () => {\n          socket.transport.doWrite(\"invalid\", () => {});\n        });\n      });\n    });\n\n    it(\"should close upgrading transport upon socket close\", (done) => {\n      const engine = listen((port) => {\n        engine.on(\"connection\", (conn) => {\n          conn.on(\"upgrading\", (transport) => {\n            transport.on(\"close\", done);\n            conn.close();\n          });\n        });\n        new ClientSocket(`ws://localhost:${port}`);\n      });\n    });\n\n    it(\"should close upgrading transport upon upgrade timeout\", (done) => {\n      const opts = { upgradeTimeout: 100 };\n      const engine = listen(opts, (port) => {\n        engine.on(\"connection\", (conn) => {\n          conn.on(\"upgrading\", (transport) => {\n            transport.on(\"close\", done);\n          });\n        });\n        const socket = new ClientSocket(`ws://localhost:${port}`);\n        socket.on(\"upgrading\", (transport) => {\n          // override not to complete upgrading\n          transport.send = () => {};\n        });\n      });\n    });\n\n    it(\"should not timeout after an upgrade\", (done) => {\n      const opts = { pingInterval: 200, pingTimeout: 20 };\n      const engine = listen(opts, (port) => {\n        const socket = new ClientSocket(`ws://localhost:${port}`);\n        socket.on(\"open\", () => {\n          setTimeout(() => {\n            socket.removeListener(\"close\");\n            engine.close();\n            socket.close();\n            done();\n          }, 500);\n        });\n        socket.on(\"close\", () => {\n          done(new Error(\"should not happen\"));\n        });\n      });\n    });\n\n    it(\"should not crash when messing with Object prototype\", (done) => {\n      Object.prototype.foo = \"bar\"; // eslint-disable-line no-extend-native\n      const engine = listen({ allowUpgrades: true }, (port) => {\n        const socket = new ClientSocket(`ws://localhost:${port}`);\n        socket.on(\"open\", () => {\n          engine.close();\n          setTimeout(() => {\n            done();\n          }, 100);\n        });\n      });\n    });\n\n    describe(\"graceful close\", () => {\n      before(function () {\n        if (process.env.EIO_WS_ENGINE === \"uws\") {\n          this.skip();\n        }\n      });\n\n      function fixture(filename) {\n        return (\n          process.execPath + \" \" + path.join(__dirname, \"fixtures\", filename)\n        );\n      }\n\n      it(\"should stop socket and timers\", (done) => {\n        exec(fixture(\"server-close.js\"), done);\n      });\n\n      it(\"should stop upgraded socket and timers\", (done) => {\n        exec(fixture(\"server-close-upgraded.js\"), done);\n      });\n\n      it(\"should stop upgrading socket and timers\", (done) => {\n        exec(fixture(\"server-close-upgrading.js\"), done);\n      });\n    });\n  });\n\n  describe(\"messages\", function () {\n    this.timeout(5000);\n\n    it(\"should arrive from server to client\", (done) => {\n      const engine = listen({ allowUpgrades: false }, (port) => {\n        const socket = new ClientSocket(`ws://localhost:${port}`);\n        engine.on(\"connection\", (conn) => {\n          conn.send(\"a\");\n        });\n        socket.on(\"open\", () => {\n          socket.on(\"message\", (msg) => {\n            expect(msg).to.be(\"a\");\n            done();\n          });\n        });\n      });\n    });\n\n    it(\"should arrive from server to client (multiple)\", (done) => {\n      const engine = listen({ allowUpgrades: false }, (port) => {\n        const socket = new ClientSocket(`ws://localhost:${port}`);\n        const expected = [\"a\", \"b\", \"c\"];\n        let i = 0;\n\n        engine.on(\"connection\", (conn) => {\n          conn.send(\"a\");\n          // we use set timeouts to ensure the messages are delivered as part\n          // of different.\n          setTimeout(() => {\n            conn.send(\"b\");\n\n            setTimeout(() => {\n              // here we make sure we buffer both the close packet and\n              // a regular packet\n              conn.send(\"c\");\n              conn.close();\n            }, 50);\n          }, 50);\n\n          conn.on(\"close\", () => {\n            // since close fires right after the buffer is drained\n            setTimeout(() => {\n              expect(i).to.be(3);\n              done();\n            }, 50);\n          });\n        });\n        socket.on(\"open\", () => {\n          socket.on(\"message\", (msg) => {\n            expect(msg).to.be(expected[i++]);\n          });\n        });\n      });\n    });\n\n    it(\"should not be receiving data when getting a message longer than maxHttpBufferSize when polling\", (done) => {\n      const opts = {\n        allowUpgrades: false,\n        transports: [\"polling\"],\n        maxHttpBufferSize: 5,\n      };\n      const engine = listen(opts, (port) => {\n        const socket = new ClientSocket(`ws://localhost:${port}`);\n        engine.on(\"connection\", (conn) => {\n          conn.on(\"message\", (msg) => {\n            done(\n              new Error(\"Test invalidation (message is longer than allowed)\")\n            );\n          });\n        });\n        socket.on(\"open\", () => {\n          socket.send(\"aasdasdakjhasdkjhasdkjhasdkjhasdkjhasdkjhasdkjha\");\n        });\n        socket.on(\"close\", () => {\n          done();\n        });\n      });\n    });\n\n    it(\"should not be receiving data when getting a message longer than maxHttpBufferSize (websocket)\", (done) => {\n      const opts = { maxHttpBufferSize: 5 };\n      const engine = listen(opts, (port) => {\n        const socket = new ClientSocket(`ws://localhost:${port}`, {\n          transports: [\"websocket\"],\n        });\n        engine.on(\"connection\", (conn) => {\n          conn.on(\"message\", (msg) => {\n            done(\n              new Error(\"Test invalidation (message is longer than allowed)\")\n            );\n          });\n        });\n        socket.on(\"open\", () => {\n          socket.send(\"aasdasdakjhasdkjhasdkjhasdkjhasdkjhasdkjhasdkjha\");\n        });\n        socket.on(\"close\", () => {\n          done();\n        });\n      });\n    });\n\n    it(\"should receive data when getting a message shorter than maxHttpBufferSize when polling\", (done) => {\n      const opts = {\n        allowUpgrades: false,\n        transports: [\"polling\"],\n        maxHttpBufferSize: 5,\n      };\n      const engine = listen(opts, (port) => {\n        const socket = new ClientSocket(`ws://localhost:${port}`);\n        engine.on(\"connection\", (conn) => {\n          conn.on(\"message\", (msg) => {\n            expect(msg).to.be(\"a\");\n            done();\n          });\n        });\n        socket.on(\"open\", () => {\n          socket.send(\"a\");\n        });\n      });\n    });\n\n    it(\"should arrive from server to client (ws)\", (done) => {\n      const opts = { allowUpgrades: false, transports: [\"websocket\"] };\n      const engine = listen(opts, (port) => {\n        const socket = new ClientSocket(`ws://localhost:${port}`, {\n          transports: [\"websocket\"],\n        });\n        engine.on(\"connection\", (conn) => {\n          conn.send(\"a\");\n        });\n        socket.on(\"open\", () => {\n          socket.on(\"message\", (msg) => {\n            expect(msg).to.be(\"a\");\n            done();\n          });\n        });\n      });\n    });\n\n    it(\"should arrive from server to client (multiple, ws)\", (done) => {\n      const opts = { allowUpgrades: false, transports: [\"websocket\"] };\n      const engine = listen(opts, (port) => {\n        const socket = new ClientSocket(`ws://localhost:${port}`, {\n          transports: [\"websocket\"],\n        });\n        const expected = [\"a\", \"b\", \"c\"];\n        let i = 0;\n\n        engine.on(\"connection\", (conn) => {\n          conn.send(\"a\");\n          setTimeout(() => {\n            conn.send(\"b\");\n            setTimeout(() => {\n              conn.send(\"c\");\n              conn.close();\n            }, 50);\n          }, 50);\n          conn.on(\"close\", () => {\n            setTimeout(() => {\n              expect(i).to.be(3);\n              done();\n            }, 50);\n          });\n        });\n\n        socket.on(\"open\", () => {\n          socket.on(\"message\", (msg) => {\n            expect(msg).to.be(expected[i++]);\n          });\n        });\n      });\n    });\n\n    it(\"should arrive from server to client (multiple, no delay, ws)\", (done) => {\n      const opts = { allowUpgrades: false, transports: [\"websocket\"] };\n      const engine = listen(opts, (port) => {\n        const socket = new ClientSocket(`ws://localhost:${port}`, {\n          transports: [\"websocket\"],\n        });\n        const expected = [\"a\", \"b\", \"c\"];\n        let i = 0;\n\n        engine.on(\"connection\", (conn) => {\n          conn.on(\"close\", () => {\n            setTimeout(() => {\n              expect(i).to.be(3);\n              done();\n            }, 50);\n          });\n          conn.send(\"a\");\n          conn.send(\"b\");\n          conn.send(\"c\");\n          conn.close();\n        });\n\n        socket.on(\"open\", () => {\n          socket.on(\"message\", (msg) => {\n            expect(msg).to.be(expected[i++]);\n          });\n        });\n      });\n    });\n\n    it(\"should arrive when binary data is sent as Int8Array (ws)\", (done) => {\n      const binaryData = new Int8Array(5);\n      for (let i = 0; i < binaryData.length; i++) {\n        binaryData[i] = i;\n      }\n\n      const opts = { allowUpgrades: false, transports: [\"websocket\"] };\n      const engine = listen(opts, (port) => {\n        const socket = new ClientSocket(`ws://localhost:${port}`, {\n          transports: [\"websocket\"],\n        });\n\n        engine.on(\"connection\", (conn) => {\n          conn.send(binaryData);\n        });\n\n        socket.on(\"open\", () => {\n          socket.on(\"message\", (msg) => {\n            for (let i = 0; i < binaryData.length; i++) {\n              const num = msg.readInt8(i);\n              expect(num).to.be(i);\n            }\n            done();\n          });\n        });\n      });\n    });\n\n    it(\"should arrive when binary data is sent as Int32Array (ws)\", (done) => {\n      const binaryData = new Int32Array(5);\n      for (let i = 0; i < binaryData.length; i++) {\n        binaryData[i] = (i + 100) * 9823;\n      }\n\n      const opts = { allowUpgrades: false, transports: [\"websocket\"] };\n      const engine = listen(opts, (port) => {\n        const socket = new ClientSocket(`ws://localhost:${port}`, {\n          transports: [\"websocket\"],\n        });\n\n        engine.on(\"connection\", (conn) => {\n          conn.send(binaryData);\n        });\n\n        socket.on(\"open\", () => {\n          socket.on(\"message\", (msg) => {\n            let i = 0,\n              ii = 0;\n            for (; ii < binaryData.length; i += 4, ii++) {\n              const num = msg.readInt32LE(i);\n              expect(num).to.be((ii + 100) * 9823);\n            }\n            done();\n          });\n        });\n      });\n    });\n\n    it(\"should arrive when binary data is sent as Int32Array, given as ArrayBuffer(ws)\", (done) => {\n      const binaryData = new Int32Array(5);\n      for (let i = 0; i < binaryData.length; i++) {\n        binaryData[i] = (i + 100) * 9823;\n      }\n\n      const opts = { allowUpgrades: false, transports: [\"websocket\"] };\n      const engine = listen(opts, (port) => {\n        const socket = new ClientSocket(`ws://localhost:${port}`, {\n          transports: [\"websocket\"],\n        });\n\n        engine.on(\"connection\", (conn) => {\n          conn.send(binaryData.buffer);\n        });\n\n        socket.on(\"open\", () => {\n          socket.on(\"message\", (msg) => {\n            let i = 0,\n              ii = 0;\n            for (; ii < binaryData.length; i += 4, ii++) {\n              const num = msg.readInt32LE(i);\n              expect(num).to.be((ii + 100) * 9823);\n            }\n            done();\n          });\n        });\n      });\n    });\n\n    it(\"should arrive when binary data is sent as Buffer (ws)\", (done) => {\n      const binaryData = Buffer.allocUnsafe(5);\n      for (let i = 0; i < binaryData.length; i++) {\n        binaryData.writeInt8(i, i);\n      }\n\n      const opts = { allowUpgrades: false, transports: [\"websocket\"] };\n      const engine = listen(opts, (port) => {\n        const socket = new ClientSocket(`ws://localhost:${port}`, {\n          transports: [\"websocket\"],\n        });\n\n        engine.on(\"connection\", (conn) => {\n          conn.send(binaryData);\n        });\n\n        socket.on(\"open\", () => {\n          socket.on(\"message\", (msg) => {\n            for (let i = 0; i < binaryData.length; i++) {\n              const num = msg.readInt8(i);\n              expect(num).to.be(i);\n            }\n            done();\n          });\n        });\n      });\n    });\n\n    it(\"should arrive when binary data sent as Buffer (polling)\", (done) => {\n      const binaryData = Buffer.allocUnsafe(5);\n      for (let i = 0; i < binaryData.length; i++) {\n        binaryData.writeInt8(i, i);\n      }\n\n      const opts = { allowUpgrades: false, transports: [\"polling\"] };\n      const engine = listen(opts, (port) => {\n        const socket = new ClientSocket(`ws://localhost:${port}`, {\n          transports: [\"polling\"],\n        });\n\n        engine.on(\"connection\", (conn) => {\n          conn.send(binaryData);\n        });\n\n        socket.on(\"open\", () => {\n          socket.on(\"message\", (msg) => {\n            for (let i = 0; i < binaryData.length; i++) {\n              const num = msg.readInt8(i);\n              expect(num).to.be(i);\n            }\n\n            done();\n          });\n        });\n      });\n    });\n\n    it(\"should arrive as ArrayBuffer if requested when binary data sent as Buffer (ws)\", (done) => {\n      const binaryData = Buffer.allocUnsafe(5);\n      for (let i = 0; i < binaryData.length; i++) {\n        binaryData.writeInt8(i, i);\n      }\n\n      const opts = { allowUpgrades: false, transports: [\"websocket\"] };\n      const engine = listen(opts, (port) => {\n        const socket = new ClientSocket(`ws://localhost:${port}`, {\n          transports: [\"websocket\"],\n        });\n        socket.binaryType = \"arraybuffer\";\n\n        engine.on(\"connection\", (conn) => {\n          conn.send(binaryData);\n        });\n\n        socket.on(\"open\", () => {\n          socket.on(\"message\", (msg) => {\n            expect(msg instanceof ArrayBuffer).to.be(true);\n            const intArray = new Int8Array(msg);\n            for (let i = 0; i < binaryData.length; i++) {\n              expect(intArray[i]).to.be(i);\n            }\n\n            done();\n          });\n        });\n      });\n    });\n\n    it(\"should arrive when content is split in multiple chunks (polling)\", (done) => {\n      const engine = listen(\n        {\n          maxHttpBufferSize: 1e10,\n        },\n        (port) => {\n          const client = new ClientSocket(`ws://localhost:${port}`, {\n            transports: [\"polling\"],\n          });\n\n          engine.on(\"connection\", (socket) => {\n            socket.on(\"message\", (data) => {\n              client.close();\n              done();\n            });\n          });\n\n          client.on(\"open\", () => {\n            client.send(\"a\".repeat(1e6));\n          });\n        }\n      );\n    });\n\n    it(\"should arrive when content is sent with chunked transfer-encoding (polling)\", function (done) {\n      if (process.env.EIO_WS_ENGINE === \"uws\") {\n        // \u00b5WebSockets.js does not currently support chunked encoding: https://github.com/uNetworking/uWebSockets.js/issues/669\n        return this.skip();\n      }\n      const engine = listen((port) => {\n        const client = new ClientSocket(`ws://localhost:${port}`, {\n          transports: [\"polling\"],\n        });\n\n        engine.on(\"connection\", (socket) => {\n          socket.on(\"message\", (data) => {\n            expect(data).to.eql(\"123\");\n\n            client.close();\n            done();\n          });\n        });\n\n        client.on(\"open\", () => {\n          const req = http.request({\n            host: \"localhost\",\n            port,\n            path: `/engine.io/?EIO=4&transport=polling&sid=${client.id}`,\n            method: \"POST\",\n          });\n\n          req.write(process.env.EIO_CLIENT === \"3\" ? \"4:41\" : \"41\");\n          req.write(\"2\");\n          req.write(\"3\");\n          req.end();\n        });\n      });\n    });\n\n    it(\"should arrive as ArrayBuffer if requested when binary data sent as Buffer (polling)\", (done) => {\n      const binaryData = Buffer.allocUnsafe(5);\n      for (let i = 0; i < binaryData.length; i++) {\n        binaryData.writeInt8(i, i);\n      }\n\n      const opts = { allowUpgrades: false, transports: [\"polling\"] };\n      const engine = listen(opts, (port) => {\n        const socket = new ClientSocket(`ws://localhost:${port}`, {\n          transports: [\"polling\"],\n        });\n        socket.binaryType = \"arraybuffer\";\n\n        engine.on(\"connection\", (conn) => {\n          conn.send(binaryData);\n        });\n\n        socket.on(\"open\", () => {\n          socket.on(\"message\", (msg) => {\n            expect(msg instanceof ArrayBuffer).to.be(true);\n            const intArray = new Int8Array(msg);\n            for (let i = 0; i < binaryData.length; i++) {\n              expect(intArray[i]).to.be(i);\n            }\n\n            done();\n          });\n        });\n      });\n    });\n\n    it(\"should trigger a flush/drain event\", (done) => {\n      const engine = listen({ allowUpgrades: false }, (port) => {\n        engine.on(\"connection\", (socket) => {\n          let totalEvents = 4;\n\n          engine.on(\"flush\", (sock, buf) => {\n            expect(sock).to.be(socket);\n            expect(buf).to.be.an(\"array\");\n            --totalEvents || done();\n          });\n          socket.on(\"flush\", (buf) => {\n            expect(buf).to.be.an(\"array\");\n            --totalEvents || done();\n          });\n\n          engine.on(\"drain\", (sock) => {\n            expect(sock).to.be(socket);\n            expect(socket.writeBuffer.length).to.be(0);\n            --totalEvents || done();\n          });\n          socket.on(\"drain\", () => {\n            expect(socket.writeBuffer.length).to.be(0);\n            --totalEvents || done();\n          });\n\n          socket.send(\"aaaa\");\n        });\n\n        new ClientSocket(`ws://localhost:${port}`);\n      });\n    });\n\n    it(\n      \"should interleave with pongs if many messages buffered \" +\n        \"after connection open\",\n      function (done) {\n        if (process.env.EIO_WS_ENGINE === \"uws\") {\n          return this.skip();\n        }\n        this.slow(4000);\n        this.timeout(8000);\n\n        const opts = {\n          transports: [\"websocket\"],\n          pingInterval: 200,\n          pingTimeout: 100,\n        };\n\n        const engine = listen(opts, (port) => {\n          const messageCount = 100;\n          const messagePayload = new Array(256 * 256).join(\"a\");\n          let connection = null;\n          engine.on(\"connection\", (conn) => {\n            connection = conn;\n          });\n          const socket = new ClientSocket(`ws://localhost:${port}`, {\n            transports: [\"websocket\"],\n          });\n          socket.on(\"open\", () => {\n            for (let i = 0; i < messageCount; i++) {\n              //            connection.send('message: ' + i);   // works\n              connection.send(messagePayload + \"|message: \" + i); // does not work\n            }\n            let receivedCount = 0;\n            socket.on(\"message\", (msg) => {\n              receivedCount += 1;\n              if (receivedCount === messageCount) {\n                done();\n              }\n            });\n          });\n        });\n      }\n    );\n\n    it(\"should support chinese\", (done) => {\n      const engine = listen({ allowUpgrades: false }, (port) => {\n        const socket = new ClientSocket(`ws://localhost:${port}`);\n        const shi = \"\u77f3\u5ba4\u8a69\u58eb\u65bd\u6c0f\uff0c\u55dc\u7345\uff0c\u8a93\u98df\u5341\u7345\u3002\";\n        const shi2 = \"\u6c0f\u6642\u6642\u9069\u5e02\u8996\u7345\u3002\";\n        engine.on(\"connection\", (conn) => {\n          conn.send(\".\");\n          conn.send(shi);\n          conn.send(shi2);\n          conn.once(\"message\", (msg0) => {\n            expect(msg0).to.be(\".\");\n            conn.once(\"message\", (msg) => {\n              expect(msg).to.be(shi);\n              conn.once(\"message\", (msg2) => {\n                expect(msg2).to.be(shi2);\n                done();\n              });\n            });\n          });\n        });\n        socket.on(\"open\", () => {\n          socket.once(\"message\", (msg0) => {\n            expect(msg0).to.be(\".\");\n            socket.once(\"message\", (msg) => {\n              expect(msg).to.be(shi);\n              socket.once(\"message\", (msg2) => {\n                expect(msg2).to.be(shi2);\n                socket.send(\".\");\n                socket.send(shi);\n                socket.send(shi2);\n              });\n            });\n          });\n        });\n      });\n    });\n\n    it(\"should send and receive data with key and cert (polling)\", function (done) {\n      if (process.env.EIO_WS_ENGINE === \"uws\") {\n        return this.skip();\n      }\n      const srvOpts = {\n        key: fs.readFileSync(\"test/fixtures/server.key\"),\n        cert: fs.readFileSync(\"test/fixtures/server.crt\"),\n        ca: fs.readFileSync(\"test/fixtures/ca.crt\"),\n        requestCert: true,\n        rejectUnauthorized: true,\n      };\n\n      const opts = {\n        key: fs.readFileSync(\"test/fixtures/client.key\"),\n        cert: fs.readFileSync(\"test/fixtures/client.crt\"),\n        ca: fs.readFileSync(\"test/fixtures/ca.crt\"),\n        transports: [\"polling\"],\n      };\n\n      const srv = https.createServer(srvOpts, (req, res) => {\n        res.writeHead(200);\n        res.end(\"hello world\\n\");\n      });\n\n      const engine = new Server({\n        transports: [\"polling\"],\n        allowUpgrades: false,\n        allowEIO3: true,\n      });\n      engine.attach(srv);\n      srv.listen(() => {\n        const port = srv.address().port;\n        const socket = new ClientSocket(`https://localhost:${port}`, opts);\n\n        engine.on(\"connection\", (conn) => {\n          conn.on(\"message\", (msg) => {\n            expect(msg).to.be(\"hello\");\n            done();\n          });\n        });\n\n        socket.on(\"open\", () => {\n          socket.send(\"hello\");\n        });\n      });\n    });\n\n    it(\"should send and receive data with ca when not requiring auth (polling)\", function (done) {\n      if (process.env.EIO_WS_ENGINE === \"uws\") {\n        return this.skip();\n      }\n      const srvOpts = {\n        key: fs.readFileSync(\"test/fixtures/server.key\"),\n        cert: fs.readFileSync(\"test/fixtures/server.crt\"),\n        ca: fs.readFileSync(\"test/fixtures/ca.crt\"),\n        requestCert: true,\n        rejectUnauthorized: false,\n      };\n\n      const opts = {\n        ca: fs.readFileSync(\"test/fixtures/ca.crt\"),\n        transports: [\"polling\"],\n      };\n\n      const srv = https.createServer(srvOpts, (req, res) => {\n        res.writeHead(200);\n        res.end(\"hello world\\n\");\n      });\n\n      const engine = new Server({\n        transports: [\"polling\"],\n        allowUpgrades: false,\n        allowEIO3: true,\n      });\n      engine.attach(srv);\n      srv.listen(() => {\n        const port = srv.address().port;\n        const socket = new ClientSocket(`https://localhost:${port}`, opts);\n\n        engine.on(\"connection\", (conn) => {\n          conn.on(\"message\", (msg) => {\n            expect(msg).to.be(\"hello\");\n            done();\n          });\n        });\n\n        socket.on(\"open\", () => {\n          socket.send(\"hello\");\n        });\n      });\n    });\n\n    it(\"should send and receive data with key and cert (ws)\", function (done) {\n      if (process.env.EIO_WS_ENGINE === \"uws\") {\n        return this.skip();\n      }\n      const srvOpts = {\n        key: fs.readFileSync(\"test/fixtures/server.key\"),\n        cert: fs.readFileSync(\"test/fixtures/server.crt\"),\n        ca: fs.readFileSync(\"test/fixtures/ca.crt\"),\n        requestCert: true,\n        rejectUnauthorized: true,\n      };\n\n      const opts = {\n        key: fs.readFileSync(\"test/fixtures/client.key\"),\n        cert: fs.readFileSync(\"test/fixtures/client.crt\"),\n        ca: fs.readFileSync(\"test/fixtures/ca.crt\"),\n        transports: [\"websocket\"],\n      };\n\n      const srv = https.createServer(srvOpts, (req, res) => {\n        res.writeHead(200);\n        res.end(\"hello world\\n\");\n      });\n\n      const engine = new Server({\n        transports: [\"websocket\"],\n        allowUpgrades: false,\n        allowEIO3: true,\n      });\n      engine.attach(srv);\n      srv.listen(() => {\n        const port = srv.address().port;\n        const socket = new ClientSocket(`https://localhost:${port}`, opts);\n\n        engine.on(\"connection\", (conn) => {\n          conn.on(\"message\", (msg) => {\n            expect(msg).to.be(\"hello\");\n            done();\n          });\n        });\n\n        socket.on(\"open\", () => {\n          socket.send(\"hello\");\n        });\n      });\n    });\n\n    it(\"should send and receive data with pfx (polling)\", function (done) {\n      if (process.env.EIO_WS_ENGINE === \"uws\") {\n        return this.skip();\n      }\n      const srvOpts = {\n        key: fs.readFileSync(\"test/fixtures/server.key\"),\n        cert: fs.readFileSync(\"test/fixtures/server.crt\"),\n        ca: fs.readFileSync(\"test/fixtures/ca.crt\"),\n        requestCert: true,\n        rejectUnauthorized: true,\n      };\n\n      const opts = {\n        pfx: fs.readFileSync(\"test/fixtures/client.pfx\"),\n        ca: fs.readFileSync(\"test/fixtures/ca.crt\"),\n        transports: [\"polling\"],\n      };\n\n      const srv = https.createServer(srvOpts, (req, res) => {\n        res.writeHead(200);\n        res.end(\"hello world\\n\");\n      });\n\n      const engine = new Server({\n        transports: [\"polling\"],\n        allowUpgrades: false,\n        allowEIO3: true,\n      });\n      engine.attach(srv);\n      srv.listen(() => {\n        const port = srv.address().port;\n        const socket = new ClientSocket(`https://localhost:${port}`, opts);\n\n        engine.on(\"connection\", (conn) => {\n          conn.on(\"message\", (msg) => {\n            expect(msg).to.be(\"hello\");\n            done();\n          });\n        });\n\n        socket.on(\"open\", () => {\n          socket.send(\"hello\");\n        });\n      });\n    });\n\n    it(\"should send and receive data with pfx (ws)\", function (done) {\n      if (process.env.EIO_WS_ENGINE === \"uws\") {\n        return this.skip();\n      }\n      const srvOpts = {\n        key: fs.readFileSync(\"test/fixtures/server.key\"),\n        cert: fs.readFileSync(\"test/fixtures/server.crt\"),\n        ca: fs.readFileSync(\"test/fixtures/ca.crt\"),\n        requestCert: true,\n        rejectUnauthorized: true,\n      };\n\n      const opts = {\n        pfx: fs.readFileSync(\"test/fixtures/client.pfx\"),\n        ca: fs.readFileSync(\"test/fixtures/ca.crt\"),\n        transports: [\"websocket\"],\n      };\n\n      const srv = https.createServer(srvOpts, (req, res) => {\n        res.writeHead(200);\n        res.end(\"hello world\\n\");\n      });\n\n      const engine = new Server({\n        transports: [\"websocket\"],\n        allowUpgrades: false,\n        allowEIO3: true,\n      });\n      engine.attach(srv);\n      srv.listen(() => {\n        const port = srv.address().port;\n        const socket = new ClientSocket(`https://localhost:${port}`, opts);\n\n        engine.on(\"connection\", (conn) => {\n          conn.on(\"message\", (msg) => {\n            expect(msg).to.be(\"hello\");\n            done();\n          });\n        });\n\n        socket.on(\"open\", () => {\n          socket.send(\"hello\");\n        });\n      });\n    });\n  });\n\n  describe(\"send\", () => {\n    describe(\"writeBuffer\", () => {\n      it(\"should not empty until `drain` event (polling)\", (done) => {\n        listen({ allowUpgrades: false }, (port) => {\n          const socket = new ClientSocket(`ws://localhost:${port}`, {\n            transports: [\"polling\"],\n          });\n          let totalEvents = 2;\n          socket.on(\"open\", () => {\n            socket.send(\"a\");\n            socket.send(\"b\");\n            // writeBuffer should be nonempty, with 'a' still in it\n            expect(socket.writeBuffer.length).to.eql(2);\n          });\n          socket.transport.on(\"drain\", () => {\n            expect(socket.writeBuffer.length).to.eql(--totalEvents);\n            totalEvents || done();\n          });\n        });\n      });\n\n      it(\"should not empty until `drain` event (websocket)\", (done) => {\n        listen({ allowUpgrades: false }, (port) => {\n          const socket = new ClientSocket(`ws://localhost:${port}`, {\n            transports: [\"websocket\"],\n          });\n          let totalEvents = 2;\n          socket.on(\"open\", () => {\n            socket.send(\"a\");\n            socket.send(\"b\");\n            // writeBuffer should be nonempty, with 'a' still in it\n            expect(socket.writeBuffer.length).to.eql(2);\n          });\n          socket.transport.on(\"drain\", () => {\n            expect(socket.writeBuffer.length).to.eql(--totalEvents);\n            totalEvents || done();\n          });\n        });\n      });\n    });\n\n    describe(\"callback\", () => {\n      it(\"should execute in order when message sent (client) (polling)\", (done) => {\n        const engine = listen({ allowUpgrades: false }, (port) => {\n          const socket = new ClientSocket(`ws://localhost:${port}`, {\n            transports: [\"polling\"],\n          });\n          let i = 0;\n          let j = 0;\n\n          engine.on(\"connection\", (conn) => {\n            conn.on(\"message\", (msg) => {\n              conn.send(msg);\n            });\n          });\n\n          socket.on(\"open\", () => {\n            socket.on(\"message\", (msg) => {\n              // send another packet until we've sent 3 total\n              if (++i < 3) {\n                expect(i).to.eql(j);\n                sendFn();\n              } else {\n                done();\n              }\n            });\n\n            function sendFn() {\n              socket.send(\n                j,\n                ((value) => {\n                  j++;\n                })(j)\n              );\n            }\n\n            sendFn();\n          });\n        });\n      });\n\n      it(\"should execute in order when message sent (client) (websocket)\", (done) => {\n        const engine = listen({ allowUpgrades: false }, (port) => {\n          const socket = new ClientSocket(`ws://localhost:${port}`, {\n            transports: [\"websocket\"],\n          });\n          let i = 0;\n          let j = 0;\n\n          engine.on(\"connection\", (conn) => {\n            conn.on(\"message\", (msg) => {\n              conn.send(msg);\n            });\n          });\n\n          socket.on(\"open\", () => {\n            socket.on(\"message\", (msg) => {\n              // send another packet until we've sent 3 total\n              if (++i < 3) {\n                expect(i).to.eql(j);\n                sendFn();\n              } else {\n                done();\n              }\n            });\n\n            function sendFn() {\n              socket.send(\n                j,\n                ((value) => {\n                  j++;\n                })(j)\n              );\n            }\n\n            sendFn();\n          });\n        });\n      });\n\n      it(\"should execute in order with payloads (client) (polling)\", (done) => {\n        const engine = listen({ allowUpgrades: false }, (port) => {\n          const socket = new ClientSocket(`ws://localhost:${port}`, {\n            transports: [\"polling\"],\n          });\n          let i = 0;\n          let lastCbFired = 0;\n\n          engine.on(\"connection\", (conn) => {\n            conn.on(\"message\", (msg) => {\n              conn.send(msg);\n            });\n          });\n\n          socket.on(\"open\", () => {\n            socket.on(\"message\", (msg) => {\n              expect(msg).to.eql(i + 1);\n              i++;\n            });\n\n            function cb(value) {\n              expect(value).to.eql(lastCbFired + 1);\n              lastCbFired = value;\n              if (value === 3) {\n                done();\n              }\n            }\n\n            // 2 and 3 will be in the same payload\n            socket.once(\"flush\", () => {\n              socket.send(2, () => {\n                cb(2);\n              });\n              socket.send(3, () => {\n                cb(3);\n              });\n            });\n\n            socket.send(1, () => {\n              cb(1);\n            });\n          });\n        });\n      });\n\n      it(\"should execute in order with payloads (client) (websocket)\", (done) => {\n        const engine = listen({ allowUpgrades: false }, (port) => {\n          const socket = new ClientSocket(`ws://localhost:${port}`, {\n            transports: [\"websocket\"],\n          });\n          let i = 0;\n          let lastCbFired = 0;\n\n          engine.on(\"connection\", (conn) => {\n            conn.on(\"message\", (msg) => {\n              conn.send(msg);\n            });\n          });\n\n          socket.on(\"open\", () => {\n            socket.on(\"message\", (msg) => {\n              expect(msg).to.eql(i + 1);\n              i++;\n            });\n\n            function cb(value) {\n              expect(value).to.eql(lastCbFired + 1);\n              lastCbFired = value;\n              if (value === 3) {\n                done();\n              }\n            }\n\n            // 2 and 3 will be in the same payload\n            socket.once(\"flush\", () => {\n              socket.send(2, () => {\n                cb(2);\n              });\n              socket.send(3, () => {\n                cb(3);\n              });\n            });\n\n            socket.send(1, () => {\n              cb(1);\n            });\n          });\n        });\n      });\n\n      it(\"should execute when message sent (polling)\", (done) => {\n        const engine = listen({ allowUpgrades: false }, (port) => {\n          const socket = new ClientSocket(`ws://localhost:${port}`, {\n            transports: [\"polling\"],\n          });\n          let i = 0;\n          let j = 0;\n\n          engine.on(\"connection\", (conn) => {\n            conn.send(\"a\", (transport) => {\n              i++;\n            });\n          });\n          socket.on(\"open\", () => {\n            socket.on(\"message\", (msg) => {\n              j++;\n            });\n          });\n\n          setTimeout(() => {\n            expect(i).to.be(j);\n            done();\n          }, 100);\n        });\n      });\n\n      it(\"should execute when message sent (websocket)\", (done) => {\n        const engine = listen({ allowUpgrades: false }, (port) => {\n          const socket = new ClientSocket(`ws://localhost:${port}`, {\n            transports: [\"websocket\"],\n          });\n          let i = 0;\n          let j = 0;\n\n          engine.on(\"connection\", (conn) => {\n            conn.send(\"a\", (transport) => {\n              i++;\n            });\n          });\n\n          socket.on(\"open\", () => {\n            socket.on(\"message\", (msg) => {\n              j++;\n            });\n          });\n\n          setTimeout(() => {\n            expect(i).to.be(j);\n            done();\n          }, 100);\n        });\n      });\n\n      it(\"should execute once for each send\", (done) => {\n        const engine = listen((port) => {\n          const socket = new ClientSocket(`ws://localhost:${port}`);\n          let a = 0;\n          let b = 0;\n          let c = 0;\n          let all = 0;\n\n          engine.on(\"connection\", (conn) => {\n            conn.send(\"a\");\n            conn.send(\"b\");\n            conn.send(\"c\");\n          });\n\n          socket.on(\"open\", () => {\n            socket.on(\"message\", (msg) => {\n              if (msg === \"a\") a++;\n              if (msg === \"b\") b++;\n              if (msg === \"c\") c++;\n\n              if (++all === 3) {\n                expect(a).to.be(1);\n                expect(b).to.be(1);\n                expect(c).to.be(1);\n                done();\n              }\n            });\n          });\n        });\n      });\n\n      it(\"should execute in multipart packet\", (done) => {\n        const engine = listen((port) => {\n          const socket = new ClientSocket(`ws://localhost:${port}`);\n          let i = 0;\n          let j = 0;\n\n          engine.on(\"connection\", (conn) => {\n            conn.send(\"b\", (transport) => {\n              i++;\n            });\n\n            conn.send(\"a\", (transport) => {\n              i++;\n            });\n          });\n          socket.on(\"open\", () => {\n            socket.on(\"message\", (msg) => {\n              j++;\n            });\n          });\n\n          setTimeout(() => {\n            expect(i).to.be(j);\n            done();\n          }, 200);\n        });\n      });\n\n      it(\"should execute in multipart packet (polling)\", (done) => {\n        const engine = listen((port) => {\n          const socket = new ClientSocket(`ws://localhost:${port}`, {\n            transports: [\"polling\"],\n          });\n          let i = 0;\n          let j = 0;\n\n          engine.on(\"connection\", (conn) => {\n            conn.send(\"d\", (transport) => {\n              i++;\n            });\n\n            conn.send(\"c\", (transport) => {\n              i++;\n            });\n\n            conn.send(\"b\", (transport) => {\n              i++;\n            });\n\n            conn.send(\"a\", (transport) => {\n              i++;\n            });\n          });\n          socket.on(\"open\", () => {\n            socket.on(\"message\", (msg) => {\n              j++;\n            });\n          });\n\n          setTimeout(() => {\n            expect(i).to.be(j);\n            done();\n          }, 200);\n        });\n      });\n\n      it(\"should clean callback references when socket gets closed with pending callbacks\", (done) => {\n        const engine = listen({ allowUpgrades: false }, (port) => {\n          const socket = new ClientSocket(`ws://localhost:${port}`, {\n            transports: [\"polling\"],\n          });\n\n          engine.on(\"connection\", (conn) => {\n            socket.transport.on(\"pollComplete\", () => {\n              conn.send(\"a\", (transport) => {\n                done(new Error(\"Test invalidation\"));\n              });\n\n              if (!conn.writeBuffer.length) {\n                done(new Error(\"Test invalidation\"));\n              }\n\n              // force to close the socket when we have one or more packet(s) in buffer\n              socket.close();\n            });\n\n            conn.on(\"close\", (reason) => {\n              expect(conn.packetsFn).to.be.empty();\n              expect(conn.sentCallbackFn).to.be.empty();\n              done();\n            });\n          });\n        });\n      });\n\n      it(\"should not execute when it is not actually sent (polling)\", (done) => {\n        const engine = listen({ allowUpgrades: false }, (port) => {\n          const socket = new ClientSocket(`ws://localhost:${port}`, {\n            transports: [\"polling\"],\n          });\n\n          socket.transport.on(\"pollComplete\", (msg) => {\n            socket.close();\n          });\n\n          engine.on(\"connection\", (conn) => {\n            let err;\n            conn.send(\"a\");\n            conn.send(\"b\", (transport) => {\n              err = new Error(\"Test invalidation\");\n            });\n            conn.on(\"close\", (reason) => {\n              done(err);\n            });\n          });\n        });\n      });\n    });\n\n    describe(\"pre-encoded content\", () => {\n      it(\"should use the pre-encoded content\", (done) => {\n        engine = listen((port) => {\n          client = new ClientSocket(`ws://localhost:${port}`, {\n            transports: [\"websocket\"],\n          });\n\n          engine.on(\"connection\", (conn) => {\n            conn.send(\"test\", {\n              wsPreEncoded: \"4test pre-encoded\",\n            });\n          });\n\n          client.on(\"message\", (msg) => {\n            expect(msg).to.be(\"test pre-encoded\");\n            done();\n          });\n        });\n      });\n\n      it(\"should use the pre-encoded frame\", function (done) {\n        if (process.env.EIO_WS_ENGINE === \"uws\") {\n          return this.skip();\n        }\n        engine = listen((port) => {\n          client = new ClientSocket(`ws://localhost:${port}`, {\n            transports: [\"websocket\"],\n          });\n\n          engine.on(\"connection\", (conn) => {\n            conn.send(\"test\", {\n              wsPreEncodedFrame: [\n                Buffer.from([129, 4]),\n                Buffer.from([52, 49, 50, 51]),\n              ],\n            });\n          });\n\n          client.on(\"message\", (msg) => {\n            expect(msg).to.be(\"123\");\n            done();\n          });\n        });\n      });\n\n      it(\"should not use the pre-encoded frame when the permessage-deflate extension is enabled\", (done) => {\n        engine = listen({ perMessageDeflate: true }, (port) => {\n          client = new ClientSocket(`ws://localhost:${port}`, {\n            transports: [\"websocket\"],\n          });\n\n          engine.on(\"connection\", (conn) => {\n            conn.send(\"test\", {\n              wsPreEncodedFrame: [\n                Buffer.from([129, 4]),\n                Buffer.from([52, 49, 50, 51]),\n              ],\n            });\n          });\n\n          client.on(\"message\", (msg) => {\n            expect(msg).to.be(\"test\");\n            done();\n          });\n        });\n      });\n    });\n  });\n\n  describe(\"packet\", () => {\n    it(\"should emit when socket receives packet\", (done) => {\n      const engine = listen({ allowUpgrades: false }, (port) => {\n        const socket = new ClientSocket(`ws://localhost:${port}`);\n        engine.on(\"connection\", (conn) => {\n          conn.on(\"packet\", (packet) => {\n            expect(packet.type).to.be(\"message\");\n            expect(packet.data).to.be(\"a\");\n            done();\n          });\n        });\n        socket.on(\"open\", () => {\n          socket.send(\"a\");\n        });\n      });\n    });\n\n    it(\"should emit when receives pong\", (done) => {\n      const engine = listen(\n        { allowUpgrades: false, pingInterval: 4 },\n        (port) => {\n          new ClientSocket(`ws://localhost:${port}`);\n          engine.on(\"connection\", (conn) => {\n            conn.on(\"packet\", (packet) => {\n              conn.close();\n              if (process.env.EIO_CLIENT === \"3\") {\n                expect(packet.type).to.be(\"ping\");\n              } else {\n                expect(packet.type).to.be(\"pong\");\n              }\n              done();\n            });\n          });\n        }\n      );\n    });\n  });\n\n  describe(\"packetCreate\", () => {\n    it(\"should emit before socket send message\", (done) => {\n      const engine = listen({ allowUpgrades: false }, (port) => {\n        new ClientSocket(`ws://localhost:${port}`);\n        engine.on(\"connection\", (conn) => {\n          conn.on(\"packetCreate\", (packet) => {\n            expect(packet.type).to.be(\"message\");\n            expect(packet.data).to.be(\"a\");\n            done();\n          });\n          conn.send(\"a\");\n        });\n      });\n    });\n\n    it(\"should emit before send pong\", (done) => {\n      const engine = listen(\n        { allowUpgrades: false, pingInterval: 4 },\n        (port) => {\n          new ClientSocket(`ws://localhost:${port}`);\n          engine.on(\"connection\", (conn) => {\n            conn.on(\"packetCreate\", (packet) => {\n              conn.close();\n              if (process.env.EIO_CLIENT === \"3\") {\n                expect(packet.type).to.be(\"pong\");\n              } else {\n                expect(packet.type).to.be(\"ping\");\n              }\n              done();\n            });\n          });\n        }\n      );\n    });\n  });\n\n  describe(\"upgrade\", () => {\n    it(\"should upgrade\", (done) => {\n      const engine = listen((port) => {\n        // it takes both to send 50 to verify\n        let ready = 2;\n        let closed = 2;\n\n        function finish() {\n          setTimeout(() => {\n            socket.close();\n          }, 10);\n        }\n\n        // server\n        engine.on(\"connection\", (conn) => {\n          let lastSent = 0;\n          let lastReceived = 0;\n          let upgraded = false;\n          const interval = setInterval(() => {\n            lastSent++;\n            conn.send(lastSent);\n            if (50 === lastSent) {\n              clearInterval(interval);\n              --ready || finish();\n            }\n          }, 2);\n\n          expect(conn.request._query.transport).to.be(\"polling\");\n\n          conn.on(\"message\", (msg) => {\n            expect(conn.request._query).to.be.an(\"object\");\n            lastReceived++;\n            expect(msg).to.eql(lastReceived);\n          });\n\n          conn.on(\"upgrade\", (to) => {\n            expect(conn.request._query.transport).to.be(\"polling\");\n            upgraded = true;\n            expect(to.name).to.be(\"websocket\");\n            expect(conn.transport.name).to.be(\"websocket\");\n          });\n\n          conn.on(\"close\", (reason) => {\n            expect(reason).to.be(\"transport close\");\n            expect(lastSent).to.be(50);\n            expect(lastReceived).to.be(50);\n            expect(upgraded).to.be(true);\n            --closed || done();\n          });\n        });\n\n        // client\n        var socket = new ClientSocket(`ws://localhost:${port}`);\n        socket.on(\"open\", () => {\n          let lastSent = 0;\n          let lastReceived = 0;\n          let upgrades = 0;\n          const interval = setInterval(() => {\n            lastSent++;\n            socket.send(lastSent);\n            if (50 === lastSent) {\n              clearInterval(interval);\n              --ready || finish();\n            }\n          }, 2);\n          socket.on(\"upgrading\", (to) => {\n            // we want to make sure for the sake of this test that we have a buffer\n            expect(to.name).to.equal(\"websocket\");\n            upgrades++;\n\n            // force send a few packets to ensure we test buffer transfer\n            lastSent++;\n            socket.send(lastSent);\n            lastSent++;\n            socket.send(lastSent);\n\n            expect(socket.writeBuffer).to.not.be.empty();\n          });\n          socket.on(\"upgrade\", (to) => {\n            expect(to.name).to.equal(\"websocket\");\n            upgrades++;\n          });\n          socket.on(\"message\", (msg) => {\n            lastReceived++;\n            expect(lastReceived).to.eql(msg);\n          });\n          socket.on(\"close\", (reason) => {\n            expect(reason).to.be(\"forced close\");\n            expect(lastSent).to.be(50);\n            expect(upgrades).to.be(2);\n            --closed || done();\n          });\n        });\n      });\n\n      if (engine.httpServer) {\n        // attach another engine to make sure it doesn't break upgrades\n        attach(engine.httpServer, { path: \"/foo\" });\n      }\n    });\n  });\n\n  describe(\"http compression\", () => {\n    function getSidFromResponse(res) {\n      const c = cookieMod.parse(res.headers[\"set-cookie\"][0]);\n      return c[Object.keys(c)[0]];\n    }\n\n    it(\"should compress by default\", (done) => {\n      const engine = listen(\n        { cookie: true, transports: [\"polling\"] },\n        (port) => {\n          engine.on(\"connection\", (conn) => {\n            const buf = Buffer.allocUnsafe(1024);\n            for (let i = 0; i < buf.length; i++) buf[i] = i % 0xff;\n            conn.send(buf);\n          });\n\n          http.get(\n            {\n              port: port,\n              path: \"/engine.io/?transport=polling\",\n            },\n            (res) => {\n              const sid = getSidFromResponse(res);\n              http.get(\n                {\n                  port: port,\n                  path: \"/engine.io/?transport=polling&sid=\" + sid,\n                  headers: { \"Accept-Encoding\": \"gzip, deflate\" },\n                },\n                (res) => {\n                  expect(res.headers[\"content-encoding\"]).to.equal(\"gzip\");\n                  res\n                    .pipe(zlib.createGunzip())\n                    .on(\"error\", done)\n                    .on(\"end\", done)\n                    .resume();\n                }\n              );\n            }\n          );\n        }\n      );\n    });\n\n    it(\"should compress using deflate\", (done) => {\n      const engine = listen(\n        { cookie: true, transports: [\"polling\"] },\n        (port) => {\n          engine.on(\"connection\", (conn) => {\n            const buf = Buffer.allocUnsafe(1024);\n            for (let i = 0; i < buf.length; i++) buf[i] = i % 0xff;\n            conn.send(buf);\n          });\n\n          http.get(\n            {\n              port: port,\n              path: \"/engine.io/?transport=polling\",\n            },\n            (res) => {\n              const sid = getSidFromResponse(res);\n              http.get(\n                {\n                  port: port,\n                  path: \"/engine.io/?transport=polling&sid=\" + sid,\n                  headers: { \"Accept-Encoding\": \"deflate\" },\n                },\n                (res) => {\n                  expect(res.headers[\"content-encoding\"]).to.equal(\"deflate\");\n                  res\n                    .pipe(zlib.createDeflate())\n                    .on(\"error\", done)\n                    .on(\"end\", done)\n                    .resume();\n                }\n              );\n            }\n          );\n        }\n      );\n    });\n\n    it(\"should set threshold\", (done) => {\n      const engine = listen(\n        {\n          cookie: true,\n          transports: [\"polling\"],\n          httpCompression: { threshold: 0 },\n        },\n        (port) => {\n          engine.on(\"connection\", (conn) => {\n            const buf = Buffer.allocUnsafe(10);\n            for (let i = 0; i < buf.length; i++) buf[i] = i % 0xff;\n            conn.send(buf);\n          });\n\n          http.get(\n            {\n              port: port,\n              path: \"/engine.io/?transport=polling\",\n            },\n            (res) => {\n              const sid = getSidFromResponse(res);\n              http.get(\n                {\n                  port: port,\n                  path: \"/engine.io/?transport=polling&sid=\" + sid,\n                  headers: { \"Accept-Encoding\": \"gzip, deflate\" },\n                },\n                (res) => {\n                  expect(res.headers[\"content-encoding\"]).to.equal(\"gzip\");\n                  done();\n                }\n              );\n            }\n          );\n        }\n      );\n    });\n\n    it(\"should disable compression\", (done) => {\n      const engine = listen(\n        { cookie: true, transports: [\"polling\"], httpCompression: false },\n        (port) => {\n          engine.on(\"connection\", (conn) => {\n            const buf = Buffer.allocUnsafe(1024);\n            for (let i = 0; i < buf.length; i++) buf[i] = i % 0xff;\n            conn.send(buf);\n          });\n\n          http.get(\n            {\n              port: port,\n              path: \"/engine.io/?transport=polling\",\n            },\n            (res) => {\n              const sid = getSidFromResponse(res);\n              http.get(\n                {\n                  port: port,\n                  path: \"/engine.io/?transport=polling&sid=\" + sid,\n                  headers: { \"Accept-Encoding\": \"gzip, deflate\" },\n                },\n                (res) => {\n                  expect(res.headers[\"content-encoding\"]).to.be(undefined);\n                  done();\n                }\n              );\n            }\n          );\n        }\n      );\n    });\n\n    it(\"should disable compression per message\", (done) => {\n      const engine = listen(\n        { cookie: true, transports: [\"polling\"] },\n        (port) => {\n          engine.on(\"connection\", (conn) => {\n            const buf = Buffer.allocUnsafe(1024);\n            for (let i = 0; i < buf.length; i++) buf[i] = i % 0xff;\n            conn.send(buf, { compress: false });\n          });\n\n          http.get(\n            {\n              port: port,\n              path: \"/engine.io/?transport=polling\",\n            },\n            (res) => {\n              const sid = getSidFromResponse(res);\n              http.get(\n                {\n                  port: port,\n                  path: \"/engine.io/?transport=polling&sid=\" + sid,\n                  headers: { \"Accept-Encoding\": \"gzip, deflate\" },\n                },\n                (res) => {\n                  expect(res.headers[\"content-encoding\"]).to.be(undefined);\n                  done();\n                }\n              );\n            }\n          );\n        }\n      );\n    });\n\n    it(\"should not compress when the byte size is below threshold\", (done) => {\n      const engine = listen(\n        { cookie: true, transports: [\"polling\"] },\n        (port) => {\n          engine.on(\"connection\", (conn) => {\n            const buf = Buffer.allocUnsafe(100);\n            for (let i = 0; i < buf.length; i++) buf[i] = i % 0xff;\n            conn.send(buf);\n          });\n\n          http.get(\n            {\n              port: port,\n              path: \"/engine.io/?transport=polling\",\n            },\n            (res) => {\n              const sid = getSidFromResponse(res);\n              http.get(\n                {\n                  port: port,\n                  path: \"/engine.io/?transport=polling&sid=\" + sid,\n                  headers: { \"Accept-Encoding\": \"gzip, deflate\" },\n                },\n                (res) => {\n                  expect(res.headers[\"content-encoding\"]).to.be(undefined);\n                  done();\n                }\n              );\n            }\n          );\n        }\n      );\n    });\n  });\n\n  describe(\"permessage-deflate\", () => {\n    it(\"should set threshold\", function (done) {\n      if (process.env.EIO_WS_ENGINE === \"uws\") {\n        return this.skip();\n      }\n      const engine = listen(\n        { transports: [\"websocket\"], perMessageDeflate: { threshold: 0 } },\n        (port) => {\n          engine.on(\"connection\", (conn) => {\n            const socket = conn.transport.socket;\n            const send = socket.send;\n            socket.send = (data, opts, callback) => {\n              socket.send = send;\n              socket.send(data, opts, callback);\n\n              expect(opts.compress).to.be(true);\n              conn.close();\n              done();\n            };\n\n            const buf = Buffer.allocUnsafe(100);\n            for (let i = 0; i < buf.length; i++) buf[i] = i % 0xff;\n            conn.send(buf, { compress: true });\n          });\n          new ClientSocket(`http://localhost:${port}`, {\n            transports: [\"websocket\"],\n          });\n        }\n      );\n    });\n\n    it(\"should not compress when the byte size is below threshold\", function (done) {\n      if (process.env.EIO_WS_ENGINE === \"uws\") {\n        return this.skip();\n      }\n      const engine = listen(\n        { transports: [\"websocket\"], perMessageDeflate: true },\n        (port) => {\n          engine.on(\"connection\", (conn) => {\n            const socket = conn.transport.socket;\n            const send = socket.send;\n            socket.send = (data, opts, callback) => {\n              socket.send = send;\n              socket.send(data, opts, callback);\n\n              expect(opts.compress).to.be(false);\n              conn.close();\n              done();\n            };\n\n            const buf = Buffer.allocUnsafe(100);\n            for (let i = 0; i < buf.length; i++) buf[i] = i % 0xff;\n            conn.send(buf, { compress: true });\n          });\n          new ClientSocket(`http://localhost:${port}`, {\n            transports: [\"websocket\"],\n          });\n        }\n      );\n    });\n  });\n\n  describe(\"extraHeaders\", function () {\n    this.timeout(5000);\n\n    const headers = {\n      \"x-custom-header-for-my-project\": \"my-secret-access-token\",\n      cookie:\n        \"user_session=NI2JlCKF90aE0sJZD9ZzujtdsUqNYSBYxzlTsvdSUe35ZzdtVRGqYFr0kdGxbfc5gUOkR9RGp20GVKza; path=/; expires=Tue, 07-Apr-2015 18:18:08 GMT; secure; HttpOnly\",\n    };\n\n    function testForTransport(transport, done) {\n      const engine = listen((port) => {\n        const socket = new ClientSocket(`ws://localhost:${port}`, {\n          extraHeaders: headers,\n          transports: [transport],\n        });\n        engine.on(\"connection\", (conn) => {\n          for (let h in headers) {\n            expect(conn.request.headers[h]).to.equal(headers[h]);\n          }\n          done();\n        });\n        socket.on(\"open\", () => {});\n      });\n    }\n\n    it(\"should arrive from client to server via WebSockets\", (done) => {\n      testForTransport(\"websocket\", done);\n    });\n\n    it(\"should arrive from client to server via XMLHttpRequest\", (done) => {\n      testForTransport(\"polling\", done);\n    });\n  });\n\n  describe(\"response headers\", () => {\n    function testForHeaders(headers, done) {\n      const engine = listen((port) => {\n        engine.on(\"connection\", (conn) => {\n          conn.transport.once(\"headers\", (headers) => {\n            expect(headers[\"X-XSS-Protection\"]).to.be(\"0\");\n            conn.close();\n            done();\n          });\n          conn.send(\"hi\");\n        });\n        new ClientSocket(`ws://localhost:${port}`, {\n          extraHeaders: headers,\n          transports: [\"polling\"],\n        });\n      });\n    }\n\n    it(\"should contain X-XSS-Protection: 0 for IE8\", (done) => {\n      const headers = {\n        \"user-agent\":\n          \"Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; Tablet PC 2.0)\",\n      };\n      testForHeaders(headers, done);\n    });\n\n    it(\"should contain X-XSS-Protection: 0 for IE11\", (done) => {\n      const headers = {\n        \"user-agent\":\n          \"Mozilla/5.0 (Windows NT 6.3; Trident/7.0; rv:11.0) like Gecko\",\n      };\n      testForHeaders(headers, done);\n    });\n\n    it(\"should emit a 'initial_headers' event (polling)\", (done) => {\n      const partialDone = createPartialDone(done, 2);\n\n      engine = listen({ cookie: true }, (port) => {\n        engine.on(\"initial_headers\", (headers, req) => {\n          expect(req.method).to.be(\"GET\");\n          headers[\"test\"] = \"123\";\n          headers[\"set-cookie\"] = \"mycookie=456\";\n          partialDone();\n        });\n\n        request\n          .get(`http://localhost:${port}/engine.io/`)\n          .query({ transport: \"polling\" })\n          .end((err, res) => {\n            expect(err).to.be(null);\n            expect(res.status).to.be(200);\n            expect(res.headers[\"test\"]).to.be(\"123\");\n            expect(res.headers[\"set-cookie\"].length).to.be(2);\n            expect(res.headers[\"set-cookie\"][1]).to.be(\"mycookie=456\");\n\n            const sid = JSON.parse(res.text.slice(5)).sid;\n\n            request\n              .post(`http://localhost:${port}/engine.io/`)\n              .query({ transport: \"polling\", sid })\n              .send(\"1:6\")\n              .end((err, res) => {\n                expect(err).to.be(null);\n                expect(res.status).to.be(200);\n                expect(res.headers[\"test\"]).to.be(undefined);\n                expect(res.headers[\"set-cookie\"]).to.be(undefined);\n                partialDone();\n              });\n          });\n      });\n    });\n\n    it(\"should emit a 'headers' event (polling)\", (done) => {\n      const partialDone = createPartialDone(done, 3);\n\n      engine = listen({ cookie: true }, (port) => {\n        engine.on(\"headers\", (headers) => {\n          headers[\"test\"] = \"123\";\n          headers[\"set-cookie\"] = \"mycookie=456\";\n          partialDone();\n        });\n\n        request\n          .get(`http://localhost:${port}/engine.io/`)\n          .query({ transport: \"polling\" })\n          .end((err, res) => {\n            expect(err).to.be(null);\n            expect(res.status).to.be(200);\n            expect(res.headers[\"test\"]).to.be(\"123\");\n            expect(res.headers[\"set-cookie\"].length).to.be(2);\n            expect(res.headers[\"set-cookie\"][1]).to.be(\"mycookie=456\");\n\n            const sid = JSON.parse(res.text.slice(5)).sid;\n\n            request\n              .post(`http://localhost:${port}/engine.io/`)\n              .query({ transport: \"polling\", sid })\n              .send(\"1:6\")\n              .end((err, res) => {\n                expect(err).to.be(null);\n                expect(res.status).to.be(200);\n                expect(res.headers[\"set-cookie\"].length).to.be(1);\n                expect(res.headers[\"set-cookie\"][0]).to.be(\"mycookie=456\");\n                partialDone();\n              });\n          });\n      });\n    });\n\n    it(\"should emit a 'initial_headers' event (websocket)\", function (done) {\n      if (\n        process.env.EIO_WS_ENGINE === \"eiows\" ||\n        process.env.EIO_WS_ENGINE === \"uws\"\n      ) {\n        return this.skip();\n      }\n      const partialDone = createPartialDone(done, 2);\n\n      engine = listen({ cookie: true }, (port) => {\n        engine.on(\"initial_headers\", (headers, req) => {\n          expect(req.method).to.be(\"GET\");\n          headers[\"test\"] = \"123\";\n          headers[\"set-cookie\"] = \"mycookie=456\";\n          partialDone();\n        });\n\n        client = new ClientSocket(`ws://localhost:${port}`, {\n          transports: [\"websocket\"],\n        });\n\n        client.transport.ws.on(\"upgrade\", (res) => {\n          expect(res.headers[\"test\"]).to.be(\"123\");\n          expect(res.headers[\"set-cookie\"].length).to.be(1);\n          expect(res.headers[\"set-cookie\"][0]).to.be(\"mycookie=456\");\n          partialDone();\n        });\n      });\n    });\n\n    it(\"should emit a single 'initial_headers' event per connection\", (done) => {\n      const partialDone = createPartialDone(done, 2);\n\n      engine = listen((port) => {\n        engine.on(\"initial_headers\", () => {\n          partialDone();\n        });\n\n        client = new ClientSocket(`ws://localhost:${port}`);\n\n        client.on(\"upgrade\", () => {\n          partialDone();\n        });\n      });\n    });\n\n    it(\"should emit several 'headers' events per connection\", function (done) {\n      if (\n        process.env.EIO_WS_ENGINE === \"eiows\" ||\n        process.env.EIO_WS_ENGINE === \"uws\"\n      ) {\n        return this.skip();\n      }\n      const partialDone = createPartialDone(done, 4);\n\n      engine = listen((port) => {\n        engine.on(\"headers\", () => {\n          partialDone();\n        });\n\n        client = new ClientSocket(`ws://localhost:${port}`);\n\n        client.on(\"upgrade\", () => {\n          partialDone();\n        });\n      });\n    });\n  });\n\n  describe(\"cors\", () => {\n    it(\"should allow CORS from the current origin (preflight request)\", (done) => {\n      listen(\n        { cors: { origin: true, headers: [\"my-header\"], credentials: true } },\n        (port) => {\n          request\n            .options(`http://localhost:${port}/engine.io/`)\n            .set(\"Origin\", \"http://engine.io\")\n            .query({ transport: \"polling\" })\n            .end((err, res) => {\n              expect(err).to.be(null);\n              expect(res.status).to.be(204);\n              expect(res.body).to.be.empty();\n              expect(res.header[\"access-control-allow-origin\"]).to.be(\n                \"http://engine.io\"\n              );\n              expect(res.header[\"access-control-allow-methods\"]).to.be(\n                \"GET,HEAD,PUT,PATCH,POST,DELETE\"\n              );\n              expect(res.header[\"access-control-allow-headers\"]).to.be(\n                \"my-header\"\n              );\n              expect(res.header[\"access-control-allow-credentials\"]).to.be(\n                \"true\"\n              );\n              done();\n            });\n        }\n      );\n    });\n\n    it(\"should allow CORS from the current origin (actual request)\", (done) => {\n      listen(\n        { cors: { origin: true, headers: [\"my-header\"], credentials: true } },\n        (port) => {\n          request\n            .get(`http://localhost:${port}/engine.io/`)\n            .set(\"Origin\", \"http://engine.io\")\n            .query({ transport: \"polling\" })\n            .end((err, res) => {\n              expect(err).to.be(null);\n              expect(res.status).to.be(200);\n              expect(res.body).to.be.empty();\n              expect(res.header[\"access-control-allow-origin\"]).to.be(\n                \"http://engine.io\"\n              );\n              expect(res.header[\"access-control-allow-methods\"]).to.be(\n                undefined\n              );\n              expect(res.header[\"access-control-allow-headers\"]).to.be(\n                undefined\n              );\n              expect(res.header[\"access-control-allow-credentials\"]).to.be(\n                \"true\"\n              );\n              done();\n            });\n        }\n      );\n    });\n\n    it(\"should disallow CORS from a bad origin\", (done) => {\n      listen(\n        {\n          cors: {\n            origin: [\"http://good-domain.com\"],\n          },\n        },\n        (port) => {\n          request\n            .options(`http://localhost:${port}/engine.io/`)\n            .set(\"Origin\", \"http://bad-domain.com\")\n            .query({ transport: \"polling\" })\n            .end((err, res) => {\n              expect(err).to.be(null);\n              expect(res.status).to.be(204);\n              expect(res.body).to.be.empty();\n              expect(res.header[\"access-control-allow-origin\"]).to.be(\n                undefined\n              );\n              expect(res.header[\"access-control-allow-credentials\"]).to.be(\n                undefined\n              );\n              done();\n            });\n        }\n      );\n    });\n\n    it(\"should forward the configuration to the cors module\", (done) => {\n      listen(\n        {\n          cors: {\n            origin: \"http://good-domain.com\",\n            methods: [\"GET\", \"PUT\", \"POST\"],\n            allowedHeaders: [\"my-header\"],\n            exposedHeaders: [\"my-exposed-header\"],\n            credentials: true,\n            maxAge: 123,\n            optionsSuccessStatus: 200,\n          },\n        },\n        (port) => {\n          request\n            .options(`http://localhost:${port}/engine.io/`)\n            .set(\"Origin\", \"http://good-domain.com\")\n            .query({ transport: \"polling\" })\n            .end((err, res) => {\n              expect(err).to.be(null);\n              expect(res.status).to.be(200);\n              expect(res.body).to.be.empty();\n              expect(res.header[\"access-control-allow-origin\"]).to.be(\n                \"http://good-domain.com\"\n              );\n              expect(res.header[\"access-control-allow-methods\"]).to.be(\n                \"GET,PUT,POST\"\n              );\n              expect(res.header[\"access-control-allow-headers\"]).to.be(\n                \"my-header\"\n              );\n              expect(res.header[\"access-control-expose-headers\"]).to.be(\n                \"my-exposed-header\"\n              );\n              expect(res.header[\"access-control-allow-credentials\"]).to.be(\n                \"true\"\n              );\n              expect(res.header[\"access-control-max-age\"]).to.be(\"123\");\n              done();\n            });\n        }\n      );\n    });\n\n    it(\"should work with CORS enabled\", (done) => {\n      engine = listen(\n        { cors: { origin: true, headers: [\"my-header\"], credentials: true } },\n        (port) => {\n          const client = new ClientSocket(`ws://localhost:${port}`, {\n            transports: [\"polling\"],\n          });\n          engine.on(\"connection\", (socket) => {\n            socket.on(\"message\", (msg) => {\n              expect(msg).to.be(\"hey\");\n              socket.send(\"hol\u00e0\");\n            });\n          });\n          client.on(\"open\", () => {\n            client.send(\"hey\");\n          });\n          client.on(\"message\", (msg) => {\n            expect(msg).to.be(\"hol\u00e0\");\n            client.close();\n            done();\n          });\n        }\n      );\n    });\n  });\n\n  describe(\"wsEngine option\", () => {\n    before(function () {\n      if (process.env.EIO_WS_ENGINE === \"uws\") {\n        this.skip();\n      }\n    });\n\n    // FIXME eiows fails to build on Node.js 18 (and has dropped support for Node.js 10)\n    it.skip(\"should allow loading of other websocket server implementation like eiows\", (done) => {\n      const engine = listen(\n        { allowUpgrades: false, wsEngine: require(\"eiows\").Server },\n        (port) => {\n          expect(engine.ws instanceof require(\"eiows\").Server).to.be.ok();\n          const socket = new ClientSocket(`ws://localhost:${port}`);\n          engine.on(\"connection\", (conn) => {\n            conn.send(\"a\");\n          });\n          socket.on(\"open\", () => {\n            socket.on(\"message\", (msg) => {\n              expect(msg).to.be(\"a\");\n              done();\n            });\n          });\n        }\n      );\n    });\n  });\n\n  describe(\"remoteAddress\", () => {\n    const POSSIBLE_VALUES = [\n      \"0000:0000:0000:0000:0000:0000:0000:0001\",\n      \"0000:0000:0000:0000:0000:ffff:7f00:0001\",\n      \"::ffff:127.0.0.1\",\n      \"::1\",\n    ];\n\n    it(\"should be defined (polling)\", (done) => {\n      const engine = listen({ transports: [\"polling\"] }, (port) => {\n        new ClientSocket(`ws://localhost:${port}`, {\n          transports: [\"polling\"],\n        });\n        engine.on(\"connection\", (socket) => {\n          expect(POSSIBLE_VALUES).to.contain(socket.remoteAddress);\n          done();\n        });\n      });\n    });\n\n    it(\"should be defined (ws)\", (done) => {\n      const engine = listen({ transports: [\"websocket\"] }, (port) => {\n        new ClientSocket(`ws://localhost:${port}`, {\n          transports: [\"websocket\"],\n        });\n        engine.on(\"connection\", (socket) => {\n          expect(POSSIBLE_VALUES).to.contain(socket.remoteAddress);\n          done();\n        });\n      });\n    });\n  });\n});\n"], "fixing_code": ["import * as qs from \"querystring\";\nimport { parse } from \"url\";\nimport * as base64id from \"base64id\";\nimport transports from \"./transports\";\nimport { EventEmitter } from \"events\";\nimport { Socket } from \"./socket\";\nimport debugModule from \"debug\";\nimport { serialize } from \"cookie\";\nimport { Server as DEFAULT_WS_ENGINE } from \"ws\";\nimport type {\n  IncomingMessage,\n  Server as HttpServer,\n  ServerResponse,\n} from \"http\";\nimport type { CookieSerializeOptions } from \"cookie\";\nimport type { CorsOptions, CorsOptionsDelegate } from \"cors\";\nimport type { Duplex } from \"stream\";\n\nconst debug = debugModule(\"engine\");\n\nconst kResponseHeaders = Symbol(\"responseHeaders\");\n\ntype Transport = \"polling\" | \"websocket\";\n\nexport interface AttachOptions {\n  /**\n   * name of the path to capture\n   * @default \"/engine.io\"\n   */\n  path?: string;\n  /**\n   * destroy unhandled upgrade requests\n   * @default true\n   */\n  destroyUpgrade?: boolean;\n  /**\n   * milliseconds after which unhandled requests are ended\n   * @default 1000\n   */\n  destroyUpgradeTimeout?: number;\n\n  /**\n   * Whether we should add a trailing slash to the request path.\n   * @default true\n   */\n  addTrailingSlash?: boolean;\n}\n\nexport interface ServerOptions {\n  /**\n   * how many ms without a pong packet to consider the connection closed\n   * @default 20000\n   */\n  pingTimeout?: number;\n  /**\n   * how many ms before sending a new ping packet\n   * @default 25000\n   */\n  pingInterval?: number;\n  /**\n   * how many ms before an uncompleted transport upgrade is cancelled\n   * @default 10000\n   */\n  upgradeTimeout?: number;\n  /**\n   * how many bytes or characters a message can be, before closing the session (to avoid DoS).\n   * @default 1e5 (100 KB)\n   */\n  maxHttpBufferSize?: number;\n  /**\n   * A function that receives a given handshake or upgrade request as its first parameter,\n   * and can decide whether to continue or not. The second argument is a function that needs\n   * to be called with the decided information: fn(err, success), where success is a boolean\n   * value where false means that the request is rejected, and err is an error code.\n   */\n  allowRequest?: (\n    req: IncomingMessage,\n    fn: (err: string | null | undefined, success: boolean) => void\n  ) => void;\n  /**\n   * the low-level transports that are enabled\n   * @default [\"polling\", \"websocket\"]\n   */\n  transports?: Transport[];\n  /**\n   * whether to allow transport upgrades\n   * @default true\n   */\n  allowUpgrades?: boolean;\n  /**\n   * parameters of the WebSocket permessage-deflate extension (see ws module api docs). Set to false to disable.\n   * @default false\n   */\n  perMessageDeflate?: boolean | object;\n  /**\n   * parameters of the http compression for the polling transports (see zlib api docs). Set to false to disable.\n   * @default true\n   */\n  httpCompression?: boolean | object;\n  /**\n   * what WebSocket server implementation to use. Specified module must\n   * conform to the ws interface (see ws module api docs).\n   * An alternative c++ addon is also available by installing eiows module.\n   *\n   * @default `require(\"ws\").Server`\n   */\n  wsEngine?: any;\n  /**\n   * an optional packet which will be concatenated to the handshake packet emitted by Engine.IO.\n   */\n  initialPacket?: any;\n  /**\n   * configuration of the cookie that contains the client sid to send as part of handshake response headers. This cookie\n   * might be used for sticky-session. Defaults to not sending any cookie.\n   * @default false\n   */\n  cookie?: (CookieSerializeOptions & { name: string }) | boolean;\n  /**\n   * the options that will be forwarded to the cors module\n   */\n  cors?: CorsOptions | CorsOptionsDelegate;\n  /**\n   * whether to enable compatibility with Socket.IO v2 clients\n   * @default false\n   */\n  allowEIO3?: boolean;\n}\n\n/**\n * An Express-compatible middleware.\n *\n * Middleware functions are functions that have access to the request object (req), the response object (res), and the\n * next middleware function in the application\u2019s request-response cycle.\n *\n * @see https://expressjs.com/en/guide/using-middleware.html\n */\ntype Middleware = (\n  req: IncomingMessage,\n  res: ServerResponse,\n  next: (err?: any) => void\n) => void;\n\nexport abstract class BaseServer extends EventEmitter {\n  public opts: ServerOptions;\n\n  protected clients: any;\n  public clientsCount: number;\n  protected middlewares: Middleware[] = [];\n\n  /**\n   * Server constructor.\n   *\n   * @param {Object} opts - options\n   * @api public\n   */\n  constructor(opts: ServerOptions = {}) {\n    super();\n\n    this.clients = {};\n    this.clientsCount = 0;\n\n    this.opts = Object.assign(\n      {\n        wsEngine: DEFAULT_WS_ENGINE,\n        pingTimeout: 20000,\n        pingInterval: 25000,\n        upgradeTimeout: 10000,\n        maxHttpBufferSize: 1e6,\n        transports: Object.keys(transports),\n        allowUpgrades: true,\n        httpCompression: {\n          threshold: 1024,\n        },\n        cors: false,\n        allowEIO3: false,\n      },\n      opts\n    );\n\n    if (opts.cookie) {\n      this.opts.cookie = Object.assign(\n        {\n          name: \"io\",\n          path: \"/\",\n          // @ts-ignore\n          httpOnly: opts.cookie.path !== false,\n          sameSite: \"lax\",\n        },\n        opts.cookie\n      );\n    }\n\n    if (this.opts.cors) {\n      this.use(require(\"cors\")(this.opts.cors));\n    }\n\n    if (opts.perMessageDeflate) {\n      this.opts.perMessageDeflate = Object.assign(\n        {\n          threshold: 1024,\n        },\n        opts.perMessageDeflate\n      );\n    }\n\n    this.init();\n  }\n\n  protected abstract init();\n\n  /**\n   * Compute the pathname of the requests that are handled by the server\n   * @param options\n   * @protected\n   */\n  protected _computePath(options: AttachOptions) {\n    let path = (options.path || \"/engine.io\").replace(/\\/$/, \"\");\n\n    if (options.addTrailingSlash !== false) {\n      // normalize path\n      path += \"/\";\n    }\n\n    return path;\n  }\n\n  /**\n   * Returns a list of available transports for upgrade given a certain transport.\n   *\n   * @return {Array}\n   * @api public\n   */\n  public upgrades(transport) {\n    if (!this.opts.allowUpgrades) return [];\n    return transports[transport].upgradesTo || [];\n  }\n\n  /**\n   * Verifies a request.\n   *\n   * @param {http.IncomingMessage}\n   * @return {Boolean} whether the request is valid\n   * @api private\n   */\n  protected verify(req, upgrade, fn) {\n    // transport check\n    const transport = req._query.transport;\n    if (!~this.opts.transports.indexOf(transport)) {\n      debug('unknown transport \"%s\"', transport);\n      return fn(Server.errors.UNKNOWN_TRANSPORT, { transport });\n    }\n\n    // 'Origin' header check\n    const isOriginInvalid = checkInvalidHeaderChar(req.headers.origin);\n    if (isOriginInvalid) {\n      const origin = req.headers.origin;\n      req.headers.origin = null;\n      debug(\"origin header invalid\");\n      return fn(Server.errors.BAD_REQUEST, {\n        name: \"INVALID_ORIGIN\",\n        origin,\n      });\n    }\n\n    // sid check\n    const sid = req._query.sid;\n    if (sid) {\n      if (!this.clients.hasOwnProperty(sid)) {\n        debug('unknown sid \"%s\"', sid);\n        return fn(Server.errors.UNKNOWN_SID, {\n          sid,\n        });\n      }\n      const previousTransport = this.clients[sid].transport.name;\n      if (!upgrade && previousTransport !== transport) {\n        debug(\"bad request: unexpected transport without upgrade\");\n        return fn(Server.errors.BAD_REQUEST, {\n          name: \"TRANSPORT_MISMATCH\",\n          transport,\n          previousTransport,\n        });\n      }\n    } else {\n      // handshake is GET only\n      if (\"GET\" !== req.method) {\n        return fn(Server.errors.BAD_HANDSHAKE_METHOD, {\n          method: req.method,\n        });\n      }\n\n      if (transport === \"websocket\" && !upgrade) {\n        debug(\"invalid transport upgrade\");\n        return fn(Server.errors.BAD_REQUEST, {\n          name: \"TRANSPORT_HANDSHAKE_ERROR\",\n        });\n      }\n\n      if (!this.opts.allowRequest) return fn();\n\n      return this.opts.allowRequest(req, (message, success) => {\n        if (!success) {\n          return fn(Server.errors.FORBIDDEN, {\n            message,\n          });\n        }\n        fn();\n      });\n    }\n\n    fn();\n  }\n\n  /**\n   * Adds a new middleware.\n   *\n   * @example\n   * import helmet from \"helmet\";\n   *\n   * engine.use(helmet());\n   *\n   * @param fn\n   */\n  public use(fn: any) {\n    this.middlewares.push(fn);\n  }\n\n  /**\n   * Apply the middlewares to the request.\n   *\n   * @param req\n   * @param res\n   * @param callback\n   * @protected\n   */\n  protected _applyMiddlewares(\n    req: IncomingMessage,\n    res: ServerResponse,\n    callback: (err?: any) => void\n  ) {\n    if (this.middlewares.length === 0) {\n      debug(\"no middleware to apply, skipping\");\n      return callback();\n    }\n\n    const apply = (i) => {\n      debug(\"applying middleware n\u00b0%d\", i + 1);\n      this.middlewares[i](req, res, (err?: any) => {\n        if (err) {\n          return callback(err);\n        }\n\n        if (i + 1 < this.middlewares.length) {\n          apply(i + 1);\n        } else {\n          callback();\n        }\n      });\n    };\n\n    apply(0);\n  }\n\n  /**\n   * Closes all clients.\n   *\n   * @api public\n   */\n  public close() {\n    debug(\"closing all open clients\");\n    for (let i in this.clients) {\n      if (this.clients.hasOwnProperty(i)) {\n        this.clients[i].close(true);\n      }\n    }\n    this.cleanup();\n    return this;\n  }\n\n  protected abstract cleanup();\n\n  /**\n   * generate a socket id.\n   * Overwrite this method to generate your custom socket id\n   *\n   * @param {Object} request object\n   * @api public\n   */\n  public generateId(req) {\n    return base64id.generateId();\n  }\n\n  /**\n   * Handshakes a new client.\n   *\n   * @param {String} transport name\n   * @param {Object} request object\n   * @param {Function} closeConnection\n   *\n   * @api protected\n   */\n  protected async handshake(transportName, req, closeConnection) {\n    const protocol = req._query.EIO === \"4\" ? 4 : 3; // 3rd revision by default\n    if (protocol === 3 && !this.opts.allowEIO3) {\n      debug(\"unsupported protocol version\");\n      this.emit(\"connection_error\", {\n        req,\n        code: Server.errors.UNSUPPORTED_PROTOCOL_VERSION,\n        message:\n          Server.errorMessages[Server.errors.UNSUPPORTED_PROTOCOL_VERSION],\n        context: {\n          protocol,\n        },\n      });\n      closeConnection(Server.errors.UNSUPPORTED_PROTOCOL_VERSION);\n      return;\n    }\n\n    let id;\n    try {\n      id = await this.generateId(req);\n    } catch (e) {\n      debug(\"error while generating an id\");\n      this.emit(\"connection_error\", {\n        req,\n        code: Server.errors.BAD_REQUEST,\n        message: Server.errorMessages[Server.errors.BAD_REQUEST],\n        context: {\n          name: \"ID_GENERATION_ERROR\",\n          error: e,\n        },\n      });\n      closeConnection(Server.errors.BAD_REQUEST);\n      return;\n    }\n\n    debug('handshaking client \"%s\"', id);\n\n    try {\n      var transport = this.createTransport(transportName, req);\n      if (\"polling\" === transportName) {\n        transport.maxHttpBufferSize = this.opts.maxHttpBufferSize;\n        transport.httpCompression = this.opts.httpCompression;\n      } else if (\"websocket\" === transportName) {\n        transport.perMessageDeflate = this.opts.perMessageDeflate;\n      }\n\n      if (req._query && req._query.b64) {\n        transport.supportsBinary = false;\n      } else {\n        transport.supportsBinary = true;\n      }\n    } catch (e) {\n      debug('error handshaking to transport \"%s\"', transportName);\n      this.emit(\"connection_error\", {\n        req,\n        code: Server.errors.BAD_REQUEST,\n        message: Server.errorMessages[Server.errors.BAD_REQUEST],\n        context: {\n          name: \"TRANSPORT_HANDSHAKE_ERROR\",\n          error: e,\n        },\n      });\n      closeConnection(Server.errors.BAD_REQUEST);\n      return;\n    }\n    const socket = new Socket(id, this, transport, req, protocol);\n\n    transport.on(\"headers\", (headers, req) => {\n      const isInitialRequest = !req._query.sid;\n\n      if (isInitialRequest) {\n        if (this.opts.cookie) {\n          headers[\"Set-Cookie\"] = [\n            // @ts-ignore\n            serialize(this.opts.cookie.name, id, this.opts.cookie),\n          ];\n        }\n        this.emit(\"initial_headers\", headers, req);\n      }\n      this.emit(\"headers\", headers, req);\n    });\n\n    transport.onRequest(req);\n\n    this.clients[id] = socket;\n    this.clientsCount++;\n\n    socket.once(\"close\", () => {\n      delete this.clients[id];\n      this.clientsCount--;\n    });\n\n    this.emit(\"connection\", socket);\n\n    return transport;\n  }\n\n  protected abstract createTransport(transportName, req);\n\n  /**\n   * Protocol errors mappings.\n   */\n\n  static errors = {\n    UNKNOWN_TRANSPORT: 0,\n    UNKNOWN_SID: 1,\n    BAD_HANDSHAKE_METHOD: 2,\n    BAD_REQUEST: 3,\n    FORBIDDEN: 4,\n    UNSUPPORTED_PROTOCOL_VERSION: 5,\n  };\n\n  static errorMessages = {\n    0: \"Transport unknown\",\n    1: \"Session ID unknown\",\n    2: \"Bad handshake method\",\n    3: \"Bad request\",\n    4: \"Forbidden\",\n    5: \"Unsupported protocol version\",\n  };\n}\n\n/**\n * Exposes a subset of the http.ServerResponse interface, in order to be able to apply the middlewares to an upgrade\n * request.\n *\n * @see https://nodejs.org/api/http.html#class-httpserverresponse\n */\nclass WebSocketResponse {\n  constructor(readonly req, readonly socket: Duplex) {\n    // temporarily store the response headers on the req object (see the \"headers\" event)\n    req[kResponseHeaders] = {};\n  }\n\n  public setHeader(name: string, value: any) {\n    this.req[kResponseHeaders][name] = value;\n  }\n\n  public getHeader(name: string) {\n    return this.req[kResponseHeaders][name];\n  }\n\n  public removeHeader(name: string) {\n    delete this.req[kResponseHeaders][name];\n  }\n\n  public write() {}\n\n  public writeHead() {}\n\n  public end() {\n    // we could return a proper error code, but the WebSocket client will emit an \"error\" event anyway.\n    this.socket.destroy();\n  }\n}\n\nexport class Server extends BaseServer {\n  public httpServer?: HttpServer;\n  private ws: any;\n\n  /**\n   * Initialize websocket server\n   *\n   * @api protected\n   */\n  protected init() {\n    if (!~this.opts.transports.indexOf(\"websocket\")) return;\n\n    if (this.ws) this.ws.close();\n\n    this.ws = new this.opts.wsEngine({\n      noServer: true,\n      clientTracking: false,\n      perMessageDeflate: this.opts.perMessageDeflate,\n      maxPayload: this.opts.maxHttpBufferSize,\n    });\n\n    if (typeof this.ws.on === \"function\") {\n      this.ws.on(\"headers\", (headersArray, req) => {\n        // note: 'ws' uses an array of headers, while Engine.IO uses an object (response.writeHead() accepts both formats)\n        // we could also try to parse the array and then sync the values, but that will be error-prone\n        const additionalHeaders = req[kResponseHeaders] || {};\n        delete req[kResponseHeaders];\n\n        const isInitialRequest = !req._query.sid;\n        if (isInitialRequest) {\n          this.emit(\"initial_headers\", additionalHeaders, req);\n        }\n\n        this.emit(\"headers\", additionalHeaders, req);\n\n        debug(\"writing headers: %j\", additionalHeaders);\n        Object.keys(additionalHeaders).forEach((key) => {\n          headersArray.push(`${key}: ${additionalHeaders[key]}`);\n        });\n      });\n    }\n  }\n\n  protected cleanup() {\n    if (this.ws) {\n      debug(\"closing webSocketServer\");\n      this.ws.close();\n      // don't delete this.ws because it can be used again if the http server starts listening again\n    }\n  }\n\n  /**\n   * Prepares a request by processing the query string.\n   *\n   * @api private\n   */\n  private prepare(req) {\n    // try to leverage pre-existing `req._query` (e.g: from connect)\n    if (!req._query) {\n      req._query = ~req.url.indexOf(\"?\") ? qs.parse(parse(req.url).query) : {};\n    }\n  }\n\n  protected createTransport(transportName, req) {\n    return new transports[transportName](req);\n  }\n\n  /**\n   * Handles an Engine.IO HTTP request.\n   *\n   * @param {IncomingMessage} req\n   * @param {ServerResponse} res\n   * @api public\n   */\n  public handleRequest(req: IncomingMessage, res: ServerResponse) {\n    debug('handling \"%s\" http request \"%s\"', req.method, req.url);\n    this.prepare(req);\n    // @ts-ignore\n    req.res = res;\n\n    const callback = (errorCode, errorContext) => {\n      if (errorCode !== undefined) {\n        this.emit(\"connection_error\", {\n          req,\n          code: errorCode,\n          message: Server.errorMessages[errorCode],\n          context: errorContext,\n        });\n        abortRequest(res, errorCode, errorContext);\n        return;\n      }\n\n      // @ts-ignore\n      if (req._query.sid) {\n        debug(\"setting new request for existing client\");\n        // @ts-ignore\n        this.clients[req._query.sid].transport.onRequest(req);\n      } else {\n        const closeConnection = (errorCode, errorContext) =>\n          abortRequest(res, errorCode, errorContext);\n        // @ts-ignore\n        this.handshake(req._query.transport, req, closeConnection);\n      }\n    };\n\n    this._applyMiddlewares(req, res, (err) => {\n      if (err) {\n        callback(Server.errors.BAD_REQUEST, { name: \"MIDDLEWARE_FAILURE\" });\n      } else {\n        this.verify(req, false, callback);\n      }\n    });\n  }\n\n  /**\n   * Handles an Engine.IO HTTP Upgrade.\n   *\n   * @api public\n   */\n  public handleUpgrade(\n    req: IncomingMessage,\n    socket: Duplex,\n    upgradeHead: Buffer\n  ) {\n    this.prepare(req);\n\n    const res = new WebSocketResponse(req, socket);\n    const callback = (errorCode, errorContext) => {\n      if (errorCode !== undefined) {\n        this.emit(\"connection_error\", {\n          req,\n          code: errorCode,\n          message: Server.errorMessages[errorCode],\n          context: errorContext,\n        });\n        abortUpgrade(socket, errorCode, errorContext);\n        return;\n      }\n\n      const head = Buffer.from(upgradeHead);\n      upgradeHead = null;\n\n      // some middlewares (like express-session) wait for the writeHead() call to flush their headers\n      // see https://github.com/expressjs/session/blob/1010fadc2f071ddf2add94235d72224cf65159c6/index.js#L220-L244\n      res.writeHead();\n\n      // delegate to ws\n      this.ws.handleUpgrade(req, socket, head, (websocket) => {\n        this.onWebSocket(req, socket, websocket);\n      });\n    };\n\n    this._applyMiddlewares(req, res as unknown as ServerResponse, (err) => {\n      if (err) {\n        callback(Server.errors.BAD_REQUEST, { name: \"MIDDLEWARE_FAILURE\" });\n      } else {\n        this.verify(req, true, callback);\n      }\n    });\n  }\n\n  /**\n   * Called upon a ws.io connection.\n   *\n   * @param {ws.Socket} websocket\n   * @api private\n   */\n  private onWebSocket(req, socket, websocket) {\n    websocket.on(\"error\", onUpgradeError);\n\n    if (\n      transports[req._query.transport] !== undefined &&\n      !transports[req._query.transport].prototype.handlesUpgrades\n    ) {\n      debug(\"transport doesnt handle upgraded requests\");\n      websocket.close();\n      return;\n    }\n\n    // get client id\n    const id = req._query.sid;\n\n    // keep a reference to the ws.Socket\n    req.websocket = websocket;\n\n    if (id) {\n      const client = this.clients[id];\n      if (!client) {\n        debug(\"upgrade attempt for closed client\");\n        websocket.close();\n      } else if (client.upgrading) {\n        debug(\"transport has already been trying to upgrade\");\n        websocket.close();\n      } else if (client.upgraded) {\n        debug(\"transport had already been upgraded\");\n        websocket.close();\n      } else {\n        debug(\"upgrading existing transport\");\n\n        // transport error handling takes over\n        websocket.removeListener(\"error\", onUpgradeError);\n\n        const transport = this.createTransport(req._query.transport, req);\n        if (req._query && req._query.b64) {\n          transport.supportsBinary = false;\n        } else {\n          transport.supportsBinary = true;\n        }\n        transport.perMessageDeflate = this.opts.perMessageDeflate;\n        client.maybeUpgrade(transport);\n      }\n    } else {\n      const closeConnection = (errorCode, errorContext) =>\n        abortUpgrade(socket, errorCode, errorContext);\n      this.handshake(req._query.transport, req, closeConnection);\n    }\n\n    function onUpgradeError() {\n      debug(\"websocket error before upgrade\");\n      // websocket.close() not needed\n    }\n  }\n\n  /**\n   * Captures upgrade requests for a http.Server.\n   *\n   * @param {http.Server} server\n   * @param {Object} options\n   * @api public\n   */\n  public attach(server: HttpServer, options: AttachOptions = {}) {\n    const path = this._computePath(options);\n    const destroyUpgradeTimeout = options.destroyUpgradeTimeout || 1000;\n\n    function check(req) {\n      // TODO use `path === new URL(...).pathname` in the next major release (ref: https://nodejs.org/api/url.html)\n      return path === req.url.slice(0, path.length);\n    }\n\n    // cache and clean up listeners\n    const listeners = server.listeners(\"request\").slice(0);\n    server.removeAllListeners(\"request\");\n    server.on(\"close\", this.close.bind(this));\n    server.on(\"listening\", this.init.bind(this));\n\n    // add request handler\n    server.on(\"request\", (req, res) => {\n      if (check(req)) {\n        debug('intercepting request for path \"%s\"', path);\n        this.handleRequest(req, res);\n      } else {\n        let i = 0;\n        const l = listeners.length;\n        for (; i < l; i++) {\n          listeners[i].call(server, req, res);\n        }\n      }\n    });\n\n    if (~this.opts.transports.indexOf(\"websocket\")) {\n      server.on(\"upgrade\", (req, socket, head) => {\n        if (check(req)) {\n          this.handleUpgrade(req, socket, head);\n        } else if (false !== options.destroyUpgrade) {\n          // default node behavior is to disconnect when no handlers\n          // but by adding a handler, we prevent that\n          // and if no eio thing handles the upgrade\n          // then the socket needs to die!\n          setTimeout(function () {\n            // @ts-ignore\n            if (socket.writable && socket.bytesWritten <= 0) {\n              socket.on(\"error\", (e) => {\n                debug(\"error while destroying upgrade: %s\", e.message);\n              });\n              return socket.end();\n            }\n          }, destroyUpgradeTimeout);\n        }\n      });\n    }\n  }\n}\n\n/**\n * Close the HTTP long-polling request\n *\n * @param res - the response object\n * @param errorCode - the error code\n * @param errorContext - additional error context\n *\n * @api private\n */\n\nfunction abortRequest(res, errorCode, errorContext) {\n  const statusCode = errorCode === Server.errors.FORBIDDEN ? 403 : 400;\n  const message =\n    errorContext && errorContext.message\n      ? errorContext.message\n      : Server.errorMessages[errorCode];\n\n  res.writeHead(statusCode, { \"Content-Type\": \"application/json\" });\n  res.end(\n    JSON.stringify({\n      code: errorCode,\n      message,\n    })\n  );\n}\n\n/**\n * Close the WebSocket connection\n *\n * @param {net.Socket} socket\n * @param {string} errorCode - the error code\n * @param {object} errorContext - additional error context\n *\n * @api private\n */\n\nfunction abortUpgrade(\n  socket,\n  errorCode,\n  errorContext: { message?: string } = {}\n) {\n  socket.on(\"error\", () => {\n    debug(\"ignoring error from closed connection\");\n  });\n  if (socket.writable) {\n    const message = errorContext.message || Server.errorMessages[errorCode];\n    const length = Buffer.byteLength(message);\n    socket.write(\n      \"HTTP/1.1 400 Bad Request\\r\\n\" +\n        \"Connection: close\\r\\n\" +\n        \"Content-type: text/html\\r\\n\" +\n        \"Content-Length: \" +\n        length +\n        \"\\r\\n\" +\n        \"\\r\\n\" +\n        message\n    );\n  }\n  socket.destroy();\n}\n\n/* eslint-disable */\n\n/**\n * From https://github.com/nodejs/node/blob/v8.4.0/lib/_http_common.js#L303-L354\n *\n * True if val contains an invalid field-vchar\n *  field-value    = *( field-content / obs-fold )\n *  field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]\n *  field-vchar    = VCHAR / obs-text\n *\n * checkInvalidHeaderChar() is currently designed to be inlinable by v8,\n * so take care when making changes to the implementation so that the source\n * code size does not exceed v8's default max_inlined_source_size setting.\n **/\n// prettier-ignore\nconst validHdrChars = [\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, // 0 - 15\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 32 - 47\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 48 - 63\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 80 - 95\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, // 112 - 127\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 128 ...\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1  // ... 255\n]\n\nfunction checkInvalidHeaderChar(val) {\n  val += \"\";\n  if (val.length < 1) return false;\n  if (!validHdrChars[val.charCodeAt(0)]) {\n    debug('invalid header, index 0, char \"%s\"', val.charCodeAt(0));\n    return true;\n  }\n  if (val.length < 2) return false;\n  if (!validHdrChars[val.charCodeAt(1)]) {\n    debug('invalid header, index 1, char \"%s\"', val.charCodeAt(1));\n    return true;\n  }\n  if (val.length < 3) return false;\n  if (!validHdrChars[val.charCodeAt(2)]) {\n    debug('invalid header, index 2, char \"%s\"', val.charCodeAt(2));\n    return true;\n  }\n  if (val.length < 4) return false;\n  if (!validHdrChars[val.charCodeAt(3)]) {\n    debug('invalid header, index 3, char \"%s\"', val.charCodeAt(3));\n    return true;\n  }\n  for (let i = 4; i < val.length; ++i) {\n    if (!validHdrChars[val.charCodeAt(i)]) {\n      debug('invalid header, index \"%i\", char \"%s\"', i, val.charCodeAt(i));\n      return true;\n    }\n  }\n  return false;\n}\n", "import debugModule from \"debug\";\nimport { AttachOptions, BaseServer, Server } from \"./server\";\nimport { HttpRequest, HttpResponse, TemplatedApp } from \"uWebSockets.js\";\nimport transports from \"./transports-uws\";\n\nconst debug = debugModule(\"engine:uws\");\n\nexport interface uOptions {\n  /**\n   * What permessage-deflate compression to use. uWS.DISABLED, uWS.SHARED_COMPRESSOR or any of the uWS.DEDICATED_COMPRESSOR_xxxKB.\n   * @default uWS.DISABLED\n   */\n  compression?: number;\n  /**\n   * Maximum amount of seconds that may pass without sending or getting a message. Connection is closed if this timeout passes. Resolution (granularity) for timeouts are typically 4 seconds, rounded to closest. Disable by using 0.\n   * @default 120\n   */\n  idleTimeout?: number;\n  /**\n   * Maximum length of allowed backpressure per socket when publishing or sending messages. Slow receivers with too high backpressure will be skipped until they catch up or timeout.\n   * @default 1024 * 1024\n   */\n  maxBackpressure?: number;\n}\n\nexport class uServer extends BaseServer {\n  protected init() {}\n  protected cleanup() {}\n\n  /**\n   * Prepares a request by processing the query string.\n   *\n   * @api private\n   */\n  private prepare(req, res: HttpResponse) {\n    req.method = req.getMethod().toUpperCase();\n    req.url = req.getUrl();\n\n    const params = new URLSearchParams(req.getQuery());\n    req._query = Object.fromEntries(params.entries());\n\n    req.headers = {};\n    req.forEach((key, value) => {\n      req.headers[key] = value;\n    });\n\n    req.connection = {\n      remoteAddress: Buffer.from(res.getRemoteAddressAsText()).toString(),\n    };\n\n    res.onAborted(() => {\n      debug(\"response has been aborted\");\n    });\n  }\n\n  protected createTransport(transportName, req) {\n    return new transports[transportName](req);\n  }\n\n  /**\n   * Attach the engine to a \u00b5WebSockets.js server\n   * @param app\n   * @param options\n   */\n  public attach(\n    app /* : TemplatedApp */,\n    options: AttachOptions & uOptions = {}\n  ) {\n    const path = this._computePath(options);\n    (app as TemplatedApp)\n      .any(path, this.handleRequest.bind(this))\n      //\n      .ws(path, {\n        compression: options.compression,\n        idleTimeout: options.idleTimeout,\n        maxBackpressure: options.maxBackpressure,\n        maxPayloadLength: this.opts.maxHttpBufferSize,\n        upgrade: this.handleUpgrade.bind(this),\n        open: (ws) => {\n          ws.transport.socket = ws;\n          ws.transport.writable = true;\n          ws.transport.emit(\"drain\");\n        },\n        message: (ws, message, isBinary) => {\n          ws.transport.onData(\n            isBinary ? message : Buffer.from(message).toString()\n          );\n        },\n        close: (ws, code, message) => {\n          ws.transport.onClose(code, message);\n        },\n      });\n  }\n\n  override _applyMiddlewares(\n    req: any,\n    res: any,\n    callback: (err?: any) => void\n  ): void {\n    if (this.middlewares.length === 0) {\n      return callback();\n    }\n\n    // needed to buffer headers until the status is computed\n    req.res = new ResponseWrapper(res);\n\n    super._applyMiddlewares(req, req.res, (err) => {\n      // some middlewares (like express-session) wait for the writeHead() call to flush their headers\n      // see https://github.com/expressjs/session/blob/1010fadc2f071ddf2add94235d72224cf65159c6/index.js#L220-L244\n      req.res.writeHead();\n\n      callback(err);\n    });\n  }\n\n  private handleRequest(\n    res: HttpResponse,\n    req: HttpRequest & { res: any; _query: any }\n  ) {\n    debug('handling \"%s\" http request \"%s\"', req.getMethod(), req.getUrl());\n    this.prepare(req, res);\n\n    req.res = res;\n\n    const callback = (errorCode, errorContext) => {\n      if (errorCode !== undefined) {\n        this.emit(\"connection_error\", {\n          req,\n          code: errorCode,\n          message: Server.errorMessages[errorCode],\n          context: errorContext,\n        });\n        this.abortRequest(req.res, errorCode, errorContext);\n        return;\n      }\n\n      if (req._query.sid) {\n        debug(\"setting new request for existing client\");\n        this.clients[req._query.sid].transport.onRequest(req);\n      } else {\n        const closeConnection = (errorCode, errorContext) =>\n          this.abortRequest(res, errorCode, errorContext);\n        this.handshake(req._query.transport, req, closeConnection);\n      }\n    };\n\n    this._applyMiddlewares(req, res, (err) => {\n      if (err) {\n        callback(Server.errors.BAD_REQUEST, { name: \"MIDDLEWARE_FAILURE\" });\n      } else {\n        this.verify(req, false, callback);\n      }\n    });\n  }\n\n  private handleUpgrade(\n    res: HttpResponse,\n    req: HttpRequest & { res: any; _query: any },\n    context\n  ) {\n    debug(\"on upgrade\");\n\n    this.prepare(req, res);\n\n    req.res = res;\n\n    const callback = async (errorCode, errorContext) => {\n      if (errorCode !== undefined) {\n        this.emit(\"connection_error\", {\n          req,\n          code: errorCode,\n          message: Server.errorMessages[errorCode],\n          context: errorContext,\n        });\n        this.abortRequest(res, errorCode, errorContext);\n        return;\n      }\n\n      const id = req._query.sid;\n      let transport;\n\n      if (id) {\n        const client = this.clients[id];\n        if (!client) {\n          debug(\"upgrade attempt for closed client\");\n          res.close();\n        } else if (client.upgrading) {\n          debug(\"transport has already been trying to upgrade\");\n          res.close();\n        } else if (client.upgraded) {\n          debug(\"transport had already been upgraded\");\n          res.close();\n        } else {\n          debug(\"upgrading existing transport\");\n          transport = this.createTransport(req._query.transport, req);\n          client.maybeUpgrade(transport);\n        }\n      } else {\n        transport = await this.handshake(\n          req._query.transport,\n          req,\n          (errorCode, errorContext) =>\n            this.abortRequest(res, errorCode, errorContext)\n        );\n        if (!transport) {\n          return;\n        }\n      }\n\n      // calling writeStatus() triggers the flushing of any header added in a middleware\n      req.res.writeStatus(\"101 Switching Protocols\");\n\n      res.upgrade(\n        {\n          transport,\n        },\n        req.getHeader(\"sec-websocket-key\"),\n        req.getHeader(\"sec-websocket-protocol\"),\n        req.getHeader(\"sec-websocket-extensions\"),\n        context\n      );\n    };\n\n    this._applyMiddlewares(req, res, (err) => {\n      if (err) {\n        callback(Server.errors.BAD_REQUEST, { name: \"MIDDLEWARE_FAILURE\" });\n      } else {\n        this.verify(req, true, callback);\n      }\n    });\n  }\n\n  private abortRequest(\n    res: HttpResponse | ResponseWrapper,\n    errorCode,\n    errorContext\n  ) {\n    const statusCode =\n      errorCode === Server.errors.FORBIDDEN\n        ? \"403 Forbidden\"\n        : \"400 Bad Request\";\n    const message =\n      errorContext && errorContext.message\n        ? errorContext.message\n        : Server.errorMessages[errorCode];\n\n    res.writeStatus(statusCode);\n    res.writeHeader(\"Content-Type\", \"application/json\");\n    res.end(\n      JSON.stringify({\n        code: errorCode,\n        message,\n      })\n    );\n  }\n}\n\nclass ResponseWrapper {\n  private statusWritten: boolean = false;\n  private headers = [];\n\n  constructor(readonly res: HttpResponse) {}\n\n  public set statusCode(status: number) {\n    if (!status) {\n      return;\n    }\n    // FIXME: handle all status codes?\n    this.writeStatus(status === 200 ? \"200 OK\" : \"204 No Content\");\n  }\n\n  public writeHead(status: number) {\n    this.statusCode = status;\n  }\n\n  public setHeader(key, value) {\n    if (Array.isArray(value)) {\n      value.forEach((val) => {\n        this.writeHeader(key, val);\n      });\n    } else {\n      this.writeHeader(key, value);\n    }\n  }\n\n  public removeHeader() {\n    // FIXME: not implemented\n  }\n\n  // needed by vary: https://github.com/jshttp/vary/blob/5d725d059b3871025cf753e9dfa08924d0bcfa8f/index.js#L134\n  public getHeader() {}\n\n  public writeStatus(status: string) {\n    this.res.writeStatus(status);\n    this.statusWritten = true;\n    this.writeBufferedHeaders();\n    return this;\n  }\n\n  public writeHeader(key: string, value: string) {\n    if (key === \"Content-Length\") {\n      // the content length is automatically added by uWebSockets.js\n      return;\n    }\n    if (this.statusWritten) {\n      this.res.writeHeader(key, value);\n    } else {\n      this.headers.push([key, value]);\n    }\n  }\n\n  private writeBufferedHeaders() {\n    this.headers.forEach(([key, value]) => {\n      this.res.writeHeader(key, value);\n    });\n  }\n\n  public end(data) {\n    if (!this.statusWritten) {\n      // status will be inferred as \"200 OK\"\n      this.writeBufferedHeaders();\n    }\n    this.res.end(data);\n  }\n\n  public onData(fn) {\n    this.res.onData(fn);\n  }\n\n  public onAborted(fn) {\n    this.res.onAborted(fn);\n  }\n}\n", "/* eslint-disable standard/no-callback-literal */\n\nconst http = require(\"http\");\nconst https = require(\"https\");\nconst fs = require(\"fs\");\nconst path = require(\"path\");\nconst exec = require(\"child_process\").exec;\nconst zlib = require(\"zlib\");\nconst { Server, Socket, attach } = require(\"..\");\nconst { ClientSocket, listen, createPartialDone } = require(\"./common\");\nconst expect = require(\"expect.js\");\nconst request = require(\"superagent\");\nconst cookieMod = require(\"cookie\");\nconst { WebSocket } = require(\"ws\");\n\n/**\n * Tests.\n */\n\ndescribe(\"server\", () => {\n  let engine, client;\n\n  afterEach(() => {\n    if (engine && engine.httpServer) {\n      engine.httpServer.close();\n    }\n    if (client) {\n      client.close();\n    }\n  });\n\n  describe(\"verification\", () => {\n    it(\"should disallow non-existent transports\", (done) => {\n      const partialDone = createPartialDone(done, 2);\n\n      engine = listen((port) => {\n        engine.on(\"connection_error\", (err) => {\n          expect(err.req).to.be.ok();\n          expect(err.code).to.be(0);\n          expect(err.message).to.be(\"Transport unknown\");\n          expect(err.context.transport).to.be(\"tobi\");\n          partialDone();\n        });\n\n        request\n          .get(`http://localhost:${port}/engine.io/`)\n          .query({ transport: \"tobi\" }) // no tobi transport - outrageous\n          .end((err, res) => {\n            expect(err).to.be.an(Error);\n            expect(res.status).to.be(400);\n            expect(res.body.code).to.be(0);\n            expect(res.body.message).to.be(\"Transport unknown\");\n            partialDone();\n          });\n      });\n    });\n\n    it(\"should disallow `constructor` as transports\", (done) => {\n      const partialDone = createPartialDone(done, 2);\n\n      // make sure we check for actual properties - not those present on every {}\n      engine = listen((port) => {\n        engine.on(\"connection_error\", (err) => {\n          expect(err.req).to.be.ok();\n          expect(err.code).to.be(0);\n          expect(err.message).to.be(\"Transport unknown\");\n          expect(err.context.transport).to.be(\"constructor\");\n          partialDone();\n        });\n\n        request\n          .get(`http://localhost:${port}/engine.io/`)\n          .set(\"Origin\", \"http://engine.io\")\n          .query({ transport: \"constructor\" })\n          .end((err, res) => {\n            expect(err).to.be.an(Error);\n            expect(res.status).to.be(400);\n            expect(res.body.code).to.be(0);\n            expect(res.body.message).to.be(\"Transport unknown\");\n            partialDone();\n          });\n      });\n    });\n\n    it(\"should disallow non-existent sids\", (done) => {\n      const partialDone = createPartialDone(done, 2);\n\n      engine = listen((port) => {\n        engine.on(\"connection_error\", (err) => {\n          expect(err.req).to.be.ok();\n          expect(err.code).to.be(1);\n          expect(err.message).to.be(\"Session ID unknown\");\n          expect(err.context.sid).to.be(\"test\");\n          partialDone();\n        });\n\n        request\n          .get(`http://localhost:${port}/engine.io/`)\n          .set(\"Origin\", \"http://engine.io\")\n          .query({ transport: \"polling\", sid: \"test\" })\n          .end((err, res) => {\n            expect(err).to.be.an(Error);\n            expect(res.status).to.be(400);\n            expect(res.body.code).to.be(1);\n            expect(res.body.message).to.be(\"Session ID unknown\");\n            partialDone();\n          });\n      });\n    });\n\n    it(\"should disallow requests that are rejected by `allowRequest`\", (done) => {\n      const partialDone = createPartialDone(done, 2);\n\n      engine = listen(\n        {\n          allowRequest: (req, fn) => {\n            fn(\"Thou shall not pass\", false);\n          },\n        },\n        (port) => {\n          engine.on(\"connection_error\", (err) => {\n            expect(err.req).to.be.ok();\n            expect(err.code).to.be(4);\n            expect(err.message).to.be(\"Forbidden\");\n            expect(err.context.message).to.be(\"Thou shall not pass\");\n            partialDone();\n          });\n\n          request\n            .get(`http://localhost:${port}/engine.io/`)\n            .set(\"Origin\", \"http://engine.io\")\n            .query({ transport: \"polling\" })\n            .end((err, res) => {\n              expect(err).to.be.an(Error);\n              expect(res.status).to.be(403);\n              expect(res.body.code).to.be(4);\n              expect(res.body.message).to.be(\"Thou shall not pass\");\n              partialDone();\n            });\n        }\n      );\n    });\n\n    it(\"should disallow connection that are rejected by `allowRequest` (ws)\", (done) => {\n      listen(\n        {\n          allowRequest: (req, fn) => {\n            fn(null, false);\n          },\n        },\n        (port) => {\n          const client = new ClientSocket(`ws://localhost:${port}`, {\n            transports: [\"websocket\"],\n          });\n          client.on(\"error\", () => {\n            done();\n          });\n        }\n      );\n    });\n\n    it(\"should not throw when the client sends invalid data during the handshake (ws only)\", (done) => {\n      listen((port) => {\n        // will throw \"RangeError: Invalid WebSocket frame: RSV2 and RSV3 must be clear\"\n        request\n          .get(`http://localhost:${port}/engine.io/`)\n          .set(\"connection\", \"upgrade\")\n          .set(\"upgrade\", \"websocket\")\n          .set(\"Sec-WebSocket-Version\", \"13\")\n          .set(\"Sec-WebSocket-Key\", \"DXR4dX615eRds8nRmlhqtw==\")\n          .query({ transport: \"websocket\", EIO: 4 })\n          .send(\"test\")\n          .end(() => {});\n\n        setTimeout(done, 50);\n      });\n    });\n\n    it(\"should not throw when the client sends invalid data during the handshake (upgrade)\", (done) => {\n      listen((port) => {\n        request\n          .get(`http://localhost:${port}/engine.io/`)\n          .query({ transport: \"polling\", EIO: 4 })\n          .end((err, res) => {\n            const sid = JSON.parse(res.text.slice(1)).sid;\n\n            request\n              .get(`http://localhost:${port}/engine.io/`)\n              .set(\"connection\", \"upgrade\")\n              .set(\"upgrade\", \"websocket\")\n              .set(\"Sec-WebSocket-Version\", \"13\")\n              .set(\"Sec-WebSocket-Key\", \"DXR4dX615eRds8nRmlhqtw==\")\n              .query({ transport: \"websocket\", EIO: 4, sid })\n              .send(\"test\")\n              .end(() => {});\n\n            setTimeout(done, 50);\n          });\n      });\n    });\n\n    it(\"should disallow `__proto__` as transport (polling)\", (done) => {\n      const partialDone = createPartialDone(done, 2);\n\n      engine = listen((port) => {\n        engine.on(\"connection_error\", (err) => {\n          expect(err.req).to.be.ok();\n          expect(err.code).to.be(0);\n          expect(err.message).to.be(\"Transport unknown\");\n          expect(err.context.transport).to.be(\"__proto__\");\n          partialDone();\n        });\n\n        request\n          .get(`http://localhost:${port}/engine.io/`)\n          .query({ transport: \"__proto__\", EIO: 4 })\n          .end((err, res) => {\n            expect(err).to.be.an(Error);\n            expect(res.status).to.be(400);\n            expect(res.body.code).to.be(0);\n            expect(res.body.message).to.be(\"Transport unknown\");\n            partialDone();\n          });\n      });\n    });\n\n    it(\"should disallow `__proto__` as transport (websocket)\", (done) => {\n      const partialDone = createPartialDone(done, 2);\n\n      engine = listen((port) => {\n        engine.on(\"connection_error\", (err) => {\n          expect(err.req).to.be.ok();\n          expect(err.code).to.be(0);\n          expect(err.message).to.be(\"Transport unknown\");\n          expect(err.context.transport).to.be(\"__proto__\");\n          partialDone();\n        });\n\n        const socket = new WebSocket(\n          `ws://localhost:${port}/engine.io/?EIO=4&transport=__proto__`\n        );\n\n        socket.onerror = partialDone;\n      });\n    });\n  });\n\n  describe(\"handshake\", () => {\n    it(\"should send the io cookie\", (done) => {\n      listen({ cookie: true }, (port) => {\n        request\n          .get(`http://localhost:${port}/engine.io/`)\n          .query({ transport: \"polling\", EIO: 4 })\n          .end((err, res) => {\n            expect(err).to.be(null);\n            // hack-obtain sid\n            const sid = res.text.match(/\"sid\":\"([^\"]+)\"/)[1];\n            expect(res.headers[\"set-cookie\"][0]).to.be(\n              `io=${sid}; Path=/; HttpOnly; SameSite=Lax`\n            );\n            done();\n          });\n      });\n    });\n\n    it(\"should send the io cookie custom name\", (done) => {\n      listen({ cookie: { name: \"woot\" } }, (port) => {\n        request\n          .get(`http://localhost:${port}/engine.io/`)\n          .query({ transport: \"polling\", b64: 1 })\n          .end((err, res) => {\n            expect(err).to.be(null);\n            const sid = res.text.match(/\"sid\":\"([^\"]+)\"/)[1];\n            expect(res.headers[\"set-cookie\"][0]).to.be(\n              `woot=${sid}; Path=/; HttpOnly; SameSite=Lax`\n            );\n            done();\n          });\n      });\n    });\n\n    it(\"should send the cookie with custom path\", (done) => {\n      listen({ cookie: { path: \"/custom\" } }, (port) => {\n        request\n          .get(`http://localhost:${port}/engine.io/`)\n          .query({ transport: \"polling\", b64: 1 })\n          .end((err, res) => {\n            expect(err).to.be(null);\n            const sid = res.text.match(/\"sid\":\"([^\"]+)\"/)[1];\n            expect(res.headers[\"set-cookie\"][0]).to.be(\n              `io=${sid}; Path=/custom; HttpOnly; SameSite=Lax`\n            );\n            done();\n          });\n      });\n    });\n\n    it(\"should send the cookie with path=false\", (done) => {\n      listen({ cookie: { path: false } }, (port) => {\n        request\n          .get(`http://localhost:${port}/engine.io/`)\n          .query({ transport: \"polling\", b64: 1 })\n          .end((err, res) => {\n            expect(err).to.be(null);\n            const sid = res.text.match(/\"sid\":\"([^\"]+)\"/)[1];\n            expect(res.headers[\"set-cookie\"][0]).to.be(\n              `io=${sid}; SameSite=Lax`\n            );\n            done();\n          });\n      });\n    });\n\n    it(\"should send the io cookie with httpOnly=true\", (done) => {\n      listen({ cookie: { httpOnly: true } }, (port) => {\n        request\n          .get(`http://localhost:${port}/engine.io/`)\n          .query({ transport: \"polling\", b64: 1 })\n          .end((err, res) => {\n            expect(err).to.be(null);\n            const sid = res.text.match(/\"sid\":\"([^\"]+)\"/)[1];\n            expect(res.headers[\"set-cookie\"][0]).to.be(\n              `io=${sid}; Path=/; HttpOnly; SameSite=Lax`\n            );\n            done();\n          });\n      });\n    });\n\n    it(\"should send the io cookie with sameSite=strict\", (done) => {\n      listen({ cookie: { sameSite: \"strict\" } }, (port) => {\n        request\n          .get(`http://localhost:${port}/engine.io/`)\n          .query({ transport: \"polling\", b64: 1 })\n          .end((err, res) => {\n            expect(err).to.be(null);\n            const sid = res.text.match(/\"sid\":\"([^\"]+)\"/)[1];\n            expect(res.headers[\"set-cookie\"][0]).to.be(\n              `io=${sid}; Path=/; HttpOnly; SameSite=Strict`\n            );\n            done();\n          });\n      });\n    });\n\n    it(\"should send the io cookie with httpOnly=false\", (done) => {\n      listen({ cookie: { httpOnly: false } }, (port) => {\n        request\n          .get(`http://localhost:${port}/engine.io/`)\n          .query({ transport: \"polling\", b64: 1 })\n          .end((err, res) => {\n            expect(err).to.be(null);\n            const sid = res.text.match(/\"sid\":\"([^\"]+)\"/)[1];\n            expect(res.headers[\"set-cookie\"][0]).to.be(\n              `io=${sid}; Path=/; SameSite=Lax`\n            );\n            done();\n          });\n      });\n    });\n\n    it(\"should send the io cookie with httpOnly not boolean\", (done) => {\n      listen({ cookie: { httpOnly: \"no\" } }, (port) => {\n        request\n          .get(`http://localhost:${port}/engine.io/`)\n          .query({ transport: \"polling\", b64: 1 })\n          .end((err, res) => {\n            expect(err).to.be(null);\n            const sid = res.text.match(/\"sid\":\"([^\"]+)\"/)[1];\n            expect(res.headers[\"set-cookie\"][0]).to.be(\n              `io=${sid}; Path=/; HttpOnly; SameSite=Lax`\n            );\n            done();\n          });\n      });\n    });\n\n    it(\"should not send the io cookie\", (done) => {\n      listen({ cookie: false }, (port) => {\n        request\n          .get(`http://localhost:${port}/engine.io/`)\n          .query({ transport: \"polling\" })\n          .end((err, res) => {\n            expect(err).to.be(null);\n            expect(res.headers[\"set-cookie\"]).to.be(undefined);\n            done();\n          });\n      });\n    });\n\n    it(\"should register a new client\", (done) => {\n      const engine = listen({ allowUpgrades: false }, (port) => {\n        expect(Object.keys(engine.clients)).to.have.length(0);\n        expect(engine.clientsCount).to.be(0);\n\n        const socket = new ClientSocket(`ws://localhost:${port}`);\n        socket.on(\"open\", () => {\n          expect(Object.keys(engine.clients)).to.have.length(1);\n          expect(engine.clientsCount).to.be(1);\n          done();\n        });\n      });\n    });\n\n    it(\"should register a new client with custom id\", (done) => {\n      const engine = listen({ allowUpgrades: false }, (port) => {\n        expect(Object.keys(engine.clients)).to.have.length(0);\n        expect(engine.clientsCount).to.be(0);\n\n        const customId = \"CustomId\" + Date.now();\n\n        engine.generateId = (req) => customId;\n\n        const socket = new ClientSocket(`ws://localhost:${port}`);\n        socket.once(\"open\", () => {\n          expect(Object.keys(engine.clients)).to.have.length(1);\n          expect(engine.clientsCount).to.be(1);\n          expect(socket.id).to.be(customId);\n          expect(engine.clients[customId].id).to.be(customId);\n          done();\n        });\n      });\n    });\n\n    it(\"should register a new client with custom id (with a Promise)\", (done) => {\n      const engine = listen({ allowUpgrades: false }, (port) => {\n        const customId = \"CustomId\" + Date.now();\n\n        engine.generateId = () => Promise.resolve(customId);\n\n        const socket = new ClientSocket(`ws://localhost:${port}`);\n        socket.once(\"open\", () => {\n          expect(socket.id).to.be(customId);\n          expect(engine.clients[customId].id).to.be(customId);\n          done();\n        });\n      });\n    });\n\n    it(\"should disallow connection that are rejected by `generateId`\", (done) => {\n      const partialDone = createPartialDone(done, 2);\n\n      engine = listen({ allowUpgrades: false }, (port) => {\n        engine.generateId = () => {\n          return Promise.reject(new Error(\"nope\"));\n        };\n\n        engine.on(\"connection_error\", (err) => {\n          expect(err.req).to.be.ok();\n          expect(err.code).to.be(3);\n          expect(err.message).to.be(\"Bad request\");\n          expect(err.context.name).to.be(\"ID_GENERATION_ERROR\");\n          partialDone();\n        });\n\n        const socket = new ClientSocket(`ws://localhost:${port}`);\n        socket.on(\"error\", () => {\n          partialDone();\n        });\n      });\n    });\n\n    it(\"should disallow connection that are rejected by `generateId` (websocket only)\", function (done) {\n      if (process.env.EIO_WS_ENGINE === \"eiows\") {\n        return this.skip();\n      }\n      const partialDone = createPartialDone(done, 2);\n\n      engine = listen({ allowUpgrades: false }, (port) => {\n        engine.generateId = () => {\n          return Promise.reject(new Error(\"nope\"));\n        };\n\n        engine.on(\"connection_error\", (err) => {\n          expect(err.req).to.be.ok();\n          expect(err.code).to.be(3);\n          expect(err.message).to.be(\"Bad request\");\n          expect(err.context.name).to.be(\"ID_GENERATION_ERROR\");\n          partialDone();\n        });\n\n        const socket = new ClientSocket(`ws://localhost:${port}`, {\n          transports: [\"websocket\"],\n        });\n        socket.on(\"error\", () => {\n          partialDone();\n        });\n      });\n    });\n\n    it(\"should exchange handshake data\", (done) => {\n      listen({ allowUpgrades: false }, (port) => {\n        const socket = new ClientSocket(`ws://localhost:${port}`);\n        socket.on(\"handshake\", (obj) => {\n          expect(obj.sid).to.be.a(\"string\");\n          expect(obj.pingTimeout).to.be.a(\"number\");\n          expect(obj.upgrades).to.be.an(\"array\");\n          expect(obj.maxPayload).to.eql(1000000);\n          done();\n        });\n      });\n    });\n\n    it(\"should allow custom ping timeouts\", (done) => {\n      listen({ allowUpgrades: false, pingTimeout: 123 }, (port) => {\n        const socket = new ClientSocket(`http://localhost:${port}`);\n        socket.on(\"handshake\", (obj) => {\n          expect(obj.pingTimeout).to.be(123);\n          done();\n        });\n      });\n    });\n\n    it(\"should trigger a connection event with a Socket\", (done) => {\n      const engine = listen({ allowUpgrades: false }, (port) => {\n        new ClientSocket(`ws://localhost:${port}`);\n        engine.on(\"connection\", (socket) => {\n          expect(socket).to.be.an(Socket);\n          done();\n        });\n      });\n    });\n\n    it(\"should open with polling by default\", (done) => {\n      const engine = listen({ allowUpgrades: false }, (port) => {\n        new ClientSocket(`ws://localhost:${port}`);\n        engine.on(\"connection\", (socket) => {\n          expect(socket.transport.name).to.be(\"polling\");\n          done();\n        });\n      });\n    });\n\n    it(\"should be able to open with ws directly\", (done) => {\n      const engine = listen({ transports: [\"websocket\"] }, (port) => {\n        new ClientSocket(`ws://localhost:${port}`, {\n          transports: [\"websocket\"],\n        });\n        engine.on(\"connection\", (socket) => {\n          expect(socket.transport.name).to.be(\"websocket\");\n          done();\n        });\n      });\n    });\n\n    it(\"should not suggest any upgrades for websocket\", (done) => {\n      listen({ transports: [\"websocket\"] }, (port) => {\n        const socket = new ClientSocket(`ws://localhost:${port}`, {\n          transports: [\"websocket\"],\n        });\n        socket.on(\"handshake\", (obj) => {\n          expect(obj.upgrades).to.have.length(0);\n          done();\n        });\n      });\n    });\n\n    it(\"should not suggest upgrades when none are availble\", (done) => {\n      listen({ transports: [\"polling\"] }, (port) => {\n        const socket = new ClientSocket(`ws://localhost:${port}`, {});\n        socket.on(\"handshake\", (obj) => {\n          expect(obj.upgrades).to.have.length(0);\n          done();\n        });\n      });\n    });\n\n    it(\"should only suggest available upgrades\", (done) => {\n      listen({ transports: [\"polling\"] }, (port) => {\n        const socket = new ClientSocket(`ws://localhost:${port}`, {});\n        socket.on(\"handshake\", (obj) => {\n          expect(obj.upgrades).to.have.length(0);\n          done();\n        });\n      });\n    });\n\n    it(\"should suggest all upgrades when no transports are disabled\", (done) => {\n      listen({}, (port) => {\n        const socket = new ClientSocket(`ws://localhost:${port}`, {});\n        socket.on(\"handshake\", (obj) => {\n          expect(obj.upgrades).to.have.length(1);\n          expect(obj.upgrades).to.have.contain(\"websocket\");\n          done();\n        });\n      });\n    });\n\n    it(\"default to polling when proxy doesn't support websocket\", (done) => {\n      const partialDone = createPartialDone(done, 2);\n\n      engine = listen({ allowUpgrades: false }, (port) => {\n        engine.on(\"connection\", (socket) => {\n          socket.on(\"message\", (msg) => {\n            if (\"echo\" === msg) socket.send(msg);\n          });\n        });\n\n        engine.on(\"connection_error\", (err) => {\n          expect(err.req).to.be.ok();\n          expect(err.code).to.be(3);\n          expect(err.message).to.be(\"Bad request\");\n          expect(err.context.name).to.be(\"TRANSPORT_MISMATCH\");\n          expect(err.context.transport).to.be(\"websocket\");\n          expect(err.context.previousTransport).to.be(\"polling\");\n          partialDone();\n        });\n\n        var socket = new ClientSocket(`ws://localhost:${port}`);\n        socket.on(\"open\", () => {\n          request\n            .get(`http://localhost:${port}/engine.io/`)\n            .set({ connection: \"close\" })\n            .query({ transport: \"websocket\", sid: socket.id })\n            .end((err, res) => {\n              expect(err).to.be.an(Error);\n              expect(res.status).to.be(400);\n              expect(res.body.code).to.be(3);\n              socket.send(\"echo\");\n              socket.on(\"message\", (msg) => {\n                expect(msg).to.be(\"echo\");\n                partialDone();\n              });\n            });\n        });\n      });\n    });\n\n    it(\"should allow arbitrary data through query string\", (done) => {\n      const engine = listen({ allowUpgrades: false }, (port) => {\n        new ClientSocket(`ws://localhost:${port}`, { query: { a: \"b\" } });\n        engine.on(\"connection\", (conn) => {\n          expect(conn.request._query).to.have.keys(\"transport\", \"a\");\n          expect(conn.request._query.a).to.be(\"b\");\n          done();\n        });\n      });\n    });\n\n    it(\"should allow data through query string in uri\", (done) => {\n      const engine = listen({ allowUpgrades: false }, (port) => {\n        new ClientSocket(`ws://localhost:${port}?a=b&c=d`);\n        engine.on(\"connection\", (conn) => {\n          expect(conn.request._query.EIO).to.be.a(\"string\");\n          expect(conn.request._query.a).to.be(\"b\");\n          expect(conn.request._query.c).to.be(\"d\");\n          done();\n        });\n      });\n    });\n\n    it(\"should disallow bad requests (handshake error)\", function (done) {\n      const partialDone = createPartialDone(done, 2);\n\n      engine = listen(\n        {\n          cors: { credentials: true, origin: \"http://engine.io\" },\n        },\n        (port) => {\n          engine.on(\"connection_error\", (err) => {\n            expect(err.req).to.be.ok();\n            expect(err.code).to.be(3);\n            expect(err.message).to.be(\"Bad request\");\n            expect(err.context.name).to.be(\"TRANSPORT_HANDSHAKE_ERROR\");\n            partialDone();\n          });\n\n          request\n            .get(`http://localhost:${port}/engine.io/`)\n            .set(\"Origin\", \"http://engine.io\")\n            .query({ transport: \"websocket\" })\n            .end((err, res) => {\n              expect(err).to.be.an(Error);\n              expect(res.status).to.be(400);\n              expect(res.body.code).to.be(3);\n              expect(res.body.message).to.be(\"Bad request\");\n              expect(res.header[\"access-control-allow-credentials\"]).to.be(\n                \"true\"\n              );\n              expect(res.header[\"access-control-allow-origin\"]).to.be(\n                \"http://engine.io\"\n              );\n              partialDone();\n            });\n        }\n      );\n    });\n\n    it(\"should disallow invalid origin header\", function (done) {\n      if (process.env.EIO_WS_ENGINE === \"uws\") {\n        return this.skip();\n      }\n      const partialDone = createPartialDone(done, 2);\n\n      engine = listen((port) => {\n        // we can't send an invalid header through request.get\n        // so add an invalid char here\n        engine.prepare = function (req) {\n          Server.prototype.prepare.call(engine, req);\n          req.headers.origin += \"\\n\";\n        };\n\n        engine.on(\"connection_error\", (err) => {\n          expect(err.req).to.be.ok();\n          expect(err.code).to.be(3);\n          expect(err.message).to.be(\"Bad request\");\n          expect(err.context.name).to.be(\"INVALID_ORIGIN\");\n          expect(err.context.origin).to.be(\"http://engine.io/\\n\");\n          partialDone();\n        });\n\n        request\n          .get(`http://localhost:${port}/engine.io/`)\n          .set(\"Origin\", \"http://engine.io/\")\n          .query({ transport: \"websocket\" })\n          .end((err, res) => {\n            expect(err).to.be.an(Error);\n            expect(res.status).to.be(400);\n            expect(res.body.code).to.be(3);\n            expect(res.body.message).to.be(\"Bad request\");\n            partialDone();\n          });\n      });\n    });\n\n    it(\"should disallow invalid handshake method\", (done) => {\n      const partialDone = createPartialDone(done, 2);\n\n      engine = listen((port) => {\n        engine.on(\"connection_error\", (err) => {\n          expect(err.req).to.be.ok();\n          expect(err.code).to.be(2);\n          expect(err.message).to.be(\"Bad handshake method\");\n          expect(err.context.method).to.be(\"OPTIONS\");\n          partialDone();\n        });\n\n        request\n          .options(`http://localhost:${port}/engine.io/`)\n          .query({ transport: \"polling\" })\n          .end((err, res) => {\n            expect(err).to.be.an(Error);\n            expect(res.status).to.be(400);\n            expect(res.body.code).to.be(2);\n            expect(res.body.message).to.be(\"Bad handshake method\");\n            partialDone();\n          });\n      });\n    });\n\n    it(\"should disallow unsupported protocol versions\", (done) => {\n      const partialDone = createPartialDone(done, 2);\n\n      const httpServer = http.createServer();\n      const engine = new Server({ allowEIO3: false });\n      engine.attach(httpServer);\n      httpServer.listen(() => {\n        const port = httpServer.address().port;\n\n        engine.on(\"connection_error\", (err) => {\n          expect(err.req).to.be.ok();\n          expect(err.code).to.be(5);\n          expect(err.message).to.be(\"Unsupported protocol version\");\n          expect(err.context.protocol).to.be(3);\n\n          httpServer.close();\n          partialDone();\n        });\n\n        request\n          .get(`http://localhost:${port}/engine.io/`)\n          .query({ transport: \"polling\", EIO: 3 })\n          .end((err, res) => {\n            expect(err).to.be.an(Error);\n            expect(res.status).to.be(400);\n            expect(res.body.code).to.be(5);\n            expect(res.body.message).to.be(\"Unsupported protocol version\");\n            partialDone();\n          });\n      });\n    });\n\n    it(\"should send a packet along with the handshake\", (done) => {\n      listen({ initialPacket: \"faster!\" }, (port) => {\n        const socket = new ClientSocket(`ws://localhost:${port}`);\n        socket.on(\"open\", () => {\n          socket.on(\"message\", (msg) => {\n            expect(msg).to.be(\"faster!\");\n            done();\n          });\n        });\n      });\n    });\n\n    it(\"should support requests without trailing slash\", (done) => {\n      listen({ addTrailingSlash: false }, (port) => {\n        const partialDone = createPartialDone(done, 2);\n\n        request\n          .get(`http://localhost:${port}/engine.io`)\n          .query({ transport: \"polling\" })\n          .end((err, res) => {\n            expect(err).to.be(null);\n            expect(res.status).to.be(200);\n            partialDone();\n          });\n\n        request\n          .get(`http://localhost:${port}/engine.io/foo/bar/`)\n          .query({ transport: \"polling\" })\n          .end((err, res) => {\n            if (process.env.EIO_WS_ENGINE === \"uws\") {\n              expect(err).to.not.be(null);\n              expect(err.message).to.be(\"socket hang up\");\n            } else {\n              expect(err).to.be(null);\n              // this should not work, but it is kept for backward-compatibility\n              expect(res.status).to.be(200);\n            }\n            partialDone();\n          });\n      });\n    });\n  });\n\n  describe(\"close\", () => {\n    it(\"should be able to access non-empty writeBuffer at closing (server)\", (done) => {\n      const opts = { allowUpgrades: false };\n      const engine = listen(opts, (port) => {\n        new ClientSocket(`http://localhost:${port}`);\n        engine.on(\"connection\", (conn) => {\n          conn.on(\"close\", (reason) => {\n            expect(conn.writeBuffer.length).to.be(1);\n            setTimeout(() => {\n              expect(conn.writeBuffer.length).to.be(0); // writeBuffer has been cleared\n            }, 10);\n            done();\n          });\n          conn.writeBuffer.push({ type: \"message\", data: \"foo\" });\n          conn.onError(\"\");\n        });\n      });\n    });\n\n    it(\"should be able to access non-empty writeBuffer at closing (client)\", (done) => {\n      const opts = { allowUpgrades: false };\n      listen(opts, (port) => {\n        const socket = new ClientSocket(`http://localhost:${port}`);\n        socket.on(\"open\", () => {\n          socket.on(\"close\", (reason) => {\n            expect(socket.writeBuffer.length).to.be(1);\n            setTimeout(() => {\n              expect(socket.writeBuffer.length).to.be(0);\n            }, 10);\n            done();\n          });\n          socket.writeBuffer.push({ type: \"message\", data: \"foo\" });\n          socket.onError(\"\");\n        });\n      });\n    });\n\n    it(\"should trigger on server if the client does not pong\", (done) => {\n      const opts = { allowUpgrades: false, pingInterval: 5, pingTimeout: 5 };\n      const engine = listen(opts, (port) => {\n        const socket = new ClientSocket(`http://localhost:${port}`);\n        socket.sendPacket = () => {};\n        engine.on(\"connection\", (conn) => {\n          conn.on(\"close\", (reason) => {\n            expect(reason).to.be(\"ping timeout\");\n            done();\n          });\n        });\n      });\n    });\n\n    it(\"should trigger on server even when there is no outstanding polling request (GH-198)\", (done) => {\n      const opts = {\n        allowUpgrades: false,\n        pingInterval: 500,\n        pingTimeout: 500,\n      };\n      const engine = listen(opts, (port) => {\n        const socket = new ClientSocket(`http://localhost:${port}`);\n        engine.on(\"connection\", (conn) => {\n          conn.on(\"close\", (reason) => {\n            expect(reason).to.be(\"ping timeout\");\n            done();\n          });\n          // client abruptly disconnects, no polling request on this tick since we've just connected\n          socket.sendPacket = () => {};\n          socket.transport.removeListener(\"packet\");\n          socket.close();\n          // then server app tries to close the socket, since client disappeared\n          conn.close();\n        });\n      });\n    });\n\n    it(\"should trigger on client if server does not meet ping timeout\", (done) => {\n      const opts = { allowUpgrades: false, pingInterval: 50, pingTimeout: 30 };\n      listen(opts, (port) => {\n        const socket = new ClientSocket(`ws://localhost:${port}`);\n        socket.on(\"open\", () => {\n          // override onPacket and Transport#onClose to simulate an inactive server after handshake\n          socket.transport.removeListener(\"packet\");\n          socket.transport.removeListener(\"close\");\n          socket.on(\"close\", (reason, err) => {\n            expect(reason).to.be(\"ping timeout\");\n            done();\n          });\n        });\n      });\n    });\n\n    it(\"should trigger on both ends upon ping timeout\", (done) => {\n      const opts = { allowUpgrades: false, pingTimeout: 50, pingInterval: 50 };\n      const engine = listen(opts, (port) => {\n        const socket = new ClientSocket(`ws://localhost:${port}`);\n        let total = 2;\n\n        function onClose(reason, err) {\n          expect(reason).to.be(\"ping timeout\");\n          --total || done();\n        }\n\n        engine.on(\"connection\", (conn) => {\n          conn.on(\"close\", onClose);\n        });\n\n        socket.on(\"open\", () => {\n          // override onPacket and Transport#onClose to simulate an inactive server after handshake\n          socket.sendPacket = () => {};\n          socket.transport.removeListener(\"packet\");\n          socket.transport.removeListener(\"close\");\n          socket.on(\"close\", onClose);\n        });\n      });\n    });\n\n    it(\"should trigger when server closes a client\", (done) => {\n      const engine = listen({ allowUpgrades: false }, (port) => {\n        const socket = new ClientSocket(`ws://localhost:${port}`);\n        let total = 2;\n\n        engine.on(\"connection\", (conn) => {\n          conn.on(\"close\", (reason) => {\n            expect(reason).to.be(\"forced close\");\n            --total || done();\n          });\n          setTimeout(() => {\n            conn.close();\n          }, 10);\n        });\n\n        socket.on(\"open\", () => {\n          socket.on(\"close\", (reason) => {\n            expect(reason).to.be(\"transport close\");\n            --total || done();\n          });\n        });\n      });\n    });\n\n    it(\"should trigger when server closes a client (ws)\", (done) => {\n      const opts = { allowUpgrades: false, transports: [\"websocket\"] };\n      const engine = listen(opts, (port) => {\n        const socket = new ClientSocket(`ws://localhost:${port}`, {\n          transports: [\"websocket\"],\n        });\n        let total = 2;\n\n        engine.on(\"connection\", (conn) => {\n          conn.on(\"close\", (reason) => {\n            expect(reason).to.be(\"forced close\");\n            --total || done();\n          });\n          setTimeout(() => {\n            conn.close();\n          }, 10);\n        });\n\n        socket.on(\"open\", () => {\n          socket.on(\"close\", (reason) => {\n            expect(reason).to.be(\"transport close\");\n            --total || done();\n          });\n        });\n      });\n    });\n\n    it(\"should allow client reconnect after restarting (ws)\", function (done) {\n      if (process.env.EIO_WS_ENGINE === \"uws\") {\n        return this.skip();\n      }\n      const opts = { transports: [\"websocket\"] };\n      const engine = listen(opts, (port) => {\n        engine.httpServer.close();\n        engine.httpServer.listen(port);\n\n        const socket = new ClientSocket(`ws://localhost:${port}`, {\n          transports: [\"websocket\"],\n        });\n\n        engine.once(\"connection\", (conn) => {\n          setTimeout(() => {\n            conn.close();\n          }, 10);\n        });\n\n        socket.once(\"close\", (reason) => {\n          expect(reason).to.be(\"transport close\");\n          done();\n        });\n      });\n    });\n\n    it(\"should trigger when client closes\", (done) => {\n      const engine = listen({ allowUpgrades: false }, (port) => {\n        const socket = new ClientSocket(`ws://localhost:${port}`);\n        let total = 2;\n\n        engine.on(\"connection\", (conn) => {\n          conn.on(\"close\", (reason) => {\n            expect(reason).to.be(\"transport close\");\n            --total || done();\n          });\n        });\n\n        socket.on(\"open\", () => {\n          socket.on(\"close\", (reason) => {\n            expect(reason).to.be(\"forced close\");\n            --total || done();\n          });\n\n          setTimeout(() => {\n            socket.close();\n          }, 10);\n        });\n      });\n    });\n\n    it(\"should trigger when client closes (ws)\", (done) => {\n      const opts = { allowUpgrades: false, transports: [\"websocket\"] };\n      const engine = listen(opts, (port) => {\n        const socket = new ClientSocket(`ws://localhost:${port}`, {\n          transports: [\"websocket\"],\n        });\n        let total = 2;\n\n        engine.on(\"connection\", (conn) => {\n          conn.on(\"close\", (reason) => {\n            expect(reason).to.be(\"transport close\");\n            --total || done();\n          });\n        });\n\n        socket.on(\"open\", () => {\n          socket.on(\"close\", (reason) => {\n            expect(reason).to.be(\"forced close\");\n            --total || done();\n          });\n\n          setTimeout(() => {\n            socket.close();\n          }, 10);\n        });\n      });\n    });\n\n    it(\"should trigger when calling socket.close() in payload\", (done) => {\n      const engine = listen({ allowUpgrades: false }, (port) => {\n        const socket = new ClientSocket(`ws://localhost:${port}`);\n\n        engine.on(\"connection\", (conn) => {\n          conn.send(null, () => {\n            socket.close();\n          });\n          conn.send(\"this should not be handled\");\n\n          conn.on(\"close\", (reason) => {\n            expect(reason).to.be(\"transport close\");\n            done();\n          });\n        });\n\n        socket.on(\"open\", () => {\n          socket.on(\"message\", (msg) => {\n            expect(msg).to.not.be(\"this should not be handled\");\n          });\n\n          socket.on(\"close\", (reason) => {\n            expect(reason).to.be(\"forced close\");\n          });\n        });\n      });\n    });\n\n    it(\"should abort upgrade if socket is closed (GH-35)\", (done) => {\n      listen({ allowUpgrades: true }, (port) => {\n        const socket = new ClientSocket(`ws://localhost:${port}`);\n        socket.on(\"open\", () => {\n          socket.close();\n          // we wait until complete to see if we get an uncaught EPIPE\n          setTimeout(() => {\n            done();\n          }, 100);\n        });\n      });\n    });\n\n    it(\"should abort connection when upgrade fails\", (done) => {\n      listen({ allowUpgrades: true }, (port) => {\n        const req = http.request(\n          {\n            port,\n            path: \"/engine.io/\",\n            headers: {\n              connection: \"Upgrade\",\n              upgrade: \"websocket\",\n            },\n          },\n          (res) => {\n            expect(res.statusCode).to.eql(400);\n            res.resume();\n            res.on(\"end\", done);\n          }\n        );\n        req.end();\n      });\n    });\n\n    it(\n      \"should trigger if a poll request is ongoing and the underlying \" +\n        \"socket closes, as in a browser tab close\",\n      ($done) => {\n        const engine = listen({ allowUpgrades: false }, (port) => {\n          // hack to access the sockets created by node-xmlhttprequest\n          // see: https://github.com/driverdan/node-XMLHttpRequest/issues/44\n          const request = require(\"http\").request;\n          const sockets = [];\n          http.request = function (opts) {\n            const req = request.apply(null, arguments);\n            req.on(\"socket\", (socket) => {\n              sockets.push(socket);\n            });\n            return req;\n          };\n\n          function done() {\n            http.request = request;\n            $done();\n          }\n\n          var socket = new ClientSocket(`ws://localhost:${port}`);\n          let serverSocket;\n\n          engine.on(\"connection\", (s) => {\n            serverSocket = s;\n          });\n\n          socket.transport.on(\"poll\", () => {\n            // we set a timer to wait for the request to actually reach\n            setTimeout(() => {\n              // at this time server's `connection` should have been fired\n              expect(serverSocket).to.be.an(\"object\");\n\n              // OPENED readyState is expected - we are actually polling\n              expect(socket.transport.pollXhr.xhr.readyState).to.be(1);\n\n              // 2 requests sent to the server over an unique port means\n              // we should have been assigned 2 sockets\n              expect(sockets.length).to.be(2);\n\n              // expect the socket to be open at this point\n              expect(serverSocket.readyState).to.be(\"open\");\n\n              // kill the underlying connection\n              sockets[1].end();\n              serverSocket.on(\"close\", (reason, err) => {\n                expect(reason).to.be(\"transport error\");\n                expect(err.message).to.be(\"poll connection closed prematurely\");\n                done();\n              });\n            }, 50);\n          });\n        });\n      }\n    );\n\n    it(\"should not trigger with connection: close header\", ($done) => {\n      const engine = listen({ allowUpgrades: false }, (port) => {\n        // intercept requests to add connection: close\n        const request = http.request;\n        http.request = function () {\n          const opts = arguments[0];\n          opts.headers = opts.headers || {};\n          opts.headers.Connection = \"close\";\n          return request.apply(this, arguments);\n        };\n\n        function done() {\n          http.request = request;\n          $done();\n        }\n\n        engine.on(\"connection\", (socket) => {\n          socket.on(\"message\", (msg) => {\n            expect(msg).to.equal(\"test\");\n            socket.send(\"woot\");\n          });\n        });\n\n        var socket = new ClientSocket(`ws://localhost:${port}`);\n        socket.on(\"open\", () => {\n          socket.send(\"test\");\n        });\n        socket.on(\"message\", (msg) => {\n          expect(msg).to.be(\"woot\");\n          done();\n        });\n      });\n    });\n\n    it(\n      \"should not trigger early with connection `ping timeout`\" +\n        \"after post handshake timeout\",\n      (done) => {\n        // first timeout should trigger after `pingInterval + pingTimeout`,\n        // not just `pingTimeout`.\n        const opts = {\n          allowUpgrades: false,\n          pingInterval: 300,\n          pingTimeout: 100,\n        };\n        listen(opts, (port) => {\n          const socket = new ClientSocket(`ws://localhost:${port}`);\n          let clientCloseReason = null;\n\n          socket.on(\"handshake\", () => {\n            socket.transport.removeListener(\"packet\");\n          });\n          socket.on(\"open\", () => {\n            socket.on(\"close\", (reason) => {\n              clientCloseReason = reason;\n            });\n          });\n\n          setTimeout(() => {\n            expect(clientCloseReason).to.be(null);\n            done();\n          }, 200);\n        });\n      }\n    );\n\n    it(\n      \"should not trigger early with connection `ping timeout` \" +\n        \"after post ping timeout\",\n      (done) => {\n        // ping timeout should trigger after `pingInterval + pingTimeout`,\n        // not just `pingTimeout`.\n        const opts = {\n          allowUpgrades: false,\n          pingInterval: 80,\n          pingTimeout: 50,\n        };\n        const engine = listen(opts, (port) => {\n          const socket = new ClientSocket(`ws://localhost:${port}`);\n          let clientCloseReason = null;\n\n          engine.on(\"connection\", (conn) => {\n            conn.on(\"heartbeat\", () => {\n              conn.onPacket = () => {};\n            });\n          });\n\n          socket.on(\"open\", () => {\n            socket.on(\"close\", (reason) => {\n              clientCloseReason = reason;\n            });\n          });\n\n          setTimeout(() => {\n            expect(clientCloseReason).to.be(null);\n            done();\n          }, 100);\n        });\n      }\n    );\n\n    it(\n      \"should trigger early with connection `transport close` \" +\n        \"after missing pong\",\n      (done) => {\n        // ping timeout should trigger after `pingInterval + pingTimeout`,\n        // not just `pingTimeout`.\n        const opts = {\n          allowUpgrades: false,\n          pingInterval: 80,\n          pingTimeout: 50,\n        };\n        const engine = listen(opts, (port) => {\n          const socket = new ClientSocket(`ws://localhost:${port}`);\n          let clientCloseReason = null;\n\n          socket.on(\"open\", () => {\n            socket.on(\"close\", (reason) => {\n              clientCloseReason = reason;\n            });\n          });\n\n          engine.on(\"connection\", (conn) => {\n            conn.on(\"heartbeat\", () => {\n              setTimeout(() => {\n                conn.close();\n              }, 20);\n              setTimeout(() => {\n                expect(clientCloseReason).to.be(\"transport close\");\n                done();\n              }, 100);\n            });\n          });\n        });\n      }\n    );\n\n    if (process.env.EIO_CLIENT === \"3\") {\n      it(\n        \"should trigger with connection `ping timeout` \" +\n          \"after `pingInterval + pingTimeout`\",\n        (done) => {\n          const opts = {\n            allowUpgrades: false,\n            pingInterval: 300,\n            pingTimeout: 100,\n          };\n          const engine = listen(opts, (port) => {\n            const socket = new ClientSocket(`ws://localhost:${port}`);\n            let clientCloseReason = null;\n\n            socket.on(\"open\", () => {\n              socket.on(\"close\", (reason) => {\n                clientCloseReason = reason;\n              });\n            });\n\n            engine.on(\"connection\", (conn) => {\n              conn.once(\"heartbeat\", () => {\n                setTimeout(() => {\n                  socket.transport.removeListener(\"packet\");\n                  expect(clientCloseReason).to.be(null);\n                }, 150);\n                setTimeout(() => {\n                  expect(clientCloseReason).to.be(null);\n                }, 350);\n                setTimeout(() => {\n                  expect(clientCloseReason).to.be(\"ping timeout\");\n                  done();\n                }, 500);\n              });\n            });\n          });\n        }\n      );\n    } else {\n      it(\n        \"should trigger with connection `ping timeout` \" +\n          \"after `pingInterval + pingTimeout`\",\n        (done) => {\n          const opts = {\n            allowUpgrades: false,\n            pingInterval: 300,\n            pingTimeout: 100,\n          };\n          const engine = listen(opts, (port) => {\n            const socket = new ClientSocket(`ws://localhost:${port}`);\n            let clientCloseReason = null;\n\n            socket.on(\"open\", () => {\n              socket.on(\"close\", (reason) => {\n                clientCloseReason = reason;\n              });\n            });\n\n            engine.on(\"connection\", (conn) => {\n              conn.once(\"heartbeat\", () => {\n                socket.transport.removeListener(\"packet\");\n                setTimeout(() => {\n                  expect(clientCloseReason).to.be(null);\n                }, 150);\n                setTimeout(() => {\n                  expect(clientCloseReason).to.be(null);\n                }, 350);\n                setTimeout(() => {\n                  expect(clientCloseReason).to.be(\"ping timeout\");\n                  done();\n                }, 500);\n              });\n            });\n          });\n        }\n      );\n    }\n\n    it(\n      \"should abort the polling data request if it is \" + \"in progress\",\n      function (done) {\n        if (process.env.EIO_WS_ENGINE === \"uws\") {\n          return this.skip();\n        }\n        const engine = listen({ transports: [\"polling\"] }, (port) => {\n          const socket = new ClientSocket(`http://localhost:${port}`);\n\n          engine.on(\"connection\", (conn) => {\n            const onDataRequest = conn.transport.onDataRequest;\n            conn.transport.onDataRequest = (req, res) => {\n              engine.httpServer.close(done);\n              onDataRequest.call(conn.transport, req, res);\n              req.removeAllListeners();\n              conn.close();\n            };\n          });\n\n          socket.on(\"open\", () => {\n            socket.send(\"test\");\n          });\n        });\n      }\n    );\n\n    // tests https://github.com/LearnBoost/engine.io-client/issues/207\n    // websocket test, transport error\n    it(\"should trigger transport close before open for ws\", (done) => {\n      const opts = { transports: [\"websocket\"] };\n      listen(opts, (port) => {\n        const url = `ws://0.0.0.0:${port}`;\n        const socket = new ClientSocket(url);\n        socket.on(\"open\", () => {\n          done(new Error(\"Test invalidation\"));\n        });\n        socket.on(\"close\", (reason) => {\n          expect(reason).to.be(\"transport error\");\n          done();\n        });\n      });\n    });\n\n    // tests https://github.com/LearnBoost/engine.io-client/issues/207\n    // polling test, transport error\n    it(\"should trigger transport close before open for xhr\", (done) => {\n      const opts = { transports: [\"polling\"] };\n      listen(opts, (port) => {\n        const socket = new ClientSocket(`http://invalidserver:${port}`);\n        socket.on(\"open\", () => {\n          done(new Error(\"Test invalidation\"));\n        });\n        socket.on(\"close\", (reason) => {\n          expect(reason).to.be(\"transport error\");\n          done();\n        });\n      });\n    });\n\n    // tests https://github.com/LearnBoost/engine.io-client/issues/207\n    // websocket test, force close\n    it(\"should trigger force close before open for ws\", (done) => {\n      const opts = { transports: [\"websocket\"] };\n      listen(opts, (port) => {\n        const socket = new ClientSocket(`ws://localhost:${port}`);\n        socket.on(\"open\", () => {\n          done(new Error(\"Test invalidation\"));\n        });\n        socket.on(\"close\", (reason) => {\n          expect(reason).to.be(\"forced close\");\n          done();\n        });\n        socket.close();\n      });\n    });\n\n    // tests https://github.com/LearnBoost/engine.io-client/issues/207\n    // polling test, force close\n    it(\"should trigger force close before open for xhr\", (done) => {\n      const opts = { transports: [\"polling\"] };\n      listen(opts, (port) => {\n        const socket = new ClientSocket(`http://localhost:${port}`);\n        socket.on(\"open\", () => {\n          done(new Error(\"Test invalidation\"));\n        });\n        socket.on(\"close\", (reason) => {\n          expect(reason).to.be(\"forced close\");\n          done();\n        });\n        socket.close();\n      });\n    });\n\n    it(\"should close transport upon ping timeout (ws)\", (done) => {\n      const opts = {\n        allowUpgrades: false,\n        transports: [\"websocket\"],\n        pingInterval: 50,\n        pingTimeout: 30,\n      };\n      const engine = listen(opts, (port) => {\n        engine.on(\"connection\", (conn) => {\n          conn.transport.on(\"close\", done);\n        });\n        const socket = new ClientSocket(`ws://localhost:${port}`, {\n          transports: [\"websocket\"],\n        });\n        // override to simulate an inactive client\n        socket.sendPacket = socket.onHeartbeat = () => {};\n      });\n    });\n\n    it(\"should close transport upon ping timeout (polling)\", (done) => {\n      const opts = {\n        allowUpgrades: false,\n        transports: [\"polling\"],\n        pingInterval: 50,\n        pingTimeout: 30,\n      };\n      const engine = listen(opts, (port) => {\n        engine.on(\"connection\", (conn) => {\n          conn.transport.on(\"close\", done);\n        });\n        const socket = new ClientSocket(`ws://localhost:${port}`, {\n          transports: [\"polling\"],\n        });\n        // override to simulate an inactive client\n        socket.sendPacket = socket.onHeartbeat = () => {};\n      });\n    });\n\n    it(\"should close transport upon parse error (ws)\", (done) => {\n      const opts = { allowUpgrades: false, transports: [\"websocket\"] };\n      const engine = listen(opts, (port) => {\n        engine.on(\"connection\", (conn) => {\n          conn.transport.on(\"close\", done);\n        });\n        const socket = new ClientSocket(`ws://localhost:${port}`, {\n          transports: [\"websocket\"],\n        });\n        socket.on(\"open\", () => {\n          socket.transport.ws.send(\"invalid\");\n        });\n      });\n    });\n\n    it(\"should close transport upon parse error (polling)\", (done) => {\n      const opts = { allowUpgrades: false, transports: [\"polling\"] };\n      const engine = listen(opts, (port) => {\n        engine.on(\"connection\", (conn) => {\n          conn.transport.closeTimeout = 100;\n          conn.transport.on(\"close\", done);\n        });\n        const socket = new ClientSocket(`ws://localhost:${port}`, {\n          transports: [\"polling\"],\n        });\n        socket.on(\"open\", () => {\n          socket.transport.doWrite(\"invalid\", () => {});\n        });\n      });\n    });\n\n    it(\"should close upgrading transport upon socket close\", (done) => {\n      const engine = listen((port) => {\n        engine.on(\"connection\", (conn) => {\n          conn.on(\"upgrading\", (transport) => {\n            transport.on(\"close\", done);\n            conn.close();\n          });\n        });\n        new ClientSocket(`ws://localhost:${port}`);\n      });\n    });\n\n    it(\"should close upgrading transport upon upgrade timeout\", (done) => {\n      const opts = { upgradeTimeout: 100 };\n      const engine = listen(opts, (port) => {\n        engine.on(\"connection\", (conn) => {\n          conn.on(\"upgrading\", (transport) => {\n            transport.on(\"close\", done);\n          });\n        });\n        const socket = new ClientSocket(`ws://localhost:${port}`);\n        socket.on(\"upgrading\", (transport) => {\n          // override not to complete upgrading\n          transport.send = () => {};\n        });\n      });\n    });\n\n    it(\"should not timeout after an upgrade\", (done) => {\n      const opts = { pingInterval: 200, pingTimeout: 20 };\n      const engine = listen(opts, (port) => {\n        const socket = new ClientSocket(`ws://localhost:${port}`);\n        socket.on(\"open\", () => {\n          setTimeout(() => {\n            socket.removeListener(\"close\");\n            engine.close();\n            socket.close();\n            done();\n          }, 500);\n        });\n        socket.on(\"close\", () => {\n          done(new Error(\"should not happen\"));\n        });\n      });\n    });\n\n    it(\"should not crash when messing with Object prototype\", (done) => {\n      Object.prototype.foo = \"bar\"; // eslint-disable-line no-extend-native\n      const engine = listen({ allowUpgrades: true }, (port) => {\n        const socket = new ClientSocket(`ws://localhost:${port}`);\n        socket.on(\"open\", () => {\n          engine.close();\n          setTimeout(() => {\n            done();\n          }, 100);\n        });\n      });\n    });\n\n    describe(\"graceful close\", () => {\n      before(function () {\n        if (process.env.EIO_WS_ENGINE === \"uws\") {\n          this.skip();\n        }\n      });\n\n      function fixture(filename) {\n        return (\n          process.execPath + \" \" + path.join(__dirname, \"fixtures\", filename)\n        );\n      }\n\n      it(\"should stop socket and timers\", (done) => {\n        exec(fixture(\"server-close.js\"), done);\n      });\n\n      it(\"should stop upgraded socket and timers\", (done) => {\n        exec(fixture(\"server-close-upgraded.js\"), done);\n      });\n\n      it(\"should stop upgrading socket and timers\", (done) => {\n        exec(fixture(\"server-close-upgrading.js\"), done);\n      });\n    });\n  });\n\n  describe(\"messages\", function () {\n    this.timeout(5000);\n\n    it(\"should arrive from server to client\", (done) => {\n      const engine = listen({ allowUpgrades: false }, (port) => {\n        const socket = new ClientSocket(`ws://localhost:${port}`);\n        engine.on(\"connection\", (conn) => {\n          conn.send(\"a\");\n        });\n        socket.on(\"open\", () => {\n          socket.on(\"message\", (msg) => {\n            expect(msg).to.be(\"a\");\n            done();\n          });\n        });\n      });\n    });\n\n    it(\"should arrive from server to client (multiple)\", (done) => {\n      const engine = listen({ allowUpgrades: false }, (port) => {\n        const socket = new ClientSocket(`ws://localhost:${port}`);\n        const expected = [\"a\", \"b\", \"c\"];\n        let i = 0;\n\n        engine.on(\"connection\", (conn) => {\n          conn.send(\"a\");\n          // we use set timeouts to ensure the messages are delivered as part\n          // of different.\n          setTimeout(() => {\n            conn.send(\"b\");\n\n            setTimeout(() => {\n              // here we make sure we buffer both the close packet and\n              // a regular packet\n              conn.send(\"c\");\n              conn.close();\n            }, 50);\n          }, 50);\n\n          conn.on(\"close\", () => {\n            // since close fires right after the buffer is drained\n            setTimeout(() => {\n              expect(i).to.be(3);\n              done();\n            }, 50);\n          });\n        });\n        socket.on(\"open\", () => {\n          socket.on(\"message\", (msg) => {\n            expect(msg).to.be(expected[i++]);\n          });\n        });\n      });\n    });\n\n    it(\"should not be receiving data when getting a message longer than maxHttpBufferSize when polling\", (done) => {\n      const opts = {\n        allowUpgrades: false,\n        transports: [\"polling\"],\n        maxHttpBufferSize: 5,\n      };\n      const engine = listen(opts, (port) => {\n        const socket = new ClientSocket(`ws://localhost:${port}`);\n        engine.on(\"connection\", (conn) => {\n          conn.on(\"message\", (msg) => {\n            done(\n              new Error(\"Test invalidation (message is longer than allowed)\")\n            );\n          });\n        });\n        socket.on(\"open\", () => {\n          socket.send(\"aasdasdakjhasdkjhasdkjhasdkjhasdkjhasdkjhasdkjha\");\n        });\n        socket.on(\"close\", () => {\n          done();\n        });\n      });\n    });\n\n    it(\"should not be receiving data when getting a message longer than maxHttpBufferSize (websocket)\", (done) => {\n      const opts = { maxHttpBufferSize: 5 };\n      const engine = listen(opts, (port) => {\n        const socket = new ClientSocket(`ws://localhost:${port}`, {\n          transports: [\"websocket\"],\n        });\n        engine.on(\"connection\", (conn) => {\n          conn.on(\"message\", (msg) => {\n            done(\n              new Error(\"Test invalidation (message is longer than allowed)\")\n            );\n          });\n        });\n        socket.on(\"open\", () => {\n          socket.send(\"aasdasdakjhasdkjhasdkjhasdkjhasdkjhasdkjhasdkjha\");\n        });\n        socket.on(\"close\", () => {\n          done();\n        });\n      });\n    });\n\n    it(\"should receive data when getting a message shorter than maxHttpBufferSize when polling\", (done) => {\n      const opts = {\n        allowUpgrades: false,\n        transports: [\"polling\"],\n        maxHttpBufferSize: 5,\n      };\n      const engine = listen(opts, (port) => {\n        const socket = new ClientSocket(`ws://localhost:${port}`);\n        engine.on(\"connection\", (conn) => {\n          conn.on(\"message\", (msg) => {\n            expect(msg).to.be(\"a\");\n            done();\n          });\n        });\n        socket.on(\"open\", () => {\n          socket.send(\"a\");\n        });\n      });\n    });\n\n    it(\"should arrive from server to client (ws)\", (done) => {\n      const opts = { allowUpgrades: false, transports: [\"websocket\"] };\n      const engine = listen(opts, (port) => {\n        const socket = new ClientSocket(`ws://localhost:${port}`, {\n          transports: [\"websocket\"],\n        });\n        engine.on(\"connection\", (conn) => {\n          conn.send(\"a\");\n        });\n        socket.on(\"open\", () => {\n          socket.on(\"message\", (msg) => {\n            expect(msg).to.be(\"a\");\n            done();\n          });\n        });\n      });\n    });\n\n    it(\"should arrive from server to client (multiple, ws)\", (done) => {\n      const opts = { allowUpgrades: false, transports: [\"websocket\"] };\n      const engine = listen(opts, (port) => {\n        const socket = new ClientSocket(`ws://localhost:${port}`, {\n          transports: [\"websocket\"],\n        });\n        const expected = [\"a\", \"b\", \"c\"];\n        let i = 0;\n\n        engine.on(\"connection\", (conn) => {\n          conn.send(\"a\");\n          setTimeout(() => {\n            conn.send(\"b\");\n            setTimeout(() => {\n              conn.send(\"c\");\n              conn.close();\n            }, 50);\n          }, 50);\n          conn.on(\"close\", () => {\n            setTimeout(() => {\n              expect(i).to.be(3);\n              done();\n            }, 50);\n          });\n        });\n\n        socket.on(\"open\", () => {\n          socket.on(\"message\", (msg) => {\n            expect(msg).to.be(expected[i++]);\n          });\n        });\n      });\n    });\n\n    it(\"should arrive from server to client (multiple, no delay, ws)\", (done) => {\n      const opts = { allowUpgrades: false, transports: [\"websocket\"] };\n      const engine = listen(opts, (port) => {\n        const socket = new ClientSocket(`ws://localhost:${port}`, {\n          transports: [\"websocket\"],\n        });\n        const expected = [\"a\", \"b\", \"c\"];\n        let i = 0;\n\n        engine.on(\"connection\", (conn) => {\n          conn.on(\"close\", () => {\n            setTimeout(() => {\n              expect(i).to.be(3);\n              done();\n            }, 50);\n          });\n          conn.send(\"a\");\n          conn.send(\"b\");\n          conn.send(\"c\");\n          conn.close();\n        });\n\n        socket.on(\"open\", () => {\n          socket.on(\"message\", (msg) => {\n            expect(msg).to.be(expected[i++]);\n          });\n        });\n      });\n    });\n\n    it(\"should arrive when binary data is sent as Int8Array (ws)\", (done) => {\n      const binaryData = new Int8Array(5);\n      for (let i = 0; i < binaryData.length; i++) {\n        binaryData[i] = i;\n      }\n\n      const opts = { allowUpgrades: false, transports: [\"websocket\"] };\n      const engine = listen(opts, (port) => {\n        const socket = new ClientSocket(`ws://localhost:${port}`, {\n          transports: [\"websocket\"],\n        });\n\n        engine.on(\"connection\", (conn) => {\n          conn.send(binaryData);\n        });\n\n        socket.on(\"open\", () => {\n          socket.on(\"message\", (msg) => {\n            for (let i = 0; i < binaryData.length; i++) {\n              const num = msg.readInt8(i);\n              expect(num).to.be(i);\n            }\n            done();\n          });\n        });\n      });\n    });\n\n    it(\"should arrive when binary data is sent as Int32Array (ws)\", (done) => {\n      const binaryData = new Int32Array(5);\n      for (let i = 0; i < binaryData.length; i++) {\n        binaryData[i] = (i + 100) * 9823;\n      }\n\n      const opts = { allowUpgrades: false, transports: [\"websocket\"] };\n      const engine = listen(opts, (port) => {\n        const socket = new ClientSocket(`ws://localhost:${port}`, {\n          transports: [\"websocket\"],\n        });\n\n        engine.on(\"connection\", (conn) => {\n          conn.send(binaryData);\n        });\n\n        socket.on(\"open\", () => {\n          socket.on(\"message\", (msg) => {\n            let i = 0,\n              ii = 0;\n            for (; ii < binaryData.length; i += 4, ii++) {\n              const num = msg.readInt32LE(i);\n              expect(num).to.be((ii + 100) * 9823);\n            }\n            done();\n          });\n        });\n      });\n    });\n\n    it(\"should arrive when binary data is sent as Int32Array, given as ArrayBuffer(ws)\", (done) => {\n      const binaryData = new Int32Array(5);\n      for (let i = 0; i < binaryData.length; i++) {\n        binaryData[i] = (i + 100) * 9823;\n      }\n\n      const opts = { allowUpgrades: false, transports: [\"websocket\"] };\n      const engine = listen(opts, (port) => {\n        const socket = new ClientSocket(`ws://localhost:${port}`, {\n          transports: [\"websocket\"],\n        });\n\n        engine.on(\"connection\", (conn) => {\n          conn.send(binaryData.buffer);\n        });\n\n        socket.on(\"open\", () => {\n          socket.on(\"message\", (msg) => {\n            let i = 0,\n              ii = 0;\n            for (; ii < binaryData.length; i += 4, ii++) {\n              const num = msg.readInt32LE(i);\n              expect(num).to.be((ii + 100) * 9823);\n            }\n            done();\n          });\n        });\n      });\n    });\n\n    it(\"should arrive when binary data is sent as Buffer (ws)\", (done) => {\n      const binaryData = Buffer.allocUnsafe(5);\n      for (let i = 0; i < binaryData.length; i++) {\n        binaryData.writeInt8(i, i);\n      }\n\n      const opts = { allowUpgrades: false, transports: [\"websocket\"] };\n      const engine = listen(opts, (port) => {\n        const socket = new ClientSocket(`ws://localhost:${port}`, {\n          transports: [\"websocket\"],\n        });\n\n        engine.on(\"connection\", (conn) => {\n          conn.send(binaryData);\n        });\n\n        socket.on(\"open\", () => {\n          socket.on(\"message\", (msg) => {\n            for (let i = 0; i < binaryData.length; i++) {\n              const num = msg.readInt8(i);\n              expect(num).to.be(i);\n            }\n            done();\n          });\n        });\n      });\n    });\n\n    it(\"should arrive when binary data sent as Buffer (polling)\", (done) => {\n      const binaryData = Buffer.allocUnsafe(5);\n      for (let i = 0; i < binaryData.length; i++) {\n        binaryData.writeInt8(i, i);\n      }\n\n      const opts = { allowUpgrades: false, transports: [\"polling\"] };\n      const engine = listen(opts, (port) => {\n        const socket = new ClientSocket(`ws://localhost:${port}`, {\n          transports: [\"polling\"],\n        });\n\n        engine.on(\"connection\", (conn) => {\n          conn.send(binaryData);\n        });\n\n        socket.on(\"open\", () => {\n          socket.on(\"message\", (msg) => {\n            for (let i = 0; i < binaryData.length; i++) {\n              const num = msg.readInt8(i);\n              expect(num).to.be(i);\n            }\n\n            done();\n          });\n        });\n      });\n    });\n\n    it(\"should arrive as ArrayBuffer if requested when binary data sent as Buffer (ws)\", (done) => {\n      const binaryData = Buffer.allocUnsafe(5);\n      for (let i = 0; i < binaryData.length; i++) {\n        binaryData.writeInt8(i, i);\n      }\n\n      const opts = { allowUpgrades: false, transports: [\"websocket\"] };\n      const engine = listen(opts, (port) => {\n        const socket = new ClientSocket(`ws://localhost:${port}`, {\n          transports: [\"websocket\"],\n        });\n        socket.binaryType = \"arraybuffer\";\n\n        engine.on(\"connection\", (conn) => {\n          conn.send(binaryData);\n        });\n\n        socket.on(\"open\", () => {\n          socket.on(\"message\", (msg) => {\n            expect(msg instanceof ArrayBuffer).to.be(true);\n            const intArray = new Int8Array(msg);\n            for (let i = 0; i < binaryData.length; i++) {\n              expect(intArray[i]).to.be(i);\n            }\n\n            done();\n          });\n        });\n      });\n    });\n\n    it(\"should arrive when content is split in multiple chunks (polling)\", (done) => {\n      const engine = listen(\n        {\n          maxHttpBufferSize: 1e10,\n        },\n        (port) => {\n          const client = new ClientSocket(`ws://localhost:${port}`, {\n            transports: [\"polling\"],\n          });\n\n          engine.on(\"connection\", (socket) => {\n            socket.on(\"message\", (data) => {\n              client.close();\n              done();\n            });\n          });\n\n          client.on(\"open\", () => {\n            client.send(\"a\".repeat(1e6));\n          });\n        }\n      );\n    });\n\n    it(\"should arrive when content is sent with chunked transfer-encoding (polling)\", function (done) {\n      if (process.env.EIO_WS_ENGINE === \"uws\") {\n        // \u00b5WebSockets.js does not currently support chunked encoding: https://github.com/uNetworking/uWebSockets.js/issues/669\n        return this.skip();\n      }\n      const engine = listen((port) => {\n        const client = new ClientSocket(`ws://localhost:${port}`, {\n          transports: [\"polling\"],\n        });\n\n        engine.on(\"connection\", (socket) => {\n          socket.on(\"message\", (data) => {\n            expect(data).to.eql(\"123\");\n\n            client.close();\n            done();\n          });\n        });\n\n        client.on(\"open\", () => {\n          const req = http.request({\n            host: \"localhost\",\n            port,\n            path: `/engine.io/?EIO=4&transport=polling&sid=${client.id}`,\n            method: \"POST\",\n          });\n\n          req.write(process.env.EIO_CLIENT === \"3\" ? \"4:41\" : \"41\");\n          req.write(\"2\");\n          req.write(\"3\");\n          req.end();\n        });\n      });\n    });\n\n    it(\"should arrive as ArrayBuffer if requested when binary data sent as Buffer (polling)\", (done) => {\n      const binaryData = Buffer.allocUnsafe(5);\n      for (let i = 0; i < binaryData.length; i++) {\n        binaryData.writeInt8(i, i);\n      }\n\n      const opts = { allowUpgrades: false, transports: [\"polling\"] };\n      const engine = listen(opts, (port) => {\n        const socket = new ClientSocket(`ws://localhost:${port}`, {\n          transports: [\"polling\"],\n        });\n        socket.binaryType = \"arraybuffer\";\n\n        engine.on(\"connection\", (conn) => {\n          conn.send(binaryData);\n        });\n\n        socket.on(\"open\", () => {\n          socket.on(\"message\", (msg) => {\n            expect(msg instanceof ArrayBuffer).to.be(true);\n            const intArray = new Int8Array(msg);\n            for (let i = 0; i < binaryData.length; i++) {\n              expect(intArray[i]).to.be(i);\n            }\n\n            done();\n          });\n        });\n      });\n    });\n\n    it(\"should trigger a flush/drain event\", (done) => {\n      const engine = listen({ allowUpgrades: false }, (port) => {\n        engine.on(\"connection\", (socket) => {\n          let totalEvents = 4;\n\n          engine.on(\"flush\", (sock, buf) => {\n            expect(sock).to.be(socket);\n            expect(buf).to.be.an(\"array\");\n            --totalEvents || done();\n          });\n          socket.on(\"flush\", (buf) => {\n            expect(buf).to.be.an(\"array\");\n            --totalEvents || done();\n          });\n\n          engine.on(\"drain\", (sock) => {\n            expect(sock).to.be(socket);\n            expect(socket.writeBuffer.length).to.be(0);\n            --totalEvents || done();\n          });\n          socket.on(\"drain\", () => {\n            expect(socket.writeBuffer.length).to.be(0);\n            --totalEvents || done();\n          });\n\n          socket.send(\"aaaa\");\n        });\n\n        new ClientSocket(`ws://localhost:${port}`);\n      });\n    });\n\n    it(\n      \"should interleave with pongs if many messages buffered \" +\n        \"after connection open\",\n      function (done) {\n        if (process.env.EIO_WS_ENGINE === \"uws\") {\n          return this.skip();\n        }\n        this.slow(4000);\n        this.timeout(8000);\n\n        const opts = {\n          transports: [\"websocket\"],\n          pingInterval: 200,\n          pingTimeout: 100,\n        };\n\n        const engine = listen(opts, (port) => {\n          const messageCount = 100;\n          const messagePayload = new Array(256 * 256).join(\"a\");\n          let connection = null;\n          engine.on(\"connection\", (conn) => {\n            connection = conn;\n          });\n          const socket = new ClientSocket(`ws://localhost:${port}`, {\n            transports: [\"websocket\"],\n          });\n          socket.on(\"open\", () => {\n            for (let i = 0; i < messageCount; i++) {\n              //            connection.send('message: ' + i);   // works\n              connection.send(messagePayload + \"|message: \" + i); // does not work\n            }\n            let receivedCount = 0;\n            socket.on(\"message\", (msg) => {\n              receivedCount += 1;\n              if (receivedCount === messageCount) {\n                done();\n              }\n            });\n          });\n        });\n      }\n    );\n\n    it(\"should support chinese\", (done) => {\n      const engine = listen({ allowUpgrades: false }, (port) => {\n        const socket = new ClientSocket(`ws://localhost:${port}`);\n        const shi = \"\u77f3\u5ba4\u8a69\u58eb\u65bd\u6c0f\uff0c\u55dc\u7345\uff0c\u8a93\u98df\u5341\u7345\u3002\";\n        const shi2 = \"\u6c0f\u6642\u6642\u9069\u5e02\u8996\u7345\u3002\";\n        engine.on(\"connection\", (conn) => {\n          conn.send(\".\");\n          conn.send(shi);\n          conn.send(shi2);\n          conn.once(\"message\", (msg0) => {\n            expect(msg0).to.be(\".\");\n            conn.once(\"message\", (msg) => {\n              expect(msg).to.be(shi);\n              conn.once(\"message\", (msg2) => {\n                expect(msg2).to.be(shi2);\n                done();\n              });\n            });\n          });\n        });\n        socket.on(\"open\", () => {\n          socket.once(\"message\", (msg0) => {\n            expect(msg0).to.be(\".\");\n            socket.once(\"message\", (msg) => {\n              expect(msg).to.be(shi);\n              socket.once(\"message\", (msg2) => {\n                expect(msg2).to.be(shi2);\n                socket.send(\".\");\n                socket.send(shi);\n                socket.send(shi2);\n              });\n            });\n          });\n        });\n      });\n    });\n\n    it(\"should send and receive data with key and cert (polling)\", function (done) {\n      if (process.env.EIO_WS_ENGINE === \"uws\") {\n        return this.skip();\n      }\n      const srvOpts = {\n        key: fs.readFileSync(\"test/fixtures/server.key\"),\n        cert: fs.readFileSync(\"test/fixtures/server.crt\"),\n        ca: fs.readFileSync(\"test/fixtures/ca.crt\"),\n        requestCert: true,\n        rejectUnauthorized: true,\n      };\n\n      const opts = {\n        key: fs.readFileSync(\"test/fixtures/client.key\"),\n        cert: fs.readFileSync(\"test/fixtures/client.crt\"),\n        ca: fs.readFileSync(\"test/fixtures/ca.crt\"),\n        transports: [\"polling\"],\n      };\n\n      const srv = https.createServer(srvOpts, (req, res) => {\n        res.writeHead(200);\n        res.end(\"hello world\\n\");\n      });\n\n      const engine = new Server({\n        transports: [\"polling\"],\n        allowUpgrades: false,\n        allowEIO3: true,\n      });\n      engine.attach(srv);\n      srv.listen(() => {\n        const port = srv.address().port;\n        const socket = new ClientSocket(`https://localhost:${port}`, opts);\n\n        engine.on(\"connection\", (conn) => {\n          conn.on(\"message\", (msg) => {\n            expect(msg).to.be(\"hello\");\n            done();\n          });\n        });\n\n        socket.on(\"open\", () => {\n          socket.send(\"hello\");\n        });\n      });\n    });\n\n    it(\"should send and receive data with ca when not requiring auth (polling)\", function (done) {\n      if (process.env.EIO_WS_ENGINE === \"uws\") {\n        return this.skip();\n      }\n      const srvOpts = {\n        key: fs.readFileSync(\"test/fixtures/server.key\"),\n        cert: fs.readFileSync(\"test/fixtures/server.crt\"),\n        ca: fs.readFileSync(\"test/fixtures/ca.crt\"),\n        requestCert: true,\n        rejectUnauthorized: false,\n      };\n\n      const opts = {\n        ca: fs.readFileSync(\"test/fixtures/ca.crt\"),\n        transports: [\"polling\"],\n      };\n\n      const srv = https.createServer(srvOpts, (req, res) => {\n        res.writeHead(200);\n        res.end(\"hello world\\n\");\n      });\n\n      const engine = new Server({\n        transports: [\"polling\"],\n        allowUpgrades: false,\n        allowEIO3: true,\n      });\n      engine.attach(srv);\n      srv.listen(() => {\n        const port = srv.address().port;\n        const socket = new ClientSocket(`https://localhost:${port}`, opts);\n\n        engine.on(\"connection\", (conn) => {\n          conn.on(\"message\", (msg) => {\n            expect(msg).to.be(\"hello\");\n            done();\n          });\n        });\n\n        socket.on(\"open\", () => {\n          socket.send(\"hello\");\n        });\n      });\n    });\n\n    it(\"should send and receive data with key and cert (ws)\", function (done) {\n      if (process.env.EIO_WS_ENGINE === \"uws\") {\n        return this.skip();\n      }\n      const srvOpts = {\n        key: fs.readFileSync(\"test/fixtures/server.key\"),\n        cert: fs.readFileSync(\"test/fixtures/server.crt\"),\n        ca: fs.readFileSync(\"test/fixtures/ca.crt\"),\n        requestCert: true,\n        rejectUnauthorized: true,\n      };\n\n      const opts = {\n        key: fs.readFileSync(\"test/fixtures/client.key\"),\n        cert: fs.readFileSync(\"test/fixtures/client.crt\"),\n        ca: fs.readFileSync(\"test/fixtures/ca.crt\"),\n        transports: [\"websocket\"],\n      };\n\n      const srv = https.createServer(srvOpts, (req, res) => {\n        res.writeHead(200);\n        res.end(\"hello world\\n\");\n      });\n\n      const engine = new Server({\n        transports: [\"websocket\"],\n        allowUpgrades: false,\n        allowEIO3: true,\n      });\n      engine.attach(srv);\n      srv.listen(() => {\n        const port = srv.address().port;\n        const socket = new ClientSocket(`https://localhost:${port}`, opts);\n\n        engine.on(\"connection\", (conn) => {\n          conn.on(\"message\", (msg) => {\n            expect(msg).to.be(\"hello\");\n            done();\n          });\n        });\n\n        socket.on(\"open\", () => {\n          socket.send(\"hello\");\n        });\n      });\n    });\n\n    it(\"should send and receive data with pfx (polling)\", function (done) {\n      if (process.env.EIO_WS_ENGINE === \"uws\") {\n        return this.skip();\n      }\n      const srvOpts = {\n        key: fs.readFileSync(\"test/fixtures/server.key\"),\n        cert: fs.readFileSync(\"test/fixtures/server.crt\"),\n        ca: fs.readFileSync(\"test/fixtures/ca.crt\"),\n        requestCert: true,\n        rejectUnauthorized: true,\n      };\n\n      const opts = {\n        pfx: fs.readFileSync(\"test/fixtures/client.pfx\"),\n        ca: fs.readFileSync(\"test/fixtures/ca.crt\"),\n        transports: [\"polling\"],\n      };\n\n      const srv = https.createServer(srvOpts, (req, res) => {\n        res.writeHead(200);\n        res.end(\"hello world\\n\");\n      });\n\n      const engine = new Server({\n        transports: [\"polling\"],\n        allowUpgrades: false,\n        allowEIO3: true,\n      });\n      engine.attach(srv);\n      srv.listen(() => {\n        const port = srv.address().port;\n        const socket = new ClientSocket(`https://localhost:${port}`, opts);\n\n        engine.on(\"connection\", (conn) => {\n          conn.on(\"message\", (msg) => {\n            expect(msg).to.be(\"hello\");\n            done();\n          });\n        });\n\n        socket.on(\"open\", () => {\n          socket.send(\"hello\");\n        });\n      });\n    });\n\n    it(\"should send and receive data with pfx (ws)\", function (done) {\n      if (process.env.EIO_WS_ENGINE === \"uws\") {\n        return this.skip();\n      }\n      const srvOpts = {\n        key: fs.readFileSync(\"test/fixtures/server.key\"),\n        cert: fs.readFileSync(\"test/fixtures/server.crt\"),\n        ca: fs.readFileSync(\"test/fixtures/ca.crt\"),\n        requestCert: true,\n        rejectUnauthorized: true,\n      };\n\n      const opts = {\n        pfx: fs.readFileSync(\"test/fixtures/client.pfx\"),\n        ca: fs.readFileSync(\"test/fixtures/ca.crt\"),\n        transports: [\"websocket\"],\n      };\n\n      const srv = https.createServer(srvOpts, (req, res) => {\n        res.writeHead(200);\n        res.end(\"hello world\\n\");\n      });\n\n      const engine = new Server({\n        transports: [\"websocket\"],\n        allowUpgrades: false,\n        allowEIO3: true,\n      });\n      engine.attach(srv);\n      srv.listen(() => {\n        const port = srv.address().port;\n        const socket = new ClientSocket(`https://localhost:${port}`, opts);\n\n        engine.on(\"connection\", (conn) => {\n          conn.on(\"message\", (msg) => {\n            expect(msg).to.be(\"hello\");\n            done();\n          });\n        });\n\n        socket.on(\"open\", () => {\n          socket.send(\"hello\");\n        });\n      });\n    });\n  });\n\n  describe(\"send\", () => {\n    describe(\"writeBuffer\", () => {\n      it(\"should not empty until `drain` event (polling)\", (done) => {\n        listen({ allowUpgrades: false }, (port) => {\n          const socket = new ClientSocket(`ws://localhost:${port}`, {\n            transports: [\"polling\"],\n          });\n          let totalEvents = 2;\n          socket.on(\"open\", () => {\n            socket.send(\"a\");\n            socket.send(\"b\");\n            // writeBuffer should be nonempty, with 'a' still in it\n            expect(socket.writeBuffer.length).to.eql(2);\n          });\n          socket.transport.on(\"drain\", () => {\n            expect(socket.writeBuffer.length).to.eql(--totalEvents);\n            totalEvents || done();\n          });\n        });\n      });\n\n      it(\"should not empty until `drain` event (websocket)\", (done) => {\n        listen({ allowUpgrades: false }, (port) => {\n          const socket = new ClientSocket(`ws://localhost:${port}`, {\n            transports: [\"websocket\"],\n          });\n          let totalEvents = 2;\n          socket.on(\"open\", () => {\n            socket.send(\"a\");\n            socket.send(\"b\");\n            // writeBuffer should be nonempty, with 'a' still in it\n            expect(socket.writeBuffer.length).to.eql(2);\n          });\n          socket.transport.on(\"drain\", () => {\n            expect(socket.writeBuffer.length).to.eql(--totalEvents);\n            totalEvents || done();\n          });\n        });\n      });\n    });\n\n    describe(\"callback\", () => {\n      it(\"should execute in order when message sent (client) (polling)\", (done) => {\n        const engine = listen({ allowUpgrades: false }, (port) => {\n          const socket = new ClientSocket(`ws://localhost:${port}`, {\n            transports: [\"polling\"],\n          });\n          let i = 0;\n          let j = 0;\n\n          engine.on(\"connection\", (conn) => {\n            conn.on(\"message\", (msg) => {\n              conn.send(msg);\n            });\n          });\n\n          socket.on(\"open\", () => {\n            socket.on(\"message\", (msg) => {\n              // send another packet until we've sent 3 total\n              if (++i < 3) {\n                expect(i).to.eql(j);\n                sendFn();\n              } else {\n                done();\n              }\n            });\n\n            function sendFn() {\n              socket.send(\n                j,\n                ((value) => {\n                  j++;\n                })(j)\n              );\n            }\n\n            sendFn();\n          });\n        });\n      });\n\n      it(\"should execute in order when message sent (client) (websocket)\", (done) => {\n        const engine = listen({ allowUpgrades: false }, (port) => {\n          const socket = new ClientSocket(`ws://localhost:${port}`, {\n            transports: [\"websocket\"],\n          });\n          let i = 0;\n          let j = 0;\n\n          engine.on(\"connection\", (conn) => {\n            conn.on(\"message\", (msg) => {\n              conn.send(msg);\n            });\n          });\n\n          socket.on(\"open\", () => {\n            socket.on(\"message\", (msg) => {\n              // send another packet until we've sent 3 total\n              if (++i < 3) {\n                expect(i).to.eql(j);\n                sendFn();\n              } else {\n                done();\n              }\n            });\n\n            function sendFn() {\n              socket.send(\n                j,\n                ((value) => {\n                  j++;\n                })(j)\n              );\n            }\n\n            sendFn();\n          });\n        });\n      });\n\n      it(\"should execute in order with payloads (client) (polling)\", (done) => {\n        const engine = listen({ allowUpgrades: false }, (port) => {\n          const socket = new ClientSocket(`ws://localhost:${port}`, {\n            transports: [\"polling\"],\n          });\n          let i = 0;\n          let lastCbFired = 0;\n\n          engine.on(\"connection\", (conn) => {\n            conn.on(\"message\", (msg) => {\n              conn.send(msg);\n            });\n          });\n\n          socket.on(\"open\", () => {\n            socket.on(\"message\", (msg) => {\n              expect(msg).to.eql(i + 1);\n              i++;\n            });\n\n            function cb(value) {\n              expect(value).to.eql(lastCbFired + 1);\n              lastCbFired = value;\n              if (value === 3) {\n                done();\n              }\n            }\n\n            // 2 and 3 will be in the same payload\n            socket.once(\"flush\", () => {\n              socket.send(2, () => {\n                cb(2);\n              });\n              socket.send(3, () => {\n                cb(3);\n              });\n            });\n\n            socket.send(1, () => {\n              cb(1);\n            });\n          });\n        });\n      });\n\n      it(\"should execute in order with payloads (client) (websocket)\", (done) => {\n        const engine = listen({ allowUpgrades: false }, (port) => {\n          const socket = new ClientSocket(`ws://localhost:${port}`, {\n            transports: [\"websocket\"],\n          });\n          let i = 0;\n          let lastCbFired = 0;\n\n          engine.on(\"connection\", (conn) => {\n            conn.on(\"message\", (msg) => {\n              conn.send(msg);\n            });\n          });\n\n          socket.on(\"open\", () => {\n            socket.on(\"message\", (msg) => {\n              expect(msg).to.eql(i + 1);\n              i++;\n            });\n\n            function cb(value) {\n              expect(value).to.eql(lastCbFired + 1);\n              lastCbFired = value;\n              if (value === 3) {\n                done();\n              }\n            }\n\n            // 2 and 3 will be in the same payload\n            socket.once(\"flush\", () => {\n              socket.send(2, () => {\n                cb(2);\n              });\n              socket.send(3, () => {\n                cb(3);\n              });\n            });\n\n            socket.send(1, () => {\n              cb(1);\n            });\n          });\n        });\n      });\n\n      it(\"should execute when message sent (polling)\", (done) => {\n        const engine = listen({ allowUpgrades: false }, (port) => {\n          const socket = new ClientSocket(`ws://localhost:${port}`, {\n            transports: [\"polling\"],\n          });\n          let i = 0;\n          let j = 0;\n\n          engine.on(\"connection\", (conn) => {\n            conn.send(\"a\", (transport) => {\n              i++;\n            });\n          });\n          socket.on(\"open\", () => {\n            socket.on(\"message\", (msg) => {\n              j++;\n            });\n          });\n\n          setTimeout(() => {\n            expect(i).to.be(j);\n            done();\n          }, 100);\n        });\n      });\n\n      it(\"should execute when message sent (websocket)\", (done) => {\n        const engine = listen({ allowUpgrades: false }, (port) => {\n          const socket = new ClientSocket(`ws://localhost:${port}`, {\n            transports: [\"websocket\"],\n          });\n          let i = 0;\n          let j = 0;\n\n          engine.on(\"connection\", (conn) => {\n            conn.send(\"a\", (transport) => {\n              i++;\n            });\n          });\n\n          socket.on(\"open\", () => {\n            socket.on(\"message\", (msg) => {\n              j++;\n            });\n          });\n\n          setTimeout(() => {\n            expect(i).to.be(j);\n            done();\n          }, 100);\n        });\n      });\n\n      it(\"should execute once for each send\", (done) => {\n        const engine = listen((port) => {\n          const socket = new ClientSocket(`ws://localhost:${port}`);\n          let a = 0;\n          let b = 0;\n          let c = 0;\n          let all = 0;\n\n          engine.on(\"connection\", (conn) => {\n            conn.send(\"a\");\n            conn.send(\"b\");\n            conn.send(\"c\");\n          });\n\n          socket.on(\"open\", () => {\n            socket.on(\"message\", (msg) => {\n              if (msg === \"a\") a++;\n              if (msg === \"b\") b++;\n              if (msg === \"c\") c++;\n\n              if (++all === 3) {\n                expect(a).to.be(1);\n                expect(b).to.be(1);\n                expect(c).to.be(1);\n                done();\n              }\n            });\n          });\n        });\n      });\n\n      it(\"should execute in multipart packet\", (done) => {\n        const engine = listen((port) => {\n          const socket = new ClientSocket(`ws://localhost:${port}`);\n          let i = 0;\n          let j = 0;\n\n          engine.on(\"connection\", (conn) => {\n            conn.send(\"b\", (transport) => {\n              i++;\n            });\n\n            conn.send(\"a\", (transport) => {\n              i++;\n            });\n          });\n          socket.on(\"open\", () => {\n            socket.on(\"message\", (msg) => {\n              j++;\n            });\n          });\n\n          setTimeout(() => {\n            expect(i).to.be(j);\n            done();\n          }, 200);\n        });\n      });\n\n      it(\"should execute in multipart packet (polling)\", (done) => {\n        const engine = listen((port) => {\n          const socket = new ClientSocket(`ws://localhost:${port}`, {\n            transports: [\"polling\"],\n          });\n          let i = 0;\n          let j = 0;\n\n          engine.on(\"connection\", (conn) => {\n            conn.send(\"d\", (transport) => {\n              i++;\n            });\n\n            conn.send(\"c\", (transport) => {\n              i++;\n            });\n\n            conn.send(\"b\", (transport) => {\n              i++;\n            });\n\n            conn.send(\"a\", (transport) => {\n              i++;\n            });\n          });\n          socket.on(\"open\", () => {\n            socket.on(\"message\", (msg) => {\n              j++;\n            });\n          });\n\n          setTimeout(() => {\n            expect(i).to.be(j);\n            done();\n          }, 200);\n        });\n      });\n\n      it(\"should clean callback references when socket gets closed with pending callbacks\", (done) => {\n        const engine = listen({ allowUpgrades: false }, (port) => {\n          const socket = new ClientSocket(`ws://localhost:${port}`, {\n            transports: [\"polling\"],\n          });\n\n          engine.on(\"connection\", (conn) => {\n            socket.transport.on(\"pollComplete\", () => {\n              conn.send(\"a\", (transport) => {\n                done(new Error(\"Test invalidation\"));\n              });\n\n              if (!conn.writeBuffer.length) {\n                done(new Error(\"Test invalidation\"));\n              }\n\n              // force to close the socket when we have one or more packet(s) in buffer\n              socket.close();\n            });\n\n            conn.on(\"close\", (reason) => {\n              expect(conn.packetsFn).to.be.empty();\n              expect(conn.sentCallbackFn).to.be.empty();\n              done();\n            });\n          });\n        });\n      });\n\n      it(\"should not execute when it is not actually sent (polling)\", (done) => {\n        const engine = listen({ allowUpgrades: false }, (port) => {\n          const socket = new ClientSocket(`ws://localhost:${port}`, {\n            transports: [\"polling\"],\n          });\n\n          socket.transport.on(\"pollComplete\", (msg) => {\n            socket.close();\n          });\n\n          engine.on(\"connection\", (conn) => {\n            let err;\n            conn.send(\"a\");\n            conn.send(\"b\", (transport) => {\n              err = new Error(\"Test invalidation\");\n            });\n            conn.on(\"close\", (reason) => {\n              done(err);\n            });\n          });\n        });\n      });\n    });\n\n    describe(\"pre-encoded content\", () => {\n      it(\"should use the pre-encoded content\", (done) => {\n        engine = listen((port) => {\n          client = new ClientSocket(`ws://localhost:${port}`, {\n            transports: [\"websocket\"],\n          });\n\n          engine.on(\"connection\", (conn) => {\n            conn.send(\"test\", {\n              wsPreEncoded: \"4test pre-encoded\",\n            });\n          });\n\n          client.on(\"message\", (msg) => {\n            expect(msg).to.be(\"test pre-encoded\");\n            done();\n          });\n        });\n      });\n\n      it(\"should use the pre-encoded frame\", function (done) {\n        if (process.env.EIO_WS_ENGINE === \"uws\") {\n          return this.skip();\n        }\n        engine = listen((port) => {\n          client = new ClientSocket(`ws://localhost:${port}`, {\n            transports: [\"websocket\"],\n          });\n\n          engine.on(\"connection\", (conn) => {\n            conn.send(\"test\", {\n              wsPreEncodedFrame: [\n                Buffer.from([129, 4]),\n                Buffer.from([52, 49, 50, 51]),\n              ],\n            });\n          });\n\n          client.on(\"message\", (msg) => {\n            expect(msg).to.be(\"123\");\n            done();\n          });\n        });\n      });\n\n      it(\"should not use the pre-encoded frame when the permessage-deflate extension is enabled\", (done) => {\n        engine = listen({ perMessageDeflate: true }, (port) => {\n          client = new ClientSocket(`ws://localhost:${port}`, {\n            transports: [\"websocket\"],\n          });\n\n          engine.on(\"connection\", (conn) => {\n            conn.send(\"test\", {\n              wsPreEncodedFrame: [\n                Buffer.from([129, 4]),\n                Buffer.from([52, 49, 50, 51]),\n              ],\n            });\n          });\n\n          client.on(\"message\", (msg) => {\n            expect(msg).to.be(\"test\");\n            done();\n          });\n        });\n      });\n    });\n  });\n\n  describe(\"packet\", () => {\n    it(\"should emit when socket receives packet\", (done) => {\n      const engine = listen({ allowUpgrades: false }, (port) => {\n        const socket = new ClientSocket(`ws://localhost:${port}`);\n        engine.on(\"connection\", (conn) => {\n          conn.on(\"packet\", (packet) => {\n            expect(packet.type).to.be(\"message\");\n            expect(packet.data).to.be(\"a\");\n            done();\n          });\n        });\n        socket.on(\"open\", () => {\n          socket.send(\"a\");\n        });\n      });\n    });\n\n    it(\"should emit when receives pong\", (done) => {\n      const engine = listen(\n        { allowUpgrades: false, pingInterval: 4 },\n        (port) => {\n          new ClientSocket(`ws://localhost:${port}`);\n          engine.on(\"connection\", (conn) => {\n            conn.on(\"packet\", (packet) => {\n              conn.close();\n              if (process.env.EIO_CLIENT === \"3\") {\n                expect(packet.type).to.be(\"ping\");\n              } else {\n                expect(packet.type).to.be(\"pong\");\n              }\n              done();\n            });\n          });\n        }\n      );\n    });\n  });\n\n  describe(\"packetCreate\", () => {\n    it(\"should emit before socket send message\", (done) => {\n      const engine = listen({ allowUpgrades: false }, (port) => {\n        new ClientSocket(`ws://localhost:${port}`);\n        engine.on(\"connection\", (conn) => {\n          conn.on(\"packetCreate\", (packet) => {\n            expect(packet.type).to.be(\"message\");\n            expect(packet.data).to.be(\"a\");\n            done();\n          });\n          conn.send(\"a\");\n        });\n      });\n    });\n\n    it(\"should emit before send pong\", (done) => {\n      const engine = listen(\n        { allowUpgrades: false, pingInterval: 4 },\n        (port) => {\n          new ClientSocket(`ws://localhost:${port}`);\n          engine.on(\"connection\", (conn) => {\n            conn.on(\"packetCreate\", (packet) => {\n              conn.close();\n              if (process.env.EIO_CLIENT === \"3\") {\n                expect(packet.type).to.be(\"pong\");\n              } else {\n                expect(packet.type).to.be(\"ping\");\n              }\n              done();\n            });\n          });\n        }\n      );\n    });\n  });\n\n  describe(\"upgrade\", () => {\n    it(\"should upgrade\", (done) => {\n      const engine = listen((port) => {\n        // it takes both to send 50 to verify\n        let ready = 2;\n        let closed = 2;\n\n        function finish() {\n          setTimeout(() => {\n            socket.close();\n          }, 10);\n        }\n\n        // server\n        engine.on(\"connection\", (conn) => {\n          let lastSent = 0;\n          let lastReceived = 0;\n          let upgraded = false;\n          const interval = setInterval(() => {\n            lastSent++;\n            conn.send(lastSent);\n            if (50 === lastSent) {\n              clearInterval(interval);\n              --ready || finish();\n            }\n          }, 2);\n\n          expect(conn.request._query.transport).to.be(\"polling\");\n\n          conn.on(\"message\", (msg) => {\n            expect(conn.request._query).to.be.an(\"object\");\n            lastReceived++;\n            expect(msg).to.eql(lastReceived);\n          });\n\n          conn.on(\"upgrade\", (to) => {\n            expect(conn.request._query.transport).to.be(\"polling\");\n            upgraded = true;\n            expect(to.name).to.be(\"websocket\");\n            expect(conn.transport.name).to.be(\"websocket\");\n          });\n\n          conn.on(\"close\", (reason) => {\n            expect(reason).to.be(\"transport close\");\n            expect(lastSent).to.be(50);\n            expect(lastReceived).to.be(50);\n            expect(upgraded).to.be(true);\n            --closed || done();\n          });\n        });\n\n        // client\n        var socket = new ClientSocket(`ws://localhost:${port}`);\n        socket.on(\"open\", () => {\n          let lastSent = 0;\n          let lastReceived = 0;\n          let upgrades = 0;\n          const interval = setInterval(() => {\n            lastSent++;\n            socket.send(lastSent);\n            if (50 === lastSent) {\n              clearInterval(interval);\n              --ready || finish();\n            }\n          }, 2);\n          socket.on(\"upgrading\", (to) => {\n            // we want to make sure for the sake of this test that we have a buffer\n            expect(to.name).to.equal(\"websocket\");\n            upgrades++;\n\n            // force send a few packets to ensure we test buffer transfer\n            lastSent++;\n            socket.send(lastSent);\n            lastSent++;\n            socket.send(lastSent);\n\n            expect(socket.writeBuffer).to.not.be.empty();\n          });\n          socket.on(\"upgrade\", (to) => {\n            expect(to.name).to.equal(\"websocket\");\n            upgrades++;\n          });\n          socket.on(\"message\", (msg) => {\n            lastReceived++;\n            expect(lastReceived).to.eql(msg);\n          });\n          socket.on(\"close\", (reason) => {\n            expect(reason).to.be(\"forced close\");\n            expect(lastSent).to.be(50);\n            expect(upgrades).to.be(2);\n            --closed || done();\n          });\n        });\n      });\n\n      if (engine.httpServer) {\n        // attach another engine to make sure it doesn't break upgrades\n        attach(engine.httpServer, { path: \"/foo\" });\n      }\n    });\n  });\n\n  describe(\"http compression\", () => {\n    function getSidFromResponse(res) {\n      const c = cookieMod.parse(res.headers[\"set-cookie\"][0]);\n      return c[Object.keys(c)[0]];\n    }\n\n    it(\"should compress by default\", (done) => {\n      const engine = listen(\n        { cookie: true, transports: [\"polling\"] },\n        (port) => {\n          engine.on(\"connection\", (conn) => {\n            const buf = Buffer.allocUnsafe(1024);\n            for (let i = 0; i < buf.length; i++) buf[i] = i % 0xff;\n            conn.send(buf);\n          });\n\n          http.get(\n            {\n              port: port,\n              path: \"/engine.io/?transport=polling\",\n            },\n            (res) => {\n              const sid = getSidFromResponse(res);\n              http.get(\n                {\n                  port: port,\n                  path: \"/engine.io/?transport=polling&sid=\" + sid,\n                  headers: { \"Accept-Encoding\": \"gzip, deflate\" },\n                },\n                (res) => {\n                  expect(res.headers[\"content-encoding\"]).to.equal(\"gzip\");\n                  res\n                    .pipe(zlib.createGunzip())\n                    .on(\"error\", done)\n                    .on(\"end\", done)\n                    .resume();\n                }\n              );\n            }\n          );\n        }\n      );\n    });\n\n    it(\"should compress using deflate\", (done) => {\n      const engine = listen(\n        { cookie: true, transports: [\"polling\"] },\n        (port) => {\n          engine.on(\"connection\", (conn) => {\n            const buf = Buffer.allocUnsafe(1024);\n            for (let i = 0; i < buf.length; i++) buf[i] = i % 0xff;\n            conn.send(buf);\n          });\n\n          http.get(\n            {\n              port: port,\n              path: \"/engine.io/?transport=polling\",\n            },\n            (res) => {\n              const sid = getSidFromResponse(res);\n              http.get(\n                {\n                  port: port,\n                  path: \"/engine.io/?transport=polling&sid=\" + sid,\n                  headers: { \"Accept-Encoding\": \"deflate\" },\n                },\n                (res) => {\n                  expect(res.headers[\"content-encoding\"]).to.equal(\"deflate\");\n                  res\n                    .pipe(zlib.createDeflate())\n                    .on(\"error\", done)\n                    .on(\"end\", done)\n                    .resume();\n                }\n              );\n            }\n          );\n        }\n      );\n    });\n\n    it(\"should set threshold\", (done) => {\n      const engine = listen(\n        {\n          cookie: true,\n          transports: [\"polling\"],\n          httpCompression: { threshold: 0 },\n        },\n        (port) => {\n          engine.on(\"connection\", (conn) => {\n            const buf = Buffer.allocUnsafe(10);\n            for (let i = 0; i < buf.length; i++) buf[i] = i % 0xff;\n            conn.send(buf);\n          });\n\n          http.get(\n            {\n              port: port,\n              path: \"/engine.io/?transport=polling\",\n            },\n            (res) => {\n              const sid = getSidFromResponse(res);\n              http.get(\n                {\n                  port: port,\n                  path: \"/engine.io/?transport=polling&sid=\" + sid,\n                  headers: { \"Accept-Encoding\": \"gzip, deflate\" },\n                },\n                (res) => {\n                  expect(res.headers[\"content-encoding\"]).to.equal(\"gzip\");\n                  done();\n                }\n              );\n            }\n          );\n        }\n      );\n    });\n\n    it(\"should disable compression\", (done) => {\n      const engine = listen(\n        { cookie: true, transports: [\"polling\"], httpCompression: false },\n        (port) => {\n          engine.on(\"connection\", (conn) => {\n            const buf = Buffer.allocUnsafe(1024);\n            for (let i = 0; i < buf.length; i++) buf[i] = i % 0xff;\n            conn.send(buf);\n          });\n\n          http.get(\n            {\n              port: port,\n              path: \"/engine.io/?transport=polling\",\n            },\n            (res) => {\n              const sid = getSidFromResponse(res);\n              http.get(\n                {\n                  port: port,\n                  path: \"/engine.io/?transport=polling&sid=\" + sid,\n                  headers: { \"Accept-Encoding\": \"gzip, deflate\" },\n                },\n                (res) => {\n                  expect(res.headers[\"content-encoding\"]).to.be(undefined);\n                  done();\n                }\n              );\n            }\n          );\n        }\n      );\n    });\n\n    it(\"should disable compression per message\", (done) => {\n      const engine = listen(\n        { cookie: true, transports: [\"polling\"] },\n        (port) => {\n          engine.on(\"connection\", (conn) => {\n            const buf = Buffer.allocUnsafe(1024);\n            for (let i = 0; i < buf.length; i++) buf[i] = i % 0xff;\n            conn.send(buf, { compress: false });\n          });\n\n          http.get(\n            {\n              port: port,\n              path: \"/engine.io/?transport=polling\",\n            },\n            (res) => {\n              const sid = getSidFromResponse(res);\n              http.get(\n                {\n                  port: port,\n                  path: \"/engine.io/?transport=polling&sid=\" + sid,\n                  headers: { \"Accept-Encoding\": \"gzip, deflate\" },\n                },\n                (res) => {\n                  expect(res.headers[\"content-encoding\"]).to.be(undefined);\n                  done();\n                }\n              );\n            }\n          );\n        }\n      );\n    });\n\n    it(\"should not compress when the byte size is below threshold\", (done) => {\n      const engine = listen(\n        { cookie: true, transports: [\"polling\"] },\n        (port) => {\n          engine.on(\"connection\", (conn) => {\n            const buf = Buffer.allocUnsafe(100);\n            for (let i = 0; i < buf.length; i++) buf[i] = i % 0xff;\n            conn.send(buf);\n          });\n\n          http.get(\n            {\n              port: port,\n              path: \"/engine.io/?transport=polling\",\n            },\n            (res) => {\n              const sid = getSidFromResponse(res);\n              http.get(\n                {\n                  port: port,\n                  path: \"/engine.io/?transport=polling&sid=\" + sid,\n                  headers: { \"Accept-Encoding\": \"gzip, deflate\" },\n                },\n                (res) => {\n                  expect(res.headers[\"content-encoding\"]).to.be(undefined);\n                  done();\n                }\n              );\n            }\n          );\n        }\n      );\n    });\n  });\n\n  describe(\"permessage-deflate\", () => {\n    it(\"should set threshold\", function (done) {\n      if (process.env.EIO_WS_ENGINE === \"uws\") {\n        return this.skip();\n      }\n      const engine = listen(\n        { transports: [\"websocket\"], perMessageDeflate: { threshold: 0 } },\n        (port) => {\n          engine.on(\"connection\", (conn) => {\n            const socket = conn.transport.socket;\n            const send = socket.send;\n            socket.send = (data, opts, callback) => {\n              socket.send = send;\n              socket.send(data, opts, callback);\n\n              expect(opts.compress).to.be(true);\n              conn.close();\n              done();\n            };\n\n            const buf = Buffer.allocUnsafe(100);\n            for (let i = 0; i < buf.length; i++) buf[i] = i % 0xff;\n            conn.send(buf, { compress: true });\n          });\n          new ClientSocket(`http://localhost:${port}`, {\n            transports: [\"websocket\"],\n          });\n        }\n      );\n    });\n\n    it(\"should not compress when the byte size is below threshold\", function (done) {\n      if (process.env.EIO_WS_ENGINE === \"uws\") {\n        return this.skip();\n      }\n      const engine = listen(\n        { transports: [\"websocket\"], perMessageDeflate: true },\n        (port) => {\n          engine.on(\"connection\", (conn) => {\n            const socket = conn.transport.socket;\n            const send = socket.send;\n            socket.send = (data, opts, callback) => {\n              socket.send = send;\n              socket.send(data, opts, callback);\n\n              expect(opts.compress).to.be(false);\n              conn.close();\n              done();\n            };\n\n            const buf = Buffer.allocUnsafe(100);\n            for (let i = 0; i < buf.length; i++) buf[i] = i % 0xff;\n            conn.send(buf, { compress: true });\n          });\n          new ClientSocket(`http://localhost:${port}`, {\n            transports: [\"websocket\"],\n          });\n        }\n      );\n    });\n  });\n\n  describe(\"extraHeaders\", function () {\n    this.timeout(5000);\n\n    const headers = {\n      \"x-custom-header-for-my-project\": \"my-secret-access-token\",\n      cookie:\n        \"user_session=NI2JlCKF90aE0sJZD9ZzujtdsUqNYSBYxzlTsvdSUe35ZzdtVRGqYFr0kdGxbfc5gUOkR9RGp20GVKza; path=/; expires=Tue, 07-Apr-2015 18:18:08 GMT; secure; HttpOnly\",\n    };\n\n    function testForTransport(transport, done) {\n      const engine = listen((port) => {\n        const socket = new ClientSocket(`ws://localhost:${port}`, {\n          extraHeaders: headers,\n          transports: [transport],\n        });\n        engine.on(\"connection\", (conn) => {\n          for (let h in headers) {\n            expect(conn.request.headers[h]).to.equal(headers[h]);\n          }\n          done();\n        });\n        socket.on(\"open\", () => {});\n      });\n    }\n\n    it(\"should arrive from client to server via WebSockets\", (done) => {\n      testForTransport(\"websocket\", done);\n    });\n\n    it(\"should arrive from client to server via XMLHttpRequest\", (done) => {\n      testForTransport(\"polling\", done);\n    });\n  });\n\n  describe(\"response headers\", () => {\n    function testForHeaders(headers, done) {\n      const engine = listen((port) => {\n        engine.on(\"connection\", (conn) => {\n          conn.transport.once(\"headers\", (headers) => {\n            expect(headers[\"X-XSS-Protection\"]).to.be(\"0\");\n            conn.close();\n            done();\n          });\n          conn.send(\"hi\");\n        });\n        new ClientSocket(`ws://localhost:${port}`, {\n          extraHeaders: headers,\n          transports: [\"polling\"],\n        });\n      });\n    }\n\n    it(\"should contain X-XSS-Protection: 0 for IE8\", (done) => {\n      const headers = {\n        \"user-agent\":\n          \"Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; Tablet PC 2.0)\",\n      };\n      testForHeaders(headers, done);\n    });\n\n    it(\"should contain X-XSS-Protection: 0 for IE11\", (done) => {\n      const headers = {\n        \"user-agent\":\n          \"Mozilla/5.0 (Windows NT 6.3; Trident/7.0; rv:11.0) like Gecko\",\n      };\n      testForHeaders(headers, done);\n    });\n\n    it(\"should emit a 'initial_headers' event (polling)\", (done) => {\n      const partialDone = createPartialDone(done, 2);\n\n      engine = listen({ cookie: true }, (port) => {\n        engine.on(\"initial_headers\", (headers, req) => {\n          expect(req.method).to.be(\"GET\");\n          headers[\"test\"] = \"123\";\n          headers[\"set-cookie\"] = \"mycookie=456\";\n          partialDone();\n        });\n\n        request\n          .get(`http://localhost:${port}/engine.io/`)\n          .query({ transport: \"polling\" })\n          .end((err, res) => {\n            expect(err).to.be(null);\n            expect(res.status).to.be(200);\n            expect(res.headers[\"test\"]).to.be(\"123\");\n            expect(res.headers[\"set-cookie\"].length).to.be(2);\n            expect(res.headers[\"set-cookie\"][1]).to.be(\"mycookie=456\");\n\n            const sid = JSON.parse(res.text.slice(5)).sid;\n\n            request\n              .post(`http://localhost:${port}/engine.io/`)\n              .query({ transport: \"polling\", sid })\n              .send(\"1:6\")\n              .end((err, res) => {\n                expect(err).to.be(null);\n                expect(res.status).to.be(200);\n                expect(res.headers[\"test\"]).to.be(undefined);\n                expect(res.headers[\"set-cookie\"]).to.be(undefined);\n                partialDone();\n              });\n          });\n      });\n    });\n\n    it(\"should emit a 'headers' event (polling)\", (done) => {\n      const partialDone = createPartialDone(done, 3);\n\n      engine = listen({ cookie: true }, (port) => {\n        engine.on(\"headers\", (headers) => {\n          headers[\"test\"] = \"123\";\n          headers[\"set-cookie\"] = \"mycookie=456\";\n          partialDone();\n        });\n\n        request\n          .get(`http://localhost:${port}/engine.io/`)\n          .query({ transport: \"polling\" })\n          .end((err, res) => {\n            expect(err).to.be(null);\n            expect(res.status).to.be(200);\n            expect(res.headers[\"test\"]).to.be(\"123\");\n            expect(res.headers[\"set-cookie\"].length).to.be(2);\n            expect(res.headers[\"set-cookie\"][1]).to.be(\"mycookie=456\");\n\n            const sid = JSON.parse(res.text.slice(5)).sid;\n\n            request\n              .post(`http://localhost:${port}/engine.io/`)\n              .query({ transport: \"polling\", sid })\n              .send(\"1:6\")\n              .end((err, res) => {\n                expect(err).to.be(null);\n                expect(res.status).to.be(200);\n                expect(res.headers[\"set-cookie\"].length).to.be(1);\n                expect(res.headers[\"set-cookie\"][0]).to.be(\"mycookie=456\");\n                partialDone();\n              });\n          });\n      });\n    });\n\n    it(\"should emit a 'initial_headers' event (websocket)\", function (done) {\n      if (\n        process.env.EIO_WS_ENGINE === \"eiows\" ||\n        process.env.EIO_WS_ENGINE === \"uws\"\n      ) {\n        return this.skip();\n      }\n      const partialDone = createPartialDone(done, 2);\n\n      engine = listen({ cookie: true }, (port) => {\n        engine.on(\"initial_headers\", (headers, req) => {\n          expect(req.method).to.be(\"GET\");\n          headers[\"test\"] = \"123\";\n          headers[\"set-cookie\"] = \"mycookie=456\";\n          partialDone();\n        });\n\n        client = new ClientSocket(`ws://localhost:${port}`, {\n          transports: [\"websocket\"],\n        });\n\n        client.transport.ws.on(\"upgrade\", (res) => {\n          expect(res.headers[\"test\"]).to.be(\"123\");\n          expect(res.headers[\"set-cookie\"].length).to.be(1);\n          expect(res.headers[\"set-cookie\"][0]).to.be(\"mycookie=456\");\n          partialDone();\n        });\n      });\n    });\n\n    it(\"should emit a single 'initial_headers' event per connection\", (done) => {\n      const partialDone = createPartialDone(done, 2);\n\n      engine = listen((port) => {\n        engine.on(\"initial_headers\", () => {\n          partialDone();\n        });\n\n        client = new ClientSocket(`ws://localhost:${port}`);\n\n        client.on(\"upgrade\", () => {\n          partialDone();\n        });\n      });\n    });\n\n    it(\"should emit several 'headers' events per connection\", function (done) {\n      if (\n        process.env.EIO_WS_ENGINE === \"eiows\" ||\n        process.env.EIO_WS_ENGINE === \"uws\"\n      ) {\n        return this.skip();\n      }\n      const partialDone = createPartialDone(done, 4);\n\n      engine = listen((port) => {\n        engine.on(\"headers\", () => {\n          partialDone();\n        });\n\n        client = new ClientSocket(`ws://localhost:${port}`);\n\n        client.on(\"upgrade\", () => {\n          partialDone();\n        });\n      });\n    });\n  });\n\n  describe(\"cors\", () => {\n    it(\"should allow CORS from the current origin (preflight request)\", (done) => {\n      listen(\n        { cors: { origin: true, headers: [\"my-header\"], credentials: true } },\n        (port) => {\n          request\n            .options(`http://localhost:${port}/engine.io/`)\n            .set(\"Origin\", \"http://engine.io\")\n            .query({ transport: \"polling\" })\n            .end((err, res) => {\n              expect(err).to.be(null);\n              expect(res.status).to.be(204);\n              expect(res.body).to.be.empty();\n              expect(res.header[\"access-control-allow-origin\"]).to.be(\n                \"http://engine.io\"\n              );\n              expect(res.header[\"access-control-allow-methods\"]).to.be(\n                \"GET,HEAD,PUT,PATCH,POST,DELETE\"\n              );\n              expect(res.header[\"access-control-allow-headers\"]).to.be(\n                \"my-header\"\n              );\n              expect(res.header[\"access-control-allow-credentials\"]).to.be(\n                \"true\"\n              );\n              done();\n            });\n        }\n      );\n    });\n\n    it(\"should allow CORS from the current origin (actual request)\", (done) => {\n      listen(\n        { cors: { origin: true, headers: [\"my-header\"], credentials: true } },\n        (port) => {\n          request\n            .get(`http://localhost:${port}/engine.io/`)\n            .set(\"Origin\", \"http://engine.io\")\n            .query({ transport: \"polling\" })\n            .end((err, res) => {\n              expect(err).to.be(null);\n              expect(res.status).to.be(200);\n              expect(res.body).to.be.empty();\n              expect(res.header[\"access-control-allow-origin\"]).to.be(\n                \"http://engine.io\"\n              );\n              expect(res.header[\"access-control-allow-methods\"]).to.be(\n                undefined\n              );\n              expect(res.header[\"access-control-allow-headers\"]).to.be(\n                undefined\n              );\n              expect(res.header[\"access-control-allow-credentials\"]).to.be(\n                \"true\"\n              );\n              done();\n            });\n        }\n      );\n    });\n\n    it(\"should disallow CORS from a bad origin\", (done) => {\n      listen(\n        {\n          cors: {\n            origin: [\"http://good-domain.com\"],\n          },\n        },\n        (port) => {\n          request\n            .options(`http://localhost:${port}/engine.io/`)\n            .set(\"Origin\", \"http://bad-domain.com\")\n            .query({ transport: \"polling\" })\n            .end((err, res) => {\n              expect(err).to.be(null);\n              expect(res.status).to.be(204);\n              expect(res.body).to.be.empty();\n              expect(res.header[\"access-control-allow-origin\"]).to.be(\n                undefined\n              );\n              expect(res.header[\"access-control-allow-credentials\"]).to.be(\n                undefined\n              );\n              done();\n            });\n        }\n      );\n    });\n\n    it(\"should forward the configuration to the cors module\", (done) => {\n      listen(\n        {\n          cors: {\n            origin: \"http://good-domain.com\",\n            methods: [\"GET\", \"PUT\", \"POST\"],\n            allowedHeaders: [\"my-header\"],\n            exposedHeaders: [\"my-exposed-header\"],\n            credentials: true,\n            maxAge: 123,\n            optionsSuccessStatus: 200,\n          },\n        },\n        (port) => {\n          request\n            .options(`http://localhost:${port}/engine.io/`)\n            .set(\"Origin\", \"http://good-domain.com\")\n            .query({ transport: \"polling\" })\n            .end((err, res) => {\n              expect(err).to.be(null);\n              expect(res.status).to.be(200);\n              expect(res.body).to.be.empty();\n              expect(res.header[\"access-control-allow-origin\"]).to.be(\n                \"http://good-domain.com\"\n              );\n              expect(res.header[\"access-control-allow-methods\"]).to.be(\n                \"GET,PUT,POST\"\n              );\n              expect(res.header[\"access-control-allow-headers\"]).to.be(\n                \"my-header\"\n              );\n              expect(res.header[\"access-control-expose-headers\"]).to.be(\n                \"my-exposed-header\"\n              );\n              expect(res.header[\"access-control-allow-credentials\"]).to.be(\n                \"true\"\n              );\n              expect(res.header[\"access-control-max-age\"]).to.be(\"123\");\n              done();\n            });\n        }\n      );\n    });\n\n    it(\"should work with CORS enabled\", (done) => {\n      engine = listen(\n        { cors: { origin: true, headers: [\"my-header\"], credentials: true } },\n        (port) => {\n          const client = new ClientSocket(`ws://localhost:${port}`, {\n            transports: [\"polling\"],\n          });\n          engine.on(\"connection\", (socket) => {\n            socket.on(\"message\", (msg) => {\n              expect(msg).to.be(\"hey\");\n              socket.send(\"hol\u00e0\");\n            });\n          });\n          client.on(\"open\", () => {\n            client.send(\"hey\");\n          });\n          client.on(\"message\", (msg) => {\n            expect(msg).to.be(\"hol\u00e0\");\n            client.close();\n            done();\n          });\n        }\n      );\n    });\n  });\n\n  describe(\"wsEngine option\", () => {\n    before(function () {\n      if (process.env.EIO_WS_ENGINE === \"uws\") {\n        this.skip();\n      }\n    });\n\n    // FIXME eiows fails to build on Node.js 18 (and has dropped support for Node.js 10)\n    it.skip(\"should allow loading of other websocket server implementation like eiows\", (done) => {\n      const engine = listen(\n        { allowUpgrades: false, wsEngine: require(\"eiows\").Server },\n        (port) => {\n          expect(engine.ws instanceof require(\"eiows\").Server).to.be.ok();\n          const socket = new ClientSocket(`ws://localhost:${port}`);\n          engine.on(\"connection\", (conn) => {\n            conn.send(\"a\");\n          });\n          socket.on(\"open\", () => {\n            socket.on(\"message\", (msg) => {\n              expect(msg).to.be(\"a\");\n              done();\n            });\n          });\n        }\n      );\n    });\n  });\n\n  describe(\"remoteAddress\", () => {\n    const POSSIBLE_VALUES = [\n      \"0000:0000:0000:0000:0000:0000:0000:0001\",\n      \"0000:0000:0000:0000:0000:ffff:7f00:0001\",\n      \"::ffff:127.0.0.1\",\n      \"::1\",\n    ];\n\n    it(\"should be defined (polling)\", (done) => {\n      const engine = listen({ transports: [\"polling\"] }, (port) => {\n        new ClientSocket(`ws://localhost:${port}`, {\n          transports: [\"polling\"],\n        });\n        engine.on(\"connection\", (socket) => {\n          expect(POSSIBLE_VALUES).to.contain(socket.remoteAddress);\n          done();\n        });\n      });\n    });\n\n    it(\"should be defined (ws)\", (done) => {\n      const engine = listen({ transports: [\"websocket\"] }, (port) => {\n        new ClientSocket(`ws://localhost:${port}`, {\n          transports: [\"websocket\"],\n        });\n        engine.on(\"connection\", (socket) => {\n          expect(POSSIBLE_VALUES).to.contain(socket.remoteAddress);\n          done();\n        });\n      });\n    });\n  });\n});\n"], "filenames": ["lib/server.ts", "lib/userver.ts", "test/server.js"], "buggy_code_start_loc": [685, 168, 13], "buggy_code_end_loc": [686, 169, 197], "fixing_code_start_loc": [685, 168, 14], "fixing_code_end_loc": [686, 169, 244], "type": "NVD-CWE-Other", "message": "Engine.IO is the implementation of transport-based cross-browser/cross-device bi-directional communication layer for Socket.IO. An uncaught exception vulnerability was introduced in version 5.1.0 and included in version 4.1.0 of the `socket.io` parent package. Older versions are not impacted. A specially crafted HTTP request can trigger an uncaught exception on the Engine.IO server, thus killing the Node.js process. This impacts all the users of the `engine.io` package, including those who use depending packages like `socket.io`. This issue was fixed in version 6.4.2 of Engine.IO. There is no known workaround except upgrading to a safe version.\n", "other": {"cve": {"id": "CVE-2023-31125", "sourceIdentifier": "security-advisories@github.com", "published": "2023-05-08T21:15:11.347", "lastModified": "2023-05-15T18:33:24.077", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Engine.IO is the implementation of transport-based cross-browser/cross-device bi-directional communication layer for Socket.IO. An uncaught exception vulnerability was introduced in version 5.1.0 and included in version 4.1.0 of the `socket.io` parent package. Older versions are not impacted. A specially crafted HTTP request can trigger an uncaught exception on the Engine.IO server, thus killing the Node.js process. This impacts all the users of the `engine.io` package, including those who use depending packages like `socket.io`. This issue was fixed in version 6.4.2 of Engine.IO. There is no known workaround except upgrading to a safe version.\n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-248"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:socket:engine.io:*:*:*:*:*:node.js:*:*", "versionStartIncluding": "5.1.0", "versionEndExcluding": "6.4.2", "matchCriteriaId": "9E9DF47D-3B77-4A1B-BE6F-03F9F532FA9D"}]}]}], "references": [{"url": "https://github.com/socketio/engine.io/commit/fc480b4f305e16fe5972cf337d055e598372dc44", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/socketio/engine.io/releases/tag/6.4.2", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/socketio/engine.io/security/advisories/GHSA-q9mw-68c2-j6m5", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/socketio/engine.io/commit/fc480b4f305e16fe5972cf337d055e598372dc44"}}