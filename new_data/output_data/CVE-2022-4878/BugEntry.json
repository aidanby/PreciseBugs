{"buggy_code": ["package utils.common;\n\nimport org.apache.commons.io.FileUtils;\n\nimport javax.inject.Singleton;\nimport java.io.*;\nimport java.nio.file.DirectoryStream;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.Enumeration;\nimport java.util.List;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipFile;\nimport java.util.zip.ZipOutputStream;\n\n/**\n * Utility class that does zipping and unzipping.\n *\n * @author Kristian Lange\n */\n@Singleton\npublic class ZipUtil {\n\n    private static final int BUFFER_SIZE = 4096;\n\n    /**\n     * File separator must be '/' and NOT the system's FILE.SEPARATOR\n     */\n    private static final String ZIP_FILE_SEPARATOR = \"/\";\n\n    /**\n     * Unzips the given File. Creates a new directory in the system's temp directory and writes the\n     * zip's content in there. The method can handle recursive unzipping of sub-directories.\n     */\n    public static File unzip(File fileToUnzip, File destDir) throws IOException {\n        FileUtils.deleteQuietly(destDir);\n        IOUtils.createDir(destDir);\n        destDir.deleteOnExit();\n\n        File file;\n        ZipFile zipFile = new ZipFile(fileToUnzip);\n        Enumeration<?> zipEnumeration = zipFile.entries();\n        while (zipEnumeration.hasMoreElements()) {\n            ZipEntry zipEntry = (ZipEntry) zipEnumeration.nextElement();\n            String fileName = zipEntry.getName();\n            file = new File(destDir, fileName);\n            if (fileName.endsWith(ZIP_FILE_SEPARATOR)) {\n                file.mkdirs();\n                continue;\n            }\n\n            File parent = file.getParentFile();\n            if (parent != null) {\n                parent.mkdirs();\n            }\n\n            InputStream inputStream = zipFile.getInputStream(zipEntry);\n            FileOutputStream fileOutputStream = new FileOutputStream(file);\n            byte[] bytes = new byte[BUFFER_SIZE];\n            int length;\n            while ((length = inputStream.read(bytes)) >= 0) {\n                fileOutputStream.write(bytes, 0, length);\n            }\n            inputStream.close();\n            fileOutputStream.close();\n        }\n        zipFile.close();\n        return destDir;\n    }\n\n    static public void zipFiles(List<Path> filesToZip, File zipFile) throws IOException {\n        BufferedOutputStream fileOutputStream = new BufferedOutputStream(new FileOutputStream(zipFile));\n        ZipOutputStream out = new ZipOutputStream(fileOutputStream);\n\n        for (Path file : filesToZip) {\n            if (Files.exists(file)) addToZip(out, file.getFileName(), file);\n        }\n\n        out.flush();\n        out.close();\n    }\n\n    private static void addToZip(final ZipOutputStream out, final Path root, final Path file) throws IOException {\n        if (Files.isDirectory(file)) {\n            addDirToZip(out, root, file);\n        } else {\n            addFileToZip(out, Paths.get(\"\"), file);\n        }\n    }\n\n    private static void addDirToZip(ZipOutputStream out, Path root, Path file) throws IOException {\n        try (DirectoryStream<Path> stream = Files.newDirectoryStream(file)) {\n            for (Path child : stream) {\n                Path entry = buildPath(root, child.getFileName());\n                if (Files.isDirectory(child)) {\n                    addToZip(out, entry, child);\n                } else {\n                    out.putNextEntry(new ZipEntry(entry.toString().replace(\"\\\\\", ZIP_FILE_SEPARATOR)));\n                    Files.copy(child, out);\n                    out.closeEntry();\n                }\n            }\n        }\n    }\n\n    static private void addFileToZip(ZipOutputStream out, Path root, Path file) throws IOException {\n        Path entry = buildPath(root, file.getFileName());\n        out.putNextEntry(new ZipEntry(entry.toString().replace(\"\\\\\", ZIP_FILE_SEPARATOR)));\n        Files.copy(file, out);\n        out.closeEntry();\n    }\n\n    private static Path buildPath(final Path root, final Path child) {\n        if (root == null) {\n            return child;\n        } else {\n            return Paths.get(root.toString(), child.toString());\n        }\n    }\n\n}\n"], "fixing_code": ["package utils.common;\n\nimport org.apache.commons.io.FileUtils;\n\nimport javax.inject.Singleton;\nimport java.io.*;\nimport java.nio.file.DirectoryStream;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.Enumeration;\nimport java.util.List;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipFile;\nimport java.util.zip.ZipOutputStream;\n\n/**\n * Utility class that does zipping and unzipping.\n *\n * @author Kristian Lange\n */\n@Singleton\npublic class ZipUtil {\n\n    private static final int BUFFER_SIZE = 4096;\n\n    /**\n     * File separator must be '/' and NOT the system's FILE.SEPARATOR\n     */\n    private static final String ZIP_FILE_SEPARATOR = \"/\";\n\n    /**\n     * Unzips the given File. Creates a new directory in the system's temp directory and writes the\n     * zip's content in there. The method can handle recursive unzipping of sub-directories.\n     */\n    public static File unzip(File fileToUnzip, File destDir) throws IOException {\n        destDir = destDir.toPath().normalize().toFile(); // normalize to prevent path traversal attacks\n        FileUtils.deleteQuietly(destDir);\n        IOUtils.createDir(destDir);\n        destDir.deleteOnExit();\n\n        File file;\n        ZipFile zipFile = new ZipFile(fileToUnzip);\n        Enumeration<?> zipEnumeration = zipFile.entries();\n        while (zipEnumeration.hasMoreElements()) {\n            ZipEntry zipEntry = (ZipEntry) zipEnumeration.nextElement();\n            String fileName = zipEntry.getName();\n            file = new File(destDir, fileName);\n            if (fileName.endsWith(ZIP_FILE_SEPARATOR)) {\n                file.mkdirs();\n                continue;\n            }\n\n            File parent = file.getParentFile();\n            if (parent != null) {\n                parent.mkdirs();\n            }\n\n            InputStream inputStream = zipFile.getInputStream(zipEntry);\n            FileOutputStream fileOutputStream = new FileOutputStream(file);\n            byte[] bytes = new byte[BUFFER_SIZE];\n            int length;\n            while ((length = inputStream.read(bytes)) >= 0) {\n                fileOutputStream.write(bytes, 0, length);\n            }\n            inputStream.close();\n            fileOutputStream.close();\n        }\n        zipFile.close();\n        return destDir;\n    }\n\n    static public void zipFiles(List<Path> filesToZip, File zipFile) throws IOException {\n        BufferedOutputStream fileOutputStream = new BufferedOutputStream(new FileOutputStream(zipFile));\n        ZipOutputStream out = new ZipOutputStream(fileOutputStream);\n\n        for (Path file : filesToZip) {\n            if (Files.exists(file)) addToZip(out, file.getFileName(), file);\n        }\n\n        out.flush();\n        out.close();\n    }\n\n    private static void addToZip(final ZipOutputStream out, final Path root, final Path file) throws IOException {\n        if (Files.isDirectory(file)) {\n            addDirToZip(out, root, file);\n        } else {\n            addFileToZip(out, Paths.get(\"\"), file);\n        }\n    }\n\n    private static void addDirToZip(ZipOutputStream out, Path root, Path file) throws IOException {\n        try (DirectoryStream<Path> stream = Files.newDirectoryStream(file)) {\n            for (Path child : stream) {\n                Path entry = buildPath(root, child.getFileName());\n                if (Files.isDirectory(child)) {\n                    addToZip(out, entry, child);\n                } else {\n                    out.putNextEntry(new ZipEntry(entry.toString().replace(\"\\\\\", ZIP_FILE_SEPARATOR)));\n                    Files.copy(child, out);\n                    out.closeEntry();\n                }\n            }\n        }\n    }\n\n    static private void addFileToZip(ZipOutputStream out, Path root, Path file) throws IOException {\n        Path entry = buildPath(root, file.getFileName());\n        out.putNextEntry(new ZipEntry(entry.toString().replace(\"\\\\\", ZIP_FILE_SEPARATOR)));\n        Files.copy(file, out);\n        out.closeEntry();\n    }\n\n    private static Path buildPath(final Path root, final Path child) {\n        if (root == null) {\n            return child;\n        } else {\n            return Paths.get(root.toString(), child.toString());\n        }\n    }\n\n}\n"], "filenames": ["modules/common/app/utils/common/ZipUtil.java"], "buggy_code_start_loc": [36], "buggy_code_end_loc": [36], "fixing_code_start_loc": [37], "fixing_code_end_loc": [38], "type": "CWE-22", "message": "A vulnerability classified as critical has been found in JATOS. Affected is the function ZipUtil of the file modules/common/app/utils/common/ZipUtil.java of the component ZIP Handler. The manipulation leads to path traversal. Upgrading to version 3.7.5-alpha is able to address this issue. The name of the patch is 2b42519f309d8164e8811392770ce604cdabb5da. It is recommended to upgrade the affected component. The identifier of this vulnerability is VDB-217548.", "other": {"cve": {"id": "CVE-2022-4878", "sourceIdentifier": "cna@vuldb.com", "published": "2023-01-06T10:15:10.507", "lastModified": "2023-01-12T13:56:09.617", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability classified as critical has been found in JATOS. Affected is the function ZipUtil of the file modules/common/app/utils/common/ZipUtil.java of the component ZIP Handler. The manipulation leads to path traversal. Upgrading to version 3.7.5-alpha is able to address this issue. The name of the patch is 2b42519f309d8164e8811392770ce604cdabb5da. It is recommended to upgrade the affected component. The identifier of this vulnerability is VDB-217548."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:A/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.1, "impactScore": 3.4}], "cvssMetricV2": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "2.0", "vectorString": "AV:A/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "ADJACENT_NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 5.2}, "baseSeverity": "MEDIUM", "exploitabilityScore": 5.1, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:jatos:jatos:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.7.5", "matchCriteriaId": "3DF47B84-943F-4A6B-8E87-0DBC639ABFC4"}]}]}], "references": [{"url": "https://github.com/JATOS/JATOS/commit/2b42519f309d8164e8811392770ce604cdabb5da", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/JATOS/JATOS/releases/tag/v3.7.5-alpha", "source": "cna@vuldb.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://vuldb.com/?ctiid.217548", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}, {"url": "https://vuldb.com/?id.217548", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/JATOS/JATOS/commit/2b42519f309d8164e8811392770ce604cdabb5da"}}