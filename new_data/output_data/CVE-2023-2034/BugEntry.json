{"buggy_code": ["<?php\n\n/**\n * This file is part of the Froxlor project.\n * Copyright (c) 2010 the Froxlor Team (see authors).\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, you can also view it online at\n * https://files.froxlor.org/misc/COPYING.txt\n *\n * @copyright  the authors\n * @author     Froxlor team <team@froxlor.org>\n * @license    https://files.froxlor.org/misc/COPYING.txt GPLv2\n */\n\nnamespace Froxlor;\n\nuse Exception;\nuse Froxlor\\Database\\Database;\nuse Froxlor\\UI\\Form;\nuse PDO;\n\n/**\n * Class SImExporter\n *\n * Import/Export settings to JSON\n */\nclass SImExporter\n{\n\t/**\n\t * settings which are not being exported\n\t *\n\t * @var array\n\t */\n\tprivate static $no_export = [\n\t\t'panel.adminmail',\n\t\t'admin.show_news_feed',\n\t\t'system.lastaccountnumber',\n\t\t'system.lastguid',\n\t\t'system.ipaddress',\n\t\t'system.last_traffic_run',\n\t\t'system.hostname',\n\t\t'system.mysql_access_host',\n\t\t'system.lastcronrun',\n\t\t'system.defaultip',\n\t\t'system.defaultsslip',\n\t\t'system.last_tasks_run',\n\t\t'system.last_archive_run',\n\t\t'system.leprivatekey',\n\t\t'system.lepublickey',\n\t\t'system.updatecheck_data',\n\t];\n\n\tpublic static function export()\n\t{\n\t\t$settings_definitions = [];\n\t\tforeach (PhpHelper::loadConfigArrayDir('./actions/admin/settings/')['groups'] as $group) {\n\t\t\tforeach ($group['fields'] as $field) {\n\t\t\t\t$settings_definitions[$field['settinggroup']][$field['varname']] = $field;\n\t\t\t}\n\t\t}\n\n\t\t$result_stmt = Database::query(\"\n\t\t\tSELECT * FROM `\" . TABLE_PANEL_SETTINGS . \"` ORDER BY `settingid` ASC\n\t\t\");\n\t\t$_data = [];\n\t\twhile ($row = $result_stmt->fetch(PDO::FETCH_ASSOC)) {\n\t\t\t$index = $row['settinggroup'] . \".\" . $row['varname'];\n\t\t\tif (!in_array($index, self::$no_export)) {\n\t\t\t\t$_data[$index] = $row['value'];\n\t\t\t}\n\n\t\t\tif (array_key_exists($row['settinggroup'], $settings_definitions) && array_key_exists($row['varname'],\n\t\t\t\t\t$settings_definitions[$row['settinggroup']])) {\n\t\t\t\t// Export image file\n\t\t\t\tif ($settings_definitions[$row['settinggroup']][$row['varname']]['type'] === \"image\") {\n\t\t\t\t\tif ($row['value'] === \"\") {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t$_data[$index . '.image_data'] = base64_encode(file_get_contents(explode('?', $row['value'],\n\t\t\t\t\t\t2)[0]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// add checksum for validation\n\t\t$_data['_sha'] = sha1(var_export($_data, true));\n\t\t$_export = json_encode($_data, JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES);\n\t\tif (!$_export) {\n\t\t\tthrow new Exception(\"Error exporting settings: \" . json_last_error_msg());\n\t\t}\n\n\t\treturn $_export;\n\t}\n\n\tpublic static function import($json_str = null)\n\t{\n\t\t// decode data\n\t\t$_data = json_decode($json_str, true);\n\t\tif ($_data) {\n\t\t\t// get validity check data\n\t\t\t$_sha = isset($_data['_sha']) ? $_data['_sha'] : false;\n\t\t\t$_version = isset($_data['panel.version']) ? $_data['panel.version'] : false;\n\t\t\t$_dbversion = isset($_data['panel.db_version']) ? $_data['panel.db_version'] : false;\n\t\t\t// check if we have everything we need\n\t\t\tif (!$_sha || !$_version || !$_dbversion) {\n\t\t\t\tthrow new Exception(\"Invalid froxlor settings data. Unable to import.\");\n\t\t\t}\n\t\t\t// validate import file\n\t\t\tunset($_data['_sha']);\n\t\t\t// compare\n\t\t\tif ($_sha != sha1(var_export($_data, true))) {\n\t\t\t\tthrow new Exception(\"SHA check of import data failed. Unable to import.\");\n\t\t\t}\n\t\t\t// do not import version info - but we need that to possibly update settings\n\t\t\t// when there were changes in the variable-name or similar\n\t\t\tunset($_data['panel.version']);\n\t\t\tunset($_data['panel.db_version']);\n\t\t\t// validate we got ssl enabled ips when ssl is enabled\n\t\t\t// otherwise deactivate it\n\t\t\tif ($_data['system.use_ssl'] == 1) {\n\t\t\t\t$result_ssl_ipsandports_stmt = Database::prepare(\"\n\t\t\t\t\tSELECT COUNT(*) as count_ssl_ip FROM `\" . TABLE_PANEL_IPSANDPORTS . \"` WHERE `ssl`='1'\n\t\t\t\t\");\n\t\t\t\t$result = Database::pexecute_first($result_ssl_ipsandports_stmt);\n\t\t\t\tif ($result['count_ssl_ip'] <= 0) {\n\t\t\t\t\t// no ssl-ip -> deactivate\n\t\t\t\t\t$_data['system.use_ssl'] = 0;\n\t\t\t\t\t// deactivate other ssl-related settings\n\t\t\t\t\t$_data['system.leenabled'] = 0;\n\t\t\t\t\t$_data['system.le_froxlor_enabled'] = 0;\n\t\t\t\t\t$_data['system.le_froxlor_redirect'] = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$form_data = [];\n\t\t\t$image_data = [];\n\t\t\t// read in all current settings\n\t\t\t$current_settings = Settings::getAll();\n\t\t\tforeach ($current_settings as $setting_group => $setting) {\n\t\t\t\tforeach ($setting as $varname => $value) {\n\t\t\t\t\t// set all group/varname:values which are not in the import file\n\t\t\t\t\tif (!array_key_exists($setting_group . '.' . $varname, $_data)) {\n\t\t\t\t\t\t$_data[$setting_group . '.' . $varname] = $value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// re-format the array-key for Form::processForm\n\t\t\tforeach ($_data as $key => $value) {\n\t\t\t\t$index_split = explode('.', $key, 3);\n\t\t\t\tif (isset($index_split[2]) && $index_split[2] === 'image_data' && !empty($_data[$index_split[0] . '.' . $index_split[1]])) {\n\t\t\t\t\t$image_data[$key] = $value;\n\t\t\t\t} else {\n\t\t\t\t\t$form_data[str_replace(\".\", \"_\", $key)] = $value;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// store new data\n\t\t\t$settings_data = PhpHelper::loadConfigArrayDir(Froxlor::getInstallDir() . '/actions/admin/settings/');\n\t\t\tSettings::loadSettingsInto($settings_data);\n\n\t\t\tif (Form::processForm($settings_data, $form_data, [], null, true)) {\n\t\t\t\t// save to DB\n\t\t\t\tSettings::Flush();\n\n\t\t\t\t// Process image_data and save it\n\t\t\t\tif (count($image_data) > 0) {\n\t\t\t\t\tforeach ($image_data as $index => $value) {\n\t\t\t\t\t\t$index_split = explode('.', $index, 3);\n\t\t\t\t\t\t$path = Froxlor::getInstallDir() . '/img/';\n\t\t\t\t\t\tif (!is_dir($path) && !mkdir($path, 0775)) {\n\t\t\t\t\t\t\tthrow new Exception(\"img directory does not exist and cannot be created\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Make sure we can write to the upload directory\n\t\t\t\t\t\tif (!is_writable($path)) {\n\t\t\t\t\t\t\tif (!chmod($path, 0775)) {\n\t\t\t\t\t\t\t\tthrow new Exception(\"Cannot write to img directory\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t$img_data = base64_decode($value);\n\t\t\t\t\t\t$img_filename = Froxlor::getInstallDir() . '/' . str_replace('../', '',\n\t\t\t\t\t\t\t\texplode('?', $_data[$index_split[0] . '.' . $index_split[1]], 2)[0]);\n\n\t\t\t\t\t\tfile_put_contents($img_filename, $img_data);\n\n\t\t\t\t\t\tif (function_exists('finfo_open')) {\n\t\t\t\t\t\t\t$finfo = finfo_open(FILEINFO_MIME_TYPE);\n\t\t\t\t\t\t\t$mimetype = finfo_file($finfo, $img_filename);\n\t\t\t\t\t\t\tfinfo_close($finfo);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$mimetype = mime_content_type($img_filename);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (empty($mimetype)) {\n\t\t\t\t\t\t\t$mimetype = 'application/octet-stream';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!in_array($mimetype, ['image/jpeg', 'image/jpg', 'image/png', 'image/gif'])) {\n\t\t\t\t\t\t\t@unlink($img_filename);\n\t\t\t\t\t\t\tthrow new Exception(\"Uploaded file is not a valid image\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t$spl = explode('.', $img_filename);\n\t\t\t\t\t\t$file_extension = strtolower(array_pop($spl));\n\t\t\t\t\t\tunset($spl);\n\n\t\t\t\t\t\tif (!in_array($file_extension, [\n\t\t\t\t\t\t\t'jpeg',\n\t\t\t\t\t\t\t'jpg',\n\t\t\t\t\t\t\t'png',\n\t\t\t\t\t\t\t'gif'\n\t\t\t\t\t\t])) {\n\t\t\t\t\t\t\t@unlink($img_filename);\n\t\t\t\t\t\t\tthrow new Exception(\"Invalid file-extension, use one of: jpeg, jpg, png, gif\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tSettings::Set($index, $value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// all good\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tthrow new Exception(\"Importing settings failed\");\n\t\t\t}\n\t\t}\n\t\tthrow new Exception(\"Invalid JSON data: \" . json_last_error_msg());\n\t}\n}\n", "<?php\n\n/**\n * This file is part of the Froxlor project.\n * Copyright (c) 2010 the Froxlor Team (see authors).\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, you can also view it online at\n * https://files.froxlor.org/misc/COPYING.txt\n *\n * @copyright  the authors\n * @author     Froxlor team <team@froxlor.org>\n * @license    https://files.froxlor.org/misc/COPYING.txt GPLv2\n */\n\nnamespace Froxlor\\Settings;\n\nuse Exception;\nuse Froxlor\\Cron\\TaskId;\nuse Froxlor\\Database\\Database;\nuse Froxlor\\Database\\DbManager;\nuse Froxlor\\FileDir;\nuse Froxlor\\Froxlor;\nuse Froxlor\\Idna\\IdnaWrapper;\nuse Froxlor\\PhpHelper;\nuse Froxlor\\Settings;\nuse Froxlor\\System\\Cronjob;\nuse Froxlor\\System\\IPTools;\nuse PDO;\n\nclass Store\n{\n\n\tpublic static function storeSettingClearCertificates($fieldname, $fielddata, $newfieldvalue)\n\t{\n\t\t$returnvalue = self::storeSettingField($fieldname, $fielddata, $newfieldvalue);\n\n\t\tif ($returnvalue !== false && is_array($fielddata) && isset($fielddata['settinggroup']) && $fielddata['settinggroup'] == 'system' && isset($fielddata['varname']) && $fielddata['varname'] == 'le_froxlor_enabled' && $newfieldvalue == '0') {\n\t\t\tDatabase::query(\"\n\t\t\t\tDELETE FROM `\" . TABLE_PANEL_DOMAIN_SSL_SETTINGS . \"` WHERE `domainid` = '0'\n\t\t\t\");\n\t\t}\n\n\t\treturn $returnvalue;\n\t}\n\n\tpublic static function storeSettingField($fieldname, $fielddata, $newfieldvalue)\n\t{\n\t\tif (is_array($fielddata) && isset($fielddata['settinggroup']) && $fielddata['settinggroup'] != '' && isset($fielddata['varname']) && $fielddata['varname'] != '') {\n\t\t\tif (Settings::Set($fielddata['settinggroup'] . '.' . $fielddata['varname'], $newfieldvalue) !== false) {\n\t\t\t\t/*\n\t\t\t\t * when fielddata[cronmodule] is set, this means enable/disable a cronjob\n\t\t\t\t */\n\t\t\t\tif (isset($fielddata['cronmodule']) && $fielddata['cronmodule'] != '') {\n\t\t\t\t\tCronjob::toggleCronStatus($fielddata['cronmodule'], $newfieldvalue);\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * satisfy dependencies\n\t\t\t\t */\n\t\t\t\tif (isset($fielddata['dependency']) && is_array($fielddata['dependency'])) {\n\t\t\t\t\tif ((int)$fielddata['dependency']['onlyif'] == (int)$newfieldvalue) {\n\t\t\t\t\t\tself::storeSettingField($fielddata['dependency']['fieldname'], $fielddata['dependency']['fielddata'], $newfieldvalue);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn [\n\t\t\t\t\t$fielddata['settinggroup'] . '.' . $fielddata['varname'] => $newfieldvalue\n\t\t\t\t];\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tpublic static function storeSettingDefaultIp($fieldname, $fielddata, $newfieldvalue)\n\t{\n\t\t$defaultips_old = Settings::Get('system.defaultip');\n\n\t\t$returnvalue = self::storeSettingField($fieldname, $fielddata, $newfieldvalue);\n\n\t\tif ($returnvalue !== false && is_array($fielddata) && isset($fielddata['settinggroup']) && $fielddata['settinggroup'] == 'system' && isset($fielddata['varname']) && $fielddata['varname'] == 'defaultip') {\n\t\t\tself::updateStdSubdomainDefaultIp($newfieldvalue, $defaultips_old);\n\t\t}\n\n\t\treturn $returnvalue;\n\t}\n\n\tprivate static function updateStdSubdomainDefaultIp($newfieldvalue, $defaultips_old)\n\t{\n\t\t// update standard-subdomain of customer if exists\n\t\t$customerstddomains_result_stmt = Database::prepare(\"\n\t\t\tSELECT `standardsubdomain` FROM `\" . TABLE_PANEL_CUSTOMERS . \"` WHERE `standardsubdomain` <> '0'\n\t\t\");\n\t\tDatabase::pexecute($customerstddomains_result_stmt);\n\n\t\t$ids = [];\n\t\twhile ($customerstddomains_row = $customerstddomains_result_stmt->fetch(PDO::FETCH_ASSOC)) {\n\t\t\t$ids[] = (int)$customerstddomains_row['standardsubdomain'];\n\t\t}\n\n\t\tif (count($ids) > 0) {\n\t\t\t$defaultips_new = explode(',', $newfieldvalue);\n\n\t\t\tif (!empty($defaultips_old) && !empty($newfieldvalue)) {\n\t\t\t\t$in_value = $defaultips_old . \", \" . $newfieldvalue;\n\t\t\t} elseif (!empty($defaultips_old) && empty($newfieldvalue)) {\n\t\t\t\t$in_value = $defaultips_old;\n\t\t\t} else {\n\t\t\t\t$in_value = $newfieldvalue;\n\t\t\t}\n\n\t\t\t// Delete the existing mappings linking to default IPs\n\t\t\t$del_stmt = Database::prepare(\"\n\t\t\t\tDELETE FROM `\" . TABLE_DOMAINTOIP . \"`\n\t\t\t\tWHERE `id_domain` IN (\" . implode(', ', $ids) . \")\n\t\t\t\tAND `id_ipandports` IN (\" . $in_value . \")\n\t\t\t\");\n\t\t\tDatabase::pexecute($del_stmt);\n\n\t\t\tif (count($defaultips_new) > 0) {\n\t\t\t\t// Insert the new mappings\n\t\t\t\t$ins_stmt = Database::prepare(\"\n\t\t\t\t\tINSERT INTO `\" . TABLE_DOMAINTOIP . \"`\n\t\t\t\t\tSET `id_domain` = :domainid, `id_ipandports` = :ipandportid\n\t\t\t\t\");\n\n\t\t\t\tforeach ($ids as $id) {\n\t\t\t\t\tforeach ($defaultips_new as $defaultip_new) {\n\t\t\t\t\t\tDatabase::pexecute($ins_stmt, [\n\t\t\t\t\t\t\t'domainid' => $id,\n\t\t\t\t\t\t\t'ipandportid' => $defaultip_new\n\t\t\t\t\t\t]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static function storeSettingDefaultSslIp($fieldname, $fielddata, $newfieldvalue)\n\t{\n\t\t$defaultips_old = Settings::Get('system.defaultsslip');\n\n\t\t$returnvalue = self::storeSettingField($fieldname, $fielddata, $newfieldvalue);\n\n\t\tif ($returnvalue !== false && is_array($fielddata) && isset($fielddata['settinggroup']) && $fielddata['settinggroup'] == 'system' && isset($fielddata['varname']) && $fielddata['varname'] == 'defaultsslip') {\n\t\t\tself::updateStdSubdomainDefaultIp($newfieldvalue, $defaultips_old);\n\t\t}\n\n\t\treturn $returnvalue;\n\t}\n\n\t/**\n\t * updates the setting for the default panel-theme\n\t * and also the user themes (customers and admins) if\n\t * the changing of themes is disallowed for them\n\t *\n\t * @param string $fieldname\n\t * @param array $fielddata\n\t * @param mixed $newfieldvalue\n\t *\n\t * @return boolean|array\n\t */\n\tpublic static function storeSettingDefaultTheme($fieldname, $fielddata, $newfieldvalue)\n\t{\n\t\t// first save the setting itself\n\t\t$returnvalue = self::storeSettingField($fieldname, $fielddata, $newfieldvalue);\n\n\t\tif ($returnvalue !== false && is_array($fielddata) && isset($fielddata['settinggroup']) && $fielddata['settinggroup'] == 'panel' && isset($fielddata['varname']) && $fielddata['varname'] == 'default_theme') {\n\t\t\t// now, if changing themes is disabled we manually set\n\t\t\t// the new theme (customers and admin, depending on settings)\n\t\t\tif (Settings::Get('panel.allow_theme_change_customer') == '0') {\n\t\t\t\t$upd_stmt = Database::prepare(\"\n\t\t\t\t\tUPDATE `\" . TABLE_PANEL_CUSTOMERS . \"` SET `theme` = :theme\n\t\t\t\t\");\n\t\t\t\tDatabase::pexecute($upd_stmt, [\n\t\t\t\t\t'theme' => $newfieldvalue\n\t\t\t\t]);\n\t\t\t}\n\t\t\tif (Settings::Get('panel.allow_theme_change_admin') == '0') {\n\t\t\t\t$upd_stmt = Database::prepare(\"\n\t\t\t\t\tUPDATE `\" . TABLE_PANEL_ADMINS . \"` SET `theme` = :theme\n\t\t\t\t\");\n\t\t\t\tDatabase::pexecute($upd_stmt, [\n\t\t\t\t\t'theme' => $newfieldvalue\n\t\t\t\t]);\n\t\t\t}\n\t\t}\n\n\t\treturn $returnvalue;\n\t}\n\n\tpublic static function storeSettingFieldInsertBindTask($fieldname, $fielddata, $newfieldvalue)\n\t{\n\t\t// first save the setting itself\n\t\t$returnvalue = self::storeSettingField($fieldname, $fielddata, $newfieldvalue);\n\n\t\tif ($returnvalue !== false) {\n\t\t\tCronjob::inserttask(TaskId::REBUILD_DNS);\n\t\t}\n\t\treturn $returnvalue;\n\t}\n\n\tpublic static function storeSettingHostname($fieldname, $fielddata, $newfieldvalue)\n\t{\n\t\t$returnvalue = self::storeSettingField($fieldname, $fielddata, $newfieldvalue);\n\n\t\tif ($returnvalue !== false && is_array($fielddata) && isset($fielddata['settinggroup']) && $fielddata['settinggroup'] == 'system' && isset($fielddata['varname']) && ($fielddata['varname'] == 'hostname' || $fielddata['varname'] == 'stdsubdomain')) {\n\t\t\t$idna_convert = new IdnaWrapper();\n\t\t\t$newfieldvalue = $idna_convert->encode($newfieldvalue);\n\n\t\t\tif (($fielddata['varname'] == 'hostname' && Settings::Get('system.stdsubdomain') == '') || $fielddata['varname'] == 'stdsubdomain') {\n\t\t\t\tif ($fielddata['varname'] == 'stdsubdomain' && $newfieldvalue == '') {\n\t\t\t\t\t// clear field, reset stdsubdomain to system-hostname\n\t\t\t\t\t$oldhost = $idna_convert->encode(Settings::Get('system.stdsubdomain'));\n\t\t\t\t\t$newhost = $idna_convert->encode(Settings::Get('system.hostname'));\n\t\t\t\t} elseif ($fielddata['varname'] == 'stdsubdomain' && Settings::Get('system.stdsubdomain') == '') {\n\t\t\t\t\t// former std-subdomain was system-hostname\n\t\t\t\t\t$oldhost = $idna_convert->encode(Settings::Get('system.hostname'));\n\t\t\t\t\t$newhost = $newfieldvalue;\n\t\t\t\t} elseif ($fielddata['varname'] == 'stdsubdomain') {\n\t\t\t\t\t// std-subdomain just changed\n\t\t\t\t\t$oldhost = $idna_convert->encode(Settings::Get('system.stdsubdomain'));\n\t\t\t\t\t$newhost = $newfieldvalue;\n\t\t\t\t} elseif ($fielddata['varname'] == 'hostname' && Settings::Get('system.stdsubdomain') == '') {\n\t\t\t\t\t// system-hostname has changed and no system-stdsubdomain is not set\n\t\t\t\t\t$oldhost = $idna_convert->encode(Settings::Get('system.hostname'));\n\t\t\t\t\t$newhost = $newfieldvalue;\n\t\t\t\t}\n\n\t\t\t\t$customerstddomains_result_stmt = Database::prepare(\"\n\t\t\t\t\tSELECT `standardsubdomain` FROM `\" . TABLE_PANEL_CUSTOMERS . \"` WHERE `standardsubdomain` <> '0'\n\t\t\t\t\");\n\t\t\t\tDatabase::pexecute($customerstddomains_result_stmt);\n\n\t\t\t\t$ids = [];\n\n\t\t\t\twhile ($customerstddomains_row = $customerstddomains_result_stmt->fetch(PDO::FETCH_ASSOC)) {\n\t\t\t\t\t$ids[] = (int)$customerstddomains_row['standardsubdomain'];\n\t\t\t\t}\n\n\t\t\t\tif (count($ids) > 0) {\n\t\t\t\t\t$upd_stmt = Database::prepare(\"\n\t\t\t\t\t\tUPDATE `\" . TABLE_PANEL_DOMAINS . \"` SET\n\t\t\t\t\t\t`domain` = REPLACE(`domain`, :host, :newval)\n\t\t\t\t\t\tWHERE `id` IN ('\" . implode(', ', $ids) . \"')\n\t\t\t\t\t\");\n\t\t\t\t\tDatabase::pexecute($upd_stmt, [\n\t\t\t\t\t\t'host' => $oldhost,\n\t\t\t\t\t\t'newval' => $newhost\n\t\t\t\t\t]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn $returnvalue;\n\t}\n\n\tpublic static function storeSettingIpAddress($fieldname, $fielddata, $newfieldvalue)\n\t{\n\t\t$returnvalue = self::storeSettingField($fieldname, $fielddata, $newfieldvalue);\n\n\t\tif ($returnvalue !== false && is_array($fielddata) && isset($fielddata['settinggroup']) && $fielddata['settinggroup'] == 'system' && isset($fielddata['varname']) && $fielddata['varname'] == 'ipaddress') {\n\t\t\t$mysql_access_host_array = array_map('trim', explode(',', Settings::Get('system.mysql_access_host')));\n\t\t\t$mysql_access_host_array[] = $newfieldvalue;\n\t\t\t$mysql_access_host_array = array_unique(PhpHelper::arrayTrim($mysql_access_host_array));\n\t\t\tDbManager::correctMysqlUsers($mysql_access_host_array);\n\t\t\t$mysql_access_host = implode(',', $mysql_access_host_array);\n\t\t\tSettings::Set('system.mysql_access_host', $mysql_access_host);\n\t\t}\n\n\t\treturn $returnvalue;\n\t}\n\n\tpublic static function storeSettingMysqlAccessHost($fieldname, $fielddata, $newfieldvalue)\n\t{\n\t\t$ips = $newfieldvalue;\n\t\t// Convert cidr to netmask for mysql, if needed be\n\t\tif (strpos($ips, ',') !== false) {\n\t\t\t$ips = explode(',', $ips);\n\t\t}\n\t\tif (is_array($ips) && count($ips) > 0) {\n\t\t\t$newfieldvalue = [];\n\t\t\tforeach ($ips as $ip) {\n\t\t\t\t$org_ip = $ip;\n\t\t\t\t$ip_cidr = explode(\"/\", $ip);\n\t\t\t\tif (count($ip_cidr) === 2) {\n\t\t\t\t\t$ip = $ip_cidr[0];\n\t\t\t\t\tif (strlen($ip_cidr[1]) <= 2) {\n\t\t\t\t\t\t$ip_cidr[1] = IPTools::cidr2NetmaskAddr($org_ip);\n\t\t\t\t\t}\n\t\t\t\t\t$newfieldvalue[] = $ip . '/' . $ip_cidr[1];\n\t\t\t\t} else {\n\t\t\t\t\t$newfieldvalue[] = $org_ip;\n\t\t\t\t}\n\t\t\t}\n\t\t\t$newfieldvalue = implode(',', $newfieldvalue);\n\t\t}\n\t\t$returnvalue = self::storeSettingField($fieldname, $fielddata, $newfieldvalue);\n\n\t\tif ($returnvalue !== false && is_array($fielddata) && isset($fielddata['settinggroup']) && $fielddata['settinggroup'] == 'system' && isset($fielddata['varname']) && $fielddata['varname'] == 'mysql_access_host') {\n\t\t\t$mysql_access_host_array = array_map('trim', explode(',', $newfieldvalue));\n\n\t\t\tif (in_array('127.0.0.1', $mysql_access_host_array) && !in_array('localhost', $mysql_access_host_array)) {\n\t\t\t\t$mysql_access_host_array[] = 'localhost';\n\t\t\t}\n\n\t\t\tif (!in_array('127.0.0.1', $mysql_access_host_array) && in_array('localhost', $mysql_access_host_array)) {\n\t\t\t\t$mysql_access_host_array[] = '127.0.0.1';\n\t\t\t}\n\n\t\t\t// be aware that ipv6 addresses are enclosed in [ ] when passed here\n\t\t\t$mysql_access_host_array = array_map([\n\t\t\t\t'\\\\Froxlor\\\\Settings\\\\Store',\n\t\t\t\t'cleanMySQLAccessHost'\n\t\t\t], $mysql_access_host_array);\n\n\t\t\t$mysql_access_host_array = array_unique(PhpHelper::arrayTrim($mysql_access_host_array));\n\t\t\t$newfieldvalue = implode(',', $mysql_access_host_array);\n\t\t\tDbManager::correctMysqlUsers($mysql_access_host_array);\n\t\t\t$mysql_access_host = implode(',', $mysql_access_host_array);\n\t\t\tSettings::Set('system.mysql_access_host', $mysql_access_host);\n\t\t}\n\n\t\treturn $returnvalue;\n\t}\n\n\tpublic static function storeSettingResetCatchall($fieldname, $fielddata, $newfieldvalue)\n\t{\n\t\t$returnvalue = self::storeSettingField($fieldname, $fielddata, $newfieldvalue);\n\n\t\tif ($returnvalue !== false && is_array($fielddata) && isset($fielddata['settinggroup']) && $fielddata['settinggroup'] == 'catchall' && isset($fielddata['varname']) && $fielddata['varname'] == 'catchall_enabled' && $newfieldvalue == '0') {\n\t\t\tDatabase::query(\"\n\t\t\t\tUPDATE `\" . TABLE_MAIL_VIRTUAL . \"` SET `iscatchall` = '0' WHERE `iscatchall` = '1'\n\t\t\t\");\n\t\t}\n\n\t\treturn $returnvalue;\n\t}\n\n\t/**\n\t * Whenever the webserver- / FCGID- or FPM-user gets updated\n\t * we need to update ftp_groups accordingly\n\t */\n\tpublic static function storeSettingWebserverFcgidFpmUser($fieldname, $fielddata, $newfieldvalue)\n\t{\n\t\tif (is_array($fielddata) && isset($fielddata['settinggroup']) && isset($fielddata['varname'])) {\n\t\t\t$update_user = null;\n\n\t\t\t// webserver\n\t\t\tif ($fielddata['settinggroup'] == 'system' && $fielddata['varname'] == 'httpuser') {\n\t\t\t\t$update_user = Settings::Get('system.httpuser');\n\t\t\t}\n\n\t\t\t// fcgid\n\t\t\tif ($fielddata['settinggroup'] == 'system' && $fielddata['varname'] == 'mod_fcgid_httpuser') {\n\t\t\t\t$update_user = Settings::Get('system.mod_fcgid_httpuser');\n\t\t\t}\n\n\t\t\t// webserver\n\t\t\tif ($fielddata['settinggroup'] == 'phpfpm' && $fielddata['varname'] == 'vhost_httpuser') {\n\t\t\t\t$update_user = Settings::Get('phpfpm.vhost_httpuser');\n\t\t\t}\n\n\t\t\t$returnvalue = self::storeSettingField($fieldname, $fielddata, $newfieldvalue);\n\n\t\t\tif ($returnvalue !== false) {\n\t\t\t\t/**\n\t\t\t\t * only update if anything changed\n\t\t\t\t */\n\t\t\t\tif ($update_user != null && $newfieldvalue != $update_user) {\n\t\t\t\t\t$upd_stmt = Database::prepare(\"UPDATE `\" . TABLE_FTP_GROUPS . \"` SET `members` = REPLACE(`members`, :olduser, :newuser)\");\n\t\t\t\t\tDatabase::pexecute($upd_stmt, [\n\t\t\t\t\t\t'olduser' => $update_user,\n\t\t\t\t\t\t'newuser' => $newfieldvalue\n\t\t\t\t\t]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn $returnvalue;\n\t}\n\n\tpublic static function storeSettingImage($fieldname, $fielddata)\n\t{\n\t\tif (isset($fielddata['settinggroup'], $fielddata['varname']) && is_array($fielddata) && $fielddata['settinggroup'] !== '' && $fielddata['varname'] !== '') {\n\t\t\t$save_to = null;\n\t\t\t$path = Froxlor::getInstallDir() . '/img/';\n\t\t\t$path = FileDir::makeCorrectDir($path);\n\n\t\t\t// New file?\n\t\t\tif (isset($_FILES[$fieldname]) && $_FILES[$fieldname]['tmp_name']) {\n\t\t\t\t// Make sure upload directory exists\n\t\t\t\tif (!is_dir($path) && !mkdir($path, 0775)) {\n\t\t\t\t\tthrow new Exception(\"img directory does not exist and cannot be created\");\n\t\t\t\t}\n\n\t\t\t\t// Make sure we can write to the upload directory\n\t\t\t\tif (!is_writable($path)) {\n\t\t\t\t\tif (!chmod($path, 0775)) {\n\t\t\t\t\t\tthrow new Exception(\"Cannot write to img directory\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Make sure mime-type matches an image\n\t\t\t\tif (function_exists('finfo_open')) {\n\t\t\t\t\t$finfo = finfo_open(FILEINFO_MIME_TYPE);\n\t\t\t\t\t$mimetype = finfo_file($finfo, $_FILES[$fieldname]['tmp_name']);\n\t\t\t\t\tfinfo_close($finfo);\n\t\t\t\t} else {\n\t\t\t\t\t$mimetype = mime_content_type($_FILES[$fieldname]['tmp_name']);\n\t\t\t\t}\n\t\t\t\tif (empty($mimetype)) {\n\t\t\t\t\t$mimetype = 'application/octet-stream';\n\t\t\t\t}\n\t\t\t\tif (!in_array($mimetype, ['image/jpeg', 'image/jpg', 'image/png', 'image/gif'])) {\n\t\t\t\t\tthrow new \\Exception(\"Uploaded file is not a valid image\");\n\t\t\t\t}\n\n\t\t\t\t// Determine file extension\n\t\t\t\t$spl = explode('.', $_FILES[$fieldname]['name']);\n\t\t\t\t$file_extension = strtolower(array_pop($spl));\n\t\t\t\tunset($spl);\n\n\t\t\t\tif (!in_array($file_extension, [\n\t\t\t\t\t'jpeg',\n\t\t\t\t\t'jpg',\n\t\t\t\t\t'png',\n\t\t\t\t\t'gif'\n\t\t\t\t])) {\n\t\t\t\t\tthrow new Exception(\"Invalid file-extension, use one of: jpeg, jpg, png, gif\");\n\t\t\t\t}\n\n\t\t\t\t// Move file\n\t\t\t\tif (!move_uploaded_file($_FILES[$fieldname]['tmp_name'], $path . $fielddata['image_name'] . '.' . $file_extension)) {\n\t\t\t\t\tthrow new Exception(\"Unable to save image to img folder\");\n\t\t\t\t}\n\n\t\t\t\t$save_to = 'img/' . $fielddata['image_name'] . '.' . $file_extension . '?v=' . time();\n\t\t\t}\n\n\t\t\t// Delete file?\n\t\t\tif ($fielddata['value'] !== \"\" && array_key_exists($fieldname . '_delete', $_POST) && $_POST[$fieldname . '_delete']) {\n\t\t\t\t@unlink(Froxlor::getInstallDir() . '/' . explode('?', $fielddata['value'], 2)[0]);\n\t\t\t\t$save_to = '';\n\t\t\t}\n\n\t\t\t// Nothing changed\n\t\t\tif ($save_to === null) {\n\t\t\t\treturn [\n\t\t\t\t\t$fielddata['settinggroup'] . '.' . $fielddata['varname'] => $fielddata['value']\n\t\t\t\t];\n\t\t\t}\n\n\t\t\tif (Settings::Set($fielddata['settinggroup'] . '.' . $fielddata['varname'], $save_to) === false) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn [\n\t\t\t\t$fielddata['settinggroup'] . '.' . $fielddata['varname'] => $save_to\n\t\t\t];\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tprivate static function cleanMySQLAccessHost($value)\n\t{\n\t\tif (substr($value, 0, 1) == '[' && substr($value, -1) == ']') {\n\t\t\treturn substr($value, 1, -1);\n\t\t}\n\t\treturn $value;\n\t}\n\n\tpublic static function storeSettingUpdateTrafficTool($fieldname, $fielddata, $newfieldvalue)\n\t{\n\t\t$returnvalue = self::storeSettingField($fieldname, $fielddata, $newfieldvalue);\n\n\t\tif ($returnvalue !== false && is_array($fielddata) && isset($fielddata['settinggroup']) && $fielddata['settinggroup'] == 'system' && isset($fielddata['varname']) && $fielddata['varname'] == 'traffictool' && $newfieldvalue != $fielddata['value']) {\n\t\t\t$oldpath = '/' . $fielddata['value'] . '/';\n\t\t\t$newpath = '/' . $newfieldvalue . '/';\n\t\t\t$sel_stmt = Database::prepare(\"SELECT * FROM `\" . TABLE_PANEL_HTPASSWDS . \"` WHERE `path` LIKE :oldpath\");\n\t\t\t$upd_stmt = Database::prepare(\"\n\t\t\t\tUPDATE `\" . TABLE_PANEL_HTPASSWDS . \"` SET `path` = :newpath WHERE `id` = :id\n\t\t\t\");\n\t\t\tDatabase::pexecute($sel_stmt, [\n\t\t\t\t'oldpath' => '%' . $oldpath\n\t\t\t]);\n\t\t\twhile ($entry = $sel_stmt->fetch(\\PDO::FETCH_ASSOC)) {\n\t\t\t\t$full_path = str_replace($oldpath, $newpath, $entry['path']);\n\t\t\t\t$eid = (int)$entry['id'];\n\t\t\t\tDatabase::pexecute($upd_stmt, [\n\t\t\t\t\t'newpath' => $full_path,\n\t\t\t\t\t'id' => $eid\n\t\t\t\t]);\n\t\t\t}\n\t\t}\n\n\t\treturn $returnvalue;\n\t}\n}\n", "<?php\n\n/**\n * This file is part of the Froxlor project.\n * Copyright (c) 2010 the Froxlor Team (see authors).\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, you can also view it online at\n * https://files.froxlor.org/misc/COPYING.txt\n *\n * @copyright  the authors\n * @author     Froxlor team <team@froxlor.org>\n * @license    https://files.froxlor.org/misc/COPYING.txt GPLv2\n */\n\nnamespace Froxlor\\Validate;\n\nuse Exception;\nuse Froxlor\\Database\\Database;\nuse Froxlor\\FroxlorLogger;\nuse Froxlor\\Idna\\IdnaWrapper;\nuse Froxlor\\System\\IPTools;\nuse Froxlor\\UI\\Response;\n\nclass Validate\n{\n\n\tconst REGEX_DIR = '/^|(\\/[\\w-]+)+$/';\n\n\tconst REGEX_PORT = '/^(([1-9])|([1-9][0-9])|([1-9][0-9][0-9])|([1-9][0-9][0-9][0-9])|([1-5][0-9][0-9][0-9][0-9])|(6[0-4][0-9][0-9][0-9])|(65[0-4][0-9][0-9])|(655[0-2][0-9])|(6553[0-5]))$/Di';\n\n\tconst REGEX_CONF_TEXT = '/^[^\\0]*$/';\n\n\tconst REGEX_DESC_TEXT = '/^[^\\0\\r\\n<>]*$/';\n\n\tconst REGEX_YYYY_MM_DD = '/^\\d{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/';\n\n\t/**\n\t * Validates the given string by matching against the pattern, prints an error on failure and exits.\n\t * If the default pattern is used and the string does not match, we try to replace the 'bad' values and log the action.\n\t *\n\t * @param string $str the string to be tested (user input)\n\t * @param string $fieldname to be used in error messages\n\t * @param string $pattern the regular expression to be used for testing\n\t * @param string|array $lng id for the error\n\t * @param string|array $emptydefault fallback value\n\t * @param bool $throw_exception whether to display error or throw an exception, default false\n\t *\n\t * @return string|void the clean string or error\n\t * @throws Exception\n\t */\n\tpublic static function validate(\n\t\tstring $str,\n\t\tstring $fieldname,\n\t\tstring $pattern = '',\n\t\t$lng = '',\n\t\t$emptydefault = [],\n\t\tbool $throw_exception = false\n\t) {\n\t\tif (!is_array($emptydefault)) {\n\t\t\t$emptydefault_array = [\n\t\t\t\t$emptydefault\n\t\t\t];\n\t\t\tunset($emptydefault);\n\t\t\t$emptydefault = $emptydefault_array;\n\t\t\tunset($emptydefault_array);\n\t\t}\n\n\t\t// Check if the $str is one of the values which represent the default for an 'empty' value\n\t\tif (is_array($emptydefault) && !empty($emptydefault) && in_array($str, $emptydefault)) {\n\t\t\treturn $str;\n\t\t}\n\n\t\tif ($pattern == '') {\n\t\t\t$pattern = '/^[^\\r\\n\\t\\f\\0]*$/D';\n\n\t\t\tif (!preg_match($pattern, $str)) {\n\t\t\t\t// Allows letters a-z, digits, space (\\\\040), hyphen (\\\\-), underscore (\\\\_) and backslash (\\\\\\\\),\n\t\t\t\t// everything else is removed from the string.\n\t\t\t\t$allowed = \"/[^a-z0-9\\\\040\\\\.\\\\-\\\\_\\\\\\\\]/i\";\n\t\t\t\t$str = preg_replace($allowed, \"\", $str);\n\t\t\t\t$log = FroxlorLogger::getInstanceOf();\n\t\t\t\t$log->logAction(FroxlorLogger::USR_ACTION, LOG_WARNING, \"cleaned bad formatted string (\" . $str . \")\");\n\t\t\t}\n\t\t}\n\n\t\tif (preg_match($pattern, $str)) {\n\t\t\treturn $str;\n\t\t}\n\n\t\tif ($lng == '') {\n\t\t\t$lng = 'stringformaterror';\n\t\t}\n\n\t\tResponse::standardError($lng, $fieldname, $throw_exception);\n\t}\n\n\t/**\n\t * Checks whether it is a valid ip\n\t *\n\t * @param string $ip ip-address to check\n\t * @param bool $return_bool whether to return bool or call \\Froxlor\\UI\\Response::standard_error()\n\t * @param string $lng index for error-message (if $return_bool is false)\n\t * @param bool $allow_localhost whether to allow 127.0.0.1\n\t * @param bool $allow_priv whether to allow private network addresses\n\t * @param bool $allow_cidr whether to allow CIDR values e.g. 10.10.10.10/16\n\t * @param bool $cidr_as_netmask whether to format CIDR notation to netmask notation\n\t * @param bool $throw_exception whether to throw an exception on failure\n\t *\n\t * @return string|bool|void ip address on success, false on failure (or nothing if error is displayed)\n\t * @throws Exception\n\t */\n\tpublic static function validate_ip2(\n\t\tstring $ip,\n\t\tbool $return_bool = false,\n\t\tstring $lng = 'invalidip',\n\t\tbool $allow_localhost = false,\n\t\tbool $allow_priv = false,\n\t\tbool $allow_cidr = false,\n\t\tbool $cidr_as_netmask = false,\n\t\tbool $throw_exception = false\n\t) {\n\t\t$cidr = \"\";\n\t\tif ($allow_cidr) {\n\t\t\t$org_ip = $ip;\n\t\t\t$ip_cidr = explode(\"/\", $ip);\n\t\t\tif (count($ip_cidr) === 2) {\n\t\t\t\t$cidr_range_max = 32;\n\t\t\t\tif (IPTools::is_ipv6($ip_cidr[0])) {\n\t\t\t\t\t$cidr_range_max = 128;\n\t\t\t\t}\n\t\t\t\tif (strlen($ip_cidr[1]) <= 3 && in_array((int)$ip_cidr[1], array_values(range(1, $cidr_range_max)),\n\t\t\t\t\t\ttrue) === false) {\n\t\t\t\t\tif ($return_bool) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tResponse::standardError($lng, $ip, $throw_exception);\n\t\t\t\t}\n\t\t\t\tif ($cidr_as_netmask && IPTools::is_ipv6($ip_cidr[0])) {\n\t\t\t\t\t// MySQL does not handle CIDR of IPv6 addresses, return error\n\t\t\t\t\tif ($return_bool) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tResponse::standardError($lng, $ip, $throw_exception);\n\t\t\t\t}\n\t\t\t\t$ip = $ip_cidr[0];\n\t\t\t\tif ($cidr_as_netmask && strlen($ip_cidr[1]) <= 3) {\n\t\t\t\t\t$ip_cidr[1] = IPTools::cidr2NetmaskAddr($org_ip);\n\t\t\t\t}\n\t\t\t\t$cidr = \"/\" . $ip_cidr[1];\n\t\t\t} else {\n\t\t\t\t$ip = $org_ip;\n\t\t\t}\n\t\t} elseif (strpos($ip, \"/\") !== false) {\n\t\t\tif ($return_bool) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tResponse::standardError($lng, $ip, $throw_exception);\n\t\t}\n\n\t\t$filter_lan = $allow_priv ? FILTER_FLAG_NO_RES_RANGE : (FILTER_FLAG_NO_RES_RANGE | FILTER_FLAG_NO_PRIV_RANGE);\n\n\t\tif ((filter_var($ip, FILTER_VALIDATE_IP, FILTER_FLAG_IPV6) || filter_var($ip, FILTER_VALIDATE_IP,\n\t\t\t\t\tFILTER_FLAG_IPV4)) && filter_var($ip, FILTER_VALIDATE_IP, $filter_lan)) {\n\t\t\treturn $ip . $cidr;\n\t\t}\n\n\t\t// special case where localhost ip is allowed (mysql-access-hosts for example)\n\t\tif ($allow_localhost && $ip == '127.0.0.1') {\n\t\t\treturn $ip . $cidr;\n\t\t}\n\n\t\tif ($return_bool) {\n\t\t\treturn false;\n\t\t}\n\t\tResponse::standardError($lng, $ip, $throw_exception);\n\t}\n\n\t/**\n\t * Returns whether a URL is in a correct format or not\n\t *\n\t * @param string $url URL to be tested\n\t * @param bool $allow_private_ip optional, default is false\n\t *\n\t * @return bool\n\t */\n\tpublic static function validateUrl(string $url, bool $allow_private_ip = false): bool\n\t{\n\t\tif (strtolower(substr($url, 0, 7)) != \"http://\" && strtolower(substr($url, 0, 8)) != \"https://\") {\n\t\t\t$url = 'http://' . $url;\n\t\t}\n\n\t\t// needs converting\n\t\ttry {\n\t\t\t$idna_convert = new IdnaWrapper();\n\t\t\t$url = $idna_convert->encode($url);\n\t\t} catch (Exception $e) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ($allow_private_ip) {\n\t\t\t$pattern = '%^(?:(?:https?):\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\x{00a1}-\\x{ffff}0-9]+-?)*[a-z\\x{00a1}-\\x{ffff}0-9]+)(?:\\.(?:[a-z\\x{00a1}-\\x{ffff}0-9]+-?)*[a-z\\x{00a1}-\\x{ffff}0-9]+)*(?:\\.(?:[a-z\\x{00a1}-\\x{ffff}]{2,})))(?::\\d{2,5})?(?:\\/[^\\s]*)?$%iuS';\n\t\t} else {\n\t\t\t$pattern = '%^(?:(?:https?):\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?!10(?:\\.\\d{1,3}){3})(?!127(?:\\.\\d{1,3}){3})(?!169\\.254(?:\\.\\d{1,3}){2})(?!192\\.168(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\x{00a1}-\\x{ffff}0-9]+-?)*[a-z\\x{00a1}-\\x{ffff}0-9]+)(?:\\.(?:[a-z\\x{00a1}-\\x{ffff}0-9]+-?)*[a-z\\x{00a1}-\\x{ffff}0-9]+)*(?:\\.(?:[a-z\\x{00a1}-\\x{ffff}]{2,})))(?::\\d{2,5})?(?:/[^\\s]*)?$%iuS';\n\t\t}\n\t\tif (preg_match($pattern, $url)) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Check if the submitted string is a valid domainname\n\t *\n\t * @param string $domainname The domainname which should be checked.\n\t * @param bool $allow_underscore optional if true, allowes the underscore character in a domain label (DKIM etc.)\n\t *\n\t * @return string|boolean the domain-name if the domain is valid, false otherwise\n\t */\n\tpublic static function validateDomain(string $domainname, bool $allow_underscore = false)\n\t{\n\t\t$char_validation = '([a-z\\d](-*[a-z\\d])*)(\\.?([a-z\\d](-*[a-z\\d])*))*\\.(xn\\-\\-)?([a-z\\d])+';\n\t\tif ($allow_underscore) {\n\t\t\t$char_validation = '([a-z\\d\\_](-*[a-z\\d\\_])*)(\\.([a-z\\d\\_](-*[a-z\\d])*))*(\\.?([a-z\\d](-*[a-z\\d])*))+\\.(xn\\-\\-)?([a-z\\d])+';\n\t\t}\n\n\t\t// valid chars check && overall length check && length of each label\n\t\tif (preg_match(\"/^\" . $char_validation . \"$/i\", $domainname) && preg_match(\"/^.{1,253}$/\",\n\t\t\t\t$domainname) && preg_match(\"/^[^\\.]{1,63}(\\.[^\\.]{1,63})*$/\", $domainname)) {\n\t\t\treturn $domainname;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * validate a local-hostname by regex\n\t *\n\t * @param string $hostname\n\t *\n\t * @return string|boolean hostname on success, else false\n\t */\n\tpublic static function validateLocalHostname(string $hostname)\n\t{\n\t\t$pattern = '/^[a-z0-9][a-z0-9\\-]{0,62}$/i';\n\t\tif (preg_match($pattern, $hostname)) {\n\t\t\treturn $hostname;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Returns if an emailaddress is in correct format or not\n\t *\n\t * @param string $email The email address to check\n\t *\n\t * @return mixed\n\t */\n\tpublic static function validateEmail(string $email)\n\t{\n\t\t$email = strtolower($email);\n\t\t// as of php-7.1\n\t\tif (defined('FILTER_FLAG_EMAIL_UNICODE')) {\n\t\t\treturn filter_var($email, FILTER_VALIDATE_EMAIL, FILTER_FLAG_EMAIL_UNICODE);\n\t\t}\n\t\treturn filter_var($email, FILTER_VALIDATE_EMAIL);\n\t}\n\n\t/**\n\t * Returns if a username is in correct format or not.\n\t *\n\t * @param string $username The username to check\n\t * @param bool $unix_names optional, default true, checks whether it must be UNIX compatible\n\t * @param int $mysql_max optional, number of max mysql username characters, default empty\n\t *\n\t * @return bool\n\t */\n\tpublic static function validateUsername(string $username, bool $unix_names = true, int $mysql_max = 0): bool\n\t{\n\t\tif (empty($mysql_max) || $mysql_max <= 0) {\n\t\t\t$mysql_max = Database::getSqlUsernameLength() - 1;\n\t\t} else {\n\t\t\t$mysql_max--;\n\t\t}\n\t\tif (!$unix_names) {\n\t\t\tif (strpos($username, '--') === false) {\n\t\t\t\treturn (preg_match('/^[a-z][a-z0-9\\-_]{0,' . $mysql_max . '}[a-z0-9]{1}$/Di', $username) != false);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\treturn (preg_match('/^[a-z][a-z0-9]{0,' . $mysql_max . '}$/Di', $username) != false);\n\t}\n\n\t/**\n\t * validate sql interval string\n\t *\n\t * @param string $interval\n\t *\n\t * @return bool\n\t */\n\tpublic static function validateSqlInterval(string $interval = ''): bool\n\t{\n\t\tif (!empty($interval) && strstr($interval, ' ') !== false) {\n\t\t\t/*\n\t\t\t * [0] = ([0-9]+)\n\t\t\t * [1] = valid SQL-Interval expression\n\t\t\t */\n\t\t\t$valid_expr = [\n\t\t\t\t'SECOND',\n\t\t\t\t'MINUTE',\n\t\t\t\t'HOUR',\n\t\t\t\t'DAY',\n\t\t\t\t'WEEK',\n\t\t\t\t'MONTH',\n\t\t\t\t'YEAR'\n\t\t\t];\n\n\t\t\t$interval_parts = explode(' ', $interval);\n\n\t\t\tif (count($interval_parts) == 2 && preg_match('/[0-9]+/',\n\t\t\t\t\t$interval_parts[0]) && in_array(strtoupper($interval_parts[1]), $valid_expr)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}\n"], "fixing_code": ["<?php\n\n/**\n * This file is part of the Froxlor project.\n * Copyright (c) 2010 the Froxlor Team (see authors).\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, you can also view it online at\n * https://files.froxlor.org/misc/COPYING.txt\n *\n * @copyright  the authors\n * @author     Froxlor team <team@froxlor.org>\n * @license    https://files.froxlor.org/misc/COPYING.txt GPLv2\n */\n\nnamespace Froxlor;\n\nuse Exception;\nuse Froxlor\\Database\\Database;\nuse Froxlor\\UI\\Form;\nuse Froxlor\\Validate\\Validate;\nuse PDO;\n\n/**\n * Class SImExporter\n *\n * Import/Export settings to JSON\n */\nclass SImExporter\n{\n\t/**\n\t * settings which are not being exported\n\t *\n\t * @var array\n\t */\n\tprivate static $no_export = [\n\t\t'panel.adminmail',\n\t\t'admin.show_news_feed',\n\t\t'system.lastaccountnumber',\n\t\t'system.lastguid',\n\t\t'system.ipaddress',\n\t\t'system.last_traffic_run',\n\t\t'system.hostname',\n\t\t'system.mysql_access_host',\n\t\t'system.lastcronrun',\n\t\t'system.defaultip',\n\t\t'system.defaultsslip',\n\t\t'system.last_tasks_run',\n\t\t'system.last_archive_run',\n\t\t'system.leprivatekey',\n\t\t'system.lepublickey',\n\t\t'system.updatecheck_data',\n\t];\n\n\tpublic static function export()\n\t{\n\t\t$settings_definitions = [];\n\t\tforeach (PhpHelper::loadConfigArrayDir('./actions/admin/settings/')['groups'] as $group) {\n\t\t\tforeach ($group['fields'] as $field) {\n\t\t\t\t$settings_definitions[$field['settinggroup']][$field['varname']] = $field;\n\t\t\t}\n\t\t}\n\n\t\t$result_stmt = Database::query(\"\n\t\t\tSELECT * FROM `\" . TABLE_PANEL_SETTINGS . \"` ORDER BY `settingid` ASC\n\t\t\");\n\t\t$_data = [];\n\t\twhile ($row = $result_stmt->fetch(PDO::FETCH_ASSOC)) {\n\t\t\t$index = $row['settinggroup'] . \".\" . $row['varname'];\n\t\t\tif (!in_array($index, self::$no_export)) {\n\t\t\t\t$_data[$index] = $row['value'];\n\t\t\t}\n\n\t\t\tif (array_key_exists($row['settinggroup'], $settings_definitions) && array_key_exists($row['varname'],\n\t\t\t\t\t$settings_definitions[$row['settinggroup']])) {\n\t\t\t\t// Export image file\n\t\t\t\tif ($settings_definitions[$row['settinggroup']][$row['varname']]['type'] === \"image\") {\n\t\t\t\t\tif ($row['value'] === \"\") {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t$_data[$index . '.image_data'] = base64_encode(file_get_contents(explode('?', $row['value'],\n\t\t\t\t\t\t2)[0]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// add checksum for validation\n\t\t$_data['_sha'] = sha1(var_export($_data, true));\n\t\t$_export = json_encode($_data, JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES);\n\t\tif (!$_export) {\n\t\t\tthrow new Exception(\"Error exporting settings: \" . json_last_error_msg());\n\t\t}\n\n\t\treturn $_export;\n\t}\n\n\tpublic static function import($json_str = null)\n\t{\n\t\t// decode data\n\t\t$_data = json_decode($json_str, true);\n\t\tif ($_data) {\n\t\t\t// get validity check data\n\t\t\t$_sha = isset($_data['_sha']) ? $_data['_sha'] : false;\n\t\t\t$_version = isset($_data['panel.version']) ? $_data['panel.version'] : false;\n\t\t\t$_dbversion = isset($_data['panel.db_version']) ? $_data['panel.db_version'] : false;\n\t\t\t// check if we have everything we need\n\t\t\tif (!$_sha || !$_version || !$_dbversion) {\n\t\t\t\tthrow new Exception(\"Invalid froxlor settings data. Unable to import.\");\n\t\t\t}\n\t\t\t// validate import file\n\t\t\tunset($_data['_sha']);\n\t\t\t// compare\n\t\t\tif ($_sha != sha1(var_export($_data, true))) {\n\t\t\t\tthrow new Exception(\"SHA check of import data failed. Unable to import.\");\n\t\t\t}\n\t\t\t// do not import version info - but we need that to possibly update settings\n\t\t\t// when there were changes in the variable-name or similar\n\t\t\tunset($_data['panel.version']);\n\t\t\tunset($_data['panel.db_version']);\n\t\t\t// validate we got ssl enabled ips when ssl is enabled\n\t\t\t// otherwise deactivate it\n\t\t\tif ($_data['system.use_ssl'] == 1) {\n\t\t\t\t$result_ssl_ipsandports_stmt = Database::prepare(\"\n\t\t\t\t\tSELECT COUNT(*) as count_ssl_ip FROM `\" . TABLE_PANEL_IPSANDPORTS . \"` WHERE `ssl`='1'\n\t\t\t\t\");\n\t\t\t\t$result = Database::pexecute_first($result_ssl_ipsandports_stmt);\n\t\t\t\tif ($result['count_ssl_ip'] <= 0) {\n\t\t\t\t\t// no ssl-ip -> deactivate\n\t\t\t\t\t$_data['system.use_ssl'] = 0;\n\t\t\t\t\t// deactivate other ssl-related settings\n\t\t\t\t\t$_data['system.leenabled'] = 0;\n\t\t\t\t\t$_data['system.le_froxlor_enabled'] = 0;\n\t\t\t\t\t$_data['system.le_froxlor_redirect'] = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$form_data = [];\n\t\t\t$image_data = [];\n\t\t\t// read in all current settings\n\t\t\t$current_settings = Settings::getAll();\n\t\t\tforeach ($current_settings as $setting_group => $setting) {\n\t\t\t\tforeach ($setting as $varname => $value) {\n\t\t\t\t\t// set all group/varname:values which are not in the import file\n\t\t\t\t\tif (!array_key_exists($setting_group . '.' . $varname, $_data)) {\n\t\t\t\t\t\t$_data[$setting_group . '.' . $varname] = $value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// re-format the array-key for Form::processForm\n\t\t\tforeach ($_data as $key => $value) {\n\t\t\t\t$index_split = explode('.', $key, 3);\n\t\t\t\tif (!isset($current_settings[$index_split[0]][$index_split[1]])) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (isset($index_split[2]) && $index_split[2] === 'image_data' && !empty($_data[$index_split[0] . '.' . $index_split[1]])) {\n\t\t\t\t\t$image_data[$key] = $value;\n\t\t\t\t} else {\n\t\t\t\t\t$form_data[str_replace(\".\", \"_\", $key)] = $value;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// store new data\n\t\t\t$settings_data = PhpHelper::loadConfigArrayDir(Froxlor::getInstallDir() . '/actions/admin/settings/');\n\t\t\tSettings::loadSettingsInto($settings_data);\n\n\t\t\tif (Form::processForm($settings_data, $form_data, [], null, true)) {\n\t\t\t\t// save to DB\n\t\t\t\tSettings::Flush();\n\n\t\t\t\t// Process image_data and save it\n\t\t\t\tif (count($image_data) > 0) {\n\t\t\t\t\tforeach ($image_data as $index => $value) {\n\t\t\t\t\t\t$index_split = explode('.', $index, 3);\n\t\t\t\t\t\t$path = Froxlor::getInstallDir() . '/img/';\n\t\t\t\t\t\tif (!is_dir($path) && !mkdir($path, 0775)) {\n\t\t\t\t\t\t\tthrow new Exception(\"img directory does not exist and cannot be created\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Make sure we can write to the upload directory\n\t\t\t\t\t\tif (!is_writable($path)) {\n\t\t\t\t\t\t\tif (!chmod($path, 0775)) {\n\t\t\t\t\t\t\t\tthrow new Exception(\"Cannot write to img directory\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (Validate::validateBase64Image($value)) {\n\t\t\t\t\t\t\t$img_data = base64_decode($value);\n\t\t\t\t\t\t\t$img_filename = explode('?', $_data[$index_split[0] . '.' . $index_split[1]], 2)[0];\n\n\t\t\t\t\t\t\t$spl = explode('.', $img_filename);\n\t\t\t\t\t\t\t$file_extension = strtolower(array_pop($spl));\n\t\t\t\t\t\t\tunset($spl);\n\n\t\t\t\t\t\t\tif (!in_array($file_extension, [\n\t\t\t\t\t\t\t\t'jpeg',\n\t\t\t\t\t\t\t\t'jpg',\n\t\t\t\t\t\t\t\t'png',\n\t\t\t\t\t\t\t\t'gif'\n\t\t\t\t\t\t\t])) {\n\t\t\t\t\t\t\t\tthrow new Exception(\"Invalid file-extension, use one of: jpeg, jpg, png, gif\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t$img_filename = 'img/' . bin2hex(random_bytes(16)) . '.' . $file_extension;\n\t\t\t\t\t\t\tfile_put_contents(Froxlor::getInstallDir() . '/' . $img_filename, $img_data);\n\t\t\t\t\t\t\t$img_index = $index_split[0].'.'.$index_split[1];\n\t\t\t\t\t\t\tSettings::Set($img_index, $img_filename . '?v=' . time());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// all good\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tthrow new Exception(\"Importing settings failed\");\n\t\t\t}\n\t\t}\n\t\tthrow new Exception(\"Invalid JSON data: \" . json_last_error_msg());\n\t}\n}\n", "<?php\n\n/**\n * This file is part of the Froxlor project.\n * Copyright (c) 2010 the Froxlor Team (see authors).\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, you can also view it online at\n * https://files.froxlor.org/misc/COPYING.txt\n *\n * @copyright  the authors\n * @author     Froxlor team <team@froxlor.org>\n * @license    https://files.froxlor.org/misc/COPYING.txt GPLv2\n */\n\nnamespace Froxlor\\Settings;\n\nuse Exception;\nuse Froxlor\\Cron\\TaskId;\nuse Froxlor\\Database\\Database;\nuse Froxlor\\Database\\DbManager;\nuse Froxlor\\FileDir;\nuse Froxlor\\Froxlor;\nuse Froxlor\\Idna\\IdnaWrapper;\nuse Froxlor\\PhpHelper;\nuse Froxlor\\Settings;\nuse Froxlor\\System\\Cronjob;\nuse Froxlor\\System\\IPTools;\nuse Froxlor\\Validate\\Validate;\nuse PDO;\n\nclass Store\n{\n\n\tpublic static function storeSettingClearCertificates($fieldname, $fielddata, $newfieldvalue)\n\t{\n\t\t$returnvalue = self::storeSettingField($fieldname, $fielddata, $newfieldvalue);\n\n\t\tif ($returnvalue !== false && is_array($fielddata) && isset($fielddata['settinggroup']) && $fielddata['settinggroup'] == 'system' && isset($fielddata['varname']) && $fielddata['varname'] == 'le_froxlor_enabled' && $newfieldvalue == '0') {\n\t\t\tDatabase::query(\"\n\t\t\t\tDELETE FROM `\" . TABLE_PANEL_DOMAIN_SSL_SETTINGS . \"` WHERE `domainid` = '0'\n\t\t\t\");\n\t\t}\n\n\t\treturn $returnvalue;\n\t}\n\n\tpublic static function storeSettingField($fieldname, $fielddata, $newfieldvalue)\n\t{\n\t\tif (is_array($fielddata) && isset($fielddata['settinggroup']) && $fielddata['settinggroup'] != '' && isset($fielddata['varname']) && $fielddata['varname'] != '') {\n\t\t\tif (Settings::Set($fielddata['settinggroup'] . '.' . $fielddata['varname'], $newfieldvalue) !== false) {\n\t\t\t\t/*\n\t\t\t\t * when fielddata[cronmodule] is set, this means enable/disable a cronjob\n\t\t\t\t */\n\t\t\t\tif (isset($fielddata['cronmodule']) && $fielddata['cronmodule'] != '') {\n\t\t\t\t\tCronjob::toggleCronStatus($fielddata['cronmodule'], $newfieldvalue);\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * satisfy dependencies\n\t\t\t\t */\n\t\t\t\tif (isset($fielddata['dependency']) && is_array($fielddata['dependency'])) {\n\t\t\t\t\tif ((int)$fielddata['dependency']['onlyif'] == (int)$newfieldvalue) {\n\t\t\t\t\t\tself::storeSettingField($fielddata['dependency']['fieldname'], $fielddata['dependency']['fielddata'], $newfieldvalue);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn [\n\t\t\t\t\t$fielddata['settinggroup'] . '.' . $fielddata['varname'] => $newfieldvalue\n\t\t\t\t];\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tpublic static function storeSettingDefaultIp($fieldname, $fielddata, $newfieldvalue)\n\t{\n\t\t$defaultips_old = Settings::Get('system.defaultip');\n\n\t\t$returnvalue = self::storeSettingField($fieldname, $fielddata, $newfieldvalue);\n\n\t\tif ($returnvalue !== false && is_array($fielddata) && isset($fielddata['settinggroup']) && $fielddata['settinggroup'] == 'system' && isset($fielddata['varname']) && $fielddata['varname'] == 'defaultip') {\n\t\t\tself::updateStdSubdomainDefaultIp($newfieldvalue, $defaultips_old);\n\t\t}\n\n\t\treturn $returnvalue;\n\t}\n\n\tprivate static function updateStdSubdomainDefaultIp($newfieldvalue, $defaultips_old)\n\t{\n\t\t// update standard-subdomain of customer if exists\n\t\t$customerstddomains_result_stmt = Database::prepare(\"\n\t\t\tSELECT `standardsubdomain` FROM `\" . TABLE_PANEL_CUSTOMERS . \"` WHERE `standardsubdomain` <> '0'\n\t\t\");\n\t\tDatabase::pexecute($customerstddomains_result_stmt);\n\n\t\t$ids = [];\n\t\twhile ($customerstddomains_row = $customerstddomains_result_stmt->fetch(PDO::FETCH_ASSOC)) {\n\t\t\t$ids[] = (int)$customerstddomains_row['standardsubdomain'];\n\t\t}\n\n\t\tif (count($ids) > 0) {\n\t\t\t$defaultips_new = explode(',', $newfieldvalue);\n\n\t\t\tif (!empty($defaultips_old) && !empty($newfieldvalue)) {\n\t\t\t\t$in_value = $defaultips_old . \", \" . $newfieldvalue;\n\t\t\t} elseif (!empty($defaultips_old) && empty($newfieldvalue)) {\n\t\t\t\t$in_value = $defaultips_old;\n\t\t\t} else {\n\t\t\t\t$in_value = $newfieldvalue;\n\t\t\t}\n\n\t\t\t// Delete the existing mappings linking to default IPs\n\t\t\t$del_stmt = Database::prepare(\"\n\t\t\t\tDELETE FROM `\" . TABLE_DOMAINTOIP . \"`\n\t\t\t\tWHERE `id_domain` IN (\" . implode(', ', $ids) . \")\n\t\t\t\tAND `id_ipandports` IN (\" . $in_value . \")\n\t\t\t\");\n\t\t\tDatabase::pexecute($del_stmt);\n\n\t\t\tif (count($defaultips_new) > 0) {\n\t\t\t\t// Insert the new mappings\n\t\t\t\t$ins_stmt = Database::prepare(\"\n\t\t\t\t\tINSERT INTO `\" . TABLE_DOMAINTOIP . \"`\n\t\t\t\t\tSET `id_domain` = :domainid, `id_ipandports` = :ipandportid\n\t\t\t\t\");\n\n\t\t\t\tforeach ($ids as $id) {\n\t\t\t\t\tforeach ($defaultips_new as $defaultip_new) {\n\t\t\t\t\t\tDatabase::pexecute($ins_stmt, [\n\t\t\t\t\t\t\t'domainid' => $id,\n\t\t\t\t\t\t\t'ipandportid' => $defaultip_new\n\t\t\t\t\t\t]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static function storeSettingDefaultSslIp($fieldname, $fielddata, $newfieldvalue)\n\t{\n\t\t$defaultips_old = Settings::Get('system.defaultsslip');\n\n\t\t$returnvalue = self::storeSettingField($fieldname, $fielddata, $newfieldvalue);\n\n\t\tif ($returnvalue !== false && is_array($fielddata) && isset($fielddata['settinggroup']) && $fielddata['settinggroup'] == 'system' && isset($fielddata['varname']) && $fielddata['varname'] == 'defaultsslip') {\n\t\t\tself::updateStdSubdomainDefaultIp($newfieldvalue, $defaultips_old);\n\t\t}\n\n\t\treturn $returnvalue;\n\t}\n\n\t/**\n\t * updates the setting for the default panel-theme\n\t * and also the user themes (customers and admins) if\n\t * the changing of themes is disallowed for them\n\t *\n\t * @param string $fieldname\n\t * @param array $fielddata\n\t * @param mixed $newfieldvalue\n\t *\n\t * @return boolean|array\n\t */\n\tpublic static function storeSettingDefaultTheme($fieldname, $fielddata, $newfieldvalue)\n\t{\n\t\t// first save the setting itself\n\t\t$returnvalue = self::storeSettingField($fieldname, $fielddata, $newfieldvalue);\n\n\t\tif ($returnvalue !== false && is_array($fielddata) && isset($fielddata['settinggroup']) && $fielddata['settinggroup'] == 'panel' && isset($fielddata['varname']) && $fielddata['varname'] == 'default_theme') {\n\t\t\t// now, if changing themes is disabled we manually set\n\t\t\t// the new theme (customers and admin, depending on settings)\n\t\t\tif (Settings::Get('panel.allow_theme_change_customer') == '0') {\n\t\t\t\t$upd_stmt = Database::prepare(\"\n\t\t\t\t\tUPDATE `\" . TABLE_PANEL_CUSTOMERS . \"` SET `theme` = :theme\n\t\t\t\t\");\n\t\t\t\tDatabase::pexecute($upd_stmt, [\n\t\t\t\t\t'theme' => $newfieldvalue\n\t\t\t\t]);\n\t\t\t}\n\t\t\tif (Settings::Get('panel.allow_theme_change_admin') == '0') {\n\t\t\t\t$upd_stmt = Database::prepare(\"\n\t\t\t\t\tUPDATE `\" . TABLE_PANEL_ADMINS . \"` SET `theme` = :theme\n\t\t\t\t\");\n\t\t\t\tDatabase::pexecute($upd_stmt, [\n\t\t\t\t\t'theme' => $newfieldvalue\n\t\t\t\t]);\n\t\t\t}\n\t\t}\n\n\t\treturn $returnvalue;\n\t}\n\n\tpublic static function storeSettingFieldInsertBindTask($fieldname, $fielddata, $newfieldvalue)\n\t{\n\t\t// first save the setting itself\n\t\t$returnvalue = self::storeSettingField($fieldname, $fielddata, $newfieldvalue);\n\n\t\tif ($returnvalue !== false) {\n\t\t\tCronjob::inserttask(TaskId::REBUILD_DNS);\n\t\t}\n\t\treturn $returnvalue;\n\t}\n\n\tpublic static function storeSettingHostname($fieldname, $fielddata, $newfieldvalue)\n\t{\n\t\t$returnvalue = self::storeSettingField($fieldname, $fielddata, $newfieldvalue);\n\n\t\tif ($returnvalue !== false && is_array($fielddata) && isset($fielddata['settinggroup']) && $fielddata['settinggroup'] == 'system' && isset($fielddata['varname']) && ($fielddata['varname'] == 'hostname' || $fielddata['varname'] == 'stdsubdomain')) {\n\t\t\t$idna_convert = new IdnaWrapper();\n\t\t\t$newfieldvalue = $idna_convert->encode($newfieldvalue);\n\n\t\t\tif (($fielddata['varname'] == 'hostname' && Settings::Get('system.stdsubdomain') == '') || $fielddata['varname'] == 'stdsubdomain') {\n\t\t\t\tif ($fielddata['varname'] == 'stdsubdomain' && $newfieldvalue == '') {\n\t\t\t\t\t// clear field, reset stdsubdomain to system-hostname\n\t\t\t\t\t$oldhost = $idna_convert->encode(Settings::Get('system.stdsubdomain'));\n\t\t\t\t\t$newhost = $idna_convert->encode(Settings::Get('system.hostname'));\n\t\t\t\t} elseif ($fielddata['varname'] == 'stdsubdomain' && Settings::Get('system.stdsubdomain') == '') {\n\t\t\t\t\t// former std-subdomain was system-hostname\n\t\t\t\t\t$oldhost = $idna_convert->encode(Settings::Get('system.hostname'));\n\t\t\t\t\t$newhost = $newfieldvalue;\n\t\t\t\t} elseif ($fielddata['varname'] == 'stdsubdomain') {\n\t\t\t\t\t// std-subdomain just changed\n\t\t\t\t\t$oldhost = $idna_convert->encode(Settings::Get('system.stdsubdomain'));\n\t\t\t\t\t$newhost = $newfieldvalue;\n\t\t\t\t} elseif ($fielddata['varname'] == 'hostname' && Settings::Get('system.stdsubdomain') == '') {\n\t\t\t\t\t// system-hostname has changed and no system-stdsubdomain is not set\n\t\t\t\t\t$oldhost = $idna_convert->encode(Settings::Get('system.hostname'));\n\t\t\t\t\t$newhost = $newfieldvalue;\n\t\t\t\t}\n\n\t\t\t\t$customerstddomains_result_stmt = Database::prepare(\"\n\t\t\t\t\tSELECT `standardsubdomain` FROM `\" . TABLE_PANEL_CUSTOMERS . \"` WHERE `standardsubdomain` <> '0'\n\t\t\t\t\");\n\t\t\t\tDatabase::pexecute($customerstddomains_result_stmt);\n\n\t\t\t\t$ids = [];\n\n\t\t\t\twhile ($customerstddomains_row = $customerstddomains_result_stmt->fetch(PDO::FETCH_ASSOC)) {\n\t\t\t\t\t$ids[] = (int)$customerstddomains_row['standardsubdomain'];\n\t\t\t\t}\n\n\t\t\t\tif (count($ids) > 0) {\n\t\t\t\t\t$upd_stmt = Database::prepare(\"\n\t\t\t\t\t\tUPDATE `\" . TABLE_PANEL_DOMAINS . \"` SET\n\t\t\t\t\t\t`domain` = REPLACE(`domain`, :host, :newval)\n\t\t\t\t\t\tWHERE `id` IN ('\" . implode(', ', $ids) . \"')\n\t\t\t\t\t\");\n\t\t\t\t\tDatabase::pexecute($upd_stmt, [\n\t\t\t\t\t\t'host' => $oldhost,\n\t\t\t\t\t\t'newval' => $newhost\n\t\t\t\t\t]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn $returnvalue;\n\t}\n\n\tpublic static function storeSettingIpAddress($fieldname, $fielddata, $newfieldvalue)\n\t{\n\t\t$returnvalue = self::storeSettingField($fieldname, $fielddata, $newfieldvalue);\n\n\t\tif ($returnvalue !== false && is_array($fielddata) && isset($fielddata['settinggroup']) && $fielddata['settinggroup'] == 'system' && isset($fielddata['varname']) && $fielddata['varname'] == 'ipaddress') {\n\t\t\t$mysql_access_host_array = array_map('trim', explode(',', Settings::Get('system.mysql_access_host')));\n\t\t\t$mysql_access_host_array[] = $newfieldvalue;\n\t\t\t$mysql_access_host_array = array_unique(PhpHelper::arrayTrim($mysql_access_host_array));\n\t\t\tDbManager::correctMysqlUsers($mysql_access_host_array);\n\t\t\t$mysql_access_host = implode(',', $mysql_access_host_array);\n\t\t\tSettings::Set('system.mysql_access_host', $mysql_access_host);\n\t\t}\n\n\t\treturn $returnvalue;\n\t}\n\n\tpublic static function storeSettingMysqlAccessHost($fieldname, $fielddata, $newfieldvalue)\n\t{\n\t\t$ips = $newfieldvalue;\n\t\t// Convert cidr to netmask for mysql, if needed be\n\t\tif (strpos($ips, ',') !== false) {\n\t\t\t$ips = explode(',', $ips);\n\t\t}\n\t\tif (is_array($ips) && count($ips) > 0) {\n\t\t\t$newfieldvalue = [];\n\t\t\tforeach ($ips as $ip) {\n\t\t\t\t$org_ip = $ip;\n\t\t\t\t$ip_cidr = explode(\"/\", $ip);\n\t\t\t\tif (count($ip_cidr) === 2) {\n\t\t\t\t\t$ip = $ip_cidr[0];\n\t\t\t\t\tif (strlen($ip_cidr[1]) <= 2) {\n\t\t\t\t\t\t$ip_cidr[1] = IPTools::cidr2NetmaskAddr($org_ip);\n\t\t\t\t\t}\n\t\t\t\t\t$newfieldvalue[] = $ip . '/' . $ip_cidr[1];\n\t\t\t\t} else {\n\t\t\t\t\t$newfieldvalue[] = $org_ip;\n\t\t\t\t}\n\t\t\t}\n\t\t\t$newfieldvalue = implode(',', $newfieldvalue);\n\t\t}\n\t\t$returnvalue = self::storeSettingField($fieldname, $fielddata, $newfieldvalue);\n\n\t\tif ($returnvalue !== false && is_array($fielddata) && isset($fielddata['settinggroup']) && $fielddata['settinggroup'] == 'system' && isset($fielddata['varname']) && $fielddata['varname'] == 'mysql_access_host') {\n\t\t\t$mysql_access_host_array = array_map('trim', explode(',', $newfieldvalue));\n\n\t\t\tif (in_array('127.0.0.1', $mysql_access_host_array) && !in_array('localhost', $mysql_access_host_array)) {\n\t\t\t\t$mysql_access_host_array[] = 'localhost';\n\t\t\t}\n\n\t\t\tif (!in_array('127.0.0.1', $mysql_access_host_array) && in_array('localhost', $mysql_access_host_array)) {\n\t\t\t\t$mysql_access_host_array[] = '127.0.0.1';\n\t\t\t}\n\n\t\t\t// be aware that ipv6 addresses are enclosed in [ ] when passed here\n\t\t\t$mysql_access_host_array = array_map([\n\t\t\t\t'\\\\Froxlor\\\\Settings\\\\Store',\n\t\t\t\t'cleanMySQLAccessHost'\n\t\t\t], $mysql_access_host_array);\n\n\t\t\t$mysql_access_host_array = array_unique(PhpHelper::arrayTrim($mysql_access_host_array));\n\t\t\t$newfieldvalue = implode(',', $mysql_access_host_array);\n\t\t\tDbManager::correctMysqlUsers($mysql_access_host_array);\n\t\t\t$mysql_access_host = implode(',', $mysql_access_host_array);\n\t\t\tSettings::Set('system.mysql_access_host', $mysql_access_host);\n\t\t}\n\n\t\treturn $returnvalue;\n\t}\n\n\tpublic static function storeSettingResetCatchall($fieldname, $fielddata, $newfieldvalue)\n\t{\n\t\t$returnvalue = self::storeSettingField($fieldname, $fielddata, $newfieldvalue);\n\n\t\tif ($returnvalue !== false && is_array($fielddata) && isset($fielddata['settinggroup']) && $fielddata['settinggroup'] == 'catchall' && isset($fielddata['varname']) && $fielddata['varname'] == 'catchall_enabled' && $newfieldvalue == '0') {\n\t\t\tDatabase::query(\"\n\t\t\t\tUPDATE `\" . TABLE_MAIL_VIRTUAL . \"` SET `iscatchall` = '0' WHERE `iscatchall` = '1'\n\t\t\t\");\n\t\t}\n\n\t\treturn $returnvalue;\n\t}\n\n\t/**\n\t * Whenever the webserver- / FCGID- or FPM-user gets updated\n\t * we need to update ftp_groups accordingly\n\t */\n\tpublic static function storeSettingWebserverFcgidFpmUser($fieldname, $fielddata, $newfieldvalue)\n\t{\n\t\tif (is_array($fielddata) && isset($fielddata['settinggroup']) && isset($fielddata['varname'])) {\n\t\t\t$update_user = null;\n\n\t\t\t// webserver\n\t\t\tif ($fielddata['settinggroup'] == 'system' && $fielddata['varname'] == 'httpuser') {\n\t\t\t\t$update_user = Settings::Get('system.httpuser');\n\t\t\t}\n\n\t\t\t// fcgid\n\t\t\tif ($fielddata['settinggroup'] == 'system' && $fielddata['varname'] == 'mod_fcgid_httpuser') {\n\t\t\t\t$update_user = Settings::Get('system.mod_fcgid_httpuser');\n\t\t\t}\n\n\t\t\t// webserver\n\t\t\tif ($fielddata['settinggroup'] == 'phpfpm' && $fielddata['varname'] == 'vhost_httpuser') {\n\t\t\t\t$update_user = Settings::Get('phpfpm.vhost_httpuser');\n\t\t\t}\n\n\t\t\t$returnvalue = self::storeSettingField($fieldname, $fielddata, $newfieldvalue);\n\n\t\t\tif ($returnvalue !== false) {\n\t\t\t\t/**\n\t\t\t\t * only update if anything changed\n\t\t\t\t */\n\t\t\t\tif ($update_user != null && $newfieldvalue != $update_user) {\n\t\t\t\t\t$upd_stmt = Database::prepare(\"UPDATE `\" . TABLE_FTP_GROUPS . \"` SET `members` = REPLACE(`members`, :olduser, :newuser)\");\n\t\t\t\t\tDatabase::pexecute($upd_stmt, [\n\t\t\t\t\t\t'olduser' => $update_user,\n\t\t\t\t\t\t'newuser' => $newfieldvalue\n\t\t\t\t\t]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn $returnvalue;\n\t}\n\n\tpublic static function storeSettingImage($fieldname, $fielddata)\n\t{\n\t\tif (isset($fielddata['settinggroup'], $fielddata['varname']) && is_array($fielddata) && $fielddata['settinggroup'] !== '' && $fielddata['varname'] !== '') {\n\t\t\t$save_to = null;\n\t\t\t$path = Froxlor::getInstallDir() . '/img/';\n\t\t\t$path = FileDir::makeCorrectDir($path);\n\n\t\t\t// New file?\n\t\t\tif (isset($_FILES[$fieldname]) && $_FILES[$fieldname]['tmp_name']) {\n\t\t\t\t// Make sure upload directory exists\n\t\t\t\tif (!is_dir($path) && !mkdir($path, 0775)) {\n\t\t\t\t\tthrow new Exception(\"img directory does not exist and cannot be created\");\n\t\t\t\t}\n\n\t\t\t\t// Make sure we can write to the upload directory\n\t\t\t\tif (!is_writable($path)) {\n\t\t\t\t\tif (!chmod($path, 0775)) {\n\t\t\t\t\t\tthrow new Exception(\"Cannot write to img directory\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Make sure mime-type matches an image\n\t\t\t\t$image_content = file_get_contents($_FILES[$fieldname]['tmp_name']);\n\t\t\t\t$value = base64_encode($image_content);\n\t\t\t\tif (Validate::validateBase64Image($value)) {\n\t\t\t\t\t$img_filename = $_FILES[$fieldname]['name'];\n\n\t\t\t\t\t$spl = explode('.', $img_filename);\n\t\t\t\t\t$file_extension = strtolower(array_pop($spl));\n\t\t\t\t\tunset($spl);\n\n\t\t\t\t\tif (!in_array($file_extension, [\n\t\t\t\t\t\t'jpeg',\n\t\t\t\t\t\t'jpg',\n\t\t\t\t\t\t'png',\n\t\t\t\t\t\t'gif'\n\t\t\t\t\t])) {\n\t\t\t\t\t\tthrow new Exception(\"Invalid file-extension, use one of: jpeg, jpg, png, gif\");\n\t\t\t\t\t}\n\t\t\t\t\t$filename = bin2hex(random_bytes(16)) . '.' . $file_extension;\n\t\t\t\t\t// Move file\n\t\t\t\t\tif (!move_uploaded_file($_FILES[$fieldname]['tmp_name'], $path . $filename)) {\n\t\t\t\t\t\tthrow new Exception(\"Unable to save image to img folder\");\n\t\t\t\t\t}\n\t\t\t\t\t$save_to = 'img/' . $filename . '?v=' . time();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Delete file?\n\t\t\tif ($fielddata['value'] !== \"\" && array_key_exists($fieldname . '_delete', $_POST) && $_POST[$fieldname . '_delete']) {\n\t\t\t\t@unlink(Froxlor::getInstallDir() . '/' . explode('?', $fielddata['value'], 2)[0]);\n\t\t\t\t$save_to = '';\n\t\t\t}\n\n\t\t\t// Nothing changed\n\t\t\tif ($save_to === null) {\n\t\t\t\treturn [\n\t\t\t\t\t$fielddata['settinggroup'] . '.' . $fielddata['varname'] => $fielddata['value']\n\t\t\t\t];\n\t\t\t}\n\n\t\t\tif (Settings::Set($fielddata['settinggroup'] . '.' . $fielddata['varname'], $save_to) === false) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn [\n\t\t\t\t$fielddata['settinggroup'] . '.' . $fielddata['varname'] => $save_to\n\t\t\t];\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tprivate static function cleanMySQLAccessHost($value)\n\t{\n\t\tif (substr($value, 0, 1) == '[' && substr($value, -1) == ']') {\n\t\t\treturn substr($value, 1, -1);\n\t\t}\n\t\treturn $value;\n\t}\n\n\tpublic static function storeSettingUpdateTrafficTool($fieldname, $fielddata, $newfieldvalue)\n\t{\n\t\t$returnvalue = self::storeSettingField($fieldname, $fielddata, $newfieldvalue);\n\n\t\tif ($returnvalue !== false && is_array($fielddata) && isset($fielddata['settinggroup']) && $fielddata['settinggroup'] == 'system' && isset($fielddata['varname']) && $fielddata['varname'] == 'traffictool' && $newfieldvalue != $fielddata['value']) {\n\t\t\t$oldpath = '/' . $fielddata['value'] . '/';\n\t\t\t$newpath = '/' . $newfieldvalue . '/';\n\t\t\t$sel_stmt = Database::prepare(\"SELECT * FROM `\" . TABLE_PANEL_HTPASSWDS . \"` WHERE `path` LIKE :oldpath\");\n\t\t\t$upd_stmt = Database::prepare(\"\n\t\t\t\tUPDATE `\" . TABLE_PANEL_HTPASSWDS . \"` SET `path` = :newpath WHERE `id` = :id\n\t\t\t\");\n\t\t\tDatabase::pexecute($sel_stmt, [\n\t\t\t\t'oldpath' => '%' . $oldpath\n\t\t\t]);\n\t\t\twhile ($entry = $sel_stmt->fetch(\\PDO::FETCH_ASSOC)) {\n\t\t\t\t$full_path = str_replace($oldpath, $newpath, $entry['path']);\n\t\t\t\t$eid = (int)$entry['id'];\n\t\t\t\tDatabase::pexecute($upd_stmt, [\n\t\t\t\t\t'newpath' => $full_path,\n\t\t\t\t\t'id' => $eid\n\t\t\t\t]);\n\t\t\t}\n\t\t}\n\n\t\treturn $returnvalue;\n\t}\n}\n", "<?php\n\n/**\n * This file is part of the Froxlor project.\n * Copyright (c) 2010 the Froxlor Team (see authors).\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, you can also view it online at\n * https://files.froxlor.org/misc/COPYING.txt\n *\n * @copyright  the authors\n * @author     Froxlor team <team@froxlor.org>\n * @license    https://files.froxlor.org/misc/COPYING.txt GPLv2\n */\n\nnamespace Froxlor\\Validate;\n\nuse Exception;\nuse Froxlor\\Database\\Database;\nuse Froxlor\\FroxlorLogger;\nuse Froxlor\\Idna\\IdnaWrapper;\nuse Froxlor\\System\\IPTools;\nuse Froxlor\\UI\\Response;\n\nclass Validate\n{\n\n\tconst REGEX_DIR = '/^|(\\/[\\w-]+)+$/';\n\n\tconst REGEX_PORT = '/^(([1-9])|([1-9][0-9])|([1-9][0-9][0-9])|([1-9][0-9][0-9][0-9])|([1-5][0-9][0-9][0-9][0-9])|(6[0-4][0-9][0-9][0-9])|(65[0-4][0-9][0-9])|(655[0-2][0-9])|(6553[0-5]))$/Di';\n\n\tconst REGEX_CONF_TEXT = '/^[^\\0]*$/';\n\n\tconst REGEX_DESC_TEXT = '/^[^\\0\\r\\n<>]*$/';\n\n\tconst REGEX_YYYY_MM_DD = '/^\\d{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/';\n\n\t/**\n\t * Validates the given string by matching against the pattern, prints an error on failure and exits.\n\t * If the default pattern is used and the string does not match, we try to replace the 'bad' values and log the action.\n\t *\n\t * @param string $str the string to be tested (user input)\n\t * @param string $fieldname to be used in error messages\n\t * @param string $pattern the regular expression to be used for testing\n\t * @param string|array $lng id for the error\n\t * @param string|array $emptydefault fallback value\n\t * @param bool $throw_exception whether to display error or throw an exception, default false\n\t *\n\t * @return string|void the clean string or error\n\t * @throws Exception\n\t */\n\tpublic static function validate(\n\t\tstring $str,\n\t\tstring $fieldname,\n\t\tstring $pattern = '',\n\t\t$lng = '',\n\t\t$emptydefault = [],\n\t\tbool $throw_exception = false\n\t) {\n\t\tif (!is_array($emptydefault)) {\n\t\t\t$emptydefault_array = [\n\t\t\t\t$emptydefault\n\t\t\t];\n\t\t\tunset($emptydefault);\n\t\t\t$emptydefault = $emptydefault_array;\n\t\t\tunset($emptydefault_array);\n\t\t}\n\n\t\t// Check if the $str is one of the values which represent the default for an 'empty' value\n\t\tif (is_array($emptydefault) && !empty($emptydefault) && in_array($str, $emptydefault)) {\n\t\t\treturn $str;\n\t\t}\n\n\t\tif ($pattern == '') {\n\t\t\t$pattern = '/^[^\\r\\n\\t\\f\\0]*$/D';\n\n\t\t\tif (!preg_match($pattern, $str)) {\n\t\t\t\t// Allows letters a-z, digits, space (\\\\040), hyphen (\\\\-), underscore (\\\\_) and backslash (\\\\\\\\),\n\t\t\t\t// everything else is removed from the string.\n\t\t\t\t$allowed = \"/[^a-z0-9\\\\040\\\\.\\\\-\\\\_\\\\\\\\]/i\";\n\t\t\t\t$str = preg_replace($allowed, \"\", $str);\n\t\t\t\t$log = FroxlorLogger::getInstanceOf();\n\t\t\t\t$log->logAction(FroxlorLogger::USR_ACTION, LOG_WARNING, \"cleaned bad formatted string (\" . $str . \")\");\n\t\t\t}\n\t\t}\n\n\t\tif (preg_match($pattern, $str)) {\n\t\t\treturn $str;\n\t\t}\n\n\t\tif ($lng == '') {\n\t\t\t$lng = 'stringformaterror';\n\t\t}\n\n\t\tResponse::standardError($lng, $fieldname, $throw_exception);\n\t}\n\n\t/**\n\t * Checks whether it is a valid ip\n\t *\n\t * @param string $ip ip-address to check\n\t * @param bool $return_bool whether to return bool or call \\Froxlor\\UI\\Response::standard_error()\n\t * @param string $lng index for error-message (if $return_bool is false)\n\t * @param bool $allow_localhost whether to allow 127.0.0.1\n\t * @param bool $allow_priv whether to allow private network addresses\n\t * @param bool $allow_cidr whether to allow CIDR values e.g. 10.10.10.10/16\n\t * @param bool $cidr_as_netmask whether to format CIDR notation to netmask notation\n\t * @param bool $throw_exception whether to throw an exception on failure\n\t *\n\t * @return string|bool|void ip address on success, false on failure (or nothing if error is displayed)\n\t * @throws Exception\n\t */\n\tpublic static function validate_ip2(\n\t\tstring $ip,\n\t\tbool $return_bool = false,\n\t\tstring $lng = 'invalidip',\n\t\tbool $allow_localhost = false,\n\t\tbool $allow_priv = false,\n\t\tbool $allow_cidr = false,\n\t\tbool $cidr_as_netmask = false,\n\t\tbool $throw_exception = false\n\t) {\n\t\t$cidr = \"\";\n\t\tif ($allow_cidr) {\n\t\t\t$org_ip = $ip;\n\t\t\t$ip_cidr = explode(\"/\", $ip);\n\t\t\tif (count($ip_cidr) === 2) {\n\t\t\t\t$cidr_range_max = 32;\n\t\t\t\tif (IPTools::is_ipv6($ip_cidr[0])) {\n\t\t\t\t\t$cidr_range_max = 128;\n\t\t\t\t}\n\t\t\t\tif (strlen($ip_cidr[1]) <= 3 && in_array((int)$ip_cidr[1], array_values(range(1, $cidr_range_max)),\n\t\t\t\t\t\ttrue) === false) {\n\t\t\t\t\tif ($return_bool) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tResponse::standardError($lng, $ip, $throw_exception);\n\t\t\t\t}\n\t\t\t\tif ($cidr_as_netmask && IPTools::is_ipv6($ip_cidr[0])) {\n\t\t\t\t\t// MySQL does not handle CIDR of IPv6 addresses, return error\n\t\t\t\t\tif ($return_bool) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tResponse::standardError($lng, $ip, $throw_exception);\n\t\t\t\t}\n\t\t\t\t$ip = $ip_cidr[0];\n\t\t\t\tif ($cidr_as_netmask && strlen($ip_cidr[1]) <= 3) {\n\t\t\t\t\t$ip_cidr[1] = IPTools::cidr2NetmaskAddr($org_ip);\n\t\t\t\t}\n\t\t\t\t$cidr = \"/\" . $ip_cidr[1];\n\t\t\t} else {\n\t\t\t\t$ip = $org_ip;\n\t\t\t}\n\t\t} elseif (strpos($ip, \"/\") !== false) {\n\t\t\tif ($return_bool) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tResponse::standardError($lng, $ip, $throw_exception);\n\t\t}\n\n\t\t$filter_lan = $allow_priv ? FILTER_FLAG_NO_RES_RANGE : (FILTER_FLAG_NO_RES_RANGE | FILTER_FLAG_NO_PRIV_RANGE);\n\n\t\tif ((filter_var($ip, FILTER_VALIDATE_IP, FILTER_FLAG_IPV6) || filter_var($ip, FILTER_VALIDATE_IP,\n\t\t\t\t\tFILTER_FLAG_IPV4)) && filter_var($ip, FILTER_VALIDATE_IP, $filter_lan)) {\n\t\t\treturn $ip . $cidr;\n\t\t}\n\n\t\t// special case where localhost ip is allowed (mysql-access-hosts for example)\n\t\tif ($allow_localhost && $ip == '127.0.0.1') {\n\t\t\treturn $ip . $cidr;\n\t\t}\n\n\t\tif ($return_bool) {\n\t\t\treturn false;\n\t\t}\n\t\tResponse::standardError($lng, $ip, $throw_exception);\n\t}\n\n\t/**\n\t * Returns whether a URL is in a correct format or not\n\t *\n\t * @param string $url URL to be tested\n\t * @param bool $allow_private_ip optional, default is false\n\t *\n\t * @return bool\n\t */\n\tpublic static function validateUrl(string $url, bool $allow_private_ip = false): bool\n\t{\n\t\tif (strtolower(substr($url, 0, 7)) != \"http://\" && strtolower(substr($url, 0, 8)) != \"https://\") {\n\t\t\t$url = 'http://' . $url;\n\t\t}\n\n\t\t// needs converting\n\t\ttry {\n\t\t\t$idna_convert = new IdnaWrapper();\n\t\t\t$url = $idna_convert->encode($url);\n\t\t} catch (Exception $e) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ($allow_private_ip) {\n\t\t\t$pattern = '%^(?:(?:https?):\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\x{00a1}-\\x{ffff}0-9]+-?)*[a-z\\x{00a1}-\\x{ffff}0-9]+)(?:\\.(?:[a-z\\x{00a1}-\\x{ffff}0-9]+-?)*[a-z\\x{00a1}-\\x{ffff}0-9]+)*(?:\\.(?:[a-z\\x{00a1}-\\x{ffff}]{2,})))(?::\\d{2,5})?(?:\\/[^\\s]*)?$%iuS';\n\t\t} else {\n\t\t\t$pattern = '%^(?:(?:https?):\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?!10(?:\\.\\d{1,3}){3})(?!127(?:\\.\\d{1,3}){3})(?!169\\.254(?:\\.\\d{1,3}){2})(?!192\\.168(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\x{00a1}-\\x{ffff}0-9]+-?)*[a-z\\x{00a1}-\\x{ffff}0-9]+)(?:\\.(?:[a-z\\x{00a1}-\\x{ffff}0-9]+-?)*[a-z\\x{00a1}-\\x{ffff}0-9]+)*(?:\\.(?:[a-z\\x{00a1}-\\x{ffff}]{2,})))(?::\\d{2,5})?(?:/[^\\s]*)?$%iuS';\n\t\t}\n\t\tif (preg_match($pattern, $url)) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Check if the submitted string is a valid domainname\n\t *\n\t * @param string $domainname The domainname which should be checked.\n\t * @param bool $allow_underscore optional if true, allowes the underscore character in a domain label (DKIM etc.)\n\t *\n\t * @return string|boolean the domain-name if the domain is valid, false otherwise\n\t */\n\tpublic static function validateDomain(string $domainname, bool $allow_underscore = false)\n\t{\n\t\t$char_validation = '([a-z\\d](-*[a-z\\d])*)(\\.?([a-z\\d](-*[a-z\\d])*))*\\.(xn\\-\\-)?([a-z\\d])+';\n\t\tif ($allow_underscore) {\n\t\t\t$char_validation = '([a-z\\d\\_](-*[a-z\\d\\_])*)(\\.([a-z\\d\\_](-*[a-z\\d])*))*(\\.?([a-z\\d](-*[a-z\\d])*))+\\.(xn\\-\\-)?([a-z\\d])+';\n\t\t}\n\n\t\t// valid chars check && overall length check && length of each label\n\t\tif (preg_match(\"/^\" . $char_validation . \"$/i\", $domainname) && preg_match(\"/^.{1,253}$/\",\n\t\t\t\t$domainname) && preg_match(\"/^[^\\.]{1,63}(\\.[^\\.]{1,63})*$/\", $domainname)) {\n\t\t\treturn $domainname;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * validate a local-hostname by regex\n\t *\n\t * @param string $hostname\n\t *\n\t * @return string|boolean hostname on success, else false\n\t */\n\tpublic static function validateLocalHostname(string $hostname)\n\t{\n\t\t$pattern = '/^[a-z0-9][a-z0-9\\-]{0,62}$/i';\n\t\tif (preg_match($pattern, $hostname)) {\n\t\t\treturn $hostname;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Returns if an emailaddress is in correct format or not\n\t *\n\t * @param string $email The email address to check\n\t *\n\t * @return mixed\n\t */\n\tpublic static function validateEmail(string $email)\n\t{\n\t\t$email = strtolower($email);\n\t\t// as of php-7.1\n\t\tif (defined('FILTER_FLAG_EMAIL_UNICODE')) {\n\t\t\treturn filter_var($email, FILTER_VALIDATE_EMAIL, FILTER_FLAG_EMAIL_UNICODE);\n\t\t}\n\t\treturn filter_var($email, FILTER_VALIDATE_EMAIL);\n\t}\n\n\t/**\n\t * Returns if a username is in correct format or not.\n\t *\n\t * @param string $username The username to check\n\t * @param bool $unix_names optional, default true, checks whether it must be UNIX compatible\n\t * @param int $mysql_max optional, number of max mysql username characters, default empty\n\t *\n\t * @return bool\n\t */\n\tpublic static function validateUsername(string $username, bool $unix_names = true, int $mysql_max = 0): bool\n\t{\n\t\tif (empty($mysql_max) || $mysql_max <= 0) {\n\t\t\t$mysql_max = Database::getSqlUsernameLength() - 1;\n\t\t} else {\n\t\t\t$mysql_max--;\n\t\t}\n\t\tif (!$unix_names) {\n\t\t\tif (strpos($username, '--') === false) {\n\t\t\t\treturn (preg_match('/^[a-z][a-z0-9\\-_]{0,' . $mysql_max . '}[a-z0-9]{1}$/Di', $username) != false);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\treturn (preg_match('/^[a-z][a-z0-9]{0,' . $mysql_max . '}$/Di', $username) != false);\n\t}\n\n\t/**\n\t * validate sql interval string\n\t *\n\t * @param string $interval\n\t *\n\t * @return bool\n\t */\n\tpublic static function validateSqlInterval(string $interval = ''): bool\n\t{\n\t\tif (!empty($interval) && strstr($interval, ' ') !== false) {\n\t\t\t/*\n\t\t\t * [0] = ([0-9]+)\n\t\t\t * [1] = valid SQL-Interval expression\n\t\t\t */\n\t\t\t$valid_expr = [\n\t\t\t\t'SECOND',\n\t\t\t\t'MINUTE',\n\t\t\t\t'HOUR',\n\t\t\t\t'DAY',\n\t\t\t\t'WEEK',\n\t\t\t\t'MONTH',\n\t\t\t\t'YEAR'\n\t\t\t];\n\n\t\t\t$interval_parts = explode(' ', $interval);\n\n\t\t\tif (count($interval_parts) == 2 && preg_match('/[0-9]+/',\n\t\t\t\t\t$interval_parts[0]) && in_array(strtoupper($interval_parts[1]), $valid_expr)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * validates whether a given base64 string decodes to an image\n\t *\n\t * @param string $base64string\n\t * @return bool\n\t * @throws Exception\n\t */\n\tpublic static function validateBase64Image(string $base64string) {\n\n\t\tif (!extension_loaded('gd')) {\n\t\t\tResponse::standardError('phpgdextensionnotavailable', null, true);\n\t\t}\n\n\t\t// Decode the base64 string\n\t\t$data = base64_decode($base64string);\n\n\t\t// Create an image from the decoded data\n\t\t$image = @imagecreatefromstring($data);\n\n\t\t// Check if the image was created successfully\n\t\tif (!$image) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Get the MIME type of the image\n\t\t$mime = image_type_to_mime_type(getimagesizefromstring($data)[2]);\n\n\t\t// Check if the MIME type is a valid image MIME type\n\t\tif (strpos($mime, 'image/') !== 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// If everything is okay, return true\n\t\treturn true;\n\t}\n}\n"], "filenames": ["lib/Froxlor/SImExporter.php", "lib/Froxlor/Settings/Store.php", "lib/Froxlor/Validate/Validate.php"], "buggy_code_start_loc": [30, 38, 336], "buggy_code_end_loc": [229, 452, 336], "fixing_code_start_loc": [31, 39, 337], "fixing_code_end_loc": [217, 443, 373], "type": "CWE-434", "message": "Unrestricted Upload of File with Dangerous Type in GitHub repository froxlor/froxlor prior to 2.0.14.", "other": {"cve": {"id": "CVE-2023-2034", "sourceIdentifier": "security@huntr.dev", "published": "2023-04-14T01:15:08.847", "lastModified": "2023-04-21T19:43:35.130", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Unrestricted Upload of File with Dangerous Type in GitHub repository froxlor/froxlor prior to 2.0.14."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:H/UI:N/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 2.3, "impactScore": 6.0}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-434"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-434"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:froxlor:froxlor:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.0.14", "matchCriteriaId": "26DAE5E7-9A76-4E78-89EE-83348E930583"}]}]}], "references": [{"url": "https://github.com/froxlor/froxlor/commit/f36bc61fc74c85a21c8d31448198b11f96eb3bc6", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.dev/bounties/aba6beaa-570e-4523-8128-da4d8e374ef6", "source": "security@huntr.dev", "tags": ["Exploit", "Patch"]}]}, "github_commit_url": "https://github.com/froxlor/froxlor/commit/f36bc61fc74c85a21c8d31448198b11f96eb3bc6"}}