{"buggy_code": ["/* -*- C++ -*-\n * File: libraw_const.h\n * Copyright 2008-2020 LibRaw LLC (info@libraw.org)\n * Created: Sat Mar  8 , 2008\n * LibRaw error codes\nLibRaw is free software; you can redistribute it and/or modify\nit under the terms of the one of two licenses as you choose:\n\n1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1\n   (See file LICENSE.LGPL provided in LibRaw distribution archive for details).\n\n2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0\n   (See file LICENSE.CDDL provided in LibRaw distribution archive for details).\n\n */\n\n#ifndef _LIBRAW_ERRORS_H\n#define _LIBRAW_ERRORS_H\n\n#define LIBRAW_DEFAULT_ADJUST_MAXIMUM_THRESHOLD 0.75\n#define LIBRAW_DEFAULT_AUTO_BRIGHTNESS_THRESHOLD 0.01\n/* limit allocation size, default is 2Gb */\n#define LIBRAW_MAX_ALLOC_MB_DEFAULT 2048L\n\n/* Check if enough file space exists before tag read */\n#ifndef LIBRAW_NO_IOSPACE_CHECK\n#define LIBRAW_IOSPACE_CHECK\n#endif\n#ifndef LIBRAW_NO_CR3_MEMPOOL\n#define LIBRAW_CR3_MEMPOOL\n#endif\n\n\n/* LibRaw uses own memory pool management, with LIBRAW_MSIZE (512)\nentries. It is enough for parsing/decoding non-damaged files, but\nmay overflow on specially crafted files (eg. with many string values\nlike XMP blocks.\nLIBRAW_MEMPOOL_CHECK define will result in error on pool overflow */\n#ifndef LIBRAW_NO_MEMPOOL_CHECK\n#define LIBRAW_MEMPOOL_CHECK\n#endif\n\n#define LIBRAW_MAX_METADATA_BLOCKS 1024\n#define LIBRAW_CBLACK_SIZE 4104\n#define LIBRAW_IFD_MAXCOUNT 10\n#define LIBRAW_CRXTRACKS_MAXCOUNT 16\n\n#define LIBRAW_AHD_TILE 512\n\nenum LibRaw_open_flags\n{\n\tLIBRAW_OPEN_BIGFILE=1,\n\tLIBRAW_OPEN_FILE= 1<<1\n};\n\nenum LibRaw_openbayer_patterns\n{\n  LIBRAW_OPENBAYER_RGGB = 0x94,\n  LIBRAW_OPENBAYER_BGGR = 0x16,\n  LIBRAW_OPENBAYER_GRBG = 0x61,\n  LIBRAW_OPENBAYER_GBRG = 0x49\n};\n\nenum LibRaw_dngfields_marks\n{\n  LIBRAW_DNGFM_FORWARDMATRIX = 1,\n  LIBRAW_DNGFM_ILLUMINANT = 1 << 1,\n  LIBRAW_DNGFM_COLORMATRIX = 1 << 2,\n  LIBRAW_DNGFM_CALIBRATION = 1 << 3,\n  LIBRAW_DNGFM_ANALOGBALANCE = 1 << 4,\n  LIBRAW_DNGFM_BLACK = 1 << 5,\n  LIBRAW_DNGFM_WHITE = 1 << 6,\n  LIBRAW_DNGFM_OPCODE2 = 1 << 7,\n  LIBRAW_DNGFM_LINTABLE = 1 << 8,\n  LIBRAW_DNGFM_CROPORIGIN = 1 << 9,\n  LIBRAW_DNGFM_CROPSIZE = 1 << 10,\n  LIBRAW_DNGFM_PREVIEWCS = 1 << 11,\n  LIBRAW_DNGFM_ASSHOTNEUTRAL = 1 << 12,\n  LIBRAW_DNGFM_BASELINEEXPOSURE = 1 << 13,\n  LIBRAW_DNGFM_LINEARRESPONSELIMIT = 1 << 14\n};\n\nenum LibRaw_As_Shot_WB_Applied_codes\n{\n  LIBRAW_ASWB_APPLIED = 1,\n  LIBRAW_ASWB_CANON = 2,\n  LIBRAW_ASWB_NIKON = 4,\n  LIBRAW_ASWB_NIKON_SRAW = 8,\n  LIBRAW_ASWB_PENTAX = 16\n};\n\n#define tagtypeIs(typex) (type == typex)\nenum LibRaw_ExifTagTypes {\n  LIBRAW_EXIFTAG_TYPE_UNKNOWN   =  0,\n  LIBRAW_EXIFTAG_TYPE_BYTE      =  1,\n  LIBRAW_EXIFTAG_TYPE_ASCII     =  2,\n  LIBRAW_EXIFTAG_TYPE_SHORT     =  3,\n  LIBRAW_EXIFTAG_TYPE_LONG      =  4,\n  LIBRAW_EXIFTAG_TYPE_RATIONAL  =  5,\n  LIBRAW_EXIFTAG_TYPE_SBYTE     =  6,\n  LIBRAW_EXIFTAG_TYPE_UNDEFINED =  7,\n  LIBRAW_EXIFTAG_TYPE_SSHORT    =  8,\n  LIBRAW_EXIFTAG_TYPE_SLONG     =  9,\n  LIBRAW_EXIFTAG_TYPE_SRATIONAL = 10,\n  LIBRAW_EXIFTAG_TYPE_FLOAT     = 11,\n  LIBRAW_EXIFTAG_TYPE_DOUBLE    = 12,\n  LIBRAW_EXIFTAG_TYPE_IFD       = 13,\n  LIBRAW_EXIFTAG_TYPE_UNICODE   = 14,\n  LIBRAW_EXIFTAG_TYPE_COMPLEX   = 15,\n  LIBRAW_EXIFTAG_TYPE_LONG8     = 16,\n  LIBRAW_EXIFTAG_TYPE_SLONG8    = 17,\n  LIBRAW_EXIFTAG_TYPE_IFD8      = 18\n};\n\n#define LIBRAW_EXIFTOOLTAGTYPE_int8u       LIBRAW_EXIFTAG_TYPE_BYTE\n#define LIBRAW_EXIFTOOLTAGTYPE_string      LIBRAW_EXIFTAG_TYPE_ASCII\n#define LIBRAW_EXIFTOOLTAGTYPE_int16u      LIBRAW_EXIFTAG_TYPE_SHORT\n#define LIBRAW_EXIFTOOLTAGTYPE_int32u      LIBRAW_EXIFTAG_TYPE_LONG\n#define LIBRAW_EXIFTOOLTAGTYPE_rational64u LIBRAW_EXIFTAG_TYPE_RATIONAL\n#define LIBRAW_EXIFTOOLTAGTYPE_int8s       LIBRAW_EXIFTAG_TYPE_SBYTE\n#define LIBRAW_EXIFTOOLTAGTYPE_undef       LIBRAW_EXIFTAG_TYPE_UNDEFINED\n#define LIBRAW_EXIFTOOLTAGTYPE_binary      LIBRAW_EXIFTAG_TYPE_UNDEFINED\n#define LIBRAW_EXIFTOOLTAGTYPE_int16s      LIBRAW_EXIFTAG_TYPE_SSHORT\n#define LIBRAW_EXIFTOOLTAGTYPE_int32s      LIBRAW_EXIFTAG_TYPE_SLONG\n#define LIBRAW_EXIFTOOLTAGTYPE_rational64s LIBRAW_EXIFTAG_TYPE_SRATIONAL\n#define LIBRAW_EXIFTOOLTAGTYPE_float       LIBRAW_EXIFTAG_TYPE_FLOAT\n#define LIBRAW_EXIFTOOLTAGTYPE_double      LIBRAW_EXIFTAG_TYPE_DOUBLE\n#define LIBRAW_EXIFTOOLTAGTYPE_ifd         LIBRAW_EXIFTAG_TYPE_IFD\n#define LIBRAW_EXIFTOOLTAGTYPE_unicode     LIBRAW_EXIFTAG_TYPE_UNICODE\n#define LIBRAW_EXIFTOOLTAGTYPE_complex     LIBRAW_EXIFTAG_TYPE_COMPLEX\n#define LIBRAW_EXIFTOOLTAGTYPE_int64u      LIBRAW_EXIFTAG_TYPE_LONG8\n#define LIBRAW_EXIFTOOLTAGTYPE_int64s      LIBRAW_EXIFTAG_TYPE_SLONG8\n#define LIBRAW_EXIFTOOLTAGTYPE_ifd64       LIBRAW_EXIFTAG_TYPE_IFD8\n\n#define LIBRAW_LENS_NOT_SET 0xffffffffffffffffULL\n\nenum LibRaw_whitebalance_code\n{\n// clang-format off\n  /*\n      EXIF light sources\n      12 = FL-D; Daylight fluorescent (D 5700K \u2013 7100K) (F1,F5)\n      13 = FL-N; Day white fluorescent (N 4600K \u2013 5400K) (F7,F8)\n      14 = FL-W; Cool white fluorescent (W 3900K \u2013 4500K) (F2,F6, office, store, warehouse)\n      15 = FL-WW; White fluorescent (WW 3200K \u2013 3700K) (F3, residential)\n      16 = FL-L; Soft/Warm white fluorescent (L 2600K - 3250K) (F4, kitchen, bath)\n  */\n//clang-format on\n  LIBRAW_WBI_Unknown = 0,\n  LIBRAW_WBI_Daylight = 1,\n  LIBRAW_WBI_Fluorescent = 2,\n  LIBRAW_WBI_Tungsten = 3,\n  LIBRAW_WBI_Flash = 4,\n  LIBRAW_WBI_FineWeather = 9,\n  LIBRAW_WBI_Cloudy = 10,\n  LIBRAW_WBI_Shade = 11,\n  LIBRAW_WBI_FL_D = 12,\n  LIBRAW_WBI_FL_N = 13,\n  LIBRAW_WBI_FL_W = 14,\n  LIBRAW_WBI_FL_WW = 15,\n  LIBRAW_WBI_FL_L = 16,\n  LIBRAW_WBI_Ill_A = 17,\n  LIBRAW_WBI_Ill_B = 18,\n  LIBRAW_WBI_Ill_C = 19,\n  LIBRAW_WBI_D55 = 20,\n  LIBRAW_WBI_D65 = 21,\n  LIBRAW_WBI_D75 = 22,\n  LIBRAW_WBI_D50 = 23,\n  LIBRAW_WBI_StudioTungsten = 24,\n  LIBRAW_WBI_Sunset = 64,\n  LIBRAW_WBI_Underwater = 65,\n  LIBRAW_WBI_FluorescentHigh = 66,\n  LIBRAW_WBI_HT_Mercury = 67,\n  LIBRAW_WBI_AsShot = 81,\n  LIBRAW_WBI_Auto = 82,\n  LIBRAW_WBI_Custom = 83,\n  LIBRAW_WBI_Auto1 = 85,\n  LIBRAW_WBI_Auto2 = 86,\n  LIBRAW_WBI_Auto3 = 87,\n  LIBRAW_WBI_Auto4 = 88,\n  LIBRAW_WBI_Custom1 = 90,\n  LIBRAW_WBI_Custom2 = 91,\n  LIBRAW_WBI_Custom3 = 92,\n  LIBRAW_WBI_Custom4 = 93,\n  LIBRAW_WBI_Custom5 = 94,\n  LIBRAW_WBI_Custom6 = 95,\n  LIBRAW_WBI_PC_Set1 = 96,\n  LIBRAW_WBI_PC_Set2 = 97,\n  LIBRAW_WBI_PC_Set3 = 98,\n  LIBRAW_WBI_PC_Set4 = 99,\n  LIBRAW_WBI_PC_Set5 = 100,\n  LIBRAW_WBI_Measured = 110,\n  LIBRAW_WBI_BW = 120,\n  LIBRAW_WBI_Kelvin = 254,\n  LIBRAW_WBI_Other = 255,\n  LIBRAW_WBI_None = 0xffff\n};\n\nenum LibRaw_MultiExposure_related\n{\n  LIBRAW_ME_NONE = 0,\n  LIBRAW_ME_SIMPLE = 1,\n  LIBRAW_ME_OVERLAY = 2,\n  LIBRAW_ME_HDR = 3\n};\n\nenum LibRaw_dng_processing\n{\n  LIBRAW_DNG_NONE = 0,\n  LIBRAW_DNG_FLOAT = 1,\n  LIBRAW_DNG_LINEAR = 2,\n  LIBRAW_DNG_DEFLATE = 4,\n  LIBRAW_DNG_XTRANS = 8,\n  LIBRAW_DNG_OTHER = 16,\n  LIBRAW_DNG_8BIT = 32,\n  /*LIBRAW_DNG_LARGERANGE=64,*/ /* more than 16 bit integer */\n  LIBRAW_DNG_ALL =\n      LIBRAW_DNG_FLOAT | LIBRAW_DNG_LINEAR | LIBRAW_DNG_XTRANS |\n      LIBRAW_DNG_8BIT | LIBRAW_DNG_OTHER /* |LIBRAW_DNG_LARGERANGE */,\n  LIBRAW_DNG_DEFAULT = LIBRAW_DNG_FLOAT | LIBRAW_DNG_LINEAR |\n                       LIBRAW_DNG_DEFLATE | LIBRAW_DNG_8BIT\n};\n\nenum LibRaw_runtime_capabilities\n{\n  LIBRAW_CAPS_RAWSPEED = 1,\n  LIBRAW_CAPS_DNGSDK = 2,\n  LIBRAW_CAPS_GPRSDK = 4,\n  LIBRAW_CAPS_UNICODEPATHS = 8,\n  LIBRAW_CAPS_X3FTOOLS = 16,\n  LIBRAW_CAPS_RPI6BY9 = 32\n};\n\nenum LibRaw_colorspace {\n  LIBRAW_COLORSPACE_NotFound = 0,\n  LIBRAW_COLORSPACE_sRGB,\n  LIBRAW_COLORSPACE_AdobeRGB,\n  LIBRAW_COLORSPACE_WideGamutRGB,\n  LIBRAW_COLORSPACE_ProPhotoRGB,\n  LIBRAW_COLORSPACE_ICC,\n  LIBRAW_COLORSPACE_Uncalibrated, // Tag 0x0001 InteropIndex containing \"R03\" + LIBRAW_COLORSPACE_Uncalibrated = Adobe RGB\n  LIBRAW_COLORSPACE_CameraLinearUniWB,\n  LIBRAW_COLORSPACE_CameraLinear,\n  LIBRAW_COLORSPACE_CameraGammaUniWB,\n  LIBRAW_COLORSPACE_CameraGamma,\n  LIBRAW_COLORSPACE_MonochromeLinear,\n  LIBRAW_COLORSPACE_MonochromeGamma,\n  LIBRAW_COLORSPACE_Unknown = 255\n};\n\nenum LibRaw_cameramaker_index\n{\n  LIBRAW_CAMERAMAKER_Unknown = 0,\n  LIBRAW_CAMERAMAKER_Agfa,\n  LIBRAW_CAMERAMAKER_Alcatel,\n  LIBRAW_CAMERAMAKER_Apple,\n  LIBRAW_CAMERAMAKER_Aptina,\n  LIBRAW_CAMERAMAKER_AVT,\n  LIBRAW_CAMERAMAKER_Baumer,\n  LIBRAW_CAMERAMAKER_Broadcom,\n  LIBRAW_CAMERAMAKER_Canon,\n  LIBRAW_CAMERAMAKER_Casio,\n  LIBRAW_CAMERAMAKER_CINE,\n  LIBRAW_CAMERAMAKER_Clauss,\n  LIBRAW_CAMERAMAKER_Contax,\n  LIBRAW_CAMERAMAKER_Creative,\n  LIBRAW_CAMERAMAKER_DJI,\n  LIBRAW_CAMERAMAKER_DXO,\n  LIBRAW_CAMERAMAKER_Epson,\n  LIBRAW_CAMERAMAKER_Foculus,\n  LIBRAW_CAMERAMAKER_Fujifilm,\n  LIBRAW_CAMERAMAKER_Generic,\n  LIBRAW_CAMERAMAKER_Gione,\n  LIBRAW_CAMERAMAKER_GITUP,\n  LIBRAW_CAMERAMAKER_Google,\n  LIBRAW_CAMERAMAKER_GoPro,\n  LIBRAW_CAMERAMAKER_Hasselblad,\n  LIBRAW_CAMERAMAKER_HTC,\n  LIBRAW_CAMERAMAKER_I_Mobile,\n  LIBRAW_CAMERAMAKER_Imacon,\n  LIBRAW_CAMERAMAKER_JK_Imaging,\n  LIBRAW_CAMERAMAKER_Kodak,\n  LIBRAW_CAMERAMAKER_Konica,\n  LIBRAW_CAMERAMAKER_Leaf,\n  LIBRAW_CAMERAMAKER_Leica,\n  LIBRAW_CAMERAMAKER_Lenovo,\n  LIBRAW_CAMERAMAKER_LG,\n  LIBRAW_CAMERAMAKER_Logitech,\n  LIBRAW_CAMERAMAKER_Mamiya,\n  LIBRAW_CAMERAMAKER_Matrix,\n  LIBRAW_CAMERAMAKER_Meizu,\n  LIBRAW_CAMERAMAKER_Micron,\n  LIBRAW_CAMERAMAKER_Minolta,\n  LIBRAW_CAMERAMAKER_Motorola,\n  LIBRAW_CAMERAMAKER_NGM,\n  LIBRAW_CAMERAMAKER_Nikon,\n  LIBRAW_CAMERAMAKER_Nokia,\n  LIBRAW_CAMERAMAKER_Olympus,\n  LIBRAW_CAMERAMAKER_OmniVison,\n  LIBRAW_CAMERAMAKER_Panasonic,\n  LIBRAW_CAMERAMAKER_Parrot,\n  LIBRAW_CAMERAMAKER_Pentax,\n  LIBRAW_CAMERAMAKER_PhaseOne,\n  LIBRAW_CAMERAMAKER_PhotoControl,\n  LIBRAW_CAMERAMAKER_Photron,\n  LIBRAW_CAMERAMAKER_Pixelink,\n  LIBRAW_CAMERAMAKER_Polaroid,\n  LIBRAW_CAMERAMAKER_RED,\n  LIBRAW_CAMERAMAKER_Ricoh,\n  LIBRAW_CAMERAMAKER_Rollei,\n  LIBRAW_CAMERAMAKER_RoverShot,\n  LIBRAW_CAMERAMAKER_Samsung,\n  LIBRAW_CAMERAMAKER_Sigma,\n  LIBRAW_CAMERAMAKER_Sinar,\n  LIBRAW_CAMERAMAKER_SMaL,\n  LIBRAW_CAMERAMAKER_Sony,\n  LIBRAW_CAMERAMAKER_ST_Micro,\n  LIBRAW_CAMERAMAKER_THL,\n  LIBRAW_CAMERAMAKER_VLUU,\n  LIBRAW_CAMERAMAKER_Xiaomi,\n  LIBRAW_CAMERAMAKER_XIAOYI,\n  LIBRAW_CAMERAMAKER_YI,\n  LIBRAW_CAMERAMAKER_Yuneec,\n  LIBRAW_CAMERAMAKER_Zeiss,\n  // Insert additional indexes here\n  LIBRAW_CAMERAMAKER_TheLastOne\n};\n\nenum LibRaw_camera_mounts\n{\n  LIBRAW_MOUNT_Unknown = 0,\n  LIBRAW_MOUNT_Alpa,\n  LIBRAW_MOUNT_C,              /* C-mount */\n  LIBRAW_MOUNT_Canon_EF_M,\n  LIBRAW_MOUNT_Canon_EF_S,\n  LIBRAW_MOUNT_Canon_EF,\n  LIBRAW_MOUNT_Canon_RF,\n  LIBRAW_MOUNT_Contax_N,\n  LIBRAW_MOUNT_Contax645,\n  LIBRAW_MOUNT_FT,             /* original 4/3 */\n  LIBRAW_MOUNT_mFT,            /* micro 4/3 */\n  LIBRAW_MOUNT_Fuji_GF,        /* Fujifilm GFX cameras, G mount */\n  LIBRAW_MOUNT_Fuji_GX,        /* Fujifilm GX680 */\n  LIBRAW_MOUNT_Fuji_X,\n  LIBRAW_MOUNT_Hasselblad_H,   /* Hasselblad Hn cameras, HC & HCD lenses */\n  LIBRAW_MOUNT_Hasselblad_V,\n  LIBRAW_MOUNT_Hasselblad_XCD, /* Hasselblad Xn cameras, XCD lenses */\n  LIBRAW_MOUNT_Leica_M,        /* Leica rangefinder bayonet */\n  LIBRAW_MOUNT_Leica_R,        /* Leica SLRs, 'R' for reflex */\n  LIBRAW_MOUNT_Leica_S,        /* LIBRAW_FORMAT_LeicaS 'MF' */\n  LIBRAW_MOUNT_Leica_SL,       /* lens, mounts on 'L' throat, FF */\n  LIBRAW_MOUNT_Leica_TL,       /* lens, mounts on 'L' throat, APS-C */\n  LIBRAW_MOUNT_LPS_L,          /* Leica/Panasonic/Sigma camera mount, takes L, SL and TL lenses */\n  LIBRAW_MOUNT_Mamiya67,       /* Mamiya RB67, RZ67 */\n  LIBRAW_MOUNT_Mamiya645,\n  LIBRAW_MOUNT_Minolta_A,\n  LIBRAW_MOUNT_Nikon_CX,       /* used in 'Nikon 1' series */\n  LIBRAW_MOUNT_Nikon_F,\n  LIBRAW_MOUNT_Nikon_Z,\n  LIBRAW_MOUNT_Pentax_645,\n  LIBRAW_MOUNT_Pentax_K,\n  LIBRAW_MOUNT_Pentax_Q,\n  LIBRAW_MOUNT_RicohModule,\n  LIBRAW_MOUNT_Rollei_bayonet, /* Rollei Hy-6: Leaf AFi, Sinar Hy6- models */\n  LIBRAW_MOUNT_Samsung_NX_M,\n  LIBRAW_MOUNT_Samsung_NX,\n  LIBRAW_MOUNT_Sigma_X3F,\n  LIBRAW_MOUNT_Sony_E,\n  LIBRAW_MOUNT_LF,\n  LIBRAW_MOUNT_DigitalBack,\n  LIBRAW_MOUNT_FixedLens,\n  LIBRAW_MOUNT_IL_UM,          /* Interchangeable lens, mount unknown */\n  LIBRAW_MOUNT_TheLastOne\n};\n\nenum LibRaw_camera_formats\n{\n  LIBRAW_FORMAT_Unknown = 0,\n  LIBRAW_FORMAT_APSC,\n  LIBRAW_FORMAT_FF,\n  LIBRAW_FORMAT_MF,\n  LIBRAW_FORMAT_APSH,\n  LIBRAW_FORMAT_1INCH,\n  LIBRAW_FORMAT_1div2p3INCH,  /* 1/2.3\" */\n  LIBRAW_FORMAT_1div1p7INCH,  /* 1/1.7\" */\n  LIBRAW_FORMAT_FT,           /* sensor size in FT & mFT cameras */\n  LIBRAW_FORMAT_CROP645,      /* 44x33mm */\n  LIBRAW_FORMAT_LeicaS,       /* 'MF' Leicas */\n  LIBRAW_FORMAT_645,\n  LIBRAW_FORMAT_66,\n  LIBRAW_FORMAT_69,\n  LIBRAW_FORMAT_LF,\n  LIBRAW_FORMAT_Leica_DMR,\n  LIBRAW_FORMAT_67,\n  LIBRAW_FORMAT_SigmaAPSC,    /* DP1, DP2, SD15, SD14, SD10, SD9 */\n  LIBRAW_FORMAT_SigmaMerrill, /* SD1,  'SD1 Merrill',  'DP1 Merrill',  'DP2 Merrill' */\n  LIBRAW_FORMAT_SigmaAPSH,    /* 'sd Quattro H' */\n  LIBRAW_FORMAT_3648,         /* DALSA FTF4052C (Mamiya ZD) */\n  LIBRAW_FORMAT_68,           /* Fujifilm GX680 */\n  LIBRAW_FORMAT_TheLastOne\n};\n\nenum LibRawImageAspects\n{\n  LIBRAW_IMAGE_ASPECT_UNKNOWN = 0,\n  LIBRAW_IMAGE_ASPECT_3to2 = 1,\n  LIBRAW_IMAGE_ASPECT_1to1 = 2,\n  LIBRAW_IMAGE_ASPECT_4to3 = 3,\n  LIBRAW_IMAGE_ASPECT_16to9 = 4,\n  LIBRAW_IMAGE_ASPECT_5to4 = 5,\n  LIBRAW_IMAGE_ASPECT_OTHER = 6\n};\n\nenum LibRaw_lens_focal_types\n{\n  LIBRAW_FT_UNDEFINED = 0,\n  LIBRAW_FT_PRIME_LENS = 1,\n  LIBRAW_FT_ZOOM_LENS = 2,\n  LIBRAW_FT_ZOOM_LENS_CONSTANT_APERTURE = 3,\n  LIBRAW_FT_ZOOM_LENS_VARIABLE_APERTURE = 4\n};\n\nenum LibRaw_Canon_RecordModes {\n  LIBRAW_Canon_RecordMode_UNDEFINED = 0,\n  LIBRAW_Canon_RecordMode_JPEG,\n  LIBRAW_Canon_RecordMode_CRW_THM,\n  LIBRAW_Canon_RecordMode_AVI_THM,\n  LIBRAW_Canon_RecordMode_TIF,\n  LIBRAW_Canon_RecordMode_TIF_JPEG,\n  LIBRAW_Canon_RecordMode_CR2,\n  LIBRAW_Canon_RecordMode_CR2_JPEG,\n  LIBRAW_Canon_RecordMode_UNKNOWN,\n  LIBRAW_Canon_RecordMode_MOV,\n  LIBRAW_Canon_RecordMode_MP4,\n  LIBRAW_Canon_RecordMode_CRM,\n  LIBRAW_Canon_RecordMode_CR3,\n  LIBRAW_Canon_RecordMode_CR3_JPEG,\n  LIBRAW_Canon_RecordMode_HEIF,\n  LIBRAW_Canon_RecordMode_CR3_HEIF,\n  LIBRAW_Canon_RecordMode_TheLastOne\n};\n\nenum LibRaw_sony_cameratypes\n{\n  LIBRAW_SONY_DSC = 1,\n  LIBRAW_SONY_DSLR = 2,\n  LIBRAW_SONY_NEX = 3,\n  LIBRAW_SONY_SLT = 4,\n  LIBRAW_SONY_ILCE = 5,\n  LIBRAW_SONY_ILCA = 6\n};\n\nenum LibRaw_KodakSensors\n{\n  LIBRAW_Kodak_UnknownSensor = 0,\n  LIBRAW_Kodak_M1 = 1,\n  LIBRAW_Kodak_M15 = 2,\n  LIBRAW_Kodak_M16 = 3,\n  LIBRAW_Kodak_M17 = 4,\n  LIBRAW_Kodak_M2 = 5,\n  LIBRAW_Kodak_M23 = 6,\n  LIBRAW_Kodak_M24 = 7,\n  LIBRAW_Kodak_M3 = 8,\n  LIBRAW_Kodak_M5 = 9,\n  LIBRAW_Kodak_M6 = 10,\n  LIBRAW_Kodak_C14 = 11,\n  LIBRAW_Kodak_X14 = 12,\n  LIBRAW_Kodak_M11 = 13\n};\n\nenum LibRaw_HasselbladFormatCodes {\n  LIBRAW_HF_Unknown = 0,\n  LIBRAW_HF_3FR,\n  LIBRAW_HF_FFF,\n  LIBRAW_HF_Imacon,\n  LIBRAW_HF_HasselbladDNG,\n  LIBRAW_HF_AdobeDNG,\n  LIBRAW_HF_AdobeDNG_fromPhocusDNG\n};\n\nenum LibRaw_processing_options\n{\n  LIBRAW_PROCESSING_SONYARW2_NONE = 0,\n  LIBRAW_PROCESSING_SONYARW2_BASEONLY = 1,\n  LIBRAW_PROCESSING_SONYARW2_DELTAONLY = 1 << 1,\n  LIBRAW_PROCESSING_SONYARW2_DELTAZEROBASE = 1 << 2,\n  LIBRAW_PROCESSING_SONYARW2_DELTATOVALUE = 1 << 3,\n  LIBRAW_PROCESSING_SONYARW2_ALLFLAGS =\n      LIBRAW_PROCESSING_SONYARW2_BASEONLY +\n      LIBRAW_PROCESSING_SONYARW2_DELTAONLY +\n      LIBRAW_PROCESSING_SONYARW2_DELTAZEROBASE +\n      LIBRAW_PROCESSING_SONYARW2_DELTATOVALUE,\n  LIBRAW_PROCESSING_DP2Q_INTERPOLATERG = 1 << 4,\n  LIBRAW_PROCESSING_DP2Q_INTERPOLATEAF = 1 << 5,\n  LIBRAW_PROCESSING_PENTAX_PS_ALLFRAMES = 1 << 6,\n  LIBRAW_PROCESSING_CONVERTFLOAT_TO_INT = 1 << 7,\n  LIBRAW_PROCESSING_SRAW_NO_RGB = 1 << 8,\n  LIBRAW_PROCESSING_SRAW_NO_INTERPOLATE = 1 << 9,\n  LIBRAW_PROCESSING_ARQ_SKIP_CHANNEL_SWAP = 1 << 10,\n  LIBRAW_PROCESSING_NO_ROTATE_FOR_KODAK_THUMBNAILS = 1 << 11,\n  LIBRAW_PROCESSING_USE_DNG_DEFAULT_CROP = 1 << 12,\n  LIBRAW_PROCESSING_USE_PPM16_THUMBS = 1 << 13,\n  LIBRAW_PROCESSING_SKIP_MAKERNOTES = 1 << 14,\n  LIBRAW_PROCESSING_DONT_CHECK_DNG_ILLUMINANT = 1 << 15,\n  LIBRAW_PROCESSING_DNGSDK_ZEROCOPY = 1 << 16,\n  LIBRAW_PROCESSING_ZEROFILTERS_FOR_MONOCHROMETIFFS = 1 << 17,\n  LIBRAW_PROCESSING_DNG_ADD_ENHANCED = 1 << 18,\n  LIBRAW_PROCESSING_DNG_ADD_PREVIEWS = 1 << 19,\n  LIBRAW_PROCESSING_DNG_PREFER_LARGEST_IMAGE = 1 << 20,\n  LIBRAW_PROCESSING_DNG_STAGE2 = 1 << 21,\n  LIBRAW_PROCESSING_DNG_STAGE3 = 1 << 22,\n  LIBRAW_PROCESSING_DNG_ALLOWSIZECHANGE = 1 << 23,\n  LIBRAW_PROCESSING_DNG_DISABLEWBADJUST = 1 << 24\n};\n\nenum LibRaw_decoder_flags\n{\n  LIBRAW_DECODER_HASCURVE = 1 << 4,\n  LIBRAW_DECODER_SONYARW2 = 1 << 5,\n  LIBRAW_DECODER_TRYRAWSPEED = 1 << 6,\n  LIBRAW_DECODER_OWNALLOC = 1 << 7,\n  LIBRAW_DECODER_FIXEDMAXC = 1 << 8,\n  LIBRAW_DECODER_ADOBECOPYPIXEL = 1 << 9,\n  LIBRAW_DECODER_LEGACY_WITH_MARGINS = 1 << 10,\n  LIBRAW_DECODER_3CHANNEL = 1 << 11,\n  LIBRAW_DECODER_SINAR4SHOT = 1 << 11,\n  LIBRAW_DECODER_FLATDATA = 1 << 12,\n  LIBRAW_DECODER_FLAT_BG2_SWAPPED = 1<<13,\n  LIBRAW_DECODER_NOTSET = 1 << 15\n};\n\n#define LIBRAW_XTRANS 9\n\nenum LibRaw_constructor_flags\n{\n  LIBRAW_OPTIONS_NONE = 0,\n  LIBRAW_OPIONS_NO_MEMERR_CALLBACK = 1,\n  LIBRAW_OPIONS_NO_DATAERR_CALLBACK = 1 << 1\n};\n\nenum LibRaw_warnings\n{\n  LIBRAW_WARN_NONE = 0,\n  LIBRAW_WARN_BAD_CAMERA_WB = 1 << 2,\n  LIBRAW_WARN_NO_METADATA = 1 << 3,\n  LIBRAW_WARN_NO_JPEGLIB = 1 << 4,\n  LIBRAW_WARN_NO_EMBEDDED_PROFILE = 1 << 5,\n  LIBRAW_WARN_NO_INPUT_PROFILE = 1 << 6,\n  LIBRAW_WARN_BAD_OUTPUT_PROFILE = 1 << 7,\n  LIBRAW_WARN_NO_BADPIXELMAP = 1 << 8,\n  LIBRAW_WARN_BAD_DARKFRAME_FILE = 1 << 9,\n  LIBRAW_WARN_BAD_DARKFRAME_DIM = 1 << 10,\n  LIBRAW_WARN_NO_JASPER = 1 << 11,\n  LIBRAW_WARN_RAWSPEED_PROBLEM = 1 << 12,\n  LIBRAW_WARN_RAWSPEED_UNSUPPORTED = 1 << 13,\n  LIBRAW_WARN_RAWSPEED_PROCESSED = 1 << 14,\n  LIBRAW_WARN_FALLBACK_TO_AHD = 1 << 15,\n  LIBRAW_WARN_PARSEFUJI_PROCESSED = 1 << 16,\n  LIBRAW_WARN_DNGSDK_PROCESSED = 1 << 17,\n  LIBRAW_WARN_DNG_IMAGES_REORDERED = 1 << 18,\n  LIBRAW_WARN_DNG_STAGE2_APPLIED = 1 << 19,\n  LIBRAW_WARN_DNG_STAGE3_APPLIED = 1 << 20,\n};\n\nenum LibRaw_exceptions\n{\n  LIBRAW_EXCEPTION_NONE = 0,\n  LIBRAW_EXCEPTION_ALLOC = 1,\n  LIBRAW_EXCEPTION_DECODE_RAW = 2,\n  LIBRAW_EXCEPTION_DECODE_JPEG = 3,\n  LIBRAW_EXCEPTION_IO_EOF = 4,\n  LIBRAW_EXCEPTION_IO_CORRUPT = 5,\n  LIBRAW_EXCEPTION_CANCELLED_BY_CALLBACK = 6,\n  LIBRAW_EXCEPTION_BAD_CROP = 7,\n  LIBRAW_EXCEPTION_IO_BADFILE = 8,\n  LIBRAW_EXCEPTION_DECODE_JPEG2000 = 9,\n  LIBRAW_EXCEPTION_TOOBIG = 10,\n  LIBRAW_EXCEPTION_MEMPOOL = 11\n};\n\nenum LibRaw_progress\n{\n  LIBRAW_PROGRESS_START = 0,\n  LIBRAW_PROGRESS_OPEN = 1,\n  LIBRAW_PROGRESS_IDENTIFY = 1 << 1,\n  LIBRAW_PROGRESS_SIZE_ADJUST = 1 << 2,\n  LIBRAW_PROGRESS_LOAD_RAW = 1 << 3,\n  LIBRAW_PROGRESS_RAW2_IMAGE = 1 << 4,\n  LIBRAW_PROGRESS_REMOVE_ZEROES = 1 << 5,\n  LIBRAW_PROGRESS_BAD_PIXELS = 1 << 6,\n  LIBRAW_PROGRESS_DARK_FRAME = 1 << 7,\n  LIBRAW_PROGRESS_FOVEON_INTERPOLATE = 1 << 8,\n  LIBRAW_PROGRESS_SCALE_COLORS = 1 << 9,\n  LIBRAW_PROGRESS_PRE_INTERPOLATE = 1 << 10,\n  LIBRAW_PROGRESS_INTERPOLATE = 1 << 11,\n  LIBRAW_PROGRESS_MIX_GREEN = 1 << 12,\n  LIBRAW_PROGRESS_MEDIAN_FILTER = 1 << 13,\n  LIBRAW_PROGRESS_HIGHLIGHTS = 1 << 14,\n  LIBRAW_PROGRESS_FUJI_ROTATE = 1 << 15,\n  LIBRAW_PROGRESS_FLIP = 1 << 16,\n  LIBRAW_PROGRESS_APPLY_PROFILE = 1 << 17,\n  LIBRAW_PROGRESS_CONVERT_RGB = 1 << 18,\n  LIBRAW_PROGRESS_STRETCH = 1 << 19,\n  /* reserved */\n  LIBRAW_PROGRESS_STAGE20 = 1 << 20,\n  LIBRAW_PROGRESS_STAGE21 = 1 << 21,\n  LIBRAW_PROGRESS_STAGE22 = 1 << 22,\n  LIBRAW_PROGRESS_STAGE23 = 1 << 23,\n  LIBRAW_PROGRESS_STAGE24 = 1 << 24,\n  LIBRAW_PROGRESS_STAGE25 = 1 << 25,\n  LIBRAW_PROGRESS_STAGE26 = 1 << 26,\n  LIBRAW_PROGRESS_STAGE27 = 1 << 27,\n\n  LIBRAW_PROGRESS_THUMB_LOAD = 1 << 28,\n  LIBRAW_PROGRESS_TRESERVED1 = 1 << 29,\n  LIBRAW_PROGRESS_TRESERVED2 = 1 << 30\n};\n#define LIBRAW_PROGRESS_THUMB_MASK 0x0fffffff\n\nenum LibRaw_errors\n{\n  LIBRAW_SUCCESS = 0,\n  LIBRAW_UNSPECIFIED_ERROR = -1,\n  LIBRAW_FILE_UNSUPPORTED = -2,\n  LIBRAW_REQUEST_FOR_NONEXISTENT_IMAGE = -3,\n  LIBRAW_OUT_OF_ORDER_CALL = -4,\n  LIBRAW_NO_THUMBNAIL = -5,\n  LIBRAW_UNSUPPORTED_THUMBNAIL = -6,\n  LIBRAW_INPUT_CLOSED = -7,\n  LIBRAW_NOT_IMPLEMENTED = -8,\n  LIBRAW_UNSUFFICIENT_MEMORY = -100007,\n  LIBRAW_DATA_ERROR = -100008,\n  LIBRAW_IO_ERROR = -100009,\n  LIBRAW_CANCELLED_BY_CALLBACK = -100010,\n  LIBRAW_BAD_CROP = -100011,\n  LIBRAW_TOO_BIG = -100012,\n  LIBRAW_MEMPOOL_OVERFLOW = -100013\n};\n\n#define LIBRAW_FATAL_ERROR(ec) ((ec) < -100000)\n\nenum LibRaw_thumbnail_formats\n{\n  LIBRAW_THUMBNAIL_UNKNOWN = 0,\n  LIBRAW_THUMBNAIL_JPEG = 1,\n  LIBRAW_THUMBNAIL_BITMAP = 2,\n  LIBRAW_THUMBNAIL_BITMAP16 = 3,\n  LIBRAW_THUMBNAIL_LAYER = 4,\n  LIBRAW_THUMBNAIL_ROLLEI = 5\n};\n\nenum LibRaw_image_formats\n{\n  LIBRAW_IMAGE_JPEG = 1,\n  LIBRAW_IMAGE_BITMAP = 2\n};\n\n#endif\n", "/* -*- C++ -*-\n * Copyright 2019-2020 LibRaw LLC (info@libraw.org)\n *\n LibRaw is free software; you can redistribute it and/or modify\n it under the terms of the one of two licenses as you choose:\n\n1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1\n   (See file LICENSE.LGPL provided in LibRaw distribution archive for details).\n\n2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0\n   (See file LICENSE.CDDL provided in LibRaw distribution archive for details).\n\n */\n\n#include \"../../internal/libraw_cxx_defs.h\"\n\n#ifndef NO_JPEG\nstruct jpegErrorManager\n{\n  struct jpeg_error_mgr pub;\n  jmp_buf setjmp_buffer;\n};\n\nstatic void jpegErrorExit(j_common_ptr cinfo)\n{\n  jpegErrorManager *myerr = (jpegErrorManager *)cinfo->err;\n  longjmp(myerr->setjmp_buffer, 1);\n}\n#endif\n\nint LibRaw::unpack_thumb(void)\n{\n  CHECK_ORDER_LOW(LIBRAW_PROGRESS_IDENTIFY);\n  CHECK_ORDER_BIT(LIBRAW_PROGRESS_THUMB_LOAD);\n\n  try\n  {\n    if (!libraw_internal_data.internal_data.input)\n      return LIBRAW_INPUT_CLOSED;\n\n    int t_colors = libraw_internal_data.unpacker_data.thumb_misc >> 5 & 7;\n    int t_bytesps = (libraw_internal_data.unpacker_data.thumb_misc & 31) / 8;\n\n    if (!ID.toffset && !(imgdata.thumbnail.tlength > 0 &&\n                         load_raw == &LibRaw::broadcom_load_raw) // RPi\n    )\n    {\n      return LIBRAW_NO_THUMBNAIL;\n    }\n    else if (thumb_load_raw)\n    {\n      kodak_thumb_loader();\n      T.tformat = LIBRAW_THUMBNAIL_BITMAP;\n      SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n      return 0;\n    }\n    else\n    {\n#ifdef USE_X3FTOOLS\n\tif (write_thumb == &LibRaw::x3f_thumb_loader)\n      {\n        INT64 tsize = x3f_thumb_size();\n        if (tsize < 2048 || INT64(ID.toffset) + tsize < 1)\n          throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n        if (INT64(ID.toffset) + tsize > ID.input->size() + THUMB_READ_BEYOND)\n          throw LIBRAW_EXCEPTION_IO_EOF;\n      }\n#else\n\tif (0) {}\n#endif\n      else\n      {\n        if (INT64(ID.toffset) + INT64(T.tlength) < 1)\n          throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n        if (INT64(ID.toffset) + INT64(T.tlength) >\n            ID.input->size() + THUMB_READ_BEYOND)\n          throw LIBRAW_EXCEPTION_IO_EOF;\n      }\n\n      ID.input->seek(ID.toffset, SEEK_SET);\n      if (write_thumb == &LibRaw::jpeg_thumb)\n      {\n        if (T.thumb)\n          free(T.thumb);\n        T.thumb = (char *)malloc(T.tlength);\n        merror(T.thumb, \"jpeg_thumb()\");\n        ID.input->read(T.thumb, 1, T.tlength);\n        unsigned char *tthumb = (unsigned char *)T.thumb;\n        tthumb[0] = 0xff;\n        tthumb[1] = 0xd8;\n#ifdef NO_JPEG\n        T.tcolors = 3;\n#else\n        {\n          jpegErrorManager jerr;\n          struct jpeg_decompress_struct cinfo;\n          cinfo.err = jpeg_std_error(&jerr.pub);\n          jerr.pub.error_exit = jpegErrorExit;\n          if (setjmp(jerr.setjmp_buffer))\n          {\n          err2:\n            // Error in original JPEG thumb, read it again because\n            // original bytes 0-1 was damaged above\n            jpeg_destroy_decompress(&cinfo);\n            T.tcolors = 3;\n            T.tformat = LIBRAW_THUMBNAIL_UNKNOWN;\n            ID.input->seek(ID.toffset, SEEK_SET);\n            ID.input->read(T.thumb, 1, T.tlength);\n            SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n            return 0;\n          }\n          jpeg_create_decompress(&cinfo);\n          jpeg_mem_src(&cinfo, (unsigned char *)T.thumb, T.tlength);\n          int rc = jpeg_read_header(&cinfo, TRUE);\n          if (rc != 1)\n            goto err2;\n          T.tcolors = (cinfo.num_components > 0 && cinfo.num_components <= 3)\n                          ? cinfo.num_components\n                          : 3;\n          jpeg_destroy_decompress(&cinfo);\n        }\n#endif\n        T.tformat = LIBRAW_THUMBNAIL_JPEG;\n        SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n        return 0;\n      }\n      else if (write_thumb == &LibRaw::layer_thumb)\n      {\n        int colors = libraw_internal_data.unpacker_data.thumb_misc >> 5 & 7;\n        if (colors != 1 && colors != 3)\n          return LIBRAW_UNSUPPORTED_THUMBNAIL;\n\n        int tlength = T.twidth * T.theight;\n        if (T.thumb)\n          free(T.thumb);\n        T.thumb = (char *)calloc(colors, tlength);\n        merror(T.thumb, \"layer_thumb()\");\n        unsigned char *tbuf = (unsigned char *)calloc(colors, tlength);\n        merror(tbuf, \"layer_thumb()\");\n        ID.input->read(tbuf, colors, T.tlength);\n        if (libraw_internal_data.unpacker_data.thumb_misc >> 8 &&\n            colors == 3) // GRB order\n          for (int i = 0; i < tlength; i++)\n          {\n            T.thumb[i * 3] = tbuf[i + tlength];\n            T.thumb[i * 3 + 1] = tbuf[i];\n            T.thumb[i * 3 + 2] = tbuf[i + 2 * tlength];\n          }\n        else if (colors == 3) // RGB or 1-channel\n          for (int i = 0; i < tlength; i++)\n          {\n            T.thumb[i * 3] = tbuf[i];\n            T.thumb[i * 3 + 1] = tbuf[i + tlength];\n            T.thumb[i * 3 + 2] = tbuf[i + 2 * tlength];\n          }\n        else if (colors == 1)\n        {\n          free(T.thumb);\n          T.thumb = (char *)tbuf;\n          tbuf = 0;\n        }\n        if (tbuf)\n          free(tbuf);\n        T.tcolors = colors;\n        T.tlength = colors * tlength;\n        T.tformat = LIBRAW_THUMBNAIL_BITMAP;\n        SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n        return 0;\n      }\n      else if (write_thumb == &LibRaw::rollei_thumb)\n      {\n        int i;\n        int tlength = T.twidth * T.theight;\n        if (T.thumb)\n          free(T.thumb);\n        T.tcolors = 3;\n        T.thumb = (char *)calloc(T.tcolors, tlength);\n        merror(T.thumb, \"layer_thumb()\");\n        unsigned short *tbuf = (unsigned short *)calloc(2, tlength);\n        merror(tbuf, \"layer_thumb()\");\n        read_shorts(tbuf, tlength);\n        for (i = 0; i < tlength; i++)\n        {\n          T.thumb[i * 3] = (tbuf[i] << 3) & 0xff;\n          T.thumb[i * 3 + 1] = (tbuf[i] >> 5 << 2) & 0xff;\n          T.thumb[i * 3 + 2] = (tbuf[i] >> 11 << 3) & 0xff;\n        }\n        free(tbuf);\n        T.tlength = T.tcolors * tlength;\n        T.tformat = LIBRAW_THUMBNAIL_BITMAP;\n        SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n        return 0;\n      }\n      else if (write_thumb == &LibRaw::ppm_thumb)\n      {\n        if (t_bytesps > 1)\n          throw LIBRAW_EXCEPTION_IO_CORRUPT; // 8-bit thumb, but parsed for more\n                                             // bits\n        int t_length = T.twidth * T.theight * t_colors;\n\n        if (T.tlength &&\n            (int)T.tlength < t_length) // try to find tiff ifd with needed offset\n        {\n          int pifd = find_ifd_by_offset(libraw_internal_data.internal_data.toffset);\n          if (pifd >= 0 && tiff_ifd[pifd].strip_offsets_count &&\n              tiff_ifd[pifd].strip_byte_counts_count)\n          {\n            // We found it, calculate final size\n            unsigned total_size = 0;\n            for (int i = 0; i < tiff_ifd[pifd].strip_byte_counts_count; i++)\n              total_size += tiff_ifd[pifd].strip_byte_counts[i];\n            if (total_size != (unsigned)t_length) // recalculate colors\n            {\n              if (total_size == T.twidth * T.tlength * 3)\n                T.tcolors = 3;\n              else if (total_size == T.twidth * T.tlength)\n                T.tcolors = 1;\n            }\n            T.tlength = total_size;\n            if (T.thumb)\n              free(T.thumb);\n            T.thumb = (char *)malloc(T.tlength);\n            merror(T.thumb, \"ppm_thumb()\");\n\n            char *dest = T.thumb;\n            INT64 pos = ID.input->tell();\n\n            for (int i = 0; i < tiff_ifd[pifd].strip_byte_counts_count &&\n                            i < tiff_ifd[pifd].strip_offsets_count;\n                 i++)\n            {\n              int remain = T.tlength;\n              int sz = tiff_ifd[pifd].strip_byte_counts[i];\n              int off = tiff_ifd[pifd].strip_offsets[i];\n              if (off >= 0 && off + sz <= ID.input->size() && sz <= remain)\n              {\n                ID.input->seek(off, SEEK_SET);\n                ID.input->read(dest, sz, 1);\n                remain -= sz;\n                dest += sz;\n              }\n            }\n            ID.input->seek(pos, SEEK_SET);\n            T.tformat = LIBRAW_THUMBNAIL_BITMAP;\n            SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n            return 0;\n          }\n        }\n\n        if (!T.tlength)\n          T.tlength = t_length;\n        if (T.thumb)\n          free(T.thumb);\n\n        T.thumb = (char *)malloc(T.tlength);\n        if (!T.tcolors)\n          T.tcolors = t_colors;\n        merror(T.thumb, \"ppm_thumb()\");\n\n        ID.input->read(T.thumb, 1, T.tlength);\n\n        T.tformat = LIBRAW_THUMBNAIL_BITMAP;\n        SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n        return 0;\n      }\n      else if (write_thumb == &LibRaw::ppm16_thumb)\n      {\n        if (t_bytesps > 2)\n          throw LIBRAW_EXCEPTION_IO_CORRUPT; // 16-bit thumb, but parsed for\n                                             // more bits\n        int o_bps = (imgdata.params.raw_processing_options &\n                     LIBRAW_PROCESSING_USE_PPM16_THUMBS)\n                        ? 2\n                        : 1;\n        int o_length = T.twidth * T.theight * t_colors * o_bps;\n        int i_length = T.twidth * T.theight * t_colors * 2;\n        if (!T.tlength)\n          T.tlength = o_length;\n        ushort *t_thumb = (ushort *)calloc(i_length, 1);\n        ID.input->read(t_thumb, 1, i_length);\n        if ((libraw_internal_data.unpacker_data.order == 0x4949) ==\n            (ntohs(0x1234) == 0x1234))\n          swab((char *)t_thumb, (char *)t_thumb, i_length);\n\n        if (T.thumb)\n          free(T.thumb);\n        if ((imgdata.params.raw_processing_options &\n             LIBRAW_PROCESSING_USE_PPM16_THUMBS))\n        {\n          T.thumb = (char *)t_thumb;\n          T.tformat = LIBRAW_THUMBNAIL_BITMAP16;\n        }\n        else\n        {\n          T.thumb = (char *)malloc(o_length);\n          merror(T.thumb, \"ppm_thumb()\");\n          for (int i = 0; i < o_length; i++)\n            T.thumb[i] = t_thumb[i] >> 8;\n          free(t_thumb);\n          T.tformat = LIBRAW_THUMBNAIL_BITMAP;\n        }\n        SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n        return 0;\n      }\n#ifdef USE_X3FTOOLS\n\t  else if (write_thumb == &LibRaw::x3f_thumb_loader)\n      {\n        x3f_thumb_loader();\n        SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n        return 0;\n      }\n#endif\n      else\n      {\n        return LIBRAW_UNSUPPORTED_THUMBNAIL;\n      }\n    }\n    // last resort\n    return LIBRAW_UNSUPPORTED_THUMBNAIL;\n  }\n  catch (LibRaw_exceptions err)\n  {\n    EXCEPTION_HANDLER(err);\n  }\n}\n", "/* -*- C++ -*-\n * Copyright 2019-2020 LibRaw LLC (info@libraw.org)\n *\n LibRaw is free software; you can redistribute it and/or modify\n it under the terms of the one of two licenses as you choose:\n\n1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1\n   (See file LICENSE.LGPL provided in LibRaw distribution archive for details).\n\n2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0\n   (See file LICENSE.CDDL provided in LibRaw distribution archive for details).\n\n */\n\n#include \"../../internal/libraw_cxx_defs.h\"\n\nlibraw_processed_image_t *LibRaw::dcraw_make_mem_thumb(int *errcode)\n{\n  if (!T.thumb)\n  {\n    if (!ID.toffset && !(imgdata.thumbnail.tlength > 0 &&\n                         load_raw == &LibRaw::broadcom_load_raw) // RPi\n    )\n    {\n      if (errcode)\n        *errcode = LIBRAW_NO_THUMBNAIL;\n    }\n    else\n    {\n      if (errcode)\n        *errcode = LIBRAW_OUT_OF_ORDER_CALL;\n    }\n    return NULL;\n  }\n\n  if (T.tformat == LIBRAW_THUMBNAIL_BITMAP)\n  {\n    libraw_processed_image_t *ret = (libraw_processed_image_t *)::malloc(\n        sizeof(libraw_processed_image_t) + T.tlength);\n\n    if (!ret)\n    {\n      if (errcode)\n        *errcode = ENOMEM;\n      return NULL;\n    }\n\n    memset(ret, 0, sizeof(libraw_processed_image_t));\n    ret->type = LIBRAW_IMAGE_BITMAP;\n    ret->height = T.theight;\n    ret->width = T.twidth;\n    ret->colors = 3;\n    ret->bits = 8;\n    ret->data_size = T.tlength;\n    memmove(ret->data, T.thumb, T.tlength);\n    if (errcode)\n      *errcode = 0;\n    return ret;\n  }\n  else if (T.tformat == LIBRAW_THUMBNAIL_JPEG)\n  {\n    ushort exif[5];\n    int mk_exif = 0;\n    if (strcmp(T.thumb + 6, \"Exif\"))\n      mk_exif = 1;\n\n    int dsize = T.tlength + mk_exif * (sizeof(exif) + sizeof(tiff_hdr));\n\n    libraw_processed_image_t *ret = (libraw_processed_image_t *)::malloc(\n        sizeof(libraw_processed_image_t) + dsize);\n\n    if (!ret)\n    {\n      if (errcode)\n        *errcode = ENOMEM;\n      return NULL;\n    }\n\n    memset(ret, 0, sizeof(libraw_processed_image_t));\n\n    ret->type = LIBRAW_IMAGE_JPEG;\n    ret->data_size = dsize;\n\n    ret->data[0] = 0xff;\n    ret->data[1] = 0xd8;\n    if (mk_exif)\n    {\n      struct tiff_hdr th;\n      memcpy(exif, \"\\xff\\xe1  Exif\\0\\0\", 10);\n      exif[1] = htons(8 + sizeof th);\n      memmove(ret->data + 2, exif, sizeof(exif));\n      tiff_head(&th, 0);\n      memmove(ret->data + (2 + sizeof(exif)), &th, sizeof(th));\n      memmove(ret->data + (2 + sizeof(exif) + sizeof(th)), T.thumb + 2,\n              T.tlength - 2);\n    }\n    else\n    {\n      memmove(ret->data + 2, T.thumb + 2, T.tlength - 2);\n    }\n    if (errcode)\n      *errcode = 0;\n    return ret;\n  }\n  else\n  {\n    if (errcode)\n      *errcode = LIBRAW_UNSUPPORTED_THUMBNAIL;\n    return NULL;\n  }\n}\n\n// jlb\n// macros for copying pixels to either BGR or RGB formats\n#define FORBGR for (c = P1.colors - 1; c >= 0; c--)\n#define FORRGB for (c = 0; c < P1.colors; c++)\n\nvoid LibRaw::get_mem_image_format(int *width, int *height, int *colors,\n                                  int *bps) const\n\n{\n  *width = S.width;\n  *height = S.height;\n  if (imgdata.progress_flags < LIBRAW_PROGRESS_FUJI_ROTATE)\n  {\n    if (O.use_fuji_rotate)\n    {\n      if (IO.fuji_width)\n      {\n        int fuji_width = (IO.fuji_width - 1 + IO.shrink) >> IO.shrink;\n        *width = (ushort)(fuji_width / sqrt(0.5));\n        *height = (ushort)((*height - fuji_width) / sqrt(0.5));\n      }\n      else\n      {\n        if (S.pixel_aspect < 0.995)\n          *height = (ushort)(*height / S.pixel_aspect + 0.5);\n        if (S.pixel_aspect > 1.005)\n          *width = (ushort)(*width * S.pixel_aspect + 0.5);\n      }\n    }\n  }\n  if (S.flip & 4)\n  {\n    std::swap(*width, *height);\n  }\n  *colors = P1.colors;\n  *bps = O.output_bps;\n}\n\nint LibRaw::copy_mem_image(void *scan0, int stride, int bgr)\n\n{\n  // the image memory pointed to by scan0 is assumed to be in the format\n  // returned by get_mem_image_format\n  if ((imgdata.progress_flags & LIBRAW_PROGRESS_THUMB_MASK) <\n      LIBRAW_PROGRESS_PRE_INTERPOLATE)\n    return LIBRAW_OUT_OF_ORDER_CALL;\n\n  if (libraw_internal_data.output_data.histogram)\n  {\n    int perc, val, total, t_white = 0x2000, c;\n    perc = S.width * S.height * O.auto_bright_thr;\n    if (IO.fuji_width)\n      perc /= 2;\n    if (!((O.highlight & ~2) || O.no_auto_bright))\n      for (t_white = c = 0; c < P1.colors; c++)\n      {\n        for (val = 0x2000, total = 0; --val > 32;)\n          if ((total += libraw_internal_data.output_data.histogram[c][val]) >\n              perc)\n            break;\n        if (t_white < val)\n          t_white = val;\n      }\n    gamma_curve(O.gamm[0], O.gamm[1], 2, (t_white << 3) / O.bright);\n  }\n\n  int s_iheight = S.iheight;\n  int s_iwidth = S.iwidth;\n  int s_width = S.width;\n  int s_hwight = S.height;\n\n  S.iheight = S.height;\n  S.iwidth = S.width;\n\n  if (S.flip & 4)\n    SWAP(S.height, S.width);\n  uchar *ppm;\n  ushort *ppm2;\n  int c, row, col, soff, rstep, cstep;\n\n  soff = flip_index(0, 0);\n  cstep = flip_index(0, 1) - soff;\n  rstep = flip_index(1, 0) - flip_index(0, S.width);\n\n  for (row = 0; row < S.height; row++, soff += rstep)\n  {\n    uchar *bufp = ((uchar *)scan0) + row * stride;\n    ppm2 = (ushort *)(ppm = bufp);\n    // keep trivial decisions in the outer loop for speed\n    if (bgr)\n    {\n      if (O.output_bps == 8)\n      {\n        for (col = 0; col < S.width; col++, soff += cstep)\n          FORBGR *ppm++ = imgdata.color.curve[imgdata.image[soff][c]] >> 8;\n      }\n      else\n      {\n        for (col = 0; col < S.width; col++, soff += cstep)\n          FORBGR *ppm2++ = imgdata.color.curve[imgdata.image[soff][c]];\n      }\n    }\n    else\n    {\n      if (O.output_bps == 8)\n      {\n        for (col = 0; col < S.width; col++, soff += cstep)\n          FORRGB *ppm++ = imgdata.color.curve[imgdata.image[soff][c]] >> 8;\n      }\n      else\n      {\n        for (col = 0; col < S.width; col++, soff += cstep)\n          FORRGB *ppm2++ = imgdata.color.curve[imgdata.image[soff][c]];\n      }\n    }\n\n    //            bufp += stride;           // go to the next line\n  }\n\n  S.iheight = s_iheight;\n  S.iwidth = s_iwidth;\n  S.width = s_width;\n  S.height = s_hwight;\n\n  return 0;\n}\n#undef FORBGR\n#undef FORRGB\n\nlibraw_processed_image_t *LibRaw::dcraw_make_mem_image(int *errcode)\n\n{\n  int width, height, colors, bps;\n  get_mem_image_format(&width, &height, &colors, &bps);\n  int stride = width * (bps / 8) * colors;\n  unsigned ds = height * stride;\n  libraw_processed_image_t *ret = (libraw_processed_image_t *)::malloc(\n      sizeof(libraw_processed_image_t) + ds);\n  if (!ret)\n  {\n    if (errcode)\n      *errcode = ENOMEM;\n    return NULL;\n  }\n  memset(ret, 0, sizeof(libraw_processed_image_t));\n\n  // metadata init\n  ret->type = LIBRAW_IMAGE_BITMAP;\n  ret->height = height;\n  ret->width = width;\n  ret->colors = colors;\n  ret->bits = bps;\n  ret->data_size = ds;\n  copy_mem_image(ret->data, stride, 0);\n\n  return ret;\n}\n\nvoid LibRaw::dcraw_clear_mem(libraw_processed_image_t *p)\n{\n  if (p)\n    ::free(p);\n}\n", "/* -*- C++ -*-\n * Copyright 2019-2020 LibRaw LLC (info@libraw.org)\n *\n\n LibRaw is free software; you can redistribute it and/or modify\n it under the terms of the one of two licenses as you choose:\n\n1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1\n   (See file LICENSE.LGPL provided in LibRaw distribution archive for details).\n\n2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0\n   (See file LICENSE.CDDL provided in LibRaw distribution archive for details).\n\n */\n\n#include \"../../internal/libraw_cxx_defs.h\"\n\nvoid LibRaw::kodak_thumb_loader()\n{\n  INT64 est_datasize =\n      T.theight * T.twidth / 3; // is 0.3 bytes per pixel good estimate?\n  if (ID.toffset < 0)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n  if (ID.toffset + est_datasize > ID.input->size() + THUMB_READ_BEYOND)\n    throw LIBRAW_EXCEPTION_IO_EOF;\n\n  // some kodak cameras\n  ushort s_height = S.height, s_width = S.width, s_iwidth = S.iwidth,\n         s_iheight = S.iheight;\n  ushort s_flags = libraw_internal_data.unpacker_data.load_flags;\n  libraw_internal_data.unpacker_data.load_flags = 12;\n  int s_colors = P1.colors;\n  unsigned s_filters = P1.filters;\n  ushort(*s_image)[4] = imgdata.image;\n\n  S.height = T.theight;\n  S.width = T.twidth;\n  P1.filters = 0;\n\n  if (thumb_load_raw == &LibRaw::kodak_ycbcr_load_raw)\n  {\n    S.height += S.height & 1;\n    S.width += S.width & 1;\n  }\n\n  imgdata.image =\n      (ushort(*)[4])calloc(S.iheight * S.iwidth, sizeof(*imgdata.image));\n  merror(imgdata.image, \"LibRaw::kodak_thumb_loader()\");\n\n  ID.input->seek(ID.toffset, SEEK_SET);\n  // read kodak thumbnail into T.image[]\n  try\n  {\n    (this->*thumb_load_raw)();\n  }\n  catch (...)\n  {\n    free(imgdata.image);\n    imgdata.image = s_image;\n\n    T.twidth = 0;\n    S.width = s_width;\n\n    S.iwidth = s_iwidth;\n    S.iheight = s_iheight;\n\n    T.theight = 0;\n    S.height = s_height;\n\n    T.tcolors = 0;\n    P1.colors = s_colors;\n\n    P1.filters = s_filters;\n    T.tlength = 0;\n    libraw_internal_data.unpacker_data.load_flags = s_flags;\n    return;\n  }\n\n  // from scale_colors\n  {\n    double dmax;\n    float scale_mul[4];\n    int c, val;\n    for (dmax = DBL_MAX, c = 0; c < 3; c++)\n      if (dmax > C.pre_mul[c])\n        dmax = C.pre_mul[c];\n\n    for (c = 0; c < 3; c++)\n      scale_mul[c] = (C.pre_mul[c] / dmax) * 65535.0 / C.maximum;\n    scale_mul[3] = scale_mul[1];\n\n    size_t size = S.height * S.width;\n    for (unsigned i = 0; i < size * 4; i++)\n    {\n      val = imgdata.image[0][i];\n      if (!val)\n        continue;\n      val *= scale_mul[i & 3];\n      imgdata.image[0][i] = CLIP(val);\n    }\n  }\n\n  // from convert_to_rgb\n  ushort *img;\n  int row, col;\n\n  int(*t_hist)[LIBRAW_HISTOGRAM_SIZE] =\n      (int(*)[LIBRAW_HISTOGRAM_SIZE])calloc(sizeof(*t_hist), 4);\n  merror(t_hist, \"LibRaw::kodak_thumb_loader()\");\n\n  float out[3], out_cam[3][4] = {{2.81761312, -1.98369181, 0.166078627, 0},\n                                 {-0.111855984, 1.73688626, -0.625030339, 0},\n                                 {-0.0379119813, -0.891268849, 1.92918086, 0}};\n\n  for (img = imgdata.image[0], row = 0; row < S.height; row++)\n    for (col = 0; col < S.width; col++, img += 4)\n    {\n      out[0] = out[1] = out[2] = 0;\n      int c;\n      for (c = 0; c < 3; c++)\n      {\n        out[0] += out_cam[0][c] * img[c];\n        out[1] += out_cam[1][c] * img[c];\n        out[2] += out_cam[2][c] * img[c];\n      }\n      for (c = 0; c < 3; c++)\n        img[c] = CLIP((int)out[c]);\n      for (c = 0; c < P1.colors; c++)\n        t_hist[c][img[c] >> 3]++;\n    }\n\n  // from gamma_lut\n  int(*save_hist)[LIBRAW_HISTOGRAM_SIZE] =\n      libraw_internal_data.output_data.histogram;\n  libraw_internal_data.output_data.histogram = t_hist;\n\n  // make curve output curve!\n  ushort *t_curve = (ushort *)calloc(sizeof(C.curve), 1);\n  merror(t_curve, \"LibRaw::kodak_thumb_loader()\");\n  memmove(t_curve, C.curve, sizeof(C.curve));\n  memset(C.curve, 0, sizeof(C.curve));\n  {\n    int perc, val, total, t_white = 0x2000, c;\n\n    perc = S.width * S.height * 0.01; /* 99th percentile white level */\n    if (IO.fuji_width)\n      perc /= 2;\n    if (!((O.highlight & ~2) || O.no_auto_bright))\n      for (t_white = c = 0; c < P1.colors; c++)\n      {\n        for (val = 0x2000, total = 0; --val > 32;)\n          if ((total += libraw_internal_data.output_data.histogram[c][val]) >\n              perc)\n            break;\n        if (t_white < val)\n          t_white = val;\n      }\n    gamma_curve(O.gamm[0], O.gamm[1], 2, (t_white << 3) / O.bright);\n  }\n\n  libraw_internal_data.output_data.histogram = save_hist;\n  free(t_hist);\n\n  // from write_ppm_tiff - copy pixels into bitmap\n\n  int s_flip = imgdata.sizes.flip;\n  if (imgdata.params.raw_processing_options &\n      LIBRAW_PROCESSING_NO_ROTATE_FOR_KODAK_THUMBNAILS)\n    imgdata.sizes.flip = 0;\n\n  S.iheight = S.height;\n  S.iwidth = S.width;\n  if (S.flip & 4)\n    SWAP(S.height, S.width);\n\n  if (T.thumb)\n    free(T.thumb);\n  T.thumb = (char *)calloc(S.width * S.height, P1.colors);\n  merror(T.thumb, \"LibRaw::kodak_thumb_loader()\");\n  T.tlength = S.width * S.height * P1.colors;\n\n  // from write_tiff_ppm\n  {\n    int soff = flip_index(0, 0);\n    int cstep = flip_index(0, 1) - soff;\n    int rstep = flip_index(1, 0) - flip_index(0, S.width);\n\n    for (int row = 0; row < S.height; row++, soff += rstep)\n    {\n      char *ppm = T.thumb + row * S.width * P1.colors;\n      for (int col = 0; col < S.width; col++, soff += cstep)\n        for (int c = 0; c < P1.colors; c++)\n          ppm[col * P1.colors + c] =\n              imgdata.color.curve[imgdata.image[soff][c]] >> 8;\n    }\n  }\n\n  memmove(C.curve, t_curve, sizeof(C.curve));\n  free(t_curve);\n\n  // restore variables\n  free(imgdata.image);\n  imgdata.image = s_image;\n\n  if (imgdata.params.raw_processing_options &\n      LIBRAW_PROCESSING_NO_ROTATE_FOR_KODAK_THUMBNAILS)\n    imgdata.sizes.flip = s_flip;\n\n  T.twidth = S.width;\n  S.width = s_width;\n\n  S.iwidth = s_iwidth;\n  S.iheight = s_iheight;\n\n  T.theight = S.height;\n  S.height = s_height;\n\n  T.tcolors = P1.colors;\n  P1.colors = s_colors;\n\n  P1.filters = s_filters;\n  libraw_internal_data.unpacker_data.load_flags = s_flags;\n}\n\n// \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd thumbnail \ufffd\ufffd \ufffd\ufffd\ufffd\ufffd\ufffd, \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd thumb_format \ufffd \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd \ufffd \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\n\nint LibRaw::thumbOK(INT64 maxsz)\n{\n  if (!ID.input)\n    return 0;\n  if (!ID.toffset && !(imgdata.thumbnail.tlength > 0 &&\n                       load_raw == &LibRaw::broadcom_load_raw) // RPi\n  )\n    return 0;\n  INT64 fsize = ID.input->size();\n  if (fsize > 0x7fffffffU)\n    return 0; // No thumb for raw > 2Gb\n  int tsize = 0;\n  int tcol = (T.tcolors > 0 && T.tcolors < 4) ? T.tcolors : 3;\n  if (write_thumb == &LibRaw::jpeg_thumb)\n    tsize = T.tlength;\n  else if (write_thumb == &LibRaw::ppm_thumb)\n    tsize = tcol * T.twidth * T.theight;\n  else if (write_thumb == &LibRaw::ppm16_thumb)\n    tsize = tcol * T.twidth * T.theight *\n            ((imgdata.params.raw_processing_options &\n              LIBRAW_PROCESSING_USE_PPM16_THUMBS)\n                 ? 2\n                 : 1);\n#ifdef USE_X3FTOOLS\n  else if (write_thumb == &LibRaw::x3f_thumb_loader)\n  {\n    tsize = x3f_thumb_size();\n  }\n#endif\n  else // Kodak => no check\n    tsize = 1;\n  if (tsize < 0)\n    return 0;\n  if (maxsz > 0 && tsize > maxsz)\n    return 0;\n  return (tsize + ID.toffset <= fsize) ? 1 : 0;\n}\n\nint LibRaw::dcraw_thumb_writer(const char *fname)\n{\n  //    CHECK_ORDER_LOW(LIBRAW_PROGRESS_THUMB_LOAD);\n\n  if (!fname)\n    return ENOENT;\n\n  FILE *tfp = fopen(fname, \"wb\");\n\n  if (!tfp)\n    return errno;\n\n  if (!T.thumb)\n  {\n    fclose(tfp);\n    return LIBRAW_OUT_OF_ORDER_CALL;\n  }\n\n  try\n  {\n    switch (T.tformat)\n    {\n    case LIBRAW_THUMBNAIL_JPEG:\n      jpeg_thumb_writer(tfp, T.thumb, T.tlength);\n      break;\n    case LIBRAW_THUMBNAIL_BITMAP:\n      fprintf(tfp, \"P6\\n%d %d\\n255\\n\", T.twidth, T.theight);\n      fwrite(T.thumb, 1, T.tlength, tfp);\n      break;\n    default:\n      fclose(tfp);\n      return LIBRAW_UNSUPPORTED_THUMBNAIL;\n    }\n    fclose(tfp);\n    return 0;\n  }\n  catch (LibRaw_exceptions err)\n  {\n    fclose(tfp);\n    EXCEPTION_HANDLER(err);\n  }\n}\n"], "fixing_code": ["/* -*- C++ -*-\n * File: libraw_const.h\n * Copyright 2008-2020 LibRaw LLC (info@libraw.org)\n * Created: Sat Mar  8 , 2008\n * LibRaw error codes\nLibRaw is free software; you can redistribute it and/or modify\nit under the terms of the one of two licenses as you choose:\n\n1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1\n   (See file LICENSE.LGPL provided in LibRaw distribution archive for details).\n\n2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0\n   (See file LICENSE.CDDL provided in LibRaw distribution archive for details).\n\n */\n\n#ifndef _LIBRAW_ERRORS_H\n#define _LIBRAW_ERRORS_H\n\n#define LIBRAW_DEFAULT_ADJUST_MAXIMUM_THRESHOLD 0.75\n#define LIBRAW_DEFAULT_AUTO_BRIGHTNESS_THRESHOLD 0.01\n/* limit allocation size, default is 2Gb */\n#ifndef LIBRAW_MAX_ALLOC_MB_DEFAULT\n#define LIBRAW_MAX_ALLOC_MB_DEFAULT 2048L\n#endif\n\n/* limit thumbnail size, default is 512Mb*/\n#ifndef LIBRAW_MAX_THUMBNAIL_MB\n#define LIBRAW_MAX_THUMBNAIL_MB 512L\n#endif\n\n/* Check if enough file space exists before tag read */\n#ifndef LIBRAW_NO_IOSPACE_CHECK\n#define LIBRAW_IOSPACE_CHECK\n#endif\n#ifndef LIBRAW_NO_CR3_MEMPOOL\n#define LIBRAW_CR3_MEMPOOL\n#endif\n\n\n/* LibRaw uses own memory pool management, with LIBRAW_MSIZE (512)\nentries. It is enough for parsing/decoding non-damaged files, but\nmay overflow on specially crafted files (eg. with many string values\nlike XMP blocks.\nLIBRAW_MEMPOOL_CHECK define will result in error on pool overflow */\n#ifndef LIBRAW_NO_MEMPOOL_CHECK\n#define LIBRAW_MEMPOOL_CHECK\n#endif\n\n#define LIBRAW_MAX_METADATA_BLOCKS 1024\n#define LIBRAW_CBLACK_SIZE 4104\n#define LIBRAW_IFD_MAXCOUNT 10\n#define LIBRAW_CRXTRACKS_MAXCOUNT 16\n\n#define LIBRAW_AHD_TILE 512\n\nenum LibRaw_open_flags\n{\n\tLIBRAW_OPEN_BIGFILE=1,\n\tLIBRAW_OPEN_FILE= 1<<1\n};\n\nenum LibRaw_openbayer_patterns\n{\n  LIBRAW_OPENBAYER_RGGB = 0x94,\n  LIBRAW_OPENBAYER_BGGR = 0x16,\n  LIBRAW_OPENBAYER_GRBG = 0x61,\n  LIBRAW_OPENBAYER_GBRG = 0x49\n};\n\nenum LibRaw_dngfields_marks\n{\n  LIBRAW_DNGFM_FORWARDMATRIX = 1,\n  LIBRAW_DNGFM_ILLUMINANT = 1 << 1,\n  LIBRAW_DNGFM_COLORMATRIX = 1 << 2,\n  LIBRAW_DNGFM_CALIBRATION = 1 << 3,\n  LIBRAW_DNGFM_ANALOGBALANCE = 1 << 4,\n  LIBRAW_DNGFM_BLACK = 1 << 5,\n  LIBRAW_DNGFM_WHITE = 1 << 6,\n  LIBRAW_DNGFM_OPCODE2 = 1 << 7,\n  LIBRAW_DNGFM_LINTABLE = 1 << 8,\n  LIBRAW_DNGFM_CROPORIGIN = 1 << 9,\n  LIBRAW_DNGFM_CROPSIZE = 1 << 10,\n  LIBRAW_DNGFM_PREVIEWCS = 1 << 11,\n  LIBRAW_DNGFM_ASSHOTNEUTRAL = 1 << 12,\n  LIBRAW_DNGFM_BASELINEEXPOSURE = 1 << 13,\n  LIBRAW_DNGFM_LINEARRESPONSELIMIT = 1 << 14\n};\n\nenum LibRaw_As_Shot_WB_Applied_codes\n{\n  LIBRAW_ASWB_APPLIED = 1,\n  LIBRAW_ASWB_CANON = 2,\n  LIBRAW_ASWB_NIKON = 4,\n  LIBRAW_ASWB_NIKON_SRAW = 8,\n  LIBRAW_ASWB_PENTAX = 16\n};\n\n#define tagtypeIs(typex) (type == typex)\nenum LibRaw_ExifTagTypes {\n  LIBRAW_EXIFTAG_TYPE_UNKNOWN   =  0,\n  LIBRAW_EXIFTAG_TYPE_BYTE      =  1,\n  LIBRAW_EXIFTAG_TYPE_ASCII     =  2,\n  LIBRAW_EXIFTAG_TYPE_SHORT     =  3,\n  LIBRAW_EXIFTAG_TYPE_LONG      =  4,\n  LIBRAW_EXIFTAG_TYPE_RATIONAL  =  5,\n  LIBRAW_EXIFTAG_TYPE_SBYTE     =  6,\n  LIBRAW_EXIFTAG_TYPE_UNDEFINED =  7,\n  LIBRAW_EXIFTAG_TYPE_SSHORT    =  8,\n  LIBRAW_EXIFTAG_TYPE_SLONG     =  9,\n  LIBRAW_EXIFTAG_TYPE_SRATIONAL = 10,\n  LIBRAW_EXIFTAG_TYPE_FLOAT     = 11,\n  LIBRAW_EXIFTAG_TYPE_DOUBLE    = 12,\n  LIBRAW_EXIFTAG_TYPE_IFD       = 13,\n  LIBRAW_EXIFTAG_TYPE_UNICODE   = 14,\n  LIBRAW_EXIFTAG_TYPE_COMPLEX   = 15,\n  LIBRAW_EXIFTAG_TYPE_LONG8     = 16,\n  LIBRAW_EXIFTAG_TYPE_SLONG8    = 17,\n  LIBRAW_EXIFTAG_TYPE_IFD8      = 18\n};\n\n#define LIBRAW_EXIFTOOLTAGTYPE_int8u       LIBRAW_EXIFTAG_TYPE_BYTE\n#define LIBRAW_EXIFTOOLTAGTYPE_string      LIBRAW_EXIFTAG_TYPE_ASCII\n#define LIBRAW_EXIFTOOLTAGTYPE_int16u      LIBRAW_EXIFTAG_TYPE_SHORT\n#define LIBRAW_EXIFTOOLTAGTYPE_int32u      LIBRAW_EXIFTAG_TYPE_LONG\n#define LIBRAW_EXIFTOOLTAGTYPE_rational64u LIBRAW_EXIFTAG_TYPE_RATIONAL\n#define LIBRAW_EXIFTOOLTAGTYPE_int8s       LIBRAW_EXIFTAG_TYPE_SBYTE\n#define LIBRAW_EXIFTOOLTAGTYPE_undef       LIBRAW_EXIFTAG_TYPE_UNDEFINED\n#define LIBRAW_EXIFTOOLTAGTYPE_binary      LIBRAW_EXIFTAG_TYPE_UNDEFINED\n#define LIBRAW_EXIFTOOLTAGTYPE_int16s      LIBRAW_EXIFTAG_TYPE_SSHORT\n#define LIBRAW_EXIFTOOLTAGTYPE_int32s      LIBRAW_EXIFTAG_TYPE_SLONG\n#define LIBRAW_EXIFTOOLTAGTYPE_rational64s LIBRAW_EXIFTAG_TYPE_SRATIONAL\n#define LIBRAW_EXIFTOOLTAGTYPE_float       LIBRAW_EXIFTAG_TYPE_FLOAT\n#define LIBRAW_EXIFTOOLTAGTYPE_double      LIBRAW_EXIFTAG_TYPE_DOUBLE\n#define LIBRAW_EXIFTOOLTAGTYPE_ifd         LIBRAW_EXIFTAG_TYPE_IFD\n#define LIBRAW_EXIFTOOLTAGTYPE_unicode     LIBRAW_EXIFTAG_TYPE_UNICODE\n#define LIBRAW_EXIFTOOLTAGTYPE_complex     LIBRAW_EXIFTAG_TYPE_COMPLEX\n#define LIBRAW_EXIFTOOLTAGTYPE_int64u      LIBRAW_EXIFTAG_TYPE_LONG8\n#define LIBRAW_EXIFTOOLTAGTYPE_int64s      LIBRAW_EXIFTAG_TYPE_SLONG8\n#define LIBRAW_EXIFTOOLTAGTYPE_ifd64       LIBRAW_EXIFTAG_TYPE_IFD8\n\n#define LIBRAW_LENS_NOT_SET 0xffffffffffffffffULL\n\nenum LibRaw_whitebalance_code\n{\n// clang-format off\n  /*\n      EXIF light sources\n      12 = FL-D; Daylight fluorescent (D 5700K \u2013 7100K) (F1,F5)\n      13 = FL-N; Day white fluorescent (N 4600K \u2013 5400K) (F7,F8)\n      14 = FL-W; Cool white fluorescent (W 3900K \u2013 4500K) (F2,F6, office, store, warehouse)\n      15 = FL-WW; White fluorescent (WW 3200K \u2013 3700K) (F3, residential)\n      16 = FL-L; Soft/Warm white fluorescent (L 2600K - 3250K) (F4, kitchen, bath)\n  */\n//clang-format on\n  LIBRAW_WBI_Unknown = 0,\n  LIBRAW_WBI_Daylight = 1,\n  LIBRAW_WBI_Fluorescent = 2,\n  LIBRAW_WBI_Tungsten = 3,\n  LIBRAW_WBI_Flash = 4,\n  LIBRAW_WBI_FineWeather = 9,\n  LIBRAW_WBI_Cloudy = 10,\n  LIBRAW_WBI_Shade = 11,\n  LIBRAW_WBI_FL_D = 12,\n  LIBRAW_WBI_FL_N = 13,\n  LIBRAW_WBI_FL_W = 14,\n  LIBRAW_WBI_FL_WW = 15,\n  LIBRAW_WBI_FL_L = 16,\n  LIBRAW_WBI_Ill_A = 17,\n  LIBRAW_WBI_Ill_B = 18,\n  LIBRAW_WBI_Ill_C = 19,\n  LIBRAW_WBI_D55 = 20,\n  LIBRAW_WBI_D65 = 21,\n  LIBRAW_WBI_D75 = 22,\n  LIBRAW_WBI_D50 = 23,\n  LIBRAW_WBI_StudioTungsten = 24,\n  LIBRAW_WBI_Sunset = 64,\n  LIBRAW_WBI_Underwater = 65,\n  LIBRAW_WBI_FluorescentHigh = 66,\n  LIBRAW_WBI_HT_Mercury = 67,\n  LIBRAW_WBI_AsShot = 81,\n  LIBRAW_WBI_Auto = 82,\n  LIBRAW_WBI_Custom = 83,\n  LIBRAW_WBI_Auto1 = 85,\n  LIBRAW_WBI_Auto2 = 86,\n  LIBRAW_WBI_Auto3 = 87,\n  LIBRAW_WBI_Auto4 = 88,\n  LIBRAW_WBI_Custom1 = 90,\n  LIBRAW_WBI_Custom2 = 91,\n  LIBRAW_WBI_Custom3 = 92,\n  LIBRAW_WBI_Custom4 = 93,\n  LIBRAW_WBI_Custom5 = 94,\n  LIBRAW_WBI_Custom6 = 95,\n  LIBRAW_WBI_PC_Set1 = 96,\n  LIBRAW_WBI_PC_Set2 = 97,\n  LIBRAW_WBI_PC_Set3 = 98,\n  LIBRAW_WBI_PC_Set4 = 99,\n  LIBRAW_WBI_PC_Set5 = 100,\n  LIBRAW_WBI_Measured = 110,\n  LIBRAW_WBI_BW = 120,\n  LIBRAW_WBI_Kelvin = 254,\n  LIBRAW_WBI_Other = 255,\n  LIBRAW_WBI_None = 0xffff\n};\n\nenum LibRaw_MultiExposure_related\n{\n  LIBRAW_ME_NONE = 0,\n  LIBRAW_ME_SIMPLE = 1,\n  LIBRAW_ME_OVERLAY = 2,\n  LIBRAW_ME_HDR = 3\n};\n\nenum LibRaw_dng_processing\n{\n  LIBRAW_DNG_NONE = 0,\n  LIBRAW_DNG_FLOAT = 1,\n  LIBRAW_DNG_LINEAR = 2,\n  LIBRAW_DNG_DEFLATE = 4,\n  LIBRAW_DNG_XTRANS = 8,\n  LIBRAW_DNG_OTHER = 16,\n  LIBRAW_DNG_8BIT = 32,\n  /*LIBRAW_DNG_LARGERANGE=64,*/ /* more than 16 bit integer */\n  LIBRAW_DNG_ALL =\n      LIBRAW_DNG_FLOAT | LIBRAW_DNG_LINEAR | LIBRAW_DNG_XTRANS |\n      LIBRAW_DNG_8BIT | LIBRAW_DNG_OTHER /* |LIBRAW_DNG_LARGERANGE */,\n  LIBRAW_DNG_DEFAULT = LIBRAW_DNG_FLOAT | LIBRAW_DNG_LINEAR |\n                       LIBRAW_DNG_DEFLATE | LIBRAW_DNG_8BIT\n};\n\nenum LibRaw_runtime_capabilities\n{\n  LIBRAW_CAPS_RAWSPEED = 1,\n  LIBRAW_CAPS_DNGSDK = 2,\n  LIBRAW_CAPS_GPRSDK = 4,\n  LIBRAW_CAPS_UNICODEPATHS = 8,\n  LIBRAW_CAPS_X3FTOOLS = 16,\n  LIBRAW_CAPS_RPI6BY9 = 32\n};\n\nenum LibRaw_colorspace {\n  LIBRAW_COLORSPACE_NotFound = 0,\n  LIBRAW_COLORSPACE_sRGB,\n  LIBRAW_COLORSPACE_AdobeRGB,\n  LIBRAW_COLORSPACE_WideGamutRGB,\n  LIBRAW_COLORSPACE_ProPhotoRGB,\n  LIBRAW_COLORSPACE_ICC,\n  LIBRAW_COLORSPACE_Uncalibrated, // Tag 0x0001 InteropIndex containing \"R03\" + LIBRAW_COLORSPACE_Uncalibrated = Adobe RGB\n  LIBRAW_COLORSPACE_CameraLinearUniWB,\n  LIBRAW_COLORSPACE_CameraLinear,\n  LIBRAW_COLORSPACE_CameraGammaUniWB,\n  LIBRAW_COLORSPACE_CameraGamma,\n  LIBRAW_COLORSPACE_MonochromeLinear,\n  LIBRAW_COLORSPACE_MonochromeGamma,\n  LIBRAW_COLORSPACE_Unknown = 255\n};\n\nenum LibRaw_cameramaker_index\n{\n  LIBRAW_CAMERAMAKER_Unknown = 0,\n  LIBRAW_CAMERAMAKER_Agfa,\n  LIBRAW_CAMERAMAKER_Alcatel,\n  LIBRAW_CAMERAMAKER_Apple,\n  LIBRAW_CAMERAMAKER_Aptina,\n  LIBRAW_CAMERAMAKER_AVT,\n  LIBRAW_CAMERAMAKER_Baumer,\n  LIBRAW_CAMERAMAKER_Broadcom,\n  LIBRAW_CAMERAMAKER_Canon,\n  LIBRAW_CAMERAMAKER_Casio,\n  LIBRAW_CAMERAMAKER_CINE,\n  LIBRAW_CAMERAMAKER_Clauss,\n  LIBRAW_CAMERAMAKER_Contax,\n  LIBRAW_CAMERAMAKER_Creative,\n  LIBRAW_CAMERAMAKER_DJI,\n  LIBRAW_CAMERAMAKER_DXO,\n  LIBRAW_CAMERAMAKER_Epson,\n  LIBRAW_CAMERAMAKER_Foculus,\n  LIBRAW_CAMERAMAKER_Fujifilm,\n  LIBRAW_CAMERAMAKER_Generic,\n  LIBRAW_CAMERAMAKER_Gione,\n  LIBRAW_CAMERAMAKER_GITUP,\n  LIBRAW_CAMERAMAKER_Google,\n  LIBRAW_CAMERAMAKER_GoPro,\n  LIBRAW_CAMERAMAKER_Hasselblad,\n  LIBRAW_CAMERAMAKER_HTC,\n  LIBRAW_CAMERAMAKER_I_Mobile,\n  LIBRAW_CAMERAMAKER_Imacon,\n  LIBRAW_CAMERAMAKER_JK_Imaging,\n  LIBRAW_CAMERAMAKER_Kodak,\n  LIBRAW_CAMERAMAKER_Konica,\n  LIBRAW_CAMERAMAKER_Leaf,\n  LIBRAW_CAMERAMAKER_Leica,\n  LIBRAW_CAMERAMAKER_Lenovo,\n  LIBRAW_CAMERAMAKER_LG,\n  LIBRAW_CAMERAMAKER_Logitech,\n  LIBRAW_CAMERAMAKER_Mamiya,\n  LIBRAW_CAMERAMAKER_Matrix,\n  LIBRAW_CAMERAMAKER_Meizu,\n  LIBRAW_CAMERAMAKER_Micron,\n  LIBRAW_CAMERAMAKER_Minolta,\n  LIBRAW_CAMERAMAKER_Motorola,\n  LIBRAW_CAMERAMAKER_NGM,\n  LIBRAW_CAMERAMAKER_Nikon,\n  LIBRAW_CAMERAMAKER_Nokia,\n  LIBRAW_CAMERAMAKER_Olympus,\n  LIBRAW_CAMERAMAKER_OmniVison,\n  LIBRAW_CAMERAMAKER_Panasonic,\n  LIBRAW_CAMERAMAKER_Parrot,\n  LIBRAW_CAMERAMAKER_Pentax,\n  LIBRAW_CAMERAMAKER_PhaseOne,\n  LIBRAW_CAMERAMAKER_PhotoControl,\n  LIBRAW_CAMERAMAKER_Photron,\n  LIBRAW_CAMERAMAKER_Pixelink,\n  LIBRAW_CAMERAMAKER_Polaroid,\n  LIBRAW_CAMERAMAKER_RED,\n  LIBRAW_CAMERAMAKER_Ricoh,\n  LIBRAW_CAMERAMAKER_Rollei,\n  LIBRAW_CAMERAMAKER_RoverShot,\n  LIBRAW_CAMERAMAKER_Samsung,\n  LIBRAW_CAMERAMAKER_Sigma,\n  LIBRAW_CAMERAMAKER_Sinar,\n  LIBRAW_CAMERAMAKER_SMaL,\n  LIBRAW_CAMERAMAKER_Sony,\n  LIBRAW_CAMERAMAKER_ST_Micro,\n  LIBRAW_CAMERAMAKER_THL,\n  LIBRAW_CAMERAMAKER_VLUU,\n  LIBRAW_CAMERAMAKER_Xiaomi,\n  LIBRAW_CAMERAMAKER_XIAOYI,\n  LIBRAW_CAMERAMAKER_YI,\n  LIBRAW_CAMERAMAKER_Yuneec,\n  LIBRAW_CAMERAMAKER_Zeiss,\n  // Insert additional indexes here\n  LIBRAW_CAMERAMAKER_TheLastOne\n};\n\nenum LibRaw_camera_mounts\n{\n  LIBRAW_MOUNT_Unknown = 0,\n  LIBRAW_MOUNT_Alpa,\n  LIBRAW_MOUNT_C,              /* C-mount */\n  LIBRAW_MOUNT_Canon_EF_M,\n  LIBRAW_MOUNT_Canon_EF_S,\n  LIBRAW_MOUNT_Canon_EF,\n  LIBRAW_MOUNT_Canon_RF,\n  LIBRAW_MOUNT_Contax_N,\n  LIBRAW_MOUNT_Contax645,\n  LIBRAW_MOUNT_FT,             /* original 4/3 */\n  LIBRAW_MOUNT_mFT,            /* micro 4/3 */\n  LIBRAW_MOUNT_Fuji_GF,        /* Fujifilm GFX cameras, G mount */\n  LIBRAW_MOUNT_Fuji_GX,        /* Fujifilm GX680 */\n  LIBRAW_MOUNT_Fuji_X,\n  LIBRAW_MOUNT_Hasselblad_H,   /* Hasselblad Hn cameras, HC & HCD lenses */\n  LIBRAW_MOUNT_Hasselblad_V,\n  LIBRAW_MOUNT_Hasselblad_XCD, /* Hasselblad Xn cameras, XCD lenses */\n  LIBRAW_MOUNT_Leica_M,        /* Leica rangefinder bayonet */\n  LIBRAW_MOUNT_Leica_R,        /* Leica SLRs, 'R' for reflex */\n  LIBRAW_MOUNT_Leica_S,        /* LIBRAW_FORMAT_LeicaS 'MF' */\n  LIBRAW_MOUNT_Leica_SL,       /* lens, mounts on 'L' throat, FF */\n  LIBRAW_MOUNT_Leica_TL,       /* lens, mounts on 'L' throat, APS-C */\n  LIBRAW_MOUNT_LPS_L,          /* Leica/Panasonic/Sigma camera mount, takes L, SL and TL lenses */\n  LIBRAW_MOUNT_Mamiya67,       /* Mamiya RB67, RZ67 */\n  LIBRAW_MOUNT_Mamiya645,\n  LIBRAW_MOUNT_Minolta_A,\n  LIBRAW_MOUNT_Nikon_CX,       /* used in 'Nikon 1' series */\n  LIBRAW_MOUNT_Nikon_F,\n  LIBRAW_MOUNT_Nikon_Z,\n  LIBRAW_MOUNT_Pentax_645,\n  LIBRAW_MOUNT_Pentax_K,\n  LIBRAW_MOUNT_Pentax_Q,\n  LIBRAW_MOUNT_RicohModule,\n  LIBRAW_MOUNT_Rollei_bayonet, /* Rollei Hy-6: Leaf AFi, Sinar Hy6- models */\n  LIBRAW_MOUNT_Samsung_NX_M,\n  LIBRAW_MOUNT_Samsung_NX,\n  LIBRAW_MOUNT_Sigma_X3F,\n  LIBRAW_MOUNT_Sony_E,\n  LIBRAW_MOUNT_LF,\n  LIBRAW_MOUNT_DigitalBack,\n  LIBRAW_MOUNT_FixedLens,\n  LIBRAW_MOUNT_IL_UM,          /* Interchangeable lens, mount unknown */\n  LIBRAW_MOUNT_TheLastOne\n};\n\nenum LibRaw_camera_formats\n{\n  LIBRAW_FORMAT_Unknown = 0,\n  LIBRAW_FORMAT_APSC,\n  LIBRAW_FORMAT_FF,\n  LIBRAW_FORMAT_MF,\n  LIBRAW_FORMAT_APSH,\n  LIBRAW_FORMAT_1INCH,\n  LIBRAW_FORMAT_1div2p3INCH,  /* 1/2.3\" */\n  LIBRAW_FORMAT_1div1p7INCH,  /* 1/1.7\" */\n  LIBRAW_FORMAT_FT,           /* sensor size in FT & mFT cameras */\n  LIBRAW_FORMAT_CROP645,      /* 44x33mm */\n  LIBRAW_FORMAT_LeicaS,       /* 'MF' Leicas */\n  LIBRAW_FORMAT_645,\n  LIBRAW_FORMAT_66,\n  LIBRAW_FORMAT_69,\n  LIBRAW_FORMAT_LF,\n  LIBRAW_FORMAT_Leica_DMR,\n  LIBRAW_FORMAT_67,\n  LIBRAW_FORMAT_SigmaAPSC,    /* DP1, DP2, SD15, SD14, SD10, SD9 */\n  LIBRAW_FORMAT_SigmaMerrill, /* SD1,  'SD1 Merrill',  'DP1 Merrill',  'DP2 Merrill' */\n  LIBRAW_FORMAT_SigmaAPSH,    /* 'sd Quattro H' */\n  LIBRAW_FORMAT_3648,         /* DALSA FTF4052C (Mamiya ZD) */\n  LIBRAW_FORMAT_68,           /* Fujifilm GX680 */\n  LIBRAW_FORMAT_TheLastOne\n};\n\nenum LibRawImageAspects\n{\n  LIBRAW_IMAGE_ASPECT_UNKNOWN = 0,\n  LIBRAW_IMAGE_ASPECT_3to2 = 1,\n  LIBRAW_IMAGE_ASPECT_1to1 = 2,\n  LIBRAW_IMAGE_ASPECT_4to3 = 3,\n  LIBRAW_IMAGE_ASPECT_16to9 = 4,\n  LIBRAW_IMAGE_ASPECT_5to4 = 5,\n  LIBRAW_IMAGE_ASPECT_OTHER = 6\n};\n\nenum LibRaw_lens_focal_types\n{\n  LIBRAW_FT_UNDEFINED = 0,\n  LIBRAW_FT_PRIME_LENS = 1,\n  LIBRAW_FT_ZOOM_LENS = 2,\n  LIBRAW_FT_ZOOM_LENS_CONSTANT_APERTURE = 3,\n  LIBRAW_FT_ZOOM_LENS_VARIABLE_APERTURE = 4\n};\n\nenum LibRaw_Canon_RecordModes {\n  LIBRAW_Canon_RecordMode_UNDEFINED = 0,\n  LIBRAW_Canon_RecordMode_JPEG,\n  LIBRAW_Canon_RecordMode_CRW_THM,\n  LIBRAW_Canon_RecordMode_AVI_THM,\n  LIBRAW_Canon_RecordMode_TIF,\n  LIBRAW_Canon_RecordMode_TIF_JPEG,\n  LIBRAW_Canon_RecordMode_CR2,\n  LIBRAW_Canon_RecordMode_CR2_JPEG,\n  LIBRAW_Canon_RecordMode_UNKNOWN,\n  LIBRAW_Canon_RecordMode_MOV,\n  LIBRAW_Canon_RecordMode_MP4,\n  LIBRAW_Canon_RecordMode_CRM,\n  LIBRAW_Canon_RecordMode_CR3,\n  LIBRAW_Canon_RecordMode_CR3_JPEG,\n  LIBRAW_Canon_RecordMode_HEIF,\n  LIBRAW_Canon_RecordMode_CR3_HEIF,\n  LIBRAW_Canon_RecordMode_TheLastOne\n};\n\nenum LibRaw_sony_cameratypes\n{\n  LIBRAW_SONY_DSC = 1,\n  LIBRAW_SONY_DSLR = 2,\n  LIBRAW_SONY_NEX = 3,\n  LIBRAW_SONY_SLT = 4,\n  LIBRAW_SONY_ILCE = 5,\n  LIBRAW_SONY_ILCA = 6\n};\n\nenum LibRaw_KodakSensors\n{\n  LIBRAW_Kodak_UnknownSensor = 0,\n  LIBRAW_Kodak_M1 = 1,\n  LIBRAW_Kodak_M15 = 2,\n  LIBRAW_Kodak_M16 = 3,\n  LIBRAW_Kodak_M17 = 4,\n  LIBRAW_Kodak_M2 = 5,\n  LIBRAW_Kodak_M23 = 6,\n  LIBRAW_Kodak_M24 = 7,\n  LIBRAW_Kodak_M3 = 8,\n  LIBRAW_Kodak_M5 = 9,\n  LIBRAW_Kodak_M6 = 10,\n  LIBRAW_Kodak_C14 = 11,\n  LIBRAW_Kodak_X14 = 12,\n  LIBRAW_Kodak_M11 = 13\n};\n\nenum LibRaw_HasselbladFormatCodes {\n  LIBRAW_HF_Unknown = 0,\n  LIBRAW_HF_3FR,\n  LIBRAW_HF_FFF,\n  LIBRAW_HF_Imacon,\n  LIBRAW_HF_HasselbladDNG,\n  LIBRAW_HF_AdobeDNG,\n  LIBRAW_HF_AdobeDNG_fromPhocusDNG\n};\n\nenum LibRaw_processing_options\n{\n  LIBRAW_PROCESSING_SONYARW2_NONE = 0,\n  LIBRAW_PROCESSING_SONYARW2_BASEONLY = 1,\n  LIBRAW_PROCESSING_SONYARW2_DELTAONLY = 1 << 1,\n  LIBRAW_PROCESSING_SONYARW2_DELTAZEROBASE = 1 << 2,\n  LIBRAW_PROCESSING_SONYARW2_DELTATOVALUE = 1 << 3,\n  LIBRAW_PROCESSING_SONYARW2_ALLFLAGS =\n      LIBRAW_PROCESSING_SONYARW2_BASEONLY +\n      LIBRAW_PROCESSING_SONYARW2_DELTAONLY +\n      LIBRAW_PROCESSING_SONYARW2_DELTAZEROBASE +\n      LIBRAW_PROCESSING_SONYARW2_DELTATOVALUE,\n  LIBRAW_PROCESSING_DP2Q_INTERPOLATERG = 1 << 4,\n  LIBRAW_PROCESSING_DP2Q_INTERPOLATEAF = 1 << 5,\n  LIBRAW_PROCESSING_PENTAX_PS_ALLFRAMES = 1 << 6,\n  LIBRAW_PROCESSING_CONVERTFLOAT_TO_INT = 1 << 7,\n  LIBRAW_PROCESSING_SRAW_NO_RGB = 1 << 8,\n  LIBRAW_PROCESSING_SRAW_NO_INTERPOLATE = 1 << 9,\n  LIBRAW_PROCESSING_ARQ_SKIP_CHANNEL_SWAP = 1 << 10,\n  LIBRAW_PROCESSING_NO_ROTATE_FOR_KODAK_THUMBNAILS = 1 << 11,\n  LIBRAW_PROCESSING_USE_DNG_DEFAULT_CROP = 1 << 12,\n  LIBRAW_PROCESSING_USE_PPM16_THUMBS = 1 << 13,\n  LIBRAW_PROCESSING_SKIP_MAKERNOTES = 1 << 14,\n  LIBRAW_PROCESSING_DONT_CHECK_DNG_ILLUMINANT = 1 << 15,\n  LIBRAW_PROCESSING_DNGSDK_ZEROCOPY = 1 << 16,\n  LIBRAW_PROCESSING_ZEROFILTERS_FOR_MONOCHROMETIFFS = 1 << 17,\n  LIBRAW_PROCESSING_DNG_ADD_ENHANCED = 1 << 18,\n  LIBRAW_PROCESSING_DNG_ADD_PREVIEWS = 1 << 19,\n  LIBRAW_PROCESSING_DNG_PREFER_LARGEST_IMAGE = 1 << 20,\n  LIBRAW_PROCESSING_DNG_STAGE2 = 1 << 21,\n  LIBRAW_PROCESSING_DNG_STAGE3 = 1 << 22,\n  LIBRAW_PROCESSING_DNG_ALLOWSIZECHANGE = 1 << 23,\n  LIBRAW_PROCESSING_DNG_DISABLEWBADJUST = 1 << 24\n};\n\nenum LibRaw_decoder_flags\n{\n  LIBRAW_DECODER_HASCURVE = 1 << 4,\n  LIBRAW_DECODER_SONYARW2 = 1 << 5,\n  LIBRAW_DECODER_TRYRAWSPEED = 1 << 6,\n  LIBRAW_DECODER_OWNALLOC = 1 << 7,\n  LIBRAW_DECODER_FIXEDMAXC = 1 << 8,\n  LIBRAW_DECODER_ADOBECOPYPIXEL = 1 << 9,\n  LIBRAW_DECODER_LEGACY_WITH_MARGINS = 1 << 10,\n  LIBRAW_DECODER_3CHANNEL = 1 << 11,\n  LIBRAW_DECODER_SINAR4SHOT = 1 << 11,\n  LIBRAW_DECODER_FLATDATA = 1 << 12,\n  LIBRAW_DECODER_FLAT_BG2_SWAPPED = 1<<13,\n  LIBRAW_DECODER_NOTSET = 1 << 15\n};\n\n#define LIBRAW_XTRANS 9\n\nenum LibRaw_constructor_flags\n{\n  LIBRAW_OPTIONS_NONE = 0,\n  LIBRAW_OPIONS_NO_MEMERR_CALLBACK = 1,\n  LIBRAW_OPIONS_NO_DATAERR_CALLBACK = 1 << 1\n};\n\nenum LibRaw_warnings\n{\n  LIBRAW_WARN_NONE = 0,\n  LIBRAW_WARN_BAD_CAMERA_WB = 1 << 2,\n  LIBRAW_WARN_NO_METADATA = 1 << 3,\n  LIBRAW_WARN_NO_JPEGLIB = 1 << 4,\n  LIBRAW_WARN_NO_EMBEDDED_PROFILE = 1 << 5,\n  LIBRAW_WARN_NO_INPUT_PROFILE = 1 << 6,\n  LIBRAW_WARN_BAD_OUTPUT_PROFILE = 1 << 7,\n  LIBRAW_WARN_NO_BADPIXELMAP = 1 << 8,\n  LIBRAW_WARN_BAD_DARKFRAME_FILE = 1 << 9,\n  LIBRAW_WARN_BAD_DARKFRAME_DIM = 1 << 10,\n  LIBRAW_WARN_NO_JASPER = 1 << 11,\n  LIBRAW_WARN_RAWSPEED_PROBLEM = 1 << 12,\n  LIBRAW_WARN_RAWSPEED_UNSUPPORTED = 1 << 13,\n  LIBRAW_WARN_RAWSPEED_PROCESSED = 1 << 14,\n  LIBRAW_WARN_FALLBACK_TO_AHD = 1 << 15,\n  LIBRAW_WARN_PARSEFUJI_PROCESSED = 1 << 16,\n  LIBRAW_WARN_DNGSDK_PROCESSED = 1 << 17,\n  LIBRAW_WARN_DNG_IMAGES_REORDERED = 1 << 18,\n  LIBRAW_WARN_DNG_STAGE2_APPLIED = 1 << 19,\n  LIBRAW_WARN_DNG_STAGE3_APPLIED = 1 << 20,\n};\n\nenum LibRaw_exceptions\n{\n  LIBRAW_EXCEPTION_NONE = 0,\n  LIBRAW_EXCEPTION_ALLOC = 1,\n  LIBRAW_EXCEPTION_DECODE_RAW = 2,\n  LIBRAW_EXCEPTION_DECODE_JPEG = 3,\n  LIBRAW_EXCEPTION_IO_EOF = 4,\n  LIBRAW_EXCEPTION_IO_CORRUPT = 5,\n  LIBRAW_EXCEPTION_CANCELLED_BY_CALLBACK = 6,\n  LIBRAW_EXCEPTION_BAD_CROP = 7,\n  LIBRAW_EXCEPTION_IO_BADFILE = 8,\n  LIBRAW_EXCEPTION_DECODE_JPEG2000 = 9,\n  LIBRAW_EXCEPTION_TOOBIG = 10,\n  LIBRAW_EXCEPTION_MEMPOOL = 11\n};\n\nenum LibRaw_progress\n{\n  LIBRAW_PROGRESS_START = 0,\n  LIBRAW_PROGRESS_OPEN = 1,\n  LIBRAW_PROGRESS_IDENTIFY = 1 << 1,\n  LIBRAW_PROGRESS_SIZE_ADJUST = 1 << 2,\n  LIBRAW_PROGRESS_LOAD_RAW = 1 << 3,\n  LIBRAW_PROGRESS_RAW2_IMAGE = 1 << 4,\n  LIBRAW_PROGRESS_REMOVE_ZEROES = 1 << 5,\n  LIBRAW_PROGRESS_BAD_PIXELS = 1 << 6,\n  LIBRAW_PROGRESS_DARK_FRAME = 1 << 7,\n  LIBRAW_PROGRESS_FOVEON_INTERPOLATE = 1 << 8,\n  LIBRAW_PROGRESS_SCALE_COLORS = 1 << 9,\n  LIBRAW_PROGRESS_PRE_INTERPOLATE = 1 << 10,\n  LIBRAW_PROGRESS_INTERPOLATE = 1 << 11,\n  LIBRAW_PROGRESS_MIX_GREEN = 1 << 12,\n  LIBRAW_PROGRESS_MEDIAN_FILTER = 1 << 13,\n  LIBRAW_PROGRESS_HIGHLIGHTS = 1 << 14,\n  LIBRAW_PROGRESS_FUJI_ROTATE = 1 << 15,\n  LIBRAW_PROGRESS_FLIP = 1 << 16,\n  LIBRAW_PROGRESS_APPLY_PROFILE = 1 << 17,\n  LIBRAW_PROGRESS_CONVERT_RGB = 1 << 18,\n  LIBRAW_PROGRESS_STRETCH = 1 << 19,\n  /* reserved */\n  LIBRAW_PROGRESS_STAGE20 = 1 << 20,\n  LIBRAW_PROGRESS_STAGE21 = 1 << 21,\n  LIBRAW_PROGRESS_STAGE22 = 1 << 22,\n  LIBRAW_PROGRESS_STAGE23 = 1 << 23,\n  LIBRAW_PROGRESS_STAGE24 = 1 << 24,\n  LIBRAW_PROGRESS_STAGE25 = 1 << 25,\n  LIBRAW_PROGRESS_STAGE26 = 1 << 26,\n  LIBRAW_PROGRESS_STAGE27 = 1 << 27,\n\n  LIBRAW_PROGRESS_THUMB_LOAD = 1 << 28,\n  LIBRAW_PROGRESS_TRESERVED1 = 1 << 29,\n  LIBRAW_PROGRESS_TRESERVED2 = 1 << 30\n};\n#define LIBRAW_PROGRESS_THUMB_MASK 0x0fffffff\n\nenum LibRaw_errors\n{\n  LIBRAW_SUCCESS = 0,\n  LIBRAW_UNSPECIFIED_ERROR = -1,\n  LIBRAW_FILE_UNSUPPORTED = -2,\n  LIBRAW_REQUEST_FOR_NONEXISTENT_IMAGE = -3,\n  LIBRAW_OUT_OF_ORDER_CALL = -4,\n  LIBRAW_NO_THUMBNAIL = -5,\n  LIBRAW_UNSUPPORTED_THUMBNAIL = -6,\n  LIBRAW_INPUT_CLOSED = -7,\n  LIBRAW_NOT_IMPLEMENTED = -8,\n  LIBRAW_UNSUFFICIENT_MEMORY = -100007,\n  LIBRAW_DATA_ERROR = -100008,\n  LIBRAW_IO_ERROR = -100009,\n  LIBRAW_CANCELLED_BY_CALLBACK = -100010,\n  LIBRAW_BAD_CROP = -100011,\n  LIBRAW_TOO_BIG = -100012,\n  LIBRAW_MEMPOOL_OVERFLOW = -100013\n};\n\n#define LIBRAW_FATAL_ERROR(ec) ((ec) < -100000)\n\nenum LibRaw_thumbnail_formats\n{\n  LIBRAW_THUMBNAIL_UNKNOWN = 0,\n  LIBRAW_THUMBNAIL_JPEG = 1,\n  LIBRAW_THUMBNAIL_BITMAP = 2,\n  LIBRAW_THUMBNAIL_BITMAP16 = 3,\n  LIBRAW_THUMBNAIL_LAYER = 4,\n  LIBRAW_THUMBNAIL_ROLLEI = 5\n};\n\nenum LibRaw_image_formats\n{\n  LIBRAW_IMAGE_JPEG = 1,\n  LIBRAW_IMAGE_BITMAP = 2\n};\n\n#endif\n", "/* -*- C++ -*-\n * Copyright 2019-2020 LibRaw LLC (info@libraw.org)\n *\n LibRaw is free software; you can redistribute it and/or modify\n it under the terms of the one of two licenses as you choose:\n\n1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1\n   (See file LICENSE.LGPL provided in LibRaw distribution archive for details).\n\n2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0\n   (See file LICENSE.CDDL provided in LibRaw distribution archive for details).\n\n */\n\n#include \"../../internal/libraw_cxx_defs.h\"\n\n#ifndef NO_JPEG\nstruct jpegErrorManager\n{\n  struct jpeg_error_mgr pub;\n  jmp_buf setjmp_buffer;\n};\n\nstatic void jpegErrorExit(j_common_ptr cinfo)\n{\n  jpegErrorManager *myerr = (jpegErrorManager *)cinfo->err;\n  longjmp(myerr->setjmp_buffer, 1);\n}\n#endif\n\nint LibRaw::unpack_thumb(void)\n{\n  CHECK_ORDER_LOW(LIBRAW_PROGRESS_IDENTIFY);\n  CHECK_ORDER_BIT(LIBRAW_PROGRESS_THUMB_LOAD);\n\n#define THUMB_SIZE_CHECKT(A) \\\n  do { \\\n    if (INT64(A) > 1024ULL * 1024ULL * LIBRAW_MAX_THUMBNAIL_MB) throw LIBRAW_EXCEPTION_IO_CORRUPT; \\\n    if (INT64(A) > 0 &&  INT64(A) < 64ULL)        throw LIBRAW_EXCEPTION_IO_CORRUPT; \\\n  } while (0)\n\n#define THUMB_SIZE_CHECKTNZ(A) \\\n  do { \\\n    if (INT64(A) > 1024ULL * 1024ULL * LIBRAW_MAX_THUMBNAIL_MB) throw LIBRAW_EXCEPTION_IO_CORRUPT; \\\n    if (INT64(A) < 64ULL)        throw LIBRAW_EXCEPTION_IO_CORRUPT; \\\n  } while (0)\n\n\n#define THUMB_SIZE_CHECKWH(W,H) \\\n  do { \\\n    if (INT64(W)*INT64(H) > 1024ULL * 1024ULL * LIBRAW_MAX_THUMBNAIL_MB) throw LIBRAW_EXCEPTION_IO_CORRUPT; \\\n    if (INT64(W)*INT64(H) < 64ULL)        throw LIBRAW_EXCEPTION_IO_CORRUPT; \\\n  } while (0)\n\n  try\n  {\n    if (!libraw_internal_data.internal_data.input)\n      return LIBRAW_INPUT_CLOSED;\n\n    int t_colors = libraw_internal_data.unpacker_data.thumb_misc >> 5 & 7;\n    int t_bytesps = (libraw_internal_data.unpacker_data.thumb_misc & 31) / 8;\n\n    if (!ID.toffset && !(imgdata.thumbnail.tlength > 0 &&\n                         load_raw == &LibRaw::broadcom_load_raw) // RPi\n    )\n    {\n      return LIBRAW_NO_THUMBNAIL;\n    }\n    else if (thumb_load_raw)\n    {\n      kodak_thumb_loader();\n      T.tformat = LIBRAW_THUMBNAIL_BITMAP;\n      SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n      return 0;\n    }\n    else\n    {\n#ifdef USE_X3FTOOLS\n\tif (write_thumb == &LibRaw::x3f_thumb_loader)\n      {\n        INT64 tsize = x3f_thumb_size();\n        if (tsize < 2048 || INT64(ID.toffset) + tsize < 1)\n          throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n        if (INT64(ID.toffset) + tsize > ID.input->size() + THUMB_READ_BEYOND)\n          throw LIBRAW_EXCEPTION_IO_EOF;\n        THUMB_SIZE_CHECKT(tsize);\n      }\n#else\n\tif (0) {}\n#endif\n      else\n      {\n        if (INT64(ID.toffset) + INT64(T.tlength) < 1)\n          throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n        if (INT64(ID.toffset) + INT64(T.tlength) >\n            ID.input->size() + THUMB_READ_BEYOND)\n          throw LIBRAW_EXCEPTION_IO_EOF;\n      }\n\n      ID.input->seek(ID.toffset, SEEK_SET);\n      if (write_thumb == &LibRaw::jpeg_thumb)\n      {\n        THUMB_SIZE_CHECKTNZ(T.tlength);\n\n        if (T.thumb)\n          free(T.thumb);\n        T.thumb = (char *)malloc(T.tlength);\n        merror(T.thumb, \"jpeg_thumb()\");\n        ID.input->read(T.thumb, 1, T.tlength);\n        unsigned char *tthumb = (unsigned char *)T.thumb;\n        tthumb[0] = 0xff;\n        tthumb[1] = 0xd8;\n#ifdef NO_JPEG\n        T.tcolors = 3;\n#else\n        {\n          jpegErrorManager jerr;\n          struct jpeg_decompress_struct cinfo;\n          cinfo.err = jpeg_std_error(&jerr.pub);\n          jerr.pub.error_exit = jpegErrorExit;\n          if (setjmp(jerr.setjmp_buffer))\n          {\n          err2:\n            // Error in original JPEG thumb, read it again because\n            // original bytes 0-1 was damaged above\n            jpeg_destroy_decompress(&cinfo);\n            T.tcolors = 3;\n            T.tformat = LIBRAW_THUMBNAIL_UNKNOWN;\n            ID.input->seek(ID.toffset, SEEK_SET);\n            ID.input->read(T.thumb, 1, T.tlength);\n            SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n            return 0;\n          }\n          jpeg_create_decompress(&cinfo);\n          jpeg_mem_src(&cinfo, (unsigned char *)T.thumb, T.tlength);\n          int rc = jpeg_read_header(&cinfo, TRUE);\n          if (rc != 1)\n            goto err2;\n          T.tcolors = (cinfo.num_components > 0 && cinfo.num_components <= 3)\n                          ? cinfo.num_components\n                          : 3;\n          jpeg_destroy_decompress(&cinfo);\n        }\n#endif\n        T.tformat = LIBRAW_THUMBNAIL_JPEG;\n        SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n        return 0;\n      }\n      else if (write_thumb == &LibRaw::layer_thumb)\n      {\n        int colors = libraw_internal_data.unpacker_data.thumb_misc >> 5 & 7;\n        if (colors != 1 && colors != 3)\n          return LIBRAW_UNSUPPORTED_THUMBNAIL;\n\n        THUMB_SIZE_CHECKWH(T.twidth, T.theight);\n\n        int tlength = T.twidth * T.theight;\n        if (T.thumb)\n          free(T.thumb);\n        T.thumb = (char *)calloc(colors, tlength);\n        merror(T.thumb, \"layer_thumb()\");\n        unsigned char *tbuf = (unsigned char *)calloc(colors, tlength);\n        merror(tbuf, \"layer_thumb()\");\n        ID.input->read(tbuf, colors, T.tlength);\n        if (libraw_internal_data.unpacker_data.thumb_misc >> 8 &&\n            colors == 3) // GRB order\n          for (int i = 0; i < tlength; i++)\n          {\n            T.thumb[i * 3] = tbuf[i + tlength];\n            T.thumb[i * 3 + 1] = tbuf[i];\n            T.thumb[i * 3 + 2] = tbuf[i + 2 * tlength];\n          }\n        else if (colors == 3) // RGB or 1-channel\n          for (int i = 0; i < tlength; i++)\n          {\n            T.thumb[i * 3] = tbuf[i];\n            T.thumb[i * 3 + 1] = tbuf[i + tlength];\n            T.thumb[i * 3 + 2] = tbuf[i + 2 * tlength];\n          }\n        else if (colors == 1)\n        {\n          free(T.thumb);\n          T.thumb = (char *)tbuf;\n          tbuf = 0;\n        }\n        if (tbuf)\n          free(tbuf);\n        T.tcolors = colors;\n        T.tlength = colors * tlength;\n        T.tformat = LIBRAW_THUMBNAIL_BITMAP;\n        SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n        return 0;\n      }\n      else if (write_thumb == &LibRaw::rollei_thumb)\n      {\n        int i;\n        THUMB_SIZE_CHECKWH(T.twidth, T.theight);\n        int tlength = T.twidth * T.theight;\n        if (T.thumb)\n          free(T.thumb);\n        T.tcolors = 3;\n        T.thumb = (char *)calloc(T.tcolors, tlength);\n        merror(T.thumb, \"layer_thumb()\");\n        unsigned short *tbuf = (unsigned short *)calloc(2, tlength);\n        merror(tbuf, \"layer_thumb()\");\n        read_shorts(tbuf, tlength);\n        for (i = 0; i < tlength; i++)\n        {\n          T.thumb[i * 3] = (tbuf[i] << 3) & 0xff;\n          T.thumb[i * 3 + 1] = (tbuf[i] >> 5 << 2) & 0xff;\n          T.thumb[i * 3 + 2] = (tbuf[i] >> 11 << 3) & 0xff;\n        }\n        free(tbuf);\n        T.tlength = T.tcolors * tlength;\n        T.tformat = LIBRAW_THUMBNAIL_BITMAP;\n        SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n        return 0;\n      }\n      else if (write_thumb == &LibRaw::ppm_thumb)\n      {\n        if (t_bytesps > 1)\n          throw LIBRAW_EXCEPTION_IO_CORRUPT; // 8-bit thumb, but parsed for more\n                                             // bits\n        THUMB_SIZE_CHECKWH(T.twidth, T.theight);\n        int t_length = T.twidth * T.theight * t_colors;\n\n        if (T.tlength &&\n            (int)T.tlength < t_length) // try to find tiff ifd with needed offset\n        {\n          int pifd = find_ifd_by_offset(libraw_internal_data.internal_data.toffset);\n          if (pifd >= 0 && tiff_ifd[pifd].strip_offsets_count &&\n              tiff_ifd[pifd].strip_byte_counts_count)\n          {\n            // We found it, calculate final size\n            unsigned total_size = 0;\n            for (int i = 0; i < tiff_ifd[pifd].strip_byte_counts_count; i++)\n              total_size += tiff_ifd[pifd].strip_byte_counts[i];\n            if (total_size != (unsigned)t_length) // recalculate colors\n            {\n              if (total_size == T.twidth * T.tlength * 3)\n                T.tcolors = 3;\n              else if (total_size == T.twidth * T.tlength)\n                T.tcolors = 1;\n            }\n            T.tlength = total_size;\n            THUMB_SIZE_CHECKTNZ(T.tlength);\n            if (T.thumb)\n              free(T.thumb);\n            T.thumb = (char *)malloc(T.tlength);\n            merror(T.thumb, \"ppm_thumb()\");\n\n            char *dest = T.thumb;\n            INT64 pos = ID.input->tell();\n\n            for (int i = 0; i < tiff_ifd[pifd].strip_byte_counts_count &&\n                            i < tiff_ifd[pifd].strip_offsets_count;\n                 i++)\n            {\n              int remain = T.tlength;\n              int sz = tiff_ifd[pifd].strip_byte_counts[i];\n              int off = tiff_ifd[pifd].strip_offsets[i];\n              if (off >= 0 && off + sz <= ID.input->size() && sz <= remain)\n              {\n                ID.input->seek(off, SEEK_SET);\n                ID.input->read(dest, sz, 1);\n                remain -= sz;\n                dest += sz;\n              }\n            }\n            ID.input->seek(pos, SEEK_SET);\n            T.tformat = LIBRAW_THUMBNAIL_BITMAP;\n            SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n            return 0;\n          }\n        }\n\n        if (!T.tlength)\n          T.tlength = t_length;\n        if (T.thumb)\n          free(T.thumb);\n\n        THUMB_SIZE_CHECKTNZ(T.tlength);\n\n        T.thumb = (char *)malloc(T.tlength);\n        if (!T.tcolors)\n          T.tcolors = t_colors;\n        merror(T.thumb, \"ppm_thumb()\");\n\n        ID.input->read(T.thumb, 1, T.tlength);\n\n        T.tformat = LIBRAW_THUMBNAIL_BITMAP;\n        SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n        return 0;\n      }\n      else if (write_thumb == &LibRaw::ppm16_thumb)\n      {\n        if (t_bytesps > 2)\n          throw LIBRAW_EXCEPTION_IO_CORRUPT; // 16-bit thumb, but parsed for\n                                             // more bits\n        int o_bps = (imgdata.params.raw_processing_options &\n                     LIBRAW_PROCESSING_USE_PPM16_THUMBS)\n                        ? 2\n                        : 1;\n        int o_length = T.twidth * T.theight * t_colors * o_bps;\n        int i_length = T.twidth * T.theight * t_colors * 2;\n        if (!T.tlength)\n          T.tlength = o_length;\n        THUMB_SIZE_CHECKTNZ(o_length);\n        THUMB_SIZE_CHECKTNZ(i_length);\n        THUMB_SIZE_CHECKTNZ(T.tlength);\n\n        ushort *t_thumb = (ushort *)calloc(i_length, 1);\n        ID.input->read(t_thumb, 1, i_length);\n        if ((libraw_internal_data.unpacker_data.order == 0x4949) ==\n            (ntohs(0x1234) == 0x1234))\n          swab((char *)t_thumb, (char *)t_thumb, i_length);\n\n        if (T.thumb)\n          free(T.thumb);\n        if ((imgdata.params.raw_processing_options &\n             LIBRAW_PROCESSING_USE_PPM16_THUMBS))\n        {\n          T.thumb = (char *)t_thumb;\n          T.tformat = LIBRAW_THUMBNAIL_BITMAP16;\n        }\n        else\n        {\n          T.thumb = (char *)malloc(o_length);\n          merror(T.thumb, \"ppm_thumb()\");\n          for (int i = 0; i < o_length; i++)\n            T.thumb[i] = t_thumb[i] >> 8;\n          free(t_thumb);\n          T.tformat = LIBRAW_THUMBNAIL_BITMAP;\n        }\n        SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n        return 0;\n      }\n#ifdef USE_X3FTOOLS\n\t  else if (write_thumb == &LibRaw::x3f_thumb_loader)\n      {\n        x3f_thumb_loader();\n        SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n        return 0;\n      }\n#endif\n      else\n      {\n        return LIBRAW_UNSUPPORTED_THUMBNAIL;\n      }\n    }\n    // last resort\n    return LIBRAW_UNSUPPORTED_THUMBNAIL;\n  }\n  catch (LibRaw_exceptions err)\n  {\n    EXCEPTION_HANDLER(err);\n  }\n}\n", "/* -*- C++ -*-\n * Copyright 2019-2020 LibRaw LLC (info@libraw.org)\n *\n LibRaw is free software; you can redistribute it and/or modify\n it under the terms of the one of two licenses as you choose:\n\n1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1\n   (See file LICENSE.LGPL provided in LibRaw distribution archive for details).\n\n2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0\n   (See file LICENSE.CDDL provided in LibRaw distribution archive for details).\n\n */\n\n#include \"../../internal/libraw_cxx_defs.h\"\n\nlibraw_processed_image_t *LibRaw::dcraw_make_mem_thumb(int *errcode)\n{\n  if (!T.thumb)\n  {\n    if (!ID.toffset && !(imgdata.thumbnail.tlength > 0 &&\n                         load_raw == &LibRaw::broadcom_load_raw) // RPi\n    )\n    {\n      if (errcode)\n        *errcode = LIBRAW_NO_THUMBNAIL;\n    }\n    else\n    {\n      if (errcode)\n        *errcode = LIBRAW_OUT_OF_ORDER_CALL;\n    }\n    return NULL;\n  }\n\n  if (T.tlength < 64u)\n  {\n      if (errcode)\n          *errcode = EINVAL;\n      return NULL;\n  }\n\n  if (INT64(T.tlength) > 1024ULL * 1024ULL * LIBRAW_MAX_THUMBNAIL_MB)\n  {\n      if (errcode)\n          *errcode = LIBRAW_TOO_BIG;\n      return NULL;\n  }\n\n  if (T.tformat == LIBRAW_THUMBNAIL_BITMAP)\n  {\n    libraw_processed_image_t *ret = (libraw_processed_image_t *)::malloc(\n        sizeof(libraw_processed_image_t) + T.tlength);\n\n    if (!ret)\n    {\n      if (errcode)\n        *errcode = ENOMEM;\n      return NULL;\n    }\n\n    memset(ret, 0, sizeof(libraw_processed_image_t));\n    ret->type = LIBRAW_IMAGE_BITMAP;\n    ret->height = T.theight;\n    ret->width = T.twidth;\n    ret->colors = 3;\n    ret->bits = 8;\n    ret->data_size = T.tlength;\n    memmove(ret->data, T.thumb, T.tlength);\n    if (errcode)\n      *errcode = 0;\n    return ret;\n  }\n  else if (T.tformat == LIBRAW_THUMBNAIL_JPEG)\n  {\n    ushort exif[5];\n    int mk_exif = 0;\n    if (strcmp(T.thumb + 6, \"Exif\"))\n      mk_exif = 1;\n\n    int dsize = T.tlength + mk_exif * (sizeof(exif) + sizeof(tiff_hdr));\n\n    libraw_processed_image_t *ret = (libraw_processed_image_t *)::malloc(\n        sizeof(libraw_processed_image_t) + dsize);\n\n    if (!ret)\n    {\n      if (errcode)\n        *errcode = ENOMEM;\n      return NULL;\n    }\n\n    memset(ret, 0, sizeof(libraw_processed_image_t));\n\n    ret->type = LIBRAW_IMAGE_JPEG;\n    ret->data_size = dsize;\n\n    ret->data[0] = 0xff;\n    ret->data[1] = 0xd8;\n    if (mk_exif)\n    {\n      struct tiff_hdr th;\n      memcpy(exif, \"\\xff\\xe1  Exif\\0\\0\", 10);\n      exif[1] = htons(8 + sizeof th);\n      memmove(ret->data + 2, exif, sizeof(exif));\n      tiff_head(&th, 0);\n      memmove(ret->data + (2 + sizeof(exif)), &th, sizeof(th));\n      memmove(ret->data + (2 + sizeof(exif) + sizeof(th)), T.thumb + 2,\n              T.tlength - 2);\n    }\n    else\n    {\n      memmove(ret->data + 2, T.thumb + 2, T.tlength - 2);\n    }\n    if (errcode)\n      *errcode = 0;\n    return ret;\n  }\n  else\n  {\n    if (errcode)\n      *errcode = LIBRAW_UNSUPPORTED_THUMBNAIL;\n    return NULL;\n  }\n}\n\n// jlb\n// macros for copying pixels to either BGR or RGB formats\n#define FORBGR for (c = P1.colors - 1; c >= 0; c--)\n#define FORRGB for (c = 0; c < P1.colors; c++)\n\nvoid LibRaw::get_mem_image_format(int *width, int *height, int *colors,\n                                  int *bps) const\n\n{\n  *width = S.width;\n  *height = S.height;\n  if (imgdata.progress_flags < LIBRAW_PROGRESS_FUJI_ROTATE)\n  {\n    if (O.use_fuji_rotate)\n    {\n      if (IO.fuji_width)\n      {\n        int fuji_width = (IO.fuji_width - 1 + IO.shrink) >> IO.shrink;\n        *width = (ushort)(fuji_width / sqrt(0.5));\n        *height = (ushort)((*height - fuji_width) / sqrt(0.5));\n      }\n      else\n      {\n        if (S.pixel_aspect < 0.995)\n          *height = (ushort)(*height / S.pixel_aspect + 0.5);\n        if (S.pixel_aspect > 1.005)\n          *width = (ushort)(*width * S.pixel_aspect + 0.5);\n      }\n    }\n  }\n  if (S.flip & 4)\n  {\n    std::swap(*width, *height);\n  }\n  *colors = P1.colors;\n  *bps = O.output_bps;\n}\n\nint LibRaw::copy_mem_image(void *scan0, int stride, int bgr)\n\n{\n  // the image memory pointed to by scan0 is assumed to be in the format\n  // returned by get_mem_image_format\n  if ((imgdata.progress_flags & LIBRAW_PROGRESS_THUMB_MASK) <\n      LIBRAW_PROGRESS_PRE_INTERPOLATE)\n    return LIBRAW_OUT_OF_ORDER_CALL;\n\n  if (libraw_internal_data.output_data.histogram)\n  {\n    int perc, val, total, t_white = 0x2000, c;\n    perc = S.width * S.height * O.auto_bright_thr;\n    if (IO.fuji_width)\n      perc /= 2;\n    if (!((O.highlight & ~2) || O.no_auto_bright))\n      for (t_white = c = 0; c < P1.colors; c++)\n      {\n        for (val = 0x2000, total = 0; --val > 32;)\n          if ((total += libraw_internal_data.output_data.histogram[c][val]) >\n              perc)\n            break;\n        if (t_white < val)\n          t_white = val;\n      }\n    gamma_curve(O.gamm[0], O.gamm[1], 2, (t_white << 3) / O.bright);\n  }\n\n  int s_iheight = S.iheight;\n  int s_iwidth = S.iwidth;\n  int s_width = S.width;\n  int s_hwight = S.height;\n\n  S.iheight = S.height;\n  S.iwidth = S.width;\n\n  if (S.flip & 4)\n    SWAP(S.height, S.width);\n  uchar *ppm;\n  ushort *ppm2;\n  int c, row, col, soff, rstep, cstep;\n\n  soff = flip_index(0, 0);\n  cstep = flip_index(0, 1) - soff;\n  rstep = flip_index(1, 0) - flip_index(0, S.width);\n\n  for (row = 0; row < S.height; row++, soff += rstep)\n  {\n    uchar *bufp = ((uchar *)scan0) + row * stride;\n    ppm2 = (ushort *)(ppm = bufp);\n    // keep trivial decisions in the outer loop for speed\n    if (bgr)\n    {\n      if (O.output_bps == 8)\n      {\n        for (col = 0; col < S.width; col++, soff += cstep)\n          FORBGR *ppm++ = imgdata.color.curve[imgdata.image[soff][c]] >> 8;\n      }\n      else\n      {\n        for (col = 0; col < S.width; col++, soff += cstep)\n          FORBGR *ppm2++ = imgdata.color.curve[imgdata.image[soff][c]];\n      }\n    }\n    else\n    {\n      if (O.output_bps == 8)\n      {\n        for (col = 0; col < S.width; col++, soff += cstep)\n          FORRGB *ppm++ = imgdata.color.curve[imgdata.image[soff][c]] >> 8;\n      }\n      else\n      {\n        for (col = 0; col < S.width; col++, soff += cstep)\n          FORRGB *ppm2++ = imgdata.color.curve[imgdata.image[soff][c]];\n      }\n    }\n\n    //            bufp += stride;           // go to the next line\n  }\n\n  S.iheight = s_iheight;\n  S.iwidth = s_iwidth;\n  S.width = s_width;\n  S.height = s_hwight;\n\n  return 0;\n}\n#undef FORBGR\n#undef FORRGB\n\nlibraw_processed_image_t *LibRaw::dcraw_make_mem_image(int *errcode)\n\n{\n  int width, height, colors, bps;\n  get_mem_image_format(&width, &height, &colors, &bps);\n  int stride = width * (bps / 8) * colors;\n  unsigned ds = height * stride;\n  libraw_processed_image_t *ret = (libraw_processed_image_t *)::malloc(\n      sizeof(libraw_processed_image_t) + ds);\n  if (!ret)\n  {\n    if (errcode)\n      *errcode = ENOMEM;\n    return NULL;\n  }\n  memset(ret, 0, sizeof(libraw_processed_image_t));\n\n  // metadata init\n  ret->type = LIBRAW_IMAGE_BITMAP;\n  ret->height = height;\n  ret->width = width;\n  ret->colors = colors;\n  ret->bits = bps;\n  ret->data_size = ds;\n  copy_mem_image(ret->data, stride, 0);\n\n  return ret;\n}\n\nvoid LibRaw::dcraw_clear_mem(libraw_processed_image_t *p)\n{\n  if (p)\n    ::free(p);\n}\n", "/* -*- C++ -*-\n * Copyright 2019-2020 LibRaw LLC (info@libraw.org)\n *\n\n LibRaw is free software; you can redistribute it and/or modify\n it under the terms of the one of two licenses as you choose:\n\n1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1\n   (See file LICENSE.LGPL provided in LibRaw distribution archive for details).\n\n2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0\n   (See file LICENSE.CDDL provided in LibRaw distribution archive for details).\n\n */\n\n#include \"../../internal/libraw_cxx_defs.h\"\n\nvoid LibRaw::kodak_thumb_loader()\n{\n  INT64 est_datasize =\n      T.theight * T.twidth / 3; // is 0.3 bytes per pixel good estimate?\n  if (ID.toffset < 0)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n  if (ID.toffset + est_datasize > ID.input->size() + THUMB_READ_BEYOND)\n    throw LIBRAW_EXCEPTION_IO_EOF;\n\n  if(INT64(T.theight) * INT64(T.twidth) > 1024ULL * 1024ULL * LIBRAW_MAX_THUMBNAIL_MB)\n      throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n  if (INT64(T.theight) * INT64(T.twidth) < 64ULL)\n      throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n  // some kodak cameras\n  ushort s_height = S.height, s_width = S.width, s_iwidth = S.iwidth,\n         s_iheight = S.iheight;\n  ushort s_flags = libraw_internal_data.unpacker_data.load_flags;\n  libraw_internal_data.unpacker_data.load_flags = 12;\n  int s_colors = P1.colors;\n  unsigned s_filters = P1.filters;\n  ushort(*s_image)[4] = imgdata.image;\n\n  S.height = T.theight;\n  S.width = T.twidth;\n  P1.filters = 0;\n\n  if (thumb_load_raw == &LibRaw::kodak_ycbcr_load_raw)\n  {\n    S.height += S.height & 1;\n    S.width += S.width & 1;\n  }\n\n  imgdata.image =\n      (ushort(*)[4])calloc(S.iheight * S.iwidth, sizeof(*imgdata.image));\n  merror(imgdata.image, \"LibRaw::kodak_thumb_loader()\");\n\n  ID.input->seek(ID.toffset, SEEK_SET);\n  // read kodak thumbnail into T.image[]\n  try\n  {\n    (this->*thumb_load_raw)();\n  }\n  catch (...)\n  {\n    free(imgdata.image);\n    imgdata.image = s_image;\n\n    T.twidth = 0;\n    S.width = s_width;\n\n    S.iwidth = s_iwidth;\n    S.iheight = s_iheight;\n\n    T.theight = 0;\n    S.height = s_height;\n\n    T.tcolors = 0;\n    P1.colors = s_colors;\n\n    P1.filters = s_filters;\n    T.tlength = 0;\n    libraw_internal_data.unpacker_data.load_flags = s_flags;\n    return;\n  }\n\n  // from scale_colors\n  {\n    double dmax;\n    float scale_mul[4];\n    int c, val;\n    for (dmax = DBL_MAX, c = 0; c < 3; c++)\n      if (dmax > C.pre_mul[c])\n        dmax = C.pre_mul[c];\n\n    for (c = 0; c < 3; c++)\n      scale_mul[c] = (C.pre_mul[c] / dmax) * 65535.0 / C.maximum;\n    scale_mul[3] = scale_mul[1];\n\n    size_t size = S.height * S.width;\n    for (unsigned i = 0; i < size * 4; i++)\n    {\n      val = imgdata.image[0][i];\n      if (!val)\n        continue;\n      val *= scale_mul[i & 3];\n      imgdata.image[0][i] = CLIP(val);\n    }\n  }\n\n  // from convert_to_rgb\n  ushort *img;\n  int row, col;\n\n  int(*t_hist)[LIBRAW_HISTOGRAM_SIZE] =\n      (int(*)[LIBRAW_HISTOGRAM_SIZE])calloc(sizeof(*t_hist), 4);\n  merror(t_hist, \"LibRaw::kodak_thumb_loader()\");\n\n  float out[3], out_cam[3][4] = {{2.81761312, -1.98369181, 0.166078627, 0},\n                                 {-0.111855984, 1.73688626, -0.625030339, 0},\n                                 {-0.0379119813, -0.891268849, 1.92918086, 0}};\n\n  for (img = imgdata.image[0], row = 0; row < S.height; row++)\n    for (col = 0; col < S.width; col++, img += 4)\n    {\n      out[0] = out[1] = out[2] = 0;\n      int c;\n      for (c = 0; c < 3; c++)\n      {\n        out[0] += out_cam[0][c] * img[c];\n        out[1] += out_cam[1][c] * img[c];\n        out[2] += out_cam[2][c] * img[c];\n      }\n      for (c = 0; c < 3; c++)\n        img[c] = CLIP((int)out[c]);\n      for (c = 0; c < P1.colors; c++)\n        t_hist[c][img[c] >> 3]++;\n    }\n\n  // from gamma_lut\n  int(*save_hist)[LIBRAW_HISTOGRAM_SIZE] =\n      libraw_internal_data.output_data.histogram;\n  libraw_internal_data.output_data.histogram = t_hist;\n\n  // make curve output curve!\n  ushort *t_curve = (ushort *)calloc(sizeof(C.curve), 1);\n  merror(t_curve, \"LibRaw::kodak_thumb_loader()\");\n  memmove(t_curve, C.curve, sizeof(C.curve));\n  memset(C.curve, 0, sizeof(C.curve));\n  {\n    int perc, val, total, t_white = 0x2000, c;\n\n    perc = S.width * S.height * 0.01; /* 99th percentile white level */\n    if (IO.fuji_width)\n      perc /= 2;\n    if (!((O.highlight & ~2) || O.no_auto_bright))\n      for (t_white = c = 0; c < P1.colors; c++)\n      {\n        for (val = 0x2000, total = 0; --val > 32;)\n          if ((total += libraw_internal_data.output_data.histogram[c][val]) >\n              perc)\n            break;\n        if (t_white < val)\n          t_white = val;\n      }\n    gamma_curve(O.gamm[0], O.gamm[1], 2, (t_white << 3) / O.bright);\n  }\n\n  libraw_internal_data.output_data.histogram = save_hist;\n  free(t_hist);\n\n  // from write_ppm_tiff - copy pixels into bitmap\n\n  int s_flip = imgdata.sizes.flip;\n  if (imgdata.params.raw_processing_options &\n      LIBRAW_PROCESSING_NO_ROTATE_FOR_KODAK_THUMBNAILS)\n    imgdata.sizes.flip = 0;\n\n  S.iheight = S.height;\n  S.iwidth = S.width;\n  if (S.flip & 4)\n    SWAP(S.height, S.width);\n\n  if (T.thumb)\n    free(T.thumb);\n  T.thumb = (char *)calloc(S.width * S.height, P1.colors);\n  merror(T.thumb, \"LibRaw::kodak_thumb_loader()\");\n  T.tlength = S.width * S.height * P1.colors;\n\n  // from write_tiff_ppm\n  {\n    int soff = flip_index(0, 0);\n    int cstep = flip_index(0, 1) - soff;\n    int rstep = flip_index(1, 0) - flip_index(0, S.width);\n\n    for (int row = 0; row < S.height; row++, soff += rstep)\n    {\n      char *ppm = T.thumb + row * S.width * P1.colors;\n      for (int col = 0; col < S.width; col++, soff += cstep)\n        for (int c = 0; c < P1.colors; c++)\n          ppm[col * P1.colors + c] =\n              imgdata.color.curve[imgdata.image[soff][c]] >> 8;\n    }\n  }\n\n  memmove(C.curve, t_curve, sizeof(C.curve));\n  free(t_curve);\n\n  // restore variables\n  free(imgdata.image);\n  imgdata.image = s_image;\n\n  if (imgdata.params.raw_processing_options &\n      LIBRAW_PROCESSING_NO_ROTATE_FOR_KODAK_THUMBNAILS)\n    imgdata.sizes.flip = s_flip;\n\n  T.twidth = S.width;\n  S.width = s_width;\n\n  S.iwidth = s_iwidth;\n  S.iheight = s_iheight;\n\n  T.theight = S.height;\n  S.height = s_height;\n\n  T.tcolors = P1.colors;\n  P1.colors = s_colors;\n\n  P1.filters = s_filters;\n  libraw_internal_data.unpacker_data.load_flags = s_flags;\n}\n\n// \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd thumbnail \ufffd\ufffd \ufffd\ufffd\ufffd\ufffd\ufffd, \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd thumb_format \ufffd \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd \ufffd \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\n\nint LibRaw::thumbOK(INT64 maxsz)\n{\n  if (!ID.input)\n    return 0;\n  if (!ID.toffset && !(imgdata.thumbnail.tlength > 0 &&\n                       load_raw == &LibRaw::broadcom_load_raw) // RPi\n  )\n    return 0;\n  INT64 fsize = ID.input->size();\n  if (fsize > 0x7fffffffU)\n    return 0; // No thumb for raw > 2Gb\n  int tsize = 0;\n  int tcol = (T.tcolors > 0 && T.tcolors < 4) ? T.tcolors : 3;\n  if (write_thumb == &LibRaw::jpeg_thumb)\n    tsize = T.tlength;\n  else if (write_thumb == &LibRaw::ppm_thumb)\n    tsize = tcol * T.twidth * T.theight;\n  else if (write_thumb == &LibRaw::ppm16_thumb)\n    tsize = tcol * T.twidth * T.theight *\n            ((imgdata.params.raw_processing_options &\n              LIBRAW_PROCESSING_USE_PPM16_THUMBS)\n                 ? 2\n                 : 1);\n#ifdef USE_X3FTOOLS\n  else if (write_thumb == &LibRaw::x3f_thumb_loader)\n  {\n    tsize = x3f_thumb_size();\n  }\n#endif\n  else // Kodak => no check\n    tsize = 1;\n  if (tsize < 0)\n    return 0;\n  if (maxsz > 0 && tsize > maxsz)\n    return 0;\n  return (tsize + ID.toffset <= fsize) ? 1 : 0;\n}\n\nint LibRaw::dcraw_thumb_writer(const char *fname)\n{\n  //    CHECK_ORDER_LOW(LIBRAW_PROGRESS_THUMB_LOAD);\n\n  if (!fname)\n    return ENOENT;\n\n  FILE *tfp = fopen(fname, \"wb\");\n\n  if (!tfp)\n    return errno;\n\n  if (!T.thumb)\n  {\n    fclose(tfp);\n    return LIBRAW_OUT_OF_ORDER_CALL;\n  }\n\n  try\n  {\n    switch (T.tformat)\n    {\n    case LIBRAW_THUMBNAIL_JPEG:\n      jpeg_thumb_writer(tfp, T.thumb, T.tlength);\n      break;\n    case LIBRAW_THUMBNAIL_BITMAP:\n      fprintf(tfp, \"P6\\n%d %d\\n255\\n\", T.twidth, T.theight);\n      fwrite(T.thumb, 1, T.tlength, tfp);\n      break;\n    default:\n      fclose(tfp);\n      return LIBRAW_UNSUPPORTED_THUMBNAIL;\n    }\n    fclose(tfp);\n    return 0;\n  }\n  catch (LibRaw_exceptions err)\n  {\n    fclose(tfp);\n    EXCEPTION_HANDLER(err);\n  }\n}\n"], "filenames": ["libraw/libraw_const.h", "src/decoders/unpack_thumb.cpp", "src/postprocessing/mem_image.cpp", "src/utils/thumb_utils.cpp"], "buggy_code_start_loc": [22, 34, 33, 26], "buggy_code_end_loc": [23, 280, 33, 26], "fixing_code_start_loc": [23, 35, 34, 27], "fixing_code_end_loc": [31, 314, 48, 33], "type": "CWE-20", "message": "LibRaw before 0.20-RC1 lacks a thumbnail size range check. This affects decoders/unpack_thumb.cpp, postprocessing/mem_image.cpp, and utils/thumb_utils.cpp. For example, malloc(sizeof(libraw_processed_image_t)+T.tlength) occurs without validating T.tlength.", "other": {"cve": {"id": "CVE-2020-15503", "sourceIdentifier": "cve@mitre.org", "published": "2020-07-02T14:15:11.683", "lastModified": "2023-02-03T21:05:08.793", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "LibRaw before 0.20-RC1 lacks a thumbnail size range check. This affects decoders/unpack_thumb.cpp, postprocessing/mem_image.cpp, and utils/thumb_utils.cpp. For example, malloc(sizeof(libraw_processed_image_t)+T.tlength) occurs without validating T.tlength."}, {"lang": "es", "value": "LibRaw versiones anteriores a 0.20-RC1, carece de una comprobaci\u00f3n de rango de tama\u00f1o de miniaturas. Esto afecta a los archivos decoders/unpack_thumb.cpp, postprocessing/mem_image.cpp, y utils/thumb_utils.cpp. Por ejemplo, malloc(sizeof(libraw_processed_image_t)+T.tlength) ocurre sin comprobar T.tlength"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libraw:libraw:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.19.5", "matchCriteriaId": "27DFF8C5-9D6E-46BE-AC83-B1CFA0EC18E9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libraw:libraw:0.20:beta1:*:*:*:*:*:*", "matchCriteriaId": "4692451F-ECE5-4545-ACB7-C6F0442C2531"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libraw:libraw:0.20:beta2:*:*:*:*:*:*", "matchCriteriaId": "D7AB8396-4358-4095-AA9F-992A661C48E0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libraw:libraw:0.20:beta3:*:*:*:*:*:*", "matchCriteriaId": "91AB2B37-1EF7-4A77-86B8-122D7719D234"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:31:*:*:*:*:*:*:*", "matchCriteriaId": "80F0FA5D-8D3B-4C0E-81E2-87998286AF33"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:32:*:*:*:*:*:*:*", "matchCriteriaId": "36D96259-24BD-44E2-96D9-78CE1D41F956"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-07/msg00075.html", "source": "cve@mitre.org", "tags": ["Broken Link", "Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2020-08/msg00001.html", "source": "cve@mitre.org", "tags": ["Broken Link", "Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/LibRaw/LibRaw/commit/20ad21c0d87ca80217aee47533d91e633ce1864d", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/LibRaw/LibRaw/compare/0.20-Beta3...0.20-RC1", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/11/msg00042.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/7HM2DS6HA4YZREI3BYGS75M6D76WMW62/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/CSXAJKZ4VNDYVQULJNY4XDPWHIJDTB4P/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/DNGDWTO45TU4KGND75EUUEGUMNSOYC7H/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/QCVKD7PTO7UQAVUTBHJAKBKYLPQQGAMZ/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/Y34ALB34P3NGQXLF7BG7R6DGRX6XL2JN/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/YZETDVPZQWZWVGIG6JTIEKP5KPVMUE7Y/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://www.libraw.org/news/libraw-0-20-rc1", "source": "cve@mitre.org", "tags": ["Broken Link", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/LibRaw/LibRaw/commit/20ad21c0d87ca80217aee47533d91e633ce1864d"}}