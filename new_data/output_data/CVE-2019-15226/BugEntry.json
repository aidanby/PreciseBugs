{"buggy_code": ["Version history\n---------------\n\n1.12.0 (pending)\n================\n* access log: added :ref:`buffering <envoy_api_field_config.accesslog.v2.CommonGrpcAccessLogConfig.buffer_size_bytes>` and :ref:`periodical flushing <envoy_api_field_config.accesslog.v2.CommonGrpcAccessLogConfig.buffer_flush_interval>` support to gRPC access logger. Defaults to 16KB buffer and flushing every 1 second.\n* access log: added DOWNSTREAM_DIRECT_REMOTE_ADDRESS and DOWNSTREAM_DIRECT_REMOTE_ADDRESS_WITHOUT_PORT :ref:`access log formatters <config_access_log_format>` and gRPC access logger.\n* access log: gRPC Access Log Service (ALS) support added for :ref:`TCP access logs <envoy_api_msg_config.accesslog.v2.TcpGrpcAccessLogConfig>`.\n* access log: reintroduce :ref:`filesystem <filesystem_stats>` stats and added the `write_failed` counter to track failed log writes\n* admin: added ability to configure listener :ref:`socket options <envoy_api_field_config.bootstrap.v2.Admin.socket_options>`.\n* admin: added config dump support for Secret Discovery Service :ref:`SecretConfigDump <envoy_api_msg_admin.v2alpha.SecretsConfigDump>`.\n* api: added ::ref:`set_node_on_first_message_only <envoy_api_field_core.ApiConfigSource.set_node_on_first_message_only>` option to omit the node identifier from the subsequent discovery requests on the same stream.\n* buffer filter: the buffer filter populates content-length header if not present, behavior can be disabled using the runtime feature `envoy.reloadable_features.buffer_filter_populate_content_length`.\n* config: added support for :ref:`delta xDS <arch_overview_dynamic_config_delta>` (including ADS) delivery\n* config: enforcing that terminal filters (e.g. HttpConnectionManager for L4, router for L7) be the last in their respective filter chains.\n* config: added access log :ref:`extension filter<envoy_api_field_config.filter.accesslog.v2.AccessLogFilter.extension_filter>`.\n* config: added support for :option:`--reject-unknown-dynamic-fields`, providing independent control\n  over whether unknown fields are rejected in static and dynamic configuration. By default, unknown\n  fields in static configuration are rejected and are allowed in dynamic configuration. Warnings\n  are logged for the first use of any unknown field and these occurrences are counted in the\n  :ref:`server.static_unknown_fields <server_statistics>` and :ref:`server.dynamic_unknown_fields\n  <server_statistics>` statistics.\n* config: async data access for local and remote data source.\n* config: changed the default value of :ref:`initial_fetch_timeout <envoy_api_field_core.ConfigSource.initial_fetch_timeout>` from 0s to 15s. This is a change in behaviour in the sense that Envoy will move to the next initialization phase, even if the first config is not delivered in 15s. Refer to :ref:`initialization process <arch_overview_initialization>` for more details.\n* config: added stat :ref:`init_fetch_timeout <config_cluster_manager_cds>`.\n* dns: added support for configuring :ref:`dns_failure_refresh_rate <envoy_api_field_Cluster.dns_failure_refresh_rate>` to set the DNS refresh rate during failures.\n* ext_authz: added :ref:`configurable ability <envoy_api_field_config.filter.http.ext_authz.v2.ExtAuthz.metadata_context_namespaces>` to send dynamic metadata to the `ext_authz` service.\n* ext_authz: added tracing to the HTTP client.\n* fault: added overrides for default runtime keys in :ref:`HTTPFault <envoy_api_msg_config.filter.http.fault.v2.HTTPFault>` filter.\n* grpc: added :ref:`AWS IAM grpc credentials extension <envoy_api_file_envoy/config/grpc_credential/v2alpha/aws_iam.proto>` for AWS-managed xDS.\n* grpc-json: added support for :ref:`ignoring unknown query parameters<envoy_api_field_config.filter.http.transcoder.v2.GrpcJsonTranscoder.ignore_unknown_query_parameters>`.\n* grpc-json: added support for :ref:`the grpc-status-details-bin header<envoy_api_field_config.filter.http.transcoder.v2.GrpcJsonTranscoder.convert_grpc_status>`.\n* header to metadata: added :ref:`PROTOBUF_VALUE <envoy_api_enum_value_config.filter.http.header_to_metadata.v2.Config.ValueType.PROTOBUF_VALUE>` and :ref:`ValueEncode <envoy_api_enum_config.filter.http.header_to_metadata.v2.Config.ValueEncode>` to support protobuf Value and Base64 encoding.\n* http: added the ability to reject HTTP/1.1 requests with invalid HTTP header values, using the runtime feature `envoy.reloadable_features.strict_header_validation`.\n* http: changed Envoy to forward existing x-forwarded-proto from upstream trusted proxies. Guarded by `envoy.reloadable_features.trusted_forwarded_proto` which defaults true.\n* http: added the ability to configure the behavior of the server response header, via the :ref:`server_header_transformation<envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.server_header_transformation>` field.\n* http: added the ability to :ref:`merge adjacent slashes<envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.merge_slashes>` in the path.\n* http: :ref:`AUTO <envoy_api_enum_value_config.filter.network.http_connection_manager.v2.HttpConnectionManager.CodecType.AUTO>` codec protocol inference now requires the H2 magic bytes to be the first bytes transmitted by a downstream client.\n* http: remove h2c upgrade headers for HTTP/1 as h2c upgrades are currently not supported.\n* http: absolute URL support is now on by default. The prior behavior can be reinstated by setting :ref:`allow_absolute_url <envoy_api_field_core.Http1ProtocolOptions.allow_absolute_url>` to false.\n* listeners: added :ref:`continue_on_listener_filters_timeout <envoy_api_field_Listener.continue_on_listener_filters_timeout>` to configure whether a listener will still create a connection when listener filters time out.\n* listeners: added :ref:`HTTP inspector listener filter <config_listener_filters_http_inspector>`.\n* lua: extended `httpCall()` and `respond()` APIs to accept headers with entry values that can be a string or table of strings.\n* lua: extended `dynamicMetadata:set()` to allow setting complex values\n* metrics_service: added support for flushing histogram buckets.\n* outlier_detector: added :ref:`support for the grpc-status response header <arch_overview_outlier_detection_grpc>` by mapping it to HTTP status. Guarded by envoy.reloadable_features.outlier_detection_support_for_grpc_status which defaults to true.\n* performance: new buffer implementation enabled by default (to disable add \"--use-libevent-buffers 1\" to the command-line arguments when starting Envoy).\n* performance: stats symbol table implementation (disabled by default; to test it, add \"--use-fake-symbol-table 0\" to the command-line arguments when starting Envoy).\n* rbac: added support for DNS SAN as :ref:`principal_name <envoy_api_field_config.rbac.v2.Principal.Authenticated.principal_name>`.\n* redis: added :ref:`enable_command_stats <envoy_api_field_config.filter.network.redis_proxy.v2.RedisProxy.ConnPoolSettings.enable_command_stats>` to enable :ref:`per command statistics <arch_overview_redis_cluster_command_stats>` for upstream clusters.\n* redis: added :ref:`read_policy <envoy_api_field_config.filter.network.redis_proxy.v2.RedisProxy.ConnPoolSettings.read_policy>` to allow reading from redis replicas for Redis Cluster deployments.\n* redis: fix a bug where the redis health checker ignored the upstream auth password.\n* redis: enable_hashtaging is always enabled when the upstream uses open source Redis cluster protocol.\n* regex: introduce new :ref:`RegexMatcher <envoy_api_msg_type.matcher.RegexMatcher>` type that\n  provides a safe regex implementation for untrusted user input. This type is now used in all\n  configuration that processes user provided input. See :ref:`deprecated configuration details\n  <deprecated>` for more information.\n* rbac: added conditions to the policy, see :ref:`condition <envoy_api_field_config.rbac.v2.Policy.condition>`.\n* router: added :ref:`rq_retry_skipped_request_not_complete <config_http_filters_router_stats>` counter stat to router stats.\n* router: :ref:`Scoped routing <arch_overview_http_routing_route_scope>` is supported.\n* router: added new :ref:`retriable-headers <config_http_filters_router_x-envoy-retry-on>` retry policy. Retries can now be configured to trigger by arbitrary response header matching.\n* router: added :ref:`respect_expected_rq_timeout <envoy_api_field_config.filter.http.router.v2.Router.respect_expected_rq_timeout>` that instructs ingress Envoy to respect :ref:`config_http_filters_router_x-envoy-expected-rq-timeout-ms` header, populated by egress Envoy, when deriving timeout for upstream cluster.\n* router: added new :ref:`retriable request headers <envoy_api_field_route.RetryPolicy.retriable_request_headers>` to retry policies. Retries can now be configured to only trigger on request header match.\n* router check tool: add coverage reporting & enforcement.\n* router check tool: add comprehensive coverage reporting.\n* router check tool: add deprecated field check.\n* router check tool: add flag for only printing results of failed tests.\n* router check tool: add support for outputting missing tests in the detailed coverage report.\n* runtime: allow for the ability to parse boolean values.\n* runtime: allow for the ability to parse integers as double values and vice-versa.\n* server: added a post initialization lifecycle event, in addition to the existing startup and shutdown events.\n* server: added :ref:`per-handler listener stats <config_listener_stats_per_handler>` and\n  :ref:`per-worker watchdog stats <operations_performance_watchdog>` to help diagnosing event\n  loop imbalance and general performance issues.\n* thrift_proxy: fix crashing bug on invalid transport/protocol framing\n* tls: added verification of IP address SAN fields in certificates against configured SANs in the\n* tracing: added support to the Zipkin reporter for sending list of spans as Zipkin JSON v2 and protobuf message over HTTP.\n  certificate validation context.\n* tracing: added tags for gRPC response status and meesage.\n* tracing: added :ref:`max_path_tag_length <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.tracing>` to support customizing the length of the request path included in the extracted `http.url <https://github.com/opentracing/specification/blob/master/semantic_conventions.md#standard-span-tags-and-log-fields>` tag.\n* upstream: added :ref:`an option <envoy_api_field_Cluster.CommonLbConfig.close_connections_on_host_set_change>` that allows draining HTTP, TCP connection pools on cluster membership change.\n* upstream: added network filter chains to upstream connections, see :ref:`filters<envoy_api_field_Cluster.filters>`.\n* upstream: added new :ref:`failure-percentage based outlier detection<arch_overview_outlier_detection_failure_percentage>` mode.\n* upstream: use p2c to select hosts for least-requests load balancers if all host weights are the same, even in cases where weights are not equal to 1.\n* upstream: added :ref:`fail_traffic_on_panic <envoy_api_field_Cluster.CommonLbConfig.ZoneAwareLbConfig.fail_traffic_on_panic>` to allow failing all requests to a cluster during panic state.\n* zookeeper: parse responses and emit latency stats.\n\n1.11.1 (August 13, 2019)\n========================\n* http: added mitigation of client initiated attacks that result in flooding of the downstream HTTP/2 connections. Those attacks can be logged at the \"warning\" level when the runtime feature `http.connection_manager.log_flood_exception` is enabled. The runtime setting defaults to disabled to avoid log spam when under attack.\n* http: added :ref:`inbound_empty_frames_flood <config_http_conn_man_stats_per_codec>` counter stat to the HTTP/2 codec stats, for tracking number of connections terminated for exceeding the limit on consecutive inbound frames with an empty payload and no end stream flag. The limit is configured by setting the :ref:`max_consecutive_inbound_frames_with_empty_payload config setting <envoy_api_field_core.Http2ProtocolOptions.max_consecutive_inbound_frames_with_empty_payload>`.\n  Runtime feature `envoy.reloadable_features.http2_protocol_options.max_consecutive_inbound_frames_with_empty_payload` overrides :ref:`max_consecutive_inbound_frames_with_empty_payload setting <envoy_api_field_core.Http2ProtocolOptions.max_consecutive_inbound_frames_with_empty_payload>`. Large override value (i.e. 2147483647) effectively disables mitigation of inbound frames with empty payload.\n* http: added :ref:`inbound_priority_frames_flood <config_http_conn_man_stats_per_codec>` counter stat to the HTTP/2 codec stats, for tracking number of connections terminated for exceeding the limit on inbound PRIORITY frames. The limit is configured by setting the :ref:`max_inbound_priority_frames_per_stream config setting <envoy_api_field_core.Http2ProtocolOptions.max_inbound_priority_frames_per_stream>`.\n  Runtime feature `envoy.reloadable_features.http2_protocol_options.max_inbound_priority_frames_per_stream` overrides :ref:`max_inbound_priority_frames_per_stream setting <envoy_api_field_core.Http2ProtocolOptions.max_inbound_priority_frames_per_stream>`. Large override value effectively disables flood mitigation of inbound PRIORITY frames.\n* http: added :ref:`inbound_window_update_frames_flood <config_http_conn_man_stats_per_codec>` counter stat to the HTTP/2 codec stats, for tracking number of connections terminated for exceeding the limit on inbound WINDOW_UPDATE frames. The limit is configured by setting the :ref:`max_inbound_window_update_frames_per_data_frame_sent config setting <envoy_api_field_core.Http2ProtocolOptions.max_inbound_window_update_frames_per_data_frame_sent>`.\n  Runtime feature `envoy.reloadable_features.http2_protocol_options.max_inbound_window_update_frames_per_data_frame_sent` overrides :ref:`max_inbound_window_update_frames_per_data_frame_sent setting <envoy_api_field_core.Http2ProtocolOptions.max_inbound_window_update_frames_per_data_frame_sent>`. Large override value effectively disables flood mitigation of inbound WINDOW_UPDATE frames.\n* http: added :ref:`outbound_flood <config_http_conn_man_stats_per_codec>` counter stat to the HTTP/2 codec stats, for tracking number of connections terminated for exceeding the outbound queue limit. The limit is configured by setting the :ref:`max_outbound_frames config setting <envoy_api_field_core.Http2ProtocolOptions.max_outbound_frames>`\n  Runtime feature `envoy.reloadable_features.http2_protocol_options.max_outbound_frames` overrides :ref:`max_outbound_frames config setting <envoy_api_field_core.Http2ProtocolOptions.max_outbound_frames>`. Large override value effectively disables flood mitigation of outbound frames of all types.\n* http: added :ref:`outbound_control_flood <config_http_conn_man_stats_per_codec>` counter stat to the HTTP/2 codec stats, for tracking number of connections terminated for exceeding the outbound queue limit for PING, SETTINGS and RST_STREAM frames. The limit is configured by setting the :ref:`max_outbound_control_frames config setting <envoy_api_field_core.Http2ProtocolOptions.max_outbound_control_frames>`.\n  Runtime feature `envoy.reloadable_features.http2_protocol_options.max_outbound_control_frames` overrides :ref:`max_outbound_control_frames config setting <envoy_api_field_core.Http2ProtocolOptions.max_outbound_control_frames>`. Large override value effectively disables flood mitigation of outbound frames of types PING, SETTINGS and RST_STREAM.\n* http: enabled strict validation of HTTP/2 messaging. Previous behavior can be restored using :ref:`stream_error_on_invalid_http_messaging config setting <envoy_api_field_core.Http2ProtocolOptions.stream_error_on_invalid_http_messaging>`.\n  Runtime feature `envoy.reloadable_features.http2_protocol_options.stream_error_on_invalid_http_messaging` overrides :ref:`stream_error_on_invalid_http_messaging config setting <envoy_api_field_core.Http2ProtocolOptions.stream_error_on_invalid_http_messaging>`.\n\n1.11.0 (July 11, 2019)\n======================\n* access log: added a new field for downstream TLS session ID to file and gRPC access logger.\n* access log: added a new field for route name to file and gRPC access logger.\n* access log: added a new field for response code details in :ref:`file access logger<config_access_log_format_response_code_details>` and :ref:`gRPC access logger<envoy_api_field_data.accesslog.v2.HTTPResponseProperties.response_code_details>`.\n* access log: added several new variables for exposing information about the downstream TLS connection to :ref:`file access logger<config_access_log_format_response_code_details>` and :ref:`gRPC access logger<envoy_api_field_data.accesslog.v2.AccessLogCommon.tls_properties>`.\n* access log: added a new flag for request rejected due to failed strict header check.\n* admin: the administration interface now includes a :ref:`/ready endpoint <operations_admin_interface>` for easier readiness checks.\n* admin: extend :ref:`/runtime_modify endpoint <operations_admin_interface_runtime_modify>` to support parameters within the request body.\n* admin: the :ref:`/listener endpoint <operations_admin_interface_listeners>` now returns :ref:`listeners.proto<envoy_api_msg_admin.v2alpha.Listeners>` which includes listener names and ports.\n* admin: added host priority to :http:get:`/clusters` and :http:get:`/clusters?format=json` endpoint response\n* admin: the :ref:`/clusters endpoint <operations_admin_interface_clusters>` now shows hostname\n  for each host, useful for DNS based clusters.\n* api: track and report requests issued since last load report.\n* build: releases are built with Clang and linked with LLD.\n* config: added :ref:stats_server_version_override` <envoy_api_field_config.bootstrap.v2.Bootstrap.stats_server_version_override>` in bootstrap, that can be used to override :ref:`server.version statistic <server_statistics>`.\n* control-plane: management servers can respond with HTTP 304 to indicate that config is up to date for Envoy proxies polling a :ref:`REST API Config Type <envoy_api_field_core.ApiConfigSource.api_type>`\n* csrf: added support for whitelisting additional source origins.\n* dns: added support for getting DNS record TTL which is used by STRICT_DNS/LOGICAL_DNS cluster as DNS refresh rate.\n* dubbo_proxy: support the :ref:`dubbo proxy filter <config_network_filters_dubbo_proxy>`.\n* dynamo_request_parser: adding support for transactions. Adds check for new types of dynamodb operations (TransactWriteItems, TransactGetItems) and awareness for new types of dynamodb errors (IdempotentParameterMismatchException, TransactionCanceledException, TransactionInProgressException).\n* eds: added support to specify max time for which endpoints can be used :ref:`gRPC filter <envoy_api_msg_ClusterLoadAssignment.Policy>`.\n* eds: removed max limit for `load_balancing_weight`.\n* event: added :ref:`loop duration and poll delay statistics <operations_performance>`.\n* ext_authz: added a `x-envoy-auth-partial-body` metadata header set to `false|true` indicating if there is a partial body sent in the authorization request message.\n* ext_authz: added configurable status code that allows customizing HTTP responses on filter check status errors.\n* ext_authz: added option to `ext_authz` that allows the filter clearing route cache.\n* grpc-json: added support for :ref:`auto mapping\n  <envoy_api_field_config.filter.http.transcoder.v2.GrpcJsonTranscoder.auto_mapping>`.\n* health check: added :ref:`initial jitter <envoy_api_field_core.HealthCheck.initial_jitter>` to add jitter to the first health check in order to prevent thundering herd on Envoy startup.\n* hot restart: stats are no longer shared between hot restart parent/child via shared memory, but rather by RPC. Hot restart version incremented to 11.\n* http: added the ability to pass a URL encoded PEM encoded peer certificate chain in the\n  :ref:`config_http_conn_man_headers_x-forwarded-client-cert` header.\n* http: fixed a bug where large unbufferable responses were not tracked in stats and logs correctly.\n* http: fixed a crashing bug where gRPC local replies would cause segfaults when upstream access logging was on.\n* http: mitigated a race condition with the :ref:`delayed_close_timeout<envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.delayed_close_timeout>` where it could trigger while actively flushing a pending write buffer for a downstream connection.\n* http: added support for :ref:`preserve_external_request_id<envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.preserve_external_request_id>` that represents whether the x-request-id should not be reset on edge entry inside mesh\n* http: changed `sendLocalReply` to send percent-encoded `GrpcMessage`.\n* http: added a :ref:header_prefix` <envoy_api_field_config.bootstrap.v2.Bootstrap.header_prefix>` configuration option to allow Envoy to send and process x-custom- prefixed headers rather than x-envoy.\n* http: added :ref:`dynamic forward proxy <arch_overview_http_dynamic_forward_proxy>` support.\n* http: tracking the active stream and dumping state in Envoy crash handlers. This can be disabled by building with `--define disable_object_dump_on_signal_trace=disabled`\n* jwt_authn: make filter's parsing of JWT more flexible, allowing syntax like ``jwt=eyJhbGciOiJS...ZFnFIw,extra=7,realm=123``\n* listener: added :ref:`source IP <envoy_api_field_listener.FilterChainMatch.source_prefix_ranges>`\n  and :ref:`source port <envoy_api_field_listener.FilterChainMatch.source_ports>` filter\n  chain matching.\n* lua: exposed functions to Lua to verify digital signature.\n* original_src filter: added the :ref:`filter<config_http_filters_original_src>`.\n* outlier_detector: added configuration :ref:`outlier_detection.split_external_local_origin_errors<envoy_api_field_cluster.OutlierDetection.split_external_local_origin_errors>` to distinguish locally and externally generated errors. See :ref:`arch_overview_outlier_detection` for full details.\n* rbac: migrated from v2alpha to v2.\n* redis: add support for Redis cluster custom cluster type.\n* redis: automatically route commands using cluster slots for Redis cluster.\n* redis: added :ref:`prefix routing <envoy_api_field_config.filter.network.redis_proxy.v2.RedisProxy.prefix_routes>` to enable routing commands based on their key's prefix to different upstream.\n* redis: added :ref:`request mirror policy <envoy_api_field_config.filter.network.redis_proxy.v2.RedisProxy.PrefixRoutes.Route.request_mirror_policy>` to enable shadow traffic and/or dual writes.\n* redis: add support for zpopmax and zpopmin commands.\n* redis: added\n  :ref:`max_buffer_size_before_flush <envoy_api_field_config.filter.network.redis_proxy.v2.RedisProxy.ConnPoolSettings.max_buffer_size_before_flush>` to batch commands together until the encoder buffer hits a certain size, and\n  :ref:`buffer_flush_timeout <envoy_api_field_config.filter.network.redis_proxy.v2.RedisProxy.ConnPoolSettings.buffer_flush_timeout>` to control how quickly the buffer is flushed if it is not full.\n* redis: added auth support :ref:`downstream_auth_password <envoy_api_field_config.filter.network.redis_proxy.v2.RedisProxy.downstream_auth_password>` for downstream client authentication, and :ref:`auth_password <envoy_api_field_config.filter.network.redis_proxy.v2.RedisProtocolOptions.auth_password>` to configure authentication passwords for upstream server clusters.\n* retry: added a retry predicate that :ref:`rejects canary hosts. <envoy_api_field_route.RetryPolicy.retry_host_predicate>`\n* router: add support for configuring a :ref:`gRPC timeout offset <envoy_api_field_route.RouteAction.grpc_timeout_offset>` on incoming requests.\n* router: added ability to control retry back-off intervals via :ref:`retry policy <envoy_api_msg_route.RetryPolicy.RetryBackOff>`.\n* router: added ability to issue a hedged retry in response to a per try timeout via a :ref:`hedge policy <envoy_api_msg_route.HedgePolicy>`.\n* router: added a route name field to each http route in route.Route list\n* router: added several new variables for exposing information about the downstream TLS connection via :ref:`header\n  formatters <config_http_conn_man_headers_custom_request_headers>`.\n* router: per try timeouts will no longer start before the downstream request has been received\n  in full by the router. This ensures that the per try timeout does not account for slow\n  downstreams and that will not start before the global timeout.\n* router: added :ref:`RouteAction's auto_host_rewrite_header <envoy_api_field_route.RouteAction.auto_host_rewrite_header>` to allow upstream host header substitution with some other header's value\n* router: added support for UPSTREAM_REMOTE_ADDRESS :ref:`header formatter\n  <config_http_conn_man_headers_custom_request_headers>`.\n* router: add ability to reject a request that includes invalid values for\n  headers configured in :ref:`strict_check_headers <envoy_api_field_config.filter.http.router.v2.Router.strict_check_headers>`\n* runtime: added support for :ref:`flexible layering configuration\n  <envoy_api_field_config.bootstrap.v2.Bootstrap.layered_runtime>`.\n* runtime: added support for statically :ref:`specifying the runtime in the bootstrap configuration\n  <envoy_api_field_config.bootstrap.v2.Runtime.base>`.\n* runtime: :ref:`Runtime Discovery Service (RTDS) <config_runtime_rtds>` support added to layered runtime configuration.\n* sandbox: added :ref:`CSRF sandbox <install_sandboxes_csrf>`.\n* server: ``--define manual_stamp=manual_stamp`` was added to allow server stamping outside of binary rules.\n  more info in the `bazel docs <https://github.com/envoyproxy/envoy/blob/master/bazel/README.md#enabling-optional-features>`_.\n* server: added :ref:`server state <statistics>` statistic.\n* server: added :ref:`initialization_time_ms<statistics>` statistic.\n* subset: added :ref:`list_as_any<envoy_api_field_Cluster.LbSubsetConfig.list_as_any>` option to\n  the subset lb which allows matching metadata against any of the values in a list value\n  on the endpoints.\n* tools: added :repo:`proto <test/tools/router_check/validation.proto>` support for :ref:`router check tool <install_tools_route_table_check_tool>` tests.\n* tracing: add trace sampling configuration to the route, to override the route level.\n* upstream: added :ref:`upstream_cx_pool_overflow <config_cluster_manager_cluster_stats>` for the connection pool circuit breaker.\n* upstream: an EDS management server can now force removal of a host that is still passing active\n  health checking by first marking the host as failed via EDS health check and subsequently removing\n  it in a future update. This is a mechanism to work around a race condition in which an EDS\n  implementation may remove a host before it has stopped passing active HC, thus causing the host\n  to become stranded until a future update.\n* upstream: added :ref:`an option <envoy_api_field_Cluster.CommonLbConfig.ignore_new_hosts_until_first_hc>`\n  that allows ignoring new hosts for the purpose of load balancing calculations until they have\n  been health checked for the first time.\n* upstream: added runtime error checking to prevent setting dns type to STRICT_DNS or LOGICAL_DNS when custom resolver name is specified.\n* upstream: added possibility to override fallback_policy per specific selector in :ref:`subset load balancer <arch_overview_load_balancer_subsets>`.\n* upstream: the :ref:`logical DNS cluster <arch_overview_service_discovery_types_logical_dns>` now\n  displays the current resolved IP address in admin output instead of 0.0.0.0.\n\n1.10.0 (Apr 5, 2019)\n====================\n* access log: added a new flag for upstream retry count exceeded.\n* access log: added a :ref:`gRPC filter <envoy_api_msg_config.filter.accesslog.v2.GrpcStatusFilter>` to allow filtering on gRPC status.\n* access log: added a new flag for stream idle timeout.\n* access log: added a new field for upstream transport failure reason in :ref:`file access logger<config_access_log_format_upstream_transport_failure_reason>` and\n  :ref:`gRPC access logger<envoy_api_field_data.accesslog.v2.AccessLogCommon.upstream_transport_failure_reason>` for HTTP access logs.\n* access log: added new fields for downstream x509 information (URI sans and subject) to file and gRPC access logger.\n* admin: the admin server can now be accessed via HTTP/2 (prior knowledge).\n* admin: changed HTTP response status code from 400 to 405 when attempting to GET a POST-only route (such as /quitquitquit).\n* buffer: fix vulnerabilities when allocation fails.\n* build: releases are built with GCC-7 and linked with LLD.\n* build: dev docker images :ref:`have been split <install_binaries>` from tagged images for easier\n  discoverability in Docker Hub. Additionally, we now build images for point releases.\n* config: added support of using google.protobuf.Any in opaque configs for extensions.\n* config: logging warnings when deprecated fields are in use.\n* config: removed deprecated --v2-config-only from command line config.\n* config: removed deprecated_v1 sds_config from :ref:`Bootstrap config <config_overview_v2_bootstrap>`.\n* config: removed the deprecated_v1 config option from :ref:`ring hash <envoy_api_msg_Cluster.RingHashLbConfig>`.\n* config: removed REST_LEGACY as a valid :ref:`ApiType <envoy_api_field_core.ApiConfigSource.api_type>`.\n* config: finish cluster warming only when a named response i.e. ClusterLoadAssignment associated to the cluster being warmed comes in the EDS response. This is a behavioural change from the current implementation where warming of cluster completes on missing load assignments also.\n* config: use Envoy cpuset size to set the default number or worker threads if :option:`--cpuset-threads` is enabled.\n* config: added support for :ref:`initial_fetch_timeout <envoy_api_field_core.ConfigSource.initial_fetch_timeout>`. The timeout is disabled by default.\n* cors: added :ref:`filter_enabled & shadow_enabled RuntimeFractionalPercent flags <cors-runtime>` to filter.\n* csrf: added :ref:`CSRF filter <config_http_filters_csrf>`.\n* ext_authz: added support for buffering request body.\n* ext_authz: migrated from v2alpha to v2 and improved docs.\n* ext_authz: added a configurable option to make the gRPC service cross-compatible with V2Alpha. Note that this feature is already deprecated. It should be used for a short time, and only when transitioning from alpha to V2 release version.\n* ext_authz: migrated from v2alpha to v2 and improved the documentation.\n* ext_authz: authorization request and response configuration has been separated into two distinct objects: :ref:`authorization request\n  <envoy_api_field_config.filter.http.ext_authz.v2.HttpService.authorization_request>` and :ref:`authorization response\n  <envoy_api_field_config.filter.http.ext_authz.v2.HttpService.authorization_response>`. In addition, :ref:`client headers\n  <envoy_api_field_config.filter.http.ext_authz.v2.AuthorizationResponse.allowed_client_headers>` and :ref:`upstream headers\n  <envoy_api_field_config.filter.http.ext_authz.v2.AuthorizationResponse.allowed_upstream_headers>` replaces the previous *allowed_authorization_headers* object.\n  All the control header lists now support :ref:`string matcher <envoy_api_msg_type.matcher.StringMatcher>` instead of standard string.\n* fault: added the :ref:`max_active_faults\n  <envoy_api_field_config.filter.http.fault.v2.HTTPFault.max_active_faults>` setting, as well as\n  :ref:`statistics <config_http_filters_fault_injection_stats>` for the number of active faults\n  and the number of faults the overflowed.\n* fault: added :ref:`response rate limit\n  <envoy_api_field_config.filter.http.fault.v2.HTTPFault.response_rate_limit>` fault injection.\n* fault: added :ref:`HTTP header fault configuration\n  <config_http_filters_fault_injection_http_header>` to the HTTP fault filter.\n* governance: extending Envoy deprecation policy from 1 release (0-3 months) to 2 releases (3-6 months).\n* health check: expected response codes in http health checks are now :ref:`configurable <envoy_api_msg_core.HealthCheck.HttpHealthCheck>`.\n* http: added new grpc_http1_reverse_bridge filter for converting gRPC requests into HTTP/1.1 requests.\n* http: fixed a bug where Content-Length:0 was added to HTTP/1 204 responses.\n* http: added :ref:`max request headers size <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.max_request_headers_kb>`. The default behaviour is unchanged.\n* http: added modifyDecodingBuffer/modifyEncodingBuffer to allow modifying the buffered request/response data.\n* http: added encodeComplete/decodeComplete. These are invoked at the end of the stream, after all data has been encoded/decoded respectively. Default implementation is a no-op.\n* outlier_detection: added support for :ref:`outlier detection event protobuf-based logging <arch_overview_outlier_detection_logging>`.\n* mysql: added a MySQL proxy filter that is capable of parsing SQL queries over MySQL wire protocol. Refer to :ref:`MySQL proxy<config_network_filters_mysql_proxy>` for more details.\n* performance: new buffer implementation (disabled by default; to test it, add \"--use-libevent-buffers 0\" to the command-line arguments when starting Envoy).\n* jwt_authn: added :ref:`filter_state_rules <envoy_api_field_config.filter.http.jwt_authn.v2alpha.JwtAuthentication.filter_state_rules>` to allow specifying requirements from filterState by other filters.\n* ratelimit: removed deprecated rate limit configuration from bootstrap.\n* redis: added :ref:`hashtagging <envoy_api_field_config.filter.network.redis_proxy.v2.RedisProxy.ConnPoolSettings.enable_hashtagging>` to guarantee a given key's upstream.\n* redis: added :ref:`latency stats <config_network_filters_redis_proxy_per_command_stats>` for commands.\n* redis: added :ref:`success and error stats <config_network_filters_redis_proxy_per_command_stats>` for commands.\n* redis: migrate hash function for host selection to `MurmurHash2 <https://sites.google.com/site/murmurhash>`_ from std::hash. MurmurHash2 is compatible with std::hash in GNU libstdc++ 3.4.20 or above. This is typically the case when compiled on Linux and not macOS.\n* redis: added :ref:`latency_in_micros <envoy_api_field_config.filter.network.redis_proxy.v2.RedisProxy.latency_in_micros>` to specify the redis commands stats time unit in microseconds.\n* router: added ability to configure a :ref:`retry policy <envoy_api_msg_route.RetryPolicy>` at the\n  virtual host level.\n* router: added reset reason to response body when upstream reset happens. After this change, the response body will be of the form `upstream connect error or disconnect/reset before headers. reset reason:`\n* router: added :ref:`rq_reset_after_downstream_response_started <config_http_filters_router_stats>` counter stat to router stats.\n* router: added per-route configuration of :ref:`internal redirects <envoy_api_field_route.RouteAction.internal_redirect_action>`.\n* router: removed deprecated route-action level headers_to_add/remove.\n* router: made :ref:`max retries header <config_http_filters_router_x-envoy-max-retries>` take precedence over the number of retries in route and virtual host retry policies.\n* router: added support for prefix wildcards in :ref:`virtual host domains<envoy_api_field_route.VirtualHost.domains>`\n* stats: added support for histograms in prometheus\n* stats: added usedonly flag to prometheus stats to only output metrics which have been\n  updated at least once.\n* stats: added gauges tracking remaining resources before circuit breakers open.\n* tap: added new alpha :ref:`HTTP tap filter <config_http_filters_tap>`.\n* tls: enabled TLS 1.3 on the server-side (non-FIPS builds).\n* upstream: add hash_function to specify the hash function for :ref:`ring hash<envoy_api_msg_Cluster.RingHashLbConfig>` as either xxHash or `murmurHash2 <https://sites.google.com/site/murmurhash>`_. MurmurHash2 is compatible with std::hash in GNU libstdc++ 3.4.20 or above. This is typically the case when compiled on Linux and not macOS.\n* upstream: added :ref:`degraded health value<arch_overview_load_balancing_degraded>` which allows\n  routing to certain hosts only when there are insufficient healthy hosts available.\n* upstream: add cluster factory to allow creating and registering :ref:`custom cluster type<arch_overview_service_discovery_types_custom>`.\n* upstream: added a :ref:`circuit breaker <arch_overview_circuit_break_cluster_maximum_connection_pools>` to limit the number of concurrent connection pools in use.\n* tracing: added :ref:`verbose <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.tracing>` to support logging annotations on spans.\n* upstream: added support for host weighting and :ref:`locality weighting <arch_overview_load_balancing_locality_weighted_lb>` in the :ref:`ring hash load balancer <arch_overview_load_balancing_types_ring_hash>`, and added a :ref:`maximum_ring_size<envoy_api_field_Cluster.RingHashLbConfig.maximum_ring_size>` config parameter to strictly bound the ring size.\n* zookeeper: added a ZooKeeper proxy filter that parses ZooKeeper messages (requests/responses/events).\n  Refer to :ref:`ZooKeeper proxy<config_network_filters_zookeeper_proxy>` for more details.\n* upstream: added configuration option to select any host when the fallback policy fails.\n* upstream: stopped incrementing upstream_rq_total for HTTP/1 conn pool when request is circuit broken.\n\n1.9.1 (Apr 2, 2019)\n===================\n* http: fixed CVE-2019-9900 by rejecting HTTP/1.x headers with embedded NUL characters.\n* http: fixed CVE-2019-9901 by normalizing HTTP paths prior to routing or L7 data plane processing.\n  This defaults off and is configurable via either HTTP connection manager :ref:`normalize_path\n  <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.normalize_path>`\n  or the :ref:`runtime <config_http_conn_man_runtime_normalize_path>`.\n\n1.9.0 (Dec 20, 2018)\n====================\n* access log: added a :ref:`JSON logging mode <config_access_log_format_dictionaries>` to output access logs in JSON format.\n* access log: added dynamic metadata to access log messages streamed over gRPC.\n* access log: added DOWNSTREAM_CONNECTION_TERMINATION.\n* admin: :http:post:`/logging` now responds with 200 while there are no params.\n* admin: added support for displaying subject alternate names in :ref:`certs<operations_admin_interface_certs>` end point.\n* admin: added host weight to the :http:get:`/clusters?format=json` end point response.\n* admin: :http:get:`/server_info` now responds with a JSON object instead of a single string.\n* admin: :http:get:`/server_info` now exposes what stage of initialization the server is currently in.\n* admin: added support for displaying command line options in :http:get:`/server_info` end point.\n* circuit-breaker: added cx_open, rq_pending_open, rq_open and rq_retry_open gauges to expose live\n  state via :ref:`circuit breakers statistics <config_cluster_manager_cluster_stats_circuit_breakers>`.\n* cluster: set a default of 1s for :ref:`option <envoy_api_field_Cluster.CommonLbConfig.update_merge_window>`.\n* config: removed support for the v1 API.\n* config: added support for :ref:`rate limiting<envoy_api_msg_core.RateLimitSettings>` discovery request calls.\n* cors: added :ref:`invalid/valid stats <cors-statistics>` to filter.\n* ext-authz: added support for providing per route config - optionally disable the filter and provide context extensions.\n* fault: removed integer percentage support.\n* grpc-json: added support for :ref:`ignoring query parameters\n  <envoy_api_field_config.filter.http.transcoder.v2.GrpcJsonTranscoder.ignored_query_parameters>`.\n* health check: added :ref:`logging health check failure events <envoy_api_field_core.HealthCheck.always_log_health_check_failures>`.\n* health check: added ability to set :ref:`authority header value\n  <envoy_api_field_core.HealthCheck.GrpcHealthCheck.authority>` for gRPC health check.\n* http: added HTTP/2 WebSocket proxying via :ref:`extended CONNECT <envoy_api_field_core.Http2ProtocolOptions.allow_connect>`.\n* http: added limits to the number and length of header modifications in all fields request_headers_to_add and response_headers_to_add. These limits are very high and should only be used as a last-resort safeguard.\n* http: added support for a :ref:`request timeout <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.request_timeout>`. The timeout is disabled by default.\n* http: no longer adding whitespace when appending X-Forwarded-For headers. **Warning**: this is not\n  compatible with 1.7.0 builds prior to `9d3a4eb4ac44be9f0651fcc7f87ad98c538b01ee <https://github.com/envoyproxy/envoy/pull/3610>`_.\n  See `#3611 <https://github.com/envoyproxy/envoy/issues/3611>`_ for details.\n* http: augmented the `sendLocalReply` filter API to accept an optional `GrpcStatus`\n  value to override the default HTTP to gRPC status mapping.\n* http: no longer close the TCP connection when a HTTP/1 request is retried due\n  to a response with empty body.\n* http: added support for more gRPC content-type headers in :ref:`gRPC bridge filter <config_http_filters_grpc_bridge>`, like application/grpc+proto.\n* listeners: all listener filters are now governed by the :ref:`listener_filters_timeout\n  <envoy_api_field_Listener.listener_filters_timeout>` setting. The hard coded 15s timeout in\n  the :ref:`TLS inspector listener filter <config_listener_filters_tls_inspector>` is superseded by\n  this setting.\n* listeners: added the ability to match :ref:`FilterChain <envoy_api_msg_listener.FilterChain>` using :ref:`source_type <envoy_api_field_listener.FilterChainMatch.source_type>`.\n* load balancer: added a `configuration <envoy_api_msg_Cluster.LeastRequestLbConfig>` option to specify the number of choices made in P2C.\n* logging: added missing [ in log prefix.\n* mongo_proxy: added :ref:`dynamic metadata <config_network_filters_mongo_proxy_dynamic_metadata>`.\n* network: removed the reference to `FilterState` in `Connection` in favor of `StreamInfo`.\n* rate-limit: added :ref:`configuration <envoy_api_field_config.filter.http.rate_limit.v2.RateLimit.rate_limited_as_resource_exhausted>`\n  to specify whether the `GrpcStatus` status returned should be `RESOURCE_EXHAUSTED` or\n  `UNAVAILABLE` when a gRPC call is rate limited.\n* rate-limit: removed support for the legacy ratelimit service and made the data-plane-api\n  :ref:`rls.proto <envoy_api_file_envoy/service/ratelimit/v2/rls.proto>` based implementation default.\n* rate-limit: removed the deprecated cluster_name attribute in :ref:`rate limit service configuration <envoy_api_file_envoy/config/ratelimit/v2/rls.proto>`.\n* rate-limit: added :ref:`rate_limit_service <envoy_api_msg_config.filter.http.rate_limit.v2.RateLimit>` configuration to filters.\n* rbac: added dynamic metadata to the network level filter.\n* rbac: added support for permission matching by :ref:`requested server name <envoy_api_field_config.rbac.v2.Permission.requested_server_name>`.\n* redis: static cluster configuration is no longer required. Redis proxy will work with clusters\n  delivered via CDS.\n* router: added ability to configure arbitrary :ref:`retriable status codes. <envoy_api_field_route.RetryPolicy.retriable_status_codes>`\n* router: added ability to set attempt count in upstream requests, see :ref:`virtual host's include request\n  attempt count flag <envoy_api_field_route.VirtualHost.include_request_attempt_count>`.\n* router: added internal :ref:`grpc-retry-on <config_http_filters_router_x-envoy-retry-grpc-on>` policy.\n* router: added :ref:`scheme_redirect <envoy_api_field_route.RedirectAction.scheme_redirect>` and\n  :ref:`port_redirect <envoy_api_field_route.RedirectAction.port_redirect>` to define the respective\n  scheme and port rewriting RedirectAction.\n* router: when :ref:`max_grpc_timeout <envoy_api_field_route.RouteAction.max_grpc_timeout>`\n  is set, Envoy will now add or update the grpc-timeout header to reflect Envoy's expected timeout.\n* router: per try timeouts now starts when an upstream stream is ready instead of when the request has\n  been fully decoded by Envoy.\n* router: added support for not retrying :ref:`rate limited requests<config_http_filters_router_x-envoy-ratelimited>`. Rate limit filter now sets the :ref:`x-envoy-ratelimited<config_http_filters_router_x-envoy-ratelimited>`\n  header so the rate limited requests that may have been retried earlier will not be retried with this change.\n* router: added support for enabling upgrades on a :ref:`per-route <envoy_api_field_route.RouteAction.upgrade_configs>` basis.\n* router: support configuring a default fraction of mirror traffic via\n  :ref:`runtime_fraction <envoy_api_field_route.RouteAction.RequestMirrorPolicy.runtime_key>`.\n* sandbox: added :ref:`cors sandbox <install_sandboxes_cors>`.\n* server: added `SIGINT` (Ctrl-C) handler to gracefully shutdown Envoy like `SIGTERM`.\n* stats: added :ref:`stats_matcher <envoy_api_field_config.metrics.v2.StatsConfig.stats_matcher>` to the bootstrap config for granular control of stat instantiation.\n* stream: renamed the `RequestInfo` namespace to `StreamInfo` to better match\n  its behaviour within TCP and HTTP implementations.\n* stream: renamed `perRequestState` to `filterState` in `StreamInfo`.\n* stream: added `downstreamDirectRemoteAddress` to `StreamInfo`.\n* thrift_proxy: introduced thrift rate limiter filter.\n* tls: added ssl.curves.<curve>, ssl.sigalgs.<sigalg> and ssl.versions.<version> to\n  :ref:`listener metrics <config_listener_stats>` to track TLS algorithms and versions in use.\n* tls: added support for :ref:`client-side session resumption <envoy_api_field_auth.UpstreamTlsContext.max_session_keys>`.\n* tls: added support for CRLs in :ref:`trusted_ca <envoy_api_field_auth.CertificateValidationContext.trusted_ca>`.\n* tls: added support for :ref:`multiple server TLS certificates <arch_overview_ssl_cert_select>`.\n* tls: added support for :ref:`password encrypted private keys <envoy_api_field_auth.TlsCertificate.password>`.\n* tls: added the ability to build :ref:`BoringSSL FIPS <arch_overview_ssl_fips>` using ``--define boringssl=fips`` Bazel option.\n* tls: removed support for ECDSA certificates with curves other than P-256.\n* tls: removed support for RSA certificates with keys smaller than 2048-bits.\n* tracing: added support to the Zipkin tracer for the :ref:`b3 <config_http_conn_man_headers_b3>` single header format.\n* tracing: added support for :ref:`Datadog <arch_overview_tracing>` tracer.\n* upstream: added :ref:`scale_locality_weight<envoy_api_field_Cluster.LbSubsetConfig.scale_locality_weight>` to enable\n  scaling locality weights by number of hosts removed by subset lb predicates.\n* upstream: changed how load calculation for :ref:`priority levels<arch_overview_load_balancing_priority_levels>` and :ref:`panic thresholds<arch_overview_load_balancing_panic_threshold>` interact. As long as normalized total health is 100% panic thresholds are disregarded.\n* upstream: changed the default hash for :ref:`ring hash <envoy_api_msg_Cluster.RingHashLbConfig>` from std::hash to `xxHash <https://github.com/Cyan4973/xxHash>`_.\n* upstream: when using active health checking and STRICT_DNS with several addresses that resolve\n  to the same hosts, Envoy will now health check each host independently.\n\n1.8.0 (Oct 4, 2018)\n===================\n* access log: added :ref:`response flag filter <envoy_api_msg_config.filter.accesslog.v2.ResponseFlagFilter>`\n  to filter based on the presence of Envoy response flags.\n* access log: added RESPONSE_DURATION and RESPONSE_TX_DURATION.\n* access log: added REQUESTED_SERVER_NAME for SNI to tcp_proxy and http\n* admin: added :http:get:`/hystrix_event_stream` as an endpoint for monitoring envoy's statistics\n  through `Hystrix dashboard <https://github.com/Netflix-Skunkworks/hystrix-dashboard/wiki>`_.\n* cli: added support for :ref:`component log level <operations_cli>` command line option for configuring log levels of individual components.\n* cluster: added :ref:`option <envoy_api_field_Cluster.CommonLbConfig.update_merge_window>` to merge\n  health check/weight/metadata updates within the given duration.\n* config: regex validation added to limit to a maximum of 1024 characters.\n* config: v1 disabled by default. v1 support remains available until October via flipping --v2-config-only=false.\n* config: v1 disabled by default. v1 support remains available until October via deprecated flag --allow-deprecated-v1-api.\n* config: fixed stat inconsistency between xDS and ADS implementation. :ref:`update_failure <config_cluster_manager_cds>`\n  stat is incremented in case of network failure and :ref:`update_rejected <config_cluster_manager_cds>` stat is incremented\n  in case of schema/validation error.\n* config: added a stat :ref:`connected_state <management_server_stats>` that indicates current connected state of Envoy with\n  management server.\n* ext_authz: added support for configuring additional :ref:`authorization headers <envoy_api_field_config.filter.http.ext_authz.v2.AuthorizationRequest.headers_to_add>`\n  to be sent from Envoy to the authorization service.\n* fault: added support for fractional percentages in :ref:`FaultDelay <envoy_api_field_config.filter.fault.v2.FaultDelay.percentage>`\n  and in :ref:`FaultAbort <envoy_api_field_config.filter.http.fault.v2.FaultAbort.percentage>`.\n* grpc-json: added support for building HTTP response from\n  `google.api.HttpBody <https://github.com/googleapis/googleapis/blob/master/google/api/httpbody.proto>`_.\n* health check: added support for :ref:`custom health check <envoy_api_field_core.HealthCheck.custom_health_check>`.\n* health check: added support for :ref:`specifying jitter as a percentage <envoy_api_field_core.HealthCheck.interval_jitter_percent>`.\n* health_check: added support for :ref:`health check event logging <arch_overview_health_check_logging>`.\n* health_check: added :ref:`timestamp <envoy_api_field_data.core.v2alpha.HealthCheckEvent.timestamp>`\n  to the :ref:`health check event <envoy_api_msg_data.core.v2alpha.HealthCheckEvent>` definition.\n* health_check: added support for specifying :ref:`custom request headers <config_http_conn_man_headers_custom_request_headers>`\n  to HTTP health checker requests.\n* http: added support for a :ref:`per-stream idle timeout\n  <envoy_api_field_route.RouteAction.idle_timeout>`. This applies at both :ref:`connection manager\n  <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.stream_idle_timeout>`\n  and :ref:`per-route granularity <envoy_api_field_route.RouteAction.idle_timeout>`. The timeout\n  defaults to 5 minutes; if you have other timeouts (e.g. connection idle timeout, upstream\n  response per-retry) that are longer than this in duration, you may want to consider setting a\n  non-default per-stream idle timeout.\n* http: added upstream_rq_completed counter for :ref:`total requests completed <config_cluster_manager_cluster_stats_dynamic_http>` to dynamic HTTP counters.\n* http: added downstream_rq_completed counter for :ref:`total requests completed <config_http_conn_man_stats>`, including on a :ref:`per-listener basis <config_http_conn_man_stats_per_listener>`.\n* http: added generic :ref:`Upgrade support\n  <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.upgrade_configs>`.\n* http: better handling of HEAD requests. Now sending transfer-encoding: chunked rather than content-length: 0.\n* http: fixed missing support for appending to predefined inline headers, e.g.\n  *authorization*, in features that interact with request and response headers,\n  e.g. :ref:`request_headers_to_add\n  <envoy_api_field_route.Route.request_headers_to_add>`. For example, a\n  request header *authorization: token1* will appear as *authorization:\n  token1,token2*, after having :ref:`request_headers_to_add\n  <envoy_api_field_route.Route.request_headers_to_add>` with *authorization:\n  token2* applied.\n* http: response filters not applied to early error paths such as http_parser generated 400s.\n* http: restrictions added to reject *:*-prefixed pseudo-headers in :ref:`custom\n  request headers <config_http_conn_man_headers_custom_request_headers>`.\n* http: :ref:`hpack_table_size <envoy_api_field_core.Http2ProtocolOptions.hpack_table_size>` now controls\n  dynamic table size of both: encoder and decoder.\n* http: added support for removing request headers using :ref:`request_headers_to_remove\n  <envoy_api_field_route.Route.request_headers_to_remove>`.\n* http: added support for a :ref:`delayed close timeout<envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.delayed_close_timeout>` to mitigate race conditions when closing connections to downstream HTTP clients. The timeout defaults to 1 second.\n* jwt-authn filter: add support for per route JWT requirements.\n* listeners: added the ability to match :ref:`FilterChain <envoy_api_msg_listener.FilterChain>` using\n  :ref:`destination_port <envoy_api_field_listener.FilterChainMatch.destination_port>` and\n  :ref:`prefix_ranges <envoy_api_field_listener.FilterChainMatch.prefix_ranges>`.\n* lua: added :ref:`connection() <config_http_filters_lua_connection_wrapper>` wrapper and *ssl()* API.\n* lua: added :ref:`streamInfo() <config_http_filters_lua_stream_info_wrapper>` wrapper and *protocol()* API.\n* lua: added :ref:`streamInfo():dynamicMetadata() <config_http_filters_lua_stream_info_dynamic_metadata_wrapper>` API.\n* network: introduced :ref:`sni_cluster <config_network_filters_sni_cluster>` network filter that forwards connections to the\n  upstream cluster specified by the SNI value presented by the client during a TLS handshake.\n* proxy_protocol: added support for HAProxy Proxy Protocol v2 (AF_INET/AF_INET6 only).\n* ratelimit: added support for :repo:`api/envoy/service/ratelimit/v2/rls.proto`.\n  Lyft's reference implementation of the `ratelimit <https://github.com/lyft/ratelimit>`_ service also supports the data-plane-api proto as of v1.1.0.\n  Envoy can use either proto to send client requests to a ratelimit server with the use of the\n  `use_data_plane_proto` boolean flag in the ratelimit configuration.\n  Support for the legacy proto `source/common/ratelimit/ratelimit.proto` is deprecated and will be removed at the start of the 1.9.0 release cycle.\n* ratelimit: added :ref:`failure_mode_deny <envoy_api_msg_config.filter.http.rate_limit.v2.RateLimit>` option to control traffic flow in\n  case of rate limit service error.\n* rbac config: added a :ref:`principal_name <envoy_api_field_config.rbac.v2.Principal.Authenticated.principal_name>` field and\n  removed the old `name` field to give more flexibility for matching certificate identity.\n* rbac network filter: a :ref:`role-based access control network filter <config_network_filters_rbac>` has been added.\n* rest-api: added ability to set the :ref:`request timeout <envoy_api_field_core.ApiConfigSource.request_timeout>` for REST API requests.\n* route checker: added v2 config support and removed support for v1 configs.\n* router: added ability to set request/response headers at the :ref:`envoy_api_msg_route.Route` level.\n* stats: added :ref:`option to configure the DogStatsD metric name prefix<envoy_api_field_config.metrics.v2.DogStatsdSink.prefix>` to DogStatsdSink.\n* tcp_proxy: added support for :ref:`weighted clusters <envoy_api_field_config.filter.network.tcp_proxy.v2.TcpProxy.weighted_clusters>`.\n* thrift_proxy: introduced thrift routing, moved configuration to correct location\n* thrift_proxy: introduced thrift configurable decoder filters\n* tls: implemented :ref:`Secret Discovery Service <config_secret_discovery_service>`.\n* tracing: added support for configuration of :ref:`tracing sampling\n  <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.tracing>`.\n* upstream: added configuration option to the subset load balancer to take locality weights into account when\n  selecting a host from a subset.\n* upstream: require opt-in to use the :ref:`x-envoy-original-dst-host <config_http_conn_man_headers_x-envoy-original-dst-host>` header\n  for overriding destination address when using the :ref:`Original Destination <arch_overview_load_balancing_types_original_destination>`\n  load balancing policy.\n\n1.7.0 (Jun 21, 2018)\n====================\n* access log: added ability to log response trailers.\n* access log: added ability to format START_TIME.\n* access log: added DYNAMIC_METADATA :ref:`access log formatter <config_access_log_format>`.\n* access log: added :ref:`HeaderFilter <envoy_api_msg_config.filter.accesslog.v2.HeaderFilter>`\n  to filter logs based on request headers.\n* access log: added `%([1-9])?f` as one of START_TIME specifiers to render subseconds.\n* access log: gRPC Access Log Service (ALS) support added for :ref:`HTTP access logs\n  <envoy_api_msg_config.accesslog.v2.HttpGrpcAccessLogConfig>`.\n* access log: improved WebSocket logging.\n* admin: added :http:get:`/config_dump` for dumping the current configuration and associated xDS\n  version information (if applicable).\n* admin: added :http:get:`/clusters?format=json` for outputing a JSON-serialized proto detailing\n  the current status of all clusters.\n* admin: added :http:get:`/stats/prometheus` as an alternative endpoint for getting stats in prometheus format.\n* admin: added :ref:`/runtime_modify endpoint <operations_admin_interface_runtime_modify>` to add or change runtime values.\n* admin: mutations must be sent as POSTs, rather than GETs. Mutations include:\n  :http:post:`/cpuprofiler`, :http:post:`/healthcheck/fail`, :http:post:`/healthcheck/ok`,\n  :http:post:`/logging`, :http:post:`/quitquitquit`, :http:post:`/reset_counters`,\n  :http:post:`/runtime_modify?key1=value1&key2=value2&keyN=valueN`.\n* admin: removed `/routes` endpoint; route configs can now be found at the :ref:`/config_dump endpoint <operations_admin_interface_config_dump>`.\n* buffer filter: the buffer filter can be optionally\n  :ref:`disabled <envoy_api_field_config.filter.http.buffer.v2.BufferPerRoute.disabled>` or\n  :ref:`overridden <envoy_api_field_config.filter.http.buffer.v2.BufferPerRoute.buffer>` with\n  route-local configuration.\n* cli: added --config-yaml flag to the Envoy binary. When set its value is interpreted as a yaml\n  representation of the bootstrap config and overrides --config-path.\n* cluster: added :ref:`option <envoy_api_field_Cluster.close_connections_on_host_health_failure>`\n  to close tcp_proxy upstream connections when health checks fail.\n* cluster: added :ref:`option <envoy_api_field_Cluster.drain_connections_on_host_removal>` to drain\n  connections from hosts after they are removed from service discovery, regardless of health status.\n* cluster: fixed bug preventing the deletion of all endpoints in a priority\n* debug: added symbolized stack traces (where supported)\n* ext-authz filter: added support to raw HTTP authorization.\n* ext-authz filter: added support to gRPC responses to carry HTTP attributes.\n* grpc: support added for the full set of :ref:`Google gRPC call credentials\n  <envoy_api_msg_core.GrpcService.GoogleGrpc.CallCredentials>`.\n* gzip filter: added :ref:`stats <gzip-statistics>` to the filter.\n* gzip filter: sending *accept-encoding* header as *identity* no longer compresses the payload.\n* health check: added ability to set :ref:`additional HTTP headers\n  <envoy_api_field_core.HealthCheck.HttpHealthCheck.request_headers_to_add>` for HTTP health check.\n* health check: added support for EDS delivered :ref:`endpoint health status\n  <envoy_api_field_endpoint.LbEndpoint.health_status>`.\n* health check: added interval overrides for health state transitions from :ref:`healthy to unhealthy\n  <envoy_api_field_core.HealthCheck.unhealthy_edge_interval>`, :ref:`unhealthy to healthy\n  <envoy_api_field_core.HealthCheck.healthy_edge_interval>` and for subsequent checks on\n  :ref:`unhealthy hosts <envoy_api_field_core.HealthCheck.unhealthy_interval>`.\n* health check: added support for :ref:`custom health check <envoy_api_field_core.HealthCheck.custom_health_check>`.\n* health check: health check connections can now be configured to use http/2.\n* health check http filter: added\n  :ref:`generic header matching <envoy_api_field_config.filter.http.health_check.v2.HealthCheck.headers>`\n  to trigger health check response. Deprecated the endpoint option.\n* http: filters can now optionally support\n  :ref:`virtual host <envoy_api_field_route.VirtualHost.per_filter_config>`,\n  :ref:`route <envoy_api_field_route.Route.per_filter_config>`, and\n  :ref:`weighted cluster <envoy_api_field_route.WeightedCluster.ClusterWeight.per_filter_config>`\n  local configuration.\n* http: added the ability to pass DNS type Subject Alternative Names of the client certificate in the\n  :ref:`config_http_conn_man_headers_x-forwarded-client-cert` header.\n* http: local responses to gRPC requests are now sent as trailers-only gRPC responses instead of plain HTTP responses.\n  Notably the HTTP response code is always \"200\" in this case, and the gRPC error code is carried in \"grpc-status\"\n  header, optionally accompanied with a text message in \"grpc-message\" header.\n* http: added support for :ref:`via header\n  <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.via>`\n  append.\n* http: added a :ref:`configuration option\n  <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.skip_xff_append>`\n  to elide *x-forwarded-for* header modifications.\n* http: fixed a bug in inline headers where addCopy and addViaMove didn't add header values when\n  encountering inline headers with multiple instances.\n* listeners: added :ref:`tcp_fast_open_queue_length <envoy_api_field_Listener.tcp_fast_open_queue_length>` option.\n* listeners: added the ability to match :ref:`FilterChain <envoy_api_msg_listener.FilterChain>` using\n  :ref:`application_protocols <envoy_api_field_listener.FilterChainMatch.application_protocols>`\n  (e.g. ALPN for TLS protocol).\n* listeners: `sni_domains` has been deprecated/renamed to :ref:`server_names <envoy_api_field_listener.FilterChainMatch.server_names>`.\n* listeners: removed restriction on all filter chains having identical filters.\n* load balancer: added :ref:`weighted round robin\n  <arch_overview_load_balancing_types_round_robin>` support. The round robin\n  scheduler now respects endpoint weights and also has improved fidelity across\n  picks.\n* load balancer: :ref:`locality weighted load balancing\n  <arch_overview_load_balancer_subsets>` is now supported.\n* load balancer: ability to configure zone aware load balancer settings :ref:`through the API\n  <envoy_api_field_Cluster.CommonLbConfig.zone_aware_lb_config>`.\n* load balancer: the :ref:`weighted least request\n  <arch_overview_load_balancing_types_least_request>` load balancing algorithm has been improved\n  to have better balance when operating in weighted mode.\n* logger: added the ability to optionally set the log format via the :option:`--log-format` option.\n* logger: all :ref:`logging levels <operations_admin_interface_logging>` can be configured\n  at run-time: trace debug info warning error critical.\n* rbac http filter: a :ref:`role-based access control http filter <config_http_filters_rbac>` has been added.\n* router: the behavior of per-try timeouts have changed in the case where a portion of the response has\n  already been proxied downstream when the timeout occurs. Previously, the response would be reset\n  leading to either an HTTP/2 reset or an HTTP/1 closed connection and a partial response. Now, the\n  timeout will be ignored and the response will continue to proxy up to the global request timeout.\n* router: changed the behavior of :ref:`source IP routing <envoy_api_field_route.RouteAction.HashPolicy.ConnectionProperties.source_ip>`\n  to ignore the source port.\n* router: added an :ref:`prefix_match <envoy_api_field_route.HeaderMatcher.prefix_match>` match type\n  to explicitly match based on the prefix of a header value.\n* router: added an :ref:`suffix_match <envoy_api_field_route.HeaderMatcher.suffix_match>` match type\n  to explicitly match based on the suffix of a header value.\n* router: added an :ref:`present_match <envoy_api_field_route.HeaderMatcher.present_match>` match type\n  to explicitly match based on a header's presence.\n* router: added an :ref:`invert_match <envoy_api_field_route.HeaderMatcher.invert_match>` config option\n  which supports inverting all other match types to match based on headers which are not a desired value.\n* router: allow :ref:`cookie routing <envoy_api_msg_route.RouteAction.HashPolicy.Cookie>` to\n  generate session cookies.\n* router: added START_TIME as one of supported variables in :ref:`header\n  formatters <config_http_conn_man_headers_custom_request_headers>`.\n* router: added a :ref:`max_grpc_timeout <envoy_api_field_route.RouteAction.max_grpc_timeout>`\n  config option to specify the maximum allowable value for timeouts decoded from gRPC header field\n  `grpc-timeout`.\n* router: added a :ref:`configuration option\n  <envoy_api_field_config.filter.http.router.v2.Router.suppress_envoy_headers>` to disable *x-envoy-*\n  header generation.\n* router: added 'unavailable' to the retriable gRPC status codes that can be specified\n  through :ref:`x-envoy-retry-grpc-on <config_http_filters_router_x-envoy-retry-grpc-on>`.\n* sockets: added :ref:`tap transport socket extension <operations_traffic_tapping>` to support\n  recording plain text traffic and PCAP generation.\n* sockets: added `IP_FREEBIND` socket option support for :ref:`listeners\n  <envoy_api_field_Listener.freebind>` and upstream connections via\n  :ref:`cluster manager wide\n  <envoy_api_field_config.bootstrap.v2.ClusterManager.upstream_bind_config>` and\n  :ref:`cluster specific <envoy_api_field_Cluster.upstream_bind_config>` options.\n* sockets: added `IP_TRANSPARENT` socket option support for :ref:`listeners\n  <envoy_api_field_Listener.transparent>`.\n* sockets: added `SO_KEEPALIVE` socket option for upstream connections\n  :ref:`per cluster <envoy_api_field_Cluster.upstream_connection_options>`.\n* stats: added support for histograms.\n* stats: added :ref:`option to configure the statsd prefix<envoy_api_field_config.metrics.v2.StatsdSink.prefix>`.\n* stats: updated stats sink interface to flush through a single call.\n* tls: added support for\n  :ref:`verify_certificate_spki <envoy_api_field_auth.CertificateValidationContext.verify_certificate_spki>`.\n* tls: added support for multiple\n  :ref:`verify_certificate_hash <envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash>`\n  values.\n* tls: added support for using\n  :ref:`verify_certificate_spki <envoy_api_field_auth.CertificateValidationContext.verify_certificate_spki>`\n  and :ref:`verify_certificate_hash <envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash>`\n  without :ref:`trusted_ca <envoy_api_field_auth.CertificateValidationContext.trusted_ca>`.\n* tls: added support for allowing expired certificates with\n  :ref:`allow_expired_certificate <envoy_api_field_auth.CertificateValidationContext.allow_expired_certificate>`.\n* tls: added support for :ref:`renegotiation <envoy_api_field_auth.UpstreamTlsContext.allow_renegotiation>`\n  when acting as a client.\n* tls: removed support for legacy SHA-2 CBC cipher suites.\n* tracing: the sampling decision is now delegated to the tracers, allowing the tracer to decide when and if\n  to use it. For example, if the :ref:`x-b3-sampled <config_http_conn_man_headers_x-b3-sampled>` header\n  is supplied with the client request, its value will override any sampling decision made by the Envoy proxy.\n* websocket: support configuring idle_timeout and max_connect_attempts.\n* upstream: added support for host override for a request in :ref:`Original destination host request header <arch_overview_load_balancing_types_original_destination_request_header>`.\n* header to metadata: added :ref:`HTTP Header to Metadata filter<config_http_filters_header_to_metadata>`.\n\n1.6.0 (March 20, 2018)\n======================\n\n* access log: added DOWNSTREAM_REMOTE_ADDRESS, DOWNSTREAM_REMOTE_ADDRESS_WITHOUT_PORT, and\n  DOWNSTREAM_LOCAL_ADDRESS :ref:`access log formatters <config_access_log_format>`.\n  DOWNSTREAM_ADDRESS access log formatter has been deprecated.\n* access log: added less than or equal (LE) :ref:`comparison filter\n  <envoy_api_msg_config.filter.accesslog.v2.ComparisonFilter>`.\n* access log: added configuration to :ref:`runtime filter\n  <envoy_api_msg_config.filter.accesslog.v2.RuntimeFilter>` to set default sampling rate, divisor,\n  and whether to use independent randomness or not.\n* admin: added :ref:`/runtime <operations_admin_interface_runtime>` admin endpoint to read the\n  current runtime values.\n* build: added support for :repo:`building Envoy with exported symbols\n  <bazel#enabling-optional-features>`. This change allows scripts loaded with the Lua filter to\n  load shared object libraries such as those installed via `LuaRocks <https://luarocks.org/>`_.\n* config: added support for sending error details as\n  `grpc.rpc.Status <https://github.com/googleapis/googleapis/blob/master/google/rpc/status.proto>`_\n  in :ref:`DiscoveryRequest <envoy_api_msg_DiscoveryRequest>`.\n* config: added support for :ref:`inline delivery <envoy_api_msg_core.DataSource>` of TLS\n  certificates and private keys.\n* config: added restrictions for the backing :ref:`config sources <envoy_api_msg_core.ConfigSource>`\n  of xDS resources. For filesystem based xDS the file must exist at configuration time. For cluster\n  based xDS the backing cluster must be statically defined and be of non-EDS type.\n* grpc: the Google gRPC C++ library client is now supported as specified in the :ref:`gRPC services\n  overview <arch_overview_grpc_services>` and :ref:`GrpcService <envoy_api_msg_core.GrpcService>`.\n* grpc-json: added support for :ref:`inline descriptors\n  <envoy_api_field_config.filter.http.transcoder.v2.GrpcJsonTranscoder.proto_descriptor_bin>`.\n* health check: added :ref:`gRPC health check <envoy_api_field_core.HealthCheck.grpc_health_check>`\n  based on `grpc.health.v1.Health <https://github.com/grpc/grpc/blob/master/src/proto/grpc/health/v1/health.proto>`_\n  service.\n* health check: added ability to set :ref:`host header value\n  <envoy_api_field_core.HealthCheck.HttpHealthCheck.host>` for http health check.\n* health check: extended the health check filter to support computation of the health check response\n  based on the :ref:`percentage of healthy servers in upstream clusters\n  <envoy_api_field_config.filter.http.health_check.v2.HealthCheck.cluster_min_healthy_percentages>`.\n* health check: added setting for :ref:`no-traffic\n  interval<envoy_api_field_core.HealthCheck.no_traffic_interval>`.\n* http: added idle timeout for :ref:`upstream http connections\n  <envoy_api_field_core.HttpProtocolOptions.idle_timeout>`.\n* http: added support for :ref:`proxying 100-Continue responses\n  <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.proxy_100_continue>`.\n* http: added the ability to pass a URL encoded PEM encoded peer certificate in the\n  :ref:`config_http_conn_man_headers_x-forwarded-client-cert` header.\n* http: added support for trusting additional hops in the\n  :ref:`config_http_conn_man_headers_x-forwarded-for` request header.\n* http: added support for :ref:`incoming HTTP/1.0\n  <envoy_api_field_core.Http1ProtocolOptions.accept_http_10>`.\n* hot restart: added SIGTERM propagation to children to :ref:`hot-restarter.py\n  <operations_hot_restarter>`, which enables using it as a parent of containers.\n* ip tagging: added :ref:`HTTP IP Tagging filter<config_http_filters_ip_tagging>`.\n* listeners: added support for :ref:`listening for both IPv4 and IPv6\n  <envoy_api_field_core.SocketAddress.ipv4_compat>` when binding to ::.\n* listeners: added support for listening on :ref:`UNIX domain sockets\n  <envoy_api_field_core.Address.pipe>`.\n* listeners: added support for :ref:`abstract unix domain sockets <envoy_api_msg_core.Pipe>` on\n  Linux. The abstract namespace can be used by prepending '@' to a socket path.\n* load balancer: added cluster configuration for :ref:`healthy panic threshold\n  <envoy_api_field_Cluster.CommonLbConfig.healthy_panic_threshold>` percentage.\n* load balancer: added :ref:`Maglev <arch_overview_load_balancing_types_maglev>` consistent hash\n  load balancer.\n* load balancer: added support for\n  :ref:`LocalityLbEndpoints<envoy_api_msg_endpoint.LocalityLbEndpoints>` priorities.\n* lua: added headers :ref:`replace() <config_http_filters_lua_header_wrapper>` API.\n* lua: extended to support :ref:`metadata object <config_http_filters_lua_metadata_wrapper>` API.\n* redis: added local `PING` support to the :ref:`Redis filter <arch_overview_redis>`.\n* redis: added `GEORADIUS_RO` and `GEORADIUSBYMEMBER_RO` to the :ref:`Redis command splitter\n  <arch_overview_redis>` whitelist.\n* router: added DOWNSTREAM_REMOTE_ADDRESS_WITHOUT_PORT, DOWNSTREAM_LOCAL_ADDRESS,\n  DOWNSTREAM_LOCAL_ADDRESS_WITHOUT_PORT, PROTOCOL, and UPSTREAM_METADATA :ref:`header\n  formatters <config_http_conn_man_headers_custom_request_headers>`. The CLIENT_IP header formatter\n  has been deprecated.\n* router: added gateway-error :ref:`retry-on <config_http_filters_router_x-envoy-retry-on>` policy.\n* router: added support for route matching based on :ref:`URL query string parameters\n  <envoy_api_msg_route.QueryParameterMatcher>`.\n* router: added support for more granular weighted cluster routing by allowing the :ref:`total_weight\n  <envoy_api_field_route.WeightedCluster.total_weight>` to be specified in configuration.\n* router: added support for :ref:`custom request/response headers\n  <config_http_conn_man_headers_custom_request_headers>` with mixed static and dynamic values.\n* router: added support for :ref:`direct responses <envoy_api_field_route.Route.direct_response>`.\n  I.e., sending a preconfigured HTTP response without proxying anywhere.\n* router: added support for :ref:`HTTPS redirects\n  <envoy_api_field_route.RedirectAction.https_redirect>` on specific routes.\n* router: added support for :ref:`prefix_rewrite\n  <envoy_api_field_route.RedirectAction.prefix_rewrite>` for redirects.\n* router: added support for :ref:`stripping the query string\n  <envoy_api_field_route.RedirectAction.strip_query>` for redirects.\n* router: added support for downstream request/upstream response\n  :ref:`header manipulation <config_http_conn_man_headers_custom_request_headers>` in :ref:`weighted\n  cluster <envoy_api_msg_route.WeightedCluster>`.\n* router: added support for :ref:`range based header matching\n  <envoy_api_field_route.HeaderMatcher.range_match>` for request routing.\n* squash: added support for the :ref:`Squash microservices debugger <config_http_filters_squash>`.\n  Allows debugging an incoming request to a microservice in the mesh.\n* stats: added metrics service API implementation.\n* stats: added native :ref:`DogStatsd <envoy_api_msg_config.metrics.v2.DogStatsdSink>` support.\n* stats: added support for :ref:`fixed stats tag values\n  <envoy_api_field_config.metrics.v2.TagSpecifier.fixed_value>` which will be added to all metrics.\n* tcp proxy: added support for specifying a :ref:`metadata matcher\n  <envoy_api_field_config.filter.network.tcp_proxy.v2.TcpProxy.metadata_match>` for upstream\n  clusters in the tcp filter.\n* tcp proxy: improved TCP proxy to correctly proxy TCP half-close.\n* tcp proxy: added :ref:`idle timeout\n  <envoy_api_field_config.filter.network.tcp_proxy.v2.TcpProxy.idle_timeout>`.\n* tcp proxy: access logs now bring an IP address without a port when using DOWNSTREAM_ADDRESS.\n  Use :ref:`DOWNSTREAM_REMOTE_ADDRESS <config_access_log_format>` instead.\n* tracing: added support for dynamically loading an :ref:`OpenTracing tracer\n  <envoy_api_msg_config.trace.v2.DynamicOtConfig>`.\n* tracing: when using the Zipkin tracer, it is now possible for clients to specify the sampling\n  decision (using the :ref:`x-b3-sampled <config_http_conn_man_headers_x-b3-sampled>` header) and\n  have the decision propagated through to subsequently invoked services.\n* tracing: when using the Zipkin tracer, it is no longer necessary to propagate the\n  :ref:`x-ot-span-context <config_http_conn_man_headers_x-ot-span-context>` header.\n  See more on trace context propagation :ref:`here <arch_overview_tracing>`.\n* transport sockets: added transport socket interface to allow custom implementations of transport\n  sockets. A transport socket provides read and write logic with buffer encryption and decryption\n  (if applicable). The existing TLS implementation has been refactored with the interface.\n* upstream: added support for specifying an :ref:`alternate stats name\n  <envoy_api_field_Cluster.alt_stat_name>` while emitting stats for clusters.\n* Many small bug fixes and performance improvements not listed.\n\n1.5.0 (December 4, 2017)\n========================\n\n* access log: added fields for :ref:`UPSTREAM_LOCAL_ADDRESS and DOWNSTREAM_ADDRESS\n  <config_access_log_format>`.\n* admin: added :ref:`JSON output <operations_admin_interface_stats>` for stats admin endpoint.\n* admin: added basic :ref:`Prometheus output <operations_admin_interface_stats>` for stats admin\n  endpoint. Histograms are not currently output.\n* admin: added ``version_info`` to the :ref:`/clusters admin endpoint<operations_admin_interface_clusters>`.\n* config: the :ref:`v2 API <config_overview_v2>` is now considered production ready.\n* config: added --v2-config-only CLI flag.\n* cors: added :ref:`CORS filter <config_http_filters_cors>`.\n* health check: added :ref:`x-envoy-immediate-health-check-fail\n  <config_http_filters_router_x-envoy-immediate-health-check-fail>` header support.\n* health check: added :ref:`reuse_connection <envoy_api_field_core.HealthCheck.reuse_connection>` option.\n* http: added :ref:`per-listener stats <config_http_conn_man_stats_per_listener>`.\n* http: end-to-end HTTP flow control is now complete across both connections, streams, and filters.\n* load balancer: added :ref:`subset load balancer <arch_overview_load_balancer_subsets>`.\n* load balancer: added ring size and hash :ref:`configuration options\n  <envoy_api_msg_Cluster.RingHashLbConfig>`. This used to be configurable via runtime. The runtime\n  configuration was deleted without deprecation as we are fairly certain no one is using it.\n* log: added the ability to optionally log to a file instead of stderr via the\n  :option:`--log-path` option.\n* listeners: added :ref:`drain_type <envoy_api_field_Listener.drain_type>` option.\n* lua: added experimental :ref:`Lua filter <config_http_filters_lua>`.\n* mongo filter: added :ref:`fault injection <config_network_filters_mongo_proxy_fault_injection>`.\n* mongo filter: added :ref:`\"drain close\" <arch_overview_draining>` support.\n* outlier detection: added :ref:`HTTP gateway failure type <arch_overview_outlier_detection>`.\n  See :ref:`deprecated log <deprecated>`\n  for outlier detection stats deprecations in this release.\n* redis: the :ref:`redis proxy filter <config_network_filters_redis_proxy>` is now considered\n  production ready.\n* redis: added :ref:`\"drain close\" <arch_overview_draining>` functionality.\n* router: added :ref:`x-envoy-overloaded <config_http_filters_router_x-envoy-overloaded_set>` support.\n* router: added :ref:`regex <envoy_api_field_route.RouteMatch.regex>` route matching.\n* router: added :ref:`custom request headers <config_http_conn_man_headers_custom_request_headers>`\n  for upstream requests.\n* router: added :ref:`downstream IP hashing\n  <envoy_api_field_route.RouteAction.HashPolicy.connection_properties>` for HTTP ketama routing.\n* router: added :ref:`cookie hashing <envoy_api_field_route.RouteAction.HashPolicy.cookie>`.\n* router: added :ref:`start_child_span <envoy_api_field_config.filter.http.router.v2.Router.start_child_span>` option\n  to create child span for egress calls.\n* router: added optional :ref:`upstream logs <envoy_api_field_config.filter.http.router.v2.Router.upstream_log>`.\n* router: added complete :ref:`custom append/override/remove support\n  <config_http_conn_man_headers_custom_request_headers>` of request/response headers.\n* router: added support to :ref:`specify response code during redirect\n  <envoy_api_field_route.RedirectAction.response_code>`.\n* router: added :ref:`configuration <envoy_api_field_route.RouteAction.cluster_not_found_response_code>`\n  to return either a 404 or 503 if the upstream cluster does not exist.\n* runtime: added :ref:`comment capability <config_runtime_comments>`.\n* server: change default log level (:option:`-l`) to `info`.\n* stats: maximum stat/name sizes and maximum number of stats are now variable via the\n  `--max-obj-name-len` and `--max-stats` options.\n* tcp proxy: added :ref:`access logging <envoy_api_field_config.filter.network.tcp_proxy.v2.TcpProxy.access_log>`.\n* tcp proxy: added :ref:`configurable connect retries\n  <envoy_api_field_config.filter.network.tcp_proxy.v2.TcpProxy.max_connect_attempts>`.\n* tcp proxy: enable use of :ref:`outlier detector <arch_overview_outlier_detection>`.\n* tls: added :ref:`SNI support <faq_how_to_setup_sni>`.\n* tls: added support for specifying :ref:`TLS session ticket keys\n  <envoy_api_field_auth.DownstreamTlsContext.session_ticket_keys>`.\n* tls: allow configuration of the :ref:`min\n  <envoy_api_field_auth.TlsParameters.tls_minimum_protocol_version>` and :ref:`max\n  <envoy_api_field_auth.TlsParameters.tls_maximum_protocol_version>` TLS protocol versions.\n* tracing: added :ref:`custom trace span decorators <envoy_api_field_route.Route.decorator>`.\n* Many small bug fixes and performance improvements not listed.\n\n1.4.0 (August 24, 2017)\n=======================\n\n* macOS is :repo:`now supported </bazel#quick-start-bazel-build-for-developers>`. (A few features\n  are missing such as hot restart and original destination routing).\n* YAML is now directly supported for config files.\n* Added /routes admin endpoint.\n* End-to-end flow control is now supported for TCP proxy, HTTP/1, and HTTP/2. HTTP flow control\n  that includes filter buffering is incomplete and will be implemented in 1.5.0.\n* Log verbosity :repo:`compile time flag </bazel#log-verbosity>` added.\n* Hot restart :repo:`compile time flag </bazel#hot-restart>` added.\n* Original destination :ref:`cluster <arch_overview_service_discovery_types_original_destination>`\n  and :ref:`load balancer <arch_overview_load_balancing_types_original_destination>` added.\n* :ref:`WebSocket <arch_overview_websocket>` is now supported.\n* Virtual cluster priorities have been hard removed without deprecation as we are reasonably sure\n  no one is using this feature.\n* Route `validate_clusters` option added.\n* :ref:`x-envoy-downstream-service-node <config_http_conn_man_headers_downstream-service-node>`\n  header added.\n* :ref:`x-forwarded-client-cert <config_http_conn_man_headers_x-forwarded-client-cert>` header\n  added.\n* Initial HTTP/1 forward proxy support for absolute URLs has been added.\n* HTTP/2 codec settings are now configurable.\n* gRPC/JSON transcoder :ref:`filter <config_http_filters_grpc_json_transcoder>` added.\n* gRPC web :ref:`filter <config_http_filters_grpc_web>` added.\n* Configurable timeout for the rate limit service call in the :ref:`network\n  <config_network_filters_rate_limit>` and :ref:`HTTP <config_http_filters_rate_limit>` rate limit\n  filters.\n* :ref:`x-envoy-retry-grpc-on <config_http_filters_router_x-envoy-retry-grpc-on>` header added.\n* :ref:`LDS API <arch_overview_dynamic_config_lds>` added.\n* TLS :`require_client_certificate` option added.\n* :ref:`Configuration check tool <install_tools_config_load_check_tool>` added.\n* :ref:`JSON schema check tool <install_tools_schema_validator_check_tool>` added.\n* Config validation mode added via the :option:`--mode` option.\n* :option:`--local-address-ip-version` option added.\n* IPv6 support is now complete.\n* UDP `statsd_ip_address` option added.\n* Per-cluster DNS resolvers added.\n* :ref:`Fault filter <config_http_filters_fault_injection>` enhancements and fixes.\n* Several features are :ref:`deprecated as of the 1.4.0 release <deprecated>`. They\n  will be removed at the beginning of the 1.5.0 release cycle. We explicitly call out that the\n  `HttpFilterConfigFactory` filter API has been deprecated in favor of\n  `NamedHttpFilterConfigFactory`.\n* Many small bug fixes and performance improvements not listed.\n\n1.3.0 (May 17, 2017)\n====================\n\n* As of this release, we now have an official :repo:`breaking change policy\n  </CONTRIBUTING.md#breaking-change-policy>`. Note that there are numerous breaking configuration\n  changes in this release. They are not listed here. Future releases will adhere to the policy and\n  have clear documentation on deprecations and changes.\n* Bazel is now the canonical build system (replacing CMake). There have been a huge number of\n  changes to the development/build/test flow. See :repo:`/bazel/README.md` and\n  :repo:`/ci/README.md` for more information.\n* :ref:`Outlier detection <arch_overview_outlier_detection>` has been expanded to include success\n  rate variance, and all parameters are now configurable in both runtime and in the JSON\n  configuration.\n* TCP level listener and cluster connections now have configurable receive buffer\n  limits at which point connection level back pressure is applied.\n  Full end to end flow control will be available in a future release.\n* :ref:`Redis health checking <config_cluster_manager_cluster_hc>` has been added as an active\n  health check type. Full Redis support will be documented/supported in 1.4.0.\n* :ref:`TCP health checking <config_cluster_manager_cluster_hc_tcp_health_checking>` now supports a\n  \"connect only\" mode that only checks if the remote server can be connected to without\n  writing/reading any data.\n* `BoringSSL <https://boringssl.googlesource.com/boringssl>`_ is now the only supported TLS provider.\n  The default cipher suites and ECDH curves have been updated with more modern defaults for both\n  listener and cluster connections.\n* The `header value match` rate limit action has been expanded to include an `expect\n  match` parameter.\n* Route level HTTP rate limit configurations now do not inherit the virtual host level\n  configurations by default. Use `include_vh_rate_limits` to inherit the virtual host\n  level options if desired.\n* HTTP routes can now add request headers on a per route and per virtual host basis via the\n  :ref:`request_headers_to_add <config_http_conn_man_headers_custom_request_headers>` option.\n* The :ref:`example configurations <install_ref_configs>` have been refreshed to demonstrate the\n  latest features.\n* `per_try_timeout_ms` can now be configured in\n  a route's retry policy in addition to via the :ref:`x-envoy-upstream-rq-per-try-timeout-ms\n  <config_http_filters_router_x-envoy-upstream-rq-per-try-timeout-ms>` HTTP header.\n* HTTP virtual host matching now includes support for prefix wildcard domains (e.g., `*.lyft.com`).\n* The default for tracing random sampling has been changed to 100% and is still configurable in\n  :ref:`runtime <config_http_conn_man_runtime>`.\n* HTTP tracing configuration has been extended to allow tags\n  to be populated from arbitrary HTTP headers.\n* The :ref:`HTTP rate limit filter <config_http_filters_rate_limit>` can now be applied to internal,\n  external, or all requests via the `request_type` option.\n* :ref:`Listener binding <config_listeners>` now requires specifying an `address` field. This can be\n  used to bind a listener to both a specific address as well as a port.\n* The :ref:`MongoDB filter <config_network_filters_mongo_proxy>` now emits a stat for queries that\n  do not have `$maxTimeMS` set.\n* The :ref:`MongoDB filter <config_network_filters_mongo_proxy>` now emits logs that are fully valid\n  JSON.\n* The CPU profiler output path is now configurable.\n* A watchdog system has been added that can kill the server if a deadlock is detected.\n* A :ref:`route table checking tool <install_tools_route_table_check_tool>` has been added that can\n  be used to test route tables before use.\n* We have added an :ref:`example repo <extending>` that shows how to compile/link a custom filter.\n* Added additional cluster wide information related to outlier detection to the :ref:`/clusters\n  admin endpoint <operations_admin_interface>`.\n* Multiple SANs can now be verified via the `verify_subject_alt_name` setting.\n  Additionally, URI type SANs can be verified.\n* HTTP filters can now be passed opaque configuration specified on a per route basis.\n* By default Envoy now has a built in crash handler that will print a back trace. This behavior can\n  be disabled if desired via the ``--define=signal_trace=disabled`` Bazel option.\n* Zipkin has been added as a supported :ref:`tracing provider <arch_overview_tracing>`.\n* Numerous small changes and fixes not listed here.\n\n1.2.0 (March 7, 2017)\n=====================\n\n* :ref:`Cluster discovery service (CDS) API <config_cluster_manager_cds>`.\n* :ref:`Outlier detection <arch_overview_outlier_detection>` (passive health checking).\n* Envoy configuration is now checked against a JSON schema.\n* :ref:`Ring hash <arch_overview_load_balancing_types>` consistent load balancer, as well as HTTP\n  consistent hash routing based on a policy.\n* Vastly :ref:`enhanced global rate limit configuration <arch_overview_rate_limit>` via the HTTP\n  rate limiting filter.\n* HTTP routing to a cluster retrieved from a header.\n* Weighted cluster HTTP routing.\n* Auto host rewrite during HTTP routing.\n* Regex header matching during HTTP routing.\n* HTTP access log runtime filter.\n* LightStep tracer :ref:`parent/child span association <arch_overview_tracing>`.\n* :ref:`Route discovery service (RDS) API <config_http_conn_man_rds>`.\n* HTTP router :ref:`x-envoy-upstream-rq-timeout-alt-response header\n  <config_http_filters_router_x-envoy-upstream-rq-timeout-alt-response>` support.\n* *use_original_dst* and *bind_to_port* :ref:`listener options <config_listeners>` (useful for\n  iptables based transparent proxy support).\n* TCP proxy filter :ref:`route table support <config_network_filters_tcp_proxy>`.\n* Configurable stats flush interval.\n* Various :ref:`third party library upgrades <install_requirements>`, including using BoringSSL as\n  the default SSL provider.\n* No longer maintain closed HTTP/2 streams for priority calculations. Leads to substantial memory\n  savings for large meshes.\n* Numerous small changes and fixes not listed here.\n\n1.1.0 (November 30, 2016)\n=========================\n\n* Switch from Jannson to RapidJSON for our JSON library (allowing for a configuration schema in\n  1.2.0).\n* Upgrade :ref:`recommended version <install_requirements>` of various other libraries.\n* Configurable DNS refresh rate for DNS service discovery types.\n* Upstream circuit breaker configuration can be :ref:`overridden via runtime\n  <config_cluster_manager_cluster_runtime>`.\n* :ref:`Zone aware routing support <arch_overview_load_balancing_zone_aware_routing>`.\n* Generic header matching routing rule.\n* HTTP/2 graceful connection draining (double GOAWAY).\n* DynamoDB filter :ref:`per shard statistics <config_http_filters_dynamo>` (pre-release AWS\n  feature).\n* Initial release of the :ref:`fault injection HTTP filter <config_http_filters_fault_injection>`.\n* HTTP :ref:`rate limit filter <config_http_filters_rate_limit>` enhancements (note that the\n  configuration for HTTP rate limiting is going to be overhauled in 1.2.0).\n* Added :ref:`refused-stream retry policy <config_http_filters_router_x-envoy-retry-on>`.\n* Multiple :ref:`priority queues <arch_overview_http_routing_priority>` for upstream clusters\n  (configurable on a per route basis, with separate connection pools, circuit breakers, etc.).\n* Added max connection circuit breaking to the :ref:`TCP proxy filter <arch_overview_tcp_proxy>`.\n* Added :ref:`CLI <operations_cli>` options for setting the logging file flush interval as well\n  as the drain/shutdown time during hot restart.\n* A very large number of performance enhancements for core HTTP/TCP proxy flows as well as a\n  few new configuration flags to allow disabling expensive features if they are not needed\n  (specifically request ID generation and dynamic response code stats).\n* Support Mongo 3.2 in the :ref:`Mongo sniffing filter <config_network_filters_mongo_proxy>`.\n* Lots of other small fixes and enhancements not listed.\n\n1.0.0 (September 12, 2016)\n==========================\n\nInitial open source release.\n", "#pragma once\n\n#include <memory>\n#include <string>\n\n#include \"envoy/common/pure.h\"\n#include \"envoy/http/header_map.h\"\n#include \"envoy/stream_info/stream_info.h\"\n\nnamespace Envoy {\nnamespace AccessLog {\n\nclass AccessLogFile {\npublic:\n  virtual ~AccessLogFile() = default;\n\n  /**\n   * Write data to the file.\n   */\n  virtual void write(absl::string_view) PURE;\n\n  /**\n   * Reopen the file.\n   */\n  virtual void reopen() PURE;\n\n  /**\n   * Synchronously flush all pending data to disk.\n   */\n  virtual void flush() PURE;\n};\n\nusing AccessLogFileSharedPtr = std::shared_ptr<AccessLogFile>;\n\nclass AccessLogManager {\npublic:\n  virtual ~AccessLogManager() = default;\n\n  /**\n   * Reopen all of the access log files.\n   */\n  virtual void reopen() PURE;\n\n  /**\n   * Create a new access log file managed by the access log manager.\n   * @param file_name specifies the file to create/open.\n   * @return the opened file.\n   */\n  virtual AccessLogFileSharedPtr createAccessLog(const std::string& file_name) PURE;\n};\n\nusing AccessLogManagerPtr = std::unique_ptr<AccessLogManager>;\n\n/**\n * Interface for access log filters.\n */\nclass Filter {\npublic:\n  virtual ~Filter() = default;\n\n  /**\n   * Evaluate whether an access log should be written based on request and response data.\n   * @return TRUE if the log should be written.\n   */\n  virtual bool evaluate(const StreamInfo::StreamInfo& info, const Http::HeaderMap& request_headers,\n                        const Http::HeaderMap& response_headers,\n                        const Http::HeaderMap& response_trailers) PURE;\n};\n\nusing FilterPtr = std::unique_ptr<Filter>;\n\n/**\n * Abstract access logger for requests and connections.\n */\nclass Instance {\npublic:\n  virtual ~Instance() = default;\n\n  /**\n   * Log a completed request.\n   * @param request_headers supplies the incoming request headers after filtering.\n   * @param response_headers supplies response headers.\n   * @param response_trailers supplies response trailers.\n   * @param stream_info supplies additional information about the request not\n   * contained in the request headers.\n   */\n  virtual void log(const Http::HeaderMap* request_headers, const Http::HeaderMap* response_headers,\n                   const Http::HeaderMap* response_trailers,\n                   const StreamInfo::StreamInfo& stream_info) PURE;\n};\n\nusing InstanceSharedPtr = std::shared_ptr<Instance>;\n\n/**\n * Interface for access log formatter.\n * Formatters provide a complete access log output line for the given headers/trailers/stream.\n */\nclass Formatter {\npublic:\n  virtual ~Formatter() = default;\n\n  /**\n   * Return a formatted access log line.\n   * @param request_headers supplies the request headers.\n   * @param response_headers supplies the response headers.\n   * @param response_trailers supplies the response trailers.\n   * @param stream_info supplies the stream info.\n   * @return std::string string containing the complete formatted access log line.\n   */\n  virtual std::string format(const Http::HeaderMap& request_headers,\n                             const Http::HeaderMap& response_headers,\n                             const Http::HeaderMap& response_trailers,\n                             const StreamInfo::StreamInfo& stream_info) const PURE;\n};\n\nusing FormatterPtr = std::unique_ptr<Formatter>;\n\n/**\n * Interface for access log provider.\n * FormatterProviders extract information from the given headers/trailers/stream.\n */\nclass FormatterProvider {\npublic:\n  virtual ~FormatterProvider() = default;\n\n  /**\n   * Extract a value from the provided headers/trailers/stream.\n   * @param request_headers supplies the request headers.\n   * @param response_headers supplies the response headers.\n   * @param response_trailers supplies the response trailers.\n   * @param stream_info supplies the stream info.\n   * @return std::string containing a single value extracted from the given headers/trailers/stream.\n   */\n  virtual std::string format(const Http::HeaderMap& request_headers,\n                             const Http::HeaderMap& response_headers,\n                             const Http::HeaderMap& response_trailers,\n                             const StreamInfo::StreamInfo& stream_info) const PURE;\n};\n\nusing FormatterProviderPtr = std::unique_ptr<FormatterProvider>;\n\n} // namespace AccessLog\n} // namespace Envoy\n", "#pragma once\n\n#include <algorithm>\n#include <cstdint>\n#include <cstring>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <unordered_set>\n#include <vector>\n\n#include \"envoy/common/pure.h\"\n\n#include \"common/common/assert.h\"\n#include \"common/common/hash.h\"\n#include \"common/common/macros.h\"\n\n#include \"absl/strings/string_view.h\"\n\nnamespace Envoy {\nnamespace Http {\n\n// Used by ASSERTs to validate internal consistency. E.g. valid HTTP header keys/values should\n// never contain embedded NULLs.\nstatic inline bool validHeaderString(absl::string_view s) {\n  // If you modify this list of illegal embedded characters you will probably\n  // want to change header_map_fuzz_impl_test at the same time.\n  for (const char c : s) {\n    switch (c) {\n    case '\\0':\n      FALLTHRU;\n    case '\\r':\n      FALLTHRU;\n    case '\\n':\n      return false;\n    default:\n      continue;\n    }\n  }\n  return true;\n}\n\n/**\n * Wrapper for a lower case string used in header operations to generally avoid needless case\n * insensitive compares.\n */\nclass LowerCaseString {\npublic:\n  LowerCaseString(LowerCaseString&& rhs) noexcept : string_(std::move(rhs.string_)) {\n    ASSERT(valid());\n  }\n  LowerCaseString(const LowerCaseString& rhs) : string_(rhs.string_) { ASSERT(valid()); }\n  explicit LowerCaseString(const std::string& new_string) : string_(new_string) {\n    ASSERT(valid());\n    lower();\n  }\n\n  const std::string& get() const { return string_; }\n  bool operator==(const LowerCaseString& rhs) const { return string_ == rhs.string_; }\n  bool operator!=(const LowerCaseString& rhs) const { return string_ != rhs.string_; }\n  bool operator<(const LowerCaseString& rhs) const { return string_.compare(rhs.string_) < 0; }\n\nprivate:\n  void lower() { std::transform(string_.begin(), string_.end(), string_.begin(), tolower); }\n  bool valid() const { return validHeaderString(string_); }\n\n  std::string string_;\n};\n\n/**\n * Lower case string hasher.\n */\nstruct LowerCaseStringHash {\n  size_t operator()(const LowerCaseString& value) const { return HashUtil::xxHash64(value.get()); }\n};\n\n/**\n * Convenient type for unordered set of lower case string.\n */\nusing LowerCaseStrUnorderedSet = std::unordered_set<LowerCaseString, LowerCaseStringHash>;\n\n/**\n * Convenient type for a vector of lower case string and string pair.\n */\nusing LowerCaseStrPairVector =\n    std::vector<std::pair<const Http::LowerCaseString, const std::string>>;\n\n/**\n * This is a string implementation for use in header processing. It is heavily optimized for\n * performance. It supports 3 different types of storage and can switch between them:\n * 1) A reference.\n * 2) Interned string.\n * 3) Heap allocated storage.\n */\nclass HeaderString {\npublic:\n  enum class Type { Inline, Reference, Dynamic };\n\n  /**\n   * Default constructor. Sets up for inline storage.\n   */\n  HeaderString();\n\n  /**\n   * Constructor for a string reference.\n   * @param ref_value MUST point to data that will live beyond the lifetime of any request/response\n   *        using the string (since a codec may optimize for zero copy).\n   */\n  explicit HeaderString(const LowerCaseString& ref_value);\n\n  /**\n   * Constructor for a string reference.\n   * @param ref_value MUST point to data that will live beyond the lifetime of any request/response\n   *        using the string (since a codec may optimize for zero copy).\n   */\n  explicit HeaderString(const std::string& ref_value);\n\n  HeaderString(HeaderString&& move_value) noexcept;\n  ~HeaderString();\n\n  /**\n   * Append data to an existing string. If the string is a reference string the reference data is\n   * not copied.\n   */\n  void append(const char* data, uint32_t size);\n\n  /**\n   * @return the modifiable backing buffer (either inline or heap allocated).\n   */\n  char* buffer() { return buffer_.dynamic_; }\n\n  /**\n   * Get an absl::string_view. It will NOT be NUL terminated!\n   *\n   * @return an absl::string_view.\n   */\n  absl::string_view getStringView() const { return {buffer_.ref_, string_length_}; }\n\n  /**\n   * Return the string to a default state. Reference strings are not touched. Both inline/dynamic\n   * strings are reset to zero size.\n   */\n  void clear();\n\n  /**\n   * @return whether the string is empty or not.\n   */\n  bool empty() const { return string_length_ == 0; }\n\n  // Looking for find? Use getStringView().find()\n\n  /**\n   * Set the value of the string by copying data into it. This overwrites any existing string.\n   */\n  void setCopy(const char* data, uint32_t size);\n\n  /**\n   * Set the value of the string by copying data into it. This overwrites any existing string.\n   */\n  void setCopy(absl::string_view view);\n\n  /**\n   * Set the value of the string to an integer. This overwrites any existing string.\n   */\n  void setInteger(uint64_t value);\n\n  /**\n   * Set the value of the string to a string reference.\n   * @param ref_value MUST point to data that will live beyond the lifetime of any request/response\n   *        using the string (since a codec may optimize for zero copy).\n   */\n  void setReference(const std::string& ref_value);\n\n  /**\n   * @return the size of the string, not including the null terminator.\n   */\n  uint32_t size() const { return string_length_; }\n\n  /**\n   * @return the type of backing storage for the string.\n   */\n  Type type() const { return type_; }\n\n  bool operator==(const char* rhs) const { return getStringView() == absl::string_view(rhs); }\n  bool operator==(absl::string_view rhs) const { return getStringView() == rhs; }\n  bool operator!=(const char* rhs) const { return getStringView() != absl::string_view(rhs); }\n  bool operator!=(absl::string_view rhs) const { return getStringView() != rhs; }\n\nprivate:\n  union Buffer {\n    // This should reference inline_buffer_ for Type::Inline.\n    char* dynamic_;\n    const char* ref_;\n  } buffer_;\n\n  // Capacity in both Type::Inline and Type::Dynamic cases must be at least MinDynamicCapacity in\n  // header_map_impl.cc.\n  union {\n    char inline_buffer_[128];\n    // Since this is a union, this is only valid for type_ == Type::Dynamic.\n    uint32_t dynamic_capacity_;\n  };\n\n  void freeDynamic();\n  bool valid() const;\n\n  uint32_t string_length_;\n  Type type_;\n};\n\n/**\n * Encapsulates an individual header entry (including both key and value).\n */\nclass HeaderEntry {\npublic:\n  virtual ~HeaderEntry() = default;\n\n  /**\n   * @return the header key.\n   */\n  virtual const HeaderString& key() const PURE;\n\n  /**\n   * Set the header value by copying data into it (deprecated, use absl::string_view variant\n   * instead).\n   * TODO(htuch): Cleanup deprecated call sites.\n   */\n  virtual void value(const char* value, uint32_t size) PURE;\n\n  /**\n   * Set the header value by copying data into it.\n   */\n  virtual void value(absl::string_view value) PURE;\n\n  /**\n   * Set the header value by copying an integer into it.\n   */\n  virtual void value(uint64_t value) PURE;\n\n  /**\n   * Set the header value by copying the value in another header entry.\n   */\n  virtual void value(const HeaderEntry& header) PURE;\n\n  /**\n   * @return the header value.\n   */\n  virtual const HeaderString& value() const PURE;\n\n  /**\n   * @return the header value.\n   */\n  virtual HeaderString& value() PURE;\n\nprivate:\n  void value(const char*); // Do not allow auto conversion to std::string\n};\n\n/**\n * The following defines all headers that Envoy allows direct access to inside of the header map.\n * In practice, these are all headers used during normal Envoy request flow processing. This allows\n * O(1) access to these headers without even a hash lookup.\n */\n#define ALL_INLINE_HEADERS(HEADER_FUNC)                                                            \\\n  HEADER_FUNC(Accept)                                                                              \\\n  HEADER_FUNC(AcceptEncoding)                                                                      \\\n  HEADER_FUNC(AccessControlRequestHeaders)                                                         \\\n  HEADER_FUNC(AccessControlRequestMethod)                                                          \\\n  HEADER_FUNC(AccessControlAllowOrigin)                                                            \\\n  HEADER_FUNC(AccessControlAllowHeaders)                                                           \\\n  HEADER_FUNC(AccessControlAllowMethods)                                                           \\\n  HEADER_FUNC(AccessControlAllowCredentials)                                                       \\\n  HEADER_FUNC(AccessControlExposeHeaders)                                                          \\\n  HEADER_FUNC(AccessControlMaxAge)                                                                 \\\n  HEADER_FUNC(Authorization)                                                                       \\\n  HEADER_FUNC(CacheControl)                                                                        \\\n  HEADER_FUNC(ClientTraceId)                                                                       \\\n  HEADER_FUNC(Connection)                                                                          \\\n  HEADER_FUNC(ContentEncoding)                                                                     \\\n  HEADER_FUNC(ContentLength)                                                                       \\\n  HEADER_FUNC(ContentType)                                                                         \\\n  HEADER_FUNC(Date)                                                                                \\\n  HEADER_FUNC(EnvoyAttemptCount)                                                                   \\\n  HEADER_FUNC(EnvoyDegraded)                                                                       \\\n  HEADER_FUNC(EnvoyDecoratorOperation)                                                             \\\n  HEADER_FUNC(EnvoyDownstreamServiceCluster)                                                       \\\n  HEADER_FUNC(EnvoyDownstreamServiceNode)                                                          \\\n  HEADER_FUNC(EnvoyExpectedRequestTimeoutMs)                                                       \\\n  HEADER_FUNC(EnvoyExternalAddress)                                                                \\\n  HEADER_FUNC(EnvoyForceTrace)                                                                     \\\n  HEADER_FUNC(EnvoyHedgeOnPerTryTimeout)                                                           \\\n  HEADER_FUNC(EnvoyImmediateHealthCheckFail)                                                       \\\n  HEADER_FUNC(EnvoyInternalRequest)                                                                \\\n  HEADER_FUNC(EnvoyIpTags)                                                                         \\\n  HEADER_FUNC(EnvoyMaxRetries)                                                                     \\\n  HEADER_FUNC(EnvoyOriginalPath)                                                                   \\\n  HEADER_FUNC(EnvoyOriginalUrl)                                                                    \\\n  HEADER_FUNC(EnvoyOverloaded)                                                                     \\\n  HEADER_FUNC(EnvoyRateLimited)                                                                    \\\n  HEADER_FUNC(EnvoyRetryOn)                                                                        \\\n  HEADER_FUNC(EnvoyRetryGrpcOn)                                                                    \\\n  HEADER_FUNC(EnvoyRetriableStatusCodes)                                                           \\\n  HEADER_FUNC(EnvoyRetriableHeaderNames)                                                           \\\n  HEADER_FUNC(EnvoyUpstreamAltStatName)                                                            \\\n  HEADER_FUNC(EnvoyUpstreamCanary)                                                                 \\\n  HEADER_FUNC(EnvoyUpstreamHealthCheckedCluster)                                                   \\\n  HEADER_FUNC(EnvoyUpstreamRequestPerTryTimeoutMs)                                                 \\\n  HEADER_FUNC(EnvoyUpstreamRequestTimeoutAltResponse)                                              \\\n  HEADER_FUNC(EnvoyUpstreamRequestTimeoutMs)                                                       \\\n  HEADER_FUNC(EnvoyUpstreamServiceTime)                                                            \\\n  HEADER_FUNC(Etag)                                                                                \\\n  HEADER_FUNC(Expect)                                                                              \\\n  HEADER_FUNC(ForwardedClientCert)                                                                 \\\n  HEADER_FUNC(ForwardedFor)                                                                        \\\n  HEADER_FUNC(ForwardedProto)                                                                      \\\n  HEADER_FUNC(GrpcAcceptEncoding)                                                                  \\\n  HEADER_FUNC(GrpcMessage)                                                                         \\\n  HEADER_FUNC(GrpcStatus)                                                                          \\\n  HEADER_FUNC(GrpcTimeout)                                                                         \\\n  HEADER_FUNC(Host)                                                                                \\\n  HEADER_FUNC(KeepAlive)                                                                           \\\n  HEADER_FUNC(LastModified)                                                                        \\\n  HEADER_FUNC(Location)                                                                            \\\n  HEADER_FUNC(Method)                                                                              \\\n  HEADER_FUNC(NoChunks)                                                                            \\\n  HEADER_FUNC(Origin)                                                                              \\\n  HEADER_FUNC(OtSpanContext)                                                                       \\\n  HEADER_FUNC(Path)                                                                                \\\n  HEADER_FUNC(Protocol)                                                                            \\\n  HEADER_FUNC(ProxyConnection)                                                                     \\\n  HEADER_FUNC(Referer)                                                                             \\\n  HEADER_FUNC(RequestId)                                                                           \\\n  HEADER_FUNC(Scheme)                                                                              \\\n  HEADER_FUNC(Server)                                                                              \\\n  HEADER_FUNC(Status)                                                                              \\\n  HEADER_FUNC(TE)                                                                                  \\\n  HEADER_FUNC(TransferEncoding)                                                                    \\\n  HEADER_FUNC(Upgrade)                                                                             \\\n  HEADER_FUNC(UserAgent)                                                                           \\\n  HEADER_FUNC(Vary)                                                                                \\\n  HEADER_FUNC(Via)\n\n/**\n * The following functions are defined for each inline header above. E.g., for ContentLength we\n * have:\n *\n * ContentLength() -> returns the header entry if it exists or nullptr.\n * insertContentLength() -> inserts the header if it does not exist, and returns a reference to it.\n * removeContentLength() -> removes the header if it exists.\n */\n#define DEFINE_INLINE_HEADER(name)                                                                 \\\n  virtual const HeaderEntry* name() const PURE;                                                    \\\n  virtual HeaderEntry* name() PURE;                                                                \\\n  virtual HeaderEntry& insert##name() PURE;                                                        \\\n  virtual void remove##name() PURE;\n\n/**\n * Wraps a set of HTTP headers.\n */\nclass HeaderMap {\npublic:\n  virtual ~HeaderMap() = default;\n\n  ALL_INLINE_HEADERS(DEFINE_INLINE_HEADER)\n\n  /**\n   * Add a reference header to the map. Both key and value MUST point to data that will live beyond\n   * the lifetime of any request/response using the string (since a codec may optimize for zero\n   * copy). The key will not be copied and a best effort will be made not to\n   * copy the value (but this may happen when comma concatenating, see below).\n   *\n   * Calling addReference multiple times for the same header will result in:\n   * - Comma concatenation for predefined inline headers.\n   * - Multiple headers being present in the HeaderMap for other headers.\n   *\n   * @param key specifies the name of the header to add; it WILL NOT be copied.\n   * @param value specifies the value of the header to add; it WILL NOT be copied.\n   */\n  virtual void addReference(const LowerCaseString& key, const std::string& value) PURE;\n\n  /**\n   * Add a header with a reference key to the map. The key MUST point to data that will live beyond\n   * the lifetime of any request/response using the string (since a codec may optimize for zero\n   * copy). The value will be copied.\n   *\n   * Calling addReference multiple times for the same header will result in:\n   * - Comma concatenation for predefined inline headers.\n   * - Multiple headers being present in the HeaderMap for other headers.\n   *\n   * @param key specifies the name of the header to add; it WILL NOT be copied.\n   * @param value specifies the value of the header to add; it WILL be copied.\n   */\n  virtual void addReferenceKey(const LowerCaseString& key, uint64_t value) PURE;\n\n  /**\n   * Add a header with a reference key to the map. The key MUST point to point to data that will\n   * live beyond the lifetime of any request/response using the string (since a codec may optimize\n   * for zero copy). The value will be copied.\n   *\n   * Calling addReference multiple times for the same header will result in:\n   * - Comma concatenation for predefined inline headers.\n   * - Multiple headers being present in the HeaderMap for other headers.\n   *\n   * @param key specifies the name of the header to add; it WILL NOT be copied.\n   * @param value specifies the value of the header to add; it WILL be copied.\n   */\n  virtual void addReferenceKey(const LowerCaseString& key, const std::string& value) PURE;\n\n  /**\n   * Add a header by copying both the header key and the value.\n   *\n   * Calling addCopy multiple times for the same header will result in:\n   * - Comma concatenation for predefined inline headers.\n   * - Multiple headers being present in the HeaderMap for other headers.\n   *\n   * @param key specifies the name of the header to add; it WILL be copied.\n   * @param value specifies the value of the header to add; it WILL be copied.\n   */\n  virtual void addCopy(const LowerCaseString& key, uint64_t value) PURE;\n\n  /**\n   * Add a header by copying both the header key and the value.\n   *\n   * Calling addCopy multiple times for the same header will result in:\n   * - Comma concatenation for predefined inline headers.\n   * - Multiple headers being present in the HeaderMap for other headers.\n   *\n   * @param key specifies the name of the header to add; it WILL be copied.\n   * @param value specifies the value of the header to add; it WILL be copied.\n   */\n  virtual void addCopy(const LowerCaseString& key, const std::string& value) PURE;\n\n  /**\n   * Set a reference header in the map. Both key and value MUST point to data that will live beyond\n   * the lifetime of any request/response using the string (since a codec may optimize for zero\n   * copy). Nothing will be copied.\n   *\n   * Calling setReference multiple times for the same header will result in only the last header\n   * being present in the HeaderMap.\n   *\n   * @param key specifies the name of the header to set; it WILL NOT be copied.\n   * @param value specifies the value of the header to set; it WILL NOT be copied.\n   */\n  virtual void setReference(const LowerCaseString& key, const std::string& value) PURE;\n\n  /**\n   * Set a header with a reference key in the map. The key MUST point to point to data that will\n   * live beyond the lifetime of any request/response using the string (since a codec may optimize\n   * for zero copy). The value will be copied.\n   *\n   * Calling setReferenceKey multiple times for the same header will result in only the last header\n   * being present in the HeaderMap.\n   *\n   * @param key specifies the name of the header to set; it WILL NOT be copied.\n   * @param value specifies the value of the header to set; it WILL be copied.\n   */\n  virtual void setReferenceKey(const LowerCaseString& key, const std::string& value) PURE;\n\n  /**\n   * @return uint64_t the approximate size of the header map in bytes.\n   */\n  virtual uint64_t byteSize() const PURE;\n\n  /**\n   * Get a header by key.\n   * @param key supplies the header key.\n   * @return the header entry if it exists otherwise nullptr.\n   */\n  virtual const HeaderEntry* get(const LowerCaseString& key) const PURE;\n  virtual HeaderEntry* get(const LowerCaseString& key) PURE;\n\n  // aliases to make iterate() and iterateReverse() callbacks easier to read\n  enum class Iterate { Continue, Break };\n\n  /**\n   * Callback when calling iterate() over a const header map.\n   * @param header supplies the header entry.\n   * @param context supplies the context passed to iterate().\n   * @return Iterate::Continue to continue iteration.\n   */\n  using ConstIterateCb = Iterate (*)(const HeaderEntry&, void*);\n\n  /**\n   * Iterate over a constant header map.\n   * @param cb supplies the iteration callback.\n   * @param context supplies the context that will be passed to the callback.\n   */\n  virtual void iterate(ConstIterateCb cb, void* context) const PURE;\n\n  /**\n   * Iterate over a constant header map in reverse order.\n   * @param cb supplies the iteration callback.\n   * @param context supplies the context that will be passed to the callback.\n   */\n  virtual void iterateReverse(ConstIterateCb cb, void* context) const PURE;\n\n  enum class Lookup { Found, NotFound, NotSupported };\n\n  /**\n   * Lookup one of the predefined inline headers (see ALL_INLINE_HEADERS below) by key.\n   * @param key supplies the header key.\n   * @param entry is set to the header entry if it exists and if key is one of the predefined inline\n   * headers; otherwise, nullptr.\n   * @return Lookup::Found if lookup was successful, Lookup::NotFound if the header entry doesn't\n   * exist, or Lookup::NotSupported if key is not one of the predefined inline headers.\n   */\n  virtual Lookup lookup(const LowerCaseString& key, const HeaderEntry** entry) const PURE;\n\n  /**\n   * Remove all instances of a header by key.\n   * @param key supplies the header key to remove.\n   */\n  virtual void remove(const LowerCaseString& key) PURE;\n\n  /**\n   * Remove all instances of headers where the key begins with the supplied prefix.\n   * @param prefix supplies the prefix to match header keys against.\n   */\n  virtual void removePrefix(const LowerCaseString& prefix) PURE;\n\n  /**\n   * @return the number of headers in the map.\n   */\n  virtual size_t size() const PURE;\n\n  /**\n   * @return true if the map is empty, false otherwise.\n   */\n  virtual bool empty() const PURE;\n\n  /**\n   * Dump the header map to the ostream specified\n   *\n   * @param os the stream to dump state to\n   * @param indent_level the depth, for pretty-printing.\n   *\n   * This function is called on Envoy fatal errors so should avoid memory allocation where possible.\n   */\n  virtual void dumpState(std::ostream& os, int indent_level = 0) const PURE;\n\n  /**\n   * Allow easy pretty-printing of the key/value pairs in HeaderMap\n   * @param os supplies the ostream to print to.\n   * @param headers the headers to print.\n   */\n  friend std::ostream& operator<<(std::ostream& os, const HeaderMap& headers) {\n    headers.dumpState(os);\n    return os;\n  }\n};\n\nusing HeaderMapPtr = std::unique_ptr<HeaderMap>;\n\n/**\n * Convenient container type for storing Http::LowerCaseString and std::string key/value pairs.\n */\nusing HeaderVector = std::vector<std::pair<LowerCaseString, std::string>>;\n\n/**\n * An interface to be implemented by header matchers.\n */\nclass HeaderMatcher {\npublic:\n  virtual ~HeaderMatcher() = default;\n\n  /*\n   * Check whether header matcher matches any headers in a given HeaderMap.\n   */\n  virtual bool matchesHeaders(const HeaderMap& headers) const PURE;\n};\n\nusing HeaderMatcherSharedPtr = std::shared_ptr<HeaderMatcher>;\n\n} // namespace Http\n} // namespace Envoy\n", "#include \"common/http/conn_manager_impl.h\"\n\n#include <cstdint>\n#include <functional>\n#include <list>\n#include <memory>\n#include <string>\n#include <vector>\n\n#include \"envoy/buffer/buffer.h\"\n#include \"envoy/common/time.h\"\n#include \"envoy/event/dispatcher.h\"\n#include \"envoy/network/drain_decision.h\"\n#include \"envoy/router/router.h\"\n#include \"envoy/server/admin.h\"\n#include \"envoy/ssl/connection.h\"\n#include \"envoy/stats/scope.h\"\n#include \"envoy/tracing/http_tracer.h\"\n\n#include \"common/buffer/buffer_impl.h\"\n#include \"common/common/assert.h\"\n#include \"common/common/empty_string.h\"\n#include \"common/common/enum_to_int.h\"\n#include \"common/common/fmt.h\"\n#include \"common/common/scope_tracker.h\"\n#include \"common/common/utility.h\"\n#include \"common/http/codes.h\"\n#include \"common/http/conn_manager_utility.h\"\n#include \"common/http/exception.h\"\n#include \"common/http/header_map_impl.h\"\n#include \"common/http/headers.h\"\n#include \"common/http/http1/codec_impl.h\"\n#include \"common/http/http2/codec_impl.h\"\n#include \"common/http/path_utility.h\"\n#include \"common/http/utility.h\"\n#include \"common/network/utility.h\"\n#include \"common/router/config_impl.h\"\n#include \"common/runtime/runtime_impl.h\"\n\n#include \"absl/strings/escaping.h\"\n#include \"absl/strings/match.h\"\n\nnamespace Envoy {\nnamespace Http {\n\nnamespace {\n\ntemplate <class T> using FilterList = std::list<std::unique_ptr<T>>;\n\n// Shared helper for recording the latest filter used.\ntemplate <class T>\nvoid recordLatestDataFilter(const typename FilterList<T>::iterator current_filter,\n                            T*& latest_filter, const FilterList<T>& filters) {\n  // If this is the first time we're calling onData, just record the current filter.\n  if (latest_filter == nullptr) {\n    latest_filter = current_filter->get();\n    return;\n  }\n\n  // We want to keep this pointing at the latest filter in the filter list that has received the\n  // onData callback. To do so, we compare the current latest with the *previous* filter. If they\n  // match, then we must be processing a new filter for the first time. We omit this check if we're\n  // the first filter, since the above check handles that case.\n  //\n  // We compare against the previous filter to avoid multiple filter iterations from reseting the\n  // pointer: If we just set latest to current, then the first onData filter iteration would\n  // correctly iterate over the filters and set latest, but on subsequent onData iterations\n  // we'd start from the beginning again, potentially allowing filter N to modify the buffer even\n  // though filter M > N was the filter that inserted data into the buffer.\n  if (current_filter != filters.begin() && latest_filter == std::prev(current_filter)->get()) {\n    latest_filter = current_filter->get();\n  }\n}\n\n} // namespace\n\nConnectionManagerStats ConnectionManagerImpl::generateStats(const std::string& prefix,\n                                                            Stats::Scope& scope) {\n  return {\n      {ALL_HTTP_CONN_MAN_STATS(POOL_COUNTER_PREFIX(scope, prefix), POOL_GAUGE_PREFIX(scope, prefix),\n                               POOL_HISTOGRAM_PREFIX(scope, prefix))},\n      prefix,\n      scope};\n}\n\nConnectionManagerTracingStats ConnectionManagerImpl::generateTracingStats(const std::string& prefix,\n                                                                          Stats::Scope& scope) {\n  return {CONN_MAN_TRACING_STATS(POOL_COUNTER_PREFIX(scope, prefix + \"tracing.\"))};\n}\n\nConnectionManagerListenerStats\nConnectionManagerImpl::generateListenerStats(const std::string& prefix, Stats::Scope& scope) {\n  return {CONN_MAN_LISTENER_STATS(POOL_COUNTER_PREFIX(scope, prefix))};\n}\n\nConnectionManagerImpl::ConnectionManagerImpl(ConnectionManagerConfig& config,\n                                             const Network::DrainDecision& drain_close,\n                                             Runtime::RandomGenerator& random_generator,\n                                             Http::Context& http_context, Runtime::Loader& runtime,\n                                             const LocalInfo::LocalInfo& local_info,\n                                             Upstream::ClusterManager& cluster_manager,\n                                             Server::OverloadManager* overload_manager,\n                                             TimeSource& time_source)\n    : config_(config), stats_(config_.stats()),\n      conn_length_(new Stats::Timespan(stats_.named_.downstream_cx_length_ms_, time_source)),\n      drain_close_(drain_close), random_generator_(random_generator), http_context_(http_context),\n      runtime_(runtime), local_info_(local_info), cluster_manager_(cluster_manager),\n      listener_stats_(config_.listenerStats()),\n      overload_stop_accepting_requests_ref_(\n          overload_manager ? overload_manager->getThreadLocalOverloadState().getState(\n                                 Server::OverloadActionNames::get().StopAcceptingRequests)\n                           : Server::OverloadManager::getInactiveState()),\n      overload_disable_keepalive_ref_(\n          overload_manager ? overload_manager->getThreadLocalOverloadState().getState(\n                                 Server::OverloadActionNames::get().DisableHttpKeepAlive)\n                           : Server::OverloadManager::getInactiveState()),\n      time_source_(time_source) {}\n\nconst HeaderMapImpl& ConnectionManagerImpl::continueHeader() {\n  CONSTRUCT_ON_FIRST_USE(HeaderMapImpl,\n                         {Http::Headers::get().Status, std::to_string(enumToInt(Code::Continue))});\n}\n\nvoid ConnectionManagerImpl::initializeReadFilterCallbacks(Network::ReadFilterCallbacks& callbacks) {\n  read_callbacks_ = &callbacks;\n  stats_.named_.downstream_cx_total_.inc();\n  stats_.named_.downstream_cx_active_.inc();\n  if (read_callbacks_->connection().ssl()) {\n    stats_.named_.downstream_cx_ssl_total_.inc();\n    stats_.named_.downstream_cx_ssl_active_.inc();\n  }\n\n  read_callbacks_->connection().addConnectionCallbacks(*this);\n\n  if (config_.idleTimeout()) {\n    connection_idle_timer_ = read_callbacks_->connection().dispatcher().createTimer(\n        [this]() -> void { onIdleTimeout(); });\n    connection_idle_timer_->enableTimer(config_.idleTimeout().value());\n  }\n\n  read_callbacks_->connection().setDelayedCloseTimeout(config_.delayedCloseTimeout());\n\n  read_callbacks_->connection().setConnectionStats(\n      {stats_.named_.downstream_cx_rx_bytes_total_, stats_.named_.downstream_cx_rx_bytes_buffered_,\n       stats_.named_.downstream_cx_tx_bytes_total_, stats_.named_.downstream_cx_tx_bytes_buffered_,\n       nullptr, &stats_.named_.downstream_cx_delayed_close_timeout_});\n}\n\nConnectionManagerImpl::~ConnectionManagerImpl() {\n  stats_.named_.downstream_cx_destroy_.inc();\n  stats_.named_.downstream_cx_active_.dec();\n  if (read_callbacks_->connection().ssl()) {\n    stats_.named_.downstream_cx_ssl_active_.dec();\n  }\n\n  if (codec_) {\n    if (codec_->protocol() == Protocol::Http2) {\n      stats_.named_.downstream_cx_http2_active_.dec();\n    } else {\n      stats_.named_.downstream_cx_http1_active_.dec();\n    }\n  }\n\n  conn_length_->complete();\n  user_agent_.completeConnectionLength(*conn_length_);\n}\n\nvoid ConnectionManagerImpl::checkForDeferredClose() {\n  if (drain_state_ == DrainState::Closing && streams_.empty() && !codec_->wantsToWrite()) {\n    read_callbacks_->connection().close(Network::ConnectionCloseType::FlushWriteAndDelay);\n  }\n}\n\nvoid ConnectionManagerImpl::doEndStream(ActiveStream& stream) {\n  // The order of what happens in this routine is important and a little complicated. We first see\n  // if the stream needs to be reset. If it needs to be, this will end up invoking reset callbacks\n  // and then moving the stream to the deferred destruction list. If the stream has not been reset,\n  // we move it to the deferred deletion list here. Then, we potentially close the connection. This\n  // must be done after deleting the stream since the stream refers to the connection and must be\n  // deleted first.\n  bool reset_stream = false;\n  // If the response encoder is still associated with the stream, reset the stream. The exception\n  // here is when Envoy \"ends\" the stream by calling recreateStream at which point recreateStream\n  // explicitly nulls out response_encoder to avoid the downstream being notified of the\n  // Envoy-internal stream instance being ended.\n  if (stream.response_encoder_ != nullptr &&\n      (!stream.state_.remote_complete_ || !stream.state_.codec_saw_local_complete_)) {\n    // Indicate local is complete at this point so that if we reset during a continuation, we don't\n    // raise further data or trailers.\n    ENVOY_STREAM_LOG(debug, \"doEndStream() resetting stream\", stream);\n    stream.state_.local_complete_ = true;\n    stream.state_.codec_saw_local_complete_ = true;\n    stream.response_encoder_->getStream().resetStream(StreamResetReason::LocalReset);\n    reset_stream = true;\n  }\n\n  if (!reset_stream) {\n    doDeferredStreamDestroy(stream);\n  }\n\n  if (reset_stream && codec_->protocol() != Protocol::Http2) {\n    drain_state_ = DrainState::Closing;\n  }\n\n  checkForDeferredClose();\n\n  // Reading may have been disabled for the non-multiplexing case, so enable it again.\n  // Also be sure to unwind any read-disable done by the prior downstream\n  // connection.\n  if (drain_state_ != DrainState::Closing && codec_->protocol() != Protocol::Http2) {\n    while (!read_callbacks_->connection().readEnabled()) {\n      read_callbacks_->connection().readDisable(false);\n    }\n  }\n}\n\nvoid ConnectionManagerImpl::doDeferredStreamDestroy(ActiveStream& stream) {\n  if (stream.stream_idle_timer_ != nullptr) {\n    stream.stream_idle_timer_->disableTimer();\n    stream.stream_idle_timer_ = nullptr;\n  }\n  stream.disarmRequestTimeout();\n\n  stream.state_.destroyed_ = true;\n  for (auto& filter : stream.decoder_filters_) {\n    filter->handle_->onDestroy();\n  }\n\n  for (auto& filter : stream.encoder_filters_) {\n    // Do not call on destroy twice for dual registered filters.\n    if (!filter->dual_filter_) {\n      filter->handle_->onDestroy();\n    }\n  }\n\n  read_callbacks_->connection().dispatcher().deferredDelete(stream.removeFromList(streams_));\n\n  if (connection_idle_timer_ && streams_.empty()) {\n    connection_idle_timer_->enableTimer(config_.idleTimeout().value());\n  }\n}\n\nStreamDecoder& ConnectionManagerImpl::newStream(StreamEncoder& response_encoder,\n                                                bool is_internally_created) {\n  if (connection_idle_timer_) {\n    connection_idle_timer_->disableTimer();\n  }\n\n  ENVOY_CONN_LOG(debug, \"new stream\", read_callbacks_->connection());\n  ActiveStreamPtr new_stream(new ActiveStream(*this));\n  new_stream->state_.is_internally_created_ = is_internally_created;\n  new_stream->response_encoder_ = &response_encoder;\n  new_stream->response_encoder_->getStream().addCallbacks(*new_stream);\n  new_stream->buffer_limit_ = new_stream->response_encoder_->getStream().bufferLimit();\n  // If the network connection is backed up, the stream should be made aware of it on creation.\n  // Both HTTP/1.x and HTTP/2 codecs handle this in StreamCallbackHelper::addCallbacks_.\n  ASSERT(read_callbacks_->connection().aboveHighWatermark() == false ||\n         new_stream->high_watermark_count_ > 0);\n  new_stream->moveIntoList(std::move(new_stream), streams_);\n  return **streams_.begin();\n}\n\nvoid ConnectionManagerImpl::handleCodecException(const char* error) {\n  ENVOY_CONN_LOG(debug, \"dispatch error: {}\", read_callbacks_->connection(), error);\n\n  // In the protocol error case, we need to reset all streams now. The connection might stick around\n  // long enough for a pending stream to come back and try to encode.\n  resetAllStreams();\n\n  // HTTP/1.1 codec has already sent a 400 response if possible. HTTP/2 codec has already sent\n  // GOAWAY.\n  read_callbacks_->connection().close(Network::ConnectionCloseType::FlushWriteAndDelay);\n}\n\nNetwork::FilterStatus ConnectionManagerImpl::onData(Buffer::Instance& data, bool) {\n  if (!codec_) {\n    codec_ = config_.createCodec(read_callbacks_->connection(), data, *this);\n    if (codec_->protocol() == Protocol::Http2) {\n      stats_.named_.downstream_cx_http2_total_.inc();\n      stats_.named_.downstream_cx_http2_active_.inc();\n    } else {\n      stats_.named_.downstream_cx_http1_total_.inc();\n      stats_.named_.downstream_cx_http1_active_.inc();\n    }\n  }\n\n  // TODO(alyssawilk) clean this up after #8352 is well vetted.\n  bool redispatch;\n  do {\n    redispatch = false;\n\n    try {\n      codec_->dispatch(data);\n    } catch (const FrameFloodException& e) {\n      // TODO(mattklein123): This is an emergency substitute for the lack of connection level\n      // logging in the HCM. In a public follow up change we will add full support for connection\n      // level logging in the HCM, similar to what we have in tcp_proxy. This will allow abuse\n      // indicators to be stored in the connection level stream info, and then matched, sampled,\n      // etc. when logged.\n      const envoy::type::FractionalPercent default_value; // 0\n      if (runtime_.snapshot().featureEnabled(\"http.connection_manager.log_flood_exception\",\n                                             default_value)) {\n        ENVOY_CONN_LOG(warn, \"downstream HTTP flood from IP '{}': {}\",\n                       read_callbacks_->connection(),\n                       read_callbacks_->connection().remoteAddress()->asString(), e.what());\n      }\n\n      handleCodecException(e.what());\n      return Network::FilterStatus::StopIteration;\n    } catch (const CodecProtocolException& e) {\n      stats_.named_.downstream_cx_protocol_error_.inc();\n      handleCodecException(e.what());\n      return Network::FilterStatus::StopIteration;\n    }\n\n    // Processing incoming data may release outbound data so check for closure here as well.\n    checkForDeferredClose();\n\n    // The HTTP/1 codec will pause dispatch after a single message is complete. We want to\n    // either redispatch if there are no streams and we have more data. If we have a single\n    // complete non-WebSocket stream but have not responded yet we will pause socket reads\n    // to apply back pressure.\n    if (codec_->protocol() != Protocol::Http2) {\n      if (read_callbacks_->connection().state() == Network::Connection::State::Open &&\n          data.length() > 0 && streams_.empty()) {\n        redispatch = true;\n      }\n\n      if (!streams_.empty() && streams_.front()->state_.remote_complete_) {\n        read_callbacks_->connection().readDisable(true);\n      }\n    }\n  } while (redispatch);\n\n  return Network::FilterStatus::StopIteration;\n}\n\nvoid ConnectionManagerImpl::resetAllStreams() {\n  while (!streams_.empty()) {\n    // Mimic a downstream reset in this case. We must also remove callbacks here. Though we are\n    // about to close the connection and will disable further reads, it is possible that flushing\n    // data out can cause stream callbacks to fire (e.g., low watermark callbacks).\n    //\n    // TODO(mattklein123): I tried to actually reset through the codec here, but ran into issues\n    // with nghttp2 state and being unhappy about sending reset frames after the connection had\n    // been terminated via GOAWAY. It might be possible to do something better here inside the h2\n    // codec but there are no easy answers and this seems simpler.\n    auto& stream = *streams_.front();\n    stream.response_encoder_->getStream().removeCallbacks(stream);\n    stream.onResetStream(StreamResetReason::ConnectionTermination, absl::string_view());\n  }\n}\n\nvoid ConnectionManagerImpl::onEvent(Network::ConnectionEvent event) {\n  if (event == Network::ConnectionEvent::LocalClose) {\n    stats_.named_.downstream_cx_destroy_local_.inc();\n  }\n\n  if (event == Network::ConnectionEvent::RemoteClose) {\n    stats_.named_.downstream_cx_destroy_remote_.inc();\n  }\n\n  if (event == Network::ConnectionEvent::RemoteClose ||\n      event == Network::ConnectionEvent::LocalClose) {\n    if (connection_idle_timer_) {\n      connection_idle_timer_->disableTimer();\n      connection_idle_timer_.reset();\n    }\n\n    if (drain_timer_) {\n      drain_timer_->disableTimer();\n      drain_timer_.reset();\n    }\n  }\n\n  if (!streams_.empty()) {\n    if (event == Network::ConnectionEvent::LocalClose) {\n      stats_.named_.downstream_cx_destroy_local_active_rq_.inc();\n    }\n    if (event == Network::ConnectionEvent::RemoteClose) {\n      stats_.named_.downstream_cx_destroy_remote_active_rq_.inc();\n    }\n\n    stats_.named_.downstream_cx_destroy_active_rq_.inc();\n    user_agent_.onConnectionDestroy(event, true);\n    resetAllStreams();\n  }\n}\n\nvoid ConnectionManagerImpl::onGoAway() {\n  // Currently we do nothing with remote go away frames. In the future we can decide to no longer\n  // push resources if applicable.\n}\n\nvoid ConnectionManagerImpl::onIdleTimeout() {\n  ENVOY_CONN_LOG(debug, \"idle timeout\", read_callbacks_->connection());\n  stats_.named_.downstream_cx_idle_timeout_.inc();\n  if (!codec_) {\n    // No need to delay close after flushing since an idle timeout has already fired. Attempt to\n    // write out buffered data one last time and issue a local close if successful.\n    read_callbacks_->connection().close(Network::ConnectionCloseType::FlushWrite);\n  } else if (drain_state_ == DrainState::NotDraining) {\n    startDrainSequence();\n  }\n}\n\nvoid ConnectionManagerImpl::onDrainTimeout() {\n  ASSERT(drain_state_ != DrainState::NotDraining);\n  codec_->goAway();\n  drain_state_ = DrainState::Closing;\n  checkForDeferredClose();\n}\n\nvoid ConnectionManagerImpl::chargeTracingStats(const Tracing::Reason& tracing_reason,\n                                               ConnectionManagerTracingStats& tracing_stats) {\n  switch (tracing_reason) {\n  case Tracing::Reason::ClientForced:\n    tracing_stats.client_enabled_.inc();\n    break;\n  case Tracing::Reason::NotTraceableRequestId:\n    tracing_stats.not_traceable_.inc();\n    break;\n  case Tracing::Reason::Sampling:\n    tracing_stats.random_sampling_.inc();\n    break;\n  case Tracing::Reason::ServiceForced:\n    tracing_stats.service_forced_.inc();\n    break;\n  default:\n    throw std::invalid_argument(\n        fmt::format(\"invalid tracing reason, value: {}\", static_cast<int32_t>(tracing_reason)));\n  }\n}\n\nConnectionManagerImpl::ActiveStream::ActiveStream(ConnectionManagerImpl& connection_manager)\n    : connection_manager_(connection_manager),\n      stream_id_(connection_manager.random_generator_.random()),\n      request_response_timespan_(new Stats::Timespan(\n          connection_manager_.stats_.named_.downstream_rq_time_, connection_manager_.timeSource())),\n      stream_info_(connection_manager_.codec_->protocol(), connection_manager_.timeSource()),\n      upstream_options_(std::make_shared<Network::Socket::Options>()) {\n  // For Server::Admin, no routeConfigProvider or SRDS route provider is used.\n  ASSERT(dynamic_cast<Server::Admin*>(&connection_manager_.config_) != nullptr ||\n             ((connection_manager.config_.routeConfigProvider() == nullptr &&\n               connection_manager.config_.scopedRouteConfigProvider() != nullptr) ||\n              (connection_manager.config_.routeConfigProvider() != nullptr &&\n               connection_manager.config_.scopedRouteConfigProvider() == nullptr)),\n         \"Either routeConfigProvider or scopedRouteConfigProvider should be set in \"\n         \"ConnectionManagerImpl.\");\n  if (connection_manager.config_.routeConfigProvider() != nullptr) {\n    snapped_route_config_ = connection_manager.config_.routeConfigProvider()->config();\n  } else if (connection_manager.config_.scopedRouteConfigProvider() != nullptr) {\n    snapped_scoped_routes_config_ =\n        connection_manager_.config_.scopedRouteConfigProvider()->config<Router::ScopedConfig>();\n    ASSERT(snapped_scoped_routes_config_ != nullptr,\n           \"Scoped rds provider returns null for scoped routes config.\");\n  }\n  ScopeTrackerScopeState scope(this,\n                               connection_manager_.read_callbacks_->connection().dispatcher());\n\n  connection_manager_.stats_.named_.downstream_rq_total_.inc();\n  connection_manager_.stats_.named_.downstream_rq_active_.inc();\n  if (connection_manager_.codec_->protocol() == Protocol::Http2) {\n    connection_manager_.stats_.named_.downstream_rq_http2_total_.inc();\n  } else {\n    connection_manager_.stats_.named_.downstream_rq_http1_total_.inc();\n  }\n  stream_info_.setDownstreamLocalAddress(\n      connection_manager_.read_callbacks_->connection().localAddress());\n  stream_info_.setDownstreamDirectRemoteAddress(\n      connection_manager_.read_callbacks_->connection().remoteAddress());\n  // Initially, the downstream remote address is the source address of the\n  // downstream connection. That can change later in the request's lifecycle,\n  // based on XFF processing, but setting the downstream remote address here\n  // prevents surprises for logging code in edge cases.\n  stream_info_.setDownstreamRemoteAddress(\n      connection_manager_.read_callbacks_->connection().remoteAddress());\n\n  stream_info_.setDownstreamSslConnection(connection_manager_.read_callbacks_->connection().ssl());\n\n  if (connection_manager_.config_.streamIdleTimeout().count()) {\n    idle_timeout_ms_ = connection_manager_.config_.streamIdleTimeout();\n    stream_idle_timer_ = connection_manager_.read_callbacks_->connection().dispatcher().createTimer(\n        [this]() -> void { onIdleTimeout(); });\n    resetIdleTimer();\n  }\n\n  if (connection_manager_.config_.requestTimeout().count()) {\n    std::chrono::milliseconds request_timeout_ms_ = connection_manager_.config_.requestTimeout();\n    request_timer_ = connection_manager.read_callbacks_->connection().dispatcher().createTimer(\n        [this]() -> void { onRequestTimeout(); });\n    request_timer_->enableTimer(request_timeout_ms_, this);\n  }\n\n  stream_info_.setRequestedServerName(\n      connection_manager_.read_callbacks_->connection().requestedServerName());\n}\n\nConnectionManagerImpl::ActiveStream::~ActiveStream() {\n  stream_info_.onRequestComplete();\n\n  // A downstream disconnect can be identified for HTTP requests when the upstream returns with a 0\n  // response code and when no other response flags are set.\n  if (!stream_info_.hasAnyResponseFlag() && !stream_info_.responseCode()) {\n    stream_info_.setResponseFlag(StreamInfo::ResponseFlag::DownstreamConnectionTermination);\n  }\n\n  connection_manager_.stats_.named_.downstream_rq_active_.dec();\n  for (const AccessLog::InstanceSharedPtr& access_log : connection_manager_.config_.accessLogs()) {\n    access_log->log(request_headers_.get(), response_headers_.get(), response_trailers_.get(),\n                    stream_info_);\n  }\n  for (const auto& log_handler : access_log_handlers_) {\n    log_handler->log(request_headers_.get(), response_headers_.get(), response_trailers_.get(),\n                     stream_info_);\n  }\n\n  if (stream_info_.healthCheck()) {\n    connection_manager_.config_.tracingStats().health_check_.inc();\n  }\n\n  if (active_span_) {\n    Tracing::HttpTracerUtility::finalizeDownstreamSpan(\n        *active_span_, request_headers_.get(), response_headers_.get(), response_trailers_.get(),\n        stream_info_, *this);\n  }\n  if (state_.successful_upgrade_) {\n    connection_manager_.stats_.named_.downstream_cx_upgrades_active_.dec();\n  }\n\n  ASSERT(state_.filter_call_state_ == 0);\n}\n\nvoid ConnectionManagerImpl::ActiveStream::resetIdleTimer() {\n  if (stream_idle_timer_ != nullptr) {\n    // TODO(htuch): If this shows up in performance profiles, optimize by only\n    // updating a timestamp here and doing periodic checks for idle timeouts\n    // instead, or reducing the accuracy of timers.\n    stream_idle_timer_->enableTimer(idle_timeout_ms_);\n  }\n}\n\nvoid ConnectionManagerImpl::ActiveStream::onIdleTimeout() {\n  connection_manager_.stats_.named_.downstream_rq_idle_timeout_.inc();\n  // If headers have not been sent to the user, send a 408.\n  if (response_headers_ != nullptr) {\n    // TODO(htuch): We could send trailers here with an x-envoy timeout header\n    // or gRPC status code, and/or set H2 RST_STREAM error.\n    connection_manager_.doEndStream(*this);\n  } else {\n    stream_info_.setResponseFlag(StreamInfo::ResponseFlag::StreamIdleTimeout);\n    sendLocalReply(request_headers_ != nullptr &&\n                       Grpc::Common::hasGrpcContentType(*request_headers_),\n                   Http::Code::RequestTimeout, \"stream timeout\", nullptr, is_head_request_,\n                   absl::nullopt, StreamInfo::ResponseCodeDetails::get().StreamIdleTimeout);\n  }\n}\n\nvoid ConnectionManagerImpl::ActiveStream::onRequestTimeout() {\n  connection_manager_.stats_.named_.downstream_rq_timeout_.inc();\n  sendLocalReply(request_headers_ != nullptr && Grpc::Common::hasGrpcContentType(*request_headers_),\n                 Http::Code::RequestTimeout, \"request timeout\", nullptr, is_head_request_,\n                 absl::nullopt, StreamInfo::ResponseCodeDetails::get().RequestOverallTimeout);\n}\n\nvoid ConnectionManagerImpl::ActiveStream::addStreamDecoderFilterWorker(\n    StreamDecoderFilterSharedPtr filter, bool dual_filter) {\n  ActiveStreamDecoderFilterPtr wrapper(new ActiveStreamDecoderFilter(*this, filter, dual_filter));\n  filter->setDecoderFilterCallbacks(*wrapper);\n  wrapper->moveIntoListBack(std::move(wrapper), decoder_filters_);\n}\n\nvoid ConnectionManagerImpl::ActiveStream::addStreamEncoderFilterWorker(\n    StreamEncoderFilterSharedPtr filter, bool dual_filter) {\n  ActiveStreamEncoderFilterPtr wrapper(new ActiveStreamEncoderFilter(*this, filter, dual_filter));\n  filter->setEncoderFilterCallbacks(*wrapper);\n  wrapper->moveIntoList(std::move(wrapper), encoder_filters_);\n}\n\nvoid ConnectionManagerImpl::ActiveStream::addAccessLogHandler(\n    AccessLog::InstanceSharedPtr handler) {\n  access_log_handlers_.push_back(handler);\n}\n\nvoid ConnectionManagerImpl::ActiveStream::chargeStats(const HeaderMap& headers) {\n  uint64_t response_code = Utility::getResponseStatus(headers);\n  stream_info_.response_code_ = response_code;\n\n  if (stream_info_.health_check_request_) {\n    return;\n  }\n\n  connection_manager_.stats_.named_.downstream_rq_completed_.inc();\n  connection_manager_.listener_stats_.downstream_rq_completed_.inc();\n  if (CodeUtility::is1xx(response_code)) {\n    connection_manager_.stats_.named_.downstream_rq_1xx_.inc();\n    connection_manager_.listener_stats_.downstream_rq_1xx_.inc();\n  } else if (CodeUtility::is2xx(response_code)) {\n    connection_manager_.stats_.named_.downstream_rq_2xx_.inc();\n    connection_manager_.listener_stats_.downstream_rq_2xx_.inc();\n  } else if (CodeUtility::is3xx(response_code)) {\n    connection_manager_.stats_.named_.downstream_rq_3xx_.inc();\n    connection_manager_.listener_stats_.downstream_rq_3xx_.inc();\n  } else if (CodeUtility::is4xx(response_code)) {\n    connection_manager_.stats_.named_.downstream_rq_4xx_.inc();\n    connection_manager_.listener_stats_.downstream_rq_4xx_.inc();\n  } else if (CodeUtility::is5xx(response_code)) {\n    connection_manager_.stats_.named_.downstream_rq_5xx_.inc();\n    connection_manager_.listener_stats_.downstream_rq_5xx_.inc();\n  }\n}\n\nconst Network::Connection* ConnectionManagerImpl::ActiveStream::connection() {\n  return &connection_manager_.read_callbacks_->connection();\n}\n\n// Ordering in this function is complicated, but important.\n//\n// We want to do minimal work before selecting route and creating a filter\n// chain to maximize the number of requests which get custom filter behavior,\n// e.g. registering access logging.\n//\n// This must be balanced by doing sanity checking for invalid requests (one\n// can't route select properly without full headers), checking state required to\n// serve error responses (connection close, head requests, etc), and\n// modifications which may themselves affect route selection.\n//\n// TODO(alyssawilk) all the calls here should be audited for order priority,\n// e.g. many early returns do not currently handle connection: close properly.\nvoid ConnectionManagerImpl::ActiveStream::decodeHeaders(HeaderMapPtr&& headers, bool end_stream) {\n  ScopeTrackerScopeState scope(this,\n                               connection_manager_.read_callbacks_->connection().dispatcher());\n  request_headers_ = std::move(headers);\n  // For Admin thread, we don't use routeConfigProvider or SRDS route provider.\n  if (dynamic_cast<Server::Admin*>(&connection_manager_.config_) == nullptr &&\n      connection_manager_.config_.scopedRouteConfigProvider() != nullptr) {\n    ASSERT(snapped_route_config_ == nullptr,\n           \"Route config already latched to the active stream when scoped RDS is enabled.\");\n    // We need to snap snapped_route_config_ here as it's used in mutateRequestHeaders later.\n    snapScopedRouteConfig();\n  }\n\n  if (Http::Headers::get().MethodValues.Head ==\n      request_headers_->Method()->value().getStringView()) {\n    is_head_request_ = true;\n  }\n  ENVOY_STREAM_LOG(debug, \"request headers complete (end_stream={}):\\n{}\", *this, end_stream,\n                   *request_headers_);\n\n  // We end the decode here only if the request is header only. If we convert the request to a\n  // header only, the stream will be marked as done once a subsequent decodeData/decodeTrailers is\n  // called with end_stream=true.\n  maybeEndDecode(end_stream);\n\n  // Drop new requests when overloaded as soon as we have decoded the headers.\n  if (connection_manager_.overload_stop_accepting_requests_ref_ ==\n      Server::OverloadActionState::Active) {\n    // In this one special case, do not create the filter chain. If there is a risk of memory\n    // overload it is more important to avoid unnecessary allocation than to create the filters.\n    state_.created_filter_chain_ = true;\n    connection_manager_.stats_.named_.downstream_rq_overload_close_.inc();\n    sendLocalReply(Grpc::Common::hasGrpcContentType(*request_headers_),\n                   Http::Code::ServiceUnavailable, \"envoy overloaded\", nullptr, is_head_request_,\n                   absl::nullopt, StreamInfo::ResponseCodeDetails::get().Overload);\n    return;\n  }\n\n  if (!connection_manager_.config_.proxy100Continue() && request_headers_->Expect() &&\n      request_headers_->Expect()->value() == Headers::get().ExpectValues._100Continue.c_str()) {\n    // Note in the case Envoy is handling 100-Continue complexity, it skips the filter chain\n    // and sends the 100-Continue directly to the encoder.\n    chargeStats(continueHeader());\n    response_encoder_->encode100ContinueHeaders(continueHeader());\n    // Remove the Expect header so it won't be handled again upstream.\n    request_headers_->removeExpect();\n  }\n\n  connection_manager_.user_agent_.initializeFromHeaders(\n      *request_headers_, connection_manager_.stats_.prefix_, connection_manager_.stats_.scope_);\n\n  // Make sure we are getting a codec version we support.\n  Protocol protocol = connection_manager_.codec_->protocol();\n  if (protocol == Protocol::Http10) {\n    // Assume this is HTTP/1.0. This is fine for HTTP/0.9 but this code will also affect any\n    // requests with non-standard version numbers (0.9, 1.3), basically anything which is not\n    // HTTP/1.1.\n    //\n    // The protocol may have shifted in the HTTP/1.0 case so reset it.\n    stream_info_.protocol(protocol);\n    if (!connection_manager_.config_.http1Settings().accept_http_10_) {\n      // Send \"Upgrade Required\" if HTTP/1.0 support is not explicitly configured on.\n      sendLocalReply(false, Code::UpgradeRequired, \"\", nullptr, is_head_request_, absl::nullopt,\n                     StreamInfo::ResponseCodeDetails::get().LowVersion);\n      return;\n    } else {\n      // HTTP/1.0 defaults to single-use connections. Make sure the connection\n      // will be closed unless Keep-Alive is present.\n      state_.saw_connection_close_ = true;\n      if (request_headers_->Connection() &&\n          absl::EqualsIgnoreCase(request_headers_->Connection()->value().getStringView(),\n                                 Http::Headers::get().ConnectionValues.KeepAlive)) {\n        state_.saw_connection_close_ = false;\n      }\n    }\n  }\n\n  if (!request_headers_->Host()) {\n    if ((protocol == Protocol::Http10) &&\n        !connection_manager_.config_.http1Settings().default_host_for_http_10_.empty()) {\n      // Add a default host if configured to do so.\n      request_headers_->insertHost().value(\n          connection_manager_.config_.http1Settings().default_host_for_http_10_);\n    } else {\n      // Require host header. For HTTP/1.1 Host has already been translated to :authority.\n      sendLocalReply(Grpc::Common::hasGrpcContentType(*request_headers_), Code::BadRequest, \"\",\n                     nullptr, is_head_request_, absl::nullopt,\n                     StreamInfo::ResponseCodeDetails::get().MissingHost);\n      return;\n    }\n  }\n\n  ASSERT(connection_manager_.config_.maxRequestHeadersKb() > 0);\n  if (request_headers_->byteSize() > (connection_manager_.config_.maxRequestHeadersKb() * 1024)) {\n    sendLocalReply(Grpc::Common::hasGrpcContentType(*request_headers_),\n                   Code::RequestHeaderFieldsTooLarge, \"\", nullptr, is_head_request_, absl::nullopt,\n                   StreamInfo::ResponseCodeDetails::get().RequestHeadersTooLarge);\n    return;\n  }\n\n  // Currently we only support relative paths at the application layer. We expect the codec to have\n  // broken the path into pieces if applicable. NOTE: Currently the HTTP/1.1 codec only does this\n  // when the allow_absolute_url flag is enabled on the HCM.\n  // https://tools.ietf.org/html/rfc7230#section-5.3 We also need to check for the existence of\n  // :path because CONNECT does not have a path, and we don't support that currently.\n  if (!request_headers_->Path() || request_headers_->Path()->value().getStringView().empty() ||\n      request_headers_->Path()->value().getStringView()[0] != '/') {\n    const bool has_path =\n        request_headers_->Path() && !request_headers_->Path()->value().getStringView().empty();\n    connection_manager_.stats_.named_.downstream_rq_non_relative_path_.inc();\n    sendLocalReply(Grpc::Common::hasGrpcContentType(*request_headers_), Code::NotFound, \"\", nullptr,\n                   is_head_request_, absl::nullopt,\n                   has_path ? StreamInfo::ResponseCodeDetails::get().AbsolutePath\n                            : StreamInfo::ResponseCodeDetails::get().MissingPath);\n    return;\n  }\n\n  // Path sanitization should happen before any path access other than the above sanity check.\n  if (!ConnectionManagerUtility::maybeNormalizePath(*request_headers_,\n                                                    connection_manager_.config_)) {\n    sendLocalReply(Grpc::Common::hasGrpcContentType(*request_headers_), Code::BadRequest, \"\",\n                   nullptr, is_head_request_, absl::nullopt,\n                   StreamInfo::ResponseCodeDetails::get().PathNormalizationFailed);\n    return;\n  }\n\n  if (protocol == Protocol::Http11 && request_headers_->Connection() &&\n      absl::EqualsIgnoreCase(request_headers_->Connection()->value().getStringView(),\n                             Http::Headers::get().ConnectionValues.Close)) {\n    state_.saw_connection_close_ = true;\n  }\n  // Note: Proxy-Connection is not a standard header, but is supported here\n  // since it is supported by http-parser the underlying parser for http\n  // requests.\n  if (protocol != Protocol::Http2 && !state_.saw_connection_close_ &&\n      request_headers_->ProxyConnection() &&\n      absl::EqualsIgnoreCase(request_headers_->ProxyConnection()->value().getStringView(),\n                             Http::Headers::get().ConnectionValues.Close)) {\n    state_.saw_connection_close_ = true;\n  }\n\n  if (!state_.is_internally_created_) { // Only sanitize headers on first pass.\n    // Modify the downstream remote address depending on configuration and headers.\n    stream_info_.setDownstreamRemoteAddress(ConnectionManagerUtility::mutateRequestHeaders(\n        *request_headers_, connection_manager_.read_callbacks_->connection(),\n        connection_manager_.config_, *snapped_route_config_, connection_manager_.random_generator_,\n        connection_manager_.local_info_));\n  }\n  ASSERT(stream_info_.downstreamRemoteAddress() != nullptr);\n\n  ASSERT(!cached_route_);\n  refreshCachedRoute();\n\n  if (!state_.is_internally_created_) { // Only mutate tracing headers on first pass.\n    ConnectionManagerUtility::mutateTracingRequestHeader(\n        *request_headers_, connection_manager_.runtime_, connection_manager_.config_,\n        cached_route_.value().get());\n  }\n\n  const bool upgrade_rejected = createFilterChain() == false;\n\n  // TODO if there are no filters when starting a filter iteration, the connection manager\n  // should return 404. The current returns no response if there is no router filter.\n  if (protocol == Protocol::Http11 && hasCachedRoute()) {\n    if (upgrade_rejected) {\n      // Do not allow upgrades if the route does not support it.\n      connection_manager_.stats_.named_.downstream_rq_ws_on_non_ws_route_.inc();\n      sendLocalReply(Grpc::Common::hasGrpcContentType(*request_headers_), Code::Forbidden, \"\",\n                     nullptr, is_head_request_, absl::nullopt,\n                     StreamInfo::ResponseCodeDetails::get().UpgradeFailed);\n      return;\n    }\n    // Allow non websocket requests to go through websocket enabled routes.\n  }\n\n  if (hasCachedRoute()) {\n    const Router::RouteEntry* route_entry = cached_route_.value()->routeEntry();\n    if (route_entry != nullptr && route_entry->idleTimeout()) {\n      idle_timeout_ms_ = route_entry->idleTimeout().value();\n      if (idle_timeout_ms_.count()) {\n        // If we have a route-level idle timeout but no global stream idle timeout, create a timer.\n        if (stream_idle_timer_ == nullptr) {\n          stream_idle_timer_ =\n              connection_manager_.read_callbacks_->connection().dispatcher().createTimer(\n                  [this]() -> void { onIdleTimeout(); });\n        }\n      } else if (stream_idle_timer_ != nullptr) {\n        // If we had a global stream idle timeout but the route-level idle timeout is set to zero\n        // (to override), we disable the idle timer.\n        stream_idle_timer_->disableTimer();\n        stream_idle_timer_ = nullptr;\n      }\n    }\n  }\n\n  // Check if tracing is enabled at all.\n  if (connection_manager_.config_.tracingConfig()) {\n    traceRequest();\n  }\n\n  decodeHeaders(nullptr, *request_headers_, end_stream);\n\n  // Reset it here for both global and overridden cases.\n  resetIdleTimer();\n}\n\nvoid ConnectionManagerImpl::ActiveStream::traceRequest() {\n  Tracing::Decision tracing_decision =\n      Tracing::HttpTracerUtility::isTracing(stream_info_, *request_headers_);\n  ConnectionManagerImpl::chargeTracingStats(tracing_decision.reason,\n                                            connection_manager_.config_.tracingStats());\n\n  active_span_ = connection_manager_.tracer().startSpan(*this, *request_headers_, stream_info_,\n                                                        tracing_decision);\n\n  if (!active_span_) {\n    return;\n  }\n\n  // TODO: Need to investigate the following code based on the cached route, as may\n  // be broken in the case a filter changes the route.\n\n  // If a decorator has been defined, apply it to the active span.\n  if (hasCachedRoute() && cached_route_.value()->decorator()) {\n    cached_route_.value()->decorator()->apply(*active_span_);\n\n    // Cache decorated operation.\n    if (!cached_route_.value()->decorator()->getOperation().empty()) {\n      decorated_operation_ = &cached_route_.value()->decorator()->getOperation();\n    }\n  }\n\n  if (connection_manager_.config_.tracingConfig()->operation_name_ ==\n      Tracing::OperationName::Egress) {\n    // For egress (outbound) requests, pass the decorator's operation name (if defined)\n    // as a request header to enable the receiving service to use it in its server span.\n    if (decorated_operation_) {\n      request_headers_->insertEnvoyDecoratorOperation().value(*decorated_operation_);\n    }\n  } else {\n    const HeaderEntry* req_operation_override = request_headers_->EnvoyDecoratorOperation();\n\n    // For ingress (inbound) requests, if a decorator operation name has been provided, it\n    // should be used to override the active span's operation.\n    if (req_operation_override) {\n      if (!req_operation_override->value().empty()) {\n        active_span_->setOperation(req_operation_override->value().getStringView());\n\n        // Clear the decorated operation so won't be used in the response header, as\n        // it has been overridden by the inbound decorator operation request header.\n        decorated_operation_ = nullptr;\n      }\n      // Remove header so not propagated to service\n      request_headers_->removeEnvoyDecoratorOperation();\n    }\n  }\n}\n\nvoid ConnectionManagerImpl::ActiveStream::decodeHeaders(ActiveStreamDecoderFilter* filter,\n                                                        HeaderMap& headers, bool end_stream) {\n  // Headers filter iteration should always start with the next filter if available.\n  std::list<ActiveStreamDecoderFilterPtr>::iterator entry =\n      commonDecodePrefix(filter, FilterIterationStartState::AlwaysStartFromNext);\n  std::list<ActiveStreamDecoderFilterPtr>::iterator continue_data_entry = decoder_filters_.end();\n\n  for (; entry != decoder_filters_.end(); entry++) {\n    ASSERT(!(state_.filter_call_state_ & FilterCallState::DecodeHeaders));\n    state_.filter_call_state_ |= FilterCallState::DecodeHeaders;\n    (*entry)->end_stream_ =\n        decoding_headers_only_ || (end_stream && continue_data_entry == decoder_filters_.end());\n    FilterHeadersStatus status = (*entry)->decodeHeaders(headers, (*entry)->end_stream_);\n\n    ASSERT(!(status == FilterHeadersStatus::ContinueAndEndStream && (*entry)->end_stream_));\n    state_.filter_call_state_ &= ~FilterCallState::DecodeHeaders;\n    ENVOY_STREAM_LOG(trace, \"decode headers called: filter={} status={}\", *this,\n                     static_cast<const void*>((*entry).get()), static_cast<uint64_t>(status));\n\n    const bool new_metadata_added = processNewlyAddedMetadata();\n    // If end_stream is set in headers, and a filter adds new metadata, we need to delay end_stream\n    // in headers by inserting an empty data frame with end_stream set. The empty data frame is sent\n    // after the new metadata.\n    if ((*entry)->end_stream_ && new_metadata_added && !buffered_request_data_) {\n      Buffer::OwnedImpl empty_data(\"\");\n      ENVOY_STREAM_LOG(\n          trace, \"inserting an empty data frame for end_stream due metadata being added.\", *this);\n      // Metadata frame doesn't carry end of stream bit. We need an empty data frame to end the\n      // stream.\n      addDecodedData(*((*entry).get()), empty_data, true);\n    }\n\n    (*entry)->decode_headers_called_ = true;\n    if (!(*entry)->commonHandleAfterHeadersCallback(status, decoding_headers_only_) &&\n        std::next(entry) != decoder_filters_.end()) {\n      // Stop iteration IFF this is not the last filter. If it is the last filter, continue with\n      // processing since we need to handle the case where a terminal filter wants to buffer, but\n      // a previous filter has added body.\n      return;\n    }\n\n    // Here we handle the case where we have a header only request, but a filter adds a body\n    // to it. We need to not raise end_stream = true to further filters during inline iteration.\n    if (end_stream && buffered_request_data_ && continue_data_entry == decoder_filters_.end()) {\n      continue_data_entry = entry;\n    }\n  }\n\n  if (continue_data_entry != decoder_filters_.end()) {\n    // We use the continueDecoding() code since it will correctly handle not calling\n    // decodeHeaders() again. Fake setting StopSingleIteration since the continueDecoding() code\n    // expects it.\n    ASSERT(buffered_request_data_);\n    (*continue_data_entry)->iteration_state_ =\n        ActiveStreamFilterBase::IterationState::StopSingleIteration;\n    (*continue_data_entry)->continueDecoding();\n  }\n\n  if (end_stream) {\n    disarmRequestTimeout();\n  }\n}\n\nvoid ConnectionManagerImpl::ActiveStream::decodeData(Buffer::Instance& data, bool end_stream) {\n  ScopeTrackerScopeState scope(this,\n                               connection_manager_.read_callbacks_->connection().dispatcher());\n  maybeEndDecode(end_stream);\n  stream_info_.addBytesReceived(data.length());\n\n  decodeData(nullptr, data, end_stream, FilterIterationStartState::CanStartFromCurrent);\n}\n\nvoid ConnectionManagerImpl::ActiveStream::decodeData(\n    ActiveStreamDecoderFilter* filter, Buffer::Instance& data, bool end_stream,\n    FilterIterationStartState filter_iteration_start_state) {\n  ScopeTrackerScopeState scope(this,\n                               connection_manager_.read_callbacks_->connection().dispatcher());\n  resetIdleTimer();\n\n  // If we previously decided to decode only the headers, do nothing here.\n  if (decoding_headers_only_) {\n    return;\n  }\n\n  // If a response is complete or a reset has been sent, filters do not care about further body\n  // data. Just drop it.\n  if (state_.local_complete_) {\n    return;\n  }\n\n  auto trailers_added_entry = decoder_filters_.end();\n  const bool trailers_exists_at_start = request_trailers_ != nullptr;\n  // Filter iteration may start at the current filter.\n  std::list<ActiveStreamDecoderFilterPtr>::iterator entry =\n      commonDecodePrefix(filter, filter_iteration_start_state);\n\n  for (; entry != decoder_filters_.end(); entry++) {\n    // If the filter pointed by entry has stopped for all frame types, return now.\n    if (handleDataIfStopAll(**entry, data, state_.decoder_filters_streaming_)) {\n      return;\n    }\n    // If end_stream_ is marked for a filter, the data is not for this filter and filters after.\n    //\n    // In following case, ActiveStreamFilterBase::commonContinue() could be called recursively and\n    // its doData() is called with wrong data.\n    //\n    //  There are 3 decode filters and \"wrapper\" refers to ActiveStreamFilter object.\n    //\n    //  filter0->decodeHeaders(_, true)\n    //    return STOP\n    //  filter0->continueDecoding()\n    //    wrapper0->commonContinue()\n    //      wrapper0->decodeHeaders(_, _, true)\n    //        filter1->decodeHeaders(_, true)\n    //          filter1->addDecodeData()\n    //          return CONTINUE\n    //        filter2->decodeHeaders(_, false)\n    //          return CONTINUE\n    //        wrapper1->commonContinue() // Detects data is added.\n    //          wrapper1->doData()\n    //            wrapper1->decodeData()\n    //              filter2->decodeData(_, true)\n    //                 return CONTINUE\n    //      wrapper0->doData() // This should not be called\n    //        wrapper0->decodeData()\n    //          filter1->decodeData(_, true)  // It will cause assertions.\n    //\n    // One way to solve this problem is to mark end_stream_ for each filter.\n    // If a filter is already marked as end_stream_ when decodeData() is called, bails out the\n    // whole function. If just skip the filter, the codes after the loop will be called with\n    // wrong data. For encodeData, the response_encoder->encode() will be called.\n    if ((*entry)->end_stream_) {\n      return;\n    }\n    ASSERT(!(state_.filter_call_state_ & FilterCallState::DecodeData));\n\n    // We check the request_trailers_ pointer here in case addDecodedTrailers\n    // is called in decodeData during a previous filter invocation, at which point we communicate to\n    // the current and future filters that the stream has not yet ended.\n    if (end_stream) {\n      state_.filter_call_state_ |= FilterCallState::LastDataFrame;\n    }\n\n    recordLatestDataFilter(entry, state_.latest_data_decoding_filter_, decoder_filters_);\n\n    state_.filter_call_state_ |= FilterCallState::DecodeData;\n    (*entry)->end_stream_ = end_stream && !request_trailers_;\n    FilterDataStatus status = (*entry)->handle_->decodeData(data, (*entry)->end_stream_);\n    if ((*entry)->end_stream_) {\n      (*entry)->handle_->decodeComplete();\n    }\n    state_.filter_call_state_ &= ~FilterCallState::DecodeData;\n    if (end_stream) {\n      state_.filter_call_state_ &= ~FilterCallState::LastDataFrame;\n    }\n    ENVOY_STREAM_LOG(trace, \"decode data called: filter={} status={}\", *this,\n                     static_cast<const void*>((*entry).get()), static_cast<uint64_t>(status));\n\n    processNewlyAddedMetadata();\n\n    if (!trailers_exists_at_start && request_trailers_ &&\n        trailers_added_entry == decoder_filters_.end()) {\n      trailers_added_entry = entry;\n    }\n\n    if (!(*entry)->commonHandleAfterDataCallback(status, data, state_.decoder_filters_streaming_) &&\n        std::next(entry) != decoder_filters_.end()) {\n      // Stop iteration IFF this is not the last filter. If it is the last filter, continue with\n      // processing since we need to handle the case where a terminal filter wants to buffer, but\n      // a previous filter has added trailers.\n      return;\n    }\n  }\n\n  // If trailers were adding during decodeData we need to trigger decodeTrailers in order\n  // to allow filters to process the trailers.\n  if (trailers_added_entry != decoder_filters_.end()) {\n    decodeTrailers(trailers_added_entry->get(), *request_trailers_);\n  }\n\n  if (end_stream) {\n    disarmRequestTimeout();\n  }\n}\n\nHeaderMap& ConnectionManagerImpl::ActiveStream::addDecodedTrailers() {\n  // Trailers can only be added during the last data frame (i.e. end_stream = true).\n  ASSERT(state_.filter_call_state_ & FilterCallState::LastDataFrame);\n\n  // Trailers can only be added once.\n  ASSERT(!request_trailers_);\n\n  request_trailers_ = std::make_unique<HeaderMapImpl>();\n  return *request_trailers_;\n}\n\nvoid ConnectionManagerImpl::ActiveStream::addDecodedData(ActiveStreamDecoderFilter& filter,\n                                                         Buffer::Instance& data, bool streaming) {\n  if (state_.filter_call_state_ == 0 ||\n      (state_.filter_call_state_ & FilterCallState::DecodeHeaders) ||\n      (state_.filter_call_state_ & FilterCallState::DecodeData) ||\n      ((state_.filter_call_state_ & FilterCallState::DecodeTrailers) && !filter.canIterate())) {\n    // Make sure if this triggers watermarks, the correct action is taken.\n    state_.decoder_filters_streaming_ = streaming;\n    // If no call is happening or we are in the decode headers/data callback, buffer the data.\n    // Inline processing happens in the decodeHeaders() callback if necessary.\n    filter.commonHandleBufferData(data);\n  } else if (state_.filter_call_state_ & FilterCallState::DecodeTrailers) {\n    // In this case we need to inline dispatch the data to further filters. If those filters\n    // choose to buffer/stop iteration that's fine.\n    decodeData(&filter, data, false, FilterIterationStartState::AlwaysStartFromNext);\n  } else {\n    // TODO(mattklein123): Formalize error handling for filters and add tests. Should probably\n    // throw an exception here.\n    NOT_IMPLEMENTED_GCOVR_EXCL_LINE;\n  }\n}\n\nMetadataMapVector& ConnectionManagerImpl::ActiveStream::addDecodedMetadata() {\n  return *getRequestMetadataMapVector();\n}\n\nvoid ConnectionManagerImpl::ActiveStream::decodeTrailers(HeaderMapPtr&& trailers) {\n  ScopeTrackerScopeState scope(this,\n                               connection_manager_.read_callbacks_->connection().dispatcher());\n  resetIdleTimer();\n  maybeEndDecode(true);\n  request_trailers_ = std::move(trailers);\n  decodeTrailers(nullptr, *request_trailers_);\n}\n\nvoid ConnectionManagerImpl::ActiveStream::decodeTrailers(ActiveStreamDecoderFilter* filter,\n                                                         HeaderMap& trailers) {\n  // If we previously decided to decode only the headers, do nothing here.\n  if (decoding_headers_only_) {\n    return;\n  }\n\n  // See decodeData() above for why we check local_complete_ here.\n  if (state_.local_complete_) {\n    return;\n  }\n\n  // Filter iteration may start at the current filter.\n  std::list<ActiveStreamDecoderFilterPtr>::iterator entry =\n      commonDecodePrefix(filter, FilterIterationStartState::CanStartFromCurrent);\n\n  for (; entry != decoder_filters_.end(); entry++) {\n    // If the filter pointed by entry has stopped for all frame type, return now.\n    if ((*entry)->stoppedAll()) {\n      return;\n    }\n\n    ASSERT(!(state_.filter_call_state_ & FilterCallState::DecodeTrailers));\n    state_.filter_call_state_ |= FilterCallState::DecodeTrailers;\n    FilterTrailersStatus status = (*entry)->handle_->decodeTrailers(trailers);\n    (*entry)->handle_->decodeComplete();\n    (*entry)->end_stream_ = true;\n    state_.filter_call_state_ &= ~FilterCallState::DecodeTrailers;\n    ENVOY_STREAM_LOG(trace, \"decode trailers called: filter={} status={}\", *this,\n                     static_cast<const void*>((*entry).get()), static_cast<uint64_t>(status));\n\n    processNewlyAddedMetadata();\n\n    if (!(*entry)->commonHandleAfterTrailersCallback(status)) {\n      return;\n    }\n  }\n  disarmRequestTimeout();\n}\n\nvoid ConnectionManagerImpl::ActiveStream::decodeMetadata(MetadataMapPtr&& metadata_map) {\n  resetIdleTimer();\n  // After going through filters, the ownership of metadata_map will be passed to terminal filter.\n  // The terminal filter may encode metadata_map to the next hop immediately or store metadata_map\n  // and encode later when connection pool is ready.\n  decodeMetadata(nullptr, *metadata_map);\n}\n\nvoid ConnectionManagerImpl::ActiveStream::decodeMetadata(ActiveStreamDecoderFilter* filter,\n                                                         MetadataMap& metadata_map) {\n  // Filter iteration may start at the current filter.\n  std::list<ActiveStreamDecoderFilterPtr>::iterator entry =\n      commonDecodePrefix(filter, FilterIterationStartState::CanStartFromCurrent);\n\n  for (; entry != decoder_filters_.end(); entry++) {\n    // If the filter pointed by entry has stopped for all frame type, stores metadata and returns.\n    // If the filter pointed by entry hasn't returned from decodeHeaders, stores newly added\n    // metadata in case decodeHeaders returns StopAllIteration. The latter can happen when headers\n    // callbacks generate new metadata.\n    if (!(*entry)->decode_headers_called_ || (*entry)->stoppedAll()) {\n      Http::MetadataMapPtr metadata_map_ptr = std::make_unique<Http::MetadataMap>(metadata_map);\n      (*entry)->getSavedRequestMetadata()->emplace_back(std::move(metadata_map_ptr));\n      return;\n    }\n\n    FilterMetadataStatus status = (*entry)->handle_->decodeMetadata(metadata_map);\n    ENVOY_STREAM_LOG(trace, \"decode metadata called: filter={} status={}, metadata: {}\", *this,\n                     static_cast<const void*>((*entry).get()), static_cast<uint64_t>(status),\n                     metadata_map);\n  }\n}\n\nvoid ConnectionManagerImpl::ActiveStream::maybeEndDecode(bool end_stream) {\n  ASSERT(!state_.remote_complete_);\n  state_.remote_complete_ = end_stream;\n  if (end_stream) {\n    stream_info_.onLastDownstreamRxByteReceived();\n    ENVOY_STREAM_LOG(debug, \"request end stream\", *this);\n  }\n}\n\nvoid ConnectionManagerImpl::ActiveStream::disarmRequestTimeout() {\n  if (request_timer_) {\n    request_timer_->disableTimer();\n  }\n}\n\nstd::list<ConnectionManagerImpl::ActiveStreamEncoderFilterPtr>::iterator\nConnectionManagerImpl::ActiveStream::commonEncodePrefix(\n    ActiveStreamEncoderFilter* filter, bool end_stream,\n    FilterIterationStartState filter_iteration_start_state) {\n  // Only do base state setting on the initial call. Subsequent calls for filtering do not touch\n  // the base state.\n  if (filter == nullptr) {\n    ASSERT(!state_.local_complete_);\n    state_.local_complete_ = end_stream;\n    return encoder_filters_.begin();\n  }\n\n  if (filter_iteration_start_state == FilterIterationStartState::CanStartFromCurrent &&\n      (*(filter->entry()))->iterate_from_current_filter_) {\n    // The filter iteration has been stopped for all frame types, and now the iteration continues.\n    // The current filter's encoding callback has not be called. Call it now.\n    return filter->entry();\n  }\n  return std::next(filter->entry());\n}\n\nstd::list<ConnectionManagerImpl::ActiveStreamDecoderFilterPtr>::iterator\nConnectionManagerImpl::ActiveStream::commonDecodePrefix(\n    ActiveStreamDecoderFilter* filter, FilterIterationStartState filter_iteration_start_state) {\n  if (!filter) {\n    return decoder_filters_.begin();\n  }\n  if (filter_iteration_start_state == FilterIterationStartState::CanStartFromCurrent &&\n      (*(filter->entry()))->iterate_from_current_filter_) {\n    // The filter iteration has been stopped for all frame types, and now the iteration continues.\n    // The current filter's callback function has not been called. Call it now.\n    return filter->entry();\n  }\n  return std::next(filter->entry());\n}\n\nvoid ConnectionManagerImpl::startDrainSequence() {\n  ASSERT(drain_state_ == DrainState::NotDraining);\n  drain_state_ = DrainState::Draining;\n  codec_->shutdownNotice();\n  drain_timer_ = read_callbacks_->connection().dispatcher().createTimer(\n      [this]() -> void { onDrainTimeout(); });\n  drain_timer_->enableTimer(config_.drainTimeout());\n}\n\nvoid ConnectionManagerImpl::ActiveStream::snapScopedRouteConfig() {\n  ASSERT(request_headers_ != nullptr,\n         \"Try to snap scoped route config when there is no request headers.\");\n\n  // NOTE: if a RDS subscription hasn't got a RouteConfiguration back, a Router::NullConfigImpl is\n  // returned, in that case we let it pass.\n  snapped_route_config_ = snapped_scoped_routes_config_->getRouteConfig(*request_headers_);\n  if (snapped_route_config_ == nullptr) {\n    ENVOY_STREAM_LOG(trace, \"can't find SRDS scope.\", *this);\n    // TODO(stevenzzzz): Consider to pass an error message to router filter, so that it can\n    // send back 404 with some more details.\n    snapped_route_config_ = std::make_shared<Router::NullConfigImpl>();\n  }\n}\n\nvoid ConnectionManagerImpl::ActiveStream::refreshCachedRoute() {\n  Router::RouteConstSharedPtr route;\n  if (request_headers_ != nullptr) {\n    if (dynamic_cast<Server::Admin*>(&connection_manager_.config_) == nullptr &&\n        connection_manager_.config_.scopedRouteConfigProvider() != nullptr) {\n      // NOTE: re-select scope as well in case the scope key header has been changed by a filter.\n      snapScopedRouteConfig();\n    }\n    if (snapped_route_config_ != nullptr) {\n      route = snapped_route_config_->route(*request_headers_, stream_id_);\n    }\n  }\n  stream_info_.route_entry_ = route ? route->routeEntry() : nullptr;\n  cached_route_ = std::move(route);\n  if (nullptr == stream_info_.route_entry_) {\n    cached_cluster_info_ = nullptr;\n  } else {\n    Upstream::ThreadLocalCluster* local_cluster =\n        connection_manager_.cluster_manager_.get(stream_info_.route_entry_->clusterName());\n    cached_cluster_info_ = (nullptr == local_cluster) ? nullptr : local_cluster->info();\n  }\n}\n\nvoid ConnectionManagerImpl::ActiveStream::sendLocalReply(\n    bool is_grpc_request, Code code, absl::string_view body,\n    const std::function<void(HeaderMap& headers)>& modify_headers, bool is_head_request,\n    const absl::optional<Grpc::Status::GrpcStatus> grpc_status, absl::string_view details) {\n  ENVOY_STREAM_LOG(debug, \"Sending local reply with details {}\", *this, details);\n  ASSERT(response_headers_ == nullptr);\n  // For early error handling, do a best-effort attempt to create a filter chain\n  // to ensure access logging.\n  if (!state_.created_filter_chain_) {\n    createFilterChain();\n  }\n  stream_info_.setResponseCodeDetails(details);\n  Utility::sendLocalReply(\n      is_grpc_request,\n      [this, modify_headers](HeaderMapPtr&& headers, bool end_stream) -> void {\n        if (modify_headers != nullptr) {\n          modify_headers(*headers);\n        }\n        response_headers_ = std::move(headers);\n        // TODO: Start encoding from the last decoder filter that saw the\n        // request instead.\n        encodeHeaders(nullptr, *response_headers_, end_stream);\n      },\n      [this](Buffer::Instance& data, bool end_stream) -> void {\n        // TODO: Start encoding from the last decoder filter that saw the\n        // request instead.\n        encodeData(nullptr, data, end_stream, FilterIterationStartState::CanStartFromCurrent);\n      },\n      state_.destroyed_, code, body, grpc_status, is_head_request);\n}\n\nvoid ConnectionManagerImpl::ActiveStream::encode100ContinueHeaders(\n    ActiveStreamEncoderFilter* filter, HeaderMap& headers) {\n  resetIdleTimer();\n  ASSERT(connection_manager_.config_.proxy100Continue());\n  // Make sure commonContinue continues encode100ContinueHeaders.\n  has_continue_headers_ = true;\n\n  // Similar to the block in encodeHeaders, run encode100ContinueHeaders on each\n  // filter. This is simpler than that case because 100 continue implies no\n  // end-stream, and because there are normal headers coming there's no need for\n  // complex continuation logic.\n  // 100-continue filter iteration should always start with the next filter if available.\n  std::list<ActiveStreamEncoderFilterPtr>::iterator entry =\n      commonEncodePrefix(filter, false, FilterIterationStartState::AlwaysStartFromNext);\n  for (; entry != encoder_filters_.end(); entry++) {\n    ASSERT(!(state_.filter_call_state_ & FilterCallState::Encode100ContinueHeaders));\n    state_.filter_call_state_ |= FilterCallState::Encode100ContinueHeaders;\n    FilterHeadersStatus status = (*entry)->handle_->encode100ContinueHeaders(headers);\n    state_.filter_call_state_ &= ~FilterCallState::Encode100ContinueHeaders;\n    ENVOY_STREAM_LOG(trace, \"encode 100 continue headers called: filter={} status={}\", *this,\n                     static_cast<const void*>((*entry).get()), static_cast<uint64_t>(status));\n    if (!(*entry)->commonHandleAfter100ContinueHeadersCallback(status)) {\n      return;\n    }\n  }\n\n  // Strip the T-E headers etc. Defer other header additions as well as drain-close logic to the\n  // continuation headers.\n  ConnectionManagerUtility::mutateResponseHeaders(headers, request_headers_.get(), EMPTY_STRING);\n\n  // Count both the 1xx and follow-up response code in stats.\n  chargeStats(headers);\n\n  ENVOY_STREAM_LOG(debug, \"encoding 100 continue headers via codec:\\n{}\", *this, headers);\n\n  // Now actually encode via the codec.\n  response_encoder_->encode100ContinueHeaders(headers);\n}\n\nvoid ConnectionManagerImpl::ActiveStream::encodeHeaders(ActiveStreamEncoderFilter* filter,\n                                                        HeaderMap& headers, bool end_stream) {\n  resetIdleTimer();\n  disarmRequestTimeout();\n\n  // Headers filter iteration should always start with the next filter if available.\n  std::list<ActiveStreamEncoderFilterPtr>::iterator entry =\n      commonEncodePrefix(filter, end_stream, FilterIterationStartState::AlwaysStartFromNext);\n  std::list<ActiveStreamEncoderFilterPtr>::iterator continue_data_entry = encoder_filters_.end();\n\n  for (; entry != encoder_filters_.end(); entry++) {\n    ASSERT(!(state_.filter_call_state_ & FilterCallState::EncodeHeaders));\n    state_.filter_call_state_ |= FilterCallState::EncodeHeaders;\n    (*entry)->end_stream_ =\n        encoding_headers_only_ || (end_stream && continue_data_entry == encoder_filters_.end());\n    FilterHeadersStatus status = (*entry)->handle_->encodeHeaders(headers, (*entry)->end_stream_);\n    if ((*entry)->end_stream_) {\n      (*entry)->handle_->encodeComplete();\n    }\n    state_.filter_call_state_ &= ~FilterCallState::EncodeHeaders;\n    ENVOY_STREAM_LOG(trace, \"encode headers called: filter={} status={}\", *this,\n                     static_cast<const void*>((*entry).get()), static_cast<uint64_t>(status));\n\n    (*entry)->encode_headers_called_ = true;\n    const auto continue_iteration =\n        (*entry)->commonHandleAfterHeadersCallback(status, encoding_headers_only_);\n\n    // If we're encoding a headers only response, then mark the local as complete. This ensures\n    // that we don't attempt to reset the downstream request in doEndStream.\n    if (encoding_headers_only_) {\n      state_.local_complete_ = true;\n    }\n\n    if (!continue_iteration) {\n      return;\n    }\n\n    // Here we handle the case where we have a header only response, but a filter adds a body\n    // to it. We need to not raise end_stream = true to further filters during inline iteration.\n    if (end_stream && buffered_response_data_ && continue_data_entry == encoder_filters_.end()) {\n      continue_data_entry = entry;\n    }\n  }\n\n  // Base headers.\n  connection_manager_.config_.dateProvider().setDateHeader(headers);\n  // Following setReference() is safe because serverName() is constant for the life of the listener.\n  const auto transformation = connection_manager_.config_.serverHeaderTransformation();\n  if (transformation == ConnectionManagerConfig::HttpConnectionManagerProto::OVERWRITE ||\n      (transformation == ConnectionManagerConfig::HttpConnectionManagerProto::APPEND_IF_ABSENT &&\n       headers.Server() == nullptr)) {\n    headers.insertServer().value().setReference(connection_manager_.config_.serverName());\n  }\n  ConnectionManagerUtility::mutateResponseHeaders(headers, request_headers_.get(),\n                                                  connection_manager_.config_.via());\n\n  // See if we want to drain/close the connection. Send the go away frame prior to encoding the\n  // header block.\n  if (connection_manager_.drain_state_ == DrainState::NotDraining &&\n      connection_manager_.drain_close_.drainClose()) {\n\n    // This doesn't really do anything for HTTP/1.1 other then give the connection another boost\n    // of time to race with incoming requests. It mainly just keeps the logic the same between\n    // HTTP/1.1 and HTTP/2.\n    connection_manager_.startDrainSequence();\n    connection_manager_.stats_.named_.downstream_cx_drain_close_.inc();\n    ENVOY_STREAM_LOG(debug, \"drain closing connection\", *this);\n  }\n\n  if (connection_manager_.drain_state_ == DrainState::NotDraining && state_.saw_connection_close_) {\n    ENVOY_STREAM_LOG(debug, \"closing connection due to connection close header\", *this);\n    connection_manager_.drain_state_ = DrainState::Closing;\n  }\n\n  if (connection_manager_.drain_state_ == DrainState::NotDraining &&\n      connection_manager_.overload_disable_keepalive_ref_ == Server::OverloadActionState::Active) {\n    ENVOY_STREAM_LOG(debug, \"disabling keepalive due to envoy overload\", *this);\n    connection_manager_.drain_state_ = DrainState::Closing;\n    connection_manager_.stats_.named_.downstream_cx_overload_disable_keepalive_.inc();\n  }\n\n  // If we are destroying a stream before remote is complete and the connection does not support\n  // multiplexing, we should disconnect since we don't want to wait around for the request to\n  // finish.\n  if (!state_.remote_complete_) {\n    if (connection_manager_.codec_->protocol() != Protocol::Http2) {\n      connection_manager_.drain_state_ = DrainState::Closing;\n    }\n\n    connection_manager_.stats_.named_.downstream_rq_response_before_rq_complete_.inc();\n  }\n\n  if (connection_manager_.drain_state_ != DrainState::NotDraining &&\n      connection_manager_.codec_->protocol() != Protocol::Http2) {\n    // If the connection manager is draining send \"Connection: Close\" on HTTP/1.1 connections.\n    // Do not do this for H2 (which drains via GOAWAY) or Upgrade (as the upgrade\n    // payload is no longer HTTP/1.1)\n    if (!Utility::isUpgrade(headers)) {\n      headers.insertConnection().value().setReference(Headers::get().ConnectionValues.Close);\n    }\n  }\n\n  if (connection_manager_.config_.tracingConfig()) {\n    if (connection_manager_.config_.tracingConfig()->operation_name_ ==\n        Tracing::OperationName::Ingress) {\n      // For ingress (inbound) responses, if the request headers do not include a\n      // decorator operation (override), then pass the decorator's operation name (if defined)\n      // as a response header to enable the client service to use it in its client span.\n      if (decorated_operation_) {\n        headers.insertEnvoyDecoratorOperation().value(*decorated_operation_);\n      }\n    } else if (connection_manager_.config_.tracingConfig()->operation_name_ ==\n               Tracing::OperationName::Egress) {\n      const HeaderEntry* resp_operation_override = headers.EnvoyDecoratorOperation();\n\n      // For Egress (outbound) response, if a decorator operation name has been provided, it\n      // should be used to override the active span's operation.\n      if (resp_operation_override) {\n        if (!resp_operation_override->value().empty() && active_span_) {\n          active_span_->setOperation(resp_operation_override->value().getStringView());\n        }\n        // Remove header so not propagated to service.\n        headers.removeEnvoyDecoratorOperation();\n      }\n    }\n  }\n\n  chargeStats(headers);\n\n  ENVOY_STREAM_LOG(debug, \"encoding headers via codec (end_stream={}):\\n{}\", *this,\n                   encoding_headers_only_ ||\n                       (end_stream && continue_data_entry == encoder_filters_.end()),\n                   headers);\n\n  // Now actually encode via the codec.\n  stream_info_.onFirstDownstreamTxByteSent();\n  response_encoder_->encodeHeaders(\n      headers,\n      encoding_headers_only_ || (end_stream && continue_data_entry == encoder_filters_.end()));\n  if (continue_data_entry != encoder_filters_.end()) {\n    // We use the continueEncoding() code since it will correctly handle not calling\n    // encodeHeaders() again. Fake setting StopSingleIteration since the continueEncoding() code\n    // expects it.\n    ASSERT(buffered_response_data_);\n    (*continue_data_entry)->iteration_state_ =\n        ActiveStreamFilterBase::IterationState::StopSingleIteration;\n    (*continue_data_entry)->continueEncoding();\n  } else {\n    // End encoding if this is a header only response, either due to a filter converting it to one\n    // or due to the upstream returning headers only.\n    maybeEndEncode(encoding_headers_only_ || end_stream);\n  }\n}\n\nvoid ConnectionManagerImpl::ActiveStream::encodeMetadata(ActiveStreamEncoderFilter* filter,\n                                                         MetadataMapPtr&& metadata_map_ptr) {\n  resetIdleTimer();\n\n  std::list<ActiveStreamEncoderFilterPtr>::iterator entry =\n      commonEncodePrefix(filter, false, FilterIterationStartState::CanStartFromCurrent);\n\n  for (; entry != encoder_filters_.end(); entry++) {\n    // If the filter pointed by entry has stopped for all frame type, stores metadata and returns.\n    // If the filter pointed by entry hasn't returned from encodeHeaders, stores newly added\n    // metadata in case encodeHeaders returns StopAllIteration. The latter can happen when headers\n    // callbacks generate new metadata.\n    if (!(*entry)->encode_headers_called_ || (*entry)->stoppedAll()) {\n      (*entry)->getSavedResponseMetadata()->emplace_back(std::move(metadata_map_ptr));\n      return;\n    }\n\n    FilterMetadataStatus status = (*entry)->handle_->encodeMetadata(*metadata_map_ptr);\n    ENVOY_STREAM_LOG(trace, \"encode metadata called: filter={} status={}\", *this,\n                     static_cast<const void*>((*entry).get()), static_cast<uint64_t>(status));\n  }\n  // TODO(soya3129): update stats with metadata.\n\n  // Now encode metadata via the codec.\n  if (!metadata_map_ptr->empty()) {\n    ENVOY_STREAM_LOG(debug, \"encoding metadata via codec:\\n{}\", *this, *metadata_map_ptr);\n    MetadataMapVector metadata_map_vector;\n    metadata_map_vector.emplace_back(std::move(metadata_map_ptr));\n    response_encoder_->encodeMetadata(metadata_map_vector);\n  }\n}\n\nHeaderMap& ConnectionManagerImpl::ActiveStream::addEncodedTrailers() {\n  // Trailers can only be added during the last data frame (i.e. end_stream = true).\n  ASSERT(state_.filter_call_state_ & FilterCallState::LastDataFrame);\n\n  // Trailers can only be added once.\n  ASSERT(!response_trailers_);\n\n  response_trailers_ = std::make_unique<HeaderMapImpl>();\n  return *response_trailers_;\n}\n\nvoid ConnectionManagerImpl::ActiveStream::addEncodedData(ActiveStreamEncoderFilter& filter,\n                                                         Buffer::Instance& data, bool streaming) {\n  if (state_.filter_call_state_ == 0 ||\n      (state_.filter_call_state_ & FilterCallState::EncodeHeaders) ||\n      (state_.filter_call_state_ & FilterCallState::EncodeData) ||\n      ((state_.filter_call_state_ & FilterCallState::EncodeTrailers) && !filter.canIterate())) {\n    // Make sure if this triggers watermarks, the correct action is taken.\n    state_.encoder_filters_streaming_ = streaming;\n    // If no call is happening or we are in the decode headers/data callback, buffer the data.\n    // Inline processing happens in the decodeHeaders() callback if necessary.\n    filter.commonHandleBufferData(data);\n  } else if (state_.filter_call_state_ & FilterCallState::EncodeTrailers) {\n    // In this case we need to inline dispatch the data to further filters. If those filters\n    // choose to buffer/stop iteration that's fine.\n    encodeData(&filter, data, false, FilterIterationStartState::AlwaysStartFromNext);\n  } else {\n    // TODO(mattklein123): Formalize error handling for filters and add tests. Should probably\n    // throw an exception here.\n    NOT_IMPLEMENTED_GCOVR_EXCL_LINE;\n  }\n}\n\nvoid ConnectionManagerImpl::ActiveStream::encodeData(\n    ActiveStreamEncoderFilter* filter, Buffer::Instance& data, bool end_stream,\n    FilterIterationStartState filter_iteration_start_state) {\n  resetIdleTimer();\n\n  // If we previously decided to encode only the headers, do nothing here.\n  if (encoding_headers_only_) {\n    return;\n  }\n\n  // Filter iteration may start at the current filter.\n  std::list<ActiveStreamEncoderFilterPtr>::iterator entry =\n      commonEncodePrefix(filter, end_stream, filter_iteration_start_state);\n  auto trailers_added_entry = encoder_filters_.end();\n\n  const bool trailers_exists_at_start = response_trailers_ != nullptr;\n  for (; entry != encoder_filters_.end(); entry++) {\n    // If the filter pointed by entry has stopped for all frame type, return now.\n    if (handleDataIfStopAll(**entry, data, state_.encoder_filters_streaming_)) {\n      return;\n    }\n    // If end_stream_ is marked for a filter, the data is not for this filter and filters after.\n    // For details, please see the comment in the ActiveStream::decodeData() function.\n    if ((*entry)->end_stream_) {\n      return;\n    }\n    ASSERT(!(state_.filter_call_state_ & FilterCallState::EncodeData));\n\n    // We check the response_trailers_ pointer here in case addEncodedTrailers\n    // is called in encodeData during a previous filter invocation, at which point we communicate to\n    // the current and future filters that the stream has not yet ended.\n    state_.filter_call_state_ |= FilterCallState::EncodeData;\n    if (end_stream) {\n      state_.filter_call_state_ |= FilterCallState::LastDataFrame;\n    }\n\n    recordLatestDataFilter(entry, state_.latest_data_encoding_filter_, encoder_filters_);\n\n    (*entry)->end_stream_ = end_stream && !response_trailers_;\n    FilterDataStatus status = (*entry)->handle_->encodeData(data, (*entry)->end_stream_);\n    if ((*entry)->end_stream_) {\n      (*entry)->handle_->encodeComplete();\n    }\n    state_.filter_call_state_ &= ~FilterCallState::EncodeData;\n    if (end_stream) {\n      state_.filter_call_state_ &= ~FilterCallState::LastDataFrame;\n    }\n    ENVOY_STREAM_LOG(trace, \"encode data called: filter={} status={}\", *this,\n                     static_cast<const void*>((*entry).get()), static_cast<uint64_t>(status));\n\n    if (!trailers_exists_at_start && response_trailers_ &&\n        trailers_added_entry == encoder_filters_.end()) {\n      trailers_added_entry = entry;\n    }\n\n    if (!(*entry)->commonHandleAfterDataCallback(status, data, state_.encoder_filters_streaming_)) {\n      return;\n    }\n  }\n\n  ENVOY_STREAM_LOG(trace, \"encoding data via codec (size={} end_stream={})\", *this, data.length(),\n                   end_stream);\n\n  stream_info_.addBytesSent(data.length());\n\n  // If trailers were adding during encodeData we need to trigger decodeTrailers in order\n  // to allow filters to process the trailers.\n  if (trailers_added_entry != encoder_filters_.end()) {\n    response_encoder_->encodeData(data, false);\n    encodeTrailers(trailers_added_entry->get(), *response_trailers_);\n  } else {\n    response_encoder_->encodeData(data, end_stream);\n    maybeEndEncode(end_stream);\n  }\n}\n\nvoid ConnectionManagerImpl::ActiveStream::encodeTrailers(ActiveStreamEncoderFilter* filter,\n                                                         HeaderMap& trailers) {\n  resetIdleTimer();\n\n  // If we previously decided to encode only the headers, do nothing here.\n  if (encoding_headers_only_) {\n    return;\n  }\n\n  // Filter iteration may start at the current filter.\n  std::list<ActiveStreamEncoderFilterPtr>::iterator entry =\n      commonEncodePrefix(filter, true, FilterIterationStartState::CanStartFromCurrent);\n  for (; entry != encoder_filters_.end(); entry++) {\n    // If the filter pointed by entry has stopped for all frame type, return now.\n    if ((*entry)->stoppedAll()) {\n      return;\n    }\n    ASSERT(!(state_.filter_call_state_ & FilterCallState::EncodeTrailers));\n    state_.filter_call_state_ |= FilterCallState::EncodeTrailers;\n    FilterTrailersStatus status = (*entry)->handle_->encodeTrailers(trailers);\n    (*entry)->handle_->encodeComplete();\n    (*entry)->end_stream_ = true;\n    state_.filter_call_state_ &= ~FilterCallState::EncodeTrailers;\n    ENVOY_STREAM_LOG(trace, \"encode trailers called: filter={} status={}\", *this,\n                     static_cast<const void*>((*entry).get()), static_cast<uint64_t>(status));\n    if (!(*entry)->commonHandleAfterTrailersCallback(status)) {\n      return;\n    }\n  }\n\n  ENVOY_STREAM_LOG(debug, \"encoding trailers via codec:\\n{}\", *this, trailers);\n\n  response_encoder_->encodeTrailers(trailers);\n  maybeEndEncode(true);\n}\n\nvoid ConnectionManagerImpl::ActiveStream::maybeEndEncode(bool end_stream) {\n  if (end_stream) {\n    ASSERT(!state_.codec_saw_local_complete_);\n    state_.codec_saw_local_complete_ = true;\n    stream_info_.onLastDownstreamTxByteSent();\n    request_response_timespan_->complete();\n    connection_manager_.doEndStream(*this);\n  }\n}\n\nbool ConnectionManagerImpl::ActiveStream::processNewlyAddedMetadata() {\n  if (request_metadata_map_vector_ == nullptr) {\n    return false;\n  }\n  for (const auto& metadata_map : *getRequestMetadataMapVector()) {\n    decodeMetadata(nullptr, *metadata_map);\n  }\n  getRequestMetadataMapVector()->clear();\n  return true;\n}\n\nbool ConnectionManagerImpl::ActiveStream::handleDataIfStopAll(ActiveStreamFilterBase& filter,\n                                                              Buffer::Instance& data,\n                                                              bool& filter_streaming) {\n  if (filter.stoppedAll()) {\n    ASSERT(!filter.canIterate());\n    filter_streaming =\n        filter.iteration_state_ == ActiveStreamFilterBase::IterationState::StopAllWatermark;\n    filter.commonHandleBufferData(data);\n    return true;\n  }\n  return false;\n}\n\nvoid ConnectionManagerImpl::ActiveStream::onResetStream(StreamResetReason, absl::string_view) {\n  // NOTE: This function gets called in all of the following cases:\n  //       1) We TX an app level reset\n  //       2) The codec TX a codec level reset\n  //       3) The codec RX a reset\n  //       If we need to differentiate we need to do it inside the codec. Can start with this.\n  ENVOY_STREAM_LOG(debug, \"stream reset\", *this);\n  connection_manager_.stats_.named_.downstream_rq_rx_reset_.inc();\n  connection_manager_.doDeferredStreamDestroy(*this);\n}\n\nvoid ConnectionManagerImpl::ActiveStream::onAboveWriteBufferHighWatermark() {\n  ENVOY_STREAM_LOG(debug, \"Disabling upstream stream due to downstream stream watermark.\", *this);\n  callHighWatermarkCallbacks();\n}\n\nvoid ConnectionManagerImpl::ActiveStream::onBelowWriteBufferLowWatermark() {\n  ENVOY_STREAM_LOG(debug, \"Enabling upstream stream due to downstream stream watermark.\", *this);\n  callLowWatermarkCallbacks();\n}\n\nTracing::OperationName ConnectionManagerImpl::ActiveStream::operationName() const {\n  return connection_manager_.config_.tracingConfig()->operation_name_;\n}\n\nconst std::vector<Http::LowerCaseString>&\nConnectionManagerImpl::ActiveStream::requestHeadersForTags() const {\n  return connection_manager_.config_.tracingConfig()->request_headers_for_tags_;\n}\n\nbool ConnectionManagerImpl::ActiveStream::verbose() const {\n  return connection_manager_.config_.tracingConfig()->verbose_;\n}\n\nuint32_t ConnectionManagerImpl::ActiveStream::maxPathTagLength() const {\n  return connection_manager_.config_.tracingConfig()->max_path_tag_length_;\n}\n\nvoid ConnectionManagerImpl::ActiveStream::callHighWatermarkCallbacks() {\n  ++high_watermark_count_;\n  for (auto watermark_callbacks : watermark_callbacks_) {\n    watermark_callbacks->onAboveWriteBufferHighWatermark();\n  }\n}\n\nvoid ConnectionManagerImpl::ActiveStream::callLowWatermarkCallbacks() {\n  ASSERT(high_watermark_count_ > 0);\n  --high_watermark_count_;\n  for (auto watermark_callbacks : watermark_callbacks_) {\n    watermark_callbacks->onBelowWriteBufferLowWatermark();\n  }\n}\n\nvoid ConnectionManagerImpl::ActiveStream::setBufferLimit(uint32_t new_limit) {\n  ENVOY_STREAM_LOG(debug, \"setting buffer limit to {}\", *this, new_limit);\n  buffer_limit_ = new_limit;\n  if (buffered_request_data_) {\n    buffered_request_data_->setWatermarks(buffer_limit_);\n  }\n  if (buffered_response_data_) {\n    buffered_response_data_->setWatermarks(buffer_limit_);\n  }\n}\n\nbool ConnectionManagerImpl::ActiveStream::createFilterChain() {\n  if (state_.created_filter_chain_) {\n    return false;\n  }\n  bool upgrade_rejected = false;\n  auto upgrade = request_headers_ ? request_headers_->Upgrade() : nullptr;\n  state_.created_filter_chain_ = true;\n  if (upgrade != nullptr) {\n    const Router::RouteEntry::UpgradeMap* upgrade_map = nullptr;\n\n    // We must check if the 'cached_route_' optional is populated since this function can be called\n    // early via sendLocalReply(), before the cached route is populated.\n    if (hasCachedRoute() && cached_route_.value()->routeEntry()) {\n      upgrade_map = &cached_route_.value()->routeEntry()->upgradeMap();\n    }\n\n    if (connection_manager_.config_.filterFactory().createUpgradeFilterChain(\n            upgrade->value().getStringView(), upgrade_map, *this)) {\n      state_.successful_upgrade_ = true;\n      connection_manager_.stats_.named_.downstream_cx_upgrades_total_.inc();\n      connection_manager_.stats_.named_.downstream_cx_upgrades_active_.inc();\n      return true;\n    } else {\n      upgrade_rejected = true;\n      // Fall through to the default filter chain. The function calling this\n      // will send a local reply indicating that the upgrade failed.\n    }\n  }\n\n  connection_manager_.config_.filterFactory().createFilterChain(*this);\n  return !upgrade_rejected;\n}\n\nvoid ConnectionManagerImpl::ActiveStreamFilterBase::commonContinue() {\n  // TODO(mattklein123): Raise an error if this is called during a callback.\n  if (!canContinue()) {\n    ENVOY_STREAM_LOG(trace, \"cannot continue filter chain: filter={}\", parent_,\n                     static_cast<const void*>(this));\n    return;\n  }\n\n  ENVOY_STREAM_LOG(trace, \"continuing filter chain: filter={}\", parent_,\n                   static_cast<const void*>(this));\n  ASSERT(!canIterate());\n  // If iteration has stopped for all frame types, set iterate_from_current_filter_ to true so the\n  // filter iteration starts with the current filter instead of the next one.\n  if (stoppedAll()) {\n    iterate_from_current_filter_ = true;\n  }\n  allowIteration();\n\n  // Only resume with do100ContinueHeaders() if we've actually seen a 100-Continue.\n  if (parent_.has_continue_headers_ && !continue_headers_continued_) {\n    continue_headers_continued_ = true;\n    do100ContinueHeaders();\n    // If the response headers have not yet come in, don't continue on with\n    // headers and body. doHeaders expects request headers to exist.\n    if (!parent_.response_headers_.get()) {\n      return;\n    }\n  }\n\n  // Make sure that we handle the zero byte data frame case. We make no effort to optimize this\n  // case in terms of merging it into a header only request/response. This could be done in the\n  // future.\n  if (!headers_continued_) {\n    headers_continued_ = true;\n    doHeaders(complete() && !bufferedData() && !trailers());\n  }\n\n  doMetadata();\n\n  if (bufferedData()) {\n    doData(complete() && !trailers());\n  }\n\n  if (trailers()) {\n    doTrailers();\n  }\n\n  iterate_from_current_filter_ = false;\n}\n\nbool ConnectionManagerImpl::ActiveStreamFilterBase::commonHandleAfter100ContinueHeadersCallback(\n    FilterHeadersStatus status) {\n  ASSERT(parent_.has_continue_headers_);\n  ASSERT(!continue_headers_continued_);\n  ASSERT(canIterate());\n\n  if (status == FilterHeadersStatus::StopIteration) {\n    iteration_state_ = IterationState::StopSingleIteration;\n    return false;\n  } else {\n    ASSERT(status == FilterHeadersStatus::Continue);\n    continue_headers_continued_ = true;\n    return true;\n  }\n}\n\nbool ConnectionManagerImpl::ActiveStreamFilterBase::commonHandleAfterHeadersCallback(\n    FilterHeadersStatus status, bool& headers_only) {\n  ASSERT(!headers_continued_);\n  ASSERT(canIterate());\n\n  if (status == FilterHeadersStatus::StopIteration) {\n    iteration_state_ = IterationState::StopSingleIteration;\n  } else if (status == FilterHeadersStatus::StopAllIterationAndBuffer) {\n    iteration_state_ = IterationState::StopAllBuffer;\n  } else if (status == FilterHeadersStatus::StopAllIterationAndWatermark) {\n    iteration_state_ = IterationState::StopAllWatermark;\n  } else if (status == FilterHeadersStatus::ContinueAndEndStream) {\n    // Set headers_only to true so we know to end early if necessary,\n    // but continue filter iteration so we actually write the headers/run the cleanup code.\n    headers_only = true;\n    ENVOY_STREAM_LOG(debug, \"converting to headers only\", parent_);\n  } else {\n    ASSERT(status == FilterHeadersStatus::Continue);\n    headers_continued_ = true;\n  }\n\n  handleMetadataAfterHeadersCallback();\n\n  if (stoppedAll() || status == FilterHeadersStatus::StopIteration) {\n    return false;\n  } else {\n    return true;\n  }\n}\n\nvoid ConnectionManagerImpl::ActiveStreamFilterBase::commonHandleBufferData(\n    Buffer::Instance& provided_data) {\n\n  // The way we do buffering is a little complicated which is why we have this common function\n  // which is used for both encoding and decoding. When data first comes into our filter pipeline,\n  // we send it through. Any filter can choose to stop iteration and buffer or not. If we then\n  // continue iteration in the future, we use the buffered data. A future filter can stop and\n  // buffer again. In this case, since we are already operating on buffered data, we don't\n  // rebuffer, because we assume the filter has modified the buffer as it wishes in place.\n  if (bufferedData().get() != &provided_data) {\n    if (!bufferedData()) {\n      bufferedData() = createBuffer();\n    }\n    bufferedData()->move(provided_data);\n  }\n}\n\nbool ConnectionManagerImpl::ActiveStreamFilterBase::commonHandleAfterDataCallback(\n    FilterDataStatus status, Buffer::Instance& provided_data, bool& buffer_was_streaming) {\n\n  if (status == FilterDataStatus::Continue) {\n    if (iteration_state_ == IterationState::StopSingleIteration) {\n      commonHandleBufferData(provided_data);\n      commonContinue();\n      return false;\n    } else {\n      ASSERT(headers_continued_);\n    }\n  } else {\n    iteration_state_ = IterationState::StopSingleIteration;\n    if (status == FilterDataStatus::StopIterationAndBuffer ||\n        status == FilterDataStatus::StopIterationAndWatermark) {\n      buffer_was_streaming = status == FilterDataStatus::StopIterationAndWatermark;\n      commonHandleBufferData(provided_data);\n    } else if (complete() && !trailers() && !bufferedData()) {\n      // If this filter is doing StopIterationNoBuffer and this stream is terminated with a zero\n      // byte data frame, we need to create an empty buffer to make sure that when commonContinue\n      // is called, the pipeline resumes with an empty data frame with end_stream = true\n      ASSERT(end_stream_);\n      bufferedData() = createBuffer();\n    }\n\n    return false;\n  }\n\n  return true;\n}\n\nbool ConnectionManagerImpl::ActiveStreamFilterBase::commonHandleAfterTrailersCallback(\n    FilterTrailersStatus status) {\n\n  if (status == FilterTrailersStatus::Continue) {\n    if (iteration_state_ == IterationState::StopSingleIteration) {\n      commonContinue();\n      return false;\n    } else {\n      ASSERT(headers_continued_);\n    }\n  } else {\n    return false;\n  }\n\n  return true;\n}\n\nconst Network::Connection* ConnectionManagerImpl::ActiveStreamFilterBase::connection() {\n  return parent_.connection();\n}\n\nEvent::Dispatcher& ConnectionManagerImpl::ActiveStreamFilterBase::dispatcher() {\n  return parent_.connection_manager_.read_callbacks_->connection().dispatcher();\n}\n\nStreamInfo::StreamInfo& ConnectionManagerImpl::ActiveStreamFilterBase::streamInfo() {\n  return parent_.stream_info_;\n}\n\nTracing::Span& ConnectionManagerImpl::ActiveStreamFilterBase::activeSpan() {\n  if (parent_.active_span_) {\n    return *parent_.active_span_;\n  } else {\n    return Tracing::NullSpan::instance();\n  }\n}\n\nTracing::Config& ConnectionManagerImpl::ActiveStreamFilterBase::tracingConfig() { return parent_; }\n\nUpstream::ClusterInfoConstSharedPtr ConnectionManagerImpl::ActiveStreamFilterBase::clusterInfo() {\n  // NOTE: Refreshing route caches clusterInfo as well.\n  if (!parent_.cached_route_.has_value()) {\n    parent_.refreshCachedRoute();\n  }\n\n  return parent_.cached_cluster_info_.value();\n}\n\nRouter::RouteConstSharedPtr ConnectionManagerImpl::ActiveStreamFilterBase::route() {\n  if (!parent_.cached_route_.has_value()) {\n    parent_.refreshCachedRoute();\n  }\n\n  return parent_.cached_route_.value();\n}\n\nvoid ConnectionManagerImpl::ActiveStreamFilterBase::clearRouteCache() {\n  parent_.cached_route_ = absl::optional<Router::RouteConstSharedPtr>();\n  parent_.cached_cluster_info_ = absl::optional<Upstream::ClusterInfoConstSharedPtr>();\n}\n\nBuffer::WatermarkBufferPtr ConnectionManagerImpl::ActiveStreamDecoderFilter::createBuffer() {\n  auto buffer =\n      std::make_unique<Buffer::WatermarkBuffer>([this]() -> void { this->requestDataDrained(); },\n                                                [this]() -> void { this->requestDataTooLarge(); });\n  buffer->setWatermarks(parent_.buffer_limit_);\n  return buffer;\n}\n\nvoid ConnectionManagerImpl::ActiveStreamDecoderFilter::handleMetadataAfterHeadersCallback() {\n  // If we drain accumulated metadata, the iteration must start with the current filter.\n  const bool saved_state = iterate_from_current_filter_;\n  iterate_from_current_filter_ = true;\n  // If decodeHeaders() returns StopAllIteration, we should skip draining metadata, and wait\n  // for doMetadata() to drain the metadata after iteration continues.\n  if (!stoppedAll() && saved_request_metadata_ != nullptr && !getSavedRequestMetadata()->empty()) {\n    drainSavedRequestMetadata();\n  }\n  // Restores the original value of iterate_from_current_filter_.\n  iterate_from_current_filter_ = saved_state;\n}\n\nHeaderMap& ConnectionManagerImpl::ActiveStreamDecoderFilter::addDecodedTrailers() {\n  return parent_.addDecodedTrailers();\n}\n\nvoid ConnectionManagerImpl::ActiveStreamDecoderFilter::addDecodedData(Buffer::Instance& data,\n                                                                      bool streaming) {\n  parent_.addDecodedData(*this, data, streaming);\n}\n\nMetadataMapVector& ConnectionManagerImpl::ActiveStreamDecoderFilter::addDecodedMetadata() {\n  return parent_.addDecodedMetadata();\n}\n\nvoid ConnectionManagerImpl::ActiveStreamDecoderFilter::injectDecodedDataToFilterChain(\n    Buffer::Instance& data, bool end_stream) {\n  parent_.decodeData(this, data, end_stream,\n                     ActiveStream::FilterIterationStartState::CanStartFromCurrent);\n}\n\nvoid ConnectionManagerImpl::ActiveStreamDecoderFilter::continueDecoding() { commonContinue(); }\n\nvoid ConnectionManagerImpl::ActiveStreamDecoderFilter::encode100ContinueHeaders(\n    HeaderMapPtr&& headers) {\n  // If Envoy is not configured to proxy 100-Continue responses, swallow the 100 Continue\n  // here. This avoids the potential situation where Envoy strips Expect: 100-Continue and sends a\n  // 100-Continue, then proxies a duplicate 100 Continue from upstream.\n  if (parent_.connection_manager_.config_.proxy100Continue()) {\n    parent_.continue_headers_ = std::move(headers);\n    parent_.encode100ContinueHeaders(nullptr, *parent_.continue_headers_);\n  }\n}\n\nvoid ConnectionManagerImpl::ActiveStreamDecoderFilter::encodeHeaders(HeaderMapPtr&& headers,\n                                                                     bool end_stream) {\n  parent_.response_headers_ = std::move(headers);\n  parent_.encodeHeaders(nullptr, *parent_.response_headers_, end_stream);\n}\n\nvoid ConnectionManagerImpl::ActiveStreamDecoderFilter::encodeData(Buffer::Instance& data,\n                                                                  bool end_stream) {\n  parent_.encodeData(nullptr, data, end_stream,\n                     ActiveStream::FilterIterationStartState::CanStartFromCurrent);\n}\n\nvoid ConnectionManagerImpl::ActiveStreamDecoderFilter::encodeTrailers(HeaderMapPtr&& trailers) {\n  parent_.response_trailers_ = std::move(trailers);\n  parent_.encodeTrailers(nullptr, *parent_.response_trailers_);\n}\n\nvoid ConnectionManagerImpl::ActiveStreamDecoderFilter::encodeMetadata(\n    MetadataMapPtr&& metadata_map_ptr) {\n  parent_.encodeMetadata(nullptr, std::move(metadata_map_ptr));\n}\n\nvoid ConnectionManagerImpl::ActiveStreamDecoderFilter::\n    onDecoderFilterAboveWriteBufferHighWatermark() {\n  ENVOY_STREAM_LOG(debug, \"Read-disabling downstream stream due to filter callbacks.\", parent_);\n  parent_.response_encoder_->getStream().readDisable(true);\n  parent_.connection_manager_.stats_.named_.downstream_flow_control_paused_reading_total_.inc();\n}\n\nvoid ConnectionManagerImpl::ActiveStreamDecoderFilter::requestDataTooLarge() {\n  ENVOY_STREAM_LOG(debug, \"request data too large watermark exceeded\", parent_);\n  if (parent_.state_.decoder_filters_streaming_) {\n    onDecoderFilterAboveWriteBufferHighWatermark();\n  } else {\n    parent_.connection_manager_.stats_.named_.downstream_rq_too_large_.inc();\n    sendLocalReply(Code::PayloadTooLarge, CodeUtility::toString(Code::PayloadTooLarge), nullptr,\n                   absl::nullopt, StreamInfo::ResponseCodeDetails::get().RequestPayloadTooLarge);\n  }\n}\n\nvoid ConnectionManagerImpl::ActiveStreamDecoderFilter::requestDataDrained() {\n  // If this is called it means the call to requestDataTooLarge() was a\n  // streaming call, or a 413 would have been sent.\n  onDecoderFilterBelowWriteBufferLowWatermark();\n}\n\nvoid ConnectionManagerImpl::ActiveStreamDecoderFilter::\n    onDecoderFilterBelowWriteBufferLowWatermark() {\n  ENVOY_STREAM_LOG(debug, \"Read-enabling downstream stream due to filter callbacks.\", parent_);\n  parent_.response_encoder_->getStream().readDisable(false);\n  parent_.connection_manager_.stats_.named_.downstream_flow_control_resumed_reading_total_.inc();\n}\n\nvoid ConnectionManagerImpl::ActiveStreamDecoderFilter::addDownstreamWatermarkCallbacks(\n    DownstreamWatermarkCallbacks& watermark_callbacks) {\n  // This is called exactly once per upstream-stream, by the router filter. Therefore, we\n  // expect the same callbacks to not be registered twice.\n  ASSERT(std::find(parent_.watermark_callbacks_.begin(), parent_.watermark_callbacks_.end(),\n                   &watermark_callbacks) == parent_.watermark_callbacks_.end());\n  parent_.watermark_callbacks_.emplace(parent_.watermark_callbacks_.end(), &watermark_callbacks);\n  for (uint32_t i = 0; i < parent_.high_watermark_count_; ++i) {\n    watermark_callbacks.onAboveWriteBufferHighWatermark();\n  }\n}\nvoid ConnectionManagerImpl::ActiveStreamDecoderFilter::removeDownstreamWatermarkCallbacks(\n    DownstreamWatermarkCallbacks& watermark_callbacks) {\n  ASSERT(std::find(parent_.watermark_callbacks_.begin(), parent_.watermark_callbacks_.end(),\n                   &watermark_callbacks) != parent_.watermark_callbacks_.end());\n  parent_.watermark_callbacks_.remove(&watermark_callbacks);\n}\n\nbool ConnectionManagerImpl::ActiveStreamDecoderFilter::recreateStream() {\n  // Because the filter's and the HCM view of if the stream has a body and if\n  // the stream is complete may differ, re-check bytesReceived() to make sure\n  // there was no body from the HCM's point of view.\n  if (!complete() || parent_.stream_info_.bytesReceived() != 0) {\n    return false;\n  }\n  // n.b. we do not currently change the codecs to point at the new stream\n  // decoder because the decoder callbacks are complete. It would be good to\n  // null out that pointer but should not be necessary.\n  HeaderMapPtr request_headers(std::move(parent_.request_headers_));\n  StreamEncoder* response_encoder = parent_.response_encoder_;\n  parent_.response_encoder_ = nullptr;\n  // This functionally deletes the stream (via deferred delete) so do not\n  // reference anything beyond this point.\n  parent_.connection_manager_.doEndStream(this->parent_);\n\n  StreamDecoder& new_stream = parent_.connection_manager_.newStream(*response_encoder, true);\n  new_stream.decodeHeaders(std::move(request_headers), true);\n  return true;\n}\n\nBuffer::WatermarkBufferPtr ConnectionManagerImpl::ActiveStreamEncoderFilter::createBuffer() {\n  auto buffer = new Buffer::WatermarkBuffer([this]() -> void { this->responseDataDrained(); },\n                                            [this]() -> void { this->responseDataTooLarge(); });\n  buffer->setWatermarks(parent_.buffer_limit_);\n  return Buffer::WatermarkBufferPtr{buffer};\n}\n\nvoid ConnectionManagerImpl::ActiveStreamEncoderFilter::handleMetadataAfterHeadersCallback() {\n  // If we drain accumulated metadata, the iteration must start with the current filter.\n  const bool saved_state = iterate_from_current_filter_;\n  iterate_from_current_filter_ = true;\n  // If encodeHeaders() returns StopAllIteration, we should skip draining metadata, and wait\n  // for doMetadata() to drain the metadata after iteration continues.\n  if (!stoppedAll() && saved_response_metadata_ != nullptr &&\n      !getSavedResponseMetadata()->empty()) {\n    drainSavedResponseMetadata();\n  }\n  // Restores the original value of iterate_from_current_filter_.\n  iterate_from_current_filter_ = saved_state;\n}\nvoid ConnectionManagerImpl::ActiveStreamEncoderFilter::addEncodedData(Buffer::Instance& data,\n                                                                      bool streaming) {\n  return parent_.addEncodedData(*this, data, streaming);\n}\n\nvoid ConnectionManagerImpl::ActiveStreamEncoderFilter::injectEncodedDataToFilterChain(\n    Buffer::Instance& data, bool end_stream) {\n  parent_.encodeData(this, data, end_stream,\n                     ActiveStream::FilterIterationStartState::CanStartFromCurrent);\n}\n\nHeaderMap& ConnectionManagerImpl::ActiveStreamEncoderFilter::addEncodedTrailers() {\n  return parent_.addEncodedTrailers();\n}\n\nvoid ConnectionManagerImpl::ActiveStreamEncoderFilter::addEncodedMetadata(\n    MetadataMapPtr&& metadata_map_ptr) {\n  return parent_.encodeMetadata(this, std::move(metadata_map_ptr));\n}\n\nvoid ConnectionManagerImpl::ActiveStreamEncoderFilter::\n    onEncoderFilterAboveWriteBufferHighWatermark() {\n  ENVOY_STREAM_LOG(debug, \"Disabling upstream stream due to filter callbacks.\", parent_);\n  parent_.callHighWatermarkCallbacks();\n}\n\nvoid ConnectionManagerImpl::ActiveStreamEncoderFilter::\n    onEncoderFilterBelowWriteBufferLowWatermark() {\n  ENVOY_STREAM_LOG(debug, \"Enabling upstream stream due to filter callbacks.\", parent_);\n  parent_.callLowWatermarkCallbacks();\n}\n\nvoid ConnectionManagerImpl::ActiveStreamEncoderFilter::continueEncoding() { commonContinue(); }\n\nvoid ConnectionManagerImpl::ActiveStreamEncoderFilter::responseDataTooLarge() {\n  if (parent_.state_.encoder_filters_streaming_) {\n    onEncoderFilterAboveWriteBufferHighWatermark();\n  } else {\n    parent_.connection_manager_.stats_.named_.rs_too_large_.inc();\n\n    // If headers have not been sent to the user, send a 500.\n    if (!headers_continued_) {\n      // Make sure we won't end up with nested watermark calls from the body buffer.\n      parent_.state_.encoder_filters_streaming_ = true;\n      allowIteration();\n\n      parent_.stream_info_.setResponseCodeDetails(\n          StreamInfo::ResponseCodeDetails::get().RequestHeadersTooLarge);\n      Http::Utility::sendLocalReply(\n          Grpc::Common::hasGrpcContentType(*parent_.request_headers_),\n          [&](HeaderMapPtr&& response_headers, bool end_stream) -> void {\n            parent_.chargeStats(*response_headers);\n            parent_.response_headers_ = std::move(response_headers);\n            parent_.response_encoder_->encodeHeaders(*parent_.response_headers_, end_stream);\n            parent_.state_.local_complete_ = end_stream;\n          },\n          [&](Buffer::Instance& data, bool end_stream) -> void {\n            parent_.response_encoder_->encodeData(data, end_stream);\n            parent_.state_.local_complete_ = end_stream;\n          },\n          parent_.state_.destroyed_, Http::Code::InternalServerError,\n          CodeUtility::toString(Http::Code::InternalServerError), absl::nullopt,\n          parent_.is_head_request_);\n      parent_.maybeEndEncode(parent_.state_.local_complete_);\n    } else {\n      resetStream();\n    }\n  }\n}\n\nvoid ConnectionManagerImpl::ActiveStreamEncoderFilter::responseDataDrained() {\n  onEncoderFilterBelowWriteBufferLowWatermark();\n}\n\nvoid ConnectionManagerImpl::ActiveStreamFilterBase::resetStream() {\n  parent_.connection_manager_.stats_.named_.downstream_rq_tx_reset_.inc();\n  parent_.connection_manager_.doEndStream(this->parent_);\n}\n\nuint64_t ConnectionManagerImpl::ActiveStreamFilterBase::streamId() { return parent_.stream_id_; }\n\n} // namespace Http\n} // namespace Envoy\n", "#include \"common/http/header_map_impl.h\"\n\n#include <cstdint>\n#include <list>\n#include <memory>\n#include <string>\n\n#include \"common/common/assert.h\"\n#include \"common/common/dump_state_utils.h\"\n#include \"common/common/empty_string.h\"\n#include \"common/common/utility.h\"\n#include \"common/singleton/const_singleton.h\"\n\n#include \"absl/strings/match.h\"\n\nnamespace Envoy {\nnamespace Http {\n\nnamespace {\nconstexpr size_t MinDynamicCapacity{32};\n// This includes the NULL (StringUtil::itoa technically only needs 21).\nconstexpr size_t MaxIntegerLength{32};\n\nuint64_t newCapacity(uint32_t existing_capacity, uint32_t size_to_append) {\n  return (static_cast<uint64_t>(existing_capacity) + size_to_append) * 2;\n}\n\nvoid validateCapacity(uint64_t new_capacity) {\n  // If the resizing will cause buffer overflow due to hitting uint32_t::max, an OOM is likely\n  // imminent. Fast-fail rather than allow a buffer overflow attack (issue #1421)\n  RELEASE_ASSERT(new_capacity <= std::numeric_limits<uint32_t>::max(),\n                 \"Trying to allocate overly large headers.\");\n  ASSERT(new_capacity >= MinDynamicCapacity);\n}\n\n} // namespace\n\nHeaderString::HeaderString() : type_(Type::Inline) {\n  buffer_.dynamic_ = inline_buffer_;\n  clear();\n  static_assert(sizeof(inline_buffer_) >= MaxIntegerLength, \"\");\n  static_assert(MinDynamicCapacity >= MaxIntegerLength, \"\");\n  ASSERT(valid());\n}\n\nHeaderString::HeaderString(const LowerCaseString& ref_value) : type_(Type::Reference) {\n  buffer_.ref_ = ref_value.get().c_str();\n  string_length_ = ref_value.get().size();\n  ASSERT(valid());\n}\n\nHeaderString::HeaderString(const std::string& ref_value) : type_(Type::Reference) {\n  buffer_.ref_ = ref_value.c_str();\n  string_length_ = ref_value.size();\n  ASSERT(valid());\n}\n\nHeaderString::HeaderString(HeaderString&& move_value) noexcept {\n  type_ = move_value.type_;\n  string_length_ = move_value.string_length_;\n  switch (move_value.type_) {\n  case Type::Reference: {\n    buffer_.ref_ = move_value.buffer_.ref_;\n    break;\n  }\n  case Type::Dynamic: {\n    // When we move a dynamic header, we switch the moved header back to its default state (inline).\n    buffer_.dynamic_ = move_value.buffer_.dynamic_;\n    dynamic_capacity_ = move_value.dynamic_capacity_;\n    move_value.type_ = Type::Inline;\n    move_value.buffer_.dynamic_ = move_value.inline_buffer_;\n    move_value.clear();\n    break;\n  }\n  case Type::Inline: {\n    buffer_.dynamic_ = inline_buffer_;\n    memcpy(inline_buffer_, move_value.inline_buffer_, string_length_);\n    move_value.string_length_ = 0;\n    break;\n  }\n  }\n  ASSERT(valid());\n}\n\nHeaderString::~HeaderString() { freeDynamic(); }\n\nvoid HeaderString::freeDynamic() {\n  if (type_ == Type::Dynamic) {\n    free(buffer_.dynamic_);\n  }\n}\n\nbool HeaderString::valid() const { return validHeaderString(getStringView()); }\n\nvoid HeaderString::append(const char* data, uint32_t size) {\n  switch (type_) {\n  case Type::Reference: {\n    // Rather than be too clever and optimize this uncommon case, we dynamically\n    // allocate and copy.\n    type_ = Type::Dynamic;\n    const uint64_t new_capacity = newCapacity(string_length_, size);\n    if (new_capacity > MinDynamicCapacity) {\n      validateCapacity(new_capacity);\n      dynamic_capacity_ = new_capacity;\n    } else {\n      dynamic_capacity_ = MinDynamicCapacity;\n    }\n    char* buf = static_cast<char*>(malloc(dynamic_capacity_));\n    RELEASE_ASSERT(buf != nullptr, \"\");\n    memcpy(buf, buffer_.ref_, string_length_);\n    buffer_.dynamic_ = buf;\n    break;\n  }\n\n  case Type::Inline: {\n    const uint64_t new_capacity = static_cast<uint64_t>(size) + string_length_;\n    if (new_capacity <= sizeof(inline_buffer_)) {\n      // Already inline and the new value fits in inline storage.\n      break;\n    }\n\n    FALLTHRU;\n  }\n\n  case Type::Dynamic: {\n    // We can get here either because we didn't fit in inline or we are already dynamic.\n    if (type_ == Type::Inline) {\n      const uint64_t new_capacity = newCapacity(string_length_, size);\n      validateCapacity(new_capacity);\n      buffer_.dynamic_ = static_cast<char*>(malloc(new_capacity));\n      RELEASE_ASSERT(buffer_.dynamic_ != nullptr, \"\");\n      memcpy(buffer_.dynamic_, inline_buffer_, string_length_);\n      dynamic_capacity_ = new_capacity;\n      type_ = Type::Dynamic;\n    } else {\n      if (size + string_length_ > dynamic_capacity_) {\n        const uint64_t new_capacity = newCapacity(string_length_, size);\n        validateCapacity(new_capacity);\n\n        // Need to reallocate.\n        dynamic_capacity_ = new_capacity;\n        buffer_.dynamic_ = static_cast<char*>(realloc(buffer_.dynamic_, dynamic_capacity_));\n        RELEASE_ASSERT(buffer_.dynamic_ != nullptr, \"\");\n      }\n    }\n  }\n  }\n  ASSERT(validHeaderString(absl::string_view(data, size)));\n  memcpy(buffer_.dynamic_ + string_length_, data, size);\n  string_length_ += size;\n}\n\nvoid HeaderString::clear() {\n  switch (type_) {\n  case Type::Reference: {\n    break;\n  }\n  case Type::Inline: {\n    FALLTHRU;\n  }\n  case Type::Dynamic: {\n    string_length_ = 0;\n  }\n  }\n}\n\nvoid HeaderString::setCopy(const char* data, uint32_t size) {\n  switch (type_) {\n  case Type::Reference: {\n    // Switch back to inline and fall through.\n    type_ = Type::Inline;\n    buffer_.dynamic_ = inline_buffer_;\n\n    FALLTHRU;\n  }\n\n  case Type::Inline: {\n    if (size <= sizeof(inline_buffer_)) {\n      // Already inline and the new value fits in inline storage.\n      break;\n    }\n\n    FALLTHRU;\n  }\n\n  case Type::Dynamic: {\n    // We can get here either because we didn't fit in inline or we are already dynamic.\n    if (type_ == Type::Inline) {\n      dynamic_capacity_ = size * 2;\n      validateCapacity(dynamic_capacity_);\n      buffer_.dynamic_ = static_cast<char*>(malloc(dynamic_capacity_));\n      RELEASE_ASSERT(buffer_.dynamic_ != nullptr, \"\");\n      type_ = Type::Dynamic;\n    } else {\n      if (size > dynamic_capacity_) {\n        // Need to reallocate. Use free/malloc to avoid the copy since we are about to overwrite.\n        dynamic_capacity_ = size * 2;\n        validateCapacity(dynamic_capacity_);\n        free(buffer_.dynamic_);\n        buffer_.dynamic_ = static_cast<char*>(malloc(dynamic_capacity_));\n        RELEASE_ASSERT(buffer_.dynamic_ != nullptr, \"\");\n      }\n    }\n  }\n  }\n\n  memcpy(buffer_.dynamic_, data, size);\n  string_length_ = size;\n  ASSERT(valid());\n}\n\nvoid HeaderString::setCopy(absl::string_view view) {\n  this->setCopy(view.data(), static_cast<uint32_t>(view.size()));\n}\n\nvoid HeaderString::setInteger(uint64_t value) {\n  switch (type_) {\n  case Type::Reference: {\n    // Switch back to inline and fall through.\n    type_ = Type::Inline;\n    buffer_.dynamic_ = inline_buffer_;\n\n    FALLTHRU;\n  }\n\n  case Type::Inline:\n    // buffer_.dynamic_ should always point at inline_buffer_ for Type::Inline.\n    ASSERT(buffer_.dynamic_ == inline_buffer_);\n    FALLTHRU;\n  case Type::Dynamic: {\n    // Whether dynamic or inline the buffer is guaranteed to be large enough.\n    ASSERT(type_ == Type::Inline || dynamic_capacity_ >= MaxIntegerLength);\n    // It's safe to use buffer.dynamic_, since buffer.ref_ is union aliased.\n    // This better not change without verifying assumptions across this file.\n    static_assert(offsetof(Buffer, dynamic_) == offsetof(Buffer, ref_), \"\");\n    string_length_ = StringUtil::itoa(buffer_.dynamic_, 32, value);\n  }\n  }\n}\n\nvoid HeaderString::setReference(const std::string& ref_value) {\n  freeDynamic();\n  type_ = Type::Reference;\n  buffer_.ref_ = ref_value.c_str();\n  string_length_ = ref_value.size();\n  ASSERT(valid());\n}\n\n// Specialization needed for HeaderMapImpl::HeaderList::insert() when key is LowerCaseString.\n// A fully specialized template must be defined once in the program, hence this may not be in\n// a header file.\ntemplate <> bool HeaderMapImpl::HeaderList::isPseudoHeader(const LowerCaseString& key) {\n  return key.get().c_str()[0] == ':';\n}\n\nHeaderMapImpl::HeaderEntryImpl::HeaderEntryImpl(const LowerCaseString& key) : key_(key) {}\n\nHeaderMapImpl::HeaderEntryImpl::HeaderEntryImpl(const LowerCaseString& key, HeaderString&& value)\n    : key_(key), value_(std::move(value)) {}\n\nHeaderMapImpl::HeaderEntryImpl::HeaderEntryImpl(HeaderString&& key, HeaderString&& value)\n    : key_(std::move(key)), value_(std::move(value)) {}\n\nvoid HeaderMapImpl::HeaderEntryImpl::value(const char* value, uint32_t size) {\n  value_.setCopy(value, size);\n}\n\nvoid HeaderMapImpl::HeaderEntryImpl::value(absl::string_view value) {\n  this->value(value.data(), static_cast<uint32_t>(value.size()));\n}\n\nvoid HeaderMapImpl::HeaderEntryImpl::value(uint64_t value) { value_.setInteger(value); }\n\nvoid HeaderMapImpl::HeaderEntryImpl::value(const HeaderEntry& header) {\n  value(header.value().getStringView());\n}\n\n#define INLINE_HEADER_STATIC_MAP_ENTRY(name)                                                       \\\n  add(Headers::get().name.get().c_str(), [](HeaderMapImpl& h) -> StaticLookupResponse {            \\\n    return {&h.inline_headers_.name##_, &Headers::get().name};                                     \\\n  });\n\n/**\n * This is the static lookup table that is used to determine whether a header is one of the O(1)\n * headers. This uses a trie for lookup time at most equal to the size of the incoming string.\n */\nstruct HeaderMapImpl::StaticLookupTable : public TrieLookupTable<EntryCb> {\n  StaticLookupTable() {\n    ALL_INLINE_HEADERS(INLINE_HEADER_STATIC_MAP_ENTRY)\n\n    // Special case where we map a legacy host header to :authority.\n    add(Headers::get().HostLegacy.get().c_str(), [](HeaderMapImpl& h) -> StaticLookupResponse {\n      return {&h.inline_headers_.Host_, &Headers::get().Host};\n    });\n  }\n};\n\nvoid HeaderMapImpl::appendToHeader(HeaderString& header, absl::string_view data) {\n  if (data.empty()) {\n    return;\n  }\n  if (!header.empty()) {\n    header.append(\",\", 1);\n  }\n  header.append(data.data(), data.size());\n}\n\nHeaderMapImpl::HeaderMapImpl() { memset(&inline_headers_, 0, sizeof(inline_headers_)); }\n\nHeaderMapImpl::HeaderMapImpl(\n    const std::initializer_list<std::pair<LowerCaseString, std::string>>& values)\n    : HeaderMapImpl() {\n  for (auto& value : values) {\n    HeaderString key_string;\n    key_string.setCopy(value.first.get().c_str(), value.first.get().size());\n    HeaderString value_string;\n    value_string.setCopy(value.second.c_str(), value.second.size());\n    addViaMove(std::move(key_string), std::move(value_string));\n  }\n}\n\nvoid HeaderMapImpl::copyFrom(const HeaderMap& header_map) {\n  header_map.iterate(\n      [](const HeaderEntry& header, void* context) -> HeaderMap::Iterate {\n        // TODO(mattklein123) PERF: Avoid copying here if not necessary.\n        HeaderString key_string;\n        key_string.setCopy(header.key().getStringView());\n        HeaderString value_string;\n        value_string.setCopy(header.value().getStringView());\n\n        static_cast<HeaderMapImpl*>(context)->addViaMove(std::move(key_string),\n                                                         std::move(value_string));\n        return HeaderMap::Iterate::Continue;\n      },\n      this);\n}\n\nbool HeaderMapImpl::operator==(const HeaderMapImpl& rhs) const {\n  if (size() != rhs.size()) {\n    return false;\n  }\n\n  for (auto i = headers_.begin(), j = rhs.headers_.begin(); i != headers_.end(); ++i, ++j) {\n    if (i->key() != j->key().getStringView() || i->value() != j->value().getStringView()) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nbool HeaderMapImpl::operator!=(const HeaderMapImpl& rhs) const { return !operator==(rhs); }\n\nvoid HeaderMapImpl::insertByKey(HeaderString&& key, HeaderString&& value) {\n  EntryCb cb = ConstSingleton<StaticLookupTable>::get().find(key.getStringView());\n  if (cb) {\n    key.clear();\n    StaticLookupResponse ref_lookup_response = cb(*this);\n    if (*ref_lookup_response.entry_ == nullptr) {\n      maybeCreateInline(ref_lookup_response.entry_, *ref_lookup_response.key_, std::move(value));\n    } else {\n      appendToHeader((*ref_lookup_response.entry_)->value(), value.getStringView());\n      value.clear();\n    }\n  } else {\n    std::list<HeaderEntryImpl>::iterator i = headers_.insert(std::move(key), std::move(value));\n    i->entry_ = i;\n  }\n}\n\nvoid HeaderMapImpl::addViaMove(HeaderString&& key, HeaderString&& value) {\n  // If this is an inline header, we can't addViaMove, because we'll overwrite\n  // the existing value.\n  auto* entry = getExistingInline(key.getStringView());\n  if (entry != nullptr) {\n    appendToHeader(entry->value(), value.getStringView());\n    key.clear();\n    value.clear();\n  } else {\n    insertByKey(std::move(key), std::move(value));\n  }\n}\n\nvoid HeaderMapImpl::addReference(const LowerCaseString& key, const std::string& value) {\n  HeaderString ref_key(key);\n  HeaderString ref_value(value);\n  addViaMove(std::move(ref_key), std::move(ref_value));\n}\n\nvoid HeaderMapImpl::addReferenceKey(const LowerCaseString& key, uint64_t value) {\n  HeaderString ref_key(key);\n  HeaderString new_value;\n  new_value.setInteger(value);\n  insertByKey(std::move(ref_key), std::move(new_value));\n  ASSERT(new_value.empty()); // NOLINT(bugprone-use-after-move)\n}\n\nvoid HeaderMapImpl::addReferenceKey(const LowerCaseString& key, const std::string& value) {\n  HeaderString ref_key(key);\n  HeaderString new_value;\n  new_value.setCopy(value.c_str(), value.size());\n  insertByKey(std::move(ref_key), std::move(new_value));\n  ASSERT(new_value.empty()); // NOLINT(bugprone-use-after-move)\n}\n\nvoid HeaderMapImpl::addCopy(const LowerCaseString& key, uint64_t value) {\n  auto* entry = getExistingInline(key.get());\n  if (entry != nullptr) {\n    char buf[32];\n    StringUtil::itoa(buf, sizeof(buf), value);\n    appendToHeader(entry->value(), buf);\n    return;\n  }\n  HeaderString new_key;\n  new_key.setCopy(key.get().c_str(), key.get().size());\n  HeaderString new_value;\n  new_value.setInteger(value);\n  insertByKey(std::move(new_key), std::move(new_value));\n  ASSERT(new_key.empty());   // NOLINT(bugprone-use-after-move)\n  ASSERT(new_value.empty()); // NOLINT(bugprone-use-after-move)\n}\n\nvoid HeaderMapImpl::addCopy(const LowerCaseString& key, const std::string& value) {\n  auto* entry = getExistingInline(key.get());\n  if (entry != nullptr) {\n    appendToHeader(entry->value(), value);\n    return;\n  }\n  HeaderString new_key;\n  new_key.setCopy(key.get().c_str(), key.get().size());\n  HeaderString new_value;\n  new_value.setCopy(value.c_str(), value.size());\n  insertByKey(std::move(new_key), std::move(new_value));\n  ASSERT(new_key.empty());   // NOLINT(bugprone-use-after-move)\n  ASSERT(new_value.empty()); // NOLINT(bugprone-use-after-move)\n}\n\nvoid HeaderMapImpl::setReference(const LowerCaseString& key, const std::string& value) {\n  HeaderString ref_key(key);\n  HeaderString ref_value(value);\n  remove(key);\n  insertByKey(std::move(ref_key), std::move(ref_value));\n}\n\nvoid HeaderMapImpl::setReferenceKey(const LowerCaseString& key, const std::string& value) {\n  HeaderString ref_key(key);\n  HeaderString new_value;\n  new_value.setCopy(value.c_str(), value.size());\n  remove(key);\n  insertByKey(std::move(ref_key), std::move(new_value));\n  ASSERT(new_value.empty()); // NOLINT(bugprone-use-after-move)\n}\n\nuint64_t HeaderMapImpl::byteSize() const {\n  uint64_t byte_size = 0;\n  for (const HeaderEntryImpl& header : headers_) {\n    byte_size += header.key().size();\n    byte_size += header.value().size();\n  }\n\n  return byte_size;\n}\n\nconst HeaderEntry* HeaderMapImpl::get(const LowerCaseString& key) const {\n  for (const HeaderEntryImpl& header : headers_) {\n    if (header.key() == key.get().c_str()) {\n      return &header;\n    }\n  }\n\n  return nullptr;\n}\n\nHeaderEntry* HeaderMapImpl::get(const LowerCaseString& key) {\n  for (HeaderEntryImpl& header : headers_) {\n    if (header.key() == key.get().c_str()) {\n      return &header;\n    }\n  }\n\n  return nullptr;\n}\n\nvoid HeaderMapImpl::iterate(ConstIterateCb cb, void* context) const {\n  for (const HeaderEntryImpl& header : headers_) {\n    if (cb(header, context) == HeaderMap::Iterate::Break) {\n      break;\n    }\n  }\n}\n\nvoid HeaderMapImpl::iterateReverse(ConstIterateCb cb, void* context) const {\n  for (auto it = headers_.rbegin(); it != headers_.rend(); it++) {\n    if (cb(*it, context) == HeaderMap::Iterate::Break) {\n      break;\n    }\n  }\n}\n\nHeaderMap::Lookup HeaderMapImpl::lookup(const LowerCaseString& key,\n                                        const HeaderEntry** entry) const {\n  EntryCb cb = ConstSingleton<StaticLookupTable>::get().find(key.get());\n  if (cb) {\n    // The accessor callbacks for predefined inline headers take a HeaderMapImpl& as an argument;\n    // even though we don't make any modifications, we need to cast_cast in order to use the\n    // accessor.\n    //\n    // Making this work without const_cast would require managing an additional const accessor\n    // callback for each predefined inline header and add to the complexity of the code.\n    StaticLookupResponse ref_lookup_response = cb(const_cast<HeaderMapImpl&>(*this));\n    *entry = *ref_lookup_response.entry_;\n    if (*entry) {\n      return Lookup::Found;\n    } else {\n      return Lookup::NotFound;\n    }\n  } else {\n    *entry = nullptr;\n    return Lookup::NotSupported;\n  }\n}\n\nvoid HeaderMapImpl::remove(const LowerCaseString& key) {\n  EntryCb cb = ConstSingleton<StaticLookupTable>::get().find(key.get());\n  if (cb) {\n    StaticLookupResponse ref_lookup_response = cb(*this);\n    removeInline(ref_lookup_response.entry_);\n  } else {\n    for (auto i = headers_.begin(); i != headers_.end();) {\n      if (i->key() == key.get().c_str()) {\n        i = headers_.erase(i);\n      } else {\n        ++i;\n      }\n    }\n  }\n}\n\nvoid HeaderMapImpl::removePrefix(const LowerCaseString& prefix) {\n  headers_.remove_if([&](const HeaderEntryImpl& entry) {\n    bool to_remove = absl::StartsWith(entry.key().getStringView(), prefix.get());\n    if (to_remove) {\n      // If this header should be removed, make sure any references in the\n      // static lookup table are cleared as well.\n      EntryCb cb = ConstSingleton<StaticLookupTable>::get().find(entry.key().getStringView());\n      if (cb) {\n        StaticLookupResponse ref_lookup_response = cb(*this);\n        if (ref_lookup_response.entry_) {\n          *ref_lookup_response.entry_ = nullptr;\n        }\n      }\n    }\n    return to_remove;\n  });\n}\n\nvoid HeaderMapImpl::dumpState(std::ostream& os, int indent_level) const {\n  using IterateData = std::pair<std::ostream*, const char*>;\n  const char* spaces = spacesForLevel(indent_level);\n  IterateData iterate_data = std::make_pair(&os, spaces);\n  iterate(\n      [](const HeaderEntry& header, void* context) -> HeaderMap::Iterate {\n        auto* data = static_cast<IterateData*>(context);\n        *data->first << data->second << \"'\" << header.key().getStringView() << \"', '\"\n                     << header.value().getStringView() << \"'\\n\";\n        return HeaderMap::Iterate::Continue;\n      },\n      &iterate_data);\n}\n\nHeaderMapImpl::HeaderEntryImpl& HeaderMapImpl::maybeCreateInline(HeaderEntryImpl** entry,\n                                                                 const LowerCaseString& key) {\n  if (*entry) {\n    return **entry;\n  }\n\n  std::list<HeaderEntryImpl>::iterator i = headers_.insert(key);\n  i->entry_ = i;\n  *entry = &(*i);\n  return **entry;\n}\n\nHeaderMapImpl::HeaderEntryImpl& HeaderMapImpl::maybeCreateInline(HeaderEntryImpl** entry,\n                                                                 const LowerCaseString& key,\n                                                                 HeaderString&& value) {\n  if (*entry) {\n    value.clear();\n    return **entry;\n  }\n\n  std::list<HeaderEntryImpl>::iterator i = headers_.insert(key, std::move(value));\n  i->entry_ = i;\n  *entry = &(*i);\n  return **entry;\n}\n\nHeaderMapImpl::HeaderEntryImpl* HeaderMapImpl::getExistingInline(absl::string_view key) {\n  EntryCb cb = ConstSingleton<StaticLookupTable>::get().find(key);\n  if (cb) {\n    StaticLookupResponse ref_lookup_response = cb(*this);\n    return *ref_lookup_response.entry_;\n  }\n  return nullptr;\n}\n\nvoid HeaderMapImpl::removeInline(HeaderEntryImpl** ptr_to_entry) {\n  if (!*ptr_to_entry) {\n    return;\n  }\n\n  HeaderEntryImpl* entry = *ptr_to_entry;\n  *ptr_to_entry = nullptr;\n  headers_.erase(entry->entry_);\n}\n\n} // namespace Http\n} // namespace Envoy\n", "#pragma once\n\n#include <array>\n#include <cstdint>\n#include <list>\n#include <memory>\n#include <string>\n\n#include \"envoy/http/header_map.h\"\n\n#include \"common/common/non_copyable.h\"\n#include \"common/http/headers.h\"\n\nnamespace Envoy {\nnamespace Http {\n\n/**\n * These are definitions of all of the inline header access functions described inside header_map.h\n */\n#define DEFINE_INLINE_HEADER_FUNCS(name)                                                           \\\npublic:                                                                                            \\\n  const HeaderEntry* name() const override { return inline_headers_.name##_; }                     \\\n  HeaderEntry* name() override { return inline_headers_.name##_; }                                 \\\n  HeaderEntry& insert##name() override {                                                           \\\n    return maybeCreateInline(&inline_headers_.name##_, Headers::get().name);                       \\\n  }                                                                                                \\\n  void remove##name() override { removeInline(&inline_headers_.name##_); }\n\n#define DEFINE_INLINE_HEADER_STRUCT(name) HeaderEntryImpl* name##_;\n\n/**\n * Implementation of Http::HeaderMap. This is heavily optimized for performance. Roughly, when\n * headers are added to the map, we do a hash lookup to see if it's one of the O(1) headers.\n * If it is, we store a reference to it that can be accessed later directly. Most high performance\n * paths use O(1) direct access. In general, we try to copy as little as possible and allocate as\n * little as possible in any of the paths.\n */\nclass HeaderMapImpl : public HeaderMap, NonCopyable {\npublic:\n  /**\n   * Appends data to header. If header already has a value, the string ',' is added between the\n   * existing value and data.\n   * @param header the header to append to.\n   * @param data to append to the header.\n   */\n  static void appendToHeader(HeaderString& header, absl::string_view data);\n\n  HeaderMapImpl();\n  explicit HeaderMapImpl(\n      const std::initializer_list<std::pair<LowerCaseString, std::string>>& values);\n  explicit HeaderMapImpl(const HeaderMap& rhs) : HeaderMapImpl() { copyFrom(rhs); }\n\n  /**\n   * Add a header via full move. This is the expected high performance paths for codecs populating\n   * a map when receiving.\n   */\n  void addViaMove(HeaderString&& key, HeaderString&& value);\n\n  /**\n   * For testing. Equality is based on equality of the backing list. This is an exact match\n   * comparison (order matters).\n   */\n  bool operator==(const HeaderMapImpl& rhs) const;\n  bool operator!=(const HeaderMapImpl& rhs) const;\n\n  // Http::HeaderMap\n  void addReference(const LowerCaseString& key, const std::string& value) override;\n  void addReferenceKey(const LowerCaseString& key, uint64_t value) override;\n  void addReferenceKey(const LowerCaseString& key, const std::string& value) override;\n  void addCopy(const LowerCaseString& key, uint64_t value) override;\n  void addCopy(const LowerCaseString& key, const std::string& value) override;\n  void setReference(const LowerCaseString& key, const std::string& value) override;\n  void setReferenceKey(const LowerCaseString& key, const std::string& value) override;\n  uint64_t byteSize() const override;\n  const HeaderEntry* get(const LowerCaseString& key) const override;\n  HeaderEntry* get(const LowerCaseString& key) override;\n  void iterate(ConstIterateCb cb, void* context) const override;\n  void iterateReverse(ConstIterateCb cb, void* context) const override;\n  Lookup lookup(const LowerCaseString& key, const HeaderEntry** entry) const override;\n  void remove(const LowerCaseString& key) override;\n  void removePrefix(const LowerCaseString& key) override;\n  size_t size() const override { return headers_.size(); }\n  bool empty() const override { return headers_.empty(); }\n  void dumpState(std::ostream& os, int indent_level = 0) const override;\n\nprotected:\n  // For tests only, unoptimized, they aren't intended for regular HeaderMapImpl users.\n  void copyFrom(const HeaderMap& rhs);\n  void clear() { removePrefix(LowerCaseString(\"\")); }\n\n  struct HeaderEntryImpl : public HeaderEntry, NonCopyable {\n    HeaderEntryImpl(const LowerCaseString& key);\n    HeaderEntryImpl(const LowerCaseString& key, HeaderString&& value);\n    HeaderEntryImpl(HeaderString&& key, HeaderString&& value);\n\n    // HeaderEntry\n    const HeaderString& key() const override { return key_; }\n    void value(const char* value, uint32_t size) override;\n    void value(absl::string_view value) override;\n    void value(uint64_t value) override;\n    void value(const HeaderEntry& header) override;\n    const HeaderString& value() const override { return value_; }\n    HeaderString& value() override { return value_; }\n\n    HeaderString key_;\n    HeaderString value_;\n    std::list<HeaderEntryImpl>::iterator entry_;\n  };\n\n  struct StaticLookupResponse {\n    HeaderEntryImpl** entry_;\n    const LowerCaseString* key_;\n  };\n\n  using EntryCb = StaticLookupResponse (*)(HeaderMapImpl&);\n\n  /**\n   * This is the static lookup table that is used to determine whether a header is one of the O(1)\n   * headers. This uses a trie for lookup time at most equal to the size of the incoming string.\n   */\n  struct StaticLookupTable; // Defined in header_map_impl.cc.\n\n  struct AllInlineHeaders {\n    ALL_INLINE_HEADERS(DEFINE_INLINE_HEADER_STRUCT)\n  };\n\n  /**\n   * List of HeaderEntryImpl that keeps the pseudo headers (key starting with ':') in the front\n   * of the list (as required by nghttp2) and otherwise maintains insertion order.\n   *\n   * Note: the internal iterators held in fields make this unsafe to copy and move, since the\n   * reference to end() is not preserved across a move (see Notes in\n   * https://en.cppreference.com/w/cpp/container/list/list). The NonCopyable will suppress both copy\n   * and move constructors/assignment.\n   * TODO(htuch): Maybe we want this to movable one day; for now, our header map moves happen on\n   * HeaderMapPtr, so the performance impact should not be evident.\n   */\n  class HeaderList : NonCopyable {\n  public:\n    HeaderList() : pseudo_headers_end_(headers_.end()) {}\n\n    template <class Key> bool isPseudoHeader(const Key& key) {\n      return !key.getStringView().empty() && key.getStringView()[0] == ':';\n    }\n\n    template <class Key, class... Value>\n    std::list<HeaderEntryImpl>::iterator insert(Key&& key, Value&&... value) {\n      const bool is_pseudo_header = isPseudoHeader(key);\n      std::list<HeaderEntryImpl>::iterator i =\n          headers_.emplace(is_pseudo_header ? pseudo_headers_end_ : headers_.end(),\n                           std::forward<Key>(key), std::forward<Value>(value)...);\n      if (!is_pseudo_header && pseudo_headers_end_ == headers_.end()) {\n        pseudo_headers_end_ = i;\n      }\n      return i;\n    }\n\n    std::list<HeaderEntryImpl>::iterator erase(std::list<HeaderEntryImpl>::iterator i) {\n      if (pseudo_headers_end_ == i) {\n        pseudo_headers_end_++;\n      }\n      return headers_.erase(i);\n    }\n\n    template <class UnaryPredicate> void remove_if(UnaryPredicate p) {\n      headers_.remove_if([&](const HeaderEntryImpl& entry) {\n        const bool to_remove = p(entry);\n        if (to_remove) {\n          if (pseudo_headers_end_ == entry.entry_) {\n            pseudo_headers_end_++;\n          }\n        }\n        return to_remove;\n      });\n    }\n\n    std::list<HeaderEntryImpl>::iterator begin() { return headers_.begin(); }\n    std::list<HeaderEntryImpl>::iterator end() { return headers_.end(); }\n    std::list<HeaderEntryImpl>::const_iterator begin() const { return headers_.begin(); }\n    std::list<HeaderEntryImpl>::const_iterator end() const { return headers_.end(); }\n    std::list<HeaderEntryImpl>::const_reverse_iterator rbegin() const { return headers_.rbegin(); }\n    std::list<HeaderEntryImpl>::const_reverse_iterator rend() const { return headers_.rend(); }\n    size_t size() const { return headers_.size(); }\n    bool empty() const { return headers_.empty(); }\n\n  private:\n    std::list<HeaderEntryImpl> headers_;\n    std::list<HeaderEntryImpl>::iterator pseudo_headers_end_;\n  };\n\n  void insertByKey(HeaderString&& key, HeaderString&& value);\n  HeaderEntryImpl& maybeCreateInline(HeaderEntryImpl** entry, const LowerCaseString& key);\n  HeaderEntryImpl& maybeCreateInline(HeaderEntryImpl** entry, const LowerCaseString& key,\n                                     HeaderString&& value);\n  HeaderEntryImpl* getExistingInline(absl::string_view key);\n\n  void removeInline(HeaderEntryImpl** entry);\n\n  AllInlineHeaders inline_headers_;\n  HeaderList headers_;\n\n  ALL_INLINE_HEADERS(DEFINE_INLINE_HEADER_FUNCS)\n};\n\nusing HeaderMapImplPtr = std::unique_ptr<HeaderMapImpl>;\n\n} // namespace Http\n} // namespace Envoy\n", "#include \"common/http/http1/codec_impl.h\"\n\n#include <cstdint>\n#include <memory>\n#include <string>\n\n#include \"envoy/buffer/buffer.h\"\n#include \"envoy/http/header_map.h\"\n#include \"envoy/network/connection.h\"\n\n#include \"common/common/enum_to_int.h\"\n#include \"common/common/fmt.h\"\n#include \"common/common/stack_array.h\"\n#include \"common/common/utility.h\"\n#include \"common/http/exception.h\"\n#include \"common/http/header_utility.h\"\n#include \"common/http/headers.h\"\n#include \"common/http/utility.h\"\n#include \"common/runtime/runtime_impl.h\"\n\nnamespace Envoy {\nnamespace Http {\nnamespace Http1 {\nnamespace {\n\nconst StringUtil::CaseUnorderedSet& caseUnorderdSetContainingUpgradeAndHttp2Settings() {\n  CONSTRUCT_ON_FIRST_USE(StringUtil::CaseUnorderedSet,\n                         Http::Headers::get().ConnectionValues.Upgrade,\n                         Http::Headers::get().ConnectionValues.Http2Settings);\n}\n\n} // namespace\n\nconst std::string StreamEncoderImpl::CRLF = \"\\r\\n\";\nconst std::string StreamEncoderImpl::LAST_CHUNK = \"0\\r\\n\\r\\n\";\n\nStreamEncoderImpl::StreamEncoderImpl(ConnectionImpl& connection) : connection_(connection) {\n  if (connection_.connection().aboveHighWatermark()) {\n    runHighWatermarkCallbacks();\n  }\n}\n\nvoid StreamEncoderImpl::encodeHeader(const char* key, uint32_t key_size, const char* value,\n                                     uint32_t value_size) {\n\n  connection_.reserveBuffer(key_size + value_size + 4);\n  ASSERT(key_size > 0);\n\n  connection_.copyToBuffer(key, key_size);\n  connection_.addCharToBuffer(':');\n  connection_.addCharToBuffer(' ');\n  connection_.copyToBuffer(value, value_size);\n  connection_.addCharToBuffer('\\r');\n  connection_.addCharToBuffer('\\n');\n}\nvoid StreamEncoderImpl::encodeHeader(absl::string_view key, absl::string_view value) {\n  this->encodeHeader(key.data(), key.size(), value.data(), value.size());\n}\n\nvoid StreamEncoderImpl::encode100ContinueHeaders(const HeaderMap& headers) {\n  ASSERT(headers.Status()->value() == \"100\");\n  processing_100_continue_ = true;\n  encodeHeaders(headers, false);\n  processing_100_continue_ = false;\n}\n\nvoid StreamEncoderImpl::encodeHeaders(const HeaderMap& headers, bool end_stream) {\n  bool saw_content_length = false;\n  headers.iterate(\n      [](const HeaderEntry& header, void* context) -> HeaderMap::Iterate {\n        absl::string_view key_to_use = header.key().getStringView();\n        uint32_t key_size_to_use = header.key().size();\n        // Translate :authority -> host so that upper layers do not need to deal with this.\n        if (key_size_to_use > 1 && key_to_use[0] == ':' && key_to_use[1] == 'a') {\n          key_to_use = absl::string_view(Headers::get().HostLegacy.get());\n          key_size_to_use = Headers::get().HostLegacy.get().size();\n        }\n\n        // Skip all headers starting with ':' that make it here.\n        if (key_to_use[0] == ':') {\n          return HeaderMap::Iterate::Continue;\n        }\n\n        static_cast<StreamEncoderImpl*>(context)->encodeHeader(key_to_use,\n                                                               header.value().getStringView());\n        return HeaderMap::Iterate::Continue;\n      },\n      this);\n\n  if (headers.ContentLength()) {\n    saw_content_length = true;\n  }\n\n  ASSERT(!headers.TransferEncoding());\n\n  // Assume we are chunk encoding unless we are passed a content length or this is a header only\n  // response. Upper layers generally should strip transfer-encoding since it only applies to\n  // HTTP/1.1. The codec will infer it based on the type of response.\n  // for streaming (e.g. SSE stream sent to hystrix dashboard), we do not want\n  // chunk transfer encoding but we don't have a content-length so we pass \"envoy only\"\n  // header to avoid adding chunks\n  //\n  // Note that for HEAD requests Envoy does best-effort guessing when there is no\n  // content-length. If a client makes a HEAD request for an upstream resource\n  // with no bytes but the upstream response doesn't include \"Content-length: 0\",\n  // Envoy will incorrectly assume a subsequent response to GET will be chunk encoded.\n  if (saw_content_length || headers.NoChunks()) {\n    chunk_encoding_ = false;\n  } else {\n    if (processing_100_continue_) {\n      // Make sure we don't serialize chunk information with 100-Continue headers.\n      chunk_encoding_ = false;\n    } else if (end_stream && !is_response_to_head_request_) {\n      // If this is a headers-only stream, append an explicit \"Content-Length: 0\" unless it's a\n      // response to a HEAD request.\n      // For 204s and 1xx where content length is disallowed, don't append the content length but\n      // also don't chunk encode.\n      if (is_content_length_allowed_) {\n        encodeHeader(Headers::get().ContentLength.get().c_str(),\n                     Headers::get().ContentLength.get().size(), \"0\", 1);\n      }\n      chunk_encoding_ = false;\n    } else if (connection_.protocol() == Protocol::Http10) {\n      chunk_encoding_ = false;\n    } else {\n      encodeHeader(Headers::get().TransferEncoding.get().c_str(),\n                   Headers::get().TransferEncoding.get().size(),\n                   Headers::get().TransferEncodingValues.Chunked.c_str(),\n                   Headers::get().TransferEncodingValues.Chunked.size());\n      // We do not apply chunk encoding for HTTP upgrades.\n      // If there is a body in a WebSocket Upgrade response, the chunks will be\n      // passed through via maybeDirectDispatch so we need to avoid appending\n      // extra chunk boundaries.\n      //\n      // When sending a response to a HEAD request Envoy may send an informational\n      // \"Transfer-Encoding: chunked\" header, but should not send a chunk encoded body.\n      chunk_encoding_ = !Utility::isUpgrade(headers) && !is_response_to_head_request_;\n    }\n  }\n\n  connection_.reserveBuffer(2);\n  connection_.addCharToBuffer('\\r');\n  connection_.addCharToBuffer('\\n');\n\n  if (end_stream) {\n    endEncode();\n  } else {\n    connection_.flushOutput();\n  }\n}\n\nvoid StreamEncoderImpl::encodeData(Buffer::Instance& data, bool end_stream) {\n  // end_stream may be indicated with a zero length data buffer. If that is the case, so not\n  // actually write the zero length buffer out.\n  if (data.length() > 0) {\n    if (chunk_encoding_) {\n      connection_.buffer().add(fmt::format(\"{:x}\\r\\n\", data.length()));\n    }\n\n    connection_.buffer().move(data);\n\n    if (chunk_encoding_) {\n      connection_.buffer().add(CRLF);\n    }\n  }\n\n  if (end_stream) {\n    endEncode();\n  } else {\n    connection_.flushOutput();\n  }\n}\n\nvoid StreamEncoderImpl::encodeTrailers(const HeaderMap&) { endEncode(); }\n\nvoid StreamEncoderImpl::encodeMetadata(const MetadataMapVector&) {\n  connection_.stats().metadata_not_supported_error_.inc();\n}\n\nvoid StreamEncoderImpl::endEncode() {\n  if (chunk_encoding_) {\n    connection_.buffer().add(LAST_CHUNK);\n  }\n\n  connection_.flushOutput();\n  connection_.onEncodeComplete();\n}\n\nvoid ConnectionImpl::flushOutput() {\n  if (reserved_current_) {\n    reserved_iovec_.len_ = reserved_current_ - static_cast<char*>(reserved_iovec_.mem_);\n    output_buffer_.commit(&reserved_iovec_, 1);\n    reserved_current_ = nullptr;\n  }\n\n  connection().write(output_buffer_, false);\n  ASSERT(0UL == output_buffer_.length());\n}\n\nvoid ConnectionImpl::addCharToBuffer(char c) {\n  ASSERT(bufferRemainingSize() >= 1);\n  *reserved_current_++ = c;\n}\n\nvoid ConnectionImpl::addIntToBuffer(uint64_t i) {\n  reserved_current_ += StringUtil::itoa(reserved_current_, bufferRemainingSize(), i);\n}\n\nuint64_t ConnectionImpl::bufferRemainingSize() {\n  return reserved_iovec_.len_ - (reserved_current_ - static_cast<char*>(reserved_iovec_.mem_));\n}\n\nvoid ConnectionImpl::copyToBuffer(const char* data, uint64_t length) {\n  ASSERT(bufferRemainingSize() >= length);\n  memcpy(reserved_current_, data, length);\n  reserved_current_ += length;\n}\n\nvoid ConnectionImpl::reserveBuffer(uint64_t size) {\n  if (reserved_current_ && bufferRemainingSize() >= size) {\n    return;\n  }\n\n  if (reserved_current_) {\n    reserved_iovec_.len_ = reserved_current_ - static_cast<char*>(reserved_iovec_.mem_);\n    output_buffer_.commit(&reserved_iovec_, 1);\n  }\n\n  // TODO PERF: It would be better to allow a split reservation. That will make fill code more\n  //            complicated.\n  output_buffer_.reserve(std::max<uint64_t>(4096, size), &reserved_iovec_, 1);\n  reserved_current_ = static_cast<char*>(reserved_iovec_.mem_);\n}\n\nvoid StreamEncoderImpl::resetStream(StreamResetReason reason) {\n  connection_.onResetStreamBase(reason);\n}\n\nvoid StreamEncoderImpl::readDisable(bool disable) { connection_.readDisable(disable); }\n\nuint32_t StreamEncoderImpl::bufferLimit() { return connection_.bufferLimit(); }\n\nstatic const char RESPONSE_PREFIX[] = \"HTTP/1.1 \";\nstatic const char HTTP_10_RESPONSE_PREFIX[] = \"HTTP/1.0 \";\n\nvoid ResponseStreamEncoderImpl::encodeHeaders(const HeaderMap& headers, bool end_stream) {\n  started_response_ = true;\n  uint64_t numeric_status = Utility::getResponseStatus(headers);\n\n  connection_.reserveBuffer(4096);\n  if (connection_.protocol() == Protocol::Http10 && connection_.supports_http_10()) {\n    connection_.copyToBuffer(HTTP_10_RESPONSE_PREFIX, sizeof(HTTP_10_RESPONSE_PREFIX) - 1);\n  } else {\n    connection_.copyToBuffer(RESPONSE_PREFIX, sizeof(RESPONSE_PREFIX) - 1);\n  }\n  connection_.addIntToBuffer(numeric_status);\n  connection_.addCharToBuffer(' ');\n\n  const char* status_string = CodeUtility::toString(static_cast<Code>(numeric_status));\n  uint32_t status_string_len = strlen(status_string);\n  connection_.copyToBuffer(status_string, status_string_len);\n\n  connection_.addCharToBuffer('\\r');\n  connection_.addCharToBuffer('\\n');\n\n  if (numeric_status == 204 || numeric_status < 200) {\n    // Per https://tools.ietf.org/html/rfc7230#section-3.3.2\n    setIsContentLengthAllowed(false);\n  } else {\n    // Make sure that if we encodeHeaders(100) then encodeHeaders(200) that we\n    // set is_content_length_allowed_ back to true.\n    setIsContentLengthAllowed(true);\n  }\n\n  StreamEncoderImpl::encodeHeaders(headers, end_stream);\n}\n\nstatic const char REQUEST_POSTFIX[] = \" HTTP/1.1\\r\\n\";\n\nvoid RequestStreamEncoderImpl::encodeHeaders(const HeaderMap& headers, bool end_stream) {\n  const HeaderEntry* method = headers.Method();\n  const HeaderEntry* path = headers.Path();\n  if (!method || !path) {\n    throw CodecClientException(\":method and :path must be specified\");\n  }\n  if (method->value() == Headers::get().MethodValues.Head) {\n    head_request_ = true;\n  }\n  connection_.onEncodeHeaders(headers);\n  connection_.reserveBuffer(std::max(4096U, path->value().size() + 4096));\n  connection_.copyToBuffer(method->value().getStringView().data(), method->value().size());\n  connection_.addCharToBuffer(' ');\n  connection_.copyToBuffer(path->value().getStringView().data(), path->value().size());\n  connection_.copyToBuffer(REQUEST_POSTFIX, sizeof(REQUEST_POSTFIX) - 1);\n\n  StreamEncoderImpl::encodeHeaders(headers, end_stream);\n}\n\nhttp_parser_settings ConnectionImpl::settings_{\n    [](http_parser* parser) -> int {\n      static_cast<ConnectionImpl*>(parser->data)->onMessageBeginBase();\n      return 0;\n    },\n    [](http_parser* parser, const char* at, size_t length) -> int {\n      static_cast<ConnectionImpl*>(parser->data)->onUrl(at, length);\n      return 0;\n    },\n    nullptr, // on_status\n    [](http_parser* parser, const char* at, size_t length) -> int {\n      static_cast<ConnectionImpl*>(parser->data)->onHeaderField(at, length);\n      return 0;\n    },\n    [](http_parser* parser, const char* at, size_t length) -> int {\n      static_cast<ConnectionImpl*>(parser->data)->onHeaderValue(at, length);\n      return 0;\n    },\n    [](http_parser* parser) -> int {\n      return static_cast<ConnectionImpl*>(parser->data)->onHeadersCompleteBase();\n    },\n    [](http_parser* parser, const char* at, size_t length) -> int {\n      static_cast<ConnectionImpl*>(parser->data)->onBody(at, length);\n      return 0;\n    },\n    [](http_parser* parser) -> int {\n      static_cast<ConnectionImpl*>(parser->data)->onMessageCompleteBase();\n      return 0;\n    },\n    nullptr, // on_chunk_header\n    nullptr  // on_chunk_complete\n};\n\nconst ToLowerTable& ConnectionImpl::toLowerTable() {\n  static auto* table = new ToLowerTable();\n  return *table;\n}\n\nConnectionImpl::ConnectionImpl(Network::Connection& connection, Stats::Scope& stats,\n                               http_parser_type type, uint32_t max_request_headers_kb)\n    : connection_(connection), stats_{ALL_HTTP1_CODEC_STATS(POOL_COUNTER_PREFIX(stats, \"http1.\"))},\n      output_buffer_([&]() -> void { this->onBelowLowWatermark(); },\n                     [&]() -> void { this->onAboveHighWatermark(); }),\n      max_request_headers_kb_(max_request_headers_kb),\n      strict_header_validation_(\n          Runtime::runtimeFeatureEnabled(\"envoy.reloadable_features.strict_header_validation\")) {\n  output_buffer_.setWatermarks(connection.bufferLimit());\n  http_parser_init(&parser_, type);\n  parser_.data = this;\n}\n\nvoid ConnectionImpl::completeLastHeader() {\n  ENVOY_CONN_LOG(trace, \"completed header: key={} value={}\", connection_,\n                 current_header_field_.getStringView(), current_header_value_.getStringView());\n  if (!current_header_field_.empty()) {\n    toLowerTable().toLowerCase(current_header_field_.buffer(), current_header_field_.size());\n    current_header_map_->addViaMove(std::move(current_header_field_),\n                                    std::move(current_header_value_));\n  }\n\n  header_parsing_state_ = HeaderParsingState::Field;\n  ASSERT(current_header_field_.empty());\n  ASSERT(current_header_value_.empty());\n}\n\nbool ConnectionImpl::maybeDirectDispatch(Buffer::Instance& data) {\n  if (!handling_upgrade_) {\n    // Only direct dispatch for Upgrade requests.\n    return false;\n  }\n\n  ssize_t total_parsed = 0;\n  uint64_t num_slices = data.getRawSlices(nullptr, 0);\n  STACK_ARRAY(slices, Buffer::RawSlice, num_slices);\n  data.getRawSlices(slices.begin(), num_slices);\n  for (const Buffer::RawSlice& slice : slices) {\n    total_parsed += slice.len_;\n    onBody(static_cast<const char*>(slice.mem_), slice.len_);\n  }\n  ENVOY_CONN_LOG(trace, \"direct-dispatched {} bytes\", connection_, total_parsed);\n  data.drain(total_parsed);\n  return true;\n}\n\nvoid ConnectionImpl::dispatch(Buffer::Instance& data) {\n  ENVOY_CONN_LOG(trace, \"parsing {} bytes\", connection_, data.length());\n\n  if (maybeDirectDispatch(data)) {\n    return;\n  }\n\n  // Always unpause before dispatch.\n  http_parser_pause(&parser_, 0);\n\n  ssize_t total_parsed = 0;\n  if (data.length() > 0) {\n    uint64_t num_slices = data.getRawSlices(nullptr, 0);\n    STACK_ARRAY(slices, Buffer::RawSlice, num_slices);\n    data.getRawSlices(slices.begin(), num_slices);\n    for (const Buffer::RawSlice& slice : slices) {\n      total_parsed += dispatchSlice(static_cast<const char*>(slice.mem_), slice.len_);\n    }\n  } else {\n    dispatchSlice(nullptr, 0);\n  }\n\n  ENVOY_CONN_LOG(trace, \"parsed {} bytes\", connection_, total_parsed);\n  data.drain(total_parsed);\n\n  // If an upgrade has been handled and there is body data or early upgrade\n  // payload to send on, send it on.\n  maybeDirectDispatch(data);\n}\n\nsize_t ConnectionImpl::dispatchSlice(const char* slice, size_t len) {\n  ssize_t rc = http_parser_execute(&parser_, &settings_, slice, len);\n  if (HTTP_PARSER_ERRNO(&parser_) != HPE_OK && HTTP_PARSER_ERRNO(&parser_) != HPE_PAUSED) {\n    sendProtocolError();\n    throw CodecProtocolException(\"http/1.1 protocol error: \" +\n                                 std::string(http_errno_name(HTTP_PARSER_ERRNO(&parser_))));\n  }\n\n  return rc;\n}\n\nvoid ConnectionImpl::onHeaderField(const char* data, size_t length) {\n  if (header_parsing_state_ == HeaderParsingState::Done) {\n    // Ignore trailers.\n    return;\n  }\n\n  if (header_parsing_state_ == HeaderParsingState::Value) {\n    completeLastHeader();\n  }\n\n  current_header_field_.append(data, length);\n}\n\nvoid ConnectionImpl::onHeaderValue(const char* data, size_t length) {\n  if (header_parsing_state_ == HeaderParsingState::Done) {\n    // Ignore trailers.\n    return;\n  }\n\n  const absl::string_view header_value = absl::string_view(data, length);\n\n  if (strict_header_validation_) {\n    if (!Http::HeaderUtility::headerIsValid(header_value)) {\n      ENVOY_CONN_LOG(debug, \"invalid header value: {}\", connection_, header_value);\n      error_code_ = Http::Code::BadRequest;\n      sendProtocolError();\n      throw CodecProtocolException(\"http/1.1 protocol error: header value contains invalid chars\");\n    }\n  } else if (header_value.find('\\0') != absl::string_view::npos) {\n    // http-parser should filter for this\n    // (https://tools.ietf.org/html/rfc7230#section-3.2.6), but it doesn't today. HeaderStrings\n    // have an invariant that they must not contain embedded zero characters\n    // (NUL, ASCII 0x0).\n    throw CodecProtocolException(\"http/1.1 protocol error: header value contains NUL\");\n  }\n\n  header_parsing_state_ = HeaderParsingState::Value;\n  current_header_value_.append(data, length);\n\n  const uint32_t total =\n      current_header_field_.size() + current_header_value_.size() + current_header_map_->byteSize();\n  if (total > (max_request_headers_kb_ * 1024)) {\n    error_code_ = Http::Code::RequestHeaderFieldsTooLarge;\n    sendProtocolError();\n    throw CodecProtocolException(\"headers size exceeds limit\");\n  }\n}\n\nint ConnectionImpl::onHeadersCompleteBase() {\n  ENVOY_CONN_LOG(trace, \"headers complete\", connection_);\n  completeLastHeader();\n  if (!(parser_.http_major == 1 && parser_.http_minor == 1)) {\n    // This is not necessarily true, but it's good enough since higher layers only care if this is\n    // HTTP/1.1 or not.\n    protocol_ = Protocol::Http10;\n  }\n  if (Utility::isUpgrade(*current_header_map_)) {\n    // Ignore h2c upgrade requests until we support them.\n    // See https://github.com/envoyproxy/envoy/issues/7161 for details.\n    if (current_header_map_->Upgrade() &&\n        absl::EqualsIgnoreCase(current_header_map_->Upgrade()->value().getStringView(),\n                               Http::Headers::get().UpgradeValues.H2c)) {\n      ENVOY_CONN_LOG(trace, \"removing unsupported h2c upgrade headers.\", connection_);\n      current_header_map_->removeUpgrade();\n      if (current_header_map_->Connection()) {\n        const auto& tokens_to_remove = caseUnorderdSetContainingUpgradeAndHttp2Settings();\n        std::string new_value = StringUtil::removeTokens(\n            current_header_map_->Connection()->value().getStringView(), \",\", tokens_to_remove, \",\");\n        if (new_value.empty()) {\n          current_header_map_->removeConnection();\n        } else {\n          current_header_map_->Connection()->value(new_value);\n        }\n      }\n      current_header_map_->remove(Headers::get().Http2Settings);\n    } else {\n      ENVOY_CONN_LOG(trace, \"codec entering upgrade mode.\", connection_);\n      handling_upgrade_ = true;\n    }\n  }\n\n  int rc = onHeadersComplete(std::move(current_header_map_));\n  current_header_map_.reset();\n  header_parsing_state_ = HeaderParsingState::Done;\n\n  // Returning 2 informs http_parser to not expect a body or further data on this connection.\n  return handling_upgrade_ ? 2 : rc;\n}\n\nvoid ConnectionImpl::onMessageCompleteBase() {\n  ENVOY_CONN_LOG(trace, \"message complete\", connection_);\n  if (handling_upgrade_) {\n    // If this is an upgrade request, swallow the onMessageComplete. The\n    // upgrade payload will be treated as stream body.\n    ASSERT(!deferred_end_stream_headers_);\n    ENVOY_CONN_LOG(trace, \"Pausing parser due to upgrade.\", connection_);\n    http_parser_pause(&parser_, 1);\n    return;\n  }\n  onMessageComplete();\n}\n\nvoid ConnectionImpl::onMessageBeginBase() {\n  ENVOY_CONN_LOG(trace, \"message begin\", connection_);\n  // Make sure that if HTTP/1.0 and HTTP/1.1 requests share a connection Envoy correctly sets\n  // protocol for each request. Envoy defaults to 1.1 but sets the protocol to 1.0 where applicable\n  // in onHeadersCompleteBase\n  protocol_ = Protocol::Http11;\n  ASSERT(!current_header_map_);\n  current_header_map_ = std::make_unique<HeaderMapImpl>();\n  header_parsing_state_ = HeaderParsingState::Field;\n  onMessageBegin();\n}\n\nvoid ConnectionImpl::onResetStreamBase(StreamResetReason reason) {\n  ASSERT(!reset_stream_called_);\n  reset_stream_called_ = true;\n  onResetStream(reason);\n}\n\nServerConnectionImpl::ServerConnectionImpl(Network::Connection& connection, Stats::Scope& stats,\n                                           ServerConnectionCallbacks& callbacks,\n                                           Http1Settings settings, uint32_t max_request_headers_kb)\n    : ConnectionImpl(connection, stats, HTTP_REQUEST, max_request_headers_kb),\n      callbacks_(callbacks), codec_settings_(settings) {}\n\nvoid ServerConnectionImpl::onEncodeComplete() {\n  ASSERT(active_request_);\n  if (active_request_->remote_complete_) {\n    // Only do this if remote is complete. If we are replying before the request is complete the\n    // only logical thing to do is for higher level code to reset() / close the connection so we\n    // leave the request around so that it can fire reset callbacks.\n    active_request_.reset();\n  }\n}\n\nvoid ServerConnectionImpl::handlePath(HeaderMapImpl& headers, unsigned int method) {\n  HeaderString path(Headers::get().Path);\n\n  bool is_connect = (method == HTTP_CONNECT);\n\n  // The url is relative or a wildcard when the method is OPTIONS. Nothing to do here.\n  if (!active_request_->request_url_.getStringView().empty() &&\n      (active_request_->request_url_.getStringView()[0] == '/' ||\n       ((method == HTTP_OPTIONS) && active_request_->request_url_.getStringView()[0] == '*'))) {\n    headers.addViaMove(std::move(path), std::move(active_request_->request_url_));\n    return;\n  }\n\n  // If absolute_urls and/or connect are not going be handled, copy the url and return.\n  // This forces the behavior to be backwards compatible with the old codec behavior.\n  if (!codec_settings_.allow_absolute_url_) {\n    headers.addViaMove(std::move(path), std::move(active_request_->request_url_));\n    return;\n  }\n\n  if (is_connect) {\n    headers.addViaMove(std::move(path), std::move(active_request_->request_url_));\n    return;\n  }\n\n  Utility::Url absolute_url;\n  if (!absolute_url.initialize(active_request_->request_url_.getStringView())) {\n    sendProtocolError();\n    throw CodecProtocolException(\"http/1.1 protocol error: invalid url in request line\");\n  }\n  // RFC7230#5.7\n  // When a proxy receives a request with an absolute-form of\n  // request-target, the proxy MUST ignore the received Host header field\n  // (if any) and instead replace it with the host information of the\n  // request-target. A proxy that forwards such a request MUST generate a\n  // new Host field-value based on the received request-target rather than\n  // forward the received Host field-value.\n  headers.insertHost().value(std::string(absolute_url.host_and_port()));\n\n  headers.insertPath().value(std::string(absolute_url.path_and_query_params()));\n  active_request_->request_url_.clear();\n}\n\nint ServerConnectionImpl::onHeadersComplete(HeaderMapImplPtr&& headers) {\n  // Handle the case where response happens prior to request complete. It's up to upper layer code\n  // to disconnect the connection but we shouldn't fire any more events since it doesn't make\n  // sense.\n  if (active_request_) {\n    const char* method_string = http_method_str(static_cast<http_method>(parser_.method));\n\n    // Inform the response encoder about any HEAD method, so it can set content\n    // length and transfer encoding headers correctly.\n    active_request_->response_encoder_.isResponseToHeadRequest(parser_.method == HTTP_HEAD);\n\n    // Currently, CONNECT is not supported, however; http_parser_parse_url needs to know about\n    // CONNECT\n    handlePath(*headers, parser_.method);\n    ASSERT(active_request_->request_url_.empty());\n\n    headers->insertMethod().value(method_string, strlen(method_string));\n\n    // Determine here whether we have a body or not. This uses the new RFC semantics where the\n    // presence of content-length or chunked transfer-encoding indicates a body vs. a particular\n    // method. If there is no body, we defer raising decodeHeaders() until the parser is flushed\n    // with message complete. This allows upper layers to behave like HTTP/2 and prevents a proxy\n    // scenario where the higher layers stream through and implicitly switch to chunked transfer\n    // encoding because end stream with zero body length has not yet been indicated.\n    if (parser_.flags & F_CHUNKED ||\n        (parser_.content_length > 0 && parser_.content_length != ULLONG_MAX) || handling_upgrade_) {\n      active_request_->request_decoder_->decodeHeaders(std::move(headers), false);\n\n      // If the connection has been closed (or is closing) after decoding headers, pause the parser\n      // so we return control to the caller.\n      if (connection_.state() != Network::Connection::State::Open) {\n        http_parser_pause(&parser_, 1);\n      }\n\n    } else {\n      deferred_end_stream_headers_ = std::move(headers);\n    }\n  }\n\n  return 0;\n}\n\nvoid ServerConnectionImpl::onMessageBegin() {\n  if (!resetStreamCalled()) {\n    ASSERT(!active_request_);\n    active_request_ = std::make_unique<ActiveRequest>(*this);\n    active_request_->request_decoder_ = &callbacks_.newStream(active_request_->response_encoder_);\n  }\n}\n\nvoid ServerConnectionImpl::onUrl(const char* data, size_t length) {\n  if (active_request_) {\n    active_request_->request_url_.append(data, length);\n  }\n}\n\nvoid ServerConnectionImpl::onBody(const char* data, size_t length) {\n  ASSERT(!deferred_end_stream_headers_);\n  if (active_request_) {\n    ENVOY_CONN_LOG(trace, \"body size={}\", connection_, length);\n    Buffer::OwnedImpl buffer(data, length);\n    active_request_->request_decoder_->decodeData(buffer, false);\n  }\n}\n\nvoid ServerConnectionImpl::onMessageComplete() {\n  if (active_request_) {\n    Buffer::OwnedImpl buffer;\n    active_request_->remote_complete_ = true;\n\n    if (deferred_end_stream_headers_) {\n      active_request_->request_decoder_->decodeHeaders(std::move(deferred_end_stream_headers_),\n                                                       true);\n      deferred_end_stream_headers_.reset();\n    } else {\n      active_request_->request_decoder_->decodeData(buffer, true);\n    }\n  }\n\n  // Always pause the parser so that the calling code can process 1 request at a time and apply\n  // back pressure. However this means that the calling code needs to detect if there is more data\n  // in the buffer and dispatch it again.\n  http_parser_pause(&parser_, 1);\n}\n\nvoid ServerConnectionImpl::onResetStream(StreamResetReason reason) {\n  ASSERT(active_request_);\n  active_request_->response_encoder_.runResetCallbacks(reason);\n  active_request_.reset();\n}\n\nvoid ServerConnectionImpl::sendProtocolError() {\n  // We do this here because we may get a protocol error before we have a logical stream. Higher\n  // layers can only operate on streams, so there is no coherent way to allow them to send an error\n  // \"out of band.\" On one hand this is kind of a hack but on the other hand it normalizes HTTP/1.1\n  // to look more like HTTP/2 to higher layers.\n  if (!active_request_ || !active_request_->response_encoder_.startedResponse()) {\n    Buffer::OwnedImpl bad_request_response(\n        fmt::format(\"HTTP/1.1 {} {}\\r\\ncontent-length: 0\\r\\nconnection: close\\r\\n\\r\\n\",\n                    std::to_string(enumToInt(error_code_)), CodeUtility::toString(error_code_)));\n\n    connection_.write(bad_request_response, false);\n  }\n}\n\nvoid ServerConnectionImpl::onAboveHighWatermark() {\n  if (active_request_) {\n    active_request_->response_encoder_.runHighWatermarkCallbacks();\n  }\n}\nvoid ServerConnectionImpl::onBelowLowWatermark() {\n  if (active_request_) {\n    active_request_->response_encoder_.runLowWatermarkCallbacks();\n  }\n}\n\nClientConnectionImpl::ClientConnectionImpl(Network::Connection& connection, Stats::Scope& stats,\n                                           ConnectionCallbacks&)\n    : ConnectionImpl(connection, stats, HTTP_RESPONSE, MAX_RESPONSE_HEADERS_KB) {}\n\nbool ClientConnectionImpl::cannotHaveBody() {\n  if ((!pending_responses_.empty() && pending_responses_.front().head_request_) ||\n      parser_.status_code == 204 || parser_.status_code == 304 ||\n      (parser_.status_code >= 200 && parser_.content_length == 0)) {\n    return true;\n  } else {\n    return false;\n  }\n}\n\nStreamEncoder& ClientConnectionImpl::newStream(StreamDecoder& response_decoder) {\n  if (resetStreamCalled()) {\n    throw CodecClientException(\"cannot create new streams after calling reset\");\n  }\n\n  // If reads were disabled due to flow control, we expect reads to always be enabled again before\n  // reusing this connection. This is done when the final pipeline response is received.\n  ASSERT(connection_.readEnabled());\n\n  request_encoder_ = std::make_unique<RequestStreamEncoderImpl>(*this);\n  pending_responses_.emplace_back(&response_decoder);\n  return *request_encoder_;\n}\n\nvoid ClientConnectionImpl::onEncodeHeaders(const HeaderMap& headers) {\n  if (headers.Method()->value() == Headers::get().MethodValues.Head.c_str()) {\n    pending_responses_.back().head_request_ = true;\n  }\n}\n\nint ClientConnectionImpl::onHeadersComplete(HeaderMapImplPtr&& headers) {\n  headers->insertStatus().value(parser_.status_code);\n\n  // Handle the case where the client is closing a kept alive connection (by sending a 408\n  // with a 'Connection: close' header). In this case we just let response flush out followed\n  // by the remote close.\n  if (pending_responses_.empty() && !resetStreamCalled()) {\n    throw PrematureResponseException(std::move(headers));\n  } else if (!pending_responses_.empty()) {\n    if (parser_.status_code == 100) {\n      // http-parser treats 100 continue headers as their own complete response.\n      // Swallow the spurious onMessageComplete and continue processing.\n      ignore_message_complete_for_100_continue_ = true;\n      pending_responses_.front().decoder_->decode100ContinueHeaders(std::move(headers));\n    } else if (cannotHaveBody()) {\n      deferred_end_stream_headers_ = std::move(headers);\n    } else {\n      pending_responses_.front().decoder_->decodeHeaders(std::move(headers), false);\n    }\n  }\n\n  // Here we deal with cases where the response cannot have a body, but http_parser does not deal\n  // with it for us.\n  return cannotHaveBody() ? 1 : 0;\n}\n\nvoid ClientConnectionImpl::onBody(const char* data, size_t length) {\n  ASSERT(!deferred_end_stream_headers_);\n  if (!pending_responses_.empty()) {\n    Buffer::OwnedImpl buffer;\n    buffer.add(data, length);\n    pending_responses_.front().decoder_->decodeData(buffer, false);\n  }\n}\n\nvoid ClientConnectionImpl::onMessageComplete() {\n  ENVOY_CONN_LOG(trace, \"message complete\", connection_);\n  if (ignore_message_complete_for_100_continue_) {\n    ignore_message_complete_for_100_continue_ = false;\n    return;\n  }\n  if (!pending_responses_.empty()) {\n    // After calling decodeData() with end stream set to true, we should no longer be able to reset.\n    PendingResponse response = pending_responses_.front();\n    pending_responses_.pop_front();\n\n    // Streams are responsible for unwinding any outstanding readDisable(true)\n    // calls done on the underlying connection as they are destroyed. As this is\n    // the only place a HTTP/1 stream is destroyed where the Network::Connection is\n    // reused, unwind any outstanding readDisable() calls here. Only do this if there are no\n    // pipelined responses remaining. Also do this before we dispatch end_stream in case the caller\n    // immediately reuses the connection.\n    if (pending_responses_.empty()) {\n      while (!connection_.readEnabled()) {\n        connection_.readDisable(false);\n      }\n    }\n\n    if (deferred_end_stream_headers_) {\n      response.decoder_->decodeHeaders(std::move(deferred_end_stream_headers_), true);\n      deferred_end_stream_headers_.reset();\n    } else {\n      Buffer::OwnedImpl buffer;\n      response.decoder_->decodeData(buffer, true);\n    }\n  }\n}\n\nvoid ClientConnectionImpl::onResetStream(StreamResetReason reason) {\n  // Only raise reset if we did not already dispatch a complete response.\n  if (!pending_responses_.empty()) {\n    pending_responses_.clear();\n    request_encoder_->runResetCallbacks(reason);\n  }\n}\n\nvoid ClientConnectionImpl::onAboveHighWatermark() {\n  // This should never happen without an active stream/request.\n  ASSERT(!pending_responses_.empty());\n  request_encoder_->runHighWatermarkCallbacks();\n}\n\nvoid ClientConnectionImpl::onBelowLowWatermark() {\n  // This can get called without an active stream/request when upstream decides to do bad things\n  // such as sending multiple responses to the same request, causing us to close the connection, but\n  // in doing so go below low watermark.\n  if (!pending_responses_.empty()) {\n    request_encoder_->runLowWatermarkCallbacks();\n  }\n}\n\n} // namespace Http1\n} // namespace Http\n} // namespace Envoy\n", "#include \"common/http/http2/codec_impl.h\"\n\n#include <cstdint>\n#include <memory>\n#include <vector>\n\n#include \"envoy/event/dispatcher.h\"\n#include \"envoy/http/codes.h\"\n#include \"envoy/http/header_map.h\"\n#include \"envoy/network/connection.h\"\n#include \"envoy/stats/scope.h\"\n\n#include \"common/common/assert.h\"\n#include \"common/common/cleanup.h\"\n#include \"common/common/enum_to_int.h\"\n#include \"common/common/fmt.h\"\n#include \"common/common/stack_array.h\"\n#include \"common/common/utility.h\"\n#include \"common/http/codes.h\"\n#include \"common/http/exception.h\"\n#include \"common/http/headers.h\"\n\nnamespace Envoy {\nnamespace Http {\nnamespace Http2 {\n\nbool Utility::reconstituteCrumbledCookies(const HeaderString& key, const HeaderString& value,\n                                          HeaderString& cookies) {\n  if (key != Headers::get().Cookie.get().c_str()) {\n    return false;\n  }\n\n  if (!cookies.empty()) {\n    cookies.append(\"; \", 2);\n  }\n\n  const absl::string_view value_view = value.getStringView();\n  cookies.append(value_view.data(), value_view.size());\n  return true;\n}\n\nConnectionImpl::Http2Callbacks ConnectionImpl::http2_callbacks_;\n\n/**\n * Helper to remove const during a cast. nghttp2 takes non-const pointers for headers even though\n * it copies them.\n */\ntemplate <typename T> static T* remove_const(const void* object) {\n  return const_cast<T*>(reinterpret_cast<const T*>(object));\n}\n\nConnectionImpl::StreamImpl::StreamImpl(ConnectionImpl& parent, uint32_t buffer_limit)\n    : parent_(parent), headers_(new HeaderMapImpl()), local_end_stream_sent_(false),\n      remote_end_stream_(false), data_deferred_(false),\n      waiting_for_non_informational_headers_(false),\n      pending_receive_buffer_high_watermark_called_(false),\n      pending_send_buffer_high_watermark_called_(false), reset_due_to_messaging_error_(false) {\n  if (buffer_limit > 0) {\n    setWriteBufferWatermarks(buffer_limit / 2, buffer_limit);\n  }\n}\n\nstatic void insertHeader(std::vector<nghttp2_nv>& headers, const HeaderEntry& header) {\n  uint8_t flags = 0;\n  if (header.key().type() == HeaderString::Type::Reference) {\n    flags |= NGHTTP2_NV_FLAG_NO_COPY_NAME;\n  }\n  if (header.value().type() == HeaderString::Type::Reference) {\n    flags |= NGHTTP2_NV_FLAG_NO_COPY_VALUE;\n  }\n  const absl::string_view header_key = header.key().getStringView();\n  const absl::string_view header_value = header.value().getStringView();\n  headers.push_back({remove_const<uint8_t>(header_key.data()),\n                     remove_const<uint8_t>(header_value.data()), header_key.size(),\n                     header_value.size(), flags});\n}\n\nvoid ConnectionImpl::StreamImpl::buildHeaders(std::vector<nghttp2_nv>& final_headers,\n                                              const HeaderMap& headers) {\n  final_headers.reserve(headers.size());\n  headers.iterate(\n      [](const HeaderEntry& header, void* context) -> HeaderMap::Iterate {\n        std::vector<nghttp2_nv>* final_headers = static_cast<std::vector<nghttp2_nv>*>(context);\n        insertHeader(*final_headers, header);\n        return HeaderMap::Iterate::Continue;\n      },\n      &final_headers);\n}\n\nvoid ConnectionImpl::StreamImpl::encode100ContinueHeaders(const HeaderMap& headers) {\n  ASSERT(headers.Status()->value() == \"100\");\n  encodeHeaders(headers, false);\n}\n\nvoid ConnectionImpl::StreamImpl::encodeHeaders(const HeaderMap& headers, bool end_stream) {\n  std::vector<nghttp2_nv> final_headers;\n\n  // This must exist outside of the scope of isUpgrade as the underlying memory is\n  // needed until submitHeaders has been called.\n  Http::HeaderMapPtr modified_headers;\n  if (Http::Utility::isUpgrade(headers)) {\n    modified_headers = std::make_unique<Http::HeaderMapImpl>(headers);\n    transformUpgradeFromH1toH2(*modified_headers);\n    buildHeaders(final_headers, *modified_headers);\n  } else {\n    buildHeaders(final_headers, headers);\n  }\n\n  nghttp2_data_provider provider;\n  if (!end_stream) {\n    provider.source.ptr = this;\n    provider.read_callback = [](nghttp2_session*, int32_t, uint8_t*, size_t length,\n                                uint32_t* data_flags, nghttp2_data_source* source,\n                                void*) -> ssize_t {\n      return static_cast<StreamImpl*>(source->ptr)->onDataSourceRead(length, data_flags);\n    };\n  }\n\n  local_end_stream_ = end_stream;\n  submitHeaders(final_headers, end_stream ? nullptr : &provider);\n  parent_.sendPendingFrames();\n}\n\nvoid ConnectionImpl::StreamImpl::encodeTrailers(const HeaderMap& trailers) {\n  ASSERT(!local_end_stream_);\n  local_end_stream_ = true;\n  if (pending_send_data_.length() > 0) {\n    // In this case we want trailers to come after we release all pending body data that is\n    // waiting on window updates. We need to save the trailers so that we can emit them later.\n    ASSERT(!pending_trailers_);\n    pending_trailers_ = std::make_unique<HeaderMapImpl>(trailers);\n  } else {\n    submitTrailers(trailers);\n    parent_.sendPendingFrames();\n  }\n}\n\nvoid ConnectionImpl::StreamImpl::encodeMetadata(const MetadataMapVector& metadata_map_vector) {\n  ASSERT(parent_.allow_metadata_);\n\n  getMetadataEncoder().createPayload(metadata_map_vector);\n\n  // Estimates the number of frames to generate, and breaks the while loop when the size is reached\n  // in case submitting succeeds and packing fails, and we don't get error from packing.\n  const size_t frame_count = metadata_encoder_->frameCountUpperBound();\n  size_t count = 0;\n  // Keep submitting extension frames if there is payload left in the encoder.\n  while (metadata_encoder_->hasNextFrame() && count++ <= frame_count) {\n    submitMetadata();\n    parent_.sendPendingFrames();\n  }\n\n  ASSERT(!metadata_encoder_->hasNextFrame());\n}\n\nvoid ConnectionImpl::StreamImpl::readDisable(bool disable) {\n  ENVOY_CONN_LOG(debug, \"Stream {} {}, unconsumed_bytes {} read_disable_count {}\",\n                 parent_.connection_, stream_id_, (disable ? \"disabled\" : \"enabled\"),\n                 unconsumed_bytes_, read_disable_count_);\n  if (disable) {\n    ++read_disable_count_;\n  } else {\n    ASSERT(read_disable_count_ > 0);\n    --read_disable_count_;\n    if (!buffers_overrun()) {\n      nghttp2_session_consume(parent_.session_, stream_id_, unconsumed_bytes_);\n      unconsumed_bytes_ = 0;\n      parent_.sendPendingFrames();\n    }\n  }\n}\n\nvoid ConnectionImpl::StreamImpl::pendingRecvBufferHighWatermark() {\n  ENVOY_CONN_LOG(debug, \"recv buffer over limit \", parent_.connection_);\n  ASSERT(!pending_receive_buffer_high_watermark_called_);\n  pending_receive_buffer_high_watermark_called_ = true;\n  readDisable(true);\n}\n\nvoid ConnectionImpl::StreamImpl::pendingRecvBufferLowWatermark() {\n  ENVOY_CONN_LOG(debug, \"recv buffer under limit \", parent_.connection_);\n  ASSERT(pending_receive_buffer_high_watermark_called_);\n  pending_receive_buffer_high_watermark_called_ = false;\n  readDisable(false);\n}\n\nvoid ConnectionImpl::StreamImpl::decodeHeaders() {\n  maybeTransformUpgradeFromH2ToH1();\n  decoder_->decodeHeaders(std::move(headers_), remote_end_stream_);\n}\n\nvoid ConnectionImpl::StreamImpl::pendingSendBufferHighWatermark() {\n  ENVOY_CONN_LOG(debug, \"send buffer over limit \", parent_.connection_);\n  ASSERT(!pending_send_buffer_high_watermark_called_);\n  pending_send_buffer_high_watermark_called_ = true;\n  runHighWatermarkCallbacks();\n}\n\nvoid ConnectionImpl::StreamImpl::pendingSendBufferLowWatermark() {\n  ENVOY_CONN_LOG(debug, \"send buffer under limit \", parent_.connection_);\n  ASSERT(pending_send_buffer_high_watermark_called_);\n  pending_send_buffer_high_watermark_called_ = false;\n  runLowWatermarkCallbacks();\n}\n\nvoid ConnectionImpl::StreamImpl::saveHeader(HeaderString&& name, HeaderString&& value) {\n  if (!Utility::reconstituteCrumbledCookies(name, value, cookies_)) {\n    headers_->addViaMove(std::move(name), std::move(value));\n  }\n}\n\nvoid ConnectionImpl::StreamImpl::submitTrailers(const HeaderMap& trailers) {\n  std::vector<nghttp2_nv> final_headers;\n  buildHeaders(final_headers, trailers);\n  int rc =\n      nghttp2_submit_trailer(parent_.session_, stream_id_, &final_headers[0], final_headers.size());\n  ASSERT(rc == 0);\n}\n\nvoid ConnectionImpl::StreamImpl::submitMetadata() {\n  ASSERT(stream_id_ > 0);\n  const int result =\n      nghttp2_submit_extension(parent_.session_, METADATA_FRAME_TYPE,\n                               metadata_encoder_->nextEndMetadata(), stream_id_, nullptr);\n  ASSERT(result == 0);\n}\n\nssize_t ConnectionImpl::StreamImpl::onDataSourceRead(uint64_t length, uint32_t* data_flags) {\n  if (pending_send_data_.length() == 0 && !local_end_stream_) {\n    ASSERT(!data_deferred_);\n    data_deferred_ = true;\n    return NGHTTP2_ERR_DEFERRED;\n  } else {\n    *data_flags |= NGHTTP2_DATA_FLAG_NO_COPY;\n    if (local_end_stream_ && pending_send_data_.length() <= length) {\n      *data_flags |= NGHTTP2_DATA_FLAG_EOF;\n      if (pending_trailers_) {\n        // We need to tell the library to not set end stream so that we can emit the trailers.\n        *data_flags |= NGHTTP2_DATA_FLAG_NO_END_STREAM;\n        submitTrailers(*pending_trailers_);\n        pending_trailers_.reset();\n      }\n    }\n\n    return std::min(length, pending_send_data_.length());\n  }\n}\n\nint ConnectionImpl::StreamImpl::onDataSourceSend(const uint8_t* framehd, size_t length) {\n  // In this callback we are writing out a raw DATA frame without copying. nghttp2 assumes that we\n  // \"just know\" that the frame header is 9 bytes.\n  // https://nghttp2.org/documentation/types.html#c.nghttp2_send_data_callback\n  static const uint64_t FRAME_HEADER_SIZE = 9;\n\n  parent_.outbound_data_frames_++;\n\n  Buffer::OwnedImpl output;\n  if (!parent_.addOutboundFrameFragment(output, framehd, FRAME_HEADER_SIZE)) {\n    ENVOY_CONN_LOG(debug, \"error sending data frame: Too many frames in the outbound queue\",\n                   parent_.connection_);\n    return NGHTTP2_ERR_FLOODED;\n  }\n\n  output.move(pending_send_data_, length);\n  parent_.connection_.write(output, false);\n  return 0;\n}\n\nvoid ConnectionImpl::ClientStreamImpl::submitHeaders(const std::vector<nghttp2_nv>& final_headers,\n                                                     nghttp2_data_provider* provider) {\n  ASSERT(stream_id_ == -1);\n  stream_id_ = nghttp2_submit_request(parent_.session_, nullptr, &final_headers.data()[0],\n                                      final_headers.size(), provider, base());\n  ASSERT(stream_id_ > 0);\n}\n\nvoid ConnectionImpl::ServerStreamImpl::submitHeaders(const std::vector<nghttp2_nv>& final_headers,\n                                                     nghttp2_data_provider* provider) {\n  ASSERT(stream_id_ != -1);\n  int rc = nghttp2_submit_response(parent_.session_, stream_id_, &final_headers.data()[0],\n                                   final_headers.size(), provider);\n  ASSERT(rc == 0);\n}\n\nvoid ConnectionImpl::StreamImpl::encodeData(Buffer::Instance& data, bool end_stream) {\n  ASSERT(!local_end_stream_);\n  local_end_stream_ = end_stream;\n  pending_send_data_.move(data);\n  if (data_deferred_) {\n    int rc = nghttp2_session_resume_data(parent_.session_, stream_id_);\n    ASSERT(rc == 0);\n\n    data_deferred_ = false;\n  }\n\n  parent_.sendPendingFrames();\n}\n\nvoid ConnectionImpl::StreamImpl::resetStream(StreamResetReason reason) {\n  // Higher layers expect calling resetStream() to immediately raise reset callbacks.\n  runResetCallbacks(reason);\n\n  // If we submit a reset, nghttp2 will cancel outbound frames that have not yet been sent.\n  // We want these frames to go out so we defer the reset until we send all of the frames that\n  // end the local stream.\n  if (local_end_stream_ && !local_end_stream_sent_) {\n    parent_.pending_deferred_reset_ = true;\n    deferred_reset_ = reason;\n    ENVOY_CONN_LOG(trace, \"deferred reset stream\", parent_.connection_);\n  } else {\n    resetStreamWorker(reason);\n  }\n\n  // We must still call sendPendingFrames() in both the deferred and not deferred path. This forces\n  // the cleanup logic to run which will reset the stream in all cases if all data frames could not\n  // be sent.\n  parent_.sendPendingFrames();\n}\n\nvoid ConnectionImpl::StreamImpl::resetStreamWorker(StreamResetReason reason) {\n  int rc = nghttp2_submit_rst_stream(parent_.session_, NGHTTP2_FLAG_NONE, stream_id_,\n                                     reason == StreamResetReason::LocalRefusedStreamReset\n                                         ? NGHTTP2_REFUSED_STREAM\n                                         : NGHTTP2_NO_ERROR);\n  ASSERT(rc == 0);\n}\n\nMetadataEncoder& ConnectionImpl::StreamImpl::getMetadataEncoder() {\n  if (metadata_encoder_ == nullptr) {\n    metadata_encoder_ = std::make_unique<MetadataEncoder>();\n  }\n  return *metadata_encoder_;\n}\n\nMetadataDecoder& ConnectionImpl::StreamImpl::getMetadataDecoder() {\n  if (metadata_decoder_ == nullptr) {\n    auto cb = [this](MetadataMapPtr&& metadata_map_ptr) {\n      this->onMetadataDecoded(std::move(metadata_map_ptr));\n    };\n    metadata_decoder_ = std::make_unique<MetadataDecoder>(cb);\n  }\n  return *metadata_decoder_;\n}\n\nvoid ConnectionImpl::StreamImpl::onMetadataDecoded(MetadataMapPtr&& metadata_map_ptr) {\n  decoder_->decodeMetadata(std::move(metadata_map_ptr));\n}\n\nnamespace {\n\nconst char InvalidHttpMessagingOverrideKey[] =\n    \"envoy.reloadable_features.http2_protocol_options.stream_error_on_invalid_http_messaging\";\nconst char MaxOutboundFramesOverrideKey[] =\n    \"envoy.reloadable_features.http2_protocol_options.max_outbound_frames\";\nconst char MaxOutboundControlFramesOverrideKey[] =\n    \"envoy.reloadable_features.http2_protocol_options.max_outbound_control_frames\";\nconst char MaxConsecutiveInboundFramesWithEmptyPayloadOverrideKey[] =\n    \"envoy.reloadable_features.http2_protocol_options.\"\n    \"max_consecutive_inbound_frames_with_empty_payload\";\nconst char MaxInboundPriorityFramesPerStreamOverrideKey[] =\n    \"envoy.reloadable_features.http2_protocol_options.max_inbound_priority_frames_per_stream\";\nconst char MaxInboundWindowUpdateFramesPerDataFrameSentOverrideKey[] =\n    \"envoy.reloadable_features.http2_protocol_options.\"\n    \"max_inbound_window_update_frames_per_data_frame_sent\";\n\nbool checkRuntimeOverride(bool config_value, const char* override_key) {\n  return Runtime::runtimeFeatureEnabled(override_key) ? true : config_value;\n}\n\n} // namespace\n\nConnectionImpl::ConnectionImpl(Network::Connection& connection, Stats::Scope& stats,\n                               const Http2Settings& http2_settings,\n                               const uint32_t max_request_headers_kb)\n    : stats_{ALL_HTTP2_CODEC_STATS(POOL_COUNTER_PREFIX(stats, \"http2.\"))}, connection_(connection),\n      max_request_headers_kb_(max_request_headers_kb),\n      per_stream_buffer_limit_(http2_settings.initial_stream_window_size_),\n      stream_error_on_invalid_http_messaging_(checkRuntimeOverride(\n          http2_settings.stream_error_on_invalid_http_messaging_, InvalidHttpMessagingOverrideKey)),\n      flood_detected_(false),\n      max_outbound_frames_(\n          Runtime::getInteger(MaxOutboundFramesOverrideKey, http2_settings.max_outbound_frames_)),\n      frame_buffer_releasor_([this](const Buffer::OwnedBufferFragmentImpl* fragment) {\n        releaseOutboundFrame(fragment);\n      }),\n      max_outbound_control_frames_(Runtime::getInteger(\n          MaxOutboundControlFramesOverrideKey, http2_settings.max_outbound_control_frames_)),\n      control_frame_buffer_releasor_([this](const Buffer::OwnedBufferFragmentImpl* fragment) {\n        releaseOutboundControlFrame(fragment);\n      }),\n      max_consecutive_inbound_frames_with_empty_payload_(\n          Runtime::getInteger(MaxConsecutiveInboundFramesWithEmptyPayloadOverrideKey,\n                              http2_settings.max_consecutive_inbound_frames_with_empty_payload_)),\n      max_inbound_priority_frames_per_stream_(\n          Runtime::getInteger(MaxInboundPriorityFramesPerStreamOverrideKey,\n                              http2_settings.max_inbound_priority_frames_per_stream_)),\n      max_inbound_window_update_frames_per_data_frame_sent_(Runtime::getInteger(\n          MaxInboundWindowUpdateFramesPerDataFrameSentOverrideKey,\n          http2_settings.max_inbound_window_update_frames_per_data_frame_sent_)),\n      dispatching_(false), raised_goaway_(false), pending_deferred_reset_(false) {}\n\nConnectionImpl::~ConnectionImpl() { nghttp2_session_del(session_); }\n\nvoid ConnectionImpl::dispatch(Buffer::Instance& data) {\n  ENVOY_CONN_LOG(trace, \"dispatching {} bytes\", connection_, data.length());\n  uint64_t num_slices = data.getRawSlices(nullptr, 0);\n  STACK_ARRAY(slices, Buffer::RawSlice, num_slices);\n  data.getRawSlices(slices.begin(), num_slices);\n  for (const Buffer::RawSlice& slice : slices) {\n    dispatching_ = true;\n    ssize_t rc =\n        nghttp2_session_mem_recv(session_, static_cast<const uint8_t*>(slice.mem_), slice.len_);\n    if (rc == NGHTTP2_ERR_FLOODED || flood_detected_) {\n      throw FrameFloodException(\n          \"Flooding was detected in this HTTP/2 session, and it must be closed\");\n    }\n    if (rc != static_cast<ssize_t>(slice.len_)) {\n      throw CodecProtocolException(fmt::format(\"{}\", nghttp2_strerror(rc)));\n    }\n\n    dispatching_ = false;\n  }\n\n  ENVOY_CONN_LOG(trace, \"dispatched {} bytes\", connection_, data.length());\n  data.drain(data.length());\n\n  // Decoding incoming frames can generate outbound frames so flush pending.\n  sendPendingFrames();\n}\n\nConnectionImpl::StreamImpl* ConnectionImpl::getStream(int32_t stream_id) {\n  return static_cast<StreamImpl*>(nghttp2_session_get_stream_user_data(session_, stream_id));\n}\n\nint ConnectionImpl::onData(int32_t stream_id, const uint8_t* data, size_t len) {\n  StreamImpl* stream = getStream(stream_id);\n  // If this results in buffering too much data, the watermark buffer will call\n  // pendingRecvBufferHighWatermark, resulting in ++read_disable_count_\n  stream->pending_recv_data_.add(data, len);\n  // Update the window to the peer unless some consumer of this stream's data has hit a flow control\n  // limit and disabled reads on this stream\n  if (!stream->buffers_overrun()) {\n    nghttp2_session_consume(session_, stream_id, len);\n  } else {\n    stream->unconsumed_bytes_ += len;\n  }\n  return 0;\n}\n\nvoid ConnectionImpl::goAway() {\n  int rc = nghttp2_submit_goaway(session_, NGHTTP2_FLAG_NONE,\n                                 nghttp2_session_get_last_proc_stream_id(session_),\n                                 NGHTTP2_NO_ERROR, nullptr, 0);\n  ASSERT(rc == 0);\n\n  sendPendingFrames();\n}\n\nvoid ConnectionImpl::shutdownNotice() {\n  int rc = nghttp2_submit_shutdown_notice(session_);\n  ASSERT(rc == 0);\n\n  sendPendingFrames();\n}\n\nint ConnectionImpl::onBeforeFrameReceived(const nghttp2_frame_hd* hd) {\n  ENVOY_CONN_LOG(trace, \"about to recv frame type={}, flags={}\", connection_,\n                 static_cast<uint64_t>(hd->type), static_cast<uint64_t>(hd->flags));\n\n  // Track all the frames without padding here, since this is the only callback we receive\n  // for some of them (e.g. CONTINUATION frame, frames sent on closed streams, etc.).\n  // HEADERS frame is tracked in onBeginHeaders(), DATA frame is tracked in onFrameReceived().\n  if (hd->type != NGHTTP2_HEADERS && hd->type != NGHTTP2_DATA) {\n    if (!trackInboundFrames(hd, 0)) {\n      return NGHTTP2_ERR_FLOODED;\n    }\n  }\n\n  return 0;\n}\n\nint ConnectionImpl::onFrameReceived(const nghttp2_frame* frame) {\n  ENVOY_CONN_LOG(trace, \"recv frame type={}\", connection_, static_cast<uint64_t>(frame->hd.type));\n\n  // onFrameReceived() is called with a complete HEADERS frame assembled from all the HEADERS\n  // and CONTINUATION frames, but we track them separately: HEADERS frames in onBeginHeaders()\n  // and CONTINUATION frames in onBeforeFrameReceived().\n  ASSERT(frame->hd.type != NGHTTP2_CONTINUATION);\n\n  if (frame->hd.type == NGHTTP2_DATA) {\n    if (!trackInboundFrames(&frame->hd, frame->data.padlen)) {\n      return NGHTTP2_ERR_FLOODED;\n    }\n  }\n\n  // Only raise GOAWAY once, since we don't currently expose stream information. Shutdown\n  // notifications are the same as a normal GOAWAY.\n  if (frame->hd.type == NGHTTP2_GOAWAY && !raised_goaway_) {\n    ASSERT(frame->hd.stream_id == 0);\n    raised_goaway_ = true;\n    callbacks().onGoAway();\n    return 0;\n  }\n\n  StreamImpl* stream = getStream(frame->hd.stream_id);\n  if (!stream) {\n    return 0;\n  }\n\n  switch (frame->hd.type) {\n  case NGHTTP2_HEADERS: {\n    stream->remote_end_stream_ = frame->hd.flags & NGHTTP2_FLAG_END_STREAM;\n    if (!stream->cookies_.empty()) {\n      HeaderString key(Headers::get().Cookie);\n      stream->headers_->addViaMove(std::move(key), std::move(stream->cookies_));\n    }\n\n    switch (frame->headers.cat) {\n    case NGHTTP2_HCAT_RESPONSE: {\n      if (CodeUtility::is1xx(Http::Utility::getResponseStatus(*stream->headers_))) {\n        stream->waiting_for_non_informational_headers_ = true;\n      }\n\n      if (stream->headers_->Status()->value() == \"100\") {\n        ASSERT(!stream->remote_end_stream_);\n        stream->decoder_->decode100ContinueHeaders(std::move(stream->headers_));\n      } else {\n        stream->decodeHeaders();\n      }\n      break;\n    }\n\n    case NGHTTP2_HCAT_REQUEST: {\n      stream->decodeHeaders();\n      break;\n    }\n\n    case NGHTTP2_HCAT_HEADERS: {\n      // It's possible that we are waiting to send a deferred reset, so only raise headers/trailers\n      // if local is not complete.\n      if (!stream->deferred_reset_) {\n        if (!stream->waiting_for_non_informational_headers_) {\n          if (!stream->remote_end_stream_) {\n            // This indicates we have received more headers frames than Envoy\n            // supports. Even if this is valid HTTP (something like 103 early hints) fail here\n            // rather than trying to push unexpected headers through the Envoy pipeline as that\n            // will likely result in Envoy crashing.\n            // It would be cleaner to reset the stream rather than reset the/ entire connection but\n            // it's also slightly more dangerous so currently we err on the side of safety.\n            stats_.too_many_header_frames_.inc();\n            throw CodecProtocolException(\"Unexpected 'trailers' with no end stream.\");\n          } else {\n            stream->decoder_->decodeTrailers(std::move(stream->headers_));\n          }\n        } else {\n          ASSERT(!nghttp2_session_check_server_session(session_));\n          stream->waiting_for_non_informational_headers_ = false;\n\n          // Even if we have :status 100 in the client case in a response, when\n          // we received a 1xx to start out with, nghttp2 message checking\n          // guarantees proper flow here.\n          stream->decodeHeaders();\n        }\n      }\n\n      break;\n    }\n\n    default:\n      // We do not currently support push.\n      NOT_IMPLEMENTED_GCOVR_EXCL_LINE;\n    }\n\n    stream->headers_.reset();\n    break;\n  }\n  case NGHTTP2_DATA: {\n    stream->remote_end_stream_ = frame->hd.flags & NGHTTP2_FLAG_END_STREAM;\n\n    // It's possible that we are waiting to send a deferred reset, so only raise data if local\n    // is not complete.\n    if (!stream->deferred_reset_) {\n      stream->decoder_->decodeData(stream->pending_recv_data_, stream->remote_end_stream_);\n    }\n\n    stream->pending_recv_data_.drain(stream->pending_recv_data_.length());\n    break;\n  }\n  case NGHTTP2_RST_STREAM: {\n    ENVOY_CONN_LOG(trace, \"remote reset: {}\", connection_, frame->rst_stream.error_code);\n    stats_.rx_reset_.inc();\n    break;\n  }\n  }\n\n  return 0;\n}\n\nint ConnectionImpl::onFrameSend(const nghttp2_frame* frame) {\n  // The nghttp2 library does not cleanly give us a way to determine whether we received invalid\n  // data from our peer. Sometimes it raises the invalid frame callback, and sometimes it does not.\n  // In all cases however it will attempt to send a GOAWAY frame with an error status. If we see\n  // an outgoing frame of this type, we will return an error code so that we can abort execution.\n  ENVOY_CONN_LOG(trace, \"sent frame type={}\", connection_, static_cast<uint64_t>(frame->hd.type));\n  switch (frame->hd.type) {\n  case NGHTTP2_GOAWAY: {\n    ENVOY_CONN_LOG(debug, \"sent goaway code={}\", connection_, frame->goaway.error_code);\n    if (frame->goaway.error_code != NGHTTP2_NO_ERROR) {\n      return NGHTTP2_ERR_CALLBACK_FAILURE;\n    }\n    break;\n  }\n\n  case NGHTTP2_RST_STREAM: {\n    ENVOY_CONN_LOG(debug, \"sent reset code={}\", connection_, frame->rst_stream.error_code);\n    stats_.tx_reset_.inc();\n    break;\n  }\n\n  case NGHTTP2_HEADERS:\n  case NGHTTP2_DATA: {\n    StreamImpl* stream = getStream(frame->hd.stream_id);\n    stream->local_end_stream_sent_ = frame->hd.flags & NGHTTP2_FLAG_END_STREAM;\n    break;\n  }\n  }\n\n  return 0;\n}\n\nint ConnectionImpl::onInvalidFrame(int32_t stream_id, int error_code) {\n  ENVOY_CONN_LOG(debug, \"invalid frame: {} on stream {}\", connection_, nghttp2_strerror(error_code),\n                 stream_id);\n\n  if (error_code == NGHTTP2_ERR_HTTP_HEADER || error_code == NGHTTP2_ERR_HTTP_MESSAGING) {\n    stats_.rx_messaging_error_.inc();\n\n    if (stream_error_on_invalid_http_messaging_) {\n      // The stream is about to be closed due to an invalid header or messaging. Don't kill the\n      // entire connection if one stream has bad headers or messaging.\n      StreamImpl* stream = getStream(stream_id);\n      if (stream != nullptr) {\n        // See comment below in onStreamClose() for why we do this.\n        stream->reset_due_to_messaging_error_ = true;\n      }\n      return 0;\n    }\n  }\n\n  // Cause dispatch to return with an error code.\n  return NGHTTP2_ERR_CALLBACK_FAILURE;\n}\n\nint ConnectionImpl::onBeforeFrameSend(const nghttp2_frame* frame) {\n  ENVOY_CONN_LOG(trace, \"about to send frame type={}, flags={}\", connection_,\n                 static_cast<uint64_t>(frame->hd.type), static_cast<uint64_t>(frame->hd.flags));\n  ASSERT(!is_outbound_flood_monitored_control_frame_);\n  // Flag flood monitored outbound control frames.\n  is_outbound_flood_monitored_control_frame_ =\n      ((frame->hd.type == NGHTTP2_PING || frame->hd.type == NGHTTP2_SETTINGS) &&\n       frame->hd.flags & NGHTTP2_FLAG_ACK) ||\n      frame->hd.type == NGHTTP2_RST_STREAM;\n  return 0;\n}\n\nvoid ConnectionImpl::incrementOutboundFrameCount(bool is_outbound_flood_monitored_control_frame) {\n  ++outbound_frames_;\n  if (is_outbound_flood_monitored_control_frame) {\n    ++outbound_control_frames_;\n  }\n  checkOutboundQueueLimits();\n}\n\nbool ConnectionImpl::addOutboundFrameFragment(Buffer::OwnedImpl& output, const uint8_t* data,\n                                              size_t length) {\n  // Reset the outbound frame type (set in the onBeforeFrameSend callback) since the\n  // onBeforeFrameSend callback is not called for DATA frames.\n  bool is_outbound_flood_monitored_control_frame = false;\n  std::swap(is_outbound_flood_monitored_control_frame, is_outbound_flood_monitored_control_frame_);\n  try {\n    incrementOutboundFrameCount(is_outbound_flood_monitored_control_frame);\n  } catch (const FrameFloodException&) {\n    return false;\n  }\n\n  auto fragment = Buffer::OwnedBufferFragmentImpl::create(\n      absl::string_view(reinterpret_cast<const char*>(data), length),\n      is_outbound_flood_monitored_control_frame ? control_frame_buffer_releasor_\n                                                : frame_buffer_releasor_);\n\n  // The Buffer::OwnedBufferFragmentImpl object will be deleted in the *frame_buffer_releasor_\n  // callback.\n  output.addBufferFragment(*fragment.release());\n  return true;\n}\n\nvoid ConnectionImpl::releaseOutboundFrame(const Buffer::OwnedBufferFragmentImpl* fragment) {\n  ASSERT(outbound_frames_ >= 1);\n  --outbound_frames_;\n  delete fragment;\n}\n\nvoid ConnectionImpl::releaseOutboundControlFrame(const Buffer::OwnedBufferFragmentImpl* fragment) {\n  ASSERT(outbound_control_frames_ >= 1);\n  --outbound_control_frames_;\n  releaseOutboundFrame(fragment);\n}\n\nssize_t ConnectionImpl::onSend(const uint8_t* data, size_t length) {\n  ENVOY_CONN_LOG(trace, \"send data: bytes={}\", connection_, length);\n  Buffer::OwnedImpl buffer;\n  if (!addOutboundFrameFragment(buffer, data, length)) {\n    ENVOY_CONN_LOG(debug, \"error sending frame: Too many frames in the outbound queue.\",\n                   connection_);\n    return NGHTTP2_ERR_FLOODED;\n  }\n\n  // While the buffer is transient the fragment it contains will be moved into the\n  // write_buffer_ of the underlying connection_ by the write method below.\n  // This creates lifetime dependency between the write_buffer_ of the underlying connection\n  // and the codec object. Specifically the write_buffer_ MUST be either fully drained or\n  // deleted before the codec object is deleted. This is presently guaranteed by the\n  // destruction order of the Network::ConnectionImpl object where write_buffer_ is\n  // destroyed before the filter_manager_ which owns the codec through Http::ConnectionManagerImpl.\n  connection_.write(buffer, false);\n  return length;\n}\n\nint ConnectionImpl::onStreamClose(int32_t stream_id, uint32_t error_code) {\n  StreamImpl* stream = getStream(stream_id);\n  if (stream) {\n    ENVOY_CONN_LOG(debug, \"stream closed: {}\", connection_, error_code);\n    if (!stream->remote_end_stream_ || !stream->local_end_stream_) {\n      StreamResetReason reason;\n      if (stream->reset_due_to_messaging_error_) {\n        // Unfortunately, the nghttp2 API makes it incredibly difficult to clearly understand\n        // the flow of resets. I.e., did the reset originate locally? Was it remote? Here,\n        // we attempt to track cases in which we sent a reset locally due to an invalid frame\n        // received from the remote. We only do that in two cases currently (HTTP messaging layer\n        // errors from https://tools.ietf.org/html/rfc7540#section-8 which nghttp2 is very strict\n        // about). In other cases we treat invalid frames as a protocol error and just kill\n        // the connection.\n        reason = StreamResetReason::LocalReset;\n      } else {\n        reason = error_code == NGHTTP2_REFUSED_STREAM ? StreamResetReason::RemoteRefusedStreamReset\n                                                      : StreamResetReason::RemoteReset;\n      }\n\n      stream->runResetCallbacks(reason);\n    }\n\n    connection_.dispatcher().deferredDelete(stream->removeFromList(active_streams_));\n    // Any unconsumed data must be consumed before the stream is deleted.\n    // nghttp2 does not appear to track this internally, and any stream deleted\n    // with outstanding window will contribute to a slow connection-window leak.\n    nghttp2_session_consume(session_, stream_id, stream->unconsumed_bytes_);\n    stream->unconsumed_bytes_ = 0;\n    nghttp2_session_set_stream_user_data(session_, stream->stream_id_, nullptr);\n  }\n\n  return 0;\n}\n\nint ConnectionImpl::onMetadataReceived(int32_t stream_id, const uint8_t* data, size_t len) {\n  ENVOY_CONN_LOG(trace, \"recv {} bytes METADATA\", connection_, len);\n\n  StreamImpl* stream = getStream(stream_id);\n  if (!stream) {\n    return 0;\n  }\n\n  bool success = stream->getMetadataDecoder().receiveMetadata(data, len);\n  return success ? 0 : NGHTTP2_ERR_CALLBACK_FAILURE;\n}\n\nint ConnectionImpl::onMetadataFrameComplete(int32_t stream_id, bool end_metadata) {\n  ENVOY_CONN_LOG(trace, \"recv METADATA frame on stream {}, end_metadata: {}\", connection_,\n                 stream_id, end_metadata);\n\n  StreamImpl* stream = getStream(stream_id);\n  ASSERT(stream != nullptr);\n\n  bool result = stream->getMetadataDecoder().onMetadataFrameComplete(end_metadata);\n  return result ? 0 : NGHTTP2_ERR_CALLBACK_FAILURE;\n}\n\nssize_t ConnectionImpl::packMetadata(int32_t stream_id, uint8_t* buf, size_t len) {\n  ENVOY_CONN_LOG(trace, \"pack METADATA frame on stream {}\", connection_, stream_id);\n\n  StreamImpl* stream = getStream(stream_id);\n  ASSERT(stream != nullptr);\n\n  MetadataEncoder& encoder = stream->getMetadataEncoder();\n  const uint64_t payload_size = encoder.packNextFramePayload(buf, len);\n  return static_cast<ssize_t>(payload_size);\n}\n\nint ConnectionImpl::saveHeader(const nghttp2_frame* frame, HeaderString&& name,\n                               HeaderString&& value) {\n  StreamImpl* stream = getStream(frame->hd.stream_id);\n  if (!stream) {\n    // We have seen 1 or 2 crashes where we get a headers callback but there is no associated\n    // stream data. I honestly am not sure how this can happen. However, from reading the nghttp2\n    // code it looks possible that inflate_header_block() can safely inflate headers for an already\n    // closed stream, but will still call the headers callback. Since that seems possible, we should\n    // ignore this case here.\n    // TODO(mattklein123): Figure out a test case that can hit this.\n    stats_.headers_cb_no_stream_.inc();\n    return 0;\n  }\n\n  stream->saveHeader(std::move(name), std::move(value));\n  if (stream->headers_->byteSize() > max_request_headers_kb_ * 1024) {\n    // This will cause the library to reset/close the stream.\n    stats_.header_overflow_.inc();\n    return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;\n  } else {\n    return 0;\n  }\n}\n\nvoid ConnectionImpl::sendPendingFrames() {\n  if (dispatching_ || connection_.state() == Network::Connection::State::Closed) {\n    return;\n  }\n\n  int rc = nghttp2_session_send(session_);\n  if (rc != 0) {\n    ASSERT(rc == NGHTTP2_ERR_CALLBACK_FAILURE);\n    // For errors caused by the pending outbound frame flood the FrameFloodException has\n    // to be thrown. However the nghttp2 library returns only the generic error code for\n    // all failure types. Check queue limits and throw FrameFloodException if they were\n    // exceeded.\n    if (outbound_frames_ > max_outbound_frames_ ||\n        outbound_control_frames_ > max_outbound_control_frames_) {\n      throw FrameFloodException(\"Too many frames in the outbound queue.\");\n    }\n\n    throw CodecProtocolException(fmt::format(\"{}\", nghttp2_strerror(rc)));\n  }\n\n  // See ConnectionImpl::StreamImpl::resetStream() for why we do this. This is an uncommon event,\n  // so iterating through every stream to find the ones that have a deferred reset is not a big\n  // deal. Furthermore, queueing a reset frame does not actually invoke the close stream callback.\n  // This is only done when the reset frame is sent. Thus, it's safe to work directly with the\n  // stream map.\n  // NOTE: The way we handle deferred reset is essentially best effort. If we intend to do a\n  //       deferred reset, we try to finish the stream, including writing any pending data frames.\n  //       If we cannot do this (potentially due to not enough window), we just reset the stream.\n  //       In general this behavior occurs only when we are trying to send immediate error messages\n  //       to short circuit requests. In the best effort case, we complete the stream before\n  //       resetting. In other cases, we just do the reset now which will blow away pending data\n  //       frames and release any memory associated with the stream.\n  if (pending_deferred_reset_) {\n    pending_deferred_reset_ = false;\n    for (auto& stream : active_streams_) {\n      if (stream->deferred_reset_) {\n        stream->resetStreamWorker(stream->deferred_reset_.value());\n      }\n    }\n    sendPendingFrames();\n  }\n}\n\nvoid ConnectionImpl::sendSettings(const Http2Settings& http2_settings, bool disable_push) {\n  ASSERT(http2_settings.hpack_table_size_ <= Http2Settings::MAX_HPACK_TABLE_SIZE);\n  ASSERT(Http2Settings::MIN_MAX_CONCURRENT_STREAMS <= http2_settings.max_concurrent_streams_ &&\n         http2_settings.max_concurrent_streams_ <= Http2Settings::MAX_MAX_CONCURRENT_STREAMS);\n  ASSERT(\n      Http2Settings::MIN_INITIAL_STREAM_WINDOW_SIZE <= http2_settings.initial_stream_window_size_ &&\n      http2_settings.initial_stream_window_size_ <= Http2Settings::MAX_INITIAL_STREAM_WINDOW_SIZE);\n  ASSERT(Http2Settings::MIN_INITIAL_CONNECTION_WINDOW_SIZE <=\n             http2_settings.initial_connection_window_size_ &&\n         http2_settings.initial_connection_window_size_ <=\n             Http2Settings::MAX_INITIAL_CONNECTION_WINDOW_SIZE);\n\n  std::vector<nghttp2_settings_entry> iv;\n\n  if (http2_settings.allow_connect_) {\n    iv.push_back({NGHTTP2_SETTINGS_ENABLE_CONNECT_PROTOCOL, 1});\n  }\n\n  if (http2_settings.hpack_table_size_ != NGHTTP2_DEFAULT_HEADER_TABLE_SIZE) {\n    iv.push_back({NGHTTP2_SETTINGS_HEADER_TABLE_SIZE, http2_settings.hpack_table_size_});\n    ENVOY_CONN_LOG(debug, \"setting HPACK table size to {}\", connection_,\n                   http2_settings.hpack_table_size_);\n  }\n\n  if (http2_settings.max_concurrent_streams_ != NGHTTP2_INITIAL_MAX_CONCURRENT_STREAMS) {\n    iv.push_back({NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS, http2_settings.max_concurrent_streams_});\n    ENVOY_CONN_LOG(debug, \"setting max concurrent streams to {}\", connection_,\n                   http2_settings.max_concurrent_streams_);\n  }\n\n  if (http2_settings.initial_stream_window_size_ != NGHTTP2_INITIAL_WINDOW_SIZE) {\n    iv.push_back(\n        {NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE, http2_settings.initial_stream_window_size_});\n    ENVOY_CONN_LOG(debug, \"setting stream-level initial window size to {}\", connection_,\n                   http2_settings.initial_stream_window_size_);\n  }\n\n  if (disable_push) {\n    // Universally disable receiving push promise frames as we don't currently support them. nghttp2\n    // will fail the connection if the other side still sends them.\n    // TODO(mattklein123): Remove this when we correctly proxy push promise.\n    iv.push_back({NGHTTP2_SETTINGS_ENABLE_PUSH, 0});\n  }\n\n  if (!iv.empty()) {\n    int rc = nghttp2_submit_settings(session_, NGHTTP2_FLAG_NONE, &iv[0], iv.size());\n    ASSERT(rc == 0);\n  } else {\n    // nghttp2_submit_settings need to be called at least once\n    int rc = nghttp2_submit_settings(session_, NGHTTP2_FLAG_NONE, nullptr, 0);\n    ASSERT(rc == 0);\n  }\n\n  // Increase connection window size up to our default size.\n  if (http2_settings.initial_connection_window_size_ != NGHTTP2_INITIAL_CONNECTION_WINDOW_SIZE) {\n    ENVOY_CONN_LOG(debug, \"updating connection-level initial window size to {}\", connection_,\n                   http2_settings.initial_connection_window_size_);\n    int rc = nghttp2_submit_window_update(session_, NGHTTP2_FLAG_NONE, 0,\n                                          http2_settings.initial_connection_window_size_ -\n                                              NGHTTP2_INITIAL_CONNECTION_WINDOW_SIZE);\n    ASSERT(rc == 0);\n  }\n}\n\nConnectionImpl::Http2Callbacks::Http2Callbacks() {\n  nghttp2_session_callbacks_new(&callbacks_);\n  nghttp2_session_callbacks_set_send_callback(\n      callbacks_,\n      [](nghttp2_session*, const uint8_t* data, size_t length, int, void* user_data) -> ssize_t {\n        return static_cast<ConnectionImpl*>(user_data)->onSend(data, length);\n      });\n\n  nghttp2_session_callbacks_set_send_data_callback(\n      callbacks_,\n      [](nghttp2_session*, nghttp2_frame* frame, const uint8_t* framehd, size_t length,\n         nghttp2_data_source* source, void*) -> int {\n        ASSERT(frame->data.padlen == 0);\n        return static_cast<StreamImpl*>(source->ptr)->onDataSourceSend(framehd, length);\n      });\n\n  nghttp2_session_callbacks_set_on_begin_headers_callback(\n      callbacks_, [](nghttp2_session*, const nghttp2_frame* frame, void* user_data) -> int {\n        return static_cast<ConnectionImpl*>(user_data)->onBeginHeaders(frame);\n      });\n\n  nghttp2_session_callbacks_set_on_header_callback(\n      callbacks_,\n      [](nghttp2_session*, const nghttp2_frame* frame, const uint8_t* raw_name, size_t name_length,\n         const uint8_t* raw_value, size_t value_length, uint8_t, void* user_data) -> int {\n        // TODO PERF: Can reference count here to avoid copies.\n        HeaderString name;\n        name.setCopy(reinterpret_cast<const char*>(raw_name), name_length);\n        HeaderString value;\n        value.setCopy(reinterpret_cast<const char*>(raw_value), value_length);\n        return static_cast<ConnectionImpl*>(user_data)->onHeader(frame, std::move(name),\n                                                                 std::move(value));\n      });\n\n  nghttp2_session_callbacks_set_on_data_chunk_recv_callback(\n      callbacks_,\n      [](nghttp2_session*, uint8_t, int32_t stream_id, const uint8_t* data, size_t len,\n         void* user_data) -> int {\n        return static_cast<ConnectionImpl*>(user_data)->onData(stream_id, data, len);\n      });\n\n  nghttp2_session_callbacks_set_on_begin_frame_callback(\n      callbacks_, [](nghttp2_session*, const nghttp2_frame_hd* hd, void* user_data) -> int {\n        return static_cast<ConnectionImpl*>(user_data)->onBeforeFrameReceived(hd);\n      });\n\n  nghttp2_session_callbacks_set_on_frame_recv_callback(\n      callbacks_, [](nghttp2_session*, const nghttp2_frame* frame, void* user_data) -> int {\n        return static_cast<ConnectionImpl*>(user_data)->onFrameReceived(frame);\n      });\n\n  nghttp2_session_callbacks_set_on_stream_close_callback(\n      callbacks_,\n      [](nghttp2_session*, int32_t stream_id, uint32_t error_code, void* user_data) -> int {\n        return static_cast<ConnectionImpl*>(user_data)->onStreamClose(stream_id, error_code);\n      });\n\n  nghttp2_session_callbacks_set_on_frame_send_callback(\n      callbacks_, [](nghttp2_session*, const nghttp2_frame* frame, void* user_data) -> int {\n        return static_cast<ConnectionImpl*>(user_data)->onFrameSend(frame);\n      });\n\n  nghttp2_session_callbacks_set_before_frame_send_callback(\n      callbacks_, [](nghttp2_session*, const nghttp2_frame* frame, void* user_data) -> int {\n        return static_cast<ConnectionImpl*>(user_data)->onBeforeFrameSend(frame);\n      });\n\n  nghttp2_session_callbacks_set_on_frame_not_send_callback(\n      callbacks_, [](nghttp2_session*, const nghttp2_frame*, int, void*) -> int {\n        // We used to always return failure here but it looks now this can get called if the other\n        // side sends GOAWAY and we are trying to send a SETTINGS ACK. Just ignore this for now.\n        return 0;\n      });\n\n  nghttp2_session_callbacks_set_on_invalid_frame_recv_callback(\n      callbacks_,\n      [](nghttp2_session*, const nghttp2_frame* frame, int error_code, void* user_data) -> int {\n        return static_cast<ConnectionImpl*>(user_data)->onInvalidFrame(frame->hd.stream_id,\n                                                                       error_code);\n      });\n\n  nghttp2_session_callbacks_set_on_extension_chunk_recv_callback(\n      callbacks_,\n      [](nghttp2_session*, const nghttp2_frame_hd* hd, const uint8_t* data, size_t len,\n         void* user_data) -> int {\n        ASSERT(hd->length >= len);\n        return static_cast<ConnectionImpl*>(user_data)->onMetadataReceived(hd->stream_id, data,\n                                                                           len);\n      });\n\n  nghttp2_session_callbacks_set_unpack_extension_callback(\n      callbacks_, [](nghttp2_session*, void**, const nghttp2_frame_hd* hd, void* user_data) -> int {\n        return static_cast<ConnectionImpl*>(user_data)->onMetadataFrameComplete(\n            hd->stream_id, hd->flags == END_METADATA_FLAG);\n      });\n\n  nghttp2_session_callbacks_set_pack_extension_callback(\n      callbacks_,\n      [](nghttp2_session*, uint8_t* buf, size_t len, const nghttp2_frame* frame,\n         void* user_data) -> ssize_t {\n        ASSERT(frame->hd.length <= len);\n        return static_cast<ConnectionImpl*>(user_data)->packMetadata(frame->hd.stream_id, buf, len);\n      });\n}\n\nConnectionImpl::Http2Callbacks::~Http2Callbacks() { nghttp2_session_callbacks_del(callbacks_); }\n\nConnectionImpl::Http2Options::Http2Options(const Http2Settings& http2_settings) {\n  nghttp2_option_new(&options_);\n  // Currently we do not do anything with stream priority. Setting the following option prevents\n  // nghttp2 from keeping around closed streams for use during stream priority dependency graph\n  // calculations. This saves a tremendous amount of memory in cases where there are a large number\n  // of kept alive HTTP/2 connections.\n  nghttp2_option_set_no_closed_streams(options_, 1);\n  nghttp2_option_set_no_auto_window_update(options_, 1);\n\n  // The max send header block length is configured to an arbitrarily high number so as to never\n  // trigger the check within nghttp2, as we check request headers length in codec_impl::saveHeader.\n  nghttp2_option_set_max_send_header_block_length(options_, 0x2000000);\n\n  if (http2_settings.hpack_table_size_ != NGHTTP2_DEFAULT_HEADER_TABLE_SIZE) {\n    nghttp2_option_set_max_deflate_dynamic_table_size(options_, http2_settings.hpack_table_size_);\n  }\n\n  if (http2_settings.allow_metadata_) {\n    nghttp2_option_set_user_recv_extension_type(options_, METADATA_FRAME_TYPE);\n  }\n}\n\nConnectionImpl::Http2Options::~Http2Options() { nghttp2_option_del(options_); }\n\nConnectionImpl::ClientHttp2Options::ClientHttp2Options(const Http2Settings& http2_settings)\n    : Http2Options(http2_settings) {\n  // Temporarily disable initial max streams limit/protection, since we might want to create\n  // more than 100 streams before receiving the HTTP/2 SETTINGS frame from the server.\n  //\n  // TODO(PiotrSikora): remove this once multiple upstream connections or queuing are implemented.\n  nghttp2_option_set_peer_max_concurrent_streams(options_,\n                                                 Http2Settings::DEFAULT_MAX_CONCURRENT_STREAMS);\n}\n\nClientConnectionImpl::ClientConnectionImpl(Network::Connection& connection,\n                                           Http::ConnectionCallbacks& callbacks,\n                                           Stats::Scope& stats, const Http2Settings& http2_settings,\n                                           const uint32_t max_request_headers_kb)\n    : ConnectionImpl(connection, stats, http2_settings, max_request_headers_kb),\n      callbacks_(callbacks) {\n  ClientHttp2Options client_http2_options(http2_settings);\n  nghttp2_session_client_new2(&session_, http2_callbacks_.callbacks(), base(),\n                              client_http2_options.options());\n  sendSettings(http2_settings, true);\n  allow_metadata_ = http2_settings.allow_metadata_;\n}\n\nHttp::StreamEncoder& ClientConnectionImpl::newStream(StreamDecoder& decoder) {\n  StreamImplPtr stream(new ClientStreamImpl(*this, per_stream_buffer_limit_));\n  stream->decoder_ = &decoder;\n  // If the connection is currently above the high watermark, make sure to inform the new stream.\n  // The connection can not pass this on automatically as it has no awareness that a new stream is\n  // created.\n  if (connection_.aboveHighWatermark()) {\n    stream->runHighWatermarkCallbacks();\n  }\n  stream->moveIntoList(std::move(stream), active_streams_);\n  return *active_streams_.front();\n}\n\nint ClientConnectionImpl::onBeginHeaders(const nghttp2_frame* frame) {\n  // The client code explicitly does not currently support push promise.\n  RELEASE_ASSERT(frame->hd.type == NGHTTP2_HEADERS, \"\");\n  RELEASE_ASSERT(frame->headers.cat == NGHTTP2_HCAT_RESPONSE ||\n                     frame->headers.cat == NGHTTP2_HCAT_HEADERS,\n                 \"\");\n  if (frame->headers.cat == NGHTTP2_HCAT_HEADERS) {\n    StreamImpl* stream = getStream(frame->hd.stream_id);\n    ASSERT(!stream->headers_);\n    stream->headers_ = std::make_unique<HeaderMapImpl>();\n  }\n\n  return 0;\n}\n\nint ClientConnectionImpl::onHeader(const nghttp2_frame* frame, HeaderString&& name,\n                                   HeaderString&& value) {\n  // The client code explicitly does not currently support push promise.\n  ASSERT(frame->hd.type == NGHTTP2_HEADERS);\n  ASSERT(frame->headers.cat == NGHTTP2_HCAT_RESPONSE || frame->headers.cat == NGHTTP2_HCAT_HEADERS);\n  return saveHeader(frame, std::move(name), std::move(value));\n}\n\nServerConnectionImpl::ServerConnectionImpl(Network::Connection& connection,\n                                           Http::ServerConnectionCallbacks& callbacks,\n                                           Stats::Scope& scope, const Http2Settings& http2_settings,\n                                           const uint32_t max_request_headers_kb)\n    : ConnectionImpl(connection, scope, http2_settings, max_request_headers_kb),\n      callbacks_(callbacks) {\n  Http2Options http2_options(http2_settings);\n  nghttp2_session_server_new2(&session_, http2_callbacks_.callbacks(), base(),\n                              http2_options.options());\n  sendSettings(http2_settings, false);\n  allow_metadata_ = http2_settings.allow_metadata_;\n}\n\nint ServerConnectionImpl::onBeginHeaders(const nghttp2_frame* frame) {\n  // For a server connection, we should never get push promise frames.\n  ASSERT(frame->hd.type == NGHTTP2_HEADERS);\n\n  if (!trackInboundFrames(&frame->hd, frame->headers.padlen)) {\n    return NGHTTP2_ERR_FLOODED;\n  }\n\n  if (frame->headers.cat != NGHTTP2_HCAT_REQUEST) {\n    stats_.trailers_.inc();\n    ASSERT(frame->headers.cat == NGHTTP2_HCAT_HEADERS);\n\n    StreamImpl* stream = getStream(frame->hd.stream_id);\n    ASSERT(!stream->headers_);\n    stream->headers_ = std::make_unique<HeaderMapImpl>();\n    return 0;\n  }\n\n  StreamImplPtr stream(new ServerStreamImpl(*this, per_stream_buffer_limit_));\n  if (connection_.aboveHighWatermark()) {\n    stream->runHighWatermarkCallbacks();\n  }\n  stream->decoder_ = &callbacks_.newStream(*stream);\n  stream->stream_id_ = frame->hd.stream_id;\n  stream->moveIntoList(std::move(stream), active_streams_);\n  nghttp2_session_set_stream_user_data(session_, frame->hd.stream_id,\n                                       active_streams_.front().get());\n  return 0;\n}\n\nint ServerConnectionImpl::onHeader(const nghttp2_frame* frame, HeaderString&& name,\n                                   HeaderString&& value) {\n  // For a server connection, we should never get push promise frames.\n  ASSERT(frame->hd.type == NGHTTP2_HEADERS);\n  ASSERT(frame->headers.cat == NGHTTP2_HCAT_REQUEST || frame->headers.cat == NGHTTP2_HCAT_HEADERS);\n  return saveHeader(frame, std::move(name), std::move(value));\n}\n\nbool ServerConnectionImpl::trackInboundFrames(const nghttp2_frame_hd* hd, uint32_t padding_length) {\n  ENVOY_CONN_LOG(trace, \"track inbound frame type={} flags={} length={} padding_length={}\",\n                 connection_, static_cast<uint64_t>(hd->type), static_cast<uint64_t>(hd->flags),\n                 static_cast<uint64_t>(hd->length), padding_length);\n  switch (hd->type) {\n  case NGHTTP2_HEADERS:\n  case NGHTTP2_CONTINUATION:\n    // Track new streams.\n    if (hd->flags & NGHTTP2_FLAG_END_HEADERS) {\n      inbound_streams_++;\n    }\n    FALLTHRU;\n  case NGHTTP2_DATA:\n    // Track frames with an empty payload and no end stream flag.\n    if (hd->length - padding_length == 0 && !(hd->flags & NGHTTP2_FLAG_END_STREAM)) {\n      ENVOY_CONN_LOG(trace, \"frame with an empty payload and no end stream flag.\", connection_);\n      consecutive_inbound_frames_with_empty_payload_++;\n    } else {\n      consecutive_inbound_frames_with_empty_payload_ = 0;\n    }\n    break;\n  case NGHTTP2_PRIORITY:\n    inbound_priority_frames_++;\n    break;\n  case NGHTTP2_WINDOW_UPDATE:\n    inbound_window_update_frames_++;\n    break;\n  default:\n    break;\n  }\n\n  if (!checkInboundFrameLimits()) {\n    // NGHTTP2_ERR_FLOODED is overridden within nghttp2 library and it doesn't propagate\n    // all the way to nghttp2_session_mem_recv() where we need it.\n    flood_detected_ = true;\n    return false;\n  }\n\n  return true;\n}\n\nbool ServerConnectionImpl::checkInboundFrameLimits() {\n  ASSERT(dispatching_downstream_data_);\n\n  if (consecutive_inbound_frames_with_empty_payload_ >\n      max_consecutive_inbound_frames_with_empty_payload_) {\n    ENVOY_CONN_LOG(trace,\n                   \"error reading frame: Too many consecutive frames with an empty payload \"\n                   \"received in this HTTP/2 session.\",\n                   connection_);\n    stats_.inbound_empty_frames_flood_.inc();\n    return false;\n  }\n\n  if (inbound_priority_frames_ > max_inbound_priority_frames_per_stream_ * (1 + inbound_streams_)) {\n    ENVOY_CONN_LOG(trace,\n                   \"error reading frame: Too many PRIORITY frames received in this HTTP/2 session.\",\n                   connection_);\n    stats_.inbound_priority_frames_flood_.inc();\n    return false;\n  }\n\n  if (inbound_window_update_frames_ >\n      1 + 2 * (inbound_streams_ +\n               max_inbound_window_update_frames_per_data_frame_sent_ * outbound_data_frames_)) {\n    ENVOY_CONN_LOG(\n        trace,\n        \"error reading frame: Too many WINDOW_UPDATE frames received in this HTTP/2 session.\",\n        connection_);\n    stats_.inbound_window_update_frames_flood_.inc();\n    return false;\n  }\n\n  return true;\n}\n\nvoid ServerConnectionImpl::checkOutboundQueueLimits() {\n  if (outbound_frames_ > max_outbound_frames_ && dispatching_downstream_data_) {\n    stats_.outbound_flood_.inc();\n    throw FrameFloodException(\"Too many frames in the outbound queue.\");\n  }\n  if (outbound_control_frames_ > max_outbound_control_frames_ && dispatching_downstream_data_) {\n    stats_.outbound_control_flood_.inc();\n    throw FrameFloodException(\"Too many control frames in the outbound queue.\");\n  }\n}\n\nvoid ServerConnectionImpl::dispatch(Buffer::Instance& data) {\n  ASSERT(!dispatching_downstream_data_);\n  dispatching_downstream_data_ = true;\n\n  // Make sure the dispatching_downstream_data_ is set to false even\n  // when ConnectionImpl::dispatch throws an exception.\n  Cleanup cleanup([this]() { dispatching_downstream_data_ = false; });\n\n  // Make sure downstream outbound queue was not flooded by the upstream frames.\n  checkOutboundQueueLimits();\n\n  ConnectionImpl::dispatch(data);\n}\n\n} // namespace Http2\n} // namespace Http\n} // namespace Envoy\n", "#include \"common/router/router.h\"\n\n#include <chrono>\n#include <cstdint>\n#include <memory>\n#include <string>\n\n#include \"envoy/event/dispatcher.h\"\n#include \"envoy/event/timer.h\"\n#include \"envoy/grpc/status.h\"\n#include \"envoy/http/conn_pool.h\"\n#include \"envoy/runtime/runtime.h\"\n#include \"envoy/upstream/cluster_manager.h\"\n#include \"envoy/upstream/upstream.h\"\n\n#include \"common/common/assert.h\"\n#include \"common/common/empty_string.h\"\n#include \"common/common/enum_to_int.h\"\n#include \"common/common/scope_tracker.h\"\n#include \"common/common/utility.h\"\n#include \"common/grpc/common.h\"\n#include \"common/http/codes.h\"\n#include \"common/http/header_map_impl.h\"\n#include \"common/http/headers.h\"\n#include \"common/http/message_impl.h\"\n#include \"common/http/utility.h\"\n#include \"common/network/application_protocol.h\"\n#include \"common/network/transport_socket_options_impl.h\"\n#include \"common/router/config_impl.h\"\n#include \"common/router/debug_config.h\"\n#include \"common/router/retry_state_impl.h\"\n#include \"common/runtime/runtime_impl.h\"\n#include \"common/tracing/http_tracer_impl.h\"\n\n#include \"extensions/filters/http/well_known_names.h\"\n\nnamespace Envoy {\nnamespace Router {\nnamespace {\nuint32_t getLength(const Buffer::Instance* instance) { return instance ? instance->length() : 0; }\n\nbool schemeIsHttp(const Http::HeaderMap& downstream_headers,\n                  const Network::Connection& connection) {\n  if (downstream_headers.ForwardedProto() &&\n      downstream_headers.ForwardedProto()->value().getStringView() ==\n          Http::Headers::get().SchemeValues.Http) {\n    return true;\n  }\n  if (!connection.ssl()) {\n    return true;\n  }\n  return false;\n}\n\nbool convertRequestHeadersForInternalRedirect(Http::HeaderMap& downstream_headers,\n                                              const Http::HeaderEntry& internal_redirect,\n                                              const Network::Connection& connection) {\n  // Envoy does not currently support multiple rounds of redirects.\n  if (downstream_headers.EnvoyOriginalUrl()) {\n    return false;\n  }\n  // Make sure the redirect response contains a URL to redirect to.\n  if (internal_redirect.value().getStringView().length() == 0) {\n    return false;\n  }\n\n  Http::Utility::Url absolute_url;\n  if (!absolute_url.initialize(internal_redirect.value().getStringView())) {\n    return false;\n  }\n\n  bool scheme_is_http = schemeIsHttp(downstream_headers, connection);\n  if (scheme_is_http && absolute_url.scheme() == Http::Headers::get().SchemeValues.Https) {\n    // Don't allow serving TLS responses over plaintext.\n    return false;\n  }\n\n  // Preserve the original request URL for the second pass.\n  downstream_headers.insertEnvoyOriginalUrl().value(\n      absl::StrCat(scheme_is_http ? Http::Headers::get().SchemeValues.Http\n                                  : Http::Headers::get().SchemeValues.Https,\n                   \"://\", downstream_headers.Host()->value().getStringView(),\n                   downstream_headers.Path()->value().getStringView()));\n\n  // Replace the original host, scheme and path.\n  downstream_headers.insertScheme().value(std::string(absolute_url.scheme()));\n  downstream_headers.insertHost().value(std::string(absolute_url.host_and_port()));\n  downstream_headers.insertPath().value(std::string(absolute_url.path_and_query_params()));\n\n  return true;\n}\n\n} // namespace\n\nvoid FilterUtility::setUpstreamScheme(Http::HeaderMap& headers,\n                                      const Upstream::ClusterInfo& cluster) {\n  if (cluster.transportSocketFactory().implementsSecureTransport()) {\n    headers.insertScheme().value().setReference(Http::Headers::get().SchemeValues.Https);\n  } else {\n    headers.insertScheme().value().setReference(Http::Headers::get().SchemeValues.Http);\n  }\n}\n\nbool FilterUtility::shouldShadow(const ShadowPolicy& policy, Runtime::Loader& runtime,\n                                 uint64_t stable_random) {\n  if (policy.cluster().empty()) {\n    return false;\n  }\n\n  if (policy.defaultValue().numerator() > 0) {\n    return runtime.snapshot().featureEnabled(policy.runtimeKey(), policy.defaultValue(),\n                                             stable_random);\n  }\n\n  if (!policy.runtimeKey().empty() &&\n      !runtime.snapshot().featureEnabled(policy.runtimeKey(), 0, stable_random, 10000UL)) {\n    return false;\n  }\n\n  return true;\n}\n\nFilterUtility::TimeoutData\nFilterUtility::finalTimeout(const RouteEntry& route, Http::HeaderMap& request_headers,\n                            bool insert_envoy_expected_request_timeout_ms, bool grpc_request,\n                            bool per_try_timeout_hedging_enabled,\n                            bool respect_expected_rq_timeout) {\n  // See if there is a user supplied timeout in a request header. If there is we take that.\n  // Otherwise if the request is gRPC and a maximum gRPC timeout is configured we use the timeout\n  // in the gRPC headers (or infinity when gRPC headers have no timeout), but cap that timeout to\n  // the configured maximum gRPC timeout (which may also be infinity, represented by a 0 value),\n  // or the default from the route config otherwise.\n  TimeoutData timeout;\n  if (grpc_request && route.maxGrpcTimeout()) {\n    const std::chrono::milliseconds max_grpc_timeout = route.maxGrpcTimeout().value();\n    std::chrono::milliseconds grpc_timeout = Grpc::Common::getGrpcTimeout(request_headers);\n    if (route.grpcTimeoutOffset()) {\n      // We only apply the offset if it won't result in grpc_timeout hitting 0 or below, as\n      // setting it to 0 means infinity and a negative timeout makes no sense.\n      const auto offset = *route.grpcTimeoutOffset();\n      if (offset < grpc_timeout) {\n        grpc_timeout -= offset;\n      }\n    }\n\n    // Cap gRPC timeout to the configured maximum considering that 0 means infinity.\n    if (max_grpc_timeout != std::chrono::milliseconds(0) &&\n        (grpc_timeout == std::chrono::milliseconds(0) || grpc_timeout > max_grpc_timeout)) {\n      grpc_timeout = max_grpc_timeout;\n    }\n    timeout.global_timeout_ = grpc_timeout;\n  } else {\n    timeout.global_timeout_ = route.timeout();\n  }\n  timeout.per_try_timeout_ = route.retryPolicy().perTryTimeout();\n\n  uint64_t header_timeout;\n\n  if (respect_expected_rq_timeout) {\n    // Check if there is timeout set by egress Envoy.\n    // If present, use that value as route timeout and don't override\n    // *x-envoy-expected-rq-timeout-ms* header. At this point *x-envoy-upstream-rq-timeout-ms*\n    // header should have been sanitized by egress Envoy.\n    Http::HeaderEntry* header_expected_timeout_entry =\n        request_headers.EnvoyExpectedRequestTimeoutMs();\n    if (header_expected_timeout_entry) {\n      trySetGlobalTimeout(header_expected_timeout_entry, timeout);\n    } else {\n      Http::HeaderEntry* header_timeout_entry = request_headers.EnvoyUpstreamRequestTimeoutMs();\n\n      if (trySetGlobalTimeout(header_timeout_entry, timeout)) {\n        request_headers.removeEnvoyUpstreamRequestTimeoutMs();\n      }\n    }\n  } else {\n    Http::HeaderEntry* header_timeout_entry = request_headers.EnvoyUpstreamRequestTimeoutMs();\n    if (trySetGlobalTimeout(header_timeout_entry, timeout)) {\n      request_headers.removeEnvoyUpstreamRequestTimeoutMs();\n    }\n  }\n\n  // See if there is a per try/retry timeout. If it's >= global we just ignore it.\n  Http::HeaderEntry* per_try_timeout_entry = request_headers.EnvoyUpstreamRequestPerTryTimeoutMs();\n  if (per_try_timeout_entry) {\n    if (absl::SimpleAtoi(per_try_timeout_entry->value().getStringView(), &header_timeout)) {\n      timeout.per_try_timeout_ = std::chrono::milliseconds(header_timeout);\n    }\n    request_headers.removeEnvoyUpstreamRequestPerTryTimeoutMs();\n  }\n\n  if (timeout.per_try_timeout_ >= timeout.global_timeout_) {\n    timeout.per_try_timeout_ = std::chrono::milliseconds(0);\n  }\n\n  // See if there is any timeout to write in the expected timeout header.\n  uint64_t expected_timeout = timeout.per_try_timeout_.count();\n  // Use the global timeout if no per try timeout was specified or if we're\n  // doing hedging when there are per try timeouts. Either of these scenarios\n  // mean that the upstream server can use the full global timeout.\n  if (per_try_timeout_hedging_enabled || expected_timeout == 0) {\n    expected_timeout = timeout.global_timeout_.count();\n  }\n\n  if (insert_envoy_expected_request_timeout_ms && expected_timeout > 0) {\n    request_headers.insertEnvoyExpectedRequestTimeoutMs().value(expected_timeout);\n  }\n\n  // If we've configured max_grpc_timeout, override the grpc-timeout header with\n  // the expected timeout. This ensures that the optional per try timeout is reflected\n  // in grpc-timeout, ensuring that the upstream gRPC server is aware of the actual timeout.\n  // If the expected timeout is 0 set no timeout, as Envoy treats 0 as infinite timeout.\n  if (grpc_request && route.maxGrpcTimeout() && expected_timeout != 0) {\n    Grpc::Common::toGrpcTimeout(std::chrono::milliseconds(expected_timeout),\n                                request_headers.insertGrpcTimeout().value());\n  }\n\n  return timeout;\n}\n\nbool FilterUtility::trySetGlobalTimeout(const Http::HeaderEntry* header_timeout_entry,\n                                        TimeoutData& timeout) {\n  if (header_timeout_entry) {\n    uint64_t header_timeout;\n    if (absl::SimpleAtoi(header_timeout_entry->value().getStringView(), &header_timeout)) {\n      timeout.global_timeout_ = std::chrono::milliseconds(header_timeout);\n    }\n    return true;\n  }\n  return false;\n}\n\nFilterUtility::HedgingParams FilterUtility::finalHedgingParams(const RouteEntry& route,\n                                                               Http::HeaderMap& request_headers) {\n  HedgingParams hedging_params;\n  hedging_params.hedge_on_per_try_timeout_ = route.hedgePolicy().hedgeOnPerTryTimeout();\n\n  Http::HeaderEntry* hedge_on_per_try_timeout_entry = request_headers.EnvoyHedgeOnPerTryTimeout();\n  if (hedge_on_per_try_timeout_entry) {\n    if (hedge_on_per_try_timeout_entry->value() == \"true\") {\n      hedging_params.hedge_on_per_try_timeout_ = true;\n    }\n    if (hedge_on_per_try_timeout_entry->value() == \"false\") {\n      hedging_params.hedge_on_per_try_timeout_ = false;\n    }\n\n    request_headers.removeEnvoyHedgeOnPerTryTimeout();\n  }\n\n  return hedging_params;\n}\n\nFilter::~Filter() {\n  // Upstream resources should already have been cleaned.\n  ASSERT(upstream_requests_.empty());\n  ASSERT(!retry_state_);\n}\n\nconst FilterUtility::StrictHeaderChecker::HeaderCheckResult\nFilterUtility::StrictHeaderChecker::checkHeader(Http::HeaderMap& headers,\n                                                const Http::LowerCaseString& target_header) {\n  if (target_header == Http::Headers::get().EnvoyUpstreamRequestTimeoutMs) {\n    return isInteger(headers.EnvoyUpstreamRequestTimeoutMs());\n  } else if (target_header == Http::Headers::get().EnvoyUpstreamRequestPerTryTimeoutMs) {\n    return isInteger(headers.EnvoyUpstreamRequestPerTryTimeoutMs());\n  } else if (target_header == Http::Headers::get().EnvoyMaxRetries) {\n    return isInteger(headers.EnvoyMaxRetries());\n  } else if (target_header == Http::Headers::get().EnvoyRetryOn) {\n    return hasValidRetryFields(headers.EnvoyRetryOn(), &Router::RetryStateImpl::parseRetryOn);\n  } else if (target_header == Http::Headers::get().EnvoyRetryGrpcOn) {\n    return hasValidRetryFields(headers.EnvoyRetryGrpcOn(),\n                               &Router::RetryStateImpl::parseRetryGrpcOn);\n  }\n  // Should only validate headers for which we have implemented a validator.\n  NOT_REACHED_GCOVR_EXCL_LINE\n}\n\nStats::StatName Filter::upstreamZone(Upstream::HostDescriptionConstSharedPtr upstream_host) {\n  return upstream_host ? upstream_host->localityZoneStatName() : config_.empty_stat_name_;\n}\n\nvoid Filter::chargeUpstreamCode(uint64_t response_status_code,\n                                const Http::HeaderMap& response_headers,\n                                Upstream::HostDescriptionConstSharedPtr upstream_host,\n                                bool dropped) {\n  // Passing the response_status_code explicitly is an optimization to avoid\n  // multiple calls to slow Http::Utility::getResponseStatus.\n  ASSERT(response_status_code == Http::Utility::getResponseStatus(response_headers));\n  if (config_.emit_dynamic_stats_ && !callbacks_->streamInfo().healthCheck()) {\n    const Http::HeaderEntry* upstream_canary_header = response_headers.EnvoyUpstreamCanary();\n    const Http::HeaderEntry* internal_request_header = downstream_headers_->EnvoyInternalRequest();\n\n    const bool is_canary = (upstream_canary_header && upstream_canary_header->value() == \"true\") ||\n                           (upstream_host ? upstream_host->canary() : false);\n    const bool internal_request =\n        internal_request_header && internal_request_header->value() == \"true\";\n\n    Stats::StatName upstream_zone = upstreamZone(upstream_host);\n    Http::CodeStats::ResponseStatInfo info{config_.scope_,\n                                           cluster_->statsScope(),\n                                           config_.empty_stat_name_,\n                                           response_status_code,\n                                           internal_request,\n                                           route_entry_->virtualHost().statName(),\n                                           request_vcluster_ ? request_vcluster_->statName()\n                                                             : config_.empty_stat_name_,\n                                           config_.zone_name_,\n                                           upstream_zone,\n                                           is_canary};\n\n    Http::CodeStats& code_stats = httpContext().codeStats();\n    code_stats.chargeResponseStat(info);\n\n    if (alt_stat_prefix_ != nullptr) {\n      Http::CodeStats::ResponseStatInfo alt_info{config_.scope_,\n                                                 cluster_->statsScope(),\n                                                 alt_stat_prefix_->statName(),\n                                                 response_status_code,\n                                                 internal_request,\n                                                 config_.empty_stat_name_,\n                                                 config_.empty_stat_name_,\n                                                 config_.zone_name_,\n                                                 upstream_zone,\n                                                 is_canary};\n      code_stats.chargeResponseStat(alt_info);\n    }\n\n    if (dropped) {\n      cluster_->loadReportStats().upstream_rq_dropped_.inc();\n    }\n    if (upstream_host && Http::CodeUtility::is5xx(response_status_code)) {\n      upstream_host->stats().rq_error_.inc();\n    }\n  }\n}\n\nvoid Filter::chargeUpstreamCode(Http::Code code,\n                                Upstream::HostDescriptionConstSharedPtr upstream_host,\n                                bool dropped) {\n  const uint64_t response_status_code = enumToInt(code);\n  Http::HeaderMapImpl fake_response_headers{\n      {Http::Headers::get().Status, std::to_string(response_status_code)}};\n  chargeUpstreamCode(response_status_code, fake_response_headers, upstream_host, dropped);\n}\n\nHttp::FilterHeadersStatus Filter::decodeHeaders(Http::HeaderMap& headers, bool end_stream) {\n  // Do a common header check. We make sure that all outgoing requests have all HTTP/2 headers.\n  // These get stripped by HTTP/1 codec where applicable.\n  ASSERT(headers.Path());\n  ASSERT(headers.Method());\n  ASSERT(headers.Host());\n\n  downstream_headers_ = &headers;\n\n  // Extract debug configuration from filter state. This is used further along to determine whether\n  // we should append cluster and host headers to the response, and whether to forward the request\n  // upstream.\n  const StreamInfo::FilterState& filter_state = callbacks_->streamInfo().filterState();\n  const DebugConfig* debug_config =\n      filter_state.hasData<DebugConfig>(DebugConfig::key())\n          ? &(filter_state.getDataReadOnly<DebugConfig>(DebugConfig::key()))\n          : nullptr;\n\n  // TODO: Maybe add a filter API for this.\n  grpc_request_ = Grpc::Common::hasGrpcContentType(headers);\n\n  // Only increment rq total stat if we actually decode headers here. This does not count requests\n  // that get handled by earlier filters.\n  config_.stats_.rq_total_.inc();\n\n  // Initialize the `modify_headers` function as a no-op (so we don't have to remember to check it\n  // against nullptr before calling it), and feed it behavior later if/when we have cluster info\n  // headers to append.\n  std::function<void(Http::HeaderMap&)> modify_headers = [](Http::HeaderMap&) {};\n\n  // Determine if there is a route entry or a direct response for the request.\n  route_ = callbacks_->route();\n  if (!route_) {\n    config_.stats_.no_route_.inc();\n    ENVOY_STREAM_LOG(debug, \"no cluster match for URL '{}'\", *callbacks_,\n                     headers.Path()->value().getStringView());\n\n    callbacks_->streamInfo().setResponseFlag(StreamInfo::ResponseFlag::NoRouteFound);\n    callbacks_->sendLocalReply(Http::Code::NotFound, \"\", modify_headers, absl::nullopt,\n                               StreamInfo::ResponseCodeDetails::get().RouteNotFound);\n    return Http::FilterHeadersStatus::StopIteration;\n  }\n\n  // Determine if there is a direct response for the request.\n  const auto* direct_response = route_->directResponseEntry();\n  if (direct_response != nullptr) {\n    config_.stats_.rq_direct_response_.inc();\n    direct_response->rewritePathHeader(headers, !config_.suppress_envoy_headers_);\n    callbacks_->sendLocalReply(\n        direct_response->responseCode(), direct_response->responseBody(),\n        [this, direct_response,\n         &request_headers = headers](Http::HeaderMap& response_headers) -> void {\n          const auto new_path = direct_response->newPath(request_headers);\n          if (!new_path.empty()) {\n            response_headers.addReferenceKey(Http::Headers::get().Location, new_path);\n          }\n          direct_response->finalizeResponseHeaders(response_headers, callbacks_->streamInfo());\n        },\n        absl::nullopt, StreamInfo::ResponseCodeDetails::get().DirectResponse);\n    callbacks_->streamInfo().setRouteName(direct_response->routeName());\n    return Http::FilterHeadersStatus::StopIteration;\n  }\n\n  // A route entry matches for the request.\n  route_entry_ = route_->routeEntry();\n  callbacks_->streamInfo().setRouteName(route_entry_->routeName());\n  if (debug_config && debug_config->append_cluster_) {\n    // The cluster name will be appended to any local or upstream responses from this point.\n    modify_headers = [this, debug_config](Http::HeaderMap& headers) {\n      headers.addCopy(debug_config->cluster_header_.value_or(Http::Headers::get().EnvoyCluster),\n                      route_entry_->clusterName());\n    };\n  }\n  Upstream::ThreadLocalCluster* cluster = config_.cm_.get(route_entry_->clusterName());\n  if (!cluster) {\n    config_.stats_.no_cluster_.inc();\n    ENVOY_STREAM_LOG(debug, \"unknown cluster '{}'\", *callbacks_, route_entry_->clusterName());\n\n    callbacks_->streamInfo().setResponseFlag(StreamInfo::ResponseFlag::NoRouteFound);\n    callbacks_->sendLocalReply(route_entry_->clusterNotFoundResponseCode(), \"\", modify_headers,\n                               absl::nullopt,\n                               StreamInfo::ResponseCodeDetails::get().ClusterNotFound);\n    return Http::FilterHeadersStatus::StopIteration;\n  }\n  cluster_ = cluster->info();\n\n  // Set up stat prefixes, etc.\n  request_vcluster_ = route_entry_->virtualCluster(headers);\n  ENVOY_STREAM_LOG(debug, \"cluster '{}' match for URL '{}'\", *callbacks_,\n                   route_entry_->clusterName(), headers.Path()->value().getStringView());\n\n  if (config_.strict_check_headers_ != nullptr) {\n    for (const auto& header : *config_.strict_check_headers_) {\n      const auto res = FilterUtility::StrictHeaderChecker::checkHeader(headers, header);\n      if (!res.valid_) {\n        callbacks_->streamInfo().setResponseFlag(\n            StreamInfo::ResponseFlag::InvalidEnvoyRequestHeaders);\n        const std::string body = fmt::format(\"invalid header '{}' with value '{}'\",\n                                             std::string(res.entry_->key().getStringView()),\n                                             std::string(res.entry_->value().getStringView()));\n        const std::string details =\n            absl::StrCat(StreamInfo::ResponseCodeDetails::get().InvalidEnvoyRequestHeaders, \"{\",\n                         res.entry_->key().getStringView(), \"}\");\n        callbacks_->sendLocalReply(Http::Code::BadRequest, body, nullptr, absl::nullopt, details);\n        return Http::FilterHeadersStatus::StopIteration;\n      }\n    }\n  }\n\n  const Http::HeaderEntry* request_alt_name = headers.EnvoyUpstreamAltStatName();\n  if (request_alt_name) {\n    // TODO(#7003): converting this header value into a StatName requires\n    // taking a global symbol-table lock. This is not a frequently used feature,\n    // but may not be the only occurrence of this pattern, where it's difficult\n    // or impossible to pre-compute a StatName for a component of a stat name.\n    alt_stat_prefix_ = std::make_unique<Stats::StatNameManagedStorage>(\n        request_alt_name->value().getStringView(), config_.scope_.symbolTable());\n    headers.removeEnvoyUpstreamAltStatName();\n  }\n\n  // See if we are supposed to immediately kill some percentage of this cluster's traffic.\n  if (cluster_->maintenanceMode()) {\n    callbacks_->streamInfo().setResponseFlag(StreamInfo::ResponseFlag::UpstreamOverflow);\n    chargeUpstreamCode(Http::Code::ServiceUnavailable, nullptr, true);\n    callbacks_->sendLocalReply(\n        Http::Code::ServiceUnavailable, \"maintenance mode\",\n        [modify_headers, this](Http::HeaderMap& headers) {\n          if (!config_.suppress_envoy_headers_) {\n            headers.insertEnvoyOverloaded().value(Http::Headers::get().EnvoyOverloadedValues.True);\n          }\n          // Note: append_cluster_info does not respect suppress_envoy_headers.\n          modify_headers(headers);\n        },\n        absl::nullopt, StreamInfo::ResponseCodeDetails::get().MaintenanceMode);\n    cluster_->stats().upstream_rq_maintenance_mode_.inc();\n    return Http::FilterHeadersStatus::StopIteration;\n  }\n\n  // Fetch a connection pool for the upstream cluster.\n  Http::ConnectionPool::Instance* conn_pool = getConnPool();\n  if (!conn_pool) {\n    sendNoHealthyUpstreamResponse();\n    return Http::FilterHeadersStatus::StopIteration;\n  }\n  if (debug_config && debug_config->append_upstream_host_) {\n    // The hostname and address will be appended to any local or upstream responses from this point,\n    // possibly in addition to the cluster name.\n    modify_headers = [modify_headers, debug_config, conn_pool](Http::HeaderMap& headers) {\n      modify_headers(headers);\n      headers.addCopy(\n          debug_config->hostname_header_.value_or(Http::Headers::get().EnvoyUpstreamHostname),\n          conn_pool->host()->hostname());\n      headers.addCopy(debug_config->host_address_header_.value_or(\n                          Http::Headers::get().EnvoyUpstreamHostAddress),\n                      conn_pool->host()->address()->asString());\n    };\n  }\n\n  // If we've been instructed not to forward the request upstream, send an empty local response.\n  if (debug_config && debug_config->do_not_forward_) {\n    modify_headers = [modify_headers, debug_config](Http::HeaderMap& headers) {\n      modify_headers(headers);\n      headers.addCopy(\n          debug_config->not_forwarded_header_.value_or(Http::Headers::get().EnvoyNotForwarded),\n          \"true\");\n    };\n    callbacks_->sendLocalReply(Http::Code::NoContent, \"\", modify_headers, absl::nullopt, \"\");\n    return Http::FilterHeadersStatus::StopIteration;\n  }\n\n  hedging_params_ = FilterUtility::finalHedgingParams(*route_entry_, headers);\n\n  timeout_ = FilterUtility::finalTimeout(*route_entry_, headers, !config_.suppress_envoy_headers_,\n                                         grpc_request_, hedging_params_.hedge_on_per_try_timeout_,\n                                         config_.respect_expected_rq_timeout_);\n\n  // If this header is set with any value, use an alternate response code on timeout\n  if (headers.EnvoyUpstreamRequestTimeoutAltResponse()) {\n    timeout_response_code_ = Http::Code::NoContent;\n    headers.removeEnvoyUpstreamRequestTimeoutAltResponse();\n  }\n\n  include_attempt_count_ = route_entry_->includeAttemptCount();\n  if (include_attempt_count_) {\n    headers.insertEnvoyAttemptCount().value(attempt_count_);\n  }\n\n  // Inject the active span's tracing context into the request headers.\n  callbacks_->activeSpan().injectContext(headers);\n\n  route_entry_->finalizeRequestHeaders(headers, callbacks_->streamInfo(),\n                                       !config_.suppress_envoy_headers_);\n  FilterUtility::setUpstreamScheme(headers, *cluster_);\n\n  // Ensure an http transport scheme is selected before continuing with decoding.\n  ASSERT(headers.Scheme());\n\n  retry_state_ =\n      createRetryState(route_entry_->retryPolicy(), headers, *cluster_, config_.runtime_,\n                       config_.random_, callbacks_->dispatcher(), route_entry_->priority());\n  do_shadowing_ = FilterUtility::shouldShadow(route_entry_->shadowPolicy(), config_.runtime_,\n                                              callbacks_->streamId());\n\n  ENVOY_STREAM_LOG(debug, \"router decoding headers:\\n{}\", *callbacks_, headers);\n\n  // Hang onto the modify_headers function for later use in handling upstream responses.\n  modify_headers_ = modify_headers;\n\n  UpstreamRequestPtr upstream_request = std::make_unique<UpstreamRequest>(*this, *conn_pool);\n  upstream_request->moveIntoList(std::move(upstream_request), upstream_requests_);\n  upstream_requests_.front()->encodeHeaders(end_stream);\n  if (end_stream) {\n    onRequestComplete();\n  }\n\n  return Http::FilterHeadersStatus::StopIteration;\n}\n\nHttp::ConnectionPool::Instance* Filter::getConnPool() {\n  // Choose protocol based on cluster configuration and downstream connection\n  // Note: Cluster may downgrade HTTP2 to HTTP1 based on runtime configuration.\n  auto features = cluster_->features();\n\n  Http::Protocol protocol;\n  if (features & Upstream::ClusterInfo::Features::USE_DOWNSTREAM_PROTOCOL) {\n    protocol = callbacks_->streamInfo().protocol().value();\n  } else {\n    protocol = (features & Upstream::ClusterInfo::Features::HTTP2) ? Http::Protocol::Http2\n                                                                   : Http::Protocol::Http11;\n  }\n\n  if (callbacks_->streamInfo().filterState().hasData<Network::ApplicationProtocols>(\n          Network::ApplicationProtocols::key())) {\n    const auto& alpn =\n        callbacks_->streamInfo().filterState().getDataReadOnly<Network::ApplicationProtocols>(\n            Network::ApplicationProtocols::key());\n    transport_socket_options_ = std::make_shared<Network::TransportSocketOptionsImpl>(\n        \"\", std::vector<std::string>{}, std::vector<std::string>{alpn.value()});\n  }\n\n  return config_.cm_.httpConnPoolForCluster(route_entry_->clusterName(), route_entry_->priority(),\n                                            protocol, this);\n}\n\nvoid Filter::sendNoHealthyUpstreamResponse() {\n  callbacks_->streamInfo().setResponseFlag(StreamInfo::ResponseFlag::NoHealthyUpstream);\n  chargeUpstreamCode(Http::Code::ServiceUnavailable, nullptr, false);\n  callbacks_->sendLocalReply(Http::Code::ServiceUnavailable, \"no healthy upstream\", modify_headers_,\n                             absl::nullopt,\n                             StreamInfo::ResponseCodeDetails::get().NoHealthyUpstream);\n}\n\nHttp::FilterDataStatus Filter::decodeData(Buffer::Instance& data, bool end_stream) {\n  // upstream_requests_.size() cannot be 0 because we add to it unconditionally\n  // in decodeHeaders(). It cannot be > 1 because that only happens when a per\n  // try timeout occurs with hedge_on_per_try_timeout enabled but the per\n  // try timeout timer is not started until onUpstreamComplete().\n  ASSERT(upstream_requests_.size() == 1);\n\n  bool buffering = (retry_state_ && retry_state_->enabled()) || do_shadowing_;\n  if (buffering && buffer_limit_ > 0 &&\n      getLength(callbacks_->decodingBuffer()) + data.length() > buffer_limit_) {\n    // The request is larger than we should buffer. Give up on the retry/shadow\n    cluster_->stats().retry_or_shadow_abandoned_.inc();\n    retry_state_.reset();\n    buffering = false;\n    do_shadowing_ = false;\n  }\n\n  if (buffering) {\n    // If we are going to buffer for retries or shadowing, we need to make a copy before encoding\n    // since it's all moves from here on.\n    Buffer::OwnedImpl copy(data);\n    upstream_requests_.front()->encodeData(copy, end_stream);\n\n    // If we are potentially going to retry or shadow this request we need to buffer.\n    // This will not cause the connection manager to 413 because before we hit the\n    // buffer limit we give up on retries and buffering. We must buffer using addDecodedData()\n    // so that all buffered data is available by the time we do request complete processing and\n    // potentially shadow.\n    callbacks_->addDecodedData(data, true);\n  } else {\n    upstream_requests_.front()->encodeData(data, end_stream);\n  }\n\n  if (end_stream) {\n    onRequestComplete();\n  }\n\n  return Http::FilterDataStatus::StopIterationNoBuffer;\n}\n\nHttp::FilterTrailersStatus Filter::decodeTrailers(Http::HeaderMap& trailers) {\n  ENVOY_STREAM_LOG(debug, \"router decoding trailers:\\n{}\", *callbacks_, trailers);\n\n  // upstream_requests_.size() cannot be 0 because we add to it unconditionally\n  // in decodeHeaders(). It cannot be > 1 because that only happens when a per\n  // try timeout occurs with hedge_on_per_try_timeout enabled but the per\n  // try timeout timer is not started until onUpstreamComplete().\n  ASSERT(upstream_requests_.size() == 1);\n  downstream_trailers_ = &trailers;\n  for (auto& upstream_request : upstream_requests_) {\n    upstream_request->encodeTrailers(trailers);\n  }\n  onRequestComplete();\n  return Http::FilterTrailersStatus::StopIteration;\n}\n\nHttp::FilterMetadataStatus Filter::decodeMetadata(Http::MetadataMap& metadata_map) {\n  Http::MetadataMapPtr metadata_map_ptr = std::make_unique<Http::MetadataMap>(metadata_map);\n  ASSERT(upstream_requests_.size() == 1);\n  upstream_requests_.front()->encodeMetadata(std::move(metadata_map_ptr));\n  return Http::FilterMetadataStatus::Continue;\n}\n\nvoid Filter::setDecoderFilterCallbacks(Http::StreamDecoderFilterCallbacks& callbacks) {\n  callbacks_ = &callbacks;\n  // As the decoder filter only pushes back via watermarks once data has reached\n  // it, it can latch the current buffer limit and does not need to update the\n  // limit if another filter increases it.\n  buffer_limit_ = callbacks_->decoderBufferLimit();\n}\n\nvoid Filter::cleanup() {\n  // All callers of cleanup() should have cleaned out the upstream_requests_\n  // list as appropriate.\n  ASSERT(upstream_requests_.empty());\n\n  retry_state_.reset();\n  if (response_timeout_) {\n    response_timeout_->disableTimer();\n    response_timeout_.reset();\n  }\n}\n\nvoid Filter::maybeDoShadowing() {\n  if (!do_shadowing_) {\n    return;\n  }\n\n  ASSERT(!route_entry_->shadowPolicy().cluster().empty());\n  Http::MessagePtr request(new Http::RequestMessageImpl(\n      Http::HeaderMapPtr{new Http::HeaderMapImpl(*downstream_headers_)}));\n  if (callbacks_->decodingBuffer()) {\n    request->body() = std::make_unique<Buffer::OwnedImpl>(*callbacks_->decodingBuffer());\n  }\n  if (downstream_trailers_) {\n    request->trailers(Http::HeaderMapPtr{new Http::HeaderMapImpl(*downstream_trailers_)});\n  }\n\n  config_.shadowWriter().shadow(route_entry_->shadowPolicy().cluster(), std::move(request),\n                                timeout_.global_timeout_);\n}\n\nvoid Filter::onRequestComplete() {\n  // This should be called exactly once, when the downstream request has been received in full.\n  ASSERT(!downstream_end_stream_);\n  downstream_end_stream_ = true;\n  Event::Dispatcher& dispatcher = callbacks_->dispatcher();\n  downstream_request_complete_time_ = dispatcher.timeSource().monotonicTime();\n\n  // Possible that we got an immediate reset.\n  if (!upstream_requests_.empty()) {\n    // Even if we got an immediate reset, we could still shadow, but that is a riskier change and\n    // seems unnecessary right now.\n    maybeDoShadowing();\n\n    if (timeout_.global_timeout_.count() > 0) {\n      response_timeout_ = dispatcher.createTimer([this]() -> void { onResponseTimeout(); });\n      response_timeout_->enableTimer(timeout_.global_timeout_);\n    }\n\n    for (auto& upstream_request : upstream_requests_) {\n      if (upstream_request->create_per_try_timeout_on_request_complete_) {\n        upstream_request->setupPerTryTimeout();\n      }\n    }\n  }\n}\n\nvoid Filter::onDestroy() {\n  // Reset any in-flight upstream requests.\n  resetAll();\n  cleanup();\n}\n\nvoid Filter::onResponseTimeout() {\n  ENVOY_STREAM_LOG(debug, \"upstream timeout\", *callbacks_);\n\n  // If we had an upstream request that got a \"good\" response, save its\n  // upstream timing information into the downstream stream info.\n  if (final_upstream_request_) {\n    callbacks_->streamInfo().setUpstreamTiming(final_upstream_request_->upstream_timing_);\n  }\n\n  // Reset any upstream requests that are still in flight.\n  while (!upstream_requests_.empty()) {\n    UpstreamRequestPtr upstream_request =\n        upstream_requests_.back()->removeFromList(upstream_requests_);\n\n    // Don't record a timeout for upstream requests we've already seen headers\n    // for.\n    if (upstream_request->awaiting_headers_) {\n      cluster_->stats().upstream_rq_timeout_.inc();\n      if (upstream_request->upstream_host_) {\n        upstream_request->upstream_host_->stats().rq_timeout_.inc();\n      }\n\n      // If this upstream request already hit a \"soft\" timeout, then it\n      // already recorded a timeout into outlier detection. Don't do it again.\n      if (!upstream_request->outlier_detection_timeout_recorded_) {\n        updateOutlierDetection(Upstream::Outlier::Result::LOCAL_ORIGIN_TIMEOUT, *upstream_request,\n                               absl::optional<uint64_t>(enumToInt(timeout_response_code_)));\n      }\n\n      chargeUpstreamAbort(timeout_response_code_, false, *upstream_request);\n    }\n    upstream_request->resetStream();\n  }\n\n  onUpstreamTimeoutAbort(StreamInfo::ResponseFlag::UpstreamRequestTimeout,\n                         StreamInfo::ResponseCodeDetails::get().UpstreamTimeout);\n}\n\n// Called when the per try timeout is hit but we didn't reset the request\n// (hedge_on_per_try_timeout enabled).\nvoid Filter::onSoftPerTryTimeout(UpstreamRequest& upstream_request) {\n  // Track this as a timeout for outlier detection purposes even though we didn't\n  // cancel the request yet and might get a 2xx later.\n  updateOutlierDetection(Upstream::Outlier::Result::LOCAL_ORIGIN_TIMEOUT, upstream_request,\n                         absl::optional<uint64_t>(enumToInt(timeout_response_code_)));\n  upstream_request.outlier_detection_timeout_recorded_ = true;\n\n  if (!downstream_response_started_ && retry_state_) {\n    RetryStatus retry_status =\n        retry_state_->shouldHedgeRetryPerTryTimeout([this]() -> void { doRetry(); });\n\n    if (retry_status == RetryStatus::Yes && setupRetry()) {\n      setupRetry();\n      // Don't increment upstream_host->stats().rq_error_ here, we'll do that\n      // later if 1) we hit global timeout or 2) we get bad response headers\n      // back.\n      upstream_request.retried_ = true;\n\n      // TODO: cluster stat for hedge attempted.\n    } else if (retry_status == RetryStatus::NoOverflow) {\n      callbacks_->streamInfo().setResponseFlag(StreamInfo::ResponseFlag::UpstreamOverflow);\n    } else if (retry_status == RetryStatus::NoRetryLimitExceeded) {\n      callbacks_->streamInfo().setResponseFlag(\n          StreamInfo::ResponseFlag::UpstreamRetryLimitExceeded);\n    }\n  }\n}\n\nvoid Filter::onPerTryTimeout(UpstreamRequest& upstream_request) {\n  if (hedging_params_.hedge_on_per_try_timeout_) {\n    onSoftPerTryTimeout(upstream_request);\n    return;\n  }\n\n  cluster_->stats().upstream_rq_per_try_timeout_.inc();\n  if (upstream_request.upstream_host_) {\n    upstream_request.upstream_host_->stats().rq_timeout_.inc();\n  }\n\n  upstream_request.resetStream();\n\n  updateOutlierDetection(Upstream::Outlier::Result::LOCAL_ORIGIN_TIMEOUT, upstream_request,\n                         absl::optional<uint64_t>(enumToInt(timeout_response_code_)));\n\n  if (maybeRetryReset(Http::StreamResetReason::LocalReset, upstream_request)) {\n    return;\n  }\n\n  chargeUpstreamAbort(timeout_response_code_, false, upstream_request);\n\n  // Remove this upstream request from the list now that we're done with it.\n  upstream_request.removeFromList(upstream_requests_);\n  onUpstreamTimeoutAbort(StreamInfo::ResponseFlag::UpstreamRequestTimeout,\n                         StreamInfo::ResponseCodeDetails::get().UpstreamPerTryTimeout);\n}\n\nvoid Filter::updateOutlierDetection(Upstream::Outlier::Result result,\n                                    UpstreamRequest& upstream_request,\n                                    absl::optional<uint64_t> code) {\n  if (upstream_request.upstream_host_) {\n    upstream_request.upstream_host_->outlierDetector().putResult(result, code);\n  }\n}\n\nvoid Filter::chargeUpstreamAbort(Http::Code code, bool dropped, UpstreamRequest& upstream_request) {\n  if (downstream_response_started_) {\n    if (upstream_request.grpc_rq_success_deferred_) {\n      upstream_request.upstream_host_->stats().rq_error_.inc();\n      config_.stats_.rq_reset_after_downstream_response_started_.inc();\n    }\n  } else {\n    Upstream::HostDescriptionConstSharedPtr upstream_host = upstream_request.upstream_host_;\n\n    chargeUpstreamCode(code, upstream_host, dropped);\n    // If we had non-5xx but still have been reset by backend or timeout before\n    // starting response, we treat this as an error. We only get non-5xx when\n    // timeout_response_code_ is used for code above, where this member can\n    // assume values such as 204 (NoContent).\n    if (upstream_host != nullptr && !Http::CodeUtility::is5xx(enumToInt(code))) {\n      upstream_host->stats().rq_error_.inc();\n    }\n  }\n}\n\nvoid Filter::onUpstreamTimeoutAbort(StreamInfo::ResponseFlag response_flags,\n                                    absl::string_view details) {\n  const absl::string_view body =\n      timeout_response_code_ == Http::Code::GatewayTimeout ? \"upstream request timeout\" : \"\";\n  onUpstreamAbort(timeout_response_code_, response_flags, body, false, details);\n}\n\nvoid Filter::onUpstreamAbort(Http::Code code, StreamInfo::ResponseFlag response_flags,\n                             absl::string_view body, bool dropped, absl::string_view details) {\n  // If we have not yet sent anything downstream, send a response with an appropriate status code.\n  // Otherwise just reset the ongoing response.\n  if (downstream_response_started_) {\n    // This will destroy any created retry timers.\n    callbacks_->streamInfo().setResponseCodeDetails(details);\n    cleanup();\n    callbacks_->resetStream();\n  } else {\n    // This will destroy any created retry timers.\n    cleanup();\n\n    callbacks_->streamInfo().setResponseFlag(response_flags);\n\n    callbacks_->sendLocalReply(\n        code, body,\n        [dropped, this](Http::HeaderMap& headers) {\n          if (dropped && !config_.suppress_envoy_headers_) {\n            headers.insertEnvoyOverloaded().value(Http::Headers::get().EnvoyOverloadedValues.True);\n          }\n          modify_headers_(headers);\n        },\n        absl::nullopt, details);\n  }\n}\n\nbool Filter::maybeRetryReset(Http::StreamResetReason reset_reason,\n                             UpstreamRequest& upstream_request) {\n  // We don't retry if we already started the response, don't have a retry policy defined,\n  // or if we've already retried this upstream request (currently only possible if a per\n  // try timeout occurred and hedge_on_per_try_timeout is enabled).\n  if (downstream_response_started_ || !retry_state_ || upstream_request.retried_) {\n    return false;\n  }\n\n  const RetryStatus retry_status =\n      retry_state_->shouldRetryReset(reset_reason, [this]() -> void { doRetry(); });\n  if (retry_status == RetryStatus::Yes && setupRetry()) {\n    if (upstream_request.upstream_host_) {\n      upstream_request.upstream_host_->stats().rq_error_.inc();\n    }\n    upstream_request.removeFromList(upstream_requests_);\n    return true;\n  } else if (retry_status == RetryStatus::NoOverflow) {\n    callbacks_->streamInfo().setResponseFlag(StreamInfo::ResponseFlag::UpstreamOverflow);\n  } else if (retry_status == RetryStatus::NoRetryLimitExceeded) {\n    callbacks_->streamInfo().setResponseFlag(StreamInfo::ResponseFlag::UpstreamRetryLimitExceeded);\n  }\n\n  return false;\n}\n\nvoid Filter::onUpstreamReset(Http::StreamResetReason reset_reason,\n                             absl::string_view transport_failure_reason,\n                             UpstreamRequest& upstream_request) {\n  ENVOY_STREAM_LOG(debug, \"upstream reset: reset reason {}\", *callbacks_,\n                   Http::Utility::resetReasonToString(reset_reason));\n\n  // TODO: The reset may also come from upstream over the wire. In this case it should be\n  // treated as external origin error and distinguished from local origin error.\n  // This matters only when running OutlierDetection with split_external_local_origin_errors config\n  // param set to true.\n  updateOutlierDetection(Upstream::Outlier::Result::LOCAL_ORIGIN_CONNECT_FAILED, upstream_request,\n                         absl::nullopt);\n\n  if (maybeRetryReset(reset_reason, upstream_request)) {\n    return;\n  }\n\n  const bool dropped = reset_reason == Http::StreamResetReason::Overflow;\n  chargeUpstreamAbort(Http::Code::ServiceUnavailable, dropped, upstream_request);\n  upstream_request.removeFromList(upstream_requests_);\n\n  // If there are other in-flight requests that might see an upstream response,\n  // don't return anything downstream.\n  if (numRequestsAwaitingHeaders() > 0 || pending_retries_ > 0) {\n    return;\n  }\n\n  const StreamInfo::ResponseFlag response_flags = streamResetReasonToResponseFlag(reset_reason);\n  const std::string body =\n      absl::StrCat(\"upstream connect error or disconnect/reset before headers. reset reason: \",\n                   Http::Utility::resetReasonToString(reset_reason));\n\n  callbacks_->streamInfo().setUpstreamTransportFailureReason(transport_failure_reason);\n  const std::string& basic_details =\n      downstream_response_started_ ? StreamInfo::ResponseCodeDetails::get().LateUpstreamReset\n                                   : StreamInfo::ResponseCodeDetails::get().EarlyUpstreamReset;\n  const std::string details = absl::StrCat(\n      basic_details, \"{\", Http::Utility::resetReasonToString(reset_reason),\n      transport_failure_reason.empty() ? \"\" : absl::StrCat(\",\", transport_failure_reason), \"}\");\n  onUpstreamAbort(Http::Code::ServiceUnavailable, response_flags, body, dropped, details);\n}\n\nStreamInfo::ResponseFlag\nFilter::streamResetReasonToResponseFlag(Http::StreamResetReason reset_reason) {\n  switch (reset_reason) {\n  case Http::StreamResetReason::ConnectionFailure:\n    return StreamInfo::ResponseFlag::UpstreamConnectionFailure;\n  case Http::StreamResetReason::ConnectionTermination:\n    return StreamInfo::ResponseFlag::UpstreamConnectionTermination;\n  case Http::StreamResetReason::LocalReset:\n  case Http::StreamResetReason::LocalRefusedStreamReset:\n    return StreamInfo::ResponseFlag::LocalReset;\n  case Http::StreamResetReason::Overflow:\n    return StreamInfo::ResponseFlag::UpstreamOverflow;\n  case Http::StreamResetReason::RemoteReset:\n  case Http::StreamResetReason::RemoteRefusedStreamReset:\n    return StreamInfo::ResponseFlag::UpstreamRemoteReset;\n  }\n\n  NOT_REACHED_GCOVR_EXCL_LINE;\n}\n\nvoid Filter::handleNon5xxResponseHeaders(absl::optional<Grpc::Status::GrpcStatus> grpc_status,\n                                         UpstreamRequest& upstream_request, bool end_stream,\n                                         uint64_t grpc_to_http_status) {\n  // We need to defer gRPC success until after we have processed grpc-status in\n  // the trailers.\n  if (grpc_request_) {\n    if (end_stream) {\n      if (grpc_status && !Http::CodeUtility::is5xx(grpc_to_http_status)) {\n        upstream_request.upstream_host_->stats().rq_success_.inc();\n      } else {\n        upstream_request.upstream_host_->stats().rq_error_.inc();\n      }\n    } else {\n      upstream_request.grpc_rq_success_deferred_ = true;\n    }\n  } else {\n    upstream_request.upstream_host_->stats().rq_success_.inc();\n  }\n}\n\nvoid Filter::onUpstream100ContinueHeaders(Http::HeaderMapPtr&& headers,\n                                          UpstreamRequest& upstream_request) {\n  chargeUpstreamCode(100, *headers, upstream_request.upstream_host_, false);\n  ENVOY_STREAM_LOG(debug, \"upstream 100 continue\", *callbacks_);\n\n  downstream_response_started_ = true;\n  final_upstream_request_ = &upstream_request;\n  resetOtherUpstreams(upstream_request);\n\n  // Don't send retries after 100-Continue has been sent on. Arguably we could attempt to do a\n  // retry, assume the next upstream would also send an 100-Continue and swallow the second one\n  // but it's sketchy (as the subsequent upstream might not send a 100-Continue) and not worth\n  // the complexity until someone asks for it.\n  retry_state_.reset();\n\n  callbacks_->encode100ContinueHeaders(std::move(headers));\n}\n\nvoid Filter::resetAll() {\n  while (!upstream_requests_.empty()) {\n    upstream_requests_.back()->removeFromList(upstream_requests_)->resetStream();\n  }\n}\n\nvoid Filter::resetOtherUpstreams(UpstreamRequest& upstream_request) {\n  // Pop each upstream request on the list and reset it if it's not the one\n  // provided. At the end we'll move it back into the list.\n  UpstreamRequestPtr final_upstream_request;\n  while (!upstream_requests_.empty()) {\n    UpstreamRequestPtr upstream_request_tmp =\n        upstream_requests_.back()->removeFromList(upstream_requests_);\n    if (upstream_request_tmp.get() != &upstream_request) {\n      upstream_request_tmp->resetStream();\n      // TODO: per-host stat for hedge abandoned.\n      // TODO: cluster stat for hedge abandoned.\n    } else {\n      final_upstream_request = std::move(upstream_request_tmp);\n    }\n  }\n\n  ASSERT(final_upstream_request);\n  // Now put the final request back on this list.\n  final_upstream_request->moveIntoList(std::move(final_upstream_request), upstream_requests_);\n}\n\nvoid Filter::onUpstreamHeaders(uint64_t response_code, Http::HeaderMapPtr&& headers,\n                               UpstreamRequest& upstream_request, bool end_stream) {\n  ENVOY_STREAM_LOG(debug, \"upstream headers complete: end_stream={}\", *callbacks_, end_stream);\n\n  modify_headers_(*headers);\n  // When grpc-status appears in response headers, convert grpc-status to HTTP status code\n  // for outlier detection. This does not currently change any stats or logging and does not\n  // handle the case when an error grpc-status is sent as a trailer.\n  absl::optional<Grpc::Status::GrpcStatus> grpc_status;\n  uint64_t grpc_to_http_status = 0;\n  if (grpc_request_) {\n    grpc_status = Grpc::Common::getGrpcStatus(*headers);\n    if (grpc_status.has_value()) {\n      grpc_to_http_status = Grpc::Utility::grpcToHttpStatus(grpc_status.value());\n    }\n  }\n\n  if (grpc_status.has_value() &&\n      Runtime::runtimeFeatureEnabled(\n          \"envoy.reloadable_features.outlier_detection_support_for_grpc_status\")) {\n    upstream_request.upstream_host_->outlierDetector().putHttpResponseCode(grpc_to_http_status);\n  } else {\n    upstream_request.upstream_host_->outlierDetector().putHttpResponseCode(response_code);\n  }\n\n  if (headers->EnvoyImmediateHealthCheckFail() != nullptr) {\n    upstream_request.upstream_host_->healthChecker().setUnhealthy();\n  }\n\n  bool could_not_retry = false;\n\n  // Check if this upstream request was already retried, for instance after\n  // hitting a per try timeout. Don't retry it if we already have.\n  if (retry_state_) {\n    if (upstream_request.retried_) {\n      // We already retried this request (presumably for a per try timeout) so\n      // we definitely won't retry it again. Check if we would have retried it\n      // if we could.\n      could_not_retry = retry_state_->wouldRetryFromHeaders(*headers);\n    } else {\n      const RetryStatus retry_status =\n          retry_state_->shouldRetryHeaders(*headers, [this]() -> void { doRetry(); });\n      // Capture upstream_host since setupRetry() in the following line will clear\n      // upstream_request.\n      const auto upstream_host = upstream_request.upstream_host_;\n      if (retry_status == RetryStatus::Yes && setupRetry()) {\n        if (!end_stream) {\n          upstream_request.resetStream();\n        }\n        upstream_request.removeFromList(upstream_requests_);\n\n        Http::CodeStats& code_stats = httpContext().codeStats();\n        code_stats.chargeBasicResponseStat(cluster_->statsScope(), config_.retry_,\n                                           static_cast<Http::Code>(response_code));\n        upstream_host->stats().rq_error_.inc();\n        return;\n      } else if (retry_status == RetryStatus::NoOverflow) {\n        callbacks_->streamInfo().setResponseFlag(StreamInfo::ResponseFlag::UpstreamOverflow);\n        could_not_retry = true;\n      } else if (retry_status == RetryStatus::NoRetryLimitExceeded) {\n        callbacks_->streamInfo().setResponseFlag(\n            StreamInfo::ResponseFlag::UpstreamRetryLimitExceeded);\n        could_not_retry = true;\n      }\n    }\n  }\n\n  if (static_cast<Http::Code>(response_code) == Http::Code::Found &&\n      route_entry_->internalRedirectAction() == InternalRedirectAction::Handle &&\n      setupRedirect(*headers, upstream_request)) {\n    return;\n    // If the redirect could not be handled, fail open and let it pass to the\n    // next downstream.\n  }\n\n  // Check if we got a \"bad\" response, but there are still upstream requests in\n  // flight awaiting headers or scheduled retries. If so, exit to give them a\n  // chance to return before returning a response downstream.\n  if (could_not_retry && (numRequestsAwaitingHeaders() > 0 || pending_retries_ > 0)) {\n    upstream_request.upstream_host_->stats().rq_error_.inc();\n\n    // Reset the stream because there are other in-flight requests that we'll\n    // wait around for and we're not interested in consuming any body/trailers.\n    upstream_request.removeFromList(upstream_requests_)->resetStream();\n    return;\n  }\n\n  // Make sure any retry timers are destroyed since we may not call cleanup() if end_stream is\n  // false.\n  if (retry_state_) {\n    retry_state_.reset();\n  }\n\n  // Only send upstream service time if we received the complete request and this is not a\n  // premature response.\n  if (DateUtil::timePointValid(downstream_request_complete_time_)) {\n    Event::Dispatcher& dispatcher = callbacks_->dispatcher();\n    MonotonicTime response_received_time = dispatcher.timeSource().monotonicTime();\n    std::chrono::milliseconds ms = std::chrono::duration_cast<std::chrono::milliseconds>(\n        response_received_time - downstream_request_complete_time_);\n    if (!config_.suppress_envoy_headers_) {\n      headers->insertEnvoyUpstreamServiceTime().value(ms.count());\n    }\n  }\n\n  upstream_request.upstream_canary_ =\n      (headers->EnvoyUpstreamCanary() && headers->EnvoyUpstreamCanary()->value() == \"true\") ||\n      upstream_request.upstream_host_->canary();\n  chargeUpstreamCode(response_code, *headers, upstream_request.upstream_host_, false);\n  if (!Http::CodeUtility::is5xx(response_code)) {\n    handleNon5xxResponseHeaders(grpc_status, upstream_request, end_stream, grpc_to_http_status);\n  }\n\n  // Append routing cookies\n  for (const auto& header_value : downstream_set_cookies_) {\n    headers->addReferenceKey(Http::Headers::get().SetCookie, header_value);\n  }\n\n  // TODO(zuercher): If access to response_headers_to_add (at any level) is ever needed outside\n  // Router::Filter we'll need to find a better location for this work. One possibility is to\n  // provide finalizeResponseHeaders functions on the Router::Config and VirtualHost interfaces.\n  route_entry_->finalizeResponseHeaders(*headers, callbacks_->streamInfo());\n\n  downstream_response_started_ = true;\n  final_upstream_request_ = &upstream_request;\n  resetOtherUpstreams(upstream_request);\n  if (end_stream) {\n    onUpstreamComplete(upstream_request);\n  }\n\n  callbacks_->streamInfo().setResponseCodeDetails(\n      StreamInfo::ResponseCodeDetails::get().ViaUpstream);\n  callbacks_->encodeHeaders(std::move(headers), end_stream);\n}\n\nvoid Filter::onUpstreamData(Buffer::Instance& data, UpstreamRequest& upstream_request,\n                            bool end_stream) {\n  // This should be true because when we saw headers we either reset the stream\n  // (hence wouldn't have made it to onUpstreamData) or all other in-flight\n  // streams.\n  ASSERT(upstream_requests_.size() == 1);\n  if (end_stream) {\n    // gRPC request termination without trailers is an error.\n    if (upstream_request.grpc_rq_success_deferred_) {\n      upstream_request.upstream_host_->stats().rq_error_.inc();\n    }\n    onUpstreamComplete(upstream_request);\n  }\n\n  callbacks_->encodeData(data, end_stream);\n}\n\nvoid Filter::onUpstreamTrailers(Http::HeaderMapPtr&& trailers, UpstreamRequest& upstream_request) {\n  // This should be true because when we saw headers we either reset the stream\n  // (hence wouldn't have made it to onUpstreamTrailers) or all other in-flight\n  // streams.\n  ASSERT(upstream_requests_.size() == 1);\n\n  if (upstream_request.grpc_rq_success_deferred_) {\n    absl::optional<Grpc::Status::GrpcStatus> grpc_status = Grpc::Common::getGrpcStatus(*trailers);\n    if (grpc_status &&\n        !Http::CodeUtility::is5xx(Grpc::Utility::grpcToHttpStatus(grpc_status.value()))) {\n      upstream_request.upstream_host_->stats().rq_success_.inc();\n    } else {\n      upstream_request.upstream_host_->stats().rq_error_.inc();\n    }\n  }\n\n  onUpstreamComplete(upstream_request);\n\n  callbacks_->encodeTrailers(std::move(trailers));\n}\n\nvoid Filter::onUpstreamMetadata(Http::MetadataMapPtr&& metadata_map) {\n  callbacks_->encodeMetadata(std::move(metadata_map));\n}\n\nvoid Filter::onUpstreamComplete(UpstreamRequest& upstream_request) {\n  if (!downstream_end_stream_) {\n    upstream_request.resetStream();\n  }\n  callbacks_->streamInfo().setUpstreamTiming(final_upstream_request_->upstream_timing_);\n\n  if (config_.emit_dynamic_stats_ && !callbacks_->streamInfo().healthCheck() &&\n      DateUtil::timePointValid(downstream_request_complete_time_)) {\n    Event::Dispatcher& dispatcher = callbacks_->dispatcher();\n    std::chrono::milliseconds response_time = std::chrono::duration_cast<std::chrono::milliseconds>(\n        dispatcher.timeSource().monotonicTime() - downstream_request_complete_time_);\n\n    upstream_request.upstream_host_->outlierDetector().putResponseTime(response_time);\n\n    const Http::HeaderEntry* internal_request_header = downstream_headers_->EnvoyInternalRequest();\n    const bool internal_request =\n        internal_request_header && internal_request_header->value() == \"true\";\n\n    Http::CodeStats& code_stats = httpContext().codeStats();\n    Http::CodeStats::ResponseTimingInfo info{config_.scope_,\n                                             cluster_->statsScope(),\n                                             config_.empty_stat_name_,\n                                             response_time,\n                                             upstream_request.upstream_canary_,\n                                             internal_request,\n                                             route_entry_->virtualHost().statName(),\n                                             request_vcluster_ ? request_vcluster_->statName()\n                                                               : config_.empty_stat_name_,\n                                             config_.zone_name_,\n                                             upstreamZone(upstream_request.upstream_host_)};\n\n    code_stats.chargeResponseTiming(info);\n\n    if (alt_stat_prefix_ != nullptr) {\n      Http::CodeStats::ResponseTimingInfo info{config_.scope_,\n                                               cluster_->statsScope(),\n                                               alt_stat_prefix_->statName(),\n                                               response_time,\n                                               upstream_request.upstream_canary_,\n                                               internal_request,\n                                               config_.empty_stat_name_,\n                                               config_.empty_stat_name_,\n                                               config_.zone_name_,\n                                               upstreamZone(upstream_request.upstream_host_)};\n\n      code_stats.chargeResponseTiming(info);\n    }\n  }\n\n  upstream_request.removeFromList(upstream_requests_);\n  cleanup();\n}\n\nbool Filter::setupRetry() {\n  // If we responded before the request was complete we don't bother doing a retry. This may not\n  // catch certain cases where we are in full streaming mode and we have a connect timeout or an\n  // overflow of some kind. However, in many cases deployments will use the buffer filter before\n  // this filter which will make this a non-issue. The implementation of supporting retry in cases\n  // where the request is not complete is more complicated so we will start with this for now.\n  if (!downstream_end_stream_) {\n    config_.stats_.rq_retry_skipped_request_not_complete_.inc();\n    return false;\n  }\n  pending_retries_++;\n\n  ENVOY_STREAM_LOG(debug, \"performing retry\", *callbacks_);\n\n  return true;\n}\n\nbool Filter::setupRedirect(const Http::HeaderMap& headers, UpstreamRequest& upstream_request) {\n  ENVOY_STREAM_LOG(debug, \"attempting internal redirect\", *callbacks_);\n  const Http::HeaderEntry* location = headers.Location();\n\n  // If the internal redirect succeeds, callbacks_->recreateStream() will result in the destruction\n  // of this filter before the stream is marked as complete, and onDestroy will reset the stream.\n  //\n  // Normally when a stream is complete we signal this by resetting the upstream but this cam not be\n  // done in this case because if recreateStream fails, the \"failure\" path continues to call code\n  // in onUpstreamHeaders which requires the upstream *not* be reset. To avoid onDestroy performing\n  // a spurious stream reset in the case recreateStream() succeeds, we explicitly track stream\n  // completion here and check it in onDestroy. This is annoyingly complicated but is better than\n  // needlessly resetting streams.\n  attempting_internal_redirect_with_complete_stream_ =\n      upstream_request.upstream_timing_.last_upstream_rx_byte_received_ && downstream_end_stream_;\n\n  // As with setupRetry, redirects are not supported for streaming requests yet.\n  if (downstream_end_stream_ &&\n      !callbacks_->decodingBuffer() && // Redirects with body not yet supported.\n      location != nullptr &&\n      convertRequestHeadersForInternalRedirect(*downstream_headers_, *location,\n                                               *callbacks_->connection()) &&\n      callbacks_->recreateStream()) {\n    cluster_->stats().upstream_internal_redirect_succeeded_total_.inc();\n    return true;\n  }\n\n  attempting_internal_redirect_with_complete_stream_ = false;\n\n  ENVOY_STREAM_LOG(debug, \"Internal redirect failed\", *callbacks_);\n  cluster_->stats().upstream_internal_redirect_failed_total_.inc();\n  return false;\n}\n\nvoid Filter::doRetry() {\n  is_retry_ = true;\n  attempt_count_++;\n  ASSERT(pending_retries_ > 0);\n  pending_retries_--;\n  Http::ConnectionPool::Instance* conn_pool = getConnPool();\n  if (!conn_pool) {\n    sendNoHealthyUpstreamResponse();\n    cleanup();\n    return;\n  }\n\n  if (include_attempt_count_) {\n    downstream_headers_->insertEnvoyAttemptCount().value(attempt_count_);\n  }\n\n  ASSERT(response_timeout_ || timeout_.global_timeout_.count() == 0);\n  UpstreamRequestPtr upstream_request = std::make_unique<UpstreamRequest>(*this, *conn_pool);\n  UpstreamRequest* upstream_request_tmp = upstream_request.get();\n  upstream_request->moveIntoList(std::move(upstream_request), upstream_requests_);\n  upstream_requests_.front()->encodeHeaders(!callbacks_->decodingBuffer() && !downstream_trailers_);\n  // It's possible we got immediately reset which means the upstream request we just\n  // added to the front of the list might have been removed, so we need to check to make\n  // sure we don't encodeData on the wrong request.\n  if (!upstream_requests_.empty() && (upstream_requests_.front().get() == upstream_request_tmp)) {\n    if (callbacks_->decodingBuffer()) {\n      // If we are doing a retry we need to make a copy.\n      Buffer::OwnedImpl copy(*callbacks_->decodingBuffer());\n      upstream_requests_.front()->encodeData(copy, !downstream_trailers_);\n    }\n\n    if (downstream_trailers_) {\n      upstream_requests_.front()->encodeTrailers(*downstream_trailers_);\n    }\n  }\n}\n\nuint32_t Filter::numRequestsAwaitingHeaders() {\n  return std::count_if(upstream_requests_.begin(), upstream_requests_.end(),\n                       [](const auto& req) -> bool { return req->awaiting_headers_; });\n}\n\nFilter::UpstreamRequest::UpstreamRequest(Filter& parent, Http::ConnectionPool::Instance& pool)\n    : parent_(parent), conn_pool_(pool), grpc_rq_success_deferred_(false),\n      stream_info_(pool.protocol(), parent_.callbacks_->dispatcher().timeSource()),\n      calling_encode_headers_(false), upstream_canary_(false), decode_complete_(false),\n      encode_complete_(false), encode_trailers_(false), retried_(false), awaiting_headers_(true),\n      outlier_detection_timeout_recorded_(false),\n      create_per_try_timeout_on_request_complete_(false) {\n\n  if (parent_.config_.start_child_span_) {\n    span_ = parent_.callbacks_->activeSpan().spawnChild(\n        parent_.callbacks_->tracingConfig(), \"router \" + parent.cluster_->name() + \" egress\",\n        parent.timeSource().systemTime());\n    if (parent.attempt_count_ != 1) {\n      // This is a retry request, add this metadata to span.\n      span_->setTag(Tracing::Tags::get().RetryCount, std::to_string(parent.attempt_count_ - 1));\n    }\n  }\n\n  stream_info_.healthCheck(parent_.callbacks_->streamInfo().healthCheck());\n}\n\nFilter::UpstreamRequest::~UpstreamRequest() {\n  if (span_ != nullptr) {\n    Tracing::HttpTracerUtility::finalizeUpstreamSpan(*span_, upstream_headers_.get(),\n                                                     upstream_trailers_.get(), stream_info_,\n                                                     Tracing::EgressConfig::get());\n  }\n\n  if (per_try_timeout_ != nullptr) {\n    // Allows for testing.\n    per_try_timeout_->disableTimer();\n  }\n  clearRequestEncoder();\n\n  stream_info_.setUpstreamTiming(upstream_timing_);\n  stream_info_.onRequestComplete();\n  for (const auto& upstream_log : parent_.config_.upstream_logs_) {\n    upstream_log->log(parent_.downstream_headers_, upstream_headers_.get(),\n                      upstream_trailers_.get(), stream_info_);\n  }\n}\n\nvoid Filter::UpstreamRequest::decode100ContinueHeaders(Http::HeaderMapPtr&& headers) {\n  ScopeTrackerScopeState scope(&parent_.callbacks_->scope(), parent_.callbacks_->dispatcher());\n\n  ASSERT(100 == Http::Utility::getResponseStatus(*headers));\n  parent_.onUpstream100ContinueHeaders(std::move(headers), *this);\n}\n\nvoid Filter::UpstreamRequest::decodeHeaders(Http::HeaderMapPtr&& headers, bool end_stream) {\n  ScopeTrackerScopeState scope(&parent_.callbacks_->scope(), parent_.callbacks_->dispatcher());\n\n  // TODO(rodaine): This is actually measuring after the headers are parsed and not the first byte.\n  upstream_timing_.onFirstUpstreamRxByteReceived(parent_.callbacks_->dispatcher().timeSource());\n  maybeEndDecode(end_stream);\n\n  awaiting_headers_ = false;\n  if (!parent_.config_.upstream_logs_.empty()) {\n    upstream_headers_ = std::make_unique<Http::HeaderMapImpl>(*headers);\n  }\n  const uint64_t response_code = Http::Utility::getResponseStatus(*headers);\n  stream_info_.response_code_ = static_cast<uint32_t>(response_code);\n  parent_.onUpstreamHeaders(response_code, std::move(headers), *this, end_stream);\n}\n\nvoid Filter::UpstreamRequest::decodeData(Buffer::Instance& data, bool end_stream) {\n  ScopeTrackerScopeState scope(&parent_.callbacks_->scope(), parent_.callbacks_->dispatcher());\n\n  maybeEndDecode(end_stream);\n  stream_info_.addBytesReceived(data.length());\n  parent_.onUpstreamData(data, *this, end_stream);\n}\n\nvoid Filter::UpstreamRequest::decodeTrailers(Http::HeaderMapPtr&& trailers) {\n  ScopeTrackerScopeState scope(&parent_.callbacks_->scope(), parent_.callbacks_->dispatcher());\n\n  maybeEndDecode(true);\n  if (!parent_.config_.upstream_logs_.empty()) {\n    upstream_trailers_ = std::make_unique<Http::HeaderMapImpl>(*trailers);\n  }\n  parent_.onUpstreamTrailers(std::move(trailers), *this);\n}\n\nvoid Filter::UpstreamRequest::decodeMetadata(Http::MetadataMapPtr&& metadata_map) {\n  parent_.onUpstreamMetadata(std::move(metadata_map));\n}\n\nvoid Filter::UpstreamRequest::maybeEndDecode(bool end_stream) {\n  if (end_stream) {\n    upstream_timing_.onLastUpstreamRxByteReceived(parent_.callbacks_->dispatcher().timeSource());\n    decode_complete_ = true;\n  }\n}\n\nvoid Filter::UpstreamRequest::encodeHeaders(bool end_stream) {\n  ASSERT(!encode_complete_);\n  encode_complete_ = end_stream;\n\n  // It's possible for a reset to happen inline within the newStream() call. In this case, we might\n  // get deleted inline as well. Only write the returned handle out if it is not nullptr to deal\n  // with this case.\n  Http::ConnectionPool::Cancellable* handle = conn_pool_.newStream(*this, *this);\n  if (handle) {\n    conn_pool_stream_handle_ = handle;\n  }\n}\n\nvoid Filter::UpstreamRequest::encodeData(Buffer::Instance& data, bool end_stream) {\n  ASSERT(!encode_complete_);\n  encode_complete_ = end_stream;\n\n  if (!request_encoder_) {\n    ENVOY_STREAM_LOG(trace, \"buffering {} bytes\", *parent_.callbacks_, data.length());\n    if (!buffered_request_body_) {\n      buffered_request_body_ = std::make_unique<Buffer::WatermarkBuffer>(\n          [this]() -> void { this->enableDataFromDownstream(); },\n          [this]() -> void { this->disableDataFromDownstream(); });\n      buffered_request_body_->setWatermarks(parent_.buffer_limit_);\n    }\n\n    buffered_request_body_->move(data);\n  } else {\n    ASSERT(downstream_metadata_map_vector_.empty());\n\n    ENVOY_STREAM_LOG(trace, \"proxying {} bytes\", *parent_.callbacks_, data.length());\n    stream_info_.addBytesSent(data.length());\n    request_encoder_->encodeData(data, end_stream);\n    if (end_stream) {\n      upstream_timing_.onLastUpstreamTxByteSent(parent_.callbacks_->dispatcher().timeSource());\n    }\n  }\n}\n\nvoid Filter::UpstreamRequest::encodeTrailers(const Http::HeaderMap& trailers) {\n  ASSERT(!encode_complete_);\n  encode_complete_ = true;\n  encode_trailers_ = true;\n\n  if (!request_encoder_) {\n    ENVOY_STREAM_LOG(trace, \"buffering trailers\", *parent_.callbacks_);\n  } else {\n    ASSERT(downstream_metadata_map_vector_.empty());\n\n    ENVOY_STREAM_LOG(trace, \"proxying trailers\", *parent_.callbacks_);\n    request_encoder_->encodeTrailers(trailers);\n    upstream_timing_.onLastUpstreamTxByteSent(parent_.callbacks_->dispatcher().timeSource());\n  }\n}\n\nvoid Filter::UpstreamRequest::encodeMetadata(Http::MetadataMapPtr&& metadata_map_ptr) {\n  if (!request_encoder_) {\n    ENVOY_STREAM_LOG(trace, \"request_encoder_ not ready. Store metadata_map to encode later: {}\",\n                     *parent_.callbacks_, *metadata_map_ptr);\n    downstream_metadata_map_vector_.emplace_back(std::move(metadata_map_ptr));\n  } else {\n    ENVOY_STREAM_LOG(trace, \"Encode metadata: {}\", *parent_.callbacks_, *metadata_map_ptr);\n    Http::MetadataMapVector metadata_map_vector;\n    metadata_map_vector.emplace_back(std::move(metadata_map_ptr));\n    request_encoder_->encodeMetadata(metadata_map_vector);\n  }\n}\n\nvoid Filter::UpstreamRequest::onResetStream(Http::StreamResetReason reason,\n                                            absl::string_view transport_failure_reason) {\n  ScopeTrackerScopeState scope(&parent_.callbacks_->scope(), parent_.callbacks_->dispatcher());\n\n  if (span_ != nullptr) {\n    // Add tags about reset.\n    span_->setTag(Tracing::Tags::get().Error, Tracing::Tags::get().True);\n    span_->setTag(Tracing::Tags::get().ErrorReason, Http::Utility::resetReasonToString(reason));\n  }\n\n  clearRequestEncoder();\n  awaiting_headers_ = false;\n  if (!calling_encode_headers_) {\n    stream_info_.setResponseFlag(parent_.streamResetReasonToResponseFlag(reason));\n    parent_.onUpstreamReset(reason, transport_failure_reason, *this);\n  } else {\n    deferred_reset_reason_ = reason;\n  }\n}\n\nvoid Filter::UpstreamRequest::resetStream() {\n  // Don't reset the stream if we're already done with it.\n  if (encode_complete_ && decode_complete_) {\n    return;\n  }\n\n  if (span_ != nullptr) {\n    // Add tags about the cancellation.\n    span_->setTag(Tracing::Tags::get().Canceled, Tracing::Tags::get().True);\n  }\n\n  if (conn_pool_stream_handle_) {\n    ENVOY_STREAM_LOG(debug, \"cancelling pool request\", *parent_.callbacks_);\n    ASSERT(!request_encoder_);\n    conn_pool_stream_handle_->cancel();\n    conn_pool_stream_handle_ = nullptr;\n  }\n\n  if (request_encoder_) {\n    ENVOY_STREAM_LOG(debug, \"resetting pool request\", *parent_.callbacks_);\n    request_encoder_->getStream().removeCallbacks(*this);\n    request_encoder_->getStream().resetStream(Http::StreamResetReason::LocalReset);\n    clearRequestEncoder();\n  }\n}\n\nvoid Filter::UpstreamRequest::setupPerTryTimeout() {\n  ASSERT(!per_try_timeout_);\n  if (parent_.timeout_.per_try_timeout_.count() > 0) {\n    per_try_timeout_ =\n        parent_.callbacks_->dispatcher().createTimer([this]() -> void { onPerTryTimeout(); });\n    per_try_timeout_->enableTimer(parent_.timeout_.per_try_timeout_);\n  }\n}\n\nvoid Filter::UpstreamRequest::onPerTryTimeout() {\n  // If we've sent anything downstream, ignore the per try timeout and let the response continue up\n  // to the global timeout\n  if (!parent_.downstream_response_started_) {\n    ENVOY_STREAM_LOG(debug, \"upstream per try timeout\", *parent_.callbacks_);\n\n    stream_info_.setResponseFlag(StreamInfo::ResponseFlag::UpstreamRequestTimeout);\n    parent_.onPerTryTimeout(*this);\n  } else {\n    ENVOY_STREAM_LOG(debug,\n                     \"ignored upstream per try timeout due to already started downstream response\",\n                     *parent_.callbacks_);\n  }\n}\n\nvoid Filter::UpstreamRequest::onPoolFailure(Http::ConnectionPool::PoolFailureReason reason,\n                                            absl::string_view transport_failure_reason,\n                                            Upstream::HostDescriptionConstSharedPtr host) {\n  Http::StreamResetReason reset_reason = Http::StreamResetReason::ConnectionFailure;\n  switch (reason) {\n  case Http::ConnectionPool::PoolFailureReason::Overflow:\n    reset_reason = Http::StreamResetReason::Overflow;\n    break;\n  case Http::ConnectionPool::PoolFailureReason::ConnectionFailure:\n    reset_reason = Http::StreamResetReason::ConnectionFailure;\n    break;\n  }\n\n  // Mimic an upstream reset.\n  onUpstreamHostSelected(host);\n  onResetStream(reset_reason, transport_failure_reason);\n}\n\nvoid Filter::UpstreamRequest::onPoolReady(Http::StreamEncoder& request_encoder,\n                                          Upstream::HostDescriptionConstSharedPtr host,\n                                          const StreamInfo::StreamInfo& info) {\n  // This may be called under an existing ScopeTrackerScopeState but it will unwind correctly.\n  ScopeTrackerScopeState scope(&parent_.callbacks_->scope(), parent_.callbacks_->dispatcher());\n  ENVOY_STREAM_LOG(debug, \"pool ready\", *parent_.callbacks_);\n\n  host->outlierDetector().putResult(Upstream::Outlier::Result::LOCAL_ORIGIN_CONNECT_SUCCESS);\n\n  // TODO(ggreenway): set upstream local address in the StreamInfo.\n  onUpstreamHostSelected(host);\n  request_encoder.getStream().addCallbacks(*this);\n\n  stream_info_.setUpstreamSslConnection(info.downstreamSslConnection());\n  parent_.callbacks_->streamInfo().setUpstreamSslConnection(info.downstreamSslConnection());\n\n  if (parent_.downstream_end_stream_) {\n    setupPerTryTimeout();\n  } else {\n    create_per_try_timeout_on_request_complete_ = true;\n  }\n\n  conn_pool_stream_handle_ = nullptr;\n  setRequestEncoder(request_encoder);\n  calling_encode_headers_ = true;\n  if (parent_.route_entry_->autoHostRewrite() && !host->hostname().empty()) {\n    parent_.downstream_headers_->Host()->value(host->hostname());\n  }\n\n  if (span_ != nullptr) {\n    span_->injectContext(*parent_.downstream_headers_);\n  }\n\n  upstream_timing_.onFirstUpstreamTxByteSent(parent_.callbacks_->dispatcher().timeSource());\n\n  const bool end_stream = !buffered_request_body_ && encode_complete_ && !encode_trailers_;\n  // If end_stream is set in headers, and there are metadata to send, delays end_stream. The case\n  // only happens when decoding headers filters return ContinueAndEndStream.\n  const bool delay_headers_end_stream = end_stream && !downstream_metadata_map_vector_.empty();\n  request_encoder.encodeHeaders(*parent_.downstream_headers_,\n                                end_stream && !delay_headers_end_stream);\n  calling_encode_headers_ = false;\n\n  // It is possible to get reset in the middle of an encodeHeaders() call. This happens for example\n  // in the HTTP/2 codec if the frame cannot be encoded for some reason. This should never happen\n  // but it's unclear if we have covered all cases so protect against it and test for it. One\n  // specific example of a case where this happens is if we try to encode a total header size that\n  // is too big in HTTP/2 (64K currently).\n  if (deferred_reset_reason_) {\n    onResetStream(deferred_reset_reason_.value(), absl::string_view());\n  } else {\n    // Encode metadata after headers and before any other frame type.\n    if (!downstream_metadata_map_vector_.empty()) {\n      ENVOY_STREAM_LOG(debug, \"Send metadata onPoolReady. {}\", *parent_.callbacks_,\n                       downstream_metadata_map_vector_);\n      request_encoder.encodeMetadata(downstream_metadata_map_vector_);\n      downstream_metadata_map_vector_.clear();\n      if (delay_headers_end_stream) {\n        Buffer::OwnedImpl empty_data(\"\");\n        request_encoder.encodeData(empty_data, true);\n      }\n    }\n\n    if (buffered_request_body_) {\n      stream_info_.addBytesSent(buffered_request_body_->length());\n      request_encoder.encodeData(*buffered_request_body_, encode_complete_ && !encode_trailers_);\n    }\n\n    if (encode_trailers_) {\n      request_encoder.encodeTrailers(*parent_.downstream_trailers_);\n    }\n\n    if (encode_complete_) {\n      upstream_timing_.onLastUpstreamTxByteSent(parent_.callbacks_->dispatcher().timeSource());\n    }\n  }\n}\n\nRetryStatePtr\nProdFilter::createRetryState(const RetryPolicy& policy, Http::HeaderMap& request_headers,\n                             const Upstream::ClusterInfo& cluster, Runtime::Loader& runtime,\n                             Runtime::RandomGenerator& random, Event::Dispatcher& dispatcher,\n                             Upstream::ResourcePriority priority) {\n  return RetryStateImpl::create(policy, request_headers, cluster, runtime, random, dispatcher,\n                                priority);\n}\n\nvoid Filter::UpstreamRequest::setRequestEncoder(Http::StreamEncoder& request_encoder) {\n  request_encoder_ = &request_encoder;\n  // Now that there is an encoder, have the connection manager inform the manager when the\n  // downstream buffers are overrun. This may result in immediate watermark callbacks referencing\n  // the encoder.\n  parent_.callbacks_->addDownstreamWatermarkCallbacks(downstream_watermark_manager_);\n}\n\nvoid Filter::UpstreamRequest::clearRequestEncoder() {\n  // Before clearing the encoder, unsubscribe from callbacks.\n  if (request_encoder_) {\n    parent_.callbacks_->removeDownstreamWatermarkCallbacks(downstream_watermark_manager_);\n  }\n  request_encoder_ = nullptr;\n}\n\nvoid Filter::UpstreamRequest::DownstreamWatermarkManager::onAboveWriteBufferHighWatermark() {\n  ASSERT(parent_.request_encoder_);\n\n  // There are two states we should get this callback in: 1) the watermark was\n  // hit due to writes from a different filter instance over a shared\n  // downstream connection, or 2) the watermark was hit due to THIS filter\n  // instance writing back the \"winning\" upstream request. In either case we\n  // can disable reads from upstream.\n  ASSERT(!parent_.parent_.final_upstream_request_ ||\n         &parent_ == parent_.parent_.final_upstream_request_);\n\n  // The downstream connection is overrun. Pause reads from upstream.\n  // If there are multiple calls to readDisable either the codec (H2) or the underlying\n  // Network::Connection (H1) will handle reference counting.\n  parent_.parent_.cluster_->stats().upstream_flow_control_paused_reading_total_.inc();\n  parent_.request_encoder_->getStream().readDisable(true);\n}\n\nvoid Filter::UpstreamRequest::DownstreamWatermarkManager::onBelowWriteBufferLowWatermark() {\n  ASSERT(parent_.request_encoder_);\n\n  // One source of connection blockage has buffer available. Pass this on to the stream, which\n  // will resume reads if this was the last remaining high watermark.\n  parent_.parent_.cluster_->stats().upstream_flow_control_resumed_reading_total_.inc();\n  parent_.request_encoder_->getStream().readDisable(false);\n}\n\n} // namespace Router\n} // namespace Envoy\n", "#pragma once\n\n#include <cstdint>\n#include <string>\n#include <unordered_set>\n#include <vector>\n\n#include \"envoy/access_log/access_log.h\"\n#include \"envoy/config/filter/accesslog/v2/accesslog.pb.h\"\n#include \"envoy/runtime/runtime.h\"\n#include \"envoy/server/access_log_config.h\"\n\n#include \"common/http/header_utility.h\"\n#include \"common/protobuf/protobuf.h\"\n\nnamespace Envoy {\nnamespace Extensions {\nnamespace AccessLoggers {\nnamespace Common {\n\n/**\n * Base implementation of Accesslog::Instance handles common filter logic.\n */\nclass ImplBase : public AccessLog::Instance {\npublic:\n  ImplBase(AccessLog::FilterPtr filter) : filter_(std::move(filter)) {}\n\n  /**\n   * Log a completed request if the underlying AccessLog `filter_` allows it.\n   */\n  void log(const Http::HeaderMap* request_headers, const Http::HeaderMap* response_headers,\n           const Http::HeaderMap* response_trailers,\n           const StreamInfo::StreamInfo& stream_info) override;\n\nprivate:\n  /**\n   * Log a completed request.\n   * @param request_headers supplies the incoming request headers after filtering.\n   * @param response_headers supplies response headers.\n   * @param response_trailers supplies response trailers.\n   * @param stream_info supplies additional information about the request not\n   * contained in the request headers.\n   */\n  virtual void emitLog(const Http::HeaderMap& request_headers,\n                       const Http::HeaderMap& response_headers,\n                       const Http::HeaderMap& response_trailers,\n                       const StreamInfo::StreamInfo& stream_info) PURE;\n\n  AccessLog::FilterPtr filter_;\n};\n\n} // namespace Common\n} // namespace AccessLoggers\n} // namespace Extensions\n} // namespace Envoy\n", "#include \"extensions/access_loggers/grpc/http_grpc_access_log_impl.h\"\n\n#include \"common/common/assert.h\"\n#include \"common/network/utility.h\"\n#include \"common/stream_info/utility.h\"\n\n#include \"extensions/access_loggers/grpc/grpc_access_log_utils.h\"\n\nnamespace Envoy {\nnamespace Extensions {\nnamespace AccessLoggers {\nnamespace HttpGrpc {\n\nHttpGrpcAccessLog::ThreadLocalLogger::ThreadLocalLogger(\n    GrpcCommon::GrpcAccessLoggerSharedPtr logger)\n    : logger_(std::move(logger)) {}\n\nHttpGrpcAccessLog::HttpGrpcAccessLog(AccessLog::FilterPtr&& filter,\n                                     envoy::config::accesslog::v2::HttpGrpcAccessLogConfig config,\n                                     ThreadLocal::SlotAllocator& tls,\n                                     GrpcCommon::GrpcAccessLoggerCacheSharedPtr access_logger_cache)\n    : Common::ImplBase(std::move(filter)), config_(std::move(config)),\n      tls_slot_(tls.allocateSlot()), access_logger_cache_(std::move(access_logger_cache)) {\n  for (const auto& header : config_.additional_request_headers_to_log()) {\n    request_headers_to_log_.emplace_back(header);\n  }\n\n  for (const auto& header : config_.additional_response_headers_to_log()) {\n    response_headers_to_log_.emplace_back(header);\n  }\n\n  for (const auto& header : config_.additional_response_trailers_to_log()) {\n    response_trailers_to_log_.emplace_back(header);\n  }\n\n  tls_slot_->set([this](Event::Dispatcher&) {\n    return std::make_shared<ThreadLocalLogger>(access_logger_cache_->getOrCreateLogger(\n        config_.common_config(), GrpcCommon::GrpcAccessLoggerType::HTTP));\n  });\n}\n\nvoid HttpGrpcAccessLog::emitLog(const Http::HeaderMap& request_headers,\n                                const Http::HeaderMap& response_headers,\n                                const Http::HeaderMap& response_trailers,\n                                const StreamInfo::StreamInfo& stream_info) {\n  // Common log properties.\n  // TODO(mattklein123): Populate sample_rate field.\n  envoy::data::accesslog::v2::HTTPAccessLogEntry log_entry;\n  GrpcCommon::Utility::extractCommonAccessLogProperties(*log_entry.mutable_common_properties(),\n                                                        stream_info);\n\n  if (stream_info.protocol()) {\n    switch (stream_info.protocol().value()) {\n    case Http::Protocol::Http10:\n      log_entry.set_protocol_version(envoy::data::accesslog::v2::HTTPAccessLogEntry::HTTP10);\n      break;\n    case Http::Protocol::Http11:\n      log_entry.set_protocol_version(envoy::data::accesslog::v2::HTTPAccessLogEntry::HTTP11);\n      break;\n    case Http::Protocol::Http2:\n      log_entry.set_protocol_version(envoy::data::accesslog::v2::HTTPAccessLogEntry::HTTP2);\n      break;\n    }\n  }\n\n  // HTTP request properties.\n  // TODO(mattklein123): Populate port field.\n  auto* request_properties = log_entry.mutable_request();\n  if (request_headers.Scheme() != nullptr) {\n    request_properties->set_scheme(std::string(request_headers.Scheme()->value().getStringView()));\n  }\n  if (request_headers.Host() != nullptr) {\n    request_properties->set_authority(std::string(request_headers.Host()->value().getStringView()));\n  }\n  if (request_headers.Path() != nullptr) {\n    request_properties->set_path(std::string(request_headers.Path()->value().getStringView()));\n  }\n  if (request_headers.UserAgent() != nullptr) {\n    request_properties->set_user_agent(\n        std::string(request_headers.UserAgent()->value().getStringView()));\n  }\n  if (request_headers.Referer() != nullptr) {\n    request_properties->set_referer(\n        std::string(request_headers.Referer()->value().getStringView()));\n  }\n  if (request_headers.ForwardedFor() != nullptr) {\n    request_properties->set_forwarded_for(\n        std::string(request_headers.ForwardedFor()->value().getStringView()));\n  }\n  if (request_headers.RequestId() != nullptr) {\n    request_properties->set_request_id(\n        std::string(request_headers.RequestId()->value().getStringView()));\n  }\n  if (request_headers.EnvoyOriginalPath() != nullptr) {\n    request_properties->set_original_path(\n        std::string(request_headers.EnvoyOriginalPath()->value().getStringView()));\n  }\n  request_properties->set_request_headers_bytes(request_headers.byteSize());\n  request_properties->set_request_body_bytes(stream_info.bytesReceived());\n  if (request_headers.Method() != nullptr) {\n    envoy::api::v2::core::RequestMethod method =\n        envoy::api::v2::core::RequestMethod::METHOD_UNSPECIFIED;\n    envoy::api::v2::core::RequestMethod_Parse(\n        std::string(request_headers.Method()->value().getStringView()), &method);\n    request_properties->set_request_method(method);\n  }\n  if (!request_headers_to_log_.empty()) {\n    auto* logged_headers = request_properties->mutable_request_headers();\n\n    for (const auto& header : request_headers_to_log_) {\n      const Http::HeaderEntry* entry = request_headers.get(header);\n      if (entry != nullptr) {\n        logged_headers->insert({header.get(), std::string(entry->value().getStringView())});\n      }\n    }\n  }\n\n  // HTTP response properties.\n  auto* response_properties = log_entry.mutable_response();\n  if (stream_info.responseCode()) {\n    response_properties->mutable_response_code()->set_value(stream_info.responseCode().value());\n  }\n  if (stream_info.responseCodeDetails()) {\n    response_properties->set_response_code_details(stream_info.responseCodeDetails().value());\n  }\n  response_properties->set_response_headers_bytes(response_headers.byteSize());\n  response_properties->set_response_body_bytes(stream_info.bytesSent());\n  if (!response_headers_to_log_.empty()) {\n    auto* logged_headers = response_properties->mutable_response_headers();\n\n    for (const auto& header : response_headers_to_log_) {\n      const Http::HeaderEntry* entry = response_headers.get(header);\n      if (entry != nullptr) {\n        logged_headers->insert({header.get(), std::string(entry->value().getStringView())});\n      }\n    }\n  }\n\n  if (!response_trailers_to_log_.empty()) {\n    auto* logged_headers = response_properties->mutable_response_trailers();\n\n    for (const auto& header : response_trailers_to_log_) {\n      const Http::HeaderEntry* entry = response_trailers.get(header);\n      if (entry != nullptr) {\n        logged_headers->insert({header.get(), std::string(entry->value().getStringView())});\n      }\n    }\n  }\n\n  tls_slot_->getTyped<ThreadLocalLogger>().logger_->log(std::move(log_entry));\n}\n\n} // namespace HttpGrpc\n} // namespace AccessLoggers\n} // namespace Extensions\n} // namespace Envoy\n", "#include \"extensions/filters/common/expr/context.h\"\n\n#include \"absl/strings/numbers.h\"\n#include \"absl/time/time.h\"\n\nnamespace Envoy {\nnamespace Extensions {\nnamespace Filters {\nnamespace Common {\nnamespace Expr {\n\nnamespace {\n\nabsl::optional<CelValue> convertHeaderEntry(const Http::HeaderEntry* header) {\n  if (header == nullptr) {\n    return {};\n  }\n  return CelValue::CreateString(header->value().getStringView());\n}\n\n} // namespace\n\nabsl::optional<CelValue> HeadersWrapper::operator[](CelValue key) const {\n  if (value_ == nullptr || !key.IsString()) {\n    return {};\n  }\n  auto out = value_->get(Http::LowerCaseString(std::string(key.StringOrDie().value())));\n  return convertHeaderEntry(out);\n}\n\nabsl::optional<CelValue> RequestWrapper::operator[](CelValue key) const {\n  if (!key.IsString()) {\n    return {};\n  }\n  auto value = key.StringOrDie().value();\n\n  if (value == Headers) {\n    return CelValue::CreateMap(&headers_);\n  } else if (value == Time) {\n    return CelValue::CreateTimestamp(absl::FromChrono(info_.startTime()));\n  } else if (value == Size) {\n    // it is important to make a choice whether to rely on content-length vs stream info\n    // (which is not available at the time of the request headers)\n    if (headers_.value_ != nullptr && headers_.value_->ContentLength() != nullptr) {\n      int64_t length;\n      if (absl::SimpleAtoi(headers_.value_->ContentLength()->value().getStringView(), &length)) {\n        return CelValue::CreateInt64(length);\n      }\n    } else {\n      return CelValue::CreateInt64(info_.bytesReceived());\n    }\n  } else if (value == Duration) {\n    auto duration = info_.requestComplete();\n    if (duration.has_value()) {\n      return CelValue::CreateDuration(absl::FromChrono(duration.value()));\n    }\n  }\n\n  if (headers_.value_ != nullptr) {\n    if (value == Path) {\n      return convertHeaderEntry(headers_.value_->Path());\n    } else if (value == UrlPath) {\n      absl::string_view path = headers_.value_->Path()->value().getStringView();\n      size_t query_offset = path.find('?');\n      if (query_offset == absl::string_view::npos) {\n        return CelValue::CreateString(path);\n      }\n      return CelValue::CreateString(path.substr(0, query_offset));\n    } else if (value == Host) {\n      return convertHeaderEntry(headers_.value_->Host());\n    } else if (value == Scheme) {\n      return convertHeaderEntry(headers_.value_->Scheme());\n    } else if (value == Method) {\n      return convertHeaderEntry(headers_.value_->Method());\n    } else if (value == Referer) {\n      return convertHeaderEntry(headers_.value_->Referer());\n    } else if (value == ID) {\n      return convertHeaderEntry(headers_.value_->RequestId());\n    } else if (value == UserAgent) {\n      return convertHeaderEntry(headers_.value_->UserAgent());\n    } else if (value == TotalSize) {\n      return CelValue::CreateInt64(info_.bytesReceived() + headers_.value_->byteSize());\n    }\n  }\n  return {};\n}\n\nabsl::optional<CelValue> ResponseWrapper::operator[](CelValue key) const {\n  if (!key.IsString()) {\n    return {};\n  }\n  auto value = key.StringOrDie().value();\n  if (value == Code) {\n    auto code = info_.responseCode();\n    if (code.has_value()) {\n      return CelValue::CreateInt64(code.value());\n    }\n  } else if (value == Size) {\n    return CelValue::CreateInt64(info_.bytesSent());\n  } else if (value == Headers) {\n    return CelValue::CreateMap(&headers_);\n  } else if (value == Trailers) {\n    return CelValue::CreateMap(&trailers_);\n  }\n  return {};\n}\n\nabsl::optional<CelValue> ConnectionWrapper::operator[](CelValue key) const {\n  if (!key.IsString()) {\n    return {};\n  }\n  auto value = key.StringOrDie().value();\n  if (value == MTLS) {\n    return CelValue::CreateBool(info_.downstreamSslConnection() != nullptr &&\n                                info_.downstreamSslConnection()->peerCertificatePresented());\n  } else if (value == RequestedServerName) {\n    return CelValue::CreateString(info_.requestedServerName());\n  }\n\n  if (info_.downstreamSslConnection() != nullptr) {\n    if (value == TLSVersion) {\n      return CelValue::CreateString(info_.downstreamSslConnection()->tlsVersion());\n    }\n  }\n\n  return {};\n}\n\nabsl::optional<CelValue> UpstreamWrapper::operator[](CelValue key) const {\n  if (!key.IsString()) {\n    return {};\n  }\n  auto value = key.StringOrDie().value();\n  if (value == Address) {\n    auto upstream_host = info_.upstreamHost();\n    if (upstream_host != nullptr && upstream_host->address() != nullptr) {\n      return CelValue::CreateString(upstream_host->address()->asStringView());\n    }\n  } else if (value == Port) {\n    auto upstream_host = info_.upstreamHost();\n    if (upstream_host != nullptr && upstream_host->address() != nullptr &&\n        upstream_host->address()->ip() != nullptr) {\n      return CelValue::CreateInt64(upstream_host->address()->ip()->port());\n    }\n  } else if (value == MTLS) {\n    return CelValue::CreateBool(info_.upstreamSslConnection() != nullptr &&\n                                info_.upstreamSslConnection()->peerCertificatePresented());\n  }\n\n  return {};\n}\n\nabsl::optional<CelValue> PeerWrapper::operator[](CelValue key) const {\n  if (!key.IsString()) {\n    return {};\n  }\n  auto value = key.StringOrDie().value();\n  if (value == Address) {\n    if (local_) {\n      return CelValue::CreateString(info_.downstreamLocalAddress()->asStringView());\n    } else {\n      return CelValue::CreateString(info_.downstreamRemoteAddress()->asStringView());\n    }\n  } else if (value == Port) {\n    if (local_) {\n      if (info_.downstreamLocalAddress()->ip() != nullptr) {\n        return CelValue::CreateInt64(info_.downstreamLocalAddress()->ip()->port());\n      }\n    } else {\n      if (info_.downstreamRemoteAddress()->ip() != nullptr) {\n        return CelValue::CreateInt64(info_.downstreamRemoteAddress()->ip()->port());\n      }\n    }\n  }\n\n  return {};\n}\n\n} // namespace Expr\n} // namespace Common\n} // namespace Filters\n} // namespace Extensions\n} // namespace Envoy\n", "#include \"extensions/filters/http/rbac/rbac_filter.h\"\n\n#include \"envoy/stats/scope.h\"\n\n#include \"common/http/utility.h\"\n\n#include \"extensions/filters/http/well_known_names.h\"\n\n#include \"absl/strings/str_join.h\"\n\nnamespace Envoy {\nnamespace Extensions {\nnamespace HttpFilters {\nnamespace RBACFilter {\n\nstruct RcDetailsValues {\n  // The rbac filter rejected the request\n  const std::string RbacAccessDenied = \"rbac_access_denied\";\n};\nusing RcDetails = ConstSingleton<RcDetailsValues>;\n\nRoleBasedAccessControlFilterConfig::RoleBasedAccessControlFilterConfig(\n    const envoy::config::filter::http::rbac::v2::RBAC& proto_config,\n    const std::string& stats_prefix, Stats::Scope& scope)\n    : stats_(Filters::Common::RBAC::generateStats(stats_prefix, scope)),\n      engine_(Filters::Common::RBAC::createEngine(proto_config)),\n      shadow_engine_(Filters::Common::RBAC::createShadowEngine(proto_config)) {}\n\nconst Filters::Common::RBAC::RoleBasedAccessControlEngineImpl*\nRoleBasedAccessControlFilterConfig::engine(const Router::RouteConstSharedPtr route,\n                                           Filters::Common::RBAC::EnforcementMode mode) const {\n  if (!route || !route->routeEntry()) {\n    return engine(mode);\n  }\n\n  const std::string& name = HttpFilterNames::get().Rbac;\n  const auto* entry = route->routeEntry();\n  const auto* tmp =\n      entry->perFilterConfigTyped<RoleBasedAccessControlRouteSpecificFilterConfig>(name);\n  const auto* route_local =\n      tmp ? tmp\n          : entry->virtualHost()\n                .perFilterConfigTyped<RoleBasedAccessControlRouteSpecificFilterConfig>(name);\n\n  if (route_local) {\n    return route_local->engine(mode);\n  }\n\n  return engine(mode);\n}\n\nRoleBasedAccessControlRouteSpecificFilterConfig::RoleBasedAccessControlRouteSpecificFilterConfig(\n    const envoy::config::filter::http::rbac::v2::RBACPerRoute& per_route_config)\n    : engine_(Filters::Common::RBAC::createEngine(per_route_config.rbac())),\n      shadow_engine_(Filters::Common::RBAC::createShadowEngine(per_route_config.rbac())) {}\n\nHttp::FilterHeadersStatus RoleBasedAccessControlFilter::decodeHeaders(Http::HeaderMap& headers,\n                                                                      bool) {\n  ENVOY_LOG(debug,\n            \"checking request: remoteAddress: {}, localAddress: {}, ssl: {}, headers: {}, \"\n            \"dynamicMetadata: {}\",\n            callbacks_->connection()->remoteAddress()->asString(),\n            callbacks_->connection()->localAddress()->asString(),\n            callbacks_->connection()->ssl()\n                ? \"uriSanPeerCertificate: \" +\n                      absl::StrJoin(callbacks_->connection()->ssl()->uriSanPeerCertificate(), \",\") +\n                      \", subjectPeerCertificate: \" +\n                      callbacks_->connection()->ssl()->subjectPeerCertificate()\n                : \"none\",\n            headers, callbacks_->streamInfo().dynamicMetadata().DebugString());\n\n  std::string effective_policy_id;\n  const auto shadow_engine =\n      config_->engine(callbacks_->route(), Filters::Common::RBAC::EnforcementMode::Shadow);\n\n  if (shadow_engine != nullptr) {\n    std::string shadow_resp_code =\n        Filters::Common::RBAC::DynamicMetadataKeysSingleton::get().EngineResultAllowed;\n    if (shadow_engine->allowed(*callbacks_->connection(), headers, callbacks_->streamInfo(),\n                               &effective_policy_id)) {\n      ENVOY_LOG(debug, \"shadow allowed\");\n      config_->stats().shadow_allowed_.inc();\n    } else {\n      ENVOY_LOG(debug, \"shadow denied\");\n      config_->stats().shadow_denied_.inc();\n      shadow_resp_code =\n          Filters::Common::RBAC::DynamicMetadataKeysSingleton::get().EngineResultDenied;\n    }\n\n    ProtobufWkt::Struct metrics;\n\n    auto& fields = *metrics.mutable_fields();\n    if (!effective_policy_id.empty()) {\n      *fields[Filters::Common::RBAC::DynamicMetadataKeysSingleton::get()\n                  .ShadowEffectivePolicyIdField]\n           .mutable_string_value() = effective_policy_id;\n    }\n\n    *fields[Filters::Common::RBAC::DynamicMetadataKeysSingleton::get().ShadowEngineResultField]\n         .mutable_string_value() = shadow_resp_code;\n\n    callbacks_->streamInfo().setDynamicMetadata(HttpFilterNames::get().Rbac, metrics);\n  }\n\n  const auto engine =\n      config_->engine(callbacks_->route(), Filters::Common::RBAC::EnforcementMode::Enforced);\n  if (engine != nullptr) {\n    if (engine->allowed(*callbacks_->connection(), headers, callbacks_->streamInfo(), nullptr)) {\n      ENVOY_LOG(debug, \"enforced allowed\");\n      config_->stats().allowed_.inc();\n      return Http::FilterHeadersStatus::Continue;\n    } else {\n      ENVOY_LOG(debug, \"enforced denied\");\n      callbacks_->sendLocalReply(Http::Code::Forbidden, \"RBAC: access denied\", nullptr,\n                                 absl::nullopt, RcDetails::get().RbacAccessDenied);\n      config_->stats().denied_.inc();\n      return Http::FilterHeadersStatus::StopIteration;\n    }\n  }\n\n  ENVOY_LOG(debug, \"no engine, allowed by default\");\n  return Http::FilterHeadersStatus::Continue;\n}\n\n} // namespace RBACFilter\n} // namespace HttpFilters\n} // namespace Extensions\n} // namespace Envoy\n", "#include <chrono>\n#include <cstdint>\n#include <list>\n#include <memory>\n#include <string>\n\n#include \"envoy/access_log/access_log.h\"\n#include \"envoy/buffer/buffer.h\"\n#include \"envoy/event/dispatcher.h\"\n#include \"envoy/tracing/http_tracer.h\"\n\n#include \"common/access_log/access_log_formatter.h\"\n#include \"common/access_log/access_log_impl.h\"\n#include \"common/buffer/buffer_impl.h\"\n#include \"common/common/empty_string.h\"\n#include \"common/common/macros.h\"\n#include \"common/http/conn_manager_impl.h\"\n#include \"common/http/context_impl.h\"\n#include \"common/http/date_provider_impl.h\"\n#include \"common/http/exception.h\"\n#include \"common/http/header_map_impl.h\"\n#include \"common/http/headers.h\"\n#include \"common/network/address_impl.h\"\n#include \"common/network/utility.h\"\n#include \"common/upstream/upstream_impl.h\"\n\n#include \"extensions/access_loggers/file/file_access_log_impl.h\"\n\n#include \"test/mocks/access_log/mocks.h\"\n#include \"test/mocks/buffer/mocks.h\"\n#include \"test/mocks/common.h\"\n#include \"test/mocks/http/mocks.h\"\n#include \"test/mocks/local_info/mocks.h\"\n#include \"test/mocks/network/mocks.h\"\n#include \"test/mocks/router/mocks.h\"\n#include \"test/mocks/runtime/mocks.h\"\n#include \"test/mocks/server/mocks.h\"\n#include \"test/mocks/ssl/mocks.h\"\n#include \"test/mocks/tracing/mocks.h\"\n#include \"test/mocks/upstream/cluster_info.h\"\n#include \"test/mocks/upstream/mocks.h\"\n#include \"test/test_common/logging.h\"\n#include \"test/test_common/printers.h\"\n#include \"test/test_common/test_time.h\"\n\n#include \"gmock/gmock.h\"\n#include \"gtest/gtest.h\"\n\nusing testing::_;\nusing testing::An;\nusing testing::AnyNumber;\nusing testing::AtLeast;\nusing testing::Eq;\nusing testing::HasSubstr;\nusing testing::InSequence;\nusing testing::Invoke;\nusing testing::InvokeWithoutArgs;\nusing testing::Matcher;\nusing testing::NiceMock;\nusing testing::Ref;\nusing testing::Return;\nusing testing::ReturnRef;\n\nnamespace Envoy {\nnamespace Http {\n\nclass HttpConnectionManagerImplTest : public testing::Test, public ConnectionManagerConfig {\npublic:\n  HttpConnectionManagerImplTest()\n      : http_context_(fake_stats_.symbolTable()), access_log_path_(\"dummy_path\"),\n        access_logs_{\n            AccessLog::InstanceSharedPtr{new Extensions::AccessLoggers::File::FileAccessLog(\n                access_log_path_, {}, AccessLog::AccessLogFormatUtils::defaultAccessLogFormatter(),\n                log_manager_)}},\n        codec_(new NiceMock<MockServerConnection>()),\n        stats_{{ALL_HTTP_CONN_MAN_STATS(POOL_COUNTER(fake_stats_), POOL_GAUGE(fake_stats_),\n                                        POOL_HISTOGRAM(fake_stats_))},\n               \"\",\n               fake_stats_},\n        tracing_stats_{CONN_MAN_TRACING_STATS(POOL_COUNTER(fake_stats_))},\n        listener_stats_{CONN_MAN_LISTENER_STATS(POOL_COUNTER(fake_listener_stats_))} {\n\n    http_context_.setTracer(tracer_);\n\n    ON_CALL(route_config_provider_, lastUpdated())\n        .WillByDefault(Return(test_time_.timeSystem().systemTime()));\n    ON_CALL(scoped_route_config_provider_, lastUpdated())\n        .WillByDefault(Return(test_time_.timeSystem().systemTime()));\n    // response_encoder_ is not a NiceMock on purpose. This prevents complaining about this\n    // method only.\n    EXPECT_CALL(response_encoder_, getStream()).Times(AtLeast(0));\n  }\n\n  ~HttpConnectionManagerImplTest() override {\n    filter_callbacks_.connection_.dispatcher_.clearDeferredDeleteList();\n  }\n\n  void setup(bool ssl, const std::string& server_name, bool tracing = true, bool use_srds = false) {\n    use_srds_ = use_srds;\n    if (ssl) {\n      ssl_connection_ = std::make_shared<Ssl::MockConnectionInfo>();\n    }\n\n    server_name_ = server_name;\n    ON_CALL(filter_callbacks_.connection_, ssl()).WillByDefault(Return(ssl_connection_));\n    ON_CALL(Const(filter_callbacks_.connection_), ssl()).WillByDefault(Return(ssl_connection_));\n    filter_callbacks_.connection_.local_address_ =\n        std::make_shared<Network::Address::Ipv4Instance>(\"127.0.0.1\");\n    filter_callbacks_.connection_.remote_address_ =\n        std::make_shared<Network::Address::Ipv4Instance>(\"0.0.0.0\");\n    conn_manager_ = std::make_unique<ConnectionManagerImpl>(\n        *this, drain_close_, random_, http_context_, runtime_, local_info_, cluster_manager_,\n        &overload_manager_, test_time_.timeSystem());\n    conn_manager_->initializeReadFilterCallbacks(filter_callbacks_);\n\n    if (tracing) {\n      envoy::type::FractionalPercent percent1;\n      percent1.set_numerator(100);\n      envoy::type::FractionalPercent percent2;\n      percent2.set_numerator(10000);\n      percent2.set_denominator(envoy::type::FractionalPercent::TEN_THOUSAND);\n      tracing_config_ = std::make_unique<TracingConnectionManagerConfig>(\n          TracingConnectionManagerConfig{Tracing::OperationName::Ingress,\n                                         {LowerCaseString(\":method\")},\n                                         percent1,\n                                         percent2,\n                                         percent1,\n                                         false,\n                                         256});\n    }\n  }\n\n  void setupFilterChain(int num_decoder_filters, int num_encoder_filters) {\n    // NOTE: The length/repetition in this routine allows InSequence to work correctly in an outer\n    // scope.\n    for (int i = 0; i < num_decoder_filters; i++) {\n      decoder_filters_.push_back(new MockStreamDecoderFilter());\n    }\n\n    for (int i = 0; i < num_encoder_filters; i++) {\n      encoder_filters_.push_back(new MockStreamEncoderFilter());\n    }\n\n    EXPECT_CALL(filter_factory_, createFilterChain(_))\n        .WillOnce(Invoke([num_decoder_filters, num_encoder_filters,\n                          this](FilterChainFactoryCallbacks& callbacks) -> void {\n          for (int i = 0; i < num_decoder_filters; i++) {\n            callbacks.addStreamDecoderFilter(StreamDecoderFilterSharedPtr{decoder_filters_[i]});\n          }\n\n          for (int i = 0; i < num_encoder_filters; i++) {\n            callbacks.addStreamEncoderFilter(StreamEncoderFilterSharedPtr{encoder_filters_[i]});\n          }\n        }));\n\n    for (int i = 0; i < num_decoder_filters; i++) {\n      EXPECT_CALL(*decoder_filters_[i], setDecoderFilterCallbacks(_));\n    }\n\n    for (int i = 0; i < num_encoder_filters; i++) {\n      EXPECT_CALL(*encoder_filters_[i], setEncoderFilterCallbacks(_));\n    }\n  }\n\n  void setUpBufferLimits() {\n    ON_CALL(response_encoder_, getStream()).WillByDefault(ReturnRef(stream_));\n    EXPECT_CALL(stream_, addCallbacks(_))\n        .WillOnce(Invoke(\n            [&](Http::StreamCallbacks& callbacks) -> void { stream_callbacks_ = &callbacks; }));\n    EXPECT_CALL(stream_, bufferLimit()).WillOnce(Return(initial_buffer_limit_));\n  }\n\n  // If request_with_data_and_trailers is true, includes data and trailers in the request. If\n  // decode_headers_stop_all is true, decoder_filters_[0]'s callback decodeHeaders() returns\n  // StopAllIterationAndBuffer.\n  void setUpEncoderAndDecoder(bool request_with_data_and_trailers, bool decode_headers_stop_all) {\n    setUpBufferLimits();\n    EXPECT_CALL(*codec_, dispatch(_))\n        .WillOnce(Invoke([&, request_with_data_and_trailers](Buffer::Instance&) -> void {\n          StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n          HeaderMapPtr headers{\n              new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n          if (request_with_data_and_trailers) {\n            decoder->decodeHeaders(std::move(headers), false);\n\n            Buffer::OwnedImpl fake_data(\"12345\");\n            decoder->decodeData(fake_data, false);\n\n            HeaderMapPtr trailers{new TestHeaderMapImpl{{\"foo\", \"bar\"}}};\n            decoder->decodeTrailers(std::move(trailers));\n          } else {\n            decoder->decodeHeaders(std::move(headers), true);\n          }\n        }));\n\n    setupFilterChain(2, 2);\n\n    EXPECT_CALL(*decoder_filters_[0], decodeHeaders(_, _))\n        .WillOnce(InvokeWithoutArgs([&, decode_headers_stop_all]() -> FilterHeadersStatus {\n          Buffer::OwnedImpl data(\"hello\");\n          decoder_filters_[0]->callbacks_->addDecodedData(data, true);\n          if (decode_headers_stop_all) {\n            return FilterHeadersStatus::StopAllIterationAndBuffer;\n          } else {\n            return FilterHeadersStatus::Continue;\n          }\n        }));\n    EXPECT_CALL(*decoder_filters_[0], decodeComplete());\n  }\n\n  Event::MockTimer* setUpTimer() {\n    // this timer belongs to whatever by whatever next creates a timer.\n    // See Envoy::Event::MockTimer for details.\n    return new Event::MockTimer(&filter_callbacks_.connection_.dispatcher_);\n  }\n\n  void sendRequestHeadersAndData() {\n    EXPECT_CALL(*decoder_filters_[1], decodeHeaders(_, false))\n        .WillOnce(Return(FilterHeadersStatus::StopIteration));\n    auto status = streaming_filter_ ? FilterDataStatus::StopIterationAndWatermark\n                                    : FilterDataStatus::StopIterationAndBuffer;\n    EXPECT_CALL(*decoder_filters_[1], decodeData(_, true)).WillOnce(Return(status));\n    EXPECT_CALL(*decoder_filters_[1], decodeComplete());\n\n    // Kick off the incoming data. |fake_input| is not sent, but instead kicks\n    // off sending the headers and |data| queued up in setUpEncoderAndDecoder().\n    Buffer::OwnedImpl fake_input(\"asdf\");\n    conn_manager_->onData(fake_input, false);\n  }\n\n  HeaderMap* sendResponseHeaders(HeaderMapPtr&& response_headers) {\n    HeaderMap* altered_response_headers = nullptr;\n\n    EXPECT_CALL(*encoder_filters_[0], encodeHeaders(_, _))\n        .WillOnce(Invoke([&](HeaderMap& headers, bool) -> FilterHeadersStatus {\n          altered_response_headers = &headers;\n          return FilterHeadersStatus::Continue;\n        }));\n    EXPECT_CALL(*encoder_filters_[1], encodeHeaders(_, false))\n        .WillOnce(Return(FilterHeadersStatus::Continue));\n    EXPECT_CALL(response_encoder_, encodeHeaders(_, false));\n    decoder_filters_[0]->callbacks_->encodeHeaders(std::move(response_headers), false);\n    return altered_response_headers;\n  }\n\n  void expectOnDestroy() {\n    for (auto filter : decoder_filters_) {\n      EXPECT_CALL(*filter, onDestroy());\n    }\n\n    auto setup_filter_expect = [](MockStreamEncoderFilter* filter) {\n      EXPECT_CALL(*filter, onDestroy());\n    };\n    std::for_each(encoder_filters_.rbegin(), encoder_filters_.rend(), setup_filter_expect);\n\n    EXPECT_CALL(filter_callbacks_.connection_.dispatcher_, deferredDelete_(_));\n  }\n\n  // Http::ConnectionManagerConfig\n  const std::list<AccessLog::InstanceSharedPtr>& accessLogs() override { return access_logs_; }\n  ServerConnectionPtr createCodec(Network::Connection&, const Buffer::Instance&,\n                                  ServerConnectionCallbacks&) override {\n    return ServerConnectionPtr{codec_};\n  }\n  DateProvider& dateProvider() override { return date_provider_; }\n  std::chrono::milliseconds drainTimeout() override { return std::chrono::milliseconds(100); }\n  FilterChainFactory& filterFactory() override { return filter_factory_; }\n  bool generateRequestId() override { return true; }\n  bool preserveExternalRequestId() const override { return false; }\n  uint32_t maxRequestHeadersKb() const override { return max_request_headers_kb_; }\n  absl::optional<std::chrono::milliseconds> idleTimeout() const override { return idle_timeout_; }\n  std::chrono::milliseconds streamIdleTimeout() const override { return stream_idle_timeout_; }\n  std::chrono::milliseconds requestTimeout() const override { return request_timeout_; }\n  std::chrono::milliseconds delayedCloseTimeout() const override { return delayed_close_timeout_; }\n  bool use_srds_{};\n  Router::RouteConfigProvider* routeConfigProvider() override {\n    if (use_srds_) {\n      return nullptr;\n    }\n    return &route_config_provider_;\n  }\n  Config::ConfigProvider* scopedRouteConfigProvider() override {\n    if (use_srds_) {\n      return &scoped_route_config_provider_;\n    }\n    return nullptr;\n  }\n  const std::string& serverName() override { return server_name_; }\n  HttpConnectionManagerProto::ServerHeaderTransformation serverHeaderTransformation() override {\n    return server_transformation_;\n  }\n  ConnectionManagerStats& stats() override { return stats_; }\n  ConnectionManagerTracingStats& tracingStats() override { return tracing_stats_; }\n  bool useRemoteAddress() override { return use_remote_address_; }\n  const Http::InternalAddressConfig& internalAddressConfig() const override {\n    return internal_address_config_;\n  }\n  uint32_t xffNumTrustedHops() const override { return 0; }\n  bool skipXffAppend() const override { return false; }\n  const std::string& via() const override { return EMPTY_STRING; }\n  Http::ForwardClientCertType forwardClientCert() override { return forward_client_cert_; }\n  const std::vector<Http::ClientCertDetailsType>& setCurrentClientCertDetails() const override {\n    return set_current_client_cert_details_;\n  }\n  const Network::Address::Instance& localAddress() override { return local_address_; }\n  const absl::optional<std::string>& userAgent() override { return user_agent_; }\n  const TracingConnectionManagerConfig* tracingConfig() override { return tracing_config_.get(); }\n  ConnectionManagerListenerStats& listenerStats() override { return listener_stats_; }\n  bool proxy100Continue() const override { return proxy_100_continue_; }\n  const Http::Http1Settings& http1Settings() const override { return http1_settings_; }\n  bool shouldNormalizePath() const override { return normalize_path_; }\n  bool shouldMergeSlashes() const override { return merge_slashes_; }\n\n  DangerousDeprecatedTestTime test_time_;\n  NiceMock<Router::MockRouteConfigProvider> route_config_provider_;\n  std::shared_ptr<Router::MockConfig> route_config_{new NiceMock<Router::MockConfig>()};\n  NiceMock<Router::MockScopedRouteConfigProvider> scoped_route_config_provider_;\n  NiceMock<Tracing::MockHttpTracer> tracer_;\n  Stats::IsolatedStoreImpl fake_stats_;\n  Http::ContextImpl http_context_;\n  NiceMock<Runtime::MockLoader> runtime_;\n  NiceMock<Envoy::AccessLog::MockAccessLogManager> log_manager_;\n  std::string access_log_path_;\n  std::list<AccessLog::InstanceSharedPtr> access_logs_;\n  NiceMock<Network::MockReadFilterCallbacks> filter_callbacks_;\n  MockServerConnection* codec_;\n  NiceMock<MockFilterChainFactory> filter_factory_;\n  ConnectionManagerStats stats_;\n  ConnectionManagerTracingStats tracing_stats_;\n  NiceMock<Network::MockDrainDecision> drain_close_;\n  std::unique_ptr<ConnectionManagerImpl> conn_manager_;\n  std::string server_name_;\n  HttpConnectionManagerProto::ServerHeaderTransformation server_transformation_{\n      HttpConnectionManagerProto::OVERWRITE};\n  Network::Address::Ipv4Instance local_address_{\"127.0.0.1\"};\n  bool use_remote_address_{true};\n  Http::DefaultInternalAddressConfig internal_address_config_;\n  Http::ForwardClientCertType forward_client_cert_{Http::ForwardClientCertType::Sanitize};\n  std::vector<Http::ClientCertDetailsType> set_current_client_cert_details_;\n  absl::optional<std::string> user_agent_;\n  uint32_t max_request_headers_kb_{Http::DEFAULT_MAX_REQUEST_HEADERS_KB};\n  absl::optional<std::chrono::milliseconds> idle_timeout_;\n  std::chrono::milliseconds stream_idle_timeout_{};\n  std::chrono::milliseconds request_timeout_{};\n  std::chrono::milliseconds delayed_close_timeout_{};\n  NiceMock<Runtime::MockRandomGenerator> random_;\n  NiceMock<LocalInfo::MockLocalInfo> local_info_;\n  NiceMock<Server::Configuration::MockFactoryContext> factory_context_;\n  std::shared_ptr<Ssl::MockConnectionInfo> ssl_connection_;\n  TracingConnectionManagerConfigPtr tracing_config_;\n  SlowDateProviderImpl date_provider_{test_time_.timeSystem()};\n  MockStream stream_;\n  Http::StreamCallbacks* stream_callbacks_{nullptr};\n  NiceMock<Upstream::MockClusterManager> cluster_manager_;\n  NiceMock<Server::MockOverloadManager> overload_manager_;\n  uint32_t initial_buffer_limit_{};\n  bool streaming_filter_{false};\n  Stats::IsolatedStoreImpl fake_listener_stats_;\n  ConnectionManagerListenerStats listener_stats_;\n  bool proxy_100_continue_ = false;\n  bool preserve_external_request_id_ = false;\n  Http::Http1Settings http1_settings_;\n  bool normalize_path_ = false;\n  bool merge_slashes_ = false;\n  NiceMock<Network::MockClientConnection> upstream_conn_; // for websocket tests\n  NiceMock<Tcp::ConnectionPool::MockInstance> conn_pool_; // for websocket tests\n\n  // TODO(mattklein123): Not all tests have been converted over to better setup. Convert the rest.\n  MockStreamEncoder response_encoder_;\n  std::vector<MockStreamDecoderFilter*> decoder_filters_;\n  std::vector<MockStreamEncoderFilter*> encoder_filters_;\n};\n\nTEST_F(HttpConnectionManagerImplTest, HeaderOnlyRequestAndResponse) {\n  setup(false, \"envoy-custom-server\", false);\n\n  // Store the basic request encoder during filter chain setup.\n  std::shared_ptr<MockStreamDecoderFilter> filter(new NiceMock<MockStreamDecoderFilter>());\n\n  EXPECT_CALL(*filter, decodeHeaders(_, true))\n      .Times(2)\n      .WillRepeatedly(Invoke([&](HeaderMap& headers, bool) -> FilterHeadersStatus {\n        EXPECT_NE(nullptr, headers.ForwardedFor());\n        EXPECT_EQ(\"http\", headers.ForwardedProto()->value().getStringView());\n        if (headers.Path()->value() == \"/healthcheck\") {\n          filter->callbacks_->streamInfo().healthCheck(true);\n        }\n\n        return FilterHeadersStatus::StopIteration;\n      }));\n\n  EXPECT_CALL(*filter, setDecoderFilterCallbacks(_)).Times(2);\n\n  EXPECT_CALL(filter_factory_, createFilterChain(_))\n      .Times(2)\n      .WillRepeatedly(Invoke([&](FilterChainFactoryCallbacks& callbacks) -> void {\n        callbacks.addStreamDecoderFilter(filter);\n      }));\n\n  EXPECT_CALL(filter_callbacks_.connection_.dispatcher_, deferredDelete_(_)).Times(2);\n\n  // When dispatch is called on the codec, we pretend to get a new stream and then fire a headers\n  // only request into it. Then we respond into the filter.\n  StreamDecoder* decoder = nullptr;\n  NiceMock<MockStreamEncoder> encoder;\n  EXPECT_CALL(*codec_, dispatch(_))\n      .Times(2)\n      .WillRepeatedly(Invoke([&](Buffer::Instance& data) -> void {\n        decoder = &conn_manager_->newStream(encoder);\n\n        // Test not charging stats on the second call.\n        if (data.length() == 4) {\n          HeaderMapPtr headers{\n              new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n          decoder->decodeHeaders(std::move(headers), true);\n        } else {\n          HeaderMapPtr headers{new TestHeaderMapImpl{\n              {\":authority\", \"host\"}, {\":path\", \"/healthcheck\"}, {\":method\", \"GET\"}}};\n          decoder->decodeHeaders(std::move(headers), true);\n        }\n\n        HeaderMapPtr response_headers{new TestHeaderMapImpl{{\":status\", \"200\"}}};\n        filter->callbacks_->encodeHeaders(std::move(response_headers), true);\n\n        // Drain 2 so that on the 2nd iteration we will hit zero.\n        data.drain(2);\n      }));\n\n  // Kick off the incoming data. Use extra data which should cause a redispatch.\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n\n  EXPECT_EQ(1U, stats_.named_.downstream_rq_2xx_.value());\n  EXPECT_EQ(1U, listener_stats_.downstream_rq_2xx_.value());\n  EXPECT_EQ(1U, stats_.named_.downstream_rq_completed_.value());\n  EXPECT_EQ(1U, listener_stats_.downstream_rq_completed_.value());\n}\n\nTEST_F(HttpConnectionManagerImplTest, 100ContinueResponse) {\n  proxy_100_continue_ = true;\n  setup(false, \"envoy-custom-server\", false);\n\n  // Store the basic request encoder during filter chain setup.\n  std::shared_ptr<MockStreamDecoderFilter> filter(new NiceMock<MockStreamDecoderFilter>());\n\n  EXPECT_CALL(*filter, decodeHeaders(_, true))\n      .WillRepeatedly(Invoke([&](HeaderMap& headers, bool) -> FilterHeadersStatus {\n        EXPECT_NE(nullptr, headers.ForwardedFor());\n        EXPECT_EQ(\"http\", headers.ForwardedProto()->value().getStringView());\n        return FilterHeadersStatus::StopIteration;\n      }));\n\n  EXPECT_CALL(*filter, setDecoderFilterCallbacks(_));\n\n  EXPECT_CALL(filter_factory_, createFilterChain(_))\n      .WillRepeatedly(Invoke([&](FilterChainFactoryCallbacks& callbacks) -> void {\n        callbacks.addStreamDecoderFilter(filter);\n      }));\n\n  EXPECT_CALL(filter_callbacks_.connection_.dispatcher_, deferredDelete_(_));\n\n  // When dispatch is called on the codec, we pretend to get a new stream and then fire a headers\n  // only request into it. Then we respond into the filter.\n  StreamDecoder* decoder = nullptr;\n  NiceMock<MockStreamEncoder> encoder;\n  EXPECT_CALL(*codec_, dispatch(_)).WillRepeatedly(Invoke([&](Buffer::Instance& data) -> void {\n    decoder = &conn_manager_->newStream(encoder);\n\n    // Test not charging stats on the second call.\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n    decoder->decodeHeaders(std::move(headers), true);\n\n    HeaderMapPtr continue_headers{new TestHeaderMapImpl{{\":status\", \"100\"}}};\n    filter->callbacks_->encode100ContinueHeaders(std::move(continue_headers));\n    HeaderMapPtr response_headers{new TestHeaderMapImpl{{\":status\", \"200\"}}};\n    filter->callbacks_->encodeHeaders(std::move(response_headers), true);\n\n    data.drain(4);\n  }));\n\n  // Kick off the incoming data.\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n\n  EXPECT_EQ(1U, stats_.named_.downstream_rq_1xx_.value());\n  EXPECT_EQ(1U, listener_stats_.downstream_rq_1xx_.value());\n  EXPECT_EQ(1U, stats_.named_.downstream_rq_2xx_.value());\n  EXPECT_EQ(1U, listener_stats_.downstream_rq_2xx_.value());\n  EXPECT_EQ(2U, stats_.named_.downstream_rq_completed_.value());\n  EXPECT_EQ(2U, listener_stats_.downstream_rq_completed_.value());\n}\n\nTEST_F(HttpConnectionManagerImplTest, 100ContinueResponseWithEncoderFiltersProxyingDisabled) {\n  proxy_100_continue_ = false;\n  setup(false, \"envoy-custom-server\", false);\n  setUpEncoderAndDecoder(false, false);\n  sendRequestHeadersAndData();\n\n  // Akin to 100ContinueResponseWithEncoderFilters below, but with\n  // proxy_100_continue_ false. Verify the filters do not get the 100 continue\n  // headers.\n  EXPECT_CALL(*encoder_filters_[0], encode100ContinueHeaders(_)).Times(0);\n  EXPECT_CALL(*encoder_filters_[1], encode100ContinueHeaders(_)).Times(0);\n  EXPECT_CALL(response_encoder_, encode100ContinueHeaders(_)).Times(0);\n  HeaderMapPtr continue_headers{new TestHeaderMapImpl{{\":status\", \"100\"}}};\n  decoder_filters_[0]->callbacks_->encode100ContinueHeaders(std::move(continue_headers));\n\n  EXPECT_CALL(*encoder_filters_[0], encodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(*encoder_filters_[1], encodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(response_encoder_, encodeHeaders(_, false));\n  HeaderMapPtr response_headers{new TestHeaderMapImpl{{\":status\", \"200\"}}};\n  decoder_filters_[0]->callbacks_->encodeHeaders(std::move(response_headers), false);\n}\n\nTEST_F(HttpConnectionManagerImplTest, 100ContinueResponseWithEncoderFilters) {\n  proxy_100_continue_ = true;\n  setup(false, \"envoy-custom-server\", false);\n  setUpEncoderAndDecoder(false, false);\n  sendRequestHeadersAndData();\n\n  EXPECT_CALL(*encoder_filters_[0], encode100ContinueHeaders(_))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(*encoder_filters_[1], encode100ContinueHeaders(_))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(response_encoder_, encode100ContinueHeaders(_));\n  HeaderMapPtr continue_headers{new TestHeaderMapImpl{{\":status\", \"100\"}}};\n  decoder_filters_[0]->callbacks_->encode100ContinueHeaders(std::move(continue_headers));\n\n  EXPECT_CALL(*encoder_filters_[0], encodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(*encoder_filters_[1], encodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(response_encoder_, encodeHeaders(_, false));\n  HeaderMapPtr response_headers{new TestHeaderMapImpl{{\":status\", \"200\"}}};\n  decoder_filters_[0]->callbacks_->encodeHeaders(std::move(response_headers), false);\n}\n\nTEST_F(HttpConnectionManagerImplTest, PauseResume100Continue) {\n  proxy_100_continue_ = true;\n  setup(false, \"envoy-custom-server\", false);\n  setUpEncoderAndDecoder(false, false);\n  sendRequestHeadersAndData();\n\n  // Stop the 100-Continue at encoder filter 1. Encoder filter 0 should not yet receive the\n  // 100-Continue\n  EXPECT_CALL(*encoder_filters_[1], encode100ContinueHeaders(_))\n      .WillOnce(Return(FilterHeadersStatus::StopIteration));\n  EXPECT_CALL(*encoder_filters_[0], encode100ContinueHeaders(_)).Times(0);\n  EXPECT_CALL(response_encoder_, encode100ContinueHeaders(_)).Times(0);\n  HeaderMapPtr continue_headers{new TestHeaderMapImpl{{\":status\", \"100\"}}};\n  decoder_filters_[1]->callbacks_->encode100ContinueHeaders(std::move(continue_headers));\n\n  // Have the encoder filter 1 continue. Make sure the 100-Continue is resumed as expected.\n  EXPECT_CALL(*encoder_filters_[0], encode100ContinueHeaders(_))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(response_encoder_, encode100ContinueHeaders(_));\n  encoder_filters_[1]->callbacks_->continueEncoding();\n\n  EXPECT_CALL(*encoder_filters_[1], encodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(*encoder_filters_[0], encodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(response_encoder_, encodeHeaders(_, false));\n  HeaderMapPtr response_headers{new TestHeaderMapImpl{{\":status\", \"200\"}}};\n  decoder_filters_[1]->callbacks_->encodeHeaders(std::move(response_headers), false);\n}\n\n// By default, Envoy will set the server header to the server name, here \"custom-value\"\nTEST_F(HttpConnectionManagerImplTest, ServerHeaderOverwritten) {\n  setup(false, \"custom-value\", false);\n  setUpEncoderAndDecoder(false, false);\n\n  sendRequestHeadersAndData();\n  const HeaderMap* altered_headers = sendResponseHeaders(\n      HeaderMapPtr{new TestHeaderMapImpl{{\":status\", \"200\"}, {\"server\", \"foo\"}}});\n  EXPECT_EQ(\"custom-value\", altered_headers->Server()->value().getStringView());\n}\n\n// When configured APPEND_IF_ABSENT if the server header is present it will be retained.\nTEST_F(HttpConnectionManagerImplTest, ServerHeaderAppendPresent) {\n  server_transformation_ = HttpConnectionManagerProto::APPEND_IF_ABSENT;\n  setup(false, \"custom-value\", false);\n  setUpEncoderAndDecoder(false, false);\n\n  sendRequestHeadersAndData();\n  const HeaderMap* altered_headers = sendResponseHeaders(\n      HeaderMapPtr{new TestHeaderMapImpl{{\":status\", \"200\"}, {\"server\", \"foo\"}}});\n  EXPECT_EQ(\"foo\", altered_headers->Server()->value().getStringView());\n}\n\n// When configured APPEND_IF_ABSENT if the server header is absent the server name will be set.\nTEST_F(HttpConnectionManagerImplTest, ServerHeaderAppendAbsent) {\n  server_transformation_ = HttpConnectionManagerProto::APPEND_IF_ABSENT;\n  setup(false, \"custom-value\", false);\n  setUpEncoderAndDecoder(false, false);\n\n  sendRequestHeadersAndData();\n  const HeaderMap* altered_headers =\n      sendResponseHeaders(HeaderMapPtr{new TestHeaderMapImpl{{\":status\", \"200\"}}});\n  EXPECT_EQ(\"custom-value\", altered_headers->Server()->value().getStringView());\n}\n\n// When configured PASS_THROUGH, the server name will pass through.\nTEST_F(HttpConnectionManagerImplTest, ServerHeaderPassthroughPresent) {\n  server_transformation_ = HttpConnectionManagerProto::PASS_THROUGH;\n  setup(false, \"custom-value\", false);\n  setUpEncoderAndDecoder(false, false);\n\n  sendRequestHeadersAndData();\n  const HeaderMap* altered_headers = sendResponseHeaders(\n      HeaderMapPtr{new TestHeaderMapImpl{{\":status\", \"200\"}, {\"server\", \"foo\"}}});\n  EXPECT_EQ(\"foo\", altered_headers->Server()->value().getStringView());\n}\n\n// When configured PASS_THROUGH, the server header will not be added if absent.\nTEST_F(HttpConnectionManagerImplTest, ServerHeaderPassthroughAbsent) {\n  server_transformation_ = HttpConnectionManagerProto::PASS_THROUGH;\n  setup(false, \"custom-value\", false);\n  setUpEncoderAndDecoder(false, false);\n\n  sendRequestHeadersAndData();\n  const HeaderMap* altered_headers =\n      sendResponseHeaders(HeaderMapPtr{new TestHeaderMapImpl{{\":status\", \"200\"}}});\n  EXPECT_TRUE(altered_headers->Server() == nullptr);\n}\n\nTEST_F(HttpConnectionManagerImplTest, InvalidPathWithDualFilter) {\n  InSequence s;\n  setup(false, \"\");\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance& data) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{new TestHeaderMapImpl{\n        {\":authority\", \"host\"}, {\":path\", \"http://api.lyft.com/\"}, {\":method\", \"GET\"}}};\n    decoder->decodeHeaders(std::move(headers), true);\n    data.drain(4);\n  }));\n\n  // This test also verifies that decoder/encoder filters have onDestroy() called only once.\n  auto* filter = new MockStreamFilter();\n  EXPECT_CALL(filter_factory_, createFilterChain(_))\n      .WillOnce(Invoke([&](FilterChainFactoryCallbacks& callbacks) -> void {\n        callbacks.addStreamFilter(StreamFilterSharedPtr{filter});\n      }));\n  EXPECT_CALL(*filter, setDecoderFilterCallbacks(_));\n  EXPECT_CALL(*filter, setEncoderFilterCallbacks(_));\n\n  EXPECT_CALL(*filter, encodeHeaders(_, true));\n  EXPECT_CALL(response_encoder_, encodeHeaders(_, true))\n      .WillOnce(Invoke([&](const HeaderMap& headers, bool) -> void {\n        EXPECT_EQ(\"404\", headers.Status()->value().getStringView());\n        EXPECT_EQ(\"absolute_path_rejected\",\n                  filter->decoder_callbacks_->streamInfo().responseCodeDetails().value());\n      }));\n  EXPECT_CALL(*filter, onDestroy());\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n}\n\n// Invalid paths are rejected with 400.\nTEST_F(HttpConnectionManagerImplTest, PathFailedtoSanitize) {\n  InSequence s;\n  setup(false, \"\");\n  // Enable path sanitizer\n  normalize_path_ = true;\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance& data) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"},\n                              {\":path\", \"/ab%00c\"}, // \"%00\" is not valid in path according to RFC\n                              {\":method\", \"GET\"}}};\n    decoder->decodeHeaders(std::move(headers), true);\n    data.drain(4);\n  }));\n\n  // This test also verifies that decoder/encoder filters have onDestroy() called only once.\n  auto* filter = new MockStreamFilter();\n  EXPECT_CALL(filter_factory_, createFilterChain(_))\n      .WillOnce(Invoke([&](FilterChainFactoryCallbacks& callbacks) -> void {\n        callbacks.addStreamFilter(StreamFilterSharedPtr{filter});\n      }));\n  EXPECT_CALL(*filter, setDecoderFilterCallbacks(_));\n  EXPECT_CALL(*filter, setEncoderFilterCallbacks(_));\n\n  EXPECT_CALL(*filter, encodeHeaders(_, true));\n  EXPECT_CALL(response_encoder_, encodeHeaders(_, true))\n      .WillOnce(Invoke([&](const HeaderMap& headers, bool) -> void {\n        EXPECT_EQ(\"400\", headers.Status()->value().getStringView());\n        EXPECT_EQ(\"path_normalization_failed\",\n                  filter->decoder_callbacks_->streamInfo().responseCodeDetails().value());\n      }));\n  EXPECT_CALL(*filter, onDestroy());\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n}\n\n// Filters observe normalized paths, not the original path, when path\n// normalization is configured.\nTEST_F(HttpConnectionManagerImplTest, FilterShouldUseSantizedPath) {\n  setup(false, \"\");\n  // Enable path sanitizer\n  normalize_path_ = true;\n  const std::string original_path = \"/x/%2E%2e/z\";\n  const std::string normalized_path = \"/z\";\n\n  auto* filter = new MockStreamFilter();\n\n  EXPECT_CALL(filter_factory_, createFilterChain(_))\n      .WillOnce(Invoke([&](FilterChainFactoryCallbacks& callbacks) -> void {\n        callbacks.addStreamDecoderFilter(StreamDecoderFilterSharedPtr{filter});\n      }));\n\n  EXPECT_CALL(*filter, decodeHeaders(_, true))\n      .WillRepeatedly(Invoke([&](HeaderMap& header_map, bool) -> FilterHeadersStatus {\n        EXPECT_EQ(normalized_path, header_map.Path()->value().getStringView());\n        return FilterHeadersStatus::StopIteration;\n      }));\n\n  EXPECT_CALL(*filter, setDecoderFilterCallbacks(_));\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{new TestHeaderMapImpl{\n        {\":authority\", \"host\"}, {\":path\", original_path}, {\":method\", \"GET\"}}};\n    decoder->decodeHeaders(std::move(headers), true);\n  }));\n\n  // Kick off the incoming data.\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n}\n\n// The router observes normalized paths, not the original path, when path\n// normalization is configured.\nTEST_F(HttpConnectionManagerImplTest, RouteShouldUseSantizedPath) {\n  setup(false, \"\");\n  // Enable path sanitizer\n  normalize_path_ = true;\n  const std::string original_path = \"/x/%2E%2e/z\";\n  const std::string normalized_path = \"/z\";\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{new TestHeaderMapImpl{\n        {\":authority\", \"host\"}, {\":path\", original_path}, {\":method\", \"GET\"}}};\n    decoder->decodeHeaders(std::move(headers), true);\n  }));\n\n  const std::string fake_cluster_name = \"fake_cluster\";\n\n  std::shared_ptr<Upstream::MockThreadLocalCluster> fake_cluster =\n      std::make_shared<NiceMock<Upstream::MockThreadLocalCluster>>();\n  std::shared_ptr<Router::MockRoute> route = std::make_shared<NiceMock<Router::MockRoute>>();\n  EXPECT_CALL(route->route_entry_, clusterName()).WillRepeatedly(ReturnRef(fake_cluster_name));\n\n  EXPECT_CALL(*route_config_provider_.route_config_, route(_, _))\n      .WillOnce(Invoke([&](const Http::HeaderMap& header_map, uint64_t) {\n        EXPECT_EQ(normalized_path, header_map.Path()->value().getStringView());\n        return route;\n      }));\n  EXPECT_CALL(filter_factory_, createFilterChain(_))\n      .WillOnce(Invoke([&](FilterChainFactoryCallbacks&) -> void {}));\n\n  // Kick off the incoming data.\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n}\n\nTEST_F(HttpConnectionManagerImplTest, StartAndFinishSpanNormalFlow) {\n  setup(false, \"\");\n\n  auto* span = new NiceMock<Tracing::MockSpan>();\n  EXPECT_CALL(tracer_, startSpan_(_, _, _, _))\n      .WillOnce(\n          Invoke([&](const Tracing::Config& config, const HeaderMap&, const StreamInfo::StreamInfo&,\n                     const Tracing::Decision) -> Tracing::Span* {\n            EXPECT_EQ(Tracing::OperationName::Ingress, config.operationName());\n\n            return span;\n          }));\n  // No decorator.\n  EXPECT_CALL(*route_config_provider_.route_config_->route_, decorator())\n      .WillRepeatedly(Return(nullptr));\n  EXPECT_CALL(*span, finishSpan());\n  EXPECT_CALL(*span, setTag(_, _)).Times(testing::AnyNumber());\n  // Verify tag is set based on the request headers.\n  EXPECT_CALL(*span, setTag(Eq(\":method\"), Eq(\"GET\")));\n  // Verify if the activeSpan interface returns reference to the current span.\n  EXPECT_CALL(*span, setTag(Eq(\"service-cluster\"), Eq(\"scoobydoo\")));\n  EXPECT_CALL(runtime_.snapshot_, featureEnabled(\"tracing.global_enabled\",\n                                                 An<const envoy::type::FractionalPercent&>(), _))\n      .WillOnce(Return(true));\n  EXPECT_CALL(*span, setOperation(_)).Times(0);\n\n  std::shared_ptr<MockStreamDecoderFilter> filter(new NiceMock<MockStreamDecoderFilter>());\n\n  EXPECT_CALL(filter_factory_, createFilterChain(_))\n      .WillRepeatedly(Invoke([&](FilterChainFactoryCallbacks& callbacks) -> void {\n        callbacks.addStreamDecoderFilter(filter);\n      }));\n\n  // Treat request as internal, otherwise x-request-id header will be overwritten.\n  use_remote_address_ = false;\n  EXPECT_CALL(random_, uuid()).Times(0);\n\n  StreamDecoder* decoder = nullptr;\n  NiceMock<MockStreamEncoder> encoder;\n  EXPECT_CALL(*codec_, dispatch(_)).WillRepeatedly(Invoke([&](Buffer::Instance& data) -> void {\n    decoder = &conn_manager_->newStream(encoder);\n\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":method\", \"GET\"},\n                              {\":authority\", \"host\"},\n                              {\":path\", \"/\"},\n                              {\"x-request-id\", \"125a4afb-6f55-a4ba-ad80-413f09f48a28\"}}};\n    decoder->decodeHeaders(std::move(headers), true);\n\n    HeaderMapPtr response_headers{new TestHeaderMapImpl{{\":status\", \"200\"}}};\n    filter->callbacks_->encodeHeaders(std::move(response_headers), true);\n    filter->callbacks_->activeSpan().setTag(\"service-cluster\", \"scoobydoo\");\n    data.drain(4);\n  }));\n\n  // Should be no 'x-envoy-decorator-operation' response header.\n  EXPECT_CALL(encoder, encodeHeaders(_, true))\n      .WillOnce(Invoke([](const HeaderMap& headers, bool) -> void {\n        EXPECT_EQ(nullptr, headers.EnvoyDecoratorOperation());\n      }));\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n\n  EXPECT_EQ(1UL, tracing_stats_.service_forced_.value());\n  EXPECT_EQ(0UL, tracing_stats_.random_sampling_.value());\n}\n\nTEST_F(HttpConnectionManagerImplTest, StartAndFinishSpanNormalFlowIngressDecorator) {\n  setup(false, \"\");\n\n  auto* span = new NiceMock<Tracing::MockSpan>();\n  EXPECT_CALL(tracer_, startSpan_(_, _, _, _))\n      .WillOnce(\n          Invoke([&](const Tracing::Config& config, const HeaderMap&, const StreamInfo::StreamInfo&,\n                     const Tracing::Decision) -> Tracing::Span* {\n            EXPECT_EQ(Tracing::OperationName::Ingress, config.operationName());\n\n            return span;\n          }));\n  route_config_provider_.route_config_->route_->decorator_.operation_ = \"testOp\";\n  EXPECT_CALL(*route_config_provider_.route_config_->route_, decorator()).Times(4);\n  EXPECT_CALL(route_config_provider_.route_config_->route_->decorator_, apply(_))\n      .WillOnce(Invoke(\n          [&](const Tracing::Span& apply_to_span) -> void { EXPECT_EQ(span, &apply_to_span); }));\n  EXPECT_CALL(*span, finishSpan());\n  EXPECT_CALL(*span, setTag(_, _)).Times(testing::AnyNumber());\n  EXPECT_CALL(runtime_.snapshot_, featureEnabled(\"tracing.global_enabled\",\n                                                 An<const envoy::type::FractionalPercent&>(), _))\n      .WillOnce(Return(true));\n  EXPECT_CALL(*span, setOperation(_)).Times(0);\n\n  std::shared_ptr<MockStreamDecoderFilter> filter(new NiceMock<MockStreamDecoderFilter>());\n\n  EXPECT_CALL(filter_factory_, createFilterChain(_))\n      .WillRepeatedly(Invoke([&](FilterChainFactoryCallbacks& callbacks) -> void {\n        callbacks.addStreamDecoderFilter(filter);\n      }));\n\n  // Treat request as internal, otherwise x-request-id header will be overwritten.\n  use_remote_address_ = false;\n  EXPECT_CALL(random_, uuid()).Times(0);\n\n  StreamDecoder* decoder = nullptr;\n  NiceMock<MockStreamEncoder> encoder;\n  EXPECT_CALL(*codec_, dispatch(_)).WillRepeatedly(Invoke([&](Buffer::Instance& data) -> void {\n    decoder = &conn_manager_->newStream(encoder);\n\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":method\", \"GET\"},\n                              {\":authority\", \"host\"},\n                              {\":path\", \"/\"},\n                              {\"x-request-id\", \"125a4afb-6f55-a4ba-ad80-413f09f48a28\"}}};\n    decoder->decodeHeaders(std::move(headers), true);\n\n    HeaderMapPtr response_headers{new TestHeaderMapImpl{{\":status\", \"200\"}}};\n    filter->callbacks_->encodeHeaders(std::move(response_headers), true);\n    filter->callbacks_->activeSpan().setTag(\"service-cluster\", \"scoobydoo\");\n    data.drain(4);\n  }));\n\n  // Verify decorator operation response header has been defined.\n  EXPECT_CALL(encoder, encodeHeaders(_, true))\n      .WillOnce(Invoke([](const HeaderMap& headers, bool) -> void {\n        EXPECT_EQ(\"testOp\", headers.EnvoyDecoratorOperation()->value().getStringView());\n      }));\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n}\n\nTEST_F(HttpConnectionManagerImplTest, StartAndFinishSpanNormalFlowIngressDecoratorOverrideOp) {\n  setup(false, \"\");\n\n  auto* span = new NiceMock<Tracing::MockSpan>();\n  EXPECT_CALL(tracer_, startSpan_(_, _, _, _))\n      .WillOnce(\n          Invoke([&](const Tracing::Config& config, const HeaderMap&, const StreamInfo::StreamInfo&,\n                     const Tracing::Decision) -> Tracing::Span* {\n            EXPECT_EQ(Tracing::OperationName::Ingress, config.operationName());\n\n            return span;\n          }));\n  route_config_provider_.route_config_->route_->decorator_.operation_ = \"initOp\";\n  EXPECT_CALL(*route_config_provider_.route_config_->route_, decorator()).Times(4);\n  EXPECT_CALL(route_config_provider_.route_config_->route_->decorator_, apply(_))\n      .WillOnce(Invoke(\n          [&](const Tracing::Span& apply_to_span) -> void { EXPECT_EQ(span, &apply_to_span); }));\n  EXPECT_CALL(*span, finishSpan());\n  EXPECT_CALL(*span, setTag(_, _)).Times(testing::AnyNumber());\n  EXPECT_CALL(runtime_.snapshot_, featureEnabled(\"tracing.global_enabled\",\n                                                 An<const envoy::type::FractionalPercent&>(), _))\n      .WillOnce(Return(true));\n  EXPECT_CALL(*span, setOperation(Eq(\"testOp\")));\n\n  std::shared_ptr<MockStreamDecoderFilter> filter(new NiceMock<MockStreamDecoderFilter>());\n\n  EXPECT_CALL(filter_factory_, createFilterChain(_))\n      .WillRepeatedly(Invoke([&](FilterChainFactoryCallbacks& callbacks) -> void {\n        callbacks.addStreamDecoderFilter(filter);\n      }));\n\n  // Treat request as internal, otherwise x-request-id header will be overwritten.\n  use_remote_address_ = false;\n  EXPECT_CALL(random_, uuid()).Times(0);\n\n  StreamDecoder* decoder = nullptr;\n  NiceMock<MockStreamEncoder> encoder;\n  EXPECT_CALL(*codec_, dispatch(_)).WillRepeatedly(Invoke([&](Buffer::Instance& data) -> void {\n    decoder = &conn_manager_->newStream(encoder);\n\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":method\", \"GET\"},\n                              {\":authority\", \"host\"},\n                              {\":path\", \"/\"},\n                              {\"x-request-id\", \"125a4afb-6f55-a4ba-ad80-413f09f48a28\"},\n                              {\"x-envoy-decorator-operation\", \"testOp\"}}};\n    decoder->decodeHeaders(std::move(headers), true);\n\n    HeaderMapPtr response_headers{new TestHeaderMapImpl{{\":status\", \"200\"}}};\n    filter->callbacks_->encodeHeaders(std::move(response_headers), true);\n    filter->callbacks_->activeSpan().setTag(\"service-cluster\", \"scoobydoo\");\n\n    data.drain(4);\n  }));\n\n  // Should be no 'x-envoy-decorator-operation' response header, as decorator\n  // was overridden by request header.\n  EXPECT_CALL(encoder, encodeHeaders(_, true))\n      .WillOnce(Invoke([](const HeaderMap& headers, bool) -> void {\n        EXPECT_EQ(nullptr, headers.EnvoyDecoratorOperation());\n      }));\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n}\n\nTEST_F(HttpConnectionManagerImplTest, StartAndFinishSpanNormalFlowEgressDecorator) {\n  setup(false, \"\");\n  envoy::type::FractionalPercent percent1;\n  percent1.set_numerator(100);\n  envoy::type::FractionalPercent percent2;\n  percent2.set_numerator(10000);\n  percent2.set_denominator(envoy::type::FractionalPercent::TEN_THOUSAND);\n  tracing_config_ = std::make_unique<TracingConnectionManagerConfig>(\n      TracingConnectionManagerConfig{Tracing::OperationName::Egress,\n                                     {LowerCaseString(\":method\")},\n                                     percent1,\n                                     percent2,\n                                     percent1,\n                                     false,\n                                     256});\n\n  auto* span = new NiceMock<Tracing::MockSpan>();\n  EXPECT_CALL(tracer_, startSpan_(_, _, _, _))\n      .WillOnce(\n          Invoke([&](const Tracing::Config& config, const HeaderMap&, const StreamInfo::StreamInfo&,\n                     const Tracing::Decision) -> Tracing::Span* {\n            EXPECT_EQ(Tracing::OperationName::Egress, config.operationName());\n\n            return span;\n          }));\n  route_config_provider_.route_config_->route_->decorator_.operation_ = \"testOp\";\n  EXPECT_CALL(*route_config_provider_.route_config_->route_, decorator()).Times(4);\n  EXPECT_CALL(route_config_provider_.route_config_->route_->decorator_, apply(_))\n      .WillOnce(Invoke(\n          [&](const Tracing::Span& apply_to_span) -> void { EXPECT_EQ(span, &apply_to_span); }));\n  EXPECT_CALL(*span, finishSpan());\n  EXPECT_CALL(*span, setTag(_, _)).Times(testing::AnyNumber());\n  EXPECT_CALL(runtime_.snapshot_, featureEnabled(\"tracing.global_enabled\",\n                                                 An<const envoy::type::FractionalPercent&>(), _))\n      .WillOnce(Return(true));\n  EXPECT_CALL(*span, setOperation(_)).Times(0);\n\n  std::shared_ptr<MockStreamDecoderFilter> filter(new NiceMock<MockStreamDecoderFilter>());\n\n  EXPECT_CALL(filter_factory_, createFilterChain(_))\n      .WillRepeatedly(Invoke([&](FilterChainFactoryCallbacks& callbacks) -> void {\n        callbacks.addStreamDecoderFilter(filter);\n      }));\n\n  // Treat request as internal, otherwise x-request-id header will be overwritten.\n  use_remote_address_ = false;\n  EXPECT_CALL(random_, uuid()).Times(0);\n\n  StreamDecoder* decoder = nullptr;\n  NiceMock<MockStreamEncoder> encoder;\n  EXPECT_CALL(*codec_, dispatch(_)).WillRepeatedly(Invoke([&](Buffer::Instance& data) -> void {\n    decoder = &conn_manager_->newStream(encoder);\n\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":method\", \"GET\"},\n                              {\":authority\", \"host\"},\n                              {\":path\", \"/\"},\n                              {\"x-request-id\", \"125a4afb-6f55-a4ba-ad80-413f09f48a28\"}}};\n    decoder->decodeHeaders(std::move(headers), true);\n\n    HeaderMapPtr response_headers{new TestHeaderMapImpl{{\":status\", \"200\"}}};\n    filter->callbacks_->encodeHeaders(std::move(response_headers), true);\n    filter->callbacks_->activeSpan().setTag(\"service-cluster\", \"scoobydoo\");\n\n    data.drain(4);\n  }));\n\n  EXPECT_CALL(*filter, decodeHeaders(_, true))\n      .WillOnce(Invoke([](HeaderMap& headers, bool) -> FilterHeadersStatus {\n        EXPECT_NE(nullptr, headers.EnvoyDecoratorOperation());\n        // Verify that decorator operation has been set as request header.\n        EXPECT_EQ(\"testOp\", headers.EnvoyDecoratorOperation()->value().getStringView());\n        return FilterHeadersStatus::StopIteration;\n      }));\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n}\n\nTEST_F(HttpConnectionManagerImplTest, StartAndFinishSpanNormalFlowEgressDecoratorOverrideOp) {\n  setup(false, \"\");\n  envoy::type::FractionalPercent percent1;\n  percent1.set_numerator(100);\n  envoy::type::FractionalPercent percent2;\n  percent2.set_numerator(10000);\n  percent2.set_denominator(envoy::type::FractionalPercent::TEN_THOUSAND);\n  tracing_config_ = std::make_unique<TracingConnectionManagerConfig>(\n      TracingConnectionManagerConfig{Tracing::OperationName::Egress,\n                                     {LowerCaseString(\":method\")},\n                                     percent1,\n                                     percent2,\n                                     percent1,\n                                     false,\n                                     256});\n\n  auto* span = new NiceMock<Tracing::MockSpan>();\n  EXPECT_CALL(tracer_, startSpan_(_, _, _, _))\n      .WillOnce(\n          Invoke([&](const Tracing::Config& config, const HeaderMap&, const StreamInfo::StreamInfo&,\n                     const Tracing::Decision) -> Tracing::Span* {\n            EXPECT_EQ(Tracing::OperationName::Egress, config.operationName());\n\n            return span;\n          }));\n  route_config_provider_.route_config_->route_->decorator_.operation_ = \"initOp\";\n  EXPECT_CALL(*route_config_provider_.route_config_->route_, decorator()).Times(4);\n  EXPECT_CALL(route_config_provider_.route_config_->route_->decorator_, apply(_))\n      .WillOnce(Invoke(\n          [&](const Tracing::Span& apply_to_span) -> void { EXPECT_EQ(span, &apply_to_span); }));\n  EXPECT_CALL(*span, finishSpan());\n  EXPECT_CALL(*span, setTag(_, _)).Times(testing::AnyNumber());\n  EXPECT_CALL(runtime_.snapshot_, featureEnabled(\"tracing.global_enabled\",\n                                                 An<const envoy::type::FractionalPercent&>(), _))\n      .WillOnce(Return(true));\n  // Verify that span operation overridden by value supplied in response header.\n  EXPECT_CALL(*span, setOperation(Eq(\"testOp\")));\n\n  std::shared_ptr<MockStreamDecoderFilter> filter(new NiceMock<MockStreamDecoderFilter>());\n\n  EXPECT_CALL(filter_factory_, createFilterChain(_))\n      .WillRepeatedly(Invoke([&](FilterChainFactoryCallbacks& callbacks) -> void {\n        callbacks.addStreamDecoderFilter(filter);\n      }));\n\n  // Treat request as internal, otherwise x-request-id header will be overwritten.\n  use_remote_address_ = false;\n  EXPECT_CALL(random_, uuid()).Times(0);\n\n  StreamDecoder* decoder = nullptr;\n  NiceMock<MockStreamEncoder> encoder;\n  EXPECT_CALL(*codec_, dispatch(_)).WillRepeatedly(Invoke([&](Buffer::Instance& data) -> void {\n    decoder = &conn_manager_->newStream(encoder);\n\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":method\", \"GET\"},\n                              {\":authority\", \"host\"},\n                              {\":path\", \"/\"},\n                              {\"x-request-id\", \"125a4afb-6f55-a4ba-ad80-413f09f48a28\"}}};\n    decoder->decodeHeaders(std::move(headers), true);\n\n    HeaderMapPtr response_headers{\n        new TestHeaderMapImpl{{\":status\", \"200\"}, {\"x-envoy-decorator-operation\", \"testOp\"}}};\n    filter->callbacks_->encodeHeaders(std::move(response_headers), true);\n    filter->callbacks_->activeSpan().setTag(\"service-cluster\", \"scoobydoo\");\n\n    data.drain(4);\n  }));\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n}\n\nTEST_F(HttpConnectionManagerImplTest,\n       StartAndFinishSpanNormalFlowEgressDecoratorOverrideOpNoActiveSpan) {\n  setup(false, \"\");\n  envoy::type::FractionalPercent percent1;\n  percent1.set_numerator(100);\n  envoy::type::FractionalPercent percent2;\n  percent2.set_numerator(10000);\n  percent2.set_denominator(envoy::type::FractionalPercent::TEN_THOUSAND);\n  tracing_config_ = std::make_unique<TracingConnectionManagerConfig>(\n      TracingConnectionManagerConfig{Tracing::OperationName::Egress,\n                                     {LowerCaseString(\":method\")},\n                                     percent1,\n                                     percent2,\n                                     percent1,\n                                     false,\n                                     256});\n\n  EXPECT_CALL(runtime_.snapshot_, featureEnabled(\"tracing.global_enabled\",\n                                                 An<const envoy::type::FractionalPercent&>(), _))\n      .WillOnce(Return(false));\n  std::shared_ptr<MockStreamDecoderFilter> filter(new NiceMock<MockStreamDecoderFilter>());\n\n  EXPECT_CALL(filter_factory_, createFilterChain(_))\n      .WillRepeatedly(Invoke([&](FilterChainFactoryCallbacks& callbacks) -> void {\n        callbacks.addStreamDecoderFilter(filter);\n      }));\n\n  // Treat request as internal, otherwise x-request-id header will be overwritten.\n  use_remote_address_ = false;\n  EXPECT_CALL(random_, uuid()).Times(0);\n\n  StreamDecoder* decoder = nullptr;\n  NiceMock<MockStreamEncoder> encoder;\n  EXPECT_CALL(*codec_, dispatch(_)).WillRepeatedly(Invoke([&](Buffer::Instance& data) -> void {\n    decoder = &conn_manager_->newStream(encoder);\n\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":method\", \"GET\"},\n                              {\":authority\", \"host\"},\n                              {\":path\", \"/\"},\n                              {\"x-request-id\", \"125a4afb-6f55-a4ba-ad80-413f09f48a28\"}}};\n    decoder->decodeHeaders(std::move(headers), true);\n\n    HeaderMapPtr response_headers{\n        new TestHeaderMapImpl{{\":status\", \"200\"}, {\"x-envoy-decorator-operation\", \"testOp\"}}};\n    filter->callbacks_->encodeHeaders(std::move(response_headers), true);\n\n    data.drain(4);\n  }));\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n}\n\nTEST_F(HttpConnectionManagerImplTest, TestAccessLog) {\n  static constexpr char local_address[] = \"0.0.0.0\";\n  static constexpr char xff_address[] = \"1.2.3.4\";\n\n  // stream_info.downstreamRemoteAddress will infer the address from request\n  // headers instead of the physical connection\n  use_remote_address_ = false;\n  setup(false, \"\");\n\n  std::shared_ptr<MockStreamDecoderFilter> filter(new NiceMock<MockStreamDecoderFilter>());\n  std::shared_ptr<AccessLog::MockInstance> handler(new NiceMock<AccessLog::MockInstance>());\n\n  EXPECT_CALL(filter_factory_, createFilterChain(_))\n      .WillOnce(Invoke([&](FilterChainFactoryCallbacks& callbacks) -> void {\n        callbacks.addStreamDecoderFilter(filter);\n        callbacks.addAccessLogHandler(handler);\n      }));\n\n  EXPECT_CALL(*handler, log(_, _, _, _))\n      .WillOnce(Invoke([](const HeaderMap*, const HeaderMap*, const HeaderMap*,\n                          const StreamInfo::StreamInfo& stream_info) {\n        EXPECT_TRUE(stream_info.responseCode());\n        EXPECT_EQ(stream_info.responseCode().value(), uint32_t(200));\n        EXPECT_NE(nullptr, stream_info.downstreamLocalAddress());\n        EXPECT_NE(nullptr, stream_info.downstreamRemoteAddress());\n        EXPECT_NE(nullptr, stream_info.downstreamDirectRemoteAddress());\n        EXPECT_NE(nullptr, stream_info.routeEntry());\n\n        EXPECT_EQ(stream_info.downstreamRemoteAddress()->ip()->addressAsString(), xff_address);\n        EXPECT_EQ(stream_info.downstreamDirectRemoteAddress()->ip()->addressAsString(),\n                  local_address);\n      }));\n\n  StreamDecoder* decoder = nullptr;\n  NiceMock<MockStreamEncoder> encoder;\n  EXPECT_CALL(*codec_, dispatch(_)).WillRepeatedly(Invoke([&](Buffer::Instance& data) -> void {\n    decoder = &conn_manager_->newStream(encoder);\n\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":method\", \"GET\"},\n                              {\":authority\", \"host\"},\n                              {\":path\", \"/\"},\n                              {\"x-forwarded-for\", xff_address},\n                              {\"x-request-id\", \"125a4afb-6f55-a4ba-ad80-413f09f48a28\"}}};\n    decoder->decodeHeaders(std::move(headers), true);\n\n    HeaderMapPtr response_headers{new TestHeaderMapImpl{{\":status\", \"200\"}}};\n    filter->callbacks_->encodeHeaders(std::move(response_headers), true);\n\n    data.drain(4);\n  }));\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n}\n\nTEST_F(HttpConnectionManagerImplTest, TestDownstreamDisconnectAccessLog) {\n  setup(false, \"\");\n\n  std::shared_ptr<MockStreamDecoderFilter> filter(new NiceMock<MockStreamDecoderFilter>());\n  std::shared_ptr<AccessLog::MockInstance> handler(new NiceMock<AccessLog::MockInstance>());\n\n  EXPECT_CALL(filter_factory_, createFilterChain(_))\n      .WillOnce(Invoke([&](FilterChainFactoryCallbacks& callbacks) -> void {\n        callbacks.addStreamDecoderFilter(filter);\n        callbacks.addAccessLogHandler(handler);\n      }));\n\n  EXPECT_CALL(*handler, log(_, _, _, _))\n      .WillOnce(Invoke([](const HeaderMap*, const HeaderMap*, const HeaderMap*,\n                          const StreamInfo::StreamInfo& stream_info) {\n        EXPECT_FALSE(stream_info.responseCode());\n        EXPECT_TRUE(stream_info.hasAnyResponseFlag());\n        EXPECT_TRUE(\n            stream_info.hasResponseFlag(StreamInfo::ResponseFlag::DownstreamConnectionTermination));\n      }));\n\n  StreamDecoder* decoder = nullptr;\n  NiceMock<MockStreamEncoder> encoder;\n  EXPECT_CALL(*codec_, dispatch(_)).WillRepeatedly(Invoke([&](Buffer::Instance& data) -> void {\n    decoder = &conn_manager_->newStream(encoder);\n\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":method\", \"GET\"}, {\":authority\", \"host\"}, {\":path\", \"/\"}}};\n    decoder->decodeHeaders(std::move(headers), true);\n\n    data.drain(4);\n  }));\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n}\n\nTEST_F(HttpConnectionManagerImplTest, TestAccessLogWithTrailers) {\n  setup(false, \"\");\n\n  std::shared_ptr<MockStreamDecoderFilter> filter(new NiceMock<MockStreamDecoderFilter>());\n  std::shared_ptr<AccessLog::MockInstance> handler(new NiceMock<AccessLog::MockInstance>());\n\n  EXPECT_CALL(filter_factory_, createFilterChain(_))\n      .WillOnce(Invoke([&](FilterChainFactoryCallbacks& callbacks) -> void {\n        callbacks.addStreamDecoderFilter(filter);\n        callbacks.addAccessLogHandler(handler);\n      }));\n\n  EXPECT_CALL(*handler, log(_, _, _, _))\n      .WillOnce(Invoke([](const HeaderMap*, const HeaderMap*, const HeaderMap*,\n                          const StreamInfo::StreamInfo& stream_info) {\n        EXPECT_TRUE(stream_info.responseCode());\n        EXPECT_EQ(stream_info.responseCode().value(), uint32_t(200));\n        EXPECT_NE(nullptr, stream_info.downstreamLocalAddress());\n        EXPECT_NE(nullptr, stream_info.downstreamRemoteAddress());\n        EXPECT_NE(nullptr, stream_info.downstreamDirectRemoteAddress());\n        EXPECT_NE(nullptr, stream_info.routeEntry());\n      }));\n\n  StreamDecoder* decoder = nullptr;\n  NiceMock<MockStreamEncoder> encoder;\n  EXPECT_CALL(*codec_, dispatch(_)).WillRepeatedly(Invoke([&](Buffer::Instance& data) -> void {\n    decoder = &conn_manager_->newStream(encoder);\n\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":method\", \"GET\"},\n                              {\":authority\", \"host\"},\n                              {\":path\", \"/\"},\n                              {\"x-request-id\", \"125a4afb-6f55-a4ba-ad80-413f09f48a28\"}}};\n    decoder->decodeHeaders(std::move(headers), true);\n\n    HeaderMapPtr response_headers{new TestHeaderMapImpl{{\":status\", \"200\"}}};\n    filter->callbacks_->encodeHeaders(std::move(response_headers), false);\n\n    HeaderMapPtr response_trailers{new TestHeaderMapImpl{{\"x-trailer\", \"1\"}}};\n    filter->callbacks_->encodeTrailers(std::move(response_trailers));\n\n    data.drain(4);\n  }));\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n}\n\nTEST_F(HttpConnectionManagerImplTest, TestAccessLogWithInvalidRequest) {\n  setup(false, \"\");\n\n  std::shared_ptr<MockStreamDecoderFilter> filter(new NiceMock<MockStreamDecoderFilter>());\n  std::shared_ptr<AccessLog::MockInstance> handler(new NiceMock<AccessLog::MockInstance>());\n\n  EXPECT_CALL(filter_factory_, createFilterChain(_))\n      .WillOnce(Invoke([&](FilterChainFactoryCallbacks& callbacks) -> void {\n        callbacks.addStreamDecoderFilter(filter);\n        callbacks.addAccessLogHandler(handler);\n      }));\n\n  EXPECT_CALL(*handler, log(_, _, _, _))\n      .WillOnce(Invoke([](const HeaderMap*, const HeaderMap*, const HeaderMap*,\n                          const StreamInfo::StreamInfo& stream_info) {\n        EXPECT_TRUE(stream_info.responseCode());\n        EXPECT_EQ(stream_info.responseCode().value(), uint32_t(400));\n        EXPECT_EQ(\"missing_host_header\", stream_info.responseCodeDetails().value());\n        EXPECT_NE(nullptr, stream_info.downstreamLocalAddress());\n        EXPECT_NE(nullptr, stream_info.downstreamRemoteAddress());\n        EXPECT_NE(nullptr, stream_info.downstreamDirectRemoteAddress());\n        EXPECT_EQ(nullptr, stream_info.routeEntry());\n      }));\n\n  StreamDecoder* decoder = nullptr;\n  NiceMock<MockStreamEncoder> encoder;\n  EXPECT_CALL(*codec_, dispatch(_)).WillRepeatedly(Invoke([&](Buffer::Instance& data) -> void {\n    decoder = &conn_manager_->newStream(encoder);\n\n    // These request headers are missing the necessary \":host\"\n    HeaderMapPtr headers{new TestHeaderMapImpl{{\":method\", \"GET\"}, {\":path\", \"/\"}}};\n    decoder->decodeHeaders(std::move(headers), true);\n    data.drain(0);\n  }));\n\n  Buffer::OwnedImpl fake_input;\n  conn_manager_->onData(fake_input, false);\n}\n\nTEST_F(HttpConnectionManagerImplTest, TestAccessLogSsl) {\n  setup(true, \"\");\n\n  std::shared_ptr<MockStreamDecoderFilter> filter(new NiceMock<MockStreamDecoderFilter>());\n  std::shared_ptr<AccessLog::MockInstance> handler(new NiceMock<AccessLog::MockInstance>());\n\n  EXPECT_CALL(filter_factory_, createFilterChain(_))\n      .WillOnce(Invoke([&](FilterChainFactoryCallbacks& callbacks) -> void {\n        callbacks.addStreamDecoderFilter(filter);\n        callbacks.addAccessLogHandler(handler);\n      }));\n\n  EXPECT_CALL(*handler, log(_, _, _, _))\n      .WillOnce(Invoke([](const HeaderMap*, const HeaderMap*, const HeaderMap*,\n                          const StreamInfo::StreamInfo& stream_info) {\n        EXPECT_TRUE(stream_info.responseCode());\n        EXPECT_EQ(stream_info.responseCode().value(), uint32_t(200));\n        EXPECT_NE(nullptr, stream_info.downstreamLocalAddress());\n        EXPECT_NE(nullptr, stream_info.downstreamRemoteAddress());\n        EXPECT_NE(nullptr, stream_info.downstreamDirectRemoteAddress());\n        EXPECT_NE(nullptr, stream_info.downstreamSslConnection());\n        EXPECT_NE(nullptr, stream_info.routeEntry());\n      }));\n\n  StreamDecoder* decoder = nullptr;\n  NiceMock<MockStreamEncoder> encoder;\n  EXPECT_CALL(*codec_, dispatch(_)).WillRepeatedly(Invoke([&](Buffer::Instance& data) -> void {\n    decoder = &conn_manager_->newStream(encoder);\n\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":method\", \"GET\"},\n                              {\":authority\", \"host\"},\n                              {\":path\", \"/\"},\n                              {\"x-request-id\", \"125a4afb-6f55-a4ba-ad80-413f09f48a28\"}}};\n    decoder->decodeHeaders(std::move(headers), true);\n\n    HeaderMapPtr response_headers{new TestHeaderMapImpl{{\":status\", \"200\"}}};\n    filter->callbacks_->encodeHeaders(std::move(response_headers), false);\n\n    HeaderMapPtr response_trailers{new TestHeaderMapImpl{{\"x-trailer\", \"1\"}}};\n    filter->callbacks_->encodeTrailers(std::move(response_trailers));\n\n    data.drain(4);\n  }));\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n}\n\nTEST_F(HttpConnectionManagerImplTest, DoNotStartSpanIfTracingIsNotEnabled) {\n  setup(false, \"\");\n\n  // Disable tracing.\n  tracing_config_.reset();\n\n  EXPECT_CALL(tracer_, startSpan_(_, _, _, _)).Times(0);\n  ON_CALL(runtime_.snapshot_,\n          featureEnabled(\"tracing.global_enabled\", An<const envoy::type::FractionalPercent&>(), _))\n      .WillByDefault(Return(true));\n\n  std::shared_ptr<MockStreamDecoderFilter> filter(new NiceMock<MockStreamDecoderFilter>());\n\n  EXPECT_CALL(filter_factory_, createFilterChain(_))\n      .WillRepeatedly(Invoke([&](FilterChainFactoryCallbacks& callbacks) -> void {\n        callbacks.addStreamDecoderFilter(filter);\n      }));\n\n  StreamDecoder* decoder = nullptr;\n  NiceMock<MockStreamEncoder> encoder;\n  EXPECT_CALL(*codec_, dispatch(_)).WillRepeatedly(Invoke([&](Buffer::Instance& data) -> void {\n    decoder = &conn_manager_->newStream(encoder);\n\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":method\", \"GET\"},\n                              {\":authority\", \"host\"},\n                              {\":path\", \"/\"},\n                              {\"x-request-id\", \"125a4afb-6f55-a4ba-ad80-413f09f48a28\"}}};\n    decoder->decodeHeaders(std::move(headers), true);\n\n    HeaderMapPtr response_headers{new TestHeaderMapImpl{{\":status\", \"200\"}}};\n    filter->callbacks_->encodeHeaders(std::move(response_headers), true);\n\n    data.drain(4);\n  }));\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n}\n\nTEST_F(HttpConnectionManagerImplTest, NoPath) {\n  setup(false, \"\");\n\n  StreamDecoder* decoder = nullptr;\n  NiceMock<MockStreamEncoder> encoder;\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance& data) -> void {\n    decoder = &conn_manager_->newStream(encoder);\n    HeaderMapPtr headers{new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":method\", \"CONNECT\"}}};\n    decoder->decodeHeaders(std::move(headers), true);\n    data.drain(4);\n  }));\n\n  EXPECT_CALL(encoder, encodeHeaders(_, true))\n      .WillOnce(Invoke([](const HeaderMap& headers, bool) -> void {\n        EXPECT_EQ(\"404\", headers.Status()->value().getStringView());\n      }));\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n}\n\n// No idle timeout when route idle timeout is implied at both global and\n// per-route level. The connection manager config is responsible for managing\n// the default configuration aspects.\nTEST_F(HttpConnectionManagerImplTest, PerStreamIdleTimeoutNotConfigured) {\n  setup(false, \"\");\n\n  EXPECT_CALL(filter_callbacks_.connection_.dispatcher_, createTimer_(_)).Times(0);\n  EXPECT_CALL(*codec_, dispatch(_)).WillRepeatedly(Invoke([&](Buffer::Instance& data) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n    decoder->decodeHeaders(std::move(headers), false);\n\n    data.drain(4);\n  }));\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n\n  EXPECT_EQ(0U, stats_.named_.downstream_rq_idle_timeout_.value());\n}\n\n// When the global timeout is configured, the timer is enabled before we receive\n// headers, if it fires we don't faceplant.\nTEST_F(HttpConnectionManagerImplTest, PerStreamIdleTimeoutGlobal) {\n  stream_idle_timeout_ = std::chrono::milliseconds(10);\n  setup(false, \"\");\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillRepeatedly(Invoke([&](Buffer::Instance&) -> void {\n    Event::MockTimer* idle_timer = setUpTimer();\n    EXPECT_CALL(*idle_timer, enableTimer(std::chrono::milliseconds(10), _));\n    conn_manager_->newStream(response_encoder_);\n\n    // Expect resetIdleTimer() to be called for the response\n    // encodeHeaders()/encodeData().\n    EXPECT_CALL(*idle_timer, enableTimer(_, _)).Times(2);\n    EXPECT_CALL(*idle_timer, disableTimer());\n    idle_timer->invokeCallback();\n  }));\n\n  // 408 direct response after timeout.\n  EXPECT_CALL(response_encoder_, encodeHeaders(_, false))\n      .WillOnce(Invoke([](const HeaderMap& headers, bool) -> void {\n        EXPECT_EQ(\"408\", headers.Status()->value().getStringView());\n      }));\n  std::string response_body;\n  EXPECT_CALL(response_encoder_, encodeData(_, true)).WillOnce(AddBufferToString(&response_body));\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n\n  EXPECT_EQ(\"stream timeout\", response_body);\n  EXPECT_EQ(1U, stats_.named_.downstream_rq_idle_timeout_.value());\n}\n\nTEST_F(HttpConnectionManagerImplTest, AccessEncoderRouteBeforeHeadersArriveOnIdleTimeout) {\n  stream_idle_timeout_ = std::chrono::milliseconds(10);\n  setup(false, \"\");\n\n  std::shared_ptr<MockStreamEncoderFilter> filter(new NiceMock<MockStreamEncoderFilter>());\n\n  EXPECT_CALL(filter_factory_, createFilterChain(_))\n      .WillOnce(Invoke([&](FilterChainFactoryCallbacks& callbacks) -> void {\n        callbacks.addStreamEncoderFilter(filter);\n      }));\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    Event::MockTimer* idle_timer = setUpTimer();\n    EXPECT_CALL(*idle_timer, enableTimer(std::chrono::milliseconds(10), _));\n    conn_manager_->newStream(response_encoder_);\n\n    // Expect resetIdleTimer() to be called for the response\n    // encodeHeaders()/encodeData().\n    EXPECT_CALL(*idle_timer, enableTimer(_, _)).Times(2);\n    EXPECT_CALL(*idle_timer, disableTimer());\n    // Simulate and idle timeout so that the filter chain gets created.\n    idle_timer->invokeCallback();\n  }));\n\n  // This should not be called as we don't have request headers.\n  EXPECT_CALL(*route_config_provider_.route_config_, route(_, _)).Times(0);\n\n  EXPECT_CALL(*filter, encodeHeaders(_, _))\n      .WillOnce(InvokeWithoutArgs([&]() -> FilterHeadersStatus {\n        // Under heavy load it is possible that stream timeout will be reached before any headers\n        // were received. Envoy will create a local reply that will go through the encoder filter\n        // chain. We want to make sure that encoder filters get a null route object.\n        auto route = filter->callbacks_->route();\n        EXPECT_EQ(route.get(), nullptr);\n        return FilterHeadersStatus::Continue;\n      }));\n  EXPECT_CALL(*filter, encodeData(_, _));\n  EXPECT_CALL(*filter, encodeComplete());\n  EXPECT_CALL(*filter, onDestroy());\n\n  EXPECT_CALL(response_encoder_, encodeHeaders(_, _));\n  EXPECT_CALL(response_encoder_, encodeData(_, _));\n\n  Buffer::OwnedImpl fake_input;\n  conn_manager_->onData(fake_input, false);\n}\n\nTEST_F(HttpConnectionManagerImplTest, TestStreamIdleAccessLog) {\n  stream_idle_timeout_ = std::chrono::milliseconds(10);\n  setup(false, \"\");\n\n  NiceMock<MockStreamEncoder> encoder;\n  EXPECT_CALL(*codec_, dispatch(_)).WillRepeatedly(Invoke([&](Buffer::Instance&) -> void {\n    Event::MockTimer* idle_timer = setUpTimer();\n    EXPECT_CALL(*idle_timer, enableTimer(std::chrono::milliseconds(10), _));\n    conn_manager_->newStream(response_encoder_);\n\n    // Expect resetIdleTimer() to be called for the response\n    // encodeHeaders()/encodeData().\n    EXPECT_CALL(*idle_timer, enableTimer(_, _)).Times(2);\n    EXPECT_CALL(*idle_timer, disableTimer());\n    idle_timer->invokeCallback();\n  }));\n\n  std::shared_ptr<MockStreamDecoderFilter> filter(new NiceMock<MockStreamDecoderFilter>());\n  std::shared_ptr<AccessLog::MockInstance> handler(new NiceMock<AccessLog::MockInstance>());\n\n  // 408 direct response after timeout.\n  EXPECT_CALL(response_encoder_, encodeHeaders(_, false))\n      .WillOnce(Invoke([](const HeaderMap& headers, bool) -> void {\n        EXPECT_EQ(\"408\", headers.Status()->value().getStringView());\n      }));\n\n  std::string response_body;\n  EXPECT_CALL(response_encoder_, encodeData(_, true)).WillOnce(AddBufferToString(&response_body));\n\n  EXPECT_CALL(*handler, log(_, _, _, _))\n      .WillOnce(Invoke([](const HeaderMap*, const HeaderMap*, const HeaderMap*,\n                          const StreamInfo::StreamInfo& stream_info) {\n        EXPECT_TRUE(stream_info.responseCode());\n        EXPECT_TRUE(stream_info.hasAnyResponseFlag());\n        EXPECT_TRUE(stream_info.hasResponseFlag(StreamInfo::ResponseFlag::StreamIdleTimeout));\n      }));\n\n  EXPECT_CALL(filter_factory_, createFilterChain(_))\n      .WillOnce(Invoke([&](FilterChainFactoryCallbacks& callbacks) -> void {\n        callbacks.addStreamDecoderFilter(filter);\n        callbacks.addAccessLogHandler(handler);\n      }));\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n\n  EXPECT_EQ(\"stream timeout\", response_body);\n  EXPECT_EQ(1U, stats_.named_.downstream_rq_idle_timeout_.value());\n}\n\n// Per-route timeouts override the global stream idle timeout.\nTEST_F(HttpConnectionManagerImplTest, PerStreamIdleTimeoutRouteOverride) {\n  stream_idle_timeout_ = std::chrono::milliseconds(10);\n  setup(false, \"\");\n  ON_CALL(route_config_provider_.route_config_->route_->route_entry_, idleTimeout())\n      .WillByDefault(Return(std::chrono::milliseconds(30)));\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillRepeatedly(Invoke([&](Buffer::Instance& data) -> void {\n    Event::MockTimer* idle_timer = setUpTimer();\n    EXPECT_CALL(*idle_timer, enableTimer(std::chrono::milliseconds(10), _));\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n    EXPECT_CALL(*idle_timer, enableTimer(std::chrono::milliseconds(30), _));\n    decoder->decodeHeaders(std::move(headers), false);\n\n    data.drain(4);\n  }));\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n\n  EXPECT_EQ(0U, stats_.named_.downstream_rq_idle_timeout_.value());\n}\n\n// Per-route zero timeout overrides the global stream idle timeout.\nTEST_F(HttpConnectionManagerImplTest, PerStreamIdleTimeoutRouteZeroOverride) {\n  stream_idle_timeout_ = std::chrono::milliseconds(10);\n  setup(false, \"\");\n  ON_CALL(route_config_provider_.route_config_->route_->route_entry_, idleTimeout())\n      .WillByDefault(Return(std::chrono::milliseconds(0)));\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillRepeatedly(Invoke([&](Buffer::Instance& data) -> void {\n    Event::MockTimer* idle_timer = setUpTimer();\n    EXPECT_CALL(*idle_timer, enableTimer(std::chrono::milliseconds(10), _));\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n    EXPECT_CALL(*idle_timer, disableTimer());\n    decoder->decodeHeaders(std::move(headers), false);\n\n    data.drain(4);\n  }));\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n\n  EXPECT_EQ(0U, stats_.named_.downstream_rq_idle_timeout_.value());\n}\n\n// Validate the per-stream idle timeout after having sent downstream headers.\nTEST_F(HttpConnectionManagerImplTest, PerStreamIdleTimeoutAfterDownstreamHeaders) {\n  setup(false, \"\");\n  ON_CALL(route_config_provider_.route_config_->route_->route_entry_, idleTimeout())\n      .WillByDefault(Return(std::chrono::milliseconds(10)));\n\n  // Codec sends downstream request headers.\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance& data) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n\n    Event::MockTimer* idle_timer = setUpTimer();\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n    EXPECT_CALL(*idle_timer, enableTimer(_, _));\n    decoder->decodeHeaders(std::move(headers), false);\n\n    // Expect resetIdleTimer() to be called for the response\n    // encodeHeaders()/encodeData().\n    EXPECT_CALL(*idle_timer, enableTimer(_, _)).Times(2);\n    EXPECT_CALL(*idle_timer, disableTimer());\n    idle_timer->invokeCallback();\n\n    data.drain(4);\n  }));\n\n  // 408 direct response after timeout.\n  EXPECT_CALL(response_encoder_, encodeHeaders(_, false))\n      .WillOnce(Invoke([](const HeaderMap& headers, bool) -> void {\n        EXPECT_EQ(\"408\", headers.Status()->value().getStringView());\n      }));\n  std::string response_body;\n  EXPECT_CALL(response_encoder_, encodeData(_, true)).WillOnce(AddBufferToString(&response_body));\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n\n  EXPECT_EQ(\"stream timeout\", response_body);\n  EXPECT_EQ(1U, stats_.named_.downstream_rq_idle_timeout_.value());\n}\n\n// Validate the per-stream idle timer is properly disabled when the stream terminates normally.\nTEST_F(HttpConnectionManagerImplTest, PerStreamIdleTimeoutNormalTermination) {\n  setup(false, \"\");\n  ON_CALL(route_config_provider_.route_config_->route_->route_entry_, idleTimeout())\n      .WillByDefault(Return(std::chrono::milliseconds(10)));\n\n  // Codec sends downstream request headers.\n  Event::MockTimer* idle_timer = setUpTimer();\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance& data) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n    EXPECT_CALL(*idle_timer, enableTimer(_, _));\n    decoder->decodeHeaders(std::move(headers), false);\n\n    data.drain(4);\n  }));\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n\n  EXPECT_CALL(*idle_timer, disableTimer());\n  conn_manager_->onEvent(Network::ConnectionEvent::RemoteClose);\n\n  EXPECT_EQ(0U, stats_.named_.downstream_rq_idle_timeout_.value());\n}\n\n// Validate the per-stream idle timeout after having sent downstream\n// headers+body.\nTEST_F(HttpConnectionManagerImplTest, PerStreamIdleTimeoutAfterDownstreamHeadersAndBody) {\n  setup(false, \"\");\n  ON_CALL(route_config_provider_.route_config_->route_->route_entry_, idleTimeout())\n      .WillByDefault(Return(std::chrono::milliseconds(10)));\n\n  // Codec sends downstream request headers.\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance& data) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n\n    Event::MockTimer* idle_timer = setUpTimer();\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n    EXPECT_CALL(*idle_timer, enableTimer(_, _));\n    decoder->decodeHeaders(std::move(headers), false);\n\n    EXPECT_CALL(*idle_timer, enableTimer(_, _));\n    decoder->decodeData(data, false);\n\n    // Expect resetIdleTimer() to be called for the response\n    // encodeHeaders()/encodeData().\n    EXPECT_CALL(*idle_timer, enableTimer(_, _)).Times(2);\n    EXPECT_CALL(*idle_timer, disableTimer());\n    idle_timer->invokeCallback();\n\n    data.drain(4);\n  }));\n\n  // 408 direct response after timeout.\n  EXPECT_CALL(response_encoder_, encodeHeaders(_, false))\n      .WillOnce(Invoke([](const HeaderMap& headers, bool) -> void {\n        EXPECT_EQ(\"408\", headers.Status()->value().getStringView());\n      }));\n  std::string response_body;\n  EXPECT_CALL(response_encoder_, encodeData(_, true)).WillOnce(AddBufferToString(&response_body));\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n\n  EXPECT_EQ(\"stream timeout\", response_body);\n  EXPECT_EQ(1U, stats_.named_.downstream_rq_idle_timeout_.value());\n}\n\n// Validate the per-stream idle timeout after upstream headers have been sent.\nTEST_F(HttpConnectionManagerImplTest, PerStreamIdleTimeoutAfterUpstreamHeaders) {\n  setup(false, \"\");\n  ON_CALL(route_config_provider_.route_config_->route_->route_entry_, idleTimeout())\n      .WillByDefault(Return(std::chrono::milliseconds(10)));\n\n  // Store the basic request encoder during filter chain setup.\n  std::shared_ptr<MockStreamDecoderFilter> filter(new NiceMock<MockStreamDecoderFilter>());\n\n  EXPECT_CALL(filter_factory_, createFilterChain(_))\n      .WillRepeatedly(Invoke([&](FilterChainFactoryCallbacks& callbacks) -> void {\n        callbacks.addStreamDecoderFilter(filter);\n      }));\n  EXPECT_CALL(filter_callbacks_.connection_.dispatcher_, deferredDelete_(_));\n\n  // Codec sends downstream request headers, upstream response headers are\n  // encoded.\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance& data) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n\n    Event::MockTimer* idle_timer = setUpTimer();\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n    EXPECT_CALL(*idle_timer, enableTimer(_, _));\n    decoder->decodeHeaders(std::move(headers), false);\n\n    HeaderMapPtr response_headers{new TestHeaderMapImpl{{\":status\", \"200\"}}};\n    EXPECT_CALL(*idle_timer, enableTimer(_, _));\n    filter->callbacks_->encodeHeaders(std::move(response_headers), false);\n\n    EXPECT_CALL(*idle_timer, disableTimer());\n    idle_timer->invokeCallback();\n\n    data.drain(4);\n  }));\n\n  // 200 upstream response.\n  EXPECT_CALL(response_encoder_, encodeHeaders(_, false))\n      .WillOnce(Invoke([](const HeaderMap& headers, bool) -> void {\n        EXPECT_EQ(\"200\", headers.Status()->value().getStringView());\n      }));\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n\n  EXPECT_EQ(1U, stats_.named_.downstream_rq_idle_timeout_.value());\n}\n\n// Validate the per-stream idle timeout after a sequence of header/data events.\nTEST_F(HttpConnectionManagerImplTest, PerStreamIdleTimeoutAfterBidiData) {\n  setup(false, \"\");\n  ON_CALL(route_config_provider_.route_config_->route_->route_entry_, idleTimeout())\n      .WillByDefault(Return(std::chrono::milliseconds(10)));\n  proxy_100_continue_ = true;\n\n  // Store the basic request encoder during filter chain setup.\n  std::shared_ptr<MockStreamDecoderFilter> filter(new NiceMock<MockStreamDecoderFilter>());\n\n  EXPECT_CALL(filter_factory_, createFilterChain(_))\n      .WillRepeatedly(Invoke([&](FilterChainFactoryCallbacks& callbacks) -> void {\n        callbacks.addStreamDecoderFilter(filter);\n      }));\n  EXPECT_CALL(filter_callbacks_.connection_.dispatcher_, deferredDelete_(_));\n\n  // Codec sends downstream request headers, upstream response headers are\n  // encoded, data events happen in various directions.\n  Event::MockTimer* idle_timer = setUpTimer();\n  StreamDecoder* decoder;\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance& data) -> void {\n    decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n    EXPECT_CALL(*idle_timer, enableTimer(_, _));\n    decoder->decodeHeaders(std::move(headers), false);\n\n    HeaderMapPtr response_continue_headers{new TestHeaderMapImpl{{\":status\", \"100\"}}};\n    EXPECT_CALL(*idle_timer, enableTimer(_, _));\n    filter->callbacks_->encode100ContinueHeaders(std::move(response_continue_headers));\n\n    HeaderMapPtr response_headers{new TestHeaderMapImpl{{\":status\", \"200\"}}};\n    EXPECT_CALL(*idle_timer, enableTimer(_, _));\n    filter->callbacks_->encodeHeaders(std::move(response_headers), false);\n\n    EXPECT_CALL(*idle_timer, enableTimer(_, _));\n    decoder->decodeData(data, false);\n\n    HeaderMapPtr trailers{new TestHeaderMapImpl{{\"foo\", \"bar\"}}};\n    EXPECT_CALL(*idle_timer, enableTimer(_, _));\n    decoder->decodeTrailers(std::move(trailers));\n\n    Buffer::OwnedImpl fake_response(\"world\");\n    EXPECT_CALL(*idle_timer, enableTimer(_, _));\n    filter->callbacks_->encodeData(fake_response, false);\n\n    EXPECT_CALL(*idle_timer, disableTimer());\n    idle_timer->invokeCallback();\n\n    data.drain(4);\n  }));\n\n  // 100 continue.\n  EXPECT_CALL(response_encoder_, encode100ContinueHeaders(_));\n\n  // 200 upstream response.\n  EXPECT_CALL(response_encoder_, encodeHeaders(_, false))\n      .WillOnce(Invoke([](const HeaderMap& headers, bool) -> void {\n        EXPECT_EQ(\"200\", headers.Status()->value().getStringView());\n      }));\n\n  std::string response_body;\n  EXPECT_CALL(response_encoder_, encodeData(_, false)).WillOnce(AddBufferToString(&response_body));\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n\n  EXPECT_EQ(1U, stats_.named_.downstream_rq_idle_timeout_.value());\n  EXPECT_EQ(\"world\", response_body);\n}\n\nTEST_F(HttpConnectionManagerImplTest, RequestTimeoutDisabledByDefault) {\n  setup(false, \"\");\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    EXPECT_CALL(filter_callbacks_.connection_.dispatcher_, createTimer_).Times(0);\n    conn_manager_->newStream(response_encoder_);\n  }));\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n}\n\nTEST_F(HttpConnectionManagerImplTest, RequestTimeoutDisabledIfSetToZero) {\n  request_timeout_ = std::chrono::milliseconds(0);\n  setup(false, \"\");\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    EXPECT_CALL(filter_callbacks_.connection_.dispatcher_, createTimer_).Times(0);\n    conn_manager_->newStream(response_encoder_);\n  }));\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n}\n\nTEST_F(HttpConnectionManagerImplTest, RequestTimeoutValidlyConfigured) {\n  request_timeout_ = std::chrono::milliseconds(10);\n  setup(false, \"\");\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    Event::MockTimer* request_timer = setUpTimer();\n    EXPECT_CALL(*request_timer, enableTimer(request_timeout_, _));\n\n    conn_manager_->newStream(response_encoder_);\n  }));\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n}\n\nTEST_F(HttpConnectionManagerImplTest, RequestTimeoutCallbackDisarmsAndReturns408) {\n  request_timeout_ = std::chrono::milliseconds(10);\n  setup(false, \"\");\n\n  std::string response_body;\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    Event::MockTimer* request_timer = setUpTimer();\n    EXPECT_CALL(*request_timer, enableTimer(request_timeout_, _)).Times(1);\n    EXPECT_CALL(*request_timer, disableTimer()).Times(AtLeast(1));\n\n    EXPECT_CALL(response_encoder_, encodeHeaders(_, false))\n        .WillOnce(Invoke([](const HeaderMap& headers, bool) -> void {\n          EXPECT_EQ(\"408\", headers.Status()->value().getStringView());\n        }));\n    EXPECT_CALL(response_encoder_, encodeData(_, true)).WillOnce(AddBufferToString(&response_body));\n\n    conn_manager_->newStream(response_encoder_);\n    EXPECT_CALL(filter_callbacks_.connection_.dispatcher_, setTrackedObject(_)).Times(2);\n    request_timer->invokeCallback();\n  }));\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false); // kick off request\n\n  EXPECT_EQ(1U, stats_.named_.downstream_rq_timeout_.value());\n  EXPECT_EQ(\"request timeout\", response_body);\n}\n\nTEST_F(HttpConnectionManagerImplTest, RequestTimeoutIsNotDisarmedOnIncompleteRequestWithHeader) {\n  request_timeout_ = std::chrono::milliseconds(10);\n  setup(false, \"\");\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    Event::MockTimer* request_timer = setUpTimer();\n    EXPECT_CALL(*request_timer, enableTimer(request_timeout_, _)).Times(1);\n    EXPECT_CALL(*request_timer, disableTimer()).Times(0);\n\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n\n    // the second parameter 'false' leaves the stream open\n    decoder->decodeHeaders(std::move(headers), false);\n  }));\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false); // kick off request\n\n  EXPECT_EQ(0U, stats_.named_.downstream_rq_timeout_.value());\n}\n\nTEST_F(HttpConnectionManagerImplTest, RequestTimeoutIsDisarmedOnCompleteRequestWithHeader) {\n  request_timeout_ = std::chrono::milliseconds(10);\n  setup(false, \"\");\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    Event::MockTimer* request_timer = setUpTimer();\n    EXPECT_CALL(*request_timer, enableTimer(request_timeout_, _)).Times(1);\n\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n\n    EXPECT_CALL(*request_timer, disableTimer()).Times(1);\n    decoder->decodeHeaders(std::move(headers), true);\n  }));\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false); // kick off request\n\n  EXPECT_EQ(0U, stats_.named_.downstream_rq_timeout_.value());\n}\n\nTEST_F(HttpConnectionManagerImplTest, RequestTimeoutIsDisarmedOnCompleteRequestWithData) {\n  request_timeout_ = std::chrono::milliseconds(10);\n  setup(false, \"\");\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance& data) -> void {\n    Event::MockTimer* request_timer = setUpTimer();\n    EXPECT_CALL(*request_timer, enableTimer(request_timeout_, _)).Times(1);\n\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"POST\"}}};\n    decoder->decodeHeaders(std::move(headers), false);\n\n    EXPECT_CALL(*request_timer, disableTimer()).Times(1);\n    decoder->decodeData(data, true);\n  }));\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n\n  EXPECT_EQ(0U, stats_.named_.downstream_rq_timeout_.value());\n}\n\nTEST_F(HttpConnectionManagerImplTest, RequestTimeoutIsDisarmedOnCompleteRequestWithTrailers) {\n  request_timeout_ = std::chrono::milliseconds(10);\n  setup(false, \"\");\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance& data) -> void {\n    Event::MockTimer* request_timer = setUpTimer();\n    EXPECT_CALL(*request_timer, enableTimer(request_timeout_, _)).Times(1);\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n    decoder->decodeHeaders(std::move(headers), false);\n    decoder->decodeData(data, false);\n\n    EXPECT_CALL(*request_timer, disableTimer()).Times(1);\n    HeaderMapPtr trailers{new TestHeaderMapImpl{{\"foo\", \"bar\"}}};\n    decoder->decodeTrailers(std::move(trailers));\n  }));\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n\n  EXPECT_EQ(0U, stats_.named_.downstream_rq_timeout_.value());\n}\n\nTEST_F(HttpConnectionManagerImplTest, RequestTimeoutIsDisarmedOnEncodeHeaders) {\n  request_timeout_ = std::chrono::milliseconds(10);\n  setup(false, \"\");\n  std::shared_ptr<MockStreamDecoderFilter> filter(new NiceMock<MockStreamDecoderFilter>());\n  EXPECT_CALL(filter_factory_, createFilterChain(_))\n      .WillRepeatedly(Invoke([&](FilterChainFactoryCallbacks& callbacks) -> void {\n        callbacks.addStreamDecoderFilter(filter);\n      }));\n  EXPECT_CALL(response_encoder_, encodeHeaders(_, _));\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    Event::MockTimer* request_timer = setUpTimer();\n    EXPECT_CALL(*request_timer, enableTimer(request_timeout_, _)).Times(1);\n\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n\n    decoder->decodeHeaders(std::move(headers), false);\n\n    EXPECT_CALL(*request_timer, disableTimer()).Times(1);\n    HeaderMapPtr response_headers{new TestHeaderMapImpl{{\":status\", \"200\"}}};\n    filter->callbacks_->encodeHeaders(std::move(response_headers), false);\n  }));\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false); // kick off request\n\n  EXPECT_EQ(0U, stats_.named_.downstream_rq_timeout_.value());\n}\n\nTEST_F(HttpConnectionManagerImplTest, RequestTimeoutIsDisarmedOnConnectionTermination) {\n  request_timeout_ = std::chrono::milliseconds(10);\n  setup(false, \"\");\n\n  Event::MockTimer* request_timer = setUpTimer();\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n\n    decoder->decodeHeaders(std::move(headers), false);\n  }));\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n\n  EXPECT_CALL(*request_timer, enableTimer(request_timeout_, _)).Times(1);\n  conn_manager_->onData(fake_input, false); // kick off request\n\n  EXPECT_CALL(*request_timer, disableTimer()).Times(1);\n  conn_manager_->onEvent(Network::ConnectionEvent::RemoteClose);\n\n  EXPECT_EQ(0U, stats_.named_.downstream_rq_timeout_.value());\n}\n\nTEST_F(HttpConnectionManagerImplTest, RejectWebSocketOnNonWebSocketRoute) {\n  setup(false, \"\");\n  StreamDecoder* decoder = nullptr;\n  NiceMock<MockStreamEncoder> encoder;\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance& data) -> void {\n    decoder = &conn_manager_->newStream(encoder);\n    HeaderMapPtr headers{new TestHeaderMapImpl{{\":authority\", \"host\"},\n                                               {\":method\", \"GET\"},\n                                               {\":path\", \"/\"},\n                                               {\"connection\", \"Upgrade\"},\n                                               {\"upgrade\", \"websocket\"}}};\n    decoder->decodeHeaders(std::move(headers), true);\n    data.drain(4);\n  }));\n\n  EXPECT_CALL(encoder, encodeHeaders(_, true))\n      .WillOnce(Invoke([](const HeaderMap& headers, bool) -> void {\n        EXPECT_EQ(\"403\", headers.Status()->value().getStringView());\n      }));\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n\n  EXPECT_EQ(1U, stats_.named_.downstream_rq_ws_on_non_ws_route_.value());\n}\n\n// Make sure for upgrades, we do not append Connection: Close when draining.\nTEST_F(HttpConnectionManagerImplTest, FooUpgradeDrainClose) {\n  setup(false, \"envoy-custom-server\", false);\n\n  // Store the basic request encoder during filter chain setup.\n  auto* filter = new MockStreamFilter();\n  EXPECT_CALL(drain_close_, drainClose()).WillOnce(Return(true));\n\n  EXPECT_CALL(*filter, decodeHeaders(_, false))\n      .WillRepeatedly(Invoke([&](HeaderMap&, bool) -> FilterHeadersStatus {\n        return FilterHeadersStatus::StopIteration;\n      }));\n\n  EXPECT_CALL(*filter, encodeHeaders(_, false))\n      .WillRepeatedly(Invoke(\n          [&](HeaderMap&, bool) -> FilterHeadersStatus { return FilterHeadersStatus::Continue; }));\n\n  NiceMock<MockStreamEncoder> encoder;\n  EXPECT_CALL(encoder, encodeHeaders(_, false))\n      .WillOnce(Invoke([&](const HeaderMap& headers, bool) -> void {\n        EXPECT_NE(nullptr, headers.Connection());\n        EXPECT_EQ(\"upgrade\", headers.Connection()->value().getStringView());\n      }));\n\n  EXPECT_CALL(*filter, setDecoderFilterCallbacks(_));\n  EXPECT_CALL(*filter, setEncoderFilterCallbacks(_));\n\n  EXPECT_CALL(filter_factory_, createUpgradeFilterChain(_, _, _))\n      .WillRepeatedly(Invoke([&](absl::string_view, const Http::FilterChainFactory::UpgradeMap*,\n                                 FilterChainFactoryCallbacks& callbacks) -> bool {\n        callbacks.addStreamFilter(StreamFilterSharedPtr{filter});\n        return true;\n      }));\n\n  // When dispatch is called on the codec, we pretend to get a new stream and then fire a headers\n  // only request into it. Then we respond into the filter.\n  StreamDecoder* decoder = nullptr;\n  EXPECT_CALL(*codec_, dispatch(_)).WillRepeatedly(Invoke([&](Buffer::Instance& data) -> void {\n    decoder = &conn_manager_->newStream(encoder);\n\n    HeaderMapPtr headers{new TestHeaderMapImpl{{\":authority\", \"host\"},\n                                               {\":method\", \"GET\"},\n                                               {\":path\", \"/\"},\n                                               {\"connection\", \"Upgrade\"},\n                                               {\"upgrade\", \"foo\"}}};\n    decoder->decodeHeaders(std::move(headers), false);\n\n    HeaderMapPtr response_headers{\n        new TestHeaderMapImpl{{\":status\", \"101\"}, {\"Connection\", \"upgrade\"}, {\"upgrade\", \"foo\"}}};\n    filter->decoder_callbacks_->encodeHeaders(std::move(response_headers), false);\n\n    data.drain(4);\n  }));\n\n  // Kick off the incoming data. Use extra data which should cause a redispatch.\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n}\n\nTEST_F(HttpConnectionManagerImplTest, DrainClose) {\n  setup(true, \"\");\n\n  MockStreamDecoderFilter* filter = new NiceMock<MockStreamDecoderFilter>();\n  EXPECT_CALL(filter_factory_, createFilterChain(_))\n      .WillOnce(Invoke([&](FilterChainFactoryCallbacks& callbacks) -> void {\n        callbacks.addStreamDecoderFilter(StreamDecoderFilterSharedPtr{filter});\n      }));\n\n  EXPECT_CALL(*filter, decodeHeaders(_, true))\n      .WillOnce(Invoke([](HeaderMap& headers, bool) -> FilterHeadersStatus {\n        EXPECT_NE(nullptr, headers.ForwardedFor());\n        EXPECT_EQ(\"https\", headers.ForwardedProto()->value().getStringView());\n        return FilterHeadersStatus::StopIteration;\n      }));\n\n  StreamDecoder* decoder = nullptr;\n  NiceMock<MockStreamEncoder> encoder;\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    decoder = &conn_manager_->newStream(encoder);\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n    decoder->decodeHeaders(std::move(headers), true);\n  }));\n\n  Buffer::OwnedImpl fake_input;\n  conn_manager_->onData(fake_input, false);\n\n  HeaderMapPtr response_headers{new TestHeaderMapImpl{{\":status\", \"300\"}}};\n  Event::MockTimer* drain_timer = setUpTimer();\n  EXPECT_CALL(*drain_timer, enableTimer(_, _));\n  EXPECT_CALL(drain_close_, drainClose()).WillOnce(Return(true));\n  EXPECT_CALL(*codec_, shutdownNotice());\n  filter->callbacks_->encodeHeaders(std::move(response_headers), true);\n  EXPECT_EQ(ssl_connection_.get(), filter->callbacks_->connection()->ssl().get());\n\n  EXPECT_CALL(*codec_, goAway());\n  EXPECT_CALL(filter_callbacks_.connection_,\n              close(Network::ConnectionCloseType::FlushWriteAndDelay));\n  EXPECT_CALL(*drain_timer, disableTimer());\n  drain_timer->invokeCallback();\n\n  EXPECT_EQ(1U, stats_.named_.downstream_cx_drain_close_.value());\n  EXPECT_EQ(1U, stats_.named_.downstream_rq_3xx_.value());\n  EXPECT_EQ(1U, listener_stats_.downstream_rq_3xx_.value());\n  EXPECT_EQ(1U, stats_.named_.downstream_rq_completed_.value());\n  EXPECT_EQ(1U, listener_stats_.downstream_rq_completed_.value());\n}\n\nTEST_F(HttpConnectionManagerImplTest, ResponseBeforeRequestComplete) {\n  InSequence s;\n  setup(false, \"envoy-server-test\");\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n    decoder->decodeHeaders(std::move(headers), false);\n  }));\n\n  setupFilterChain(1, 0);\n\n  EXPECT_CALL(*decoder_filters_[0], decodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::StopIteration));\n\n  Buffer::OwnedImpl fake_input;\n  conn_manager_->onData(fake_input, false);\n\n  EXPECT_CALL(response_encoder_, encodeHeaders(_, true))\n      .WillOnce(Invoke([](const HeaderMap& headers, bool) -> void {\n        EXPECT_NE(nullptr, headers.Server());\n        EXPECT_EQ(\"envoy-server-test\", headers.Server()->value().getStringView());\n      }));\n  EXPECT_CALL(*decoder_filters_[0], onDestroy());\n  EXPECT_CALL(filter_callbacks_.connection_,\n              close(Network::ConnectionCloseType::FlushWriteAndDelay));\n\n  HeaderMapPtr response_headers{new TestHeaderMapImpl{{\":status\", \"200\"}}};\n  decoder_filters_[0]->callbacks_->encodeHeaders(std::move(response_headers), true);\n}\n\nTEST_F(HttpConnectionManagerImplTest, DisconnectOnProxyConnectionDisconnect) {\n  InSequence s;\n  setup(false, \"envoy-server-test\");\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{new TestHeaderMapImpl{\n        {\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}, {\"proxy-connection\", \"close\"}}};\n    decoder->decodeHeaders(std::move(headers), false);\n  }));\n\n  setupFilterChain(1, 0);\n\n  EXPECT_CALL(*decoder_filters_[0], decodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::StopIteration));\n\n  Buffer::OwnedImpl fake_input;\n  conn_manager_->onData(fake_input, false);\n\n  EXPECT_CALL(response_encoder_, encodeHeaders(_, true))\n      .WillOnce(Invoke([](const HeaderMap& headers, bool) -> void {\n        EXPECT_NE(nullptr, headers.Connection());\n        EXPECT_EQ(\"close\", headers.Connection()->value().getStringView());\n        EXPECT_EQ(nullptr, headers.ProxyConnection());\n      }));\n  EXPECT_CALL(*decoder_filters_[0], onDestroy());\n  EXPECT_CALL(filter_callbacks_.connection_,\n              close(Network::ConnectionCloseType::FlushWriteAndDelay));\n\n  HeaderMapPtr response_headers{new TestHeaderMapImpl{{\":status\", \"200\"}}};\n  decoder_filters_[0]->callbacks_->encodeHeaders(std::move(response_headers), true);\n}\n\nTEST_F(HttpConnectionManagerImplTest, ResponseStartBeforeRequestComplete) {\n  setup(false, \"\");\n\n  // This is like ResponseBeforeRequestComplete, but it tests the case where we start the reply\n  // before the request completes, but don't finish the reply until after the request completes.\n  MockStreamDecoderFilter* filter = new NiceMock<MockStreamDecoderFilter>();\n  EXPECT_CALL(filter_factory_, createFilterChain(_))\n      .WillOnce(Invoke([&](FilterChainFactoryCallbacks& callbacks) -> void {\n        callbacks.addStreamDecoderFilter(StreamDecoderFilterSharedPtr{filter});\n      }));\n\n  EXPECT_CALL(*filter, decodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::StopIteration));\n\n  // Start the request\n  StreamDecoder* decoder = nullptr;\n  NiceMock<MockStreamEncoder> encoder;\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    decoder = &conn_manager_->newStream(encoder);\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n    decoder->decodeHeaders(std::move(headers), false);\n  }));\n\n  Buffer::OwnedImpl fake_input(\"hello\");\n  conn_manager_->onData(fake_input, false);\n\n  // Start the response\n  HeaderMapPtr response_headers{new TestHeaderMapImpl{{\":status\", \"200\"}}};\n  EXPECT_CALL(encoder, encodeHeaders(_, false))\n      .WillOnce(Invoke([](const HeaderMap& headers, bool) -> void {\n        EXPECT_NE(nullptr, headers.Server());\n        EXPECT_EQ(\"\", headers.Server()->value().getStringView());\n      }));\n  filter->callbacks_->encodeHeaders(std::move(response_headers), false);\n\n  // Finish the request.\n  EXPECT_CALL(*filter, decodeData(_, true));\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance& data) -> void {\n    decoder->decodeData(data, true);\n  }));\n\n  conn_manager_->onData(fake_input, false);\n\n  // Since we started the response before the request was complete, we will still close the\n  // connection since we already sent a connection: close header. We won't \"reset\" the stream\n  // however.\n  EXPECT_CALL(filter_callbacks_.connection_,\n              close(Network::ConnectionCloseType::FlushWriteAndDelay));\n  Buffer::OwnedImpl fake_response(\"world\");\n  filter->callbacks_->encodeData(fake_response, true);\n}\n\nTEST_F(HttpConnectionManagerImplTest, DownstreamDisconnect) {\n  InSequence s;\n  setup(false, \"\");\n\n  NiceMock<MockStreamEncoder> encoder;\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance& data) -> void {\n    conn_manager_->newStream(encoder);\n    data.drain(2);\n  }));\n\n  EXPECT_CALL(filter_factory_, createFilterChain(_)).Times(0);\n\n  // Kick off the incoming data.\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n\n  // Now raise a remote disconnection, we should see the filter get reset called.\n  conn_manager_->onEvent(Network::ConnectionEvent::RemoteClose);\n}\n\nTEST_F(HttpConnectionManagerImplTest, DownstreamProtocolError) {\n  InSequence s;\n  setup(false, \"\");\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    conn_manager_->newStream(response_encoder_);\n    throw CodecProtocolException(\"protocol error\");\n  }));\n\n  EXPECT_CALL(response_encoder_.stream_, removeCallbacks(_));\n  EXPECT_CALL(filter_factory_, createFilterChain(_)).Times(0);\n\n  // A protocol exception should result in reset of the streams followed by a remote or local close\n  // depending on whether the downstream client closes the connection prior to the delayed close\n  // timer firing.\n  EXPECT_CALL(filter_callbacks_.connection_,\n              close(Network::ConnectionCloseType::FlushWriteAndDelay));\n\n  // Kick off the incoming data.\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n}\n\n// Verify that FrameFloodException causes connection to be closed abortively.\nTEST_F(HttpConnectionManagerImplTest, FrameFloodError) {\n  InSequence s;\n  setup(false, \"\");\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    conn_manager_->newStream(response_encoder_);\n    throw FrameFloodException(\"too many outbound frames.\");\n  }));\n\n  EXPECT_CALL(response_encoder_.stream_, removeCallbacks(_));\n  EXPECT_CALL(filter_factory_, createFilterChain(_)).Times(0);\n\n  // FrameFloodException should result in reset of the streams followed by abortive close.\n  EXPECT_CALL(filter_callbacks_.connection_,\n              close(Network::ConnectionCloseType::FlushWriteAndDelay));\n\n  // Kick off the incoming data.\n  Buffer::OwnedImpl fake_input(\"1234\");\n  EXPECT_LOG_NOT_CONTAINS(\"warning\", \"downstream HTTP flood\",\n                          conn_manager_->onData(fake_input, false));\n}\n\n// Verify that FrameFloodException causes connection to be closed abortively as well as logged\n// if runtime indicates to do so.\nTEST_F(HttpConnectionManagerImplTest, FrameFloodErrorWithLog) {\n  InSequence s;\n  setup(false, \"\");\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    conn_manager_->newStream(response_encoder_);\n    throw FrameFloodException(\"too many outbound frames.\");\n  }));\n\n  EXPECT_CALL(runtime_.snapshot_, featureEnabled(\"http.connection_manager.log_flood_exception\",\n                                                 Matcher<const envoy::type::FractionalPercent&>(_)))\n      .WillOnce(Return(true));\n\n  EXPECT_CALL(response_encoder_.stream_, removeCallbacks(_));\n  EXPECT_CALL(filter_factory_, createFilterChain(_)).Times(0);\n\n  // FrameFloodException should result in reset of the streams followed by abortive close.\n  EXPECT_CALL(filter_callbacks_.connection_,\n              close(Network::ConnectionCloseType::FlushWriteAndDelay));\n\n  // Kick off the incoming data.\n  Buffer::OwnedImpl fake_input(\"1234\");\n  EXPECT_LOG_CONTAINS(\"warning\",\n                      \"downstream HTTP flood from IP '0.0.0.0:0': too many outbound frames.\",\n                      conn_manager_->onData(fake_input, false));\n}\n\nTEST_F(HttpConnectionManagerImplTest, IdleTimeoutNoCodec) {\n  // Not used in the test.\n  delete codec_;\n\n  idle_timeout_ = (std::chrono::milliseconds(10));\n  Event::MockTimer* idle_timer = setUpTimer();\n  EXPECT_CALL(*idle_timer, enableTimer(_, _));\n  setup(false, \"\");\n\n  EXPECT_CALL(filter_callbacks_.connection_, close(Network::ConnectionCloseType::FlushWrite));\n  EXPECT_CALL(*idle_timer, disableTimer());\n  idle_timer->invokeCallback();\n\n  EXPECT_EQ(1U, stats_.named_.downstream_cx_idle_timeout_.value());\n}\n\nTEST_F(HttpConnectionManagerImplTest, IdleTimeout) {\n  idle_timeout_ = (std::chrono::milliseconds(10));\n  Event::MockTimer* idle_timer = setUpTimer();\n  EXPECT_CALL(*idle_timer, enableTimer(_, _));\n  setup(false, \"\");\n\n  MockStreamDecoderFilter* filter = new NiceMock<MockStreamDecoderFilter>();\n  EXPECT_CALL(filter_factory_, createFilterChain(_))\n      .WillOnce(Invoke([&](FilterChainFactoryCallbacks& callbacks) -> void {\n        callbacks.addStreamDecoderFilter(StreamDecoderFilterSharedPtr{filter});\n      }));\n\n  NiceMock<MockStreamEncoder> encoder;\n  StreamDecoder* decoder = nullptr;\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    decoder = &conn_manager_->newStream(encoder);\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n    decoder->decodeHeaders(std::move(headers), false);\n\n    Buffer::OwnedImpl fake_data(\"hello\");\n    decoder->decodeData(fake_data, true);\n  }));\n\n  EXPECT_CALL(*idle_timer, disableTimer());\n  EXPECT_CALL(*filter, decodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::StopIteration));\n  EXPECT_CALL(*filter, decodeData(_, true))\n      .WillOnce(Return(FilterDataStatus::StopIterationNoBuffer));\n\n  // Kick off the incoming data.\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n\n  EXPECT_CALL(*idle_timer, enableTimer(_, _));\n  HeaderMapPtr response_headers{new TestHeaderMapImpl{{\":status\", \"200\"}}};\n  filter->callbacks_->encodeHeaders(std::move(response_headers), true);\n\n  Event::MockTimer* drain_timer = setUpTimer();\n  EXPECT_CALL(*drain_timer, enableTimer(_, _));\n  idle_timer->invokeCallback();\n\n  EXPECT_CALL(*codec_, goAway());\n  EXPECT_CALL(filter_callbacks_.connection_,\n              close(Network::ConnectionCloseType::FlushWriteAndDelay));\n  EXPECT_CALL(*idle_timer, disableTimer());\n  EXPECT_CALL(*drain_timer, disableTimer());\n  drain_timer->invokeCallback();\n\n  EXPECT_EQ(1U, stats_.named_.downstream_cx_idle_timeout_.value());\n}\n\nTEST_F(HttpConnectionManagerImplTest, IntermediateBufferingEarlyResponse) {\n  InSequence s;\n  setup(false, \"\");\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n    decoder->decodeHeaders(std::move(headers), false);\n\n    Buffer::OwnedImpl fake_data(\"hello\");\n    decoder->decodeData(fake_data, true);\n  }));\n\n  setupFilterChain(2, 0);\n\n  EXPECT_CALL(*decoder_filters_[0], decodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::StopIteration));\n  EXPECT_CALL(*decoder_filters_[0], decodeData(_, true))\n      .WillOnce(Return(FilterDataStatus::StopIterationAndBuffer));\n  EXPECT_CALL(*decoder_filters_[0], decodeComplete());\n\n  // Kick off the incoming data.\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n\n  // Mimic a decoder filter that trapped data and now sends on the headers.\n  EXPECT_CALL(*decoder_filters_[1], decodeHeaders(_, false))\n      .WillOnce(Invoke([&](HeaderMap&, bool) -> FilterHeadersStatus {\n        // Now filter 2 will send a complete response.\n        HeaderMapPtr response_headers{new TestHeaderMapImpl{{\":status\", \"200\"}}};\n        decoder_filters_[1]->callbacks_->encodeHeaders(std::move(response_headers), true);\n        return FilterHeadersStatus::StopIteration;\n      }));\n\n  EXPECT_CALL(response_encoder_, encodeHeaders(_, true));\n  expectOnDestroy();\n\n  // Response is already complete so we drop buffered body data when we continue.\n  EXPECT_CALL(*decoder_filters_[1], decodeData(_, _)).Times(0);\n  decoder_filters_[0]->callbacks_->continueDecoding();\n}\n\nTEST_F(HttpConnectionManagerImplTest, DoubleBuffering) {\n  InSequence s;\n  setup(false, \"\");\n\n  // The data will get moved so we need to have a copy to compare against.\n  Buffer::OwnedImpl fake_data(\"hello\");\n  Buffer::OwnedImpl fake_data_copy(\"hello\");\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n    decoder->decodeHeaders(std::move(headers), false);\n    decoder->decodeData(fake_data, true);\n  }));\n\n  setupFilterChain(3, 0);\n\n  EXPECT_CALL(*decoder_filters_[0], decodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::StopIteration));\n  EXPECT_CALL(*decoder_filters_[0], decodeData(_, true))\n      .WillOnce(Return(FilterDataStatus::StopIterationAndBuffer));\n  EXPECT_CALL(*decoder_filters_[0], decodeComplete());\n\n  // Kick off the incoming data.\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n\n  // Continue iteration and stop and buffer on the 2nd filter.\n  EXPECT_CALL(*decoder_filters_[1], decodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::StopIteration));\n  EXPECT_CALL(*decoder_filters_[1], decodeData(_, true))\n      .WillOnce(Return(FilterDataStatus::StopIterationAndBuffer));\n  EXPECT_CALL(*decoder_filters_[1], decodeComplete());\n  decoder_filters_[0]->callbacks_->continueDecoding();\n\n  // Continue iteration. We expect the 3rd filter to not receive double data but for the buffered\n  // data to have been kept inline as it moves through.\n  EXPECT_CALL(*decoder_filters_[2], decodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::StopIteration));\n  EXPECT_CALL(*decoder_filters_[2], decodeData(BufferEqual(&fake_data_copy), true))\n      .WillOnce(Return(FilterDataStatus::StopIterationNoBuffer));\n  EXPECT_CALL(*decoder_filters_[2], decodeComplete());\n  decoder_filters_[1]->callbacks_->continueDecoding();\n}\n\nTEST_F(HttpConnectionManagerImplTest, ZeroByteDataFiltering) {\n  InSequence s;\n  setup(false, \"\");\n\n  StreamDecoder* decoder = nullptr;\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n    decoder->decodeHeaders(std::move(headers), false);\n  }));\n\n  setupFilterChain(2, 0);\n\n  EXPECT_CALL(*decoder_filters_[0], decodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::StopIteration));\n\n  // Kick off the incoming data.\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n\n  // Continue headers only of filter 1.\n  EXPECT_CALL(*decoder_filters_[1], decodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::StopIteration));\n  decoder_filters_[0]->callbacks_->continueDecoding();\n\n  // Stop zero byte data.\n  EXPECT_CALL(*decoder_filters_[0], decodeData(_, true))\n      .WillOnce(Return(FilterDataStatus::StopIterationAndBuffer));\n  EXPECT_CALL(*decoder_filters_[0], decodeComplete());\n  Buffer::OwnedImpl zero;\n  decoder->decodeData(zero, true);\n\n  // Continue.\n  EXPECT_CALL(*decoder_filters_[1], decodeData(_, true))\n      .WillOnce(Return(FilterDataStatus::StopIterationNoBuffer));\n  EXPECT_CALL(*decoder_filters_[1], decodeComplete());\n  decoder_filters_[0]->callbacks_->continueDecoding();\n}\n\nTEST_F(HttpConnectionManagerImplTest, FilterAddTrailersInTrailersCallback) {\n  InSequence s;\n  setup(false, \"\");\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n    decoder->decodeHeaders(std::move(headers), false);\n\n    Buffer::OwnedImpl fake_data(\"hello\");\n    decoder->decodeData(fake_data, false);\n\n    HeaderMapPtr trailers{new TestHeaderMapImpl{{\"bazzz\", \"bar\"}}};\n    decoder->decodeTrailers(std::move(trailers));\n  }));\n\n  setupFilterChain(2, 2);\n\n  Http::LowerCaseString trailer_key(\"foo\");\n  std::string trailers_data(\"trailers\");\n  EXPECT_CALL(*decoder_filters_[0], decodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::StopIteration));\n  EXPECT_CALL(*decoder_filters_[0], decodeData(_, false))\n      .WillOnce(Return(FilterDataStatus::StopIterationAndBuffer));\n  EXPECT_CALL(*decoder_filters_[0], decodeTrailers(_))\n      .WillOnce(Return(FilterTrailersStatus::Continue));\n  EXPECT_CALL(*decoder_filters_[0], decodeComplete());\n  EXPECT_CALL(*decoder_filters_[1], decodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::StopIteration));\n  EXPECT_CALL(*decoder_filters_[1], decodeData(_, false))\n      .WillOnce(Return(FilterDataStatus::StopIterationAndBuffer));\n  EXPECT_CALL(*decoder_filters_[1], decodeTrailers(_))\n      .WillOnce(Invoke([&](Http::HeaderMap& trailers) -> FilterTrailersStatus {\n        Http::LowerCaseString key(\"foo\");\n        EXPECT_EQ(trailers.get(key), nullptr);\n        return FilterTrailersStatus::Continue;\n      }));\n  EXPECT_CALL(*decoder_filters_[1], decodeComplete());\n\n  // Kick off the incoming data.\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n\n  // set up encodeHeaders expectations\n  EXPECT_CALL(*encoder_filters_[1], encodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(*encoder_filters_[0], encodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(response_encoder_, encodeHeaders(_, false));\n\n  // invoke encodeHeaders\n  decoder_filters_[0]->callbacks_->encodeHeaders(\n      HeaderMapPtr{new TestHeaderMapImpl{{\":status\", \"200\"}}}, false);\n\n  // set up encodeData expectations\n  EXPECT_CALL(*encoder_filters_[1], encodeData(_, false))\n      .WillOnce(Return(FilterDataStatus::Continue));\n  EXPECT_CALL(*encoder_filters_[0], encodeData(_, false))\n      .WillOnce(Return(FilterDataStatus::Continue));\n  EXPECT_CALL(response_encoder_, encodeData(_, false));\n\n  // invoke encodeData\n  Buffer::OwnedImpl response_body(\"response\");\n  decoder_filters_[0]->callbacks_->encodeData(response_body, false);\n  // set up encodeTrailer expectations\n  EXPECT_CALL(*encoder_filters_[1], encodeTrailers(_))\n      .WillOnce(Return(FilterTrailersStatus::Continue));\n  EXPECT_CALL(*encoder_filters_[1], encodeComplete());\n\n  EXPECT_CALL(*encoder_filters_[0], encodeTrailers(_))\n      .WillOnce(Invoke([&](Http::HeaderMap& trailers) -> FilterTrailersStatus {\n        // assert that the trailers set in the previous filter was ignored\n        Http::LowerCaseString key(\"foo\");\n        EXPECT_EQ(trailers.get(key), nullptr);\n        return FilterTrailersStatus::Continue;\n      }));\n  EXPECT_CALL(*encoder_filters_[0], encodeComplete());\n  EXPECT_CALL(response_encoder_, encodeTrailers(_));\n  expectOnDestroy();\n\n  // invoke encodeTrailers\n  decoder_filters_[0]->callbacks_->encodeTrailers(\n      HeaderMapPtr{new TestHeaderMapImpl{{\"some\", \"trailer\"}}});\n}\n\nTEST_F(HttpConnectionManagerImplTest, FilterAddTrailersInDataCallbackNoTrailers) {\n  InSequence s;\n  setup(false, \"\");\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n    decoder->decodeHeaders(std::move(headers), false);\n\n    Buffer::OwnedImpl fake_data(\"hello\");\n    decoder->decodeData(fake_data, true);\n  }));\n\n  setupFilterChain(2, 2);\n\n  std::string trailers_data(\"trailers\");\n  Http::LowerCaseString trailer_key(\"foo\");\n  EXPECT_CALL(*decoder_filters_[0], decodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(*decoder_filters_[1], decodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(*decoder_filters_[0], decodeData(_, true))\n      .WillOnce(InvokeWithoutArgs([&]() -> FilterDataStatus {\n        decoder_filters_[0]->callbacks_->addDecodedTrailers().addCopy(trailer_key, trailers_data);\n        return FilterDataStatus::Continue;\n      }));\n  EXPECT_CALL(*decoder_filters_[0], decodeComplete());\n\n  // ensure that the second decodeData call sees end_stream = false\n  EXPECT_CALL(*decoder_filters_[1], decodeData(_, false))\n      .WillOnce(Return(FilterDataStatus::Continue));\n\n  // since we added trailers, we should see decodeTrailers\n  EXPECT_CALL(*decoder_filters_[1], decodeTrailers(_)).WillOnce(Invoke([&](HeaderMap& trailers) {\n    // ensure that we see the trailers set in decodeData\n    Http::LowerCaseString key(\"foo\");\n    auto t = trailers.get(key);\n    ASSERT(t);\n    EXPECT_EQ(t->value(), trailers_data.c_str());\n    return FilterTrailersStatus::Continue;\n  }));\n  EXPECT_CALL(*decoder_filters_[1], decodeComplete());\n\n  // Kick off the incoming data.\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n\n  // set up encodeHeaders expectations\n  EXPECT_CALL(*encoder_filters_[1], encodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(*encoder_filters_[0], encodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(response_encoder_, encodeHeaders(_, false));\n\n  // invoke encodeHeaders\n  decoder_filters_[0]->callbacks_->encodeHeaders(\n      HeaderMapPtr{new TestHeaderMapImpl{{\":status\", \"200\"}}}, false);\n\n  // set up encodeData expectations\n  EXPECT_CALL(*encoder_filters_[1], encodeData(_, true))\n      .WillOnce(InvokeWithoutArgs([&]() -> FilterDataStatus {\n        encoder_filters_[1]->callbacks_->addEncodedTrailers().addCopy(trailer_key, trailers_data);\n        return FilterDataStatus::Continue;\n      }));\n  EXPECT_CALL(*encoder_filters_[1], encodeComplete());\n  // ensure encodeData calls after setting header sees end_stream = false\n  EXPECT_CALL(*encoder_filters_[0], encodeData(_, false))\n      .WillOnce(Return(FilterDataStatus::Continue));\n\n  EXPECT_CALL(response_encoder_, encodeData(_, false));\n\n  // since we added trailers, we should see encodeTrailer callbacks\n  EXPECT_CALL(*encoder_filters_[0], encodeTrailers(_)).WillOnce(Invoke([&](HeaderMap& trailers) {\n    // ensure that we see the trailers set in decodeData\n    Http::LowerCaseString key(\"foo\");\n    auto t = trailers.get(key);\n    EXPECT_EQ(t->value(), trailers_data.c_str());\n    return FilterTrailersStatus::Continue;\n  }));\n  EXPECT_CALL(*encoder_filters_[0], encodeComplete());\n\n  // Ensure that we call encodeTrailers\n  EXPECT_CALL(response_encoder_, encodeTrailers(_));\n\n  expectOnDestroy();\n  // invoke encodeData\n  Buffer::OwnedImpl response_body(\"response\");\n  decoder_filters_[0]->callbacks_->encodeData(response_body, true);\n}\n\nTEST_F(HttpConnectionManagerImplTest, FilterAddBodyInTrailersCallback) {\n  InSequence s;\n  setup(false, \"\");\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n    decoder->decodeHeaders(std::move(headers), false);\n\n    Buffer::OwnedImpl fake_data(\"hello\");\n    decoder->decodeData(fake_data, false);\n\n    HeaderMapPtr trailers{new TestHeaderMapImpl{{\"foo\", \"bar\"}}};\n    decoder->decodeTrailers(std::move(trailers));\n  }));\n\n  setupFilterChain(2, 2);\n\n  EXPECT_CALL(*decoder_filters_[0], decodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(*decoder_filters_[1], decodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::StopIteration));\n  EXPECT_CALL(*decoder_filters_[0], decodeData(_, false))\n      .WillOnce(Return(FilterDataStatus::Continue));\n  EXPECT_CALL(*decoder_filters_[1], decodeData(_, false))\n      .WillOnce(Return(FilterDataStatus::StopIterationAndBuffer));\n  Buffer::OwnedImpl trailers_data(\"hello\");\n  EXPECT_CALL(*decoder_filters_[0], decodeTrailers(_))\n      .WillOnce(InvokeWithoutArgs([&]() -> FilterTrailersStatus {\n        decoder_filters_[0]->callbacks_->addDecodedData(trailers_data, true);\n        return FilterTrailersStatus::Continue;\n      }));\n  EXPECT_CALL(*decoder_filters_[1], decodeData(Ref(trailers_data), false))\n      .WillOnce(Return(FilterDataStatus::StopIterationAndBuffer));\n  EXPECT_CALL(*decoder_filters_[0], decodeComplete());\n  EXPECT_CALL(*decoder_filters_[1], decodeTrailers(_))\n      .WillOnce(Return(FilterTrailersStatus::StopIteration));\n  EXPECT_CALL(*decoder_filters_[1], decodeComplete());\n\n  // Kick off the incoming data.\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n\n  EXPECT_CALL(*encoder_filters_[1], encodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(*encoder_filters_[0], encodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(response_encoder_, encodeHeaders(_, false));\n\n  decoder_filters_[1]->callbacks_->encodeHeaders(\n      HeaderMapPtr{new TestHeaderMapImpl{{\":status\", \"200\"}}}, false);\n\n  EXPECT_CALL(*encoder_filters_[1], encodeData(_, false))\n      .WillOnce(Return(FilterDataStatus::Continue));\n  EXPECT_CALL(*encoder_filters_[0], encodeData(_, false))\n      .WillOnce(Return(FilterDataStatus::Continue));\n  EXPECT_CALL(response_encoder_, encodeData(_, false));\n\n  Buffer::OwnedImpl response_body(\"response\");\n  decoder_filters_[1]->callbacks_->encodeData(response_body, false);\n  EXPECT_CALL(*encoder_filters_[1], encodeTrailers(_))\n      .WillOnce(InvokeWithoutArgs([&]() -> FilterTrailersStatus {\n        encoder_filters_[1]->callbacks_->addEncodedData(trailers_data, true);\n        return FilterTrailersStatus::Continue;\n      }));\n  EXPECT_CALL(*encoder_filters_[0], encodeData(Ref(trailers_data), false))\n      .WillOnce(Return(FilterDataStatus::Continue));\n  EXPECT_CALL(response_encoder_, encodeData(_, false));\n  EXPECT_CALL(*encoder_filters_[1], encodeComplete());\n  EXPECT_CALL(*encoder_filters_[0], encodeTrailers(_))\n      .WillOnce(Return(FilterTrailersStatus::Continue));\n  EXPECT_CALL(*encoder_filters_[0], encodeComplete());\n  EXPECT_CALL(response_encoder_, encodeTrailers(_));\n  expectOnDestroy();\n\n  decoder_filters_[1]->callbacks_->encodeTrailers(\n      HeaderMapPtr{new TestHeaderMapImpl{{\"some\", \"trailer\"}}});\n}\n\n// Don't send data frames, only headers and trailers.\nTEST_F(HttpConnectionManagerImplTest, FilterAddBodyInTrailersCallback_NoDataFrames) {\n  InSequence s;\n  setup(false, \"\");\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n    decoder->decodeHeaders(std::move(headers), false);\n\n    HeaderMapPtr trailers{new TestHeaderMapImpl{{\"foo\", \"bar\"}}};\n    decoder->decodeTrailers(std::move(trailers));\n  }));\n\n  setupFilterChain(2, 1);\n\n  EXPECT_CALL(*decoder_filters_[0], decodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::StopIteration));\n\n  Buffer::OwnedImpl trailers_data(\"hello\");\n  EXPECT_CALL(*decoder_filters_[0], decodeTrailers(_))\n      .WillOnce(InvokeWithoutArgs([&]() -> FilterTrailersStatus {\n        decoder_filters_[0]->callbacks_->addDecodedData(trailers_data, false);\n        return FilterTrailersStatus::Continue;\n      }));\n  EXPECT_CALL(*decoder_filters_[0], decodeComplete());\n  EXPECT_CALL(*decoder_filters_[1], decodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::StopIteration));\n  EXPECT_CALL(*decoder_filters_[1], decodeData(_, false))\n      .WillOnce(Return(FilterDataStatus::StopIterationAndBuffer));\n  EXPECT_CALL(*decoder_filters_[1], decodeTrailers(_))\n      .WillOnce(Return(FilterTrailersStatus::StopIteration));\n  EXPECT_CALL(*decoder_filters_[1], decodeComplete());\n\n  // Kick off the incoming data.\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n\n  EXPECT_CALL(*encoder_filters_[0], encodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::StopIteration));\n  decoder_filters_[0]->callbacks_->encodeHeaders(\n      HeaderMapPtr{new TestHeaderMapImpl{{\":status\", \"200\"}}}, false);\n\n  EXPECT_CALL(*encoder_filters_[0], encodeTrailers(_))\n      .WillOnce(InvokeWithoutArgs([&]() -> FilterTrailersStatus {\n        encoder_filters_[0]->callbacks_->addEncodedData(trailers_data, false);\n        return FilterTrailersStatus::Continue;\n      }));\n  EXPECT_CALL(*encoder_filters_[0], encodeComplete());\n  EXPECT_CALL(response_encoder_, encodeHeaders(_, false));\n  EXPECT_CALL(response_encoder_, encodeData(_, false));\n  EXPECT_CALL(response_encoder_, encodeTrailers(_));\n  expectOnDestroy();\n\n  decoder_filters_[0]->callbacks_->encodeTrailers(\n      HeaderMapPtr{new TestHeaderMapImpl{{\"some\", \"trailer\"}}});\n}\n\n// Don't send data frames, only headers and trailers.\nTEST_F(HttpConnectionManagerImplTest, FilterAddBodyInTrailersCallback_ContinueAfterCallback) {\n  InSequence s;\n  setup(false, \"\");\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n    decoder->decodeHeaders(std::move(headers), false);\n\n    HeaderMapPtr trailers{new TestHeaderMapImpl{{\"foo\", \"bar\"}}};\n    decoder->decodeTrailers(std::move(trailers));\n  }));\n\n  setupFilterChain(2, 1);\n\n  EXPECT_CALL(*decoder_filters_[0], decodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::StopIteration));\n\n  Buffer::OwnedImpl trailers_data(\"hello\");\n  EXPECT_CALL(*decoder_filters_[0], decodeTrailers(_))\n      .WillOnce(InvokeWithoutArgs([&]() -> FilterTrailersStatus {\n        decoder_filters_[0]->callbacks_->addDecodedData(trailers_data, false);\n        return FilterTrailersStatus::StopIteration;\n      }));\n  EXPECT_CALL(*decoder_filters_[0], decodeComplete());\n\n  // Kick off the incoming data.\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n\n  EXPECT_CALL(*decoder_filters_[1], decodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::StopIteration));\n  EXPECT_CALL(*decoder_filters_[1], decodeData(_, false))\n      .WillOnce(Return(FilterDataStatus::StopIterationAndBuffer));\n  EXPECT_CALL(*decoder_filters_[1], decodeTrailers(_))\n      .WillOnce(Return(FilterTrailersStatus::StopIteration));\n  EXPECT_CALL(*decoder_filters_[1], decodeComplete());\n\n  decoder_filters_[0]->callbacks_->continueDecoding();\n\n  EXPECT_CALL(*encoder_filters_[0], encodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::StopIteration));\n  decoder_filters_[0]->callbacks_->encodeHeaders(\n      HeaderMapPtr{new TestHeaderMapImpl{{\":status\", \"200\"}}}, false);\n\n  EXPECT_CALL(*encoder_filters_[0], encodeTrailers(_))\n      .WillOnce(InvokeWithoutArgs([&]() -> FilterTrailersStatus {\n        encoder_filters_[0]->callbacks_->addEncodedData(trailers_data, false);\n        return FilterTrailersStatus::StopIteration;\n      }));\n  EXPECT_CALL(*encoder_filters_[0], encodeComplete());\n\n  decoder_filters_[0]->callbacks_->encodeTrailers(\n      HeaderMapPtr{new TestHeaderMapImpl{{\"some\", \"trailer\"}}});\n\n  EXPECT_CALL(response_encoder_, encodeHeaders(_, false));\n  EXPECT_CALL(response_encoder_, encodeData(_, false));\n  EXPECT_CALL(response_encoder_, encodeTrailers(_));\n  expectOnDestroy();\n\n  encoder_filters_[0]->callbacks_->continueEncoding();\n}\n\n// Add*Data during the *Data callbacks.\nTEST_F(HttpConnectionManagerImplTest, FilterAddBodyDuringDecodeData) {\n  InSequence s;\n  setup(false, \"\");\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n    decoder->decodeHeaders(std::move(headers), false);\n\n    Buffer::OwnedImpl data1(\"hello\");\n    decoder->decodeData(data1, false);\n\n    Buffer::OwnedImpl data2(\"world\");\n    decoder->decodeData(data2, true);\n  }));\n\n  setupFilterChain(2, 2);\n\n  EXPECT_CALL(*decoder_filters_[0], decodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::StopIteration));\n  EXPECT_CALL(*decoder_filters_[0], decodeData(_, false))\n      .WillOnce(Return(FilterDataStatus::StopIterationAndBuffer));\n  EXPECT_CALL(*decoder_filters_[0], decodeData(_, true))\n      .WillOnce(Invoke([&](Buffer::Instance& data, bool) -> FilterDataStatus {\n        decoder_filters_[0]->callbacks_->addDecodedData(data, true);\n        EXPECT_EQ(decoder_filters_[0]->callbacks_->decodingBuffer()->toString(), \"helloworld\");\n        return FilterDataStatus::Continue;\n      }));\n  EXPECT_CALL(*decoder_filters_[0], decodeComplete());\n  EXPECT_CALL(*decoder_filters_[1], decodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(*decoder_filters_[1], decodeData(_, true))\n      .WillOnce(Return(FilterDataStatus::Continue));\n  EXPECT_CALL(*decoder_filters_[1], decodeComplete());\n\n  // Kick off the incoming data.\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n\n  EXPECT_CALL(*encoder_filters_[1], encodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::StopIteration));\n  EXPECT_CALL(*encoder_filters_[1], encodeData(_, false))\n      .WillOnce(Return(FilterDataStatus::StopIterationAndBuffer));\n  EXPECT_CALL(*encoder_filters_[1], encodeData(_, true))\n      .WillOnce(Invoke([&](Buffer::Instance& data, bool) -> FilterDataStatus {\n        encoder_filters_[1]->callbacks_->addEncodedData(data, true);\n        EXPECT_EQ(encoder_filters_[1]->callbacks_->encodingBuffer()->toString(), \"goodbye\");\n        return FilterDataStatus::Continue;\n      }));\n  EXPECT_CALL(*encoder_filters_[1], encodeComplete());\n  EXPECT_CALL(*encoder_filters_[0], encodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(response_encoder_, encodeHeaders(_, false));\n  EXPECT_CALL(*encoder_filters_[0], encodeData(_, true))\n      .WillOnce(Return(FilterDataStatus::Continue));\n  EXPECT_CALL(*encoder_filters_[0], encodeComplete());\n  EXPECT_CALL(response_encoder_, encodeData(_, true));\n  expectOnDestroy();\n\n  decoder_filters_[1]->callbacks_->encodeHeaders(\n      HeaderMapPtr{new TestHeaderMapImpl{{\":status\", \"200\"}}}, false);\n  Buffer::OwnedImpl data1(\"good\");\n  decoder_filters_[1]->callbacks_->encodeData(data1, false);\n  Buffer::OwnedImpl data2(\"bye\");\n  decoder_filters_[1]->callbacks_->encodeData(data2, true);\n}\n\nTEST_F(HttpConnectionManagerImplTest, FilterAddBodyInline) {\n  InSequence s;\n  setup(false, \"\");\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n    decoder->decodeHeaders(std::move(headers), true);\n  }));\n\n  setupFilterChain(2, 2);\n\n  EXPECT_CALL(*decoder_filters_[0], decodeHeaders(_, true))\n      .WillOnce(InvokeWithoutArgs([&]() -> FilterHeadersStatus {\n        Buffer::OwnedImpl data(\"hello\");\n        decoder_filters_[0]->callbacks_->addDecodedData(data, true);\n        return FilterHeadersStatus::Continue;\n      }));\n  EXPECT_CALL(*decoder_filters_[0], decodeComplete());\n  EXPECT_CALL(*decoder_filters_[1], decodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::StopIteration));\n  EXPECT_CALL(*decoder_filters_[1], decodeData(_, true))\n      .WillOnce(Return(FilterDataStatus::StopIterationAndBuffer));\n  EXPECT_CALL(*decoder_filters_[1], decodeComplete());\n\n  // Kick off the incoming data.\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n\n  EXPECT_CALL(*encoder_filters_[1], encodeHeaders(_, true))\n      .WillOnce(InvokeWithoutArgs([&]() -> FilterHeadersStatus {\n        Buffer::OwnedImpl data(\"hello\");\n        encoder_filters_[1]->callbacks_->addEncodedData(data, true);\n        EXPECT_EQ(5UL, encoder_filters_[0]->callbacks_->encodingBuffer()->length());\n        return FilterHeadersStatus::Continue;\n      }));\n  EXPECT_CALL(*encoder_filters_[1], encodeComplete());\n  EXPECT_CALL(*encoder_filters_[0], encodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(response_encoder_, encodeHeaders(_, false));\n  EXPECT_CALL(*encoder_filters_[0], encodeData(_, true))\n      .WillOnce(Return(FilterDataStatus::Continue));\n  EXPECT_CALL(*encoder_filters_[0], encodeComplete());\n  EXPECT_CALL(response_encoder_, encodeData(_, true));\n  expectOnDestroy();\n\n  decoder_filters_[1]->callbacks_->encodeHeaders(\n      HeaderMapPtr{new TestHeaderMapImpl{{\":status\", \"200\"}}}, true);\n}\n\nTEST_F(HttpConnectionManagerImplTest, FilterClearRouteCache) {\n  setup(false, \"\");\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n    decoder->decodeHeaders(std::move(headers), true);\n  }));\n\n  setupFilterChain(3, 2);\n  const std::string fake_cluster1_name = \"fake_cluster1\";\n  const std::string fake_cluster2_name = \"fake_cluster2\";\n\n  std::shared_ptr<Upstream::MockThreadLocalCluster> fake_cluster1 =\n      std::make_shared<NiceMock<Upstream::MockThreadLocalCluster>>();\n  EXPECT_CALL(cluster_manager_, get(_))\n      .WillOnce(Return(fake_cluster1.get()))\n      .WillOnce(Return(nullptr));\n\n  std::shared_ptr<Router::MockRoute> route1 = std::make_shared<NiceMock<Router::MockRoute>>();\n  EXPECT_CALL(route1->route_entry_, clusterName()).WillRepeatedly(ReturnRef(fake_cluster1_name));\n  std::shared_ptr<Router::MockRoute> route2 = std::make_shared<NiceMock<Router::MockRoute>>();\n  EXPECT_CALL(route2->route_entry_, clusterName()).WillRepeatedly(ReturnRef(fake_cluster2_name));\n\n  EXPECT_CALL(*route_config_provider_.route_config_, route(_, _))\n      .WillOnce(Return(route1))\n      .WillOnce(Return(route2))\n      .WillOnce(Return(nullptr));\n\n  EXPECT_CALL(*decoder_filters_[0], decodeHeaders(_, true))\n      .WillOnce(InvokeWithoutArgs([&]() -> FilterHeadersStatus {\n        EXPECT_EQ(route1, decoder_filters_[0]->callbacks_->route());\n        EXPECT_EQ(route1->routeEntry(), decoder_filters_[0]->callbacks_->streamInfo().routeEntry());\n        EXPECT_EQ(fake_cluster1->info(), decoder_filters_[0]->callbacks_->clusterInfo());\n        decoder_filters_[0]->callbacks_->clearRouteCache();\n        return FilterHeadersStatus::Continue;\n      }));\n  EXPECT_CALL(*decoder_filters_[0], decodeComplete());\n  EXPECT_CALL(*decoder_filters_[1], decodeHeaders(_, true))\n      .WillOnce(InvokeWithoutArgs([&]() -> FilterHeadersStatus {\n        EXPECT_EQ(route2, decoder_filters_[1]->callbacks_->route());\n        EXPECT_EQ(route2->routeEntry(), decoder_filters_[1]->callbacks_->streamInfo().routeEntry());\n        // RDS & CDS consistency problem: route2 points to fake_cluster2, which doesn't exist.\n        EXPECT_EQ(nullptr, decoder_filters_[1]->callbacks_->clusterInfo());\n        decoder_filters_[1]->callbacks_->clearRouteCache();\n        return FilterHeadersStatus::Continue;\n      }));\n  EXPECT_CALL(*decoder_filters_[1], decodeComplete());\n  EXPECT_CALL(*decoder_filters_[2], decodeHeaders(_, true))\n      .WillOnce(InvokeWithoutArgs([&]() -> FilterHeadersStatus {\n        EXPECT_EQ(nullptr, decoder_filters_[2]->callbacks_->clusterInfo());\n        EXPECT_EQ(nullptr, decoder_filters_[2]->callbacks_->route());\n        EXPECT_EQ(nullptr, decoder_filters_[2]->callbacks_->streamInfo().routeEntry());\n        return FilterHeadersStatus::StopIteration;\n      }));\n  EXPECT_CALL(*decoder_filters_[2], decodeComplete());\n\n  // Kick off the incoming data.\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n}\n\nTEST_F(HttpConnectionManagerImplTest, UpstreamWatermarkCallbacks) {\n  setup(false, \"\");\n  setUpEncoderAndDecoder(false, false);\n  sendRequestHeadersAndData();\n\n  // Mimic the upstream connection backing up. The router would call\n  // onDecoderFilterAboveWriteBufferHighWatermark which should readDisable the stream and increment\n  // stats.\n  EXPECT_CALL(response_encoder_, getStream()).WillOnce(ReturnRef(stream_));\n  EXPECT_CALL(stream_, readDisable(true));\n  ASSERT(decoder_filters_[0]->callbacks_ != nullptr);\n  decoder_filters_[0]->callbacks_->onDecoderFilterAboveWriteBufferHighWatermark();\n  EXPECT_EQ(1U, stats_.named_.downstream_flow_control_paused_reading_total_.value());\n\n  // Resume the flow of data. When the router buffer drains it calls\n  // onDecoderFilterBelowWriteBufferLowWatermark which should re-enable reads on the stream.\n  EXPECT_CALL(response_encoder_, getStream()).WillOnce(ReturnRef(stream_));\n  EXPECT_CALL(stream_, readDisable(false));\n  ASSERT(decoder_filters_[0]->callbacks_ != nullptr);\n  decoder_filters_[0]->callbacks_->onDecoderFilterBelowWriteBufferLowWatermark();\n  EXPECT_EQ(1U, stats_.named_.downstream_flow_control_resumed_reading_total_.value());\n\n  // Backup upstream once again.\n  EXPECT_CALL(response_encoder_, getStream()).WillOnce(ReturnRef(stream_));\n  EXPECT_CALL(stream_, readDisable(true));\n  ASSERT(decoder_filters_[0]->callbacks_ != nullptr);\n  decoder_filters_[0]->callbacks_->onDecoderFilterAboveWriteBufferHighWatermark();\n  EXPECT_EQ(2U, stats_.named_.downstream_flow_control_paused_reading_total_.value());\n\n  // Send a full response.\n  EXPECT_CALL(*encoder_filters_[0], encodeHeaders(_, true));\n  EXPECT_CALL(*encoder_filters_[0], encodeComplete());\n  EXPECT_CALL(*encoder_filters_[1], encodeHeaders(_, true));\n  EXPECT_CALL(*encoder_filters_[1], encodeComplete());\n  EXPECT_CALL(response_encoder_, encodeHeaders(_, true));\n  // When the stream ends, the manager should check to see if the connection is\n  // read disabled, and keep calling readDisable(false) until readEnabled()\n  // returns true.\n  EXPECT_CALL(filter_callbacks_.connection_, readEnabled())\n      .Times(2)\n      .WillOnce(Return(false))\n      .WillRepeatedly(Return(true));\n  EXPECT_CALL(filter_callbacks_.connection_, readDisable(false));\n  expectOnDestroy();\n  decoder_filters_[1]->callbacks_->encodeHeaders(\n      HeaderMapPtr{new TestHeaderMapImpl{{\":status\", \"200\"}}}, true);\n}\n\nTEST_F(HttpConnectionManagerImplTest, UnderlyingConnectionWatermarksPassedOnWithLazyCreation) {\n  setup(false, \"\");\n\n  // Make sure codec_ is created.\n  EXPECT_CALL(*codec_, dispatch(_));\n  Buffer::OwnedImpl fake_input(\"\");\n  conn_manager_->onData(fake_input, false);\n\n  // Mark the connection manger as backed up before the stream is created.\n  ASSERT_EQ(decoder_filters_.size(), 0);\n  EXPECT_CALL(*codec_, onUnderlyingConnectionAboveWriteBufferHighWatermark());\n  conn_manager_->onAboveWriteBufferHighWatermark();\n\n  // Create the stream. Defer the creation of the filter chain by not sending\n  // complete headers.\n  StreamDecoder* decoder;\n  {\n    setUpBufferLimits();\n    EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n      decoder = &conn_manager_->newStream(response_encoder_);\n      // Call the high buffer callbacks as the codecs do.\n      stream_callbacks_->onAboveWriteBufferHighWatermark();\n    }));\n\n    // Send fake data to kick off newStream being created.\n    Buffer::OwnedImpl fake_input2(\"asdf\");\n    conn_manager_->onData(fake_input2, false);\n  }\n\n  // Now set up the filter chain by sending full headers. The filters should be\n  // immediately appraised that the low watermark is in effect.\n  {\n    setupFilterChain(2, 2);\n    EXPECT_CALL(filter_callbacks_.connection_, aboveHighWatermark()).Times(0);\n    EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n      HeaderMapPtr headers{\n          new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n      decoder->decodeHeaders(std::move(headers), true);\n    }));\n    EXPECT_CALL(*decoder_filters_[0], decodeHeaders(_, true))\n        .WillOnce(InvokeWithoutArgs([&]() -> FilterHeadersStatus {\n          Buffer::OwnedImpl data(\"hello\");\n          decoder_filters_[0]->callbacks_->addDecodedData(data, true);\n          return FilterHeadersStatus::Continue;\n        }));\n    EXPECT_CALL(*decoder_filters_[0], decodeComplete());\n    sendRequestHeadersAndData();\n    ASSERT_GE(decoder_filters_.size(), 1);\n    MockDownstreamWatermarkCallbacks callbacks;\n    EXPECT_CALL(callbacks, onAboveWriteBufferHighWatermark());\n    decoder_filters_[0]->callbacks_->addDownstreamWatermarkCallbacks(callbacks);\n\n    // Ensures that when new callbacks are registered they get invoked immediately\n    // and the already-registered callbacks do not.\n    MockDownstreamWatermarkCallbacks callbacks2;\n    EXPECT_CALL(callbacks2, onAboveWriteBufferHighWatermark());\n    decoder_filters_[0]->callbacks_->addDownstreamWatermarkCallbacks(callbacks2);\n  }\n}\n\nTEST_F(HttpConnectionManagerImplTest, UnderlyingConnectionWatermarksUnwoundWithLazyCreation) {\n  setup(false, \"\");\n\n  // Make sure codec_ is created.\n  EXPECT_CALL(*codec_, dispatch(_));\n  Buffer::OwnedImpl fake_input(\"\");\n  conn_manager_->onData(fake_input, false);\n\n  // Mark the connection manger as backed up before the stream is created.\n  ASSERT_EQ(decoder_filters_.size(), 0);\n  EXPECT_CALL(*codec_, onUnderlyingConnectionAboveWriteBufferHighWatermark());\n  conn_manager_->onAboveWriteBufferHighWatermark();\n\n  // Create the stream. Defer the creation of the filter chain by not sending\n  // complete headers.\n  StreamDecoder* decoder;\n  {\n    setUpBufferLimits();\n    EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n      decoder = &conn_manager_->newStream(response_encoder_);\n      // Call the high buffer callbacks as the codecs do.\n      stream_callbacks_->onAboveWriteBufferHighWatermark();\n    }));\n\n    // Send fake data to kick off newStream being created.\n    Buffer::OwnedImpl fake_input2(\"asdf\");\n    conn_manager_->onData(fake_input2, false);\n  }\n\n  // Now before the filter chain is created, fire the low watermark callbacks\n  // and ensure it is passed down to the stream.\n  ASSERT(stream_callbacks_ != nullptr);\n  EXPECT_CALL(*codec_, onUnderlyingConnectionBelowWriteBufferLowWatermark())\n      .WillOnce(Invoke([&]() -> void { stream_callbacks_->onBelowWriteBufferLowWatermark(); }));\n  conn_manager_->onBelowWriteBufferLowWatermark();\n\n  // Now set up the filter chain by sending full headers. The filters should\n  // not get any watermark callbacks.\n  {\n    setupFilterChain(2, 2);\n    EXPECT_CALL(filter_callbacks_.connection_, aboveHighWatermark()).Times(0);\n    EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n      HeaderMapPtr headers{\n          new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n      decoder->decodeHeaders(std::move(headers), true);\n    }));\n    EXPECT_CALL(*decoder_filters_[0], decodeHeaders(_, true))\n        .WillOnce(InvokeWithoutArgs([&]() -> FilterHeadersStatus {\n          Buffer::OwnedImpl data(\"hello\");\n          decoder_filters_[0]->callbacks_->addDecodedData(data, true);\n          return FilterHeadersStatus::Continue;\n        }));\n    EXPECT_CALL(*decoder_filters_[0], decodeComplete());\n    sendRequestHeadersAndData();\n    ASSERT_GE(decoder_filters_.size(), 1);\n    MockDownstreamWatermarkCallbacks callbacks;\n    EXPECT_CALL(callbacks, onAboveWriteBufferHighWatermark()).Times(0);\n    EXPECT_CALL(callbacks, onBelowWriteBufferLowWatermark()).Times(0);\n    decoder_filters_[0]->callbacks_->addDownstreamWatermarkCallbacks(callbacks);\n  }\n}\n\nTEST_F(HttpConnectionManagerImplTest, AlterFilterWatermarkLimits) {\n  initial_buffer_limit_ = 100;\n  setup(false, \"\");\n  setUpEncoderAndDecoder(false, false);\n  sendRequestHeadersAndData();\n\n  // Check initial limits.\n  EXPECT_EQ(initial_buffer_limit_, decoder_filters_[0]->callbacks_->decoderBufferLimit());\n  EXPECT_EQ(initial_buffer_limit_, encoder_filters_[0]->callbacks_->encoderBufferLimit());\n\n  // Check lowering the limits.\n  decoder_filters_[0]->callbacks_->setDecoderBufferLimit(initial_buffer_limit_ - 1);\n  EXPECT_EQ(initial_buffer_limit_ - 1, decoder_filters_[0]->callbacks_->decoderBufferLimit());\n\n  // Check raising the limits.\n  decoder_filters_[0]->callbacks_->setDecoderBufferLimit(initial_buffer_limit_ + 1);\n  EXPECT_EQ(initial_buffer_limit_ + 1, decoder_filters_[0]->callbacks_->decoderBufferLimit());\n  EXPECT_EQ(initial_buffer_limit_ + 1, encoder_filters_[0]->callbacks_->encoderBufferLimit());\n\n  // Verify turning off buffer limits works.\n  decoder_filters_[0]->callbacks_->setDecoderBufferLimit(0);\n  EXPECT_EQ(0, decoder_filters_[0]->callbacks_->decoderBufferLimit());\n\n  // Once the limits are turned off can be turned on again.\n  decoder_filters_[0]->callbacks_->setDecoderBufferLimit(100);\n  EXPECT_EQ(100, decoder_filters_[0]->callbacks_->decoderBufferLimit());\n}\n\nTEST_F(HttpConnectionManagerImplTest, HitFilterWatermarkLimits) {\n  initial_buffer_limit_ = 1;\n  streaming_filter_ = true;\n  setup(false, \"\");\n  setUpEncoderAndDecoder(false, false);\n\n  // The filter is a streaming filter. Sending 4 bytes should hit the\n  // watermark limit and disable reads on the stream.\n  EXPECT_CALL(stream_, readDisable(true));\n  sendRequestHeadersAndData();\n\n  // Change the limit so the buffered data is below the new watermark. The\n  // stream should be read-enabled\n  EXPECT_CALL(stream_, readDisable(false));\n  int buffer_len = decoder_filters_[0]->callbacks_->decodingBuffer()->length();\n  decoder_filters_[0]->callbacks_->setDecoderBufferLimit((buffer_len + 1) * 2);\n\n  // Start the response\n  HeaderMapPtr response_headers{new TestHeaderMapImpl{{\":status\", \"200\"}}};\n  EXPECT_CALL(*encoder_filters_[1], encodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::StopIteration));\n  decoder_filters_[0]->callbacks_->encodeHeaders(std::move(response_headers), false);\n\n  MockDownstreamWatermarkCallbacks callbacks;\n  decoder_filters_[0]->callbacks_->addDownstreamWatermarkCallbacks(callbacks);\n  MockDownstreamWatermarkCallbacks callbacks2;\n  decoder_filters_[0]->callbacks_->addDownstreamWatermarkCallbacks(callbacks2);\n\n  // Now overload the buffer with response data. The downstream watermark\n  // callbacks should be called.\n  EXPECT_CALL(callbacks, onAboveWriteBufferHighWatermark());\n  EXPECT_CALL(callbacks2, onAboveWriteBufferHighWatermark());\n  Buffer::OwnedImpl fake_response(\"A long enough string to go over watermarks\");\n  EXPECT_CALL(*encoder_filters_[1], encodeData(_, false))\n      .WillOnce(Return(FilterDataStatus::StopIterationAndWatermark));\n  decoder_filters_[0]->callbacks_->encodeData(fake_response, false);\n\n  // unregister callbacks2\n  decoder_filters_[0]->callbacks_->removeDownstreamWatermarkCallbacks(callbacks2);\n\n  // Change the limit so the buffered data is below the new watermark.\n  buffer_len = encoder_filters_[1]->callbacks_->encodingBuffer()->length();\n  EXPECT_CALL(callbacks, onBelowWriteBufferLowWatermark());\n  EXPECT_CALL(callbacks2, onBelowWriteBufferLowWatermark()).Times(0);\n  encoder_filters_[1]->callbacks_->setEncoderBufferLimit((buffer_len + 1) * 2);\n}\n\nTEST_F(HttpConnectionManagerImplTest, HitRequestBufferLimits) {\n  initial_buffer_limit_ = 10;\n  streaming_filter_ = false;\n  setup(false, \"\");\n  setUpEncoderAndDecoder(false, false);\n  sendRequestHeadersAndData();\n\n  // Set the filter to be a buffering filter. Sending any data will hit the\n  // watermark limit and result in a 413 being sent to the user.\n  Http::TestHeaderMapImpl response_headers{\n      {\":status\", \"413\"}, {\"content-length\", \"17\"}, {\"content-type\", \"text/plain\"}};\n  EXPECT_CALL(*encoder_filters_[1], encodeHeaders(HeaderMapEqualRef(&response_headers), false))\n      .WillOnce(Return(FilterHeadersStatus::StopIteration));\n  EXPECT_CALL(*encoder_filters_[1], encodeData(_, true))\n      .WillOnce(Return(FilterDataStatus::StopIterationAndWatermark));\n  EXPECT_CALL(*encoder_filters_[1], encodeComplete());\n  Buffer::OwnedImpl data(\"A longer string\");\n  decoder_filters_[0]->callbacks_->addDecodedData(data, false);\n  const auto rc_details = encoder_filters_[1]->callbacks_->streamInfo().responseCodeDetails();\n  EXPECT_EQ(\"request_payload_too_large\", rc_details.value());\n}\n\n// Return 413 from an intermediate filter and make sure we don't continue the filter chain.\nTEST_F(HttpConnectionManagerImplTest, HitRequestBufferLimitsIntermediateFilter) {\n  InSequence s;\n  initial_buffer_limit_ = 10;\n  setup(false, \"\");\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n    decoder->decodeHeaders(std::move(headers), false);\n\n    Buffer::OwnedImpl fake_data(\"hello\");\n    decoder->decodeData(fake_data, false);\n\n    Buffer::OwnedImpl fake_data2(\"world world\");\n    decoder->decodeData(fake_data2, true);\n  }));\n\n  setUpBufferLimits();\n  setupFilterChain(2, 1);\n\n  EXPECT_CALL(*decoder_filters_[0], decodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::StopIteration));\n  EXPECT_CALL(*decoder_filters_[0], decodeData(_, false))\n      .WillOnce(Return(FilterDataStatus::StopIterationAndBuffer));\n  EXPECT_CALL(*decoder_filters_[0], decodeData(_, true))\n      .WillOnce(Return(FilterDataStatus::Continue));\n  EXPECT_CALL(*decoder_filters_[0], decodeComplete());\n  Http::TestHeaderMapImpl response_headers{\n      {\":status\", \"413\"}, {\"content-length\", \"17\"}, {\"content-type\", \"text/plain\"}};\n  EXPECT_CALL(*encoder_filters_[0], encodeHeaders(HeaderMapEqualRef(&response_headers), false))\n      .WillOnce(Return(FilterHeadersStatus::StopIteration));\n  EXPECT_CALL(*encoder_filters_[0], encodeData(_, true))\n      .WillOnce(Return(FilterDataStatus::StopIterationAndWatermark));\n  EXPECT_CALL(*encoder_filters_[0], encodeComplete());\n\n  // Kick off the incoming data.\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n}\n\nTEST_F(HttpConnectionManagerImplTest, HitResponseBufferLimitsBeforeHeaders) {\n  initial_buffer_limit_ = 10;\n  setup(false, \"\");\n  setUpEncoderAndDecoder(false, false);\n  sendRequestHeadersAndData();\n\n  // Start the response without processing the request headers through all\n  // filters.\n  HeaderMapPtr response_headers{new TestHeaderMapImpl{{\":status\", \"200\"}}};\n  EXPECT_CALL(*encoder_filters_[1], encodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::StopIteration));\n  decoder_filters_[0]->callbacks_->encodeHeaders(std::move(response_headers), false);\n\n  // Now overload the buffer with response data. The filter returns\n  // StopIterationAndBuffer, which will trigger an early response.\n\n  expectOnDestroy();\n  Http::TestHeaderMapImpl expected_response_headers{\n      {\":status\", \"500\"}, {\"content-length\", \"21\"}, {\"content-type\", \"text/plain\"}};\n  Buffer::OwnedImpl fake_response(\"A long enough string to go over watermarks\");\n  // Fake response starts doing through the filter.\n  EXPECT_CALL(*encoder_filters_[1], encodeData(_, false))\n      .WillOnce(Return(FilterDataStatus::StopIterationAndBuffer));\n  std::string response_body;\n  // The 500 goes directly to the encoder.\n  EXPECT_CALL(response_encoder_,\n              encodeHeaders(HeaderMapEqualRef(&expected_response_headers), false));\n  EXPECT_CALL(response_encoder_, encodeData(_, true)).WillOnce(AddBufferToString(&response_body));\n  decoder_filters_[0]->callbacks_->encodeData(fake_response, false);\n  EXPECT_EQ(\"Internal Server Error\", response_body);\n\n  EXPECT_EQ(1U, stats_.named_.rs_too_large_.value());\n}\n\nTEST_F(HttpConnectionManagerImplTest, HitResponseBufferLimitsAfterHeaders) {\n  initial_buffer_limit_ = 10;\n  setup(false, \"\");\n  setUpEncoderAndDecoder(false, false);\n  sendRequestHeadersAndData();\n\n  // Start the response, and make sure the request headers are fully processed.\n  HeaderMapPtr response_headers{new TestHeaderMapImpl{{\":status\", \"200\"}}};\n  EXPECT_CALL(*encoder_filters_[1], encodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(*encoder_filters_[0], encodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(response_encoder_, encodeHeaders(_, false));\n  decoder_filters_[0]->callbacks_->encodeHeaders(std::move(response_headers), false);\n\n  // Now overload the buffer with response data. The filter returns\n  // StopIterationAndBuffer, which will trigger an early reset.\n  const std::string data = \"A long enough string to go over watermarks\";\n  Buffer::OwnedImpl fake_response(data);\n  InSequence s;\n  EXPECT_CALL(*encoder_filters_[1], encodeData(_, false))\n      .WillOnce(Return(FilterDataStatus::StopIterationAndBuffer));\n  EXPECT_CALL(stream_, resetStream(_));\n  decoder_filters_[0]->callbacks_->encodeData(fake_response, false);\n\n  EXPECT_EQ(1U, stats_.named_.rs_too_large_.value());\n}\n\nTEST_F(HttpConnectionManagerImplTest, FilterHeadReply) {\n  InSequence s;\n  setup(false, \"\");\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance& data) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"HEAD\"}}};\n    decoder->decodeHeaders(std::move(headers), true);\n    data.drain(4);\n  }));\n\n  setupFilterChain(1, 1);\n\n  EXPECT_CALL(*decoder_filters_[0], decodeHeaders(_, true))\n      .WillOnce(InvokeWithoutArgs([&]() -> FilterHeadersStatus {\n        decoder_filters_[0]->callbacks_->sendLocalReply(Code::BadRequest, \"Bad request\", nullptr,\n                                                        absl::nullopt, \"\");\n        return FilterHeadersStatus::Continue;\n      }));\n\n  EXPECT_CALL(*encoder_filters_[0], encodeHeaders(_, true))\n      .WillOnce(Invoke([&](HeaderMap& headers, bool) -> FilterHeadersStatus {\n        EXPECT_EQ(\"11\", headers.ContentLength()->value().getStringView());\n        return FilterHeadersStatus::Continue;\n      }));\n  EXPECT_CALL(*encoder_filters_[0], encodeComplete());\n  EXPECT_CALL(response_encoder_, encodeHeaders(_, true));\n  expectOnDestroy();\n  EXPECT_CALL(*decoder_filters_[0], decodeComplete());\n  // Kick off the incoming data.\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n}\n\n// Verify that if an encoded stream has been ended, but gets stopped by a filter chain, we end\n// up resetting the stream in the doEndStream() path (e.g., via filter reset due to timeout, etc.),\n// we emit a reset to the codec.\nTEST_F(HttpConnectionManagerImplTest, ResetWithStoppedFilter) {\n  InSequence s;\n  setup(false, \"\");\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance& data) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n    decoder->decodeHeaders(std::move(headers), true);\n    data.drain(4);\n  }));\n\n  setupFilterChain(1, 1);\n\n  EXPECT_CALL(*decoder_filters_[0], decodeHeaders(_, true))\n      .WillOnce(InvokeWithoutArgs([&]() -> FilterHeadersStatus {\n        decoder_filters_[0]->callbacks_->sendLocalReply(Code::BadRequest, \"Bad request\", nullptr,\n                                                        absl::nullopt, \"\");\n        return FilterHeadersStatus::Continue;\n      }));\n\n  EXPECT_CALL(*encoder_filters_[0], encodeHeaders(_, false))\n      .WillOnce(Invoke([&](HeaderMap& headers, bool) -> FilterHeadersStatus {\n        EXPECT_EQ(\"11\", headers.ContentLength()->value().getStringView());\n        return FilterHeadersStatus::Continue;\n      }));\n  EXPECT_CALL(response_encoder_, encodeHeaders(_, false));\n  EXPECT_CALL(*encoder_filters_[0], encodeData(_, true))\n      .WillOnce(Invoke([&](Buffer::Instance&, bool) -> FilterDataStatus {\n        return FilterDataStatus::StopIterationAndBuffer;\n      }));\n\n  EXPECT_CALL(*encoder_filters_[0], encodeComplete());\n  EXPECT_CALL(*decoder_filters_[0], decodeComplete());\n\n  // Kick off the incoming data.\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n\n  EXPECT_CALL(response_encoder_.stream_, resetStream(_));\n  expectOnDestroy();\n  encoder_filters_[0]->callbacks_->resetStream();\n}\n\nTEST_F(HttpConnectionManagerImplTest, FilterContinueAndEndStreamHeaders) {\n  InSequence s;\n  setup(false, \"\");\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    auto headers = std::make_unique<TestHeaderMapImpl>(\n        std::initializer_list<std::pair<std::string, std::string>>(\n            {{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}));\n    decoder->decodeHeaders(std::move(headers), false);\n  }));\n\n  setupFilterChain(2, 2);\n\n  EXPECT_CALL(*decoder_filters_[0], decodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::ContinueAndEndStream));\n  EXPECT_CALL(*decoder_filters_[1], decodeHeaders(_, true))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(*decoder_filters_[1], decodeComplete());\n\n  // Kick off the incoming data.\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, true);\n\n  EXPECT_CALL(*encoder_filters_[1], encodeHeaders(_, true))\n      .WillOnce(Return(FilterHeadersStatus::ContinueAndEndStream));\n  EXPECT_CALL(*encoder_filters_[1], encodeComplete());\n  EXPECT_CALL(*encoder_filters_[0], encodeHeaders(_, true))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(*encoder_filters_[0], encodeComplete());\n  EXPECT_CALL(response_encoder_, encodeHeaders(_, true));\n\n  expectOnDestroy();\n\n  decoder_filters_[1]->callbacks_->encodeHeaders(makeHeaderMap({{\":status\", \"200\"}}), true);\n\n  Buffer::OwnedImpl response_body(\"response\");\n  decoder_filters_[1]->callbacks_->encodeData(response_body, true);\n}\n\nTEST_F(HttpConnectionManagerImplTest, FilterContinueAndEndStreamData) {\n  InSequence s;\n  setup(false, \"\");\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    auto headers = makeHeaderMap({{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}});\n    decoder->decodeHeaders(std::move(headers), false);\n\n    Buffer::OwnedImpl fake_data(\"hello\");\n    decoder->decodeData(fake_data, true);\n  }));\n\n  setupFilterChain(2, 2);\n\n  EXPECT_CALL(*decoder_filters_[0], decodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::ContinueAndEndStream));\n  EXPECT_CALL(*decoder_filters_[1], decodeHeaders(_, true))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(*decoder_filters_[1], decodeComplete());\n\n  // Kick off the incoming data.\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n\n  EXPECT_CALL(*encoder_filters_[1], encodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::ContinueAndEndStream));\n  EXPECT_CALL(*encoder_filters_[0], encodeHeaders(_, true))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(*encoder_filters_[0], encodeComplete());\n  EXPECT_CALL(response_encoder_, encodeHeaders(_, true));\n\n  expectOnDestroy();\n\n  decoder_filters_[1]->callbacks_->encodeHeaders(makeHeaderMap({{\":status\", \"200\"}}), false);\n\n  Buffer::OwnedImpl response_body(\"response\");\n  decoder_filters_[1]->callbacks_->encodeData(response_body, true);\n}\n\nTEST_F(HttpConnectionManagerImplTest, FilterContinueAndEndStreamTrailers) {\n  InSequence s;\n  setup(false, \"\");\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    auto headers = makeHeaderMap({{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}});\n    decoder->decodeHeaders(std::move(headers), false);\n\n    Buffer::OwnedImpl fake_data(\"hello\");\n    decoder->decodeData(fake_data, false);\n\n    auto trailers = makeHeaderMap({{\"foo\", \"bar\"}});\n    decoder->decodeTrailers(std::move(trailers));\n  }));\n\n  setupFilterChain(2, 2);\n\n  EXPECT_CALL(*decoder_filters_[0], decodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::ContinueAndEndStream));\n  EXPECT_CALL(*decoder_filters_[1], decodeHeaders(_, true))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(*decoder_filters_[1], decodeComplete());\n\n  // Kick off the incoming data.\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n\n  EXPECT_CALL(*encoder_filters_[1], encodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::ContinueAndEndStream));\n  EXPECT_CALL(*encoder_filters_[0], encodeHeaders(_, true))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(*encoder_filters_[0], encodeComplete());\n  EXPECT_CALL(response_encoder_, encodeHeaders(_, true));\n\n  expectOnDestroy();\n\n  decoder_filters_[1]->callbacks_->encodeHeaders(makeHeaderMap({{\":status\", \"200\"}}), false);\n\n  Buffer::OwnedImpl response_body(\"response\");\n  decoder_filters_[1]->callbacks_->encodeData(response_body, false);\n\n  auto response_trailers = makeHeaderMap({{\"x-trailer\", \"1\"}});\n  decoder_filters_[1]->callbacks_->encodeTrailers(std::move(response_trailers));\n}\n\nTEST_F(HttpConnectionManagerImplTest, FilterAddBodyContinuation) {\n  InSequence s;\n  setup(false, \"\");\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n    decoder->decodeHeaders(std::move(headers), true);\n  }));\n\n  setupFilterChain(2, 2);\n\n  EXPECT_CALL(*decoder_filters_[0], decodeHeaders(_, true))\n      .WillOnce(Return(FilterHeadersStatus::StopIteration));\n  EXPECT_CALL(*decoder_filters_[0], decodeComplete());\n\n  // Kick off the incoming data.\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n\n  EXPECT_CALL(*decoder_filters_[1], decodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(*decoder_filters_[1], decodeData(_, true))\n      .WillOnce(Return(FilterDataStatus::Continue));\n  EXPECT_CALL(*decoder_filters_[1], decodeComplete());\n\n  Buffer::OwnedImpl data(\"hello\");\n  decoder_filters_[0]->callbacks_->addDecodedData(data, true);\n  decoder_filters_[0]->callbacks_->continueDecoding();\n\n  EXPECT_CALL(*encoder_filters_[1], encodeHeaders(_, true))\n      .WillOnce(Return(FilterHeadersStatus::StopIteration));\n  EXPECT_CALL(*encoder_filters_[1], encodeComplete());\n\n  decoder_filters_[1]->callbacks_->encodeHeaders(\n      HeaderMapPtr{new TestHeaderMapImpl{{\":status\", \"200\"}}}, true);\n\n  EXPECT_CALL(*encoder_filters_[0], encodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(response_encoder_, encodeHeaders(_, false));\n  EXPECT_CALL(*encoder_filters_[0], encodeData(_, true))\n      .WillOnce(Return(FilterDataStatus::Continue));\n  EXPECT_CALL(*encoder_filters_[0], encodeComplete());\n  EXPECT_CALL(response_encoder_, encodeData(_, true));\n  expectOnDestroy();\n\n  Buffer::OwnedImpl data2(\"hello\");\n  encoder_filters_[1]->callbacks_->addEncodedData(data2, true);\n  encoder_filters_[1]->callbacks_->continueEncoding();\n}\n\n// This test verifies proper sequences of decodeData() and encodeData() are called\n// when all filers return \"CONTINUE\" in following case:\n//\n// 3 decode filters:\n//\n//   filter0->decodeHeaders(_, true)\n//     return CONTINUE\n//   filter1->decodeHeaders(_, true)\n//     filter1->addDecodeData()\n//     return CONTINUE\n//   filter2->decodeHeaders(_, false)\n//     return CONTINUE\n//   filter2->decodeData(_, true)\n//     return CONTINUE\n//\n//   filter0->decodeData(, true) is NOT called.\n//   filter1->decodeData(, true) is NOT called.\n//\n// 3 encode filters:\n//\n//   filter2->encodeHeaders(_, true)\n//     return CONTINUE\n//   filter1->encodeHeaders(_, true)\n//     filter1->addEncodeData()\n//     return CONTINUE\n//   filter0->decodeHeaders(_, false)\n//     return CONTINUE\n//   filter0->decodeData(_, true)\n//     return CONTINUE\n//\n//   filter2->encodeData(, true) is NOT called.\n//   filter1->encodeData(, true) is NOT called.\n//\nTEST_F(HttpConnectionManagerImplTest, AddDataWithAllContinue) {\n  InSequence s;\n  setup(false, \"\");\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n    decoder->decodeHeaders(std::move(headers), true);\n  }));\n\n  setupFilterChain(3, 3);\n\n  EXPECT_CALL(*decoder_filters_[0], decodeHeaders(_, true))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(*decoder_filters_[0], decodeComplete());\n\n  EXPECT_CALL(*decoder_filters_[1], decodeHeaders(_, true))\n      .WillOnce(InvokeWithoutArgs([&]() -> FilterHeadersStatus {\n        Buffer::OwnedImpl data2(\"hello\");\n        decoder_filters_[1]->callbacks_->addDecodedData(data2, true);\n        return FilterHeadersStatus::Continue;\n      }));\n  EXPECT_CALL(*decoder_filters_[1], decodeComplete());\n\n  EXPECT_CALL(*decoder_filters_[2], decodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(*decoder_filters_[2], decodeData(_, true))\n      .WillOnce(Return(FilterDataStatus::Continue));\n  EXPECT_CALL(*decoder_filters_[2], decodeComplete());\n\n  EXPECT_CALL(*decoder_filters_[0], decodeData(_, true)).Times(0);\n  EXPECT_CALL(*decoder_filters_[1], decodeData(_, true)).Times(0);\n\n  // Kick off the incoming data.\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, true);\n\n  // For encode direction\n  EXPECT_CALL(*encoder_filters_[2], encodeHeaders(_, true))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(*encoder_filters_[2], encodeComplete());\n\n  EXPECT_CALL(*encoder_filters_[1], encodeHeaders(_, true))\n      .WillOnce(InvokeWithoutArgs([&]() -> FilterHeadersStatus {\n        Buffer::OwnedImpl data2(\"goodbyte\");\n        encoder_filters_[1]->callbacks_->addEncodedData(data2, true);\n        return FilterHeadersStatus::Continue;\n      }));\n  EXPECT_CALL(*encoder_filters_[1], encodeComplete());\n\n  EXPECT_CALL(*encoder_filters_[0], encodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(response_encoder_, encodeHeaders(_, false));\n  EXPECT_CALL(*encoder_filters_[0], encodeData(_, true))\n      .WillOnce(Return(FilterDataStatus::Continue));\n  EXPECT_CALL(*encoder_filters_[0], encodeComplete());\n  EXPECT_CALL(response_encoder_, encodeData(_, true));\n  expectOnDestroy();\n\n  EXPECT_CALL(*encoder_filters_[2], encodeData(_, true)).Times(0);\n  EXPECT_CALL(*encoder_filters_[1], encodeData(_, true)).Times(0);\n\n  decoder_filters_[2]->callbacks_->encodeHeaders(\n      HeaderMapPtr{new TestHeaderMapImpl{{\":status\", \"200\"}}}, true);\n}\n\n// This test verifies proper sequences of decodeData() and encodeData() are called\n// when the first filer is \"stopped\" and \"continue\" in following case:\n//\n// 3 decode filters:\n//\n//   filter0->decodeHeaders(_, true)\n//     return STOP\n//   filter0->continueDecoding()\n//   filter1->decodeHeaders(_, true)\n//     filter1->addDecodeData()\n//     return CONTINUE\n//   filter2->decodeHeaders(_, false)\n//     return CONTINUE\n//   filter2->decodeData(_, true)\n//     return CONTINUE\n//\n//   filter0->decodeData(, true) is NOT called.\n//   filter1->decodeData(, true) is NOT called.\n//\n// 3 encode filters:\n//\n//   filter2->encodeHeaders(_, true)\n//     return STOP\n//   filter2->continueEncoding()\n//   filter1->encodeHeaders(_, true)\n//     filter1->addEncodeData()\n//     return CONTINUE\n//   filter0->decodeHeaders(_, false)\n//     return CONTINUE\n//   filter0->decodeData(_, true)\n//     return CONTINUE\n//\n//   filter2->encodeData(, true) is NOT called.\n//   filter1->encodeData(, true) is NOT called.\n//\nTEST_F(HttpConnectionManagerImplTest, AddDataWithStopAndContinue) {\n  InSequence s;\n  setup(false, \"\");\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n    decoder->decodeHeaders(std::move(headers), true);\n  }));\n\n  setupFilterChain(3, 3);\n\n  EXPECT_CALL(*decoder_filters_[0], decodeHeaders(_, true))\n      .WillOnce(Return(FilterHeadersStatus::StopIteration));\n  EXPECT_CALL(*decoder_filters_[0], decodeComplete());\n\n  // Kick off the incoming data.\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, true);\n\n  EXPECT_CALL(*decoder_filters_[1], decodeHeaders(_, true))\n      .WillOnce(InvokeWithoutArgs([&]() -> FilterHeadersStatus {\n        Buffer::OwnedImpl data2(\"hello\");\n        decoder_filters_[1]->callbacks_->addDecodedData(data2, true);\n        return FilterHeadersStatus::Continue;\n      }));\n  EXPECT_CALL(*decoder_filters_[1], decodeComplete());\n\n  EXPECT_CALL(*decoder_filters_[2], decodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  // This fail, it is called twice.\n  EXPECT_CALL(*decoder_filters_[2], decodeData(_, true))\n      .WillOnce(Return(FilterDataStatus::Continue));\n  EXPECT_CALL(*decoder_filters_[2], decodeComplete());\n\n  EXPECT_CALL(*decoder_filters_[0], decodeData(_, true)).Times(0);\n  // This fail, it is called once\n  EXPECT_CALL(*decoder_filters_[1], decodeData(_, true)).Times(0);\n\n  decoder_filters_[0]->callbacks_->continueDecoding();\n\n  // For encode direction\n  EXPECT_CALL(*encoder_filters_[2], encodeHeaders(_, true))\n      .WillOnce(Return(FilterHeadersStatus::StopIteration));\n  EXPECT_CALL(*encoder_filters_[2], encodeComplete());\n\n  decoder_filters_[2]->callbacks_->encodeHeaders(\n      HeaderMapPtr{new TestHeaderMapImpl{{\":status\", \"200\"}}}, true);\n\n  EXPECT_CALL(*encoder_filters_[1], encodeHeaders(_, true))\n      .WillOnce(InvokeWithoutArgs([&]() -> FilterHeadersStatus {\n        Buffer::OwnedImpl data2(\"goodbyte\");\n        encoder_filters_[1]->callbacks_->addEncodedData(data2, true);\n        return FilterHeadersStatus::Continue;\n      }));\n  EXPECT_CALL(*encoder_filters_[1], encodeComplete());\n\n  EXPECT_CALL(*encoder_filters_[0], encodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(response_encoder_, encodeHeaders(_, false));\n\n  EXPECT_CALL(*encoder_filters_[0], encodeData(_, true))\n      .WillOnce(Return(FilterDataStatus::Continue));\n  EXPECT_CALL(*encoder_filters_[0], encodeComplete());\n  EXPECT_CALL(response_encoder_, encodeData(_, true));\n  expectOnDestroy();\n\n  EXPECT_CALL(*encoder_filters_[2], encodeData(_, true)).Times(0);\n  EXPECT_CALL(*encoder_filters_[1], encodeData(_, true)).Times(0);\n\n  encoder_filters_[2]->callbacks_->continueEncoding();\n}\n\n// Use filter direct decode/encodeData() calls without trailers.\nTEST_F(HttpConnectionManagerImplTest, FilterDirectDecodeEncodeDataNoTrailers) {\n  InSequence s;\n  setup(false, \"\");\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n    decoder->decodeHeaders(std::move(headers), false);\n\n    Buffer::OwnedImpl fake_data(\"hello\");\n    decoder->decodeData(fake_data, true);\n  }));\n\n  EXPECT_CALL(*route_config_provider_.route_config_, route(_, _));\n  setupFilterChain(2, 2);\n\n  EXPECT_CALL(*decoder_filters_[0], decodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(*decoder_filters_[1], decodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::StopIteration));\n\n  Buffer::OwnedImpl decode_buffer;\n  EXPECT_CALL(*decoder_filters_[0], decodeData(_, true))\n      .WillOnce(Invoke([&](Buffer::Instance& data, bool) {\n        decode_buffer.move(data);\n        return FilterDataStatus::StopIterationNoBuffer;\n      }));\n  EXPECT_CALL(*decoder_filters_[0], decodeComplete());\n\n  // Kick off the incoming data.\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n\n  Buffer::OwnedImpl decoded_data_to_forward;\n  decoded_data_to_forward.move(decode_buffer, 2);\n  EXPECT_CALL(*decoder_filters_[1], decodeData(BufferStringEqual(\"he\"), false))\n      .WillOnce(Return(FilterDataStatus::StopIterationNoBuffer));\n  decoder_filters_[0]->callbacks_->injectDecodedDataToFilterChain(decoded_data_to_forward, false);\n\n  EXPECT_CALL(*decoder_filters_[1], decodeData(BufferStringEqual(\"llo\"), true))\n      .WillOnce(Return(FilterDataStatus::StopIterationNoBuffer));\n  EXPECT_CALL(*decoder_filters_[1], decodeComplete());\n  decoder_filters_[0]->callbacks_->injectDecodedDataToFilterChain(decode_buffer, true);\n\n  // Response path.\n  EXPECT_CALL(*encoder_filters_[1], encodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(*encoder_filters_[0], encodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(response_encoder_, encodeHeaders(_, false));\n\n  Buffer::OwnedImpl encoder_buffer;\n  EXPECT_CALL(*encoder_filters_[1], encodeData(_, true))\n      .WillOnce(Invoke([&](Buffer::Instance& data, bool) {\n        encoder_buffer.move(data);\n        return FilterDataStatus::StopIterationNoBuffer;\n      }));\n  EXPECT_CALL(*encoder_filters_[1], encodeComplete());\n\n  decoder_filters_[1]->callbacks_->encodeHeaders(\n      HeaderMapPtr{new TestHeaderMapImpl{{\":status\", \"200\"}}}, false);\n  Buffer::OwnedImpl response_body(\"response\");\n  decoder_filters_[1]->callbacks_->encodeData(response_body, true);\n\n  Buffer::OwnedImpl encoded_data_to_forward;\n  encoded_data_to_forward.move(encoder_buffer, 3);\n  EXPECT_CALL(*encoder_filters_[0], encodeData(BufferStringEqual(\"res\"), false));\n  EXPECT_CALL(response_encoder_, encodeData(_, false));\n  encoder_filters_[1]->callbacks_->injectEncodedDataToFilterChain(encoded_data_to_forward, false);\n\n  EXPECT_CALL(*encoder_filters_[0], encodeData(BufferStringEqual(\"ponse\"), true));\n  EXPECT_CALL(*encoder_filters_[0], encodeComplete());\n  EXPECT_CALL(response_encoder_, encodeData(_, true));\n  expectOnDestroy();\n  encoder_filters_[1]->callbacks_->injectEncodedDataToFilterChain(encoder_buffer, true);\n}\n\n// Use filter direct decode/encodeData() calls with trailers.\nTEST_F(HttpConnectionManagerImplTest, FilterDirectDecodeEncodeDataTrailers) {\n  InSequence s;\n  setup(false, \"\");\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n    decoder->decodeHeaders(std::move(headers), false);\n\n    Buffer::OwnedImpl fake_data(\"hello\");\n    decoder->decodeData(fake_data, false);\n\n    HeaderMapPtr trailers{new TestHeaderMapImpl{{\"foo\", \"bar\"}}};\n    decoder->decodeTrailers(std::move(trailers));\n  }));\n\n  EXPECT_CALL(*route_config_provider_.route_config_, route(_, _));\n  setupFilterChain(2, 2);\n\n  EXPECT_CALL(*decoder_filters_[0], decodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(*decoder_filters_[1], decodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::StopIteration));\n\n  Buffer::OwnedImpl decode_buffer;\n  EXPECT_CALL(*decoder_filters_[0], decodeData(_, false))\n      .WillOnce(Invoke([&](Buffer::Instance& data, bool) {\n        decode_buffer.move(data);\n        return FilterDataStatus::StopIterationNoBuffer;\n      }));\n  EXPECT_CALL(*decoder_filters_[0], decodeTrailers(_))\n      .WillOnce(Return(FilterTrailersStatus::StopIteration));\n  EXPECT_CALL(*decoder_filters_[0], decodeComplete());\n\n  // Kick off the incoming data.\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n\n  Buffer::OwnedImpl decoded_data_to_forward;\n  decoded_data_to_forward.move(decode_buffer, 2);\n  EXPECT_CALL(*decoder_filters_[1], decodeData(BufferStringEqual(\"he\"), false))\n      .WillOnce(Return(FilterDataStatus::StopIterationNoBuffer));\n  decoder_filters_[0]->callbacks_->injectDecodedDataToFilterChain(decoded_data_to_forward, false);\n\n  EXPECT_CALL(*decoder_filters_[1], decodeData(BufferStringEqual(\"llo\"), false))\n      .WillOnce(Return(FilterDataStatus::StopIterationNoBuffer));\n  decoder_filters_[0]->callbacks_->injectDecodedDataToFilterChain(decode_buffer, false);\n\n  EXPECT_CALL(*decoder_filters_[1], decodeTrailers(_));\n  EXPECT_CALL(*decoder_filters_[1], decodeComplete());\n  decoder_filters_[0]->callbacks_->continueDecoding();\n\n  // Response path.\n  EXPECT_CALL(*encoder_filters_[1], encodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(*encoder_filters_[0], encodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(response_encoder_, encodeHeaders(_, false));\n\n  Buffer::OwnedImpl encoder_buffer;\n  EXPECT_CALL(*encoder_filters_[1], encodeData(_, false))\n      .WillOnce(Invoke([&](Buffer::Instance& data, bool) {\n        encoder_buffer.move(data);\n        return FilterDataStatus::StopIterationNoBuffer;\n      }));\n  EXPECT_CALL(*encoder_filters_[1], encodeTrailers(_))\n      .WillOnce(Return(FilterTrailersStatus::StopIteration));\n  EXPECT_CALL(*encoder_filters_[1], encodeComplete());\n\n  decoder_filters_[1]->callbacks_->encodeHeaders(\n      HeaderMapPtr{new TestHeaderMapImpl{{\":status\", \"200\"}}}, false);\n  Buffer::OwnedImpl response_body(\"response\");\n  decoder_filters_[1]->callbacks_->encodeData(response_body, false);\n  decoder_filters_[1]->callbacks_->encodeTrailers(\n      HeaderMapPtr{new TestHeaderMapImpl{{\":status\", \"200\"}}});\n\n  Buffer::OwnedImpl encoded_data_to_forward;\n  encoded_data_to_forward.move(encoder_buffer, 3);\n  EXPECT_CALL(*encoder_filters_[0], encodeData(BufferStringEqual(\"res\"), false));\n  EXPECT_CALL(response_encoder_, encodeData(_, false));\n  encoder_filters_[1]->callbacks_->injectEncodedDataToFilterChain(encoded_data_to_forward, false);\n\n  EXPECT_CALL(*encoder_filters_[0], encodeData(BufferStringEqual(\"ponse\"), false));\n  EXPECT_CALL(response_encoder_, encodeData(_, false));\n  encoder_filters_[1]->callbacks_->injectEncodedDataToFilterChain(encoder_buffer, false);\n\n  EXPECT_CALL(*encoder_filters_[0], encodeTrailers(_));\n  EXPECT_CALL(*encoder_filters_[0], encodeComplete());\n  EXPECT_CALL(response_encoder_, encodeTrailers(_));\n  expectOnDestroy();\n  encoder_filters_[1]->callbacks_->continueEncoding();\n}\n\nTEST_F(HttpConnectionManagerImplTest, MultipleFilters) {\n  InSequence s;\n  setup(false, \"\");\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n    decoder->decodeHeaders(std::move(headers), false);\n\n    Buffer::OwnedImpl fake_data(\"hello\");\n    decoder->decodeData(fake_data, false);\n\n    Buffer::OwnedImpl fake_data2(\"world\");\n    decoder->decodeData(fake_data2, true);\n  }));\n\n  EXPECT_CALL(*route_config_provider_.route_config_, route(_, _));\n  setupFilterChain(3, 2);\n\n  EXPECT_CALL(*decoder_filters_[0], decodeHeaders(_, false))\n      .WillOnce(InvokeWithoutArgs([&]() -> FilterHeadersStatus {\n        EXPECT_EQ(route_config_provider_.route_config_->route_,\n                  decoder_filters_[0]->callbacks_->route());\n        EXPECT_EQ(ssl_connection_.get(),\n                  decoder_filters_[0]->callbacks_->connection()->ssl().get());\n        return FilterHeadersStatus::StopIteration;\n      }));\n\n  EXPECT_CALL(*decoder_filters_[0], decodeData(_, false))\n      .WillOnce(Return(FilterDataStatus::StopIterationAndBuffer));\n  EXPECT_CALL(*decoder_filters_[0], decodeData(_, true))\n      .WillOnce(Return(FilterDataStatus::StopIterationAndBuffer));\n  EXPECT_CALL(*decoder_filters_[0], decodeComplete());\n\n  // Kick off the incoming data.\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n\n  // Mimic a decoder filter that trapped data and now sends it on, since the data was buffered\n  // by the first filter, we expect to get it in 1 decodeData() call.\n  EXPECT_CALL(*decoder_filters_[1], decodeHeaders(_, false))\n      .WillOnce(InvokeWithoutArgs([&]() -> FilterHeadersStatus {\n        EXPECT_EQ(route_config_provider_.route_config_->route_,\n                  decoder_filters_[1]->callbacks_->route());\n        EXPECT_EQ(ssl_connection_.get(),\n                  decoder_filters_[1]->callbacks_->connection()->ssl().get());\n        return FilterHeadersStatus::StopIteration;\n      }));\n  EXPECT_CALL(*decoder_filters_[1], decodeData(_, true))\n      .WillOnce(Return(FilterDataStatus::Continue));\n  EXPECT_CALL(*decoder_filters_[1], decodeComplete());\n  EXPECT_CALL(*decoder_filters_[2], decodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::StopIteration));\n  EXPECT_CALL(*decoder_filters_[2], decodeData(_, true))\n      .WillOnce(Return(FilterDataStatus::StopIterationNoBuffer));\n  EXPECT_CALL(*decoder_filters_[2], decodeComplete());\n  decoder_filters_[0]->callbacks_->continueDecoding();\n\n  // Now start encoding and mimic trapping in the encoding filter.\n  EXPECT_CALL(*encoder_filters_[1], encodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::StopIteration));\n  EXPECT_CALL(*encoder_filters_[1], encodeData(_, false))\n      .WillOnce(Return(FilterDataStatus::StopIterationAndBuffer));\n  EXPECT_CALL(*encoder_filters_[1], encodeTrailers(_))\n      .WillOnce(Return(FilterTrailersStatus::StopIteration));\n  EXPECT_CALL(*encoder_filters_[1], encodeComplete());\n  EXPECT_EQ(ssl_connection_.get(), encoder_filters_[1]->callbacks_->connection()->ssl().get());\n  decoder_filters_[2]->callbacks_->encodeHeaders(\n      HeaderMapPtr{new TestHeaderMapImpl{{\":status\", \"200\"}}}, false);\n  Buffer::OwnedImpl response_body(\"response\");\n  decoder_filters_[2]->callbacks_->encodeData(response_body, false);\n  decoder_filters_[2]->callbacks_->encodeTrailers(\n      HeaderMapPtr{new TestHeaderMapImpl{{\"some\", \"trailer\"}}});\n  EXPECT_EQ(ssl_connection_.get(), decoder_filters_[2]->callbacks_->connection()->ssl().get());\n\n  // Now finish the encode.\n  EXPECT_CALL(*encoder_filters_[0], encodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(response_encoder_, encodeHeaders(_, false));\n  EXPECT_CALL(*encoder_filters_[0], encodeData(_, false))\n      .WillOnce(Return(FilterDataStatus::Continue));\n  EXPECT_CALL(response_encoder_, encodeData(_, false));\n  EXPECT_CALL(*encoder_filters_[0], encodeTrailers(_))\n      .WillOnce(Return(FilterTrailersStatus::Continue));\n  EXPECT_CALL(*encoder_filters_[0], encodeComplete());\n  EXPECT_CALL(response_encoder_, encodeTrailers(_));\n  expectOnDestroy();\n  encoder_filters_[1]->callbacks_->continueEncoding();\n\n  EXPECT_EQ(ssl_connection_.get(), encoder_filters_[0]->callbacks_->connection()->ssl().get());\n}\n\nTEST(HttpConnectionManagerTracingStatsTest, verifyTracingStats) {\n  Stats::IsolatedStoreImpl stats;\n  ConnectionManagerTracingStats tracing_stats{CONN_MAN_TRACING_STATS(POOL_COUNTER(stats))};\n\n  EXPECT_THROW(\n      ConnectionManagerImpl::chargeTracingStats(Tracing::Reason::HealthCheck, tracing_stats),\n      std::invalid_argument);\n\n  ConnectionManagerImpl::chargeTracingStats(Tracing::Reason::ClientForced, tracing_stats);\n  EXPECT_EQ(1UL, tracing_stats.client_enabled_.value());\n\n  ConnectionManagerImpl::chargeTracingStats(Tracing::Reason::NotTraceableRequestId, tracing_stats);\n  EXPECT_EQ(1UL, tracing_stats.not_traceable_.value());\n}\n\nTEST_F(HttpConnectionManagerImplTest, NoNewStreamWhenOverloaded) {\n  setup(false, \"\");\n\n  overload_manager_.overload_state_.setState(\n      Server::OverloadActionNames::get().StopAcceptingRequests,\n      Server::OverloadActionState::Active);\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillRepeatedly(Invoke([&](Buffer::Instance&) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n    decoder->decodeHeaders(std::move(headers), false);\n  }));\n\n  // 503 direct response when overloaded.\n  EXPECT_CALL(response_encoder_, encodeHeaders(_, false))\n      .WillOnce(Invoke([](const HeaderMap& headers, bool) -> void {\n        EXPECT_EQ(\"503\", headers.Status()->value().getStringView());\n      }));\n  std::string response_body;\n  EXPECT_CALL(response_encoder_, encodeData(_, true)).WillOnce(AddBufferToString(&response_body));\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n\n  EXPECT_EQ(\"envoy overloaded\", response_body);\n  EXPECT_EQ(1U, stats_.named_.downstream_rq_overload_close_.value());\n}\n\nTEST_F(HttpConnectionManagerImplTest, DisableKeepAliveWhenOverloaded) {\n  setup(false, \"\");\n\n  overload_manager_.overload_state_.setState(\n      Server::OverloadActionNames::get().DisableHttpKeepAlive, Server::OverloadActionState::Active);\n\n  std::shared_ptr<MockStreamDecoderFilter> filter(new NiceMock<MockStreamDecoderFilter>());\n  EXPECT_CALL(filter_factory_, createFilterChain(_))\n      .WillOnce(Invoke([&](FilterChainFactoryCallbacks& callbacks) -> void {\n        callbacks.addStreamDecoderFilter(StreamDecoderFilterSharedPtr{filter});\n      }));\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillRepeatedly(Invoke([&](Buffer::Instance& data) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{new TestHeaderMapImpl{\n        {\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}, {\"connection\", \"keep-alive\"}}};\n    decoder->decodeHeaders(std::move(headers), true);\n\n    HeaderMapPtr response_headers{new TestHeaderMapImpl{{\":status\", \"200\"}}};\n    filter->callbacks_->encodeHeaders(std::move(response_headers), true);\n\n    data.drain(4);\n  }));\n\n  EXPECT_CALL(response_encoder_, encodeHeaders(_, true))\n      .WillOnce(Invoke([](const HeaderMap& headers, bool) -> void {\n        EXPECT_EQ(\"close\", headers.Connection()->value().getStringView());\n      }));\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n  EXPECT_EQ(1U, stats_.named_.downstream_cx_overload_disable_keepalive_.value());\n}\n\nTEST_F(HttpConnectionManagerImplTest, OverlyLongHeadersRejected) {\n  setup(false, \"\");\n\n  std::string response_code;\n  std::string response_body;\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n    headers->addCopy(LowerCaseString(\"Foo\"), std::string(60 * 1024, 'a'));\n\n    EXPECT_CALL(response_encoder_, encodeHeaders(_, true))\n        .WillOnce(Invoke([&response_code](const HeaderMap& headers, bool) -> void {\n          response_code = std::string(headers.Status()->value().getStringView());\n        }));\n    decoder->decodeHeaders(std::move(headers), true);\n    conn_manager_->newStream(response_encoder_);\n  }));\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false); // kick off request\n\n  EXPECT_EQ(\"431\", response_code);\n  EXPECT_EQ(\"\", response_body);\n}\n\nTEST_F(HttpConnectionManagerImplTest, OverlyLongHeadersAcceptedIfConfigured) {\n  max_request_headers_kb_ = 62;\n  setup(false, \"\");\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n    headers->addCopy(LowerCaseString(\"Foo\"), std::string(60 * 1024, 'a'));\n\n    EXPECT_CALL(response_encoder_, encodeHeaders(_, _)).Times(0);\n    decoder->decodeHeaders(std::move(headers), true);\n    conn_manager_->newStream(response_encoder_);\n  }));\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false); // kick off request\n}\n\nTEST_F(HttpConnectionManagerImplTest, TestStopAllIterationAndBufferOnDecodingPathFirstFilter) {\n  setup(false, \"envoy-custom-server\", false);\n  setUpEncoderAndDecoder(true, true);\n\n  // Kick off the incoming data.\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n\n  // Verify that once the decoder_filters_[0]'s contineDecoding() is called, decoder_filters_[1]'s\n  // decodeHeaders() is called, and both filters receive data and trailers consequently.\n  EXPECT_CALL(*decoder_filters_[1], decodeHeaders(_, _))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(*decoder_filters_[0], decodeData(_, _)).WillOnce(Return(FilterDataStatus::Continue));\n  EXPECT_CALL(*decoder_filters_[1], decodeData(_, _)).WillOnce(Return(FilterDataStatus::Continue));\n  EXPECT_CALL(*decoder_filters_[0], decodeTrailers(_))\n      .WillOnce(Return(FilterTrailersStatus::Continue));\n  EXPECT_CALL(*decoder_filters_[1], decodeTrailers(_))\n      .WillOnce(Return(FilterTrailersStatus::Continue));\n  EXPECT_CALL(*decoder_filters_[1], decodeComplete());\n  decoder_filters_[0]->callbacks_->continueDecoding();\n}\n\nTEST_F(HttpConnectionManagerImplTest, TestStopAllIterationAndBufferOnDecodingPathSecondFilter) {\n  setup(false, \"envoy-custom-server\", false);\n  setUpEncoderAndDecoder(true, false);\n\n  // Verify headers go through both filters, and data and trailers go through the first filter only.\n  EXPECT_CALL(*decoder_filters_[1], decodeHeaders(_, _))\n      .WillOnce(Return(FilterHeadersStatus::StopAllIterationAndBuffer));\n  EXPECT_CALL(*decoder_filters_[0], decodeData(_, _)).WillOnce(Return(FilterDataStatus::Continue));\n  EXPECT_CALL(*decoder_filters_[0], decodeTrailers(_))\n      .WillOnce(Return(FilterTrailersStatus::Continue));\n  // Kick off the incoming data.\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n\n  // Verify that once the decoder_filters_[1]'s contineDecoding() is called, both data and trailers\n  // go through the second filter.\n  EXPECT_CALL(*decoder_filters_[1], decodeData(_, _)).WillOnce(Return(FilterDataStatus::Continue));\n  EXPECT_CALL(*decoder_filters_[1], decodeTrailers(_))\n      .WillOnce(Return(FilterTrailersStatus::Continue));\n  EXPECT_CALL(*decoder_filters_[1], decodeComplete());\n  decoder_filters_[1]->callbacks_->continueDecoding();\n}\n\nTEST_F(HttpConnectionManagerImplTest, TestStopAllIterationAndBufferOnEncodingPath) {\n  setup(false, \"envoy-custom-server\", false);\n  setUpEncoderAndDecoder(false, false);\n  sendRequestHeadersAndData();\n\n  // encoder_filters_[1] is the first filter in the chain.\n  EXPECT_CALL(*encoder_filters_[1], encodeHeaders(_, false))\n      .WillOnce(Invoke([&](HeaderMap&, bool) -> FilterHeadersStatus {\n        return FilterHeadersStatus::StopAllIterationAndBuffer;\n      }));\n  HeaderMapPtr response_headers{new TestHeaderMapImpl{{\":status\", \"200\"}}};\n  decoder_filters_[0]->callbacks_->encodeHeaders(std::move(response_headers), false);\n\n  // Invoke encodeData while all iteration is stopped and make sure the filters do not have\n  // encodeData called.\n  EXPECT_CALL(*encoder_filters_[0], encodeData(_, _)).Times(0);\n  EXPECT_CALL(*encoder_filters_[1], encodeData(_, _)).Times(0);\n  Buffer::OwnedImpl response_body(\"response\");\n  decoder_filters_[0]->callbacks_->encodeData(response_body, false);\n  decoder_filters_[0]->callbacks_->encodeTrailers(\n      HeaderMapPtr{new TestHeaderMapImpl{{\"some\", \"trailer\"}}});\n\n  // Verify that once encoder_filters_[1]'s continueEncoding() is called, encoder_filters_[0]'s\n  // encodeHeaders() is called, and both filters receive data and trailers consequently.\n  EXPECT_CALL(*encoder_filters_[0], encodeHeaders(_, _))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(response_encoder_, encodeHeaders(_, false));\n  EXPECT_CALL(*encoder_filters_[1], encodeData(_, _)).WillOnce(Return(FilterDataStatus::Continue));\n  EXPECT_CALL(*encoder_filters_[0], encodeData(_, _)).WillOnce(Return(FilterDataStatus::Continue));\n  EXPECT_CALL(response_encoder_, encodeData(_, _));\n  EXPECT_CALL(*encoder_filters_[1], encodeTrailers(_))\n      .WillOnce(Return(FilterTrailersStatus::Continue));\n  EXPECT_CALL(*encoder_filters_[0], encodeTrailers(_))\n      .WillOnce(Return(FilterTrailersStatus::Continue));\n  EXPECT_CALL(response_encoder_, encodeTrailers(_));\n  EXPECT_CALL(*encoder_filters_[0], encodeComplete());\n  EXPECT_CALL(*encoder_filters_[1], encodeComplete());\n  expectOnDestroy();\n  encoder_filters_[1]->callbacks_->continueEncoding();\n}\n\nTEST_F(HttpConnectionManagerImplTest, DisableKeepAliveWhenDraining) {\n  setup(false, \"\");\n\n  EXPECT_CALL(drain_close_, drainClose()).WillOnce(Return(true));\n\n  std::shared_ptr<MockStreamDecoderFilter> filter(new NiceMock<MockStreamDecoderFilter>());\n  EXPECT_CALL(filter_factory_, createFilterChain(_))\n      .WillOnce(Invoke([&](FilterChainFactoryCallbacks& callbacks) -> void {\n        callbacks.addStreamDecoderFilter(StreamDecoderFilterSharedPtr{filter});\n      }));\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillRepeatedly(Invoke([&](Buffer::Instance& data) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{new TestHeaderMapImpl{\n        {\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}, {\"connection\", \"keep-alive\"}}};\n    decoder->decodeHeaders(std::move(headers), true);\n\n    HeaderMapPtr response_headers{new TestHeaderMapImpl{{\":status\", \"200\"}}};\n    filter->callbacks_->encodeHeaders(std::move(response_headers), true);\n\n    data.drain(4);\n  }));\n\n  EXPECT_CALL(response_encoder_, encodeHeaders(_, true))\n      .WillOnce(Invoke([](const HeaderMap& headers, bool) -> void {\n        EXPECT_EQ(\"close\", headers.Connection()->value().getStringView());\n      }));\n\n  Buffer::OwnedImpl fake_input;\n  conn_manager_->onData(fake_input, false);\n}\n\nTEST_F(HttpConnectionManagerImplTest, TestSessionTrace) {\n  setup(false, \"\");\n\n  // Set up the codec.\n  EXPECT_CALL(*codec_, dispatch(_)).WillRepeatedly(Invoke([&](Buffer::Instance& data) -> void {\n    data.drain(4);\n  }));\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n\n  setupFilterChain(1, 1);\n\n  // Create a new stream\n  StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n\n  // Send headers to that stream, and verify we both set and clear the tracked object.\n  {\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"POST\"}}};\n    EXPECT_CALL(filter_callbacks_.connection_.dispatcher_, setTrackedObject(_))\n        .Times(2)\n        .WillOnce(Invoke([](const ScopeTrackedObject* object) -> const ScopeTrackedObject* {\n          ASSERT(object != nullptr); // On the first call, this should be the active stream.\n          std::stringstream out;\n          object->dumpState(out);\n          std::string state = out.str();\n          EXPECT_THAT(state, testing::HasSubstr(\"request_headers_: null\"));\n          EXPECT_THAT(state, testing::HasSubstr(\"protocol_: 1\"));\n          return nullptr;\n        }))\n        .WillRepeatedly(Return(nullptr));\n    EXPECT_CALL(*decoder_filters_[0], decodeHeaders(_, false))\n        .WillOnce(Invoke([](HeaderMap&, bool) -> FilterHeadersStatus {\n          return FilterHeadersStatus::StopIteration;\n        }));\n    decoder->decodeHeaders(std::move(headers), false);\n  }\n\n  // Send trailers to that stream, and verify by this point headers are in logged state.\n  {\n    HeaderMapPtr trailers{new TestHeaderMapImpl{{\"foo\", \"bar\"}}};\n    EXPECT_CALL(filter_callbacks_.connection_.dispatcher_, setTrackedObject(_))\n        .Times(2)\n        .WillOnce(Invoke([](const ScopeTrackedObject* object) -> const ScopeTrackedObject* {\n          ASSERT(object != nullptr); // On the first call, this should be the active stream.\n          std::stringstream out;\n          object->dumpState(out);\n          std::string state = out.str();\n          EXPECT_THAT(state, testing::HasSubstr(\"request_headers_: \\n\"));\n          EXPECT_THAT(state, testing::HasSubstr(\"':authority', 'host'\\n\"));\n          EXPECT_THAT(state, testing::HasSubstr(\"protocol_: 1\"));\n          return nullptr;\n        }))\n        .WillRepeatedly(Return(nullptr));\n    EXPECT_CALL(*decoder_filters_[0], decodeComplete());\n    EXPECT_CALL(*decoder_filters_[0], decodeTrailers(_))\n        .WillOnce(Return(FilterTrailersStatus::StopIteration));\n    decoder->decodeTrailers(std::move(trailers));\n  }\n}\n\n// SRDS no scope found.\nTEST_F(HttpConnectionManagerImplTest, TestSrdsRouteNotFound) {\n  setup(false, \"\", true, true);\n  setupFilterChain(1, 0); // Recreate the chain for second stream.\n\n  EXPECT_CALL(*static_cast<const Router::MockScopedConfig*>(\n                  scopedRouteConfigProvider()->config<Router::ScopedConfig>().get()),\n              getRouteConfig(_))\n      .Times(2)\n      .WillRepeatedly(Return(nullptr));\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance& data) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":method\", \"GET\"}, {\":path\", \"/foo\"}}};\n    decoder->decodeHeaders(std::move(headers), true);\n    data.drain(4);\n  }));\n\n  EXPECT_CALL(*decoder_filters_[0], decodeHeaders(_, true))\n      .WillOnce(InvokeWithoutArgs([&]() -> FilterHeadersStatus {\n        EXPECT_EQ(nullptr, decoder_filters_[0]->callbacks_->route());\n        return FilterHeadersStatus::StopIteration;\n      }));\n  EXPECT_CALL(*decoder_filters_[0], decodeComplete()); // end_stream=true.\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n}\n\n// SRDS updating scopes affects routing.\nTEST_F(HttpConnectionManagerImplTest, TestSrdsUpdate) {\n  setup(false, \"\", true, true);\n\n  EXPECT_CALL(*static_cast<const Router::MockScopedConfig*>(\n                  scopedRouteConfigProvider()->config<Router::ScopedConfig>().get()),\n              getRouteConfig(_))\n      .Times(3)\n      .WillOnce(Return(nullptr))\n      .WillOnce(Return(nullptr))        // refreshCachedRoute first time.\n      .WillOnce(Return(route_config_)); // triggered by callbacks_->route(), SRDS now updated.\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance& data) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":method\", \"GET\"}, {\":path\", \"/foo\"}}};\n    decoder->decodeHeaders(std::move(headers), true);\n    data.drain(4);\n  }));\n  const std::string fake_cluster1_name = \"fake_cluster1\";\n  std::shared_ptr<Router::MockRoute> route1 = std::make_shared<NiceMock<Router::MockRoute>>();\n  EXPECT_CALL(route1->route_entry_, clusterName()).WillRepeatedly(ReturnRef(fake_cluster1_name));\n  std::shared_ptr<Upstream::MockThreadLocalCluster> fake_cluster1 =\n      std::make_shared<NiceMock<Upstream::MockThreadLocalCluster>>();\n  EXPECT_CALL(cluster_manager_, get(_)).WillOnce(Return(fake_cluster1.get()));\n  EXPECT_CALL(*route_config_, route(_, _)).WillOnce(Return(route1));\n  // First no-scope-found request will be handled by decoder_filters_[0].\n  setupFilterChain(1, 0);\n  EXPECT_CALL(*decoder_filters_[0], decodeHeaders(_, true))\n      .WillOnce(InvokeWithoutArgs([&]() -> FilterHeadersStatus {\n        EXPECT_EQ(nullptr, decoder_filters_[0]->callbacks_->route());\n\n        // Clear route and next call on callbacks_->route() will trigger a re-snapping of the\n        // snapped_route_config_.\n        decoder_filters_[0]->callbacks_->clearRouteCache();\n\n        // Now route config provider returns something.\n        EXPECT_EQ(route1, decoder_filters_[0]->callbacks_->route());\n        EXPECT_EQ(route1->routeEntry(), decoder_filters_[0]->callbacks_->streamInfo().routeEntry());\n        EXPECT_EQ(fake_cluster1->info(), decoder_filters_[0]->callbacks_->clusterInfo());\n        return FilterHeadersStatus::StopIteration;\n\n        return FilterHeadersStatus::StopIteration;\n      }));\n  EXPECT_CALL(*decoder_filters_[0], decodeComplete()); // end_stream=true.\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n}\n\n// SRDS Scope header update cause cross-scope reroute.\nTEST_F(HttpConnectionManagerImplTest, TestSrdsCrossScopeReroute) {\n  setup(false, \"\", true, true);\n\n  std::shared_ptr<Router::MockConfig> route_config1 =\n      std::make_shared<NiceMock<Router::MockConfig>>();\n  std::shared_ptr<Router::MockConfig> route_config2 =\n      std::make_shared<NiceMock<Router::MockConfig>>();\n  std::shared_ptr<Router::MockRoute> route1 = std::make_shared<NiceMock<Router::MockRoute>>();\n  std::shared_ptr<Router::MockRoute> route2 = std::make_shared<NiceMock<Router::MockRoute>>();\n  EXPECT_CALL(*route_config1, route(_, _)).WillRepeatedly(Return(route1));\n  EXPECT_CALL(*route_config2, route(_, _)).WillRepeatedly(Return(route2));\n  EXPECT_CALL(*static_cast<const Router::MockScopedConfig*>(\n                  scopedRouteConfigProvider()->config<Router::ScopedConfig>().get()),\n              getRouteConfig(_))\n      // 1. Snap scoped route config;\n      // 2. refreshCachedRoute (both in decodeHeaders(headers,end_stream);\n      // 3. then refreshCachedRoute triggered by decoder_filters_[1]->callbacks_->route().\n      .Times(3)\n      .WillRepeatedly(Invoke([&](const HeaderMap& headers) -> Router::ConfigConstSharedPtr {\n        auto& test_headers = static_cast<const TestHeaderMapImpl&>(headers);\n        if (test_headers.get_(\"scope_key\") == \"foo\") {\n          return route_config1;\n        }\n        return route_config2;\n      }));\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance& data) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{new TestHeaderMapImpl{\n        {\":authority\", \"host\"}, {\":method\", \"GET\"}, {\"scope_key\", \"foo\"}, {\":path\", \"/foo\"}}};\n    decoder->decodeHeaders(std::move(headers), false);\n    data.drain(4);\n  }));\n  setupFilterChain(2, 0);\n  EXPECT_CALL(*decoder_filters_[0], decodeHeaders(_, false))\n      .WillOnce(Invoke([&](Http::HeaderMap& headers, bool) -> FilterHeadersStatus {\n        EXPECT_EQ(route1, decoder_filters_[0]->callbacks_->route());\n        auto& test_headers = static_cast<TestHeaderMapImpl&>(headers);\n        // Clear cached route and change scope key to \"bar\".\n        decoder_filters_[0]->callbacks_->clearRouteCache();\n        test_headers.remove(\"scope_key\");\n        test_headers.addCopy(\"scope_key\", \"bar\");\n        return FilterHeadersStatus::Continue;\n      }));\n  EXPECT_CALL(*decoder_filters_[1], decodeHeaders(_, false))\n      .WillOnce(Invoke([&](Http::HeaderMap& headers, bool) -> FilterHeadersStatus {\n        auto& test_headers = static_cast<TestHeaderMapImpl&>(headers);\n        EXPECT_EQ(test_headers.get_(\"scope_key\"), \"bar\");\n        // Route now switched to route2 as header \"scope_key\" has changed.\n        EXPECT_EQ(route2, decoder_filters_[1]->callbacks_->route());\n        EXPECT_EQ(route2->routeEntry(), decoder_filters_[1]->callbacks_->streamInfo().routeEntry());\n        return FilterHeadersStatus::StopIteration;\n      }));\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n}\n\n// SRDS scoped RouteConfiguration found and route found.\nTEST_F(HttpConnectionManagerImplTest, TestSrdsRouteFound) {\n  setup(false, \"\", true, true);\n  setupFilterChain(1, 0);\n\n  const std::string fake_cluster1_name = \"fake_cluster1\";\n  std::shared_ptr<Router::MockRoute> route1 = std::make_shared<NiceMock<Router::MockRoute>>();\n  EXPECT_CALL(route1->route_entry_, clusterName()).WillRepeatedly(ReturnRef(fake_cluster1_name));\n  std::shared_ptr<Upstream::MockThreadLocalCluster> fake_cluster1 =\n      std::make_shared<NiceMock<Upstream::MockThreadLocalCluster>>();\n  EXPECT_CALL(cluster_manager_, get(_)).WillOnce(Return(fake_cluster1.get()));\n  EXPECT_CALL(*scopedRouteConfigProvider()->config<Router::MockScopedConfig>(), getRouteConfig(_))\n      // 1. decodeHeaders() snaping route config.\n      // 2. refreshCachedRoute() later in the same decodeHeaders().\n      .Times(2);\n  EXPECT_CALL(\n      *static_cast<const Router::MockConfig*>(\n          scopedRouteConfigProvider()->config<Router::MockScopedConfig>()->route_config_.get()),\n      route(_, _))\n      .WillOnce(Return(route1));\n  StreamDecoder* decoder = nullptr;\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance& data) -> void {\n    decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":method\", \"GET\"}, {\":path\", \"/foo\"}}};\n    decoder->decodeHeaders(std::move(headers), true);\n    data.drain(4);\n  }));\n  EXPECT_CALL(*decoder_filters_[0], decodeHeaders(_, true))\n      .WillOnce(InvokeWithoutArgs([&]() -> FilterHeadersStatus {\n        EXPECT_EQ(route1, decoder_filters_[0]->callbacks_->route());\n        EXPECT_EQ(route1->routeEntry(), decoder_filters_[0]->callbacks_->streamInfo().routeEntry());\n        EXPECT_EQ(fake_cluster1->info(), decoder_filters_[0]->callbacks_->clusterInfo());\n        return FilterHeadersStatus::StopIteration;\n      }));\n  EXPECT_CALL(*decoder_filters_[0], decodeComplete());\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n}\n\nclass HttpConnectionManagerImplDeathTest : public HttpConnectionManagerImplTest {\npublic:\n  Router::RouteConfigProvider* routeConfigProvider() override {\n    return route_config_provider2_.get();\n  }\n  Config::ConfigProvider* scopedRouteConfigProvider() override {\n    return scoped_route_config_provider2_.get();\n  }\n\n  std::shared_ptr<Router::MockRouteConfigProvider> route_config_provider2_;\n  std::shared_ptr<Router::MockScopedRouteConfigProvider> scoped_route_config_provider2_;\n};\n\n// HCM config can only have either RouteConfigProvider or ScopedRoutesConfigProvider.\nTEST_F(HttpConnectionManagerImplDeathTest, InvalidConnectionManagerConfig) {\n  setup(false, \"\");\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  EXPECT_CALL(*codec_, dispatch(_)).WillRepeatedly(Invoke([&](Buffer::Instance&) -> void {\n    conn_manager_->newStream(response_encoder_);\n  }));\n  // Either RDS or SRDS should be set.\n  EXPECT_DEBUG_DEATH(conn_manager_->onData(fake_input, false),\n                     \"Either routeConfigProvider or scopedRouteConfigProvider should be set in \"\n                     \"ConnectionManagerImpl.\");\n\n  route_config_provider2_ = std::make_shared<NiceMock<Router::MockRouteConfigProvider>>();\n\n  // Only route config provider valid.\n  EXPECT_NO_THROW(conn_manager_->onData(fake_input, false));\n\n  scoped_route_config_provider2_ =\n      std::make_shared<NiceMock<Router::MockScopedRouteConfigProvider>>();\n  // Can't have RDS and SRDS provider in the same time.\n  EXPECT_DEBUG_DEATH(conn_manager_->onData(fake_input, false),\n                     \"Either routeConfigProvider or scopedRouteConfigProvider should be set in \"\n                     \"ConnectionManagerImpl.\");\n\n  route_config_provider2_.reset();\n  // Only scoped route config provider valid.\n  EXPECT_NO_THROW(conn_manager_->onData(fake_input, false));\n\n#if !defined(NDEBUG)\n  EXPECT_CALL(*scoped_route_config_provider2_, getConfig()).WillRepeatedly(Return(nullptr));\n  // ASSERT failure when SRDS provider returns a nullptr.\n  EXPECT_DEBUG_DEATH(conn_manager_->onData(fake_input, false),\n                     \"Scoped rds provider returns null for scoped routes config.\");\n#endif // !defined(NDEBUG)\n}\n\n} // namespace Http\n} // namespace Envoy\n", "#include \"common/http/header_map_impl.h\"\n\n#include \"benchmark/benchmark.h\"\n\nnamespace Envoy {\nnamespace Http {\n\n/**\n * Add several dummy headers to a HeaderMap.\n * @param num_headers the number of dummy headers to add.\n */\nstatic void addDummyHeaders(HeaderMap& headers, size_t num_headers) {\n  const std::string prefix(\"dummy-key-\");\n  for (size_t i = 0; i < num_headers; i++) {\n    headers.addCopy(LowerCaseString(prefix + std::to_string(i)), \"abcd\");\n  }\n}\n\n/** Measure the construction/destruction speed of HeaderMapImpl.*/\nstatic void HeaderMapImplCreate(benchmark::State& state) {\n  for (auto _ : state) {\n    HeaderMapImpl headers;\n    benchmark::DoNotOptimize(headers.size());\n  }\n}\nBENCHMARK(HeaderMapImplCreate);\n\n/**\n * Measure the speed of setting/overwriting a header value. The numeric Arg passed\n * by the BENCHMARK(...) macro call below indicates how many dummy headers this test\n * will add to the HeaderMapImpl before testing the setReference() method. That helps\n * identify whether the speed of setReference() is dependent on the number of other\n * headers in the HeaderMapImpl.\n */\nstatic void HeaderMapImplSetReference(benchmark::State& state) {\n  const LowerCaseString key(\"example-key\");\n  const std::string value(\"01234567890123456789\");\n  HeaderMapImpl headers;\n  addDummyHeaders(headers, state.range(0));\n  for (auto _ : state) {\n    headers.setReference(key, value);\n  }\n  benchmark::DoNotOptimize(headers.size());\n}\nBENCHMARK(HeaderMapImplSetReference)->Arg(0)->Arg(1)->Arg(10)->Arg(50);\n\n/**\n * Measure the speed of retrieving a header value. The numeric Arg passed by the\n * BENCHMARK(...) macro call below indicates how many dummy headers this test\n * will add to the HeaderMapImpl during test setup. The relative performance of\n * this test for different Arg values will help reveal how the speed of the get()\n * method depends (or doesn't depend) on the number of other headers in the\n * HeaderMapImpl.\n */\nstatic void HeaderMapImplGet(benchmark::State& state) {\n  const LowerCaseString key(\"example-key\");\n  const std::string value(\"01234567890123456789\");\n  HeaderMapImpl headers;\n  addDummyHeaders(headers, state.range(0));\n  headers.setReference(key, value);\n  size_t successes = 0;\n  for (auto _ : state) {\n    successes += (headers.get(key) != nullptr);\n  }\n  benchmark::DoNotOptimize(successes);\n}\nBENCHMARK(HeaderMapImplGet)->Arg(0)->Arg(1)->Arg(10)->Arg(50);\n\n/**\n * Measure the retrieval speed of a header for which HeaderMapImpl is expected to\n * provide special optimizations.\n */\nstatic void HeaderMapImplGetInline(benchmark::State& state) {\n  const std::string value(\"01234567890123456789\");\n  HeaderMapImpl headers;\n  addDummyHeaders(headers, state.range(0));\n  headers.insertConnection().value().setReference(value);\n  size_t size = 0;\n  for (auto _ : state) {\n    size += headers.Connection()->value().size();\n  }\n  benchmark::DoNotOptimize(size);\n}\nBENCHMARK(HeaderMapImplGetInline)->Arg(0)->Arg(1)->Arg(10)->Arg(50);\n\n/**\n * Measure the speed of writing to a header for which HeaderMapImpl is expected to\n * provide special optimizations.\n */\nstatic void HeaderMapImplSetInline(benchmark::State& state) {\n  const std::string value(\"01234567890123456789\");\n  HeaderMapImpl headers;\n  addDummyHeaders(headers, state.range(0));\n  for (auto _ : state) {\n    headers.insertConnection().value().setReference(value);\n  }\n  benchmark::DoNotOptimize(headers.size());\n}\nBENCHMARK(HeaderMapImplSetInline)->Arg(0)->Arg(1)->Arg(10)->Arg(50);\n\n/** Measure the speed of the byteSize() estimation method. */\nstatic void HeaderMapImplGetByteSize(benchmark::State& state) {\n  HeaderMapImpl headers;\n  addDummyHeaders(headers, state.range(0));\n  uint64_t size = 0;\n  for (auto _ : state) {\n    size += headers.byteSize();\n  }\n  benchmark::DoNotOptimize(size);\n}\nBENCHMARK(HeaderMapImplGetByteSize)->Arg(0)->Arg(1)->Arg(10)->Arg(50);\n\n/** Measure the speed of iteration with a lightweight callback. */\nstatic void HeaderMapImplIterate(benchmark::State& state) {\n  HeaderMapImpl headers;\n  size_t num_callbacks = 0;\n  addDummyHeaders(headers, state.range(0));\n  auto counting_callback = [](const HeaderEntry&, void* context) -> HeaderMap::Iterate {\n    (*static_cast<size_t*>(context))++;\n    return HeaderMap::Iterate::Continue;\n  };\n  for (auto _ : state) {\n    headers.iterate(counting_callback, &num_callbacks);\n  }\n  benchmark::DoNotOptimize(num_callbacks);\n}\nBENCHMARK(HeaderMapImplIterate)->Arg(0)->Arg(1)->Arg(10)->Arg(50);\n\n/** Measure the speed of the HeaderMapImpl lookup() method. */\nstatic void HeaderMapImplLookup(benchmark::State& state) {\n  const LowerCaseString key(\"connection\");\n  const std::string value(\"01234567890123456789\");\n  HeaderMapImpl headers;\n  addDummyHeaders(headers, state.range(0));\n  headers.addReference(key, value);\n  for (auto _ : state) {\n    const HeaderEntry* entry = nullptr;\n    auto result = headers.lookup(key, &entry);\n    benchmark::DoNotOptimize(result);\n  }\n}\nBENCHMARK(HeaderMapImplLookup)->Arg(0)->Arg(1)->Arg(10)->Arg(50);\n\n/**\n * Measure the speed of removing a header by key name.\n * @note The measured time for each iteration includes the time needed to add\n *       one copy of the header.\n */\nstatic void HeaderMapImplRemove(benchmark::State& state) {\n  const LowerCaseString key(\"example-key\");\n  const std::string value(\"01234567890123456789\");\n  HeaderMapImpl headers;\n  addDummyHeaders(headers, state.range(0));\n  for (auto _ : state) {\n    headers.addReference(key, value);\n    headers.remove(key);\n  }\n  benchmark::DoNotOptimize(headers.size());\n}\nBENCHMARK(HeaderMapImplRemove)->Arg(0)->Arg(1)->Arg(10)->Arg(50);\n\n/**\n * Measure the speed of removing a header by key name, for the special case of\n * a key for which HeaderMapImpl is expected to provide special optimization.\n * @note The measured time for each iteration includes the time needed to add\n *       one copy of the header.\n */\nstatic void HeaderMapImplRemoveInline(benchmark::State& state) {\n  const LowerCaseString key(\"connection\");\n  const std::string value(\"01234567890123456789\");\n  HeaderMapImpl headers;\n  addDummyHeaders(headers, state.range(0));\n  for (auto _ : state) {\n    headers.addReference(key, value);\n    headers.remove(key);\n  }\n  benchmark::DoNotOptimize(headers.size());\n}\nBENCHMARK(HeaderMapImplRemoveInline)->Arg(0)->Arg(1)->Arg(10)->Arg(50);\n\n/**\n * Measure the speed of creating a HeaderMapImpl and populating it with a realistic\n * set of response headers.\n */\nstatic void HeaderMapImplPopulate(benchmark::State& state) {\n  const std::pair<LowerCaseString, std::string> headers_to_add[] = {\n      {LowerCaseString(\"cache-control\"), \"max-age=0, private, must-revalidate\"},\n      {LowerCaseString(\"content-encoding\"), \"gzip\"},\n      {LowerCaseString(\"content-type\"), \"text/html; charset=utf-8\"},\n      {LowerCaseString(\"date\"), \"Wed, 23 Jan 2019 04:00:00 GMT\"},\n      {LowerCaseString(\"server\"), \"envoy\"},\n      {LowerCaseString(\"x-custom-header-1\"), \"example 1\"},\n      {LowerCaseString(\"x-custom-header-2\"), \"example 2\"},\n      {LowerCaseString(\"x-custom-header-3\"), \"example 3\"},\n      {LowerCaseString(\"set-cookie\"), \"_cookie1=12345678; path = /; secure\"},\n      {LowerCaseString(\"set-cookie\"), \"_cookie2=12345678; path = /; secure\"},\n  };\n  for (auto _ : state) {\n    HeaderMapImpl headers;\n    for (const auto& key_value : headers_to_add) {\n      headers.addReference(key_value.first, key_value.second);\n    }\n    benchmark::DoNotOptimize(headers.size());\n  }\n}\nBENCHMARK(HeaderMapImplPopulate);\n\n} // namespace Http\n} // namespace Envoy\n\n// Boilerplate main(), which discovers benchmarks in the same file and runs them.\nint main(int argc, char** argv) {\n  benchmark::Initialize(&argc, argv);\n\n  if (benchmark::ReportUnrecognizedArguments(argc, argv)) {\n    return 1;\n  }\n  benchmark::RunSpecifiedBenchmarks();\n}\n", "#include <memory>\n#include <string>\n\n#include \"common/http/header_map_impl.h\"\n#include \"common/http/header_utility.h\"\n\n#include \"test/test_common/printers.h\"\n#include \"test/test_common/utility.h\"\n\n#include \"gtest/gtest.h\"\n\nusing ::testing::InSequence;\n\nnamespace Envoy {\nnamespace Http {\n\nTEST(HeaderStringTest, All) {\n  // Static LowerCaseString constructor\n  {\n    LowerCaseString static_string(\"hello\");\n    HeaderString string(static_string);\n    EXPECT_EQ(\"hello\", string.getStringView());\n    EXPECT_EQ(static_string.get(), string.getStringView());\n    EXPECT_EQ(5U, string.size());\n  }\n\n  // Static LowerCaseString operators\n  {\n    LowerCaseString banana(\"banana\");\n    LowerCaseString lemon(\"lemon\");\n    EXPECT_TRUE(banana < lemon);\n    EXPECT_TRUE(banana != lemon);\n    EXPECT_TRUE(banana == banana);\n  }\n\n  // Static std::string constructor\n  {\n    std::string static_string(\"HELLO\");\n    HeaderString string(static_string);\n    EXPECT_EQ(\"HELLO\", string.getStringView());\n    EXPECT_EQ(static_string, string.getStringView());\n    EXPECT_EQ(5U, string.size());\n  }\n\n  // Static move constructor\n  {\n    std::string static_string(\"HELLO\");\n    HeaderString string1(static_string);\n    HeaderString string2(std::move(string1));\n    EXPECT_EQ(\"HELLO\", string2.getStringView());\n    EXPECT_EQ(static_string, string1.getStringView()); // NOLINT(bugprone-use-after-move)\n    EXPECT_EQ(static_string, string2.getStringView());\n    EXPECT_EQ(5U, string1.size());\n    EXPECT_EQ(5U, string2.size());\n  }\n\n  // Inline move constructor\n  {\n    HeaderString string;\n    string.setCopy(\"hello\", 5);\n    EXPECT_EQ(HeaderString::Type::Inline, string.type());\n    HeaderString string2(std::move(string));\n    EXPECT_TRUE(string.empty()); // NOLINT(bugprone-use-after-move)\n    EXPECT_EQ(HeaderString::Type::Inline, string.type());\n    EXPECT_EQ(HeaderString::Type::Inline, string2.type());\n    string.append(\"world\", 5);\n    EXPECT_EQ(\"world\", string.getStringView());\n    EXPECT_EQ(5UL, string.size());\n    EXPECT_EQ(\"hello\", string2.getStringView());\n    EXPECT_EQ(5UL, string2.size());\n  }\n\n  // Dynamic move constructor\n  {\n    std::string large(4096, 'a');\n    HeaderString string;\n    string.setCopy(large.c_str(), large.size());\n    EXPECT_EQ(HeaderString::Type::Dynamic, string.type());\n    HeaderString string2(std::move(string));\n    EXPECT_TRUE(string.empty()); // NOLINT(bugprone-use-after-move)\n    EXPECT_EQ(HeaderString::Type::Inline, string.type());\n    EXPECT_EQ(HeaderString::Type::Dynamic, string2.type());\n    string.append(\"b\", 1);\n    EXPECT_EQ(\"b\", string.getStringView());\n    EXPECT_EQ(1UL, string.size());\n    EXPECT_EQ(large, string2.getStringView());\n    EXPECT_EQ(4096UL, string2.size());\n  }\n\n  // Static to inline number.\n  {\n    std::string static_string(\"HELLO\");\n    HeaderString string(static_string);\n    string.setInteger(5);\n    EXPECT_EQ(HeaderString::Type::Inline, string.type());\n    EXPECT_EQ(\"5\", string.getStringView());\n  }\n\n  // Static to inline string.\n  {\n    std::string static_string(\"HELLO\");\n    HeaderString string(static_string);\n    string.setCopy(static_string.c_str(), static_string.size());\n    EXPECT_EQ(HeaderString::Type::Inline, string.type());\n    EXPECT_EQ(\"HELLO\", string.getStringView());\n  }\n\n  // Static clear() does nothing.\n  {\n    std::string static_string(\"HELLO\");\n    HeaderString string(static_string);\n    EXPECT_EQ(HeaderString::Type::Reference, string.type());\n    string.clear();\n    EXPECT_EQ(HeaderString::Type::Reference, string.type());\n    EXPECT_EQ(\"HELLO\", string.getStringView());\n  }\n\n  // Static to append.\n  {\n    std::string static_string(\"HELLO\");\n    HeaderString string(static_string);\n    EXPECT_EQ(HeaderString::Type::Reference, string.type());\n    string.append(\"a\", 1);\n    EXPECT_EQ(\"HELLOa\", string.getStringView());\n  }\n\n  // Copy inline\n  {\n    HeaderString string;\n    string.setCopy(\"hello\", 5);\n    EXPECT_EQ(\"hello\", string.getStringView());\n    EXPECT_EQ(5U, string.size());\n  }\n\n  // Copy dynamic\n  {\n    HeaderString string;\n    std::string large_value(4096, 'a');\n    string.setCopy(large_value.c_str(), large_value.size());\n    EXPECT_EQ(large_value, string.getStringView());\n    EXPECT_NE(large_value.c_str(), string.getStringView().data());\n    EXPECT_EQ(4096U, string.size());\n  }\n\n  // Copy twice dynamic\n  {\n    HeaderString string;\n    std::string large_value1(4096, 'a');\n    string.setCopy(large_value1.c_str(), large_value1.size());\n    std::string large_value2(2048, 'b');\n    string.setCopy(large_value2.c_str(), large_value2.size());\n    EXPECT_EQ(large_value2, string.getStringView());\n    EXPECT_NE(large_value2.c_str(), string.getStringView().data());\n    EXPECT_EQ(2048U, string.size());\n  }\n\n  // Copy twice dynamic with reallocate\n  {\n    HeaderString string;\n    std::string large_value1(4096, 'a');\n    string.setCopy(large_value1.c_str(), large_value1.size());\n    std::string large_value2(16384, 'b');\n    string.setCopy(large_value2.c_str(), large_value2.size());\n    EXPECT_EQ(large_value2, string.getStringView());\n    EXPECT_NE(large_value2.c_str(), string.getStringView().data());\n    EXPECT_EQ(16384U, string.size());\n  }\n\n  // Copy twice inline to dynamic\n  {\n    HeaderString string;\n    std::string large_value1(16, 'a');\n    string.setCopy(large_value1.c_str(), large_value1.size());\n    std::string large_value2(16384, 'b');\n    string.setCopy(large_value2.c_str(), large_value2.size());\n    EXPECT_EQ(large_value2, string.getStringView());\n    EXPECT_NE(large_value2.c_str(), string.getStringView().data());\n    EXPECT_EQ(16384U, string.size());\n  }\n\n  // Copy, exactly filling inline capacity\n  //\n  // ASAN does not catch the clobber in the case where the code writes one past the\n  // end of the inline buffer. To ensure coverage the next block checks that setCopy\n  // is not introducing a NUL in a way that does not rely on an actual clobber getting\n  // detected.\n  {\n    HeaderString string;\n    std::string large(128, 'z');\n    string.setCopy(large.c_str(), large.size());\n    EXPECT_EQ(string.type(), HeaderString::Type::Inline);\n    EXPECT_EQ(string.getStringView(), large);\n  }\n\n  // Ensure setCopy does not add NUL.\n  {\n    HeaderString string;\n    std::string large(128, 'z');\n    string.setCopy(large.c_str(), large.size());\n    EXPECT_EQ(string.type(), HeaderString::Type::Inline);\n    EXPECT_EQ(string.getStringView(), large);\n    std::string small(1, 'a');\n    string.setCopy(small.c_str(), small.size());\n    EXPECT_EQ(string.type(), HeaderString::Type::Inline);\n    EXPECT_EQ(string.getStringView(), small);\n    // If we peek past the valid first character of the\n    // header string_view it should still be 'z' and not '\\0'.\n    // We know this peek is OK since the memory is much larger\n    // than two bytes.\n    EXPECT_EQ(string.getStringView().data()[1], 'z');\n  }\n\n  // Copy, exactly filling dynamic capacity\n  //\n  // ASAN should catch a write one past the end of the dynamic buffer. This test\n  // forces a dynamic buffer with one copy and then fills it with the next.\n  {\n    HeaderString string;\n    // Force Dynamic with setCopy of inline buffer size + 1.\n    std::string large1(129, 'z');\n    string.setCopy(large1.c_str(), large1.size());\n    EXPECT_EQ(string.type(), HeaderString::Type::Dynamic);\n    const void* dynamic_buffer_address = string.getStringView().data();\n    // Dynamic capacity in setCopy is 2x required by the size.\n    // So to fill it exactly setCopy with a total of 258 chars.\n    std::string large2(258, 'z');\n    string.setCopy(large2.c_str(), large2.size());\n    EXPECT_EQ(string.type(), HeaderString::Type::Dynamic);\n    // The actual buffer address should be the same as it was after\n    // setCopy(large1), ensuring no reallocation occurred.\n    EXPECT_EQ(string.getStringView().data(), dynamic_buffer_address);\n    EXPECT_EQ(string.getStringView(), large2);\n  }\n\n  // Append, small buffer to dynamic\n  {\n    HeaderString string;\n    std::string test(128, 'a');\n    string.append(test.c_str(), test.size());\n    EXPECT_EQ(HeaderString::Type::Inline, string.type());\n    string.append(\"a\", 1);\n    EXPECT_EQ(HeaderString::Type::Dynamic, string.type());\n    test += 'a';\n    EXPECT_EQ(test, string.getStringView());\n  }\n\n  // Append into inline twice, then shift to dynamic.\n  {\n    HeaderString string;\n    string.append(\"hello\", 5);\n    EXPECT_EQ(\"hello\", string.getStringView());\n    EXPECT_EQ(5U, string.size());\n    string.append(\"world\", 5);\n    EXPECT_EQ(\"helloworld\", string.getStringView());\n    EXPECT_EQ(10U, string.size());\n    std::string large(4096, 'a');\n    string.append(large.c_str(), large.size());\n    large = \"helloworld\" + large;\n    EXPECT_EQ(large, string.getStringView());\n    EXPECT_EQ(4106U, string.size());\n  }\n\n  // Append, realloc dynamic.\n  {\n    HeaderString string;\n    std::string large(129, 'a');\n    string.append(large.c_str(), large.size());\n    EXPECT_EQ(HeaderString::Type::Dynamic, string.type());\n    std::string large2 = large + large;\n    string.append(large2.c_str(), large2.size());\n    large += large2;\n    EXPECT_EQ(large, string.getStringView());\n    EXPECT_EQ(387U, string.size());\n  }\n\n  // Append, realloc close to limit with small buffer.\n  {\n    HeaderString string;\n    std::string large(129, 'a');\n    string.append(large.c_str(), large.size());\n    EXPECT_EQ(HeaderString::Type::Dynamic, string.type());\n    std::string large2(120, 'b');\n    string.append(large2.c_str(), large2.size());\n    std::string large3(32, 'c');\n    string.append(large3.c_str(), large3.size());\n    EXPECT_EQ((large + large2 + large3), string.getStringView());\n    EXPECT_EQ(281U, string.size());\n  }\n\n  // Append, exactly filling dynamic capacity\n  //\n  // ASAN should catch a write one past the end of the dynamic buffer. This test\n  // forces a dynamic buffer with one copy and then fills it with the next.\n  {\n    HeaderString string;\n    // Force Dynamic with setCopy of inline buffer size + 1.\n    std::string large1(129, 'z');\n    string.setCopy(large1.c_str(), large1.size());\n    EXPECT_EQ(string.type(), HeaderString::Type::Dynamic);\n    const void* dynamic_buffer_address = string.getStringView().data();\n    // Dynamic capacity in setCopy is 2x required by the size.\n    // So to fill it exactly append 129 chars for a total of 258 chars.\n    std::string large2(129, 'z');\n    string.append(large2.c_str(), large2.size());\n    EXPECT_EQ(string.type(), HeaderString::Type::Dynamic);\n    // The actual buffer address should be the same as it was after\n    // setCopy(large1), ensuring no reallocation occurred.\n    EXPECT_EQ(string.getStringView().data(), dynamic_buffer_address);\n    EXPECT_EQ(string.getStringView(), large1 + large2);\n  }\n\n  // Set integer, inline\n  {\n    HeaderString string;\n    string.setInteger(123456789);\n    EXPECT_EQ(\"123456789\", string.getStringView());\n    EXPECT_EQ(9U, string.size());\n  }\n\n  // Set integer, dynamic\n  {\n    HeaderString string;\n    std::string large(129, 'a');\n    string.append(large.c_str(), large.size());\n    string.setInteger(123456789);\n    EXPECT_EQ(\"123456789\", string.getStringView());\n    EXPECT_EQ(9U, string.size());\n    EXPECT_EQ(HeaderString::Type::Dynamic, string.type());\n  }\n\n  // Set static, switch to dynamic, back to static.\n  {\n    const std::string static_string = \"hello world\";\n    HeaderString string;\n    string.setReference(static_string);\n    EXPECT_EQ(string.getStringView(), static_string);\n    EXPECT_EQ(11U, string.size());\n    EXPECT_EQ(HeaderString::Type::Reference, string.type());\n\n    const std::string large(129, 'a');\n    string.setCopy(large.c_str(), large.size());\n    EXPECT_NE(string.getStringView().data(), large.c_str());\n    EXPECT_EQ(HeaderString::Type::Dynamic, string.type());\n\n    string.setReference(static_string);\n    EXPECT_EQ(string.getStringView(), static_string);\n    EXPECT_EQ(11U, string.size());\n    EXPECT_EQ(HeaderString::Type::Reference, string.type());\n  }\n\n  // getString\n  {\n    std::string static_string(\"HELLO\");\n    HeaderString headerString1(static_string);\n    absl::string_view retString1 = headerString1.getStringView();\n    EXPECT_EQ(\"HELLO\", retString1);\n    EXPECT_EQ(5U, retString1.size());\n\n    HeaderString headerString2;\n    absl::string_view retString2 = headerString2.getStringView();\n    EXPECT_EQ(0U, retString2.size());\n  }\n}\n\nTEST(HeaderMapImplTest, InlineInsert) {\n  HeaderMapImpl headers;\n  EXPECT_TRUE(headers.empty());\n  EXPECT_EQ(0, headers.size());\n  EXPECT_EQ(nullptr, headers.Host());\n  headers.insertHost().value(std::string(\"hello\"));\n  EXPECT_FALSE(headers.empty());\n  EXPECT_EQ(1, headers.size());\n  EXPECT_EQ(\":authority\", headers.Host()->key().getStringView());\n  EXPECT_EQ(\"hello\", headers.Host()->value().getStringView());\n  EXPECT_EQ(\"hello\", headers.get(Headers::get().Host)->value().getStringView());\n}\n\nTEST(HeaderMapImplTest, MoveIntoInline) {\n  HeaderMapImpl headers;\n  HeaderString key;\n  key.setCopy(Headers::get().CacheControl.get());\n  HeaderString value;\n  value.setCopy(\"hello\", 5);\n  headers.addViaMove(std::move(key), std::move(value));\n  EXPECT_EQ(\"cache-control\", headers.CacheControl()->key().getStringView());\n  EXPECT_EQ(\"hello\", headers.CacheControl()->value().getStringView());\n\n  HeaderString key2;\n  key2.setCopy(Headers::get().CacheControl.get().c_str(), Headers::get().CacheControl.get().size());\n  HeaderString value2;\n  value2.setCopy(\"there\", 5);\n  headers.addViaMove(std::move(key2), std::move(value2));\n  EXPECT_EQ(\"cache-control\", headers.CacheControl()->key().getStringView());\n  EXPECT_EQ(\"hello,there\", headers.CacheControl()->value().getStringView());\n}\n\nTEST(HeaderMapImplTest, Remove) {\n  HeaderMapImpl headers;\n\n  // Add random header and then remove by name.\n  LowerCaseString static_key(\"hello\");\n  std::string ref_value(\"value\");\n  headers.addReference(static_key, ref_value);\n  EXPECT_EQ(\"value\", headers.get(static_key)->value().getStringView());\n  EXPECT_EQ(HeaderString::Type::Reference, headers.get(static_key)->value().type());\n  EXPECT_EQ(1UL, headers.size());\n  EXPECT_FALSE(headers.empty());\n  headers.remove(static_key);\n  EXPECT_EQ(nullptr, headers.get(static_key));\n  EXPECT_EQ(0UL, headers.size());\n  EXPECT_TRUE(headers.empty());\n\n  // Add and remove by inline.\n  headers.insertContentLength().value(5);\n  EXPECT_EQ(\"5\", headers.ContentLength()->value().getStringView());\n  EXPECT_EQ(1UL, headers.size());\n  EXPECT_FALSE(headers.empty());\n  headers.removeContentLength();\n  EXPECT_EQ(nullptr, headers.ContentLength());\n  EXPECT_EQ(0UL, headers.size());\n  EXPECT_TRUE(headers.empty());\n\n  // Add inline and remove by name.\n  headers.insertContentLength().value(5);\n  EXPECT_EQ(\"5\", headers.ContentLength()->value().getStringView());\n  EXPECT_EQ(1UL, headers.size());\n  EXPECT_FALSE(headers.empty());\n  headers.remove(Headers::get().ContentLength);\n  EXPECT_EQ(nullptr, headers.ContentLength());\n  EXPECT_EQ(0UL, headers.size());\n  EXPECT_TRUE(headers.empty());\n}\n\nTEST(HeaderMapImplTest, RemoveRegex) {\n  // These will match.\n  LowerCaseString key1 = LowerCaseString(\"X-prefix-foo\");\n  LowerCaseString key3 = LowerCaseString(\"X-Prefix-\");\n  LowerCaseString key5 = LowerCaseString(\"x-prefix-eep\");\n  // These will not.\n  LowerCaseString key2 = LowerCaseString(\" x-prefix-foo\");\n  LowerCaseString key4 = LowerCaseString(\"y-x-prefix-foo\");\n\n  HeaderMapImpl headers;\n  headers.addReference(key1, \"value\");\n  headers.addReference(key2, \"value\");\n  headers.addReference(key3, \"value\");\n  headers.addReference(key4, \"value\");\n  headers.addReference(key5, \"value\");\n\n  // Test removing the first header, middle headers, and the end header.\n  headers.removePrefix(LowerCaseString(\"x-prefix-\"));\n  EXPECT_EQ(nullptr, headers.get(key1));\n  EXPECT_NE(nullptr, headers.get(key2));\n  EXPECT_EQ(nullptr, headers.get(key3));\n  EXPECT_NE(nullptr, headers.get(key4));\n  EXPECT_EQ(nullptr, headers.get(key5));\n\n  // Remove all headers.\n  headers.removePrefix(LowerCaseString(\"\"));\n  EXPECT_EQ(nullptr, headers.get(key2));\n  EXPECT_EQ(nullptr, headers.get(key4));\n\n  // Add inline and remove by regex\n  headers.insertContentLength().value(5);\n  EXPECT_EQ(\"5\", headers.ContentLength()->value().getStringView());\n  EXPECT_EQ(1UL, headers.size());\n  EXPECT_FALSE(headers.empty());\n  headers.removePrefix(LowerCaseString(\"content\"));\n  EXPECT_EQ(nullptr, headers.ContentLength());\n}\n\nTEST(HeaderMapImplTest, SetRemovesAllValues) {\n  HeaderMapImpl headers;\n\n  LowerCaseString key1(\"hello\");\n  LowerCaseString key2(\"olleh\");\n  std::string ref_value1(\"world\");\n  std::string ref_value2(\"planet\");\n  std::string ref_value3(\"globe\");\n  std::string ref_value4(\"earth\");\n  std::string ref_value5(\"blue marble\");\n\n  headers.addReference(key1, ref_value1);\n  headers.addReference(key2, ref_value2);\n  headers.addReference(key1, ref_value3);\n  headers.addReference(key1, ref_value4);\n\n  using MockCb = testing::MockFunction<void(const std::string&, const std::string&)>;\n\n  {\n    MockCb cb;\n\n    InSequence seq;\n    EXPECT_CALL(cb, Call(\"hello\", \"world\"));\n    EXPECT_CALL(cb, Call(\"olleh\", \"planet\"));\n    EXPECT_CALL(cb, Call(\"hello\", \"globe\"));\n    EXPECT_CALL(cb, Call(\"hello\", \"earth\"));\n\n    headers.iterate(\n        [](const Http::HeaderEntry& header, void* cb_v) -> HeaderMap::Iterate {\n          static_cast<MockCb*>(cb_v)->Call(std::string(header.key().getStringView()),\n                                           std::string(header.value().getStringView()));\n          return HeaderMap::Iterate::Continue;\n        },\n        &cb);\n  }\n\n  headers.setReference(key1, ref_value5); // set moves key to end\n\n  {\n    MockCb cb;\n\n    InSequence seq;\n    EXPECT_CALL(cb, Call(\"olleh\", \"planet\"));\n    EXPECT_CALL(cb, Call(\"hello\", \"blue marble\"));\n\n    headers.iterate(\n        [](const Http::HeaderEntry& header, void* cb_v) -> HeaderMap::Iterate {\n          static_cast<MockCb*>(cb_v)->Call(std::string(header.key().getStringView()),\n                                           std::string(header.value().getStringView()));\n          return HeaderMap::Iterate::Continue;\n        },\n        &cb);\n  }\n}\n\nTEST(HeaderMapImplTest, DoubleInlineAdd) {\n  {\n    HeaderMapImpl headers;\n    const std::string foo(\"foo\");\n    const std::string bar(\"bar\");\n    headers.addReference(Headers::get().ContentLength, foo);\n    headers.addReference(Headers::get().ContentLength, bar);\n    EXPECT_EQ(\"foo,bar\", headers.ContentLength()->value().getStringView());\n    EXPECT_EQ(1UL, headers.size());\n  }\n  {\n    HeaderMapImpl headers;\n    headers.addReferenceKey(Headers::get().ContentLength, \"foo\");\n    headers.addReferenceKey(Headers::get().ContentLength, \"bar\");\n    EXPECT_EQ(\"foo,bar\", headers.ContentLength()->value().getStringView());\n    EXPECT_EQ(1UL, headers.size());\n  }\n  {\n    HeaderMapImpl headers;\n    headers.addReferenceKey(Headers::get().ContentLength, 5);\n    headers.addReferenceKey(Headers::get().ContentLength, 6);\n    EXPECT_EQ(\"5,6\", headers.ContentLength()->value().getStringView());\n    EXPECT_EQ(1UL, headers.size());\n  }\n  {\n    HeaderMapImpl headers;\n    const std::string foo(\"foo\");\n    headers.addReference(Headers::get().ContentLength, foo);\n    headers.addReferenceKey(Headers::get().ContentLength, 6);\n    EXPECT_EQ(\"foo,6\", headers.ContentLength()->value().getStringView());\n    EXPECT_EQ(1UL, headers.size());\n  }\n}\n\n// Per https://github.com/envoyproxy/envoy/issues/7488 make sure we don't\n// combine set-cookie headers\nTEST(HeaderMapImplTest, DoubleCookieAdd) {\n  HeaderMapImpl headers;\n  const std::string foo(\"foo\");\n  const std::string bar(\"bar\");\n  const LowerCaseString& set_cookie = Http::Headers::get().SetCookie;\n  headers.addReference(set_cookie, foo);\n  headers.addReference(set_cookie, bar);\n  EXPECT_EQ(2UL, headers.size());\n\n  std::vector<absl::string_view> out;\n  Http::HeaderUtility::getAllOfHeader(headers, \"set-cookie\", out);\n  ASSERT_EQ(out.size(), 2);\n  ASSERT_EQ(out[0], \"foo\");\n  ASSERT_EQ(out[1], \"bar\");\n}\n\nTEST(HeaderMapImplTest, DoubleInlineSet) {\n  HeaderMapImpl headers;\n  headers.setReferenceKey(Headers::get().ContentType, \"blah\");\n  headers.setReferenceKey(Headers::get().ContentType, \"text/html\");\n  EXPECT_EQ(\"text/html\", headers.ContentType()->value().getStringView());\n  EXPECT_EQ(1UL, headers.size());\n}\n\nTEST(HeaderMapImplTest, AddReferenceKey) {\n  HeaderMapImpl headers;\n  LowerCaseString foo(\"hello\");\n  headers.addReferenceKey(foo, \"world\");\n  EXPECT_NE(\"world\", headers.get(foo)->value().getStringView().data());\n  EXPECT_EQ(\"world\", headers.get(foo)->value().getStringView());\n}\n\nTEST(HeaderMapImplTest, SetReferenceKey) {\n  HeaderMapImpl headers;\n  LowerCaseString foo(\"hello\");\n  headers.setReferenceKey(foo, \"world\");\n  EXPECT_NE(\"world\", headers.get(foo)->value().getStringView().data());\n  EXPECT_EQ(\"world\", headers.get(foo)->value().getStringView());\n\n  headers.setReferenceKey(foo, \"monde\");\n  EXPECT_NE(\"monde\", headers.get(foo)->value().getStringView().data());\n  EXPECT_EQ(\"monde\", headers.get(foo)->value().getStringView());\n}\n\nTEST(HeaderMapImplTest, AddCopy) {\n  HeaderMapImpl headers;\n\n  // Start with a string value.\n  std::unique_ptr<LowerCaseString> lcKeyPtr(new LowerCaseString(\"hello\"));\n  headers.addCopy(*lcKeyPtr, \"world\");\n\n  const HeaderString& value = headers.get(*lcKeyPtr)->value();\n\n  EXPECT_EQ(\"world\", value.getStringView());\n  EXPECT_EQ(5UL, value.size());\n\n  lcKeyPtr.reset();\n\n  const HeaderString& value2 = headers.get(LowerCaseString(\"hello\"))->value();\n\n  EXPECT_EQ(\"world\", value2.getStringView());\n  EXPECT_EQ(5UL, value2.size());\n  EXPECT_EQ(value.getStringView(), value2.getStringView());\n  EXPECT_EQ(1UL, headers.size());\n\n  // Repeat with an int value.\n  //\n  // addReferenceKey and addCopy can both add multiple instances of a\n  // given header, so we need to delete the old \"hello\" header.\n  headers.remove(LowerCaseString(\"hello\"));\n\n  // Build \"hello\" with string concatenation to make it unlikely that the\n  // compiler is just reusing the same string constant for everything.\n  lcKeyPtr = std::make_unique<LowerCaseString>(std::string(\"he\") + \"llo\");\n  EXPECT_STREQ(\"hello\", lcKeyPtr->get().c_str());\n\n  headers.addCopy(*lcKeyPtr, 42);\n\n  const HeaderString& value3 = headers.get(*lcKeyPtr)->value();\n\n  EXPECT_EQ(\"42\", value3.getStringView());\n  EXPECT_EQ(2UL, value3.size());\n\n  lcKeyPtr.reset();\n\n  const HeaderString& value4 = headers.get(LowerCaseString(\"hello\"))->value();\n\n  EXPECT_EQ(\"42\", value4.getStringView());\n  EXPECT_EQ(2UL, value4.size());\n  EXPECT_EQ(1UL, headers.size());\n\n  // Here, again, we'll build yet another key string.\n  LowerCaseString lcKey3(std::string(\"he\") + \"ll\" + \"o\");\n  EXPECT_STREQ(\"hello\", lcKey3.get().c_str());\n\n  EXPECT_EQ(\"42\", headers.get(lcKey3)->value().getStringView());\n  EXPECT_EQ(2UL, headers.get(lcKey3)->value().size());\n\n  LowerCaseString cache_control(\"cache-control\");\n  headers.addCopy(cache_control, \"max-age=1345\");\n  EXPECT_EQ(\"max-age=1345\", headers.get(cache_control)->value().getStringView());\n  EXPECT_EQ(\"max-age=1345\", headers.CacheControl()->value().getStringView());\n  headers.addCopy(cache_control, \"public\");\n  EXPECT_EQ(\"max-age=1345,public\", headers.get(cache_control)->value().getStringView());\n  headers.addCopy(cache_control, \"\");\n  EXPECT_EQ(\"max-age=1345,public\", headers.get(cache_control)->value().getStringView());\n  headers.addCopy(cache_control, 123);\n  EXPECT_EQ(\"max-age=1345,public,123\", headers.get(cache_control)->value().getStringView());\n  headers.addCopy(cache_control, std::numeric_limits<uint64_t>::max());\n  EXPECT_EQ(\"max-age=1345,public,123,18446744073709551615\",\n            headers.get(cache_control)->value().getStringView());\n}\n\nTEST(HeaderMapImplTest, Equality) {\n  TestHeaderMapImpl headers1;\n  TestHeaderMapImpl headers2;\n  EXPECT_EQ(headers1, headers2);\n\n  headers1.addCopy(\"hello\", \"world\");\n  EXPECT_FALSE(headers1 == headers2);\n\n  headers2.addCopy(\"foo\", \"bar\");\n  EXPECT_FALSE(headers1 == headers2);\n}\n\nTEST(HeaderMapImplTest, LargeCharInHeader) {\n  HeaderMapImpl headers;\n  LowerCaseString static_key(\"\\x90hello\");\n  std::string ref_value(\"value\");\n  headers.addReference(static_key, ref_value);\n  EXPECT_EQ(\"value\", headers.get(static_key)->value().getStringView());\n}\n\nTEST(HeaderMapImplTest, Iterate) {\n  TestHeaderMapImpl headers;\n  headers.addCopy(\"hello\", \"world\");\n  headers.addCopy(\"foo\", \"xxx\");\n  headers.addCopy(\"world\", \"hello\");\n  LowerCaseString foo_key(\"foo\");\n  headers.setReferenceKey(foo_key, \"bar\"); // set moves key to end\n\n  using MockCb = testing::MockFunction<void(const std::string&, const std::string&)>;\n  MockCb cb;\n\n  InSequence seq;\n  EXPECT_CALL(cb, Call(\"hello\", \"world\"));\n  EXPECT_CALL(cb, Call(\"world\", \"hello\"));\n  EXPECT_CALL(cb, Call(\"foo\", \"bar\"));\n  headers.iterate(\n      [](const Http::HeaderEntry& header, void* cb_v) -> HeaderMap::Iterate {\n        static_cast<MockCb*>(cb_v)->Call(std::string(header.key().getStringView()),\n                                         std::string(header.value().getStringView()));\n        return HeaderMap::Iterate::Continue;\n      },\n      &cb);\n}\n\nTEST(HeaderMapImplTest, IterateReverse) {\n  TestHeaderMapImpl headers;\n  headers.addCopy(\"hello\", \"world\");\n  headers.addCopy(\"foo\", \"bar\");\n  LowerCaseString world_key(\"world\");\n  headers.setReferenceKey(world_key, \"hello\");\n\n  using MockCb = testing::MockFunction<void(const std::string&, const std::string&)>;\n  MockCb cb;\n\n  InSequence seq;\n  EXPECT_CALL(cb, Call(\"world\", \"hello\"));\n  EXPECT_CALL(cb, Call(\"foo\", \"bar\"));\n  // no \"hello\"\n  headers.iterateReverse(\n      [](const Http::HeaderEntry& header, void* cb_v) -> HeaderMap::Iterate {\n        static_cast<MockCb*>(cb_v)->Call(std::string(header.key().getStringView()),\n                                         std::string(header.value().getStringView()));\n        if (header.key().getStringView() != \"foo\") {\n          return HeaderMap::Iterate::Continue;\n        } else {\n          return HeaderMap::Iterate::Break;\n        }\n      },\n      &cb);\n}\n\nTEST(HeaderMapImplTest, Lookup) {\n  TestHeaderMapImpl headers;\n  headers.addCopy(\"hello\", \"world\");\n  headers.insertContentLength().value(5);\n\n  // Lookup is not supported for non predefined inline headers.\n  {\n    const HeaderEntry* entry;\n    EXPECT_EQ(HeaderMap::Lookup::NotSupported, headers.lookup(LowerCaseString{\"hello\"}, &entry));\n    EXPECT_EQ(nullptr, entry);\n  }\n\n  // Lookup returns the entry of a predefined inline header if it exists.\n  {\n    const HeaderEntry* entry;\n    EXPECT_EQ(HeaderMap::Lookup::Found, headers.lookup(Headers::get().ContentLength, &entry));\n    EXPECT_EQ(\"5\", entry->value().getStringView());\n  }\n\n  // Lookup returns HeaderMap::Lookup::NotFound if a predefined inline header does not exist.\n  {\n    const HeaderEntry* entry;\n    EXPECT_EQ(HeaderMap::Lookup::NotFound, headers.lookup(Headers::get().Host, &entry));\n    EXPECT_EQ(nullptr, entry);\n  }\n}\n\nTEST(HeaderMapImplTest, Get) {\n  {\n    const TestHeaderMapImpl headers{{\":path\", \"/\"}, {\"hello\", \"world\"}};\n    EXPECT_EQ(\"/\", headers.get(LowerCaseString(\":path\"))->value().getStringView());\n    EXPECT_EQ(\"world\", headers.get(LowerCaseString(\"hello\"))->value().getStringView());\n    EXPECT_EQ(nullptr, headers.get(LowerCaseString(\"foo\")));\n  }\n\n  {\n    TestHeaderMapImpl headers{{\":path\", \"/\"}, {\"hello\", \"world\"}};\n    headers.get(LowerCaseString(\":path\"))->value(std::string(\"/new_path\"));\n    EXPECT_EQ(\"/new_path\", headers.get(LowerCaseString(\":path\"))->value().getStringView());\n    headers.get(LowerCaseString(\"hello\"))->value(std::string(\"world2\"));\n    EXPECT_EQ(\"world2\", headers.get(LowerCaseString(\"hello\"))->value().getStringView());\n    EXPECT_EQ(nullptr, headers.get(LowerCaseString(\"foo\")));\n  }\n}\n\nTEST(HeaderMapImplTest, TestAppendHeader) {\n  // Test appending to a string with a value.\n  {\n    HeaderString value1;\n    value1.setCopy(\"some;\", 5);\n    HeaderMapImpl::appendToHeader(value1, \"test\");\n    EXPECT_EQ(value1, \"some;,test\");\n  }\n\n  // Test appending to an empty string.\n  {\n    HeaderString value2;\n    HeaderMapImpl::appendToHeader(value2, \"my tag data\");\n    EXPECT_EQ(value2, \"my tag data\");\n  }\n\n  // Test empty data case.\n  {\n    HeaderString value3;\n    value3.setCopy(\"empty\", 5);\n    HeaderMapImpl::appendToHeader(value3, \"\");\n    EXPECT_EQ(value3, \"empty\");\n  }\n  // Regression test for appending to an empty string with a short string, then\n  // setting integer.\n  {\n    const std::string empty;\n    HeaderString value4(empty);\n    HeaderMapImpl::appendToHeader(value4, \" \");\n    value4.setInteger(0);\n    EXPECT_EQ(\"0\", value4.getStringView());\n    EXPECT_EQ(1U, value4.size());\n  }\n}\n\nTEST(HeaderMapImplDeathTest, TestHeaderLengthChecks) {\n  HeaderString value;\n  value.setCopy(\"some;\", 5);\n  EXPECT_DEATH_LOG_TO_STDERR(value.append(nullptr, std::numeric_limits<uint32_t>::max()),\n                             \"Trying to allocate overly large headers.\");\n\n  std::string source(\"hello\");\n  HeaderString reference;\n  reference.setReference(source);\n  EXPECT_DEATH_LOG_TO_STDERR(reference.append(nullptr, std::numeric_limits<uint32_t>::max()),\n                             \"Trying to allocate overly large headers.\");\n}\n\nTEST(HeaderMapImplTest, PseudoHeaderOrder) {\n  using MockCb = testing::MockFunction<void(const std::string&, const std::string&)>;\n  MockCb cb;\n\n  {\n    LowerCaseString foo(\"hello\");\n    Http::TestHeaderMapImpl headers{};\n    EXPECT_EQ(0UL, headers.size());\n    EXPECT_TRUE(headers.empty());\n\n    headers.addReferenceKey(foo, \"world\");\n    EXPECT_EQ(1UL, headers.size());\n    EXPECT_FALSE(headers.empty());\n\n    headers.setReferenceKey(Headers::get().ContentType, \"text/html\");\n    EXPECT_EQ(2UL, headers.size());\n    EXPECT_FALSE(headers.empty());\n\n    // Pseudo header gets inserted before non-pseudo headers\n    headers.setReferenceKey(Headers::get().Method, \"PUT\");\n    EXPECT_EQ(3UL, headers.size());\n    EXPECT_FALSE(headers.empty());\n\n    InSequence seq;\n    EXPECT_CALL(cb, Call(\":method\", \"PUT\"));\n    EXPECT_CALL(cb, Call(\"hello\", \"world\"));\n    EXPECT_CALL(cb, Call(\"content-type\", \"text/html\"));\n\n    headers.iterate(\n        [](const Http::HeaderEntry& header, void* cb_v) -> HeaderMap::Iterate {\n          static_cast<MockCb*>(cb_v)->Call(std::string(header.key().getStringView()),\n                                           std::string(header.value().getStringView()));\n          return HeaderMap::Iterate::Continue;\n        },\n        &cb);\n\n    // Removal of the header before which pseudo-headers are inserted\n    headers.remove(foo);\n    EXPECT_EQ(2UL, headers.size());\n    EXPECT_FALSE(headers.empty());\n\n    EXPECT_CALL(cb, Call(\":method\", \"PUT\"));\n    EXPECT_CALL(cb, Call(\"content-type\", \"text/html\"));\n\n    headers.iterate(\n        [](const Http::HeaderEntry& header, void* cb_v) -> HeaderMap::Iterate {\n          static_cast<MockCb*>(cb_v)->Call(std::string(header.key().getStringView()),\n                                           std::string(header.value().getStringView()));\n          return HeaderMap::Iterate::Continue;\n        },\n        &cb);\n\n    // Next pseudo-header goes after other pseudo-headers, but before normal headers\n    headers.setReferenceKey(Headers::get().Path, \"/test\");\n    EXPECT_EQ(3UL, headers.size());\n    EXPECT_FALSE(headers.empty());\n\n    EXPECT_CALL(cb, Call(\":method\", \"PUT\"));\n    EXPECT_CALL(cb, Call(\":path\", \"/test\"));\n    EXPECT_CALL(cb, Call(\"content-type\", \"text/html\"));\n\n    headers.iterate(\n        [](const Http::HeaderEntry& header, void* cb_v) -> HeaderMap::Iterate {\n          static_cast<MockCb*>(cb_v)->Call(std::string(header.key().getStringView()),\n                                           std::string(header.value().getStringView()));\n          return HeaderMap::Iterate::Continue;\n        },\n        &cb);\n\n    // Removing the last normal header\n    headers.remove(Headers::get().ContentType);\n    EXPECT_EQ(2UL, headers.size());\n    EXPECT_FALSE(headers.empty());\n\n    EXPECT_CALL(cb, Call(\":method\", \"PUT\"));\n    EXPECT_CALL(cb, Call(\":path\", \"/test\"));\n\n    headers.iterate(\n        [](const Http::HeaderEntry& header, void* cb_v) -> HeaderMap::Iterate {\n          static_cast<MockCb*>(cb_v)->Call(std::string(header.key().getStringView()),\n                                           std::string(header.value().getStringView()));\n          return HeaderMap::Iterate::Continue;\n        },\n        &cb);\n\n    // Adding a new pseudo-header after removing the last normal header\n    headers.setReferenceKey(Headers::get().Host, \"host\");\n    EXPECT_EQ(3UL, headers.size());\n    EXPECT_FALSE(headers.empty());\n\n    EXPECT_CALL(cb, Call(\":method\", \"PUT\"));\n    EXPECT_CALL(cb, Call(\":path\", \"/test\"));\n    EXPECT_CALL(cb, Call(\":authority\", \"host\"));\n\n    headers.iterate(\n        [](const Http::HeaderEntry& header, void* cb_v) -> HeaderMap::Iterate {\n          static_cast<MockCb*>(cb_v)->Call(std::string(header.key().getStringView()),\n                                           std::string(header.value().getStringView()));\n          return HeaderMap::Iterate::Continue;\n        },\n        &cb);\n\n    // Adding the first normal header\n    headers.setReferenceKey(Headers::get().ContentType, \"text/html\");\n    EXPECT_EQ(4UL, headers.size());\n    EXPECT_FALSE(headers.empty());\n\n    EXPECT_CALL(cb, Call(\":method\", \"PUT\"));\n    EXPECT_CALL(cb, Call(\":path\", \"/test\"));\n    EXPECT_CALL(cb, Call(\":authority\", \"host\"));\n    EXPECT_CALL(cb, Call(\"content-type\", \"text/html\"));\n\n    headers.iterate(\n        [](const Http::HeaderEntry& header, void* cb_v) -> HeaderMap::Iterate {\n          static_cast<MockCb*>(cb_v)->Call(std::string(header.key().getStringView()),\n                                           std::string(header.value().getStringView()));\n          return HeaderMap::Iterate::Continue;\n        },\n        &cb);\n\n    // Removing all pseudo-headers\n    headers.remove(Headers::get().Path);\n    headers.remove(Headers::get().Method);\n    headers.remove(Headers::get().Host);\n    EXPECT_EQ(1UL, headers.size());\n    EXPECT_FALSE(headers.empty());\n\n    EXPECT_CALL(cb, Call(\"content-type\", \"text/html\"));\n\n    headers.iterate(\n        [](const Http::HeaderEntry& header, void* cb_v) -> HeaderMap::Iterate {\n          static_cast<MockCb*>(cb_v)->Call(std::string(header.key().getStringView()),\n                                           std::string(header.value().getStringView()));\n          return HeaderMap::Iterate::Continue;\n        },\n        &cb);\n\n    // Removing all headers\n    headers.remove(Headers::get().ContentType);\n    EXPECT_EQ(0UL, headers.size());\n    EXPECT_TRUE(headers.empty());\n\n    // Adding a lone pseudo-header\n    headers.setReferenceKey(Headers::get().Status, \"200\");\n    EXPECT_EQ(1UL, headers.size());\n    EXPECT_FALSE(headers.empty());\n\n    EXPECT_CALL(cb, Call(\":status\", \"200\"));\n\n    headers.iterate(\n        [](const Http::HeaderEntry& header, void* cb_v) -> HeaderMap::Iterate {\n          static_cast<MockCb*>(cb_v)->Call(std::string(header.key().getStringView()),\n                                           std::string(header.value().getStringView()));\n          return HeaderMap::Iterate::Continue;\n        },\n        &cb);\n  }\n\n  // Starting with a normal header\n  {\n    Http::TestHeaderMapImpl headers{{\"content-type\", \"text/plain\"},\n                                    {\":method\", \"GET\"},\n                                    {\":path\", \"/\"},\n                                    {\"hello\", \"world\"},\n                                    {\":authority\", \"host\"}};\n\n    InSequence seq;\n    EXPECT_CALL(cb, Call(\":method\", \"GET\"));\n    EXPECT_CALL(cb, Call(\":path\", \"/\"));\n    EXPECT_CALL(cb, Call(\":authority\", \"host\"));\n    EXPECT_CALL(cb, Call(\"content-type\", \"text/plain\"));\n    EXPECT_CALL(cb, Call(\"hello\", \"world\"));\n\n    headers.iterate(\n        [](const Http::HeaderEntry& header, void* cb_v) -> HeaderMap::Iterate {\n          static_cast<MockCb*>(cb_v)->Call(std::string(header.key().getStringView()),\n                                           std::string(header.value().getStringView()));\n          return HeaderMap::Iterate::Continue;\n        },\n        &cb);\n  }\n\n  // Starting with a pseudo-header\n  {\n    Http::TestHeaderMapImpl headers{{\":path\", \"/\"},\n                                    {\"content-type\", \"text/plain\"},\n                                    {\":method\", \"GET\"},\n                                    {\"hello\", \"world\"},\n                                    {\":authority\", \"host\"}};\n\n    InSequence seq;\n    EXPECT_CALL(cb, Call(\":path\", \"/\"));\n    EXPECT_CALL(cb, Call(\":method\", \"GET\"));\n    EXPECT_CALL(cb, Call(\":authority\", \"host\"));\n    EXPECT_CALL(cb, Call(\"content-type\", \"text/plain\"));\n    EXPECT_CALL(cb, Call(\"hello\", \"world\"));\n\n    headers.iterate(\n        [](const Http::HeaderEntry& header, void* cb_v) -> HeaderMap::Iterate {\n          static_cast<MockCb*>(cb_v)->Call(std::string(header.key().getStringView()),\n                                           std::string(header.value().getStringView()));\n          return HeaderMap::Iterate::Continue;\n        },\n        &cb);\n  }\n}\n\n// Validate that TestHeaderMapImpl copy construction and assignment works. This is a\n// regression for where we were missing a valid copy constructor and had the\n// default (dangerous) move semantics takeover.\nTEST(HeaderMapImplTest, TestHeaderMapImplyCopy) {\n  TestHeaderMapImpl foo;\n  foo.addCopy(LowerCaseString(\"foo\"), \"bar\");\n  auto headers = std::make_unique<TestHeaderMapImpl>(foo);\n  EXPECT_EQ(\"bar\", headers->get(LowerCaseString(\"foo\"))->value().getStringView());\n  TestHeaderMapImpl baz{{\"foo\", \"baz\"}};\n  baz = *headers;\n  EXPECT_EQ(\"bar\", baz.get(LowerCaseString(\"foo\"))->value().getStringView());\n  const TestHeaderMapImpl& baz2 = baz;\n  baz = baz2;\n  EXPECT_EQ(\"bar\", baz.get(LowerCaseString(\"foo\"))->value().getStringView());\n}\n\n} // namespace Http\n} // namespace Envoy\n", "#include <cstdint>\n#include <string>\n\n#include \"envoy/http/codec.h\"\n#include \"envoy/stats/scope.h\"\n\n#include \"common/http/exception.h\"\n#include \"common/http/header_map_impl.h\"\n#include \"common/http/http2/codec_impl.h\"\n\n#include \"test/common/http/common.h\"\n#include \"test/common/http/http2/http2_frame.h\"\n#include \"test/mocks/http/mocks.h\"\n#include \"test/mocks/network/mocks.h\"\n#include \"test/test_common/printers.h\"\n#include \"test/test_common/test_runtime.h\"\n#include \"test/test_common/utility.h\"\n\n#include \"codec_impl_test_util.h\"\n#include \"gmock/gmock.h\"\n#include \"gtest/gtest.h\"\n\nusing testing::_;\nusing testing::AnyNumber;\nusing testing::AtLeast;\nusing testing::InSequence;\nusing testing::Invoke;\nusing testing::InvokeWithoutArgs;\nusing testing::NiceMock;\nusing testing::Return;\n\nnamespace Envoy {\nnamespace Http {\nnamespace Http2 {\n\nusing Http2SettingsTuple = ::testing::tuple<uint32_t, uint32_t, uint32_t, uint32_t>;\nusing Http2SettingsTestParam = ::testing::tuple<Http2SettingsTuple, Http2SettingsTuple>;\n\nclass Http2CodecImplTestFixture {\npublic:\n  struct ConnectionWrapper {\n    void dispatch(const Buffer::Instance& data, ConnectionImpl& connection) {\n      buffer_.add(data);\n      if (!dispatching_) {\n        while (buffer_.length() > 0) {\n          dispatching_ = true;\n          connection.dispatch(buffer_);\n          dispatching_ = false;\n        }\n      }\n    }\n\n    bool dispatching_{};\n    Buffer::OwnedImpl buffer_;\n  };\n\n  Http2CodecImplTestFixture(Http2SettingsTuple client_settings, Http2SettingsTuple server_settings)\n      : client_settings_(client_settings), server_settings_(server_settings) {}\n  virtual ~Http2CodecImplTestFixture() = default;\n\n  virtual void initialize() {\n    Http2SettingsFromTuple(client_http2settings_, client_settings_);\n    Http2SettingsFromTuple(server_http2settings_, server_settings_);\n    client_ = std::make_unique<TestClientConnectionImpl>(client_connection_, client_callbacks_,\n                                                         stats_store_, client_http2settings_,\n                                                         max_request_headers_kb_);\n    server_ = std::make_unique<TestServerConnectionImpl>(server_connection_, server_callbacks_,\n                                                         stats_store_, server_http2settings_,\n                                                         max_request_headers_kb_);\n\n    request_encoder_ = &client_->newStream(response_decoder_);\n    setupDefaultConnectionMocks();\n\n    EXPECT_CALL(server_callbacks_, newStream(_, _))\n        .WillRepeatedly(Invoke([&](StreamEncoder& encoder, bool) -> StreamDecoder& {\n          response_encoder_ = &encoder;\n          encoder.getStream().addCallbacks(server_stream_callbacks_);\n          return request_decoder_;\n        }));\n  }\n\n  void setupDefaultConnectionMocks() {\n    ON_CALL(client_connection_, write(_, _))\n        .WillByDefault(Invoke([&](Buffer::Instance& data, bool) -> void {\n          if (corrupt_metadata_frame_) {\n            corruptMetadataFramePayload(data);\n          }\n          server_wrapper_.dispatch(data, *server_);\n        }));\n    ON_CALL(server_connection_, write(_, _))\n        .WillByDefault(Invoke([&](Buffer::Instance& data, bool) -> void {\n          client_wrapper_.dispatch(data, *client_);\n        }));\n  }\n\n  void Http2SettingsFromTuple(Http2Settings& setting, const Http2SettingsTuple& tp) {\n    setting.hpack_table_size_ = ::testing::get<0>(tp);\n    setting.max_concurrent_streams_ = ::testing::get<1>(tp);\n    setting.initial_stream_window_size_ = ::testing::get<2>(tp);\n    setting.initial_connection_window_size_ = ::testing::get<3>(tp);\n    setting.allow_metadata_ = allow_metadata_;\n    setting.stream_error_on_invalid_http_messaging_ = stream_error_on_invalid_http_messaging_;\n    setting.max_outbound_frames_ = max_outbound_frames_;\n    setting.max_outbound_control_frames_ = max_outbound_control_frames_;\n    setting.max_consecutive_inbound_frames_with_empty_payload_ =\n        max_consecutive_inbound_frames_with_empty_payload_;\n    setting.max_inbound_priority_frames_per_stream_ = max_inbound_priority_frames_per_stream_;\n    setting.max_inbound_window_update_frames_per_data_frame_sent_ =\n        max_inbound_window_update_frames_per_data_frame_sent_;\n  }\n\n  // corruptMetadataFramePayload assumes data contains at least 10 bytes of the beginning of a\n  // frame.\n  void corruptMetadataFramePayload(Buffer::Instance& data) {\n    const size_t length = data.length();\n    const size_t corrupt_start = 10;\n    if (length < corrupt_start || length > METADATA_MAX_PAYLOAD_SIZE) {\n      ENVOY_LOG_MISC(error, \"data size too big or too small\");\n      return;\n    }\n    corruptAtOffset(data, corrupt_start, 0xff);\n  }\n\n  void corruptAtOffset(Buffer::Instance& data, size_t index, char new_value) {\n    if (data.length() == 0) {\n      return;\n    }\n    reinterpret_cast<uint8_t*>(data.linearize(data.length()))[index % data.length()] = new_value;\n  }\n\n  const Http2SettingsTuple client_settings_;\n  const Http2SettingsTuple server_settings_;\n  bool allow_metadata_ = false;\n  bool stream_error_on_invalid_http_messaging_ = false;\n  Stats::IsolatedStoreImpl stats_store_;\n  Http2Settings client_http2settings_;\n  NiceMock<Network::MockConnection> client_connection_;\n  MockConnectionCallbacks client_callbacks_;\n  std::unique_ptr<TestClientConnectionImpl> client_;\n  ConnectionWrapper client_wrapper_;\n  Http2Settings server_http2settings_;\n  NiceMock<Network::MockConnection> server_connection_;\n  MockServerConnectionCallbacks server_callbacks_;\n  std::unique_ptr<TestServerConnectionImpl> server_;\n  ConnectionWrapper server_wrapper_;\n  MockStreamDecoder response_decoder_;\n  StreamEncoder* request_encoder_;\n  MockStreamDecoder request_decoder_;\n  StreamEncoder* response_encoder_{};\n  MockStreamCallbacks server_stream_callbacks_;\n  // Corrupt a metadata frame payload.\n  bool corrupt_metadata_frame_ = false;\n\n  uint32_t max_request_headers_kb_ = Http::DEFAULT_MAX_REQUEST_HEADERS_KB;\n  uint32_t max_outbound_frames_ = Http2Settings::DEFAULT_MAX_OUTBOUND_FRAMES;\n  uint32_t max_outbound_control_frames_ = Http2Settings::DEFAULT_MAX_OUTBOUND_CONTROL_FRAMES;\n  uint32_t max_consecutive_inbound_frames_with_empty_payload_ =\n      Http2Settings::DEFAULT_MAX_CONSECUTIVE_INBOUND_FRAMES_WITH_EMPTY_PAYLOAD;\n  uint32_t max_inbound_priority_frames_per_stream_ =\n      Http2Settings::DEFAULT_MAX_INBOUND_PRIORITY_FRAMES_PER_STREAM;\n  uint32_t max_inbound_window_update_frames_per_data_frame_sent_ =\n      Http2Settings::DEFAULT_MAX_INBOUND_WINDOW_UPDATE_FRAMES_PER_DATA_FRAME_SENT;\n};\n\nclass Http2CodecImplTest : public ::testing::TestWithParam<Http2SettingsTestParam>,\n                           protected Http2CodecImplTestFixture {\npublic:\n  Http2CodecImplTest()\n      : Http2CodecImplTestFixture(::testing::get<0>(GetParam()), ::testing::get<1>(GetParam())) {}\n\nprotected:\n  void priorityFlood() {\n    initialize();\n\n    TestHeaderMapImpl request_headers;\n    HttpTestUtility::addDefaultHeaders(request_headers, \"POST\");\n    EXPECT_CALL(request_decoder_, decodeHeaders_(_, false));\n    request_encoder_->encodeHeaders(request_headers, false);\n\n    nghttp2_priority_spec spec = {0, 10, 0};\n    // HTTP/2 codec adds 1 to the number of active streams when computing PRIORITY frames limit\n    constexpr uint32_t max_allowed =\n        2 * Http2Settings::DEFAULT_MAX_INBOUND_PRIORITY_FRAMES_PER_STREAM;\n    for (uint32_t i = 0; i < max_allowed + 1; ++i) {\n      EXPECT_EQ(0, nghttp2_submit_priority(client_->session(), NGHTTP2_FLAG_NONE, 1, &spec));\n    }\n  }\n\n  void windowUpdateFlood() {\n    initialize();\n\n    TestHeaderMapImpl request_headers;\n    HttpTestUtility::addDefaultHeaders(request_headers);\n    EXPECT_CALL(request_decoder_, decodeHeaders_(_, true));\n    request_encoder_->encodeHeaders(request_headers, true);\n\n    // Send one DATA frame back\n    EXPECT_CALL(response_decoder_, decodeHeaders_(_, false));\n    EXPECT_CALL(response_decoder_, decodeData(_, false));\n    TestHeaderMapImpl response_headers{{\":status\", \"200\"}};\n    response_encoder_->encodeHeaders(response_headers, false);\n    Buffer::OwnedImpl data(\"0\");\n    EXPECT_NO_THROW(response_encoder_->encodeData(data, false));\n\n    // See the limit formula in the\n    // `Envoy::Http::Http2::ServerConnectionImpl::checkInboundFrameLimits()' method.\n    constexpr uint32_t max_allowed =\n        1 + 2 * (Http2Settings::DEFAULT_MAX_INBOUND_WINDOW_UPDATE_FRAMES_PER_DATA_FRAME_SENT + 1);\n    for (uint32_t i = 0; i < max_allowed + 1; ++i) {\n      EXPECT_EQ(0, nghttp2_submit_window_update(client_->session(), NGHTTP2_FLAG_NONE, 1, 1));\n    }\n  }\n\n  void emptyDataFlood(Buffer::OwnedImpl& data) {\n    initialize();\n\n    TestHeaderMapImpl request_headers;\n    HttpTestUtility::addDefaultHeaders(request_headers, \"POST\");\n    EXPECT_CALL(request_decoder_, decodeHeaders_(_, false));\n    request_encoder_->encodeHeaders(request_headers, false);\n\n    // HTTP/2 codec does not send empty DATA frames with no END_STREAM flag.\n    // To make this work, send raw bytes representing empty DATA frames bypassing client codec.\n    Http2Frame emptyDataFrame = Http2Frame::makeEmptyDataFrame(0);\n    constexpr uint32_t max_allowed =\n        Http2Settings::DEFAULT_MAX_CONSECUTIVE_INBOUND_FRAMES_WITH_EMPTY_PAYLOAD;\n    for (uint32_t i = 0; i < max_allowed + 1; ++i) {\n      data.add(emptyDataFrame.data(), emptyDataFrame.size());\n    }\n  }\n\n  // Make sure the test fixture has a fake runtime, for the tests which use\n  // Runtime::LoaderSingleton::getExisting()->mergeValues(...)\n  TestScopedRuntime scoped_runtime_;\n};\n\nTEST_P(Http2CodecImplTest, ShutdownNotice) {\n  initialize();\n\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  EXPECT_CALL(request_decoder_, decodeHeaders_(_, true));\n  request_encoder_->encodeHeaders(request_headers, true);\n\n  EXPECT_CALL(client_callbacks_, onGoAway());\n  server_->shutdownNotice();\n  server_->goAway();\n\n  TestHeaderMapImpl response_headers{{\":status\", \"200\"}};\n  EXPECT_CALL(response_decoder_, decodeHeaders_(_, true));\n  response_encoder_->encodeHeaders(response_headers, true);\n}\n\nTEST_P(Http2CodecImplTest, ContinueHeaders) {\n  initialize();\n\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  EXPECT_CALL(request_decoder_, decodeHeaders_(_, true));\n  request_encoder_->encodeHeaders(request_headers, true);\n\n  TestHeaderMapImpl continue_headers{{\":status\", \"100\"}};\n  EXPECT_CALL(response_decoder_, decode100ContinueHeaders_(_));\n  response_encoder_->encode100ContinueHeaders(continue_headers);\n\n  TestHeaderMapImpl response_headers{{\":status\", \"200\"}};\n  EXPECT_CALL(response_decoder_, decodeHeaders_(_, true));\n  response_encoder_->encodeHeaders(response_headers, true);\n};\n\nTEST_P(Http2CodecImplTest, InvalidContinueWithFin) {\n  initialize();\n\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  EXPECT_CALL(request_decoder_, decodeHeaders_(_, true));\n  request_encoder_->encodeHeaders(request_headers, true);\n\n  TestHeaderMapImpl continue_headers{{\":status\", \"100\"}};\n  EXPECT_THROW(response_encoder_->encodeHeaders(continue_headers, true), CodecProtocolException);\n  EXPECT_EQ(1, stats_store_.counter(\"http2.rx_messaging_error\").value());\n}\n\nTEST_P(Http2CodecImplTest, InvalidContinueWithFinAllowed) {\n  stream_error_on_invalid_http_messaging_ = true;\n  initialize();\n\n  MockStreamCallbacks request_callbacks;\n  request_encoder_->getStream().addCallbacks(request_callbacks);\n\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  EXPECT_CALL(request_decoder_, decodeHeaders_(_, true));\n  request_encoder_->encodeHeaders(request_headers, true);\n\n  // Buffer client data to avoid mock recursion causing lifetime issues.\n  ON_CALL(server_connection_, write(_, _))\n      .WillByDefault(\n          Invoke([&](Buffer::Instance& data, bool) -> void { client_wrapper_.buffer_.add(data); }));\n\n  TestHeaderMapImpl continue_headers{{\":status\", \"100\"}};\n  response_encoder_->encodeHeaders(continue_headers, true);\n\n  // Flush pending data.\n  EXPECT_CALL(request_callbacks, onResetStream(StreamResetReason::LocalReset, _));\n  setupDefaultConnectionMocks();\n  client_wrapper_.dispatch(Buffer::OwnedImpl(), *client_);\n\n  EXPECT_EQ(1, stats_store_.counter(\"http2.rx_messaging_error\").value());\n}\n\nTEST_P(Http2CodecImplTest, InvalidRepeatContinue) {\n  initialize();\n\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  EXPECT_CALL(request_decoder_, decodeHeaders_(_, true));\n  request_encoder_->encodeHeaders(request_headers, true);\n\n  TestHeaderMapImpl continue_headers{{\":status\", \"100\"}};\n  EXPECT_CALL(response_decoder_, decode100ContinueHeaders_(_));\n  response_encoder_->encode100ContinueHeaders(continue_headers);\n\n  EXPECT_THROW(response_encoder_->encodeHeaders(continue_headers, true), CodecProtocolException);\n  EXPECT_EQ(1, stats_store_.counter(\"http2.rx_messaging_error\").value());\n};\n\nTEST_P(Http2CodecImplTest, InvalidRepeatContinueAllowed) {\n  stream_error_on_invalid_http_messaging_ = true;\n  initialize();\n\n  MockStreamCallbacks request_callbacks;\n  request_encoder_->getStream().addCallbacks(request_callbacks);\n\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  EXPECT_CALL(request_decoder_, decodeHeaders_(_, true));\n  request_encoder_->encodeHeaders(request_headers, true);\n\n  TestHeaderMapImpl continue_headers{{\":status\", \"100\"}};\n  EXPECT_CALL(response_decoder_, decode100ContinueHeaders_(_));\n  response_encoder_->encode100ContinueHeaders(continue_headers);\n\n  // Buffer client data to avoid mock recursion causing lifetime issues.\n  ON_CALL(server_connection_, write(_, _))\n      .WillByDefault(\n          Invoke([&](Buffer::Instance& data, bool) -> void { client_wrapper_.buffer_.add(data); }));\n\n  response_encoder_->encodeHeaders(continue_headers, true);\n\n  // Flush pending data.\n  EXPECT_CALL(request_callbacks, onResetStream(StreamResetReason::LocalReset, _));\n  setupDefaultConnectionMocks();\n  client_wrapper_.dispatch(Buffer::OwnedImpl(), *client_);\n\n  EXPECT_EQ(1, stats_store_.counter(\"http2.rx_messaging_error\").value());\n};\n\nTEST_P(Http2CodecImplTest, Invalid103) {\n  initialize();\n\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  EXPECT_CALL(request_decoder_, decodeHeaders_(_, true));\n  request_encoder_->encodeHeaders(request_headers, true);\n\n  TestHeaderMapImpl continue_headers{{\":status\", \"100\"}};\n  EXPECT_CALL(response_decoder_, decode100ContinueHeaders_(_));\n  response_encoder_->encode100ContinueHeaders(continue_headers);\n\n  TestHeaderMapImpl early_hint_headers{{\":status\", \"103\"}};\n  EXPECT_CALL(response_decoder_, decodeHeaders_(_, false));\n  response_encoder_->encodeHeaders(early_hint_headers, false);\n\n  EXPECT_THROW_WITH_MESSAGE(response_encoder_->encodeHeaders(early_hint_headers, false),\n                            CodecProtocolException, \"Unexpected 'trailers' with no end stream.\");\n  EXPECT_EQ(1, stats_store_.counter(\"http2.too_many_header_frames\").value());\n}\n\nTEST_P(Http2CodecImplTest, Invalid204WithContentLength) {\n  initialize();\n\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  EXPECT_CALL(request_decoder_, decodeHeaders_(_, true));\n  request_encoder_->encodeHeaders(request_headers, true);\n\n  TestHeaderMapImpl response_headers{{\":status\", \"204\"}, {\"content-length\", \"3\"}};\n  // What follows is a hack to get headers that should span into continuation frames. The default\n  // maximum frame size is 16K. We will add 3,000 headers that will take us above this size and\n  // not easily compress with HPACK. (I confirmed this generates 26,468 bytes of header data\n  // which should contain a continuation.)\n  for (uint i = 1; i < 3000; i++) {\n    response_headers.addCopy(std::to_string(i), std::to_string(i));\n  }\n\n  EXPECT_THROW(response_encoder_->encodeHeaders(response_headers, false), CodecProtocolException);\n  EXPECT_EQ(1, stats_store_.counter(\"http2.rx_messaging_error\").value());\n};\n\nTEST_P(Http2CodecImplTest, Invalid204WithContentLengthAllowed) {\n  stream_error_on_invalid_http_messaging_ = true;\n  initialize();\n\n  MockStreamCallbacks request_callbacks;\n  request_encoder_->getStream().addCallbacks(request_callbacks);\n\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  EXPECT_CALL(request_decoder_, decodeHeaders_(_, true));\n  request_encoder_->encodeHeaders(request_headers, true);\n\n  // Buffer client data to avoid mock recursion causing lifetime issues.\n  ON_CALL(server_connection_, write(_, _))\n      .WillByDefault(\n          Invoke([&](Buffer::Instance& data, bool) -> void { client_wrapper_.buffer_.add(data); }));\n\n  TestHeaderMapImpl response_headers{{\":status\", \"204\"}, {\"content-length\", \"3\"}};\n  // What follows is a hack to get headers that should span into continuation frames. The default\n  // maximum frame size is 16K. We will add 3,000 headers that will take us above this size and\n  // not easily compress with HPACK. (I confirmed this generates 26,468 bytes of header data\n  // which should contain a continuation.)\n  for (uint i = 1; i < 3000; i++) {\n    response_headers.addCopy(std::to_string(i), std::to_string(i));\n  }\n\n  response_encoder_->encodeHeaders(response_headers, false);\n\n  // Flush pending data.\n  EXPECT_CALL(request_callbacks, onResetStream(StreamResetReason::LocalReset, _));\n  EXPECT_CALL(server_stream_callbacks_, onResetStream(StreamResetReason::RemoteReset, _));\n  setupDefaultConnectionMocks();\n  client_wrapper_.dispatch(Buffer::OwnedImpl(), *client_);\n\n  EXPECT_EQ(1, stats_store_.counter(\"http2.rx_messaging_error\").value());\n};\n\nTEST_P(Http2CodecImplTest, RefusedStreamReset) {\n  initialize();\n\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  EXPECT_CALL(request_decoder_, decodeHeaders_(_, false));\n  request_encoder_->encodeHeaders(request_headers, false);\n\n  MockStreamCallbacks callbacks;\n  request_encoder_->getStream().addCallbacks(callbacks);\n  EXPECT_CALL(server_stream_callbacks_,\n              onResetStream(StreamResetReason::LocalRefusedStreamReset, _));\n  EXPECT_CALL(callbacks, onResetStream(StreamResetReason::RemoteRefusedStreamReset, _));\n  response_encoder_->getStream().resetStream(StreamResetReason::LocalRefusedStreamReset);\n}\n\nTEST_P(Http2CodecImplTest, InvalidHeadersFrame) {\n  initialize();\n\n  EXPECT_THROW(request_encoder_->encodeHeaders(TestHeaderMapImpl{}, true), CodecProtocolException);\n  EXPECT_EQ(1, stats_store_.counter(\"http2.rx_messaging_error\").value());\n}\n\nTEST_P(Http2CodecImplTest, InvalidHeadersFrameAllowed) {\n  stream_error_on_invalid_http_messaging_ = true;\n  initialize();\n\n  MockStreamCallbacks request_callbacks;\n  request_encoder_->getStream().addCallbacks(request_callbacks);\n\n  ON_CALL(client_connection_, write(_, _))\n      .WillByDefault(\n          Invoke([&](Buffer::Instance& data, bool) -> void { server_wrapper_.buffer_.add(data); }));\n\n  request_encoder_->encodeHeaders(TestHeaderMapImpl{}, true);\n  EXPECT_CALL(server_stream_callbacks_, onResetStream(StreamResetReason::LocalReset, _));\n  EXPECT_CALL(request_callbacks, onResetStream(StreamResetReason::RemoteReset, _));\n  server_wrapper_.dispatch(Buffer::OwnedImpl(), *server_);\n}\n\nTEST_P(Http2CodecImplTest, InvalidHeadersFrameOverriden) {\n  Runtime::LoaderSingleton::getExisting()->mergeValues(\n      {{\"envoy.reloadable_features.http2_protocol_options.stream_error_on_invalid_http_messaging\",\n        \"true\"}});\n  initialize();\n\n  MockStreamCallbacks request_callbacks;\n  request_encoder_->getStream().addCallbacks(request_callbacks);\n\n  ON_CALL(client_connection_, write(_, _))\n      .WillByDefault(\n          Invoke([&](Buffer::Instance& data, bool) -> void { server_wrapper_.buffer_.add(data); }));\n\n  request_encoder_->encodeHeaders(TestHeaderMapImpl{}, true);\n  EXPECT_CALL(server_stream_callbacks_, onResetStream(StreamResetReason::LocalReset, _));\n  EXPECT_CALL(request_callbacks, onResetStream(StreamResetReason::RemoteReset, _));\n  server_wrapper_.dispatch(Buffer::OwnedImpl(), *server_);\n}\n\nTEST_P(Http2CodecImplTest, TrailingHeaders) {\n  initialize();\n\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  EXPECT_CALL(request_decoder_, decodeHeaders_(_, false));\n  request_encoder_->encodeHeaders(request_headers, false);\n  EXPECT_CALL(request_decoder_, decodeData(_, false));\n  Buffer::OwnedImpl hello(\"hello\");\n  request_encoder_->encodeData(hello, false);\n  EXPECT_CALL(request_decoder_, decodeTrailers_(_));\n  request_encoder_->encodeTrailers(TestHeaderMapImpl{{\"trailing\", \"header\"}});\n\n  TestHeaderMapImpl response_headers{{\":status\", \"200\"}};\n  EXPECT_CALL(response_decoder_, decodeHeaders_(_, false));\n  response_encoder_->encodeHeaders(response_headers, false);\n  EXPECT_CALL(response_decoder_, decodeData(_, false));\n  Buffer::OwnedImpl world(\"world\");\n  response_encoder_->encodeData(world, false);\n  EXPECT_CALL(response_decoder_, decodeTrailers_(_));\n  response_encoder_->encodeTrailers(TestHeaderMapImpl{{\"trailing\", \"header\"}});\n}\n\nTEST_P(Http2CodecImplTest, TrailingHeadersLargeBody) {\n  initialize();\n\n  // Buffer server data so we can make sure we don't get any window updates.\n  ON_CALL(client_connection_, write(_, _))\n      .WillByDefault(\n          Invoke([&](Buffer::Instance& data, bool) -> void { server_wrapper_.buffer_.add(data); }));\n\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  EXPECT_CALL(request_decoder_, decodeHeaders_(_, false));\n  request_encoder_->encodeHeaders(request_headers, false);\n  EXPECT_CALL(request_decoder_, decodeData(_, false)).Times(AtLeast(1));\n  Buffer::OwnedImpl body(std::string(1024 * 1024, 'a'));\n  request_encoder_->encodeData(body, false);\n  EXPECT_CALL(request_decoder_, decodeTrailers_(_));\n  request_encoder_->encodeTrailers(TestHeaderMapImpl{{\"trailing\", \"header\"}});\n\n  // Flush pending data.\n  setupDefaultConnectionMocks();\n  server_wrapper_.dispatch(Buffer::OwnedImpl(), *server_);\n\n  TestHeaderMapImpl response_headers{{\":status\", \"200\"}};\n  EXPECT_CALL(response_decoder_, decodeHeaders_(_, false));\n  response_encoder_->encodeHeaders(response_headers, false);\n  EXPECT_CALL(response_decoder_, decodeData(_, false));\n  Buffer::OwnedImpl world(\"world\");\n  response_encoder_->encodeData(world, false);\n  EXPECT_CALL(response_decoder_, decodeTrailers_(_));\n  response_encoder_->encodeTrailers(TestHeaderMapImpl{{\"trailing\", \"header\"}});\n}\n\nTEST_P(Http2CodecImplTest, SmallMetadataVecTest) {\n  allow_metadata_ = true;\n  initialize();\n\n  // Generates a valid stream_id by sending a request header.\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  EXPECT_CALL(request_decoder_, decodeHeaders_(_, true));\n  request_encoder_->encodeHeaders(request_headers, true);\n\n  MetadataMapVector metadata_map_vector;\n  const int size = 10;\n  for (int i = 0; i < size; i++) {\n    MetadataMap metadata_map = {\n        {\"header_key1\", \"header_value1\"},\n        {\"header_key2\", \"header_value2\"},\n        {\"header_key3\", \"header_value3\"},\n        {\"header_key4\", \"header_value4\"},\n    };\n    MetadataMapPtr metadata_map_ptr = std::make_unique<MetadataMap>(metadata_map);\n    metadata_map_vector.push_back(std::move(metadata_map_ptr));\n  }\n\n  EXPECT_CALL(request_decoder_, decodeMetadata_(_)).Times(size);\n  request_encoder_->encodeMetadata(metadata_map_vector);\n\n  EXPECT_CALL(response_decoder_, decodeMetadata_(_)).Times(size);\n  response_encoder_->encodeMetadata(metadata_map_vector);\n}\n\nTEST_P(Http2CodecImplTest, LargeMetadataVecTest) {\n  allow_metadata_ = true;\n  initialize();\n\n  // Generates a valid stream_id by sending a request header.\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  EXPECT_CALL(request_decoder_, decodeHeaders_(_, true));\n  request_encoder_->encodeHeaders(request_headers, true);\n\n  MetadataMapVector metadata_map_vector;\n  const int size = 10;\n  for (int i = 0; i < size; i++) {\n    MetadataMap metadata_map = {\n        {\"header_key1\", std::string(50 * 1024, 'a')},\n    };\n    MetadataMapPtr metadata_map_ptr = std::make_unique<MetadataMap>(metadata_map);\n    metadata_map_vector.push_back(std::move(metadata_map_ptr));\n  }\n\n  EXPECT_CALL(request_decoder_, decodeMetadata_(_)).Times(size);\n  request_encoder_->encodeMetadata(metadata_map_vector);\n\n  EXPECT_CALL(response_decoder_, decodeMetadata_(_)).Times(size);\n  response_encoder_->encodeMetadata(metadata_map_vector);\n}\n\nTEST_P(Http2CodecImplTest, BadMetadataVecReceivedTest) {\n  allow_metadata_ = true;\n  initialize();\n\n  // Generates a valid stream_id by sending a request header.\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  EXPECT_CALL(request_decoder_, decodeHeaders_(_, true));\n  request_encoder_->encodeHeaders(request_headers, true);\n\n  MetadataMap metadata_map = {\n      {\"header_key1\", \"header_value1\"},\n      {\"header_key2\", \"header_value2\"},\n      {\"header_key3\", \"header_value3\"},\n      {\"header_key4\", \"header_value4\"},\n  };\n  MetadataMapPtr metadata_map_ptr = std::make_unique<MetadataMap>(metadata_map);\n  MetadataMapVector metadata_map_vector;\n  metadata_map_vector.push_back(std::move(metadata_map_ptr));\n\n  corrupt_metadata_frame_ = true;\n  EXPECT_THROW_WITH_MESSAGE(request_encoder_->encodeMetadata(metadata_map_vector), EnvoyException,\n                            \"The user callback function failed\");\n}\nclass Http2CodecImplDeferredResetTest : public Http2CodecImplTest {};\n\nTEST_P(Http2CodecImplDeferredResetTest, DeferredResetClient) {\n  initialize();\n\n  InSequence s;\n\n  MockStreamCallbacks client_stream_callbacks;\n  request_encoder_->getStream().addCallbacks(client_stream_callbacks);\n\n  // Do a request, but pause server dispatch so we don't send window updates. This will result in a\n  // deferred reset, followed by a pending frames flush which will cause the stream to actually\n  // be reset immediately since we are outside of dispatch context.\n  ON_CALL(client_connection_, write(_, _))\n      .WillByDefault(\n          Invoke([&](Buffer::Instance& data, bool) -> void { server_wrapper_.buffer_.add(data); }));\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  request_encoder_->encodeHeaders(request_headers, false);\n  Buffer::OwnedImpl body(std::string(1024 * 1024, 'a'));\n  EXPECT_CALL(client_stream_callbacks, onAboveWriteBufferHighWatermark()).Times(AnyNumber());\n  request_encoder_->encodeData(body, true);\n  EXPECT_CALL(client_stream_callbacks, onResetStream(StreamResetReason::LocalReset, _));\n  request_encoder_->getStream().resetStream(StreamResetReason::LocalReset);\n\n  // Dispatch server. We expect to see some data.\n  EXPECT_CALL(response_decoder_, decodeHeaders_(_, _)).Times(0);\n  EXPECT_CALL(request_decoder_, decodeHeaders_(_, false)).WillOnce(InvokeWithoutArgs([&]() -> void {\n    // Start a response inside the headers callback. This should not result in the client\n    // seeing any headers as the stream should already be reset on the other side, even though\n    // we don't know about it yet.\n    TestHeaderMapImpl response_headers{{\":status\", \"200\"}};\n    response_encoder_->encodeHeaders(response_headers, false);\n  }));\n  EXPECT_CALL(request_decoder_, decodeData(_, false)).Times(AtLeast(1));\n  EXPECT_CALL(server_stream_callbacks_, onResetStream(StreamResetReason::RemoteReset, _));\n\n  setupDefaultConnectionMocks();\n  server_wrapper_.dispatch(Buffer::OwnedImpl(), *server_);\n}\n\nTEST_P(Http2CodecImplDeferredResetTest, DeferredResetServer) {\n  initialize();\n\n  InSequence s;\n\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  EXPECT_CALL(request_decoder_, decodeHeaders_(_, false));\n  request_encoder_->encodeHeaders(request_headers, false);\n\n  // In this case we do the same thing as DeferredResetClient but on the server side.\n  ON_CALL(server_connection_, write(_, _))\n      .WillByDefault(\n          Invoke([&](Buffer::Instance& data, bool) -> void { client_wrapper_.buffer_.add(data); }));\n  TestHeaderMapImpl response_headers{{\":status\", \"200\"}};\n  response_encoder_->encodeHeaders(response_headers, false);\n  Buffer::OwnedImpl body(std::string(1024 * 1024, 'a'));\n  EXPECT_CALL(server_stream_callbacks_, onAboveWriteBufferHighWatermark()).Times(AnyNumber());\n  response_encoder_->encodeData(body, true);\n  EXPECT_CALL(server_stream_callbacks_, onResetStream(StreamResetReason::LocalReset, _));\n  response_encoder_->getStream().resetStream(StreamResetReason::LocalReset);\n\n  MockStreamCallbacks client_stream_callbacks;\n  request_encoder_->getStream().addCallbacks(client_stream_callbacks);\n  EXPECT_CALL(response_decoder_, decodeHeaders_(_, false));\n  EXPECT_CALL(response_decoder_, decodeData(_, false)).Times(AtLeast(1));\n  EXPECT_CALL(client_stream_callbacks, onResetStream(StreamResetReason::RemoteReset, _));\n  setupDefaultConnectionMocks();\n  client_wrapper_.dispatch(Buffer::OwnedImpl(), *client_);\n}\n\nclass Http2CodecImplFlowControlTest : public Http2CodecImplTest {};\n\n// Back up the pending_sent_data_ buffer in the client connection and make sure the watermarks fire\n// as expected.\n//\n// This also tests the readDisable logic in StreamImpl, verifying that h2 bytes are consumed\n// when the stream has readDisable(true) called.\nTEST_P(Http2CodecImplFlowControlTest, TestFlowControlInPendingSendData) {\n  initialize();\n  MockStreamCallbacks callbacks;\n  request_encoder_->getStream().addCallbacks(callbacks);\n\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  TestHeaderMapImpl expected_headers;\n  HttpTestUtility::addDefaultHeaders(expected_headers);\n  EXPECT_CALL(request_decoder_, decodeHeaders_(HeaderMapEqual(&expected_headers), false));\n  request_encoder_->encodeHeaders(request_headers, false);\n\n  // Force the server stream to be read disabled. This will cause it to stop sending window\n  // updates to the client.\n  server_->getStream(1)->readDisable(true);\n\n  uint32_t initial_stream_window =\n      nghttp2_session_get_stream_effective_local_window_size(client_->session(), 1);\n  // If this limit is changed, this test will fail due to the initial large writes being divided\n  // into more than 4 frames. Fast fail here with this explanatory comment.\n  ASSERT_EQ(65535, initial_stream_window);\n  // Make sure the limits were configured properly in test set up.\n  EXPECT_EQ(initial_stream_window, server_->getStream(1)->bufferLimit());\n  EXPECT_EQ(initial_stream_window, client_->getStream(1)->bufferLimit());\n\n  // One large write gets broken into smaller frames.\n  EXPECT_CALL(request_decoder_, decodeData(_, false)).Times(AnyNumber());\n  Buffer::OwnedImpl long_data(std::string(initial_stream_window, 'a'));\n  request_encoder_->encodeData(long_data, false);\n\n  // Verify that the window is full. The client will not send more data to the server for this\n  // stream.\n  EXPECT_EQ(0, nghttp2_session_get_stream_local_window_size(server_->session(), 1));\n  EXPECT_EQ(0, nghttp2_session_get_stream_remote_window_size(client_->session(), 1));\n  EXPECT_EQ(initial_stream_window, server_->getStream(1)->unconsumed_bytes_);\n\n  // Now that the flow control window is full, further data causes the send buffer to back up.\n  Buffer::OwnedImpl more_long_data(std::string(initial_stream_window, 'a'));\n  request_encoder_->encodeData(more_long_data, false);\n  EXPECT_EQ(initial_stream_window, client_->getStream(1)->pending_send_data_.length());\n  EXPECT_EQ(initial_stream_window, server_->getStream(1)->unconsumed_bytes_);\n\n  // If we go over the limit, the stream callbacks should fire.\n  EXPECT_CALL(callbacks, onAboveWriteBufferHighWatermark());\n  Buffer::OwnedImpl last_byte(\"!\");\n  request_encoder_->encodeData(last_byte, false);\n  EXPECT_EQ(initial_stream_window + 1, client_->getStream(1)->pending_send_data_.length());\n\n  // Now create a second stream on the connection.\n  MockStreamDecoder response_decoder2;\n  StreamEncoder* request_encoder2 = &client_->newStream(response_decoder_);\n  StreamEncoder* response_encoder2;\n  MockStreamCallbacks server_stream_callbacks2;\n  MockStreamDecoder request_decoder2;\n  // When the server stream is created it should check the status of the\n  // underlying connection. Pretend it is overrun.\n  EXPECT_CALL(server_connection_, aboveHighWatermark()).WillOnce(Return(true));\n  EXPECT_CALL(server_stream_callbacks2, onAboveWriteBufferHighWatermark());\n  EXPECT_CALL(server_callbacks_, newStream(_, _))\n      .WillOnce(Invoke([&](StreamEncoder& encoder, bool) -> StreamDecoder& {\n        response_encoder2 = &encoder;\n        encoder.getStream().addCallbacks(server_stream_callbacks2);\n        return request_decoder2;\n      }));\n  EXPECT_CALL(request_decoder2, decodeHeaders_(_, false));\n  request_encoder2->encodeHeaders(request_headers, false);\n\n  // Add the stream callbacks belatedly. On creation the stream should have\n  // been noticed that the connection was backed up. Any new subscriber to\n  // stream callbacks should get a callback when they addCallbacks.\n  MockStreamCallbacks callbacks2;\n  EXPECT_CALL(callbacks2, onAboveWriteBufferHighWatermark());\n  request_encoder_->getStream().addCallbacks(callbacks2);\n\n  // Add a third callback to make testing removal mid-watermark call below more interesting.\n  MockStreamCallbacks callbacks3;\n  EXPECT_CALL(callbacks3, onAboveWriteBufferHighWatermark());\n  request_encoder_->getStream().addCallbacks(callbacks3);\n\n  // Now unblock the server's stream. This will cause the bytes to be consumed, flow control\n  // updates to be sent, and the client to flush all queued data.\n  // For bonus corner case coverage, remove callback2 in the middle of runLowWatermarkCallbacks()\n  // and ensure it is not called.\n  EXPECT_CALL(callbacks, onBelowWriteBufferLowWatermark()).WillOnce(Invoke([&]() -> void {\n    request_encoder_->getStream().removeCallbacks(callbacks2);\n  }));\n  EXPECT_CALL(callbacks2, onBelowWriteBufferLowWatermark()).Times(0);\n  EXPECT_CALL(callbacks3, onBelowWriteBufferLowWatermark());\n  server_->getStream(1)->readDisable(false);\n  EXPECT_EQ(0, client_->getStream(1)->pending_send_data_.length());\n  // The extra 1 byte sent won't trigger another window update, so the final window should be the\n  // initial window minus the last 1 byte flush from the client to server.\n  EXPECT_EQ(initial_stream_window - 1,\n            nghttp2_session_get_stream_local_window_size(server_->session(), 1));\n  EXPECT_EQ(initial_stream_window - 1,\n            nghttp2_session_get_stream_remote_window_size(client_->session(), 1));\n}\n\n// Set up the same asTestFlowControlInPendingSendData, but tears the stream down with an early reset\n// once the flow control window is full up.\nTEST_P(Http2CodecImplFlowControlTest, EarlyResetRestoresWindow) {\n  initialize();\n  MockStreamCallbacks callbacks;\n  request_encoder_->getStream().addCallbacks(callbacks);\n\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  TestHeaderMapImpl expected_headers;\n  HttpTestUtility::addDefaultHeaders(expected_headers);\n  EXPECT_CALL(request_decoder_, decodeHeaders_(HeaderMapEqual(&expected_headers), false));\n  request_encoder_->encodeHeaders(request_headers, false);\n\n  // Force the server stream to be read disabled. This will cause it to stop sending window\n  // updates to the client.\n  server_->getStream(1)->readDisable(true);\n\n  uint32_t initial_stream_window =\n      nghttp2_session_get_stream_effective_local_window_size(client_->session(), 1);\n  uint32_t initial_connection_window = nghttp2_session_get_remote_window_size(client_->session());\n  // If this limit is changed, this test will fail due to the initial large writes being divided\n  // into more than 4 frames. Fast fail here with this explanatory comment.\n  ASSERT_EQ(65535, initial_stream_window);\n  // One large write may get broken into smaller frames.\n  EXPECT_CALL(request_decoder_, decodeData(_, false)).Times(AnyNumber());\n  Buffer::OwnedImpl long_data(std::string(initial_stream_window, 'a'));\n  // The one giant write will cause the buffer to go over the limit, then drain and go back under\n  // the limit.\n  request_encoder_->encodeData(long_data, false);\n\n  // Verify that the window is full. The client will not send more data to the server for this\n  // stream.\n  EXPECT_EQ(0, nghttp2_session_get_stream_local_window_size(server_->session(), 1));\n  EXPECT_EQ(0, nghttp2_session_get_stream_remote_window_size(client_->session(), 1));\n  EXPECT_EQ(initial_stream_window, server_->getStream(1)->unconsumed_bytes_);\n  EXPECT_GT(initial_connection_window, nghttp2_session_get_remote_window_size(client_->session()));\n\n  EXPECT_CALL(server_stream_callbacks_,\n              onResetStream(StreamResetReason::LocalRefusedStreamReset, _));\n  EXPECT_CALL(callbacks, onAboveWriteBufferHighWatermark()).Times(0);\n  EXPECT_CALL(callbacks, onBelowWriteBufferLowWatermark()).Times(0);\n  EXPECT_CALL(server_stream_callbacks_, onAboveWriteBufferHighWatermark()).Times(0);\n  EXPECT_CALL(server_stream_callbacks_, onBelowWriteBufferLowWatermark()).Times(0);\n  EXPECT_CALL(callbacks, onResetStream(StreamResetReason::RemoteRefusedStreamReset, _))\n      .WillOnce(Invoke([&](StreamResetReason, absl::string_view) -> void {\n        // Test the case where the reset callbacks cause the socket to fill up,\n        // causing the underlying connection to back up. Given the stream is\n        // being destroyed the watermark callbacks should not fire (mocks for Times(0)\n        // above)\n        client_->onUnderlyingConnectionAboveWriteBufferHighWatermark();\n        client_->onUnderlyingConnectionBelowWriteBufferLowWatermark();\n        server_->onUnderlyingConnectionAboveWriteBufferHighWatermark();\n        server_->onUnderlyingConnectionBelowWriteBufferLowWatermark();\n      }));\n  response_encoder_->getStream().resetStream(StreamResetReason::LocalRefusedStreamReset);\n\n  // Regression test that the window is consumed even if the stream is destroyed early.\n  EXPECT_EQ(initial_connection_window, nghttp2_session_get_remote_window_size(client_->session()));\n}\n\n// Test the HTTP2 pending_recv_data_ buffer going over and under watermark limits.\nTEST_P(Http2CodecImplFlowControlTest, FlowControlPendingRecvData) {\n  initialize();\n  MockStreamCallbacks callbacks;\n\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  TestHeaderMapImpl expected_headers;\n  HttpTestUtility::addDefaultHeaders(expected_headers);\n  EXPECT_CALL(request_decoder_, decodeHeaders_(HeaderMapEqual(&expected_headers), false));\n  request_encoder_->encodeHeaders(request_headers, false);\n\n  // Set artificially small watermarks to make the recv buffer easy to overrun. In production,\n  // the recv buffer can be overrun by a client which negotiates a larger\n  // SETTINGS_MAX_FRAME_SIZE but there's no current easy way to tweak that in\n  // envoy (without sending raw HTTP/2 frames) so we lower the buffer limit instead.\n  server_->getStream(1)->setWriteBufferWatermarks(10, 20);\n\n  EXPECT_CALL(request_decoder_, decodeData(_, false));\n  Buffer::OwnedImpl data(std::string(40, 'a'));\n  request_encoder_->encodeData(data, false);\n}\n\nTEST_P(Http2CodecImplTest, WatermarkUnderEndStream) {\n  initialize();\n  MockStreamCallbacks callbacks;\n  request_encoder_->getStream().addCallbacks(callbacks);\n\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  EXPECT_CALL(request_decoder_, decodeHeaders_(_, false));\n  request_encoder_->encodeHeaders(request_headers, false);\n\n  // The 'true' on encodeData will set local_end_stream_ on the client but not\n  // the server. Verify that client watermark callbacks will not be called, but\n  // server callbacks may be called by simulating connection overflow on both\n  // ends.\n  EXPECT_CALL(callbacks, onAboveWriteBufferHighWatermark()).Times(0);\n  EXPECT_CALL(callbacks, onBelowWriteBufferLowWatermark()).Times(0);\n  EXPECT_CALL(server_stream_callbacks_, onAboveWriteBufferHighWatermark());\n  EXPECT_CALL(server_stream_callbacks_, onBelowWriteBufferLowWatermark());\n  EXPECT_CALL(request_decoder_, decodeData(_, true)).WillOnce(InvokeWithoutArgs([&]() -> void {\n    client_->onUnderlyingConnectionAboveWriteBufferHighWatermark();\n    client_->onUnderlyingConnectionBelowWriteBufferLowWatermark();\n    server_->onUnderlyingConnectionAboveWriteBufferHighWatermark();\n    server_->onUnderlyingConnectionBelowWriteBufferLowWatermark();\n  }));\n  Buffer::OwnedImpl hello(\"hello\");\n  request_encoder_->encodeData(hello, true);\n\n  // The 'true' on encodeData will set local_end_stream_ on the server. Verify\n  // that neither client nor server watermark callbacks will be called again.\n  EXPECT_CALL(callbacks, onAboveWriteBufferHighWatermark()).Times(0);\n  EXPECT_CALL(callbacks, onBelowWriteBufferLowWatermark()).Times(0);\n  EXPECT_CALL(server_stream_callbacks_, onAboveWriteBufferHighWatermark()).Times(0);\n  EXPECT_CALL(server_stream_callbacks_, onBelowWriteBufferLowWatermark()).Times(0);\n  TestHeaderMapImpl response_headers{{\":status\", \"200\"}};\n  EXPECT_CALL(response_decoder_, decodeHeaders_(HeaderMapEqual(&response_headers), true))\n      .WillOnce(InvokeWithoutArgs([&]() -> void {\n        client_->onUnderlyingConnectionAboveWriteBufferHighWatermark();\n        client_->onUnderlyingConnectionBelowWriteBufferLowWatermark();\n        server_->onUnderlyingConnectionAboveWriteBufferHighWatermark();\n        server_->onUnderlyingConnectionBelowWriteBufferLowWatermark();\n      }));\n  response_encoder_->encodeHeaders(response_headers, true);\n}\n\nclass Http2CodecImplStreamLimitTest : public Http2CodecImplTest {};\n\n// Regression test for issue #3076.\n//\n// TODO(PiotrSikora): add tests that exercise both scenarios: before and after receiving\n// the HTTP/2 SETTINGS frame.\nTEST_P(Http2CodecImplStreamLimitTest, MaxClientStreams) {\n  Http2SettingsFromTuple(client_http2settings_, ::testing::get<0>(GetParam()));\n  Http2SettingsFromTuple(server_http2settings_, ::testing::get<1>(GetParam()));\n  client_ = std::make_unique<TestClientConnectionImpl>(client_connection_, client_callbacks_,\n                                                       stats_store_, client_http2settings_,\n                                                       max_request_headers_kb_);\n  server_ = std::make_unique<TestServerConnectionImpl>(server_connection_, server_callbacks_,\n                                                       stats_store_, server_http2settings_,\n                                                       max_request_headers_kb_);\n\n  for (int i = 0; i < 101; ++i) {\n    request_encoder_ = &client_->newStream(response_decoder_);\n    setupDefaultConnectionMocks();\n    EXPECT_CALL(server_callbacks_, newStream(_, _))\n        .WillOnce(Invoke([&](StreamEncoder& encoder, bool) -> StreamDecoder& {\n          response_encoder_ = &encoder;\n          encoder.getStream().addCallbacks(server_stream_callbacks_);\n          return request_decoder_;\n        }));\n\n    TestHeaderMapImpl request_headers;\n    HttpTestUtility::addDefaultHeaders(request_headers);\n    EXPECT_CALL(request_decoder_, decodeHeaders_(_, true));\n    request_encoder_->encodeHeaders(request_headers, true);\n  }\n}\n\n#define HTTP2SETTINGS_SMALL_WINDOW_COMBINE                                                         \\\n  ::testing::Combine(::testing::Values(Http2Settings::DEFAULT_HPACK_TABLE_SIZE),                   \\\n                     ::testing::Values(Http2Settings::DEFAULT_MAX_CONCURRENT_STREAMS),             \\\n                     ::testing::Values(Http2Settings::MIN_INITIAL_STREAM_WINDOW_SIZE),             \\\n                     ::testing::Values(Http2Settings::MIN_INITIAL_CONNECTION_WINDOW_SIZE))\n\n// Deferred reset tests use only small windows so that we can test certain conditions.\nINSTANTIATE_TEST_SUITE_P(Http2CodecImplDeferredResetTest, Http2CodecImplDeferredResetTest,\n                         ::testing::Combine(HTTP2SETTINGS_SMALL_WINDOW_COMBINE,\n                                            HTTP2SETTINGS_SMALL_WINDOW_COMBINE));\n\n// Flow control tests only use only small windows so that we can test certain conditions.\nINSTANTIATE_TEST_SUITE_P(Http2CodecImplFlowControlTest, Http2CodecImplFlowControlTest,\n                         ::testing::Combine(HTTP2SETTINGS_SMALL_WINDOW_COMBINE,\n                                            HTTP2SETTINGS_SMALL_WINDOW_COMBINE));\n\n// we separate default/edge cases here to avoid combinatorial explosion\n#define HTTP2SETTINGS_DEFAULT_COMBINE                                                              \\\n  ::testing::Combine(::testing::Values(Http2Settings::DEFAULT_HPACK_TABLE_SIZE),                   \\\n                     ::testing::Values(Http2Settings::DEFAULT_MAX_CONCURRENT_STREAMS),             \\\n                     ::testing::Values(Http2Settings::DEFAULT_INITIAL_STREAM_WINDOW_SIZE),         \\\n                     ::testing::Values(Http2Settings::DEFAULT_INITIAL_CONNECTION_WINDOW_SIZE))\n\n// Stream limit test only uses the default values because not all combinations of\n// edge settings allow for the number of streams needed by the test.\nINSTANTIATE_TEST_SUITE_P(Http2CodecImplStreamLimitTest, Http2CodecImplStreamLimitTest,\n                         ::testing::Combine(HTTP2SETTINGS_DEFAULT_COMBINE,\n                                            HTTP2SETTINGS_DEFAULT_COMBINE));\n\nINSTANTIATE_TEST_SUITE_P(Http2CodecImplTestDefaultSettings, Http2CodecImplTest,\n                         ::testing::Combine(HTTP2SETTINGS_DEFAULT_COMBINE,\n                                            HTTP2SETTINGS_DEFAULT_COMBINE));\n\n#define HTTP2SETTINGS_EDGE_COMBINE                                                                 \\\n  ::testing::Combine(                                                                              \\\n      ::testing::Values(Http2Settings::MIN_HPACK_TABLE_SIZE, Http2Settings::MAX_HPACK_TABLE_SIZE), \\\n      ::testing::Values(Http2Settings::MIN_MAX_CONCURRENT_STREAMS,                                 \\\n                        Http2Settings::MAX_MAX_CONCURRENT_STREAMS),                                \\\n      ::testing::Values(Http2Settings::MIN_INITIAL_STREAM_WINDOW_SIZE,                             \\\n                        Http2Settings::MAX_INITIAL_STREAM_WINDOW_SIZE),                            \\\n      ::testing::Values(Http2Settings::MIN_INITIAL_CONNECTION_WINDOW_SIZE,                         \\\n                        Http2Settings::MAX_INITIAL_CONNECTION_WINDOW_SIZE))\n\n// Make sure we have coverage for high and low values for various  combinations and permutations\n// of HTTP settings in at least one test fixture.\n// Use with caution as any test using this runs 255 times.\nusing Http2CodecImplTestAll = Http2CodecImplTest;\n\nINSTANTIATE_TEST_SUITE_P(Http2CodecImplTestDefaultSettings, Http2CodecImplTestAll,\n                         ::testing::Combine(HTTP2SETTINGS_DEFAULT_COMBINE,\n                                            HTTP2SETTINGS_DEFAULT_COMBINE));\nINSTANTIATE_TEST_SUITE_P(Http2CodecImplTestEdgeSettings, Http2CodecImplTestAll,\n                         ::testing::Combine(HTTP2SETTINGS_EDGE_COMBINE,\n                                            HTTP2SETTINGS_EDGE_COMBINE));\n\nTEST(Http2CodecUtility, reconstituteCrumbledCookies) {\n  {\n    HeaderString key;\n    HeaderString value;\n    HeaderString cookies;\n    EXPECT_FALSE(Utility::reconstituteCrumbledCookies(key, value, cookies));\n    EXPECT_TRUE(cookies.empty());\n  }\n\n  {\n    HeaderString key(Headers::get().ContentLength);\n    HeaderString value;\n    value.setInteger(5);\n    HeaderString cookies;\n    EXPECT_FALSE(Utility::reconstituteCrumbledCookies(key, value, cookies));\n    EXPECT_TRUE(cookies.empty());\n  }\n\n  {\n    HeaderString key(Headers::get().Cookie);\n    HeaderString value;\n    value.setCopy(\"a=b\", 3);\n    HeaderString cookies;\n    EXPECT_TRUE(Utility::reconstituteCrumbledCookies(key, value, cookies));\n    EXPECT_EQ(cookies, \"a=b\");\n\n    HeaderString key2(Headers::get().Cookie);\n    HeaderString value2;\n    value2.setCopy(\"c=d\", 3);\n    EXPECT_TRUE(Utility::reconstituteCrumbledCookies(key2, value2, cookies));\n    EXPECT_EQ(cookies, \"a=b; c=d\");\n  }\n}\n\nTEST_P(Http2CodecImplTest, TestLargeRequestHeadersInvokeResetStream) {\n  initialize();\n\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  std::string long_string = std::string(63 * 1024, 'q');\n  request_headers.addCopy(\"big\", long_string);\n  EXPECT_CALL(server_stream_callbacks_, onResetStream(_, _)).Times(1);\n  request_encoder_->encodeHeaders(request_headers, false);\n}\n\nTEST_P(Http2CodecImplTest, TestLargeRequestHeadersAccepted) {\n  max_request_headers_kb_ = 64;\n  initialize();\n\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  std::string long_string = std::string(63 * 1024, 'q');\n  request_headers.addCopy(\"big\", long_string);\n\n  EXPECT_CALL(request_decoder_, decodeHeaders_(_, _));\n  EXPECT_CALL(server_stream_callbacks_, onResetStream(_, _)).Times(0);\n  request_encoder_->encodeHeaders(request_headers, false);\n}\n\nTEST_P(Http2CodecImplTest, TestLargeRequestHeadersAtLimitAccepted) {\n  uint32_t codec_limit_kb = 64;\n  max_request_headers_kb_ = codec_limit_kb;\n  initialize();\n\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  std::string key = \"big\";\n  uint32_t head_room = 77;\n  uint32_t long_string_length =\n      codec_limit_kb * 1024 - request_headers.byteSize() - key.length() - head_room;\n  std::string long_string = std::string(long_string_length, 'q');\n  request_headers.addCopy(key, long_string);\n\n  // The amount of data sent to the codec is not equivalent to the size of the\n  // request headers that Envoy computes, as the codec limits based on the\n  // entire http2 frame. The exact head room needed (76) was found through iteration.\n  ASSERT_EQ(request_headers.byteSize() + head_room, codec_limit_kb * 1024);\n\n  EXPECT_CALL(request_decoder_, decodeHeaders_(_, _));\n  request_encoder_->encodeHeaders(request_headers, true);\n}\n\nTEST_P(Http2CodecImplTest, TestLargeRequestHeadersOverDefaultCodecLibraryLimit) {\n  max_request_headers_kb_ = 66;\n  initialize();\n\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  std::string long_string = std::string(65 * 1024, 'q');\n  request_headers.addCopy(\"big\", long_string);\n\n  EXPECT_CALL(request_decoder_, decodeHeaders_(_, _)).Times(1);\n  EXPECT_CALL(server_stream_callbacks_, onResetStream(_, _)).Times(0);\n  request_encoder_->encodeHeaders(request_headers, true);\n}\n\nTEST_P(Http2CodecImplTest, TestLargeRequestHeadersExceedPerHeaderLimit) {\n  // The name-value pair max is set by NGHTTP2_HD_MAX_NV in lib/nghttp2_hd.h to 64KB, and\n  // creates a per-request header limit for us in h2. Note that the nghttp2\n  // calculated byte size will differ from envoy due to H2 compression and frames.\n\n  max_request_headers_kb_ = 81;\n  initialize();\n\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  std::string long_string = std::string(80 * 1024, 'q');\n  request_headers.addCopy(\"big\", long_string);\n\n  EXPECT_CALL(request_decoder_, decodeHeaders_(_, _)).Times(0);\n  EXPECT_CALL(client_callbacks_, onGoAway());\n  server_->shutdownNotice();\n  server_->goAway();\n  request_encoder_->encodeHeaders(request_headers, true);\n}\n\nTEST_P(Http2CodecImplTest, TestManyLargeRequestHeadersUnderPerHeaderLimit) {\n  max_request_headers_kb_ = 81;\n  initialize();\n\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  std::string long_string = std::string(1024, 'q');\n  for (int i = 0; i < 80; i++) {\n    request_headers.addCopy(fmt::format(\"{}\", i), long_string);\n  }\n\n  EXPECT_CALL(request_decoder_, decodeHeaders_(_, _)).Times(1);\n  EXPECT_CALL(server_stream_callbacks_, onResetStream(_, _)).Times(0);\n  request_encoder_->encodeHeaders(request_headers, true);\n}\n\nTEST_P(Http2CodecImplTest, TestLargeRequestHeadersAtMaxConfigurable) {\n  // Raising the limit past this triggers some unexpected nghttp2 error.\n  // Further debugging required to increase past ~96 KiB.\n  max_request_headers_kb_ = 96;\n  initialize();\n\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  std::string long_string = std::string(1024, 'q');\n  for (int i = 0; i < 95; i++) {\n    request_headers.addCopy(fmt::format(\"{}\", i), long_string);\n  }\n\n  EXPECT_CALL(request_decoder_, decodeHeaders_(_, _)).Times(1);\n  EXPECT_CALL(server_stream_callbacks_, onResetStream(_, _)).Times(0);\n  request_encoder_->encodeHeaders(request_headers, true);\n}\n\n// Note this is Http2CodecImplTestAll not Http2CodecImplTest, to test\n// compression with min and max HPACK table size.\nTEST_P(Http2CodecImplTestAll, TestCodecHeaderCompression) {\n  initialize();\n\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  EXPECT_CALL(request_decoder_, decodeHeaders_(_, true));\n  request_encoder_->encodeHeaders(request_headers, true);\n\n  TestHeaderMapImpl response_headers{{\":status\", \"200\"}, {\"compression\", \"test\"}};\n  EXPECT_CALL(response_decoder_, decodeHeaders_(_, true));\n  response_encoder_->encodeHeaders(response_headers, true);\n\n  // Sanity check to verify that state of encoders and decoders matches.\n  EXPECT_EQ(nghttp2_session_get_hd_deflate_dynamic_table_size(server_->session()),\n            nghttp2_session_get_hd_inflate_dynamic_table_size(client_->session()));\n  EXPECT_EQ(nghttp2_session_get_hd_deflate_dynamic_table_size(client_->session()),\n            nghttp2_session_get_hd_inflate_dynamic_table_size(server_->session()));\n\n  // Verify that headers are compressed only when both client and server advertise table size > 0:\n  if (client_http2settings_.hpack_table_size_ && server_http2settings_.hpack_table_size_) {\n    EXPECT_NE(0, nghttp2_session_get_hd_deflate_dynamic_table_size(client_->session()));\n    EXPECT_NE(0, nghttp2_session_get_hd_deflate_dynamic_table_size(server_->session()));\n  } else {\n    EXPECT_EQ(0, nghttp2_session_get_hd_deflate_dynamic_table_size(client_->session()));\n    EXPECT_EQ(0, nghttp2_session_get_hd_deflate_dynamic_table_size(server_->session()));\n  }\n}\n\n// Verify that codec detects PING flood\nTEST_P(Http2CodecImplTest, PingFlood) {\n  initialize();\n\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  EXPECT_CALL(request_decoder_, decodeHeaders_(_, false));\n  request_encoder_->encodeHeaders(request_headers, false);\n\n  // Send one frame above the outbound control queue size limit\n  for (uint32_t i = 0; i < Http2Settings::DEFAULT_MAX_OUTBOUND_CONTROL_FRAMES + 1; ++i) {\n    EXPECT_EQ(0, nghttp2_submit_ping(client_->session(), NGHTTP2_FLAG_NONE, nullptr));\n  }\n\n  int ack_count = 0;\n  Buffer::OwnedImpl buffer;\n  ON_CALL(server_connection_, write(_, _))\n      .WillByDefault(Invoke([&buffer, &ack_count](Buffer::Instance& frame, bool) {\n        ++ack_count;\n        buffer.move(frame);\n      }));\n\n  EXPECT_THROW(client_->sendPendingFrames(), FrameFloodException);\n  EXPECT_EQ(ack_count, Http2Settings::DEFAULT_MAX_OUTBOUND_CONTROL_FRAMES);\n  EXPECT_EQ(1, stats_store_.counter(\"http2.outbound_control_flood\").value());\n}\n\n// Verify that codec allows PING flood when mitigation is disabled\nTEST_P(Http2CodecImplTest, PingFloodMitigationDisabled) {\n  Runtime::LoaderSingleton::getExisting()->mergeValues(\n      {{\"envoy.reloadable_features.http2_protocol_options.max_outbound_control_frames\",\n        \"2147483647\"}});\n  initialize();\n\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  EXPECT_CALL(request_decoder_, decodeHeaders_(_, false));\n  request_encoder_->encodeHeaders(request_headers, false);\n\n  // Send one frame above the outbound control queue size limit\n  for (uint32_t i = 0; i < Http2Settings::DEFAULT_MAX_OUTBOUND_CONTROL_FRAMES + 1; ++i) {\n    EXPECT_EQ(0, nghttp2_submit_ping(client_->session(), NGHTTP2_FLAG_NONE, nullptr));\n  }\n\n  EXPECT_CALL(server_connection_, write(_, _))\n      .Times(Http2Settings::DEFAULT_MAX_OUTBOUND_CONTROL_FRAMES + 1);\n  EXPECT_NO_THROW(client_->sendPendingFrames());\n}\n\n// Verify that outbound control frame counter decreases when send buffer is drained\nTEST_P(Http2CodecImplTest, PingFloodCounterReset) {\n  static const int kMaxOutboundControlFrames = 100;\n  max_outbound_control_frames_ = kMaxOutboundControlFrames;\n  initialize();\n\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  EXPECT_CALL(request_decoder_, decodeHeaders_(_, false));\n  request_encoder_->encodeHeaders(request_headers, false);\n\n  for (int i = 0; i < kMaxOutboundControlFrames; ++i) {\n    EXPECT_EQ(0, nghttp2_submit_ping(client_->session(), NGHTTP2_FLAG_NONE, nullptr));\n  }\n\n  int ack_count = 0;\n  Buffer::OwnedImpl buffer;\n  ON_CALL(server_connection_, write(_, _))\n      .WillByDefault(Invoke([&buffer, &ack_count](Buffer::Instance& frame, bool) {\n        ++ack_count;\n        buffer.move(frame);\n      }));\n\n  // We should be 1 frame under the control frame flood mitigation threshold.\n  EXPECT_NO_THROW(client_->sendPendingFrames());\n  EXPECT_EQ(ack_count, kMaxOutboundControlFrames);\n\n  // Drain kMaxOutboundFrames / 2 slices from the send buffer\n  buffer.drain(buffer.length() / 2);\n\n  // Send kMaxOutboundFrames / 2 more pings.\n  for (int i = 0; i < kMaxOutboundControlFrames / 2; ++i) {\n    EXPECT_EQ(0, nghttp2_submit_ping(client_->session(), NGHTTP2_FLAG_NONE, nullptr));\n  }\n  // The number of outbound frames should be half of max so the connection should not be terminated.\n  EXPECT_NO_THROW(client_->sendPendingFrames());\n\n  // 1 more ping frame should overflow the outbound frame limit.\n  EXPECT_EQ(0, nghttp2_submit_ping(client_->session(), NGHTTP2_FLAG_NONE, nullptr));\n  EXPECT_THROW(client_->sendPendingFrames(), FrameFloodException);\n}\n\n// Verify that codec detects flood of outbound HEADER frames\nTEST_P(Http2CodecImplTest, ResponseHeadersFlood) {\n  initialize();\n\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  EXPECT_CALL(request_decoder_, decodeHeaders_(_, false));\n  request_encoder_->encodeHeaders(request_headers, false);\n\n  int frame_count = 0;\n  Buffer::OwnedImpl buffer;\n  ON_CALL(server_connection_, write(_, _))\n      .WillByDefault(Invoke([&buffer, &frame_count](Buffer::Instance& frame, bool) {\n        ++frame_count;\n        buffer.move(frame);\n      }));\n\n  TestHeaderMapImpl response_headers{{\":status\", \"200\"}};\n  for (uint32_t i = 0; i < Http2Settings::DEFAULT_MAX_OUTBOUND_FRAMES + 1; ++i) {\n    EXPECT_NO_THROW(response_encoder_->encodeHeaders(response_headers, false));\n  }\n  // Presently flood mitigation is done only when processing downstream data\n  // So we need to send stream from downstream client to trigger mitigation\n  EXPECT_EQ(0, nghttp2_submit_ping(client_->session(), NGHTTP2_FLAG_NONE, nullptr));\n  EXPECT_THROW(client_->sendPendingFrames(), FrameFloodException);\n\n  EXPECT_EQ(frame_count, Http2Settings::DEFAULT_MAX_OUTBOUND_FRAMES + 1);\n  EXPECT_EQ(1, stats_store_.counter(\"http2.outbound_flood\").value());\n}\n\n// Verify that codec detects flood of outbound DATA frames\nTEST_P(Http2CodecImplTest, ResponseDataFlood) {\n  initialize();\n\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  EXPECT_CALL(request_decoder_, decodeHeaders_(_, false));\n  request_encoder_->encodeHeaders(request_headers, false);\n\n  int frame_count = 0;\n  Buffer::OwnedImpl buffer;\n  ON_CALL(server_connection_, write(_, _))\n      .WillByDefault(Invoke([&buffer, &frame_count](Buffer::Instance& frame, bool) {\n        ++frame_count;\n        buffer.move(frame);\n      }));\n\n  TestHeaderMapImpl response_headers{{\":status\", \"200\"}};\n  response_encoder_->encodeHeaders(response_headers, false);\n  // Account for the single HEADERS frame above\n  for (uint32_t i = 0; i < Http2Settings::DEFAULT_MAX_OUTBOUND_FRAMES; ++i) {\n    Buffer::OwnedImpl data(\"0\");\n    EXPECT_NO_THROW(response_encoder_->encodeData(data, false));\n  }\n  // Presently flood mitigation is done only when processing downstream data\n  // So we need to send stream from downstream client to trigger mitigation\n  EXPECT_EQ(0, nghttp2_submit_ping(client_->session(), NGHTTP2_FLAG_NONE, nullptr));\n  EXPECT_THROW(client_->sendPendingFrames(), FrameFloodException);\n\n  EXPECT_EQ(frame_count, Http2Settings::DEFAULT_MAX_OUTBOUND_FRAMES + 1);\n  EXPECT_EQ(1, stats_store_.counter(\"http2.outbound_flood\").value());\n}\n\n// Verify that codec allows outbound DATA flood when mitigation is disabled\nTEST_P(Http2CodecImplTest, ResponseDataFloodMitigationDisabled) {\n  Runtime::LoaderSingleton::getExisting()->mergeValues(\n      {{\"envoy.reloadable_features.http2_protocol_options.max_outbound_frames\", \"2147483647\"}});\n  initialize();\n\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  EXPECT_CALL(request_decoder_, decodeHeaders_(_, false));\n  request_encoder_->encodeHeaders(request_headers, false);\n\n  // +2 is to account for HEADERS and PING ACK, that is used to trigger mitigation\n  EXPECT_CALL(server_connection_, write(_, _))\n      .Times(Http2Settings::DEFAULT_MAX_OUTBOUND_FRAMES + 2);\n  EXPECT_CALL(response_decoder_, decodeHeaders_(_, false)).Times(1);\n  EXPECT_CALL(response_decoder_, decodeData(_, false))\n      .Times(Http2Settings::DEFAULT_MAX_OUTBOUND_FRAMES);\n  TestHeaderMapImpl response_headers{{\":status\", \"200\"}};\n  response_encoder_->encodeHeaders(response_headers, false);\n  // Account for the single HEADERS frame above\n  for (uint32_t i = 0; i < Http2Settings::DEFAULT_MAX_OUTBOUND_FRAMES; ++i) {\n    Buffer::OwnedImpl data(\"0\");\n    EXPECT_NO_THROW(response_encoder_->encodeData(data, false));\n  }\n  // Presently flood mitigation is done only when processing downstream data\n  // So we need to send stream from downstream client to trigger mitigation\n  EXPECT_EQ(0, nghttp2_submit_ping(client_->session(), NGHTTP2_FLAG_NONE, nullptr));\n  EXPECT_NO_THROW(client_->sendPendingFrames());\n}\n\n// Verify that outbound frame counter decreases when send buffer is drained\nTEST_P(Http2CodecImplTest, ResponseDataFloodCounterReset) {\n  static const int kMaxOutboundFrames = 100;\n  max_outbound_frames_ = kMaxOutboundFrames;\n  initialize();\n\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  EXPECT_CALL(request_decoder_, decodeHeaders_(_, false));\n  request_encoder_->encodeHeaders(request_headers, false);\n\n  int frame_count = 0;\n  Buffer::OwnedImpl buffer;\n  ON_CALL(server_connection_, write(_, _))\n      .WillByDefault(Invoke([&buffer, &frame_count](Buffer::Instance& frame, bool) {\n        ++frame_count;\n        buffer.move(frame);\n      }));\n\n  TestHeaderMapImpl response_headers{{\":status\", \"200\"}};\n  response_encoder_->encodeHeaders(response_headers, false);\n  // Account for the single HEADERS frame above\n  for (uint32_t i = 0; i < kMaxOutboundFrames - 1; ++i) {\n    Buffer::OwnedImpl data(\"0\");\n    EXPECT_NO_THROW(response_encoder_->encodeData(data, false));\n  }\n\n  EXPECT_EQ(frame_count, kMaxOutboundFrames);\n  // Drain kMaxOutboundFrames / 2 slices from the send buffer\n  buffer.drain(buffer.length() / 2);\n\n  for (uint32_t i = 0; i < kMaxOutboundFrames / 2 + 1; ++i) {\n    Buffer::OwnedImpl data(\"0\");\n    EXPECT_NO_THROW(response_encoder_->encodeData(data, false));\n  }\n\n  // Presently flood mitigation is done only when processing downstream data\n  // So we need to send a frame from downstream client to trigger mitigation\n  EXPECT_EQ(0, nghttp2_submit_ping(client_->session(), NGHTTP2_FLAG_NONE, nullptr));\n  EXPECT_THROW(client_->sendPendingFrames(), FrameFloodException);\n}\n\n// Verify that control frames are added to the counter of outbound frames of all types.\nTEST_P(Http2CodecImplTest, PingStacksWithDataFlood) {\n  initialize();\n\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  EXPECT_CALL(request_decoder_, decodeHeaders_(_, false));\n  request_encoder_->encodeHeaders(request_headers, false);\n\n  int frame_count = 0;\n  Buffer::OwnedImpl buffer;\n  ON_CALL(server_connection_, write(_, _))\n      .WillByDefault(Invoke([&buffer, &frame_count](Buffer::Instance& frame, bool) {\n        ++frame_count;\n        buffer.move(frame);\n      }));\n\n  TestHeaderMapImpl response_headers{{\":status\", \"200\"}};\n  response_encoder_->encodeHeaders(response_headers, false);\n  // Account for the single HEADERS frame above\n  for (uint32_t i = 0; i < Http2Settings::DEFAULT_MAX_OUTBOUND_FRAMES - 1; ++i) {\n    Buffer::OwnedImpl data(\"0\");\n    EXPECT_NO_THROW(response_encoder_->encodeData(data, false));\n  }\n  // Send one PING frame above the outbound queue size limit\n  EXPECT_EQ(0, nghttp2_submit_ping(client_->session(), NGHTTP2_FLAG_NONE, nullptr));\n  EXPECT_THROW(client_->sendPendingFrames(), FrameFloodException);\n\n  EXPECT_EQ(frame_count, Http2Settings::DEFAULT_MAX_OUTBOUND_FRAMES);\n  EXPECT_EQ(1, stats_store_.counter(\"http2.outbound_flood\").value());\n}\n\nTEST_P(Http2CodecImplTest, PriorityFlood) {\n  priorityFlood();\n  EXPECT_THROW(client_->sendPendingFrames(), FrameFloodException);\n}\n\nTEST_P(Http2CodecImplTest, PriorityFloodOverride) {\n  Runtime::LoaderSingleton::getExisting()->mergeValues(\n      {{\"envoy.reloadable_features.http2_protocol_options.max_inbound_priority_frames_per_stream\",\n        \"2147483647\"}});\n\n  priorityFlood();\n  EXPECT_NO_THROW(client_->sendPendingFrames());\n}\n\nTEST_P(Http2CodecImplTest, WindowUpdateFlood) {\n  windowUpdateFlood();\n  EXPECT_THROW(client_->sendPendingFrames(), FrameFloodException);\n}\n\nTEST_P(Http2CodecImplTest, WindowUpdateFloodOverride) {\n  Runtime::LoaderSingleton::getExisting()->mergeValues(\n      {{\"envoy.reloadable_features.http2_protocol_options.max_inbound_window_update_frames_per_\"\n        \"data_frame_sent\",\n        \"2147483647\"}});\n  windowUpdateFlood();\n  EXPECT_NO_THROW(client_->sendPendingFrames());\n}\n\nTEST_P(Http2CodecImplTest, EmptyDataFlood) {\n  Buffer::OwnedImpl data;\n  emptyDataFlood(data);\n  EXPECT_CALL(request_decoder_, decodeData(_, false));\n  EXPECT_THROW(server_wrapper_.dispatch(data, *server_), FrameFloodException);\n}\n\nTEST_P(Http2CodecImplTest, EmptyDataFloodOverride) {\n  Runtime::LoaderSingleton::getExisting()->mergeValues(\n      {{\"envoy.reloadable_features.http2_protocol_options.max_consecutive_inbound_frames_with_\"\n        \"empty_payload\",\n        \"2147483647\"}});\n  Buffer::OwnedImpl data;\n  emptyDataFlood(data);\n  EXPECT_CALL(request_decoder_, decodeData(_, false))\n      .Times(Http2Settings::DEFAULT_MAX_CONSECUTIVE_INBOUND_FRAMES_WITH_EMPTY_PAYLOAD + 1);\n  EXPECT_NO_THROW(server_wrapper_.dispatch(data, *server_));\n}\n\n} // namespace Http2\n} // namespace Http\n} // namespace Envoy\n", "#include \"test/integration/http2_integration_test.h\"\n\n#include <algorithm>\n#include <string>\n\n#include \"common/buffer/buffer_impl.h\"\n#include \"common/http/header_map_impl.h\"\n\n#include \"test/integration/utility.h\"\n#include \"test/mocks/http/mocks.h\"\n#include \"test/test_common/network_utility.h\"\n#include \"test/test_common/printers.h\"\n#include \"test/test_common/utility.h\"\n\n#include \"gtest/gtest.h\"\n\nusing ::testing::HasSubstr;\nusing ::testing::MatchesRegex;\n\nnamespace Envoy {\n\nINSTANTIATE_TEST_SUITE_P(IpVersions, Http2IntegrationTest,\n                         testing::ValuesIn(TestEnvironment::getIpVersionsForTest()),\n                         TestUtility::ipTestParamsToString);\n\nTEST_P(Http2IntegrationTest, RouterRequestAndResponseWithBodyNoBuffer) {\n  testRouterRequestAndResponseWithBody(1024, 512, false);\n}\n\nTEST_P(Http2IntegrationTest, FlowControlOnAndGiantBody) {\n  config_helper_.setBufferLimits(1024, 1024); // Set buffer limits upstream and downstream.\n  testRouterRequestAndResponseWithBody(1024 * 1024, 1024 * 1024, false);\n}\n\nTEST_P(Http2IntegrationTest, RouterHeaderOnlyRequestAndResponseNoBuffer) {\n  testRouterHeaderOnlyRequestAndResponse();\n}\n\nTEST_P(Http2IntegrationTest, RouterRequestAndResponseLargeHeaderNoBuffer) {\n  testRouterRequestAndResponseWithBody(1024, 512, true);\n}\n\nTEST_P(Http2IntegrationTest, RouterUpstreamDisconnectBeforeRequestcomplete) {\n  testRouterUpstreamDisconnectBeforeRequestComplete();\n}\n\nTEST_P(Http2IntegrationTest, RouterUpstreamDisconnectBeforeResponseComplete) {\n  testRouterUpstreamDisconnectBeforeResponseComplete();\n}\n\nTEST_P(Http2IntegrationTest, RouterDownstreamDisconnectBeforeRequestComplete) {\n  testRouterDownstreamDisconnectBeforeRequestComplete();\n}\n\nTEST_P(Http2IntegrationTest, RouterDownstreamDisconnectBeforeResponseComplete) {\n  testRouterDownstreamDisconnectBeforeResponseComplete();\n}\n\nTEST_P(Http2IntegrationTest, RouterUpstreamResponseBeforeRequestComplete) {\n  testRouterUpstreamResponseBeforeRequestComplete();\n}\n\nTEST_P(Http2IntegrationTest, Retry) { testRetry(); }\n\nTEST_P(Http2IntegrationTest, RetryAttemptCount) { testRetryAttemptCountHeader(); }\n\nstatic std::string response_metadata_filter = R\"EOF(\nname: response-metadata-filter\nconfig: {}\n)EOF\";\n\n// Verifies metadata can be sent at different locations of the responses.\nTEST_P(Http2MetadataIntegrationTest, ProxyMetadataInResponse) {\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  // Sends the first request.\n  auto response = codec_client_->makeRequestWithBody(default_request_headers_, 10);\n  waitForNextUpstreamRequest();\n\n  // Sends metadata before response header.\n  const std::string key = \"key\";\n  std::string value = std::string(80 * 1024, '1');\n  Http::MetadataMap metadata_map = {{key, value}};\n  Http::MetadataMapPtr metadata_map_ptr = std::make_unique<Http::MetadataMap>(metadata_map);\n  Http::MetadataMapVector metadata_map_vector;\n  metadata_map_vector.push_back(std::move(metadata_map_ptr));\n  upstream_request_->encodeMetadata(metadata_map_vector);\n  upstream_request_->encodeHeaders(default_response_headers_, false);\n  upstream_request_->encodeData(12, true);\n\n  // Verifies metadata is received by the client.\n  response->waitForEndStream();\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(response->metadata_map().find(key)->second, value);\n\n  // Sends the second request.\n  response = codec_client_->makeRequestWithBody(default_request_headers_, 10);\n  waitForNextUpstreamRequest();\n\n  // Sends metadata after response header followed by an empty data frame with end_stream true.\n  value = std::string(10, '2');\n  upstream_request_->encodeHeaders(default_response_headers_, false);\n  metadata_map = {{key, value}};\n  metadata_map_ptr = std::make_unique<Http::MetadataMap>(metadata_map);\n  metadata_map_vector.erase(metadata_map_vector.begin());\n  metadata_map_vector.push_back(std::move(metadata_map_ptr));\n  upstream_request_->encodeMetadata(metadata_map_vector);\n  upstream_request_->encodeData(0, true);\n\n  // Verifies metadata is received by the client.\n  response->waitForEndStream();\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(response->metadata_map().find(key)->second, value);\n\n  // Sends the third request.\n  response = codec_client_->makeRequestWithBody(default_request_headers_, 10);\n  waitForNextUpstreamRequest();\n\n  // Sends metadata after response header and before data.\n  value = std::string(10, '3');\n  upstream_request_->encodeHeaders(default_response_headers_, false);\n  metadata_map = {{key, value}};\n  metadata_map_ptr = std::make_unique<Http::MetadataMap>(metadata_map);\n  metadata_map_vector.erase(metadata_map_vector.begin());\n  metadata_map_vector.push_back(std::move(metadata_map_ptr));\n  upstream_request_->encodeMetadata(metadata_map_vector);\n  upstream_request_->encodeData(10, true);\n\n  // Verifies metadata is received by the client.\n  response->waitForEndStream();\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(response->metadata_map().find(key)->second, value);\n\n  // Sends the fourth request.\n  response = codec_client_->makeRequestWithBody(default_request_headers_, 10);\n  waitForNextUpstreamRequest();\n\n  // Sends metadata between data frames.\n  value = std::string(10, '4');\n  upstream_request_->encodeHeaders(default_response_headers_, false);\n  upstream_request_->encodeData(10, false);\n  metadata_map = {{key, value}};\n  metadata_map_ptr = std::make_unique<Http::MetadataMap>(metadata_map);\n  metadata_map_vector.erase(metadata_map_vector.begin());\n  metadata_map_vector.push_back(std::move(metadata_map_ptr));\n  upstream_request_->encodeMetadata(metadata_map_vector);\n  upstream_request_->encodeData(10, true);\n\n  // Verifies metadata is received by the client.\n  response->waitForEndStream();\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(response->metadata_map().find(key)->second, value);\n\n  // Sends the fifth request.\n  response = codec_client_->makeRequestWithBody(default_request_headers_, 10);\n  waitForNextUpstreamRequest();\n\n  // Sends metadata after the last non-empty data frames.\n  value = std::string(10, '5');\n  upstream_request_->encodeHeaders(default_response_headers_, false);\n  upstream_request_->encodeData(10, false);\n  metadata_map = {{key, value}};\n  metadata_map_ptr = std::make_unique<Http::MetadataMap>(metadata_map);\n  metadata_map_vector.erase(metadata_map_vector.begin());\n  metadata_map_vector.push_back(std::move(metadata_map_ptr));\n  upstream_request_->encodeMetadata(metadata_map_vector);\n  upstream_request_->encodeData(0, true);\n\n  // Verifies metadata is received by the client.\n  response->waitForEndStream();\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(response->metadata_map().find(key)->second, value);\n\n  // Sends the sixth request.\n  response = codec_client_->makeRequestWithBody(default_request_headers_, 10);\n  waitForNextUpstreamRequest();\n\n  // Sends metadata before reset.\n  value = std::string(10, '6');\n  upstream_request_->encodeHeaders(default_response_headers_, false);\n  upstream_request_->encodeData(10, false);\n  metadata_map = {{key, value}};\n  metadata_map_ptr = std::make_unique<Http::MetadataMap>(metadata_map);\n  metadata_map_vector.erase(metadata_map_vector.begin());\n  metadata_map_vector.push_back(std::move(metadata_map_ptr));\n  upstream_request_->encodeMetadata(metadata_map_vector);\n  upstream_request_->encodeResetStream();\n\n  // Verifies stream is reset.\n  response->waitForReset();\n  ASSERT_FALSE(response->complete());\n}\n\nTEST_P(Http2MetadataIntegrationTest, ProxyMultipleMetadata) {\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  // Sends a request.\n  auto response = codec_client_->makeRequestWithBody(default_request_headers_, 10);\n  waitForNextUpstreamRequest();\n\n  const int size = 4;\n  std::vector<Http::MetadataMapVector> multiple_vecs(size);\n  for (int i = 0; i < size; i++) {\n    Runtime::RandomGeneratorImpl random;\n    int value_size = random.random() % Http::METADATA_MAX_PAYLOAD_SIZE + 1;\n    Http::MetadataMap metadata_map = {{std::string(i, 'a'), std::string(value_size, 'b')}};\n    Http::MetadataMapPtr metadata_map_ptr = std::make_unique<Http::MetadataMap>(metadata_map);\n    multiple_vecs[i].push_back(std::move(metadata_map_ptr));\n  }\n  upstream_request_->encodeMetadata(multiple_vecs[0]);\n  upstream_request_->encodeHeaders(default_response_headers_, false);\n  upstream_request_->encodeMetadata(multiple_vecs[1]);\n  upstream_request_->encodeData(12, false);\n  upstream_request_->encodeMetadata(multiple_vecs[2]);\n  upstream_request_->encodeData(12, false);\n  upstream_request_->encodeMetadata(multiple_vecs[3]);\n  upstream_request_->encodeData(12, true);\n\n  // Verifies multiple metadata are received by the client.\n  response->waitForEndStream();\n  ASSERT_TRUE(response->complete());\n  for (int i = 0; i < size; i++) {\n    for (const auto& metadata : *multiple_vecs[i][0]) {\n      EXPECT_EQ(response->metadata_map().find(metadata.first)->second, metadata.second);\n    }\n  }\n  EXPECT_EQ(response->metadata_map().size(), multiple_vecs.size());\n}\n\nTEST_P(Http2MetadataIntegrationTest, ProxyInvalidMetadata) {\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  // Sends a request.\n  auto response = codec_client_->makeRequestWithBody(default_request_headers_, 10);\n  waitForNextUpstreamRequest();\n\n  // Sends over-sized metadata before response header.\n  const std::string key = \"key\";\n  std::string value = std::string(1024 * 1024, 'a');\n  Http::MetadataMap metadata_map = {{key, value}};\n  Http::MetadataMapPtr metadata_map_ptr = std::make_unique<Http::MetadataMap>(metadata_map);\n  Http::MetadataMapVector metadata_map_vector;\n  metadata_map_vector.push_back(std::move(metadata_map_ptr));\n  upstream_request_->encodeMetadata(metadata_map_vector);\n  upstream_request_->encodeHeaders(default_response_headers_, false);\n  upstream_request_->encodeMetadata(metadata_map_vector);\n  upstream_request_->encodeData(12, false);\n  upstream_request_->encodeMetadata(metadata_map_vector);\n  upstream_request_->encodeData(12, true);\n\n  // Verifies metadata is not received by the client.\n  response->waitForEndStream();\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(response->metadata_map().size(), 0);\n}\n\nvoid verifyExpectedMetadata(Http::MetadataMap metadata_map, std::set<std::string> keys) {\n  for (const auto& key : keys) {\n    // keys are the same as their corresponding values.\n    EXPECT_EQ(metadata_map.find(key)->second, key);\n  }\n  EXPECT_EQ(metadata_map.size(), keys.size());\n}\n\nTEST_P(Http2MetadataIntegrationTest, TestResponseMetadata) {\n  addFilters({response_metadata_filter});\n  config_helper_.addConfigModifier(\n      [&](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager& hcm)\n          -> void { hcm.set_proxy_100_continue(true); });\n\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  // Upstream responds with headers.\n  auto response = codec_client_->makeRequestWithBody(default_request_headers_, 10);\n  waitForNextUpstreamRequest();\n  upstream_request_->encodeHeaders(default_response_headers_, true);\n\n  response->waitForEndStream();\n  ASSERT_TRUE(response->complete());\n  std::set<std::string> expected_metadata_keys = {\"headers\", \"duplicate\"};\n  verifyExpectedMetadata(response->metadata_map(), expected_metadata_keys);\n\n  // Upstream responds with headers and data.\n  response = codec_client_->makeRequestWithBody(default_request_headers_, 10);\n  waitForNextUpstreamRequest();\n  upstream_request_->encodeHeaders(default_response_headers_, false);\n  upstream_request_->encodeData(100, true);\n\n  response->waitForEndStream();\n  ASSERT_TRUE(response->complete());\n  expected_metadata_keys.insert(\"data\");\n  verifyExpectedMetadata(response->metadata_map(), expected_metadata_keys);\n  EXPECT_EQ(response->keyCount(\"duplicate\"), 2);\n\n  // Upstream responds with headers, data and trailers.\n  response = codec_client_->makeRequestWithBody(default_request_headers_, 10);\n  waitForNextUpstreamRequest();\n  upstream_request_->encodeHeaders(default_response_headers_, false);\n  upstream_request_->encodeData(10, false);\n  Http::TestHeaderMapImpl response_trailers{{\"response\", \"trailer\"}};\n  upstream_request_->encodeTrailers(response_trailers);\n\n  response->waitForEndStream();\n  ASSERT_TRUE(response->complete());\n  expected_metadata_keys.insert(\"trailers\");\n  verifyExpectedMetadata(response->metadata_map(), expected_metadata_keys);\n  EXPECT_EQ(response->keyCount(\"duplicate\"), 3);\n\n  // Upstream responds with headers, 100-continue and data.\n  response = codec_client_->makeRequestWithBody(Http::TestHeaderMapImpl{{\":method\", \"GET\"},\n                                                                        {\":path\", \"/dynamo/url\"},\n                                                                        {\":scheme\", \"http\"},\n                                                                        {\":authority\", \"host\"},\n                                                                        {\"expect\", \"100-continue\"}},\n                                                10);\n\n  waitForNextUpstreamRequest();\n  upstream_request_->encode100ContinueHeaders(Http::TestHeaderMapImpl{{\":status\", \"100\"}});\n  response->waitForContinueHeaders();\n  upstream_request_->encodeHeaders(default_response_headers_, false);\n  upstream_request_->encodeData(100, true);\n\n  response->waitForEndStream();\n  ASSERT_TRUE(response->complete());\n  expected_metadata_keys.erase(\"trailers\");\n  expected_metadata_keys.insert(\"100-continue\");\n  verifyExpectedMetadata(response->metadata_map(), expected_metadata_keys);\n  EXPECT_EQ(response->keyCount(\"duplicate\"), 4);\n\n  // Upstream responds with headers and metadata that will not be consumed.\n  response = codec_client_->makeRequestWithBody(default_request_headers_, 10);\n  waitForNextUpstreamRequest();\n  Http::MetadataMap metadata_map = {{\"aaa\", \"aaa\"}};\n  Http::MetadataMapPtr metadata_map_ptr = std::make_unique<Http::MetadataMap>(metadata_map);\n  Http::MetadataMapVector metadata_map_vector;\n  metadata_map_vector.push_back(std::move(metadata_map_ptr));\n  upstream_request_->encodeMetadata(metadata_map_vector);\n  upstream_request_->encodeHeaders(default_response_headers_, true);\n\n  response->waitForEndStream();\n  ASSERT_TRUE(response->complete());\n  expected_metadata_keys.erase(\"data\");\n  expected_metadata_keys.erase(\"100-continue\");\n  expected_metadata_keys.insert(\"aaa\");\n  expected_metadata_keys.insert(\"keep\");\n  verifyExpectedMetadata(response->metadata_map(), expected_metadata_keys);\n\n  // Upstream responds with headers, data and metadata that will be consumed.\n  response = codec_client_->makeRequestWithBody(default_request_headers_, 10);\n  waitForNextUpstreamRequest();\n  metadata_map = {{\"consume\", \"consume\"}};\n  metadata_map_ptr = std::make_unique<Http::MetadataMap>(metadata_map);\n  metadata_map_vector.clear();\n  metadata_map_vector.push_back(std::move(metadata_map_ptr));\n  upstream_request_->encodeMetadata(metadata_map_vector);\n  upstream_request_->encodeHeaders(default_response_headers_, false);\n  upstream_request_->encodeData(100, true);\n\n  response->waitForEndStream();\n  ASSERT_TRUE(response->complete());\n  expected_metadata_keys.erase(\"aaa\");\n  expected_metadata_keys.insert(\"data\");\n  expected_metadata_keys.insert(\"replace\");\n  verifyExpectedMetadata(response->metadata_map(), expected_metadata_keys);\n  EXPECT_EQ(response->keyCount(\"duplicate\"), 2);\n}\n\nTEST_P(Http2MetadataIntegrationTest, ProxyMultipleMetadataReachSizeLimit) {\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  // Sends a request.\n  auto response = codec_client_->makeRequestWithBody(default_request_headers_, 10);\n  waitForNextUpstreamRequest();\n\n  // Sends multiple metadata after response header until max size limit is reached.\n  upstream_request_->encodeHeaders(default_response_headers_, false);\n  const int size = 200;\n  std::vector<Http::MetadataMapVector> multiple_vecs(size);\n  for (int i = 0; i < size; i++) {\n    Http::MetadataMap metadata_map = {{\"key\", std::string(10000, 'a')}};\n    Http::MetadataMapPtr metadata_map_ptr = std::make_unique<Http::MetadataMap>(metadata_map);\n    multiple_vecs[i].push_back(std::move(metadata_map_ptr));\n    upstream_request_->encodeMetadata(multiple_vecs[i]);\n  }\n  upstream_request_->encodeData(12, true);\n\n  // Verifies reset is received.\n  response->waitForReset();\n  ASSERT_FALSE(response->complete());\n}\n\n// Verifies small metadata can be sent at different locations of a request.\nTEST_P(Http2MetadataIntegrationTest, ProxySmallMetadataInRequest) {\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  auto encoder_decoder = codec_client_->startRequest(default_request_headers_);\n  request_encoder_ = &encoder_decoder.first;\n  auto response = std::move(encoder_decoder.second);\n  Http::MetadataMap metadata_map = {{\"key\", \"value\"}};\n  codec_client_->sendMetadata(*request_encoder_, metadata_map);\n  codec_client_->sendData(*request_encoder_, 1, false);\n  codec_client_->sendMetadata(*request_encoder_, metadata_map);\n  codec_client_->sendData(*request_encoder_, 1, false);\n  codec_client_->sendMetadata(*request_encoder_, metadata_map);\n  Http::TestHeaderMapImpl request_trailers{{\"request\", \"trailer\"}};\n  codec_client_->sendTrailers(*request_encoder_, request_trailers);\n\n  waitForNextUpstreamRequest();\n\n  // Verifies metadata is received by upstream.\n  upstream_request_->encodeHeaders(default_response_headers_, true);\n  EXPECT_EQ(upstream_request_->metadata_map().find(\"key\")->second, \"value\");\n  EXPECT_EQ(upstream_request_->metadata_map().size(), 1);\n  EXPECT_EQ(upstream_request_->duplicated_metadata_key_count().find(\"key\")->second, 3);\n\n  response->waitForEndStream();\n  ASSERT_TRUE(response->complete());\n}\n\n// Verifies large metadata can be sent at different locations of a request.\nTEST_P(Http2MetadataIntegrationTest, ProxyLargeMetadataInRequest) {\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  auto encoder_decoder = codec_client_->startRequest(default_request_headers_);\n  request_encoder_ = &encoder_decoder.first;\n  auto response = std::move(encoder_decoder.second);\n  std::string value = std::string(80 * 1024, '1');\n  Http::MetadataMap metadata_map = {{\"key\", value}};\n  codec_client_->sendMetadata(*request_encoder_, metadata_map);\n  codec_client_->sendData(*request_encoder_, 1, false);\n  codec_client_->sendMetadata(*request_encoder_, metadata_map);\n  codec_client_->sendData(*request_encoder_, 1, false);\n  codec_client_->sendMetadata(*request_encoder_, metadata_map);\n  Http::TestHeaderMapImpl request_trailers{{\"request\", \"trailer\"}};\n  codec_client_->sendTrailers(*request_encoder_, request_trailers);\n\n  waitForNextUpstreamRequest();\n\n  // Verifies metadata is received upstream.\n  upstream_request_->encodeHeaders(default_response_headers_, true);\n  EXPECT_EQ(upstream_request_->metadata_map().find(\"key\")->second, value);\n  EXPECT_EQ(upstream_request_->metadata_map().size(), 1);\n  EXPECT_EQ(upstream_request_->duplicated_metadata_key_count().find(\"key\")->second, 3);\n\n  response->waitForEndStream();\n  ASSERT_TRUE(response->complete());\n}\n\nTEST_P(Http2MetadataIntegrationTest, RequestMetadataReachSizeLimit) {\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  fake_upstreams_[0]->set_allow_unexpected_disconnects(true);\n\n  auto encoder_decoder = codec_client_->startRequest(default_request_headers_);\n  request_encoder_ = &encoder_decoder.first;\n  auto response = std::move(encoder_decoder.second);\n  std::string value = std::string(10 * 1024, '1');\n  Http::MetadataMap metadata_map = {{\"key\", value}};\n  codec_client_->sendMetadata(*request_encoder_, metadata_map);\n  codec_client_->sendData(*request_encoder_, 1, false);\n  codec_client_->sendMetadata(*request_encoder_, metadata_map);\n  codec_client_->sendData(*request_encoder_, 1, false);\n  for (int i = 0; i < 200; i++) {\n    codec_client_->sendMetadata(*request_encoder_, metadata_map);\n    if (codec_client_->disconnected()) {\n      break;\n    }\n  }\n\n  // Verifies client connection will be closed.\n  codec_client_->waitForDisconnect();\n  ASSERT_FALSE(response->complete());\n}\n\nstatic std::string request_metadata_filter = R\"EOF(\nname: request-metadata-filter\nconfig: {}\n)EOF\";\n\nTEST_P(Http2MetadataIntegrationTest, ConsumeAndInsertRequestMetadata) {\n  addFilters({request_metadata_filter});\n  config_helper_.addConfigModifier(\n      [&](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager& hcm)\n          -> void { hcm.set_proxy_100_continue(true); });\n\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  // Sends a headers only request.\n  auto response = codec_client_->makeHeaderOnlyRequest(default_request_headers_);\n  waitForNextUpstreamRequest();\n\n  upstream_request_->encodeHeaders(default_response_headers_, true);\n  response->waitForEndStream();\n  ASSERT_TRUE(response->complete());\n  // Verifies a headers metadata added.\n  std::set<std::string> expected_metadata_keys = {\"headers\"};\n  expected_metadata_keys.insert(\"metadata\");\n  verifyExpectedMetadata(upstream_request_->metadata_map(), expected_metadata_keys);\n\n  // Sends a headers only request with metadata. An empty data frame carries end_stream.\n  auto encoder_decoder = codec_client_->startRequest(default_request_headers_);\n  request_encoder_ = &encoder_decoder.first;\n  response = std::move(encoder_decoder.second);\n  Http::MetadataMap metadata_map = {{\"consume\", \"consume\"}};\n  codec_client_->sendMetadata(*request_encoder_, metadata_map);\n  codec_client_->sendData(*request_encoder_, 0, true);\n  waitForNextUpstreamRequest();\n\n  upstream_request_->encodeHeaders(default_response_headers_, true);\n  response->waitForEndStream();\n  ASSERT_TRUE(response->complete());\n  expected_metadata_keys.insert(\"data\");\n  expected_metadata_keys.insert(\"metadata\");\n  expected_metadata_keys.insert(\"replace\");\n  verifyExpectedMetadata(upstream_request_->metadata_map(), expected_metadata_keys);\n  EXPECT_EQ(upstream_request_->duplicated_metadata_key_count().find(\"metadata\")->second, 3);\n  // Verifies zero length data received, and end_stream is true.\n  EXPECT_EQ(true, upstream_request_->receivedData());\n  EXPECT_EQ(0, upstream_request_->bodyLength());\n  EXPECT_EQ(true, upstream_request_->complete());\n\n  // Sends headers, data, metadata and trailer.\n  auto encoder_decoder_2 = codec_client_->startRequest(default_request_headers_);\n  request_encoder_ = &encoder_decoder_2.first;\n  response = std::move(encoder_decoder_2.second);\n  codec_client_->sendData(*request_encoder_, 10, false);\n  metadata_map = {{\"consume\", \"consume\"}};\n  codec_client_->sendMetadata(*request_encoder_, metadata_map);\n  Http::TestHeaderMapImpl request_trailers{{\"trailer\", \"trailer\"}};\n  codec_client_->sendTrailers(*request_encoder_, request_trailers);\n  waitForNextUpstreamRequest();\n\n  upstream_request_->encodeHeaders(default_response_headers_, true);\n  response->waitForEndStream();\n  ASSERT_TRUE(response->complete());\n  expected_metadata_keys.insert(\"trailers\");\n  verifyExpectedMetadata(upstream_request_->metadata_map(), expected_metadata_keys);\n  EXPECT_EQ(upstream_request_->duplicated_metadata_key_count().find(\"metadata\")->second, 4);\n\n  // Sends headers, large data, metadata. Large data triggers decodeData() multiple times, and each\n  // time, a \"data\" metadata is added.\n  auto encoder_decoder_3 = codec_client_->startRequest(default_request_headers_);\n  request_encoder_ = &encoder_decoder_3.first;\n  response = std::move(encoder_decoder_3.second);\n  codec_client_->sendData(*request_encoder_, 100000, false);\n  codec_client_->sendMetadata(*request_encoder_, metadata_map);\n  codec_client_->sendData(*request_encoder_, 100000, true);\n  waitForNextUpstreamRequest();\n\n  upstream_request_->encodeHeaders(default_response_headers_, true);\n  response->waitForEndStream();\n  ASSERT_TRUE(response->complete());\n\n  expected_metadata_keys.erase(\"trailers\");\n  verifyExpectedMetadata(upstream_request_->metadata_map(), expected_metadata_keys);\n  EXPECT_GE(upstream_request_->duplicated_metadata_key_count().find(\"data\")->second, 2);\n  EXPECT_GE(upstream_request_->duplicated_metadata_key_count().find(\"metadata\")->second, 3);\n\n  // Sends multiple metadata.\n  auto encoder_decoder_4 = codec_client_->startRequest(default_request_headers_);\n  request_encoder_ = &encoder_decoder_4.first;\n  response = std::move(encoder_decoder_4.second);\n  metadata_map = {{\"metadata1\", \"metadata1\"}};\n  codec_client_->sendMetadata(*request_encoder_, metadata_map);\n  codec_client_->sendData(*request_encoder_, 10, false);\n  metadata_map = {{\"metadata2\", \"metadata2\"}};\n  codec_client_->sendMetadata(*request_encoder_, metadata_map);\n  metadata_map = {{\"consume\", \"consume\"}};\n  codec_client_->sendMetadata(*request_encoder_, metadata_map);\n  codec_client_->sendTrailers(*request_encoder_, request_trailers);\n  waitForNextUpstreamRequest();\n\n  upstream_request_->encodeHeaders(default_response_headers_, true);\n  response->waitForEndStream();\n  ASSERT_TRUE(response->complete());\n  expected_metadata_keys.insert(\"metadata1\");\n  expected_metadata_keys.insert(\"metadata2\");\n  expected_metadata_keys.insert(\"trailers\");\n  verifyExpectedMetadata(upstream_request_->metadata_map(), expected_metadata_keys);\n  EXPECT_EQ(upstream_request_->duplicated_metadata_key_count().find(\"metadata\")->second, 6);\n}\n\nstatic std::string decode_headers_only = R\"EOF(\nname: decode-headers-only\nconfig: {}\n)EOF\";\n\nvoid Http2MetadataIntegrationTest::runHeaderOnlyTest(bool send_request_body, size_t body_size) {\n  config_helper_.addConfigModifier(\n      [&](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager& hcm)\n          -> void { hcm.set_proxy_100_continue(true); });\n\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  // Sends a request with body. Only headers will pass through filters.\n  IntegrationStreamDecoderPtr response;\n  if (send_request_body) {\n    response =\n        codec_client_->makeRequestWithBody(Http::TestHeaderMapImpl{{\":method\", \"POST\"},\n                                                                   {\":path\", \"/test/long/url\"},\n                                                                   {\":scheme\", \"http\"},\n                                                                   {\":authority\", \"host\"}},\n                                           body_size);\n  } else {\n    response =\n        codec_client_->makeHeaderOnlyRequest(Http::TestHeaderMapImpl{{\":method\", \"POST\"},\n                                                                     {\":path\", \"/test/long/url\"},\n                                                                     {\":scheme\", \"http\"},\n                                                                     {\":authority\", \"host\"}});\n  }\n  waitForNextUpstreamRequest();\n\n  upstream_request_->encodeHeaders(default_response_headers_, true);\n  response->waitForEndStream();\n  ASSERT_TRUE(response->complete());\n}\n\nvoid Http2MetadataIntegrationTest::verifyHeadersOnlyTest() {\n  // Verifies a headers metadata added.\n  std::set<std::string> expected_metadata_keys = {\"headers\"};\n  expected_metadata_keys.insert(\"metadata\");\n  verifyExpectedMetadata(upstream_request_->metadata_map(), expected_metadata_keys);\n\n  // Verifies zero length data received, and end_stream is true.\n  EXPECT_EQ(true, upstream_request_->receivedData());\n  EXPECT_EQ(0, upstream_request_->bodyLength());\n  EXPECT_EQ(true, upstream_request_->complete());\n}\n\nTEST_P(Http2MetadataIntegrationTest, DecodingHeadersOnlyRequestWithRequestMetadataEmptyData) {\n  addFilters({request_metadata_filter, decode_headers_only});\n\n  // Send a request with body, and body size is 0.\n  runHeaderOnlyTest(true, 0);\n  verifyHeadersOnlyTest();\n}\n\nTEST_P(Http2MetadataIntegrationTest, DecodingHeadersOnlyRequestWithRequestMetadataNoneEmptyData) {\n  addFilters({request_metadata_filter, decode_headers_only});\n  // Send a request with body, and body size is 128.\n  runHeaderOnlyTest(true, 128);\n  verifyHeadersOnlyTest();\n}\n\nTEST_P(Http2MetadataIntegrationTest, DecodingHeadersOnlyRequestWithRequestMetadataDiffFilterOrder) {\n  addFilters({decode_headers_only, request_metadata_filter});\n  // Send a request with body, and body size is 128.\n  runHeaderOnlyTest(true, 128);\n  verifyHeadersOnlyTest();\n}\n\nTEST_P(Http2MetadataIntegrationTest, HeadersOnlyRequestWithRequestMetadata) {\n  addFilters({request_metadata_filter});\n  // Send a headers only request.\n  runHeaderOnlyTest(false, 0);\n  verifyHeadersOnlyTest();\n}\n\nvoid Http2MetadataIntegrationTest::testRequestMetadataWithStopAllFilter() {\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  // Sends multiple metadata.\n  const size_t size = 10;\n  default_request_headers_.addCopy(\"content_size\", std::to_string(size));\n  auto encoder_decoder = codec_client_->startRequest(default_request_headers_);\n  request_encoder_ = &encoder_decoder.first;\n  auto response = std::move(encoder_decoder.second);\n  Http::MetadataMap metadata_map = {{\"metadata1\", \"metadata1\"}};\n  codec_client_->sendMetadata(*request_encoder_, metadata_map);\n  codec_client_->sendData(*request_encoder_, size, false);\n  metadata_map = {{\"metadata2\", \"metadata2\"}};\n  codec_client_->sendMetadata(*request_encoder_, metadata_map);\n  metadata_map = {{\"consume\", \"consume\"}};\n  codec_client_->sendMetadata(*request_encoder_, metadata_map);\n  Http::TestHeaderMapImpl request_trailers{{\"trailer\", \"trailer\"}};\n  codec_client_->sendTrailers(*request_encoder_, request_trailers);\n  waitForNextUpstreamRequest();\n\n  upstream_request_->encodeHeaders(default_response_headers_, true);\n  response->waitForEndStream();\n  ASSERT_TRUE(response->complete());\n  std::set<std::string> expected_metadata_keys = {\"headers\",   \"data\",    \"metadata\", \"metadata1\",\n                                                  \"metadata2\", \"replace\", \"trailers\"};\n  verifyExpectedMetadata(upstream_request_->metadata_map(), expected_metadata_keys);\n  EXPECT_EQ(upstream_request_->duplicated_metadata_key_count().find(\"metadata\")->second, 6);\n}\n\nstatic std::string metadata_stop_all_filter = R\"EOF(\nname: metadata-stop-all-filter\nconfig: {}\n)EOF\";\n\nTEST_P(Http2MetadataIntegrationTest, RequestMetadataWithStopAllFilterBeforeMetadataFilter) {\n  addFilters({request_metadata_filter, metadata_stop_all_filter});\n  testRequestMetadataWithStopAllFilter();\n}\n\nTEST_P(Http2MetadataIntegrationTest, RequestMetadataWithStopAllFilterAfterMetadataFilter) {\n  addFilters({metadata_stop_all_filter, request_metadata_filter});\n  testRequestMetadataWithStopAllFilter();\n}\n\nTEST_P(Http2MetadataIntegrationTest, TestAddEncodedMetadata) {\n  config_helper_.addFilter(R\"EOF(\nname: encode-headers-return-stop-all-filter\n)EOF\");\n\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  // Upstream responds with headers, data and trailers.\n  auto response = codec_client_->makeRequestWithBody(default_request_headers_, 10);\n  waitForNextUpstreamRequest();\n\n  const int count = 70;\n  const int size = 1000;\n  const int added_decoded_data_size = 1;\n\n  default_response_headers_.addCopy(\"content_size\", std::to_string(count * size));\n  default_response_headers_.addCopy(\"added_size\", std::to_string(added_decoded_data_size));\n  default_response_headers_.addCopy(\"is_first_trigger\", \"value\");\n\n  upstream_request_->encodeHeaders(default_response_headers_, false);\n  for (int i = 0; i < count - 1; i++) {\n    upstream_request_->encodeData(size, false);\n  }\n\n  upstream_request_->encodeData(size, false);\n  Http::TestHeaderMapImpl response_trailers{{\"response\", \"trailer\"}};\n  upstream_request_->encodeTrailers(response_trailers);\n\n  response->waitForEndStream();\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(response->metadata_map().find(\"headers\")->second, \"headers\");\n  EXPECT_EQ(response->metadata_map().find(\"data\")->second, \"data\");\n  EXPECT_EQ(response->metadata_map().find(\"trailers\")->second, \"trailers\");\n  EXPECT_EQ(response->metadata_map().size(), 3);\n  EXPECT_EQ(count * size + added_decoded_data_size * 2, response->body().size());\n}\n\nTEST_P(Http2IntegrationTest, GrpcRouterNotFound) {\n  config_helper_.setDefaultHostAndRoute(\"foo.com\", \"/found\");\n  initialize();\n\n  BufferingStreamDecoderPtr response = IntegrationUtil::makeSingleRequest(\n      lookupPort(\"http\"), \"POST\", \"/service/notfound\", \"\", downstream_protocol_, version_, \"host\",\n      Http::Headers::get().ContentTypeValues.Grpc);\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().Status()->value().getStringView());\n  EXPECT_EQ(Http::Headers::get().ContentTypeValues.Grpc,\n            response->headers().ContentType()->value().getStringView());\n  EXPECT_EQ(\"12\", response->headers().GrpcStatus()->value().getStringView());\n}\n\nTEST_P(Http2IntegrationTest, GrpcRetry) { testGrpcRetry(); }\n\n// Verify the case where there is an HTTP/2 codec/protocol error with an active stream.\nTEST_P(Http2IntegrationTest, CodecErrorAfterStreamStart) {\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  // Sends a request.\n  auto response = codec_client_->makeRequestWithBody(default_request_headers_, 10);\n  waitForNextUpstreamRequest();\n\n  // Send bogus raw data on the connection.\n  Buffer::OwnedImpl bogus_data(\"some really bogus data\");\n  codec_client_->rawConnection().write(bogus_data, false);\n\n  // Verifies reset is received.\n  response->waitForReset();\n}\n\nTEST_P(Http2IntegrationTest, BadMagic) {\n  initialize();\n  Buffer::OwnedImpl buffer(\"hello\");\n  std::string response;\n  RawConnectionDriver connection(\n      lookupPort(\"http\"), buffer,\n      [&](Network::ClientConnection&, const Buffer::Instance& data) -> void {\n        response.append(data.toString());\n      },\n      version_);\n\n  connection.run();\n  EXPECT_EQ(\"\", response);\n}\n\nTEST_P(Http2IntegrationTest, BadFrame) {\n  initialize();\n  Buffer::OwnedImpl buffer(\"PRI * HTTP/2.0\\r\\n\\r\\nSM\\r\\n\\r\\nhelloworldcauseanerror\");\n  std::string response;\n  RawConnectionDriver connection(\n      lookupPort(\"http\"), buffer,\n      [&](Network::ClientConnection&, const Buffer::Instance& data) -> void {\n        response.append(data.toString());\n      },\n      version_);\n\n  connection.run();\n  EXPECT_TRUE(response.find(\"SETTINGS expected\") != std::string::npos);\n}\n\n// Send client headers, a GoAway and then a body and ensure the full request and\n// response are received.\nTEST_P(Http2IntegrationTest, GoAway) {\n  config_helper_.addFilter(ConfigHelper::DEFAULT_HEALTH_CHECK_FILTER);\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  auto encoder_decoder = codec_client_->startRequest(Http::TestHeaderMapImpl{\n      {\":method\", \"GET\"}, {\":path\", \"/healthcheck\"}, {\":scheme\", \"http\"}, {\":authority\", \"host\"}});\n  request_encoder_ = &encoder_decoder.first;\n  auto response = std::move(encoder_decoder.second);\n  codec_client_->goAway();\n  codec_client_->sendData(*request_encoder_, 0, true);\n  response->waitForEndStream();\n  codec_client_->close();\n\n  EXPECT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().Status()->value().getStringView());\n}\n\nTEST_P(Http2IntegrationTest, Trailers) { testTrailers(1024, 2048); }\n\nTEST_P(Http2IntegrationTest, TrailersGiantBody) { testTrailers(1024 * 1024, 1024 * 1024); }\n\nTEST_P(Http2IntegrationTest, GrpcRequestTimeout) {\n  config_helper_.addConfigModifier(\n      [&](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager& hcm)\n          -> void {\n        auto* route_config = hcm.mutable_route_config();\n        auto* virtual_host = route_config->mutable_virtual_hosts(0);\n        auto* route = virtual_host->mutable_routes(0);\n        route->mutable_route()->mutable_max_grpc_timeout()->set_seconds(60 * 60);\n      });\n  initialize();\n\n  // Envoy will close some number of connections when request times out.\n  // Make sure they don't cause assertion failures when we ignore them.\n  fake_upstreams_[0]->set_allow_unexpected_disconnects(true);\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  // With upstream request timeout Envoy should send a gRPC-Status \"DEADLINE EXCEEDED\".\n  // TODO: Properly map request timeout to \"DEADLINE EXCEEDED\" instead of \"SERVICE UNAVAILABLE\".\n  auto response = codec_client_->makeHeaderOnlyRequest(\n      Http::TestHeaderMapImpl{{\":method\", \"POST\"},\n                              {\":path\", \"/test/long/url\"},\n                              {\":scheme\", \"http\"},\n                              {\":authority\", \"host\"},\n                              {\"te\", \"trailers\"},\n                              {\"grpc-timeout\", \"1S\"}, // 1 Second\n                              {\"content-type\", \"application/grpc\"}});\n  response->waitForEndStream();\n  EXPECT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().Status()->value().getStringView());\n  EXPECT_NE(response->headers().GrpcStatus(), nullptr);\n  EXPECT_EQ(\"14\", response->headers().GrpcStatus()->value().getStringView()); // Service Unavailable\n  EXPECT_LT(0, test_server_->counter(\"cluster.cluster_0.upstream_rq_timeout\")->value());\n}\n\n// Interleave two requests and responses and make sure that idle timeout is handled correctly.\nTEST_P(Http2IntegrationTest, IdleTimeoutWithSimultaneousRequests) {\n  FakeHttpConnectionPtr fake_upstream_connection1;\n  FakeHttpConnectionPtr fake_upstream_connection2;\n  Http::StreamEncoder* encoder1;\n  Http::StreamEncoder* encoder2;\n  FakeStreamPtr upstream_request1;\n  FakeStreamPtr upstream_request2;\n  int32_t request1_bytes = 1024;\n  int32_t request2_bytes = 512;\n\n  config_helper_.addConfigModifier([](envoy::config::bootstrap::v2::Bootstrap& bootstrap) {\n    auto* static_resources = bootstrap.mutable_static_resources();\n    auto* cluster = static_resources->mutable_clusters(0);\n    auto* http_protocol_options = cluster->mutable_common_http_protocol_options();\n    auto* idle_time_out = http_protocol_options->mutable_idle_timeout();\n    std::chrono::milliseconds timeout(1000);\n    auto seconds = std::chrono::duration_cast<std::chrono::seconds>(timeout);\n    idle_time_out->set_seconds(seconds.count());\n  });\n\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  // Start request 1\n  auto encoder_decoder =\n      codec_client_->startRequest(Http::TestHeaderMapImpl{{\":method\", \"POST\"},\n                                                          {\":path\", \"/test/long/url\"},\n                                                          {\":scheme\", \"http\"},\n                                                          {\":authority\", \"host\"}});\n  encoder1 = &encoder_decoder.first;\n  auto response1 = std::move(encoder_decoder.second);\n\n  ASSERT_TRUE(fake_upstreams_[0]->waitForHttpConnection(*dispatcher_, fake_upstream_connection1));\n  ASSERT_TRUE(fake_upstream_connection1->waitForNewStream(*dispatcher_, upstream_request1));\n\n  // Start request 2\n  auto encoder_decoder2 =\n      codec_client_->startRequest(Http::TestHeaderMapImpl{{\":method\", \"POST\"},\n                                                          {\":path\", \"/test/long/url\"},\n                                                          {\":scheme\", \"http\"},\n                                                          {\":authority\", \"host\"}});\n  encoder2 = &encoder_decoder2.first;\n  auto response2 = std::move(encoder_decoder2.second);\n  ASSERT_TRUE(fake_upstreams_[0]->waitForHttpConnection(*dispatcher_, fake_upstream_connection2));\n  ASSERT_TRUE(fake_upstream_connection2->waitForNewStream(*dispatcher_, upstream_request2));\n\n  // Finish request 1\n  codec_client_->sendData(*encoder1, request1_bytes, true);\n  ASSERT_TRUE(upstream_request1->waitForEndStream(*dispatcher_));\n\n  // Finish request i2\n  codec_client_->sendData(*encoder2, request2_bytes, true);\n  ASSERT_TRUE(upstream_request2->waitForEndStream(*dispatcher_));\n\n  // Respond to request 2\n  upstream_request2->encodeHeaders(Http::TestHeaderMapImpl{{\":status\", \"200\"}}, false);\n  upstream_request2->encodeData(request2_bytes, true);\n  response2->waitForEndStream();\n  EXPECT_TRUE(upstream_request2->complete());\n  EXPECT_EQ(request2_bytes, upstream_request2->bodyLength());\n  EXPECT_TRUE(response2->complete());\n  EXPECT_EQ(\"200\", response2->headers().Status()->value().getStringView());\n  EXPECT_EQ(request2_bytes, response2->body().size());\n\n  // Validate that idle time is not kicked in.\n  EXPECT_EQ(0, test_server_->counter(\"cluster.cluster_0.upstream_cx_idle_timeout\")->value());\n  EXPECT_NE(0, test_server_->counter(\"cluster.cluster_0.upstream_cx_total\")->value());\n\n  // Respond to request 1\n  upstream_request1->encodeHeaders(Http::TestHeaderMapImpl{{\":status\", \"200\"}}, false);\n  upstream_request1->encodeData(request1_bytes, true);\n  response1->waitForEndStream();\n  EXPECT_TRUE(upstream_request1->complete());\n  EXPECT_EQ(request1_bytes, upstream_request1->bodyLength());\n  EXPECT_TRUE(response1->complete());\n  EXPECT_EQ(\"200\", response1->headers().Status()->value().getStringView());\n  EXPECT_EQ(request1_bytes, response1->body().size());\n\n  // Do not send any requests and validate idle timeout kicks in after both the requests are done.\n  ASSERT_TRUE(fake_upstream_connection1->waitForDisconnect());\n  ASSERT_TRUE(fake_upstream_connection2->waitForDisconnect());\n  test_server_->waitForCounterGe(\"cluster.cluster_0.upstream_cx_idle_timeout\", 2);\n}\n\n// Test request mirroring / shadowing with an HTTP/2 downstream and a request with a body.\nTEST_P(Http2IntegrationTest, RequestMirrorWithBody) {\n  config_helper_.addConfigModifier(\n      [&](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager& hcm)\n          -> void {\n        hcm.mutable_route_config()\n            ->mutable_virtual_hosts(0)\n            ->mutable_routes(0)\n            ->mutable_route()\n            ->mutable_request_mirror_policy()\n            ->set_cluster(\"cluster_0\");\n      });\n\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  // Send request with body.\n  IntegrationStreamDecoderPtr request =\n      codec_client_->makeRequestWithBody(Http::TestHeaderMapImpl{{\":method\", \"POST\"},\n                                                                 {\":path\", \"/test/long/url\"},\n                                                                 {\":scheme\", \"http\"},\n                                                                 {\":authority\", \"host\"}},\n                                         \"hello\");\n\n  // Wait for the first request as well as the shadow.\n  waitForNextUpstreamRequest();\n\n  FakeHttpConnectionPtr fake_upstream_connection2;\n  FakeStreamPtr upstream_request2;\n  ASSERT_TRUE(fake_upstreams_[0]->waitForHttpConnection(*dispatcher_, fake_upstream_connection2));\n  ASSERT_TRUE(fake_upstream_connection2->waitForNewStream(*dispatcher_, upstream_request2));\n  ASSERT_TRUE(upstream_request2->waitForEndStream(*dispatcher_));\n\n  // Make sure both requests have a body. Also check the shadow for the shadow headers.\n  EXPECT_EQ(\"hello\", upstream_request_->body().toString());\n  EXPECT_EQ(\"hello\", upstream_request2->body().toString());\n  EXPECT_EQ(\"host-shadow\", upstream_request2->headers().Host()->value().getStringView());\n\n  upstream_request_->encodeHeaders(Http::TestHeaderMapImpl{{\":status\", \"200\"}}, true);\n  upstream_request2->encodeHeaders(Http::TestHeaderMapImpl{{\":status\", \"200\"}}, true);\n  request->waitForEndStream();\n  EXPECT_EQ(\"200\", request->headers().Status()->value().getStringView());\n\n  // Cleanup.\n  ASSERT_TRUE(fake_upstream_connection2->close());\n  ASSERT_TRUE(fake_upstream_connection2->waitForDisconnect());\n}\n\n// Interleave two requests and responses and make sure the HTTP2 stack handles this correctly.\nvoid Http2IntegrationTest::simultaneousRequest(int32_t request1_bytes, int32_t request2_bytes) {\n  FakeHttpConnectionPtr fake_upstream_connection1;\n  FakeHttpConnectionPtr fake_upstream_connection2;\n  Http::StreamEncoder* encoder1;\n  Http::StreamEncoder* encoder2;\n  FakeStreamPtr upstream_request1;\n  FakeStreamPtr upstream_request2;\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  // Start request 1\n  auto encoder_decoder =\n      codec_client_->startRequest(Http::TestHeaderMapImpl{{\":method\", \"POST\"},\n                                                          {\":path\", \"/test/long/url\"},\n                                                          {\":scheme\", \"http\"},\n                                                          {\":authority\", \"host\"}});\n  encoder1 = &encoder_decoder.first;\n  auto response1 = std::move(encoder_decoder.second);\n\n  ASSERT_TRUE(fake_upstreams_[0]->waitForHttpConnection(*dispatcher_, fake_upstream_connection1));\n  ASSERT_TRUE(fake_upstream_connection1->waitForNewStream(*dispatcher_, upstream_request1));\n\n  // Start request 2\n  auto encoder_decoder2 =\n      codec_client_->startRequest(Http::TestHeaderMapImpl{{\":method\", \"POST\"},\n                                                          {\":path\", \"/test/long/url\"},\n                                                          {\":scheme\", \"http\"},\n                                                          {\":authority\", \"host\"}});\n  encoder2 = &encoder_decoder2.first;\n  auto response2 = std::move(encoder_decoder2.second);\n  ASSERT_TRUE(fake_upstreams_[0]->waitForHttpConnection(*dispatcher_, fake_upstream_connection2));\n  ASSERT_TRUE(fake_upstream_connection2->waitForNewStream(*dispatcher_, upstream_request2));\n\n  // Finish request 1\n  codec_client_->sendData(*encoder1, request1_bytes, true);\n  ASSERT_TRUE(upstream_request1->waitForEndStream(*dispatcher_));\n\n  // Finish request 2\n  codec_client_->sendData(*encoder2, request2_bytes, true);\n  ASSERT_TRUE(upstream_request2->waitForEndStream(*dispatcher_));\n\n  // Respond to request 2\n  upstream_request2->encodeHeaders(Http::TestHeaderMapImpl{{\":status\", \"200\"}}, false);\n  upstream_request2->encodeData(request2_bytes, true);\n  response2->waitForEndStream();\n  EXPECT_TRUE(upstream_request2->complete());\n  EXPECT_EQ(request2_bytes, upstream_request2->bodyLength());\n  EXPECT_TRUE(response2->complete());\n  EXPECT_EQ(\"200\", response2->headers().Status()->value().getStringView());\n  EXPECT_EQ(request2_bytes, response2->body().size());\n\n  // Respond to request 1\n  upstream_request1->encodeHeaders(Http::TestHeaderMapImpl{{\":status\", \"200\"}}, false);\n  upstream_request1->encodeData(request2_bytes, true);\n  response1->waitForEndStream();\n  EXPECT_TRUE(upstream_request1->complete());\n  EXPECT_EQ(request1_bytes, upstream_request1->bodyLength());\n  EXPECT_TRUE(response1->complete());\n  EXPECT_EQ(\"200\", response1->headers().Status()->value().getStringView());\n  EXPECT_EQ(request2_bytes, response1->body().size());\n\n  // Cleanup both downstream and upstream\n  ASSERT_TRUE(fake_upstream_connection1->close());\n  ASSERT_TRUE(fake_upstream_connection1->waitForDisconnect());\n  ASSERT_TRUE(fake_upstream_connection2->close());\n  ASSERT_TRUE(fake_upstream_connection2->waitForDisconnect());\n  codec_client_->close();\n}\n\nTEST_P(Http2IntegrationTest, SimultaneousRequest) { simultaneousRequest(1024, 512); }\n\nTEST_P(Http2IntegrationTest, SimultaneousRequestWithBufferLimits) {\n  config_helper_.setBufferLimits(1024, 1024); // Set buffer limits upstream and downstream.\n  simultaneousRequest(1024 * 32, 1024 * 16);\n}\n\n// Test downstream connection delayed close processing.\nTEST_P(Http2IntegrationTest, DelayedCloseAfterBadFrame) {\n  initialize();\n  Buffer::OwnedImpl buffer(\"PRI * HTTP/2.0\\r\\n\\r\\nSM\\r\\n\\r\\nhelloworldcauseanerror\");\n  std::string response;\n  RawConnectionDriver connection(\n      lookupPort(\"http\"), buffer,\n      [&](Network::ClientConnection& connection, const Buffer::Instance& data) -> void {\n        response.append(data.toString());\n        connection.dispatcher().exit();\n      },\n      version_);\n\n  connection.run();\n  EXPECT_THAT(response, HasSubstr(\"SETTINGS expected\"));\n  // Due to the multiple dispatchers involved (one for the RawConnectionDriver and another for the\n  // Envoy server), it's possible the delayed close timer could fire and close the server socket\n  // prior to the data callback above firing. Therefore, we may either still be connected, or have\n  // received a remote close.\n  if (connection.last_connection_event() == Network::ConnectionEvent::Connected) {\n    connection.run();\n  }\n  EXPECT_EQ(connection.last_connection_event(), Network::ConnectionEvent::RemoteClose);\n  EXPECT_EQ(test_server_->counter(\"http.config_test.downstream_cx_delayed_close_timeout\")->value(),\n            1);\n}\n\n// Test disablement of delayed close processing on downstream connections.\nTEST_P(Http2IntegrationTest, DelayedCloseDisabled) {\n  config_helper_.addConfigModifier(\n      [](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager& hcm) {\n        hcm.mutable_delayed_close_timeout()->set_seconds(0);\n      });\n  initialize();\n  Buffer::OwnedImpl buffer(\"PRI * HTTP/2.0\\r\\n\\r\\nSM\\r\\n\\r\\nhelloworldcauseanerror\");\n  std::string response;\n  RawConnectionDriver connection(\n      lookupPort(\"http\"), buffer,\n      [&](Network::ClientConnection& connection, const Buffer::Instance& data) -> void {\n        response.append(data.toString());\n        connection.dispatcher().exit();\n      },\n      version_);\n\n  connection.run();\n  EXPECT_THAT(response, HasSubstr(\"SETTINGS expected\"));\n  // Due to the multiple dispatchers involved (one for the RawConnectionDriver and another for the\n  // Envoy server), it's possible for the 'connection' to receive the data and exit the dispatcher\n  // prior to the FIN being received from the server.\n  if (connection.last_connection_event() == Network::ConnectionEvent::Connected) {\n    connection.run();\n  }\n  EXPECT_EQ(connection.last_connection_event(), Network::ConnectionEvent::RemoteClose);\n  EXPECT_EQ(test_server_->counter(\"http.config_test.downstream_cx_delayed_close_timeout\")->value(),\n            0);\n}\n\nTEST_P(Http2IntegrationTest, PauseAndResume) {\n  config_helper_.addFilter(R\"EOF(\n  name: stop-iteration-and-continue-filter\n  config: {}\n  )EOF\");\n  initialize();\n\n  // Send a request with a bit of data, to trigger the filter pausing.\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  auto encoder_decoder = codec_client_->startRequest(default_request_headers_);\n  request_encoder_ = &encoder_decoder.first;\n  codec_client_->sendData(*request_encoder_, 1, false);\n\n  auto response = std::move(encoder_decoder.second);\n  ASSERT_TRUE(fake_upstreams_[0]->waitForHttpConnection(*dispatcher_, fake_upstream_connection_));\n  ASSERT_TRUE(fake_upstream_connection_->waitForNewStream(*dispatcher_, upstream_request_));\n  ASSERT_TRUE(upstream_request_->waitForHeadersComplete());\n\n  // Now send the final data frame and make sure it gets proxied.\n  codec_client_->sendData(*request_encoder_, 0, true);\n  ASSERT_TRUE(upstream_request_->waitForEndStream(*dispatcher_));\n  upstream_request_->encodeHeaders(default_response_headers_, false);\n\n  response->waitForHeaders();\n  upstream_request_->encodeData(0, true);\n  response->waitForEndStream();\n  ASSERT_TRUE(response->complete());\n}\n\nTEST_P(Http2IntegrationTest, PauseAndResumeHeadersOnly) {\n  config_helper_.addFilter(R\"EOF(\n  name: stop-iteration-and-continue-filter\n  config: {}\n  )EOF\");\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  auto response = codec_client_->makeHeaderOnlyRequest(default_request_headers_);\n\n  ASSERT_TRUE(fake_upstreams_[0]->waitForHttpConnection(*dispatcher_, fake_upstream_connection_));\n  ASSERT_TRUE(fake_upstream_connection_->waitForNewStream(*dispatcher_, upstream_request_));\n  ASSERT_TRUE(upstream_request_->waitForEndStream(*dispatcher_));\n\n  upstream_request_->encodeHeaders(default_response_headers_, true);\n  response->waitForEndStream();\n  ASSERT_TRUE(response->complete());\n}\n\nHttp2RingHashIntegrationTest::Http2RingHashIntegrationTest() {\n  config_helper_.addConfigModifier([&](envoy::config::bootstrap::v2::Bootstrap& bootstrap) -> void {\n    auto* cluster = bootstrap.mutable_static_resources()->mutable_clusters(0);\n    cluster->clear_hosts();\n    cluster->set_lb_policy(envoy::api::v2::Cluster_LbPolicy_RING_HASH);\n    for (int i = 0; i < num_upstreams_; i++) {\n      auto* socket = cluster->add_hosts()->mutable_socket_address();\n      socket->set_address(Network::Test::getLoopbackAddressString(version_));\n    }\n  });\n}\n\nHttp2RingHashIntegrationTest::~Http2RingHashIntegrationTest() {\n  if (codec_client_) {\n    codec_client_->close();\n    codec_client_ = nullptr;\n  }\n  for (auto& fake_upstream_connection : fake_upstream_connections_) {\n    AssertionResult result = fake_upstream_connection->close();\n    RELEASE_ASSERT(result, result.message());\n    result = fake_upstream_connection->waitForDisconnect();\n    RELEASE_ASSERT(result, result.message());\n  }\n}\n\nvoid Http2RingHashIntegrationTest::createUpstreams() {\n  for (int i = 0; i < num_upstreams_; i++) {\n    fake_upstreams_.emplace_back(\n        new FakeUpstream(0, FakeHttpConnection::Type::HTTP1, version_, timeSystem()));\n  }\n}\n\nINSTANTIATE_TEST_SUITE_P(IpVersions, Http2RingHashIntegrationTest,\n                         testing::ValuesIn(TestEnvironment::getIpVersionsForTest()),\n                         TestUtility::ipTestParamsToString);\n\nINSTANTIATE_TEST_SUITE_P(IpVersions, Http2MetadataIntegrationTest,\n                         testing::ValuesIn(TestEnvironment::getIpVersionsForTest()),\n                         TestUtility::ipTestParamsToString);\n\nvoid Http2RingHashIntegrationTest::sendMultipleRequests(\n    int request_bytes, Http::TestHeaderMapImpl headers,\n    std::function<void(IntegrationStreamDecoder&)> cb) {\n  TestRandomGenerator rand;\n  const uint32_t num_requests = 50;\n  std::vector<Http::StreamEncoder*> encoders;\n  std::vector<IntegrationStreamDecoderPtr> responses;\n  std::vector<FakeStreamPtr> upstream_requests;\n\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  for (uint32_t i = 0; i < num_requests; ++i) {\n    auto encoder_decoder = codec_client_->startRequest(headers);\n    encoders.push_back(&encoder_decoder.first);\n    responses.push_back(std::move(encoder_decoder.second));\n    codec_client_->sendData(*encoders[i], request_bytes, true);\n  }\n\n  for (uint32_t i = 0; i < num_requests; ++i) {\n    FakeHttpConnectionPtr fake_upstream_connection;\n    ASSERT_TRUE(FakeUpstream::waitForHttpConnection(*dispatcher_, fake_upstreams_,\n                                                    fake_upstream_connection));\n    // As data and streams are interwoven, make sure waitForNewStream()\n    // ignores incoming data and waits for actual stream establishment.\n    upstream_requests.emplace_back();\n    ASSERT_TRUE(\n        fake_upstream_connection->waitForNewStream(*dispatcher_, upstream_requests.back(), true));\n    upstream_requests.back()->setAddServedByHeader(true);\n    fake_upstream_connections_.push_back(std::move(fake_upstream_connection));\n  }\n\n  for (uint32_t i = 0; i < num_requests; ++i) {\n    ASSERT_TRUE(upstream_requests[i]->waitForEndStream(*dispatcher_));\n    upstream_requests[i]->encodeHeaders(Http::TestHeaderMapImpl{{\":status\", \"200\"}}, false);\n    upstream_requests[i]->encodeData(rand.random() % (1024 * 2), true);\n  }\n\n  for (uint32_t i = 0; i < num_requests; ++i) {\n    responses[i]->waitForEndStream();\n    EXPECT_TRUE(upstream_requests[i]->complete());\n    EXPECT_EQ(request_bytes, upstream_requests[i]->bodyLength());\n\n    EXPECT_TRUE(responses[i]->complete());\n    cb(*responses[i]);\n  }\n}\n\nTEST_P(Http2RingHashIntegrationTest, CookieRoutingNoCookieNoTtl) {\n  config_helper_.addConfigModifier(\n      [&](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager& hcm)\n          -> void {\n        auto* hash_policy = hcm.mutable_route_config()\n                                ->mutable_virtual_hosts(0)\n                                ->mutable_routes(0)\n                                ->mutable_route()\n                                ->add_hash_policy();\n        auto* cookie = hash_policy->mutable_cookie();\n        cookie->set_name(\"foo\");\n      });\n\n  // This test is non-deterministic, so make it extremely unlikely that not all\n  // upstreams get hit.\n  num_upstreams_ = 2;\n  std::set<std::string> served_by;\n  sendMultipleRequests(\n      1024,\n      Http::TestHeaderMapImpl{{\":method\", \"POST\"},\n                              {\":path\", \"/test/long/url\"},\n                              {\":scheme\", \"http\"},\n                              {\":authority\", \"host\"}},\n      [&](IntegrationStreamDecoder& response) {\n        EXPECT_EQ(\"200\", response.headers().Status()->value().getStringView());\n        EXPECT_TRUE(response.headers().get(Http::Headers::get().SetCookie) == nullptr);\n        served_by.insert(std::string(\n            response.headers().get(Http::LowerCaseString(\"x-served-by\"))->value().getStringView()));\n      });\n  EXPECT_EQ(served_by.size(), num_upstreams_);\n}\n\nTEST_P(Http2RingHashIntegrationTest, CookieRoutingNoCookieWithNonzeroTtlSet) {\n  config_helper_.addConfigModifier(\n      [&](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager& hcm)\n          -> void {\n        auto* hash_policy = hcm.mutable_route_config()\n                                ->mutable_virtual_hosts(0)\n                                ->mutable_routes(0)\n                                ->mutable_route()\n                                ->add_hash_policy();\n        auto* cookie = hash_policy->mutable_cookie();\n        cookie->set_name(\"foo\");\n        cookie->mutable_ttl()->set_seconds(15);\n      });\n\n  std::set<std::string> set_cookies;\n  sendMultipleRequests(\n      1024,\n      Http::TestHeaderMapImpl{{\":method\", \"POST\"},\n                              {\":path\", \"/test/long/url\"},\n                              {\":scheme\", \"http\"},\n                              {\":authority\", \"host\"}},\n      [&](IntegrationStreamDecoder& response) {\n        EXPECT_EQ(\"200\", response.headers().Status()->value().getStringView());\n        std::string value(\n            response.headers().get(Http::Headers::get().SetCookie)->value().getStringView());\n        set_cookies.insert(value);\n        EXPECT_THAT(value, MatchesRegex(\"foo=.*; Max-Age=15; HttpOnly\"));\n      });\n  EXPECT_EQ(set_cookies.size(), 1);\n}\n\nTEST_P(Http2RingHashIntegrationTest, CookieRoutingNoCookieWithZeroTtlSet) {\n  config_helper_.addConfigModifier(\n      [&](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager& hcm)\n          -> void {\n        auto* hash_policy = hcm.mutable_route_config()\n                                ->mutable_virtual_hosts(0)\n                                ->mutable_routes(0)\n                                ->mutable_route()\n                                ->add_hash_policy();\n        auto* cookie = hash_policy->mutable_cookie();\n        cookie->set_name(\"foo\");\n        cookie->mutable_ttl();\n      });\n\n  std::set<std::string> set_cookies;\n  sendMultipleRequests(\n      1024,\n      Http::TestHeaderMapImpl{{\":method\", \"POST\"},\n                              {\":path\", \"/test/long/url\"},\n                              {\":scheme\", \"http\"},\n                              {\":authority\", \"host\"}},\n      [&](IntegrationStreamDecoder& response) {\n        EXPECT_EQ(\"200\", response.headers().Status()->value().getStringView());\n        std::string value(\n            response.headers().get(Http::Headers::get().SetCookie)->value().getStringView());\n        set_cookies.insert(value);\n        EXPECT_THAT(value, MatchesRegex(\"^foo=.*$\"));\n      });\n  EXPECT_EQ(set_cookies.size(), 1);\n}\n\nTEST_P(Http2RingHashIntegrationTest, CookieRoutingWithCookieNoTtl) {\n  config_helper_.addConfigModifier(\n      [&](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager& hcm)\n          -> void {\n        auto* hash_policy = hcm.mutable_route_config()\n                                ->mutable_virtual_hosts(0)\n                                ->mutable_routes(0)\n                                ->mutable_route()\n                                ->add_hash_policy();\n        auto* cookie = hash_policy->mutable_cookie();\n        cookie->set_name(\"foo\");\n      });\n\n  std::set<std::string> served_by;\n  sendMultipleRequests(\n      1024,\n      Http::TestHeaderMapImpl{{\":method\", \"POST\"},\n                              {\"cookie\", \"foo=bar\"},\n                              {\":path\", \"/test/long/url\"},\n                              {\":scheme\", \"http\"},\n                              {\":authority\", \"host\"}},\n      [&](IntegrationStreamDecoder& response) {\n        EXPECT_EQ(\"200\", response.headers().Status()->value().getStringView());\n        EXPECT_TRUE(response.headers().get(Http::Headers::get().SetCookie) == nullptr);\n        served_by.insert(std::string(\n            response.headers().get(Http::LowerCaseString(\"x-served-by\"))->value().getStringView()));\n      });\n  EXPECT_EQ(served_by.size(), 1);\n}\n\nTEST_P(Http2RingHashIntegrationTest, CookieRoutingWithCookieWithTtlSet) {\n  config_helper_.addConfigModifier(\n      [&](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager& hcm)\n          -> void {\n        auto* hash_policy = hcm.mutable_route_config()\n                                ->mutable_virtual_hosts(0)\n                                ->mutable_routes(0)\n                                ->mutable_route()\n                                ->add_hash_policy();\n        auto* cookie = hash_policy->mutable_cookie();\n        cookie->set_name(\"foo\");\n        cookie->mutable_ttl()->set_seconds(15);\n      });\n\n  std::set<std::string> served_by;\n  sendMultipleRequests(\n      1024,\n      Http::TestHeaderMapImpl{{\":method\", \"POST\"},\n                              {\"cookie\", \"foo=bar\"},\n                              {\":path\", \"/test/long/url\"},\n                              {\":scheme\", \"http\"},\n                              {\":authority\", \"host\"}},\n      [&](IntegrationStreamDecoder& response) {\n        EXPECT_EQ(\"200\", response.headers().Status()->value().getStringView());\n        EXPECT_TRUE(response.headers().get(Http::Headers::get().SetCookie) == nullptr);\n        served_by.insert(std::string(\n            response.headers().get(Http::LowerCaseString(\"x-served-by\"))->value().getStringView()));\n      });\n  EXPECT_EQ(served_by.size(), 1);\n}\n\nnamespace {\nconst int64_t TransmitThreshold = 100 * 1024 * 1024;\n} // namespace\n\nvoid Http2FloodMitigationTest::setNetworkConnectionBufferSize() {\n  // nghttp2 library has its own internal mitigation for outbound control frames. The mitigation is\n  // triggered when there are more than 10000 PING or SETTINGS frames with ACK flag in the nghttp2\n  // internal outbound queue. It is possible to trigger this mitigation in nghttp2 before triggering\n  // Envoy's own flood mitigation. This can happen when a buffer larger enough to contain over 10K\n  // PING or SETTINGS frames is dispatched to the nghttp2 library. To prevent this from happening\n  // the network connection receive buffer needs to be smaller than 90Kb (which is 10K SETTINGS\n  // frames). Set it to the arbitrarily chosen value of 32K.\n  config_helper_.addConfigModifier([](envoy::config::bootstrap::v2::Bootstrap& bootstrap) -> void {\n    RELEASE_ASSERT(bootstrap.mutable_static_resources()->listeners_size() >= 1, \"\");\n    auto* listener = bootstrap.mutable_static_resources()->mutable_listeners(0);\n    listener->mutable_per_connection_buffer_limit_bytes()->set_value(32 * 1024);\n  });\n}\n\nvoid Http2FloodMitigationTest::beginSession() {\n  setDownstreamProtocol(Http::CodecClient::Type::HTTP2);\n  setUpstreamProtocol(FakeHttpConnection::Type::HTTP2);\n  // set lower outbound frame limits to make tests run faster\n  config_helper_.setOutboundFramesLimits(1000, 100);\n  initialize();\n  tcp_client_ = makeTcpConnection(lookupPort(\"http\"));\n  startHttp2Session();\n}\n\nHttp2Frame Http2FloodMitigationTest::readFrame() {\n  Http2Frame frame;\n  tcp_client_->waitForData(frame.HeaderSize);\n  frame.setHeader(tcp_client_->data());\n  tcp_client_->clearData(frame.HeaderSize);\n  auto len = frame.payloadSize();\n  if (len) {\n    tcp_client_->waitForData(len);\n    frame.setPayload(tcp_client_->data());\n    tcp_client_->clearData(len);\n  }\n  return frame;\n}\n\nvoid Http2FloodMitigationTest::sendFame(const Http2Frame& frame) {\n  ASSERT_TRUE(tcp_client_->connected());\n  tcp_client_->write(std::string(frame), false, false);\n}\n\nvoid Http2FloodMitigationTest::startHttp2Session() {\n  tcp_client_->write(Http2Frame::Preamble, false, false);\n\n  // Send empty initial SETTINGS frame.\n  auto settings = Http2Frame::makeEmptySettingsFrame();\n  tcp_client_->write(std::string(settings), false, false);\n\n  // Read initial SETTINGS frame from the server.\n  readFrame();\n\n  // Send an SETTINGS ACK.\n  settings = Http2Frame::makeEmptySettingsFrame(Http2Frame::SettingsFlags::ACK);\n  tcp_client_->write(std::string(settings), false, false);\n\n  // read pending SETTINGS and WINDOW_UPDATE frames\n  readFrame();\n  readFrame();\n}\n\n// Verify that the server detects the flood of the given frame.\nvoid Http2FloodMitigationTest::floodServer(const Http2Frame& frame, const std::string& flood_stat) {\n  // pack the as many frames as we can into 16k buffer\n  const int FrameCount = (16 * 1024) / frame.size();\n  std::vector<char> buf(FrameCount * frame.size());\n  for (auto pos = buf.begin(); pos != buf.end();) {\n    pos = std::copy(frame.begin(), frame.end(), pos);\n  }\n\n  tcp_client_->readDisable(true);\n  int64_t total_bytes_sent = 0;\n  // If the flood protection is not working this loop will keep going\n  // forever until it is killed by blaze timer or run out of memory.\n  // Add early stop if we have sent more than 100M of frames, as it this\n  // point it is obvious something is wrong.\n  while (total_bytes_sent < TransmitThreshold && tcp_client_->connected()) {\n    tcp_client_->write({buf.begin(), buf.end()}, false, false);\n    total_bytes_sent += buf.size();\n  }\n\n  EXPECT_LE(total_bytes_sent, TransmitThreshold) << \"Flood mitigation is broken.\";\n  EXPECT_EQ(1, test_server_->counter(flood_stat)->value());\n  EXPECT_EQ(1,\n            test_server_->counter(\"http.config_test.downstream_cx_delayed_close_timeout\")->value());\n}\n\n// Verify that the server detects the flood using specified request parameters.\nvoid Http2FloodMitigationTest::floodServer(absl::string_view host, absl::string_view path,\n                                           Http2Frame::ResponseStatus expected_http_status,\n                                           const std::string& flood_stat) {\n  uint32_t request_idx = 0;\n  auto request = Http2Frame::makeRequest(request_idx, host, path);\n  sendFame(request);\n  auto frame = readFrame();\n  EXPECT_EQ(Http2Frame::Type::HEADERS, frame.type());\n  EXPECT_EQ(expected_http_status, frame.responseStatus());\n  tcp_client_->readDisable(true);\n  uint64_t total_bytes_sent = 0;\n  while (total_bytes_sent < TransmitThreshold && tcp_client_->connected()) {\n    request = Http2Frame::makeRequest(++request_idx, host, path);\n    sendFame(request);\n    total_bytes_sent += request.size();\n  }\n  EXPECT_LE(total_bytes_sent, TransmitThreshold) << \"Flood mitigation is broken.\";\n  if (!flood_stat.empty()) {\n    EXPECT_EQ(1, test_server_->counter(flood_stat)->value());\n  }\n  EXPECT_EQ(1,\n            test_server_->counter(\"http.config_test.downstream_cx_delayed_close_timeout\")->value());\n}\n\nINSTANTIATE_TEST_SUITE_P(IpVersions, Http2FloodMitigationTest,\n                         testing::ValuesIn(TestEnvironment::getIpVersionsForTest()),\n                         TestUtility::ipTestParamsToString);\n\nTEST_P(Http2FloodMitigationTest, Ping) {\n  setNetworkConnectionBufferSize();\n  beginSession();\n  floodServer(Http2Frame::makePingFrame(), \"http2.outbound_control_flood\");\n}\n\nTEST_P(Http2FloodMitigationTest, Settings) {\n  setNetworkConnectionBufferSize();\n  beginSession();\n  floodServer(Http2Frame::makeEmptySettingsFrame(), \"http2.outbound_control_flood\");\n}\n\n// Verify that the server can detect flood of internally generated 404 responses.\nTEST_P(Http2FloodMitigationTest, 404) {\n  // Change the default route to be restrictive, and send a request to a non existent route.\n  config_helper_.setDefaultHostAndRoute(\"foo.com\", \"/found\");\n  beginSession();\n\n  // Send requests to a non existent path to generate 404s\n  floodServer(\"host\", \"/notfound\", Http2Frame::ResponseStatus::_404, \"http2.outbound_flood\");\n}\n\n// Verify that the server can detect flood of DATA frames\nTEST_P(Http2FloodMitigationTest, Data) {\n  // Set large buffer limits so the test is not affected by the flow control.\n  config_helper_.setBufferLimits(1024 * 1024 * 1024, 1024 * 1024 * 1024);\n  autonomous_upstream_ = true;\n  beginSession();\n  fake_upstreams_[0]->set_allow_unexpected_disconnects(true);\n\n  floodServer(\"host\", \"/test/long/url\", Http2Frame::ResponseStatus::_200, \"http2.outbound_flood\");\n}\n\n// Verify that the server can detect flood of RST_STREAM frames.\nTEST_P(Http2FloodMitigationTest, RST_STREAM) {\n  // Use invalid HTTP headers to trigger sending RST_STREAM frames.\n  config_helper_.addConfigModifier(\n      [](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager& hcm)\n          -> void {\n        hcm.mutable_http2_protocol_options()->set_stream_error_on_invalid_http_messaging(true);\n      });\n  beginSession();\n\n  int i = 0;\n  auto request = Http::Http2::Http2Frame::makeMalformedRequest(i);\n  sendFame(request);\n  auto response = readFrame();\n  // Make sure we've got RST_STREAM from the server\n  EXPECT_EQ(Http2Frame::Type::RST_STREAM, response.type());\n  uint64_t total_bytes_sent = 0;\n  while (total_bytes_sent < TransmitThreshold && tcp_client_->connected()) {\n    request = Http::Http2::Http2Frame::makeMalformedRequest(++i);\n    sendFame(request);\n    total_bytes_sent += request.size();\n  }\n  EXPECT_LE(total_bytes_sent, TransmitThreshold) << \"Flood mitigation is broken.\";\n  EXPECT_EQ(1, test_server_->counter(\"http2.outbound_control_flood\")->value());\n  EXPECT_EQ(1,\n            test_server_->counter(\"http.config_test.downstream_cx_delayed_close_timeout\")->value());\n}\n\n// Verify that the server stop reading downstream connection on protocol error.\nTEST_P(Http2FloodMitigationTest, TooManyStreams) {\n  config_helper_.addConfigModifier(\n      [](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager& hcm)\n          -> void {\n        hcm.mutable_http2_protocol_options()->mutable_max_concurrent_streams()->set_value(2);\n      });\n  autonomous_upstream_ = true;\n  beginSession();\n  fake_upstreams_[0]->set_allow_unexpected_disconnects(true);\n\n  // Exceed the number of streams allowed by the server. The server should stop reading from the\n  // client. Verify that the client was unable to stuff a lot of data into the server.\n  floodServer(\"host\", \"/test/long/url\", Http2Frame::ResponseStatus::_200, \"\");\n}\n\nTEST_P(Http2FloodMitigationTest, EmptyHeaders) {\n  config_helper_.addConfigModifier(\n      [&](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager& hcm)\n          -> void {\n        hcm.mutable_http2_protocol_options()\n            ->mutable_max_consecutive_inbound_frames_with_empty_payload()\n            ->set_value(0);\n      });\n  beginSession();\n\n  uint32_t request_idx = 0;\n  auto request = Http2Frame::makeEmptyHeadersFrame(request_idx);\n  sendFame(request);\n\n  tcp_client_->waitForDisconnect();\n\n  EXPECT_EQ(1, test_server_->counter(\"http2.inbound_empty_frames_flood\")->value());\n  EXPECT_EQ(1,\n            test_server_->counter(\"http.config_test.downstream_cx_delayed_close_timeout\")->value());\n}\n\nTEST_P(Http2FloodMitigationTest, EmptyHeadersContinuation) {\n  beginSession();\n\n  uint32_t request_idx = 0;\n  auto request = Http2Frame::makeEmptyHeadersFrame(request_idx);\n  sendFame(request);\n\n  for (int i = 0; i < 2; i++) {\n    request = Http2Frame::makeEmptyContinuationFrame(request_idx);\n    sendFame(request);\n  }\n\n  tcp_client_->waitForDisconnect();\n\n  EXPECT_EQ(1, test_server_->counter(\"http2.inbound_empty_frames_flood\")->value());\n  EXPECT_EQ(1,\n            test_server_->counter(\"http.config_test.downstream_cx_delayed_close_timeout\")->value());\n}\n\nTEST_P(Http2FloodMitigationTest, EmptyData) {\n  beginSession();\n  fake_upstreams_[0]->set_allow_unexpected_disconnects(true);\n\n  uint32_t request_idx = 0;\n  auto request = Http2Frame::makePostRequest(request_idx, \"host\", \"/\");\n  sendFame(request);\n\n  for (int i = 0; i < 2; i++) {\n    request = Http2Frame::makeEmptyDataFrame(request_idx);\n    sendFame(request);\n  }\n\n  tcp_client_->waitForDisconnect();\n\n  EXPECT_EQ(1, test_server_->counter(\"http2.inbound_empty_frames_flood\")->value());\n  EXPECT_EQ(1,\n            test_server_->counter(\"http.config_test.downstream_cx_delayed_close_timeout\")->value());\n}\n\nTEST_P(Http2FloodMitigationTest, PriorityIdleStream) {\n  beginSession();\n\n  floodServer(Http2Frame::makePriorityFrame(0, 1), \"http2.inbound_priority_frames_flood\");\n}\n\nTEST_P(Http2FloodMitigationTest, PriorityOpenStream) {\n  beginSession();\n  fake_upstreams_[0]->set_allow_unexpected_disconnects(true);\n\n  // Open stream.\n  uint32_t request_idx = 0;\n  auto request = Http2Frame::makeRequest(request_idx, \"host\", \"/\");\n  sendFame(request);\n\n  floodServer(Http2Frame::makePriorityFrame(request_idx, request_idx + 1),\n              \"http2.inbound_priority_frames_flood\");\n}\n\nTEST_P(Http2FloodMitigationTest, PriorityClosedStream) {\n  autonomous_upstream_ = true;\n  beginSession();\n  fake_upstreams_[0]->set_allow_unexpected_disconnects(true);\n\n  // Open stream.\n  uint32_t request_idx = 0;\n  auto request = Http2Frame::makeRequest(request_idx, \"host\", \"/\");\n  sendFame(request);\n  // Reading response marks this stream as closed in nghttp2.\n  auto frame = readFrame();\n  EXPECT_EQ(Http2Frame::Type::HEADERS, frame.type());\n\n  floodServer(Http2Frame::makePriorityFrame(request_idx, request_idx + 1),\n              \"http2.inbound_priority_frames_flood\");\n}\n\nTEST_P(Http2FloodMitigationTest, WindowUpdate) {\n  beginSession();\n  fake_upstreams_[0]->set_allow_unexpected_disconnects(true);\n\n  // Open stream.\n  uint32_t request_idx = 0;\n  auto request = Http2Frame::makeRequest(request_idx, \"host\", \"/\");\n  sendFame(request);\n\n  floodServer(Http2Frame::makeWindowUpdateFrame(request_idx, 1),\n              \"http2.inbound_window_update_frames_flood\");\n}\n\n// Verify that the HTTP/2 connection is terminated upon receiving invalid HEADERS frame.\nTEST_P(Http2FloodMitigationTest, ZerolenHeader) {\n  beginSession();\n\n  // Send invalid request.\n  uint32_t request_idx = 0;\n  auto request = Http2Frame::makeMalformedRequestWithZerolenHeader(request_idx, \"host\", \"/\");\n  sendFame(request);\n\n  tcp_client_->waitForDisconnect();\n\n  EXPECT_EQ(1, test_server_->counter(\"http2.rx_messaging_error\")->value());\n  EXPECT_EQ(1,\n            test_server_->counter(\"http.config_test.downstream_cx_delayed_close_timeout\")->value());\n}\n\n// Verify that only the offending stream is terminated upon receiving invalid HEADERS frame.\nTEST_P(Http2FloodMitigationTest, ZerolenHeaderAllowed) {\n  config_helper_.addConfigModifier(\n      [](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager& hcm)\n          -> void {\n        hcm.mutable_http2_protocol_options()->set_stream_error_on_invalid_http_messaging(true);\n      });\n  autonomous_upstream_ = true;\n  beginSession();\n  fake_upstreams_[0]->set_allow_unexpected_disconnects(true);\n\n  // Send invalid request.\n  uint32_t request_idx = 0;\n  auto request = Http2Frame::makeMalformedRequestWithZerolenHeader(request_idx, \"host\", \"/\");\n  sendFame(request);\n  // Make sure we've got RST_STREAM from the server.\n  auto response = readFrame();\n  EXPECT_EQ(Http2Frame::Type::RST_STREAM, response.type());\n\n  // Send valid request using the same connection.\n  request_idx++;\n  request = Http2Frame::makeRequest(request_idx, \"host\", \"/\");\n  sendFame(request);\n  response = readFrame();\n  EXPECT_EQ(Http2Frame::Type::HEADERS, response.type());\n  EXPECT_EQ(Http2Frame::ResponseStatus::_200, response.responseStatus());\n\n  tcp_client_->close();\n\n  EXPECT_EQ(1, test_server_->counter(\"http2.rx_messaging_error\")->value());\n  EXPECT_EQ(0,\n            test_server_->counter(\"http.config_test.downstream_cx_delayed_close_timeout\")->value());\n}\n\n} // namespace Envoy\n", "#include \"test/integration/http_integration.h\"\n\n#include <functional>\n#include <list>\n#include <memory>\n#include <regex>\n#include <string>\n#include <vector>\n\n#include \"envoy/buffer/buffer.h\"\n#include \"envoy/event/dispatcher.h\"\n#include \"envoy/http/header_map.h\"\n#include \"envoy/network/address.h\"\n#include \"envoy/registry/registry.h\"\n\n#include \"common/api/api_impl.h\"\n#include \"common/buffer/buffer_impl.h\"\n#include \"common/common/fmt.h\"\n#include \"common/common/thread_annotations.h\"\n#include \"common/http/headers.h\"\n#include \"common/network/utility.h\"\n#include \"common/protobuf/utility.h\"\n#include \"common/runtime/runtime_impl.h\"\n#include \"common/upstream/upstream_impl.h\"\n\n#include \"test/common/upstream/utility.h\"\n#include \"test/integration/autonomous_upstream.h\"\n#include \"test/integration/test_host_predicate_config.h\"\n#include \"test/integration/utility.h\"\n#include \"test/mocks/upstream/mocks.h\"\n#include \"test/test_common/environment.h\"\n#include \"test/test_common/network_utility.h\"\n#include \"test/test_common/registry.h\"\n\n#include \"gtest/gtest.h\"\n\nnamespace Envoy {\nnamespace {\n\nenvoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager::CodecType\ntypeToCodecType(Http::CodecClient::Type type) {\n  switch (type) {\n  case Http::CodecClient::Type::HTTP1:\n    return envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager::\n        HTTP1;\n  case Http::CodecClient::Type::HTTP2:\n    return envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager::\n        HTTP2;\n  default:\n    RELEASE_ASSERT(0, \"\");\n  }\n}\n\n} // namespace\n\nIntegrationCodecClient::IntegrationCodecClient(\n    Event::Dispatcher& dispatcher, Network::ClientConnectionPtr&& conn,\n    Upstream::HostDescriptionConstSharedPtr host_description, CodecClient::Type type)\n    : CodecClientProd(type, std::move(conn), host_description, dispatcher), dispatcher_(dispatcher),\n      callbacks_(*this), codec_callbacks_(*this) {\n  connection_->addConnectionCallbacks(callbacks_);\n  setCodecConnectionCallbacks(codec_callbacks_);\n  dispatcher.run(Event::Dispatcher::RunType::Block);\n}\n\nvoid IntegrationCodecClient::flushWrite() {\n  connection_->dispatcher().run(Event::Dispatcher::RunType::NonBlock);\n  // NOTE: We should run blocking until all the body data is flushed.\n}\n\nIntegrationStreamDecoderPtr\nIntegrationCodecClient::makeHeaderOnlyRequest(const Http::HeaderMap& headers) {\n  auto response = std::make_unique<IntegrationStreamDecoder>(dispatcher_);\n  Http::StreamEncoder& encoder = newStream(*response);\n  encoder.getStream().addCallbacks(*response);\n  encoder.encodeHeaders(headers, true);\n  flushWrite();\n  return response;\n}\n\nIntegrationStreamDecoderPtr\nIntegrationCodecClient::makeRequestWithBody(const Http::HeaderMap& headers, uint64_t body_size) {\n  return makeRequestWithBody(headers, std::string(body_size, 'a'));\n}\n\nIntegrationStreamDecoderPtr\nIntegrationCodecClient::makeRequestWithBody(const Http::HeaderMap& headers,\n                                            const std::string& body) {\n  auto response = std::make_unique<IntegrationStreamDecoder>(dispatcher_);\n  Http::StreamEncoder& encoder = newStream(*response);\n  encoder.getStream().addCallbacks(*response);\n  encoder.encodeHeaders(headers, false);\n  Buffer::OwnedImpl data(body);\n  encoder.encodeData(data, true);\n  flushWrite();\n  return response;\n}\n\nvoid IntegrationCodecClient::sendData(Http::StreamEncoder& encoder, absl::string_view data,\n                                      bool end_stream) {\n  Buffer::OwnedImpl buffer_data(data.data(), data.size());\n  encoder.encodeData(buffer_data, end_stream);\n  flushWrite();\n}\n\nvoid IntegrationCodecClient::sendData(Http::StreamEncoder& encoder, Buffer::Instance& data,\n                                      bool end_stream) {\n  encoder.encodeData(data, end_stream);\n  flushWrite();\n}\n\nvoid IntegrationCodecClient::sendData(Http::StreamEncoder& encoder, uint64_t size,\n                                      bool end_stream) {\n  Buffer::OwnedImpl data(std::string(size, 'a'));\n  sendData(encoder, data, end_stream);\n}\n\nvoid IntegrationCodecClient::sendTrailers(Http::StreamEncoder& encoder,\n                                          const Http::HeaderMap& trailers) {\n  encoder.encodeTrailers(trailers);\n  flushWrite();\n}\n\nvoid IntegrationCodecClient::sendReset(Http::StreamEncoder& encoder) {\n  encoder.getStream().resetStream(Http::StreamResetReason::LocalReset);\n  flushWrite();\n}\n\nvoid IntegrationCodecClient::sendMetadata(Http::StreamEncoder& encoder,\n                                          Http::MetadataMap metadata_map) {\n  Http::MetadataMapPtr metadata_map_ptr = std::make_unique<Http::MetadataMap>(metadata_map);\n  Http::MetadataMapVector metadata_map_vector;\n  metadata_map_vector.push_back(std::move(metadata_map_ptr));\n  encoder.encodeMetadata(metadata_map_vector);\n  flushWrite();\n}\n\nstd::pair<Http::StreamEncoder&, IntegrationStreamDecoderPtr>\nIntegrationCodecClient::startRequest(const Http::HeaderMap& headers) {\n  auto response = std::make_unique<IntegrationStreamDecoder>(dispatcher_);\n  Http::StreamEncoder& encoder = newStream(*response);\n  encoder.getStream().addCallbacks(*response);\n  encoder.encodeHeaders(headers, false);\n  flushWrite();\n  return {encoder, std::move(response)};\n}\n\nbool IntegrationCodecClient::waitForDisconnect(std::chrono::milliseconds time_to_wait) {\n  Event::TimerPtr wait_timer;\n  bool wait_timer_triggered = false;\n  if (time_to_wait.count()) {\n    wait_timer = connection_->dispatcher().createTimer([this, &wait_timer_triggered] {\n      connection_->dispatcher().exit();\n      wait_timer_triggered = true;\n    });\n    wait_timer->enableTimer(time_to_wait);\n  }\n\n  connection_->dispatcher().run(Event::Dispatcher::RunType::Block);\n\n  // Disable the timer if it was created. This call is harmless if the timer already triggered.\n  if (wait_timer) {\n    wait_timer->disableTimer();\n  }\n\n  if (wait_timer_triggered && !disconnected_) {\n    return false;\n  }\n  EXPECT_TRUE(disconnected_);\n\n  return true;\n}\n\nvoid IntegrationCodecClient::ConnectionCallbacks::onEvent(Network::ConnectionEvent event) {\n  parent_.last_connection_event_ = event;\n  if (event == Network::ConnectionEvent::Connected) {\n    parent_.connected_ = true;\n    parent_.connection_->dispatcher().exit();\n  } else if (event == Network::ConnectionEvent::RemoteClose) {\n    parent_.disconnected_ = true;\n    parent_.connection_->dispatcher().exit();\n  } else {\n    parent_.disconnected_ = true;\n  }\n}\n\nIntegrationCodecClientPtr HttpIntegrationTest::makeHttpConnection(uint32_t port) {\n  return makeHttpConnection(makeClientConnection(port));\n}\n\nIntegrationCodecClientPtr\nHttpIntegrationTest::makeRawHttpConnection(Network::ClientConnectionPtr&& conn) {\n  std::shared_ptr<Upstream::MockClusterInfo> cluster{new NiceMock<Upstream::MockClusterInfo>()};\n  cluster->http2_settings_.allow_connect_ = true;\n  cluster->http2_settings_.allow_metadata_ = true;\n  Upstream::HostDescriptionConstSharedPtr host_description{Upstream::makeTestHostDescription(\n      cluster, fmt::format(\"tcp://{}:80\", Network::Test::getLoopbackAddressUrlString(version_)))};\n  return std::make_unique<IntegrationCodecClient>(*dispatcher_, std::move(conn), host_description,\n                                                  downstream_protocol_);\n}\n\nIntegrationCodecClientPtr\nHttpIntegrationTest::makeHttpConnection(Network::ClientConnectionPtr&& conn) {\n  auto codec = makeRawHttpConnection(std::move(conn));\n  EXPECT_TRUE(codec->connected());\n  return codec;\n}\n\nHttpIntegrationTest::HttpIntegrationTest(Http::CodecClient::Type downstream_protocol,\n                                         Network::Address::IpVersion version,\n                                         const std::string& config)\n    : HttpIntegrationTest::HttpIntegrationTest(\n          downstream_protocol,\n          [version](int) {\n            return Network::Utility::parseInternetAddress(\n                Network::Test::getAnyAddressString(version), 0);\n          },\n          version, config) {}\n\nHttpIntegrationTest::HttpIntegrationTest(Http::CodecClient::Type downstream_protocol,\n                                         const InstanceConstSharedPtrFn& upstream_address_fn,\n                                         Network::Address::IpVersion version,\n                                         const std::string& config)\n    : BaseIntegrationTest(upstream_address_fn, version, config),\n      downstream_protocol_(downstream_protocol) {\n  // Legacy integration tests expect the default listener to be named \"http\" for\n  // lookupPort calls.\n  config_helper_.renameListener(\"http\");\n  config_helper_.setClientCodec(typeToCodecType(downstream_protocol_));\n}\n\nvoid HttpIntegrationTest::useAccessLog() {\n  access_log_name_ = TestEnvironment::temporaryPath(TestUtility::uniqueFilename());\n  ASSERT_TRUE(config_helper_.setAccessLog(access_log_name_));\n}\n\nHttpIntegrationTest::~HttpIntegrationTest() {\n  cleanupUpstreamAndDownstream();\n  test_server_.reset();\n  fake_upstreams_.clear();\n}\n\nstd::string HttpIntegrationTest::waitForAccessLog(const std::string& filename) {\n  // Wait a max of 1s for logs to flush to disk.\n  for (int i = 0; i < 1000; ++i) {\n    std::string contents = TestEnvironment::readFileToStringForTest(filename, false);\n    if (contents.length() > 0) {\n      return contents;\n    }\n    usleep(1000);\n  }\n  RELEASE_ASSERT(0, \"Timed out waiting for access log\");\n  return \"\";\n}\n\nvoid HttpIntegrationTest::setDownstreamProtocol(Http::CodecClient::Type downstream_protocol) {\n  downstream_protocol_ = downstream_protocol;\n  config_helper_.setClientCodec(typeToCodecType(downstream_protocol_));\n}\n\nIntegrationStreamDecoderPtr HttpIntegrationTest::sendRequestAndWaitForResponse(\n    const Http::TestHeaderMapImpl& request_headers, uint32_t request_body_size,\n    const Http::TestHeaderMapImpl& response_headers, uint32_t response_size, int upstream_index) {\n  ASSERT(codec_client_ != nullptr);\n  // Send the request to Envoy.\n  IntegrationStreamDecoderPtr response;\n  if (request_body_size) {\n    response = codec_client_->makeRequestWithBody(request_headers, request_body_size);\n  } else {\n    response = codec_client_->makeHeaderOnlyRequest(request_headers);\n  }\n  waitForNextUpstreamRequest(upstream_index);\n  // Send response headers, and end_stream if there is no response body.\n  upstream_request_->encodeHeaders(response_headers, response_size == 0);\n  // Send any response data, with end_stream true.\n  if (response_size) {\n    upstream_request_->encodeData(response_size, true);\n  }\n  // Wait for the response to be read by the codec client.\n  response->waitForEndStream();\n  return response;\n}\n\nvoid HttpIntegrationTest::cleanupUpstreamAndDownstream() {\n  // Close the upstream connection first. If there's an outstanding request,\n  // closing the client may result in a FIN being sent upstream, and FakeConnectionBase::close\n  // will interpret that as an unexpected disconnect. The codec client is not\n  // subject to the same failure mode.\n  if (fake_upstream_connection_) {\n    AssertionResult result = fake_upstream_connection_->close();\n    RELEASE_ASSERT(result, result.message());\n    result = fake_upstream_connection_->waitForDisconnect();\n    RELEASE_ASSERT(result, result.message());\n    fake_upstream_connection_.reset();\n  }\n  if (codec_client_) {\n    codec_client_->close();\n  }\n}\n\nvoid HttpIntegrationTest::sendRequestAndVerifyResponse(\n    const Http::TestHeaderMapImpl& request_headers, const int request_size,\n    const Http::TestHeaderMapImpl& response_headers, const int response_size,\n    const int backend_idx) {\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  auto response = sendRequestAndWaitForResponse(request_headers, request_size, response_headers,\n                                                response_size, backend_idx);\n  verifyResponse(std::move(response), \"200\", response_headers, std::string(response_size, 'a'));\n\n  EXPECT_TRUE(upstream_request_->complete());\n  EXPECT_EQ(request_size, upstream_request_->bodyLength());\n  cleanupUpstreamAndDownstream();\n}\n\nvoid HttpIntegrationTest::verifyResponse(IntegrationStreamDecoderPtr response,\n                                         const std::string& response_code,\n                                         const Http::TestHeaderMapImpl& expected_headers,\n                                         const std::string& expected_body) {\n  EXPECT_TRUE(response->complete());\n  EXPECT_EQ(response_code, response->headers().Status()->value().getStringView());\n  expected_headers.iterate(\n      [](const Http::HeaderEntry& header, void* context) -> Http::HeaderMap::Iterate {\n        auto response_headers = static_cast<Http::HeaderMap*>(context);\n        const Http::HeaderEntry* entry =\n            response_headers->get(Http::LowerCaseString{std::string(header.key().getStringView())});\n        EXPECT_NE(entry, nullptr);\n        EXPECT_EQ(header.value().getStringView(), entry->value().getStringView());\n        return Http::HeaderMap::Iterate::Continue;\n      },\n      const_cast<void*>(static_cast<const void*>(&response->headers())));\n\n  EXPECT_EQ(response->body(), expected_body);\n}\n\nuint64_t\nHttpIntegrationTest::waitForNextUpstreamRequest(const std::vector<uint64_t>& upstream_indices) {\n  uint64_t upstream_with_request;\n  // If there is no upstream connection, wait for it to be established.\n  if (!fake_upstream_connection_) {\n\n    AssertionResult result = AssertionFailure();\n    for (auto upstream_index : upstream_indices) {\n      result = fake_upstreams_[upstream_index]->waitForHttpConnection(\n          *dispatcher_, fake_upstream_connection_, TestUtility::DefaultTimeout,\n          max_request_headers_kb_);\n      if (result) {\n        upstream_with_request = upstream_index;\n        break;\n      }\n    }\n    RELEASE_ASSERT(result, result.message());\n  }\n  // Wait for the next stream on the upstream connection.\n  AssertionResult result =\n      fake_upstream_connection_->waitForNewStream(*dispatcher_, upstream_request_);\n  RELEASE_ASSERT(result, result.message());\n  // Wait for the stream to be completely received.\n  result = upstream_request_->waitForEndStream(*dispatcher_);\n  RELEASE_ASSERT(result, result.message());\n\n  return upstream_with_request;\n}\n\nvoid HttpIntegrationTest::waitForNextUpstreamRequest(uint64_t upstream_index) {\n  waitForNextUpstreamRequest(std::vector<uint64_t>({upstream_index}));\n}\n\nvoid HttpIntegrationTest::checkSimpleRequestSuccess(uint64_t expected_request_size,\n                                                    uint64_t expected_response_size,\n                                                    IntegrationStreamDecoder* response) {\n  EXPECT_TRUE(upstream_request_->complete());\n  EXPECT_EQ(expected_request_size, upstream_request_->bodyLength());\n\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().Status()->value().getStringView());\n  EXPECT_EQ(expected_response_size, response->body().size());\n}\n\nvoid HttpIntegrationTest::testRouterRequestAndResponseWithBody(\n    uint64_t request_size, uint64_t response_size, bool big_header,\n    ConnectionCreationFunction* create_connection) {\n  initialize();\n  codec_client_ = makeHttpConnection(\n      create_connection ? ((*create_connection)()) : makeClientConnection((lookupPort(\"http\"))));\n  Http::TestHeaderMapImpl request_headers{\n      {\":method\", \"POST\"},    {\":path\", \"/test/long/url\"}, {\":scheme\", \"http\"},\n      {\":authority\", \"host\"}, {\"x-lyft-user-id\", \"123\"},   {\"x-forwarded-for\", \"10.0.0.1\"}};\n  if (big_header) {\n    request_headers.addCopy(\"big\", std::string(4096, 'a'));\n  }\n  auto response = sendRequestAndWaitForResponse(request_headers, request_size,\n                                                default_response_headers_, response_size);\n  checkSimpleRequestSuccess(request_size, response_size, response.get());\n}\n\nIntegrationStreamDecoderPtr\nHttpIntegrationTest::makeHeaderOnlyRequest(ConnectionCreationFunction* create_connection,\n                                           int upstream_index, const std::string& path,\n                                           const std::string& authority) {\n  // This is called multiple times per test in ads_integration_test. Only call\n  // initialize() the first time.\n  if (!initialized()) {\n    initialize();\n  }\n  codec_client_ = makeHttpConnection(\n      create_connection ? ((*create_connection)()) : makeClientConnection((lookupPort(\"http\"))));\n  Http::TestHeaderMapImpl request_headers{{\":method\", \"GET\"},\n                                          {\":path\", path},\n                                          {\":scheme\", \"http\"},\n                                          {\":authority\", authority},\n                                          {\"x-lyft-user-id\", \"123\"}};\n  return sendRequestAndWaitForResponse(request_headers, 0, default_response_headers_, 0,\n                                       upstream_index);\n}\n\nvoid HttpIntegrationTest::testRouterHeaderOnlyRequestAndResponse(\n    ConnectionCreationFunction* create_connection, int upstream_index, const std::string& path,\n    const std::string& authority) {\n  auto response = makeHeaderOnlyRequest(create_connection, upstream_index, path, authority);\n  checkSimpleRequestSuccess(0U, 0U, response.get());\n}\n\n// Change the default route to be restrictive, and send a request to an alternate route.\nvoid HttpIntegrationTest::testRouterNotFound() {\n  config_helper_.setDefaultHostAndRoute(\"foo.com\", \"/found\");\n  initialize();\n\n  BufferingStreamDecoderPtr response = IntegrationUtil::makeSingleRequest(\n      lookupPort(\"http\"), \"GET\", \"/notfound\", \"\", downstream_protocol_, version_);\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"404\", response->headers().Status()->value().getStringView());\n}\n\n// Change the default route to be restrictive, and send a POST to an alternate route.\nvoid HttpIntegrationTest::testRouterNotFoundWithBody() {\n  config_helper_.setDefaultHostAndRoute(\"foo.com\", \"/found\");\n  initialize();\n\n  BufferingStreamDecoderPtr response = IntegrationUtil::makeSingleRequest(\n      lookupPort(\"http\"), \"POST\", \"/notfound\", \"foo\", downstream_protocol_, version_);\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"404\", response->headers().Status()->value().getStringView());\n}\n\nvoid HttpIntegrationTest::testRouterUpstreamDisconnectBeforeRequestComplete() {\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  auto encoder_decoder = codec_client_->startRequest(default_request_headers_);\n  auto response = std::move(encoder_decoder.second);\n\n  ASSERT_TRUE(fake_upstreams_[0]->waitForHttpConnection(*dispatcher_, fake_upstream_connection_));\n\n  ASSERT_TRUE(fake_upstream_connection_->waitForNewStream(*dispatcher_, upstream_request_));\n  ASSERT_TRUE(upstream_request_->waitForHeadersComplete());\n  ASSERT_TRUE(fake_upstream_connection_->close());\n  ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());\n  response->waitForEndStream();\n\n  if (downstream_protocol_ == Http::CodecClient::Type::HTTP1) {\n    codec_client_->waitForDisconnect();\n  } else {\n    codec_client_->close();\n  }\n\n  EXPECT_FALSE(upstream_request_->complete());\n  EXPECT_EQ(0U, upstream_request_->bodyLength());\n\n  EXPECT_TRUE(response->complete());\n  EXPECT_EQ(\"503\", response->headers().Status()->value().getStringView());\n  EXPECT_EQ(\"upstream connect error or disconnect/reset before headers. reset reason: connection \"\n            \"termination\",\n            response->body());\n}\n\nvoid HttpIntegrationTest::testRouterUpstreamDisconnectBeforeResponseComplete(\n    ConnectionCreationFunction* create_connection) {\n  initialize();\n  codec_client_ = makeHttpConnection(\n      create_connection ? ((*create_connection)()) : makeClientConnection((lookupPort(\"http\"))));\n  auto response = codec_client_->makeHeaderOnlyRequest(default_request_headers_);\n  waitForNextUpstreamRequest();\n  upstream_request_->encodeHeaders(default_response_headers_, false);\n  ASSERT_TRUE(fake_upstream_connection_->close());\n  ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());\n\n  if (downstream_protocol_ == Http::CodecClient::Type::HTTP1) {\n    codec_client_->waitForDisconnect();\n  } else {\n    response->waitForReset();\n    codec_client_->close();\n  }\n\n  EXPECT_TRUE(upstream_request_->complete());\n  EXPECT_EQ(0U, upstream_request_->bodyLength());\n\n  EXPECT_FALSE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().Status()->value().getStringView());\n  EXPECT_EQ(0U, response->body().size());\n}\n\nvoid HttpIntegrationTest::testRouterDownstreamDisconnectBeforeRequestComplete(\n    ConnectionCreationFunction* create_connection) {\n  initialize();\n\n  codec_client_ = makeHttpConnection(\n      create_connection ? ((*create_connection)()) : makeClientConnection((lookupPort(\"http\"))));\n  auto encoder_decoder = codec_client_->startRequest(default_request_headers_);\n  auto response = std::move(encoder_decoder.second);\n  ASSERT_TRUE(fake_upstreams_[0]->waitForHttpConnection(*dispatcher_, fake_upstream_connection_));\n  ASSERT_TRUE(fake_upstream_connection_->waitForNewStream(*dispatcher_, upstream_request_));\n  ASSERT_TRUE(upstream_request_->waitForHeadersComplete());\n  codec_client_->close();\n\n  if (upstreamProtocol() == FakeHttpConnection::Type::HTTP1) {\n    ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());\n  } else {\n    ASSERT_TRUE(upstream_request_->waitForReset());\n    ASSERT_TRUE(fake_upstream_connection_->close());\n    ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());\n  }\n\n  EXPECT_FALSE(upstream_request_->complete());\n  EXPECT_EQ(0U, upstream_request_->bodyLength());\n\n  EXPECT_FALSE(response->complete());\n}\n\nvoid HttpIntegrationTest::testRouterDownstreamDisconnectBeforeResponseComplete(\n    ConnectionCreationFunction* create_connection) {\n#ifdef __APPLE__\n  // Skip this test on macOS: we can't detect the early close on macOS, and we\n  // won't clean up the upstream connection until it times out. See #4294.\n  if (downstream_protocol_ == Http::CodecClient::Type::HTTP1) {\n    return;\n  }\n#endif\n  initialize();\n  codec_client_ = makeHttpConnection(\n      create_connection ? ((*create_connection)()) : makeClientConnection((lookupPort(\"http\"))));\n  auto response = codec_client_->makeHeaderOnlyRequest(default_request_headers_);\n  waitForNextUpstreamRequest();\n  upstream_request_->encodeHeaders(default_response_headers_, false);\n  upstream_request_->encodeData(512, false);\n  response->waitForBodyData(512);\n  codec_client_->close();\n\n  if (upstreamProtocol() == FakeHttpConnection::Type::HTTP1) {\n    ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());\n  } else {\n    ASSERT_TRUE(upstream_request_->waitForReset());\n    ASSERT_TRUE(fake_upstream_connection_->close());\n    ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());\n  }\n\n  EXPECT_TRUE(upstream_request_->complete());\n  EXPECT_EQ(0U, upstream_request_->bodyLength());\n\n  EXPECT_FALSE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().Status()->value().getStringView());\n  EXPECT_EQ(512U, response->body().size());\n}\n\nvoid HttpIntegrationTest::testRouterUpstreamResponseBeforeRequestComplete() {\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  auto encoder_decoder = codec_client_->startRequest(default_request_headers_);\n  auto response = std::move(encoder_decoder.second);\n  ASSERT_TRUE(fake_upstreams_[0]->waitForHttpConnection(*dispatcher_, fake_upstream_connection_));\n  ASSERT_TRUE(fake_upstream_connection_->waitForNewStream(*dispatcher_, upstream_request_));\n  ASSERT_TRUE(upstream_request_->waitForHeadersComplete());\n  upstream_request_->encodeHeaders(default_response_headers_, false);\n  upstream_request_->encodeData(512, true);\n  response->waitForEndStream();\n\n  if (upstreamProtocol() == FakeHttpConnection::Type::HTTP1) {\n    ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());\n  } else {\n    ASSERT_TRUE(upstream_request_->waitForReset());\n    ASSERT_TRUE(fake_upstream_connection_->close());\n    ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());\n  }\n\n  if (downstream_protocol_ == Http::CodecClient::Type::HTTP1) {\n    codec_client_->waitForDisconnect();\n  } else {\n    codec_client_->close();\n  }\n\n  EXPECT_FALSE(upstream_request_->complete());\n  EXPECT_EQ(0U, upstream_request_->bodyLength());\n\n  EXPECT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().Status()->value().getStringView());\n  EXPECT_EQ(512U, response->body().size());\n}\n\nvoid HttpIntegrationTest::testRetry() {\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  auto response =\n      codec_client_->makeRequestWithBody(Http::TestHeaderMapImpl{{\":method\", \"POST\"},\n                                                                 {\":path\", \"/test/long/url\"},\n                                                                 {\":scheme\", \"http\"},\n                                                                 {\":authority\", \"host\"},\n                                                                 {\"x-forwarded-for\", \"10.0.0.1\"},\n                                                                 {\"x-envoy-retry-on\", \"5xx\"}},\n                                         1024);\n  waitForNextUpstreamRequest();\n  upstream_request_->encodeHeaders(Http::TestHeaderMapImpl{{\":status\", \"503\"}}, false);\n\n  if (fake_upstreams_[0]->httpType() == FakeHttpConnection::Type::HTTP1) {\n    ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());\n    ASSERT_TRUE(fake_upstreams_[0]->waitForHttpConnection(*dispatcher_, fake_upstream_connection_));\n  } else {\n    ASSERT_TRUE(upstream_request_->waitForReset());\n  }\n  waitForNextUpstreamRequest();\n  upstream_request_->encodeHeaders(default_response_headers_, false);\n  upstream_request_->encodeData(512, true);\n\n  response->waitForEndStream();\n  EXPECT_TRUE(upstream_request_->complete());\n  EXPECT_EQ(1024U, upstream_request_->bodyLength());\n\n  EXPECT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().Status()->value().getStringView());\n  EXPECT_EQ(512U, response->body().size());\n}\n\n// Tests that the x-envoy-attempt-count header is properly set on the upstream request\n// and updated after the request is retried.\nvoid HttpIntegrationTest::testRetryAttemptCountHeader() {\n  auto host = config_helper_.createVirtualHost(\"host\", \"/test_retry\");\n  host.set_include_request_attempt_count(true);\n  config_helper_.addVirtualHost(host);\n\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  auto response =\n      codec_client_->makeRequestWithBody(Http::TestHeaderMapImpl{{\":method\", \"POST\"},\n                                                                 {\":path\", \"/test_retry\"},\n                                                                 {\":scheme\", \"http\"},\n                                                                 {\":authority\", \"host\"},\n                                                                 {\"x-forwarded-for\", \"10.0.0.1\"},\n                                                                 {\"x-envoy-retry-on\", \"5xx\"}},\n                                         1024);\n  waitForNextUpstreamRequest();\n  upstream_request_->encodeHeaders(Http::TestHeaderMapImpl{{\":status\", \"503\"}}, false);\n\n  EXPECT_EQ(\n      atoi(std::string(upstream_request_->headers().EnvoyAttemptCount()->value().getStringView())\n               .c_str()),\n      1);\n\n  if (fake_upstreams_[0]->httpType() == FakeHttpConnection::Type::HTTP1) {\n    ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());\n    ASSERT_TRUE(fake_upstreams_[0]->waitForHttpConnection(*dispatcher_, fake_upstream_connection_));\n  } else {\n    ASSERT_TRUE(upstream_request_->waitForReset());\n  }\n  waitForNextUpstreamRequest();\n  EXPECT_EQ(\n      atoi(std::string(upstream_request_->headers().EnvoyAttemptCount()->value().getStringView())\n               .c_str()),\n      2);\n  upstream_request_->encodeHeaders(default_response_headers_, false);\n  upstream_request_->encodeData(512, true);\n\n  response->waitForEndStream();\n  EXPECT_TRUE(upstream_request_->complete());\n  EXPECT_EQ(1024U, upstream_request_->bodyLength());\n\n  EXPECT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().Status()->value().getStringView());\n  EXPECT_EQ(512U, response->body().size());\n}\n\nvoid HttpIntegrationTest::testGrpcRetry() {\n  Http::TestHeaderMapImpl response_trailers{{\"response1\", \"trailer1\"}, {\"grpc-status\", \"0\"}};\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  auto encoder_decoder =\n      codec_client_->startRequest(Http::TestHeaderMapImpl{{\":method\", \"POST\"},\n                                                          {\":path\", \"/test/long/url\"},\n                                                          {\":scheme\", \"http\"},\n                                                          {\":authority\", \"host\"},\n                                                          {\"x-forwarded-for\", \"10.0.0.1\"},\n                                                          {\"x-envoy-retry-grpc-on\", \"cancelled\"}});\n  request_encoder_ = &encoder_decoder.first;\n  auto response = std::move(encoder_decoder.second);\n  codec_client_->sendData(*request_encoder_, 1024, true);\n  waitForNextUpstreamRequest();\n  upstream_request_->encodeHeaders(\n      Http::TestHeaderMapImpl{{\":status\", \"200\"}, {\"grpc-status\", \"1\"}}, false);\n  if (fake_upstreams_[0]->httpType() == FakeHttpConnection::Type::HTTP1) {\n    ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());\n    ASSERT_TRUE(fake_upstreams_[0]->waitForHttpConnection(*dispatcher_, fake_upstream_connection_));\n  } else {\n    ASSERT_TRUE(upstream_request_->waitForReset());\n  }\n  waitForNextUpstreamRequest();\n\n  upstream_request_->encodeHeaders(default_response_headers_, false);\n  upstream_request_->encodeData(512,\n                                fake_upstreams_[0]->httpType() != FakeHttpConnection::Type::HTTP2);\n  if (fake_upstreams_[0]->httpType() == FakeHttpConnection::Type::HTTP2) {\n    upstream_request_->encodeTrailers(response_trailers);\n  }\n\n  response->waitForEndStream();\n  EXPECT_TRUE(upstream_request_->complete());\n  EXPECT_EQ(1024U, upstream_request_->bodyLength());\n\n  EXPECT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().Status()->value().getStringView());\n  EXPECT_EQ(512U, response->body().size());\n  if (fake_upstreams_[0]->httpType() == FakeHttpConnection::Type::HTTP2) {\n    EXPECT_THAT(*response->trailers(), HeaderMapEqualRef(&response_trailers));\n  }\n}\n\nvoid HttpIntegrationTest::testEnvoyHandling100Continue(bool additional_continue_from_upstream,\n                                                       const std::string& via) {\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  auto encoder_decoder =\n      codec_client_->startRequest(Http::TestHeaderMapImpl{{\":method\", \"POST\"},\n                                                          {\":path\", \"/dynamo/url\"},\n                                                          {\":scheme\", \"http\"},\n                                                          {\":authority\", \"host\"},\n                                                          {\"expect\", \"100-continue\"}});\n  request_encoder_ = &encoder_decoder.first;\n  auto response = std::move(encoder_decoder.second);\n  ASSERT_TRUE(fake_upstreams_[0]->waitForHttpConnection(*dispatcher_, fake_upstream_connection_));\n  // The continue headers should arrive immediately.\n  response->waitForContinueHeaders();\n  ASSERT_TRUE(fake_upstream_connection_->waitForNewStream(*dispatcher_, upstream_request_));\n\n  // Send the rest of the request.\n  codec_client_->sendData(*request_encoder_, 10, true);\n  ASSERT_TRUE(upstream_request_->waitForEndStream(*dispatcher_));\n  // Verify the Expect header is stripped.\n  EXPECT_EQ(nullptr, upstream_request_->headers().get(Http::Headers::get().Expect));\n  if (via.empty()) {\n    EXPECT_EQ(nullptr, upstream_request_->headers().get(Http::Headers::get().Via));\n  } else {\n    EXPECT_EQ(via,\n              upstream_request_->headers().get(Http::Headers::get().Via)->value().getStringView());\n  }\n\n  if (additional_continue_from_upstream) {\n    // Make sure if upstream sends an 100-Continue Envoy doesn't send its own and proxy the one\n    // from upstream!\n    upstream_request_->encode100ContinueHeaders(Http::TestHeaderMapImpl{{\":status\", \"100\"}});\n  }\n  upstream_request_->encodeHeaders(default_response_headers_, false);\n  upstream_request_->encodeData(12, true);\n\n  response->waitForEndStream();\n  ASSERT_TRUE(response->complete());\n  ASSERT(response->continue_headers() != nullptr);\n  EXPECT_EQ(\"100\", response->continue_headers()->Status()->value().getStringView());\n  EXPECT_EQ(nullptr, response->continue_headers()->Via());\n  EXPECT_EQ(\"200\", response->headers().Status()->value().getStringView());\n  if (via.empty()) {\n    EXPECT_EQ(nullptr, response->headers().Via());\n  } else {\n    EXPECT_EQ(via.c_str(), response->headers().Via()->value().getStringView());\n  }\n}\n\nvoid HttpIntegrationTest::testEnvoyProxying100Continue(bool continue_before_upstream_complete,\n                                                       bool with_encoder_filter) {\n  if (with_encoder_filter) {\n    // Because 100-continue only affects encoder filters, make sure it plays well with one.\n    config_helper_.addFilter(\"name: envoy.cors\");\n    config_helper_.addConfigModifier(\n        [&](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager& hcm)\n            -> void {\n          auto* route_config = hcm.mutable_route_config();\n          auto* virtual_host = route_config->mutable_virtual_hosts(0);\n          {\n            auto* cors = virtual_host->mutable_cors();\n            cors->mutable_allow_origin_string_match()->Add()->set_exact(\"*\");\n            cors->set_allow_headers(\"content-type,x-grpc-web\");\n            cors->set_allow_methods(\"GET,POST\");\n          }\n        });\n  }\n  config_helper_.addConfigModifier(\n      [&](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager& hcm)\n          -> void { hcm.set_proxy_100_continue(true); });\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  auto encoder_decoder =\n      codec_client_->startRequest(Http::TestHeaderMapImpl{{\":method\", \"GET\"},\n                                                          {\":path\", \"/dynamo/url\"},\n                                                          {\":scheme\", \"http\"},\n                                                          {\":authority\", \"host\"},\n                                                          {\"expect\", \"100-continue\"}});\n  request_encoder_ = &encoder_decoder.first;\n  auto response = std::move(encoder_decoder.second);\n\n  // Wait for the request headers to be received upstream.\n  ASSERT_TRUE(fake_upstreams_[0]->waitForHttpConnection(*dispatcher_, fake_upstream_connection_));\n  ASSERT_TRUE(fake_upstream_connection_->waitForNewStream(*dispatcher_, upstream_request_));\n\n  if (continue_before_upstream_complete) {\n    // This case tests sending on 100-Continue headers before the client has sent all the\n    // request data.\n    upstream_request_->encode100ContinueHeaders(Http::TestHeaderMapImpl{{\":status\", \"100\"}});\n    response->waitForContinueHeaders();\n  }\n  // Send all of the request data and wait for it to be received upstream.\n  codec_client_->sendData(*request_encoder_, 10, true);\n  ASSERT_TRUE(upstream_request_->waitForEndStream(*dispatcher_));\n\n  if (!continue_before_upstream_complete) {\n    // This case tests forwarding 100-Continue after the client has sent all data.\n    upstream_request_->encode100ContinueHeaders(Http::TestHeaderMapImpl{{\":status\", \"100\"}});\n    response->waitForContinueHeaders();\n  }\n  // Now send the rest of the response.\n  upstream_request_->encodeHeaders(default_response_headers_, true);\n  response->waitForEndStream();\n  EXPECT_TRUE(response->complete());\n  ASSERT(response->continue_headers() != nullptr);\n  EXPECT_EQ(\"100\", response->continue_headers()->Status()->value().getStringView());\n\n  EXPECT_EQ(\"200\", response->headers().Status()->value().getStringView());\n}\n\nvoid HttpIntegrationTest::testTwoRequests(bool network_backup) {\n  // if network_backup is false, this simply tests that Envoy can handle multiple\n  // requests on a connection.\n  //\n  // If network_backup is true, the first request will explicitly set the TCP level flow control\n  // as blocked as it finishes the encode and set a timer to unblock. The second stream should be\n  // created while the socket appears to be in the high watermark state, and regression tests that\n  // flow control will be corrected as the socket \"becomes unblocked\"\n  if (network_backup) {\n    config_helper_.addFilter(R\"EOF(\n  name: pause-filter\n  config: {}\n  )EOF\");\n  }\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  // Request 1.\n  auto response = codec_client_->makeRequestWithBody(default_request_headers_, 1024);\n  waitForNextUpstreamRequest();\n\n  upstream_request_->encodeHeaders(default_response_headers_, false);\n  upstream_request_->encodeData(512, true);\n  response->waitForEndStream();\n\n  EXPECT_TRUE(upstream_request_->complete());\n  EXPECT_EQ(1024U, upstream_request_->bodyLength());\n  EXPECT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().Status()->value().getStringView());\n  EXPECT_EQ(512U, response->body().size());\n\n  // Request 2.\n  response = codec_client_->makeRequestWithBody(default_request_headers_, 512);\n  waitForNextUpstreamRequest();\n  upstream_request_->encodeHeaders(default_response_headers_, false);\n  upstream_request_->encodeData(1024, true);\n  response->waitForEndStream();\n\n  EXPECT_TRUE(upstream_request_->complete());\n  EXPECT_EQ(512U, upstream_request_->bodyLength());\n  EXPECT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().Status()->value().getStringView());\n  EXPECT_EQ(1024U, response->body().size());\n}\n\nvoid HttpIntegrationTest::testLargeRequestHeaders(uint32_t size, uint32_t max_size) {\n  // `size` parameter is the size of the header that will be added to the\n  // request. The actual request byte size will exceed `size` due to keys\n  // and other headers.\n\n  config_helper_.addConfigModifier(\n      [&](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager& hcm)\n          -> void { hcm.mutable_max_request_headers_kb()->set_value(max_size); });\n  max_request_headers_kb_ = max_size;\n\n  Http::TestHeaderMapImpl big_headers{\n      {\":method\", \"GET\"}, {\":path\", \"/test/long/url\"}, {\":scheme\", \"http\"}, {\":authority\", \"host\"}};\n\n  big_headers.addCopy(\"big\", std::string(size * 1024, 'a'));\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  if (size >= max_size) {\n    // header size includes keys too, so expect rejection when equal\n    auto encoder_decoder = codec_client_->startRequest(big_headers);\n    auto response = std::move(encoder_decoder.second);\n\n    if (downstream_protocol_ == Http::CodecClient::Type::HTTP1) {\n      codec_client_->waitForDisconnect();\n      EXPECT_TRUE(response->complete());\n      EXPECT_EQ(\"431\", response->headers().Status()->value().getStringView());\n    } else {\n      response->waitForReset();\n      codec_client_->close();\n    }\n  } else {\n    auto response = sendRequestAndWaitForResponse(big_headers, 0, default_response_headers_, 0);\n    EXPECT_TRUE(response->complete());\n    EXPECT_EQ(\"200\", response->headers().Status()->value().getStringView());\n  }\n}\n\nvoid HttpIntegrationTest::testDownstreamResetBeforeResponseComplete() {\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  auto encoder_decoder =\n      codec_client_->startRequest(Http::TestHeaderMapImpl{{\":method\", \"GET\"},\n                                                          {\":path\", \"/test/long/url\"},\n                                                          {\":scheme\", \"http\"},\n                                                          {\":authority\", \"host\"},\n                                                          {\"cookie\", \"a=b\"},\n                                                          {\"cookie\", \"c=d\"}});\n  request_encoder_ = &encoder_decoder.first;\n  auto response = std::move(encoder_decoder.second);\n  codec_client_->sendData(*request_encoder_, 0, true);\n  waitForNextUpstreamRequest();\n\n  EXPECT_EQ(upstream_request_->headers().get(Http::Headers::get().Cookie)->value(), \"a=b; c=d\");\n\n  upstream_request_->encodeHeaders(default_response_headers_, false);\n  upstream_request_->encodeData(512, false);\n\n  response->waitForBodyData(512);\n  codec_client_->sendReset(*request_encoder_);\n\n  if (upstreamProtocol() == FakeHttpConnection::Type::HTTP1) {\n    ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());\n  } else {\n    ASSERT_TRUE(upstream_request_->waitForReset());\n    ASSERT_TRUE(fake_upstream_connection_->close());\n    ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());\n  }\n\n  codec_client_->close();\n\n  EXPECT_TRUE(upstream_request_->complete());\n  EXPECT_EQ(0U, upstream_request_->bodyLength());\n\n  EXPECT_FALSE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().Status()->value().getStringView());\n  EXPECT_EQ(512U, response->body().size());\n}\n\nvoid HttpIntegrationTest::testTrailers(uint64_t request_size, uint64_t response_size) {\n  Http::TestHeaderMapImpl request_trailers{{\"request1\", \"trailer1\"}, {\"request2\", \"trailer2\"}};\n  Http::TestHeaderMapImpl response_trailers{{\"response1\", \"trailer1\"}, {\"response2\", \"trailer2\"}};\n\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  auto encoder_decoder =\n      codec_client_->startRequest(Http::TestHeaderMapImpl{{\":method\", \"POST\"},\n                                                          {\":path\", \"/test/long/url\"},\n                                                          {\":scheme\", \"http\"},\n                                                          {\":authority\", \"host\"}});\n  request_encoder_ = &encoder_decoder.first;\n  auto response = std::move(encoder_decoder.second);\n  codec_client_->sendData(*request_encoder_, request_size, false);\n  codec_client_->sendTrailers(*request_encoder_, request_trailers);\n  waitForNextUpstreamRequest();\n  upstream_request_->encodeHeaders(default_response_headers_, false);\n  upstream_request_->encodeData(response_size, false);\n  upstream_request_->encodeTrailers(response_trailers);\n  response->waitForEndStream();\n\n  EXPECT_TRUE(upstream_request_->complete());\n  EXPECT_EQ(request_size, upstream_request_->bodyLength());\n  if (fake_upstreams_[0]->httpType() == FakeHttpConnection::Type::HTTP2) {\n    EXPECT_THAT(*upstream_request_->trailers(), HeaderMapEqualRef(&request_trailers));\n  }\n\n  EXPECT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().Status()->value().getStringView());\n  EXPECT_EQ(response_size, response->body().size());\n  if (fake_upstreams_[0]->httpType() == FakeHttpConnection::Type::HTTP2) {\n    EXPECT_THAT(*response->trailers(), HeaderMapEqualRef(&response_trailers));\n  }\n}\n\nstd::string HttpIntegrationTest::listenerStatPrefix(const std::string& stat_name) {\n  if (version_ == Network::Address::IpVersion::v4) {\n    return \"listener.127.0.0.1_0.\" + stat_name;\n  }\n  return \"listener.[__1]_0.\" + stat_name;\n}\n} // namespace Envoy\n", "#pragma once\n\n#include <cstdint>\n#include <memory>\n#include <string>\n\n#include \"common/http/codec_client.h\"\n#include \"common/network/filter_impl.h\"\n\n#include \"test/integration/integration.h\"\n#include \"test/integration/utility.h\"\n#include \"test/test_common/printers.h\"\n\nnamespace Envoy {\n\n/**\n * HTTP codec client used during integration testing.\n */\nclass IntegrationCodecClient : public Http::CodecClientProd {\npublic:\n  IntegrationCodecClient(Event::Dispatcher& dispatcher, Network::ClientConnectionPtr&& conn,\n                         Upstream::HostDescriptionConstSharedPtr host_description,\n                         Http::CodecClient::Type type);\n\n  IntegrationStreamDecoderPtr makeHeaderOnlyRequest(const Http::HeaderMap& headers);\n  IntegrationStreamDecoderPtr makeRequestWithBody(const Http::HeaderMap& headers,\n                                                  uint64_t body_size);\n  IntegrationStreamDecoderPtr makeRequestWithBody(const Http::HeaderMap& headers,\n                                                  const std::string& body);\n  bool sawGoAway() const { return saw_goaway_; }\n  bool connected() const { return connected_; }\n  void sendData(Http::StreamEncoder& encoder, absl::string_view data, bool end_stream);\n  void sendData(Http::StreamEncoder& encoder, Buffer::Instance& data, bool end_stream);\n  void sendData(Http::StreamEncoder& encoder, uint64_t size, bool end_stream);\n  void sendTrailers(Http::StreamEncoder& encoder, const Http::HeaderMap& trailers);\n  void sendReset(Http::StreamEncoder& encoder);\n  // Intentionally makes a copy of metadata_map.\n  void sendMetadata(Http::StreamEncoder& encoder, Http::MetadataMap metadata_map);\n  std::pair<Http::StreamEncoder&, IntegrationStreamDecoderPtr>\n  startRequest(const Http::HeaderMap& headers);\n  bool waitForDisconnect(std::chrono::milliseconds time_to_wait = std::chrono::milliseconds(0));\n  Network::ClientConnection* connection() const { return connection_.get(); }\n  Network::ConnectionEvent last_connection_event() const { return last_connection_event_; }\n  Network::Connection& rawConnection() { return *connection_; }\n  bool disconnected() { return disconnected_; }\n\nprivate:\n  struct ConnectionCallbacks : public Network::ConnectionCallbacks {\n    ConnectionCallbacks(IntegrationCodecClient& parent) : parent_(parent) {}\n\n    // Network::ConnectionCallbacks\n    void onEvent(Network::ConnectionEvent event) override;\n    void onAboveWriteBufferHighWatermark() override {}\n    void onBelowWriteBufferLowWatermark() override {}\n\n    IntegrationCodecClient& parent_;\n  };\n\n  struct CodecCallbacks : public Http::ConnectionCallbacks {\n    CodecCallbacks(IntegrationCodecClient& parent) : parent_(parent) {}\n\n    // Http::ConnectionCallbacks\n    void onGoAway() override { parent_.saw_goaway_ = true; }\n\n    IntegrationCodecClient& parent_;\n  };\n\n  void flushWrite();\n\n  Event::Dispatcher& dispatcher_;\n  ConnectionCallbacks callbacks_;\n  CodecCallbacks codec_callbacks_;\n  bool connected_{};\n  bool disconnected_{};\n  bool saw_goaway_{};\n  Network::ConnectionEvent last_connection_event_;\n};\n\nusing IntegrationCodecClientPtr = std::unique_ptr<IntegrationCodecClient>;\n\n/**\n * Test fixture for HTTP and HTTP/2 integration tests.\n */\nclass HttpIntegrationTest : public BaseIntegrationTest {\npublic:\n  // TODO(jmarantz): Remove this once\n  // https://github.com/envoyproxy/envoy-filter-example/pull/69 is reverted.\n  HttpIntegrationTest(Http::CodecClient::Type downstream_protocol,\n                      Network::Address::IpVersion version, TestTimeSystemPtr,\n                      const std::string& config = ConfigHelper::HTTP_PROXY_CONFIG)\n      : HttpIntegrationTest(downstream_protocol, version, config) {}\n\n  HttpIntegrationTest(Http::CodecClient::Type downstream_protocol,\n                      Network::Address::IpVersion version,\n                      const std::string& config = ConfigHelper::HTTP_PROXY_CONFIG);\n\n  HttpIntegrationTest(Http::CodecClient::Type downstream_protocol,\n                      const InstanceConstSharedPtrFn& upstream_address_fn,\n                      Network::Address::IpVersion version,\n                      const std::string& config = ConfigHelper::HTTP_PROXY_CONFIG);\n  ~HttpIntegrationTest() override;\n\n  // Waits for the first access log entry.\n  std::string waitForAccessLog(const std::string& filename);\n\nprotected:\n  void useAccessLog();\n\n  IntegrationCodecClientPtr makeHttpConnection(uint32_t port);\n  // Makes a http connection object without checking its connected state.\n  IntegrationCodecClientPtr makeRawHttpConnection(Network::ClientConnectionPtr&& conn);\n  // Makes a http connection object with asserting a connected state.\n  IntegrationCodecClientPtr makeHttpConnection(Network::ClientConnectionPtr&& conn);\n\n  // Sets downstream_protocol_ and alters the HTTP connection manager codec type in the\n  // config_helper_.\n  void setDownstreamProtocol(Http::CodecClient::Type type);\n\n  // Sends |request_headers| and |request_body_size| bytes of body upstream.\n  // Configured upstream to send |response_headers| and |response_body_size|\n  // bytes of body downstream.\n  //\n  // Waits for the complete downstream response before returning.\n  // Requires |codec_client_| to be initialized.\n  IntegrationStreamDecoderPtr\n  sendRequestAndWaitForResponse(const Http::TestHeaderMapImpl& request_headers,\n                                uint32_t request_body_size,\n                                const Http::TestHeaderMapImpl& response_headers,\n                                uint32_t response_body_size, int upstream_index = 0);\n\n  // Wait for the end of stream on the next upstream stream on any of the provided fake upstreams.\n  // Sets fake_upstream_connection_ to the connection and upstream_request_ to stream.\n  // In cases where the upstream that will receive the request is not deterministic, a second\n  // upstream index may be provided, in which case both upstreams will be checked for requests.\n  uint64_t waitForNextUpstreamRequest(const std::vector<uint64_t>& upstream_indices);\n  void waitForNextUpstreamRequest(uint64_t upstream_index = 0);\n\n  // Close |codec_client_| and |fake_upstream_connection_| cleanly.\n  void cleanupUpstreamAndDownstream();\n\n  // Verifies the response_headers contains the expected_headers, and response body matches given\n  // body string.\n  void verifyResponse(IntegrationStreamDecoderPtr response, const std::string& response_code,\n                      const Http::TestHeaderMapImpl& expected_headers,\n                      const std::string& expected_body);\n\n  // Helper that sends a request to Envoy, and verifies if Envoy response headers and body size is\n  // the same as the expected headers map.\n  // Requires the \"http\" port has been registered.\n  void sendRequestAndVerifyResponse(const Http::TestHeaderMapImpl& request_headers,\n                                    const int request_size,\n                                    const Http::TestHeaderMapImpl& response_headers,\n                                    const int response_size, const int backend_idx);\n\n  // Check for completion of upstream_request_, and a simple \"200\" response.\n  void checkSimpleRequestSuccess(uint64_t expected_request_size, uint64_t expected_response_size,\n                                 IntegrationStreamDecoder* response);\n\n  using ConnectionCreationFunction = std::function<Network::ClientConnectionPtr()>;\n  // Sends a simple header-only HTTP request, and waits for a response.\n  IntegrationStreamDecoderPtr makeHeaderOnlyRequest(ConnectionCreationFunction* create_connection,\n                                                    int upstream_index,\n                                                    const std::string& path = \"/test/long/url\",\n                                                    const std::string& authority = \"host\");\n  void testRouterNotFound();\n  void testRouterNotFoundWithBody();\n\n  void testRouterRequestAndResponseWithBody(uint64_t request_size, uint64_t response_size,\n                                            bool big_header,\n                                            ConnectionCreationFunction* creator = nullptr);\n  void testRouterHeaderOnlyRequestAndResponse(ConnectionCreationFunction* creator = nullptr,\n                                              int upstream_index = 0,\n                                              const std::string& path = \"/test/long/url\",\n                                              const std::string& authority = \"host\");\n  void testRequestAndResponseShutdownWithActiveConnection();\n\n  // Disconnect tests\n  void testRouterUpstreamDisconnectBeforeRequestComplete();\n  void\n  testRouterUpstreamDisconnectBeforeResponseComplete(ConnectionCreationFunction* creator = nullptr);\n  void testRouterDownstreamDisconnectBeforeRequestComplete(\n      ConnectionCreationFunction* creator = nullptr);\n  void testRouterDownstreamDisconnectBeforeResponseComplete(\n      ConnectionCreationFunction* creator = nullptr);\n  void testRouterUpstreamResponseBeforeRequestComplete();\n\n  void testTwoRequests(bool force_network_backup = false);\n  void testLargeRequestHeaders(uint32_t size, uint32_t max_size = 60);\n\n  void testAddEncodedTrailers();\n  void testRetry();\n  void testRetryHittingBufferLimit();\n  void testRetryAttemptCountHeader();\n  void testGrpcRetry();\n\n  void testEnvoyHandling100Continue(bool additional_continue_from_upstream = false,\n                                    const std::string& via = \"\");\n  void testEnvoyProxying100Continue(bool continue_before_upstream_complete = false,\n                                    bool with_encoder_filter = false);\n\n  // HTTP/2 client tests.\n  void testDownstreamResetBeforeResponseComplete();\n  void testTrailers(uint64_t request_size, uint64_t response_size);\n\n  Http::CodecClient::Type downstreamProtocol() const { return downstream_protocol_; }\n  // Prefix listener stat with IP:port, including IP version dependent loopback address.\n  std::string listenerStatPrefix(const std::string& stat_name);\n\n  // The client making requests to Envoy.\n  IntegrationCodecClientPtr codec_client_;\n  // A placeholder for the first upstream connection.\n  FakeHttpConnectionPtr fake_upstream_connection_;\n  // A placeholder for the first request received at upstream.\n  FakeStreamPtr upstream_request_;\n  // A pointer to the request encoder, if used.\n  Http::StreamEncoder* request_encoder_{nullptr};\n  // The response headers sent by sendRequestAndWaitForResponse() by default.\n  Http::TestHeaderMapImpl default_response_headers_{{\":status\", \"200\"}};\n  Http::TestHeaderMapImpl default_request_headers_{\n      {\":method\", \"GET\"}, {\":path\", \"/test/long/url\"}, {\":scheme\", \"http\"}, {\":authority\", \"host\"}};\n  // The codec type for the client-to-Envoy connection\n  Http::CodecClient::Type downstream_protocol_{Http::CodecClient::Type::HTTP1};\n  uint32_t max_request_headers_kb_{Http::DEFAULT_MAX_REQUEST_HEADERS_KB};\n  std::string access_log_name_;\n};\n} // namespace Envoy\n", "#include <functional>\n#include <list>\n#include <memory>\n#include <regex>\n#include <string>\n#include <vector>\n\n#include \"envoy/buffer/buffer.h\"\n#include \"envoy/event/dispatcher.h\"\n#include \"envoy/http/header_map.h\"\n#include \"envoy/registry/registry.h\"\n\n#include \"common/api/api_impl.h\"\n#include \"common/buffer/buffer_impl.h\"\n#include \"common/common/fmt.h\"\n#include \"common/common/thread_annotations.h\"\n#include \"common/http/headers.h\"\n#include \"common/network/utility.h\"\n#include \"common/protobuf/utility.h\"\n#include \"common/runtime/runtime_impl.h\"\n#include \"common/upstream/upstream_impl.h\"\n\n#include \"test/common/upstream/utility.h\"\n#include \"test/integration/autonomous_upstream.h\"\n#include \"test/integration/http_integration.h\"\n#include \"test/integration/http_protocol_integration.h\"\n#include \"test/integration/test_host_predicate_config.h\"\n#include \"test/integration/utility.h\"\n#include \"test/mocks/upstream/mocks.h\"\n#include \"test/test_common/environment.h\"\n#include \"test/test_common/network_utility.h\"\n#include \"test/test_common/registry.h\"\n\n#include \"gtest/gtest.h\"\n\nusing testing::HasSubstr;\n\nnamespace Envoy {\n\nvoid setDoNotValidateRouteConfig(\n    envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager& hcm) {\n  auto* route_config = hcm.mutable_route_config();\n  route_config->mutable_validate_clusters()->set_value(false);\n};\n\n// Tests for DownstreamProtocolIntegrationTest will be run with all protocols\n// (H1/H2 downstream) but only H1 upstreams.\n//\n// This is useful for things which will likely not differ based on upstream\n// behavior, for example \"how does Envoy handle duplicate content lengths from\n// downstream\"?\nclass DownstreamProtocolIntegrationTest : public HttpProtocolIntegrationTest {\nprotected:\n  void changeHeadersForStopAllTests(Http::TestHeaderMapImpl& headers, bool set_buffer_limit) {\n    headers.addCopy(\"content_size\", std::to_string(count_ * size_));\n    headers.addCopy(\"added_size\", std::to_string(added_decoded_data_size_));\n    headers.addCopy(\"is_first_trigger\", \"value\");\n    if (set_buffer_limit) {\n      headers.addCopy(\"buffer_limit\", std::to_string(buffer_limit_));\n    }\n  }\n\n  void verifyUpStreamRequestAfterStopAllFilter() {\n    if (downstreamProtocol() == Http::CodecClient::Type::HTTP2) {\n      // decode-headers-return-stop-all-filter calls addDecodedData in decodeData and\n      // decodeTrailers. 2 decoded data were added.\n      EXPECT_EQ(count_ * size_ + added_decoded_data_size_ * 2, upstream_request_->bodyLength());\n    } else {\n      EXPECT_EQ(count_ * size_ + added_decoded_data_size_ * 1, upstream_request_->bodyLength());\n    }\n    EXPECT_EQ(true, upstream_request_->complete());\n  }\n\n  const int count_ = 70;\n  const int size_ = 1000;\n  const int added_decoded_data_size_ = 1;\n  const int buffer_limit_ = 100;\n};\n\n// Tests for ProtocolIntegrationTest will be run with the full mesh of H1/H2\n// downstream and H1/H2 upstreams.\nusing ProtocolIntegrationTest = HttpProtocolIntegrationTest;\n\nTEST_P(ProtocolIntegrationTest, ShutdownWithActiveConnPoolConnections) {\n  auto response = makeHeaderOnlyRequest(nullptr, 0);\n  // Shut down the server with active connection pool connections.\n  fake_upstreams_[0]->set_allow_unexpected_disconnects(true);\n  test_server_.reset();\n  checkSimpleRequestSuccess(0U, 0U, response.get());\n}\n\n// Change the default route to be restrictive, and send a request to an alternate route.\nTEST_P(ProtocolIntegrationTest, RouterNotFound) { testRouterNotFound(); }\n\n// Change the default route to be restrictive, and send a POST to an alternate route.\nTEST_P(DownstreamProtocolIntegrationTest, RouterNotFoundBodyNoBuffer) {\n  testRouterNotFoundWithBody();\n}\n\n// Add a route that uses unknown cluster (expect 404 Not Found).\nTEST_P(DownstreamProtocolIntegrationTest, RouterClusterNotFound404) {\n  config_helper_.addConfigModifier(&setDoNotValidateRouteConfig);\n  auto host = config_helper_.createVirtualHost(\"foo.com\", \"/unknown\", \"unknown_cluster\");\n  host.mutable_routes(0)->mutable_route()->set_cluster_not_found_response_code(\n      envoy::api::v2::route::RouteAction::NOT_FOUND);\n  config_helper_.addVirtualHost(host);\n  initialize();\n\n  BufferingStreamDecoderPtr response = IntegrationUtil::makeSingleRequest(\n      lookupPort(\"http\"), \"GET\", \"/unknown\", \"\", downstream_protocol_, version_, \"foo.com\");\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"404\", response->headers().Status()->value().getStringView());\n}\n\n// Add a route that uses unknown cluster (expect 503 Service Unavailable).\nTEST_P(DownstreamProtocolIntegrationTest, RouterClusterNotFound503) {\n  config_helper_.addConfigModifier(&setDoNotValidateRouteConfig);\n  auto host = config_helper_.createVirtualHost(\"foo.com\", \"/unknown\", \"unknown_cluster\");\n  host.mutable_routes(0)->mutable_route()->set_cluster_not_found_response_code(\n      envoy::api::v2::route::RouteAction::SERVICE_UNAVAILABLE);\n  config_helper_.addVirtualHost(host);\n  initialize();\n\n  BufferingStreamDecoderPtr response = IntegrationUtil::makeSingleRequest(\n      lookupPort(\"http\"), \"GET\", \"/unknown\", \"\", downstream_protocol_, version_, \"foo.com\");\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"503\", response->headers().Status()->value().getStringView());\n}\n\n// Add a route which redirects HTTP to HTTPS, and verify Envoy sends a 301\nTEST_P(ProtocolIntegrationTest, RouterRedirect) {\n  auto host = config_helper_.createVirtualHost(\"www.redirect.com\", \"/\");\n  host.set_require_tls(envoy::api::v2::route::VirtualHost::ALL);\n  config_helper_.addVirtualHost(host);\n  initialize();\n\n  BufferingStreamDecoderPtr response = IntegrationUtil::makeSingleRequest(\n      lookupPort(\"http\"), \"GET\", \"/foo\", \"\", downstream_protocol_, version_, \"www.redirect.com\");\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"301\", response->headers().Status()->value().getStringView());\n  EXPECT_EQ(\"https://www.redirect.com/foo\",\n            response->headers().get(Http::Headers::get().Location)->value().getStringView());\n}\n\n// Add a health check filter and verify correct computation of health based on upstream status.\nTEST_P(ProtocolIntegrationTest, ComputedHealthCheck) {\n  config_helper_.addFilter(R\"EOF(\nname: envoy.health_check\nconfig:\n    pass_through_mode: false\n    cluster_min_healthy_percentages:\n        example_cluster_name: { value: 75 }\n)EOF\");\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  auto response = codec_client_->makeHeaderOnlyRequest(Http::TestHeaderMapImpl{\n      {\":method\", \"GET\"}, {\":path\", \"/healthcheck\"}, {\":scheme\", \"http\"}, {\":authority\", \"host\"}});\n  response->waitForEndStream();\n\n  EXPECT_TRUE(response->complete());\n  EXPECT_EQ(\"503\", response->headers().Status()->value().getStringView());\n}\n\n// Add a health check filter and verify correct computation of health based on upstream status.\nTEST_P(ProtocolIntegrationTest, ModifyBuffer) {\n  config_helper_.addFilter(R\"EOF(\nname: envoy.health_check\nconfig:\n    pass_through_mode: false\n    cluster_min_healthy_percentages:\n        example_cluster_name: { value: 75 }\n)EOF\");\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  auto response = codec_client_->makeHeaderOnlyRequest(Http::TestHeaderMapImpl{\n      {\":method\", \"GET\"}, {\":path\", \"/healthcheck\"}, {\":scheme\", \"http\"}, {\":authority\", \"host\"}});\n  response->waitForEndStream();\n\n  EXPECT_TRUE(response->complete());\n  EXPECT_EQ(\"503\", response->headers().Status()->value().getStringView());\n}\n\nTEST_P(ProtocolIntegrationTest, AddEncodedTrailers) {\n  config_helper_.addFilter(R\"EOF(\nname: add-trailers-filter\nconfig: {}\n)EOF\");\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  auto response = codec_client_->makeRequestWithBody(default_request_headers_, 128);\n  waitForNextUpstreamRequest();\n  upstream_request_->encodeHeaders(Http::TestHeaderMapImpl{{\":status\", \"503\"}}, false);\n  upstream_request_->encodeData(128, true);\n  response->waitForEndStream();\n\n  if (upstreamProtocol() == FakeHttpConnection::Type::HTTP2) {\n    EXPECT_EQ(\"decode\", upstream_request_->trailers()->GrpcMessage()->value().getStringView());\n  }\n  EXPECT_TRUE(response->complete());\n  EXPECT_EQ(\"503\", response->headers().Status()->value().getStringView());\n  if (downstream_protocol_ == Http::CodecClient::Type::HTTP2) {\n    EXPECT_EQ(\"encode\", response->trailers()->GrpcMessage()->value().getStringView());\n  }\n}\n\n// Add a health check filter and verify correct behavior when draining.\nTEST_P(ProtocolIntegrationTest, DrainClose) {\n  config_helper_.addFilter(ConfigHelper::DEFAULT_HEALTH_CHECK_FILTER);\n  initialize();\n\n  test_server_->drainManager().draining_ = true;\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  auto response = codec_client_->makeHeaderOnlyRequest(default_request_headers_);\n  response->waitForEndStream();\n  codec_client_->waitForDisconnect();\n\n  EXPECT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().Status()->value().getStringView());\n  if (downstream_protocol_ == Http::CodecClient::Type::HTTP2) {\n    EXPECT_TRUE(codec_client_->sawGoAway());\n  }\n\n  test_server_->drainManager().draining_ = false;\n}\n\nTEST_P(ProtocolIntegrationTest, Retry) {\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  auto response =\n      codec_client_->makeRequestWithBody(Http::TestHeaderMapImpl{{\":method\", \"POST\"},\n                                                                 {\":path\", \"/test/long/url\"},\n                                                                 {\":scheme\", \"http\"},\n                                                                 {\":authority\", \"host\"},\n                                                                 {\"x-forwarded-for\", \"10.0.0.1\"},\n                                                                 {\"x-envoy-retry-on\", \"5xx\"}},\n                                         1024);\n  waitForNextUpstreamRequest();\n  upstream_request_->encodeHeaders(Http::TestHeaderMapImpl{{\":status\", \"503\"}}, false);\n\n  if (fake_upstreams_[0]->httpType() == FakeHttpConnection::Type::HTTP1) {\n    ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());\n    ASSERT_TRUE(fake_upstreams_[0]->waitForHttpConnection(*dispatcher_, fake_upstream_connection_));\n  } else {\n    ASSERT_TRUE(upstream_request_->waitForReset());\n  }\n  waitForNextUpstreamRequest();\n  upstream_request_->encodeHeaders(default_response_headers_, false);\n  upstream_request_->encodeData(512, true);\n\n  response->waitForEndStream();\n  EXPECT_TRUE(upstream_request_->complete());\n  EXPECT_EQ(1024U, upstream_request_->bodyLength());\n\n  EXPECT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().Status()->value().getStringView());\n  EXPECT_EQ(512U, response->body().size());\n}\n\n// Tests that the x-envoy-attempt-count header is properly set on the upstream request\n// and updated after the request is retried.\nTEST_P(DownstreamProtocolIntegrationTest, RetryAttemptCountHeader) {\n  auto host = config_helper_.createVirtualHost(\"host\", \"/test_retry\");\n  host.set_include_request_attempt_count(true);\n  config_helper_.addVirtualHost(host);\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  auto response =\n      codec_client_->makeRequestWithBody(Http::TestHeaderMapImpl{{\":method\", \"POST\"},\n                                                                 {\":path\", \"/test_retry\"},\n                                                                 {\":scheme\", \"http\"},\n                                                                 {\":authority\", \"host\"},\n                                                                 {\"x-forwarded-for\", \"10.0.0.1\"},\n                                                                 {\"x-envoy-retry-on\", \"5xx\"}},\n                                         1024);\n  waitForNextUpstreamRequest();\n  upstream_request_->encodeHeaders(Http::TestHeaderMapImpl{{\":status\", \"503\"}}, false);\n\n  EXPECT_EQ(\n      atoi(std::string(upstream_request_->headers().EnvoyAttemptCount()->value().getStringView())\n               .c_str()),\n      1);\n\n  if (fake_upstreams_[0]->httpType() == FakeHttpConnection::Type::HTTP1) {\n    ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());\n    ASSERT_TRUE(fake_upstreams_[0]->waitForHttpConnection(*dispatcher_, fake_upstream_connection_));\n  } else {\n    ASSERT_TRUE(upstream_request_->waitForReset());\n  }\n  waitForNextUpstreamRequest();\n  EXPECT_EQ(\n      atoi(std::string(upstream_request_->headers().EnvoyAttemptCount()->value().getStringView())\n               .c_str()),\n      2);\n  upstream_request_->encodeHeaders(default_response_headers_, false);\n  upstream_request_->encodeData(512, true);\n\n  response->waitForEndStream();\n  EXPECT_TRUE(upstream_request_->complete());\n  EXPECT_EQ(1024U, upstream_request_->bodyLength());\n\n  EXPECT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().Status()->value().getStringView());\n  EXPECT_EQ(512U, response->body().size());\n}\n\n// Verifies that a retry priority can be configured and affect the host selected during retries.\n// The retry priority will always target P1, which would otherwise never be hit due to P0 being\n// healthy.\nTEST_P(DownstreamProtocolIntegrationTest, RetryPriority) {\n  const Upstream::HealthyLoad healthy_priority_load({0u, 100u});\n  const Upstream::DegradedLoad degraded_priority_load({0u, 100u});\n  NiceMock<Upstream::MockRetryPriority> retry_priority(healthy_priority_load,\n                                                       degraded_priority_load);\n  Upstream::MockRetryPriorityFactory factory(retry_priority);\n\n  Registry::InjectFactory<Upstream::RetryPriorityFactory> inject_factory(factory);\n\n  // Add route with custom retry policy\n  auto host = config_helper_.createVirtualHost(\"host\", \"/test_retry\");\n  host.set_include_request_attempt_count(true);\n  auto retry_policy = host.mutable_routes(0)->mutable_route()->mutable_retry_policy();\n  retry_policy->mutable_retry_priority()->set_name(factory.name());\n  config_helper_.addVirtualHost(host);\n\n  // Use load assignments instead of static hosts. Necessary in order to use priorities.\n  config_helper_.addConfigModifier([](envoy::config::bootstrap::v2::Bootstrap& bootstrap) {\n    auto cluster = bootstrap.mutable_static_resources()->mutable_clusters(0);\n    auto load_assignment = cluster->mutable_load_assignment();\n    load_assignment->set_cluster_name(cluster->name());\n    const auto& host_address = cluster->hosts(0).socket_address().address();\n\n    for (int i = 0; i < 2; ++i) {\n      auto locality = load_assignment->add_endpoints();\n      locality->set_priority(i);\n      locality->mutable_locality()->set_region(\"region\");\n      locality->mutable_locality()->set_zone(\"zone\");\n      locality->mutable_locality()->set_sub_zone(\"sub_zone\" + std::to_string(i));\n      auto lb_endpoint = locality->add_lb_endpoints();\n      lb_endpoint->mutable_endpoint()->mutable_address()->mutable_socket_address()->set_address(\n          host_address);\n      lb_endpoint->mutable_endpoint()->mutable_address()->mutable_socket_address()->set_port_value(\n          0);\n    }\n\n    cluster->clear_hosts();\n  });\n\n  fake_upstreams_count_ = 2;\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  auto response =\n      codec_client_->makeRequestWithBody(Http::TestHeaderMapImpl{{\":method\", \"POST\"},\n                                                                 {\":path\", \"/test_retry\"},\n                                                                 {\":scheme\", \"http\"},\n                                                                 {\":authority\", \"host\"},\n                                                                 {\"x-forwarded-for\", \"10.0.0.1\"},\n                                                                 {\"x-envoy-retry-on\", \"5xx\"}},\n                                         1024);\n\n  // Note how we're expecting each upstream request to hit the same upstream.\n  waitForNextUpstreamRequest(0);\n  upstream_request_->encodeHeaders(Http::TestHeaderMapImpl{{\":status\", \"503\"}}, false);\n\n  if (fake_upstreams_[0]->httpType() == FakeHttpConnection::Type::HTTP1) {\n    ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());\n    ASSERT_TRUE(fake_upstreams_[1]->waitForHttpConnection(*dispatcher_, fake_upstream_connection_));\n  } else {\n    ASSERT_TRUE(upstream_request_->waitForReset());\n  }\n\n  waitForNextUpstreamRequest(1);\n  upstream_request_->encodeHeaders(default_response_headers_, false);\n  upstream_request_->encodeData(512, true);\n\n  response->waitForEndStream();\n  EXPECT_TRUE(upstream_request_->complete());\n  EXPECT_EQ(1024U, upstream_request_->bodyLength());\n\n  EXPECT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().Status()->value().getStringView());\n  EXPECT_EQ(512U, response->body().size());\n}\n\n//\n// Verifies that a retry host filter can be configured and affect the host selected during retries.\n// The predicate will keep track of the first host attempted, and attempt to route all requests to\n// the same host. With a total of two upstream hosts, this should result in us continuously sending\n// requests to the same host.\nTEST_P(DownstreamProtocolIntegrationTest, RetryHostPredicateFilter) {\n  TestHostPredicateFactory predicate_factory;\n  Registry::InjectFactory<Upstream::RetryHostPredicateFactory> inject_factory(predicate_factory);\n\n  // Add route with custom retry policy\n  auto host = config_helper_.createVirtualHost(\"host\", \"/test_retry\");\n  host.set_include_request_attempt_count(true);\n  auto retry_policy = host.mutable_routes(0)->mutable_route()->mutable_retry_policy();\n  retry_policy->add_retry_host_predicate()->set_name(predicate_factory.name());\n  config_helper_.addVirtualHost(host);\n\n  // We want to work with a cluster with two hosts.\n  config_helper_.addConfigModifier([](envoy::config::bootstrap::v2::Bootstrap& bootstrap) {\n    auto* new_host = bootstrap.mutable_static_resources()->mutable_clusters(0)->add_hosts();\n    new_host->MergeFrom(bootstrap.static_resources().clusters(0).hosts(0));\n  });\n  fake_upstreams_count_ = 2;\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  auto response =\n      codec_client_->makeRequestWithBody(Http::TestHeaderMapImpl{{\":method\", \"POST\"},\n                                                                 {\":path\", \"/test_retry\"},\n                                                                 {\":scheme\", \"http\"},\n                                                                 {\":authority\", \"host\"},\n                                                                 {\"x-forwarded-for\", \"10.0.0.1\"},\n                                                                 {\"x-envoy-retry-on\", \"5xx\"}},\n                                         1024);\n\n  // Note how we're expecting each upstream request to hit the same upstream.\n  auto upstream_idx = waitForNextUpstreamRequest({0, 1});\n  upstream_request_->encodeHeaders(Http::TestHeaderMapImpl{{\":status\", \"503\"}}, false);\n\n  if (fake_upstreams_[upstream_idx]->httpType() == FakeHttpConnection::Type::HTTP1) {\n    ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());\n    ASSERT_TRUE(fake_upstreams_[upstream_idx]->waitForHttpConnection(*dispatcher_,\n                                                                     fake_upstream_connection_));\n  } else {\n    ASSERT_TRUE(upstream_request_->waitForReset());\n  }\n\n  waitForNextUpstreamRequest(upstream_idx);\n  upstream_request_->encodeHeaders(default_response_headers_, false);\n  upstream_request_->encodeData(512, true);\n\n  response->waitForEndStream();\n  EXPECT_TRUE(upstream_request_->complete());\n  EXPECT_EQ(1024U, upstream_request_->bodyLength());\n\n  EXPECT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().Status()->value().getStringView());\n  EXPECT_EQ(512U, response->body().size());\n}\n\n// Very similar set-up to testRetry but with a 16k request the request will not\n// be buffered and the 503 will be returned to the user.\nTEST_P(ProtocolIntegrationTest, RetryHittingBufferLimit) {\n  config_helper_.setBufferLimits(1024, 1024); // Set buffer limits upstream and downstream.\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  auto response =\n      codec_client_->makeRequestWithBody(Http::TestHeaderMapImpl{{\":method\", \"POST\"},\n                                                                 {\":path\", \"/test/long/url\"},\n                                                                 {\":scheme\", \"http\"},\n                                                                 {\":authority\", \"host\"},\n                                                                 {\"x-forwarded-for\", \"10.0.0.1\"},\n                                                                 {\"x-envoy-retry-on\", \"5xx\"}},\n                                         1024 * 65);\n  waitForNextUpstreamRequest();\n\n  upstream_request_->encodeHeaders(Http::TestHeaderMapImpl{{\":status\", \"503\"}}, true);\n\n  response->waitForEndStream();\n  EXPECT_TRUE(upstream_request_->complete());\n  EXPECT_EQ(66560U, upstream_request_->bodyLength());\n\n  EXPECT_TRUE(response->complete());\n  EXPECT_EQ(\"503\", response->headers().Status()->value().getStringView());\n}\n\n// Test hitting the dynamo filter with too many request bytes to buffer. Ensure the connection\n// manager sends a 413.\nTEST_P(DownstreamProtocolIntegrationTest, HittingDecoderFilterLimit) {\n  config_helper_.addFilter(\"{ name: envoy.http_dynamo_filter, config: {} }\");\n  config_helper_.setBufferLimits(1024, 1024);\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  // Envoy will likely connect and proxy some unspecified amount of data before\n  // hitting the buffer limit and disconnecting. Ignore this if it happens.\n  fake_upstreams_[0]->set_allow_unexpected_disconnects(true);\n  auto response =\n      codec_client_->makeRequestWithBody(Http::TestHeaderMapImpl{{\":method\", \"POST\"},\n                                                                 {\":path\", \"/dynamo/url\"},\n                                                                 {\":scheme\", \"http\"},\n                                                                 {\":authority\", \"host\"},\n                                                                 {\"x-forwarded-for\", \"10.0.0.1\"},\n                                                                 {\"x-envoy-retry-on\", \"5xx\"}},\n                                         1024 * 65);\n\n  response->waitForEndStream();\n  // With HTTP/1 there's a possible race where if the connection backs up early,\n  // the 413-and-connection-close may be sent while the body is still being\n  // sent, resulting in a write error and the connection being closed before the\n  // response is read.\n  if (downstream_protocol_ == Http::CodecClient::Type::HTTP2) {\n    ASSERT_TRUE(response->complete());\n  }\n  if (response->complete()) {\n    EXPECT_EQ(\"413\", response->headers().Status()->value().getStringView());\n  }\n}\n\n// Test hitting the dynamo filter with too many response bytes to buffer. Given the request headers\n// are sent on early, the stream/connection will be reset.\nTEST_P(ProtocolIntegrationTest, HittingEncoderFilterLimit) {\n  useAccessLog();\n  config_helper_.addFilter(\"{ name: envoy.http_dynamo_filter, config: {} }\");\n  config_helper_.setBufferLimits(1024, 1024);\n  initialize();\n\n  // Send the request.\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  auto encoder_decoder = codec_client_->startRequest(default_request_headers_);\n  auto downstream_request = &encoder_decoder.first;\n  auto response = std::move(encoder_decoder.second);\n  Buffer::OwnedImpl data(R\"({\"TableName\":\"locations\"})\");\n  codec_client_->sendData(*downstream_request, data, true);\n  waitForNextUpstreamRequest();\n\n  // Send the response headers.\n  upstream_request_->encodeHeaders(default_response_headers_, false);\n\n  // Now send an overly large response body. At some point, too much data will\n  // be buffered, the stream will be reset, and the connection will disconnect.\n  fake_upstreams_[0]->set_allow_unexpected_disconnects(true);\n  upstream_request_->encodeData(1024 * 65, false);\n  if (upstreamProtocol() == FakeHttpConnection::Type::HTTP1) {\n    ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());\n  } else {\n    ASSERT_TRUE(upstream_request_->waitForReset());\n    ASSERT_TRUE(fake_upstream_connection_->close());\n    ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());\n  }\n\n  response->waitForEndStream();\n  EXPECT_TRUE(response->complete());\n  EXPECT_EQ(\"500\", response->headers().Status()->value().getStringView());\n  EXPECT_THAT(waitForAccessLog(access_log_name_), HasSubstr(\"500\"));\n  test_server_->waitForCounterEq(\"http.config_test.downstream_rq_5xx\", 1);\n}\n\nTEST_P(ProtocolIntegrationTest, EnvoyHandling100Continue) { testEnvoyHandling100Continue(); }\n\nTEST_P(ProtocolIntegrationTest, EnvoyHandlingDuplicate100Continue) {\n  testEnvoyHandling100Continue(true);\n}\n\nTEST_P(ProtocolIntegrationTest, EnvoyProxyingEarly100Continue) {\n  testEnvoyProxying100Continue(true);\n}\n\nTEST_P(ProtocolIntegrationTest, EnvoyProxyingLate100Continue) {\n  testEnvoyProxying100Continue(false);\n}\n\nTEST_P(ProtocolIntegrationTest, TwoRequests) { testTwoRequests(); }\n\nTEST_P(ProtocolIntegrationTest, TwoRequestsWithForcedBackup) { testTwoRequests(true); }\n\nTEST_P(DownstreamProtocolIntegrationTest, ValidZeroLengthContent) {\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  Http::TestHeaderMapImpl request_headers{{\":method\", \"POST\"},\n                                          {\":path\", \"/test/long/url\"},\n                                          {\":scheme\", \"http\"},\n                                          {\":authority\", \"host\"},\n                                          {\"content-length\", \"0\"}};\n  auto response = sendRequestAndWaitForResponse(request_headers, 0, default_response_headers_, 0);\n\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().Status()->value().getStringView());\n}\n\nTEST_P(DownstreamProtocolIntegrationTest, InvalidContentLength) {\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  auto encoder_decoder =\n      codec_client_->startRequest(Http::TestHeaderMapImpl{{\":method\", \"POST\"},\n                                                          {\":path\", \"/test/long/url\"},\n                                                          {\":authority\", \"host\"},\n                                                          {\"content-length\", \"-1\"}});\n  auto response = std::move(encoder_decoder.second);\n\n  codec_client_->waitForDisconnect();\n\n  if (downstream_protocol_ == Http::CodecClient::Type::HTTP1) {\n    ASSERT_TRUE(response->complete());\n    EXPECT_EQ(\"400\", response->headers().Status()->value().getStringView());\n  } else {\n    ASSERT_TRUE(response->reset());\n    EXPECT_EQ(Http::StreamResetReason::ConnectionTermination, response->reset_reason());\n  }\n}\n\n// TODO(PiotrSikora): move this HTTP/2 only variant to http2_integration_test.cc.\nTEST_P(DownstreamProtocolIntegrationTest, InvalidContentLengthAllowed) {\n  config_helper_.addConfigModifier(\n      [](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager& hcm)\n          -> void {\n        hcm.mutable_http2_protocol_options()->set_stream_error_on_invalid_http_messaging(true);\n      });\n\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  auto encoder_decoder =\n      codec_client_->startRequest(Http::TestHeaderMapImpl{{\":method\", \"POST\"},\n                                                          {\":path\", \"/test/long/url\"},\n                                                          {\":authority\", \"host\"},\n                                                          {\"content-length\", \"-1\"}});\n  auto response = std::move(encoder_decoder.second);\n\n  if (downstream_protocol_ == Http::CodecClient::Type::HTTP1) {\n    codec_client_->waitForDisconnect();\n  } else {\n    response->waitForReset();\n    codec_client_->close();\n  }\n\n  if (downstream_protocol_ == Http::CodecClient::Type::HTTP1) {\n    ASSERT_TRUE(response->complete());\n    EXPECT_EQ(\"400\", response->headers().Status()->value().getStringView());\n  } else {\n    ASSERT_TRUE(response->reset());\n    EXPECT_EQ(Http::StreamResetReason::RemoteReset, response->reset_reason());\n  }\n}\n\nTEST_P(DownstreamProtocolIntegrationTest, MultipleContentLengths) {\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  auto encoder_decoder =\n      codec_client_->startRequest(Http::TestHeaderMapImpl{{\":method\", \"POST\"},\n                                                          {\":path\", \"/test/long/url\"},\n                                                          {\":authority\", \"host\"},\n                                                          {\"content-length\", \"3,2\"}});\n  auto response = std::move(encoder_decoder.second);\n\n  codec_client_->waitForDisconnect();\n\n  if (downstream_protocol_ == Http::CodecClient::Type::HTTP1) {\n    ASSERT_TRUE(response->complete());\n    EXPECT_EQ(\"400\", response->headers().Status()->value().getStringView());\n  } else {\n    ASSERT_TRUE(response->reset());\n    EXPECT_EQ(Http::StreamResetReason::ConnectionTermination, response->reset_reason());\n  }\n}\n\n// TODO(PiotrSikora): move this HTTP/2 only variant to http2_integration_test.cc.\nTEST_P(DownstreamProtocolIntegrationTest, MultipleContentLengthsAllowed) {\n  config_helper_.addConfigModifier(\n      [](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager& hcm)\n          -> void {\n        hcm.mutable_http2_protocol_options()->set_stream_error_on_invalid_http_messaging(true);\n      });\n\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  auto encoder_decoder =\n      codec_client_->startRequest(Http::TestHeaderMapImpl{{\":method\", \"POST\"},\n                                                          {\":path\", \"/test/long/url\"},\n                                                          {\":authority\", \"host\"},\n                                                          {\"content-length\", \"3,2\"}});\n  auto response = std::move(encoder_decoder.second);\n\n  if (downstream_protocol_ == Http::CodecClient::Type::HTTP1) {\n    codec_client_->waitForDisconnect();\n  } else {\n    response->waitForReset();\n    codec_client_->close();\n  }\n\n  if (downstream_protocol_ == Http::CodecClient::Type::HTTP1) {\n    ASSERT_TRUE(response->complete());\n    EXPECT_EQ(\"400\", response->headers().Status()->value().getStringView());\n  } else {\n    ASSERT_TRUE(response->reset());\n    EXPECT_EQ(Http::StreamResetReason::RemoteReset, response->reset_reason());\n  }\n}\n\nTEST_P(DownstreamProtocolIntegrationTest, HeadersOnlyFilterEncoding) {\n  config_helper_.addFilter(R\"EOF(\nname: encode-headers-only\n)EOF\");\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  auto response =\n      codec_client_->makeRequestWithBody(Http::TestHeaderMapImpl{{\":method\", \"GET\"},\n                                                                 {\":path\", \"/test/long/url\"},\n                                                                 {\":scheme\", \"http\"},\n                                                                 {\":authority\", \"host\"}},\n                                         128);\n  waitForNextUpstreamRequest();\n  upstream_request_->encodeHeaders(Http::TestHeaderMapImpl{{\":status\", \"503\"}}, false);\n  response->waitForEndStream();\n  EXPECT_TRUE(upstream_request_->waitForEndStream(*dispatcher_));\n  if (upstreamProtocol() == FakeHttpConnection::Type::HTTP1) {\n    ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());\n  } else {\n    ASSERT_TRUE(upstream_request_->waitForReset());\n    ASSERT_TRUE(fake_upstream_connection_->close());\n    ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());\n  }\n\n  EXPECT_TRUE(response->complete());\n  EXPECT_EQ(\"503\", response->headers().Status()->value().getStringView());\n  EXPECT_EQ(0, response->body().size());\n}\n\nTEST_P(DownstreamProtocolIntegrationTest, HeadersOnlyFilterDecoding) {\n  config_helper_.addFilter(R\"EOF(\nname: decode-headers-only\n)EOF\");\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  auto response =\n      codec_client_->makeRequestWithBody(Http::TestHeaderMapImpl{{\":method\", \"POST\"},\n                                                                 {\":path\", \"/test/long/url\"},\n                                                                 {\":scheme\", \"http\"},\n                                                                 {\":authority\", \"host\"}},\n                                         128);\n  waitForNextUpstreamRequest();\n  upstream_request_->encodeHeaders(Http::TestHeaderMapImpl{{\":status\", \"503\"}}, false);\n  upstream_request_->encodeData(128, true);\n  response->waitForEndStream();\n\n  EXPECT_TRUE(response->complete());\n  EXPECT_EQ(\"503\", response->headers().Status()->value().getStringView());\n  EXPECT_EQ(128, response->body().size());\n}\n\nTEST_P(DownstreamProtocolIntegrationTest, HeadersOnlyFilterEncodingIntermediateFilters) {\n  config_helper_.addFilter(R\"EOF(\nname: passthrough-filter\n)EOF\");\n  config_helper_.addFilter(R\"EOF(\nname: encode-headers-only\n)EOF\");\n  config_helper_.addFilter(R\"EOF(\nname: passthrough-filter\n)EOF\");\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  auto response =\n      codec_client_->makeRequestWithBody(Http::TestHeaderMapImpl{{\":method\", \"GET\"},\n                                                                 {\":path\", \"/test/long/url\"},\n                                                                 {\":scheme\", \"http\"},\n                                                                 {\":authority\", \"host\"}},\n                                         128);\n  waitForNextUpstreamRequest();\n  upstream_request_->encodeHeaders(Http::TestHeaderMapImpl{{\":status\", \"503\"}}, false);\n  response->waitForEndStream();\n  if (upstreamProtocol() == FakeHttpConnection::Type::HTTP1) {\n    ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());\n  } else {\n    ASSERT_TRUE(upstream_request_->waitForReset());\n    ASSERT_TRUE(fake_upstream_connection_->close());\n    ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());\n  }\n\n  EXPECT_TRUE(response->complete());\n  EXPECT_EQ(\"503\", response->headers().Status()->value().getStringView());\n  EXPECT_EQ(0, response->body().size());\n}\n\nTEST_P(DownstreamProtocolIntegrationTest, HeadersOnlyFilterDecodingIntermediateFilters) {\n  config_helper_.addFilter(R\"EOF(\nname: passthrough-filter\n)EOF\");\n  config_helper_.addFilter(R\"EOF(\nname: decode-headers-only\n)EOF\");\n  config_helper_.addFilter(R\"EOF(\nname: passthrough-filter\n)EOF\");\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  auto response =\n      codec_client_->makeRequestWithBody(Http::TestHeaderMapImpl{{\":method\", \"POST\"},\n                                                                 {\":path\", \"/test/long/url\"},\n                                                                 {\":scheme\", \"http\"},\n                                                                 {\":authority\", \"host\"}},\n                                         128);\n  waitForNextUpstreamRequest();\n  upstream_request_->encodeHeaders(Http::TestHeaderMapImpl{{\":status\", \"503\"}}, false);\n  upstream_request_->encodeData(128, true);\n  response->waitForEndStream();\n\n  EXPECT_TRUE(response->complete());\n  EXPECT_EQ(\"503\", response->headers().Status()->value().getStringView());\n  EXPECT_EQ(128, response->body().size());\n}\n\n// Verifies behavior when request data is encoded after the request has been\n// turned into a headers-only request and the response has already begun.\nTEST_P(DownstreamProtocolIntegrationTest, HeadersOnlyFilterInterleaved) {\n  config_helper_.addFilter(R\"EOF(\nname: decode-headers-only\n)EOF\");\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  // First send the request headers. The filter should turn this into a header-only\n  // request.\n  auto encoder_decoder =\n      codec_client_->startRequest(Http::TestHeaderMapImpl{{\":method\", \"GET\"},\n                                                          {\":path\", \"/test/long/url\"},\n                                                          {\":scheme\", \"http\"},\n                                                          {\":authority\", \"host\"}});\n  request_encoder_ = &encoder_decoder.first;\n  auto response = std::move(encoder_decoder.second);\n\n  // Wait for the upstream request and begin sending a response with end_stream = false.\n  waitForNextUpstreamRequest();\n  upstream_request_->encodeHeaders(Http::TestHeaderMapImpl{{\":status\", \"503\"}}, false);\n\n  // Simulate additional data after the request has been turned into a headers only request.\n  Buffer::OwnedImpl data(std::string(128, 'a'));\n  request_encoder_->encodeData(data, false);\n\n  // End the response.\n  upstream_request_->encodeData(128, true);\n\n  response->waitForEndStream();\n  EXPECT_TRUE(response->complete());\n  EXPECT_EQ(\"503\", response->headers().Status()->value().getStringView());\n  EXPECT_EQ(0, upstream_request_->body().length());\n}\n\nTEST_P(DownstreamProtocolIntegrationTest, LargeRequestHeadersRejected) {\n  testLargeRequestHeaders(95, 60);\n}\n\nTEST_P(DownstreamProtocolIntegrationTest, LargeRequestHeadersAccepted) {\n  testLargeRequestHeaders(95, 96);\n}\n\n// Tests StopAllIterationAndBuffer. Verifies decode-headers-return-stop-all-filter calls decodeData\n// once after iteration is resumed.\nTEST_P(DownstreamProtocolIntegrationTest, testDecodeHeadersReturnsStopAll) {\n  config_helper_.addFilter(R\"EOF(\nname: call-decodedata-once-filter\n)EOF\");\n  config_helper_.addFilter(R\"EOF(\nname: decode-headers-return-stop-all-filter\n)EOF\");\n  config_helper_.addFilter(R\"EOF(\nname: passthrough-filter\n)EOF\");\n\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  // Sends a request with headers and data.\n  changeHeadersForStopAllTests(default_request_headers_, false);\n  auto encoder_decoder = codec_client_->startRequest(default_request_headers_);\n  request_encoder_ = &encoder_decoder.first;\n  auto response = std::move(encoder_decoder.second);\n  for (int i = 0; i < count_ - 1; i++) {\n    codec_client_->sendData(*request_encoder_, size_, false);\n  }\n  // Sleeps for 1s in order to be consistent with testDecodeHeadersReturnsStopAllWatermark.\n  sleep(1);\n  codec_client_->sendData(*request_encoder_, size_, true);\n  waitForNextUpstreamRequest();\n\n  upstream_request_->encodeHeaders(default_response_headers_, true);\n  response->waitForEndStream();\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(count_ * size_ + added_decoded_data_size_, upstream_request_->bodyLength());\n  EXPECT_EQ(true, upstream_request_->complete());\n\n  // Sends a request with headers, data, and trailers.\n  auto encoder_decoder_2 = codec_client_->startRequest(default_request_headers_);\n  request_encoder_ = &encoder_decoder_2.first;\n  response = std::move(encoder_decoder_2.second);\n  for (int i = 0; i < count_; i++) {\n    codec_client_->sendData(*request_encoder_, size_, false);\n  }\n  Http::TestHeaderMapImpl request_trailers{{\"trailer\", \"trailer\"}};\n  codec_client_->sendTrailers(*request_encoder_, request_trailers);\n  waitForNextUpstreamRequest();\n\n  upstream_request_->encodeHeaders(default_response_headers_, true);\n  response->waitForEndStream();\n  verifyUpStreamRequestAfterStopAllFilter();\n}\n\n// Tests StopAllIterationAndWatermark. decode-headers-return-stop-all-watermark-filter sets buffer\n// limit to 100. Verifies data pause when limit is reached, and resume after iteration continues.\nTEST_P(DownstreamProtocolIntegrationTest, testDecodeHeadersReturnsStopAllWatermark) {\n  config_helper_.addFilter(R\"EOF(\nname: decode-headers-return-stop-all-filter\n)EOF\");\n  config_helper_.addFilter(R\"EOF(\nname: passthrough-filter\n)EOF\");\n\n  // Sets initial stream window to min value to make the client sensitive to a low watermark.\n  config_helper_.addConfigModifier(\n      [&](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager& hcm)\n          -> void {\n        hcm.mutable_http2_protocol_options()->mutable_initial_stream_window_size()->set_value(\n            Http::Http2Settings::MIN_INITIAL_STREAM_WINDOW_SIZE);\n      });\n\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  // Sends a request with headers and data.\n  changeHeadersForStopAllTests(default_request_headers_, true);\n  auto encoder_decoder = codec_client_->startRequest(default_request_headers_);\n  request_encoder_ = &encoder_decoder.first;\n  auto response = std::move(encoder_decoder.second);\n  for (int i = 0; i < count_ - 1; i++) {\n    codec_client_->sendData(*request_encoder_, size_, false);\n  }\n  // Gives buffer 1s to react to buffer limit.\n  sleep(1);\n  codec_client_->sendData(*request_encoder_, size_, true);\n  waitForNextUpstreamRequest();\n\n  upstream_request_->encodeHeaders(default_response_headers_, true);\n  response->waitForEndStream();\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(count_ * size_ + added_decoded_data_size_, upstream_request_->bodyLength());\n  EXPECT_EQ(true, upstream_request_->complete());\n\n  // Sends a request with headers, data, and trailers.\n  auto encoder_decoder_2 = codec_client_->startRequest(default_request_headers_);\n  request_encoder_ = &encoder_decoder_2.first;\n  response = std::move(encoder_decoder_2.second);\n  for (int i = 0; i < count_ - 1; i++) {\n    codec_client_->sendData(*request_encoder_, size_, false);\n  }\n  // Gives buffer 1s to react to buffer limit.\n  sleep(1);\n  codec_client_->sendData(*request_encoder_, size_, false);\n  Http::TestHeaderMapImpl request_trailers{{\"trailer\", \"trailer\"}};\n  codec_client_->sendTrailers(*request_encoder_, request_trailers);\n  waitForNextUpstreamRequest();\n\n  upstream_request_->encodeHeaders(default_response_headers_, true);\n  response->waitForEndStream();\n  verifyUpStreamRequestAfterStopAllFilter();\n}\n\n// Test two filters that return StopAllIterationAndBuffer back-to-back.\nTEST_P(DownstreamProtocolIntegrationTest, testTwoFiltersDecodeHeadersReturnsStopAll) {\n  config_helper_.addFilter(R\"EOF(\nname: decode-headers-return-stop-all-filter\n)EOF\");\n  config_helper_.addFilter(R\"EOF(\nname: decode-headers-return-stop-all-filter\n)EOF\");\n  config_helper_.addFilter(R\"EOF(\nname: passthrough-filter\n)EOF\");\n\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  // Sends a request with headers and data.\n  changeHeadersForStopAllTests(default_request_headers_, false);\n  auto encoder_decoder = codec_client_->startRequest(default_request_headers_);\n  request_encoder_ = &encoder_decoder.first;\n  auto response = std::move(encoder_decoder.second);\n  for (int i = 0; i < count_ - 1; i++) {\n    codec_client_->sendData(*request_encoder_, size_, false);\n  }\n  codec_client_->sendData(*request_encoder_, size_, true);\n  waitForNextUpstreamRequest();\n\n  upstream_request_->encodeHeaders(default_response_headers_, true);\n  response->waitForEndStream();\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(count_ * size_ + added_decoded_data_size_, upstream_request_->bodyLength());\n  EXPECT_EQ(true, upstream_request_->complete());\n\n  // Sends a request with headers, data, and trailers.\n  auto encoder_decoder_2 = codec_client_->startRequest(default_request_headers_);\n  request_encoder_ = &encoder_decoder_2.first;\n  response = std::move(encoder_decoder_2.second);\n  for (int i = 0; i < count_; i++) {\n    codec_client_->sendData(*request_encoder_, size_, false);\n  }\n  Http::TestHeaderMapImpl request_trailers{{\"trailer\", \"trailer\"}};\n  codec_client_->sendTrailers(*request_encoder_, request_trailers);\n  waitForNextUpstreamRequest();\n\n  upstream_request_->encodeHeaders(default_response_headers_, true);\n  response->waitForEndStream();\n  verifyUpStreamRequestAfterStopAllFilter();\n}\n\n// Tests encodeHeaders() returns StopAllIterationAndBuffer.\nTEST_P(DownstreamProtocolIntegrationTest, testEncodeHeadersReturnsStopAll) {\n  config_helper_.addFilter(R\"EOF(\nname: encode-headers-return-stop-all-filter\n)EOF\");\n  config_helper_.addConfigModifier(\n      [&](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager& hcm)\n          -> void { hcm.mutable_http2_protocol_options()->set_allow_metadata(true); });\n\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  // Upstream responds with headers, data and trailers.\n  auto response = codec_client_->makeRequestWithBody(default_request_headers_, 10);\n  waitForNextUpstreamRequest();\n\n  changeHeadersForStopAllTests(default_response_headers_, false);\n  upstream_request_->encodeHeaders(default_response_headers_, false);\n  for (int i = 0; i < count_ - 1; i++) {\n    upstream_request_->encodeData(size_, false);\n  }\n  // Sleeps for 1s in order to be consistent with testEncodeHeadersReturnsStopAllWatermark.\n  sleep(1);\n  upstream_request_->encodeData(size_, false);\n  Http::TestHeaderMapImpl response_trailers{{\"response\", \"trailer\"}};\n  upstream_request_->encodeTrailers(response_trailers);\n\n  response->waitForEndStream();\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(count_ * size_ + added_decoded_data_size_, response->body().size());\n}\n\n// Tests encodeHeaders() returns StopAllIterationAndWatermark.\nTEST_P(DownstreamProtocolIntegrationTest, testEncodeHeadersReturnsStopAllWatermark) {\n  config_helper_.addFilter(R\"EOF(\nname: encode-headers-return-stop-all-filter\n)EOF\");\n  config_helper_.addConfigModifier(\n      [&](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager& hcm)\n          -> void { hcm.mutable_http2_protocol_options()->set_allow_metadata(true); });\n\n  // Sets initial stream window to min value to make the upstream sensitive to a low watermark.\n  config_helper_.addConfigModifier(\n      [&](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager& hcm)\n          -> void {\n        hcm.mutable_http2_protocol_options()->mutable_initial_stream_window_size()->set_value(\n            Http::Http2Settings::MIN_INITIAL_STREAM_WINDOW_SIZE);\n      });\n\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  // Upstream responds with headers, data and trailers.\n  auto response = codec_client_->makeRequestWithBody(default_request_headers_, 10);\n  waitForNextUpstreamRequest();\n\n  changeHeadersForStopAllTests(default_response_headers_, true);\n  upstream_request_->encodeHeaders(default_response_headers_, false);\n  for (int i = 0; i < count_ - 1; i++) {\n    upstream_request_->encodeData(size_, false);\n  }\n  // Gives buffer 1s to react to buffer limit.\n  sleep(1);\n  upstream_request_->encodeData(size_, false);\n  Http::TestHeaderMapImpl response_trailers{{\"response\", \"trailer\"}};\n  upstream_request_->encodeTrailers(response_trailers);\n\n  response->waitForEndStream();\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(count_ * size_ + added_decoded_data_size_, response->body().size());\n}\n\n// Per https://github.com/envoyproxy/envoy/issues/7488 make sure we don't\n// combine set-cookie headers\nTEST_P(ProtocolIntegrationTest, MultipleSetCookies) {\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  Http::TestHeaderMapImpl response_headers{\n      {\":status\", \"200\"}, {\"set-cookie\", \"foo\"}, {\"set-cookie\", \"bar\"}};\n\n  auto response = sendRequestAndWaitForResponse(default_request_headers_, 0, response_headers, 0);\n\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().Status()->value().getStringView());\n\n  std::vector<absl::string_view> out;\n  Http::HeaderUtility::getAllOfHeader(response->headers(), \"set-cookie\", out);\n  ASSERT_EQ(out.size(), 2);\n  ASSERT_EQ(out[0], \"foo\");\n  ASSERT_EQ(out[1], \"bar\");\n}\n\n// Resets the downstream stream immediately and verifies that we clean up everything.\nTEST_P(ProtocolIntegrationTest, TestDownstreamResetIdleTimeout) {\n  config_helper_.setDownstreamHttpIdleTimeout(std::chrono::milliseconds(100));\n\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  auto encoder_decoder = codec_client_->startRequest(default_request_headers_);\n\n  EXPECT_TRUE(fake_upstreams_[0]->waitForHttpConnection(*dispatcher_, fake_upstream_connection_,\n                                                        TestUtility::DefaultTimeout,\n                                                        max_request_headers_kb_));\n\n  EXPECT_TRUE(fake_upstream_connection_->waitForNewStream(*dispatcher_, upstream_request_));\n\n  if (downstreamProtocol() == Http::CodecClient::Type::HTTP1) {\n    codec_client_->close();\n  } else {\n    codec_client_->sendReset(encoder_decoder.first);\n  }\n\n  if (upstreamProtocol() == FakeHttpConnection::Type::HTTP1) {\n    ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());\n  } else {\n    ASSERT_TRUE(upstream_request_->waitForReset());\n    ASSERT_TRUE(fake_upstream_connection_->close());\n    ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());\n  }\n\n  codec_client_->waitForDisconnect();\n}\n\n// For tests which focus on downstream-to-Envoy behavior, and don't need to be\n// run with both HTTP/1 and HTTP/2 upstreams.\nINSTANTIATE_TEST_SUITE_P(Protocols, DownstreamProtocolIntegrationTest,\n                         testing::ValuesIn(HttpProtocolIntegrationTest::getProtocolTestParams(\n                             {Http::CodecClient::Type::HTTP1, Http::CodecClient::Type::HTTP2},\n                             {FakeHttpConnection::Type::HTTP1})),\n                         HttpProtocolIntegrationTest::protocolTestParamsToString);\n\nINSTANTIATE_TEST_SUITE_P(Protocols, ProtocolIntegrationTest,\n                         testing::ValuesIn(HttpProtocolIntegrationTest::getProtocolTestParams()),\n                         HttpProtocolIntegrationTest::protocolTestParamsToString);\n\n} // namespace Envoy\n"], "fixing_code": ["Version history\n---------------\n\n1.12.0 (pending)\n================\n* access log: added :ref:`buffering <envoy_api_field_config.accesslog.v2.CommonGrpcAccessLogConfig.buffer_size_bytes>` and :ref:`periodical flushing <envoy_api_field_config.accesslog.v2.CommonGrpcAccessLogConfig.buffer_flush_interval>` support to gRPC access logger. Defaults to 16KB buffer and flushing every 1 second.\n* access log: added DOWNSTREAM_DIRECT_REMOTE_ADDRESS and DOWNSTREAM_DIRECT_REMOTE_ADDRESS_WITHOUT_PORT :ref:`access log formatters <config_access_log_format>` and gRPC access logger.\n* access log: gRPC Access Log Service (ALS) support added for :ref:`TCP access logs <envoy_api_msg_config.accesslog.v2.TcpGrpcAccessLogConfig>`.\n* access log: reintroduce :ref:`filesystem <filesystem_stats>` stats and added the `write_failed` counter to track failed log writes\n* admin: added ability to configure listener :ref:`socket options <envoy_api_field_config.bootstrap.v2.Admin.socket_options>`.\n* admin: added config dump support for Secret Discovery Service :ref:`SecretConfigDump <envoy_api_msg_admin.v2alpha.SecretsConfigDump>`.\n* api: added ::ref:`set_node_on_first_message_only <envoy_api_field_core.ApiConfigSource.set_node_on_first_message_only>` option to omit the node identifier from the subsequent discovery requests on the same stream.\n* buffer filter: the buffer filter populates content-length header if not present, behavior can be disabled using the runtime feature `envoy.reloadable_features.buffer_filter_populate_content_length`.\n* config: added support for :ref:`delta xDS <arch_overview_dynamic_config_delta>` (including ADS) delivery\n* config: enforcing that terminal filters (e.g. HttpConnectionManager for L4, router for L7) be the last in their respective filter chains.\n* config: added access log :ref:`extension filter<envoy_api_field_config.filter.accesslog.v2.AccessLogFilter.extension_filter>`.\n* config: added support for :option:`--reject-unknown-dynamic-fields`, providing independent control\n  over whether unknown fields are rejected in static and dynamic configuration. By default, unknown\n  fields in static configuration are rejected and are allowed in dynamic configuration. Warnings\n  are logged for the first use of any unknown field and these occurrences are counted in the\n  :ref:`server.static_unknown_fields <server_statistics>` and :ref:`server.dynamic_unknown_fields\n  <server_statistics>` statistics.\n* config: async data access for local and remote data source.\n* config: changed the default value of :ref:`initial_fetch_timeout <envoy_api_field_core.ConfigSource.initial_fetch_timeout>` from 0s to 15s. This is a change in behaviour in the sense that Envoy will move to the next initialization phase, even if the first config is not delivered in 15s. Refer to :ref:`initialization process <arch_overview_initialization>` for more details.\n* config: added stat :ref:`init_fetch_timeout <config_cluster_manager_cds>`.\n* dns: added support for configuring :ref:`dns_failure_refresh_rate <envoy_api_field_Cluster.dns_failure_refresh_rate>` to set the DNS refresh rate during failures.\n* ext_authz: added :ref:`configurable ability <envoy_api_field_config.filter.http.ext_authz.v2.ExtAuthz.metadata_context_namespaces>` to send dynamic metadata to the `ext_authz` service.\n* ext_authz: added tracing to the HTTP client.\n* fault: added overrides for default runtime keys in :ref:`HTTPFault <envoy_api_msg_config.filter.http.fault.v2.HTTPFault>` filter.\n* grpc: added :ref:`AWS IAM grpc credentials extension <envoy_api_file_envoy/config/grpc_credential/v2alpha/aws_iam.proto>` for AWS-managed xDS.\n* grpc-json: added support for :ref:`ignoring unknown query parameters<envoy_api_field_config.filter.http.transcoder.v2.GrpcJsonTranscoder.ignore_unknown_query_parameters>`.\n* grpc-json: added support for :ref:`the grpc-status-details-bin header<envoy_api_field_config.filter.http.transcoder.v2.GrpcJsonTranscoder.convert_grpc_status>`.\n* header to metadata: added :ref:`PROTOBUF_VALUE <envoy_api_enum_value_config.filter.http.header_to_metadata.v2.Config.ValueType.PROTOBUF_VALUE>` and :ref:`ValueEncode <envoy_api_enum_config.filter.http.header_to_metadata.v2.Config.ValueEncode>` to support protobuf Value and Base64 encoding.\n* http: added the ability to reject HTTP/1.1 requests with invalid HTTP header values, using the runtime feature `envoy.reloadable_features.strict_header_validation`.\n* http: changed Envoy to forward existing x-forwarded-proto from upstream trusted proxies. Guarded by `envoy.reloadable_features.trusted_forwarded_proto` which defaults true.\n* http: added the ability to configure the behavior of the server response header, via the :ref:`server_header_transformation<envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.server_header_transformation>` field.\n* http: added the ability to :ref:`merge adjacent slashes<envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.merge_slashes>` in the path.\n* http: :ref:`AUTO <envoy_api_enum_value_config.filter.network.http_connection_manager.v2.HttpConnectionManager.CodecType.AUTO>` codec protocol inference now requires the H2 magic bytes to be the first bytes transmitted by a downstream client.\n* http: remove h2c upgrade headers for HTTP/1 as h2c upgrades are currently not supported.\n* http: absolute URL support is now on by default. The prior behavior can be reinstated by setting :ref:`allow_absolute_url <envoy_api_field_core.Http1ProtocolOptions.allow_absolute_url>` to false.\n* listeners: added :ref:`continue_on_listener_filters_timeout <envoy_api_field_Listener.continue_on_listener_filters_timeout>` to configure whether a listener will still create a connection when listener filters time out.\n* listeners: added :ref:`HTTP inspector listener filter <config_listener_filters_http_inspector>`.\n* lua: extended `httpCall()` and `respond()` APIs to accept headers with entry values that can be a string or table of strings.\n* lua: extended `dynamicMetadata:set()` to allow setting complex values\n* metrics_service: added support for flushing histogram buckets.\n* outlier_detector: added :ref:`support for the grpc-status response header <arch_overview_outlier_detection_grpc>` by mapping it to HTTP status. Guarded by envoy.reloadable_features.outlier_detection_support_for_grpc_status which defaults to true.\n* performance: new buffer implementation enabled by default (to disable add \"--use-libevent-buffers 1\" to the command-line arguments when starting Envoy).\n* performance: stats symbol table implementation (disabled by default; to test it, add \"--use-fake-symbol-table 0\" to the command-line arguments when starting Envoy).\n* rbac: added support for DNS SAN as :ref:`principal_name <envoy_api_field_config.rbac.v2.Principal.Authenticated.principal_name>`.\n* redis: added :ref:`enable_command_stats <envoy_api_field_config.filter.network.redis_proxy.v2.RedisProxy.ConnPoolSettings.enable_command_stats>` to enable :ref:`per command statistics <arch_overview_redis_cluster_command_stats>` for upstream clusters.\n* redis: added :ref:`read_policy <envoy_api_field_config.filter.network.redis_proxy.v2.RedisProxy.ConnPoolSettings.read_policy>` to allow reading from redis replicas for Redis Cluster deployments.\n* redis: fix a bug where the redis health checker ignored the upstream auth password.\n* redis: enable_hashtaging is always enabled when the upstream uses open source Redis cluster protocol.\n* regex: introduce new :ref:`RegexMatcher <envoy_api_msg_type.matcher.RegexMatcher>` type that\n  provides a safe regex implementation for untrusted user input. This type is now used in all\n  configuration that processes user provided input. See :ref:`deprecated configuration details\n  <deprecated>` for more information.\n* rbac: added conditions to the policy, see :ref:`condition <envoy_api_field_config.rbac.v2.Policy.condition>`.\n* router: added :ref:`rq_retry_skipped_request_not_complete <config_http_filters_router_stats>` counter stat to router stats.\n* router: :ref:`Scoped routing <arch_overview_http_routing_route_scope>` is supported.\n* router: added new :ref:`retriable-headers <config_http_filters_router_x-envoy-retry-on>` retry policy. Retries can now be configured to trigger by arbitrary response header matching.\n* router: added :ref:`respect_expected_rq_timeout <envoy_api_field_config.filter.http.router.v2.Router.respect_expected_rq_timeout>` that instructs ingress Envoy to respect :ref:`config_http_filters_router_x-envoy-expected-rq-timeout-ms` header, populated by egress Envoy, when deriving timeout for upstream cluster.\n* router: added new :ref:`retriable request headers <envoy_api_field_route.RetryPolicy.retriable_request_headers>` to retry policies. Retries can now be configured to only trigger on request header match.\n* router check tool: add coverage reporting & enforcement.\n* router check tool: add comprehensive coverage reporting.\n* router check tool: add deprecated field check.\n* router check tool: add flag for only printing results of failed tests.\n* router check tool: add support for outputting missing tests in the detailed coverage report.\n* runtime: allow for the ability to parse boolean values.\n* runtime: allow for the ability to parse integers as double values and vice-versa.\n* server: added a post initialization lifecycle event, in addition to the existing startup and shutdown events.\n* server: added :ref:`per-handler listener stats <config_listener_stats_per_handler>` and\n  :ref:`per-worker watchdog stats <operations_performance_watchdog>` to help diagnosing event\n  loop imbalance and general performance issues.\n* thrift_proxy: fix crashing bug on invalid transport/protocol framing\n* tls: added verification of IP address SAN fields in certificates against configured SANs in the\n* tracing: added support to the Zipkin reporter for sending list of spans as Zipkin JSON v2 and protobuf message over HTTP.\n  certificate validation context.\n* tracing: added tags for gRPC response status and meesage.\n* tracing: added :ref:`max_path_tag_length <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.tracing>` to support customizing the length of the request path included in the extracted `http.url <https://github.com/opentracing/specification/blob/master/semantic_conventions.md#standard-span-tags-and-log-fields>` tag.\n* upstream: added :ref:`an option <envoy_api_field_Cluster.CommonLbConfig.close_connections_on_host_set_change>` that allows draining HTTP, TCP connection pools on cluster membership change.\n* upstream: added network filter chains to upstream connections, see :ref:`filters<envoy_api_field_Cluster.filters>`.\n* upstream: added new :ref:`failure-percentage based outlier detection<arch_overview_outlier_detection_failure_percentage>` mode.\n* upstream: use p2c to select hosts for least-requests load balancers if all host weights are the same, even in cases where weights are not equal to 1.\n* upstream: added :ref:`fail_traffic_on_panic <envoy_api_field_Cluster.CommonLbConfig.ZoneAwareLbConfig.fail_traffic_on_panic>` to allow failing all requests to a cluster during panic state.\n* zookeeper: parse responses and emit latency stats.\n\n1.11.2 (October 8, 2019)\n========================\n* http: fixed CVE-2019-15226 by adding a cached byte size in HeaderMap.\n\n1.11.1 (August 13, 2019)\n========================\n* http: added mitigation of client initiated attacks that result in flooding of the downstream HTTP/2 connections. Those attacks can be logged at the \"warning\" level when the runtime feature `http.connection_manager.log_flood_exception` is enabled. The runtime setting defaults to disabled to avoid log spam when under attack.\n* http: added :ref:`inbound_empty_frames_flood <config_http_conn_man_stats_per_codec>` counter stat to the HTTP/2 codec stats, for tracking number of connections terminated for exceeding the limit on consecutive inbound frames with an empty payload and no end stream flag. The limit is configured by setting the :ref:`max_consecutive_inbound_frames_with_empty_payload config setting <envoy_api_field_core.Http2ProtocolOptions.max_consecutive_inbound_frames_with_empty_payload>`.\n  Runtime feature `envoy.reloadable_features.http2_protocol_options.max_consecutive_inbound_frames_with_empty_payload` overrides :ref:`max_consecutive_inbound_frames_with_empty_payload setting <envoy_api_field_core.Http2ProtocolOptions.max_consecutive_inbound_frames_with_empty_payload>`. Large override value (i.e. 2147483647) effectively disables mitigation of inbound frames with empty payload.\n* http: added :ref:`inbound_priority_frames_flood <config_http_conn_man_stats_per_codec>` counter stat to the HTTP/2 codec stats, for tracking number of connections terminated for exceeding the limit on inbound PRIORITY frames. The limit is configured by setting the :ref:`max_inbound_priority_frames_per_stream config setting <envoy_api_field_core.Http2ProtocolOptions.max_inbound_priority_frames_per_stream>`.\n  Runtime feature `envoy.reloadable_features.http2_protocol_options.max_inbound_priority_frames_per_stream` overrides :ref:`max_inbound_priority_frames_per_stream setting <envoy_api_field_core.Http2ProtocolOptions.max_inbound_priority_frames_per_stream>`. Large override value effectively disables flood mitigation of inbound PRIORITY frames.\n* http: added :ref:`inbound_window_update_frames_flood <config_http_conn_man_stats_per_codec>` counter stat to the HTTP/2 codec stats, for tracking number of connections terminated for exceeding the limit on inbound WINDOW_UPDATE frames. The limit is configured by setting the :ref:`max_inbound_window_update_frames_per_data_frame_sent config setting <envoy_api_field_core.Http2ProtocolOptions.max_inbound_window_update_frames_per_data_frame_sent>`.\n  Runtime feature `envoy.reloadable_features.http2_protocol_options.max_inbound_window_update_frames_per_data_frame_sent` overrides :ref:`max_inbound_window_update_frames_per_data_frame_sent setting <envoy_api_field_core.Http2ProtocolOptions.max_inbound_window_update_frames_per_data_frame_sent>`. Large override value effectively disables flood mitigation of inbound WINDOW_UPDATE frames.\n* http: added :ref:`outbound_flood <config_http_conn_man_stats_per_codec>` counter stat to the HTTP/2 codec stats, for tracking number of connections terminated for exceeding the outbound queue limit. The limit is configured by setting the :ref:`max_outbound_frames config setting <envoy_api_field_core.Http2ProtocolOptions.max_outbound_frames>`\n  Runtime feature `envoy.reloadable_features.http2_protocol_options.max_outbound_frames` overrides :ref:`max_outbound_frames config setting <envoy_api_field_core.Http2ProtocolOptions.max_outbound_frames>`. Large override value effectively disables flood mitigation of outbound frames of all types.\n* http: added :ref:`outbound_control_flood <config_http_conn_man_stats_per_codec>` counter stat to the HTTP/2 codec stats, for tracking number of connections terminated for exceeding the outbound queue limit for PING, SETTINGS and RST_STREAM frames. The limit is configured by setting the :ref:`max_outbound_control_frames config setting <envoy_api_field_core.Http2ProtocolOptions.max_outbound_control_frames>`.\n  Runtime feature `envoy.reloadable_features.http2_protocol_options.max_outbound_control_frames` overrides :ref:`max_outbound_control_frames config setting <envoy_api_field_core.Http2ProtocolOptions.max_outbound_control_frames>`. Large override value effectively disables flood mitigation of outbound frames of types PING, SETTINGS and RST_STREAM.\n* http: enabled strict validation of HTTP/2 messaging. Previous behavior can be restored using :ref:`stream_error_on_invalid_http_messaging config setting <envoy_api_field_core.Http2ProtocolOptions.stream_error_on_invalid_http_messaging>`.\n  Runtime feature `envoy.reloadable_features.http2_protocol_options.stream_error_on_invalid_http_messaging` overrides :ref:`stream_error_on_invalid_http_messaging config setting <envoy_api_field_core.Http2ProtocolOptions.stream_error_on_invalid_http_messaging>`.\n\n1.11.0 (July 11, 2019)\n======================\n* access log: added a new field for downstream TLS session ID to file and gRPC access logger.\n* access log: added a new field for route name to file and gRPC access logger.\n* access log: added a new field for response code details in :ref:`file access logger<config_access_log_format_response_code_details>` and :ref:`gRPC access logger<envoy_api_field_data.accesslog.v2.HTTPResponseProperties.response_code_details>`.\n* access log: added several new variables for exposing information about the downstream TLS connection to :ref:`file access logger<config_access_log_format_response_code_details>` and :ref:`gRPC access logger<envoy_api_field_data.accesslog.v2.AccessLogCommon.tls_properties>`.\n* access log: added a new flag for request rejected due to failed strict header check.\n* admin: the administration interface now includes a :ref:`/ready endpoint <operations_admin_interface>` for easier readiness checks.\n* admin: extend :ref:`/runtime_modify endpoint <operations_admin_interface_runtime_modify>` to support parameters within the request body.\n* admin: the :ref:`/listener endpoint <operations_admin_interface_listeners>` now returns :ref:`listeners.proto<envoy_api_msg_admin.v2alpha.Listeners>` which includes listener names and ports.\n* admin: added host priority to :http:get:`/clusters` and :http:get:`/clusters?format=json` endpoint response\n* admin: the :ref:`/clusters endpoint <operations_admin_interface_clusters>` now shows hostname\n  for each host, useful for DNS based clusters.\n* api: track and report requests issued since last load report.\n* build: releases are built with Clang and linked with LLD.\n* config: added :ref:stats_server_version_override` <envoy_api_field_config.bootstrap.v2.Bootstrap.stats_server_version_override>` in bootstrap, that can be used to override :ref:`server.version statistic <server_statistics>`.\n* control-plane: management servers can respond with HTTP 304 to indicate that config is up to date for Envoy proxies polling a :ref:`REST API Config Type <envoy_api_field_core.ApiConfigSource.api_type>`\n* csrf: added support for whitelisting additional source origins.\n* dns: added support for getting DNS record TTL which is used by STRICT_DNS/LOGICAL_DNS cluster as DNS refresh rate.\n* dubbo_proxy: support the :ref:`dubbo proxy filter <config_network_filters_dubbo_proxy>`.\n* dynamo_request_parser: adding support for transactions. Adds check for new types of dynamodb operations (TransactWriteItems, TransactGetItems) and awareness for new types of dynamodb errors (IdempotentParameterMismatchException, TransactionCanceledException, TransactionInProgressException).\n* eds: added support to specify max time for which endpoints can be used :ref:`gRPC filter <envoy_api_msg_ClusterLoadAssignment.Policy>`.\n* eds: removed max limit for `load_balancing_weight`.\n* event: added :ref:`loop duration and poll delay statistics <operations_performance>`.\n* ext_authz: added a `x-envoy-auth-partial-body` metadata header set to `false|true` indicating if there is a partial body sent in the authorization request message.\n* ext_authz: added configurable status code that allows customizing HTTP responses on filter check status errors.\n* ext_authz: added option to `ext_authz` that allows the filter clearing route cache.\n* grpc-json: added support for :ref:`auto mapping\n  <envoy_api_field_config.filter.http.transcoder.v2.GrpcJsonTranscoder.auto_mapping>`.\n* health check: added :ref:`initial jitter <envoy_api_field_core.HealthCheck.initial_jitter>` to add jitter to the first health check in order to prevent thundering herd on Envoy startup.\n* hot restart: stats are no longer shared between hot restart parent/child via shared memory, but rather by RPC. Hot restart version incremented to 11.\n* http: added the ability to pass a URL encoded PEM encoded peer certificate chain in the\n  :ref:`config_http_conn_man_headers_x-forwarded-client-cert` header.\n* http: fixed a bug where large unbufferable responses were not tracked in stats and logs correctly.\n* http: fixed a crashing bug where gRPC local replies would cause segfaults when upstream access logging was on.\n* http: mitigated a race condition with the :ref:`delayed_close_timeout<envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.delayed_close_timeout>` where it could trigger while actively flushing a pending write buffer for a downstream connection.\n* http: added support for :ref:`preserve_external_request_id<envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.preserve_external_request_id>` that represents whether the x-request-id should not be reset on edge entry inside mesh\n* http: changed `sendLocalReply` to send percent-encoded `GrpcMessage`.\n* http: added a :ref:header_prefix` <envoy_api_field_config.bootstrap.v2.Bootstrap.header_prefix>` configuration option to allow Envoy to send and process x-custom- prefixed headers rather than x-envoy.\n* http: added :ref:`dynamic forward proxy <arch_overview_http_dynamic_forward_proxy>` support.\n* http: tracking the active stream and dumping state in Envoy crash handlers. This can be disabled by building with `--define disable_object_dump_on_signal_trace=disabled`\n* jwt_authn: make filter's parsing of JWT more flexible, allowing syntax like ``jwt=eyJhbGciOiJS...ZFnFIw,extra=7,realm=123``\n* listener: added :ref:`source IP <envoy_api_field_listener.FilterChainMatch.source_prefix_ranges>`\n  and :ref:`source port <envoy_api_field_listener.FilterChainMatch.source_ports>` filter\n  chain matching.\n* lua: exposed functions to Lua to verify digital signature.\n* original_src filter: added the :ref:`filter<config_http_filters_original_src>`.\n* outlier_detector: added configuration :ref:`outlier_detection.split_external_local_origin_errors<envoy_api_field_cluster.OutlierDetection.split_external_local_origin_errors>` to distinguish locally and externally generated errors. See :ref:`arch_overview_outlier_detection` for full details.\n* rbac: migrated from v2alpha to v2.\n* redis: add support for Redis cluster custom cluster type.\n* redis: automatically route commands using cluster slots for Redis cluster.\n* redis: added :ref:`prefix routing <envoy_api_field_config.filter.network.redis_proxy.v2.RedisProxy.prefix_routes>` to enable routing commands based on their key's prefix to different upstream.\n* redis: added :ref:`request mirror policy <envoy_api_field_config.filter.network.redis_proxy.v2.RedisProxy.PrefixRoutes.Route.request_mirror_policy>` to enable shadow traffic and/or dual writes.\n* redis: add support for zpopmax and zpopmin commands.\n* redis: added\n  :ref:`max_buffer_size_before_flush <envoy_api_field_config.filter.network.redis_proxy.v2.RedisProxy.ConnPoolSettings.max_buffer_size_before_flush>` to batch commands together until the encoder buffer hits a certain size, and\n  :ref:`buffer_flush_timeout <envoy_api_field_config.filter.network.redis_proxy.v2.RedisProxy.ConnPoolSettings.buffer_flush_timeout>` to control how quickly the buffer is flushed if it is not full.\n* redis: added auth support :ref:`downstream_auth_password <envoy_api_field_config.filter.network.redis_proxy.v2.RedisProxy.downstream_auth_password>` for downstream client authentication, and :ref:`auth_password <envoy_api_field_config.filter.network.redis_proxy.v2.RedisProtocolOptions.auth_password>` to configure authentication passwords for upstream server clusters.\n* retry: added a retry predicate that :ref:`rejects canary hosts. <envoy_api_field_route.RetryPolicy.retry_host_predicate>`\n* router: add support for configuring a :ref:`gRPC timeout offset <envoy_api_field_route.RouteAction.grpc_timeout_offset>` on incoming requests.\n* router: added ability to control retry back-off intervals via :ref:`retry policy <envoy_api_msg_route.RetryPolicy.RetryBackOff>`.\n* router: added ability to issue a hedged retry in response to a per try timeout via a :ref:`hedge policy <envoy_api_msg_route.HedgePolicy>`.\n* router: added a route name field to each http route in route.Route list\n* router: added several new variables for exposing information about the downstream TLS connection via :ref:`header\n  formatters <config_http_conn_man_headers_custom_request_headers>`.\n* router: per try timeouts will no longer start before the downstream request has been received\n  in full by the router. This ensures that the per try timeout does not account for slow\n  downstreams and that will not start before the global timeout.\n* router: added :ref:`RouteAction's auto_host_rewrite_header <envoy_api_field_route.RouteAction.auto_host_rewrite_header>` to allow upstream host header substitution with some other header's value\n* router: added support for UPSTREAM_REMOTE_ADDRESS :ref:`header formatter\n  <config_http_conn_man_headers_custom_request_headers>`.\n* router: add ability to reject a request that includes invalid values for\n  headers configured in :ref:`strict_check_headers <envoy_api_field_config.filter.http.router.v2.Router.strict_check_headers>`\n* runtime: added support for :ref:`flexible layering configuration\n  <envoy_api_field_config.bootstrap.v2.Bootstrap.layered_runtime>`.\n* runtime: added support for statically :ref:`specifying the runtime in the bootstrap configuration\n  <envoy_api_field_config.bootstrap.v2.Runtime.base>`.\n* runtime: :ref:`Runtime Discovery Service (RTDS) <config_runtime_rtds>` support added to layered runtime configuration.\n* sandbox: added :ref:`CSRF sandbox <install_sandboxes_csrf>`.\n* server: ``--define manual_stamp=manual_stamp`` was added to allow server stamping outside of binary rules.\n  more info in the `bazel docs <https://github.com/envoyproxy/envoy/blob/master/bazel/README.md#enabling-optional-features>`_.\n* server: added :ref:`server state <statistics>` statistic.\n* server: added :ref:`initialization_time_ms<statistics>` statistic.\n* subset: added :ref:`list_as_any<envoy_api_field_Cluster.LbSubsetConfig.list_as_any>` option to\n  the subset lb which allows matching metadata against any of the values in a list value\n  on the endpoints.\n* tools: added :repo:`proto <test/tools/router_check/validation.proto>` support for :ref:`router check tool <install_tools_route_table_check_tool>` tests.\n* tracing: add trace sampling configuration to the route, to override the route level.\n* upstream: added :ref:`upstream_cx_pool_overflow <config_cluster_manager_cluster_stats>` for the connection pool circuit breaker.\n* upstream: an EDS management server can now force removal of a host that is still passing active\n  health checking by first marking the host as failed via EDS health check and subsequently removing\n  it in a future update. This is a mechanism to work around a race condition in which an EDS\n  implementation may remove a host before it has stopped passing active HC, thus causing the host\n  to become stranded until a future update.\n* upstream: added :ref:`an option <envoy_api_field_Cluster.CommonLbConfig.ignore_new_hosts_until_first_hc>`\n  that allows ignoring new hosts for the purpose of load balancing calculations until they have\n  been health checked for the first time.\n* upstream: added runtime error checking to prevent setting dns type to STRICT_DNS or LOGICAL_DNS when custom resolver name is specified.\n* upstream: added possibility to override fallback_policy per specific selector in :ref:`subset load balancer <arch_overview_load_balancer_subsets>`.\n* upstream: the :ref:`logical DNS cluster <arch_overview_service_discovery_types_logical_dns>` now\n  displays the current resolved IP address in admin output instead of 0.0.0.0.\n\n1.10.0 (Apr 5, 2019)\n====================\n* access log: added a new flag for upstream retry count exceeded.\n* access log: added a :ref:`gRPC filter <envoy_api_msg_config.filter.accesslog.v2.GrpcStatusFilter>` to allow filtering on gRPC status.\n* access log: added a new flag for stream idle timeout.\n* access log: added a new field for upstream transport failure reason in :ref:`file access logger<config_access_log_format_upstream_transport_failure_reason>` and\n  :ref:`gRPC access logger<envoy_api_field_data.accesslog.v2.AccessLogCommon.upstream_transport_failure_reason>` for HTTP access logs.\n* access log: added new fields for downstream x509 information (URI sans and subject) to file and gRPC access logger.\n* admin: the admin server can now be accessed via HTTP/2 (prior knowledge).\n* admin: changed HTTP response status code from 400 to 405 when attempting to GET a POST-only route (such as /quitquitquit).\n* buffer: fix vulnerabilities when allocation fails.\n* build: releases are built with GCC-7 and linked with LLD.\n* build: dev docker images :ref:`have been split <install_binaries>` from tagged images for easier\n  discoverability in Docker Hub. Additionally, we now build images for point releases.\n* config: added support of using google.protobuf.Any in opaque configs for extensions.\n* config: logging warnings when deprecated fields are in use.\n* config: removed deprecated --v2-config-only from command line config.\n* config: removed deprecated_v1 sds_config from :ref:`Bootstrap config <config_overview_v2_bootstrap>`.\n* config: removed the deprecated_v1 config option from :ref:`ring hash <envoy_api_msg_Cluster.RingHashLbConfig>`.\n* config: removed REST_LEGACY as a valid :ref:`ApiType <envoy_api_field_core.ApiConfigSource.api_type>`.\n* config: finish cluster warming only when a named response i.e. ClusterLoadAssignment associated to the cluster being warmed comes in the EDS response. This is a behavioural change from the current implementation where warming of cluster completes on missing load assignments also.\n* config: use Envoy cpuset size to set the default number or worker threads if :option:`--cpuset-threads` is enabled.\n* config: added support for :ref:`initial_fetch_timeout <envoy_api_field_core.ConfigSource.initial_fetch_timeout>`. The timeout is disabled by default.\n* cors: added :ref:`filter_enabled & shadow_enabled RuntimeFractionalPercent flags <cors-runtime>` to filter.\n* csrf: added :ref:`CSRF filter <config_http_filters_csrf>`.\n* ext_authz: added support for buffering request body.\n* ext_authz: migrated from v2alpha to v2 and improved docs.\n* ext_authz: added a configurable option to make the gRPC service cross-compatible with V2Alpha. Note that this feature is already deprecated. It should be used for a short time, and only when transitioning from alpha to V2 release version.\n* ext_authz: migrated from v2alpha to v2 and improved the documentation.\n* ext_authz: authorization request and response configuration has been separated into two distinct objects: :ref:`authorization request\n  <envoy_api_field_config.filter.http.ext_authz.v2.HttpService.authorization_request>` and :ref:`authorization response\n  <envoy_api_field_config.filter.http.ext_authz.v2.HttpService.authorization_response>`. In addition, :ref:`client headers\n  <envoy_api_field_config.filter.http.ext_authz.v2.AuthorizationResponse.allowed_client_headers>` and :ref:`upstream headers\n  <envoy_api_field_config.filter.http.ext_authz.v2.AuthorizationResponse.allowed_upstream_headers>` replaces the previous *allowed_authorization_headers* object.\n  All the control header lists now support :ref:`string matcher <envoy_api_msg_type.matcher.StringMatcher>` instead of standard string.\n* fault: added the :ref:`max_active_faults\n  <envoy_api_field_config.filter.http.fault.v2.HTTPFault.max_active_faults>` setting, as well as\n  :ref:`statistics <config_http_filters_fault_injection_stats>` for the number of active faults\n  and the number of faults the overflowed.\n* fault: added :ref:`response rate limit\n  <envoy_api_field_config.filter.http.fault.v2.HTTPFault.response_rate_limit>` fault injection.\n* fault: added :ref:`HTTP header fault configuration\n  <config_http_filters_fault_injection_http_header>` to the HTTP fault filter.\n* governance: extending Envoy deprecation policy from 1 release (0-3 months) to 2 releases (3-6 months).\n* health check: expected response codes in http health checks are now :ref:`configurable <envoy_api_msg_core.HealthCheck.HttpHealthCheck>`.\n* http: added new grpc_http1_reverse_bridge filter for converting gRPC requests into HTTP/1.1 requests.\n* http: fixed a bug where Content-Length:0 was added to HTTP/1 204 responses.\n* http: added :ref:`max request headers size <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.max_request_headers_kb>`. The default behaviour is unchanged.\n* http: added modifyDecodingBuffer/modifyEncodingBuffer to allow modifying the buffered request/response data.\n* http: added encodeComplete/decodeComplete. These are invoked at the end of the stream, after all data has been encoded/decoded respectively. Default implementation is a no-op.\n* outlier_detection: added support for :ref:`outlier detection event protobuf-based logging <arch_overview_outlier_detection_logging>`.\n* mysql: added a MySQL proxy filter that is capable of parsing SQL queries over MySQL wire protocol. Refer to :ref:`MySQL proxy<config_network_filters_mysql_proxy>` for more details.\n* performance: new buffer implementation (disabled by default; to test it, add \"--use-libevent-buffers 0\" to the command-line arguments when starting Envoy).\n* jwt_authn: added :ref:`filter_state_rules <envoy_api_field_config.filter.http.jwt_authn.v2alpha.JwtAuthentication.filter_state_rules>` to allow specifying requirements from filterState by other filters.\n* ratelimit: removed deprecated rate limit configuration from bootstrap.\n* redis: added :ref:`hashtagging <envoy_api_field_config.filter.network.redis_proxy.v2.RedisProxy.ConnPoolSettings.enable_hashtagging>` to guarantee a given key's upstream.\n* redis: added :ref:`latency stats <config_network_filters_redis_proxy_per_command_stats>` for commands.\n* redis: added :ref:`success and error stats <config_network_filters_redis_proxy_per_command_stats>` for commands.\n* redis: migrate hash function for host selection to `MurmurHash2 <https://sites.google.com/site/murmurhash>`_ from std::hash. MurmurHash2 is compatible with std::hash in GNU libstdc++ 3.4.20 or above. This is typically the case when compiled on Linux and not macOS.\n* redis: added :ref:`latency_in_micros <envoy_api_field_config.filter.network.redis_proxy.v2.RedisProxy.latency_in_micros>` to specify the redis commands stats time unit in microseconds.\n* router: added ability to configure a :ref:`retry policy <envoy_api_msg_route.RetryPolicy>` at the\n  virtual host level.\n* router: added reset reason to response body when upstream reset happens. After this change, the response body will be of the form `upstream connect error or disconnect/reset before headers. reset reason:`\n* router: added :ref:`rq_reset_after_downstream_response_started <config_http_filters_router_stats>` counter stat to router stats.\n* router: added per-route configuration of :ref:`internal redirects <envoy_api_field_route.RouteAction.internal_redirect_action>`.\n* router: removed deprecated route-action level headers_to_add/remove.\n* router: made :ref:`max retries header <config_http_filters_router_x-envoy-max-retries>` take precedence over the number of retries in route and virtual host retry policies.\n* router: added support for prefix wildcards in :ref:`virtual host domains<envoy_api_field_route.VirtualHost.domains>`\n* stats: added support for histograms in prometheus\n* stats: added usedonly flag to prometheus stats to only output metrics which have been\n  updated at least once.\n* stats: added gauges tracking remaining resources before circuit breakers open.\n* tap: added new alpha :ref:`HTTP tap filter <config_http_filters_tap>`.\n* tls: enabled TLS 1.3 on the server-side (non-FIPS builds).\n* upstream: add hash_function to specify the hash function for :ref:`ring hash<envoy_api_msg_Cluster.RingHashLbConfig>` as either xxHash or `murmurHash2 <https://sites.google.com/site/murmurhash>`_. MurmurHash2 is compatible with std::hash in GNU libstdc++ 3.4.20 or above. This is typically the case when compiled on Linux and not macOS.\n* upstream: added :ref:`degraded health value<arch_overview_load_balancing_degraded>` which allows\n  routing to certain hosts only when there are insufficient healthy hosts available.\n* upstream: add cluster factory to allow creating and registering :ref:`custom cluster type<arch_overview_service_discovery_types_custom>`.\n* upstream: added a :ref:`circuit breaker <arch_overview_circuit_break_cluster_maximum_connection_pools>` to limit the number of concurrent connection pools in use.\n* tracing: added :ref:`verbose <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.tracing>` to support logging annotations on spans.\n* upstream: added support for host weighting and :ref:`locality weighting <arch_overview_load_balancing_locality_weighted_lb>` in the :ref:`ring hash load balancer <arch_overview_load_balancing_types_ring_hash>`, and added a :ref:`maximum_ring_size<envoy_api_field_Cluster.RingHashLbConfig.maximum_ring_size>` config parameter to strictly bound the ring size.\n* zookeeper: added a ZooKeeper proxy filter that parses ZooKeeper messages (requests/responses/events).\n  Refer to :ref:`ZooKeeper proxy<config_network_filters_zookeeper_proxy>` for more details.\n* upstream: added configuration option to select any host when the fallback policy fails.\n* upstream: stopped incrementing upstream_rq_total for HTTP/1 conn pool when request is circuit broken.\n\n1.9.1 (Apr 2, 2019)\n===================\n* http: fixed CVE-2019-9900 by rejecting HTTP/1.x headers with embedded NUL characters.\n* http: fixed CVE-2019-9901 by normalizing HTTP paths prior to routing or L7 data plane processing.\n  This defaults off and is configurable via either HTTP connection manager :ref:`normalize_path\n  <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.normalize_path>`\n  or the :ref:`runtime <config_http_conn_man_runtime_normalize_path>`.\n\n1.9.0 (Dec 20, 2018)\n====================\n* access log: added a :ref:`JSON logging mode <config_access_log_format_dictionaries>` to output access logs in JSON format.\n* access log: added dynamic metadata to access log messages streamed over gRPC.\n* access log: added DOWNSTREAM_CONNECTION_TERMINATION.\n* admin: :http:post:`/logging` now responds with 200 while there are no params.\n* admin: added support for displaying subject alternate names in :ref:`certs<operations_admin_interface_certs>` end point.\n* admin: added host weight to the :http:get:`/clusters?format=json` end point response.\n* admin: :http:get:`/server_info` now responds with a JSON object instead of a single string.\n* admin: :http:get:`/server_info` now exposes what stage of initialization the server is currently in.\n* admin: added support for displaying command line options in :http:get:`/server_info` end point.\n* circuit-breaker: added cx_open, rq_pending_open, rq_open and rq_retry_open gauges to expose live\n  state via :ref:`circuit breakers statistics <config_cluster_manager_cluster_stats_circuit_breakers>`.\n* cluster: set a default of 1s for :ref:`option <envoy_api_field_Cluster.CommonLbConfig.update_merge_window>`.\n* config: removed support for the v1 API.\n* config: added support for :ref:`rate limiting<envoy_api_msg_core.RateLimitSettings>` discovery request calls.\n* cors: added :ref:`invalid/valid stats <cors-statistics>` to filter.\n* ext-authz: added support for providing per route config - optionally disable the filter and provide context extensions.\n* fault: removed integer percentage support.\n* grpc-json: added support for :ref:`ignoring query parameters\n  <envoy_api_field_config.filter.http.transcoder.v2.GrpcJsonTranscoder.ignored_query_parameters>`.\n* health check: added :ref:`logging health check failure events <envoy_api_field_core.HealthCheck.always_log_health_check_failures>`.\n* health check: added ability to set :ref:`authority header value\n  <envoy_api_field_core.HealthCheck.GrpcHealthCheck.authority>` for gRPC health check.\n* http: added HTTP/2 WebSocket proxying via :ref:`extended CONNECT <envoy_api_field_core.Http2ProtocolOptions.allow_connect>`.\n* http: added limits to the number and length of header modifications in all fields request_headers_to_add and response_headers_to_add. These limits are very high and should only be used as a last-resort safeguard.\n* http: added support for a :ref:`request timeout <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.request_timeout>`. The timeout is disabled by default.\n* http: no longer adding whitespace when appending X-Forwarded-For headers. **Warning**: this is not\n  compatible with 1.7.0 builds prior to `9d3a4eb4ac44be9f0651fcc7f87ad98c538b01ee <https://github.com/envoyproxy/envoy/pull/3610>`_.\n  See `#3611 <https://github.com/envoyproxy/envoy/issues/3611>`_ for details.\n* http: augmented the `sendLocalReply` filter API to accept an optional `GrpcStatus`\n  value to override the default HTTP to gRPC status mapping.\n* http: no longer close the TCP connection when a HTTP/1 request is retried due\n  to a response with empty body.\n* http: added support for more gRPC content-type headers in :ref:`gRPC bridge filter <config_http_filters_grpc_bridge>`, like application/grpc+proto.\n* listeners: all listener filters are now governed by the :ref:`listener_filters_timeout\n  <envoy_api_field_Listener.listener_filters_timeout>` setting. The hard coded 15s timeout in\n  the :ref:`TLS inspector listener filter <config_listener_filters_tls_inspector>` is superseded by\n  this setting.\n* listeners: added the ability to match :ref:`FilterChain <envoy_api_msg_listener.FilterChain>` using :ref:`source_type <envoy_api_field_listener.FilterChainMatch.source_type>`.\n* load balancer: added a `configuration <envoy_api_msg_Cluster.LeastRequestLbConfig>` option to specify the number of choices made in P2C.\n* logging: added missing [ in log prefix.\n* mongo_proxy: added :ref:`dynamic metadata <config_network_filters_mongo_proxy_dynamic_metadata>`.\n* network: removed the reference to `FilterState` in `Connection` in favor of `StreamInfo`.\n* rate-limit: added :ref:`configuration <envoy_api_field_config.filter.http.rate_limit.v2.RateLimit.rate_limited_as_resource_exhausted>`\n  to specify whether the `GrpcStatus` status returned should be `RESOURCE_EXHAUSTED` or\n  `UNAVAILABLE` when a gRPC call is rate limited.\n* rate-limit: removed support for the legacy ratelimit service and made the data-plane-api\n  :ref:`rls.proto <envoy_api_file_envoy/service/ratelimit/v2/rls.proto>` based implementation default.\n* rate-limit: removed the deprecated cluster_name attribute in :ref:`rate limit service configuration <envoy_api_file_envoy/config/ratelimit/v2/rls.proto>`.\n* rate-limit: added :ref:`rate_limit_service <envoy_api_msg_config.filter.http.rate_limit.v2.RateLimit>` configuration to filters.\n* rbac: added dynamic metadata to the network level filter.\n* rbac: added support for permission matching by :ref:`requested server name <envoy_api_field_config.rbac.v2.Permission.requested_server_name>`.\n* redis: static cluster configuration is no longer required. Redis proxy will work with clusters\n  delivered via CDS.\n* router: added ability to configure arbitrary :ref:`retriable status codes. <envoy_api_field_route.RetryPolicy.retriable_status_codes>`\n* router: added ability to set attempt count in upstream requests, see :ref:`virtual host's include request\n  attempt count flag <envoy_api_field_route.VirtualHost.include_request_attempt_count>`.\n* router: added internal :ref:`grpc-retry-on <config_http_filters_router_x-envoy-retry-grpc-on>` policy.\n* router: added :ref:`scheme_redirect <envoy_api_field_route.RedirectAction.scheme_redirect>` and\n  :ref:`port_redirect <envoy_api_field_route.RedirectAction.port_redirect>` to define the respective\n  scheme and port rewriting RedirectAction.\n* router: when :ref:`max_grpc_timeout <envoy_api_field_route.RouteAction.max_grpc_timeout>`\n  is set, Envoy will now add or update the grpc-timeout header to reflect Envoy's expected timeout.\n* router: per try timeouts now starts when an upstream stream is ready instead of when the request has\n  been fully decoded by Envoy.\n* router: added support for not retrying :ref:`rate limited requests<config_http_filters_router_x-envoy-ratelimited>`. Rate limit filter now sets the :ref:`x-envoy-ratelimited<config_http_filters_router_x-envoy-ratelimited>`\n  header so the rate limited requests that may have been retried earlier will not be retried with this change.\n* router: added support for enabling upgrades on a :ref:`per-route <envoy_api_field_route.RouteAction.upgrade_configs>` basis.\n* router: support configuring a default fraction of mirror traffic via\n  :ref:`runtime_fraction <envoy_api_field_route.RouteAction.RequestMirrorPolicy.runtime_key>`.\n* sandbox: added :ref:`cors sandbox <install_sandboxes_cors>`.\n* server: added `SIGINT` (Ctrl-C) handler to gracefully shutdown Envoy like `SIGTERM`.\n* stats: added :ref:`stats_matcher <envoy_api_field_config.metrics.v2.StatsConfig.stats_matcher>` to the bootstrap config for granular control of stat instantiation.\n* stream: renamed the `RequestInfo` namespace to `StreamInfo` to better match\n  its behaviour within TCP and HTTP implementations.\n* stream: renamed `perRequestState` to `filterState` in `StreamInfo`.\n* stream: added `downstreamDirectRemoteAddress` to `StreamInfo`.\n* thrift_proxy: introduced thrift rate limiter filter.\n* tls: added ssl.curves.<curve>, ssl.sigalgs.<sigalg> and ssl.versions.<version> to\n  :ref:`listener metrics <config_listener_stats>` to track TLS algorithms and versions in use.\n* tls: added support for :ref:`client-side session resumption <envoy_api_field_auth.UpstreamTlsContext.max_session_keys>`.\n* tls: added support for CRLs in :ref:`trusted_ca <envoy_api_field_auth.CertificateValidationContext.trusted_ca>`.\n* tls: added support for :ref:`multiple server TLS certificates <arch_overview_ssl_cert_select>`.\n* tls: added support for :ref:`password encrypted private keys <envoy_api_field_auth.TlsCertificate.password>`.\n* tls: added the ability to build :ref:`BoringSSL FIPS <arch_overview_ssl_fips>` using ``--define boringssl=fips`` Bazel option.\n* tls: removed support for ECDSA certificates with curves other than P-256.\n* tls: removed support for RSA certificates with keys smaller than 2048-bits.\n* tracing: added support to the Zipkin tracer for the :ref:`b3 <config_http_conn_man_headers_b3>` single header format.\n* tracing: added support for :ref:`Datadog <arch_overview_tracing>` tracer.\n* upstream: added :ref:`scale_locality_weight<envoy_api_field_Cluster.LbSubsetConfig.scale_locality_weight>` to enable\n  scaling locality weights by number of hosts removed by subset lb predicates.\n* upstream: changed how load calculation for :ref:`priority levels<arch_overview_load_balancing_priority_levels>` and :ref:`panic thresholds<arch_overview_load_balancing_panic_threshold>` interact. As long as normalized total health is 100% panic thresholds are disregarded.\n* upstream: changed the default hash for :ref:`ring hash <envoy_api_msg_Cluster.RingHashLbConfig>` from std::hash to `xxHash <https://github.com/Cyan4973/xxHash>`_.\n* upstream: when using active health checking and STRICT_DNS with several addresses that resolve\n  to the same hosts, Envoy will now health check each host independently.\n\n1.8.0 (Oct 4, 2018)\n===================\n* access log: added :ref:`response flag filter <envoy_api_msg_config.filter.accesslog.v2.ResponseFlagFilter>`\n  to filter based on the presence of Envoy response flags.\n* access log: added RESPONSE_DURATION and RESPONSE_TX_DURATION.\n* access log: added REQUESTED_SERVER_NAME for SNI to tcp_proxy and http\n* admin: added :http:get:`/hystrix_event_stream` as an endpoint for monitoring envoy's statistics\n  through `Hystrix dashboard <https://github.com/Netflix-Skunkworks/hystrix-dashboard/wiki>`_.\n* cli: added support for :ref:`component log level <operations_cli>` command line option for configuring log levels of individual components.\n* cluster: added :ref:`option <envoy_api_field_Cluster.CommonLbConfig.update_merge_window>` to merge\n  health check/weight/metadata updates within the given duration.\n* config: regex validation added to limit to a maximum of 1024 characters.\n* config: v1 disabled by default. v1 support remains available until October via flipping --v2-config-only=false.\n* config: v1 disabled by default. v1 support remains available until October via deprecated flag --allow-deprecated-v1-api.\n* config: fixed stat inconsistency between xDS and ADS implementation. :ref:`update_failure <config_cluster_manager_cds>`\n  stat is incremented in case of network failure and :ref:`update_rejected <config_cluster_manager_cds>` stat is incremented\n  in case of schema/validation error.\n* config: added a stat :ref:`connected_state <management_server_stats>` that indicates current connected state of Envoy with\n  management server.\n* ext_authz: added support for configuring additional :ref:`authorization headers <envoy_api_field_config.filter.http.ext_authz.v2.AuthorizationRequest.headers_to_add>`\n  to be sent from Envoy to the authorization service.\n* fault: added support for fractional percentages in :ref:`FaultDelay <envoy_api_field_config.filter.fault.v2.FaultDelay.percentage>`\n  and in :ref:`FaultAbort <envoy_api_field_config.filter.http.fault.v2.FaultAbort.percentage>`.\n* grpc-json: added support for building HTTP response from\n  `google.api.HttpBody <https://github.com/googleapis/googleapis/blob/master/google/api/httpbody.proto>`_.\n* health check: added support for :ref:`custom health check <envoy_api_field_core.HealthCheck.custom_health_check>`.\n* health check: added support for :ref:`specifying jitter as a percentage <envoy_api_field_core.HealthCheck.interval_jitter_percent>`.\n* health_check: added support for :ref:`health check event logging <arch_overview_health_check_logging>`.\n* health_check: added :ref:`timestamp <envoy_api_field_data.core.v2alpha.HealthCheckEvent.timestamp>`\n  to the :ref:`health check event <envoy_api_msg_data.core.v2alpha.HealthCheckEvent>` definition.\n* health_check: added support for specifying :ref:`custom request headers <config_http_conn_man_headers_custom_request_headers>`\n  to HTTP health checker requests.\n* http: added support for a :ref:`per-stream idle timeout\n  <envoy_api_field_route.RouteAction.idle_timeout>`. This applies at both :ref:`connection manager\n  <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.stream_idle_timeout>`\n  and :ref:`per-route granularity <envoy_api_field_route.RouteAction.idle_timeout>`. The timeout\n  defaults to 5 minutes; if you have other timeouts (e.g. connection idle timeout, upstream\n  response per-retry) that are longer than this in duration, you may want to consider setting a\n  non-default per-stream idle timeout.\n* http: added upstream_rq_completed counter for :ref:`total requests completed <config_cluster_manager_cluster_stats_dynamic_http>` to dynamic HTTP counters.\n* http: added downstream_rq_completed counter for :ref:`total requests completed <config_http_conn_man_stats>`, including on a :ref:`per-listener basis <config_http_conn_man_stats_per_listener>`.\n* http: added generic :ref:`Upgrade support\n  <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.upgrade_configs>`.\n* http: better handling of HEAD requests. Now sending transfer-encoding: chunked rather than content-length: 0.\n* http: fixed missing support for appending to predefined inline headers, e.g.\n  *authorization*, in features that interact with request and response headers,\n  e.g. :ref:`request_headers_to_add\n  <envoy_api_field_route.Route.request_headers_to_add>`. For example, a\n  request header *authorization: token1* will appear as *authorization:\n  token1,token2*, after having :ref:`request_headers_to_add\n  <envoy_api_field_route.Route.request_headers_to_add>` with *authorization:\n  token2* applied.\n* http: response filters not applied to early error paths such as http_parser generated 400s.\n* http: restrictions added to reject *:*-prefixed pseudo-headers in :ref:`custom\n  request headers <config_http_conn_man_headers_custom_request_headers>`.\n* http: :ref:`hpack_table_size <envoy_api_field_core.Http2ProtocolOptions.hpack_table_size>` now controls\n  dynamic table size of both: encoder and decoder.\n* http: added support for removing request headers using :ref:`request_headers_to_remove\n  <envoy_api_field_route.Route.request_headers_to_remove>`.\n* http: added support for a :ref:`delayed close timeout<envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.delayed_close_timeout>` to mitigate race conditions when closing connections to downstream HTTP clients. The timeout defaults to 1 second.\n* jwt-authn filter: add support for per route JWT requirements.\n* listeners: added the ability to match :ref:`FilterChain <envoy_api_msg_listener.FilterChain>` using\n  :ref:`destination_port <envoy_api_field_listener.FilterChainMatch.destination_port>` and\n  :ref:`prefix_ranges <envoy_api_field_listener.FilterChainMatch.prefix_ranges>`.\n* lua: added :ref:`connection() <config_http_filters_lua_connection_wrapper>` wrapper and *ssl()* API.\n* lua: added :ref:`streamInfo() <config_http_filters_lua_stream_info_wrapper>` wrapper and *protocol()* API.\n* lua: added :ref:`streamInfo():dynamicMetadata() <config_http_filters_lua_stream_info_dynamic_metadata_wrapper>` API.\n* network: introduced :ref:`sni_cluster <config_network_filters_sni_cluster>` network filter that forwards connections to the\n  upstream cluster specified by the SNI value presented by the client during a TLS handshake.\n* proxy_protocol: added support for HAProxy Proxy Protocol v2 (AF_INET/AF_INET6 only).\n* ratelimit: added support for :repo:`api/envoy/service/ratelimit/v2/rls.proto`.\n  Lyft's reference implementation of the `ratelimit <https://github.com/lyft/ratelimit>`_ service also supports the data-plane-api proto as of v1.1.0.\n  Envoy can use either proto to send client requests to a ratelimit server with the use of the\n  `use_data_plane_proto` boolean flag in the ratelimit configuration.\n  Support for the legacy proto `source/common/ratelimit/ratelimit.proto` is deprecated and will be removed at the start of the 1.9.0 release cycle.\n* ratelimit: added :ref:`failure_mode_deny <envoy_api_msg_config.filter.http.rate_limit.v2.RateLimit>` option to control traffic flow in\n  case of rate limit service error.\n* rbac config: added a :ref:`principal_name <envoy_api_field_config.rbac.v2.Principal.Authenticated.principal_name>` field and\n  removed the old `name` field to give more flexibility for matching certificate identity.\n* rbac network filter: a :ref:`role-based access control network filter <config_network_filters_rbac>` has been added.\n* rest-api: added ability to set the :ref:`request timeout <envoy_api_field_core.ApiConfigSource.request_timeout>` for REST API requests.\n* route checker: added v2 config support and removed support for v1 configs.\n* router: added ability to set request/response headers at the :ref:`envoy_api_msg_route.Route` level.\n* stats: added :ref:`option to configure the DogStatsD metric name prefix<envoy_api_field_config.metrics.v2.DogStatsdSink.prefix>` to DogStatsdSink.\n* tcp_proxy: added support for :ref:`weighted clusters <envoy_api_field_config.filter.network.tcp_proxy.v2.TcpProxy.weighted_clusters>`.\n* thrift_proxy: introduced thrift routing, moved configuration to correct location\n* thrift_proxy: introduced thrift configurable decoder filters\n* tls: implemented :ref:`Secret Discovery Service <config_secret_discovery_service>`.\n* tracing: added support for configuration of :ref:`tracing sampling\n  <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.tracing>`.\n* upstream: added configuration option to the subset load balancer to take locality weights into account when\n  selecting a host from a subset.\n* upstream: require opt-in to use the :ref:`x-envoy-original-dst-host <config_http_conn_man_headers_x-envoy-original-dst-host>` header\n  for overriding destination address when using the :ref:`Original Destination <arch_overview_load_balancing_types_original_destination>`\n  load balancing policy.\n\n1.7.0 (Jun 21, 2018)\n====================\n* access log: added ability to log response trailers.\n* access log: added ability to format START_TIME.\n* access log: added DYNAMIC_METADATA :ref:`access log formatter <config_access_log_format>`.\n* access log: added :ref:`HeaderFilter <envoy_api_msg_config.filter.accesslog.v2.HeaderFilter>`\n  to filter logs based on request headers.\n* access log: added `%([1-9])?f` as one of START_TIME specifiers to render subseconds.\n* access log: gRPC Access Log Service (ALS) support added for :ref:`HTTP access logs\n  <envoy_api_msg_config.accesslog.v2.HttpGrpcAccessLogConfig>`.\n* access log: improved WebSocket logging.\n* admin: added :http:get:`/config_dump` for dumping the current configuration and associated xDS\n  version information (if applicable).\n* admin: added :http:get:`/clusters?format=json` for outputing a JSON-serialized proto detailing\n  the current status of all clusters.\n* admin: added :http:get:`/stats/prometheus` as an alternative endpoint for getting stats in prometheus format.\n* admin: added :ref:`/runtime_modify endpoint <operations_admin_interface_runtime_modify>` to add or change runtime values.\n* admin: mutations must be sent as POSTs, rather than GETs. Mutations include:\n  :http:post:`/cpuprofiler`, :http:post:`/healthcheck/fail`, :http:post:`/healthcheck/ok`,\n  :http:post:`/logging`, :http:post:`/quitquitquit`, :http:post:`/reset_counters`,\n  :http:post:`/runtime_modify?key1=value1&key2=value2&keyN=valueN`.\n* admin: removed `/routes` endpoint; route configs can now be found at the :ref:`/config_dump endpoint <operations_admin_interface_config_dump>`.\n* buffer filter: the buffer filter can be optionally\n  :ref:`disabled <envoy_api_field_config.filter.http.buffer.v2.BufferPerRoute.disabled>` or\n  :ref:`overridden <envoy_api_field_config.filter.http.buffer.v2.BufferPerRoute.buffer>` with\n  route-local configuration.\n* cli: added --config-yaml flag to the Envoy binary. When set its value is interpreted as a yaml\n  representation of the bootstrap config and overrides --config-path.\n* cluster: added :ref:`option <envoy_api_field_Cluster.close_connections_on_host_health_failure>`\n  to close tcp_proxy upstream connections when health checks fail.\n* cluster: added :ref:`option <envoy_api_field_Cluster.drain_connections_on_host_removal>` to drain\n  connections from hosts after they are removed from service discovery, regardless of health status.\n* cluster: fixed bug preventing the deletion of all endpoints in a priority\n* debug: added symbolized stack traces (where supported)\n* ext-authz filter: added support to raw HTTP authorization.\n* ext-authz filter: added support to gRPC responses to carry HTTP attributes.\n* grpc: support added for the full set of :ref:`Google gRPC call credentials\n  <envoy_api_msg_core.GrpcService.GoogleGrpc.CallCredentials>`.\n* gzip filter: added :ref:`stats <gzip-statistics>` to the filter.\n* gzip filter: sending *accept-encoding* header as *identity* no longer compresses the payload.\n* health check: added ability to set :ref:`additional HTTP headers\n  <envoy_api_field_core.HealthCheck.HttpHealthCheck.request_headers_to_add>` for HTTP health check.\n* health check: added support for EDS delivered :ref:`endpoint health status\n  <envoy_api_field_endpoint.LbEndpoint.health_status>`.\n* health check: added interval overrides for health state transitions from :ref:`healthy to unhealthy\n  <envoy_api_field_core.HealthCheck.unhealthy_edge_interval>`, :ref:`unhealthy to healthy\n  <envoy_api_field_core.HealthCheck.healthy_edge_interval>` and for subsequent checks on\n  :ref:`unhealthy hosts <envoy_api_field_core.HealthCheck.unhealthy_interval>`.\n* health check: added support for :ref:`custom health check <envoy_api_field_core.HealthCheck.custom_health_check>`.\n* health check: health check connections can now be configured to use http/2.\n* health check http filter: added\n  :ref:`generic header matching <envoy_api_field_config.filter.http.health_check.v2.HealthCheck.headers>`\n  to trigger health check response. Deprecated the endpoint option.\n* http: filters can now optionally support\n  :ref:`virtual host <envoy_api_field_route.VirtualHost.per_filter_config>`,\n  :ref:`route <envoy_api_field_route.Route.per_filter_config>`, and\n  :ref:`weighted cluster <envoy_api_field_route.WeightedCluster.ClusterWeight.per_filter_config>`\n  local configuration.\n* http: added the ability to pass DNS type Subject Alternative Names of the client certificate in the\n  :ref:`config_http_conn_man_headers_x-forwarded-client-cert` header.\n* http: local responses to gRPC requests are now sent as trailers-only gRPC responses instead of plain HTTP responses.\n  Notably the HTTP response code is always \"200\" in this case, and the gRPC error code is carried in \"grpc-status\"\n  header, optionally accompanied with a text message in \"grpc-message\" header.\n* http: added support for :ref:`via header\n  <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.via>`\n  append.\n* http: added a :ref:`configuration option\n  <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.skip_xff_append>`\n  to elide *x-forwarded-for* header modifications.\n* http: fixed a bug in inline headers where addCopy and addViaMove didn't add header values when\n  encountering inline headers with multiple instances.\n* listeners: added :ref:`tcp_fast_open_queue_length <envoy_api_field_Listener.tcp_fast_open_queue_length>` option.\n* listeners: added the ability to match :ref:`FilterChain <envoy_api_msg_listener.FilterChain>` using\n  :ref:`application_protocols <envoy_api_field_listener.FilterChainMatch.application_protocols>`\n  (e.g. ALPN for TLS protocol).\n* listeners: `sni_domains` has been deprecated/renamed to :ref:`server_names <envoy_api_field_listener.FilterChainMatch.server_names>`.\n* listeners: removed restriction on all filter chains having identical filters.\n* load balancer: added :ref:`weighted round robin\n  <arch_overview_load_balancing_types_round_robin>` support. The round robin\n  scheduler now respects endpoint weights and also has improved fidelity across\n  picks.\n* load balancer: :ref:`locality weighted load balancing\n  <arch_overview_load_balancer_subsets>` is now supported.\n* load balancer: ability to configure zone aware load balancer settings :ref:`through the API\n  <envoy_api_field_Cluster.CommonLbConfig.zone_aware_lb_config>`.\n* load balancer: the :ref:`weighted least request\n  <arch_overview_load_balancing_types_least_request>` load balancing algorithm has been improved\n  to have better balance when operating in weighted mode.\n* logger: added the ability to optionally set the log format via the :option:`--log-format` option.\n* logger: all :ref:`logging levels <operations_admin_interface_logging>` can be configured\n  at run-time: trace debug info warning error critical.\n* rbac http filter: a :ref:`role-based access control http filter <config_http_filters_rbac>` has been added.\n* router: the behavior of per-try timeouts have changed in the case where a portion of the response has\n  already been proxied downstream when the timeout occurs. Previously, the response would be reset\n  leading to either an HTTP/2 reset or an HTTP/1 closed connection and a partial response. Now, the\n  timeout will be ignored and the response will continue to proxy up to the global request timeout.\n* router: changed the behavior of :ref:`source IP routing <envoy_api_field_route.RouteAction.HashPolicy.ConnectionProperties.source_ip>`\n  to ignore the source port.\n* router: added an :ref:`prefix_match <envoy_api_field_route.HeaderMatcher.prefix_match>` match type\n  to explicitly match based on the prefix of a header value.\n* router: added an :ref:`suffix_match <envoy_api_field_route.HeaderMatcher.suffix_match>` match type\n  to explicitly match based on the suffix of a header value.\n* router: added an :ref:`present_match <envoy_api_field_route.HeaderMatcher.present_match>` match type\n  to explicitly match based on a header's presence.\n* router: added an :ref:`invert_match <envoy_api_field_route.HeaderMatcher.invert_match>` config option\n  which supports inverting all other match types to match based on headers which are not a desired value.\n* router: allow :ref:`cookie routing <envoy_api_msg_route.RouteAction.HashPolicy.Cookie>` to\n  generate session cookies.\n* router: added START_TIME as one of supported variables in :ref:`header\n  formatters <config_http_conn_man_headers_custom_request_headers>`.\n* router: added a :ref:`max_grpc_timeout <envoy_api_field_route.RouteAction.max_grpc_timeout>`\n  config option to specify the maximum allowable value for timeouts decoded from gRPC header field\n  `grpc-timeout`.\n* router: added a :ref:`configuration option\n  <envoy_api_field_config.filter.http.router.v2.Router.suppress_envoy_headers>` to disable *x-envoy-*\n  header generation.\n* router: added 'unavailable' to the retriable gRPC status codes that can be specified\n  through :ref:`x-envoy-retry-grpc-on <config_http_filters_router_x-envoy-retry-grpc-on>`.\n* sockets: added :ref:`tap transport socket extension <operations_traffic_tapping>` to support\n  recording plain text traffic and PCAP generation.\n* sockets: added `IP_FREEBIND` socket option support for :ref:`listeners\n  <envoy_api_field_Listener.freebind>` and upstream connections via\n  :ref:`cluster manager wide\n  <envoy_api_field_config.bootstrap.v2.ClusterManager.upstream_bind_config>` and\n  :ref:`cluster specific <envoy_api_field_Cluster.upstream_bind_config>` options.\n* sockets: added `IP_TRANSPARENT` socket option support for :ref:`listeners\n  <envoy_api_field_Listener.transparent>`.\n* sockets: added `SO_KEEPALIVE` socket option for upstream connections\n  :ref:`per cluster <envoy_api_field_Cluster.upstream_connection_options>`.\n* stats: added support for histograms.\n* stats: added :ref:`option to configure the statsd prefix<envoy_api_field_config.metrics.v2.StatsdSink.prefix>`.\n* stats: updated stats sink interface to flush through a single call.\n* tls: added support for\n  :ref:`verify_certificate_spki <envoy_api_field_auth.CertificateValidationContext.verify_certificate_spki>`.\n* tls: added support for multiple\n  :ref:`verify_certificate_hash <envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash>`\n  values.\n* tls: added support for using\n  :ref:`verify_certificate_spki <envoy_api_field_auth.CertificateValidationContext.verify_certificate_spki>`\n  and :ref:`verify_certificate_hash <envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash>`\n  without :ref:`trusted_ca <envoy_api_field_auth.CertificateValidationContext.trusted_ca>`.\n* tls: added support for allowing expired certificates with\n  :ref:`allow_expired_certificate <envoy_api_field_auth.CertificateValidationContext.allow_expired_certificate>`.\n* tls: added support for :ref:`renegotiation <envoy_api_field_auth.UpstreamTlsContext.allow_renegotiation>`\n  when acting as a client.\n* tls: removed support for legacy SHA-2 CBC cipher suites.\n* tracing: the sampling decision is now delegated to the tracers, allowing the tracer to decide when and if\n  to use it. For example, if the :ref:`x-b3-sampled <config_http_conn_man_headers_x-b3-sampled>` header\n  is supplied with the client request, its value will override any sampling decision made by the Envoy proxy.\n* websocket: support configuring idle_timeout and max_connect_attempts.\n* upstream: added support for host override for a request in :ref:`Original destination host request header <arch_overview_load_balancing_types_original_destination_request_header>`.\n* header to metadata: added :ref:`HTTP Header to Metadata filter<config_http_filters_header_to_metadata>`.\n\n1.6.0 (March 20, 2018)\n======================\n\n* access log: added DOWNSTREAM_REMOTE_ADDRESS, DOWNSTREAM_REMOTE_ADDRESS_WITHOUT_PORT, and\n  DOWNSTREAM_LOCAL_ADDRESS :ref:`access log formatters <config_access_log_format>`.\n  DOWNSTREAM_ADDRESS access log formatter has been deprecated.\n* access log: added less than or equal (LE) :ref:`comparison filter\n  <envoy_api_msg_config.filter.accesslog.v2.ComparisonFilter>`.\n* access log: added configuration to :ref:`runtime filter\n  <envoy_api_msg_config.filter.accesslog.v2.RuntimeFilter>` to set default sampling rate, divisor,\n  and whether to use independent randomness or not.\n* admin: added :ref:`/runtime <operations_admin_interface_runtime>` admin endpoint to read the\n  current runtime values.\n* build: added support for :repo:`building Envoy with exported symbols\n  <bazel#enabling-optional-features>`. This change allows scripts loaded with the Lua filter to\n  load shared object libraries such as those installed via `LuaRocks <https://luarocks.org/>`_.\n* config: added support for sending error details as\n  `grpc.rpc.Status <https://github.com/googleapis/googleapis/blob/master/google/rpc/status.proto>`_\n  in :ref:`DiscoveryRequest <envoy_api_msg_DiscoveryRequest>`.\n* config: added support for :ref:`inline delivery <envoy_api_msg_core.DataSource>` of TLS\n  certificates and private keys.\n* config: added restrictions for the backing :ref:`config sources <envoy_api_msg_core.ConfigSource>`\n  of xDS resources. For filesystem based xDS the file must exist at configuration time. For cluster\n  based xDS the backing cluster must be statically defined and be of non-EDS type.\n* grpc: the Google gRPC C++ library client is now supported as specified in the :ref:`gRPC services\n  overview <arch_overview_grpc_services>` and :ref:`GrpcService <envoy_api_msg_core.GrpcService>`.\n* grpc-json: added support for :ref:`inline descriptors\n  <envoy_api_field_config.filter.http.transcoder.v2.GrpcJsonTranscoder.proto_descriptor_bin>`.\n* health check: added :ref:`gRPC health check <envoy_api_field_core.HealthCheck.grpc_health_check>`\n  based on `grpc.health.v1.Health <https://github.com/grpc/grpc/blob/master/src/proto/grpc/health/v1/health.proto>`_\n  service.\n* health check: added ability to set :ref:`host header value\n  <envoy_api_field_core.HealthCheck.HttpHealthCheck.host>` for http health check.\n* health check: extended the health check filter to support computation of the health check response\n  based on the :ref:`percentage of healthy servers in upstream clusters\n  <envoy_api_field_config.filter.http.health_check.v2.HealthCheck.cluster_min_healthy_percentages>`.\n* health check: added setting for :ref:`no-traffic\n  interval<envoy_api_field_core.HealthCheck.no_traffic_interval>`.\n* http: added idle timeout for :ref:`upstream http connections\n  <envoy_api_field_core.HttpProtocolOptions.idle_timeout>`.\n* http: added support for :ref:`proxying 100-Continue responses\n  <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.proxy_100_continue>`.\n* http: added the ability to pass a URL encoded PEM encoded peer certificate in the\n  :ref:`config_http_conn_man_headers_x-forwarded-client-cert` header.\n* http: added support for trusting additional hops in the\n  :ref:`config_http_conn_man_headers_x-forwarded-for` request header.\n* http: added support for :ref:`incoming HTTP/1.0\n  <envoy_api_field_core.Http1ProtocolOptions.accept_http_10>`.\n* hot restart: added SIGTERM propagation to children to :ref:`hot-restarter.py\n  <operations_hot_restarter>`, which enables using it as a parent of containers.\n* ip tagging: added :ref:`HTTP IP Tagging filter<config_http_filters_ip_tagging>`.\n* listeners: added support for :ref:`listening for both IPv4 and IPv6\n  <envoy_api_field_core.SocketAddress.ipv4_compat>` when binding to ::.\n* listeners: added support for listening on :ref:`UNIX domain sockets\n  <envoy_api_field_core.Address.pipe>`.\n* listeners: added support for :ref:`abstract unix domain sockets <envoy_api_msg_core.Pipe>` on\n  Linux. The abstract namespace can be used by prepending '@' to a socket path.\n* load balancer: added cluster configuration for :ref:`healthy panic threshold\n  <envoy_api_field_Cluster.CommonLbConfig.healthy_panic_threshold>` percentage.\n* load balancer: added :ref:`Maglev <arch_overview_load_balancing_types_maglev>` consistent hash\n  load balancer.\n* load balancer: added support for\n  :ref:`LocalityLbEndpoints<envoy_api_msg_endpoint.LocalityLbEndpoints>` priorities.\n* lua: added headers :ref:`replace() <config_http_filters_lua_header_wrapper>` API.\n* lua: extended to support :ref:`metadata object <config_http_filters_lua_metadata_wrapper>` API.\n* redis: added local `PING` support to the :ref:`Redis filter <arch_overview_redis>`.\n* redis: added `GEORADIUS_RO` and `GEORADIUSBYMEMBER_RO` to the :ref:`Redis command splitter\n  <arch_overview_redis>` whitelist.\n* router: added DOWNSTREAM_REMOTE_ADDRESS_WITHOUT_PORT, DOWNSTREAM_LOCAL_ADDRESS,\n  DOWNSTREAM_LOCAL_ADDRESS_WITHOUT_PORT, PROTOCOL, and UPSTREAM_METADATA :ref:`header\n  formatters <config_http_conn_man_headers_custom_request_headers>`. The CLIENT_IP header formatter\n  has been deprecated.\n* router: added gateway-error :ref:`retry-on <config_http_filters_router_x-envoy-retry-on>` policy.\n* router: added support for route matching based on :ref:`URL query string parameters\n  <envoy_api_msg_route.QueryParameterMatcher>`.\n* router: added support for more granular weighted cluster routing by allowing the :ref:`total_weight\n  <envoy_api_field_route.WeightedCluster.total_weight>` to be specified in configuration.\n* router: added support for :ref:`custom request/response headers\n  <config_http_conn_man_headers_custom_request_headers>` with mixed static and dynamic values.\n* router: added support for :ref:`direct responses <envoy_api_field_route.Route.direct_response>`.\n  I.e., sending a preconfigured HTTP response without proxying anywhere.\n* router: added support for :ref:`HTTPS redirects\n  <envoy_api_field_route.RedirectAction.https_redirect>` on specific routes.\n* router: added support for :ref:`prefix_rewrite\n  <envoy_api_field_route.RedirectAction.prefix_rewrite>` for redirects.\n* router: added support for :ref:`stripping the query string\n  <envoy_api_field_route.RedirectAction.strip_query>` for redirects.\n* router: added support for downstream request/upstream response\n  :ref:`header manipulation <config_http_conn_man_headers_custom_request_headers>` in :ref:`weighted\n  cluster <envoy_api_msg_route.WeightedCluster>`.\n* router: added support for :ref:`range based header matching\n  <envoy_api_field_route.HeaderMatcher.range_match>` for request routing.\n* squash: added support for the :ref:`Squash microservices debugger <config_http_filters_squash>`.\n  Allows debugging an incoming request to a microservice in the mesh.\n* stats: added metrics service API implementation.\n* stats: added native :ref:`DogStatsd <envoy_api_msg_config.metrics.v2.DogStatsdSink>` support.\n* stats: added support for :ref:`fixed stats tag values\n  <envoy_api_field_config.metrics.v2.TagSpecifier.fixed_value>` which will be added to all metrics.\n* tcp proxy: added support for specifying a :ref:`metadata matcher\n  <envoy_api_field_config.filter.network.tcp_proxy.v2.TcpProxy.metadata_match>` for upstream\n  clusters in the tcp filter.\n* tcp proxy: improved TCP proxy to correctly proxy TCP half-close.\n* tcp proxy: added :ref:`idle timeout\n  <envoy_api_field_config.filter.network.tcp_proxy.v2.TcpProxy.idle_timeout>`.\n* tcp proxy: access logs now bring an IP address without a port when using DOWNSTREAM_ADDRESS.\n  Use :ref:`DOWNSTREAM_REMOTE_ADDRESS <config_access_log_format>` instead.\n* tracing: added support for dynamically loading an :ref:`OpenTracing tracer\n  <envoy_api_msg_config.trace.v2.DynamicOtConfig>`.\n* tracing: when using the Zipkin tracer, it is now possible for clients to specify the sampling\n  decision (using the :ref:`x-b3-sampled <config_http_conn_man_headers_x-b3-sampled>` header) and\n  have the decision propagated through to subsequently invoked services.\n* tracing: when using the Zipkin tracer, it is no longer necessary to propagate the\n  :ref:`x-ot-span-context <config_http_conn_man_headers_x-ot-span-context>` header.\n  See more on trace context propagation :ref:`here <arch_overview_tracing>`.\n* transport sockets: added transport socket interface to allow custom implementations of transport\n  sockets. A transport socket provides read and write logic with buffer encryption and decryption\n  (if applicable). The existing TLS implementation has been refactored with the interface.\n* upstream: added support for specifying an :ref:`alternate stats name\n  <envoy_api_field_Cluster.alt_stat_name>` while emitting stats for clusters.\n* Many small bug fixes and performance improvements not listed.\n\n1.5.0 (December 4, 2017)\n========================\n\n* access log: added fields for :ref:`UPSTREAM_LOCAL_ADDRESS and DOWNSTREAM_ADDRESS\n  <config_access_log_format>`.\n* admin: added :ref:`JSON output <operations_admin_interface_stats>` for stats admin endpoint.\n* admin: added basic :ref:`Prometheus output <operations_admin_interface_stats>` for stats admin\n  endpoint. Histograms are not currently output.\n* admin: added ``version_info`` to the :ref:`/clusters admin endpoint<operations_admin_interface_clusters>`.\n* config: the :ref:`v2 API <config_overview_v2>` is now considered production ready.\n* config: added --v2-config-only CLI flag.\n* cors: added :ref:`CORS filter <config_http_filters_cors>`.\n* health check: added :ref:`x-envoy-immediate-health-check-fail\n  <config_http_filters_router_x-envoy-immediate-health-check-fail>` header support.\n* health check: added :ref:`reuse_connection <envoy_api_field_core.HealthCheck.reuse_connection>` option.\n* http: added :ref:`per-listener stats <config_http_conn_man_stats_per_listener>`.\n* http: end-to-end HTTP flow control is now complete across both connections, streams, and filters.\n* load balancer: added :ref:`subset load balancer <arch_overview_load_balancer_subsets>`.\n* load balancer: added ring size and hash :ref:`configuration options\n  <envoy_api_msg_Cluster.RingHashLbConfig>`. This used to be configurable via runtime. The runtime\n  configuration was deleted without deprecation as we are fairly certain no one is using it.\n* log: added the ability to optionally log to a file instead of stderr via the\n  :option:`--log-path` option.\n* listeners: added :ref:`drain_type <envoy_api_field_Listener.drain_type>` option.\n* lua: added experimental :ref:`Lua filter <config_http_filters_lua>`.\n* mongo filter: added :ref:`fault injection <config_network_filters_mongo_proxy_fault_injection>`.\n* mongo filter: added :ref:`\"drain close\" <arch_overview_draining>` support.\n* outlier detection: added :ref:`HTTP gateway failure type <arch_overview_outlier_detection>`.\n  See :ref:`deprecated log <deprecated>`\n  for outlier detection stats deprecations in this release.\n* redis: the :ref:`redis proxy filter <config_network_filters_redis_proxy>` is now considered\n  production ready.\n* redis: added :ref:`\"drain close\" <arch_overview_draining>` functionality.\n* router: added :ref:`x-envoy-overloaded <config_http_filters_router_x-envoy-overloaded_set>` support.\n* router: added :ref:`regex <envoy_api_field_route.RouteMatch.regex>` route matching.\n* router: added :ref:`custom request headers <config_http_conn_man_headers_custom_request_headers>`\n  for upstream requests.\n* router: added :ref:`downstream IP hashing\n  <envoy_api_field_route.RouteAction.HashPolicy.connection_properties>` for HTTP ketama routing.\n* router: added :ref:`cookie hashing <envoy_api_field_route.RouteAction.HashPolicy.cookie>`.\n* router: added :ref:`start_child_span <envoy_api_field_config.filter.http.router.v2.Router.start_child_span>` option\n  to create child span for egress calls.\n* router: added optional :ref:`upstream logs <envoy_api_field_config.filter.http.router.v2.Router.upstream_log>`.\n* router: added complete :ref:`custom append/override/remove support\n  <config_http_conn_man_headers_custom_request_headers>` of request/response headers.\n* router: added support to :ref:`specify response code during redirect\n  <envoy_api_field_route.RedirectAction.response_code>`.\n* router: added :ref:`configuration <envoy_api_field_route.RouteAction.cluster_not_found_response_code>`\n  to return either a 404 or 503 if the upstream cluster does not exist.\n* runtime: added :ref:`comment capability <config_runtime_comments>`.\n* server: change default log level (:option:`-l`) to `info`.\n* stats: maximum stat/name sizes and maximum number of stats are now variable via the\n  `--max-obj-name-len` and `--max-stats` options.\n* tcp proxy: added :ref:`access logging <envoy_api_field_config.filter.network.tcp_proxy.v2.TcpProxy.access_log>`.\n* tcp proxy: added :ref:`configurable connect retries\n  <envoy_api_field_config.filter.network.tcp_proxy.v2.TcpProxy.max_connect_attempts>`.\n* tcp proxy: enable use of :ref:`outlier detector <arch_overview_outlier_detection>`.\n* tls: added :ref:`SNI support <faq_how_to_setup_sni>`.\n* tls: added support for specifying :ref:`TLS session ticket keys\n  <envoy_api_field_auth.DownstreamTlsContext.session_ticket_keys>`.\n* tls: allow configuration of the :ref:`min\n  <envoy_api_field_auth.TlsParameters.tls_minimum_protocol_version>` and :ref:`max\n  <envoy_api_field_auth.TlsParameters.tls_maximum_protocol_version>` TLS protocol versions.\n* tracing: added :ref:`custom trace span decorators <envoy_api_field_route.Route.decorator>`.\n* Many small bug fixes and performance improvements not listed.\n\n1.4.0 (August 24, 2017)\n=======================\n\n* macOS is :repo:`now supported </bazel#quick-start-bazel-build-for-developers>`. (A few features\n  are missing such as hot restart and original destination routing).\n* YAML is now directly supported for config files.\n* Added /routes admin endpoint.\n* End-to-end flow control is now supported for TCP proxy, HTTP/1, and HTTP/2. HTTP flow control\n  that includes filter buffering is incomplete and will be implemented in 1.5.0.\n* Log verbosity :repo:`compile time flag </bazel#log-verbosity>` added.\n* Hot restart :repo:`compile time flag </bazel#hot-restart>` added.\n* Original destination :ref:`cluster <arch_overview_service_discovery_types_original_destination>`\n  and :ref:`load balancer <arch_overview_load_balancing_types_original_destination>` added.\n* :ref:`WebSocket <arch_overview_websocket>` is now supported.\n* Virtual cluster priorities have been hard removed without deprecation as we are reasonably sure\n  no one is using this feature.\n* Route `validate_clusters` option added.\n* :ref:`x-envoy-downstream-service-node <config_http_conn_man_headers_downstream-service-node>`\n  header added.\n* :ref:`x-forwarded-client-cert <config_http_conn_man_headers_x-forwarded-client-cert>` header\n  added.\n* Initial HTTP/1 forward proxy support for absolute URLs has been added.\n* HTTP/2 codec settings are now configurable.\n* gRPC/JSON transcoder :ref:`filter <config_http_filters_grpc_json_transcoder>` added.\n* gRPC web :ref:`filter <config_http_filters_grpc_web>` added.\n* Configurable timeout for the rate limit service call in the :ref:`network\n  <config_network_filters_rate_limit>` and :ref:`HTTP <config_http_filters_rate_limit>` rate limit\n  filters.\n* :ref:`x-envoy-retry-grpc-on <config_http_filters_router_x-envoy-retry-grpc-on>` header added.\n* :ref:`LDS API <arch_overview_dynamic_config_lds>` added.\n* TLS :`require_client_certificate` option added.\n* :ref:`Configuration check tool <install_tools_config_load_check_tool>` added.\n* :ref:`JSON schema check tool <install_tools_schema_validator_check_tool>` added.\n* Config validation mode added via the :option:`--mode` option.\n* :option:`--local-address-ip-version` option added.\n* IPv6 support is now complete.\n* UDP `statsd_ip_address` option added.\n* Per-cluster DNS resolvers added.\n* :ref:`Fault filter <config_http_filters_fault_injection>` enhancements and fixes.\n* Several features are :ref:`deprecated as of the 1.4.0 release <deprecated>`. They\n  will be removed at the beginning of the 1.5.0 release cycle. We explicitly call out that the\n  `HttpFilterConfigFactory` filter API has been deprecated in favor of\n  `NamedHttpFilterConfigFactory`.\n* Many small bug fixes and performance improvements not listed.\n\n1.3.0 (May 17, 2017)\n====================\n\n* As of this release, we now have an official :repo:`breaking change policy\n  </CONTRIBUTING.md#breaking-change-policy>`. Note that there are numerous breaking configuration\n  changes in this release. They are not listed here. Future releases will adhere to the policy and\n  have clear documentation on deprecations and changes.\n* Bazel is now the canonical build system (replacing CMake). There have been a huge number of\n  changes to the development/build/test flow. See :repo:`/bazel/README.md` and\n  :repo:`/ci/README.md` for more information.\n* :ref:`Outlier detection <arch_overview_outlier_detection>` has been expanded to include success\n  rate variance, and all parameters are now configurable in both runtime and in the JSON\n  configuration.\n* TCP level listener and cluster connections now have configurable receive buffer\n  limits at which point connection level back pressure is applied.\n  Full end to end flow control will be available in a future release.\n* :ref:`Redis health checking <config_cluster_manager_cluster_hc>` has been added as an active\n  health check type. Full Redis support will be documented/supported in 1.4.0.\n* :ref:`TCP health checking <config_cluster_manager_cluster_hc_tcp_health_checking>` now supports a\n  \"connect only\" mode that only checks if the remote server can be connected to without\n  writing/reading any data.\n* `BoringSSL <https://boringssl.googlesource.com/boringssl>`_ is now the only supported TLS provider.\n  The default cipher suites and ECDH curves have been updated with more modern defaults for both\n  listener and cluster connections.\n* The `header value match` rate limit action has been expanded to include an `expect\n  match` parameter.\n* Route level HTTP rate limit configurations now do not inherit the virtual host level\n  configurations by default. Use `include_vh_rate_limits` to inherit the virtual host\n  level options if desired.\n* HTTP routes can now add request headers on a per route and per virtual host basis via the\n  :ref:`request_headers_to_add <config_http_conn_man_headers_custom_request_headers>` option.\n* The :ref:`example configurations <install_ref_configs>` have been refreshed to demonstrate the\n  latest features.\n* `per_try_timeout_ms` can now be configured in\n  a route's retry policy in addition to via the :ref:`x-envoy-upstream-rq-per-try-timeout-ms\n  <config_http_filters_router_x-envoy-upstream-rq-per-try-timeout-ms>` HTTP header.\n* HTTP virtual host matching now includes support for prefix wildcard domains (e.g., `*.lyft.com`).\n* The default for tracing random sampling has been changed to 100% and is still configurable in\n  :ref:`runtime <config_http_conn_man_runtime>`.\n* HTTP tracing configuration has been extended to allow tags\n  to be populated from arbitrary HTTP headers.\n* The :ref:`HTTP rate limit filter <config_http_filters_rate_limit>` can now be applied to internal,\n  external, or all requests via the `request_type` option.\n* :ref:`Listener binding <config_listeners>` now requires specifying an `address` field. This can be\n  used to bind a listener to both a specific address as well as a port.\n* The :ref:`MongoDB filter <config_network_filters_mongo_proxy>` now emits a stat for queries that\n  do not have `$maxTimeMS` set.\n* The :ref:`MongoDB filter <config_network_filters_mongo_proxy>` now emits logs that are fully valid\n  JSON.\n* The CPU profiler output path is now configurable.\n* A watchdog system has been added that can kill the server if a deadlock is detected.\n* A :ref:`route table checking tool <install_tools_route_table_check_tool>` has been added that can\n  be used to test route tables before use.\n* We have added an :ref:`example repo <extending>` that shows how to compile/link a custom filter.\n* Added additional cluster wide information related to outlier detection to the :ref:`/clusters\n  admin endpoint <operations_admin_interface>`.\n* Multiple SANs can now be verified via the `verify_subject_alt_name` setting.\n  Additionally, URI type SANs can be verified.\n* HTTP filters can now be passed opaque configuration specified on a per route basis.\n* By default Envoy now has a built in crash handler that will print a back trace. This behavior can\n  be disabled if desired via the ``--define=signal_trace=disabled`` Bazel option.\n* Zipkin has been added as a supported :ref:`tracing provider <arch_overview_tracing>`.\n* Numerous small changes and fixes not listed here.\n\n1.2.0 (March 7, 2017)\n=====================\n\n* :ref:`Cluster discovery service (CDS) API <config_cluster_manager_cds>`.\n* :ref:`Outlier detection <arch_overview_outlier_detection>` (passive health checking).\n* Envoy configuration is now checked against a JSON schema.\n* :ref:`Ring hash <arch_overview_load_balancing_types>` consistent load balancer, as well as HTTP\n  consistent hash routing based on a policy.\n* Vastly :ref:`enhanced global rate limit configuration <arch_overview_rate_limit>` via the HTTP\n  rate limiting filter.\n* HTTP routing to a cluster retrieved from a header.\n* Weighted cluster HTTP routing.\n* Auto host rewrite during HTTP routing.\n* Regex header matching during HTTP routing.\n* HTTP access log runtime filter.\n* LightStep tracer :ref:`parent/child span association <arch_overview_tracing>`.\n* :ref:`Route discovery service (RDS) API <config_http_conn_man_rds>`.\n* HTTP router :ref:`x-envoy-upstream-rq-timeout-alt-response header\n  <config_http_filters_router_x-envoy-upstream-rq-timeout-alt-response>` support.\n* *use_original_dst* and *bind_to_port* :ref:`listener options <config_listeners>` (useful for\n  iptables based transparent proxy support).\n* TCP proxy filter :ref:`route table support <config_network_filters_tcp_proxy>`.\n* Configurable stats flush interval.\n* Various :ref:`third party library upgrades <install_requirements>`, including using BoringSSL as\n  the default SSL provider.\n* No longer maintain closed HTTP/2 streams for priority calculations. Leads to substantial memory\n  savings for large meshes.\n* Numerous small changes and fixes not listed here.\n\n1.1.0 (November 30, 2016)\n=========================\n\n* Switch from Jannson to RapidJSON for our JSON library (allowing for a configuration schema in\n  1.2.0).\n* Upgrade :ref:`recommended version <install_requirements>` of various other libraries.\n* Configurable DNS refresh rate for DNS service discovery types.\n* Upstream circuit breaker configuration can be :ref:`overridden via runtime\n  <config_cluster_manager_cluster_runtime>`.\n* :ref:`Zone aware routing support <arch_overview_load_balancing_zone_aware_routing>`.\n* Generic header matching routing rule.\n* HTTP/2 graceful connection draining (double GOAWAY).\n* DynamoDB filter :ref:`per shard statistics <config_http_filters_dynamo>` (pre-release AWS\n  feature).\n* Initial release of the :ref:`fault injection HTTP filter <config_http_filters_fault_injection>`.\n* HTTP :ref:`rate limit filter <config_http_filters_rate_limit>` enhancements (note that the\n  configuration for HTTP rate limiting is going to be overhauled in 1.2.0).\n* Added :ref:`refused-stream retry policy <config_http_filters_router_x-envoy-retry-on>`.\n* Multiple :ref:`priority queues <arch_overview_http_routing_priority>` for upstream clusters\n  (configurable on a per route basis, with separate connection pools, circuit breakers, etc.).\n* Added max connection circuit breaking to the :ref:`TCP proxy filter <arch_overview_tcp_proxy>`.\n* Added :ref:`CLI <operations_cli>` options for setting the logging file flush interval as well\n  as the drain/shutdown time during hot restart.\n* A very large number of performance enhancements for core HTTP/TCP proxy flows as well as a\n  few new configuration flags to allow disabling expensive features if they are not needed\n  (specifically request ID generation and dynamic response code stats).\n* Support Mongo 3.2 in the :ref:`Mongo sniffing filter <config_network_filters_mongo_proxy>`.\n* Lots of other small fixes and enhancements not listed.\n\n1.0.0 (September 12, 2016)\n==========================\n\nInitial open source release.\n", "#pragma once\n\n#include <memory>\n#include <string>\n\n#include \"envoy/common/pure.h\"\n#include \"envoy/http/header_map.h\"\n#include \"envoy/stream_info/stream_info.h\"\n\nnamespace Envoy {\nnamespace AccessLog {\n\nclass AccessLogFile {\npublic:\n  virtual ~AccessLogFile() = default;\n\n  /**\n   * Write data to the file.\n   */\n  virtual void write(absl::string_view) PURE;\n\n  /**\n   * Reopen the file.\n   */\n  virtual void reopen() PURE;\n\n  /**\n   * Synchronously flush all pending data to disk.\n   */\n  virtual void flush() PURE;\n};\n\nusing AccessLogFileSharedPtr = std::shared_ptr<AccessLogFile>;\n\nclass AccessLogManager {\npublic:\n  virtual ~AccessLogManager() = default;\n\n  /**\n   * Reopen all of the access log files.\n   */\n  virtual void reopen() PURE;\n\n  /**\n   * Create a new access log file managed by the access log manager.\n   * @param file_name specifies the file to create/open.\n   * @return the opened file.\n   */\n  virtual AccessLogFileSharedPtr createAccessLog(const std::string& file_name) PURE;\n};\n\nusing AccessLogManagerPtr = std::unique_ptr<AccessLogManager>;\n\n/**\n * Interface for access log filters.\n */\nclass Filter {\npublic:\n  virtual ~Filter() = default;\n\n  /**\n   * Evaluate whether an access log should be written based on request and response data.\n   * @return TRUE if the log should be written.\n   */\n  virtual bool evaluate(const StreamInfo::StreamInfo& info, const Http::HeaderMap& request_headers,\n                        const Http::HeaderMap& response_headers,\n                        const Http::HeaderMap& response_trailers) PURE;\n};\n\nusing FilterPtr = std::unique_ptr<Filter>;\n\n/**\n * Abstract access logger for requests and connections.\n */\nclass Instance {\npublic:\n  virtual ~Instance() = default;\n\n  /**\n   * Log a completed request.\n   * Prior to logging, call refreshByteSize() on HeaderMaps to ensure that an accurate byte size\n   * count is logged.\n   * TODO(asraa): Remove refreshByteSize() requirement when entries in HeaderMap can no longer be\n   * modified by reference and headerMap holds an accurate internal byte size count.\n   * @param request_headers supplies the incoming request headers after filtering.\n   * @param response_headers supplies response headers.\n   * @param response_trailers supplies response trailers.\n   * @param stream_info supplies additional information about the request not\n   * contained in the request headers.\n   */\n  virtual void log(const Http::HeaderMap* request_headers, const Http::HeaderMap* response_headers,\n                   const Http::HeaderMap* response_trailers,\n                   const StreamInfo::StreamInfo& stream_info) PURE;\n};\n\nusing InstanceSharedPtr = std::shared_ptr<Instance>;\n\n/**\n * Interface for access log formatter.\n * Formatters provide a complete access log output line for the given headers/trailers/stream.\n */\nclass Formatter {\npublic:\n  virtual ~Formatter() = default;\n\n  /**\n   * Return a formatted access log line.\n   * @param request_headers supplies the request headers.\n   * @param response_headers supplies the response headers.\n   * @param response_trailers supplies the response trailers.\n   * @param stream_info supplies the stream info.\n   * @return std::string string containing the complete formatted access log line.\n   */\n  virtual std::string format(const Http::HeaderMap& request_headers,\n                             const Http::HeaderMap& response_headers,\n                             const Http::HeaderMap& response_trailers,\n                             const StreamInfo::StreamInfo& stream_info) const PURE;\n};\n\nusing FormatterPtr = std::unique_ptr<Formatter>;\n\n/**\n * Interface for access log provider.\n * FormatterProviders extract information from the given headers/trailers/stream.\n */\nclass FormatterProvider {\npublic:\n  virtual ~FormatterProvider() = default;\n\n  /**\n   * Extract a value from the provided headers/trailers/stream.\n   * @param request_headers supplies the request headers.\n   * @param response_headers supplies the response headers.\n   * @param response_trailers supplies the response trailers.\n   * @param stream_info supplies the stream info.\n   * @return std::string containing a single value extracted from the given headers/trailers/stream.\n   */\n  virtual std::string format(const Http::HeaderMap& request_headers,\n                             const Http::HeaderMap& response_headers,\n                             const Http::HeaderMap& response_trailers,\n                             const StreamInfo::StreamInfo& stream_info) const PURE;\n};\n\nusing FormatterProviderPtr = std::unique_ptr<FormatterProvider>;\n\n} // namespace AccessLog\n} // namespace Envoy\n", "#pragma once\n\n#include <algorithm>\n#include <cstdint>\n#include <cstring>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <unordered_set>\n#include <vector>\n\n#include \"envoy/common/pure.h\"\n\n#include \"common/common/assert.h\"\n#include \"common/common/hash.h\"\n#include \"common/common/macros.h\"\n\n#include \"absl/strings/string_view.h\"\n\nnamespace Envoy {\nnamespace Http {\n\n// Used by ASSERTs to validate internal consistency. E.g. valid HTTP header keys/values should\n// never contain embedded NULLs.\nstatic inline bool validHeaderString(absl::string_view s) {\n  // If you modify this list of illegal embedded characters you will probably\n  // want to change header_map_fuzz_impl_test at the same time.\n  for (const char c : s) {\n    switch (c) {\n    case '\\0':\n      FALLTHRU;\n    case '\\r':\n      FALLTHRU;\n    case '\\n':\n      return false;\n    default:\n      continue;\n    }\n  }\n  return true;\n}\n\n/**\n * Wrapper for a lower case string used in header operations to generally avoid needless case\n * insensitive compares.\n */\nclass LowerCaseString {\npublic:\n  LowerCaseString(LowerCaseString&& rhs) noexcept : string_(std::move(rhs.string_)) {\n    ASSERT(valid());\n  }\n  LowerCaseString(const LowerCaseString& rhs) : string_(rhs.string_) { ASSERT(valid()); }\n  explicit LowerCaseString(const std::string& new_string) : string_(new_string) {\n    ASSERT(valid());\n    lower();\n  }\n\n  const std::string& get() const { return string_; }\n  bool operator==(const LowerCaseString& rhs) const { return string_ == rhs.string_; }\n  bool operator!=(const LowerCaseString& rhs) const { return string_ != rhs.string_; }\n  bool operator<(const LowerCaseString& rhs) const { return string_.compare(rhs.string_) < 0; }\n\nprivate:\n  void lower() { std::transform(string_.begin(), string_.end(), string_.begin(), tolower); }\n  bool valid() const { return validHeaderString(string_); }\n\n  std::string string_;\n};\n\n/**\n * Lower case string hasher.\n */\nstruct LowerCaseStringHash {\n  size_t operator()(const LowerCaseString& value) const { return HashUtil::xxHash64(value.get()); }\n};\n\n/**\n * Convenient type for unordered set of lower case string.\n */\nusing LowerCaseStrUnorderedSet = std::unordered_set<LowerCaseString, LowerCaseStringHash>;\n\n/**\n * Convenient type for a vector of lower case string and string pair.\n */\nusing LowerCaseStrPairVector =\n    std::vector<std::pair<const Http::LowerCaseString, const std::string>>;\n\n/**\n * This is a string implementation for use in header processing. It is heavily optimized for\n * performance. It supports 3 different types of storage and can switch between them:\n * 1) A reference.\n * 2) Interned string.\n * 3) Heap allocated storage.\n */\nclass HeaderString {\npublic:\n  enum class Type { Inline, Reference, Dynamic };\n\n  /**\n   * Default constructor. Sets up for inline storage.\n   */\n  HeaderString();\n\n  /**\n   * Constructor for a string reference.\n   * @param ref_value MUST point to data that will live beyond the lifetime of any request/response\n   *        using the string (since a codec may optimize for zero copy).\n   */\n  explicit HeaderString(const LowerCaseString& ref_value);\n\n  /**\n   * Constructor for a string reference.\n   * @param ref_value MUST point to data that will live beyond the lifetime of any request/response\n   *        using the string (since a codec may optimize for zero copy).\n   */\n  explicit HeaderString(const std::string& ref_value);\n\n  HeaderString(HeaderString&& move_value) noexcept;\n  ~HeaderString();\n\n  /**\n   * Append data to an existing string. If the string is a reference string the reference data is\n   * not copied.\n   */\n  void append(const char* data, uint32_t size);\n\n  /**\n   * @return the modifiable backing buffer (either inline or heap allocated).\n   */\n  char* buffer() { return buffer_.dynamic_; }\n\n  /**\n   * Get an absl::string_view. It will NOT be NUL terminated!\n   *\n   * @return an absl::string_view.\n   */\n  absl::string_view getStringView() const { return {buffer_.ref_, string_length_}; }\n\n  /**\n   * Return the string to a default state. Reference strings are not touched. Both inline/dynamic\n   * strings are reset to zero size.\n   */\n  void clear();\n\n  /**\n   * @return whether the string is empty or not.\n   */\n  bool empty() const { return string_length_ == 0; }\n\n  // Looking for find? Use getStringView().find()\n\n  /**\n   * Set the value of the string by copying data into it. This overwrites any existing string.\n   */\n  void setCopy(const char* data, uint32_t size);\n\n  /**\n   * Set the value of the string by copying data into it. This overwrites any existing string.\n   */\n  void setCopy(absl::string_view view);\n\n  /**\n   * Set the value of the string to an integer. This overwrites any existing string.\n   */\n  void setInteger(uint64_t value);\n\n  /**\n   * Set the value of the string to a string reference.\n   * @param ref_value MUST point to data that will live beyond the lifetime of any request/response\n   *        using the string (since a codec may optimize for zero copy).\n   */\n  void setReference(const std::string& ref_value);\n\n  /**\n   * @return the size of the string, not including the null terminator.\n   */\n  uint32_t size() const { return string_length_; }\n\n  /**\n   * @return the type of backing storage for the string.\n   */\n  Type type() const { return type_; }\n\n  bool operator==(const char* rhs) const { return getStringView() == absl::string_view(rhs); }\n  bool operator==(absl::string_view rhs) const { return getStringView() == rhs; }\n  bool operator!=(const char* rhs) const { return getStringView() != absl::string_view(rhs); }\n  bool operator!=(absl::string_view rhs) const { return getStringView() != rhs; }\n\nprivate:\n  union Buffer {\n    // This should reference inline_buffer_ for Type::Inline.\n    char* dynamic_;\n    const char* ref_;\n  } buffer_;\n\n  // Capacity in both Type::Inline and Type::Dynamic cases must be at least MinDynamicCapacity in\n  // header_map_impl.cc.\n  union {\n    char inline_buffer_[128];\n    // Since this is a union, this is only valid for type_ == Type::Dynamic.\n    uint32_t dynamic_capacity_;\n  };\n\n  void freeDynamic();\n  bool valid() const;\n\n  uint32_t string_length_;\n  Type type_;\n};\n\n/**\n * Encapsulates an individual header entry (including both key and value).\n */\nclass HeaderEntry {\npublic:\n  virtual ~HeaderEntry() = default;\n\n  /**\n   * @return the header key.\n   */\n  virtual const HeaderString& key() const PURE;\n\n  /**\n   * Set the header value by copying data into it (deprecated, use absl::string_view variant\n   * instead).\n   * TODO(htuch): Cleanup deprecated call sites.\n   */\n  virtual void value(const char* value, uint32_t size) PURE;\n\n  /**\n   * Set the header value by copying data into it.\n   */\n  virtual void value(absl::string_view value) PURE;\n\n  /**\n   * Set the header value by copying an integer into it.\n   */\n  virtual void value(uint64_t value) PURE;\n\n  /**\n   * Set the header value by copying the value in another header entry.\n   */\n  virtual void value(const HeaderEntry& header) PURE;\n\n  /**\n   * @return the header value.\n   */\n  virtual const HeaderString& value() const PURE;\n\n  /**\n   * @return the header value.\n   */\n  virtual HeaderString& value() PURE;\n\nprivate:\n  void value(const char*); // Do not allow auto conversion to std::string\n};\n\n/**\n * The following defines all headers that Envoy allows direct access to inside of the header map.\n * In practice, these are all headers used during normal Envoy request flow processing. This allows\n * O(1) access to these headers without even a hash lookup.\n */\n#define ALL_INLINE_HEADERS(HEADER_FUNC)                                                            \\\n  HEADER_FUNC(Accept)                                                                              \\\n  HEADER_FUNC(AcceptEncoding)                                                                      \\\n  HEADER_FUNC(AccessControlRequestHeaders)                                                         \\\n  HEADER_FUNC(AccessControlRequestMethod)                                                          \\\n  HEADER_FUNC(AccessControlAllowOrigin)                                                            \\\n  HEADER_FUNC(AccessControlAllowHeaders)                                                           \\\n  HEADER_FUNC(AccessControlAllowMethods)                                                           \\\n  HEADER_FUNC(AccessControlAllowCredentials)                                                       \\\n  HEADER_FUNC(AccessControlExposeHeaders)                                                          \\\n  HEADER_FUNC(AccessControlMaxAge)                                                                 \\\n  HEADER_FUNC(Authorization)                                                                       \\\n  HEADER_FUNC(CacheControl)                                                                        \\\n  HEADER_FUNC(ClientTraceId)                                                                       \\\n  HEADER_FUNC(Connection)                                                                          \\\n  HEADER_FUNC(ContentEncoding)                                                                     \\\n  HEADER_FUNC(ContentLength)                                                                       \\\n  HEADER_FUNC(ContentType)                                                                         \\\n  HEADER_FUNC(Date)                                                                                \\\n  HEADER_FUNC(EnvoyAttemptCount)                                                                   \\\n  HEADER_FUNC(EnvoyDegraded)                                                                       \\\n  HEADER_FUNC(EnvoyDecoratorOperation)                                                             \\\n  HEADER_FUNC(EnvoyDownstreamServiceCluster)                                                       \\\n  HEADER_FUNC(EnvoyDownstreamServiceNode)                                                          \\\n  HEADER_FUNC(EnvoyExpectedRequestTimeoutMs)                                                       \\\n  HEADER_FUNC(EnvoyExternalAddress)                                                                \\\n  HEADER_FUNC(EnvoyForceTrace)                                                                     \\\n  HEADER_FUNC(EnvoyHedgeOnPerTryTimeout)                                                           \\\n  HEADER_FUNC(EnvoyImmediateHealthCheckFail)                                                       \\\n  HEADER_FUNC(EnvoyInternalRequest)                                                                \\\n  HEADER_FUNC(EnvoyIpTags)                                                                         \\\n  HEADER_FUNC(EnvoyMaxRetries)                                                                     \\\n  HEADER_FUNC(EnvoyOriginalPath)                                                                   \\\n  HEADER_FUNC(EnvoyOriginalUrl)                                                                    \\\n  HEADER_FUNC(EnvoyOverloaded)                                                                     \\\n  HEADER_FUNC(EnvoyRateLimited)                                                                    \\\n  HEADER_FUNC(EnvoyRetryOn)                                                                        \\\n  HEADER_FUNC(EnvoyRetryGrpcOn)                                                                    \\\n  HEADER_FUNC(EnvoyRetriableStatusCodes)                                                           \\\n  HEADER_FUNC(EnvoyRetriableHeaderNames)                                                           \\\n  HEADER_FUNC(EnvoyUpstreamAltStatName)                                                            \\\n  HEADER_FUNC(EnvoyUpstreamCanary)                                                                 \\\n  HEADER_FUNC(EnvoyUpstreamHealthCheckedCluster)                                                   \\\n  HEADER_FUNC(EnvoyUpstreamRequestPerTryTimeoutMs)                                                 \\\n  HEADER_FUNC(EnvoyUpstreamRequestTimeoutAltResponse)                                              \\\n  HEADER_FUNC(EnvoyUpstreamRequestTimeoutMs)                                                       \\\n  HEADER_FUNC(EnvoyUpstreamServiceTime)                                                            \\\n  HEADER_FUNC(Etag)                                                                                \\\n  HEADER_FUNC(Expect)                                                                              \\\n  HEADER_FUNC(ForwardedClientCert)                                                                 \\\n  HEADER_FUNC(ForwardedFor)                                                                        \\\n  HEADER_FUNC(ForwardedProto)                                                                      \\\n  HEADER_FUNC(GrpcAcceptEncoding)                                                                  \\\n  HEADER_FUNC(GrpcMessage)                                                                         \\\n  HEADER_FUNC(GrpcStatus)                                                                          \\\n  HEADER_FUNC(GrpcTimeout)                                                                         \\\n  HEADER_FUNC(Host)                                                                                \\\n  HEADER_FUNC(KeepAlive)                                                                           \\\n  HEADER_FUNC(LastModified)                                                                        \\\n  HEADER_FUNC(Location)                                                                            \\\n  HEADER_FUNC(Method)                                                                              \\\n  HEADER_FUNC(NoChunks)                                                                            \\\n  HEADER_FUNC(Origin)                                                                              \\\n  HEADER_FUNC(OtSpanContext)                                                                       \\\n  HEADER_FUNC(Path)                                                                                \\\n  HEADER_FUNC(Protocol)                                                                            \\\n  HEADER_FUNC(ProxyConnection)                                                                     \\\n  HEADER_FUNC(Referer)                                                                             \\\n  HEADER_FUNC(RequestId)                                                                           \\\n  HEADER_FUNC(Scheme)                                                                              \\\n  HEADER_FUNC(Server)                                                                              \\\n  HEADER_FUNC(Status)                                                                              \\\n  HEADER_FUNC(TE)                                                                                  \\\n  HEADER_FUNC(TransferEncoding)                                                                    \\\n  HEADER_FUNC(Upgrade)                                                                             \\\n  HEADER_FUNC(UserAgent)                                                                           \\\n  HEADER_FUNC(Vary)                                                                                \\\n  HEADER_FUNC(Via)\n\n/**\n * The following functions are defined for each inline header above. E.g., for ContentLength we\n * have:\n *\n * ContentLength() -> returns the header entry if it exists or nullptr.\n * insertContentLength() -> inserts the header if it does not exist, and returns a reference to it.\n * removeContentLength() -> removes the header if it exists.\n */\n#define DEFINE_INLINE_HEADER(name)                                                                 \\\n  virtual const HeaderEntry* name() const PURE;                                                    \\\n  virtual HeaderEntry* name() PURE;                                                                \\\n  virtual HeaderEntry& insert##name() PURE;                                                        \\\n  virtual void remove##name() PURE;\n\n/**\n * Wraps a set of HTTP headers.\n */\nclass HeaderMap {\npublic:\n  virtual ~HeaderMap() = default;\n\n  ALL_INLINE_HEADERS(DEFINE_INLINE_HEADER)\n\n  /**\n   * Add a reference header to the map. Both key and value MUST point to data that will live beyond\n   * the lifetime of any request/response using the string (since a codec may optimize for zero\n   * copy). The key will not be copied and a best effort will be made not to\n   * copy the value (but this may happen when comma concatenating, see below).\n   *\n   * Calling addReference multiple times for the same header will result in:\n   * - Comma concatenation for predefined inline headers.\n   * - Multiple headers being present in the HeaderMap for other headers.\n   *\n   * @param key specifies the name of the header to add; it WILL NOT be copied.\n   * @param value specifies the value of the header to add; it WILL NOT be copied.\n   */\n  virtual void addReference(const LowerCaseString& key, const std::string& value) PURE;\n\n  /**\n   * Add a header with a reference key to the map. The key MUST point to data that will live beyond\n   * the lifetime of any request/response using the string (since a codec may optimize for zero\n   * copy). The value will be copied.\n   *\n   * Calling addReference multiple times for the same header will result in:\n   * - Comma concatenation for predefined inline headers.\n   * - Multiple headers being present in the HeaderMap for other headers.\n   *\n   * @param key specifies the name of the header to add; it WILL NOT be copied.\n   * @param value specifies the value of the header to add; it WILL be copied.\n   */\n  virtual void addReferenceKey(const LowerCaseString& key, uint64_t value) PURE;\n\n  /**\n   * Add a header with a reference key to the map. The key MUST point to point to data that will\n   * live beyond the lifetime of any request/response using the string (since a codec may optimize\n   * for zero copy). The value will be copied.\n   *\n   * Calling addReference multiple times for the same header will result in:\n   * - Comma concatenation for predefined inline headers.\n   * - Multiple headers being present in the HeaderMap for other headers.\n   *\n   * @param key specifies the name of the header to add; it WILL NOT be copied.\n   * @param value specifies the value of the header to add; it WILL be copied.\n   */\n  virtual void addReferenceKey(const LowerCaseString& key, const std::string& value) PURE;\n\n  /**\n   * Add a header by copying both the header key and the value.\n   *\n   * Calling addCopy multiple times for the same header will result in:\n   * - Comma concatenation for predefined inline headers.\n   * - Multiple headers being present in the HeaderMap for other headers.\n   *\n   * @param key specifies the name of the header to add; it WILL be copied.\n   * @param value specifies the value of the header to add; it WILL be copied.\n   */\n  virtual void addCopy(const LowerCaseString& key, uint64_t value) PURE;\n\n  /**\n   * Add a header by copying both the header key and the value.\n   *\n   * Calling addCopy multiple times for the same header will result in:\n   * - Comma concatenation for predefined inline headers.\n   * - Multiple headers being present in the HeaderMap for other headers.\n   *\n   * @param key specifies the name of the header to add; it WILL be copied.\n   * @param value specifies the value of the header to add; it WILL be copied.\n   */\n  virtual void addCopy(const LowerCaseString& key, const std::string& value) PURE;\n\n  /**\n   * Set a reference header in the map. Both key and value MUST point to data that will live beyond\n   * the lifetime of any request/response using the string (since a codec may optimize for zero\n   * copy). Nothing will be copied.\n   *\n   * Calling setReference multiple times for the same header will result in only the last header\n   * being present in the HeaderMap.\n   *\n   * @param key specifies the name of the header to set; it WILL NOT be copied.\n   * @param value specifies the value of the header to set; it WILL NOT be copied.\n   */\n  virtual void setReference(const LowerCaseString& key, const std::string& value) PURE;\n\n  /**\n   * Set a header with a reference key in the map. The key MUST point to point to data that will\n   * live beyond the lifetime of any request/response using the string (since a codec may optimize\n   * for zero copy). The value will be copied.\n   *\n   * Calling setReferenceKey multiple times for the same header will result in only the last header\n   * being present in the HeaderMap.\n   *\n   * @param key specifies the name of the header to set; it WILL NOT be copied.\n   * @param value specifies the value of the header to set; it WILL be copied.\n   */\n  virtual void setReferenceKey(const LowerCaseString& key, const std::string& value) PURE;\n\n  /**\n   * HeaderMap contains an internal byte size count, updated as entries are added, removed, or\n   * modified through the HeaderMap interface. However, HeaderEntries can be accessed and modified\n   * by reference so that the HeaderMap can no longer accurately update the internal byte size\n   * count.\n   *\n   * Calling byteSize before a HeaderEntry is accessed will return the internal byte size count. The\n   * value is cleared when a HeaderEntry is accessed, and the value is updated and set again when\n   * refreshByteSize is called.\n   *\n   * To guarantee an accurate byte size count, call refreshByteSize.\n   *\n   * @return uint64_t the approximate size of the header map in bytes if valid.\n   */\n  virtual absl::optional<uint64_t> byteSize() const PURE;\n\n  /**\n   * This returns the sum of the byte sizes of the keys and values in the HeaderMap. This also\n   * updates and sets the byte size count.\n   *\n   * To guarantee an accurate byte size count, use this. If it is known HeaderEntries have not been\n   * manipulated since a call to refreshByteSize, it is safe to use byteSize.\n   *\n   * @return uint64_t the approximate size of the header map in bytes.\n   */\n  virtual uint64_t refreshByteSize() PURE;\n\n  /**\n   * This returns the sum of the byte sizes of the keys and values in the HeaderMap.\n   *\n   * This iterates over the HeaderMap to calculate size and should only be called directly when the\n   * user wants an explicit recalculation of the byte size.\n   *\n   * @return uint64_t the approximate size of the header map in bytes.\n   */\n  virtual uint64_t byteSizeInternal() const PURE;\n\n  /**\n   * Get a header by key.\n   * @param key supplies the header key.\n   * @return the header entry if it exists otherwise nullptr.\n   */\n  virtual const HeaderEntry* get(const LowerCaseString& key) const PURE;\n  virtual HeaderEntry* get(const LowerCaseString& key) PURE;\n\n  // aliases to make iterate() and iterateReverse() callbacks easier to read\n  enum class Iterate { Continue, Break };\n\n  /**\n   * Callback when calling iterate() over a const header map.\n   * @param header supplies the header entry.\n   * @param context supplies the context passed to iterate().\n   * @return Iterate::Continue to continue iteration.\n   */\n  using ConstIterateCb = Iterate (*)(const HeaderEntry&, void*);\n\n  /**\n   * Iterate over a constant header map.\n   * @param cb supplies the iteration callback.\n   * @param context supplies the context that will be passed to the callback.\n   */\n  virtual void iterate(ConstIterateCb cb, void* context) const PURE;\n\n  /**\n   * Iterate over a constant header map in reverse order.\n   * @param cb supplies the iteration callback.\n   * @param context supplies the context that will be passed to the callback.\n   */\n  virtual void iterateReverse(ConstIterateCb cb, void* context) const PURE;\n\n  enum class Lookup { Found, NotFound, NotSupported };\n\n  /**\n   * Lookup one of the predefined inline headers (see ALL_INLINE_HEADERS below) by key.\n   * @param key supplies the header key.\n   * @param entry is set to the header entry if it exists and if key is one of the predefined inline\n   * headers; otherwise, nullptr.\n   * @return Lookup::Found if lookup was successful, Lookup::NotFound if the header entry doesn't\n   * exist, or Lookup::NotSupported if key is not one of the predefined inline headers.\n   */\n  virtual Lookup lookup(const LowerCaseString& key, const HeaderEntry** entry) const PURE;\n\n  /**\n   * Remove all instances of a header by key.\n   * @param key supplies the header key to remove.\n   */\n  virtual void remove(const LowerCaseString& key) PURE;\n\n  /**\n   * Remove all instances of headers where the key begins with the supplied prefix.\n   * @param prefix supplies the prefix to match header keys against.\n   */\n  virtual void removePrefix(const LowerCaseString& prefix) PURE;\n\n  /**\n   * @return the number of headers in the map.\n   */\n  virtual size_t size() const PURE;\n\n  /**\n   * @return true if the map is empty, false otherwise.\n   */\n  virtual bool empty() const PURE;\n\n  /**\n   * Dump the header map to the ostream specified\n   *\n   * @param os the stream to dump state to\n   * @param indent_level the depth, for pretty-printing.\n   *\n   * This function is called on Envoy fatal errors so should avoid memory allocation where possible.\n   */\n  virtual void dumpState(std::ostream& os, int indent_level = 0) const PURE;\n\n  /**\n   * Allow easy pretty-printing of the key/value pairs in HeaderMap\n   * @param os supplies the ostream to print to.\n   * @param headers the headers to print.\n   */\n  friend std::ostream& operator<<(std::ostream& os, const HeaderMap& headers) {\n    headers.dumpState(os);\n    return os;\n  }\n};\n\nusing HeaderMapPtr = std::unique_ptr<HeaderMap>;\n\n/**\n * Convenient container type for storing Http::LowerCaseString and std::string key/value pairs.\n */\nusing HeaderVector = std::vector<std::pair<LowerCaseString, std::string>>;\n\n/**\n * An interface to be implemented by header matchers.\n */\nclass HeaderMatcher {\npublic:\n  virtual ~HeaderMatcher() = default;\n\n  /*\n   * Check whether header matcher matches any headers in a given HeaderMap.\n   */\n  virtual bool matchesHeaders(const HeaderMap& headers) const PURE;\n};\n\nusing HeaderMatcherSharedPtr = std::shared_ptr<HeaderMatcher>;\n\n} // namespace Http\n} // namespace Envoy\n", "#include \"common/http/conn_manager_impl.h\"\n\n#include <cstdint>\n#include <functional>\n#include <list>\n#include <memory>\n#include <string>\n#include <vector>\n\n#include \"envoy/buffer/buffer.h\"\n#include \"envoy/common/time.h\"\n#include \"envoy/event/dispatcher.h\"\n#include \"envoy/network/drain_decision.h\"\n#include \"envoy/router/router.h\"\n#include \"envoy/server/admin.h\"\n#include \"envoy/ssl/connection.h\"\n#include \"envoy/stats/scope.h\"\n#include \"envoy/tracing/http_tracer.h\"\n\n#include \"common/buffer/buffer_impl.h\"\n#include \"common/common/assert.h\"\n#include \"common/common/empty_string.h\"\n#include \"common/common/enum_to_int.h\"\n#include \"common/common/fmt.h\"\n#include \"common/common/scope_tracker.h\"\n#include \"common/common/utility.h\"\n#include \"common/http/codes.h\"\n#include \"common/http/conn_manager_utility.h\"\n#include \"common/http/exception.h\"\n#include \"common/http/header_map_impl.h\"\n#include \"common/http/headers.h\"\n#include \"common/http/http1/codec_impl.h\"\n#include \"common/http/http2/codec_impl.h\"\n#include \"common/http/path_utility.h\"\n#include \"common/http/utility.h\"\n#include \"common/network/utility.h\"\n#include \"common/router/config_impl.h\"\n#include \"common/runtime/runtime_impl.h\"\n\n#include \"absl/strings/escaping.h\"\n#include \"absl/strings/match.h\"\n\nnamespace Envoy {\nnamespace Http {\n\nnamespace {\n\ntemplate <class T> using FilterList = std::list<std::unique_ptr<T>>;\n\n// Shared helper for recording the latest filter used.\ntemplate <class T>\nvoid recordLatestDataFilter(const typename FilterList<T>::iterator current_filter,\n                            T*& latest_filter, const FilterList<T>& filters) {\n  // If this is the first time we're calling onData, just record the current filter.\n  if (latest_filter == nullptr) {\n    latest_filter = current_filter->get();\n    return;\n  }\n\n  // We want to keep this pointing at the latest filter in the filter list that has received the\n  // onData callback. To do so, we compare the current latest with the *previous* filter. If they\n  // match, then we must be processing a new filter for the first time. We omit this check if we're\n  // the first filter, since the above check handles that case.\n  //\n  // We compare against the previous filter to avoid multiple filter iterations from reseting the\n  // pointer: If we just set latest to current, then the first onData filter iteration would\n  // correctly iterate over the filters and set latest, but on subsequent onData iterations\n  // we'd start from the beginning again, potentially allowing filter N to modify the buffer even\n  // though filter M > N was the filter that inserted data into the buffer.\n  if (current_filter != filters.begin() && latest_filter == std::prev(current_filter)->get()) {\n    latest_filter = current_filter->get();\n  }\n}\n\n} // namespace\n\nConnectionManagerStats ConnectionManagerImpl::generateStats(const std::string& prefix,\n                                                            Stats::Scope& scope) {\n  return {\n      {ALL_HTTP_CONN_MAN_STATS(POOL_COUNTER_PREFIX(scope, prefix), POOL_GAUGE_PREFIX(scope, prefix),\n                               POOL_HISTOGRAM_PREFIX(scope, prefix))},\n      prefix,\n      scope};\n}\n\nConnectionManagerTracingStats ConnectionManagerImpl::generateTracingStats(const std::string& prefix,\n                                                                          Stats::Scope& scope) {\n  return {CONN_MAN_TRACING_STATS(POOL_COUNTER_PREFIX(scope, prefix + \"tracing.\"))};\n}\n\nConnectionManagerListenerStats\nConnectionManagerImpl::generateListenerStats(const std::string& prefix, Stats::Scope& scope) {\n  return {CONN_MAN_LISTENER_STATS(POOL_COUNTER_PREFIX(scope, prefix))};\n}\n\nConnectionManagerImpl::ConnectionManagerImpl(ConnectionManagerConfig& config,\n                                             const Network::DrainDecision& drain_close,\n                                             Runtime::RandomGenerator& random_generator,\n                                             Http::Context& http_context, Runtime::Loader& runtime,\n                                             const LocalInfo::LocalInfo& local_info,\n                                             Upstream::ClusterManager& cluster_manager,\n                                             Server::OverloadManager* overload_manager,\n                                             TimeSource& time_source)\n    : config_(config), stats_(config_.stats()),\n      conn_length_(new Stats::Timespan(stats_.named_.downstream_cx_length_ms_, time_source)),\n      drain_close_(drain_close), random_generator_(random_generator), http_context_(http_context),\n      runtime_(runtime), local_info_(local_info), cluster_manager_(cluster_manager),\n      listener_stats_(config_.listenerStats()),\n      overload_stop_accepting_requests_ref_(\n          overload_manager ? overload_manager->getThreadLocalOverloadState().getState(\n                                 Server::OverloadActionNames::get().StopAcceptingRequests)\n                           : Server::OverloadManager::getInactiveState()),\n      overload_disable_keepalive_ref_(\n          overload_manager ? overload_manager->getThreadLocalOverloadState().getState(\n                                 Server::OverloadActionNames::get().DisableHttpKeepAlive)\n                           : Server::OverloadManager::getInactiveState()),\n      time_source_(time_source) {}\n\nconst HeaderMapImpl& ConnectionManagerImpl::continueHeader() {\n  CONSTRUCT_ON_FIRST_USE(HeaderMapImpl,\n                         {Http::Headers::get().Status, std::to_string(enumToInt(Code::Continue))});\n}\n\nvoid ConnectionManagerImpl::initializeReadFilterCallbacks(Network::ReadFilterCallbacks& callbacks) {\n  read_callbacks_ = &callbacks;\n  stats_.named_.downstream_cx_total_.inc();\n  stats_.named_.downstream_cx_active_.inc();\n  if (read_callbacks_->connection().ssl()) {\n    stats_.named_.downstream_cx_ssl_total_.inc();\n    stats_.named_.downstream_cx_ssl_active_.inc();\n  }\n\n  read_callbacks_->connection().addConnectionCallbacks(*this);\n\n  if (config_.idleTimeout()) {\n    connection_idle_timer_ = read_callbacks_->connection().dispatcher().createTimer(\n        [this]() -> void { onIdleTimeout(); });\n    connection_idle_timer_->enableTimer(config_.idleTimeout().value());\n  }\n\n  read_callbacks_->connection().setDelayedCloseTimeout(config_.delayedCloseTimeout());\n\n  read_callbacks_->connection().setConnectionStats(\n      {stats_.named_.downstream_cx_rx_bytes_total_, stats_.named_.downstream_cx_rx_bytes_buffered_,\n       stats_.named_.downstream_cx_tx_bytes_total_, stats_.named_.downstream_cx_tx_bytes_buffered_,\n       nullptr, &stats_.named_.downstream_cx_delayed_close_timeout_});\n}\n\nConnectionManagerImpl::~ConnectionManagerImpl() {\n  stats_.named_.downstream_cx_destroy_.inc();\n  stats_.named_.downstream_cx_active_.dec();\n  if (read_callbacks_->connection().ssl()) {\n    stats_.named_.downstream_cx_ssl_active_.dec();\n  }\n\n  if (codec_) {\n    if (codec_->protocol() == Protocol::Http2) {\n      stats_.named_.downstream_cx_http2_active_.dec();\n    } else {\n      stats_.named_.downstream_cx_http1_active_.dec();\n    }\n  }\n\n  conn_length_->complete();\n  user_agent_.completeConnectionLength(*conn_length_);\n}\n\nvoid ConnectionManagerImpl::checkForDeferredClose() {\n  if (drain_state_ == DrainState::Closing && streams_.empty() && !codec_->wantsToWrite()) {\n    read_callbacks_->connection().close(Network::ConnectionCloseType::FlushWriteAndDelay);\n  }\n}\n\nvoid ConnectionManagerImpl::doEndStream(ActiveStream& stream) {\n  // The order of what happens in this routine is important and a little complicated. We first see\n  // if the stream needs to be reset. If it needs to be, this will end up invoking reset callbacks\n  // and then moving the stream to the deferred destruction list. If the stream has not been reset,\n  // we move it to the deferred deletion list here. Then, we potentially close the connection. This\n  // must be done after deleting the stream since the stream refers to the connection and must be\n  // deleted first.\n  bool reset_stream = false;\n  // If the response encoder is still associated with the stream, reset the stream. The exception\n  // here is when Envoy \"ends\" the stream by calling recreateStream at which point recreateStream\n  // explicitly nulls out response_encoder to avoid the downstream being notified of the\n  // Envoy-internal stream instance being ended.\n  if (stream.response_encoder_ != nullptr &&\n      (!stream.state_.remote_complete_ || !stream.state_.codec_saw_local_complete_)) {\n    // Indicate local is complete at this point so that if we reset during a continuation, we don't\n    // raise further data or trailers.\n    ENVOY_STREAM_LOG(debug, \"doEndStream() resetting stream\", stream);\n    stream.state_.local_complete_ = true;\n    stream.state_.codec_saw_local_complete_ = true;\n    stream.response_encoder_->getStream().resetStream(StreamResetReason::LocalReset);\n    reset_stream = true;\n  }\n\n  if (!reset_stream) {\n    doDeferredStreamDestroy(stream);\n  }\n\n  if (reset_stream && codec_->protocol() != Protocol::Http2) {\n    drain_state_ = DrainState::Closing;\n  }\n\n  checkForDeferredClose();\n\n  // Reading may have been disabled for the non-multiplexing case, so enable it again.\n  // Also be sure to unwind any read-disable done by the prior downstream\n  // connection.\n  if (drain_state_ != DrainState::Closing && codec_->protocol() != Protocol::Http2) {\n    while (!read_callbacks_->connection().readEnabled()) {\n      read_callbacks_->connection().readDisable(false);\n    }\n  }\n}\n\nvoid ConnectionManagerImpl::doDeferredStreamDestroy(ActiveStream& stream) {\n  if (stream.stream_idle_timer_ != nullptr) {\n    stream.stream_idle_timer_->disableTimer();\n    stream.stream_idle_timer_ = nullptr;\n  }\n  stream.disarmRequestTimeout();\n\n  stream.state_.destroyed_ = true;\n  for (auto& filter : stream.decoder_filters_) {\n    filter->handle_->onDestroy();\n  }\n\n  for (auto& filter : stream.encoder_filters_) {\n    // Do not call on destroy twice for dual registered filters.\n    if (!filter->dual_filter_) {\n      filter->handle_->onDestroy();\n    }\n  }\n\n  read_callbacks_->connection().dispatcher().deferredDelete(stream.removeFromList(streams_));\n\n  if (connection_idle_timer_ && streams_.empty()) {\n    connection_idle_timer_->enableTimer(config_.idleTimeout().value());\n  }\n}\n\nStreamDecoder& ConnectionManagerImpl::newStream(StreamEncoder& response_encoder,\n                                                bool is_internally_created) {\n  if (connection_idle_timer_) {\n    connection_idle_timer_->disableTimer();\n  }\n\n  ENVOY_CONN_LOG(debug, \"new stream\", read_callbacks_->connection());\n  ActiveStreamPtr new_stream(new ActiveStream(*this));\n  new_stream->state_.is_internally_created_ = is_internally_created;\n  new_stream->response_encoder_ = &response_encoder;\n  new_stream->response_encoder_->getStream().addCallbacks(*new_stream);\n  new_stream->buffer_limit_ = new_stream->response_encoder_->getStream().bufferLimit();\n  // If the network connection is backed up, the stream should be made aware of it on creation.\n  // Both HTTP/1.x and HTTP/2 codecs handle this in StreamCallbackHelper::addCallbacks_.\n  ASSERT(read_callbacks_->connection().aboveHighWatermark() == false ||\n         new_stream->high_watermark_count_ > 0);\n  new_stream->moveIntoList(std::move(new_stream), streams_);\n  return **streams_.begin();\n}\n\nvoid ConnectionManagerImpl::handleCodecException(const char* error) {\n  ENVOY_CONN_LOG(debug, \"dispatch error: {}\", read_callbacks_->connection(), error);\n\n  // In the protocol error case, we need to reset all streams now. The connection might stick around\n  // long enough for a pending stream to come back and try to encode.\n  resetAllStreams();\n\n  // HTTP/1.1 codec has already sent a 400 response if possible. HTTP/2 codec has already sent\n  // GOAWAY.\n  read_callbacks_->connection().close(Network::ConnectionCloseType::FlushWriteAndDelay);\n}\n\nNetwork::FilterStatus ConnectionManagerImpl::onData(Buffer::Instance& data, bool) {\n  if (!codec_) {\n    codec_ = config_.createCodec(read_callbacks_->connection(), data, *this);\n    if (codec_->protocol() == Protocol::Http2) {\n      stats_.named_.downstream_cx_http2_total_.inc();\n      stats_.named_.downstream_cx_http2_active_.inc();\n    } else {\n      stats_.named_.downstream_cx_http1_total_.inc();\n      stats_.named_.downstream_cx_http1_active_.inc();\n    }\n  }\n\n  // TODO(alyssawilk) clean this up after #8352 is well vetted.\n  bool redispatch;\n  do {\n    redispatch = false;\n\n    try {\n      codec_->dispatch(data);\n    } catch (const FrameFloodException& e) {\n      // TODO(mattklein123): This is an emergency substitute for the lack of connection level\n      // logging in the HCM. In a public follow up change we will add full support for connection\n      // level logging in the HCM, similar to what we have in tcp_proxy. This will allow abuse\n      // indicators to be stored in the connection level stream info, and then matched, sampled,\n      // etc. when logged.\n      const envoy::type::FractionalPercent default_value; // 0\n      if (runtime_.snapshot().featureEnabled(\"http.connection_manager.log_flood_exception\",\n                                             default_value)) {\n        ENVOY_CONN_LOG(warn, \"downstream HTTP flood from IP '{}': {}\",\n                       read_callbacks_->connection(),\n                       read_callbacks_->connection().remoteAddress()->asString(), e.what());\n      }\n\n      handleCodecException(e.what());\n      return Network::FilterStatus::StopIteration;\n    } catch (const CodecProtocolException& e) {\n      stats_.named_.downstream_cx_protocol_error_.inc();\n      handleCodecException(e.what());\n      return Network::FilterStatus::StopIteration;\n    }\n\n    // Processing incoming data may release outbound data so check for closure here as well.\n    checkForDeferredClose();\n\n    // The HTTP/1 codec will pause dispatch after a single message is complete. We want to\n    // either redispatch if there are no streams and we have more data. If we have a single\n    // complete non-WebSocket stream but have not responded yet we will pause socket reads\n    // to apply back pressure.\n    if (codec_->protocol() != Protocol::Http2) {\n      if (read_callbacks_->connection().state() == Network::Connection::State::Open &&\n          data.length() > 0 && streams_.empty()) {\n        redispatch = true;\n      }\n\n      if (!streams_.empty() && streams_.front()->state_.remote_complete_) {\n        read_callbacks_->connection().readDisable(true);\n      }\n    }\n  } while (redispatch);\n\n  return Network::FilterStatus::StopIteration;\n}\n\nvoid ConnectionManagerImpl::resetAllStreams() {\n  while (!streams_.empty()) {\n    // Mimic a downstream reset in this case. We must also remove callbacks here. Though we are\n    // about to close the connection and will disable further reads, it is possible that flushing\n    // data out can cause stream callbacks to fire (e.g., low watermark callbacks).\n    //\n    // TODO(mattklein123): I tried to actually reset through the codec here, but ran into issues\n    // with nghttp2 state and being unhappy about sending reset frames after the connection had\n    // been terminated via GOAWAY. It might be possible to do something better here inside the h2\n    // codec but there are no easy answers and this seems simpler.\n    auto& stream = *streams_.front();\n    stream.response_encoder_->getStream().removeCallbacks(stream);\n    stream.onResetStream(StreamResetReason::ConnectionTermination, absl::string_view());\n  }\n}\n\nvoid ConnectionManagerImpl::onEvent(Network::ConnectionEvent event) {\n  if (event == Network::ConnectionEvent::LocalClose) {\n    stats_.named_.downstream_cx_destroy_local_.inc();\n  }\n\n  if (event == Network::ConnectionEvent::RemoteClose) {\n    stats_.named_.downstream_cx_destroy_remote_.inc();\n  }\n\n  if (event == Network::ConnectionEvent::RemoteClose ||\n      event == Network::ConnectionEvent::LocalClose) {\n    if (connection_idle_timer_) {\n      connection_idle_timer_->disableTimer();\n      connection_idle_timer_.reset();\n    }\n\n    if (drain_timer_) {\n      drain_timer_->disableTimer();\n      drain_timer_.reset();\n    }\n  }\n\n  if (!streams_.empty()) {\n    if (event == Network::ConnectionEvent::LocalClose) {\n      stats_.named_.downstream_cx_destroy_local_active_rq_.inc();\n    }\n    if (event == Network::ConnectionEvent::RemoteClose) {\n      stats_.named_.downstream_cx_destroy_remote_active_rq_.inc();\n    }\n\n    stats_.named_.downstream_cx_destroy_active_rq_.inc();\n    user_agent_.onConnectionDestroy(event, true);\n    resetAllStreams();\n  }\n}\n\nvoid ConnectionManagerImpl::onGoAway() {\n  // Currently we do nothing with remote go away frames. In the future we can decide to no longer\n  // push resources if applicable.\n}\n\nvoid ConnectionManagerImpl::onIdleTimeout() {\n  ENVOY_CONN_LOG(debug, \"idle timeout\", read_callbacks_->connection());\n  stats_.named_.downstream_cx_idle_timeout_.inc();\n  if (!codec_) {\n    // No need to delay close after flushing since an idle timeout has already fired. Attempt to\n    // write out buffered data one last time and issue a local close if successful.\n    read_callbacks_->connection().close(Network::ConnectionCloseType::FlushWrite);\n  } else if (drain_state_ == DrainState::NotDraining) {\n    startDrainSequence();\n  }\n}\n\nvoid ConnectionManagerImpl::onDrainTimeout() {\n  ASSERT(drain_state_ != DrainState::NotDraining);\n  codec_->goAway();\n  drain_state_ = DrainState::Closing;\n  checkForDeferredClose();\n}\n\nvoid ConnectionManagerImpl::chargeTracingStats(const Tracing::Reason& tracing_reason,\n                                               ConnectionManagerTracingStats& tracing_stats) {\n  switch (tracing_reason) {\n  case Tracing::Reason::ClientForced:\n    tracing_stats.client_enabled_.inc();\n    break;\n  case Tracing::Reason::NotTraceableRequestId:\n    tracing_stats.not_traceable_.inc();\n    break;\n  case Tracing::Reason::Sampling:\n    tracing_stats.random_sampling_.inc();\n    break;\n  case Tracing::Reason::ServiceForced:\n    tracing_stats.service_forced_.inc();\n    break;\n  default:\n    throw std::invalid_argument(\n        fmt::format(\"invalid tracing reason, value: {}\", static_cast<int32_t>(tracing_reason)));\n  }\n}\n\nConnectionManagerImpl::ActiveStream::ActiveStream(ConnectionManagerImpl& connection_manager)\n    : connection_manager_(connection_manager),\n      stream_id_(connection_manager.random_generator_.random()),\n      request_response_timespan_(new Stats::Timespan(\n          connection_manager_.stats_.named_.downstream_rq_time_, connection_manager_.timeSource())),\n      stream_info_(connection_manager_.codec_->protocol(), connection_manager_.timeSource()),\n      upstream_options_(std::make_shared<Network::Socket::Options>()) {\n  // For Server::Admin, no routeConfigProvider or SRDS route provider is used.\n  ASSERT(dynamic_cast<Server::Admin*>(&connection_manager_.config_) != nullptr ||\n             ((connection_manager.config_.routeConfigProvider() == nullptr &&\n               connection_manager.config_.scopedRouteConfigProvider() != nullptr) ||\n              (connection_manager.config_.routeConfigProvider() != nullptr &&\n               connection_manager.config_.scopedRouteConfigProvider() == nullptr)),\n         \"Either routeConfigProvider or scopedRouteConfigProvider should be set in \"\n         \"ConnectionManagerImpl.\");\n  if (connection_manager.config_.routeConfigProvider() != nullptr) {\n    snapped_route_config_ = connection_manager.config_.routeConfigProvider()->config();\n  } else if (connection_manager.config_.scopedRouteConfigProvider() != nullptr) {\n    snapped_scoped_routes_config_ =\n        connection_manager_.config_.scopedRouteConfigProvider()->config<Router::ScopedConfig>();\n    ASSERT(snapped_scoped_routes_config_ != nullptr,\n           \"Scoped rds provider returns null for scoped routes config.\");\n  }\n  ScopeTrackerScopeState scope(this,\n                               connection_manager_.read_callbacks_->connection().dispatcher());\n\n  connection_manager_.stats_.named_.downstream_rq_total_.inc();\n  connection_manager_.stats_.named_.downstream_rq_active_.inc();\n  if (connection_manager_.codec_->protocol() == Protocol::Http2) {\n    connection_manager_.stats_.named_.downstream_rq_http2_total_.inc();\n  } else {\n    connection_manager_.stats_.named_.downstream_rq_http1_total_.inc();\n  }\n  stream_info_.setDownstreamLocalAddress(\n      connection_manager_.read_callbacks_->connection().localAddress());\n  stream_info_.setDownstreamDirectRemoteAddress(\n      connection_manager_.read_callbacks_->connection().remoteAddress());\n  // Initially, the downstream remote address is the source address of the\n  // downstream connection. That can change later in the request's lifecycle,\n  // based on XFF processing, but setting the downstream remote address here\n  // prevents surprises for logging code in edge cases.\n  stream_info_.setDownstreamRemoteAddress(\n      connection_manager_.read_callbacks_->connection().remoteAddress());\n\n  stream_info_.setDownstreamSslConnection(connection_manager_.read_callbacks_->connection().ssl());\n\n  if (connection_manager_.config_.streamIdleTimeout().count()) {\n    idle_timeout_ms_ = connection_manager_.config_.streamIdleTimeout();\n    stream_idle_timer_ = connection_manager_.read_callbacks_->connection().dispatcher().createTimer(\n        [this]() -> void { onIdleTimeout(); });\n    resetIdleTimer();\n  }\n\n  if (connection_manager_.config_.requestTimeout().count()) {\n    std::chrono::milliseconds request_timeout_ms_ = connection_manager_.config_.requestTimeout();\n    request_timer_ = connection_manager.read_callbacks_->connection().dispatcher().createTimer(\n        [this]() -> void { onRequestTimeout(); });\n    request_timer_->enableTimer(request_timeout_ms_, this);\n  }\n\n  stream_info_.setRequestedServerName(\n      connection_manager_.read_callbacks_->connection().requestedServerName());\n}\n\nConnectionManagerImpl::ActiveStream::~ActiveStream() {\n  stream_info_.onRequestComplete();\n\n  // A downstream disconnect can be identified for HTTP requests when the upstream returns with a 0\n  // response code and when no other response flags are set.\n  if (!stream_info_.hasAnyResponseFlag() && !stream_info_.responseCode()) {\n    stream_info_.setResponseFlag(StreamInfo::ResponseFlag::DownstreamConnectionTermination);\n  }\n\n  connection_manager_.stats_.named_.downstream_rq_active_.dec();\n  // Refresh byte sizes of the HeaderMaps before logging.\n  // TODO(asraa): Remove this when entries in HeaderMap can no longer be modified by reference and\n  // HeaderMap holds an accurate internal byte size count.\n  if (request_headers_ != nullptr) {\n    request_headers_->refreshByteSize();\n  }\n  if (response_headers_ != nullptr) {\n    response_headers_->refreshByteSize();\n  }\n  if (response_trailers_ != nullptr) {\n    response_trailers_->refreshByteSize();\n  }\n  for (const AccessLog::InstanceSharedPtr& access_log : connection_manager_.config_.accessLogs()) {\n    access_log->log(request_headers_.get(), response_headers_.get(), response_trailers_.get(),\n                    stream_info_);\n  }\n  for (const auto& log_handler : access_log_handlers_) {\n    log_handler->log(request_headers_.get(), response_headers_.get(), response_trailers_.get(),\n                     stream_info_);\n  }\n\n  if (stream_info_.healthCheck()) {\n    connection_manager_.config_.tracingStats().health_check_.inc();\n  }\n\n  if (active_span_) {\n    Tracing::HttpTracerUtility::finalizeDownstreamSpan(\n        *active_span_, request_headers_.get(), response_headers_.get(), response_trailers_.get(),\n        stream_info_, *this);\n  }\n  if (state_.successful_upgrade_) {\n    connection_manager_.stats_.named_.downstream_cx_upgrades_active_.dec();\n  }\n\n  ASSERT(state_.filter_call_state_ == 0);\n}\n\nvoid ConnectionManagerImpl::ActiveStream::resetIdleTimer() {\n  if (stream_idle_timer_ != nullptr) {\n    // TODO(htuch): If this shows up in performance profiles, optimize by only\n    // updating a timestamp here and doing periodic checks for idle timeouts\n    // instead, or reducing the accuracy of timers.\n    stream_idle_timer_->enableTimer(idle_timeout_ms_);\n  }\n}\n\nvoid ConnectionManagerImpl::ActiveStream::onIdleTimeout() {\n  connection_manager_.stats_.named_.downstream_rq_idle_timeout_.inc();\n  // If headers have not been sent to the user, send a 408.\n  if (response_headers_ != nullptr) {\n    // TODO(htuch): We could send trailers here with an x-envoy timeout header\n    // or gRPC status code, and/or set H2 RST_STREAM error.\n    connection_manager_.doEndStream(*this);\n  } else {\n    stream_info_.setResponseFlag(StreamInfo::ResponseFlag::StreamIdleTimeout);\n    sendLocalReply(request_headers_ != nullptr &&\n                       Grpc::Common::hasGrpcContentType(*request_headers_),\n                   Http::Code::RequestTimeout, \"stream timeout\", nullptr, is_head_request_,\n                   absl::nullopt, StreamInfo::ResponseCodeDetails::get().StreamIdleTimeout);\n  }\n}\n\nvoid ConnectionManagerImpl::ActiveStream::onRequestTimeout() {\n  connection_manager_.stats_.named_.downstream_rq_timeout_.inc();\n  sendLocalReply(request_headers_ != nullptr && Grpc::Common::hasGrpcContentType(*request_headers_),\n                 Http::Code::RequestTimeout, \"request timeout\", nullptr, is_head_request_,\n                 absl::nullopt, StreamInfo::ResponseCodeDetails::get().RequestOverallTimeout);\n}\n\nvoid ConnectionManagerImpl::ActiveStream::addStreamDecoderFilterWorker(\n    StreamDecoderFilterSharedPtr filter, bool dual_filter) {\n  ActiveStreamDecoderFilterPtr wrapper(new ActiveStreamDecoderFilter(*this, filter, dual_filter));\n  filter->setDecoderFilterCallbacks(*wrapper);\n  wrapper->moveIntoListBack(std::move(wrapper), decoder_filters_);\n}\n\nvoid ConnectionManagerImpl::ActiveStream::addStreamEncoderFilterWorker(\n    StreamEncoderFilterSharedPtr filter, bool dual_filter) {\n  ActiveStreamEncoderFilterPtr wrapper(new ActiveStreamEncoderFilter(*this, filter, dual_filter));\n  filter->setEncoderFilterCallbacks(*wrapper);\n  wrapper->moveIntoList(std::move(wrapper), encoder_filters_);\n}\n\nvoid ConnectionManagerImpl::ActiveStream::addAccessLogHandler(\n    AccessLog::InstanceSharedPtr handler) {\n  access_log_handlers_.push_back(handler);\n}\n\nvoid ConnectionManagerImpl::ActiveStream::chargeStats(const HeaderMap& headers) {\n  uint64_t response_code = Utility::getResponseStatus(headers);\n  stream_info_.response_code_ = response_code;\n\n  if (stream_info_.health_check_request_) {\n    return;\n  }\n\n  connection_manager_.stats_.named_.downstream_rq_completed_.inc();\n  connection_manager_.listener_stats_.downstream_rq_completed_.inc();\n  if (CodeUtility::is1xx(response_code)) {\n    connection_manager_.stats_.named_.downstream_rq_1xx_.inc();\n    connection_manager_.listener_stats_.downstream_rq_1xx_.inc();\n  } else if (CodeUtility::is2xx(response_code)) {\n    connection_manager_.stats_.named_.downstream_rq_2xx_.inc();\n    connection_manager_.listener_stats_.downstream_rq_2xx_.inc();\n  } else if (CodeUtility::is3xx(response_code)) {\n    connection_manager_.stats_.named_.downstream_rq_3xx_.inc();\n    connection_manager_.listener_stats_.downstream_rq_3xx_.inc();\n  } else if (CodeUtility::is4xx(response_code)) {\n    connection_manager_.stats_.named_.downstream_rq_4xx_.inc();\n    connection_manager_.listener_stats_.downstream_rq_4xx_.inc();\n  } else if (CodeUtility::is5xx(response_code)) {\n    connection_manager_.stats_.named_.downstream_rq_5xx_.inc();\n    connection_manager_.listener_stats_.downstream_rq_5xx_.inc();\n  }\n}\n\nconst Network::Connection* ConnectionManagerImpl::ActiveStream::connection() {\n  return &connection_manager_.read_callbacks_->connection();\n}\n\n// Ordering in this function is complicated, but important.\n//\n// We want to do minimal work before selecting route and creating a filter\n// chain to maximize the number of requests which get custom filter behavior,\n// e.g. registering access logging.\n//\n// This must be balanced by doing sanity checking for invalid requests (one\n// can't route select properly without full headers), checking state required to\n// serve error responses (connection close, head requests, etc), and\n// modifications which may themselves affect route selection.\n//\n// TODO(alyssawilk) all the calls here should be audited for order priority,\n// e.g. many early returns do not currently handle connection: close properly.\nvoid ConnectionManagerImpl::ActiveStream::decodeHeaders(HeaderMapPtr&& headers, bool end_stream) {\n  ScopeTrackerScopeState scope(this,\n                               connection_manager_.read_callbacks_->connection().dispatcher());\n  request_headers_ = std::move(headers);\n  // For Admin thread, we don't use routeConfigProvider or SRDS route provider.\n  if (dynamic_cast<Server::Admin*>(&connection_manager_.config_) == nullptr &&\n      connection_manager_.config_.scopedRouteConfigProvider() != nullptr) {\n    ASSERT(snapped_route_config_ == nullptr,\n           \"Route config already latched to the active stream when scoped RDS is enabled.\");\n    // We need to snap snapped_route_config_ here as it's used in mutateRequestHeaders later.\n    snapScopedRouteConfig();\n  }\n\n  if (Http::Headers::get().MethodValues.Head ==\n      request_headers_->Method()->value().getStringView()) {\n    is_head_request_ = true;\n  }\n  ENVOY_STREAM_LOG(debug, \"request headers complete (end_stream={}):\\n{}\", *this, end_stream,\n                   *request_headers_);\n\n  // We end the decode here only if the request is header only. If we convert the request to a\n  // header only, the stream will be marked as done once a subsequent decodeData/decodeTrailers is\n  // called with end_stream=true.\n  maybeEndDecode(end_stream);\n\n  // Drop new requests when overloaded as soon as we have decoded the headers.\n  if (connection_manager_.overload_stop_accepting_requests_ref_ ==\n      Server::OverloadActionState::Active) {\n    // In this one special case, do not create the filter chain. If there is a risk of memory\n    // overload it is more important to avoid unnecessary allocation than to create the filters.\n    state_.created_filter_chain_ = true;\n    connection_manager_.stats_.named_.downstream_rq_overload_close_.inc();\n    sendLocalReply(Grpc::Common::hasGrpcContentType(*request_headers_),\n                   Http::Code::ServiceUnavailable, \"envoy overloaded\", nullptr, is_head_request_,\n                   absl::nullopt, StreamInfo::ResponseCodeDetails::get().Overload);\n    return;\n  }\n\n  if (!connection_manager_.config_.proxy100Continue() && request_headers_->Expect() &&\n      request_headers_->Expect()->value() == Headers::get().ExpectValues._100Continue.c_str()) {\n    // Note in the case Envoy is handling 100-Continue complexity, it skips the filter chain\n    // and sends the 100-Continue directly to the encoder.\n    chargeStats(continueHeader());\n    response_encoder_->encode100ContinueHeaders(continueHeader());\n    // Remove the Expect header so it won't be handled again upstream.\n    request_headers_->removeExpect();\n  }\n\n  connection_manager_.user_agent_.initializeFromHeaders(\n      *request_headers_, connection_manager_.stats_.prefix_, connection_manager_.stats_.scope_);\n\n  // Make sure we are getting a codec version we support.\n  Protocol protocol = connection_manager_.codec_->protocol();\n  if (protocol == Protocol::Http10) {\n    // Assume this is HTTP/1.0. This is fine for HTTP/0.9 but this code will also affect any\n    // requests with non-standard version numbers (0.9, 1.3), basically anything which is not\n    // HTTP/1.1.\n    //\n    // The protocol may have shifted in the HTTP/1.0 case so reset it.\n    stream_info_.protocol(protocol);\n    if (!connection_manager_.config_.http1Settings().accept_http_10_) {\n      // Send \"Upgrade Required\" if HTTP/1.0 support is not explicitly configured on.\n      sendLocalReply(false, Code::UpgradeRequired, \"\", nullptr, is_head_request_, absl::nullopt,\n                     StreamInfo::ResponseCodeDetails::get().LowVersion);\n      return;\n    } else {\n      // HTTP/1.0 defaults to single-use connections. Make sure the connection\n      // will be closed unless Keep-Alive is present.\n      state_.saw_connection_close_ = true;\n      if (request_headers_->Connection() &&\n          absl::EqualsIgnoreCase(request_headers_->Connection()->value().getStringView(),\n                                 Http::Headers::get().ConnectionValues.KeepAlive)) {\n        state_.saw_connection_close_ = false;\n      }\n    }\n  }\n\n  if (!request_headers_->Host()) {\n    if ((protocol == Protocol::Http10) &&\n        !connection_manager_.config_.http1Settings().default_host_for_http_10_.empty()) {\n      // Add a default host if configured to do so.\n      request_headers_->insertHost().value(\n          connection_manager_.config_.http1Settings().default_host_for_http_10_);\n    } else {\n      // Require host header. For HTTP/1.1 Host has already been translated to :authority.\n      sendLocalReply(Grpc::Common::hasGrpcContentType(*request_headers_), Code::BadRequest, \"\",\n                     nullptr, is_head_request_, absl::nullopt,\n                     StreamInfo::ResponseCodeDetails::get().MissingHost);\n      return;\n    }\n  }\n\n  // Currently we only support relative paths at the application layer. We expect the codec to have\n  // broken the path into pieces if applicable. NOTE: Currently the HTTP/1.1 codec only does this\n  // when the allow_absolute_url flag is enabled on the HCM.\n  // https://tools.ietf.org/html/rfc7230#section-5.3 We also need to check for the existence of\n  // :path because CONNECT does not have a path, and we don't support that currently.\n  if (!request_headers_->Path() || request_headers_->Path()->value().getStringView().empty() ||\n      request_headers_->Path()->value().getStringView()[0] != '/') {\n    const bool has_path =\n        request_headers_->Path() && !request_headers_->Path()->value().getStringView().empty();\n    connection_manager_.stats_.named_.downstream_rq_non_relative_path_.inc();\n    sendLocalReply(Grpc::Common::hasGrpcContentType(*request_headers_), Code::NotFound, \"\", nullptr,\n                   is_head_request_, absl::nullopt,\n                   has_path ? StreamInfo::ResponseCodeDetails::get().AbsolutePath\n                            : StreamInfo::ResponseCodeDetails::get().MissingPath);\n    return;\n  }\n\n  // Path sanitization should happen before any path access other than the above sanity check.\n  if (!ConnectionManagerUtility::maybeNormalizePath(*request_headers_,\n                                                    connection_manager_.config_)) {\n    sendLocalReply(Grpc::Common::hasGrpcContentType(*request_headers_), Code::BadRequest, \"\",\n                   nullptr, is_head_request_, absl::nullopt,\n                   StreamInfo::ResponseCodeDetails::get().PathNormalizationFailed);\n    return;\n  }\n\n  if (protocol == Protocol::Http11 && request_headers_->Connection() &&\n      absl::EqualsIgnoreCase(request_headers_->Connection()->value().getStringView(),\n                             Http::Headers::get().ConnectionValues.Close)) {\n    state_.saw_connection_close_ = true;\n  }\n  // Note: Proxy-Connection is not a standard header, but is supported here\n  // since it is supported by http-parser the underlying parser for http\n  // requests.\n  if (protocol != Protocol::Http2 && !state_.saw_connection_close_ &&\n      request_headers_->ProxyConnection() &&\n      absl::EqualsIgnoreCase(request_headers_->ProxyConnection()->value().getStringView(),\n                             Http::Headers::get().ConnectionValues.Close)) {\n    state_.saw_connection_close_ = true;\n  }\n\n  if (!state_.is_internally_created_) { // Only sanitize headers on first pass.\n    // Modify the downstream remote address depending on configuration and headers.\n    stream_info_.setDownstreamRemoteAddress(ConnectionManagerUtility::mutateRequestHeaders(\n        *request_headers_, connection_manager_.read_callbacks_->connection(),\n        connection_manager_.config_, *snapped_route_config_, connection_manager_.random_generator_,\n        connection_manager_.local_info_));\n  }\n  ASSERT(stream_info_.downstreamRemoteAddress() != nullptr);\n\n  ASSERT(!cached_route_);\n  refreshCachedRoute();\n\n  if (!state_.is_internally_created_) { // Only mutate tracing headers on first pass.\n    ConnectionManagerUtility::mutateTracingRequestHeader(\n        *request_headers_, connection_manager_.runtime_, connection_manager_.config_,\n        cached_route_.value().get());\n  }\n\n  const bool upgrade_rejected = createFilterChain() == false;\n\n  // TODO if there are no filters when starting a filter iteration, the connection manager\n  // should return 404. The current returns no response if there is no router filter.\n  if (protocol == Protocol::Http11 && hasCachedRoute()) {\n    if (upgrade_rejected) {\n      // Do not allow upgrades if the route does not support it.\n      connection_manager_.stats_.named_.downstream_rq_ws_on_non_ws_route_.inc();\n      sendLocalReply(Grpc::Common::hasGrpcContentType(*request_headers_), Code::Forbidden, \"\",\n                     nullptr, is_head_request_, absl::nullopt,\n                     StreamInfo::ResponseCodeDetails::get().UpgradeFailed);\n      return;\n    }\n    // Allow non websocket requests to go through websocket enabled routes.\n  }\n\n  if (hasCachedRoute()) {\n    const Router::RouteEntry* route_entry = cached_route_.value()->routeEntry();\n    if (route_entry != nullptr && route_entry->idleTimeout()) {\n      idle_timeout_ms_ = route_entry->idleTimeout().value();\n      if (idle_timeout_ms_.count()) {\n        // If we have a route-level idle timeout but no global stream idle timeout, create a timer.\n        if (stream_idle_timer_ == nullptr) {\n          stream_idle_timer_ =\n              connection_manager_.read_callbacks_->connection().dispatcher().createTimer(\n                  [this]() -> void { onIdleTimeout(); });\n        }\n      } else if (stream_idle_timer_ != nullptr) {\n        // If we had a global stream idle timeout but the route-level idle timeout is set to zero\n        // (to override), we disable the idle timer.\n        stream_idle_timer_->disableTimer();\n        stream_idle_timer_ = nullptr;\n      }\n    }\n  }\n\n  // Check if tracing is enabled at all.\n  if (connection_manager_.config_.tracingConfig()) {\n    traceRequest();\n  }\n\n  decodeHeaders(nullptr, *request_headers_, end_stream);\n\n  // Reset it here for both global and overridden cases.\n  resetIdleTimer();\n}\n\nvoid ConnectionManagerImpl::ActiveStream::traceRequest() {\n  Tracing::Decision tracing_decision =\n      Tracing::HttpTracerUtility::isTracing(stream_info_, *request_headers_);\n  ConnectionManagerImpl::chargeTracingStats(tracing_decision.reason,\n                                            connection_manager_.config_.tracingStats());\n\n  active_span_ = connection_manager_.tracer().startSpan(*this, *request_headers_, stream_info_,\n                                                        tracing_decision);\n\n  if (!active_span_) {\n    return;\n  }\n\n  // TODO: Need to investigate the following code based on the cached route, as may\n  // be broken in the case a filter changes the route.\n\n  // If a decorator has been defined, apply it to the active span.\n  if (hasCachedRoute() && cached_route_.value()->decorator()) {\n    cached_route_.value()->decorator()->apply(*active_span_);\n\n    // Cache decorated operation.\n    if (!cached_route_.value()->decorator()->getOperation().empty()) {\n      decorated_operation_ = &cached_route_.value()->decorator()->getOperation();\n    }\n  }\n\n  if (connection_manager_.config_.tracingConfig()->operation_name_ ==\n      Tracing::OperationName::Egress) {\n    // For egress (outbound) requests, pass the decorator's operation name (if defined)\n    // as a request header to enable the receiving service to use it in its server span.\n    if (decorated_operation_) {\n      request_headers_->insertEnvoyDecoratorOperation().value(*decorated_operation_);\n    }\n  } else {\n    const HeaderEntry* req_operation_override = request_headers_->EnvoyDecoratorOperation();\n\n    // For ingress (inbound) requests, if a decorator operation name has been provided, it\n    // should be used to override the active span's operation.\n    if (req_operation_override) {\n      if (!req_operation_override->value().empty()) {\n        active_span_->setOperation(req_operation_override->value().getStringView());\n\n        // Clear the decorated operation so won't be used in the response header, as\n        // it has been overridden by the inbound decorator operation request header.\n        decorated_operation_ = nullptr;\n      }\n      // Remove header so not propagated to service\n      request_headers_->removeEnvoyDecoratorOperation();\n    }\n  }\n}\n\nvoid ConnectionManagerImpl::ActiveStream::decodeHeaders(ActiveStreamDecoderFilter* filter,\n                                                        HeaderMap& headers, bool end_stream) {\n  // Headers filter iteration should always start with the next filter if available.\n  std::list<ActiveStreamDecoderFilterPtr>::iterator entry =\n      commonDecodePrefix(filter, FilterIterationStartState::AlwaysStartFromNext);\n  std::list<ActiveStreamDecoderFilterPtr>::iterator continue_data_entry = decoder_filters_.end();\n\n  for (; entry != decoder_filters_.end(); entry++) {\n    ASSERT(!(state_.filter_call_state_ & FilterCallState::DecodeHeaders));\n    state_.filter_call_state_ |= FilterCallState::DecodeHeaders;\n    (*entry)->end_stream_ =\n        decoding_headers_only_ || (end_stream && continue_data_entry == decoder_filters_.end());\n    FilterHeadersStatus status = (*entry)->decodeHeaders(headers, (*entry)->end_stream_);\n\n    ASSERT(!(status == FilterHeadersStatus::ContinueAndEndStream && (*entry)->end_stream_));\n    state_.filter_call_state_ &= ~FilterCallState::DecodeHeaders;\n    ENVOY_STREAM_LOG(trace, \"decode headers called: filter={} status={}\", *this,\n                     static_cast<const void*>((*entry).get()), static_cast<uint64_t>(status));\n\n    const bool new_metadata_added = processNewlyAddedMetadata();\n    // If end_stream is set in headers, and a filter adds new metadata, we need to delay end_stream\n    // in headers by inserting an empty data frame with end_stream set. The empty data frame is sent\n    // after the new metadata.\n    if ((*entry)->end_stream_ && new_metadata_added && !buffered_request_data_) {\n      Buffer::OwnedImpl empty_data(\"\");\n      ENVOY_STREAM_LOG(\n          trace, \"inserting an empty data frame for end_stream due metadata being added.\", *this);\n      // Metadata frame doesn't carry end of stream bit. We need an empty data frame to end the\n      // stream.\n      addDecodedData(*((*entry).get()), empty_data, true);\n    }\n\n    (*entry)->decode_headers_called_ = true;\n    if (!(*entry)->commonHandleAfterHeadersCallback(status, decoding_headers_only_) &&\n        std::next(entry) != decoder_filters_.end()) {\n      // Stop iteration IFF this is not the last filter. If it is the last filter, continue with\n      // processing since we need to handle the case where a terminal filter wants to buffer, but\n      // a previous filter has added body.\n      return;\n    }\n\n    // Here we handle the case where we have a header only request, but a filter adds a body\n    // to it. We need to not raise end_stream = true to further filters during inline iteration.\n    if (end_stream && buffered_request_data_ && continue_data_entry == decoder_filters_.end()) {\n      continue_data_entry = entry;\n    }\n  }\n\n  if (continue_data_entry != decoder_filters_.end()) {\n    // We use the continueDecoding() code since it will correctly handle not calling\n    // decodeHeaders() again. Fake setting StopSingleIteration since the continueDecoding() code\n    // expects it.\n    ASSERT(buffered_request_data_);\n    (*continue_data_entry)->iteration_state_ =\n        ActiveStreamFilterBase::IterationState::StopSingleIteration;\n    (*continue_data_entry)->continueDecoding();\n  }\n\n  if (end_stream) {\n    disarmRequestTimeout();\n  }\n}\n\nvoid ConnectionManagerImpl::ActiveStream::decodeData(Buffer::Instance& data, bool end_stream) {\n  ScopeTrackerScopeState scope(this,\n                               connection_manager_.read_callbacks_->connection().dispatcher());\n  maybeEndDecode(end_stream);\n  stream_info_.addBytesReceived(data.length());\n\n  decodeData(nullptr, data, end_stream, FilterIterationStartState::CanStartFromCurrent);\n}\n\nvoid ConnectionManagerImpl::ActiveStream::decodeData(\n    ActiveStreamDecoderFilter* filter, Buffer::Instance& data, bool end_stream,\n    FilterIterationStartState filter_iteration_start_state) {\n  ScopeTrackerScopeState scope(this,\n                               connection_manager_.read_callbacks_->connection().dispatcher());\n  resetIdleTimer();\n\n  // If we previously decided to decode only the headers, do nothing here.\n  if (decoding_headers_only_) {\n    return;\n  }\n\n  // If a response is complete or a reset has been sent, filters do not care about further body\n  // data. Just drop it.\n  if (state_.local_complete_) {\n    return;\n  }\n\n  auto trailers_added_entry = decoder_filters_.end();\n  const bool trailers_exists_at_start = request_trailers_ != nullptr;\n  // Filter iteration may start at the current filter.\n  std::list<ActiveStreamDecoderFilterPtr>::iterator entry =\n      commonDecodePrefix(filter, filter_iteration_start_state);\n\n  for (; entry != decoder_filters_.end(); entry++) {\n    // If the filter pointed by entry has stopped for all frame types, return now.\n    if (handleDataIfStopAll(**entry, data, state_.decoder_filters_streaming_)) {\n      return;\n    }\n    // If end_stream_ is marked for a filter, the data is not for this filter and filters after.\n    //\n    // In following case, ActiveStreamFilterBase::commonContinue() could be called recursively and\n    // its doData() is called with wrong data.\n    //\n    //  There are 3 decode filters and \"wrapper\" refers to ActiveStreamFilter object.\n    //\n    //  filter0->decodeHeaders(_, true)\n    //    return STOP\n    //  filter0->continueDecoding()\n    //    wrapper0->commonContinue()\n    //      wrapper0->decodeHeaders(_, _, true)\n    //        filter1->decodeHeaders(_, true)\n    //          filter1->addDecodeData()\n    //          return CONTINUE\n    //        filter2->decodeHeaders(_, false)\n    //          return CONTINUE\n    //        wrapper1->commonContinue() // Detects data is added.\n    //          wrapper1->doData()\n    //            wrapper1->decodeData()\n    //              filter2->decodeData(_, true)\n    //                 return CONTINUE\n    //      wrapper0->doData() // This should not be called\n    //        wrapper0->decodeData()\n    //          filter1->decodeData(_, true)  // It will cause assertions.\n    //\n    // One way to solve this problem is to mark end_stream_ for each filter.\n    // If a filter is already marked as end_stream_ when decodeData() is called, bails out the\n    // whole function. If just skip the filter, the codes after the loop will be called with\n    // wrong data. For encodeData, the response_encoder->encode() will be called.\n    if ((*entry)->end_stream_) {\n      return;\n    }\n    ASSERT(!(state_.filter_call_state_ & FilterCallState::DecodeData));\n\n    // We check the request_trailers_ pointer here in case addDecodedTrailers\n    // is called in decodeData during a previous filter invocation, at which point we communicate to\n    // the current and future filters that the stream has not yet ended.\n    if (end_stream) {\n      state_.filter_call_state_ |= FilterCallState::LastDataFrame;\n    }\n\n    recordLatestDataFilter(entry, state_.latest_data_decoding_filter_, decoder_filters_);\n\n    state_.filter_call_state_ |= FilterCallState::DecodeData;\n    (*entry)->end_stream_ = end_stream && !request_trailers_;\n    FilterDataStatus status = (*entry)->handle_->decodeData(data, (*entry)->end_stream_);\n    if ((*entry)->end_stream_) {\n      (*entry)->handle_->decodeComplete();\n    }\n    state_.filter_call_state_ &= ~FilterCallState::DecodeData;\n    if (end_stream) {\n      state_.filter_call_state_ &= ~FilterCallState::LastDataFrame;\n    }\n    ENVOY_STREAM_LOG(trace, \"decode data called: filter={} status={}\", *this,\n                     static_cast<const void*>((*entry).get()), static_cast<uint64_t>(status));\n\n    processNewlyAddedMetadata();\n\n    if (!trailers_exists_at_start && request_trailers_ &&\n        trailers_added_entry == decoder_filters_.end()) {\n      trailers_added_entry = entry;\n    }\n\n    if (!(*entry)->commonHandleAfterDataCallback(status, data, state_.decoder_filters_streaming_) &&\n        std::next(entry) != decoder_filters_.end()) {\n      // Stop iteration IFF this is not the last filter. If it is the last filter, continue with\n      // processing since we need to handle the case where a terminal filter wants to buffer, but\n      // a previous filter has added trailers.\n      return;\n    }\n  }\n\n  // If trailers were adding during decodeData we need to trigger decodeTrailers in order\n  // to allow filters to process the trailers.\n  if (trailers_added_entry != decoder_filters_.end()) {\n    decodeTrailers(trailers_added_entry->get(), *request_trailers_);\n  }\n\n  if (end_stream) {\n    disarmRequestTimeout();\n  }\n}\n\nHeaderMap& ConnectionManagerImpl::ActiveStream::addDecodedTrailers() {\n  // Trailers can only be added during the last data frame (i.e. end_stream = true).\n  ASSERT(state_.filter_call_state_ & FilterCallState::LastDataFrame);\n\n  // Trailers can only be added once.\n  ASSERT(!request_trailers_);\n\n  request_trailers_ = std::make_unique<HeaderMapImpl>();\n  return *request_trailers_;\n}\n\nvoid ConnectionManagerImpl::ActiveStream::addDecodedData(ActiveStreamDecoderFilter& filter,\n                                                         Buffer::Instance& data, bool streaming) {\n  if (state_.filter_call_state_ == 0 ||\n      (state_.filter_call_state_ & FilterCallState::DecodeHeaders) ||\n      (state_.filter_call_state_ & FilterCallState::DecodeData) ||\n      ((state_.filter_call_state_ & FilterCallState::DecodeTrailers) && !filter.canIterate())) {\n    // Make sure if this triggers watermarks, the correct action is taken.\n    state_.decoder_filters_streaming_ = streaming;\n    // If no call is happening or we are in the decode headers/data callback, buffer the data.\n    // Inline processing happens in the decodeHeaders() callback if necessary.\n    filter.commonHandleBufferData(data);\n  } else if (state_.filter_call_state_ & FilterCallState::DecodeTrailers) {\n    // In this case we need to inline dispatch the data to further filters. If those filters\n    // choose to buffer/stop iteration that's fine.\n    decodeData(&filter, data, false, FilterIterationStartState::AlwaysStartFromNext);\n  } else {\n    // TODO(mattklein123): Formalize error handling for filters and add tests. Should probably\n    // throw an exception here.\n    NOT_IMPLEMENTED_GCOVR_EXCL_LINE;\n  }\n}\n\nMetadataMapVector& ConnectionManagerImpl::ActiveStream::addDecodedMetadata() {\n  return *getRequestMetadataMapVector();\n}\n\nvoid ConnectionManagerImpl::ActiveStream::decodeTrailers(HeaderMapPtr&& trailers) {\n  ScopeTrackerScopeState scope(this,\n                               connection_manager_.read_callbacks_->connection().dispatcher());\n  resetIdleTimer();\n  maybeEndDecode(true);\n  request_trailers_ = std::move(trailers);\n  decodeTrailers(nullptr, *request_trailers_);\n}\n\nvoid ConnectionManagerImpl::ActiveStream::decodeTrailers(ActiveStreamDecoderFilter* filter,\n                                                         HeaderMap& trailers) {\n  // If we previously decided to decode only the headers, do nothing here.\n  if (decoding_headers_only_) {\n    return;\n  }\n\n  // See decodeData() above for why we check local_complete_ here.\n  if (state_.local_complete_) {\n    return;\n  }\n\n  // Filter iteration may start at the current filter.\n  std::list<ActiveStreamDecoderFilterPtr>::iterator entry =\n      commonDecodePrefix(filter, FilterIterationStartState::CanStartFromCurrent);\n\n  for (; entry != decoder_filters_.end(); entry++) {\n    // If the filter pointed by entry has stopped for all frame type, return now.\n    if ((*entry)->stoppedAll()) {\n      return;\n    }\n\n    ASSERT(!(state_.filter_call_state_ & FilterCallState::DecodeTrailers));\n    state_.filter_call_state_ |= FilterCallState::DecodeTrailers;\n    FilterTrailersStatus status = (*entry)->handle_->decodeTrailers(trailers);\n    (*entry)->handle_->decodeComplete();\n    (*entry)->end_stream_ = true;\n    state_.filter_call_state_ &= ~FilterCallState::DecodeTrailers;\n    ENVOY_STREAM_LOG(trace, \"decode trailers called: filter={} status={}\", *this,\n                     static_cast<const void*>((*entry).get()), static_cast<uint64_t>(status));\n\n    processNewlyAddedMetadata();\n\n    if (!(*entry)->commonHandleAfterTrailersCallback(status)) {\n      return;\n    }\n  }\n  disarmRequestTimeout();\n}\n\nvoid ConnectionManagerImpl::ActiveStream::decodeMetadata(MetadataMapPtr&& metadata_map) {\n  resetIdleTimer();\n  // After going through filters, the ownership of metadata_map will be passed to terminal filter.\n  // The terminal filter may encode metadata_map to the next hop immediately or store metadata_map\n  // and encode later when connection pool is ready.\n  decodeMetadata(nullptr, *metadata_map);\n}\n\nvoid ConnectionManagerImpl::ActiveStream::decodeMetadata(ActiveStreamDecoderFilter* filter,\n                                                         MetadataMap& metadata_map) {\n  // Filter iteration may start at the current filter.\n  std::list<ActiveStreamDecoderFilterPtr>::iterator entry =\n      commonDecodePrefix(filter, FilterIterationStartState::CanStartFromCurrent);\n\n  for (; entry != decoder_filters_.end(); entry++) {\n    // If the filter pointed by entry has stopped for all frame type, stores metadata and returns.\n    // If the filter pointed by entry hasn't returned from decodeHeaders, stores newly added\n    // metadata in case decodeHeaders returns StopAllIteration. The latter can happen when headers\n    // callbacks generate new metadata.\n    if (!(*entry)->decode_headers_called_ || (*entry)->stoppedAll()) {\n      Http::MetadataMapPtr metadata_map_ptr = std::make_unique<Http::MetadataMap>(metadata_map);\n      (*entry)->getSavedRequestMetadata()->emplace_back(std::move(metadata_map_ptr));\n      return;\n    }\n\n    FilterMetadataStatus status = (*entry)->handle_->decodeMetadata(metadata_map);\n    ENVOY_STREAM_LOG(trace, \"decode metadata called: filter={} status={}, metadata: {}\", *this,\n                     static_cast<const void*>((*entry).get()), static_cast<uint64_t>(status),\n                     metadata_map);\n  }\n}\n\nvoid ConnectionManagerImpl::ActiveStream::maybeEndDecode(bool end_stream) {\n  ASSERT(!state_.remote_complete_);\n  state_.remote_complete_ = end_stream;\n  if (end_stream) {\n    stream_info_.onLastDownstreamRxByteReceived();\n    ENVOY_STREAM_LOG(debug, \"request end stream\", *this);\n  }\n}\n\nvoid ConnectionManagerImpl::ActiveStream::disarmRequestTimeout() {\n  if (request_timer_) {\n    request_timer_->disableTimer();\n  }\n}\n\nstd::list<ConnectionManagerImpl::ActiveStreamEncoderFilterPtr>::iterator\nConnectionManagerImpl::ActiveStream::commonEncodePrefix(\n    ActiveStreamEncoderFilter* filter, bool end_stream,\n    FilterIterationStartState filter_iteration_start_state) {\n  // Only do base state setting on the initial call. Subsequent calls for filtering do not touch\n  // the base state.\n  if (filter == nullptr) {\n    ASSERT(!state_.local_complete_);\n    state_.local_complete_ = end_stream;\n    return encoder_filters_.begin();\n  }\n\n  if (filter_iteration_start_state == FilterIterationStartState::CanStartFromCurrent &&\n      (*(filter->entry()))->iterate_from_current_filter_) {\n    // The filter iteration has been stopped for all frame types, and now the iteration continues.\n    // The current filter's encoding callback has not be called. Call it now.\n    return filter->entry();\n  }\n  return std::next(filter->entry());\n}\n\nstd::list<ConnectionManagerImpl::ActiveStreamDecoderFilterPtr>::iterator\nConnectionManagerImpl::ActiveStream::commonDecodePrefix(\n    ActiveStreamDecoderFilter* filter, FilterIterationStartState filter_iteration_start_state) {\n  if (!filter) {\n    return decoder_filters_.begin();\n  }\n  if (filter_iteration_start_state == FilterIterationStartState::CanStartFromCurrent &&\n      (*(filter->entry()))->iterate_from_current_filter_) {\n    // The filter iteration has been stopped for all frame types, and now the iteration continues.\n    // The current filter's callback function has not been called. Call it now.\n    return filter->entry();\n  }\n  return std::next(filter->entry());\n}\n\nvoid ConnectionManagerImpl::startDrainSequence() {\n  ASSERT(drain_state_ == DrainState::NotDraining);\n  drain_state_ = DrainState::Draining;\n  codec_->shutdownNotice();\n  drain_timer_ = read_callbacks_->connection().dispatcher().createTimer(\n      [this]() -> void { onDrainTimeout(); });\n  drain_timer_->enableTimer(config_.drainTimeout());\n}\n\nvoid ConnectionManagerImpl::ActiveStream::snapScopedRouteConfig() {\n  ASSERT(request_headers_ != nullptr,\n         \"Try to snap scoped route config when there is no request headers.\");\n\n  // NOTE: if a RDS subscription hasn't got a RouteConfiguration back, a Router::NullConfigImpl is\n  // returned, in that case we let it pass.\n  snapped_route_config_ = snapped_scoped_routes_config_->getRouteConfig(*request_headers_);\n  if (snapped_route_config_ == nullptr) {\n    ENVOY_STREAM_LOG(trace, \"can't find SRDS scope.\", *this);\n    // TODO(stevenzzzz): Consider to pass an error message to router filter, so that it can\n    // send back 404 with some more details.\n    snapped_route_config_ = std::make_shared<Router::NullConfigImpl>();\n  }\n}\n\nvoid ConnectionManagerImpl::ActiveStream::refreshCachedRoute() {\n  Router::RouteConstSharedPtr route;\n  if (request_headers_ != nullptr) {\n    if (dynamic_cast<Server::Admin*>(&connection_manager_.config_) == nullptr &&\n        connection_manager_.config_.scopedRouteConfigProvider() != nullptr) {\n      // NOTE: re-select scope as well in case the scope key header has been changed by a filter.\n      snapScopedRouteConfig();\n    }\n    if (snapped_route_config_ != nullptr) {\n      route = snapped_route_config_->route(*request_headers_, stream_id_);\n    }\n  }\n  stream_info_.route_entry_ = route ? route->routeEntry() : nullptr;\n  cached_route_ = std::move(route);\n  if (nullptr == stream_info_.route_entry_) {\n    cached_cluster_info_ = nullptr;\n  } else {\n    Upstream::ThreadLocalCluster* local_cluster =\n        connection_manager_.cluster_manager_.get(stream_info_.route_entry_->clusterName());\n    cached_cluster_info_ = (nullptr == local_cluster) ? nullptr : local_cluster->info();\n  }\n}\n\nvoid ConnectionManagerImpl::ActiveStream::sendLocalReply(\n    bool is_grpc_request, Code code, absl::string_view body,\n    const std::function<void(HeaderMap& headers)>& modify_headers, bool is_head_request,\n    const absl::optional<Grpc::Status::GrpcStatus> grpc_status, absl::string_view details) {\n  ENVOY_STREAM_LOG(debug, \"Sending local reply with details {}\", *this, details);\n  ASSERT(response_headers_ == nullptr);\n  // For early error handling, do a best-effort attempt to create a filter chain\n  // to ensure access logging.\n  if (!state_.created_filter_chain_) {\n    createFilterChain();\n  }\n  stream_info_.setResponseCodeDetails(details);\n  Utility::sendLocalReply(\n      is_grpc_request,\n      [this, modify_headers](HeaderMapPtr&& headers, bool end_stream) -> void {\n        if (modify_headers != nullptr) {\n          modify_headers(*headers);\n        }\n        response_headers_ = std::move(headers);\n        // TODO: Start encoding from the last decoder filter that saw the\n        // request instead.\n        encodeHeaders(nullptr, *response_headers_, end_stream);\n      },\n      [this](Buffer::Instance& data, bool end_stream) -> void {\n        // TODO: Start encoding from the last decoder filter that saw the\n        // request instead.\n        encodeData(nullptr, data, end_stream, FilterIterationStartState::CanStartFromCurrent);\n      },\n      state_.destroyed_, code, body, grpc_status, is_head_request);\n}\n\nvoid ConnectionManagerImpl::ActiveStream::encode100ContinueHeaders(\n    ActiveStreamEncoderFilter* filter, HeaderMap& headers) {\n  resetIdleTimer();\n  ASSERT(connection_manager_.config_.proxy100Continue());\n  // Make sure commonContinue continues encode100ContinueHeaders.\n  has_continue_headers_ = true;\n\n  // Similar to the block in encodeHeaders, run encode100ContinueHeaders on each\n  // filter. This is simpler than that case because 100 continue implies no\n  // end-stream, and because there are normal headers coming there's no need for\n  // complex continuation logic.\n  // 100-continue filter iteration should always start with the next filter if available.\n  std::list<ActiveStreamEncoderFilterPtr>::iterator entry =\n      commonEncodePrefix(filter, false, FilterIterationStartState::AlwaysStartFromNext);\n  for (; entry != encoder_filters_.end(); entry++) {\n    ASSERT(!(state_.filter_call_state_ & FilterCallState::Encode100ContinueHeaders));\n    state_.filter_call_state_ |= FilterCallState::Encode100ContinueHeaders;\n    FilterHeadersStatus status = (*entry)->handle_->encode100ContinueHeaders(headers);\n    state_.filter_call_state_ &= ~FilterCallState::Encode100ContinueHeaders;\n    ENVOY_STREAM_LOG(trace, \"encode 100 continue headers called: filter={} status={}\", *this,\n                     static_cast<const void*>((*entry).get()), static_cast<uint64_t>(status));\n    if (!(*entry)->commonHandleAfter100ContinueHeadersCallback(status)) {\n      return;\n    }\n  }\n\n  // Strip the T-E headers etc. Defer other header additions as well as drain-close logic to the\n  // continuation headers.\n  ConnectionManagerUtility::mutateResponseHeaders(headers, request_headers_.get(), EMPTY_STRING);\n\n  // Count both the 1xx and follow-up response code in stats.\n  chargeStats(headers);\n\n  ENVOY_STREAM_LOG(debug, \"encoding 100 continue headers via codec:\\n{}\", *this, headers);\n\n  // Now actually encode via the codec.\n  response_encoder_->encode100ContinueHeaders(headers);\n}\n\nvoid ConnectionManagerImpl::ActiveStream::encodeHeaders(ActiveStreamEncoderFilter* filter,\n                                                        HeaderMap& headers, bool end_stream) {\n  resetIdleTimer();\n  disarmRequestTimeout();\n\n  // Headers filter iteration should always start with the next filter if available.\n  std::list<ActiveStreamEncoderFilterPtr>::iterator entry =\n      commonEncodePrefix(filter, end_stream, FilterIterationStartState::AlwaysStartFromNext);\n  std::list<ActiveStreamEncoderFilterPtr>::iterator continue_data_entry = encoder_filters_.end();\n\n  for (; entry != encoder_filters_.end(); entry++) {\n    ASSERT(!(state_.filter_call_state_ & FilterCallState::EncodeHeaders));\n    state_.filter_call_state_ |= FilterCallState::EncodeHeaders;\n    (*entry)->end_stream_ =\n        encoding_headers_only_ || (end_stream && continue_data_entry == encoder_filters_.end());\n    FilterHeadersStatus status = (*entry)->handle_->encodeHeaders(headers, (*entry)->end_stream_);\n    if ((*entry)->end_stream_) {\n      (*entry)->handle_->encodeComplete();\n    }\n    state_.filter_call_state_ &= ~FilterCallState::EncodeHeaders;\n    ENVOY_STREAM_LOG(trace, \"encode headers called: filter={} status={}\", *this,\n                     static_cast<const void*>((*entry).get()), static_cast<uint64_t>(status));\n\n    (*entry)->encode_headers_called_ = true;\n    const auto continue_iteration =\n        (*entry)->commonHandleAfterHeadersCallback(status, encoding_headers_only_);\n\n    // If we're encoding a headers only response, then mark the local as complete. This ensures\n    // that we don't attempt to reset the downstream request in doEndStream.\n    if (encoding_headers_only_) {\n      state_.local_complete_ = true;\n    }\n\n    if (!continue_iteration) {\n      return;\n    }\n\n    // Here we handle the case where we have a header only response, but a filter adds a body\n    // to it. We need to not raise end_stream = true to further filters during inline iteration.\n    if (end_stream && buffered_response_data_ && continue_data_entry == encoder_filters_.end()) {\n      continue_data_entry = entry;\n    }\n  }\n\n  // Base headers.\n  connection_manager_.config_.dateProvider().setDateHeader(headers);\n  // Following setReference() is safe because serverName() is constant for the life of the listener.\n  const auto transformation = connection_manager_.config_.serverHeaderTransformation();\n  if (transformation == ConnectionManagerConfig::HttpConnectionManagerProto::OVERWRITE ||\n      (transformation == ConnectionManagerConfig::HttpConnectionManagerProto::APPEND_IF_ABSENT &&\n       headers.Server() == nullptr)) {\n    headers.insertServer().value().setReference(connection_manager_.config_.serverName());\n  }\n  ConnectionManagerUtility::mutateResponseHeaders(headers, request_headers_.get(),\n                                                  connection_manager_.config_.via());\n\n  // See if we want to drain/close the connection. Send the go away frame prior to encoding the\n  // header block.\n  if (connection_manager_.drain_state_ == DrainState::NotDraining &&\n      connection_manager_.drain_close_.drainClose()) {\n\n    // This doesn't really do anything for HTTP/1.1 other then give the connection another boost\n    // of time to race with incoming requests. It mainly just keeps the logic the same between\n    // HTTP/1.1 and HTTP/2.\n    connection_manager_.startDrainSequence();\n    connection_manager_.stats_.named_.downstream_cx_drain_close_.inc();\n    ENVOY_STREAM_LOG(debug, \"drain closing connection\", *this);\n  }\n\n  if (connection_manager_.drain_state_ == DrainState::NotDraining && state_.saw_connection_close_) {\n    ENVOY_STREAM_LOG(debug, \"closing connection due to connection close header\", *this);\n    connection_manager_.drain_state_ = DrainState::Closing;\n  }\n\n  if (connection_manager_.drain_state_ == DrainState::NotDraining &&\n      connection_manager_.overload_disable_keepalive_ref_ == Server::OverloadActionState::Active) {\n    ENVOY_STREAM_LOG(debug, \"disabling keepalive due to envoy overload\", *this);\n    connection_manager_.drain_state_ = DrainState::Closing;\n    connection_manager_.stats_.named_.downstream_cx_overload_disable_keepalive_.inc();\n  }\n\n  // If we are destroying a stream before remote is complete and the connection does not support\n  // multiplexing, we should disconnect since we don't want to wait around for the request to\n  // finish.\n  if (!state_.remote_complete_) {\n    if (connection_manager_.codec_->protocol() != Protocol::Http2) {\n      connection_manager_.drain_state_ = DrainState::Closing;\n    }\n\n    connection_manager_.stats_.named_.downstream_rq_response_before_rq_complete_.inc();\n  }\n\n  if (connection_manager_.drain_state_ != DrainState::NotDraining &&\n      connection_manager_.codec_->protocol() != Protocol::Http2) {\n    // If the connection manager is draining send \"Connection: Close\" on HTTP/1.1 connections.\n    // Do not do this for H2 (which drains via GOAWAY) or Upgrade (as the upgrade\n    // payload is no longer HTTP/1.1)\n    if (!Utility::isUpgrade(headers)) {\n      headers.insertConnection().value().setReference(Headers::get().ConnectionValues.Close);\n    }\n  }\n\n  if (connection_manager_.config_.tracingConfig()) {\n    if (connection_manager_.config_.tracingConfig()->operation_name_ ==\n        Tracing::OperationName::Ingress) {\n      // For ingress (inbound) responses, if the request headers do not include a\n      // decorator operation (override), then pass the decorator's operation name (if defined)\n      // as a response header to enable the client service to use it in its client span.\n      if (decorated_operation_) {\n        headers.insertEnvoyDecoratorOperation().value(*decorated_operation_);\n      }\n    } else if (connection_manager_.config_.tracingConfig()->operation_name_ ==\n               Tracing::OperationName::Egress) {\n      const HeaderEntry* resp_operation_override = headers.EnvoyDecoratorOperation();\n\n      // For Egress (outbound) response, if a decorator operation name has been provided, it\n      // should be used to override the active span's operation.\n      if (resp_operation_override) {\n        if (!resp_operation_override->value().empty() && active_span_) {\n          active_span_->setOperation(resp_operation_override->value().getStringView());\n        }\n        // Remove header so not propagated to service.\n        headers.removeEnvoyDecoratorOperation();\n      }\n    }\n  }\n\n  chargeStats(headers);\n\n  ENVOY_STREAM_LOG(debug, \"encoding headers via codec (end_stream={}):\\n{}\", *this,\n                   encoding_headers_only_ ||\n                       (end_stream && continue_data_entry == encoder_filters_.end()),\n                   headers);\n\n  // Now actually encode via the codec.\n  stream_info_.onFirstDownstreamTxByteSent();\n  response_encoder_->encodeHeaders(\n      headers,\n      encoding_headers_only_ || (end_stream && continue_data_entry == encoder_filters_.end()));\n  if (continue_data_entry != encoder_filters_.end()) {\n    // We use the continueEncoding() code since it will correctly handle not calling\n    // encodeHeaders() again. Fake setting StopSingleIteration since the continueEncoding() code\n    // expects it.\n    ASSERT(buffered_response_data_);\n    (*continue_data_entry)->iteration_state_ =\n        ActiveStreamFilterBase::IterationState::StopSingleIteration;\n    (*continue_data_entry)->continueEncoding();\n  } else {\n    // End encoding if this is a header only response, either due to a filter converting it to one\n    // or due to the upstream returning headers only.\n    maybeEndEncode(encoding_headers_only_ || end_stream);\n  }\n}\n\nvoid ConnectionManagerImpl::ActiveStream::encodeMetadata(ActiveStreamEncoderFilter* filter,\n                                                         MetadataMapPtr&& metadata_map_ptr) {\n  resetIdleTimer();\n\n  std::list<ActiveStreamEncoderFilterPtr>::iterator entry =\n      commonEncodePrefix(filter, false, FilterIterationStartState::CanStartFromCurrent);\n\n  for (; entry != encoder_filters_.end(); entry++) {\n    // If the filter pointed by entry has stopped for all frame type, stores metadata and returns.\n    // If the filter pointed by entry hasn't returned from encodeHeaders, stores newly added\n    // metadata in case encodeHeaders returns StopAllIteration. The latter can happen when headers\n    // callbacks generate new metadata.\n    if (!(*entry)->encode_headers_called_ || (*entry)->stoppedAll()) {\n      (*entry)->getSavedResponseMetadata()->emplace_back(std::move(metadata_map_ptr));\n      return;\n    }\n\n    FilterMetadataStatus status = (*entry)->handle_->encodeMetadata(*metadata_map_ptr);\n    ENVOY_STREAM_LOG(trace, \"encode metadata called: filter={} status={}\", *this,\n                     static_cast<const void*>((*entry).get()), static_cast<uint64_t>(status));\n  }\n  // TODO(soya3129): update stats with metadata.\n\n  // Now encode metadata via the codec.\n  if (!metadata_map_ptr->empty()) {\n    ENVOY_STREAM_LOG(debug, \"encoding metadata via codec:\\n{}\", *this, *metadata_map_ptr);\n    MetadataMapVector metadata_map_vector;\n    metadata_map_vector.emplace_back(std::move(metadata_map_ptr));\n    response_encoder_->encodeMetadata(metadata_map_vector);\n  }\n}\n\nHeaderMap& ConnectionManagerImpl::ActiveStream::addEncodedTrailers() {\n  // Trailers can only be added during the last data frame (i.e. end_stream = true).\n  ASSERT(state_.filter_call_state_ & FilterCallState::LastDataFrame);\n\n  // Trailers can only be added once.\n  ASSERT(!response_trailers_);\n\n  response_trailers_ = std::make_unique<HeaderMapImpl>();\n  return *response_trailers_;\n}\n\nvoid ConnectionManagerImpl::ActiveStream::addEncodedData(ActiveStreamEncoderFilter& filter,\n                                                         Buffer::Instance& data, bool streaming) {\n  if (state_.filter_call_state_ == 0 ||\n      (state_.filter_call_state_ & FilterCallState::EncodeHeaders) ||\n      (state_.filter_call_state_ & FilterCallState::EncodeData) ||\n      ((state_.filter_call_state_ & FilterCallState::EncodeTrailers) && !filter.canIterate())) {\n    // Make sure if this triggers watermarks, the correct action is taken.\n    state_.encoder_filters_streaming_ = streaming;\n    // If no call is happening or we are in the decode headers/data callback, buffer the data.\n    // Inline processing happens in the decodeHeaders() callback if necessary.\n    filter.commonHandleBufferData(data);\n  } else if (state_.filter_call_state_ & FilterCallState::EncodeTrailers) {\n    // In this case we need to inline dispatch the data to further filters. If those filters\n    // choose to buffer/stop iteration that's fine.\n    encodeData(&filter, data, false, FilterIterationStartState::AlwaysStartFromNext);\n  } else {\n    // TODO(mattklein123): Formalize error handling for filters and add tests. Should probably\n    // throw an exception here.\n    NOT_IMPLEMENTED_GCOVR_EXCL_LINE;\n  }\n}\n\nvoid ConnectionManagerImpl::ActiveStream::encodeData(\n    ActiveStreamEncoderFilter* filter, Buffer::Instance& data, bool end_stream,\n    FilterIterationStartState filter_iteration_start_state) {\n  resetIdleTimer();\n\n  // If we previously decided to encode only the headers, do nothing here.\n  if (encoding_headers_only_) {\n    return;\n  }\n\n  // Filter iteration may start at the current filter.\n  std::list<ActiveStreamEncoderFilterPtr>::iterator entry =\n      commonEncodePrefix(filter, end_stream, filter_iteration_start_state);\n  auto trailers_added_entry = encoder_filters_.end();\n\n  const bool trailers_exists_at_start = response_trailers_ != nullptr;\n  for (; entry != encoder_filters_.end(); entry++) {\n    // If the filter pointed by entry has stopped for all frame type, return now.\n    if (handleDataIfStopAll(**entry, data, state_.encoder_filters_streaming_)) {\n      return;\n    }\n    // If end_stream_ is marked for a filter, the data is not for this filter and filters after.\n    // For details, please see the comment in the ActiveStream::decodeData() function.\n    if ((*entry)->end_stream_) {\n      return;\n    }\n    ASSERT(!(state_.filter_call_state_ & FilterCallState::EncodeData));\n\n    // We check the response_trailers_ pointer here in case addEncodedTrailers\n    // is called in encodeData during a previous filter invocation, at which point we communicate to\n    // the current and future filters that the stream has not yet ended.\n    state_.filter_call_state_ |= FilterCallState::EncodeData;\n    if (end_stream) {\n      state_.filter_call_state_ |= FilterCallState::LastDataFrame;\n    }\n\n    recordLatestDataFilter(entry, state_.latest_data_encoding_filter_, encoder_filters_);\n\n    (*entry)->end_stream_ = end_stream && !response_trailers_;\n    FilterDataStatus status = (*entry)->handle_->encodeData(data, (*entry)->end_stream_);\n    if ((*entry)->end_stream_) {\n      (*entry)->handle_->encodeComplete();\n    }\n    state_.filter_call_state_ &= ~FilterCallState::EncodeData;\n    if (end_stream) {\n      state_.filter_call_state_ &= ~FilterCallState::LastDataFrame;\n    }\n    ENVOY_STREAM_LOG(trace, \"encode data called: filter={} status={}\", *this,\n                     static_cast<const void*>((*entry).get()), static_cast<uint64_t>(status));\n\n    if (!trailers_exists_at_start && response_trailers_ &&\n        trailers_added_entry == encoder_filters_.end()) {\n      trailers_added_entry = entry;\n    }\n\n    if (!(*entry)->commonHandleAfterDataCallback(status, data, state_.encoder_filters_streaming_)) {\n      return;\n    }\n  }\n\n  ENVOY_STREAM_LOG(trace, \"encoding data via codec (size={} end_stream={})\", *this, data.length(),\n                   end_stream);\n\n  stream_info_.addBytesSent(data.length());\n\n  // If trailers were adding during encodeData we need to trigger decodeTrailers in order\n  // to allow filters to process the trailers.\n  if (trailers_added_entry != encoder_filters_.end()) {\n    response_encoder_->encodeData(data, false);\n    encodeTrailers(trailers_added_entry->get(), *response_trailers_);\n  } else {\n    response_encoder_->encodeData(data, end_stream);\n    maybeEndEncode(end_stream);\n  }\n}\n\nvoid ConnectionManagerImpl::ActiveStream::encodeTrailers(ActiveStreamEncoderFilter* filter,\n                                                         HeaderMap& trailers) {\n  resetIdleTimer();\n\n  // If we previously decided to encode only the headers, do nothing here.\n  if (encoding_headers_only_) {\n    return;\n  }\n\n  // Filter iteration may start at the current filter.\n  std::list<ActiveStreamEncoderFilterPtr>::iterator entry =\n      commonEncodePrefix(filter, true, FilterIterationStartState::CanStartFromCurrent);\n  for (; entry != encoder_filters_.end(); entry++) {\n    // If the filter pointed by entry has stopped for all frame type, return now.\n    if ((*entry)->stoppedAll()) {\n      return;\n    }\n    ASSERT(!(state_.filter_call_state_ & FilterCallState::EncodeTrailers));\n    state_.filter_call_state_ |= FilterCallState::EncodeTrailers;\n    FilterTrailersStatus status = (*entry)->handle_->encodeTrailers(trailers);\n    (*entry)->handle_->encodeComplete();\n    (*entry)->end_stream_ = true;\n    state_.filter_call_state_ &= ~FilterCallState::EncodeTrailers;\n    ENVOY_STREAM_LOG(trace, \"encode trailers called: filter={} status={}\", *this,\n                     static_cast<const void*>((*entry).get()), static_cast<uint64_t>(status));\n    if (!(*entry)->commonHandleAfterTrailersCallback(status)) {\n      return;\n    }\n  }\n\n  ENVOY_STREAM_LOG(debug, \"encoding trailers via codec:\\n{}\", *this, trailers);\n\n  response_encoder_->encodeTrailers(trailers);\n  maybeEndEncode(true);\n}\n\nvoid ConnectionManagerImpl::ActiveStream::maybeEndEncode(bool end_stream) {\n  if (end_stream) {\n    ASSERT(!state_.codec_saw_local_complete_);\n    state_.codec_saw_local_complete_ = true;\n    stream_info_.onLastDownstreamTxByteSent();\n    request_response_timespan_->complete();\n    connection_manager_.doEndStream(*this);\n  }\n}\n\nbool ConnectionManagerImpl::ActiveStream::processNewlyAddedMetadata() {\n  if (request_metadata_map_vector_ == nullptr) {\n    return false;\n  }\n  for (const auto& metadata_map : *getRequestMetadataMapVector()) {\n    decodeMetadata(nullptr, *metadata_map);\n  }\n  getRequestMetadataMapVector()->clear();\n  return true;\n}\n\nbool ConnectionManagerImpl::ActiveStream::handleDataIfStopAll(ActiveStreamFilterBase& filter,\n                                                              Buffer::Instance& data,\n                                                              bool& filter_streaming) {\n  if (filter.stoppedAll()) {\n    ASSERT(!filter.canIterate());\n    filter_streaming =\n        filter.iteration_state_ == ActiveStreamFilterBase::IterationState::StopAllWatermark;\n    filter.commonHandleBufferData(data);\n    return true;\n  }\n  return false;\n}\n\nvoid ConnectionManagerImpl::ActiveStream::onResetStream(StreamResetReason, absl::string_view) {\n  // NOTE: This function gets called in all of the following cases:\n  //       1) We TX an app level reset\n  //       2) The codec TX a codec level reset\n  //       3) The codec RX a reset\n  //       If we need to differentiate we need to do it inside the codec. Can start with this.\n  ENVOY_STREAM_LOG(debug, \"stream reset\", *this);\n  connection_manager_.stats_.named_.downstream_rq_rx_reset_.inc();\n  connection_manager_.doDeferredStreamDestroy(*this);\n}\n\nvoid ConnectionManagerImpl::ActiveStream::onAboveWriteBufferHighWatermark() {\n  ENVOY_STREAM_LOG(debug, \"Disabling upstream stream due to downstream stream watermark.\", *this);\n  callHighWatermarkCallbacks();\n}\n\nvoid ConnectionManagerImpl::ActiveStream::onBelowWriteBufferLowWatermark() {\n  ENVOY_STREAM_LOG(debug, \"Enabling upstream stream due to downstream stream watermark.\", *this);\n  callLowWatermarkCallbacks();\n}\n\nTracing::OperationName ConnectionManagerImpl::ActiveStream::operationName() const {\n  return connection_manager_.config_.tracingConfig()->operation_name_;\n}\n\nconst std::vector<Http::LowerCaseString>&\nConnectionManagerImpl::ActiveStream::requestHeadersForTags() const {\n  return connection_manager_.config_.tracingConfig()->request_headers_for_tags_;\n}\n\nbool ConnectionManagerImpl::ActiveStream::verbose() const {\n  return connection_manager_.config_.tracingConfig()->verbose_;\n}\n\nuint32_t ConnectionManagerImpl::ActiveStream::maxPathTagLength() const {\n  return connection_manager_.config_.tracingConfig()->max_path_tag_length_;\n}\n\nvoid ConnectionManagerImpl::ActiveStream::callHighWatermarkCallbacks() {\n  ++high_watermark_count_;\n  for (auto watermark_callbacks : watermark_callbacks_) {\n    watermark_callbacks->onAboveWriteBufferHighWatermark();\n  }\n}\n\nvoid ConnectionManagerImpl::ActiveStream::callLowWatermarkCallbacks() {\n  ASSERT(high_watermark_count_ > 0);\n  --high_watermark_count_;\n  for (auto watermark_callbacks : watermark_callbacks_) {\n    watermark_callbacks->onBelowWriteBufferLowWatermark();\n  }\n}\n\nvoid ConnectionManagerImpl::ActiveStream::setBufferLimit(uint32_t new_limit) {\n  ENVOY_STREAM_LOG(debug, \"setting buffer limit to {}\", *this, new_limit);\n  buffer_limit_ = new_limit;\n  if (buffered_request_data_) {\n    buffered_request_data_->setWatermarks(buffer_limit_);\n  }\n  if (buffered_response_data_) {\n    buffered_response_data_->setWatermarks(buffer_limit_);\n  }\n}\n\nbool ConnectionManagerImpl::ActiveStream::createFilterChain() {\n  if (state_.created_filter_chain_) {\n    return false;\n  }\n  bool upgrade_rejected = false;\n  auto upgrade = request_headers_ ? request_headers_->Upgrade() : nullptr;\n  state_.created_filter_chain_ = true;\n  if (upgrade != nullptr) {\n    const Router::RouteEntry::UpgradeMap* upgrade_map = nullptr;\n\n    // We must check if the 'cached_route_' optional is populated since this function can be called\n    // early via sendLocalReply(), before the cached route is populated.\n    if (hasCachedRoute() && cached_route_.value()->routeEntry()) {\n      upgrade_map = &cached_route_.value()->routeEntry()->upgradeMap();\n    }\n\n    if (connection_manager_.config_.filterFactory().createUpgradeFilterChain(\n            upgrade->value().getStringView(), upgrade_map, *this)) {\n      state_.successful_upgrade_ = true;\n      connection_manager_.stats_.named_.downstream_cx_upgrades_total_.inc();\n      connection_manager_.stats_.named_.downstream_cx_upgrades_active_.inc();\n      return true;\n    } else {\n      upgrade_rejected = true;\n      // Fall through to the default filter chain. The function calling this\n      // will send a local reply indicating that the upgrade failed.\n    }\n  }\n\n  connection_manager_.config_.filterFactory().createFilterChain(*this);\n  return !upgrade_rejected;\n}\n\nvoid ConnectionManagerImpl::ActiveStreamFilterBase::commonContinue() {\n  // TODO(mattklein123): Raise an error if this is called during a callback.\n  if (!canContinue()) {\n    ENVOY_STREAM_LOG(trace, \"cannot continue filter chain: filter={}\", parent_,\n                     static_cast<const void*>(this));\n    return;\n  }\n\n  ENVOY_STREAM_LOG(trace, \"continuing filter chain: filter={}\", parent_,\n                   static_cast<const void*>(this));\n  ASSERT(!canIterate());\n  // If iteration has stopped for all frame types, set iterate_from_current_filter_ to true so the\n  // filter iteration starts with the current filter instead of the next one.\n  if (stoppedAll()) {\n    iterate_from_current_filter_ = true;\n  }\n  allowIteration();\n\n  // Only resume with do100ContinueHeaders() if we've actually seen a 100-Continue.\n  if (parent_.has_continue_headers_ && !continue_headers_continued_) {\n    continue_headers_continued_ = true;\n    do100ContinueHeaders();\n    // If the response headers have not yet come in, don't continue on with\n    // headers and body. doHeaders expects request headers to exist.\n    if (!parent_.response_headers_.get()) {\n      return;\n    }\n  }\n\n  // Make sure that we handle the zero byte data frame case. We make no effort to optimize this\n  // case in terms of merging it into a header only request/response. This could be done in the\n  // future.\n  if (!headers_continued_) {\n    headers_continued_ = true;\n    doHeaders(complete() && !bufferedData() && !trailers());\n  }\n\n  doMetadata();\n\n  if (bufferedData()) {\n    doData(complete() && !trailers());\n  }\n\n  if (trailers()) {\n    doTrailers();\n  }\n\n  iterate_from_current_filter_ = false;\n}\n\nbool ConnectionManagerImpl::ActiveStreamFilterBase::commonHandleAfter100ContinueHeadersCallback(\n    FilterHeadersStatus status) {\n  ASSERT(parent_.has_continue_headers_);\n  ASSERT(!continue_headers_continued_);\n  ASSERT(canIterate());\n\n  if (status == FilterHeadersStatus::StopIteration) {\n    iteration_state_ = IterationState::StopSingleIteration;\n    return false;\n  } else {\n    ASSERT(status == FilterHeadersStatus::Continue);\n    continue_headers_continued_ = true;\n    return true;\n  }\n}\n\nbool ConnectionManagerImpl::ActiveStreamFilterBase::commonHandleAfterHeadersCallback(\n    FilterHeadersStatus status, bool& headers_only) {\n  ASSERT(!headers_continued_);\n  ASSERT(canIterate());\n\n  if (status == FilterHeadersStatus::StopIteration) {\n    iteration_state_ = IterationState::StopSingleIteration;\n  } else if (status == FilterHeadersStatus::StopAllIterationAndBuffer) {\n    iteration_state_ = IterationState::StopAllBuffer;\n  } else if (status == FilterHeadersStatus::StopAllIterationAndWatermark) {\n    iteration_state_ = IterationState::StopAllWatermark;\n  } else if (status == FilterHeadersStatus::ContinueAndEndStream) {\n    // Set headers_only to true so we know to end early if necessary,\n    // but continue filter iteration so we actually write the headers/run the cleanup code.\n    headers_only = true;\n    ENVOY_STREAM_LOG(debug, \"converting to headers only\", parent_);\n  } else {\n    ASSERT(status == FilterHeadersStatus::Continue);\n    headers_continued_ = true;\n  }\n\n  handleMetadataAfterHeadersCallback();\n\n  if (stoppedAll() || status == FilterHeadersStatus::StopIteration) {\n    return false;\n  } else {\n    return true;\n  }\n}\n\nvoid ConnectionManagerImpl::ActiveStreamFilterBase::commonHandleBufferData(\n    Buffer::Instance& provided_data) {\n\n  // The way we do buffering is a little complicated which is why we have this common function\n  // which is used for both encoding and decoding. When data first comes into our filter pipeline,\n  // we send it through. Any filter can choose to stop iteration and buffer or not. If we then\n  // continue iteration in the future, we use the buffered data. A future filter can stop and\n  // buffer again. In this case, since we are already operating on buffered data, we don't\n  // rebuffer, because we assume the filter has modified the buffer as it wishes in place.\n  if (bufferedData().get() != &provided_data) {\n    if (!bufferedData()) {\n      bufferedData() = createBuffer();\n    }\n    bufferedData()->move(provided_data);\n  }\n}\n\nbool ConnectionManagerImpl::ActiveStreamFilterBase::commonHandleAfterDataCallback(\n    FilterDataStatus status, Buffer::Instance& provided_data, bool& buffer_was_streaming) {\n\n  if (status == FilterDataStatus::Continue) {\n    if (iteration_state_ == IterationState::StopSingleIteration) {\n      commonHandleBufferData(provided_data);\n      commonContinue();\n      return false;\n    } else {\n      ASSERT(headers_continued_);\n    }\n  } else {\n    iteration_state_ = IterationState::StopSingleIteration;\n    if (status == FilterDataStatus::StopIterationAndBuffer ||\n        status == FilterDataStatus::StopIterationAndWatermark) {\n      buffer_was_streaming = status == FilterDataStatus::StopIterationAndWatermark;\n      commonHandleBufferData(provided_data);\n    } else if (complete() && !trailers() && !bufferedData()) {\n      // If this filter is doing StopIterationNoBuffer and this stream is terminated with a zero\n      // byte data frame, we need to create an empty buffer to make sure that when commonContinue\n      // is called, the pipeline resumes with an empty data frame with end_stream = true\n      ASSERT(end_stream_);\n      bufferedData() = createBuffer();\n    }\n\n    return false;\n  }\n\n  return true;\n}\n\nbool ConnectionManagerImpl::ActiveStreamFilterBase::commonHandleAfterTrailersCallback(\n    FilterTrailersStatus status) {\n\n  if (status == FilterTrailersStatus::Continue) {\n    if (iteration_state_ == IterationState::StopSingleIteration) {\n      commonContinue();\n      return false;\n    } else {\n      ASSERT(headers_continued_);\n    }\n  } else {\n    return false;\n  }\n\n  return true;\n}\n\nconst Network::Connection* ConnectionManagerImpl::ActiveStreamFilterBase::connection() {\n  return parent_.connection();\n}\n\nEvent::Dispatcher& ConnectionManagerImpl::ActiveStreamFilterBase::dispatcher() {\n  return parent_.connection_manager_.read_callbacks_->connection().dispatcher();\n}\n\nStreamInfo::StreamInfo& ConnectionManagerImpl::ActiveStreamFilterBase::streamInfo() {\n  return parent_.stream_info_;\n}\n\nTracing::Span& ConnectionManagerImpl::ActiveStreamFilterBase::activeSpan() {\n  if (parent_.active_span_) {\n    return *parent_.active_span_;\n  } else {\n    return Tracing::NullSpan::instance();\n  }\n}\n\nTracing::Config& ConnectionManagerImpl::ActiveStreamFilterBase::tracingConfig() { return parent_; }\n\nUpstream::ClusterInfoConstSharedPtr ConnectionManagerImpl::ActiveStreamFilterBase::clusterInfo() {\n  // NOTE: Refreshing route caches clusterInfo as well.\n  if (!parent_.cached_route_.has_value()) {\n    parent_.refreshCachedRoute();\n  }\n\n  return parent_.cached_cluster_info_.value();\n}\n\nRouter::RouteConstSharedPtr ConnectionManagerImpl::ActiveStreamFilterBase::route() {\n  if (!parent_.cached_route_.has_value()) {\n    parent_.refreshCachedRoute();\n  }\n\n  return parent_.cached_route_.value();\n}\n\nvoid ConnectionManagerImpl::ActiveStreamFilterBase::clearRouteCache() {\n  parent_.cached_route_ = absl::optional<Router::RouteConstSharedPtr>();\n  parent_.cached_cluster_info_ = absl::optional<Upstream::ClusterInfoConstSharedPtr>();\n}\n\nBuffer::WatermarkBufferPtr ConnectionManagerImpl::ActiveStreamDecoderFilter::createBuffer() {\n  auto buffer =\n      std::make_unique<Buffer::WatermarkBuffer>([this]() -> void { this->requestDataDrained(); },\n                                                [this]() -> void { this->requestDataTooLarge(); });\n  buffer->setWatermarks(parent_.buffer_limit_);\n  return buffer;\n}\n\nvoid ConnectionManagerImpl::ActiveStreamDecoderFilter::handleMetadataAfterHeadersCallback() {\n  // If we drain accumulated metadata, the iteration must start with the current filter.\n  const bool saved_state = iterate_from_current_filter_;\n  iterate_from_current_filter_ = true;\n  // If decodeHeaders() returns StopAllIteration, we should skip draining metadata, and wait\n  // for doMetadata() to drain the metadata after iteration continues.\n  if (!stoppedAll() && saved_request_metadata_ != nullptr && !getSavedRequestMetadata()->empty()) {\n    drainSavedRequestMetadata();\n  }\n  // Restores the original value of iterate_from_current_filter_.\n  iterate_from_current_filter_ = saved_state;\n}\n\nHeaderMap& ConnectionManagerImpl::ActiveStreamDecoderFilter::addDecodedTrailers() {\n  return parent_.addDecodedTrailers();\n}\n\nvoid ConnectionManagerImpl::ActiveStreamDecoderFilter::addDecodedData(Buffer::Instance& data,\n                                                                      bool streaming) {\n  parent_.addDecodedData(*this, data, streaming);\n}\n\nMetadataMapVector& ConnectionManagerImpl::ActiveStreamDecoderFilter::addDecodedMetadata() {\n  return parent_.addDecodedMetadata();\n}\n\nvoid ConnectionManagerImpl::ActiveStreamDecoderFilter::injectDecodedDataToFilterChain(\n    Buffer::Instance& data, bool end_stream) {\n  parent_.decodeData(this, data, end_stream,\n                     ActiveStream::FilterIterationStartState::CanStartFromCurrent);\n}\n\nvoid ConnectionManagerImpl::ActiveStreamDecoderFilter::continueDecoding() { commonContinue(); }\n\nvoid ConnectionManagerImpl::ActiveStreamDecoderFilter::encode100ContinueHeaders(\n    HeaderMapPtr&& headers) {\n  // If Envoy is not configured to proxy 100-Continue responses, swallow the 100 Continue\n  // here. This avoids the potential situation where Envoy strips Expect: 100-Continue and sends a\n  // 100-Continue, then proxies a duplicate 100 Continue from upstream.\n  if (parent_.connection_manager_.config_.proxy100Continue()) {\n    parent_.continue_headers_ = std::move(headers);\n    parent_.encode100ContinueHeaders(nullptr, *parent_.continue_headers_);\n  }\n}\n\nvoid ConnectionManagerImpl::ActiveStreamDecoderFilter::encodeHeaders(HeaderMapPtr&& headers,\n                                                                     bool end_stream) {\n  parent_.response_headers_ = std::move(headers);\n  parent_.encodeHeaders(nullptr, *parent_.response_headers_, end_stream);\n}\n\nvoid ConnectionManagerImpl::ActiveStreamDecoderFilter::encodeData(Buffer::Instance& data,\n                                                                  bool end_stream) {\n  parent_.encodeData(nullptr, data, end_stream,\n                     ActiveStream::FilterIterationStartState::CanStartFromCurrent);\n}\n\nvoid ConnectionManagerImpl::ActiveStreamDecoderFilter::encodeTrailers(HeaderMapPtr&& trailers) {\n  parent_.response_trailers_ = std::move(trailers);\n  parent_.encodeTrailers(nullptr, *parent_.response_trailers_);\n}\n\nvoid ConnectionManagerImpl::ActiveStreamDecoderFilter::encodeMetadata(\n    MetadataMapPtr&& metadata_map_ptr) {\n  parent_.encodeMetadata(nullptr, std::move(metadata_map_ptr));\n}\n\nvoid ConnectionManagerImpl::ActiveStreamDecoderFilter::\n    onDecoderFilterAboveWriteBufferHighWatermark() {\n  ENVOY_STREAM_LOG(debug, \"Read-disabling downstream stream due to filter callbacks.\", parent_);\n  parent_.response_encoder_->getStream().readDisable(true);\n  parent_.connection_manager_.stats_.named_.downstream_flow_control_paused_reading_total_.inc();\n}\n\nvoid ConnectionManagerImpl::ActiveStreamDecoderFilter::requestDataTooLarge() {\n  ENVOY_STREAM_LOG(debug, \"request data too large watermark exceeded\", parent_);\n  if (parent_.state_.decoder_filters_streaming_) {\n    onDecoderFilterAboveWriteBufferHighWatermark();\n  } else {\n    parent_.connection_manager_.stats_.named_.downstream_rq_too_large_.inc();\n    sendLocalReply(Code::PayloadTooLarge, CodeUtility::toString(Code::PayloadTooLarge), nullptr,\n                   absl::nullopt, StreamInfo::ResponseCodeDetails::get().RequestPayloadTooLarge);\n  }\n}\n\nvoid ConnectionManagerImpl::ActiveStreamDecoderFilter::requestDataDrained() {\n  // If this is called it means the call to requestDataTooLarge() was a\n  // streaming call, or a 413 would have been sent.\n  onDecoderFilterBelowWriteBufferLowWatermark();\n}\n\nvoid ConnectionManagerImpl::ActiveStreamDecoderFilter::\n    onDecoderFilterBelowWriteBufferLowWatermark() {\n  ENVOY_STREAM_LOG(debug, \"Read-enabling downstream stream due to filter callbacks.\", parent_);\n  parent_.response_encoder_->getStream().readDisable(false);\n  parent_.connection_manager_.stats_.named_.downstream_flow_control_resumed_reading_total_.inc();\n}\n\nvoid ConnectionManagerImpl::ActiveStreamDecoderFilter::addDownstreamWatermarkCallbacks(\n    DownstreamWatermarkCallbacks& watermark_callbacks) {\n  // This is called exactly once per upstream-stream, by the router filter. Therefore, we\n  // expect the same callbacks to not be registered twice.\n  ASSERT(std::find(parent_.watermark_callbacks_.begin(), parent_.watermark_callbacks_.end(),\n                   &watermark_callbacks) == parent_.watermark_callbacks_.end());\n  parent_.watermark_callbacks_.emplace(parent_.watermark_callbacks_.end(), &watermark_callbacks);\n  for (uint32_t i = 0; i < parent_.high_watermark_count_; ++i) {\n    watermark_callbacks.onAboveWriteBufferHighWatermark();\n  }\n}\nvoid ConnectionManagerImpl::ActiveStreamDecoderFilter::removeDownstreamWatermarkCallbacks(\n    DownstreamWatermarkCallbacks& watermark_callbacks) {\n  ASSERT(std::find(parent_.watermark_callbacks_.begin(), parent_.watermark_callbacks_.end(),\n                   &watermark_callbacks) != parent_.watermark_callbacks_.end());\n  parent_.watermark_callbacks_.remove(&watermark_callbacks);\n}\n\nbool ConnectionManagerImpl::ActiveStreamDecoderFilter::recreateStream() {\n  // Because the filter's and the HCM view of if the stream has a body and if\n  // the stream is complete may differ, re-check bytesReceived() to make sure\n  // there was no body from the HCM's point of view.\n  if (!complete() || parent_.stream_info_.bytesReceived() != 0) {\n    return false;\n  }\n  // n.b. we do not currently change the codecs to point at the new stream\n  // decoder because the decoder callbacks are complete. It would be good to\n  // null out that pointer but should not be necessary.\n  HeaderMapPtr request_headers(std::move(parent_.request_headers_));\n  StreamEncoder* response_encoder = parent_.response_encoder_;\n  parent_.response_encoder_ = nullptr;\n  // This functionally deletes the stream (via deferred delete) so do not\n  // reference anything beyond this point.\n  parent_.connection_manager_.doEndStream(this->parent_);\n\n  StreamDecoder& new_stream = parent_.connection_manager_.newStream(*response_encoder, true);\n  new_stream.decodeHeaders(std::move(request_headers), true);\n  return true;\n}\n\nBuffer::WatermarkBufferPtr ConnectionManagerImpl::ActiveStreamEncoderFilter::createBuffer() {\n  auto buffer = new Buffer::WatermarkBuffer([this]() -> void { this->responseDataDrained(); },\n                                            [this]() -> void { this->responseDataTooLarge(); });\n  buffer->setWatermarks(parent_.buffer_limit_);\n  return Buffer::WatermarkBufferPtr{buffer};\n}\n\nvoid ConnectionManagerImpl::ActiveStreamEncoderFilter::handleMetadataAfterHeadersCallback() {\n  // If we drain accumulated metadata, the iteration must start with the current filter.\n  const bool saved_state = iterate_from_current_filter_;\n  iterate_from_current_filter_ = true;\n  // If encodeHeaders() returns StopAllIteration, we should skip draining metadata, and wait\n  // for doMetadata() to drain the metadata after iteration continues.\n  if (!stoppedAll() && saved_response_metadata_ != nullptr &&\n      !getSavedResponseMetadata()->empty()) {\n    drainSavedResponseMetadata();\n  }\n  // Restores the original value of iterate_from_current_filter_.\n  iterate_from_current_filter_ = saved_state;\n}\nvoid ConnectionManagerImpl::ActiveStreamEncoderFilter::addEncodedData(Buffer::Instance& data,\n                                                                      bool streaming) {\n  return parent_.addEncodedData(*this, data, streaming);\n}\n\nvoid ConnectionManagerImpl::ActiveStreamEncoderFilter::injectEncodedDataToFilterChain(\n    Buffer::Instance& data, bool end_stream) {\n  parent_.encodeData(this, data, end_stream,\n                     ActiveStream::FilterIterationStartState::CanStartFromCurrent);\n}\n\nHeaderMap& ConnectionManagerImpl::ActiveStreamEncoderFilter::addEncodedTrailers() {\n  return parent_.addEncodedTrailers();\n}\n\nvoid ConnectionManagerImpl::ActiveStreamEncoderFilter::addEncodedMetadata(\n    MetadataMapPtr&& metadata_map_ptr) {\n  return parent_.encodeMetadata(this, std::move(metadata_map_ptr));\n}\n\nvoid ConnectionManagerImpl::ActiveStreamEncoderFilter::\n    onEncoderFilterAboveWriteBufferHighWatermark() {\n  ENVOY_STREAM_LOG(debug, \"Disabling upstream stream due to filter callbacks.\", parent_);\n  parent_.callHighWatermarkCallbacks();\n}\n\nvoid ConnectionManagerImpl::ActiveStreamEncoderFilter::\n    onEncoderFilterBelowWriteBufferLowWatermark() {\n  ENVOY_STREAM_LOG(debug, \"Enabling upstream stream due to filter callbacks.\", parent_);\n  parent_.callLowWatermarkCallbacks();\n}\n\nvoid ConnectionManagerImpl::ActiveStreamEncoderFilter::continueEncoding() { commonContinue(); }\n\nvoid ConnectionManagerImpl::ActiveStreamEncoderFilter::responseDataTooLarge() {\n  if (parent_.state_.encoder_filters_streaming_) {\n    onEncoderFilterAboveWriteBufferHighWatermark();\n  } else {\n    parent_.connection_manager_.stats_.named_.rs_too_large_.inc();\n\n    // If headers have not been sent to the user, send a 500.\n    if (!headers_continued_) {\n      // Make sure we won't end up with nested watermark calls from the body buffer.\n      parent_.state_.encoder_filters_streaming_ = true;\n      allowIteration();\n\n      parent_.stream_info_.setResponseCodeDetails(\n          StreamInfo::ResponseCodeDetails::get().RequestHeadersTooLarge);\n      Http::Utility::sendLocalReply(\n          Grpc::Common::hasGrpcContentType(*parent_.request_headers_),\n          [&](HeaderMapPtr&& response_headers, bool end_stream) -> void {\n            parent_.chargeStats(*response_headers);\n            parent_.response_headers_ = std::move(response_headers);\n            parent_.response_encoder_->encodeHeaders(*parent_.response_headers_, end_stream);\n            parent_.state_.local_complete_ = end_stream;\n          },\n          [&](Buffer::Instance& data, bool end_stream) -> void {\n            parent_.response_encoder_->encodeData(data, end_stream);\n            parent_.state_.local_complete_ = end_stream;\n          },\n          parent_.state_.destroyed_, Http::Code::InternalServerError,\n          CodeUtility::toString(Http::Code::InternalServerError), absl::nullopt,\n          parent_.is_head_request_);\n      parent_.maybeEndEncode(parent_.state_.local_complete_);\n    } else {\n      resetStream();\n    }\n  }\n}\n\nvoid ConnectionManagerImpl::ActiveStreamEncoderFilter::responseDataDrained() {\n  onEncoderFilterBelowWriteBufferLowWatermark();\n}\n\nvoid ConnectionManagerImpl::ActiveStreamFilterBase::resetStream() {\n  parent_.connection_manager_.stats_.named_.downstream_rq_tx_reset_.inc();\n  parent_.connection_manager_.doEndStream(this->parent_);\n}\n\nuint64_t ConnectionManagerImpl::ActiveStreamFilterBase::streamId() { return parent_.stream_id_; }\n\n} // namespace Http\n} // namespace Envoy\n", "#include \"common/http/header_map_impl.h\"\n\n#include <cstdint>\n#include <list>\n#include <memory>\n#include <string>\n\n#include \"common/common/assert.h\"\n#include \"common/common/dump_state_utils.h\"\n#include \"common/common/empty_string.h\"\n#include \"common/common/utility.h\"\n#include \"common/singleton/const_singleton.h\"\n\n#include \"absl/strings/match.h\"\n\nnamespace Envoy {\nnamespace Http {\n\nnamespace {\nconstexpr size_t MinDynamicCapacity{32};\n// This includes the NULL (StringUtil::itoa technically only needs 21).\nconstexpr size_t MaxIntegerLength{32};\n\nuint64_t newCapacity(uint32_t existing_capacity, uint32_t size_to_append) {\n  return (static_cast<uint64_t>(existing_capacity) + size_to_append) * 2;\n}\n\nvoid validateCapacity(uint64_t new_capacity) {\n  // If the resizing will cause buffer overflow due to hitting uint32_t::max, an OOM is likely\n  // imminent. Fast-fail rather than allow a buffer overflow attack (issue #1421)\n  RELEASE_ASSERT(new_capacity <= std::numeric_limits<uint32_t>::max(),\n                 \"Trying to allocate overly large headers.\");\n  ASSERT(new_capacity >= MinDynamicCapacity);\n}\n\n} // namespace\n\nHeaderString::HeaderString() : type_(Type::Inline) {\n  buffer_.dynamic_ = inline_buffer_;\n  clear();\n  static_assert(sizeof(inline_buffer_) >= MaxIntegerLength, \"\");\n  static_assert(MinDynamicCapacity >= MaxIntegerLength, \"\");\n  ASSERT(valid());\n}\n\nHeaderString::HeaderString(const LowerCaseString& ref_value) : type_(Type::Reference) {\n  buffer_.ref_ = ref_value.get().c_str();\n  string_length_ = ref_value.get().size();\n  ASSERT(valid());\n}\n\nHeaderString::HeaderString(const std::string& ref_value) : type_(Type::Reference) {\n  buffer_.ref_ = ref_value.c_str();\n  string_length_ = ref_value.size();\n  ASSERT(valid());\n}\n\nHeaderString::HeaderString(HeaderString&& move_value) noexcept {\n  type_ = move_value.type_;\n  string_length_ = move_value.string_length_;\n  switch (move_value.type_) {\n  case Type::Reference: {\n    buffer_.ref_ = move_value.buffer_.ref_;\n    break;\n  }\n  case Type::Dynamic: {\n    // When we move a dynamic header, we switch the moved header back to its default state (inline).\n    buffer_.dynamic_ = move_value.buffer_.dynamic_;\n    dynamic_capacity_ = move_value.dynamic_capacity_;\n    move_value.type_ = Type::Inline;\n    move_value.buffer_.dynamic_ = move_value.inline_buffer_;\n    move_value.clear();\n    break;\n  }\n  case Type::Inline: {\n    buffer_.dynamic_ = inline_buffer_;\n    memcpy(inline_buffer_, move_value.inline_buffer_, string_length_);\n    move_value.string_length_ = 0;\n    break;\n  }\n  }\n  ASSERT(valid());\n}\n\nHeaderString::~HeaderString() { freeDynamic(); }\n\nvoid HeaderString::freeDynamic() {\n  if (type_ == Type::Dynamic) {\n    free(buffer_.dynamic_);\n  }\n}\n\nbool HeaderString::valid() const { return validHeaderString(getStringView()); }\n\nvoid HeaderString::append(const char* data, uint32_t size) {\n  switch (type_) {\n  case Type::Reference: {\n    // Rather than be too clever and optimize this uncommon case, we dynamically\n    // allocate and copy.\n    type_ = Type::Dynamic;\n    const uint64_t new_capacity = newCapacity(string_length_, size);\n    if (new_capacity > MinDynamicCapacity) {\n      validateCapacity(new_capacity);\n      dynamic_capacity_ = new_capacity;\n    } else {\n      dynamic_capacity_ = MinDynamicCapacity;\n    }\n    char* buf = static_cast<char*>(malloc(dynamic_capacity_));\n    RELEASE_ASSERT(buf != nullptr, \"\");\n    memcpy(buf, buffer_.ref_, string_length_);\n    buffer_.dynamic_ = buf;\n    break;\n  }\n\n  case Type::Inline: {\n    const uint64_t new_capacity = static_cast<uint64_t>(size) + string_length_;\n    if (new_capacity <= sizeof(inline_buffer_)) {\n      // Already inline and the new value fits in inline storage.\n      break;\n    }\n\n    FALLTHRU;\n  }\n\n  case Type::Dynamic: {\n    // We can get here either because we didn't fit in inline or we are already dynamic.\n    if (type_ == Type::Inline) {\n      const uint64_t new_capacity = newCapacity(string_length_, size);\n      validateCapacity(new_capacity);\n      buffer_.dynamic_ = static_cast<char*>(malloc(new_capacity));\n      RELEASE_ASSERT(buffer_.dynamic_ != nullptr, \"\");\n      memcpy(buffer_.dynamic_, inline_buffer_, string_length_);\n      dynamic_capacity_ = new_capacity;\n      type_ = Type::Dynamic;\n    } else {\n      if (size + string_length_ > dynamic_capacity_) {\n        const uint64_t new_capacity = newCapacity(string_length_, size);\n        validateCapacity(new_capacity);\n\n        // Need to reallocate.\n        dynamic_capacity_ = new_capacity;\n        buffer_.dynamic_ = static_cast<char*>(realloc(buffer_.dynamic_, dynamic_capacity_));\n        RELEASE_ASSERT(buffer_.dynamic_ != nullptr, \"\");\n      }\n    }\n  }\n  }\n  ASSERT(validHeaderString(absl::string_view(data, size)));\n  memcpy(buffer_.dynamic_ + string_length_, data, size);\n  string_length_ += size;\n}\n\nvoid HeaderString::clear() {\n  switch (type_) {\n  case Type::Reference: {\n    break;\n  }\n  case Type::Inline: {\n    FALLTHRU;\n  }\n  case Type::Dynamic: {\n    string_length_ = 0;\n  }\n  }\n}\n\nvoid HeaderString::setCopy(const char* data, uint32_t size) {\n  switch (type_) {\n  case Type::Reference: {\n    // Switch back to inline and fall through.\n    type_ = Type::Inline;\n    buffer_.dynamic_ = inline_buffer_;\n\n    FALLTHRU;\n  }\n\n  case Type::Inline: {\n    if (size <= sizeof(inline_buffer_)) {\n      // Already inline and the new value fits in inline storage.\n      break;\n    }\n\n    FALLTHRU;\n  }\n\n  case Type::Dynamic: {\n    // We can get here either because we didn't fit in inline or we are already dynamic.\n    if (type_ == Type::Inline) {\n      dynamic_capacity_ = size * 2;\n      validateCapacity(dynamic_capacity_);\n      buffer_.dynamic_ = static_cast<char*>(malloc(dynamic_capacity_));\n      RELEASE_ASSERT(buffer_.dynamic_ != nullptr, \"\");\n      type_ = Type::Dynamic;\n    } else {\n      if (size > dynamic_capacity_) {\n        // Need to reallocate. Use free/malloc to avoid the copy since we are about to overwrite.\n        dynamic_capacity_ = size * 2;\n        validateCapacity(dynamic_capacity_);\n        free(buffer_.dynamic_);\n        buffer_.dynamic_ = static_cast<char*>(malloc(dynamic_capacity_));\n        RELEASE_ASSERT(buffer_.dynamic_ != nullptr, \"\");\n      }\n    }\n  }\n  }\n\n  memcpy(buffer_.dynamic_, data, size);\n  string_length_ = size;\n  ASSERT(valid());\n}\n\nvoid HeaderString::setCopy(absl::string_view view) {\n  this->setCopy(view.data(), static_cast<uint32_t>(view.size()));\n}\n\nvoid HeaderString::setInteger(uint64_t value) {\n  switch (type_) {\n  case Type::Reference: {\n    // Switch back to inline and fall through.\n    type_ = Type::Inline;\n    buffer_.dynamic_ = inline_buffer_;\n\n    FALLTHRU;\n  }\n\n  case Type::Inline:\n    // buffer_.dynamic_ should always point at inline_buffer_ for Type::Inline.\n    ASSERT(buffer_.dynamic_ == inline_buffer_);\n    FALLTHRU;\n  case Type::Dynamic: {\n    // Whether dynamic or inline the buffer is guaranteed to be large enough.\n    ASSERT(type_ == Type::Inline || dynamic_capacity_ >= MaxIntegerLength);\n    // It's safe to use buffer.dynamic_, since buffer.ref_ is union aliased.\n    // This better not change without verifying assumptions across this file.\n    static_assert(offsetof(Buffer, dynamic_) == offsetof(Buffer, ref_), \"\");\n    string_length_ = StringUtil::itoa(buffer_.dynamic_, 32, value);\n  }\n  }\n}\n\nvoid HeaderString::setReference(const std::string& ref_value) {\n  freeDynamic();\n  type_ = Type::Reference;\n  buffer_.ref_ = ref_value.c_str();\n  string_length_ = ref_value.size();\n  ASSERT(valid());\n}\n\n// Specialization needed for HeaderMapImpl::HeaderList::insert() when key is LowerCaseString.\n// A fully specialized template must be defined once in the program, hence this may not be in\n// a header file.\ntemplate <> bool HeaderMapImpl::HeaderList::isPseudoHeader(const LowerCaseString& key) {\n  return key.get().c_str()[0] == ':';\n}\n\nHeaderMapImpl::HeaderEntryImpl::HeaderEntryImpl(const LowerCaseString& key) : key_(key) {}\n\nHeaderMapImpl::HeaderEntryImpl::HeaderEntryImpl(const LowerCaseString& key, HeaderString&& value)\n    : key_(key), value_(std::move(value)) {}\n\nHeaderMapImpl::HeaderEntryImpl::HeaderEntryImpl(HeaderString&& key, HeaderString&& value)\n    : key_(std::move(key)), value_(std::move(value)) {}\n\nvoid HeaderMapImpl::HeaderEntryImpl::value(const char* value, uint32_t size) {\n  value_.setCopy(value, size);\n}\n\nvoid HeaderMapImpl::HeaderEntryImpl::value(absl::string_view value) {\n  this->value(value.data(), static_cast<uint32_t>(value.size()));\n}\n\nvoid HeaderMapImpl::HeaderEntryImpl::value(uint64_t value) { value_.setInteger(value); }\n\nvoid HeaderMapImpl::HeaderEntryImpl::value(const HeaderEntry& header) {\n  value(header.value().getStringView());\n}\n\n#define INLINE_HEADER_STATIC_MAP_ENTRY(name)                                                       \\\n  add(Headers::get().name.get().c_str(), [](HeaderMapImpl& h) -> StaticLookupResponse {            \\\n    return {&h.inline_headers_.name##_, &Headers::get().name};                                     \\\n  });\n\n/**\n * This is the static lookup table that is used to determine whether a header is one of the O(1)\n * headers. This uses a trie for lookup time at most equal to the size of the incoming string.\n */\nstruct HeaderMapImpl::StaticLookupTable : public TrieLookupTable<EntryCb> {\n  StaticLookupTable() {\n    ALL_INLINE_HEADERS(INLINE_HEADER_STATIC_MAP_ENTRY)\n\n    // Special case where we map a legacy host header to :authority.\n    add(Headers::get().HostLegacy.get().c_str(), [](HeaderMapImpl& h) -> StaticLookupResponse {\n      return {&h.inline_headers_.Host_, &Headers::get().Host};\n    });\n  }\n};\n\nuint64_t HeaderMapImpl::appendToHeader(HeaderString& header, absl::string_view data) {\n  if (data.empty()) {\n    return 0;\n  }\n  uint64_t byte_size = 0;\n  if (!header.empty()) {\n    header.append(\",\", 1);\n    byte_size += 1;\n  }\n  header.append(data.data(), data.size());\n  return data.size() + byte_size;\n}\n\nHeaderMapImpl::HeaderMapImpl() { memset(&inline_headers_, 0, sizeof(inline_headers_)); }\n\nHeaderMapImpl::HeaderMapImpl(\n    const std::initializer_list<std::pair<LowerCaseString, std::string>>& values)\n    : HeaderMapImpl() {\n  for (auto& value : values) {\n    HeaderString key_string;\n    key_string.setCopy(value.first.get().c_str(), value.first.get().size());\n    HeaderString value_string;\n    value_string.setCopy(value.second.c_str(), value.second.size());\n    addViaMove(std::move(key_string), std::move(value_string));\n  }\n}\n\nvoid HeaderMapImpl::addSize(uint64_t size) {\n  // Adds size to cached_byte_size_ if it exists.\n  if (cached_byte_size_.has_value()) {\n    cached_byte_size_.value() += size;\n  }\n}\n\nvoid HeaderMapImpl::subtractSize(uint64_t size) {\n  if (cached_byte_size_.has_value()) {\n    ASSERT(cached_byte_size_ >= size);\n    cached_byte_size_.value() -= size;\n  }\n}\n\nvoid HeaderMapImpl::copyFrom(const HeaderMap& header_map) {\n  header_map.iterate(\n      [](const HeaderEntry& header, void* context) -> HeaderMap::Iterate {\n        // TODO(mattklein123) PERF: Avoid copying here if not necessary.\n        HeaderString key_string;\n        key_string.setCopy(header.key().getStringView());\n        HeaderString value_string;\n        value_string.setCopy(header.value().getStringView());\n\n        static_cast<HeaderMapImpl*>(context)->addViaMove(std::move(key_string),\n                                                         std::move(value_string));\n        return HeaderMap::Iterate::Continue;\n      },\n      this);\n}\n\nbool HeaderMapImpl::operator==(const HeaderMapImpl& rhs) const {\n  if (size() != rhs.size()) {\n    return false;\n  }\n\n  for (auto i = headers_.begin(), j = rhs.headers_.begin(); i != headers_.end(); ++i, ++j) {\n    if (i->key() != j->key().getStringView() || i->value() != j->value().getStringView()) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nbool HeaderMapImpl::operator!=(const HeaderMapImpl& rhs) const { return !operator==(rhs); }\n\nvoid HeaderMapImpl::insertByKey(HeaderString&& key, HeaderString&& value) {\n  EntryCb cb = ConstSingleton<StaticLookupTable>::get().find(key.getStringView());\n  if (cb) {\n    key.clear();\n    StaticLookupResponse ref_lookup_response = cb(*this);\n    if (*ref_lookup_response.entry_ == nullptr) {\n      maybeCreateInline(ref_lookup_response.entry_, *ref_lookup_response.key_, std::move(value));\n    } else {\n      const uint64_t added_size =\n          appendToHeader((*ref_lookup_response.entry_)->value(), value.getStringView());\n      addSize(added_size);\n      value.clear();\n    }\n  } else {\n    addSize(key.size() + value.size());\n    std::list<HeaderEntryImpl>::iterator i = headers_.insert(std::move(key), std::move(value));\n    i->entry_ = i;\n  }\n}\n\nvoid HeaderMapImpl::addViaMove(HeaderString&& key, HeaderString&& value) {\n  // If this is an inline header, we can't addViaMove, because we'll overwrite\n  // the existing value.\n  auto* entry = getExistingInline(key.getStringView());\n  if (entry != nullptr) {\n    const uint64_t added_size = appendToHeader(entry->value(), value.getStringView());\n    addSize(added_size);\n    key.clear();\n    value.clear();\n  } else {\n    insertByKey(std::move(key), std::move(value));\n  }\n}\n\nvoid HeaderMapImpl::addReference(const LowerCaseString& key, const std::string& value) {\n  HeaderString ref_key(key);\n  HeaderString ref_value(value);\n  addViaMove(std::move(ref_key), std::move(ref_value));\n}\n\nvoid HeaderMapImpl::addReferenceKey(const LowerCaseString& key, uint64_t value) {\n  HeaderString ref_key(key);\n  HeaderString new_value;\n  new_value.setInteger(value);\n  insertByKey(std::move(ref_key), std::move(new_value));\n  ASSERT(new_value.empty()); // NOLINT(bugprone-use-after-move)\n}\n\nvoid HeaderMapImpl::addReferenceKey(const LowerCaseString& key, const std::string& value) {\n  HeaderString ref_key(key);\n  HeaderString new_value;\n  new_value.setCopy(value.c_str(), value.size());\n  insertByKey(std::move(ref_key), std::move(new_value));\n  ASSERT(new_value.empty()); // NOLINT(bugprone-use-after-move)\n}\n\nvoid HeaderMapImpl::addCopy(const LowerCaseString& key, uint64_t value) {\n  auto* entry = getExistingInline(key.get());\n  if (entry != nullptr) {\n    char buf[32];\n    StringUtil::itoa(buf, sizeof(buf), value);\n    const uint64_t added_size = appendToHeader(entry->value(), buf);\n    addSize(added_size);\n    return;\n  }\n  HeaderString new_key;\n  new_key.setCopy(key.get().c_str(), key.get().size());\n  HeaderString new_value;\n  new_value.setInteger(value);\n  insertByKey(std::move(new_key), std::move(new_value));\n  ASSERT(new_key.empty());   // NOLINT(bugprone-use-after-move)\n  ASSERT(new_value.empty()); // NOLINT(bugprone-use-after-move)\n}\n\nvoid HeaderMapImpl::addCopy(const LowerCaseString& key, const std::string& value) {\n  auto* entry = getExistingInline(key.get());\n  if (entry != nullptr) {\n    const uint64_t added_size = appendToHeader(entry->value(), value);\n    addSize(added_size);\n    return;\n  }\n  HeaderString new_key;\n  new_key.setCopy(key.get().c_str(), key.get().size());\n  HeaderString new_value;\n  new_value.setCopy(value.c_str(), value.size());\n  insertByKey(std::move(new_key), std::move(new_value));\n  ASSERT(new_key.empty());   // NOLINT(bugprone-use-after-move)\n  ASSERT(new_value.empty()); // NOLINT(bugprone-use-after-move)\n}\n\nvoid HeaderMapImpl::setReference(const LowerCaseString& key, const std::string& value) {\n  HeaderString ref_key(key);\n  HeaderString ref_value(value);\n  remove(key);\n  insertByKey(std::move(ref_key), std::move(ref_value));\n}\n\nvoid HeaderMapImpl::setReferenceKey(const LowerCaseString& key, const std::string& value) {\n  HeaderString ref_key(key);\n  HeaderString new_value;\n  new_value.setCopy(value.c_str(), value.size());\n  remove(key);\n  insertByKey(std::move(ref_key), std::move(new_value));\n  ASSERT(new_value.empty()); // NOLINT(bugprone-use-after-move)\n}\n\nabsl::optional<uint64_t> HeaderMapImpl::byteSize() const { return cached_byte_size_; }\n\nuint64_t HeaderMapImpl::refreshByteSize() {\n  if (!cached_byte_size_.has_value()) {\n    // In this case, the cached byte size is not valid, and the byte size is computed via an\n    // iteration over the HeaderMap. The cached byte size is updated.\n    cached_byte_size_ = byteSizeInternal();\n  }\n  return cached_byte_size_.value();\n}\n\nuint64_t HeaderMapImpl::byteSizeInternal() const {\n  // Computes the total byte size by summing the byte size of the keys and values.\n  uint64_t byte_size = 0;\n  for (const HeaderEntryImpl& header : headers_) {\n    byte_size += header.key().size();\n    byte_size += header.value().size();\n  }\n  return byte_size;\n}\n\nconst HeaderEntry* HeaderMapImpl::get(const LowerCaseString& key) const {\n  for (const HeaderEntryImpl& header : headers_) {\n    if (header.key() == key.get().c_str()) {\n      return &header;\n    }\n  }\n\n  return nullptr;\n}\n\nHeaderEntry* HeaderMapImpl::get(const LowerCaseString& key) {\n  for (HeaderEntryImpl& header : headers_) {\n    if (header.key() == key.get().c_str()) {\n      cached_byte_size_.reset();\n      return &header;\n    }\n  }\n\n  return nullptr;\n}\n\nvoid HeaderMapImpl::iterate(ConstIterateCb cb, void* context) const {\n  for (const HeaderEntryImpl& header : headers_) {\n    if (cb(header, context) == HeaderMap::Iterate::Break) {\n      break;\n    }\n  }\n}\n\nvoid HeaderMapImpl::iterateReverse(ConstIterateCb cb, void* context) const {\n  for (auto it = headers_.rbegin(); it != headers_.rend(); it++) {\n    if (cb(*it, context) == HeaderMap::Iterate::Break) {\n      break;\n    }\n  }\n}\n\nHeaderMap::Lookup HeaderMapImpl::lookup(const LowerCaseString& key,\n                                        const HeaderEntry** entry) const {\n  EntryCb cb = ConstSingleton<StaticLookupTable>::get().find(key.get());\n  if (cb) {\n    // The accessor callbacks for predefined inline headers take a HeaderMapImpl& as an argument;\n    // even though we don't make any modifications, we need to cast_cast in order to use the\n    // accessor.\n    //\n    // Making this work without const_cast would require managing an additional const accessor\n    // callback for each predefined inline header and add to the complexity of the code.\n    StaticLookupResponse ref_lookup_response = cb(const_cast<HeaderMapImpl&>(*this));\n    *entry = *ref_lookup_response.entry_;\n    if (*entry) {\n      return Lookup::Found;\n    } else {\n      return Lookup::NotFound;\n    }\n  } else {\n    *entry = nullptr;\n    return Lookup::NotSupported;\n  }\n}\n\nvoid HeaderMapImpl::remove(const LowerCaseString& key) {\n  EntryCb cb = ConstSingleton<StaticLookupTable>::get().find(key.get());\n  if (cb) {\n    StaticLookupResponse ref_lookup_response = cb(*this);\n    removeInline(ref_lookup_response.entry_);\n  } else {\n    for (auto i = headers_.begin(); i != headers_.end();) {\n      if (i->key() == key.get().c_str()) {\n        subtractSize(i->key().size() + i->value().size());\n        i = headers_.erase(i);\n      } else {\n        ++i;\n      }\n    }\n  }\n}\n\nvoid HeaderMapImpl::removePrefix(const LowerCaseString& prefix) {\n  headers_.remove_if([&prefix, this](const HeaderEntryImpl& entry) {\n    bool to_remove = absl::StartsWith(entry.key().getStringView(), prefix.get());\n    if (to_remove) {\n      // If this header should be removed, make sure any references in the\n      // static lookup table are cleared as well.\n      EntryCb cb = ConstSingleton<StaticLookupTable>::get().find(entry.key().getStringView());\n      if (cb) {\n        StaticLookupResponse ref_lookup_response = cb(*this);\n        if (ref_lookup_response.entry_) {\n          const uint32_t key_value_size = (*ref_lookup_response.entry_)->key().size() +\n                                          (*ref_lookup_response.entry_)->value().size();\n          subtractSize(key_value_size);\n          *ref_lookup_response.entry_ = nullptr;\n        }\n      } else {\n        subtractSize(entry.key().size() + entry.value().size());\n      }\n    }\n    return to_remove;\n  });\n}\n\nvoid HeaderMapImpl::dumpState(std::ostream& os, int indent_level) const {\n  using IterateData = std::pair<std::ostream*, const char*>;\n  const char* spaces = spacesForLevel(indent_level);\n  IterateData iterate_data = std::make_pair(&os, spaces);\n  iterate(\n      [](const HeaderEntry& header, void* context) -> HeaderMap::Iterate {\n        auto* data = static_cast<IterateData*>(context);\n        *data->first << data->second << \"'\" << header.key().getStringView() << \"', '\"\n                     << header.value().getStringView() << \"'\\n\";\n        return HeaderMap::Iterate::Continue;\n      },\n      &iterate_data);\n}\n\nHeaderMapImpl::HeaderEntryImpl& HeaderMapImpl::maybeCreateInline(HeaderEntryImpl** entry,\n                                                                 const LowerCaseString& key) {\n  cached_byte_size_.reset();\n  if (*entry) {\n    return **entry;\n  }\n\n  std::list<HeaderEntryImpl>::iterator i = headers_.insert(key);\n  i->entry_ = i;\n  *entry = &(*i);\n  return **entry;\n}\n\nHeaderMapImpl::HeaderEntryImpl& HeaderMapImpl::maybeCreateInline(HeaderEntryImpl** entry,\n                                                                 const LowerCaseString& key,\n                                                                 HeaderString&& value) {\n  if (*entry) {\n    value.clear();\n    return **entry;\n  }\n\n  addSize(key.get().size() + value.size());\n  std::list<HeaderEntryImpl>::iterator i = headers_.insert(key, std::move(value));\n  i->entry_ = i;\n  *entry = &(*i);\n  return **entry;\n}\n\nHeaderMapImpl::HeaderEntryImpl* HeaderMapImpl::getExistingInline(absl::string_view key) {\n  EntryCb cb = ConstSingleton<StaticLookupTable>::get().find(key);\n  if (cb) {\n    StaticLookupResponse ref_lookup_response = cb(*this);\n    return *ref_lookup_response.entry_;\n  }\n  return nullptr;\n}\n\nvoid HeaderMapImpl::removeInline(HeaderEntryImpl** ptr_to_entry) {\n  if (!*ptr_to_entry) {\n    return;\n  }\n\n  HeaderEntryImpl* entry = *ptr_to_entry;\n  const uint64_t size_to_subtract = entry->entry_->key().size() + entry->entry_->value().size();\n  subtractSize(size_to_subtract);\n  *ptr_to_entry = nullptr;\n  headers_.erase(entry->entry_);\n}\n\n} // namespace Http\n} // namespace Envoy\n", "#pragma once\n\n#include <array>\n#include <cstdint>\n#include <list>\n#include <memory>\n#include <string>\n\n#include \"envoy/http/header_map.h\"\n\n#include \"common/common/non_copyable.h\"\n#include \"common/http/headers.h\"\n\nnamespace Envoy {\nnamespace Http {\n\n/**\n * These are definitions of all of the inline header access functions described inside header_map.h\n *\n * When a non-const reference or pointer to a HeaderEntry is returned, the internal byte size count\n * will be cleared, since HeaderMap will no longer be able to accurately update the size of that\n * HeaderEntry.\n * TODO(asraa): Remove functions with a non-const HeaderEntry return value.\n */\n#define DEFINE_INLINE_HEADER_FUNCS(name)                                                           \\\npublic:                                                                                            \\\n  const HeaderEntry* name() const override { return inline_headers_.name##_; }                     \\\n  HeaderEntry* name() override {                                                                   \\\n    cached_byte_size_.reset();                                                                     \\\n    return inline_headers_.name##_;                                                                \\\n  }                                                                                                \\\n  HeaderEntry& insert##name() override {                                                           \\\n    cached_byte_size_.reset();                                                                     \\\n    return maybeCreateInline(&inline_headers_.name##_, Headers::get().name);                       \\\n  }                                                                                                \\\n  void remove##name() override { removeInline(&inline_headers_.name##_); }\n\n#define DEFINE_INLINE_HEADER_STRUCT(name) HeaderEntryImpl* name##_;\n\n/**\n * Implementation of Http::HeaderMap. This is heavily optimized for performance. Roughly, when\n * headers are added to the map, we do a hash lookup to see if it's one of the O(1) headers.\n * If it is, we store a reference to it that can be accessed later directly. Most high performance\n * paths use O(1) direct access. In general, we try to copy as little as possible and allocate as\n * little as possible in any of the paths.\n */\nclass HeaderMapImpl : public HeaderMap, NonCopyable {\npublic:\n  /**\n   * Appends data to header. If header already has a value, the string ',' is added between the\n   * existing value and data.\n   * @param header the header to append to.\n   * @param data to append to the header.\n   */\n  static uint64_t appendToHeader(HeaderString& header, absl::string_view data);\n\n  HeaderMapImpl();\n  explicit HeaderMapImpl(\n      const std::initializer_list<std::pair<LowerCaseString, std::string>>& values);\n  explicit HeaderMapImpl(const HeaderMap& rhs) : HeaderMapImpl() { copyFrom(rhs); }\n\n  /**\n   * Add a header via full move. This is the expected high performance paths for codecs populating\n   * a map when receiving.\n   */\n  void addViaMove(HeaderString&& key, HeaderString&& value);\n\n  /**\n   * For testing. Equality is based on equality of the backing list. This is an exact match\n   * comparison (order matters).\n   */\n  bool operator==(const HeaderMapImpl& rhs) const;\n  bool operator!=(const HeaderMapImpl& rhs) const;\n\n  // Http::HeaderMap\n  void addReference(const LowerCaseString& key, const std::string& value) override;\n  void addReferenceKey(const LowerCaseString& key, uint64_t value) override;\n  void addReferenceKey(const LowerCaseString& key, const std::string& value) override;\n  void addCopy(const LowerCaseString& key, uint64_t value) override;\n  void addCopy(const LowerCaseString& key, const std::string& value) override;\n  void setReference(const LowerCaseString& key, const std::string& value) override;\n  void setReferenceKey(const LowerCaseString& key, const std::string& value) override;\n  absl::optional<uint64_t> byteSize() const override;\n  uint64_t refreshByteSize() override;\n  uint64_t byteSizeInternal() const override;\n  const HeaderEntry* get(const LowerCaseString& key) const override;\n  HeaderEntry* get(const LowerCaseString& key) override;\n  void iterate(ConstIterateCb cb, void* context) const override;\n  void iterateReverse(ConstIterateCb cb, void* context) const override;\n  Lookup lookup(const LowerCaseString& key, const HeaderEntry** entry) const override;\n  void remove(const LowerCaseString& key) override;\n  void removePrefix(const LowerCaseString& key) override;\n  size_t size() const override { return headers_.size(); }\n  bool empty() const override { return headers_.empty(); }\n  void dumpState(std::ostream& os, int indent_level = 0) const override;\n\nprotected:\n  // For tests only, unoptimized, they aren't intended for regular HeaderMapImpl users.\n  void copyFrom(const HeaderMap& rhs);\n  void clear() { removePrefix(LowerCaseString(\"\")); }\n\n  struct HeaderEntryImpl : public HeaderEntry, NonCopyable {\n    HeaderEntryImpl(const LowerCaseString& key);\n    HeaderEntryImpl(const LowerCaseString& key, HeaderString&& value);\n    HeaderEntryImpl(HeaderString&& key, HeaderString&& value);\n\n    // HeaderEntry\n    const HeaderString& key() const override { return key_; }\n    void value(const char* value, uint32_t size) override;\n    void value(absl::string_view value) override;\n    void value(uint64_t value) override;\n    void value(const HeaderEntry& header) override;\n    const HeaderString& value() const override { return value_; }\n    HeaderString& value() override { return value_; }\n\n    HeaderString key_;\n    HeaderString value_;\n    std::list<HeaderEntryImpl>::iterator entry_;\n  };\n\n  struct StaticLookupResponse {\n    HeaderEntryImpl** entry_;\n    const LowerCaseString* key_;\n  };\n\n  using EntryCb = StaticLookupResponse (*)(HeaderMapImpl&);\n\n  /**\n   * This is the static lookup table that is used to determine whether a header is one of the O(1)\n   * headers. This uses a trie for lookup time at most equal to the size of the incoming string.\n   */\n  struct StaticLookupTable; // Defined in header_map_impl.cc.\n\n  struct AllInlineHeaders {\n    ALL_INLINE_HEADERS(DEFINE_INLINE_HEADER_STRUCT)\n  };\n\n  /**\n   * List of HeaderEntryImpl that keeps the pseudo headers (key starting with ':') in the front\n   * of the list (as required by nghttp2) and otherwise maintains insertion order.\n   *\n   * Note: the internal iterators held in fields make this unsafe to copy and move, since the\n   * reference to end() is not preserved across a move (see Notes in\n   * https://en.cppreference.com/w/cpp/container/list/list). The NonCopyable will suppress both copy\n   * and move constructors/assignment.\n   * TODO(htuch): Maybe we want this to movable one day; for now, our header map moves happen on\n   * HeaderMapPtr, so the performance impact should not be evident.\n   */\n  class HeaderList : NonCopyable {\n  public:\n    HeaderList() : pseudo_headers_end_(headers_.end()) {}\n\n    template <class Key> bool isPseudoHeader(const Key& key) {\n      return !key.getStringView().empty() && key.getStringView()[0] == ':';\n    }\n\n    template <class Key, class... Value>\n    std::list<HeaderEntryImpl>::iterator insert(Key&& key, Value&&... value) {\n      const bool is_pseudo_header = isPseudoHeader(key);\n      std::list<HeaderEntryImpl>::iterator i =\n          headers_.emplace(is_pseudo_header ? pseudo_headers_end_ : headers_.end(),\n                           std::forward<Key>(key), std::forward<Value>(value)...);\n      if (!is_pseudo_header && pseudo_headers_end_ == headers_.end()) {\n        pseudo_headers_end_ = i;\n      }\n      return i;\n    }\n\n    std::list<HeaderEntryImpl>::iterator erase(std::list<HeaderEntryImpl>::iterator i) {\n      if (pseudo_headers_end_ == i) {\n        pseudo_headers_end_++;\n      }\n      return headers_.erase(i);\n    }\n\n    template <class UnaryPredicate> void remove_if(UnaryPredicate p) {\n      headers_.remove_if([&](const HeaderEntryImpl& entry) {\n        const bool to_remove = p(entry);\n        if (to_remove) {\n          if (pseudo_headers_end_ == entry.entry_) {\n            pseudo_headers_end_++;\n          }\n        }\n        return to_remove;\n      });\n    }\n\n    std::list<HeaderEntryImpl>::iterator begin() { return headers_.begin(); }\n    std::list<HeaderEntryImpl>::iterator end() { return headers_.end(); }\n    std::list<HeaderEntryImpl>::const_iterator begin() const { return headers_.begin(); }\n    std::list<HeaderEntryImpl>::const_iterator end() const { return headers_.end(); }\n    std::list<HeaderEntryImpl>::const_reverse_iterator rbegin() const { return headers_.rbegin(); }\n    std::list<HeaderEntryImpl>::const_reverse_iterator rend() const { return headers_.rend(); }\n    size_t size() const { return headers_.size(); }\n    bool empty() const { return headers_.empty(); }\n\n  private:\n    std::list<HeaderEntryImpl> headers_;\n    std::list<HeaderEntryImpl>::iterator pseudo_headers_end_;\n  };\n\n  void insertByKey(HeaderString&& key, HeaderString&& value);\n  HeaderEntryImpl& maybeCreateInline(HeaderEntryImpl** entry, const LowerCaseString& key);\n  HeaderEntryImpl& maybeCreateInline(HeaderEntryImpl** entry, const LowerCaseString& key,\n                                     HeaderString&& value);\n  HeaderEntryImpl* getExistingInline(absl::string_view key);\n\n  void removeInline(HeaderEntryImpl** entry);\n  void addSize(uint64_t size);\n  void subtractSize(uint64_t size);\n\n  AllInlineHeaders inline_headers_;\n  HeaderList headers_;\n\n  // When present, this holds the internal byte size of the HeaderMap. The value is removed once an\n  // inline header entry is accessed and updated when refreshByteSize() is called.\n  absl::optional<uint64_t> cached_byte_size_ = 0;\n\n  ALL_INLINE_HEADERS(DEFINE_INLINE_HEADER_FUNCS)\n};\n\nusing HeaderMapImplPtr = std::unique_ptr<HeaderMapImpl>;\n\n} // namespace Http\n} // namespace Envoy\n", "#include \"common/http/http1/codec_impl.h\"\n\n#include <cstdint>\n#include <memory>\n#include <string>\n\n#include \"envoy/buffer/buffer.h\"\n#include \"envoy/http/header_map.h\"\n#include \"envoy/network/connection.h\"\n\n#include \"common/common/enum_to_int.h\"\n#include \"common/common/fmt.h\"\n#include \"common/common/stack_array.h\"\n#include \"common/common/utility.h\"\n#include \"common/http/exception.h\"\n#include \"common/http/header_utility.h\"\n#include \"common/http/headers.h\"\n#include \"common/http/utility.h\"\n#include \"common/runtime/runtime_impl.h\"\n\nnamespace Envoy {\nnamespace Http {\nnamespace Http1 {\nnamespace {\n\nconst StringUtil::CaseUnorderedSet& caseUnorderdSetContainingUpgradeAndHttp2Settings() {\n  CONSTRUCT_ON_FIRST_USE(StringUtil::CaseUnorderedSet,\n                         Http::Headers::get().ConnectionValues.Upgrade,\n                         Http::Headers::get().ConnectionValues.Http2Settings);\n}\n\n} // namespace\n\nconst std::string StreamEncoderImpl::CRLF = \"\\r\\n\";\nconst std::string StreamEncoderImpl::LAST_CHUNK = \"0\\r\\n\\r\\n\";\n\nStreamEncoderImpl::StreamEncoderImpl(ConnectionImpl& connection) : connection_(connection) {\n  if (connection_.connection().aboveHighWatermark()) {\n    runHighWatermarkCallbacks();\n  }\n}\n\nvoid StreamEncoderImpl::encodeHeader(const char* key, uint32_t key_size, const char* value,\n                                     uint32_t value_size) {\n\n  connection_.reserveBuffer(key_size + value_size + 4);\n  ASSERT(key_size > 0);\n\n  connection_.copyToBuffer(key, key_size);\n  connection_.addCharToBuffer(':');\n  connection_.addCharToBuffer(' ');\n  connection_.copyToBuffer(value, value_size);\n  connection_.addCharToBuffer('\\r');\n  connection_.addCharToBuffer('\\n');\n}\nvoid StreamEncoderImpl::encodeHeader(absl::string_view key, absl::string_view value) {\n  this->encodeHeader(key.data(), key.size(), value.data(), value.size());\n}\n\nvoid StreamEncoderImpl::encode100ContinueHeaders(const HeaderMap& headers) {\n  ASSERT(headers.Status()->value() == \"100\");\n  processing_100_continue_ = true;\n  encodeHeaders(headers, false);\n  processing_100_continue_ = false;\n}\n\nvoid StreamEncoderImpl::encodeHeaders(const HeaderMap& headers, bool end_stream) {\n  bool saw_content_length = false;\n  headers.iterate(\n      [](const HeaderEntry& header, void* context) -> HeaderMap::Iterate {\n        absl::string_view key_to_use = header.key().getStringView();\n        uint32_t key_size_to_use = header.key().size();\n        // Translate :authority -> host so that upper layers do not need to deal with this.\n        if (key_size_to_use > 1 && key_to_use[0] == ':' && key_to_use[1] == 'a') {\n          key_to_use = absl::string_view(Headers::get().HostLegacy.get());\n          key_size_to_use = Headers::get().HostLegacy.get().size();\n        }\n\n        // Skip all headers starting with ':' that make it here.\n        if (key_to_use[0] == ':') {\n          return HeaderMap::Iterate::Continue;\n        }\n\n        static_cast<StreamEncoderImpl*>(context)->encodeHeader(key_to_use,\n                                                               header.value().getStringView());\n        return HeaderMap::Iterate::Continue;\n      },\n      this);\n\n  if (headers.ContentLength()) {\n    saw_content_length = true;\n  }\n\n  ASSERT(!headers.TransferEncoding());\n\n  // Assume we are chunk encoding unless we are passed a content length or this is a header only\n  // response. Upper layers generally should strip transfer-encoding since it only applies to\n  // HTTP/1.1. The codec will infer it based on the type of response.\n  // for streaming (e.g. SSE stream sent to hystrix dashboard), we do not want\n  // chunk transfer encoding but we don't have a content-length so we pass \"envoy only\"\n  // header to avoid adding chunks\n  //\n  // Note that for HEAD requests Envoy does best-effort guessing when there is no\n  // content-length. If a client makes a HEAD request for an upstream resource\n  // with no bytes but the upstream response doesn't include \"Content-length: 0\",\n  // Envoy will incorrectly assume a subsequent response to GET will be chunk encoded.\n  if (saw_content_length || headers.NoChunks()) {\n    chunk_encoding_ = false;\n  } else {\n    if (processing_100_continue_) {\n      // Make sure we don't serialize chunk information with 100-Continue headers.\n      chunk_encoding_ = false;\n    } else if (end_stream && !is_response_to_head_request_) {\n      // If this is a headers-only stream, append an explicit \"Content-Length: 0\" unless it's a\n      // response to a HEAD request.\n      // For 204s and 1xx where content length is disallowed, don't append the content length but\n      // also don't chunk encode.\n      if (is_content_length_allowed_) {\n        encodeHeader(Headers::get().ContentLength.get().c_str(),\n                     Headers::get().ContentLength.get().size(), \"0\", 1);\n      }\n      chunk_encoding_ = false;\n    } else if (connection_.protocol() == Protocol::Http10) {\n      chunk_encoding_ = false;\n    } else {\n      encodeHeader(Headers::get().TransferEncoding.get().c_str(),\n                   Headers::get().TransferEncoding.get().size(),\n                   Headers::get().TransferEncodingValues.Chunked.c_str(),\n                   Headers::get().TransferEncodingValues.Chunked.size());\n      // We do not apply chunk encoding for HTTP upgrades.\n      // If there is a body in a WebSocket Upgrade response, the chunks will be\n      // passed through via maybeDirectDispatch so we need to avoid appending\n      // extra chunk boundaries.\n      //\n      // When sending a response to a HEAD request Envoy may send an informational\n      // \"Transfer-Encoding: chunked\" header, but should not send a chunk encoded body.\n      chunk_encoding_ = !Utility::isUpgrade(headers) && !is_response_to_head_request_;\n    }\n  }\n\n  connection_.reserveBuffer(2);\n  connection_.addCharToBuffer('\\r');\n  connection_.addCharToBuffer('\\n');\n\n  if (end_stream) {\n    endEncode();\n  } else {\n    connection_.flushOutput();\n  }\n}\n\nvoid StreamEncoderImpl::encodeData(Buffer::Instance& data, bool end_stream) {\n  // end_stream may be indicated with a zero length data buffer. If that is the case, so not\n  // actually write the zero length buffer out.\n  if (data.length() > 0) {\n    if (chunk_encoding_) {\n      connection_.buffer().add(fmt::format(\"{:x}\\r\\n\", data.length()));\n    }\n\n    connection_.buffer().move(data);\n\n    if (chunk_encoding_) {\n      connection_.buffer().add(CRLF);\n    }\n  }\n\n  if (end_stream) {\n    endEncode();\n  } else {\n    connection_.flushOutput();\n  }\n}\n\nvoid StreamEncoderImpl::encodeTrailers(const HeaderMap&) { endEncode(); }\n\nvoid StreamEncoderImpl::encodeMetadata(const MetadataMapVector&) {\n  connection_.stats().metadata_not_supported_error_.inc();\n}\n\nvoid StreamEncoderImpl::endEncode() {\n  if (chunk_encoding_) {\n    connection_.buffer().add(LAST_CHUNK);\n  }\n\n  connection_.flushOutput();\n  connection_.onEncodeComplete();\n}\n\nvoid ConnectionImpl::flushOutput() {\n  if (reserved_current_) {\n    reserved_iovec_.len_ = reserved_current_ - static_cast<char*>(reserved_iovec_.mem_);\n    output_buffer_.commit(&reserved_iovec_, 1);\n    reserved_current_ = nullptr;\n  }\n\n  connection().write(output_buffer_, false);\n  ASSERT(0UL == output_buffer_.length());\n}\n\nvoid ConnectionImpl::addCharToBuffer(char c) {\n  ASSERT(bufferRemainingSize() >= 1);\n  *reserved_current_++ = c;\n}\n\nvoid ConnectionImpl::addIntToBuffer(uint64_t i) {\n  reserved_current_ += StringUtil::itoa(reserved_current_, bufferRemainingSize(), i);\n}\n\nuint64_t ConnectionImpl::bufferRemainingSize() {\n  return reserved_iovec_.len_ - (reserved_current_ - static_cast<char*>(reserved_iovec_.mem_));\n}\n\nvoid ConnectionImpl::copyToBuffer(const char* data, uint64_t length) {\n  ASSERT(bufferRemainingSize() >= length);\n  memcpy(reserved_current_, data, length);\n  reserved_current_ += length;\n}\n\nvoid ConnectionImpl::reserveBuffer(uint64_t size) {\n  if (reserved_current_ && bufferRemainingSize() >= size) {\n    return;\n  }\n\n  if (reserved_current_) {\n    reserved_iovec_.len_ = reserved_current_ - static_cast<char*>(reserved_iovec_.mem_);\n    output_buffer_.commit(&reserved_iovec_, 1);\n  }\n\n  // TODO PERF: It would be better to allow a split reservation. That will make fill code more\n  //            complicated.\n  output_buffer_.reserve(std::max<uint64_t>(4096, size), &reserved_iovec_, 1);\n  reserved_current_ = static_cast<char*>(reserved_iovec_.mem_);\n}\n\nvoid StreamEncoderImpl::resetStream(StreamResetReason reason) {\n  connection_.onResetStreamBase(reason);\n}\n\nvoid StreamEncoderImpl::readDisable(bool disable) { connection_.readDisable(disable); }\n\nuint32_t StreamEncoderImpl::bufferLimit() { return connection_.bufferLimit(); }\n\nstatic const char RESPONSE_PREFIX[] = \"HTTP/1.1 \";\nstatic const char HTTP_10_RESPONSE_PREFIX[] = \"HTTP/1.0 \";\n\nvoid ResponseStreamEncoderImpl::encodeHeaders(const HeaderMap& headers, bool end_stream) {\n  started_response_ = true;\n  uint64_t numeric_status = Utility::getResponseStatus(headers);\n\n  connection_.reserveBuffer(4096);\n  if (connection_.protocol() == Protocol::Http10 && connection_.supports_http_10()) {\n    connection_.copyToBuffer(HTTP_10_RESPONSE_PREFIX, sizeof(HTTP_10_RESPONSE_PREFIX) - 1);\n  } else {\n    connection_.copyToBuffer(RESPONSE_PREFIX, sizeof(RESPONSE_PREFIX) - 1);\n  }\n  connection_.addIntToBuffer(numeric_status);\n  connection_.addCharToBuffer(' ');\n\n  const char* status_string = CodeUtility::toString(static_cast<Code>(numeric_status));\n  uint32_t status_string_len = strlen(status_string);\n  connection_.copyToBuffer(status_string, status_string_len);\n\n  connection_.addCharToBuffer('\\r');\n  connection_.addCharToBuffer('\\n');\n\n  if (numeric_status == 204 || numeric_status < 200) {\n    // Per https://tools.ietf.org/html/rfc7230#section-3.3.2\n    setIsContentLengthAllowed(false);\n  } else {\n    // Make sure that if we encodeHeaders(100) then encodeHeaders(200) that we\n    // set is_content_length_allowed_ back to true.\n    setIsContentLengthAllowed(true);\n  }\n\n  StreamEncoderImpl::encodeHeaders(headers, end_stream);\n}\n\nstatic const char REQUEST_POSTFIX[] = \" HTTP/1.1\\r\\n\";\n\nvoid RequestStreamEncoderImpl::encodeHeaders(const HeaderMap& headers, bool end_stream) {\n  const HeaderEntry* method = headers.Method();\n  const HeaderEntry* path = headers.Path();\n  if (!method || !path) {\n    throw CodecClientException(\":method and :path must be specified\");\n  }\n  if (method->value() == Headers::get().MethodValues.Head) {\n    head_request_ = true;\n  }\n  connection_.onEncodeHeaders(headers);\n  connection_.reserveBuffer(std::max(4096U, path->value().size() + 4096));\n  connection_.copyToBuffer(method->value().getStringView().data(), method->value().size());\n  connection_.addCharToBuffer(' ');\n  connection_.copyToBuffer(path->value().getStringView().data(), path->value().size());\n  connection_.copyToBuffer(REQUEST_POSTFIX, sizeof(REQUEST_POSTFIX) - 1);\n\n  StreamEncoderImpl::encodeHeaders(headers, end_stream);\n}\n\nhttp_parser_settings ConnectionImpl::settings_{\n    [](http_parser* parser) -> int {\n      static_cast<ConnectionImpl*>(parser->data)->onMessageBeginBase();\n      return 0;\n    },\n    [](http_parser* parser, const char* at, size_t length) -> int {\n      static_cast<ConnectionImpl*>(parser->data)->onUrl(at, length);\n      return 0;\n    },\n    nullptr, // on_status\n    [](http_parser* parser, const char* at, size_t length) -> int {\n      static_cast<ConnectionImpl*>(parser->data)->onHeaderField(at, length);\n      return 0;\n    },\n    [](http_parser* parser, const char* at, size_t length) -> int {\n      static_cast<ConnectionImpl*>(parser->data)->onHeaderValue(at, length);\n      return 0;\n    },\n    [](http_parser* parser) -> int {\n      return static_cast<ConnectionImpl*>(parser->data)->onHeadersCompleteBase();\n    },\n    [](http_parser* parser, const char* at, size_t length) -> int {\n      static_cast<ConnectionImpl*>(parser->data)->onBody(at, length);\n      return 0;\n    },\n    [](http_parser* parser) -> int {\n      static_cast<ConnectionImpl*>(parser->data)->onMessageCompleteBase();\n      return 0;\n    },\n    nullptr, // on_chunk_header\n    nullptr  // on_chunk_complete\n};\n\nconst ToLowerTable& ConnectionImpl::toLowerTable() {\n  static auto* table = new ToLowerTable();\n  return *table;\n}\n\nConnectionImpl::ConnectionImpl(Network::Connection& connection, Stats::Scope& stats,\n                               http_parser_type type, uint32_t max_request_headers_kb)\n    : connection_(connection), stats_{ALL_HTTP1_CODEC_STATS(POOL_COUNTER_PREFIX(stats, \"http1.\"))},\n      output_buffer_([&]() -> void { this->onBelowLowWatermark(); },\n                     [&]() -> void { this->onAboveHighWatermark(); }),\n      max_request_headers_kb_(max_request_headers_kb),\n      strict_header_validation_(\n          Runtime::runtimeFeatureEnabled(\"envoy.reloadable_features.strict_header_validation\")) {\n  output_buffer_.setWatermarks(connection.bufferLimit());\n  http_parser_init(&parser_, type);\n  parser_.data = this;\n}\n\nvoid ConnectionImpl::completeLastHeader() {\n  ENVOY_CONN_LOG(trace, \"completed header: key={} value={}\", connection_,\n                 current_header_field_.getStringView(), current_header_value_.getStringView());\n  if (!current_header_field_.empty()) {\n    toLowerTable().toLowerCase(current_header_field_.buffer(), current_header_field_.size());\n    current_header_map_->addViaMove(std::move(current_header_field_),\n                                    std::move(current_header_value_));\n  }\n\n  header_parsing_state_ = HeaderParsingState::Field;\n  ASSERT(current_header_field_.empty());\n  ASSERT(current_header_value_.empty());\n}\n\nbool ConnectionImpl::maybeDirectDispatch(Buffer::Instance& data) {\n  if (!handling_upgrade_) {\n    // Only direct dispatch for Upgrade requests.\n    return false;\n  }\n\n  ssize_t total_parsed = 0;\n  uint64_t num_slices = data.getRawSlices(nullptr, 0);\n  STACK_ARRAY(slices, Buffer::RawSlice, num_slices);\n  data.getRawSlices(slices.begin(), num_slices);\n  for (const Buffer::RawSlice& slice : slices) {\n    total_parsed += slice.len_;\n    onBody(static_cast<const char*>(slice.mem_), slice.len_);\n  }\n  ENVOY_CONN_LOG(trace, \"direct-dispatched {} bytes\", connection_, total_parsed);\n  data.drain(total_parsed);\n  return true;\n}\n\nvoid ConnectionImpl::dispatch(Buffer::Instance& data) {\n  ENVOY_CONN_LOG(trace, \"parsing {} bytes\", connection_, data.length());\n\n  if (maybeDirectDispatch(data)) {\n    return;\n  }\n\n  // Always unpause before dispatch.\n  http_parser_pause(&parser_, 0);\n\n  ssize_t total_parsed = 0;\n  if (data.length() > 0) {\n    uint64_t num_slices = data.getRawSlices(nullptr, 0);\n    STACK_ARRAY(slices, Buffer::RawSlice, num_slices);\n    data.getRawSlices(slices.begin(), num_slices);\n    for (const Buffer::RawSlice& slice : slices) {\n      total_parsed += dispatchSlice(static_cast<const char*>(slice.mem_), slice.len_);\n    }\n  } else {\n    dispatchSlice(nullptr, 0);\n  }\n\n  ENVOY_CONN_LOG(trace, \"parsed {} bytes\", connection_, total_parsed);\n  data.drain(total_parsed);\n\n  // If an upgrade has been handled and there is body data or early upgrade\n  // payload to send on, send it on.\n  maybeDirectDispatch(data);\n}\n\nsize_t ConnectionImpl::dispatchSlice(const char* slice, size_t len) {\n  ssize_t rc = http_parser_execute(&parser_, &settings_, slice, len);\n  if (HTTP_PARSER_ERRNO(&parser_) != HPE_OK && HTTP_PARSER_ERRNO(&parser_) != HPE_PAUSED) {\n    sendProtocolError();\n    throw CodecProtocolException(\"http/1.1 protocol error: \" +\n                                 std::string(http_errno_name(HTTP_PARSER_ERRNO(&parser_))));\n  }\n\n  return rc;\n}\n\nvoid ConnectionImpl::onHeaderField(const char* data, size_t length) {\n  if (header_parsing_state_ == HeaderParsingState::Done) {\n    // Ignore trailers.\n    return;\n  }\n\n  if (header_parsing_state_ == HeaderParsingState::Value) {\n    completeLastHeader();\n  }\n\n  current_header_field_.append(data, length);\n}\n\nvoid ConnectionImpl::onHeaderValue(const char* data, size_t length) {\n  if (header_parsing_state_ == HeaderParsingState::Done) {\n    // Ignore trailers.\n    return;\n  }\n\n  const absl::string_view header_value = absl::string_view(data, length);\n\n  if (strict_header_validation_) {\n    if (!Http::HeaderUtility::headerIsValid(header_value)) {\n      ENVOY_CONN_LOG(debug, \"invalid header value: {}\", connection_, header_value);\n      error_code_ = Http::Code::BadRequest;\n      sendProtocolError();\n      throw CodecProtocolException(\"http/1.1 protocol error: header value contains invalid chars\");\n    }\n  } else if (header_value.find('\\0') != absl::string_view::npos) {\n    // http-parser should filter for this\n    // (https://tools.ietf.org/html/rfc7230#section-3.2.6), but it doesn't today. HeaderStrings\n    // have an invariant that they must not contain embedded zero characters\n    // (NUL, ASCII 0x0).\n    throw CodecProtocolException(\"http/1.1 protocol error: header value contains NUL\");\n  }\n\n  header_parsing_state_ = HeaderParsingState::Value;\n  current_header_value_.append(data, length);\n\n  // Verify that the cached value in byte size exists.\n  ASSERT(current_header_map_->byteSize().has_value());\n  const uint32_t total = current_header_field_.size() + current_header_value_.size() +\n                         current_header_map_->byteSize().value();\n  if (total > (max_request_headers_kb_ * 1024)) {\n    error_code_ = Http::Code::RequestHeaderFieldsTooLarge;\n    sendProtocolError();\n    throw CodecProtocolException(\"headers size exceeds limit\");\n  }\n}\n\nint ConnectionImpl::onHeadersCompleteBase() {\n  ENVOY_CONN_LOG(trace, \"headers complete\", connection_);\n  completeLastHeader();\n  // Validate that the completed HeaderMap's cached byte size exists and is correct.\n  // This assert iterates over the HeaderMap.\n  ASSERT(current_header_map_->byteSize().has_value() &&\n         current_header_map_->byteSize() == current_header_map_->byteSizeInternal());\n  if (!(parser_.http_major == 1 && parser_.http_minor == 1)) {\n    // This is not necessarily true, but it's good enough since higher layers only care if this is\n    // HTTP/1.1 or not.\n    protocol_ = Protocol::Http10;\n  }\n  if (Utility::isUpgrade(*current_header_map_)) {\n    // Ignore h2c upgrade requests until we support them.\n    // See https://github.com/envoyproxy/envoy/issues/7161 for details.\n    if (current_header_map_->Upgrade() &&\n        absl::EqualsIgnoreCase(current_header_map_->Upgrade()->value().getStringView(),\n                               Http::Headers::get().UpgradeValues.H2c)) {\n      ENVOY_CONN_LOG(trace, \"removing unsupported h2c upgrade headers.\", connection_);\n      current_header_map_->removeUpgrade();\n      if (current_header_map_->Connection()) {\n        const auto& tokens_to_remove = caseUnorderdSetContainingUpgradeAndHttp2Settings();\n        std::string new_value = StringUtil::removeTokens(\n            current_header_map_->Connection()->value().getStringView(), \",\", tokens_to_remove, \",\");\n        if (new_value.empty()) {\n          current_header_map_->removeConnection();\n        } else {\n          current_header_map_->Connection()->value(new_value);\n        }\n      }\n      current_header_map_->remove(Headers::get().Http2Settings);\n    } else {\n      ENVOY_CONN_LOG(trace, \"codec entering upgrade mode.\", connection_);\n      handling_upgrade_ = true;\n    }\n  }\n\n  int rc = onHeadersComplete(std::move(current_header_map_));\n  current_header_map_.reset();\n  header_parsing_state_ = HeaderParsingState::Done;\n\n  // Returning 2 informs http_parser to not expect a body or further data on this connection.\n  return handling_upgrade_ ? 2 : rc;\n}\n\nvoid ConnectionImpl::onMessageCompleteBase() {\n  ENVOY_CONN_LOG(trace, \"message complete\", connection_);\n  if (handling_upgrade_) {\n    // If this is an upgrade request, swallow the onMessageComplete. The\n    // upgrade payload will be treated as stream body.\n    ASSERT(!deferred_end_stream_headers_);\n    ENVOY_CONN_LOG(trace, \"Pausing parser due to upgrade.\", connection_);\n    http_parser_pause(&parser_, 1);\n    return;\n  }\n  onMessageComplete();\n}\n\nvoid ConnectionImpl::onMessageBeginBase() {\n  ENVOY_CONN_LOG(trace, \"message begin\", connection_);\n  // Make sure that if HTTP/1.0 and HTTP/1.1 requests share a connection Envoy correctly sets\n  // protocol for each request. Envoy defaults to 1.1 but sets the protocol to 1.0 where applicable\n  // in onHeadersCompleteBase\n  protocol_ = Protocol::Http11;\n  ASSERT(!current_header_map_);\n  current_header_map_ = std::make_unique<HeaderMapImpl>();\n  header_parsing_state_ = HeaderParsingState::Field;\n  onMessageBegin();\n}\n\nvoid ConnectionImpl::onResetStreamBase(StreamResetReason reason) {\n  ASSERT(!reset_stream_called_);\n  reset_stream_called_ = true;\n  onResetStream(reason);\n}\n\nServerConnectionImpl::ServerConnectionImpl(Network::Connection& connection, Stats::Scope& stats,\n                                           ServerConnectionCallbacks& callbacks,\n                                           Http1Settings settings, uint32_t max_request_headers_kb)\n    : ConnectionImpl(connection, stats, HTTP_REQUEST, max_request_headers_kb),\n      callbacks_(callbacks), codec_settings_(settings) {}\n\nvoid ServerConnectionImpl::onEncodeComplete() {\n  ASSERT(active_request_);\n  if (active_request_->remote_complete_) {\n    // Only do this if remote is complete. If we are replying before the request is complete the\n    // only logical thing to do is for higher level code to reset() / close the connection so we\n    // leave the request around so that it can fire reset callbacks.\n    active_request_.reset();\n  }\n}\n\nvoid ServerConnectionImpl::handlePath(HeaderMapImpl& headers, unsigned int method) {\n  HeaderString path(Headers::get().Path);\n\n  bool is_connect = (method == HTTP_CONNECT);\n\n  // The url is relative or a wildcard when the method is OPTIONS. Nothing to do here.\n  if (!active_request_->request_url_.getStringView().empty() &&\n      (active_request_->request_url_.getStringView()[0] == '/' ||\n       ((method == HTTP_OPTIONS) && active_request_->request_url_.getStringView()[0] == '*'))) {\n    headers.addViaMove(std::move(path), std::move(active_request_->request_url_));\n    return;\n  }\n\n  // If absolute_urls and/or connect are not going be handled, copy the url and return.\n  // This forces the behavior to be backwards compatible with the old codec behavior.\n  if (!codec_settings_.allow_absolute_url_) {\n    headers.addViaMove(std::move(path), std::move(active_request_->request_url_));\n    return;\n  }\n\n  if (is_connect) {\n    headers.addViaMove(std::move(path), std::move(active_request_->request_url_));\n    return;\n  }\n\n  Utility::Url absolute_url;\n  if (!absolute_url.initialize(active_request_->request_url_.getStringView())) {\n    sendProtocolError();\n    throw CodecProtocolException(\"http/1.1 protocol error: invalid url in request line\");\n  }\n  // RFC7230#5.7\n  // When a proxy receives a request with an absolute-form of\n  // request-target, the proxy MUST ignore the received Host header field\n  // (if any) and instead replace it with the host information of the\n  // request-target. A proxy that forwards such a request MUST generate a\n  // new Host field-value based on the received request-target rather than\n  // forward the received Host field-value.\n  headers.insertHost().value(std::string(absolute_url.host_and_port()));\n\n  headers.insertPath().value(std::string(absolute_url.path_and_query_params()));\n  active_request_->request_url_.clear();\n}\n\nint ServerConnectionImpl::onHeadersComplete(HeaderMapImplPtr&& headers) {\n  // Handle the case where response happens prior to request complete. It's up to upper layer code\n  // to disconnect the connection but we shouldn't fire any more events since it doesn't make\n  // sense.\n  if (active_request_) {\n    const char* method_string = http_method_str(static_cast<http_method>(parser_.method));\n\n    // Inform the response encoder about any HEAD method, so it can set content\n    // length and transfer encoding headers correctly.\n    active_request_->response_encoder_.isResponseToHeadRequest(parser_.method == HTTP_HEAD);\n\n    // Currently, CONNECT is not supported, however; http_parser_parse_url needs to know about\n    // CONNECT\n    handlePath(*headers, parser_.method);\n    ASSERT(active_request_->request_url_.empty());\n\n    headers->insertMethod().value(method_string, strlen(method_string));\n\n    // Determine here whether we have a body or not. This uses the new RFC semantics where the\n    // presence of content-length or chunked transfer-encoding indicates a body vs. a particular\n    // method. If there is no body, we defer raising decodeHeaders() until the parser is flushed\n    // with message complete. This allows upper layers to behave like HTTP/2 and prevents a proxy\n    // scenario where the higher layers stream through and implicitly switch to chunked transfer\n    // encoding because end stream with zero body length has not yet been indicated.\n    if (parser_.flags & F_CHUNKED ||\n        (parser_.content_length > 0 && parser_.content_length != ULLONG_MAX) || handling_upgrade_) {\n      active_request_->request_decoder_->decodeHeaders(std::move(headers), false);\n\n      // If the connection has been closed (or is closing) after decoding headers, pause the parser\n      // so we return control to the caller.\n      if (connection_.state() != Network::Connection::State::Open) {\n        http_parser_pause(&parser_, 1);\n      }\n\n    } else {\n      deferred_end_stream_headers_ = std::move(headers);\n    }\n  }\n\n  return 0;\n}\n\nvoid ServerConnectionImpl::onMessageBegin() {\n  if (!resetStreamCalled()) {\n    ASSERT(!active_request_);\n    active_request_ = std::make_unique<ActiveRequest>(*this);\n    active_request_->request_decoder_ = &callbacks_.newStream(active_request_->response_encoder_);\n  }\n}\n\nvoid ServerConnectionImpl::onUrl(const char* data, size_t length) {\n  if (active_request_) {\n    active_request_->request_url_.append(data, length);\n  }\n}\n\nvoid ServerConnectionImpl::onBody(const char* data, size_t length) {\n  ASSERT(!deferred_end_stream_headers_);\n  if (active_request_) {\n    ENVOY_CONN_LOG(trace, \"body size={}\", connection_, length);\n    Buffer::OwnedImpl buffer(data, length);\n    active_request_->request_decoder_->decodeData(buffer, false);\n  }\n}\n\nvoid ServerConnectionImpl::onMessageComplete() {\n  if (active_request_) {\n    Buffer::OwnedImpl buffer;\n    active_request_->remote_complete_ = true;\n\n    if (deferred_end_stream_headers_) {\n      active_request_->request_decoder_->decodeHeaders(std::move(deferred_end_stream_headers_),\n                                                       true);\n      deferred_end_stream_headers_.reset();\n    } else {\n      active_request_->request_decoder_->decodeData(buffer, true);\n    }\n  }\n\n  // Always pause the parser so that the calling code can process 1 request at a time and apply\n  // back pressure. However this means that the calling code needs to detect if there is more data\n  // in the buffer and dispatch it again.\n  http_parser_pause(&parser_, 1);\n}\n\nvoid ServerConnectionImpl::onResetStream(StreamResetReason reason) {\n  ASSERT(active_request_);\n  active_request_->response_encoder_.runResetCallbacks(reason);\n  active_request_.reset();\n}\n\nvoid ServerConnectionImpl::sendProtocolError() {\n  // We do this here because we may get a protocol error before we have a logical stream. Higher\n  // layers can only operate on streams, so there is no coherent way to allow them to send an error\n  // \"out of band.\" On one hand this is kind of a hack but on the other hand it normalizes HTTP/1.1\n  // to look more like HTTP/2 to higher layers.\n  if (!active_request_ || !active_request_->response_encoder_.startedResponse()) {\n    Buffer::OwnedImpl bad_request_response(\n        fmt::format(\"HTTP/1.1 {} {}\\r\\ncontent-length: 0\\r\\nconnection: close\\r\\n\\r\\n\",\n                    std::to_string(enumToInt(error_code_)), CodeUtility::toString(error_code_)));\n\n    connection_.write(bad_request_response, false);\n  }\n}\n\nvoid ServerConnectionImpl::onAboveHighWatermark() {\n  if (active_request_) {\n    active_request_->response_encoder_.runHighWatermarkCallbacks();\n  }\n}\nvoid ServerConnectionImpl::onBelowLowWatermark() {\n  if (active_request_) {\n    active_request_->response_encoder_.runLowWatermarkCallbacks();\n  }\n}\n\nClientConnectionImpl::ClientConnectionImpl(Network::Connection& connection, Stats::Scope& stats,\n                                           ConnectionCallbacks&)\n    : ConnectionImpl(connection, stats, HTTP_RESPONSE, MAX_RESPONSE_HEADERS_KB) {}\n\nbool ClientConnectionImpl::cannotHaveBody() {\n  if ((!pending_responses_.empty() && pending_responses_.front().head_request_) ||\n      parser_.status_code == 204 || parser_.status_code == 304 ||\n      (parser_.status_code >= 200 && parser_.content_length == 0)) {\n    return true;\n  } else {\n    return false;\n  }\n}\n\nStreamEncoder& ClientConnectionImpl::newStream(StreamDecoder& response_decoder) {\n  if (resetStreamCalled()) {\n    throw CodecClientException(\"cannot create new streams after calling reset\");\n  }\n\n  // If reads were disabled due to flow control, we expect reads to always be enabled again before\n  // reusing this connection. This is done when the final pipeline response is received.\n  ASSERT(connection_.readEnabled());\n\n  request_encoder_ = std::make_unique<RequestStreamEncoderImpl>(*this);\n  pending_responses_.emplace_back(&response_decoder);\n  return *request_encoder_;\n}\n\nvoid ClientConnectionImpl::onEncodeHeaders(const HeaderMap& headers) {\n  if (headers.Method()->value() == Headers::get().MethodValues.Head.c_str()) {\n    pending_responses_.back().head_request_ = true;\n  }\n}\n\nint ClientConnectionImpl::onHeadersComplete(HeaderMapImplPtr&& headers) {\n  headers->insertStatus().value(parser_.status_code);\n\n  // Handle the case where the client is closing a kept alive connection (by sending a 408\n  // with a 'Connection: close' header). In this case we just let response flush out followed\n  // by the remote close.\n  if (pending_responses_.empty() && !resetStreamCalled()) {\n    throw PrematureResponseException(std::move(headers));\n  } else if (!pending_responses_.empty()) {\n    if (parser_.status_code == 100) {\n      // http-parser treats 100 continue headers as their own complete response.\n      // Swallow the spurious onMessageComplete and continue processing.\n      ignore_message_complete_for_100_continue_ = true;\n      pending_responses_.front().decoder_->decode100ContinueHeaders(std::move(headers));\n    } else if (cannotHaveBody()) {\n      deferred_end_stream_headers_ = std::move(headers);\n    } else {\n      pending_responses_.front().decoder_->decodeHeaders(std::move(headers), false);\n    }\n  }\n\n  // Here we deal with cases where the response cannot have a body, but http_parser does not deal\n  // with it for us.\n  return cannotHaveBody() ? 1 : 0;\n}\n\nvoid ClientConnectionImpl::onBody(const char* data, size_t length) {\n  ASSERT(!deferred_end_stream_headers_);\n  if (!pending_responses_.empty()) {\n    Buffer::OwnedImpl buffer;\n    buffer.add(data, length);\n    pending_responses_.front().decoder_->decodeData(buffer, false);\n  }\n}\n\nvoid ClientConnectionImpl::onMessageComplete() {\n  ENVOY_CONN_LOG(trace, \"message complete\", connection_);\n  if (ignore_message_complete_for_100_continue_) {\n    ignore_message_complete_for_100_continue_ = false;\n    return;\n  }\n  if (!pending_responses_.empty()) {\n    // After calling decodeData() with end stream set to true, we should no longer be able to reset.\n    PendingResponse response = pending_responses_.front();\n    pending_responses_.pop_front();\n\n    // Streams are responsible for unwinding any outstanding readDisable(true)\n    // calls done on the underlying connection as they are destroyed. As this is\n    // the only place a HTTP/1 stream is destroyed where the Network::Connection is\n    // reused, unwind any outstanding readDisable() calls here. Only do this if there are no\n    // pipelined responses remaining. Also do this before we dispatch end_stream in case the caller\n    // immediately reuses the connection.\n    if (pending_responses_.empty()) {\n      while (!connection_.readEnabled()) {\n        connection_.readDisable(false);\n      }\n    }\n\n    if (deferred_end_stream_headers_) {\n      response.decoder_->decodeHeaders(std::move(deferred_end_stream_headers_), true);\n      deferred_end_stream_headers_.reset();\n    } else {\n      Buffer::OwnedImpl buffer;\n      response.decoder_->decodeData(buffer, true);\n    }\n  }\n}\n\nvoid ClientConnectionImpl::onResetStream(StreamResetReason reason) {\n  // Only raise reset if we did not already dispatch a complete response.\n  if (!pending_responses_.empty()) {\n    pending_responses_.clear();\n    request_encoder_->runResetCallbacks(reason);\n  }\n}\n\nvoid ClientConnectionImpl::onAboveHighWatermark() {\n  // This should never happen without an active stream/request.\n  ASSERT(!pending_responses_.empty());\n  request_encoder_->runHighWatermarkCallbacks();\n}\n\nvoid ClientConnectionImpl::onBelowLowWatermark() {\n  // This can get called without an active stream/request when upstream decides to do bad things\n  // such as sending multiple responses to the same request, causing us to close the connection, but\n  // in doing so go below low watermark.\n  if (!pending_responses_.empty()) {\n    request_encoder_->runLowWatermarkCallbacks();\n  }\n}\n\n} // namespace Http1\n} // namespace Http\n} // namespace Envoy\n", "#include \"common/http/http2/codec_impl.h\"\n\n#include <cstdint>\n#include <memory>\n#include <vector>\n\n#include \"envoy/event/dispatcher.h\"\n#include \"envoy/http/codes.h\"\n#include \"envoy/http/header_map.h\"\n#include \"envoy/network/connection.h\"\n#include \"envoy/stats/scope.h\"\n\n#include \"common/common/assert.h\"\n#include \"common/common/cleanup.h\"\n#include \"common/common/enum_to_int.h\"\n#include \"common/common/fmt.h\"\n#include \"common/common/stack_array.h\"\n#include \"common/common/utility.h\"\n#include \"common/http/codes.h\"\n#include \"common/http/exception.h\"\n#include \"common/http/headers.h\"\n\nnamespace Envoy {\nnamespace Http {\nnamespace Http2 {\n\nbool Utility::reconstituteCrumbledCookies(const HeaderString& key, const HeaderString& value,\n                                          HeaderString& cookies) {\n  if (key != Headers::get().Cookie.get().c_str()) {\n    return false;\n  }\n\n  if (!cookies.empty()) {\n    cookies.append(\"; \", 2);\n  }\n\n  const absl::string_view value_view = value.getStringView();\n  cookies.append(value_view.data(), value_view.size());\n  return true;\n}\n\nConnectionImpl::Http2Callbacks ConnectionImpl::http2_callbacks_;\n\n/**\n * Helper to remove const during a cast. nghttp2 takes non-const pointers for headers even though\n * it copies them.\n */\ntemplate <typename T> static T* remove_const(const void* object) {\n  return const_cast<T*>(reinterpret_cast<const T*>(object));\n}\n\nConnectionImpl::StreamImpl::StreamImpl(ConnectionImpl& parent, uint32_t buffer_limit)\n    : parent_(parent), headers_(new HeaderMapImpl()), local_end_stream_sent_(false),\n      remote_end_stream_(false), data_deferred_(false),\n      waiting_for_non_informational_headers_(false),\n      pending_receive_buffer_high_watermark_called_(false),\n      pending_send_buffer_high_watermark_called_(false), reset_due_to_messaging_error_(false) {\n  if (buffer_limit > 0) {\n    setWriteBufferWatermarks(buffer_limit / 2, buffer_limit);\n  }\n}\n\nstatic void insertHeader(std::vector<nghttp2_nv>& headers, const HeaderEntry& header) {\n  uint8_t flags = 0;\n  if (header.key().type() == HeaderString::Type::Reference) {\n    flags |= NGHTTP2_NV_FLAG_NO_COPY_NAME;\n  }\n  if (header.value().type() == HeaderString::Type::Reference) {\n    flags |= NGHTTP2_NV_FLAG_NO_COPY_VALUE;\n  }\n  const absl::string_view header_key = header.key().getStringView();\n  const absl::string_view header_value = header.value().getStringView();\n  headers.push_back({remove_const<uint8_t>(header_key.data()),\n                     remove_const<uint8_t>(header_value.data()), header_key.size(),\n                     header_value.size(), flags});\n}\n\nvoid ConnectionImpl::StreamImpl::buildHeaders(std::vector<nghttp2_nv>& final_headers,\n                                              const HeaderMap& headers) {\n  final_headers.reserve(headers.size());\n  headers.iterate(\n      [](const HeaderEntry& header, void* context) -> HeaderMap::Iterate {\n        std::vector<nghttp2_nv>* final_headers = static_cast<std::vector<nghttp2_nv>*>(context);\n        insertHeader(*final_headers, header);\n        return HeaderMap::Iterate::Continue;\n      },\n      &final_headers);\n}\n\nvoid ConnectionImpl::StreamImpl::encode100ContinueHeaders(const HeaderMap& headers) {\n  ASSERT(headers.Status()->value() == \"100\");\n  encodeHeaders(headers, false);\n}\n\nvoid ConnectionImpl::StreamImpl::encodeHeaders(const HeaderMap& headers, bool end_stream) {\n  std::vector<nghttp2_nv> final_headers;\n\n  // This must exist outside of the scope of isUpgrade as the underlying memory is\n  // needed until submitHeaders has been called.\n  Http::HeaderMapPtr modified_headers;\n  if (Http::Utility::isUpgrade(headers)) {\n    modified_headers = std::make_unique<Http::HeaderMapImpl>(headers);\n    transformUpgradeFromH1toH2(*modified_headers);\n    buildHeaders(final_headers, *modified_headers);\n  } else {\n    buildHeaders(final_headers, headers);\n  }\n\n  nghttp2_data_provider provider;\n  if (!end_stream) {\n    provider.source.ptr = this;\n    provider.read_callback = [](nghttp2_session*, int32_t, uint8_t*, size_t length,\n                                uint32_t* data_flags, nghttp2_data_source* source,\n                                void*) -> ssize_t {\n      return static_cast<StreamImpl*>(source->ptr)->onDataSourceRead(length, data_flags);\n    };\n  }\n\n  local_end_stream_ = end_stream;\n  submitHeaders(final_headers, end_stream ? nullptr : &provider);\n  parent_.sendPendingFrames();\n}\n\nvoid ConnectionImpl::StreamImpl::encodeTrailers(const HeaderMap& trailers) {\n  ASSERT(!local_end_stream_);\n  local_end_stream_ = true;\n  if (pending_send_data_.length() > 0) {\n    // In this case we want trailers to come after we release all pending body data that is\n    // waiting on window updates. We need to save the trailers so that we can emit them later.\n    ASSERT(!pending_trailers_);\n    pending_trailers_ = std::make_unique<HeaderMapImpl>(trailers);\n  } else {\n    submitTrailers(trailers);\n    parent_.sendPendingFrames();\n  }\n}\n\nvoid ConnectionImpl::StreamImpl::encodeMetadata(const MetadataMapVector& metadata_map_vector) {\n  ASSERT(parent_.allow_metadata_);\n\n  getMetadataEncoder().createPayload(metadata_map_vector);\n\n  // Estimates the number of frames to generate, and breaks the while loop when the size is reached\n  // in case submitting succeeds and packing fails, and we don't get error from packing.\n  const size_t frame_count = metadata_encoder_->frameCountUpperBound();\n  size_t count = 0;\n  // Keep submitting extension frames if there is payload left in the encoder.\n  while (metadata_encoder_->hasNextFrame() && count++ <= frame_count) {\n    submitMetadata();\n    parent_.sendPendingFrames();\n  }\n\n  ASSERT(!metadata_encoder_->hasNextFrame());\n}\n\nvoid ConnectionImpl::StreamImpl::readDisable(bool disable) {\n  ENVOY_CONN_LOG(debug, \"Stream {} {}, unconsumed_bytes {} read_disable_count {}\",\n                 parent_.connection_, stream_id_, (disable ? \"disabled\" : \"enabled\"),\n                 unconsumed_bytes_, read_disable_count_);\n  if (disable) {\n    ++read_disable_count_;\n  } else {\n    ASSERT(read_disable_count_ > 0);\n    --read_disable_count_;\n    if (!buffers_overrun()) {\n      nghttp2_session_consume(parent_.session_, stream_id_, unconsumed_bytes_);\n      unconsumed_bytes_ = 0;\n      parent_.sendPendingFrames();\n    }\n  }\n}\n\nvoid ConnectionImpl::StreamImpl::pendingRecvBufferHighWatermark() {\n  ENVOY_CONN_LOG(debug, \"recv buffer over limit \", parent_.connection_);\n  ASSERT(!pending_receive_buffer_high_watermark_called_);\n  pending_receive_buffer_high_watermark_called_ = true;\n  readDisable(true);\n}\n\nvoid ConnectionImpl::StreamImpl::pendingRecvBufferLowWatermark() {\n  ENVOY_CONN_LOG(debug, \"recv buffer under limit \", parent_.connection_);\n  ASSERT(pending_receive_buffer_high_watermark_called_);\n  pending_receive_buffer_high_watermark_called_ = false;\n  readDisable(false);\n}\n\nvoid ConnectionImpl::StreamImpl::decodeHeaders() {\n  maybeTransformUpgradeFromH2ToH1();\n  decoder_->decodeHeaders(std::move(headers_), remote_end_stream_);\n}\n\nvoid ConnectionImpl::StreamImpl::pendingSendBufferHighWatermark() {\n  ENVOY_CONN_LOG(debug, \"send buffer over limit \", parent_.connection_);\n  ASSERT(!pending_send_buffer_high_watermark_called_);\n  pending_send_buffer_high_watermark_called_ = true;\n  runHighWatermarkCallbacks();\n}\n\nvoid ConnectionImpl::StreamImpl::pendingSendBufferLowWatermark() {\n  ENVOY_CONN_LOG(debug, \"send buffer under limit \", parent_.connection_);\n  ASSERT(pending_send_buffer_high_watermark_called_);\n  pending_send_buffer_high_watermark_called_ = false;\n  runLowWatermarkCallbacks();\n}\n\nvoid ConnectionImpl::StreamImpl::saveHeader(HeaderString&& name, HeaderString&& value) {\n  if (!Utility::reconstituteCrumbledCookies(name, value, cookies_)) {\n    headers_->addViaMove(std::move(name), std::move(value));\n  }\n}\n\nvoid ConnectionImpl::StreamImpl::submitTrailers(const HeaderMap& trailers) {\n  std::vector<nghttp2_nv> final_headers;\n  buildHeaders(final_headers, trailers);\n  int rc =\n      nghttp2_submit_trailer(parent_.session_, stream_id_, &final_headers[0], final_headers.size());\n  ASSERT(rc == 0);\n}\n\nvoid ConnectionImpl::StreamImpl::submitMetadata() {\n  ASSERT(stream_id_ > 0);\n  const int result =\n      nghttp2_submit_extension(parent_.session_, METADATA_FRAME_TYPE,\n                               metadata_encoder_->nextEndMetadata(), stream_id_, nullptr);\n  ASSERT(result == 0);\n}\n\nssize_t ConnectionImpl::StreamImpl::onDataSourceRead(uint64_t length, uint32_t* data_flags) {\n  if (pending_send_data_.length() == 0 && !local_end_stream_) {\n    ASSERT(!data_deferred_);\n    data_deferred_ = true;\n    return NGHTTP2_ERR_DEFERRED;\n  } else {\n    *data_flags |= NGHTTP2_DATA_FLAG_NO_COPY;\n    if (local_end_stream_ && pending_send_data_.length() <= length) {\n      *data_flags |= NGHTTP2_DATA_FLAG_EOF;\n      if (pending_trailers_) {\n        // We need to tell the library to not set end stream so that we can emit the trailers.\n        *data_flags |= NGHTTP2_DATA_FLAG_NO_END_STREAM;\n        submitTrailers(*pending_trailers_);\n        pending_trailers_.reset();\n      }\n    }\n\n    return std::min(length, pending_send_data_.length());\n  }\n}\n\nint ConnectionImpl::StreamImpl::onDataSourceSend(const uint8_t* framehd, size_t length) {\n  // In this callback we are writing out a raw DATA frame without copying. nghttp2 assumes that we\n  // \"just know\" that the frame header is 9 bytes.\n  // https://nghttp2.org/documentation/types.html#c.nghttp2_send_data_callback\n  static const uint64_t FRAME_HEADER_SIZE = 9;\n\n  parent_.outbound_data_frames_++;\n\n  Buffer::OwnedImpl output;\n  if (!parent_.addOutboundFrameFragment(output, framehd, FRAME_HEADER_SIZE)) {\n    ENVOY_CONN_LOG(debug, \"error sending data frame: Too many frames in the outbound queue\",\n                   parent_.connection_);\n    return NGHTTP2_ERR_FLOODED;\n  }\n\n  output.move(pending_send_data_, length);\n  parent_.connection_.write(output, false);\n  return 0;\n}\n\nvoid ConnectionImpl::ClientStreamImpl::submitHeaders(const std::vector<nghttp2_nv>& final_headers,\n                                                     nghttp2_data_provider* provider) {\n  ASSERT(stream_id_ == -1);\n  stream_id_ = nghttp2_submit_request(parent_.session_, nullptr, &final_headers.data()[0],\n                                      final_headers.size(), provider, base());\n  ASSERT(stream_id_ > 0);\n}\n\nvoid ConnectionImpl::ServerStreamImpl::submitHeaders(const std::vector<nghttp2_nv>& final_headers,\n                                                     nghttp2_data_provider* provider) {\n  ASSERT(stream_id_ != -1);\n  int rc = nghttp2_submit_response(parent_.session_, stream_id_, &final_headers.data()[0],\n                                   final_headers.size(), provider);\n  ASSERT(rc == 0);\n}\n\nvoid ConnectionImpl::StreamImpl::encodeData(Buffer::Instance& data, bool end_stream) {\n  ASSERT(!local_end_stream_);\n  local_end_stream_ = end_stream;\n  pending_send_data_.move(data);\n  if (data_deferred_) {\n    int rc = nghttp2_session_resume_data(parent_.session_, stream_id_);\n    ASSERT(rc == 0);\n\n    data_deferred_ = false;\n  }\n\n  parent_.sendPendingFrames();\n}\n\nvoid ConnectionImpl::StreamImpl::resetStream(StreamResetReason reason) {\n  // Higher layers expect calling resetStream() to immediately raise reset callbacks.\n  runResetCallbacks(reason);\n\n  // If we submit a reset, nghttp2 will cancel outbound frames that have not yet been sent.\n  // We want these frames to go out so we defer the reset until we send all of the frames that\n  // end the local stream.\n  if (local_end_stream_ && !local_end_stream_sent_) {\n    parent_.pending_deferred_reset_ = true;\n    deferred_reset_ = reason;\n    ENVOY_CONN_LOG(trace, \"deferred reset stream\", parent_.connection_);\n  } else {\n    resetStreamWorker(reason);\n  }\n\n  // We must still call sendPendingFrames() in both the deferred and not deferred path. This forces\n  // the cleanup logic to run which will reset the stream in all cases if all data frames could not\n  // be sent.\n  parent_.sendPendingFrames();\n}\n\nvoid ConnectionImpl::StreamImpl::resetStreamWorker(StreamResetReason reason) {\n  int rc = nghttp2_submit_rst_stream(parent_.session_, NGHTTP2_FLAG_NONE, stream_id_,\n                                     reason == StreamResetReason::LocalRefusedStreamReset\n                                         ? NGHTTP2_REFUSED_STREAM\n                                         : NGHTTP2_NO_ERROR);\n  ASSERT(rc == 0);\n}\n\nMetadataEncoder& ConnectionImpl::StreamImpl::getMetadataEncoder() {\n  if (metadata_encoder_ == nullptr) {\n    metadata_encoder_ = std::make_unique<MetadataEncoder>();\n  }\n  return *metadata_encoder_;\n}\n\nMetadataDecoder& ConnectionImpl::StreamImpl::getMetadataDecoder() {\n  if (metadata_decoder_ == nullptr) {\n    auto cb = [this](MetadataMapPtr&& metadata_map_ptr) {\n      this->onMetadataDecoded(std::move(metadata_map_ptr));\n    };\n    metadata_decoder_ = std::make_unique<MetadataDecoder>(cb);\n  }\n  return *metadata_decoder_;\n}\n\nvoid ConnectionImpl::StreamImpl::onMetadataDecoded(MetadataMapPtr&& metadata_map_ptr) {\n  decoder_->decodeMetadata(std::move(metadata_map_ptr));\n}\n\nnamespace {\n\nconst char InvalidHttpMessagingOverrideKey[] =\n    \"envoy.reloadable_features.http2_protocol_options.stream_error_on_invalid_http_messaging\";\nconst char MaxOutboundFramesOverrideKey[] =\n    \"envoy.reloadable_features.http2_protocol_options.max_outbound_frames\";\nconst char MaxOutboundControlFramesOverrideKey[] =\n    \"envoy.reloadable_features.http2_protocol_options.max_outbound_control_frames\";\nconst char MaxConsecutiveInboundFramesWithEmptyPayloadOverrideKey[] =\n    \"envoy.reloadable_features.http2_protocol_options.\"\n    \"max_consecutive_inbound_frames_with_empty_payload\";\nconst char MaxInboundPriorityFramesPerStreamOverrideKey[] =\n    \"envoy.reloadable_features.http2_protocol_options.max_inbound_priority_frames_per_stream\";\nconst char MaxInboundWindowUpdateFramesPerDataFrameSentOverrideKey[] =\n    \"envoy.reloadable_features.http2_protocol_options.\"\n    \"max_inbound_window_update_frames_per_data_frame_sent\";\n\nbool checkRuntimeOverride(bool config_value, const char* override_key) {\n  return Runtime::runtimeFeatureEnabled(override_key) ? true : config_value;\n}\n\n} // namespace\n\nConnectionImpl::ConnectionImpl(Network::Connection& connection, Stats::Scope& stats,\n                               const Http2Settings& http2_settings,\n                               const uint32_t max_request_headers_kb)\n    : stats_{ALL_HTTP2_CODEC_STATS(POOL_COUNTER_PREFIX(stats, \"http2.\"))}, connection_(connection),\n      max_request_headers_kb_(max_request_headers_kb),\n      per_stream_buffer_limit_(http2_settings.initial_stream_window_size_),\n      stream_error_on_invalid_http_messaging_(checkRuntimeOverride(\n          http2_settings.stream_error_on_invalid_http_messaging_, InvalidHttpMessagingOverrideKey)),\n      flood_detected_(false),\n      max_outbound_frames_(\n          Runtime::getInteger(MaxOutboundFramesOverrideKey, http2_settings.max_outbound_frames_)),\n      frame_buffer_releasor_([this](const Buffer::OwnedBufferFragmentImpl* fragment) {\n        releaseOutboundFrame(fragment);\n      }),\n      max_outbound_control_frames_(Runtime::getInteger(\n          MaxOutboundControlFramesOverrideKey, http2_settings.max_outbound_control_frames_)),\n      control_frame_buffer_releasor_([this](const Buffer::OwnedBufferFragmentImpl* fragment) {\n        releaseOutboundControlFrame(fragment);\n      }),\n      max_consecutive_inbound_frames_with_empty_payload_(\n          Runtime::getInteger(MaxConsecutiveInboundFramesWithEmptyPayloadOverrideKey,\n                              http2_settings.max_consecutive_inbound_frames_with_empty_payload_)),\n      max_inbound_priority_frames_per_stream_(\n          Runtime::getInteger(MaxInboundPriorityFramesPerStreamOverrideKey,\n                              http2_settings.max_inbound_priority_frames_per_stream_)),\n      max_inbound_window_update_frames_per_data_frame_sent_(Runtime::getInteger(\n          MaxInboundWindowUpdateFramesPerDataFrameSentOverrideKey,\n          http2_settings.max_inbound_window_update_frames_per_data_frame_sent_)),\n      dispatching_(false), raised_goaway_(false), pending_deferred_reset_(false) {}\n\nConnectionImpl::~ConnectionImpl() { nghttp2_session_del(session_); }\n\nvoid ConnectionImpl::dispatch(Buffer::Instance& data) {\n  ENVOY_CONN_LOG(trace, \"dispatching {} bytes\", connection_, data.length());\n  uint64_t num_slices = data.getRawSlices(nullptr, 0);\n  STACK_ARRAY(slices, Buffer::RawSlice, num_slices);\n  data.getRawSlices(slices.begin(), num_slices);\n  for (const Buffer::RawSlice& slice : slices) {\n    dispatching_ = true;\n    ssize_t rc =\n        nghttp2_session_mem_recv(session_, static_cast<const uint8_t*>(slice.mem_), slice.len_);\n    if (rc == NGHTTP2_ERR_FLOODED || flood_detected_) {\n      throw FrameFloodException(\n          \"Flooding was detected in this HTTP/2 session, and it must be closed\");\n    }\n    if (rc != static_cast<ssize_t>(slice.len_)) {\n      throw CodecProtocolException(fmt::format(\"{}\", nghttp2_strerror(rc)));\n    }\n\n    dispatching_ = false;\n  }\n\n  ENVOY_CONN_LOG(trace, \"dispatched {} bytes\", connection_, data.length());\n  data.drain(data.length());\n\n  // Decoding incoming frames can generate outbound frames so flush pending.\n  sendPendingFrames();\n}\n\nConnectionImpl::StreamImpl* ConnectionImpl::getStream(int32_t stream_id) {\n  return static_cast<StreamImpl*>(nghttp2_session_get_stream_user_data(session_, stream_id));\n}\n\nint ConnectionImpl::onData(int32_t stream_id, const uint8_t* data, size_t len) {\n  StreamImpl* stream = getStream(stream_id);\n  // If this results in buffering too much data, the watermark buffer will call\n  // pendingRecvBufferHighWatermark, resulting in ++read_disable_count_\n  stream->pending_recv_data_.add(data, len);\n  // Update the window to the peer unless some consumer of this stream's data has hit a flow control\n  // limit and disabled reads on this stream\n  if (!stream->buffers_overrun()) {\n    nghttp2_session_consume(session_, stream_id, len);\n  } else {\n    stream->unconsumed_bytes_ += len;\n  }\n  return 0;\n}\n\nvoid ConnectionImpl::goAway() {\n  int rc = nghttp2_submit_goaway(session_, NGHTTP2_FLAG_NONE,\n                                 nghttp2_session_get_last_proc_stream_id(session_),\n                                 NGHTTP2_NO_ERROR, nullptr, 0);\n  ASSERT(rc == 0);\n\n  sendPendingFrames();\n}\n\nvoid ConnectionImpl::shutdownNotice() {\n  int rc = nghttp2_submit_shutdown_notice(session_);\n  ASSERT(rc == 0);\n\n  sendPendingFrames();\n}\n\nint ConnectionImpl::onBeforeFrameReceived(const nghttp2_frame_hd* hd) {\n  ENVOY_CONN_LOG(trace, \"about to recv frame type={}, flags={}\", connection_,\n                 static_cast<uint64_t>(hd->type), static_cast<uint64_t>(hd->flags));\n\n  // Track all the frames without padding here, since this is the only callback we receive\n  // for some of them (e.g. CONTINUATION frame, frames sent on closed streams, etc.).\n  // HEADERS frame is tracked in onBeginHeaders(), DATA frame is tracked in onFrameReceived().\n  if (hd->type != NGHTTP2_HEADERS && hd->type != NGHTTP2_DATA) {\n    if (!trackInboundFrames(hd, 0)) {\n      return NGHTTP2_ERR_FLOODED;\n    }\n  }\n\n  return 0;\n}\n\nint ConnectionImpl::onFrameReceived(const nghttp2_frame* frame) {\n  ENVOY_CONN_LOG(trace, \"recv frame type={}\", connection_, static_cast<uint64_t>(frame->hd.type));\n\n  // onFrameReceived() is called with a complete HEADERS frame assembled from all the HEADERS\n  // and CONTINUATION frames, but we track them separately: HEADERS frames in onBeginHeaders()\n  // and CONTINUATION frames in onBeforeFrameReceived().\n  ASSERT(frame->hd.type != NGHTTP2_CONTINUATION);\n\n  if (frame->hd.type == NGHTTP2_DATA) {\n    if (!trackInboundFrames(&frame->hd, frame->data.padlen)) {\n      return NGHTTP2_ERR_FLOODED;\n    }\n  }\n\n  // Only raise GOAWAY once, since we don't currently expose stream information. Shutdown\n  // notifications are the same as a normal GOAWAY.\n  if (frame->hd.type == NGHTTP2_GOAWAY && !raised_goaway_) {\n    ASSERT(frame->hd.stream_id == 0);\n    raised_goaway_ = true;\n    callbacks().onGoAway();\n    return 0;\n  }\n\n  StreamImpl* stream = getStream(frame->hd.stream_id);\n  if (!stream) {\n    return 0;\n  }\n\n  switch (frame->hd.type) {\n  case NGHTTP2_HEADERS: {\n    // Verify that the final HeaderMap's byte size is under the limit before decoding headers.\n    // This assert iterates over the HeaderMap.\n    ASSERT(stream->headers_->byteSize().has_value() &&\n           stream->headers_->byteSize().value() == stream->headers_->byteSizeInternal());\n    stream->remote_end_stream_ = frame->hd.flags & NGHTTP2_FLAG_END_STREAM;\n    if (!stream->cookies_.empty()) {\n      HeaderString key(Headers::get().Cookie);\n      stream->headers_->addViaMove(std::move(key), std::move(stream->cookies_));\n    }\n\n    switch (frame->headers.cat) {\n    case NGHTTP2_HCAT_RESPONSE: {\n      if (CodeUtility::is1xx(Http::Utility::getResponseStatus(*stream->headers_))) {\n        stream->waiting_for_non_informational_headers_ = true;\n      }\n\n      if (stream->headers_->Status()->value() == \"100\") {\n        ASSERT(!stream->remote_end_stream_);\n        stream->decoder_->decode100ContinueHeaders(std::move(stream->headers_));\n      } else {\n        stream->decodeHeaders();\n      }\n      break;\n    }\n\n    case NGHTTP2_HCAT_REQUEST: {\n      stream->decodeHeaders();\n      break;\n    }\n\n    case NGHTTP2_HCAT_HEADERS: {\n      // It's possible that we are waiting to send a deferred reset, so only raise headers/trailers\n      // if local is not complete.\n      if (!stream->deferred_reset_) {\n        if (!stream->waiting_for_non_informational_headers_) {\n          if (!stream->remote_end_stream_) {\n            // This indicates we have received more headers frames than Envoy\n            // supports. Even if this is valid HTTP (something like 103 early hints) fail here\n            // rather than trying to push unexpected headers through the Envoy pipeline as that\n            // will likely result in Envoy crashing.\n            // It would be cleaner to reset the stream rather than reset the/ entire connection but\n            // it's also slightly more dangerous so currently we err on the side of safety.\n            stats_.too_many_header_frames_.inc();\n            throw CodecProtocolException(\"Unexpected 'trailers' with no end stream.\");\n          } else {\n            stream->decoder_->decodeTrailers(std::move(stream->headers_));\n          }\n        } else {\n          ASSERT(!nghttp2_session_check_server_session(session_));\n          stream->waiting_for_non_informational_headers_ = false;\n\n          // Even if we have :status 100 in the client case in a response, when\n          // we received a 1xx to start out with, nghttp2 message checking\n          // guarantees proper flow here.\n          stream->decodeHeaders();\n        }\n      }\n\n      break;\n    }\n\n    default:\n      // We do not currently support push.\n      NOT_IMPLEMENTED_GCOVR_EXCL_LINE;\n    }\n\n    stream->headers_.reset();\n    break;\n  }\n  case NGHTTP2_DATA: {\n    stream->remote_end_stream_ = frame->hd.flags & NGHTTP2_FLAG_END_STREAM;\n\n    // It's possible that we are waiting to send a deferred reset, so only raise data if local\n    // is not complete.\n    if (!stream->deferred_reset_) {\n      stream->decoder_->decodeData(stream->pending_recv_data_, stream->remote_end_stream_);\n    }\n\n    stream->pending_recv_data_.drain(stream->pending_recv_data_.length());\n    break;\n  }\n  case NGHTTP2_RST_STREAM: {\n    ENVOY_CONN_LOG(trace, \"remote reset: {}\", connection_, frame->rst_stream.error_code);\n    stats_.rx_reset_.inc();\n    break;\n  }\n  }\n\n  return 0;\n}\n\nint ConnectionImpl::onFrameSend(const nghttp2_frame* frame) {\n  // The nghttp2 library does not cleanly give us a way to determine whether we received invalid\n  // data from our peer. Sometimes it raises the invalid frame callback, and sometimes it does not.\n  // In all cases however it will attempt to send a GOAWAY frame with an error status. If we see\n  // an outgoing frame of this type, we will return an error code so that we can abort execution.\n  ENVOY_CONN_LOG(trace, \"sent frame type={}\", connection_, static_cast<uint64_t>(frame->hd.type));\n  switch (frame->hd.type) {\n  case NGHTTP2_GOAWAY: {\n    ENVOY_CONN_LOG(debug, \"sent goaway code={}\", connection_, frame->goaway.error_code);\n    if (frame->goaway.error_code != NGHTTP2_NO_ERROR) {\n      return NGHTTP2_ERR_CALLBACK_FAILURE;\n    }\n    break;\n  }\n\n  case NGHTTP2_RST_STREAM: {\n    ENVOY_CONN_LOG(debug, \"sent reset code={}\", connection_, frame->rst_stream.error_code);\n    stats_.tx_reset_.inc();\n    break;\n  }\n\n  case NGHTTP2_HEADERS:\n  case NGHTTP2_DATA: {\n    StreamImpl* stream = getStream(frame->hd.stream_id);\n    if (stream->headers_) {\n      // Verify that the final HeaderMap's byte size is under the limit before sending frames.\n      // This assert iterates over the HeaderMap.\n      ASSERT(stream->headers_->byteSize().has_value() &&\n             stream->headers_->byteSize().value() == stream->headers_->byteSizeInternal());\n    }\n    stream->local_end_stream_sent_ = frame->hd.flags & NGHTTP2_FLAG_END_STREAM;\n    break;\n  }\n  }\n\n  return 0;\n}\n\nint ConnectionImpl::onInvalidFrame(int32_t stream_id, int error_code) {\n  ENVOY_CONN_LOG(debug, \"invalid frame: {} on stream {}\", connection_, nghttp2_strerror(error_code),\n                 stream_id);\n\n  if (error_code == NGHTTP2_ERR_HTTP_HEADER || error_code == NGHTTP2_ERR_HTTP_MESSAGING) {\n    stats_.rx_messaging_error_.inc();\n\n    if (stream_error_on_invalid_http_messaging_) {\n      // The stream is about to be closed due to an invalid header or messaging. Don't kill the\n      // entire connection if one stream has bad headers or messaging.\n      StreamImpl* stream = getStream(stream_id);\n      if (stream != nullptr) {\n        // See comment below in onStreamClose() for why we do this.\n        stream->reset_due_to_messaging_error_ = true;\n      }\n      return 0;\n    }\n  }\n\n  // Cause dispatch to return with an error code.\n  return NGHTTP2_ERR_CALLBACK_FAILURE;\n}\n\nint ConnectionImpl::onBeforeFrameSend(const nghttp2_frame* frame) {\n  ENVOY_CONN_LOG(trace, \"about to send frame type={}, flags={}\", connection_,\n                 static_cast<uint64_t>(frame->hd.type), static_cast<uint64_t>(frame->hd.flags));\n  ASSERT(!is_outbound_flood_monitored_control_frame_);\n  // Flag flood monitored outbound control frames.\n  is_outbound_flood_monitored_control_frame_ =\n      ((frame->hd.type == NGHTTP2_PING || frame->hd.type == NGHTTP2_SETTINGS) &&\n       frame->hd.flags & NGHTTP2_FLAG_ACK) ||\n      frame->hd.type == NGHTTP2_RST_STREAM;\n  return 0;\n}\n\nvoid ConnectionImpl::incrementOutboundFrameCount(bool is_outbound_flood_monitored_control_frame) {\n  ++outbound_frames_;\n  if (is_outbound_flood_monitored_control_frame) {\n    ++outbound_control_frames_;\n  }\n  checkOutboundQueueLimits();\n}\n\nbool ConnectionImpl::addOutboundFrameFragment(Buffer::OwnedImpl& output, const uint8_t* data,\n                                              size_t length) {\n  // Reset the outbound frame type (set in the onBeforeFrameSend callback) since the\n  // onBeforeFrameSend callback is not called for DATA frames.\n  bool is_outbound_flood_monitored_control_frame = false;\n  std::swap(is_outbound_flood_monitored_control_frame, is_outbound_flood_monitored_control_frame_);\n  try {\n    incrementOutboundFrameCount(is_outbound_flood_monitored_control_frame);\n  } catch (const FrameFloodException&) {\n    return false;\n  }\n\n  auto fragment = Buffer::OwnedBufferFragmentImpl::create(\n      absl::string_view(reinterpret_cast<const char*>(data), length),\n      is_outbound_flood_monitored_control_frame ? control_frame_buffer_releasor_\n                                                : frame_buffer_releasor_);\n\n  // The Buffer::OwnedBufferFragmentImpl object will be deleted in the *frame_buffer_releasor_\n  // callback.\n  output.addBufferFragment(*fragment.release());\n  return true;\n}\n\nvoid ConnectionImpl::releaseOutboundFrame(const Buffer::OwnedBufferFragmentImpl* fragment) {\n  ASSERT(outbound_frames_ >= 1);\n  --outbound_frames_;\n  delete fragment;\n}\n\nvoid ConnectionImpl::releaseOutboundControlFrame(const Buffer::OwnedBufferFragmentImpl* fragment) {\n  ASSERT(outbound_control_frames_ >= 1);\n  --outbound_control_frames_;\n  releaseOutboundFrame(fragment);\n}\n\nssize_t ConnectionImpl::onSend(const uint8_t* data, size_t length) {\n  ENVOY_CONN_LOG(trace, \"send data: bytes={}\", connection_, length);\n  Buffer::OwnedImpl buffer;\n  if (!addOutboundFrameFragment(buffer, data, length)) {\n    ENVOY_CONN_LOG(debug, \"error sending frame: Too many frames in the outbound queue.\",\n                   connection_);\n    return NGHTTP2_ERR_FLOODED;\n  }\n\n  // While the buffer is transient the fragment it contains will be moved into the\n  // write_buffer_ of the underlying connection_ by the write method below.\n  // This creates lifetime dependency between the write_buffer_ of the underlying connection\n  // and the codec object. Specifically the write_buffer_ MUST be either fully drained or\n  // deleted before the codec object is deleted. This is presently guaranteed by the\n  // destruction order of the Network::ConnectionImpl object where write_buffer_ is\n  // destroyed before the filter_manager_ which owns the codec through Http::ConnectionManagerImpl.\n  connection_.write(buffer, false);\n  return length;\n}\n\nint ConnectionImpl::onStreamClose(int32_t stream_id, uint32_t error_code) {\n  StreamImpl* stream = getStream(stream_id);\n  if (stream) {\n    ENVOY_CONN_LOG(debug, \"stream closed: {}\", connection_, error_code);\n    if (!stream->remote_end_stream_ || !stream->local_end_stream_) {\n      StreamResetReason reason;\n      if (stream->reset_due_to_messaging_error_) {\n        // Unfortunately, the nghttp2 API makes it incredibly difficult to clearly understand\n        // the flow of resets. I.e., did the reset originate locally? Was it remote? Here,\n        // we attempt to track cases in which we sent a reset locally due to an invalid frame\n        // received from the remote. We only do that in two cases currently (HTTP messaging layer\n        // errors from https://tools.ietf.org/html/rfc7540#section-8 which nghttp2 is very strict\n        // about). In other cases we treat invalid frames as a protocol error and just kill\n        // the connection.\n        reason = StreamResetReason::LocalReset;\n      } else {\n        reason = error_code == NGHTTP2_REFUSED_STREAM ? StreamResetReason::RemoteRefusedStreamReset\n                                                      : StreamResetReason::RemoteReset;\n      }\n\n      stream->runResetCallbacks(reason);\n    }\n\n    connection_.dispatcher().deferredDelete(stream->removeFromList(active_streams_));\n    // Any unconsumed data must be consumed before the stream is deleted.\n    // nghttp2 does not appear to track this internally, and any stream deleted\n    // with outstanding window will contribute to a slow connection-window leak.\n    nghttp2_session_consume(session_, stream_id, stream->unconsumed_bytes_);\n    stream->unconsumed_bytes_ = 0;\n    nghttp2_session_set_stream_user_data(session_, stream->stream_id_, nullptr);\n  }\n\n  return 0;\n}\n\nint ConnectionImpl::onMetadataReceived(int32_t stream_id, const uint8_t* data, size_t len) {\n  ENVOY_CONN_LOG(trace, \"recv {} bytes METADATA\", connection_, len);\n\n  StreamImpl* stream = getStream(stream_id);\n  if (!stream) {\n    return 0;\n  }\n\n  bool success = stream->getMetadataDecoder().receiveMetadata(data, len);\n  return success ? 0 : NGHTTP2_ERR_CALLBACK_FAILURE;\n}\n\nint ConnectionImpl::onMetadataFrameComplete(int32_t stream_id, bool end_metadata) {\n  ENVOY_CONN_LOG(trace, \"recv METADATA frame on stream {}, end_metadata: {}\", connection_,\n                 stream_id, end_metadata);\n\n  StreamImpl* stream = getStream(stream_id);\n  ASSERT(stream != nullptr);\n\n  bool result = stream->getMetadataDecoder().onMetadataFrameComplete(end_metadata);\n  return result ? 0 : NGHTTP2_ERR_CALLBACK_FAILURE;\n}\n\nssize_t ConnectionImpl::packMetadata(int32_t stream_id, uint8_t* buf, size_t len) {\n  ENVOY_CONN_LOG(trace, \"pack METADATA frame on stream {}\", connection_, stream_id);\n\n  StreamImpl* stream = getStream(stream_id);\n  ASSERT(stream != nullptr);\n\n  MetadataEncoder& encoder = stream->getMetadataEncoder();\n  const uint64_t payload_size = encoder.packNextFramePayload(buf, len);\n  return static_cast<ssize_t>(payload_size);\n}\n\nint ConnectionImpl::saveHeader(const nghttp2_frame* frame, HeaderString&& name,\n                               HeaderString&& value) {\n  StreamImpl* stream = getStream(frame->hd.stream_id);\n  if (!stream) {\n    // We have seen 1 or 2 crashes where we get a headers callback but there is no associated\n    // stream data. I honestly am not sure how this can happen. However, from reading the nghttp2\n    // code it looks possible that inflate_header_block() can safely inflate headers for an already\n    // closed stream, but will still call the headers callback. Since that seems possible, we should\n    // ignore this case here.\n    // TODO(mattklein123): Figure out a test case that can hit this.\n    stats_.headers_cb_no_stream_.inc();\n    return 0;\n  }\n  stream->saveHeader(std::move(name), std::move(value));\n  // Verify that the cached value in byte size exists.\n  ASSERT(stream->headers_->byteSize().has_value());\n  if (stream->headers_->byteSize().value() > max_request_headers_kb_ * 1024) {\n    // This will cause the library to reset/close the stream.\n    stats_.header_overflow_.inc();\n    return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;\n  } else {\n    return 0;\n  }\n}\n\nvoid ConnectionImpl::sendPendingFrames() {\n  if (dispatching_ || connection_.state() == Network::Connection::State::Closed) {\n    return;\n  }\n\n  int rc = nghttp2_session_send(session_);\n  if (rc != 0) {\n    ASSERT(rc == NGHTTP2_ERR_CALLBACK_FAILURE);\n    // For errors caused by the pending outbound frame flood the FrameFloodException has\n    // to be thrown. However the nghttp2 library returns only the generic error code for\n    // all failure types. Check queue limits and throw FrameFloodException if they were\n    // exceeded.\n    if (outbound_frames_ > max_outbound_frames_ ||\n        outbound_control_frames_ > max_outbound_control_frames_) {\n      throw FrameFloodException(\"Too many frames in the outbound queue.\");\n    }\n\n    throw CodecProtocolException(fmt::format(\"{}\", nghttp2_strerror(rc)));\n  }\n\n  // See ConnectionImpl::StreamImpl::resetStream() for why we do this. This is an uncommon event,\n  // so iterating through every stream to find the ones that have a deferred reset is not a big\n  // deal. Furthermore, queueing a reset frame does not actually invoke the close stream callback.\n  // This is only done when the reset frame is sent. Thus, it's safe to work directly with the\n  // stream map.\n  // NOTE: The way we handle deferred reset is essentially best effort. If we intend to do a\n  //       deferred reset, we try to finish the stream, including writing any pending data frames.\n  //       If we cannot do this (potentially due to not enough window), we just reset the stream.\n  //       In general this behavior occurs only when we are trying to send immediate error messages\n  //       to short circuit requests. In the best effort case, we complete the stream before\n  //       resetting. In other cases, we just do the reset now which will blow away pending data\n  //       frames and release any memory associated with the stream.\n  if (pending_deferred_reset_) {\n    pending_deferred_reset_ = false;\n    for (auto& stream : active_streams_) {\n      if (stream->deferred_reset_) {\n        stream->resetStreamWorker(stream->deferred_reset_.value());\n      }\n    }\n    sendPendingFrames();\n  }\n}\n\nvoid ConnectionImpl::sendSettings(const Http2Settings& http2_settings, bool disable_push) {\n  ASSERT(http2_settings.hpack_table_size_ <= Http2Settings::MAX_HPACK_TABLE_SIZE);\n  ASSERT(Http2Settings::MIN_MAX_CONCURRENT_STREAMS <= http2_settings.max_concurrent_streams_ &&\n         http2_settings.max_concurrent_streams_ <= Http2Settings::MAX_MAX_CONCURRENT_STREAMS);\n  ASSERT(\n      Http2Settings::MIN_INITIAL_STREAM_WINDOW_SIZE <= http2_settings.initial_stream_window_size_ &&\n      http2_settings.initial_stream_window_size_ <= Http2Settings::MAX_INITIAL_STREAM_WINDOW_SIZE);\n  ASSERT(Http2Settings::MIN_INITIAL_CONNECTION_WINDOW_SIZE <=\n             http2_settings.initial_connection_window_size_ &&\n         http2_settings.initial_connection_window_size_ <=\n             Http2Settings::MAX_INITIAL_CONNECTION_WINDOW_SIZE);\n\n  std::vector<nghttp2_settings_entry> iv;\n\n  if (http2_settings.allow_connect_) {\n    iv.push_back({NGHTTP2_SETTINGS_ENABLE_CONNECT_PROTOCOL, 1});\n  }\n\n  if (http2_settings.hpack_table_size_ != NGHTTP2_DEFAULT_HEADER_TABLE_SIZE) {\n    iv.push_back({NGHTTP2_SETTINGS_HEADER_TABLE_SIZE, http2_settings.hpack_table_size_});\n    ENVOY_CONN_LOG(debug, \"setting HPACK table size to {}\", connection_,\n                   http2_settings.hpack_table_size_);\n  }\n\n  if (http2_settings.max_concurrent_streams_ != NGHTTP2_INITIAL_MAX_CONCURRENT_STREAMS) {\n    iv.push_back({NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS, http2_settings.max_concurrent_streams_});\n    ENVOY_CONN_LOG(debug, \"setting max concurrent streams to {}\", connection_,\n                   http2_settings.max_concurrent_streams_);\n  }\n\n  if (http2_settings.initial_stream_window_size_ != NGHTTP2_INITIAL_WINDOW_SIZE) {\n    iv.push_back(\n        {NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE, http2_settings.initial_stream_window_size_});\n    ENVOY_CONN_LOG(debug, \"setting stream-level initial window size to {}\", connection_,\n                   http2_settings.initial_stream_window_size_);\n  }\n\n  if (disable_push) {\n    // Universally disable receiving push promise frames as we don't currently support them. nghttp2\n    // will fail the connection if the other side still sends them.\n    // TODO(mattklein123): Remove this when we correctly proxy push promise.\n    iv.push_back({NGHTTP2_SETTINGS_ENABLE_PUSH, 0});\n  }\n\n  if (!iv.empty()) {\n    int rc = nghttp2_submit_settings(session_, NGHTTP2_FLAG_NONE, &iv[0], iv.size());\n    ASSERT(rc == 0);\n  } else {\n    // nghttp2_submit_settings need to be called at least once\n    int rc = nghttp2_submit_settings(session_, NGHTTP2_FLAG_NONE, nullptr, 0);\n    ASSERT(rc == 0);\n  }\n\n  // Increase connection window size up to our default size.\n  if (http2_settings.initial_connection_window_size_ != NGHTTP2_INITIAL_CONNECTION_WINDOW_SIZE) {\n    ENVOY_CONN_LOG(debug, \"updating connection-level initial window size to {}\", connection_,\n                   http2_settings.initial_connection_window_size_);\n    int rc = nghttp2_submit_window_update(session_, NGHTTP2_FLAG_NONE, 0,\n                                          http2_settings.initial_connection_window_size_ -\n                                              NGHTTP2_INITIAL_CONNECTION_WINDOW_SIZE);\n    ASSERT(rc == 0);\n  }\n}\n\nConnectionImpl::Http2Callbacks::Http2Callbacks() {\n  nghttp2_session_callbacks_new(&callbacks_);\n  nghttp2_session_callbacks_set_send_callback(\n      callbacks_,\n      [](nghttp2_session*, const uint8_t* data, size_t length, int, void* user_data) -> ssize_t {\n        return static_cast<ConnectionImpl*>(user_data)->onSend(data, length);\n      });\n\n  nghttp2_session_callbacks_set_send_data_callback(\n      callbacks_,\n      [](nghttp2_session*, nghttp2_frame* frame, const uint8_t* framehd, size_t length,\n         nghttp2_data_source* source, void*) -> int {\n        ASSERT(frame->data.padlen == 0);\n        return static_cast<StreamImpl*>(source->ptr)->onDataSourceSend(framehd, length);\n      });\n\n  nghttp2_session_callbacks_set_on_begin_headers_callback(\n      callbacks_, [](nghttp2_session*, const nghttp2_frame* frame, void* user_data) -> int {\n        return static_cast<ConnectionImpl*>(user_data)->onBeginHeaders(frame);\n      });\n\n  nghttp2_session_callbacks_set_on_header_callback(\n      callbacks_,\n      [](nghttp2_session*, const nghttp2_frame* frame, const uint8_t* raw_name, size_t name_length,\n         const uint8_t* raw_value, size_t value_length, uint8_t, void* user_data) -> int {\n        // TODO PERF: Can reference count here to avoid copies.\n        HeaderString name;\n        name.setCopy(reinterpret_cast<const char*>(raw_name), name_length);\n        HeaderString value;\n        value.setCopy(reinterpret_cast<const char*>(raw_value), value_length);\n        return static_cast<ConnectionImpl*>(user_data)->onHeader(frame, std::move(name),\n                                                                 std::move(value));\n      });\n\n  nghttp2_session_callbacks_set_on_data_chunk_recv_callback(\n      callbacks_,\n      [](nghttp2_session*, uint8_t, int32_t stream_id, const uint8_t* data, size_t len,\n         void* user_data) -> int {\n        return static_cast<ConnectionImpl*>(user_data)->onData(stream_id, data, len);\n      });\n\n  nghttp2_session_callbacks_set_on_begin_frame_callback(\n      callbacks_, [](nghttp2_session*, const nghttp2_frame_hd* hd, void* user_data) -> int {\n        return static_cast<ConnectionImpl*>(user_data)->onBeforeFrameReceived(hd);\n      });\n\n  nghttp2_session_callbacks_set_on_frame_recv_callback(\n      callbacks_, [](nghttp2_session*, const nghttp2_frame* frame, void* user_data) -> int {\n        return static_cast<ConnectionImpl*>(user_data)->onFrameReceived(frame);\n      });\n\n  nghttp2_session_callbacks_set_on_stream_close_callback(\n      callbacks_,\n      [](nghttp2_session*, int32_t stream_id, uint32_t error_code, void* user_data) -> int {\n        return static_cast<ConnectionImpl*>(user_data)->onStreamClose(stream_id, error_code);\n      });\n\n  nghttp2_session_callbacks_set_on_frame_send_callback(\n      callbacks_, [](nghttp2_session*, const nghttp2_frame* frame, void* user_data) -> int {\n        return static_cast<ConnectionImpl*>(user_data)->onFrameSend(frame);\n      });\n\n  nghttp2_session_callbacks_set_before_frame_send_callback(\n      callbacks_, [](nghttp2_session*, const nghttp2_frame* frame, void* user_data) -> int {\n        return static_cast<ConnectionImpl*>(user_data)->onBeforeFrameSend(frame);\n      });\n\n  nghttp2_session_callbacks_set_on_frame_not_send_callback(\n      callbacks_, [](nghttp2_session*, const nghttp2_frame*, int, void*) -> int {\n        // We used to always return failure here but it looks now this can get called if the other\n        // side sends GOAWAY and we are trying to send a SETTINGS ACK. Just ignore this for now.\n        return 0;\n      });\n\n  nghttp2_session_callbacks_set_on_invalid_frame_recv_callback(\n      callbacks_,\n      [](nghttp2_session*, const nghttp2_frame* frame, int error_code, void* user_data) -> int {\n        return static_cast<ConnectionImpl*>(user_data)->onInvalidFrame(frame->hd.stream_id,\n                                                                       error_code);\n      });\n\n  nghttp2_session_callbacks_set_on_extension_chunk_recv_callback(\n      callbacks_,\n      [](nghttp2_session*, const nghttp2_frame_hd* hd, const uint8_t* data, size_t len,\n         void* user_data) -> int {\n        ASSERT(hd->length >= len);\n        return static_cast<ConnectionImpl*>(user_data)->onMetadataReceived(hd->stream_id, data,\n                                                                           len);\n      });\n\n  nghttp2_session_callbacks_set_unpack_extension_callback(\n      callbacks_, [](nghttp2_session*, void**, const nghttp2_frame_hd* hd, void* user_data) -> int {\n        return static_cast<ConnectionImpl*>(user_data)->onMetadataFrameComplete(\n            hd->stream_id, hd->flags == END_METADATA_FLAG);\n      });\n\n  nghttp2_session_callbacks_set_pack_extension_callback(\n      callbacks_,\n      [](nghttp2_session*, uint8_t* buf, size_t len, const nghttp2_frame* frame,\n         void* user_data) -> ssize_t {\n        ASSERT(frame->hd.length <= len);\n        return static_cast<ConnectionImpl*>(user_data)->packMetadata(frame->hd.stream_id, buf, len);\n      });\n}\n\nConnectionImpl::Http2Callbacks::~Http2Callbacks() { nghttp2_session_callbacks_del(callbacks_); }\n\nConnectionImpl::Http2Options::Http2Options(const Http2Settings& http2_settings) {\n  nghttp2_option_new(&options_);\n  // Currently we do not do anything with stream priority. Setting the following option prevents\n  // nghttp2 from keeping around closed streams for use during stream priority dependency graph\n  // calculations. This saves a tremendous amount of memory in cases where there are a large number\n  // of kept alive HTTP/2 connections.\n  nghttp2_option_set_no_closed_streams(options_, 1);\n  nghttp2_option_set_no_auto_window_update(options_, 1);\n\n  // The max send header block length is configured to an arbitrarily high number so as to never\n  // trigger the check within nghttp2, as we check request headers length in codec_impl::saveHeader.\n  nghttp2_option_set_max_send_header_block_length(options_, 0x2000000);\n\n  if (http2_settings.hpack_table_size_ != NGHTTP2_DEFAULT_HEADER_TABLE_SIZE) {\n    nghttp2_option_set_max_deflate_dynamic_table_size(options_, http2_settings.hpack_table_size_);\n  }\n\n  if (http2_settings.allow_metadata_) {\n    nghttp2_option_set_user_recv_extension_type(options_, METADATA_FRAME_TYPE);\n  }\n}\n\nConnectionImpl::Http2Options::~Http2Options() { nghttp2_option_del(options_); }\n\nConnectionImpl::ClientHttp2Options::ClientHttp2Options(const Http2Settings& http2_settings)\n    : Http2Options(http2_settings) {\n  // Temporarily disable initial max streams limit/protection, since we might want to create\n  // more than 100 streams before receiving the HTTP/2 SETTINGS frame from the server.\n  //\n  // TODO(PiotrSikora): remove this once multiple upstream connections or queuing are implemented.\n  nghttp2_option_set_peer_max_concurrent_streams(options_,\n                                                 Http2Settings::DEFAULT_MAX_CONCURRENT_STREAMS);\n}\n\nClientConnectionImpl::ClientConnectionImpl(Network::Connection& connection,\n                                           Http::ConnectionCallbacks& callbacks,\n                                           Stats::Scope& stats, const Http2Settings& http2_settings,\n                                           const uint32_t max_request_headers_kb)\n    : ConnectionImpl(connection, stats, http2_settings, max_request_headers_kb),\n      callbacks_(callbacks) {\n  ClientHttp2Options client_http2_options(http2_settings);\n  nghttp2_session_client_new2(&session_, http2_callbacks_.callbacks(), base(),\n                              client_http2_options.options());\n  sendSettings(http2_settings, true);\n  allow_metadata_ = http2_settings.allow_metadata_;\n}\n\nHttp::StreamEncoder& ClientConnectionImpl::newStream(StreamDecoder& decoder) {\n  StreamImplPtr stream(new ClientStreamImpl(*this, per_stream_buffer_limit_));\n  stream->decoder_ = &decoder;\n  // If the connection is currently above the high watermark, make sure to inform the new stream.\n  // The connection can not pass this on automatically as it has no awareness that a new stream is\n  // created.\n  if (connection_.aboveHighWatermark()) {\n    stream->runHighWatermarkCallbacks();\n  }\n  stream->moveIntoList(std::move(stream), active_streams_);\n  return *active_streams_.front();\n}\n\nint ClientConnectionImpl::onBeginHeaders(const nghttp2_frame* frame) {\n  // The client code explicitly does not currently support push promise.\n  RELEASE_ASSERT(frame->hd.type == NGHTTP2_HEADERS, \"\");\n  RELEASE_ASSERT(frame->headers.cat == NGHTTP2_HCAT_RESPONSE ||\n                     frame->headers.cat == NGHTTP2_HCAT_HEADERS,\n                 \"\");\n  if (frame->headers.cat == NGHTTP2_HCAT_HEADERS) {\n    StreamImpl* stream = getStream(frame->hd.stream_id);\n    ASSERT(!stream->headers_);\n    stream->headers_ = std::make_unique<HeaderMapImpl>();\n  }\n\n  return 0;\n}\n\nint ClientConnectionImpl::onHeader(const nghttp2_frame* frame, HeaderString&& name,\n                                   HeaderString&& value) {\n  // The client code explicitly does not currently support push promise.\n  ASSERT(frame->hd.type == NGHTTP2_HEADERS);\n  ASSERT(frame->headers.cat == NGHTTP2_HCAT_RESPONSE || frame->headers.cat == NGHTTP2_HCAT_HEADERS);\n  return saveHeader(frame, std::move(name), std::move(value));\n}\n\nServerConnectionImpl::ServerConnectionImpl(Network::Connection& connection,\n                                           Http::ServerConnectionCallbacks& callbacks,\n                                           Stats::Scope& scope, const Http2Settings& http2_settings,\n                                           const uint32_t max_request_headers_kb)\n    : ConnectionImpl(connection, scope, http2_settings, max_request_headers_kb),\n      callbacks_(callbacks) {\n  Http2Options http2_options(http2_settings);\n  nghttp2_session_server_new2(&session_, http2_callbacks_.callbacks(), base(),\n                              http2_options.options());\n  sendSettings(http2_settings, false);\n  allow_metadata_ = http2_settings.allow_metadata_;\n}\n\nint ServerConnectionImpl::onBeginHeaders(const nghttp2_frame* frame) {\n  // For a server connection, we should never get push promise frames.\n  ASSERT(frame->hd.type == NGHTTP2_HEADERS);\n\n  if (!trackInboundFrames(&frame->hd, frame->headers.padlen)) {\n    return NGHTTP2_ERR_FLOODED;\n  }\n\n  if (frame->headers.cat != NGHTTP2_HCAT_REQUEST) {\n    stats_.trailers_.inc();\n    ASSERT(frame->headers.cat == NGHTTP2_HCAT_HEADERS);\n\n    StreamImpl* stream = getStream(frame->hd.stream_id);\n    ASSERT(!stream->headers_);\n    stream->headers_ = std::make_unique<HeaderMapImpl>();\n    return 0;\n  }\n\n  StreamImplPtr stream(new ServerStreamImpl(*this, per_stream_buffer_limit_));\n  if (connection_.aboveHighWatermark()) {\n    stream->runHighWatermarkCallbacks();\n  }\n  stream->decoder_ = &callbacks_.newStream(*stream);\n  stream->stream_id_ = frame->hd.stream_id;\n  stream->moveIntoList(std::move(stream), active_streams_);\n  nghttp2_session_set_stream_user_data(session_, frame->hd.stream_id,\n                                       active_streams_.front().get());\n  return 0;\n}\n\nint ServerConnectionImpl::onHeader(const nghttp2_frame* frame, HeaderString&& name,\n                                   HeaderString&& value) {\n  // For a server connection, we should never get push promise frames.\n  ASSERT(frame->hd.type == NGHTTP2_HEADERS);\n  ASSERT(frame->headers.cat == NGHTTP2_HCAT_REQUEST || frame->headers.cat == NGHTTP2_HCAT_HEADERS);\n  return saveHeader(frame, std::move(name), std::move(value));\n}\n\nbool ServerConnectionImpl::trackInboundFrames(const nghttp2_frame_hd* hd, uint32_t padding_length) {\n  ENVOY_CONN_LOG(trace, \"track inbound frame type={} flags={} length={} padding_length={}\",\n                 connection_, static_cast<uint64_t>(hd->type), static_cast<uint64_t>(hd->flags),\n                 static_cast<uint64_t>(hd->length), padding_length);\n  switch (hd->type) {\n  case NGHTTP2_HEADERS:\n  case NGHTTP2_CONTINUATION:\n    // Track new streams.\n    if (hd->flags & NGHTTP2_FLAG_END_HEADERS) {\n      inbound_streams_++;\n    }\n    FALLTHRU;\n  case NGHTTP2_DATA:\n    // Track frames with an empty payload and no end stream flag.\n    if (hd->length - padding_length == 0 && !(hd->flags & NGHTTP2_FLAG_END_STREAM)) {\n      ENVOY_CONN_LOG(trace, \"frame with an empty payload and no end stream flag.\", connection_);\n      consecutive_inbound_frames_with_empty_payload_++;\n    } else {\n      consecutive_inbound_frames_with_empty_payload_ = 0;\n    }\n    break;\n  case NGHTTP2_PRIORITY:\n    inbound_priority_frames_++;\n    break;\n  case NGHTTP2_WINDOW_UPDATE:\n    inbound_window_update_frames_++;\n    break;\n  default:\n    break;\n  }\n\n  if (!checkInboundFrameLimits()) {\n    // NGHTTP2_ERR_FLOODED is overridden within nghttp2 library and it doesn't propagate\n    // all the way to nghttp2_session_mem_recv() where we need it.\n    flood_detected_ = true;\n    return false;\n  }\n\n  return true;\n}\n\nbool ServerConnectionImpl::checkInboundFrameLimits() {\n  ASSERT(dispatching_downstream_data_);\n\n  if (consecutive_inbound_frames_with_empty_payload_ >\n      max_consecutive_inbound_frames_with_empty_payload_) {\n    ENVOY_CONN_LOG(trace,\n                   \"error reading frame: Too many consecutive frames with an empty payload \"\n                   \"received in this HTTP/2 session.\",\n                   connection_);\n    stats_.inbound_empty_frames_flood_.inc();\n    return false;\n  }\n\n  if (inbound_priority_frames_ > max_inbound_priority_frames_per_stream_ * (1 + inbound_streams_)) {\n    ENVOY_CONN_LOG(trace,\n                   \"error reading frame: Too many PRIORITY frames received in this HTTP/2 session.\",\n                   connection_);\n    stats_.inbound_priority_frames_flood_.inc();\n    return false;\n  }\n\n  if (inbound_window_update_frames_ >\n      1 + 2 * (inbound_streams_ +\n               max_inbound_window_update_frames_per_data_frame_sent_ * outbound_data_frames_)) {\n    ENVOY_CONN_LOG(\n        trace,\n        \"error reading frame: Too many WINDOW_UPDATE frames received in this HTTP/2 session.\",\n        connection_);\n    stats_.inbound_window_update_frames_flood_.inc();\n    return false;\n  }\n\n  return true;\n}\n\nvoid ServerConnectionImpl::checkOutboundQueueLimits() {\n  if (outbound_frames_ > max_outbound_frames_ && dispatching_downstream_data_) {\n    stats_.outbound_flood_.inc();\n    throw FrameFloodException(\"Too many frames in the outbound queue.\");\n  }\n  if (outbound_control_frames_ > max_outbound_control_frames_ && dispatching_downstream_data_) {\n    stats_.outbound_control_flood_.inc();\n    throw FrameFloodException(\"Too many control frames in the outbound queue.\");\n  }\n}\n\nvoid ServerConnectionImpl::dispatch(Buffer::Instance& data) {\n  ASSERT(!dispatching_downstream_data_);\n  dispatching_downstream_data_ = true;\n\n  // Make sure the dispatching_downstream_data_ is set to false even\n  // when ConnectionImpl::dispatch throws an exception.\n  Cleanup cleanup([this]() { dispatching_downstream_data_ = false; });\n\n  // Make sure downstream outbound queue was not flooded by the upstream frames.\n  checkOutboundQueueLimits();\n\n  ConnectionImpl::dispatch(data);\n}\n\n} // namespace Http2\n} // namespace Http\n} // namespace Envoy\n", "#include \"common/router/router.h\"\n\n#include <chrono>\n#include <cstdint>\n#include <memory>\n#include <string>\n\n#include \"envoy/event/dispatcher.h\"\n#include \"envoy/event/timer.h\"\n#include \"envoy/grpc/status.h\"\n#include \"envoy/http/conn_pool.h\"\n#include \"envoy/runtime/runtime.h\"\n#include \"envoy/upstream/cluster_manager.h\"\n#include \"envoy/upstream/upstream.h\"\n\n#include \"common/common/assert.h\"\n#include \"common/common/empty_string.h\"\n#include \"common/common/enum_to_int.h\"\n#include \"common/common/scope_tracker.h\"\n#include \"common/common/utility.h\"\n#include \"common/grpc/common.h\"\n#include \"common/http/codes.h\"\n#include \"common/http/header_map_impl.h\"\n#include \"common/http/headers.h\"\n#include \"common/http/message_impl.h\"\n#include \"common/http/utility.h\"\n#include \"common/network/application_protocol.h\"\n#include \"common/network/transport_socket_options_impl.h\"\n#include \"common/router/config_impl.h\"\n#include \"common/router/debug_config.h\"\n#include \"common/router/retry_state_impl.h\"\n#include \"common/runtime/runtime_impl.h\"\n#include \"common/tracing/http_tracer_impl.h\"\n\n#include \"extensions/filters/http/well_known_names.h\"\n\nnamespace Envoy {\nnamespace Router {\nnamespace {\nuint32_t getLength(const Buffer::Instance* instance) { return instance ? instance->length() : 0; }\n\nbool schemeIsHttp(const Http::HeaderMap& downstream_headers,\n                  const Network::Connection& connection) {\n  if (downstream_headers.ForwardedProto() &&\n      downstream_headers.ForwardedProto()->value().getStringView() ==\n          Http::Headers::get().SchemeValues.Http) {\n    return true;\n  }\n  if (!connection.ssl()) {\n    return true;\n  }\n  return false;\n}\n\nbool convertRequestHeadersForInternalRedirect(Http::HeaderMap& downstream_headers,\n                                              const Http::HeaderEntry& internal_redirect,\n                                              const Network::Connection& connection) {\n  // Envoy does not currently support multiple rounds of redirects.\n  if (downstream_headers.EnvoyOriginalUrl()) {\n    return false;\n  }\n  // Make sure the redirect response contains a URL to redirect to.\n  if (internal_redirect.value().getStringView().length() == 0) {\n    return false;\n  }\n\n  Http::Utility::Url absolute_url;\n  if (!absolute_url.initialize(internal_redirect.value().getStringView())) {\n    return false;\n  }\n\n  bool scheme_is_http = schemeIsHttp(downstream_headers, connection);\n  if (scheme_is_http && absolute_url.scheme() == Http::Headers::get().SchemeValues.Https) {\n    // Don't allow serving TLS responses over plaintext.\n    return false;\n  }\n\n  // Preserve the original request URL for the second pass.\n  downstream_headers.insertEnvoyOriginalUrl().value(\n      absl::StrCat(scheme_is_http ? Http::Headers::get().SchemeValues.Http\n                                  : Http::Headers::get().SchemeValues.Https,\n                   \"://\", downstream_headers.Host()->value().getStringView(),\n                   downstream_headers.Path()->value().getStringView()));\n\n  // Replace the original host, scheme and path.\n  downstream_headers.insertScheme().value(std::string(absolute_url.scheme()));\n  downstream_headers.insertHost().value(std::string(absolute_url.host_and_port()));\n  downstream_headers.insertPath().value(std::string(absolute_url.path_and_query_params()));\n\n  return true;\n}\n\n} // namespace\n\nvoid FilterUtility::setUpstreamScheme(Http::HeaderMap& headers,\n                                      const Upstream::ClusterInfo& cluster) {\n  if (cluster.transportSocketFactory().implementsSecureTransport()) {\n    headers.insertScheme().value().setReference(Http::Headers::get().SchemeValues.Https);\n  } else {\n    headers.insertScheme().value().setReference(Http::Headers::get().SchemeValues.Http);\n  }\n}\n\nbool FilterUtility::shouldShadow(const ShadowPolicy& policy, Runtime::Loader& runtime,\n                                 uint64_t stable_random) {\n  if (policy.cluster().empty()) {\n    return false;\n  }\n\n  if (policy.defaultValue().numerator() > 0) {\n    return runtime.snapshot().featureEnabled(policy.runtimeKey(), policy.defaultValue(),\n                                             stable_random);\n  }\n\n  if (!policy.runtimeKey().empty() &&\n      !runtime.snapshot().featureEnabled(policy.runtimeKey(), 0, stable_random, 10000UL)) {\n    return false;\n  }\n\n  return true;\n}\n\nFilterUtility::TimeoutData\nFilterUtility::finalTimeout(const RouteEntry& route, Http::HeaderMap& request_headers,\n                            bool insert_envoy_expected_request_timeout_ms, bool grpc_request,\n                            bool per_try_timeout_hedging_enabled,\n                            bool respect_expected_rq_timeout) {\n  // See if there is a user supplied timeout in a request header. If there is we take that.\n  // Otherwise if the request is gRPC and a maximum gRPC timeout is configured we use the timeout\n  // in the gRPC headers (or infinity when gRPC headers have no timeout), but cap that timeout to\n  // the configured maximum gRPC timeout (which may also be infinity, represented by a 0 value),\n  // or the default from the route config otherwise.\n  TimeoutData timeout;\n  if (grpc_request && route.maxGrpcTimeout()) {\n    const std::chrono::milliseconds max_grpc_timeout = route.maxGrpcTimeout().value();\n    std::chrono::milliseconds grpc_timeout = Grpc::Common::getGrpcTimeout(request_headers);\n    if (route.grpcTimeoutOffset()) {\n      // We only apply the offset if it won't result in grpc_timeout hitting 0 or below, as\n      // setting it to 0 means infinity and a negative timeout makes no sense.\n      const auto offset = *route.grpcTimeoutOffset();\n      if (offset < grpc_timeout) {\n        grpc_timeout -= offset;\n      }\n    }\n\n    // Cap gRPC timeout to the configured maximum considering that 0 means infinity.\n    if (max_grpc_timeout != std::chrono::milliseconds(0) &&\n        (grpc_timeout == std::chrono::milliseconds(0) || grpc_timeout > max_grpc_timeout)) {\n      grpc_timeout = max_grpc_timeout;\n    }\n    timeout.global_timeout_ = grpc_timeout;\n  } else {\n    timeout.global_timeout_ = route.timeout();\n  }\n  timeout.per_try_timeout_ = route.retryPolicy().perTryTimeout();\n\n  uint64_t header_timeout;\n\n  if (respect_expected_rq_timeout) {\n    // Check if there is timeout set by egress Envoy.\n    // If present, use that value as route timeout and don't override\n    // *x-envoy-expected-rq-timeout-ms* header. At this point *x-envoy-upstream-rq-timeout-ms*\n    // header should have been sanitized by egress Envoy.\n    Http::HeaderEntry* header_expected_timeout_entry =\n        request_headers.EnvoyExpectedRequestTimeoutMs();\n    if (header_expected_timeout_entry) {\n      trySetGlobalTimeout(header_expected_timeout_entry, timeout);\n    } else {\n      Http::HeaderEntry* header_timeout_entry = request_headers.EnvoyUpstreamRequestTimeoutMs();\n\n      if (trySetGlobalTimeout(header_timeout_entry, timeout)) {\n        request_headers.removeEnvoyUpstreamRequestTimeoutMs();\n      }\n    }\n  } else {\n    Http::HeaderEntry* header_timeout_entry = request_headers.EnvoyUpstreamRequestTimeoutMs();\n    if (trySetGlobalTimeout(header_timeout_entry, timeout)) {\n      request_headers.removeEnvoyUpstreamRequestTimeoutMs();\n    }\n  }\n\n  // See if there is a per try/retry timeout. If it's >= global we just ignore it.\n  Http::HeaderEntry* per_try_timeout_entry = request_headers.EnvoyUpstreamRequestPerTryTimeoutMs();\n  if (per_try_timeout_entry) {\n    if (absl::SimpleAtoi(per_try_timeout_entry->value().getStringView(), &header_timeout)) {\n      timeout.per_try_timeout_ = std::chrono::milliseconds(header_timeout);\n    }\n    request_headers.removeEnvoyUpstreamRequestPerTryTimeoutMs();\n  }\n\n  if (timeout.per_try_timeout_ >= timeout.global_timeout_) {\n    timeout.per_try_timeout_ = std::chrono::milliseconds(0);\n  }\n\n  // See if there is any timeout to write in the expected timeout header.\n  uint64_t expected_timeout = timeout.per_try_timeout_.count();\n  // Use the global timeout if no per try timeout was specified or if we're\n  // doing hedging when there are per try timeouts. Either of these scenarios\n  // mean that the upstream server can use the full global timeout.\n  if (per_try_timeout_hedging_enabled || expected_timeout == 0) {\n    expected_timeout = timeout.global_timeout_.count();\n  }\n\n  if (insert_envoy_expected_request_timeout_ms && expected_timeout > 0) {\n    request_headers.insertEnvoyExpectedRequestTimeoutMs().value(expected_timeout);\n  }\n\n  // If we've configured max_grpc_timeout, override the grpc-timeout header with\n  // the expected timeout. This ensures that the optional per try timeout is reflected\n  // in grpc-timeout, ensuring that the upstream gRPC server is aware of the actual timeout.\n  // If the expected timeout is 0 set no timeout, as Envoy treats 0 as infinite timeout.\n  if (grpc_request && route.maxGrpcTimeout() && expected_timeout != 0) {\n    Grpc::Common::toGrpcTimeout(std::chrono::milliseconds(expected_timeout),\n                                request_headers.insertGrpcTimeout().value());\n  }\n\n  return timeout;\n}\n\nbool FilterUtility::trySetGlobalTimeout(const Http::HeaderEntry* header_timeout_entry,\n                                        TimeoutData& timeout) {\n  if (header_timeout_entry) {\n    uint64_t header_timeout;\n    if (absl::SimpleAtoi(header_timeout_entry->value().getStringView(), &header_timeout)) {\n      timeout.global_timeout_ = std::chrono::milliseconds(header_timeout);\n    }\n    return true;\n  }\n  return false;\n}\n\nFilterUtility::HedgingParams FilterUtility::finalHedgingParams(const RouteEntry& route,\n                                                               Http::HeaderMap& request_headers) {\n  HedgingParams hedging_params;\n  hedging_params.hedge_on_per_try_timeout_ = route.hedgePolicy().hedgeOnPerTryTimeout();\n\n  Http::HeaderEntry* hedge_on_per_try_timeout_entry = request_headers.EnvoyHedgeOnPerTryTimeout();\n  if (hedge_on_per_try_timeout_entry) {\n    if (hedge_on_per_try_timeout_entry->value() == \"true\") {\n      hedging_params.hedge_on_per_try_timeout_ = true;\n    }\n    if (hedge_on_per_try_timeout_entry->value() == \"false\") {\n      hedging_params.hedge_on_per_try_timeout_ = false;\n    }\n\n    request_headers.removeEnvoyHedgeOnPerTryTimeout();\n  }\n\n  return hedging_params;\n}\n\nFilter::~Filter() {\n  // Upstream resources should already have been cleaned.\n  ASSERT(upstream_requests_.empty());\n  ASSERT(!retry_state_);\n}\n\nconst FilterUtility::StrictHeaderChecker::HeaderCheckResult\nFilterUtility::StrictHeaderChecker::checkHeader(Http::HeaderMap& headers,\n                                                const Http::LowerCaseString& target_header) {\n  if (target_header == Http::Headers::get().EnvoyUpstreamRequestTimeoutMs) {\n    return isInteger(headers.EnvoyUpstreamRequestTimeoutMs());\n  } else if (target_header == Http::Headers::get().EnvoyUpstreamRequestPerTryTimeoutMs) {\n    return isInteger(headers.EnvoyUpstreamRequestPerTryTimeoutMs());\n  } else if (target_header == Http::Headers::get().EnvoyMaxRetries) {\n    return isInteger(headers.EnvoyMaxRetries());\n  } else if (target_header == Http::Headers::get().EnvoyRetryOn) {\n    return hasValidRetryFields(headers.EnvoyRetryOn(), &Router::RetryStateImpl::parseRetryOn);\n  } else if (target_header == Http::Headers::get().EnvoyRetryGrpcOn) {\n    return hasValidRetryFields(headers.EnvoyRetryGrpcOn(),\n                               &Router::RetryStateImpl::parseRetryGrpcOn);\n  }\n  // Should only validate headers for which we have implemented a validator.\n  NOT_REACHED_GCOVR_EXCL_LINE\n}\n\nStats::StatName Filter::upstreamZone(Upstream::HostDescriptionConstSharedPtr upstream_host) {\n  return upstream_host ? upstream_host->localityZoneStatName() : config_.empty_stat_name_;\n}\n\nvoid Filter::chargeUpstreamCode(uint64_t response_status_code,\n                                const Http::HeaderMap& response_headers,\n                                Upstream::HostDescriptionConstSharedPtr upstream_host,\n                                bool dropped) {\n  // Passing the response_status_code explicitly is an optimization to avoid\n  // multiple calls to slow Http::Utility::getResponseStatus.\n  ASSERT(response_status_code == Http::Utility::getResponseStatus(response_headers));\n  if (config_.emit_dynamic_stats_ && !callbacks_->streamInfo().healthCheck()) {\n    const Http::HeaderEntry* upstream_canary_header = response_headers.EnvoyUpstreamCanary();\n    const Http::HeaderEntry* internal_request_header = downstream_headers_->EnvoyInternalRequest();\n\n    const bool is_canary = (upstream_canary_header && upstream_canary_header->value() == \"true\") ||\n                           (upstream_host ? upstream_host->canary() : false);\n    const bool internal_request =\n        internal_request_header && internal_request_header->value() == \"true\";\n\n    Stats::StatName upstream_zone = upstreamZone(upstream_host);\n    Http::CodeStats::ResponseStatInfo info{config_.scope_,\n                                           cluster_->statsScope(),\n                                           config_.empty_stat_name_,\n                                           response_status_code,\n                                           internal_request,\n                                           route_entry_->virtualHost().statName(),\n                                           request_vcluster_ ? request_vcluster_->statName()\n                                                             : config_.empty_stat_name_,\n                                           config_.zone_name_,\n                                           upstream_zone,\n                                           is_canary};\n\n    Http::CodeStats& code_stats = httpContext().codeStats();\n    code_stats.chargeResponseStat(info);\n\n    if (alt_stat_prefix_ != nullptr) {\n      Http::CodeStats::ResponseStatInfo alt_info{config_.scope_,\n                                                 cluster_->statsScope(),\n                                                 alt_stat_prefix_->statName(),\n                                                 response_status_code,\n                                                 internal_request,\n                                                 config_.empty_stat_name_,\n                                                 config_.empty_stat_name_,\n                                                 config_.zone_name_,\n                                                 upstream_zone,\n                                                 is_canary};\n      code_stats.chargeResponseStat(alt_info);\n    }\n\n    if (dropped) {\n      cluster_->loadReportStats().upstream_rq_dropped_.inc();\n    }\n    if (upstream_host && Http::CodeUtility::is5xx(response_status_code)) {\n      upstream_host->stats().rq_error_.inc();\n    }\n  }\n}\n\nvoid Filter::chargeUpstreamCode(Http::Code code,\n                                Upstream::HostDescriptionConstSharedPtr upstream_host,\n                                bool dropped) {\n  const uint64_t response_status_code = enumToInt(code);\n  Http::HeaderMapImpl fake_response_headers{\n      {Http::Headers::get().Status, std::to_string(response_status_code)}};\n  chargeUpstreamCode(response_status_code, fake_response_headers, upstream_host, dropped);\n}\n\nHttp::FilterHeadersStatus Filter::decodeHeaders(Http::HeaderMap& headers, bool end_stream) {\n  // Do a common header check. We make sure that all outgoing requests have all HTTP/2 headers.\n  // These get stripped by HTTP/1 codec where applicable.\n  ASSERT(headers.Path());\n  ASSERT(headers.Method());\n  ASSERT(headers.Host());\n\n  downstream_headers_ = &headers;\n\n  // Extract debug configuration from filter state. This is used further along to determine whether\n  // we should append cluster and host headers to the response, and whether to forward the request\n  // upstream.\n  const StreamInfo::FilterState& filter_state = callbacks_->streamInfo().filterState();\n  const DebugConfig* debug_config =\n      filter_state.hasData<DebugConfig>(DebugConfig::key())\n          ? &(filter_state.getDataReadOnly<DebugConfig>(DebugConfig::key()))\n          : nullptr;\n\n  // TODO: Maybe add a filter API for this.\n  grpc_request_ = Grpc::Common::hasGrpcContentType(headers);\n\n  // Only increment rq total stat if we actually decode headers here. This does not count requests\n  // that get handled by earlier filters.\n  config_.stats_.rq_total_.inc();\n\n  // Initialize the `modify_headers` function as a no-op (so we don't have to remember to check it\n  // against nullptr before calling it), and feed it behavior later if/when we have cluster info\n  // headers to append.\n  std::function<void(Http::HeaderMap&)> modify_headers = [](Http::HeaderMap&) {};\n\n  // Determine if there is a route entry or a direct response for the request.\n  route_ = callbacks_->route();\n  if (!route_) {\n    config_.stats_.no_route_.inc();\n    ENVOY_STREAM_LOG(debug, \"no cluster match for URL '{}'\", *callbacks_,\n                     headers.Path()->value().getStringView());\n\n    callbacks_->streamInfo().setResponseFlag(StreamInfo::ResponseFlag::NoRouteFound);\n    callbacks_->sendLocalReply(Http::Code::NotFound, \"\", modify_headers, absl::nullopt,\n                               StreamInfo::ResponseCodeDetails::get().RouteNotFound);\n    return Http::FilterHeadersStatus::StopIteration;\n  }\n\n  // Determine if there is a direct response for the request.\n  const auto* direct_response = route_->directResponseEntry();\n  if (direct_response != nullptr) {\n    config_.stats_.rq_direct_response_.inc();\n    direct_response->rewritePathHeader(headers, !config_.suppress_envoy_headers_);\n    callbacks_->sendLocalReply(\n        direct_response->responseCode(), direct_response->responseBody(),\n        [this, direct_response,\n         &request_headers = headers](Http::HeaderMap& response_headers) -> void {\n          const auto new_path = direct_response->newPath(request_headers);\n          if (!new_path.empty()) {\n            response_headers.addReferenceKey(Http::Headers::get().Location, new_path);\n          }\n          direct_response->finalizeResponseHeaders(response_headers, callbacks_->streamInfo());\n        },\n        absl::nullopt, StreamInfo::ResponseCodeDetails::get().DirectResponse);\n    callbacks_->streamInfo().setRouteName(direct_response->routeName());\n    return Http::FilterHeadersStatus::StopIteration;\n  }\n\n  // A route entry matches for the request.\n  route_entry_ = route_->routeEntry();\n  callbacks_->streamInfo().setRouteName(route_entry_->routeName());\n  if (debug_config && debug_config->append_cluster_) {\n    // The cluster name will be appended to any local or upstream responses from this point.\n    modify_headers = [this, debug_config](Http::HeaderMap& headers) {\n      headers.addCopy(debug_config->cluster_header_.value_or(Http::Headers::get().EnvoyCluster),\n                      route_entry_->clusterName());\n    };\n  }\n  Upstream::ThreadLocalCluster* cluster = config_.cm_.get(route_entry_->clusterName());\n  if (!cluster) {\n    config_.stats_.no_cluster_.inc();\n    ENVOY_STREAM_LOG(debug, \"unknown cluster '{}'\", *callbacks_, route_entry_->clusterName());\n\n    callbacks_->streamInfo().setResponseFlag(StreamInfo::ResponseFlag::NoRouteFound);\n    callbacks_->sendLocalReply(route_entry_->clusterNotFoundResponseCode(), \"\", modify_headers,\n                               absl::nullopt,\n                               StreamInfo::ResponseCodeDetails::get().ClusterNotFound);\n    return Http::FilterHeadersStatus::StopIteration;\n  }\n  cluster_ = cluster->info();\n\n  // Set up stat prefixes, etc.\n  request_vcluster_ = route_entry_->virtualCluster(headers);\n  ENVOY_STREAM_LOG(debug, \"cluster '{}' match for URL '{}'\", *callbacks_,\n                   route_entry_->clusterName(), headers.Path()->value().getStringView());\n\n  if (config_.strict_check_headers_ != nullptr) {\n    for (const auto& header : *config_.strict_check_headers_) {\n      const auto res = FilterUtility::StrictHeaderChecker::checkHeader(headers, header);\n      if (!res.valid_) {\n        callbacks_->streamInfo().setResponseFlag(\n            StreamInfo::ResponseFlag::InvalidEnvoyRequestHeaders);\n        const std::string body = fmt::format(\"invalid header '{}' with value '{}'\",\n                                             std::string(res.entry_->key().getStringView()),\n                                             std::string(res.entry_->value().getStringView()));\n        const std::string details =\n            absl::StrCat(StreamInfo::ResponseCodeDetails::get().InvalidEnvoyRequestHeaders, \"{\",\n                         res.entry_->key().getStringView(), \"}\");\n        callbacks_->sendLocalReply(Http::Code::BadRequest, body, nullptr, absl::nullopt, details);\n        return Http::FilterHeadersStatus::StopIteration;\n      }\n    }\n  }\n\n  const Http::HeaderEntry* request_alt_name = headers.EnvoyUpstreamAltStatName();\n  if (request_alt_name) {\n    // TODO(#7003): converting this header value into a StatName requires\n    // taking a global symbol-table lock. This is not a frequently used feature,\n    // but may not be the only occurrence of this pattern, where it's difficult\n    // or impossible to pre-compute a StatName for a component of a stat name.\n    alt_stat_prefix_ = std::make_unique<Stats::StatNameManagedStorage>(\n        request_alt_name->value().getStringView(), config_.scope_.symbolTable());\n    headers.removeEnvoyUpstreamAltStatName();\n  }\n\n  // See if we are supposed to immediately kill some percentage of this cluster's traffic.\n  if (cluster_->maintenanceMode()) {\n    callbacks_->streamInfo().setResponseFlag(StreamInfo::ResponseFlag::UpstreamOverflow);\n    chargeUpstreamCode(Http::Code::ServiceUnavailable, nullptr, true);\n    callbacks_->sendLocalReply(\n        Http::Code::ServiceUnavailable, \"maintenance mode\",\n        [modify_headers, this](Http::HeaderMap& headers) {\n          if (!config_.suppress_envoy_headers_) {\n            headers.insertEnvoyOverloaded().value(Http::Headers::get().EnvoyOverloadedValues.True);\n          }\n          // Note: append_cluster_info does not respect suppress_envoy_headers.\n          modify_headers(headers);\n        },\n        absl::nullopt, StreamInfo::ResponseCodeDetails::get().MaintenanceMode);\n    cluster_->stats().upstream_rq_maintenance_mode_.inc();\n    return Http::FilterHeadersStatus::StopIteration;\n  }\n\n  // Fetch a connection pool for the upstream cluster.\n  Http::ConnectionPool::Instance* conn_pool = getConnPool();\n  if (!conn_pool) {\n    sendNoHealthyUpstreamResponse();\n    return Http::FilterHeadersStatus::StopIteration;\n  }\n  if (debug_config && debug_config->append_upstream_host_) {\n    // The hostname and address will be appended to any local or upstream responses from this point,\n    // possibly in addition to the cluster name.\n    modify_headers = [modify_headers, debug_config, conn_pool](Http::HeaderMap& headers) {\n      modify_headers(headers);\n      headers.addCopy(\n          debug_config->hostname_header_.value_or(Http::Headers::get().EnvoyUpstreamHostname),\n          conn_pool->host()->hostname());\n      headers.addCopy(debug_config->host_address_header_.value_or(\n                          Http::Headers::get().EnvoyUpstreamHostAddress),\n                      conn_pool->host()->address()->asString());\n    };\n  }\n\n  // If we've been instructed not to forward the request upstream, send an empty local response.\n  if (debug_config && debug_config->do_not_forward_) {\n    modify_headers = [modify_headers, debug_config](Http::HeaderMap& headers) {\n      modify_headers(headers);\n      headers.addCopy(\n          debug_config->not_forwarded_header_.value_or(Http::Headers::get().EnvoyNotForwarded),\n          \"true\");\n    };\n    callbacks_->sendLocalReply(Http::Code::NoContent, \"\", modify_headers, absl::nullopt, \"\");\n    return Http::FilterHeadersStatus::StopIteration;\n  }\n\n  hedging_params_ = FilterUtility::finalHedgingParams(*route_entry_, headers);\n\n  timeout_ = FilterUtility::finalTimeout(*route_entry_, headers, !config_.suppress_envoy_headers_,\n                                         grpc_request_, hedging_params_.hedge_on_per_try_timeout_,\n                                         config_.respect_expected_rq_timeout_);\n\n  // If this header is set with any value, use an alternate response code on timeout\n  if (headers.EnvoyUpstreamRequestTimeoutAltResponse()) {\n    timeout_response_code_ = Http::Code::NoContent;\n    headers.removeEnvoyUpstreamRequestTimeoutAltResponse();\n  }\n\n  include_attempt_count_ = route_entry_->includeAttemptCount();\n  if (include_attempt_count_) {\n    headers.insertEnvoyAttemptCount().value(attempt_count_);\n  }\n\n  // Inject the active span's tracing context into the request headers.\n  callbacks_->activeSpan().injectContext(headers);\n\n  route_entry_->finalizeRequestHeaders(headers, callbacks_->streamInfo(),\n                                       !config_.suppress_envoy_headers_);\n  FilterUtility::setUpstreamScheme(headers, *cluster_);\n\n  // Ensure an http transport scheme is selected before continuing with decoding.\n  ASSERT(headers.Scheme());\n\n  retry_state_ =\n      createRetryState(route_entry_->retryPolicy(), headers, *cluster_, config_.runtime_,\n                       config_.random_, callbacks_->dispatcher(), route_entry_->priority());\n  do_shadowing_ = FilterUtility::shouldShadow(route_entry_->shadowPolicy(), config_.runtime_,\n                                              callbacks_->streamId());\n\n  ENVOY_STREAM_LOG(debug, \"router decoding headers:\\n{}\", *callbacks_, headers);\n\n  // Hang onto the modify_headers function for later use in handling upstream responses.\n  modify_headers_ = modify_headers;\n\n  UpstreamRequestPtr upstream_request = std::make_unique<UpstreamRequest>(*this, *conn_pool);\n  upstream_request->moveIntoList(std::move(upstream_request), upstream_requests_);\n  upstream_requests_.front()->encodeHeaders(end_stream);\n  if (end_stream) {\n    onRequestComplete();\n  }\n\n  return Http::FilterHeadersStatus::StopIteration;\n}\n\nHttp::ConnectionPool::Instance* Filter::getConnPool() {\n  // Choose protocol based on cluster configuration and downstream connection\n  // Note: Cluster may downgrade HTTP2 to HTTP1 based on runtime configuration.\n  auto features = cluster_->features();\n\n  Http::Protocol protocol;\n  if (features & Upstream::ClusterInfo::Features::USE_DOWNSTREAM_PROTOCOL) {\n    protocol = callbacks_->streamInfo().protocol().value();\n  } else {\n    protocol = (features & Upstream::ClusterInfo::Features::HTTP2) ? Http::Protocol::Http2\n                                                                   : Http::Protocol::Http11;\n  }\n\n  if (callbacks_->streamInfo().filterState().hasData<Network::ApplicationProtocols>(\n          Network::ApplicationProtocols::key())) {\n    const auto& alpn =\n        callbacks_->streamInfo().filterState().getDataReadOnly<Network::ApplicationProtocols>(\n            Network::ApplicationProtocols::key());\n    transport_socket_options_ = std::make_shared<Network::TransportSocketOptionsImpl>(\n        \"\", std::vector<std::string>{}, std::vector<std::string>{alpn.value()});\n  }\n\n  return config_.cm_.httpConnPoolForCluster(route_entry_->clusterName(), route_entry_->priority(),\n                                            protocol, this);\n}\n\nvoid Filter::sendNoHealthyUpstreamResponse() {\n  callbacks_->streamInfo().setResponseFlag(StreamInfo::ResponseFlag::NoHealthyUpstream);\n  chargeUpstreamCode(Http::Code::ServiceUnavailable, nullptr, false);\n  callbacks_->sendLocalReply(Http::Code::ServiceUnavailable, \"no healthy upstream\", modify_headers_,\n                             absl::nullopt,\n                             StreamInfo::ResponseCodeDetails::get().NoHealthyUpstream);\n}\n\nHttp::FilterDataStatus Filter::decodeData(Buffer::Instance& data, bool end_stream) {\n  // upstream_requests_.size() cannot be 0 because we add to it unconditionally\n  // in decodeHeaders(). It cannot be > 1 because that only happens when a per\n  // try timeout occurs with hedge_on_per_try_timeout enabled but the per\n  // try timeout timer is not started until onUpstreamComplete().\n  ASSERT(upstream_requests_.size() == 1);\n\n  bool buffering = (retry_state_ && retry_state_->enabled()) || do_shadowing_;\n  if (buffering && buffer_limit_ > 0 &&\n      getLength(callbacks_->decodingBuffer()) + data.length() > buffer_limit_) {\n    // The request is larger than we should buffer. Give up on the retry/shadow\n    cluster_->stats().retry_or_shadow_abandoned_.inc();\n    retry_state_.reset();\n    buffering = false;\n    do_shadowing_ = false;\n  }\n\n  if (buffering) {\n    // If we are going to buffer for retries or shadowing, we need to make a copy before encoding\n    // since it's all moves from here on.\n    Buffer::OwnedImpl copy(data);\n    upstream_requests_.front()->encodeData(copy, end_stream);\n\n    // If we are potentially going to retry or shadow this request we need to buffer.\n    // This will not cause the connection manager to 413 because before we hit the\n    // buffer limit we give up on retries and buffering. We must buffer using addDecodedData()\n    // so that all buffered data is available by the time we do request complete processing and\n    // potentially shadow.\n    callbacks_->addDecodedData(data, true);\n  } else {\n    upstream_requests_.front()->encodeData(data, end_stream);\n  }\n\n  if (end_stream) {\n    onRequestComplete();\n  }\n\n  return Http::FilterDataStatus::StopIterationNoBuffer;\n}\n\nHttp::FilterTrailersStatus Filter::decodeTrailers(Http::HeaderMap& trailers) {\n  ENVOY_STREAM_LOG(debug, \"router decoding trailers:\\n{}\", *callbacks_, trailers);\n\n  // upstream_requests_.size() cannot be 0 because we add to it unconditionally\n  // in decodeHeaders(). It cannot be > 1 because that only happens when a per\n  // try timeout occurs with hedge_on_per_try_timeout enabled but the per\n  // try timeout timer is not started until onUpstreamComplete().\n  ASSERT(upstream_requests_.size() == 1);\n  downstream_trailers_ = &trailers;\n  for (auto& upstream_request : upstream_requests_) {\n    upstream_request->encodeTrailers(trailers);\n  }\n  onRequestComplete();\n  return Http::FilterTrailersStatus::StopIteration;\n}\n\nHttp::FilterMetadataStatus Filter::decodeMetadata(Http::MetadataMap& metadata_map) {\n  Http::MetadataMapPtr metadata_map_ptr = std::make_unique<Http::MetadataMap>(metadata_map);\n  ASSERT(upstream_requests_.size() == 1);\n  upstream_requests_.front()->encodeMetadata(std::move(metadata_map_ptr));\n  return Http::FilterMetadataStatus::Continue;\n}\n\nvoid Filter::setDecoderFilterCallbacks(Http::StreamDecoderFilterCallbacks& callbacks) {\n  callbacks_ = &callbacks;\n  // As the decoder filter only pushes back via watermarks once data has reached\n  // it, it can latch the current buffer limit and does not need to update the\n  // limit if another filter increases it.\n  buffer_limit_ = callbacks_->decoderBufferLimit();\n}\n\nvoid Filter::cleanup() {\n  // All callers of cleanup() should have cleaned out the upstream_requests_\n  // list as appropriate.\n  ASSERT(upstream_requests_.empty());\n\n  retry_state_.reset();\n  if (response_timeout_) {\n    response_timeout_->disableTimer();\n    response_timeout_.reset();\n  }\n}\n\nvoid Filter::maybeDoShadowing() {\n  if (!do_shadowing_) {\n    return;\n  }\n\n  ASSERT(!route_entry_->shadowPolicy().cluster().empty());\n  Http::MessagePtr request(new Http::RequestMessageImpl(\n      Http::HeaderMapPtr{new Http::HeaderMapImpl(*downstream_headers_)}));\n  if (callbacks_->decodingBuffer()) {\n    request->body() = std::make_unique<Buffer::OwnedImpl>(*callbacks_->decodingBuffer());\n  }\n  if (downstream_trailers_) {\n    request->trailers(Http::HeaderMapPtr{new Http::HeaderMapImpl(*downstream_trailers_)});\n  }\n\n  config_.shadowWriter().shadow(route_entry_->shadowPolicy().cluster(), std::move(request),\n                                timeout_.global_timeout_);\n}\n\nvoid Filter::onRequestComplete() {\n  // This should be called exactly once, when the downstream request has been received in full.\n  ASSERT(!downstream_end_stream_);\n  downstream_end_stream_ = true;\n  Event::Dispatcher& dispatcher = callbacks_->dispatcher();\n  downstream_request_complete_time_ = dispatcher.timeSource().monotonicTime();\n\n  // Possible that we got an immediate reset.\n  if (!upstream_requests_.empty()) {\n    // Even if we got an immediate reset, we could still shadow, but that is a riskier change and\n    // seems unnecessary right now.\n    maybeDoShadowing();\n\n    if (timeout_.global_timeout_.count() > 0) {\n      response_timeout_ = dispatcher.createTimer([this]() -> void { onResponseTimeout(); });\n      response_timeout_->enableTimer(timeout_.global_timeout_);\n    }\n\n    for (auto& upstream_request : upstream_requests_) {\n      if (upstream_request->create_per_try_timeout_on_request_complete_) {\n        upstream_request->setupPerTryTimeout();\n      }\n    }\n  }\n}\n\nvoid Filter::onDestroy() {\n  // Reset any in-flight upstream requests.\n  resetAll();\n  cleanup();\n}\n\nvoid Filter::onResponseTimeout() {\n  ENVOY_STREAM_LOG(debug, \"upstream timeout\", *callbacks_);\n\n  // If we had an upstream request that got a \"good\" response, save its\n  // upstream timing information into the downstream stream info.\n  if (final_upstream_request_) {\n    callbacks_->streamInfo().setUpstreamTiming(final_upstream_request_->upstream_timing_);\n  }\n\n  // Reset any upstream requests that are still in flight.\n  while (!upstream_requests_.empty()) {\n    UpstreamRequestPtr upstream_request =\n        upstream_requests_.back()->removeFromList(upstream_requests_);\n\n    // Don't record a timeout for upstream requests we've already seen headers\n    // for.\n    if (upstream_request->awaiting_headers_) {\n      cluster_->stats().upstream_rq_timeout_.inc();\n      if (upstream_request->upstream_host_) {\n        upstream_request->upstream_host_->stats().rq_timeout_.inc();\n      }\n\n      // If this upstream request already hit a \"soft\" timeout, then it\n      // already recorded a timeout into outlier detection. Don't do it again.\n      if (!upstream_request->outlier_detection_timeout_recorded_) {\n        updateOutlierDetection(Upstream::Outlier::Result::LOCAL_ORIGIN_TIMEOUT, *upstream_request,\n                               absl::optional<uint64_t>(enumToInt(timeout_response_code_)));\n      }\n\n      chargeUpstreamAbort(timeout_response_code_, false, *upstream_request);\n    }\n    upstream_request->resetStream();\n  }\n\n  onUpstreamTimeoutAbort(StreamInfo::ResponseFlag::UpstreamRequestTimeout,\n                         StreamInfo::ResponseCodeDetails::get().UpstreamTimeout);\n}\n\n// Called when the per try timeout is hit but we didn't reset the request\n// (hedge_on_per_try_timeout enabled).\nvoid Filter::onSoftPerTryTimeout(UpstreamRequest& upstream_request) {\n  // Track this as a timeout for outlier detection purposes even though we didn't\n  // cancel the request yet and might get a 2xx later.\n  updateOutlierDetection(Upstream::Outlier::Result::LOCAL_ORIGIN_TIMEOUT, upstream_request,\n                         absl::optional<uint64_t>(enumToInt(timeout_response_code_)));\n  upstream_request.outlier_detection_timeout_recorded_ = true;\n\n  if (!downstream_response_started_ && retry_state_) {\n    RetryStatus retry_status =\n        retry_state_->shouldHedgeRetryPerTryTimeout([this]() -> void { doRetry(); });\n\n    if (retry_status == RetryStatus::Yes && setupRetry()) {\n      setupRetry();\n      // Don't increment upstream_host->stats().rq_error_ here, we'll do that\n      // later if 1) we hit global timeout or 2) we get bad response headers\n      // back.\n      upstream_request.retried_ = true;\n\n      // TODO: cluster stat for hedge attempted.\n    } else if (retry_status == RetryStatus::NoOverflow) {\n      callbacks_->streamInfo().setResponseFlag(StreamInfo::ResponseFlag::UpstreamOverflow);\n    } else if (retry_status == RetryStatus::NoRetryLimitExceeded) {\n      callbacks_->streamInfo().setResponseFlag(\n          StreamInfo::ResponseFlag::UpstreamRetryLimitExceeded);\n    }\n  }\n}\n\nvoid Filter::onPerTryTimeout(UpstreamRequest& upstream_request) {\n  if (hedging_params_.hedge_on_per_try_timeout_) {\n    onSoftPerTryTimeout(upstream_request);\n    return;\n  }\n\n  cluster_->stats().upstream_rq_per_try_timeout_.inc();\n  if (upstream_request.upstream_host_) {\n    upstream_request.upstream_host_->stats().rq_timeout_.inc();\n  }\n\n  upstream_request.resetStream();\n\n  updateOutlierDetection(Upstream::Outlier::Result::LOCAL_ORIGIN_TIMEOUT, upstream_request,\n                         absl::optional<uint64_t>(enumToInt(timeout_response_code_)));\n\n  if (maybeRetryReset(Http::StreamResetReason::LocalReset, upstream_request)) {\n    return;\n  }\n\n  chargeUpstreamAbort(timeout_response_code_, false, upstream_request);\n\n  // Remove this upstream request from the list now that we're done with it.\n  upstream_request.removeFromList(upstream_requests_);\n  onUpstreamTimeoutAbort(StreamInfo::ResponseFlag::UpstreamRequestTimeout,\n                         StreamInfo::ResponseCodeDetails::get().UpstreamPerTryTimeout);\n}\n\nvoid Filter::updateOutlierDetection(Upstream::Outlier::Result result,\n                                    UpstreamRequest& upstream_request,\n                                    absl::optional<uint64_t> code) {\n  if (upstream_request.upstream_host_) {\n    upstream_request.upstream_host_->outlierDetector().putResult(result, code);\n  }\n}\n\nvoid Filter::chargeUpstreamAbort(Http::Code code, bool dropped, UpstreamRequest& upstream_request) {\n  if (downstream_response_started_) {\n    if (upstream_request.grpc_rq_success_deferred_) {\n      upstream_request.upstream_host_->stats().rq_error_.inc();\n      config_.stats_.rq_reset_after_downstream_response_started_.inc();\n    }\n  } else {\n    Upstream::HostDescriptionConstSharedPtr upstream_host = upstream_request.upstream_host_;\n\n    chargeUpstreamCode(code, upstream_host, dropped);\n    // If we had non-5xx but still have been reset by backend or timeout before\n    // starting response, we treat this as an error. We only get non-5xx when\n    // timeout_response_code_ is used for code above, where this member can\n    // assume values such as 204 (NoContent).\n    if (upstream_host != nullptr && !Http::CodeUtility::is5xx(enumToInt(code))) {\n      upstream_host->stats().rq_error_.inc();\n    }\n  }\n}\n\nvoid Filter::onUpstreamTimeoutAbort(StreamInfo::ResponseFlag response_flags,\n                                    absl::string_view details) {\n  const absl::string_view body =\n      timeout_response_code_ == Http::Code::GatewayTimeout ? \"upstream request timeout\" : \"\";\n  onUpstreamAbort(timeout_response_code_, response_flags, body, false, details);\n}\n\nvoid Filter::onUpstreamAbort(Http::Code code, StreamInfo::ResponseFlag response_flags,\n                             absl::string_view body, bool dropped, absl::string_view details) {\n  // If we have not yet sent anything downstream, send a response with an appropriate status code.\n  // Otherwise just reset the ongoing response.\n  if (downstream_response_started_) {\n    // This will destroy any created retry timers.\n    callbacks_->streamInfo().setResponseCodeDetails(details);\n    cleanup();\n    callbacks_->resetStream();\n  } else {\n    // This will destroy any created retry timers.\n    cleanup();\n\n    callbacks_->streamInfo().setResponseFlag(response_flags);\n\n    callbacks_->sendLocalReply(\n        code, body,\n        [dropped, this](Http::HeaderMap& headers) {\n          if (dropped && !config_.suppress_envoy_headers_) {\n            headers.insertEnvoyOverloaded().value(Http::Headers::get().EnvoyOverloadedValues.True);\n          }\n          modify_headers_(headers);\n        },\n        absl::nullopt, details);\n  }\n}\n\nbool Filter::maybeRetryReset(Http::StreamResetReason reset_reason,\n                             UpstreamRequest& upstream_request) {\n  // We don't retry if we already started the response, don't have a retry policy defined,\n  // or if we've already retried this upstream request (currently only possible if a per\n  // try timeout occurred and hedge_on_per_try_timeout is enabled).\n  if (downstream_response_started_ || !retry_state_ || upstream_request.retried_) {\n    return false;\n  }\n\n  const RetryStatus retry_status =\n      retry_state_->shouldRetryReset(reset_reason, [this]() -> void { doRetry(); });\n  if (retry_status == RetryStatus::Yes && setupRetry()) {\n    if (upstream_request.upstream_host_) {\n      upstream_request.upstream_host_->stats().rq_error_.inc();\n    }\n    upstream_request.removeFromList(upstream_requests_);\n    return true;\n  } else if (retry_status == RetryStatus::NoOverflow) {\n    callbacks_->streamInfo().setResponseFlag(StreamInfo::ResponseFlag::UpstreamOverflow);\n  } else if (retry_status == RetryStatus::NoRetryLimitExceeded) {\n    callbacks_->streamInfo().setResponseFlag(StreamInfo::ResponseFlag::UpstreamRetryLimitExceeded);\n  }\n\n  return false;\n}\n\nvoid Filter::onUpstreamReset(Http::StreamResetReason reset_reason,\n                             absl::string_view transport_failure_reason,\n                             UpstreamRequest& upstream_request) {\n  ENVOY_STREAM_LOG(debug, \"upstream reset: reset reason {}\", *callbacks_,\n                   Http::Utility::resetReasonToString(reset_reason));\n\n  // TODO: The reset may also come from upstream over the wire. In this case it should be\n  // treated as external origin error and distinguished from local origin error.\n  // This matters only when running OutlierDetection with split_external_local_origin_errors config\n  // param set to true.\n  updateOutlierDetection(Upstream::Outlier::Result::LOCAL_ORIGIN_CONNECT_FAILED, upstream_request,\n                         absl::nullopt);\n\n  if (maybeRetryReset(reset_reason, upstream_request)) {\n    return;\n  }\n\n  const bool dropped = reset_reason == Http::StreamResetReason::Overflow;\n  chargeUpstreamAbort(Http::Code::ServiceUnavailable, dropped, upstream_request);\n  upstream_request.removeFromList(upstream_requests_);\n\n  // If there are other in-flight requests that might see an upstream response,\n  // don't return anything downstream.\n  if (numRequestsAwaitingHeaders() > 0 || pending_retries_ > 0) {\n    return;\n  }\n\n  const StreamInfo::ResponseFlag response_flags = streamResetReasonToResponseFlag(reset_reason);\n  const std::string body =\n      absl::StrCat(\"upstream connect error or disconnect/reset before headers. reset reason: \",\n                   Http::Utility::resetReasonToString(reset_reason));\n\n  callbacks_->streamInfo().setUpstreamTransportFailureReason(transport_failure_reason);\n  const std::string& basic_details =\n      downstream_response_started_ ? StreamInfo::ResponseCodeDetails::get().LateUpstreamReset\n                                   : StreamInfo::ResponseCodeDetails::get().EarlyUpstreamReset;\n  const std::string details = absl::StrCat(\n      basic_details, \"{\", Http::Utility::resetReasonToString(reset_reason),\n      transport_failure_reason.empty() ? \"\" : absl::StrCat(\",\", transport_failure_reason), \"}\");\n  onUpstreamAbort(Http::Code::ServiceUnavailable, response_flags, body, dropped, details);\n}\n\nStreamInfo::ResponseFlag\nFilter::streamResetReasonToResponseFlag(Http::StreamResetReason reset_reason) {\n  switch (reset_reason) {\n  case Http::StreamResetReason::ConnectionFailure:\n    return StreamInfo::ResponseFlag::UpstreamConnectionFailure;\n  case Http::StreamResetReason::ConnectionTermination:\n    return StreamInfo::ResponseFlag::UpstreamConnectionTermination;\n  case Http::StreamResetReason::LocalReset:\n  case Http::StreamResetReason::LocalRefusedStreamReset:\n    return StreamInfo::ResponseFlag::LocalReset;\n  case Http::StreamResetReason::Overflow:\n    return StreamInfo::ResponseFlag::UpstreamOverflow;\n  case Http::StreamResetReason::RemoteReset:\n  case Http::StreamResetReason::RemoteRefusedStreamReset:\n    return StreamInfo::ResponseFlag::UpstreamRemoteReset;\n  }\n\n  NOT_REACHED_GCOVR_EXCL_LINE;\n}\n\nvoid Filter::handleNon5xxResponseHeaders(absl::optional<Grpc::Status::GrpcStatus> grpc_status,\n                                         UpstreamRequest& upstream_request, bool end_stream,\n                                         uint64_t grpc_to_http_status) {\n  // We need to defer gRPC success until after we have processed grpc-status in\n  // the trailers.\n  if (grpc_request_) {\n    if (end_stream) {\n      if (grpc_status && !Http::CodeUtility::is5xx(grpc_to_http_status)) {\n        upstream_request.upstream_host_->stats().rq_success_.inc();\n      } else {\n        upstream_request.upstream_host_->stats().rq_error_.inc();\n      }\n    } else {\n      upstream_request.grpc_rq_success_deferred_ = true;\n    }\n  } else {\n    upstream_request.upstream_host_->stats().rq_success_.inc();\n  }\n}\n\nvoid Filter::onUpstream100ContinueHeaders(Http::HeaderMapPtr&& headers,\n                                          UpstreamRequest& upstream_request) {\n  chargeUpstreamCode(100, *headers, upstream_request.upstream_host_, false);\n  ENVOY_STREAM_LOG(debug, \"upstream 100 continue\", *callbacks_);\n\n  downstream_response_started_ = true;\n  final_upstream_request_ = &upstream_request;\n  resetOtherUpstreams(upstream_request);\n\n  // Don't send retries after 100-Continue has been sent on. Arguably we could attempt to do a\n  // retry, assume the next upstream would also send an 100-Continue and swallow the second one\n  // but it's sketchy (as the subsequent upstream might not send a 100-Continue) and not worth\n  // the complexity until someone asks for it.\n  retry_state_.reset();\n\n  callbacks_->encode100ContinueHeaders(std::move(headers));\n}\n\nvoid Filter::resetAll() {\n  while (!upstream_requests_.empty()) {\n    upstream_requests_.back()->removeFromList(upstream_requests_)->resetStream();\n  }\n}\n\nvoid Filter::resetOtherUpstreams(UpstreamRequest& upstream_request) {\n  // Pop each upstream request on the list and reset it if it's not the one\n  // provided. At the end we'll move it back into the list.\n  UpstreamRequestPtr final_upstream_request;\n  while (!upstream_requests_.empty()) {\n    UpstreamRequestPtr upstream_request_tmp =\n        upstream_requests_.back()->removeFromList(upstream_requests_);\n    if (upstream_request_tmp.get() != &upstream_request) {\n      upstream_request_tmp->resetStream();\n      // TODO: per-host stat for hedge abandoned.\n      // TODO: cluster stat for hedge abandoned.\n    } else {\n      final_upstream_request = std::move(upstream_request_tmp);\n    }\n  }\n\n  ASSERT(final_upstream_request);\n  // Now put the final request back on this list.\n  final_upstream_request->moveIntoList(std::move(final_upstream_request), upstream_requests_);\n}\n\nvoid Filter::onUpstreamHeaders(uint64_t response_code, Http::HeaderMapPtr&& headers,\n                               UpstreamRequest& upstream_request, bool end_stream) {\n  ENVOY_STREAM_LOG(debug, \"upstream headers complete: end_stream={}\", *callbacks_, end_stream);\n\n  modify_headers_(*headers);\n  // When grpc-status appears in response headers, convert grpc-status to HTTP status code\n  // for outlier detection. This does not currently change any stats or logging and does not\n  // handle the case when an error grpc-status is sent as a trailer.\n  absl::optional<Grpc::Status::GrpcStatus> grpc_status;\n  uint64_t grpc_to_http_status = 0;\n  if (grpc_request_) {\n    grpc_status = Grpc::Common::getGrpcStatus(*headers);\n    if (grpc_status.has_value()) {\n      grpc_to_http_status = Grpc::Utility::grpcToHttpStatus(grpc_status.value());\n    }\n  }\n\n  if (grpc_status.has_value() &&\n      Runtime::runtimeFeatureEnabled(\n          \"envoy.reloadable_features.outlier_detection_support_for_grpc_status\")) {\n    upstream_request.upstream_host_->outlierDetector().putHttpResponseCode(grpc_to_http_status);\n  } else {\n    upstream_request.upstream_host_->outlierDetector().putHttpResponseCode(response_code);\n  }\n\n  if (headers->EnvoyImmediateHealthCheckFail() != nullptr) {\n    upstream_request.upstream_host_->healthChecker().setUnhealthy();\n  }\n\n  bool could_not_retry = false;\n\n  // Check if this upstream request was already retried, for instance after\n  // hitting a per try timeout. Don't retry it if we already have.\n  if (retry_state_) {\n    if (upstream_request.retried_) {\n      // We already retried this request (presumably for a per try timeout) so\n      // we definitely won't retry it again. Check if we would have retried it\n      // if we could.\n      could_not_retry = retry_state_->wouldRetryFromHeaders(*headers);\n    } else {\n      const RetryStatus retry_status =\n          retry_state_->shouldRetryHeaders(*headers, [this]() -> void { doRetry(); });\n      // Capture upstream_host since setupRetry() in the following line will clear\n      // upstream_request.\n      const auto upstream_host = upstream_request.upstream_host_;\n      if (retry_status == RetryStatus::Yes && setupRetry()) {\n        if (!end_stream) {\n          upstream_request.resetStream();\n        }\n        upstream_request.removeFromList(upstream_requests_);\n\n        Http::CodeStats& code_stats = httpContext().codeStats();\n        code_stats.chargeBasicResponseStat(cluster_->statsScope(), config_.retry_,\n                                           static_cast<Http::Code>(response_code));\n        upstream_host->stats().rq_error_.inc();\n        return;\n      } else if (retry_status == RetryStatus::NoOverflow) {\n        callbacks_->streamInfo().setResponseFlag(StreamInfo::ResponseFlag::UpstreamOverflow);\n        could_not_retry = true;\n      } else if (retry_status == RetryStatus::NoRetryLimitExceeded) {\n        callbacks_->streamInfo().setResponseFlag(\n            StreamInfo::ResponseFlag::UpstreamRetryLimitExceeded);\n        could_not_retry = true;\n      }\n    }\n  }\n\n  if (static_cast<Http::Code>(response_code) == Http::Code::Found &&\n      route_entry_->internalRedirectAction() == InternalRedirectAction::Handle &&\n      setupRedirect(*headers, upstream_request)) {\n    return;\n    // If the redirect could not be handled, fail open and let it pass to the\n    // next downstream.\n  }\n\n  // Check if we got a \"bad\" response, but there are still upstream requests in\n  // flight awaiting headers or scheduled retries. If so, exit to give them a\n  // chance to return before returning a response downstream.\n  if (could_not_retry && (numRequestsAwaitingHeaders() > 0 || pending_retries_ > 0)) {\n    upstream_request.upstream_host_->stats().rq_error_.inc();\n\n    // Reset the stream because there are other in-flight requests that we'll\n    // wait around for and we're not interested in consuming any body/trailers.\n    upstream_request.removeFromList(upstream_requests_)->resetStream();\n    return;\n  }\n\n  // Make sure any retry timers are destroyed since we may not call cleanup() if end_stream is\n  // false.\n  if (retry_state_) {\n    retry_state_.reset();\n  }\n\n  // Only send upstream service time if we received the complete request and this is not a\n  // premature response.\n  if (DateUtil::timePointValid(downstream_request_complete_time_)) {\n    Event::Dispatcher& dispatcher = callbacks_->dispatcher();\n    MonotonicTime response_received_time = dispatcher.timeSource().monotonicTime();\n    std::chrono::milliseconds ms = std::chrono::duration_cast<std::chrono::milliseconds>(\n        response_received_time - downstream_request_complete_time_);\n    if (!config_.suppress_envoy_headers_) {\n      headers->insertEnvoyUpstreamServiceTime().value(ms.count());\n    }\n  }\n\n  upstream_request.upstream_canary_ =\n      (headers->EnvoyUpstreamCanary() && headers->EnvoyUpstreamCanary()->value() == \"true\") ||\n      upstream_request.upstream_host_->canary();\n  chargeUpstreamCode(response_code, *headers, upstream_request.upstream_host_, false);\n  if (!Http::CodeUtility::is5xx(response_code)) {\n    handleNon5xxResponseHeaders(grpc_status, upstream_request, end_stream, grpc_to_http_status);\n  }\n\n  // Append routing cookies\n  for (const auto& header_value : downstream_set_cookies_) {\n    headers->addReferenceKey(Http::Headers::get().SetCookie, header_value);\n  }\n\n  // TODO(zuercher): If access to response_headers_to_add (at any level) is ever needed outside\n  // Router::Filter we'll need to find a better location for this work. One possibility is to\n  // provide finalizeResponseHeaders functions on the Router::Config and VirtualHost interfaces.\n  route_entry_->finalizeResponseHeaders(*headers, callbacks_->streamInfo());\n\n  downstream_response_started_ = true;\n  final_upstream_request_ = &upstream_request;\n  resetOtherUpstreams(upstream_request);\n  if (end_stream) {\n    onUpstreamComplete(upstream_request);\n  }\n\n  callbacks_->streamInfo().setResponseCodeDetails(\n      StreamInfo::ResponseCodeDetails::get().ViaUpstream);\n  callbacks_->encodeHeaders(std::move(headers), end_stream);\n}\n\nvoid Filter::onUpstreamData(Buffer::Instance& data, UpstreamRequest& upstream_request,\n                            bool end_stream) {\n  // This should be true because when we saw headers we either reset the stream\n  // (hence wouldn't have made it to onUpstreamData) or all other in-flight\n  // streams.\n  ASSERT(upstream_requests_.size() == 1);\n  if (end_stream) {\n    // gRPC request termination without trailers is an error.\n    if (upstream_request.grpc_rq_success_deferred_) {\n      upstream_request.upstream_host_->stats().rq_error_.inc();\n    }\n    onUpstreamComplete(upstream_request);\n  }\n\n  callbacks_->encodeData(data, end_stream);\n}\n\nvoid Filter::onUpstreamTrailers(Http::HeaderMapPtr&& trailers, UpstreamRequest& upstream_request) {\n  // This should be true because when we saw headers we either reset the stream\n  // (hence wouldn't have made it to onUpstreamTrailers) or all other in-flight\n  // streams.\n  ASSERT(upstream_requests_.size() == 1);\n\n  if (upstream_request.grpc_rq_success_deferred_) {\n    absl::optional<Grpc::Status::GrpcStatus> grpc_status = Grpc::Common::getGrpcStatus(*trailers);\n    if (grpc_status &&\n        !Http::CodeUtility::is5xx(Grpc::Utility::grpcToHttpStatus(grpc_status.value()))) {\n      upstream_request.upstream_host_->stats().rq_success_.inc();\n    } else {\n      upstream_request.upstream_host_->stats().rq_error_.inc();\n    }\n  }\n\n  onUpstreamComplete(upstream_request);\n\n  callbacks_->encodeTrailers(std::move(trailers));\n}\n\nvoid Filter::onUpstreamMetadata(Http::MetadataMapPtr&& metadata_map) {\n  callbacks_->encodeMetadata(std::move(metadata_map));\n}\n\nvoid Filter::onUpstreamComplete(UpstreamRequest& upstream_request) {\n  if (!downstream_end_stream_) {\n    upstream_request.resetStream();\n  }\n  callbacks_->streamInfo().setUpstreamTiming(final_upstream_request_->upstream_timing_);\n\n  if (config_.emit_dynamic_stats_ && !callbacks_->streamInfo().healthCheck() &&\n      DateUtil::timePointValid(downstream_request_complete_time_)) {\n    Event::Dispatcher& dispatcher = callbacks_->dispatcher();\n    std::chrono::milliseconds response_time = std::chrono::duration_cast<std::chrono::milliseconds>(\n        dispatcher.timeSource().monotonicTime() - downstream_request_complete_time_);\n\n    upstream_request.upstream_host_->outlierDetector().putResponseTime(response_time);\n\n    const Http::HeaderEntry* internal_request_header = downstream_headers_->EnvoyInternalRequest();\n    const bool internal_request =\n        internal_request_header && internal_request_header->value() == \"true\";\n\n    Http::CodeStats& code_stats = httpContext().codeStats();\n    Http::CodeStats::ResponseTimingInfo info{config_.scope_,\n                                             cluster_->statsScope(),\n                                             config_.empty_stat_name_,\n                                             response_time,\n                                             upstream_request.upstream_canary_,\n                                             internal_request,\n                                             route_entry_->virtualHost().statName(),\n                                             request_vcluster_ ? request_vcluster_->statName()\n                                                               : config_.empty_stat_name_,\n                                             config_.zone_name_,\n                                             upstreamZone(upstream_request.upstream_host_)};\n\n    code_stats.chargeResponseTiming(info);\n\n    if (alt_stat_prefix_ != nullptr) {\n      Http::CodeStats::ResponseTimingInfo info{config_.scope_,\n                                               cluster_->statsScope(),\n                                               alt_stat_prefix_->statName(),\n                                               response_time,\n                                               upstream_request.upstream_canary_,\n                                               internal_request,\n                                               config_.empty_stat_name_,\n                                               config_.empty_stat_name_,\n                                               config_.zone_name_,\n                                               upstreamZone(upstream_request.upstream_host_)};\n\n      code_stats.chargeResponseTiming(info);\n    }\n  }\n\n  upstream_request.removeFromList(upstream_requests_);\n  cleanup();\n}\n\nbool Filter::setupRetry() {\n  // If we responded before the request was complete we don't bother doing a retry. This may not\n  // catch certain cases where we are in full streaming mode and we have a connect timeout or an\n  // overflow of some kind. However, in many cases deployments will use the buffer filter before\n  // this filter which will make this a non-issue. The implementation of supporting retry in cases\n  // where the request is not complete is more complicated so we will start with this for now.\n  if (!downstream_end_stream_) {\n    config_.stats_.rq_retry_skipped_request_not_complete_.inc();\n    return false;\n  }\n  pending_retries_++;\n\n  ENVOY_STREAM_LOG(debug, \"performing retry\", *callbacks_);\n\n  return true;\n}\n\nbool Filter::setupRedirect(const Http::HeaderMap& headers, UpstreamRequest& upstream_request) {\n  ENVOY_STREAM_LOG(debug, \"attempting internal redirect\", *callbacks_);\n  const Http::HeaderEntry* location = headers.Location();\n\n  // If the internal redirect succeeds, callbacks_->recreateStream() will result in the destruction\n  // of this filter before the stream is marked as complete, and onDestroy will reset the stream.\n  //\n  // Normally when a stream is complete we signal this by resetting the upstream but this cam not be\n  // done in this case because if recreateStream fails, the \"failure\" path continues to call code\n  // in onUpstreamHeaders which requires the upstream *not* be reset. To avoid onDestroy performing\n  // a spurious stream reset in the case recreateStream() succeeds, we explicitly track stream\n  // completion here and check it in onDestroy. This is annoyingly complicated but is better than\n  // needlessly resetting streams.\n  attempting_internal_redirect_with_complete_stream_ =\n      upstream_request.upstream_timing_.last_upstream_rx_byte_received_ && downstream_end_stream_;\n\n  // As with setupRetry, redirects are not supported for streaming requests yet.\n  if (downstream_end_stream_ &&\n      !callbacks_->decodingBuffer() && // Redirects with body not yet supported.\n      location != nullptr &&\n      convertRequestHeadersForInternalRedirect(*downstream_headers_, *location,\n                                               *callbacks_->connection()) &&\n      callbacks_->recreateStream()) {\n    cluster_->stats().upstream_internal_redirect_succeeded_total_.inc();\n    return true;\n  }\n\n  attempting_internal_redirect_with_complete_stream_ = false;\n\n  ENVOY_STREAM_LOG(debug, \"Internal redirect failed\", *callbacks_);\n  cluster_->stats().upstream_internal_redirect_failed_total_.inc();\n  return false;\n}\n\nvoid Filter::doRetry() {\n  is_retry_ = true;\n  attempt_count_++;\n  ASSERT(pending_retries_ > 0);\n  pending_retries_--;\n  Http::ConnectionPool::Instance* conn_pool = getConnPool();\n  if (!conn_pool) {\n    sendNoHealthyUpstreamResponse();\n    cleanup();\n    return;\n  }\n\n  if (include_attempt_count_) {\n    downstream_headers_->insertEnvoyAttemptCount().value(attempt_count_);\n  }\n\n  ASSERT(response_timeout_ || timeout_.global_timeout_.count() == 0);\n  UpstreamRequestPtr upstream_request = std::make_unique<UpstreamRequest>(*this, *conn_pool);\n  UpstreamRequest* upstream_request_tmp = upstream_request.get();\n  upstream_request->moveIntoList(std::move(upstream_request), upstream_requests_);\n  upstream_requests_.front()->encodeHeaders(!callbacks_->decodingBuffer() && !downstream_trailers_);\n  // It's possible we got immediately reset which means the upstream request we just\n  // added to the front of the list might have been removed, so we need to check to make\n  // sure we don't encodeData on the wrong request.\n  if (!upstream_requests_.empty() && (upstream_requests_.front().get() == upstream_request_tmp)) {\n    if (callbacks_->decodingBuffer()) {\n      // If we are doing a retry we need to make a copy.\n      Buffer::OwnedImpl copy(*callbacks_->decodingBuffer());\n      upstream_requests_.front()->encodeData(copy, !downstream_trailers_);\n    }\n\n    if (downstream_trailers_) {\n      upstream_requests_.front()->encodeTrailers(*downstream_trailers_);\n    }\n  }\n}\n\nuint32_t Filter::numRequestsAwaitingHeaders() {\n  return std::count_if(upstream_requests_.begin(), upstream_requests_.end(),\n                       [](const auto& req) -> bool { return req->awaiting_headers_; });\n}\n\nFilter::UpstreamRequest::UpstreamRequest(Filter& parent, Http::ConnectionPool::Instance& pool)\n    : parent_(parent), conn_pool_(pool), grpc_rq_success_deferred_(false),\n      stream_info_(pool.protocol(), parent_.callbacks_->dispatcher().timeSource()),\n      calling_encode_headers_(false), upstream_canary_(false), decode_complete_(false),\n      encode_complete_(false), encode_trailers_(false), retried_(false), awaiting_headers_(true),\n      outlier_detection_timeout_recorded_(false),\n      create_per_try_timeout_on_request_complete_(false) {\n\n  if (parent_.config_.start_child_span_) {\n    span_ = parent_.callbacks_->activeSpan().spawnChild(\n        parent_.callbacks_->tracingConfig(), \"router \" + parent.cluster_->name() + \" egress\",\n        parent.timeSource().systemTime());\n    if (parent.attempt_count_ != 1) {\n      // This is a retry request, add this metadata to span.\n      span_->setTag(Tracing::Tags::get().RetryCount, std::to_string(parent.attempt_count_ - 1));\n    }\n  }\n\n  stream_info_.healthCheck(parent_.callbacks_->streamInfo().healthCheck());\n}\n\nFilter::UpstreamRequest::~UpstreamRequest() {\n  if (span_ != nullptr) {\n    Tracing::HttpTracerUtility::finalizeUpstreamSpan(*span_, upstream_headers_.get(),\n                                                     upstream_trailers_.get(), stream_info_,\n                                                     Tracing::EgressConfig::get());\n  }\n\n  if (per_try_timeout_ != nullptr) {\n    // Allows for testing.\n    per_try_timeout_->disableTimer();\n  }\n  clearRequestEncoder();\n\n  stream_info_.setUpstreamTiming(upstream_timing_);\n  stream_info_.onRequestComplete();\n  // Prior to logging, refresh the byte size of the HeaderMaps.\n  // TODO(asraa): Remove this when entries in HeaderMap can no longer be modified by reference and\n  // HeaderMap holds an accurate internal byte size count.\n  if (upstream_headers_ != nullptr) {\n    upstream_headers_->refreshByteSize();\n  }\n  if (upstream_trailers_ != nullptr) {\n    upstream_trailers_->refreshByteSize();\n  }\n  for (const auto& upstream_log : parent_.config_.upstream_logs_) {\n    upstream_log->log(parent_.downstream_headers_, upstream_headers_.get(),\n                      upstream_trailers_.get(), stream_info_);\n  }\n}\n\nvoid Filter::UpstreamRequest::decode100ContinueHeaders(Http::HeaderMapPtr&& headers) {\n  ScopeTrackerScopeState scope(&parent_.callbacks_->scope(), parent_.callbacks_->dispatcher());\n\n  ASSERT(100 == Http::Utility::getResponseStatus(*headers));\n  parent_.onUpstream100ContinueHeaders(std::move(headers), *this);\n}\n\nvoid Filter::UpstreamRequest::decodeHeaders(Http::HeaderMapPtr&& headers, bool end_stream) {\n  ScopeTrackerScopeState scope(&parent_.callbacks_->scope(), parent_.callbacks_->dispatcher());\n\n  // TODO(rodaine): This is actually measuring after the headers are parsed and not the first byte.\n  upstream_timing_.onFirstUpstreamRxByteReceived(parent_.callbacks_->dispatcher().timeSource());\n  maybeEndDecode(end_stream);\n\n  awaiting_headers_ = false;\n  if (!parent_.config_.upstream_logs_.empty()) {\n    upstream_headers_ = std::make_unique<Http::HeaderMapImpl>(*headers);\n  }\n  const uint64_t response_code = Http::Utility::getResponseStatus(*headers);\n  stream_info_.response_code_ = static_cast<uint32_t>(response_code);\n  parent_.onUpstreamHeaders(response_code, std::move(headers), *this, end_stream);\n}\n\nvoid Filter::UpstreamRequest::decodeData(Buffer::Instance& data, bool end_stream) {\n  ScopeTrackerScopeState scope(&parent_.callbacks_->scope(), parent_.callbacks_->dispatcher());\n\n  maybeEndDecode(end_stream);\n  stream_info_.addBytesReceived(data.length());\n  parent_.onUpstreamData(data, *this, end_stream);\n}\n\nvoid Filter::UpstreamRequest::decodeTrailers(Http::HeaderMapPtr&& trailers) {\n  ScopeTrackerScopeState scope(&parent_.callbacks_->scope(), parent_.callbacks_->dispatcher());\n\n  maybeEndDecode(true);\n  if (!parent_.config_.upstream_logs_.empty()) {\n    upstream_trailers_ = std::make_unique<Http::HeaderMapImpl>(*trailers);\n  }\n  parent_.onUpstreamTrailers(std::move(trailers), *this);\n}\n\nvoid Filter::UpstreamRequest::decodeMetadata(Http::MetadataMapPtr&& metadata_map) {\n  parent_.onUpstreamMetadata(std::move(metadata_map));\n}\n\nvoid Filter::UpstreamRequest::maybeEndDecode(bool end_stream) {\n  if (end_stream) {\n    upstream_timing_.onLastUpstreamRxByteReceived(parent_.callbacks_->dispatcher().timeSource());\n    decode_complete_ = true;\n  }\n}\n\nvoid Filter::UpstreamRequest::encodeHeaders(bool end_stream) {\n  ASSERT(!encode_complete_);\n  encode_complete_ = end_stream;\n\n  // It's possible for a reset to happen inline within the newStream() call. In this case, we might\n  // get deleted inline as well. Only write the returned handle out if it is not nullptr to deal\n  // with this case.\n  Http::ConnectionPool::Cancellable* handle = conn_pool_.newStream(*this, *this);\n  if (handle) {\n    conn_pool_stream_handle_ = handle;\n  }\n}\n\nvoid Filter::UpstreamRequest::encodeData(Buffer::Instance& data, bool end_stream) {\n  ASSERT(!encode_complete_);\n  encode_complete_ = end_stream;\n\n  if (!request_encoder_) {\n    ENVOY_STREAM_LOG(trace, \"buffering {} bytes\", *parent_.callbacks_, data.length());\n    if (!buffered_request_body_) {\n      buffered_request_body_ = std::make_unique<Buffer::WatermarkBuffer>(\n          [this]() -> void { this->enableDataFromDownstream(); },\n          [this]() -> void { this->disableDataFromDownstream(); });\n      buffered_request_body_->setWatermarks(parent_.buffer_limit_);\n    }\n\n    buffered_request_body_->move(data);\n  } else {\n    ASSERT(downstream_metadata_map_vector_.empty());\n\n    ENVOY_STREAM_LOG(trace, \"proxying {} bytes\", *parent_.callbacks_, data.length());\n    stream_info_.addBytesSent(data.length());\n    request_encoder_->encodeData(data, end_stream);\n    if (end_stream) {\n      upstream_timing_.onLastUpstreamTxByteSent(parent_.callbacks_->dispatcher().timeSource());\n    }\n  }\n}\n\nvoid Filter::UpstreamRequest::encodeTrailers(const Http::HeaderMap& trailers) {\n  ASSERT(!encode_complete_);\n  encode_complete_ = true;\n  encode_trailers_ = true;\n\n  if (!request_encoder_) {\n    ENVOY_STREAM_LOG(trace, \"buffering trailers\", *parent_.callbacks_);\n  } else {\n    ASSERT(downstream_metadata_map_vector_.empty());\n\n    ENVOY_STREAM_LOG(trace, \"proxying trailers\", *parent_.callbacks_);\n    request_encoder_->encodeTrailers(trailers);\n    upstream_timing_.onLastUpstreamTxByteSent(parent_.callbacks_->dispatcher().timeSource());\n  }\n}\n\nvoid Filter::UpstreamRequest::encodeMetadata(Http::MetadataMapPtr&& metadata_map_ptr) {\n  if (!request_encoder_) {\n    ENVOY_STREAM_LOG(trace, \"request_encoder_ not ready. Store metadata_map to encode later: {}\",\n                     *parent_.callbacks_, *metadata_map_ptr);\n    downstream_metadata_map_vector_.emplace_back(std::move(metadata_map_ptr));\n  } else {\n    ENVOY_STREAM_LOG(trace, \"Encode metadata: {}\", *parent_.callbacks_, *metadata_map_ptr);\n    Http::MetadataMapVector metadata_map_vector;\n    metadata_map_vector.emplace_back(std::move(metadata_map_ptr));\n    request_encoder_->encodeMetadata(metadata_map_vector);\n  }\n}\n\nvoid Filter::UpstreamRequest::onResetStream(Http::StreamResetReason reason,\n                                            absl::string_view transport_failure_reason) {\n  ScopeTrackerScopeState scope(&parent_.callbacks_->scope(), parent_.callbacks_->dispatcher());\n\n  if (span_ != nullptr) {\n    // Add tags about reset.\n    span_->setTag(Tracing::Tags::get().Error, Tracing::Tags::get().True);\n    span_->setTag(Tracing::Tags::get().ErrorReason, Http::Utility::resetReasonToString(reason));\n  }\n\n  clearRequestEncoder();\n  awaiting_headers_ = false;\n  if (!calling_encode_headers_) {\n    stream_info_.setResponseFlag(parent_.streamResetReasonToResponseFlag(reason));\n    parent_.onUpstreamReset(reason, transport_failure_reason, *this);\n  } else {\n    deferred_reset_reason_ = reason;\n  }\n}\n\nvoid Filter::UpstreamRequest::resetStream() {\n  // Don't reset the stream if we're already done with it.\n  if (encode_complete_ && decode_complete_) {\n    return;\n  }\n\n  if (span_ != nullptr) {\n    // Add tags about the cancellation.\n    span_->setTag(Tracing::Tags::get().Canceled, Tracing::Tags::get().True);\n  }\n\n  if (conn_pool_stream_handle_) {\n    ENVOY_STREAM_LOG(debug, \"cancelling pool request\", *parent_.callbacks_);\n    ASSERT(!request_encoder_);\n    conn_pool_stream_handle_->cancel();\n    conn_pool_stream_handle_ = nullptr;\n  }\n\n  if (request_encoder_) {\n    ENVOY_STREAM_LOG(debug, \"resetting pool request\", *parent_.callbacks_);\n    request_encoder_->getStream().removeCallbacks(*this);\n    request_encoder_->getStream().resetStream(Http::StreamResetReason::LocalReset);\n    clearRequestEncoder();\n  }\n}\n\nvoid Filter::UpstreamRequest::setupPerTryTimeout() {\n  ASSERT(!per_try_timeout_);\n  if (parent_.timeout_.per_try_timeout_.count() > 0) {\n    per_try_timeout_ =\n        parent_.callbacks_->dispatcher().createTimer([this]() -> void { onPerTryTimeout(); });\n    per_try_timeout_->enableTimer(parent_.timeout_.per_try_timeout_);\n  }\n}\n\nvoid Filter::UpstreamRequest::onPerTryTimeout() {\n  // If we've sent anything downstream, ignore the per try timeout and let the response continue up\n  // to the global timeout\n  if (!parent_.downstream_response_started_) {\n    ENVOY_STREAM_LOG(debug, \"upstream per try timeout\", *parent_.callbacks_);\n\n    stream_info_.setResponseFlag(StreamInfo::ResponseFlag::UpstreamRequestTimeout);\n    parent_.onPerTryTimeout(*this);\n  } else {\n    ENVOY_STREAM_LOG(debug,\n                     \"ignored upstream per try timeout due to already started downstream response\",\n                     *parent_.callbacks_);\n  }\n}\n\nvoid Filter::UpstreamRequest::onPoolFailure(Http::ConnectionPool::PoolFailureReason reason,\n                                            absl::string_view transport_failure_reason,\n                                            Upstream::HostDescriptionConstSharedPtr host) {\n  Http::StreamResetReason reset_reason = Http::StreamResetReason::ConnectionFailure;\n  switch (reason) {\n  case Http::ConnectionPool::PoolFailureReason::Overflow:\n    reset_reason = Http::StreamResetReason::Overflow;\n    break;\n  case Http::ConnectionPool::PoolFailureReason::ConnectionFailure:\n    reset_reason = Http::StreamResetReason::ConnectionFailure;\n    break;\n  }\n\n  // Mimic an upstream reset.\n  onUpstreamHostSelected(host);\n  onResetStream(reset_reason, transport_failure_reason);\n}\n\nvoid Filter::UpstreamRequest::onPoolReady(Http::StreamEncoder& request_encoder,\n                                          Upstream::HostDescriptionConstSharedPtr host,\n                                          const StreamInfo::StreamInfo& info) {\n  // This may be called under an existing ScopeTrackerScopeState but it will unwind correctly.\n  ScopeTrackerScopeState scope(&parent_.callbacks_->scope(), parent_.callbacks_->dispatcher());\n  ENVOY_STREAM_LOG(debug, \"pool ready\", *parent_.callbacks_);\n\n  host->outlierDetector().putResult(Upstream::Outlier::Result::LOCAL_ORIGIN_CONNECT_SUCCESS);\n\n  // TODO(ggreenway): set upstream local address in the StreamInfo.\n  onUpstreamHostSelected(host);\n  request_encoder.getStream().addCallbacks(*this);\n\n  stream_info_.setUpstreamSslConnection(info.downstreamSslConnection());\n  parent_.callbacks_->streamInfo().setUpstreamSslConnection(info.downstreamSslConnection());\n\n  if (parent_.downstream_end_stream_) {\n    setupPerTryTimeout();\n  } else {\n    create_per_try_timeout_on_request_complete_ = true;\n  }\n\n  conn_pool_stream_handle_ = nullptr;\n  setRequestEncoder(request_encoder);\n  calling_encode_headers_ = true;\n  if (parent_.route_entry_->autoHostRewrite() && !host->hostname().empty()) {\n    parent_.downstream_headers_->Host()->value(host->hostname());\n  }\n\n  if (span_ != nullptr) {\n    span_->injectContext(*parent_.downstream_headers_);\n  }\n\n  upstream_timing_.onFirstUpstreamTxByteSent(parent_.callbacks_->dispatcher().timeSource());\n\n  const bool end_stream = !buffered_request_body_ && encode_complete_ && !encode_trailers_;\n  // If end_stream is set in headers, and there are metadata to send, delays end_stream. The case\n  // only happens when decoding headers filters return ContinueAndEndStream.\n  const bool delay_headers_end_stream = end_stream && !downstream_metadata_map_vector_.empty();\n  request_encoder.encodeHeaders(*parent_.downstream_headers_,\n                                end_stream && !delay_headers_end_stream);\n  calling_encode_headers_ = false;\n\n  // It is possible to get reset in the middle of an encodeHeaders() call. This happens for example\n  // in the HTTP/2 codec if the frame cannot be encoded for some reason. This should never happen\n  // but it's unclear if we have covered all cases so protect against it and test for it. One\n  // specific example of a case where this happens is if we try to encode a total header size that\n  // is too big in HTTP/2 (64K currently).\n  if (deferred_reset_reason_) {\n    onResetStream(deferred_reset_reason_.value(), absl::string_view());\n  } else {\n    // Encode metadata after headers and before any other frame type.\n    if (!downstream_metadata_map_vector_.empty()) {\n      ENVOY_STREAM_LOG(debug, \"Send metadata onPoolReady. {}\", *parent_.callbacks_,\n                       downstream_metadata_map_vector_);\n      request_encoder.encodeMetadata(downstream_metadata_map_vector_);\n      downstream_metadata_map_vector_.clear();\n      if (delay_headers_end_stream) {\n        Buffer::OwnedImpl empty_data(\"\");\n        request_encoder.encodeData(empty_data, true);\n      }\n    }\n\n    if (buffered_request_body_) {\n      stream_info_.addBytesSent(buffered_request_body_->length());\n      request_encoder.encodeData(*buffered_request_body_, encode_complete_ && !encode_trailers_);\n    }\n\n    if (encode_trailers_) {\n      request_encoder.encodeTrailers(*parent_.downstream_trailers_);\n    }\n\n    if (encode_complete_) {\n      upstream_timing_.onLastUpstreamTxByteSent(parent_.callbacks_->dispatcher().timeSource());\n    }\n  }\n}\n\nRetryStatePtr\nProdFilter::createRetryState(const RetryPolicy& policy, Http::HeaderMap& request_headers,\n                             const Upstream::ClusterInfo& cluster, Runtime::Loader& runtime,\n                             Runtime::RandomGenerator& random, Event::Dispatcher& dispatcher,\n                             Upstream::ResourcePriority priority) {\n  return RetryStateImpl::create(policy, request_headers, cluster, runtime, random, dispatcher,\n                                priority);\n}\n\nvoid Filter::UpstreamRequest::setRequestEncoder(Http::StreamEncoder& request_encoder) {\n  request_encoder_ = &request_encoder;\n  // Now that there is an encoder, have the connection manager inform the manager when the\n  // downstream buffers are overrun. This may result in immediate watermark callbacks referencing\n  // the encoder.\n  parent_.callbacks_->addDownstreamWatermarkCallbacks(downstream_watermark_manager_);\n}\n\nvoid Filter::UpstreamRequest::clearRequestEncoder() {\n  // Before clearing the encoder, unsubscribe from callbacks.\n  if (request_encoder_) {\n    parent_.callbacks_->removeDownstreamWatermarkCallbacks(downstream_watermark_manager_);\n  }\n  request_encoder_ = nullptr;\n}\n\nvoid Filter::UpstreamRequest::DownstreamWatermarkManager::onAboveWriteBufferHighWatermark() {\n  ASSERT(parent_.request_encoder_);\n\n  // There are two states we should get this callback in: 1) the watermark was\n  // hit due to writes from a different filter instance over a shared\n  // downstream connection, or 2) the watermark was hit due to THIS filter\n  // instance writing back the \"winning\" upstream request. In either case we\n  // can disable reads from upstream.\n  ASSERT(!parent_.parent_.final_upstream_request_ ||\n         &parent_ == parent_.parent_.final_upstream_request_);\n\n  // The downstream connection is overrun. Pause reads from upstream.\n  // If there are multiple calls to readDisable either the codec (H2) or the underlying\n  // Network::Connection (H1) will handle reference counting.\n  parent_.parent_.cluster_->stats().upstream_flow_control_paused_reading_total_.inc();\n  parent_.request_encoder_->getStream().readDisable(true);\n}\n\nvoid Filter::UpstreamRequest::DownstreamWatermarkManager::onBelowWriteBufferLowWatermark() {\n  ASSERT(parent_.request_encoder_);\n\n  // One source of connection blockage has buffer available. Pass this on to the stream, which\n  // will resume reads if this was the last remaining high watermark.\n  parent_.parent_.cluster_->stats().upstream_flow_control_resumed_reading_total_.inc();\n  parent_.request_encoder_->getStream().readDisable(false);\n}\n\n} // namespace Router\n} // namespace Envoy\n", "#pragma once\n\n#include <cstdint>\n#include <string>\n#include <unordered_set>\n#include <vector>\n\n#include \"envoy/access_log/access_log.h\"\n#include \"envoy/config/filter/accesslog/v2/accesslog.pb.h\"\n#include \"envoy/runtime/runtime.h\"\n#include \"envoy/server/access_log_config.h\"\n\n#include \"common/http/header_utility.h\"\n#include \"common/protobuf/protobuf.h\"\n\nnamespace Envoy {\nnamespace Extensions {\nnamespace AccessLoggers {\nnamespace Common {\n\n/**\n * Base implementation of Accesslog::Instance handles common filter logic.\n */\nclass ImplBase : public AccessLog::Instance {\npublic:\n  ImplBase(AccessLog::FilterPtr filter) : filter_(std::move(filter)) {}\n\n  /**\n   * Log a completed request if the underlying AccessLog `filter_` allows it.\n   *\n   * Prior to logging, call refreshByteSize() on HeaderMaps to ensure that an accurate byte size\n   * count is logged.\n   * TODO(asraa): Remove refreshByteSize() requirement when entries in HeaderMap can no longer be\n   * modified by reference and HeaderMap holds an accurate internal byte size count.\n   */\n  void log(const Http::HeaderMap* request_headers, const Http::HeaderMap* response_headers,\n           const Http::HeaderMap* response_trailers,\n           const StreamInfo::StreamInfo& stream_info) override;\n\nprivate:\n  /**\n   * Log a completed request.\n   * @param request_headers supplies the incoming request headers after filtering.\n   * @param response_headers supplies response headers.\n   * @param response_trailers supplies response trailers.\n   * @param stream_info supplies additional information about the request not\n   * contained in the request headers.\n   */\n  virtual void emitLog(const Http::HeaderMap& request_headers,\n                       const Http::HeaderMap& response_headers,\n                       const Http::HeaderMap& response_trailers,\n                       const StreamInfo::StreamInfo& stream_info) PURE;\n\n  AccessLog::FilterPtr filter_;\n};\n\n} // namespace Common\n} // namespace AccessLoggers\n} // namespace Extensions\n} // namespace Envoy\n", "#include \"extensions/access_loggers/grpc/http_grpc_access_log_impl.h\"\n\n#include \"common/common/assert.h\"\n#include \"common/network/utility.h\"\n#include \"common/stream_info/utility.h\"\n\n#include \"extensions/access_loggers/grpc/grpc_access_log_utils.h\"\n\nnamespace Envoy {\nnamespace Extensions {\nnamespace AccessLoggers {\nnamespace HttpGrpc {\n\nHttpGrpcAccessLog::ThreadLocalLogger::ThreadLocalLogger(\n    GrpcCommon::GrpcAccessLoggerSharedPtr logger)\n    : logger_(std::move(logger)) {}\n\nHttpGrpcAccessLog::HttpGrpcAccessLog(AccessLog::FilterPtr&& filter,\n                                     envoy::config::accesslog::v2::HttpGrpcAccessLogConfig config,\n                                     ThreadLocal::SlotAllocator& tls,\n                                     GrpcCommon::GrpcAccessLoggerCacheSharedPtr access_logger_cache)\n    : Common::ImplBase(std::move(filter)), config_(std::move(config)),\n      tls_slot_(tls.allocateSlot()), access_logger_cache_(std::move(access_logger_cache)) {\n  for (const auto& header : config_.additional_request_headers_to_log()) {\n    request_headers_to_log_.emplace_back(header);\n  }\n\n  for (const auto& header : config_.additional_response_headers_to_log()) {\n    response_headers_to_log_.emplace_back(header);\n  }\n\n  for (const auto& header : config_.additional_response_trailers_to_log()) {\n    response_trailers_to_log_.emplace_back(header);\n  }\n\n  tls_slot_->set([this](Event::Dispatcher&) {\n    return std::make_shared<ThreadLocalLogger>(access_logger_cache_->getOrCreateLogger(\n        config_.common_config(), GrpcCommon::GrpcAccessLoggerType::HTTP));\n  });\n}\n\nvoid HttpGrpcAccessLog::emitLog(const Http::HeaderMap& request_headers,\n                                const Http::HeaderMap& response_headers,\n                                const Http::HeaderMap& response_trailers,\n                                const StreamInfo::StreamInfo& stream_info) {\n  // Common log properties.\n  // TODO(mattklein123): Populate sample_rate field.\n  envoy::data::accesslog::v2::HTTPAccessLogEntry log_entry;\n  GrpcCommon::Utility::extractCommonAccessLogProperties(*log_entry.mutable_common_properties(),\n                                                        stream_info);\n\n  if (stream_info.protocol()) {\n    switch (stream_info.protocol().value()) {\n    case Http::Protocol::Http10:\n      log_entry.set_protocol_version(envoy::data::accesslog::v2::HTTPAccessLogEntry::HTTP10);\n      break;\n    case Http::Protocol::Http11:\n      log_entry.set_protocol_version(envoy::data::accesslog::v2::HTTPAccessLogEntry::HTTP11);\n      break;\n    case Http::Protocol::Http2:\n      log_entry.set_protocol_version(envoy::data::accesslog::v2::HTTPAccessLogEntry::HTTP2);\n      break;\n    }\n  }\n\n  // HTTP request properties.\n  // TODO(mattklein123): Populate port field.\n  auto* request_properties = log_entry.mutable_request();\n  if (request_headers.Scheme() != nullptr) {\n    request_properties->set_scheme(std::string(request_headers.Scheme()->value().getStringView()));\n  }\n  if (request_headers.Host() != nullptr) {\n    request_properties->set_authority(std::string(request_headers.Host()->value().getStringView()));\n  }\n  if (request_headers.Path() != nullptr) {\n    request_properties->set_path(std::string(request_headers.Path()->value().getStringView()));\n  }\n  if (request_headers.UserAgent() != nullptr) {\n    request_properties->set_user_agent(\n        std::string(request_headers.UserAgent()->value().getStringView()));\n  }\n  if (request_headers.Referer() != nullptr) {\n    request_properties->set_referer(\n        std::string(request_headers.Referer()->value().getStringView()));\n  }\n  if (request_headers.ForwardedFor() != nullptr) {\n    request_properties->set_forwarded_for(\n        std::string(request_headers.ForwardedFor()->value().getStringView()));\n  }\n  if (request_headers.RequestId() != nullptr) {\n    request_properties->set_request_id(\n        std::string(request_headers.RequestId()->value().getStringView()));\n  }\n  if (request_headers.EnvoyOriginalPath() != nullptr) {\n    request_properties->set_original_path(\n        std::string(request_headers.EnvoyOriginalPath()->value().getStringView()));\n  }\n  request_properties->set_request_headers_bytes(request_headers.byteSize().value());\n  request_properties->set_request_body_bytes(stream_info.bytesReceived());\n  if (request_headers.Method() != nullptr) {\n    envoy::api::v2::core::RequestMethod method =\n        envoy::api::v2::core::RequestMethod::METHOD_UNSPECIFIED;\n    envoy::api::v2::core::RequestMethod_Parse(\n        std::string(request_headers.Method()->value().getStringView()), &method);\n    request_properties->set_request_method(method);\n  }\n  if (!request_headers_to_log_.empty()) {\n    auto* logged_headers = request_properties->mutable_request_headers();\n\n    for (const auto& header : request_headers_to_log_) {\n      const Http::HeaderEntry* entry = request_headers.get(header);\n      if (entry != nullptr) {\n        logged_headers->insert({header.get(), std::string(entry->value().getStringView())});\n      }\n    }\n  }\n\n  // HTTP response properties.\n  auto* response_properties = log_entry.mutable_response();\n  if (stream_info.responseCode()) {\n    response_properties->mutable_response_code()->set_value(stream_info.responseCode().value());\n  }\n  if (stream_info.responseCodeDetails()) {\n    response_properties->set_response_code_details(stream_info.responseCodeDetails().value());\n  }\n  response_properties->set_response_headers_bytes(response_headers.byteSize().value());\n  response_properties->set_response_body_bytes(stream_info.bytesSent());\n  if (!response_headers_to_log_.empty()) {\n    auto* logged_headers = response_properties->mutable_response_headers();\n\n    for (const auto& header : response_headers_to_log_) {\n      const Http::HeaderEntry* entry = response_headers.get(header);\n      if (entry != nullptr) {\n        logged_headers->insert({header.get(), std::string(entry->value().getStringView())});\n      }\n    }\n  }\n\n  if (!response_trailers_to_log_.empty()) {\n    auto* logged_headers = response_properties->mutable_response_trailers();\n\n    for (const auto& header : response_trailers_to_log_) {\n      const Http::HeaderEntry* entry = response_trailers.get(header);\n      if (entry != nullptr) {\n        logged_headers->insert({header.get(), std::string(entry->value().getStringView())});\n      }\n    }\n  }\n\n  tls_slot_->getTyped<ThreadLocalLogger>().logger_->log(std::move(log_entry));\n}\n\n} // namespace HttpGrpc\n} // namespace AccessLoggers\n} // namespace Extensions\n} // namespace Envoy\n", "#include \"extensions/filters/common/expr/context.h\"\n\n#include \"absl/strings/numbers.h\"\n#include \"absl/time/time.h\"\n\nnamespace Envoy {\nnamespace Extensions {\nnamespace Filters {\nnamespace Common {\nnamespace Expr {\n\nnamespace {\n\nabsl::optional<CelValue> convertHeaderEntry(const Http::HeaderEntry* header) {\n  if (header == nullptr) {\n    return {};\n  }\n  return CelValue::CreateString(header->value().getStringView());\n}\n\n} // namespace\n\nabsl::optional<CelValue> HeadersWrapper::operator[](CelValue key) const {\n  if (value_ == nullptr || !key.IsString()) {\n    return {};\n  }\n  auto out = value_->get(Http::LowerCaseString(std::string(key.StringOrDie().value())));\n  return convertHeaderEntry(out);\n}\n\nabsl::optional<CelValue> RequestWrapper::operator[](CelValue key) const {\n  if (!key.IsString()) {\n    return {};\n  }\n  auto value = key.StringOrDie().value();\n\n  if (value == Headers) {\n    return CelValue::CreateMap(&headers_);\n  } else if (value == Time) {\n    return CelValue::CreateTimestamp(absl::FromChrono(info_.startTime()));\n  } else if (value == Size) {\n    // it is important to make a choice whether to rely on content-length vs stream info\n    // (which is not available at the time of the request headers)\n    if (headers_.value_ != nullptr && headers_.value_->ContentLength() != nullptr) {\n      int64_t length;\n      if (absl::SimpleAtoi(headers_.value_->ContentLength()->value().getStringView(), &length)) {\n        return CelValue::CreateInt64(length);\n      }\n    } else {\n      return CelValue::CreateInt64(info_.bytesReceived());\n    }\n  } else if (value == Duration) {\n    auto duration = info_.requestComplete();\n    if (duration.has_value()) {\n      return CelValue::CreateDuration(absl::FromChrono(duration.value()));\n    }\n  }\n\n  if (headers_.value_ != nullptr) {\n    if (value == Path) {\n      return convertHeaderEntry(headers_.value_->Path());\n    } else if (value == UrlPath) {\n      absl::string_view path = headers_.value_->Path()->value().getStringView();\n      size_t query_offset = path.find('?');\n      if (query_offset == absl::string_view::npos) {\n        return CelValue::CreateString(path);\n      }\n      return CelValue::CreateString(path.substr(0, query_offset));\n    } else if (value == Host) {\n      return convertHeaderEntry(headers_.value_->Host());\n    } else if (value == Scheme) {\n      return convertHeaderEntry(headers_.value_->Scheme());\n    } else if (value == Method) {\n      return convertHeaderEntry(headers_.value_->Method());\n    } else if (value == Referer) {\n      return convertHeaderEntry(headers_.value_->Referer());\n    } else if (value == ID) {\n      return convertHeaderEntry(headers_.value_->RequestId());\n    } else if (value == UserAgent) {\n      return convertHeaderEntry(headers_.value_->UserAgent());\n    } else if (value == TotalSize) {\n      return CelValue::CreateInt64(info_.bytesReceived() + headers_.value_->byteSize().value());\n    }\n  }\n  return {};\n}\n\nabsl::optional<CelValue> ResponseWrapper::operator[](CelValue key) const {\n  if (!key.IsString()) {\n    return {};\n  }\n  auto value = key.StringOrDie().value();\n  if (value == Code) {\n    auto code = info_.responseCode();\n    if (code.has_value()) {\n      return CelValue::CreateInt64(code.value());\n    }\n  } else if (value == Size) {\n    return CelValue::CreateInt64(info_.bytesSent());\n  } else if (value == Headers) {\n    return CelValue::CreateMap(&headers_);\n  } else if (value == Trailers) {\n    return CelValue::CreateMap(&trailers_);\n  }\n  return {};\n}\n\nabsl::optional<CelValue> ConnectionWrapper::operator[](CelValue key) const {\n  if (!key.IsString()) {\n    return {};\n  }\n  auto value = key.StringOrDie().value();\n  if (value == MTLS) {\n    return CelValue::CreateBool(info_.downstreamSslConnection() != nullptr &&\n                                info_.downstreamSslConnection()->peerCertificatePresented());\n  } else if (value == RequestedServerName) {\n    return CelValue::CreateString(info_.requestedServerName());\n  }\n\n  if (info_.downstreamSslConnection() != nullptr) {\n    if (value == TLSVersion) {\n      return CelValue::CreateString(info_.downstreamSslConnection()->tlsVersion());\n    }\n  }\n\n  return {};\n}\n\nabsl::optional<CelValue> UpstreamWrapper::operator[](CelValue key) const {\n  if (!key.IsString()) {\n    return {};\n  }\n  auto value = key.StringOrDie().value();\n  if (value == Address) {\n    auto upstream_host = info_.upstreamHost();\n    if (upstream_host != nullptr && upstream_host->address() != nullptr) {\n      return CelValue::CreateString(upstream_host->address()->asStringView());\n    }\n  } else if (value == Port) {\n    auto upstream_host = info_.upstreamHost();\n    if (upstream_host != nullptr && upstream_host->address() != nullptr &&\n        upstream_host->address()->ip() != nullptr) {\n      return CelValue::CreateInt64(upstream_host->address()->ip()->port());\n    }\n  } else if (value == MTLS) {\n    return CelValue::CreateBool(info_.upstreamSslConnection() != nullptr &&\n                                info_.upstreamSslConnection()->peerCertificatePresented());\n  }\n\n  return {};\n}\n\nabsl::optional<CelValue> PeerWrapper::operator[](CelValue key) const {\n  if (!key.IsString()) {\n    return {};\n  }\n  auto value = key.StringOrDie().value();\n  if (value == Address) {\n    if (local_) {\n      return CelValue::CreateString(info_.downstreamLocalAddress()->asStringView());\n    } else {\n      return CelValue::CreateString(info_.downstreamRemoteAddress()->asStringView());\n    }\n  } else if (value == Port) {\n    if (local_) {\n      if (info_.downstreamLocalAddress()->ip() != nullptr) {\n        return CelValue::CreateInt64(info_.downstreamLocalAddress()->ip()->port());\n      }\n    } else {\n      if (info_.downstreamRemoteAddress()->ip() != nullptr) {\n        return CelValue::CreateInt64(info_.downstreamRemoteAddress()->ip()->port());\n      }\n    }\n  }\n\n  return {};\n}\n\n} // namespace Expr\n} // namespace Common\n} // namespace Filters\n} // namespace Extensions\n} // namespace Envoy\n", "#include \"extensions/filters/http/rbac/rbac_filter.h\"\n\n#include \"envoy/stats/scope.h\"\n\n#include \"common/http/utility.h\"\n\n#include \"extensions/filters/http/well_known_names.h\"\n\n#include \"absl/strings/str_join.h\"\n\nnamespace Envoy {\nnamespace Extensions {\nnamespace HttpFilters {\nnamespace RBACFilter {\n\nstruct RcDetailsValues {\n  // The rbac filter rejected the request\n  const std::string RbacAccessDenied = \"rbac_access_denied\";\n};\nusing RcDetails = ConstSingleton<RcDetailsValues>;\n\nRoleBasedAccessControlFilterConfig::RoleBasedAccessControlFilterConfig(\n    const envoy::config::filter::http::rbac::v2::RBAC& proto_config,\n    const std::string& stats_prefix, Stats::Scope& scope)\n    : stats_(Filters::Common::RBAC::generateStats(stats_prefix, scope)),\n      engine_(Filters::Common::RBAC::createEngine(proto_config)),\n      shadow_engine_(Filters::Common::RBAC::createShadowEngine(proto_config)) {}\n\nconst Filters::Common::RBAC::RoleBasedAccessControlEngineImpl*\nRoleBasedAccessControlFilterConfig::engine(const Router::RouteConstSharedPtr route,\n                                           Filters::Common::RBAC::EnforcementMode mode) const {\n  if (!route || !route->routeEntry()) {\n    return engine(mode);\n  }\n\n  const std::string& name = HttpFilterNames::get().Rbac;\n  const auto* entry = route->routeEntry();\n  const auto* tmp =\n      entry->perFilterConfigTyped<RoleBasedAccessControlRouteSpecificFilterConfig>(name);\n  const auto* route_local =\n      tmp ? tmp\n          : entry->virtualHost()\n                .perFilterConfigTyped<RoleBasedAccessControlRouteSpecificFilterConfig>(name);\n\n  if (route_local) {\n    return route_local->engine(mode);\n  }\n\n  return engine(mode);\n}\n\nRoleBasedAccessControlRouteSpecificFilterConfig::RoleBasedAccessControlRouteSpecificFilterConfig(\n    const envoy::config::filter::http::rbac::v2::RBACPerRoute& per_route_config)\n    : engine_(Filters::Common::RBAC::createEngine(per_route_config.rbac())),\n      shadow_engine_(Filters::Common::RBAC::createShadowEngine(per_route_config.rbac())) {}\n\nHttp::FilterHeadersStatus RoleBasedAccessControlFilter::decodeHeaders(Http::HeaderMap& headers,\n                                                                      bool) {\n  ENVOY_LOG(debug,\n            \"checking request: remoteAddress: {}, localAddress: {}, ssl: {}, headers: {}, \"\n            \"dynamicMetadata: {}\",\n            callbacks_->connection()->remoteAddress()->asString(),\n            callbacks_->connection()->localAddress()->asString(),\n            callbacks_->connection()->ssl()\n                ? \"uriSanPeerCertificate: \" +\n                      absl::StrJoin(callbacks_->connection()->ssl()->uriSanPeerCertificate(), \",\") +\n                      \", subjectPeerCertificate: \" +\n                      callbacks_->connection()->ssl()->subjectPeerCertificate()\n                : \"none\",\n            headers, callbacks_->streamInfo().dynamicMetadata().DebugString());\n\n  std::string effective_policy_id;\n  const auto shadow_engine =\n      config_->engine(callbacks_->route(), Filters::Common::RBAC::EnforcementMode::Shadow);\n\n  if (shadow_engine != nullptr) {\n    std::string shadow_resp_code =\n        Filters::Common::RBAC::DynamicMetadataKeysSingleton::get().EngineResultAllowed;\n    // Refresh headers byte size before checking if allowed.\n    // TODO(asraa): Remove this when entries in HeaderMap can no longer be modified by reference and\n    // HeaderMap holds an accurate internal byte size count.\n    headers.refreshByteSize();\n    if (shadow_engine->allowed(*callbacks_->connection(), headers, callbacks_->streamInfo(),\n                               &effective_policy_id)) {\n      ENVOY_LOG(debug, \"shadow allowed\");\n      config_->stats().shadow_allowed_.inc();\n    } else {\n      ENVOY_LOG(debug, \"shadow denied\");\n      config_->stats().shadow_denied_.inc();\n      shadow_resp_code =\n          Filters::Common::RBAC::DynamicMetadataKeysSingleton::get().EngineResultDenied;\n    }\n\n    ProtobufWkt::Struct metrics;\n\n    auto& fields = *metrics.mutable_fields();\n    if (!effective_policy_id.empty()) {\n      *fields[Filters::Common::RBAC::DynamicMetadataKeysSingleton::get()\n                  .ShadowEffectivePolicyIdField]\n           .mutable_string_value() = effective_policy_id;\n    }\n\n    *fields[Filters::Common::RBAC::DynamicMetadataKeysSingleton::get().ShadowEngineResultField]\n         .mutable_string_value() = shadow_resp_code;\n\n    callbacks_->streamInfo().setDynamicMetadata(HttpFilterNames::get().Rbac, metrics);\n  }\n\n  const auto engine =\n      config_->engine(callbacks_->route(), Filters::Common::RBAC::EnforcementMode::Enforced);\n  if (engine != nullptr) {\n    // Refresh headers byte size before checking if allowed.\n    // TODO(asraa): Remove this when entries in HeaderMap can no longer be modified by reference and\n    // HeaderMap holds an accurate internal byte size count.\n    headers.refreshByteSize();\n    if (engine->allowed(*callbacks_->connection(), headers, callbacks_->streamInfo(), nullptr)) {\n      ENVOY_LOG(debug, \"enforced allowed\");\n      config_->stats().allowed_.inc();\n      return Http::FilterHeadersStatus::Continue;\n    } else {\n      ENVOY_LOG(debug, \"enforced denied\");\n      callbacks_->sendLocalReply(Http::Code::Forbidden, \"RBAC: access denied\", nullptr,\n                                 absl::nullopt, RcDetails::get().RbacAccessDenied);\n      config_->stats().denied_.inc();\n      return Http::FilterHeadersStatus::StopIteration;\n    }\n  }\n\n  ENVOY_LOG(debug, \"no engine, allowed by default\");\n  return Http::FilterHeadersStatus::Continue;\n}\n\n} // namespace RBACFilter\n} // namespace HttpFilters\n} // namespace Extensions\n} // namespace Envoy\n", "#include <chrono>\n#include <cstdint>\n#include <list>\n#include <memory>\n#include <string>\n\n#include \"envoy/access_log/access_log.h\"\n#include \"envoy/buffer/buffer.h\"\n#include \"envoy/event/dispatcher.h\"\n#include \"envoy/tracing/http_tracer.h\"\n\n#include \"common/access_log/access_log_formatter.h\"\n#include \"common/access_log/access_log_impl.h\"\n#include \"common/buffer/buffer_impl.h\"\n#include \"common/common/empty_string.h\"\n#include \"common/common/macros.h\"\n#include \"common/http/conn_manager_impl.h\"\n#include \"common/http/context_impl.h\"\n#include \"common/http/date_provider_impl.h\"\n#include \"common/http/exception.h\"\n#include \"common/http/header_map_impl.h\"\n#include \"common/http/headers.h\"\n#include \"common/network/address_impl.h\"\n#include \"common/network/utility.h\"\n#include \"common/upstream/upstream_impl.h\"\n\n#include \"extensions/access_loggers/file/file_access_log_impl.h\"\n\n#include \"test/mocks/access_log/mocks.h\"\n#include \"test/mocks/buffer/mocks.h\"\n#include \"test/mocks/common.h\"\n#include \"test/mocks/http/mocks.h\"\n#include \"test/mocks/local_info/mocks.h\"\n#include \"test/mocks/network/mocks.h\"\n#include \"test/mocks/router/mocks.h\"\n#include \"test/mocks/runtime/mocks.h\"\n#include \"test/mocks/server/mocks.h\"\n#include \"test/mocks/ssl/mocks.h\"\n#include \"test/mocks/tracing/mocks.h\"\n#include \"test/mocks/upstream/cluster_info.h\"\n#include \"test/mocks/upstream/mocks.h\"\n#include \"test/test_common/logging.h\"\n#include \"test/test_common/printers.h\"\n#include \"test/test_common/test_time.h\"\n\n#include \"gmock/gmock.h\"\n#include \"gtest/gtest.h\"\n\nusing testing::_;\nusing testing::An;\nusing testing::AnyNumber;\nusing testing::AtLeast;\nusing testing::Eq;\nusing testing::HasSubstr;\nusing testing::InSequence;\nusing testing::Invoke;\nusing testing::InvokeWithoutArgs;\nusing testing::Matcher;\nusing testing::NiceMock;\nusing testing::Ref;\nusing testing::Return;\nusing testing::ReturnRef;\n\nnamespace Envoy {\nnamespace Http {\n\nclass HttpConnectionManagerImplTest : public testing::Test, public ConnectionManagerConfig {\npublic:\n  HttpConnectionManagerImplTest()\n      : http_context_(fake_stats_.symbolTable()), access_log_path_(\"dummy_path\"),\n        access_logs_{\n            AccessLog::InstanceSharedPtr{new Extensions::AccessLoggers::File::FileAccessLog(\n                access_log_path_, {}, AccessLog::AccessLogFormatUtils::defaultAccessLogFormatter(),\n                log_manager_)}},\n        codec_(new NiceMock<MockServerConnection>()),\n        stats_{{ALL_HTTP_CONN_MAN_STATS(POOL_COUNTER(fake_stats_), POOL_GAUGE(fake_stats_),\n                                        POOL_HISTOGRAM(fake_stats_))},\n               \"\",\n               fake_stats_},\n        tracing_stats_{CONN_MAN_TRACING_STATS(POOL_COUNTER(fake_stats_))},\n        listener_stats_{CONN_MAN_LISTENER_STATS(POOL_COUNTER(fake_listener_stats_))} {\n\n    http_context_.setTracer(tracer_);\n\n    ON_CALL(route_config_provider_, lastUpdated())\n        .WillByDefault(Return(test_time_.timeSystem().systemTime()));\n    ON_CALL(scoped_route_config_provider_, lastUpdated())\n        .WillByDefault(Return(test_time_.timeSystem().systemTime()));\n    // response_encoder_ is not a NiceMock on purpose. This prevents complaining about this\n    // method only.\n    EXPECT_CALL(response_encoder_, getStream()).Times(AtLeast(0));\n  }\n\n  ~HttpConnectionManagerImplTest() override {\n    filter_callbacks_.connection_.dispatcher_.clearDeferredDeleteList();\n  }\n\n  void setup(bool ssl, const std::string& server_name, bool tracing = true, bool use_srds = false) {\n    use_srds_ = use_srds;\n    if (ssl) {\n      ssl_connection_ = std::make_shared<Ssl::MockConnectionInfo>();\n    }\n\n    server_name_ = server_name;\n    ON_CALL(filter_callbacks_.connection_, ssl()).WillByDefault(Return(ssl_connection_));\n    ON_CALL(Const(filter_callbacks_.connection_), ssl()).WillByDefault(Return(ssl_connection_));\n    filter_callbacks_.connection_.local_address_ =\n        std::make_shared<Network::Address::Ipv4Instance>(\"127.0.0.1\");\n    filter_callbacks_.connection_.remote_address_ =\n        std::make_shared<Network::Address::Ipv4Instance>(\"0.0.0.0\");\n    conn_manager_ = std::make_unique<ConnectionManagerImpl>(\n        *this, drain_close_, random_, http_context_, runtime_, local_info_, cluster_manager_,\n        &overload_manager_, test_time_.timeSystem());\n    conn_manager_->initializeReadFilterCallbacks(filter_callbacks_);\n\n    if (tracing) {\n      envoy::type::FractionalPercent percent1;\n      percent1.set_numerator(100);\n      envoy::type::FractionalPercent percent2;\n      percent2.set_numerator(10000);\n      percent2.set_denominator(envoy::type::FractionalPercent::TEN_THOUSAND);\n      tracing_config_ = std::make_unique<TracingConnectionManagerConfig>(\n          TracingConnectionManagerConfig{Tracing::OperationName::Ingress,\n                                         {LowerCaseString(\":method\")},\n                                         percent1,\n                                         percent2,\n                                         percent1,\n                                         false,\n                                         256});\n    }\n  }\n\n  void setupFilterChain(int num_decoder_filters, int num_encoder_filters) {\n    // NOTE: The length/repetition in this routine allows InSequence to work correctly in an outer\n    // scope.\n    for (int i = 0; i < num_decoder_filters; i++) {\n      decoder_filters_.push_back(new MockStreamDecoderFilter());\n    }\n\n    for (int i = 0; i < num_encoder_filters; i++) {\n      encoder_filters_.push_back(new MockStreamEncoderFilter());\n    }\n\n    EXPECT_CALL(filter_factory_, createFilterChain(_))\n        .WillOnce(Invoke([num_decoder_filters, num_encoder_filters,\n                          this](FilterChainFactoryCallbacks& callbacks) -> void {\n          for (int i = 0; i < num_decoder_filters; i++) {\n            callbacks.addStreamDecoderFilter(StreamDecoderFilterSharedPtr{decoder_filters_[i]});\n          }\n\n          for (int i = 0; i < num_encoder_filters; i++) {\n            callbacks.addStreamEncoderFilter(StreamEncoderFilterSharedPtr{encoder_filters_[i]});\n          }\n        }));\n\n    for (int i = 0; i < num_decoder_filters; i++) {\n      EXPECT_CALL(*decoder_filters_[i], setDecoderFilterCallbacks(_));\n    }\n\n    for (int i = 0; i < num_encoder_filters; i++) {\n      EXPECT_CALL(*encoder_filters_[i], setEncoderFilterCallbacks(_));\n    }\n  }\n\n  void setUpBufferLimits() {\n    ON_CALL(response_encoder_, getStream()).WillByDefault(ReturnRef(stream_));\n    EXPECT_CALL(stream_, addCallbacks(_))\n        .WillOnce(Invoke(\n            [&](Http::StreamCallbacks& callbacks) -> void { stream_callbacks_ = &callbacks; }));\n    EXPECT_CALL(stream_, bufferLimit()).WillOnce(Return(initial_buffer_limit_));\n  }\n\n  // If request_with_data_and_trailers is true, includes data and trailers in the request. If\n  // decode_headers_stop_all is true, decoder_filters_[0]'s callback decodeHeaders() returns\n  // StopAllIterationAndBuffer.\n  void setUpEncoderAndDecoder(bool request_with_data_and_trailers, bool decode_headers_stop_all) {\n    setUpBufferLimits();\n    EXPECT_CALL(*codec_, dispatch(_))\n        .WillOnce(Invoke([&, request_with_data_and_trailers](Buffer::Instance&) -> void {\n          StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n          HeaderMapPtr headers{\n              new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n          if (request_with_data_and_trailers) {\n            decoder->decodeHeaders(std::move(headers), false);\n\n            Buffer::OwnedImpl fake_data(\"12345\");\n            decoder->decodeData(fake_data, false);\n\n            HeaderMapPtr trailers{new TestHeaderMapImpl{{\"foo\", \"bar\"}}};\n            decoder->decodeTrailers(std::move(trailers));\n          } else {\n            decoder->decodeHeaders(std::move(headers), true);\n          }\n        }));\n\n    setupFilterChain(2, 2);\n\n    EXPECT_CALL(*decoder_filters_[0], decodeHeaders(_, _))\n        .WillOnce(InvokeWithoutArgs([&, decode_headers_stop_all]() -> FilterHeadersStatus {\n          Buffer::OwnedImpl data(\"hello\");\n          decoder_filters_[0]->callbacks_->addDecodedData(data, true);\n          if (decode_headers_stop_all) {\n            return FilterHeadersStatus::StopAllIterationAndBuffer;\n          } else {\n            return FilterHeadersStatus::Continue;\n          }\n        }));\n    EXPECT_CALL(*decoder_filters_[0], decodeComplete());\n  }\n\n  Event::MockTimer* setUpTimer() {\n    // this timer belongs to whatever by whatever next creates a timer.\n    // See Envoy::Event::MockTimer for details.\n    return new Event::MockTimer(&filter_callbacks_.connection_.dispatcher_);\n  }\n\n  void sendRequestHeadersAndData() {\n    EXPECT_CALL(*decoder_filters_[1], decodeHeaders(_, false))\n        .WillOnce(Return(FilterHeadersStatus::StopIteration));\n    auto status = streaming_filter_ ? FilterDataStatus::StopIterationAndWatermark\n                                    : FilterDataStatus::StopIterationAndBuffer;\n    EXPECT_CALL(*decoder_filters_[1], decodeData(_, true)).WillOnce(Return(status));\n    EXPECT_CALL(*decoder_filters_[1], decodeComplete());\n\n    // Kick off the incoming data. |fake_input| is not sent, but instead kicks\n    // off sending the headers and |data| queued up in setUpEncoderAndDecoder().\n    Buffer::OwnedImpl fake_input(\"asdf\");\n    conn_manager_->onData(fake_input, false);\n  }\n\n  HeaderMap* sendResponseHeaders(HeaderMapPtr&& response_headers) {\n    HeaderMap* altered_response_headers = nullptr;\n\n    EXPECT_CALL(*encoder_filters_[0], encodeHeaders(_, _))\n        .WillOnce(Invoke([&](HeaderMap& headers, bool) -> FilterHeadersStatus {\n          altered_response_headers = &headers;\n          return FilterHeadersStatus::Continue;\n        }));\n    EXPECT_CALL(*encoder_filters_[1], encodeHeaders(_, false))\n        .WillOnce(Return(FilterHeadersStatus::Continue));\n    EXPECT_CALL(response_encoder_, encodeHeaders(_, false));\n    decoder_filters_[0]->callbacks_->encodeHeaders(std::move(response_headers), false);\n    return altered_response_headers;\n  }\n\n  void expectOnDestroy() {\n    for (auto filter : decoder_filters_) {\n      EXPECT_CALL(*filter, onDestroy());\n    }\n\n    auto setup_filter_expect = [](MockStreamEncoderFilter* filter) {\n      EXPECT_CALL(*filter, onDestroy());\n    };\n    std::for_each(encoder_filters_.rbegin(), encoder_filters_.rend(), setup_filter_expect);\n\n    EXPECT_CALL(filter_callbacks_.connection_.dispatcher_, deferredDelete_(_));\n  }\n\n  // Http::ConnectionManagerConfig\n  const std::list<AccessLog::InstanceSharedPtr>& accessLogs() override { return access_logs_; }\n  ServerConnectionPtr createCodec(Network::Connection&, const Buffer::Instance&,\n                                  ServerConnectionCallbacks&) override {\n    return ServerConnectionPtr{codec_};\n  }\n  DateProvider& dateProvider() override { return date_provider_; }\n  std::chrono::milliseconds drainTimeout() override { return std::chrono::milliseconds(100); }\n  FilterChainFactory& filterFactory() override { return filter_factory_; }\n  bool generateRequestId() override { return true; }\n  bool preserveExternalRequestId() const override { return false; }\n  uint32_t maxRequestHeadersKb() const override { return max_request_headers_kb_; }\n  absl::optional<std::chrono::milliseconds> idleTimeout() const override { return idle_timeout_; }\n  std::chrono::milliseconds streamIdleTimeout() const override { return stream_idle_timeout_; }\n  std::chrono::milliseconds requestTimeout() const override { return request_timeout_; }\n  std::chrono::milliseconds delayedCloseTimeout() const override { return delayed_close_timeout_; }\n  bool use_srds_{};\n  Router::RouteConfigProvider* routeConfigProvider() override {\n    if (use_srds_) {\n      return nullptr;\n    }\n    return &route_config_provider_;\n  }\n  Config::ConfigProvider* scopedRouteConfigProvider() override {\n    if (use_srds_) {\n      return &scoped_route_config_provider_;\n    }\n    return nullptr;\n  }\n  const std::string& serverName() override { return server_name_; }\n  HttpConnectionManagerProto::ServerHeaderTransformation serverHeaderTransformation() override {\n    return server_transformation_;\n  }\n  ConnectionManagerStats& stats() override { return stats_; }\n  ConnectionManagerTracingStats& tracingStats() override { return tracing_stats_; }\n  bool useRemoteAddress() override { return use_remote_address_; }\n  const Http::InternalAddressConfig& internalAddressConfig() const override {\n    return internal_address_config_;\n  }\n  uint32_t xffNumTrustedHops() const override { return 0; }\n  bool skipXffAppend() const override { return false; }\n  const std::string& via() const override { return EMPTY_STRING; }\n  Http::ForwardClientCertType forwardClientCert() override { return forward_client_cert_; }\n  const std::vector<Http::ClientCertDetailsType>& setCurrentClientCertDetails() const override {\n    return set_current_client_cert_details_;\n  }\n  const Network::Address::Instance& localAddress() override { return local_address_; }\n  const absl::optional<std::string>& userAgent() override { return user_agent_; }\n  const TracingConnectionManagerConfig* tracingConfig() override { return tracing_config_.get(); }\n  ConnectionManagerListenerStats& listenerStats() override { return listener_stats_; }\n  bool proxy100Continue() const override { return proxy_100_continue_; }\n  const Http::Http1Settings& http1Settings() const override { return http1_settings_; }\n  bool shouldNormalizePath() const override { return normalize_path_; }\n  bool shouldMergeSlashes() const override { return merge_slashes_; }\n\n  DangerousDeprecatedTestTime test_time_;\n  NiceMock<Router::MockRouteConfigProvider> route_config_provider_;\n  std::shared_ptr<Router::MockConfig> route_config_{new NiceMock<Router::MockConfig>()};\n  NiceMock<Router::MockScopedRouteConfigProvider> scoped_route_config_provider_;\n  NiceMock<Tracing::MockHttpTracer> tracer_;\n  Stats::IsolatedStoreImpl fake_stats_;\n  Http::ContextImpl http_context_;\n  NiceMock<Runtime::MockLoader> runtime_;\n  NiceMock<Envoy::AccessLog::MockAccessLogManager> log_manager_;\n  std::string access_log_path_;\n  std::list<AccessLog::InstanceSharedPtr> access_logs_;\n  NiceMock<Network::MockReadFilterCallbacks> filter_callbacks_;\n  MockServerConnection* codec_;\n  NiceMock<MockFilterChainFactory> filter_factory_;\n  ConnectionManagerStats stats_;\n  ConnectionManagerTracingStats tracing_stats_;\n  NiceMock<Network::MockDrainDecision> drain_close_;\n  std::unique_ptr<ConnectionManagerImpl> conn_manager_;\n  std::string server_name_;\n  HttpConnectionManagerProto::ServerHeaderTransformation server_transformation_{\n      HttpConnectionManagerProto::OVERWRITE};\n  Network::Address::Ipv4Instance local_address_{\"127.0.0.1\"};\n  bool use_remote_address_{true};\n  Http::DefaultInternalAddressConfig internal_address_config_;\n  Http::ForwardClientCertType forward_client_cert_{Http::ForwardClientCertType::Sanitize};\n  std::vector<Http::ClientCertDetailsType> set_current_client_cert_details_;\n  absl::optional<std::string> user_agent_;\n  uint32_t max_request_headers_kb_{Http::DEFAULT_MAX_REQUEST_HEADERS_KB};\n  absl::optional<std::chrono::milliseconds> idle_timeout_;\n  std::chrono::milliseconds stream_idle_timeout_{};\n  std::chrono::milliseconds request_timeout_{};\n  std::chrono::milliseconds delayed_close_timeout_{};\n  NiceMock<Runtime::MockRandomGenerator> random_;\n  NiceMock<LocalInfo::MockLocalInfo> local_info_;\n  NiceMock<Server::Configuration::MockFactoryContext> factory_context_;\n  std::shared_ptr<Ssl::MockConnectionInfo> ssl_connection_;\n  TracingConnectionManagerConfigPtr tracing_config_;\n  SlowDateProviderImpl date_provider_{test_time_.timeSystem()};\n  MockStream stream_;\n  Http::StreamCallbacks* stream_callbacks_{nullptr};\n  NiceMock<Upstream::MockClusterManager> cluster_manager_;\n  NiceMock<Server::MockOverloadManager> overload_manager_;\n  uint32_t initial_buffer_limit_{};\n  bool streaming_filter_{false};\n  Stats::IsolatedStoreImpl fake_listener_stats_;\n  ConnectionManagerListenerStats listener_stats_;\n  bool proxy_100_continue_ = false;\n  bool preserve_external_request_id_ = false;\n  Http::Http1Settings http1_settings_;\n  bool normalize_path_ = false;\n  bool merge_slashes_ = false;\n  NiceMock<Network::MockClientConnection> upstream_conn_; // for websocket tests\n  NiceMock<Tcp::ConnectionPool::MockInstance> conn_pool_; // for websocket tests\n\n  // TODO(mattklein123): Not all tests have been converted over to better setup. Convert the rest.\n  MockStreamEncoder response_encoder_;\n  std::vector<MockStreamDecoderFilter*> decoder_filters_;\n  std::vector<MockStreamEncoderFilter*> encoder_filters_;\n};\n\nTEST_F(HttpConnectionManagerImplTest, HeaderOnlyRequestAndResponse) {\n  setup(false, \"envoy-custom-server\", false);\n\n  // Store the basic request encoder during filter chain setup.\n  std::shared_ptr<MockStreamDecoderFilter> filter(new NiceMock<MockStreamDecoderFilter>());\n\n  EXPECT_CALL(*filter, decodeHeaders(_, true))\n      .Times(2)\n      .WillRepeatedly(Invoke([&](HeaderMap& headers, bool) -> FilterHeadersStatus {\n        EXPECT_NE(nullptr, headers.ForwardedFor());\n        EXPECT_EQ(\"http\", headers.ForwardedProto()->value().getStringView());\n        if (headers.Path()->value() == \"/healthcheck\") {\n          filter->callbacks_->streamInfo().healthCheck(true);\n        }\n\n        return FilterHeadersStatus::StopIteration;\n      }));\n\n  EXPECT_CALL(*filter, setDecoderFilterCallbacks(_)).Times(2);\n\n  EXPECT_CALL(filter_factory_, createFilterChain(_))\n      .Times(2)\n      .WillRepeatedly(Invoke([&](FilterChainFactoryCallbacks& callbacks) -> void {\n        callbacks.addStreamDecoderFilter(filter);\n      }));\n\n  EXPECT_CALL(filter_callbacks_.connection_.dispatcher_, deferredDelete_(_)).Times(2);\n\n  // When dispatch is called on the codec, we pretend to get a new stream and then fire a headers\n  // only request into it. Then we respond into the filter.\n  StreamDecoder* decoder = nullptr;\n  NiceMock<MockStreamEncoder> encoder;\n  EXPECT_CALL(*codec_, dispatch(_))\n      .Times(2)\n      .WillRepeatedly(Invoke([&](Buffer::Instance& data) -> void {\n        decoder = &conn_manager_->newStream(encoder);\n\n        // Test not charging stats on the second call.\n        if (data.length() == 4) {\n          HeaderMapPtr headers{\n              new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n          decoder->decodeHeaders(std::move(headers), true);\n        } else {\n          HeaderMapPtr headers{new TestHeaderMapImpl{\n              {\":authority\", \"host\"}, {\":path\", \"/healthcheck\"}, {\":method\", \"GET\"}}};\n          decoder->decodeHeaders(std::move(headers), true);\n        }\n\n        HeaderMapPtr response_headers{new TestHeaderMapImpl{{\":status\", \"200\"}}};\n        filter->callbacks_->encodeHeaders(std::move(response_headers), true);\n\n        // Drain 2 so that on the 2nd iteration we will hit zero.\n        data.drain(2);\n      }));\n\n  // Kick off the incoming data. Use extra data which should cause a redispatch.\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n\n  EXPECT_EQ(1U, stats_.named_.downstream_rq_2xx_.value());\n  EXPECT_EQ(1U, listener_stats_.downstream_rq_2xx_.value());\n  EXPECT_EQ(1U, stats_.named_.downstream_rq_completed_.value());\n  EXPECT_EQ(1U, listener_stats_.downstream_rq_completed_.value());\n}\n\nTEST_F(HttpConnectionManagerImplTest, 100ContinueResponse) {\n  proxy_100_continue_ = true;\n  setup(false, \"envoy-custom-server\", false);\n\n  // Store the basic request encoder during filter chain setup.\n  std::shared_ptr<MockStreamDecoderFilter> filter(new NiceMock<MockStreamDecoderFilter>());\n\n  EXPECT_CALL(*filter, decodeHeaders(_, true))\n      .WillRepeatedly(Invoke([&](HeaderMap& headers, bool) -> FilterHeadersStatus {\n        EXPECT_NE(nullptr, headers.ForwardedFor());\n        EXPECT_EQ(\"http\", headers.ForwardedProto()->value().getStringView());\n        return FilterHeadersStatus::StopIteration;\n      }));\n\n  EXPECT_CALL(*filter, setDecoderFilterCallbacks(_));\n\n  EXPECT_CALL(filter_factory_, createFilterChain(_))\n      .WillRepeatedly(Invoke([&](FilterChainFactoryCallbacks& callbacks) -> void {\n        callbacks.addStreamDecoderFilter(filter);\n      }));\n\n  EXPECT_CALL(filter_callbacks_.connection_.dispatcher_, deferredDelete_(_));\n\n  // When dispatch is called on the codec, we pretend to get a new stream and then fire a headers\n  // only request into it. Then we respond into the filter.\n  StreamDecoder* decoder = nullptr;\n  NiceMock<MockStreamEncoder> encoder;\n  EXPECT_CALL(*codec_, dispatch(_)).WillRepeatedly(Invoke([&](Buffer::Instance& data) -> void {\n    decoder = &conn_manager_->newStream(encoder);\n\n    // Test not charging stats on the second call.\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n    decoder->decodeHeaders(std::move(headers), true);\n\n    HeaderMapPtr continue_headers{new TestHeaderMapImpl{{\":status\", \"100\"}}};\n    filter->callbacks_->encode100ContinueHeaders(std::move(continue_headers));\n    HeaderMapPtr response_headers{new TestHeaderMapImpl{{\":status\", \"200\"}}};\n    filter->callbacks_->encodeHeaders(std::move(response_headers), true);\n\n    data.drain(4);\n  }));\n\n  // Kick off the incoming data.\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n\n  EXPECT_EQ(1U, stats_.named_.downstream_rq_1xx_.value());\n  EXPECT_EQ(1U, listener_stats_.downstream_rq_1xx_.value());\n  EXPECT_EQ(1U, stats_.named_.downstream_rq_2xx_.value());\n  EXPECT_EQ(1U, listener_stats_.downstream_rq_2xx_.value());\n  EXPECT_EQ(2U, stats_.named_.downstream_rq_completed_.value());\n  EXPECT_EQ(2U, listener_stats_.downstream_rq_completed_.value());\n}\n\nTEST_F(HttpConnectionManagerImplTest, 100ContinueResponseWithEncoderFiltersProxyingDisabled) {\n  proxy_100_continue_ = false;\n  setup(false, \"envoy-custom-server\", false);\n  setUpEncoderAndDecoder(false, false);\n  sendRequestHeadersAndData();\n\n  // Akin to 100ContinueResponseWithEncoderFilters below, but with\n  // proxy_100_continue_ false. Verify the filters do not get the 100 continue\n  // headers.\n  EXPECT_CALL(*encoder_filters_[0], encode100ContinueHeaders(_)).Times(0);\n  EXPECT_CALL(*encoder_filters_[1], encode100ContinueHeaders(_)).Times(0);\n  EXPECT_CALL(response_encoder_, encode100ContinueHeaders(_)).Times(0);\n  HeaderMapPtr continue_headers{new TestHeaderMapImpl{{\":status\", \"100\"}}};\n  decoder_filters_[0]->callbacks_->encode100ContinueHeaders(std::move(continue_headers));\n\n  EXPECT_CALL(*encoder_filters_[0], encodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(*encoder_filters_[1], encodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(response_encoder_, encodeHeaders(_, false));\n  HeaderMapPtr response_headers{new TestHeaderMapImpl{{\":status\", \"200\"}}};\n  decoder_filters_[0]->callbacks_->encodeHeaders(std::move(response_headers), false);\n}\n\nTEST_F(HttpConnectionManagerImplTest, 100ContinueResponseWithEncoderFilters) {\n  proxy_100_continue_ = true;\n  setup(false, \"envoy-custom-server\", false);\n  setUpEncoderAndDecoder(false, false);\n  sendRequestHeadersAndData();\n\n  EXPECT_CALL(*encoder_filters_[0], encode100ContinueHeaders(_))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(*encoder_filters_[1], encode100ContinueHeaders(_))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(response_encoder_, encode100ContinueHeaders(_));\n  HeaderMapPtr continue_headers{new TestHeaderMapImpl{{\":status\", \"100\"}}};\n  decoder_filters_[0]->callbacks_->encode100ContinueHeaders(std::move(continue_headers));\n\n  EXPECT_CALL(*encoder_filters_[0], encodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(*encoder_filters_[1], encodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(response_encoder_, encodeHeaders(_, false));\n  HeaderMapPtr response_headers{new TestHeaderMapImpl{{\":status\", \"200\"}}};\n  decoder_filters_[0]->callbacks_->encodeHeaders(std::move(response_headers), false);\n}\n\nTEST_F(HttpConnectionManagerImplTest, PauseResume100Continue) {\n  proxy_100_continue_ = true;\n  setup(false, \"envoy-custom-server\", false);\n  setUpEncoderAndDecoder(false, false);\n  sendRequestHeadersAndData();\n\n  // Stop the 100-Continue at encoder filter 1. Encoder filter 0 should not yet receive the\n  // 100-Continue\n  EXPECT_CALL(*encoder_filters_[1], encode100ContinueHeaders(_))\n      .WillOnce(Return(FilterHeadersStatus::StopIteration));\n  EXPECT_CALL(*encoder_filters_[0], encode100ContinueHeaders(_)).Times(0);\n  EXPECT_CALL(response_encoder_, encode100ContinueHeaders(_)).Times(0);\n  HeaderMapPtr continue_headers{new TestHeaderMapImpl{{\":status\", \"100\"}}};\n  decoder_filters_[1]->callbacks_->encode100ContinueHeaders(std::move(continue_headers));\n\n  // Have the encoder filter 1 continue. Make sure the 100-Continue is resumed as expected.\n  EXPECT_CALL(*encoder_filters_[0], encode100ContinueHeaders(_))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(response_encoder_, encode100ContinueHeaders(_));\n  encoder_filters_[1]->callbacks_->continueEncoding();\n\n  EXPECT_CALL(*encoder_filters_[1], encodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(*encoder_filters_[0], encodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(response_encoder_, encodeHeaders(_, false));\n  HeaderMapPtr response_headers{new TestHeaderMapImpl{{\":status\", \"200\"}}};\n  decoder_filters_[1]->callbacks_->encodeHeaders(std::move(response_headers), false);\n}\n\n// By default, Envoy will set the server header to the server name, here \"custom-value\"\nTEST_F(HttpConnectionManagerImplTest, ServerHeaderOverwritten) {\n  setup(false, \"custom-value\", false);\n  setUpEncoderAndDecoder(false, false);\n\n  sendRequestHeadersAndData();\n  const HeaderMap* altered_headers = sendResponseHeaders(\n      HeaderMapPtr{new TestHeaderMapImpl{{\":status\", \"200\"}, {\"server\", \"foo\"}}});\n  EXPECT_EQ(\"custom-value\", altered_headers->Server()->value().getStringView());\n}\n\n// When configured APPEND_IF_ABSENT if the server header is present it will be retained.\nTEST_F(HttpConnectionManagerImplTest, ServerHeaderAppendPresent) {\n  server_transformation_ = HttpConnectionManagerProto::APPEND_IF_ABSENT;\n  setup(false, \"custom-value\", false);\n  setUpEncoderAndDecoder(false, false);\n\n  sendRequestHeadersAndData();\n  const HeaderMap* altered_headers = sendResponseHeaders(\n      HeaderMapPtr{new TestHeaderMapImpl{{\":status\", \"200\"}, {\"server\", \"foo\"}}});\n  EXPECT_EQ(\"foo\", altered_headers->Server()->value().getStringView());\n}\n\n// When configured APPEND_IF_ABSENT if the server header is absent the server name will be set.\nTEST_F(HttpConnectionManagerImplTest, ServerHeaderAppendAbsent) {\n  server_transformation_ = HttpConnectionManagerProto::APPEND_IF_ABSENT;\n  setup(false, \"custom-value\", false);\n  setUpEncoderAndDecoder(false, false);\n\n  sendRequestHeadersAndData();\n  const HeaderMap* altered_headers =\n      sendResponseHeaders(HeaderMapPtr{new TestHeaderMapImpl{{\":status\", \"200\"}}});\n  EXPECT_EQ(\"custom-value\", altered_headers->Server()->value().getStringView());\n}\n\n// When configured PASS_THROUGH, the server name will pass through.\nTEST_F(HttpConnectionManagerImplTest, ServerHeaderPassthroughPresent) {\n  server_transformation_ = HttpConnectionManagerProto::PASS_THROUGH;\n  setup(false, \"custom-value\", false);\n  setUpEncoderAndDecoder(false, false);\n\n  sendRequestHeadersAndData();\n  const HeaderMap* altered_headers = sendResponseHeaders(\n      HeaderMapPtr{new TestHeaderMapImpl{{\":status\", \"200\"}, {\"server\", \"foo\"}}});\n  EXPECT_EQ(\"foo\", altered_headers->Server()->value().getStringView());\n}\n\n// When configured PASS_THROUGH, the server header will not be added if absent.\nTEST_F(HttpConnectionManagerImplTest, ServerHeaderPassthroughAbsent) {\n  server_transformation_ = HttpConnectionManagerProto::PASS_THROUGH;\n  setup(false, \"custom-value\", false);\n  setUpEncoderAndDecoder(false, false);\n\n  sendRequestHeadersAndData();\n  const HeaderMap* altered_headers =\n      sendResponseHeaders(HeaderMapPtr{new TestHeaderMapImpl{{\":status\", \"200\"}}});\n  EXPECT_TRUE(altered_headers->Server() == nullptr);\n}\n\nTEST_F(HttpConnectionManagerImplTest, InvalidPathWithDualFilter) {\n  InSequence s;\n  setup(false, \"\");\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance& data) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{new TestHeaderMapImpl{\n        {\":authority\", \"host\"}, {\":path\", \"http://api.lyft.com/\"}, {\":method\", \"GET\"}}};\n    decoder->decodeHeaders(std::move(headers), true);\n    data.drain(4);\n  }));\n\n  // This test also verifies that decoder/encoder filters have onDestroy() called only once.\n  auto* filter = new MockStreamFilter();\n  EXPECT_CALL(filter_factory_, createFilterChain(_))\n      .WillOnce(Invoke([&](FilterChainFactoryCallbacks& callbacks) -> void {\n        callbacks.addStreamFilter(StreamFilterSharedPtr{filter});\n      }));\n  EXPECT_CALL(*filter, setDecoderFilterCallbacks(_));\n  EXPECT_CALL(*filter, setEncoderFilterCallbacks(_));\n\n  EXPECT_CALL(*filter, encodeHeaders(_, true));\n  EXPECT_CALL(response_encoder_, encodeHeaders(_, true))\n      .WillOnce(Invoke([&](const HeaderMap& headers, bool) -> void {\n        EXPECT_EQ(\"404\", headers.Status()->value().getStringView());\n        EXPECT_EQ(\"absolute_path_rejected\",\n                  filter->decoder_callbacks_->streamInfo().responseCodeDetails().value());\n      }));\n  EXPECT_CALL(*filter, onDestroy());\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n}\n\n// Invalid paths are rejected with 400.\nTEST_F(HttpConnectionManagerImplTest, PathFailedtoSanitize) {\n  InSequence s;\n  setup(false, \"\");\n  // Enable path sanitizer\n  normalize_path_ = true;\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance& data) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"},\n                              {\":path\", \"/ab%00c\"}, // \"%00\" is not valid in path according to RFC\n                              {\":method\", \"GET\"}}};\n    decoder->decodeHeaders(std::move(headers), true);\n    data.drain(4);\n  }));\n\n  // This test also verifies that decoder/encoder filters have onDestroy() called only once.\n  auto* filter = new MockStreamFilter();\n  EXPECT_CALL(filter_factory_, createFilterChain(_))\n      .WillOnce(Invoke([&](FilterChainFactoryCallbacks& callbacks) -> void {\n        callbacks.addStreamFilter(StreamFilterSharedPtr{filter});\n      }));\n  EXPECT_CALL(*filter, setDecoderFilterCallbacks(_));\n  EXPECT_CALL(*filter, setEncoderFilterCallbacks(_));\n\n  EXPECT_CALL(*filter, encodeHeaders(_, true));\n  EXPECT_CALL(response_encoder_, encodeHeaders(_, true))\n      .WillOnce(Invoke([&](const HeaderMap& headers, bool) -> void {\n        EXPECT_EQ(\"400\", headers.Status()->value().getStringView());\n        EXPECT_EQ(\"path_normalization_failed\",\n                  filter->decoder_callbacks_->streamInfo().responseCodeDetails().value());\n      }));\n  EXPECT_CALL(*filter, onDestroy());\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n}\n\n// Filters observe normalized paths, not the original path, when path\n// normalization is configured.\nTEST_F(HttpConnectionManagerImplTest, FilterShouldUseSantizedPath) {\n  setup(false, \"\");\n  // Enable path sanitizer\n  normalize_path_ = true;\n  const std::string original_path = \"/x/%2E%2e/z\";\n  const std::string normalized_path = \"/z\";\n\n  auto* filter = new MockStreamFilter();\n\n  EXPECT_CALL(filter_factory_, createFilterChain(_))\n      .WillOnce(Invoke([&](FilterChainFactoryCallbacks& callbacks) -> void {\n        callbacks.addStreamDecoderFilter(StreamDecoderFilterSharedPtr{filter});\n      }));\n\n  EXPECT_CALL(*filter, decodeHeaders(_, true))\n      .WillRepeatedly(Invoke([&](HeaderMap& header_map, bool) -> FilterHeadersStatus {\n        EXPECT_EQ(normalized_path, header_map.Path()->value().getStringView());\n        return FilterHeadersStatus::StopIteration;\n      }));\n\n  EXPECT_CALL(*filter, setDecoderFilterCallbacks(_));\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{new TestHeaderMapImpl{\n        {\":authority\", \"host\"}, {\":path\", original_path}, {\":method\", \"GET\"}}};\n    decoder->decodeHeaders(std::move(headers), true);\n  }));\n\n  // Kick off the incoming data.\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n}\n\n// The router observes normalized paths, not the original path, when path\n// normalization is configured.\nTEST_F(HttpConnectionManagerImplTest, RouteShouldUseSantizedPath) {\n  setup(false, \"\");\n  // Enable path sanitizer\n  normalize_path_ = true;\n  const std::string original_path = \"/x/%2E%2e/z\";\n  const std::string normalized_path = \"/z\";\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{new TestHeaderMapImpl{\n        {\":authority\", \"host\"}, {\":path\", original_path}, {\":method\", \"GET\"}}};\n    decoder->decodeHeaders(std::move(headers), true);\n  }));\n\n  const std::string fake_cluster_name = \"fake_cluster\";\n\n  std::shared_ptr<Upstream::MockThreadLocalCluster> fake_cluster =\n      std::make_shared<NiceMock<Upstream::MockThreadLocalCluster>>();\n  std::shared_ptr<Router::MockRoute> route = std::make_shared<NiceMock<Router::MockRoute>>();\n  EXPECT_CALL(route->route_entry_, clusterName()).WillRepeatedly(ReturnRef(fake_cluster_name));\n\n  EXPECT_CALL(*route_config_provider_.route_config_, route(_, _))\n      .WillOnce(Invoke([&](const Http::HeaderMap& header_map, uint64_t) {\n        EXPECT_EQ(normalized_path, header_map.Path()->value().getStringView());\n        return route;\n      }));\n  EXPECT_CALL(filter_factory_, createFilterChain(_))\n      .WillOnce(Invoke([&](FilterChainFactoryCallbacks&) -> void {}));\n\n  // Kick off the incoming data.\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n}\n\nTEST_F(HttpConnectionManagerImplTest, StartAndFinishSpanNormalFlow) {\n  setup(false, \"\");\n\n  auto* span = new NiceMock<Tracing::MockSpan>();\n  EXPECT_CALL(tracer_, startSpan_(_, _, _, _))\n      .WillOnce(\n          Invoke([&](const Tracing::Config& config, const HeaderMap&, const StreamInfo::StreamInfo&,\n                     const Tracing::Decision) -> Tracing::Span* {\n            EXPECT_EQ(Tracing::OperationName::Ingress, config.operationName());\n\n            return span;\n          }));\n  // No decorator.\n  EXPECT_CALL(*route_config_provider_.route_config_->route_, decorator())\n      .WillRepeatedly(Return(nullptr));\n  EXPECT_CALL(*span, finishSpan());\n  EXPECT_CALL(*span, setTag(_, _)).Times(testing::AnyNumber());\n  // Verify tag is set based on the request headers.\n  EXPECT_CALL(*span, setTag(Eq(\":method\"), Eq(\"GET\")));\n  // Verify if the activeSpan interface returns reference to the current span.\n  EXPECT_CALL(*span, setTag(Eq(\"service-cluster\"), Eq(\"scoobydoo\")));\n  EXPECT_CALL(runtime_.snapshot_, featureEnabled(\"tracing.global_enabled\",\n                                                 An<const envoy::type::FractionalPercent&>(), _))\n      .WillOnce(Return(true));\n  EXPECT_CALL(*span, setOperation(_)).Times(0);\n\n  std::shared_ptr<MockStreamDecoderFilter> filter(new NiceMock<MockStreamDecoderFilter>());\n\n  EXPECT_CALL(filter_factory_, createFilterChain(_))\n      .WillRepeatedly(Invoke([&](FilterChainFactoryCallbacks& callbacks) -> void {\n        callbacks.addStreamDecoderFilter(filter);\n      }));\n\n  // Treat request as internal, otherwise x-request-id header will be overwritten.\n  use_remote_address_ = false;\n  EXPECT_CALL(random_, uuid()).Times(0);\n\n  StreamDecoder* decoder = nullptr;\n  NiceMock<MockStreamEncoder> encoder;\n  EXPECT_CALL(*codec_, dispatch(_)).WillRepeatedly(Invoke([&](Buffer::Instance& data) -> void {\n    decoder = &conn_manager_->newStream(encoder);\n\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":method\", \"GET\"},\n                              {\":authority\", \"host\"},\n                              {\":path\", \"/\"},\n                              {\"x-request-id\", \"125a4afb-6f55-a4ba-ad80-413f09f48a28\"}}};\n    decoder->decodeHeaders(std::move(headers), true);\n\n    HeaderMapPtr response_headers{new TestHeaderMapImpl{{\":status\", \"200\"}}};\n    filter->callbacks_->encodeHeaders(std::move(response_headers), true);\n    filter->callbacks_->activeSpan().setTag(\"service-cluster\", \"scoobydoo\");\n    data.drain(4);\n  }));\n\n  // Should be no 'x-envoy-decorator-operation' response header.\n  EXPECT_CALL(encoder, encodeHeaders(_, true))\n      .WillOnce(Invoke([](const HeaderMap& headers, bool) -> void {\n        EXPECT_EQ(nullptr, headers.EnvoyDecoratorOperation());\n      }));\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n\n  EXPECT_EQ(1UL, tracing_stats_.service_forced_.value());\n  EXPECT_EQ(0UL, tracing_stats_.random_sampling_.value());\n}\n\nTEST_F(HttpConnectionManagerImplTest, StartAndFinishSpanNormalFlowIngressDecorator) {\n  setup(false, \"\");\n\n  auto* span = new NiceMock<Tracing::MockSpan>();\n  EXPECT_CALL(tracer_, startSpan_(_, _, _, _))\n      .WillOnce(\n          Invoke([&](const Tracing::Config& config, const HeaderMap&, const StreamInfo::StreamInfo&,\n                     const Tracing::Decision) -> Tracing::Span* {\n            EXPECT_EQ(Tracing::OperationName::Ingress, config.operationName());\n\n            return span;\n          }));\n  route_config_provider_.route_config_->route_->decorator_.operation_ = \"testOp\";\n  EXPECT_CALL(*route_config_provider_.route_config_->route_, decorator()).Times(4);\n  EXPECT_CALL(route_config_provider_.route_config_->route_->decorator_, apply(_))\n      .WillOnce(Invoke(\n          [&](const Tracing::Span& apply_to_span) -> void { EXPECT_EQ(span, &apply_to_span); }));\n  EXPECT_CALL(*span, finishSpan());\n  EXPECT_CALL(*span, setTag(_, _)).Times(testing::AnyNumber());\n  EXPECT_CALL(runtime_.snapshot_, featureEnabled(\"tracing.global_enabled\",\n                                                 An<const envoy::type::FractionalPercent&>(), _))\n      .WillOnce(Return(true));\n  EXPECT_CALL(*span, setOperation(_)).Times(0);\n\n  std::shared_ptr<MockStreamDecoderFilter> filter(new NiceMock<MockStreamDecoderFilter>());\n\n  EXPECT_CALL(filter_factory_, createFilterChain(_))\n      .WillRepeatedly(Invoke([&](FilterChainFactoryCallbacks& callbacks) -> void {\n        callbacks.addStreamDecoderFilter(filter);\n      }));\n\n  // Treat request as internal, otherwise x-request-id header will be overwritten.\n  use_remote_address_ = false;\n  EXPECT_CALL(random_, uuid()).Times(0);\n\n  StreamDecoder* decoder = nullptr;\n  NiceMock<MockStreamEncoder> encoder;\n  EXPECT_CALL(*codec_, dispatch(_)).WillRepeatedly(Invoke([&](Buffer::Instance& data) -> void {\n    decoder = &conn_manager_->newStream(encoder);\n\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":method\", \"GET\"},\n                              {\":authority\", \"host\"},\n                              {\":path\", \"/\"},\n                              {\"x-request-id\", \"125a4afb-6f55-a4ba-ad80-413f09f48a28\"}}};\n    decoder->decodeHeaders(std::move(headers), true);\n\n    HeaderMapPtr response_headers{new TestHeaderMapImpl{{\":status\", \"200\"}}};\n    filter->callbacks_->encodeHeaders(std::move(response_headers), true);\n    filter->callbacks_->activeSpan().setTag(\"service-cluster\", \"scoobydoo\");\n    data.drain(4);\n  }));\n\n  // Verify decorator operation response header has been defined.\n  EXPECT_CALL(encoder, encodeHeaders(_, true))\n      .WillOnce(Invoke([](const HeaderMap& headers, bool) -> void {\n        EXPECT_EQ(\"testOp\", headers.EnvoyDecoratorOperation()->value().getStringView());\n      }));\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n}\n\nTEST_F(HttpConnectionManagerImplTest, StartAndFinishSpanNormalFlowIngressDecoratorOverrideOp) {\n  setup(false, \"\");\n\n  auto* span = new NiceMock<Tracing::MockSpan>();\n  EXPECT_CALL(tracer_, startSpan_(_, _, _, _))\n      .WillOnce(\n          Invoke([&](const Tracing::Config& config, const HeaderMap&, const StreamInfo::StreamInfo&,\n                     const Tracing::Decision) -> Tracing::Span* {\n            EXPECT_EQ(Tracing::OperationName::Ingress, config.operationName());\n\n            return span;\n          }));\n  route_config_provider_.route_config_->route_->decorator_.operation_ = \"initOp\";\n  EXPECT_CALL(*route_config_provider_.route_config_->route_, decorator()).Times(4);\n  EXPECT_CALL(route_config_provider_.route_config_->route_->decorator_, apply(_))\n      .WillOnce(Invoke(\n          [&](const Tracing::Span& apply_to_span) -> void { EXPECT_EQ(span, &apply_to_span); }));\n  EXPECT_CALL(*span, finishSpan());\n  EXPECT_CALL(*span, setTag(_, _)).Times(testing::AnyNumber());\n  EXPECT_CALL(runtime_.snapshot_, featureEnabled(\"tracing.global_enabled\",\n                                                 An<const envoy::type::FractionalPercent&>(), _))\n      .WillOnce(Return(true));\n  EXPECT_CALL(*span, setOperation(Eq(\"testOp\")));\n\n  std::shared_ptr<MockStreamDecoderFilter> filter(new NiceMock<MockStreamDecoderFilter>());\n\n  EXPECT_CALL(filter_factory_, createFilterChain(_))\n      .WillRepeatedly(Invoke([&](FilterChainFactoryCallbacks& callbacks) -> void {\n        callbacks.addStreamDecoderFilter(filter);\n      }));\n\n  // Treat request as internal, otherwise x-request-id header will be overwritten.\n  use_remote_address_ = false;\n  EXPECT_CALL(random_, uuid()).Times(0);\n\n  StreamDecoder* decoder = nullptr;\n  NiceMock<MockStreamEncoder> encoder;\n  EXPECT_CALL(*codec_, dispatch(_)).WillRepeatedly(Invoke([&](Buffer::Instance& data) -> void {\n    decoder = &conn_manager_->newStream(encoder);\n\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":method\", \"GET\"},\n                              {\":authority\", \"host\"},\n                              {\":path\", \"/\"},\n                              {\"x-request-id\", \"125a4afb-6f55-a4ba-ad80-413f09f48a28\"},\n                              {\"x-envoy-decorator-operation\", \"testOp\"}}};\n    decoder->decodeHeaders(std::move(headers), true);\n\n    HeaderMapPtr response_headers{new TestHeaderMapImpl{{\":status\", \"200\"}}};\n    filter->callbacks_->encodeHeaders(std::move(response_headers), true);\n    filter->callbacks_->activeSpan().setTag(\"service-cluster\", \"scoobydoo\");\n\n    data.drain(4);\n  }));\n\n  // Should be no 'x-envoy-decorator-operation' response header, as decorator\n  // was overridden by request header.\n  EXPECT_CALL(encoder, encodeHeaders(_, true))\n      .WillOnce(Invoke([](const HeaderMap& headers, bool) -> void {\n        EXPECT_EQ(nullptr, headers.EnvoyDecoratorOperation());\n      }));\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n}\n\nTEST_F(HttpConnectionManagerImplTest, StartAndFinishSpanNormalFlowEgressDecorator) {\n  setup(false, \"\");\n  envoy::type::FractionalPercent percent1;\n  percent1.set_numerator(100);\n  envoy::type::FractionalPercent percent2;\n  percent2.set_numerator(10000);\n  percent2.set_denominator(envoy::type::FractionalPercent::TEN_THOUSAND);\n  tracing_config_ = std::make_unique<TracingConnectionManagerConfig>(\n      TracingConnectionManagerConfig{Tracing::OperationName::Egress,\n                                     {LowerCaseString(\":method\")},\n                                     percent1,\n                                     percent2,\n                                     percent1,\n                                     false,\n                                     256});\n\n  auto* span = new NiceMock<Tracing::MockSpan>();\n  EXPECT_CALL(tracer_, startSpan_(_, _, _, _))\n      .WillOnce(\n          Invoke([&](const Tracing::Config& config, const HeaderMap&, const StreamInfo::StreamInfo&,\n                     const Tracing::Decision) -> Tracing::Span* {\n            EXPECT_EQ(Tracing::OperationName::Egress, config.operationName());\n\n            return span;\n          }));\n  route_config_provider_.route_config_->route_->decorator_.operation_ = \"testOp\";\n  EXPECT_CALL(*route_config_provider_.route_config_->route_, decorator()).Times(4);\n  EXPECT_CALL(route_config_provider_.route_config_->route_->decorator_, apply(_))\n      .WillOnce(Invoke(\n          [&](const Tracing::Span& apply_to_span) -> void { EXPECT_EQ(span, &apply_to_span); }));\n  EXPECT_CALL(*span, finishSpan());\n  EXPECT_CALL(*span, setTag(_, _)).Times(testing::AnyNumber());\n  EXPECT_CALL(runtime_.snapshot_, featureEnabled(\"tracing.global_enabled\",\n                                                 An<const envoy::type::FractionalPercent&>(), _))\n      .WillOnce(Return(true));\n  EXPECT_CALL(*span, setOperation(_)).Times(0);\n\n  std::shared_ptr<MockStreamDecoderFilter> filter(new NiceMock<MockStreamDecoderFilter>());\n\n  EXPECT_CALL(filter_factory_, createFilterChain(_))\n      .WillRepeatedly(Invoke([&](FilterChainFactoryCallbacks& callbacks) -> void {\n        callbacks.addStreamDecoderFilter(filter);\n      }));\n\n  // Treat request as internal, otherwise x-request-id header will be overwritten.\n  use_remote_address_ = false;\n  EXPECT_CALL(random_, uuid()).Times(0);\n\n  StreamDecoder* decoder = nullptr;\n  NiceMock<MockStreamEncoder> encoder;\n  EXPECT_CALL(*codec_, dispatch(_)).WillRepeatedly(Invoke([&](Buffer::Instance& data) -> void {\n    decoder = &conn_manager_->newStream(encoder);\n\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":method\", \"GET\"},\n                              {\":authority\", \"host\"},\n                              {\":path\", \"/\"},\n                              {\"x-request-id\", \"125a4afb-6f55-a4ba-ad80-413f09f48a28\"}}};\n    decoder->decodeHeaders(std::move(headers), true);\n\n    HeaderMapPtr response_headers{new TestHeaderMapImpl{{\":status\", \"200\"}}};\n    filter->callbacks_->encodeHeaders(std::move(response_headers), true);\n    filter->callbacks_->activeSpan().setTag(\"service-cluster\", \"scoobydoo\");\n\n    data.drain(4);\n  }));\n\n  EXPECT_CALL(*filter, decodeHeaders(_, true))\n      .WillOnce(Invoke([](HeaderMap& headers, bool) -> FilterHeadersStatus {\n        EXPECT_NE(nullptr, headers.EnvoyDecoratorOperation());\n        // Verify that decorator operation has been set as request header.\n        EXPECT_EQ(\"testOp\", headers.EnvoyDecoratorOperation()->value().getStringView());\n        return FilterHeadersStatus::StopIteration;\n      }));\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n}\n\nTEST_F(HttpConnectionManagerImplTest, StartAndFinishSpanNormalFlowEgressDecoratorOverrideOp) {\n  setup(false, \"\");\n  envoy::type::FractionalPercent percent1;\n  percent1.set_numerator(100);\n  envoy::type::FractionalPercent percent2;\n  percent2.set_numerator(10000);\n  percent2.set_denominator(envoy::type::FractionalPercent::TEN_THOUSAND);\n  tracing_config_ = std::make_unique<TracingConnectionManagerConfig>(\n      TracingConnectionManagerConfig{Tracing::OperationName::Egress,\n                                     {LowerCaseString(\":method\")},\n                                     percent1,\n                                     percent2,\n                                     percent1,\n                                     false,\n                                     256});\n\n  auto* span = new NiceMock<Tracing::MockSpan>();\n  EXPECT_CALL(tracer_, startSpan_(_, _, _, _))\n      .WillOnce(\n          Invoke([&](const Tracing::Config& config, const HeaderMap&, const StreamInfo::StreamInfo&,\n                     const Tracing::Decision) -> Tracing::Span* {\n            EXPECT_EQ(Tracing::OperationName::Egress, config.operationName());\n\n            return span;\n          }));\n  route_config_provider_.route_config_->route_->decorator_.operation_ = \"initOp\";\n  EXPECT_CALL(*route_config_provider_.route_config_->route_, decorator()).Times(4);\n  EXPECT_CALL(route_config_provider_.route_config_->route_->decorator_, apply(_))\n      .WillOnce(Invoke(\n          [&](const Tracing::Span& apply_to_span) -> void { EXPECT_EQ(span, &apply_to_span); }));\n  EXPECT_CALL(*span, finishSpan());\n  EXPECT_CALL(*span, setTag(_, _)).Times(testing::AnyNumber());\n  EXPECT_CALL(runtime_.snapshot_, featureEnabled(\"tracing.global_enabled\",\n                                                 An<const envoy::type::FractionalPercent&>(), _))\n      .WillOnce(Return(true));\n  // Verify that span operation overridden by value supplied in response header.\n  EXPECT_CALL(*span, setOperation(Eq(\"testOp\")));\n\n  std::shared_ptr<MockStreamDecoderFilter> filter(new NiceMock<MockStreamDecoderFilter>());\n\n  EXPECT_CALL(filter_factory_, createFilterChain(_))\n      .WillRepeatedly(Invoke([&](FilterChainFactoryCallbacks& callbacks) -> void {\n        callbacks.addStreamDecoderFilter(filter);\n      }));\n\n  // Treat request as internal, otherwise x-request-id header will be overwritten.\n  use_remote_address_ = false;\n  EXPECT_CALL(random_, uuid()).Times(0);\n\n  StreamDecoder* decoder = nullptr;\n  NiceMock<MockStreamEncoder> encoder;\n  EXPECT_CALL(*codec_, dispatch(_)).WillRepeatedly(Invoke([&](Buffer::Instance& data) -> void {\n    decoder = &conn_manager_->newStream(encoder);\n\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":method\", \"GET\"},\n                              {\":authority\", \"host\"},\n                              {\":path\", \"/\"},\n                              {\"x-request-id\", \"125a4afb-6f55-a4ba-ad80-413f09f48a28\"}}};\n    decoder->decodeHeaders(std::move(headers), true);\n\n    HeaderMapPtr response_headers{\n        new TestHeaderMapImpl{{\":status\", \"200\"}, {\"x-envoy-decorator-operation\", \"testOp\"}}};\n    filter->callbacks_->encodeHeaders(std::move(response_headers), true);\n    filter->callbacks_->activeSpan().setTag(\"service-cluster\", \"scoobydoo\");\n\n    data.drain(4);\n  }));\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n}\n\nTEST_F(HttpConnectionManagerImplTest,\n       StartAndFinishSpanNormalFlowEgressDecoratorOverrideOpNoActiveSpan) {\n  setup(false, \"\");\n  envoy::type::FractionalPercent percent1;\n  percent1.set_numerator(100);\n  envoy::type::FractionalPercent percent2;\n  percent2.set_numerator(10000);\n  percent2.set_denominator(envoy::type::FractionalPercent::TEN_THOUSAND);\n  tracing_config_ = std::make_unique<TracingConnectionManagerConfig>(\n      TracingConnectionManagerConfig{Tracing::OperationName::Egress,\n                                     {LowerCaseString(\":method\")},\n                                     percent1,\n                                     percent2,\n                                     percent1,\n                                     false,\n                                     256});\n\n  EXPECT_CALL(runtime_.snapshot_, featureEnabled(\"tracing.global_enabled\",\n                                                 An<const envoy::type::FractionalPercent&>(), _))\n      .WillOnce(Return(false));\n  std::shared_ptr<MockStreamDecoderFilter> filter(new NiceMock<MockStreamDecoderFilter>());\n\n  EXPECT_CALL(filter_factory_, createFilterChain(_))\n      .WillRepeatedly(Invoke([&](FilterChainFactoryCallbacks& callbacks) -> void {\n        callbacks.addStreamDecoderFilter(filter);\n      }));\n\n  // Treat request as internal, otherwise x-request-id header will be overwritten.\n  use_remote_address_ = false;\n  EXPECT_CALL(random_, uuid()).Times(0);\n\n  StreamDecoder* decoder = nullptr;\n  NiceMock<MockStreamEncoder> encoder;\n  EXPECT_CALL(*codec_, dispatch(_)).WillRepeatedly(Invoke([&](Buffer::Instance& data) -> void {\n    decoder = &conn_manager_->newStream(encoder);\n\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":method\", \"GET\"},\n                              {\":authority\", \"host\"},\n                              {\":path\", \"/\"},\n                              {\"x-request-id\", \"125a4afb-6f55-a4ba-ad80-413f09f48a28\"}}};\n    decoder->decodeHeaders(std::move(headers), true);\n\n    HeaderMapPtr response_headers{\n        new TestHeaderMapImpl{{\":status\", \"200\"}, {\"x-envoy-decorator-operation\", \"testOp\"}}};\n    filter->callbacks_->encodeHeaders(std::move(response_headers), true);\n\n    data.drain(4);\n  }));\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n}\n\nTEST_F(HttpConnectionManagerImplTest, TestAccessLog) {\n  static constexpr char local_address[] = \"0.0.0.0\";\n  static constexpr char xff_address[] = \"1.2.3.4\";\n\n  // stream_info.downstreamRemoteAddress will infer the address from request\n  // headers instead of the physical connection\n  use_remote_address_ = false;\n  setup(false, \"\");\n\n  std::shared_ptr<MockStreamDecoderFilter> filter(new NiceMock<MockStreamDecoderFilter>());\n  std::shared_ptr<AccessLog::MockInstance> handler(new NiceMock<AccessLog::MockInstance>());\n\n  EXPECT_CALL(filter_factory_, createFilterChain(_))\n      .WillOnce(Invoke([&](FilterChainFactoryCallbacks& callbacks) -> void {\n        callbacks.addStreamDecoderFilter(filter);\n        callbacks.addAccessLogHandler(handler);\n      }));\n\n  EXPECT_CALL(*handler, log(_, _, _, _))\n      .WillOnce(Invoke([](const HeaderMap*, const HeaderMap*, const HeaderMap*,\n                          const StreamInfo::StreamInfo& stream_info) {\n        EXPECT_TRUE(stream_info.responseCode());\n        EXPECT_EQ(stream_info.responseCode().value(), uint32_t(200));\n        EXPECT_NE(nullptr, stream_info.downstreamLocalAddress());\n        EXPECT_NE(nullptr, stream_info.downstreamRemoteAddress());\n        EXPECT_NE(nullptr, stream_info.downstreamDirectRemoteAddress());\n        EXPECT_NE(nullptr, stream_info.routeEntry());\n\n        EXPECT_EQ(stream_info.downstreamRemoteAddress()->ip()->addressAsString(), xff_address);\n        EXPECT_EQ(stream_info.downstreamDirectRemoteAddress()->ip()->addressAsString(),\n                  local_address);\n      }));\n\n  StreamDecoder* decoder = nullptr;\n  NiceMock<MockStreamEncoder> encoder;\n  EXPECT_CALL(*codec_, dispatch(_)).WillRepeatedly(Invoke([&](Buffer::Instance& data) -> void {\n    decoder = &conn_manager_->newStream(encoder);\n\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":method\", \"GET\"},\n                              {\":authority\", \"host\"},\n                              {\":path\", \"/\"},\n                              {\"x-forwarded-for\", xff_address},\n                              {\"x-request-id\", \"125a4afb-6f55-a4ba-ad80-413f09f48a28\"}}};\n    decoder->decodeHeaders(std::move(headers), true);\n\n    HeaderMapPtr response_headers{new TestHeaderMapImpl{{\":status\", \"200\"}}};\n    filter->callbacks_->encodeHeaders(std::move(response_headers), true);\n\n    data.drain(4);\n  }));\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n}\n\nTEST_F(HttpConnectionManagerImplTest, TestDownstreamDisconnectAccessLog) {\n  setup(false, \"\");\n\n  std::shared_ptr<MockStreamDecoderFilter> filter(new NiceMock<MockStreamDecoderFilter>());\n  std::shared_ptr<AccessLog::MockInstance> handler(new NiceMock<AccessLog::MockInstance>());\n\n  EXPECT_CALL(filter_factory_, createFilterChain(_))\n      .WillOnce(Invoke([&](FilterChainFactoryCallbacks& callbacks) -> void {\n        callbacks.addStreamDecoderFilter(filter);\n        callbacks.addAccessLogHandler(handler);\n      }));\n\n  EXPECT_CALL(*handler, log(_, _, _, _))\n      .WillOnce(Invoke([](const HeaderMap*, const HeaderMap*, const HeaderMap*,\n                          const StreamInfo::StreamInfo& stream_info) {\n        EXPECT_FALSE(stream_info.responseCode());\n        EXPECT_TRUE(stream_info.hasAnyResponseFlag());\n        EXPECT_TRUE(\n            stream_info.hasResponseFlag(StreamInfo::ResponseFlag::DownstreamConnectionTermination));\n      }));\n\n  StreamDecoder* decoder = nullptr;\n  NiceMock<MockStreamEncoder> encoder;\n  EXPECT_CALL(*codec_, dispatch(_)).WillRepeatedly(Invoke([&](Buffer::Instance& data) -> void {\n    decoder = &conn_manager_->newStream(encoder);\n\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":method\", \"GET\"}, {\":authority\", \"host\"}, {\":path\", \"/\"}}};\n    decoder->decodeHeaders(std::move(headers), true);\n\n    data.drain(4);\n  }));\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n}\n\nTEST_F(HttpConnectionManagerImplTest, TestAccessLogWithTrailers) {\n  setup(false, \"\");\n\n  std::shared_ptr<MockStreamDecoderFilter> filter(new NiceMock<MockStreamDecoderFilter>());\n  std::shared_ptr<AccessLog::MockInstance> handler(new NiceMock<AccessLog::MockInstance>());\n\n  EXPECT_CALL(filter_factory_, createFilterChain(_))\n      .WillOnce(Invoke([&](FilterChainFactoryCallbacks& callbacks) -> void {\n        callbacks.addStreamDecoderFilter(filter);\n        callbacks.addAccessLogHandler(handler);\n      }));\n\n  EXPECT_CALL(*handler, log(_, _, _, _))\n      .WillOnce(Invoke([](const HeaderMap*, const HeaderMap*, const HeaderMap*,\n                          const StreamInfo::StreamInfo& stream_info) {\n        EXPECT_TRUE(stream_info.responseCode());\n        EXPECT_EQ(stream_info.responseCode().value(), uint32_t(200));\n        EXPECT_NE(nullptr, stream_info.downstreamLocalAddress());\n        EXPECT_NE(nullptr, stream_info.downstreamRemoteAddress());\n        EXPECT_NE(nullptr, stream_info.downstreamDirectRemoteAddress());\n        EXPECT_NE(nullptr, stream_info.routeEntry());\n      }));\n\n  StreamDecoder* decoder = nullptr;\n  NiceMock<MockStreamEncoder> encoder;\n  EXPECT_CALL(*codec_, dispatch(_)).WillRepeatedly(Invoke([&](Buffer::Instance& data) -> void {\n    decoder = &conn_manager_->newStream(encoder);\n\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":method\", \"GET\"},\n                              {\":authority\", \"host\"},\n                              {\":path\", \"/\"},\n                              {\"x-request-id\", \"125a4afb-6f55-a4ba-ad80-413f09f48a28\"}}};\n    decoder->decodeHeaders(std::move(headers), true);\n\n    HeaderMapPtr response_headers{new TestHeaderMapImpl{{\":status\", \"200\"}}};\n    filter->callbacks_->encodeHeaders(std::move(response_headers), false);\n\n    HeaderMapPtr response_trailers{new TestHeaderMapImpl{{\"x-trailer\", \"1\"}}};\n    filter->callbacks_->encodeTrailers(std::move(response_trailers));\n\n    data.drain(4);\n  }));\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n}\n\nTEST_F(HttpConnectionManagerImplTest, TestAccessLogWithInvalidRequest) {\n  setup(false, \"\");\n\n  std::shared_ptr<MockStreamDecoderFilter> filter(new NiceMock<MockStreamDecoderFilter>());\n  std::shared_ptr<AccessLog::MockInstance> handler(new NiceMock<AccessLog::MockInstance>());\n\n  EXPECT_CALL(filter_factory_, createFilterChain(_))\n      .WillOnce(Invoke([&](FilterChainFactoryCallbacks& callbacks) -> void {\n        callbacks.addStreamDecoderFilter(filter);\n        callbacks.addAccessLogHandler(handler);\n      }));\n\n  EXPECT_CALL(*handler, log(_, _, _, _))\n      .WillOnce(Invoke([](const HeaderMap*, const HeaderMap*, const HeaderMap*,\n                          const StreamInfo::StreamInfo& stream_info) {\n        EXPECT_TRUE(stream_info.responseCode());\n        EXPECT_EQ(stream_info.responseCode().value(), uint32_t(400));\n        EXPECT_EQ(\"missing_host_header\", stream_info.responseCodeDetails().value());\n        EXPECT_NE(nullptr, stream_info.downstreamLocalAddress());\n        EXPECT_NE(nullptr, stream_info.downstreamRemoteAddress());\n        EXPECT_NE(nullptr, stream_info.downstreamDirectRemoteAddress());\n        EXPECT_EQ(nullptr, stream_info.routeEntry());\n      }));\n\n  StreamDecoder* decoder = nullptr;\n  NiceMock<MockStreamEncoder> encoder;\n  EXPECT_CALL(*codec_, dispatch(_)).WillRepeatedly(Invoke([&](Buffer::Instance& data) -> void {\n    decoder = &conn_manager_->newStream(encoder);\n\n    // These request headers are missing the necessary \":host\"\n    HeaderMapPtr headers{new TestHeaderMapImpl{{\":method\", \"GET\"}, {\":path\", \"/\"}}};\n    decoder->decodeHeaders(std::move(headers), true);\n    data.drain(0);\n  }));\n\n  Buffer::OwnedImpl fake_input;\n  conn_manager_->onData(fake_input, false);\n}\n\nTEST_F(HttpConnectionManagerImplTest, TestAccessLogSsl) {\n  setup(true, \"\");\n\n  std::shared_ptr<MockStreamDecoderFilter> filter(new NiceMock<MockStreamDecoderFilter>());\n  std::shared_ptr<AccessLog::MockInstance> handler(new NiceMock<AccessLog::MockInstance>());\n\n  EXPECT_CALL(filter_factory_, createFilterChain(_))\n      .WillOnce(Invoke([&](FilterChainFactoryCallbacks& callbacks) -> void {\n        callbacks.addStreamDecoderFilter(filter);\n        callbacks.addAccessLogHandler(handler);\n      }));\n\n  EXPECT_CALL(*handler, log(_, _, _, _))\n      .WillOnce(Invoke([](const HeaderMap*, const HeaderMap*, const HeaderMap*,\n                          const StreamInfo::StreamInfo& stream_info) {\n        EXPECT_TRUE(stream_info.responseCode());\n        EXPECT_EQ(stream_info.responseCode().value(), uint32_t(200));\n        EXPECT_NE(nullptr, stream_info.downstreamLocalAddress());\n        EXPECT_NE(nullptr, stream_info.downstreamRemoteAddress());\n        EXPECT_NE(nullptr, stream_info.downstreamDirectRemoteAddress());\n        EXPECT_NE(nullptr, stream_info.downstreamSslConnection());\n        EXPECT_NE(nullptr, stream_info.routeEntry());\n      }));\n\n  StreamDecoder* decoder = nullptr;\n  NiceMock<MockStreamEncoder> encoder;\n  EXPECT_CALL(*codec_, dispatch(_)).WillRepeatedly(Invoke([&](Buffer::Instance& data) -> void {\n    decoder = &conn_manager_->newStream(encoder);\n\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":method\", \"GET\"},\n                              {\":authority\", \"host\"},\n                              {\":path\", \"/\"},\n                              {\"x-request-id\", \"125a4afb-6f55-a4ba-ad80-413f09f48a28\"}}};\n    decoder->decodeHeaders(std::move(headers), true);\n\n    HeaderMapPtr response_headers{new TestHeaderMapImpl{{\":status\", \"200\"}}};\n    filter->callbacks_->encodeHeaders(std::move(response_headers), false);\n\n    HeaderMapPtr response_trailers{new TestHeaderMapImpl{{\"x-trailer\", \"1\"}}};\n    filter->callbacks_->encodeTrailers(std::move(response_trailers));\n\n    data.drain(4);\n  }));\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n}\n\nTEST_F(HttpConnectionManagerImplTest, DoNotStartSpanIfTracingIsNotEnabled) {\n  setup(false, \"\");\n\n  // Disable tracing.\n  tracing_config_.reset();\n\n  EXPECT_CALL(tracer_, startSpan_(_, _, _, _)).Times(0);\n  ON_CALL(runtime_.snapshot_,\n          featureEnabled(\"tracing.global_enabled\", An<const envoy::type::FractionalPercent&>(), _))\n      .WillByDefault(Return(true));\n\n  std::shared_ptr<MockStreamDecoderFilter> filter(new NiceMock<MockStreamDecoderFilter>());\n\n  EXPECT_CALL(filter_factory_, createFilterChain(_))\n      .WillRepeatedly(Invoke([&](FilterChainFactoryCallbacks& callbacks) -> void {\n        callbacks.addStreamDecoderFilter(filter);\n      }));\n\n  StreamDecoder* decoder = nullptr;\n  NiceMock<MockStreamEncoder> encoder;\n  EXPECT_CALL(*codec_, dispatch(_)).WillRepeatedly(Invoke([&](Buffer::Instance& data) -> void {\n    decoder = &conn_manager_->newStream(encoder);\n\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":method\", \"GET\"},\n                              {\":authority\", \"host\"},\n                              {\":path\", \"/\"},\n                              {\"x-request-id\", \"125a4afb-6f55-a4ba-ad80-413f09f48a28\"}}};\n    decoder->decodeHeaders(std::move(headers), true);\n\n    HeaderMapPtr response_headers{new TestHeaderMapImpl{{\":status\", \"200\"}}};\n    filter->callbacks_->encodeHeaders(std::move(response_headers), true);\n\n    data.drain(4);\n  }));\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n}\n\nTEST_F(HttpConnectionManagerImplTest, NoPath) {\n  setup(false, \"\");\n\n  StreamDecoder* decoder = nullptr;\n  NiceMock<MockStreamEncoder> encoder;\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance& data) -> void {\n    decoder = &conn_manager_->newStream(encoder);\n    HeaderMapPtr headers{new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":method\", \"CONNECT\"}}};\n    decoder->decodeHeaders(std::move(headers), true);\n    data.drain(4);\n  }));\n\n  EXPECT_CALL(encoder, encodeHeaders(_, true))\n      .WillOnce(Invoke([](const HeaderMap& headers, bool) -> void {\n        EXPECT_EQ(\"404\", headers.Status()->value().getStringView());\n      }));\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n}\n\n// No idle timeout when route idle timeout is implied at both global and\n// per-route level. The connection manager config is responsible for managing\n// the default configuration aspects.\nTEST_F(HttpConnectionManagerImplTest, PerStreamIdleTimeoutNotConfigured) {\n  setup(false, \"\");\n\n  EXPECT_CALL(filter_callbacks_.connection_.dispatcher_, createTimer_(_)).Times(0);\n  EXPECT_CALL(*codec_, dispatch(_)).WillRepeatedly(Invoke([&](Buffer::Instance& data) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n    decoder->decodeHeaders(std::move(headers), false);\n\n    data.drain(4);\n  }));\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n\n  EXPECT_EQ(0U, stats_.named_.downstream_rq_idle_timeout_.value());\n}\n\n// When the global timeout is configured, the timer is enabled before we receive\n// headers, if it fires we don't faceplant.\nTEST_F(HttpConnectionManagerImplTest, PerStreamIdleTimeoutGlobal) {\n  stream_idle_timeout_ = std::chrono::milliseconds(10);\n  setup(false, \"\");\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillRepeatedly(Invoke([&](Buffer::Instance&) -> void {\n    Event::MockTimer* idle_timer = setUpTimer();\n    EXPECT_CALL(*idle_timer, enableTimer(std::chrono::milliseconds(10), _));\n    conn_manager_->newStream(response_encoder_);\n\n    // Expect resetIdleTimer() to be called for the response\n    // encodeHeaders()/encodeData().\n    EXPECT_CALL(*idle_timer, enableTimer(_, _)).Times(2);\n    EXPECT_CALL(*idle_timer, disableTimer());\n    idle_timer->invokeCallback();\n  }));\n\n  // 408 direct response after timeout.\n  EXPECT_CALL(response_encoder_, encodeHeaders(_, false))\n      .WillOnce(Invoke([](const HeaderMap& headers, bool) -> void {\n        EXPECT_EQ(\"408\", headers.Status()->value().getStringView());\n      }));\n  std::string response_body;\n  EXPECT_CALL(response_encoder_, encodeData(_, true)).WillOnce(AddBufferToString(&response_body));\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n\n  EXPECT_EQ(\"stream timeout\", response_body);\n  EXPECT_EQ(1U, stats_.named_.downstream_rq_idle_timeout_.value());\n}\n\nTEST_F(HttpConnectionManagerImplTest, AccessEncoderRouteBeforeHeadersArriveOnIdleTimeout) {\n  stream_idle_timeout_ = std::chrono::milliseconds(10);\n  setup(false, \"\");\n\n  std::shared_ptr<MockStreamEncoderFilter> filter(new NiceMock<MockStreamEncoderFilter>());\n\n  EXPECT_CALL(filter_factory_, createFilterChain(_))\n      .WillOnce(Invoke([&](FilterChainFactoryCallbacks& callbacks) -> void {\n        callbacks.addStreamEncoderFilter(filter);\n      }));\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    Event::MockTimer* idle_timer = setUpTimer();\n    EXPECT_CALL(*idle_timer, enableTimer(std::chrono::milliseconds(10), _));\n    conn_manager_->newStream(response_encoder_);\n\n    // Expect resetIdleTimer() to be called for the response\n    // encodeHeaders()/encodeData().\n    EXPECT_CALL(*idle_timer, enableTimer(_, _)).Times(2);\n    EXPECT_CALL(*idle_timer, disableTimer());\n    // Simulate and idle timeout so that the filter chain gets created.\n    idle_timer->invokeCallback();\n  }));\n\n  // This should not be called as we don't have request headers.\n  EXPECT_CALL(*route_config_provider_.route_config_, route(_, _)).Times(0);\n\n  EXPECT_CALL(*filter, encodeHeaders(_, _))\n      .WillOnce(InvokeWithoutArgs([&]() -> FilterHeadersStatus {\n        // Under heavy load it is possible that stream timeout will be reached before any headers\n        // were received. Envoy will create a local reply that will go through the encoder filter\n        // chain. We want to make sure that encoder filters get a null route object.\n        auto route = filter->callbacks_->route();\n        EXPECT_EQ(route.get(), nullptr);\n        return FilterHeadersStatus::Continue;\n      }));\n  EXPECT_CALL(*filter, encodeData(_, _));\n  EXPECT_CALL(*filter, encodeComplete());\n  EXPECT_CALL(*filter, onDestroy());\n\n  EXPECT_CALL(response_encoder_, encodeHeaders(_, _));\n  EXPECT_CALL(response_encoder_, encodeData(_, _));\n\n  Buffer::OwnedImpl fake_input;\n  conn_manager_->onData(fake_input, false);\n}\n\nTEST_F(HttpConnectionManagerImplTest, TestStreamIdleAccessLog) {\n  stream_idle_timeout_ = std::chrono::milliseconds(10);\n  setup(false, \"\");\n\n  NiceMock<MockStreamEncoder> encoder;\n  EXPECT_CALL(*codec_, dispatch(_)).WillRepeatedly(Invoke([&](Buffer::Instance&) -> void {\n    Event::MockTimer* idle_timer = setUpTimer();\n    EXPECT_CALL(*idle_timer, enableTimer(std::chrono::milliseconds(10), _));\n    conn_manager_->newStream(response_encoder_);\n\n    // Expect resetIdleTimer() to be called for the response\n    // encodeHeaders()/encodeData().\n    EXPECT_CALL(*idle_timer, enableTimer(_, _)).Times(2);\n    EXPECT_CALL(*idle_timer, disableTimer());\n    idle_timer->invokeCallback();\n  }));\n\n  std::shared_ptr<MockStreamDecoderFilter> filter(new NiceMock<MockStreamDecoderFilter>());\n  std::shared_ptr<AccessLog::MockInstance> handler(new NiceMock<AccessLog::MockInstance>());\n\n  // 408 direct response after timeout.\n  EXPECT_CALL(response_encoder_, encodeHeaders(_, false))\n      .WillOnce(Invoke([](const HeaderMap& headers, bool) -> void {\n        EXPECT_EQ(\"408\", headers.Status()->value().getStringView());\n      }));\n\n  std::string response_body;\n  EXPECT_CALL(response_encoder_, encodeData(_, true)).WillOnce(AddBufferToString(&response_body));\n\n  EXPECT_CALL(*handler, log(_, _, _, _))\n      .WillOnce(Invoke([](const HeaderMap*, const HeaderMap*, const HeaderMap*,\n                          const StreamInfo::StreamInfo& stream_info) {\n        EXPECT_TRUE(stream_info.responseCode());\n        EXPECT_TRUE(stream_info.hasAnyResponseFlag());\n        EXPECT_TRUE(stream_info.hasResponseFlag(StreamInfo::ResponseFlag::StreamIdleTimeout));\n      }));\n\n  EXPECT_CALL(filter_factory_, createFilterChain(_))\n      .WillOnce(Invoke([&](FilterChainFactoryCallbacks& callbacks) -> void {\n        callbacks.addStreamDecoderFilter(filter);\n        callbacks.addAccessLogHandler(handler);\n      }));\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n\n  EXPECT_EQ(\"stream timeout\", response_body);\n  EXPECT_EQ(1U, stats_.named_.downstream_rq_idle_timeout_.value());\n}\n\n// Per-route timeouts override the global stream idle timeout.\nTEST_F(HttpConnectionManagerImplTest, PerStreamIdleTimeoutRouteOverride) {\n  stream_idle_timeout_ = std::chrono::milliseconds(10);\n  setup(false, \"\");\n  ON_CALL(route_config_provider_.route_config_->route_->route_entry_, idleTimeout())\n      .WillByDefault(Return(std::chrono::milliseconds(30)));\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillRepeatedly(Invoke([&](Buffer::Instance& data) -> void {\n    Event::MockTimer* idle_timer = setUpTimer();\n    EXPECT_CALL(*idle_timer, enableTimer(std::chrono::milliseconds(10), _));\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n    EXPECT_CALL(*idle_timer, enableTimer(std::chrono::milliseconds(30), _));\n    decoder->decodeHeaders(std::move(headers), false);\n\n    data.drain(4);\n  }));\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n\n  EXPECT_EQ(0U, stats_.named_.downstream_rq_idle_timeout_.value());\n}\n\n// Per-route zero timeout overrides the global stream idle timeout.\nTEST_F(HttpConnectionManagerImplTest, PerStreamIdleTimeoutRouteZeroOverride) {\n  stream_idle_timeout_ = std::chrono::milliseconds(10);\n  setup(false, \"\");\n  ON_CALL(route_config_provider_.route_config_->route_->route_entry_, idleTimeout())\n      .WillByDefault(Return(std::chrono::milliseconds(0)));\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillRepeatedly(Invoke([&](Buffer::Instance& data) -> void {\n    Event::MockTimer* idle_timer = setUpTimer();\n    EXPECT_CALL(*idle_timer, enableTimer(std::chrono::milliseconds(10), _));\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n    EXPECT_CALL(*idle_timer, disableTimer());\n    decoder->decodeHeaders(std::move(headers), false);\n\n    data.drain(4);\n  }));\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n\n  EXPECT_EQ(0U, stats_.named_.downstream_rq_idle_timeout_.value());\n}\n\n// Validate the per-stream idle timeout after having sent downstream headers.\nTEST_F(HttpConnectionManagerImplTest, PerStreamIdleTimeoutAfterDownstreamHeaders) {\n  setup(false, \"\");\n  ON_CALL(route_config_provider_.route_config_->route_->route_entry_, idleTimeout())\n      .WillByDefault(Return(std::chrono::milliseconds(10)));\n\n  // Codec sends downstream request headers.\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance& data) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n\n    Event::MockTimer* idle_timer = setUpTimer();\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n    EXPECT_CALL(*idle_timer, enableTimer(_, _));\n    decoder->decodeHeaders(std::move(headers), false);\n\n    // Expect resetIdleTimer() to be called for the response\n    // encodeHeaders()/encodeData().\n    EXPECT_CALL(*idle_timer, enableTimer(_, _)).Times(2);\n    EXPECT_CALL(*idle_timer, disableTimer());\n    idle_timer->invokeCallback();\n\n    data.drain(4);\n  }));\n\n  // 408 direct response after timeout.\n  EXPECT_CALL(response_encoder_, encodeHeaders(_, false))\n      .WillOnce(Invoke([](const HeaderMap& headers, bool) -> void {\n        EXPECT_EQ(\"408\", headers.Status()->value().getStringView());\n      }));\n  std::string response_body;\n  EXPECT_CALL(response_encoder_, encodeData(_, true)).WillOnce(AddBufferToString(&response_body));\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n\n  EXPECT_EQ(\"stream timeout\", response_body);\n  EXPECT_EQ(1U, stats_.named_.downstream_rq_idle_timeout_.value());\n}\n\n// Validate the per-stream idle timer is properly disabled when the stream terminates normally.\nTEST_F(HttpConnectionManagerImplTest, PerStreamIdleTimeoutNormalTermination) {\n  setup(false, \"\");\n  ON_CALL(route_config_provider_.route_config_->route_->route_entry_, idleTimeout())\n      .WillByDefault(Return(std::chrono::milliseconds(10)));\n\n  // Codec sends downstream request headers.\n  Event::MockTimer* idle_timer = setUpTimer();\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance& data) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n    EXPECT_CALL(*idle_timer, enableTimer(_, _));\n    decoder->decodeHeaders(std::move(headers), false);\n\n    data.drain(4);\n  }));\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n\n  EXPECT_CALL(*idle_timer, disableTimer());\n  conn_manager_->onEvent(Network::ConnectionEvent::RemoteClose);\n\n  EXPECT_EQ(0U, stats_.named_.downstream_rq_idle_timeout_.value());\n}\n\n// Validate the per-stream idle timeout after having sent downstream\n// headers+body.\nTEST_F(HttpConnectionManagerImplTest, PerStreamIdleTimeoutAfterDownstreamHeadersAndBody) {\n  setup(false, \"\");\n  ON_CALL(route_config_provider_.route_config_->route_->route_entry_, idleTimeout())\n      .WillByDefault(Return(std::chrono::milliseconds(10)));\n\n  // Codec sends downstream request headers.\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance& data) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n\n    Event::MockTimer* idle_timer = setUpTimer();\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n    EXPECT_CALL(*idle_timer, enableTimer(_, _));\n    decoder->decodeHeaders(std::move(headers), false);\n\n    EXPECT_CALL(*idle_timer, enableTimer(_, _));\n    decoder->decodeData(data, false);\n\n    // Expect resetIdleTimer() to be called for the response\n    // encodeHeaders()/encodeData().\n    EXPECT_CALL(*idle_timer, enableTimer(_, _)).Times(2);\n    EXPECT_CALL(*idle_timer, disableTimer());\n    idle_timer->invokeCallback();\n\n    data.drain(4);\n  }));\n\n  // 408 direct response after timeout.\n  EXPECT_CALL(response_encoder_, encodeHeaders(_, false))\n      .WillOnce(Invoke([](const HeaderMap& headers, bool) -> void {\n        EXPECT_EQ(\"408\", headers.Status()->value().getStringView());\n      }));\n  std::string response_body;\n  EXPECT_CALL(response_encoder_, encodeData(_, true)).WillOnce(AddBufferToString(&response_body));\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n\n  EXPECT_EQ(\"stream timeout\", response_body);\n  EXPECT_EQ(1U, stats_.named_.downstream_rq_idle_timeout_.value());\n}\n\n// Validate the per-stream idle timeout after upstream headers have been sent.\nTEST_F(HttpConnectionManagerImplTest, PerStreamIdleTimeoutAfterUpstreamHeaders) {\n  setup(false, \"\");\n  ON_CALL(route_config_provider_.route_config_->route_->route_entry_, idleTimeout())\n      .WillByDefault(Return(std::chrono::milliseconds(10)));\n\n  // Store the basic request encoder during filter chain setup.\n  std::shared_ptr<MockStreamDecoderFilter> filter(new NiceMock<MockStreamDecoderFilter>());\n\n  EXPECT_CALL(filter_factory_, createFilterChain(_))\n      .WillRepeatedly(Invoke([&](FilterChainFactoryCallbacks& callbacks) -> void {\n        callbacks.addStreamDecoderFilter(filter);\n      }));\n  EXPECT_CALL(filter_callbacks_.connection_.dispatcher_, deferredDelete_(_));\n\n  // Codec sends downstream request headers, upstream response headers are\n  // encoded.\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance& data) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n\n    Event::MockTimer* idle_timer = setUpTimer();\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n    EXPECT_CALL(*idle_timer, enableTimer(_, _));\n    decoder->decodeHeaders(std::move(headers), false);\n\n    HeaderMapPtr response_headers{new TestHeaderMapImpl{{\":status\", \"200\"}}};\n    EXPECT_CALL(*idle_timer, enableTimer(_, _));\n    filter->callbacks_->encodeHeaders(std::move(response_headers), false);\n\n    EXPECT_CALL(*idle_timer, disableTimer());\n    idle_timer->invokeCallback();\n\n    data.drain(4);\n  }));\n\n  // 200 upstream response.\n  EXPECT_CALL(response_encoder_, encodeHeaders(_, false))\n      .WillOnce(Invoke([](const HeaderMap& headers, bool) -> void {\n        EXPECT_EQ(\"200\", headers.Status()->value().getStringView());\n      }));\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n\n  EXPECT_EQ(1U, stats_.named_.downstream_rq_idle_timeout_.value());\n}\n\n// Validate the per-stream idle timeout after a sequence of header/data events.\nTEST_F(HttpConnectionManagerImplTest, PerStreamIdleTimeoutAfterBidiData) {\n  setup(false, \"\");\n  ON_CALL(route_config_provider_.route_config_->route_->route_entry_, idleTimeout())\n      .WillByDefault(Return(std::chrono::milliseconds(10)));\n  proxy_100_continue_ = true;\n\n  // Store the basic request encoder during filter chain setup.\n  std::shared_ptr<MockStreamDecoderFilter> filter(new NiceMock<MockStreamDecoderFilter>());\n\n  EXPECT_CALL(filter_factory_, createFilterChain(_))\n      .WillRepeatedly(Invoke([&](FilterChainFactoryCallbacks& callbacks) -> void {\n        callbacks.addStreamDecoderFilter(filter);\n      }));\n  EXPECT_CALL(filter_callbacks_.connection_.dispatcher_, deferredDelete_(_));\n\n  // Codec sends downstream request headers, upstream response headers are\n  // encoded, data events happen in various directions.\n  Event::MockTimer* idle_timer = setUpTimer();\n  StreamDecoder* decoder;\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance& data) -> void {\n    decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n    EXPECT_CALL(*idle_timer, enableTimer(_, _));\n    decoder->decodeHeaders(std::move(headers), false);\n\n    HeaderMapPtr response_continue_headers{new TestHeaderMapImpl{{\":status\", \"100\"}}};\n    EXPECT_CALL(*idle_timer, enableTimer(_, _));\n    filter->callbacks_->encode100ContinueHeaders(std::move(response_continue_headers));\n\n    HeaderMapPtr response_headers{new TestHeaderMapImpl{{\":status\", \"200\"}}};\n    EXPECT_CALL(*idle_timer, enableTimer(_, _));\n    filter->callbacks_->encodeHeaders(std::move(response_headers), false);\n\n    EXPECT_CALL(*idle_timer, enableTimer(_, _));\n    decoder->decodeData(data, false);\n\n    HeaderMapPtr trailers{new TestHeaderMapImpl{{\"foo\", \"bar\"}}};\n    EXPECT_CALL(*idle_timer, enableTimer(_, _));\n    decoder->decodeTrailers(std::move(trailers));\n\n    Buffer::OwnedImpl fake_response(\"world\");\n    EXPECT_CALL(*idle_timer, enableTimer(_, _));\n    filter->callbacks_->encodeData(fake_response, false);\n\n    EXPECT_CALL(*idle_timer, disableTimer());\n    idle_timer->invokeCallback();\n\n    data.drain(4);\n  }));\n\n  // 100 continue.\n  EXPECT_CALL(response_encoder_, encode100ContinueHeaders(_));\n\n  // 200 upstream response.\n  EXPECT_CALL(response_encoder_, encodeHeaders(_, false))\n      .WillOnce(Invoke([](const HeaderMap& headers, bool) -> void {\n        EXPECT_EQ(\"200\", headers.Status()->value().getStringView());\n      }));\n\n  std::string response_body;\n  EXPECT_CALL(response_encoder_, encodeData(_, false)).WillOnce(AddBufferToString(&response_body));\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n\n  EXPECT_EQ(1U, stats_.named_.downstream_rq_idle_timeout_.value());\n  EXPECT_EQ(\"world\", response_body);\n}\n\nTEST_F(HttpConnectionManagerImplTest, RequestTimeoutDisabledByDefault) {\n  setup(false, \"\");\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    EXPECT_CALL(filter_callbacks_.connection_.dispatcher_, createTimer_).Times(0);\n    conn_manager_->newStream(response_encoder_);\n  }));\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n}\n\nTEST_F(HttpConnectionManagerImplTest, RequestTimeoutDisabledIfSetToZero) {\n  request_timeout_ = std::chrono::milliseconds(0);\n  setup(false, \"\");\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    EXPECT_CALL(filter_callbacks_.connection_.dispatcher_, createTimer_).Times(0);\n    conn_manager_->newStream(response_encoder_);\n  }));\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n}\n\nTEST_F(HttpConnectionManagerImplTest, RequestTimeoutValidlyConfigured) {\n  request_timeout_ = std::chrono::milliseconds(10);\n  setup(false, \"\");\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    Event::MockTimer* request_timer = setUpTimer();\n    EXPECT_CALL(*request_timer, enableTimer(request_timeout_, _));\n\n    conn_manager_->newStream(response_encoder_);\n  }));\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n}\n\nTEST_F(HttpConnectionManagerImplTest, RequestTimeoutCallbackDisarmsAndReturns408) {\n  request_timeout_ = std::chrono::milliseconds(10);\n  setup(false, \"\");\n\n  std::string response_body;\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    Event::MockTimer* request_timer = setUpTimer();\n    EXPECT_CALL(*request_timer, enableTimer(request_timeout_, _)).Times(1);\n    EXPECT_CALL(*request_timer, disableTimer()).Times(AtLeast(1));\n\n    EXPECT_CALL(response_encoder_, encodeHeaders(_, false))\n        .WillOnce(Invoke([](const HeaderMap& headers, bool) -> void {\n          EXPECT_EQ(\"408\", headers.Status()->value().getStringView());\n        }));\n    EXPECT_CALL(response_encoder_, encodeData(_, true)).WillOnce(AddBufferToString(&response_body));\n\n    conn_manager_->newStream(response_encoder_);\n    EXPECT_CALL(filter_callbacks_.connection_.dispatcher_, setTrackedObject(_)).Times(2);\n    request_timer->invokeCallback();\n  }));\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false); // kick off request\n\n  EXPECT_EQ(1U, stats_.named_.downstream_rq_timeout_.value());\n  EXPECT_EQ(\"request timeout\", response_body);\n}\n\nTEST_F(HttpConnectionManagerImplTest, RequestTimeoutIsNotDisarmedOnIncompleteRequestWithHeader) {\n  request_timeout_ = std::chrono::milliseconds(10);\n  setup(false, \"\");\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    Event::MockTimer* request_timer = setUpTimer();\n    EXPECT_CALL(*request_timer, enableTimer(request_timeout_, _)).Times(1);\n    EXPECT_CALL(*request_timer, disableTimer()).Times(0);\n\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n\n    // the second parameter 'false' leaves the stream open\n    decoder->decodeHeaders(std::move(headers), false);\n  }));\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false); // kick off request\n\n  EXPECT_EQ(0U, stats_.named_.downstream_rq_timeout_.value());\n}\n\nTEST_F(HttpConnectionManagerImplTest, RequestTimeoutIsDisarmedOnCompleteRequestWithHeader) {\n  request_timeout_ = std::chrono::milliseconds(10);\n  setup(false, \"\");\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    Event::MockTimer* request_timer = setUpTimer();\n    EXPECT_CALL(*request_timer, enableTimer(request_timeout_, _)).Times(1);\n\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n\n    EXPECT_CALL(*request_timer, disableTimer()).Times(1);\n    decoder->decodeHeaders(std::move(headers), true);\n  }));\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false); // kick off request\n\n  EXPECT_EQ(0U, stats_.named_.downstream_rq_timeout_.value());\n}\n\nTEST_F(HttpConnectionManagerImplTest, RequestTimeoutIsDisarmedOnCompleteRequestWithData) {\n  request_timeout_ = std::chrono::milliseconds(10);\n  setup(false, \"\");\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance& data) -> void {\n    Event::MockTimer* request_timer = setUpTimer();\n    EXPECT_CALL(*request_timer, enableTimer(request_timeout_, _)).Times(1);\n\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"POST\"}}};\n    decoder->decodeHeaders(std::move(headers), false);\n\n    EXPECT_CALL(*request_timer, disableTimer()).Times(1);\n    decoder->decodeData(data, true);\n  }));\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n\n  EXPECT_EQ(0U, stats_.named_.downstream_rq_timeout_.value());\n}\n\nTEST_F(HttpConnectionManagerImplTest, RequestTimeoutIsDisarmedOnCompleteRequestWithTrailers) {\n  request_timeout_ = std::chrono::milliseconds(10);\n  setup(false, \"\");\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance& data) -> void {\n    Event::MockTimer* request_timer = setUpTimer();\n    EXPECT_CALL(*request_timer, enableTimer(request_timeout_, _)).Times(1);\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n    decoder->decodeHeaders(std::move(headers), false);\n    decoder->decodeData(data, false);\n\n    EXPECT_CALL(*request_timer, disableTimer()).Times(1);\n    HeaderMapPtr trailers{new TestHeaderMapImpl{{\"foo\", \"bar\"}}};\n    decoder->decodeTrailers(std::move(trailers));\n  }));\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n\n  EXPECT_EQ(0U, stats_.named_.downstream_rq_timeout_.value());\n}\n\nTEST_F(HttpConnectionManagerImplTest, RequestTimeoutIsDisarmedOnEncodeHeaders) {\n  request_timeout_ = std::chrono::milliseconds(10);\n  setup(false, \"\");\n  std::shared_ptr<MockStreamDecoderFilter> filter(new NiceMock<MockStreamDecoderFilter>());\n  EXPECT_CALL(filter_factory_, createFilterChain(_))\n      .WillRepeatedly(Invoke([&](FilterChainFactoryCallbacks& callbacks) -> void {\n        callbacks.addStreamDecoderFilter(filter);\n      }));\n  EXPECT_CALL(response_encoder_, encodeHeaders(_, _));\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    Event::MockTimer* request_timer = setUpTimer();\n    EXPECT_CALL(*request_timer, enableTimer(request_timeout_, _)).Times(1);\n\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n\n    decoder->decodeHeaders(std::move(headers), false);\n\n    EXPECT_CALL(*request_timer, disableTimer()).Times(1);\n    HeaderMapPtr response_headers{new TestHeaderMapImpl{{\":status\", \"200\"}}};\n    filter->callbacks_->encodeHeaders(std::move(response_headers), false);\n  }));\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false); // kick off request\n\n  EXPECT_EQ(0U, stats_.named_.downstream_rq_timeout_.value());\n}\n\nTEST_F(HttpConnectionManagerImplTest, RequestTimeoutIsDisarmedOnConnectionTermination) {\n  request_timeout_ = std::chrono::milliseconds(10);\n  setup(false, \"\");\n\n  Event::MockTimer* request_timer = setUpTimer();\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n\n    decoder->decodeHeaders(std::move(headers), false);\n  }));\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n\n  EXPECT_CALL(*request_timer, enableTimer(request_timeout_, _)).Times(1);\n  conn_manager_->onData(fake_input, false); // kick off request\n\n  EXPECT_CALL(*request_timer, disableTimer()).Times(1);\n  conn_manager_->onEvent(Network::ConnectionEvent::RemoteClose);\n\n  EXPECT_EQ(0U, stats_.named_.downstream_rq_timeout_.value());\n}\n\nTEST_F(HttpConnectionManagerImplTest, RejectWebSocketOnNonWebSocketRoute) {\n  setup(false, \"\");\n  StreamDecoder* decoder = nullptr;\n  NiceMock<MockStreamEncoder> encoder;\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance& data) -> void {\n    decoder = &conn_manager_->newStream(encoder);\n    HeaderMapPtr headers{new TestHeaderMapImpl{{\":authority\", \"host\"},\n                                               {\":method\", \"GET\"},\n                                               {\":path\", \"/\"},\n                                               {\"connection\", \"Upgrade\"},\n                                               {\"upgrade\", \"websocket\"}}};\n    decoder->decodeHeaders(std::move(headers), true);\n    data.drain(4);\n  }));\n\n  EXPECT_CALL(encoder, encodeHeaders(_, true))\n      .WillOnce(Invoke([](const HeaderMap& headers, bool) -> void {\n        EXPECT_EQ(\"403\", headers.Status()->value().getStringView());\n      }));\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n\n  EXPECT_EQ(1U, stats_.named_.downstream_rq_ws_on_non_ws_route_.value());\n}\n\n// Make sure for upgrades, we do not append Connection: Close when draining.\nTEST_F(HttpConnectionManagerImplTest, FooUpgradeDrainClose) {\n  setup(false, \"envoy-custom-server\", false);\n\n  // Store the basic request encoder during filter chain setup.\n  auto* filter = new MockStreamFilter();\n  EXPECT_CALL(drain_close_, drainClose()).WillOnce(Return(true));\n\n  EXPECT_CALL(*filter, decodeHeaders(_, false))\n      .WillRepeatedly(Invoke([&](HeaderMap&, bool) -> FilterHeadersStatus {\n        return FilterHeadersStatus::StopIteration;\n      }));\n\n  EXPECT_CALL(*filter, encodeHeaders(_, false))\n      .WillRepeatedly(Invoke(\n          [&](HeaderMap&, bool) -> FilterHeadersStatus { return FilterHeadersStatus::Continue; }));\n\n  NiceMock<MockStreamEncoder> encoder;\n  EXPECT_CALL(encoder, encodeHeaders(_, false))\n      .WillOnce(Invoke([&](const HeaderMap& headers, bool) -> void {\n        EXPECT_NE(nullptr, headers.Connection());\n        EXPECT_EQ(\"upgrade\", headers.Connection()->value().getStringView());\n      }));\n\n  EXPECT_CALL(*filter, setDecoderFilterCallbacks(_));\n  EXPECT_CALL(*filter, setEncoderFilterCallbacks(_));\n\n  EXPECT_CALL(filter_factory_, createUpgradeFilterChain(_, _, _))\n      .WillRepeatedly(Invoke([&](absl::string_view, const Http::FilterChainFactory::UpgradeMap*,\n                                 FilterChainFactoryCallbacks& callbacks) -> bool {\n        callbacks.addStreamFilter(StreamFilterSharedPtr{filter});\n        return true;\n      }));\n\n  // When dispatch is called on the codec, we pretend to get a new stream and then fire a headers\n  // only request into it. Then we respond into the filter.\n  StreamDecoder* decoder = nullptr;\n  EXPECT_CALL(*codec_, dispatch(_)).WillRepeatedly(Invoke([&](Buffer::Instance& data) -> void {\n    decoder = &conn_manager_->newStream(encoder);\n\n    HeaderMapPtr headers{new TestHeaderMapImpl{{\":authority\", \"host\"},\n                                               {\":method\", \"GET\"},\n                                               {\":path\", \"/\"},\n                                               {\"connection\", \"Upgrade\"},\n                                               {\"upgrade\", \"foo\"}}};\n    decoder->decodeHeaders(std::move(headers), false);\n\n    HeaderMapPtr response_headers{\n        new TestHeaderMapImpl{{\":status\", \"101\"}, {\"Connection\", \"upgrade\"}, {\"upgrade\", \"foo\"}}};\n    filter->decoder_callbacks_->encodeHeaders(std::move(response_headers), false);\n\n    data.drain(4);\n  }));\n\n  // Kick off the incoming data. Use extra data which should cause a redispatch.\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n}\n\nTEST_F(HttpConnectionManagerImplTest, DrainClose) {\n  setup(true, \"\");\n\n  MockStreamDecoderFilter* filter = new NiceMock<MockStreamDecoderFilter>();\n  EXPECT_CALL(filter_factory_, createFilterChain(_))\n      .WillOnce(Invoke([&](FilterChainFactoryCallbacks& callbacks) -> void {\n        callbacks.addStreamDecoderFilter(StreamDecoderFilterSharedPtr{filter});\n      }));\n\n  EXPECT_CALL(*filter, decodeHeaders(_, true))\n      .WillOnce(Invoke([](HeaderMap& headers, bool) -> FilterHeadersStatus {\n        EXPECT_NE(nullptr, headers.ForwardedFor());\n        EXPECT_EQ(\"https\", headers.ForwardedProto()->value().getStringView());\n        return FilterHeadersStatus::StopIteration;\n      }));\n\n  StreamDecoder* decoder = nullptr;\n  NiceMock<MockStreamEncoder> encoder;\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    decoder = &conn_manager_->newStream(encoder);\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n    decoder->decodeHeaders(std::move(headers), true);\n  }));\n\n  Buffer::OwnedImpl fake_input;\n  conn_manager_->onData(fake_input, false);\n\n  HeaderMapPtr response_headers{new TestHeaderMapImpl{{\":status\", \"300\"}}};\n  Event::MockTimer* drain_timer = setUpTimer();\n  EXPECT_CALL(*drain_timer, enableTimer(_, _));\n  EXPECT_CALL(drain_close_, drainClose()).WillOnce(Return(true));\n  EXPECT_CALL(*codec_, shutdownNotice());\n  filter->callbacks_->encodeHeaders(std::move(response_headers), true);\n  EXPECT_EQ(ssl_connection_.get(), filter->callbacks_->connection()->ssl().get());\n\n  EXPECT_CALL(*codec_, goAway());\n  EXPECT_CALL(filter_callbacks_.connection_,\n              close(Network::ConnectionCloseType::FlushWriteAndDelay));\n  EXPECT_CALL(*drain_timer, disableTimer());\n  drain_timer->invokeCallback();\n\n  EXPECT_EQ(1U, stats_.named_.downstream_cx_drain_close_.value());\n  EXPECT_EQ(1U, stats_.named_.downstream_rq_3xx_.value());\n  EXPECT_EQ(1U, listener_stats_.downstream_rq_3xx_.value());\n  EXPECT_EQ(1U, stats_.named_.downstream_rq_completed_.value());\n  EXPECT_EQ(1U, listener_stats_.downstream_rq_completed_.value());\n}\n\nTEST_F(HttpConnectionManagerImplTest, ResponseBeforeRequestComplete) {\n  InSequence s;\n  setup(false, \"envoy-server-test\");\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n    decoder->decodeHeaders(std::move(headers), false);\n  }));\n\n  setupFilterChain(1, 0);\n\n  EXPECT_CALL(*decoder_filters_[0], decodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::StopIteration));\n\n  Buffer::OwnedImpl fake_input;\n  conn_manager_->onData(fake_input, false);\n\n  EXPECT_CALL(response_encoder_, encodeHeaders(_, true))\n      .WillOnce(Invoke([](const HeaderMap& headers, bool) -> void {\n        EXPECT_NE(nullptr, headers.Server());\n        EXPECT_EQ(\"envoy-server-test\", headers.Server()->value().getStringView());\n      }));\n  EXPECT_CALL(*decoder_filters_[0], onDestroy());\n  EXPECT_CALL(filter_callbacks_.connection_,\n              close(Network::ConnectionCloseType::FlushWriteAndDelay));\n\n  HeaderMapPtr response_headers{new TestHeaderMapImpl{{\":status\", \"200\"}}};\n  decoder_filters_[0]->callbacks_->encodeHeaders(std::move(response_headers), true);\n}\n\nTEST_F(HttpConnectionManagerImplTest, DisconnectOnProxyConnectionDisconnect) {\n  InSequence s;\n  setup(false, \"envoy-server-test\");\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{new TestHeaderMapImpl{\n        {\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}, {\"proxy-connection\", \"close\"}}};\n    decoder->decodeHeaders(std::move(headers), false);\n  }));\n\n  setupFilterChain(1, 0);\n\n  EXPECT_CALL(*decoder_filters_[0], decodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::StopIteration));\n\n  Buffer::OwnedImpl fake_input;\n  conn_manager_->onData(fake_input, false);\n\n  EXPECT_CALL(response_encoder_, encodeHeaders(_, true))\n      .WillOnce(Invoke([](const HeaderMap& headers, bool) -> void {\n        EXPECT_NE(nullptr, headers.Connection());\n        EXPECT_EQ(\"close\", headers.Connection()->value().getStringView());\n        EXPECT_EQ(nullptr, headers.ProxyConnection());\n      }));\n  EXPECT_CALL(*decoder_filters_[0], onDestroy());\n  EXPECT_CALL(filter_callbacks_.connection_,\n              close(Network::ConnectionCloseType::FlushWriteAndDelay));\n\n  HeaderMapPtr response_headers{new TestHeaderMapImpl{{\":status\", \"200\"}}};\n  decoder_filters_[0]->callbacks_->encodeHeaders(std::move(response_headers), true);\n}\n\nTEST_F(HttpConnectionManagerImplTest, ResponseStartBeforeRequestComplete) {\n  setup(false, \"\");\n\n  // This is like ResponseBeforeRequestComplete, but it tests the case where we start the reply\n  // before the request completes, but don't finish the reply until after the request completes.\n  MockStreamDecoderFilter* filter = new NiceMock<MockStreamDecoderFilter>();\n  EXPECT_CALL(filter_factory_, createFilterChain(_))\n      .WillOnce(Invoke([&](FilterChainFactoryCallbacks& callbacks) -> void {\n        callbacks.addStreamDecoderFilter(StreamDecoderFilterSharedPtr{filter});\n      }));\n\n  EXPECT_CALL(*filter, decodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::StopIteration));\n\n  // Start the request\n  StreamDecoder* decoder = nullptr;\n  NiceMock<MockStreamEncoder> encoder;\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    decoder = &conn_manager_->newStream(encoder);\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n    decoder->decodeHeaders(std::move(headers), false);\n  }));\n\n  Buffer::OwnedImpl fake_input(\"hello\");\n  conn_manager_->onData(fake_input, false);\n\n  // Start the response\n  HeaderMapPtr response_headers{new TestHeaderMapImpl{{\":status\", \"200\"}}};\n  EXPECT_CALL(encoder, encodeHeaders(_, false))\n      .WillOnce(Invoke([](const HeaderMap& headers, bool) -> void {\n        EXPECT_NE(nullptr, headers.Server());\n        EXPECT_EQ(\"\", headers.Server()->value().getStringView());\n      }));\n  filter->callbacks_->encodeHeaders(std::move(response_headers), false);\n\n  // Finish the request.\n  EXPECT_CALL(*filter, decodeData(_, true));\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance& data) -> void {\n    decoder->decodeData(data, true);\n  }));\n\n  conn_manager_->onData(fake_input, false);\n\n  // Since we started the response before the request was complete, we will still close the\n  // connection since we already sent a connection: close header. We won't \"reset\" the stream\n  // however.\n  EXPECT_CALL(filter_callbacks_.connection_,\n              close(Network::ConnectionCloseType::FlushWriteAndDelay));\n  Buffer::OwnedImpl fake_response(\"world\");\n  filter->callbacks_->encodeData(fake_response, true);\n}\n\nTEST_F(HttpConnectionManagerImplTest, DownstreamDisconnect) {\n  InSequence s;\n  setup(false, \"\");\n\n  NiceMock<MockStreamEncoder> encoder;\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance& data) -> void {\n    conn_manager_->newStream(encoder);\n    data.drain(2);\n  }));\n\n  EXPECT_CALL(filter_factory_, createFilterChain(_)).Times(0);\n\n  // Kick off the incoming data.\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n\n  // Now raise a remote disconnection, we should see the filter get reset called.\n  conn_manager_->onEvent(Network::ConnectionEvent::RemoteClose);\n}\n\nTEST_F(HttpConnectionManagerImplTest, DownstreamProtocolError) {\n  InSequence s;\n  setup(false, \"\");\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    conn_manager_->newStream(response_encoder_);\n    throw CodecProtocolException(\"protocol error\");\n  }));\n\n  EXPECT_CALL(response_encoder_.stream_, removeCallbacks(_));\n  EXPECT_CALL(filter_factory_, createFilterChain(_)).Times(0);\n\n  // A protocol exception should result in reset of the streams followed by a remote or local close\n  // depending on whether the downstream client closes the connection prior to the delayed close\n  // timer firing.\n  EXPECT_CALL(filter_callbacks_.connection_,\n              close(Network::ConnectionCloseType::FlushWriteAndDelay));\n\n  // Kick off the incoming data.\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n}\n\n// Verify that FrameFloodException causes connection to be closed abortively.\nTEST_F(HttpConnectionManagerImplTest, FrameFloodError) {\n  InSequence s;\n  setup(false, \"\");\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    conn_manager_->newStream(response_encoder_);\n    throw FrameFloodException(\"too many outbound frames.\");\n  }));\n\n  EXPECT_CALL(response_encoder_.stream_, removeCallbacks(_));\n  EXPECT_CALL(filter_factory_, createFilterChain(_)).Times(0);\n\n  // FrameFloodException should result in reset of the streams followed by abortive close.\n  EXPECT_CALL(filter_callbacks_.connection_,\n              close(Network::ConnectionCloseType::FlushWriteAndDelay));\n\n  // Kick off the incoming data.\n  Buffer::OwnedImpl fake_input(\"1234\");\n  EXPECT_LOG_NOT_CONTAINS(\"warning\", \"downstream HTTP flood\",\n                          conn_manager_->onData(fake_input, false));\n}\n\n// Verify that FrameFloodException causes connection to be closed abortively as well as logged\n// if runtime indicates to do so.\nTEST_F(HttpConnectionManagerImplTest, FrameFloodErrorWithLog) {\n  InSequence s;\n  setup(false, \"\");\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    conn_manager_->newStream(response_encoder_);\n    throw FrameFloodException(\"too many outbound frames.\");\n  }));\n\n  EXPECT_CALL(runtime_.snapshot_, featureEnabled(\"http.connection_manager.log_flood_exception\",\n                                                 Matcher<const envoy::type::FractionalPercent&>(_)))\n      .WillOnce(Return(true));\n\n  EXPECT_CALL(response_encoder_.stream_, removeCallbacks(_));\n  EXPECT_CALL(filter_factory_, createFilterChain(_)).Times(0);\n\n  // FrameFloodException should result in reset of the streams followed by abortive close.\n  EXPECT_CALL(filter_callbacks_.connection_,\n              close(Network::ConnectionCloseType::FlushWriteAndDelay));\n\n  // Kick off the incoming data.\n  Buffer::OwnedImpl fake_input(\"1234\");\n  EXPECT_LOG_CONTAINS(\"warning\",\n                      \"downstream HTTP flood from IP '0.0.0.0:0': too many outbound frames.\",\n                      conn_manager_->onData(fake_input, false));\n}\n\nTEST_F(HttpConnectionManagerImplTest, IdleTimeoutNoCodec) {\n  // Not used in the test.\n  delete codec_;\n\n  idle_timeout_ = (std::chrono::milliseconds(10));\n  Event::MockTimer* idle_timer = setUpTimer();\n  EXPECT_CALL(*idle_timer, enableTimer(_, _));\n  setup(false, \"\");\n\n  EXPECT_CALL(filter_callbacks_.connection_, close(Network::ConnectionCloseType::FlushWrite));\n  EXPECT_CALL(*idle_timer, disableTimer());\n  idle_timer->invokeCallback();\n\n  EXPECT_EQ(1U, stats_.named_.downstream_cx_idle_timeout_.value());\n}\n\nTEST_F(HttpConnectionManagerImplTest, IdleTimeout) {\n  idle_timeout_ = (std::chrono::milliseconds(10));\n  Event::MockTimer* idle_timer = setUpTimer();\n  EXPECT_CALL(*idle_timer, enableTimer(_, _));\n  setup(false, \"\");\n\n  MockStreamDecoderFilter* filter = new NiceMock<MockStreamDecoderFilter>();\n  EXPECT_CALL(filter_factory_, createFilterChain(_))\n      .WillOnce(Invoke([&](FilterChainFactoryCallbacks& callbacks) -> void {\n        callbacks.addStreamDecoderFilter(StreamDecoderFilterSharedPtr{filter});\n      }));\n\n  NiceMock<MockStreamEncoder> encoder;\n  StreamDecoder* decoder = nullptr;\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    decoder = &conn_manager_->newStream(encoder);\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n    decoder->decodeHeaders(std::move(headers), false);\n\n    Buffer::OwnedImpl fake_data(\"hello\");\n    decoder->decodeData(fake_data, true);\n  }));\n\n  EXPECT_CALL(*idle_timer, disableTimer());\n  EXPECT_CALL(*filter, decodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::StopIteration));\n  EXPECT_CALL(*filter, decodeData(_, true))\n      .WillOnce(Return(FilterDataStatus::StopIterationNoBuffer));\n\n  // Kick off the incoming data.\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n\n  EXPECT_CALL(*idle_timer, enableTimer(_, _));\n  HeaderMapPtr response_headers{new TestHeaderMapImpl{{\":status\", \"200\"}}};\n  filter->callbacks_->encodeHeaders(std::move(response_headers), true);\n\n  Event::MockTimer* drain_timer = setUpTimer();\n  EXPECT_CALL(*drain_timer, enableTimer(_, _));\n  idle_timer->invokeCallback();\n\n  EXPECT_CALL(*codec_, goAway());\n  EXPECT_CALL(filter_callbacks_.connection_,\n              close(Network::ConnectionCloseType::FlushWriteAndDelay));\n  EXPECT_CALL(*idle_timer, disableTimer());\n  EXPECT_CALL(*drain_timer, disableTimer());\n  drain_timer->invokeCallback();\n\n  EXPECT_EQ(1U, stats_.named_.downstream_cx_idle_timeout_.value());\n}\n\nTEST_F(HttpConnectionManagerImplTest, IntermediateBufferingEarlyResponse) {\n  InSequence s;\n  setup(false, \"\");\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n    decoder->decodeHeaders(std::move(headers), false);\n\n    Buffer::OwnedImpl fake_data(\"hello\");\n    decoder->decodeData(fake_data, true);\n  }));\n\n  setupFilterChain(2, 0);\n\n  EXPECT_CALL(*decoder_filters_[0], decodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::StopIteration));\n  EXPECT_CALL(*decoder_filters_[0], decodeData(_, true))\n      .WillOnce(Return(FilterDataStatus::StopIterationAndBuffer));\n  EXPECT_CALL(*decoder_filters_[0], decodeComplete());\n\n  // Kick off the incoming data.\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n\n  // Mimic a decoder filter that trapped data and now sends on the headers.\n  EXPECT_CALL(*decoder_filters_[1], decodeHeaders(_, false))\n      .WillOnce(Invoke([&](HeaderMap&, bool) -> FilterHeadersStatus {\n        // Now filter 2 will send a complete response.\n        HeaderMapPtr response_headers{new TestHeaderMapImpl{{\":status\", \"200\"}}};\n        decoder_filters_[1]->callbacks_->encodeHeaders(std::move(response_headers), true);\n        return FilterHeadersStatus::StopIteration;\n      }));\n\n  EXPECT_CALL(response_encoder_, encodeHeaders(_, true));\n  expectOnDestroy();\n\n  // Response is already complete so we drop buffered body data when we continue.\n  EXPECT_CALL(*decoder_filters_[1], decodeData(_, _)).Times(0);\n  decoder_filters_[0]->callbacks_->continueDecoding();\n}\n\nTEST_F(HttpConnectionManagerImplTest, DoubleBuffering) {\n  InSequence s;\n  setup(false, \"\");\n\n  // The data will get moved so we need to have a copy to compare against.\n  Buffer::OwnedImpl fake_data(\"hello\");\n  Buffer::OwnedImpl fake_data_copy(\"hello\");\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n    decoder->decodeHeaders(std::move(headers), false);\n    decoder->decodeData(fake_data, true);\n  }));\n\n  setupFilterChain(3, 0);\n\n  EXPECT_CALL(*decoder_filters_[0], decodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::StopIteration));\n  EXPECT_CALL(*decoder_filters_[0], decodeData(_, true))\n      .WillOnce(Return(FilterDataStatus::StopIterationAndBuffer));\n  EXPECT_CALL(*decoder_filters_[0], decodeComplete());\n\n  // Kick off the incoming data.\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n\n  // Continue iteration and stop and buffer on the 2nd filter.\n  EXPECT_CALL(*decoder_filters_[1], decodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::StopIteration));\n  EXPECT_CALL(*decoder_filters_[1], decodeData(_, true))\n      .WillOnce(Return(FilterDataStatus::StopIterationAndBuffer));\n  EXPECT_CALL(*decoder_filters_[1], decodeComplete());\n  decoder_filters_[0]->callbacks_->continueDecoding();\n\n  // Continue iteration. We expect the 3rd filter to not receive double data but for the buffered\n  // data to have been kept inline as it moves through.\n  EXPECT_CALL(*decoder_filters_[2], decodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::StopIteration));\n  EXPECT_CALL(*decoder_filters_[2], decodeData(BufferEqual(&fake_data_copy), true))\n      .WillOnce(Return(FilterDataStatus::StopIterationNoBuffer));\n  EXPECT_CALL(*decoder_filters_[2], decodeComplete());\n  decoder_filters_[1]->callbacks_->continueDecoding();\n}\n\nTEST_F(HttpConnectionManagerImplTest, ZeroByteDataFiltering) {\n  InSequence s;\n  setup(false, \"\");\n\n  StreamDecoder* decoder = nullptr;\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n    decoder->decodeHeaders(std::move(headers), false);\n  }));\n\n  setupFilterChain(2, 0);\n\n  EXPECT_CALL(*decoder_filters_[0], decodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::StopIteration));\n\n  // Kick off the incoming data.\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n\n  // Continue headers only of filter 1.\n  EXPECT_CALL(*decoder_filters_[1], decodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::StopIteration));\n  decoder_filters_[0]->callbacks_->continueDecoding();\n\n  // Stop zero byte data.\n  EXPECT_CALL(*decoder_filters_[0], decodeData(_, true))\n      .WillOnce(Return(FilterDataStatus::StopIterationAndBuffer));\n  EXPECT_CALL(*decoder_filters_[0], decodeComplete());\n  Buffer::OwnedImpl zero;\n  decoder->decodeData(zero, true);\n\n  // Continue.\n  EXPECT_CALL(*decoder_filters_[1], decodeData(_, true))\n      .WillOnce(Return(FilterDataStatus::StopIterationNoBuffer));\n  EXPECT_CALL(*decoder_filters_[1], decodeComplete());\n  decoder_filters_[0]->callbacks_->continueDecoding();\n}\n\nTEST_F(HttpConnectionManagerImplTest, FilterAddTrailersInTrailersCallback) {\n  InSequence s;\n  setup(false, \"\");\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n    decoder->decodeHeaders(std::move(headers), false);\n\n    Buffer::OwnedImpl fake_data(\"hello\");\n    decoder->decodeData(fake_data, false);\n\n    HeaderMapPtr trailers{new TestHeaderMapImpl{{\"bazzz\", \"bar\"}}};\n    decoder->decodeTrailers(std::move(trailers));\n  }));\n\n  setupFilterChain(2, 2);\n\n  Http::LowerCaseString trailer_key(\"foo\");\n  std::string trailers_data(\"trailers\");\n  EXPECT_CALL(*decoder_filters_[0], decodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::StopIteration));\n  EXPECT_CALL(*decoder_filters_[0], decodeData(_, false))\n      .WillOnce(Return(FilterDataStatus::StopIterationAndBuffer));\n  EXPECT_CALL(*decoder_filters_[0], decodeTrailers(_))\n      .WillOnce(Return(FilterTrailersStatus::Continue));\n  EXPECT_CALL(*decoder_filters_[0], decodeComplete());\n  EXPECT_CALL(*decoder_filters_[1], decodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::StopIteration));\n  EXPECT_CALL(*decoder_filters_[1], decodeData(_, false))\n      .WillOnce(Return(FilterDataStatus::StopIterationAndBuffer));\n  EXPECT_CALL(*decoder_filters_[1], decodeTrailers(_))\n      .WillOnce(Invoke([&](Http::HeaderMap& trailers) -> FilterTrailersStatus {\n        Http::LowerCaseString key(\"foo\");\n        EXPECT_EQ(trailers.get(key), nullptr);\n        return FilterTrailersStatus::Continue;\n      }));\n  EXPECT_CALL(*decoder_filters_[1], decodeComplete());\n\n  // Kick off the incoming data.\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n\n  // set up encodeHeaders expectations\n  EXPECT_CALL(*encoder_filters_[1], encodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(*encoder_filters_[0], encodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(response_encoder_, encodeHeaders(_, false));\n\n  // invoke encodeHeaders\n  decoder_filters_[0]->callbacks_->encodeHeaders(\n      HeaderMapPtr{new TestHeaderMapImpl{{\":status\", \"200\"}}}, false);\n\n  // set up encodeData expectations\n  EXPECT_CALL(*encoder_filters_[1], encodeData(_, false))\n      .WillOnce(Return(FilterDataStatus::Continue));\n  EXPECT_CALL(*encoder_filters_[0], encodeData(_, false))\n      .WillOnce(Return(FilterDataStatus::Continue));\n  EXPECT_CALL(response_encoder_, encodeData(_, false));\n\n  // invoke encodeData\n  Buffer::OwnedImpl response_body(\"response\");\n  decoder_filters_[0]->callbacks_->encodeData(response_body, false);\n  // set up encodeTrailer expectations\n  EXPECT_CALL(*encoder_filters_[1], encodeTrailers(_))\n      .WillOnce(Return(FilterTrailersStatus::Continue));\n  EXPECT_CALL(*encoder_filters_[1], encodeComplete());\n\n  EXPECT_CALL(*encoder_filters_[0], encodeTrailers(_))\n      .WillOnce(Invoke([&](Http::HeaderMap& trailers) -> FilterTrailersStatus {\n        // assert that the trailers set in the previous filter was ignored\n        Http::LowerCaseString key(\"foo\");\n        EXPECT_EQ(trailers.get(key), nullptr);\n        return FilterTrailersStatus::Continue;\n      }));\n  EXPECT_CALL(*encoder_filters_[0], encodeComplete());\n  EXPECT_CALL(response_encoder_, encodeTrailers(_));\n  expectOnDestroy();\n\n  // invoke encodeTrailers\n  decoder_filters_[0]->callbacks_->encodeTrailers(\n      HeaderMapPtr{new TestHeaderMapImpl{{\"some\", \"trailer\"}}});\n}\n\nTEST_F(HttpConnectionManagerImplTest, FilterAddTrailersInDataCallbackNoTrailers) {\n  InSequence s;\n  setup(false, \"\");\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n    decoder->decodeHeaders(std::move(headers), false);\n\n    Buffer::OwnedImpl fake_data(\"hello\");\n    decoder->decodeData(fake_data, true);\n  }));\n\n  setupFilterChain(2, 2);\n\n  std::string trailers_data(\"trailers\");\n  Http::LowerCaseString trailer_key(\"foo\");\n  EXPECT_CALL(*decoder_filters_[0], decodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(*decoder_filters_[1], decodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(*decoder_filters_[0], decodeData(_, true))\n      .WillOnce(InvokeWithoutArgs([&]() -> FilterDataStatus {\n        decoder_filters_[0]->callbacks_->addDecodedTrailers().addCopy(trailer_key, trailers_data);\n        return FilterDataStatus::Continue;\n      }));\n  EXPECT_CALL(*decoder_filters_[0], decodeComplete());\n\n  // ensure that the second decodeData call sees end_stream = false\n  EXPECT_CALL(*decoder_filters_[1], decodeData(_, false))\n      .WillOnce(Return(FilterDataStatus::Continue));\n\n  // since we added trailers, we should see decodeTrailers\n  EXPECT_CALL(*decoder_filters_[1], decodeTrailers(_)).WillOnce(Invoke([&](HeaderMap& trailers) {\n    // ensure that we see the trailers set in decodeData\n    Http::LowerCaseString key(\"foo\");\n    auto t = trailers.get(key);\n    ASSERT(t);\n    EXPECT_EQ(t->value(), trailers_data.c_str());\n    return FilterTrailersStatus::Continue;\n  }));\n  EXPECT_CALL(*decoder_filters_[1], decodeComplete());\n\n  // Kick off the incoming data.\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n\n  // set up encodeHeaders expectations\n  EXPECT_CALL(*encoder_filters_[1], encodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(*encoder_filters_[0], encodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(response_encoder_, encodeHeaders(_, false));\n\n  // invoke encodeHeaders\n  decoder_filters_[0]->callbacks_->encodeHeaders(\n      HeaderMapPtr{new TestHeaderMapImpl{{\":status\", \"200\"}}}, false);\n\n  // set up encodeData expectations\n  EXPECT_CALL(*encoder_filters_[1], encodeData(_, true))\n      .WillOnce(InvokeWithoutArgs([&]() -> FilterDataStatus {\n        encoder_filters_[1]->callbacks_->addEncodedTrailers().addCopy(trailer_key, trailers_data);\n        return FilterDataStatus::Continue;\n      }));\n  EXPECT_CALL(*encoder_filters_[1], encodeComplete());\n  // ensure encodeData calls after setting header sees end_stream = false\n  EXPECT_CALL(*encoder_filters_[0], encodeData(_, false))\n      .WillOnce(Return(FilterDataStatus::Continue));\n\n  EXPECT_CALL(response_encoder_, encodeData(_, false));\n\n  // since we added trailers, we should see encodeTrailer callbacks\n  EXPECT_CALL(*encoder_filters_[0], encodeTrailers(_)).WillOnce(Invoke([&](HeaderMap& trailers) {\n    // ensure that we see the trailers set in decodeData\n    Http::LowerCaseString key(\"foo\");\n    auto t = trailers.get(key);\n    EXPECT_EQ(t->value(), trailers_data.c_str());\n    return FilterTrailersStatus::Continue;\n  }));\n  EXPECT_CALL(*encoder_filters_[0], encodeComplete());\n\n  // Ensure that we call encodeTrailers\n  EXPECT_CALL(response_encoder_, encodeTrailers(_));\n\n  expectOnDestroy();\n  // invoke encodeData\n  Buffer::OwnedImpl response_body(\"response\");\n  decoder_filters_[0]->callbacks_->encodeData(response_body, true);\n}\n\nTEST_F(HttpConnectionManagerImplTest, FilterAddBodyInTrailersCallback) {\n  InSequence s;\n  setup(false, \"\");\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n    decoder->decodeHeaders(std::move(headers), false);\n\n    Buffer::OwnedImpl fake_data(\"hello\");\n    decoder->decodeData(fake_data, false);\n\n    HeaderMapPtr trailers{new TestHeaderMapImpl{{\"foo\", \"bar\"}}};\n    decoder->decodeTrailers(std::move(trailers));\n  }));\n\n  setupFilterChain(2, 2);\n\n  EXPECT_CALL(*decoder_filters_[0], decodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(*decoder_filters_[1], decodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::StopIteration));\n  EXPECT_CALL(*decoder_filters_[0], decodeData(_, false))\n      .WillOnce(Return(FilterDataStatus::Continue));\n  EXPECT_CALL(*decoder_filters_[1], decodeData(_, false))\n      .WillOnce(Return(FilterDataStatus::StopIterationAndBuffer));\n  Buffer::OwnedImpl trailers_data(\"hello\");\n  EXPECT_CALL(*decoder_filters_[0], decodeTrailers(_))\n      .WillOnce(InvokeWithoutArgs([&]() -> FilterTrailersStatus {\n        decoder_filters_[0]->callbacks_->addDecodedData(trailers_data, true);\n        return FilterTrailersStatus::Continue;\n      }));\n  EXPECT_CALL(*decoder_filters_[1], decodeData(Ref(trailers_data), false))\n      .WillOnce(Return(FilterDataStatus::StopIterationAndBuffer));\n  EXPECT_CALL(*decoder_filters_[0], decodeComplete());\n  EXPECT_CALL(*decoder_filters_[1], decodeTrailers(_))\n      .WillOnce(Return(FilterTrailersStatus::StopIteration));\n  EXPECT_CALL(*decoder_filters_[1], decodeComplete());\n\n  // Kick off the incoming data.\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n\n  EXPECT_CALL(*encoder_filters_[1], encodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(*encoder_filters_[0], encodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(response_encoder_, encodeHeaders(_, false));\n\n  decoder_filters_[1]->callbacks_->encodeHeaders(\n      HeaderMapPtr{new TestHeaderMapImpl{{\":status\", \"200\"}}}, false);\n\n  EXPECT_CALL(*encoder_filters_[1], encodeData(_, false))\n      .WillOnce(Return(FilterDataStatus::Continue));\n  EXPECT_CALL(*encoder_filters_[0], encodeData(_, false))\n      .WillOnce(Return(FilterDataStatus::Continue));\n  EXPECT_CALL(response_encoder_, encodeData(_, false));\n\n  Buffer::OwnedImpl response_body(\"response\");\n  decoder_filters_[1]->callbacks_->encodeData(response_body, false);\n  EXPECT_CALL(*encoder_filters_[1], encodeTrailers(_))\n      .WillOnce(InvokeWithoutArgs([&]() -> FilterTrailersStatus {\n        encoder_filters_[1]->callbacks_->addEncodedData(trailers_data, true);\n        return FilterTrailersStatus::Continue;\n      }));\n  EXPECT_CALL(*encoder_filters_[0], encodeData(Ref(trailers_data), false))\n      .WillOnce(Return(FilterDataStatus::Continue));\n  EXPECT_CALL(response_encoder_, encodeData(_, false));\n  EXPECT_CALL(*encoder_filters_[1], encodeComplete());\n  EXPECT_CALL(*encoder_filters_[0], encodeTrailers(_))\n      .WillOnce(Return(FilterTrailersStatus::Continue));\n  EXPECT_CALL(*encoder_filters_[0], encodeComplete());\n  EXPECT_CALL(response_encoder_, encodeTrailers(_));\n  expectOnDestroy();\n\n  decoder_filters_[1]->callbacks_->encodeTrailers(\n      HeaderMapPtr{new TestHeaderMapImpl{{\"some\", \"trailer\"}}});\n}\n\n// Don't send data frames, only headers and trailers.\nTEST_F(HttpConnectionManagerImplTest, FilterAddBodyInTrailersCallback_NoDataFrames) {\n  InSequence s;\n  setup(false, \"\");\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n    decoder->decodeHeaders(std::move(headers), false);\n\n    HeaderMapPtr trailers{new TestHeaderMapImpl{{\"foo\", \"bar\"}}};\n    decoder->decodeTrailers(std::move(trailers));\n  }));\n\n  setupFilterChain(2, 1);\n\n  EXPECT_CALL(*decoder_filters_[0], decodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::StopIteration));\n\n  Buffer::OwnedImpl trailers_data(\"hello\");\n  EXPECT_CALL(*decoder_filters_[0], decodeTrailers(_))\n      .WillOnce(InvokeWithoutArgs([&]() -> FilterTrailersStatus {\n        decoder_filters_[0]->callbacks_->addDecodedData(trailers_data, false);\n        return FilterTrailersStatus::Continue;\n      }));\n  EXPECT_CALL(*decoder_filters_[0], decodeComplete());\n  EXPECT_CALL(*decoder_filters_[1], decodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::StopIteration));\n  EXPECT_CALL(*decoder_filters_[1], decodeData(_, false))\n      .WillOnce(Return(FilterDataStatus::StopIterationAndBuffer));\n  EXPECT_CALL(*decoder_filters_[1], decodeTrailers(_))\n      .WillOnce(Return(FilterTrailersStatus::StopIteration));\n  EXPECT_CALL(*decoder_filters_[1], decodeComplete());\n\n  // Kick off the incoming data.\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n\n  EXPECT_CALL(*encoder_filters_[0], encodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::StopIteration));\n  decoder_filters_[0]->callbacks_->encodeHeaders(\n      HeaderMapPtr{new TestHeaderMapImpl{{\":status\", \"200\"}}}, false);\n\n  EXPECT_CALL(*encoder_filters_[0], encodeTrailers(_))\n      .WillOnce(InvokeWithoutArgs([&]() -> FilterTrailersStatus {\n        encoder_filters_[0]->callbacks_->addEncodedData(trailers_data, false);\n        return FilterTrailersStatus::Continue;\n      }));\n  EXPECT_CALL(*encoder_filters_[0], encodeComplete());\n  EXPECT_CALL(response_encoder_, encodeHeaders(_, false));\n  EXPECT_CALL(response_encoder_, encodeData(_, false));\n  EXPECT_CALL(response_encoder_, encodeTrailers(_));\n  expectOnDestroy();\n\n  decoder_filters_[0]->callbacks_->encodeTrailers(\n      HeaderMapPtr{new TestHeaderMapImpl{{\"some\", \"trailer\"}}});\n}\n\n// Don't send data frames, only headers and trailers.\nTEST_F(HttpConnectionManagerImplTest, FilterAddBodyInTrailersCallback_ContinueAfterCallback) {\n  InSequence s;\n  setup(false, \"\");\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n    decoder->decodeHeaders(std::move(headers), false);\n\n    HeaderMapPtr trailers{new TestHeaderMapImpl{{\"foo\", \"bar\"}}};\n    decoder->decodeTrailers(std::move(trailers));\n  }));\n\n  setupFilterChain(2, 1);\n\n  EXPECT_CALL(*decoder_filters_[0], decodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::StopIteration));\n\n  Buffer::OwnedImpl trailers_data(\"hello\");\n  EXPECT_CALL(*decoder_filters_[0], decodeTrailers(_))\n      .WillOnce(InvokeWithoutArgs([&]() -> FilterTrailersStatus {\n        decoder_filters_[0]->callbacks_->addDecodedData(trailers_data, false);\n        return FilterTrailersStatus::StopIteration;\n      }));\n  EXPECT_CALL(*decoder_filters_[0], decodeComplete());\n\n  // Kick off the incoming data.\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n\n  EXPECT_CALL(*decoder_filters_[1], decodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::StopIteration));\n  EXPECT_CALL(*decoder_filters_[1], decodeData(_, false))\n      .WillOnce(Return(FilterDataStatus::StopIterationAndBuffer));\n  EXPECT_CALL(*decoder_filters_[1], decodeTrailers(_))\n      .WillOnce(Return(FilterTrailersStatus::StopIteration));\n  EXPECT_CALL(*decoder_filters_[1], decodeComplete());\n\n  decoder_filters_[0]->callbacks_->continueDecoding();\n\n  EXPECT_CALL(*encoder_filters_[0], encodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::StopIteration));\n  decoder_filters_[0]->callbacks_->encodeHeaders(\n      HeaderMapPtr{new TestHeaderMapImpl{{\":status\", \"200\"}}}, false);\n\n  EXPECT_CALL(*encoder_filters_[0], encodeTrailers(_))\n      .WillOnce(InvokeWithoutArgs([&]() -> FilterTrailersStatus {\n        encoder_filters_[0]->callbacks_->addEncodedData(trailers_data, false);\n        return FilterTrailersStatus::StopIteration;\n      }));\n  EXPECT_CALL(*encoder_filters_[0], encodeComplete());\n\n  decoder_filters_[0]->callbacks_->encodeTrailers(\n      HeaderMapPtr{new TestHeaderMapImpl{{\"some\", \"trailer\"}}});\n\n  EXPECT_CALL(response_encoder_, encodeHeaders(_, false));\n  EXPECT_CALL(response_encoder_, encodeData(_, false));\n  EXPECT_CALL(response_encoder_, encodeTrailers(_));\n  expectOnDestroy();\n\n  encoder_filters_[0]->callbacks_->continueEncoding();\n}\n\n// Add*Data during the *Data callbacks.\nTEST_F(HttpConnectionManagerImplTest, FilterAddBodyDuringDecodeData) {\n  InSequence s;\n  setup(false, \"\");\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n    decoder->decodeHeaders(std::move(headers), false);\n\n    Buffer::OwnedImpl data1(\"hello\");\n    decoder->decodeData(data1, false);\n\n    Buffer::OwnedImpl data2(\"world\");\n    decoder->decodeData(data2, true);\n  }));\n\n  setupFilterChain(2, 2);\n\n  EXPECT_CALL(*decoder_filters_[0], decodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::StopIteration));\n  EXPECT_CALL(*decoder_filters_[0], decodeData(_, false))\n      .WillOnce(Return(FilterDataStatus::StopIterationAndBuffer));\n  EXPECT_CALL(*decoder_filters_[0], decodeData(_, true))\n      .WillOnce(Invoke([&](Buffer::Instance& data, bool) -> FilterDataStatus {\n        decoder_filters_[0]->callbacks_->addDecodedData(data, true);\n        EXPECT_EQ(decoder_filters_[0]->callbacks_->decodingBuffer()->toString(), \"helloworld\");\n        return FilterDataStatus::Continue;\n      }));\n  EXPECT_CALL(*decoder_filters_[0], decodeComplete());\n  EXPECT_CALL(*decoder_filters_[1], decodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(*decoder_filters_[1], decodeData(_, true))\n      .WillOnce(Return(FilterDataStatus::Continue));\n  EXPECT_CALL(*decoder_filters_[1], decodeComplete());\n\n  // Kick off the incoming data.\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n\n  EXPECT_CALL(*encoder_filters_[1], encodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::StopIteration));\n  EXPECT_CALL(*encoder_filters_[1], encodeData(_, false))\n      .WillOnce(Return(FilterDataStatus::StopIterationAndBuffer));\n  EXPECT_CALL(*encoder_filters_[1], encodeData(_, true))\n      .WillOnce(Invoke([&](Buffer::Instance& data, bool) -> FilterDataStatus {\n        encoder_filters_[1]->callbacks_->addEncodedData(data, true);\n        EXPECT_EQ(encoder_filters_[1]->callbacks_->encodingBuffer()->toString(), \"goodbye\");\n        return FilterDataStatus::Continue;\n      }));\n  EXPECT_CALL(*encoder_filters_[1], encodeComplete());\n  EXPECT_CALL(*encoder_filters_[0], encodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(response_encoder_, encodeHeaders(_, false));\n  EXPECT_CALL(*encoder_filters_[0], encodeData(_, true))\n      .WillOnce(Return(FilterDataStatus::Continue));\n  EXPECT_CALL(*encoder_filters_[0], encodeComplete());\n  EXPECT_CALL(response_encoder_, encodeData(_, true));\n  expectOnDestroy();\n\n  decoder_filters_[1]->callbacks_->encodeHeaders(\n      HeaderMapPtr{new TestHeaderMapImpl{{\":status\", \"200\"}}}, false);\n  Buffer::OwnedImpl data1(\"good\");\n  decoder_filters_[1]->callbacks_->encodeData(data1, false);\n  Buffer::OwnedImpl data2(\"bye\");\n  decoder_filters_[1]->callbacks_->encodeData(data2, true);\n}\n\nTEST_F(HttpConnectionManagerImplTest, FilterAddBodyInline) {\n  InSequence s;\n  setup(false, \"\");\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n    decoder->decodeHeaders(std::move(headers), true);\n  }));\n\n  setupFilterChain(2, 2);\n\n  EXPECT_CALL(*decoder_filters_[0], decodeHeaders(_, true))\n      .WillOnce(InvokeWithoutArgs([&]() -> FilterHeadersStatus {\n        Buffer::OwnedImpl data(\"hello\");\n        decoder_filters_[0]->callbacks_->addDecodedData(data, true);\n        return FilterHeadersStatus::Continue;\n      }));\n  EXPECT_CALL(*decoder_filters_[0], decodeComplete());\n  EXPECT_CALL(*decoder_filters_[1], decodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::StopIteration));\n  EXPECT_CALL(*decoder_filters_[1], decodeData(_, true))\n      .WillOnce(Return(FilterDataStatus::StopIterationAndBuffer));\n  EXPECT_CALL(*decoder_filters_[1], decodeComplete());\n\n  // Kick off the incoming data.\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n\n  EXPECT_CALL(*encoder_filters_[1], encodeHeaders(_, true))\n      .WillOnce(InvokeWithoutArgs([&]() -> FilterHeadersStatus {\n        Buffer::OwnedImpl data(\"hello\");\n        encoder_filters_[1]->callbacks_->addEncodedData(data, true);\n        EXPECT_EQ(5UL, encoder_filters_[0]->callbacks_->encodingBuffer()->length());\n        return FilterHeadersStatus::Continue;\n      }));\n  EXPECT_CALL(*encoder_filters_[1], encodeComplete());\n  EXPECT_CALL(*encoder_filters_[0], encodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(response_encoder_, encodeHeaders(_, false));\n  EXPECT_CALL(*encoder_filters_[0], encodeData(_, true))\n      .WillOnce(Return(FilterDataStatus::Continue));\n  EXPECT_CALL(*encoder_filters_[0], encodeComplete());\n  EXPECT_CALL(response_encoder_, encodeData(_, true));\n  expectOnDestroy();\n\n  decoder_filters_[1]->callbacks_->encodeHeaders(\n      HeaderMapPtr{new TestHeaderMapImpl{{\":status\", \"200\"}}}, true);\n}\n\nTEST_F(HttpConnectionManagerImplTest, FilterClearRouteCache) {\n  setup(false, \"\");\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n    decoder->decodeHeaders(std::move(headers), true);\n  }));\n\n  setupFilterChain(3, 2);\n  const std::string fake_cluster1_name = \"fake_cluster1\";\n  const std::string fake_cluster2_name = \"fake_cluster2\";\n\n  std::shared_ptr<Upstream::MockThreadLocalCluster> fake_cluster1 =\n      std::make_shared<NiceMock<Upstream::MockThreadLocalCluster>>();\n  EXPECT_CALL(cluster_manager_, get(_))\n      .WillOnce(Return(fake_cluster1.get()))\n      .WillOnce(Return(nullptr));\n\n  std::shared_ptr<Router::MockRoute> route1 = std::make_shared<NiceMock<Router::MockRoute>>();\n  EXPECT_CALL(route1->route_entry_, clusterName()).WillRepeatedly(ReturnRef(fake_cluster1_name));\n  std::shared_ptr<Router::MockRoute> route2 = std::make_shared<NiceMock<Router::MockRoute>>();\n  EXPECT_CALL(route2->route_entry_, clusterName()).WillRepeatedly(ReturnRef(fake_cluster2_name));\n\n  EXPECT_CALL(*route_config_provider_.route_config_, route(_, _))\n      .WillOnce(Return(route1))\n      .WillOnce(Return(route2))\n      .WillOnce(Return(nullptr));\n\n  EXPECT_CALL(*decoder_filters_[0], decodeHeaders(_, true))\n      .WillOnce(InvokeWithoutArgs([&]() -> FilterHeadersStatus {\n        EXPECT_EQ(route1, decoder_filters_[0]->callbacks_->route());\n        EXPECT_EQ(route1->routeEntry(), decoder_filters_[0]->callbacks_->streamInfo().routeEntry());\n        EXPECT_EQ(fake_cluster1->info(), decoder_filters_[0]->callbacks_->clusterInfo());\n        decoder_filters_[0]->callbacks_->clearRouteCache();\n        return FilterHeadersStatus::Continue;\n      }));\n  EXPECT_CALL(*decoder_filters_[0], decodeComplete());\n  EXPECT_CALL(*decoder_filters_[1], decodeHeaders(_, true))\n      .WillOnce(InvokeWithoutArgs([&]() -> FilterHeadersStatus {\n        EXPECT_EQ(route2, decoder_filters_[1]->callbacks_->route());\n        EXPECT_EQ(route2->routeEntry(), decoder_filters_[1]->callbacks_->streamInfo().routeEntry());\n        // RDS & CDS consistency problem: route2 points to fake_cluster2, which doesn't exist.\n        EXPECT_EQ(nullptr, decoder_filters_[1]->callbacks_->clusterInfo());\n        decoder_filters_[1]->callbacks_->clearRouteCache();\n        return FilterHeadersStatus::Continue;\n      }));\n  EXPECT_CALL(*decoder_filters_[1], decodeComplete());\n  EXPECT_CALL(*decoder_filters_[2], decodeHeaders(_, true))\n      .WillOnce(InvokeWithoutArgs([&]() -> FilterHeadersStatus {\n        EXPECT_EQ(nullptr, decoder_filters_[2]->callbacks_->clusterInfo());\n        EXPECT_EQ(nullptr, decoder_filters_[2]->callbacks_->route());\n        EXPECT_EQ(nullptr, decoder_filters_[2]->callbacks_->streamInfo().routeEntry());\n        return FilterHeadersStatus::StopIteration;\n      }));\n  EXPECT_CALL(*decoder_filters_[2], decodeComplete());\n\n  // Kick off the incoming data.\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n}\n\nTEST_F(HttpConnectionManagerImplTest, UpstreamWatermarkCallbacks) {\n  setup(false, \"\");\n  setUpEncoderAndDecoder(false, false);\n  sendRequestHeadersAndData();\n\n  // Mimic the upstream connection backing up. The router would call\n  // onDecoderFilterAboveWriteBufferHighWatermark which should readDisable the stream and increment\n  // stats.\n  EXPECT_CALL(response_encoder_, getStream()).WillOnce(ReturnRef(stream_));\n  EXPECT_CALL(stream_, readDisable(true));\n  ASSERT(decoder_filters_[0]->callbacks_ != nullptr);\n  decoder_filters_[0]->callbacks_->onDecoderFilterAboveWriteBufferHighWatermark();\n  EXPECT_EQ(1U, stats_.named_.downstream_flow_control_paused_reading_total_.value());\n\n  // Resume the flow of data. When the router buffer drains it calls\n  // onDecoderFilterBelowWriteBufferLowWatermark which should re-enable reads on the stream.\n  EXPECT_CALL(response_encoder_, getStream()).WillOnce(ReturnRef(stream_));\n  EXPECT_CALL(stream_, readDisable(false));\n  ASSERT(decoder_filters_[0]->callbacks_ != nullptr);\n  decoder_filters_[0]->callbacks_->onDecoderFilterBelowWriteBufferLowWatermark();\n  EXPECT_EQ(1U, stats_.named_.downstream_flow_control_resumed_reading_total_.value());\n\n  // Backup upstream once again.\n  EXPECT_CALL(response_encoder_, getStream()).WillOnce(ReturnRef(stream_));\n  EXPECT_CALL(stream_, readDisable(true));\n  ASSERT(decoder_filters_[0]->callbacks_ != nullptr);\n  decoder_filters_[0]->callbacks_->onDecoderFilterAboveWriteBufferHighWatermark();\n  EXPECT_EQ(2U, stats_.named_.downstream_flow_control_paused_reading_total_.value());\n\n  // Send a full response.\n  EXPECT_CALL(*encoder_filters_[0], encodeHeaders(_, true));\n  EXPECT_CALL(*encoder_filters_[0], encodeComplete());\n  EXPECT_CALL(*encoder_filters_[1], encodeHeaders(_, true));\n  EXPECT_CALL(*encoder_filters_[1], encodeComplete());\n  EXPECT_CALL(response_encoder_, encodeHeaders(_, true));\n  // When the stream ends, the manager should check to see if the connection is\n  // read disabled, and keep calling readDisable(false) until readEnabled()\n  // returns true.\n  EXPECT_CALL(filter_callbacks_.connection_, readEnabled())\n      .Times(2)\n      .WillOnce(Return(false))\n      .WillRepeatedly(Return(true));\n  EXPECT_CALL(filter_callbacks_.connection_, readDisable(false));\n  expectOnDestroy();\n  decoder_filters_[1]->callbacks_->encodeHeaders(\n      HeaderMapPtr{new TestHeaderMapImpl{{\":status\", \"200\"}}}, true);\n}\n\nTEST_F(HttpConnectionManagerImplTest, UnderlyingConnectionWatermarksPassedOnWithLazyCreation) {\n  setup(false, \"\");\n\n  // Make sure codec_ is created.\n  EXPECT_CALL(*codec_, dispatch(_));\n  Buffer::OwnedImpl fake_input(\"\");\n  conn_manager_->onData(fake_input, false);\n\n  // Mark the connection manger as backed up before the stream is created.\n  ASSERT_EQ(decoder_filters_.size(), 0);\n  EXPECT_CALL(*codec_, onUnderlyingConnectionAboveWriteBufferHighWatermark());\n  conn_manager_->onAboveWriteBufferHighWatermark();\n\n  // Create the stream. Defer the creation of the filter chain by not sending\n  // complete headers.\n  StreamDecoder* decoder;\n  {\n    setUpBufferLimits();\n    EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n      decoder = &conn_manager_->newStream(response_encoder_);\n      // Call the high buffer callbacks as the codecs do.\n      stream_callbacks_->onAboveWriteBufferHighWatermark();\n    }));\n\n    // Send fake data to kick off newStream being created.\n    Buffer::OwnedImpl fake_input2(\"asdf\");\n    conn_manager_->onData(fake_input2, false);\n  }\n\n  // Now set up the filter chain by sending full headers. The filters should be\n  // immediately appraised that the low watermark is in effect.\n  {\n    setupFilterChain(2, 2);\n    EXPECT_CALL(filter_callbacks_.connection_, aboveHighWatermark()).Times(0);\n    EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n      HeaderMapPtr headers{\n          new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n      decoder->decodeHeaders(std::move(headers), true);\n    }));\n    EXPECT_CALL(*decoder_filters_[0], decodeHeaders(_, true))\n        .WillOnce(InvokeWithoutArgs([&]() -> FilterHeadersStatus {\n          Buffer::OwnedImpl data(\"hello\");\n          decoder_filters_[0]->callbacks_->addDecodedData(data, true);\n          return FilterHeadersStatus::Continue;\n        }));\n    EXPECT_CALL(*decoder_filters_[0], decodeComplete());\n    sendRequestHeadersAndData();\n    ASSERT_GE(decoder_filters_.size(), 1);\n    MockDownstreamWatermarkCallbacks callbacks;\n    EXPECT_CALL(callbacks, onAboveWriteBufferHighWatermark());\n    decoder_filters_[0]->callbacks_->addDownstreamWatermarkCallbacks(callbacks);\n\n    // Ensures that when new callbacks are registered they get invoked immediately\n    // and the already-registered callbacks do not.\n    MockDownstreamWatermarkCallbacks callbacks2;\n    EXPECT_CALL(callbacks2, onAboveWriteBufferHighWatermark());\n    decoder_filters_[0]->callbacks_->addDownstreamWatermarkCallbacks(callbacks2);\n  }\n}\n\nTEST_F(HttpConnectionManagerImplTest, UnderlyingConnectionWatermarksUnwoundWithLazyCreation) {\n  setup(false, \"\");\n\n  // Make sure codec_ is created.\n  EXPECT_CALL(*codec_, dispatch(_));\n  Buffer::OwnedImpl fake_input(\"\");\n  conn_manager_->onData(fake_input, false);\n\n  // Mark the connection manger as backed up before the stream is created.\n  ASSERT_EQ(decoder_filters_.size(), 0);\n  EXPECT_CALL(*codec_, onUnderlyingConnectionAboveWriteBufferHighWatermark());\n  conn_manager_->onAboveWriteBufferHighWatermark();\n\n  // Create the stream. Defer the creation of the filter chain by not sending\n  // complete headers.\n  StreamDecoder* decoder;\n  {\n    setUpBufferLimits();\n    EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n      decoder = &conn_manager_->newStream(response_encoder_);\n      // Call the high buffer callbacks as the codecs do.\n      stream_callbacks_->onAboveWriteBufferHighWatermark();\n    }));\n\n    // Send fake data to kick off newStream being created.\n    Buffer::OwnedImpl fake_input2(\"asdf\");\n    conn_manager_->onData(fake_input2, false);\n  }\n\n  // Now before the filter chain is created, fire the low watermark callbacks\n  // and ensure it is passed down to the stream.\n  ASSERT(stream_callbacks_ != nullptr);\n  EXPECT_CALL(*codec_, onUnderlyingConnectionBelowWriteBufferLowWatermark())\n      .WillOnce(Invoke([&]() -> void { stream_callbacks_->onBelowWriteBufferLowWatermark(); }));\n  conn_manager_->onBelowWriteBufferLowWatermark();\n\n  // Now set up the filter chain by sending full headers. The filters should\n  // not get any watermark callbacks.\n  {\n    setupFilterChain(2, 2);\n    EXPECT_CALL(filter_callbacks_.connection_, aboveHighWatermark()).Times(0);\n    EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n      HeaderMapPtr headers{\n          new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n      decoder->decodeHeaders(std::move(headers), true);\n    }));\n    EXPECT_CALL(*decoder_filters_[0], decodeHeaders(_, true))\n        .WillOnce(InvokeWithoutArgs([&]() -> FilterHeadersStatus {\n          Buffer::OwnedImpl data(\"hello\");\n          decoder_filters_[0]->callbacks_->addDecodedData(data, true);\n          return FilterHeadersStatus::Continue;\n        }));\n    EXPECT_CALL(*decoder_filters_[0], decodeComplete());\n    sendRequestHeadersAndData();\n    ASSERT_GE(decoder_filters_.size(), 1);\n    MockDownstreamWatermarkCallbacks callbacks;\n    EXPECT_CALL(callbacks, onAboveWriteBufferHighWatermark()).Times(0);\n    EXPECT_CALL(callbacks, onBelowWriteBufferLowWatermark()).Times(0);\n    decoder_filters_[0]->callbacks_->addDownstreamWatermarkCallbacks(callbacks);\n  }\n}\n\nTEST_F(HttpConnectionManagerImplTest, AlterFilterWatermarkLimits) {\n  initial_buffer_limit_ = 100;\n  setup(false, \"\");\n  setUpEncoderAndDecoder(false, false);\n  sendRequestHeadersAndData();\n\n  // Check initial limits.\n  EXPECT_EQ(initial_buffer_limit_, decoder_filters_[0]->callbacks_->decoderBufferLimit());\n  EXPECT_EQ(initial_buffer_limit_, encoder_filters_[0]->callbacks_->encoderBufferLimit());\n\n  // Check lowering the limits.\n  decoder_filters_[0]->callbacks_->setDecoderBufferLimit(initial_buffer_limit_ - 1);\n  EXPECT_EQ(initial_buffer_limit_ - 1, decoder_filters_[0]->callbacks_->decoderBufferLimit());\n\n  // Check raising the limits.\n  decoder_filters_[0]->callbacks_->setDecoderBufferLimit(initial_buffer_limit_ + 1);\n  EXPECT_EQ(initial_buffer_limit_ + 1, decoder_filters_[0]->callbacks_->decoderBufferLimit());\n  EXPECT_EQ(initial_buffer_limit_ + 1, encoder_filters_[0]->callbacks_->encoderBufferLimit());\n\n  // Verify turning off buffer limits works.\n  decoder_filters_[0]->callbacks_->setDecoderBufferLimit(0);\n  EXPECT_EQ(0, decoder_filters_[0]->callbacks_->decoderBufferLimit());\n\n  // Once the limits are turned off can be turned on again.\n  decoder_filters_[0]->callbacks_->setDecoderBufferLimit(100);\n  EXPECT_EQ(100, decoder_filters_[0]->callbacks_->decoderBufferLimit());\n}\n\nTEST_F(HttpConnectionManagerImplTest, HitFilterWatermarkLimits) {\n  initial_buffer_limit_ = 1;\n  streaming_filter_ = true;\n  setup(false, \"\");\n  setUpEncoderAndDecoder(false, false);\n\n  // The filter is a streaming filter. Sending 4 bytes should hit the\n  // watermark limit and disable reads on the stream.\n  EXPECT_CALL(stream_, readDisable(true));\n  sendRequestHeadersAndData();\n\n  // Change the limit so the buffered data is below the new watermark. The\n  // stream should be read-enabled\n  EXPECT_CALL(stream_, readDisable(false));\n  int buffer_len = decoder_filters_[0]->callbacks_->decodingBuffer()->length();\n  decoder_filters_[0]->callbacks_->setDecoderBufferLimit((buffer_len + 1) * 2);\n\n  // Start the response\n  HeaderMapPtr response_headers{new TestHeaderMapImpl{{\":status\", \"200\"}}};\n  EXPECT_CALL(*encoder_filters_[1], encodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::StopIteration));\n  decoder_filters_[0]->callbacks_->encodeHeaders(std::move(response_headers), false);\n\n  MockDownstreamWatermarkCallbacks callbacks;\n  decoder_filters_[0]->callbacks_->addDownstreamWatermarkCallbacks(callbacks);\n  MockDownstreamWatermarkCallbacks callbacks2;\n  decoder_filters_[0]->callbacks_->addDownstreamWatermarkCallbacks(callbacks2);\n\n  // Now overload the buffer with response data. The downstream watermark\n  // callbacks should be called.\n  EXPECT_CALL(callbacks, onAboveWriteBufferHighWatermark());\n  EXPECT_CALL(callbacks2, onAboveWriteBufferHighWatermark());\n  Buffer::OwnedImpl fake_response(\"A long enough string to go over watermarks\");\n  EXPECT_CALL(*encoder_filters_[1], encodeData(_, false))\n      .WillOnce(Return(FilterDataStatus::StopIterationAndWatermark));\n  decoder_filters_[0]->callbacks_->encodeData(fake_response, false);\n\n  // unregister callbacks2\n  decoder_filters_[0]->callbacks_->removeDownstreamWatermarkCallbacks(callbacks2);\n\n  // Change the limit so the buffered data is below the new watermark.\n  buffer_len = encoder_filters_[1]->callbacks_->encodingBuffer()->length();\n  EXPECT_CALL(callbacks, onBelowWriteBufferLowWatermark());\n  EXPECT_CALL(callbacks2, onBelowWriteBufferLowWatermark()).Times(0);\n  encoder_filters_[1]->callbacks_->setEncoderBufferLimit((buffer_len + 1) * 2);\n}\n\nTEST_F(HttpConnectionManagerImplTest, HitRequestBufferLimits) {\n  initial_buffer_limit_ = 10;\n  streaming_filter_ = false;\n  setup(false, \"\");\n  setUpEncoderAndDecoder(false, false);\n  sendRequestHeadersAndData();\n\n  // Set the filter to be a buffering filter. Sending any data will hit the\n  // watermark limit and result in a 413 being sent to the user.\n  Http::TestHeaderMapImpl response_headers{\n      {\":status\", \"413\"}, {\"content-length\", \"17\"}, {\"content-type\", \"text/plain\"}};\n  EXPECT_CALL(*encoder_filters_[1], encodeHeaders(HeaderMapEqualRef(&response_headers), false))\n      .WillOnce(Return(FilterHeadersStatus::StopIteration));\n  EXPECT_CALL(*encoder_filters_[1], encodeData(_, true))\n      .WillOnce(Return(FilterDataStatus::StopIterationAndWatermark));\n  EXPECT_CALL(*encoder_filters_[1], encodeComplete());\n  Buffer::OwnedImpl data(\"A longer string\");\n  decoder_filters_[0]->callbacks_->addDecodedData(data, false);\n  const auto rc_details = encoder_filters_[1]->callbacks_->streamInfo().responseCodeDetails();\n  EXPECT_EQ(\"request_payload_too_large\", rc_details.value());\n}\n\n// Return 413 from an intermediate filter and make sure we don't continue the filter chain.\nTEST_F(HttpConnectionManagerImplTest, HitRequestBufferLimitsIntermediateFilter) {\n  InSequence s;\n  initial_buffer_limit_ = 10;\n  setup(false, \"\");\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n    decoder->decodeHeaders(std::move(headers), false);\n\n    Buffer::OwnedImpl fake_data(\"hello\");\n    decoder->decodeData(fake_data, false);\n\n    Buffer::OwnedImpl fake_data2(\"world world\");\n    decoder->decodeData(fake_data2, true);\n  }));\n\n  setUpBufferLimits();\n  setupFilterChain(2, 1);\n\n  EXPECT_CALL(*decoder_filters_[0], decodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::StopIteration));\n  EXPECT_CALL(*decoder_filters_[0], decodeData(_, false))\n      .WillOnce(Return(FilterDataStatus::StopIterationAndBuffer));\n  EXPECT_CALL(*decoder_filters_[0], decodeData(_, true))\n      .WillOnce(Return(FilterDataStatus::Continue));\n  EXPECT_CALL(*decoder_filters_[0], decodeComplete());\n  Http::TestHeaderMapImpl response_headers{\n      {\":status\", \"413\"}, {\"content-length\", \"17\"}, {\"content-type\", \"text/plain\"}};\n  EXPECT_CALL(*encoder_filters_[0], encodeHeaders(HeaderMapEqualRef(&response_headers), false))\n      .WillOnce(Return(FilterHeadersStatus::StopIteration));\n  EXPECT_CALL(*encoder_filters_[0], encodeData(_, true))\n      .WillOnce(Return(FilterDataStatus::StopIterationAndWatermark));\n  EXPECT_CALL(*encoder_filters_[0], encodeComplete());\n\n  // Kick off the incoming data.\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n}\n\nTEST_F(HttpConnectionManagerImplTest, HitResponseBufferLimitsBeforeHeaders) {\n  initial_buffer_limit_ = 10;\n  setup(false, \"\");\n  setUpEncoderAndDecoder(false, false);\n  sendRequestHeadersAndData();\n\n  // Start the response without processing the request headers through all\n  // filters.\n  HeaderMapPtr response_headers{new TestHeaderMapImpl{{\":status\", \"200\"}}};\n  EXPECT_CALL(*encoder_filters_[1], encodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::StopIteration));\n  decoder_filters_[0]->callbacks_->encodeHeaders(std::move(response_headers), false);\n\n  // Now overload the buffer with response data. The filter returns\n  // StopIterationAndBuffer, which will trigger an early response.\n\n  expectOnDestroy();\n  Http::TestHeaderMapImpl expected_response_headers{\n      {\":status\", \"500\"}, {\"content-length\", \"21\"}, {\"content-type\", \"text/plain\"}};\n  Buffer::OwnedImpl fake_response(\"A long enough string to go over watermarks\");\n  // Fake response starts doing through the filter.\n  EXPECT_CALL(*encoder_filters_[1], encodeData(_, false))\n      .WillOnce(Return(FilterDataStatus::StopIterationAndBuffer));\n  std::string response_body;\n  // The 500 goes directly to the encoder.\n  EXPECT_CALL(response_encoder_,\n              encodeHeaders(HeaderMapEqualRef(&expected_response_headers), false));\n  EXPECT_CALL(response_encoder_, encodeData(_, true)).WillOnce(AddBufferToString(&response_body));\n  decoder_filters_[0]->callbacks_->encodeData(fake_response, false);\n  EXPECT_EQ(\"Internal Server Error\", response_body);\n\n  EXPECT_EQ(1U, stats_.named_.rs_too_large_.value());\n}\n\nTEST_F(HttpConnectionManagerImplTest, HitResponseBufferLimitsAfterHeaders) {\n  initial_buffer_limit_ = 10;\n  setup(false, \"\");\n  setUpEncoderAndDecoder(false, false);\n  sendRequestHeadersAndData();\n\n  // Start the response, and make sure the request headers are fully processed.\n  HeaderMapPtr response_headers{new TestHeaderMapImpl{{\":status\", \"200\"}}};\n  EXPECT_CALL(*encoder_filters_[1], encodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(*encoder_filters_[0], encodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(response_encoder_, encodeHeaders(_, false));\n  decoder_filters_[0]->callbacks_->encodeHeaders(std::move(response_headers), false);\n\n  // Now overload the buffer with response data. The filter returns\n  // StopIterationAndBuffer, which will trigger an early reset.\n  const std::string data = \"A long enough string to go over watermarks\";\n  Buffer::OwnedImpl fake_response(data);\n  InSequence s;\n  EXPECT_CALL(*encoder_filters_[1], encodeData(_, false))\n      .WillOnce(Return(FilterDataStatus::StopIterationAndBuffer));\n  EXPECT_CALL(stream_, resetStream(_));\n  decoder_filters_[0]->callbacks_->encodeData(fake_response, false);\n\n  EXPECT_EQ(1U, stats_.named_.rs_too_large_.value());\n}\n\nTEST_F(HttpConnectionManagerImplTest, FilterHeadReply) {\n  InSequence s;\n  setup(false, \"\");\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance& data) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"HEAD\"}}};\n    decoder->decodeHeaders(std::move(headers), true);\n    data.drain(4);\n  }));\n\n  setupFilterChain(1, 1);\n\n  EXPECT_CALL(*decoder_filters_[0], decodeHeaders(_, true))\n      .WillOnce(InvokeWithoutArgs([&]() -> FilterHeadersStatus {\n        decoder_filters_[0]->callbacks_->sendLocalReply(Code::BadRequest, \"Bad request\", nullptr,\n                                                        absl::nullopt, \"\");\n        return FilterHeadersStatus::Continue;\n      }));\n\n  EXPECT_CALL(*encoder_filters_[0], encodeHeaders(_, true))\n      .WillOnce(Invoke([&](HeaderMap& headers, bool) -> FilterHeadersStatus {\n        EXPECT_EQ(\"11\", headers.ContentLength()->value().getStringView());\n        return FilterHeadersStatus::Continue;\n      }));\n  EXPECT_CALL(*encoder_filters_[0], encodeComplete());\n  EXPECT_CALL(response_encoder_, encodeHeaders(_, true));\n  expectOnDestroy();\n  EXPECT_CALL(*decoder_filters_[0], decodeComplete());\n  // Kick off the incoming data.\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n}\n\n// Verify that if an encoded stream has been ended, but gets stopped by a filter chain, we end\n// up resetting the stream in the doEndStream() path (e.g., via filter reset due to timeout, etc.),\n// we emit a reset to the codec.\nTEST_F(HttpConnectionManagerImplTest, ResetWithStoppedFilter) {\n  InSequence s;\n  setup(false, \"\");\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance& data) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n    decoder->decodeHeaders(std::move(headers), true);\n    data.drain(4);\n  }));\n\n  setupFilterChain(1, 1);\n\n  EXPECT_CALL(*decoder_filters_[0], decodeHeaders(_, true))\n      .WillOnce(InvokeWithoutArgs([&]() -> FilterHeadersStatus {\n        decoder_filters_[0]->callbacks_->sendLocalReply(Code::BadRequest, \"Bad request\", nullptr,\n                                                        absl::nullopt, \"\");\n        return FilterHeadersStatus::Continue;\n      }));\n\n  EXPECT_CALL(*encoder_filters_[0], encodeHeaders(_, false))\n      .WillOnce(Invoke([&](HeaderMap& headers, bool) -> FilterHeadersStatus {\n        EXPECT_EQ(\"11\", headers.ContentLength()->value().getStringView());\n        return FilterHeadersStatus::Continue;\n      }));\n  EXPECT_CALL(response_encoder_, encodeHeaders(_, false));\n  EXPECT_CALL(*encoder_filters_[0], encodeData(_, true))\n      .WillOnce(Invoke([&](Buffer::Instance&, bool) -> FilterDataStatus {\n        return FilterDataStatus::StopIterationAndBuffer;\n      }));\n\n  EXPECT_CALL(*encoder_filters_[0], encodeComplete());\n  EXPECT_CALL(*decoder_filters_[0], decodeComplete());\n\n  // Kick off the incoming data.\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n\n  EXPECT_CALL(response_encoder_.stream_, resetStream(_));\n  expectOnDestroy();\n  encoder_filters_[0]->callbacks_->resetStream();\n}\n\nTEST_F(HttpConnectionManagerImplTest, FilterContinueAndEndStreamHeaders) {\n  InSequence s;\n  setup(false, \"\");\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    auto headers = std::make_unique<TestHeaderMapImpl>(\n        std::initializer_list<std::pair<std::string, std::string>>(\n            {{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}));\n    decoder->decodeHeaders(std::move(headers), false);\n  }));\n\n  setupFilterChain(2, 2);\n\n  EXPECT_CALL(*decoder_filters_[0], decodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::ContinueAndEndStream));\n  EXPECT_CALL(*decoder_filters_[1], decodeHeaders(_, true))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(*decoder_filters_[1], decodeComplete());\n\n  // Kick off the incoming data.\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, true);\n\n  EXPECT_CALL(*encoder_filters_[1], encodeHeaders(_, true))\n      .WillOnce(Return(FilterHeadersStatus::ContinueAndEndStream));\n  EXPECT_CALL(*encoder_filters_[1], encodeComplete());\n  EXPECT_CALL(*encoder_filters_[0], encodeHeaders(_, true))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(*encoder_filters_[0], encodeComplete());\n  EXPECT_CALL(response_encoder_, encodeHeaders(_, true));\n\n  expectOnDestroy();\n\n  decoder_filters_[1]->callbacks_->encodeHeaders(makeHeaderMap({{\":status\", \"200\"}}), true);\n\n  Buffer::OwnedImpl response_body(\"response\");\n  decoder_filters_[1]->callbacks_->encodeData(response_body, true);\n}\n\nTEST_F(HttpConnectionManagerImplTest, FilterContinueAndEndStreamData) {\n  InSequence s;\n  setup(false, \"\");\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    auto headers = makeHeaderMap({{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}});\n    decoder->decodeHeaders(std::move(headers), false);\n\n    Buffer::OwnedImpl fake_data(\"hello\");\n    decoder->decodeData(fake_data, true);\n  }));\n\n  setupFilterChain(2, 2);\n\n  EXPECT_CALL(*decoder_filters_[0], decodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::ContinueAndEndStream));\n  EXPECT_CALL(*decoder_filters_[1], decodeHeaders(_, true))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(*decoder_filters_[1], decodeComplete());\n\n  // Kick off the incoming data.\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n\n  EXPECT_CALL(*encoder_filters_[1], encodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::ContinueAndEndStream));\n  EXPECT_CALL(*encoder_filters_[0], encodeHeaders(_, true))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(*encoder_filters_[0], encodeComplete());\n  EXPECT_CALL(response_encoder_, encodeHeaders(_, true));\n\n  expectOnDestroy();\n\n  decoder_filters_[1]->callbacks_->encodeHeaders(makeHeaderMap({{\":status\", \"200\"}}), false);\n\n  Buffer::OwnedImpl response_body(\"response\");\n  decoder_filters_[1]->callbacks_->encodeData(response_body, true);\n}\n\nTEST_F(HttpConnectionManagerImplTest, FilterContinueAndEndStreamTrailers) {\n  InSequence s;\n  setup(false, \"\");\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    auto headers = makeHeaderMap({{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}});\n    decoder->decodeHeaders(std::move(headers), false);\n\n    Buffer::OwnedImpl fake_data(\"hello\");\n    decoder->decodeData(fake_data, false);\n\n    auto trailers = makeHeaderMap({{\"foo\", \"bar\"}});\n    decoder->decodeTrailers(std::move(trailers));\n  }));\n\n  setupFilterChain(2, 2);\n\n  EXPECT_CALL(*decoder_filters_[0], decodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::ContinueAndEndStream));\n  EXPECT_CALL(*decoder_filters_[1], decodeHeaders(_, true))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(*decoder_filters_[1], decodeComplete());\n\n  // Kick off the incoming data.\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n\n  EXPECT_CALL(*encoder_filters_[1], encodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::ContinueAndEndStream));\n  EXPECT_CALL(*encoder_filters_[0], encodeHeaders(_, true))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(*encoder_filters_[0], encodeComplete());\n  EXPECT_CALL(response_encoder_, encodeHeaders(_, true));\n\n  expectOnDestroy();\n\n  decoder_filters_[1]->callbacks_->encodeHeaders(makeHeaderMap({{\":status\", \"200\"}}), false);\n\n  Buffer::OwnedImpl response_body(\"response\");\n  decoder_filters_[1]->callbacks_->encodeData(response_body, false);\n\n  auto response_trailers = makeHeaderMap({{\"x-trailer\", \"1\"}});\n  decoder_filters_[1]->callbacks_->encodeTrailers(std::move(response_trailers));\n}\n\nTEST_F(HttpConnectionManagerImplTest, FilterAddBodyContinuation) {\n  InSequence s;\n  setup(false, \"\");\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n    decoder->decodeHeaders(std::move(headers), true);\n  }));\n\n  setupFilterChain(2, 2);\n\n  EXPECT_CALL(*decoder_filters_[0], decodeHeaders(_, true))\n      .WillOnce(Return(FilterHeadersStatus::StopIteration));\n  EXPECT_CALL(*decoder_filters_[0], decodeComplete());\n\n  // Kick off the incoming data.\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n\n  EXPECT_CALL(*decoder_filters_[1], decodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(*decoder_filters_[1], decodeData(_, true))\n      .WillOnce(Return(FilterDataStatus::Continue));\n  EXPECT_CALL(*decoder_filters_[1], decodeComplete());\n\n  Buffer::OwnedImpl data(\"hello\");\n  decoder_filters_[0]->callbacks_->addDecodedData(data, true);\n  decoder_filters_[0]->callbacks_->continueDecoding();\n\n  EXPECT_CALL(*encoder_filters_[1], encodeHeaders(_, true))\n      .WillOnce(Return(FilterHeadersStatus::StopIteration));\n  EXPECT_CALL(*encoder_filters_[1], encodeComplete());\n\n  decoder_filters_[1]->callbacks_->encodeHeaders(\n      HeaderMapPtr{new TestHeaderMapImpl{{\":status\", \"200\"}}}, true);\n\n  EXPECT_CALL(*encoder_filters_[0], encodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(response_encoder_, encodeHeaders(_, false));\n  EXPECT_CALL(*encoder_filters_[0], encodeData(_, true))\n      .WillOnce(Return(FilterDataStatus::Continue));\n  EXPECT_CALL(*encoder_filters_[0], encodeComplete());\n  EXPECT_CALL(response_encoder_, encodeData(_, true));\n  expectOnDestroy();\n\n  Buffer::OwnedImpl data2(\"hello\");\n  encoder_filters_[1]->callbacks_->addEncodedData(data2, true);\n  encoder_filters_[1]->callbacks_->continueEncoding();\n}\n\n// This test verifies proper sequences of decodeData() and encodeData() are called\n// when all filers return \"CONTINUE\" in following case:\n//\n// 3 decode filters:\n//\n//   filter0->decodeHeaders(_, true)\n//     return CONTINUE\n//   filter1->decodeHeaders(_, true)\n//     filter1->addDecodeData()\n//     return CONTINUE\n//   filter2->decodeHeaders(_, false)\n//     return CONTINUE\n//   filter2->decodeData(_, true)\n//     return CONTINUE\n//\n//   filter0->decodeData(, true) is NOT called.\n//   filter1->decodeData(, true) is NOT called.\n//\n// 3 encode filters:\n//\n//   filter2->encodeHeaders(_, true)\n//     return CONTINUE\n//   filter1->encodeHeaders(_, true)\n//     filter1->addEncodeData()\n//     return CONTINUE\n//   filter0->decodeHeaders(_, false)\n//     return CONTINUE\n//   filter0->decodeData(_, true)\n//     return CONTINUE\n//\n//   filter2->encodeData(, true) is NOT called.\n//   filter1->encodeData(, true) is NOT called.\n//\nTEST_F(HttpConnectionManagerImplTest, AddDataWithAllContinue) {\n  InSequence s;\n  setup(false, \"\");\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n    decoder->decodeHeaders(std::move(headers), true);\n  }));\n\n  setupFilterChain(3, 3);\n\n  EXPECT_CALL(*decoder_filters_[0], decodeHeaders(_, true))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(*decoder_filters_[0], decodeComplete());\n\n  EXPECT_CALL(*decoder_filters_[1], decodeHeaders(_, true))\n      .WillOnce(InvokeWithoutArgs([&]() -> FilterHeadersStatus {\n        Buffer::OwnedImpl data2(\"hello\");\n        decoder_filters_[1]->callbacks_->addDecodedData(data2, true);\n        return FilterHeadersStatus::Continue;\n      }));\n  EXPECT_CALL(*decoder_filters_[1], decodeComplete());\n\n  EXPECT_CALL(*decoder_filters_[2], decodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(*decoder_filters_[2], decodeData(_, true))\n      .WillOnce(Return(FilterDataStatus::Continue));\n  EXPECT_CALL(*decoder_filters_[2], decodeComplete());\n\n  EXPECT_CALL(*decoder_filters_[0], decodeData(_, true)).Times(0);\n  EXPECT_CALL(*decoder_filters_[1], decodeData(_, true)).Times(0);\n\n  // Kick off the incoming data.\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, true);\n\n  // For encode direction\n  EXPECT_CALL(*encoder_filters_[2], encodeHeaders(_, true))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(*encoder_filters_[2], encodeComplete());\n\n  EXPECT_CALL(*encoder_filters_[1], encodeHeaders(_, true))\n      .WillOnce(InvokeWithoutArgs([&]() -> FilterHeadersStatus {\n        Buffer::OwnedImpl data2(\"goodbyte\");\n        encoder_filters_[1]->callbacks_->addEncodedData(data2, true);\n        return FilterHeadersStatus::Continue;\n      }));\n  EXPECT_CALL(*encoder_filters_[1], encodeComplete());\n\n  EXPECT_CALL(*encoder_filters_[0], encodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(response_encoder_, encodeHeaders(_, false));\n  EXPECT_CALL(*encoder_filters_[0], encodeData(_, true))\n      .WillOnce(Return(FilterDataStatus::Continue));\n  EXPECT_CALL(*encoder_filters_[0], encodeComplete());\n  EXPECT_CALL(response_encoder_, encodeData(_, true));\n  expectOnDestroy();\n\n  EXPECT_CALL(*encoder_filters_[2], encodeData(_, true)).Times(0);\n  EXPECT_CALL(*encoder_filters_[1], encodeData(_, true)).Times(0);\n\n  decoder_filters_[2]->callbacks_->encodeHeaders(\n      HeaderMapPtr{new TestHeaderMapImpl{{\":status\", \"200\"}}}, true);\n}\n\n// This test verifies proper sequences of decodeData() and encodeData() are called\n// when the first filer is \"stopped\" and \"continue\" in following case:\n//\n// 3 decode filters:\n//\n//   filter0->decodeHeaders(_, true)\n//     return STOP\n//   filter0->continueDecoding()\n//   filter1->decodeHeaders(_, true)\n//     filter1->addDecodeData()\n//     return CONTINUE\n//   filter2->decodeHeaders(_, false)\n//     return CONTINUE\n//   filter2->decodeData(_, true)\n//     return CONTINUE\n//\n//   filter0->decodeData(, true) is NOT called.\n//   filter1->decodeData(, true) is NOT called.\n//\n// 3 encode filters:\n//\n//   filter2->encodeHeaders(_, true)\n//     return STOP\n//   filter2->continueEncoding()\n//   filter1->encodeHeaders(_, true)\n//     filter1->addEncodeData()\n//     return CONTINUE\n//   filter0->decodeHeaders(_, false)\n//     return CONTINUE\n//   filter0->decodeData(_, true)\n//     return CONTINUE\n//\n//   filter2->encodeData(, true) is NOT called.\n//   filter1->encodeData(, true) is NOT called.\n//\nTEST_F(HttpConnectionManagerImplTest, AddDataWithStopAndContinue) {\n  InSequence s;\n  setup(false, \"\");\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n    decoder->decodeHeaders(std::move(headers), true);\n  }));\n\n  setupFilterChain(3, 3);\n\n  EXPECT_CALL(*decoder_filters_[0], decodeHeaders(_, true))\n      .WillOnce(Return(FilterHeadersStatus::StopIteration));\n  EXPECT_CALL(*decoder_filters_[0], decodeComplete());\n\n  // Kick off the incoming data.\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, true);\n\n  EXPECT_CALL(*decoder_filters_[1], decodeHeaders(_, true))\n      .WillOnce(InvokeWithoutArgs([&]() -> FilterHeadersStatus {\n        Buffer::OwnedImpl data2(\"hello\");\n        decoder_filters_[1]->callbacks_->addDecodedData(data2, true);\n        return FilterHeadersStatus::Continue;\n      }));\n  EXPECT_CALL(*decoder_filters_[1], decodeComplete());\n\n  EXPECT_CALL(*decoder_filters_[2], decodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  // This fail, it is called twice.\n  EXPECT_CALL(*decoder_filters_[2], decodeData(_, true))\n      .WillOnce(Return(FilterDataStatus::Continue));\n  EXPECT_CALL(*decoder_filters_[2], decodeComplete());\n\n  EXPECT_CALL(*decoder_filters_[0], decodeData(_, true)).Times(0);\n  // This fail, it is called once\n  EXPECT_CALL(*decoder_filters_[1], decodeData(_, true)).Times(0);\n\n  decoder_filters_[0]->callbacks_->continueDecoding();\n\n  // For encode direction\n  EXPECT_CALL(*encoder_filters_[2], encodeHeaders(_, true))\n      .WillOnce(Return(FilterHeadersStatus::StopIteration));\n  EXPECT_CALL(*encoder_filters_[2], encodeComplete());\n\n  decoder_filters_[2]->callbacks_->encodeHeaders(\n      HeaderMapPtr{new TestHeaderMapImpl{{\":status\", \"200\"}}}, true);\n\n  EXPECT_CALL(*encoder_filters_[1], encodeHeaders(_, true))\n      .WillOnce(InvokeWithoutArgs([&]() -> FilterHeadersStatus {\n        Buffer::OwnedImpl data2(\"goodbyte\");\n        encoder_filters_[1]->callbacks_->addEncodedData(data2, true);\n        return FilterHeadersStatus::Continue;\n      }));\n  EXPECT_CALL(*encoder_filters_[1], encodeComplete());\n\n  EXPECT_CALL(*encoder_filters_[0], encodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(response_encoder_, encodeHeaders(_, false));\n\n  EXPECT_CALL(*encoder_filters_[0], encodeData(_, true))\n      .WillOnce(Return(FilterDataStatus::Continue));\n  EXPECT_CALL(*encoder_filters_[0], encodeComplete());\n  EXPECT_CALL(response_encoder_, encodeData(_, true));\n  expectOnDestroy();\n\n  EXPECT_CALL(*encoder_filters_[2], encodeData(_, true)).Times(0);\n  EXPECT_CALL(*encoder_filters_[1], encodeData(_, true)).Times(0);\n\n  encoder_filters_[2]->callbacks_->continueEncoding();\n}\n\n// Use filter direct decode/encodeData() calls without trailers.\nTEST_F(HttpConnectionManagerImplTest, FilterDirectDecodeEncodeDataNoTrailers) {\n  InSequence s;\n  setup(false, \"\");\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n    decoder->decodeHeaders(std::move(headers), false);\n\n    Buffer::OwnedImpl fake_data(\"hello\");\n    decoder->decodeData(fake_data, true);\n  }));\n\n  EXPECT_CALL(*route_config_provider_.route_config_, route(_, _));\n  setupFilterChain(2, 2);\n\n  EXPECT_CALL(*decoder_filters_[0], decodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(*decoder_filters_[1], decodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::StopIteration));\n\n  Buffer::OwnedImpl decode_buffer;\n  EXPECT_CALL(*decoder_filters_[0], decodeData(_, true))\n      .WillOnce(Invoke([&](Buffer::Instance& data, bool) {\n        decode_buffer.move(data);\n        return FilterDataStatus::StopIterationNoBuffer;\n      }));\n  EXPECT_CALL(*decoder_filters_[0], decodeComplete());\n\n  // Kick off the incoming data.\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n\n  Buffer::OwnedImpl decoded_data_to_forward;\n  decoded_data_to_forward.move(decode_buffer, 2);\n  EXPECT_CALL(*decoder_filters_[1], decodeData(BufferStringEqual(\"he\"), false))\n      .WillOnce(Return(FilterDataStatus::StopIterationNoBuffer));\n  decoder_filters_[0]->callbacks_->injectDecodedDataToFilterChain(decoded_data_to_forward, false);\n\n  EXPECT_CALL(*decoder_filters_[1], decodeData(BufferStringEqual(\"llo\"), true))\n      .WillOnce(Return(FilterDataStatus::StopIterationNoBuffer));\n  EXPECT_CALL(*decoder_filters_[1], decodeComplete());\n  decoder_filters_[0]->callbacks_->injectDecodedDataToFilterChain(decode_buffer, true);\n\n  // Response path.\n  EXPECT_CALL(*encoder_filters_[1], encodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(*encoder_filters_[0], encodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(response_encoder_, encodeHeaders(_, false));\n\n  Buffer::OwnedImpl encoder_buffer;\n  EXPECT_CALL(*encoder_filters_[1], encodeData(_, true))\n      .WillOnce(Invoke([&](Buffer::Instance& data, bool) {\n        encoder_buffer.move(data);\n        return FilterDataStatus::StopIterationNoBuffer;\n      }));\n  EXPECT_CALL(*encoder_filters_[1], encodeComplete());\n\n  decoder_filters_[1]->callbacks_->encodeHeaders(\n      HeaderMapPtr{new TestHeaderMapImpl{{\":status\", \"200\"}}}, false);\n  Buffer::OwnedImpl response_body(\"response\");\n  decoder_filters_[1]->callbacks_->encodeData(response_body, true);\n\n  Buffer::OwnedImpl encoded_data_to_forward;\n  encoded_data_to_forward.move(encoder_buffer, 3);\n  EXPECT_CALL(*encoder_filters_[0], encodeData(BufferStringEqual(\"res\"), false));\n  EXPECT_CALL(response_encoder_, encodeData(_, false));\n  encoder_filters_[1]->callbacks_->injectEncodedDataToFilterChain(encoded_data_to_forward, false);\n\n  EXPECT_CALL(*encoder_filters_[0], encodeData(BufferStringEqual(\"ponse\"), true));\n  EXPECT_CALL(*encoder_filters_[0], encodeComplete());\n  EXPECT_CALL(response_encoder_, encodeData(_, true));\n  expectOnDestroy();\n  encoder_filters_[1]->callbacks_->injectEncodedDataToFilterChain(encoder_buffer, true);\n}\n\n// Use filter direct decode/encodeData() calls with trailers.\nTEST_F(HttpConnectionManagerImplTest, FilterDirectDecodeEncodeDataTrailers) {\n  InSequence s;\n  setup(false, \"\");\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n    decoder->decodeHeaders(std::move(headers), false);\n\n    Buffer::OwnedImpl fake_data(\"hello\");\n    decoder->decodeData(fake_data, false);\n\n    HeaderMapPtr trailers{new TestHeaderMapImpl{{\"foo\", \"bar\"}}};\n    decoder->decodeTrailers(std::move(trailers));\n  }));\n\n  EXPECT_CALL(*route_config_provider_.route_config_, route(_, _));\n  setupFilterChain(2, 2);\n\n  EXPECT_CALL(*decoder_filters_[0], decodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(*decoder_filters_[1], decodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::StopIteration));\n\n  Buffer::OwnedImpl decode_buffer;\n  EXPECT_CALL(*decoder_filters_[0], decodeData(_, false))\n      .WillOnce(Invoke([&](Buffer::Instance& data, bool) {\n        decode_buffer.move(data);\n        return FilterDataStatus::StopIterationNoBuffer;\n      }));\n  EXPECT_CALL(*decoder_filters_[0], decodeTrailers(_))\n      .WillOnce(Return(FilterTrailersStatus::StopIteration));\n  EXPECT_CALL(*decoder_filters_[0], decodeComplete());\n\n  // Kick off the incoming data.\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n\n  Buffer::OwnedImpl decoded_data_to_forward;\n  decoded_data_to_forward.move(decode_buffer, 2);\n  EXPECT_CALL(*decoder_filters_[1], decodeData(BufferStringEqual(\"he\"), false))\n      .WillOnce(Return(FilterDataStatus::StopIterationNoBuffer));\n  decoder_filters_[0]->callbacks_->injectDecodedDataToFilterChain(decoded_data_to_forward, false);\n\n  EXPECT_CALL(*decoder_filters_[1], decodeData(BufferStringEqual(\"llo\"), false))\n      .WillOnce(Return(FilterDataStatus::StopIterationNoBuffer));\n  decoder_filters_[0]->callbacks_->injectDecodedDataToFilterChain(decode_buffer, false);\n\n  EXPECT_CALL(*decoder_filters_[1], decodeTrailers(_));\n  EXPECT_CALL(*decoder_filters_[1], decodeComplete());\n  decoder_filters_[0]->callbacks_->continueDecoding();\n\n  // Response path.\n  EXPECT_CALL(*encoder_filters_[1], encodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(*encoder_filters_[0], encodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(response_encoder_, encodeHeaders(_, false));\n\n  Buffer::OwnedImpl encoder_buffer;\n  EXPECT_CALL(*encoder_filters_[1], encodeData(_, false))\n      .WillOnce(Invoke([&](Buffer::Instance& data, bool) {\n        encoder_buffer.move(data);\n        return FilterDataStatus::StopIterationNoBuffer;\n      }));\n  EXPECT_CALL(*encoder_filters_[1], encodeTrailers(_))\n      .WillOnce(Return(FilterTrailersStatus::StopIteration));\n  EXPECT_CALL(*encoder_filters_[1], encodeComplete());\n\n  decoder_filters_[1]->callbacks_->encodeHeaders(\n      HeaderMapPtr{new TestHeaderMapImpl{{\":status\", \"200\"}}}, false);\n  Buffer::OwnedImpl response_body(\"response\");\n  decoder_filters_[1]->callbacks_->encodeData(response_body, false);\n  decoder_filters_[1]->callbacks_->encodeTrailers(\n      HeaderMapPtr{new TestHeaderMapImpl{{\":status\", \"200\"}}});\n\n  Buffer::OwnedImpl encoded_data_to_forward;\n  encoded_data_to_forward.move(encoder_buffer, 3);\n  EXPECT_CALL(*encoder_filters_[0], encodeData(BufferStringEqual(\"res\"), false));\n  EXPECT_CALL(response_encoder_, encodeData(_, false));\n  encoder_filters_[1]->callbacks_->injectEncodedDataToFilterChain(encoded_data_to_forward, false);\n\n  EXPECT_CALL(*encoder_filters_[0], encodeData(BufferStringEqual(\"ponse\"), false));\n  EXPECT_CALL(response_encoder_, encodeData(_, false));\n  encoder_filters_[1]->callbacks_->injectEncodedDataToFilterChain(encoder_buffer, false);\n\n  EXPECT_CALL(*encoder_filters_[0], encodeTrailers(_));\n  EXPECT_CALL(*encoder_filters_[0], encodeComplete());\n  EXPECT_CALL(response_encoder_, encodeTrailers(_));\n  expectOnDestroy();\n  encoder_filters_[1]->callbacks_->continueEncoding();\n}\n\nTEST_F(HttpConnectionManagerImplTest, MultipleFilters) {\n  InSequence s;\n  setup(false, \"\");\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n    decoder->decodeHeaders(std::move(headers), false);\n\n    Buffer::OwnedImpl fake_data(\"hello\");\n    decoder->decodeData(fake_data, false);\n\n    Buffer::OwnedImpl fake_data2(\"world\");\n    decoder->decodeData(fake_data2, true);\n  }));\n\n  EXPECT_CALL(*route_config_provider_.route_config_, route(_, _));\n  setupFilterChain(3, 2);\n\n  EXPECT_CALL(*decoder_filters_[0], decodeHeaders(_, false))\n      .WillOnce(InvokeWithoutArgs([&]() -> FilterHeadersStatus {\n        EXPECT_EQ(route_config_provider_.route_config_->route_,\n                  decoder_filters_[0]->callbacks_->route());\n        EXPECT_EQ(ssl_connection_.get(),\n                  decoder_filters_[0]->callbacks_->connection()->ssl().get());\n        return FilterHeadersStatus::StopIteration;\n      }));\n\n  EXPECT_CALL(*decoder_filters_[0], decodeData(_, false))\n      .WillOnce(Return(FilterDataStatus::StopIterationAndBuffer));\n  EXPECT_CALL(*decoder_filters_[0], decodeData(_, true))\n      .WillOnce(Return(FilterDataStatus::StopIterationAndBuffer));\n  EXPECT_CALL(*decoder_filters_[0], decodeComplete());\n\n  // Kick off the incoming data.\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n\n  // Mimic a decoder filter that trapped data and now sends it on, since the data was buffered\n  // by the first filter, we expect to get it in 1 decodeData() call.\n  EXPECT_CALL(*decoder_filters_[1], decodeHeaders(_, false))\n      .WillOnce(InvokeWithoutArgs([&]() -> FilterHeadersStatus {\n        EXPECT_EQ(route_config_provider_.route_config_->route_,\n                  decoder_filters_[1]->callbacks_->route());\n        EXPECT_EQ(ssl_connection_.get(),\n                  decoder_filters_[1]->callbacks_->connection()->ssl().get());\n        return FilterHeadersStatus::StopIteration;\n      }));\n  EXPECT_CALL(*decoder_filters_[1], decodeData(_, true))\n      .WillOnce(Return(FilterDataStatus::Continue));\n  EXPECT_CALL(*decoder_filters_[1], decodeComplete());\n  EXPECT_CALL(*decoder_filters_[2], decodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::StopIteration));\n  EXPECT_CALL(*decoder_filters_[2], decodeData(_, true))\n      .WillOnce(Return(FilterDataStatus::StopIterationNoBuffer));\n  EXPECT_CALL(*decoder_filters_[2], decodeComplete());\n  decoder_filters_[0]->callbacks_->continueDecoding();\n\n  // Now start encoding and mimic trapping in the encoding filter.\n  EXPECT_CALL(*encoder_filters_[1], encodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::StopIteration));\n  EXPECT_CALL(*encoder_filters_[1], encodeData(_, false))\n      .WillOnce(Return(FilterDataStatus::StopIterationAndBuffer));\n  EXPECT_CALL(*encoder_filters_[1], encodeTrailers(_))\n      .WillOnce(Return(FilterTrailersStatus::StopIteration));\n  EXPECT_CALL(*encoder_filters_[1], encodeComplete());\n  EXPECT_EQ(ssl_connection_.get(), encoder_filters_[1]->callbacks_->connection()->ssl().get());\n  decoder_filters_[2]->callbacks_->encodeHeaders(\n      HeaderMapPtr{new TestHeaderMapImpl{{\":status\", \"200\"}}}, false);\n  Buffer::OwnedImpl response_body(\"response\");\n  decoder_filters_[2]->callbacks_->encodeData(response_body, false);\n  decoder_filters_[2]->callbacks_->encodeTrailers(\n      HeaderMapPtr{new TestHeaderMapImpl{{\"some\", \"trailer\"}}});\n  EXPECT_EQ(ssl_connection_.get(), decoder_filters_[2]->callbacks_->connection()->ssl().get());\n\n  // Now finish the encode.\n  EXPECT_CALL(*encoder_filters_[0], encodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(response_encoder_, encodeHeaders(_, false));\n  EXPECT_CALL(*encoder_filters_[0], encodeData(_, false))\n      .WillOnce(Return(FilterDataStatus::Continue));\n  EXPECT_CALL(response_encoder_, encodeData(_, false));\n  EXPECT_CALL(*encoder_filters_[0], encodeTrailers(_))\n      .WillOnce(Return(FilterTrailersStatus::Continue));\n  EXPECT_CALL(*encoder_filters_[0], encodeComplete());\n  EXPECT_CALL(response_encoder_, encodeTrailers(_));\n  expectOnDestroy();\n  encoder_filters_[1]->callbacks_->continueEncoding();\n\n  EXPECT_EQ(ssl_connection_.get(), encoder_filters_[0]->callbacks_->connection()->ssl().get());\n}\n\nTEST(HttpConnectionManagerTracingStatsTest, verifyTracingStats) {\n  Stats::IsolatedStoreImpl stats;\n  ConnectionManagerTracingStats tracing_stats{CONN_MAN_TRACING_STATS(POOL_COUNTER(stats))};\n\n  EXPECT_THROW(\n      ConnectionManagerImpl::chargeTracingStats(Tracing::Reason::HealthCheck, tracing_stats),\n      std::invalid_argument);\n\n  ConnectionManagerImpl::chargeTracingStats(Tracing::Reason::ClientForced, tracing_stats);\n  EXPECT_EQ(1UL, tracing_stats.client_enabled_.value());\n\n  ConnectionManagerImpl::chargeTracingStats(Tracing::Reason::NotTraceableRequestId, tracing_stats);\n  EXPECT_EQ(1UL, tracing_stats.not_traceable_.value());\n}\n\nTEST_F(HttpConnectionManagerImplTest, NoNewStreamWhenOverloaded) {\n  setup(false, \"\");\n\n  overload_manager_.overload_state_.setState(\n      Server::OverloadActionNames::get().StopAcceptingRequests,\n      Server::OverloadActionState::Active);\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillRepeatedly(Invoke([&](Buffer::Instance&) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n    decoder->decodeHeaders(std::move(headers), false);\n  }));\n\n  // 503 direct response when overloaded.\n  EXPECT_CALL(response_encoder_, encodeHeaders(_, false))\n      .WillOnce(Invoke([](const HeaderMap& headers, bool) -> void {\n        EXPECT_EQ(\"503\", headers.Status()->value().getStringView());\n      }));\n  std::string response_body;\n  EXPECT_CALL(response_encoder_, encodeData(_, true)).WillOnce(AddBufferToString(&response_body));\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n\n  EXPECT_EQ(\"envoy overloaded\", response_body);\n  EXPECT_EQ(1U, stats_.named_.downstream_rq_overload_close_.value());\n}\n\nTEST_F(HttpConnectionManagerImplTest, DisableKeepAliveWhenOverloaded) {\n  setup(false, \"\");\n\n  overload_manager_.overload_state_.setState(\n      Server::OverloadActionNames::get().DisableHttpKeepAlive, Server::OverloadActionState::Active);\n\n  std::shared_ptr<MockStreamDecoderFilter> filter(new NiceMock<MockStreamDecoderFilter>());\n  EXPECT_CALL(filter_factory_, createFilterChain(_))\n      .WillOnce(Invoke([&](FilterChainFactoryCallbacks& callbacks) -> void {\n        callbacks.addStreamDecoderFilter(StreamDecoderFilterSharedPtr{filter});\n      }));\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillRepeatedly(Invoke([&](Buffer::Instance& data) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{new TestHeaderMapImpl{\n        {\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}, {\"connection\", \"keep-alive\"}}};\n    decoder->decodeHeaders(std::move(headers), true);\n\n    HeaderMapPtr response_headers{new TestHeaderMapImpl{{\":status\", \"200\"}}};\n    filter->callbacks_->encodeHeaders(std::move(response_headers), true);\n\n    data.drain(4);\n  }));\n\n  EXPECT_CALL(response_encoder_, encodeHeaders(_, true))\n      .WillOnce(Invoke([](const HeaderMap& headers, bool) -> void {\n        EXPECT_EQ(\"close\", headers.Connection()->value().getStringView());\n      }));\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n  EXPECT_EQ(1U, stats_.named_.downstream_cx_overload_disable_keepalive_.value());\n}\n\nTEST_F(HttpConnectionManagerImplTest, TestStopAllIterationAndBufferOnDecodingPathFirstFilter) {\n  setup(false, \"envoy-custom-server\", false);\n  setUpEncoderAndDecoder(true, true);\n\n  // Kick off the incoming data.\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n\n  // Verify that once the decoder_filters_[0]'s contineDecoding() is called, decoder_filters_[1]'s\n  // decodeHeaders() is called, and both filters receive data and trailers consequently.\n  EXPECT_CALL(*decoder_filters_[1], decodeHeaders(_, _))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(*decoder_filters_[0], decodeData(_, _)).WillOnce(Return(FilterDataStatus::Continue));\n  EXPECT_CALL(*decoder_filters_[1], decodeData(_, _)).WillOnce(Return(FilterDataStatus::Continue));\n  EXPECT_CALL(*decoder_filters_[0], decodeTrailers(_))\n      .WillOnce(Return(FilterTrailersStatus::Continue));\n  EXPECT_CALL(*decoder_filters_[1], decodeTrailers(_))\n      .WillOnce(Return(FilterTrailersStatus::Continue));\n  EXPECT_CALL(*decoder_filters_[1], decodeComplete());\n  decoder_filters_[0]->callbacks_->continueDecoding();\n}\n\nTEST_F(HttpConnectionManagerImplTest, TestStopAllIterationAndBufferOnDecodingPathSecondFilter) {\n  setup(false, \"envoy-custom-server\", false);\n  setUpEncoderAndDecoder(true, false);\n\n  // Verify headers go through both filters, and data and trailers go through the first filter only.\n  EXPECT_CALL(*decoder_filters_[1], decodeHeaders(_, _))\n      .WillOnce(Return(FilterHeadersStatus::StopAllIterationAndBuffer));\n  EXPECT_CALL(*decoder_filters_[0], decodeData(_, _)).WillOnce(Return(FilterDataStatus::Continue));\n  EXPECT_CALL(*decoder_filters_[0], decodeTrailers(_))\n      .WillOnce(Return(FilterTrailersStatus::Continue));\n  // Kick off the incoming data.\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n\n  // Verify that once the decoder_filters_[1]'s contineDecoding() is called, both data and trailers\n  // go through the second filter.\n  EXPECT_CALL(*decoder_filters_[1], decodeData(_, _)).WillOnce(Return(FilterDataStatus::Continue));\n  EXPECT_CALL(*decoder_filters_[1], decodeTrailers(_))\n      .WillOnce(Return(FilterTrailersStatus::Continue));\n  EXPECT_CALL(*decoder_filters_[1], decodeComplete());\n  decoder_filters_[1]->callbacks_->continueDecoding();\n}\n\nTEST_F(HttpConnectionManagerImplTest, TestStopAllIterationAndBufferOnEncodingPath) {\n  setup(false, \"envoy-custom-server\", false);\n  setUpEncoderAndDecoder(false, false);\n  sendRequestHeadersAndData();\n\n  // encoder_filters_[1] is the first filter in the chain.\n  EXPECT_CALL(*encoder_filters_[1], encodeHeaders(_, false))\n      .WillOnce(Invoke([&](HeaderMap&, bool) -> FilterHeadersStatus {\n        return FilterHeadersStatus::StopAllIterationAndBuffer;\n      }));\n  HeaderMapPtr response_headers{new TestHeaderMapImpl{{\":status\", \"200\"}}};\n  decoder_filters_[0]->callbacks_->encodeHeaders(std::move(response_headers), false);\n\n  // Invoke encodeData while all iteration is stopped and make sure the filters do not have\n  // encodeData called.\n  EXPECT_CALL(*encoder_filters_[0], encodeData(_, _)).Times(0);\n  EXPECT_CALL(*encoder_filters_[1], encodeData(_, _)).Times(0);\n  Buffer::OwnedImpl response_body(\"response\");\n  decoder_filters_[0]->callbacks_->encodeData(response_body, false);\n  decoder_filters_[0]->callbacks_->encodeTrailers(\n      HeaderMapPtr{new TestHeaderMapImpl{{\"some\", \"trailer\"}}});\n\n  // Verify that once encoder_filters_[1]'s continueEncoding() is called, encoder_filters_[0]'s\n  // encodeHeaders() is called, and both filters receive data and trailers consequently.\n  EXPECT_CALL(*encoder_filters_[0], encodeHeaders(_, _))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(response_encoder_, encodeHeaders(_, false));\n  EXPECT_CALL(*encoder_filters_[1], encodeData(_, _)).WillOnce(Return(FilterDataStatus::Continue));\n  EXPECT_CALL(*encoder_filters_[0], encodeData(_, _)).WillOnce(Return(FilterDataStatus::Continue));\n  EXPECT_CALL(response_encoder_, encodeData(_, _));\n  EXPECT_CALL(*encoder_filters_[1], encodeTrailers(_))\n      .WillOnce(Return(FilterTrailersStatus::Continue));\n  EXPECT_CALL(*encoder_filters_[0], encodeTrailers(_))\n      .WillOnce(Return(FilterTrailersStatus::Continue));\n  EXPECT_CALL(response_encoder_, encodeTrailers(_));\n  EXPECT_CALL(*encoder_filters_[0], encodeComplete());\n  EXPECT_CALL(*encoder_filters_[1], encodeComplete());\n  expectOnDestroy();\n  encoder_filters_[1]->callbacks_->continueEncoding();\n}\n\nTEST_F(HttpConnectionManagerImplTest, DisableKeepAliveWhenDraining) {\n  setup(false, \"\");\n\n  EXPECT_CALL(drain_close_, drainClose()).WillOnce(Return(true));\n\n  std::shared_ptr<MockStreamDecoderFilter> filter(new NiceMock<MockStreamDecoderFilter>());\n  EXPECT_CALL(filter_factory_, createFilterChain(_))\n      .WillOnce(Invoke([&](FilterChainFactoryCallbacks& callbacks) -> void {\n        callbacks.addStreamDecoderFilter(StreamDecoderFilterSharedPtr{filter});\n      }));\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillRepeatedly(Invoke([&](Buffer::Instance& data) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{new TestHeaderMapImpl{\n        {\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}, {\"connection\", \"keep-alive\"}}};\n    decoder->decodeHeaders(std::move(headers), true);\n\n    HeaderMapPtr response_headers{new TestHeaderMapImpl{{\":status\", \"200\"}}};\n    filter->callbacks_->encodeHeaders(std::move(response_headers), true);\n\n    data.drain(4);\n  }));\n\n  EXPECT_CALL(response_encoder_, encodeHeaders(_, true))\n      .WillOnce(Invoke([](const HeaderMap& headers, bool) -> void {\n        EXPECT_EQ(\"close\", headers.Connection()->value().getStringView());\n      }));\n\n  Buffer::OwnedImpl fake_input;\n  conn_manager_->onData(fake_input, false);\n}\n\nTEST_F(HttpConnectionManagerImplTest, TestSessionTrace) {\n  setup(false, \"\");\n\n  // Set up the codec.\n  EXPECT_CALL(*codec_, dispatch(_)).WillRepeatedly(Invoke([&](Buffer::Instance& data) -> void {\n    data.drain(4);\n  }));\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n\n  setupFilterChain(1, 1);\n\n  // Create a new stream\n  StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n\n  // Send headers to that stream, and verify we both set and clear the tracked object.\n  {\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"POST\"}}};\n    EXPECT_CALL(filter_callbacks_.connection_.dispatcher_, setTrackedObject(_))\n        .Times(2)\n        .WillOnce(Invoke([](const ScopeTrackedObject* object) -> const ScopeTrackedObject* {\n          ASSERT(object != nullptr); // On the first call, this should be the active stream.\n          std::stringstream out;\n          object->dumpState(out);\n          std::string state = out.str();\n          EXPECT_THAT(state, testing::HasSubstr(\"request_headers_: null\"));\n          EXPECT_THAT(state, testing::HasSubstr(\"protocol_: 1\"));\n          return nullptr;\n        }))\n        .WillRepeatedly(Return(nullptr));\n    EXPECT_CALL(*decoder_filters_[0], decodeHeaders(_, false))\n        .WillOnce(Invoke([](HeaderMap&, bool) -> FilterHeadersStatus {\n          return FilterHeadersStatus::StopIteration;\n        }));\n    decoder->decodeHeaders(std::move(headers), false);\n  }\n\n  // Send trailers to that stream, and verify by this point headers are in logged state.\n  {\n    HeaderMapPtr trailers{new TestHeaderMapImpl{{\"foo\", \"bar\"}}};\n    EXPECT_CALL(filter_callbacks_.connection_.dispatcher_, setTrackedObject(_))\n        .Times(2)\n        .WillOnce(Invoke([](const ScopeTrackedObject* object) -> const ScopeTrackedObject* {\n          ASSERT(object != nullptr); // On the first call, this should be the active stream.\n          std::stringstream out;\n          object->dumpState(out);\n          std::string state = out.str();\n          EXPECT_THAT(state, testing::HasSubstr(\"request_headers_: \\n\"));\n          EXPECT_THAT(state, testing::HasSubstr(\"':authority', 'host'\\n\"));\n          EXPECT_THAT(state, testing::HasSubstr(\"protocol_: 1\"));\n          return nullptr;\n        }))\n        .WillRepeatedly(Return(nullptr));\n    EXPECT_CALL(*decoder_filters_[0], decodeComplete());\n    EXPECT_CALL(*decoder_filters_[0], decodeTrailers(_))\n        .WillOnce(Return(FilterTrailersStatus::StopIteration));\n    decoder->decodeTrailers(std::move(trailers));\n  }\n}\n\n// SRDS no scope found.\nTEST_F(HttpConnectionManagerImplTest, TestSrdsRouteNotFound) {\n  setup(false, \"\", true, true);\n  setupFilterChain(1, 0); // Recreate the chain for second stream.\n\n  EXPECT_CALL(*static_cast<const Router::MockScopedConfig*>(\n                  scopedRouteConfigProvider()->config<Router::ScopedConfig>().get()),\n              getRouteConfig(_))\n      .Times(2)\n      .WillRepeatedly(Return(nullptr));\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance& data) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":method\", \"GET\"}, {\":path\", \"/foo\"}}};\n    decoder->decodeHeaders(std::move(headers), true);\n    data.drain(4);\n  }));\n\n  EXPECT_CALL(*decoder_filters_[0], decodeHeaders(_, true))\n      .WillOnce(InvokeWithoutArgs([&]() -> FilterHeadersStatus {\n        EXPECT_EQ(nullptr, decoder_filters_[0]->callbacks_->route());\n        return FilterHeadersStatus::StopIteration;\n      }));\n  EXPECT_CALL(*decoder_filters_[0], decodeComplete()); // end_stream=true.\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n}\n\n// SRDS updating scopes affects routing.\nTEST_F(HttpConnectionManagerImplTest, TestSrdsUpdate) {\n  setup(false, \"\", true, true);\n\n  EXPECT_CALL(*static_cast<const Router::MockScopedConfig*>(\n                  scopedRouteConfigProvider()->config<Router::ScopedConfig>().get()),\n              getRouteConfig(_))\n      .Times(3)\n      .WillOnce(Return(nullptr))\n      .WillOnce(Return(nullptr))        // refreshCachedRoute first time.\n      .WillOnce(Return(route_config_)); // triggered by callbacks_->route(), SRDS now updated.\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance& data) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":method\", \"GET\"}, {\":path\", \"/foo\"}}};\n    decoder->decodeHeaders(std::move(headers), true);\n    data.drain(4);\n  }));\n  const std::string fake_cluster1_name = \"fake_cluster1\";\n  std::shared_ptr<Router::MockRoute> route1 = std::make_shared<NiceMock<Router::MockRoute>>();\n  EXPECT_CALL(route1->route_entry_, clusterName()).WillRepeatedly(ReturnRef(fake_cluster1_name));\n  std::shared_ptr<Upstream::MockThreadLocalCluster> fake_cluster1 =\n      std::make_shared<NiceMock<Upstream::MockThreadLocalCluster>>();\n  EXPECT_CALL(cluster_manager_, get(_)).WillOnce(Return(fake_cluster1.get()));\n  EXPECT_CALL(*route_config_, route(_, _)).WillOnce(Return(route1));\n  // First no-scope-found request will be handled by decoder_filters_[0].\n  setupFilterChain(1, 0);\n  EXPECT_CALL(*decoder_filters_[0], decodeHeaders(_, true))\n      .WillOnce(InvokeWithoutArgs([&]() -> FilterHeadersStatus {\n        EXPECT_EQ(nullptr, decoder_filters_[0]->callbacks_->route());\n\n        // Clear route and next call on callbacks_->route() will trigger a re-snapping of the\n        // snapped_route_config_.\n        decoder_filters_[0]->callbacks_->clearRouteCache();\n\n        // Now route config provider returns something.\n        EXPECT_EQ(route1, decoder_filters_[0]->callbacks_->route());\n        EXPECT_EQ(route1->routeEntry(), decoder_filters_[0]->callbacks_->streamInfo().routeEntry());\n        EXPECT_EQ(fake_cluster1->info(), decoder_filters_[0]->callbacks_->clusterInfo());\n        return FilterHeadersStatus::StopIteration;\n\n        return FilterHeadersStatus::StopIteration;\n      }));\n  EXPECT_CALL(*decoder_filters_[0], decodeComplete()); // end_stream=true.\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n}\n\n// SRDS Scope header update cause cross-scope reroute.\nTEST_F(HttpConnectionManagerImplTest, TestSrdsCrossScopeReroute) {\n  setup(false, \"\", true, true);\n\n  std::shared_ptr<Router::MockConfig> route_config1 =\n      std::make_shared<NiceMock<Router::MockConfig>>();\n  std::shared_ptr<Router::MockConfig> route_config2 =\n      std::make_shared<NiceMock<Router::MockConfig>>();\n  std::shared_ptr<Router::MockRoute> route1 = std::make_shared<NiceMock<Router::MockRoute>>();\n  std::shared_ptr<Router::MockRoute> route2 = std::make_shared<NiceMock<Router::MockRoute>>();\n  EXPECT_CALL(*route_config1, route(_, _)).WillRepeatedly(Return(route1));\n  EXPECT_CALL(*route_config2, route(_, _)).WillRepeatedly(Return(route2));\n  EXPECT_CALL(*static_cast<const Router::MockScopedConfig*>(\n                  scopedRouteConfigProvider()->config<Router::ScopedConfig>().get()),\n              getRouteConfig(_))\n      // 1. Snap scoped route config;\n      // 2. refreshCachedRoute (both in decodeHeaders(headers,end_stream);\n      // 3. then refreshCachedRoute triggered by decoder_filters_[1]->callbacks_->route().\n      .Times(3)\n      .WillRepeatedly(Invoke([&](const HeaderMap& headers) -> Router::ConfigConstSharedPtr {\n        auto& test_headers = static_cast<const TestHeaderMapImpl&>(headers);\n        if (test_headers.get_(\"scope_key\") == \"foo\") {\n          return route_config1;\n        }\n        return route_config2;\n      }));\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance& data) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{new TestHeaderMapImpl{\n        {\":authority\", \"host\"}, {\":method\", \"GET\"}, {\"scope_key\", \"foo\"}, {\":path\", \"/foo\"}}};\n    decoder->decodeHeaders(std::move(headers), false);\n    data.drain(4);\n  }));\n  setupFilterChain(2, 0);\n  EXPECT_CALL(*decoder_filters_[0], decodeHeaders(_, false))\n      .WillOnce(Invoke([&](Http::HeaderMap& headers, bool) -> FilterHeadersStatus {\n        EXPECT_EQ(route1, decoder_filters_[0]->callbacks_->route());\n        auto& test_headers = static_cast<TestHeaderMapImpl&>(headers);\n        // Clear cached route and change scope key to \"bar\".\n        decoder_filters_[0]->callbacks_->clearRouteCache();\n        test_headers.remove(\"scope_key\");\n        test_headers.addCopy(\"scope_key\", \"bar\");\n        return FilterHeadersStatus::Continue;\n      }));\n  EXPECT_CALL(*decoder_filters_[1], decodeHeaders(_, false))\n      .WillOnce(Invoke([&](Http::HeaderMap& headers, bool) -> FilterHeadersStatus {\n        auto& test_headers = static_cast<TestHeaderMapImpl&>(headers);\n        EXPECT_EQ(test_headers.get_(\"scope_key\"), \"bar\");\n        // Route now switched to route2 as header \"scope_key\" has changed.\n        EXPECT_EQ(route2, decoder_filters_[1]->callbacks_->route());\n        EXPECT_EQ(route2->routeEntry(), decoder_filters_[1]->callbacks_->streamInfo().routeEntry());\n        return FilterHeadersStatus::StopIteration;\n      }));\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n}\n\n// SRDS scoped RouteConfiguration found and route found.\nTEST_F(HttpConnectionManagerImplTest, TestSrdsRouteFound) {\n  setup(false, \"\", true, true);\n  setupFilterChain(1, 0);\n\n  const std::string fake_cluster1_name = \"fake_cluster1\";\n  std::shared_ptr<Router::MockRoute> route1 = std::make_shared<NiceMock<Router::MockRoute>>();\n  EXPECT_CALL(route1->route_entry_, clusterName()).WillRepeatedly(ReturnRef(fake_cluster1_name));\n  std::shared_ptr<Upstream::MockThreadLocalCluster> fake_cluster1 =\n      std::make_shared<NiceMock<Upstream::MockThreadLocalCluster>>();\n  EXPECT_CALL(cluster_manager_, get(_)).WillOnce(Return(fake_cluster1.get()));\n  EXPECT_CALL(*scopedRouteConfigProvider()->config<Router::MockScopedConfig>(), getRouteConfig(_))\n      // 1. decodeHeaders() snaping route config.\n      // 2. refreshCachedRoute() later in the same decodeHeaders().\n      .Times(2);\n  EXPECT_CALL(\n      *static_cast<const Router::MockConfig*>(\n          scopedRouteConfigProvider()->config<Router::MockScopedConfig>()->route_config_.get()),\n      route(_, _))\n      .WillOnce(Return(route1));\n  StreamDecoder* decoder = nullptr;\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance& data) -> void {\n    decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":method\", \"GET\"}, {\":path\", \"/foo\"}}};\n    decoder->decodeHeaders(std::move(headers), true);\n    data.drain(4);\n  }));\n  EXPECT_CALL(*decoder_filters_[0], decodeHeaders(_, true))\n      .WillOnce(InvokeWithoutArgs([&]() -> FilterHeadersStatus {\n        EXPECT_EQ(route1, decoder_filters_[0]->callbacks_->route());\n        EXPECT_EQ(route1->routeEntry(), decoder_filters_[0]->callbacks_->streamInfo().routeEntry());\n        EXPECT_EQ(fake_cluster1->info(), decoder_filters_[0]->callbacks_->clusterInfo());\n        return FilterHeadersStatus::StopIteration;\n      }));\n  EXPECT_CALL(*decoder_filters_[0], decodeComplete());\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false);\n}\n\nclass HttpConnectionManagerImplDeathTest : public HttpConnectionManagerImplTest {\npublic:\n  Router::RouteConfigProvider* routeConfigProvider() override {\n    return route_config_provider2_.get();\n  }\n  Config::ConfigProvider* scopedRouteConfigProvider() override {\n    return scoped_route_config_provider2_.get();\n  }\n\n  std::shared_ptr<Router::MockRouteConfigProvider> route_config_provider2_;\n  std::shared_ptr<Router::MockScopedRouteConfigProvider> scoped_route_config_provider2_;\n};\n\n// HCM config can only have either RouteConfigProvider or ScopedRoutesConfigProvider.\nTEST_F(HttpConnectionManagerImplDeathTest, InvalidConnectionManagerConfig) {\n  setup(false, \"\");\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  EXPECT_CALL(*codec_, dispatch(_)).WillRepeatedly(Invoke([&](Buffer::Instance&) -> void {\n    conn_manager_->newStream(response_encoder_);\n  }));\n  // Either RDS or SRDS should be set.\n  EXPECT_DEBUG_DEATH(conn_manager_->onData(fake_input, false),\n                     \"Either routeConfigProvider or scopedRouteConfigProvider should be set in \"\n                     \"ConnectionManagerImpl.\");\n\n  route_config_provider2_ = std::make_shared<NiceMock<Router::MockRouteConfigProvider>>();\n\n  // Only route config provider valid.\n  EXPECT_NO_THROW(conn_manager_->onData(fake_input, false));\n\n  scoped_route_config_provider2_ =\n      std::make_shared<NiceMock<Router::MockScopedRouteConfigProvider>>();\n  // Can't have RDS and SRDS provider in the same time.\n  EXPECT_DEBUG_DEATH(conn_manager_->onData(fake_input, false),\n                     \"Either routeConfigProvider or scopedRouteConfigProvider should be set in \"\n                     \"ConnectionManagerImpl.\");\n\n  route_config_provider2_.reset();\n  // Only scoped route config provider valid.\n  EXPECT_NO_THROW(conn_manager_->onData(fake_input, false));\n\n#if !defined(NDEBUG)\n  EXPECT_CALL(*scoped_route_config_provider2_, getConfig()).WillRepeatedly(Return(nullptr));\n  // ASSERT failure when SRDS provider returns a nullptr.\n  EXPECT_DEBUG_DEATH(conn_manager_->onData(fake_input, false),\n                     \"Scoped rds provider returns null for scoped routes config.\");\n#endif // !defined(NDEBUG)\n}\n\n} // namespace Http\n} // namespace Envoy\n", "#include \"common/http/header_map_impl.h\"\n\n#include \"benchmark/benchmark.h\"\n\nnamespace Envoy {\nnamespace Http {\n\n/**\n * Add several dummy headers to a HeaderMap.\n * @param num_headers the number of dummy headers to add.\n */\nstatic void addDummyHeaders(HeaderMap& headers, size_t num_headers) {\n  const std::string prefix(\"dummy-key-\");\n  for (size_t i = 0; i < num_headers; i++) {\n    headers.addCopy(LowerCaseString(prefix + std::to_string(i)), \"abcd\");\n  }\n}\n\n/** Measure the construction/destruction speed of HeaderMapImpl.*/\nstatic void HeaderMapImplCreate(benchmark::State& state) {\n  for (auto _ : state) {\n    HeaderMapImpl headers;\n    benchmark::DoNotOptimize(headers.size());\n  }\n}\nBENCHMARK(HeaderMapImplCreate);\n\n/**\n * Measure the speed of setting/overwriting a header value. The numeric Arg passed\n * by the BENCHMARK(...) macro call below indicates how many dummy headers this test\n * will add to the HeaderMapImpl before testing the setReference() method. That helps\n * identify whether the speed of setReference() is dependent on the number of other\n * headers in the HeaderMapImpl.\n */\nstatic void HeaderMapImplSetReference(benchmark::State& state) {\n  const LowerCaseString key(\"example-key\");\n  const std::string value(\"01234567890123456789\");\n  HeaderMapImpl headers;\n  addDummyHeaders(headers, state.range(0));\n  for (auto _ : state) {\n    headers.setReference(key, value);\n  }\n  benchmark::DoNotOptimize(headers.size());\n}\nBENCHMARK(HeaderMapImplSetReference)->Arg(0)->Arg(1)->Arg(10)->Arg(50);\n\n/**\n * Measure the speed of retrieving a header value. The numeric Arg passed by the\n * BENCHMARK(...) macro call below indicates how many dummy headers this test\n * will add to the HeaderMapImpl during test setup. The relative performance of\n * this test for different Arg values will help reveal how the speed of the get()\n * method depends (or doesn't depend) on the number of other headers in the\n * HeaderMapImpl.\n */\nstatic void HeaderMapImplGet(benchmark::State& state) {\n  const LowerCaseString key(\"example-key\");\n  const std::string value(\"01234567890123456789\");\n  HeaderMapImpl headers;\n  addDummyHeaders(headers, state.range(0));\n  headers.setReference(key, value);\n  size_t successes = 0;\n  for (auto _ : state) {\n    successes += (headers.get(key) != nullptr);\n  }\n  benchmark::DoNotOptimize(successes);\n}\nBENCHMARK(HeaderMapImplGet)->Arg(0)->Arg(1)->Arg(10)->Arg(50);\n\n/**\n * Measure the retrieval speed of a header for which HeaderMapImpl is expected to\n * provide special optimizations.\n */\nstatic void HeaderMapImplGetInline(benchmark::State& state) {\n  const std::string value(\"01234567890123456789\");\n  HeaderMapImpl headers;\n  addDummyHeaders(headers, state.range(0));\n  headers.insertConnection().value().setReference(value);\n  size_t size = 0;\n  for (auto _ : state) {\n    size += headers.Connection()->value().size();\n  }\n  benchmark::DoNotOptimize(size);\n}\nBENCHMARK(HeaderMapImplGetInline)->Arg(0)->Arg(1)->Arg(10)->Arg(50);\n\n/**\n * Measure the speed of writing to a header for which HeaderMapImpl is expected to\n * provide special optimizations.\n */\nstatic void HeaderMapImplSetInline(benchmark::State& state) {\n  const std::string value(\"01234567890123456789\");\n  HeaderMapImpl headers;\n  addDummyHeaders(headers, state.range(0));\n  for (auto _ : state) {\n    headers.insertConnection().value().setReference(value);\n  }\n  benchmark::DoNotOptimize(headers.size());\n}\nBENCHMARK(HeaderMapImplSetInline)->Arg(0)->Arg(1)->Arg(10)->Arg(50);\n\n/** Measure the speed of the byteSize() estimation method. */\nstatic void HeaderMapImplGetByteSize(benchmark::State& state) {\n  HeaderMapImpl headers;\n  addDummyHeaders(headers, state.range(0));\n  uint64_t size = 0;\n  for (auto _ : state) {\n    size += headers.byteSize().value();\n  }\n  benchmark::DoNotOptimize(size);\n}\nBENCHMARK(HeaderMapImplGetByteSize)->Arg(0)->Arg(1)->Arg(10)->Arg(50);\n\n/** Measure the speed of iteration with a lightweight callback. */\nstatic void HeaderMapImplIterate(benchmark::State& state) {\n  HeaderMapImpl headers;\n  size_t num_callbacks = 0;\n  addDummyHeaders(headers, state.range(0));\n  auto counting_callback = [](const HeaderEntry&, void* context) -> HeaderMap::Iterate {\n    (*static_cast<size_t*>(context))++;\n    return HeaderMap::Iterate::Continue;\n  };\n  for (auto _ : state) {\n    headers.iterate(counting_callback, &num_callbacks);\n  }\n  benchmark::DoNotOptimize(num_callbacks);\n}\nBENCHMARK(HeaderMapImplIterate)->Arg(0)->Arg(1)->Arg(10)->Arg(50);\n\n/** Measure the speed of the HeaderMapImpl lookup() method. */\nstatic void HeaderMapImplLookup(benchmark::State& state) {\n  const LowerCaseString key(\"connection\");\n  const std::string value(\"01234567890123456789\");\n  HeaderMapImpl headers;\n  addDummyHeaders(headers, state.range(0));\n  headers.addReference(key, value);\n  for (auto _ : state) {\n    const HeaderEntry* entry = nullptr;\n    auto result = headers.lookup(key, &entry);\n    benchmark::DoNotOptimize(result);\n  }\n}\nBENCHMARK(HeaderMapImplLookup)->Arg(0)->Arg(1)->Arg(10)->Arg(50);\n\n/**\n * Measure the speed of removing a header by key name.\n * @note The measured time for each iteration includes the time needed to add\n *       one copy of the header.\n */\nstatic void HeaderMapImplRemove(benchmark::State& state) {\n  const LowerCaseString key(\"example-key\");\n  const std::string value(\"01234567890123456789\");\n  HeaderMapImpl headers;\n  addDummyHeaders(headers, state.range(0));\n  for (auto _ : state) {\n    headers.addReference(key, value);\n    headers.remove(key);\n  }\n  benchmark::DoNotOptimize(headers.size());\n}\nBENCHMARK(HeaderMapImplRemove)->Arg(0)->Arg(1)->Arg(10)->Arg(50);\n\n/**\n * Measure the speed of removing a header by key name, for the special case of\n * a key for which HeaderMapImpl is expected to provide special optimization.\n * @note The measured time for each iteration includes the time needed to add\n *       one copy of the header.\n */\nstatic void HeaderMapImplRemoveInline(benchmark::State& state) {\n  const LowerCaseString key(\"connection\");\n  const std::string value(\"01234567890123456789\");\n  HeaderMapImpl headers;\n  addDummyHeaders(headers, state.range(0));\n  for (auto _ : state) {\n    headers.addReference(key, value);\n    headers.remove(key);\n  }\n  benchmark::DoNotOptimize(headers.size());\n}\nBENCHMARK(HeaderMapImplRemoveInline)->Arg(0)->Arg(1)->Arg(10)->Arg(50);\n\n/**\n * Measure the speed of creating a HeaderMapImpl and populating it with a realistic\n * set of response headers.\n */\nstatic void HeaderMapImplPopulate(benchmark::State& state) {\n  const std::pair<LowerCaseString, std::string> headers_to_add[] = {\n      {LowerCaseString(\"cache-control\"), \"max-age=0, private, must-revalidate\"},\n      {LowerCaseString(\"content-encoding\"), \"gzip\"},\n      {LowerCaseString(\"content-type\"), \"text/html; charset=utf-8\"},\n      {LowerCaseString(\"date\"), \"Wed, 23 Jan 2019 04:00:00 GMT\"},\n      {LowerCaseString(\"server\"), \"envoy\"},\n      {LowerCaseString(\"x-custom-header-1\"), \"example 1\"},\n      {LowerCaseString(\"x-custom-header-2\"), \"example 2\"},\n      {LowerCaseString(\"x-custom-header-3\"), \"example 3\"},\n      {LowerCaseString(\"set-cookie\"), \"_cookie1=12345678; path = /; secure\"},\n      {LowerCaseString(\"set-cookie\"), \"_cookie2=12345678; path = /; secure\"},\n  };\n  for (auto _ : state) {\n    HeaderMapImpl headers;\n    for (const auto& key_value : headers_to_add) {\n      headers.addReference(key_value.first, key_value.second);\n    }\n    benchmark::DoNotOptimize(headers.size());\n  }\n}\nBENCHMARK(HeaderMapImplPopulate);\n\n} // namespace Http\n} // namespace Envoy\n\n// Boilerplate main(), which discovers benchmarks in the same file and runs them.\nint main(int argc, char** argv) {\n  benchmark::Initialize(&argc, argv);\n\n  if (benchmark::ReportUnrecognizedArguments(argc, argv)) {\n    return 1;\n  }\n  benchmark::RunSpecifiedBenchmarks();\n}\n", "#include <memory>\n#include <string>\n\n#include \"common/http/header_map_impl.h\"\n#include \"common/http/header_utility.h\"\n\n#include \"test/test_common/printers.h\"\n#include \"test/test_common/utility.h\"\n\n#include \"gtest/gtest.h\"\n\nusing ::testing::InSequence;\n\nnamespace Envoy {\nnamespace Http {\n\nTEST(HeaderStringTest, All) {\n  // Static LowerCaseString constructor\n  {\n    LowerCaseString static_string(\"hello\");\n    HeaderString string(static_string);\n    EXPECT_EQ(\"hello\", string.getStringView());\n    EXPECT_EQ(static_string.get(), string.getStringView());\n    EXPECT_EQ(5U, string.size());\n  }\n\n  // Static LowerCaseString operators\n  {\n    LowerCaseString banana(\"banana\");\n    LowerCaseString lemon(\"lemon\");\n    EXPECT_TRUE(banana < lemon);\n    EXPECT_TRUE(banana != lemon);\n    EXPECT_TRUE(banana == banana);\n  }\n\n  // Static std::string constructor\n  {\n    std::string static_string(\"HELLO\");\n    HeaderString string(static_string);\n    EXPECT_EQ(\"HELLO\", string.getStringView());\n    EXPECT_EQ(static_string, string.getStringView());\n    EXPECT_EQ(5U, string.size());\n  }\n\n  // Static move constructor\n  {\n    std::string static_string(\"HELLO\");\n    HeaderString string1(static_string);\n    HeaderString string2(std::move(string1));\n    EXPECT_EQ(\"HELLO\", string2.getStringView());\n    EXPECT_EQ(static_string, string1.getStringView()); // NOLINT(bugprone-use-after-move)\n    EXPECT_EQ(static_string, string2.getStringView());\n    EXPECT_EQ(5U, string1.size());\n    EXPECT_EQ(5U, string2.size());\n  }\n\n  // Inline move constructor\n  {\n    HeaderString string;\n    string.setCopy(\"hello\", 5);\n    EXPECT_EQ(HeaderString::Type::Inline, string.type());\n    HeaderString string2(std::move(string));\n    EXPECT_TRUE(string.empty()); // NOLINT(bugprone-use-after-move)\n    EXPECT_EQ(HeaderString::Type::Inline, string.type());\n    EXPECT_EQ(HeaderString::Type::Inline, string2.type());\n    string.append(\"world\", 5);\n    EXPECT_EQ(\"world\", string.getStringView());\n    EXPECT_EQ(5UL, string.size());\n    EXPECT_EQ(\"hello\", string2.getStringView());\n    EXPECT_EQ(5UL, string2.size());\n  }\n\n  // Dynamic move constructor\n  {\n    std::string large(4096, 'a');\n    HeaderString string;\n    string.setCopy(large.c_str(), large.size());\n    EXPECT_EQ(HeaderString::Type::Dynamic, string.type());\n    HeaderString string2(std::move(string));\n    EXPECT_TRUE(string.empty()); // NOLINT(bugprone-use-after-move)\n    EXPECT_EQ(HeaderString::Type::Inline, string.type());\n    EXPECT_EQ(HeaderString::Type::Dynamic, string2.type());\n    string.append(\"b\", 1);\n    EXPECT_EQ(\"b\", string.getStringView());\n    EXPECT_EQ(1UL, string.size());\n    EXPECT_EQ(large, string2.getStringView());\n    EXPECT_EQ(4096UL, string2.size());\n  }\n\n  // Static to inline number.\n  {\n    std::string static_string(\"HELLO\");\n    HeaderString string(static_string);\n    string.setInteger(5);\n    EXPECT_EQ(HeaderString::Type::Inline, string.type());\n    EXPECT_EQ(\"5\", string.getStringView());\n  }\n\n  // Static to inline string.\n  {\n    std::string static_string(\"HELLO\");\n    HeaderString string(static_string);\n    string.setCopy(static_string.c_str(), static_string.size());\n    EXPECT_EQ(HeaderString::Type::Inline, string.type());\n    EXPECT_EQ(\"HELLO\", string.getStringView());\n  }\n\n  // Static clear() does nothing.\n  {\n    std::string static_string(\"HELLO\");\n    HeaderString string(static_string);\n    EXPECT_EQ(HeaderString::Type::Reference, string.type());\n    string.clear();\n    EXPECT_EQ(HeaderString::Type::Reference, string.type());\n    EXPECT_EQ(\"HELLO\", string.getStringView());\n  }\n\n  // Static to append.\n  {\n    std::string static_string(\"HELLO\");\n    HeaderString string(static_string);\n    EXPECT_EQ(HeaderString::Type::Reference, string.type());\n    string.append(\"a\", 1);\n    EXPECT_EQ(\"HELLOa\", string.getStringView());\n  }\n\n  // Copy inline\n  {\n    HeaderString string;\n    string.setCopy(\"hello\", 5);\n    EXPECT_EQ(\"hello\", string.getStringView());\n    EXPECT_EQ(5U, string.size());\n  }\n\n  // Copy dynamic\n  {\n    HeaderString string;\n    std::string large_value(4096, 'a');\n    string.setCopy(large_value.c_str(), large_value.size());\n    EXPECT_EQ(large_value, string.getStringView());\n    EXPECT_NE(large_value.c_str(), string.getStringView().data());\n    EXPECT_EQ(4096U, string.size());\n  }\n\n  // Copy twice dynamic\n  {\n    HeaderString string;\n    std::string large_value1(4096, 'a');\n    string.setCopy(large_value1.c_str(), large_value1.size());\n    std::string large_value2(2048, 'b');\n    string.setCopy(large_value2.c_str(), large_value2.size());\n    EXPECT_EQ(large_value2, string.getStringView());\n    EXPECT_NE(large_value2.c_str(), string.getStringView().data());\n    EXPECT_EQ(2048U, string.size());\n  }\n\n  // Copy twice dynamic with reallocate\n  {\n    HeaderString string;\n    std::string large_value1(4096, 'a');\n    string.setCopy(large_value1.c_str(), large_value1.size());\n    std::string large_value2(16384, 'b');\n    string.setCopy(large_value2.c_str(), large_value2.size());\n    EXPECT_EQ(large_value2, string.getStringView());\n    EXPECT_NE(large_value2.c_str(), string.getStringView().data());\n    EXPECT_EQ(16384U, string.size());\n  }\n\n  // Copy twice inline to dynamic\n  {\n    HeaderString string;\n    std::string large_value1(16, 'a');\n    string.setCopy(large_value1.c_str(), large_value1.size());\n    std::string large_value2(16384, 'b');\n    string.setCopy(large_value2.c_str(), large_value2.size());\n    EXPECT_EQ(large_value2, string.getStringView());\n    EXPECT_NE(large_value2.c_str(), string.getStringView().data());\n    EXPECT_EQ(16384U, string.size());\n  }\n\n  // Copy, exactly filling inline capacity\n  //\n  // ASAN does not catch the clobber in the case where the code writes one past the\n  // end of the inline buffer. To ensure coverage the next block checks that setCopy\n  // is not introducing a NUL in a way that does not rely on an actual clobber getting\n  // detected.\n  {\n    HeaderString string;\n    std::string large(128, 'z');\n    string.setCopy(large.c_str(), large.size());\n    EXPECT_EQ(string.type(), HeaderString::Type::Inline);\n    EXPECT_EQ(string.getStringView(), large);\n  }\n\n  // Ensure setCopy does not add NUL.\n  {\n    HeaderString string;\n    std::string large(128, 'z');\n    string.setCopy(large.c_str(), large.size());\n    EXPECT_EQ(string.type(), HeaderString::Type::Inline);\n    EXPECT_EQ(string.getStringView(), large);\n    std::string small(1, 'a');\n    string.setCopy(small.c_str(), small.size());\n    EXPECT_EQ(string.type(), HeaderString::Type::Inline);\n    EXPECT_EQ(string.getStringView(), small);\n    // If we peek past the valid first character of the\n    // header string_view it should still be 'z' and not '\\0'.\n    // We know this peek is OK since the memory is much larger\n    // than two bytes.\n    EXPECT_EQ(string.getStringView().data()[1], 'z');\n  }\n\n  // Copy, exactly filling dynamic capacity\n  //\n  // ASAN should catch a write one past the end of the dynamic buffer. This test\n  // forces a dynamic buffer with one copy and then fills it with the next.\n  {\n    HeaderString string;\n    // Force Dynamic with setCopy of inline buffer size + 1.\n    std::string large1(129, 'z');\n    string.setCopy(large1.c_str(), large1.size());\n    EXPECT_EQ(string.type(), HeaderString::Type::Dynamic);\n    const void* dynamic_buffer_address = string.getStringView().data();\n    // Dynamic capacity in setCopy is 2x required by the size.\n    // So to fill it exactly setCopy with a total of 258 chars.\n    std::string large2(258, 'z');\n    string.setCopy(large2.c_str(), large2.size());\n    EXPECT_EQ(string.type(), HeaderString::Type::Dynamic);\n    // The actual buffer address should be the same as it was after\n    // setCopy(large1), ensuring no reallocation occurred.\n    EXPECT_EQ(string.getStringView().data(), dynamic_buffer_address);\n    EXPECT_EQ(string.getStringView(), large2);\n  }\n\n  // Append, small buffer to dynamic\n  {\n    HeaderString string;\n    std::string test(128, 'a');\n    string.append(test.c_str(), test.size());\n    EXPECT_EQ(HeaderString::Type::Inline, string.type());\n    string.append(\"a\", 1);\n    EXPECT_EQ(HeaderString::Type::Dynamic, string.type());\n    test += 'a';\n    EXPECT_EQ(test, string.getStringView());\n  }\n\n  // Append into inline twice, then shift to dynamic.\n  {\n    HeaderString string;\n    string.append(\"hello\", 5);\n    EXPECT_EQ(\"hello\", string.getStringView());\n    EXPECT_EQ(5U, string.size());\n    string.append(\"world\", 5);\n    EXPECT_EQ(\"helloworld\", string.getStringView());\n    EXPECT_EQ(10U, string.size());\n    std::string large(4096, 'a');\n    string.append(large.c_str(), large.size());\n    large = \"helloworld\" + large;\n    EXPECT_EQ(large, string.getStringView());\n    EXPECT_EQ(4106U, string.size());\n  }\n\n  // Append, realloc dynamic.\n  {\n    HeaderString string;\n    std::string large(129, 'a');\n    string.append(large.c_str(), large.size());\n    EXPECT_EQ(HeaderString::Type::Dynamic, string.type());\n    std::string large2 = large + large;\n    string.append(large2.c_str(), large2.size());\n    large += large2;\n    EXPECT_EQ(large, string.getStringView());\n    EXPECT_EQ(387U, string.size());\n  }\n\n  // Append, realloc close to limit with small buffer.\n  {\n    HeaderString string;\n    std::string large(129, 'a');\n    string.append(large.c_str(), large.size());\n    EXPECT_EQ(HeaderString::Type::Dynamic, string.type());\n    std::string large2(120, 'b');\n    string.append(large2.c_str(), large2.size());\n    std::string large3(32, 'c');\n    string.append(large3.c_str(), large3.size());\n    EXPECT_EQ((large + large2 + large3), string.getStringView());\n    EXPECT_EQ(281U, string.size());\n  }\n\n  // Append, exactly filling dynamic capacity\n  //\n  // ASAN should catch a write one past the end of the dynamic buffer. This test\n  // forces a dynamic buffer with one copy and then fills it with the next.\n  {\n    HeaderString string;\n    // Force Dynamic with setCopy of inline buffer size + 1.\n    std::string large1(129, 'z');\n    string.setCopy(large1.c_str(), large1.size());\n    EXPECT_EQ(string.type(), HeaderString::Type::Dynamic);\n    const void* dynamic_buffer_address = string.getStringView().data();\n    // Dynamic capacity in setCopy is 2x required by the size.\n    // So to fill it exactly append 129 chars for a total of 258 chars.\n    std::string large2(129, 'z');\n    string.append(large2.c_str(), large2.size());\n    EXPECT_EQ(string.type(), HeaderString::Type::Dynamic);\n    // The actual buffer address should be the same as it was after\n    // setCopy(large1), ensuring no reallocation occurred.\n    EXPECT_EQ(string.getStringView().data(), dynamic_buffer_address);\n    EXPECT_EQ(string.getStringView(), large1 + large2);\n  }\n\n  // Set integer, inline\n  {\n    HeaderString string;\n    string.setInteger(123456789);\n    EXPECT_EQ(\"123456789\", string.getStringView());\n    EXPECT_EQ(9U, string.size());\n  }\n\n  // Set integer, dynamic\n  {\n    HeaderString string;\n    std::string large(129, 'a');\n    string.append(large.c_str(), large.size());\n    string.setInteger(123456789);\n    EXPECT_EQ(\"123456789\", string.getStringView());\n    EXPECT_EQ(9U, string.size());\n    EXPECT_EQ(HeaderString::Type::Dynamic, string.type());\n  }\n\n  // Set static, switch to dynamic, back to static.\n  {\n    const std::string static_string = \"hello world\";\n    HeaderString string;\n    string.setReference(static_string);\n    EXPECT_EQ(string.getStringView(), static_string);\n    EXPECT_EQ(11U, string.size());\n    EXPECT_EQ(HeaderString::Type::Reference, string.type());\n\n    const std::string large(129, 'a');\n    string.setCopy(large.c_str(), large.size());\n    EXPECT_NE(string.getStringView().data(), large.c_str());\n    EXPECT_EQ(HeaderString::Type::Dynamic, string.type());\n\n    string.setReference(static_string);\n    EXPECT_EQ(string.getStringView(), static_string);\n    EXPECT_EQ(11U, string.size());\n    EXPECT_EQ(HeaderString::Type::Reference, string.type());\n  }\n\n  // getString\n  {\n    std::string static_string(\"HELLO\");\n    HeaderString headerString1(static_string);\n    absl::string_view retString1 = headerString1.getStringView();\n    EXPECT_EQ(\"HELLO\", retString1);\n    EXPECT_EQ(5U, retString1.size());\n\n    HeaderString headerString2;\n    absl::string_view retString2 = headerString2.getStringView();\n    EXPECT_EQ(0U, retString2.size());\n  }\n}\n\nTEST(HeaderMapImplTest, InlineInsert) {\n  HeaderMapImpl headers;\n  EXPECT_TRUE(headers.empty());\n  EXPECT_EQ(0, headers.size());\n  EXPECT_EQ(headers.byteSize().value(), 0);\n  EXPECT_EQ(nullptr, headers.Host());\n  headers.insertHost().value(std::string(\"hello\"));\n  EXPECT_FALSE(headers.empty());\n  EXPECT_EQ(1, headers.size());\n  EXPECT_EQ(\":authority\", headers.Host()->key().getStringView());\n  EXPECT_EQ(\"hello\", headers.Host()->value().getStringView());\n  EXPECT_EQ(\"hello\", headers.get(Headers::get().Host)->value().getStringView());\n}\n\n// Utility function for testing byteSize() against a manual byte count.\nuint64_t countBytesForTest(const HeaderMapImpl& headers) {\n  uint64_t byte_size = 0;\n  headers.iterate(\n      [](const Http::HeaderEntry& header, void* context) -> Http::HeaderMap::Iterate {\n        auto* byte_size = static_cast<uint64_t*>(context);\n        *byte_size += header.key().getStringView().size() + header.value().getStringView().size();\n        return Http::HeaderMap::Iterate::Continue;\n      },\n      &byte_size);\n  return byte_size;\n}\n\nTEST(HeaderMapImplTest, MoveIntoInline) {\n  HeaderMapImpl headers;\n  HeaderString key;\n  key.setCopy(Headers::get().CacheControl.get());\n  HeaderString value;\n  value.setCopy(\"hello\", 5);\n  headers.addViaMove(std::move(key), std::move(value));\n  EXPECT_EQ(\"cache-control\", headers.CacheControl()->key().getStringView());\n  EXPECT_EQ(\"hello\", headers.CacheControl()->value().getStringView());\n\n  HeaderString key2;\n  key2.setCopy(Headers::get().CacheControl.get().c_str(), Headers::get().CacheControl.get().size());\n  HeaderString value2;\n  value2.setCopy(\"there\", 5);\n  headers.addViaMove(std::move(key2), std::move(value2));\n  EXPECT_EQ(\"cache-control\", headers.CacheControl()->key().getStringView());\n  EXPECT_EQ(\"hello,there\", headers.CacheControl()->value().getStringView());\n  EXPECT_EQ(headers.refreshByteSize(), countBytesForTest(headers));\n}\n\nTEST(HeaderMapImplTest, Remove) {\n  HeaderMapImpl headers;\n\n  // Add random header and then remove by name.\n  LowerCaseString static_key(\"hello\");\n  std::string ref_value(\"value\");\n  headers.addReference(static_key, ref_value);\n  EXPECT_EQ(headers.byteSize().value(), countBytesForTest(headers));\n  EXPECT_EQ(\"value\", headers.get(static_key)->value().getStringView());\n  EXPECT_EQ(HeaderString::Type::Reference, headers.get(static_key)->value().type());\n  EXPECT_EQ(1UL, headers.size());\n  EXPECT_FALSE(headers.empty());\n  headers.remove(static_key);\n  EXPECT_EQ(nullptr, headers.get(static_key));\n  EXPECT_EQ(0UL, headers.size());\n  EXPECT_TRUE(headers.empty());\n  EXPECT_EQ(headers.refreshByteSize(), 0);\n\n  // Add and remove by inline.\n  headers.insertContentLength().value(5);\n  EXPECT_EQ(headers.refreshByteSize(), countBytesForTest(headers));\n  EXPECT_EQ(\"5\", headers.ContentLength()->value().getStringView());\n  EXPECT_EQ(1UL, headers.size());\n  EXPECT_FALSE(headers.empty());\n  headers.removeContentLength();\n  EXPECT_EQ(nullptr, headers.ContentLength());\n  EXPECT_EQ(0UL, headers.size());\n  EXPECT_TRUE(headers.empty());\n  EXPECT_EQ(headers.refreshByteSize(), countBytesForTest(headers));\n\n  // Add inline and remove by name.\n  headers.insertContentLength().value(5);\n  EXPECT_EQ(\"5\", headers.ContentLength()->value().getStringView());\n  EXPECT_EQ(1UL, headers.size());\n  EXPECT_FALSE(headers.empty());\n  EXPECT_EQ(headers.refreshByteSize(), countBytesForTest(headers));\n  headers.remove(Headers::get().ContentLength);\n  EXPECT_EQ(nullptr, headers.ContentLength());\n  EXPECT_EQ(0UL, headers.size());\n  EXPECT_TRUE(headers.empty());\n  EXPECT_EQ(headers.refreshByteSize(), 0);\n}\n\nTEST(HeaderMapImplTest, RemoveRegex) {\n  // These will match.\n  LowerCaseString key1 = LowerCaseString(\"X-prefix-foo\");\n  LowerCaseString key3 = LowerCaseString(\"X-Prefix-\");\n  LowerCaseString key5 = LowerCaseString(\"x-prefix-eep\");\n  // These will not.\n  LowerCaseString key2 = LowerCaseString(\" x-prefix-foo\");\n  LowerCaseString key4 = LowerCaseString(\"y-x-prefix-foo\");\n\n  HeaderMapImpl headers;\n  headers.addReference(key1, \"value\");\n  headers.addReference(key2, \"value\");\n  headers.addReference(key3, \"value\");\n  headers.addReference(key4, \"value\");\n  headers.addReference(key5, \"value\");\n  EXPECT_EQ(headers.byteSize().value(), countBytesForTest(headers));\n\n  // Test removing the first header, middle headers, and the end header.\n  headers.removePrefix(LowerCaseString(\"x-prefix-\"));\n  EXPECT_EQ(headers.byteSize().value(), countBytesForTest(headers));\n  EXPECT_EQ(nullptr, headers.get(key1));\n  EXPECT_NE(nullptr, headers.get(key2));\n  EXPECT_EQ(nullptr, headers.get(key3));\n  EXPECT_NE(nullptr, headers.get(key4));\n  EXPECT_EQ(nullptr, headers.get(key5));\n\n  // Remove all headers.\n  headers.refreshByteSize();\n  headers.removePrefix(LowerCaseString(\"\"));\n  EXPECT_EQ(headers.byteSize().value(), 0);\n  EXPECT_EQ(nullptr, headers.get(key2));\n  EXPECT_EQ(nullptr, headers.get(key4));\n\n  // Add inline and remove by regex\n  headers.insertContentLength().value(5);\n  EXPECT_EQ(\"5\", headers.ContentLength()->value().getStringView());\n  EXPECT_EQ(1UL, headers.size());\n  EXPECT_FALSE(headers.empty());\n  EXPECT_EQ(headers.refreshByteSize(), countBytesForTest(headers));\n  headers.removePrefix(LowerCaseString(\"content\"));\n  EXPECT_EQ(nullptr, headers.ContentLength());\n  EXPECT_EQ(headers.refreshByteSize(), 0);\n}\n\nTEST(HeaderMapImplTest, SetRemovesAllValues) {\n  HeaderMapImpl headers;\n\n  LowerCaseString key1(\"hello\");\n  LowerCaseString key2(\"olleh\");\n  std::string ref_value1(\"world\");\n  std::string ref_value2(\"planet\");\n  std::string ref_value3(\"globe\");\n  std::string ref_value4(\"earth\");\n  std::string ref_value5(\"blue marble\");\n\n  headers.addReference(key1, ref_value1);\n  headers.addReference(key2, ref_value2);\n  headers.addReference(key1, ref_value3);\n  headers.addReference(key1, ref_value4);\n  EXPECT_EQ(headers.byteSize().value(), countBytesForTest(headers));\n\n  using MockCb = testing::MockFunction<void(const std::string&, const std::string&)>;\n\n  {\n    MockCb cb;\n\n    InSequence seq;\n    EXPECT_CALL(cb, Call(\"hello\", \"world\"));\n    EXPECT_CALL(cb, Call(\"olleh\", \"planet\"));\n    EXPECT_CALL(cb, Call(\"hello\", \"globe\"));\n    EXPECT_CALL(cb, Call(\"hello\", \"earth\"));\n\n    headers.iterate(\n        [](const Http::HeaderEntry& header, void* cb_v) -> HeaderMap::Iterate {\n          static_cast<MockCb*>(cb_v)->Call(std::string(header.key().getStringView()),\n                                           std::string(header.value().getStringView()));\n          return HeaderMap::Iterate::Continue;\n        },\n        &cb);\n  }\n\n  headers.setReference(key1, ref_value5); // set moves key to end\n\n  {\n    MockCb cb;\n\n    InSequence seq;\n    EXPECT_CALL(cb, Call(\"olleh\", \"planet\"));\n    EXPECT_CALL(cb, Call(\"hello\", \"blue marble\"));\n\n    headers.iterate(\n        [](const Http::HeaderEntry& header, void* cb_v) -> HeaderMap::Iterate {\n          static_cast<MockCb*>(cb_v)->Call(std::string(header.key().getStringView()),\n                                           std::string(header.value().getStringView()));\n          return HeaderMap::Iterate::Continue;\n        },\n        &cb);\n  }\n}\n\nTEST(HeaderMapImplTest, DoubleInlineAdd) {\n  {\n    HeaderMapImpl headers;\n    const std::string foo(\"foo\");\n    const std::string bar(\"bar\");\n    headers.addReference(Headers::get().ContentLength, foo);\n    headers.addReference(Headers::get().ContentLength, bar);\n    EXPECT_EQ(headers.byteSize().value(), countBytesForTest(headers));\n    EXPECT_EQ(\"foo,bar\", headers.ContentLength()->value().getStringView());\n    EXPECT_EQ(1UL, headers.size());\n  }\n  {\n    HeaderMapImpl headers;\n    headers.addReferenceKey(Headers::get().ContentLength, \"foo\");\n    headers.addReferenceKey(Headers::get().ContentLength, \"bar\");\n    EXPECT_EQ(headers.byteSize().value(), countBytesForTest(headers));\n    EXPECT_EQ(\"foo,bar\", headers.ContentLength()->value().getStringView());\n    EXPECT_EQ(1UL, headers.size());\n  }\n  {\n    HeaderMapImpl headers;\n    headers.addReferenceKey(Headers::get().ContentLength, 5);\n    headers.addReferenceKey(Headers::get().ContentLength, 6);\n    EXPECT_EQ(headers.byteSize().value(), countBytesForTest(headers));\n    EXPECT_EQ(\"5,6\", headers.ContentLength()->value().getStringView());\n    EXPECT_EQ(1UL, headers.size());\n  }\n  {\n    HeaderMapImpl headers;\n    const std::string foo(\"foo\");\n    headers.addReference(Headers::get().ContentLength, foo);\n    headers.addReferenceKey(Headers::get().ContentLength, 6);\n    EXPECT_EQ(headers.byteSize().value(), countBytesForTest(headers));\n    EXPECT_EQ(\"foo,6\", headers.ContentLength()->value().getStringView());\n    EXPECT_EQ(1UL, headers.size());\n  }\n}\n\n// Per https://github.com/envoyproxy/envoy/issues/7488 make sure we don't\n// combine set-cookie headers\nTEST(HeaderMapImplTest, DoubleCookieAdd) {\n  HeaderMapImpl headers;\n  const std::string foo(\"foo\");\n  const std::string bar(\"bar\");\n  const LowerCaseString& set_cookie = Http::Headers::get().SetCookie;\n  headers.addReference(set_cookie, foo);\n  headers.addReference(set_cookie, bar);\n  EXPECT_EQ(2UL, headers.size());\n  EXPECT_EQ(headers.byteSize().value(), countBytesForTest(headers));\n\n  std::vector<absl::string_view> out;\n  Http::HeaderUtility::getAllOfHeader(headers, \"set-cookie\", out);\n  ASSERT_EQ(out.size(), 2);\n  ASSERT_EQ(out[0], \"foo\");\n  ASSERT_EQ(out[1], \"bar\");\n}\n\nTEST(HeaderMapImplTest, DoubleInlineSet) {\n  HeaderMapImpl headers;\n  headers.setReferenceKey(Headers::get().ContentType, \"blah\");\n  headers.setReferenceKey(Headers::get().ContentType, \"text/html\");\n  EXPECT_EQ(headers.byteSize().value(), countBytesForTest(headers));\n  EXPECT_EQ(\"text/html\", headers.ContentType()->value().getStringView());\n  EXPECT_EQ(1UL, headers.size());\n}\n\nTEST(HeaderMapImplTest, AddReferenceKey) {\n  HeaderMapImpl headers;\n  LowerCaseString foo(\"hello\");\n  headers.addReferenceKey(foo, \"world\");\n  EXPECT_EQ(headers.byteSize().value(), countBytesForTest(headers));\n  EXPECT_NE(\"world\", headers.get(foo)->value().getStringView().data());\n  EXPECT_EQ(\"world\", headers.get(foo)->value().getStringView());\n}\n\nTEST(HeaderMapImplTest, SetReferenceKey) {\n  HeaderMapImpl headers;\n  LowerCaseString foo(\"hello\");\n  headers.setReferenceKey(foo, \"world\");\n  EXPECT_EQ(headers.byteSize().value(), countBytesForTest(headers));\n  EXPECT_NE(\"world\", headers.get(foo)->value().getStringView().data());\n  EXPECT_EQ(\"world\", headers.get(foo)->value().getStringView());\n  headers.refreshByteSize();\n\n  headers.setReferenceKey(foo, \"monde\");\n  EXPECT_EQ(headers.byteSize().value(), countBytesForTest(headers));\n  EXPECT_NE(\"monde\", headers.get(foo)->value().getStringView().data());\n  EXPECT_EQ(\"monde\", headers.get(foo)->value().getStringView());\n}\n\nTEST(HeaderMapImplTest, AddCopy) {\n  HeaderMapImpl headers;\n\n  // Start with a string value.\n  std::unique_ptr<LowerCaseString> lcKeyPtr(new LowerCaseString(\"hello\"));\n  headers.addCopy(*lcKeyPtr, \"world\");\n  EXPECT_EQ(headers.byteSize().value(), countBytesForTest(headers));\n\n  const HeaderString& value = headers.get(*lcKeyPtr)->value();\n\n  EXPECT_EQ(\"world\", value.getStringView());\n  EXPECT_EQ(5UL, value.size());\n\n  lcKeyPtr.reset();\n\n  const HeaderString& value2 = headers.get(LowerCaseString(\"hello\"))->value();\n\n  EXPECT_EQ(\"world\", value2.getStringView());\n  EXPECT_EQ(5UL, value2.size());\n  EXPECT_EQ(value.getStringView(), value2.getStringView());\n  EXPECT_EQ(1UL, headers.size());\n\n  // Repeat with an int value.\n  //\n  // addReferenceKey and addCopy can both add multiple instances of a\n  // given header, so we need to delete the old \"hello\" header.\n  // Test that removing will return 0 byte size.\n  headers.refreshByteSize();\n  headers.remove(LowerCaseString(\"hello\"));\n  EXPECT_EQ(headers.byteSize().value(), 0);\n\n  // Build \"hello\" with string concatenation to make it unlikely that the\n  // compiler is just reusing the same string constant for everything.\n  lcKeyPtr = std::make_unique<LowerCaseString>(std::string(\"he\") + \"llo\");\n  EXPECT_STREQ(\"hello\", lcKeyPtr->get().c_str());\n\n  headers.refreshByteSize();\n  headers.addCopy(*lcKeyPtr, 42);\n  EXPECT_EQ(headers.byteSize().value(), countBytesForTest(headers));\n\n  const HeaderString& value3 = headers.get(*lcKeyPtr)->value();\n\n  EXPECT_EQ(\"42\", value3.getStringView());\n  EXPECT_EQ(2UL, value3.size());\n\n  lcKeyPtr.reset();\n\n  const HeaderString& value4 = headers.get(LowerCaseString(\"hello\"))->value();\n\n  EXPECT_EQ(\"42\", value4.getStringView());\n  EXPECT_EQ(2UL, value4.size());\n  EXPECT_EQ(1UL, headers.size());\n\n  // Here, again, we'll build yet another key string.\n  LowerCaseString lcKey3(std::string(\"he\") + \"ll\" + \"o\");\n  EXPECT_STREQ(\"hello\", lcKey3.get().c_str());\n\n  EXPECT_EQ(\"42\", headers.get(lcKey3)->value().getStringView());\n  EXPECT_EQ(2UL, headers.get(lcKey3)->value().size());\n\n  LowerCaseString cache_control(\"cache-control\");\n  headers.addCopy(cache_control, \"max-age=1345\");\n  EXPECT_EQ(\"max-age=1345\", headers.get(cache_control)->value().getStringView());\n  EXPECT_EQ(\"max-age=1345\", headers.CacheControl()->value().getStringView());\n  EXPECT_EQ(headers.refreshByteSize(), countBytesForTest(headers));\n  headers.addCopy(cache_control, \"public\");\n  EXPECT_EQ(headers.refreshByteSize(), countBytesForTest(headers));\n  EXPECT_EQ(\"max-age=1345,public\", headers.get(cache_control)->value().getStringView());\n  headers.addCopy(cache_control, \"\");\n  EXPECT_EQ(headers.refreshByteSize(), countBytesForTest(headers));\n  EXPECT_EQ(\"max-age=1345,public\", headers.get(cache_control)->value().getStringView());\n  headers.addCopy(cache_control, 123);\n  EXPECT_EQ(headers.refreshByteSize(), countBytesForTest(headers));\n  EXPECT_EQ(\"max-age=1345,public,123\", headers.get(cache_control)->value().getStringView());\n  headers.addCopy(cache_control, std::numeric_limits<uint64_t>::max());\n  EXPECT_EQ(\"max-age=1345,public,123,18446744073709551615\",\n            headers.get(cache_control)->value().getStringView());\n  EXPECT_EQ(headers.refreshByteSize(), countBytesForTest(headers));\n}\n\nTEST(HeaderMapImplTest, Equality) {\n  TestHeaderMapImpl headers1;\n  TestHeaderMapImpl headers2;\n  EXPECT_EQ(headers1, headers2);\n\n  headers1.addCopy(\"hello\", \"world\");\n  EXPECT_FALSE(headers1 == headers2);\n\n  headers2.addCopy(\"foo\", \"bar\");\n  EXPECT_FALSE(headers1 == headers2);\n}\n\nTEST(HeaderMapImplTest, LargeCharInHeader) {\n  HeaderMapImpl headers;\n  LowerCaseString static_key(\"\\x90hello\");\n  std::string ref_value(\"value\");\n  headers.addReference(static_key, ref_value);\n  EXPECT_EQ(headers.byteSize().value(), countBytesForTest(headers));\n  EXPECT_EQ(\"value\", headers.get(static_key)->value().getStringView());\n}\n\nTEST(HeaderMapImplTest, Iterate) {\n  TestHeaderMapImpl headers;\n  headers.addCopy(\"hello\", \"world\");\n  headers.addCopy(\"foo\", \"xxx\");\n  headers.addCopy(\"world\", \"hello\");\n  LowerCaseString foo_key(\"foo\");\n  headers.setReferenceKey(foo_key, \"bar\"); // set moves key to end\n\n  using MockCb = testing::MockFunction<void(const std::string&, const std::string&)>;\n  MockCb cb;\n\n  InSequence seq;\n  EXPECT_CALL(cb, Call(\"hello\", \"world\"));\n  EXPECT_CALL(cb, Call(\"world\", \"hello\"));\n  EXPECT_CALL(cb, Call(\"foo\", \"bar\"));\n  headers.iterate(\n      [](const Http::HeaderEntry& header, void* cb_v) -> HeaderMap::Iterate {\n        static_cast<MockCb*>(cb_v)->Call(std::string(header.key().getStringView()),\n                                         std::string(header.value().getStringView()));\n        return HeaderMap::Iterate::Continue;\n      },\n      &cb);\n}\n\nTEST(HeaderMapImplTest, IterateReverse) {\n  TestHeaderMapImpl headers;\n  headers.addCopy(\"hello\", \"world\");\n  headers.addCopy(\"foo\", \"bar\");\n  LowerCaseString world_key(\"world\");\n  headers.setReferenceKey(world_key, \"hello\");\n\n  using MockCb = testing::MockFunction<void(const std::string&, const std::string&)>;\n  MockCb cb;\n\n  InSequence seq;\n  EXPECT_CALL(cb, Call(\"world\", \"hello\"));\n  EXPECT_CALL(cb, Call(\"foo\", \"bar\"));\n  // no \"hello\"\n  headers.iterateReverse(\n      [](const Http::HeaderEntry& header, void* cb_v) -> HeaderMap::Iterate {\n        static_cast<MockCb*>(cb_v)->Call(std::string(header.key().getStringView()),\n                                         std::string(header.value().getStringView()));\n        if (header.key().getStringView() != \"foo\") {\n          return HeaderMap::Iterate::Continue;\n        } else {\n          return HeaderMap::Iterate::Break;\n        }\n      },\n      &cb);\n}\n\nTEST(HeaderMapImplTest, Lookup) {\n  TestHeaderMapImpl headers;\n  headers.addCopy(\"hello\", \"world\");\n  headers.insertContentLength().value(5);\n\n  // Lookup is not supported for non predefined inline headers.\n  {\n    const HeaderEntry* entry;\n    EXPECT_EQ(HeaderMap::Lookup::NotSupported, headers.lookup(LowerCaseString{\"hello\"}, &entry));\n    EXPECT_EQ(nullptr, entry);\n  }\n\n  // Lookup returns the entry of a predefined inline header if it exists.\n  {\n    const HeaderEntry* entry;\n    EXPECT_EQ(HeaderMap::Lookup::Found, headers.lookup(Headers::get().ContentLength, &entry));\n    EXPECT_EQ(\"5\", entry->value().getStringView());\n  }\n\n  // Lookup returns HeaderMap::Lookup::NotFound if a predefined inline header does not exist.\n  {\n    const HeaderEntry* entry;\n    EXPECT_EQ(HeaderMap::Lookup::NotFound, headers.lookup(Headers::get().Host, &entry));\n    EXPECT_EQ(nullptr, entry);\n  }\n}\n\nTEST(HeaderMapImplTest, Get) {\n  {\n    const TestHeaderMapImpl headers{{\":path\", \"/\"}, {\"hello\", \"world\"}};\n    EXPECT_EQ(\"/\", headers.get(LowerCaseString(\":path\"))->value().getStringView());\n    EXPECT_EQ(\"world\", headers.get(LowerCaseString(\"hello\"))->value().getStringView());\n    EXPECT_EQ(nullptr, headers.get(LowerCaseString(\"foo\")));\n  }\n\n  {\n    TestHeaderMapImpl headers{{\":path\", \"/\"}, {\"hello\", \"world\"}};\n    headers.get(LowerCaseString(\":path\"))->value(std::string(\"/new_path\"));\n    EXPECT_EQ(\"/new_path\", headers.get(LowerCaseString(\":path\"))->value().getStringView());\n    headers.get(LowerCaseString(\"hello\"))->value(std::string(\"world2\"));\n    EXPECT_EQ(\"world2\", headers.get(LowerCaseString(\"hello\"))->value().getStringView());\n    EXPECT_EQ(nullptr, headers.get(LowerCaseString(\"foo\")));\n  }\n}\n\nTEST(HeaderMapImplTest, TestAppendHeader) {\n  // Test appending to a string with a value.\n  {\n    HeaderString value1;\n    value1.setCopy(\"some;\", 5);\n    HeaderMapImpl::appendToHeader(value1, \"test\");\n    EXPECT_EQ(value1, \"some;,test\");\n  }\n\n  // Test appending to an empty string.\n  {\n    HeaderString value2;\n    HeaderMapImpl::appendToHeader(value2, \"my tag data\");\n    EXPECT_EQ(value2, \"my tag data\");\n  }\n\n  // Test empty data case.\n  {\n    HeaderString value3;\n    value3.setCopy(\"empty\", 5);\n    HeaderMapImpl::appendToHeader(value3, \"\");\n    EXPECT_EQ(value3, \"empty\");\n  }\n  // Regression test for appending to an empty string with a short string, then\n  // setting integer.\n  {\n    const std::string empty;\n    HeaderString value4(empty);\n    HeaderMapImpl::appendToHeader(value4, \" \");\n    value4.setInteger(0);\n    EXPECT_EQ(\"0\", value4.getStringView());\n    EXPECT_EQ(1U, value4.size());\n  }\n}\n\nTEST(HeaderMapImplDeathTest, TestHeaderLengthChecks) {\n  HeaderString value;\n  value.setCopy(\"some;\", 5);\n  EXPECT_DEATH_LOG_TO_STDERR(value.append(nullptr, std::numeric_limits<uint32_t>::max()),\n                             \"Trying to allocate overly large headers.\");\n\n  std::string source(\"hello\");\n  HeaderString reference;\n  reference.setReference(source);\n  EXPECT_DEATH_LOG_TO_STDERR(reference.append(nullptr, std::numeric_limits<uint32_t>::max()),\n                             \"Trying to allocate overly large headers.\");\n}\n\nTEST(HeaderMapImplTest, PseudoHeaderOrder) {\n  using MockCb = testing::MockFunction<void(const std::string&, const std::string&)>;\n  MockCb cb;\n\n  {\n    LowerCaseString foo(\"hello\");\n    Http::TestHeaderMapImpl headers{};\n    EXPECT_EQ(headers.refreshByteSize(), 0);\n    EXPECT_EQ(0UL, headers.size());\n    EXPECT_TRUE(headers.empty());\n\n    headers.addReferenceKey(foo, \"world\");\n    EXPECT_EQ(1UL, headers.size());\n    EXPECT_FALSE(headers.empty());\n\n    headers.setReferenceKey(Headers::get().ContentType, \"text/html\");\n    EXPECT_EQ(2UL, headers.size());\n    EXPECT_FALSE(headers.empty());\n\n    // Pseudo header gets inserted before non-pseudo headers\n    headers.setReferenceKey(Headers::get().Method, \"PUT\");\n    EXPECT_EQ(3UL, headers.size());\n    EXPECT_FALSE(headers.empty());\n\n    InSequence seq;\n    EXPECT_CALL(cb, Call(\":method\", \"PUT\"));\n    EXPECT_CALL(cb, Call(\"hello\", \"world\"));\n    EXPECT_CALL(cb, Call(\"content-type\", \"text/html\"));\n\n    headers.iterate(\n        [](const Http::HeaderEntry& header, void* cb_v) -> HeaderMap::Iterate {\n          static_cast<MockCb*>(cb_v)->Call(std::string(header.key().getStringView()),\n                                           std::string(header.value().getStringView()));\n          return HeaderMap::Iterate::Continue;\n        },\n        &cb);\n\n    // Removal of the header before which pseudo-headers are inserted\n    headers.remove(foo);\n    EXPECT_EQ(2UL, headers.size());\n    EXPECT_FALSE(headers.empty());\n\n    EXPECT_CALL(cb, Call(\":method\", \"PUT\"));\n    EXPECT_CALL(cb, Call(\"content-type\", \"text/html\"));\n\n    headers.iterate(\n        [](const Http::HeaderEntry& header, void* cb_v) -> HeaderMap::Iterate {\n          static_cast<MockCb*>(cb_v)->Call(std::string(header.key().getStringView()),\n                                           std::string(header.value().getStringView()));\n          return HeaderMap::Iterate::Continue;\n        },\n        &cb);\n\n    // Next pseudo-header goes after other pseudo-headers, but before normal headers\n    headers.setReferenceKey(Headers::get().Path, \"/test\");\n    EXPECT_EQ(3UL, headers.size());\n    EXPECT_FALSE(headers.empty());\n\n    EXPECT_CALL(cb, Call(\":method\", \"PUT\"));\n    EXPECT_CALL(cb, Call(\":path\", \"/test\"));\n    EXPECT_CALL(cb, Call(\"content-type\", \"text/html\"));\n\n    headers.iterate(\n        [](const Http::HeaderEntry& header, void* cb_v) -> HeaderMap::Iterate {\n          static_cast<MockCb*>(cb_v)->Call(std::string(header.key().getStringView()),\n                                           std::string(header.value().getStringView()));\n          return HeaderMap::Iterate::Continue;\n        },\n        &cb);\n\n    // Removing the last normal header\n    headers.remove(Headers::get().ContentType);\n    EXPECT_EQ(2UL, headers.size());\n    EXPECT_FALSE(headers.empty());\n\n    EXPECT_CALL(cb, Call(\":method\", \"PUT\"));\n    EXPECT_CALL(cb, Call(\":path\", \"/test\"));\n\n    headers.iterate(\n        [](const Http::HeaderEntry& header, void* cb_v) -> HeaderMap::Iterate {\n          static_cast<MockCb*>(cb_v)->Call(std::string(header.key().getStringView()),\n                                           std::string(header.value().getStringView()));\n          return HeaderMap::Iterate::Continue;\n        },\n        &cb);\n\n    // Adding a new pseudo-header after removing the last normal header\n    headers.setReferenceKey(Headers::get().Host, \"host\");\n    EXPECT_EQ(3UL, headers.size());\n    EXPECT_FALSE(headers.empty());\n\n    EXPECT_CALL(cb, Call(\":method\", \"PUT\"));\n    EXPECT_CALL(cb, Call(\":path\", \"/test\"));\n    EXPECT_CALL(cb, Call(\":authority\", \"host\"));\n\n    headers.iterate(\n        [](const Http::HeaderEntry& header, void* cb_v) -> HeaderMap::Iterate {\n          static_cast<MockCb*>(cb_v)->Call(std::string(header.key().getStringView()),\n                                           std::string(header.value().getStringView()));\n          return HeaderMap::Iterate::Continue;\n        },\n        &cb);\n\n    // Adding the first normal header\n    headers.setReferenceKey(Headers::get().ContentType, \"text/html\");\n    EXPECT_EQ(4UL, headers.size());\n    EXPECT_FALSE(headers.empty());\n\n    EXPECT_CALL(cb, Call(\":method\", \"PUT\"));\n    EXPECT_CALL(cb, Call(\":path\", \"/test\"));\n    EXPECT_CALL(cb, Call(\":authority\", \"host\"));\n    EXPECT_CALL(cb, Call(\"content-type\", \"text/html\"));\n\n    headers.iterate(\n        [](const Http::HeaderEntry& header, void* cb_v) -> HeaderMap::Iterate {\n          static_cast<MockCb*>(cb_v)->Call(std::string(header.key().getStringView()),\n                                           std::string(header.value().getStringView()));\n          return HeaderMap::Iterate::Continue;\n        },\n        &cb);\n\n    // Removing all pseudo-headers\n    headers.remove(Headers::get().Path);\n    headers.remove(Headers::get().Method);\n    headers.remove(Headers::get().Host);\n    EXPECT_EQ(1UL, headers.size());\n    EXPECT_FALSE(headers.empty());\n\n    EXPECT_CALL(cb, Call(\"content-type\", \"text/html\"));\n\n    headers.iterate(\n        [](const Http::HeaderEntry& header, void* cb_v) -> HeaderMap::Iterate {\n          static_cast<MockCb*>(cb_v)->Call(std::string(header.key().getStringView()),\n                                           std::string(header.value().getStringView()));\n          return HeaderMap::Iterate::Continue;\n        },\n        &cb);\n\n    // Removing all headers\n    headers.remove(Headers::get().ContentType);\n    EXPECT_EQ(0UL, headers.size());\n    EXPECT_TRUE(headers.empty());\n\n    // Adding a lone pseudo-header\n    headers.setReferenceKey(Headers::get().Status, \"200\");\n    EXPECT_EQ(1UL, headers.size());\n    EXPECT_FALSE(headers.empty());\n\n    EXPECT_CALL(cb, Call(\":status\", \"200\"));\n\n    headers.iterate(\n        [](const Http::HeaderEntry& header, void* cb_v) -> HeaderMap::Iterate {\n          static_cast<MockCb*>(cb_v)->Call(std::string(header.key().getStringView()),\n                                           std::string(header.value().getStringView()));\n          return HeaderMap::Iterate::Continue;\n        },\n        &cb);\n  }\n\n  // Starting with a normal header\n  {\n    Http::TestHeaderMapImpl headers{{\"content-type\", \"text/plain\"},\n                                    {\":method\", \"GET\"},\n                                    {\":path\", \"/\"},\n                                    {\"hello\", \"world\"},\n                                    {\":authority\", \"host\"}};\n\n    InSequence seq;\n    EXPECT_CALL(cb, Call(\":method\", \"GET\"));\n    EXPECT_CALL(cb, Call(\":path\", \"/\"));\n    EXPECT_CALL(cb, Call(\":authority\", \"host\"));\n    EXPECT_CALL(cb, Call(\"content-type\", \"text/plain\"));\n    EXPECT_CALL(cb, Call(\"hello\", \"world\"));\n\n    headers.iterate(\n        [](const Http::HeaderEntry& header, void* cb_v) -> HeaderMap::Iterate {\n          static_cast<MockCb*>(cb_v)->Call(std::string(header.key().getStringView()),\n                                           std::string(header.value().getStringView()));\n          return HeaderMap::Iterate::Continue;\n        },\n        &cb);\n  }\n\n  // Starting with a pseudo-header\n  {\n    Http::TestHeaderMapImpl headers{{\":path\", \"/\"},\n                                    {\"content-type\", \"text/plain\"},\n                                    {\":method\", \"GET\"},\n                                    {\"hello\", \"world\"},\n                                    {\":authority\", \"host\"}};\n\n    InSequence seq;\n    EXPECT_CALL(cb, Call(\":path\", \"/\"));\n    EXPECT_CALL(cb, Call(\":method\", \"GET\"));\n    EXPECT_CALL(cb, Call(\":authority\", \"host\"));\n    EXPECT_CALL(cb, Call(\"content-type\", \"text/plain\"));\n    EXPECT_CALL(cb, Call(\"hello\", \"world\"));\n\n    headers.iterate(\n        [](const Http::HeaderEntry& header, void* cb_v) -> HeaderMap::Iterate {\n          static_cast<MockCb*>(cb_v)->Call(std::string(header.key().getStringView()),\n                                           std::string(header.value().getStringView()));\n          return HeaderMap::Iterate::Continue;\n        },\n        &cb);\n  }\n}\n\n// Validate that TestHeaderMapImpl copy construction and assignment works. This is a\n// regression for where we were missing a valid copy constructor and had the\n// default (dangerous) move semantics takeover.\nTEST(HeaderMapImplTest, TestHeaderMapImplyCopy) {\n  TestHeaderMapImpl foo;\n  foo.addCopy(LowerCaseString(\"foo\"), \"bar\");\n  auto headers = std::make_unique<TestHeaderMapImpl>(foo);\n  EXPECT_EQ(\"bar\", headers->get(LowerCaseString(\"foo\"))->value().getStringView());\n  TestHeaderMapImpl baz{{\"foo\", \"baz\"}};\n  baz = *headers;\n  EXPECT_EQ(\"bar\", baz.get(LowerCaseString(\"foo\"))->value().getStringView());\n  const TestHeaderMapImpl& baz2 = baz;\n  baz = baz2;\n  EXPECT_EQ(\"bar\", baz.get(LowerCaseString(\"foo\"))->value().getStringView());\n}\n\n} // namespace Http\n} // namespace Envoy\n", "#include <cstdint>\n#include <string>\n\n#include \"envoy/http/codec.h\"\n#include \"envoy/stats/scope.h\"\n\n#include \"common/http/exception.h\"\n#include \"common/http/header_map_impl.h\"\n#include \"common/http/http2/codec_impl.h\"\n\n#include \"test/common/http/common.h\"\n#include \"test/common/http/http2/http2_frame.h\"\n#include \"test/mocks/http/mocks.h\"\n#include \"test/mocks/network/mocks.h\"\n#include \"test/test_common/printers.h\"\n#include \"test/test_common/test_runtime.h\"\n#include \"test/test_common/utility.h\"\n\n#include \"codec_impl_test_util.h\"\n#include \"gmock/gmock.h\"\n#include \"gtest/gtest.h\"\n\nusing testing::_;\nusing testing::AnyNumber;\nusing testing::AtLeast;\nusing testing::InSequence;\nusing testing::Invoke;\nusing testing::InvokeWithoutArgs;\nusing testing::NiceMock;\nusing testing::Return;\n\nnamespace Envoy {\nnamespace Http {\nnamespace Http2 {\n\nusing Http2SettingsTuple = ::testing::tuple<uint32_t, uint32_t, uint32_t, uint32_t>;\nusing Http2SettingsTestParam = ::testing::tuple<Http2SettingsTuple, Http2SettingsTuple>;\n\nclass Http2CodecImplTestFixture {\npublic:\n  struct ConnectionWrapper {\n    void dispatch(const Buffer::Instance& data, ConnectionImpl& connection) {\n      buffer_.add(data);\n      if (!dispatching_) {\n        while (buffer_.length() > 0) {\n          dispatching_ = true;\n          connection.dispatch(buffer_);\n          dispatching_ = false;\n        }\n      }\n    }\n\n    bool dispatching_{};\n    Buffer::OwnedImpl buffer_;\n  };\n\n  Http2CodecImplTestFixture(Http2SettingsTuple client_settings, Http2SettingsTuple server_settings)\n      : client_settings_(client_settings), server_settings_(server_settings) {}\n  virtual ~Http2CodecImplTestFixture() = default;\n\n  virtual void initialize() {\n    Http2SettingsFromTuple(client_http2settings_, client_settings_);\n    Http2SettingsFromTuple(server_http2settings_, server_settings_);\n    client_ = std::make_unique<TestClientConnectionImpl>(client_connection_, client_callbacks_,\n                                                         stats_store_, client_http2settings_,\n                                                         max_request_headers_kb_);\n    server_ = std::make_unique<TestServerConnectionImpl>(server_connection_, server_callbacks_,\n                                                         stats_store_, server_http2settings_,\n                                                         max_request_headers_kb_);\n\n    request_encoder_ = &client_->newStream(response_decoder_);\n    setupDefaultConnectionMocks();\n\n    EXPECT_CALL(server_callbacks_, newStream(_, _))\n        .WillRepeatedly(Invoke([&](StreamEncoder& encoder, bool) -> StreamDecoder& {\n          response_encoder_ = &encoder;\n          encoder.getStream().addCallbacks(server_stream_callbacks_);\n          return request_decoder_;\n        }));\n  }\n\n  void setupDefaultConnectionMocks() {\n    ON_CALL(client_connection_, write(_, _))\n        .WillByDefault(Invoke([&](Buffer::Instance& data, bool) -> void {\n          if (corrupt_metadata_frame_) {\n            corruptMetadataFramePayload(data);\n          }\n          server_wrapper_.dispatch(data, *server_);\n        }));\n    ON_CALL(server_connection_, write(_, _))\n        .WillByDefault(Invoke([&](Buffer::Instance& data, bool) -> void {\n          client_wrapper_.dispatch(data, *client_);\n        }));\n  }\n\n  void Http2SettingsFromTuple(Http2Settings& setting, const Http2SettingsTuple& tp) {\n    setting.hpack_table_size_ = ::testing::get<0>(tp);\n    setting.max_concurrent_streams_ = ::testing::get<1>(tp);\n    setting.initial_stream_window_size_ = ::testing::get<2>(tp);\n    setting.initial_connection_window_size_ = ::testing::get<3>(tp);\n    setting.allow_metadata_ = allow_metadata_;\n    setting.stream_error_on_invalid_http_messaging_ = stream_error_on_invalid_http_messaging_;\n    setting.max_outbound_frames_ = max_outbound_frames_;\n    setting.max_outbound_control_frames_ = max_outbound_control_frames_;\n    setting.max_consecutive_inbound_frames_with_empty_payload_ =\n        max_consecutive_inbound_frames_with_empty_payload_;\n    setting.max_inbound_priority_frames_per_stream_ = max_inbound_priority_frames_per_stream_;\n    setting.max_inbound_window_update_frames_per_data_frame_sent_ =\n        max_inbound_window_update_frames_per_data_frame_sent_;\n  }\n\n  // corruptMetadataFramePayload assumes data contains at least 10 bytes of the beginning of a\n  // frame.\n  void corruptMetadataFramePayload(Buffer::Instance& data) {\n    const size_t length = data.length();\n    const size_t corrupt_start = 10;\n    if (length < corrupt_start || length > METADATA_MAX_PAYLOAD_SIZE) {\n      ENVOY_LOG_MISC(error, \"data size too big or too small\");\n      return;\n    }\n    corruptAtOffset(data, corrupt_start, 0xff);\n  }\n\n  void corruptAtOffset(Buffer::Instance& data, size_t index, char new_value) {\n    if (data.length() == 0) {\n      return;\n    }\n    reinterpret_cast<uint8_t*>(data.linearize(data.length()))[index % data.length()] = new_value;\n  }\n\n  const Http2SettingsTuple client_settings_;\n  const Http2SettingsTuple server_settings_;\n  bool allow_metadata_ = false;\n  bool stream_error_on_invalid_http_messaging_ = false;\n  Stats::IsolatedStoreImpl stats_store_;\n  Http2Settings client_http2settings_;\n  NiceMock<Network::MockConnection> client_connection_;\n  MockConnectionCallbacks client_callbacks_;\n  std::unique_ptr<TestClientConnectionImpl> client_;\n  ConnectionWrapper client_wrapper_;\n  Http2Settings server_http2settings_;\n  NiceMock<Network::MockConnection> server_connection_;\n  MockServerConnectionCallbacks server_callbacks_;\n  std::unique_ptr<TestServerConnectionImpl> server_;\n  ConnectionWrapper server_wrapper_;\n  MockStreamDecoder response_decoder_;\n  StreamEncoder* request_encoder_;\n  MockStreamDecoder request_decoder_;\n  StreamEncoder* response_encoder_{};\n  MockStreamCallbacks server_stream_callbacks_;\n  // Corrupt a metadata frame payload.\n  bool corrupt_metadata_frame_ = false;\n\n  uint32_t max_request_headers_kb_ = Http::DEFAULT_MAX_REQUEST_HEADERS_KB;\n  uint32_t max_outbound_frames_ = Http2Settings::DEFAULT_MAX_OUTBOUND_FRAMES;\n  uint32_t max_outbound_control_frames_ = Http2Settings::DEFAULT_MAX_OUTBOUND_CONTROL_FRAMES;\n  uint32_t max_consecutive_inbound_frames_with_empty_payload_ =\n      Http2Settings::DEFAULT_MAX_CONSECUTIVE_INBOUND_FRAMES_WITH_EMPTY_PAYLOAD;\n  uint32_t max_inbound_priority_frames_per_stream_ =\n      Http2Settings::DEFAULT_MAX_INBOUND_PRIORITY_FRAMES_PER_STREAM;\n  uint32_t max_inbound_window_update_frames_per_data_frame_sent_ =\n      Http2Settings::DEFAULT_MAX_INBOUND_WINDOW_UPDATE_FRAMES_PER_DATA_FRAME_SENT;\n};\n\nclass Http2CodecImplTest : public ::testing::TestWithParam<Http2SettingsTestParam>,\n                           protected Http2CodecImplTestFixture {\npublic:\n  Http2CodecImplTest()\n      : Http2CodecImplTestFixture(::testing::get<0>(GetParam()), ::testing::get<1>(GetParam())) {}\n\nprotected:\n  void priorityFlood() {\n    initialize();\n\n    TestHeaderMapImpl request_headers;\n    HttpTestUtility::addDefaultHeaders(request_headers, \"POST\");\n    EXPECT_CALL(request_decoder_, decodeHeaders_(_, false));\n    request_encoder_->encodeHeaders(request_headers, false);\n\n    nghttp2_priority_spec spec = {0, 10, 0};\n    // HTTP/2 codec adds 1 to the number of active streams when computing PRIORITY frames limit\n    constexpr uint32_t max_allowed =\n        2 * Http2Settings::DEFAULT_MAX_INBOUND_PRIORITY_FRAMES_PER_STREAM;\n    for (uint32_t i = 0; i < max_allowed + 1; ++i) {\n      EXPECT_EQ(0, nghttp2_submit_priority(client_->session(), NGHTTP2_FLAG_NONE, 1, &spec));\n    }\n  }\n\n  void windowUpdateFlood() {\n    initialize();\n\n    TestHeaderMapImpl request_headers;\n    HttpTestUtility::addDefaultHeaders(request_headers);\n    EXPECT_CALL(request_decoder_, decodeHeaders_(_, true));\n    request_encoder_->encodeHeaders(request_headers, true);\n\n    // Send one DATA frame back\n    EXPECT_CALL(response_decoder_, decodeHeaders_(_, false));\n    EXPECT_CALL(response_decoder_, decodeData(_, false));\n    TestHeaderMapImpl response_headers{{\":status\", \"200\"}};\n    response_encoder_->encodeHeaders(response_headers, false);\n    Buffer::OwnedImpl data(\"0\");\n    EXPECT_NO_THROW(response_encoder_->encodeData(data, false));\n\n    // See the limit formula in the\n    // `Envoy::Http::Http2::ServerConnectionImpl::checkInboundFrameLimits()' method.\n    constexpr uint32_t max_allowed =\n        1 + 2 * (Http2Settings::DEFAULT_MAX_INBOUND_WINDOW_UPDATE_FRAMES_PER_DATA_FRAME_SENT + 1);\n    for (uint32_t i = 0; i < max_allowed + 1; ++i) {\n      EXPECT_EQ(0, nghttp2_submit_window_update(client_->session(), NGHTTP2_FLAG_NONE, 1, 1));\n    }\n  }\n\n  void emptyDataFlood(Buffer::OwnedImpl& data) {\n    initialize();\n\n    TestHeaderMapImpl request_headers;\n    HttpTestUtility::addDefaultHeaders(request_headers, \"POST\");\n    EXPECT_CALL(request_decoder_, decodeHeaders_(_, false));\n    request_encoder_->encodeHeaders(request_headers, false);\n\n    // HTTP/2 codec does not send empty DATA frames with no END_STREAM flag.\n    // To make this work, send raw bytes representing empty DATA frames bypassing client codec.\n    Http2Frame emptyDataFrame = Http2Frame::makeEmptyDataFrame(0);\n    constexpr uint32_t max_allowed =\n        Http2Settings::DEFAULT_MAX_CONSECUTIVE_INBOUND_FRAMES_WITH_EMPTY_PAYLOAD;\n    for (uint32_t i = 0; i < max_allowed + 1; ++i) {\n      data.add(emptyDataFrame.data(), emptyDataFrame.size());\n    }\n  }\n\n  // Make sure the test fixture has a fake runtime, for the tests which use\n  // Runtime::LoaderSingleton::getExisting()->mergeValues(...)\n  TestScopedRuntime scoped_runtime_;\n};\n\nTEST_P(Http2CodecImplTest, ShutdownNotice) {\n  initialize();\n\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  EXPECT_CALL(request_decoder_, decodeHeaders_(_, true));\n  request_encoder_->encodeHeaders(request_headers, true);\n\n  EXPECT_CALL(client_callbacks_, onGoAway());\n  server_->shutdownNotice();\n  server_->goAway();\n\n  TestHeaderMapImpl response_headers{{\":status\", \"200\"}};\n  EXPECT_CALL(response_decoder_, decodeHeaders_(_, true));\n  response_encoder_->encodeHeaders(response_headers, true);\n}\n\nTEST_P(Http2CodecImplTest, ContinueHeaders) {\n  initialize();\n\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  EXPECT_CALL(request_decoder_, decodeHeaders_(_, true));\n  request_encoder_->encodeHeaders(request_headers, true);\n\n  TestHeaderMapImpl continue_headers{{\":status\", \"100\"}};\n  EXPECT_CALL(response_decoder_, decode100ContinueHeaders_(_));\n  response_encoder_->encode100ContinueHeaders(continue_headers);\n\n  TestHeaderMapImpl response_headers{{\":status\", \"200\"}};\n  EXPECT_CALL(response_decoder_, decodeHeaders_(_, true));\n  response_encoder_->encodeHeaders(response_headers, true);\n};\n\nTEST_P(Http2CodecImplTest, InvalidContinueWithFin) {\n  initialize();\n\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  EXPECT_CALL(request_decoder_, decodeHeaders_(_, true));\n  request_encoder_->encodeHeaders(request_headers, true);\n\n  TestHeaderMapImpl continue_headers{{\":status\", \"100\"}};\n  EXPECT_THROW(response_encoder_->encodeHeaders(continue_headers, true), CodecProtocolException);\n  EXPECT_EQ(1, stats_store_.counter(\"http2.rx_messaging_error\").value());\n}\n\nTEST_P(Http2CodecImplTest, InvalidContinueWithFinAllowed) {\n  stream_error_on_invalid_http_messaging_ = true;\n  initialize();\n\n  MockStreamCallbacks request_callbacks;\n  request_encoder_->getStream().addCallbacks(request_callbacks);\n\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  EXPECT_CALL(request_decoder_, decodeHeaders_(_, true));\n  request_encoder_->encodeHeaders(request_headers, true);\n\n  // Buffer client data to avoid mock recursion causing lifetime issues.\n  ON_CALL(server_connection_, write(_, _))\n      .WillByDefault(\n          Invoke([&](Buffer::Instance& data, bool) -> void { client_wrapper_.buffer_.add(data); }));\n\n  TestHeaderMapImpl continue_headers{{\":status\", \"100\"}};\n  response_encoder_->encodeHeaders(continue_headers, true);\n\n  // Flush pending data.\n  EXPECT_CALL(request_callbacks, onResetStream(StreamResetReason::LocalReset, _));\n  setupDefaultConnectionMocks();\n  client_wrapper_.dispatch(Buffer::OwnedImpl(), *client_);\n\n  EXPECT_EQ(1, stats_store_.counter(\"http2.rx_messaging_error\").value());\n}\n\nTEST_P(Http2CodecImplTest, InvalidRepeatContinue) {\n  initialize();\n\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  EXPECT_CALL(request_decoder_, decodeHeaders_(_, true));\n  request_encoder_->encodeHeaders(request_headers, true);\n\n  TestHeaderMapImpl continue_headers{{\":status\", \"100\"}};\n  EXPECT_CALL(response_decoder_, decode100ContinueHeaders_(_));\n  response_encoder_->encode100ContinueHeaders(continue_headers);\n\n  EXPECT_THROW(response_encoder_->encodeHeaders(continue_headers, true), CodecProtocolException);\n  EXPECT_EQ(1, stats_store_.counter(\"http2.rx_messaging_error\").value());\n};\n\nTEST_P(Http2CodecImplTest, InvalidRepeatContinueAllowed) {\n  stream_error_on_invalid_http_messaging_ = true;\n  initialize();\n\n  MockStreamCallbacks request_callbacks;\n  request_encoder_->getStream().addCallbacks(request_callbacks);\n\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  EXPECT_CALL(request_decoder_, decodeHeaders_(_, true));\n  request_encoder_->encodeHeaders(request_headers, true);\n\n  TestHeaderMapImpl continue_headers{{\":status\", \"100\"}};\n  EXPECT_CALL(response_decoder_, decode100ContinueHeaders_(_));\n  response_encoder_->encode100ContinueHeaders(continue_headers);\n\n  // Buffer client data to avoid mock recursion causing lifetime issues.\n  ON_CALL(server_connection_, write(_, _))\n      .WillByDefault(\n          Invoke([&](Buffer::Instance& data, bool) -> void { client_wrapper_.buffer_.add(data); }));\n\n  response_encoder_->encodeHeaders(continue_headers, true);\n\n  // Flush pending data.\n  EXPECT_CALL(request_callbacks, onResetStream(StreamResetReason::LocalReset, _));\n  setupDefaultConnectionMocks();\n  client_wrapper_.dispatch(Buffer::OwnedImpl(), *client_);\n\n  EXPECT_EQ(1, stats_store_.counter(\"http2.rx_messaging_error\").value());\n};\n\nTEST_P(Http2CodecImplTest, Invalid103) {\n  initialize();\n\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  EXPECT_CALL(request_decoder_, decodeHeaders_(_, true));\n  request_encoder_->encodeHeaders(request_headers, true);\n\n  TestHeaderMapImpl continue_headers{{\":status\", \"100\"}};\n  EXPECT_CALL(response_decoder_, decode100ContinueHeaders_(_));\n  response_encoder_->encode100ContinueHeaders(continue_headers);\n\n  TestHeaderMapImpl early_hint_headers{{\":status\", \"103\"}};\n  EXPECT_CALL(response_decoder_, decodeHeaders_(_, false));\n  response_encoder_->encodeHeaders(early_hint_headers, false);\n\n  EXPECT_THROW_WITH_MESSAGE(response_encoder_->encodeHeaders(early_hint_headers, false),\n                            CodecProtocolException, \"Unexpected 'trailers' with no end stream.\");\n  EXPECT_EQ(1, stats_store_.counter(\"http2.too_many_header_frames\").value());\n}\n\nTEST_P(Http2CodecImplTest, Invalid204WithContentLength) {\n  initialize();\n\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  EXPECT_CALL(request_decoder_, decodeHeaders_(_, true));\n  request_encoder_->encodeHeaders(request_headers, true);\n\n  TestHeaderMapImpl response_headers{{\":status\", \"204\"}, {\"content-length\", \"3\"}};\n  // What follows is a hack to get headers that should span into continuation frames. The default\n  // maximum frame size is 16K. We will add 3,000 headers that will take us above this size and\n  // not easily compress with HPACK. (I confirmed this generates 26,468 bytes of header data\n  // which should contain a continuation.)\n  for (uint i = 1; i < 3000; i++) {\n    response_headers.addCopy(std::to_string(i), std::to_string(i));\n  }\n\n  EXPECT_THROW(response_encoder_->encodeHeaders(response_headers, false), CodecProtocolException);\n  EXPECT_EQ(1, stats_store_.counter(\"http2.rx_messaging_error\").value());\n};\n\nTEST_P(Http2CodecImplTest, Invalid204WithContentLengthAllowed) {\n  stream_error_on_invalid_http_messaging_ = true;\n  initialize();\n\n  MockStreamCallbacks request_callbacks;\n  request_encoder_->getStream().addCallbacks(request_callbacks);\n\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  EXPECT_CALL(request_decoder_, decodeHeaders_(_, true));\n  request_encoder_->encodeHeaders(request_headers, true);\n\n  // Buffer client data to avoid mock recursion causing lifetime issues.\n  ON_CALL(server_connection_, write(_, _))\n      .WillByDefault(\n          Invoke([&](Buffer::Instance& data, bool) -> void { client_wrapper_.buffer_.add(data); }));\n\n  TestHeaderMapImpl response_headers{{\":status\", \"204\"}, {\"content-length\", \"3\"}};\n  // What follows is a hack to get headers that should span into continuation frames. The default\n  // maximum frame size is 16K. We will add 3,000 headers that will take us above this size and\n  // not easily compress with HPACK. (I confirmed this generates 26,468 bytes of header data\n  // which should contain a continuation.)\n  for (uint i = 1; i < 3000; i++) {\n    response_headers.addCopy(std::to_string(i), std::to_string(i));\n  }\n\n  response_encoder_->encodeHeaders(response_headers, false);\n\n  // Flush pending data.\n  EXPECT_CALL(request_callbacks, onResetStream(StreamResetReason::LocalReset, _));\n  EXPECT_CALL(server_stream_callbacks_, onResetStream(StreamResetReason::RemoteReset, _));\n  setupDefaultConnectionMocks();\n  client_wrapper_.dispatch(Buffer::OwnedImpl(), *client_);\n\n  EXPECT_EQ(1, stats_store_.counter(\"http2.rx_messaging_error\").value());\n};\n\nTEST_P(Http2CodecImplTest, RefusedStreamReset) {\n  initialize();\n\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  EXPECT_CALL(request_decoder_, decodeHeaders_(_, false));\n  request_encoder_->encodeHeaders(request_headers, false);\n\n  MockStreamCallbacks callbacks;\n  request_encoder_->getStream().addCallbacks(callbacks);\n  EXPECT_CALL(server_stream_callbacks_,\n              onResetStream(StreamResetReason::LocalRefusedStreamReset, _));\n  EXPECT_CALL(callbacks, onResetStream(StreamResetReason::RemoteRefusedStreamReset, _));\n  response_encoder_->getStream().resetStream(StreamResetReason::LocalRefusedStreamReset);\n}\n\nTEST_P(Http2CodecImplTest, InvalidHeadersFrame) {\n  initialize();\n\n  EXPECT_THROW(request_encoder_->encodeHeaders(TestHeaderMapImpl{}, true), CodecProtocolException);\n  EXPECT_EQ(1, stats_store_.counter(\"http2.rx_messaging_error\").value());\n}\n\nTEST_P(Http2CodecImplTest, InvalidHeadersFrameAllowed) {\n  stream_error_on_invalid_http_messaging_ = true;\n  initialize();\n\n  MockStreamCallbacks request_callbacks;\n  request_encoder_->getStream().addCallbacks(request_callbacks);\n\n  ON_CALL(client_connection_, write(_, _))\n      .WillByDefault(\n          Invoke([&](Buffer::Instance& data, bool) -> void { server_wrapper_.buffer_.add(data); }));\n\n  request_encoder_->encodeHeaders(TestHeaderMapImpl{}, true);\n  EXPECT_CALL(server_stream_callbacks_, onResetStream(StreamResetReason::LocalReset, _));\n  EXPECT_CALL(request_callbacks, onResetStream(StreamResetReason::RemoteReset, _));\n  server_wrapper_.dispatch(Buffer::OwnedImpl(), *server_);\n}\n\nTEST_P(Http2CodecImplTest, InvalidHeadersFrameOverriden) {\n  Runtime::LoaderSingleton::getExisting()->mergeValues(\n      {{\"envoy.reloadable_features.http2_protocol_options.stream_error_on_invalid_http_messaging\",\n        \"true\"}});\n  initialize();\n\n  MockStreamCallbacks request_callbacks;\n  request_encoder_->getStream().addCallbacks(request_callbacks);\n\n  ON_CALL(client_connection_, write(_, _))\n      .WillByDefault(\n          Invoke([&](Buffer::Instance& data, bool) -> void { server_wrapper_.buffer_.add(data); }));\n\n  request_encoder_->encodeHeaders(TestHeaderMapImpl{}, true);\n  EXPECT_CALL(server_stream_callbacks_, onResetStream(StreamResetReason::LocalReset, _));\n  EXPECT_CALL(request_callbacks, onResetStream(StreamResetReason::RemoteReset, _));\n  server_wrapper_.dispatch(Buffer::OwnedImpl(), *server_);\n}\n\nTEST_P(Http2CodecImplTest, TrailingHeaders) {\n  initialize();\n\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  EXPECT_CALL(request_decoder_, decodeHeaders_(_, false));\n  request_encoder_->encodeHeaders(request_headers, false);\n  EXPECT_CALL(request_decoder_, decodeData(_, false));\n  Buffer::OwnedImpl hello(\"hello\");\n  request_encoder_->encodeData(hello, false);\n  EXPECT_CALL(request_decoder_, decodeTrailers_(_));\n  request_encoder_->encodeTrailers(TestHeaderMapImpl{{\"trailing\", \"header\"}});\n\n  TestHeaderMapImpl response_headers{{\":status\", \"200\"}};\n  EXPECT_CALL(response_decoder_, decodeHeaders_(_, false));\n  response_encoder_->encodeHeaders(response_headers, false);\n  EXPECT_CALL(response_decoder_, decodeData(_, false));\n  Buffer::OwnedImpl world(\"world\");\n  response_encoder_->encodeData(world, false);\n  EXPECT_CALL(response_decoder_, decodeTrailers_(_));\n  response_encoder_->encodeTrailers(TestHeaderMapImpl{{\"trailing\", \"header\"}});\n}\n\nTEST_P(Http2CodecImplTest, TrailingHeadersLargeBody) {\n  initialize();\n\n  // Buffer server data so we can make sure we don't get any window updates.\n  ON_CALL(client_connection_, write(_, _))\n      .WillByDefault(\n          Invoke([&](Buffer::Instance& data, bool) -> void { server_wrapper_.buffer_.add(data); }));\n\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  EXPECT_CALL(request_decoder_, decodeHeaders_(_, false));\n  request_encoder_->encodeHeaders(request_headers, false);\n  EXPECT_CALL(request_decoder_, decodeData(_, false)).Times(AtLeast(1));\n  Buffer::OwnedImpl body(std::string(1024 * 1024, 'a'));\n  request_encoder_->encodeData(body, false);\n  EXPECT_CALL(request_decoder_, decodeTrailers_(_));\n  request_encoder_->encodeTrailers(TestHeaderMapImpl{{\"trailing\", \"header\"}});\n\n  // Flush pending data.\n  setupDefaultConnectionMocks();\n  server_wrapper_.dispatch(Buffer::OwnedImpl(), *server_);\n\n  TestHeaderMapImpl response_headers{{\":status\", \"200\"}};\n  EXPECT_CALL(response_decoder_, decodeHeaders_(_, false));\n  response_encoder_->encodeHeaders(response_headers, false);\n  EXPECT_CALL(response_decoder_, decodeData(_, false));\n  Buffer::OwnedImpl world(\"world\");\n  response_encoder_->encodeData(world, false);\n  EXPECT_CALL(response_decoder_, decodeTrailers_(_));\n  response_encoder_->encodeTrailers(TestHeaderMapImpl{{\"trailing\", \"header\"}});\n}\n\nTEST_P(Http2CodecImplTest, SmallMetadataVecTest) {\n  allow_metadata_ = true;\n  initialize();\n\n  // Generates a valid stream_id by sending a request header.\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  EXPECT_CALL(request_decoder_, decodeHeaders_(_, true));\n  request_encoder_->encodeHeaders(request_headers, true);\n\n  MetadataMapVector metadata_map_vector;\n  const int size = 10;\n  for (int i = 0; i < size; i++) {\n    MetadataMap metadata_map = {\n        {\"header_key1\", \"header_value1\"},\n        {\"header_key2\", \"header_value2\"},\n        {\"header_key3\", \"header_value3\"},\n        {\"header_key4\", \"header_value4\"},\n    };\n    MetadataMapPtr metadata_map_ptr = std::make_unique<MetadataMap>(metadata_map);\n    metadata_map_vector.push_back(std::move(metadata_map_ptr));\n  }\n\n  EXPECT_CALL(request_decoder_, decodeMetadata_(_)).Times(size);\n  request_encoder_->encodeMetadata(metadata_map_vector);\n\n  EXPECT_CALL(response_decoder_, decodeMetadata_(_)).Times(size);\n  response_encoder_->encodeMetadata(metadata_map_vector);\n}\n\nTEST_P(Http2CodecImplTest, LargeMetadataVecTest) {\n  allow_metadata_ = true;\n  initialize();\n\n  // Generates a valid stream_id by sending a request header.\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  EXPECT_CALL(request_decoder_, decodeHeaders_(_, true));\n  request_encoder_->encodeHeaders(request_headers, true);\n\n  MetadataMapVector metadata_map_vector;\n  const int size = 10;\n  for (int i = 0; i < size; i++) {\n    MetadataMap metadata_map = {\n        {\"header_key1\", std::string(50 * 1024, 'a')},\n    };\n    MetadataMapPtr metadata_map_ptr = std::make_unique<MetadataMap>(metadata_map);\n    metadata_map_vector.push_back(std::move(metadata_map_ptr));\n  }\n\n  EXPECT_CALL(request_decoder_, decodeMetadata_(_)).Times(size);\n  request_encoder_->encodeMetadata(metadata_map_vector);\n\n  EXPECT_CALL(response_decoder_, decodeMetadata_(_)).Times(size);\n  response_encoder_->encodeMetadata(metadata_map_vector);\n}\n\nTEST_P(Http2CodecImplTest, BadMetadataVecReceivedTest) {\n  allow_metadata_ = true;\n  initialize();\n\n  // Generates a valid stream_id by sending a request header.\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  EXPECT_CALL(request_decoder_, decodeHeaders_(_, true));\n  request_encoder_->encodeHeaders(request_headers, true);\n\n  MetadataMap metadata_map = {\n      {\"header_key1\", \"header_value1\"},\n      {\"header_key2\", \"header_value2\"},\n      {\"header_key3\", \"header_value3\"},\n      {\"header_key4\", \"header_value4\"},\n  };\n  MetadataMapPtr metadata_map_ptr = std::make_unique<MetadataMap>(metadata_map);\n  MetadataMapVector metadata_map_vector;\n  metadata_map_vector.push_back(std::move(metadata_map_ptr));\n\n  corrupt_metadata_frame_ = true;\n  EXPECT_THROW_WITH_MESSAGE(request_encoder_->encodeMetadata(metadata_map_vector), EnvoyException,\n                            \"The user callback function failed\");\n}\nclass Http2CodecImplDeferredResetTest : public Http2CodecImplTest {};\n\nTEST_P(Http2CodecImplDeferredResetTest, DeferredResetClient) {\n  initialize();\n\n  InSequence s;\n\n  MockStreamCallbacks client_stream_callbacks;\n  request_encoder_->getStream().addCallbacks(client_stream_callbacks);\n\n  // Do a request, but pause server dispatch so we don't send window updates. This will result in a\n  // deferred reset, followed by a pending frames flush which will cause the stream to actually\n  // be reset immediately since we are outside of dispatch context.\n  ON_CALL(client_connection_, write(_, _))\n      .WillByDefault(\n          Invoke([&](Buffer::Instance& data, bool) -> void { server_wrapper_.buffer_.add(data); }));\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  request_encoder_->encodeHeaders(request_headers, false);\n  Buffer::OwnedImpl body(std::string(1024 * 1024, 'a'));\n  EXPECT_CALL(client_stream_callbacks, onAboveWriteBufferHighWatermark()).Times(AnyNumber());\n  request_encoder_->encodeData(body, true);\n  EXPECT_CALL(client_stream_callbacks, onResetStream(StreamResetReason::LocalReset, _));\n  request_encoder_->getStream().resetStream(StreamResetReason::LocalReset);\n\n  // Dispatch server. We expect to see some data.\n  EXPECT_CALL(response_decoder_, decodeHeaders_(_, _)).Times(0);\n  EXPECT_CALL(request_decoder_, decodeHeaders_(_, false)).WillOnce(InvokeWithoutArgs([&]() -> void {\n    // Start a response inside the headers callback. This should not result in the client\n    // seeing any headers as the stream should already be reset on the other side, even though\n    // we don't know about it yet.\n    TestHeaderMapImpl response_headers{{\":status\", \"200\"}};\n    response_encoder_->encodeHeaders(response_headers, false);\n  }));\n  EXPECT_CALL(request_decoder_, decodeData(_, false)).Times(AtLeast(1));\n  EXPECT_CALL(server_stream_callbacks_, onResetStream(StreamResetReason::RemoteReset, _));\n\n  setupDefaultConnectionMocks();\n  server_wrapper_.dispatch(Buffer::OwnedImpl(), *server_);\n}\n\nTEST_P(Http2CodecImplDeferredResetTest, DeferredResetServer) {\n  initialize();\n\n  InSequence s;\n\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  EXPECT_CALL(request_decoder_, decodeHeaders_(_, false));\n  request_encoder_->encodeHeaders(request_headers, false);\n\n  // In this case we do the same thing as DeferredResetClient but on the server side.\n  ON_CALL(server_connection_, write(_, _))\n      .WillByDefault(\n          Invoke([&](Buffer::Instance& data, bool) -> void { client_wrapper_.buffer_.add(data); }));\n  TestHeaderMapImpl response_headers{{\":status\", \"200\"}};\n  response_encoder_->encodeHeaders(response_headers, false);\n  Buffer::OwnedImpl body(std::string(1024 * 1024, 'a'));\n  EXPECT_CALL(server_stream_callbacks_, onAboveWriteBufferHighWatermark()).Times(AnyNumber());\n  response_encoder_->encodeData(body, true);\n  EXPECT_CALL(server_stream_callbacks_, onResetStream(StreamResetReason::LocalReset, _));\n  response_encoder_->getStream().resetStream(StreamResetReason::LocalReset);\n\n  MockStreamCallbacks client_stream_callbacks;\n  request_encoder_->getStream().addCallbacks(client_stream_callbacks);\n  EXPECT_CALL(response_decoder_, decodeHeaders_(_, false));\n  EXPECT_CALL(response_decoder_, decodeData(_, false)).Times(AtLeast(1));\n  EXPECT_CALL(client_stream_callbacks, onResetStream(StreamResetReason::RemoteReset, _));\n  setupDefaultConnectionMocks();\n  client_wrapper_.dispatch(Buffer::OwnedImpl(), *client_);\n}\n\nclass Http2CodecImplFlowControlTest : public Http2CodecImplTest {};\n\n// Back up the pending_sent_data_ buffer in the client connection and make sure the watermarks fire\n// as expected.\n//\n// This also tests the readDisable logic in StreamImpl, verifying that h2 bytes are consumed\n// when the stream has readDisable(true) called.\nTEST_P(Http2CodecImplFlowControlTest, TestFlowControlInPendingSendData) {\n  initialize();\n  MockStreamCallbacks callbacks;\n  request_encoder_->getStream().addCallbacks(callbacks);\n\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  TestHeaderMapImpl expected_headers;\n  HttpTestUtility::addDefaultHeaders(expected_headers);\n  EXPECT_CALL(request_decoder_, decodeHeaders_(HeaderMapEqual(&expected_headers), false));\n  request_encoder_->encodeHeaders(request_headers, false);\n\n  // Force the server stream to be read disabled. This will cause it to stop sending window\n  // updates to the client.\n  server_->getStream(1)->readDisable(true);\n\n  uint32_t initial_stream_window =\n      nghttp2_session_get_stream_effective_local_window_size(client_->session(), 1);\n  // If this limit is changed, this test will fail due to the initial large writes being divided\n  // into more than 4 frames. Fast fail here with this explanatory comment.\n  ASSERT_EQ(65535, initial_stream_window);\n  // Make sure the limits were configured properly in test set up.\n  EXPECT_EQ(initial_stream_window, server_->getStream(1)->bufferLimit());\n  EXPECT_EQ(initial_stream_window, client_->getStream(1)->bufferLimit());\n\n  // One large write gets broken into smaller frames.\n  EXPECT_CALL(request_decoder_, decodeData(_, false)).Times(AnyNumber());\n  Buffer::OwnedImpl long_data(std::string(initial_stream_window, 'a'));\n  request_encoder_->encodeData(long_data, false);\n\n  // Verify that the window is full. The client will not send more data to the server for this\n  // stream.\n  EXPECT_EQ(0, nghttp2_session_get_stream_local_window_size(server_->session(), 1));\n  EXPECT_EQ(0, nghttp2_session_get_stream_remote_window_size(client_->session(), 1));\n  EXPECT_EQ(initial_stream_window, server_->getStream(1)->unconsumed_bytes_);\n\n  // Now that the flow control window is full, further data causes the send buffer to back up.\n  Buffer::OwnedImpl more_long_data(std::string(initial_stream_window, 'a'));\n  request_encoder_->encodeData(more_long_data, false);\n  EXPECT_EQ(initial_stream_window, client_->getStream(1)->pending_send_data_.length());\n  EXPECT_EQ(initial_stream_window, server_->getStream(1)->unconsumed_bytes_);\n\n  // If we go over the limit, the stream callbacks should fire.\n  EXPECT_CALL(callbacks, onAboveWriteBufferHighWatermark());\n  Buffer::OwnedImpl last_byte(\"!\");\n  request_encoder_->encodeData(last_byte, false);\n  EXPECT_EQ(initial_stream_window + 1, client_->getStream(1)->pending_send_data_.length());\n\n  // Now create a second stream on the connection.\n  MockStreamDecoder response_decoder2;\n  StreamEncoder* request_encoder2 = &client_->newStream(response_decoder_);\n  StreamEncoder* response_encoder2;\n  MockStreamCallbacks server_stream_callbacks2;\n  MockStreamDecoder request_decoder2;\n  // When the server stream is created it should check the status of the\n  // underlying connection. Pretend it is overrun.\n  EXPECT_CALL(server_connection_, aboveHighWatermark()).WillOnce(Return(true));\n  EXPECT_CALL(server_stream_callbacks2, onAboveWriteBufferHighWatermark());\n  EXPECT_CALL(server_callbacks_, newStream(_, _))\n      .WillOnce(Invoke([&](StreamEncoder& encoder, bool) -> StreamDecoder& {\n        response_encoder2 = &encoder;\n        encoder.getStream().addCallbacks(server_stream_callbacks2);\n        return request_decoder2;\n      }));\n  EXPECT_CALL(request_decoder2, decodeHeaders_(_, false));\n  request_encoder2->encodeHeaders(request_headers, false);\n\n  // Add the stream callbacks belatedly. On creation the stream should have\n  // been noticed that the connection was backed up. Any new subscriber to\n  // stream callbacks should get a callback when they addCallbacks.\n  MockStreamCallbacks callbacks2;\n  EXPECT_CALL(callbacks2, onAboveWriteBufferHighWatermark());\n  request_encoder_->getStream().addCallbacks(callbacks2);\n\n  // Add a third callback to make testing removal mid-watermark call below more interesting.\n  MockStreamCallbacks callbacks3;\n  EXPECT_CALL(callbacks3, onAboveWriteBufferHighWatermark());\n  request_encoder_->getStream().addCallbacks(callbacks3);\n\n  // Now unblock the server's stream. This will cause the bytes to be consumed, flow control\n  // updates to be sent, and the client to flush all queued data.\n  // For bonus corner case coverage, remove callback2 in the middle of runLowWatermarkCallbacks()\n  // and ensure it is not called.\n  EXPECT_CALL(callbacks, onBelowWriteBufferLowWatermark()).WillOnce(Invoke([&]() -> void {\n    request_encoder_->getStream().removeCallbacks(callbacks2);\n  }));\n  EXPECT_CALL(callbacks2, onBelowWriteBufferLowWatermark()).Times(0);\n  EXPECT_CALL(callbacks3, onBelowWriteBufferLowWatermark());\n  server_->getStream(1)->readDisable(false);\n  EXPECT_EQ(0, client_->getStream(1)->pending_send_data_.length());\n  // The extra 1 byte sent won't trigger another window update, so the final window should be the\n  // initial window minus the last 1 byte flush from the client to server.\n  EXPECT_EQ(initial_stream_window - 1,\n            nghttp2_session_get_stream_local_window_size(server_->session(), 1));\n  EXPECT_EQ(initial_stream_window - 1,\n            nghttp2_session_get_stream_remote_window_size(client_->session(), 1));\n}\n\n// Set up the same asTestFlowControlInPendingSendData, but tears the stream down with an early reset\n// once the flow control window is full up.\nTEST_P(Http2CodecImplFlowControlTest, EarlyResetRestoresWindow) {\n  initialize();\n  MockStreamCallbacks callbacks;\n  request_encoder_->getStream().addCallbacks(callbacks);\n\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  TestHeaderMapImpl expected_headers;\n  HttpTestUtility::addDefaultHeaders(expected_headers);\n  EXPECT_CALL(request_decoder_, decodeHeaders_(HeaderMapEqual(&expected_headers), false));\n  request_encoder_->encodeHeaders(request_headers, false);\n\n  // Force the server stream to be read disabled. This will cause it to stop sending window\n  // updates to the client.\n  server_->getStream(1)->readDisable(true);\n\n  uint32_t initial_stream_window =\n      nghttp2_session_get_stream_effective_local_window_size(client_->session(), 1);\n  uint32_t initial_connection_window = nghttp2_session_get_remote_window_size(client_->session());\n  // If this limit is changed, this test will fail due to the initial large writes being divided\n  // into more than 4 frames. Fast fail here with this explanatory comment.\n  ASSERT_EQ(65535, initial_stream_window);\n  // One large write may get broken into smaller frames.\n  EXPECT_CALL(request_decoder_, decodeData(_, false)).Times(AnyNumber());\n  Buffer::OwnedImpl long_data(std::string(initial_stream_window, 'a'));\n  // The one giant write will cause the buffer to go over the limit, then drain and go back under\n  // the limit.\n  request_encoder_->encodeData(long_data, false);\n\n  // Verify that the window is full. The client will not send more data to the server for this\n  // stream.\n  EXPECT_EQ(0, nghttp2_session_get_stream_local_window_size(server_->session(), 1));\n  EXPECT_EQ(0, nghttp2_session_get_stream_remote_window_size(client_->session(), 1));\n  EXPECT_EQ(initial_stream_window, server_->getStream(1)->unconsumed_bytes_);\n  EXPECT_GT(initial_connection_window, nghttp2_session_get_remote_window_size(client_->session()));\n\n  EXPECT_CALL(server_stream_callbacks_,\n              onResetStream(StreamResetReason::LocalRefusedStreamReset, _));\n  EXPECT_CALL(callbacks, onAboveWriteBufferHighWatermark()).Times(0);\n  EXPECT_CALL(callbacks, onBelowWriteBufferLowWatermark()).Times(0);\n  EXPECT_CALL(server_stream_callbacks_, onAboveWriteBufferHighWatermark()).Times(0);\n  EXPECT_CALL(server_stream_callbacks_, onBelowWriteBufferLowWatermark()).Times(0);\n  EXPECT_CALL(callbacks, onResetStream(StreamResetReason::RemoteRefusedStreamReset, _))\n      .WillOnce(Invoke([&](StreamResetReason, absl::string_view) -> void {\n        // Test the case where the reset callbacks cause the socket to fill up,\n        // causing the underlying connection to back up. Given the stream is\n        // being destroyed the watermark callbacks should not fire (mocks for Times(0)\n        // above)\n        client_->onUnderlyingConnectionAboveWriteBufferHighWatermark();\n        client_->onUnderlyingConnectionBelowWriteBufferLowWatermark();\n        server_->onUnderlyingConnectionAboveWriteBufferHighWatermark();\n        server_->onUnderlyingConnectionBelowWriteBufferLowWatermark();\n      }));\n  response_encoder_->getStream().resetStream(StreamResetReason::LocalRefusedStreamReset);\n\n  // Regression test that the window is consumed even if the stream is destroyed early.\n  EXPECT_EQ(initial_connection_window, nghttp2_session_get_remote_window_size(client_->session()));\n}\n\n// Test the HTTP2 pending_recv_data_ buffer going over and under watermark limits.\nTEST_P(Http2CodecImplFlowControlTest, FlowControlPendingRecvData) {\n  initialize();\n  MockStreamCallbacks callbacks;\n\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  TestHeaderMapImpl expected_headers;\n  HttpTestUtility::addDefaultHeaders(expected_headers);\n  EXPECT_CALL(request_decoder_, decodeHeaders_(HeaderMapEqual(&expected_headers), false));\n  request_encoder_->encodeHeaders(request_headers, false);\n\n  // Set artificially small watermarks to make the recv buffer easy to overrun. In production,\n  // the recv buffer can be overrun by a client which negotiates a larger\n  // SETTINGS_MAX_FRAME_SIZE but there's no current easy way to tweak that in\n  // envoy (without sending raw HTTP/2 frames) so we lower the buffer limit instead.\n  server_->getStream(1)->setWriteBufferWatermarks(10, 20);\n\n  EXPECT_CALL(request_decoder_, decodeData(_, false));\n  Buffer::OwnedImpl data(std::string(40, 'a'));\n  request_encoder_->encodeData(data, false);\n}\n\nTEST_P(Http2CodecImplTest, WatermarkUnderEndStream) {\n  initialize();\n  MockStreamCallbacks callbacks;\n  request_encoder_->getStream().addCallbacks(callbacks);\n\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  EXPECT_CALL(request_decoder_, decodeHeaders_(_, false));\n  request_encoder_->encodeHeaders(request_headers, false);\n\n  // The 'true' on encodeData will set local_end_stream_ on the client but not\n  // the server. Verify that client watermark callbacks will not be called, but\n  // server callbacks may be called by simulating connection overflow on both\n  // ends.\n  EXPECT_CALL(callbacks, onAboveWriteBufferHighWatermark()).Times(0);\n  EXPECT_CALL(callbacks, onBelowWriteBufferLowWatermark()).Times(0);\n  EXPECT_CALL(server_stream_callbacks_, onAboveWriteBufferHighWatermark());\n  EXPECT_CALL(server_stream_callbacks_, onBelowWriteBufferLowWatermark());\n  EXPECT_CALL(request_decoder_, decodeData(_, true)).WillOnce(InvokeWithoutArgs([&]() -> void {\n    client_->onUnderlyingConnectionAboveWriteBufferHighWatermark();\n    client_->onUnderlyingConnectionBelowWriteBufferLowWatermark();\n    server_->onUnderlyingConnectionAboveWriteBufferHighWatermark();\n    server_->onUnderlyingConnectionBelowWriteBufferLowWatermark();\n  }));\n  Buffer::OwnedImpl hello(\"hello\");\n  request_encoder_->encodeData(hello, true);\n\n  // The 'true' on encodeData will set local_end_stream_ on the server. Verify\n  // that neither client nor server watermark callbacks will be called again.\n  EXPECT_CALL(callbacks, onAboveWriteBufferHighWatermark()).Times(0);\n  EXPECT_CALL(callbacks, onBelowWriteBufferLowWatermark()).Times(0);\n  EXPECT_CALL(server_stream_callbacks_, onAboveWriteBufferHighWatermark()).Times(0);\n  EXPECT_CALL(server_stream_callbacks_, onBelowWriteBufferLowWatermark()).Times(0);\n  TestHeaderMapImpl response_headers{{\":status\", \"200\"}};\n  EXPECT_CALL(response_decoder_, decodeHeaders_(HeaderMapEqual(&response_headers), true))\n      .WillOnce(InvokeWithoutArgs([&]() -> void {\n        client_->onUnderlyingConnectionAboveWriteBufferHighWatermark();\n        client_->onUnderlyingConnectionBelowWriteBufferLowWatermark();\n        server_->onUnderlyingConnectionAboveWriteBufferHighWatermark();\n        server_->onUnderlyingConnectionBelowWriteBufferLowWatermark();\n      }));\n  response_encoder_->encodeHeaders(response_headers, true);\n}\n\nclass Http2CodecImplStreamLimitTest : public Http2CodecImplTest {};\n\n// Regression test for issue #3076.\n//\n// TODO(PiotrSikora): add tests that exercise both scenarios: before and after receiving\n// the HTTP/2 SETTINGS frame.\nTEST_P(Http2CodecImplStreamLimitTest, MaxClientStreams) {\n  Http2SettingsFromTuple(client_http2settings_, ::testing::get<0>(GetParam()));\n  Http2SettingsFromTuple(server_http2settings_, ::testing::get<1>(GetParam()));\n  client_ = std::make_unique<TestClientConnectionImpl>(client_connection_, client_callbacks_,\n                                                       stats_store_, client_http2settings_,\n                                                       max_request_headers_kb_);\n  server_ = std::make_unique<TestServerConnectionImpl>(server_connection_, server_callbacks_,\n                                                       stats_store_, server_http2settings_,\n                                                       max_request_headers_kb_);\n\n  for (int i = 0; i < 101; ++i) {\n    request_encoder_ = &client_->newStream(response_decoder_);\n    setupDefaultConnectionMocks();\n    EXPECT_CALL(server_callbacks_, newStream(_, _))\n        .WillOnce(Invoke([&](StreamEncoder& encoder, bool) -> StreamDecoder& {\n          response_encoder_ = &encoder;\n          encoder.getStream().addCallbacks(server_stream_callbacks_);\n          return request_decoder_;\n        }));\n\n    TestHeaderMapImpl request_headers;\n    HttpTestUtility::addDefaultHeaders(request_headers);\n    EXPECT_CALL(request_decoder_, decodeHeaders_(_, true));\n    request_encoder_->encodeHeaders(request_headers, true);\n  }\n}\n\n#define HTTP2SETTINGS_SMALL_WINDOW_COMBINE                                                         \\\n  ::testing::Combine(::testing::Values(Http2Settings::DEFAULT_HPACK_TABLE_SIZE),                   \\\n                     ::testing::Values(Http2Settings::DEFAULT_MAX_CONCURRENT_STREAMS),             \\\n                     ::testing::Values(Http2Settings::MIN_INITIAL_STREAM_WINDOW_SIZE),             \\\n                     ::testing::Values(Http2Settings::MIN_INITIAL_CONNECTION_WINDOW_SIZE))\n\n// Deferred reset tests use only small windows so that we can test certain conditions.\nINSTANTIATE_TEST_SUITE_P(Http2CodecImplDeferredResetTest, Http2CodecImplDeferredResetTest,\n                         ::testing::Combine(HTTP2SETTINGS_SMALL_WINDOW_COMBINE,\n                                            HTTP2SETTINGS_SMALL_WINDOW_COMBINE));\n\n// Flow control tests only use only small windows so that we can test certain conditions.\nINSTANTIATE_TEST_SUITE_P(Http2CodecImplFlowControlTest, Http2CodecImplFlowControlTest,\n                         ::testing::Combine(HTTP2SETTINGS_SMALL_WINDOW_COMBINE,\n                                            HTTP2SETTINGS_SMALL_WINDOW_COMBINE));\n\n// we separate default/edge cases here to avoid combinatorial explosion\n#define HTTP2SETTINGS_DEFAULT_COMBINE                                                              \\\n  ::testing::Combine(::testing::Values(Http2Settings::DEFAULT_HPACK_TABLE_SIZE),                   \\\n                     ::testing::Values(Http2Settings::DEFAULT_MAX_CONCURRENT_STREAMS),             \\\n                     ::testing::Values(Http2Settings::DEFAULT_INITIAL_STREAM_WINDOW_SIZE),         \\\n                     ::testing::Values(Http2Settings::DEFAULT_INITIAL_CONNECTION_WINDOW_SIZE))\n\n// Stream limit test only uses the default values because not all combinations of\n// edge settings allow for the number of streams needed by the test.\nINSTANTIATE_TEST_SUITE_P(Http2CodecImplStreamLimitTest, Http2CodecImplStreamLimitTest,\n                         ::testing::Combine(HTTP2SETTINGS_DEFAULT_COMBINE,\n                                            HTTP2SETTINGS_DEFAULT_COMBINE));\n\nINSTANTIATE_TEST_SUITE_P(Http2CodecImplTestDefaultSettings, Http2CodecImplTest,\n                         ::testing::Combine(HTTP2SETTINGS_DEFAULT_COMBINE,\n                                            HTTP2SETTINGS_DEFAULT_COMBINE));\n\n#define HTTP2SETTINGS_EDGE_COMBINE                                                                 \\\n  ::testing::Combine(                                                                              \\\n      ::testing::Values(Http2Settings::MIN_HPACK_TABLE_SIZE, Http2Settings::MAX_HPACK_TABLE_SIZE), \\\n      ::testing::Values(Http2Settings::MIN_MAX_CONCURRENT_STREAMS,                                 \\\n                        Http2Settings::MAX_MAX_CONCURRENT_STREAMS),                                \\\n      ::testing::Values(Http2Settings::MIN_INITIAL_STREAM_WINDOW_SIZE,                             \\\n                        Http2Settings::MAX_INITIAL_STREAM_WINDOW_SIZE),                            \\\n      ::testing::Values(Http2Settings::MIN_INITIAL_CONNECTION_WINDOW_SIZE,                         \\\n                        Http2Settings::MAX_INITIAL_CONNECTION_WINDOW_SIZE))\n\n// Make sure we have coverage for high and low values for various  combinations and permutations\n// of HTTP settings in at least one test fixture.\n// Use with caution as any test using this runs 255 times.\nusing Http2CodecImplTestAll = Http2CodecImplTest;\n\nINSTANTIATE_TEST_SUITE_P(Http2CodecImplTestDefaultSettings, Http2CodecImplTestAll,\n                         ::testing::Combine(HTTP2SETTINGS_DEFAULT_COMBINE,\n                                            HTTP2SETTINGS_DEFAULT_COMBINE));\nINSTANTIATE_TEST_SUITE_P(Http2CodecImplTestEdgeSettings, Http2CodecImplTestAll,\n                         ::testing::Combine(HTTP2SETTINGS_EDGE_COMBINE,\n                                            HTTP2SETTINGS_EDGE_COMBINE));\n\nTEST(Http2CodecUtility, reconstituteCrumbledCookies) {\n  {\n    HeaderString key;\n    HeaderString value;\n    HeaderString cookies;\n    EXPECT_FALSE(Utility::reconstituteCrumbledCookies(key, value, cookies));\n    EXPECT_TRUE(cookies.empty());\n  }\n\n  {\n    HeaderString key(Headers::get().ContentLength);\n    HeaderString value;\n    value.setInteger(5);\n    HeaderString cookies;\n    EXPECT_FALSE(Utility::reconstituteCrumbledCookies(key, value, cookies));\n    EXPECT_TRUE(cookies.empty());\n  }\n\n  {\n    HeaderString key(Headers::get().Cookie);\n    HeaderString value;\n    value.setCopy(\"a=b\", 3);\n    HeaderString cookies;\n    EXPECT_TRUE(Utility::reconstituteCrumbledCookies(key, value, cookies));\n    EXPECT_EQ(cookies, \"a=b\");\n\n    HeaderString key2(Headers::get().Cookie);\n    HeaderString value2;\n    value2.setCopy(\"c=d\", 3);\n    EXPECT_TRUE(Utility::reconstituteCrumbledCookies(key2, value2, cookies));\n    EXPECT_EQ(cookies, \"a=b; c=d\");\n  }\n}\n\nTEST_P(Http2CodecImplTest, TestLargeRequestHeadersInvokeResetStream) {\n  initialize();\n\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  std::string long_string = std::string(63 * 1024, 'q');\n  request_headers.addCopy(\"big\", long_string);\n  EXPECT_CALL(server_stream_callbacks_, onResetStream(_, _)).Times(1);\n  request_encoder_->encodeHeaders(request_headers, false);\n}\n\nTEST_P(Http2CodecImplTest, TestLargeRequestHeadersAccepted) {\n  max_request_headers_kb_ = 64;\n  initialize();\n\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  std::string long_string = std::string(63 * 1024, 'q');\n  request_headers.addCopy(\"big\", long_string);\n\n  EXPECT_CALL(request_decoder_, decodeHeaders_(_, _));\n  EXPECT_CALL(server_stream_callbacks_, onResetStream(_, _)).Times(0);\n  request_encoder_->encodeHeaders(request_headers, false);\n}\n\nTEST_P(Http2CodecImplTest, TestLargeRequestHeadersAtLimitAccepted) {\n  uint32_t codec_limit_kb = 64;\n  max_request_headers_kb_ = codec_limit_kb;\n  initialize();\n\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  // Refresh byte size after adding default inline headers by reference.\n  request_headers.refreshByteSize();\n  std::string key = \"big\";\n  uint32_t head_room = 77;\n  uint32_t long_string_length =\n      codec_limit_kb * 1024 - request_headers.byteSize().value() - key.length() - head_room;\n  std::string long_string = std::string(long_string_length, 'q');\n  request_headers.addCopy(key, long_string);\n\n  // The amount of data sent to the codec is not equivalent to the size of the\n  // request headers that Envoy computes, as the codec limits based on the\n  // entire http2 frame. The exact head room needed (76) was found through iteration.\n  ASSERT_EQ(request_headers.byteSize().value() + head_room, codec_limit_kb * 1024);\n\n  EXPECT_CALL(request_decoder_, decodeHeaders_(_, _));\n  request_encoder_->encodeHeaders(request_headers, true);\n}\n\nTEST_P(Http2CodecImplTest, TestLargeRequestHeadersOverDefaultCodecLibraryLimit) {\n  max_request_headers_kb_ = 66;\n  initialize();\n\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  std::string long_string = std::string(65 * 1024, 'q');\n  request_headers.addCopy(\"big\", long_string);\n\n  EXPECT_CALL(request_decoder_, decodeHeaders_(_, _)).Times(1);\n  EXPECT_CALL(server_stream_callbacks_, onResetStream(_, _)).Times(0);\n  request_encoder_->encodeHeaders(request_headers, true);\n}\n\nTEST_P(Http2CodecImplTest, TestLargeRequestHeadersExceedPerHeaderLimit) {\n  // The name-value pair max is set by NGHTTP2_HD_MAX_NV in lib/nghttp2_hd.h to 64KB, and\n  // creates a per-request header limit for us in h2. Note that the nghttp2\n  // calculated byte size will differ from envoy due to H2 compression and frames.\n\n  max_request_headers_kb_ = 81;\n  initialize();\n\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  std::string long_string = std::string(80 * 1024, 'q');\n  request_headers.addCopy(\"big\", long_string);\n\n  EXPECT_CALL(request_decoder_, decodeHeaders_(_, _)).Times(0);\n  EXPECT_CALL(client_callbacks_, onGoAway());\n  server_->shutdownNotice();\n  server_->goAway();\n  request_encoder_->encodeHeaders(request_headers, true);\n}\n\nTEST_P(Http2CodecImplTest, TestManyLargeRequestHeadersUnderPerHeaderLimit) {\n  max_request_headers_kb_ = 81;\n  initialize();\n\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  std::string long_string = std::string(1024, 'q');\n  for (int i = 0; i < 80; i++) {\n    request_headers.addCopy(fmt::format(\"{}\", i), long_string);\n  }\n\n  EXPECT_CALL(request_decoder_, decodeHeaders_(_, _)).Times(1);\n  EXPECT_CALL(server_stream_callbacks_, onResetStream(_, _)).Times(0);\n  request_encoder_->encodeHeaders(request_headers, true);\n}\n\nTEST_P(Http2CodecImplTest, TestLargeRequestHeadersAtMaxConfigurable) {\n  // Raising the limit past this triggers some unexpected nghttp2 error.\n  // Further debugging required to increase past ~96 KiB.\n  max_request_headers_kb_ = 96;\n  initialize();\n\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  std::string long_string = std::string(1024, 'q');\n  for (int i = 0; i < 95; i++) {\n    request_headers.addCopy(fmt::format(\"{}\", i), long_string);\n  }\n\n  EXPECT_CALL(request_decoder_, decodeHeaders_(_, _)).Times(1);\n  EXPECT_CALL(server_stream_callbacks_, onResetStream(_, _)).Times(0);\n  request_encoder_->encodeHeaders(request_headers, true);\n}\n\n// Note this is Http2CodecImplTestAll not Http2CodecImplTest, to test\n// compression with min and max HPACK table size.\nTEST_P(Http2CodecImplTestAll, TestCodecHeaderCompression) {\n  initialize();\n\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  EXPECT_CALL(request_decoder_, decodeHeaders_(_, true));\n  request_encoder_->encodeHeaders(request_headers, true);\n\n  TestHeaderMapImpl response_headers{{\":status\", \"200\"}, {\"compression\", \"test\"}};\n  EXPECT_CALL(response_decoder_, decodeHeaders_(_, true));\n  response_encoder_->encodeHeaders(response_headers, true);\n\n  // Sanity check to verify that state of encoders and decoders matches.\n  EXPECT_EQ(nghttp2_session_get_hd_deflate_dynamic_table_size(server_->session()),\n            nghttp2_session_get_hd_inflate_dynamic_table_size(client_->session()));\n  EXPECT_EQ(nghttp2_session_get_hd_deflate_dynamic_table_size(client_->session()),\n            nghttp2_session_get_hd_inflate_dynamic_table_size(server_->session()));\n\n  // Verify that headers are compressed only when both client and server advertise table size > 0:\n  if (client_http2settings_.hpack_table_size_ && server_http2settings_.hpack_table_size_) {\n    EXPECT_NE(0, nghttp2_session_get_hd_deflate_dynamic_table_size(client_->session()));\n    EXPECT_NE(0, nghttp2_session_get_hd_deflate_dynamic_table_size(server_->session()));\n  } else {\n    EXPECT_EQ(0, nghttp2_session_get_hd_deflate_dynamic_table_size(client_->session()));\n    EXPECT_EQ(0, nghttp2_session_get_hd_deflate_dynamic_table_size(server_->session()));\n  }\n}\n\n// Verify that codec detects PING flood\nTEST_P(Http2CodecImplTest, PingFlood) {\n  initialize();\n\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  EXPECT_CALL(request_decoder_, decodeHeaders_(_, false));\n  request_encoder_->encodeHeaders(request_headers, false);\n\n  // Send one frame above the outbound control queue size limit\n  for (uint32_t i = 0; i < Http2Settings::DEFAULT_MAX_OUTBOUND_CONTROL_FRAMES + 1; ++i) {\n    EXPECT_EQ(0, nghttp2_submit_ping(client_->session(), NGHTTP2_FLAG_NONE, nullptr));\n  }\n\n  int ack_count = 0;\n  Buffer::OwnedImpl buffer;\n  ON_CALL(server_connection_, write(_, _))\n      .WillByDefault(Invoke([&buffer, &ack_count](Buffer::Instance& frame, bool) {\n        ++ack_count;\n        buffer.move(frame);\n      }));\n\n  EXPECT_THROW(client_->sendPendingFrames(), FrameFloodException);\n  EXPECT_EQ(ack_count, Http2Settings::DEFAULT_MAX_OUTBOUND_CONTROL_FRAMES);\n  EXPECT_EQ(1, stats_store_.counter(\"http2.outbound_control_flood\").value());\n}\n\n// Verify that codec allows PING flood when mitigation is disabled\nTEST_P(Http2CodecImplTest, PingFloodMitigationDisabled) {\n  Runtime::LoaderSingleton::getExisting()->mergeValues(\n      {{\"envoy.reloadable_features.http2_protocol_options.max_outbound_control_frames\",\n        \"2147483647\"}});\n  initialize();\n\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  EXPECT_CALL(request_decoder_, decodeHeaders_(_, false));\n  request_encoder_->encodeHeaders(request_headers, false);\n\n  // Send one frame above the outbound control queue size limit\n  for (uint32_t i = 0; i < Http2Settings::DEFAULT_MAX_OUTBOUND_CONTROL_FRAMES + 1; ++i) {\n    EXPECT_EQ(0, nghttp2_submit_ping(client_->session(), NGHTTP2_FLAG_NONE, nullptr));\n  }\n\n  EXPECT_CALL(server_connection_, write(_, _))\n      .Times(Http2Settings::DEFAULT_MAX_OUTBOUND_CONTROL_FRAMES + 1);\n  EXPECT_NO_THROW(client_->sendPendingFrames());\n}\n\n// Verify that outbound control frame counter decreases when send buffer is drained\nTEST_P(Http2CodecImplTest, PingFloodCounterReset) {\n  static const int kMaxOutboundControlFrames = 100;\n  max_outbound_control_frames_ = kMaxOutboundControlFrames;\n  initialize();\n\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  EXPECT_CALL(request_decoder_, decodeHeaders_(_, false));\n  request_encoder_->encodeHeaders(request_headers, false);\n\n  for (int i = 0; i < kMaxOutboundControlFrames; ++i) {\n    EXPECT_EQ(0, nghttp2_submit_ping(client_->session(), NGHTTP2_FLAG_NONE, nullptr));\n  }\n\n  int ack_count = 0;\n  Buffer::OwnedImpl buffer;\n  ON_CALL(server_connection_, write(_, _))\n      .WillByDefault(Invoke([&buffer, &ack_count](Buffer::Instance& frame, bool) {\n        ++ack_count;\n        buffer.move(frame);\n      }));\n\n  // We should be 1 frame under the control frame flood mitigation threshold.\n  EXPECT_NO_THROW(client_->sendPendingFrames());\n  EXPECT_EQ(ack_count, kMaxOutboundControlFrames);\n\n  // Drain kMaxOutboundFrames / 2 slices from the send buffer\n  buffer.drain(buffer.length() / 2);\n\n  // Send kMaxOutboundFrames / 2 more pings.\n  for (int i = 0; i < kMaxOutboundControlFrames / 2; ++i) {\n    EXPECT_EQ(0, nghttp2_submit_ping(client_->session(), NGHTTP2_FLAG_NONE, nullptr));\n  }\n  // The number of outbound frames should be half of max so the connection should not be terminated.\n  EXPECT_NO_THROW(client_->sendPendingFrames());\n\n  // 1 more ping frame should overflow the outbound frame limit.\n  EXPECT_EQ(0, nghttp2_submit_ping(client_->session(), NGHTTP2_FLAG_NONE, nullptr));\n  EXPECT_THROW(client_->sendPendingFrames(), FrameFloodException);\n}\n\n// Verify that codec detects flood of outbound HEADER frames\nTEST_P(Http2CodecImplTest, ResponseHeadersFlood) {\n  initialize();\n\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  EXPECT_CALL(request_decoder_, decodeHeaders_(_, false));\n  request_encoder_->encodeHeaders(request_headers, false);\n\n  int frame_count = 0;\n  Buffer::OwnedImpl buffer;\n  ON_CALL(server_connection_, write(_, _))\n      .WillByDefault(Invoke([&buffer, &frame_count](Buffer::Instance& frame, bool) {\n        ++frame_count;\n        buffer.move(frame);\n      }));\n\n  TestHeaderMapImpl response_headers{{\":status\", \"200\"}};\n  for (uint32_t i = 0; i < Http2Settings::DEFAULT_MAX_OUTBOUND_FRAMES + 1; ++i) {\n    EXPECT_NO_THROW(response_encoder_->encodeHeaders(response_headers, false));\n  }\n  // Presently flood mitigation is done only when processing downstream data\n  // So we need to send stream from downstream client to trigger mitigation\n  EXPECT_EQ(0, nghttp2_submit_ping(client_->session(), NGHTTP2_FLAG_NONE, nullptr));\n  EXPECT_THROW(client_->sendPendingFrames(), FrameFloodException);\n\n  EXPECT_EQ(frame_count, Http2Settings::DEFAULT_MAX_OUTBOUND_FRAMES + 1);\n  EXPECT_EQ(1, stats_store_.counter(\"http2.outbound_flood\").value());\n}\n\n// Verify that codec detects flood of outbound DATA frames\nTEST_P(Http2CodecImplTest, ResponseDataFlood) {\n  initialize();\n\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  EXPECT_CALL(request_decoder_, decodeHeaders_(_, false));\n  request_encoder_->encodeHeaders(request_headers, false);\n\n  int frame_count = 0;\n  Buffer::OwnedImpl buffer;\n  ON_CALL(server_connection_, write(_, _))\n      .WillByDefault(Invoke([&buffer, &frame_count](Buffer::Instance& frame, bool) {\n        ++frame_count;\n        buffer.move(frame);\n      }));\n\n  TestHeaderMapImpl response_headers{{\":status\", \"200\"}};\n  response_encoder_->encodeHeaders(response_headers, false);\n  // Account for the single HEADERS frame above\n  for (uint32_t i = 0; i < Http2Settings::DEFAULT_MAX_OUTBOUND_FRAMES; ++i) {\n    Buffer::OwnedImpl data(\"0\");\n    EXPECT_NO_THROW(response_encoder_->encodeData(data, false));\n  }\n  // Presently flood mitigation is done only when processing downstream data\n  // So we need to send stream from downstream client to trigger mitigation\n  EXPECT_EQ(0, nghttp2_submit_ping(client_->session(), NGHTTP2_FLAG_NONE, nullptr));\n  EXPECT_THROW(client_->sendPendingFrames(), FrameFloodException);\n\n  EXPECT_EQ(frame_count, Http2Settings::DEFAULT_MAX_OUTBOUND_FRAMES + 1);\n  EXPECT_EQ(1, stats_store_.counter(\"http2.outbound_flood\").value());\n}\n\n// Verify that codec allows outbound DATA flood when mitigation is disabled\nTEST_P(Http2CodecImplTest, ResponseDataFloodMitigationDisabled) {\n  Runtime::LoaderSingleton::getExisting()->mergeValues(\n      {{\"envoy.reloadable_features.http2_protocol_options.max_outbound_frames\", \"2147483647\"}});\n  initialize();\n\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  EXPECT_CALL(request_decoder_, decodeHeaders_(_, false));\n  request_encoder_->encodeHeaders(request_headers, false);\n\n  // +2 is to account for HEADERS and PING ACK, that is used to trigger mitigation\n  EXPECT_CALL(server_connection_, write(_, _))\n      .Times(Http2Settings::DEFAULT_MAX_OUTBOUND_FRAMES + 2);\n  EXPECT_CALL(response_decoder_, decodeHeaders_(_, false)).Times(1);\n  EXPECT_CALL(response_decoder_, decodeData(_, false))\n      .Times(Http2Settings::DEFAULT_MAX_OUTBOUND_FRAMES);\n  TestHeaderMapImpl response_headers{{\":status\", \"200\"}};\n  response_encoder_->encodeHeaders(response_headers, false);\n  // Account for the single HEADERS frame above\n  for (uint32_t i = 0; i < Http2Settings::DEFAULT_MAX_OUTBOUND_FRAMES; ++i) {\n    Buffer::OwnedImpl data(\"0\");\n    EXPECT_NO_THROW(response_encoder_->encodeData(data, false));\n  }\n  // Presently flood mitigation is done only when processing downstream data\n  // So we need to send stream from downstream client to trigger mitigation\n  EXPECT_EQ(0, nghttp2_submit_ping(client_->session(), NGHTTP2_FLAG_NONE, nullptr));\n  EXPECT_NO_THROW(client_->sendPendingFrames());\n}\n\n// Verify that outbound frame counter decreases when send buffer is drained\nTEST_P(Http2CodecImplTest, ResponseDataFloodCounterReset) {\n  static const int kMaxOutboundFrames = 100;\n  max_outbound_frames_ = kMaxOutboundFrames;\n  initialize();\n\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  EXPECT_CALL(request_decoder_, decodeHeaders_(_, false));\n  request_encoder_->encodeHeaders(request_headers, false);\n\n  int frame_count = 0;\n  Buffer::OwnedImpl buffer;\n  ON_CALL(server_connection_, write(_, _))\n      .WillByDefault(Invoke([&buffer, &frame_count](Buffer::Instance& frame, bool) {\n        ++frame_count;\n        buffer.move(frame);\n      }));\n\n  TestHeaderMapImpl response_headers{{\":status\", \"200\"}};\n  response_encoder_->encodeHeaders(response_headers, false);\n  // Account for the single HEADERS frame above\n  for (uint32_t i = 0; i < kMaxOutboundFrames - 1; ++i) {\n    Buffer::OwnedImpl data(\"0\");\n    EXPECT_NO_THROW(response_encoder_->encodeData(data, false));\n  }\n\n  EXPECT_EQ(frame_count, kMaxOutboundFrames);\n  // Drain kMaxOutboundFrames / 2 slices from the send buffer\n  buffer.drain(buffer.length() / 2);\n\n  for (uint32_t i = 0; i < kMaxOutboundFrames / 2 + 1; ++i) {\n    Buffer::OwnedImpl data(\"0\");\n    EXPECT_NO_THROW(response_encoder_->encodeData(data, false));\n  }\n\n  // Presently flood mitigation is done only when processing downstream data\n  // So we need to send a frame from downstream client to trigger mitigation\n  EXPECT_EQ(0, nghttp2_submit_ping(client_->session(), NGHTTP2_FLAG_NONE, nullptr));\n  EXPECT_THROW(client_->sendPendingFrames(), FrameFloodException);\n}\n\n// Verify that control frames are added to the counter of outbound frames of all types.\nTEST_P(Http2CodecImplTest, PingStacksWithDataFlood) {\n  initialize();\n\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  EXPECT_CALL(request_decoder_, decodeHeaders_(_, false));\n  request_encoder_->encodeHeaders(request_headers, false);\n\n  int frame_count = 0;\n  Buffer::OwnedImpl buffer;\n  ON_CALL(server_connection_, write(_, _))\n      .WillByDefault(Invoke([&buffer, &frame_count](Buffer::Instance& frame, bool) {\n        ++frame_count;\n        buffer.move(frame);\n      }));\n\n  TestHeaderMapImpl response_headers{{\":status\", \"200\"}};\n  response_encoder_->encodeHeaders(response_headers, false);\n  // Account for the single HEADERS frame above\n  for (uint32_t i = 0; i < Http2Settings::DEFAULT_MAX_OUTBOUND_FRAMES - 1; ++i) {\n    Buffer::OwnedImpl data(\"0\");\n    EXPECT_NO_THROW(response_encoder_->encodeData(data, false));\n  }\n  // Send one PING frame above the outbound queue size limit\n  EXPECT_EQ(0, nghttp2_submit_ping(client_->session(), NGHTTP2_FLAG_NONE, nullptr));\n  EXPECT_THROW(client_->sendPendingFrames(), FrameFloodException);\n\n  EXPECT_EQ(frame_count, Http2Settings::DEFAULT_MAX_OUTBOUND_FRAMES);\n  EXPECT_EQ(1, stats_store_.counter(\"http2.outbound_flood\").value());\n}\n\nTEST_P(Http2CodecImplTest, PriorityFlood) {\n  priorityFlood();\n  EXPECT_THROW(client_->sendPendingFrames(), FrameFloodException);\n}\n\nTEST_P(Http2CodecImplTest, PriorityFloodOverride) {\n  Runtime::LoaderSingleton::getExisting()->mergeValues(\n      {{\"envoy.reloadable_features.http2_protocol_options.max_inbound_priority_frames_per_stream\",\n        \"2147483647\"}});\n\n  priorityFlood();\n  EXPECT_NO_THROW(client_->sendPendingFrames());\n}\n\nTEST_P(Http2CodecImplTest, WindowUpdateFlood) {\n  windowUpdateFlood();\n  EXPECT_THROW(client_->sendPendingFrames(), FrameFloodException);\n}\n\nTEST_P(Http2CodecImplTest, WindowUpdateFloodOverride) {\n  Runtime::LoaderSingleton::getExisting()->mergeValues(\n      {{\"envoy.reloadable_features.http2_protocol_options.max_inbound_window_update_frames_per_\"\n        \"data_frame_sent\",\n        \"2147483647\"}});\n  windowUpdateFlood();\n  EXPECT_NO_THROW(client_->sendPendingFrames());\n}\n\nTEST_P(Http2CodecImplTest, EmptyDataFlood) {\n  Buffer::OwnedImpl data;\n  emptyDataFlood(data);\n  EXPECT_CALL(request_decoder_, decodeData(_, false));\n  EXPECT_THROW(server_wrapper_.dispatch(data, *server_), FrameFloodException);\n}\n\nTEST_P(Http2CodecImplTest, EmptyDataFloodOverride) {\n  Runtime::LoaderSingleton::getExisting()->mergeValues(\n      {{\"envoy.reloadable_features.http2_protocol_options.max_consecutive_inbound_frames_with_\"\n        \"empty_payload\",\n        \"2147483647\"}});\n  Buffer::OwnedImpl data;\n  emptyDataFlood(data);\n  EXPECT_CALL(request_decoder_, decodeData(_, false))\n      .Times(Http2Settings::DEFAULT_MAX_CONSECUTIVE_INBOUND_FRAMES_WITH_EMPTY_PAYLOAD + 1);\n  EXPECT_NO_THROW(server_wrapper_.dispatch(data, *server_));\n}\n\n} // namespace Http2\n} // namespace Http\n} // namespace Envoy\n", "#include \"test/integration/http2_integration_test.h\"\n\n#include <algorithm>\n#include <string>\n\n#include \"common/buffer/buffer_impl.h\"\n#include \"common/http/header_map_impl.h\"\n\n#include \"test/integration/utility.h\"\n#include \"test/mocks/http/mocks.h\"\n#include \"test/test_common/network_utility.h\"\n#include \"test/test_common/printers.h\"\n#include \"test/test_common/utility.h\"\n\n#include \"gtest/gtest.h\"\n\nusing ::testing::HasSubstr;\nusing ::testing::MatchesRegex;\n\nnamespace Envoy {\n\nINSTANTIATE_TEST_SUITE_P(IpVersions, Http2IntegrationTest,\n                         testing::ValuesIn(TestEnvironment::getIpVersionsForTest()),\n                         TestUtility::ipTestParamsToString);\n\nTEST_P(Http2IntegrationTest, RouterRequestAndResponseWithBodyNoBuffer) {\n  testRouterRequestAndResponseWithBody(1024, 512, false);\n}\n\nTEST_P(Http2IntegrationTest, FlowControlOnAndGiantBody) {\n  config_helper_.setBufferLimits(1024, 1024); // Set buffer limits upstream and downstream.\n  testRouterRequestAndResponseWithBody(1024 * 1024, 1024 * 1024, false);\n}\n\nTEST_P(Http2IntegrationTest, RouterHeaderOnlyRequestAndResponseNoBuffer) {\n  testRouterHeaderOnlyRequestAndResponse();\n}\n\nTEST_P(Http2IntegrationTest, RouterRequestAndResponseLargeHeaderNoBuffer) {\n  testRouterRequestAndResponseWithBody(1024, 512, true);\n}\n\nTEST_P(Http2IntegrationTest, RouterUpstreamDisconnectBeforeRequestcomplete) {\n  testRouterUpstreamDisconnectBeforeRequestComplete();\n}\n\nTEST_P(Http2IntegrationTest, RouterUpstreamDisconnectBeforeResponseComplete) {\n  testRouterUpstreamDisconnectBeforeResponseComplete();\n}\n\nTEST_P(Http2IntegrationTest, RouterDownstreamDisconnectBeforeRequestComplete) {\n  testRouterDownstreamDisconnectBeforeRequestComplete();\n}\n\nTEST_P(Http2IntegrationTest, RouterDownstreamDisconnectBeforeResponseComplete) {\n  testRouterDownstreamDisconnectBeforeResponseComplete();\n}\n\nTEST_P(Http2IntegrationTest, RouterUpstreamResponseBeforeRequestComplete) {\n  testRouterUpstreamResponseBeforeRequestComplete();\n}\n\nTEST_P(Http2IntegrationTest, Retry) { testRetry(); }\n\nTEST_P(Http2IntegrationTest, RetryAttemptCount) { testRetryAttemptCountHeader(); }\n\nTEST_P(Http2IntegrationTest, LargeRequestTrailersRejected) { testLargeRequestTrailers(66, 60); }\n\nstatic std::string response_metadata_filter = R\"EOF(\nname: response-metadata-filter\nconfig: {}\n)EOF\";\n\n// Verifies metadata can be sent at different locations of the responses.\nTEST_P(Http2MetadataIntegrationTest, ProxyMetadataInResponse) {\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  // Sends the first request.\n  auto response = codec_client_->makeRequestWithBody(default_request_headers_, 10);\n  waitForNextUpstreamRequest();\n\n  // Sends metadata before response header.\n  const std::string key = \"key\";\n  std::string value = std::string(80 * 1024, '1');\n  Http::MetadataMap metadata_map = {{key, value}};\n  Http::MetadataMapPtr metadata_map_ptr = std::make_unique<Http::MetadataMap>(metadata_map);\n  Http::MetadataMapVector metadata_map_vector;\n  metadata_map_vector.push_back(std::move(metadata_map_ptr));\n  upstream_request_->encodeMetadata(metadata_map_vector);\n  upstream_request_->encodeHeaders(default_response_headers_, false);\n  upstream_request_->encodeData(12, true);\n\n  // Verifies metadata is received by the client.\n  response->waitForEndStream();\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(response->metadata_map().find(key)->second, value);\n\n  // Sends the second request.\n  response = codec_client_->makeRequestWithBody(default_request_headers_, 10);\n  waitForNextUpstreamRequest();\n\n  // Sends metadata after response header followed by an empty data frame with end_stream true.\n  value = std::string(10, '2');\n  upstream_request_->encodeHeaders(default_response_headers_, false);\n  metadata_map = {{key, value}};\n  metadata_map_ptr = std::make_unique<Http::MetadataMap>(metadata_map);\n  metadata_map_vector.erase(metadata_map_vector.begin());\n  metadata_map_vector.push_back(std::move(metadata_map_ptr));\n  upstream_request_->encodeMetadata(metadata_map_vector);\n  upstream_request_->encodeData(0, true);\n\n  // Verifies metadata is received by the client.\n  response->waitForEndStream();\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(response->metadata_map().find(key)->second, value);\n\n  // Sends the third request.\n  response = codec_client_->makeRequestWithBody(default_request_headers_, 10);\n  waitForNextUpstreamRequest();\n\n  // Sends metadata after response header and before data.\n  value = std::string(10, '3');\n  upstream_request_->encodeHeaders(default_response_headers_, false);\n  metadata_map = {{key, value}};\n  metadata_map_ptr = std::make_unique<Http::MetadataMap>(metadata_map);\n  metadata_map_vector.erase(metadata_map_vector.begin());\n  metadata_map_vector.push_back(std::move(metadata_map_ptr));\n  upstream_request_->encodeMetadata(metadata_map_vector);\n  upstream_request_->encodeData(10, true);\n\n  // Verifies metadata is received by the client.\n  response->waitForEndStream();\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(response->metadata_map().find(key)->second, value);\n\n  // Sends the fourth request.\n  response = codec_client_->makeRequestWithBody(default_request_headers_, 10);\n  waitForNextUpstreamRequest();\n\n  // Sends metadata between data frames.\n  value = std::string(10, '4');\n  upstream_request_->encodeHeaders(default_response_headers_, false);\n  upstream_request_->encodeData(10, false);\n  metadata_map = {{key, value}};\n  metadata_map_ptr = std::make_unique<Http::MetadataMap>(metadata_map);\n  metadata_map_vector.erase(metadata_map_vector.begin());\n  metadata_map_vector.push_back(std::move(metadata_map_ptr));\n  upstream_request_->encodeMetadata(metadata_map_vector);\n  upstream_request_->encodeData(10, true);\n\n  // Verifies metadata is received by the client.\n  response->waitForEndStream();\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(response->metadata_map().find(key)->second, value);\n\n  // Sends the fifth request.\n  response = codec_client_->makeRequestWithBody(default_request_headers_, 10);\n  waitForNextUpstreamRequest();\n\n  // Sends metadata after the last non-empty data frames.\n  value = std::string(10, '5');\n  upstream_request_->encodeHeaders(default_response_headers_, false);\n  upstream_request_->encodeData(10, false);\n  metadata_map = {{key, value}};\n  metadata_map_ptr = std::make_unique<Http::MetadataMap>(metadata_map);\n  metadata_map_vector.erase(metadata_map_vector.begin());\n  metadata_map_vector.push_back(std::move(metadata_map_ptr));\n  upstream_request_->encodeMetadata(metadata_map_vector);\n  upstream_request_->encodeData(0, true);\n\n  // Verifies metadata is received by the client.\n  response->waitForEndStream();\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(response->metadata_map().find(key)->second, value);\n\n  // Sends the sixth request.\n  response = codec_client_->makeRequestWithBody(default_request_headers_, 10);\n  waitForNextUpstreamRequest();\n\n  // Sends metadata before reset.\n  value = std::string(10, '6');\n  upstream_request_->encodeHeaders(default_response_headers_, false);\n  upstream_request_->encodeData(10, false);\n  metadata_map = {{key, value}};\n  metadata_map_ptr = std::make_unique<Http::MetadataMap>(metadata_map);\n  metadata_map_vector.erase(metadata_map_vector.begin());\n  metadata_map_vector.push_back(std::move(metadata_map_ptr));\n  upstream_request_->encodeMetadata(metadata_map_vector);\n  upstream_request_->encodeResetStream();\n\n  // Verifies stream is reset.\n  response->waitForReset();\n  ASSERT_FALSE(response->complete());\n}\n\nTEST_P(Http2MetadataIntegrationTest, ProxyMultipleMetadata) {\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  // Sends a request.\n  auto response = codec_client_->makeRequestWithBody(default_request_headers_, 10);\n  waitForNextUpstreamRequest();\n\n  const int size = 4;\n  std::vector<Http::MetadataMapVector> multiple_vecs(size);\n  for (int i = 0; i < size; i++) {\n    Runtime::RandomGeneratorImpl random;\n    int value_size = random.random() % Http::METADATA_MAX_PAYLOAD_SIZE + 1;\n    Http::MetadataMap metadata_map = {{std::string(i, 'a'), std::string(value_size, 'b')}};\n    Http::MetadataMapPtr metadata_map_ptr = std::make_unique<Http::MetadataMap>(metadata_map);\n    multiple_vecs[i].push_back(std::move(metadata_map_ptr));\n  }\n  upstream_request_->encodeMetadata(multiple_vecs[0]);\n  upstream_request_->encodeHeaders(default_response_headers_, false);\n  upstream_request_->encodeMetadata(multiple_vecs[1]);\n  upstream_request_->encodeData(12, false);\n  upstream_request_->encodeMetadata(multiple_vecs[2]);\n  upstream_request_->encodeData(12, false);\n  upstream_request_->encodeMetadata(multiple_vecs[3]);\n  upstream_request_->encodeData(12, true);\n\n  // Verifies multiple metadata are received by the client.\n  response->waitForEndStream();\n  ASSERT_TRUE(response->complete());\n  for (int i = 0; i < size; i++) {\n    for (const auto& metadata : *multiple_vecs[i][0]) {\n      EXPECT_EQ(response->metadata_map().find(metadata.first)->second, metadata.second);\n    }\n  }\n  EXPECT_EQ(response->metadata_map().size(), multiple_vecs.size());\n}\n\nTEST_P(Http2MetadataIntegrationTest, ProxyInvalidMetadata) {\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  // Sends a request.\n  auto response = codec_client_->makeRequestWithBody(default_request_headers_, 10);\n  waitForNextUpstreamRequest();\n\n  // Sends over-sized metadata before response header.\n  const std::string key = \"key\";\n  std::string value = std::string(1024 * 1024, 'a');\n  Http::MetadataMap metadata_map = {{key, value}};\n  Http::MetadataMapPtr metadata_map_ptr = std::make_unique<Http::MetadataMap>(metadata_map);\n  Http::MetadataMapVector metadata_map_vector;\n  metadata_map_vector.push_back(std::move(metadata_map_ptr));\n  upstream_request_->encodeMetadata(metadata_map_vector);\n  upstream_request_->encodeHeaders(default_response_headers_, false);\n  upstream_request_->encodeMetadata(metadata_map_vector);\n  upstream_request_->encodeData(12, false);\n  upstream_request_->encodeMetadata(metadata_map_vector);\n  upstream_request_->encodeData(12, true);\n\n  // Verifies metadata is not received by the client.\n  response->waitForEndStream();\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(response->metadata_map().size(), 0);\n}\n\nvoid verifyExpectedMetadata(Http::MetadataMap metadata_map, std::set<std::string> keys) {\n  for (const auto& key : keys) {\n    // keys are the same as their corresponding values.\n    EXPECT_EQ(metadata_map.find(key)->second, key);\n  }\n  EXPECT_EQ(metadata_map.size(), keys.size());\n}\n\nTEST_P(Http2MetadataIntegrationTest, TestResponseMetadata) {\n  addFilters({response_metadata_filter});\n  config_helper_.addConfigModifier(\n      [&](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager& hcm)\n          -> void { hcm.set_proxy_100_continue(true); });\n\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  // Upstream responds with headers.\n  auto response = codec_client_->makeRequestWithBody(default_request_headers_, 10);\n  waitForNextUpstreamRequest();\n  upstream_request_->encodeHeaders(default_response_headers_, true);\n\n  response->waitForEndStream();\n  ASSERT_TRUE(response->complete());\n  std::set<std::string> expected_metadata_keys = {\"headers\", \"duplicate\"};\n  verifyExpectedMetadata(response->metadata_map(), expected_metadata_keys);\n\n  // Upstream responds with headers and data.\n  response = codec_client_->makeRequestWithBody(default_request_headers_, 10);\n  waitForNextUpstreamRequest();\n  upstream_request_->encodeHeaders(default_response_headers_, false);\n  upstream_request_->encodeData(100, true);\n\n  response->waitForEndStream();\n  ASSERT_TRUE(response->complete());\n  expected_metadata_keys.insert(\"data\");\n  verifyExpectedMetadata(response->metadata_map(), expected_metadata_keys);\n  EXPECT_EQ(response->keyCount(\"duplicate\"), 2);\n\n  // Upstream responds with headers, data and trailers.\n  response = codec_client_->makeRequestWithBody(default_request_headers_, 10);\n  waitForNextUpstreamRequest();\n  upstream_request_->encodeHeaders(default_response_headers_, false);\n  upstream_request_->encodeData(10, false);\n  Http::TestHeaderMapImpl response_trailers{{\"response\", \"trailer\"}};\n  upstream_request_->encodeTrailers(response_trailers);\n\n  response->waitForEndStream();\n  ASSERT_TRUE(response->complete());\n  expected_metadata_keys.insert(\"trailers\");\n  verifyExpectedMetadata(response->metadata_map(), expected_metadata_keys);\n  EXPECT_EQ(response->keyCount(\"duplicate\"), 3);\n\n  // Upstream responds with headers, 100-continue and data.\n  response = codec_client_->makeRequestWithBody(Http::TestHeaderMapImpl{{\":method\", \"GET\"},\n                                                                        {\":path\", \"/dynamo/url\"},\n                                                                        {\":scheme\", \"http\"},\n                                                                        {\":authority\", \"host\"},\n                                                                        {\"expect\", \"100-continue\"}},\n                                                10);\n\n  waitForNextUpstreamRequest();\n  upstream_request_->encode100ContinueHeaders(Http::TestHeaderMapImpl{{\":status\", \"100\"}});\n  response->waitForContinueHeaders();\n  upstream_request_->encodeHeaders(default_response_headers_, false);\n  upstream_request_->encodeData(100, true);\n\n  response->waitForEndStream();\n  ASSERT_TRUE(response->complete());\n  expected_metadata_keys.erase(\"trailers\");\n  expected_metadata_keys.insert(\"100-continue\");\n  verifyExpectedMetadata(response->metadata_map(), expected_metadata_keys);\n  EXPECT_EQ(response->keyCount(\"duplicate\"), 4);\n\n  // Upstream responds with headers and metadata that will not be consumed.\n  response = codec_client_->makeRequestWithBody(default_request_headers_, 10);\n  waitForNextUpstreamRequest();\n  Http::MetadataMap metadata_map = {{\"aaa\", \"aaa\"}};\n  Http::MetadataMapPtr metadata_map_ptr = std::make_unique<Http::MetadataMap>(metadata_map);\n  Http::MetadataMapVector metadata_map_vector;\n  metadata_map_vector.push_back(std::move(metadata_map_ptr));\n  upstream_request_->encodeMetadata(metadata_map_vector);\n  upstream_request_->encodeHeaders(default_response_headers_, true);\n\n  response->waitForEndStream();\n  ASSERT_TRUE(response->complete());\n  expected_metadata_keys.erase(\"data\");\n  expected_metadata_keys.erase(\"100-continue\");\n  expected_metadata_keys.insert(\"aaa\");\n  expected_metadata_keys.insert(\"keep\");\n  verifyExpectedMetadata(response->metadata_map(), expected_metadata_keys);\n\n  // Upstream responds with headers, data and metadata that will be consumed.\n  response = codec_client_->makeRequestWithBody(default_request_headers_, 10);\n  waitForNextUpstreamRequest();\n  metadata_map = {{\"consume\", \"consume\"}};\n  metadata_map_ptr = std::make_unique<Http::MetadataMap>(metadata_map);\n  metadata_map_vector.clear();\n  metadata_map_vector.push_back(std::move(metadata_map_ptr));\n  upstream_request_->encodeMetadata(metadata_map_vector);\n  upstream_request_->encodeHeaders(default_response_headers_, false);\n  upstream_request_->encodeData(100, true);\n\n  response->waitForEndStream();\n  ASSERT_TRUE(response->complete());\n  expected_metadata_keys.erase(\"aaa\");\n  expected_metadata_keys.insert(\"data\");\n  expected_metadata_keys.insert(\"replace\");\n  verifyExpectedMetadata(response->metadata_map(), expected_metadata_keys);\n  EXPECT_EQ(response->keyCount(\"duplicate\"), 2);\n}\n\nTEST_P(Http2MetadataIntegrationTest, ProxyMultipleMetadataReachSizeLimit) {\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  // Sends a request.\n  auto response = codec_client_->makeRequestWithBody(default_request_headers_, 10);\n  waitForNextUpstreamRequest();\n\n  // Sends multiple metadata after response header until max size limit is reached.\n  upstream_request_->encodeHeaders(default_response_headers_, false);\n  const int size = 200;\n  std::vector<Http::MetadataMapVector> multiple_vecs(size);\n  for (int i = 0; i < size; i++) {\n    Http::MetadataMap metadata_map = {{\"key\", std::string(10000, 'a')}};\n    Http::MetadataMapPtr metadata_map_ptr = std::make_unique<Http::MetadataMap>(metadata_map);\n    multiple_vecs[i].push_back(std::move(metadata_map_ptr));\n    upstream_request_->encodeMetadata(multiple_vecs[i]);\n  }\n  upstream_request_->encodeData(12, true);\n\n  // Verifies reset is received.\n  response->waitForReset();\n  ASSERT_FALSE(response->complete());\n}\n\n// Verifies small metadata can be sent at different locations of a request.\nTEST_P(Http2MetadataIntegrationTest, ProxySmallMetadataInRequest) {\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  auto encoder_decoder = codec_client_->startRequest(default_request_headers_);\n  request_encoder_ = &encoder_decoder.first;\n  auto response = std::move(encoder_decoder.second);\n  Http::MetadataMap metadata_map = {{\"key\", \"value\"}};\n  codec_client_->sendMetadata(*request_encoder_, metadata_map);\n  codec_client_->sendData(*request_encoder_, 1, false);\n  codec_client_->sendMetadata(*request_encoder_, metadata_map);\n  codec_client_->sendData(*request_encoder_, 1, false);\n  codec_client_->sendMetadata(*request_encoder_, metadata_map);\n  Http::TestHeaderMapImpl request_trailers{{\"request\", \"trailer\"}};\n  codec_client_->sendTrailers(*request_encoder_, request_trailers);\n\n  waitForNextUpstreamRequest();\n\n  // Verifies metadata is received by upstream.\n  upstream_request_->encodeHeaders(default_response_headers_, true);\n  EXPECT_EQ(upstream_request_->metadata_map().find(\"key\")->second, \"value\");\n  EXPECT_EQ(upstream_request_->metadata_map().size(), 1);\n  EXPECT_EQ(upstream_request_->duplicated_metadata_key_count().find(\"key\")->second, 3);\n\n  response->waitForEndStream();\n  ASSERT_TRUE(response->complete());\n}\n\n// Verifies large metadata can be sent at different locations of a request.\nTEST_P(Http2MetadataIntegrationTest, ProxyLargeMetadataInRequest) {\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  auto encoder_decoder = codec_client_->startRequest(default_request_headers_);\n  request_encoder_ = &encoder_decoder.first;\n  auto response = std::move(encoder_decoder.second);\n  std::string value = std::string(80 * 1024, '1');\n  Http::MetadataMap metadata_map = {{\"key\", value}};\n  codec_client_->sendMetadata(*request_encoder_, metadata_map);\n  codec_client_->sendData(*request_encoder_, 1, false);\n  codec_client_->sendMetadata(*request_encoder_, metadata_map);\n  codec_client_->sendData(*request_encoder_, 1, false);\n  codec_client_->sendMetadata(*request_encoder_, metadata_map);\n  Http::TestHeaderMapImpl request_trailers{{\"request\", \"trailer\"}};\n  codec_client_->sendTrailers(*request_encoder_, request_trailers);\n\n  waitForNextUpstreamRequest();\n\n  // Verifies metadata is received upstream.\n  upstream_request_->encodeHeaders(default_response_headers_, true);\n  EXPECT_EQ(upstream_request_->metadata_map().find(\"key\")->second, value);\n  EXPECT_EQ(upstream_request_->metadata_map().size(), 1);\n  EXPECT_EQ(upstream_request_->duplicated_metadata_key_count().find(\"key\")->second, 3);\n\n  response->waitForEndStream();\n  ASSERT_TRUE(response->complete());\n}\n\nTEST_P(Http2MetadataIntegrationTest, RequestMetadataReachSizeLimit) {\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  fake_upstreams_[0]->set_allow_unexpected_disconnects(true);\n\n  auto encoder_decoder = codec_client_->startRequest(default_request_headers_);\n  request_encoder_ = &encoder_decoder.first;\n  auto response = std::move(encoder_decoder.second);\n  std::string value = std::string(10 * 1024, '1');\n  Http::MetadataMap metadata_map = {{\"key\", value}};\n  codec_client_->sendMetadata(*request_encoder_, metadata_map);\n  codec_client_->sendData(*request_encoder_, 1, false);\n  codec_client_->sendMetadata(*request_encoder_, metadata_map);\n  codec_client_->sendData(*request_encoder_, 1, false);\n  for (int i = 0; i < 200; i++) {\n    codec_client_->sendMetadata(*request_encoder_, metadata_map);\n    if (codec_client_->disconnected()) {\n      break;\n    }\n  }\n\n  // Verifies client connection will be closed.\n  codec_client_->waitForDisconnect();\n  ASSERT_FALSE(response->complete());\n}\n\nstatic std::string request_metadata_filter = R\"EOF(\nname: request-metadata-filter\nconfig: {}\n)EOF\";\n\nTEST_P(Http2MetadataIntegrationTest, ConsumeAndInsertRequestMetadata) {\n  addFilters({request_metadata_filter});\n  config_helper_.addConfigModifier(\n      [&](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager& hcm)\n          -> void { hcm.set_proxy_100_continue(true); });\n\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  // Sends a headers only request.\n  auto response = codec_client_->makeHeaderOnlyRequest(default_request_headers_);\n  waitForNextUpstreamRequest();\n\n  upstream_request_->encodeHeaders(default_response_headers_, true);\n  response->waitForEndStream();\n  ASSERT_TRUE(response->complete());\n  // Verifies a headers metadata added.\n  std::set<std::string> expected_metadata_keys = {\"headers\"};\n  expected_metadata_keys.insert(\"metadata\");\n  verifyExpectedMetadata(upstream_request_->metadata_map(), expected_metadata_keys);\n\n  // Sends a headers only request with metadata. An empty data frame carries end_stream.\n  auto encoder_decoder = codec_client_->startRequest(default_request_headers_);\n  request_encoder_ = &encoder_decoder.first;\n  response = std::move(encoder_decoder.second);\n  Http::MetadataMap metadata_map = {{\"consume\", \"consume\"}};\n  codec_client_->sendMetadata(*request_encoder_, metadata_map);\n  codec_client_->sendData(*request_encoder_, 0, true);\n  waitForNextUpstreamRequest();\n\n  upstream_request_->encodeHeaders(default_response_headers_, true);\n  response->waitForEndStream();\n  ASSERT_TRUE(response->complete());\n  expected_metadata_keys.insert(\"data\");\n  expected_metadata_keys.insert(\"metadata\");\n  expected_metadata_keys.insert(\"replace\");\n  verifyExpectedMetadata(upstream_request_->metadata_map(), expected_metadata_keys);\n  EXPECT_EQ(upstream_request_->duplicated_metadata_key_count().find(\"metadata\")->second, 3);\n  // Verifies zero length data received, and end_stream is true.\n  EXPECT_EQ(true, upstream_request_->receivedData());\n  EXPECT_EQ(0, upstream_request_->bodyLength());\n  EXPECT_EQ(true, upstream_request_->complete());\n\n  // Sends headers, data, metadata and trailer.\n  auto encoder_decoder_2 = codec_client_->startRequest(default_request_headers_);\n  request_encoder_ = &encoder_decoder_2.first;\n  response = std::move(encoder_decoder_2.second);\n  codec_client_->sendData(*request_encoder_, 10, false);\n  metadata_map = {{\"consume\", \"consume\"}};\n  codec_client_->sendMetadata(*request_encoder_, metadata_map);\n  Http::TestHeaderMapImpl request_trailers{{\"trailer\", \"trailer\"}};\n  codec_client_->sendTrailers(*request_encoder_, request_trailers);\n  waitForNextUpstreamRequest();\n\n  upstream_request_->encodeHeaders(default_response_headers_, true);\n  response->waitForEndStream();\n  ASSERT_TRUE(response->complete());\n  expected_metadata_keys.insert(\"trailers\");\n  verifyExpectedMetadata(upstream_request_->metadata_map(), expected_metadata_keys);\n  EXPECT_EQ(upstream_request_->duplicated_metadata_key_count().find(\"metadata\")->second, 4);\n\n  // Sends headers, large data, metadata. Large data triggers decodeData() multiple times, and each\n  // time, a \"data\" metadata is added.\n  auto encoder_decoder_3 = codec_client_->startRequest(default_request_headers_);\n  request_encoder_ = &encoder_decoder_3.first;\n  response = std::move(encoder_decoder_3.second);\n  codec_client_->sendData(*request_encoder_, 100000, false);\n  codec_client_->sendMetadata(*request_encoder_, metadata_map);\n  codec_client_->sendData(*request_encoder_, 100000, true);\n  waitForNextUpstreamRequest();\n\n  upstream_request_->encodeHeaders(default_response_headers_, true);\n  response->waitForEndStream();\n  ASSERT_TRUE(response->complete());\n\n  expected_metadata_keys.erase(\"trailers\");\n  verifyExpectedMetadata(upstream_request_->metadata_map(), expected_metadata_keys);\n  EXPECT_GE(upstream_request_->duplicated_metadata_key_count().find(\"data\")->second, 2);\n  EXPECT_GE(upstream_request_->duplicated_metadata_key_count().find(\"metadata\")->second, 3);\n\n  // Sends multiple metadata.\n  auto encoder_decoder_4 = codec_client_->startRequest(default_request_headers_);\n  request_encoder_ = &encoder_decoder_4.first;\n  response = std::move(encoder_decoder_4.second);\n  metadata_map = {{\"metadata1\", \"metadata1\"}};\n  codec_client_->sendMetadata(*request_encoder_, metadata_map);\n  codec_client_->sendData(*request_encoder_, 10, false);\n  metadata_map = {{\"metadata2\", \"metadata2\"}};\n  codec_client_->sendMetadata(*request_encoder_, metadata_map);\n  metadata_map = {{\"consume\", \"consume\"}};\n  codec_client_->sendMetadata(*request_encoder_, metadata_map);\n  codec_client_->sendTrailers(*request_encoder_, request_trailers);\n  waitForNextUpstreamRequest();\n\n  upstream_request_->encodeHeaders(default_response_headers_, true);\n  response->waitForEndStream();\n  ASSERT_TRUE(response->complete());\n  expected_metadata_keys.insert(\"metadata1\");\n  expected_metadata_keys.insert(\"metadata2\");\n  expected_metadata_keys.insert(\"trailers\");\n  verifyExpectedMetadata(upstream_request_->metadata_map(), expected_metadata_keys);\n  EXPECT_EQ(upstream_request_->duplicated_metadata_key_count().find(\"metadata\")->second, 6);\n}\n\nstatic std::string decode_headers_only = R\"EOF(\nname: decode-headers-only\nconfig: {}\n)EOF\";\n\nvoid Http2MetadataIntegrationTest::runHeaderOnlyTest(bool send_request_body, size_t body_size) {\n  config_helper_.addConfigModifier(\n      [&](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager& hcm)\n          -> void { hcm.set_proxy_100_continue(true); });\n\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  // Sends a request with body. Only headers will pass through filters.\n  IntegrationStreamDecoderPtr response;\n  if (send_request_body) {\n    response =\n        codec_client_->makeRequestWithBody(Http::TestHeaderMapImpl{{\":method\", \"POST\"},\n                                                                   {\":path\", \"/test/long/url\"},\n                                                                   {\":scheme\", \"http\"},\n                                                                   {\":authority\", \"host\"}},\n                                           body_size);\n  } else {\n    response =\n        codec_client_->makeHeaderOnlyRequest(Http::TestHeaderMapImpl{{\":method\", \"POST\"},\n                                                                     {\":path\", \"/test/long/url\"},\n                                                                     {\":scheme\", \"http\"},\n                                                                     {\":authority\", \"host\"}});\n  }\n  waitForNextUpstreamRequest();\n\n  upstream_request_->encodeHeaders(default_response_headers_, true);\n  response->waitForEndStream();\n  ASSERT_TRUE(response->complete());\n}\n\nvoid Http2MetadataIntegrationTest::verifyHeadersOnlyTest() {\n  // Verifies a headers metadata added.\n  std::set<std::string> expected_metadata_keys = {\"headers\"};\n  expected_metadata_keys.insert(\"metadata\");\n  verifyExpectedMetadata(upstream_request_->metadata_map(), expected_metadata_keys);\n\n  // Verifies zero length data received, and end_stream is true.\n  EXPECT_EQ(true, upstream_request_->receivedData());\n  EXPECT_EQ(0, upstream_request_->bodyLength());\n  EXPECT_EQ(true, upstream_request_->complete());\n}\n\nTEST_P(Http2MetadataIntegrationTest, DecodingHeadersOnlyRequestWithRequestMetadataEmptyData) {\n  addFilters({request_metadata_filter, decode_headers_only});\n\n  // Send a request with body, and body size is 0.\n  runHeaderOnlyTest(true, 0);\n  verifyHeadersOnlyTest();\n}\n\nTEST_P(Http2MetadataIntegrationTest, DecodingHeadersOnlyRequestWithRequestMetadataNoneEmptyData) {\n  addFilters({request_metadata_filter, decode_headers_only});\n  // Send a request with body, and body size is 128.\n  runHeaderOnlyTest(true, 128);\n  verifyHeadersOnlyTest();\n}\n\nTEST_P(Http2MetadataIntegrationTest, DecodingHeadersOnlyRequestWithRequestMetadataDiffFilterOrder) {\n  addFilters({decode_headers_only, request_metadata_filter});\n  // Send a request with body, and body size is 128.\n  runHeaderOnlyTest(true, 128);\n  verifyHeadersOnlyTest();\n}\n\nTEST_P(Http2MetadataIntegrationTest, HeadersOnlyRequestWithRequestMetadata) {\n  addFilters({request_metadata_filter});\n  // Send a headers only request.\n  runHeaderOnlyTest(false, 0);\n  verifyHeadersOnlyTest();\n}\n\nvoid Http2MetadataIntegrationTest::testRequestMetadataWithStopAllFilter() {\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  // Sends multiple metadata.\n  const size_t size = 10;\n  default_request_headers_.addCopy(\"content_size\", std::to_string(size));\n  auto encoder_decoder = codec_client_->startRequest(default_request_headers_);\n  request_encoder_ = &encoder_decoder.first;\n  auto response = std::move(encoder_decoder.second);\n  Http::MetadataMap metadata_map = {{\"metadata1\", \"metadata1\"}};\n  codec_client_->sendMetadata(*request_encoder_, metadata_map);\n  codec_client_->sendData(*request_encoder_, size, false);\n  metadata_map = {{\"metadata2\", \"metadata2\"}};\n  codec_client_->sendMetadata(*request_encoder_, metadata_map);\n  metadata_map = {{\"consume\", \"consume\"}};\n  codec_client_->sendMetadata(*request_encoder_, metadata_map);\n  Http::TestHeaderMapImpl request_trailers{{\"trailer\", \"trailer\"}};\n  codec_client_->sendTrailers(*request_encoder_, request_trailers);\n  waitForNextUpstreamRequest();\n\n  upstream_request_->encodeHeaders(default_response_headers_, true);\n  response->waitForEndStream();\n  ASSERT_TRUE(response->complete());\n  std::set<std::string> expected_metadata_keys = {\"headers\",   \"data\",    \"metadata\", \"metadata1\",\n                                                  \"metadata2\", \"replace\", \"trailers\"};\n  verifyExpectedMetadata(upstream_request_->metadata_map(), expected_metadata_keys);\n  EXPECT_EQ(upstream_request_->duplicated_metadata_key_count().find(\"metadata\")->second, 6);\n}\n\nstatic std::string metadata_stop_all_filter = R\"EOF(\nname: metadata-stop-all-filter\nconfig: {}\n)EOF\";\n\nTEST_P(Http2MetadataIntegrationTest, RequestMetadataWithStopAllFilterBeforeMetadataFilter) {\n  addFilters({request_metadata_filter, metadata_stop_all_filter});\n  testRequestMetadataWithStopAllFilter();\n}\n\nTEST_P(Http2MetadataIntegrationTest, RequestMetadataWithStopAllFilterAfterMetadataFilter) {\n  addFilters({metadata_stop_all_filter, request_metadata_filter});\n  testRequestMetadataWithStopAllFilter();\n}\n\nTEST_P(Http2MetadataIntegrationTest, TestAddEncodedMetadata) {\n  config_helper_.addFilter(R\"EOF(\nname: encode-headers-return-stop-all-filter\n)EOF\");\n\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  // Upstream responds with headers, data and trailers.\n  auto response = codec_client_->makeRequestWithBody(default_request_headers_, 10);\n  waitForNextUpstreamRequest();\n\n  const int count = 70;\n  const int size = 1000;\n  const int added_decoded_data_size = 1;\n\n  default_response_headers_.addCopy(\"content_size\", std::to_string(count * size));\n  default_response_headers_.addCopy(\"added_size\", std::to_string(added_decoded_data_size));\n  default_response_headers_.addCopy(\"is_first_trigger\", \"value\");\n\n  upstream_request_->encodeHeaders(default_response_headers_, false);\n  for (int i = 0; i < count - 1; i++) {\n    upstream_request_->encodeData(size, false);\n  }\n\n  upstream_request_->encodeData(size, false);\n  Http::TestHeaderMapImpl response_trailers{{\"response\", \"trailer\"}};\n  upstream_request_->encodeTrailers(response_trailers);\n\n  response->waitForEndStream();\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(response->metadata_map().find(\"headers\")->second, \"headers\");\n  EXPECT_EQ(response->metadata_map().find(\"data\")->second, \"data\");\n  EXPECT_EQ(response->metadata_map().find(\"trailers\")->second, \"trailers\");\n  EXPECT_EQ(response->metadata_map().size(), 3);\n  EXPECT_EQ(count * size + added_decoded_data_size * 2, response->body().size());\n}\n\nTEST_P(Http2IntegrationTest, GrpcRouterNotFound) {\n  config_helper_.setDefaultHostAndRoute(\"foo.com\", \"/found\");\n  initialize();\n\n  BufferingStreamDecoderPtr response = IntegrationUtil::makeSingleRequest(\n      lookupPort(\"http\"), \"POST\", \"/service/notfound\", \"\", downstream_protocol_, version_, \"host\",\n      Http::Headers::get().ContentTypeValues.Grpc);\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().Status()->value().getStringView());\n  EXPECT_EQ(Http::Headers::get().ContentTypeValues.Grpc,\n            response->headers().ContentType()->value().getStringView());\n  EXPECT_EQ(\"12\", response->headers().GrpcStatus()->value().getStringView());\n}\n\nTEST_P(Http2IntegrationTest, GrpcRetry) { testGrpcRetry(); }\n\n// Verify the case where there is an HTTP/2 codec/protocol error with an active stream.\nTEST_P(Http2IntegrationTest, CodecErrorAfterStreamStart) {\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  // Sends a request.\n  auto response = codec_client_->makeRequestWithBody(default_request_headers_, 10);\n  waitForNextUpstreamRequest();\n\n  // Send bogus raw data on the connection.\n  Buffer::OwnedImpl bogus_data(\"some really bogus data\");\n  codec_client_->rawConnection().write(bogus_data, false);\n\n  // Verifies reset is received.\n  response->waitForReset();\n}\n\nTEST_P(Http2IntegrationTest, BadMagic) {\n  initialize();\n  Buffer::OwnedImpl buffer(\"hello\");\n  std::string response;\n  RawConnectionDriver connection(\n      lookupPort(\"http\"), buffer,\n      [&](Network::ClientConnection&, const Buffer::Instance& data) -> void {\n        response.append(data.toString());\n      },\n      version_);\n\n  connection.run();\n  EXPECT_EQ(\"\", response);\n}\n\nTEST_P(Http2IntegrationTest, BadFrame) {\n  initialize();\n  Buffer::OwnedImpl buffer(\"PRI * HTTP/2.0\\r\\n\\r\\nSM\\r\\n\\r\\nhelloworldcauseanerror\");\n  std::string response;\n  RawConnectionDriver connection(\n      lookupPort(\"http\"), buffer,\n      [&](Network::ClientConnection&, const Buffer::Instance& data) -> void {\n        response.append(data.toString());\n      },\n      version_);\n\n  connection.run();\n  EXPECT_TRUE(response.find(\"SETTINGS expected\") != std::string::npos);\n}\n\n// Send client headers, a GoAway and then a body and ensure the full request and\n// response are received.\nTEST_P(Http2IntegrationTest, GoAway) {\n  config_helper_.addFilter(ConfigHelper::DEFAULT_HEALTH_CHECK_FILTER);\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  auto encoder_decoder = codec_client_->startRequest(Http::TestHeaderMapImpl{\n      {\":method\", \"GET\"}, {\":path\", \"/healthcheck\"}, {\":scheme\", \"http\"}, {\":authority\", \"host\"}});\n  request_encoder_ = &encoder_decoder.first;\n  auto response = std::move(encoder_decoder.second);\n  codec_client_->goAway();\n  codec_client_->sendData(*request_encoder_, 0, true);\n  response->waitForEndStream();\n  codec_client_->close();\n\n  EXPECT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().Status()->value().getStringView());\n}\n\nTEST_P(Http2IntegrationTest, Trailers) { testTrailers(1024, 2048); }\n\nTEST_P(Http2IntegrationTest, TrailersGiantBody) { testTrailers(1024 * 1024, 1024 * 1024); }\n\nTEST_P(Http2IntegrationTest, GrpcRequestTimeout) {\n  config_helper_.addConfigModifier(\n      [&](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager& hcm)\n          -> void {\n        auto* route_config = hcm.mutable_route_config();\n        auto* virtual_host = route_config->mutable_virtual_hosts(0);\n        auto* route = virtual_host->mutable_routes(0);\n        route->mutable_route()->mutable_max_grpc_timeout()->set_seconds(60 * 60);\n      });\n  initialize();\n\n  // Envoy will close some number of connections when request times out.\n  // Make sure they don't cause assertion failures when we ignore them.\n  fake_upstreams_[0]->set_allow_unexpected_disconnects(true);\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  // With upstream request timeout Envoy should send a gRPC-Status \"DEADLINE EXCEEDED\".\n  // TODO: Properly map request timeout to \"DEADLINE EXCEEDED\" instead of \"SERVICE UNAVAILABLE\".\n  auto response = codec_client_->makeHeaderOnlyRequest(\n      Http::TestHeaderMapImpl{{\":method\", \"POST\"},\n                              {\":path\", \"/test/long/url\"},\n                              {\":scheme\", \"http\"},\n                              {\":authority\", \"host\"},\n                              {\"te\", \"trailers\"},\n                              {\"grpc-timeout\", \"1S\"}, // 1 Second\n                              {\"content-type\", \"application/grpc\"}});\n  response->waitForEndStream();\n  EXPECT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().Status()->value().getStringView());\n  EXPECT_NE(response->headers().GrpcStatus(), nullptr);\n  EXPECT_EQ(\"14\", response->headers().GrpcStatus()->value().getStringView()); // Service Unavailable\n  EXPECT_LT(0, test_server_->counter(\"cluster.cluster_0.upstream_rq_timeout\")->value());\n}\n\n// Interleave two requests and responses and make sure that idle timeout is handled correctly.\nTEST_P(Http2IntegrationTest, IdleTimeoutWithSimultaneousRequests) {\n  FakeHttpConnectionPtr fake_upstream_connection1;\n  FakeHttpConnectionPtr fake_upstream_connection2;\n  Http::StreamEncoder* encoder1;\n  Http::StreamEncoder* encoder2;\n  FakeStreamPtr upstream_request1;\n  FakeStreamPtr upstream_request2;\n  int32_t request1_bytes = 1024;\n  int32_t request2_bytes = 512;\n\n  config_helper_.addConfigModifier([](envoy::config::bootstrap::v2::Bootstrap& bootstrap) {\n    auto* static_resources = bootstrap.mutable_static_resources();\n    auto* cluster = static_resources->mutable_clusters(0);\n    auto* http_protocol_options = cluster->mutable_common_http_protocol_options();\n    auto* idle_time_out = http_protocol_options->mutable_idle_timeout();\n    std::chrono::milliseconds timeout(1000);\n    auto seconds = std::chrono::duration_cast<std::chrono::seconds>(timeout);\n    idle_time_out->set_seconds(seconds.count());\n  });\n\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  // Start request 1\n  auto encoder_decoder =\n      codec_client_->startRequest(Http::TestHeaderMapImpl{{\":method\", \"POST\"},\n                                                          {\":path\", \"/test/long/url\"},\n                                                          {\":scheme\", \"http\"},\n                                                          {\":authority\", \"host\"}});\n  encoder1 = &encoder_decoder.first;\n  auto response1 = std::move(encoder_decoder.second);\n\n  ASSERT_TRUE(fake_upstreams_[0]->waitForHttpConnection(*dispatcher_, fake_upstream_connection1));\n  ASSERT_TRUE(fake_upstream_connection1->waitForNewStream(*dispatcher_, upstream_request1));\n\n  // Start request 2\n  auto encoder_decoder2 =\n      codec_client_->startRequest(Http::TestHeaderMapImpl{{\":method\", \"POST\"},\n                                                          {\":path\", \"/test/long/url\"},\n                                                          {\":scheme\", \"http\"},\n                                                          {\":authority\", \"host\"}});\n  encoder2 = &encoder_decoder2.first;\n  auto response2 = std::move(encoder_decoder2.second);\n  ASSERT_TRUE(fake_upstreams_[0]->waitForHttpConnection(*dispatcher_, fake_upstream_connection2));\n  ASSERT_TRUE(fake_upstream_connection2->waitForNewStream(*dispatcher_, upstream_request2));\n\n  // Finish request 1\n  codec_client_->sendData(*encoder1, request1_bytes, true);\n  ASSERT_TRUE(upstream_request1->waitForEndStream(*dispatcher_));\n\n  // Finish request i2\n  codec_client_->sendData(*encoder2, request2_bytes, true);\n  ASSERT_TRUE(upstream_request2->waitForEndStream(*dispatcher_));\n\n  // Respond to request 2\n  upstream_request2->encodeHeaders(Http::TestHeaderMapImpl{{\":status\", \"200\"}}, false);\n  upstream_request2->encodeData(request2_bytes, true);\n  response2->waitForEndStream();\n  EXPECT_TRUE(upstream_request2->complete());\n  EXPECT_EQ(request2_bytes, upstream_request2->bodyLength());\n  EXPECT_TRUE(response2->complete());\n  EXPECT_EQ(\"200\", response2->headers().Status()->value().getStringView());\n  EXPECT_EQ(request2_bytes, response2->body().size());\n\n  // Validate that idle time is not kicked in.\n  EXPECT_EQ(0, test_server_->counter(\"cluster.cluster_0.upstream_cx_idle_timeout\")->value());\n  EXPECT_NE(0, test_server_->counter(\"cluster.cluster_0.upstream_cx_total\")->value());\n\n  // Respond to request 1\n  upstream_request1->encodeHeaders(Http::TestHeaderMapImpl{{\":status\", \"200\"}}, false);\n  upstream_request1->encodeData(request1_bytes, true);\n  response1->waitForEndStream();\n  EXPECT_TRUE(upstream_request1->complete());\n  EXPECT_EQ(request1_bytes, upstream_request1->bodyLength());\n  EXPECT_TRUE(response1->complete());\n  EXPECT_EQ(\"200\", response1->headers().Status()->value().getStringView());\n  EXPECT_EQ(request1_bytes, response1->body().size());\n\n  // Do not send any requests and validate idle timeout kicks in after both the requests are done.\n  ASSERT_TRUE(fake_upstream_connection1->waitForDisconnect());\n  ASSERT_TRUE(fake_upstream_connection2->waitForDisconnect());\n  test_server_->waitForCounterGe(\"cluster.cluster_0.upstream_cx_idle_timeout\", 2);\n}\n\n// Test request mirroring / shadowing with an HTTP/2 downstream and a request with a body.\nTEST_P(Http2IntegrationTest, RequestMirrorWithBody) {\n  config_helper_.addConfigModifier(\n      [&](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager& hcm)\n          -> void {\n        hcm.mutable_route_config()\n            ->mutable_virtual_hosts(0)\n            ->mutable_routes(0)\n            ->mutable_route()\n            ->mutable_request_mirror_policy()\n            ->set_cluster(\"cluster_0\");\n      });\n\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  // Send request with body.\n  IntegrationStreamDecoderPtr request =\n      codec_client_->makeRequestWithBody(Http::TestHeaderMapImpl{{\":method\", \"POST\"},\n                                                                 {\":path\", \"/test/long/url\"},\n                                                                 {\":scheme\", \"http\"},\n                                                                 {\":authority\", \"host\"}},\n                                         \"hello\");\n\n  // Wait for the first request as well as the shadow.\n  waitForNextUpstreamRequest();\n\n  FakeHttpConnectionPtr fake_upstream_connection2;\n  FakeStreamPtr upstream_request2;\n  ASSERT_TRUE(fake_upstreams_[0]->waitForHttpConnection(*dispatcher_, fake_upstream_connection2));\n  ASSERT_TRUE(fake_upstream_connection2->waitForNewStream(*dispatcher_, upstream_request2));\n  ASSERT_TRUE(upstream_request2->waitForEndStream(*dispatcher_));\n\n  // Make sure both requests have a body. Also check the shadow for the shadow headers.\n  EXPECT_EQ(\"hello\", upstream_request_->body().toString());\n  EXPECT_EQ(\"hello\", upstream_request2->body().toString());\n  EXPECT_EQ(\"host-shadow\", upstream_request2->headers().Host()->value().getStringView());\n\n  upstream_request_->encodeHeaders(Http::TestHeaderMapImpl{{\":status\", \"200\"}}, true);\n  upstream_request2->encodeHeaders(Http::TestHeaderMapImpl{{\":status\", \"200\"}}, true);\n  request->waitForEndStream();\n  EXPECT_EQ(\"200\", request->headers().Status()->value().getStringView());\n\n  // Cleanup.\n  ASSERT_TRUE(fake_upstream_connection2->close());\n  ASSERT_TRUE(fake_upstream_connection2->waitForDisconnect());\n}\n\n// Interleave two requests and responses and make sure the HTTP2 stack handles this correctly.\nvoid Http2IntegrationTest::simultaneousRequest(int32_t request1_bytes, int32_t request2_bytes) {\n  FakeHttpConnectionPtr fake_upstream_connection1;\n  FakeHttpConnectionPtr fake_upstream_connection2;\n  Http::StreamEncoder* encoder1;\n  Http::StreamEncoder* encoder2;\n  FakeStreamPtr upstream_request1;\n  FakeStreamPtr upstream_request2;\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  // Start request 1\n  auto encoder_decoder =\n      codec_client_->startRequest(Http::TestHeaderMapImpl{{\":method\", \"POST\"},\n                                                          {\":path\", \"/test/long/url\"},\n                                                          {\":scheme\", \"http\"},\n                                                          {\":authority\", \"host\"}});\n  encoder1 = &encoder_decoder.first;\n  auto response1 = std::move(encoder_decoder.second);\n\n  ASSERT_TRUE(fake_upstreams_[0]->waitForHttpConnection(*dispatcher_, fake_upstream_connection1));\n  ASSERT_TRUE(fake_upstream_connection1->waitForNewStream(*dispatcher_, upstream_request1));\n\n  // Start request 2\n  auto encoder_decoder2 =\n      codec_client_->startRequest(Http::TestHeaderMapImpl{{\":method\", \"POST\"},\n                                                          {\":path\", \"/test/long/url\"},\n                                                          {\":scheme\", \"http\"},\n                                                          {\":authority\", \"host\"}});\n  encoder2 = &encoder_decoder2.first;\n  auto response2 = std::move(encoder_decoder2.second);\n  ASSERT_TRUE(fake_upstreams_[0]->waitForHttpConnection(*dispatcher_, fake_upstream_connection2));\n  ASSERT_TRUE(fake_upstream_connection2->waitForNewStream(*dispatcher_, upstream_request2));\n\n  // Finish request 1\n  codec_client_->sendData(*encoder1, request1_bytes, true);\n  ASSERT_TRUE(upstream_request1->waitForEndStream(*dispatcher_));\n\n  // Finish request 2\n  codec_client_->sendData(*encoder2, request2_bytes, true);\n  ASSERT_TRUE(upstream_request2->waitForEndStream(*dispatcher_));\n\n  // Respond to request 2\n  upstream_request2->encodeHeaders(Http::TestHeaderMapImpl{{\":status\", \"200\"}}, false);\n  upstream_request2->encodeData(request2_bytes, true);\n  response2->waitForEndStream();\n  EXPECT_TRUE(upstream_request2->complete());\n  EXPECT_EQ(request2_bytes, upstream_request2->bodyLength());\n  EXPECT_TRUE(response2->complete());\n  EXPECT_EQ(\"200\", response2->headers().Status()->value().getStringView());\n  EXPECT_EQ(request2_bytes, response2->body().size());\n\n  // Respond to request 1\n  upstream_request1->encodeHeaders(Http::TestHeaderMapImpl{{\":status\", \"200\"}}, false);\n  upstream_request1->encodeData(request2_bytes, true);\n  response1->waitForEndStream();\n  EXPECT_TRUE(upstream_request1->complete());\n  EXPECT_EQ(request1_bytes, upstream_request1->bodyLength());\n  EXPECT_TRUE(response1->complete());\n  EXPECT_EQ(\"200\", response1->headers().Status()->value().getStringView());\n  EXPECT_EQ(request2_bytes, response1->body().size());\n\n  // Cleanup both downstream and upstream\n  ASSERT_TRUE(fake_upstream_connection1->close());\n  ASSERT_TRUE(fake_upstream_connection1->waitForDisconnect());\n  ASSERT_TRUE(fake_upstream_connection2->close());\n  ASSERT_TRUE(fake_upstream_connection2->waitForDisconnect());\n  codec_client_->close();\n}\n\nTEST_P(Http2IntegrationTest, SimultaneousRequest) { simultaneousRequest(1024, 512); }\n\nTEST_P(Http2IntegrationTest, SimultaneousRequestWithBufferLimits) {\n  config_helper_.setBufferLimits(1024, 1024); // Set buffer limits upstream and downstream.\n  simultaneousRequest(1024 * 32, 1024 * 16);\n}\n\n// Test downstream connection delayed close processing.\nTEST_P(Http2IntegrationTest, DelayedCloseAfterBadFrame) {\n  initialize();\n  Buffer::OwnedImpl buffer(\"PRI * HTTP/2.0\\r\\n\\r\\nSM\\r\\n\\r\\nhelloworldcauseanerror\");\n  std::string response;\n  RawConnectionDriver connection(\n      lookupPort(\"http\"), buffer,\n      [&](Network::ClientConnection& connection, const Buffer::Instance& data) -> void {\n        response.append(data.toString());\n        connection.dispatcher().exit();\n      },\n      version_);\n\n  connection.run();\n  EXPECT_THAT(response, HasSubstr(\"SETTINGS expected\"));\n  // Due to the multiple dispatchers involved (one for the RawConnectionDriver and another for the\n  // Envoy server), it's possible the delayed close timer could fire and close the server socket\n  // prior to the data callback above firing. Therefore, we may either still be connected, or have\n  // received a remote close.\n  if (connection.last_connection_event() == Network::ConnectionEvent::Connected) {\n    connection.run();\n  }\n  EXPECT_EQ(connection.last_connection_event(), Network::ConnectionEvent::RemoteClose);\n  EXPECT_EQ(test_server_->counter(\"http.config_test.downstream_cx_delayed_close_timeout\")->value(),\n            1);\n}\n\n// Test disablement of delayed close processing on downstream connections.\nTEST_P(Http2IntegrationTest, DelayedCloseDisabled) {\n  config_helper_.addConfigModifier(\n      [](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager& hcm) {\n        hcm.mutable_delayed_close_timeout()->set_seconds(0);\n      });\n  initialize();\n  Buffer::OwnedImpl buffer(\"PRI * HTTP/2.0\\r\\n\\r\\nSM\\r\\n\\r\\nhelloworldcauseanerror\");\n  std::string response;\n  RawConnectionDriver connection(\n      lookupPort(\"http\"), buffer,\n      [&](Network::ClientConnection& connection, const Buffer::Instance& data) -> void {\n        response.append(data.toString());\n        connection.dispatcher().exit();\n      },\n      version_);\n\n  connection.run();\n  EXPECT_THAT(response, HasSubstr(\"SETTINGS expected\"));\n  // Due to the multiple dispatchers involved (one for the RawConnectionDriver and another for the\n  // Envoy server), it's possible for the 'connection' to receive the data and exit the dispatcher\n  // prior to the FIN being received from the server.\n  if (connection.last_connection_event() == Network::ConnectionEvent::Connected) {\n    connection.run();\n  }\n  EXPECT_EQ(connection.last_connection_event(), Network::ConnectionEvent::RemoteClose);\n  EXPECT_EQ(test_server_->counter(\"http.config_test.downstream_cx_delayed_close_timeout\")->value(),\n            0);\n}\n\nTEST_P(Http2IntegrationTest, PauseAndResume) {\n  config_helper_.addFilter(R\"EOF(\n  name: stop-iteration-and-continue-filter\n  config: {}\n  )EOF\");\n  initialize();\n\n  // Send a request with a bit of data, to trigger the filter pausing.\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  auto encoder_decoder = codec_client_->startRequest(default_request_headers_);\n  request_encoder_ = &encoder_decoder.first;\n  codec_client_->sendData(*request_encoder_, 1, false);\n\n  auto response = std::move(encoder_decoder.second);\n  ASSERT_TRUE(fake_upstreams_[0]->waitForHttpConnection(*dispatcher_, fake_upstream_connection_));\n  ASSERT_TRUE(fake_upstream_connection_->waitForNewStream(*dispatcher_, upstream_request_));\n  ASSERT_TRUE(upstream_request_->waitForHeadersComplete());\n\n  // Now send the final data frame and make sure it gets proxied.\n  codec_client_->sendData(*request_encoder_, 0, true);\n  ASSERT_TRUE(upstream_request_->waitForEndStream(*dispatcher_));\n  upstream_request_->encodeHeaders(default_response_headers_, false);\n\n  response->waitForHeaders();\n  upstream_request_->encodeData(0, true);\n  response->waitForEndStream();\n  ASSERT_TRUE(response->complete());\n}\n\nTEST_P(Http2IntegrationTest, PauseAndResumeHeadersOnly) {\n  config_helper_.addFilter(R\"EOF(\n  name: stop-iteration-and-continue-filter\n  config: {}\n  )EOF\");\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  auto response = codec_client_->makeHeaderOnlyRequest(default_request_headers_);\n\n  ASSERT_TRUE(fake_upstreams_[0]->waitForHttpConnection(*dispatcher_, fake_upstream_connection_));\n  ASSERT_TRUE(fake_upstream_connection_->waitForNewStream(*dispatcher_, upstream_request_));\n  ASSERT_TRUE(upstream_request_->waitForEndStream(*dispatcher_));\n\n  upstream_request_->encodeHeaders(default_response_headers_, true);\n  response->waitForEndStream();\n  ASSERT_TRUE(response->complete());\n}\n\nHttp2RingHashIntegrationTest::Http2RingHashIntegrationTest() {\n  config_helper_.addConfigModifier([&](envoy::config::bootstrap::v2::Bootstrap& bootstrap) -> void {\n    auto* cluster = bootstrap.mutable_static_resources()->mutable_clusters(0);\n    cluster->clear_hosts();\n    cluster->set_lb_policy(envoy::api::v2::Cluster_LbPolicy_RING_HASH);\n    for (int i = 0; i < num_upstreams_; i++) {\n      auto* socket = cluster->add_hosts()->mutable_socket_address();\n      socket->set_address(Network::Test::getLoopbackAddressString(version_));\n    }\n  });\n}\n\nHttp2RingHashIntegrationTest::~Http2RingHashIntegrationTest() {\n  if (codec_client_) {\n    codec_client_->close();\n    codec_client_ = nullptr;\n  }\n  for (auto& fake_upstream_connection : fake_upstream_connections_) {\n    AssertionResult result = fake_upstream_connection->close();\n    RELEASE_ASSERT(result, result.message());\n    result = fake_upstream_connection->waitForDisconnect();\n    RELEASE_ASSERT(result, result.message());\n  }\n}\n\nvoid Http2RingHashIntegrationTest::createUpstreams() {\n  for (int i = 0; i < num_upstreams_; i++) {\n    fake_upstreams_.emplace_back(\n        new FakeUpstream(0, FakeHttpConnection::Type::HTTP1, version_, timeSystem()));\n  }\n}\n\nINSTANTIATE_TEST_SUITE_P(IpVersions, Http2RingHashIntegrationTest,\n                         testing::ValuesIn(TestEnvironment::getIpVersionsForTest()),\n                         TestUtility::ipTestParamsToString);\n\nINSTANTIATE_TEST_SUITE_P(IpVersions, Http2MetadataIntegrationTest,\n                         testing::ValuesIn(TestEnvironment::getIpVersionsForTest()),\n                         TestUtility::ipTestParamsToString);\n\nvoid Http2RingHashIntegrationTest::sendMultipleRequests(\n    int request_bytes, Http::TestHeaderMapImpl headers,\n    std::function<void(IntegrationStreamDecoder&)> cb) {\n  TestRandomGenerator rand;\n  const uint32_t num_requests = 50;\n  std::vector<Http::StreamEncoder*> encoders;\n  std::vector<IntegrationStreamDecoderPtr> responses;\n  std::vector<FakeStreamPtr> upstream_requests;\n\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  for (uint32_t i = 0; i < num_requests; ++i) {\n    auto encoder_decoder = codec_client_->startRequest(headers);\n    encoders.push_back(&encoder_decoder.first);\n    responses.push_back(std::move(encoder_decoder.second));\n    codec_client_->sendData(*encoders[i], request_bytes, true);\n  }\n\n  for (uint32_t i = 0; i < num_requests; ++i) {\n    FakeHttpConnectionPtr fake_upstream_connection;\n    ASSERT_TRUE(FakeUpstream::waitForHttpConnection(*dispatcher_, fake_upstreams_,\n                                                    fake_upstream_connection));\n    // As data and streams are interwoven, make sure waitForNewStream()\n    // ignores incoming data and waits for actual stream establishment.\n    upstream_requests.emplace_back();\n    ASSERT_TRUE(\n        fake_upstream_connection->waitForNewStream(*dispatcher_, upstream_requests.back(), true));\n    upstream_requests.back()->setAddServedByHeader(true);\n    fake_upstream_connections_.push_back(std::move(fake_upstream_connection));\n  }\n\n  for (uint32_t i = 0; i < num_requests; ++i) {\n    ASSERT_TRUE(upstream_requests[i]->waitForEndStream(*dispatcher_));\n    upstream_requests[i]->encodeHeaders(Http::TestHeaderMapImpl{{\":status\", \"200\"}}, false);\n    upstream_requests[i]->encodeData(rand.random() % (1024 * 2), true);\n  }\n\n  for (uint32_t i = 0; i < num_requests; ++i) {\n    responses[i]->waitForEndStream();\n    EXPECT_TRUE(upstream_requests[i]->complete());\n    EXPECT_EQ(request_bytes, upstream_requests[i]->bodyLength());\n\n    EXPECT_TRUE(responses[i]->complete());\n    cb(*responses[i]);\n  }\n}\n\nTEST_P(Http2RingHashIntegrationTest, CookieRoutingNoCookieNoTtl) {\n  config_helper_.addConfigModifier(\n      [&](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager& hcm)\n          -> void {\n        auto* hash_policy = hcm.mutable_route_config()\n                                ->mutable_virtual_hosts(0)\n                                ->mutable_routes(0)\n                                ->mutable_route()\n                                ->add_hash_policy();\n        auto* cookie = hash_policy->mutable_cookie();\n        cookie->set_name(\"foo\");\n      });\n\n  // This test is non-deterministic, so make it extremely unlikely that not all\n  // upstreams get hit.\n  num_upstreams_ = 2;\n  std::set<std::string> served_by;\n  sendMultipleRequests(\n      1024,\n      Http::TestHeaderMapImpl{{\":method\", \"POST\"},\n                              {\":path\", \"/test/long/url\"},\n                              {\":scheme\", \"http\"},\n                              {\":authority\", \"host\"}},\n      [&](IntegrationStreamDecoder& response) {\n        EXPECT_EQ(\"200\", response.headers().Status()->value().getStringView());\n        EXPECT_TRUE(response.headers().get(Http::Headers::get().SetCookie) == nullptr);\n        served_by.insert(std::string(\n            response.headers().get(Http::LowerCaseString(\"x-served-by\"))->value().getStringView()));\n      });\n  EXPECT_EQ(served_by.size(), num_upstreams_);\n}\n\nTEST_P(Http2RingHashIntegrationTest, CookieRoutingNoCookieWithNonzeroTtlSet) {\n  config_helper_.addConfigModifier(\n      [&](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager& hcm)\n          -> void {\n        auto* hash_policy = hcm.mutable_route_config()\n                                ->mutable_virtual_hosts(0)\n                                ->mutable_routes(0)\n                                ->mutable_route()\n                                ->add_hash_policy();\n        auto* cookie = hash_policy->mutable_cookie();\n        cookie->set_name(\"foo\");\n        cookie->mutable_ttl()->set_seconds(15);\n      });\n\n  std::set<std::string> set_cookies;\n  sendMultipleRequests(\n      1024,\n      Http::TestHeaderMapImpl{{\":method\", \"POST\"},\n                              {\":path\", \"/test/long/url\"},\n                              {\":scheme\", \"http\"},\n                              {\":authority\", \"host\"}},\n      [&](IntegrationStreamDecoder& response) {\n        EXPECT_EQ(\"200\", response.headers().Status()->value().getStringView());\n        std::string value(\n            response.headers().get(Http::Headers::get().SetCookie)->value().getStringView());\n        set_cookies.insert(value);\n        EXPECT_THAT(value, MatchesRegex(\"foo=.*; Max-Age=15; HttpOnly\"));\n      });\n  EXPECT_EQ(set_cookies.size(), 1);\n}\n\nTEST_P(Http2RingHashIntegrationTest, CookieRoutingNoCookieWithZeroTtlSet) {\n  config_helper_.addConfigModifier(\n      [&](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager& hcm)\n          -> void {\n        auto* hash_policy = hcm.mutable_route_config()\n                                ->mutable_virtual_hosts(0)\n                                ->mutable_routes(0)\n                                ->mutable_route()\n                                ->add_hash_policy();\n        auto* cookie = hash_policy->mutable_cookie();\n        cookie->set_name(\"foo\");\n        cookie->mutable_ttl();\n      });\n\n  std::set<std::string> set_cookies;\n  sendMultipleRequests(\n      1024,\n      Http::TestHeaderMapImpl{{\":method\", \"POST\"},\n                              {\":path\", \"/test/long/url\"},\n                              {\":scheme\", \"http\"},\n                              {\":authority\", \"host\"}},\n      [&](IntegrationStreamDecoder& response) {\n        EXPECT_EQ(\"200\", response.headers().Status()->value().getStringView());\n        std::string value(\n            response.headers().get(Http::Headers::get().SetCookie)->value().getStringView());\n        set_cookies.insert(value);\n        EXPECT_THAT(value, MatchesRegex(\"^foo=.*$\"));\n      });\n  EXPECT_EQ(set_cookies.size(), 1);\n}\n\nTEST_P(Http2RingHashIntegrationTest, CookieRoutingWithCookieNoTtl) {\n  config_helper_.addConfigModifier(\n      [&](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager& hcm)\n          -> void {\n        auto* hash_policy = hcm.mutable_route_config()\n                                ->mutable_virtual_hosts(0)\n                                ->mutable_routes(0)\n                                ->mutable_route()\n                                ->add_hash_policy();\n        auto* cookie = hash_policy->mutable_cookie();\n        cookie->set_name(\"foo\");\n      });\n\n  std::set<std::string> served_by;\n  sendMultipleRequests(\n      1024,\n      Http::TestHeaderMapImpl{{\":method\", \"POST\"},\n                              {\"cookie\", \"foo=bar\"},\n                              {\":path\", \"/test/long/url\"},\n                              {\":scheme\", \"http\"},\n                              {\":authority\", \"host\"}},\n      [&](IntegrationStreamDecoder& response) {\n        EXPECT_EQ(\"200\", response.headers().Status()->value().getStringView());\n        EXPECT_TRUE(response.headers().get(Http::Headers::get().SetCookie) == nullptr);\n        served_by.insert(std::string(\n            response.headers().get(Http::LowerCaseString(\"x-served-by\"))->value().getStringView()));\n      });\n  EXPECT_EQ(served_by.size(), 1);\n}\n\nTEST_P(Http2RingHashIntegrationTest, CookieRoutingWithCookieWithTtlSet) {\n  config_helper_.addConfigModifier(\n      [&](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager& hcm)\n          -> void {\n        auto* hash_policy = hcm.mutable_route_config()\n                                ->mutable_virtual_hosts(0)\n                                ->mutable_routes(0)\n                                ->mutable_route()\n                                ->add_hash_policy();\n        auto* cookie = hash_policy->mutable_cookie();\n        cookie->set_name(\"foo\");\n        cookie->mutable_ttl()->set_seconds(15);\n      });\n\n  std::set<std::string> served_by;\n  sendMultipleRequests(\n      1024,\n      Http::TestHeaderMapImpl{{\":method\", \"POST\"},\n                              {\"cookie\", \"foo=bar\"},\n                              {\":path\", \"/test/long/url\"},\n                              {\":scheme\", \"http\"},\n                              {\":authority\", \"host\"}},\n      [&](IntegrationStreamDecoder& response) {\n        EXPECT_EQ(\"200\", response.headers().Status()->value().getStringView());\n        EXPECT_TRUE(response.headers().get(Http::Headers::get().SetCookie) == nullptr);\n        served_by.insert(std::string(\n            response.headers().get(Http::LowerCaseString(\"x-served-by\"))->value().getStringView()));\n      });\n  EXPECT_EQ(served_by.size(), 1);\n}\n\nnamespace {\nconst int64_t TransmitThreshold = 100 * 1024 * 1024;\n} // namespace\n\nvoid Http2FloodMitigationTest::setNetworkConnectionBufferSize() {\n  // nghttp2 library has its own internal mitigation for outbound control frames. The mitigation is\n  // triggered when there are more than 10000 PING or SETTINGS frames with ACK flag in the nghttp2\n  // internal outbound queue. It is possible to trigger this mitigation in nghttp2 before triggering\n  // Envoy's own flood mitigation. This can happen when a buffer larger enough to contain over 10K\n  // PING or SETTINGS frames is dispatched to the nghttp2 library. To prevent this from happening\n  // the network connection receive buffer needs to be smaller than 90Kb (which is 10K SETTINGS\n  // frames). Set it to the arbitrarily chosen value of 32K.\n  config_helper_.addConfigModifier([](envoy::config::bootstrap::v2::Bootstrap& bootstrap) -> void {\n    RELEASE_ASSERT(bootstrap.mutable_static_resources()->listeners_size() >= 1, \"\");\n    auto* listener = bootstrap.mutable_static_resources()->mutable_listeners(0);\n    listener->mutable_per_connection_buffer_limit_bytes()->set_value(32 * 1024);\n  });\n}\n\nvoid Http2FloodMitigationTest::beginSession() {\n  setDownstreamProtocol(Http::CodecClient::Type::HTTP2);\n  setUpstreamProtocol(FakeHttpConnection::Type::HTTP2);\n  // set lower outbound frame limits to make tests run faster\n  config_helper_.setOutboundFramesLimits(1000, 100);\n  initialize();\n  tcp_client_ = makeTcpConnection(lookupPort(\"http\"));\n  startHttp2Session();\n}\n\nHttp2Frame Http2FloodMitigationTest::readFrame() {\n  Http2Frame frame;\n  tcp_client_->waitForData(frame.HeaderSize);\n  frame.setHeader(tcp_client_->data());\n  tcp_client_->clearData(frame.HeaderSize);\n  auto len = frame.payloadSize();\n  if (len) {\n    tcp_client_->waitForData(len);\n    frame.setPayload(tcp_client_->data());\n    tcp_client_->clearData(len);\n  }\n  return frame;\n}\n\nvoid Http2FloodMitigationTest::sendFame(const Http2Frame& frame) {\n  ASSERT_TRUE(tcp_client_->connected());\n  tcp_client_->write(std::string(frame), false, false);\n}\n\nvoid Http2FloodMitigationTest::startHttp2Session() {\n  tcp_client_->write(Http2Frame::Preamble, false, false);\n\n  // Send empty initial SETTINGS frame.\n  auto settings = Http2Frame::makeEmptySettingsFrame();\n  tcp_client_->write(std::string(settings), false, false);\n\n  // Read initial SETTINGS frame from the server.\n  readFrame();\n\n  // Send an SETTINGS ACK.\n  settings = Http2Frame::makeEmptySettingsFrame(Http2Frame::SettingsFlags::ACK);\n  tcp_client_->write(std::string(settings), false, false);\n\n  // read pending SETTINGS and WINDOW_UPDATE frames\n  readFrame();\n  readFrame();\n}\n\n// Verify that the server detects the flood of the given frame.\nvoid Http2FloodMitigationTest::floodServer(const Http2Frame& frame, const std::string& flood_stat) {\n  // pack the as many frames as we can into 16k buffer\n  const int FrameCount = (16 * 1024) / frame.size();\n  std::vector<char> buf(FrameCount * frame.size());\n  for (auto pos = buf.begin(); pos != buf.end();) {\n    pos = std::copy(frame.begin(), frame.end(), pos);\n  }\n\n  tcp_client_->readDisable(true);\n  int64_t total_bytes_sent = 0;\n  // If the flood protection is not working this loop will keep going\n  // forever until it is killed by blaze timer or run out of memory.\n  // Add early stop if we have sent more than 100M of frames, as it this\n  // point it is obvious something is wrong.\n  while (total_bytes_sent < TransmitThreshold && tcp_client_->connected()) {\n    tcp_client_->write({buf.begin(), buf.end()}, false, false);\n    total_bytes_sent += buf.size();\n  }\n\n  EXPECT_LE(total_bytes_sent, TransmitThreshold) << \"Flood mitigation is broken.\";\n  EXPECT_EQ(1, test_server_->counter(flood_stat)->value());\n  EXPECT_EQ(1,\n            test_server_->counter(\"http.config_test.downstream_cx_delayed_close_timeout\")->value());\n}\n\n// Verify that the server detects the flood using specified request parameters.\nvoid Http2FloodMitigationTest::floodServer(absl::string_view host, absl::string_view path,\n                                           Http2Frame::ResponseStatus expected_http_status,\n                                           const std::string& flood_stat) {\n  uint32_t request_idx = 0;\n  auto request = Http2Frame::makeRequest(request_idx, host, path);\n  sendFame(request);\n  auto frame = readFrame();\n  EXPECT_EQ(Http2Frame::Type::HEADERS, frame.type());\n  EXPECT_EQ(expected_http_status, frame.responseStatus());\n  tcp_client_->readDisable(true);\n  uint64_t total_bytes_sent = 0;\n  while (total_bytes_sent < TransmitThreshold && tcp_client_->connected()) {\n    request = Http2Frame::makeRequest(++request_idx, host, path);\n    sendFame(request);\n    total_bytes_sent += request.size();\n  }\n  EXPECT_LE(total_bytes_sent, TransmitThreshold) << \"Flood mitigation is broken.\";\n  if (!flood_stat.empty()) {\n    EXPECT_EQ(1, test_server_->counter(flood_stat)->value());\n  }\n  EXPECT_EQ(1,\n            test_server_->counter(\"http.config_test.downstream_cx_delayed_close_timeout\")->value());\n}\n\nINSTANTIATE_TEST_SUITE_P(IpVersions, Http2FloodMitigationTest,\n                         testing::ValuesIn(TestEnvironment::getIpVersionsForTest()),\n                         TestUtility::ipTestParamsToString);\n\nTEST_P(Http2FloodMitigationTest, Ping) {\n  setNetworkConnectionBufferSize();\n  beginSession();\n  floodServer(Http2Frame::makePingFrame(), \"http2.outbound_control_flood\");\n}\n\nTEST_P(Http2FloodMitigationTest, Settings) {\n  setNetworkConnectionBufferSize();\n  beginSession();\n  floodServer(Http2Frame::makeEmptySettingsFrame(), \"http2.outbound_control_flood\");\n}\n\n// Verify that the server can detect flood of internally generated 404 responses.\nTEST_P(Http2FloodMitigationTest, 404) {\n  // Change the default route to be restrictive, and send a request to a non existent route.\n  config_helper_.setDefaultHostAndRoute(\"foo.com\", \"/found\");\n  beginSession();\n\n  // Send requests to a non existent path to generate 404s\n  floodServer(\"host\", \"/notfound\", Http2Frame::ResponseStatus::_404, \"http2.outbound_flood\");\n}\n\n// Verify that the server can detect flood of DATA frames\nTEST_P(Http2FloodMitigationTest, Data) {\n  // Set large buffer limits so the test is not affected by the flow control.\n  config_helper_.setBufferLimits(1024 * 1024 * 1024, 1024 * 1024 * 1024);\n  autonomous_upstream_ = true;\n  beginSession();\n  fake_upstreams_[0]->set_allow_unexpected_disconnects(true);\n\n  floodServer(\"host\", \"/test/long/url\", Http2Frame::ResponseStatus::_200, \"http2.outbound_flood\");\n}\n\n// Verify that the server can detect flood of RST_STREAM frames.\nTEST_P(Http2FloodMitigationTest, RST_STREAM) {\n  // Use invalid HTTP headers to trigger sending RST_STREAM frames.\n  config_helper_.addConfigModifier(\n      [](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager& hcm)\n          -> void {\n        hcm.mutable_http2_protocol_options()->set_stream_error_on_invalid_http_messaging(true);\n      });\n  beginSession();\n\n  int i = 0;\n  auto request = Http::Http2::Http2Frame::makeMalformedRequest(i);\n  sendFame(request);\n  auto response = readFrame();\n  // Make sure we've got RST_STREAM from the server\n  EXPECT_EQ(Http2Frame::Type::RST_STREAM, response.type());\n  uint64_t total_bytes_sent = 0;\n  while (total_bytes_sent < TransmitThreshold && tcp_client_->connected()) {\n    request = Http::Http2::Http2Frame::makeMalformedRequest(++i);\n    sendFame(request);\n    total_bytes_sent += request.size();\n  }\n  EXPECT_LE(total_bytes_sent, TransmitThreshold) << \"Flood mitigation is broken.\";\n  EXPECT_EQ(1, test_server_->counter(\"http2.outbound_control_flood\")->value());\n  EXPECT_EQ(1,\n            test_server_->counter(\"http.config_test.downstream_cx_delayed_close_timeout\")->value());\n}\n\n// Verify that the server stop reading downstream connection on protocol error.\nTEST_P(Http2FloodMitigationTest, TooManyStreams) {\n  config_helper_.addConfigModifier(\n      [](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager& hcm)\n          -> void {\n        hcm.mutable_http2_protocol_options()->mutable_max_concurrent_streams()->set_value(2);\n      });\n  autonomous_upstream_ = true;\n  beginSession();\n  fake_upstreams_[0]->set_allow_unexpected_disconnects(true);\n\n  // Exceed the number of streams allowed by the server. The server should stop reading from the\n  // client. Verify that the client was unable to stuff a lot of data into the server.\n  floodServer(\"host\", \"/test/long/url\", Http2Frame::ResponseStatus::_200, \"\");\n}\n\nTEST_P(Http2FloodMitigationTest, EmptyHeaders) {\n  config_helper_.addConfigModifier(\n      [&](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager& hcm)\n          -> void {\n        hcm.mutable_http2_protocol_options()\n            ->mutable_max_consecutive_inbound_frames_with_empty_payload()\n            ->set_value(0);\n      });\n  beginSession();\n\n  uint32_t request_idx = 0;\n  auto request = Http2Frame::makeEmptyHeadersFrame(request_idx);\n  sendFame(request);\n\n  tcp_client_->waitForDisconnect();\n\n  EXPECT_EQ(1, test_server_->counter(\"http2.inbound_empty_frames_flood\")->value());\n  EXPECT_EQ(1,\n            test_server_->counter(\"http.config_test.downstream_cx_delayed_close_timeout\")->value());\n}\n\nTEST_P(Http2FloodMitigationTest, EmptyHeadersContinuation) {\n  beginSession();\n\n  uint32_t request_idx = 0;\n  auto request = Http2Frame::makeEmptyHeadersFrame(request_idx);\n  sendFame(request);\n\n  for (int i = 0; i < 2; i++) {\n    request = Http2Frame::makeEmptyContinuationFrame(request_idx);\n    sendFame(request);\n  }\n\n  tcp_client_->waitForDisconnect();\n\n  EXPECT_EQ(1, test_server_->counter(\"http2.inbound_empty_frames_flood\")->value());\n  EXPECT_EQ(1,\n            test_server_->counter(\"http.config_test.downstream_cx_delayed_close_timeout\")->value());\n}\n\nTEST_P(Http2FloodMitigationTest, EmptyData) {\n  beginSession();\n  fake_upstreams_[0]->set_allow_unexpected_disconnects(true);\n\n  uint32_t request_idx = 0;\n  auto request = Http2Frame::makePostRequest(request_idx, \"host\", \"/\");\n  sendFame(request);\n\n  for (int i = 0; i < 2; i++) {\n    request = Http2Frame::makeEmptyDataFrame(request_idx);\n    sendFame(request);\n  }\n\n  tcp_client_->waitForDisconnect();\n\n  EXPECT_EQ(1, test_server_->counter(\"http2.inbound_empty_frames_flood\")->value());\n  EXPECT_EQ(1,\n            test_server_->counter(\"http.config_test.downstream_cx_delayed_close_timeout\")->value());\n}\n\nTEST_P(Http2FloodMitigationTest, PriorityIdleStream) {\n  beginSession();\n\n  floodServer(Http2Frame::makePriorityFrame(0, 1), \"http2.inbound_priority_frames_flood\");\n}\n\nTEST_P(Http2FloodMitigationTest, PriorityOpenStream) {\n  beginSession();\n  fake_upstreams_[0]->set_allow_unexpected_disconnects(true);\n\n  // Open stream.\n  uint32_t request_idx = 0;\n  auto request = Http2Frame::makeRequest(request_idx, \"host\", \"/\");\n  sendFame(request);\n\n  floodServer(Http2Frame::makePriorityFrame(request_idx, request_idx + 1),\n              \"http2.inbound_priority_frames_flood\");\n}\n\nTEST_P(Http2FloodMitigationTest, PriorityClosedStream) {\n  autonomous_upstream_ = true;\n  beginSession();\n  fake_upstreams_[0]->set_allow_unexpected_disconnects(true);\n\n  // Open stream.\n  uint32_t request_idx = 0;\n  auto request = Http2Frame::makeRequest(request_idx, \"host\", \"/\");\n  sendFame(request);\n  // Reading response marks this stream as closed in nghttp2.\n  auto frame = readFrame();\n  EXPECT_EQ(Http2Frame::Type::HEADERS, frame.type());\n\n  floodServer(Http2Frame::makePriorityFrame(request_idx, request_idx + 1),\n              \"http2.inbound_priority_frames_flood\");\n}\n\nTEST_P(Http2FloodMitigationTest, WindowUpdate) {\n  beginSession();\n  fake_upstreams_[0]->set_allow_unexpected_disconnects(true);\n\n  // Open stream.\n  uint32_t request_idx = 0;\n  auto request = Http2Frame::makeRequest(request_idx, \"host\", \"/\");\n  sendFame(request);\n\n  floodServer(Http2Frame::makeWindowUpdateFrame(request_idx, 1),\n              \"http2.inbound_window_update_frames_flood\");\n}\n\n// Verify that the HTTP/2 connection is terminated upon receiving invalid HEADERS frame.\nTEST_P(Http2FloodMitigationTest, ZerolenHeader) {\n  beginSession();\n\n  // Send invalid request.\n  uint32_t request_idx = 0;\n  auto request = Http2Frame::makeMalformedRequestWithZerolenHeader(request_idx, \"host\", \"/\");\n  sendFame(request);\n\n  tcp_client_->waitForDisconnect();\n\n  EXPECT_EQ(1, test_server_->counter(\"http2.rx_messaging_error\")->value());\n  EXPECT_EQ(1,\n            test_server_->counter(\"http.config_test.downstream_cx_delayed_close_timeout\")->value());\n}\n\n// Verify that only the offending stream is terminated upon receiving invalid HEADERS frame.\nTEST_P(Http2FloodMitigationTest, ZerolenHeaderAllowed) {\n  config_helper_.addConfigModifier(\n      [](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager& hcm)\n          -> void {\n        hcm.mutable_http2_protocol_options()->set_stream_error_on_invalid_http_messaging(true);\n      });\n  autonomous_upstream_ = true;\n  beginSession();\n  fake_upstreams_[0]->set_allow_unexpected_disconnects(true);\n\n  // Send invalid request.\n  uint32_t request_idx = 0;\n  auto request = Http2Frame::makeMalformedRequestWithZerolenHeader(request_idx, \"host\", \"/\");\n  sendFame(request);\n  // Make sure we've got RST_STREAM from the server.\n  auto response = readFrame();\n  EXPECT_EQ(Http2Frame::Type::RST_STREAM, response.type());\n\n  // Send valid request using the same connection.\n  request_idx++;\n  request = Http2Frame::makeRequest(request_idx, \"host\", \"/\");\n  sendFame(request);\n  response = readFrame();\n  EXPECT_EQ(Http2Frame::Type::HEADERS, response.type());\n  EXPECT_EQ(Http2Frame::ResponseStatus::_200, response.responseStatus());\n\n  tcp_client_->close();\n\n  EXPECT_EQ(1, test_server_->counter(\"http2.rx_messaging_error\")->value());\n  EXPECT_EQ(0,\n            test_server_->counter(\"http.config_test.downstream_cx_delayed_close_timeout\")->value());\n}\n\n} // namespace Envoy\n", "#include \"test/integration/http_integration.h\"\n\n#include <functional>\n#include <list>\n#include <memory>\n#include <regex>\n#include <string>\n#include <vector>\n\n#include \"envoy/buffer/buffer.h\"\n#include \"envoy/event/dispatcher.h\"\n#include \"envoy/http/header_map.h\"\n#include \"envoy/network/address.h\"\n#include \"envoy/registry/registry.h\"\n\n#include \"common/api/api_impl.h\"\n#include \"common/buffer/buffer_impl.h\"\n#include \"common/common/fmt.h\"\n#include \"common/common/thread_annotations.h\"\n#include \"common/http/headers.h\"\n#include \"common/network/utility.h\"\n#include \"common/protobuf/utility.h\"\n#include \"common/runtime/runtime_impl.h\"\n#include \"common/upstream/upstream_impl.h\"\n\n#include \"test/common/upstream/utility.h\"\n#include \"test/integration/autonomous_upstream.h\"\n#include \"test/integration/test_host_predicate_config.h\"\n#include \"test/integration/utility.h\"\n#include \"test/mocks/upstream/mocks.h\"\n#include \"test/test_common/environment.h\"\n#include \"test/test_common/network_utility.h\"\n#include \"test/test_common/registry.h\"\n\n#include \"gtest/gtest.h\"\n\nnamespace Envoy {\nnamespace {\n\nenvoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager::CodecType\ntypeToCodecType(Http::CodecClient::Type type) {\n  switch (type) {\n  case Http::CodecClient::Type::HTTP1:\n    return envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager::\n        HTTP1;\n  case Http::CodecClient::Type::HTTP2:\n    return envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager::\n        HTTP2;\n  default:\n    RELEASE_ASSERT(0, \"\");\n  }\n}\n\n} // namespace\n\nIntegrationCodecClient::IntegrationCodecClient(\n    Event::Dispatcher& dispatcher, Network::ClientConnectionPtr&& conn,\n    Upstream::HostDescriptionConstSharedPtr host_description, CodecClient::Type type)\n    : CodecClientProd(type, std::move(conn), host_description, dispatcher), dispatcher_(dispatcher),\n      callbacks_(*this), codec_callbacks_(*this) {\n  connection_->addConnectionCallbacks(callbacks_);\n  setCodecConnectionCallbacks(codec_callbacks_);\n  dispatcher.run(Event::Dispatcher::RunType::Block);\n}\n\nvoid IntegrationCodecClient::flushWrite() {\n  connection_->dispatcher().run(Event::Dispatcher::RunType::NonBlock);\n  // NOTE: We should run blocking until all the body data is flushed.\n}\n\nIntegrationStreamDecoderPtr\nIntegrationCodecClient::makeHeaderOnlyRequest(const Http::HeaderMap& headers) {\n  auto response = std::make_unique<IntegrationStreamDecoder>(dispatcher_);\n  Http::StreamEncoder& encoder = newStream(*response);\n  encoder.getStream().addCallbacks(*response);\n  encoder.encodeHeaders(headers, true);\n  flushWrite();\n  return response;\n}\n\nIntegrationStreamDecoderPtr\nIntegrationCodecClient::makeRequestWithBody(const Http::HeaderMap& headers, uint64_t body_size) {\n  return makeRequestWithBody(headers, std::string(body_size, 'a'));\n}\n\nIntegrationStreamDecoderPtr\nIntegrationCodecClient::makeRequestWithBody(const Http::HeaderMap& headers,\n                                            const std::string& body) {\n  auto response = std::make_unique<IntegrationStreamDecoder>(dispatcher_);\n  Http::StreamEncoder& encoder = newStream(*response);\n  encoder.getStream().addCallbacks(*response);\n  encoder.encodeHeaders(headers, false);\n  Buffer::OwnedImpl data(body);\n  encoder.encodeData(data, true);\n  flushWrite();\n  return response;\n}\n\nvoid IntegrationCodecClient::sendData(Http::StreamEncoder& encoder, absl::string_view data,\n                                      bool end_stream) {\n  Buffer::OwnedImpl buffer_data(data.data(), data.size());\n  encoder.encodeData(buffer_data, end_stream);\n  flushWrite();\n}\n\nvoid IntegrationCodecClient::sendData(Http::StreamEncoder& encoder, Buffer::Instance& data,\n                                      bool end_stream) {\n  encoder.encodeData(data, end_stream);\n  flushWrite();\n}\n\nvoid IntegrationCodecClient::sendData(Http::StreamEncoder& encoder, uint64_t size,\n                                      bool end_stream) {\n  Buffer::OwnedImpl data(std::string(size, 'a'));\n  sendData(encoder, data, end_stream);\n}\n\nvoid IntegrationCodecClient::sendTrailers(Http::StreamEncoder& encoder,\n                                          const Http::HeaderMap& trailers) {\n  encoder.encodeTrailers(trailers);\n  flushWrite();\n}\n\nvoid IntegrationCodecClient::sendReset(Http::StreamEncoder& encoder) {\n  encoder.getStream().resetStream(Http::StreamResetReason::LocalReset);\n  flushWrite();\n}\n\nvoid IntegrationCodecClient::sendMetadata(Http::StreamEncoder& encoder,\n                                          Http::MetadataMap metadata_map) {\n  Http::MetadataMapPtr metadata_map_ptr = std::make_unique<Http::MetadataMap>(metadata_map);\n  Http::MetadataMapVector metadata_map_vector;\n  metadata_map_vector.push_back(std::move(metadata_map_ptr));\n  encoder.encodeMetadata(metadata_map_vector);\n  flushWrite();\n}\n\nstd::pair<Http::StreamEncoder&, IntegrationStreamDecoderPtr>\nIntegrationCodecClient::startRequest(const Http::HeaderMap& headers) {\n  auto response = std::make_unique<IntegrationStreamDecoder>(dispatcher_);\n  Http::StreamEncoder& encoder = newStream(*response);\n  encoder.getStream().addCallbacks(*response);\n  encoder.encodeHeaders(headers, false);\n  flushWrite();\n  return {encoder, std::move(response)};\n}\n\nbool IntegrationCodecClient::waitForDisconnect(std::chrono::milliseconds time_to_wait) {\n  Event::TimerPtr wait_timer;\n  bool wait_timer_triggered = false;\n  if (time_to_wait.count()) {\n    wait_timer = connection_->dispatcher().createTimer([this, &wait_timer_triggered] {\n      connection_->dispatcher().exit();\n      wait_timer_triggered = true;\n    });\n    wait_timer->enableTimer(time_to_wait);\n  }\n\n  connection_->dispatcher().run(Event::Dispatcher::RunType::Block);\n\n  // Disable the timer if it was created. This call is harmless if the timer already triggered.\n  if (wait_timer) {\n    wait_timer->disableTimer();\n  }\n\n  if (wait_timer_triggered && !disconnected_) {\n    return false;\n  }\n  EXPECT_TRUE(disconnected_);\n\n  return true;\n}\n\nvoid IntegrationCodecClient::ConnectionCallbacks::onEvent(Network::ConnectionEvent event) {\n  parent_.last_connection_event_ = event;\n  if (event == Network::ConnectionEvent::Connected) {\n    parent_.connected_ = true;\n    parent_.connection_->dispatcher().exit();\n  } else if (event == Network::ConnectionEvent::RemoteClose) {\n    parent_.disconnected_ = true;\n    parent_.connection_->dispatcher().exit();\n  } else {\n    parent_.disconnected_ = true;\n  }\n}\n\nIntegrationCodecClientPtr HttpIntegrationTest::makeHttpConnection(uint32_t port) {\n  return makeHttpConnection(makeClientConnection(port));\n}\n\nIntegrationCodecClientPtr\nHttpIntegrationTest::makeRawHttpConnection(Network::ClientConnectionPtr&& conn) {\n  std::shared_ptr<Upstream::MockClusterInfo> cluster{new NiceMock<Upstream::MockClusterInfo>()};\n  cluster->http2_settings_.allow_connect_ = true;\n  cluster->http2_settings_.allow_metadata_ = true;\n  Upstream::HostDescriptionConstSharedPtr host_description{Upstream::makeTestHostDescription(\n      cluster, fmt::format(\"tcp://{}:80\", Network::Test::getLoopbackAddressUrlString(version_)))};\n  return std::make_unique<IntegrationCodecClient>(*dispatcher_, std::move(conn), host_description,\n                                                  downstream_protocol_);\n}\n\nIntegrationCodecClientPtr\nHttpIntegrationTest::makeHttpConnection(Network::ClientConnectionPtr&& conn) {\n  auto codec = makeRawHttpConnection(std::move(conn));\n  EXPECT_TRUE(codec->connected());\n  return codec;\n}\n\nHttpIntegrationTest::HttpIntegrationTest(Http::CodecClient::Type downstream_protocol,\n                                         Network::Address::IpVersion version,\n                                         const std::string& config)\n    : HttpIntegrationTest::HttpIntegrationTest(\n          downstream_protocol,\n          [version](int) {\n            return Network::Utility::parseInternetAddress(\n                Network::Test::getAnyAddressString(version), 0);\n          },\n          version, config) {}\n\nHttpIntegrationTest::HttpIntegrationTest(Http::CodecClient::Type downstream_protocol,\n                                         const InstanceConstSharedPtrFn& upstream_address_fn,\n                                         Network::Address::IpVersion version,\n                                         const std::string& config)\n    : BaseIntegrationTest(upstream_address_fn, version, config),\n      downstream_protocol_(downstream_protocol) {\n  // Legacy integration tests expect the default listener to be named \"http\" for\n  // lookupPort calls.\n  config_helper_.renameListener(\"http\");\n  config_helper_.setClientCodec(typeToCodecType(downstream_protocol_));\n}\n\nvoid HttpIntegrationTest::useAccessLog() {\n  access_log_name_ = TestEnvironment::temporaryPath(TestUtility::uniqueFilename());\n  ASSERT_TRUE(config_helper_.setAccessLog(access_log_name_));\n}\n\nHttpIntegrationTest::~HttpIntegrationTest() {\n  cleanupUpstreamAndDownstream();\n  test_server_.reset();\n  fake_upstreams_.clear();\n}\n\nstd::string HttpIntegrationTest::waitForAccessLog(const std::string& filename) {\n  // Wait a max of 1s for logs to flush to disk.\n  for (int i = 0; i < 1000; ++i) {\n    std::string contents = TestEnvironment::readFileToStringForTest(filename, false);\n    if (contents.length() > 0) {\n      return contents;\n    }\n    usleep(1000);\n  }\n  RELEASE_ASSERT(0, \"Timed out waiting for access log\");\n  return \"\";\n}\n\nvoid HttpIntegrationTest::setDownstreamProtocol(Http::CodecClient::Type downstream_protocol) {\n  downstream_protocol_ = downstream_protocol;\n  config_helper_.setClientCodec(typeToCodecType(downstream_protocol_));\n}\n\nIntegrationStreamDecoderPtr HttpIntegrationTest::sendRequestAndWaitForResponse(\n    const Http::TestHeaderMapImpl& request_headers, uint32_t request_body_size,\n    const Http::TestHeaderMapImpl& response_headers, uint32_t response_size, int upstream_index,\n    std::chrono::milliseconds time) {\n  ASSERT(codec_client_ != nullptr);\n  // Send the request to Envoy.\n  IntegrationStreamDecoderPtr response;\n  if (request_body_size) {\n    response = codec_client_->makeRequestWithBody(request_headers, request_body_size);\n  } else {\n    response = codec_client_->makeHeaderOnlyRequest(request_headers);\n  }\n  waitForNextUpstreamRequest(upstream_index, time);\n  // Send response headers, and end_stream if there is no response body.\n  upstream_request_->encodeHeaders(response_headers, response_size == 0);\n  // Send any response data, with end_stream true.\n  if (response_size) {\n    upstream_request_->encodeData(response_size, true);\n  }\n  // Wait for the response to be read by the codec client.\n  response->waitForEndStream();\n  return response;\n}\n\nvoid HttpIntegrationTest::cleanupUpstreamAndDownstream() {\n  // Close the upstream connection first. If there's an outstanding request,\n  // closing the client may result in a FIN being sent upstream, and FakeConnectionBase::close\n  // will interpret that as an unexpected disconnect. The codec client is not\n  // subject to the same failure mode.\n  if (fake_upstream_connection_) {\n    AssertionResult result = fake_upstream_connection_->close();\n    RELEASE_ASSERT(result, result.message());\n    result = fake_upstream_connection_->waitForDisconnect();\n    RELEASE_ASSERT(result, result.message());\n    fake_upstream_connection_.reset();\n  }\n  if (codec_client_) {\n    codec_client_->close();\n  }\n}\n\nvoid HttpIntegrationTest::sendRequestAndVerifyResponse(\n    const Http::TestHeaderMapImpl& request_headers, const int request_size,\n    const Http::TestHeaderMapImpl& response_headers, const int response_size,\n    const int backend_idx) {\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  auto response = sendRequestAndWaitForResponse(request_headers, request_size, response_headers,\n                                                response_size, backend_idx);\n  verifyResponse(std::move(response), \"200\", response_headers, std::string(response_size, 'a'));\n\n  EXPECT_TRUE(upstream_request_->complete());\n  EXPECT_EQ(request_size, upstream_request_->bodyLength());\n  cleanupUpstreamAndDownstream();\n}\n\nvoid HttpIntegrationTest::verifyResponse(IntegrationStreamDecoderPtr response,\n                                         const std::string& response_code,\n                                         const Http::TestHeaderMapImpl& expected_headers,\n                                         const std::string& expected_body) {\n  EXPECT_TRUE(response->complete());\n  EXPECT_EQ(response_code, response->headers().Status()->value().getStringView());\n  expected_headers.iterate(\n      [](const Http::HeaderEntry& header, void* context) -> Http::HeaderMap::Iterate {\n        auto response_headers = static_cast<Http::HeaderMap*>(context);\n        const Http::HeaderEntry* entry =\n            response_headers->get(Http::LowerCaseString{std::string(header.key().getStringView())});\n        EXPECT_NE(entry, nullptr);\n        EXPECT_EQ(header.value().getStringView(), entry->value().getStringView());\n        return Http::HeaderMap::Iterate::Continue;\n      },\n      const_cast<void*>(static_cast<const void*>(&response->headers())));\n\n  EXPECT_EQ(response->body(), expected_body);\n}\n\nuint64_t\nHttpIntegrationTest::waitForNextUpstreamRequest(const std::vector<uint64_t>& upstream_indices,\n                                                std::chrono::milliseconds connection_wait_timeout) {\n  uint64_t upstream_with_request;\n  // If there is no upstream connection, wait for it to be established.\n  if (!fake_upstream_connection_) {\n\n    AssertionResult result = AssertionFailure();\n    for (auto upstream_index : upstream_indices) {\n      result = fake_upstreams_[upstream_index]->waitForHttpConnection(\n          *dispatcher_, fake_upstream_connection_, connection_wait_timeout,\n          max_request_headers_kb_);\n      if (result) {\n        upstream_with_request = upstream_index;\n        break;\n      }\n    }\n    RELEASE_ASSERT(result, result.message());\n  }\n  // Wait for the next stream on the upstream connection.\n  AssertionResult result =\n      fake_upstream_connection_->waitForNewStream(*dispatcher_, upstream_request_);\n  RELEASE_ASSERT(result, result.message());\n  // Wait for the stream to be completely received.\n  result = upstream_request_->waitForEndStream(*dispatcher_);\n  RELEASE_ASSERT(result, result.message());\n\n  return upstream_with_request;\n}\n\nvoid HttpIntegrationTest::waitForNextUpstreamRequest(\n    uint64_t upstream_index, std::chrono::milliseconds connection_wait_timeout) {\n  waitForNextUpstreamRequest(std::vector<uint64_t>({upstream_index}), connection_wait_timeout);\n}\n\nvoid HttpIntegrationTest::checkSimpleRequestSuccess(uint64_t expected_request_size,\n                                                    uint64_t expected_response_size,\n                                                    IntegrationStreamDecoder* response) {\n  EXPECT_TRUE(upstream_request_->complete());\n  EXPECT_EQ(expected_request_size, upstream_request_->bodyLength());\n\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().Status()->value().getStringView());\n  EXPECT_EQ(expected_response_size, response->body().size());\n}\n\nvoid HttpIntegrationTest::testRouterRequestAndResponseWithBody(\n    uint64_t request_size, uint64_t response_size, bool big_header,\n    ConnectionCreationFunction* create_connection) {\n  initialize();\n  codec_client_ = makeHttpConnection(\n      create_connection ? ((*create_connection)()) : makeClientConnection((lookupPort(\"http\"))));\n  Http::TestHeaderMapImpl request_headers{\n      {\":method\", \"POST\"},    {\":path\", \"/test/long/url\"}, {\":scheme\", \"http\"},\n      {\":authority\", \"host\"}, {\"x-lyft-user-id\", \"123\"},   {\"x-forwarded-for\", \"10.0.0.1\"}};\n  if (big_header) {\n    request_headers.addCopy(\"big\", std::string(4096, 'a'));\n  }\n  auto response = sendRequestAndWaitForResponse(request_headers, request_size,\n                                                default_response_headers_, response_size);\n  checkSimpleRequestSuccess(request_size, response_size, response.get());\n}\n\nIntegrationStreamDecoderPtr\nHttpIntegrationTest::makeHeaderOnlyRequest(ConnectionCreationFunction* create_connection,\n                                           int upstream_index, const std::string& path,\n                                           const std::string& authority) {\n  // This is called multiple times per test in ads_integration_test. Only call\n  // initialize() the first time.\n  if (!initialized()) {\n    initialize();\n  }\n  codec_client_ = makeHttpConnection(\n      create_connection ? ((*create_connection)()) : makeClientConnection((lookupPort(\"http\"))));\n  Http::TestHeaderMapImpl request_headers{{\":method\", \"GET\"},\n                                          {\":path\", path},\n                                          {\":scheme\", \"http\"},\n                                          {\":authority\", authority},\n                                          {\"x-lyft-user-id\", \"123\"}};\n  return sendRequestAndWaitForResponse(request_headers, 0, default_response_headers_, 0,\n                                       upstream_index);\n}\n\nvoid HttpIntegrationTest::testRouterHeaderOnlyRequestAndResponse(\n    ConnectionCreationFunction* create_connection, int upstream_index, const std::string& path,\n    const std::string& authority) {\n  auto response = makeHeaderOnlyRequest(create_connection, upstream_index, path, authority);\n  checkSimpleRequestSuccess(0U, 0U, response.get());\n}\n\n// Change the default route to be restrictive, and send a request to an alternate route.\nvoid HttpIntegrationTest::testRouterNotFound() {\n  config_helper_.setDefaultHostAndRoute(\"foo.com\", \"/found\");\n  initialize();\n\n  BufferingStreamDecoderPtr response = IntegrationUtil::makeSingleRequest(\n      lookupPort(\"http\"), \"GET\", \"/notfound\", \"\", downstream_protocol_, version_);\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"404\", response->headers().Status()->value().getStringView());\n}\n\n// Change the default route to be restrictive, and send a POST to an alternate route.\nvoid HttpIntegrationTest::testRouterNotFoundWithBody() {\n  config_helper_.setDefaultHostAndRoute(\"foo.com\", \"/found\");\n  initialize();\n\n  BufferingStreamDecoderPtr response = IntegrationUtil::makeSingleRequest(\n      lookupPort(\"http\"), \"POST\", \"/notfound\", \"foo\", downstream_protocol_, version_);\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"404\", response->headers().Status()->value().getStringView());\n}\n\nvoid HttpIntegrationTest::testRouterUpstreamDisconnectBeforeRequestComplete() {\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  auto encoder_decoder = codec_client_->startRequest(default_request_headers_);\n  auto response = std::move(encoder_decoder.second);\n\n  ASSERT_TRUE(fake_upstreams_[0]->waitForHttpConnection(*dispatcher_, fake_upstream_connection_));\n\n  ASSERT_TRUE(fake_upstream_connection_->waitForNewStream(*dispatcher_, upstream_request_));\n  ASSERT_TRUE(upstream_request_->waitForHeadersComplete());\n  ASSERT_TRUE(fake_upstream_connection_->close());\n  ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());\n  response->waitForEndStream();\n\n  if (downstream_protocol_ == Http::CodecClient::Type::HTTP1) {\n    codec_client_->waitForDisconnect();\n  } else {\n    codec_client_->close();\n  }\n\n  EXPECT_FALSE(upstream_request_->complete());\n  EXPECT_EQ(0U, upstream_request_->bodyLength());\n\n  EXPECT_TRUE(response->complete());\n  EXPECT_EQ(\"503\", response->headers().Status()->value().getStringView());\n  EXPECT_EQ(\"upstream connect error or disconnect/reset before headers. reset reason: connection \"\n            \"termination\",\n            response->body());\n}\n\nvoid HttpIntegrationTest::testRouterUpstreamDisconnectBeforeResponseComplete(\n    ConnectionCreationFunction* create_connection) {\n  initialize();\n  codec_client_ = makeHttpConnection(\n      create_connection ? ((*create_connection)()) : makeClientConnection((lookupPort(\"http\"))));\n  auto response = codec_client_->makeHeaderOnlyRequest(default_request_headers_);\n  waitForNextUpstreamRequest();\n  upstream_request_->encodeHeaders(default_response_headers_, false);\n  ASSERT_TRUE(fake_upstream_connection_->close());\n  ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());\n\n  if (downstream_protocol_ == Http::CodecClient::Type::HTTP1) {\n    codec_client_->waitForDisconnect();\n  } else {\n    response->waitForReset();\n    codec_client_->close();\n  }\n\n  EXPECT_TRUE(upstream_request_->complete());\n  EXPECT_EQ(0U, upstream_request_->bodyLength());\n\n  EXPECT_FALSE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().Status()->value().getStringView());\n  EXPECT_EQ(0U, response->body().size());\n}\n\nvoid HttpIntegrationTest::testRouterDownstreamDisconnectBeforeRequestComplete(\n    ConnectionCreationFunction* create_connection) {\n  initialize();\n\n  codec_client_ = makeHttpConnection(\n      create_connection ? ((*create_connection)()) : makeClientConnection((lookupPort(\"http\"))));\n  auto encoder_decoder = codec_client_->startRequest(default_request_headers_);\n  auto response = std::move(encoder_decoder.second);\n  ASSERT_TRUE(fake_upstreams_[0]->waitForHttpConnection(*dispatcher_, fake_upstream_connection_));\n  ASSERT_TRUE(fake_upstream_connection_->waitForNewStream(*dispatcher_, upstream_request_));\n  ASSERT_TRUE(upstream_request_->waitForHeadersComplete());\n  codec_client_->close();\n\n  if (upstreamProtocol() == FakeHttpConnection::Type::HTTP1) {\n    ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());\n  } else {\n    ASSERT_TRUE(upstream_request_->waitForReset());\n    ASSERT_TRUE(fake_upstream_connection_->close());\n    ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());\n  }\n\n  EXPECT_FALSE(upstream_request_->complete());\n  EXPECT_EQ(0U, upstream_request_->bodyLength());\n\n  EXPECT_FALSE(response->complete());\n}\n\nvoid HttpIntegrationTest::testRouterDownstreamDisconnectBeforeResponseComplete(\n    ConnectionCreationFunction* create_connection) {\n#ifdef __APPLE__\n  // Skip this test on macOS: we can't detect the early close on macOS, and we\n  // won't clean up the upstream connection until it times out. See #4294.\n  if (downstream_protocol_ == Http::CodecClient::Type::HTTP1) {\n    return;\n  }\n#endif\n  initialize();\n  codec_client_ = makeHttpConnection(\n      create_connection ? ((*create_connection)()) : makeClientConnection((lookupPort(\"http\"))));\n  auto response = codec_client_->makeHeaderOnlyRequest(default_request_headers_);\n  waitForNextUpstreamRequest();\n  upstream_request_->encodeHeaders(default_response_headers_, false);\n  upstream_request_->encodeData(512, false);\n  response->waitForBodyData(512);\n  codec_client_->close();\n\n  if (upstreamProtocol() == FakeHttpConnection::Type::HTTP1) {\n    ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());\n  } else {\n    ASSERT_TRUE(upstream_request_->waitForReset());\n    ASSERT_TRUE(fake_upstream_connection_->close());\n    ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());\n  }\n\n  EXPECT_TRUE(upstream_request_->complete());\n  EXPECT_EQ(0U, upstream_request_->bodyLength());\n\n  EXPECT_FALSE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().Status()->value().getStringView());\n  EXPECT_EQ(512U, response->body().size());\n}\n\nvoid HttpIntegrationTest::testRouterUpstreamResponseBeforeRequestComplete() {\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  auto encoder_decoder = codec_client_->startRequest(default_request_headers_);\n  auto response = std::move(encoder_decoder.second);\n  ASSERT_TRUE(fake_upstreams_[0]->waitForHttpConnection(*dispatcher_, fake_upstream_connection_));\n  ASSERT_TRUE(fake_upstream_connection_->waitForNewStream(*dispatcher_, upstream_request_));\n  ASSERT_TRUE(upstream_request_->waitForHeadersComplete());\n  upstream_request_->encodeHeaders(default_response_headers_, false);\n  upstream_request_->encodeData(512, true);\n  response->waitForEndStream();\n\n  if (upstreamProtocol() == FakeHttpConnection::Type::HTTP1) {\n    ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());\n  } else {\n    ASSERT_TRUE(upstream_request_->waitForReset());\n    ASSERT_TRUE(fake_upstream_connection_->close());\n    ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());\n  }\n\n  if (downstream_protocol_ == Http::CodecClient::Type::HTTP1) {\n    codec_client_->waitForDisconnect();\n  } else {\n    codec_client_->close();\n  }\n\n  EXPECT_FALSE(upstream_request_->complete());\n  EXPECT_EQ(0U, upstream_request_->bodyLength());\n\n  EXPECT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().Status()->value().getStringView());\n  EXPECT_EQ(512U, response->body().size());\n}\n\nvoid HttpIntegrationTest::testRetry() {\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  auto response =\n      codec_client_->makeRequestWithBody(Http::TestHeaderMapImpl{{\":method\", \"POST\"},\n                                                                 {\":path\", \"/test/long/url\"},\n                                                                 {\":scheme\", \"http\"},\n                                                                 {\":authority\", \"host\"},\n                                                                 {\"x-forwarded-for\", \"10.0.0.1\"},\n                                                                 {\"x-envoy-retry-on\", \"5xx\"}},\n                                         1024);\n  waitForNextUpstreamRequest();\n  upstream_request_->encodeHeaders(Http::TestHeaderMapImpl{{\":status\", \"503\"}}, false);\n\n  if (fake_upstreams_[0]->httpType() == FakeHttpConnection::Type::HTTP1) {\n    ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());\n    ASSERT_TRUE(fake_upstreams_[0]->waitForHttpConnection(*dispatcher_, fake_upstream_connection_));\n  } else {\n    ASSERT_TRUE(upstream_request_->waitForReset());\n  }\n  waitForNextUpstreamRequest();\n  upstream_request_->encodeHeaders(default_response_headers_, false);\n  upstream_request_->encodeData(512, true);\n\n  response->waitForEndStream();\n  EXPECT_TRUE(upstream_request_->complete());\n  EXPECT_EQ(1024U, upstream_request_->bodyLength());\n\n  EXPECT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().Status()->value().getStringView());\n  EXPECT_EQ(512U, response->body().size());\n}\n\n// Tests that the x-envoy-attempt-count header is properly set on the upstream request\n// and updated after the request is retried.\nvoid HttpIntegrationTest::testRetryAttemptCountHeader() {\n  auto host = config_helper_.createVirtualHost(\"host\", \"/test_retry\");\n  host.set_include_request_attempt_count(true);\n  config_helper_.addVirtualHost(host);\n\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  auto response =\n      codec_client_->makeRequestWithBody(Http::TestHeaderMapImpl{{\":method\", \"POST\"},\n                                                                 {\":path\", \"/test_retry\"},\n                                                                 {\":scheme\", \"http\"},\n                                                                 {\":authority\", \"host\"},\n                                                                 {\"x-forwarded-for\", \"10.0.0.1\"},\n                                                                 {\"x-envoy-retry-on\", \"5xx\"}},\n                                         1024);\n  waitForNextUpstreamRequest();\n  upstream_request_->encodeHeaders(Http::TestHeaderMapImpl{{\":status\", \"503\"}}, false);\n\n  EXPECT_EQ(\n      atoi(std::string(upstream_request_->headers().EnvoyAttemptCount()->value().getStringView())\n               .c_str()),\n      1);\n\n  if (fake_upstreams_[0]->httpType() == FakeHttpConnection::Type::HTTP1) {\n    ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());\n    ASSERT_TRUE(fake_upstreams_[0]->waitForHttpConnection(*dispatcher_, fake_upstream_connection_));\n  } else {\n    ASSERT_TRUE(upstream_request_->waitForReset());\n  }\n  waitForNextUpstreamRequest();\n  EXPECT_EQ(\n      atoi(std::string(upstream_request_->headers().EnvoyAttemptCount()->value().getStringView())\n               .c_str()),\n      2);\n  upstream_request_->encodeHeaders(default_response_headers_, false);\n  upstream_request_->encodeData(512, true);\n\n  response->waitForEndStream();\n  EXPECT_TRUE(upstream_request_->complete());\n  EXPECT_EQ(1024U, upstream_request_->bodyLength());\n\n  EXPECT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().Status()->value().getStringView());\n  EXPECT_EQ(512U, response->body().size());\n}\n\nvoid HttpIntegrationTest::testGrpcRetry() {\n  Http::TestHeaderMapImpl response_trailers{{\"response1\", \"trailer1\"}, {\"grpc-status\", \"0\"}};\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  auto encoder_decoder =\n      codec_client_->startRequest(Http::TestHeaderMapImpl{{\":method\", \"POST\"},\n                                                          {\":path\", \"/test/long/url\"},\n                                                          {\":scheme\", \"http\"},\n                                                          {\":authority\", \"host\"},\n                                                          {\"x-forwarded-for\", \"10.0.0.1\"},\n                                                          {\"x-envoy-retry-grpc-on\", \"cancelled\"}});\n  request_encoder_ = &encoder_decoder.first;\n  auto response = std::move(encoder_decoder.second);\n  codec_client_->sendData(*request_encoder_, 1024, true);\n  waitForNextUpstreamRequest();\n  upstream_request_->encodeHeaders(\n      Http::TestHeaderMapImpl{{\":status\", \"200\"}, {\"grpc-status\", \"1\"}}, false);\n  if (fake_upstreams_[0]->httpType() == FakeHttpConnection::Type::HTTP1) {\n    ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());\n    ASSERT_TRUE(fake_upstreams_[0]->waitForHttpConnection(*dispatcher_, fake_upstream_connection_));\n  } else {\n    ASSERT_TRUE(upstream_request_->waitForReset());\n  }\n  waitForNextUpstreamRequest();\n\n  upstream_request_->encodeHeaders(default_response_headers_, false);\n  upstream_request_->encodeData(512,\n                                fake_upstreams_[0]->httpType() != FakeHttpConnection::Type::HTTP2);\n  if (fake_upstreams_[0]->httpType() == FakeHttpConnection::Type::HTTP2) {\n    upstream_request_->encodeTrailers(response_trailers);\n  }\n\n  response->waitForEndStream();\n  EXPECT_TRUE(upstream_request_->complete());\n  EXPECT_EQ(1024U, upstream_request_->bodyLength());\n\n  EXPECT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().Status()->value().getStringView());\n  EXPECT_EQ(512U, response->body().size());\n  if (fake_upstreams_[0]->httpType() == FakeHttpConnection::Type::HTTP2) {\n    EXPECT_THAT(*response->trailers(), HeaderMapEqualRef(&response_trailers));\n  }\n}\n\nvoid HttpIntegrationTest::testEnvoyHandling100Continue(bool additional_continue_from_upstream,\n                                                       const std::string& via) {\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  auto encoder_decoder =\n      codec_client_->startRequest(Http::TestHeaderMapImpl{{\":method\", \"POST\"},\n                                                          {\":path\", \"/dynamo/url\"},\n                                                          {\":scheme\", \"http\"},\n                                                          {\":authority\", \"host\"},\n                                                          {\"expect\", \"100-continue\"}});\n  request_encoder_ = &encoder_decoder.first;\n  auto response = std::move(encoder_decoder.second);\n  ASSERT_TRUE(fake_upstreams_[0]->waitForHttpConnection(*dispatcher_, fake_upstream_connection_));\n  // The continue headers should arrive immediately.\n  response->waitForContinueHeaders();\n  ASSERT_TRUE(fake_upstream_connection_->waitForNewStream(*dispatcher_, upstream_request_));\n\n  // Send the rest of the request.\n  codec_client_->sendData(*request_encoder_, 10, true);\n  ASSERT_TRUE(upstream_request_->waitForEndStream(*dispatcher_));\n  // Verify the Expect header is stripped.\n  EXPECT_EQ(nullptr, upstream_request_->headers().get(Http::Headers::get().Expect));\n  if (via.empty()) {\n    EXPECT_EQ(nullptr, upstream_request_->headers().get(Http::Headers::get().Via));\n  } else {\n    EXPECT_EQ(via,\n              upstream_request_->headers().get(Http::Headers::get().Via)->value().getStringView());\n  }\n\n  if (additional_continue_from_upstream) {\n    // Make sure if upstream sends an 100-Continue Envoy doesn't send its own and proxy the one\n    // from upstream!\n    upstream_request_->encode100ContinueHeaders(Http::TestHeaderMapImpl{{\":status\", \"100\"}});\n  }\n  upstream_request_->encodeHeaders(default_response_headers_, false);\n  upstream_request_->encodeData(12, true);\n\n  response->waitForEndStream();\n  ASSERT_TRUE(response->complete());\n  ASSERT(response->continue_headers() != nullptr);\n  EXPECT_EQ(\"100\", response->continue_headers()->Status()->value().getStringView());\n  EXPECT_EQ(nullptr, response->continue_headers()->Via());\n  EXPECT_EQ(\"200\", response->headers().Status()->value().getStringView());\n  if (via.empty()) {\n    EXPECT_EQ(nullptr, response->headers().Via());\n  } else {\n    EXPECT_EQ(via.c_str(), response->headers().Via()->value().getStringView());\n  }\n}\n\nvoid HttpIntegrationTest::testEnvoyProxying100Continue(bool continue_before_upstream_complete,\n                                                       bool with_encoder_filter) {\n  if (with_encoder_filter) {\n    // Because 100-continue only affects encoder filters, make sure it plays well with one.\n    config_helper_.addFilter(\"name: envoy.cors\");\n    config_helper_.addConfigModifier(\n        [&](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager& hcm)\n            -> void {\n          auto* route_config = hcm.mutable_route_config();\n          auto* virtual_host = route_config->mutable_virtual_hosts(0);\n          {\n            auto* cors = virtual_host->mutable_cors();\n            cors->mutable_allow_origin_string_match()->Add()->set_exact(\"*\");\n            cors->set_allow_headers(\"content-type,x-grpc-web\");\n            cors->set_allow_methods(\"GET,POST\");\n          }\n        });\n  }\n  config_helper_.addConfigModifier(\n      [&](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager& hcm)\n          -> void { hcm.set_proxy_100_continue(true); });\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  auto encoder_decoder =\n      codec_client_->startRequest(Http::TestHeaderMapImpl{{\":method\", \"GET\"},\n                                                          {\":path\", \"/dynamo/url\"},\n                                                          {\":scheme\", \"http\"},\n                                                          {\":authority\", \"host\"},\n                                                          {\"expect\", \"100-continue\"}});\n  request_encoder_ = &encoder_decoder.first;\n  auto response = std::move(encoder_decoder.second);\n\n  // Wait for the request headers to be received upstream.\n  ASSERT_TRUE(fake_upstreams_[0]->waitForHttpConnection(*dispatcher_, fake_upstream_connection_));\n  ASSERT_TRUE(fake_upstream_connection_->waitForNewStream(*dispatcher_, upstream_request_));\n\n  if (continue_before_upstream_complete) {\n    // This case tests sending on 100-Continue headers before the client has sent all the\n    // request data.\n    upstream_request_->encode100ContinueHeaders(Http::TestHeaderMapImpl{{\":status\", \"100\"}});\n    response->waitForContinueHeaders();\n  }\n  // Send all of the request data and wait for it to be received upstream.\n  codec_client_->sendData(*request_encoder_, 10, true);\n  ASSERT_TRUE(upstream_request_->waitForEndStream(*dispatcher_));\n\n  if (!continue_before_upstream_complete) {\n    // This case tests forwarding 100-Continue after the client has sent all data.\n    upstream_request_->encode100ContinueHeaders(Http::TestHeaderMapImpl{{\":status\", \"100\"}});\n    response->waitForContinueHeaders();\n  }\n  // Now send the rest of the response.\n  upstream_request_->encodeHeaders(default_response_headers_, true);\n  response->waitForEndStream();\n  EXPECT_TRUE(response->complete());\n  ASSERT(response->continue_headers() != nullptr);\n  EXPECT_EQ(\"100\", response->continue_headers()->Status()->value().getStringView());\n\n  EXPECT_EQ(\"200\", response->headers().Status()->value().getStringView());\n}\n\nvoid HttpIntegrationTest::testTwoRequests(bool network_backup) {\n  // if network_backup is false, this simply tests that Envoy can handle multiple\n  // requests on a connection.\n  //\n  // If network_backup is true, the first request will explicitly set the TCP level flow control\n  // as blocked as it finishes the encode and set a timer to unblock. The second stream should be\n  // created while the socket appears to be in the high watermark state, and regression tests that\n  // flow control will be corrected as the socket \"becomes unblocked\"\n  if (network_backup) {\n    config_helper_.addFilter(R\"EOF(\n  name: pause-filter\n  config: {}\n  )EOF\");\n  }\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  // Request 1.\n  auto response = codec_client_->makeRequestWithBody(default_request_headers_, 1024);\n  waitForNextUpstreamRequest();\n\n  upstream_request_->encodeHeaders(default_response_headers_, false);\n  upstream_request_->encodeData(512, true);\n  response->waitForEndStream();\n\n  EXPECT_TRUE(upstream_request_->complete());\n  EXPECT_EQ(1024U, upstream_request_->bodyLength());\n  EXPECT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().Status()->value().getStringView());\n  EXPECT_EQ(512U, response->body().size());\n\n  // Request 2.\n  response = codec_client_->makeRequestWithBody(default_request_headers_, 512);\n  waitForNextUpstreamRequest();\n  upstream_request_->encodeHeaders(default_response_headers_, false);\n  upstream_request_->encodeData(1024, true);\n  response->waitForEndStream();\n\n  EXPECT_TRUE(upstream_request_->complete());\n  EXPECT_EQ(512U, upstream_request_->bodyLength());\n  EXPECT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().Status()->value().getStringView());\n  EXPECT_EQ(1024U, response->body().size());\n}\n\nvoid HttpIntegrationTest::testLargeRequestHeaders(uint32_t size, uint32_t max_size) {\n  // `size` parameter is the size of the header that will be added to the\n  // request. The actual request byte size will exceed `size` due to keys\n  // and other headers.\n\n  config_helper_.addConfigModifier(\n      [&](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager& hcm)\n          -> void { hcm.mutable_max_request_headers_kb()->set_value(max_size); });\n  max_request_headers_kb_ = max_size;\n\n  Http::TestHeaderMapImpl big_headers{\n      {\":method\", \"GET\"}, {\":path\", \"/test/long/url\"}, {\":scheme\", \"http\"}, {\":authority\", \"host\"}};\n\n  big_headers.addCopy(\"big\", std::string(size * 1024, 'a'));\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  if (size >= max_size) {\n    // header size includes keys too, so expect rejection when equal\n    auto encoder_decoder = codec_client_->startRequest(big_headers);\n    auto response = std::move(encoder_decoder.second);\n\n    if (downstream_protocol_ == Http::CodecClient::Type::HTTP1) {\n      codec_client_->waitForDisconnect();\n      EXPECT_TRUE(response->complete());\n      EXPECT_EQ(\"431\", response->headers().Status()->value().getStringView());\n    } else {\n      response->waitForReset();\n      codec_client_->close();\n    }\n  } else {\n    auto response = sendRequestAndWaitForResponse(big_headers, 0, default_response_headers_, 0);\n    EXPECT_TRUE(response->complete());\n    EXPECT_EQ(\"200\", response->headers().Status()->value().getStringView());\n  }\n}\n\nvoid HttpIntegrationTest::testLargeRequestTrailers(uint32_t size, uint32_t max_size) {\n  // `size` parameter is the size of the trailer that will be added to the\n  // request. The actual request byte size will exceed `size` due to keys\n  // and other headers.\n\n  config_helper_.addConfigModifier(\n      [&](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager& hcm)\n          -> void { hcm.mutable_max_request_headers_kb()->set_value(max_size); });\n  max_request_headers_kb_ = max_size;\n  Http::TestHeaderMapImpl request_trailers{{\"trailer\", \"trailer\"}};\n  request_trailers.addCopy(\"big\", std::string(size * 1024, 'a'));\n\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  fake_upstreams_[0]->set_allow_unexpected_disconnects(true);\n\n  auto encoder_decoder = codec_client_->startRequest(default_request_headers_);\n  request_encoder_ = &encoder_decoder.first;\n  auto response = std::move(encoder_decoder.second);\n  codec_client_->sendData(*request_encoder_, 10, false);\n  codec_client_->sendTrailers(*request_encoder_, request_trailers);\n\n  if (size >= max_size && downstream_protocol_ == Http::CodecClient::Type::HTTP2) {\n    // For HTTP/2, expect a stream reset when the size of the trailers is larger than the maximum\n    // limit.\n    response->waitForReset();\n    codec_client_->close();\n    EXPECT_FALSE(response->complete());\n\n  } else {\n    waitForNextUpstreamRequest();\n    upstream_request_->encodeHeaders(default_response_headers_, true);\n    response->waitForEndStream();\n    EXPECT_TRUE(response->complete());\n  }\n}\n\nvoid HttpIntegrationTest::testManyRequestHeaders(std::chrono::milliseconds time) {\n  config_helper_.addConfigModifier(\n      [&](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager& hcm)\n          -> void { hcm.mutable_max_request_headers_kb()->set_value(96); });\n  max_request_headers_kb_ = 96;\n\n  Http::TestHeaderMapImpl big_headers{\n      {\":method\", \"GET\"}, {\":path\", \"/test/long/url\"}, {\":scheme\", \"http\"}, {\":authority\", \"host\"}};\n\n  for (int i = 0; i < 20000; i++) {\n    big_headers.addCopy(std::to_string(i), std::string(0, 'a'));\n  }\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  auto response =\n      sendRequestAndWaitForResponse(big_headers, 0, default_response_headers_, 0, 0, time);\n\n  EXPECT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().Status()->value().getStringView());\n}\n\nvoid HttpIntegrationTest::testDownstreamResetBeforeResponseComplete() {\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  auto encoder_decoder =\n      codec_client_->startRequest(Http::TestHeaderMapImpl{{\":method\", \"GET\"},\n                                                          {\":path\", \"/test/long/url\"},\n                                                          {\":scheme\", \"http\"},\n                                                          {\":authority\", \"host\"},\n                                                          {\"cookie\", \"a=b\"},\n                                                          {\"cookie\", \"c=d\"}});\n  request_encoder_ = &encoder_decoder.first;\n  auto response = std::move(encoder_decoder.second);\n  codec_client_->sendData(*request_encoder_, 0, true);\n  waitForNextUpstreamRequest();\n\n  EXPECT_EQ(upstream_request_->headers().get(Http::Headers::get().Cookie)->value(), \"a=b; c=d\");\n\n  upstream_request_->encodeHeaders(default_response_headers_, false);\n  upstream_request_->encodeData(512, false);\n\n  response->waitForBodyData(512);\n  codec_client_->sendReset(*request_encoder_);\n\n  if (upstreamProtocol() == FakeHttpConnection::Type::HTTP1) {\n    ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());\n  } else {\n    ASSERT_TRUE(upstream_request_->waitForReset());\n    ASSERT_TRUE(fake_upstream_connection_->close());\n    ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());\n  }\n\n  codec_client_->close();\n\n  EXPECT_TRUE(upstream_request_->complete());\n  EXPECT_EQ(0U, upstream_request_->bodyLength());\n\n  EXPECT_FALSE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().Status()->value().getStringView());\n  EXPECT_EQ(512U, response->body().size());\n}\n\nvoid HttpIntegrationTest::testTrailers(uint64_t request_size, uint64_t response_size) {\n  Http::TestHeaderMapImpl request_trailers{{\"request1\", \"trailer1\"}, {\"request2\", \"trailer2\"}};\n  Http::TestHeaderMapImpl response_trailers{{\"response1\", \"trailer1\"}, {\"response2\", \"trailer2\"}};\n\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  auto encoder_decoder =\n      codec_client_->startRequest(Http::TestHeaderMapImpl{{\":method\", \"POST\"},\n                                                          {\":path\", \"/test/long/url\"},\n                                                          {\":scheme\", \"http\"},\n                                                          {\":authority\", \"host\"}});\n  request_encoder_ = &encoder_decoder.first;\n  auto response = std::move(encoder_decoder.second);\n  codec_client_->sendData(*request_encoder_, request_size, false);\n  codec_client_->sendTrailers(*request_encoder_, request_trailers);\n  waitForNextUpstreamRequest();\n  upstream_request_->encodeHeaders(default_response_headers_, false);\n  upstream_request_->encodeData(response_size, false);\n  upstream_request_->encodeTrailers(response_trailers);\n  response->waitForEndStream();\n\n  EXPECT_TRUE(upstream_request_->complete());\n  EXPECT_EQ(request_size, upstream_request_->bodyLength());\n  if (fake_upstreams_[0]->httpType() == FakeHttpConnection::Type::HTTP2) {\n    EXPECT_THAT(*upstream_request_->trailers(), HeaderMapEqualRef(&request_trailers));\n  }\n\n  EXPECT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().Status()->value().getStringView());\n  EXPECT_EQ(response_size, response->body().size());\n  if (fake_upstreams_[0]->httpType() == FakeHttpConnection::Type::HTTP2) {\n    EXPECT_THAT(*response->trailers(), HeaderMapEqualRef(&response_trailers));\n  }\n}\n\nstd::string HttpIntegrationTest::listenerStatPrefix(const std::string& stat_name) {\n  if (version_ == Network::Address::IpVersion::v4) {\n    return \"listener.127.0.0.1_0.\" + stat_name;\n  }\n  return \"listener.[__1]_0.\" + stat_name;\n}\n} // namespace Envoy\n", "#pragma once\n\n#include <cstdint>\n#include <memory>\n#include <string>\n\n#include \"common/http/codec_client.h\"\n#include \"common/network/filter_impl.h\"\n\n#include \"test/integration/integration.h\"\n#include \"test/integration/utility.h\"\n#include \"test/test_common/printers.h\"\n\nnamespace Envoy {\n\n/**\n * HTTP codec client used during integration testing.\n */\nclass IntegrationCodecClient : public Http::CodecClientProd {\npublic:\n  IntegrationCodecClient(Event::Dispatcher& dispatcher, Network::ClientConnectionPtr&& conn,\n                         Upstream::HostDescriptionConstSharedPtr host_description,\n                         Http::CodecClient::Type type);\n\n  IntegrationStreamDecoderPtr makeHeaderOnlyRequest(const Http::HeaderMap& headers);\n  IntegrationStreamDecoderPtr makeRequestWithBody(const Http::HeaderMap& headers,\n                                                  uint64_t body_size);\n  IntegrationStreamDecoderPtr makeRequestWithBody(const Http::HeaderMap& headers,\n                                                  const std::string& body);\n  bool sawGoAway() const { return saw_goaway_; }\n  bool connected() const { return connected_; }\n  void sendData(Http::StreamEncoder& encoder, absl::string_view data, bool end_stream);\n  void sendData(Http::StreamEncoder& encoder, Buffer::Instance& data, bool end_stream);\n  void sendData(Http::StreamEncoder& encoder, uint64_t size, bool end_stream);\n  void sendTrailers(Http::StreamEncoder& encoder, const Http::HeaderMap& trailers);\n  void sendReset(Http::StreamEncoder& encoder);\n  // Intentionally makes a copy of metadata_map.\n  void sendMetadata(Http::StreamEncoder& encoder, Http::MetadataMap metadata_map);\n  std::pair<Http::StreamEncoder&, IntegrationStreamDecoderPtr>\n  startRequest(const Http::HeaderMap& headers);\n  bool waitForDisconnect(std::chrono::milliseconds time_to_wait = std::chrono::milliseconds(0));\n  Network::ClientConnection* connection() const { return connection_.get(); }\n  Network::ConnectionEvent last_connection_event() const { return last_connection_event_; }\n  Network::Connection& rawConnection() { return *connection_; }\n  bool disconnected() { return disconnected_; }\n\nprivate:\n  struct ConnectionCallbacks : public Network::ConnectionCallbacks {\n    ConnectionCallbacks(IntegrationCodecClient& parent) : parent_(parent) {}\n\n    // Network::ConnectionCallbacks\n    void onEvent(Network::ConnectionEvent event) override;\n    void onAboveWriteBufferHighWatermark() override {}\n    void onBelowWriteBufferLowWatermark() override {}\n\n    IntegrationCodecClient& parent_;\n  };\n\n  struct CodecCallbacks : public Http::ConnectionCallbacks {\n    CodecCallbacks(IntegrationCodecClient& parent) : parent_(parent) {}\n\n    // Http::ConnectionCallbacks\n    void onGoAway() override { parent_.saw_goaway_ = true; }\n\n    IntegrationCodecClient& parent_;\n  };\n\n  void flushWrite();\n\n  Event::Dispatcher& dispatcher_;\n  ConnectionCallbacks callbacks_;\n  CodecCallbacks codec_callbacks_;\n  bool connected_{};\n  bool disconnected_{};\n  bool saw_goaway_{};\n  Network::ConnectionEvent last_connection_event_;\n};\n\nusing IntegrationCodecClientPtr = std::unique_ptr<IntegrationCodecClient>;\n\n/**\n * Test fixture for HTTP and HTTP/2 integration tests.\n */\nclass HttpIntegrationTest : public BaseIntegrationTest {\npublic:\n  // TODO(jmarantz): Remove this once\n  // https://github.com/envoyproxy/envoy-filter-example/pull/69 is reverted.\n  HttpIntegrationTest(Http::CodecClient::Type downstream_protocol,\n                      Network::Address::IpVersion version, TestTimeSystemPtr,\n                      const std::string& config = ConfigHelper::HTTP_PROXY_CONFIG)\n      : HttpIntegrationTest(downstream_protocol, version, config) {}\n\n  HttpIntegrationTest(Http::CodecClient::Type downstream_protocol,\n                      Network::Address::IpVersion version,\n                      const std::string& config = ConfigHelper::HTTP_PROXY_CONFIG);\n\n  HttpIntegrationTest(Http::CodecClient::Type downstream_protocol,\n                      const InstanceConstSharedPtrFn& upstream_address_fn,\n                      Network::Address::IpVersion version,\n                      const std::string& config = ConfigHelper::HTTP_PROXY_CONFIG);\n  ~HttpIntegrationTest() override;\n\n  // Waits for the first access log entry.\n  std::string waitForAccessLog(const std::string& filename);\n\nprotected:\n  void useAccessLog();\n\n  IntegrationCodecClientPtr makeHttpConnection(uint32_t port);\n  // Makes a http connection object without checking its connected state.\n  IntegrationCodecClientPtr makeRawHttpConnection(Network::ClientConnectionPtr&& conn);\n  // Makes a http connection object with asserting a connected state.\n  IntegrationCodecClientPtr makeHttpConnection(Network::ClientConnectionPtr&& conn);\n\n  // Sets downstream_protocol_ and alters the HTTP connection manager codec type in the\n  // config_helper_.\n  void setDownstreamProtocol(Http::CodecClient::Type type);\n\n  // Sends |request_headers| and |request_body_size| bytes of body upstream.\n  // Configured upstream to send |response_headers| and |response_body_size|\n  // bytes of body downstream.\n  //\n  // Waits for the complete downstream response before returning.\n  // Requires |codec_client_| to be initialized.\n  IntegrationStreamDecoderPtr sendRequestAndWaitForResponse(\n      const Http::TestHeaderMapImpl& request_headers, uint32_t request_body_size,\n      const Http::TestHeaderMapImpl& response_headers, uint32_t response_body_size,\n      int upstream_index = 0, std::chrono::milliseconds time = TestUtility::DefaultTimeout);\n\n  // Wait for the end of stream on the next upstream stream on any of the provided fake upstreams.\n  // Sets fake_upstream_connection_ to the connection and upstream_request_ to stream.\n  // In cases where the upstream that will receive the request is not deterministic, a second\n  // upstream index may be provided, in which case both upstreams will be checked for requests.\n  uint64_t waitForNextUpstreamRequest(\n      const std::vector<uint64_t>& upstream_indices,\n      std::chrono::milliseconds connection_wait_timeout = TestUtility::DefaultTimeout);\n  void waitForNextUpstreamRequest(\n      uint64_t upstream_index = 0,\n      std::chrono::milliseconds connection_wait_timeout = TestUtility::DefaultTimeout);\n\n  // Close |codec_client_| and |fake_upstream_connection_| cleanly.\n  void cleanupUpstreamAndDownstream();\n\n  // Verifies the response_headers contains the expected_headers, and response body matches given\n  // body string.\n  void verifyResponse(IntegrationStreamDecoderPtr response, const std::string& response_code,\n                      const Http::TestHeaderMapImpl& expected_headers,\n                      const std::string& expected_body);\n\n  // Helper that sends a request to Envoy, and verifies if Envoy response headers and body size is\n  // the same as the expected headers map.\n  // Requires the \"http\" port has been registered.\n  void sendRequestAndVerifyResponse(const Http::TestHeaderMapImpl& request_headers,\n                                    const int request_size,\n                                    const Http::TestHeaderMapImpl& response_headers,\n                                    const int response_size, const int backend_idx);\n\n  // Check for completion of upstream_request_, and a simple \"200\" response.\n  void checkSimpleRequestSuccess(uint64_t expected_request_size, uint64_t expected_response_size,\n                                 IntegrationStreamDecoder* response);\n\n  using ConnectionCreationFunction = std::function<Network::ClientConnectionPtr()>;\n  // Sends a simple header-only HTTP request, and waits for a response.\n  IntegrationStreamDecoderPtr makeHeaderOnlyRequest(ConnectionCreationFunction* create_connection,\n                                                    int upstream_index,\n                                                    const std::string& path = \"/test/long/url\",\n                                                    const std::string& authority = \"host\");\n  void testRouterNotFound();\n  void testRouterNotFoundWithBody();\n\n  void testRouterRequestAndResponseWithBody(uint64_t request_size, uint64_t response_size,\n                                            bool big_header,\n                                            ConnectionCreationFunction* creator = nullptr);\n  void testRouterHeaderOnlyRequestAndResponse(ConnectionCreationFunction* creator = nullptr,\n                                              int upstream_index = 0,\n                                              const std::string& path = \"/test/long/url\",\n                                              const std::string& authority = \"host\");\n  void testRequestAndResponseShutdownWithActiveConnection();\n\n  // Disconnect tests\n  void testRouterUpstreamDisconnectBeforeRequestComplete();\n  void\n  testRouterUpstreamDisconnectBeforeResponseComplete(ConnectionCreationFunction* creator = nullptr);\n  void testRouterDownstreamDisconnectBeforeRequestComplete(\n      ConnectionCreationFunction* creator = nullptr);\n  void testRouterDownstreamDisconnectBeforeResponseComplete(\n      ConnectionCreationFunction* creator = nullptr);\n  void testRouterUpstreamResponseBeforeRequestComplete();\n\n  void testTwoRequests(bool force_network_backup = false);\n  void testLargeHeaders(Http::TestHeaderMapImpl request_headers,\n                        Http::TestHeaderMapImpl request_trailers, uint32_t size, uint32_t max_size);\n  void testLargeRequestHeaders(uint32_t size, uint32_t max_size = 60);\n  void testLargeRequestTrailers(uint32_t size, uint32_t max_size = 60);\n  void testManyRequestHeaders(std::chrono::milliseconds time = TestUtility::DefaultTimeout);\n\n  void testAddEncodedTrailers();\n  void testRetry();\n  void testRetryHittingBufferLimit();\n  void testRetryAttemptCountHeader();\n  void testGrpcRetry();\n\n  void testEnvoyHandling100Continue(bool additional_continue_from_upstream = false,\n                                    const std::string& via = \"\");\n  void testEnvoyProxying100Continue(bool continue_before_upstream_complete = false,\n                                    bool with_encoder_filter = false);\n\n  // HTTP/2 client tests.\n  void testDownstreamResetBeforeResponseComplete();\n  void testTrailers(uint64_t request_size, uint64_t response_size);\n\n  Http::CodecClient::Type downstreamProtocol() const { return downstream_protocol_; }\n  // Prefix listener stat with IP:port, including IP version dependent loopback address.\n  std::string listenerStatPrefix(const std::string& stat_name);\n\n  // The client making requests to Envoy.\n  IntegrationCodecClientPtr codec_client_;\n  // A placeholder for the first upstream connection.\n  FakeHttpConnectionPtr fake_upstream_connection_;\n  // A placeholder for the first request received at upstream.\n  FakeStreamPtr upstream_request_;\n  // A pointer to the request encoder, if used.\n  Http::StreamEncoder* request_encoder_{nullptr};\n  // The response headers sent by sendRequestAndWaitForResponse() by default.\n  Http::TestHeaderMapImpl default_response_headers_{{\":status\", \"200\"}};\n  Http::TestHeaderMapImpl default_request_headers_{\n      {\":method\", \"GET\"}, {\":path\", \"/test/long/url\"}, {\":scheme\", \"http\"}, {\":authority\", \"host\"}};\n  // The codec type for the client-to-Envoy connection\n  Http::CodecClient::Type downstream_protocol_{Http::CodecClient::Type::HTTP1};\n  uint32_t max_request_headers_kb_{Http::DEFAULT_MAX_REQUEST_HEADERS_KB};\n  std::string access_log_name_;\n};\n} // namespace Envoy\n", "#include <functional>\n#include <list>\n#include <memory>\n#include <regex>\n#include <string>\n#include <vector>\n\n#include \"envoy/buffer/buffer.h\"\n#include \"envoy/event/dispatcher.h\"\n#include \"envoy/http/header_map.h\"\n#include \"envoy/registry/registry.h\"\n\n#include \"common/api/api_impl.h\"\n#include \"common/buffer/buffer_impl.h\"\n#include \"common/common/fmt.h\"\n#include \"common/common/thread_annotations.h\"\n#include \"common/http/headers.h\"\n#include \"common/network/utility.h\"\n#include \"common/protobuf/utility.h\"\n#include \"common/runtime/runtime_impl.h\"\n#include \"common/upstream/upstream_impl.h\"\n\n#include \"test/common/upstream/utility.h\"\n#include \"test/integration/autonomous_upstream.h\"\n#include \"test/integration/http_integration.h\"\n#include \"test/integration/http_protocol_integration.h\"\n#include \"test/integration/test_host_predicate_config.h\"\n#include \"test/integration/utility.h\"\n#include \"test/mocks/upstream/mocks.h\"\n#include \"test/test_common/environment.h\"\n#include \"test/test_common/network_utility.h\"\n#include \"test/test_common/registry.h\"\n\n#include \"gtest/gtest.h\"\n\nusing testing::HasSubstr;\n\nnamespace Envoy {\n\nvoid setDoNotValidateRouteConfig(\n    envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager& hcm) {\n  auto* route_config = hcm.mutable_route_config();\n  route_config->mutable_validate_clusters()->set_value(false);\n};\n\n// Tests for DownstreamProtocolIntegrationTest will be run with all protocols\n// (H1/H2 downstream) but only H1 upstreams.\n//\n// This is useful for things which will likely not differ based on upstream\n// behavior, for example \"how does Envoy handle duplicate content lengths from\n// downstream\"?\nclass DownstreamProtocolIntegrationTest : public HttpProtocolIntegrationTest {\nprotected:\n  void changeHeadersForStopAllTests(Http::TestHeaderMapImpl& headers, bool set_buffer_limit) {\n    headers.addCopy(\"content_size\", std::to_string(count_ * size_));\n    headers.addCopy(\"added_size\", std::to_string(added_decoded_data_size_));\n    headers.addCopy(\"is_first_trigger\", \"value\");\n    if (set_buffer_limit) {\n      headers.addCopy(\"buffer_limit\", std::to_string(buffer_limit_));\n    }\n  }\n\n  void verifyUpStreamRequestAfterStopAllFilter() {\n    if (downstreamProtocol() == Http::CodecClient::Type::HTTP2) {\n      // decode-headers-return-stop-all-filter calls addDecodedData in decodeData and\n      // decodeTrailers. 2 decoded data were added.\n      EXPECT_EQ(count_ * size_ + added_decoded_data_size_ * 2, upstream_request_->bodyLength());\n    } else {\n      EXPECT_EQ(count_ * size_ + added_decoded_data_size_ * 1, upstream_request_->bodyLength());\n    }\n    EXPECT_EQ(true, upstream_request_->complete());\n  }\n\n  const int count_ = 70;\n  const int size_ = 1000;\n  const int added_decoded_data_size_ = 1;\n  const int buffer_limit_ = 100;\n};\n\n// Tests for ProtocolIntegrationTest will be run with the full mesh of H1/H2\n// downstream and H1/H2 upstreams.\nusing ProtocolIntegrationTest = HttpProtocolIntegrationTest;\n\nTEST_P(ProtocolIntegrationTest, ShutdownWithActiveConnPoolConnections) {\n  auto response = makeHeaderOnlyRequest(nullptr, 0);\n  // Shut down the server with active connection pool connections.\n  fake_upstreams_[0]->set_allow_unexpected_disconnects(true);\n  test_server_.reset();\n  checkSimpleRequestSuccess(0U, 0U, response.get());\n}\n\n// Change the default route to be restrictive, and send a request to an alternate route.\nTEST_P(ProtocolIntegrationTest, RouterNotFound) { testRouterNotFound(); }\n\n// Change the default route to be restrictive, and send a POST to an alternate route.\nTEST_P(DownstreamProtocolIntegrationTest, RouterNotFoundBodyNoBuffer) {\n  testRouterNotFoundWithBody();\n}\n\n// Add a route that uses unknown cluster (expect 404 Not Found).\nTEST_P(DownstreamProtocolIntegrationTest, RouterClusterNotFound404) {\n  config_helper_.addConfigModifier(&setDoNotValidateRouteConfig);\n  auto host = config_helper_.createVirtualHost(\"foo.com\", \"/unknown\", \"unknown_cluster\");\n  host.mutable_routes(0)->mutable_route()->set_cluster_not_found_response_code(\n      envoy::api::v2::route::RouteAction::NOT_FOUND);\n  config_helper_.addVirtualHost(host);\n  initialize();\n\n  BufferingStreamDecoderPtr response = IntegrationUtil::makeSingleRequest(\n      lookupPort(\"http\"), \"GET\", \"/unknown\", \"\", downstream_protocol_, version_, \"foo.com\");\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"404\", response->headers().Status()->value().getStringView());\n}\n\n// Add a route that uses unknown cluster (expect 503 Service Unavailable).\nTEST_P(DownstreamProtocolIntegrationTest, RouterClusterNotFound503) {\n  config_helper_.addConfigModifier(&setDoNotValidateRouteConfig);\n  auto host = config_helper_.createVirtualHost(\"foo.com\", \"/unknown\", \"unknown_cluster\");\n  host.mutable_routes(0)->mutable_route()->set_cluster_not_found_response_code(\n      envoy::api::v2::route::RouteAction::SERVICE_UNAVAILABLE);\n  config_helper_.addVirtualHost(host);\n  initialize();\n\n  BufferingStreamDecoderPtr response = IntegrationUtil::makeSingleRequest(\n      lookupPort(\"http\"), \"GET\", \"/unknown\", \"\", downstream_protocol_, version_, \"foo.com\");\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"503\", response->headers().Status()->value().getStringView());\n}\n\n// Add a route which redirects HTTP to HTTPS, and verify Envoy sends a 301\nTEST_P(ProtocolIntegrationTest, RouterRedirect) {\n  auto host = config_helper_.createVirtualHost(\"www.redirect.com\", \"/\");\n  host.set_require_tls(envoy::api::v2::route::VirtualHost::ALL);\n  config_helper_.addVirtualHost(host);\n  initialize();\n\n  BufferingStreamDecoderPtr response = IntegrationUtil::makeSingleRequest(\n      lookupPort(\"http\"), \"GET\", \"/foo\", \"\", downstream_protocol_, version_, \"www.redirect.com\");\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"301\", response->headers().Status()->value().getStringView());\n  EXPECT_EQ(\"https://www.redirect.com/foo\",\n            response->headers().get(Http::Headers::get().Location)->value().getStringView());\n}\n\n// Add a health check filter and verify correct computation of health based on upstream status.\nTEST_P(ProtocolIntegrationTest, ComputedHealthCheck) {\n  config_helper_.addFilter(R\"EOF(\nname: envoy.health_check\nconfig:\n    pass_through_mode: false\n    cluster_min_healthy_percentages:\n        example_cluster_name: { value: 75 }\n)EOF\");\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  auto response = codec_client_->makeHeaderOnlyRequest(Http::TestHeaderMapImpl{\n      {\":method\", \"GET\"}, {\":path\", \"/healthcheck\"}, {\":scheme\", \"http\"}, {\":authority\", \"host\"}});\n  response->waitForEndStream();\n\n  EXPECT_TRUE(response->complete());\n  EXPECT_EQ(\"503\", response->headers().Status()->value().getStringView());\n}\n\n// Add a health check filter and verify correct computation of health based on upstream status.\nTEST_P(ProtocolIntegrationTest, ModifyBuffer) {\n  config_helper_.addFilter(R\"EOF(\nname: envoy.health_check\nconfig:\n    pass_through_mode: false\n    cluster_min_healthy_percentages:\n        example_cluster_name: { value: 75 }\n)EOF\");\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  auto response = codec_client_->makeHeaderOnlyRequest(Http::TestHeaderMapImpl{\n      {\":method\", \"GET\"}, {\":path\", \"/healthcheck\"}, {\":scheme\", \"http\"}, {\":authority\", \"host\"}});\n  response->waitForEndStream();\n\n  EXPECT_TRUE(response->complete());\n  EXPECT_EQ(\"503\", response->headers().Status()->value().getStringView());\n}\n\nTEST_P(ProtocolIntegrationTest, AddEncodedTrailers) {\n  config_helper_.addFilter(R\"EOF(\nname: add-trailers-filter\nconfig: {}\n)EOF\");\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  auto response = codec_client_->makeRequestWithBody(default_request_headers_, 128);\n  waitForNextUpstreamRequest();\n  upstream_request_->encodeHeaders(Http::TestHeaderMapImpl{{\":status\", \"503\"}}, false);\n  upstream_request_->encodeData(128, true);\n  response->waitForEndStream();\n\n  if (upstreamProtocol() == FakeHttpConnection::Type::HTTP2) {\n    EXPECT_EQ(\"decode\", upstream_request_->trailers()->GrpcMessage()->value().getStringView());\n  }\n  EXPECT_TRUE(response->complete());\n  EXPECT_EQ(\"503\", response->headers().Status()->value().getStringView());\n  if (downstream_protocol_ == Http::CodecClient::Type::HTTP2) {\n    EXPECT_EQ(\"encode\", response->trailers()->GrpcMessage()->value().getStringView());\n  }\n}\n\n// Add a health check filter and verify correct behavior when draining.\nTEST_P(ProtocolIntegrationTest, DrainClose) {\n  config_helper_.addFilter(ConfigHelper::DEFAULT_HEALTH_CHECK_FILTER);\n  initialize();\n\n  test_server_->drainManager().draining_ = true;\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  auto response = codec_client_->makeHeaderOnlyRequest(default_request_headers_);\n  response->waitForEndStream();\n  codec_client_->waitForDisconnect();\n\n  EXPECT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().Status()->value().getStringView());\n  if (downstream_protocol_ == Http::CodecClient::Type::HTTP2) {\n    EXPECT_TRUE(codec_client_->sawGoAway());\n  }\n\n  test_server_->drainManager().draining_ = false;\n}\n\nTEST_P(ProtocolIntegrationTest, Retry) {\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  auto response =\n      codec_client_->makeRequestWithBody(Http::TestHeaderMapImpl{{\":method\", \"POST\"},\n                                                                 {\":path\", \"/test/long/url\"},\n                                                                 {\":scheme\", \"http\"},\n                                                                 {\":authority\", \"host\"},\n                                                                 {\"x-forwarded-for\", \"10.0.0.1\"},\n                                                                 {\"x-envoy-retry-on\", \"5xx\"}},\n                                         1024);\n  waitForNextUpstreamRequest();\n  upstream_request_->encodeHeaders(Http::TestHeaderMapImpl{{\":status\", \"503\"}}, false);\n\n  if (fake_upstreams_[0]->httpType() == FakeHttpConnection::Type::HTTP1) {\n    ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());\n    ASSERT_TRUE(fake_upstreams_[0]->waitForHttpConnection(*dispatcher_, fake_upstream_connection_));\n  } else {\n    ASSERT_TRUE(upstream_request_->waitForReset());\n  }\n  waitForNextUpstreamRequest();\n  upstream_request_->encodeHeaders(default_response_headers_, false);\n  upstream_request_->encodeData(512, true);\n\n  response->waitForEndStream();\n  EXPECT_TRUE(upstream_request_->complete());\n  EXPECT_EQ(1024U, upstream_request_->bodyLength());\n\n  EXPECT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().Status()->value().getStringView());\n  EXPECT_EQ(512U, response->body().size());\n}\n\n// Tests that the x-envoy-attempt-count header is properly set on the upstream request\n// and updated after the request is retried.\nTEST_P(DownstreamProtocolIntegrationTest, RetryAttemptCountHeader) {\n  auto host = config_helper_.createVirtualHost(\"host\", \"/test_retry\");\n  host.set_include_request_attempt_count(true);\n  config_helper_.addVirtualHost(host);\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  auto response =\n      codec_client_->makeRequestWithBody(Http::TestHeaderMapImpl{{\":method\", \"POST\"},\n                                                                 {\":path\", \"/test_retry\"},\n                                                                 {\":scheme\", \"http\"},\n                                                                 {\":authority\", \"host\"},\n                                                                 {\"x-forwarded-for\", \"10.0.0.1\"},\n                                                                 {\"x-envoy-retry-on\", \"5xx\"}},\n                                         1024);\n  waitForNextUpstreamRequest();\n  upstream_request_->encodeHeaders(Http::TestHeaderMapImpl{{\":status\", \"503\"}}, false);\n\n  EXPECT_EQ(\n      atoi(std::string(upstream_request_->headers().EnvoyAttemptCount()->value().getStringView())\n               .c_str()),\n      1);\n\n  if (fake_upstreams_[0]->httpType() == FakeHttpConnection::Type::HTTP1) {\n    ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());\n    ASSERT_TRUE(fake_upstreams_[0]->waitForHttpConnection(*dispatcher_, fake_upstream_connection_));\n  } else {\n    ASSERT_TRUE(upstream_request_->waitForReset());\n  }\n  waitForNextUpstreamRequest();\n  EXPECT_EQ(\n      atoi(std::string(upstream_request_->headers().EnvoyAttemptCount()->value().getStringView())\n               .c_str()),\n      2);\n  upstream_request_->encodeHeaders(default_response_headers_, false);\n  upstream_request_->encodeData(512, true);\n\n  response->waitForEndStream();\n  EXPECT_TRUE(upstream_request_->complete());\n  EXPECT_EQ(1024U, upstream_request_->bodyLength());\n\n  EXPECT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().Status()->value().getStringView());\n  EXPECT_EQ(512U, response->body().size());\n}\n\n// Verifies that a retry priority can be configured and affect the host selected during retries.\n// The retry priority will always target P1, which would otherwise never be hit due to P0 being\n// healthy.\nTEST_P(DownstreamProtocolIntegrationTest, RetryPriority) {\n  const Upstream::HealthyLoad healthy_priority_load({0u, 100u});\n  const Upstream::DegradedLoad degraded_priority_load({0u, 100u});\n  NiceMock<Upstream::MockRetryPriority> retry_priority(healthy_priority_load,\n                                                       degraded_priority_load);\n  Upstream::MockRetryPriorityFactory factory(retry_priority);\n\n  Registry::InjectFactory<Upstream::RetryPriorityFactory> inject_factory(factory);\n\n  // Add route with custom retry policy\n  auto host = config_helper_.createVirtualHost(\"host\", \"/test_retry\");\n  host.set_include_request_attempt_count(true);\n  auto retry_policy = host.mutable_routes(0)->mutable_route()->mutable_retry_policy();\n  retry_policy->mutable_retry_priority()->set_name(factory.name());\n  config_helper_.addVirtualHost(host);\n\n  // Use load assignments instead of static hosts. Necessary in order to use priorities.\n  config_helper_.addConfigModifier([](envoy::config::bootstrap::v2::Bootstrap& bootstrap) {\n    auto cluster = bootstrap.mutable_static_resources()->mutable_clusters(0);\n    auto load_assignment = cluster->mutable_load_assignment();\n    load_assignment->set_cluster_name(cluster->name());\n    const auto& host_address = cluster->hosts(0).socket_address().address();\n\n    for (int i = 0; i < 2; ++i) {\n      auto locality = load_assignment->add_endpoints();\n      locality->set_priority(i);\n      locality->mutable_locality()->set_region(\"region\");\n      locality->mutable_locality()->set_zone(\"zone\");\n      locality->mutable_locality()->set_sub_zone(\"sub_zone\" + std::to_string(i));\n      auto lb_endpoint = locality->add_lb_endpoints();\n      lb_endpoint->mutable_endpoint()->mutable_address()->mutable_socket_address()->set_address(\n          host_address);\n      lb_endpoint->mutable_endpoint()->mutable_address()->mutable_socket_address()->set_port_value(\n          0);\n    }\n\n    cluster->clear_hosts();\n  });\n\n  fake_upstreams_count_ = 2;\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  auto response =\n      codec_client_->makeRequestWithBody(Http::TestHeaderMapImpl{{\":method\", \"POST\"},\n                                                                 {\":path\", \"/test_retry\"},\n                                                                 {\":scheme\", \"http\"},\n                                                                 {\":authority\", \"host\"},\n                                                                 {\"x-forwarded-for\", \"10.0.0.1\"},\n                                                                 {\"x-envoy-retry-on\", \"5xx\"}},\n                                         1024);\n\n  // Note how we're expecting each upstream request to hit the same upstream.\n  waitForNextUpstreamRequest(0);\n  upstream_request_->encodeHeaders(Http::TestHeaderMapImpl{{\":status\", \"503\"}}, false);\n\n  if (fake_upstreams_[0]->httpType() == FakeHttpConnection::Type::HTTP1) {\n    ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());\n    ASSERT_TRUE(fake_upstreams_[1]->waitForHttpConnection(*dispatcher_, fake_upstream_connection_));\n  } else {\n    ASSERT_TRUE(upstream_request_->waitForReset());\n  }\n\n  waitForNextUpstreamRequest(1);\n  upstream_request_->encodeHeaders(default_response_headers_, false);\n  upstream_request_->encodeData(512, true);\n\n  response->waitForEndStream();\n  EXPECT_TRUE(upstream_request_->complete());\n  EXPECT_EQ(1024U, upstream_request_->bodyLength());\n\n  EXPECT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().Status()->value().getStringView());\n  EXPECT_EQ(512U, response->body().size());\n}\n\n//\n// Verifies that a retry host filter can be configured and affect the host selected during retries.\n// The predicate will keep track of the first host attempted, and attempt to route all requests to\n// the same host. With a total of two upstream hosts, this should result in us continuously sending\n// requests to the same host.\nTEST_P(DownstreamProtocolIntegrationTest, RetryHostPredicateFilter) {\n  TestHostPredicateFactory predicate_factory;\n  Registry::InjectFactory<Upstream::RetryHostPredicateFactory> inject_factory(predicate_factory);\n\n  // Add route with custom retry policy\n  auto host = config_helper_.createVirtualHost(\"host\", \"/test_retry\");\n  host.set_include_request_attempt_count(true);\n  auto retry_policy = host.mutable_routes(0)->mutable_route()->mutable_retry_policy();\n  retry_policy->add_retry_host_predicate()->set_name(predicate_factory.name());\n  config_helper_.addVirtualHost(host);\n\n  // We want to work with a cluster with two hosts.\n  config_helper_.addConfigModifier([](envoy::config::bootstrap::v2::Bootstrap& bootstrap) {\n    auto* new_host = bootstrap.mutable_static_resources()->mutable_clusters(0)->add_hosts();\n    new_host->MergeFrom(bootstrap.static_resources().clusters(0).hosts(0));\n  });\n  fake_upstreams_count_ = 2;\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  auto response =\n      codec_client_->makeRequestWithBody(Http::TestHeaderMapImpl{{\":method\", \"POST\"},\n                                                                 {\":path\", \"/test_retry\"},\n                                                                 {\":scheme\", \"http\"},\n                                                                 {\":authority\", \"host\"},\n                                                                 {\"x-forwarded-for\", \"10.0.0.1\"},\n                                                                 {\"x-envoy-retry-on\", \"5xx\"}},\n                                         1024);\n\n  // Note how we're expecting each upstream request to hit the same upstream.\n  auto upstream_idx = waitForNextUpstreamRequest({0, 1});\n  upstream_request_->encodeHeaders(Http::TestHeaderMapImpl{{\":status\", \"503\"}}, false);\n\n  if (fake_upstreams_[upstream_idx]->httpType() == FakeHttpConnection::Type::HTTP1) {\n    ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());\n    ASSERT_TRUE(fake_upstreams_[upstream_idx]->waitForHttpConnection(*dispatcher_,\n                                                                     fake_upstream_connection_));\n  } else {\n    ASSERT_TRUE(upstream_request_->waitForReset());\n  }\n\n  waitForNextUpstreamRequest(upstream_idx);\n  upstream_request_->encodeHeaders(default_response_headers_, false);\n  upstream_request_->encodeData(512, true);\n\n  response->waitForEndStream();\n  EXPECT_TRUE(upstream_request_->complete());\n  EXPECT_EQ(1024U, upstream_request_->bodyLength());\n\n  EXPECT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().Status()->value().getStringView());\n  EXPECT_EQ(512U, response->body().size());\n}\n\n// Very similar set-up to testRetry but with a 16k request the request will not\n// be buffered and the 503 will be returned to the user.\nTEST_P(ProtocolIntegrationTest, RetryHittingBufferLimit) {\n  config_helper_.setBufferLimits(1024, 1024); // Set buffer limits upstream and downstream.\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  auto response =\n      codec_client_->makeRequestWithBody(Http::TestHeaderMapImpl{{\":method\", \"POST\"},\n                                                                 {\":path\", \"/test/long/url\"},\n                                                                 {\":scheme\", \"http\"},\n                                                                 {\":authority\", \"host\"},\n                                                                 {\"x-forwarded-for\", \"10.0.0.1\"},\n                                                                 {\"x-envoy-retry-on\", \"5xx\"}},\n                                         1024 * 65);\n  waitForNextUpstreamRequest();\n\n  upstream_request_->encodeHeaders(Http::TestHeaderMapImpl{{\":status\", \"503\"}}, true);\n\n  response->waitForEndStream();\n  EXPECT_TRUE(upstream_request_->complete());\n  EXPECT_EQ(66560U, upstream_request_->bodyLength());\n\n  EXPECT_TRUE(response->complete());\n  EXPECT_EQ(\"503\", response->headers().Status()->value().getStringView());\n}\n\n// Test hitting the dynamo filter with too many request bytes to buffer. Ensure the connection\n// manager sends a 413.\nTEST_P(DownstreamProtocolIntegrationTest, HittingDecoderFilterLimit) {\n  config_helper_.addFilter(\"{ name: envoy.http_dynamo_filter, config: {} }\");\n  config_helper_.setBufferLimits(1024, 1024);\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  // Envoy will likely connect and proxy some unspecified amount of data before\n  // hitting the buffer limit and disconnecting. Ignore this if it happens.\n  fake_upstreams_[0]->set_allow_unexpected_disconnects(true);\n  auto response =\n      codec_client_->makeRequestWithBody(Http::TestHeaderMapImpl{{\":method\", \"POST\"},\n                                                                 {\":path\", \"/dynamo/url\"},\n                                                                 {\":scheme\", \"http\"},\n                                                                 {\":authority\", \"host\"},\n                                                                 {\"x-forwarded-for\", \"10.0.0.1\"},\n                                                                 {\"x-envoy-retry-on\", \"5xx\"}},\n                                         1024 * 65);\n\n  response->waitForEndStream();\n  // With HTTP/1 there's a possible race where if the connection backs up early,\n  // the 413-and-connection-close may be sent while the body is still being\n  // sent, resulting in a write error and the connection being closed before the\n  // response is read.\n  if (downstream_protocol_ == Http::CodecClient::Type::HTTP2) {\n    ASSERT_TRUE(response->complete());\n  }\n  if (response->complete()) {\n    EXPECT_EQ(\"413\", response->headers().Status()->value().getStringView());\n  }\n}\n\n// Test hitting the dynamo filter with too many response bytes to buffer. Given the request headers\n// are sent on early, the stream/connection will be reset.\nTEST_P(ProtocolIntegrationTest, HittingEncoderFilterLimit) {\n  useAccessLog();\n  config_helper_.addFilter(\"{ name: envoy.http_dynamo_filter, config: {} }\");\n  config_helper_.setBufferLimits(1024, 1024);\n  initialize();\n\n  // Send the request.\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  auto encoder_decoder = codec_client_->startRequest(default_request_headers_);\n  auto downstream_request = &encoder_decoder.first;\n  auto response = std::move(encoder_decoder.second);\n  Buffer::OwnedImpl data(R\"({\"TableName\":\"locations\"})\");\n  codec_client_->sendData(*downstream_request, data, true);\n  waitForNextUpstreamRequest();\n\n  // Send the response headers.\n  upstream_request_->encodeHeaders(default_response_headers_, false);\n\n  // Now send an overly large response body. At some point, too much data will\n  // be buffered, the stream will be reset, and the connection will disconnect.\n  fake_upstreams_[0]->set_allow_unexpected_disconnects(true);\n  upstream_request_->encodeData(1024 * 65, false);\n  if (upstreamProtocol() == FakeHttpConnection::Type::HTTP1) {\n    ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());\n  } else {\n    ASSERT_TRUE(upstream_request_->waitForReset());\n    ASSERT_TRUE(fake_upstream_connection_->close());\n    ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());\n  }\n\n  response->waitForEndStream();\n  EXPECT_TRUE(response->complete());\n  EXPECT_EQ(\"500\", response->headers().Status()->value().getStringView());\n  EXPECT_THAT(waitForAccessLog(access_log_name_), HasSubstr(\"500\"));\n  test_server_->waitForCounterEq(\"http.config_test.downstream_rq_5xx\", 1);\n}\n\nTEST_P(ProtocolIntegrationTest, EnvoyHandling100Continue) { testEnvoyHandling100Continue(); }\n\nTEST_P(ProtocolIntegrationTest, EnvoyHandlingDuplicate100Continue) {\n  testEnvoyHandling100Continue(true);\n}\n\nTEST_P(ProtocolIntegrationTest, EnvoyProxyingEarly100Continue) {\n  testEnvoyProxying100Continue(true);\n}\n\nTEST_P(ProtocolIntegrationTest, EnvoyProxyingLate100Continue) {\n  testEnvoyProxying100Continue(false);\n}\n\nTEST_P(ProtocolIntegrationTest, TwoRequests) { testTwoRequests(); }\n\nTEST_P(ProtocolIntegrationTest, TwoRequestsWithForcedBackup) { testTwoRequests(true); }\n\nTEST_P(DownstreamProtocolIntegrationTest, ValidZeroLengthContent) {\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  Http::TestHeaderMapImpl request_headers{{\":method\", \"POST\"},\n                                          {\":path\", \"/test/long/url\"},\n                                          {\":scheme\", \"http\"},\n                                          {\":authority\", \"host\"},\n                                          {\"content-length\", \"0\"}};\n  auto response = sendRequestAndWaitForResponse(request_headers, 0, default_response_headers_, 0);\n\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().Status()->value().getStringView());\n}\n\n// Validate that lots of tiny cookies doesn't cause a DoS (single cookie header).\nTEST_P(DownstreamProtocolIntegrationTest, LargeCookieParsingConcatenated) {\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  Http::TestHeaderMapImpl request_headers{{\":method\", \"POST\"},\n                                          {\":path\", \"/test/long/url\"},\n                                          {\":scheme\", \"http\"},\n                                          {\":authority\", \"host\"},\n                                          {\"content-length\", \"0\"}};\n  std::vector<std::string> cookie_pieces;\n  for (int i = 0; i < 7000; i++) {\n    cookie_pieces.push_back(fmt::sprintf(\"a%x=b\", i));\n  }\n  request_headers.addCopy(\"cookie\", absl::StrJoin(cookie_pieces, \"; \"));\n  auto response = sendRequestAndWaitForResponse(request_headers, 0, default_response_headers_, 0);\n\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().Status()->value().getStringView());\n}\n\n// Validate that lots of tiny cookies doesn't cause a DoS (many cookie headers).\nTEST_P(DownstreamProtocolIntegrationTest, LargeCookieParsingMany) {\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  Http::TestHeaderMapImpl request_headers{{\":method\", \"POST\"},\n                                          {\":path\", \"/test/long/url\"},\n                                          {\":scheme\", \"http\"},\n                                          {\":authority\", \"host\"},\n                                          {\"content-length\", \"0\"}};\n  for (int i = 0; i < 2000; i++) {\n    request_headers.addCopy(\"cookie\", fmt::sprintf(\"a%x=b\", i));\n  }\n  auto response = sendRequestAndWaitForResponse(request_headers, 0, default_response_headers_, 0);\n\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().Status()->value().getStringView());\n}\n\nTEST_P(DownstreamProtocolIntegrationTest, InvalidContentLength) {\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  auto encoder_decoder =\n      codec_client_->startRequest(Http::TestHeaderMapImpl{{\":method\", \"POST\"},\n                                                          {\":path\", \"/test/long/url\"},\n                                                          {\":authority\", \"host\"},\n                                                          {\"content-length\", \"-1\"}});\n  auto response = std::move(encoder_decoder.second);\n\n  codec_client_->waitForDisconnect();\n\n  if (downstream_protocol_ == Http::CodecClient::Type::HTTP1) {\n    ASSERT_TRUE(response->complete());\n    EXPECT_EQ(\"400\", response->headers().Status()->value().getStringView());\n  } else {\n    ASSERT_TRUE(response->reset());\n    EXPECT_EQ(Http::StreamResetReason::ConnectionTermination, response->reset_reason());\n  }\n}\n\n// TODO(PiotrSikora): move this HTTP/2 only variant to http2_integration_test.cc.\nTEST_P(DownstreamProtocolIntegrationTest, InvalidContentLengthAllowed) {\n  config_helper_.addConfigModifier(\n      [](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager& hcm)\n          -> void {\n        hcm.mutable_http2_protocol_options()->set_stream_error_on_invalid_http_messaging(true);\n      });\n\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  auto encoder_decoder =\n      codec_client_->startRequest(Http::TestHeaderMapImpl{{\":method\", \"POST\"},\n                                                          {\":path\", \"/test/long/url\"},\n                                                          {\":authority\", \"host\"},\n                                                          {\"content-length\", \"-1\"}});\n  auto response = std::move(encoder_decoder.second);\n\n  if (downstream_protocol_ == Http::CodecClient::Type::HTTP1) {\n    codec_client_->waitForDisconnect();\n  } else {\n    response->waitForReset();\n    codec_client_->close();\n  }\n\n  if (downstream_protocol_ == Http::CodecClient::Type::HTTP1) {\n    ASSERT_TRUE(response->complete());\n    EXPECT_EQ(\"400\", response->headers().Status()->value().getStringView());\n  } else {\n    ASSERT_TRUE(response->reset());\n    EXPECT_EQ(Http::StreamResetReason::RemoteReset, response->reset_reason());\n  }\n}\n\nTEST_P(DownstreamProtocolIntegrationTest, MultipleContentLengths) {\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  auto encoder_decoder =\n      codec_client_->startRequest(Http::TestHeaderMapImpl{{\":method\", \"POST\"},\n                                                          {\":path\", \"/test/long/url\"},\n                                                          {\":authority\", \"host\"},\n                                                          {\"content-length\", \"3,2\"}});\n  auto response = std::move(encoder_decoder.second);\n\n  codec_client_->waitForDisconnect();\n\n  if (downstream_protocol_ == Http::CodecClient::Type::HTTP1) {\n    ASSERT_TRUE(response->complete());\n    EXPECT_EQ(\"400\", response->headers().Status()->value().getStringView());\n  } else {\n    ASSERT_TRUE(response->reset());\n    EXPECT_EQ(Http::StreamResetReason::ConnectionTermination, response->reset_reason());\n  }\n}\n\n// TODO(PiotrSikora): move this HTTP/2 only variant to http2_integration_test.cc.\nTEST_P(DownstreamProtocolIntegrationTest, MultipleContentLengthsAllowed) {\n  config_helper_.addConfigModifier(\n      [](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager& hcm)\n          -> void {\n        hcm.mutable_http2_protocol_options()->set_stream_error_on_invalid_http_messaging(true);\n      });\n\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  auto encoder_decoder =\n      codec_client_->startRequest(Http::TestHeaderMapImpl{{\":method\", \"POST\"},\n                                                          {\":path\", \"/test/long/url\"},\n                                                          {\":authority\", \"host\"},\n                                                          {\"content-length\", \"3,2\"}});\n  auto response = std::move(encoder_decoder.second);\n\n  if (downstream_protocol_ == Http::CodecClient::Type::HTTP1) {\n    codec_client_->waitForDisconnect();\n  } else {\n    response->waitForReset();\n    codec_client_->close();\n  }\n\n  if (downstream_protocol_ == Http::CodecClient::Type::HTTP1) {\n    ASSERT_TRUE(response->complete());\n    EXPECT_EQ(\"400\", response->headers().Status()->value().getStringView());\n  } else {\n    ASSERT_TRUE(response->reset());\n    EXPECT_EQ(Http::StreamResetReason::RemoteReset, response->reset_reason());\n  }\n}\n\nTEST_P(DownstreamProtocolIntegrationTest, HeadersOnlyFilterEncoding) {\n  config_helper_.addFilter(R\"EOF(\nname: encode-headers-only\n)EOF\");\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  auto response =\n      codec_client_->makeRequestWithBody(Http::TestHeaderMapImpl{{\":method\", \"GET\"},\n                                                                 {\":path\", \"/test/long/url\"},\n                                                                 {\":scheme\", \"http\"},\n                                                                 {\":authority\", \"host\"}},\n                                         128);\n  waitForNextUpstreamRequest();\n  upstream_request_->encodeHeaders(Http::TestHeaderMapImpl{{\":status\", \"503\"}}, false);\n  response->waitForEndStream();\n  EXPECT_TRUE(upstream_request_->waitForEndStream(*dispatcher_));\n  if (upstreamProtocol() == FakeHttpConnection::Type::HTTP1) {\n    ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());\n  } else {\n    ASSERT_TRUE(upstream_request_->waitForReset());\n    ASSERT_TRUE(fake_upstream_connection_->close());\n    ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());\n  }\n\n  EXPECT_TRUE(response->complete());\n  EXPECT_EQ(\"503\", response->headers().Status()->value().getStringView());\n  EXPECT_EQ(0, response->body().size());\n}\n\nTEST_P(DownstreamProtocolIntegrationTest, HeadersOnlyFilterDecoding) {\n  config_helper_.addFilter(R\"EOF(\nname: decode-headers-only\n)EOF\");\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  auto response =\n      codec_client_->makeRequestWithBody(Http::TestHeaderMapImpl{{\":method\", \"POST\"},\n                                                                 {\":path\", \"/test/long/url\"},\n                                                                 {\":scheme\", \"http\"},\n                                                                 {\":authority\", \"host\"}},\n                                         128);\n  waitForNextUpstreamRequest();\n  upstream_request_->encodeHeaders(Http::TestHeaderMapImpl{{\":status\", \"503\"}}, false);\n  upstream_request_->encodeData(128, true);\n  response->waitForEndStream();\n\n  EXPECT_TRUE(response->complete());\n  EXPECT_EQ(\"503\", response->headers().Status()->value().getStringView());\n  EXPECT_EQ(128, response->body().size());\n}\n\nTEST_P(DownstreamProtocolIntegrationTest, HeadersOnlyFilterEncodingIntermediateFilters) {\n  config_helper_.addFilter(R\"EOF(\nname: passthrough-filter\n)EOF\");\n  config_helper_.addFilter(R\"EOF(\nname: encode-headers-only\n)EOF\");\n  config_helper_.addFilter(R\"EOF(\nname: passthrough-filter\n)EOF\");\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  auto response =\n      codec_client_->makeRequestWithBody(Http::TestHeaderMapImpl{{\":method\", \"GET\"},\n                                                                 {\":path\", \"/test/long/url\"},\n                                                                 {\":scheme\", \"http\"},\n                                                                 {\":authority\", \"host\"}},\n                                         128);\n  waitForNextUpstreamRequest();\n  upstream_request_->encodeHeaders(Http::TestHeaderMapImpl{{\":status\", \"503\"}}, false);\n  response->waitForEndStream();\n  if (upstreamProtocol() == FakeHttpConnection::Type::HTTP1) {\n    ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());\n  } else {\n    ASSERT_TRUE(upstream_request_->waitForReset());\n    ASSERT_TRUE(fake_upstream_connection_->close());\n    ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());\n  }\n\n  EXPECT_TRUE(response->complete());\n  EXPECT_EQ(\"503\", response->headers().Status()->value().getStringView());\n  EXPECT_EQ(0, response->body().size());\n}\n\nTEST_P(DownstreamProtocolIntegrationTest, HeadersOnlyFilterDecodingIntermediateFilters) {\n  config_helper_.addFilter(R\"EOF(\nname: passthrough-filter\n)EOF\");\n  config_helper_.addFilter(R\"EOF(\nname: decode-headers-only\n)EOF\");\n  config_helper_.addFilter(R\"EOF(\nname: passthrough-filter\n)EOF\");\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  auto response =\n      codec_client_->makeRequestWithBody(Http::TestHeaderMapImpl{{\":method\", \"POST\"},\n                                                                 {\":path\", \"/test/long/url\"},\n                                                                 {\":scheme\", \"http\"},\n                                                                 {\":authority\", \"host\"}},\n                                         128);\n  waitForNextUpstreamRequest();\n  upstream_request_->encodeHeaders(Http::TestHeaderMapImpl{{\":status\", \"503\"}}, false);\n  upstream_request_->encodeData(128, true);\n  response->waitForEndStream();\n\n  EXPECT_TRUE(response->complete());\n  EXPECT_EQ(\"503\", response->headers().Status()->value().getStringView());\n  EXPECT_EQ(128, response->body().size());\n}\n\n// Verifies behavior when request data is encoded after the request has been\n// turned into a headers-only request and the response has already begun.\nTEST_P(DownstreamProtocolIntegrationTest, HeadersOnlyFilterInterleaved) {\n  config_helper_.addFilter(R\"EOF(\nname: decode-headers-only\n)EOF\");\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  // First send the request headers. The filter should turn this into a header-only\n  // request.\n  auto encoder_decoder =\n      codec_client_->startRequest(Http::TestHeaderMapImpl{{\":method\", \"GET\"},\n                                                          {\":path\", \"/test/long/url\"},\n                                                          {\":scheme\", \"http\"},\n                                                          {\":authority\", \"host\"}});\n  request_encoder_ = &encoder_decoder.first;\n  auto response = std::move(encoder_decoder.second);\n\n  // Wait for the upstream request and begin sending a response with end_stream = false.\n  waitForNextUpstreamRequest();\n  upstream_request_->encodeHeaders(Http::TestHeaderMapImpl{{\":status\", \"503\"}}, false);\n\n  // Simulate additional data after the request has been turned into a headers only request.\n  Buffer::OwnedImpl data(std::string(128, 'a'));\n  request_encoder_->encodeData(data, false);\n\n  // End the response.\n  upstream_request_->encodeData(128, true);\n\n  response->waitForEndStream();\n  EXPECT_TRUE(response->complete());\n  EXPECT_EQ(\"503\", response->headers().Status()->value().getStringView());\n  EXPECT_EQ(0, upstream_request_->body().length());\n}\n\nTEST_P(DownstreamProtocolIntegrationTest, LargeRequestHeadersRejected) {\n  testLargeRequestHeaders(95, 60);\n}\n\nTEST_P(DownstreamProtocolIntegrationTest, LargeRequestHeadersAccepted) {\n  testLargeRequestHeaders(95, 96);\n}\n\nTEST_P(DownstreamProtocolIntegrationTest, ManyRequestHeadersTimeout) {\n  // Set timeout for 5 seconds, and ensure that a request with 20k+ headers can be sent.\n  testManyRequestHeaders(std::chrono::milliseconds(5000));\n}\n\nTEST_P(DownstreamProtocolIntegrationTest, LargeRequestTrailersAccepted) {\n  testLargeRequestTrailers(60, 96);\n}\n\nTEST_P(DownstreamProtocolIntegrationTest, LargeRequestTrailersRejected) {\n  testLargeRequestTrailers(66, 60);\n}\n\nTEST_P(DownstreamProtocolIntegrationTest, ManyTrailerHeaders) {\n  config_helper_.addConfigModifier(\n      [&](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager& hcm)\n          -> void { hcm.mutable_max_request_headers_kb()->set_value(96); });\n\n  Http::TestHeaderMapImpl request_trailers{};\n  for (int i = 0; i < 20000; i++) {\n    request_trailers.addCopy(std::to_string(i), \"\");\n  }\n\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  auto encoder_decoder =\n      codec_client_->startRequest(Http::TestHeaderMapImpl{{\":method\", \"POST\"},\n                                                          {\":path\", \"/test/long/url\"},\n                                                          {\":scheme\", \"http\"},\n                                                          {\":authority\", \"host\"}});\n  request_encoder_ = &encoder_decoder.first;\n  auto response = std::move(encoder_decoder.second);\n  codec_client_->sendTrailers(*request_encoder_, request_trailers);\n  waitForNextUpstreamRequest();\n  upstream_request_->encodeHeaders(default_response_headers_, true);\n  response->waitForEndStream();\n\n  EXPECT_TRUE(upstream_request_->complete());\n  EXPECT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().Status()->value().getStringView());\n}\n\n// Tests StopAllIterationAndBuffer. Verifies decode-headers-return-stop-all-filter calls decodeData\n// once after iteration is resumed.\nTEST_P(DownstreamProtocolIntegrationTest, testDecodeHeadersReturnsStopAll) {\n  config_helper_.addFilter(R\"EOF(\nname: call-decodedata-once-filter\n)EOF\");\n  config_helper_.addFilter(R\"EOF(\nname: decode-headers-return-stop-all-filter\n)EOF\");\n  config_helper_.addFilter(R\"EOF(\nname: passthrough-filter\n)EOF\");\n\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  // Sends a request with headers and data.\n  changeHeadersForStopAllTests(default_request_headers_, false);\n  auto encoder_decoder = codec_client_->startRequest(default_request_headers_);\n  request_encoder_ = &encoder_decoder.first;\n  auto response = std::move(encoder_decoder.second);\n  for (int i = 0; i < count_ - 1; i++) {\n    codec_client_->sendData(*request_encoder_, size_, false);\n  }\n  // Sleeps for 1s in order to be consistent with testDecodeHeadersReturnsStopAllWatermark.\n  sleep(1);\n  codec_client_->sendData(*request_encoder_, size_, true);\n  waitForNextUpstreamRequest();\n\n  upstream_request_->encodeHeaders(default_response_headers_, true);\n  response->waitForEndStream();\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(count_ * size_ + added_decoded_data_size_, upstream_request_->bodyLength());\n  EXPECT_EQ(true, upstream_request_->complete());\n\n  // Sends a request with headers, data, and trailers.\n  auto encoder_decoder_2 = codec_client_->startRequest(default_request_headers_);\n  request_encoder_ = &encoder_decoder_2.first;\n  response = std::move(encoder_decoder_2.second);\n  for (int i = 0; i < count_; i++) {\n    codec_client_->sendData(*request_encoder_, size_, false);\n  }\n  Http::TestHeaderMapImpl request_trailers{{\"trailer\", \"trailer\"}};\n  codec_client_->sendTrailers(*request_encoder_, request_trailers);\n  waitForNextUpstreamRequest();\n\n  upstream_request_->encodeHeaders(default_response_headers_, true);\n  response->waitForEndStream();\n  verifyUpStreamRequestAfterStopAllFilter();\n}\n\n// Tests StopAllIterationAndWatermark. decode-headers-return-stop-all-watermark-filter sets buffer\n// limit to 100. Verifies data pause when limit is reached, and resume after iteration continues.\nTEST_P(DownstreamProtocolIntegrationTest, testDecodeHeadersReturnsStopAllWatermark) {\n  config_helper_.addFilter(R\"EOF(\nname: decode-headers-return-stop-all-filter\n)EOF\");\n  config_helper_.addFilter(R\"EOF(\nname: passthrough-filter\n)EOF\");\n\n  // Sets initial stream window to min value to make the client sensitive to a low watermark.\n  config_helper_.addConfigModifier(\n      [&](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager& hcm)\n          -> void {\n        hcm.mutable_http2_protocol_options()->mutable_initial_stream_window_size()->set_value(\n            Http::Http2Settings::MIN_INITIAL_STREAM_WINDOW_SIZE);\n      });\n\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  // Sends a request with headers and data.\n  changeHeadersForStopAllTests(default_request_headers_, true);\n  auto encoder_decoder = codec_client_->startRequest(default_request_headers_);\n  request_encoder_ = &encoder_decoder.first;\n  auto response = std::move(encoder_decoder.second);\n  for (int i = 0; i < count_ - 1; i++) {\n    codec_client_->sendData(*request_encoder_, size_, false);\n  }\n  // Gives buffer 1s to react to buffer limit.\n  sleep(1);\n  codec_client_->sendData(*request_encoder_, size_, true);\n  waitForNextUpstreamRequest();\n\n  upstream_request_->encodeHeaders(default_response_headers_, true);\n  response->waitForEndStream();\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(count_ * size_ + added_decoded_data_size_, upstream_request_->bodyLength());\n  EXPECT_EQ(true, upstream_request_->complete());\n\n  // Sends a request with headers, data, and trailers.\n  auto encoder_decoder_2 = codec_client_->startRequest(default_request_headers_);\n  request_encoder_ = &encoder_decoder_2.first;\n  response = std::move(encoder_decoder_2.second);\n  for (int i = 0; i < count_ - 1; i++) {\n    codec_client_->sendData(*request_encoder_, size_, false);\n  }\n  // Gives buffer 1s to react to buffer limit.\n  sleep(1);\n  codec_client_->sendData(*request_encoder_, size_, false);\n  Http::TestHeaderMapImpl request_trailers{{\"trailer\", \"trailer\"}};\n  codec_client_->sendTrailers(*request_encoder_, request_trailers);\n  waitForNextUpstreamRequest();\n\n  upstream_request_->encodeHeaders(default_response_headers_, true);\n  response->waitForEndStream();\n  verifyUpStreamRequestAfterStopAllFilter();\n}\n\n// Test two filters that return StopAllIterationAndBuffer back-to-back.\nTEST_P(DownstreamProtocolIntegrationTest, testTwoFiltersDecodeHeadersReturnsStopAll) {\n  config_helper_.addFilter(R\"EOF(\nname: decode-headers-return-stop-all-filter\n)EOF\");\n  config_helper_.addFilter(R\"EOF(\nname: decode-headers-return-stop-all-filter\n)EOF\");\n  config_helper_.addFilter(R\"EOF(\nname: passthrough-filter\n)EOF\");\n\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  // Sends a request with headers and data.\n  changeHeadersForStopAllTests(default_request_headers_, false);\n  auto encoder_decoder = codec_client_->startRequest(default_request_headers_);\n  request_encoder_ = &encoder_decoder.first;\n  auto response = std::move(encoder_decoder.second);\n  for (int i = 0; i < count_ - 1; i++) {\n    codec_client_->sendData(*request_encoder_, size_, false);\n  }\n  codec_client_->sendData(*request_encoder_, size_, true);\n  waitForNextUpstreamRequest();\n\n  upstream_request_->encodeHeaders(default_response_headers_, true);\n  response->waitForEndStream();\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(count_ * size_ + added_decoded_data_size_, upstream_request_->bodyLength());\n  EXPECT_EQ(true, upstream_request_->complete());\n\n  // Sends a request with headers, data, and trailers.\n  auto encoder_decoder_2 = codec_client_->startRequest(default_request_headers_);\n  request_encoder_ = &encoder_decoder_2.first;\n  response = std::move(encoder_decoder_2.second);\n  for (int i = 0; i < count_; i++) {\n    codec_client_->sendData(*request_encoder_, size_, false);\n  }\n  Http::TestHeaderMapImpl request_trailers{{\"trailer\", \"trailer\"}};\n  codec_client_->sendTrailers(*request_encoder_, request_trailers);\n  waitForNextUpstreamRequest();\n\n  upstream_request_->encodeHeaders(default_response_headers_, true);\n  response->waitForEndStream();\n  verifyUpStreamRequestAfterStopAllFilter();\n}\n\n// Tests encodeHeaders() returns StopAllIterationAndBuffer.\nTEST_P(DownstreamProtocolIntegrationTest, testEncodeHeadersReturnsStopAll) {\n  config_helper_.addFilter(R\"EOF(\nname: encode-headers-return-stop-all-filter\n)EOF\");\n  config_helper_.addConfigModifier(\n      [&](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager& hcm)\n          -> void { hcm.mutable_http2_protocol_options()->set_allow_metadata(true); });\n\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  // Upstream responds with headers, data and trailers.\n  auto response = codec_client_->makeRequestWithBody(default_request_headers_, 10);\n  waitForNextUpstreamRequest();\n\n  changeHeadersForStopAllTests(default_response_headers_, false);\n  upstream_request_->encodeHeaders(default_response_headers_, false);\n  for (int i = 0; i < count_ - 1; i++) {\n    upstream_request_->encodeData(size_, false);\n  }\n  // Sleeps for 1s in order to be consistent with testEncodeHeadersReturnsStopAllWatermark.\n  sleep(1);\n  upstream_request_->encodeData(size_, false);\n  Http::TestHeaderMapImpl response_trailers{{\"response\", \"trailer\"}};\n  upstream_request_->encodeTrailers(response_trailers);\n\n  response->waitForEndStream();\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(count_ * size_ + added_decoded_data_size_, response->body().size());\n}\n\n// Tests encodeHeaders() returns StopAllIterationAndWatermark.\nTEST_P(DownstreamProtocolIntegrationTest, testEncodeHeadersReturnsStopAllWatermark) {\n  config_helper_.addFilter(R\"EOF(\nname: encode-headers-return-stop-all-filter\n)EOF\");\n  config_helper_.addConfigModifier(\n      [&](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager& hcm)\n          -> void { hcm.mutable_http2_protocol_options()->set_allow_metadata(true); });\n\n  // Sets initial stream window to min value to make the upstream sensitive to a low watermark.\n  config_helper_.addConfigModifier(\n      [&](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager& hcm)\n          -> void {\n        hcm.mutable_http2_protocol_options()->mutable_initial_stream_window_size()->set_value(\n            Http::Http2Settings::MIN_INITIAL_STREAM_WINDOW_SIZE);\n      });\n\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  // Upstream responds with headers, data and trailers.\n  auto response = codec_client_->makeRequestWithBody(default_request_headers_, 10);\n  waitForNextUpstreamRequest();\n\n  changeHeadersForStopAllTests(default_response_headers_, true);\n  upstream_request_->encodeHeaders(default_response_headers_, false);\n  for (int i = 0; i < count_ - 1; i++) {\n    upstream_request_->encodeData(size_, false);\n  }\n  // Gives buffer 1s to react to buffer limit.\n  sleep(1);\n  upstream_request_->encodeData(size_, false);\n  Http::TestHeaderMapImpl response_trailers{{\"response\", \"trailer\"}};\n  upstream_request_->encodeTrailers(response_trailers);\n\n  response->waitForEndStream();\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(count_ * size_ + added_decoded_data_size_, response->body().size());\n}\n\n// Per https://github.com/envoyproxy/envoy/issues/7488 make sure we don't\n// combine set-cookie headers\nTEST_P(ProtocolIntegrationTest, MultipleSetCookies) {\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  Http::TestHeaderMapImpl response_headers{\n      {\":status\", \"200\"}, {\"set-cookie\", \"foo\"}, {\"set-cookie\", \"bar\"}};\n\n  auto response = sendRequestAndWaitForResponse(default_request_headers_, 0, response_headers, 0);\n\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().Status()->value().getStringView());\n\n  std::vector<absl::string_view> out;\n  Http::HeaderUtility::getAllOfHeader(response->headers(), \"set-cookie\", out);\n  ASSERT_EQ(out.size(), 2);\n  ASSERT_EQ(out[0], \"foo\");\n  ASSERT_EQ(out[1], \"bar\");\n}\n\n// Resets the downstream stream immediately and verifies that we clean up everything.\nTEST_P(ProtocolIntegrationTest, TestDownstreamResetIdleTimeout) {\n  config_helper_.setDownstreamHttpIdleTimeout(std::chrono::milliseconds(100));\n\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  auto encoder_decoder = codec_client_->startRequest(default_request_headers_);\n\n  EXPECT_TRUE(fake_upstreams_[0]->waitForHttpConnection(*dispatcher_, fake_upstream_connection_,\n                                                        TestUtility::DefaultTimeout,\n                                                        max_request_headers_kb_));\n\n  EXPECT_TRUE(fake_upstream_connection_->waitForNewStream(*dispatcher_, upstream_request_));\n\n  if (downstreamProtocol() == Http::CodecClient::Type::HTTP1) {\n    codec_client_->close();\n  } else {\n    codec_client_->sendReset(encoder_decoder.first);\n  }\n\n  if (upstreamProtocol() == FakeHttpConnection::Type::HTTP1) {\n    ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());\n  } else {\n    ASSERT_TRUE(upstream_request_->waitForReset());\n    ASSERT_TRUE(fake_upstream_connection_->close());\n    ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());\n  }\n\n  codec_client_->waitForDisconnect();\n}\n\n// For tests which focus on downstream-to-Envoy behavior, and don't need to be\n// run with both HTTP/1 and HTTP/2 upstreams.\nINSTANTIATE_TEST_SUITE_P(Protocols, DownstreamProtocolIntegrationTest,\n                         testing::ValuesIn(HttpProtocolIntegrationTest::getProtocolTestParams(\n                             {Http::CodecClient::Type::HTTP1, Http::CodecClient::Type::HTTP2},\n                             {FakeHttpConnection::Type::HTTP1})),\n                         HttpProtocolIntegrationTest::protocolTestParamsToString);\n\nINSTANTIATE_TEST_SUITE_P(Protocols, ProtocolIntegrationTest,\n                         testing::ValuesIn(HttpProtocolIntegrationTest::getProtocolTestParams()),\n                         HttpProtocolIntegrationTest::protocolTestParamsToString);\n\n} // namespace Envoy\n"], "filenames": ["docs/root/intro/version_history.rst", "include/envoy/access_log/access_log.h", "include/envoy/http/header_map.h", "source/common/http/conn_manager_impl.cc", "source/common/http/header_map_impl.cc", "source/common/http/header_map_impl.h", "source/common/http/http1/codec_impl.cc", "source/common/http/http2/codec_impl.cc", "source/common/router/router.cc", "source/extensions/access_loggers/common/access_log_base.h", "source/extensions/access_loggers/grpc/http_grpc_access_log_impl.cc", "source/extensions/filters/common/expr/context.cc", "source/extensions/filters/http/rbac/rbac_filter.cc", "test/common/http/conn_manager_impl_test.cc", "test/common/http/header_map_impl_speed_test.cc", "test/common/http/header_map_impl_test.cc", "test/common/http/http2/codec_impl_test.cc", "test/integration/http2_integration_test.cc", "test/integration/http_integration.cc", "test/integration/http_integration.h", "test/integration/protocol_integration_test.cc"], "buggy_code_start_loc": [86, 80, 459, 508, 298, 18, 463, 511, 1400, 29, 98, 82, 78, 4412, 107, 368, 1091, 65, 263, 125, 578], "buggy_code_end_loc": [86, 80, 463, 728, 611, 201, 474, 814, 1400, 29, 127, 83, 107, 4457, 108, 846, 1103, 65, 918, 188, 852], "fixing_code_start_loc": [87, 81, 460, 509, 298, 19, 463, 512, 1401, 30, 98, 82, 79, 4411, 107, 369, 1092, 66, 263, 125, 579], "fixing_code_end_loc": [91, 85, 495, 731, 657, 219, 481, 825, 1410, 35, 127, 83, 116, 4411, 108, 898, 1105, 68, 983, 196, 935], "type": "CWE-400", "message": "Upon receiving each incoming request header data, Envoy will iterate over existing request headers to verify that the total size of the headers stays below a maximum limit. The implementation in versions 1.10.0 through 1.11.1 for HTTP/1.x traffic and all versions of Envoy for HTTP/2 traffic had O(n^2) performance characteristics. A remote attacker may craft a request that stays below the maximum request header size but consists of many thousands of small headers to consume CPU and result in a denial-of-service attack.", "other": {"cve": {"id": "CVE-2019-15226", "sourceIdentifier": "cve@mitre.org", "published": "2019-10-09T16:15:14.687", "lastModified": "2019-10-17T17:03:07.697", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Upon receiving each incoming request header data, Envoy will iterate over existing request headers to verify that the total size of the headers stays below a maximum limit. The implementation in versions 1.10.0 through 1.11.1 for HTTP/1.x traffic and all versions of Envoy for HTTP/2 traffic had O(n^2) performance characteristics. A remote attacker may craft a request that stays below the maximum request header size but consists of many thousands of small headers to consume CPU and result in a denial-of-service attack."}, {"lang": "es", "value": "Al recibir los datos de cada encabezado de petici\u00f3n entrante, Envoy iterar\u00e1 sobre los encabezados de petici\u00f3n existentes para comprobar que el tama\u00f1o total de los encabezados permanezca por debajo del l\u00edmite m\u00e1ximo. La implementaci\u00f3n en las versiones 1.10.0 hasta 1.11.1 para el tr\u00e1fico HTTP/1.x y todas las versiones de Envoy para el tr\u00e1fico HTTP/2 ten\u00edan caracter\u00edsticas de rendimiento O(n^2). Un atacante remoto puede crear una petici\u00f3n que se mantenga por debajo del tama\u00f1o m\u00e1ximo del encabezado de la petici\u00f3n, pero que consista en muchos miles de encabezados peque\u00f1os para consumir la CPU y resultar en un ataque de denegaci\u00f3n de servicio."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 7.8}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-400"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:envoyproxy:envoy:1.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "1A41CDE9-4AEA-4D10-B8AB-464DD392CDB9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:envoyproxy:envoy:1.1.0:*:*:*:*:*:*:*", "matchCriteriaId": "F0DB36A7-0053-45BE-A0E1-CEA00E3E19A6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:envoyproxy:envoy:1.2.0:*:*:*:*:*:*:*", "matchCriteriaId": "FA462017-5394-43F8-96ED-0EE177FE0873"}, {"vulnerable": true, "criteria": "cpe:2.3:a:envoyproxy:envoy:1.3.0:*:*:*:*:*:*:*", "matchCriteriaId": "4E80A9D3-D22E-4BE4-BAD7-BC56EF40A2F4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:envoyproxy:envoy:1.4.0:*:*:*:*:*:*:*", "matchCriteriaId": "5127853B-821C-47C6-9A25-76E9E66EE804"}, {"vulnerable": true, "criteria": "cpe:2.3:a:envoyproxy:envoy:1.5.0:*:*:*:*:*:*:*", "matchCriteriaId": "684F3C83-3F67-4D04-8CF0-A6038C7BF84A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:envoyproxy:envoy:1.6.0:*:*:*:*:*:*:*", "matchCriteriaId": "BC08C225-35BC-40BB-BFA4-9029ACB64F69"}, {"vulnerable": true, "criteria": "cpe:2.3:a:envoyproxy:envoy:1.7.0:*:*:*:*:*:*:*", "matchCriteriaId": "BF0082A6-4495-41FD-83F4-7FFC7CBD68C1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:envoyproxy:envoy:1.7.1:*:*:*:*:*:*:*", "matchCriteriaId": "9E55D00E-7B40-4CB9-A22B-979851493EC0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:envoyproxy:envoy:1.8.0:*:*:*:*:*:*:*", "matchCriteriaId": "A690019F-9ACC-4054-B886-2FB7D66B9965"}, {"vulnerable": true, "criteria": "cpe:2.3:a:envoyproxy:envoy:1.9.0:*:*:*:*:*:*:*", "matchCriteriaId": "EF8A839E-09A8-40C0-837B-C4096F7194A9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:envoyproxy:envoy:1.9.1:*:*:*:*:*:*:*", "matchCriteriaId": "1677F01F-0112-41FF-B2DF-0DC8C2C4D8EF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:envoyproxy:envoy:1.10.0:*:*:*:*:*:*:*", "matchCriteriaId": "87EF5304-3318-436B-B13B-0697DA591A20"}, {"vulnerable": true, "criteria": "cpe:2.3:a:envoyproxy:envoy:1.11.0:*:*:*:*:*:*:*", "matchCriteriaId": "4DC9B252-E49B-4D80-814B-3CC932CC64AC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:envoyproxy:envoy:1.11.1:*:*:*:*:*:*:*", "matchCriteriaId": "68F07BA5-07C7-4630-95AD-E40600B9BD1B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:envoyproxy:envoy:1.11.2:*:*:*:*:*:*:*", "matchCriteriaId": "D020CF31-4608-4917-AC10-C90B60BEC91C"}]}]}], "references": [{"url": "https://github.com/envoyproxy/envoy/commit/afc39bea36fd436e54262f150c009e8d72db5014", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/envoyproxy/envoy/commits/master", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/envoyproxy/envoy/issues/8520", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/envoyproxy/envoy/commit/afc39bea36fd436e54262f150c009e8d72db5014"}}