{"buggy_code": ["const entities = require('entities');\nconst cheerio = require('cheerio');\nconst { simplecc } = require('simplecc-wasm');\nconst got = require('@/utils/got');\nconst config = require('@/config').value;\nconst RE2 = require('re2');\n\nlet mercury_parser;\n\nconst resolveRelativeLink = ($, elem, attr, baseUrl) => {\n    const $elem = $(elem);\n\n    if (baseUrl) {\n        try {\n            const oldAttr = $elem.attr(attr);\n            if (oldAttr) {\n                // e.g. <video><source src=\"https://example.com\"></video> should leave <video> unchanged\n                $elem.attr(attr, new URL(oldAttr, baseUrl).href);\n            }\n        } catch (e) {\n            // no-empty\n        }\n    }\n};\n\nmodule.exports = async (ctx, next) => {\n    await next();\n\n    if (!ctx.state.data && !ctx._matchedRoute) {\n        // Given that the official demo has a cache TTL of 2h, a \"wrong path\" page will be cached by CloudFlare for\n        // 200h (8.33d).\n        // What makes it worse is that the documentation contains status badges to detect the availability of routes,\n        // but the documentation is updated more timely than the official demo, so the every example path of every\n        // new route will probably have a \"wrong path\" page cached for at least 200h soon after accepted. That is to\n        // say, the example paths of a new route will probably be unavailable on the public demo in the first 200h\n        // after accepted.\n        // As a conclusion, the next 3 lines has been commented out. (exactly the same behavior as any internal error)\n        // ctx.set({\n        //     'Cache-Control': `public, max-age=${config.cache.routeExpire * 100}`,\n        // });\n        throw Error('wrong path');\n    }\n\n    if (ctx.state.data) {\n        if ((!ctx.state.data.item || ctx.state.data.item.length === 0) && !ctx.state.data.allowEmpty) {\n            throw Error('this route is empty, please check the original site or <a href=\"https://github.com/DIYgod/RSSHub/issues/new/choose\">create an issue</a>');\n        }\n\n        // fix allowEmpty\n        ctx.state.data.item = ctx.state.data.item || [];\n\n        // decode HTML entities\n        ctx.state.data.title && (ctx.state.data.title = entities.decodeXML(ctx.state.data.title + ''));\n        ctx.state.data.description && (ctx.state.data.description = entities.decodeXML(ctx.state.data.description + ''));\n\n        // sort items\n        if (ctx.query.sorted !== 'false') {\n            ctx.state.data.item = ctx.state.data.item.sort((a, b) => +new Date(b.pubDate || 0) - +new Date(a.pubDate || 0));\n        }\n\n        const handleItem = (item) => {\n            item.title && (item.title = entities.decodeXML(item.title + ''));\n\n            // handle pubDate\n            if (item.pubDate) {\n                item.pubDate = new Date(item.pubDate).toUTCString();\n            }\n\n            // handle link\n            if (item.link) {\n                let baseUrl = ctx.state.data.link;\n                if (baseUrl && !baseUrl.match(/^https?:\\/\\//)) {\n                    if (baseUrl.match(/^\\/\\//)) {\n                        baseUrl = 'http:' + baseUrl;\n                    } else {\n                        baseUrl = 'http://' + baseUrl;\n                    }\n                }\n\n                item.link = new URL(item.link, baseUrl).href;\n            }\n\n            // handle description\n            if (item.description) {\n                const $ = cheerio.load(item.description);\n                let baseUrl = item.link || ctx.state.data.link;\n\n                if (baseUrl && !baseUrl.match(/^https?:\\/\\//)) {\n                    if (baseUrl.match(/^\\/\\//)) {\n                        baseUrl = 'http:' + baseUrl;\n                    } else {\n                        baseUrl = 'http://' + baseUrl;\n                    }\n                }\n\n                $('script').remove();\n\n                $('img').each((_, ele) => {\n                    const $ele = $(ele);\n\n                    // fix lazyload\n                    if (!$ele.attr('src')) {\n                        const lazySrc = $ele.attr('data-src') || $ele.attr('data-original');\n                        if (lazySrc) {\n                            $ele.attr('src', lazySrc);\n                        } else {\n                            for (const key in ele.attribs) {\n                                const value = ele.attribs[key].trim();\n                                if (['.gif', '.png', '.jpg', '.webp'].some((suffix) => value.includes(suffix))) {\n                                    $ele.attr('src', value);\n                                    break;\n                                }\n                            }\n                        }\n                    }\n\n                    // redundant attributes\n                    ['onclick', 'onerror', 'onload'].forEach((e) => {\n                        $ele.removeAttr(e);\n                    });\n                });\n\n                // resolve relative link & fix referrer policy\n                // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy\n                // https://www.w3schools.com/tags/att_href.asp\n                $('a, area').each((_, elem) => {\n                    resolveRelativeLink($, elem, 'href', baseUrl);\n                    // $(elem).attr('rel', 'noreferrer');  // currently no such a need\n                });\n                // https://www.w3schools.com/tags/att_src.asp\n                $('img, video, audio, source, iframe, embed, track').each((_, elem) => {\n                    resolveRelativeLink($, elem, 'src', baseUrl);\n                });\n                $('video[poster]').each((_, elem) => {\n                    resolveRelativeLink($, elem, 'poster', baseUrl);\n                });\n                $('img, iframe').each((_, elem) => {\n                    $(elem).attr('referrerpolicy', 'no-referrer');\n                });\n\n                item.description = $('body').html() + '' + (config.suffix || '');\n\n                if (item._extra?.links && $('.rsshub-quote').length) {\n                    item._extra?.links?.map((e) => {\n                        e.content_html = $.html($('.rsshub-quote'));\n                        return e;\n                    });\n                }\n            }\n            return item;\n        };\n\n        ctx.state.data.item = await Promise.all(ctx.state.data.item.map(handleItem));\n\n        if (ctx.query) {\n            // limit\n            if (ctx.query.limit) {\n                ctx.state.data.item = ctx.state.data.item.slice(0, parseInt(ctx.query.limit));\n            }\n\n            // filter\n            const makeRegex = (string) => {\n                // default: case_senstivie = true\n                const engine = config.feature.filter_regex_engine;\n                if (ctx.query.filter_case_sensitive === 'false') {\n                    switch (engine) {\n                        case 'regexp':\n                            return new RegExp(string, 'i');\n                        case 're2':\n                            return new RE2(string, 'i');\n                        default:\n                            throw Error(`Invalid Engine Value: ${engine}, please check your config.`);\n                    }\n                } else {\n                    switch (engine) {\n                        case 'regexp':\n                            return new RegExp(string);\n                        case 're2':\n                            return new RE2(string);\n                        default:\n                            throw Error(`Invalid Engine Value: ${engine}, please check your config.`);\n                    }\n                }\n            };\n\n            if (ctx.query.filter) {\n                ctx.state.data.item = ctx.state.data.item.filter((item) => {\n                    const title = item.title || '';\n                    const description = item.description || title;\n                    const author = item.author || '';\n                    const category = item.category ? (Array.isArray(item.category) ? item.category : [item.category]) : [];\n                    const isFilter =\n                        title.match(makeRegex(ctx.query.filter)) || description.match(makeRegex(ctx.query.filter)) || author.match(makeRegex(ctx.query.filter)) || category.some((c) => c.match(makeRegex(ctx.query.filter)));\n                    return isFilter;\n                });\n            }\n\n            // \u542f\u7528filter\u53c2\u6570\u65f6\uff0c\u65e0\u6548filter_title/description/author/category\n            if (!ctx.query.filter && (ctx.query.filter_title || ctx.query.filter_description || ctx.query.filter_author || ctx.query.filter_category)) {\n                ctx.state.data.item = ctx.state.data.item.filter((item) => {\n                    const title = item.title || '';\n                    const description = item.description || title;\n                    const author = item.author || '';\n                    const category = item.category ? (Array.isArray(item.category) ? item.category : [item.category]) : [];\n                    let isFilter = true;\n                    ctx.query.filter_title && (isFilter = title.match(makeRegex(ctx.query.filter_title)));\n                    ctx.query.filter_description && (isFilter = isFilter && description.match(makeRegex(ctx.query.filter_description)));\n                    ctx.query.filter_author && (isFilter = isFilter && author.match(makeRegex(ctx.query.filter_author)));\n                    ctx.query.filter_category && (isFilter = isFilter && category.some((c) => c.match(makeRegex(ctx.query.filter_category))));\n                    return isFilter;\n                });\n            }\n\n            if (ctx.query.filterout || ctx.query.filterout_title || ctx.query.filterout_description || ctx.query.filterout_author || ctx.query.filterout_category) {\n                if (ctx.query.filterout) {\n                    ctx.query.filterout_title = ctx.query.filterout;\n                    ctx.query.filterout_description = ctx.query.filterout;\n                }\n                ctx.state.data.item = ctx.state.data.item.filter((item) => {\n                    const title = item.title;\n                    const description = item.description || title;\n                    const author = item.author || '';\n                    const category = item.category ? (Array.isArray(item.category) ? item.category : [item.category]) : [];\n                    let isFilter = true;\n                    ctx.query.filterout_title && (isFilter = !title.match(makeRegex(ctx.query.filterout_title)));\n                    ctx.query.filterout_description && (isFilter = isFilter && !description.match(makeRegex(ctx.query.filterout_description)));\n                    ctx.query.filterout_author && (isFilter = isFilter && !author.match(makeRegex(ctx.query.filterout_author)));\n                    ctx.query.filterout_category && (isFilter = isFilter && !category.some((c) => c.match(makeRegex(ctx.query.filterout_category))));\n                    return isFilter;\n                });\n            }\n\n            if (ctx.query.filter_time) {\n                const now = Date.now();\n                ctx.state.data.item = ctx.state.data.item.filter(({ pubDate }) => {\n                    let isFilter = true;\n                    try {\n                        isFilter = !pubDate || now - new Date(pubDate).getTime() <= parseInt(ctx.query.filter_time) * 1000;\n                    } catch (err) {\n                        // no-empty\n                    }\n                    return isFilter;\n                });\n            }\n\n            // telegram instant view\n            if (ctx.query.tgiv) {\n                ctx.state.data.item.map((item) => {\n                    const encodedlink = encodeURIComponent(item.link);\n                    item.link = `https://t.me/iv?url=${encodedlink}&rhash=${ctx.query.tgiv}`;\n                    return item;\n                });\n            }\n\n            // fulltext\n            if (ctx.query.mode && ctx.query.mode.toLowerCase() === 'fulltext') {\n                const tasks = ctx.state.data.item.map(async (item) => {\n                    const { link, author, description } = item;\n                    const parsed_result = await ctx.cache.tryGet(`mercury-cache-${link}`, async () => {\n                        // if parser failed, return default description and not report error\n                        try {\n                            mercury_parser = mercury_parser || require('@postlight/parser');\n\n                            const { data: res } = await got(link);\n                            const $ = cheerio.load(res);\n                            const result = await mercury_parser.parse(link, {\n                                html: $.html(),\n                            });\n                            return result;\n                        } catch (e) {\n                            // no-empty\n                        }\n                    });\n\n                    item.author = author || (parsed_result ? parsed_result.author : '');\n                    item.description = parsed_result && parsed_result.content.length > 40 ? entities.decodeXML(parsed_result.content) : description;\n                });\n                await Promise.all(tasks);\n            }\n\n            // scihub\n            if (ctx.query.scihub) {\n                ctx.state.data.item.map((item) => {\n                    item.link = item.doi ? `${config.scihub.host}${item.doi}` : `${config.scihub.host}${item.link}`;\n                    return item;\n                });\n            }\n\n            // opencc\n            if (ctx.query.opencc) {\n                ctx.state.data.item.forEach((item) => {\n                    item.title = simplecc(item.title ?? item.link, ctx.query.opencc);\n                    item.description = simplecc(item.description ?? item.title ?? item.link, ctx.query.opencc);\n                });\n            }\n\n            // brief\n            if (ctx.query.brief) {\n                const num = /[1-9]\\d{2,}/;\n                if (num.test(ctx.query.brief)) {\n                    ctx.query.brief = parseInt(ctx.query.brief);\n                    ctx.state.data.item.forEach((item) => {\n                        let text;\n                        if (item.description) {\n                            text = item.description.replace(/<\\/?[^>]+(>|$)/g, '');\n                        }\n                        if (text && text.length) {\n                            if (text.length > ctx.query.brief) {\n                                item.description = `<p>${text.substring(0, ctx.query.brief)}\u2026</p>`;\n                            } else {\n                                item.description = `<p>${text}</p>`;\n                            }\n                        }\n                    });\n                } else {\n                    throw Error(`Invalid parameter <code>brief=${ctx.query.brief}</code>. Please check the doc https://docs.rsshub.app/parameter.html#shu-chu-jian-xun`);\n                }\n            }\n\n            // some parameters are processed in `anti-hotlink.js`\n        }\n    }\n};\n"], "fixing_code": ["const entities = require('entities');\nconst cheerio = require('cheerio');\nconst { simplecc } = require('simplecc-wasm');\nconst got = require('@/utils/got');\nconst config = require('@/config').value;\nconst RE2 = require('re2');\n\nlet mercury_parser;\n\nconst resolveRelativeLink = ($, elem, attr, baseUrl) => {\n    const $elem = $(elem);\n\n    if (baseUrl) {\n        try {\n            const oldAttr = $elem.attr(attr);\n            if (oldAttr) {\n                // e.g. <video><source src=\"https://example.com\"></video> should leave <video> unchanged\n                $elem.attr(attr, new URL(oldAttr, baseUrl).href);\n            }\n        } catch (e) {\n            // no-empty\n        }\n    }\n};\n\nmodule.exports = async (ctx, next) => {\n    await next();\n\n    if (!ctx.state.data && !ctx._matchedRoute) {\n        // Given that the official demo has a cache TTL of 2h, a \"wrong path\" page will be cached by CloudFlare for\n        // 200h (8.33d).\n        // What makes it worse is that the documentation contains status badges to detect the availability of routes,\n        // but the documentation is updated more timely than the official demo, so the every example path of every\n        // new route will probably have a \"wrong path\" page cached for at least 200h soon after accepted. That is to\n        // say, the example paths of a new route will probably be unavailable on the public demo in the first 200h\n        // after accepted.\n        // As a conclusion, the next 3 lines has been commented out. (exactly the same behavior as any internal error)\n        // ctx.set({\n        //     'Cache-Control': `public, max-age=${config.cache.routeExpire * 100}`,\n        // });\n        throw Error('wrong path');\n    }\n\n    if (ctx.state.data) {\n        if ((!ctx.state.data.item || ctx.state.data.item.length === 0) && !ctx.state.data.allowEmpty) {\n            throw Error('this route is empty, please check the original site or <a href=\"https://github.com/DIYgod/RSSHub/issues/new/choose\">create an issue</a>');\n        }\n\n        // fix allowEmpty\n        ctx.state.data.item = ctx.state.data.item || [];\n\n        // decode HTML entities\n        ctx.state.data.title && (ctx.state.data.title = entities.decodeXML(ctx.state.data.title + ''));\n        ctx.state.data.description && (ctx.state.data.description = entities.decodeXML(ctx.state.data.description + ''));\n\n        // sort items\n        if (ctx.query.sorted !== 'false') {\n            ctx.state.data.item = ctx.state.data.item.sort((a, b) => +new Date(b.pubDate || 0) - +new Date(a.pubDate || 0));\n        }\n\n        const handleItem = (item) => {\n            item.title && (item.title = entities.decodeXML(item.title + ''));\n\n            // handle pubDate\n            if (item.pubDate) {\n                item.pubDate = new Date(item.pubDate).toUTCString();\n            }\n\n            // handle link\n            if (item.link) {\n                let baseUrl = ctx.state.data.link;\n                if (baseUrl && !baseUrl.match(/^https?:\\/\\//)) {\n                    if (baseUrl.match(/^\\/\\//)) {\n                        baseUrl = 'http:' + baseUrl;\n                    } else {\n                        baseUrl = 'http://' + baseUrl;\n                    }\n                }\n\n                item.link = new URL(item.link, baseUrl).href;\n            }\n\n            // handle description\n            if (item.description) {\n                const $ = cheerio.load(item.description);\n                let baseUrl = item.link || ctx.state.data.link;\n\n                if (baseUrl && !baseUrl.match(/^https?:\\/\\//)) {\n                    if (baseUrl.match(/^\\/\\//)) {\n                        baseUrl = 'http:' + baseUrl;\n                    } else {\n                        baseUrl = 'http://' + baseUrl;\n                    }\n                }\n\n                $('script').remove();\n\n                $('img').each((_, ele) => {\n                    const $ele = $(ele);\n\n                    // fix lazyload\n                    if (!$ele.attr('src')) {\n                        const lazySrc = $ele.attr('data-src') || $ele.attr('data-original');\n                        if (lazySrc) {\n                            $ele.attr('src', lazySrc);\n                        } else {\n                            for (const key in ele.attribs) {\n                                const value = ele.attribs[key].trim();\n                                if (['.gif', '.png', '.jpg', '.webp'].some((suffix) => value.includes(suffix))) {\n                                    $ele.attr('src', value);\n                                    break;\n                                }\n                            }\n                        }\n                    }\n\n                    // redundant attributes\n                    ['onclick', 'onerror', 'onload'].forEach((e) => {\n                        $ele.removeAttr(e);\n                    });\n                });\n\n                // resolve relative link & fix referrer policy\n                // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy\n                // https://www.w3schools.com/tags/att_href.asp\n                $('a, area').each((_, elem) => {\n                    resolveRelativeLink($, elem, 'href', baseUrl);\n                    // $(elem).attr('rel', 'noreferrer');  // currently no such a need\n                });\n                // https://www.w3schools.com/tags/att_src.asp\n                $('img, video, audio, source, iframe, embed, track').each((_, elem) => {\n                    resolveRelativeLink($, elem, 'src', baseUrl);\n                });\n                $('video[poster]').each((_, elem) => {\n                    resolveRelativeLink($, elem, 'poster', baseUrl);\n                });\n                $('img, iframe').each((_, elem) => {\n                    $(elem).attr('referrerpolicy', 'no-referrer');\n                });\n\n                item.description = $('body').html() + '' + (config.suffix || '');\n\n                if (item._extra?.links && $('.rsshub-quote').length) {\n                    item._extra?.links?.map((e) => {\n                        e.content_html = $.html($('.rsshub-quote'));\n                        return e;\n                    });\n                }\n            }\n            return item;\n        };\n\n        ctx.state.data.item = await Promise.all(ctx.state.data.item.map(handleItem));\n\n        if (ctx.query) {\n            // limit\n            if (ctx.query.limit) {\n                ctx.state.data.item = ctx.state.data.item.slice(0, parseInt(ctx.query.limit));\n            }\n\n            // filter\n            const makeRegex = (string) => {\n                // default: case_senstivie = true\n                const engine = config.feature.filter_regex_engine;\n                if (ctx.query.filter_case_sensitive === 'false') {\n                    switch (engine) {\n                        case 'regexp':\n                            return new RegExp(string, 'i');\n                        case 're2':\n                            return new RE2(string, 'i');\n                        default:\n                            throw Error(`Invalid Engine Value: ${engine}, please check your config.`);\n                    }\n                } else {\n                    switch (engine) {\n                        case 'regexp':\n                            return new RegExp(string);\n                        case 're2':\n                            return new RE2(string);\n                        default:\n                            throw Error(`Invalid Engine Value: ${engine}, please check your config.`);\n                    }\n                }\n            };\n\n            if (ctx.query.filter) {\n                ctx.state.data.item = ctx.state.data.item.filter((item) => {\n                    const title = item.title || '';\n                    const description = item.description || title;\n                    const author = item.author || '';\n                    const category = item.category ? (Array.isArray(item.category) ? item.category : [item.category]) : [];\n                    const isFilter =\n                        title.match(makeRegex(ctx.query.filter)) || description.match(makeRegex(ctx.query.filter)) || author.match(makeRegex(ctx.query.filter)) || category.some((c) => c.match(makeRegex(ctx.query.filter)));\n                    return isFilter;\n                });\n            }\n\n            // \u542f\u7528filter\u53c2\u6570\u65f6\uff0c\u65e0\u6548filter_title/description/author/category\n            if (!ctx.query.filter && (ctx.query.filter_title || ctx.query.filter_description || ctx.query.filter_author || ctx.query.filter_category)) {\n                ctx.state.data.item = ctx.state.data.item.filter((item) => {\n                    const title = item.title || '';\n                    const description = item.description || title;\n                    const author = item.author || '';\n                    const category = item.category ? (Array.isArray(item.category) ? item.category : [item.category]) : [];\n                    let isFilter = true;\n                    ctx.query.filter_title && (isFilter = title.match(makeRegex(ctx.query.filter_title)));\n                    ctx.query.filter_description && (isFilter = isFilter && description.match(makeRegex(ctx.query.filter_description)));\n                    ctx.query.filter_author && (isFilter = isFilter && author.match(makeRegex(ctx.query.filter_author)));\n                    ctx.query.filter_category && (isFilter = isFilter && category.some((c) => c.match(makeRegex(ctx.query.filter_category))));\n                    return isFilter;\n                });\n            }\n\n            if (ctx.query.filterout || ctx.query.filterout_title || ctx.query.filterout_description || ctx.query.filterout_author || ctx.query.filterout_category) {\n                if (ctx.query.filterout) {\n                    ctx.query.filterout_title = ctx.query.filterout;\n                    ctx.query.filterout_description = ctx.query.filterout;\n                }\n                ctx.state.data.item = ctx.state.data.item.filter((item) => {\n                    const title = item.title;\n                    const description = item.description || title;\n                    const author = item.author || '';\n                    const category = item.category ? (Array.isArray(item.category) ? item.category : [item.category]) : [];\n                    let isFilter = true;\n                    ctx.query.filterout_title && (isFilter = !title.match(makeRegex(ctx.query.filterout_title)));\n                    ctx.query.filterout_description && (isFilter = isFilter && !description.match(makeRegex(ctx.query.filterout_description)));\n                    ctx.query.filterout_author && (isFilter = isFilter && !author.match(makeRegex(ctx.query.filterout_author)));\n                    ctx.query.filterout_category && (isFilter = isFilter && !category.some((c) => c.match(makeRegex(ctx.query.filterout_category))));\n                    return isFilter;\n                });\n            }\n\n            if (ctx.query.filter_time) {\n                const now = Date.now();\n                ctx.state.data.item = ctx.state.data.item.filter(({ pubDate }) => {\n                    let isFilter = true;\n                    try {\n                        isFilter = !pubDate || now - new Date(pubDate).getTime() <= parseInt(ctx.query.filter_time) * 1000;\n                    } catch (err) {\n                        // no-empty\n                    }\n                    return isFilter;\n                });\n            }\n\n            // telegram instant view\n            if (ctx.query.tgiv) {\n                ctx.state.data.item.map((item) => {\n                    const encodedlink = encodeURIComponent(item.link);\n                    item.link = `https://t.me/iv?url=${encodedlink}&rhash=${ctx.query.tgiv}`;\n                    return item;\n                });\n            }\n\n            // fulltext\n            if (ctx.query.mode && ctx.query.mode.toLowerCase() === 'fulltext') {\n                const tasks = ctx.state.data.item.map(async (item) => {\n                    const { link, author, description } = item;\n                    const parsed_result = await ctx.cache.tryGet(`mercury-cache-${link}`, async () => {\n                        // if parser failed, return default description and not report error\n                        try {\n                            mercury_parser = mercury_parser || require('@postlight/parser');\n\n                            const { data: res } = await got(link);\n                            const $ = cheerio.load(res);\n                            const result = await mercury_parser.parse(link, {\n                                html: $.html(),\n                            });\n                            return result;\n                        } catch (e) {\n                            // no-empty\n                        }\n                    });\n\n                    item.author = author || (parsed_result ? parsed_result.author : '');\n                    item.description = parsed_result && parsed_result.content.length > 40 ? entities.decodeXML(parsed_result.content) : description;\n                });\n                await Promise.all(tasks);\n            }\n\n            // scihub\n            if (ctx.query.scihub) {\n                ctx.state.data.item.map((item) => {\n                    item.link = item.doi ? `${config.scihub.host}${item.doi}` : `${config.scihub.host}${item.link}`;\n                    return item;\n                });\n            }\n\n            // opencc\n            if (ctx.query.opencc) {\n                ctx.state.data.item.forEach((item) => {\n                    item.title = simplecc(item.title ?? item.link, ctx.query.opencc);\n                    item.description = simplecc(item.description ?? item.title ?? item.link, ctx.query.opencc);\n                });\n            }\n\n            // brief\n            if (ctx.query.brief) {\n                const num = /[1-9]\\d{2,}/;\n                if (num.test(ctx.query.brief)) {\n                    ctx.query.brief = parseInt(ctx.query.brief);\n                    ctx.state.data.item.forEach((item) => {\n                        let text;\n                        if (item.description) {\n                            text = item.description.replace(/<\\/?[^>]+(>|$)/g, '');\n                        }\n                        if (text && text.length) {\n                            if (text.length > ctx.query.brief) {\n                                item.description = `<p>${text.substring(0, ctx.query.brief)}\u2026</p>`;\n                            } else {\n                                item.description = `<p>${text}</p>`;\n                            }\n                        }\n                    });\n                } else {\n                    throw Error(`Invalid parameter brief. Please check the doc https://docs.rsshub.app/parameter.html#shu-chu-jian-xun`);\n                }\n            }\n\n            // some parameters are processed in `anti-hotlink.js`\n        }\n    }\n};\n"], "filenames": ["lib/middleware/parameter.js"], "buggy_code_start_loc": [316], "buggy_code_end_loc": [317], "fixing_code_start_loc": [316], "fixing_code_end_loc": [317], "type": "CWE-79", "message": "RSSHub is an open source and extensible RSS feed generator. When the URL parameters contain certain special characters, it returns an error page that does not properly handle XSS vulnerabilities, allowing for the execution of arbitrary JavaScript code. Users who access the deliberately constructed URL are affected. This vulnerability was fixed in version c910c4d28717fb860fbe064736641f379fab2c91. Please upgrade to this or a later version, there are no known workarounds.", "other": {"cve": {"id": "CVE-2023-26491", "sourceIdentifier": "security-advisories@github.com", "published": "2023-03-03T23:15:12.427", "lastModified": "2023-03-13T17:00:21.960", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "RSSHub is an open source and extensible RSS feed generator. When the URL parameters contain certain special characters, it returns an error page that does not properly handle XSS vulnerabilities, allowing for the execution of arbitrary JavaScript code. Users who access the deliberately constructed URL are affected. This vulnerability was fixed in version c910c4d28717fb860fbe064736641f379fab2c91. Please upgrade to this or a later version, there are no known workarounds."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:L/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.5}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:rsshub:rsshub:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "2023-03-02", "matchCriteriaId": "98548C91-26F9-4604-BCC4-EB1DEC380700"}]}]}], "references": [{"url": "https://github.com/DIYgod/RSSHub/commit/c910c4d28717fb860fbe064736641f379fab2c91", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/DIYgod/RSSHub/security/advisories/GHSA-32gr-4cq6-5w5q", "source": "security-advisories@github.com", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/DIYgod/RSSHub/commit/c910c4d28717fb860fbe064736641f379fab2c91"}}