{"buggy_code": ["package dockerfile\n\nimport (\n\t\"context\"\n\t\"encoding/base64\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/containerd/continuity/fs/fstest\"\n\t\"github.com/moby/buildkit/client\"\n\t\"github.com/moby/buildkit/exporter/containerimage/exptypes\"\n\t\"github.com/moby/buildkit/frontend/dockerui\"\n\tgateway \"github.com/moby/buildkit/frontend/gateway/client\"\n\t\"github.com/moby/buildkit/solver/pb\"\n\tbinfotypes \"github.com/moby/buildkit/util/buildinfo/types\"\n\t\"github.com/moby/buildkit/util/testutil/integration\"\n\t\"github.com/pkg/errors\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nvar buildinfoTests = integration.TestFuncs(\n\ttestBuildInfoSources,\n\ttestBuildInfoSourcesNoop,\n\ttestBuildInfoAttrs,\n\ttestBuildInfoMultiPlatform,\n\ttestBuildInfoImageContext,\n\ttestBuildInfoLocalContext,\n\ttestBuildInfoDeps,\n\ttestBuildInfoDepsMultiPlatform,\n\ttestBuildInfoDepsMainNoSource,\n)\n\nfunc init() {\n\tallTests = append(allTests, buildinfoTests...)\n}\n\n// moby/buildkit#2311\nfunc testBuildInfoSources(t *testing.T, sb integration.Sandbox) {\n\tf := getFrontend(t, sb)\n\tf.RequiresBuildctl(t)\n\n\tgitDir := t.TempDir()\n\n\tdockerfile := `\nFROM alpine:latest@sha256:21a3deaa0d32a8057914f36584b5288d2e5ecc984380bc0118285c70fa8c9300 AS alpine\nFROM busybox:latest\nADD https://raw.githubusercontent.com/moby/moby/v20.10.21/README.md /\nCOPY --from=alpine /bin/busybox /alpine-busybox\n`\n\n\terr := os.WriteFile(filepath.Join(gitDir, \"Dockerfile\"), []byte(dockerfile), 0600)\n\trequire.NoError(t, err)\n\n\terr = runShell(gitDir,\n\t\t\"git init\",\n\t\t\"git config --local user.email test\",\n\t\t\"git config --local user.name test\",\n\t\t\"git add Dockerfile\",\n\t\t\"git commit -m initial\",\n\t\t\"git branch buildinfo\",\n\t\t\"git update-server-info\",\n\t)\n\trequire.NoError(t, err)\n\n\tserver := httptest.NewServer(http.FileServer(http.Dir(filepath.Join(gitDir))))\n\tdefer server.Close()\n\n\tc, err := client.New(sb.Context(), sb.Address())\n\trequire.NoError(t, err)\n\tdefer c.Close()\n\n\tvar exports []client.ExportEntry\n\tif integration.IsTestDockerdMoby(sb) {\n\t\texports = []client.ExportEntry{{\n\t\t\tType: \"moby\",\n\t\t\tAttrs: map[string]string{\n\t\t\t\t\"name\": \"reg.dummy:5000/buildkit/test:latest\",\n\t\t\t},\n\t\t}}\n\t} else {\n\t\texports = []client.ExportEntry{{\n\t\t\tType:   client.ExporterOCI,\n\t\t\tAttrs:  map[string]string{},\n\t\t\tOutput: fixedWriteCloser(nopWriteCloser{io.Discard}),\n\t\t}}\n\t}\n\n\tres, err := f.Solve(sb.Context(), c, client.SolveOpt{\n\t\tExports: exports,\n\t\tFrontendAttrs: map[string]string{\n\t\t\tdockerui.DefaultLocalNameContext: server.URL + \"/.git#buildinfo\",\n\t\t},\n\t}, nil)\n\trequire.NoError(t, err)\n\n\trequire.Contains(t, res.ExporterResponse, exptypes.ExporterBuildInfo)\n\tdtbi, err := base64.StdEncoding.DecodeString(res.ExporterResponse[exptypes.ExporterBuildInfo])\n\trequire.NoError(t, err)\n\n\tvar bi binfotypes.BuildInfo\n\terr = json.Unmarshal(dtbi, &bi)\n\trequire.NoError(t, err)\n\n\trequire.Contains(t, bi.Attrs, \"context\")\n\trequire.Equal(t, server.URL+\"/.git#buildinfo\", *bi.Attrs[\"context\"])\n\n\t_, isGateway := f.(*gatewayFrontend)\n\n\tsources := bi.Sources\n\tif isGateway {\n\t\trequire.Equal(t, 5, len(sources), \"%+v\", sources)\n\t\tassert.Equal(t, binfotypes.SourceTypeDockerImage, sources[0].Type)\n\t\tassert.Contains(t, sources[0].Ref, \"buildkit_test\")\n\t\tsources = sources[1:]\n\t}\n\trequire.Equal(t, 4, len(sources), \"%+v\", sources)\n\tassert.Equal(t, binfotypes.SourceTypeDockerImage, sources[0].Type)\n\tassert.Equal(t, \"docker.io/library/alpine:latest@sha256:21a3deaa0d32a8057914f36584b5288d2e5ecc984380bc0118285c70fa8c9300\", sources[0].Ref)\n\tassert.Equal(t, \"sha256:21a3deaa0d32a8057914f36584b5288d2e5ecc984380bc0118285c70fa8c9300\", sources[0].Pin)\n\n\tassert.Equal(t, binfotypes.SourceTypeDockerImage, sources[1].Type)\n\tassert.Equal(t, \"docker.io/library/busybox:latest\", sources[1].Ref)\n\tassert.NotEmpty(t, sources[1].Pin)\n\n\tassert.Equal(t, binfotypes.SourceTypeGit, sources[2].Type)\n\tassert.Equal(t, server.URL+\"/.git#buildinfo\", sources[2].Ref)\n\tassert.NotEmpty(t, sources[2].Pin)\n\n\tassert.Equal(t, binfotypes.SourceTypeHTTP, sources[3].Type)\n\tassert.Equal(t, \"https://raw.githubusercontent.com/moby/moby/v20.10.21/README.md\", sources[3].Ref)\n\tassert.Equal(t, \"sha256:419455202b0ef97e480d7f8199b26a721a417818bc0e2d106975f74323f25e6c\", sources[3].Pin)\n}\n\nfunc testBuildInfoSourcesNoop(t *testing.T, sb integration.Sandbox) {\n\tf := getFrontend(t, sb)\n\tf.RequiresBuildctl(t)\n\n\tdockerfile := `\nFROM busybox:latest\n`\n\n\tdir, err := integration.Tmpdir(\n\t\tt,\n\t\tfstest.CreateFile(\"Dockerfile\", []byte(dockerfile), 0600),\n\t)\n\trequire.NoError(t, err)\n\n\tc, err := client.New(sb.Context(), sb.Address())\n\trequire.NoError(t, err)\n\tdefer c.Close()\n\n\tvar exports []client.ExportEntry\n\tif integration.IsTestDockerdMoby(sb) {\n\t\texports = []client.ExportEntry{{\n\t\t\tType: \"moby\",\n\t\t\tAttrs: map[string]string{\n\t\t\t\t\"name\": \"reg.dummy:5000/buildkit/test:latest\",\n\t\t\t},\n\t\t}}\n\t} else {\n\t\texports = []client.ExportEntry{{\n\t\t\tType:   client.ExporterOCI,\n\t\t\tAttrs:  map[string]string{},\n\t\t\tOutput: fixedWriteCloser(nopWriteCloser{io.Discard}),\n\t\t}}\n\t}\n\n\tres, err := f.Solve(sb.Context(), c, client.SolveOpt{\n\t\tExports: exports,\n\t\tLocalDirs: map[string]string{\n\t\t\tdockerui.DefaultLocalNameDockerfile: dir,\n\t\t\tdockerui.DefaultLocalNameContext:    dir,\n\t\t},\n\t}, nil)\n\trequire.NoError(t, err)\n\n\trequire.Contains(t, res.ExporterResponse, exptypes.ExporterBuildInfo)\n\tdtbi, err := base64.StdEncoding.DecodeString(res.ExporterResponse[exptypes.ExporterBuildInfo])\n\trequire.NoError(t, err)\n\n\tvar bi binfotypes.BuildInfo\n\terr = json.Unmarshal(dtbi, &bi)\n\trequire.NoError(t, err)\n\n\tsources := bi.Sources\n\n\tif _, isGateway := f.(*gatewayFrontend); isGateway {\n\t\trequire.Equal(t, 2, len(sources), \"%+v\", sources)\n\t\tsources = sources[1:]\n\t}\n\trequire.Equal(t, 1, len(sources))\n\tassert.Equal(t, binfotypes.SourceTypeDockerImage, sources[0].Type)\n\tassert.Equal(t, \"docker.io/library/busybox:latest\", sources[0].Ref)\n\tassert.NotEmpty(t, sources[0].Pin)\n}\n\n// moby/buildkit#2476\nfunc testBuildInfoAttrs(t *testing.T, sb integration.Sandbox) {\n\tf := getFrontend(t, sb)\n\tf.RequiresBuildctl(t)\n\n\tdockerfile := `\nFROM busybox:latest\nARG foo\nRUN echo $foo\n`\n\n\tdir, err := integration.Tmpdir(\n\t\tt,\n\t\tfstest.CreateFile(\"Dockerfile\", []byte(dockerfile), 0600),\n\t)\n\trequire.NoError(t, err)\n\n\tc, err := client.New(sb.Context(), sb.Address())\n\trequire.NoError(t, err)\n\tdefer c.Close()\n\n\tvar exports []client.ExportEntry\n\tif integration.IsTestDockerdMoby(sb) {\n\t\texports = []client.ExportEntry{{\n\t\t\tType: \"moby\",\n\t\t\tAttrs: map[string]string{\n\t\t\t\t\"name\": \"reg.dummy:5000/buildkit/test:latest\",\n\t\t\t},\n\t\t}}\n\t} else {\n\t\texports = []client.ExportEntry{{\n\t\t\tType:   client.ExporterOCI,\n\t\t\tAttrs:  map[string]string{},\n\t\t\tOutput: fixedWriteCloser(nopWriteCloser{io.Discard}),\n\t\t}}\n\t}\n\n\tres, err := f.Solve(sb.Context(), c, client.SolveOpt{\n\t\tFrontendAttrs: map[string]string{\n\t\t\t\"build-arg:foo\": \"bar\",\n\t\t},\n\t\tExports: exports,\n\t\tLocalDirs: map[string]string{\n\t\t\tdockerui.DefaultLocalNameDockerfile: dir,\n\t\t\tdockerui.DefaultLocalNameContext:    dir,\n\t\t},\n\t}, nil)\n\trequire.NoError(t, err)\n\n\trequire.Contains(t, res.ExporterResponse, exptypes.ExporterBuildInfo)\n\tdtbi, err := base64.StdEncoding.DecodeString(res.ExporterResponse[exptypes.ExporterBuildInfo])\n\trequire.NoError(t, err)\n\n\tvar bi binfotypes.BuildInfo\n\terr = json.Unmarshal(dtbi, &bi)\n\trequire.NoError(t, err)\n\n\trequire.Contains(t, bi.Attrs, \"build-arg:foo\")\n\trequire.Equal(t, \"bar\", *bi.Attrs[\"build-arg:foo\"])\n}\n\n// moby/buildkit#2476\nfunc testBuildInfoMultiPlatform(t *testing.T, sb integration.Sandbox) {\n\tintegration.CheckFeatureCompat(t, sb, integration.FeatureOCIExporter, integration.FeatureMultiPlatform)\n\tf := getFrontend(t, sb)\n\tf.RequiresBuildctl(t)\n\n\tdockerfile := `\nFROM busybox:latest\nARG foo\nRUN echo $foo\nADD https://raw.githubusercontent.com/moby/moby/v20.10.21/README.md /\n`\n\n\tdir, err := integration.Tmpdir(\n\t\tt,\n\t\tfstest.CreateFile(\"Dockerfile\", []byte(dockerfile), 0600),\n\t)\n\trequire.NoError(t, err)\n\n\tc, err := client.New(sb.Context(), sb.Address())\n\trequire.NoError(t, err)\n\tdefer c.Close()\n\n\tplatforms := []string{\"linux/amd64\", \"linux/arm64\"}\n\n\tres, err := f.Solve(sb.Context(), c, client.SolveOpt{\n\t\tFrontendAttrs: map[string]string{\n\t\t\t\"build-arg:foo\": \"bar\",\n\t\t\t\"platform\":      strings.Join(platforms, \",\"),\n\t\t},\n\t\tExports: []client.ExportEntry{\n\t\t\t{\n\t\t\t\tType:   client.ExporterOCI,\n\t\t\t\tOutput: fixedWriteCloser(nopWriteCloser{io.Discard}),\n\t\t\t},\n\t\t},\n\t\tLocalDirs: map[string]string{\n\t\t\tdockerui.DefaultLocalNameDockerfile: dir,\n\t\t\tdockerui.DefaultLocalNameContext:    dir,\n\t\t},\n\t}, nil)\n\trequire.NoError(t, err)\n\n\tfor _, platform := range platforms {\n\t\trequire.Contains(t, res.ExporterResponse, fmt.Sprintf(\"%s/%s\", exptypes.ExporterBuildInfo, platform))\n\t\tdtbi, err := base64.StdEncoding.DecodeString(res.ExporterResponse[fmt.Sprintf(\"%s/%s\", exptypes.ExporterBuildInfo, platform)])\n\t\trequire.NoError(t, err)\n\n\t\tvar bi binfotypes.BuildInfo\n\t\terr = json.Unmarshal(dtbi, &bi)\n\t\trequire.NoError(t, err)\n\n\t\trequire.Contains(t, bi.Attrs, \"build-arg:foo\")\n\t\trequire.Equal(t, \"bar\", *bi.Attrs[\"build-arg:foo\"])\n\n\t\t_, isGateway := f.(*gatewayFrontend)\n\n\t\tsources := bi.Sources\n\t\tif isGateway {\n\t\t\trequire.Equal(t, 3, len(sources), \"%+v\", sources)\n\t\t\tsources = sources[1:]\n\t\t}\n\t\trequire.Equal(t, 2, len(sources), \"%+v\", sources)\n\n\t\tassert.Equal(t, binfotypes.SourceTypeDockerImage, sources[0].Type)\n\t\tassert.Equal(t, \"docker.io/library/busybox:latest\", sources[0].Ref)\n\t\tassert.NotEmpty(t, sources[0].Pin)\n\n\t\tassert.Equal(t, binfotypes.SourceTypeHTTP, sources[1].Type)\n\t\tassert.Equal(t, \"https://raw.githubusercontent.com/moby/moby/v20.10.21/README.md\", sources[1].Ref)\n\t\tassert.Equal(t, \"sha256:419455202b0ef97e480d7f8199b26a721a417818bc0e2d106975f74323f25e6c\", sources[1].Pin)\n\t}\n}\n\nfunc testBuildInfoImageContext(t *testing.T, sb integration.Sandbox) {\n\tf := getFrontend(t, sb)\n\tf.RequiresBuildctl(t)\n\n\tdockerfile := `\nFROM busybox AS base\nRUN cat /etc/alpine-release > /out\nFROM scratch\nCOPY --from=base /out /\n`\n\n\tdir, err := integration.Tmpdir(\n\t\tt,\n\t\tfstest.CreateFile(\"Dockerfile\", []byte(dockerfile), 0600),\n\t)\n\trequire.NoError(t, err)\n\n\tc, err := client.New(sb.Context(), sb.Address())\n\trequire.NoError(t, err)\n\tdefer c.Close()\n\n\tvar exports []client.ExportEntry\n\tif integration.IsTestDockerdMoby(sb) {\n\t\texports = []client.ExportEntry{{\n\t\t\tType: \"moby\",\n\t\t\tAttrs: map[string]string{\n\t\t\t\t\"name\": \"reg.dummy:5000/buildkit/test:latest\",\n\t\t\t},\n\t\t}}\n\t} else {\n\t\texports = []client.ExportEntry{{\n\t\t\tType:   client.ExporterOCI,\n\t\t\tAttrs:  map[string]string{},\n\t\t\tOutput: fixedWriteCloser(nopWriteCloser{io.Discard}),\n\t\t}}\n\t}\n\n\tres, err := f.Solve(sb.Context(), c, client.SolveOpt{\n\t\tFrontendAttrs: map[string]string{\n\t\t\t\"build-arg:foo\":   \"bar\",\n\t\t\t\"context:busybox\": \"docker-image://alpine\",\n\t\t},\n\t\tExports: exports,\n\t\tLocalDirs: map[string]string{\n\t\t\tdockerui.DefaultLocalNameDockerfile: dir,\n\t\t\tdockerui.DefaultLocalNameContext:    dir,\n\t\t},\n\t}, nil)\n\trequire.NoError(t, err)\n\n\trequire.Contains(t, res.ExporterResponse, exptypes.ExporterBuildInfo)\n\tdtbi, err := base64.StdEncoding.DecodeString(res.ExporterResponse[exptypes.ExporterBuildInfo])\n\trequire.NoError(t, err)\n\n\tvar bi binfotypes.BuildInfo\n\terr = json.Unmarshal(dtbi, &bi)\n\trequire.NoError(t, err)\n\n\trequire.Contains(t, bi.Attrs, \"context:busybox\")\n\trequire.Equal(t, \"docker-image://alpine\", *bi.Attrs[\"context:busybox\"])\n\trequire.Contains(t, bi.Attrs, \"build-arg:foo\")\n\trequire.Equal(t, \"bar\", *bi.Attrs[\"build-arg:foo\"])\n\n\t_, isGateway := f.(*gatewayFrontend)\n\n\tsources := bi.Sources\n\tif isGateway {\n\t\trequire.Equal(t, 2, len(sources), \"%+v\", sources)\n\t\tsources = sources[1:]\n\t} else {\n\t\trequire.Equal(t, 1, len(sources))\n\t}\n\tassert.Equal(t, binfotypes.SourceTypeDockerImage, sources[0].Type)\n\tassert.Equal(t, \"docker.io/library/alpine:latest\", sources[0].Ref)\n\tassert.NotEmpty(t, sources[0].Pin)\n}\n\nfunc testBuildInfoLocalContext(t *testing.T, sb integration.Sandbox) {\n\tf := getFrontend(t, sb)\n\tf.RequiresBuildctl(t)\n\n\tdockerfile := `\nFROM busybox AS base\nRUN cat /etc/alpine-release > /out\nFROM scratch\nCOPY --from=base /o* /\n`\n\n\tdir, err := integration.Tmpdir(\n\t\tt,\n\t\tfstest.CreateFile(\"Dockerfile\", []byte(dockerfile), 0600),\n\t)\n\trequire.NoError(t, err)\n\n\tc, err := client.New(sb.Context(), sb.Address())\n\trequire.NoError(t, err)\n\tdefer c.Close()\n\n\toutf := []byte(`dummy-result`)\n\n\tdir2, err := integration.Tmpdir(\n\t\tt,\n\t\tfstest.CreateFile(\"out\", outf, 0600),\n\t\tfstest.CreateFile(\"out2\", outf, 0600),\n\t\tfstest.CreateFile(\".dockerignore\", []byte(\"out2\\n\"), 0600),\n\t)\n\trequire.NoError(t, err)\n\n\tvar exports []client.ExportEntry\n\tif integration.IsTestDockerdMoby(sb) {\n\t\texports = []client.ExportEntry{{\n\t\t\tType: \"moby\",\n\t\t\tAttrs: map[string]string{\n\t\t\t\t\"name\": \"reg.dummy:5000/buildkit/test:latest\",\n\t\t\t},\n\t\t}}\n\t} else {\n\t\texports = []client.ExportEntry{{\n\t\t\tType:   client.ExporterOCI,\n\t\t\tAttrs:  map[string]string{},\n\t\t\tOutput: fixedWriteCloser(nopWriteCloser{io.Discard}),\n\t\t}}\n\t}\n\n\tres, err := f.Solve(sb.Context(), c, client.SolveOpt{\n\t\tFrontendAttrs: map[string]string{\n\t\t\t\"build-arg:foo\": \"bar\",\n\t\t\t\"context:base\":  \"local:basedir\",\n\t\t},\n\t\tExports: exports,\n\t\tLocalDirs: map[string]string{\n\t\t\tdockerui.DefaultLocalNameDockerfile: dir,\n\t\t\tdockerui.DefaultLocalNameContext:    dir,\n\t\t\t\"basedir\":                           dir2,\n\t\t},\n\t}, nil)\n\trequire.NoError(t, err)\n\n\trequire.Contains(t, res.ExporterResponse, exptypes.ExporterBuildInfo)\n\tdtbi, err := base64.StdEncoding.DecodeString(res.ExporterResponse[exptypes.ExporterBuildInfo])\n\trequire.NoError(t, err)\n\n\tvar bi binfotypes.BuildInfo\n\terr = json.Unmarshal(dtbi, &bi)\n\trequire.NoError(t, err)\n\n\trequire.Contains(t, bi.Attrs, \"context:base\")\n\trequire.Equal(t, \"local:basedir\", *bi.Attrs[\"context:base\"])\n\trequire.Contains(t, bi.Attrs, \"build-arg:foo\")\n\trequire.Equal(t, \"bar\", *bi.Attrs[\"build-arg:foo\"])\n\n\t_, isGateway := f.(*gatewayFrontend)\n\tif isGateway {\n\t\trequire.Equal(t, 1, len(bi.Sources))\n\t} else {\n\t\trequire.Equal(t, 0, len(bi.Sources))\n\t}\n}\n\nfunc testBuildInfoDeps(t *testing.T, sb integration.Sandbox) {\n\tt.Skip(\"deps temporarily disabled with SLSA provenance support\")\n\n\tctx := sb.Context()\n\tf := getFrontend(t, sb)\n\tf.RequiresBuildctl(t)\n\n\tc, err := client.New(ctx, sb.Address())\n\trequire.NoError(t, err)\n\tdefer c.Close()\n\n\tdockerfile := []byte(`\nFROM alpine\nENV FOO=bar\nADD https://raw.githubusercontent.com/moby/moby/v20.10.21/README.md /\nRUN echo first > /out\n`)\n\n\tdir, err := integration.Tmpdir(\n\t\tt,\n\t\tfstest.CreateFile(\"Dockerfile\", dockerfile, 0600),\n\t)\n\trequire.NoError(t, err)\n\n\tdockerfile2 := []byte(`\nFROM base AS build\nRUN echo \"foo is $FOO\" > /foo\nFROM busybox\nCOPY --from=build /foo /out /\n`)\n\n\tdir2, err := integration.Tmpdir(\n\t\tt,\n\t\tfstest.CreateFile(\"Dockerfile\", dockerfile2, 0600),\n\t)\n\trequire.NoError(t, err)\n\n\tb := func(ctx context.Context, c gateway.Client) (*gateway.Result, error) {\n\t\tres, err := f.SolveGateway(ctx, c, gateway.SolveRequest{})\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tref, err := res.SingleRef()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tst, err := ref.ToState()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tdef, err := st.Marshal(ctx)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tdtic, ok := res.Metadata[exptypes.ExporterImageConfigKey]\n\t\tif !ok {\n\t\t\treturn nil, errors.Errorf(\"no containerimage.config in metadata\")\n\t\t}\n\n\t\tdtbi, ok := res.Metadata[exptypes.ExporterBuildInfo]\n\t\tif !ok {\n\t\t\treturn nil, errors.Errorf(\"no containerimage.buildinfo in metadata\")\n\t\t}\n\n\t\tdt, err := json.Marshal(map[string][]byte{\n\t\t\texptypes.ExporterImageConfigKey: dtic,\n\t\t\texptypes.ExporterBuildInfo:      dtbi,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tres, err = f.SolveGateway(ctx, c, gateway.SolveRequest{\n\t\t\tFrontendOpt: map[string]string{\n\t\t\t\t\"dockerfilekey\":       dockerui.DefaultLocalNameDockerfile + \"2\",\n\t\t\t\t\"context:base\":        \"input:base\",\n\t\t\t\t\"input-metadata:base\": string(dt),\n\t\t\t},\n\t\t\tFrontendInputs: map[string]*pb.Definition{\n\t\t\t\t\"base\": def.ToPB(),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn res, nil\n\t}\n\n\tdestDir := t.TempDir()\n\n\tres, err := c.Build(ctx, client.SolveOpt{\n\t\tLocalDirs: map[string]string{\n\t\t\tdockerui.DefaultLocalNameDockerfile:       dir,\n\t\t\tdockerui.DefaultLocalNameContext:          dir,\n\t\t\tdockerui.DefaultLocalNameDockerfile + \"2\": dir2,\n\t\t},\n\t\tExports: []client.ExportEntry{\n\t\t\t{\n\t\t\t\tType:      client.ExporterLocal,\n\t\t\t\tOutputDir: destDir,\n\t\t\t},\n\t\t},\n\t}, \"\", b, nil)\n\trequire.NoError(t, err)\n\n\trequire.Contains(t, res.ExporterResponse, exptypes.ExporterBuildInfo)\n\tdtbi, err := base64.StdEncoding.DecodeString(res.ExporterResponse[exptypes.ExporterBuildInfo])\n\trequire.NoError(t, err)\n\n\tvar bi binfotypes.BuildInfo\n\terr = json.Unmarshal(dtbi, &bi)\n\trequire.NoError(t, err)\n\n\trequire.Contains(t, bi.Attrs, \"context:base\")\n\trequire.Equal(t, \"input:base\", *bi.Attrs[\"context:base\"])\n\n\trequire.Equal(t, 2, len(bi.Sources))\n\n\tassert.Equal(t, binfotypes.SourceTypeDockerImage, bi.Sources[0].Type)\n\tassert.Equal(t, \"docker.io/library/busybox:latest\", bi.Sources[0].Ref)\n\tassert.NotEmpty(t, bi.Sources[0].Pin)\n\n\tassert.Equal(t, binfotypes.SourceTypeHTTP, bi.Sources[1].Type)\n\tassert.Equal(t, \"https://raw.githubusercontent.com/moby/moby/v20.10.21/README.md\", bi.Sources[1].Ref)\n\tassert.Equal(t, \"sha256:419455202b0ef97e480d7f8199b26a721a417818bc0e2d106975f74323f25e6c\", bi.Sources[1].Pin)\n\n\trequire.Contains(t, bi.Deps, \"base\")\n\tdepsrc := bi.Deps[\"base\"].Sources\n\trequire.Equal(t, 1, len(depsrc))\n\tassert.Equal(t, binfotypes.SourceTypeDockerImage, depsrc[0].Type)\n\tassert.Equal(t, \"docker.io/library/alpine:latest\", depsrc[0].Ref)\n\tassert.NotEmpty(t, depsrc[0].Pin)\n}\n\nfunc testBuildInfoDepsMultiPlatform(t *testing.T, sb integration.Sandbox) {\n\tt.Skip(\"deps temporarily disabled with SLSA provenance support\")\n\n\tctx := sb.Context()\n\tf := getFrontend(t, sb)\n\tf.RequiresBuildctl(t)\n\n\tplatforms := []string{\"linux/amd64\", \"linux/arm64\"}\n\n\tc, err := client.New(ctx, sb.Address())\n\trequire.NoError(t, err)\n\tdefer c.Close()\n\n\tdockerfile := []byte(`\nFROM --platform=$BUILDPLATFORM alpine\nARG TARGETARCH\nENV FOO=bar-$TARGETARCH\nRUN echo \"foo $TARGETARCH\" > /out\n`)\n\n\tdir, err := integration.Tmpdir(\n\t\tt,\n\t\tfstest.CreateFile(\"Dockerfile\", dockerfile, 0600),\n\t)\n\trequire.NoError(t, err)\n\n\tdockerfile2 := []byte(`\nFROM base AS build\nRUN echo \"foo is $FOO\" > /foo\nFROM busybox\nCOPY --from=build /foo /out /\n`)\n\n\tdir2, err := integration.Tmpdir(\n\t\tt,\n\t\tfstest.CreateFile(\"Dockerfile\", dockerfile2, 0600),\n\t)\n\trequire.NoError(t, err)\n\n\tb := func(ctx context.Context, c gateway.Client) (*gateway.Result, error) {\n\t\tres, err := f.SolveGateway(ctx, c, gateway.SolveRequest{\n\t\t\tFrontendOpt: map[string]string{\n\t\t\t\t\"platform\": strings.Join(platforms, \",\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tif len(res.Refs) != 2 {\n\t\t\treturn nil, errors.Errorf(\"expected 2 refs, got %d\", len(res.Refs))\n\t\t}\n\n\t\tfrontendOpt := map[string]string{\n\t\t\t\"dockerfilekey\": dockerui.DefaultLocalNameDockerfile + \"2\",\n\t\t\t\"platform\":      strings.Join(platforms, \",\"),\n\t\t}\n\n\t\tinputs := map[string]*pb.Definition{}\n\t\tfor _, platform := range platforms {\n\t\t\tfrontendOpt[\"context:base::\"+platform] = \"input:base::\" + platform\n\n\t\t\tst, err := res.Refs[platform].ToState()\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tdef, err := st.Marshal(ctx)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tinputs[\"base::\"+platform] = def.ToPB()\n\n\t\t\tdtic, ok := res.Metadata[exptypes.ExporterImageConfigKey+\"/\"+platform]\n\t\t\tif !ok {\n\t\t\t\treturn nil, errors.Errorf(\"no containerimage.config/\" + platform + \" in metadata\")\n\t\t\t}\n\t\t\tdtbi, ok := res.Metadata[exptypes.ExporterBuildInfo+\"/\"+platform]\n\t\t\tif !ok {\n\t\t\t\treturn nil, errors.Errorf(\"no containerimage.buildinfo/\" + platform + \" in metadata\")\n\t\t\t}\n\t\t\tdt, err := json.Marshal(map[string][]byte{\n\t\t\t\texptypes.ExporterImageConfigKey: dtic,\n\t\t\t\texptypes.ExporterBuildInfo:      dtbi,\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tfrontendOpt[\"input-metadata:base::\"+platform] = string(dt)\n\t\t}\n\n\t\tres, err = f.SolveGateway(ctx, c, gateway.SolveRequest{\n\t\t\tFrontendOpt:    frontendOpt,\n\t\t\tFrontendInputs: inputs,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn res, nil\n\t}\n\n\tdestDir := t.TempDir()\n\n\tres, err := c.Build(ctx, client.SolveOpt{\n\t\tLocalDirs: map[string]string{\n\t\t\tdockerui.DefaultLocalNameDockerfile:       dir,\n\t\t\tdockerui.DefaultLocalNameContext:          dir,\n\t\t\tdockerui.DefaultLocalNameDockerfile + \"2\": dir2,\n\t\t},\n\t\tExports: []client.ExportEntry{\n\t\t\t{\n\t\t\t\tType:      client.ExporterLocal,\n\t\t\t\tOutputDir: destDir,\n\t\t\t},\n\t\t},\n\t}, \"\", b, nil)\n\trequire.NoError(t, err)\n\n\tfor _, platform := range platforms {\n\t\trequire.Contains(t, res.ExporterResponse, fmt.Sprintf(\"%s/%s\", exptypes.ExporterBuildInfo, platform))\n\t\tdtbi, err := base64.StdEncoding.DecodeString(res.ExporterResponse[fmt.Sprintf(\"%s/%s\", exptypes.ExporterBuildInfo, platform)])\n\t\trequire.NoError(t, err)\n\n\t\tvar bi binfotypes.BuildInfo\n\t\terr = json.Unmarshal(dtbi, &bi)\n\t\trequire.NoError(t, err)\n\n\t\trequire.Contains(t, bi.Attrs, \"context:base\")\n\t\trequire.Equal(t, \"input:base\", *bi.Attrs[\"context:base\"])\n\n\t\trequire.Equal(t, 1, len(bi.Sources))\n\t\tassert.Equal(t, binfotypes.SourceTypeDockerImage, bi.Sources[0].Type)\n\t\tassert.Equal(t, \"docker.io/library/busybox:latest\", bi.Sources[0].Ref)\n\t\tassert.NotEmpty(t, bi.Sources[0].Pin)\n\n\t\trequire.Contains(t, bi.Deps, \"base\")\n\t\tdepsrc := bi.Deps[\"base\"].Sources\n\t\trequire.Equal(t, 1, len(depsrc))\n\t\tassert.Equal(t, binfotypes.SourceTypeDockerImage, depsrc[0].Type)\n\t\tassert.Equal(t, \"docker.io/library/alpine:latest\", depsrc[0].Ref)\n\t\tassert.NotEmpty(t, depsrc[0].Pin)\n\t}\n}\n\nfunc testBuildInfoDepsMainNoSource(t *testing.T, sb integration.Sandbox) {\n\tt.Skip(\"deps temporarily disabled with SLSA provenance support\")\n\n\tctx := sb.Context()\n\tf := getFrontend(t, sb)\n\tf.RequiresBuildctl(t)\n\n\tc, err := client.New(ctx, sb.Address())\n\trequire.NoError(t, err)\n\tdefer c.Close()\n\n\tdockerfile := []byte(`\nFROM alpine\nENV FOO=bar\nADD https://raw.githubusercontent.com/moby/moby/v20.10.21/README.md /\nRUN echo first > /out\n`)\n\n\tdir, err := integration.Tmpdir(\n\t\tt,\n\t\tfstest.CreateFile(\"Dockerfile\", dockerfile, 0600),\n\t)\n\trequire.NoError(t, err)\n\n\tdockerfile2 := []byte(`\nFROM base AS build\nRUN echo \"foo is $FOO\" > /foo\n`)\n\n\tdir2, err := integration.Tmpdir(\n\t\tt,\n\t\tfstest.CreateFile(\"Dockerfile\", dockerfile2, 0600),\n\t)\n\trequire.NoError(t, err)\n\n\tb := func(ctx context.Context, c gateway.Client) (*gateway.Result, error) {\n\t\tres, err := f.SolveGateway(ctx, c, gateway.SolveRequest{})\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tref, err := res.SingleRef()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tst, err := ref.ToState()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tdef, err := st.Marshal(ctx)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tdtic, ok := res.Metadata[exptypes.ExporterImageConfigKey]\n\t\tif !ok {\n\t\t\treturn nil, errors.Errorf(\"no containerimage.config in metadata\")\n\t\t}\n\n\t\tdtbi, ok := res.Metadata[exptypes.ExporterBuildInfo]\n\t\tif !ok {\n\t\t\treturn nil, errors.Errorf(\"no containerimage.buildinfo in metadata\")\n\t\t}\n\n\t\tdt, err := json.Marshal(map[string][]byte{\n\t\t\texptypes.ExporterImageConfigKey: dtic,\n\t\t\texptypes.ExporterBuildInfo:      dtbi,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tres, err = f.SolveGateway(ctx, c, gateway.SolveRequest{\n\t\t\tFrontendOpt: map[string]string{\n\t\t\t\t\"dockerfilekey\":       dockerui.DefaultLocalNameDockerfile + \"2\",\n\t\t\t\t\"context:base\":        \"input:base\",\n\t\t\t\t\"input-metadata:base\": string(dt),\n\t\t\t},\n\t\t\tFrontendInputs: map[string]*pb.Definition{\n\t\t\t\t\"base\": def.ToPB(),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn res, nil\n\t}\n\n\tdestDir := t.TempDir()\n\n\tres, err := c.Build(ctx, client.SolveOpt{\n\t\tLocalDirs: map[string]string{\n\t\t\tdockerui.DefaultLocalNameDockerfile:       dir,\n\t\t\tdockerui.DefaultLocalNameContext:          dir,\n\t\t\tdockerui.DefaultLocalNameDockerfile + \"2\": dir2,\n\t\t},\n\t\tExports: []client.ExportEntry{\n\t\t\t{\n\t\t\t\tType:      client.ExporterLocal,\n\t\t\t\tOutputDir: destDir,\n\t\t\t},\n\t\t},\n\t}, \"\", b, nil)\n\trequire.NoError(t, err)\n\n\trequire.Contains(t, res.ExporterResponse, exptypes.ExporterBuildInfo)\n\tdtbi, err := base64.StdEncoding.DecodeString(res.ExporterResponse[exptypes.ExporterBuildInfo])\n\trequire.NoError(t, err)\n\n\tvar bi binfotypes.BuildInfo\n\terr = json.Unmarshal(dtbi, &bi)\n\trequire.NoError(t, err)\n\n\trequire.Contains(t, bi.Attrs, \"context:base\")\n\trequire.Equal(t, \"input:base\", *bi.Attrs[\"context:base\"])\n\n\trequire.Equal(t, 1, len(bi.Sources))\n\n\tassert.Equal(t, binfotypes.SourceTypeHTTP, bi.Sources[0].Type)\n\tassert.Equal(t, \"https://raw.githubusercontent.com/moby/moby/v20.10.21/README.md\", bi.Sources[0].Ref)\n\tassert.Equal(t, \"sha256:419455202b0ef97e480d7f8199b26a721a417818bc0e2d106975f74323f25e6c\", bi.Sources[0].Pin)\n\n\trequire.Contains(t, bi.Deps, \"base\")\n\tdepsrc := bi.Deps[\"base\"].Sources\n\trequire.Equal(t, 1, len(depsrc))\n\tassert.Equal(t, binfotypes.SourceTypeDockerImage, depsrc[0].Type)\n\tassert.Equal(t, \"docker.io/library/alpine:latest\", depsrc[0].Ref)\n\tassert.NotEmpty(t, depsrc[0].Pin)\n}\n", "package dockerfile\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"net/url\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/containerd/containerd/platforms\"\n\t\"github.com/containerd/continuity/fs/fstest\"\n\tintoto \"github.com/in-toto/in-toto-golang/in_toto\"\n\t\"github.com/moby/buildkit/client\"\n\t\"github.com/moby/buildkit/client/llb\"\n\t\"github.com/moby/buildkit/exporter/containerimage/exptypes\"\n\t\"github.com/moby/buildkit/frontend/dockerui\"\n\tgateway \"github.com/moby/buildkit/frontend/gateway/client\"\n\t\"github.com/moby/buildkit/solver/llbsolver/provenance\"\n\t\"github.com/moby/buildkit/util/contentutil\"\n\t\"github.com/moby/buildkit/util/testutil\"\n\t\"github.com/moby/buildkit/util/testutil/integration\"\n\tocispecs \"github.com/opencontainers/image-spec/specs-go/v1\"\n\t\"github.com/pkg/errors\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc testProvenanceAttestation(t *testing.T, sb integration.Sandbox) {\n\tintegration.CheckFeatureCompat(t, sb, integration.FeatureDirectPush, integration.FeatureProvenance)\n\tctx := sb.Context()\n\n\tc, err := client.New(ctx, sb.Address())\n\trequire.NoError(t, err)\n\tdefer c.Close()\n\n\tregistry, err := sb.NewRegistry()\n\tif errors.Is(err, integration.ErrRequirements) {\n\t\tt.Skip(err.Error())\n\t}\n\trequire.NoError(t, err)\n\n\tf := getFrontend(t, sb)\n\n\tdockerfile := []byte(`\nFROM busybox:latest\nRUN echo \"ok\" > /foo\n`)\n\tdir, err := integration.Tmpdir(\n\t\tt,\n\t\tfstest.CreateFile(\"Dockerfile\", dockerfile, 0600),\n\t)\n\trequire.NoError(t, err)\n\n\tfor _, mode := range []string{\"\", \"min\", \"max\"} {\n\t\tt.Run(mode, func(t *testing.T) {\n\t\t\tvar target string\n\t\t\tif target == \"\" {\n\t\t\t\ttarget = registry + \"/buildkit/testwithprovenance:none\"\n\t\t\t} else {\n\t\t\t\ttarget = registry + \"/buildkit/testwithprovenance:\" + mode\n\t\t\t}\n\n\t\t\tprovReq := \"\"\n\t\t\tif mode != \"\" {\n\t\t\t\tprovReq = \"mode=\" + mode\n\t\t\t}\n\t\t\t_, err = f.Solve(sb.Context(), c, client.SolveOpt{\n\t\t\t\tLocalDirs: map[string]string{\n\t\t\t\t\tdockerui.DefaultLocalNameDockerfile: dir,\n\t\t\t\t\tdockerui.DefaultLocalNameContext:    dir,\n\t\t\t\t},\n\t\t\t\tFrontendAttrs: map[string]string{\n\t\t\t\t\t\"attest:provenance\": provReq,\n\t\t\t\t\t\"build-arg:FOO\":     \"bar\",\n\t\t\t\t\t\"label:lbl\":         \"abc\",\n\t\t\t\t\t\"vcs:source\":        \"https://example.invalid/repo.git\",\n\t\t\t\t\t\"vcs:revision\":      \"123456\",\n\t\t\t\t\t\"filename\":          \"Dockerfile\",\n\t\t\t\t},\n\t\t\t\tExports: []client.ExportEntry{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: client.ExporterImage,\n\t\t\t\t\t\tAttrs: map[string]string{\n\t\t\t\t\t\t\t\"name\": target,\n\t\t\t\t\t\t\t\"push\": \"true\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}, nil)\n\t\t\trequire.NoError(t, err)\n\n\t\t\tdesc, provider, err := contentutil.ProviderFromRef(target)\n\t\t\trequire.NoError(t, err)\n\t\t\timgs, err := testutil.ReadImages(sb.Context(), provider, desc)\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.Equal(t, 2, len(imgs.Images))\n\n\t\t\timg := imgs.Find(platforms.Format(platforms.Normalize(platforms.DefaultSpec())))\n\t\t\trequire.NotNil(t, img)\n\t\t\trequire.Equal(t, []byte(\"ok\\n\"), img.Layers[1][\"foo\"].Data)\n\n\t\t\tatt := imgs.Find(\"unknown/unknown\")\n\t\t\trequire.NotNil(t, att)\n\t\t\trequire.Equal(t, att.Desc.Annotations[\"vnd.docker.reference.digest\"], string(img.Desc.Digest))\n\t\t\trequire.Equal(t, att.Desc.Annotations[\"vnd.docker.reference.type\"], \"attestation-manifest\")\n\t\t\tvar attest intoto.Statement\n\t\t\trequire.NoError(t, json.Unmarshal(att.LayersRaw[0], &attest))\n\t\t\trequire.Equal(t, \"https://in-toto.io/Statement/v0.1\", attest.Type)\n\t\t\trequire.Equal(t, \"https://slsa.dev/provenance/v0.2\", attest.PredicateType) // intentionally not const\n\n\t\t\ttype stmtT struct {\n\t\t\t\tPredicate provenance.ProvenancePredicate `json:\"predicate\"`\n\t\t\t}\n\t\t\tvar stmt stmtT\n\t\t\trequire.NoError(t, json.Unmarshal(att.LayersRaw[0], &stmt))\n\t\t\tpred := stmt.Predicate\n\n\t\t\trequire.Equal(t, \"https://mobyproject.org/buildkit@v1\", pred.BuildType)\n\t\t\trequire.Equal(t, \"\", pred.Builder.ID)\n\n\t\t\trequire.Equal(t, \"\", pred.Invocation.ConfigSource.URI)\n\n\t\t\t_, isClient := f.(*clientFrontend)\n\t\t\t_, isGateway := f.(*gatewayFrontend)\n\n\t\t\targs := pred.Invocation.Parameters.Args\n\t\t\tif isClient {\n\t\t\t\trequire.Equal(t, \"\", pred.Invocation.Parameters.Frontend)\n\t\t\t\trequire.Equal(t, 0, len(args), \"%v\", args)\n\t\t\t\trequire.False(t, pred.Metadata.Completeness.Parameters)\n\t\t\t\trequire.Equal(t, \"\", pred.Invocation.ConfigSource.EntryPoint)\n\t\t\t} else if isGateway {\n\t\t\t\trequire.Equal(t, \"gateway.v0\", pred.Invocation.Parameters.Frontend)\n\n\t\t\t\tif mode == \"max\" || mode == \"\" {\n\t\t\t\t\trequire.Equal(t, 3, len(args), \"%v\", args)\n\t\t\t\t\trequire.True(t, pred.Metadata.Completeness.Parameters)\n\n\t\t\t\t\trequire.Equal(t, \"bar\", args[\"build-arg:FOO\"])\n\t\t\t\t\trequire.Equal(t, \"abc\", args[\"label:lbl\"])\n\t\t\t\t\trequire.Contains(t, args[\"source\"], \"buildkit_test/\")\n\t\t\t\t} else {\n\t\t\t\t\trequire.False(t, pred.Metadata.Completeness.Parameters)\n\t\t\t\t\trequire.Equal(t, 1, len(args), \"%v\", args)\n\t\t\t\t\trequire.Contains(t, args[\"source\"], \"buildkit_test/\")\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trequire.Equal(t, \"dockerfile.v0\", pred.Invocation.Parameters.Frontend)\n\n\t\t\t\tif mode == \"max\" || mode == \"\" {\n\t\t\t\t\trequire.Equal(t, 2, len(args))\n\t\t\t\t\trequire.True(t, pred.Metadata.Completeness.Parameters)\n\n\t\t\t\t\trequire.Equal(t, \"bar\", args[\"build-arg:FOO\"])\n\t\t\t\t\trequire.Equal(t, \"abc\", args[\"label:lbl\"])\n\t\t\t\t} else {\n\t\t\t\t\trequire.False(t, pred.Metadata.Completeness.Parameters)\n\t\t\t\t\trequire.Equal(t, 0, len(args), \"%v\", args)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\texpectedBase := \"pkg:docker/busybox@latest?platform=\" + url.PathEscape(platforms.Format(platforms.Normalize(platforms.DefaultSpec())))\n\t\t\tif isGateway {\n\t\t\t\trequire.Equal(t, 2, len(pred.Materials), \"%+v\", pred.Materials)\n\t\t\t\trequire.Contains(t, pred.Materials[0].URI, \"docker/buildkit_test\")\n\t\t\t\trequire.Equal(t, expectedBase, pred.Materials[1].URI)\n\t\t\t\trequire.NotEmpty(t, pred.Materials[1].Digest[\"sha256\"])\n\t\t\t} else {\n\t\t\t\trequire.Equal(t, 1, len(pred.Materials), \"%+v\", pred.Materials)\n\t\t\t\trequire.Equal(t, expectedBase, pred.Materials[0].URI)\n\t\t\t\trequire.NotEmpty(t, pred.Materials[0].Digest[\"sha256\"])\n\t\t\t}\n\n\t\t\tif !isClient {\n\t\t\t\trequire.Equal(t, \"Dockerfile\", pred.Invocation.ConfigSource.EntryPoint)\n\t\t\t\trequire.Equal(t, \"https://example.invalid/repo.git\", pred.Metadata.BuildKitMetadata.VCS[\"source\"])\n\t\t\t\trequire.Equal(t, \"123456\", pred.Metadata.BuildKitMetadata.VCS[\"revision\"])\n\t\t\t}\n\n\t\t\trequire.NotEmpty(t, pred.Metadata.BuildInvocationID)\n\n\t\t\trequire.Equal(t, 2, len(pred.Invocation.Parameters.Locals), \"%+v\", pred.Invocation.Parameters.Locals)\n\t\t\trequire.Equal(t, \"context\", pred.Invocation.Parameters.Locals[0].Name)\n\t\t\trequire.Equal(t, \"dockerfile\", pred.Invocation.Parameters.Locals[1].Name)\n\n\t\t\trequire.NotNil(t, pred.Metadata.BuildFinishedOn)\n\t\t\trequire.True(t, time.Since(*pred.Metadata.BuildFinishedOn) < 5*time.Minute)\n\t\t\trequire.NotNil(t, pred.Metadata.BuildStartedOn)\n\t\t\trequire.True(t, time.Since(*pred.Metadata.BuildStartedOn) < 5*time.Minute)\n\t\t\trequire.True(t, pred.Metadata.BuildStartedOn.Before(*pred.Metadata.BuildFinishedOn))\n\n\t\t\trequire.True(t, pred.Metadata.Completeness.Environment)\n\t\t\trequire.Equal(t, platforms.Format(platforms.Normalize(platforms.DefaultSpec())), pred.Invocation.Environment.Platform)\n\n\t\t\trequire.False(t, pred.Metadata.Completeness.Materials)\n\t\t\trequire.False(t, pred.Metadata.Reproducible)\n\t\t\trequire.False(t, pred.Metadata.Hermetic)\n\n\t\t\tif mode == \"max\" || mode == \"\" {\n\t\t\t\trequire.Equal(t, 2, len(pred.Metadata.BuildKitMetadata.Layers))\n\t\t\t\trequire.NotNil(t, pred.Metadata.BuildKitMetadata.Source)\n\t\t\t\trequire.Equal(t, \"Dockerfile\", pred.Metadata.BuildKitMetadata.Source.Infos[0].Filename)\n\t\t\t\trequire.Equal(t, dockerfile, pred.Metadata.BuildKitMetadata.Source.Infos[0].Data)\n\t\t\t\trequire.NotNil(t, pred.BuildConfig)\n\n\t\t\t\trequire.Equal(t, 3, len(pred.BuildConfig.Definition))\n\t\t\t} else {\n\t\t\t\trequire.Equal(t, 0, len(pred.Metadata.BuildKitMetadata.Layers))\n\t\t\t\trequire.Nil(t, pred.Metadata.BuildKitMetadata.Source)\n\t\t\t\trequire.Nil(t, pred.BuildConfig)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc testGitProvenanceAttestation(t *testing.T, sb integration.Sandbox) {\n\tintegration.CheckFeatureCompat(t, sb, integration.FeatureDirectPush, integration.FeatureProvenance)\n\tctx := sb.Context()\n\n\tc, err := client.New(ctx, sb.Address())\n\trequire.NoError(t, err)\n\tdefer c.Close()\n\n\tregistry, err := sb.NewRegistry()\n\tif errors.Is(err, integration.ErrRequirements) {\n\t\tt.Skip(err.Error())\n\t}\n\trequire.NoError(t, err)\n\n\tf := getFrontend(t, sb)\n\n\tdockerfile := []byte(`\nFROM busybox:latest\nRUN --network=none echo \"git\" > /foo\nCOPY myapp.Dockerfile /\n`)\n\tdir, err := integration.Tmpdir(\n\t\tt,\n\t\tfstest.CreateFile(\"myapp.Dockerfile\", dockerfile, 0600),\n\t)\n\trequire.NoError(t, err)\n\n\terr = runShell(dir,\n\t\t\"git init\",\n\t\t\"git config --local user.email test\",\n\t\t\"git config --local user.name test\",\n\t\t\"git add myapp.Dockerfile\",\n\t\t\"git commit -m initial\",\n\t\t\"git branch v1\",\n\t\t\"git update-server-info\",\n\t)\n\trequire.NoError(t, err)\n\n\tcmd := exec.Command(\"git\", \"rev-parse\", \"v1\")\n\tcmd.Dir = dir\n\texpectedGitSHA, err := cmd.Output()\n\trequire.NoError(t, err)\n\n\tserver := httptest.NewServer(http.FileServer(http.Dir(filepath.Join(dir))))\n\tdefer server.Close()\n\n\ttarget := registry + \"/buildkit/testwithprovenance:git\"\n\n\t_, err = f.Solve(sb.Context(), c, client.SolveOpt{\n\t\tFrontendAttrs: map[string]string{\n\t\t\t\"context\":           server.URL + \"/.git#v1\",\n\t\t\t\"attest:provenance\": \"\",\n\t\t\t\"filename\":          \"myapp.Dockerfile\",\n\t\t},\n\t\tExports: []client.ExportEntry{\n\t\t\t{\n\t\t\t\tType: client.ExporterImage,\n\t\t\t\tAttrs: map[string]string{\n\t\t\t\t\t\"name\": target,\n\t\t\t\t\t\"push\": \"true\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}, nil)\n\trequire.NoError(t, err)\n\n\tdesc, provider, err := contentutil.ProviderFromRef(target)\n\trequire.NoError(t, err)\n\timgs, err := testutil.ReadImages(sb.Context(), provider, desc)\n\trequire.NoError(t, err)\n\trequire.Equal(t, 2, len(imgs.Images))\n\n\timg := imgs.Find(platforms.Format(platforms.Normalize(platforms.DefaultSpec())))\n\trequire.NotNil(t, img)\n\trequire.Equal(t, []byte(\"git\\n\"), img.Layers[1][\"foo\"].Data)\n\n\tatt := imgs.Find(\"unknown/unknown\")\n\trequire.NotNil(t, att)\n\trequire.Equal(t, att.Desc.Annotations[\"vnd.docker.reference.digest\"], string(img.Desc.Digest))\n\trequire.Equal(t, att.Desc.Annotations[\"vnd.docker.reference.type\"], \"attestation-manifest\")\n\tvar attest intoto.Statement\n\trequire.NoError(t, json.Unmarshal(att.LayersRaw[0], &attest))\n\trequire.Equal(t, \"https://in-toto.io/Statement/v0.1\", attest.Type)\n\trequire.Equal(t, \"https://slsa.dev/provenance/v0.2\", attest.PredicateType) // intentionally not const\n\n\ttype stmtT struct {\n\t\tPredicate provenance.ProvenancePredicate `json:\"predicate\"`\n\t}\n\tvar stmt stmtT\n\trequire.NoError(t, json.Unmarshal(att.LayersRaw[0], &stmt))\n\tpred := stmt.Predicate\n\n\t_, isClient := f.(*clientFrontend)\n\t_, isGateway := f.(*gatewayFrontend)\n\n\tif isClient {\n\t\trequire.Empty(t, pred.Invocation.Parameters.Frontend)\n\t\trequire.Equal(t, \"\", pred.Invocation.ConfigSource.URI)\n\t\trequire.Equal(t, \"\", pred.Invocation.ConfigSource.EntryPoint)\n\t} else {\n\t\trequire.NotEmpty(t, pred.Invocation.Parameters.Frontend)\n\t\trequire.Equal(t, server.URL+\"/.git#v1\", pred.Invocation.ConfigSource.URI)\n\t\trequire.Equal(t, \"myapp.Dockerfile\", pred.Invocation.ConfigSource.EntryPoint)\n\t}\n\n\texpBase := \"pkg:docker/busybox@latest?platform=\" + url.PathEscape(platforms.Format(platforms.Normalize(platforms.DefaultSpec())))\n\tif isGateway {\n\t\trequire.Equal(t, 3, len(pred.Materials), \"%+v\", pred.Materials)\n\n\t\trequire.Contains(t, pred.Materials[0].URI, \"pkg:docker/buildkit_test/\")\n\t\trequire.NotEmpty(t, pred.Materials[0].Digest)\n\n\t\trequire.Equal(t, expBase, pred.Materials[1].URI)\n\t\trequire.NotEmpty(t, pred.Materials[1].Digest[\"sha256\"])\n\n\t\trequire.Equal(t, server.URL+\"/.git#v1\", pred.Materials[2].URI)\n\t\trequire.Equal(t, strings.TrimSpace(string(expectedGitSHA)), pred.Materials[2].Digest[\"sha1\"])\n\t} else {\n\t\trequire.Equal(t, 2, len(pred.Materials), \"%+v\", pred.Materials)\n\n\t\trequire.Equal(t, expBase, pred.Materials[0].URI)\n\t\trequire.NotEmpty(t, pred.Materials[0].Digest[\"sha256\"])\n\n\t\trequire.Equal(t, server.URL+\"/.git#v1\", pred.Materials[1].URI)\n\t\trequire.Equal(t, strings.TrimSpace(string(expectedGitSHA)), pred.Materials[1].Digest[\"sha1\"])\n\t}\n\n\trequire.Equal(t, 0, len(pred.Invocation.Parameters.Locals))\n\n\trequire.True(t, pred.Metadata.Completeness.Materials)\n\trequire.True(t, pred.Metadata.Completeness.Environment)\n\trequire.True(t, pred.Metadata.Hermetic)\n\n\tif isClient {\n\t\trequire.False(t, pred.Metadata.Completeness.Parameters)\n\t} else {\n\t\trequire.True(t, pred.Metadata.Completeness.Parameters)\n\t}\n\trequire.False(t, pred.Metadata.Reproducible)\n\n\trequire.Equal(t, 0, len(pred.Metadata.BuildKitMetadata.VCS), \"%+v\", pred.Metadata.BuildKitMetadata.VCS)\n}\n\nfunc testMultiPlatformProvenance(t *testing.T, sb integration.Sandbox) {\n\tintegration.CheckFeatureCompat(t, sb, integration.FeatureDirectPush, integration.FeatureMultiPlatform, integration.FeatureProvenance)\n\tctx := sb.Context()\n\n\tc, err := client.New(ctx, sb.Address())\n\trequire.NoError(t, err)\n\tdefer c.Close()\n\n\tregistry, err := sb.NewRegistry()\n\tif errors.Is(err, integration.ErrRequirements) {\n\t\tt.Skip(err.Error())\n\t}\n\trequire.NoError(t, err)\n\n\tf := getFrontend(t, sb)\n\n\tdockerfile := []byte(`\nFROM busybox:latest\nARG TARGETARCH\nRUN echo \"ok-$TARGETARCH\" > /foo\n`)\n\tdir, err := integration.Tmpdir(\n\t\tt,\n\t\tfstest.CreateFile(\"Dockerfile\", dockerfile, 0600),\n\t)\n\trequire.NoError(t, err)\n\n\ttarget := registry + \"/buildkit/testmultiprovenance:latest\"\n\n\t_, err = f.Solve(sb.Context(), c, client.SolveOpt{\n\t\tLocalDirs: map[string]string{\n\t\t\tdockerui.DefaultLocalNameDockerfile: dir,\n\t\t\tdockerui.DefaultLocalNameContext:    dir,\n\t\t},\n\t\tFrontendAttrs: map[string]string{\n\t\t\t\"attest:provenance\": \"mode=max\",\n\t\t\t\"build-arg:FOO\":     \"bar\",\n\t\t\t\"label:lbl\":         \"abc\",\n\t\t\t\"platform\":          \"linux/amd64,linux/arm64\",\n\t\t},\n\t\tExports: []client.ExportEntry{\n\t\t\t{\n\t\t\t\tType: client.ExporterImage,\n\t\t\t\tAttrs: map[string]string{\n\t\t\t\t\t\"name\": target,\n\t\t\t\t\t\"push\": \"true\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}, nil)\n\trequire.NoError(t, err)\n\n\tdesc, provider, err := contentutil.ProviderFromRef(target)\n\trequire.NoError(t, err)\n\timgs, err := testutil.ReadImages(sb.Context(), provider, desc)\n\trequire.NoError(t, err)\n\trequire.Equal(t, 4, len(imgs.Images))\n\n\t_, isClient := f.(*clientFrontend)\n\t_, isGateway := f.(*gatewayFrontend)\n\n\tfor _, p := range []string{\"linux/amd64\", \"linux/arm64\"} {\n\t\timg := imgs.Find(p)\n\t\trequire.NotNil(t, img)\n\t\tif p == \"linux/amd64\" {\n\t\t\trequire.Equal(t, []byte(\"ok-amd64\\n\"), img.Layers[1][\"foo\"].Data)\n\t\t} else {\n\t\t\trequire.Equal(t, []byte(\"ok-arm64\\n\"), img.Layers[1][\"foo\"].Data)\n\t\t}\n\n\t\tatt := imgs.FindAttestation(p)\n\t\trequire.NotNil(t, att)\n\t\trequire.Equal(t, att.Desc.Annotations[\"vnd.docker.reference.type\"], \"attestation-manifest\")\n\t\tvar attest intoto.Statement\n\t\trequire.NoError(t, json.Unmarshal(att.LayersRaw[0], &attest))\n\t\trequire.Equal(t, \"https://in-toto.io/Statement/v0.1\", attest.Type)\n\t\trequire.Equal(t, \"https://slsa.dev/provenance/v0.2\", attest.PredicateType) // intentionally not const\n\n\t\ttype stmtT struct {\n\t\t\tPredicate provenance.ProvenancePredicate `json:\"predicate\"`\n\t\t}\n\t\tvar stmt stmtT\n\t\trequire.NoError(t, json.Unmarshal(att.LayersRaw[0], &stmt))\n\t\tpred := stmt.Predicate\n\n\t\trequire.Equal(t, \"https://mobyproject.org/buildkit@v1\", pred.BuildType)\n\t\trequire.Equal(t, \"\", pred.Builder.ID)\n\t\trequire.Equal(t, \"\", pred.Invocation.ConfigSource.URI)\n\n\t\tif isGateway {\n\t\t\trequire.Equal(t, 2, len(pred.Materials), \"%+v\", pred.Materials)\n\t\t\trequire.Contains(t, pred.Materials[0].URI, \"buildkit_test\")\n\t\t\trequire.Contains(t, pred.Materials[1].URI, \"pkg:docker/busybox@latest\")\n\t\t\trequire.Contains(t, pred.Materials[1].URI, url.PathEscape(p))\n\t\t} else {\n\t\t\trequire.Equal(t, 1, len(pred.Materials), \"%+v\", pred.Materials)\n\t\t\trequire.Contains(t, pred.Materials[0].URI, \"pkg:docker/busybox@latest\")\n\t\t\trequire.Contains(t, pred.Materials[0].URI, url.PathEscape(p))\n\t\t}\n\n\t\targs := pred.Invocation.Parameters.Args\n\t\tif isClient {\n\t\t\trequire.Equal(t, 0, len(args), \"%+v\", args)\n\t\t} else if isGateway {\n\t\t\trequire.Equal(t, 3, len(args), \"%+v\", args)\n\t\t\trequire.Equal(t, \"bar\", args[\"build-arg:FOO\"])\n\t\t\trequire.Equal(t, \"abc\", args[\"label:lbl\"])\n\t\t\trequire.Contains(t, args[\"source\"], \"buildkit_test/\")\n\t\t} else {\n\t\t\trequire.Equal(t, 2, len(args), \"%+v\", args)\n\t\t\trequire.Equal(t, \"bar\", args[\"build-arg:FOO\"])\n\t\t\trequire.Equal(t, \"abc\", args[\"label:lbl\"])\n\t\t}\n\t}\n}\n\nfunc testClientFrontendProvenance(t *testing.T, sb integration.Sandbox) {\n\tintegration.CheckFeatureCompat(t, sb, integration.FeatureDirectPush, integration.FeatureProvenance)\n\t// Building with client frontend does not capture frontend provenance\n\t// because frontend runs in client, not in BuildKit.\n\t// This test builds Dockerfile inside a client frontend ensuring that\n\t// in that case frontend provenance is captured.\n\tctx := sb.Context()\n\n\tc, err := client.New(ctx, sb.Address())\n\trequire.NoError(t, err)\n\tdefer c.Close()\n\n\tregistry, err := sb.NewRegistry()\n\tif errors.Is(err, integration.ErrRequirements) {\n\t\tt.Skip(err.Error())\n\t}\n\trequire.NoError(t, err)\n\n\ttarget := registry + \"/buildkit/clientprovenance:latest\"\n\n\tf := getFrontend(t, sb)\n\n\t_, isClient := f.(*clientFrontend)\n\tif !isClient {\n\t\tt.Skip(\"not a client frontend\")\n\t}\n\n\tdockerfile := []byte(`\n\tFROM alpine as x86target\n\tRUN echo \"alpine\" > /foo\n\n\tFROM busybox:latest AS armtarget\n\tRUN --network=none echo \"bbox\" > /foo\n\t`)\n\tdir, err := integration.Tmpdir(\n\t\tt,\n\t\tfstest.CreateFile(\"Dockerfile\", dockerfile, 0600),\n\t)\n\trequire.NoError(t, err)\n\n\tfrontend := func(ctx context.Context, c gateway.Client) (*gateway.Result, error) {\n\t\tst := llb.HTTP(\"https://raw.githubusercontent.com/moby/moby/v20.10.21/README.md\")\n\t\tdef, err := st.Marshal(ctx)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\t// This does not show up in provenance\n\t\tres0, err := c.Solve(ctx, gateway.SolveRequest{\n\t\t\tDefinition: def.ToPB(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tdt, err := res0.Ref.ReadFile(ctx, gateway.ReadRequest{\n\t\t\tFilename: \"README.md\",\n\t\t})\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tres1, err := c.Solve(ctx, gateway.SolveRequest{\n\t\t\tFrontend: \"dockerfile.v0\",\n\t\t\tFrontendOpt: map[string]string{\n\t\t\t\t\"build-arg:FOO\": string(dt[:3]),\n\t\t\t\t\"target\":        \"armtarget\",\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tres2, err := c.Solve(ctx, gateway.SolveRequest{\n\t\t\tFrontend: \"dockerfile.v0\",\n\t\t\tFrontendOpt: map[string]string{\n\t\t\t\t\"build-arg:FOO\": string(dt[4:8]),\n\t\t\t\t\"target\":        \"x86target\",\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tres := gateway.NewResult()\n\t\tres.AddRef(\"linux/arm64\", res1.Ref)\n\t\tres.AddRef(\"linux/amd64\", res2.Ref)\n\n\t\tpl, err := json.Marshal(exptypes.Platforms{\n\t\t\tPlatforms: []exptypes.Platform{\n\t\t\t\t{\n\t\t\t\t\tID:       \"linux/arm64\",\n\t\t\t\t\tPlatform: ocispecs.Platform{OS: \"linux\", Architecture: \"arm64\"},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tID:       \"linux/amd64\",\n\t\t\t\t\tPlatform: ocispecs.Platform{OS: \"linux\", Architecture: \"amd64\"},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tres.AddMeta(exptypes.ExporterPlatformsKey, pl)\n\n\t\treturn res, nil\n\t}\n\n\t_, err = c.Build(sb.Context(), client.SolveOpt{\n\t\tFrontendAttrs: map[string]string{\n\t\t\t\"attest:provenance\": \"mode=full\",\n\t\t},\n\t\tExports: []client.ExportEntry{\n\t\t\t{\n\t\t\t\tType: client.ExporterImage,\n\t\t\t\tAttrs: map[string]string{\n\t\t\t\t\t\"name\": target,\n\t\t\t\t\t\"push\": \"true\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tLocalDirs: map[string]string{\n\t\t\tdockerui.DefaultLocalNameDockerfile: dir,\n\t\t\tdockerui.DefaultLocalNameContext:    dir,\n\t\t},\n\t}, \"\", frontend, nil)\n\trequire.NoError(t, err)\n\n\tdesc, provider, err := contentutil.ProviderFromRef(target)\n\trequire.NoError(t, err)\n\timgs, err := testutil.ReadImages(sb.Context(), provider, desc)\n\trequire.NoError(t, err)\n\trequire.Equal(t, 4, len(imgs.Images))\n\n\timg := imgs.Find(\"linux/arm64\")\n\trequire.NotNil(t, img)\n\trequire.Equal(t, []byte(\"bbox\\n\"), img.Layers[1][\"foo\"].Data)\n\n\tatt := imgs.FindAttestation(\"linux/arm64\")\n\trequire.NotNil(t, att)\n\trequire.Equal(t, att.Desc.Annotations[\"vnd.docker.reference.type\"], \"attestation-manifest\")\n\tvar attest intoto.Statement\n\trequire.NoError(t, json.Unmarshal(att.LayersRaw[0], &attest))\n\trequire.Equal(t, \"https://in-toto.io/Statement/v0.1\", attest.Type)\n\trequire.Equal(t, \"https://slsa.dev/provenance/v0.2\", attest.PredicateType) // intentionally not const\n\n\ttype stmtT struct {\n\t\tPredicate provenance.ProvenancePredicate `json:\"predicate\"`\n\t}\n\tvar stmt stmtT\n\trequire.NoError(t, json.Unmarshal(att.LayersRaw[0], &stmt))\n\tpred := stmt.Predicate\n\n\trequire.Equal(t, \"https://mobyproject.org/buildkit@v1\", pred.BuildType)\n\trequire.Equal(t, \"\", pred.Builder.ID)\n\trequire.Equal(t, \"\", pred.Invocation.ConfigSource.URI)\n\n\targs := pred.Invocation.Parameters.Args\n\trequire.Equal(t, 2, len(args), \"%+v\", args)\n\trequire.Equal(t, \"The\", args[\"build-arg:FOO\"])\n\trequire.Equal(t, \"armtarget\", args[\"target\"])\n\n\trequire.Equal(t, 2, len(pred.Invocation.Parameters.Locals))\n\trequire.Equal(t, 1, len(pred.Materials))\n\trequire.Contains(t, pred.Materials[0].URI, \"docker/busybox\")\n\n\t// amd64\n\timg = imgs.Find(\"linux/amd64\")\n\trequire.NotNil(t, img)\n\trequire.Equal(t, []byte(\"alpine\\n\"), img.Layers[1][\"foo\"].Data)\n\n\tatt = imgs.FindAttestation(\"linux/amd64\")\n\trequire.NotNil(t, att)\n\trequire.Equal(t, att.Desc.Annotations[\"vnd.docker.reference.type\"], \"attestation-manifest\")\n\tattest = intoto.Statement{}\n\trequire.NoError(t, json.Unmarshal(att.LayersRaw[0], &attest))\n\trequire.Equal(t, \"https://in-toto.io/Statement/v0.1\", attest.Type)\n\trequire.Equal(t, \"https://slsa.dev/provenance/v0.2\", attest.PredicateType) // intentionally not const\n\n\tstmt = stmtT{}\n\trequire.NoError(t, json.Unmarshal(att.LayersRaw[0], &stmt))\n\tpred = stmt.Predicate\n\n\trequire.Equal(t, \"https://mobyproject.org/buildkit@v1\", pred.BuildType)\n\trequire.Equal(t, \"\", pred.Builder.ID)\n\trequire.Equal(t, \"\", pred.Invocation.ConfigSource.URI)\n\n\targs = pred.Invocation.Parameters.Args\n\trequire.Equal(t, 2, len(args), \"%+v\", args)\n\trequire.Equal(t, \"Moby\", args[\"build-arg:FOO\"])\n\trequire.Equal(t, \"x86target\", args[\"target\"])\n\n\trequire.Equal(t, 2, len(pred.Invocation.Parameters.Locals))\n\trequire.Equal(t, 1, len(pred.Materials))\n\trequire.Contains(t, pred.Materials[0].URI, \"docker/alpine\")\n}\n\nfunc testClientLLBProvenance(t *testing.T, sb integration.Sandbox) {\n\tintegration.CheckFeatureCompat(t, sb, integration.FeatureDirectPush, integration.FeatureProvenance)\n\tctx := sb.Context()\n\n\tc, err := client.New(ctx, sb.Address())\n\trequire.NoError(t, err)\n\tdefer c.Close()\n\n\tregistry, err := sb.NewRegistry()\n\tif errors.Is(err, integration.ErrRequirements) {\n\t\tt.Skip(err.Error())\n\t}\n\trequire.NoError(t, err)\n\n\ttarget := registry + \"/buildkit/clientprovenance:llb\"\n\n\tf := getFrontend(t, sb)\n\n\t_, isClient := f.(*clientFrontend)\n\tif !isClient {\n\t\tt.Skip(\"not a client frontend\")\n\t}\n\n\tfrontend := func(ctx context.Context, c gateway.Client) (*gateway.Result, error) {\n\t\tst := llb.HTTP(\"https://raw.githubusercontent.com/moby/moby/v20.10.21/README.md\")\n\t\tdef, err := st.Marshal(ctx)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\t// this also shows up in the provenance\n\t\tres0, err := c.Solve(ctx, gateway.SolveRequest{\n\t\t\tDefinition: def.ToPB(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tdt, err := res0.Ref.ReadFile(ctx, gateway.ReadRequest{\n\t\t\tFilename: \"README.md\",\n\t\t})\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tst = llb.Image(\"alpine\").File(llb.Mkfile(\"/foo\", 0600, dt))\n\t\tdef, err = st.Marshal(ctx)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tres1, err := c.Solve(ctx, gateway.SolveRequest{\n\t\t\tDefinition: def.ToPB(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn res1, nil\n\t}\n\n\t_, err = c.Build(sb.Context(), client.SolveOpt{\n\t\tFrontendAttrs: map[string]string{\n\t\t\t\"attest:provenance\": \"mode=full\",\n\t\t},\n\t\tExports: []client.ExportEntry{\n\t\t\t{\n\t\t\t\tType: client.ExporterImage,\n\t\t\t\tAttrs: map[string]string{\n\t\t\t\t\t\"name\": target,\n\t\t\t\t\t\"push\": \"true\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tLocalDirs: map[string]string{},\n\t}, \"\", frontend, nil)\n\trequire.NoError(t, err)\n\n\tdesc, provider, err := contentutil.ProviderFromRef(target)\n\trequire.NoError(t, err)\n\timgs, err := testutil.ReadImages(sb.Context(), provider, desc)\n\trequire.NoError(t, err)\n\trequire.Equal(t, 2, len(imgs.Images))\n\n\tnativePlatform := platforms.Format(platforms.Normalize(platforms.DefaultSpec()))\n\n\timg := imgs.Find(nativePlatform)\n\trequire.NotNil(t, img)\n\trequire.Contains(t, string(img.Layers[1][\"foo\"].Data), \"The Moby Project\")\n\n\tatt := imgs.FindAttestation(nativePlatform)\n\trequire.NotNil(t, att)\n\trequire.Equal(t, att.Desc.Annotations[\"vnd.docker.reference.type\"], \"attestation-manifest\")\n\tvar attest intoto.Statement\n\trequire.NoError(t, json.Unmarshal(att.LayersRaw[0], &attest))\n\trequire.Equal(t, \"https://in-toto.io/Statement/v0.1\", attest.Type)\n\trequire.Equal(t, \"https://slsa.dev/provenance/v0.2\", attest.PredicateType) // intentionally not const\n\n\ttype stmtT struct {\n\t\tPredicate provenance.ProvenancePredicate `json:\"predicate\"`\n\t}\n\tvar stmt stmtT\n\trequire.NoError(t, json.Unmarshal(att.LayersRaw[0], &stmt))\n\tpred := stmt.Predicate\n\n\trequire.Equal(t, \"https://mobyproject.org/buildkit@v1\", pred.BuildType)\n\trequire.Equal(t, \"\", pred.Builder.ID)\n\trequire.Equal(t, \"\", pred.Invocation.ConfigSource.URI)\n\n\targs := pred.Invocation.Parameters.Args\n\trequire.Equal(t, 0, len(args), \"%+v\", args)\n\trequire.Equal(t, 0, len(pred.Invocation.Parameters.Locals))\n\n\trequire.Equal(t, 2, len(pred.Materials), \"%+v\", pred.Materials)\n\trequire.Contains(t, pred.Materials[0].URI, \"docker/alpine\")\n\trequire.Contains(t, pred.Materials[1].URI, \"README.md\")\n}\n\nfunc testSecretSSHProvenance(t *testing.T, sb integration.Sandbox) {\n\tintegration.CheckFeatureCompat(t, sb, integration.FeatureDirectPush, integration.FeatureProvenance)\n\tctx := sb.Context()\n\n\tc, err := client.New(ctx, sb.Address())\n\trequire.NoError(t, err)\n\tdefer c.Close()\n\n\tregistry, err := sb.NewRegistry()\n\tif errors.Is(err, integration.ErrRequirements) {\n\t\tt.Skip(err.Error())\n\t}\n\trequire.NoError(t, err)\n\n\tf := getFrontend(t, sb)\n\n\tdockerfile := []byte(`\nFROM busybox:latest\nRUN --mount=type=secret,id=mysecret --mount=type=secret,id=othersecret --mount=type=ssh echo \"ok\" > /foo\n`)\n\tdir, err := integration.Tmpdir(\n\t\tt,\n\t\tfstest.CreateFile(\"Dockerfile\", dockerfile, 0600),\n\t)\n\trequire.NoError(t, err)\n\n\ttarget := registry + \"/buildkit/testsecretprovenance:latest\"\n\t_, err = f.Solve(sb.Context(), c, client.SolveOpt{\n\t\tLocalDirs: map[string]string{\n\t\t\tdockerui.DefaultLocalNameDockerfile: dir,\n\t\t\tdockerui.DefaultLocalNameContext:    dir,\n\t\t},\n\t\tFrontendAttrs: map[string]string{\n\t\t\t\"attest:provenance\": \"mode=max\",\n\t\t},\n\t\tExports: []client.ExportEntry{\n\t\t\t{\n\t\t\t\tType: client.ExporterImage,\n\t\t\t\tAttrs: map[string]string{\n\t\t\t\t\t\"name\": target,\n\t\t\t\t\t\"push\": \"true\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}, nil)\n\trequire.NoError(t, err)\n\n\tdesc, provider, err := contentutil.ProviderFromRef(target)\n\trequire.NoError(t, err)\n\timgs, err := testutil.ReadImages(sb.Context(), provider, desc)\n\trequire.NoError(t, err)\n\trequire.Equal(t, 2, len(imgs.Images))\n\n\texpPlatform := platforms.Format(platforms.Normalize(platforms.DefaultSpec()))\n\n\timg := imgs.Find(expPlatform)\n\trequire.NotNil(t, img)\n\trequire.Equal(t, []byte(\"ok\\n\"), img.Layers[1][\"foo\"].Data)\n\n\tatt := imgs.FindAttestation(expPlatform)\n\ttype stmtT struct {\n\t\tPredicate provenance.ProvenancePredicate `json:\"predicate\"`\n\t}\n\tvar stmt stmtT\n\trequire.NoError(t, json.Unmarshal(att.LayersRaw[0], &stmt))\n\tpred := stmt.Predicate\n\n\trequire.Equal(t, 2, len(pred.Invocation.Parameters.Secrets), \"%+v\", pred.Invocation.Parameters.Secrets)\n\trequire.Equal(t, \"mysecret\", pred.Invocation.Parameters.Secrets[0].ID)\n\trequire.True(t, pred.Invocation.Parameters.Secrets[0].Optional)\n\trequire.Equal(t, \"othersecret\", pred.Invocation.Parameters.Secrets[1].ID)\n\trequire.True(t, pred.Invocation.Parameters.Secrets[1].Optional)\n\n\trequire.Equal(t, 1, len(pred.Invocation.Parameters.SSH), \"%+v\", pred.Invocation.Parameters.SSH)\n\trequire.Equal(t, \"default\", pred.Invocation.Parameters.SSH[0].ID)\n\trequire.True(t, pred.Invocation.Parameters.SSH[0].Optional)\n}\n\nfunc testNilProvenance(t *testing.T, sb integration.Sandbox) {\n\tintegration.CheckFeatureCompat(t, sb, integration.FeatureProvenance)\n\tctx := sb.Context()\n\n\tc, err := client.New(ctx, sb.Address())\n\trequire.NoError(t, err)\n\tdefer c.Close()\n\n\tf := getFrontend(t, sb)\n\n\tdockerfile := []byte(`\nFROM scratch\nENV FOO=bar\n`)\n\tdir, err := integration.Tmpdir(\n\t\tt,\n\t\tfstest.CreateFile(\"Dockerfile\", dockerfile, 0600),\n\t)\n\trequire.NoError(t, err)\n\n\t_, err = f.Solve(sb.Context(), c, client.SolveOpt{\n\t\tLocalDirs: map[string]string{\n\t\t\tdockerui.DefaultLocalNameDockerfile: dir,\n\t\t\tdockerui.DefaultLocalNameContext:    dir,\n\t\t},\n\t\tFrontendAttrs: map[string]string{\n\t\t\t\"attest:provenance\": \"mode=max\",\n\t\t},\n\t\tExports: []client.ExportEntry{\n\t\t\t{\n\t\t\t\tType: client.ExporterImage,\n\t\t\t},\n\t\t},\n\t}, nil)\n\trequire.NoError(t, err)\n}\n", "package provenance\n\nimport (\n\t\"sort\"\n\n\tdistreference \"github.com/docker/distribution/reference\"\n\t\"github.com/moby/buildkit/solver/result\"\n\tdigest \"github.com/opencontainers/go-digest\"\n\tocispecs \"github.com/opencontainers/image-spec/specs-go/v1\"\n)\n\ntype Result = result.Result[*Capture]\n\ntype ImageSource struct {\n\tRef      string\n\tPlatform *ocispecs.Platform\n\tDigest   digest.Digest\n}\n\ntype GitSource struct {\n\tURL    string\n\tCommit string\n}\n\ntype HTTPSource struct {\n\tURL    string\n\tDigest digest.Digest\n}\n\ntype LocalSource struct {\n\tName string `json:\"name\"`\n}\n\ntype Secret struct {\n\tID       string `json:\"id\"`\n\tOptional bool   `json:\"optional,omitempty\"`\n}\n\ntype SSH struct {\n\tID       string `json:\"id\"`\n\tOptional bool   `json:\"optional,omitempty\"`\n}\n\ntype Sources struct {\n\tImages      []ImageSource\n\tLocalImages []ImageSource\n\tGit         []GitSource\n\tHTTP        []HTTPSource\n\tLocal       []LocalSource\n}\n\ntype Capture struct {\n\tFrontend            string\n\tArgs                map[string]string\n\tSources             Sources\n\tSecrets             []Secret\n\tSSH                 []SSH\n\tNetworkAccess       bool\n\tIncompleteMaterials bool\n}\n\nfunc (c *Capture) Merge(c2 *Capture) error {\n\tif c2 == nil {\n\t\treturn nil\n\t}\n\tfor _, i := range c2.Sources.Images {\n\t\tc.AddImage(i)\n\t}\n\tfor _, i := range c2.Sources.LocalImages {\n\t\tc.AddLocalImage(i)\n\t}\n\tfor _, l := range c2.Sources.Local {\n\t\tc.AddLocal(l)\n\t}\n\tfor _, g := range c2.Sources.Git {\n\t\tc.AddGit(g)\n\t}\n\tfor _, h := range c2.Sources.HTTP {\n\t\tc.AddHTTP(h)\n\t}\n\tfor _, s := range c2.Secrets {\n\t\tc.AddSecret(s)\n\t}\n\tfor _, s := range c2.SSH {\n\t\tc.AddSSH(s)\n\t}\n\tif c2.NetworkAccess {\n\t\tc.NetworkAccess = true\n\t}\n\tif c2.IncompleteMaterials {\n\t\tc.IncompleteMaterials = true\n\t}\n\treturn nil\n}\n\nfunc (c *Capture) Sort() {\n\tsort.Slice(c.Sources.Images, func(i, j int) bool {\n\t\treturn c.Sources.Images[i].Ref < c.Sources.Images[j].Ref\n\t})\n\tsort.Slice(c.Sources.LocalImages, func(i, j int) bool {\n\t\treturn c.Sources.LocalImages[i].Ref < c.Sources.LocalImages[j].Ref\n\t})\n\tsort.Slice(c.Sources.Local, func(i, j int) bool {\n\t\treturn c.Sources.Local[i].Name < c.Sources.Local[j].Name\n\t})\n\tsort.Slice(c.Sources.Git, func(i, j int) bool {\n\t\treturn c.Sources.Git[i].URL < c.Sources.Git[j].URL\n\t})\n\tsort.Slice(c.Sources.HTTP, func(i, j int) bool {\n\t\treturn c.Sources.HTTP[i].URL < c.Sources.HTTP[j].URL\n\t})\n\tsort.Slice(c.Secrets, func(i, j int) bool {\n\t\treturn c.Secrets[i].ID < c.Secrets[j].ID\n\t})\n\tsort.Slice(c.SSH, func(i, j int) bool {\n\t\treturn c.SSH[i].ID < c.SSH[j].ID\n\t})\n}\n\n// OptimizeImageSources filters out image sources by digest reference if same digest\n// is already present by a tag reference.\nfunc (c *Capture) OptimizeImageSources() error {\n\tm := map[string]struct{}{}\n\tfor _, i := range c.Sources.Images {\n\t\tref, nameTag, err := parseRefName(i.Ref)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, ok := ref.(distreference.Canonical); !ok {\n\t\t\tm[nameTag] = struct{}{}\n\t\t}\n\t}\n\n\timages := make([]ImageSource, 0, len(c.Sources.Images))\n\tfor _, i := range c.Sources.Images {\n\t\tref, nameTag, err := parseRefName(i.Ref)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, ok := ref.(distreference.Canonical); ok {\n\t\t\tif _, ok := m[nameTag]; ok {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t\timages = append(images, i)\n\t}\n\tc.Sources.Images = images\n\treturn nil\n}\n\nfunc (c *Capture) AddImage(i ImageSource) {\n\tfor _, v := range c.Sources.Images {\n\t\tif v.Ref == i.Ref {\n\t\t\tif v.Platform == i.Platform {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif v.Platform != nil && i.Platform != nil {\n\t\t\t\tif v.Platform.Architecture == i.Platform.Architecture && v.Platform.OS == i.Platform.OS && v.Platform.Variant == i.Platform.Variant {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tc.Sources.Images = append(c.Sources.Images, i)\n}\n\nfunc (c *Capture) AddLocalImage(i ImageSource) {\n\tfor _, v := range c.Sources.LocalImages {\n\t\tif v.Ref == i.Ref {\n\t\t\tif v.Platform == i.Platform {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif v.Platform != nil && i.Platform != nil {\n\t\t\t\tif v.Platform.Architecture == i.Platform.Architecture && v.Platform.OS == i.Platform.OS && v.Platform.Variant == i.Platform.Variant {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tc.Sources.LocalImages = append(c.Sources.LocalImages, i)\n}\n\nfunc (c *Capture) AddLocal(l LocalSource) {\n\tfor _, v := range c.Sources.Local {\n\t\tif v.Name == l.Name {\n\t\t\treturn\n\t\t}\n\t}\n\tc.Sources.Local = append(c.Sources.Local, l)\n}\n\nfunc (c *Capture) AddGit(g GitSource) {\n\tfor _, v := range c.Sources.Git {\n\t\tif v.URL == g.URL {\n\t\t\treturn\n\t\t}\n\t}\n\tc.Sources.Git = append(c.Sources.Git, g)\n}\n\nfunc (c *Capture) AddHTTP(h HTTPSource) {\n\tfor _, v := range c.Sources.HTTP {\n\t\tif v.URL == h.URL {\n\t\t\treturn\n\t\t}\n\t}\n\tc.Sources.HTTP = append(c.Sources.HTTP, h)\n}\n\nfunc (c *Capture) AddSecret(s Secret) {\n\tfor i, v := range c.Secrets {\n\t\tif v.ID == s.ID {\n\t\t\tif !s.Optional {\n\t\t\t\tc.Secrets[i].Optional = false\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t}\n\tc.Secrets = append(c.Secrets, s)\n}\n\nfunc (c *Capture) AddSSH(s SSH) {\n\tif s.ID == \"\" {\n\t\ts.ID = \"default\"\n\t}\n\tfor i, v := range c.SSH {\n\t\tif v.ID == s.ID {\n\t\t\tif !s.Optional {\n\t\t\t\tc.SSH[i].Optional = false\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t}\n\tc.SSH = append(c.SSH, s)\n}\n\nfunc parseRefName(s string) (distreference.Named, string, error) {\n\tref, err := distreference.ParseNormalizedNamed(s)\n\tif err != nil {\n\t\treturn nil, \"\", err\n\t}\n\tname := ref.Name()\n\ttag := \"latest\"\n\tif r, ok := ref.(distreference.Tagged); ok {\n\t\ttag = r.Tag()\n\t}\n\treturn ref, name + \":\" + tag, nil\n}\n", "package provenance\n\nimport (\n\t\"strings\"\n\n\t\"github.com/containerd/containerd/platforms\"\n\tslsa \"github.com/in-toto/in-toto-golang/in_toto/slsa_provenance/common\"\n\tslsa02 \"github.com/in-toto/in-toto-golang/in_toto/slsa_provenance/v0.2\"\n\t\"github.com/moby/buildkit/util/purl\"\n\tocispecs \"github.com/opencontainers/image-spec/specs-go/v1\"\n\t\"github.com/package-url/packageurl-go\"\n)\n\nconst (\n\tBuildKitBuildType = \"https://mobyproject.org/buildkit@v1\"\n)\n\ntype ProvenancePredicate struct {\n\tslsa02.ProvenancePredicate\n\tInvocation  ProvenanceInvocation `json:\"invocation,omitempty\"`\n\tBuildConfig *BuildConfig         `json:\"buildConfig,omitempty\"`\n\tMetadata    *ProvenanceMetadata  `json:\"metadata,omitempty\"`\n}\n\ntype ProvenanceInvocation struct {\n\tConfigSource slsa02.ConfigSource `json:\"configSource,omitempty\"`\n\tParameters   Parameters          `json:\"parameters,omitempty\"`\n\tEnvironment  Environment         `json:\"environment,omitempty\"`\n}\n\ntype Parameters struct {\n\tFrontend string            `json:\"frontend,omitempty\"`\n\tArgs     map[string]string `json:\"args,omitempty\"`\n\tSecrets  []*Secret         `json:\"secrets,omitempty\"`\n\tSSH      []*SSH            `json:\"ssh,omitempty\"`\n\tLocals   []*LocalSource    `json:\"locals,omitempty\"`\n\t// TODO: select export attributes\n\t// TODO: frontend inputs\n}\n\ntype Environment struct {\n\tPlatform string `json:\"platform\"`\n}\n\ntype ProvenanceMetadata struct {\n\tslsa02.ProvenanceMetadata\n\tBuildKitMetadata BuildKitMetadata `json:\"https://mobyproject.org/buildkit@v1#metadata,omitempty\"`\n\tHermetic         bool             `json:\"https://mobyproject.org/buildkit@v1#hermetic,omitempty\"`\n}\n\ntype BuildKitMetadata struct {\n\tVCS    map[string]string                  `json:\"vcs,omitempty\"`\n\tSource *Source                            `json:\"source,omitempty\"`\n\tLayers map[string][][]ocispecs.Descriptor `json:\"layers,omitempty\"`\n}\n\nfunc slsaMaterials(srcs Sources) ([]slsa.ProvenanceMaterial, error) {\n\tcount := len(srcs.Images) + len(srcs.Git) + len(srcs.HTTP) + len(srcs.LocalImages)\n\tout := make([]slsa.ProvenanceMaterial, 0, count)\n\n\tfor _, s := range srcs.Images {\n\t\turi, err := purl.RefToPURL(s.Ref, s.Platform)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tout = append(out, slsa.ProvenanceMaterial{\n\t\t\tURI: uri,\n\t\t\tDigest: slsa.DigestSet{\n\t\t\t\ts.Digest.Algorithm().String(): s.Digest.Hex(),\n\t\t\t},\n\t\t})\n\t}\n\n\tfor _, s := range srcs.Git {\n\t\tout = append(out, slsa.ProvenanceMaterial{\n\t\t\tURI: s.URL,\n\t\t\tDigest: slsa.DigestSet{\n\t\t\t\t\"sha1\": s.Commit,\n\t\t\t},\n\t\t})\n\t}\n\n\tfor _, s := range srcs.HTTP {\n\t\tout = append(out, slsa.ProvenanceMaterial{\n\t\t\tURI: s.URL,\n\t\t\tDigest: slsa.DigestSet{\n\t\t\t\ts.Digest.Algorithm().String(): s.Digest.Hex(),\n\t\t\t},\n\t\t})\n\t}\n\n\tfor _, s := range srcs.LocalImages {\n\t\tq := []packageurl.Qualifier{}\n\t\tif s.Platform != nil {\n\t\t\tq = append(q, packageurl.Qualifier{\n\t\t\t\tKey:   \"platform\",\n\t\t\t\tValue: platforms.Format(*s.Platform),\n\t\t\t})\n\t\t}\n\t\tpackageurl.NewPackageURL(packageurl.TypeOCI, \"\", s.Ref, \"\", q, \"\")\n\t\tout = append(out, slsa.ProvenanceMaterial{\n\t\t\tURI: s.Ref,\n\t\t\tDigest: slsa.DigestSet{\n\t\t\t\ts.Digest.Algorithm().String(): s.Digest.Hex(),\n\t\t\t},\n\t\t})\n\t}\n\treturn out, nil\n}\n\nfunc findMaterial(srcs Sources, uri string) (*slsa.ProvenanceMaterial, bool) {\n\tfor _, s := range srcs.Git {\n\t\tif s.URL == uri {\n\t\t\treturn &slsa.ProvenanceMaterial{\n\t\t\t\tURI: s.URL,\n\t\t\t\tDigest: slsa.DigestSet{\n\t\t\t\t\t\"sha1\": s.Commit,\n\t\t\t\t},\n\t\t\t}, true\n\t\t}\n\t}\n\tfor _, s := range srcs.HTTP {\n\t\tif s.URL == uri {\n\t\t\treturn &slsa.ProvenanceMaterial{\n\t\t\t\tURI: s.URL,\n\t\t\t\tDigest: slsa.DigestSet{\n\t\t\t\t\ts.Digest.Algorithm().String(): s.Digest.Hex(),\n\t\t\t\t},\n\t\t\t}, true\n\t\t}\n\t}\n\treturn nil, false\n}\n\nfunc NewPredicate(c *Capture) (*ProvenancePredicate, error) {\n\tmaterials, err := slsaMaterials(c.Sources)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tinv := ProvenanceInvocation{}\n\n\tcontextKey := \"context\"\n\tif v, ok := c.Args[\"contextkey\"]; ok && v != \"\" {\n\t\tcontextKey = v\n\t}\n\n\tif v, ok := c.Args[contextKey]; ok && v != \"\" {\n\t\tif m, ok := findMaterial(c.Sources, v); ok {\n\t\t\tinv.ConfigSource.URI = m.URI\n\t\t\tinv.ConfigSource.Digest = m.Digest\n\t\t} else {\n\t\t\tinv.ConfigSource.URI = v\n\t\t}\n\t\tdelete(c.Args, contextKey)\n\t}\n\n\tif v, ok := c.Args[\"filename\"]; ok && v != \"\" {\n\t\tinv.ConfigSource.EntryPoint = v\n\t\tdelete(c.Args, \"filename\")\n\t}\n\n\tvcs := make(map[string]string)\n\tfor k, v := range c.Args {\n\t\tif strings.HasPrefix(k, \"vcs:\") {\n\t\t\tdelete(c.Args, k)\n\t\t\tif v != \"\" {\n\t\t\t\tvcs[strings.TrimPrefix(k, \"vcs:\")] = v\n\t\t\t}\n\t\t}\n\t}\n\n\tinv.Environment.Platform = platforms.Format(platforms.Normalize(platforms.DefaultSpec()))\n\n\tinv.Parameters.Frontend = c.Frontend\n\tinv.Parameters.Args = c.Args\n\n\tfor _, s := range c.Secrets {\n\t\tinv.Parameters.Secrets = append(inv.Parameters.Secrets, &Secret{\n\t\t\tID:       s.ID,\n\t\t\tOptional: s.Optional,\n\t\t})\n\t}\n\tfor _, s := range c.SSH {\n\t\tinv.Parameters.SSH = append(inv.Parameters.SSH, &SSH{\n\t\t\tID:       s.ID,\n\t\t\tOptional: s.Optional,\n\t\t})\n\t}\n\tfor _, s := range c.Sources.Local {\n\t\tinv.Parameters.Locals = append(inv.Parameters.Locals, &LocalSource{\n\t\t\tName: s.Name,\n\t\t})\n\t}\n\n\tincompleteMaterials := c.IncompleteMaterials\n\tif !incompleteMaterials {\n\t\tif len(c.Sources.Local) > 0 {\n\t\t\tincompleteMaterials = true\n\t\t}\n\t}\n\n\tpr := &ProvenancePredicate{\n\t\tInvocation: inv,\n\t\tProvenancePredicate: slsa02.ProvenancePredicate{\n\t\t\tBuildType: BuildKitBuildType,\n\t\t\tMaterials: materials,\n\t\t},\n\t\tMetadata: &ProvenanceMetadata{\n\t\t\tProvenanceMetadata: slsa02.ProvenanceMetadata{\n\t\t\t\tCompleteness: slsa02.ProvenanceComplete{\n\t\t\t\t\tParameters:  c.Frontend != \"\",\n\t\t\t\t\tEnvironment: true,\n\t\t\t\t\tMaterials:   !incompleteMaterials,\n\t\t\t\t},\n\t\t\t},\n\t\t\tHermetic: !incompleteMaterials && !c.NetworkAccess,\n\t\t},\n\t}\n\n\tif len(vcs) > 0 {\n\t\tpr.Metadata.BuildKitMetadata.VCS = vcs\n\t}\n\n\treturn pr, nil\n}\n\nfunc FilterArgs(m map[string]string) map[string]string {\n\tvar hostSpecificArgs = map[string]struct{}{\n\t\t\"cgroup-parent\":      {},\n\t\t\"image-resolve-mode\": {},\n\t\t\"platform\":           {},\n\t\t\"cache-imports\":      {},\n\t}\n\tout := make(map[string]string)\n\tfor k, v := range m {\n\t\tif _, ok := hostSpecificArgs[k]; ok {\n\t\t\tcontinue\n\t\t}\n\t\tif strings.HasPrefix(k, \"attest:\") {\n\t\t\tcontinue\n\t\t}\n\t\tout[k] = v\n\t}\n\treturn out\n}\n"], "fixing_code": ["package dockerfile\n\nimport (\n\t\"context\"\n\t\"encoding/base64\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/containerd/continuity/fs/fstest\"\n\t\"github.com/moby/buildkit/client\"\n\t\"github.com/moby/buildkit/exporter/containerimage/exptypes\"\n\t\"github.com/moby/buildkit/frontend/dockerui\"\n\tgateway \"github.com/moby/buildkit/frontend/gateway/client\"\n\t\"github.com/moby/buildkit/solver/pb\"\n\tbinfotypes \"github.com/moby/buildkit/util/buildinfo/types\"\n\t\"github.com/moby/buildkit/util/testutil/integration\"\n\t\"github.com/pkg/errors\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nvar buildinfoTests = integration.TestFuncs(\n\ttestBuildInfoSources,\n\ttestBuildInfoSourcesNoop,\n\ttestBuildInfoAttrs,\n\ttestBuildInfoMultiPlatform,\n\ttestBuildInfoImageContext,\n\ttestBuildInfoLocalContext,\n\ttestBuildInfoDeps,\n\ttestBuildInfoDepsMultiPlatform,\n\ttestBuildInfoDepsMainNoSource,\n)\n\nfunc init() {\n\tallTests = append(allTests, buildinfoTests...)\n}\n\n// moby/buildkit#2311\nfunc testBuildInfoSources(t *testing.T, sb integration.Sandbox) {\n\tf := getFrontend(t, sb)\n\tf.RequiresBuildctl(t)\n\n\tgitDir := t.TempDir()\n\n\tdockerfile := `\nFROM alpine:latest@sha256:21a3deaa0d32a8057914f36584b5288d2e5ecc984380bc0118285c70fa8c9300 AS alpine\nFROM busybox:latest\nADD https://user2:pw2@raw.githubusercontent.com/moby/moby/v20.10.21/README.md /\nCOPY --from=alpine /bin/busybox /alpine-busybox\n`\n\n\terr := os.WriteFile(filepath.Join(gitDir, \"Dockerfile\"), []byte(dockerfile), 0600)\n\trequire.NoError(t, err)\n\n\terr = runShell(gitDir,\n\t\t\"git init\",\n\t\t\"git config --local user.email test\",\n\t\t\"git config --local user.name test\",\n\t\t\"git add Dockerfile\",\n\t\t\"git commit -m initial\",\n\t\t\"git branch buildinfo\",\n\t\t\"git update-server-info\",\n\t)\n\trequire.NoError(t, err)\n\n\tserver := httptest.NewServer(http.FileServer(http.Dir(filepath.Join(gitDir))))\n\tdefer server.Close()\n\n\tc, err := client.New(sb.Context(), sb.Address())\n\trequire.NoError(t, err)\n\tdefer c.Close()\n\n\tvar exports []client.ExportEntry\n\tif integration.IsTestDockerdMoby(sb) {\n\t\texports = []client.ExportEntry{{\n\t\t\tType: \"moby\",\n\t\t\tAttrs: map[string]string{\n\t\t\t\t\"name\": \"reg.dummy:5000/buildkit/test:latest\",\n\t\t\t},\n\t\t}}\n\t} else {\n\t\texports = []client.ExportEntry{{\n\t\t\tType:   client.ExporterOCI,\n\t\t\tAttrs:  map[string]string{},\n\t\t\tOutput: fixedWriteCloser(nopWriteCloser{io.Discard}),\n\t\t}}\n\t}\n\n\texpectedURL := strings.Replace(server.URL, \"http://\", \"http://xxxxx:xxxxx@\", 1)\n\trequire.NotEqual(t, expectedURL, server.URL)\n\tserver.URL = strings.Replace(server.URL, \"http://\", \"http://user:pass@\", 1)\n\n\tres, err := f.Solve(sb.Context(), c, client.SolveOpt{\n\t\tExports: exports,\n\t\tFrontendAttrs: map[string]string{\n\t\t\tdockerui.DefaultLocalNameContext:          server.URL + \"/.git#buildinfo\",\n\t\t\tdockerui.DefaultLocalNameContext + \":foo\": \"https://foo:bar@example.invalid/foo.html\",\n\t\t},\n\t}, nil)\n\trequire.NoError(t, err)\n\n\trequire.Contains(t, res.ExporterResponse, exptypes.ExporterBuildInfo)\n\tdtbi, err := base64.StdEncoding.DecodeString(res.ExporterResponse[exptypes.ExporterBuildInfo])\n\trequire.NoError(t, err)\n\n\tvar bi binfotypes.BuildInfo\n\terr = json.Unmarshal(dtbi, &bi)\n\trequire.NoError(t, err)\n\n\trequire.Contains(t, bi.Attrs, \"context\")\n\trequire.Equal(t, expectedURL+\"/.git#buildinfo\", *bi.Attrs[\"context\"])\n\n\trequire.Equal(t, \"https://xxxxx:xxxxx@example.invalid/foo.html\", *bi.Attrs[\"context:foo\"])\n\n\t_, isGateway := f.(*gatewayFrontend)\n\n\tsources := bi.Sources\n\tif isGateway {\n\t\trequire.Equal(t, 5, len(sources), \"%+v\", sources)\n\t\tassert.Equal(t, binfotypes.SourceTypeDockerImage, sources[0].Type)\n\t\tassert.Contains(t, sources[0].Ref, \"buildkit_test\")\n\t\tsources = sources[1:]\n\t}\n\trequire.Equal(t, 4, len(sources), \"%+v\", sources)\n\tassert.Equal(t, binfotypes.SourceTypeDockerImage, sources[0].Type)\n\tassert.Equal(t, \"docker.io/library/alpine:latest@sha256:21a3deaa0d32a8057914f36584b5288d2e5ecc984380bc0118285c70fa8c9300\", sources[0].Ref)\n\tassert.Equal(t, \"sha256:21a3deaa0d32a8057914f36584b5288d2e5ecc984380bc0118285c70fa8c9300\", sources[0].Pin)\n\n\tassert.Equal(t, binfotypes.SourceTypeDockerImage, sources[1].Type)\n\tassert.Equal(t, \"docker.io/library/busybox:latest\", sources[1].Ref)\n\tassert.NotEmpty(t, sources[1].Pin)\n\n\tassert.Equal(t, binfotypes.SourceTypeGit, sources[2].Type)\n\tassert.Equal(t, expectedURL+\"/.git#buildinfo\", sources[2].Ref)\n\tassert.NotEmpty(t, sources[2].Pin)\n\n\tassert.Equal(t, binfotypes.SourceTypeHTTP, sources[3].Type)\n\tassert.Equal(t, \"https://xxxxx:xxxxx@raw.githubusercontent.com/moby/moby/v20.10.21/README.md\", sources[3].Ref)\n\tassert.Equal(t, \"sha256:419455202b0ef97e480d7f8199b26a721a417818bc0e2d106975f74323f25e6c\", sources[3].Pin)\n}\n\nfunc testBuildInfoSourcesNoop(t *testing.T, sb integration.Sandbox) {\n\tf := getFrontend(t, sb)\n\tf.RequiresBuildctl(t)\n\n\tdockerfile := `\nFROM busybox:latest\n`\n\n\tdir, err := integration.Tmpdir(\n\t\tt,\n\t\tfstest.CreateFile(\"Dockerfile\", []byte(dockerfile), 0600),\n\t)\n\trequire.NoError(t, err)\n\n\tc, err := client.New(sb.Context(), sb.Address())\n\trequire.NoError(t, err)\n\tdefer c.Close()\n\n\tvar exports []client.ExportEntry\n\tif integration.IsTestDockerdMoby(sb) {\n\t\texports = []client.ExportEntry{{\n\t\t\tType: \"moby\",\n\t\t\tAttrs: map[string]string{\n\t\t\t\t\"name\": \"reg.dummy:5000/buildkit/test:latest\",\n\t\t\t},\n\t\t}}\n\t} else {\n\t\texports = []client.ExportEntry{{\n\t\t\tType:   client.ExporterOCI,\n\t\t\tAttrs:  map[string]string{},\n\t\t\tOutput: fixedWriteCloser(nopWriteCloser{io.Discard}),\n\t\t}}\n\t}\n\n\tres, err := f.Solve(sb.Context(), c, client.SolveOpt{\n\t\tExports: exports,\n\t\tLocalDirs: map[string]string{\n\t\t\tdockerui.DefaultLocalNameDockerfile: dir,\n\t\t\tdockerui.DefaultLocalNameContext:    dir,\n\t\t},\n\t}, nil)\n\trequire.NoError(t, err)\n\n\trequire.Contains(t, res.ExporterResponse, exptypes.ExporterBuildInfo)\n\tdtbi, err := base64.StdEncoding.DecodeString(res.ExporterResponse[exptypes.ExporterBuildInfo])\n\trequire.NoError(t, err)\n\n\tvar bi binfotypes.BuildInfo\n\terr = json.Unmarshal(dtbi, &bi)\n\trequire.NoError(t, err)\n\n\tsources := bi.Sources\n\n\tif _, isGateway := f.(*gatewayFrontend); isGateway {\n\t\trequire.Equal(t, 2, len(sources), \"%+v\", sources)\n\t\tsources = sources[1:]\n\t}\n\trequire.Equal(t, 1, len(sources))\n\tassert.Equal(t, binfotypes.SourceTypeDockerImage, sources[0].Type)\n\tassert.Equal(t, \"docker.io/library/busybox:latest\", sources[0].Ref)\n\tassert.NotEmpty(t, sources[0].Pin)\n}\n\n// moby/buildkit#2476\nfunc testBuildInfoAttrs(t *testing.T, sb integration.Sandbox) {\n\tf := getFrontend(t, sb)\n\tf.RequiresBuildctl(t)\n\n\tdockerfile := `\nFROM busybox:latest\nARG foo\nRUN echo $foo\n`\n\n\tdir, err := integration.Tmpdir(\n\t\tt,\n\t\tfstest.CreateFile(\"Dockerfile\", []byte(dockerfile), 0600),\n\t)\n\trequire.NoError(t, err)\n\n\tc, err := client.New(sb.Context(), sb.Address())\n\trequire.NoError(t, err)\n\tdefer c.Close()\n\n\tvar exports []client.ExportEntry\n\tif integration.IsTestDockerdMoby(sb) {\n\t\texports = []client.ExportEntry{{\n\t\t\tType: \"moby\",\n\t\t\tAttrs: map[string]string{\n\t\t\t\t\"name\": \"reg.dummy:5000/buildkit/test:latest\",\n\t\t\t},\n\t\t}}\n\t} else {\n\t\texports = []client.ExportEntry{{\n\t\t\tType:   client.ExporterOCI,\n\t\t\tAttrs:  map[string]string{},\n\t\t\tOutput: fixedWriteCloser(nopWriteCloser{io.Discard}),\n\t\t}}\n\t}\n\n\tres, err := f.Solve(sb.Context(), c, client.SolveOpt{\n\t\tFrontendAttrs: map[string]string{\n\t\t\t\"build-arg:foo\": \"bar\",\n\t\t},\n\t\tExports: exports,\n\t\tLocalDirs: map[string]string{\n\t\t\tdockerui.DefaultLocalNameDockerfile: dir,\n\t\t\tdockerui.DefaultLocalNameContext:    dir,\n\t\t},\n\t}, nil)\n\trequire.NoError(t, err)\n\n\trequire.Contains(t, res.ExporterResponse, exptypes.ExporterBuildInfo)\n\tdtbi, err := base64.StdEncoding.DecodeString(res.ExporterResponse[exptypes.ExporterBuildInfo])\n\trequire.NoError(t, err)\n\n\tvar bi binfotypes.BuildInfo\n\terr = json.Unmarshal(dtbi, &bi)\n\trequire.NoError(t, err)\n\n\trequire.Contains(t, bi.Attrs, \"build-arg:foo\")\n\trequire.Equal(t, \"bar\", *bi.Attrs[\"build-arg:foo\"])\n}\n\n// moby/buildkit#2476\nfunc testBuildInfoMultiPlatform(t *testing.T, sb integration.Sandbox) {\n\tintegration.CheckFeatureCompat(t, sb, integration.FeatureOCIExporter, integration.FeatureMultiPlatform)\n\tf := getFrontend(t, sb)\n\tf.RequiresBuildctl(t)\n\n\tdockerfile := `\nFROM busybox:latest\nARG foo\nRUN echo $foo\nADD https://raw.githubusercontent.com/moby/moby/v20.10.21/README.md /\n`\n\n\tdir, err := integration.Tmpdir(\n\t\tt,\n\t\tfstest.CreateFile(\"Dockerfile\", []byte(dockerfile), 0600),\n\t)\n\trequire.NoError(t, err)\n\n\tc, err := client.New(sb.Context(), sb.Address())\n\trequire.NoError(t, err)\n\tdefer c.Close()\n\n\tplatforms := []string{\"linux/amd64\", \"linux/arm64\"}\n\n\tres, err := f.Solve(sb.Context(), c, client.SolveOpt{\n\t\tFrontendAttrs: map[string]string{\n\t\t\t\"build-arg:foo\": \"bar\",\n\t\t\t\"platform\":      strings.Join(platforms, \",\"),\n\t\t},\n\t\tExports: []client.ExportEntry{\n\t\t\t{\n\t\t\t\tType:   client.ExporterOCI,\n\t\t\t\tOutput: fixedWriteCloser(nopWriteCloser{io.Discard}),\n\t\t\t},\n\t\t},\n\t\tLocalDirs: map[string]string{\n\t\t\tdockerui.DefaultLocalNameDockerfile: dir,\n\t\t\tdockerui.DefaultLocalNameContext:    dir,\n\t\t},\n\t}, nil)\n\trequire.NoError(t, err)\n\n\tfor _, platform := range platforms {\n\t\trequire.Contains(t, res.ExporterResponse, fmt.Sprintf(\"%s/%s\", exptypes.ExporterBuildInfo, platform))\n\t\tdtbi, err := base64.StdEncoding.DecodeString(res.ExporterResponse[fmt.Sprintf(\"%s/%s\", exptypes.ExporterBuildInfo, platform)])\n\t\trequire.NoError(t, err)\n\n\t\tvar bi binfotypes.BuildInfo\n\t\terr = json.Unmarshal(dtbi, &bi)\n\t\trequire.NoError(t, err)\n\n\t\trequire.Contains(t, bi.Attrs, \"build-arg:foo\")\n\t\trequire.Equal(t, \"bar\", *bi.Attrs[\"build-arg:foo\"])\n\n\t\t_, isGateway := f.(*gatewayFrontend)\n\n\t\tsources := bi.Sources\n\t\tif isGateway {\n\t\t\trequire.Equal(t, 3, len(sources), \"%+v\", sources)\n\t\t\tsources = sources[1:]\n\t\t}\n\t\trequire.Equal(t, 2, len(sources), \"%+v\", sources)\n\n\t\tassert.Equal(t, binfotypes.SourceTypeDockerImage, sources[0].Type)\n\t\tassert.Equal(t, \"docker.io/library/busybox:latest\", sources[0].Ref)\n\t\tassert.NotEmpty(t, sources[0].Pin)\n\n\t\tassert.Equal(t, binfotypes.SourceTypeHTTP, sources[1].Type)\n\t\tassert.Equal(t, \"https://raw.githubusercontent.com/moby/moby/v20.10.21/README.md\", sources[1].Ref)\n\t\tassert.Equal(t, \"sha256:419455202b0ef97e480d7f8199b26a721a417818bc0e2d106975f74323f25e6c\", sources[1].Pin)\n\t}\n}\n\nfunc testBuildInfoImageContext(t *testing.T, sb integration.Sandbox) {\n\tf := getFrontend(t, sb)\n\tf.RequiresBuildctl(t)\n\n\tdockerfile := `\nFROM busybox AS base\nRUN cat /etc/alpine-release > /out\nFROM scratch\nCOPY --from=base /out /\n`\n\n\tdir, err := integration.Tmpdir(\n\t\tt,\n\t\tfstest.CreateFile(\"Dockerfile\", []byte(dockerfile), 0600),\n\t)\n\trequire.NoError(t, err)\n\n\tc, err := client.New(sb.Context(), sb.Address())\n\trequire.NoError(t, err)\n\tdefer c.Close()\n\n\tvar exports []client.ExportEntry\n\tif integration.IsTestDockerdMoby(sb) {\n\t\texports = []client.ExportEntry{{\n\t\t\tType: \"moby\",\n\t\t\tAttrs: map[string]string{\n\t\t\t\t\"name\": \"reg.dummy:5000/buildkit/test:latest\",\n\t\t\t},\n\t\t}}\n\t} else {\n\t\texports = []client.ExportEntry{{\n\t\t\tType:   client.ExporterOCI,\n\t\t\tAttrs:  map[string]string{},\n\t\t\tOutput: fixedWriteCloser(nopWriteCloser{io.Discard}),\n\t\t}}\n\t}\n\n\tres, err := f.Solve(sb.Context(), c, client.SolveOpt{\n\t\tFrontendAttrs: map[string]string{\n\t\t\t\"build-arg:foo\":   \"bar\",\n\t\t\t\"context:busybox\": \"docker-image://alpine\",\n\t\t},\n\t\tExports: exports,\n\t\tLocalDirs: map[string]string{\n\t\t\tdockerui.DefaultLocalNameDockerfile: dir,\n\t\t\tdockerui.DefaultLocalNameContext:    dir,\n\t\t},\n\t}, nil)\n\trequire.NoError(t, err)\n\n\trequire.Contains(t, res.ExporterResponse, exptypes.ExporterBuildInfo)\n\tdtbi, err := base64.StdEncoding.DecodeString(res.ExporterResponse[exptypes.ExporterBuildInfo])\n\trequire.NoError(t, err)\n\n\tvar bi binfotypes.BuildInfo\n\terr = json.Unmarshal(dtbi, &bi)\n\trequire.NoError(t, err)\n\n\trequire.Contains(t, bi.Attrs, \"context:busybox\")\n\trequire.Equal(t, \"docker-image://alpine\", *bi.Attrs[\"context:busybox\"])\n\trequire.Contains(t, bi.Attrs, \"build-arg:foo\")\n\trequire.Equal(t, \"bar\", *bi.Attrs[\"build-arg:foo\"])\n\n\t_, isGateway := f.(*gatewayFrontend)\n\n\tsources := bi.Sources\n\tif isGateway {\n\t\trequire.Equal(t, 2, len(sources), \"%+v\", sources)\n\t\tsources = sources[1:]\n\t} else {\n\t\trequire.Equal(t, 1, len(sources))\n\t}\n\tassert.Equal(t, binfotypes.SourceTypeDockerImage, sources[0].Type)\n\tassert.Equal(t, \"docker.io/library/alpine:latest\", sources[0].Ref)\n\tassert.NotEmpty(t, sources[0].Pin)\n}\n\nfunc testBuildInfoLocalContext(t *testing.T, sb integration.Sandbox) {\n\tf := getFrontend(t, sb)\n\tf.RequiresBuildctl(t)\n\n\tdockerfile := `\nFROM busybox AS base\nRUN cat /etc/alpine-release > /out\nFROM scratch\nCOPY --from=base /o* /\n`\n\n\tdir, err := integration.Tmpdir(\n\t\tt,\n\t\tfstest.CreateFile(\"Dockerfile\", []byte(dockerfile), 0600),\n\t)\n\trequire.NoError(t, err)\n\n\tc, err := client.New(sb.Context(), sb.Address())\n\trequire.NoError(t, err)\n\tdefer c.Close()\n\n\toutf := []byte(`dummy-result`)\n\n\tdir2, err := integration.Tmpdir(\n\t\tt,\n\t\tfstest.CreateFile(\"out\", outf, 0600),\n\t\tfstest.CreateFile(\"out2\", outf, 0600),\n\t\tfstest.CreateFile(\".dockerignore\", []byte(\"out2\\n\"), 0600),\n\t)\n\trequire.NoError(t, err)\n\n\tvar exports []client.ExportEntry\n\tif integration.IsTestDockerdMoby(sb) {\n\t\texports = []client.ExportEntry{{\n\t\t\tType: \"moby\",\n\t\t\tAttrs: map[string]string{\n\t\t\t\t\"name\": \"reg.dummy:5000/buildkit/test:latest\",\n\t\t\t},\n\t\t}}\n\t} else {\n\t\texports = []client.ExportEntry{{\n\t\t\tType:   client.ExporterOCI,\n\t\t\tAttrs:  map[string]string{},\n\t\t\tOutput: fixedWriteCloser(nopWriteCloser{io.Discard}),\n\t\t}}\n\t}\n\n\tres, err := f.Solve(sb.Context(), c, client.SolveOpt{\n\t\tFrontendAttrs: map[string]string{\n\t\t\t\"build-arg:foo\": \"bar\",\n\t\t\t\"context:base\":  \"local:basedir\",\n\t\t},\n\t\tExports: exports,\n\t\tLocalDirs: map[string]string{\n\t\t\tdockerui.DefaultLocalNameDockerfile: dir,\n\t\t\tdockerui.DefaultLocalNameContext:    dir,\n\t\t\t\"basedir\":                           dir2,\n\t\t},\n\t}, nil)\n\trequire.NoError(t, err)\n\n\trequire.Contains(t, res.ExporterResponse, exptypes.ExporterBuildInfo)\n\tdtbi, err := base64.StdEncoding.DecodeString(res.ExporterResponse[exptypes.ExporterBuildInfo])\n\trequire.NoError(t, err)\n\n\tvar bi binfotypes.BuildInfo\n\terr = json.Unmarshal(dtbi, &bi)\n\trequire.NoError(t, err)\n\n\trequire.Contains(t, bi.Attrs, \"context:base\")\n\trequire.Equal(t, \"local:basedir\", *bi.Attrs[\"context:base\"])\n\trequire.Contains(t, bi.Attrs, \"build-arg:foo\")\n\trequire.Equal(t, \"bar\", *bi.Attrs[\"build-arg:foo\"])\n\n\t_, isGateway := f.(*gatewayFrontend)\n\tif isGateway {\n\t\trequire.Equal(t, 1, len(bi.Sources))\n\t} else {\n\t\trequire.Equal(t, 0, len(bi.Sources))\n\t}\n}\n\nfunc testBuildInfoDeps(t *testing.T, sb integration.Sandbox) {\n\tt.Skip(\"deps temporarily disabled with SLSA provenance support\")\n\n\tctx := sb.Context()\n\tf := getFrontend(t, sb)\n\tf.RequiresBuildctl(t)\n\n\tc, err := client.New(ctx, sb.Address())\n\trequire.NoError(t, err)\n\tdefer c.Close()\n\n\tdockerfile := []byte(`\nFROM alpine\nENV FOO=bar\nADD https://raw.githubusercontent.com/moby/moby/v20.10.21/README.md /\nRUN echo first > /out\n`)\n\n\tdir, err := integration.Tmpdir(\n\t\tt,\n\t\tfstest.CreateFile(\"Dockerfile\", dockerfile, 0600),\n\t)\n\trequire.NoError(t, err)\n\n\tdockerfile2 := []byte(`\nFROM base AS build\nRUN echo \"foo is $FOO\" > /foo\nFROM busybox\nCOPY --from=build /foo /out /\n`)\n\n\tdir2, err := integration.Tmpdir(\n\t\tt,\n\t\tfstest.CreateFile(\"Dockerfile\", dockerfile2, 0600),\n\t)\n\trequire.NoError(t, err)\n\n\tb := func(ctx context.Context, c gateway.Client) (*gateway.Result, error) {\n\t\tres, err := f.SolveGateway(ctx, c, gateway.SolveRequest{})\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tref, err := res.SingleRef()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tst, err := ref.ToState()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tdef, err := st.Marshal(ctx)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tdtic, ok := res.Metadata[exptypes.ExporterImageConfigKey]\n\t\tif !ok {\n\t\t\treturn nil, errors.Errorf(\"no containerimage.config in metadata\")\n\t\t}\n\n\t\tdtbi, ok := res.Metadata[exptypes.ExporterBuildInfo]\n\t\tif !ok {\n\t\t\treturn nil, errors.Errorf(\"no containerimage.buildinfo in metadata\")\n\t\t}\n\n\t\tdt, err := json.Marshal(map[string][]byte{\n\t\t\texptypes.ExporterImageConfigKey: dtic,\n\t\t\texptypes.ExporterBuildInfo:      dtbi,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tres, err = f.SolveGateway(ctx, c, gateway.SolveRequest{\n\t\t\tFrontendOpt: map[string]string{\n\t\t\t\t\"dockerfilekey\":       dockerui.DefaultLocalNameDockerfile + \"2\",\n\t\t\t\t\"context:base\":        \"input:base\",\n\t\t\t\t\"input-metadata:base\": string(dt),\n\t\t\t},\n\t\t\tFrontendInputs: map[string]*pb.Definition{\n\t\t\t\t\"base\": def.ToPB(),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn res, nil\n\t}\n\n\tdestDir := t.TempDir()\n\n\tres, err := c.Build(ctx, client.SolveOpt{\n\t\tLocalDirs: map[string]string{\n\t\t\tdockerui.DefaultLocalNameDockerfile:       dir,\n\t\t\tdockerui.DefaultLocalNameContext:          dir,\n\t\t\tdockerui.DefaultLocalNameDockerfile + \"2\": dir2,\n\t\t},\n\t\tExports: []client.ExportEntry{\n\t\t\t{\n\t\t\t\tType:      client.ExporterLocal,\n\t\t\t\tOutputDir: destDir,\n\t\t\t},\n\t\t},\n\t}, \"\", b, nil)\n\trequire.NoError(t, err)\n\n\trequire.Contains(t, res.ExporterResponse, exptypes.ExporterBuildInfo)\n\tdtbi, err := base64.StdEncoding.DecodeString(res.ExporterResponse[exptypes.ExporterBuildInfo])\n\trequire.NoError(t, err)\n\n\tvar bi binfotypes.BuildInfo\n\terr = json.Unmarshal(dtbi, &bi)\n\trequire.NoError(t, err)\n\n\trequire.Contains(t, bi.Attrs, \"context:base\")\n\trequire.Equal(t, \"input:base\", *bi.Attrs[\"context:base\"])\n\n\trequire.Equal(t, 2, len(bi.Sources))\n\n\tassert.Equal(t, binfotypes.SourceTypeDockerImage, bi.Sources[0].Type)\n\tassert.Equal(t, \"docker.io/library/busybox:latest\", bi.Sources[0].Ref)\n\tassert.NotEmpty(t, bi.Sources[0].Pin)\n\n\tassert.Equal(t, binfotypes.SourceTypeHTTP, bi.Sources[1].Type)\n\tassert.Equal(t, \"https://raw.githubusercontent.com/moby/moby/v20.10.21/README.md\", bi.Sources[1].Ref)\n\tassert.Equal(t, \"sha256:419455202b0ef97e480d7f8199b26a721a417818bc0e2d106975f74323f25e6c\", bi.Sources[1].Pin)\n\n\trequire.Contains(t, bi.Deps, \"base\")\n\tdepsrc := bi.Deps[\"base\"].Sources\n\trequire.Equal(t, 1, len(depsrc))\n\tassert.Equal(t, binfotypes.SourceTypeDockerImage, depsrc[0].Type)\n\tassert.Equal(t, \"docker.io/library/alpine:latest\", depsrc[0].Ref)\n\tassert.NotEmpty(t, depsrc[0].Pin)\n}\n\nfunc testBuildInfoDepsMultiPlatform(t *testing.T, sb integration.Sandbox) {\n\tt.Skip(\"deps temporarily disabled with SLSA provenance support\")\n\n\tctx := sb.Context()\n\tf := getFrontend(t, sb)\n\tf.RequiresBuildctl(t)\n\n\tplatforms := []string{\"linux/amd64\", \"linux/arm64\"}\n\n\tc, err := client.New(ctx, sb.Address())\n\trequire.NoError(t, err)\n\tdefer c.Close()\n\n\tdockerfile := []byte(`\nFROM --platform=$BUILDPLATFORM alpine\nARG TARGETARCH\nENV FOO=bar-$TARGETARCH\nRUN echo \"foo $TARGETARCH\" > /out\n`)\n\n\tdir, err := integration.Tmpdir(\n\t\tt,\n\t\tfstest.CreateFile(\"Dockerfile\", dockerfile, 0600),\n\t)\n\trequire.NoError(t, err)\n\n\tdockerfile2 := []byte(`\nFROM base AS build\nRUN echo \"foo is $FOO\" > /foo\nFROM busybox\nCOPY --from=build /foo /out /\n`)\n\n\tdir2, err := integration.Tmpdir(\n\t\tt,\n\t\tfstest.CreateFile(\"Dockerfile\", dockerfile2, 0600),\n\t)\n\trequire.NoError(t, err)\n\n\tb := func(ctx context.Context, c gateway.Client) (*gateway.Result, error) {\n\t\tres, err := f.SolveGateway(ctx, c, gateway.SolveRequest{\n\t\t\tFrontendOpt: map[string]string{\n\t\t\t\t\"platform\": strings.Join(platforms, \",\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tif len(res.Refs) != 2 {\n\t\t\treturn nil, errors.Errorf(\"expected 2 refs, got %d\", len(res.Refs))\n\t\t}\n\n\t\tfrontendOpt := map[string]string{\n\t\t\t\"dockerfilekey\": dockerui.DefaultLocalNameDockerfile + \"2\",\n\t\t\t\"platform\":      strings.Join(platforms, \",\"),\n\t\t}\n\n\t\tinputs := map[string]*pb.Definition{}\n\t\tfor _, platform := range platforms {\n\t\t\tfrontendOpt[\"context:base::\"+platform] = \"input:base::\" + platform\n\n\t\t\tst, err := res.Refs[platform].ToState()\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tdef, err := st.Marshal(ctx)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tinputs[\"base::\"+platform] = def.ToPB()\n\n\t\t\tdtic, ok := res.Metadata[exptypes.ExporterImageConfigKey+\"/\"+platform]\n\t\t\tif !ok {\n\t\t\t\treturn nil, errors.Errorf(\"no containerimage.config/\" + platform + \" in metadata\")\n\t\t\t}\n\t\t\tdtbi, ok := res.Metadata[exptypes.ExporterBuildInfo+\"/\"+platform]\n\t\t\tif !ok {\n\t\t\t\treturn nil, errors.Errorf(\"no containerimage.buildinfo/\" + platform + \" in metadata\")\n\t\t\t}\n\t\t\tdt, err := json.Marshal(map[string][]byte{\n\t\t\t\texptypes.ExporterImageConfigKey: dtic,\n\t\t\t\texptypes.ExporterBuildInfo:      dtbi,\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tfrontendOpt[\"input-metadata:base::\"+platform] = string(dt)\n\t\t}\n\n\t\tres, err = f.SolveGateway(ctx, c, gateway.SolveRequest{\n\t\t\tFrontendOpt:    frontendOpt,\n\t\t\tFrontendInputs: inputs,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn res, nil\n\t}\n\n\tdestDir := t.TempDir()\n\n\tres, err := c.Build(ctx, client.SolveOpt{\n\t\tLocalDirs: map[string]string{\n\t\t\tdockerui.DefaultLocalNameDockerfile:       dir,\n\t\t\tdockerui.DefaultLocalNameContext:          dir,\n\t\t\tdockerui.DefaultLocalNameDockerfile + \"2\": dir2,\n\t\t},\n\t\tExports: []client.ExportEntry{\n\t\t\t{\n\t\t\t\tType:      client.ExporterLocal,\n\t\t\t\tOutputDir: destDir,\n\t\t\t},\n\t\t},\n\t}, \"\", b, nil)\n\trequire.NoError(t, err)\n\n\tfor _, platform := range platforms {\n\t\trequire.Contains(t, res.ExporterResponse, fmt.Sprintf(\"%s/%s\", exptypes.ExporterBuildInfo, platform))\n\t\tdtbi, err := base64.StdEncoding.DecodeString(res.ExporterResponse[fmt.Sprintf(\"%s/%s\", exptypes.ExporterBuildInfo, platform)])\n\t\trequire.NoError(t, err)\n\n\t\tvar bi binfotypes.BuildInfo\n\t\terr = json.Unmarshal(dtbi, &bi)\n\t\trequire.NoError(t, err)\n\n\t\trequire.Contains(t, bi.Attrs, \"context:base\")\n\t\trequire.Equal(t, \"input:base\", *bi.Attrs[\"context:base\"])\n\n\t\trequire.Equal(t, 1, len(bi.Sources))\n\t\tassert.Equal(t, binfotypes.SourceTypeDockerImage, bi.Sources[0].Type)\n\t\tassert.Equal(t, \"docker.io/library/busybox:latest\", bi.Sources[0].Ref)\n\t\tassert.NotEmpty(t, bi.Sources[0].Pin)\n\n\t\trequire.Contains(t, bi.Deps, \"base\")\n\t\tdepsrc := bi.Deps[\"base\"].Sources\n\t\trequire.Equal(t, 1, len(depsrc))\n\t\tassert.Equal(t, binfotypes.SourceTypeDockerImage, depsrc[0].Type)\n\t\tassert.Equal(t, \"docker.io/library/alpine:latest\", depsrc[0].Ref)\n\t\tassert.NotEmpty(t, depsrc[0].Pin)\n\t}\n}\n\nfunc testBuildInfoDepsMainNoSource(t *testing.T, sb integration.Sandbox) {\n\tt.Skip(\"deps temporarily disabled with SLSA provenance support\")\n\n\tctx := sb.Context()\n\tf := getFrontend(t, sb)\n\tf.RequiresBuildctl(t)\n\n\tc, err := client.New(ctx, sb.Address())\n\trequire.NoError(t, err)\n\tdefer c.Close()\n\n\tdockerfile := []byte(`\nFROM alpine\nENV FOO=bar\nADD https://raw.githubusercontent.com/moby/moby/v20.10.21/README.md /\nRUN echo first > /out\n`)\n\n\tdir, err := integration.Tmpdir(\n\t\tt,\n\t\tfstest.CreateFile(\"Dockerfile\", dockerfile, 0600),\n\t)\n\trequire.NoError(t, err)\n\n\tdockerfile2 := []byte(`\nFROM base AS build\nRUN echo \"foo is $FOO\" > /foo\n`)\n\n\tdir2, err := integration.Tmpdir(\n\t\tt,\n\t\tfstest.CreateFile(\"Dockerfile\", dockerfile2, 0600),\n\t)\n\trequire.NoError(t, err)\n\n\tb := func(ctx context.Context, c gateway.Client) (*gateway.Result, error) {\n\t\tres, err := f.SolveGateway(ctx, c, gateway.SolveRequest{})\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tref, err := res.SingleRef()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tst, err := ref.ToState()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tdef, err := st.Marshal(ctx)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tdtic, ok := res.Metadata[exptypes.ExporterImageConfigKey]\n\t\tif !ok {\n\t\t\treturn nil, errors.Errorf(\"no containerimage.config in metadata\")\n\t\t}\n\n\t\tdtbi, ok := res.Metadata[exptypes.ExporterBuildInfo]\n\t\tif !ok {\n\t\t\treturn nil, errors.Errorf(\"no containerimage.buildinfo in metadata\")\n\t\t}\n\n\t\tdt, err := json.Marshal(map[string][]byte{\n\t\t\texptypes.ExporterImageConfigKey: dtic,\n\t\t\texptypes.ExporterBuildInfo:      dtbi,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tres, err = f.SolveGateway(ctx, c, gateway.SolveRequest{\n\t\t\tFrontendOpt: map[string]string{\n\t\t\t\t\"dockerfilekey\":       dockerui.DefaultLocalNameDockerfile + \"2\",\n\t\t\t\t\"context:base\":        \"input:base\",\n\t\t\t\t\"input-metadata:base\": string(dt),\n\t\t\t},\n\t\t\tFrontendInputs: map[string]*pb.Definition{\n\t\t\t\t\"base\": def.ToPB(),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn res, nil\n\t}\n\n\tdestDir := t.TempDir()\n\n\tres, err := c.Build(ctx, client.SolveOpt{\n\t\tLocalDirs: map[string]string{\n\t\t\tdockerui.DefaultLocalNameDockerfile:       dir,\n\t\t\tdockerui.DefaultLocalNameContext:          dir,\n\t\t\tdockerui.DefaultLocalNameDockerfile + \"2\": dir2,\n\t\t},\n\t\tExports: []client.ExportEntry{\n\t\t\t{\n\t\t\t\tType:      client.ExporterLocal,\n\t\t\t\tOutputDir: destDir,\n\t\t\t},\n\t\t},\n\t}, \"\", b, nil)\n\trequire.NoError(t, err)\n\n\trequire.Contains(t, res.ExporterResponse, exptypes.ExporterBuildInfo)\n\tdtbi, err := base64.StdEncoding.DecodeString(res.ExporterResponse[exptypes.ExporterBuildInfo])\n\trequire.NoError(t, err)\n\n\tvar bi binfotypes.BuildInfo\n\terr = json.Unmarshal(dtbi, &bi)\n\trequire.NoError(t, err)\n\n\trequire.Contains(t, bi.Attrs, \"context:base\")\n\trequire.Equal(t, \"input:base\", *bi.Attrs[\"context:base\"])\n\n\trequire.Equal(t, 1, len(bi.Sources))\n\n\tassert.Equal(t, binfotypes.SourceTypeHTTP, bi.Sources[0].Type)\n\tassert.Equal(t, \"https://raw.githubusercontent.com/moby/moby/v20.10.21/README.md\", bi.Sources[0].Ref)\n\tassert.Equal(t, \"sha256:419455202b0ef97e480d7f8199b26a721a417818bc0e2d106975f74323f25e6c\", bi.Sources[0].Pin)\n\n\trequire.Contains(t, bi.Deps, \"base\")\n\tdepsrc := bi.Deps[\"base\"].Sources\n\trequire.Equal(t, 1, len(depsrc))\n\tassert.Equal(t, binfotypes.SourceTypeDockerImage, depsrc[0].Type)\n\tassert.Equal(t, \"docker.io/library/alpine:latest\", depsrc[0].Ref)\n\tassert.NotEmpty(t, depsrc[0].Pin)\n}\n", "package dockerfile\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"net/url\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/containerd/containerd/platforms\"\n\t\"github.com/containerd/continuity/fs/fstest\"\n\tintoto \"github.com/in-toto/in-toto-golang/in_toto\"\n\t\"github.com/moby/buildkit/client\"\n\t\"github.com/moby/buildkit/client/llb\"\n\t\"github.com/moby/buildkit/exporter/containerimage/exptypes\"\n\t\"github.com/moby/buildkit/frontend/dockerui\"\n\tgateway \"github.com/moby/buildkit/frontend/gateway/client\"\n\t\"github.com/moby/buildkit/solver/llbsolver/provenance\"\n\t\"github.com/moby/buildkit/util/contentutil\"\n\t\"github.com/moby/buildkit/util/testutil\"\n\t\"github.com/moby/buildkit/util/testutil/integration\"\n\tocispecs \"github.com/opencontainers/image-spec/specs-go/v1\"\n\t\"github.com/pkg/errors\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc testProvenanceAttestation(t *testing.T, sb integration.Sandbox) {\n\tintegration.CheckFeatureCompat(t, sb, integration.FeatureDirectPush, integration.FeatureProvenance)\n\tctx := sb.Context()\n\n\tc, err := client.New(ctx, sb.Address())\n\trequire.NoError(t, err)\n\tdefer c.Close()\n\n\tregistry, err := sb.NewRegistry()\n\tif errors.Is(err, integration.ErrRequirements) {\n\t\tt.Skip(err.Error())\n\t}\n\trequire.NoError(t, err)\n\n\tf := getFrontend(t, sb)\n\n\tdockerfile := []byte(`\nFROM busybox:latest\nRUN echo \"ok\" > /foo\n`)\n\tdir, err := integration.Tmpdir(\n\t\tt,\n\t\tfstest.CreateFile(\"Dockerfile\", dockerfile, 0600),\n\t)\n\trequire.NoError(t, err)\n\n\tfor _, mode := range []string{\"\", \"min\", \"max\"} {\n\t\tt.Run(mode, func(t *testing.T) {\n\t\t\tvar target string\n\t\t\tif target == \"\" {\n\t\t\t\ttarget = registry + \"/buildkit/testwithprovenance:none\"\n\t\t\t} else {\n\t\t\t\ttarget = registry + \"/buildkit/testwithprovenance:\" + mode\n\t\t\t}\n\n\t\t\tprovReq := \"\"\n\t\t\tif mode != \"\" {\n\t\t\t\tprovReq = \"mode=\" + mode\n\t\t\t}\n\t\t\t_, err = f.Solve(sb.Context(), c, client.SolveOpt{\n\t\t\t\tLocalDirs: map[string]string{\n\t\t\t\t\tdockerui.DefaultLocalNameDockerfile: dir,\n\t\t\t\t\tdockerui.DefaultLocalNameContext:    dir,\n\t\t\t\t},\n\t\t\t\tFrontendAttrs: map[string]string{\n\t\t\t\t\t\"attest:provenance\": provReq,\n\t\t\t\t\t\"build-arg:FOO\":     \"bar\",\n\t\t\t\t\t\"label:lbl\":         \"abc\",\n\t\t\t\t\t\"vcs:source\":        \"https://user:pass@example.invalid/repo.git\",\n\t\t\t\t\t\"vcs:revision\":      \"123456\",\n\t\t\t\t\t\"filename\":          \"Dockerfile\",\n\t\t\t\t\tdockerui.DefaultLocalNameContext + \":foo\": \"https://foo:bar@example.invalid/foo.html\",\n\t\t\t\t},\n\t\t\t\tExports: []client.ExportEntry{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: client.ExporterImage,\n\t\t\t\t\t\tAttrs: map[string]string{\n\t\t\t\t\t\t\t\"name\": target,\n\t\t\t\t\t\t\t\"push\": \"true\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}, nil)\n\t\t\trequire.NoError(t, err)\n\n\t\t\tdesc, provider, err := contentutil.ProviderFromRef(target)\n\t\t\trequire.NoError(t, err)\n\t\t\timgs, err := testutil.ReadImages(sb.Context(), provider, desc)\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.Equal(t, 2, len(imgs.Images))\n\n\t\t\timg := imgs.Find(platforms.Format(platforms.Normalize(platforms.DefaultSpec())))\n\t\t\trequire.NotNil(t, img)\n\t\t\trequire.Equal(t, []byte(\"ok\\n\"), img.Layers[1][\"foo\"].Data)\n\n\t\t\tatt := imgs.Find(\"unknown/unknown\")\n\t\t\trequire.NotNil(t, att)\n\t\t\trequire.Equal(t, att.Desc.Annotations[\"vnd.docker.reference.digest\"], string(img.Desc.Digest))\n\t\t\trequire.Equal(t, att.Desc.Annotations[\"vnd.docker.reference.type\"], \"attestation-manifest\")\n\t\t\tvar attest intoto.Statement\n\t\t\trequire.NoError(t, json.Unmarshal(att.LayersRaw[0], &attest))\n\t\t\trequire.Equal(t, \"https://in-toto.io/Statement/v0.1\", attest.Type)\n\t\t\trequire.Equal(t, \"https://slsa.dev/provenance/v0.2\", attest.PredicateType) // intentionally not const\n\n\t\t\ttype stmtT struct {\n\t\t\t\tPredicate provenance.ProvenancePredicate `json:\"predicate\"`\n\t\t\t}\n\t\t\tvar stmt stmtT\n\t\t\trequire.NoError(t, json.Unmarshal(att.LayersRaw[0], &stmt))\n\t\t\tpred := stmt.Predicate\n\n\t\t\trequire.Equal(t, \"https://mobyproject.org/buildkit@v1\", pred.BuildType)\n\t\t\trequire.Equal(t, \"\", pred.Builder.ID)\n\n\t\t\trequire.Equal(t, \"\", pred.Invocation.ConfigSource.URI)\n\n\t\t\t_, isClient := f.(*clientFrontend)\n\t\t\t_, isGateway := f.(*gatewayFrontend)\n\n\t\t\targs := pred.Invocation.Parameters.Args\n\t\t\tif isClient {\n\t\t\t\trequire.Equal(t, \"\", pred.Invocation.Parameters.Frontend)\n\t\t\t\trequire.Equal(t, 0, len(args), \"%v\", args)\n\t\t\t\trequire.False(t, pred.Metadata.Completeness.Parameters)\n\t\t\t\trequire.Equal(t, \"\", pred.Invocation.ConfigSource.EntryPoint)\n\t\t\t} else if isGateway {\n\t\t\t\trequire.Equal(t, \"gateway.v0\", pred.Invocation.Parameters.Frontend)\n\n\t\t\t\tif mode == \"max\" || mode == \"\" {\n\t\t\t\t\trequire.Equal(t, 4, len(args), \"%v\", args)\n\t\t\t\t\trequire.True(t, pred.Metadata.Completeness.Parameters)\n\n\t\t\t\t\trequire.Equal(t, \"bar\", args[\"build-arg:FOO\"])\n\t\t\t\t\trequire.Equal(t, \"abc\", args[\"label:lbl\"])\n\t\t\t\t\trequire.Contains(t, args[\"source\"], \"buildkit_test/\")\n\t\t\t\t} else {\n\t\t\t\t\trequire.False(t, pred.Metadata.Completeness.Parameters)\n\t\t\t\t\trequire.Equal(t, 2, len(args), \"%v\", args)\n\t\t\t\t\trequire.Contains(t, args[\"source\"], \"buildkit_test/\")\n\t\t\t\t}\n\t\t\t\trequire.Equal(t, \"https://xxxxx:xxxxx@example.invalid/foo.html\", args[\"context:foo\"])\n\t\t\t} else {\n\t\t\t\trequire.Equal(t, \"dockerfile.v0\", pred.Invocation.Parameters.Frontend)\n\n\t\t\t\tif mode == \"max\" || mode == \"\" {\n\t\t\t\t\trequire.Equal(t, 3, len(args))\n\t\t\t\t\trequire.True(t, pred.Metadata.Completeness.Parameters)\n\n\t\t\t\t\trequire.Equal(t, \"bar\", args[\"build-arg:FOO\"])\n\t\t\t\t\trequire.Equal(t, \"abc\", args[\"label:lbl\"])\n\t\t\t\t} else {\n\t\t\t\t\trequire.False(t, pred.Metadata.Completeness.Parameters)\n\t\t\t\t\trequire.Equal(t, 1, len(args), \"%v\", args)\n\t\t\t\t}\n\t\t\t\trequire.Equal(t, \"https://xxxxx:xxxxx@example.invalid/foo.html\", args[\"context:foo\"])\n\t\t\t}\n\n\t\t\texpectedBase := \"pkg:docker/busybox@latest?platform=\" + url.PathEscape(platforms.Format(platforms.Normalize(platforms.DefaultSpec())))\n\t\t\tif isGateway {\n\t\t\t\trequire.Equal(t, 2, len(pred.Materials), \"%+v\", pred.Materials)\n\t\t\t\trequire.Contains(t, pred.Materials[0].URI, \"docker/buildkit_test\")\n\t\t\t\trequire.Equal(t, expectedBase, pred.Materials[1].URI)\n\t\t\t\trequire.NotEmpty(t, pred.Materials[1].Digest[\"sha256\"])\n\t\t\t} else {\n\t\t\t\trequire.Equal(t, 1, len(pred.Materials), \"%+v\", pred.Materials)\n\t\t\t\trequire.Equal(t, expectedBase, pred.Materials[0].URI)\n\t\t\t\trequire.NotEmpty(t, pred.Materials[0].Digest[\"sha256\"])\n\t\t\t}\n\n\t\t\tif !isClient {\n\t\t\t\trequire.Equal(t, \"Dockerfile\", pred.Invocation.ConfigSource.EntryPoint)\n\t\t\t\trequire.Equal(t, \"https://xxxxx:xxxxx@example.invalid/repo.git\", pred.Metadata.BuildKitMetadata.VCS[\"source\"])\n\t\t\t\trequire.Equal(t, \"123456\", pred.Metadata.BuildKitMetadata.VCS[\"revision\"])\n\t\t\t}\n\n\t\t\trequire.NotEmpty(t, pred.Metadata.BuildInvocationID)\n\n\t\t\trequire.Equal(t, 2, len(pred.Invocation.Parameters.Locals), \"%+v\", pred.Invocation.Parameters.Locals)\n\t\t\trequire.Equal(t, \"context\", pred.Invocation.Parameters.Locals[0].Name)\n\t\t\trequire.Equal(t, \"dockerfile\", pred.Invocation.Parameters.Locals[1].Name)\n\n\t\t\trequire.NotNil(t, pred.Metadata.BuildFinishedOn)\n\t\t\trequire.True(t, time.Since(*pred.Metadata.BuildFinishedOn) < 5*time.Minute)\n\t\t\trequire.NotNil(t, pred.Metadata.BuildStartedOn)\n\t\t\trequire.True(t, time.Since(*pred.Metadata.BuildStartedOn) < 5*time.Minute)\n\t\t\trequire.True(t, pred.Metadata.BuildStartedOn.Before(*pred.Metadata.BuildFinishedOn))\n\n\t\t\trequire.True(t, pred.Metadata.Completeness.Environment)\n\t\t\trequire.Equal(t, platforms.Format(platforms.Normalize(platforms.DefaultSpec())), pred.Invocation.Environment.Platform)\n\n\t\t\trequire.False(t, pred.Metadata.Completeness.Materials)\n\t\t\trequire.False(t, pred.Metadata.Reproducible)\n\t\t\trequire.False(t, pred.Metadata.Hermetic)\n\n\t\t\tif mode == \"max\" || mode == \"\" {\n\t\t\t\trequire.Equal(t, 2, len(pred.Metadata.BuildKitMetadata.Layers))\n\t\t\t\trequire.NotNil(t, pred.Metadata.BuildKitMetadata.Source)\n\t\t\t\trequire.Equal(t, \"Dockerfile\", pred.Metadata.BuildKitMetadata.Source.Infos[0].Filename)\n\t\t\t\trequire.Equal(t, dockerfile, pred.Metadata.BuildKitMetadata.Source.Infos[0].Data)\n\t\t\t\trequire.NotNil(t, pred.BuildConfig)\n\n\t\t\t\trequire.Equal(t, 3, len(pred.BuildConfig.Definition))\n\t\t\t} else {\n\t\t\t\trequire.Equal(t, 0, len(pred.Metadata.BuildKitMetadata.Layers))\n\t\t\t\trequire.Nil(t, pred.Metadata.BuildKitMetadata.Source)\n\t\t\t\trequire.Nil(t, pred.BuildConfig)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc testGitProvenanceAttestation(t *testing.T, sb integration.Sandbox) {\n\tintegration.CheckFeatureCompat(t, sb, integration.FeatureDirectPush, integration.FeatureProvenance)\n\tctx := sb.Context()\n\n\tc, err := client.New(ctx, sb.Address())\n\trequire.NoError(t, err)\n\tdefer c.Close()\n\n\tregistry, err := sb.NewRegistry()\n\tif errors.Is(err, integration.ErrRequirements) {\n\t\tt.Skip(err.Error())\n\t}\n\trequire.NoError(t, err)\n\n\tf := getFrontend(t, sb)\n\n\tdockerfile := []byte(`\nFROM busybox:latest\nRUN --network=none echo \"git\" > /foo\nCOPY myapp.Dockerfile /\n`)\n\tdir, err := integration.Tmpdir(\n\t\tt,\n\t\tfstest.CreateFile(\"myapp.Dockerfile\", dockerfile, 0600),\n\t)\n\trequire.NoError(t, err)\n\n\terr = runShell(dir,\n\t\t\"git init\",\n\t\t\"git config --local user.email test\",\n\t\t\"git config --local user.name test\",\n\t\t\"git add myapp.Dockerfile\",\n\t\t\"git commit -m initial\",\n\t\t\"git branch v1\",\n\t\t\"git update-server-info\",\n\t)\n\trequire.NoError(t, err)\n\n\tcmd := exec.Command(\"git\", \"rev-parse\", \"v1\")\n\tcmd.Dir = dir\n\texpectedGitSHA, err := cmd.Output()\n\trequire.NoError(t, err)\n\n\tserver := httptest.NewServer(http.FileServer(http.Dir(filepath.Join(dir))))\n\tdefer server.Close()\n\n\ttarget := registry + \"/buildkit/testwithprovenance:git\"\n\n\t// inject dummy credentials to test that they are masked\n\texpectedURL := strings.Replace(server.URL, \"http://\", \"http://xxxxx:xxxxx@\", 1)\n\trequire.NotEqual(t, expectedURL, server.URL)\n\tserver.URL = strings.Replace(server.URL, \"http://\", \"http://user:pass@\", 1)\n\n\t_, err = f.Solve(sb.Context(), c, client.SolveOpt{\n\t\tFrontendAttrs: map[string]string{\n\t\t\t\"context\":           server.URL + \"/.git#v1\",\n\t\t\t\"attest:provenance\": \"\",\n\t\t\t\"filename\":          \"myapp.Dockerfile\",\n\t\t},\n\t\tExports: []client.ExportEntry{\n\t\t\t{\n\t\t\t\tType: client.ExporterImage,\n\t\t\t\tAttrs: map[string]string{\n\t\t\t\t\t\"name\": target,\n\t\t\t\t\t\"push\": \"true\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}, nil)\n\trequire.NoError(t, err)\n\n\tdesc, provider, err := contentutil.ProviderFromRef(target)\n\trequire.NoError(t, err)\n\timgs, err := testutil.ReadImages(sb.Context(), provider, desc)\n\trequire.NoError(t, err)\n\trequire.Equal(t, 2, len(imgs.Images))\n\n\timg := imgs.Find(platforms.Format(platforms.Normalize(platforms.DefaultSpec())))\n\trequire.NotNil(t, img)\n\trequire.Equal(t, []byte(\"git\\n\"), img.Layers[1][\"foo\"].Data)\n\n\tatt := imgs.Find(\"unknown/unknown\")\n\trequire.NotNil(t, att)\n\trequire.Equal(t, att.Desc.Annotations[\"vnd.docker.reference.digest\"], string(img.Desc.Digest))\n\trequire.Equal(t, att.Desc.Annotations[\"vnd.docker.reference.type\"], \"attestation-manifest\")\n\tvar attest intoto.Statement\n\trequire.NoError(t, json.Unmarshal(att.LayersRaw[0], &attest))\n\trequire.Equal(t, \"https://in-toto.io/Statement/v0.1\", attest.Type)\n\trequire.Equal(t, \"https://slsa.dev/provenance/v0.2\", attest.PredicateType) // intentionally not const\n\n\ttype stmtT struct {\n\t\tPredicate provenance.ProvenancePredicate `json:\"predicate\"`\n\t}\n\tvar stmt stmtT\n\trequire.NoError(t, json.Unmarshal(att.LayersRaw[0], &stmt))\n\tpred := stmt.Predicate\n\n\t_, isClient := f.(*clientFrontend)\n\t_, isGateway := f.(*gatewayFrontend)\n\n\tif isClient {\n\t\trequire.Empty(t, pred.Invocation.Parameters.Frontend)\n\t\trequire.Equal(t, \"\", pred.Invocation.ConfigSource.URI)\n\t\trequire.Equal(t, \"\", pred.Invocation.ConfigSource.EntryPoint)\n\t} else {\n\t\trequire.NotEmpty(t, pred.Invocation.Parameters.Frontend)\n\t\trequire.Equal(t, expectedURL+\"/.git#v1\", pred.Invocation.ConfigSource.URI)\n\t\trequire.Equal(t, \"myapp.Dockerfile\", pred.Invocation.ConfigSource.EntryPoint)\n\t}\n\n\texpBase := \"pkg:docker/busybox@latest?platform=\" + url.PathEscape(platforms.Format(platforms.Normalize(platforms.DefaultSpec())))\n\tif isGateway {\n\t\trequire.Equal(t, 3, len(pred.Materials), \"%+v\", pred.Materials)\n\n\t\trequire.Contains(t, pred.Materials[0].URI, \"pkg:docker/buildkit_test/\")\n\t\trequire.NotEmpty(t, pred.Materials[0].Digest)\n\n\t\trequire.Equal(t, expBase, pred.Materials[1].URI)\n\t\trequire.NotEmpty(t, pred.Materials[1].Digest[\"sha256\"])\n\n\t\trequire.Equal(t, expectedURL+\"/.git#v1\", pred.Materials[2].URI)\n\t\trequire.Equal(t, strings.TrimSpace(string(expectedGitSHA)), pred.Materials[2].Digest[\"sha1\"])\n\t} else {\n\t\trequire.Equal(t, 2, len(pred.Materials), \"%+v\", pred.Materials)\n\n\t\trequire.Equal(t, expBase, pred.Materials[0].URI)\n\t\trequire.NotEmpty(t, pred.Materials[0].Digest[\"sha256\"])\n\n\t\trequire.Equal(t, expectedURL+\"/.git#v1\", pred.Materials[1].URI)\n\t\trequire.Equal(t, strings.TrimSpace(string(expectedGitSHA)), pred.Materials[1].Digest[\"sha1\"])\n\t}\n\n\trequire.Equal(t, 0, len(pred.Invocation.Parameters.Locals))\n\n\trequire.True(t, pred.Metadata.Completeness.Materials)\n\trequire.True(t, pred.Metadata.Completeness.Environment)\n\trequire.True(t, pred.Metadata.Hermetic)\n\n\tif isClient {\n\t\trequire.False(t, pred.Metadata.Completeness.Parameters)\n\t} else {\n\t\trequire.True(t, pred.Metadata.Completeness.Parameters)\n\t}\n\trequire.False(t, pred.Metadata.Reproducible)\n\n\trequire.Equal(t, 0, len(pred.Metadata.BuildKitMetadata.VCS), \"%+v\", pred.Metadata.BuildKitMetadata.VCS)\n}\n\nfunc testMultiPlatformProvenance(t *testing.T, sb integration.Sandbox) {\n\tintegration.CheckFeatureCompat(t, sb, integration.FeatureDirectPush, integration.FeatureMultiPlatform, integration.FeatureProvenance)\n\tctx := sb.Context()\n\n\tc, err := client.New(ctx, sb.Address())\n\trequire.NoError(t, err)\n\tdefer c.Close()\n\n\tregistry, err := sb.NewRegistry()\n\tif errors.Is(err, integration.ErrRequirements) {\n\t\tt.Skip(err.Error())\n\t}\n\trequire.NoError(t, err)\n\n\tf := getFrontend(t, sb)\n\n\tdockerfile := []byte(`\nFROM busybox:latest\nARG TARGETARCH\nRUN echo \"ok-$TARGETARCH\" > /foo\n`)\n\tdir, err := integration.Tmpdir(\n\t\tt,\n\t\tfstest.CreateFile(\"Dockerfile\", dockerfile, 0600),\n\t)\n\trequire.NoError(t, err)\n\n\ttarget := registry + \"/buildkit/testmultiprovenance:latest\"\n\n\t_, err = f.Solve(sb.Context(), c, client.SolveOpt{\n\t\tLocalDirs: map[string]string{\n\t\t\tdockerui.DefaultLocalNameDockerfile: dir,\n\t\t\tdockerui.DefaultLocalNameContext:    dir,\n\t\t},\n\t\tFrontendAttrs: map[string]string{\n\t\t\t\"attest:provenance\": \"mode=max\",\n\t\t\t\"build-arg:FOO\":     \"bar\",\n\t\t\t\"label:lbl\":         \"abc\",\n\t\t\t\"platform\":          \"linux/amd64,linux/arm64\",\n\t\t},\n\t\tExports: []client.ExportEntry{\n\t\t\t{\n\t\t\t\tType: client.ExporterImage,\n\t\t\t\tAttrs: map[string]string{\n\t\t\t\t\t\"name\": target,\n\t\t\t\t\t\"push\": \"true\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}, nil)\n\trequire.NoError(t, err)\n\n\tdesc, provider, err := contentutil.ProviderFromRef(target)\n\trequire.NoError(t, err)\n\timgs, err := testutil.ReadImages(sb.Context(), provider, desc)\n\trequire.NoError(t, err)\n\trequire.Equal(t, 4, len(imgs.Images))\n\n\t_, isClient := f.(*clientFrontend)\n\t_, isGateway := f.(*gatewayFrontend)\n\n\tfor _, p := range []string{\"linux/amd64\", \"linux/arm64\"} {\n\t\timg := imgs.Find(p)\n\t\trequire.NotNil(t, img)\n\t\tif p == \"linux/amd64\" {\n\t\t\trequire.Equal(t, []byte(\"ok-amd64\\n\"), img.Layers[1][\"foo\"].Data)\n\t\t} else {\n\t\t\trequire.Equal(t, []byte(\"ok-arm64\\n\"), img.Layers[1][\"foo\"].Data)\n\t\t}\n\n\t\tatt := imgs.FindAttestation(p)\n\t\trequire.NotNil(t, att)\n\t\trequire.Equal(t, att.Desc.Annotations[\"vnd.docker.reference.type\"], \"attestation-manifest\")\n\t\tvar attest intoto.Statement\n\t\trequire.NoError(t, json.Unmarshal(att.LayersRaw[0], &attest))\n\t\trequire.Equal(t, \"https://in-toto.io/Statement/v0.1\", attest.Type)\n\t\trequire.Equal(t, \"https://slsa.dev/provenance/v0.2\", attest.PredicateType) // intentionally not const\n\n\t\ttype stmtT struct {\n\t\t\tPredicate provenance.ProvenancePredicate `json:\"predicate\"`\n\t\t}\n\t\tvar stmt stmtT\n\t\trequire.NoError(t, json.Unmarshal(att.LayersRaw[0], &stmt))\n\t\tpred := stmt.Predicate\n\n\t\trequire.Equal(t, \"https://mobyproject.org/buildkit@v1\", pred.BuildType)\n\t\trequire.Equal(t, \"\", pred.Builder.ID)\n\t\trequire.Equal(t, \"\", pred.Invocation.ConfigSource.URI)\n\n\t\tif isGateway {\n\t\t\trequire.Equal(t, 2, len(pred.Materials), \"%+v\", pred.Materials)\n\t\t\trequire.Contains(t, pred.Materials[0].URI, \"buildkit_test\")\n\t\t\trequire.Contains(t, pred.Materials[1].URI, \"pkg:docker/busybox@latest\")\n\t\t\trequire.Contains(t, pred.Materials[1].URI, url.PathEscape(p))\n\t\t} else {\n\t\t\trequire.Equal(t, 1, len(pred.Materials), \"%+v\", pred.Materials)\n\t\t\trequire.Contains(t, pred.Materials[0].URI, \"pkg:docker/busybox@latest\")\n\t\t\trequire.Contains(t, pred.Materials[0].URI, url.PathEscape(p))\n\t\t}\n\n\t\targs := pred.Invocation.Parameters.Args\n\t\tif isClient {\n\t\t\trequire.Equal(t, 0, len(args), \"%+v\", args)\n\t\t} else if isGateway {\n\t\t\trequire.Equal(t, 3, len(args), \"%+v\", args)\n\t\t\trequire.Equal(t, \"bar\", args[\"build-arg:FOO\"])\n\t\t\trequire.Equal(t, \"abc\", args[\"label:lbl\"])\n\t\t\trequire.Contains(t, args[\"source\"], \"buildkit_test/\")\n\t\t} else {\n\t\t\trequire.Equal(t, 2, len(args), \"%+v\", args)\n\t\t\trequire.Equal(t, \"bar\", args[\"build-arg:FOO\"])\n\t\t\trequire.Equal(t, \"abc\", args[\"label:lbl\"])\n\t\t}\n\t}\n}\n\nfunc testClientFrontendProvenance(t *testing.T, sb integration.Sandbox) {\n\tintegration.CheckFeatureCompat(t, sb, integration.FeatureDirectPush, integration.FeatureProvenance)\n\t// Building with client frontend does not capture frontend provenance\n\t// because frontend runs in client, not in BuildKit.\n\t// This test builds Dockerfile inside a client frontend ensuring that\n\t// in that case frontend provenance is captured.\n\tctx := sb.Context()\n\n\tc, err := client.New(ctx, sb.Address())\n\trequire.NoError(t, err)\n\tdefer c.Close()\n\n\tregistry, err := sb.NewRegistry()\n\tif errors.Is(err, integration.ErrRequirements) {\n\t\tt.Skip(err.Error())\n\t}\n\trequire.NoError(t, err)\n\n\ttarget := registry + \"/buildkit/clientprovenance:latest\"\n\n\tf := getFrontend(t, sb)\n\n\t_, isClient := f.(*clientFrontend)\n\tif !isClient {\n\t\tt.Skip(\"not a client frontend\")\n\t}\n\n\tdockerfile := []byte(`\n\tFROM alpine as x86target\n\tRUN echo \"alpine\" > /foo\n\n\tFROM busybox:latest AS armtarget\n\tRUN --network=none echo \"bbox\" > /foo\n\t`)\n\tdir, err := integration.Tmpdir(\n\t\tt,\n\t\tfstest.CreateFile(\"Dockerfile\", dockerfile, 0600),\n\t)\n\trequire.NoError(t, err)\n\n\tfrontend := func(ctx context.Context, c gateway.Client) (*gateway.Result, error) {\n\t\tst := llb.HTTP(\"https://raw.githubusercontent.com/moby/moby/v20.10.21/README.md\")\n\t\tdef, err := st.Marshal(ctx)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\t// This does not show up in provenance\n\t\tres0, err := c.Solve(ctx, gateway.SolveRequest{\n\t\t\tDefinition: def.ToPB(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tdt, err := res0.Ref.ReadFile(ctx, gateway.ReadRequest{\n\t\t\tFilename: \"README.md\",\n\t\t})\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tres1, err := c.Solve(ctx, gateway.SolveRequest{\n\t\t\tFrontend: \"dockerfile.v0\",\n\t\t\tFrontendOpt: map[string]string{\n\t\t\t\t\"build-arg:FOO\": string(dt[:3]),\n\t\t\t\t\"target\":        \"armtarget\",\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tres2, err := c.Solve(ctx, gateway.SolveRequest{\n\t\t\tFrontend: \"dockerfile.v0\",\n\t\t\tFrontendOpt: map[string]string{\n\t\t\t\t\"build-arg:FOO\": string(dt[4:8]),\n\t\t\t\t\"target\":        \"x86target\",\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tres := gateway.NewResult()\n\t\tres.AddRef(\"linux/arm64\", res1.Ref)\n\t\tres.AddRef(\"linux/amd64\", res2.Ref)\n\n\t\tpl, err := json.Marshal(exptypes.Platforms{\n\t\t\tPlatforms: []exptypes.Platform{\n\t\t\t\t{\n\t\t\t\t\tID:       \"linux/arm64\",\n\t\t\t\t\tPlatform: ocispecs.Platform{OS: \"linux\", Architecture: \"arm64\"},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tID:       \"linux/amd64\",\n\t\t\t\t\tPlatform: ocispecs.Platform{OS: \"linux\", Architecture: \"amd64\"},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tres.AddMeta(exptypes.ExporterPlatformsKey, pl)\n\n\t\treturn res, nil\n\t}\n\n\t_, err = c.Build(sb.Context(), client.SolveOpt{\n\t\tFrontendAttrs: map[string]string{\n\t\t\t\"attest:provenance\": \"mode=full\",\n\t\t},\n\t\tExports: []client.ExportEntry{\n\t\t\t{\n\t\t\t\tType: client.ExporterImage,\n\t\t\t\tAttrs: map[string]string{\n\t\t\t\t\t\"name\": target,\n\t\t\t\t\t\"push\": \"true\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tLocalDirs: map[string]string{\n\t\t\tdockerui.DefaultLocalNameDockerfile: dir,\n\t\t\tdockerui.DefaultLocalNameContext:    dir,\n\t\t},\n\t}, \"\", frontend, nil)\n\trequire.NoError(t, err)\n\n\tdesc, provider, err := contentutil.ProviderFromRef(target)\n\trequire.NoError(t, err)\n\timgs, err := testutil.ReadImages(sb.Context(), provider, desc)\n\trequire.NoError(t, err)\n\trequire.Equal(t, 4, len(imgs.Images))\n\n\timg := imgs.Find(\"linux/arm64\")\n\trequire.NotNil(t, img)\n\trequire.Equal(t, []byte(\"bbox\\n\"), img.Layers[1][\"foo\"].Data)\n\n\tatt := imgs.FindAttestation(\"linux/arm64\")\n\trequire.NotNil(t, att)\n\trequire.Equal(t, att.Desc.Annotations[\"vnd.docker.reference.type\"], \"attestation-manifest\")\n\tvar attest intoto.Statement\n\trequire.NoError(t, json.Unmarshal(att.LayersRaw[0], &attest))\n\trequire.Equal(t, \"https://in-toto.io/Statement/v0.1\", attest.Type)\n\trequire.Equal(t, \"https://slsa.dev/provenance/v0.2\", attest.PredicateType) // intentionally not const\n\n\ttype stmtT struct {\n\t\tPredicate provenance.ProvenancePredicate `json:\"predicate\"`\n\t}\n\tvar stmt stmtT\n\trequire.NoError(t, json.Unmarshal(att.LayersRaw[0], &stmt))\n\tpred := stmt.Predicate\n\n\trequire.Equal(t, \"https://mobyproject.org/buildkit@v1\", pred.BuildType)\n\trequire.Equal(t, \"\", pred.Builder.ID)\n\trequire.Equal(t, \"\", pred.Invocation.ConfigSource.URI)\n\n\targs := pred.Invocation.Parameters.Args\n\trequire.Equal(t, 2, len(args), \"%+v\", args)\n\trequire.Equal(t, \"The\", args[\"build-arg:FOO\"])\n\trequire.Equal(t, \"armtarget\", args[\"target\"])\n\n\trequire.Equal(t, 2, len(pred.Invocation.Parameters.Locals))\n\trequire.Equal(t, 1, len(pred.Materials))\n\trequire.Contains(t, pred.Materials[0].URI, \"docker/busybox\")\n\n\t// amd64\n\timg = imgs.Find(\"linux/amd64\")\n\trequire.NotNil(t, img)\n\trequire.Equal(t, []byte(\"alpine\\n\"), img.Layers[1][\"foo\"].Data)\n\n\tatt = imgs.FindAttestation(\"linux/amd64\")\n\trequire.NotNil(t, att)\n\trequire.Equal(t, att.Desc.Annotations[\"vnd.docker.reference.type\"], \"attestation-manifest\")\n\tattest = intoto.Statement{}\n\trequire.NoError(t, json.Unmarshal(att.LayersRaw[0], &attest))\n\trequire.Equal(t, \"https://in-toto.io/Statement/v0.1\", attest.Type)\n\trequire.Equal(t, \"https://slsa.dev/provenance/v0.2\", attest.PredicateType) // intentionally not const\n\n\tstmt = stmtT{}\n\trequire.NoError(t, json.Unmarshal(att.LayersRaw[0], &stmt))\n\tpred = stmt.Predicate\n\n\trequire.Equal(t, \"https://mobyproject.org/buildkit@v1\", pred.BuildType)\n\trequire.Equal(t, \"\", pred.Builder.ID)\n\trequire.Equal(t, \"\", pred.Invocation.ConfigSource.URI)\n\n\targs = pred.Invocation.Parameters.Args\n\trequire.Equal(t, 2, len(args), \"%+v\", args)\n\trequire.Equal(t, \"Moby\", args[\"build-arg:FOO\"])\n\trequire.Equal(t, \"x86target\", args[\"target\"])\n\n\trequire.Equal(t, 2, len(pred.Invocation.Parameters.Locals))\n\trequire.Equal(t, 1, len(pred.Materials))\n\trequire.Contains(t, pred.Materials[0].URI, \"docker/alpine\")\n}\n\nfunc testClientLLBProvenance(t *testing.T, sb integration.Sandbox) {\n\tintegration.CheckFeatureCompat(t, sb, integration.FeatureDirectPush, integration.FeatureProvenance)\n\tctx := sb.Context()\n\n\tc, err := client.New(ctx, sb.Address())\n\trequire.NoError(t, err)\n\tdefer c.Close()\n\n\tregistry, err := sb.NewRegistry()\n\tif errors.Is(err, integration.ErrRequirements) {\n\t\tt.Skip(err.Error())\n\t}\n\trequire.NoError(t, err)\n\n\ttarget := registry + \"/buildkit/clientprovenance:llb\"\n\n\tf := getFrontend(t, sb)\n\n\t_, isClient := f.(*clientFrontend)\n\tif !isClient {\n\t\tt.Skip(\"not a client frontend\")\n\t}\n\n\tfrontend := func(ctx context.Context, c gateway.Client) (*gateway.Result, error) {\n\t\tst := llb.HTTP(\"https://raw.githubusercontent.com/moby/moby/v20.10.21/README.md\")\n\t\tdef, err := st.Marshal(ctx)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\t// this also shows up in the provenance\n\t\tres0, err := c.Solve(ctx, gateway.SolveRequest{\n\t\t\tDefinition: def.ToPB(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tdt, err := res0.Ref.ReadFile(ctx, gateway.ReadRequest{\n\t\t\tFilename: \"README.md\",\n\t\t})\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tst = llb.Image(\"alpine\").File(llb.Mkfile(\"/foo\", 0600, dt))\n\t\tdef, err = st.Marshal(ctx)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tres1, err := c.Solve(ctx, gateway.SolveRequest{\n\t\t\tDefinition: def.ToPB(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn res1, nil\n\t}\n\n\t_, err = c.Build(sb.Context(), client.SolveOpt{\n\t\tFrontendAttrs: map[string]string{\n\t\t\t\"attest:provenance\": \"mode=full\",\n\t\t},\n\t\tExports: []client.ExportEntry{\n\t\t\t{\n\t\t\t\tType: client.ExporterImage,\n\t\t\t\tAttrs: map[string]string{\n\t\t\t\t\t\"name\": target,\n\t\t\t\t\t\"push\": \"true\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tLocalDirs: map[string]string{},\n\t}, \"\", frontend, nil)\n\trequire.NoError(t, err)\n\n\tdesc, provider, err := contentutil.ProviderFromRef(target)\n\trequire.NoError(t, err)\n\timgs, err := testutil.ReadImages(sb.Context(), provider, desc)\n\trequire.NoError(t, err)\n\trequire.Equal(t, 2, len(imgs.Images))\n\n\tnativePlatform := platforms.Format(platforms.Normalize(platforms.DefaultSpec()))\n\n\timg := imgs.Find(nativePlatform)\n\trequire.NotNil(t, img)\n\trequire.Contains(t, string(img.Layers[1][\"foo\"].Data), \"The Moby Project\")\n\n\tatt := imgs.FindAttestation(nativePlatform)\n\trequire.NotNil(t, att)\n\trequire.Equal(t, att.Desc.Annotations[\"vnd.docker.reference.type\"], \"attestation-manifest\")\n\tvar attest intoto.Statement\n\trequire.NoError(t, json.Unmarshal(att.LayersRaw[0], &attest))\n\trequire.Equal(t, \"https://in-toto.io/Statement/v0.1\", attest.Type)\n\trequire.Equal(t, \"https://slsa.dev/provenance/v0.2\", attest.PredicateType) // intentionally not const\n\n\ttype stmtT struct {\n\t\tPredicate provenance.ProvenancePredicate `json:\"predicate\"`\n\t}\n\tvar stmt stmtT\n\trequire.NoError(t, json.Unmarshal(att.LayersRaw[0], &stmt))\n\tpred := stmt.Predicate\n\n\trequire.Equal(t, \"https://mobyproject.org/buildkit@v1\", pred.BuildType)\n\trequire.Equal(t, \"\", pred.Builder.ID)\n\trequire.Equal(t, \"\", pred.Invocation.ConfigSource.URI)\n\n\targs := pred.Invocation.Parameters.Args\n\trequire.Equal(t, 0, len(args), \"%+v\", args)\n\trequire.Equal(t, 0, len(pred.Invocation.Parameters.Locals))\n\n\trequire.Equal(t, 2, len(pred.Materials), \"%+v\", pred.Materials)\n\trequire.Contains(t, pred.Materials[0].URI, \"docker/alpine\")\n\trequire.Contains(t, pred.Materials[1].URI, \"README.md\")\n}\n\nfunc testSecretSSHProvenance(t *testing.T, sb integration.Sandbox) {\n\tintegration.CheckFeatureCompat(t, sb, integration.FeatureDirectPush, integration.FeatureProvenance)\n\tctx := sb.Context()\n\n\tc, err := client.New(ctx, sb.Address())\n\trequire.NoError(t, err)\n\tdefer c.Close()\n\n\tregistry, err := sb.NewRegistry()\n\tif errors.Is(err, integration.ErrRequirements) {\n\t\tt.Skip(err.Error())\n\t}\n\trequire.NoError(t, err)\n\n\tf := getFrontend(t, sb)\n\n\tdockerfile := []byte(`\nFROM busybox:latest\nRUN --mount=type=secret,id=mysecret --mount=type=secret,id=othersecret --mount=type=ssh echo \"ok\" > /foo\n`)\n\tdir, err := integration.Tmpdir(\n\t\tt,\n\t\tfstest.CreateFile(\"Dockerfile\", dockerfile, 0600),\n\t)\n\trequire.NoError(t, err)\n\n\ttarget := registry + \"/buildkit/testsecretprovenance:latest\"\n\t_, err = f.Solve(sb.Context(), c, client.SolveOpt{\n\t\tLocalDirs: map[string]string{\n\t\t\tdockerui.DefaultLocalNameDockerfile: dir,\n\t\t\tdockerui.DefaultLocalNameContext:    dir,\n\t\t},\n\t\tFrontendAttrs: map[string]string{\n\t\t\t\"attest:provenance\": \"mode=max\",\n\t\t},\n\t\tExports: []client.ExportEntry{\n\t\t\t{\n\t\t\t\tType: client.ExporterImage,\n\t\t\t\tAttrs: map[string]string{\n\t\t\t\t\t\"name\": target,\n\t\t\t\t\t\"push\": \"true\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}, nil)\n\trequire.NoError(t, err)\n\n\tdesc, provider, err := contentutil.ProviderFromRef(target)\n\trequire.NoError(t, err)\n\timgs, err := testutil.ReadImages(sb.Context(), provider, desc)\n\trequire.NoError(t, err)\n\trequire.Equal(t, 2, len(imgs.Images))\n\n\texpPlatform := platforms.Format(platforms.Normalize(platforms.DefaultSpec()))\n\n\timg := imgs.Find(expPlatform)\n\trequire.NotNil(t, img)\n\trequire.Equal(t, []byte(\"ok\\n\"), img.Layers[1][\"foo\"].Data)\n\n\tatt := imgs.FindAttestation(expPlatform)\n\ttype stmtT struct {\n\t\tPredicate provenance.ProvenancePredicate `json:\"predicate\"`\n\t}\n\tvar stmt stmtT\n\trequire.NoError(t, json.Unmarshal(att.LayersRaw[0], &stmt))\n\tpred := stmt.Predicate\n\n\trequire.Equal(t, 2, len(pred.Invocation.Parameters.Secrets), \"%+v\", pred.Invocation.Parameters.Secrets)\n\trequire.Equal(t, \"mysecret\", pred.Invocation.Parameters.Secrets[0].ID)\n\trequire.True(t, pred.Invocation.Parameters.Secrets[0].Optional)\n\trequire.Equal(t, \"othersecret\", pred.Invocation.Parameters.Secrets[1].ID)\n\trequire.True(t, pred.Invocation.Parameters.Secrets[1].Optional)\n\n\trequire.Equal(t, 1, len(pred.Invocation.Parameters.SSH), \"%+v\", pred.Invocation.Parameters.SSH)\n\trequire.Equal(t, \"default\", pred.Invocation.Parameters.SSH[0].ID)\n\trequire.True(t, pred.Invocation.Parameters.SSH[0].Optional)\n}\n\nfunc testNilProvenance(t *testing.T, sb integration.Sandbox) {\n\tintegration.CheckFeatureCompat(t, sb, integration.FeatureProvenance)\n\tctx := sb.Context()\n\n\tc, err := client.New(ctx, sb.Address())\n\trequire.NoError(t, err)\n\tdefer c.Close()\n\n\tf := getFrontend(t, sb)\n\n\tdockerfile := []byte(`\nFROM scratch\nENV FOO=bar\n`)\n\tdir, err := integration.Tmpdir(\n\t\tt,\n\t\tfstest.CreateFile(\"Dockerfile\", dockerfile, 0600),\n\t)\n\trequire.NoError(t, err)\n\n\t_, err = f.Solve(sb.Context(), c, client.SolveOpt{\n\t\tLocalDirs: map[string]string{\n\t\t\tdockerui.DefaultLocalNameDockerfile: dir,\n\t\t\tdockerui.DefaultLocalNameContext:    dir,\n\t\t},\n\t\tFrontendAttrs: map[string]string{\n\t\t\t\"attest:provenance\": \"mode=max\",\n\t\t},\n\t\tExports: []client.ExportEntry{\n\t\t\t{\n\t\t\t\tType: client.ExporterImage,\n\t\t\t},\n\t\t},\n\t}, nil)\n\trequire.NoError(t, err)\n}\n", "package provenance\n\nimport (\n\t\"sort\"\n\n\tdistreference \"github.com/docker/distribution/reference\"\n\t\"github.com/moby/buildkit/solver/result\"\n\t\"github.com/moby/buildkit/util/urlutil\"\n\tdigest \"github.com/opencontainers/go-digest\"\n\tocispecs \"github.com/opencontainers/image-spec/specs-go/v1\"\n)\n\ntype Result = result.Result[*Capture]\n\ntype ImageSource struct {\n\tRef      string\n\tPlatform *ocispecs.Platform\n\tDigest   digest.Digest\n}\n\ntype GitSource struct {\n\tURL    string\n\tCommit string\n}\n\ntype HTTPSource struct {\n\tURL    string\n\tDigest digest.Digest\n}\n\ntype LocalSource struct {\n\tName string `json:\"name\"`\n}\n\ntype Secret struct {\n\tID       string `json:\"id\"`\n\tOptional bool   `json:\"optional,omitempty\"`\n}\n\ntype SSH struct {\n\tID       string `json:\"id\"`\n\tOptional bool   `json:\"optional,omitempty\"`\n}\n\ntype Sources struct {\n\tImages      []ImageSource\n\tLocalImages []ImageSource\n\tGit         []GitSource\n\tHTTP        []HTTPSource\n\tLocal       []LocalSource\n}\n\ntype Capture struct {\n\tFrontend            string\n\tArgs                map[string]string\n\tSources             Sources\n\tSecrets             []Secret\n\tSSH                 []SSH\n\tNetworkAccess       bool\n\tIncompleteMaterials bool\n}\n\nfunc (c *Capture) Merge(c2 *Capture) error {\n\tif c2 == nil {\n\t\treturn nil\n\t}\n\tfor _, i := range c2.Sources.Images {\n\t\tc.AddImage(i)\n\t}\n\tfor _, i := range c2.Sources.LocalImages {\n\t\tc.AddLocalImage(i)\n\t}\n\tfor _, l := range c2.Sources.Local {\n\t\tc.AddLocal(l)\n\t}\n\tfor _, g := range c2.Sources.Git {\n\t\tc.AddGit(g)\n\t}\n\tfor _, h := range c2.Sources.HTTP {\n\t\tc.AddHTTP(h)\n\t}\n\tfor _, s := range c2.Secrets {\n\t\tc.AddSecret(s)\n\t}\n\tfor _, s := range c2.SSH {\n\t\tc.AddSSH(s)\n\t}\n\tif c2.NetworkAccess {\n\t\tc.NetworkAccess = true\n\t}\n\tif c2.IncompleteMaterials {\n\t\tc.IncompleteMaterials = true\n\t}\n\treturn nil\n}\n\nfunc (c *Capture) Sort() {\n\tsort.Slice(c.Sources.Images, func(i, j int) bool {\n\t\treturn c.Sources.Images[i].Ref < c.Sources.Images[j].Ref\n\t})\n\tsort.Slice(c.Sources.LocalImages, func(i, j int) bool {\n\t\treturn c.Sources.LocalImages[i].Ref < c.Sources.LocalImages[j].Ref\n\t})\n\tsort.Slice(c.Sources.Local, func(i, j int) bool {\n\t\treturn c.Sources.Local[i].Name < c.Sources.Local[j].Name\n\t})\n\tsort.Slice(c.Sources.Git, func(i, j int) bool {\n\t\treturn c.Sources.Git[i].URL < c.Sources.Git[j].URL\n\t})\n\tsort.Slice(c.Sources.HTTP, func(i, j int) bool {\n\t\treturn c.Sources.HTTP[i].URL < c.Sources.HTTP[j].URL\n\t})\n\tsort.Slice(c.Secrets, func(i, j int) bool {\n\t\treturn c.Secrets[i].ID < c.Secrets[j].ID\n\t})\n\tsort.Slice(c.SSH, func(i, j int) bool {\n\t\treturn c.SSH[i].ID < c.SSH[j].ID\n\t})\n}\n\n// OptimizeImageSources filters out image sources by digest reference if same digest\n// is already present by a tag reference.\nfunc (c *Capture) OptimizeImageSources() error {\n\tm := map[string]struct{}{}\n\tfor _, i := range c.Sources.Images {\n\t\tref, nameTag, err := parseRefName(i.Ref)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, ok := ref.(distreference.Canonical); !ok {\n\t\t\tm[nameTag] = struct{}{}\n\t\t}\n\t}\n\n\timages := make([]ImageSource, 0, len(c.Sources.Images))\n\tfor _, i := range c.Sources.Images {\n\t\tref, nameTag, err := parseRefName(i.Ref)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, ok := ref.(distreference.Canonical); ok {\n\t\t\tif _, ok := m[nameTag]; ok {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t\timages = append(images, i)\n\t}\n\tc.Sources.Images = images\n\treturn nil\n}\n\nfunc (c *Capture) AddImage(i ImageSource) {\n\tfor _, v := range c.Sources.Images {\n\t\tif v.Ref == i.Ref {\n\t\t\tif v.Platform == i.Platform {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif v.Platform != nil && i.Platform != nil {\n\t\t\t\tif v.Platform.Architecture == i.Platform.Architecture && v.Platform.OS == i.Platform.OS && v.Platform.Variant == i.Platform.Variant {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tc.Sources.Images = append(c.Sources.Images, i)\n}\n\nfunc (c *Capture) AddLocalImage(i ImageSource) {\n\tfor _, v := range c.Sources.LocalImages {\n\t\tif v.Ref == i.Ref {\n\t\t\tif v.Platform == i.Platform {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif v.Platform != nil && i.Platform != nil {\n\t\t\t\tif v.Platform.Architecture == i.Platform.Architecture && v.Platform.OS == i.Platform.OS && v.Platform.Variant == i.Platform.Variant {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tc.Sources.LocalImages = append(c.Sources.LocalImages, i)\n}\n\nfunc (c *Capture) AddLocal(l LocalSource) {\n\tfor _, v := range c.Sources.Local {\n\t\tif v.Name == l.Name {\n\t\t\treturn\n\t\t}\n\t}\n\tc.Sources.Local = append(c.Sources.Local, l)\n}\n\nfunc (c *Capture) AddGit(g GitSource) {\n\tg.URL = urlutil.RedactCredentials(g.URL)\n\tfor _, v := range c.Sources.Git {\n\t\tif v.URL == g.URL {\n\t\t\treturn\n\t\t}\n\t}\n\tc.Sources.Git = append(c.Sources.Git, g)\n}\n\nfunc (c *Capture) AddHTTP(h HTTPSource) {\n\th.URL = urlutil.RedactCredentials(h.URL)\n\tfor _, v := range c.Sources.HTTP {\n\t\tif v.URL == h.URL {\n\t\t\treturn\n\t\t}\n\t}\n\tc.Sources.HTTP = append(c.Sources.HTTP, h)\n}\n\nfunc (c *Capture) AddSecret(s Secret) {\n\tfor i, v := range c.Secrets {\n\t\tif v.ID == s.ID {\n\t\t\tif !s.Optional {\n\t\t\t\tc.Secrets[i].Optional = false\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t}\n\tc.Secrets = append(c.Secrets, s)\n}\n\nfunc (c *Capture) AddSSH(s SSH) {\n\tif s.ID == \"\" {\n\t\ts.ID = \"default\"\n\t}\n\tfor i, v := range c.SSH {\n\t\tif v.ID == s.ID {\n\t\t\tif !s.Optional {\n\t\t\t\tc.SSH[i].Optional = false\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t}\n\tc.SSH = append(c.SSH, s)\n}\n\nfunc parseRefName(s string) (distreference.Named, string, error) {\n\tref, err := distreference.ParseNormalizedNamed(s)\n\tif err != nil {\n\t\treturn nil, \"\", err\n\t}\n\tname := ref.Name()\n\ttag := \"latest\"\n\tif r, ok := ref.(distreference.Tagged); ok {\n\t\ttag = r.Tag()\n\t}\n\treturn ref, name + \":\" + tag, nil\n}\n", "package provenance\n\nimport (\n\t\"strings\"\n\n\t\"github.com/containerd/containerd/platforms\"\n\tslsa \"github.com/in-toto/in-toto-golang/in_toto/slsa_provenance/common\"\n\tslsa02 \"github.com/in-toto/in-toto-golang/in_toto/slsa_provenance/v0.2\"\n\t\"github.com/moby/buildkit/util/purl\"\n\t\"github.com/moby/buildkit/util/urlutil\"\n\tocispecs \"github.com/opencontainers/image-spec/specs-go/v1\"\n\t\"github.com/package-url/packageurl-go\"\n)\n\nconst (\n\tBuildKitBuildType = \"https://mobyproject.org/buildkit@v1\"\n)\n\ntype ProvenancePredicate struct {\n\tslsa02.ProvenancePredicate\n\tInvocation  ProvenanceInvocation `json:\"invocation,omitempty\"`\n\tBuildConfig *BuildConfig         `json:\"buildConfig,omitempty\"`\n\tMetadata    *ProvenanceMetadata  `json:\"metadata,omitempty\"`\n}\n\ntype ProvenanceInvocation struct {\n\tConfigSource slsa02.ConfigSource `json:\"configSource,omitempty\"`\n\tParameters   Parameters          `json:\"parameters,omitempty\"`\n\tEnvironment  Environment         `json:\"environment,omitempty\"`\n}\n\ntype Parameters struct {\n\tFrontend string            `json:\"frontend,omitempty\"`\n\tArgs     map[string]string `json:\"args,omitempty\"`\n\tSecrets  []*Secret         `json:\"secrets,omitempty\"`\n\tSSH      []*SSH            `json:\"ssh,omitempty\"`\n\tLocals   []*LocalSource    `json:\"locals,omitempty\"`\n\t// TODO: select export attributes\n\t// TODO: frontend inputs\n}\n\ntype Environment struct {\n\tPlatform string `json:\"platform\"`\n}\n\ntype ProvenanceMetadata struct {\n\tslsa02.ProvenanceMetadata\n\tBuildKitMetadata BuildKitMetadata `json:\"https://mobyproject.org/buildkit@v1#metadata,omitempty\"`\n\tHermetic         bool             `json:\"https://mobyproject.org/buildkit@v1#hermetic,omitempty\"`\n}\n\ntype BuildKitMetadata struct {\n\tVCS    map[string]string                  `json:\"vcs,omitempty\"`\n\tSource *Source                            `json:\"source,omitempty\"`\n\tLayers map[string][][]ocispecs.Descriptor `json:\"layers,omitempty\"`\n}\n\nfunc slsaMaterials(srcs Sources) ([]slsa.ProvenanceMaterial, error) {\n\tcount := len(srcs.Images) + len(srcs.Git) + len(srcs.HTTP) + len(srcs.LocalImages)\n\tout := make([]slsa.ProvenanceMaterial, 0, count)\n\n\tfor _, s := range srcs.Images {\n\t\turi, err := purl.RefToPURL(s.Ref, s.Platform)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tout = append(out, slsa.ProvenanceMaterial{\n\t\t\tURI: uri,\n\t\t\tDigest: slsa.DigestSet{\n\t\t\t\ts.Digest.Algorithm().String(): s.Digest.Hex(),\n\t\t\t},\n\t\t})\n\t}\n\n\tfor _, s := range srcs.Git {\n\t\tout = append(out, slsa.ProvenanceMaterial{\n\t\t\tURI: s.URL,\n\t\t\tDigest: slsa.DigestSet{\n\t\t\t\t\"sha1\": s.Commit,\n\t\t\t},\n\t\t})\n\t}\n\n\tfor _, s := range srcs.HTTP {\n\t\tout = append(out, slsa.ProvenanceMaterial{\n\t\t\tURI: s.URL,\n\t\t\tDigest: slsa.DigestSet{\n\t\t\t\ts.Digest.Algorithm().String(): s.Digest.Hex(),\n\t\t\t},\n\t\t})\n\t}\n\n\tfor _, s := range srcs.LocalImages {\n\t\tq := []packageurl.Qualifier{}\n\t\tif s.Platform != nil {\n\t\t\tq = append(q, packageurl.Qualifier{\n\t\t\t\tKey:   \"platform\",\n\t\t\t\tValue: platforms.Format(*s.Platform),\n\t\t\t})\n\t\t}\n\t\tpackageurl.NewPackageURL(packageurl.TypeOCI, \"\", s.Ref, \"\", q, \"\")\n\t\tout = append(out, slsa.ProvenanceMaterial{\n\t\t\tURI: s.Ref,\n\t\t\tDigest: slsa.DigestSet{\n\t\t\t\ts.Digest.Algorithm().String(): s.Digest.Hex(),\n\t\t\t},\n\t\t})\n\t}\n\treturn out, nil\n}\n\nfunc findMaterial(srcs Sources, uri string) (*slsa.ProvenanceMaterial, bool) {\n\tfor _, s := range srcs.Git {\n\t\tif s.URL == uri {\n\t\t\treturn &slsa.ProvenanceMaterial{\n\t\t\t\tURI: s.URL,\n\t\t\t\tDigest: slsa.DigestSet{\n\t\t\t\t\t\"sha1\": s.Commit,\n\t\t\t\t},\n\t\t\t}, true\n\t\t}\n\t}\n\tfor _, s := range srcs.HTTP {\n\t\tif s.URL == uri {\n\t\t\treturn &slsa.ProvenanceMaterial{\n\t\t\t\tURI: s.URL,\n\t\t\t\tDigest: slsa.DigestSet{\n\t\t\t\t\ts.Digest.Algorithm().String(): s.Digest.Hex(),\n\t\t\t\t},\n\t\t\t}, true\n\t\t}\n\t}\n\treturn nil, false\n}\n\nfunc NewPredicate(c *Capture) (*ProvenancePredicate, error) {\n\tmaterials, err := slsaMaterials(c.Sources)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tinv := ProvenanceInvocation{}\n\n\tcontextKey := \"context\"\n\tif v, ok := c.Args[\"contextkey\"]; ok && v != \"\" {\n\t\tcontextKey = v\n\t}\n\n\tif v, ok := c.Args[contextKey]; ok && v != \"\" {\n\t\tif m, ok := findMaterial(c.Sources, v); ok {\n\t\t\tinv.ConfigSource.URI = m.URI\n\t\t\tinv.ConfigSource.Digest = m.Digest\n\t\t} else {\n\t\t\tinv.ConfigSource.URI = v\n\t\t}\n\t\tinv.ConfigSource.URI = urlutil.RedactCredentials(inv.ConfigSource.URI)\n\t\tdelete(c.Args, contextKey)\n\t}\n\n\tif v, ok := c.Args[\"filename\"]; ok && v != \"\" {\n\t\tinv.ConfigSource.EntryPoint = v\n\t\tdelete(c.Args, \"filename\")\n\t}\n\n\tvcs := make(map[string]string)\n\tfor k, v := range c.Args {\n\t\tif strings.HasPrefix(k, \"vcs:\") {\n\t\t\tif k == \"vcs:source\" {\n\t\t\t\tv = urlutil.RedactCredentials(v)\n\t\t\t}\n\t\t\tdelete(c.Args, k)\n\t\t\tif v != \"\" {\n\t\t\t\tvcs[strings.TrimPrefix(k, \"vcs:\")] = v\n\t\t\t}\n\t\t}\n\t}\n\n\tinv.Environment.Platform = platforms.Format(platforms.Normalize(platforms.DefaultSpec()))\n\n\tinv.Parameters.Frontend = c.Frontend\n\tinv.Parameters.Args = c.Args\n\n\tfor _, s := range c.Secrets {\n\t\tinv.Parameters.Secrets = append(inv.Parameters.Secrets, &Secret{\n\t\t\tID:       s.ID,\n\t\t\tOptional: s.Optional,\n\t\t})\n\t}\n\tfor _, s := range c.SSH {\n\t\tinv.Parameters.SSH = append(inv.Parameters.SSH, &SSH{\n\t\t\tID:       s.ID,\n\t\t\tOptional: s.Optional,\n\t\t})\n\t}\n\tfor _, s := range c.Sources.Local {\n\t\tinv.Parameters.Locals = append(inv.Parameters.Locals, &LocalSource{\n\t\t\tName: s.Name,\n\t\t})\n\t}\n\n\tincompleteMaterials := c.IncompleteMaterials\n\tif !incompleteMaterials {\n\t\tif len(c.Sources.Local) > 0 {\n\t\t\tincompleteMaterials = true\n\t\t}\n\t}\n\n\tpr := &ProvenancePredicate{\n\t\tInvocation: inv,\n\t\tProvenancePredicate: slsa02.ProvenancePredicate{\n\t\t\tBuildType: BuildKitBuildType,\n\t\t\tMaterials: materials,\n\t\t},\n\t\tMetadata: &ProvenanceMetadata{\n\t\t\tProvenanceMetadata: slsa02.ProvenanceMetadata{\n\t\t\t\tCompleteness: slsa02.ProvenanceComplete{\n\t\t\t\t\tParameters:  c.Frontend != \"\",\n\t\t\t\t\tEnvironment: true,\n\t\t\t\t\tMaterials:   !incompleteMaterials,\n\t\t\t\t},\n\t\t\t},\n\t\t\tHermetic: !incompleteMaterials && !c.NetworkAccess,\n\t\t},\n\t}\n\n\tif len(vcs) > 0 {\n\t\tpr.Metadata.BuildKitMetadata.VCS = vcs\n\t}\n\n\treturn pr, nil\n}\n\nfunc FilterArgs(m map[string]string) map[string]string {\n\tvar hostSpecificArgs = map[string]struct{}{\n\t\t\"cgroup-parent\":      {},\n\t\t\"image-resolve-mode\": {},\n\t\t\"platform\":           {},\n\t\t\"cache-imports\":      {},\n\t}\n\tconst defaultContextKey = \"context\"\n\tcontextKey := defaultContextKey\n\tif v, ok := m[\"contextkey\"]; ok && v != \"\" {\n\t\tcontextKey = v\n\t}\n\tout := make(map[string]string)\n\tfor k, v := range m {\n\t\tif _, ok := hostSpecificArgs[k]; ok {\n\t\t\tcontinue\n\t\t}\n\t\tif strings.HasPrefix(k, \"attest:\") {\n\t\t\tcontinue\n\t\t}\n\t\tif k == contextKey || strings.HasPrefix(k, defaultContextKey+\":\") {\n\t\t\tv = urlutil.RedactCredentials(v)\n\t\t}\n\t\tout[k] = v\n\t}\n\treturn out\n}\n"], "filenames": ["frontend/dockerfile/dockerfile_buildinfo_test.go", "frontend/dockerfile/dockerfile_provenance_test.go", "solver/llbsolver/provenance/capture.go", "solver/llbsolver/provenance/predicate.go"], "buggy_code_start_loc": [55, 80, 7, 9], "buggy_code_end_loc": [139, 344, 201, 241], "fixing_code_start_loc": [55, 80, 8, 10], "fixing_code_end_loc": [146, 352, 205, 255], "type": "NVD-CWE-noinfo", "message": "BuildKit is a toolkit for converting source code to build artifacts in an efficient, expressive and repeatable manner. In affected versions when the user sends a build request that contains a Git URL that contains credentials and the build creates a provenance attestation describing that build, these credentials could be visible from the provenance attestation. Git URL can be passed in two ways: 1) Invoking build directly from a URL with credentials. 2) If the client sends additional version control system (VCS) info hint parameters on builds from a local source. Usually, that would mean reading the origin URL from `.git/config` file. When a build is performed under specific conditions where credentials were passed to BuildKit they may be visible to everyone who has access to provenance attestation. Provenance attestations and VCS info hints were added in version v0.11.0. Previous versions are not vulnerable. In v0.10, when building directly from Git URL, the same URL could be visible in `BuildInfo` structure that is a predecessor of Provenance attestations. Previous versions are not vulnerable. This bug has been fixed in v0.11.4. Users are advised to upgrade. Users unable to upgrade may disable VCS info hints by setting `BUILDX_GIT_INFO=0`. `buildctl` does not set VCS hints based on `.git` directory, and values would need to be passed manually with `--opt`.", "other": {"cve": {"id": "CVE-2023-26054", "sourceIdentifier": "security-advisories@github.com", "published": "2023-03-06T19:15:10.390", "lastModified": "2023-03-13T18:37:50.100", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "BuildKit is a toolkit for converting source code to build artifacts in an efficient, expressive and repeatable manner. In affected versions when the user sends a build request that contains a Git URL that contains credentials and the build creates a provenance attestation describing that build, these credentials could be visible from the provenance attestation. Git URL can be passed in two ways: 1) Invoking build directly from a URL with credentials. 2) If the client sends additional version control system (VCS) info hint parameters on builds from a local source. Usually, that would mean reading the origin URL from `.git/config` file. When a build is performed under specific conditions where credentials were passed to BuildKit they may be visible to everyone who has access to provenance attestation. Provenance attestations and VCS info hints were added in version v0.11.0. Previous versions are not vulnerable. In v0.10, when building directly from Git URL, the same URL could be visible in `BuildInfo` structure that is a predecessor of Provenance attestations. Previous versions are not vulnerable. This bug has been fixed in v0.11.4. Users are advised to upgrade. Users unable to upgrade may disable VCS info hints by setting `BUILDX_GIT_INFO=0`. `buildctl` does not set VCS hints based on `.git` directory, and values would need to be passed manually with `--opt`."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mobyproject:buildkit:*:*:*:*:*:*:*:*", "versionStartIncluding": "0.10.0", "versionEndExcluding": "0.11.4", "matchCriteriaId": "B20CBA03-7DD3-4756-AE19-BE0B45272C1F"}]}]}], "references": [{"url": "https://github.com/moby/buildkit/commit/75123c696506bdbca1ed69906479e200f1b62604", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/moby/buildkit/security/advisories/GHSA-gc89-7gcr-jxqc", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/moby/buildkit/commit/75123c696506bdbca1ed69906479e200f1b62604"}}