{"buggy_code": ["# frozen_string_literal: true\n\nclass TagsController < ::ApplicationController\n  include TopicListResponder\n  include TopicQueryParams\n\n  before_action :ensure_tags_enabled\n  before_action :ensure_visible, only: %i[show info]\n\n  def self.show_methods\n    Discourse.anonymous_filters.map { |f| :\"show_#{f}\" }\n  end\n\n  requires_login except: [:index, :show, :tag_feed, :search, :info, *show_methods]\n\n  skip_before_action :check_xhr, only: [:tag_feed, :show, :index, *show_methods]\n\n  before_action :set_category,\n                except: %i[\n                  index\n                  update\n                  destroy\n                  tag_feed\n                  search\n                  notifications\n                  update_notifications\n                  personal_messages\n                  info\n                ]\n\n  before_action :fetch_tag, only: %i[info create_synonyms destroy_synonym]\n\n  after_action :add_noindex_header, except: %i[index show]\n\n  def index\n    @description_meta = I18n.t(\"tags.title\")\n    @title = @description_meta\n\n    show_all_tags = guardian.can_admin_tags? && guardian.is_admin?\n\n    if SiteSetting.tags_listed_by_group\n      ungrouped_tags = Tag.where(\"tags.id NOT IN (SELECT tag_id FROM tag_group_memberships)\")\n      ungrouped_tags = ungrouped_tags.used_tags_in_regular_topics(guardian) unless show_all_tags\n\n      grouped_tag_counts =\n        TagGroup\n          .visible(guardian)\n          .order(\"name ASC\")\n          .includes(:none_synonym_tags)\n          .map do |tag_group|\n            {\n              id: tag_group.id,\n              name: tag_group.name,\n              tags: self.class.tag_counts_json(tag_group.none_synonym_tags, guardian),\n            }\n          end\n\n      @tags = self.class.tag_counts_json(ungrouped_tags, guardian)\n      @extras = { tag_groups: grouped_tag_counts }\n    else\n      tags = show_all_tags ? Tag.all : Tag.used_tags_in_regular_topics(guardian)\n      unrestricted_tags = DiscourseTagging.filter_visible(tags.where(target_tag_id: nil), guardian)\n\n      categories =\n        Category\n          .where(\"id IN (SELECT category_id FROM category_tags)\")\n          .where(\"id IN (?)\", guardian.allowed_category_ids)\n          .includes(:tags)\n\n      category_tag_counts =\n        categories\n          .map do |c|\n            category_tags =\n              self.class.tag_counts_json(\n                DiscourseTagging.filter_visible(c.tags.where(target_tag_id: nil), guardian),\n                guardian,\n              )\n            next if category_tags.empty?\n            { id: c.id, tags: category_tags }\n          end\n          .compact\n\n      @tags = self.class.tag_counts_json(unrestricted_tags, guardian)\n      @extras = { categories: category_tag_counts }\n    end\n\n    respond_to do |format|\n      format.html { render :index }\n\n      format.json { render json: { tags: @tags, extras: @extras } }\n    end\n  end\n\n  Discourse.filters.each do |filter|\n    define_method(\"show_#{filter}\") do\n      @tag_id = params[:tag_id].force_encoding(\"UTF-8\")\n      @additional_tags =\n        params[:additional_tag_ids].to_s.split(\"/\").map { |t| t.force_encoding(\"UTF-8\") }\n\n      list_opts = build_topic_list_options\n      @list = nil\n\n      if filter == :top\n        period = params[:period] || SiteSetting.top_page_default_timeframe.to_sym\n        TopTopic.validate_period(period)\n\n        @list = TopicQuery.new(current_user, list_opts).public_send(\"list_top_for\", period)\n        @list.for_period = period\n      else\n        @list = TopicQuery.new(current_user, list_opts).public_send(\"list_#{filter}\")\n      end\n\n      @list.more_topics_url = construct_url_with(:next, list_opts)\n      @list.prev_topics_url = construct_url_with(:prev, list_opts)\n      @rss = \"tag\"\n      @description_meta = I18n.t(\"rss_by_tag\", tag: tag_params.join(\" & \"))\n      @title = @description_meta\n\n      canonical_params = params.slice(:category_slug_path_with_id, :tag_id)\n      canonical_method = url_method(canonical_params)\n      canonical_url \"#{Discourse.base_url_no_prefix}#{public_send(canonical_method, *(canonical_params.values.map { |t| t.force_encoding(\"UTF-8\") }))}\"\n\n      if @list.topics.size == 0 && params[:tag_id] != \"none\" && !Tag.where_name(@tag_id).exists?\n        raise Discourse::NotFound.new(\"tag not found\", check_permalinks: true)\n      else\n        respond_with_list(@list)\n      end\n    end\n  end\n\n  def show\n    show_latest\n  end\n\n  def info\n    render_serialized(@tag, DetailedTagSerializer, rest_serializer: true, root: :tag_info)\n  end\n\n  def update\n    guardian.ensure_can_admin_tags!\n\n    tag = Tag.find_by_name(params[:tag_id])\n    raise Discourse::NotFound if tag.nil?\n\n    if (params[:tag][:id].present?)\n      new_tag_name = DiscourseTagging.clean_tag(params[:tag][:id])\n      tag.name = new_tag_name\n    end\n    tag.description = params[:tag][:description] if params[:tag]&.has_key?(:description)\n    if tag.save\n      StaffActionLogger.new(current_user).log_custom(\n        \"renamed_tag\",\n        previous_value: params[:tag_id],\n        new_value: new_tag_name,\n      )\n      render json: { tag: { id: tag.name, description: tag.description } }\n    else\n      render_json_error tag.errors.full_messages\n    end\n  end\n\n  def upload\n    require \"csv\"\n\n    guardian.ensure_can_admin_tags!\n\n    file = params[:file] || params[:files].first\n\n    hijack do\n      begin\n        Tag.transaction do\n          CSV.foreach(file.tempfile) do |row|\n            if row.length > 2\n              raise Discourse::InvalidParameters.new(I18n.t(\"tags.upload_row_too_long\"))\n            end\n\n            tag_name = DiscourseTagging.clean_tag(row[0])\n            tag_group_name = row[1] || nil\n\n            tag = Tag.find_by_name(tag_name) || Tag.create!(name: tag_name)\n\n            if tag_group_name\n              tag_group =\n                TagGroup.find_by(name: tag_group_name) || TagGroup.create!(name: tag_group_name)\n              tag.tag_groups << tag_group unless tag.tag_groups.include?(tag_group)\n            end\n          end\n        end\n        render json: success_json\n      rescue Discourse::InvalidParameters => e\n        render json: failed_json.merge(errors: [e.message]), status: 422\n      end\n    end\n  end\n\n  def list_unused\n    guardian.ensure_can_admin_tags!\n    render json: { tags: Tag.unused.pluck(:name) }\n  end\n\n  def destroy_unused\n    guardian.ensure_can_admin_tags!\n    tags = Tag.unused\n    StaffActionLogger.new(current_user).log_custom(\"deleted_unused_tags\", tags: tags.pluck(:name))\n    tags.destroy_all\n    render json: success_json\n  end\n\n  def destroy\n    guardian.ensure_can_admin_tags!\n    tag_name = params[:tag_id]\n    tag = Tag.find_by_name(tag_name)\n    raise Discourse::NotFound if tag.nil?\n\n    TopicCustomField.transaction do\n      tag.destroy\n      StaffActionLogger.new(current_user).log_custom(\"deleted_tag\", subject: tag_name)\n    end\n    render json: success_json\n  end\n\n  def tag_feed\n    discourse_expires_in 1.minute\n\n    tag_id = params[:tag_id]\n    @link = \"#{Discourse.base_url}/tag/#{tag_id}\"\n    @description = I18n.t(\"rss_by_tag\", tag: tag_id)\n    @title = \"#{SiteSetting.title} - #{@description}\"\n    @atom_link = \"#{Discourse.base_url}/tag/#{tag_id}.rss\"\n\n    query = TopicQuery.new(current_user, tags: [tag_id])\n    latest_results = query.latest_results\n    @topic_list = query.create_list(:by_tag, {}, latest_results)\n\n    render \"list/list\", formats: [:rss]\n  end\n\n  def search\n    filter_params = {\n      for_input: params[:filterForInput],\n      selected_tags: params[:selected_tags],\n      limit: params[:limit],\n      exclude_synonyms: params[:excludeSynonyms],\n      exclude_has_synonyms: params[:excludeHasSynonyms],\n    }\n\n    if filter_params[:limit] && filter_params[:limit].to_i < 0\n      raise Discourse::InvalidParameters.new(:limit)\n    end\n\n    filter_params[:category] = Category.find_by_id(params[:categoryId]) if params[:categoryId]\n\n    if !params[:q].blank?\n      clean_name = DiscourseTagging.clean_tag(params[:q])\n      filter_params[:term] = clean_name\n      filter_params[:order_search_results] = true\n    else\n      filter_params[:order_popularity] = true\n    end\n\n    tags_with_counts, filter_result_context =\n      DiscourseTagging.filter_allowed_tags(guardian, **filter_params, with_context: true)\n\n    tags = self.class.tag_counts_json(tags_with_counts, guardian)\n\n    json_response = { results: tags }\n\n    if clean_name && !tags.find { |h| h[:id].downcase == clean_name.downcase } &&\n         tag = Tag.where_name(clean_name).first\n      # filter_allowed_tags determined that the tag entered is not allowed\n      json_response[:forbidden] = params[:q]\n\n      if filter_params[:exclude_synonyms] && tag.synonym?\n        json_response[:forbidden_message] = I18n.t(\n          \"tags.forbidden.synonym\",\n          tag_name: tag.target_tag.name,\n        )\n      elsif filter_params[:exclude_has_synonyms] && tag.synonyms.exists?\n        json_response[:forbidden_message] = I18n.t(\n          \"tags.forbidden.has_synonyms\",\n          tag_name: tag.name,\n        )\n      else\n        category_names = tag.categories.where(id: guardian.allowed_category_ids).pluck(:name)\n        category_names +=\n          Category\n            .joins(tag_groups: :tags)\n            .where(id: guardian.allowed_category_ids, \"tags.id\": tag.id)\n            .pluck(:name)\n\n        if category_names.present?\n          category_names.uniq!\n          json_response[:forbidden_message] = I18n.t(\n            \"tags.forbidden.restricted_to\",\n            count: category_names.count,\n            tag_name: tag.name,\n            category_names: category_names.join(\", \"),\n          )\n        else\n          json_response[:forbidden_message] = I18n.t(\n            \"tags.forbidden.in_this_category\",\n            tag_name: tag.name,\n          )\n        end\n      end\n    end\n\n    if required_tag_group = filter_result_context[:required_tag_group]\n      json_response[:required_tag_group] = required_tag_group\n    end\n\n    render json: json_response\n  end\n\n  def notifications\n    tag = Tag.where_name(params[:tag_id]).first\n    raise Discourse::NotFound unless tag\n    level =\n      tag.tag_users.where(user: current_user).first.try(:notification_level) ||\n        TagUser.notification_levels[:regular]\n    render json: { tag_notification: { id: tag.name, notification_level: level.to_i } }\n  end\n\n  def update_notifications\n    tag = Tag.find_by_name(params[:tag_id])\n    raise Discourse::NotFound unless tag\n    level = params[:tag_notification][:notification_level].to_i\n    TagUser.change(current_user.id, tag.id, level)\n    render_serialized(current_user, UserTagNotificationsSerializer, root: false)\n  end\n\n  def personal_messages\n    guardian.ensure_can_tag_pms!\n    allowed_user = fetch_user_from_params\n    raise Discourse::NotFound if allowed_user.blank?\n    raise Discourse::NotFound if current_user.id != allowed_user.id && !@guardian.is_admin?\n    pm_tags = Tag.pm_tags(guardian: guardian, allowed_user: allowed_user)\n\n    render json: { tags: pm_tags }\n  end\n\n  def create_synonyms\n    guardian.ensure_can_admin_tags!\n    value = DiscourseTagging.add_or_create_synonyms_by_name(@tag, params[:synonyms])\n    if value.is_a?(Array)\n      render json:\n               failed_json.merge(\n                 failed_tags:\n                   value.inject({}) do |h, t|\n                     h[t.name] = t.errors.full_messages.first\n                     h\n                   end,\n               )\n    else\n      render json: success_json\n    end\n  end\n\n  def destroy_synonym\n    guardian.ensure_can_admin_tags!\n    synonym = Tag.where_name(params[:synonym_id]).first\n    raise Discourse::NotFound unless synonym\n    if synonym.target_tag == @tag\n      synonym.update!(target_tag: nil)\n      render json: success_json\n    else\n      render json: failed_json, status: 400\n    end\n  end\n\n  private\n\n  def fetch_tag\n    @tag = Tag.find_by_name(params[:tag_id].force_encoding(\"UTF-8\"))\n    raise Discourse::NotFound unless @tag\n  end\n\n  def ensure_tags_enabled\n    raise Discourse::NotFound unless SiteSetting.tagging_enabled?\n  end\n\n  def ensure_visible\n    if DiscourseTagging.hidden_tag_names(guardian).include?(params[:tag_id])\n      raise Discourse::NotFound\n    end\n  end\n\n  def self.tag_counts_json(tags, guardian)\n    show_pm_tags = guardian.can_tag_pms?\n    target_tags = Tag.where(id: tags.map(&:target_tag_id).compact.uniq).select(:id, :name)\n\n    tags\n      .map do |t|\n        topic_count = t.public_send(Tag.topic_count_column(guardian))\n\n        next if topic_count == 0 && t.pm_topic_count > 0 && !show_pm_tags\n\n        {\n          id: t.name,\n          text: t.name,\n          name: t.name,\n          description: t.description,\n          count: topic_count,\n          pm_count: show_pm_tags ? t.pm_topic_count : 0,\n          target_tag:\n            t.target_tag_id ? target_tags.find { |x| x.id == t.target_tag_id }&.name : nil,\n        }\n      end\n      .compact\n  end\n\n  def set_category\n    if request.path_parameters.include?(:category_slug_path_with_id)\n      @filter_on_category = Category.find_by_slug_path_with_id(params[:category_slug_path_with_id])\n    else\n      slug_or_id = params[:category]\n      return true if slug_or_id.nil?\n\n      @filter_on_category = Category.query_category(slug_or_id, nil)\n    end\n\n    if !@filter_on_category\n      permalink = Permalink.find_by_url(\"c/#{params[:category_slug_path_with_id]}\")\n      if permalink.present? && permalink.category_id\n        return(\n          redirect_to \"#{Discourse.base_path}/tags#{permalink.target_url}/#{params[:tag_id]}\",\n                      status: :moved_permanently\n        )\n      end\n    end\n\n    if !(@filter_on_category && guardian.can_see?(@filter_on_category))\n      # 404 on 'access denied' to avoid leaking existence of category\n      raise Discourse::NotFound\n    end\n  end\n\n  def page_params\n    route_params = { format: \"json\" }\n\n    if @filter_on_category\n      if request.path_parameters.include?(:category_slug_path_with_id)\n        slug_path = @filter_on_category.slug_path\n\n        route_params[:category_slug_path_with_id] = (\n          slug_path + [@filter_on_category.id.to_s]\n        ).join(\"/\")\n      else\n        route_params[:category] = @filter_on_category.slug_for_url\n      end\n    end\n\n    route_params\n  end\n\n  def next_page_params\n    page_params.merge(page: params[:page].to_i + 1)\n  end\n\n  def prev_page_params\n    pg = params[:page].to_i\n    if pg > 1\n      page_params.merge(page: pg - 1)\n    else\n      page_params.merge(page: nil)\n    end\n  end\n\n  def url_method(opts = {})\n    if opts[:category_slug_path_with_id]\n      \"tag_category_#{action_name}_path\"\n    else\n      \"tag_#{action_name}_path\"\n    end\n  end\n\n  def construct_url_with(action, opts)\n    page_params =\n      case action\n      when :prev\n        prev_page_params\n      when :next\n        next_page_params\n      else\n        raise \"unreachable\"\n      end\n\n    opts = opts.merge(page_params)\n    opts.delete(:category) if opts.include?(:category_slug_path_with_id)\n\n    method = url_method(opts)\n\n    begin\n      url = public_send(method, opts)\n    rescue ActionController::UrlGenerationError\n      raise Discourse::NotFound\n    end\n\n    url.sub(\".json?\", \"?\")\n  end\n\n  def build_topic_list_options\n    options =\n      super.merge(\n        page: params[:page],\n        topic_ids: param_to_integer_list(:topic_ids),\n        category: @filter_on_category ? @filter_on_category.id : params[:category],\n        order: params[:order],\n        ascending: params[:ascending],\n        min_posts: params[:min_posts],\n        max_posts: params[:max_posts],\n        status: params[:status],\n        filter: params[:filter],\n        state: params[:state],\n        search: params[:search],\n        q: params[:q],\n      )\n    options[:no_subcategories] = true if params[:no_subcategories] == true ||\n      params[:no_subcategories] == \"true\"\n    options[:per_page] = params[:per_page].to_i.clamp(1, 30) if params[:per_page].present?\n\n    if params[:tag_id] == \"none\"\n      options.delete(:tags)\n      options[:no_tags] = true\n    else\n      options[:tags] = tag_params\n      options[:match_all_tags] ||= true\n    end\n\n    options\n  end\n\n  def tag_params\n    [@tag_id].concat(Array(@additional_tags))\n  end\nend\n", "# frozen_string_literal: true\n\nRSpec.describe TagsController do\n  fab!(:user) { Fabricate(:user) }\n  fab!(:admin) { Fabricate(:admin) }\n  fab!(:regular_user) { Fabricate(:trust_level_4) }\n  fab!(:moderator) { Fabricate(:moderator) }\n  fab!(:category) { Fabricate(:category) }\n  fab!(:subcategory) { Fabricate(:category, parent_category_id: category.id) }\n\n  before { SiteSetting.tagging_enabled = true }\n\n  describe \"#index\" do\n    fab!(:test_tag) { Fabricate(:tag, name: \"test\") }\n    fab!(:topic_tag) do\n      Fabricate(:tag, name: \"topic-test\", public_topic_count: 1, staff_topic_count: 1)\n    end\n    fab!(:synonym) { Fabricate(:tag, name: \"synonym\", target_tag: topic_tag) }\n\n    shared_examples \"retrieves the right tags\" do\n      it \"retrieves all tags as a staff user\" do\n        sign_in(admin)\n\n        get \"/tags.json\"\n\n        expect(response.status).to eq(200)\n\n        tags = response.parsed_body[\"tags\"]\n\n        expect(tags[0][\"name\"]).to eq(test_tag.name)\n        expect(tags[0][\"count\"]).to eq(0)\n        expect(tags[0][\"pm_count\"]).to eq(0)\n\n        expect(tags[1][\"name\"]).to eq(topic_tag.name)\n        expect(tags[1][\"count\"]).to eq(1)\n        expect(tags[1][\"pm_count\"]).to eq(0)\n      end\n\n      it \"only retrieve tags that have been used in public topics for non-staff user\" do\n        sign_in(user)\n\n        get \"/tags.json\"\n\n        expect(response.status).to eq(200)\n\n        tags = response.parsed_body[\"tags\"]\n        expect(tags.length).to eq(1)\n\n        expect(tags[0][\"name\"]).to eq(topic_tag.name)\n        expect(tags[0][\"count\"]).to eq(1)\n        expect(tags[0][\"pm_count\"]).to eq(0)\n      end\n    end\n\n    context \"with pm_tags_allowed_for_groups\" do\n      fab!(:admin) { Fabricate(:admin) }\n      fab!(:topic) { Fabricate(:topic, tags: [topic_tag]) }\n      fab!(:pm) do\n        Fabricate(\n          :private_message_topic,\n          tags: [test_tag],\n          topic_allowed_users: [Fabricate.build(:topic_allowed_user, user: admin)],\n        )\n      end\n\n      context \"when enabled\" do\n        before do\n          SiteSetting.pm_tags_allowed_for_groups = \"1|2|3\"\n          sign_in(admin)\n        end\n\n        it \"shows topic tags and pm tags\" do\n          get \"/tags.json\"\n          tags = response.parsed_body[\"tags\"]\n          expect(tags.length).to eq(2)\n\n          serialized_tag = tags.find { |t| t[\"id\"] == topic_tag.name }\n          expect(serialized_tag[\"count\"]).to eq(2)\n          expect(serialized_tag[\"pm_count\"]).to eq(0)\n\n          serialized_tag = tags.find { |t| t[\"id\"] == test_tag.name }\n          expect(serialized_tag[\"count\"]).to eq(0)\n          expect(serialized_tag[\"pm_count\"]).to eq(1)\n        end\n      end\n\n      context \"when disabled\" do\n        before do\n          SiteSetting.pm_tags_allowed_for_groups = \"\"\n          sign_in(admin)\n        end\n\n        it \"hides pm tags\" do\n          get \"/tags.json\"\n          tags = response.parsed_body[\"tags\"]\n          expect(tags.length).to eq(1)\n          expect(tags[0][\"id\"]).to eq(topic_tag.name)\n        end\n      end\n    end\n\n    context \"with tags_listed_by_group enabled\" do\n      before { SiteSetting.tags_listed_by_group = true }\n      include_examples \"retrieves the right tags\"\n\n      it \"works for tags in groups\" do\n        tag_group = Fabricate(:tag_group, tags: [test_tag, topic_tag, synonym])\n\n        get \"/tags.json\"\n\n        expect(response.status).to eq(200)\n        tags = response.parsed_body[\"tags\"]\n        expect(tags.length).to eq(0)\n        group = response.parsed_body.dig(\"extras\", \"tag_groups\")&.first\n        expect(group).to be_present\n        expect(group[\"tags\"].length).to eq(2)\n        expect(group[\"tags\"].map { |t| t[\"id\"] }).to contain_exactly(test_tag.name, topic_tag.name)\n      end\n\n      it \"does not result in N+1 queries with multiple tag_groups\" do\n        tag_group1 = Fabricate(:tag_group, tags: [test_tag, topic_tag, synonym])\n\n        # warm up\n        get \"/tags.json\"\n        expect(response.status).to eq(200)\n\n        initial_sql_queries_count =\n          track_sql_queries do\n            get \"/tags.json\"\n\n            expect(response.status).to eq(200)\n\n            tag_groups = response.parsed_body.dig(\"extras\", \"tag_groups\")\n\n            expect(tag_groups.length).to eq(1)\n            expect(tag_groups.map { |tag_group| tag_group[\"name\"] }).to contain_exactly(\n              tag_group1.name,\n            )\n          end.length\n\n        tag_group2 = Fabricate(:tag_group, tags: [topic_tag])\n\n        new_sql_queries_count =\n          track_sql_queries do\n            get \"/tags.json\"\n\n            expect(response.status).to eq(200)\n\n            tag_groups = response.parsed_body.dig(\"extras\", \"tag_groups\")\n\n            expect(tag_groups.length).to eq(2)\n            expect(tag_groups.map { |tag_group| tag_group[\"name\"] }).to contain_exactly(\n              tag_group1.name,\n              tag_group2.name,\n            )\n          end.length\n\n        expect(new_sql_queries_count).to be <= initial_sql_queries_count\n      end\n    end\n\n    context \"with tags_listed_by_group disabled\" do\n      before { SiteSetting.tags_listed_by_group = false }\n      include_examples \"retrieves the right tags\"\n    end\n\n    context \"with hidden tags\" do\n      before { create_hidden_tags([\"staff1\"]) }\n\n      it \"is returned to admins\" do\n        sign_in(admin)\n        get \"/tags.json\"\n        expect(response.parsed_body[\"tags\"].map { |t| t[\"text\"] }).to include(\"staff1\")\n        expect(response.parsed_body[\"extras\"][\"categories\"]).to be_empty\n      end\n\n      it \"is not returned to anon\" do\n        get \"/tags.json\"\n        expect(response.parsed_body[\"tags\"].map { |t| t[\"text\"] }).to_not include(\"staff1\")\n        expect(response.parsed_body[\"extras\"][\"categories\"]).to be_empty\n      end\n\n      it \"is not returned to regular user\" do\n        sign_in(user)\n        get \"/tags.json\"\n        expect(response.parsed_body[\"tags\"].map { |t| t[\"text\"] }).to_not include(\"staff1\")\n        expect(response.parsed_body[\"extras\"][\"categories\"]).to be_empty\n      end\n\n      context \"when restricted to a category\" do\n        before { category.tags = [Tag.find_by_name(\"staff1\")] }\n\n        it \"is returned to admins\" do\n          sign_in(admin)\n          get \"/tags.json\"\n          expect(response.parsed_body[\"tags\"].map { |t| t[\"text\"] }).to include(\"staff1\")\n          categories = response.parsed_body[\"extras\"][\"categories\"]\n          expect(categories.length).to eq(1)\n          expect(categories.first[\"tags\"].map { |t| t[\"text\"] }).to include(\"staff1\")\n        end\n\n        it \"is not returned to anon\" do\n          get \"/tags.json\"\n          expect(response.parsed_body[\"tags\"].map { |t| t[\"text\"] }).to_not include(\"staff1\")\n          expect(response.parsed_body[\"extras\"][\"categories\"]).to be_empty\n        end\n\n        it \"is not returned to regular user\" do\n          sign_in(user)\n          get \"/tags.json\"\n          expect(response.parsed_body[\"tags\"].map { |t| t[\"text\"] }).to_not include(\"staff1\")\n          expect(response.parsed_body[\"extras\"][\"categories\"]).to be_empty\n        end\n      end\n\n      context \"when listed by group\" do\n        before { SiteSetting.tags_listed_by_group = true }\n\n        it \"is returned to admins\" do\n          sign_in(admin)\n          get \"/tags.json\"\n          expect(response.parsed_body[\"tags\"].map { |t| t[\"text\"] }).to_not include(\"staff1\")\n          tag_groups = response.parsed_body[\"extras\"][\"tag_groups\"]\n          expect(tag_groups.length).to eq(1)\n          expect(tag_groups.first[\"tags\"].map { |t| t[\"text\"] }).to include(\"staff1\")\n        end\n\n        it \"is not returned to anon\" do\n          get \"/tags.json\"\n          expect(response.parsed_body[\"tags\"].map { |t| t[\"text\"] }).to_not include(\"staff1\")\n          expect(response.parsed_body[\"extras\"][\"tag_groups\"]).to be_empty\n        end\n\n        it \"is not returned to regular user\" do\n          sign_in(user)\n          get \"/tags.json\"\n          expect(response.parsed_body[\"tags\"].map { |t| t[\"text\"] }).to_not include(\"staff1\")\n          expect(response.parsed_body[\"extras\"][\"tag_groups\"]).to be_empty\n        end\n      end\n    end\n  end\n\n  describe \"#show\" do\n    fab!(:tag) { Fabricate(:tag, name: \"test\") }\n    fab!(:topic_without_tags) { Fabricate(:topic) }\n    fab!(:topic_with_tags) { Fabricate(:topic, tags: [tag]) }\n\n    it \"should return the right response\" do\n      get \"/tag/test.json\"\n\n      expect(response.status).to eq(200)\n\n      json = response.parsed_body\n\n      topic_list = json[\"topic_list\"]\n\n      expect(topic_list[\"tags\"].map { |t| t[\"id\"] }).to contain_exactly(tag.id)\n    end\n\n    it \"should handle invalid tags\" do\n      get \"/tag/%2ftest%2f\"\n      expect(response.status).to eq(404)\n    end\n\n    it \"should handle synonyms\" do\n      synonym = Fabricate(:tag, target_tag: tag)\n      get \"/tag/#{synonym.name}\"\n      expect(response.status).to eq(200)\n    end\n\n    it \"does not show staff-only tags\" do\n      tag_group = Fabricate(:tag_group, permissions: { \"staff\" => 1 }, tag_names: [\"test\"])\n\n      get \"/tag/test\"\n      expect(response.status).to eq(404)\n\n      sign_in(admin)\n\n      get \"/tag/test\"\n      expect(response.status).to eq(200)\n    end\n\n    it \"handles special tag 'none'\" do\n      SiteSetting.pm_tags_allowed_for_groups = \"1|2|3\"\n\n      sign_in(admin)\n\n      get \"/tag/none.json\"\n      expect(response.parsed_body[\"topic_list\"][\"topics\"].length).to eq(1)\n    end\n\n    context \"with a category in the path\" do\n      fab!(:topic_in_category) { Fabricate(:topic, tags: [tag], category: category) }\n\n      fab!(:topic_in_category_without_tag) { Fabricate(:topic, category: category) }\n\n      fab!(:topic_out_of_category) { Fabricate(:topic, tags: [tag]) }\n\n      it \"should produce the topic inside the category and not the topic outside of it\" do\n        get \"/tags/c/#{category.slug}/#{tag.name}.json\"\n\n        topic_ids = response.parsed_body[\"topic_list\"][\"topics\"].map { |x| x[\"id\"] }\n        expect(topic_ids).to include(topic_in_category.id)\n        expect(topic_ids).to_not include(topic_out_of_category.id)\n        expect(topic_ids).to_not include(topic_in_category_without_tag.id)\n      end\n\n      it \"should produce the right next topic URL\" do\n        get \"/tags/c/#{category.slug_path.join(\"/\")}/#{category.id}/#{tag.name}.json?per_page=1\"\n\n        expect(response.parsed_body[\"topic_list\"][\"more_topics_url\"]).to start_with(\n          \"/tags/c/#{category.slug_path.join(\"/\")}/#{category.id}/#{tag.name}\",\n        )\n      end\n\n      it \"should 404 for invalid category path\" do\n        get \"/tags/c/#{category.slug_path.join(\"/\")}/#{category.id}/somerandomstring/#{tag.name}.json?per_page=1\"\n\n        expect(response.status).to eq(404)\n      end\n\n      it \"should 404 for secure categories\" do\n        c = Fabricate(:private_category, group: Fabricate(:group))\n        get \"/tags/c/#{c.slug_path.join(\"/\")}/#{c.id}/#{tag.name}.json\"\n\n        expect(response.status).to eq(404)\n      end\n    end\n\n    context \"with a subcategory in the path\" do\n      fab!(:topic_in_subcategory) { Fabricate(:topic, tags: [tag], category: subcategory) }\n\n      fab!(:topic_in_subcategory_without_tag) { Fabricate(:topic, category: subcategory) }\n\n      fab!(:topic_out_of_subcategory) { Fabricate(:topic, tags: [tag]) }\n\n      it \"should produce the topic inside the subcategory and not the topic outside of it\" do\n        get \"/tags/c/#{category.slug}/#{subcategory.slug}/#{tag.name}.json\"\n\n        topic_ids = response.parsed_body[\"topic_list\"][\"topics\"].map { |x| x[\"id\"] }\n        expect(topic_ids).to include(topic_in_subcategory.id)\n        expect(topic_ids).to_not include(topic_out_of_subcategory.id)\n        expect(topic_ids).to_not include(topic_in_subcategory_without_tag.id)\n      end\n    end\n  end\n\n  describe \"#info\" do\n    fab!(:tag) { Fabricate(:tag, name: \"test\") }\n    let(:synonym) { Fabricate(:tag, name: \"synonym\", target_tag: tag) }\n\n    it \"returns 404 if tag not found\" do\n      get \"/tag/nope/info.json\"\n      expect(response.status).to eq(404)\n    end\n\n    it \"can handle tag with no synonyms\" do\n      get \"/tag/#{tag.name}/info.json\"\n      expect(response.status).to eq(200)\n      expect(response.parsed_body.dig(\"tag_info\", \"name\")).to eq(tag.name)\n      expect(response.parsed_body.dig(\"tag_info\", \"synonyms\")).to be_empty\n      expect(response.parsed_body.dig(\"tag_info\", \"category_ids\")).to be_empty\n      expect(response.parsed_body.dig(\"tag_info\", \"category_restricted\")).to eq(false)\n    end\n\n    it \"can handle a synonym\" do\n      get \"/tag/#{synonym.name}/info.json\"\n      expect(response.status).to eq(200)\n      expect(response.parsed_body.dig(\"tag_info\", \"name\")).to eq(synonym.name)\n      expect(response.parsed_body.dig(\"tag_info\", \"synonyms\")).to be_empty\n      expect(response.parsed_body.dig(\"tag_info\", \"category_ids\")).to be_empty\n      expect(response.parsed_body.dig(\"tag_info\", \"category_restricted\")).to eq(false)\n    end\n\n    it \"can return a tag's synonyms\" do\n      synonym\n      get \"/tag/#{tag.name}/info.json\"\n      expect(response.status).to eq(200)\n      expect(response.parsed_body.dig(\"tag_info\", \"synonyms\").map { |t| t[\"text\"] }).to eq(\n        [synonym.name],\n      )\n    end\n\n    it \"returns 404 if tag is staff-only\" do\n      tag_group = Fabricate(:tag_group, permissions: { \"staff\" => 1 }, tag_names: [\"test\"])\n      get \"/tag/test/info.json\"\n      expect(response.status).to eq(404)\n    end\n\n    it \"staff-only tags can be retrieved for staff user\" do\n      sign_in(admin)\n      tag_group = Fabricate(:tag_group, permissions: { \"staff\" => 1 }, tag_names: [\"test\"])\n      get \"/tag/test/info.json\"\n      expect(response.status).to eq(200)\n    end\n\n    it \"can return category restrictions\" do\n      category.update!(tags: [tag])\n      category2 = Fabricate(:category)\n      tag_group = Fabricate(:tag_group, tags: [tag])\n      category2.update!(tag_groups: [tag_group])\n      staff_category = Fabricate(:private_category, group: Fabricate(:group), tags: [tag])\n      get \"/tag/#{tag.name}/info.json\"\n      expect(response.parsed_body.dig(\"tag_info\", \"category_ids\")).to contain_exactly(\n        category.id,\n        category2.id,\n      )\n      expect(response.parsed_body[\"categories\"]).to be_present\n      expect(response.parsed_body.dig(\"tag_info\", \"category_restricted\")).to eq(true)\n    end\n\n    context \"when tag belongs to a tag group\" do\n      fab!(:tag_group) { Fabricate(:tag_group, tags: [tag]) }\n\n      it \"returns tag groups if tag groups are visible\" do\n        SiteSetting.tags_listed_by_group = true\n        get \"/tag/#{tag.name}/info.json\"\n        expect(response.parsed_body.dig(\"tag_info\", \"tag_group_names\")).to eq([tag_group.name])\n      end\n\n      it \"doesn't return tag groups if tag groups aren't visible\" do\n        SiteSetting.tags_listed_by_group = false\n        get \"/tag/#{tag.name}/info.json\"\n        expect(response.parsed_body[\"tag_info\"].has_key?(\"tag_group_names\")).to eq(false)\n      end\n\n      context \"when restricted to a private category\" do\n        let!(:private_category) do\n          Fabricate(\n            :private_category,\n            group: Fabricate(:group),\n            tag_groups: [tag_group],\n            allow_global_tags: true,\n          )\n        end\n\n        it \"can return categories to users who can access them\" do\n          sign_in(admin)\n          get \"/tag/#{tag.name}/info.json\"\n          expect(response.parsed_body.dig(\"tag_info\", \"category_ids\")).to contain_exactly(\n            private_category.id,\n          )\n          expect(response.parsed_body[\"categories\"]).to be_present\n          expect(response.parsed_body.dig(\"tag_info\", \"category_restricted\")).to eq(true)\n        end\n\n        it \"can indicate category restriction to users who can't access them\" do\n          sign_in(user)\n          get \"/tag/#{tag.name}/info.json\"\n          expect(response.parsed_body.dig(\"tag_info\", \"category_ids\")).to be_empty\n          expect(response.parsed_body[\"categories\"]).to be_blank\n          expect(response.parsed_body.dig(\"tag_info\", \"category_restricted\")).to eq(true)\n        end\n\n        it \"can indicate category restriction to anon\" do\n          get \"/tag/#{tag.name}/info.json\"\n          expect(response.parsed_body.dig(\"tag_info\", \"category_ids\")).to be_empty\n          expect(response.parsed_body[\"categories\"]).to be_blank\n          expect(response.parsed_body.dig(\"tag_info\", \"category_restricted\")).to eq(true)\n        end\n      end\n    end\n  end\n\n  describe \"#update\" do\n    fab!(:tag) { Fabricate(:tag) }\n\n    before do\n      tag\n      sign_in(admin)\n    end\n\n    it \"triggers a extensibility event\" do\n      event =\n        DiscourseEvent\n          .track_events { put \"/tag/#{tag.name}.json\", params: { tag: { id: \"hello\" } } }\n          .last\n\n      expect(event[:event_name]).to eq(:tag_updated)\n      expect(event[:params].first).to eq(tag)\n    end\n  end\n\n  describe \"#personal_messages\" do\n    fab!(:personal_message) do\n      Fabricate(\n        :private_message_topic,\n        user: regular_user,\n        topic_allowed_users: [\n          Fabricate.build(:topic_allowed_user, user: regular_user),\n          Fabricate.build(:topic_allowed_user, user: moderator),\n          Fabricate.build(:topic_allowed_user, user: admin),\n        ],\n      )\n    end\n\n    fab!(:tag) { Fabricate(:tag, topics: [personal_message], name: \"test\") }\n\n    before { SiteSetting.pm_tags_allowed_for_groups = \"1|2|3\" }\n\n    context \"as a regular user\" do\n      it \"can't see pm tags\" do\n        get \"/tags/personal_messages/#{regular_user.username}.json\"\n\n        expect(response.status).to eq(403)\n      end\n    end\n\n    context \"as an moderator\" do\n      before { sign_in(moderator) }\n\n      it \"can't see pm tags for regular user\" do\n        get \"/tags/personal_messages/#{regular_user.username}.json\"\n\n        expect(response.status).to eq(404)\n      end\n\n      it \"can see their own pm tags\" do\n        get \"/tags/personal_messages/#{moderator.username}.json\"\n\n        expect(response.status).to eq(200)\n\n        tag = response.parsed_body[\"tags\"]\n        expect(tag[0][\"id\"]).to eq(\"test\")\n      end\n    end\n\n    context \"as an admin\" do\n      before { sign_in(admin) }\n\n      it \"can see pm tags for regular user\" do\n        get \"/tags/personal_messages/#{regular_user.username}.json\"\n\n        expect(response.status).to eq(200)\n\n        tag = response.parsed_body[\"tags\"]\n        expect(tag[0][\"id\"]).to eq(\"test\")\n      end\n\n      it \"can see their own pm tags\" do\n        get \"/tags/personal_messages/#{admin.username}.json\"\n\n        expect(response.status).to eq(200)\n\n        tag = response.parsed_body[\"tags\"]\n        expect(tag[0][\"id\"]).to eq(\"test\")\n      end\n\n      it \"works with usernames with a period\" do\n        admin.update!(username: \"test.test\")\n\n        get \"/tags/personal_messages/#{admin.username}.json\"\n\n        expect(response.status).to eq(200)\n      end\n    end\n  end\n\n  describe \"#show_latest\" do\n    fab!(:tag) { Fabricate(:tag) }\n    fab!(:other_tag) { Fabricate(:tag) }\n    fab!(:third_tag) { Fabricate(:tag) }\n\n    fab!(:single_tag_topic) { Fabricate(:topic, tags: [tag]) }\n    fab!(:multi_tag_topic) { Fabricate(:topic, tags: [tag, other_tag]) }\n    fab!(:all_tag_topic) { Fabricate(:topic, tags: [tag, other_tag, third_tag]) }\n\n    context \"with tagging disabled\" do\n      it \"returns 404\" do\n        SiteSetting.tagging_enabled = false\n        get \"/tag/#{tag.name}/l/latest.json\"\n        expect(response.status).to eq(404)\n      end\n    end\n\n    context \"with tagging enabled\" do\n      def parse_topic_ids\n        response.parsed_body[\"topic_list\"][\"topics\"].map { |topic| topic[\"id\"] }\n      end\n\n      it \"can filter by tag\" do\n        get \"/tag/#{tag.name}/l/latest.json\"\n        expect(response.status).to eq(200)\n      end\n\n      it \"can render a topic list from the latest endpoint\" do\n        get \"/tag/#{tag.name}/l/latest\"\n        expect(response.status).to eq(200)\n        expect(response.body).to include(\"topic-list\")\n      end\n\n      it \"can filter by two tags\" do\n        single_tag_topic\n        multi_tag_topic\n        all_tag_topic\n\n        get \"/tag/#{tag.name}/l/latest.json\", params: { additional_tag_ids: other_tag.name }\n\n        expect(response.status).to eq(200)\n\n        topic_ids = parse_topic_ids\n        expect(topic_ids).to include(all_tag_topic.id)\n        expect(topic_ids).to include(multi_tag_topic.id)\n        expect(topic_ids).to_not include(single_tag_topic.id)\n      end\n\n      it \"can filter by multiple tags\" do\n        single_tag_topic\n        multi_tag_topic\n        all_tag_topic\n\n        get \"/tag/#{tag.name}/l/latest.json\",\n            params: {\n              additional_tag_ids: \"#{other_tag.name}/#{third_tag.name}\",\n            }\n\n        expect(response.status).to eq(200)\n\n        topic_ids = parse_topic_ids\n        expect(topic_ids).to include(all_tag_topic.id)\n        expect(topic_ids).to_not include(multi_tag_topic.id)\n        expect(topic_ids).to_not include(single_tag_topic.id)\n      end\n\n      it \"does not find any tags when a tag which doesn't exist is passed\" do\n        single_tag_topic\n\n        get \"/tag/#{tag.name}/l/latest.json\", params: { additional_tag_ids: \"notatag\" }\n\n        expect(response.status).to eq(200)\n\n        topic_ids = parse_topic_ids\n        expect(topic_ids).to_not include(single_tag_topic.id)\n      end\n\n      it \"can filter by category and tag\" do\n        get \"/tags/c/#{category.slug}/#{tag.name}/l/latest.json\"\n        expect(response.status).to eq(200)\n      end\n\n      it \"can filter by category, sub-category, and tag\" do\n        get \"/tags/c/#{category.slug}/#{subcategory.slug}/#{tag.name}/l/latest.json\"\n        expect(response.status).to eq(200)\n      end\n\n      it \"can filter by category, no sub-category, and tag\" do\n        get \"/tags/c/#{category.slug}/none/#{tag.name}/l/latest.json\"\n        expect(response.status).to eq(200)\n      end\n\n      it \"can handle subcategories with the same name\" do\n        category2 = Fabricate(:category)\n        subcategory2 =\n          Fabricate(\n            :category,\n            parent_category_id: category2.id,\n            name: subcategory.name,\n            slug: subcategory.slug,\n          )\n        t = Fabricate(:topic, category_id: subcategory2.id, tags: [other_tag])\n        get \"/tags/c/#{category2.slug}/#{subcategory2.slug}/#{other_tag.name}/l/latest.json\"\n\n        expect(response.status).to eq(200)\n\n        topic_ids = parse_topic_ids\n        expect(topic_ids).to include(t.id)\n      end\n\n      context \"when logged in\" do\n        before { sign_in(user) }\n\n        it \"can filter by bookmarked\" do\n          get \"/tag/#{tag.name}/l/bookmarks.json\"\n\n          expect(response.status).to eq(200)\n        end\n\n        context \"with muted tags\" do\n          before do\n            TagUser.create!(\n              user_id: user.id,\n              tag_id: tag.id,\n              notification_level: CategoryUser.notification_levels[:muted],\n            )\n          end\n\n          it \"includes topics when filtered by muted tag\" do\n            single_tag_topic\n\n            get \"/tag/#{tag.name}/l/latest.json\"\n            expect(response.status).to eq(200)\n\n            topic_ids = parse_topic_ids\n            expect(topic_ids).to include(single_tag_topic.id)\n          end\n\n          it \"includes topics when filtered by category and muted tag\" do\n            category = Fabricate(:category)\n            single_tag_topic.update!(category: category)\n\n            get \"/tags/c/#{category.slug}/#{tag.name}/l/latest.json\"\n            expect(response.status).to eq(200)\n\n            topic_ids = parse_topic_ids\n            expect(topic_ids).to include(single_tag_topic.id)\n          end\n        end\n      end\n    end\n  end\n\n  describe \"#show_top\" do\n    fab!(:tag) { Fabricate(:tag) }\n\n    fab!(:category) { Fabricate(:category) }\n    fab!(:topic) { Fabricate(:topic, category: category) }\n    fab!(:tag_topic) { Fabricate(:topic, category: category, tags: [tag]) }\n    fab!(:tag_topic2) { Fabricate(:topic, category: category, tags: [tag]) }\n\n    before do\n      SiteSetting.top_page_default_timeframe = \"all\"\n      TopTopic.create!(topic: topic, all_score: 1)\n      TopTopic.create!(topic: tag_topic, all_score: 1)\n      TopTopic.create!(topic: tag_topic2, daily_score: 1)\n    end\n\n    it \"can filter by tag\" do\n      get \"/tag/#{tag.name}/l/top.json\"\n      expect(response.status).to eq(200)\n\n      topic_ids = response.parsed_body[\"topic_list\"][\"topics\"].map { |topic| topic[\"id\"] }\n      expect(topic_ids).to eq([tag_topic.id])\n    end\n\n    it \"can filter by tag and period\" do\n      get \"/tag/#{tag.name}/l/top.json?period=daily\"\n      expect(response.status).to eq(200)\n\n      list = response.parsed_body[\"topic_list\"]\n      topic_ids = list[\"topics\"].map { |topic| topic[\"id\"] }\n      expect(topic_ids).to eq([tag_topic2.id])\n      expect(list[\"for_period\"]).to eq(\"daily\")\n    end\n\n    it \"can filter by both category and tag\" do\n      get \"/tags/c/#{category.slug}/#{category.id}/#{tag.name}/l/top.json\"\n      expect(response.status).to eq(200)\n\n      topic_ids = response.parsed_body[\"topic_list\"][\"topics\"].map { |topic| topic[\"id\"] }\n      expect(topic_ids).to eq([tag_topic.id])\n    end\n\n    it \"raises an error if the period is not valid\" do\n      get \"/tag/#{tag.name}/l/top.json?period=decadely\"\n      expect(response.status).to eq(400)\n    end\n  end\n\n  describe \"#search\" do\n    context \"with tagging disabled\" do\n      it \"returns 404\" do\n        SiteSetting.tagging_enabled = false\n        get \"/tags/filter/search.json\", params: { q: \"stuff\" }\n        expect(response.status).to eq(404)\n      end\n    end\n\n    context \"with tagging enabled\" do\n      it \"can return some tags\" do\n        tag_names = %w[stuff stinky stumped]\n        tag_names.each { |name| Fabricate(:tag, name: name) }\n        get \"/tags/filter/search.json\", params: { q: \"stu\" }\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"results\"].map { |j| j[\"id\"] }.sort).to eq(%w[stuff stumped])\n      end\n\n      it \"returns tags ordered by public_topic_count, and prioritises exact matches\" do\n        Fabricate(:tag, name: \"tag1\", public_topic_count: 10, staff_topic_count: 10)\n        Fabricate(:tag, name: \"tag2\", public_topic_count: 100, staff_topic_count: 100)\n        Fabricate(:tag, name: \"tag\", public_topic_count: 1, staff_topic_count: 1)\n\n        get \"/tags/filter/search.json\", params: { q: \"tag\", limit: 2 }\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"results\"].map { |j| j[\"id\"] }).to eq(%w[tag tag2])\n      end\n\n      context \"with category restriction\" do\n        fab!(:yup) { Fabricate(:tag, name: \"yup\") }\n        fab!(:category) { Fabricate(:category, tags: [yup]) }\n\n        it \"can say if given tag is not allowed\" do\n          nope = Fabricate(:tag, name: \"nope\")\n          get \"/tags/filter/search.json\", params: { q: nope.name, categoryId: category.id }\n          expect(response.status).to eq(200)\n          expect(response.parsed_body[\"results\"].map { |j| j[\"id\"] }.sort).to eq([])\n          expect(response.parsed_body[\"forbidden\"]).to be_present\n          expect(response.parsed_body[\"forbidden_message\"]).to eq(\n            I18n.t(\"tags.forbidden.in_this_category\", tag_name: nope.name),\n          )\n        end\n\n        it \"can say if given tag is restricted to different category\" do\n          category\n          get \"/tags/filter/search.json\",\n              params: {\n                q: yup.name,\n                categoryId: Fabricate(:category).id,\n              }\n          expect(response.parsed_body[\"results\"].map { |j| j[\"id\"] }.sort).to eq([])\n          expect(response.parsed_body[\"forbidden\"]).to be_present\n          expect(response.parsed_body[\"forbidden_message\"]).to eq(\n            I18n.t(\n              \"tags.forbidden.restricted_to\",\n              count: 1,\n              tag_name: yup.name,\n              category_names: category.name,\n            ),\n          )\n        end\n\n        it \"can filter on category without q param\" do\n          nope = Fabricate(:tag, name: \"nope\")\n          get \"/tags/filter/search.json\", params: { categoryId: category.id }\n          expect(response.status).to eq(200)\n          expect(response.parsed_body[\"results\"].map { |j| j[\"id\"] }.sort).to eq([yup.name])\n        end\n      end\n\n      context \"with synonyms\" do\n        fab!(:tag) { Fabricate(:tag, name: \"plant\") }\n        fab!(:synonym) { Fabricate(:tag, name: \"plants\", target_tag: tag) }\n\n        it \"can return synonyms\" do\n          get \"/tags/filter/search.json\", params: { q: \"plant\" }\n          expect(response.status).to eq(200)\n          expect(response.parsed_body[\"results\"].map { |j| j[\"id\"] }).to contain_exactly(\n            \"plant\",\n            \"plants\",\n          )\n        end\n\n        it \"can omit synonyms\" do\n          get \"/tags/filter/search.json\", params: { q: \"plant\", excludeSynonyms: \"true\" }\n          expect(response.status).to eq(200)\n          expect(response.parsed_body[\"results\"].map { |j| j[\"id\"] }).to contain_exactly(\"plant\")\n        end\n\n        it \"can return a message about synonyms not being allowed\" do\n          get \"/tags/filter/search.json\", params: { q: \"plants\", excludeSynonyms: \"true\" }\n          expect(response.status).to eq(200)\n          expect(response.parsed_body[\"results\"].map { |j| j[\"id\"] }.sort).to eq([])\n          expect(response.parsed_body[\"forbidden\"]).to be_present\n          expect(response.parsed_body[\"forbidden_message\"]).to eq(\n            I18n.t(\"tags.forbidden.synonym\", tag_name: tag.name),\n          )\n        end\n      end\n\n      it \"matches tags after sanitizing input\" do\n        yup, nope = Fabricate(:tag, name: \"yup\"), Fabricate(:tag, name: \"nope\")\n        get \"/tags/filter/search.json\", params: { q: \"N/ope\" }\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"results\"].map { |j| j[\"id\"] }.sort).to eq([\"nope\"])\n      end\n\n      it \"can return tags that are in secured categories but are allowed to be used\" do\n        c = Fabricate(:private_category, group: Fabricate(:group))\n        Fabricate(:topic, category: c, tags: [Fabricate(:tag, name: \"cooltag\")])\n        get \"/tags/filter/search.json\", params: { q: \"cool\" }\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"results\"].map { |j| j[\"id\"] }).to eq([\"cooltag\"])\n      end\n\n      it \"supports Chinese and Russian\" do\n        tag_names = %w[\u623f\u5730\u4ea7 \u0442\u0435\u043c\u0430-\u0432-\u0440\u0430\u0437\u0440\u0430\u0431\u043e\u0442\u043a\u0435]\n        tag_names.each { |name| Fabricate(:tag, name: name) }\n\n        get \"/tags/filter/search.json\", params: { q: \"\u623f\" }\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"results\"].map { |j| j[\"id\"] }).to eq([\"\u623f\u5730\u4ea7\"])\n\n        get \"/tags/filter/search.json\", params: { q: \"\u0442\u0435\u043c\u0430\" }\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"results\"].map { |j| j[\"id\"] }).to eq([\"\u0442\u0435\u043c\u0430-\u0432-\u0440\u0430\u0437\u0440\u0430\u0431\u043e\u0442\u043a\u0435\"])\n      end\n\n      it \"can return all the results\" do\n        tag_group1 = Fabricate(:tag_group, tag_names: %w[common1 common2 group1tag group1tag2])\n        tag_group2 = Fabricate(:tag_group, tag_names: %w[common1 common2])\n        category = Fabricate(:category, tag_groups: [tag_group1])\n        get \"/tags/filter/search.json\",\n            params: {\n              q: \"\",\n              limit: 5,\n              categoryId: category.id,\n              filterForInput: \"true\",\n            }\n\n        expect(response.status).to eq(200)\n        expect_same_tag_names(\n          response.parsed_body[\"results\"].map { |j| j[\"id\"] },\n          %w[common1 common2 group1tag group1tag2],\n        )\n      end\n\n      it \"returns error 400 for negative limit\" do\n        get \"/tags/filter/search.json\", params: { q: \"\", limit: -1 }\n\n        expect(response.status).to eq(400)\n        expect(response.parsed_body[\"errors\"].first).to eq(\n          I18n.t(\"invalid_params\", message: \"limit\"),\n        )\n      end\n\n      it \"includes required tag group information\" do\n        tag1 = Fabricate(:tag)\n        tag2 = Fabricate(:tag)\n\n        tag_group = Fabricate(:tag_group, tags: [tag1, tag2])\n        crtg = CategoryRequiredTagGroup.new(tag_group: tag_group, min_count: 1)\n        category = Fabricate(:category, category_required_tag_groups: [crtg])\n\n        get \"/tags/filter/search.json\",\n            params: {\n              q: \"\",\n              categoryId: category.id,\n              filterForInput: true,\n            }\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"results\"].map { |t| t[\"name\"] }).to contain_exactly(\n          tag1.name,\n          tag2.name,\n        )\n        expect(response.parsed_body[\"required_tag_group\"]).to eq(\n          { \"name\" => tag_group.name, \"min_count\" => crtg.min_count },\n        )\n\n        get \"/tags/filter/search.json\",\n            params: {\n              q: \"\",\n              categoryId: category.id,\n              filterForInput: true,\n              selected_tags: [tag1.name],\n            }\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"results\"].map { |t| t[\"name\"] }).to contain_exactly(tag2.name)\n        expect(response.parsed_body[\"required_tag_group\"]).to eq(nil)\n      end\n    end\n  end\n\n  describe \"#destroy\" do\n    context \"with tagging enabled\" do\n      before { sign_in(admin) }\n\n      context \"with an existent tag name\" do\n        it \"deletes the tag\" do\n          tag = Fabricate(:tag)\n          delete \"/tag/#{tag.name}.json\"\n          expect(response.status).to eq(200)\n          expect(Tag.where(id: tag.id)).to be_empty\n        end\n      end\n\n      context \"with a nonexistent tag name\" do\n        it \"returns a tag not found message\" do\n          delete \"/tag/doesntexists.json\"\n          expect(response).not_to be_successful\n          expect(response.parsed_body[\"error_type\"]).to eq(\"not_found\")\n        end\n      end\n    end\n  end\n\n  describe \"#unused\" do\n    it \"fails if you can't manage tags\" do\n      sign_in(user)\n      get \"/tags/unused.json\"\n      expect(response.status).to eq(403)\n      delete \"/tags/unused.json\"\n      expect(response.status).to eq(403)\n    end\n\n    context \"when logged in\" do\n      before { sign_in(admin) }\n\n      context \"with some tags\" do\n        let!(:tags) do\n          [\n            Fabricate(\n              :tag,\n              name: \"used_publically\",\n              public_topic_count: 2,\n              staff_topic_count: 2,\n              pm_topic_count: 0,\n            ),\n            Fabricate(\n              :tag,\n              name: \"used_privately\",\n              public_topic_count: 0,\n              staff_topic_count: 0,\n              pm_topic_count: 3,\n            ),\n            Fabricate(\n              :tag,\n              name: \"used_everywhere\",\n              public_topic_count: 0,\n              staff_topic_count: 0,\n              pm_topic_count: 3,\n            ),\n            Fabricate(\n              :tag,\n              name: \"unused1\",\n              public_topic_count: 0,\n              staff_topic_count: 0,\n              pm_topic_count: 0,\n            ),\n            Fabricate(\n              :tag,\n              name: \"unused2\",\n              public_topic_count: 0,\n              staff_topic_count: 0,\n              pm_topic_count: 0,\n            ),\n          ]\n        end\n\n        it \"returns the correct unused tags\" do\n          get \"/tags/unused.json\"\n          expect(response.status).to eq(200)\n          expect(response.parsed_body[\"tags\"]).to contain_exactly(\"unused1\", \"unused2\")\n        end\n\n        it \"deletes the correct tags\" do\n          expect { delete \"/tags/unused.json\" }.to change { Tag.count }.by(-2) &\n            change { UserHistory.count }.by(1)\n          expect(Tag.pluck(:name)).to contain_exactly(\n            \"used_publically\",\n            \"used_privately\",\n            \"used_everywhere\",\n          )\n        end\n      end\n    end\n  end\n\n  describe \"#upload_csv\" do\n    it \"requires you to be logged in\" do\n      post \"/tags/upload.json\"\n      expect(response.status).to eq(403)\n    end\n\n    context \"while logged in\" do\n      let(:csv_file) { File.new(\"#{Rails.root}/spec/fixtures/csv/tags.csv\") }\n      let(:invalid_csv_file) { File.new(\"#{Rails.root}/spec/fixtures/csv/tags_invalid.csv\") }\n\n      let(:file) { Rack::Test::UploadedFile.new(File.open(csv_file)) }\n\n      let(:invalid_file) { Rack::Test::UploadedFile.new(File.open(invalid_csv_file)) }\n\n      let(:filename) { \"tags.csv\" }\n\n      it \"fails if you can't manage tags\" do\n        sign_in(user)\n        post \"/tags/upload.json\", params: { file: file, name: filename }\n        expect(response.status).to eq(403)\n      end\n\n      it \"allows staff to bulk upload tags\" do\n        sign_in(moderator)\n        post \"/tags/upload.json\", params: { file: file, name: filename }\n        expect(response.status).to eq(200)\n        expect(Tag.pluck(:name)).to contain_exactly(\n          \"tag1\",\n          \"capitaltag2\",\n          \"spaced-tag\",\n          \"tag3\",\n          \"tag4\",\n        )\n        expect(Tag.find_by_name(\"tag3\").tag_groups.pluck(:name)).to contain_exactly(\"taggroup1\")\n        expect(Tag.find_by_name(\"tag4\").tag_groups.pluck(:name)).to contain_exactly(\"taggroup1\")\n      end\n\n      it \"fails gracefully with invalid input\" do\n        sign_in(moderator)\n\n        expect do\n          post \"/tags/upload.json\", params: { file: invalid_file, name: filename }\n          expect(response.status).to eq(422)\n        end.not_to change { [Tag.count, TagGroup.count] }\n      end\n    end\n  end\n\n  describe \"#create_synonyms\" do\n    fab!(:tag) { Fabricate(:tag) }\n\n    it \"fails if not logged in\" do\n      post \"/tag/#{tag.name}/synonyms.json\", params: { synonyms: [\"synonym1\"] }\n      expect(response.status).to eq(403)\n    end\n\n    it \"fails if not staff user\" do\n      sign_in(user)\n      post \"/tag/#{tag.name}/synonyms.json\", params: { synonyms: [\"synonym1\"] }\n      expect(response.status).to eq(403)\n    end\n\n    context \"when signed in as admin\" do\n      before { sign_in(admin) }\n\n      it \"can make a tag a synonym of another tag\" do\n        tag2 = Fabricate(:tag)\n        expect {\n          post \"/tag/#{tag.name}/synonyms.json\", params: { synonyms: [tag2.name] }\n        }.to_not change { Tag.count }\n        expect(response.status).to eq(200)\n        expect(tag2.reload.target_tag).to eq(tag)\n      end\n\n      it \"can create new tags at the same time\" do\n        expect {\n          post \"/tag/#{tag.name}/synonyms.json\", params: { synonyms: [\"synonym\"] }\n        }.to change { Tag.count }.by(1)\n        expect(response.status).to eq(200)\n        expect(Tag.find_by_name(\"synonym\")&.target_tag).to eq(tag)\n      end\n\n      it \"can return errors\" do\n        tag2 = Fabricate(:tag, target_tag: tag)\n        tag3 = Fabricate(:tag)\n        post \"/tag/#{tag3.name}/synonyms.json\", params: { synonyms: [tag.name] }\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"failed\"]).to be_present\n        expect(response.parsed_body.dig(\"failed_tags\", tag.name)).to be_present\n      end\n    end\n  end\n\n  describe \"#destroy_synonym\" do\n    fab!(:tag) { Fabricate(:tag) }\n    fab!(:synonym) { Fabricate(:tag, target_tag: tag, name: \"synonym\") }\n    subject { delete(\"/tag/#{tag.name}/synonyms/#{synonym.name}.json\") }\n\n    it \"fails if not logged in\" do\n      subject\n      expect(response.status).to eq(403)\n    end\n\n    it \"fails if not staff user\" do\n      sign_in(user)\n      subject\n      expect(response.status).to eq(403)\n    end\n\n    context \"when signed in as admin\" do\n      before { sign_in(admin) }\n\n      it \"can remove a synonym from a tag\" do\n        synonym2 = Fabricate(:tag, target_tag: tag, name: \"synonym2\")\n        expect { subject }.to_not change { Tag.count }\n        expect_same_tag_names(tag.reload.synonyms, [synonym2])\n        expect(synonym.reload).to_not be_synonym\n      end\n\n      it \"returns error if tag isn't a synonym\" do\n        delete \"/tag/#{Fabricate(:tag).name}/synonyms/#{synonym.name}.json\"\n        expect(response.status).to eq(400)\n        expect_same_tag_names(tag.reload.synonyms, [synonym])\n      end\n\n      it \"returns error if synonym not found\" do\n        delete \"/tag/#{Fabricate(:tag).name}/synonyms/nope.json\"\n        expect(response.status).to eq(404)\n        expect_same_tag_names(tag.reload.synonyms, [synonym])\n      end\n    end\n  end\n\n  describe \"#update_notifications\" do\n    fab!(:tag) { Fabricate(:tag) }\n\n    before { sign_in(user) }\n\n    it \"returns 404 when tag is not found\" do\n      put \"/tag/someinvalidtagname/notifications.json\"\n\n      expect(response.status).to eq(404)\n    end\n\n    it \"updates the notification level of a tag for a user\" do\n      tag_user = TagUser.change(user.id, tag.id, NotificationLevels.all[:muted])\n\n      put \"/tag/#{tag.name}/notifications.json\",\n          params: {\n            tag_notification: {\n              notification_level: NotificationLevels.all[:tracking],\n            },\n          }\n\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"watched_tags\"]).to eq([])\n      expect(response.parsed_body[\"watching_first_post_tags\"]).to eq([])\n      expect(response.parsed_body[\"tracked_tags\"]).to eq([tag.name])\n      expect(response.parsed_body[\"muted_tags\"]).to eq([])\n      expect(response.parsed_body[\"regular_tags\"]).to eq([])\n\n      expect(tag_user.reload.notification_level).to eq(NotificationLevels.all[:tracking])\n    end\n\n    it \"sets the notification level of a tag for a user\" do\n      expect do\n        put \"/tag/#{tag.name}/notifications.json\",\n            params: {\n              tag_notification: {\n                notification_level: NotificationLevels.all[:muted],\n              },\n            }\n\n        expect(response.status).to eq(200)\n\n        expect(response.parsed_body[\"watched_tags\"]).to eq([])\n        expect(response.parsed_body[\"watching_first_post_tags\"]).to eq([])\n        expect(response.parsed_body[\"tracked_tags\"]).to eq([])\n        expect(response.parsed_body[\"muted_tags\"]).to eq([tag.name])\n        expect(response.parsed_body[\"regular_tags\"]).to eq([])\n      end.to change { user.tag_users.count }.by(1)\n\n      tag_user = user.tag_users.last\n\n      expect(tag_user.notification_level).to eq(NotificationLevels.all[:muted])\n    end\n  end\nend\n"], "fixing_code": ["# frozen_string_literal: true\n\nclass TagsController < ::ApplicationController\n  include TopicListResponder\n  include TopicQueryParams\n\n  before_action :ensure_tags_enabled\n\n  def self.show_methods\n    Discourse.anonymous_filters.map { |f| :\"show_#{f}\" }\n  end\n\n  before_action :ensure_visible, only: [:show, :info, *show_methods]\n\n  requires_login except: [:index, :show, :tag_feed, :search, :info, *show_methods]\n\n  skip_before_action :check_xhr, only: [:tag_feed, :show, :index, *show_methods]\n\n  before_action :set_category,\n                except: %i[\n                  index\n                  update\n                  destroy\n                  tag_feed\n                  search\n                  notifications\n                  update_notifications\n                  personal_messages\n                  info\n                ]\n\n  before_action :fetch_tag, only: %i[info create_synonyms destroy_synonym]\n\n  after_action :add_noindex_header, except: %i[index show]\n\n  def index\n    @description_meta = I18n.t(\"tags.title\")\n    @title = @description_meta\n\n    show_all_tags = guardian.can_admin_tags? && guardian.is_admin?\n\n    if SiteSetting.tags_listed_by_group\n      ungrouped_tags = Tag.where(\"tags.id NOT IN (SELECT tag_id FROM tag_group_memberships)\")\n      ungrouped_tags = ungrouped_tags.used_tags_in_regular_topics(guardian) unless show_all_tags\n\n      grouped_tag_counts =\n        TagGroup\n          .visible(guardian)\n          .order(\"name ASC\")\n          .includes(:none_synonym_tags)\n          .map do |tag_group|\n            {\n              id: tag_group.id,\n              name: tag_group.name,\n              tags: self.class.tag_counts_json(tag_group.none_synonym_tags, guardian),\n            }\n          end\n\n      @tags = self.class.tag_counts_json(ungrouped_tags, guardian)\n      @extras = { tag_groups: grouped_tag_counts }\n    else\n      tags = show_all_tags ? Tag.all : Tag.used_tags_in_regular_topics(guardian)\n      unrestricted_tags = DiscourseTagging.filter_visible(tags.where(target_tag_id: nil), guardian)\n\n      categories =\n        Category\n          .where(\"id IN (SELECT category_id FROM category_tags)\")\n          .where(\"id IN (?)\", guardian.allowed_category_ids)\n          .includes(:tags)\n\n      category_tag_counts =\n        categories\n          .map do |c|\n            category_tags =\n              self.class.tag_counts_json(\n                DiscourseTagging.filter_visible(c.tags.where(target_tag_id: nil), guardian),\n                guardian,\n              )\n            next if category_tags.empty?\n            { id: c.id, tags: category_tags }\n          end\n          .compact\n\n      @tags = self.class.tag_counts_json(unrestricted_tags, guardian)\n      @extras = { categories: category_tag_counts }\n    end\n\n    respond_to do |format|\n      format.html { render :index }\n\n      format.json { render json: { tags: @tags, extras: @extras } }\n    end\n  end\n\n  Discourse.filters.each do |filter|\n    define_method(\"show_#{filter}\") do\n      @tag_id = params[:tag_id].force_encoding(\"UTF-8\")\n      @additional_tags =\n        params[:additional_tag_ids].to_s.split(\"/\").map { |t| t.force_encoding(\"UTF-8\") }\n\n      list_opts = build_topic_list_options\n      @list = nil\n\n      if filter == :top\n        period = params[:period] || SiteSetting.top_page_default_timeframe.to_sym\n        TopTopic.validate_period(period)\n\n        @list = TopicQuery.new(current_user, list_opts).public_send(\"list_top_for\", period)\n        @list.for_period = period\n      else\n        @list = TopicQuery.new(current_user, list_opts).public_send(\"list_#{filter}\")\n      end\n\n      @list.more_topics_url = construct_url_with(:next, list_opts)\n      @list.prev_topics_url = construct_url_with(:prev, list_opts)\n      @rss = \"tag\"\n      @description_meta = I18n.t(\"rss_by_tag\", tag: tag_params.join(\" & \"))\n      @title = @description_meta\n\n      canonical_params = params.slice(:category_slug_path_with_id, :tag_id)\n      canonical_method = url_method(canonical_params)\n      canonical_url \"#{Discourse.base_url_no_prefix}#{public_send(canonical_method, *(canonical_params.values.map { |t| t.force_encoding(\"UTF-8\") }))}\"\n\n      if @list.topics.size == 0 && params[:tag_id] != \"none\" && !Tag.where_name(@tag_id).exists?\n        raise Discourse::NotFound.new(\"tag not found\", check_permalinks: true)\n      else\n        respond_with_list(@list)\n      end\n    end\n  end\n\n  def show\n    show_latest\n  end\n\n  def info\n    render_serialized(@tag, DetailedTagSerializer, rest_serializer: true, root: :tag_info)\n  end\n\n  def update\n    guardian.ensure_can_admin_tags!\n\n    tag = Tag.find_by_name(params[:tag_id])\n    raise Discourse::NotFound if tag.nil?\n\n    if (params[:tag][:id].present?)\n      new_tag_name = DiscourseTagging.clean_tag(params[:tag][:id])\n      tag.name = new_tag_name\n    end\n    tag.description = params[:tag][:description] if params[:tag]&.has_key?(:description)\n    if tag.save\n      StaffActionLogger.new(current_user).log_custom(\n        \"renamed_tag\",\n        previous_value: params[:tag_id],\n        new_value: new_tag_name,\n      )\n      render json: { tag: { id: tag.name, description: tag.description } }\n    else\n      render_json_error tag.errors.full_messages\n    end\n  end\n\n  def upload\n    require \"csv\"\n\n    guardian.ensure_can_admin_tags!\n\n    file = params[:file] || params[:files].first\n\n    hijack do\n      begin\n        Tag.transaction do\n          CSV.foreach(file.tempfile) do |row|\n            if row.length > 2\n              raise Discourse::InvalidParameters.new(I18n.t(\"tags.upload_row_too_long\"))\n            end\n\n            tag_name = DiscourseTagging.clean_tag(row[0])\n            tag_group_name = row[1] || nil\n\n            tag = Tag.find_by_name(tag_name) || Tag.create!(name: tag_name)\n\n            if tag_group_name\n              tag_group =\n                TagGroup.find_by(name: tag_group_name) || TagGroup.create!(name: tag_group_name)\n              tag.tag_groups << tag_group unless tag.tag_groups.include?(tag_group)\n            end\n          end\n        end\n        render json: success_json\n      rescue Discourse::InvalidParameters => e\n        render json: failed_json.merge(errors: [e.message]), status: 422\n      end\n    end\n  end\n\n  def list_unused\n    guardian.ensure_can_admin_tags!\n    render json: { tags: Tag.unused.pluck(:name) }\n  end\n\n  def destroy_unused\n    guardian.ensure_can_admin_tags!\n    tags = Tag.unused\n    StaffActionLogger.new(current_user).log_custom(\"deleted_unused_tags\", tags: tags.pluck(:name))\n    tags.destroy_all\n    render json: success_json\n  end\n\n  def destroy\n    guardian.ensure_can_admin_tags!\n    tag_name = params[:tag_id]\n    tag = Tag.find_by_name(tag_name)\n    raise Discourse::NotFound if tag.nil?\n\n    TopicCustomField.transaction do\n      tag.destroy\n      StaffActionLogger.new(current_user).log_custom(\"deleted_tag\", subject: tag_name)\n    end\n    render json: success_json\n  end\n\n  def tag_feed\n    discourse_expires_in 1.minute\n\n    tag_id = params[:tag_id]\n    @link = \"#{Discourse.base_url}/tag/#{tag_id}\"\n    @description = I18n.t(\"rss_by_tag\", tag: tag_id)\n    @title = \"#{SiteSetting.title} - #{@description}\"\n    @atom_link = \"#{Discourse.base_url}/tag/#{tag_id}.rss\"\n\n    query = TopicQuery.new(current_user, tags: [tag_id])\n    latest_results = query.latest_results\n    @topic_list = query.create_list(:by_tag, {}, latest_results)\n\n    render \"list/list\", formats: [:rss]\n  end\n\n  def search\n    filter_params = {\n      for_input: params[:filterForInput],\n      selected_tags: params[:selected_tags],\n      limit: params[:limit],\n      exclude_synonyms: params[:excludeSynonyms],\n      exclude_has_synonyms: params[:excludeHasSynonyms],\n    }\n\n    if filter_params[:limit] && filter_params[:limit].to_i < 0\n      raise Discourse::InvalidParameters.new(:limit)\n    end\n\n    filter_params[:category] = Category.find_by_id(params[:categoryId]) if params[:categoryId]\n\n    if !params[:q].blank?\n      clean_name = DiscourseTagging.clean_tag(params[:q])\n      filter_params[:term] = clean_name\n      filter_params[:order_search_results] = true\n    else\n      filter_params[:order_popularity] = true\n    end\n\n    tags_with_counts, filter_result_context =\n      DiscourseTagging.filter_allowed_tags(guardian, **filter_params, with_context: true)\n\n    tags = self.class.tag_counts_json(tags_with_counts, guardian)\n\n    json_response = { results: tags }\n\n    if clean_name && !tags.find { |h| h[:id].downcase == clean_name.downcase } &&\n         tag = Tag.where_name(clean_name).first\n      # filter_allowed_tags determined that the tag entered is not allowed\n      json_response[:forbidden] = params[:q]\n\n      if filter_params[:exclude_synonyms] && tag.synonym?\n        json_response[:forbidden_message] = I18n.t(\n          \"tags.forbidden.synonym\",\n          tag_name: tag.target_tag.name,\n        )\n      elsif filter_params[:exclude_has_synonyms] && tag.synonyms.exists?\n        json_response[:forbidden_message] = I18n.t(\n          \"tags.forbidden.has_synonyms\",\n          tag_name: tag.name,\n        )\n      else\n        category_names = tag.categories.where(id: guardian.allowed_category_ids).pluck(:name)\n        category_names +=\n          Category\n            .joins(tag_groups: :tags)\n            .where(id: guardian.allowed_category_ids, \"tags.id\": tag.id)\n            .pluck(:name)\n\n        if category_names.present?\n          category_names.uniq!\n          json_response[:forbidden_message] = I18n.t(\n            \"tags.forbidden.restricted_to\",\n            count: category_names.count,\n            tag_name: tag.name,\n            category_names: category_names.join(\", \"),\n          )\n        else\n          json_response[:forbidden_message] = I18n.t(\n            \"tags.forbidden.in_this_category\",\n            tag_name: tag.name,\n          )\n        end\n      end\n    end\n\n    if required_tag_group = filter_result_context[:required_tag_group]\n      json_response[:required_tag_group] = required_tag_group\n    end\n\n    render json: json_response\n  end\n\n  def notifications\n    tag = Tag.where_name(params[:tag_id]).first\n    raise Discourse::NotFound unless tag\n    level =\n      tag.tag_users.where(user: current_user).first.try(:notification_level) ||\n        TagUser.notification_levels[:regular]\n    render json: { tag_notification: { id: tag.name, notification_level: level.to_i } }\n  end\n\n  def update_notifications\n    tag = Tag.find_by_name(params[:tag_id])\n    raise Discourse::NotFound unless tag\n    level = params[:tag_notification][:notification_level].to_i\n    TagUser.change(current_user.id, tag.id, level)\n    render_serialized(current_user, UserTagNotificationsSerializer, root: false)\n  end\n\n  def personal_messages\n    guardian.ensure_can_tag_pms!\n    allowed_user = fetch_user_from_params\n    raise Discourse::NotFound if allowed_user.blank?\n    raise Discourse::NotFound if current_user.id != allowed_user.id && !@guardian.is_admin?\n    pm_tags = Tag.pm_tags(guardian: guardian, allowed_user: allowed_user)\n\n    render json: { tags: pm_tags }\n  end\n\n  def create_synonyms\n    guardian.ensure_can_admin_tags!\n    value = DiscourseTagging.add_or_create_synonyms_by_name(@tag, params[:synonyms])\n    if value.is_a?(Array)\n      render json:\n               failed_json.merge(\n                 failed_tags:\n                   value.inject({}) do |h, t|\n                     h[t.name] = t.errors.full_messages.first\n                     h\n                   end,\n               )\n    else\n      render json: success_json\n    end\n  end\n\n  def destroy_synonym\n    guardian.ensure_can_admin_tags!\n    synonym = Tag.where_name(params[:synonym_id]).first\n    raise Discourse::NotFound unless synonym\n    if synonym.target_tag == @tag\n      synonym.update!(target_tag: nil)\n      render json: success_json\n    else\n      render json: failed_json, status: 400\n    end\n  end\n\n  private\n\n  def fetch_tag\n    @tag = Tag.find_by_name(params[:tag_id].force_encoding(\"UTF-8\"))\n    raise Discourse::NotFound unless @tag\n  end\n\n  def ensure_tags_enabled\n    raise Discourse::NotFound unless SiteSetting.tagging_enabled?\n  end\n\n  def ensure_visible\n    if DiscourseTagging.hidden_tag_names(guardian).include?(params[:tag_id])\n      raise Discourse::NotFound\n    end\n  end\n\n  def self.tag_counts_json(tags, guardian)\n    show_pm_tags = guardian.can_tag_pms?\n    target_tags = Tag.where(id: tags.map(&:target_tag_id).compact.uniq).select(:id, :name)\n\n    tags\n      .map do |t|\n        topic_count = t.public_send(Tag.topic_count_column(guardian))\n\n        next if topic_count == 0 && t.pm_topic_count > 0 && !show_pm_tags\n\n        {\n          id: t.name,\n          text: t.name,\n          name: t.name,\n          description: t.description,\n          count: topic_count,\n          pm_count: show_pm_tags ? t.pm_topic_count : 0,\n          target_tag:\n            t.target_tag_id ? target_tags.find { |x| x.id == t.target_tag_id }&.name : nil,\n        }\n      end\n      .compact\n  end\n\n  def set_category\n    if request.path_parameters.include?(:category_slug_path_with_id)\n      @filter_on_category = Category.find_by_slug_path_with_id(params[:category_slug_path_with_id])\n    else\n      slug_or_id = params[:category]\n      return true if slug_or_id.nil?\n\n      @filter_on_category = Category.query_category(slug_or_id, nil)\n    end\n\n    if !@filter_on_category\n      permalink = Permalink.find_by_url(\"c/#{params[:category_slug_path_with_id]}\")\n      if permalink.present? && permalink.category_id\n        return(\n          redirect_to \"#{Discourse.base_path}/tags#{permalink.target_url}/#{params[:tag_id]}\",\n                      status: :moved_permanently\n        )\n      end\n    end\n\n    if !(@filter_on_category && guardian.can_see?(@filter_on_category))\n      # 404 on 'access denied' to avoid leaking existence of category\n      raise Discourse::NotFound\n    end\n  end\n\n  def page_params\n    route_params = { format: \"json\" }\n\n    if @filter_on_category\n      if request.path_parameters.include?(:category_slug_path_with_id)\n        slug_path = @filter_on_category.slug_path\n\n        route_params[:category_slug_path_with_id] = (\n          slug_path + [@filter_on_category.id.to_s]\n        ).join(\"/\")\n      else\n        route_params[:category] = @filter_on_category.slug_for_url\n      end\n    end\n\n    route_params\n  end\n\n  def next_page_params\n    page_params.merge(page: params[:page].to_i + 1)\n  end\n\n  def prev_page_params\n    pg = params[:page].to_i\n    if pg > 1\n      page_params.merge(page: pg - 1)\n    else\n      page_params.merge(page: nil)\n    end\n  end\n\n  def url_method(opts = {})\n    if opts[:category_slug_path_with_id]\n      \"tag_category_#{action_name}_path\"\n    else\n      \"tag_#{action_name}_path\"\n    end\n  end\n\n  def construct_url_with(action, opts)\n    page_params =\n      case action\n      when :prev\n        prev_page_params\n      when :next\n        next_page_params\n      else\n        raise \"unreachable\"\n      end\n\n    opts = opts.merge(page_params)\n    opts.delete(:category) if opts.include?(:category_slug_path_with_id)\n\n    method = url_method(opts)\n\n    begin\n      url = public_send(method, opts)\n    rescue ActionController::UrlGenerationError\n      raise Discourse::NotFound\n    end\n\n    url.sub(\".json?\", \"?\")\n  end\n\n  def build_topic_list_options\n    options =\n      super.merge(\n        page: params[:page],\n        topic_ids: param_to_integer_list(:topic_ids),\n        category: @filter_on_category ? @filter_on_category.id : params[:category],\n        order: params[:order],\n        ascending: params[:ascending],\n        min_posts: params[:min_posts],\n        max_posts: params[:max_posts],\n        status: params[:status],\n        filter: params[:filter],\n        state: params[:state],\n        search: params[:search],\n        q: params[:q],\n      )\n    options[:no_subcategories] = true if params[:no_subcategories] == true ||\n      params[:no_subcategories] == \"true\"\n    options[:per_page] = params[:per_page].to_i.clamp(1, 30) if params[:per_page].present?\n\n    if params[:tag_id] == \"none\"\n      options.delete(:tags)\n      options[:no_tags] = true\n    else\n      options[:tags] = tag_params\n      options[:match_all_tags] ||= true\n    end\n\n    options\n  end\n\n  def tag_params\n    [@tag_id].concat(Array(@additional_tags))\n  end\nend\n", "# frozen_string_literal: true\n\nRSpec.describe TagsController do\n  fab!(:user) { Fabricate(:user) }\n  fab!(:admin) { Fabricate(:admin) }\n  fab!(:regular_user) { Fabricate(:trust_level_4) }\n  fab!(:moderator) { Fabricate(:moderator) }\n  fab!(:category) { Fabricate(:category) }\n  fab!(:subcategory) { Fabricate(:category, parent_category_id: category.id) }\n\n  before { SiteSetting.tagging_enabled = true }\n\n  describe \"#index\" do\n    fab!(:test_tag) { Fabricate(:tag, name: \"test\") }\n    fab!(:topic_tag) do\n      Fabricate(:tag, name: \"topic-test\", public_topic_count: 1, staff_topic_count: 1)\n    end\n    fab!(:synonym) { Fabricate(:tag, name: \"synonym\", target_tag: topic_tag) }\n\n    shared_examples \"retrieves the right tags\" do\n      it \"retrieves all tags as a staff user\" do\n        sign_in(admin)\n\n        get \"/tags.json\"\n\n        expect(response.status).to eq(200)\n\n        tags = response.parsed_body[\"tags\"]\n\n        expect(tags[0][\"name\"]).to eq(test_tag.name)\n        expect(tags[0][\"count\"]).to eq(0)\n        expect(tags[0][\"pm_count\"]).to eq(0)\n\n        expect(tags[1][\"name\"]).to eq(topic_tag.name)\n        expect(tags[1][\"count\"]).to eq(1)\n        expect(tags[1][\"pm_count\"]).to eq(0)\n      end\n\n      it \"only retrieve tags that have been used in public topics for non-staff user\" do\n        sign_in(user)\n\n        get \"/tags.json\"\n\n        expect(response.status).to eq(200)\n\n        tags = response.parsed_body[\"tags\"]\n        expect(tags.length).to eq(1)\n\n        expect(tags[0][\"name\"]).to eq(topic_tag.name)\n        expect(tags[0][\"count\"]).to eq(1)\n        expect(tags[0][\"pm_count\"]).to eq(0)\n      end\n    end\n\n    context \"with pm_tags_allowed_for_groups\" do\n      fab!(:admin) { Fabricate(:admin) }\n      fab!(:topic) { Fabricate(:topic, tags: [topic_tag]) }\n      fab!(:pm) do\n        Fabricate(\n          :private_message_topic,\n          tags: [test_tag],\n          topic_allowed_users: [Fabricate.build(:topic_allowed_user, user: admin)],\n        )\n      end\n\n      context \"when enabled\" do\n        before do\n          SiteSetting.pm_tags_allowed_for_groups = \"1|2|3\"\n          sign_in(admin)\n        end\n\n        it \"shows topic tags and pm tags\" do\n          get \"/tags.json\"\n          tags = response.parsed_body[\"tags\"]\n          expect(tags.length).to eq(2)\n\n          serialized_tag = tags.find { |t| t[\"id\"] == topic_tag.name }\n          expect(serialized_tag[\"count\"]).to eq(2)\n          expect(serialized_tag[\"pm_count\"]).to eq(0)\n\n          serialized_tag = tags.find { |t| t[\"id\"] == test_tag.name }\n          expect(serialized_tag[\"count\"]).to eq(0)\n          expect(serialized_tag[\"pm_count\"]).to eq(1)\n        end\n      end\n\n      context \"when disabled\" do\n        before do\n          SiteSetting.pm_tags_allowed_for_groups = \"\"\n          sign_in(admin)\n        end\n\n        it \"hides pm tags\" do\n          get \"/tags.json\"\n          tags = response.parsed_body[\"tags\"]\n          expect(tags.length).to eq(1)\n          expect(tags[0][\"id\"]).to eq(topic_tag.name)\n        end\n      end\n    end\n\n    context \"with tags_listed_by_group enabled\" do\n      before { SiteSetting.tags_listed_by_group = true }\n      include_examples \"retrieves the right tags\"\n\n      it \"works for tags in groups\" do\n        tag_group = Fabricate(:tag_group, tags: [test_tag, topic_tag, synonym])\n\n        get \"/tags.json\"\n\n        expect(response.status).to eq(200)\n        tags = response.parsed_body[\"tags\"]\n        expect(tags.length).to eq(0)\n        group = response.parsed_body.dig(\"extras\", \"tag_groups\")&.first\n        expect(group).to be_present\n        expect(group[\"tags\"].length).to eq(2)\n        expect(group[\"tags\"].map { |t| t[\"id\"] }).to contain_exactly(test_tag.name, topic_tag.name)\n      end\n\n      it \"does not result in N+1 queries with multiple tag_groups\" do\n        tag_group1 = Fabricate(:tag_group, tags: [test_tag, topic_tag, synonym])\n\n        # warm up\n        get \"/tags.json\"\n        expect(response.status).to eq(200)\n\n        initial_sql_queries_count =\n          track_sql_queries do\n            get \"/tags.json\"\n\n            expect(response.status).to eq(200)\n\n            tag_groups = response.parsed_body.dig(\"extras\", \"tag_groups\")\n\n            expect(tag_groups.length).to eq(1)\n            expect(tag_groups.map { |tag_group| tag_group[\"name\"] }).to contain_exactly(\n              tag_group1.name,\n            )\n          end.length\n\n        tag_group2 = Fabricate(:tag_group, tags: [topic_tag])\n\n        new_sql_queries_count =\n          track_sql_queries do\n            get \"/tags.json\"\n\n            expect(response.status).to eq(200)\n\n            tag_groups = response.parsed_body.dig(\"extras\", \"tag_groups\")\n\n            expect(tag_groups.length).to eq(2)\n            expect(tag_groups.map { |tag_group| tag_group[\"name\"] }).to contain_exactly(\n              tag_group1.name,\n              tag_group2.name,\n            )\n          end.length\n\n        expect(new_sql_queries_count).to be <= initial_sql_queries_count\n      end\n    end\n\n    context \"with tags_listed_by_group disabled\" do\n      before { SiteSetting.tags_listed_by_group = false }\n      include_examples \"retrieves the right tags\"\n    end\n\n    context \"with hidden tags\" do\n      before { create_hidden_tags([\"staff1\"]) }\n\n      it \"is returned to admins\" do\n        sign_in(admin)\n        get \"/tags.json\"\n        expect(response.parsed_body[\"tags\"].map { |t| t[\"text\"] }).to include(\"staff1\")\n        expect(response.parsed_body[\"extras\"][\"categories\"]).to be_empty\n      end\n\n      it \"is not returned to anon\" do\n        get \"/tags.json\"\n        expect(response.parsed_body[\"tags\"].map { |t| t[\"text\"] }).to_not include(\"staff1\")\n        expect(response.parsed_body[\"extras\"][\"categories\"]).to be_empty\n      end\n\n      it \"is not returned to regular user\" do\n        sign_in(user)\n        get \"/tags.json\"\n        expect(response.parsed_body[\"tags\"].map { |t| t[\"text\"] }).to_not include(\"staff1\")\n        expect(response.parsed_body[\"extras\"][\"categories\"]).to be_empty\n      end\n\n      context \"when restricted to a category\" do\n        before { category.tags = [Tag.find_by_name(\"staff1\")] }\n\n        it \"is returned to admins\" do\n          sign_in(admin)\n          get \"/tags.json\"\n          expect(response.parsed_body[\"tags\"].map { |t| t[\"text\"] }).to include(\"staff1\")\n          categories = response.parsed_body[\"extras\"][\"categories\"]\n          expect(categories.length).to eq(1)\n          expect(categories.first[\"tags\"].map { |t| t[\"text\"] }).to include(\"staff1\")\n        end\n\n        it \"is not returned to anon\" do\n          get \"/tags.json\"\n          expect(response.parsed_body[\"tags\"].map { |t| t[\"text\"] }).to_not include(\"staff1\")\n          expect(response.parsed_body[\"extras\"][\"categories\"]).to be_empty\n        end\n\n        it \"is not returned to regular user\" do\n          sign_in(user)\n          get \"/tags.json\"\n          expect(response.parsed_body[\"tags\"].map { |t| t[\"text\"] }).to_not include(\"staff1\")\n          expect(response.parsed_body[\"extras\"][\"categories\"]).to be_empty\n        end\n      end\n\n      context \"when listed by group\" do\n        before { SiteSetting.tags_listed_by_group = true }\n\n        it \"is returned to admins\" do\n          sign_in(admin)\n          get \"/tags.json\"\n          expect(response.parsed_body[\"tags\"].map { |t| t[\"text\"] }).to_not include(\"staff1\")\n          tag_groups = response.parsed_body[\"extras\"][\"tag_groups\"]\n          expect(tag_groups.length).to eq(1)\n          expect(tag_groups.first[\"tags\"].map { |t| t[\"text\"] }).to include(\"staff1\")\n        end\n\n        it \"is not returned to anon\" do\n          get \"/tags.json\"\n          expect(response.parsed_body[\"tags\"].map { |t| t[\"text\"] }).to_not include(\"staff1\")\n          expect(response.parsed_body[\"extras\"][\"tag_groups\"]).to be_empty\n        end\n\n        it \"is not returned to regular user\" do\n          sign_in(user)\n          get \"/tags.json\"\n          expect(response.parsed_body[\"tags\"].map { |t| t[\"text\"] }).to_not include(\"staff1\")\n          expect(response.parsed_body[\"extras\"][\"tag_groups\"]).to be_empty\n        end\n      end\n    end\n  end\n\n  describe \"#show\" do\n    fab!(:tag) { Fabricate(:tag, name: \"test\") }\n    fab!(:topic_without_tags) { Fabricate(:topic) }\n    fab!(:topic_with_tags) { Fabricate(:topic, tags: [tag]) }\n\n    it \"should return the right response\" do\n      get \"/tag/test.json\"\n\n      expect(response.status).to eq(200)\n\n      json = response.parsed_body\n\n      topic_list = json[\"topic_list\"]\n\n      expect(topic_list[\"tags\"].map { |t| t[\"id\"] }).to contain_exactly(tag.id)\n    end\n\n    it \"should handle invalid tags\" do\n      get \"/tag/%2ftest%2f\"\n      expect(response.status).to eq(404)\n    end\n\n    it \"should handle synonyms\" do\n      synonym = Fabricate(:tag, target_tag: tag)\n      get \"/tag/#{synonym.name}\"\n      expect(response.status).to eq(200)\n    end\n\n    it \"does not show staff-only tags\" do\n      tag_group = Fabricate(:tag_group, permissions: { \"staff\" => 1 }, tag_names: [\"test\"])\n\n      get \"/tag/test\"\n      expect(response.status).to eq(404)\n\n      sign_in(admin)\n\n      get \"/tag/test\"\n      expect(response.status).to eq(200)\n    end\n\n    it \"handles special tag 'none'\" do\n      SiteSetting.pm_tags_allowed_for_groups = \"1|2|3\"\n\n      sign_in(admin)\n\n      get \"/tag/none.json\"\n      expect(response.parsed_body[\"topic_list\"][\"topics\"].length).to eq(1)\n    end\n\n    context \"with a category in the path\" do\n      fab!(:topic_in_category) { Fabricate(:topic, tags: [tag], category: category) }\n\n      fab!(:topic_in_category_without_tag) { Fabricate(:topic, category: category) }\n\n      fab!(:topic_out_of_category) { Fabricate(:topic, tags: [tag]) }\n\n      it \"should produce the topic inside the category and not the topic outside of it\" do\n        get \"/tags/c/#{category.slug}/#{tag.name}.json\"\n\n        topic_ids = response.parsed_body[\"topic_list\"][\"topics\"].map { |x| x[\"id\"] }\n        expect(topic_ids).to include(topic_in_category.id)\n        expect(topic_ids).to_not include(topic_out_of_category.id)\n        expect(topic_ids).to_not include(topic_in_category_without_tag.id)\n      end\n\n      it \"should produce the right next topic URL\" do\n        get \"/tags/c/#{category.slug_path.join(\"/\")}/#{category.id}/#{tag.name}.json?per_page=1\"\n\n        expect(response.parsed_body[\"topic_list\"][\"more_topics_url\"]).to start_with(\n          \"/tags/c/#{category.slug_path.join(\"/\")}/#{category.id}/#{tag.name}\",\n        )\n      end\n\n      it \"should 404 for invalid category path\" do\n        get \"/tags/c/#{category.slug_path.join(\"/\")}/#{category.id}/somerandomstring/#{tag.name}.json?per_page=1\"\n\n        expect(response.status).to eq(404)\n      end\n\n      it \"should 404 for secure categories\" do\n        c = Fabricate(:private_category, group: Fabricate(:group))\n        get \"/tags/c/#{c.slug_path.join(\"/\")}/#{c.id}/#{tag.name}.json\"\n\n        expect(response.status).to eq(404)\n      end\n    end\n\n    context \"with a subcategory in the path\" do\n      fab!(:topic_in_subcategory) { Fabricate(:topic, tags: [tag], category: subcategory) }\n\n      fab!(:topic_in_subcategory_without_tag) { Fabricate(:topic, category: subcategory) }\n\n      fab!(:topic_out_of_subcategory) { Fabricate(:topic, tags: [tag]) }\n\n      it \"should produce the topic inside the subcategory and not the topic outside of it\" do\n        get \"/tags/c/#{category.slug}/#{subcategory.slug}/#{tag.name}.json\"\n\n        topic_ids = response.parsed_body[\"topic_list\"][\"topics\"].map { |x| x[\"id\"] }\n        expect(topic_ids).to include(topic_in_subcategory.id)\n        expect(topic_ids).to_not include(topic_out_of_subcategory.id)\n        expect(topic_ids).to_not include(topic_in_subcategory_without_tag.id)\n      end\n    end\n  end\n\n  describe \"#info\" do\n    fab!(:tag) { Fabricate(:tag, name: \"test\") }\n    let(:synonym) { Fabricate(:tag, name: \"synonym\", target_tag: tag) }\n\n    it \"returns 404 if tag not found\" do\n      get \"/tag/nope/info.json\"\n      expect(response.status).to eq(404)\n    end\n\n    it \"can handle tag with no synonyms\" do\n      get \"/tag/#{tag.name}/info.json\"\n      expect(response.status).to eq(200)\n      expect(response.parsed_body.dig(\"tag_info\", \"name\")).to eq(tag.name)\n      expect(response.parsed_body.dig(\"tag_info\", \"synonyms\")).to be_empty\n      expect(response.parsed_body.dig(\"tag_info\", \"category_ids\")).to be_empty\n      expect(response.parsed_body.dig(\"tag_info\", \"category_restricted\")).to eq(false)\n    end\n\n    it \"can handle a synonym\" do\n      get \"/tag/#{synonym.name}/info.json\"\n      expect(response.status).to eq(200)\n      expect(response.parsed_body.dig(\"tag_info\", \"name\")).to eq(synonym.name)\n      expect(response.parsed_body.dig(\"tag_info\", \"synonyms\")).to be_empty\n      expect(response.parsed_body.dig(\"tag_info\", \"category_ids\")).to be_empty\n      expect(response.parsed_body.dig(\"tag_info\", \"category_restricted\")).to eq(false)\n    end\n\n    it \"can return a tag's synonyms\" do\n      synonym\n      get \"/tag/#{tag.name}/info.json\"\n      expect(response.status).to eq(200)\n      expect(response.parsed_body.dig(\"tag_info\", \"synonyms\").map { |t| t[\"text\"] }).to eq(\n        [synonym.name],\n      )\n    end\n\n    it \"returns 404 if tag is staff-only\" do\n      tag_group = Fabricate(:tag_group, permissions: { \"staff\" => 1 }, tag_names: [\"test\"])\n      get \"/tag/test/info.json\"\n      expect(response.status).to eq(404)\n    end\n\n    it \"staff-only tags can be retrieved for staff user\" do\n      sign_in(admin)\n      tag_group = Fabricate(:tag_group, permissions: { \"staff\" => 1 }, tag_names: [\"test\"])\n      get \"/tag/test/info.json\"\n      expect(response.status).to eq(200)\n    end\n\n    it \"can return category restrictions\" do\n      category.update!(tags: [tag])\n      category2 = Fabricate(:category)\n      tag_group = Fabricate(:tag_group, tags: [tag])\n      category2.update!(tag_groups: [tag_group])\n      staff_category = Fabricate(:private_category, group: Fabricate(:group), tags: [tag])\n      get \"/tag/#{tag.name}/info.json\"\n      expect(response.parsed_body.dig(\"tag_info\", \"category_ids\")).to contain_exactly(\n        category.id,\n        category2.id,\n      )\n      expect(response.parsed_body[\"categories\"]).to be_present\n      expect(response.parsed_body.dig(\"tag_info\", \"category_restricted\")).to eq(true)\n    end\n\n    context \"when tag belongs to a tag group\" do\n      fab!(:tag_group) { Fabricate(:tag_group, tags: [tag]) }\n\n      it \"returns tag groups if tag groups are visible\" do\n        SiteSetting.tags_listed_by_group = true\n        get \"/tag/#{tag.name}/info.json\"\n        expect(response.parsed_body.dig(\"tag_info\", \"tag_group_names\")).to eq([tag_group.name])\n      end\n\n      it \"doesn't return tag groups if tag groups aren't visible\" do\n        SiteSetting.tags_listed_by_group = false\n        get \"/tag/#{tag.name}/info.json\"\n        expect(response.parsed_body[\"tag_info\"].has_key?(\"tag_group_names\")).to eq(false)\n      end\n\n      context \"when restricted to a private category\" do\n        let!(:private_category) do\n          Fabricate(\n            :private_category,\n            group: Fabricate(:group),\n            tag_groups: [tag_group],\n            allow_global_tags: true,\n          )\n        end\n\n        it \"can return categories to users who can access them\" do\n          sign_in(admin)\n          get \"/tag/#{tag.name}/info.json\"\n          expect(response.parsed_body.dig(\"tag_info\", \"category_ids\")).to contain_exactly(\n            private_category.id,\n          )\n          expect(response.parsed_body[\"categories\"]).to be_present\n          expect(response.parsed_body.dig(\"tag_info\", \"category_restricted\")).to eq(true)\n        end\n\n        it \"can indicate category restriction to users who can't access them\" do\n          sign_in(user)\n          get \"/tag/#{tag.name}/info.json\"\n          expect(response.parsed_body.dig(\"tag_info\", \"category_ids\")).to be_empty\n          expect(response.parsed_body[\"categories\"]).to be_blank\n          expect(response.parsed_body.dig(\"tag_info\", \"category_restricted\")).to eq(true)\n        end\n\n        it \"can indicate category restriction to anon\" do\n          get \"/tag/#{tag.name}/info.json\"\n          expect(response.parsed_body.dig(\"tag_info\", \"category_ids\")).to be_empty\n          expect(response.parsed_body[\"categories\"]).to be_blank\n          expect(response.parsed_body.dig(\"tag_info\", \"category_restricted\")).to eq(true)\n        end\n      end\n    end\n  end\n\n  describe \"#update\" do\n    fab!(:tag) { Fabricate(:tag) }\n\n    before do\n      tag\n      sign_in(admin)\n    end\n\n    it \"triggers a extensibility event\" do\n      event =\n        DiscourseEvent\n          .track_events { put \"/tag/#{tag.name}.json\", params: { tag: { id: \"hello\" } } }\n          .last\n\n      expect(event[:event_name]).to eq(:tag_updated)\n      expect(event[:params].first).to eq(tag)\n    end\n  end\n\n  describe \"#personal_messages\" do\n    fab!(:personal_message) do\n      Fabricate(\n        :private_message_topic,\n        user: regular_user,\n        topic_allowed_users: [\n          Fabricate.build(:topic_allowed_user, user: regular_user),\n          Fabricate.build(:topic_allowed_user, user: moderator),\n          Fabricate.build(:topic_allowed_user, user: admin),\n        ],\n      )\n    end\n\n    fab!(:tag) { Fabricate(:tag, topics: [personal_message], name: \"test\") }\n\n    before { SiteSetting.pm_tags_allowed_for_groups = \"1|2|3\" }\n\n    context \"as a regular user\" do\n      it \"can't see pm tags\" do\n        get \"/tags/personal_messages/#{regular_user.username}.json\"\n\n        expect(response.status).to eq(403)\n      end\n    end\n\n    context \"as an moderator\" do\n      before { sign_in(moderator) }\n\n      it \"can't see pm tags for regular user\" do\n        get \"/tags/personal_messages/#{regular_user.username}.json\"\n\n        expect(response.status).to eq(404)\n      end\n\n      it \"can see their own pm tags\" do\n        get \"/tags/personal_messages/#{moderator.username}.json\"\n\n        expect(response.status).to eq(200)\n\n        tag = response.parsed_body[\"tags\"]\n        expect(tag[0][\"id\"]).to eq(\"test\")\n      end\n    end\n\n    context \"as an admin\" do\n      before { sign_in(admin) }\n\n      it \"can see pm tags for regular user\" do\n        get \"/tags/personal_messages/#{regular_user.username}.json\"\n\n        expect(response.status).to eq(200)\n\n        tag = response.parsed_body[\"tags\"]\n        expect(tag[0][\"id\"]).to eq(\"test\")\n      end\n\n      it \"can see their own pm tags\" do\n        get \"/tags/personal_messages/#{admin.username}.json\"\n\n        expect(response.status).to eq(200)\n\n        tag = response.parsed_body[\"tags\"]\n        expect(tag[0][\"id\"]).to eq(\"test\")\n      end\n\n      it \"works with usernames with a period\" do\n        admin.update!(username: \"test.test\")\n\n        get \"/tags/personal_messages/#{admin.username}.json\"\n\n        expect(response.status).to eq(200)\n      end\n    end\n  end\n\n  describe \"#show_latest\" do\n    fab!(:tag) { Fabricate(:tag) }\n    fab!(:other_tag) { Fabricate(:tag) }\n    fab!(:third_tag) { Fabricate(:tag) }\n\n    fab!(:single_tag_topic) { Fabricate(:topic, tags: [tag]) }\n    fab!(:multi_tag_topic) { Fabricate(:topic, tags: [tag, other_tag]) }\n    fab!(:all_tag_topic) { Fabricate(:topic, tags: [tag, other_tag, third_tag]) }\n\n    context \"with tagging disabled\" do\n      it \"returns 404\" do\n        SiteSetting.tagging_enabled = false\n        get \"/tag/#{tag.name}/l/latest.json\"\n        expect(response.status).to eq(404)\n      end\n    end\n\n    context \"with tagging enabled\" do\n      def parse_topic_ids\n        response.parsed_body[\"topic_list\"][\"topics\"].map { |topic| topic[\"id\"] }\n      end\n\n      it \"can filter by tag\" do\n        get \"/tag/#{tag.name}/l/latest.json\"\n        expect(response.status).to eq(200)\n      end\n\n      it \"can render a topic list from the latest endpoint\" do\n        get \"/tag/#{tag.name}/l/latest\"\n        expect(response.status).to eq(200)\n        expect(response.body).to include(\"topic-list\")\n      end\n\n      it \"can filter by two tags\" do\n        single_tag_topic\n        multi_tag_topic\n        all_tag_topic\n\n        get \"/tag/#{tag.name}/l/latest.json\", params: { additional_tag_ids: other_tag.name }\n\n        expect(response.status).to eq(200)\n\n        topic_ids = parse_topic_ids\n        expect(topic_ids).to include(all_tag_topic.id)\n        expect(topic_ids).to include(multi_tag_topic.id)\n        expect(topic_ids).to_not include(single_tag_topic.id)\n      end\n\n      it \"can filter by multiple tags\" do\n        single_tag_topic\n        multi_tag_topic\n        all_tag_topic\n\n        get \"/tag/#{tag.name}/l/latest.json\",\n            params: {\n              additional_tag_ids: \"#{other_tag.name}/#{third_tag.name}\",\n            }\n\n        expect(response.status).to eq(200)\n\n        topic_ids = parse_topic_ids\n        expect(topic_ids).to include(all_tag_topic.id)\n        expect(topic_ids).to_not include(multi_tag_topic.id)\n        expect(topic_ids).to_not include(single_tag_topic.id)\n      end\n\n      it \"does not find any tags when a tag which doesn't exist is passed\" do\n        single_tag_topic\n\n        get \"/tag/#{tag.name}/l/latest.json\", params: { additional_tag_ids: \"notatag\" }\n\n        expect(response.status).to eq(200)\n\n        topic_ids = parse_topic_ids\n        expect(topic_ids).to_not include(single_tag_topic.id)\n      end\n\n      it \"can filter by category and tag\" do\n        get \"/tags/c/#{category.slug}/#{tag.name}/l/latest.json\"\n        expect(response.status).to eq(200)\n      end\n\n      it \"can filter by category, sub-category, and tag\" do\n        get \"/tags/c/#{category.slug}/#{subcategory.slug}/#{tag.name}/l/latest.json\"\n        expect(response.status).to eq(200)\n      end\n\n      it \"can filter by category, no sub-category, and tag\" do\n        get \"/tags/c/#{category.slug}/none/#{tag.name}/l/latest.json\"\n        expect(response.status).to eq(200)\n      end\n\n      it \"can handle subcategories with the same name\" do\n        category2 = Fabricate(:category)\n        subcategory2 =\n          Fabricate(\n            :category,\n            parent_category_id: category2.id,\n            name: subcategory.name,\n            slug: subcategory.slug,\n          )\n        t = Fabricate(:topic, category_id: subcategory2.id, tags: [other_tag])\n        get \"/tags/c/#{category2.slug}/#{subcategory2.slug}/#{other_tag.name}/l/latest.json\"\n\n        expect(response.status).to eq(200)\n\n        topic_ids = parse_topic_ids\n        expect(topic_ids).to include(t.id)\n      end\n\n      context \"when logged in\" do\n        before { sign_in(user) }\n\n        it \"can filter by bookmarked\" do\n          get \"/tag/#{tag.name}/l/bookmarks.json\"\n\n          expect(response.status).to eq(200)\n        end\n\n        it \"returns a 404 when tag is restricted\" do\n          tag_group = Fabricate(:tag_group, permissions: { \"staff\" => 1 }, tag_names: [\"test\"])\n\n          get \"/tag/test/l/latest.json\"\n          expect(response.status).to eq(404)\n\n          sign_in(admin)\n\n          get \"/tag/test/l/latest.json\"\n          expect(response.status).to eq(200)\n        end\n\n        context \"with muted tags\" do\n          before do\n            TagUser.create!(\n              user_id: user.id,\n              tag_id: tag.id,\n              notification_level: CategoryUser.notification_levels[:muted],\n            )\n          end\n\n          it \"includes topics when filtered by muted tag\" do\n            single_tag_topic\n\n            get \"/tag/#{tag.name}/l/latest.json\"\n            expect(response.status).to eq(200)\n\n            topic_ids = parse_topic_ids\n            expect(topic_ids).to include(single_tag_topic.id)\n          end\n\n          it \"includes topics when filtered by category and muted tag\" do\n            category = Fabricate(:category)\n            single_tag_topic.update!(category: category)\n\n            get \"/tags/c/#{category.slug}/#{tag.name}/l/latest.json\"\n            expect(response.status).to eq(200)\n\n            topic_ids = parse_topic_ids\n            expect(topic_ids).to include(single_tag_topic.id)\n          end\n        end\n      end\n    end\n  end\n\n  describe \"#show_top\" do\n    fab!(:tag) { Fabricate(:tag) }\n\n    fab!(:category) { Fabricate(:category) }\n    fab!(:topic) { Fabricate(:topic, category: category) }\n    fab!(:tag_topic) { Fabricate(:topic, category: category, tags: [tag]) }\n    fab!(:tag_topic2) { Fabricate(:topic, category: category, tags: [tag]) }\n\n    before do\n      SiteSetting.top_page_default_timeframe = \"all\"\n      TopTopic.create!(topic: topic, all_score: 1)\n      TopTopic.create!(topic: tag_topic, all_score: 1)\n      TopTopic.create!(topic: tag_topic2, daily_score: 1)\n    end\n\n    it \"can filter by tag\" do\n      get \"/tag/#{tag.name}/l/top.json\"\n      expect(response.status).to eq(200)\n\n      topic_ids = response.parsed_body[\"topic_list\"][\"topics\"].map { |topic| topic[\"id\"] }\n      expect(topic_ids).to eq([tag_topic.id])\n    end\n\n    it \"can filter by tag and period\" do\n      get \"/tag/#{tag.name}/l/top.json?period=daily\"\n      expect(response.status).to eq(200)\n\n      list = response.parsed_body[\"topic_list\"]\n      topic_ids = list[\"topics\"].map { |topic| topic[\"id\"] }\n      expect(topic_ids).to eq([tag_topic2.id])\n      expect(list[\"for_period\"]).to eq(\"daily\")\n    end\n\n    it \"can filter by both category and tag\" do\n      get \"/tags/c/#{category.slug}/#{category.id}/#{tag.name}/l/top.json\"\n      expect(response.status).to eq(200)\n\n      topic_ids = response.parsed_body[\"topic_list\"][\"topics\"].map { |topic| topic[\"id\"] }\n      expect(topic_ids).to eq([tag_topic.id])\n    end\n\n    it \"raises an error if the period is not valid\" do\n      get \"/tag/#{tag.name}/l/top.json?period=decadely\"\n      expect(response.status).to eq(400)\n    end\n\n    it \"returns a 404 if tag is restricted\" do\n      tag_group = Fabricate(:tag_group, permissions: { \"staff\" => 1 }, tag_names: [\"test\"])\n\n      get \"/tag/test/l/top.json\"\n      expect(response.status).to eq(404)\n\n      sign_in(admin)\n\n      get \"/tag/test/l/top.json\"\n      expect(response.status).to eq(200)\n    end\n  end\n\n  describe \"#search\" do\n    context \"with tagging disabled\" do\n      it \"returns 404\" do\n        SiteSetting.tagging_enabled = false\n        get \"/tags/filter/search.json\", params: { q: \"stuff\" }\n        expect(response.status).to eq(404)\n      end\n    end\n\n    context \"with tagging enabled\" do\n      it \"can return some tags\" do\n        tag_names = %w[stuff stinky stumped]\n        tag_names.each { |name| Fabricate(:tag, name: name) }\n        get \"/tags/filter/search.json\", params: { q: \"stu\" }\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"results\"].map { |j| j[\"id\"] }.sort).to eq(%w[stuff stumped])\n      end\n\n      it \"returns tags ordered by public_topic_count, and prioritises exact matches\" do\n        Fabricate(:tag, name: \"tag1\", public_topic_count: 10, staff_topic_count: 10)\n        Fabricate(:tag, name: \"tag2\", public_topic_count: 100, staff_topic_count: 100)\n        Fabricate(:tag, name: \"tag\", public_topic_count: 1, staff_topic_count: 1)\n\n        get \"/tags/filter/search.json\", params: { q: \"tag\", limit: 2 }\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"results\"].map { |j| j[\"id\"] }).to eq(%w[tag tag2])\n      end\n\n      context \"with category restriction\" do\n        fab!(:yup) { Fabricate(:tag, name: \"yup\") }\n        fab!(:category) { Fabricate(:category, tags: [yup]) }\n\n        it \"can say if given tag is not allowed\" do\n          nope = Fabricate(:tag, name: \"nope\")\n          get \"/tags/filter/search.json\", params: { q: nope.name, categoryId: category.id }\n          expect(response.status).to eq(200)\n          expect(response.parsed_body[\"results\"].map { |j| j[\"id\"] }.sort).to eq([])\n          expect(response.parsed_body[\"forbidden\"]).to be_present\n          expect(response.parsed_body[\"forbidden_message\"]).to eq(\n            I18n.t(\"tags.forbidden.in_this_category\", tag_name: nope.name),\n          )\n        end\n\n        it \"can say if given tag is restricted to different category\" do\n          category\n          get \"/tags/filter/search.json\",\n              params: {\n                q: yup.name,\n                categoryId: Fabricate(:category).id,\n              }\n          expect(response.parsed_body[\"results\"].map { |j| j[\"id\"] }.sort).to eq([])\n          expect(response.parsed_body[\"forbidden\"]).to be_present\n          expect(response.parsed_body[\"forbidden_message\"]).to eq(\n            I18n.t(\n              \"tags.forbidden.restricted_to\",\n              count: 1,\n              tag_name: yup.name,\n              category_names: category.name,\n            ),\n          )\n        end\n\n        it \"can filter on category without q param\" do\n          nope = Fabricate(:tag, name: \"nope\")\n          get \"/tags/filter/search.json\", params: { categoryId: category.id }\n          expect(response.status).to eq(200)\n          expect(response.parsed_body[\"results\"].map { |j| j[\"id\"] }.sort).to eq([yup.name])\n        end\n      end\n\n      context \"with synonyms\" do\n        fab!(:tag) { Fabricate(:tag, name: \"plant\") }\n        fab!(:synonym) { Fabricate(:tag, name: \"plants\", target_tag: tag) }\n\n        it \"can return synonyms\" do\n          get \"/tags/filter/search.json\", params: { q: \"plant\" }\n          expect(response.status).to eq(200)\n          expect(response.parsed_body[\"results\"].map { |j| j[\"id\"] }).to contain_exactly(\n            \"plant\",\n            \"plants\",\n          )\n        end\n\n        it \"can omit synonyms\" do\n          get \"/tags/filter/search.json\", params: { q: \"plant\", excludeSynonyms: \"true\" }\n          expect(response.status).to eq(200)\n          expect(response.parsed_body[\"results\"].map { |j| j[\"id\"] }).to contain_exactly(\"plant\")\n        end\n\n        it \"can return a message about synonyms not being allowed\" do\n          get \"/tags/filter/search.json\", params: { q: \"plants\", excludeSynonyms: \"true\" }\n          expect(response.status).to eq(200)\n          expect(response.parsed_body[\"results\"].map { |j| j[\"id\"] }.sort).to eq([])\n          expect(response.parsed_body[\"forbidden\"]).to be_present\n          expect(response.parsed_body[\"forbidden_message\"]).to eq(\n            I18n.t(\"tags.forbidden.synonym\", tag_name: tag.name),\n          )\n        end\n      end\n\n      it \"matches tags after sanitizing input\" do\n        yup, nope = Fabricate(:tag, name: \"yup\"), Fabricate(:tag, name: \"nope\")\n        get \"/tags/filter/search.json\", params: { q: \"N/ope\" }\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"results\"].map { |j| j[\"id\"] }.sort).to eq([\"nope\"])\n      end\n\n      it \"can return tags that are in secured categories but are allowed to be used\" do\n        c = Fabricate(:private_category, group: Fabricate(:group))\n        Fabricate(:topic, category: c, tags: [Fabricate(:tag, name: \"cooltag\")])\n        get \"/tags/filter/search.json\", params: { q: \"cool\" }\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"results\"].map { |j| j[\"id\"] }).to eq([\"cooltag\"])\n      end\n\n      it \"supports Chinese and Russian\" do\n        tag_names = %w[\u623f\u5730\u4ea7 \u0442\u0435\u043c\u0430-\u0432-\u0440\u0430\u0437\u0440\u0430\u0431\u043e\u0442\u043a\u0435]\n        tag_names.each { |name| Fabricate(:tag, name: name) }\n\n        get \"/tags/filter/search.json\", params: { q: \"\u623f\" }\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"results\"].map { |j| j[\"id\"] }).to eq([\"\u623f\u5730\u4ea7\"])\n\n        get \"/tags/filter/search.json\", params: { q: \"\u0442\u0435\u043c\u0430\" }\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"results\"].map { |j| j[\"id\"] }).to eq([\"\u0442\u0435\u043c\u0430-\u0432-\u0440\u0430\u0437\u0440\u0430\u0431\u043e\u0442\u043a\u0435\"])\n      end\n\n      it \"can return all the results\" do\n        tag_group1 = Fabricate(:tag_group, tag_names: %w[common1 common2 group1tag group1tag2])\n        tag_group2 = Fabricate(:tag_group, tag_names: %w[common1 common2])\n        category = Fabricate(:category, tag_groups: [tag_group1])\n        get \"/tags/filter/search.json\",\n            params: {\n              q: \"\",\n              limit: 5,\n              categoryId: category.id,\n              filterForInput: \"true\",\n            }\n\n        expect(response.status).to eq(200)\n        expect_same_tag_names(\n          response.parsed_body[\"results\"].map { |j| j[\"id\"] },\n          %w[common1 common2 group1tag group1tag2],\n        )\n      end\n\n      it \"returns error 400 for negative limit\" do\n        get \"/tags/filter/search.json\", params: { q: \"\", limit: -1 }\n\n        expect(response.status).to eq(400)\n        expect(response.parsed_body[\"errors\"].first).to eq(\n          I18n.t(\"invalid_params\", message: \"limit\"),\n        )\n      end\n\n      it \"includes required tag group information\" do\n        tag1 = Fabricate(:tag)\n        tag2 = Fabricate(:tag)\n\n        tag_group = Fabricate(:tag_group, tags: [tag1, tag2])\n        crtg = CategoryRequiredTagGroup.new(tag_group: tag_group, min_count: 1)\n        category = Fabricate(:category, category_required_tag_groups: [crtg])\n\n        get \"/tags/filter/search.json\",\n            params: {\n              q: \"\",\n              categoryId: category.id,\n              filterForInput: true,\n            }\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"results\"].map { |t| t[\"name\"] }).to contain_exactly(\n          tag1.name,\n          tag2.name,\n        )\n        expect(response.parsed_body[\"required_tag_group\"]).to eq(\n          { \"name\" => tag_group.name, \"min_count\" => crtg.min_count },\n        )\n\n        get \"/tags/filter/search.json\",\n            params: {\n              q: \"\",\n              categoryId: category.id,\n              filterForInput: true,\n              selected_tags: [tag1.name],\n            }\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"results\"].map { |t| t[\"name\"] }).to contain_exactly(tag2.name)\n        expect(response.parsed_body[\"required_tag_group\"]).to eq(nil)\n      end\n    end\n  end\n\n  describe \"#destroy\" do\n    context \"with tagging enabled\" do\n      before { sign_in(admin) }\n\n      context \"with an existent tag name\" do\n        it \"deletes the tag\" do\n          tag = Fabricate(:tag)\n          delete \"/tag/#{tag.name}.json\"\n          expect(response.status).to eq(200)\n          expect(Tag.where(id: tag.id)).to be_empty\n        end\n      end\n\n      context \"with a nonexistent tag name\" do\n        it \"returns a tag not found message\" do\n          delete \"/tag/doesntexists.json\"\n          expect(response).not_to be_successful\n          expect(response.parsed_body[\"error_type\"]).to eq(\"not_found\")\n        end\n      end\n    end\n  end\n\n  describe \"#unused\" do\n    it \"fails if you can't manage tags\" do\n      sign_in(user)\n      get \"/tags/unused.json\"\n      expect(response.status).to eq(403)\n      delete \"/tags/unused.json\"\n      expect(response.status).to eq(403)\n    end\n\n    context \"when logged in\" do\n      before { sign_in(admin) }\n\n      context \"with some tags\" do\n        let!(:tags) do\n          [\n            Fabricate(\n              :tag,\n              name: \"used_publically\",\n              public_topic_count: 2,\n              staff_topic_count: 2,\n              pm_topic_count: 0,\n            ),\n            Fabricate(\n              :tag,\n              name: \"used_privately\",\n              public_topic_count: 0,\n              staff_topic_count: 0,\n              pm_topic_count: 3,\n            ),\n            Fabricate(\n              :tag,\n              name: \"used_everywhere\",\n              public_topic_count: 0,\n              staff_topic_count: 0,\n              pm_topic_count: 3,\n            ),\n            Fabricate(\n              :tag,\n              name: \"unused1\",\n              public_topic_count: 0,\n              staff_topic_count: 0,\n              pm_topic_count: 0,\n            ),\n            Fabricate(\n              :tag,\n              name: \"unused2\",\n              public_topic_count: 0,\n              staff_topic_count: 0,\n              pm_topic_count: 0,\n            ),\n          ]\n        end\n\n        it \"returns the correct unused tags\" do\n          get \"/tags/unused.json\"\n          expect(response.status).to eq(200)\n          expect(response.parsed_body[\"tags\"]).to contain_exactly(\"unused1\", \"unused2\")\n        end\n\n        it \"deletes the correct tags\" do\n          expect { delete \"/tags/unused.json\" }.to change { Tag.count }.by(-2) &\n            change { UserHistory.count }.by(1)\n          expect(Tag.pluck(:name)).to contain_exactly(\n            \"used_publically\",\n            \"used_privately\",\n            \"used_everywhere\",\n          )\n        end\n      end\n    end\n  end\n\n  describe \"#upload_csv\" do\n    it \"requires you to be logged in\" do\n      post \"/tags/upload.json\"\n      expect(response.status).to eq(403)\n    end\n\n    context \"while logged in\" do\n      let(:csv_file) { File.new(\"#{Rails.root}/spec/fixtures/csv/tags.csv\") }\n      let(:invalid_csv_file) { File.new(\"#{Rails.root}/spec/fixtures/csv/tags_invalid.csv\") }\n\n      let(:file) { Rack::Test::UploadedFile.new(File.open(csv_file)) }\n\n      let(:invalid_file) { Rack::Test::UploadedFile.new(File.open(invalid_csv_file)) }\n\n      let(:filename) { \"tags.csv\" }\n\n      it \"fails if you can't manage tags\" do\n        sign_in(user)\n        post \"/tags/upload.json\", params: { file: file, name: filename }\n        expect(response.status).to eq(403)\n      end\n\n      it \"allows staff to bulk upload tags\" do\n        sign_in(moderator)\n        post \"/tags/upload.json\", params: { file: file, name: filename }\n        expect(response.status).to eq(200)\n        expect(Tag.pluck(:name)).to contain_exactly(\n          \"tag1\",\n          \"capitaltag2\",\n          \"spaced-tag\",\n          \"tag3\",\n          \"tag4\",\n        )\n        expect(Tag.find_by_name(\"tag3\").tag_groups.pluck(:name)).to contain_exactly(\"taggroup1\")\n        expect(Tag.find_by_name(\"tag4\").tag_groups.pluck(:name)).to contain_exactly(\"taggroup1\")\n      end\n\n      it \"fails gracefully with invalid input\" do\n        sign_in(moderator)\n\n        expect do\n          post \"/tags/upload.json\", params: { file: invalid_file, name: filename }\n          expect(response.status).to eq(422)\n        end.not_to change { [Tag.count, TagGroup.count] }\n      end\n    end\n  end\n\n  describe \"#create_synonyms\" do\n    fab!(:tag) { Fabricate(:tag) }\n\n    it \"fails if not logged in\" do\n      post \"/tag/#{tag.name}/synonyms.json\", params: { synonyms: [\"synonym1\"] }\n      expect(response.status).to eq(403)\n    end\n\n    it \"fails if not staff user\" do\n      sign_in(user)\n      post \"/tag/#{tag.name}/synonyms.json\", params: { synonyms: [\"synonym1\"] }\n      expect(response.status).to eq(403)\n    end\n\n    context \"when signed in as admin\" do\n      before { sign_in(admin) }\n\n      it \"can make a tag a synonym of another tag\" do\n        tag2 = Fabricate(:tag)\n        expect {\n          post \"/tag/#{tag.name}/synonyms.json\", params: { synonyms: [tag2.name] }\n        }.to_not change { Tag.count }\n        expect(response.status).to eq(200)\n        expect(tag2.reload.target_tag).to eq(tag)\n      end\n\n      it \"can create new tags at the same time\" do\n        expect {\n          post \"/tag/#{tag.name}/synonyms.json\", params: { synonyms: [\"synonym\"] }\n        }.to change { Tag.count }.by(1)\n        expect(response.status).to eq(200)\n        expect(Tag.find_by_name(\"synonym\")&.target_tag).to eq(tag)\n      end\n\n      it \"can return errors\" do\n        tag2 = Fabricate(:tag, target_tag: tag)\n        tag3 = Fabricate(:tag)\n        post \"/tag/#{tag3.name}/synonyms.json\", params: { synonyms: [tag.name] }\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"failed\"]).to be_present\n        expect(response.parsed_body.dig(\"failed_tags\", tag.name)).to be_present\n      end\n    end\n  end\n\n  describe \"#destroy_synonym\" do\n    fab!(:tag) { Fabricate(:tag) }\n    fab!(:synonym) { Fabricate(:tag, target_tag: tag, name: \"synonym\") }\n    subject { delete(\"/tag/#{tag.name}/synonyms/#{synonym.name}.json\") }\n\n    it \"fails if not logged in\" do\n      subject\n      expect(response.status).to eq(403)\n    end\n\n    it \"fails if not staff user\" do\n      sign_in(user)\n      subject\n      expect(response.status).to eq(403)\n    end\n\n    context \"when signed in as admin\" do\n      before { sign_in(admin) }\n\n      it \"can remove a synonym from a tag\" do\n        synonym2 = Fabricate(:tag, target_tag: tag, name: \"synonym2\")\n        expect { subject }.to_not change { Tag.count }\n        expect_same_tag_names(tag.reload.synonyms, [synonym2])\n        expect(synonym.reload).to_not be_synonym\n      end\n\n      it \"returns error if tag isn't a synonym\" do\n        delete \"/tag/#{Fabricate(:tag).name}/synonyms/#{synonym.name}.json\"\n        expect(response.status).to eq(400)\n        expect_same_tag_names(tag.reload.synonyms, [synonym])\n      end\n\n      it \"returns error if synonym not found\" do\n        delete \"/tag/#{Fabricate(:tag).name}/synonyms/nope.json\"\n        expect(response.status).to eq(404)\n        expect_same_tag_names(tag.reload.synonyms, [synonym])\n      end\n    end\n  end\n\n  describe \"#update_notifications\" do\n    fab!(:tag) { Fabricate(:tag) }\n\n    before { sign_in(user) }\n\n    it \"returns 404 when tag is not found\" do\n      put \"/tag/someinvalidtagname/notifications.json\"\n\n      expect(response.status).to eq(404)\n    end\n\n    it \"updates the notification level of a tag for a user\" do\n      tag_user = TagUser.change(user.id, tag.id, NotificationLevels.all[:muted])\n\n      put \"/tag/#{tag.name}/notifications.json\",\n          params: {\n            tag_notification: {\n              notification_level: NotificationLevels.all[:tracking],\n            },\n          }\n\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"watched_tags\"]).to eq([])\n      expect(response.parsed_body[\"watching_first_post_tags\"]).to eq([])\n      expect(response.parsed_body[\"tracked_tags\"]).to eq([tag.name])\n      expect(response.parsed_body[\"muted_tags\"]).to eq([])\n      expect(response.parsed_body[\"regular_tags\"]).to eq([])\n\n      expect(tag_user.reload.notification_level).to eq(NotificationLevels.all[:tracking])\n    end\n\n    it \"sets the notification level of a tag for a user\" do\n      expect do\n        put \"/tag/#{tag.name}/notifications.json\",\n            params: {\n              tag_notification: {\n                notification_level: NotificationLevels.all[:muted],\n              },\n            }\n\n        expect(response.status).to eq(200)\n\n        expect(response.parsed_body[\"watched_tags\"]).to eq([])\n        expect(response.parsed_body[\"watching_first_post_tags\"]).to eq([])\n        expect(response.parsed_body[\"tracked_tags\"]).to eq([])\n        expect(response.parsed_body[\"muted_tags\"]).to eq([tag.name])\n        expect(response.parsed_body[\"regular_tags\"]).to eq([])\n      end.to change { user.tag_users.count }.by(1)\n\n      tag_user = user.tag_users.last\n\n      expect(tag_user.notification_level).to eq(NotificationLevels.all[:muted])\n    end\n  end\nend\n"], "filenames": ["app/controllers/tags_controller.rb", "spec/requests/tags_controller_spec.rb"], "buggy_code_start_loc": [8, 678], "buggy_code_end_loc": [12, 756], "fixing_code_start_loc": [7, 679], "fixing_code_end_loc": [14, 781], "type": "NVD-CWE-noinfo", "message": "Discourse is an open-source discussion platform. Prior to version 3.0.1 of the `stable` branch and version 3.1.0.beta2 of the `beta` and `tests-passed` branches, the count of topics displayed for a tag is a count of all regular topics regardless of whether the topic is in a read restricted category or not. As a result, any users can technically poll a sensitive tag to determine if a new topic is created in a category which the user does not have excess to. In version 3.0.1 of the `stable` branch and version 3.1.0.beta2 of the `beta` and `tests-passed` branches, the count of topics displayed for a tag defaults to only counting regular topics which are not in read restricted categories. Staff users will continue to see a count of all topics regardless of the topic's category read restrictions.", "other": {"cve": {"id": "CVE-2023-23622", "sourceIdentifier": "security-advisories@github.com", "published": "2023-03-17T15:15:12.147", "lastModified": "2023-03-23T20:21:36.680", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Discourse is an open-source discussion platform. Prior to version 3.0.1 of the `stable` branch and version 3.1.0.beta2 of the `beta` and `tests-passed` branches, the count of topics displayed for a tag is a count of all regular topics regardless of whether the topic is in a read restricted category or not. As a result, any users can technically poll a sensitive tag to determine if a new topic is created in a category which the user does not have excess to. In version 3.0.1 of the `stable` branch and version 3.1.0.beta2 of the `beta` and `tests-passed` branches, the count of topics displayed for a tag defaults to only counting regular topics which are not in read restricted categories. Staff users will continue to see a count of all topics regardless of the topic's category read restrictions."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:*:*:*:*:stable:*:*:*", "versionEndExcluding": "3.0.0", "matchCriteriaId": "73E3B1B2-6F62-4A60-8C75-C9ADD81AC748"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.1.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "BF272688-1B08-4ABC-8002-66B59690F9A5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.1.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "A29A2465-B21D-4147-8292-DCF864D385B4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.1.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "BBC3511E-3D68-42E2-B521-966FB429B640"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.1.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "EC8B99C2-E267-4EC2-AF09-C9AD1EEE76D9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.1.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "F21A22EE-081A-4489-A7F8-22E2DBC5B00E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.1.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "6E6C8FB3-4B19-4510-B9A8-BCF9ED8ED7C9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.1.0:beta6b:*:*:beta:*:*:*", "matchCriteriaId": "5B827291-6483-4BB7-AF76-530B669B3ED5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.1.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "551E70ED-34FF-4989-91C9-6312DE4AB4DF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.1.0:beta8:*:*:beta:*:*:*", "matchCriteriaId": "204FB99A-8F11-4F04-9ED9-D94551790116"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.2.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "46A8705C-0DF6-45D7-A38C-D2AB69194C59"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.2.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "F59B0D8E-CFFB-4EBA-9D6A-526F9541BA17"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.2.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "D801A898-27D0-4076-8AF9-2B574FA11723"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.2.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "E7CBBD4A-4FDB-49E0-A5B6-22701C12BDF2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.2.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "9E7328DF-1924-4D0D-AC6B-1BA2D9CF1D4D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.2.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "9421CE10-F226-4F2C-9DA7-EBB44B73C304"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.2.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "1E71FBB6-ECAD-4581-9982-4C330D55FEAF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.2.0:beta8:*:*:beta:*:*:*", "matchCriteriaId": "1B631CCC-D456-49FF-B626-59C40BD4E167"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.2.0:beta9:*:*:beta:*:*:*", "matchCriteriaId": "BE83F98D-F7AA-434B-8438-5B1FB96681B9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.3.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "EB93F19B-9087-44CE-B884-45F434B7906F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.3.0:beta10:*:*:beta:*:*:*", "matchCriteriaId": "5A88A5A3-EF1A-4E86-B074-CE0AC4325484"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.3.0:beta11:*:*:beta:*:*:*", "matchCriteriaId": "0650B4C7-BCFE-4180-8FEF-4170A67E8BD3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.3.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "388F376E-46C9-4163-992D-95E3E4548D0F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.3.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "D661090A-DA61-4BBE-85C3-6F48C053C84B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.3.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "4A458242-D6DD-46E3-AF09-66BC87C5D7A6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.3.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "A8FACCBA-0D3B-4E6F-85A0-1CBD2B367F71"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.3.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "F1D83D80-A0BE-4794-91A1-599AF558FB67"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.3.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "BD15B6B2-BFB3-4271-A507-48E9B827FA02"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.3.0:beta8:*:*:beta:*:*:*", "matchCriteriaId": "E0003042-9B14-4E1B-800F-3D154FFE8A1A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.3.0:beta9:*:*:beta:*:*:*", "matchCriteriaId": "E449EA29-81C8-4477-977E-746EACDBED86"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.4.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "6FC6D4DF-8686-4054-A0C1-784E194171E6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.4.0:beta10:*:*:beta:*:*:*", "matchCriteriaId": "C574C37D-3D99-4430-A3D5-199883556B64"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.4.0:beta11:*:*:beta:*:*:*", "matchCriteriaId": "F344E950-EFF9-4405-99D7-0B615C32873F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.4.0:beta12:*:*:beta:*:*:*", "matchCriteriaId": "0A50DE1B-29EB-4014-B5B6-46CF493485F2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.4.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "638B3E17-9F0A-4A96-B8D3-DDFEA518DBE9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.4.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "6D3E3AEB-8CD4-4EE7-9C81-2F74512071DD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.4.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "254FF9D9-E696-41C8-B15B-DA089D2C6597"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.4.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "2A5001E1-E716-43AA-8093-E0EED9E07909"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.4.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "7FD16B13-516A-4D03-B1EF-A11156471A06"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.4.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "E886D9EF-7FBD-4A24-A8B6-54E4B15403C6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.4.0:beta8:*:*:beta:*:*:*", "matchCriteriaId": "369A83D1-AB7E-488D-9D74-26A69DFC1AD9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.4.0:beta9:*:*:beta:*:*:*", "matchCriteriaId": "3189CAC1-8970-4A33-B1E4-EB9EC3C19A25"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.5.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "A8733438-7625-400E-8237-BAE3D9F147AB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.5.0:beta10:*:*:beta:*:*:*", "matchCriteriaId": "E87F1ED0-FD0D-4767-8E7C-325D920B79BD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.5.0:beta11:*:*:beta:*:*:*", "matchCriteriaId": "97811266-A13C-4441-A1B5-BFA4B0862DFE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.5.0:beta12:*:*:beta:*:*:*", "matchCriteriaId": "3D09D157-4B19-4561-AB20-952F2EA9BA0C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.5.0:beta13:*:*:beta:*:*:*", "matchCriteriaId": "789087AF-0011-4E8F-A5AB-432A5F91BBA8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.5.0:beta13b:*:*:beta:*:*:*", "matchCriteriaId": "8EC9DC8C-56DC-482B-8847-BD0CFACA6F8D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.5.0:beta14:*:*:beta:*:*:*", "matchCriteriaId": "F63B3D13-24F6-4EFA-9528-DBF59D973A9A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.5.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "7F3A2388-18DE-46B0-BC13-7714E25D1B1C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.5.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "940B11CB-053F-4D60-8BC4-81CA659D2F7B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.5.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "83684DCB-B201-43B8-8B6E-6D0B13B7E437"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.5.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "DF92E1FD-9B41-4A41-8B13-9D789C5729D6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.5.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "351D224A-E67C-454C-AF43-8AD6CD44C685"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.5.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "E058CA6D-A295-4CAD-8C85-E8C83BAFEBD2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.5.0:beta8:*:*:beta:*:*:*", "matchCriteriaId": "FF99C114-1BCA-4400-BC7E-EDA1F55559CE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.5.0:beta9:*:*:beta:*:*:*", "matchCriteriaId": "BBA1EFBA-5A26-46A0-B2A6-53B9924253BF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.6.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "FE5B90B0-B6CC-4189-9C98-CF29017A47B5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.6.0:beta10:*:*:beta:*:*:*", "matchCriteriaId": "A1818628-5F4E-4E5D-974A-0BEBCE821209"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.6.0:beta11:*:*:beta:*:*:*", "matchCriteriaId": "14785840-3BC0-4030-AE44-E3013DF19AD7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.6.0:beta12:*:*:beta:*:*:*", "matchCriteriaId": "90444209-684C-4BF8-9BCF-6B29EA0A0593"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.6.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "668E15DE-8CF2-4AF3-B13A-9080046B1E03"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.6.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "1191861C-1B2C-4762-805D-FCDC20F84D05"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.6.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "3CB518E5-CCC0-46B8-848E-C492BCF7E9BB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.6.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "CA1F68FE-67EA-4408-8E0F-558B0FAFFF32"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.6.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "66E9F05C-799A-43D3-9367-FCA86166BD65"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.6.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "85DB4097-6EFC-4017-ADFD-56EE49BB2F34"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.6.0:beta8:*:*:beta:*:*:*", "matchCriteriaId": "AD283EA2-9026-497F-A7DE-E16CE0764ED0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.6.0:beta9:*:*:beta:*:*:*", "matchCriteriaId": "ED19DDDF-A29E-4C3F-A818-23D7E37B6974"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.7.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "508D0052-B7D7-4A08-8BB0-7D7A1EDAB96D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.7.0:beta10:*:*:beta:*:*:*", "matchCriteriaId": "3E50BFB0-67D3-4EDE-93FE-85EAF605461E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.7.0:beta11:*:*:beta:*:*:*", "matchCriteriaId": "D7EE0134-6AD7-4695-B536-1959FE3A9672"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.7.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "25DFFB5C-277F-4436-9BCE-643E98721C5A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.7.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "B8B80EB2-0B48-4AFA-8A09-26006CCDB022"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.7.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "AC8705E0-23ED-4817-8B69-21A4963C27F8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.7.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "BAA156A9-A9FB-4D03-B0EE-4AA303D7A9CF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.7.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "F733E585-075C-402A-9B34-1FE79DE4137E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.7.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "05C43439-C694-47AA-90AF-0AC2277E3D3B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.7.0:beta8:*:*:beta:*:*:*", "matchCriteriaId": "B391F8A1-F102-4C88-864C-1386452CDAB0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.7.0:beta9:*:*:beta:*:*:*", "matchCriteriaId": "0BC33C93-9947-4983-96A3-7DE223929817"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.8.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "B46DE141-1224-499E-AAE0-6CC0D5249B2C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.8.0:beta10:*:*:beta:*:*:*", "matchCriteriaId": "D8D07501-A07E-4743-A188-2E5BBC3C8F97"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.8.0:beta11:*:*:beta:*:*:*", "matchCriteriaId": "64FD2A30-EE33-4680-9DCF-29283DBA3C4F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.8.0:beta12:*:*:beta:*:*:*", "matchCriteriaId": "B517F7A2-6FD1-4A7B-80E7-1167EC296591"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.8.0:beta13:*:*:beta:*:*:*", "matchCriteriaId": "E6CA6EA5-DDAD-4882-AD1B-634C0CD741BE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.8.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "F14DCB07-9464-4DDE-98A1-FAE85DD60FBC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.8.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "6EDFD679-4710-4A62-B254-E658EED4295B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.8.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "A1B81072-08A5-4EC6-B737-E35C505C1E47"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.8.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "A0748A9E-5737-48F9-BB66-6576AFE16198"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.8.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "453E51D9-89A1-4A91-B218-05C45CC4E329"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.8.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "51542BA7-8151-4FC9-9C86-36CEB476B912"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.8.0:beta8:*:*:beta:*:*:*", "matchCriteriaId": "5F95391C-0B75-47D2-9770-561E05414CEF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.8.0:beta9:*:*:beta:*:*:*", "matchCriteriaId": "10384675-B949-4B50-AF42-B5A3EE27250B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "7C0DB1C0-5749-4508-A265-C2138F7852E9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta10:*:*:beta:*:*:*", "matchCriteriaId": "CA9977CF-575C-4A19-84C8-EBB68EBE88C9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta11:*:*:beta:*:*:*", "matchCriteriaId": "87C525C5-E282-4EC6-956F-0C94DC11FC69"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta12:*:*:beta:*:*:*", "matchCriteriaId": "7F02A2A8-6312-4F6D-ABBF-952CA4C5E02E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta13:*:*:beta:*:*:*", "matchCriteriaId": "DE54D1A3-FC2A-40DE-9177-50332208B0B2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta14:*:*:beta:*:*:*", "matchCriteriaId": "170AE3DA-92C1-4D1D-9CAC-543C01FFF479"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta15:*:*:beta:*:*:*", "matchCriteriaId": "2130C3C5-E4A5-41C3-89F0-C6FB4E47D096"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta16:*:*:beta:*:*:*", "matchCriteriaId": "74248527-B884-4134-95C8-DEAF3D774A9A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta17:*:*:beta:*:*:*", "matchCriteriaId": "01A8AF9C-8BF6-4ADC-A85A-A5C1F9FFB2C7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "B4038D09-467C-4815-A429-F0E1E3E545E7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "6F273237-7223-4047-83B7-16A49B7E554A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "CF26EE13-554C-4180-98A2-238D84E40927"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "12688C9C-291D-4BF2-93F9-09AA323C52A9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "A7F7A437-D538-4B44-AC41-C95641A11A35"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "9BB61DCF-52DB-498D-8779-D565E548C285"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta8:*:*:beta:*:*:*", "matchCriteriaId": "EE56BB77-B7F7-4BE7-AD9C-33888C5D01FE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:1.9.0:beta9:*:*:beta:*:*:*", "matchCriteriaId": "9DB49E1D-BCC8-4984-A81D-5DAC5E3DF168"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.0.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "F775EA72-CCE3-4230-A666-EFDAA61F71FE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.0.0:beta10:*:*:beta:*:*:*", "matchCriteriaId": "5E65BDEE-850A-41C6-8CFB-BD8B3A105CD1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.0.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "AF196429-FDED-4C3F-9F7D-0A2BF7DCAD1E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.0.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "64B84326-5397-4C60-8007-F7E7D81DC661"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.0.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "9A0A526A-9662-4E39-8BF6-E464BE1A2B6F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.0.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "712DACC2-A21E-429F-8A7B-86D8F7CE3468"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.0.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "6E93F9F6-5B03-4F77-B8B4-AEC9E4011692"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.0.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "C5B2B98E-804F-4525-B726-3F1DF2693F79"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.0.0:beta8:*:*:beta:*:*:*", "matchCriteriaId": "582E339F-678A-4377-8EE0-8F4208E3EF78"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.0.0:beta9:*:*:beta:*:*:*", "matchCriteriaId": "1BF1D945-6EAA-4FA7-8252-2FED079587F0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.1.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "9325DFF5-EA7B-4B8D-A227-4B1A59449CE1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.1.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "0ECB28DA-3CA1-4011-9170-BFBF2ED3E091"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.1.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "2A6399B0-471B-4B26-859C-3836F2A6B7D1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.1.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "131E2AE4-E35D-495D-8907-3B899BB8AC41"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.1.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "83601528-0DD9-4835-B6C0-0F341871CC15"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.1.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "4AEB5AAF-73EB-4356-8C53-10E22B2F910E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.2.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "9EB199D6-E253-4EC2-BF0B-059F7B6662ED"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.2.0:beta10:*:*:beta:*:*:*", "matchCriteriaId": "94A586EB-B0E0-4190-88DF-3BCC04E5EF84"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.2.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "0BF27B44-9AA7-4B91-9B4B-0E84418F5632"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.2.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "461744BD-3974-4C33-8514-0A917DC90C6C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.2.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "6A86FB2B-6915-49C0-B993-0711AAECA5FE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.2.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "9EF3DD36-2776-4CD2-A3F1-88872024D223"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.2.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "D91D71ED-F08F-4DB5-B7DD-062E7C11435F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.2.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "62B5812A-FB52-4F4B-9A15-3AA5CD6562E3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.2.0:beta8:*:*:beta:*:*:*", "matchCriteriaId": "83231EC0-E3F7-4E35-B165-487C2725B4F1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.2.0:beta9:*:*:beta:*:*:*", "matchCriteriaId": "A53AFFA6-7B98-47F2-9BD7-71C83A69CE26"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.3.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "A42D3FB9-9197-4101-A729-876C490BD572"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.3.0:beta10:*:*:beta:*:*:*", "matchCriteriaId": "A5DE0C47-0C66-4EFE-AF82-1B22F4F54A44"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.3.0:beta11:*:*:beta:*:*:*", "matchCriteriaId": "E587D10F-BEF8-4923-AF76-6DC3172880EE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.3.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "155568EF-6A7E-423A-B5EA-D20E407B271B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.3.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "7E94B119-8C75-43DF-A2DF-A5B3E04F0778"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.3.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "5348F94F-F6AE-4400-8AC7-036111EF43D9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.3.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "57948A73-C9C5-4C24-947D-0A4659C7002E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.3.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "3532EE37-2D0F-496C-B5A8-F9315FFB4552"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.3.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "2CAE7CC9-B91D-494C-B91A-497D6FE6B14B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.3.0:beta8:*:*:beta:*:*:*", "matchCriteriaId": "623BBBF8-4121-466A-82C8-D179B02B3E34"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.3.0:beta9:*:*:beta:*:*:*", "matchCriteriaId": "648D010A-8B8D-42AA-8888-09E4E0FAA954"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.4.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "8ADC7613-25E3-4CB8-A962-2775C20E4D4F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.4.0:beta10:*:*:beta:*:*:*", "matchCriteriaId": "1B0099F0-A275-4C65-9B79-041374F183DF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.4.0:beta11:*:*:beta:*:*:*", "matchCriteriaId": "FE69800E-5CB5-4916-879C-51DE5E94489F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.4.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "8C64EAFE-2B60-4D95-869F-4A2FC98B99C8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.4.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "AB2045F1-AC39-4738-B3F0-33F00D23C921"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.4.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "E32589F8-2E87-40D2-BAD3-E6C1C088CA60"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.4.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "4868BAFD-BFE5-4361-855A-644B040E7233"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.4.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "4B6C25BF-5B2A-43C4-8918-E32BA9DD8A22"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.4.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "EB9917D3-D848-4D2B-8A44-B3723BA377DA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.4.0:beta8:*:*:beta:*:*:*", "matchCriteriaId": "7046D95B-73CE-406B-ACC3-FD71F7DEC7CE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.4.0:beta9:*:*:beta:*:*:*", "matchCriteriaId": "D3BA5033-2C06-42FF-962E-48EBA2EBB469"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.5.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "630D29DE-0FD7-4306-BA80-20D0791D334B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.5.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "08F94E42-07A1-480D-B6DD-D96AE38F1EBA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.5.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "FA4B3DE5-21DA-4185-AF74-AAA6DD89FB3D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.5.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "E602BEF9-E89D-40F7-BC6F-5C6F9F25BA97"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.5.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "C06A8627-683D-4328-BE7A-4A33A4B736F2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.5.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "E3EF8240-D3F5-422C-B70A-90C6CBA4E622"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.5.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "93CC792D-AE0B-498E-8374-5D09EF4E28FF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.6.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "093D4EA8-B002-4AB4-97C9-CEE4D70BF3C8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.6.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "4C778180-E7BF-4EF2-8B19-0388E23E1424"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.6.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "0C0B2BC1-35F1-4A1D-B9B2-54426B4ADF34"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.6.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "6BCAB620-465A-41FF-A064-FB638DD3A557"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.6.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "6AFCB802-A275-444C-8245-D0397322125F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.6.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "9F9B70E2-AAAD-4E61-AEB2-E5F635F6AAD5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.7.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "6182074E-C467-448C-9299-B92CFE4EEBE0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.7.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "09EA8F36-7647-42D0-8675-34C002E0754D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.7.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "9CE2276A-9680-4B14-9636-806F7E4C1669"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.7.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "AD150166-4C8D-47E3-989A-1A71A46C36A1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.7.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "CF5CA6AD-FA4D-47DF-A684-5DAD7662EA13"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.7.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "B94F75B8-7C84-4727-9D18-114A815E1906"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.7.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "4D94E03A-32EE-408F-81FA-4B9C25AA7DDF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.7.0:beta8:*:*:beta:*:*:*", "matchCriteriaId": "AD495875-007C-4A90-B940-B62E6FA492CC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.7.0:beta9:*:*:beta:*:*:*", "matchCriteriaId": "05F1B84E-8AF8-46E8-9DE9-00D1DE348C2C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "BCCEFDFB-61E6-4846-8093-B5CEB0D8450C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta10:*:*:beta:*:*:*", "matchCriteriaId": "0BC63647-B692-4BB9-9A3D-6F8DF19C3494"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta11:*:*:beta:*:*:*", "matchCriteriaId": "05F0ED55-C8C6-47C1-859A-60046838B6F7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "6A2D59BC-2EE8-4F9C-AB5B-B9D01B44F7CD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "933DFEBC-5568-431B-809D-AFAEFD08E985"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "BE920E80-C02B-4EC8-982F-ADE89C936684"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "CDAE3441-12BA-41F4-8A5A-B2EE844C86BF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "1443EA1B-D210-4219-8452-CBFD5FACBC77"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "948A4B4A-A11F-477E-BEC5-0D60C7E3570C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta8:*:*:beta:*:*:*", "matchCriteriaId": "98B2A052-5427-4B72-9F59-82F430836CB4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta9:*:*:beta:*:*:*", "matchCriteriaId": "CB6D636E-B51F-4648-A637-62B2603BA18F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta1:*:*:beta:*:*:*", "matchCriteriaId": "3DA17871-7ED7-4D68-A46D-D15DC5B3235F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta10:*:*:beta:*:*:*", "matchCriteriaId": "705FE965-0415-4382-8CA1-A19DF3B5EF35"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta11:*:*:beta:*:*:*", "matchCriteriaId": "BC6EDCE3-D564-434F-9A7F-D4A6D579F8F7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta12:*:*:beta:*:*:*", "matchCriteriaId": "FB05E54B-9CF6-45A7-8D47-C98DB6D19E7E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta13:*:*:beta:*:*:*", "matchCriteriaId": "03CD1C5E-18F5-4C6D-B92C-C511C8C12D0B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta14:*:*:beta:*:*:*", "matchCriteriaId": "FF4ABB9D-69DF-42D5-AD60-F9CEEC1B6730"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta2:*:*:beta:*:*:*", "matchCriteriaId": "7B4DCCF5-E290-4BDA-AAB9-DF362A2EB7B3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta3:*:*:beta:*:*:*", "matchCriteriaId": "3AE1F3A2-8340-4ED7-B943-ACDA9617DF64"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta4:*:*:beta:*:*:*", "matchCriteriaId": "5E033AB7-9987-4C30-849F-2495376CA4F2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta5:*:*:beta:*:*:*", "matchCriteriaId": "D87E9338-C7F6-43BA-886F-C30987ADBA1D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta6:*:*:beta:*:*:*", "matchCriteriaId": "E24EB90F-FE81-4746-8741-8DC9346F79C1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta7:*:*:beta:*:*:*", "matchCriteriaId": "D237956F-FC90-467E-A493-24EFDA1A9F2D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta8:*:*:beta:*:*:*", "matchCriteriaId": "F7AA9AB8-AB6F-43E2-B3E5-685EE9BFE7D4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta9:*:*:beta:*:*:*", "matchCriteriaId": "5BC240A1-431E-4A50-88DC-7AC9BC674254"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:3.0.0:beta15:*:*:beta:*:*:*", "matchCriteriaId": "3F85AFD4-D397-4FDB-B762-521BD5FF14C1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:3.0.0:beta16:*:*:beta:*:*:*", "matchCriteriaId": "D40CDCE1-3462-4D6C-A3C7-487F175264CA"}]}]}], "references": [{"url": "https://github.com/discourse/discourse/commit/105fee978d73b0ec23ff814a09d1c0c9ace95164", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/discourse/discourse/commit/ecb9aa5dba94741d9579f4f873f0675f48b4184f", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/discourse/discourse/pull/20004", "source": "security-advisories@github.com", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://github.com/discourse/discourse/pull/20005", "source": "security-advisories@github.com", "tags": ["Issue Tracking"]}, {"url": "https://github.com/discourse/discourse/security/advisories/GHSA-2wvr-4x7w-v795", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/discourse/discourse/commit/105fee978d73b0ec23ff814a09d1c0c9ace95164"}}