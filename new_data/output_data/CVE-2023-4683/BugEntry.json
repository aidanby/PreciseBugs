{"buggy_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2022\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / Scene Management sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/scene_manager.h>\n#include <gpac/utf.h>\n#include <gpac/constants.h>\n#include <gpac/network.h>\n#include <gpac/internal/bifs_dev.h>\n#include <gpac/internal/scenegraph_dev.h>\n\n#include <gpac/nodes_x3d.h>\n#include <gpac/color.h>\n\n\n#if !defined(GPAC_DISABLE_LOADER_BT) && !defined(GPAC_DISABLE_ZLIB)\n\n#include <gpac/mpeg4_odf.h>\n\n/*since 0.2.2, we use zlib for bt reading to handle wrl.gz files*/\n#include <zlib.h>\n\nvoid gf_sm_update_bitwrapper_buffer(GF_Node *node, const char *fileName);\n\nvoid load_bt_done(GF_SceneLoader *load);\n\n#define BT_LINE_SIZE\t4000\n\ntypedef struct\n{\n\tchar *name;\n\tchar *value;\n} BTDefSymbol;\n\ntypedef struct\n{\n\tGF_SceneLoader *load;\n\tBool initialized;\n\tgzFile gz_in;\n\tu32 file_size, file_pos;\n\n\t/*create from string only*/\n\tGF_List *top_nodes;\n\n\tGF_Err last_error;\n\tu32 line;\n\n\tBool done, in_com;\n\tu32 is_wrl;\n\t/*0: no unicode, 1: UTF-16BE, 2: UTF-16LE*/\n\tu32 unicode_type;\n\n\tGF_List *def_symbols;\n\n\t/*routes are not created in the graph when parsing, so we need to track insert and delete/replace*/\n\tGF_List *unresolved_routes, *inserted_routes, *peeked_nodes;\n\tGF_List *undef_nodes, *def_nodes;\n\n\tchar *line_buffer;\n\tchar cur_buffer[500];\n\ts32 line_size, line_pos, line_start_pos;\n\n\tu32 block_comment;\n\n\t/*set when parsing proto*/\n\tGF_Proto *parsing_proto;\n\tBool is_extern_proto_field;\n\n\t/*current stream ID, AU time and RAP flag*/\n\tu32 stream_id;\n\tu32 au_time;\n\tBool au_is_rap;\n\n\t/*current BIFS stream & AU*/\n\tGF_StreamContext *bifs_es;\n\tGF_AUContext *bifs_au;\n\tu32 base_bifs_id;\n\tGF_Command *cur_com;\n\n\t/*current OD stream & AU*/\n\tGF_StreamContext *od_es;\n\tGF_AUContext *od_au;\n\tu32 base_od_id;\n\n\tGF_List *scripts;\n\n\tu32 def_w, def_h;\n\n} GF_BTParser;\n\nGF_Err gf_bt_parse_bifs_command(GF_BTParser *parser, char *name, GF_List *cmdList);\nGF_Route *gf_bt_parse_route(GF_BTParser *parser, Bool skip_def, Bool is_insert, GF_Command *com);\nvoid gf_bt_resolve_routes(GF_BTParser *parser, Bool clean);\n\nGF_Node *gf_bt_peek_node(GF_BTParser *parser, char *defID);\n\nstatic GF_Err gf_bt_report(GF_BTParser *parser, GF_Err e, char *format, ...)\n{\n#ifndef GPAC_DISABLE_LOG\n\tif (format && gf_log_tool_level_on(GF_LOG_PARSER, e ? GF_LOG_ERROR : GF_LOG_WARNING)) {\n\t\tchar szMsg[2048];\n\t\tva_list args;\n\t\tva_start(args, format);\n\t\tvsnprintf(szMsg, 2048, format, args);\n\t\tva_end(args);\n\t\tGF_LOG((u32) (e ? GF_LOG_ERROR : GF_LOG_WARNING), GF_LOG_PARSER, (\"[BT/WRL Parsing] %s (line %d)\\n\", szMsg, parser->line));\n\t}\n#endif\n\tif (e) parser->last_error = e;\n\treturn e;\n}\n\n\nvoid gf_bt_check_line(GF_BTParser *parser)\n{\n\twhile (1) {\n\t\tswitch (parser->line_buffer[parser->line_pos]) {\n\t\tcase ' ':\n\t\tcase '\\t':\n\t\tcase '\\n':\n\t\tcase '\\r':\n\t\t\tparser->line_pos++;\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (parser->line_buffer[parser->line_pos]=='#') {\n\t\tparser->line_size = parser->line_pos;\n\t}\n\telse if ((parser->line_buffer[parser->line_pos]=='/') && (parser->line_buffer[parser->line_pos+1]=='/') ) parser->line_size = parser->line_pos;\n\n\tif (parser->line_size == parser->line_pos) {\n\t\t/*string based input - done*/\n\t\tif (!parser->gz_in) {\n\t\t\tparser->done = 1;\n\t\t\treturn;\n\t\t}\n\nnext_line:\n\t\tparser->line_start_pos = (s32) gf_gztell(parser->gz_in);\n\t\tparser->line_buffer[0] = 0;\n\t\tif (parser->unicode_type) {\n\t\t\tu8 c1, c2;\n\t\t\tunsigned short wchar;\n\t\t\tunsigned short l[BT_LINE_SIZE];\n\t\t\tunsigned short *dst = l;\n\t\t\tBool is_ret = 0;\n\t\t\tu32 last_space_pos, last_space_pos_stream;\n\t\t\tu32 go = BT_LINE_SIZE - 1;\n\t\t\tlast_space_pos = last_space_pos_stream = 0;\n\t\t\twhile (go && !gf_gzeof(parser->gz_in) ) {\n\t\t\t\tc1 = gf_gzgetc(parser->gz_in);\n\t\t\t\tc2 = gf_gzgetc(parser->gz_in);\n\t\t\t\t/*Little-endian order*/\n\t\t\t\tif (parser->unicode_type==2) {\n\t\t\t\t\tif (c2) {\n\t\t\t\t\t\twchar = c2;\n\t\t\t\t\t\twchar <<=8;\n\t\t\t\t\t\twchar |= c1;\n\t\t\t\t\t}\n\t\t\t\t\telse wchar = c1;\n\t\t\t\t} else {\n\t\t\t\t\twchar = c1;\n\t\t\t\t\tif (c2) {\n\t\t\t\t\t\twchar <<= 8;\n\t\t\t\t\t\twchar |= c2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t*dst = wchar;\n\t\t\t\tif (wchar=='\\r') is_ret = 1;\n\t\t\t\telse if (wchar=='\\n') {\n\t\t\t\t\tdst++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (is_ret) {\n\t\t\t\t\tu32 fpos = (u32) gf_gztell(parser->gz_in);\n\t\t\t\t\tgf_gzseek(parser->gz_in, fpos-2, SEEK_SET);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (wchar==' ') {\n\t\t\t\t\t//last_space_pos_stream = (u32) gf_gztell(parser->gz_in);\n\t\t\t\t\tlast_space_pos = (u32) (dst - l);\n\t\t\t\t}\n\t\t\t\tdst++;\n\t\t\t\tgo--;\n\n\t\t\t}\n\t\t\t*dst = 0;\n\t\t\t/*long line, rewind stream to last space*/\n\t\t\tif (!go) {\n\t\t\t\tu32 rew_pos = (u32)  (gf_gztell(parser->gz_in) - 2*(dst - &l[last_space_pos]) );\n\t\t\t\tgf_gzseek(parser->gz_in, rew_pos, SEEK_SET);\n\t\t\t\tl[last_space_pos+1] = 0;\n\t\t\t}\n\t\t\t/*check eof*/\n\t\t\tif (l[0]==0xFFFF) {\n\t\t\t\tparser->done = 1;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t/*convert to mbc string*/\n\t\t\tdst = l;\n\t\t\tgf_utf8_wcstombs(parser->line_buffer, BT_LINE_SIZE, (const unsigned short **) &dst);\n\n\t\t\tif (!strlen(parser->line_buffer) && gf_gzeof(parser->gz_in)) {\n\t\t\t\tparser->done = 1;\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\tif ((gf_gzgets(parser->gz_in, parser->line_buffer, BT_LINE_SIZE) == NULL)\n\t\t\t        || (!strlen(parser->line_buffer) && gf_gzeof(parser->gz_in))) {\n\t\t\t\tparser->done = 1;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t/*watchout for long lines*/\n\t\t\tif (1 + strlen(parser->line_buffer) == BT_LINE_SIZE) {\n\t\t\t\tu32 rew, pos, go;\n\t\t\t\trew = 0;\n\t\t\t\tgo = 1;\n\t\t\t\twhile (go) {\n\t\t\t\t\tswitch (parser->line_buffer[strlen(parser->line_buffer)-1]) {\n\t\t\t\t\tcase ' ':\n\t\t\t\t\tcase ',':\n\t\t\t\t\tcase '[':\n\t\t\t\t\tcase ']':\n\t\t\t\t\t\tgo = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tparser->line_buffer[strlen(parser->line_buffer)-1] = 0;\n\t\t\t\t\t\trew++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpos = (u32) gf_gztell(parser->gz_in);\n\t\t\t\tgf_gzseek(parser->gz_in, pos-rew, SEEK_SET);\n\t\t\t}\n\t\t}\n\n\n\t\twhile (1) {\n\t\t\tchar c;\n\t\t\tu32 len = (u32) strlen(parser->line_buffer);\n\t\t\tif (!len) break;\n\t\t\tc = parser->line_buffer[len-1];\n\t\t\tif (!strchr(\"\\n\\r\\t\", c)) break;\n\t\t\tparser->line_buffer[len-1] = 0;\n\t\t}\n\n\n\t\tparser->line_size = (u32) strlen(parser->line_buffer);\n\t\tparser->line_pos = 0;\n\t\tparser->line++;\n\n\t\t{\n\t\t\tu32 pos = (u32) gf_gztell(parser->gz_in);\n\t\t\tif (pos>=parser->file_pos) {\n\t\t\t\tparser->file_pos = pos;\n\t\t\t\tif (parser->line>1) gf_set_progress(\"BT Parsing\", pos, parser->file_size);\n\t\t\t}\n\t\t}\n\n\t\twhile ((parser->line_buffer[parser->line_pos]==' ') || (parser->line_buffer[parser->line_pos]=='\\t'))\n\t\t\tparser->line_pos++;\n\t\tif ( (parser->line_buffer[parser->line_pos]=='#')\n\t\t        || ( (parser->line_buffer[parser->line_pos]=='/') && (parser->line_buffer[parser->line_pos+1]=='/')) ) {\n\n\t\t\tif (parser->line==1) {\n\t\t\t\tif (strstr(parser->line_buffer, \"VRML\")) {\n\t\t\t\t\tif (strstr(parser->line_buffer, \"VRML V2.0\")) parser->is_wrl = 1;\n\t\t\t\t\t/*although not std, many files use this*/\n\t\t\t\t\telse if (strstr(parser->line_buffer, \"VRML2.0\")) parser->is_wrl = 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\tgf_bt_report(parser, GF_NOT_SUPPORTED, \"%s: VRML Version Not Supported\", parser->line_buffer);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (strstr(parser->line_buffer, \"X3D\")) {\n\t\t\t\t\tif (strstr(parser->line_buffer, \"X3D V3.0\")) parser->is_wrl = 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\tgf_bt_report(parser, GF_NOT_SUPPORTED, \"%s: X3D Version Not Supported\", parser->line_buffer);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!strnicmp(parser->line_buffer+parser->line_pos, \"#define \", 8) && !parser->block_comment) {\n\t\t\t\tchar *buf, *sep;\n\t\t\t\tparser->line_pos+=8;\n\t\t\t\tbuf = parser->line_buffer+parser->line_pos;\n\t\t\t\tsep = strchr(buf, ' ');\n\t\t\t\tif (sep && (sep[1]!='\\n') ) {\n\t\t\t\t\tBTDefSymbol *def;\n\t\t\t\t\tGF_SAFEALLOC(def, BTDefSymbol);\n\t\t\t\t\tif (!def) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"Fail to allocate DEF node\\n\"));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tsep[0] = 0;\n\t\t\t\t\tdef->name = gf_strdup(buf);\n\t\t\t\t\tsep[0] = ' ';\n\t\t\t\t\tbuf = sep+1;\n\t\t\t\t\twhile (strchr(\" \\t\", buf[0])) buf++;\n\t\t\t\t\tdef->value = gf_strdup(buf);\n\t\t\t\t\tgf_list_add(parser->def_symbols, def);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!strnicmp(parser->line_buffer+parser->line_pos, \"#if \", 4)) {\n\t\t\t\tu32 len = 0;\n\t\t\t\tparser->line_pos+=4;\n\t\t\t\twhile (1) {\n\t\t\t\t\tif (parser->line_pos+(s32)len==parser->line_size) break;\n\t\t\t\t\tif (strchr(\" \\n\\t\", parser->line_buffer[parser->line_pos+len]))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tlen++;\n\t\t\t\t}\n\t\t\t\tif (len) {\n\t\t\t\t\tif (len==1) {\n\t\t\t\t\t\tif (!strnicmp(parser->line_buffer+parser->line_pos, \"0\", 1)) {\n\t\t\t\t\t\t\tparser->block_comment++;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tu32 i, count;\n\t\t\t\t\t\tchar *keyWord = NULL;\n\t\t\t\t\t\tcount = gf_list_count(parser->def_symbols);\n\t\t\t\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\t\t\t\tBTDefSymbol *def = (BTDefSymbol *)gf_list_get(parser->def_symbols, i);\n\t\t\t\t\t\t\tif (!strnicmp(parser->line_buffer+parser->line_pos, def->name, len)) {\n\t\t\t\t\t\t\t\tkeyWord = def->value;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (keyWord && !strcmp(keyWord, \"0\")) {\n\t\t\t\t\t\t\tparser->block_comment++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!strnicmp(parser->line_buffer+parser->line_pos, \"#endif\", 6)) {\n\t\t\t\tif (parser->block_comment) parser->block_comment--;\n\t\t\t}\n\t\t\telse if (!strnicmp(parser->line_buffer+parser->line_pos, \"#else\", 5)) {\n\t\t\t\tif (parser->block_comment)\n\t\t\t\t\tparser->block_comment--;\n\t\t\t\telse\n\t\t\t\t\tparser->block_comment++;\n\t\t\t}\n\t\t\telse if (!strnicmp(parser->line_buffer+parser->line_pos, \"#size\", 5)) {\n\t\t\t\tchar *buf;\n\t\t\t\tparser->line_pos+=6;\n\t\t\t\tbuf = parser->line_buffer+parser->line_pos;\n\t\t\t\twhile (strchr(\" \\t\", buf[0]))\n\t\t\t\t\tbuf++;\n\t\t\t\tsscanf(buf, \"%dx%d\", &parser->def_w, &parser->def_h);\n\t\t\t}\n\t\t\tgoto next_line;\n\t\t}\n\n\t\tif (parser->block_comment)\n\t\t\tgoto next_line;\n\n\t\t/*brute-force replacement of defined symbols (!!FIXME - no mem checking done !!)*/\n\t\tif (parser->line_pos < parser->line_size) {\n\t\t\tu32 i, count;\n\t\t\tcount = gf_list_count(parser->def_symbols);\n\t\t\twhile (1) {\n\t\t\t\tBool found = 0;\n\t\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\t\tu32 symb_len, val_len, copy_len;\n\t\t\t\t\tBTDefSymbol *def = (BTDefSymbol *)gf_list_get(parser->def_symbols, i);\n\t\t\t\t\tchar *start = strstr(parser->line_buffer, def->name);\n\t\t\t\t\tif (!start) continue;\n\t\t\t\t\tsymb_len = (u32) strlen(def->name);\n\t\t\t\t\tif (!strchr(\" \\n\\r\\t,[]{}\\'\\\"\", start[symb_len])) continue;\n\t\t\t\t\tval_len = (u32) strlen(def->value);\n\t\t\t\t\tcopy_len = (u32) strlen(start + symb_len) + 1;\n\t\t\t\t\tmemmove(start + val_len, start + symb_len, sizeof(char)*copy_len);\n\t\t\t\t\tmemcpy(start, def->value, sizeof(char)*val_len);\n\t\t\t\t\tparser->line_size = (u32) strlen(parser->line_buffer);\n\t\t\t\t\tfound = 1;\n\t\t\t\t}\n\t\t\t\tif (!found) break;\n\t\t\t}\n\t\t}\n\t}\n\tif (!parser->line_size) {\n\t\tif (!gf_gzeof(parser->gz_in)) gf_bt_check_line(parser);\n\t\telse parser->done = 1;\n\t}\n\telse if (!parser->done && (parser->line_size == parser->line_pos)) gf_bt_check_line(parser);\n}\n\nvoid gf_bt_force_line(GF_BTParser *parser)\n{\n\tparser->line_pos = parser->line_size;\n}\n\nBool gf_bt_check_code(GF_BTParser *parser, char code)\n{\n\tgf_bt_check_line(parser);\n\tif (parser->line_buffer[parser->line_pos]==code) {\n\t\tparser->line_pos++;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nchar *gf_bt_get_next(GF_BTParser *parser, Bool point_break)\n{\n\tu32 has_quote;\n\tBool go = 1;\n\ts32 i;\n\tgf_bt_check_line(parser);\n\ti=0;\n\thas_quote = 0;\n\twhile (go) {\n\t\tif (parser->line_buffer[parser->line_pos + i] == '\\\"') {\n\t\t\tif (!has_quote) has_quote = 1;\n\t\t\telse has_quote = 0;\n\t\t\tparser->line_pos += 1;\n\n\t\t\tif (parser->line_pos+i==parser->line_size) break;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!has_quote) {\n\t\t\tswitch (parser->line_buffer[parser->line_pos + i]) {\n\t\t\tcase 0:\n\t\t\tcase ' ':\n\t\t\tcase '\\t':\n\t\t\tcase '\\r':\n\t\t\tcase '\\n':\n\t\t\tcase '{':\n\t\t\tcase '}':\n\t\t\tcase ']':\n\t\t\tcase '[':\n\t\t\tcase ',':\n\t\t\t\tgo = 0;\n\t\t\t\tbreak;\n\t\t\tcase '.':\n\t\t\t\tif (point_break) go = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!go) break;\n\t\t}\n\t\tparser->cur_buffer[i] = parser->line_buffer[parser->line_pos + i];\n\t\ti++;\n\t\tif (parser->line_pos+i==parser->line_size) break;\n\t}\n\tparser->cur_buffer[i] = 0;\n\tparser->line_pos += i;\n\treturn parser->cur_buffer;\n}\n\nchar *gf_bt_get_string(GF_BTParser *parser, u8 string_delim)\n{\n\tchar *res;\n\ts32 i, size;\n\n#define\tBT_STR_CHECK_ALLOC\t\\\n\t\tif (i==size) {\t\t\\\n\t\t\tres = (char*)gf_realloc(res, sizeof(char) * (size+500+1));\t\\\n\t\t\tsize += 500;\t\\\n\t\t}\t\\\n\n\tres = (char*)gf_malloc(sizeof(char) * 500);\n\tsize = 500;\n\twhile (parser->line_buffer[parser->line_pos]==' ') parser->line_pos++;\n\n\tif (parser->line_pos==parser->line_size) {\n\t\tif (gf_gzeof(parser->gz_in)) return NULL;\n\t\tgf_bt_check_line(parser);\n\t}\n\tif (!string_delim) string_delim = '\"';\n\n\ti=0;\n\twhile (1) {\n\t\tif (parser->line_buffer[parser->line_pos] == string_delim)\n\t\t\tif ( !parser->line_pos || (parser->line_buffer[parser->line_pos-1] != '\\\\') ) break;\n\n\t\tBT_STR_CHECK_ALLOC\n\n\t\tif ((parser->line_buffer[parser->line_pos]=='/') && (parser->line_buffer[parser->line_pos+1]=='/') && (parser->line_buffer[parser->line_pos-1]!=':') ) {\n\t\t\t/*this looks like a comment*/\n\t\t\tif (!strchr(&parser->line_buffer[parser->line_pos], string_delim)) {\n\t\t\t\tgf_bt_check_line(parser);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif ((parser->line_buffer[parser->line_pos] != '\\\\') || (parser->line_buffer[parser->line_pos+1] != string_delim)) {\n\t\t\t/*handle UTF-8 - WARNING: if parser is in unicode string is already utf8 multibyte chars*/\n\t\t\tif (!parser->unicode_type && parser->line_buffer[parser->line_pos] & 0x80) {\n\t\t\t\tchar c = parser->line_buffer[parser->line_pos];\n\t\t\t\t/*non UTF8 (likely some win-CP)*/\n\t\t\t\tif ( (parser->line_buffer[parser->line_pos+1] & 0xc0) != 0x80) {\n\t\t\t\t\tres[i] = 0xc0 | ( (parser->line_buffer[parser->line_pos] >> 6) & 0x3 );\n\t\t\t\t\ti++;\n\t\t\t\t\tBT_STR_CHECK_ALLOC\n\t\t\t\t\tparser->line_buffer[parser->line_pos] &= 0xbf;\n\t\t\t\t}\n\t\t\t\t/*UTF8 2 bytes char*/\n\t\t\t\telse if ( (c & 0xe0) == 0xc0) {\n\t\t\t\t\tres[i] = parser->line_buffer[parser->line_pos];\n\t\t\t\t\tparser->line_pos++;\n\t\t\t\t\ti++;\n\t\t\t\t\tBT_STR_CHECK_ALLOC\n\t\t\t\t}\n\t\t\t\t/*UTF8 3 bytes char*/\n\t\t\t\telse if ( (c & 0xf0) == 0xe0) {\n\t\t\t\t\tres[i] = parser->line_buffer[parser->line_pos];\n\t\t\t\t\tparser->line_pos++;\n\t\t\t\t\ti++;\n\t\t\t\t\tBT_STR_CHECK_ALLOC\n\t\t\t\t\tres[i] = parser->line_buffer[parser->line_pos];\n\t\t\t\t\tparser->line_pos++;\n\t\t\t\t\ti++;\n\t\t\t\t\tBT_STR_CHECK_ALLOC\n\t\t\t\t}\n\t\t\t\t/*UTF8 4 bytes char*/\n\t\t\t\telse if ( (c & 0xf8) == 0xf0) {\n\t\t\t\t\tres[i] = parser->line_buffer[parser->line_pos];\n\t\t\t\t\tparser->line_pos++;\n\t\t\t\t\ti++;\n\t\t\t\t\tBT_STR_CHECK_ALLOC\n\t\t\t\t\tres[i] = parser->line_buffer[parser->line_pos];\n\t\t\t\t\tparser->line_pos++;\n\t\t\t\t\ti++;\n\t\t\t\t\tBT_STR_CHECK_ALLOC\n\t\t\t\t\tres[i] = parser->line_buffer[parser->line_pos];\n\t\t\t\t\tparser->line_pos++;\n\t\t\t\t\ti++;\n\t\t\t\t\tBT_STR_CHECK_ALLOC\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tres[i] = parser->line_buffer[parser->line_pos];\n\t\t\ti++;\n\t\t}\n\t\tparser->line_pos++;\n\t\tif (parser->line_pos==parser->line_size) {\n\t\t\tgf_bt_check_line(parser);\n\t\t}\n\n\t}\n\n#undef\tBT_STR_CHECK_ALLOC\n\n\tres[i] = 0;\n\tparser->line_pos += 1;\n\treturn res;\n}\n\nBool gf_bt_check_externproto_field(GF_BTParser *parser, char *str)\n{\n\tif (!parser->is_extern_proto_field) return 0;\n\tif (!strcmp(str, \"\") || !strcmp(str, \"field\") || !strcmp(str, \"eventIn\") || !strcmp(str, \"eventOut\") || !strcmp(str, \"exposedField\")) {\n\t\tparser->last_error = GF_EOS;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic Bool check_keyword(GF_BTParser *parser, char *str, s32 *val)\n{\n\ts32 res;\n\tchar *sep;\n\tsep = strchr(str, '$');\n\tif (!sep) return 0;\n\tsep++;\n\tif (!strcmp(sep, \"F1\")) res = GF_KEY_F1;\n\telse if (!strcmp(sep, \"F2\")) res = GF_KEY_F2;\n\telse if (!strcmp(sep, \"F3\")) res = GF_KEY_F3;\n\telse if (!strcmp(sep, \"F4\")) res = GF_KEY_F4;\n\telse if (!strcmp(sep, \"F5\")) res = GF_KEY_F5;\n\telse if (!strcmp(sep, \"F6\")) res = GF_KEY_F6;\n\telse if (!strcmp(sep, \"F7\")) res = GF_KEY_F7;\n\telse if (!strcmp(sep, \"F8\")) res = GF_KEY_F8;\n\telse if (!strcmp(sep, \"F9\")) res = GF_KEY_F9;\n\telse if (!strcmp(sep, \"F10\")) res = GF_KEY_F10;\n\telse if (!strcmp(sep, \"F11\")) res = GF_KEY_F11;\n\telse if (!strcmp(sep, \"F12\")) res = GF_KEY_F12;\n\telse if (!strcmp(sep, \"HOME\")) res = GF_KEY_HOME;\n\telse if (!strcmp(sep, \"END\")) res = GF_KEY_END;\n\telse if (!strcmp(sep, \"PREV\")) res = GF_KEY_PAGEUP;\n\telse if (!strcmp(sep, \"NEXT\")) res = GF_KEY_PAGEDOWN;\n\telse if (!strcmp(sep, \"UP\")) res = GF_KEY_UP;\n\telse if (!strcmp(sep, \"DOWN\")) res = GF_KEY_DOWN;\n\telse if (!strcmp(sep, \"LEFT\")) res = GF_KEY_LEFT;\n\telse if (!strcmp(sep, \"RIGHT\")) res = GF_KEY_RIGHT;\n\telse if (!strcmp(sep, \"RETURN\")) res = GF_KEY_ENTER;\n\telse if (!strcmp(sep, \"BACK\")) res = GF_KEY_BACKSPACE;\n\telse if (!strcmp(sep, \"TAB\")) res = GF_KEY_TAB;\n\telse if (strlen(sep)==1) {\n\t\tchar c;\n\t\tsscanf(sep, \"%c\", &c);\n\t\tres = c;\n\t} else {\n\t\tgf_bt_report(parser, GF_OK, \"unrecognized keyword %s - skipping\", str);\n\t\tres = 0;\n\t}\n\tif (strchr(str, '-')) *val = -res;\n\telse *val = res;\n\treturn 1;\n}\n\nGF_Err gf_bt_parse_float(GF_BTParser *parser, const char *name, Fixed *val)\n{\n\ts32 var;\n\tFloat f;\n\tchar *str = gf_bt_get_next(parser, 0);\n\tif (!str) return parser->last_error = GF_IO_ERR;\n\tif (gf_bt_check_externproto_field(parser, str)) return GF_OK;\n\n\tif (check_keyword(parser, str, &var)) {\n\t\t*val = INT2FIX(var);\n\t\treturn GF_OK;\n\t}\n\tif (sscanf(str, \"%g\", &f) != 1) {\n\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"%s: Number expected\", name);\n\t}\n\t*val = FLT2FIX(f);\n\treturn GF_OK;\n}\nGF_Err gf_bt_parse_double(GF_BTParser *parser, const char *name, SFDouble *val)\n{\n\tchar *str = gf_bt_get_next(parser, 0);\n\tif (!str) return parser->last_error = GF_IO_ERR;\n\tif (gf_bt_check_externproto_field(parser, str)) return GF_OK;\n\tif (sscanf(str, \"%lf\", val) != 1) {\n\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"%s: Number expected\", name);\n\t}\n\treturn GF_OK;\n}\nGF_Err gf_bt_parse_int(GF_BTParser *parser, const char *name, SFInt32 *val)\n{\n\tchar *str = gf_bt_get_next(parser, 0);\n\tif (!str) return parser->last_error = GF_IO_ERR;\n\tif (gf_bt_check_externproto_field(parser, str)) return GF_OK;\n\n\tif (check_keyword(parser, str, val)) return GF_OK;\n\t/*URL ODID*/\n\tif (!strnicmp(str, \"od:\", 3)) str += 3;\n\tif (sscanf(str, \"%d\", val) != 1) {\n\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"%s: Number expected\", name);\n\t}\n\treturn GF_OK;\n}\nGF_Err gf_bt_parse_bool(GF_BTParser *parser, const char *name, SFBool *val)\n{\n\tchar *str = gf_bt_get_next(parser, 0);\n\tif (!str) return parser->last_error = GF_IO_ERR;\n\tif (gf_bt_check_externproto_field(parser, str)) return GF_OK;\n\n\tif (!stricmp(str, \"true\") || !strcmp(str, \"1\") ) {\n\t\t*val = 1;\n\t}\n\telse if (!stricmp(str, \"false\") || !strcmp(str, \"0\") ) {\n\t\t*val = 0;\n\t} else {\n\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"%s: Boolean expected\", name);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err gf_bt_parse_color(GF_BTParser *parser, const char *name, SFColor *col)\n{\n\tFloat f;\n\tu32 val;\n\tchar *str = gf_bt_get_next(parser, 0);\n\tif (!str) return parser->last_error = GF_IO_ERR;\n\tif (gf_bt_check_externproto_field(parser, str)) return GF_OK;\n\n\tif (sscanf(str, \"%f\", &f) == 1) {\n\t\tcol->red = FLT2FIX(f);\n\t\t/*many VRML files use ',' separator*/\n\t\tgf_bt_check_code(parser, ',');\n\t\tgf_bt_parse_float(parser, name, & col->green);\n\t\tgf_bt_check_code(parser, ',');\n\t\tgf_bt_parse_float(parser, name, & col->blue);\n\t\treturn parser->last_error;\n\t}\n\tval = gf_color_parse(str);\n\tif (!val) {\n\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"%s: Number or name expected\", name);\n\t}\n\tcol->red = INT2FIX((val>>16) & 0xFF) / 255;\n\tcol->green = INT2FIX((val>>8) & 0xFF) / 255;\n\tcol->blue = INT2FIX(val & 0xFF) / 255;\n\treturn parser->last_error;\n}\n\nGF_Err gf_bt_parse_colorRGBA(GF_BTParser *parser, const char *name, SFColorRGBA *col)\n{\n\tFloat f;\n\tchar *str = gf_bt_get_next(parser, 0);\n\tif (!str) return parser->last_error = GF_IO_ERR;\n\tif (gf_bt_check_externproto_field(parser, str)) return GF_OK;\n\n\t/*HTML code*/\n\tif (str[0]=='$') {\n\t\tu32 val;\n\t\tsscanf(str, \"%x\", &val);\n\t\tcol->red = INT2FIX((val>>24) & 0xFF) / 255;\n\t\tcol->green = INT2FIX((val>>16) & 0xFF) / 255;\n\t\tcol->blue = INT2FIX((val>>8) & 0xFF) / 255;\n\t\tcol->alpha = INT2FIX(val & 0xFF) / 255;\n\t\treturn parser->last_error;\n\t}\n\tif (sscanf(str, \"%f\", &f) != 1) {\n\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"%s: Number expected\", name);\n\t}\n\tcol->red = FLT2FIX(f);\n\tgf_bt_check_code(parser, ',');\n\tgf_bt_parse_float(parser, name, & col->green);\n\tgf_bt_check_code(parser, ',');\n\tgf_bt_parse_float(parser, name, & col->blue);\n\tgf_bt_check_code(parser, ',');\n\tgf_bt_parse_float(parser, name, & col->alpha);\n\treturn parser->last_error;\n}\n\nstatic void gf_bt_offset_time(GF_BTParser *parser, Double *time)\n{\n\tif (!parser->is_wrl) {\n\t\tDouble res;\n\t\tres = parser->au_time;\n\t\tres /= parser->bifs_es->timeScale;\n\t\t*time += res;\n\t}\n}\n\nstatic void gf_bt_check_time_offset(GF_BTParser *parser, GF_Node *n, GF_FieldInfo *info)\n{\n\tif (!n || !(parser->load->flags & GF_SM_LOAD_FOR_PLAYBACK)) return;\n\tif (gf_node_get_tag(n) != TAG_ProtoNode) {\n\t\tif (!stricmp(info->name, \"startTime\") || !stricmp(info->name, \"stopTime\"))\n\t\t\tgf_bt_offset_time(parser, (Double *)info->far_ptr);\n\t} else if (gf_sg_proto_field_is_sftime_offset(n, info)) {\n\t\tgf_bt_offset_time(parser, (Double *)info->far_ptr);\n\t}\n}\nstatic void gf_bt_update_timenode(GF_BTParser *parser, GF_Node *node)\n{\n\tif (!node || !(parser->load->flags & GF_SM_LOAD_FOR_PLAYBACK)) return;\n\n\tswitch (gf_node_get_tag(node)) {\n\tcase TAG_MPEG4_AnimationStream:\n\t\tgf_bt_offset_time(parser, & ((M_AnimationStream*)node)->startTime);\n\t\tgf_bt_offset_time(parser, & ((M_AnimationStream*)node)->stopTime);\n\t\tbreak;\n\tcase TAG_MPEG4_AudioBuffer:\n\t\tgf_bt_offset_time(parser, & ((M_AudioBuffer*)node)->startTime);\n\t\tgf_bt_offset_time(parser, & ((M_AudioBuffer*)node)->stopTime);\n\t\tbreak;\n\tcase TAG_MPEG4_AudioClip:\n\t\tgf_bt_offset_time(parser, & ((M_AudioClip*)node)->startTime);\n\t\tgf_bt_offset_time(parser, & ((M_AudioClip*)node)->stopTime);\n\t\tbreak;\n\tcase TAG_MPEG4_AudioSource:\n\t\tgf_bt_offset_time(parser, & ((M_AudioSource*)node)->startTime);\n\t\tgf_bt_offset_time(parser, & ((M_AudioSource*)node)->stopTime);\n\t\tbreak;\n\tcase TAG_MPEG4_MovieTexture:\n\t\tgf_bt_offset_time(parser, & ((M_MovieTexture*)node)->startTime);\n\t\tgf_bt_offset_time(parser, & ((M_MovieTexture*)node)->stopTime);\n\t\tbreak;\n\tcase TAG_MPEG4_TimeSensor:\n\t\tgf_bt_offset_time(parser, & ((M_TimeSensor*)node)->startTime);\n\t\tgf_bt_offset_time(parser, & ((M_TimeSensor*)node)->stopTime);\n\t\tbreak;\n\tcase TAG_ProtoNode:\n\t{\n\t\tu32 i, nbFields;\n\t\tGF_FieldInfo inf;\n\t\tnbFields = gf_node_get_num_fields_in_mode(node, GF_SG_FIELD_CODING_ALL);\n\t\tfor (i=0; i<nbFields; i++) {\n\t\t\tgf_node_get_field(node, i, &inf);\n\t\t\tif (inf.fieldType != GF_SG_VRML_SFTIME) continue;\n\t\t\tgf_bt_check_time_offset(parser, node, &inf);\n\t\t}\n\t}\n\tbreak;\n\t}\n}\n\n\nvoid gf_bt_sffield(GF_BTParser *parser, GF_FieldInfo *info, GF_Node *n)\n{\n\tswitch (info->fieldType) {\n\tcase GF_SG_VRML_SFINT32:\n\t\tgf_bt_parse_int(parser, info->name, (SFInt32 *)info->far_ptr);\n\t\tif (parser->last_error) return;\n\t\tbreak;\n\tcase GF_SG_VRML_SFBOOL:\n\t\tgf_bt_parse_bool(parser, info->name, (SFBool *)info->far_ptr);\n\t\tif (parser->last_error) return;\n\t\tbreak;\n\tcase GF_SG_VRML_SFFLOAT:\n\t\tgf_bt_parse_float(parser, info->name, (SFFloat *)info->far_ptr);\n\t\tif (parser->last_error) return;\n\t\tbreak;\n\tcase GF_SG_VRML_SFDOUBLE:\n\t\tgf_bt_parse_double(parser, info->name, (SFDouble *)info->far_ptr);\n\t\tif (parser->last_error) return;\n\t\tbreak;\n\tcase GF_SG_VRML_SFTIME:\n\t\tgf_bt_parse_double(parser, info->name, (SFDouble *)info->far_ptr);\n\t\tif (parser->last_error) return;\n\t\tgf_bt_check_time_offset(parser, n, info);\n\t\tbreak;\n\tcase GF_SG_VRML_SFCOLOR:\n\t\tgf_bt_parse_color(parser, info->name, (SFColor *)info->far_ptr);\n\t\tbreak;\n\tcase GF_SG_VRML_SFCOLORRGBA:\n\t\tgf_bt_parse_colorRGBA(parser, info->name, (SFColorRGBA *)info->far_ptr);\n\t\tbreak;\n\tcase GF_SG_VRML_SFVEC2F:\n\t\tgf_bt_parse_float(parser, info->name, & ((SFVec2f *)info->far_ptr)->x);\n\t\tif (parser->last_error) return;\n\t\t/*many VRML files use ',' separator*/\n\t\tgf_bt_check_code(parser, ',');\n\t\tgf_bt_parse_float(parser, info->name, & ((SFVec2f *)info->far_ptr)->y);\n\t\tif (parser->last_error) return;\n\t\tbreak;\n\tcase GF_SG_VRML_SFVEC2D:\n\t\tgf_bt_parse_double(parser, info->name, & ((SFVec2d *)info->far_ptr)->x);\n\t\tif (parser->last_error) return;\n\t\t/*many VRML files use ',' separator*/\n\t\tgf_bt_check_code(parser, ',');\n\t\tgf_bt_parse_double(parser, info->name, & ((SFVec2d *)info->far_ptr)->y);\n\t\tif (parser->last_error) return;\n\t\tbreak;\n\tcase GF_SG_VRML_SFVEC3F:\n\t\tgf_bt_parse_float(parser, info->name, & ((SFVec3f *)info->far_ptr)->x);\n\t\tif (parser->last_error) return;\n\t\t/*many VRML files use ',' separator*/\n\t\tgf_bt_check_code(parser, ',');\n\t\tgf_bt_parse_float(parser, info->name, & ((SFVec3f *)info->far_ptr)->y);\n\t\tif (parser->last_error) return;\n\t\t/*many VRML files use ',' separator*/\n\t\tgf_bt_check_code(parser, ',');\n\t\tgf_bt_parse_float(parser, info->name, & ((SFVec3f *)info->far_ptr)->z);\n\t\tif (parser->last_error) return;\n\t\tbreak;\n\tcase GF_SG_VRML_SFVEC3D:\n\t\tgf_bt_parse_double(parser, info->name, & ((SFVec3d *)info->far_ptr)->x);\n\t\tif (parser->last_error) return;\n\t\t/*many VRML files use ',' separator*/\n\t\tgf_bt_check_code(parser, ',');\n\t\tgf_bt_parse_double(parser, info->name, & ((SFVec3d *)info->far_ptr)->y);\n\t\tif (parser->last_error) return;\n\t\t/*many VRML files use ',' separator*/\n\t\tgf_bt_check_code(parser, ',');\n\t\tgf_bt_parse_double(parser, info->name, & ((SFVec3d *)info->far_ptr)->z);\n\t\tif (parser->last_error) return;\n\t\tbreak;\n\tcase GF_SG_VRML_SFVEC4F:\n\t\tgf_bt_parse_float(parser, info->name, & ((SFVec4f *)info->far_ptr)->x);\n\t\tif (parser->last_error) return;\n\t\t/*many VRML files use ',' separator*/\n\t\tgf_bt_check_code(parser, ',');\n\t\tgf_bt_parse_float(parser, info->name, & ((SFVec4f *)info->far_ptr)->y);\n\t\tif (parser->last_error) return;\n\t\t/*many VRML files use ',' separator*/\n\t\tgf_bt_check_code(parser, ',');\n\t\tgf_bt_parse_float(parser, info->name, & ((SFVec4f *)info->far_ptr)->z);\n\t\tif (parser->last_error) return;\n\t\t/*many VRML files use ',' separator*/\n\t\tgf_bt_check_code(parser, ',');\n\t\tgf_bt_parse_float(parser, info->name, & ((SFVec4f *)info->far_ptr)->q);\n\t\tif (parser->last_error) return;\n\t\tbreak;\n\tcase GF_SG_VRML_SFROTATION:\n\t\tgf_bt_parse_float(parser, info->name, & ((SFRotation *)info->far_ptr)->x);\n\t\tif (parser->last_error) return;\n\t\tgf_bt_parse_float(parser, info->name, & ((SFRotation *)info->far_ptr)->y);\n\t\tif (parser->last_error) return;\n\t\tgf_bt_parse_float(parser, info->name, & ((SFRotation *)info->far_ptr)->z);\n\t\tif (parser->last_error) return;\n\t\tgf_bt_parse_float(parser, info->name, & ((SFRotation *)info->far_ptr)->q);\n\t\tif (parser->last_error) return;\n\t\tbreak;\n\tcase GF_SG_VRML_SFSTRING:\n\t{\n\t\tu8 delim = 0;\n\t\tif (gf_bt_check_code(parser, '\\\"')) delim = '\\\"';\n\t\telse if (gf_bt_check_code(parser, '\\'')) delim = '\\'';\n\t\tif (delim) {\n\t\t\tchar *str = gf_bt_get_string(parser, delim);\n\t\t\tif (!str)\n\t\t\t\tgoto err;\n\t\t\tif (((SFString *)info->far_ptr)->buffer) gf_free(((SFString *)info->far_ptr)->buffer);\n\t\t\t((SFString *)info->far_ptr)->buffer = NULL;\n\t\t\tif (strlen(str))\n\t\t\t\t((SFString *)info->far_ptr)->buffer = str;\n\t\t\telse\n\t\t\t\tgf_free(str);\n\n\t\t\tif (n && (n->sgprivate->tag==TAG_MPEG4_BitWrapper)) {\n\t\t\t\tgf_sm_update_bitwrapper_buffer(n, parser->load->fileName);\n\t\t\t}\n\t\t} else {\n\t\t\tgoto err;\n\t\t}\n\t}\n\tbreak;\n\tcase GF_SG_VRML_SFURL:\n\t{\n\t\tu8 delim = 0;\n\t\tif (gf_bt_check_code(parser, '\\\"')) delim = '\\\"';\n\t\telse if (gf_bt_check_code(parser, '\\'')) delim = '\\'';\n\t\tif (delim) {\n\t\t\tSFURL *url = (SFURL *)info->far_ptr;\n\t\t\tchar *str = gf_bt_get_string(parser, delim);\n\t\t\tif (!str) goto err;\n\t\t\tif (url->url) gf_free(url->url);\n\t\t\turl->url = NULL;\n\t\t\turl->OD_ID = 0;\n\t\t\tif (strchr(str, '#')) {\n\t\t\t\turl->url = str;\n\t\t\t} else {\n\t\t\t\tu32 id = 0;\n\t\t\t\tchar *odstr = str;\n\t\t\t\tif (!strnicmp(str, \"od://\", 5)) odstr += 5;\n\t\t\t\telse if (!strnicmp(str, \"od:\", 3)) odstr += 3;\n\t\t\t\t/*be careful, an url like \"11-regression-test.mp4\" will return 1 on sscanf :)*/\n\t\t\t\tif (sscanf(odstr, \"%u\", &id) == 1) {\n\t\t\t\t\tchar szURL[20];\n\t\t\t\t\tsprintf(szURL, \"%u\", id);\n\t\t\t\t\tif (strcmp(szURL, odstr)) id=0;\n\t\t\t\t}\n\t\t\t\tif (id) {\n\t\t\t\t\turl->OD_ID = id;\n\t\t\t\t\tgf_free(str);\n\t\t\t\t} else {\n\t\t\t\t\turl->url = str;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\ts32 val;\n\t\t\tgf_bt_parse_int(parser, info->name, & val );\n\t\t\tif (parser->last_error) return;\n\t\t\t((SFURL *)info->far_ptr)->OD_ID = val;\n\t\t}\n\t}\n\tbreak;\n\tcase GF_SG_VRML_SFCOMMANDBUFFER:\n\t{\n\t\tSFCommandBuffer *cb = (SFCommandBuffer *)info->far_ptr;\n\t\tif (gf_bt_check_code(parser, '{')) {\n\t\t\tGF_Command *prev_com = parser->cur_com;\n\t\t\twhile (!parser->last_error) {\n\t\t\t\tif (gf_bt_check_code(parser, '}')) break;\n\t\t\t\tparser->last_error = gf_bt_parse_bifs_command(parser, NULL, cb->commandList);\n\t\t\t}\n\t\t\tparser->cur_com = prev_com;\n\t\t}\n\t}\n\tbreak;\n\tcase GF_SG_VRML_SFIMAGE:\n\t{\n\t\tu32 i, size, v;\n\t\tSFImage *img = (SFImage *)info->far_ptr;\n\t\tgf_bt_parse_int(parser, \"width\", (SFInt32 *)&img->width);\n\t\tif (parser->last_error) return;\n\t\tgf_bt_parse_int(parser, \"height\", (SFInt32 *)&img->height);\n\t\tif (parser->last_error) return;\n\t\tgf_bt_parse_int(parser, \"nbComp\", (SFInt32 *)&v);\n\t\tif (parser->last_error) return;\n\t\timg->numComponents = v;\n\t\tsize = img->width * img->height * img->numComponents;\n\t\tif (img->pixels) gf_free(img->pixels);\n\t\timg->pixels = (unsigned char*)gf_malloc(sizeof(char) * size);\n\t\tfor (i=0; i<size; i++) {\n\t\t\tchar *str = gf_bt_get_next(parser, 0);\n\t\t\tif (strstr(str, \"0x\")) sscanf(str, \"%x\", &v);\n\t\t\telse sscanf(str, \"%u\", &v);\n\t\t\tswitch (img->numComponents) {\n\t\t\tcase 1:\n\t\t\t\timg->pixels[i] = (char) v;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\timg->pixels[i] = (char) (v>>8)&0xFF;\n\t\t\t\timg->pixels[i+1] = (char) (v)&0xFF;\n\t\t\t\ti++;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\timg->pixels[i] = (char) (v>>16)&0xFF;\n\t\t\t\timg->pixels[i+1] = (char) (v>>8)&0xFF;\n\t\t\t\timg->pixels[i+2] = (char) (v)&0xFF;\n\t\t\t\ti+=2;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\timg->pixels[i] = (char) (v>>24)&0xFF;\n\t\t\t\timg->pixels[i+1] = (char) (v>>16)&0xFF;\n\t\t\t\timg->pixels[i+2] = (char) (v>>8)&0xFF;\n\t\t\t\timg->pixels[i+3] = (char) (v)&0xFF;\n\t\t\t\ti+=3;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tbreak;\n\tcase GF_SG_VRML_SFSCRIPT:\n\t{\n\t\tSFScript *sc = (SFScript *) info->far_ptr;\n\t\tif (!gf_bt_check_code(parser, '\\\"')) {\n\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"\\\" expected in Script\");\n\t\t}\n\t\tsc->script_text = (char*)gf_bt_get_string(parser, '\\\"');\n\t}\n\tbreak;\n\tcase GF_SG_VRML_SFATTRREF:\n\t{\n\t\tSFAttrRef *ar = (SFAttrRef*) info->far_ptr;\n\t\tchar *str = gf_bt_get_next(parser, 1);\n\t\tif (!gf_bt_check_code(parser, '.')) {\n\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"'.' expected in SFAttrRef\");\n\t\t} else {\n\t\t\tGF_FieldInfo pinfo;\n\t\t\tar->node = gf_bt_peek_node(parser, str);\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tif (gf_node_get_field_by_name(ar->node, str, &pinfo) != GF_OK) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"field %s is not a member of node %s\", str, gf_node_get_class_name(ar->node) );\n\t\t\t} else {\n\t\t\t\tar->fieldIndex = pinfo.fieldIndex;\n\t\t\t}\n\t\t}\n\n\t}\n\tbreak;\n\tdefault:\n\t\tparser->last_error = GF_NOT_SUPPORTED;\n\t\tbreak;\n\n\t}\n\tgf_bt_check_code(parser, ',');\n\treturn;\nerr:\n\tgf_bt_report(parser, GF_BAD_PARAM, \"%s: Invalid field syntax\", info->name);\n}\n\nvoid gf_bt_mffield(GF_BTParser *parser, GF_FieldInfo *info, GF_Node *n)\n{\n\tGF_FieldInfo sfInfo;\n\tBool force_single = 0;\n\n\tif (!gf_bt_check_code(parser, '[')) {\n\t\tif (parser->is_extern_proto_field) return;\n\t\tforce_single = 1;\n\t}\n\n\tsfInfo.fieldType = gf_sg_vrml_get_sf_type(info->fieldType);\n\tsfInfo.name = info->name;\n\tgf_sg_vrml_mf_reset(info->far_ptr, info->fieldType);\n\n\twhile (!gf_bt_check_code(parser, ']')) {\n\t\tgf_sg_vrml_mf_append(info->far_ptr, info->fieldType, &sfInfo.far_ptr);\n\t\tgf_bt_sffield(parser, &sfInfo, n);\n\t\tif (parser->last_error) return;\n\n\t\tgf_bt_check_code(parser, ',');\n\t\tif (force_single) break;\n\t}\n}\n\nBool gf_bt_check_ndt(GF_BTParser *parser, GF_FieldInfo *info, GF_Node *node, GF_Node *parent)\n{\n\tif (!node) return 1;\n\tif (parent->sgprivate->tag == TAG_MPEG4_Script) return 1;\n#ifndef GPAC_DISABLE_X3D\n\tif (parent->sgprivate->tag == TAG_X3D_Script) return 1;\n#endif\n\tif (node->sgprivate->tag == TAG_UndefinedNode) return 1;\n\n\t/*this handles undefined nodes*/\n\tif (gf_node_in_table(node, info->NDTtype)) return 1;\n\t/*not found*/\n\tgf_bt_report(parser, GF_BAD_PARAM, \"node %s not valid in field %s\\n\", gf_node_get_class_name(node), info->name);\n\tgf_node_unregister(node, parent);\n\treturn 0;\n}\n\nu32 gf_bt_get_next_node_id(GF_BTParser *parser)\n{\n\tu32 ID;\n\tGF_SceneGraph *sc = parser->load->scene_graph;\n\tif (parser->parsing_proto) sc = gf_sg_proto_get_graph(parser->parsing_proto);\n\tID = gf_sg_get_next_available_node_id(sc);\n\tif (parser->load->ctx && (ID>parser->load->ctx->max_node_id))\n\t\tparser->load->ctx->max_node_id = ID;\n\treturn ID;\n}\nu32 gf_bt_get_next_route_id(GF_BTParser *parser)\n{\n\tu32 ID;\n\tGF_SceneGraph *sg = parser->load->scene_graph;\n\tif (parser->parsing_proto) sg = gf_sg_proto_get_graph(parser->parsing_proto);\n\n\tID = gf_sg_get_next_available_route_id(sg);\n\tif (parser->load->ctx && (ID>parser->load->ctx->max_route_id))\n\t\tparser->load->ctx->max_route_id = ID;\n\treturn ID;\n}\nu32 gf_bt_get_next_proto_id(GF_BTParser *parser)\n{\n\tu32 ID;\n\tGF_SceneGraph *sc = parser->load->scene_graph;\n\tif (parser->parsing_proto) sc = gf_sg_proto_get_graph(parser->parsing_proto);\n\tID = gf_sg_get_next_available_proto_id(sc);\n\tif (parser->load->ctx && (ID>parser->load->ctx->max_node_id))\n\t\tparser->load->ctx->max_proto_id = ID;\n\treturn ID;\n}\n\nu32 gf_bt_get_def_id(GF_BTParser *parser, char *defName)\n{\n\tGF_Node *n=NULL;\n\tu32 ID=0;\n\tif (sscanf(defName, \"N%u\", &ID) == 1) {\n\t\tu32 k=1;\n\t\twhile (defName[k]) {\n\t\t\tif (strchr(\"0123456789\", defName[k])==0) {\n\t\t\t\tID = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tk++;\n\t\t}\n\t\tif (ID) {\n\t\t\tID ++;\n\t\t\tn = gf_sg_find_node(parser->load->scene_graph, ID);\n\t\t\tif (!n) {\n\t\t\t\tif (parser->load->ctx && (parser->load->ctx->max_node_id<ID)) parser->load->ctx->max_node_id=ID;\n\t\t\t\treturn ID;\n\t\t\t}\n\t\t}\n\t}\n\n\tID = gf_bt_get_next_node_id(parser);\n\tif (n) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (\"[BT Parsing] (line %d) Binary ID %d already assigned to %s - keeping internal ID %d\", parser->line, gf_node_get_name(n), ID));\n\t}\n\treturn ID;\n}\n\nBool gf_bt_set_field_is(GF_BTParser *parser, GF_FieldInfo *info, GF_Node *n)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_ProtoFieldInterface *pfield;\n\tGF_FieldInfo pinfo;\n\tchar *str;\n\tgf_bt_check_line(parser);\n\ti=0;\n\twhile ((parser->line_buffer[parser->line_pos + i] == ' ') || (parser->line_buffer[parser->line_pos + i] == '\\t')) i++;\n\tif (strnicmp(&parser->line_buffer[parser->line_pos + i] , \"IS\", 2)) return 0;\n\n\tgf_bt_get_next(parser, 0);\n\tstr = gf_bt_get_next(parser, 0);\n\n\t/*that's an ISed field*/\n\tpfield = gf_sg_proto_field_find_by_name(parser->parsing_proto, str);\n\tif (!pfield) {\n\t\tgf_bt_report(parser, GF_BAD_PARAM, \"%s: Unknown proto field\", str);\n\t\treturn 1;\n\t}\n\tgf_sg_proto_field_get_field(pfield, &pinfo);\n\te = gf_sg_proto_field_set_ised(parser->parsing_proto, pinfo.fieldIndex, n, info->fieldIndex);\n\tif (e) gf_bt_report(parser, GF_BAD_PARAM, \"IS: Invalid field type for field %s\", info->name);\n\treturn 1;\n}\n\nvoid gf_bt_check_unresolved_nodes(GF_BTParser *parser)\n{\n\tu32 i, count;\n\tcount = gf_list_count(parser->undef_nodes);\n\tif (!count) return;\n\tfor (i=0; i<count; i++) {\n\t\tGF_Node *n = (GF_Node *)gf_list_get(parser->undef_nodes, i);\n\t\tgf_bt_report(parser, GF_BAD_PARAM, \"Cannot find node %s\\n\", gf_node_get_name(n) );\n\t\tgf_node_unregister(n, NULL);\n\t}\n\tparser->last_error = GF_BAD_PARAM;\n}\n\nBool gf_bt_has_been_def(GF_BTParser *parser, char *node_name)\n{\n\tu32 i, count;\n\tcount = gf_list_count(parser->def_nodes);\n\tfor (i=0; i<count; i++) {\n\t\tGF_Node *n = (GF_Node *) gf_list_get(parser->def_nodes, i);\n\t\tif (!strcmp(gf_node_get_name(n), node_name)) return 1;\n\t}\n\treturn 0;\n}\n\nu32 gf_bt_get_node_tag(GF_BTParser *parser, char *node_name)\n{\n\tu32 tag;\n\t/*if VRML and allowing non MPEG4 nodes, use X3D*/\n\tif (parser->is_wrl && !(parser->load->flags & GF_SM_LOAD_MPEG4_STRICT)) {\n#ifndef GPAC_DISABLE_X3D\n\t\ttag = gf_node_x3d_type_by_class_name(node_name);\n\t\tif (!tag)\n#endif\n\t\t\ttag = gf_node_mpeg4_type_by_class_name(node_name);\n\t\tif (tag) return tag;\n#ifndef GPAC_DISABLE_X3D\n\t\tif (!strcmp(node_name, \"Rectangle\")) return TAG_X3D_Rectangle2D;\n\t\tif (!strcmp(node_name, \"Circle\")) return TAG_X3D_Circle2D;\n#endif\n\t} else {\n\t\ttag = gf_node_mpeg4_type_by_class_name(node_name);\n\t\tif (!tag) {\n\t\t\tif (!strcmp(node_name, \"Rectangle2D\")) return TAG_MPEG4_Rectangle;\n\t\t\tif (!strcmp(node_name, \"Circle2D\")) return TAG_MPEG4_Circle;\n#ifndef GPAC_DISABLE_X3D\n\t\t\tif (!(parser->load->flags & GF_SM_LOAD_MPEG4_STRICT)) return gf_node_x3d_type_by_class_name(node_name);\n#endif\n\t\t}\n\t}\n\treturn tag;\n}\n\nGF_Node *gf_bt_sf_node(GF_BTParser *parser, char *node_name, GF_Node *parent, char *szDEFName)\n{\n\tu32 tag, ID;\n\tBool is_script, replace_prev, register_def;\n\tGF_Proto *proto;\n\tGF_Node *node, *newnode, *undef_node;\n\tGF_FieldInfo info;\n\tBool init_node;\n\tchar *name;\n\tchar * str;\n\n\tinit_node = 0;\n\n\tif (node_name) {\n\t\tstr = node_name;\n\t} else {\n\t\tstr = gf_bt_get_next(parser, 0);\n\t}\n\tname = NULL;\n\tif (!strcmp(str, \"NULL\")) return NULL;\n\n\tID = 0;\n\tregister_def = 0;\n\treplace_prev = 0;\n\tundef_node = NULL;\n\tif (!strcmp(str, \"DEF\")) {\n\t\tregister_def = 1;\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\tname = gf_strdup(str);\n\t\tstr = gf_bt_get_next(parser, 0);\n\t} else if (szDEFName) {\n\t\tname = gf_strdup(szDEFName);\n\t\tregister_def = 1;\n\t}\n\tif (name) {\n\t\tundef_node = gf_sg_find_node_by_name(parser->load->scene_graph, name);\n\t\tif (undef_node) {\n\t\t\tgf_list_del_item(parser->peeked_nodes, undef_node);\n\t\t\tID = gf_node_get_id(undef_node);\n\t\t\t/*if we see twice a DEF N1 then force creation of a new node*/\n\t\t\tif (gf_bt_has_been_def(parser, name)) {\n\t\t\t\tundef_node = NULL;\n\t\t\t\tID = gf_bt_get_def_id(parser, name);\n\t\t\t\tgf_bt_report(parser, GF_OK, \"Node %s has been DEFed several times, IDs may get corrupted\", name);\n\t\t\t}\n\t\t} else {\n\t\t\tID = gf_bt_get_def_id(parser, name);\n\t\t}\n\t}\n\telse if (!strcmp(str, \"USE\")) {\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\tnode = gf_sg_find_node_by_name(parser->load->scene_graph, str);\n\t\tif (!node) {\n\t\t\t/*create a temp node (undefined)*/\n\t\t\tnode = gf_node_new(parser->load->scene_graph, TAG_UndefinedNode);\n\t\t\tID = gf_bt_get_def_id(parser, str);\n\t\t\tgf_node_set_id(node, ID, str);\n\t\t\tgf_node_register(node, NULL);\n\t\t\tgf_list_add(parser->undef_nodes, node);\n\t\t}\n\t\tgf_node_register(node, parent);\n\t\treturn node;\n\t}\n\tproto = NULL;\n\ttag = gf_bt_get_node_tag(parser, str);\n\tif (!tag) {\n\t\tGF_SceneGraph *sg = parser->load->scene_graph;\n\t\twhile (1) {\n\t\t\tproto = gf_sg_find_proto(sg, 0, str);\n\t\t\tif (proto) break;\n\t\t\tsg = sg->parent_scene;\n\t\t\tif (!sg) break;\n\t\t}\n\t\tif (!proto) {\n\t\t\t/*locate proto*/\n\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"%s: not a valid/supported node\", str);\n\t\t\treturn NULL;\n\t\t}\n\t\ttag = TAG_ProtoNode;\n\t}\n\tif (undef_node && (undef_node->sgprivate->tag == tag)) {\n\t\tnode = undef_node;\n\t} else {\n\t\tif (undef_node) replace_prev = 1;\n\t\tif (proto) {\n\t\t\tnode = gf_sg_proto_create_instance(parser->load->scene_graph, proto);\n\t\t} else {\n\t\t\tnode = gf_node_new(parser->load->scene_graph, tag);\n\t\t}\n\t\tif (!parser->parsing_proto) init_node = 1;\n\t}\n\tis_script = 0;\n\tif ((tag==TAG_MPEG4_Script)\n#ifndef GPAC_DISABLE_X3D\n\t        || (tag==TAG_X3D_Script)\n#endif\n\t   )\n\t\tis_script = 1;\n\n\tif (!node) {\n\t\tparser->last_error = GF_SG_UNKNOWN_NODE;\n\t\treturn NULL;\n\t}\n\tif (register_def) gf_list_add(parser->def_nodes, node);\n\n\tgf_node_register(node, parent);\n\n\t/*VRML: \"The transformation hierarchy shall be a directed acyclic graph; results are undefined if a node\n\tin the transformation hierarchy is its own ancestor\"\n\tthat's good, because the scene graph can't handle cyclic graphs (destroy will never be called).\n\tHowever we still have to register the node before parsing it, to update node registry and get correct IDs*/\n\tif (name) {\n\t\tif (!undef_node || replace_prev) {\n\t\t\tgf_node_set_id(node, ID, name);\n\t\t}\n\t\tgf_free(name);\n\t\tname = NULL;\n\t}\n\tif (!parser->parsing_proto) gf_bt_update_timenode(parser, node);\n\n\tif (gf_bt_check_code(parser, '{')) {\n\n\t\twhile (1) {\n\t\t\tif (gf_bt_check_code(parser, '}'))\n\t\t\t\tbreak;\n\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tif (!str) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"Invalid node syntax\");\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\t/*VRML/X3D specific */\n\t\t\tif (parser->is_wrl) {\n\t\t\t\t/*we ignore bboxCenter and bboxSize*/\n\t\t\t\tif (!strcmp(str, \"bboxCenter\") || !strcmp(str, \"bboxSize\")) {\n\t\t\t\t\tFixed f;\n\t\t\t\t\tgf_bt_parse_float(parser, \"x\", &f);\n\t\t\t\t\tgf_bt_parse_float(parser, \"y\", &f);\n\t\t\t\t\tgf_bt_parse_float(parser, \"z\", &f);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/*some VRML files declare routes almost anywhere*/\n\t\t\t\tif (!strcmp(str, \"ROUTE\")) {\n\t\t\t\t\tgf_bt_parse_route(parser, 1, 0, NULL);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tparser->last_error = gf_node_get_field_by_name(node, str, &info);\n\n\t\t\t/*check common VRML fields removed in MPEG4*/\n\t\t\tif (parser->last_error) {\n\t\t\t\tif (!parser->is_wrl) {\n\t\t\t\t\t/*we ignore 'solid' for MPEG4 box/cone/etc*/\n\t\t\t\t\tif (!strcmp(str, \"solid\")) {\n\t\t\t\t\t\tSFBool b;\n\t\t\t\t\t\tgf_bt_parse_bool(parser, \"solid\", &b);\n\t\t\t\t\t\tparser->last_error = GF_OK;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t/*we ignore 'description' for MPEG4 sensors*/\n\t\t\t\t\telse if (!strcmp(str, \"description\")) {\n\t\t\t\t\t\tchar *tmpstr = gf_bt_get_string(parser, 0);\n\t\t\t\t\t\tgf_free(tmpstr);\n\t\t\t\t\t\tparser->last_error = GF_OK;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t/*remaps X3D to old VRML/MPEG4*/\n\t\t\t\t\telse if ((tag==TAG_MPEG4_LOD) && !strcmp(str, \"children\")) {\n\t\t\t\t\t\tstr = \"level\";\n\t\t\t\t\t\tparser->last_error = gf_node_get_field_by_name(node, str, &info);\n\t\t\t\t\t}\n\t\t\t\t\telse if ((tag==TAG_MPEG4_Switch) && !strcmp(str, \"children\")) {\n\t\t\t\t\t\tstr = \"choice\";\n\t\t\t\t\t\tparser->last_error = gf_node_get_field_by_name(node, str, &info);\n\t\t\t\t\t}\n\t\t\t\t\telse if (!strcmp(str, \"enabled\")) {\n\t\t\t\t\t\tSFBool b;\n\t\t\t\t\t\tgf_bt_parse_bool(parser, \"collide\", &b);\n\t\t\t\t\t\tparser->last_error = GF_OK;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t/*remaps old VRML/MPEG4 to X3D if possible*/\n#ifndef GPAC_DISABLE_X3D\n\t\t\t\t\tif ((tag==TAG_X3D_LOD) && !strcmp(str, \"level\")) {\n\t\t\t\t\t\tstr = \"children\";\n\t\t\t\t\t\tparser->last_error = gf_node_get_field_by_name(node, str, &info);\n\t\t\t\t\t}\n\t\t\t\t\telse if ((tag==TAG_X3D_Switch) && !strcmp(str, \"choice\")) {\n\t\t\t\t\t\tstr = \"children\";\n\t\t\t\t\t\tparser->last_error = gf_node_get_field_by_name(node, str, &info);\n\t\t\t\t\t}\n\t\t\t\t\telse\n#endif\n\t\t\t\t\t\tif (!strcmp(str, \"collide\")) {\n\t\t\t\t\t\t\tSFBool b;\n\t\t\t\t\t\t\tgf_bt_parse_bool(parser, \"enabled\", &b);\n\t\t\t\t\t\t\tparser->last_error = GF_OK;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (is_script && parser->last_error) {\n\t\t\t\tu32 eType, fType;\n\n\t\t\t\tif (!strcmp(str, \"eventIn\") || !strcmp(str, \"inputOnly\")) eType = GF_SG_SCRIPT_TYPE_EVENT_IN;\n\t\t\t\telse if (!strcmp(str, \"eventOut\") || !strcmp(str, \"outputOnly\")) eType = GF_SG_SCRIPT_TYPE_EVENT_OUT;\n\t\t\t\telse if (!strcmp(str, \"field\") || !strcmp(str, \"initializeOnly\")) eType = GF_SG_SCRIPT_TYPE_FIELD;\n\t\t\t\telse {\n\t\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"%s: Unknown script event type\", str);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\t\tfType = gf_sg_field_type_by_name(str);\n\t\t\t\tif (fType==GF_SG_VRML_UNKNOWN) {\n\t\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"%s: Unknown script field type\", str);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tparser->last_error = GF_OK;\n\t\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\t\tgf_sg_script_field_new(node, eType, fType, str);\n\t\t\t\tparser->last_error = gf_node_get_field_by_name(node, str, &info);\n\n\t\t\t\tif (parser->parsing_proto && gf_bt_set_field_is(parser, &info, node)) continue;\n\t\t\t\tif ((eType == GF_SG_SCRIPT_TYPE_EVENT_IN) || (eType == GF_SG_SCRIPT_TYPE_EVENT_OUT)) continue;\n\t\t\t}\n\n\t\t\tif (parser->last_error) {\n\t\t\t\tgf_bt_report(parser, parser->last_error, \"%s: Unknown field\", str);\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tif (proto) gf_sg_proto_mark_field_loaded(node, &info);\n\t\t\tif (parser->parsing_proto && gf_bt_set_field_is(parser, &info, node)) continue;\n\n\t\t\tswitch (info.fieldType) {\n\t\t\tcase GF_SG_VRML_SFNODE:\n\t\t\t\t/*if redefining node reset it - this happens with CreateVrmlFromString*/\n\t\t\t\tif (* ((GF_Node **)info.far_ptr) ) {\n\t\t\t\t\tgf_node_unregister(* ((GF_Node **)info.far_ptr), node);\n\t\t\t\t\t* ((GF_Node **)info.far_ptr) = NULL;\n\t\t\t\t}\n\n\t\t\t\tnewnode = gf_bt_sf_node(parser, NULL, node, NULL);\n\t\t\t\tif (!newnode && parser->last_error) goto err;\n\t\t\t\tif (newnode) {\n\t\t\t\t\tif (!gf_bt_check_ndt(parser, &info, newnode, node)) goto err;\n\n\t\t\t\t\t* ((GF_Node **)info.far_ptr) = newnode;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GF_SG_VRML_MFNODE:\n\t\t\t{\n\t\t\t\tGF_ChildNodeItem *last = NULL;\n\t\t\t\tBool single_child = 0;\n\t\t\t\tif (!gf_bt_check_code(parser, '[')) {\n\t\t\t\t\tif (parser->is_wrl) single_child = 1;\n\t\t\t\t\telse break;\n\t\t\t\t}\n\n\t\t\t\t/*if redefining node reset it - this happens with CreateVrmlFromString*/\n\t\t\t\tif (undef_node==node) {\n\t\t\t\t\tgf_node_unregister_children(node, *(GF_ChildNodeItem **)info.far_ptr);\n\t\t\t\t\t*(GF_ChildNodeItem **)info.far_ptr = NULL;\n\t\t\t\t}\n\n\t\t\t\twhile (single_child || !gf_bt_check_code(parser, ']')) {\n\t\t\t\t\t/*VRML seems to allow that*/\n\t\t\t\t\tgf_bt_check_code(parser, ',');\n\t\t\t\t\tnewnode = gf_bt_sf_node(parser, NULL, node, NULL);\n\t\t\t\t\tif (!newnode && parser->last_error) goto err;\n\t\t\t\t\tif (newnode) {\n\t\t\t\t\t\tif (!gf_bt_check_ndt(parser, &info, newnode, node)) goto err;\n\t\t\t\t\t\tgf_node_list_add_child_last( (GF_ChildNodeItem **)info.far_ptr, newnode, &last);\n\t\t\t\t\t}\n\t\t\t\t\tif (single_child) break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (gf_sg_vrml_is_sf_field(info.fieldType)) {\n\t\t\t\t\tgf_bt_sffield(parser, &info, node);\n\t\t\t\t} else {\n\t\t\t\t\tgf_bt_mffield(parser, &info, node);\n\t\t\t\t}\n\t\t\t\tif (parser->last_error) goto err;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*VRML seems to allow that*/\n\t\t\tgf_bt_check_code(parser, ',');\n\t\t}\n\t}\n\t/*VRML seems to allow that*/\n\tgf_bt_check_code(parser, ',');\n\n\t/*we must init the node once ID is set in case we're creating rendering stacks*/\n\tif (init_node && (gf_node_get_tag(node)!=TAG_ProtoNode) ) gf_node_init(node);\n\n\t/*remove temp node*/\n\tif (replace_prev) {\n\t\tgf_node_replace(undef_node, node, 0);\n\t\tgf_node_unregister(undef_node, NULL);\n\t\tgf_list_del_item(parser->undef_nodes, undef_node);\n\t}\n\n\tif (!parser->parsing_proto && is_script && (parser->load->flags & GF_SM_LOAD_FOR_PLAYBACK) ) {\n\t\tif (parser->cur_com) {\n\t\t\tif (!parser->cur_com->scripts_to_load) parser->cur_com->scripts_to_load = gf_list_new();\n\t\t\tgf_list_add(parser->cur_com->scripts_to_load, node);\n\t\t} else {\n\t\t\t/*postpone script init since it may use routes/nodes not yet defined ...*/\n\t\t\tgf_list_add(parser->scripts, node);\n\t\t}\n\t}\n\t/*For Ivica: load proto as soon as found when in playback mode*/\n\tif ( (parser->load->flags & GF_SM_LOAD_FOR_PLAYBACK) && proto && !parser->parsing_proto) {\n\t\tparser->last_error = gf_sg_proto_load_code(node);\n\t}\n\treturn node;\n\nerr:\n\tgf_node_unregister(node, parent);\n\tif (name) gf_free(name);\n\treturn NULL;\n}\n/*\n\tlocate node, if not defined yet parse ahead in current AU\n\toptimization: we actually peek ALL DEF NODES till end of AU\n*/\nGF_Node *gf_bt_peek_node(GF_BTParser *parser, char *defID)\n{\n\tGF_Node *n, *the_node;\n\tu32 tag, ID;\n\tBool prev_is_insert = 0;\n\tchar *ret;\n\tchar nName[1000];\n\tu32 pos, line, line_pos, i, count;\n\n\tn = gf_sg_find_node_by_name(parser->load->scene_graph, defID);\n\tif (n) return n;\n\n\tcount = gf_list_count(parser->peeked_nodes);\n\tfor (i=0; i<count; i++) {\n\t\tn = (GF_Node *)gf_list_get(parser->peeked_nodes, i);\n\t\tif (!strcmp(gf_node_get_name(n), defID)) return n;\n\t}\n\n\tthe_node = NULL;\n\tpos = parser->line_start_pos;\n\tline_pos = parser->line_pos;\n\tline = parser->line;\n\tstrcpy(nName, defID);\n\n\tn = NULL;\n\twhile (!parser->done && !the_node) {\n\t\tchar *str = gf_bt_get_next(parser, 0);\n\t\tgf_bt_check_code(parser, '[');\n\t\tgf_bt_check_code(parser, ']');\n\t\tgf_bt_check_code(parser, '{');\n\t\tgf_bt_check_code(parser, '}');\n\t\tgf_bt_check_code(parser, ',');\n\t\tgf_bt_check_code(parser, '.');\n\n\t\tif ( (!prev_is_insert && !strcmp(str, \"AT\")) || !strcmp(str, \"PROTO\") ) {\n\t\t\t/*only check in current command (but be aware of conditionals..)*/\n\t\t\tif (gf_list_find(parser->bifs_au->commands, parser->cur_com)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(str, \"INSERT\")) prev_is_insert = 1;\n\t\telse prev_is_insert = 0;\n\n\t\tif (strcmp(str, \"DEF\")) continue;\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\tret = gf_strdup(str);\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\tif (!strcmp(str, \"ROUTE\")) {\n\t\t\tgf_free(ret);\n\t\t\tcontinue;\n\t\t}\n\n\t\ttag = gf_bt_get_node_tag(parser, str);\n\t\tif (!tag) {\n\t\t\tGF_Proto *p;\n\t\t\tGF_SceneGraph *sg = parser->load->scene_graph;\n\t\t\twhile (1) {\n\t\t\t\tp = gf_sg_find_proto(sg, 0, str);\n\t\t\t\tif (p) break;\n\t\t\t\tsg = sg->parent_scene;\n\t\t\t\tif (!sg) break;\n\t\t\t}\n\t\t\tif (!p) {\n\t\t\t\t/*locate proto*/\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"%s: not a valid/supported node\", str);\n\t\t\t\tgf_free(ret);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tn = gf_sg_proto_create_instance(parser->load->scene_graph, p);\n\t\t} else {\n\t\t\tn = gf_node_new(parser->load->scene_graph, tag);\n\t\t}\n\t\tID = gf_bt_get_def_id(parser, ret);\n\t\tif (n) {\n\t\t\tgf_node_set_id(n, ID, ret);\n\t\t\tgf_list_add(parser->peeked_nodes, n);\n\t\t\tif (!parser->parsing_proto) gf_node_init(n);\n\t\t\tif (!strcmp(ret, nName)) the_node = n;\n\t\t}\n\t\tgf_free(ret);\n\n\t\t/*NO REGISTER on peek (both scene graph or DEF list) because peek is only used to get node type\n\t\tand fields, never to insert in the graph*/\n\n\t\t/*go on till end of AU*/\n\t}\n\t/*restore context*/\n\tparser->done = 0;\n\tgf_gzrewind(parser->gz_in);\n\tgf_gzseek(parser->gz_in, pos, SEEK_SET);\n\tparser->line_pos = parser->line_size;\n\tgf_bt_check_line(parser);\n\tparser->line = line;\n\tparser->line_pos = line_pos;\n\n\treturn the_node;\n}\n\nu32 gf_bt_get_route(GF_BTParser *parser, char *name)\n{\n\tu32 i;\n\tGF_Command *com;\n\tGF_Route *r = gf_sg_route_find_by_name(parser->load->scene_graph, name);\n\tif (r) return r->ID;\n\ti=0;\n\twhile ((com = (GF_Command *)gf_list_enum(parser->inserted_routes, &i))) {\n\t\tif (com->def_name && !strcmp(com->def_name, name)) return com->RouteID;\n\t}\n\treturn 0;\n}\n\nBool gf_bt_route_id_used(GF_BTParser *parser, u32 ID)\n{\n\tu32 i;\n\tGF_Command *com;\n\tGF_Route *r = gf_sg_route_find(parser->load->scene_graph, ID);\n\tif (r) return 1;\n\ti=0;\n\twhile ((com = (GF_Command *)gf_list_enum(parser->inserted_routes, &i))) {\n\t\tif (com->RouteID == ID) return 1;\n\t}\n\treturn 0;\n}\n\nstatic u32 get_evt_type(char *eventName)\n{\n\tif (!strcmp(eventName, \"eventIn\") || !strcmp(eventName, \"inputOnly\")) return GF_SG_EVENT_IN;\n\telse if (!strcmp(eventName, \"eventOut\") || !strcmp(eventName, \"outputOnly\")) return GF_SG_EVENT_OUT;\n\telse if (!strcmp(eventName, \"field\") || !strcmp(eventName, \"initializeOnly\")) return GF_SG_EVENT_FIELD;\n\telse if (!strcmp(eventName, \"exposedField\") || !strcmp(eventName, \"inputOutput\")) return GF_SG_EVENT_EXPOSED_FIELD;\n\telse return GF_SG_EVENT_UNKNOWN;\n}\n\nGF_Err gf_bt_parse_proto(GF_BTParser *parser, char *proto_code, GF_List *proto_list)\n{\n\tGF_FieldInfo info;\n\tu32 fType, eType, QPType=0, pID;\n\tBool externProto;\n\tGF_Proto *proto, *prevproto;\n\tGF_ProtoFieldInterface *pfield;\n\tGF_SceneGraph *sg;\n\tchar *str, *name;\n\tchar szDefName[1024];\n\tBool isDEF;\n\n\tif (proto_code)\n\t\tstr = proto_code;\n\telse\n\t\tstr = gf_bt_get_next(parser, 0);\n\n\texternProto = !strcmp(str, \"EXTERNPROTO\") ? 1 : 0;\n\tstr = gf_bt_get_next(parser, 0);\n\tname = gf_strdup(str);\n\tif (!gf_bt_check_code(parser, '[')) {\n\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"[ expected in proto declare\");\n\t}\n\tpID = gf_bt_get_next_proto_id(parser);\n\t/*if redefinition remove it - WRL only, may be used by loadVRMLFormString*/\n\tif (!proto_list && parser->is_wrl) {\n\t\tproto = gf_sg_find_proto(parser->load->scene_graph, pID, name);\n\t\tif (proto) gf_sg_proto_del(proto);\n\t}\n\tproto = gf_sg_proto_new(parser->load->scene_graph, pID, name, proto_list ? 1 : 0);\n\tif (proto_list) gf_list_add(proto_list, proto);\n\tif (parser->load->ctx && (parser->load->ctx->max_proto_id<pID)) parser->load->ctx->max_proto_id = pID;\n\n\t/*hack for VRML, where externProto default field values are not mandatory*/\n\tparser->is_extern_proto_field = externProto;\n\n\tgf_free(name);\n\t/*get all fields*/\n\twhile (!parser->last_error && !gf_bt_check_code(parser, ']')) {\n\t\tstr = gf_bt_get_next(parser, 0);\n\nnext_field:\n\t\tif (gf_bt_check_code(parser, ']')) break;\n\n\t\teType = get_evt_type(str);\n\t\tif (eType==GF_SG_EVENT_UNKNOWN) {\n\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"%s: Unknown event type\", str);\n\t\t\tgoto err;\n\t\t}\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\tfType = gf_sg_field_type_by_name(str);\n\t\tif (fType==GF_SG_VRML_UNKNOWN) {\n\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"%s: Unknown field type\", str);\n\t\t\tgoto err;\n\t\t}\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\tpfield = gf_sg_proto_field_new(proto, fType, eType, str);\n\t\tif ((eType==GF_SG_EVENT_IN) || (eType==GF_SG_EVENT_OUT)) continue;\n\n\t\tgf_sg_proto_field_get_field(pfield, &info);\n\t\tif (fType==GF_SG_VRML_SFNODE) {\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tif (strcmp(str, \"NULL\")) {\n\t\t\t\tif ( (!strlen(str) || (get_evt_type(str)!=GF_SG_EVENT_UNKNOWN)) && parser->is_extern_proto_field) goto next_field;\n\t\t\t\tpfield->def_sfnode_value = gf_bt_sf_node(parser, str, NULL, NULL);\n\t\t\t}\n\t\t} else if (fType==GF_SG_VRML_MFNODE) {\n\t\t\tGF_ChildNodeItem *last = NULL;\n\t\t\tif (gf_bt_check_code(parser, '[')) {\n\t\t\t\twhile (1) {\n\t\t\t\t\tGF_Node *pf_node;\n\t\t\t\t\tif (gf_bt_check_code(parser, ']')) break;\n\t\t\t\t\tpf_node = gf_bt_sf_node(parser, NULL, NULL, NULL);\n\t\t\t\t\tif (pf_node) gf_node_list_add_child_last( &pfield->def_mfnode_value, pf_node, &last);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (gf_sg_vrml_is_sf_field(fType)) {\n\t\t\tgf_bt_sffield(parser, &info, NULL);\n\t\t\t/*value not specified for externproto*/\n\t\t\tif (parser->last_error==GF_EOS) {\n\t\t\t\tparser->last_error=GF_OK;\n\t\t\t\tgoto next_field;\n\t\t\t}\n\t\t} else {\n\t\t\tgf_bt_mffield(parser, &info, NULL);\n\t\t}\n\t\t/*check QP info*/\n\t\tif (!gf_bt_check_code(parser, '{')) continue;\n\t\tif (gf_bt_check_code(parser, '}')) continue;\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\tif (!strcmp(str, \"QP\")) {\n\t\t\tu32 nbBits, hasMin;\n\t\t\tFixed ftMin, ftMax;\n\t\t\tgf_bt_parse_int(parser, \"QPType\", (SFInt32*)&QPType);\n\n\t\t\tnbBits = 0;\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tif (!strcmp(str, \"nbBits\")) {\n\t\t\t\tgf_bt_parse_int(parser, \"nbBits\", (SFInt32*)&nbBits);\n\t\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\t}\n\t\t\thasMin = 0;\n\t\t\teType = 0;\n\t\t\tif (!strcmp(str, \"b\")) {\n\t\t\t\thasMin = 1;\n\t\t\t\tif (!gf_bt_check_code(parser, '{')) {\n\t\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"%s: Invalid proto coding parameter declare\", str);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tgf_bt_parse_float(parser, \"min\", &ftMin);\n\t\t\t\tgf_bt_parse_float(parser, \"max\", &ftMax);\n\t\t\t\tif (!gf_bt_check_code(parser, '}')) {\n\t\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"Invalid proto coding parameter declare\");\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tif (gf_sg_vrml_get_sf_type(fType) == GF_SG_VRML_SFINT32) {\n\t\t\t\t\teType = GF_SG_VRML_SFINT32;\n\t\t\t\t} else {\n\t\t\t\t\teType = GF_SG_VRML_SFFLOAT;\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_bifs_proto_field_set_aq_info(pfield, QPType, hasMin, eType, &ftMin, &ftMax, nbBits);\n\t\t\tif (!gf_bt_check_code(parser, '}')) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"Invalid proto coding parameter declare\");\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\t}\n\tparser->is_extern_proto_field = 0;\n\n\tif (externProto) {\n\t\tSFURL *url;\n\t\tBool has_urls = 0;\n\t\tif (gf_bt_check_code(parser, '[')) has_urls = 1;\n\n\t\tgf_sg_vrml_mf_reset(&proto->ExternProto, GF_SG_VRML_MFURL);\n\t\tdo {\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tgf_sg_vrml_mf_append(&proto->ExternProto, GF_SG_VRML_MFURL, (void **) &url);\n\t\t\tif (!strnicmp(str, \"od:\", 3)) {\n\t\t\t\tsscanf(str, \"od:%u\", &url->OD_ID);\n\t\t\t} else {\n\t\t\t\tif (!sscanf(str, \"%u\", &url->OD_ID)) {\n\t\t\t\t\turl->url = gf_strdup(str);\n\t\t\t\t} else {\n\t\t\t\t\tchar szURL[20];\n\t\t\t\t\tsprintf(szURL, \"%d\", url->OD_ID);\n\t\t\t\t\tif (strcmp(szURL, str)) {\n\t\t\t\t\t\turl->OD_ID = 0;\n\t\t\t\t\t\turl->url = gf_strdup(str);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (has_urls) {\n\t\t\t\tgf_bt_check_code(parser, ',');\n\t\t\t\tif (gf_bt_check_code(parser, ']')) has_urls = 0;\n\t\t\t}\n\t\t} while (has_urls);\n\t\treturn GF_OK;\n\t}\n\n\t/*parse proto code */\n\tif (!gf_bt_check_code(parser, '{')) {\n\t\tgf_bt_report(parser, GF_OK, \"empty proto body\");\n\t\treturn GF_OK;\n\t}\n\n\tprevproto = parser->parsing_proto;\n\tsg = parser->load->scene_graph;\n\tparser->parsing_proto = proto;\n\tparser->load->scene_graph = gf_sg_proto_get_graph(proto);\n\n\tisDEF = 0;\n\twhile (!gf_bt_check_code(parser, '}')) {\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\tif (!strcmp(str, \"PROTO\") || !strcmp(str, \"EXTERNPROTO\")) {\n\t\t\tgf_bt_parse_proto(parser, str, NULL);\n\t\t} else if (!strcmp(str, \"DEF\")) {\n\t\t\tisDEF = 1;\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tstrcpy(szDefName, str);\n\t\t} else if (!strcmp(str, \"ROUTE\")) {\n\t\t\tGF_Route *r = gf_bt_parse_route(parser, 1, 0, NULL);\n\t\t\tif (isDEF) {\n\t\t\t\tu32 rID = gf_bt_get_route(parser, szDefName);\n\t\t\t\tif (!rID) rID = gf_bt_get_next_route_id(parser);\n\t\t\t\tparser->last_error = gf_sg_route_set_id(r, rID);\n\t\t\t\tgf_sg_route_set_name(r, szDefName);\n\t\t\t\tisDEF = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tGF_Node *n = gf_bt_sf_node(parser, str, NULL, isDEF ? szDefName : NULL);\n\t\t\tisDEF = 0;\n\t\t\tif (!n) goto err;\n\t\t\tif ((0) && isDEF) {\n\t\t\t\tu32 ID = gf_bt_get_def_id(parser, szDefName);\n\t\t\t\tisDEF = 0;\n\t\t\t\tgf_node_set_id(n, ID, szDefName);\n\t\t\t}\n\t\t\tgf_sg_proto_add_node_code(proto, n);\n\t\t}\n\t}\n\tgf_bt_resolve_routes(parser, 1);\n\tgf_bt_check_unresolved_nodes(parser);\n\tparser->load->scene_graph = sg;\n\tparser->parsing_proto = prevproto;\n\treturn parser->last_error;\n\nerr:\n\tif (proto_list) gf_list_del_item(proto_list, proto);\n\tgf_sg_proto_del(proto);\n\treturn parser->last_error;\n}\n\n\nGF_Route *gf_bt_parse_route(GF_BTParser *parser, Bool skip_def, Bool is_insert, GF_Command *com)\n{\n\tGF_Route *r;\n\tchar *str, nstr[1000], rName[1000];\n\tu32 rID;\n\tGF_Node *orig, *dest;\n\tGF_FieldInfo orig_field, dest_field;\n\tGF_Err e;\n\n\trID = 0;\n\tstrcpy(nstr, gf_bt_get_next(parser, 1));\n\tif (!skip_def && !strcmp(nstr, \"DEF\")) {\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\tstrcpy(rName, str);\n\t\trID = gf_bt_get_route(parser, rName);\n\t\tif (!rID && (str[0]=='R') ) {\n\t\t\trID = atoi(&str[1]);\n\t\t\tif (rID) {\n\t\t\t\trID++;\n\t\t\t\tif (gf_bt_route_id_used(parser, rID)) rID = 0;\n\t\t\t}\n\t\t}\n\t\tif (!rID) rID = gf_bt_get_next_route_id(parser);\n\t\tstrcpy(nstr, gf_bt_get_next(parser, 1));\n\t}\n\torig = gf_bt_peek_node(parser, nstr);\n\tif (!orig) {\n\t\tgf_bt_report(parser, GF_BAD_PARAM, \"cannot find node %s\", nstr);\n\t\treturn NULL;\n\t}\n\tif (!gf_bt_check_code(parser, '.')) {\n\t\tgf_bt_report(parser, GF_BAD_PARAM, \". expected in route decl\");\n\t\treturn NULL;\n\t}\n\tstr = gf_bt_get_next(parser, 0);\n\te = gf_node_get_field_by_name(orig, str, &orig_field);\n\t/*VRML loosy syntax*/\n\tif ((e != GF_OK) && parser->is_wrl && !strnicmp(str, \"set_\", 4))\n\t\te = gf_node_get_field_by_name(orig, &str[4], &orig_field);\n\n\tif ((e != GF_OK) && parser->is_wrl && strstr(str, \"_changed\")) {\n\t\tchar *s = strstr(str, \"_changed\");\n\t\ts[0] = 0;\n\t\te = gf_node_get_field_by_name(orig, str, &orig_field);\n\t}\n\n\tif (e != GF_OK) {\n\t\tgf_bt_report(parser, GF_BAD_PARAM, \"%s not a field of node %s (%s)\", str, gf_node_get_name(orig), gf_node_get_class_name(orig));\n\t\treturn NULL;\n\t}\n\tstr = gf_bt_get_next(parser, 0);\n\tif (strcmp(str, \"TO\")) {\n\t\tgf_bt_report(parser, GF_BAD_PARAM, \"TO expected in route declaration - got \\\"%s\\\"\", str);\n\t\treturn NULL;\n\t}\n\n\tstrcpy(nstr, gf_bt_get_next(parser, 1));\n\tdest = gf_bt_peek_node(parser, nstr);\n\tif (!dest) {\n\t\tgf_bt_report(parser, GF_BAD_PARAM, \"cannot find node %s\", nstr);\n\t\treturn NULL;\n\t}\n\tif (!gf_bt_check_code(parser, '.')) {\n\t\tgf_bt_report(parser, GF_BAD_PARAM, \". expected in route decl\");\n\t\treturn NULL;\n\t}\n\tstr = gf_bt_get_next(parser, 0);\n\te = gf_node_get_field_by_name(dest, str, &dest_field);\n\t/*VRML loosy syntax*/\n\tif ((e != GF_OK) && parser->is_wrl && !strnicmp(str, \"set_\", 4))\n\t\te = gf_node_get_field_by_name(dest, &str[4], &dest_field);\n\n\tif ((e != GF_OK) && parser->is_wrl && strstr(str, \"_changed\")) {\n\t\tchar *s = strstr(str, \"_changed\");\n\t\ts[0] = 0;\n\t\te = gf_node_get_field_by_name(dest, str, &dest_field);\n\t}\n\n\tif (e != GF_OK) {\n\t\tgf_bt_report(parser, GF_BAD_PARAM, \"%s not a field of node %s (%s)\", str, gf_node_get_name(dest), gf_node_get_class_name(dest));\n\t\treturn NULL;\n\t}\n\tif (com) {\n\t\tcom->fromNodeID = gf_node_get_id(orig);\n\t\tcom->fromFieldIndex = orig_field.fieldIndex;\n\t\tcom->toNodeID = gf_node_get_id(dest);\n\t\tcom->toFieldIndex = dest_field.fieldIndex;\n\t\tif (rID) {\n\t\t\tcom->RouteID = rID;\n\t\t\tcom->def_name = gf_strdup(rName);\n\t\t\t/*whenever inserting routes, keep track of max defined ID*/\n\t\t\tif (is_insert) {\n\t\t\t\tgf_sg_set_max_defined_route_id(parser->load->scene_graph, rID);\n\t\t\t\tif (parser->load->ctx && (rID>parser->load->ctx->max_route_id))\n\t\t\t\t\tparser->load->ctx->max_route_id = rID;\n\t\t\t}\n\t\t}\n\t\treturn NULL;\n\t}\n\tr = gf_sg_route_new(parser->load->scene_graph, orig, orig_field.fieldIndex, dest, dest_field.fieldIndex);\n\tif (r && rID) {\n\t\tgf_sg_route_set_id(r, rID);\n\t\tgf_sg_route_set_name(r, rName);\n\t}\n\treturn r;\n}\n\nvoid gf_bt_resolve_routes(GF_BTParser *parser, Bool clean)\n{\n\t/*resolve all commands*/\n\twhile(gf_list_count(parser->unresolved_routes) ) {\n\t\tGF_Command *com = (GF_Command *)gf_list_get(parser->unresolved_routes, 0);\n\t\tgf_list_rem(parser->unresolved_routes, 0);\n\t\tswitch (com->tag) {\n\t\tcase GF_SG_ROUTE_DELETE:\n\t\tcase GF_SG_ROUTE_REPLACE:\n\t\t\tcom->RouteID = gf_bt_get_route(parser, com->unres_name);\n\t\t\tif (!com->RouteID) gf_bt_report(parser, GF_BAD_PARAM, \"Cannot resolve Route %s\", com->unres_name);\n\t\t\tgf_free(com->unres_name);\n\t\t\tcom->unres_name = NULL;\n\t\t\tcom->unresolved = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!clean) return;\n\twhile (gf_list_count(parser->inserted_routes)) gf_list_rem(parser->inserted_routes, 0);\n}\n\n\nstatic void bd_set_com_node(GF_Command *com, GF_Node *node)\n{\n\tcom->node = node;\n\tgf_node_register(com->node, NULL);\n}\n\nGF_Err gf_bt_parse_bifs_command(GF_BTParser *parser, char *name, GF_List *cmdList)\n{\n\ts32 pos;\n\tGF_Route *r;\n\tGF_Node *n, *newnode;\n\tGF_Command *com;\n\tGF_CommandField *inf;\n\tGF_FieldInfo info;\n\tchar *str, field[1000];\n\tif (!name) {\n\t\tstr = gf_bt_get_next(parser, 0);\n\t} else {\n\t\tstr = name;\n\t}\n\tcom = NULL;\n\tpos = -2;\n\t/*REPLACE commands*/\n\tif (!strcmp(str, \"REPLACE\")) {\n\t\tstr = gf_bt_get_next(parser, 1);\n\t\tif (!strcmp(str, \"ROUTE\")) {\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tr = gf_sg_route_find_by_name(parser->load->scene_graph, str);\n\t\t\tif (!r) strcpy(field, str);\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tif (strcmp(str, \"BY\")) {\n\t\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"BY expected got %s\", str);\n\t\t\t}\n\t\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_ROUTE_REPLACE);\n\t\t\tif (r) {\n\t\t\t\tcom->RouteID = r->ID;\n\t\t\t} else {\n\t\t\t\tcom->unres_name = gf_strdup(field);\n\t\t\t\tcom->unresolved = 1;\n\t\t\t\tgf_list_add(parser->unresolved_routes, com);\n\t\t\t}\n\t\t\tgf_bt_parse_route(parser, 1, 0, com);\n\t\t\tgf_list_add(cmdList, com);\n\t\t\treturn parser->last_error;\n\t\t}\n\t\t/*scene replace*/\n\t\tif (!strcmp(str, \"SCENE\")) {\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tif (strcmp(str, \"BY\")) {\n\t\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"BY expected got %s\", str);\n\t\t\t}\n\t\t\tgf_bt_resolve_routes(parser, 1);\n\t\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_SCENE_REPLACE);\n\t\t\twhile (gf_list_count(parser->def_nodes)) gf_list_rem(parser->def_nodes, 0);\n\n\t\t\twhile (1) {\n\t\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\t\tif (!strcmp(str, \"PROTO\") || !strcmp(str, \"EXTERNPROTO\")) {\n\t\t\t\t\tgf_bt_parse_proto(parser, str, com->new_proto_list);\n\t\t\t\t\tif (parser->last_error) goto err;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tn = gf_bt_sf_node(parser, str, NULL, NULL);\n\t\t\tcom->node = n;\n\n\t\t\tif (parser->last_error) goto err;\n\t\t\tgf_list_add(cmdList, com);\n\t\t\tparser->cur_com = com;\n\t\t\treturn GF_OK;\n\t\t}\n\t\tif (!strcmp(str, \"LAST\")) pos = -1;\n\t\telse if (!strcmp(str, \"BEGIN\")) pos = 0;\n\n\t\tgf_bt_check_code(parser, '.');\n\t\tstrcpy(field, str);\n\t\tn = gf_bt_peek_node(parser, str);\n\t\tif (!n) return gf_bt_report(parser, GF_BAD_PARAM, \"%s: unknown node\", field);\n\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\tstrcpy(field, str);\n\t\tif (gf_bt_check_code(parser, '[')) {\n\t\t\tif ( (parser->last_error = gf_bt_parse_int(parser, \"index\", &pos)) ) return parser->last_error;\n\t\t\tif (!gf_bt_check_code(parser, ']'))\n\t\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"] expected\");\n\t\t}\n\t\t/*node replace*/\n\t\tif (!strcmp(field, \"BY\")) {\n\t\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_NODE_REPLACE);\n\t\t\tbd_set_com_node(com, n);\n\t\t\tinf = gf_sg_command_field_new(com);\n\t\t\tinf->new_node = gf_bt_sf_node(parser, NULL, NULL, NULL);\n\t\t\tinf->fieldType = GF_SG_VRML_SFNODE;\n\t\t\tinf->field_ptr = &inf->new_node;\n\t\t\tgf_list_add(cmdList, com);\n\t\t\tparser->cur_com = com;\n\t\t\treturn parser->last_error;\n\t\t}\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\tif (strcmp(str, \"BY\"))\n\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"BY expected got %s\", str);\n\n\t\tparser->last_error = gf_node_get_field_by_name(n, field, &info);\n\t\tif (parser->last_error)\n\t\t\treturn gf_bt_report(parser, parser->last_error, \"%s: Unknown node field\", field);\n\n\t\t/*field replace*/\n\t\tif (pos==-2) {\n\t\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_FIELD_REPLACE);\n\t\t\tbd_set_com_node(com, n);\n\n\t\t\tinf = gf_sg_command_field_new(com);\n\t\t\tinf->fieldIndex = info.fieldIndex;\n\t\t\tinf->fieldType = info.fieldType;\n\n\t\t\tswitch (info.fieldType) {\n\t\t\tcase GF_SG_VRML_SFNODE:\n\t\t\t\tnewnode = gf_bt_sf_node(parser, NULL, NULL, NULL);\n\t\t\t\tif (!gf_bt_check_ndt(parser, &info, newnode, n)) goto err;\n\t\t\t\tinf->new_node = newnode;\n\t\t\t\tinf->field_ptr = &inf->new_node;\n\t\t\t\tbreak;\n\t\t\tcase GF_SG_VRML_MFNODE:\n\t\t\t{\n\t\t\t\tGF_ChildNodeItem *last = NULL;\n\t\t\t\tif (!gf_bt_check_code(parser, '[')) break;\n\t\t\t\tinf->field_ptr = &inf->node_list;\n\t\t\t\twhile (!gf_bt_check_code(parser, ']')) {\n\t\t\t\t\tnewnode = gf_bt_sf_node(parser, NULL, NULL, NULL);\n\t\t\t\t\tif (!newnode) goto err;\n\t\t\t\t\tif (parser->last_error!=GF_OK) goto err;\n\t\t\t\t\tif (!gf_bt_check_ndt(parser, &info, newnode, n)) goto err;\n\t\t\t\t\tgf_node_list_add_child_last(& inf->node_list, newnode, &last);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tinf->field_ptr = gf_sg_vrml_field_pointer_new(info.fieldType);\n\t\t\t\tinfo.far_ptr = inf->field_ptr;\n\t\t\t\tif (gf_sg_vrml_is_sf_field(info.fieldType)) {\n\t\t\t\t\tgf_bt_sffield(parser, &info, n);\n\t\t\t\t} else {\n\t\t\t\t\tgf_bt_mffield(parser, &info, n);\n\t\t\t\t}\n\t\t\t\tif (parser->last_error) goto err;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tgf_list_add(cmdList, com);\n\t\t\tparser->cur_com = com;\n\t\t\treturn parser->last_error;\n\t\t}\n\t\t/*indexed field replace*/\n\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_INDEXED_REPLACE);\n\t\tbd_set_com_node(com, n);\n\t\tinf = gf_sg_command_field_new(com);\n\t\tinf->pos = pos;\n\t\tinf->fieldIndex = info.fieldIndex;\n\t\tif (gf_sg_vrml_is_sf_field(info.fieldType)) {\n\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"%s: MF type field expected\", info.name);\n\t\t\tgoto err;\n\t\t}\n\t\tinf->fieldType = gf_sg_vrml_get_sf_type(info.fieldType);\n\t\tswitch (info.fieldType) {\n\t\tcase GF_SG_VRML_MFNODE:\n\t\t\tnewnode = gf_bt_sf_node(parser, NULL, NULL, NULL);\n\t\t\tif (!gf_bt_check_ndt(parser, &info, newnode, n)) goto err;\n\t\t\tinf->new_node = newnode;\n\t\t\tinf->field_ptr = &inf->new_node;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tinfo.fieldType = inf->fieldType;\n\t\t\tinfo.far_ptr = inf->field_ptr = gf_sg_vrml_field_pointer_new(inf->fieldType);\n\t\t\tgf_bt_sffield(parser, &info, n);\n\t\t\tbreak;\n\t\t}\n\t\tif (parser->last_error) goto err;\n\t\tgf_list_add(cmdList, com);\n\t\tparser->cur_com = com;\n\t\treturn parser->last_error;\n\t}\n\t/*XREPLACE commands*/\n\tif (!strcmp(str, \"XREPLACE\")) {\n\t\tu32 j;\n\t\tBool force_sf=0;\n\t\tchar csep;\n\t\tGF_Node *targetNode, *idxNode, *childNode, *fromNode;\n\t\tGF_FieldInfo targetField, idxField, childField, fromField;\n\n\t\tidxNode = childNode = fromNode = NULL;\n\t\tstr = gf_bt_get_next(parser, 1);\n\t\t/*get source node*/\n\t\tstrcpy(field, str);\n\t\ttargetNode = gf_bt_peek_node(parser, str);\n\t\tif (!targetNode) return gf_bt_report(parser, GF_BAD_PARAM, \"%s: unknown node\", field);\n\t\tif (!gf_bt_check_code(parser, '.')) {\n\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"XREPLACE: '.' expected\");\n\t\t}\n\t\t/*get source field*/\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\tstrcpy(field, str);\n\t\tparser->last_error = gf_node_get_field_by_name(targetNode, field, &targetField);\n\t\tif (parser->last_error)\n\t\t\treturn gf_bt_report(parser, parser->last_error, \"%s: Unknown node field\", field);\n\n\t\tif (gf_bt_check_code(parser, '[')) {\n\t\t\tpos = -2;\n\t\t\tstr = gf_bt_get_next(parser, 1);\n\t\t\tforce_sf = 1;\n\t\t\tif (sscanf(str, \"%d\", &pos) != 1) {\n\t\t\t\tpos = -2;\n\t\t\t\tif (!strcmp(str, \"LAST\")) pos = -1;\n\t\t\t\telse if (!strcmp(str, \"first\")) pos = 0;\n\t\t\t\telse {\n\t\t\t\t\tstrcpy(field, str);\n\t\t\t\t\t/*get idx node*/\n\t\t\t\t\tidxNode = gf_bt_peek_node(parser, str);\n\t\t\t\t\tif (!idxNode) return gf_bt_report(parser, GF_BAD_PARAM, \"%s: unknown node\", field);\n\t\t\t\t\tif (!gf_bt_check_code(parser, '.'))\n\t\t\t\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"XREPLACE: '.' expected\");\n\n\t\t\t\t\t/*get idx field*/\n\t\t\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\t\t\tstrcpy(field, str);\n\t\t\t\t\tparser->last_error = gf_node_get_field_by_name(idxNode, field, &idxField);\n\t\t\t\t\tif (parser->last_error)\n\t\t\t\t\t\treturn gf_bt_report(parser, parser->last_error, \"%s: Unknown node field\", field);\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_bt_check_code(parser, ']');\n\n\t\t\t/*check if we have a child node*/\n\t\t\tif (gf_bt_check_code(parser, '.')) {\n\t\t\t\ts32 apos = pos;\n\t\t\t\tforce_sf = 0;\n\t\t\t\tif (idxNode) {\n\t\t\t\t\tapos = 0;\n\t\t\t\t\tswitch (idxField.fieldType) {\n\t\t\t\t\tcase GF_SG_VRML_SFBOOL:\n\t\t\t\t\t\tif (*(SFBool*)idxField.far_ptr) apos = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase GF_SG_VRML_SFINT32:\n\t\t\t\t\t\tif (*(SFInt32*)idxField.far_ptr >=0) apos = *(SFInt32*)idxField.far_ptr;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase GF_SG_VRML_SFFLOAT:\n\t\t\t\t\t\tif ( (*(SFFloat *)idxField.far_ptr) >=0) apos = (s32) floor( FIX2FLT(*(SFFloat*)idxField.far_ptr) );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase GF_SG_VRML_SFTIME:\n\t\t\t\t\t\tif ( (*(SFTime *)idxField.far_ptr) >=0) apos = (s32) floor( (*(SFTime *)idxField.far_ptr) );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tchildNode = gf_node_list_get_child(*(GF_ChildNodeItem **)targetField.far_ptr, apos);\n\t\t\t\tif (!childNode)\n\t\t\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"Cannot find child node at specified index\");\n\n\t\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\t\tstrcpy(field, str);\n\t\t\t\tparser->last_error = gf_node_get_field_by_name(childNode, field, &childField);\n\t\t\t\tif (parser->last_error)\n\t\t\t\t\treturn gf_bt_report(parser, parser->last_error, \"%s: Unknown node field\", field);\n\t\t\t}\n\t\t}\n\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\tif (strcmp(str, \"BY\"))\n\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"BY expected got %s\", str);\n\n\t\t/*peek the next word*/\n\t\tj = 0;\n\t\twhile (strchr(\" \\n\\t\\0\", parser->line_buffer[parser->line_pos + j])) j++;\n\t\tstr = parser->line_buffer + parser->line_pos + j;\n\t\tj = 0;\n\t\twhile (!strchr(\" .\\0\", str[j])) j++;\n\t\tcsep = str[j];\n\t\tstr[j]=0;\n\t\tstrcpy(field, str);\n\t\tstr[j] = csep;\n\t\tfromNode = gf_bt_peek_node(parser, field);\n\t\tif (fromNode) {\n\t\t\tgf_bt_get_next(parser, 1);\n\n\t\t\tif (!gf_bt_check_code(parser, '.')) {\n\t\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"XREPLACE: '.' expected\");\n\t\t\t}\n\t\t\t/*get source field*/\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tstrcpy(field, str);\n\t\t\tparser->last_error = gf_node_get_field_by_name(fromNode, field, &fromField);\n\t\t\tif (parser->last_error)\n\t\t\t\treturn gf_bt_report(parser, parser->last_error, \"%s: Unknown node field\", field);\n\n\t\t} else {\n\t\t\t/*regular parsing*/\n\t\t}\n\n\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_XREPLACE);\n\t\tbd_set_com_node(com, targetNode);\n\t\tif (fromNode) {\n\t\t\tcom->fromNodeID = gf_node_get_id(fromNode);\n\t\t\tcom->fromFieldIndex = fromField.fieldIndex;\n\t\t}\n\t\tif (idxNode) {\n\t\t\tcom->toNodeID = gf_node_get_id(idxNode);\n\t\t\tcom->toFieldIndex = idxField.fieldIndex;\n\t\t}\n\t\tif (childNode) {\n\t\t\tcom->ChildNodeTag = gf_node_get_tag(childNode);\n\t\t\tif (com->ChildNodeTag==1) {\n\t\t\t\tcom->ChildNodeTag = ((GF_ProtoInstance*)childNode)->proto_interface->ID;\n\t\t\t\tcom->ChildNodeTag = -com->ChildNodeTag ;\n\t\t\t}\n\t\t\tcom->child_field = childField.fieldIndex;\n\t\t}\n\t\tinf = gf_sg_command_field_new(com);\n\t\tinf->fieldIndex = targetField.fieldIndex;\n\t\tinf->pos = pos;\n\t\tif (force_sf) {\n\t\t\tinf->fieldType = gf_sg_vrml_get_sf_type(targetField.fieldType);\n\t\t} else if (childNode) {\n\t\t\tinf->fieldType = childField.fieldType;\n\t\t} else {\n\t\t\tinf->fieldType = targetField.fieldType;\n\t\t}\n\t\tif (!fromNode) {\n\t\t\tswitch (inf->fieldType) {\n\t\t\tcase GF_SG_VRML_SFNODE:\n\t\t\t\tinf->new_node = gf_bt_sf_node(parser, NULL, NULL, NULL);\n\t\t\t\tinf->field_ptr = &inf->new_node;\n\t\t\t\tif (childNode) {\n\t\t\t\t\tif (!gf_bt_check_ndt(parser, &childField, inf->new_node, childNode)) goto err;\n\t\t\t\t} else {\n\t\t\t\t\tif (!gf_bt_check_ndt(parser, &targetField, inf->new_node, targetNode)) goto err;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GF_SG_VRML_MFNODE:\n\t\t\t{\n\t\t\t\tGF_ChildNodeItem *last = NULL;\n\t\t\t\tif (!gf_bt_check_code(parser, '[')) break;\n\t\t\t\tinf->field_ptr = &inf->node_list;\n\t\t\t\twhile (!gf_bt_check_code(parser, ']')) {\n\t\t\t\t\tnewnode = gf_bt_sf_node(parser, NULL, NULL, NULL);\n\t\t\t\t\tif (!newnode) goto err;\n\t\t\t\t\tif (parser->last_error!=GF_OK) goto err;\n\n\t\t\t\t\tif (childNode) {\n\t\t\t\t\t\tif (!gf_bt_check_ndt(parser, &childField, inf->new_node, childNode)) goto err;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (!gf_bt_check_ndt(parser, &targetField, inf->new_node, targetNode)) goto err;\n\t\t\t\t\t}\n\n\t\t\t\t\tgf_node_list_add_child_last(& inf->node_list, newnode, &last);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tinf->field_ptr = gf_sg_vrml_field_pointer_new(inf->fieldType);\n\t\t\t\tinfo.far_ptr = inf->field_ptr;\n\t\t\t\tinfo.fieldType = inf->fieldType;\n\t\t\t\tinfo.name = targetField.name;\n\n\t\t\t\tif (gf_sg_vrml_is_sf_field(inf->fieldType)) {\n\t\t\t\t\tgf_bt_sffield(parser, &info, childNode ? childNode : targetNode);\n\t\t\t\t} else {\n\t\t\t\t\tgf_bt_mffield(parser, &info, childNode ? childNode : targetNode);\n\t\t\t\t}\n\t\t\t\tif (parser->last_error) goto err;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (parser->last_error) goto err;\n\t\tgf_list_add(cmdList, com);\n\t\tparser->cur_com = com;\n\t\treturn parser->last_error;\n\t}\n\n\n\t/*INSERT commands*/\n\tif (!strcmp(str, \"INSERT\") || !strcmp(str, \"APPEND\")) {\n\t\tBool is_append = !strcmp(str, \"APPEND\") ? 1 : 0;\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\tif (!strcmp(str, \"ROUTE\")) {\n\t\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_ROUTE_INSERT);\n\t\t\tgf_bt_parse_route(parser, 0, 1, com);\n\t\t\tif (parser->last_error) goto err;\n\t\t\tgf_list_add(cmdList, com);\n\t\t\tgf_list_add(parser->inserted_routes, com);\n\t\t\tparser->cur_com = com;\n\t\t\treturn GF_OK;\n\t\t}\n\t\tif (strcmp(str, \"AT\") && strcmp(str, \"TO\")) {\n\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, (char*) (is_append ? \"TO expected got %s\" : \"AT expected got %s\"), str);\n\t\t}\n\t\tstr = gf_bt_get_next(parser, 1);\n\t\tstrcpy(field, str);\n\t\tn = gf_bt_peek_node(parser, str);\n\t\tif (!n) {\n\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"%s: Unknown node\", field);\n\t\t}\n\t\tif (!gf_bt_check_code(parser, '.')) {\n\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \". expected\");\n\t\t}\n\t\tstr = gf_bt_get_next(parser, 1);\n\t\tstrcpy(field, str);\n\t\tif (!is_append) {\n\t\t\tif (!gf_bt_check_code(parser, '[')) {\n\t\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"[ expected\");\n\t\t\t}\n\t\t\tgf_bt_parse_int(parser, \"index\", &pos);\n\t\t\tif (!gf_bt_check_code(parser, ']')) {\n\t\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"] expected\");\n\t\t\t}\n\t\t} else {\n\t\t\tif (gf_bt_check_code(parser, '[')) {\n\t\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"[ unexpected in Append command\");\n\t\t\t}\n\t\t\tpos = -1;\n\t\t}\n\t\tgf_node_get_field_by_name(n, field, &info);\n\t\tif (!strcmp(field, \"children\")) {\n\t\t\tnewnode = gf_bt_sf_node(parser, NULL, NULL, NULL);\n\t\t\tif (parser->last_error) goto err;\n\n\t\t\tif (!gf_bt_check_ndt(parser, &info, newnode, n)) goto err;\n\t\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_NODE_INSERT);\n\t\t\tbd_set_com_node(com, n);\n\t\t\tinf = gf_sg_command_field_new(com);\n\t\t\tinf->pos = pos;\n\t\t\tinf->new_node = newnode;\n\t\t\tinf->fieldType = GF_SG_VRML_SFNODE;\n\t\t\tinf->field_ptr = &inf->new_node;\n\t\t\tif (parser->last_error) goto err;\n\t\t\tparser->cur_com = com;\n\t\t\treturn gf_list_add(cmdList, com);\n\t\t}\n\t\tif (gf_sg_vrml_is_sf_field(info.fieldType)) {\n\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"%s: MF type field expected\", info.name);\n\t\t\tgoto err;\n\t\t}\n\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_INDEXED_INSERT);\n\t\tbd_set_com_node(com, n);\n\t\tinf = gf_sg_command_field_new(com);\n\t\tinf->pos = pos;\n\t\tinf->fieldIndex = info.fieldIndex;\n\t\tinf->fieldType = gf_sg_vrml_get_sf_type(info.fieldType);\n\t\tswitch (info.fieldType) {\n\t\tcase GF_SG_VRML_MFNODE:\n\t\t\tinf->new_node = gf_bt_sf_node(parser, NULL, NULL, NULL);\n\t\t\tinf->field_ptr = &inf->new_node;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tinfo.fieldType = inf->fieldType;\n\t\t\tinf->field_ptr = gf_sg_vrml_field_pointer_new(inf->fieldType);\n\t\t\tinfo.far_ptr = inf->field_ptr;\n\t\t\tgf_bt_sffield(parser, &info, n);\n\t\t\tbreak;\n\t\t}\n\t\tif (parser->last_error) goto err;\n\t\tgf_list_add(cmdList, com);\n\t\tparser->cur_com = com;\n\t\treturn parser->last_error;\n\t}\n\t/*DELETE commands*/\n\tif (!strcmp(str, \"DELETE\")) {\n\t\tstr = gf_bt_get_next(parser, 1);\n\t\tif (!strcmp(str, \"ROUTE\")) {\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_ROUTE_DELETE);\n\t\t\tcom->RouteID = gf_bt_get_route(parser, str);\n\t\t\tif (!com->RouteID) {\n\t\t\t\tcom->unres_name = gf_strdup(str);\n\t\t\t\tcom->unresolved = 1;\n\t\t\t\tgf_list_add(parser->unresolved_routes, com);\n\t\t\t}\n\t\t\t/*for bt<->xmt conversions*/\n\t\t\tcom->def_name = gf_strdup(str);\n\t\t\treturn gf_list_add(cmdList, com);\n\t\t}\n\t\tstrcpy(field, str);\n\t\tn = gf_bt_peek_node(parser, str);\n\t\tif (!n) {\n\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"DELETE %s: Unknown Node\", field);\n\t\t}\n\t\tif (!gf_bt_check_code(parser, '.')) {\n\t\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_NODE_DELETE);\n\t\t\tbd_set_com_node(com, n);\n\t\t\treturn gf_list_add(cmdList, com);\n\t\t}\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\tif (gf_node_get_field_by_name(n, str, &info) != GF_OK) {\n\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"%s not a field of node %s\", str, gf_node_get_class_name(n) );\n\t\t}\n\t\tif (gf_bt_check_code(parser, '[')) {\n\t\t\tgf_bt_parse_int(parser, \"index\", &pos);\n\t\t\tif (!gf_bt_check_code(parser, ']'))\n\t\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"[ expected\");\n\t\t}\n\t\tif (gf_sg_vrml_is_sf_field(info.fieldType)) {\n\t\t\tif (info.fieldType == GF_SG_VRML_SFNODE) {\n\t\t\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_FIELD_REPLACE);\n\t\t\t\tbd_set_com_node(com, n);\n\t\t\t\tinf = gf_sg_command_field_new(com);\n\t\t\t\tinf->fieldIndex = info.fieldIndex;\n\t\t\t\tinf->fieldType = info.fieldType;\n\t\t\t\tinf->new_node = NULL;\n\t\t\t\tinf->field_ptr = &inf->new_node;\n\t\t\t\treturn gf_list_add(cmdList, com);\n\t\t\t}\n\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"%s is an SFField - cannot indexed delete\", info.name);\n\t\t}\n\n\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_INDEXED_DELETE);\n\t\tbd_set_com_node(com, n);\n\t\tinf = gf_sg_command_field_new(com);\n\t\tinf->fieldIndex = info.fieldIndex;\n\t\tinf->fieldType = info.fieldType;\n\t\tinf->pos = pos;\n\t\treturn gf_list_add(cmdList, com);\n\t}\n\t/*Extended BIFS commands*/\n\n\t/*GlobalQP commands*/\n\tif (!strcmp(str, \"GLOBALQP\")) {\n\t\tnewnode = gf_bt_sf_node(parser, NULL, NULL, NULL);\n\t\tif (newnode && (newnode->sgprivate->tag != TAG_MPEG4_QuantizationParameter)) {\n\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"Only QuantizationParameter node allowed in GLOBALQP\");\n\t\t\tgf_node_unregister(newnode, NULL);\n\t\t\treturn parser->last_error;\n\t\t}\n\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_GLOBAL_QUANTIZER);\n\t\tcom->node = NULL;\n\t\tinf = gf_sg_command_field_new(com);\n\t\tinf->new_node = newnode;\n\t\tinf->field_ptr = &inf->new_node;\n\t\tinf->fieldType = GF_SG_VRML_SFNODE;\n\t\treturn gf_list_add(cmdList, com);\n\t}\n\n\t/*MultipleReplace commands*/\n\tif (!strcmp(str, \"MULTIPLEREPLACE\")) {\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\tstrcpy(field, str);\n\t\tn = gf_bt_peek_node(parser, str);\n\t\tif (!n) {\n\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"%s: Unknown node\", field);\n\t\t}\n\t\tif (!gf_bt_check_code(parser, '{')) {\n\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"{ expected\");\n\t\t}\n\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_MULTIPLE_REPLACE);\n\t\tbd_set_com_node(com, n);\n\n\t\twhile (!gf_bt_check_code(parser, '}')) {\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tparser->last_error = gf_node_get_field_by_name(n, str, &info);\n\t\t\tif (parser->last_error) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"%s: Unknown node field\", str);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tinf = gf_sg_command_field_new(com);\n\t\t\tinf->fieldIndex = info.fieldIndex;\n\t\t\tinf->fieldType = info.fieldType;\n\t\t\tinf->pos = -1;\n\n\t\t\tswitch (info.fieldType) {\n\t\t\tcase GF_SG_VRML_SFNODE:\n\t\t\t\tinf->new_node = gf_bt_sf_node(parser, NULL, NULL, NULL);\n\t\t\t\tif (parser->last_error) goto err;\n\t\t\t\tif (!gf_bt_check_ndt(parser, &info, inf->new_node, n)) goto err;\n\t\t\t\tinf->field_ptr = &inf->new_node;\n\t\t\t\tbreak;\n\t\t\tcase GF_SG_VRML_MFNODE:\n\t\t\t{\n\t\t\t\tGF_ChildNodeItem *last = NULL;\n\t\t\t\tif (!gf_bt_check_code(parser, '[')) {\n\t\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"[ expected\");\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tinfo.far_ptr = inf->field_ptr = &inf->node_list;\n\t\t\t\twhile (!gf_bt_check_code(parser, ']')) {\n\t\t\t\t\tnewnode = gf_bt_sf_node(parser, NULL, NULL, NULL);\n\t\t\t\t\tif (parser->last_error!=GF_OK) goto err;\n\t\t\t\t\tif (!gf_bt_check_ndt(parser, &info, newnode, n)) goto err;\n\t\t\t\t\tgf_node_list_add_child_last( & inf->node_list, newnode, &last);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tinfo.far_ptr = inf->field_ptr = gf_sg_vrml_field_pointer_new(inf->fieldType);\n\t\t\t\tif (gf_sg_vrml_is_sf_field(info.fieldType)) {\n\t\t\t\t\tgf_bt_sffield(parser, &info, n);\n\t\t\t\t} else {\n\t\t\t\t\tgf_bt_mffield(parser, &info, n);\n\t\t\t\t}\n\t\t\t\tif (parser->last_error) goto err;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tparser->cur_com = com;\n\t\treturn gf_list_add(cmdList, com);\n\t}\n\n\t/*MultipleIndexReplace commands*/\n\tif (!strcmp(str, \"MULTIPLEINDREPLACE\")) {\n\t\tstr = gf_bt_get_next(parser, 1);\n\t\tstrcpy(field, str);\n\t\tn = gf_bt_peek_node(parser, str);\n\t\tif (!n) {\n\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"%s: Unknown node\", field);\n\t\t}\n\t\tif (!gf_bt_check_code(parser, '.')) {\n\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \". expected\");\n\t\t}\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\tparser->last_error = gf_node_get_field_by_name(n, str, &info);\n\t\tif (parser->last_error) {\n\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"%s: Unknown field\", info.name);\n\t\t}\n\t\tif (gf_sg_vrml_is_sf_field(info.fieldType)) {\n\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"Only MF field allowed\");\n\t\t}\n\t\tif (!gf_bt_check_code(parser, '[')) {\n\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"[ expected\");\n\t\t}\n\n\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_MULTIPLE_INDEXED_REPLACE);\n\t\tbd_set_com_node(com, n);\n\t\tinfo.fieldType = gf_sg_vrml_get_sf_type(info.fieldType);\n\n\t\twhile (!gf_bt_check_code(parser, ']')) {\n\t\t\tpos=0;\n\t\t\tif (gf_bt_parse_int(parser, \"position\", (SFInt32 *)&pos)) goto err;\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tif (strcmp(str, \"BY\")) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"BY expected\");\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tinf = gf_sg_command_field_new(com);\n\t\t\tinf->fieldIndex = info.fieldIndex;\n\t\t\tinf->fieldType = info.fieldType;\n\t\t\tinf->pos = pos;\n\t\t\tif (inf->fieldType==GF_SG_VRML_SFNODE) {\n\t\t\t\tinfo.far_ptr = inf->field_ptr = &inf->new_node;\n\t\t\t\tinf->new_node = gf_bt_sf_node(parser, NULL, NULL, NULL);\n\t\t\t\tif (parser->last_error) goto err;\n\t\t\t\tif (!gf_bt_check_ndt(parser, &info, inf->new_node, n)) goto err;\n\t\t\t\tinf->field_ptr = &inf->new_node;\n\t\t\t} else {\n\t\t\t\tinfo.far_ptr = inf->field_ptr = gf_sg_vrml_field_pointer_new(inf->fieldType);\n\t\t\t\tgf_bt_sffield(parser, &info, n);\n\t\t\t\tif (parser->last_error) goto err;\n\t\t\t}\n\t\t}\n\t\tparser->cur_com = com;\n\t\treturn gf_list_add(cmdList, com);\n\t}\n\n\tif (!strcmp(str, \"XDELETE\")) {\n\t\tstr = gf_bt_get_next(parser, 1);\n\t\tstrcpy(field, str);\n\t\tn = gf_bt_peek_node(parser, str);\n\t\tif (!n) {\n\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"%s: Unknown Node\", field);\n\t\t}\n\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_NODE_DELETE_EX);\n\t\tbd_set_com_node(com, n);\n\t\treturn gf_list_add(cmdList, com);\n\t}\n\n\tif (!strcmp(str, \"INSERTPROTO\")) {\n\t\tif (!gf_bt_check_code(parser, '[')) {\n\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"[ expected\");\n\t\t}\n\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_PROTO_INSERT);\n\t\twhile (!gf_bt_check_code(parser, ']')) {\n\t\t\tparser->last_error = gf_bt_parse_proto(parser, NULL, com->new_proto_list);\n\t\t\tif (parser->last_error) goto err;\n\t\t}\n\t\tgf_list_add(cmdList, com);\n\t\treturn GF_OK;\n\t}\n\tif (!strcmp(str, \"DELETEPROTO\")) {\n\t\tif (!gf_bt_check_code(parser, '[')) {\n\t\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_PROTO_DELETE_ALL);\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tif (strcmp(str, \"ALL\")) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"ALL expected\");\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\treturn gf_list_add(cmdList, com);\n\t\t}\n\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_PROTO_DELETE);\n\t\twhile (!gf_bt_check_code(parser, ']')) {\n\t\t\tGF_Proto *proto;\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tproto = gf_sg_find_proto(parser->load->scene_graph, 0, str);\n\t\t\tif (!proto) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"%s: Unknown proto\", str);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tcom->del_proto_list = (u32*)gf_realloc(com->del_proto_list, sizeof(u32)*(com->del_proto_list_size+1));\n\t\t\tcom->del_proto_list[com->del_proto_list_size] = proto->ID;\n\t\t\tcom->del_proto_list_size++;\n\t\t}\n\t\tgf_list_add(cmdList, com);\n\t\treturn GF_OK;\n\t}\n\treturn gf_bt_report(parser, GF_BAD_PARAM, \"%s: Unknown command syntax, str\");\n\nerr:\n\tif (com) gf_sg_command_del(com);\n\treturn parser->last_error;\n}\n\nGF_Descriptor *gf_bt_parse_descriptor(GF_BTParser *parser, char *name);\n\n#ifndef GPAC_MINIMAL_ODF\nGF_IPMPX_Data *gf_bt_parse_ipmpx(GF_BTParser *parser, char *name)\n{\n\tchar *str, field[500];\n\tGF_IPMPX_Data *desc, *subdesc;\n\tGF_Descriptor *oddesc;\n\tGF_Err e;\n\tu32 type;\n\tu8 tag;\n\tif (name) {\n\t\tstr = name;\n\t} else {\n\t\tstr = gf_bt_get_next(parser, 0);\n\t}\n\ttag = gf_ipmpx_get_tag(str);\n\tif (!tag) {\n\t\tgf_bt_report(parser, GF_BAD_PARAM, \"%s: Unknown IPMPX Data\", str);\n\t\treturn NULL;\n\t}\n\tdesc = gf_ipmpx_data_new(tag);\n\n\tif (!desc) return NULL;\n\tif (!gf_bt_check_code(parser, '{')) return desc;\n\n\twhile (1) {\n\t\t/*done*/\n\t\tif (gf_bt_check_code(parser, '}')) break;\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\tstrcpy(field, str);\n\t\ttype = gf_ipmpx_get_field_type(desc, str);\n\t\tswitch (type) {\n\t\t/*single descriptor*/\n\t\tcase GF_ODF_FT_OD:\n\t\t\tassert(desc->tag==GF_IPMPX_CONNECT_TOOL_TAG);\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\toddesc = gf_bt_parse_descriptor(parser, str);\n\t\t\tif (!oddesc) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"Unknown desc %s in field %s\", str, field);\n\t\t\t\tgf_ipmpx_data_del(desc);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tassert(oddesc->tag==GF_ODF_IPMP_TAG);\n\t\t\t((GF_IPMPX_ConnectTool *)desc)->toolDescriptor = (GF_IPMP_Descriptor *)oddesc;\n\t\t\tbreak;\n\t\t/*descriptor list*/\n\t\tcase GF_ODF_FT_OD_LIST:\n\t\t\tassert(desc->tag==GF_IPMPX_GET_TOOLS_RESPONSE_TAG);\n\t\t\tif (gf_bt_check_code(parser, '[')) {\n\t\t\t\twhile (!gf_bt_check_code(parser, ']')) {\n\t\t\t\t\tGF_Descriptor *ipmp_t = gf_bt_parse_descriptor(parser, NULL);\n\t\t\t\t\tif (!ipmp_t) {\n\t\t\t\t\t\tgf_ipmpx_data_del(desc);\n\t\t\t\t\t\tparser->last_error = GF_BAD_PARAM;\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\t\t\t\t\tassert(ipmp_t->tag==GF_ODF_IPMP_TOOL_TAG);\n\t\t\t\t\tgf_list_add( ((GF_IPMPX_GetToolsResponse *)desc)->ipmp_tools, ipmp_t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\t/*IPMPX ByteArray list*/\n\t\tcase GF_ODF_FT_IPMPX_BA_LIST:\n\t\t\tif (gf_bt_check_code(parser, '[')) {\n\t\t\t\twhile (!gf_bt_check_code(parser, ']')) {\n\t\t\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\t\t\tif (!str) continue;\n\t\t\t\t\tif (gf_ipmpx_set_byte_array(desc, field, str) != GF_OK) {\n\t\t\t\t\t\tgf_bt_report(parser, GF_OK, \"Invalid ipmpx %s in field %s - skipping\", str, field);\n\t\t\t\t\t}\n\t\t\t\t\tgf_bt_check_code(parser, ',');\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t/*IPMPX ByteArray: check if declared as sub-data or not*/\n\t\tcase GF_ODF_FT_IPMPX_BA:\n\t\t\tstr = NULL;\n\t\t\tif (gf_bt_check_code(parser, '{')) {\n\t\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\t\tif (stricmp(str, \"array\")) {\n\t\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"IPMP ByteArray syntax is %s { array \\\"...\\\" } or %s \\\"....\\\"\\n\", field, field);\n\t\t\t\t\tgf_ipmpx_data_del(desc);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\t\tgf_bt_check_code(parser, '}');\n\t\t\t} else {\n\t\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\t}\n\t\t\te = gf_ipmpx_set_byte_array(desc, field, str);\n\t\t\tif (e) {\n\t\t\t\tgf_bt_report(parser, e, \"Error assigning IPMP ByteArray %s\\n\", field);\n\t\t\t\tgf_ipmpx_data_del(desc);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tbreak;\n\t\t/*IPMPX Data list*/\n\t\tcase GF_ODF_FT_IPMPX_LIST:\n\t\t\tif (gf_bt_check_code(parser, '[')) {\n\t\t\t\twhile (!gf_bt_check_code(parser, ']')) {\n\t\t\t\t\tsubdesc = gf_bt_parse_ipmpx(parser, NULL);\n\t\t\t\t\tif (!subdesc) {\n\t\t\t\t\t\tgf_ipmpx_data_del(desc);\n\t\t\t\t\t\tparser->last_error = GF_BAD_PARAM;\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\t\t\t\t\tif (gf_ipmpx_set_sub_data(desc, field, subdesc) != GF_OK) {\n\t\t\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"Invalid ipmpx %s in field %s - skipping\", str, field);\n\t\t\t\t\t\tgf_ipmpx_data_del(subdesc);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t/*regular IPMPX Data*/\n\t\tcase GF_ODF_FT_IPMPX:\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tsubdesc = gf_bt_parse_ipmpx(parser, str);\n\t\t\tif (!subdesc) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"Unknown ipmpx %s in field %s\", str, field);\n\t\t\t\tgf_ipmpx_data_del(desc);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (gf_ipmpx_set_sub_data(desc, field, subdesc) != GF_OK) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"Invalid ipmpx in field %s - skipping\", field);\n\t\t\t\tgf_ipmpx_data_del(subdesc);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tparser->last_error = gf_ipmpx_set_field(desc, field, str);\n\n\t\t\tif (parser->last_error) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"Invalid value %s in field %s\", str, field);\n\t\t\t\tgf_ipmpx_data_del(desc);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn desc;\n}\n#endif\n\nstatic void gf_bt_add_desc(GF_BTParser *parser, GF_Descriptor *par, GF_Descriptor *child, char *fieldName)\n{\n\tGF_Err e = gf_odf_desc_add_desc(par, child);\n\tif (e) {\n\t\tgf_bt_report(parser, GF_OK, \"Invalid child descriptor in field %s - skipping\", fieldName);\n\t\tgf_odf_desc_del(child);\n\t}\n}\n\nGF_Descriptor *gf_bt_parse_descriptor(GF_BTParser *parser, char *name)\n{\n\tchar *str, field[500];\n\tGF_Descriptor *desc, *subdesc;\n\tu32 type;\n\tu8 tag;\n\tif (name) {\n\t\tstr = name;\n\t} else {\n\t\tstr = gf_bt_get_next(parser, 0);\n\t}\n\ttag = gf_odf_get_tag_by_name(str);\n\tif (!tag) {\n\t\tgf_bt_report(parser, GF_BAD_PARAM, \"%s: Unknown descriptor\", str);\n\t\treturn NULL;\n\t}\n\tdesc = gf_odf_desc_new(tag);\n\n\tif (!desc) return NULL;\n\tif (!gf_bt_check_code(parser, '{')) return desc;\n\n\twhile (1) {\n\t\tBool is_anim_mask = 0;\n\t\t/*done*/\n\t\tif (gf_bt_check_code(parser, '}')) break;\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\tstrcpy(field, str);\n\n\t\tif ((tag==GF_ODF_BIFS_CFG_TAG) && !strcmp(field, \"animationMask\")) {\n\t\t\tgf_bt_get_next(parser, 0);\n\t\t\tif (gf_bt_check_code(parser, '{')) is_anim_mask = 1;\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tstrcpy(field, str);\n\t\t}\n\n\t\ttype = gf_odf_get_field_type(desc, str);\n\t\tswitch (type) {\n#ifndef GPAC_MINIMAL_ODF\n\t\t/*IPMPX list*/\n\t\tcase GF_ODF_FT_IPMPX_LIST:\n\t\t\tif(desc->tag!=GF_ODF_IPMP_TAG) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"IPMPX_Data list only allowed in GF_IPMP_Descriptor\");\n\t\t\t\tgf_odf_desc_del(desc);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (gf_bt_check_code(parser, '[')) {\n\t\t\t\twhile (!gf_bt_check_code(parser, ']')) {\n\t\t\t\t\tGF_IPMPX_Data *ipmpx = gf_bt_parse_ipmpx(parser, NULL);\n\t\t\t\t\tif (!ipmpx) {\n\t\t\t\t\t\tgf_odf_desc_del(desc);\n\t\t\t\t\t\tparser->last_error = GF_BAD_PARAM;\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\t\t\t\t\tgf_list_add( ((GF_IPMP_Descriptor *)desc)->ipmpx_data, ipmpx);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t/*IPMPX*/\n\t\tcase GF_ODF_FT_IPMPX:\n\t\t\tif(desc->tag!=GF_ODF_IPMP_TOOL_TAG) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"IPMPX_Data only allowed in GF_IPMP_Tool\");\n\t\t\t\tgf_odf_desc_del(desc);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (gf_bt_check_code(parser, '[')) {\n\t\t\t\twhile (!gf_bt_check_code(parser, ']')) {\n\t\t\t\t\tGF_IPMPX_Data *ipmpx = gf_bt_parse_ipmpx(parser, NULL);\n\t\t\t\t\tif (!ipmpx) {\n\t\t\t\t\t\tgf_odf_desc_del(desc);\n\t\t\t\t\t\tparser->last_error = GF_BAD_PARAM;\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\t\t\t\t\tif (ipmpx->tag==GF_IPMPX_PARAMETRIC_DESCRIPTION_TAG) {\n\t\t\t\t\t\tGF_IPMP_Tool *it = (GF_IPMP_Tool *)desc;\n\t\t\t\t\t\tif (it->toolParamDesc) gf_ipmpx_data_del((GF_IPMPX_Data *)it->toolParamDesc);\n\t\t\t\t\t\tit->toolParamDesc = (GF_IPMPX_ParametricDescription*)ipmpx;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgf_bt_report(parser, GF_OK, \"Only ToolParametricDescription allowed in GF_IPMP_Tool - skipping\");\n\t\t\t\t\t\tgf_ipmpx_data_del(ipmpx);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n#endif\n\n\t\t/*descriptor list*/\n\t\tcase GF_ODF_FT_OD_LIST:\n\t\t\tif (gf_bt_check_code(parser, '[')) {\n\t\t\t\twhile (!gf_bt_check_code(parser, ']')) {\n\t\t\t\t\tsubdesc = gf_bt_parse_descriptor(parser, NULL);\n\t\t\t\t\tif (!subdesc) {\n\t\t\t\t\t\tgf_odf_desc_del(desc);\n\t\t\t\t\t\tparser->last_error = GF_BAD_PARAM;\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\t\t\t\t\tgf_bt_add_desc(parser, desc, subdesc, field);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (is_anim_mask)\n\t\t\t\tgf_bt_check_code(parser, '}');\n\t\t\tbreak;\n\t\t/*single descriptor*/\n\t\tcase GF_ODF_FT_OD:\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tsubdesc = gf_bt_parse_descriptor(parser, str);\n\t\t\tif (!subdesc) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"Unknown desc %s in field %s\", str, field);\n\t\t\t\tgf_odf_desc_del(desc);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tgf_bt_add_desc(parser, desc, subdesc, field);\n\t\t\tbreak;\n\t\t/*regular field*/\n\t\tdefault:\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tparser->last_error = gf_odf_set_field(desc, field, str);\n\n\t\t\tif (parser->last_error) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"Invalid value %s in field %s\", str, field);\n\t\t\t\tgf_odf_desc_del(desc);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (desc->tag == GF_ODF_BIFS_CFG_TAG) {\n\t\tGF_BIFSConfig *bcfg = (GF_BIFSConfig *)desc;\n\t\tif (!parser->load->ctx->scene_width) {\n\t\t\tparser->load->ctx->scene_width = bcfg->pixelWidth;\n\t\t\tparser->load->ctx->scene_height = bcfg->pixelHeight;\n\t\t\tparser->load->ctx->is_pixel_metrics = bcfg->pixelMetrics;\n\t\t}\n\n\t\t/*for bt->xmt*/\n\t\tif (!bcfg->version) bcfg->version = 1;\n\t}\n\telse if (desc->tag==GF_ODF_ESD_TAG) {\n\t\tGF_ESD *esd  =(GF_ESD*)desc;\n\t\tif (esd->decoderConfig) {\n\t\t\tGF_StreamContext *sc=NULL;\n\t\t\tGF_MuxInfo *mux;\n\t\t\t/*watchout for default BIFS stream*/\n\t\t\tif (parser->bifs_es && !parser->base_bifs_id && (esd->decoderConfig->streamType==GF_STREAM_SCENE)) {\n\t\t\t\tparser->bifs_es->ESID = parser->base_bifs_id = esd->ESID;\n\t\t\t\tparser->bifs_es->timeScale = (esd->slConfig && esd->slConfig->timestampResolution) ? esd->slConfig->timestampResolution : 1000;\n\t\t\t\tsc = parser->bifs_es;\n\t\t\t} else {\n\t\t\t\tsc = gf_sm_stream_new(parser->load->ctx, esd->ESID, esd->decoderConfig->streamType, esd->decoderConfig->objectTypeIndication);\n\t\t\t\t/*set default timescale for systems tracks (ignored for other)*/\n\t\t\t\tif (sc) sc->timeScale = (esd->slConfig && esd->slConfig->timestampResolution) ? esd->slConfig->timestampResolution : 1000;\n\t\t\t\t/*assign base OD*/\n\t\t\t\tif (!parser->base_od_id && (esd->decoderConfig->streamType==GF_STREAM_OD)) parser->base_od_id = esd->ESID;\n\t\t\t}\n\t\t\t/*assign broadcast parameter tools*/\n\t\t\tmux = gf_sm_get_mux_info(esd);\n\t\t\tif (sc && mux) {\n\t\t\t\tsc->aggregate_on_esid = mux->aggregate_on_esid;\n\t\t\t\tif (!mux->carousel_period_plus_one) sc->carousel_period  = (u32) -1;\n\t\t\t\telse sc->carousel_period = mux->carousel_period_plus_one - 1;\n\t\t\t}\n\t\t}\n\t} else if (desc->tag==GF_ODF_MUXINFO_TAG) {\n\t\tGF_MuxInfo *mi = (GF_MuxInfo *)desc;\n\t\tif (! mi->src_url) {\n\t\t\tmi->src_url = gf_strdup(parser->load->src_url ? parser->load->src_url : parser->load->fileName);\n\t\t}\n\t}\n\treturn desc;\n}\n\nvoid gf_bt_parse_od_command(GF_BTParser *parser, char *name)\n{\n\tu32 val=0;\n\tchar *str;\n\n\tif (!strcmp(name, \"UPDATE\")) {\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\t/*OD update*/\n\t\tif (!strcmp(str, \"OD\")) {\n\t\t\tGF_ODUpdate *odU;\n\t\t\tif (!gf_bt_check_code(parser, '[')) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"[ expected\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\todU = (GF_ODUpdate *) gf_odf_com_new(GF_ODF_OD_UPDATE_TAG);\n\t\t\tgf_list_add(parser->od_au->commands, odU);\n\t\t\twhile (!parser->done) {\n\t\t\t\tGF_Descriptor *desc;\n\t\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\t\tif (gf_bt_check_code(parser, ']')) break;\n\t\t\t\tif (strcmp(str, \"ObjectDescriptor\") && strcmp(str, \"InitialObjectDescriptor\")) {\n\t\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"Object Descriptor expected got %s\", str);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdesc = gf_bt_parse_descriptor(parser, str);\n\t\t\t\tif (!desc) break;\n\t\t\t\tgf_list_add(odU->objectDescriptors, desc);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t/*ESD update*/\n\t\tif (!strcmp(str, \"ESD\")) {\n\t\t\tGF_ESDUpdate *esdU;\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tif (strcmp(str, \"IN\")) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"IN expected got %s\", str);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tesdU = (GF_ESDUpdate *) gf_odf_com_new(GF_ODF_ESD_UPDATE_TAG);\n\t\t\tparser->last_error = gf_bt_parse_int(parser, \"OD_ID\", (SFInt32*)&val);\n\t\t\tif (parser->last_error) return;\n\t\t\tesdU->ODID = val;\n\t\t\tgf_list_add(parser->od_au->commands, esdU);\n\n\t\t\tif (!gf_bt_check_code(parser, '[')) {\n\t\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\t\tif (strcmp(str, \"esDescr\")) {\n\t\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"esDescr expected got %s\", str);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (!gf_bt_check_code(parser, '[')) {\n\t\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"[ expected\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\twhile (!parser->done) {\n\t\t\t\tGF_Descriptor *desc;\n\t\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\t\tif (gf_bt_check_code(parser, ']')) break;\n\t\t\t\tif (strcmp(str, \"ES_Descriptor\")) {\n\t\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"ES_Descriptor expected got %s\", str);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdesc = gf_bt_parse_descriptor(parser, str);\n\t\t\t\tif (!desc) break;\n\t\t\t\tgf_list_add(esdU->ESDescriptors, desc);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t/*IPMP descriptor update*/\n\t\tif (!strcmp(str, \"IPMPD\") || !strcmp(str, \"IPMPDX\")) {\n\t\t\tGF_IPMPUpdate *ipU;\n\t\t\tif (!gf_bt_check_code(parser, '[')) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"[ expected\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tipU = (GF_IPMPUpdate *) gf_odf_com_new(GF_ODF_IPMP_UPDATE_TAG);\n\t\t\tgf_list_add(parser->od_au->commands, ipU);\n\t\t\twhile (!parser->done) {\n\t\t\t\tGF_Descriptor *desc;\n\t\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\t\tif (gf_bt_check_code(parser, ']')) break;\n\t\t\t\tif (strcmp(str, \"IPMP_Descriptor\")) {\n\t\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"IPMP_Descriptor expected got %s\", str);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdesc = gf_bt_parse_descriptor(parser, str);\n\t\t\t\tif (!desc) break;\n\t\t\t\tgf_list_add(ipU->IPMPDescList, desc);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tgf_bt_report(parser, GF_BAD_PARAM, \"unknown OD command\", str);\n\t\treturn;\n\t}\n\tif (!strcmp(name, \"REMOVE\")) {\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\t/*OD remove*/\n\t\tif (!strcmp(str, \"OD\")) {\n\t\t\tGF_ODRemove *odR;\n\t\t\tif (!gf_bt_check_code(parser, '[')) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"[ expected\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\todR = (GF_ODRemove *) gf_odf_com_new(GF_ODF_OD_REMOVE_TAG);\n\t\t\tgf_list_add(parser->od_au->commands, odR);\n\t\t\twhile (!parser->done) {\n\t\t\t\tu32 id;\n\t\t\t\tif (gf_bt_check_code(parser, ']')) break;\n\t\t\t\tgf_bt_parse_int(parser, \"ODID\", (SFInt32*)&id);\n\t\t\t\tif (parser->last_error) return;\n\t\t\t\todR->OD_ID = (u16*)gf_realloc(odR->OD_ID, sizeof(u16) * (odR->NbODs+1));\n\t\t\t\todR->OD_ID[odR->NbODs] = id;\n\t\t\t\todR->NbODs++;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t/*ESD remove*/\n\t\tif (!strcmp(str, \"ESD\")) {\n\t\t\tu32 odid;\n\t\t\tGF_ESDRemove *esdR;\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tif (strcmp(str, \"FROM\")) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"FROM expected got %s\", str);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tgf_bt_parse_int(parser, \"ODID\", (SFInt32*)&odid);\n\t\t\tif (parser->last_error) return;\n\n\t\t\tif (!gf_bt_check_code(parser, '[')) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"[ expected\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tesdR = (GF_ESDRemove *) gf_odf_com_new(GF_ODF_ESD_REMOVE_TAG);\n\t\t\tesdR->ODID = odid;\n\t\t\tgf_list_add(parser->od_au->commands, esdR);\n\t\t\twhile (!parser->done) {\n\t\t\t\tu32 id;\n\t\t\t\tif (gf_bt_check_code(parser, ']')) break;\n\t\t\t\tgf_bt_parse_int(parser, \"ES_ID\", (SFInt32*)&id);\n\t\t\t\tif (parser->last_error) return;\n\t\t\t\tesdR->ES_ID = (u16*)gf_realloc(esdR->ES_ID, sizeof(u16) * (esdR->NbESDs+1));\n\t\t\t\tesdR->ES_ID[esdR->NbESDs] = id;\n\t\t\t\tesdR->NbESDs++;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tgf_bt_report(parser, GF_BAD_PARAM, \"%s: Unknown OD command\", str);\n\t\treturn;\n\t}\n}\n\n\n\nGF_Err gf_bt_loader_run_intern(GF_BTParser *parser, GF_Command *init_com, Bool initial_run)\n{\n\tchar *str;\n\tGF_Node *node, *vrml_root_node;\n\tBool force_new_com;\n\tGF_Route *r;\n\tBool has_id;\n\tchar szDEFName[1000];\n\n\tvrml_root_node = NULL;\n\thas_id = 0;\n\n\tif (init_com)\n\t\tparser->in_com = 0 ;\n\n\tparser->cur_com = init_com;\n\n\tforce_new_com = (parser->load->flags & GF_SM_LOAD_CONTEXT_READY) ? 1 : 0;\n\n\n\t/*create a default root node for all VRML nodes*/\n\tif (parser->is_wrl && !parser->top_nodes) {\n\t\tif (initial_run ) {\n#ifndef GPAC_DISABLE_X3D\n\t\t\tvrml_root_node = gf_node_new(parser->load->scene_graph, (parser->load->flags & GF_SM_LOAD_MPEG4_STRICT) ? TAG_MPEG4_Group : TAG_X3D_Group);\n#else\n\t\t\tvrml_root_node = gf_node_new(parser->load->scene_graph, TAG_MPEG4_Group);\n#endif\n\t\t\tgf_node_register(vrml_root_node, NULL);\n\t\t\tgf_node_init(vrml_root_node);\n\t\t\tgf_sg_set_root_node(parser->load->scene_graph, vrml_root_node);\n\t\t} else {\n\t\t\tvrml_root_node = gf_sg_get_root_node(parser->load->scene_graph);\n\t\t}\n\t}\n\n\tif (!parser->in_com)\n\t\tparser->stream_id = parser->load->force_es_id;\n\n\t/*parse all top-level items*/\n\twhile (!parser->last_error) {\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\tif (parser->done) break;\n\n\t\t/*X3D specific things (ignored for now)*/\n\t\tif (!strcmp(str, \"PROFILE\")) gf_bt_force_line(parser);\n\t\telse if (!strcmp(str, \"COMPONENT\")) gf_bt_force_line(parser);\n\t\telse if (!strcmp(str, \"META\")) gf_bt_force_line(parser);\n\t\telse if (!strcmp(str, \"IMPORT\") || !strcmp(str, \"EXPORT\")) {\n\t\t\tgf_bt_report(parser, GF_NOT_SUPPORTED, \"X3D IMPORT/EXPORT not implemented\");\n\t\t\tbreak;\n\t\t}\n\n\t\t/*IOD*/\n\t\telse if (!strcmp(str, \"InitialObjectDescriptor\") || !strcmp(str, \"ObjectDescriptor\")) {\n\t\t\tparser->load->ctx->root_od = (GF_ObjectDescriptor *) gf_bt_parse_descriptor(parser, str);\n\t\t}\n\t\t/*explicit command*/\n\t\telse if (!strcmp(str, \"AT\") || !strcmp(str, \"RAP\")) {\n\t\t\tparser->au_is_rap = 0;\n\t\t\tif (!strcmp(str, \"RAP\")) {\n\t\t\t\tparser->au_is_rap = 1;\n\t\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\t\tif (strcmp(str, \"AT\")) {\n\t\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"AT expected got %s\", str);\n\t\t\t\t\tparser->last_error = GF_BAD_PARAM;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tforce_new_com = 0;\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tif (str[0] == 'D') {\n\t\t\t\tparser->au_time += atoi(&str[1]);\n\t\t\t} else {\n\t\t\t\tif (sscanf(str, \"%u\", &parser->au_time) != 1) {\n\t\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"Number expected got %s\", str);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (parser->last_error) break;\n\t\t\t/*reset all contexts*/\n\t\t\tif (parser->od_au && (parser->od_au->timing != parser->au_time)) parser->od_au = NULL;\n\t\t\tif (parser->bifs_au && (parser->bifs_au->timing != parser->au_time)) {\n\t\t\t\tgf_bt_check_unresolved_nodes(parser);\n\t\t\t\tparser->bifs_au = NULL;\n\t\t\t}\n\n\t\t\tparser->stream_id = 0;\n\t\t\t/*fix for mp4tool bt which doesn't support RAP signaling: assume the first AU\n\t\t\tis always RAP*/\n\t\t\tif (!parser->au_time) parser->au_is_rap = 1;\n\n\t\t\tparser->in_com = 1;\n\n\t\t\tif (!gf_bt_check_code(parser, '{')) {\n\t\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\t\tif (!strcmp(str, \"IN\")) {\n\t\t\t\t\tgf_bt_parse_int(parser, \"IN\", (SFInt32*)&parser->stream_id);\n\t\t\t\t\tif (parser->last_error) break;\n\t\t\t\t}\n\t\t\t\tif (!gf_bt_check_code(parser, '{')) {\n\t\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"{ expected\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*done loading init frame*/\n\t\t\tif (init_com && parser->au_time) break;\n\t\t}\n\t\telse if (!strcmp(str, \"PROTO\") || !strcmp(str, \"EXTERNPROTO\")) {\n\t\t\tgf_bt_parse_proto(parser, str, init_com ? init_com->new_proto_list : NULL);\n\t\t}\n\t\t/*compatibility for old bt (mp4tool) in ProtoLibs*/\n\t\telse if (!strcmp(str, \"NULL\")) {\n\t\t}\n\t\telse if (!strcmp(str, \"DEF\")) {\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tstrcpy(szDEFName, str);\n\t\t\thas_id = 1;\n\t\t}\n\t\telse if (!strcmp(str, \"ROUTE\")) {\n\t\t\tGF_Command *com = NULL;\n\t\t\tif (!parser->top_nodes && parser->bifs_au && !parser->is_wrl) {\n\t\t\t\t/*if doing a scene replace, we need route insert stuff*/\n\t\t\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_ROUTE_INSERT);\n\t\t\t\tgf_list_add(parser->bifs_au->commands, com);\n\t\t\t\tgf_list_add(parser->inserted_routes, com);\n\t\t\t}\n\n\t\t\tr = gf_bt_parse_route(parser, 1, 0, com);\n\t\t\tif (has_id) {\n\t\t\t\tu32 rID = gf_bt_get_route(parser, szDEFName);\n\t\t\t\tif (!rID) rID = gf_bt_get_next_route_id(parser);\n\t\t\t\tif (com) {\n\t\t\t\t\tcom->RouteID = rID;\n\t\t\t\t\tcom->def_name = gf_strdup(szDEFName);\n\t\t\t\t\tgf_sg_set_max_defined_route_id(parser->load->scene_graph, rID);\n\t\t\t\t} else if (r) {\n\t\t\t\t\tgf_sg_route_set_id(r, rID);\n\t\t\t\t\tgf_sg_route_set_name(r, szDEFName);\n\t\t\t\t}\n\t\t\t\thas_id = 0;\n\t\t\t}\n\t\t}\n\t\t/*OD commands*/\n\t\telse if (!strcmp(str, \"UPDATE\") || !strcmp(str, \"REMOVE\")) {\n\t\t\tBool is_base_stream = parser->stream_id ? 0 : 1;\n\t\t\tif (!parser->stream_id || parser->stream_id==parser->bifs_es->ESID) parser->stream_id = parser->base_od_id;\n\n\t\t\tif (parser->od_es && (parser->od_es->ESID != parser->stream_id)) {\n\t\t\t\tGF_StreamContext *prev = parser->od_es;\n\t\t\t\tparser->od_es = gf_sm_stream_new(parser->load->ctx, (u16) parser->stream_id, GF_STREAM_OD, GF_CODECID_OD_V1);\n\t\t\t\t/*force new AU if stream changed*/\n\t\t\t\tif (parser->od_es != prev) {\n\t\t\t\t\tparser->bifs_au = NULL;\n\t\t\t\t\tparser->od_au = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!parser->od_es) parser->od_es = gf_sm_stream_new(parser->load->ctx, (u16) parser->stream_id, GF_STREAM_OD, GF_CODECID_OD_V1);\n\t\t\tif (!parser->od_au) parser->od_au = gf_sm_stream_au_new(parser->od_es, parser->au_time, 0, parser->au_is_rap);\n\t\t\tgf_bt_parse_od_command(parser, str);\n\t\t\tif (is_base_stream) parser->stream_id= 0;\n\t\t}\n\t\t/*BIFS commands*/\n\t\telse if (!strcmp(str, \"REPLACE\") || !strcmp(str, \"INSERT\") || !strcmp(str, \"APPEND\") || !strcmp(str, \"DELETE\")\n\t\t         /*BIFS extended commands*/\n\t\t         || !strcmp(str, \"GLOBALQP\") || !strcmp(str, \"MULTIPLEREPLACE\") || !strcmp(str, \"MULTIPLEINDREPLACE\") || !strcmp(str, \"XDELETE\") || !strcmp(str, \"DELETEPROTO\") || !strcmp(str, \"INSERTPROTO\")\n\t\t         || !strcmp(str, \"XREPLACE\")\n\t\t        ) {\n\t\t\tBool is_base_stream = parser->stream_id ? 0 : 1;\n\n\t\t\tif (!parser->stream_id) parser->stream_id = parser->base_bifs_id;\n\t\t\tif (!parser->stream_id || (parser->od_es && (parser->stream_id==parser->od_es->ESID)) ) parser->stream_id = parser->base_bifs_id;\n\n\t\t\tif (parser->bifs_es->ESID != parser->stream_id) {\n\t\t\t\tGF_StreamContext *prev = parser->bifs_es;\n\t\t\t\tparser->bifs_es = gf_sm_stream_new(parser->load->ctx, (u16) parser->stream_id, GF_STREAM_SCENE, GF_CODECID_BIFS);\n\t\t\t\t/*force new AU if stream changed*/\n\t\t\t\tif (parser->bifs_es != prev) {\n\t\t\t\t\tgf_bt_check_unresolved_nodes(parser);\n\t\t\t\t\tparser->bifs_au = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (force_new_com) {\n\t\t\t\tforce_new_com = 0;\n\t\t\t\tparser->bifs_au = gf_list_last(parser->bifs_es->AUs);\n\t\t\t\tparser->au_time = (u32) (parser->bifs_au ? parser->bifs_au->timing : 0) + 1;\n\t\t\t\tparser->bifs_au = NULL;\n\t\t\t}\n\n\t\t\tif (!parser->bifs_au) parser->bifs_au = gf_sm_stream_au_new(parser->bifs_es, parser->au_time, 0, parser->au_is_rap);\n\t\t\tgf_bt_parse_bifs_command(parser, str, parser->bifs_au->commands);\n\t\t\tif (is_base_stream) parser->stream_id= 0;\n\t\t}\n\t\t/*implicit BIFS command on SFTopNodes only*/\n\t\telse if (!strcmp(str, \"OrderedGroup\")\n\t\t         || !strcmp(str, \"Group\")\n\t\t         || !strcmp(str, \"Layer2D\")\n\t\t         || !strcmp(str, \"Layer3D\")\n\t\t         /* VRML parsing: all nodes are allowed*/\n\t\t         || parser->is_wrl\n\t\t        )\n\t\t{\n\n\t\t\tnode = gf_bt_sf_node(parser, str, vrml_root_node, has_id ? szDEFName : NULL);\n\t\t\thas_id = 0;\n\t\t\tif (!node) break;\n\t\t\tif (parser->top_nodes) {\n\t\t\t\tgf_list_add(parser->top_nodes, node);\n\t\t\t} else if (!vrml_root_node) {\n\t\t\t\tif (init_com) init_com->node = node;\n\t\t\t\telse if (parser->load->flags & GF_SM_LOAD_CONTEXT_READY) {\n\t\t\t\t\tGF_Command *com = gf_sg_command_new(parser->load->scene_graph, GF_SG_SCENE_REPLACE);\n\t\t\t\t\tassert(!parser->bifs_au);\n\t\t\t\t\tassert(parser->bifs_es);\n\t\t\t\t\tparser->bifs_au = gf_sm_stream_au_new(parser->bifs_es, 0, 0, 1);\n\t\t\t\t\tgf_list_add(parser->bifs_au->commands, com);\n\t\t\t\t\tcom->node = node;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tgf_node_insert_child(vrml_root_node, node, -1);\n\t\t\t}\n\n\t\t\t/*\n\t\t\tif (!gf_sg_get_root_node(parser->load->scene_graph)) {\n\t\t\t\tgf_node_register(node, NULL);\n\t\t\t\tgf_sg_set_root_node(parser->load->scene_graph, node);\n\t\t\t}\n\t\t\t*/\n\t\t}\n\n\t\t/*if in command, check command end*/\n\t\telse {\n\t\t\t/*check command end*/\n\t\t\tif (/*in_com && */gf_bt_check_code(parser, '}')) parser->in_com = 0;\n\t\t\telse if (strlen(str)) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"%s: Unknown top-level element\", str);\n\t\t\t}\n\t\t\tparser->au_is_rap = 0;\n\t\t}\n\t}\n\tgf_bt_resolve_routes(parser, 0);\n\tgf_bt_check_unresolved_nodes(parser);\n\n\t/*load scripts*/\n\twhile (gf_list_count(parser->scripts)) {\n\t\tGF_Node *n = (GF_Node *)gf_list_get(parser->scripts, 0);\n\t\tgf_list_rem(parser->scripts, 0);\n\t\tgf_sg_script_load(n);\n\t}\n\treturn parser->last_error;\n}\n\nstatic GF_Err gf_sm_load_bt_initialize(GF_SceneLoader *load, const char *str, Bool input_only)\n{\n\tu32 size;\n\tgzFile gzInput;\n\tGF_Err e;\n\tunsigned char BOM[5];\n\tGF_BTParser *parser = load->loader_priv;\n\n\tparser->last_error = GF_OK;\n\n\tif (load->fileName) {\n\t\tFILE *test = gf_fopen(load->fileName, \"rb\");\n\t\tif (!test) return GF_URL_ERROR;\n\n\t\tsize = (u32) gf_fsize(test);\n\t\tgf_fclose(test);\n\n\t\tgzInput = gf_gzopen(load->fileName, \"rb\");\n\t\tif (!gzInput) return GF_IO_ERR;\n\n\t\tparser->line_buffer = (char *) gf_malloc(sizeof(char)*BT_LINE_SIZE);\n\t\tmemset(parser->line_buffer, 0, sizeof(char)*BT_LINE_SIZE);\n\t\tparser->file_size = size;\n\n\t\tparser->line_pos = parser->line_size = 0;\n\t\tgf_gzgets(gzInput, (char*) BOM, 5);\n\t\tgf_gzseek(gzInput, 0, SEEK_SET);\n\t\tparser->gz_in = gzInput;\n\n\t} else {\n\t\tif (!str || (strlen(str)<5) ) {\n\t\t\t/*wait for first string data to be fed to the parser (for load from string)*/\n\t\t\tparser->initialized = 0;\n\t\t\treturn GF_OK;\n\t\t}\n\t\tstrncpy((char *) BOM, str, 5);\n\t}\n\n\t/*0: no unicode, 1: UTF-16BE, 2: UTF-16LE*/\n\tif ((BOM[0]==0xFF) && (BOM[1]==0xFE)) {\n\t\tif (!BOM[2] && !BOM[3]) {\n\t\t\tgf_bt_report(parser, GF_NOT_SUPPORTED, \"UTF-32 Text Files not supported\");\n\t\t\treturn GF_NOT_SUPPORTED;\n\t\t} else {\n\t\t\tparser->unicode_type = 2;\n\t\t\tif (parser->gz_in) gf_gzseek(parser->gz_in, 2, SEEK_CUR);\n\t\t}\n\t} else if ((BOM[0]==0xFE) && (BOM[1]==0xFF)) {\n\t\tif (!BOM[2] && !BOM[3]) {\n\t\t\tgf_bt_report(parser, GF_NOT_SUPPORTED, \"UTF-32 Text Files not supported\");\n\t\t\treturn GF_NOT_SUPPORTED;\n\t\t} else {\n\t\t\tparser->unicode_type = 1;\n\t\t\tif (parser->gz_in) gf_gzseek(parser->gz_in, 2, SEEK_CUR);\n\t\t}\n\t} else if ((BOM[0]==0xEF) && (BOM[1]==0xBB) && (BOM[2]==0xBF)) {\n\t\t/*we handle UTF8 as asci*/\n\t\tparser->unicode_type = 0;\n\t\tif (parser->gz_in) gf_gzseek(parser->gz_in, 3, SEEK_CUR);\n\t}\n\tparser->initialized = 1;\n\n\tif ( load->fileName )\n\t{\n\t\tchar *sep = gf_file_ext_start(load->fileName);\n\t\tif (sep && !strnicmp(sep, \".wrl\", 4)) parser->is_wrl = 1;\n\t}\n\n\tif (input_only) return GF_OK;\n\n\t/*initalize default streams in the context*/\n\n\t/*chunk parsing*/\n\tif (load->flags & GF_SM_LOAD_CONTEXT_READY) {\n\t\tu32 i;\n\t\tGF_StreamContext *sc;\n\t\tif (!load->ctx) return GF_BAD_PARAM;\n\n\t\t/*restore context - note that base layer are ALWAYS declared BEFORE enhancement layers with gpac parsers*/\n\t\ti=0;\n\t\twhile ((sc = (GF_StreamContext*)gf_list_enum(load->ctx->streams, &i))) {\n\t\t\tswitch (sc->streamType) {\n\t\t\tcase GF_STREAM_SCENE:\n\t\t\t\tif (!parser->bifs_es) parser->bifs_es = sc;\n\t\t\t\tbreak;\n\t\t\tcase GF_STREAM_OD:\n\t\t\t\tif (!parser->od_es) parser->od_es = sc;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/*need at least one scene stream*/\n\t\tif (!parser->bifs_es) {\n\t\t\tparser->bifs_es = gf_sm_stream_new(load->ctx, 0, GF_STREAM_SCENE, GF_CODECID_BIFS);\n\t\t\tparser->load->ctx->scene_width = 0;\n\t\t\tparser->load->ctx->scene_height = 0;\n\t\t\tparser->load->ctx->is_pixel_metrics = 1;\n\t\t}\n\t\telse parser->base_bifs_id = parser->bifs_es->ESID;\n\t\tif (parser->od_es) parser->base_od_id = parser->od_es->ESID;\n\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_PARSER, (\"BT: MPEG-4 (BT) Scene Chunk Parsing\"));\n\t}\n\t/*context is not initialized - check for VRML*/\n\telse {\n\t\tGF_Command *com;\n\n\n\t\tparser->load = NULL;\n\t\tgf_bt_check_line(parser);\n\t\tparser->load = load;\n\t\tif (load->ctx && parser->def_w && parser->def_h) {\n\t\t\tload->ctx->scene_width = parser->def_w;\n\t\t\tload->ctx->scene_height = parser->def_h;\n\t\t}\n\n\t\t/*create at least one empty BIFS stream*/\n\t\tif (!parser->is_wrl && load->ctx) {\n\t\t\tparser->bifs_es = gf_sm_stream_new(load->ctx, 0, GF_STREAM_SCENE, GF_CODECID_BIFS);\n\t\t\tparser->bifs_au = gf_sm_stream_au_new(parser->bifs_es, 0, 0, 1);\n\t\t\tparser->load->ctx->is_pixel_metrics = 1;\n\t\t}\n\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_PARSER, ( ((parser->is_wrl==2) ? \"BT: X3D (WRL) Scene Parsing\\n\" : (parser->is_wrl ? \"BT: VRML Scene Parsing\\n\" : \"BT: MPEG-4 Scene Parsing\\n\")) ));\n\n\t\t/*default scene replace - we create it no matter what since it is used to store BIFS config when parsing IOD.*/\n\t\tcom = NULL;\n\t\tif (!parser->is_wrl) {\n\t\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_SCENE_REPLACE);\n\t\t\tgf_list_add(parser->bifs_au->commands, com);\n\t\t}\n\n\t\t/*and perform initial load*/\n\t\te = gf_bt_loader_run_intern(parser, com, 1);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\nvoid load_bt_done(GF_SceneLoader *load)\n{\n\tGF_BTParser *parser = (GF_BTParser *)load->loader_priv;\n\tif (!parser) return;\n\tgf_list_del(parser->unresolved_routes);\n\tgf_list_del(parser->inserted_routes);\n\tgf_list_del(parser->undef_nodes);\n\tgf_list_del(parser->def_nodes);\n\tgf_list_del(parser->peeked_nodes);\n\twhile (gf_list_count(parser->def_symbols)) {\n\t\tBTDefSymbol *d = (BTDefSymbol *)gf_list_get(parser->def_symbols, 0);\n\t\tgf_list_rem(parser->def_symbols, 0);\n\t\tgf_free(d->name);\n\t\tgf_free(d->value);\n\t\tgf_free(d);\n\t}\n\tgf_list_del(parser->def_symbols);\n\tgf_list_del(parser->scripts);\n\n\tif (parser->gz_in) gf_gzclose(parser->gz_in);\n\tif (parser->line_buffer) gf_free(parser->line_buffer);\n\tgf_free(parser);\n\tload->loader_priv = NULL;\n}\n\nGF_Err load_bt_run(GF_SceneLoader *load)\n{\n\tGF_Err e;\n\tGF_BTParser *parser = (GF_BTParser *)load->loader_priv;\n\tif (!parser) return GF_BAD_PARAM;\n\n\tif (!parser->initialized) {\n\t\te = gf_sm_load_bt_initialize(load, NULL, 1);\n\t\tif (e) return e;\n\t}\n\n\te = gf_bt_loader_run_intern(parser, NULL, 0);\n\n\tif ((e<0) || parser->done) {\n\t\tparser->done = 0;\n\t\tparser->initialized = 0;\n\t\tif (parser->gz_in) {\n\t\t\tgf_gzclose(parser->gz_in);\n\t\t\tparser->gz_in = NULL;\n\t\t}\n\n\t\tif (parser->line_buffer) {\n\t\t\tgf_free(parser->line_buffer);\n\t\t\tparser->line_buffer = NULL;\n\t\t}\n\t\tparser->file_size = 0;\n\t\tparser->line_pos = parser->line_size = 0;\n\t\tload->fileName = NULL;\n\t}\n\treturn e;\n}\n\n\nGF_Err load_bt_parse_string(GF_SceneLoader *load, const char *str)\n{\n\tGF_Err e;\n\tchar *dup_str;\n\tGF_BTParser *parser = (GF_BTParser *)load->loader_priv;\n\tif (!parser) return GF_BAD_PARAM;\n\n\tif (parser->done) {\n\t\tparser->done = 0;\n\t\tparser->initialized = 0;\n\t\tparser->file_size = 0;\n\t\tparser->line_pos = 0;\n\t}\n\tparser->line_buffer = dup_str = gf_strdup(str);\n\tparser->line_size = (s32)strlen(str);\n\n\tif (!parser->initialized) {\n\t\te = gf_sm_load_bt_initialize(load, str, 0);\n\t\tif (e) {\n\t\t\tgf_free(dup_str);\n\t\t\treturn e;\n\t\t}\n\t}\n\te = gf_bt_loader_run_intern(parser, NULL, 0);\n\tparser->line_buffer = NULL;\n\tparser->line_size = 0;\n\tgf_free(dup_str);\n\treturn e;\n}\n\nGF_Err load_bt_suspend(GF_SceneLoader *load, Bool suspend)\n{\n\treturn GF_OK;\n}\n\nGF_Err gf_sm_load_init_bt(GF_SceneLoader *load)\n{\n\tGF_Err e;\n\tGF_BTParser *parser;\n\n\tif (!load || (!load->ctx && !load->scene_graph) ) return GF_BAD_PARAM;\n\tif (!load->scene_graph) load->scene_graph = load->ctx->scene_graph;\n\n\tGF_SAFEALLOC(parser, GF_BTParser);\n\tif (!parser) return GF_OUT_OF_MEM;\n\tparser->load = load;\n\tload->loader_priv = parser;\n\tparser->def_symbols = gf_list_new();\n\tparser->unresolved_routes = gf_list_new();\n\tparser->inserted_routes = gf_list_new();\n\tparser->undef_nodes = gf_list_new();\n\tparser->def_nodes = gf_list_new();\n\tparser->peeked_nodes = gf_list_new();\n\tparser->scripts = gf_list_new();\n\n\tload->process = load_bt_run;\n\tload->done = load_bt_done;\n\tload->suspend = load_bt_suspend;\n\tload->parse_string = load_bt_parse_string;\n\n#ifdef GPAC_ENABLE_COVERAGE\n\tif (gf_sys_is_cov_mode()) {\n\t\tgf_bt_report(parser, GF_OK, NULL);\n\t}\n#endif\n\n\te = gf_sm_load_bt_initialize(load, NULL, 0);\n\tif (e) {\n\t\tload_bt_done(load);\n\t\treturn e;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_List *gf_sm_load_bt_from_string(GF_SceneGraph *in_scene, char *node_str, Bool force_wrl)\n{\n\tGF_SceneLoader ctx;\n\tGF_BTParser parser;\n\tmemset(&ctx, 0, sizeof(GF_SceneLoader));\n\tctx.scene_graph = in_scene;\n\tmemset(&parser, 0, sizeof(GF_BTParser));\n\tparser.line_buffer = node_str;\n\tparser.line_size = (u32) strlen(node_str);\n\tparser.load = &ctx;\n\tparser.top_nodes = gf_list_new();\n\tparser.undef_nodes = gf_list_new();\n\tparser.def_nodes = gf_list_new();\n\tparser.peeked_nodes = gf_list_new();\n\tparser.is_wrl = force_wrl;\n\tgf_bt_loader_run_intern(&parser, NULL, 1);\n\tgf_list_del(parser.undef_nodes);\n\tgf_list_del(parser.def_nodes);\n\tgf_list_del(parser.peeked_nodes);\n\twhile (gf_list_count(parser.def_symbols)) {\n\t\tBTDefSymbol *d = (BTDefSymbol *)gf_list_get(parser.def_symbols, 0);\n\t\tgf_list_rem(parser.def_symbols, 0);\n\t\tgf_free(d->name);\n\t\tgf_free(d->value);\n\t\tgf_free(d);\n\t}\n\tgf_list_del(parser.def_symbols);\n\tgf_list_del(parser.scripts);\n\n\treturn parser.top_nodes;\n}\n\n#endif /*GPAC_DISABLE_LOADER_BT*/\n", "/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2005-2022\n *\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / common tools sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/xml.h>\n#include <gpac/utf.h>\n#include <gpac/network.h>\n\n#ifndef GPAC_DISABLE_ZLIB\n/*since 0.2.2, we use zlib for xmt/x3d reading to handle gz files*/\n#include <zlib.h>\n\n#if (defined(WIN32) || defined(_WIN32_WCE)) && !defined(__GNUC__)\n#pragma comment(lib, \"zlib\")\n#endif\n#else\n#define NO_GZIP\n#endif\n\n\n#define XML_INPUT_SIZE\t4096\n\n\nstatic GF_Err gf_xml_sax_parse_intern(GF_SAXParser *parser, char *current);\n\nstatic char *xml_translate_xml_string(char *str)\n{\n\tchar *value;\n\tu32 size, i, j;\n\tif (!str || !strlen(str)) return NULL;\n\tvalue = (char *)gf_malloc(sizeof(char) * 500);\n\tsize = 500;\n\ti = j = 0;\n\twhile (str[i]) {\n\t\tif (j+20 >= size) {\n\t\t\tsize += 500;\n\t\t\tvalue = (char *)gf_realloc(value, sizeof(char)*size);\n\t\t}\n\t\tif (str[i] == '&') {\n\t\t\tif (str[i+1]=='#') {\n\t\t\t\tchar szChar[20], *end;\n\t\t\t\tu16 wchar[2];\n\t\t\t\tu32 val, _len;\n\t\t\t\tconst unsigned short *srcp;\n\t\t\t\tstrncpy(szChar, str+i, 10);\n\t\t\t\tszChar[10] = 0;\n\t\t\t\tend = strchr(szChar, ';');\n\t\t\t\tif (!end) break;\n\t\t\t\tend[1] = 0;\n\t\t\t\ti += (u32) strlen(szChar);\n\t\t\t\twchar[1] = 0;\n\t\t\t\tif (szChar[2]=='x')\n\t\t\t\t\tsscanf(szChar, \"&#x%x;\", &val);\n\t\t\t\telse\n\t\t\t\t\tsscanf(szChar, \"&#%u;\", &val);\n\t\t\t\twchar[0] = val;\n\t\t\t\tsrcp = wchar;\n\t\t\t\t_len = gf_utf8_wcstombs(&value[j], 20, &srcp);\n\t\t\t\tif (_len == GF_UTF8_FAIL) _len = 0;\n\t\t\t\tj += _len;\n\t\t\t}\n\t\t\telse if (!strnicmp(&str[i], \"&amp;\", sizeof(char)*5)) {\n\t\t\t\tvalue[j] = '&';\n\t\t\t\tj++;\n\t\t\t\ti+= 5;\n\t\t\t}\n\t\t\telse if (!strnicmp(&str[i], \"&lt;\", sizeof(char)*4)) {\n\t\t\t\tvalue[j] = '<';\n\t\t\t\tj++;\n\t\t\t\ti+= 4;\n\t\t\t}\n\t\t\telse if (!strnicmp(&str[i], \"&gt;\", sizeof(char)*4)) {\n\t\t\t\tvalue[j] = '>';\n\t\t\t\tj++;\n\t\t\t\ti+= 4;\n\t\t\t}\n\t\t\telse if (!strnicmp(&str[i], \"&apos;\", sizeof(char)*6)) {\n\t\t\t\tvalue[j] = '\\'';\n\t\t\t\tj++;\n\t\t\t\ti+= 6;\n\t\t\t}\n\t\t\telse if (!strnicmp(&str[i], \"&quot;\", sizeof(char)*6)) {\n\t\t\t\tvalue[j] = '\\\"';\n\t\t\t\tj++;\n\t\t\t\ti+= 6;\n\t\t\t} else {\n\t\t\t\tvalue[j] = str[i];\n\t\t\t\tj++;\n\t\t\t\ti++;\n\t\t\t}\n\t\t} else {\n\t\t\tvalue[j] = str[i];\n\t\t\tj++;\n\t\t\ti++;\n\t\t}\n\t}\n\tvalue[j] = 0;\n\treturn value;\n}\n\n\nenum\n{\n\tSAX_STATE_ATT_NAME,\n\tSAX_STATE_ATT_VALUE,\n\tSAX_STATE_ELEMENT,\n\tSAX_STATE_COMMENT,\n\tSAX_STATE_TEXT_CONTENT,\n\tSAX_STATE_ENTITY,\n\tSAX_STATE_SKIP_DOCTYPE,\n\tSAX_STATE_CDATA,\n\tSAX_STATE_DONE,\n\tSAX_STATE_XML_PROC,\n\tSAX_STATE_SYNTAX_ERROR,\n\tSAX_STATE_ALLOC_ERROR,\n};\n\ntypedef struct\n{\n\tu32 name_start, name_end;\n\tu32 val_start, val_end;\n\tBool has_entities;\n} GF_XMLSaxAttribute;\n\n\n/* #define NO_GZIP */\n\n\nstruct _tag_sax_parser\n{\n\t/*0: UTF-8, 1: UTF-16 BE, 2: UTF-16 LE. String input is always converted back to utf8*/\n\ts32 unicode_type;\n\tchar *buffer;\n\t/*alloc size, line size and current position*/\n\tu32 alloc_size, line_size, current_pos;\n\t/*current node depth*/\n\tu32 node_depth;\n\n\t/*gz input file*/\n#ifdef NO_GZIP\n\tFILE *f_in;\n#else\n\tgzFile gz_in;\n#endif\n\t/*current line , file size and pos for user notif*/\n\tu32 line, file_size, file_pos;\n\n\t/*SAX callbacks*/\n\tgf_xml_sax_node_start sax_node_start;\n\tgf_xml_sax_node_end sax_node_end;\n\tgf_xml_sax_text_content sax_text_content;\n\tvoid *sax_cbck;\n\tgf_xml_sax_progress on_progress;\n\n\tu32 sax_state;\n\tu32 init_state;\n\tGF_List *entities;\n\tchar att_sep;\n\tBool in_entity, suspended;\n\tu32 in_quote;\n\n\tu32 elt_start_pos, elt_end_pos;\n\n\t/*last error found*/\n\tchar err_msg[1000];\n\n\tu32 att_name_start, elt_name_start, elt_name_end, text_start, text_end;\n\tu32 text_check_escapes;\n\n\tGF_XMLAttribute *attrs;\n\tGF_XMLSaxAttribute *sax_attrs;\n\tu32 nb_attrs, nb_alloc_attrs;\n\tu32 ent_rec_level;\n};\n\nstatic GF_XMLSaxAttribute *xml_get_sax_attribute(GF_SAXParser *parser)\n{\n\tif (parser->nb_attrs==parser->nb_alloc_attrs) {\n\t\tparser->nb_alloc_attrs++;\n\t\tparser->sax_attrs = (GF_XMLSaxAttribute *)gf_realloc(parser->sax_attrs, sizeof(GF_XMLSaxAttribute)*parser->nb_alloc_attrs);\n\t\tparser->attrs = (GF_XMLAttribute *)gf_realloc(parser->attrs, sizeof(GF_XMLAttribute)*parser->nb_alloc_attrs);\n\t}\n\treturn &parser->sax_attrs[parser->nb_attrs++];\n}\n\nstatic void xml_sax_swap(GF_SAXParser *parser)\n{\n\tif (parser->current_pos && ((parser->sax_state==SAX_STATE_TEXT_CONTENT) || (parser->sax_state==SAX_STATE_COMMENT) ) ) {\n\t\tif (parser->line_size >= parser->current_pos) {\n\t\t\tparser->line_size -= parser->current_pos;\n\t\t\tparser->file_pos += parser->current_pos;\n\t\t\tif (parser->line_size) memmove(parser->buffer, parser->buffer + parser->current_pos, sizeof(char)*parser->line_size);\n\t\t\tparser->buffer[parser->line_size] = 0;\n\t\t\tparser->current_pos = 0;\n\t\t}\n\t}\n}\n\nstatic void format_sax_error(GF_SAXParser *parser, u32 linepos, const char* fmt, ...)\n{\n\tva_list args;\n\tu32 len;\n\n\tif (!parser) return;\n\n\tva_start(args, fmt);\n\tvsnprintf(parser->err_msg, GF_ARRAY_LENGTH(parser->err_msg), fmt, args);\n\tva_end(args);\n\n\tif (strlen(parser->err_msg)+30 < GF_ARRAY_LENGTH(parser->err_msg)) {\n\t\tchar szM[20];\n\t\tsnprintf(szM, 20, \" - Line %d: \", parser->line + 1);\n\t\tstrcat(parser->err_msg, szM);\n\t\tlen = (u32) strlen(parser->err_msg);\n\t\tstrncpy(parser->err_msg + len, parser->buffer+ (linepos ? linepos : parser->current_pos), 10);\n\t\tparser->err_msg[len + 10] = 0;\n\t}\n\tparser->sax_state = SAX_STATE_SYNTAX_ERROR;\n}\n\nstatic void xml_sax_node_end(GF_SAXParser *parser, Bool had_children)\n{\n\tchar *name, c;\n\n\tassert(parser->elt_name_start);\n\tassert(parser->elt_name_end);\n\tif (!parser->node_depth) {\n\t\tformat_sax_error(parser, 0, \"Markup error\");\n\t\treturn;\n\t}\n\tc = parser->buffer[parser->elt_name_end - 1];\n\tparser->buffer[parser->elt_name_end - 1] = 0;\n\tname = parser->buffer + parser->elt_name_start - 1;\n\n\tif (parser->sax_node_end) {\n\t\tchar *sep = strchr(name, ':');\n\t\tif (sep) {\n\t\t\tsep[0] = 0;\n\t\t\tparser->sax_node_end(parser->sax_cbck, sep+1, name);\n\t\t\tsep[0] = ':';\n\t\t} else {\n\t\t\tparser->sax_node_end(parser->sax_cbck, name, NULL);\n\t\t}\n\t}\n\tparser->buffer[parser->elt_name_end - 1] = c;\n\tparser->node_depth--;\n\tif (!parser->init_state && !parser->node_depth) parser->sax_state = SAX_STATE_DONE;\n\txml_sax_swap(parser);\n\tparser->text_start = parser->text_end = 0;\n}\n\nstatic void xml_sax_node_start(GF_SAXParser *parser)\n{\n\tBool has_entities = GF_FALSE;\n\tu32 i;\n\tchar c, *name;\n\n\tassert(parser->elt_name_start && parser->elt_name_end);\n\tc = parser->buffer[parser->elt_name_end - 1];\n\tparser->buffer[parser->elt_name_end - 1] = 0;\n\tname = parser->buffer + parser->elt_name_start - 1;\n\n\tfor (i=0; i<parser->nb_attrs; i++) {\n\t\tparser->attrs[i].name = parser->buffer + parser->sax_attrs[i].name_start - 1;\n\t\tparser->buffer[parser->sax_attrs[i].name_end-1] = 0;\n\t\tparser->attrs[i].value = parser->buffer + parser->sax_attrs[i].val_start - 1;\n\t\tparser->buffer[parser->sax_attrs[i].val_end-1] = 0;\n\n\t\tif (strchr(parser->attrs[i].value, '&')) {\n\t\t\tparser->sax_attrs[i].has_entities = GF_TRUE;\n\t\t\thas_entities = GF_TRUE;\n\t\t\tparser->attrs[i].value = xml_translate_xml_string(parser->attrs[i].value);\n\t\t}\n\t\t/*store first char pos after current attrib for node peeking*/\n\t\tparser->att_name_start = parser->sax_attrs[i].val_end;\n\t}\n\n\tif (parser->sax_node_start) {\n\t\tchar *sep = strchr(name, ':');\n\t\tif (sep) {\n\t\t\tsep[0] = 0;\n\t\t\tparser->sax_node_start(parser->sax_cbck, sep+1, name, parser->attrs, parser->nb_attrs);\n\t\t\tsep[0] = ':';\n\t\t} else {\n\t\t\tparser->sax_node_start(parser->sax_cbck, name, NULL, parser->attrs, parser->nb_attrs);\n\t\t}\n\t}\n\tparser->att_name_start = 0;\n\tparser->buffer[parser->elt_name_end - 1] = c;\n\tparser->node_depth++;\n\tif (has_entities) {\n\t\tfor (i=0; i<parser->nb_attrs; i++) {\n\t\t\tif (parser->sax_attrs[i].has_entities) {\n\t\t\t\tparser->sax_attrs[i].has_entities = GF_FALSE;\n\t\t\t\tgf_free(parser->attrs[i].value);\n\t\t\t}\n\t\t}\n\t}\n\tparser->nb_attrs = 0;\n\txml_sax_swap(parser);\n\tparser->text_start = parser->text_end = 0;\n}\n\nstatic Bool xml_sax_parse_attribute(GF_SAXParser *parser)\n{\n\tchar *sep;\n\tGF_XMLSaxAttribute *att = NULL;\n\n\t/*looking for attribute name*/\n\tif (parser->sax_state==SAX_STATE_ATT_NAME) {\n\t\t/*looking for start*/\n\t\tif (!parser->att_name_start) {\n\t\t\twhile (parser->current_pos < parser->line_size) {\n\t\t\t\tu8 c = parser->buffer[parser->current_pos];\n\t\t\t\tswitch (c) {\n\t\t\t\tcase '\\n':\n\t\t\t\t\tparser->line++;\n\t\t\t\tcase ' ':\n\t\t\t\tcase '\\r':\n\t\t\t\tcase '\\t':\n\t\t\t\t\tparser->current_pos++;\n\t\t\t\t\tcontinue;\n\t\t\t\t/*end of element*/\n\t\t\t\tcase '?':\n\t\t\t\t\tif (parser->init_state!=1) break;\n\t\t\t\tcase '/':\n\t\t\t\t\t/*not enough data*/\n\t\t\t\t\tif (parser->current_pos+1 == parser->line_size) return GF_TRUE;\n\t\t\t\t\tif (parser->buffer[parser->current_pos+1]=='>') {\n\t\t\t\t\t\tparser->current_pos+=2;\n\t\t\t\t\t\tparser->elt_end_pos = parser->file_pos + parser->current_pos - 1;\n\t\t\t\t\t\t/*done parsing attr AND elements*/\n\t\t\t\t\t\tif (!parser->init_state) {\n\t\t\t\t\t\t\txml_sax_node_start(parser);\n\t\t\t\t\t\t\t/*move to SAX_STATE_TEXT_CONTENT to force text flush*/\n\t\t\t\t\t\t\tparser->sax_state = SAX_STATE_TEXT_CONTENT;\n\t\t\t\t\t\t\txml_sax_node_end(parser, GF_FALSE);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tparser->nb_attrs = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tparser->sax_state = (parser->init_state) ? SAX_STATE_ELEMENT : SAX_STATE_TEXT_CONTENT;\n\t\t\t\t\t\tparser->text_start = parser->text_end = 0;\n\t\t\t\t\t\treturn GF_FALSE;\n\t\t\t\t\t}\n\t\t\t\t\tif (!parser->in_quote && (c=='/')) {\n\t\t\t\t\t\tif (!parser->init_state) {\n\t\t\t\t\t\t\tformat_sax_error(parser, 0, \"Markup error\");\n\t\t\t\t\t\t\treturn GF_TRUE;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\"':\n\t\t\t\t\tif (parser->sax_state==SAX_STATE_ATT_VALUE) break;\n\t\t\t\t\tif (parser->in_quote && (parser->in_quote!=c) ) {\n\t\t\t\t\t\tformat_sax_error(parser, 0, \"Markup error\");\n\t\t\t\t\t\treturn GF_TRUE;\n\t\t\t\t\t}\n\t\t\t\t\tif (parser->in_quote) parser->in_quote = 0;\n\t\t\t\t\telse parser->in_quote = c;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '>':\n\t\t\t\t\tparser->current_pos+=1;\n\t\t\t\t\t/*end of <!DOCTYPE>*/\n\t\t\t\t\tif (parser->init_state) {\n\t\t\t\t\t\tif (parser->init_state==1) {\n\t\t\t\t\t\t\tformat_sax_error(parser, 0, \"Invalid <!DOCTYPE...> or <?xml...?>\");\n\t\t\t\t\t\t\treturn GF_TRUE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tparser->sax_state = SAX_STATE_ELEMENT;\n\t\t\t\t\t\treturn GF_FALSE;\n\t\t\t\t\t}\n\t\t\t\t\t/*done parsing attr*/\n\t\t\t\t\tparser->sax_state = SAX_STATE_TEXT_CONTENT;\n\t\t\t\t\txml_sax_node_start(parser);\n\t\t\t\t\treturn GF_FALSE;\n\t\t\t\tcase '[':\n\t\t\t\t\tif (parser->init_state) {\n\t\t\t\t\t\tparser->current_pos+=1;\n\t\t\t\t\t\tif (parser->init_state==1) {\n\t\t\t\t\t\t\tformat_sax_error(parser, 0, \"Invalid <!DOCTYPE...> or <?xml...?>\");\n\t\t\t\t\t\t\treturn GF_TRUE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tparser->sax_state = SAX_STATE_ELEMENT;\n\t\t\t\t\t\treturn GF_FALSE;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '<':\n\t\t\t\t\tformat_sax_error(parser, 0, \"Invalid character '<'\");\n\t\t\t\t\treturn GF_FALSE;\n\t\t\t\t/*first char of attr name*/\n\t\t\t\tdefault:\n\t\t\t\t\tparser->att_name_start = parser->current_pos + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tparser->current_pos++;\n\t\t\t\tif (parser->att_name_start) break;\n\t\t\t}\n\t\t\tif (parser->current_pos == parser->line_size) return GF_TRUE;\n\t\t}\n\n\t\tif (parser->init_state==2) {\n\t\t\tsep = strchr(parser->buffer + parser->att_name_start - 1, parser->in_quote ?  parser->in_quote : ' ');\n\t\t\t/*not enough data*/\n\t\t\tif (!sep) return GF_TRUE;\n\t\t\tparser->current_pos = (u32) (sep - parser->buffer);\n\t\t\tparser->att_name_start = 0;\n\t\t\tif (parser->in_quote) {\n\t\t\t\tparser->current_pos++;\n\t\t\t\tparser->in_quote = 0;\n\t\t\t}\n\t\t\treturn GF_FALSE;\n\t\t}\n\n\t\t/*looking for '\"'*/\n\t\tif (parser->att_name_start) {\n\t\t\tu32 i, first=1;\n\t\t\tsep = strchr(parser->buffer + parser->att_name_start - 1, '=');\n\t\t\t/*not enough data*/\n\t\t\tif (!sep) return GF_TRUE;\n\n\t\t\tparser->current_pos = (u32) (sep - parser->buffer);\n\t\t\tatt = xml_get_sax_attribute(parser);\n\t\t\tatt->name_start = parser->att_name_start;\n\t\t\tatt->name_end = parser->current_pos + 1;\n\t\t\twhile (strchr(\" \\n\\t\", parser->buffer[att->name_end - 2])) {\n\t\t\t\tassert(att->name_end);\n\t\t\t\tatt->name_end --;\n\t\t\t}\n\t\t\tatt->has_entities = GF_FALSE;\n\n\t\t\tfor (i=att->name_start; i<att->name_end; i++) {\n\t\t\t\tchar c = parser->buffer[i-1];\n\t\t\t\tif ((c>='a') && (c<='z')) {}\n\t\t\t\telse if ((c>='A') && (c<='Z')) {}\n\t\t\t\telse if ((c==':') || (c=='_')) {}\n\n\t\t\t\telse if (!first && ((c=='-') || (c=='.') || ((c>='0') && (c<='9')) )) {}\n\n\t\t\t\telse {\n\t\t\t\t\tformat_sax_error(parser, att->name_start-1, \"Invalid character \\'%c\\' for attribute name\", c);\n\t\t\t\t\treturn GF_TRUE;\n\t\t\t\t}\n\n\t\t\t\tfirst=0;\n\t\t\t}\n\n\t\t\tparser->att_name_start = 0;\n\t\t\tparser->current_pos++;\n\t\t\tparser->sax_state = SAX_STATE_ATT_VALUE;\n\n\t\t}\n\t}\n\n\tif (parser->sax_state == SAX_STATE_ATT_VALUE) {\n\t\tatt = &parser->sax_attrs[parser->nb_attrs-1];\n\t\t/*looking for first delimiter*/\n\t\tif (!parser->att_sep) {\n\t\t\twhile (parser->current_pos < parser->line_size) {\n\t\t\t\tu8 c = parser->buffer[parser->current_pos];\n\t\t\t\tswitch (c) {\n\t\t\t\tcase '\\n':\n\t\t\t\t\tparser->line++;\n\t\t\t\tcase ' ':\n\t\t\t\tcase '\\r':\n\t\t\t\tcase '\\t':\n\t\t\t\t\tparser->current_pos++;\n\t\t\t\t\tcontinue;\n\t\t\t\tcase '\\'':\n\t\t\t\tcase '\"':\n\t\t\t\t\tparser->att_sep = c;\n\t\t\t\t\tatt->val_start = parser->current_pos + 2;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tparser->current_pos++;\n\t\t\t\tif (parser->att_sep) break;\n\t\t\t}\n\t\t\tif (parser->current_pos == parser->line_size) return GF_TRUE;\n\t\t}\n\natt_retry:\n\n\t\tassert(parser->att_sep);\n\t\tsep = strchr(parser->buffer + parser->current_pos, parser->att_sep);\n\t\tif (!sep || !sep[1]) return GF_TRUE;\n\n\t\tif (sep[1]==parser->att_sep) {\n\t\t\tformat_sax_error(parser, (u32) (sep - parser->buffer), \"Invalid character %c after attribute value separator %c \", sep[1], parser->att_sep);\n\t\t\treturn GF_TRUE;\n\t\t}\n\n\t\tif (!parser->init_state && (strchr(\" />\\n\\t\\r\", sep[1])==NULL)) {\n\t\t\tparser->current_pos = (u32) (sep - parser->buffer + 1);\n\t\t\tgoto att_retry;\n\t\t}\n\n\t\tparser->current_pos = (u32) (sep - parser->buffer);\n\t\tatt->val_end = parser->current_pos + 1;\n\t\tparser->current_pos++;\n\n\t\t/*\"style\" always at the beginning of the attributes for ease of parsing*/\n\t\tif (!strncmp(parser->buffer + att->name_start-1, \"style\", 5)) {\n\t\t\tGF_XMLSaxAttribute prev = parser->sax_attrs[0];\n\t\t\tparser->sax_attrs[0] = *att;\n\t\t\t*att = prev;\n\t\t}\n\t\tparser->att_sep = 0;\n\t\tparser->sax_state = SAX_STATE_ATT_NAME;\n\t\tparser->att_name_start = 0;\n\t\treturn GF_FALSE;\n\t}\n\treturn GF_TRUE;\n}\n\n\ntypedef struct\n{\n\tchar *name;\n\tchar *value;\n\tu32 namelen;\n\tu8 sep;\n} XML_Entity;\n\nstatic void xml_sax_flush_text(GF_SAXParser *parser)\n{\n\tchar *text, c;\n\tif (!parser->text_start || parser->init_state || !parser->sax_text_content) return;\n\n\tassert(parser->text_start < parser->text_end);\n\n\tc = parser->buffer[parser->text_end-1];\n\tparser->buffer[parser->text_end-1] = 0;\n\ttext = parser->buffer + parser->text_start-1;\n\n\t/*solve XML built-in entities*/\n//old code commented for ref, we now track escape chars\n//\tif (strchr(text, '&') && strchr(text, ';')) {\n\tif (parser->text_check_escapes==0x3) {\n\t\tchar *xml_text = xml_translate_xml_string(text);\n\t\tif (xml_text) {\n\t\t\tparser->sax_text_content(parser->sax_cbck, xml_text, (parser->sax_state==SAX_STATE_CDATA) ? GF_TRUE : GF_FALSE);\n\t\t\tgf_free(xml_text);\n\t\t}\n\t} else {\n\t\tparser->sax_text_content(parser->sax_cbck, text, (parser->sax_state==SAX_STATE_CDATA) ? GF_TRUE : GF_FALSE);\n\t}\n\tparser->buffer[parser->text_end-1] = c;\n\tparser->text_start = parser->text_end = 0;\n\tparser->text_check_escapes = 0;\n}\n\nstatic void xml_sax_store_text(GF_SAXParser *parser, u32 txt_len)\n{\n\tif (!txt_len) return;\n\n\tif (!parser->text_start) {\n\t\tparser->text_check_escapes = 0;\n\t\tparser->text_start = parser->current_pos + 1;\n\t\tparser->text_end = parser->text_start + txt_len;\n\t\tparser->current_pos += txt_len;\n\t\tassert(parser->current_pos <= parser->line_size);\n\t\treturn;\n\t}\n\t/*contiguous text*/\n\tif (parser->text_end && (parser->text_end-1 == parser->current_pos)) {\n\t\tparser->text_end += txt_len;\n\t\tparser->current_pos += txt_len;\n\t\tassert(parser->current_pos <= parser->line_size);\n\t\treturn;\n\t}\n\t/*need to flush*/\n\txml_sax_flush_text(parser);\n\n\tparser->text_start = parser->current_pos + 1;\n\tparser->text_end = parser->text_start + txt_len;\n\tparser->current_pos += txt_len;\n\tassert(parser->current_pos <= parser->line_size);\n}\n\nstatic char *xml_get_current_text(GF_SAXParser *parser)\n{\n\tchar *text, c;\n\tif (!parser->text_start) return NULL;\n\n\tc = parser->buffer[parser->text_end-1];\n\tparser->buffer[parser->text_end-1] = 0;\n\ttext = gf_strdup(parser->buffer + parser->text_start-1);\n\tparser->buffer[parser->text_end-1] = c;\n\tparser->text_start = parser->text_end = 0;\n\treturn text;\n}\n\nstatic void xml_sax_skip_doctype(GF_SAXParser *parser)\n{\n\twhile (parser->current_pos < parser->line_size) {\n\t\tif (parser->buffer[parser->current_pos]=='>') {\n\t\t\tparser->sax_state = SAX_STATE_ELEMENT;\n\t\t\tparser->current_pos++;\n\t\t\txml_sax_swap(parser);\n\t\t\treturn;\n\t\t}\n\t\tparser->current_pos++;\n\t}\n}\n\nstatic void xml_sax_skip_xml_proc(GF_SAXParser *parser)\n{\n\twhile (parser->current_pos + 1 < parser->line_size) {\n\t\tif ((parser->buffer[parser->current_pos]=='?') && (parser->buffer[parser->current_pos+1]=='>')) {\n\t\t\tparser->sax_state = SAX_STATE_ELEMENT;\n\t\t\tparser->current_pos++;\n\t\t\txml_sax_swap(parser);\n\t\t\treturn;\n\t\t}\n\t\tparser->current_pos++;\n\t}\n}\n\n\nstatic void xml_sax_parse_entity(GF_SAXParser *parser)\n{\n\tchar szC[2];\n\tchar *ent_name=NULL;\n\tu32 i = 0;\n\tXML_Entity *ent = (XML_Entity *)gf_list_last(parser->entities);\n\tchar *skip_chars = \" \\t\\n\\r\";\n\ti=0;\n\tif (ent && ent->value) ent = NULL;\n\tif (ent) skip_chars = NULL;\n\tszC[1]=0;\n\n\twhile (parser->current_pos+i < parser->line_size) {\n\t\tu8 c = parser->buffer[parser->current_pos+i];\n\t\tif (skip_chars && strchr(skip_chars, c)) {\n\t\t\tif (c=='\\n') parser->line++;\n\t\t\tparser->current_pos++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!ent && (c=='%')) {\n\t\t\tparser->current_pos+=i+1;\n\t\t\tparser->sax_state = SAX_STATE_SKIP_DOCTYPE;\n\t\t\tif (ent_name) gf_free(ent_name);\n\t\t\treturn;\n\t\t}\n\t\telse if (!ent && ((c=='\\\"') || (c=='\\'')) ) {\n\t\t\tGF_SAFEALLOC(ent, XML_Entity);\n\t\t\tif (!ent) {\n\t\t\t\tparser->sax_state = SAX_STATE_ALLOC_ERROR;\n\t\t\t\tif (ent_name) gf_free(ent_name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!ent_name) gf_dynstrcat(&ent_name, \"\", NULL);\n\n\t\t\tent->name = ent_name;\n\t\t\tent_name=NULL;\n\t\t\tent->namelen = (u32) strlen(ent->name);\n\t\t\tent->sep = c;\n\t\t\tparser->current_pos += 1+i;\n\t\t\tassert(parser->current_pos < parser->line_size);\n\t\t\txml_sax_swap(parser);\n\t\t\ti=0;\n\t\t\tgf_list_add(parser->entities, ent);\n\t\t\tskip_chars = NULL;\n\t\t} else if (ent && c==ent->sep) {\n\t\t\tif (ent_name) gf_free(ent_name);\n\t\t\txml_sax_store_text(parser, i);\n\n\t\t\tent->value = xml_get_current_text(parser);\n\t\t\tif (!ent->value) ent->value = gf_strdup(\"\");\n\n\t\t\tparser->current_pos += 1;\n\t\t\tassert(parser->current_pos < parser->line_size);\n\t\t\txml_sax_swap(parser);\n\t\t\tparser->sax_state = SAX_STATE_SKIP_DOCTYPE;\n\t\t\treturn;\n\t\t} else if (!ent) {\n\t\t\tszC[0] = c;\n\t\t\tgf_dynstrcat(&ent_name, szC, NULL);\n\t\t\ti++;\n\t\t} else {\n\t\t\ti++;\n\t\t}\n\t}\n\tif (ent_name) gf_free(ent_name);\n\tif (ent && !ent->value)\n\t\tparser->sax_state = SAX_STATE_SYNTAX_ERROR;\n\txml_sax_store_text(parser, i);\n}\n\nstatic void xml_sax_cdata(GF_SAXParser *parser)\n{\n\tchar *cd_end = strstr(parser->buffer + parser->current_pos, \"]]>\");\n\tif (!cd_end) {\n\t\txml_sax_store_text(parser, parser->line_size - parser->current_pos);\n\t} else {\n\t\tu32 size = (u32) (cd_end - (parser->buffer + parser->current_pos));\n\t\txml_sax_store_text(parser, size);\n\t\txml_sax_flush_text(parser);\n\t\tparser->current_pos += 3;\n\t\tassert(parser->current_pos <= parser->line_size);\n\t\tparser->sax_state = SAX_STATE_TEXT_CONTENT;\n\t}\n}\n\nstatic Bool xml_sax_parse_comments(GF_SAXParser *parser)\n{\n\tchar *end = strstr(parser->buffer + parser->current_pos, \"-->\");\n\tif (!end) {\n\t\tif (parser->line_size>3)\n\t\t\tparser->current_pos = parser->line_size-3;\n\t\txml_sax_swap(parser);\n\t\treturn GF_FALSE;\n\t}\n\n\tparser->current_pos += 3 + (u32) (end - (parser->buffer + parser->current_pos) );\n\tassert(parser->current_pos <= parser->line_size);\n\tparser->sax_state = SAX_STATE_TEXT_CONTENT;\n\tparser->text_start = parser->text_end = 0;\n\txml_sax_swap(parser);\n\treturn GF_TRUE;\n}\n\n\n\nstatic GF_Err xml_sax_parse(GF_SAXParser *parser, Bool force_parse)\n{\n\tu32 i = 0;\n\tBool is_text;\n\tu32 is_end;\n\tu8 c;\n\tchar *elt, sep;\n\tu32 cdata_sep;\n\n\twhile (parser->current_pos<parser->line_size) {\n\t\tif (!force_parse && parser->suspended) goto exit;\n\nrestart:\n\t\tis_text = GF_FALSE;\n\t\tswitch (parser->sax_state) {\n\t\t/*load an XML element*/\n\t\tcase SAX_STATE_TEXT_CONTENT:\n\t\t\tis_text = GF_TRUE;\n\t\tcase SAX_STATE_ELEMENT:\n\t\t\telt = NULL;\n\t\t\ti=0;\n\t\t\twhile ((c = parser->buffer[parser->current_pos+i]) !='<') {\n\t\t\t\tif ((parser->init_state==2) && (c ==']')) {\n\t\t\t\t\tparser->sax_state = SAX_STATE_ATT_NAME;\n\t\t\t\t\tparser->current_pos+=i+1;\n\t\t\t\t\tgoto restart;\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t\tif (c=='\\n') parser->line++;\n\t\t\t\tif (is_text) {\n\t\t\t\t\tif (c=='&') parser->text_check_escapes |= 1;\n\t\t\t\t\telse if (c==';') parser->text_check_escapes |= 2;\n\t\t\t\t}\n\n\t\t\t\tif (parser->current_pos+i==parser->line_size) {\n\t\t\t\t\tif ((parser->line_size>=2*XML_INPUT_SIZE) && !parser->init_state)\n\t\t\t\t\t\tparser->sax_state = SAX_STATE_SYNTAX_ERROR;\n\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (is_text && i) {\n\t\t\t\tu32 has_esc = parser->text_check_escapes;\n\t\t\t\txml_sax_store_text(parser, i);\n\t\t\t\tparser->text_check_escapes = has_esc;\n\t\t\t\tparser->sax_state = SAX_STATE_ELEMENT;\n\t\t\t} else if (i) {\n\t\t\t\tparser->current_pos += i;\n\t\t\t\tassert(parser->current_pos < parser->line_size);\n\t\t\t}\n\t\t\tis_end = 0;\n\t\t\ti = 0;\n\t\t\tcdata_sep = 0;\n\t\t\twhile (1) {\n\t\t\t\tc = parser->buffer[parser->current_pos+1+i];\n\t\t\t\tif (!strncmp(parser->buffer+parser->current_pos+1+i, \"!--\", 3)) {\n\t\t\t\t\tparser->sax_state = SAX_STATE_COMMENT;\n\t\t\t\t\ti += 3;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!c) {\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t\tif ((c=='\\t') || (c=='\\r') || (c==' ') ) {\n\t\t\t\t\tif (i) break;\n\t\t\t\t\telse parser->current_pos++;\n\t\t\t\t}\n\t\t\t\telse if (c=='\\n') {\n\t\t\t\t\tparser->line++;\n\t\t\t\t\tif (i) break;\n\t\t\t\t\telse parser->current_pos++;\n\t\t\t\t}\n\t\t\t\telse if (c=='>') break;\n\t\t\t\telse if (c=='=') break;\n\t\t\t\telse if (c=='[') {\n\t\t\t\t\ti++;\n\t\t\t\t\tif (!cdata_sep) cdata_sep = 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (c=='/') {\n\t\t\t\t\tis_end = !i ? 1 : 2;\n\t\t\t\t\ti++;\n\t\t\t\t} else if (c=='<') {\n\t\t\t\t\tif (parser->sax_state != SAX_STATE_COMMENT) {\n\t\t\t\t\t\tparser->sax_state = SAX_STATE_SYNTAX_ERROR;\n\t\t\t\t\t\treturn GF_CORRUPTED_DATA;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\t/*\t\t\t\tif ((c=='[') && (parser->buffer[parser->elt_name_start-1 + i-2]=='A') ) break; */\n\t\t\t\tif (parser->current_pos+1+i==parser->line_size) {\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i) {\n\t\t\t\tparser->elt_name_start = parser->current_pos+1 + 1;\n\t\t\t\tif (is_end==1) parser->elt_name_start ++;\n\t\t\t\tif (is_end==2) parser->elt_name_end = parser->current_pos+1+i;\n\t\t\t\telse parser->elt_name_end = parser->current_pos+1+i + 1;\n\t\t\t}\n\t\t\tif (is_end) {\n\t\t\t\txml_sax_flush_text(parser);\n\t\t\t\tparser->elt_end_pos = parser->file_pos + parser->current_pos + i;\n\t\t\t\tif (is_end==2) {\n\t\t\t\t\tparser->sax_state = SAX_STATE_ELEMENT;\n\t\t\t\t\txml_sax_node_start(parser);\n\t\t\t\t\txml_sax_node_end(parser, GF_FALSE);\n\t\t\t\t} else {\n\t\t\t\t\tparser->elt_end_pos += parser->elt_name_end - parser->elt_name_start;\n\t\t\t\t\txml_sax_node_end(parser, GF_TRUE);\n\t\t\t\t}\n\t\t\t\tif (parser->sax_state == SAX_STATE_SYNTAX_ERROR) break;\n\t\t\t\tparser->current_pos+=2+i;\n\t\t\t\tparser->sax_state = SAX_STATE_TEXT_CONTENT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!parser->elt_name_end) {\n\t\t\t\treturn GF_CORRUPTED_DATA;\n\t\t\t}\n\t\t\tsep = parser->buffer[parser->elt_name_end-1];\n\t\t\tparser->buffer[parser->elt_name_end-1] = 0;\n\t\t\telt = parser->buffer + parser->elt_name_start-1;\n\n\t\t\tparser->sax_state = SAX_STATE_ATT_NAME;\n\t\t\tassert(parser->elt_start_pos <= parser->file_pos + parser->current_pos);\n\t\t\tparser->elt_start_pos = parser->file_pos + parser->current_pos;\n\n\t\t\tif (!strncmp(elt, \"!--\", 3)) {\n\t\t\t\txml_sax_flush_text(parser);\n\t\t\t\tparser->sax_state = SAX_STATE_COMMENT;\n\t\t\t\tif (i>3) parser->current_pos -= (i-3);\n\t\t\t}\n\t\t\telse if (!strcmp(elt, \"?xml\")) parser->init_state = 1;\n\t\t\telse if (!strcmp(elt, \"!DOCTYPE\")) parser->init_state = 2;\n\t\t\telse if (!strcmp(elt, \"!ENTITY\")) parser->sax_state = SAX_STATE_ENTITY;\n\t\t\telse if (!strcmp(elt, \"!ATTLIST\") || !strcmp(elt, \"!ELEMENT\")) parser->sax_state = SAX_STATE_SKIP_DOCTYPE;\n\t\t\telse if (!strcmp(elt, \"![CDATA[\"))\n\t\t\t\tparser->sax_state = SAX_STATE_CDATA;\n\t\t\telse if (elt[0]=='?') {\n\t\t\t\ti--;\n\t\t\t\tparser->sax_state = SAX_STATE_XML_PROC;\n\t\t\t}\n\t\t\t/*node found*/\n\t\t\telse {\n\t\t\t\txml_sax_flush_text(parser);\n\t\t\t\tif (parser->init_state) {\n\t\t\t\t\tparser->init_state = 0;\n\t\t\t\t\t/*that's a bit ugly: since we solve entities when appending text, we need to\n\t\t\t\t\treparse the current buffer*/\n\t\t\t\t\tif (gf_list_count(parser->entities)) {\n\t\t\t\t\t\tchar *orig_buf;\n\t\t\t\t\t\tGF_Err e;\n\t\t\t\t\t\tparser->buffer[parser->elt_name_end-1] = sep;\n\t\t\t\t\t\torig_buf = gf_strdup(parser->buffer + parser->current_pos);\n\t\t\t\t\t\tparser->current_pos = 0;\n\t\t\t\t\t\tparser->line_size = 0;\n\t\t\t\t\t\tparser->elt_start_pos = 0;\n\t\t\t\t\t\tparser->sax_state = SAX_STATE_TEXT_CONTENT;\n\t\t\t\t\t\tparser->ent_rec_level++;\n\t\t\t\t\t\tif (parser->ent_rec_level>100) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CORE, (\"[XML] Too many recursions in entity solving, max 100 allowed\\n\"));\n\t\t\t\t\t\t\te = GF_NOT_SUPPORTED;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\te = gf_xml_sax_parse_intern(parser, orig_buf);\n\t\t\t\t\t\t\tparser->ent_rec_level--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgf_free(orig_buf);\n\t\t\t\t\t\treturn e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tparser->current_pos+=1+i;\n\t\t\tparser->buffer[parser->elt_name_end-1] = sep;\n\t\t\tbreak;\n\t\tcase SAX_STATE_COMMENT:\n\t\t\tif (!xml_sax_parse_comments(parser)) {\n\t\t\t\txml_sax_swap(parser);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SAX_STATE_ATT_NAME:\n\t\tcase SAX_STATE_ATT_VALUE:\n\t\t\tif (xml_sax_parse_attribute(parser))\n\t\t\t\tgoto exit;\n\t\t\tbreak;\n\t\tcase SAX_STATE_ENTITY:\n\t\t\txml_sax_parse_entity(parser);\n\t\t\tbreak;\n\t\tcase SAX_STATE_SKIP_DOCTYPE:\n\t\t\txml_sax_skip_doctype(parser);\n\t\t\tbreak;\n\t\tcase SAX_STATE_XML_PROC:\n\t\t\txml_sax_skip_xml_proc(parser);\n\t\t\tbreak;\n\t\tcase SAX_STATE_CDATA:\n\t\t\txml_sax_cdata(parser);\n\t\t\tbreak;\n\t\tcase SAX_STATE_SYNTAX_ERROR:\n\t\t\treturn GF_CORRUPTED_DATA;\n\t\tcase SAX_STATE_ALLOC_ERROR:\n\t\t\treturn GF_OUT_OF_MEM;\n\t\tcase SAX_STATE_DONE:\n\t\t\treturn GF_EOS;\n\t\t}\n\t}\nexit:\n#if 0\n\tif (is_text) {\n\t\tif (i) xml_sax_store_text(parser, i);\n\t\t/*DON'T FLUSH TEXT YET, wait for next '<' to do so otherwise we may corrupt xml base entities (&apos;, ...)*/\n\t}\n#endif\n\txml_sax_swap(parser);\n\n\tif (parser->sax_state==SAX_STATE_SYNTAX_ERROR)\n\t\treturn GF_CORRUPTED_DATA;\n\telse\n\t\treturn GF_OK;\n}\n\nstatic GF_Err xml_sax_append_string(GF_SAXParser *parser, char *string)\n{\n\tu32 size = parser->line_size;\n\tu32 nl_size = string ? (u32) strlen(string) : 0;\n\n\tif (!nl_size) return GF_OK;\n\n\tif ( (parser->alloc_size < size+nl_size+1)\n\t        /*\t\t|| (parser->alloc_size / 2 ) > size+nl_size+1 */\n\t   )\n\t{\n\t\tparser->alloc_size = size+nl_size+1;\n\t\tparser->alloc_size = 3 * parser->alloc_size / 2;\n\t\tparser->buffer = (char*)gf_realloc(parser->buffer, sizeof(char) * parser->alloc_size);\n\t\tif (!parser->buffer ) return GF_OUT_OF_MEM;\n\t}\n\tmemcpy(parser->buffer+size, string, sizeof(char)*nl_size);\n\tparser->buffer[size+nl_size] = 0;\n\tparser->line_size = size+nl_size;\n\treturn GF_OK;\n}\n\nstatic XML_Entity *gf_xml_locate_entity(GF_SAXParser *parser, char *ent_start, Bool *needs_text)\n{\n\tu32 i, count;\n\tu32 len = (u32) strlen(ent_start);\n\n\t*needs_text = GF_FALSE;\n\tcount = gf_list_count(parser->entities);\n\n\tfor (i=0; i<count; i++) {\n\t\tXML_Entity *ent = (XML_Entity *)gf_list_get(parser->entities, i);\n\t\tif (len < ent->namelen + 1) {\n\t\t\tif (strncmp(ent->name, ent_start, len))\n\t\t\t \treturn NULL;\n\n\t\t\t*needs_text = GF_TRUE;\n\t\t\treturn NULL;\n\t\t}\n\t\tif (!strncmp(ent->name, ent_start, ent->namelen) && (ent_start[ent->namelen]==';')) {\n\t\t\treturn ent;\n\t\t}\n\t}\n\treturn NULL;\n}\n\n\nstatic GF_Err gf_xml_sax_parse_intern(GF_SAXParser *parser, char *current)\n{\n\tu32 count;\n\t/*solve entities*/\n\tcount = gf_list_count(parser->entities);\n\twhile (count) {\n\t\tchar *entityEnd;\n\t\tXML_Entity *ent;\n\t\tchar *entityStart = strstr(current, \"&\");\n\t\tBool needs_text;\n\t\tu32 line_num;\n\n\t\t/*if in entity, the start of the entity is in the buffer !!*/\n\t\tif (parser->in_entity) {\n\t\t\tu32 len;\n\t\t\tchar *name;\n\t\t\tentityEnd = strstr(current, \";\");\n\t\t\tif (!entityEnd) return xml_sax_append_string(parser, current);\n\t\t\tentityStart = strrchr(parser->buffer, '&');\n\n\t\t\tentityEnd[0] = 0;\n\t\t\tlen = (u32) strlen(entityStart) + (u32) strlen(current) + 1;\n\t\t\tname = (char*)gf_malloc(sizeof(char)*len);\n\t\t\tsprintf(name, \"%s%s;\", entityStart+1, current);\n\n\t\t\tent = gf_xml_locate_entity(parser, name, &needs_text);\n\t\t\tgf_free(name);\n\n\t\t\tif (!ent && !needs_text) {\n\t\t\t\txml_sax_append_string(parser, current);\n\t\t\t\txml_sax_parse(parser, GF_TRUE);\n\t\t\t\tentityEnd[0] = ';';\n\t\t\t\tcurrent = entityEnd;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tassert(ent);\n\t\t\t/*truncate input buffer*/\n\t\t\tparser->line_size -= (u32) strlen(entityStart);\n\t\t\tentityStart[0] = 0;\n\n\t\t\tparser->in_entity = GF_FALSE;\n\t\t\tentityEnd[0] = ';';\n\t\t\tcurrent = entityEnd+1;\n\t\t} else {\n\t\t\tif (!entityStart) break;\n\n\t\t\tent = gf_xml_locate_entity(parser, entityStart+1, &needs_text);\n\n\t\t\t/*store current string before entity start*/\n\t\t\tentityStart[0] = 0;\n\t\t\txml_sax_append_string(parser, current);\n\t\t\txml_sax_parse(parser, GF_TRUE);\n\t\t\tentityStart[0] = '&';\n\n\t\t\t/*this is not an entitiy*/\n\t\t\tif (!ent && !needs_text) {\n\t\t\t\txml_sax_append_string(parser, \"&\");\n\t\t\t\tcurrent = entityStart+1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!ent) {\n\t\t\t\tparser->in_entity = GF_TRUE;\n\t\t\t\t/*store entity start*/\n\t\t\t\treturn xml_sax_append_string(parser, entityStart);\n\t\t\t}\n\t\t\tcurrent = entityStart + ent->namelen + 2;\n\t\t}\n\t\t/*append entity*/\n\t\tline_num = parser->line;\n\t\txml_sax_append_string(parser, ent->value);\n\t\tGF_Err e = xml_sax_parse(parser, GF_TRUE);\n\t\tparser->line = line_num;\n\t\tif (e) return e;\n\n\t}\n\txml_sax_append_string(parser, current);\n\treturn xml_sax_parse(parser, GF_FALSE);\n}\n\nGF_EXPORT\nGF_Err gf_xml_sax_parse(GF_SAXParser *parser, const void *string)\n{\n\tGF_Err e;\n\tchar *current;\n\tchar *utf_conv = NULL;\n\n\tif (parser->unicode_type < 0) return GF_BAD_PARAM;\n\n\tif (parser->unicode_type>1) {\n\t\tconst u16 *sptr = (const u16 *)string;\n\t\tu32 len = 2 * gf_utf8_wcslen(sptr);\n\t\tutf_conv = (char *)gf_malloc(sizeof(char)*(len+1));\n\t\tlen = gf_utf8_wcstombs(utf_conv, len, &sptr);\n\t\tif (len == GF_UTF8_FAIL) {\n\t\t\tparser->sax_state = SAX_STATE_SYNTAX_ERROR;\n\t\t\tgf_free(utf_conv);\n\t\t\treturn GF_CORRUPTED_DATA;\n\t\t}\n\t\tutf_conv[len] = 0;\n\t\tcurrent = utf_conv;\n\t} else {\n\t\tcurrent = (char *)string;\n\t}\n\n\te = gf_xml_sax_parse_intern(parser, current);\n\tif (utf_conv) gf_free(utf_conv);\n\treturn e;\n}\n\n\nGF_EXPORT\nGF_Err gf_xml_sax_init(GF_SAXParser *parser, unsigned char *BOM)\n{\n\tu32 offset;\n\tif (!BOM) {\n\t\tparser->unicode_type = 0;\n\t\tparser->sax_state = SAX_STATE_ELEMENT;\n\t\treturn GF_OK;\n\t}\n\n\tif (parser->unicode_type >= 0) return gf_xml_sax_parse(parser, BOM);\n\n\tif ((BOM[0]==0xFF) && (BOM[1]==0xFE)) {\n\t\tif (!BOM[2] && !BOM[3]) return GF_NOT_SUPPORTED;\n\t\tparser->unicode_type = 2;\n\t\toffset = 2;\n\t} else if ((BOM[0]==0xFE) && (BOM[1]==0xFF)) {\n\t\tif (!BOM[2] && !BOM[3]) return GF_NOT_SUPPORTED;\n\t\tparser->unicode_type = 1;\n\t\toffset = 2;\n\t} else if ((BOM[0]==0xEF) && (BOM[1]==0xBB) && (BOM[2]==0xBF)) {\n\t\t/*we handle UTF8 as asci*/\n\t\tparser->unicode_type = 0;\n\t\toffset = 3;\n\t} else {\n\t\tparser->unicode_type = 0;\n\t\toffset = 0;\n\t}\n\n#ifdef GPAC_ENABLE_COVERAGE\n\tif (gf_sys_is_cov_mode()) {\n\t\tformat_sax_error(NULL, 0, \"\");\n\t}\n#endif\n\n\tparser->sax_state = SAX_STATE_ELEMENT;\n\treturn gf_xml_sax_parse(parser, BOM + offset);\n}\n\nstatic void xml_sax_reset(GF_SAXParser *parser)\n{\n\twhile (1) {\n\t\tXML_Entity *ent = (XML_Entity *)gf_list_last(parser->entities);\n\t\tif (!ent) break;\n\t\tgf_list_rem_last(parser->entities);\n\t\tif (ent->name) gf_free(ent->name);\n\t\tif (ent->value) gf_free(ent->value);\n\t\tgf_free(ent);\n\t}\n\tif (parser->buffer) gf_free(parser->buffer);\n\tparser->buffer = NULL;\n\tparser->current_pos = 0;\n\tgf_free(parser->attrs);\n\tparser->attrs = NULL;\n\tgf_free(parser->sax_attrs);\n\tparser->sax_attrs = NULL;\n\tparser->nb_alloc_attrs = parser->nb_attrs = 0;\n}\n\n\nstatic GF_Err xml_sax_read_file(GF_SAXParser *parser)\n{\n\tGF_Err e = GF_EOS;\n\tunsigned char szLine[XML_INPUT_SIZE+2];\n\n#ifdef NO_GZIP\n\tif (!parser->f_in) return GF_BAD_PARAM;\n#else\n\tif (!parser->gz_in) return GF_BAD_PARAM;\n#endif\n\n\n\twhile (!parser->suspended) {\n#ifdef NO_GZIP\n\t\ts32 read = (s32)gf_fread(szLine, XML_INPUT_SIZE, parser->f_in);\n#else\n\t\ts32 read = gf_gzread(parser->gz_in, szLine, XML_INPUT_SIZE);\n#endif\n\t\tif ((read<=0) /*&& !parser->node_depth*/) break;\n\t\tszLine[read] = 0;\n\t\tszLine[read+1] = 0;\n\t\te = gf_xml_sax_parse(parser, szLine);\n\t\tif (e) break;\n\t\tif (parser->file_pos > parser->file_size) parser->file_size = parser->file_pos + 1;\n\t\tif (parser->on_progress) parser->on_progress(parser->sax_cbck, parser->file_pos, parser->file_size);\n\t}\n\n#ifdef NO_GZIP\n\tif (gf_feof(parser->f_in)) {\n#else\n\tif (gf_gzeof(parser->gz_in)) {\n#endif\n\t\tif (!e) e = GF_EOS;\n\t\tif (parser->on_progress) parser->on_progress(parser->sax_cbck, parser->file_size, parser->file_size);\n\n#ifdef NO_GZIP\n\t\tgf_fclose(parser->f_in);\n\t\tparser->f_in = NULL;\n#else\n\t\tgf_gzclose(parser->gz_in);\n\t\tparser->gz_in = 0;\n#endif\n\n\t\tparser->elt_start_pos = parser->elt_end_pos = 0;\n\t\tparser->elt_name_start = parser->elt_name_end = 0;\n\t\tparser->att_name_start = 0;\n\t\tparser->current_pos = 0;\n\t\tparser->line_size = 0;\n\t\tparser->att_sep = 0;\n\t\tparser->file_pos = 0;\n\t\tparser->file_size = 0;\n\t\tparser->line_size = 0;\n\t}\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_xml_sax_parse_file(GF_SAXParser *parser, const char *fileName, gf_xml_sax_progress OnProgress)\n{\n\tFILE *test;\n\tGF_Err e;\n\tu64 filesize;\n#ifndef NO_GZIP\n\tgzFile gzInput;\n#endif\n\tunsigned char szLine[6];\n\n\tparser->on_progress = OnProgress;\n\n\tif (!strncmp(fileName, \"gmem://\", 7)) {\n\t\tu32 size;\n\t\tu8 *xml_mem_address;\n\t\te = gf_blob_get(fileName, &xml_mem_address, &size, NULL);\n\t\tif (e) return e;\n\n\t\tparser->file_size = size;\n\t\t//copy possible BOM\n\t\tmemcpy(szLine, xml_mem_address, 4);\n\t\tszLine[4] = szLine[5] = 0;\n\n\t\tparser->file_pos = 0;\n\t\tparser->elt_start_pos = 0;\n\t\tparser->current_pos = 0;\n\n\t\te = gf_xml_sax_init(parser, szLine);\n        if (!e) {\n            e = gf_xml_sax_parse(parser, xml_mem_address+4);\n            if (parser->on_progress) parser->on_progress(parser->sax_cbck, parser->file_pos, parser->file_size);\n        }\n        gf_blob_release(fileName);\n        \n\t\tparser->elt_start_pos = parser->elt_end_pos = 0;\n\t\tparser->elt_name_start = parser->elt_name_end = 0;\n\t\tparser->att_name_start = 0;\n\t\tparser->current_pos = 0;\n\t\tparser->line_size = 0;\n\t\tparser->att_sep = 0;\n\t\tparser->file_pos = 0;\n\t\tparser->file_size = 0;\n\t\tparser->line_size = 0;\n\t\treturn e;\n\t}\n\n\t/*check file exists and gets its size (zlib doesn't support SEEK_END)*/\n\ttest = gf_fopen(fileName, \"rb\");\n\tif (!test) return GF_URL_ERROR;\n\n\tfilesize = gf_fsize(test);\n\tassert(filesize < 0x80000000);\n\tparser->file_size = (u32) filesize;\n\tgf_fclose(test);\n\n\tparser->file_pos = 0;\n\tparser->elt_start_pos = 0;\n\tparser->current_pos = 0;\n\t//open file and copy possible BOM\n#ifdef NO_GZIP\n\tparser->f_in = gf_fopen(fileName, \"rt\");\n\tif (gf_fread(szLine, 4, parser->f_in) != 4) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CORE, (\"[XML] Error loading BOM\\n\"));\n\t}\n#else\n\tgzInput = gf_gzopen(fileName, \"rb\");\n\tif (!gzInput) return GF_IO_ERR;\n\tparser->gz_in = gzInput;\n\t/*init SAX parser (unicode setup)*/\n\tgf_gzread(gzInput, szLine, 4);\n#endif\n\n\tszLine[4] = szLine[5] = 0;\n\te = gf_xml_sax_init(parser, szLine);\n\tif (e) return e;\n\n\treturn xml_sax_read_file(parser);\n}\n\nGF_EXPORT\nBool gf_xml_sax_binary_file(GF_SAXParser *parser)\n{\n\tif (!parser) return GF_FALSE;\n#ifdef NO_GZIP\n\treturn GF_FALSE;\n#else\n\tif (!parser->gz_in) return GF_FALSE;\n\treturn (((z_stream*)parser->gz_in)->data_type==Z_BINARY) ? GF_TRUE : GF_FALSE;\n#endif\n}\n\nGF_EXPORT\nGF_SAXParser *gf_xml_sax_new(gf_xml_sax_node_start on_node_start,\n                             gf_xml_sax_node_end on_node_end,\n                             gf_xml_sax_text_content on_text_content,\n                             void *cbck)\n{\n\tGF_SAXParser *parser;\n\tGF_SAFEALLOC(parser, GF_SAXParser);\n\tif (!parser) return NULL;\n\tparser->entities = gf_list_new();\n\tparser->unicode_type = -1;\n\tparser->sax_node_start = on_node_start;\n\tparser->sax_node_end = on_node_end;\n\tparser->sax_text_content = on_text_content;\n\tparser->sax_cbck = cbck;\n\treturn parser;\n}\n\nGF_EXPORT\nvoid gf_xml_sax_del(GF_SAXParser *parser)\n{\n\txml_sax_reset(parser);\n\tgf_list_del(parser->entities);\n#ifdef NO_GZIP\n\tif (parser->f_in) gf_fclose(parser->f_in);\n#else\n\tif (parser->gz_in) gf_gzclose(parser->gz_in);\n#endif\n\tgf_free(parser);\n}\n\nGF_EXPORT\nGF_Err gf_xml_sax_suspend(GF_SAXParser *parser, Bool do_suspend)\n{\n\tparser->suspended = do_suspend;\n\tif (!do_suspend) {\n#ifdef NO_GZIP\n\t\tif (parser->f_in) return xml_sax_read_file(parser);\n#else\n\t\tif (parser->gz_in) return xml_sax_read_file(parser);\n#endif\n\t\treturn xml_sax_parse(parser, GF_FALSE);\n\t}\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nu32 gf_xml_sax_get_line(GF_SAXParser *parser) {\n\treturn parser->line + 1 ;\n}\n\n#if 0 //unused\nu32 gf_xml_sax_get_file_size(GF_SAXParser *parser)\n{\n#ifdef NO_GZIP\n\treturn parser->f_in ? parser->file_size : 0;\n#else\n\treturn parser->gz_in ? parser->file_size : 0;\n#endif\n}\n\nu32 gf_xml_sax_get_file_pos(GF_SAXParser *parser)\n{\n#ifdef NO_GZIP\n\treturn parser->f_in ? parser->file_pos : 0;\n#else\n\treturn parser->gz_in ? parser->file_pos : 0;\n#endif\n}\n#endif\n\n\n\nGF_EXPORT\nchar *gf_xml_sax_peek_node(GF_SAXParser *parser, char *att_name, char *att_value, char *substitute, char *get_attr, char *end_pattern, Bool *is_substitute)\n{\n\tu32 state, att_len, alloc_size, _len;\n#ifdef NO_GZIP\n\tu64 pos;\n#else\n\tz_off_t pos;\n#endif\n\tBool from_buffer;\n\tBool dobreak=GF_FALSE;\n\tchar szLine1[XML_INPUT_SIZE+2], szLine2[XML_INPUT_SIZE+2], *szLine, *cur_line, *sep, *start, first_c, *result;\n\n\n#define CPYCAT_ALLOC(__str, __is_copy) _len = (u32) strlen(__str);\\\n\t\t\t\t\t\t\tif ( _len + (__is_copy ? 0 : strlen(szLine))>=alloc_size) {\\\n\t\t\t\t\t\t\t\talloc_size = 1 + (u32) strlen(__str);\t\\\n\t\t\t\t\t\t\t\tif (!__is_copy) alloc_size += (u32) strlen(szLine); \\\n\t\t\t\t\t\t\t\tszLine = gf_realloc(szLine, alloc_size);\t\\\n\t\t\t\t\t\t\t}\\\n\t\t\t\t\t\t\tif (__is_copy) { memmove(szLine, __str, sizeof(char)*_len); szLine[_len] = 0; }\\\n\t\t\t\t\t\t\telse strcat(szLine, __str); \\\n\n\tfrom_buffer=GF_FALSE;\n#ifdef NO_GZIP\n\tif (!parser->f_in) from_buffer=GF_TRUE;\n#else\n\tif (!parser->gz_in) from_buffer=GF_TRUE;\n#endif\n\n\tresult = NULL;\n\n\tszLine1[0] = szLine2[0] = 0;\n\tpos=0;\n\tif (!from_buffer) {\n#ifdef NO_GZIP\n\t\tpos = gf_ftell(parser->f_in);\n#else\n\t\tpos = (u32) gf_gztell(parser->gz_in);\n#endif\n\t}\n\tatt_len = (u32) strlen(parser->buffer + parser->att_name_start);\n\tif (att_len<2*XML_INPUT_SIZE) att_len = 2*XML_INPUT_SIZE;\n\talloc_size = att_len;\n\tszLine = (char *) gf_malloc(sizeof(char)*alloc_size);\n\tstrcpy(szLine, parser->buffer + parser->att_name_start);\n\tcur_line = szLine;\n\tatt_len = (u32) strlen(att_value);\n\tstate = 0;\n\tgoto retry;\n\n\twhile (1) {\n\t\tu32 read;\n\t\tu8 sep_char;\n\t\tif (!from_buffer) {\n#ifdef NO_GZIP\n\t\t\tif (gf_feof(parser->f_in)) break;\n#else\n\t\t\tif (gf_gzeof(parser->gz_in)) break;\n#endif\n\t\t}\n\n\t\tif (dobreak) break;\n\n\t\tif (cur_line == szLine2) {\n\t\t\tcur_line = szLine1;\n\t\t} else {\n\t\t\tcur_line = szLine2;\n\t\t}\n\t\tif (from_buffer) {\n\t\t\tdobreak=GF_TRUE;\n\t\t} else {\n#ifdef NO_GZIP\n\t\t\tread = (u32)gf_fread(cur_line, XML_INPUT_SIZE, parser->f_in);\n#else\n\t\t\tread = gf_gzread(parser->gz_in, cur_line, XML_INPUT_SIZE);\n#endif\n\t\t\tcur_line[read] = cur_line[read+1] = 0;\n\n\t\t\tCPYCAT_ALLOC(cur_line, 0);\n\t\t}\n\n\t\tif (end_pattern) {\n\t\t\tstart  = strstr(szLine, end_pattern);\n\t\t\tif (start) {\n\t\t\t\tstart[0] = 0;\n\t\t\t\tdobreak = GF_TRUE;\n\t\t\t}\n\t\t}\n\nretry:\n\t\tif (state == 2) goto fetch_attr;\n\t\tsep = strstr(szLine, att_name);\n\t\tif (!sep && !state) {\n\t\t\tstate = 0;\n\t\t\tstart = strrchr(szLine, '<');\n\t\t\tif (start) {\n\t\t\t\tCPYCAT_ALLOC(start, 1);\n\t\t\t} else {\n\t\t\t\tCPYCAT_ALLOC(cur_line, 1);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!state) {\n\t\t\tstate = 1;\n\t\t\t/*load next line*/\n\t\t\tfirst_c = sep[0];\n\t\t\tsep[0] = 0;\n\t\t\tstart = strrchr(szLine, '<');\n\t\t\tif (!start)\n\t\t\t\tgoto exit;\n\t\t\tsep[0] = first_c;\n\t\t\tCPYCAT_ALLOC(start, 1);\n\t\t\tsep = strstr(szLine, att_name);\n\t\t}\n\t\tsep = sep ? strchr(sep, '=') : NULL;\n\t\tif (!sep) {\n\t\t\tstate = 0;\n\t\t\tCPYCAT_ALLOC(cur_line, 1);\n\t\t\tcontinue;\n\t\t}\n\t\twhile (sep[0] && (sep[0] != '\\\"') && (sep[0] != '\\'') ) sep++;\n\t\tif (!sep[0]) continue;\n\t\tsep_char = sep[0];\n\t\tsep++;\n\t\twhile (sep[0] && strchr(\" \\n\\r\\t\", sep[0]) ) sep++;\n\t\tif (!sep[0]) continue;\n\t\tif (!strchr(sep, sep_char))\n\t\t\tcontinue;\n\n\t\t/*found*/\n\t\tif (!strncmp(sep, att_value, att_len)) {\n\t\t\tu32 sub_pos;\n\t\t\tsep = szLine + 1;\n\t\t\twhile (strchr(\" \\t\\r\\n\", sep[0])) sep++;\n\t\t\tsub_pos = 0;\n\t\t\twhile (!strchr(\" \\t\\r\\n\", sep[sub_pos])) sub_pos++;\n\t\t\tfirst_c = sep[sub_pos];\n\t\t\tsep[sub_pos] = 0;\n\t\t\tstate = 2;\n\t\t\tif (!substitute || !get_attr || strcmp(sep, substitute) ) {\n\t\t\t\tif (is_substitute) *is_substitute = GF_FALSE;\n\t\t\t\tresult = gf_strdup(sep);\n\t\t\t\tsep[sub_pos] = first_c;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tsep[sub_pos] = first_c;\nfetch_attr:\n\t\t\tsep = strstr(szLine + 1, get_attr);\n\t\t\tif (!sep) {\n\t\t\t\tCPYCAT_ALLOC(cur_line, 1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsep += strlen(get_attr);\n\t\t\twhile (strchr(\"= \\t\\r\\n\", sep[0])) sep++;\n\t\t\tsep++;\n\t\t\tsub_pos = 0;\n\t\t\twhile (!strchr(\" \\t\\r\\n/>\", sep[sub_pos])) sub_pos++;\n\t\t\tsep[sub_pos-1] = 0;\n\t\t\tresult = gf_strdup(sep);\n\t\t\tif (is_substitute) *is_substitute = GF_TRUE;\n\t\t\tgoto exit;\n\t\t}\n\t\tstate = 0;\n\t\tCPYCAT_ALLOC(sep, 1);\n\t\tgoto retry;\n\t}\nexit:\n\tgf_free(szLine);\n\n\tif (!from_buffer) {\n#ifdef NO_GZIP\n\t\tgf_fseek(parser->f_in, pos, SEEK_SET);\n#else\n\t\tgf_gzrewind(parser->gz_in);\n\t\tgf_gzseek(parser->gz_in, pos, SEEK_SET);\n#endif\n\t}\n\treturn result;\n}\n\nGF_EXPORT\nconst char *gf_xml_sax_get_error(GF_SAXParser *parser)\n{\n\treturn parser->err_msg;\n}\n\n\nstruct _peek_type\n{\n\tGF_SAXParser *parser;\n\tchar *res;\n};\n\nstatic void on_peek_node_start(void *cbk, const char *name, const char *ns, const GF_XMLAttribute *attributes, u32 nb_attributes)\n{\n\tstruct _peek_type *pt = (struct _peek_type*)cbk;\n\tpt->res = gf_strdup(name);\n\tpt->parser->suspended = GF_TRUE;\n}\n\nGF_EXPORT\nchar *gf_xml_get_root_type(const char *file, GF_Err *ret)\n{\n\tGF_Err e;\n\tstruct _peek_type pt;\n\tpt.res = NULL;\n\tpt.parser = gf_xml_sax_new(on_peek_node_start, NULL, NULL, &pt);\n\te = gf_xml_sax_parse_file(pt.parser, file, NULL);\n\tif (ret) *ret = e;\n\tgf_xml_sax_del(pt.parser);\n\treturn pt.res;\n}\n\n\nGF_EXPORT\nu32 gf_xml_sax_get_node_start_pos(GF_SAXParser *parser)\n{\n\treturn parser->elt_start_pos;\n}\n\nGF_EXPORT\nu32 gf_xml_sax_get_node_end_pos(GF_SAXParser *parser)\n{\n\treturn parser->elt_end_pos;\n}\n\nstruct _tag_dom_parser\n{\n\tGF_SAXParser *parser;\n\tGF_List *stack;\n\t//root node being parsed\n\tGF_XMLNode *root;\n\t//usually only one :)\n\tGF_List *root_nodes;\n\tu32 depth;\n\n\tvoid (*OnProgress)(void *cbck, u64 done, u64 tot);\n\tvoid *cbk;\n};\n\n\nGF_EXPORT\nvoid gf_xml_dom_node_reset(GF_XMLNode *node, Bool reset_attribs, Bool reset_children)\n{\n\tif (!node) return;\n\tif (node->attributes && reset_attribs) {\n\t\twhile (gf_list_count(node->attributes)) {\n\t\t\tGF_XMLAttribute *att = (GF_XMLAttribute *)gf_list_last(node->attributes);\n\t\t\tgf_list_rem_last(node->attributes);\n\t\t\tif (att->name) gf_free(att->name);\n\t\t\tif (att->value) gf_free(att->value);\n\t\t\tgf_free(att);\n\t\t}\n\t}\n\n\tif (reset_children && node->content) {\n\t\twhile (gf_list_count(node->content)) {\n\t\t\tGF_XMLNode *child = (GF_XMLNode *)gf_list_last(node->content);\n\t\t\tgf_list_rem_last(node->content);\n\t\t\tgf_xml_dom_node_del(child);\n\t\t}\n\t}\n}\n\nGF_EXPORT\nvoid gf_xml_dom_node_del(GF_XMLNode *node)\n{\n\tif (!node) return;\n\tgf_xml_dom_node_reset(node, GF_TRUE, GF_TRUE);\n\tif (node->attributes) gf_list_del(node->attributes);\n\tif (node->content) gf_list_del(node->content);\n\tif (node->ns) gf_free(node->ns);\n\tif (node->name) gf_free(node->name);\n\tgf_free(node);\n}\n\nGF_List * gf_list_new_prealloc(u32 nb_prealloc);\n\nstatic void on_dom_node_start(void *cbk, const char *name, const char *ns, const GF_XMLAttribute *attributes, u32 nb_attributes)\n{\n\tu32 i;\n\tGF_DOMParser *par = (GF_DOMParser *) cbk;\n\tGF_XMLNode *node;\n\n\tif (par->root && !gf_list_count(par->stack)) {\n\t\tpar->parser->suspended = GF_TRUE;\n\t\treturn;\n\t}\n\n\tGF_SAFEALLOC(node, GF_XMLNode);\n\tif (!node) {\n\t\tpar->parser->sax_state = SAX_STATE_ALLOC_ERROR;\n\t\treturn;\n\t}\n\tnode->attributes = gf_list_new_prealloc(nb_attributes);\n\t//don't allocate content yet\n\tnode->name = gf_strdup(name);\n\tif (ns) node->ns = gf_strdup(ns);\n\tgf_list_add(par->stack, node);\n\tif (!par->root) {\n\t\tpar->root = node;\n\t\tgf_list_add(par->root_nodes, node);\n\t}\n\n\tfor (i=0; i<nb_attributes; i++) {\n\t\tGF_XMLAttribute *att;\n\t\tconst GF_XMLAttribute *in_att = & attributes[i];\n\t\tGF_SAFEALLOC(att, GF_XMLAttribute);\n\t\tif (! att) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[SAX] Failed to allocate attribute\"));\n\t\t\tpar->parser->sax_state = SAX_STATE_ALLOC_ERROR;\n\t\t\treturn;\n\t\t}\n\t\tatt->name = gf_strdup(in_att->name);\n\t\tatt->value = gf_strdup(in_att->value);\n\t\tgf_list_add(node->attributes, att);\n\t}\n}\n\nstatic void on_dom_node_end(void *cbk, const char *name, const char *ns)\n{\n\tGF_DOMParser *par = (GF_DOMParser *)cbk;\n\tGF_XMLNode *last = (GF_XMLNode *)gf_list_last(par->stack);\n\tgf_list_rem_last(par->stack);\n\n\tif (!last || (strlen(last->name)!=strlen(name)) || strcmp(last->name, name) || (!ns && last->ns) || (ns && !last->ns) || (ns && strcmp(last->ns, ns) ) ) {\n\t\ts32 idx;\n\t\tformat_sax_error(par->parser, 0, \"Invalid node stack: closing node is %s but %s was expected\", name, last ? last->name : \"unknown\");\n\t\tpar->parser->suspended = GF_TRUE;\n\t\tgf_xml_dom_node_del(last);\n\t\tif (last == par->root)\n\t\t\tpar->root=NULL;\n\t\tidx = gf_list_find(par->root_nodes, last);\n\t\tif (idx != -1)\n\t\t\tgf_list_rem(par->root_nodes, idx);\n\t\treturn;\n\t}\n\tif (last != par->root) {\n\t\tGF_XMLNode *node = (GF_XMLNode *)gf_list_last(par->stack);\n\t\tif (!node->content)\n\t\t\tnode->content = gf_list_new();\n\n\t\tgf_list_add(node->content, last);\n\t}\n}\n\nstatic void on_dom_text_content(void *cbk, const char *content, Bool is_cdata)\n{\n\tGF_DOMParser *par = (GF_DOMParser *)cbk;\n\tGF_XMLNode *node;\n\tGF_XMLNode *last = (GF_XMLNode *)gf_list_last(par->stack);\n\tif (!last) return;\n\tif (!last->content)\n\t\tlast->content = gf_list_new();\n\n\tGF_SAFEALLOC(node, GF_XMLNode);\n\tif (!node) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[SAX] Failed to allocate XML node\"));\n\t\tpar->parser->sax_state = SAX_STATE_ALLOC_ERROR;\n\t\treturn;\n\t}\n\tnode->type = is_cdata ? GF_XML_CDATA_TYPE : GF_XML_TEXT_TYPE;\n\tnode->name = gf_strdup(content);\n\tgf_list_add(last->content, node);\n}\n\nGF_EXPORT\nGF_DOMParser *gf_xml_dom_new()\n{\n\tGF_DOMParser *dom;\n\tGF_SAFEALLOC(dom, GF_DOMParser);\n\tif (!dom) return NULL;\n\n\tdom->root_nodes = gf_list_new();\n\treturn dom;\n}\n\nstatic void gf_xml_dom_reset(GF_DOMParser *dom, Bool full_reset)\n{\n\tif (full_reset && dom->parser) {\n\t\tgf_xml_sax_del(dom->parser);\n\t\tdom->parser = NULL;\n\t}\n\n\tif (dom->stack) {\n\t\twhile (gf_list_count(dom->stack)) {\n\t\t\tGF_XMLNode *n = (GF_XMLNode *)gf_list_last(dom->stack);\n\t\t\tgf_list_rem_last(dom->stack);\n\t\t\tif (dom->root==n) {\n\t\t\t\tgf_list_del_item(dom->root_nodes, n);\n\t\t\t\tdom->root = NULL;\n\t\t\t}\n\t\t\tgf_xml_dom_node_del(n);\n\t\t}\n\t\tgf_list_del(dom->stack);\n\t\tdom->stack = NULL;\n\t}\n\tif (full_reset && gf_list_count(dom->root_nodes) ) {\n\t\twhile (gf_list_count(dom->root_nodes)) {\n\t\t\tGF_XMLNode *n = (GF_XMLNode *)gf_list_last(dom->root_nodes);\n\t\t\tgf_list_rem_last(dom->root_nodes);\n\t\t\tgf_xml_dom_node_del(n);\n\t\t}\n\t\tdom->root = NULL;\n\t}\n}\n\nGF_EXPORT\nvoid gf_xml_dom_del(GF_DOMParser *parser)\n{\n\tif (!parser)\n\t\treturn;\n\n\tgf_xml_dom_reset(parser, GF_TRUE);\n\tgf_list_del(parser->root_nodes);\n\tgf_free(parser);\n}\n\nGF_EXPORT\nGF_XMLNode *gf_xml_dom_detach_root(GF_DOMParser *parser)\n{\n\tGF_XMLNode *root;\n\tif (!parser)\n\t\treturn NULL;\n\troot = parser->root;\n\tgf_list_del_item(parser->root_nodes, root);\n\tparser->root = gf_list_get(parser->root_nodes, 0);\n\treturn root;\n}\n\nstatic void dom_on_progress(void *cbck, u64 done, u64 tot)\n{\n\tGF_DOMParser *dom = (GF_DOMParser *)cbck;\n\tdom->OnProgress(dom->cbk, done, tot);\n}\n\nGF_EXPORT\nGF_Err gf_xml_dom_parse(GF_DOMParser *dom, const char *file, gf_xml_sax_progress OnProgress, void *cbk)\n{\n\tGF_Err e;\n\tgf_xml_dom_reset(dom, GF_TRUE);\n\tdom->stack = gf_list_new();\n\tdom->parser = gf_xml_sax_new(on_dom_node_start, on_dom_node_end, on_dom_text_content, dom);\n\tdom->OnProgress = OnProgress;\n\tdom->cbk = cbk;\n\te = gf_xml_sax_parse_file(dom->parser, file, OnProgress ? dom_on_progress : NULL);\n\tgf_xml_dom_reset(dom, GF_FALSE);\n\treturn e<0 ? e : GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_xml_dom_parse_string(GF_DOMParser *dom, char *string)\n{\n\tGF_Err e;\n\tgf_xml_dom_reset(dom, GF_TRUE);\n\tdom->stack = gf_list_new();\n\tdom->parser = gf_xml_sax_new(on_dom_node_start, on_dom_node_end, on_dom_text_content, dom);\n\te = gf_xml_sax_init(dom->parser, (unsigned char *) string);\n\tgf_xml_dom_reset(dom, GF_FALSE);\n\treturn e<0 ? e : GF_OK;\n}\n\n#if 0 //unused\nGF_XMLNode *gf_xml_dom_create_root(GF_DOMParser *parser, const char* name) {\n\tGF_XMLNode * root;\n\tif (!parser) return NULL;\n\n\tGF_SAFEALLOC(root, GF_XMLNode);\n\tif (!root) return NULL;\n\troot->name = gf_strdup(name);\n\n\treturn root;\n}\n#endif\n\nGF_EXPORT\nGF_XMLNode *gf_xml_dom_get_root(GF_DOMParser *parser)\n{\n\treturn parser ? parser->root : NULL;\n}\nGF_EXPORT\nconst char *gf_xml_dom_get_error(GF_DOMParser *parser)\n{\n\treturn gf_xml_sax_get_error(parser->parser);\n}\nGF_EXPORT\nu32 gf_xml_dom_get_line(GF_DOMParser *parser)\n{\n\treturn gf_xml_sax_get_line(parser->parser);\n}\n\nGF_EXPORT\nu32 gf_xml_dom_get_root_nodes_count(GF_DOMParser *parser)\n{\n\treturn parser? gf_list_count(parser->root_nodes) : 0;\n}\n\nGF_EXPORT\nGF_XMLNode *gf_xml_dom_get_root_idx(GF_DOMParser *parser, u32 idx)\n{\n\treturn parser ? (GF_XMLNode*)gf_list_get(parser->root_nodes, idx) : NULL;\n}\n\n\nstatic void gf_xml_dom_node_serialize(GF_XMLNode *node, Bool content_only, Bool no_escape, char **str, u32 *alloc_size, u32 *size)\n{\n\tu32 i, count, vlen;\n\tchar *name;\n\n#define SET_STRING(v)\t\\\n\tvlen = (u32) strlen(v);\t\\\n\tif (vlen + (*size) >= (*alloc_size)) {\t\\\n\t\t(*alloc_size) += 1024;\t\\\n\t\tif (vlen + (*size) >= (*alloc_size)) (*alloc_size) = vlen + (*size) + 1;\\\n\t\t(*str) = gf_realloc((*str), (*alloc_size));\t\\\n\t\t(*str)[(*size)] = 0;\t\\\n\t}\t\\\n\tstrcat((*str), v);\t\\\n\t*size += vlen;\t\\\n\n\tswitch (node->type) {\n\tcase GF_XML_CDATA_TYPE:\n\t\tSET_STRING(\"![CDATA[\");\n\t\tSET_STRING(node->name);\n\t\tSET_STRING(\"]]>\");\n\t\treturn;\n\tcase GF_XML_TEXT_TYPE:\n\t\tname = node->name;\n\t\tif ((name[0]=='\\r') && (name[1]=='\\n'))\n\t\t\tname++;\n\n\t\tif (no_escape) {\n\t\t\tSET_STRING(name);\n\t\t} else {\n\t\t\tu32 tlen;\n\t\t\tchar szChar[2];\n\t\t\tszChar[1] = 0;\n\t\t\ttlen = (u32) strlen(name);\n\t\t\tfor (i= 0; i<tlen; i++) {\n\t\t\t\tswitch (name[i]) {\n\t\t\t\tcase '&':\n\t\t\t\t\tSET_STRING(\"&amp;\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase '<':\n\t\t\t\t\tSET_STRING(\"&lt;\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase '>':\n\t\t\t\t\tSET_STRING(\"&gt;\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\\'':\n\t\t\t\t\tSET_STRING(\"&apos;\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\\\"':\n\t\t\t\t\tSET_STRING(\"&quot;\");\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tszChar[0] = name[i];\n\t\t\t\t\tSET_STRING(szChar);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\tif (!content_only) {\n\t\tSET_STRING(\"<\");\n\t\tif (node->ns) {\n\t\t\tSET_STRING(node->ns);\n\t\t\tSET_STRING(\":\");\n\t\t}\n\t\tSET_STRING(node->name);\n\t\tcount = gf_list_count(node->attributes);\n\t\tif (count > 0) {\n\t\t\tSET_STRING(\" \");\n\t\t}\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_XMLAttribute *att = (GF_XMLAttribute*)gf_list_get(node->attributes, i);\n\t\t\tSET_STRING(att->name);\n\t\t\tSET_STRING(\"=\\\"\");\n\t\t\tSET_STRING(att->value);\n\t\t\tSET_STRING(\"\\\" \");\n\t\t}\n\n\t\tif (!gf_list_count(node->content)) {\n\t\t\tSET_STRING(\"/>\");\n\t\t\treturn;\n\t\t}\n\t\tSET_STRING(\">\");\n\t}\n\n\tcount = gf_list_count(node->content);\n\tfor (i=0; i<count; i++) {\n\t\tGF_XMLNode *child = (GF_XMLNode*)gf_list_get(node->content, i);\n\t\tgf_xml_dom_node_serialize(child, GF_FALSE, GF_FALSE, str, alloc_size, size);\n\t}\n\tif (!content_only) {\n\t\tSET_STRING(\"</\");\n\t\tif (node->ns) {\n\t\t\tSET_STRING(node->ns);\n\t\t\tSET_STRING(\":\");\n\t\t}\n\t\tSET_STRING(node->name);\n\t\tSET_STRING(\">\");\n\t}\n}\n\nGF_EXPORT\nchar *gf_xml_dom_serialize(GF_XMLNode *node, Bool content_only, Bool no_escape)\n{\n\tu32 alloc_size = 0;\n\tu32 size = 0;\n\tchar *str = NULL;\n\tgf_xml_dom_node_serialize(node, content_only, no_escape, &str, &alloc_size, &size);\n\treturn str;\n}\n\nGF_EXPORT\nchar *gf_xml_dom_serialize_root(GF_XMLNode *node, Bool content_only, Bool no_escape)\n{\n\tu32 alloc_size, size;\n\tchar *str = NULL;\n\tgf_dynstrcat(&str, \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\", NULL);\n\tif (!str) return NULL;\n\n\talloc_size = size = (u32) strlen(str) + 1;\n\tgf_xml_dom_node_serialize(node, content_only, no_escape, &str, &alloc_size, &size);\n\treturn str;\n}\n\n#if 0 //unused\nGF_XMLAttribute *gf_xml_dom_set_attribute(GF_XMLNode *node, const char* name, const char* value) {\n\tGF_XMLAttribute *att;\n\tif (!name || !value) return NULL;\n\tif (!node->attributes) {\n\t\tnode->attributes = gf_list_new();\n\t\tif (!node->attributes) return NULL;\n\t}\n\n\tatt = gf_xml_dom_create_attribute(name, value);\n\tif (!att) return NULL;\n\tgf_list_add(node->attributes, att);\n\treturn att;\n}\n\nGF_XMLAttribute *gf_xml_dom_get_attribute(GF_XMLNode *node, const char* name) {\n\tu32 i = 0;\n\tGF_XMLAttribute *att;\n\tif (!node || !name) return NULL;\n\n\twhile ( (att = (GF_XMLAttribute*)gf_list_enum(node->attributes, &i))) {\n\t\tif (!strcmp(att->name, name)) {\n\t\t\treturn att;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\n#endif\n\nGF_EXPORT\nGF_XMLAttribute *gf_xml_dom_create_attribute(const char* name, const char* value) {\n\tGF_XMLAttribute *att;\n\tGF_SAFEALLOC(att, GF_XMLAttribute);\n\tif (!att) return NULL;\n\n\tatt->name = gf_strdup(name);\n\tatt->value = gf_strdup(value);\n\treturn att;\n}\n\n\nGF_EXPORT\nGF_Err gf_xml_dom_append_child(GF_XMLNode *node, GF_XMLNode *child) {\n\tif (!node || !child) return GF_BAD_PARAM;\n\tif (!node->content) {\n\t\tnode->content = gf_list_new();\n\t\tif (!node->content) return GF_OUT_OF_MEM;\n\t}\n\treturn gf_list_add(node->content, child);\n}\n\n#if 0\n/*!\n\\brief Removes the node to the list of children of this node.\n\nRemoves the node to the list of children of this node.\n\\warning Doesn't free the memory of the removed children.\n\n\\param node the GF_XMLNode node\n\\param child the GF_XMLNode child to remove\n\\return Error code if any, otherwise GF_OK\n */\nGF_EXPORT\nGF_Err gf_xml_dom_rem_child(GF_XMLNode *node, GF_XMLNode *child) {\n\ts32 idx;\n\tif (!node || !child || !node->content) return GF_BAD_PARAM;\n\tidx = gf_list_find(node->content, child);\n\tif (idx == -1) return GF_BAD_PARAM;\n\treturn gf_list_rem(node->content, idx);\n}\n#endif //unused\n\n\nGF_XMLNode *gf_xml_dom_node_new(const char* ns, const char* name)\n{\n\tGF_XMLNode* node;\n\tGF_SAFEALLOC(node, GF_XMLNode);\n\tif (!node) return NULL;\n\tif (ns) {\n\t\tnode->ns = gf_strdup(ns);\n\t\tif (!node->ns) {\n\t\t\tgf_free(node);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (name) {\n\t\tnode->name = gf_strdup(name);\n\t\tif (!node->name) {\n\t\t\tgf_free(node->ns);\n\t\t\tgf_free(node);\n\t\t\treturn NULL;\n\t\t}\n\t\tnode->type = GF_XML_NODE_TYPE;\n\t} else {\n\t\tnode->type = GF_XML_TEXT_TYPE;\n\t}\n\treturn node;\n}\n\n#include <gpac/base_coding.h>\n\n#define XML_SCAN_INT(_fmt, _value)\t\\\n\t{\\\n\tif (strstr(att->value, \"0x\")) { u32 __i; sscanf(att->value+2, \"%x\", &__i); _value = __i; }\\\n\telse if (strstr(att->value, \"0X\")) { u32 __i; sscanf(att->value+2, \"%X\", &__i); _value = __i; }\\\n\telse sscanf(att->value, _fmt, &_value); \\\n\t}\\\n\n\nGF_Err gf_xml_parse_bit_sequence_bs(GF_XMLNode *bsroot, const char *parent_url, const char *base_media_file, GF_BitStream *bs_orig)\n{\n\tu32 i, j;\n\tGF_Err e = GF_OK;\n\tGF_XMLNode *node;\n\tGF_XMLAttribute *att;\n\tGF_BitStream *bs = bs_orig;\n\tu32 enc_base64 = 0;\n\n\ti=0;\n\twhile ((node = (GF_XMLNode *) gf_list_enum(bsroot->content, &i))) {\n\t\tu32 nb_bits = 0;\n\t\tu32 size = 0;\n\t\tu64 offset = 0;\n\t\ts64 value = 0;\n\t\tBool use_file = GF_FALSE;\n\t\tbin128 word128;\n\t\tFloat val_float = 0;\n\t\tDouble val_double = 0;\n\t\tBool use_word128 = GF_FALSE;\n\t\tBool use_text = GF_FALSE;\n\t\tBool base64_prefix_bits = 0;\n\t\tBool big_endian = GF_TRUE;\n\t\tBool has_float = GF_FALSE;\n\t\tBool has_double = GF_FALSE;\n\t\tconst char *szFile = NULL;\n\t\tconst char *szString = NULL;\n\t\tconst char *szBase64 = NULL;\n\t\tconst char *szData = NULL;\n\t\tif (node->type) continue;\n\n\t\tif (stricmp(node->name, \"BS\") ) {\n\t\t\te = gf_xml_parse_bit_sequence_bs(node, parent_url, base_media_file, bs);\n\t\t\tif (e) goto exit;\n\t\t\tcontinue;\n\t\t}\n\n\t\tj=0;\n\t\twhile ( (att = (GF_XMLAttribute *)gf_list_enum(node->attributes, &j))) {\n\t\t\tif (!stricmp(att->name, \"bits\")) {\n\t\t\t\tXML_SCAN_INT(\"%d\", nb_bits);\n\t\t\t} else if (!stricmp(att->name, \"value\")) {\n\t\t\t\tXML_SCAN_INT(LLD, value);\n\t\t\t} else if (!stricmp(att->name, \"float\")) {\n\t\t\t\tsscanf(att->value, \"%f\", &val_float);\n\t\t\t\thas_float = GF_TRUE;\n\t\t\t} else if (!stricmp(att->name, \"double\")) {\n\t\t\t\tsscanf(att->value, \"%lf\", &val_double);\n\t\t\t\thas_double = GF_TRUE;\n\t\t\t} else if (!stricmp(att->name, \"mediaOffset\") || !stricmp(att->name, \"dataOffset\")) {\n\t\t\t\tXML_SCAN_INT(LLU, offset);\n\t\t\t\tuse_file = GF_TRUE;\n\t\t\t} else if (!stricmp(att->name, \"dataLength\")) {\n\t\t\t\tXML_SCAN_INT(\"%u\", size);\n\t\t\t\tuse_file = GF_TRUE;\n\t\t\t} else if (!stricmp(att->name, \"mediaFile\") || !stricmp(att->name, \"dataFile\")) {\n\t\t\t\tszFile = att->value;\n\t\t\t\tuse_file = GF_TRUE;\n\t\t\t} else if (!stricmp(att->name, \"text\") || !stricmp(att->name, \"string\")) {\n\t\t\t\tszString = att->value;\n\t\t\t} else if (!stricmp(att->name, \"fcc\")) {\n\t\t\t\tvalue = GF_4CC(att->value[0], att->value[1], att->value[2], att->value[3]);\n\t\t\t\tnb_bits = 32;\n\t\t\t} else if (!stricmp(att->name, \"ID128\")) {\n\t\t\t\te = gf_bin128_parse(att->value, word128);\n                if (e != GF_OK) {\n                    GF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[XML/NHML] Cannot parse ID128\\n\"));\n                    goto exit;\n                }\n\t\t\t\tuse_word128 = GF_TRUE;\n\t\t\t} else if (!stricmp(att->name, \"textmode\")) {\n\t\t\t\tif (!strcmp(att->value, \"yes\")) use_text = GF_TRUE;\n\t\t\t} else if (!stricmp(att->name, \"data64\")) {\n\t\t\t\tszBase64 = att->value;\n\t\t\t} else if (!stricmp(att->name, \"data\")) {\n\t\t\t\tszData = att->value;\n\t\t\t\tif (!strnicmp(szData, \"0x\", 2)) szData += 2;\n\t\t\t} else if (!stricmp(att->name, \"endian\") && !stricmp(att->value, \"little\")) {\n\t\t\t\tbig_endian = GF_FALSE;\n\t\t\t} else if (!stricmp(att->name, \"base64\")) {\n\t\t\t\tif (!stricmp(att->value, \"yes\") || !stricmp(att->value, \"true\") ) {\n\t\t\t\t\tif (!enc_base64) enc_base64 = 1;\n\t\t\t\t} else if (!stricmp(att->value, \"start\")) {\n\t\t\t\t\tif (!enc_base64) enc_base64 = 2;\n\t\t\t\t} else if (!stricmp(att->value, \"end\")) {\n\t\t\t\t\tif (enc_base64==2) enc_base64 = 3;\n\t\t\t\t} else {\n                    GF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[XML/NHML] Invalid base64 attribute %s, expecting yes/no, start or end\\n\", att->value));\n                    e = GF_NON_COMPLIANT_BITSTREAM;\n                    goto exit;\n\t\t\t\t}\n\t\t\t} else if (!stricmp(att->name, \"base64Prefix\")) {\n\t\t\t\tbase64_prefix_bits = atoi(att->value);\n\t\t\t} else if (!stricmp(att->name, \"id\")) {\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[XML/NHML] Unkown attribute %s, ignoring\\n\", att->name));\n\t\t\t}\n\t\t}\n\n\t\tif (enc_base64 && (enc_base64<3)) {\n\t\t\tif (bs == bs_orig) {\n\t\t\t\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\t\t\tif (!bs) {\n\t\t\t\t\te = GF_OUT_OF_MEM;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (use_file && !szFile)\n\t\t\tszFile = base_media_file;\n\n\t\tif (szString) {\n\t\t\tu32 len = (u32) strlen(szString);\n\t\t\tif (nb_bits)\n\t\t\t\tgf_bs_write_int(bs, len, nb_bits);\n\n\t\t\tgf_bs_write_data(bs, szString, len);\n\t\t} else if (szBase64) {\n\t\t\tu32 len = (u32) strlen(szBase64);\n\t\t\tchar *data = (char *) gf_malloc(sizeof(char)*len);\n\t\t\tu32 ret;\n\t\t\tif (!data) {\n\t\t\t\te = GF_OUT_OF_MEM;\n\t\t\t\tgoto exit;\n\t\t\t}\n\n\t\t\tret = (u32) gf_base64_decode((char *)szBase64, len, data, len);\n\t\t\tif ((s32) ret >=0) {\n\t\t\t\tgf_bs_write_int(bs, ret, nb_bits);\n\t\t\t\tgf_bs_write_data(bs, data, ret);\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[XML/NHML] Error decoding base64 %s\\n\", att->value));\n\t\t\t\tgf_free(data);\n\t\t\t\te = GF_BAD_PARAM;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tgf_free(data);\n\t\t} else if (szData) {\n\t\t\tu32 len = (u32) strlen(szData);\n\t\t\tchar *data = (char *) gf_malloc(sizeof(char)*len/2);\n\t\t\tif (!data) {\n\t\t\t\te = GF_OUT_OF_MEM;\n\t\t\t\tgoto exit;\n\t\t\t}\n\n\t\t\tfor (j=0; j<len; j+=2) {\n\t\t\t\tu32 v;\n\t\t\t\tchar szV[5];\n\t\t\t\tsprintf(szV, \"%c%c\", szData[j], szData[j+1]);\n\t\t\t\tsscanf(szV, \"%x\", &v);\n\t\t\t\tdata[j/2] = v;\n\t\t\t}\n\t\t\tgf_bs_write_int(bs, len/2, nb_bits);\n\t\t\tgf_bs_write_data(bs, data, len/2);\n\t\t\tgf_free(data);\n\t\t} else if (has_float) {\n\t\t\tgf_bs_write_float(bs, val_float);\n\t\t} else if (has_double) {\n\t\t\tgf_bs_write_double(bs, val_double);\n\t\t} else if (nb_bits) {\n\t\t\tif (!big_endian) {\n\t\t\t\tif (nb_bits == 16)\n\t\t\t\t\tgf_bs_write_u16_le(bs, (u32)value);\n\t\t\t\telse if (nb_bits == 32)\n\t\t\t\t\tgf_bs_write_u32_le(bs, (u32)value);\n\t\t\t\telse {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[XML/NHML] Little-endian values can only be 16 or 32-bit\\n\"));\n\t\t\t\t\te = GF_BAD_PARAM;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (nb_bits<33) gf_bs_write_int(bs, (s32) value, nb_bits);\n\t\t\t\telse gf_bs_write_long_int(bs, value, nb_bits);\n\t\t\t}\n\t\t} else if (szFile) {\n\t\t\tu32 read, remain;\n\t\t\tchar block[1024];\n\t\t\tFILE *_tmp = NULL;\n\t\t\tif (parent_url) {\n\t\t\t\tchar *f_url = gf_url_concatenate(parent_url, szFile);\n\t\t\t\t_tmp = gf_fopen(f_url, use_text ? \"rt\" : \"rb\");\n\t\t\t\tgf_free(f_url);\n\t\t\t} else {\n\t\t\t\t_tmp = gf_fopen(szFile, use_text ? \"rt\" : \"rb\");\n\t\t\t}\n\n\t\t\tif (!_tmp) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[XML/NHML] Error opening file %s\\n\", szFile));\n\t\t\t\te = GF_URL_ERROR;\n\t\t\t\tgoto exit;\n\t\t\t}\n\n\t\t\tif (!size) {\n\t\t\t\tsize = (u32) gf_fsize(_tmp);\n\t\t\t\t//if offset only copy from offset until end\n\t\t\t\tif ((u64) size > offset)\n\t\t\t\t\tsize -= (u32) offset;\n\t\t\t}\n\t\t\tremain = size;\n\t\t\tgf_fseek(_tmp, offset, SEEK_SET);\n\t\t\twhile (remain) {\n\t\t\t\tu32 bsize = remain;\n\t\t\t\tif (bsize>1024) bsize=1024;\n\t\t\t\tread = (u32) gf_fread(block, bsize, _tmp);\n\t\t\t\tif ((s32) read < 0) {\n\t\t\t\t\tgf_fclose(_tmp);\n\t\t\t\t\te = GF_IO_ERR;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\n\t\t\t\tgf_bs_write_data(bs, block, read);\n\t\t\t\tremain -= bsize;\n\t\t\t}\n\t\t\tgf_fclose(_tmp);\n\t\t} else if (use_word128) {\n\t\t\tgf_bs_write_data(bs, (char *)word128, 16);\n\t\t}\n\n\t\tif ((enc_base64==1) || (enc_base64==3)) {\n\t\t\tu8 *bs_data;\n\t\t\tu32 bs_data_size;\n\t\t\tassert (bs != bs_orig);\n\t\t\tgf_bs_get_content(bs, &bs_data, &bs_data_size);\n\t\t\tgf_bs_del(bs);\n\t\t\tenc_base64 = 0;\n\t\t\tbs = bs_orig;\n\t\t\tif (bs_data) {\n\t\t\t\tu8 *bs_data_out;\n\t\t\t\tu32 res = 2*bs_data_size + 3;\n\t\t\t\tbs_data_out = gf_malloc(sizeof(char) * res);\n\t\t\t\tif (!bs_data_out) {\n\t\t\t\t\te = GF_OUT_OF_MEM;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t\tres = gf_base64_encode(bs_data, bs_data_size, bs_data_out, res);\n\t\t\t\tbs_data_out[res] = 0;\n\t\t\t\tif (base64_prefix_bits) {\n\t\t\t\t\tif (base64_prefix_bits % 8) {\n\t\t\t\t\t\tgf_bs_write_int(bs, res, base64_prefix_bits);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tu32 nb_bytes = base64_prefix_bits/8;\n\t\t\t\t\t\tif (!big_endian && (nb_bytes==8)) gf_bs_write_u64_le(bs, res);\n\t\t\t\t\t\telse if (!big_endian && (nb_bytes==4)) gf_bs_write_u32_le(bs, res);\n\t\t\t\t\t\telse if (!big_endian && (nb_bytes==2)) gf_bs_write_u16_le(bs, res);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tgf_bs_write_int(bs, res, base64_prefix_bits);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgf_bs_write_data(bs, bs_data_out, res);\n\t\t\t\tgf_free(bs_data);\n\t\t\t\tgf_free(bs_data_out);\n\t\t\t}\n\t\t}\n\t}\n\nexit:\n\tif (bs != bs_orig) {\n\t\tif (!e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[XML/NHML] base64 encoding context not closed\\n\"));\n\t\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t\tgf_bs_del(bs);\n\t}\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_xml_parse_bit_sequence(GF_XMLNode *bsroot, const char *parent_url, u8 **data, u32 *data_size)\n{\n\tGF_BitStream *bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tif (!bs) return GF_OUT_OF_MEM;\n\n\tgf_xml_parse_bit_sequence_bs(bsroot, parent_url, NULL, bs);\n\n\tgf_bs_align(bs);\n\tgf_bs_get_content(bs, data, data_size);\n\tgf_bs_del(bs);\n\treturn GF_OK;\n}\n\nGF_Err gf_xml_get_element_check_namespace(const GF_XMLNode *n, const char *expected_node_name, const char *expected_ns_prefix) {\n\tu32 i;\n\tGF_XMLAttribute *att;\n\n\t/*check we are processing the expected node*/\n\tif (expected_node_name && strcmp(expected_node_name, n->name)) {\n\t\treturn GF_SG_UNKNOWN_NODE;\n\t}\n\n\t/*check for previously declared prefix (to be manually provided)*/\n\tif (!n->ns) {\n\t\treturn GF_OK;\n\t}\n\tif (expected_ns_prefix && !strcmp(expected_ns_prefix, n->ns)) {\n\t\treturn GF_OK;\n\t}\n\n\t/*look for new namespace in attributes*/\n\ti = 0;\n\twhile ( (att = (GF_XMLAttribute*)gf_list_enum(n->attributes, &i)) ) {\n\t\tconst char *ns;\n\t\tns = strstr(att->name, \":\");\n\t\tif (!ns) continue;\n\t\t\n\t\tif (!strncmp(att->name, \"xmlns\", 5)) {\n\t\t\tif (!strcmp(ns+1, n->ns)) {\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CORE, (\"[XML] Unsupported attribute namespace \\\"%s\\\": ignoring\\n\", att->name));\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tGF_LOG(GF_LOG_WARNING, GF_LOG_CORE, (\"[XML] Unresolved namespace \\\"%s\\\" for node \\\"%s\\\"\\n\", n->ns, n->name));\n\treturn GF_BAD_PARAM;\n}\n\nvoid gf_xml_dump_string(FILE* file, const char *before, const char *str, const char *after)\n{\n\tsize_t i;\n\tsize_t len=str?strlen(str):0;\n\n\tif (before) {\n\t\tgf_fprintf(file, \"%s\", before);\n\t}\n\n\tfor (i = 0; i < len; i++) {\n\t\tswitch (str[i]) {\n\t\tcase '&':\n\t\t\tgf_fprintf(file, \"%s\", \"&amp;\");\n\t\t\tbreak;\n\t\tcase '<':\n\t\t\tgf_fprintf(file, \"%s\", \"&lt;\");\n\t\t\tbreak;\n\t\tcase '>':\n\t\t\tgf_fprintf(file, \"%s\", \"&gt;\");\n\t\t\tbreak;\n\t\tcase '\\'':\n\t\t\tgf_fprintf(file, \"&apos;\");\n\t\t\tbreak;\n\t\tcase '\\\"':\n\t\t\tgf_fprintf(file, \"&quot;\");\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tgf_fprintf(file, \"%c\", str[i]);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (after) {\n\t\tgf_fprintf(file, \"%s\", after);\n\t}\n}\n"], "fixing_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2022\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / Scene Management sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/scene_manager.h>\n#include <gpac/utf.h>\n#include <gpac/constants.h>\n#include <gpac/network.h>\n#include <gpac/internal/bifs_dev.h>\n#include <gpac/internal/scenegraph_dev.h>\n\n#include <gpac/nodes_x3d.h>\n#include <gpac/color.h>\n\n\n#if !defined(GPAC_DISABLE_LOADER_BT) && !defined(GPAC_DISABLE_ZLIB)\n\n#include <gpac/mpeg4_odf.h>\n\n/*since 0.2.2, we use zlib for bt reading to handle wrl.gz files*/\n#include <zlib.h>\n\nvoid gf_sm_update_bitwrapper_buffer(GF_Node *node, const char *fileName);\n\nvoid load_bt_done(GF_SceneLoader *load);\n\n#define BT_LINE_SIZE\t4000\n\ntypedef struct\n{\n\tchar *name;\n\tchar *value;\n} BTDefSymbol;\n\ntypedef struct\n{\n\tGF_SceneLoader *load;\n\tBool initialized;\n\tgzFile gz_in;\n\tu32 file_size, file_pos;\n\n\t/*create from string only*/\n\tGF_List *top_nodes;\n\n\tGF_Err last_error;\n\tu32 line;\n\n\tBool done, in_com;\n\tu32 is_wrl;\n\t/*0: no unicode, 1: UTF-16BE, 2: UTF-16LE*/\n\tu32 unicode_type;\n\n\tGF_List *def_symbols;\n\n\t/*routes are not created in the graph when parsing, so we need to track insert and delete/replace*/\n\tGF_List *unresolved_routes, *inserted_routes, *peeked_nodes;\n\tGF_List *undef_nodes, *def_nodes;\n\n\tchar *line_buffer;\n\tchar cur_buffer[500];\n\ts32 line_size, line_pos, line_start_pos;\n\n\tu32 block_comment;\n\n\t/*set when parsing proto*/\n\tGF_Proto *parsing_proto;\n\tBool is_extern_proto_field;\n\n\t/*current stream ID, AU time and RAP flag*/\n\tu32 stream_id;\n\tu32 au_time;\n\tBool au_is_rap;\n\n\t/*current BIFS stream & AU*/\n\tGF_StreamContext *bifs_es;\n\tGF_AUContext *bifs_au;\n\tu32 base_bifs_id;\n\tGF_Command *cur_com;\n\n\t/*current OD stream & AU*/\n\tGF_StreamContext *od_es;\n\tGF_AUContext *od_au;\n\tu32 base_od_id;\n\n\tGF_List *scripts;\n\n\tu32 def_w, def_h;\n\n} GF_BTParser;\n\nGF_Err gf_bt_parse_bifs_command(GF_BTParser *parser, char *name, GF_List *cmdList);\nGF_Route *gf_bt_parse_route(GF_BTParser *parser, Bool skip_def, Bool is_insert, GF_Command *com);\nvoid gf_bt_resolve_routes(GF_BTParser *parser, Bool clean);\n\nGF_Node *gf_bt_peek_node(GF_BTParser *parser, char *defID);\n\nstatic GF_Err gf_bt_report(GF_BTParser *parser, GF_Err e, char *format, ...)\n{\n#ifndef GPAC_DISABLE_LOG\n\tif (format && gf_log_tool_level_on(GF_LOG_PARSER, e ? GF_LOG_ERROR : GF_LOG_WARNING)) {\n\t\tchar szMsg[2048];\n\t\tva_list args;\n\t\tva_start(args, format);\n\t\tvsnprintf(szMsg, 2048, format, args);\n\t\tva_end(args);\n\t\tGF_LOG((u32) (e ? GF_LOG_ERROR : GF_LOG_WARNING), GF_LOG_PARSER, (\"[BT/WRL Parsing] %s (line %d)\\n\", szMsg, parser->line));\n\t}\n#endif\n\tif (e) parser->last_error = e;\n\treturn e;\n}\n\n\nvoid gf_bt_check_line(GF_BTParser *parser)\n{\n\twhile (1) {\n\t\tswitch (parser->line_buffer[parser->line_pos]) {\n\t\tcase ' ':\n\t\tcase '\\t':\n\t\tcase '\\n':\n\t\tcase '\\r':\n\t\t\tparser->line_pos++;\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (parser->line_buffer[parser->line_pos]=='#') {\n\t\tparser->line_size = parser->line_pos;\n\t}\n\telse if ((parser->line_buffer[parser->line_pos]=='/') && (parser->line_buffer[parser->line_pos+1]=='/') ) parser->line_size = parser->line_pos;\n\n\tif (parser->line_size == parser->line_pos) {\n\t\t/*string based input - done*/\n\t\tif (!parser->gz_in) {\n\t\t\tparser->done = 1;\n\t\t\treturn;\n\t\t}\n\nnext_line:\n\t\tparser->line_start_pos = (s32) gf_gztell(parser->gz_in);\n\t\tparser->line_buffer[0] = 0;\n\t\tif (parser->unicode_type) {\n\t\t\tu8 c1, c2;\n\t\t\tunsigned short wchar;\n\t\t\tunsigned short l[BT_LINE_SIZE];\n\t\t\tunsigned short *dst = l;\n\t\t\tBool is_ret = 0;\n\t\t\tu32 last_space_pos, last_space_pos_stream;\n\t\t\tu32 go = BT_LINE_SIZE - 1;\n\t\t\tlast_space_pos = last_space_pos_stream = 0;\n\t\t\twhile (go && !gf_gzeof(parser->gz_in) ) {\n\t\t\t\tc1 = gf_gzgetc(parser->gz_in);\n\t\t\t\tc2 = gf_gzgetc(parser->gz_in);\n\t\t\t\t/*Little-endian order*/\n\t\t\t\tif (parser->unicode_type==2) {\n\t\t\t\t\tif (c2) {\n\t\t\t\t\t\twchar = c2;\n\t\t\t\t\t\twchar <<=8;\n\t\t\t\t\t\twchar |= c1;\n\t\t\t\t\t}\n\t\t\t\t\telse wchar = c1;\n\t\t\t\t} else {\n\t\t\t\t\twchar = c1;\n\t\t\t\t\tif (c2) {\n\t\t\t\t\t\twchar <<= 8;\n\t\t\t\t\t\twchar |= c2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t*dst = wchar;\n\t\t\t\tif (wchar=='\\r') is_ret = 1;\n\t\t\t\telse if (wchar=='\\n') {\n\t\t\t\t\tdst++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (is_ret) {\n\t\t\t\t\tu32 fpos = (u32) gf_gztell(parser->gz_in);\n\t\t\t\t\tgf_gzseek(parser->gz_in, fpos-2, SEEK_SET);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (wchar==' ') {\n\t\t\t\t\t//last_space_pos_stream = (u32) gf_gztell(parser->gz_in);\n\t\t\t\t\tlast_space_pos = (u32) (dst - l);\n\t\t\t\t}\n\t\t\t\tdst++;\n\t\t\t\tgo--;\n\n\t\t\t}\n\t\t\t*dst = 0;\n\t\t\t/*long line, rewind stream to last space*/\n\t\t\tif (!go) {\n\t\t\t\tu32 rew_pos = (u32)  (gf_gztell(parser->gz_in) - 2*(dst - &l[last_space_pos]) );\n\t\t\t\tgf_gzseek(parser->gz_in, rew_pos, SEEK_SET);\n\t\t\t\tl[last_space_pos+1] = 0;\n\t\t\t}\n\t\t\t/*check eof*/\n\t\t\tif (l[0]==0xFFFF) {\n\t\t\t\tparser->done = 1;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t/*convert to mbc string*/\n\t\t\tdst = l;\n\t\t\tgf_utf8_wcstombs(parser->line_buffer, BT_LINE_SIZE, (const unsigned short **) &dst);\n\n\t\t\tif (!strlen(parser->line_buffer) && gf_gzeof(parser->gz_in)) {\n\t\t\t\tparser->done = 1;\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\tif ((gf_gzgets(parser->gz_in, parser->line_buffer, BT_LINE_SIZE) == NULL)\n\t\t\t        || (!strlen(parser->line_buffer) && gf_gzeof(parser->gz_in))) {\n\t\t\t\tparser->done = 1;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t/*watchout for long lines*/\n\t\t\tif (1 + strlen(parser->line_buffer) == BT_LINE_SIZE) {\n\t\t\t\tu32 rew, pos, go;\n\t\t\t\trew = 0;\n\t\t\t\tgo = 1;\n\t\t\t\twhile (go) {\n\t\t\t\t\tswitch (parser->line_buffer[strlen(parser->line_buffer)-1]) {\n\t\t\t\t\tcase ' ':\n\t\t\t\t\tcase ',':\n\t\t\t\t\tcase '[':\n\t\t\t\t\tcase ']':\n\t\t\t\t\t\tgo = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tparser->line_buffer[strlen(parser->line_buffer)-1] = 0;\n\t\t\t\t\t\trew++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpos = (u32) gf_gztell(parser->gz_in);\n\t\t\t\tgf_gzseek(parser->gz_in, pos-rew, SEEK_SET);\n\t\t\t}\n\t\t}\n\n\n\t\twhile (1) {\n\t\t\tchar c;\n\t\t\tu32 len = (u32) strlen(parser->line_buffer);\n\t\t\tif (!len) break;\n\t\t\tc = parser->line_buffer[len-1];\n\t\t\tif (!strchr(\"\\n\\r\\t\", c)) break;\n\t\t\tparser->line_buffer[len-1] = 0;\n\t\t}\n\n\n\t\tparser->line_size = (u32) strlen(parser->line_buffer);\n\t\tparser->line_pos = 0;\n\t\tparser->line++;\n\n\t\t{\n\t\t\tu32 pos = (u32) gf_gztell(parser->gz_in);\n\t\t\tif (pos>=parser->file_pos) {\n\t\t\t\tparser->file_pos = pos;\n\t\t\t\tif (parser->line>1) gf_set_progress(\"BT Parsing\", pos, parser->file_size);\n\t\t\t}\n\t\t}\n\n\t\twhile ((parser->line_buffer[parser->line_pos]==' ') || (parser->line_buffer[parser->line_pos]=='\\t'))\n\t\t\tparser->line_pos++;\n\t\tif ( (parser->line_buffer[parser->line_pos]=='#')\n\t\t        || ( (parser->line_buffer[parser->line_pos]=='/') && (parser->line_buffer[parser->line_pos+1]=='/')) ) {\n\n\t\t\tif (parser->line==1) {\n\t\t\t\tif (strstr(parser->line_buffer, \"VRML\")) {\n\t\t\t\t\tif (strstr(parser->line_buffer, \"VRML V2.0\")) parser->is_wrl = 1;\n\t\t\t\t\t/*although not std, many files use this*/\n\t\t\t\t\telse if (strstr(parser->line_buffer, \"VRML2.0\")) parser->is_wrl = 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\tgf_bt_report(parser, GF_NOT_SUPPORTED, \"%s: VRML Version Not Supported\", parser->line_buffer);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (strstr(parser->line_buffer, \"X3D\")) {\n\t\t\t\t\tif (strstr(parser->line_buffer, \"X3D V3.0\")) parser->is_wrl = 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\tgf_bt_report(parser, GF_NOT_SUPPORTED, \"%s: X3D Version Not Supported\", parser->line_buffer);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!strnicmp(parser->line_buffer+parser->line_pos, \"#define \", 8) && !parser->block_comment) {\n\t\t\t\tchar *buf, *sep;\n\t\t\t\tparser->line_pos+=8;\n\t\t\t\tbuf = parser->line_buffer+parser->line_pos;\n\t\t\t\tsep = strchr(buf, ' ');\n\t\t\t\tif (sep && (sep[1]!='\\n') ) {\n\t\t\t\t\tBTDefSymbol *def;\n\t\t\t\t\tGF_SAFEALLOC(def, BTDefSymbol);\n\t\t\t\t\tif (!def) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"Fail to allocate DEF node\\n\"));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tsep[0] = 0;\n\t\t\t\t\tdef->name = gf_strdup(buf);\n\t\t\t\t\tsep[0] = ' ';\n\t\t\t\t\tbuf = sep+1;\n\t\t\t\t\twhile (strchr(\" \\t\", buf[0])) buf++;\n\t\t\t\t\tdef->value = gf_strdup(buf);\n\t\t\t\t\tgf_list_add(parser->def_symbols, def);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!strnicmp(parser->line_buffer+parser->line_pos, \"#if \", 4)) {\n\t\t\t\tu32 len = 0;\n\t\t\t\tparser->line_pos+=4;\n\t\t\t\twhile (1) {\n\t\t\t\t\tif (parser->line_pos+(s32)len==parser->line_size) break;\n\t\t\t\t\tif (strchr(\" \\n\\t\", parser->line_buffer[parser->line_pos+len]))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tlen++;\n\t\t\t\t}\n\t\t\t\tif (len) {\n\t\t\t\t\tif (len==1) {\n\t\t\t\t\t\tif (!strnicmp(parser->line_buffer+parser->line_pos, \"0\", 1)) {\n\t\t\t\t\t\t\tparser->block_comment++;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tu32 i, count;\n\t\t\t\t\t\tchar *keyWord = NULL;\n\t\t\t\t\t\tcount = gf_list_count(parser->def_symbols);\n\t\t\t\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\t\t\t\tBTDefSymbol *def = (BTDefSymbol *)gf_list_get(parser->def_symbols, i);\n\t\t\t\t\t\t\tif (!strnicmp(parser->line_buffer+parser->line_pos, def->name, len)) {\n\t\t\t\t\t\t\t\tkeyWord = def->value;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (keyWord && !strcmp(keyWord, \"0\")) {\n\t\t\t\t\t\t\tparser->block_comment++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!strnicmp(parser->line_buffer+parser->line_pos, \"#endif\", 6)) {\n\t\t\t\tif (parser->block_comment) parser->block_comment--;\n\t\t\t}\n\t\t\telse if (!strnicmp(parser->line_buffer+parser->line_pos, \"#else\", 5)) {\n\t\t\t\tif (parser->block_comment)\n\t\t\t\t\tparser->block_comment--;\n\t\t\t\telse\n\t\t\t\t\tparser->block_comment++;\n\t\t\t}\n\t\t\telse if (!strnicmp(parser->line_buffer+parser->line_pos, \"#size\", 5)) {\n\t\t\t\tchar *buf;\n\t\t\t\tparser->line_pos+=6;\n\t\t\t\tbuf = parser->line_buffer+parser->line_pos;\n\t\t\t\twhile (strchr(\" \\t\", buf[0]))\n\t\t\t\t\tbuf++;\n\t\t\t\tsscanf(buf, \"%dx%d\", &parser->def_w, &parser->def_h);\n\t\t\t}\n\t\t\tgoto next_line;\n\t\t}\n\n\t\tif (parser->block_comment)\n\t\t\tgoto next_line;\n\n\t\t/*brute-force replacement of defined symbols (!!FIXME - no mem checking done !!)*/\n\t\tif (parser->line_pos < parser->line_size) {\n\t\t\tu32 i, count;\n\t\t\tcount = gf_list_count(parser->def_symbols);\n\t\t\twhile (1) {\n\t\t\t\tBool found = 0;\n\t\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\t\tu32 symb_len, val_len, copy_len;\n\t\t\t\t\tBTDefSymbol *def = (BTDefSymbol *)gf_list_get(parser->def_symbols, i);\n\t\t\t\t\tchar *start = strstr(parser->line_buffer, def->name);\n\t\t\t\t\tif (!start) continue;\n\t\t\t\t\tsymb_len = (u32) strlen(def->name);\n\t\t\t\t\tif (!strchr(\" \\n\\r\\t,[]{}\\'\\\"\", start[symb_len])) continue;\n\t\t\t\t\tval_len = (u32) strlen(def->value);\n\t\t\t\t\tcopy_len = (u32) strlen(start + symb_len) + 1;\n\t\t\t\t\tmemmove(start + val_len, start + symb_len, sizeof(char)*copy_len);\n\t\t\t\t\tmemcpy(start, def->value, sizeof(char)*val_len);\n\t\t\t\t\tparser->line_size = (u32) strlen(parser->line_buffer);\n\t\t\t\t\tfound = 1;\n\t\t\t\t}\n\t\t\t\tif (!found) break;\n\t\t\t}\n\t\t}\n\t}\n\tif (!parser->line_size) {\n\t\tif (!gf_gzeof(parser->gz_in)) gf_bt_check_line(parser);\n\t\telse parser->done = 1;\n\t}\n\telse if (!parser->done && (parser->line_size == parser->line_pos)) gf_bt_check_line(parser);\n}\n\nvoid gf_bt_force_line(GF_BTParser *parser)\n{\n\tparser->line_pos = parser->line_size;\n}\n\nBool gf_bt_check_code(GF_BTParser *parser, char code)\n{\n\tgf_bt_check_line(parser);\n\tif (parser->line_buffer[parser->line_pos]==code) {\n\t\tparser->line_pos++;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nchar *gf_bt_get_next(GF_BTParser *parser, Bool point_break)\n{\n\tu32 has_quote;\n\tBool go = 1;\n\ts32 i;\n\tgf_bt_check_line(parser);\n\ti=0;\n\thas_quote = 0;\n\twhile (go) {\n\t\tif (parser->line_buffer[parser->line_pos + i] == '\\\"') {\n\t\t\tif (!has_quote) has_quote = 1;\n\t\t\telse has_quote = 0;\n\t\t\tparser->line_pos += 1;\n\n\t\t\tif (parser->line_pos+i==parser->line_size) break;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!has_quote) {\n\t\t\tswitch (parser->line_buffer[parser->line_pos + i]) {\n\t\t\tcase 0:\n\t\t\tcase ' ':\n\t\t\tcase '\\t':\n\t\t\tcase '\\r':\n\t\t\tcase '\\n':\n\t\t\tcase '{':\n\t\t\tcase '}':\n\t\t\tcase ']':\n\t\t\tcase '[':\n\t\t\tcase ',':\n\t\t\t\tgo = 0;\n\t\t\t\tbreak;\n\t\t\tcase '.':\n\t\t\t\tif (point_break) go = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!go) break;\n\t\t}\n\t\tparser->cur_buffer[i] = parser->line_buffer[parser->line_pos + i];\n\t\ti++;\n\t\tif (parser->line_pos+i==parser->line_size) break;\n\t}\n\tparser->cur_buffer[i] = 0;\n\tparser->line_pos += i;\n\treturn parser->cur_buffer;\n}\n\nchar *gf_bt_get_string(GF_BTParser *parser, u8 string_delim)\n{\n\tchar *res;\n\ts32 i, size;\n\n#define\tBT_STR_CHECK_ALLOC\t\\\n\t\tif (i==size) {\t\t\\\n\t\t\tres = (char*)gf_realloc(res, sizeof(char) * (size+500+1));\t\\\n\t\t\tsize += 500;\t\\\n\t\t}\t\\\n\n\tres = (char*)gf_malloc(sizeof(char) * 500);\n\tsize = 500;\n\twhile (parser->line_buffer[parser->line_pos]==' ') parser->line_pos++;\n\n\tif (parser->line_pos==parser->line_size) {\n\t\tif (gf_gzeof(parser->gz_in)) return NULL;\n\t\tgf_bt_check_line(parser);\n\t}\n\tif (!string_delim) string_delim = '\"';\n\n\ti=0;\n\twhile (1) {\n\t\tif (parser->line_buffer[parser->line_pos] == string_delim)\n\t\t\tif ( !parser->line_pos || (parser->line_buffer[parser->line_pos-1] != '\\\\') ) break;\n\n\t\tBT_STR_CHECK_ALLOC\n\n\t\tif ((parser->line_buffer[parser->line_pos]=='/') && (parser->line_buffer[parser->line_pos+1]=='/') && (parser->line_buffer[parser->line_pos-1]!=':') ) {\n\t\t\t/*this looks like a comment*/\n\t\t\tif (!strchr(&parser->line_buffer[parser->line_pos], string_delim)) {\n\t\t\t\tgf_bt_check_line(parser);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif ((parser->line_buffer[parser->line_pos] != '\\\\') || (parser->line_buffer[parser->line_pos+1] != string_delim)) {\n\t\t\t/*handle UTF-8 - WARNING: if parser is in unicode string is already utf8 multibyte chars*/\n\t\t\tif (!parser->unicode_type && parser->line_buffer[parser->line_pos] & 0x80) {\n\t\t\t\tchar c = parser->line_buffer[parser->line_pos];\n\t\t\t\t/*non UTF8 (likely some win-CP)*/\n\t\t\t\tif ( (parser->line_buffer[parser->line_pos+1] & 0xc0) != 0x80) {\n\t\t\t\t\tres[i] = 0xc0 | ( (parser->line_buffer[parser->line_pos] >> 6) & 0x3 );\n\t\t\t\t\ti++;\n\t\t\t\t\tBT_STR_CHECK_ALLOC\n\t\t\t\t\tparser->line_buffer[parser->line_pos] &= 0xbf;\n\t\t\t\t}\n\t\t\t\t/*UTF8 2 bytes char*/\n\t\t\t\telse if ( (c & 0xe0) == 0xc0) {\n\t\t\t\t\tres[i] = parser->line_buffer[parser->line_pos];\n\t\t\t\t\tparser->line_pos++;\n\t\t\t\t\ti++;\n\t\t\t\t\tBT_STR_CHECK_ALLOC\n\t\t\t\t}\n\t\t\t\t/*UTF8 3 bytes char*/\n\t\t\t\telse if ( (c & 0xf0) == 0xe0) {\n\t\t\t\t\tres[i] = parser->line_buffer[parser->line_pos];\n\t\t\t\t\tparser->line_pos++;\n\t\t\t\t\ti++;\n\t\t\t\t\tBT_STR_CHECK_ALLOC\n\t\t\t\t\tres[i] = parser->line_buffer[parser->line_pos];\n\t\t\t\t\tparser->line_pos++;\n\t\t\t\t\ti++;\n\t\t\t\t\tBT_STR_CHECK_ALLOC\n\t\t\t\t}\n\t\t\t\t/*UTF8 4 bytes char*/\n\t\t\t\telse if ( (c & 0xf8) == 0xf0) {\n\t\t\t\t\tres[i] = parser->line_buffer[parser->line_pos];\n\t\t\t\t\tparser->line_pos++;\n\t\t\t\t\ti++;\n\t\t\t\t\tBT_STR_CHECK_ALLOC\n\t\t\t\t\tres[i] = parser->line_buffer[parser->line_pos];\n\t\t\t\t\tparser->line_pos++;\n\t\t\t\t\ti++;\n\t\t\t\t\tBT_STR_CHECK_ALLOC\n\t\t\t\t\tres[i] = parser->line_buffer[parser->line_pos];\n\t\t\t\t\tparser->line_pos++;\n\t\t\t\t\ti++;\n\t\t\t\t\tBT_STR_CHECK_ALLOC\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tres[i] = parser->line_buffer[parser->line_pos];\n\t\t\ti++;\n\t\t}\n\t\tparser->line_pos++;\n\t\tif (parser->line_pos==parser->line_size) {\n\t\t\tgf_bt_check_line(parser);\n\t\t}\n\n\t}\n\n#undef\tBT_STR_CHECK_ALLOC\n\n\tres[i] = 0;\n\tparser->line_pos += 1;\n\treturn res;\n}\n\nBool gf_bt_check_externproto_field(GF_BTParser *parser, char *str)\n{\n\tif (!parser->is_extern_proto_field) return 0;\n\tif (!strcmp(str, \"\") || !strcmp(str, \"field\") || !strcmp(str, \"eventIn\") || !strcmp(str, \"eventOut\") || !strcmp(str, \"exposedField\")) {\n\t\tparser->last_error = GF_EOS;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic Bool check_keyword(GF_BTParser *parser, char *str, s32 *val)\n{\n\ts32 res;\n\tchar *sep;\n\tsep = strchr(str, '$');\n\tif (!sep) return 0;\n\tsep++;\n\tif (!strcmp(sep, \"F1\")) res = GF_KEY_F1;\n\telse if (!strcmp(sep, \"F2\")) res = GF_KEY_F2;\n\telse if (!strcmp(sep, \"F3\")) res = GF_KEY_F3;\n\telse if (!strcmp(sep, \"F4\")) res = GF_KEY_F4;\n\telse if (!strcmp(sep, \"F5\")) res = GF_KEY_F5;\n\telse if (!strcmp(sep, \"F6\")) res = GF_KEY_F6;\n\telse if (!strcmp(sep, \"F7\")) res = GF_KEY_F7;\n\telse if (!strcmp(sep, \"F8\")) res = GF_KEY_F8;\n\telse if (!strcmp(sep, \"F9\")) res = GF_KEY_F9;\n\telse if (!strcmp(sep, \"F10\")) res = GF_KEY_F10;\n\telse if (!strcmp(sep, \"F11\")) res = GF_KEY_F11;\n\telse if (!strcmp(sep, \"F12\")) res = GF_KEY_F12;\n\telse if (!strcmp(sep, \"HOME\")) res = GF_KEY_HOME;\n\telse if (!strcmp(sep, \"END\")) res = GF_KEY_END;\n\telse if (!strcmp(sep, \"PREV\")) res = GF_KEY_PAGEUP;\n\telse if (!strcmp(sep, \"NEXT\")) res = GF_KEY_PAGEDOWN;\n\telse if (!strcmp(sep, \"UP\")) res = GF_KEY_UP;\n\telse if (!strcmp(sep, \"DOWN\")) res = GF_KEY_DOWN;\n\telse if (!strcmp(sep, \"LEFT\")) res = GF_KEY_LEFT;\n\telse if (!strcmp(sep, \"RIGHT\")) res = GF_KEY_RIGHT;\n\telse if (!strcmp(sep, \"RETURN\")) res = GF_KEY_ENTER;\n\telse if (!strcmp(sep, \"BACK\")) res = GF_KEY_BACKSPACE;\n\telse if (!strcmp(sep, \"TAB\")) res = GF_KEY_TAB;\n\telse if (strlen(sep)==1) {\n\t\tchar c;\n\t\tsscanf(sep, \"%c\", &c);\n\t\tres = c;\n\t} else {\n\t\tgf_bt_report(parser, GF_OK, \"unrecognized keyword %s - skipping\", str);\n\t\tres = 0;\n\t}\n\tif (strchr(str, '-')) *val = -res;\n\telse *val = res;\n\treturn 1;\n}\n\nGF_Err gf_bt_parse_float(GF_BTParser *parser, const char *name, Fixed *val)\n{\n\ts32 var;\n\tFloat f;\n\tchar *str = gf_bt_get_next(parser, 0);\n\tif (!str) return parser->last_error = GF_IO_ERR;\n\tif (gf_bt_check_externproto_field(parser, str)) return GF_OK;\n\n\tif (check_keyword(parser, str, &var)) {\n\t\t*val = INT2FIX(var);\n\t\treturn GF_OK;\n\t}\n\tif (sscanf(str, \"%g\", &f) != 1) {\n\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"%s: Number expected\", name);\n\t}\n\t*val = FLT2FIX(f);\n\treturn GF_OK;\n}\nGF_Err gf_bt_parse_double(GF_BTParser *parser, const char *name, SFDouble *val)\n{\n\tchar *str = gf_bt_get_next(parser, 0);\n\tif (!str) return parser->last_error = GF_IO_ERR;\n\tif (gf_bt_check_externproto_field(parser, str)) return GF_OK;\n\tif (sscanf(str, \"%lf\", val) != 1) {\n\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"%s: Number expected\", name);\n\t}\n\treturn GF_OK;\n}\nGF_Err gf_bt_parse_int(GF_BTParser *parser, const char *name, SFInt32 *val)\n{\n\tchar *str = gf_bt_get_next(parser, 0);\n\tif (!str) return parser->last_error = GF_IO_ERR;\n\tif (gf_bt_check_externproto_field(parser, str)) return GF_OK;\n\n\tif (check_keyword(parser, str, val)) return GF_OK;\n\t/*URL ODID*/\n\tif (!strnicmp(str, \"od:\", 3)) str += 3;\n\tif (sscanf(str, \"%d\", val) != 1) {\n\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"%s: Number expected\", name);\n\t}\n\treturn GF_OK;\n}\nGF_Err gf_bt_parse_bool(GF_BTParser *parser, const char *name, SFBool *val)\n{\n\tchar *str = gf_bt_get_next(parser, 0);\n\tif (!str) return parser->last_error = GF_IO_ERR;\n\tif (gf_bt_check_externproto_field(parser, str)) return GF_OK;\n\n\tif (!stricmp(str, \"true\") || !strcmp(str, \"1\") ) {\n\t\t*val = 1;\n\t}\n\telse if (!stricmp(str, \"false\") || !strcmp(str, \"0\") ) {\n\t\t*val = 0;\n\t} else {\n\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"%s: Boolean expected\", name);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err gf_bt_parse_color(GF_BTParser *parser, const char *name, SFColor *col)\n{\n\tFloat f;\n\tu32 val;\n\tchar *str = gf_bt_get_next(parser, 0);\n\tif (!str) return parser->last_error = GF_IO_ERR;\n\tif (gf_bt_check_externproto_field(parser, str)) return GF_OK;\n\n\tif (sscanf(str, \"%f\", &f) == 1) {\n\t\tcol->red = FLT2FIX(f);\n\t\t/*many VRML files use ',' separator*/\n\t\tgf_bt_check_code(parser, ',');\n\t\tgf_bt_parse_float(parser, name, & col->green);\n\t\tgf_bt_check_code(parser, ',');\n\t\tgf_bt_parse_float(parser, name, & col->blue);\n\t\treturn parser->last_error;\n\t}\n\tval = gf_color_parse(str);\n\tif (!val) {\n\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"%s: Number or name expected\", name);\n\t}\n\tcol->red = INT2FIX((val>>16) & 0xFF) / 255;\n\tcol->green = INT2FIX((val>>8) & 0xFF) / 255;\n\tcol->blue = INT2FIX(val & 0xFF) / 255;\n\treturn parser->last_error;\n}\n\nGF_Err gf_bt_parse_colorRGBA(GF_BTParser *parser, const char *name, SFColorRGBA *col)\n{\n\tFloat f;\n\tchar *str = gf_bt_get_next(parser, 0);\n\tif (!str) return parser->last_error = GF_IO_ERR;\n\tif (gf_bt_check_externproto_field(parser, str)) return GF_OK;\n\n\t/*HTML code*/\n\tif (str[0]=='$') {\n\t\tu32 val;\n\t\tsscanf(str, \"%x\", &val);\n\t\tcol->red = INT2FIX((val>>24) & 0xFF) / 255;\n\t\tcol->green = INT2FIX((val>>16) & 0xFF) / 255;\n\t\tcol->blue = INT2FIX((val>>8) & 0xFF) / 255;\n\t\tcol->alpha = INT2FIX(val & 0xFF) / 255;\n\t\treturn parser->last_error;\n\t}\n\tif (sscanf(str, \"%f\", &f) != 1) {\n\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"%s: Number expected\", name);\n\t}\n\tcol->red = FLT2FIX(f);\n\tgf_bt_check_code(parser, ',');\n\tgf_bt_parse_float(parser, name, & col->green);\n\tgf_bt_check_code(parser, ',');\n\tgf_bt_parse_float(parser, name, & col->blue);\n\tgf_bt_check_code(parser, ',');\n\tgf_bt_parse_float(parser, name, & col->alpha);\n\treturn parser->last_error;\n}\n\nstatic void gf_bt_offset_time(GF_BTParser *parser, Double *time)\n{\n\tif (!parser->is_wrl) {\n\t\tDouble res;\n\t\tres = parser->au_time;\n\t\tres /= parser->bifs_es->timeScale;\n\t\t*time += res;\n\t}\n}\n\nstatic void gf_bt_check_time_offset(GF_BTParser *parser, GF_Node *n, GF_FieldInfo *info)\n{\n\tif (!n || !(parser->load->flags & GF_SM_LOAD_FOR_PLAYBACK)) return;\n\tif (gf_node_get_tag(n) != TAG_ProtoNode) {\n\t\tif (!stricmp(info->name, \"startTime\") || !stricmp(info->name, \"stopTime\"))\n\t\t\tgf_bt_offset_time(parser, (Double *)info->far_ptr);\n\t} else if (gf_sg_proto_field_is_sftime_offset(n, info)) {\n\t\tgf_bt_offset_time(parser, (Double *)info->far_ptr);\n\t}\n}\nstatic void gf_bt_update_timenode(GF_BTParser *parser, GF_Node *node)\n{\n\tif (!node || !(parser->load->flags & GF_SM_LOAD_FOR_PLAYBACK)) return;\n\n\tswitch (gf_node_get_tag(node)) {\n\tcase TAG_MPEG4_AnimationStream:\n\t\tgf_bt_offset_time(parser, & ((M_AnimationStream*)node)->startTime);\n\t\tgf_bt_offset_time(parser, & ((M_AnimationStream*)node)->stopTime);\n\t\tbreak;\n\tcase TAG_MPEG4_AudioBuffer:\n\t\tgf_bt_offset_time(parser, & ((M_AudioBuffer*)node)->startTime);\n\t\tgf_bt_offset_time(parser, & ((M_AudioBuffer*)node)->stopTime);\n\t\tbreak;\n\tcase TAG_MPEG4_AudioClip:\n\t\tgf_bt_offset_time(parser, & ((M_AudioClip*)node)->startTime);\n\t\tgf_bt_offset_time(parser, & ((M_AudioClip*)node)->stopTime);\n\t\tbreak;\n\tcase TAG_MPEG4_AudioSource:\n\t\tgf_bt_offset_time(parser, & ((M_AudioSource*)node)->startTime);\n\t\tgf_bt_offset_time(parser, & ((M_AudioSource*)node)->stopTime);\n\t\tbreak;\n\tcase TAG_MPEG4_MovieTexture:\n\t\tgf_bt_offset_time(parser, & ((M_MovieTexture*)node)->startTime);\n\t\tgf_bt_offset_time(parser, & ((M_MovieTexture*)node)->stopTime);\n\t\tbreak;\n\tcase TAG_MPEG4_TimeSensor:\n\t\tgf_bt_offset_time(parser, & ((M_TimeSensor*)node)->startTime);\n\t\tgf_bt_offset_time(parser, & ((M_TimeSensor*)node)->stopTime);\n\t\tbreak;\n\tcase TAG_ProtoNode:\n\t{\n\t\tu32 i, nbFields;\n\t\tGF_FieldInfo inf;\n\t\tnbFields = gf_node_get_num_fields_in_mode(node, GF_SG_FIELD_CODING_ALL);\n\t\tfor (i=0; i<nbFields; i++) {\n\t\t\tgf_node_get_field(node, i, &inf);\n\t\t\tif (inf.fieldType != GF_SG_VRML_SFTIME) continue;\n\t\t\tgf_bt_check_time_offset(parser, node, &inf);\n\t\t}\n\t}\n\tbreak;\n\t}\n}\n\n\nvoid gf_bt_sffield(GF_BTParser *parser, GF_FieldInfo *info, GF_Node *n)\n{\n\tswitch (info->fieldType) {\n\tcase GF_SG_VRML_SFINT32:\n\t\tgf_bt_parse_int(parser, info->name, (SFInt32 *)info->far_ptr);\n\t\tif (parser->last_error) return;\n\t\tbreak;\n\tcase GF_SG_VRML_SFBOOL:\n\t\tgf_bt_parse_bool(parser, info->name, (SFBool *)info->far_ptr);\n\t\tif (parser->last_error) return;\n\t\tbreak;\n\tcase GF_SG_VRML_SFFLOAT:\n\t\tgf_bt_parse_float(parser, info->name, (SFFloat *)info->far_ptr);\n\t\tif (parser->last_error) return;\n\t\tbreak;\n\tcase GF_SG_VRML_SFDOUBLE:\n\t\tgf_bt_parse_double(parser, info->name, (SFDouble *)info->far_ptr);\n\t\tif (parser->last_error) return;\n\t\tbreak;\n\tcase GF_SG_VRML_SFTIME:\n\t\tgf_bt_parse_double(parser, info->name, (SFDouble *)info->far_ptr);\n\t\tif (parser->last_error) return;\n\t\tgf_bt_check_time_offset(parser, n, info);\n\t\tbreak;\n\tcase GF_SG_VRML_SFCOLOR:\n\t\tgf_bt_parse_color(parser, info->name, (SFColor *)info->far_ptr);\n\t\tbreak;\n\tcase GF_SG_VRML_SFCOLORRGBA:\n\t\tgf_bt_parse_colorRGBA(parser, info->name, (SFColorRGBA *)info->far_ptr);\n\t\tbreak;\n\tcase GF_SG_VRML_SFVEC2F:\n\t\tgf_bt_parse_float(parser, info->name, & ((SFVec2f *)info->far_ptr)->x);\n\t\tif (parser->last_error) return;\n\t\t/*many VRML files use ',' separator*/\n\t\tgf_bt_check_code(parser, ',');\n\t\tgf_bt_parse_float(parser, info->name, & ((SFVec2f *)info->far_ptr)->y);\n\t\tif (parser->last_error) return;\n\t\tbreak;\n\tcase GF_SG_VRML_SFVEC2D:\n\t\tgf_bt_parse_double(parser, info->name, & ((SFVec2d *)info->far_ptr)->x);\n\t\tif (parser->last_error) return;\n\t\t/*many VRML files use ',' separator*/\n\t\tgf_bt_check_code(parser, ',');\n\t\tgf_bt_parse_double(parser, info->name, & ((SFVec2d *)info->far_ptr)->y);\n\t\tif (parser->last_error) return;\n\t\tbreak;\n\tcase GF_SG_VRML_SFVEC3F:\n\t\tgf_bt_parse_float(parser, info->name, & ((SFVec3f *)info->far_ptr)->x);\n\t\tif (parser->last_error) return;\n\t\t/*many VRML files use ',' separator*/\n\t\tgf_bt_check_code(parser, ',');\n\t\tgf_bt_parse_float(parser, info->name, & ((SFVec3f *)info->far_ptr)->y);\n\t\tif (parser->last_error) return;\n\t\t/*many VRML files use ',' separator*/\n\t\tgf_bt_check_code(parser, ',');\n\t\tgf_bt_parse_float(parser, info->name, & ((SFVec3f *)info->far_ptr)->z);\n\t\tif (parser->last_error) return;\n\t\tbreak;\n\tcase GF_SG_VRML_SFVEC3D:\n\t\tgf_bt_parse_double(parser, info->name, & ((SFVec3d *)info->far_ptr)->x);\n\t\tif (parser->last_error) return;\n\t\t/*many VRML files use ',' separator*/\n\t\tgf_bt_check_code(parser, ',');\n\t\tgf_bt_parse_double(parser, info->name, & ((SFVec3d *)info->far_ptr)->y);\n\t\tif (parser->last_error) return;\n\t\t/*many VRML files use ',' separator*/\n\t\tgf_bt_check_code(parser, ',');\n\t\tgf_bt_parse_double(parser, info->name, & ((SFVec3d *)info->far_ptr)->z);\n\t\tif (parser->last_error) return;\n\t\tbreak;\n\tcase GF_SG_VRML_SFVEC4F:\n\t\tgf_bt_parse_float(parser, info->name, & ((SFVec4f *)info->far_ptr)->x);\n\t\tif (parser->last_error) return;\n\t\t/*many VRML files use ',' separator*/\n\t\tgf_bt_check_code(parser, ',');\n\t\tgf_bt_parse_float(parser, info->name, & ((SFVec4f *)info->far_ptr)->y);\n\t\tif (parser->last_error) return;\n\t\t/*many VRML files use ',' separator*/\n\t\tgf_bt_check_code(parser, ',');\n\t\tgf_bt_parse_float(parser, info->name, & ((SFVec4f *)info->far_ptr)->z);\n\t\tif (parser->last_error) return;\n\t\t/*many VRML files use ',' separator*/\n\t\tgf_bt_check_code(parser, ',');\n\t\tgf_bt_parse_float(parser, info->name, & ((SFVec4f *)info->far_ptr)->q);\n\t\tif (parser->last_error) return;\n\t\tbreak;\n\tcase GF_SG_VRML_SFROTATION:\n\t\tgf_bt_parse_float(parser, info->name, & ((SFRotation *)info->far_ptr)->x);\n\t\tif (parser->last_error) return;\n\t\tgf_bt_parse_float(parser, info->name, & ((SFRotation *)info->far_ptr)->y);\n\t\tif (parser->last_error) return;\n\t\tgf_bt_parse_float(parser, info->name, & ((SFRotation *)info->far_ptr)->z);\n\t\tif (parser->last_error) return;\n\t\tgf_bt_parse_float(parser, info->name, & ((SFRotation *)info->far_ptr)->q);\n\t\tif (parser->last_error) return;\n\t\tbreak;\n\tcase GF_SG_VRML_SFSTRING:\n\t{\n\t\tu8 delim = 0;\n\t\tif (gf_bt_check_code(parser, '\\\"')) delim = '\\\"';\n\t\telse if (gf_bt_check_code(parser, '\\'')) delim = '\\'';\n\t\tif (delim) {\n\t\t\tchar *str = gf_bt_get_string(parser, delim);\n\t\t\tif (!str)\n\t\t\t\tgoto err;\n\t\t\tif (((SFString *)info->far_ptr)->buffer) gf_free(((SFString *)info->far_ptr)->buffer);\n\t\t\t((SFString *)info->far_ptr)->buffer = NULL;\n\t\t\tif (strlen(str))\n\t\t\t\t((SFString *)info->far_ptr)->buffer = str;\n\t\t\telse\n\t\t\t\tgf_free(str);\n\n\t\t\tif (n && (n->sgprivate->tag==TAG_MPEG4_BitWrapper)) {\n\t\t\t\tgf_sm_update_bitwrapper_buffer(n, parser->load->fileName);\n\t\t\t}\n\t\t} else {\n\t\t\tgoto err;\n\t\t}\n\t}\n\tbreak;\n\tcase GF_SG_VRML_SFURL:\n\t{\n\t\tu8 delim = 0;\n\t\tif (gf_bt_check_code(parser, '\\\"')) delim = '\\\"';\n\t\telse if (gf_bt_check_code(parser, '\\'')) delim = '\\'';\n\t\tif (delim) {\n\t\t\tSFURL *url = (SFURL *)info->far_ptr;\n\t\t\tchar *str = gf_bt_get_string(parser, delim);\n\t\t\tif (!str) goto err;\n\t\t\tif (url->url) gf_free(url->url);\n\t\t\turl->url = NULL;\n\t\t\turl->OD_ID = 0;\n\t\t\tif (strchr(str, '#')) {\n\t\t\t\turl->url = str;\n\t\t\t} else {\n\t\t\t\tu32 id = 0;\n\t\t\t\tchar *odstr = str;\n\t\t\t\tif (!strnicmp(str, \"od://\", 5)) odstr += 5;\n\t\t\t\telse if (!strnicmp(str, \"od:\", 3)) odstr += 3;\n\t\t\t\t/*be careful, an url like \"11-regression-test.mp4\" will return 1 on sscanf :)*/\n\t\t\t\tif (sscanf(odstr, \"%u\", &id) == 1) {\n\t\t\t\t\tchar szURL[20];\n\t\t\t\t\tsprintf(szURL, \"%u\", id);\n\t\t\t\t\tif (strcmp(szURL, odstr)) id=0;\n\t\t\t\t}\n\t\t\t\tif (id) {\n\t\t\t\t\turl->OD_ID = id;\n\t\t\t\t\tgf_free(str);\n\t\t\t\t} else {\n\t\t\t\t\turl->url = str;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\ts32 val;\n\t\t\tgf_bt_parse_int(parser, info->name, & val );\n\t\t\tif (parser->last_error) return;\n\t\t\t((SFURL *)info->far_ptr)->OD_ID = val;\n\t\t}\n\t}\n\tbreak;\n\tcase GF_SG_VRML_SFCOMMANDBUFFER:\n\t{\n\t\tSFCommandBuffer *cb = (SFCommandBuffer *)info->far_ptr;\n\t\tif (gf_bt_check_code(parser, '{')) {\n\t\t\tGF_Command *prev_com = parser->cur_com;\n\t\t\twhile (!parser->last_error) {\n\t\t\t\tif (gf_bt_check_code(parser, '}')) break;\n\t\t\t\tparser->last_error = gf_bt_parse_bifs_command(parser, NULL, cb->commandList);\n\t\t\t}\n\t\t\tparser->cur_com = prev_com;\n\t\t}\n\t}\n\tbreak;\n\tcase GF_SG_VRML_SFIMAGE:\n\t{\n\t\tu32 i, size, v;\n\t\tSFImage *img = (SFImage *)info->far_ptr;\n\t\tgf_bt_parse_int(parser, \"width\", (SFInt32 *)&img->width);\n\t\tif (parser->last_error) return;\n\t\tgf_bt_parse_int(parser, \"height\", (SFInt32 *)&img->height);\n\t\tif (parser->last_error) return;\n\t\tgf_bt_parse_int(parser, \"nbComp\", (SFInt32 *)&v);\n\t\tif (parser->last_error) return;\n\t\timg->numComponents = v;\n\t\tsize = img->width * img->height * img->numComponents;\n\t\tif (img->pixels) gf_free(img->pixels);\n\t\timg->pixels = (unsigned char*)gf_malloc(sizeof(char) * size);\n\t\tfor (i=0; i<size; i++) {\n\t\t\tchar *str = gf_bt_get_next(parser, 0);\n\t\t\tif (strstr(str, \"0x\")) sscanf(str, \"%x\", &v);\n\t\t\telse sscanf(str, \"%u\", &v);\n\t\t\tswitch (img->numComponents) {\n\t\t\tcase 1:\n\t\t\t\timg->pixels[i] = (char) v;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\timg->pixels[i] = (char) (v>>8)&0xFF;\n\t\t\t\timg->pixels[i+1] = (char) (v)&0xFF;\n\t\t\t\ti++;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\timg->pixels[i] = (char) (v>>16)&0xFF;\n\t\t\t\timg->pixels[i+1] = (char) (v>>8)&0xFF;\n\t\t\t\timg->pixels[i+2] = (char) (v)&0xFF;\n\t\t\t\ti+=2;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\timg->pixels[i] = (char) (v>>24)&0xFF;\n\t\t\t\timg->pixels[i+1] = (char) (v>>16)&0xFF;\n\t\t\t\timg->pixels[i+2] = (char) (v>>8)&0xFF;\n\t\t\t\timg->pixels[i+3] = (char) (v)&0xFF;\n\t\t\t\ti+=3;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tbreak;\n\tcase GF_SG_VRML_SFSCRIPT:\n\t{\n\t\tSFScript *sc = (SFScript *) info->far_ptr;\n\t\tif (!gf_bt_check_code(parser, '\\\"')) {\n\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"\\\" expected in Script\");\n\t\t}\n\t\tsc->script_text = (char*)gf_bt_get_string(parser, '\\\"');\n\t}\n\tbreak;\n\tcase GF_SG_VRML_SFATTRREF:\n\t{\n\t\tSFAttrRef *ar = (SFAttrRef*) info->far_ptr;\n\t\tchar *str = gf_bt_get_next(parser, 1);\n\t\tif (!gf_bt_check_code(parser, '.')) {\n\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"'.' expected in SFAttrRef\");\n\t\t} else {\n\t\t\tGF_FieldInfo pinfo;\n\t\t\tar->node = gf_bt_peek_node(parser, str);\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tif (gf_node_get_field_by_name(ar->node, str, &pinfo) != GF_OK) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"field %s is not a member of node %s\", str, gf_node_get_class_name(ar->node) );\n\t\t\t} else {\n\t\t\t\tar->fieldIndex = pinfo.fieldIndex;\n\t\t\t}\n\t\t}\n\n\t}\n\tbreak;\n\tdefault:\n\t\tparser->last_error = GF_NOT_SUPPORTED;\n\t\tbreak;\n\n\t}\n\tgf_bt_check_code(parser, ',');\n\treturn;\nerr:\n\tgf_bt_report(parser, GF_BAD_PARAM, \"%s: Invalid field syntax\", info->name);\n}\n\nvoid gf_bt_mffield(GF_BTParser *parser, GF_FieldInfo *info, GF_Node *n)\n{\n\tGF_FieldInfo sfInfo;\n\tBool force_single = 0;\n\n\tif (!gf_bt_check_code(parser, '[')) {\n\t\tif (parser->is_extern_proto_field) return;\n\t\tforce_single = 1;\n\t}\n\n\tsfInfo.fieldType = gf_sg_vrml_get_sf_type(info->fieldType);\n\tsfInfo.name = info->name;\n\tgf_sg_vrml_mf_reset(info->far_ptr, info->fieldType);\n\n\twhile (!gf_bt_check_code(parser, ']')) {\n\t\tgf_sg_vrml_mf_append(info->far_ptr, info->fieldType, &sfInfo.far_ptr);\n\t\tgf_bt_sffield(parser, &sfInfo, n);\n\t\tif (parser->last_error) return;\n\n\t\tgf_bt_check_code(parser, ',');\n\t\tif (force_single) break;\n\t}\n}\n\nBool gf_bt_check_ndt(GF_BTParser *parser, GF_FieldInfo *info, GF_Node *node, GF_Node *parent)\n{\n\tif (!node) return 1;\n\tif (parent->sgprivate->tag == TAG_MPEG4_Script) return 1;\n#ifndef GPAC_DISABLE_X3D\n\tif (parent->sgprivate->tag == TAG_X3D_Script) return 1;\n#endif\n\tif (node->sgprivate->tag == TAG_UndefinedNode) return 1;\n\n\t/*this handles undefined nodes*/\n\tif (gf_node_in_table(node, info->NDTtype)) return 1;\n\t/*not found*/\n\tgf_bt_report(parser, GF_BAD_PARAM, \"node %s not valid in field %s\\n\", gf_node_get_class_name(node), info->name);\n\tgf_node_unregister(node, parent);\n\treturn 0;\n}\n\nu32 gf_bt_get_next_node_id(GF_BTParser *parser)\n{\n\tu32 ID;\n\tGF_SceneGraph *sc = parser->load->scene_graph;\n\tif (parser->parsing_proto) sc = gf_sg_proto_get_graph(parser->parsing_proto);\n\tID = gf_sg_get_next_available_node_id(sc);\n\tif (parser->load->ctx && (ID>parser->load->ctx->max_node_id))\n\t\tparser->load->ctx->max_node_id = ID;\n\treturn ID;\n}\nu32 gf_bt_get_next_route_id(GF_BTParser *parser)\n{\n\tu32 ID;\n\tGF_SceneGraph *sg = parser->load->scene_graph;\n\tif (parser->parsing_proto) sg = gf_sg_proto_get_graph(parser->parsing_proto);\n\n\tID = gf_sg_get_next_available_route_id(sg);\n\tif (parser->load->ctx && (ID>parser->load->ctx->max_route_id))\n\t\tparser->load->ctx->max_route_id = ID;\n\treturn ID;\n}\nu32 gf_bt_get_next_proto_id(GF_BTParser *parser)\n{\n\tu32 ID;\n\tGF_SceneGraph *sc = parser->load->scene_graph;\n\tif (parser->parsing_proto) sc = gf_sg_proto_get_graph(parser->parsing_proto);\n\tID = gf_sg_get_next_available_proto_id(sc);\n\tif (parser->load->ctx && (ID>parser->load->ctx->max_node_id))\n\t\tparser->load->ctx->max_proto_id = ID;\n\treturn ID;\n}\n\nu32 gf_bt_get_def_id(GF_BTParser *parser, char *defName)\n{\n\tGF_Node *n=NULL;\n\tu32 ID=0;\n\tif (sscanf(defName, \"N%u\", &ID) == 1) {\n\t\tu32 k=1;\n\t\twhile (defName[k]) {\n\t\t\tif (strchr(\"0123456789\", defName[k])==0) {\n\t\t\t\tID = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tk++;\n\t\t}\n\t\tif (ID) {\n\t\t\tID ++;\n\t\t\tn = gf_sg_find_node(parser->load->scene_graph, ID);\n\t\t\tif (!n) {\n\t\t\t\tif (parser->load->ctx && (parser->load->ctx->max_node_id<ID)) parser->load->ctx->max_node_id=ID;\n\t\t\t\treturn ID;\n\t\t\t}\n\t\t}\n\t}\n\n\tID = gf_bt_get_next_node_id(parser);\n\tif (n) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (\"[BT Parsing] (line %d) Binary ID %d already assigned to %s - keeping internal ID %d\", parser->line, gf_node_get_name(n), ID));\n\t}\n\treturn ID;\n}\n\nBool gf_bt_set_field_is(GF_BTParser *parser, GF_FieldInfo *info, GF_Node *n)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_ProtoFieldInterface *pfield;\n\tGF_FieldInfo pinfo;\n\tchar *str;\n\tgf_bt_check_line(parser);\n\ti=0;\n\twhile ((parser->line_buffer[parser->line_pos + i] == ' ') || (parser->line_buffer[parser->line_pos + i] == '\\t')) i++;\n\tif (strnicmp(&parser->line_buffer[parser->line_pos + i] , \"IS\", 2)) return 0;\n\n\tgf_bt_get_next(parser, 0);\n\tstr = gf_bt_get_next(parser, 0);\n\n\t/*that's an ISed field*/\n\tpfield = gf_sg_proto_field_find_by_name(parser->parsing_proto, str);\n\tif (!pfield) {\n\t\tgf_bt_report(parser, GF_BAD_PARAM, \"%s: Unknown proto field\", str);\n\t\treturn 1;\n\t}\n\tgf_sg_proto_field_get_field(pfield, &pinfo);\n\te = gf_sg_proto_field_set_ised(parser->parsing_proto, pinfo.fieldIndex, n, info->fieldIndex);\n\tif (e) gf_bt_report(parser, GF_BAD_PARAM, \"IS: Invalid field type for field %s\", info->name);\n\treturn 1;\n}\n\nvoid gf_bt_check_unresolved_nodes(GF_BTParser *parser)\n{\n\tu32 i, count;\n\tcount = gf_list_count(parser->undef_nodes);\n\tif (!count) return;\n\tfor (i=0; i<count; i++) {\n\t\tGF_Node *n = (GF_Node *)gf_list_get(parser->undef_nodes, i);\n\t\tgf_bt_report(parser, GF_BAD_PARAM, \"Cannot find node %s\\n\", gf_node_get_name(n) );\n\t\tgf_node_unregister(n, NULL);\n\t}\n\tparser->last_error = GF_BAD_PARAM;\n}\n\nBool gf_bt_has_been_def(GF_BTParser *parser, char *node_name)\n{\n\tu32 i, count;\n\tcount = gf_list_count(parser->def_nodes);\n\tfor (i=0; i<count; i++) {\n\t\tGF_Node *n = (GF_Node *) gf_list_get(parser->def_nodes, i);\n\t\tif (!strcmp(gf_node_get_name(n), node_name)) return 1;\n\t}\n\treturn 0;\n}\n\nu32 gf_bt_get_node_tag(GF_BTParser *parser, char *node_name)\n{\n\tu32 tag;\n\t/*if VRML and allowing non MPEG4 nodes, use X3D*/\n\tif (parser->is_wrl && !(parser->load->flags & GF_SM_LOAD_MPEG4_STRICT)) {\n#ifndef GPAC_DISABLE_X3D\n\t\ttag = gf_node_x3d_type_by_class_name(node_name);\n\t\tif (!tag)\n#endif\n\t\t\ttag = gf_node_mpeg4_type_by_class_name(node_name);\n\t\tif (tag) return tag;\n#ifndef GPAC_DISABLE_X3D\n\t\tif (!strcmp(node_name, \"Rectangle\")) return TAG_X3D_Rectangle2D;\n\t\tif (!strcmp(node_name, \"Circle\")) return TAG_X3D_Circle2D;\n#endif\n\t} else {\n\t\ttag = gf_node_mpeg4_type_by_class_name(node_name);\n\t\tif (!tag) {\n\t\t\tif (!strcmp(node_name, \"Rectangle2D\")) return TAG_MPEG4_Rectangle;\n\t\t\tif (!strcmp(node_name, \"Circle2D\")) return TAG_MPEG4_Circle;\n#ifndef GPAC_DISABLE_X3D\n\t\t\tif (!(parser->load->flags & GF_SM_LOAD_MPEG4_STRICT)) return gf_node_x3d_type_by_class_name(node_name);\n#endif\n\t\t}\n\t}\n\treturn tag;\n}\n\nGF_Node *gf_bt_sf_node(GF_BTParser *parser, char *node_name, GF_Node *parent, char *szDEFName)\n{\n\tu32 tag, ID;\n\tBool is_script, replace_prev, register_def;\n\tGF_Proto *proto;\n\tGF_Node *node, *newnode, *undef_node;\n\tGF_FieldInfo info;\n\tBool init_node;\n\tchar *name;\n\tchar * str;\n\n\tinit_node = 0;\n\n\tif (node_name) {\n\t\tstr = node_name;\n\t} else {\n\t\tstr = gf_bt_get_next(parser, 0);\n\t}\n\tname = NULL;\n\tif (!strcmp(str, \"NULL\")) return NULL;\n\n\tID = 0;\n\tregister_def = 0;\n\treplace_prev = 0;\n\tundef_node = NULL;\n\tif (!strcmp(str, \"DEF\")) {\n\t\tregister_def = 1;\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\tname = gf_strdup(str);\n\t\tstr = gf_bt_get_next(parser, 0);\n\t} else if (szDEFName) {\n\t\tname = gf_strdup(szDEFName);\n\t\tregister_def = 1;\n\t}\n\tif (name) {\n\t\tundef_node = gf_sg_find_node_by_name(parser->load->scene_graph, name);\n\t\tif (undef_node) {\n\t\t\tgf_list_del_item(parser->peeked_nodes, undef_node);\n\t\t\tID = gf_node_get_id(undef_node);\n\t\t\t/*if we see twice a DEF N1 then force creation of a new node*/\n\t\t\tif (gf_bt_has_been_def(parser, name)) {\n\t\t\t\tundef_node = NULL;\n\t\t\t\tID = gf_bt_get_def_id(parser, name);\n\t\t\t\tgf_bt_report(parser, GF_OK, \"Node %s has been DEFed several times, IDs may get corrupted\", name);\n\t\t\t}\n\t\t} else {\n\t\t\tID = gf_bt_get_def_id(parser, name);\n\t\t}\n\t}\n\telse if (!strcmp(str, \"USE\")) {\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\tnode = gf_sg_find_node_by_name(parser->load->scene_graph, str);\n\t\tif (!node) {\n\t\t\t/*create a temp node (undefined)*/\n\t\t\tnode = gf_node_new(parser->load->scene_graph, TAG_UndefinedNode);\n\t\t\tID = gf_bt_get_def_id(parser, str);\n\t\t\tgf_node_set_id(node, ID, str);\n\t\t\tgf_node_register(node, NULL);\n\t\t\tgf_list_add(parser->undef_nodes, node);\n\t\t}\n\t\tgf_node_register(node, parent);\n\t\treturn node;\n\t}\n\tproto = NULL;\n\ttag = gf_bt_get_node_tag(parser, str);\n\tif (!tag) {\n\t\tGF_SceneGraph *sg = parser->load->scene_graph;\n\t\twhile (1) {\n\t\t\tproto = gf_sg_find_proto(sg, 0, str);\n\t\t\tif (proto) break;\n\t\t\tsg = sg->parent_scene;\n\t\t\tif (!sg) break;\n\t\t}\n\t\tif (!proto) {\n\t\t\t/*locate proto*/\n\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"%s: not a valid/supported node\", str);\n\t\t\treturn NULL;\n\t\t}\n\t\ttag = TAG_ProtoNode;\n\t}\n\tif (undef_node && (undef_node->sgprivate->tag == tag)) {\n\t\tnode = undef_node;\n\t} else {\n\t\tif (undef_node) replace_prev = 1;\n\t\tif (proto) {\n\t\t\tnode = gf_sg_proto_create_instance(parser->load->scene_graph, proto);\n\t\t} else {\n\t\t\tnode = gf_node_new(parser->load->scene_graph, tag);\n\t\t}\n\t\tif (!parser->parsing_proto) init_node = 1;\n\t}\n\tis_script = 0;\n\tif ((tag==TAG_MPEG4_Script)\n#ifndef GPAC_DISABLE_X3D\n\t        || (tag==TAG_X3D_Script)\n#endif\n\t   )\n\t\tis_script = 1;\n\n\tif (!node) {\n\t\tparser->last_error = GF_SG_UNKNOWN_NODE;\n\t\treturn NULL;\n\t}\n\tif (register_def) gf_list_add(parser->def_nodes, node);\n\n\tgf_node_register(node, parent);\n\n\t/*VRML: \"The transformation hierarchy shall be a directed acyclic graph; results are undefined if a node\n\tin the transformation hierarchy is its own ancestor\"\n\tthat's good, because the scene graph can't handle cyclic graphs (destroy will never be called).\n\tHowever we still have to register the node before parsing it, to update node registry and get correct IDs*/\n\tif (name) {\n\t\tif (!undef_node || replace_prev) {\n\t\t\tgf_node_set_id(node, ID, name);\n\t\t}\n\t\tgf_free(name);\n\t\tname = NULL;\n\t}\n\tif (!parser->parsing_proto) gf_bt_update_timenode(parser, node);\n\n\tif (gf_bt_check_code(parser, '{')) {\n\n\t\twhile (1) {\n\t\t\tif (gf_bt_check_code(parser, '}'))\n\t\t\t\tbreak;\n\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tif (!str) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"Invalid node syntax\");\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\t/*VRML/X3D specific */\n\t\t\tif (parser->is_wrl) {\n\t\t\t\t/*we ignore bboxCenter and bboxSize*/\n\t\t\t\tif (!strcmp(str, \"bboxCenter\") || !strcmp(str, \"bboxSize\")) {\n\t\t\t\t\tFixed f;\n\t\t\t\t\tgf_bt_parse_float(parser, \"x\", &f);\n\t\t\t\t\tgf_bt_parse_float(parser, \"y\", &f);\n\t\t\t\t\tgf_bt_parse_float(parser, \"z\", &f);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/*some VRML files declare routes almost anywhere*/\n\t\t\t\tif (!strcmp(str, \"ROUTE\")) {\n\t\t\t\t\tgf_bt_parse_route(parser, 1, 0, NULL);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tparser->last_error = gf_node_get_field_by_name(node, str, &info);\n\n\t\t\t/*check common VRML fields removed in MPEG4*/\n\t\t\tif (parser->last_error) {\n\t\t\t\tif (!parser->is_wrl) {\n\t\t\t\t\t/*we ignore 'solid' for MPEG4 box/cone/etc*/\n\t\t\t\t\tif (!strcmp(str, \"solid\")) {\n\t\t\t\t\t\tSFBool b;\n\t\t\t\t\t\tgf_bt_parse_bool(parser, \"solid\", &b);\n\t\t\t\t\t\tparser->last_error = GF_OK;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t/*we ignore 'description' for MPEG4 sensors*/\n\t\t\t\t\telse if (!strcmp(str, \"description\")) {\n\t\t\t\t\t\tchar *tmpstr = gf_bt_get_string(parser, 0);\n\t\t\t\t\t\tgf_free(tmpstr);\n\t\t\t\t\t\tparser->last_error = GF_OK;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t/*remaps X3D to old VRML/MPEG4*/\n\t\t\t\t\telse if ((tag==TAG_MPEG4_LOD) && !strcmp(str, \"children\")) {\n\t\t\t\t\t\tstr = \"level\";\n\t\t\t\t\t\tparser->last_error = gf_node_get_field_by_name(node, str, &info);\n\t\t\t\t\t}\n\t\t\t\t\telse if ((tag==TAG_MPEG4_Switch) && !strcmp(str, \"children\")) {\n\t\t\t\t\t\tstr = \"choice\";\n\t\t\t\t\t\tparser->last_error = gf_node_get_field_by_name(node, str, &info);\n\t\t\t\t\t}\n\t\t\t\t\telse if (!strcmp(str, \"enabled\")) {\n\t\t\t\t\t\tSFBool b;\n\t\t\t\t\t\tgf_bt_parse_bool(parser, \"collide\", &b);\n\t\t\t\t\t\tparser->last_error = GF_OK;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t/*remaps old VRML/MPEG4 to X3D if possible*/\n#ifndef GPAC_DISABLE_X3D\n\t\t\t\t\tif ((tag==TAG_X3D_LOD) && !strcmp(str, \"level\")) {\n\t\t\t\t\t\tstr = \"children\";\n\t\t\t\t\t\tparser->last_error = gf_node_get_field_by_name(node, str, &info);\n\t\t\t\t\t}\n\t\t\t\t\telse if ((tag==TAG_X3D_Switch) && !strcmp(str, \"choice\")) {\n\t\t\t\t\t\tstr = \"children\";\n\t\t\t\t\t\tparser->last_error = gf_node_get_field_by_name(node, str, &info);\n\t\t\t\t\t}\n\t\t\t\t\telse\n#endif\n\t\t\t\t\t\tif (!strcmp(str, \"collide\")) {\n\t\t\t\t\t\t\tSFBool b;\n\t\t\t\t\t\t\tgf_bt_parse_bool(parser, \"enabled\", &b);\n\t\t\t\t\t\t\tparser->last_error = GF_OK;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (is_script && parser->last_error) {\n\t\t\t\tu32 eType, fType;\n\n\t\t\t\tif (!strcmp(str, \"eventIn\") || !strcmp(str, \"inputOnly\")) eType = GF_SG_SCRIPT_TYPE_EVENT_IN;\n\t\t\t\telse if (!strcmp(str, \"eventOut\") || !strcmp(str, \"outputOnly\")) eType = GF_SG_SCRIPT_TYPE_EVENT_OUT;\n\t\t\t\telse if (!strcmp(str, \"field\") || !strcmp(str, \"initializeOnly\")) eType = GF_SG_SCRIPT_TYPE_FIELD;\n\t\t\t\telse {\n\t\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"%s: Unknown script event type\", str);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\t\tfType = gf_sg_field_type_by_name(str);\n\t\t\t\tif (fType==GF_SG_VRML_UNKNOWN) {\n\t\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"%s: Unknown script field type\", str);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tparser->last_error = GF_OK;\n\t\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\t\tgf_sg_script_field_new(node, eType, fType, str);\n\t\t\t\tparser->last_error = gf_node_get_field_by_name(node, str, &info);\n\n\t\t\t\tif (parser->parsing_proto && gf_bt_set_field_is(parser, &info, node)) continue;\n\t\t\t\tif ((eType == GF_SG_SCRIPT_TYPE_EVENT_IN) || (eType == GF_SG_SCRIPT_TYPE_EVENT_OUT)) continue;\n\t\t\t}\n\n\t\t\tif (parser->last_error) {\n\t\t\t\tgf_bt_report(parser, parser->last_error, \"%s: Unknown field\", str);\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tif (proto) gf_sg_proto_mark_field_loaded(node, &info);\n\t\t\tif (parser->parsing_proto && gf_bt_set_field_is(parser, &info, node)) continue;\n\n\t\t\tswitch (info.fieldType) {\n\t\t\tcase GF_SG_VRML_SFNODE:\n\t\t\t\t/*if redefining node reset it - this happens with CreateVrmlFromString*/\n\t\t\t\tif (* ((GF_Node **)info.far_ptr) ) {\n\t\t\t\t\tgf_node_unregister(* ((GF_Node **)info.far_ptr), node);\n\t\t\t\t\t* ((GF_Node **)info.far_ptr) = NULL;\n\t\t\t\t}\n\n\t\t\t\tnewnode = gf_bt_sf_node(parser, NULL, node, NULL);\n\t\t\t\tif (!newnode && parser->last_error) goto err;\n\t\t\t\tif (newnode) {\n\t\t\t\t\tif (!gf_bt_check_ndt(parser, &info, newnode, node)) goto err;\n\n\t\t\t\t\t* ((GF_Node **)info.far_ptr) = newnode;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GF_SG_VRML_MFNODE:\n\t\t\t{\n\t\t\t\tGF_ChildNodeItem *last = NULL;\n\t\t\t\tBool single_child = 0;\n\t\t\t\tif (!gf_bt_check_code(parser, '[')) {\n\t\t\t\t\tif (parser->is_wrl) single_child = 1;\n\t\t\t\t\telse break;\n\t\t\t\t}\n\n\t\t\t\t/*if redefining node reset it - this happens with CreateVrmlFromString*/\n\t\t\t\tif (undef_node==node) {\n\t\t\t\t\tgf_node_unregister_children(node, *(GF_ChildNodeItem **)info.far_ptr);\n\t\t\t\t\t*(GF_ChildNodeItem **)info.far_ptr = NULL;\n\t\t\t\t}\n\n\t\t\t\twhile (single_child || !gf_bt_check_code(parser, ']')) {\n\t\t\t\t\t/*VRML seems to allow that*/\n\t\t\t\t\tgf_bt_check_code(parser, ',');\n\t\t\t\t\tnewnode = gf_bt_sf_node(parser, NULL, node, NULL);\n\t\t\t\t\tif (!newnode && parser->last_error) goto err;\n\t\t\t\t\tif (newnode) {\n\t\t\t\t\t\tif (!gf_bt_check_ndt(parser, &info, newnode, node)) goto err;\n\t\t\t\t\t\tgf_node_list_add_child_last( (GF_ChildNodeItem **)info.far_ptr, newnode, &last);\n\t\t\t\t\t}\n\t\t\t\t\tif (single_child) break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (gf_sg_vrml_is_sf_field(info.fieldType)) {\n\t\t\t\t\tgf_bt_sffield(parser, &info, node);\n\t\t\t\t} else {\n\t\t\t\t\tgf_bt_mffield(parser, &info, node);\n\t\t\t\t}\n\t\t\t\tif (parser->last_error) goto err;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*VRML seems to allow that*/\n\t\t\tgf_bt_check_code(parser, ',');\n\t\t}\n\t}\n\t/*VRML seems to allow that*/\n\tgf_bt_check_code(parser, ',');\n\n\t/*we must init the node once ID is set in case we're creating rendering stacks*/\n\tif (init_node && (gf_node_get_tag(node)!=TAG_ProtoNode) ) gf_node_init(node);\n\n\t/*remove temp node*/\n\tif (replace_prev) {\n\t\tgf_node_replace(undef_node, node, 0);\n\t\tgf_node_unregister(undef_node, NULL);\n\t\tgf_list_del_item(parser->undef_nodes, undef_node);\n\t}\n\n\tif (!parser->parsing_proto && is_script && (parser->load->flags & GF_SM_LOAD_FOR_PLAYBACK) ) {\n\t\tif (parser->cur_com) {\n\t\t\tif (!parser->cur_com->scripts_to_load) parser->cur_com->scripts_to_load = gf_list_new();\n\t\t\tgf_list_add(parser->cur_com->scripts_to_load, node);\n\t\t} else {\n\t\t\t/*postpone script init since it may use routes/nodes not yet defined ...*/\n\t\t\tgf_list_add(parser->scripts, node);\n\t\t}\n\t}\n\t/*For Ivica: load proto as soon as found when in playback mode*/\n\tif ( (parser->load->flags & GF_SM_LOAD_FOR_PLAYBACK) && proto && !parser->parsing_proto) {\n\t\tparser->last_error = gf_sg_proto_load_code(node);\n\t}\n\treturn node;\n\nerr:\n\tgf_node_unregister(node, parent);\n\tif (name) gf_free(name);\n\treturn NULL;\n}\n/*\n\tlocate node, if not defined yet parse ahead in current AU\n\toptimization: we actually peek ALL DEF NODES till end of AU\n*/\nGF_Node *gf_bt_peek_node(GF_BTParser *parser, char *defID)\n{\n\tGF_Node *n, *the_node;\n\tu32 tag, ID;\n\tBool prev_is_insert = 0;\n\tchar *ret;\n\tchar nName[1000];\n\tu32 pos, line, line_pos, i, count;\n\n\tn = gf_sg_find_node_by_name(parser->load->scene_graph, defID);\n\tif (n) return n;\n\n\tcount = gf_list_count(parser->peeked_nodes);\n\tfor (i=0; i<count; i++) {\n\t\tn = (GF_Node *)gf_list_get(parser->peeked_nodes, i);\n\t\tif (!strcmp(gf_node_get_name(n), defID)) return n;\n\t}\n\n\tthe_node = NULL;\n\tpos = parser->line_start_pos;\n\tline_pos = parser->line_pos;\n\tline = parser->line;\n\tstrcpy(nName, defID);\n\n\tn = NULL;\n\twhile (!parser->done && !the_node) {\n\t\tchar *str = gf_bt_get_next(parser, 0);\n\t\tgf_bt_check_code(parser, '[');\n\t\tgf_bt_check_code(parser, ']');\n\t\tgf_bt_check_code(parser, '{');\n\t\tgf_bt_check_code(parser, '}');\n\t\tgf_bt_check_code(parser, ',');\n\t\tgf_bt_check_code(parser, '.');\n\n\t\tif ( (!prev_is_insert && !strcmp(str, \"AT\")) || !strcmp(str, \"PROTO\") ) {\n\t\t\t/*only check in current command (but be aware of conditionals..)*/\n\t\t\tif (gf_list_find(parser->bifs_au->commands, parser->cur_com)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(str, \"INSERT\")) prev_is_insert = 1;\n\t\telse prev_is_insert = 0;\n\n\t\tif (strcmp(str, \"DEF\")) continue;\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\tret = gf_strdup(str);\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\tif (!strcmp(str, \"ROUTE\")) {\n\t\t\tgf_free(ret);\n\t\t\tcontinue;\n\t\t}\n\n\t\ttag = gf_bt_get_node_tag(parser, str);\n\t\tif (!tag) {\n\t\t\tGF_Proto *p;\n\t\t\tGF_SceneGraph *sg = parser->load->scene_graph;\n\t\t\twhile (1) {\n\t\t\t\tp = gf_sg_find_proto(sg, 0, str);\n\t\t\t\tif (p) break;\n\t\t\t\tsg = sg->parent_scene;\n\t\t\t\tif (!sg) break;\n\t\t\t}\n\t\t\tif (!p) {\n\t\t\t\t/*locate proto*/\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"%s: not a valid/supported node\", str);\n\t\t\t\tgf_free(ret);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tn = gf_sg_proto_create_instance(parser->load->scene_graph, p);\n\t\t} else {\n\t\t\tn = gf_node_new(parser->load->scene_graph, tag);\n\t\t}\n\t\tID = gf_bt_get_def_id(parser, ret);\n\t\tif (n) {\n\t\t\tgf_node_set_id(n, ID, ret);\n\t\t\tgf_list_add(parser->peeked_nodes, n);\n\t\t\tif (!parser->parsing_proto) gf_node_init(n);\n\t\t\tif (!strcmp(ret, nName)) the_node = n;\n\t\t}\n\t\tgf_free(ret);\n\n\t\t/*NO REGISTER on peek (both scene graph or DEF list) because peek is only used to get node type\n\t\tand fields, never to insert in the graph*/\n\n\t\t/*go on till end of AU*/\n\t}\n\t/*restore context*/\n\tparser->done = 0;\n\tgf_gzrewind(parser->gz_in);\n\tgf_gzseek(parser->gz_in, pos, SEEK_SET);\n\tparser->line_pos = parser->line_size;\n\tgf_bt_check_line(parser);\n\tparser->line = line;\n\tparser->line_pos = line_pos;\n\n\treturn the_node;\n}\n\nu32 gf_bt_get_route(GF_BTParser *parser, char *name)\n{\n\tu32 i;\n\tGF_Command *com;\n\tGF_Route *r = gf_sg_route_find_by_name(parser->load->scene_graph, name);\n\tif (r) return r->ID;\n\ti=0;\n\twhile ((com = (GF_Command *)gf_list_enum(parser->inserted_routes, &i))) {\n\t\tif (com->def_name && !strcmp(com->def_name, name)) return com->RouteID;\n\t}\n\treturn 0;\n}\n\nBool gf_bt_route_id_used(GF_BTParser *parser, u32 ID)\n{\n\tu32 i;\n\tGF_Command *com;\n\tGF_Route *r = gf_sg_route_find(parser->load->scene_graph, ID);\n\tif (r) return 1;\n\ti=0;\n\twhile ((com = (GF_Command *)gf_list_enum(parser->inserted_routes, &i))) {\n\t\tif (com->RouteID == ID) return 1;\n\t}\n\treturn 0;\n}\n\nstatic u32 get_evt_type(char *eventName)\n{\n\tif (!strcmp(eventName, \"eventIn\") || !strcmp(eventName, \"inputOnly\")) return GF_SG_EVENT_IN;\n\telse if (!strcmp(eventName, \"eventOut\") || !strcmp(eventName, \"outputOnly\")) return GF_SG_EVENT_OUT;\n\telse if (!strcmp(eventName, \"field\") || !strcmp(eventName, \"initializeOnly\")) return GF_SG_EVENT_FIELD;\n\telse if (!strcmp(eventName, \"exposedField\") || !strcmp(eventName, \"inputOutput\")) return GF_SG_EVENT_EXPOSED_FIELD;\n\telse return GF_SG_EVENT_UNKNOWN;\n}\n\nGF_Err gf_bt_parse_proto(GF_BTParser *parser, char *proto_code, GF_List *proto_list)\n{\n\tGF_FieldInfo info;\n\tu32 fType, eType, QPType=0, pID;\n\tBool externProto;\n\tGF_Proto *proto, *prevproto;\n\tGF_ProtoFieldInterface *pfield;\n\tGF_SceneGraph *sg;\n\tchar *str, *name;\n\tchar szDefName[1024];\n\tBool isDEF;\n\n\tif (proto_code)\n\t\tstr = proto_code;\n\telse\n\t\tstr = gf_bt_get_next(parser, 0);\n\n\texternProto = !strcmp(str, \"EXTERNPROTO\") ? 1 : 0;\n\tstr = gf_bt_get_next(parser, 0);\n\tname = gf_strdup(str);\n\tif (!gf_bt_check_code(parser, '[')) {\n\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"[ expected in proto declare\");\n\t}\n\tpID = gf_bt_get_next_proto_id(parser);\n\t/*if redefinition remove it - WRL only, may be used by loadVRMLFormString*/\n\tif (!proto_list && parser->is_wrl) {\n\t\tproto = gf_sg_find_proto(parser->load->scene_graph, pID, name);\n\t\tif (proto) gf_sg_proto_del(proto);\n\t}\n\tproto = gf_sg_proto_new(parser->load->scene_graph, pID, name, proto_list ? 1 : 0);\n\tif (proto_list) gf_list_add(proto_list, proto);\n\tif (parser->load->ctx && (parser->load->ctx->max_proto_id<pID)) parser->load->ctx->max_proto_id = pID;\n\n\t/*hack for VRML, where externProto default field values are not mandatory*/\n\tparser->is_extern_proto_field = externProto;\n\n\tgf_free(name);\n\t/*get all fields*/\n\twhile (!parser->last_error && !gf_bt_check_code(parser, ']')) {\n\t\tstr = gf_bt_get_next(parser, 0);\n\nnext_field:\n\t\tif (gf_bt_check_code(parser, ']')) break;\n\n\t\teType = get_evt_type(str);\n\t\tif (eType==GF_SG_EVENT_UNKNOWN) {\n\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"%s: Unknown event type\", str);\n\t\t\tgoto err;\n\t\t}\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\tfType = gf_sg_field_type_by_name(str);\n\t\tif (fType==GF_SG_VRML_UNKNOWN) {\n\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"%s: Unknown field type\", str);\n\t\t\tgoto err;\n\t\t}\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\tpfield = gf_sg_proto_field_new(proto, fType, eType, str);\n\t\tif ((eType==GF_SG_EVENT_IN) || (eType==GF_SG_EVENT_OUT)) continue;\n\n\t\tgf_sg_proto_field_get_field(pfield, &info);\n\t\tif (fType==GF_SG_VRML_SFNODE) {\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tif (strcmp(str, \"NULL\")) {\n\t\t\t\tif ( (!strlen(str) || (get_evt_type(str)!=GF_SG_EVENT_UNKNOWN)) && parser->is_extern_proto_field) goto next_field;\n\t\t\t\tpfield->def_sfnode_value = gf_bt_sf_node(parser, str, NULL, NULL);\n\t\t\t}\n\t\t} else if (fType==GF_SG_VRML_MFNODE) {\n\t\t\tGF_ChildNodeItem *last = NULL;\n\t\t\tif (gf_bt_check_code(parser, '[')) {\n\t\t\t\twhile (1) {\n\t\t\t\t\tGF_Node *pf_node;\n\t\t\t\t\tif (gf_bt_check_code(parser, ']')) break;\n\t\t\t\t\tpf_node = gf_bt_sf_node(parser, NULL, NULL, NULL);\n\t\t\t\t\tif (pf_node) gf_node_list_add_child_last( &pfield->def_mfnode_value, pf_node, &last);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (gf_sg_vrml_is_sf_field(fType)) {\n\t\t\tgf_bt_sffield(parser, &info, NULL);\n\t\t\t/*value not specified for externproto*/\n\t\t\tif (parser->last_error==GF_EOS) {\n\t\t\t\tparser->last_error=GF_OK;\n\t\t\t\tgoto next_field;\n\t\t\t}\n\t\t} else {\n\t\t\tgf_bt_mffield(parser, &info, NULL);\n\t\t}\n\t\t/*check QP info*/\n\t\tif (!gf_bt_check_code(parser, '{')) continue;\n\t\tif (gf_bt_check_code(parser, '}')) continue;\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\tif (!strcmp(str, \"QP\")) {\n\t\t\tu32 nbBits, hasMin;\n\t\t\tFixed ftMin, ftMax;\n\t\t\tgf_bt_parse_int(parser, \"QPType\", (SFInt32*)&QPType);\n\n\t\t\tnbBits = 0;\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tif (!strcmp(str, \"nbBits\")) {\n\t\t\t\tgf_bt_parse_int(parser, \"nbBits\", (SFInt32*)&nbBits);\n\t\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\t}\n\t\t\thasMin = 0;\n\t\t\teType = 0;\n\t\t\tif (!strcmp(str, \"b\")) {\n\t\t\t\thasMin = 1;\n\t\t\t\tif (!gf_bt_check_code(parser, '{')) {\n\t\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"%s: Invalid proto coding parameter declare\", str);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tgf_bt_parse_float(parser, \"min\", &ftMin);\n\t\t\t\tgf_bt_parse_float(parser, \"max\", &ftMax);\n\t\t\t\tif (!gf_bt_check_code(parser, '}')) {\n\t\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"Invalid proto coding parameter declare\");\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tif (gf_sg_vrml_get_sf_type(fType) == GF_SG_VRML_SFINT32) {\n\t\t\t\t\teType = GF_SG_VRML_SFINT32;\n\t\t\t\t} else {\n\t\t\t\t\teType = GF_SG_VRML_SFFLOAT;\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_bifs_proto_field_set_aq_info(pfield, QPType, hasMin, eType, &ftMin, &ftMax, nbBits);\n\t\t\tif (!gf_bt_check_code(parser, '}')) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"Invalid proto coding parameter declare\");\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\t}\n\tparser->is_extern_proto_field = 0;\n\n\tif (externProto) {\n\t\tSFURL *url;\n\t\tBool has_urls = 0;\n\t\tif (gf_bt_check_code(parser, '[')) has_urls = 1;\n\n\t\tgf_sg_vrml_mf_reset(&proto->ExternProto, GF_SG_VRML_MFURL);\n\t\tdo {\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tgf_sg_vrml_mf_append(&proto->ExternProto, GF_SG_VRML_MFURL, (void **) &url);\n\t\t\tif (!strnicmp(str, \"od:\", 3)) {\n\t\t\t\tsscanf(str, \"od:%u\", &url->OD_ID);\n\t\t\t} else {\n\t\t\t\tif (!sscanf(str, \"%u\", &url->OD_ID)) {\n\t\t\t\t\turl->url = gf_strdup(str);\n\t\t\t\t} else {\n\t\t\t\t\tchar szURL[20];\n\t\t\t\t\tsprintf(szURL, \"%d\", url->OD_ID);\n\t\t\t\t\tif (strcmp(szURL, str)) {\n\t\t\t\t\t\turl->OD_ID = 0;\n\t\t\t\t\t\turl->url = gf_strdup(str);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (has_urls) {\n\t\t\t\tgf_bt_check_code(parser, ',');\n\t\t\t\tif (gf_bt_check_code(parser, ']')) has_urls = 0;\n\t\t\t}\n\t\t} while (has_urls);\n\t\treturn GF_OK;\n\t}\n\n\t/*parse proto code */\n\tif (!gf_bt_check_code(parser, '{')) {\n\t\tgf_bt_report(parser, GF_OK, \"empty proto body\");\n\t\treturn GF_OK;\n\t}\n\n\tprevproto = parser->parsing_proto;\n\tsg = parser->load->scene_graph;\n\tparser->parsing_proto = proto;\n\tparser->load->scene_graph = gf_sg_proto_get_graph(proto);\n\n\tisDEF = 0;\n\twhile (!gf_bt_check_code(parser, '}')) {\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\tif (!strcmp(str, \"PROTO\") || !strcmp(str, \"EXTERNPROTO\")) {\n\t\t\tgf_bt_parse_proto(parser, str, NULL);\n\t\t} else if (!strcmp(str, \"DEF\")) {\n\t\t\tisDEF = 1;\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tstrcpy(szDefName, str);\n\t\t} else if (!strcmp(str, \"ROUTE\")) {\n\t\t\tGF_Route *r = gf_bt_parse_route(parser, 1, 0, NULL);\n\t\t\tif (isDEF) {\n\t\t\t\tu32 rID = gf_bt_get_route(parser, szDefName);\n\t\t\t\tif (!rID) rID = gf_bt_get_next_route_id(parser);\n\t\t\t\tparser->last_error = gf_sg_route_set_id(r, rID);\n\t\t\t\tgf_sg_route_set_name(r, szDefName);\n\t\t\t\tisDEF = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tGF_Node *n = gf_bt_sf_node(parser, str, NULL, isDEF ? szDefName : NULL);\n\t\t\tisDEF = 0;\n\t\t\tif (!n) goto err;\n\t\t\tif ((0) && isDEF) {\n\t\t\t\tu32 ID = gf_bt_get_def_id(parser, szDefName);\n\t\t\t\tisDEF = 0;\n\t\t\t\tgf_node_set_id(n, ID, szDefName);\n\t\t\t}\n\t\t\tgf_sg_proto_add_node_code(proto, n);\n\t\t}\n\t}\n\tgf_bt_resolve_routes(parser, 1);\n\tgf_bt_check_unresolved_nodes(parser);\n\tparser->load->scene_graph = sg;\n\tparser->parsing_proto = prevproto;\n\treturn parser->last_error;\n\nerr:\n\tif (proto_list) gf_list_del_item(proto_list, proto);\n\tgf_sg_proto_del(proto);\n\treturn parser->last_error;\n}\n\n\nGF_Route *gf_bt_parse_route(GF_BTParser *parser, Bool skip_def, Bool is_insert, GF_Command *com)\n{\n\tGF_Route *r;\n\tchar *str, nstr[1000], rName[1000];\n\tu32 rID;\n\tGF_Node *orig, *dest;\n\tGF_FieldInfo orig_field, dest_field;\n\tGF_Err e;\n\n\trID = 0;\n\tstrcpy(nstr, gf_bt_get_next(parser, 1));\n\tif (!skip_def && !strcmp(nstr, \"DEF\")) {\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\tstrcpy(rName, str);\n\t\trID = gf_bt_get_route(parser, rName);\n\t\tif (!rID && (str[0]=='R') ) {\n\t\t\trID = atoi(&str[1]);\n\t\t\tif (rID) {\n\t\t\t\trID++;\n\t\t\t\tif (gf_bt_route_id_used(parser, rID)) rID = 0;\n\t\t\t}\n\t\t}\n\t\tif (!rID) rID = gf_bt_get_next_route_id(parser);\n\t\tstrcpy(nstr, gf_bt_get_next(parser, 1));\n\t}\n\torig = gf_bt_peek_node(parser, nstr);\n\tif (!orig) {\n\t\tgf_bt_report(parser, GF_BAD_PARAM, \"cannot find node %s\", nstr);\n\t\treturn NULL;\n\t}\n\tif (!gf_bt_check_code(parser, '.')) {\n\t\tgf_bt_report(parser, GF_BAD_PARAM, \". expected in route decl\");\n\t\treturn NULL;\n\t}\n\tstr = gf_bt_get_next(parser, 0);\n\te = gf_node_get_field_by_name(orig, str, &orig_field);\n\t/*VRML loosy syntax*/\n\tif ((e != GF_OK) && parser->is_wrl && !strnicmp(str, \"set_\", 4))\n\t\te = gf_node_get_field_by_name(orig, &str[4], &orig_field);\n\n\tif ((e != GF_OK) && parser->is_wrl && strstr(str, \"_changed\")) {\n\t\tchar *s = strstr(str, \"_changed\");\n\t\ts[0] = 0;\n\t\te = gf_node_get_field_by_name(orig, str, &orig_field);\n\t}\n\n\tif (e != GF_OK) {\n\t\tgf_bt_report(parser, GF_BAD_PARAM, \"%s not a field of node %s (%s)\", str, gf_node_get_name(orig), gf_node_get_class_name(orig));\n\t\treturn NULL;\n\t}\n\tstr = gf_bt_get_next(parser, 0);\n\tif (strcmp(str, \"TO\")) {\n\t\tgf_bt_report(parser, GF_BAD_PARAM, \"TO expected in route declaration - got \\\"%s\\\"\", str);\n\t\treturn NULL;\n\t}\n\n\tstrcpy(nstr, gf_bt_get_next(parser, 1));\n\tdest = gf_bt_peek_node(parser, nstr);\n\tif (!dest) {\n\t\tgf_bt_report(parser, GF_BAD_PARAM, \"cannot find node %s\", nstr);\n\t\treturn NULL;\n\t}\n\tif (!gf_bt_check_code(parser, '.')) {\n\t\tgf_bt_report(parser, GF_BAD_PARAM, \". expected in route decl\");\n\t\treturn NULL;\n\t}\n\tstr = gf_bt_get_next(parser, 0);\n\te = gf_node_get_field_by_name(dest, str, &dest_field);\n\t/*VRML loosy syntax*/\n\tif ((e != GF_OK) && parser->is_wrl && !strnicmp(str, \"set_\", 4))\n\t\te = gf_node_get_field_by_name(dest, &str[4], &dest_field);\n\n\tif ((e != GF_OK) && parser->is_wrl && strstr(str, \"_changed\")) {\n\t\tchar *s = strstr(str, \"_changed\");\n\t\ts[0] = 0;\n\t\te = gf_node_get_field_by_name(dest, str, &dest_field);\n\t}\n\n\tif (e != GF_OK) {\n\t\tgf_bt_report(parser, GF_BAD_PARAM, \"%s not a field of node %s (%s)\", str, gf_node_get_name(dest), gf_node_get_class_name(dest));\n\t\treturn NULL;\n\t}\n\tif (com) {\n\t\tcom->fromNodeID = gf_node_get_id(orig);\n\t\tcom->fromFieldIndex = orig_field.fieldIndex;\n\t\tcom->toNodeID = gf_node_get_id(dest);\n\t\tcom->toFieldIndex = dest_field.fieldIndex;\n\t\tif (rID) {\n\t\t\tcom->RouteID = rID;\n\t\t\tcom->def_name = gf_strdup(rName);\n\t\t\t/*whenever inserting routes, keep track of max defined ID*/\n\t\t\tif (is_insert) {\n\t\t\t\tgf_sg_set_max_defined_route_id(parser->load->scene_graph, rID);\n\t\t\t\tif (parser->load->ctx && (rID>parser->load->ctx->max_route_id))\n\t\t\t\t\tparser->load->ctx->max_route_id = rID;\n\t\t\t}\n\t\t}\n\t\treturn NULL;\n\t}\n\tr = gf_sg_route_new(parser->load->scene_graph, orig, orig_field.fieldIndex, dest, dest_field.fieldIndex);\n\tif (r && rID) {\n\t\tgf_sg_route_set_id(r, rID);\n\t\tgf_sg_route_set_name(r, rName);\n\t}\n\treturn r;\n}\n\nvoid gf_bt_resolve_routes(GF_BTParser *parser, Bool clean)\n{\n\t/*resolve all commands*/\n\twhile(gf_list_count(parser->unresolved_routes) ) {\n\t\tGF_Command *com = (GF_Command *)gf_list_get(parser->unresolved_routes, 0);\n\t\tgf_list_rem(parser->unresolved_routes, 0);\n\t\tswitch (com->tag) {\n\t\tcase GF_SG_ROUTE_DELETE:\n\t\tcase GF_SG_ROUTE_REPLACE:\n\t\t\tcom->RouteID = gf_bt_get_route(parser, com->unres_name);\n\t\t\tif (!com->RouteID) gf_bt_report(parser, GF_BAD_PARAM, \"Cannot resolve Route %s\", com->unres_name);\n\t\t\tgf_free(com->unres_name);\n\t\t\tcom->unres_name = NULL;\n\t\t\tcom->unresolved = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!clean) return;\n\twhile (gf_list_count(parser->inserted_routes)) gf_list_rem(parser->inserted_routes, 0);\n}\n\n\nstatic void bd_set_com_node(GF_Command *com, GF_Node *node)\n{\n\tcom->node = node;\n\tgf_node_register(com->node, NULL);\n}\n\nGF_Err gf_bt_parse_bifs_command(GF_BTParser *parser, char *name, GF_List *cmdList)\n{\n\ts32 pos;\n\tGF_Route *r;\n\tGF_Node *n, *newnode;\n\tGF_Command *com;\n\tGF_CommandField *inf;\n\tGF_FieldInfo info;\n\tchar *str, field[1000];\n\tif (!name) {\n\t\tstr = gf_bt_get_next(parser, 0);\n\t} else {\n\t\tstr = name;\n\t}\n\tcom = NULL;\n\tpos = -2;\n\t/*REPLACE commands*/\n\tif (!strcmp(str, \"REPLACE\")) {\n\t\tstr = gf_bt_get_next(parser, 1);\n\t\tif (!strcmp(str, \"ROUTE\")) {\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tr = gf_sg_route_find_by_name(parser->load->scene_graph, str);\n\t\t\tif (!r) strcpy(field, str);\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tif (strcmp(str, \"BY\")) {\n\t\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"BY expected got %s\", str);\n\t\t\t}\n\t\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_ROUTE_REPLACE);\n\t\t\tif (r) {\n\t\t\t\tcom->RouteID = r->ID;\n\t\t\t} else {\n\t\t\t\tcom->unres_name = gf_strdup(field);\n\t\t\t\tcom->unresolved = 1;\n\t\t\t\tgf_list_add(parser->unresolved_routes, com);\n\t\t\t}\n\t\t\tgf_bt_parse_route(parser, 1, 0, com);\n\t\t\tgf_list_add(cmdList, com);\n\t\t\treturn parser->last_error;\n\t\t}\n\t\t/*scene replace*/\n\t\tif (!strcmp(str, \"SCENE\")) {\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tif (strcmp(str, \"BY\")) {\n\t\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"BY expected got %s\", str);\n\t\t\t}\n\t\t\tgf_bt_resolve_routes(parser, 1);\n\t\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_SCENE_REPLACE);\n\t\t\twhile (gf_list_count(parser->def_nodes)) gf_list_rem(parser->def_nodes, 0);\n\n\t\t\twhile (1) {\n\t\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\t\tif (!strcmp(str, \"PROTO\") || !strcmp(str, \"EXTERNPROTO\")) {\n\t\t\t\t\tgf_bt_parse_proto(parser, str, com->new_proto_list);\n\t\t\t\t\tif (parser->last_error) goto err;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tn = gf_bt_sf_node(parser, str, NULL, NULL);\n\t\t\tcom->node = n;\n\n\t\t\tif (parser->last_error) goto err;\n\t\t\tgf_list_add(cmdList, com);\n\t\t\tparser->cur_com = com;\n\t\t\treturn GF_OK;\n\t\t}\n\t\tif (!strcmp(str, \"LAST\")) pos = -1;\n\t\telse if (!strcmp(str, \"BEGIN\")) pos = 0;\n\n\t\tgf_bt_check_code(parser, '.');\n\t\tstrcpy(field, str);\n\t\tn = gf_bt_peek_node(parser, str);\n\t\tif (!n) return gf_bt_report(parser, GF_BAD_PARAM, \"%s: unknown node\", field);\n\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\tstrcpy(field, str);\n\t\tif (gf_bt_check_code(parser, '[')) {\n\t\t\tif ( (parser->last_error = gf_bt_parse_int(parser, \"index\", &pos)) ) return parser->last_error;\n\t\t\tif (!gf_bt_check_code(parser, ']'))\n\t\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"] expected\");\n\t\t}\n\t\t/*node replace*/\n\t\tif (!strcmp(field, \"BY\")) {\n\t\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_NODE_REPLACE);\n\t\t\tbd_set_com_node(com, n);\n\t\t\tinf = gf_sg_command_field_new(com);\n\t\t\tinf->new_node = gf_bt_sf_node(parser, NULL, NULL, NULL);\n\t\t\tinf->fieldType = GF_SG_VRML_SFNODE;\n\t\t\tinf->field_ptr = &inf->new_node;\n\t\t\tgf_list_add(cmdList, com);\n\t\t\tparser->cur_com = com;\n\t\t\treturn parser->last_error;\n\t\t}\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\tif (strcmp(str, \"BY\"))\n\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"BY expected got %s\", str);\n\n\t\tparser->last_error = gf_node_get_field_by_name(n, field, &info);\n\t\tif (parser->last_error)\n\t\t\treturn gf_bt_report(parser, parser->last_error, \"%s: Unknown node field\", field);\n\n\t\t/*field replace*/\n\t\tif (pos==-2) {\n\t\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_FIELD_REPLACE);\n\t\t\tbd_set_com_node(com, n);\n\n\t\t\tinf = gf_sg_command_field_new(com);\n\t\t\tinf->fieldIndex = info.fieldIndex;\n\t\t\tinf->fieldType = info.fieldType;\n\n\t\t\tswitch (info.fieldType) {\n\t\t\tcase GF_SG_VRML_SFNODE:\n\t\t\t\tnewnode = gf_bt_sf_node(parser, NULL, NULL, NULL);\n\t\t\t\tif (!gf_bt_check_ndt(parser, &info, newnode, n)) goto err;\n\t\t\t\tinf->new_node = newnode;\n\t\t\t\tinf->field_ptr = &inf->new_node;\n\t\t\t\tbreak;\n\t\t\tcase GF_SG_VRML_MFNODE:\n\t\t\t{\n\t\t\t\tGF_ChildNodeItem *last = NULL;\n\t\t\t\tif (!gf_bt_check_code(parser, '[')) break;\n\t\t\t\tinf->field_ptr = &inf->node_list;\n\t\t\t\twhile (!gf_bt_check_code(parser, ']')) {\n\t\t\t\t\tnewnode = gf_bt_sf_node(parser, NULL, NULL, NULL);\n\t\t\t\t\tif (!newnode) goto err;\n\t\t\t\t\tif (parser->last_error!=GF_OK) goto err;\n\t\t\t\t\tif (!gf_bt_check_ndt(parser, &info, newnode, n)) goto err;\n\t\t\t\t\tgf_node_list_add_child_last(& inf->node_list, newnode, &last);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tinf->field_ptr = gf_sg_vrml_field_pointer_new(info.fieldType);\n\t\t\t\tinfo.far_ptr = inf->field_ptr;\n\t\t\t\tif (gf_sg_vrml_is_sf_field(info.fieldType)) {\n\t\t\t\t\tgf_bt_sffield(parser, &info, n);\n\t\t\t\t} else {\n\t\t\t\t\tgf_bt_mffield(parser, &info, n);\n\t\t\t\t}\n\t\t\t\tif (parser->last_error) goto err;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tgf_list_add(cmdList, com);\n\t\t\tparser->cur_com = com;\n\t\t\treturn parser->last_error;\n\t\t}\n\t\t/*indexed field replace*/\n\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_INDEXED_REPLACE);\n\t\tbd_set_com_node(com, n);\n\t\tinf = gf_sg_command_field_new(com);\n\t\tinf->pos = pos;\n\t\tinf->fieldIndex = info.fieldIndex;\n\t\tif (gf_sg_vrml_is_sf_field(info.fieldType)) {\n\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"%s: MF type field expected\", info.name);\n\t\t\tgoto err;\n\t\t}\n\t\tinf->fieldType = gf_sg_vrml_get_sf_type(info.fieldType);\n\t\tswitch (info.fieldType) {\n\t\tcase GF_SG_VRML_MFNODE:\n\t\t\tnewnode = gf_bt_sf_node(parser, NULL, NULL, NULL);\n\t\t\tif (!gf_bt_check_ndt(parser, &info, newnode, n)) goto err;\n\t\t\tinf->new_node = newnode;\n\t\t\tinf->field_ptr = &inf->new_node;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tinfo.fieldType = inf->fieldType;\n\t\t\tinfo.far_ptr = inf->field_ptr = gf_sg_vrml_field_pointer_new(inf->fieldType);\n\t\t\tgf_bt_sffield(parser, &info, n);\n\t\t\tbreak;\n\t\t}\n\t\tif (parser->last_error) goto err;\n\t\tgf_list_add(cmdList, com);\n\t\tparser->cur_com = com;\n\t\treturn parser->last_error;\n\t}\n\t/*XREPLACE commands*/\n\tif (!strcmp(str, \"XREPLACE\")) {\n\t\tu32 j;\n\t\tBool force_sf=0;\n\t\tchar csep;\n\t\tGF_Node *targetNode, *idxNode, *childNode, *fromNode;\n\t\tGF_FieldInfo targetField, idxField, childField, fromField;\n\n\t\tidxNode = childNode = fromNode = NULL;\n\t\tstr = gf_bt_get_next(parser, 1);\n\t\t/*get source node*/\n\t\tstrcpy(field, str);\n\t\ttargetNode = gf_bt_peek_node(parser, str);\n\t\tif (!targetNode) return gf_bt_report(parser, GF_BAD_PARAM, \"%s: unknown node\", field);\n\t\tif (!gf_bt_check_code(parser, '.')) {\n\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"XREPLACE: '.' expected\");\n\t\t}\n\t\t/*get source field*/\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\tstrcpy(field, str);\n\t\tparser->last_error = gf_node_get_field_by_name(targetNode, field, &targetField);\n\t\tif (parser->last_error)\n\t\t\treturn gf_bt_report(parser, parser->last_error, \"%s: Unknown node field\", field);\n\n\t\tif (gf_bt_check_code(parser, '[')) {\n\t\t\tpos = -2;\n\t\t\tstr = gf_bt_get_next(parser, 1);\n\t\t\tforce_sf = 1;\n\t\t\tif (sscanf(str, \"%d\", &pos) != 1) {\n\t\t\t\tpos = -2;\n\t\t\t\tif (!strcmp(str, \"LAST\")) pos = -1;\n\t\t\t\telse if (!strcmp(str, \"first\")) pos = 0;\n\t\t\t\telse {\n\t\t\t\t\tstrcpy(field, str);\n\t\t\t\t\t/*get idx node*/\n\t\t\t\t\tidxNode = gf_bt_peek_node(parser, str);\n\t\t\t\t\tif (!idxNode) return gf_bt_report(parser, GF_BAD_PARAM, \"%s: unknown node\", field);\n\t\t\t\t\tif (!gf_bt_check_code(parser, '.'))\n\t\t\t\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"XREPLACE: '.' expected\");\n\n\t\t\t\t\t/*get idx field*/\n\t\t\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\t\t\tstrcpy(field, str);\n\t\t\t\t\tparser->last_error = gf_node_get_field_by_name(idxNode, field, &idxField);\n\t\t\t\t\tif (parser->last_error)\n\t\t\t\t\t\treturn gf_bt_report(parser, parser->last_error, \"%s: Unknown node field\", field);\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_bt_check_code(parser, ']');\n\n\t\t\t/*check if we have a child node*/\n\t\t\tif (gf_bt_check_code(parser, '.')) {\n\t\t\t\ts32 apos = pos;\n\t\t\t\tforce_sf = 0;\n\t\t\t\tif (idxNode) {\n\t\t\t\t\tapos = 0;\n\t\t\t\t\tswitch (idxField.fieldType) {\n\t\t\t\t\tcase GF_SG_VRML_SFBOOL:\n\t\t\t\t\t\tif (*(SFBool*)idxField.far_ptr) apos = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase GF_SG_VRML_SFINT32:\n\t\t\t\t\t\tif (*(SFInt32*)idxField.far_ptr >=0) apos = *(SFInt32*)idxField.far_ptr;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase GF_SG_VRML_SFFLOAT:\n\t\t\t\t\t\tif ( (*(SFFloat *)idxField.far_ptr) >=0) apos = (s32) floor( FIX2FLT(*(SFFloat*)idxField.far_ptr) );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase GF_SG_VRML_SFTIME:\n\t\t\t\t\t\tif ( (*(SFTime *)idxField.far_ptr) >=0) apos = (s32) floor( (*(SFTime *)idxField.far_ptr) );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tchildNode = gf_node_list_get_child(*(GF_ChildNodeItem **)targetField.far_ptr, apos);\n\t\t\t\tif (!childNode)\n\t\t\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"Cannot find child node at specified index\");\n\n\t\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\t\tstrcpy(field, str);\n\t\t\t\tparser->last_error = gf_node_get_field_by_name(childNode, field, &childField);\n\t\t\t\tif (parser->last_error)\n\t\t\t\t\treturn gf_bt_report(parser, parser->last_error, \"%s: Unknown node field\", field);\n\t\t\t}\n\t\t}\n\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\tif (strcmp(str, \"BY\"))\n\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"BY expected got %s\", str);\n\n\t\t/*peek the next word*/\n\t\tj = 0;\n\t\twhile (strchr(\" \\n\\t\\0\", parser->line_buffer[parser->line_pos + j])) j++;\n\t\tstr = parser->line_buffer + parser->line_pos + j;\n\t\tj = 0;\n\t\twhile (!strchr(\" .\\0\", str[j])) j++;\n\t\tcsep = str[j];\n\t\tstr[j]=0;\n\t\tstrcpy(field, str);\n\t\tstr[j] = csep;\n\t\tfromNode = gf_bt_peek_node(parser, field);\n\t\tif (fromNode) {\n\t\t\tgf_bt_get_next(parser, 1);\n\n\t\t\tif (!gf_bt_check_code(parser, '.')) {\n\t\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"XREPLACE: '.' expected\");\n\t\t\t}\n\t\t\t/*get source field*/\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tstrcpy(field, str);\n\t\t\tparser->last_error = gf_node_get_field_by_name(fromNode, field, &fromField);\n\t\t\tif (parser->last_error)\n\t\t\t\treturn gf_bt_report(parser, parser->last_error, \"%s: Unknown node field\", field);\n\n\t\t} else {\n\t\t\t/*regular parsing*/\n\t\t}\n\n\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_XREPLACE);\n\t\tbd_set_com_node(com, targetNode);\n\t\tif (fromNode) {\n\t\t\tcom->fromNodeID = gf_node_get_id(fromNode);\n\t\t\tcom->fromFieldIndex = fromField.fieldIndex;\n\t\t}\n\t\tif (idxNode) {\n\t\t\tcom->toNodeID = gf_node_get_id(idxNode);\n\t\t\tcom->toFieldIndex = idxField.fieldIndex;\n\t\t}\n\t\tif (childNode) {\n\t\t\tcom->ChildNodeTag = gf_node_get_tag(childNode);\n\t\t\tif (com->ChildNodeTag==1) {\n\t\t\t\tcom->ChildNodeTag = ((GF_ProtoInstance*)childNode)->proto_interface->ID;\n\t\t\t\tcom->ChildNodeTag = -com->ChildNodeTag ;\n\t\t\t}\n\t\t\tcom->child_field = childField.fieldIndex;\n\t\t}\n\t\tinf = gf_sg_command_field_new(com);\n\t\tinf->fieldIndex = targetField.fieldIndex;\n\t\tinf->pos = pos;\n\t\tif (force_sf) {\n\t\t\tinf->fieldType = gf_sg_vrml_get_sf_type(targetField.fieldType);\n\t\t} else if (childNode) {\n\t\t\tinf->fieldType = childField.fieldType;\n\t\t} else {\n\t\t\tinf->fieldType = targetField.fieldType;\n\t\t}\n\t\tif (!fromNode) {\n\t\t\tswitch (inf->fieldType) {\n\t\t\tcase GF_SG_VRML_SFNODE:\n\t\t\t\tinf->new_node = gf_bt_sf_node(parser, NULL, NULL, NULL);\n\t\t\t\tinf->field_ptr = &inf->new_node;\n\t\t\t\tif (childNode) {\n\t\t\t\t\tif (!gf_bt_check_ndt(parser, &childField, inf->new_node, childNode)) goto err;\n\t\t\t\t} else {\n\t\t\t\t\tif (!gf_bt_check_ndt(parser, &targetField, inf->new_node, targetNode)) goto err;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GF_SG_VRML_MFNODE:\n\t\t\t{\n\t\t\t\tGF_ChildNodeItem *last = NULL;\n\t\t\t\tif (!gf_bt_check_code(parser, '[')) break;\n\t\t\t\tinf->field_ptr = &inf->node_list;\n\t\t\t\twhile (!gf_bt_check_code(parser, ']')) {\n\t\t\t\t\tnewnode = gf_bt_sf_node(parser, NULL, NULL, NULL);\n\t\t\t\t\tif (!newnode) goto err;\n\t\t\t\t\tif (parser->last_error!=GF_OK) goto err;\n\n\t\t\t\t\tif (childNode) {\n\t\t\t\t\t\tif (!gf_bt_check_ndt(parser, &childField, inf->new_node, childNode)) goto err;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (!gf_bt_check_ndt(parser, &targetField, inf->new_node, targetNode)) goto err;\n\t\t\t\t\t}\n\n\t\t\t\t\tgf_node_list_add_child_last(& inf->node_list, newnode, &last);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tinf->field_ptr = gf_sg_vrml_field_pointer_new(inf->fieldType);\n\t\t\t\tinfo.far_ptr = inf->field_ptr;\n\t\t\t\tinfo.fieldType = inf->fieldType;\n\t\t\t\tinfo.name = targetField.name;\n\n\t\t\t\tif (gf_sg_vrml_is_sf_field(inf->fieldType)) {\n\t\t\t\t\tgf_bt_sffield(parser, &info, childNode ? childNode : targetNode);\n\t\t\t\t} else {\n\t\t\t\t\tgf_bt_mffield(parser, &info, childNode ? childNode : targetNode);\n\t\t\t\t}\n\t\t\t\tif (parser->last_error) goto err;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (parser->last_error) goto err;\n\t\tgf_list_add(cmdList, com);\n\t\tparser->cur_com = com;\n\t\treturn parser->last_error;\n\t}\n\n\n\t/*INSERT commands*/\n\tif (!strcmp(str, \"INSERT\") || !strcmp(str, \"APPEND\")) {\n\t\tBool is_append = !strcmp(str, \"APPEND\") ? 1 : 0;\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\tif (!strcmp(str, \"ROUTE\")) {\n\t\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_ROUTE_INSERT);\n\t\t\tgf_bt_parse_route(parser, 0, 1, com);\n\t\t\tif (parser->last_error) goto err;\n\t\t\tgf_list_add(cmdList, com);\n\t\t\tgf_list_add(parser->inserted_routes, com);\n\t\t\tparser->cur_com = com;\n\t\t\treturn GF_OK;\n\t\t}\n\t\tif (strcmp(str, \"AT\") && strcmp(str, \"TO\")) {\n\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, (char*) (is_append ? \"TO expected got %s\" : \"AT expected got %s\"), str);\n\t\t}\n\t\tstr = gf_bt_get_next(parser, 1);\n\t\tstrcpy(field, str);\n\t\tn = gf_bt_peek_node(parser, str);\n\t\tif (!n) {\n\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"%s: Unknown node\", field);\n\t\t}\n\t\tif (!gf_bt_check_code(parser, '.')) {\n\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \". expected\");\n\t\t}\n\t\tstr = gf_bt_get_next(parser, 1);\n\t\tstrcpy(field, str);\n\t\tif (!is_append) {\n\t\t\tif (!gf_bt_check_code(parser, '[')) {\n\t\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"[ expected\");\n\t\t\t}\n\t\t\tgf_bt_parse_int(parser, \"index\", &pos);\n\t\t\tif (!gf_bt_check_code(parser, ']')) {\n\t\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"] expected\");\n\t\t\t}\n\t\t} else {\n\t\t\tif (gf_bt_check_code(parser, '[')) {\n\t\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"[ unexpected in Append command\");\n\t\t\t}\n\t\t\tpos = -1;\n\t\t}\n\t\tgf_node_get_field_by_name(n, field, &info);\n\t\tif (!strcmp(field, \"children\")) {\n\t\t\tnewnode = gf_bt_sf_node(parser, NULL, NULL, NULL);\n\t\t\tif (parser->last_error) goto err;\n\n\t\t\tif (!gf_bt_check_ndt(parser, &info, newnode, n)) goto err;\n\t\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_NODE_INSERT);\n\t\t\tbd_set_com_node(com, n);\n\t\t\tinf = gf_sg_command_field_new(com);\n\t\t\tinf->pos = pos;\n\t\t\tinf->new_node = newnode;\n\t\t\tinf->fieldType = GF_SG_VRML_SFNODE;\n\t\t\tinf->field_ptr = &inf->new_node;\n\t\t\tif (parser->last_error) goto err;\n\t\t\tparser->cur_com = com;\n\t\t\treturn gf_list_add(cmdList, com);\n\t\t}\n\t\tif (gf_sg_vrml_is_sf_field(info.fieldType)) {\n\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"%s: MF type field expected\", info.name);\n\t\t\tgoto err;\n\t\t}\n\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_INDEXED_INSERT);\n\t\tbd_set_com_node(com, n);\n\t\tinf = gf_sg_command_field_new(com);\n\t\tinf->pos = pos;\n\t\tinf->fieldIndex = info.fieldIndex;\n\t\tinf->fieldType = gf_sg_vrml_get_sf_type(info.fieldType);\n\t\tswitch (info.fieldType) {\n\t\tcase GF_SG_VRML_MFNODE:\n\t\t\tinf->new_node = gf_bt_sf_node(parser, NULL, NULL, NULL);\n\t\t\tinf->field_ptr = &inf->new_node;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tinfo.fieldType = inf->fieldType;\n\t\t\tinf->field_ptr = gf_sg_vrml_field_pointer_new(inf->fieldType);\n\t\t\tinfo.far_ptr = inf->field_ptr;\n\t\t\tgf_bt_sffield(parser, &info, n);\n\t\t\tbreak;\n\t\t}\n\t\tif (parser->last_error) goto err;\n\t\tgf_list_add(cmdList, com);\n\t\tparser->cur_com = com;\n\t\treturn parser->last_error;\n\t}\n\t/*DELETE commands*/\n\tif (!strcmp(str, \"DELETE\")) {\n\t\tstr = gf_bt_get_next(parser, 1);\n\t\tif (!strcmp(str, \"ROUTE\")) {\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_ROUTE_DELETE);\n\t\t\tcom->RouteID = gf_bt_get_route(parser, str);\n\t\t\tif (!com->RouteID) {\n\t\t\t\tcom->unres_name = gf_strdup(str);\n\t\t\t\tcom->unresolved = 1;\n\t\t\t\tgf_list_add(parser->unresolved_routes, com);\n\t\t\t}\n\t\t\t/*for bt<->xmt conversions*/\n\t\t\tcom->def_name = gf_strdup(str);\n\t\t\treturn gf_list_add(cmdList, com);\n\t\t}\n\t\tstrcpy(field, str);\n\t\tn = gf_bt_peek_node(parser, str);\n\t\tif (!n) {\n\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"DELETE %s: Unknown Node\", field);\n\t\t}\n\t\tif (!gf_bt_check_code(parser, '.')) {\n\t\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_NODE_DELETE);\n\t\t\tbd_set_com_node(com, n);\n\t\t\treturn gf_list_add(cmdList, com);\n\t\t}\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\tif (gf_node_get_field_by_name(n, str, &info) != GF_OK) {\n\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"%s not a field of node %s\", str, gf_node_get_class_name(n) );\n\t\t}\n\t\tif (gf_bt_check_code(parser, '[')) {\n\t\t\tgf_bt_parse_int(parser, \"index\", &pos);\n\t\t\tif (!gf_bt_check_code(parser, ']'))\n\t\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"[ expected\");\n\t\t}\n\t\tif (gf_sg_vrml_is_sf_field(info.fieldType)) {\n\t\t\tif (info.fieldType == GF_SG_VRML_SFNODE) {\n\t\t\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_FIELD_REPLACE);\n\t\t\t\tbd_set_com_node(com, n);\n\t\t\t\tinf = gf_sg_command_field_new(com);\n\t\t\t\tinf->fieldIndex = info.fieldIndex;\n\t\t\t\tinf->fieldType = info.fieldType;\n\t\t\t\tinf->new_node = NULL;\n\t\t\t\tinf->field_ptr = &inf->new_node;\n\t\t\t\treturn gf_list_add(cmdList, com);\n\t\t\t}\n\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"%s is an SFField - cannot indexed delete\", info.name);\n\t\t}\n\n\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_INDEXED_DELETE);\n\t\tbd_set_com_node(com, n);\n\t\tinf = gf_sg_command_field_new(com);\n\t\tinf->fieldIndex = info.fieldIndex;\n\t\tinf->fieldType = info.fieldType;\n\t\tinf->pos = pos;\n\t\treturn gf_list_add(cmdList, com);\n\t}\n\t/*Extended BIFS commands*/\n\n\t/*GlobalQP commands*/\n\tif (!strcmp(str, \"GLOBALQP\")) {\n\t\tnewnode = gf_bt_sf_node(parser, NULL, NULL, NULL);\n\t\tif (newnode && (newnode->sgprivate->tag != TAG_MPEG4_QuantizationParameter)) {\n\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"Only QuantizationParameter node allowed in GLOBALQP\");\n\t\t\tgf_node_unregister(newnode, NULL);\n\t\t\treturn parser->last_error;\n\t\t}\n\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_GLOBAL_QUANTIZER);\n\t\tcom->node = NULL;\n\t\tinf = gf_sg_command_field_new(com);\n\t\tinf->new_node = newnode;\n\t\tinf->field_ptr = &inf->new_node;\n\t\tinf->fieldType = GF_SG_VRML_SFNODE;\n\t\treturn gf_list_add(cmdList, com);\n\t}\n\n\t/*MultipleReplace commands*/\n\tif (!strcmp(str, \"MULTIPLEREPLACE\")) {\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\tstrcpy(field, str);\n\t\tn = gf_bt_peek_node(parser, str);\n\t\tif (!n) {\n\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"%s: Unknown node\", field);\n\t\t}\n\t\tif (!gf_bt_check_code(parser, '{')) {\n\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"{ expected\");\n\t\t}\n\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_MULTIPLE_REPLACE);\n\t\tbd_set_com_node(com, n);\n\n\t\twhile (!gf_bt_check_code(parser, '}')) {\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tparser->last_error = gf_node_get_field_by_name(n, str, &info);\n\t\t\tif (parser->last_error) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"%s: Unknown node field\", str);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tinf = gf_sg_command_field_new(com);\n\t\t\tinf->fieldIndex = info.fieldIndex;\n\t\t\tinf->fieldType = info.fieldType;\n\t\t\tinf->pos = -1;\n\n\t\t\tswitch (info.fieldType) {\n\t\t\tcase GF_SG_VRML_SFNODE:\n\t\t\t\tinf->new_node = gf_bt_sf_node(parser, NULL, NULL, NULL);\n\t\t\t\tif (parser->last_error) goto err;\n\t\t\t\tif (!gf_bt_check_ndt(parser, &info, inf->new_node, n)) goto err;\n\t\t\t\tinf->field_ptr = &inf->new_node;\n\t\t\t\tbreak;\n\t\t\tcase GF_SG_VRML_MFNODE:\n\t\t\t{\n\t\t\t\tGF_ChildNodeItem *last = NULL;\n\t\t\t\tif (!gf_bt_check_code(parser, '[')) {\n\t\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"[ expected\");\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tinfo.far_ptr = inf->field_ptr = &inf->node_list;\n\t\t\t\twhile (!gf_bt_check_code(parser, ']')) {\n\t\t\t\t\tnewnode = gf_bt_sf_node(parser, NULL, NULL, NULL);\n\t\t\t\t\tif (parser->last_error!=GF_OK) goto err;\n\t\t\t\t\tif (!gf_bt_check_ndt(parser, &info, newnode, n)) goto err;\n\t\t\t\t\tgf_node_list_add_child_last( & inf->node_list, newnode, &last);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tinfo.far_ptr = inf->field_ptr = gf_sg_vrml_field_pointer_new(inf->fieldType);\n\t\t\t\tif (gf_sg_vrml_is_sf_field(info.fieldType)) {\n\t\t\t\t\tgf_bt_sffield(parser, &info, n);\n\t\t\t\t} else {\n\t\t\t\t\tgf_bt_mffield(parser, &info, n);\n\t\t\t\t}\n\t\t\t\tif (parser->last_error) goto err;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tparser->cur_com = com;\n\t\treturn gf_list_add(cmdList, com);\n\t}\n\n\t/*MultipleIndexReplace commands*/\n\tif (!strcmp(str, \"MULTIPLEINDREPLACE\")) {\n\t\tstr = gf_bt_get_next(parser, 1);\n\t\tstrcpy(field, str);\n\t\tn = gf_bt_peek_node(parser, str);\n\t\tif (!n) {\n\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"%s: Unknown node\", field);\n\t\t}\n\t\tif (!gf_bt_check_code(parser, '.')) {\n\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \". expected\");\n\t\t}\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\tparser->last_error = gf_node_get_field_by_name(n, str, &info);\n\t\tif (parser->last_error) {\n\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"%s: Unknown field\", info.name);\n\t\t}\n\t\tif (gf_sg_vrml_is_sf_field(info.fieldType)) {\n\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"Only MF field allowed\");\n\t\t}\n\t\tif (!gf_bt_check_code(parser, '[')) {\n\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"[ expected\");\n\t\t}\n\n\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_MULTIPLE_INDEXED_REPLACE);\n\t\tbd_set_com_node(com, n);\n\t\tinfo.fieldType = gf_sg_vrml_get_sf_type(info.fieldType);\n\n\t\twhile (!gf_bt_check_code(parser, ']')) {\n\t\t\tpos=0;\n\t\t\tif (gf_bt_parse_int(parser, \"position\", (SFInt32 *)&pos)) goto err;\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tif (strcmp(str, \"BY\")) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"BY expected\");\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tinf = gf_sg_command_field_new(com);\n\t\t\tinf->fieldIndex = info.fieldIndex;\n\t\t\tinf->fieldType = info.fieldType;\n\t\t\tinf->pos = pos;\n\t\t\tif (inf->fieldType==GF_SG_VRML_SFNODE) {\n\t\t\t\tinfo.far_ptr = inf->field_ptr = &inf->new_node;\n\t\t\t\tinf->new_node = gf_bt_sf_node(parser, NULL, NULL, NULL);\n\t\t\t\tif (parser->last_error) goto err;\n\t\t\t\tif (!gf_bt_check_ndt(parser, &info, inf->new_node, n)) goto err;\n\t\t\t\tinf->field_ptr = &inf->new_node;\n\t\t\t} else {\n\t\t\t\tinfo.far_ptr = inf->field_ptr = gf_sg_vrml_field_pointer_new(inf->fieldType);\n\t\t\t\tgf_bt_sffield(parser, &info, n);\n\t\t\t\tif (parser->last_error) goto err;\n\t\t\t}\n\t\t}\n\t\tparser->cur_com = com;\n\t\treturn gf_list_add(cmdList, com);\n\t}\n\n\tif (!strcmp(str, \"XDELETE\")) {\n\t\tstr = gf_bt_get_next(parser, 1);\n\t\tstrcpy(field, str);\n\t\tn = gf_bt_peek_node(parser, str);\n\t\tif (!n) {\n\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"%s: Unknown Node\", field);\n\t\t}\n\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_NODE_DELETE_EX);\n\t\tbd_set_com_node(com, n);\n\t\treturn gf_list_add(cmdList, com);\n\t}\n\n\tif (!strcmp(str, \"INSERTPROTO\")) {\n\t\tif (!gf_bt_check_code(parser, '[')) {\n\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"[ expected\");\n\t\t}\n\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_PROTO_INSERT);\n\t\twhile (!gf_bt_check_code(parser, ']')) {\n\t\t\tparser->last_error = gf_bt_parse_proto(parser, NULL, com->new_proto_list);\n\t\t\tif (parser->last_error) goto err;\n\t\t}\n\t\tgf_list_add(cmdList, com);\n\t\treturn GF_OK;\n\t}\n\tif (!strcmp(str, \"DELETEPROTO\")) {\n\t\tif (!gf_bt_check_code(parser, '[')) {\n\t\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_PROTO_DELETE_ALL);\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tif (strcmp(str, \"ALL\")) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"ALL expected\");\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\treturn gf_list_add(cmdList, com);\n\t\t}\n\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_PROTO_DELETE);\n\t\twhile (!gf_bt_check_code(parser, ']')) {\n\t\t\tGF_Proto *proto;\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tproto = gf_sg_find_proto(parser->load->scene_graph, 0, str);\n\t\t\tif (!proto) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"%s: Unknown proto\", str);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tcom->del_proto_list = (u32*)gf_realloc(com->del_proto_list, sizeof(u32)*(com->del_proto_list_size+1));\n\t\t\tcom->del_proto_list[com->del_proto_list_size] = proto->ID;\n\t\t\tcom->del_proto_list_size++;\n\t\t}\n\t\tgf_list_add(cmdList, com);\n\t\treturn GF_OK;\n\t}\n\treturn gf_bt_report(parser, GF_BAD_PARAM, \"%s: Unknown command syntax, str\");\n\nerr:\n\tif (com) gf_sg_command_del(com);\n\treturn parser->last_error;\n}\n\nGF_Descriptor *gf_bt_parse_descriptor(GF_BTParser *parser, char *name);\n\n#ifndef GPAC_MINIMAL_ODF\nGF_IPMPX_Data *gf_bt_parse_ipmpx(GF_BTParser *parser, char *name)\n{\n\tchar *str, field[500];\n\tGF_IPMPX_Data *desc, *subdesc;\n\tGF_Descriptor *oddesc;\n\tGF_Err e;\n\tu32 type;\n\tu8 tag;\n\tif (name) {\n\t\tstr = name;\n\t} else {\n\t\tstr = gf_bt_get_next(parser, 0);\n\t}\n\ttag = gf_ipmpx_get_tag(str);\n\tif (!tag) {\n\t\tgf_bt_report(parser, GF_BAD_PARAM, \"%s: Unknown IPMPX Data\", str);\n\t\treturn NULL;\n\t}\n\tdesc = gf_ipmpx_data_new(tag);\n\n\tif (!desc) return NULL;\n\tif (!gf_bt_check_code(parser, '{')) return desc;\n\n\twhile (1) {\n\t\t/*done*/\n\t\tif (gf_bt_check_code(parser, '}')) break;\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\tstrcpy(field, str);\n\t\ttype = gf_ipmpx_get_field_type(desc, str);\n\t\tswitch (type) {\n\t\t/*single descriptor*/\n\t\tcase GF_ODF_FT_OD:\n\t\t\tassert(desc->tag==GF_IPMPX_CONNECT_TOOL_TAG);\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\toddesc = gf_bt_parse_descriptor(parser, str);\n\t\t\tif (!oddesc) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"Unknown desc %s in field %s\", str, field);\n\t\t\t\tgf_ipmpx_data_del(desc);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tassert(oddesc->tag==GF_ODF_IPMP_TAG);\n\t\t\t((GF_IPMPX_ConnectTool *)desc)->toolDescriptor = (GF_IPMP_Descriptor *)oddesc;\n\t\t\tbreak;\n\t\t/*descriptor list*/\n\t\tcase GF_ODF_FT_OD_LIST:\n\t\t\tassert(desc->tag==GF_IPMPX_GET_TOOLS_RESPONSE_TAG);\n\t\t\tif (gf_bt_check_code(parser, '[')) {\n\t\t\t\twhile (!gf_bt_check_code(parser, ']')) {\n\t\t\t\t\tGF_Descriptor *ipmp_t = gf_bt_parse_descriptor(parser, NULL);\n\t\t\t\t\tif (!ipmp_t) {\n\t\t\t\t\t\tgf_ipmpx_data_del(desc);\n\t\t\t\t\t\tparser->last_error = GF_BAD_PARAM;\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\t\t\t\t\tassert(ipmp_t->tag==GF_ODF_IPMP_TOOL_TAG);\n\t\t\t\t\tgf_list_add( ((GF_IPMPX_GetToolsResponse *)desc)->ipmp_tools, ipmp_t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\t/*IPMPX ByteArray list*/\n\t\tcase GF_ODF_FT_IPMPX_BA_LIST:\n\t\t\tif (gf_bt_check_code(parser, '[')) {\n\t\t\t\twhile (!gf_bt_check_code(parser, ']')) {\n\t\t\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\t\t\tif (!str) continue;\n\t\t\t\t\tif (gf_ipmpx_set_byte_array(desc, field, str) != GF_OK) {\n\t\t\t\t\t\tgf_bt_report(parser, GF_OK, \"Invalid ipmpx %s in field %s - skipping\", str, field);\n\t\t\t\t\t}\n\t\t\t\t\tgf_bt_check_code(parser, ',');\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t/*IPMPX ByteArray: check if declared as sub-data or not*/\n\t\tcase GF_ODF_FT_IPMPX_BA:\n\t\t\tstr = NULL;\n\t\t\tif (gf_bt_check_code(parser, '{')) {\n\t\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\t\tif (stricmp(str, \"array\")) {\n\t\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"IPMP ByteArray syntax is %s { array \\\"...\\\" } or %s \\\"....\\\"\\n\", field, field);\n\t\t\t\t\tgf_ipmpx_data_del(desc);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\t\tgf_bt_check_code(parser, '}');\n\t\t\t} else {\n\t\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\t}\n\t\t\te = gf_ipmpx_set_byte_array(desc, field, str);\n\t\t\tif (e) {\n\t\t\t\tgf_bt_report(parser, e, \"Error assigning IPMP ByteArray %s\\n\", field);\n\t\t\t\tgf_ipmpx_data_del(desc);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tbreak;\n\t\t/*IPMPX Data list*/\n\t\tcase GF_ODF_FT_IPMPX_LIST:\n\t\t\tif (gf_bt_check_code(parser, '[')) {\n\t\t\t\twhile (!gf_bt_check_code(parser, ']')) {\n\t\t\t\t\tsubdesc = gf_bt_parse_ipmpx(parser, NULL);\n\t\t\t\t\tif (!subdesc) {\n\t\t\t\t\t\tgf_ipmpx_data_del(desc);\n\t\t\t\t\t\tparser->last_error = GF_BAD_PARAM;\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\t\t\t\t\tif (gf_ipmpx_set_sub_data(desc, field, subdesc) != GF_OK) {\n\t\t\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"Invalid ipmpx %s in field %s - skipping\", str, field);\n\t\t\t\t\t\tgf_ipmpx_data_del(subdesc);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t/*regular IPMPX Data*/\n\t\tcase GF_ODF_FT_IPMPX:\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tsubdesc = gf_bt_parse_ipmpx(parser, str);\n\t\t\tif (!subdesc) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"Unknown ipmpx %s in field %s\", str, field);\n\t\t\t\tgf_ipmpx_data_del(desc);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (gf_ipmpx_set_sub_data(desc, field, subdesc) != GF_OK) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"Invalid ipmpx in field %s - skipping\", field);\n\t\t\t\tgf_ipmpx_data_del(subdesc);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tparser->last_error = gf_ipmpx_set_field(desc, field, str);\n\n\t\t\tif (parser->last_error) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"Invalid value %s in field %s\", str, field);\n\t\t\t\tgf_ipmpx_data_del(desc);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn desc;\n}\n#endif\n\nstatic void gf_bt_add_desc(GF_BTParser *parser, GF_Descriptor *par, GF_Descriptor *child, char *fieldName)\n{\n\tGF_Err e = gf_odf_desc_add_desc(par, child);\n\tif (e) {\n\t\tgf_bt_report(parser, GF_OK, \"Invalid child descriptor in field %s - skipping\", fieldName);\n\t\tgf_odf_desc_del(child);\n\t}\n}\n\nGF_Descriptor *gf_bt_parse_descriptor(GF_BTParser *parser, char *name)\n{\n\tchar *str, field[500];\n\tGF_Descriptor *desc, *subdesc;\n\tu32 type;\n\tu8 tag;\n\tif (name) {\n\t\tstr = name;\n\t} else {\n\t\tstr = gf_bt_get_next(parser, 0);\n\t}\n\ttag = gf_odf_get_tag_by_name(str);\n\tif (!tag) {\n\t\tgf_bt_report(parser, GF_BAD_PARAM, \"%s: Unknown descriptor\", str);\n\t\treturn NULL;\n\t}\n\tdesc = gf_odf_desc_new(tag);\n\n\tif (!desc) return NULL;\n\tif (!gf_bt_check_code(parser, '{')) return desc;\n\n\twhile (1) {\n\t\tBool is_anim_mask = 0;\n\t\t/*done*/\n\t\tif (gf_bt_check_code(parser, '}')) break;\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\tstrcpy(field, str);\n\n\t\tif ((tag==GF_ODF_BIFS_CFG_TAG) && !strcmp(field, \"animationMask\")) {\n\t\t\tgf_bt_get_next(parser, 0);\n\t\t\tif (gf_bt_check_code(parser, '{')) is_anim_mask = 1;\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tstrcpy(field, str);\n\t\t}\n\n\t\ttype = gf_odf_get_field_type(desc, str);\n\t\tswitch (type) {\n#ifndef GPAC_MINIMAL_ODF\n\t\t/*IPMPX list*/\n\t\tcase GF_ODF_FT_IPMPX_LIST:\n\t\t\tif(desc->tag!=GF_ODF_IPMP_TAG) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"IPMPX_Data list only allowed in GF_IPMP_Descriptor\");\n\t\t\t\tgf_odf_desc_del(desc);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (gf_bt_check_code(parser, '[')) {\n\t\t\t\twhile (!gf_bt_check_code(parser, ']')) {\n\t\t\t\t\tGF_IPMPX_Data *ipmpx = gf_bt_parse_ipmpx(parser, NULL);\n\t\t\t\t\tif (!ipmpx) {\n\t\t\t\t\t\tgf_odf_desc_del(desc);\n\t\t\t\t\t\tparser->last_error = GF_BAD_PARAM;\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\t\t\t\t\tgf_list_add( ((GF_IPMP_Descriptor *)desc)->ipmpx_data, ipmpx);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t/*IPMPX*/\n\t\tcase GF_ODF_FT_IPMPX:\n\t\t\tif(desc->tag!=GF_ODF_IPMP_TOOL_TAG) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"IPMPX_Data only allowed in GF_IPMP_Tool\");\n\t\t\t\tgf_odf_desc_del(desc);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (gf_bt_check_code(parser, '[')) {\n\t\t\t\twhile (!gf_bt_check_code(parser, ']')) {\n\t\t\t\t\tGF_IPMPX_Data *ipmpx = gf_bt_parse_ipmpx(parser, NULL);\n\t\t\t\t\tif (!ipmpx) {\n\t\t\t\t\t\tgf_odf_desc_del(desc);\n\t\t\t\t\t\tparser->last_error = GF_BAD_PARAM;\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\t\t\t\t\tif (ipmpx->tag==GF_IPMPX_PARAMETRIC_DESCRIPTION_TAG) {\n\t\t\t\t\t\tGF_IPMP_Tool *it = (GF_IPMP_Tool *)desc;\n\t\t\t\t\t\tif (it->toolParamDesc) gf_ipmpx_data_del((GF_IPMPX_Data *)it->toolParamDesc);\n\t\t\t\t\t\tit->toolParamDesc = (GF_IPMPX_ParametricDescription*)ipmpx;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgf_bt_report(parser, GF_OK, \"Only ToolParametricDescription allowed in GF_IPMP_Tool - skipping\");\n\t\t\t\t\t\tgf_ipmpx_data_del(ipmpx);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n#endif\n\n\t\t/*descriptor list*/\n\t\tcase GF_ODF_FT_OD_LIST:\n\t\t\tif (gf_bt_check_code(parser, '[')) {\n\t\t\t\twhile (!gf_bt_check_code(parser, ']')) {\n\t\t\t\t\tsubdesc = gf_bt_parse_descriptor(parser, NULL);\n\t\t\t\t\tif (!subdesc) {\n\t\t\t\t\t\tgf_odf_desc_del(desc);\n\t\t\t\t\t\tparser->last_error = GF_BAD_PARAM;\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\t\t\t\t\tgf_bt_add_desc(parser, desc, subdesc, field);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (is_anim_mask)\n\t\t\t\tgf_bt_check_code(parser, '}');\n\t\t\tbreak;\n\t\t/*single descriptor*/\n\t\tcase GF_ODF_FT_OD:\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tsubdesc = gf_bt_parse_descriptor(parser, str);\n\t\t\tif (!subdesc) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"Unknown desc %s in field %s\", str, field);\n\t\t\t\tgf_odf_desc_del(desc);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tgf_bt_add_desc(parser, desc, subdesc, field);\n\t\t\tbreak;\n\t\t/*regular field*/\n\t\tdefault:\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tparser->last_error = gf_odf_set_field(desc, field, str);\n\n\t\t\tif (parser->last_error) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"Invalid value %s in field %s\", str, field);\n\t\t\t\tgf_odf_desc_del(desc);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (desc->tag == GF_ODF_BIFS_CFG_TAG) {\n\t\tGF_BIFSConfig *bcfg = (GF_BIFSConfig *)desc;\n\t\tif (!parser->load->ctx->scene_width) {\n\t\t\tparser->load->ctx->scene_width = bcfg->pixelWidth;\n\t\t\tparser->load->ctx->scene_height = bcfg->pixelHeight;\n\t\t\tparser->load->ctx->is_pixel_metrics = bcfg->pixelMetrics;\n\t\t}\n\n\t\t/*for bt->xmt*/\n\t\tif (!bcfg->version) bcfg->version = 1;\n\t}\n\telse if (desc->tag==GF_ODF_ESD_TAG) {\n\t\tGF_ESD *esd  =(GF_ESD*)desc;\n\t\tif (esd->decoderConfig) {\n\t\t\tGF_StreamContext *sc=NULL;\n\t\t\tGF_MuxInfo *mux;\n\t\t\t/*watchout for default BIFS stream*/\n\t\t\tif (parser->bifs_es && !parser->base_bifs_id && (esd->decoderConfig->streamType==GF_STREAM_SCENE)) {\n\t\t\t\tparser->bifs_es->ESID = parser->base_bifs_id = esd->ESID;\n\t\t\t\tparser->bifs_es->timeScale = (esd->slConfig && esd->slConfig->timestampResolution) ? esd->slConfig->timestampResolution : 1000;\n\t\t\t\tsc = parser->bifs_es;\n\t\t\t} else {\n\t\t\t\tsc = gf_sm_stream_new(parser->load->ctx, esd->ESID, esd->decoderConfig->streamType, esd->decoderConfig->objectTypeIndication);\n\t\t\t\t/*set default timescale for systems tracks (ignored for other)*/\n\t\t\t\tif (sc) sc->timeScale = (esd->slConfig && esd->slConfig->timestampResolution) ? esd->slConfig->timestampResolution : 1000;\n\t\t\t\t/*assign base OD*/\n\t\t\t\tif (!parser->base_od_id && (esd->decoderConfig->streamType==GF_STREAM_OD)) parser->base_od_id = esd->ESID;\n\t\t\t}\n\t\t\t/*assign broadcast parameter tools*/\n\t\t\tmux = gf_sm_get_mux_info(esd);\n\t\t\tif (sc && mux) {\n\t\t\t\tsc->aggregate_on_esid = mux->aggregate_on_esid;\n\t\t\t\tif (!mux->carousel_period_plus_one) sc->carousel_period  = (u32) -1;\n\t\t\t\telse sc->carousel_period = mux->carousel_period_plus_one - 1;\n\t\t\t}\n\t\t}\n\t} else if (desc->tag==GF_ODF_MUXINFO_TAG) {\n\t\tGF_MuxInfo *mi = (GF_MuxInfo *)desc;\n\t\tif (! mi->src_url) {\n\t\t\tmi->src_url = gf_strdup(parser->load->src_url ? parser->load->src_url : parser->load->fileName);\n\t\t}\n\t}\n\treturn desc;\n}\n\nvoid gf_bt_parse_od_command(GF_BTParser *parser, char *name)\n{\n\tu32 val=0;\n\tchar *str;\n\n\tif (!strcmp(name, \"UPDATE\")) {\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\t/*OD update*/\n\t\tif (!strcmp(str, \"OD\")) {\n\t\t\tGF_ODUpdate *odU;\n\t\t\tif (!gf_bt_check_code(parser, '[')) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"[ expected\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\todU = (GF_ODUpdate *) gf_odf_com_new(GF_ODF_OD_UPDATE_TAG);\n\t\t\tgf_list_add(parser->od_au->commands, odU);\n\t\t\twhile (!parser->done) {\n\t\t\t\tGF_Descriptor *desc;\n\t\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\t\tif (gf_bt_check_code(parser, ']')) break;\n\t\t\t\tif (strcmp(str, \"ObjectDescriptor\") && strcmp(str, \"InitialObjectDescriptor\")) {\n\t\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"Object Descriptor expected got %s\", str);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdesc = gf_bt_parse_descriptor(parser, str);\n\t\t\t\tif (!desc) break;\n\t\t\t\tgf_list_add(odU->objectDescriptors, desc);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t/*ESD update*/\n\t\tif (!strcmp(str, \"ESD\")) {\n\t\t\tGF_ESDUpdate *esdU;\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tif (strcmp(str, \"IN\")) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"IN expected got %s\", str);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tesdU = (GF_ESDUpdate *) gf_odf_com_new(GF_ODF_ESD_UPDATE_TAG);\n\t\t\tparser->last_error = gf_bt_parse_int(parser, \"OD_ID\", (SFInt32*)&val);\n\t\t\tif (parser->last_error) return;\n\t\t\tesdU->ODID = val;\n\t\t\tgf_list_add(parser->od_au->commands, esdU);\n\n\t\t\tif (!gf_bt_check_code(parser, '[')) {\n\t\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\t\tif (strcmp(str, \"esDescr\")) {\n\t\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"esDescr expected got %s\", str);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (!gf_bt_check_code(parser, '[')) {\n\t\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"[ expected\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\twhile (!parser->done) {\n\t\t\t\tGF_Descriptor *desc;\n\t\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\t\tif (gf_bt_check_code(parser, ']')) break;\n\t\t\t\tif (strcmp(str, \"ES_Descriptor\")) {\n\t\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"ES_Descriptor expected got %s\", str);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdesc = gf_bt_parse_descriptor(parser, str);\n\t\t\t\tif (!desc) break;\n\t\t\t\tgf_list_add(esdU->ESDescriptors, desc);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t/*IPMP descriptor update*/\n\t\tif (!strcmp(str, \"IPMPD\") || !strcmp(str, \"IPMPDX\")) {\n\t\t\tGF_IPMPUpdate *ipU;\n\t\t\tif (!gf_bt_check_code(parser, '[')) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"[ expected\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tipU = (GF_IPMPUpdate *) gf_odf_com_new(GF_ODF_IPMP_UPDATE_TAG);\n\t\t\tgf_list_add(parser->od_au->commands, ipU);\n\t\t\twhile (!parser->done) {\n\t\t\t\tGF_Descriptor *desc;\n\t\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\t\tif (gf_bt_check_code(parser, ']')) break;\n\t\t\t\tif (strcmp(str, \"IPMP_Descriptor\")) {\n\t\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"IPMP_Descriptor expected got %s\", str);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdesc = gf_bt_parse_descriptor(parser, str);\n\t\t\t\tif (!desc) break;\n\t\t\t\tgf_list_add(ipU->IPMPDescList, desc);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tgf_bt_report(parser, GF_BAD_PARAM, \"unknown OD command\", str);\n\t\treturn;\n\t}\n\tif (!strcmp(name, \"REMOVE\")) {\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\t/*OD remove*/\n\t\tif (!strcmp(str, \"OD\")) {\n\t\t\tGF_ODRemove *odR;\n\t\t\tif (!gf_bt_check_code(parser, '[')) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"[ expected\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\todR = (GF_ODRemove *) gf_odf_com_new(GF_ODF_OD_REMOVE_TAG);\n\t\t\tgf_list_add(parser->od_au->commands, odR);\n\t\t\twhile (!parser->done) {\n\t\t\t\tu32 id;\n\t\t\t\tif (gf_bt_check_code(parser, ']')) break;\n\t\t\t\tgf_bt_parse_int(parser, \"ODID\", (SFInt32*)&id);\n\t\t\t\tif (parser->last_error) return;\n\t\t\t\todR->OD_ID = (u16*)gf_realloc(odR->OD_ID, sizeof(u16) * (odR->NbODs+1));\n\t\t\t\todR->OD_ID[odR->NbODs] = id;\n\t\t\t\todR->NbODs++;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t/*ESD remove*/\n\t\tif (!strcmp(str, \"ESD\")) {\n\t\t\tu32 odid;\n\t\t\tGF_ESDRemove *esdR;\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tif (strcmp(str, \"FROM\")) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"FROM expected got %s\", str);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tgf_bt_parse_int(parser, \"ODID\", (SFInt32*)&odid);\n\t\t\tif (parser->last_error) return;\n\n\t\t\tif (!gf_bt_check_code(parser, '[')) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"[ expected\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tesdR = (GF_ESDRemove *) gf_odf_com_new(GF_ODF_ESD_REMOVE_TAG);\n\t\t\tesdR->ODID = odid;\n\t\t\tgf_list_add(parser->od_au->commands, esdR);\n\t\t\twhile (!parser->done) {\n\t\t\t\tu32 id;\n\t\t\t\tif (gf_bt_check_code(parser, ']')) break;\n\t\t\t\tgf_bt_parse_int(parser, \"ES_ID\", (SFInt32*)&id);\n\t\t\t\tif (parser->last_error) return;\n\t\t\t\tesdR->ES_ID = (u16*)gf_realloc(esdR->ES_ID, sizeof(u16) * (esdR->NbESDs+1));\n\t\t\t\tesdR->ES_ID[esdR->NbESDs] = id;\n\t\t\t\tesdR->NbESDs++;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tgf_bt_report(parser, GF_BAD_PARAM, \"%s: Unknown OD command\", str);\n\t\treturn;\n\t}\n}\n\n\n\nGF_Err gf_bt_loader_run_intern(GF_BTParser *parser, GF_Command *init_com, Bool initial_run)\n{\n\tchar *str;\n\tGF_Node *node, *vrml_root_node;\n\tBool force_new_com;\n\tGF_Route *r;\n\tBool has_id;\n\tchar szDEFName[1000];\n\n\tvrml_root_node = NULL;\n\thas_id = 0;\n\n\tif (init_com)\n\t\tparser->in_com = 0 ;\n\n\tparser->cur_com = init_com;\n\n\tforce_new_com = (parser->load->flags & GF_SM_LOAD_CONTEXT_READY) ? 1 : 0;\n\n\n\t/*create a default root node for all VRML nodes*/\n\tif (parser->is_wrl && !parser->top_nodes) {\n\t\tif (initial_run ) {\n#ifndef GPAC_DISABLE_X3D\n\t\t\tvrml_root_node = gf_node_new(parser->load->scene_graph, (parser->load->flags & GF_SM_LOAD_MPEG4_STRICT) ? TAG_MPEG4_Group : TAG_X3D_Group);\n#else\n\t\t\tvrml_root_node = gf_node_new(parser->load->scene_graph, TAG_MPEG4_Group);\n#endif\n\t\t\tgf_node_register(vrml_root_node, NULL);\n\t\t\tgf_node_init(vrml_root_node);\n\t\t\tgf_sg_set_root_node(parser->load->scene_graph, vrml_root_node);\n\t\t} else {\n\t\t\tvrml_root_node = gf_sg_get_root_node(parser->load->scene_graph);\n\t\t}\n\t}\n\n\tif (!parser->in_com)\n\t\tparser->stream_id = parser->load->force_es_id;\n\n\t/*parse all top-level items*/\n\twhile (!parser->last_error) {\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\tif (parser->done) break;\n\n\t\tif (!strcmp(str, \"\")) {\n\t\t\t//empty string, force moving to next char\n\t\t\tif (parser->line_pos<parser->line_size) parser->line_pos++;\n\t\t}\n\t\t/*X3D specific things (ignored for now)*/\n\t\telse if (!strcmp(str, \"PROFILE\")) gf_bt_force_line(parser);\n\t\telse if (!strcmp(str, \"COMPONENT\")) gf_bt_force_line(parser);\n\t\telse if (!strcmp(str, \"META\")) gf_bt_force_line(parser);\n\t\telse if (!strcmp(str, \"IMPORT\") || !strcmp(str, \"EXPORT\")) {\n\t\t\tgf_bt_report(parser, GF_NOT_SUPPORTED, \"X3D IMPORT/EXPORT not implemented\");\n\t\t\tbreak;\n\t\t}\n\n\t\t/*IOD*/\n\t\telse if (!strcmp(str, \"InitialObjectDescriptor\") || !strcmp(str, \"ObjectDescriptor\")) {\n\t\t\tparser->load->ctx->root_od = (GF_ObjectDescriptor *) gf_bt_parse_descriptor(parser, str);\n\t\t}\n\t\t/*explicit command*/\n\t\telse if (!strcmp(str, \"AT\") || !strcmp(str, \"RAP\")) {\n\t\t\tparser->au_is_rap = 0;\n\t\t\tif (!strcmp(str, \"RAP\")) {\n\t\t\t\tparser->au_is_rap = 1;\n\t\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\t\tif (strcmp(str, \"AT\")) {\n\t\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"AT expected got %s\", str);\n\t\t\t\t\tparser->last_error = GF_BAD_PARAM;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tforce_new_com = 0;\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tif (str[0] == 'D') {\n\t\t\t\tparser->au_time += atoi(&str[1]);\n\t\t\t} else {\n\t\t\t\tif (sscanf(str, \"%u\", &parser->au_time) != 1) {\n\t\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"Number expected got %s\", str);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (parser->last_error) break;\n\t\t\t/*reset all contexts*/\n\t\t\tif (parser->od_au && (parser->od_au->timing != parser->au_time)) parser->od_au = NULL;\n\t\t\tif (parser->bifs_au && (parser->bifs_au->timing != parser->au_time)) {\n\t\t\t\tgf_bt_check_unresolved_nodes(parser);\n\t\t\t\tparser->bifs_au = NULL;\n\t\t\t}\n\n\t\t\tparser->stream_id = 0;\n\t\t\t/*fix for mp4tool bt which doesn't support RAP signaling: assume the first AU\n\t\t\tis always RAP*/\n\t\t\tif (!parser->au_time) parser->au_is_rap = 1;\n\n\t\t\tparser->in_com = 1;\n\n\t\t\tif (!gf_bt_check_code(parser, '{')) {\n\t\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\t\tif (!strcmp(str, \"IN\")) {\n\t\t\t\t\tgf_bt_parse_int(parser, \"IN\", (SFInt32*)&parser->stream_id);\n\t\t\t\t\tif (parser->last_error) break;\n\t\t\t\t}\n\t\t\t\tif (!gf_bt_check_code(parser, '{')) {\n\t\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"{ expected\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*done loading init frame*/\n\t\t\tif (init_com && parser->au_time) break;\n\t\t}\n\t\telse if (!strcmp(str, \"PROTO\") || !strcmp(str, \"EXTERNPROTO\")) {\n\t\t\tgf_bt_parse_proto(parser, str, init_com ? init_com->new_proto_list : NULL);\n\t\t}\n\t\t/*compatibility for old bt (mp4tool) in ProtoLibs*/\n\t\telse if (!strcmp(str, \"NULL\")) {\n\t\t}\n\t\telse if (!strcmp(str, \"DEF\")) {\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tstrcpy(szDEFName, str);\n\t\t\thas_id = 1;\n\t\t}\n\t\telse if (!strcmp(str, \"ROUTE\")) {\n\t\t\tGF_Command *com = NULL;\n\t\t\tif (!parser->top_nodes && parser->bifs_au && !parser->is_wrl) {\n\t\t\t\t/*if doing a scene replace, we need route insert stuff*/\n\t\t\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_ROUTE_INSERT);\n\t\t\t\tgf_list_add(parser->bifs_au->commands, com);\n\t\t\t\tgf_list_add(parser->inserted_routes, com);\n\t\t\t}\n\n\t\t\tr = gf_bt_parse_route(parser, 1, 0, com);\n\t\t\tif (has_id) {\n\t\t\t\tu32 rID = gf_bt_get_route(parser, szDEFName);\n\t\t\t\tif (!rID) rID = gf_bt_get_next_route_id(parser);\n\t\t\t\tif (com) {\n\t\t\t\t\tcom->RouteID = rID;\n\t\t\t\t\tcom->def_name = gf_strdup(szDEFName);\n\t\t\t\t\tgf_sg_set_max_defined_route_id(parser->load->scene_graph, rID);\n\t\t\t\t} else if (r) {\n\t\t\t\t\tgf_sg_route_set_id(r, rID);\n\t\t\t\t\tgf_sg_route_set_name(r, szDEFName);\n\t\t\t\t}\n\t\t\t\thas_id = 0;\n\t\t\t}\n\t\t}\n\t\t/*OD commands*/\n\t\telse if (!strcmp(str, \"UPDATE\") || !strcmp(str, \"REMOVE\")) {\n\t\t\tBool is_base_stream = parser->stream_id ? 0 : 1;\n\t\t\tif (!parser->stream_id || parser->stream_id==parser->bifs_es->ESID) parser->stream_id = parser->base_od_id;\n\n\t\t\tif (parser->od_es && (parser->od_es->ESID != parser->stream_id)) {\n\t\t\t\tGF_StreamContext *prev = parser->od_es;\n\t\t\t\tparser->od_es = gf_sm_stream_new(parser->load->ctx, (u16) parser->stream_id, GF_STREAM_OD, GF_CODECID_OD_V1);\n\t\t\t\t/*force new AU if stream changed*/\n\t\t\t\tif (parser->od_es != prev) {\n\t\t\t\t\tparser->bifs_au = NULL;\n\t\t\t\t\tparser->od_au = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!parser->od_es) parser->od_es = gf_sm_stream_new(parser->load->ctx, (u16) parser->stream_id, GF_STREAM_OD, GF_CODECID_OD_V1);\n\t\t\tif (!parser->od_au) parser->od_au = gf_sm_stream_au_new(parser->od_es, parser->au_time, 0, parser->au_is_rap);\n\t\t\tgf_bt_parse_od_command(parser, str);\n\t\t\tif (is_base_stream) parser->stream_id= 0;\n\t\t}\n\t\t/*BIFS commands*/\n\t\telse if (!strcmp(str, \"REPLACE\") || !strcmp(str, \"INSERT\") || !strcmp(str, \"APPEND\") || !strcmp(str, \"DELETE\")\n\t\t         /*BIFS extended commands*/\n\t\t         || !strcmp(str, \"GLOBALQP\") || !strcmp(str, \"MULTIPLEREPLACE\") || !strcmp(str, \"MULTIPLEINDREPLACE\") || !strcmp(str, \"XDELETE\") || !strcmp(str, \"DELETEPROTO\") || !strcmp(str, \"INSERTPROTO\")\n\t\t         || !strcmp(str, \"XREPLACE\")\n\t\t        ) {\n\t\t\tBool is_base_stream = parser->stream_id ? 0 : 1;\n\n\t\t\tif (!parser->stream_id) parser->stream_id = parser->base_bifs_id;\n\t\t\tif (!parser->stream_id || (parser->od_es && (parser->stream_id==parser->od_es->ESID)) ) parser->stream_id = parser->base_bifs_id;\n\n\t\t\tif (parser->bifs_es->ESID != parser->stream_id) {\n\t\t\t\tGF_StreamContext *prev = parser->bifs_es;\n\t\t\t\tparser->bifs_es = gf_sm_stream_new(parser->load->ctx, (u16) parser->stream_id, GF_STREAM_SCENE, GF_CODECID_BIFS);\n\t\t\t\t/*force new AU if stream changed*/\n\t\t\t\tif (parser->bifs_es != prev) {\n\t\t\t\t\tgf_bt_check_unresolved_nodes(parser);\n\t\t\t\t\tparser->bifs_au = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (force_new_com) {\n\t\t\t\tforce_new_com = 0;\n\t\t\t\tparser->bifs_au = gf_list_last(parser->bifs_es->AUs);\n\t\t\t\tparser->au_time = (u32) (parser->bifs_au ? parser->bifs_au->timing : 0) + 1;\n\t\t\t\tparser->bifs_au = NULL;\n\t\t\t}\n\n\t\t\tif (!parser->bifs_au) parser->bifs_au = gf_sm_stream_au_new(parser->bifs_es, parser->au_time, 0, parser->au_is_rap);\n\t\t\tgf_bt_parse_bifs_command(parser, str, parser->bifs_au->commands);\n\t\t\tif (is_base_stream) parser->stream_id= 0;\n\t\t}\n\t\t/*implicit BIFS command on SFTopNodes only*/\n\t\telse if (!strcmp(str, \"OrderedGroup\")\n\t\t         || !strcmp(str, \"Group\")\n\t\t         || !strcmp(str, \"Layer2D\")\n\t\t         || !strcmp(str, \"Layer3D\")\n\t\t         /* VRML parsing: all nodes are allowed*/\n\t\t         || parser->is_wrl\n\t\t        )\n\t\t{\n\n\t\t\tnode = gf_bt_sf_node(parser, str, vrml_root_node, has_id ? szDEFName : NULL);\n\t\t\thas_id = 0;\n\t\t\tif (!node) break;\n\t\t\tif (parser->top_nodes) {\n\t\t\t\tgf_list_add(parser->top_nodes, node);\n\t\t\t} else if (!vrml_root_node) {\n\t\t\t\tif (init_com) init_com->node = node;\n\t\t\t\telse if (parser->load->flags & GF_SM_LOAD_CONTEXT_READY) {\n\t\t\t\t\tGF_Command *com = gf_sg_command_new(parser->load->scene_graph, GF_SG_SCENE_REPLACE);\n\t\t\t\t\tassert(!parser->bifs_au);\n\t\t\t\t\tassert(parser->bifs_es);\n\t\t\t\t\tparser->bifs_au = gf_sm_stream_au_new(parser->bifs_es, 0, 0, 1);\n\t\t\t\t\tgf_list_add(parser->bifs_au->commands, com);\n\t\t\t\t\tcom->node = node;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tgf_node_insert_child(vrml_root_node, node, -1);\n\t\t\t}\n\n\t\t\t/*\n\t\t\tif (!gf_sg_get_root_node(parser->load->scene_graph)) {\n\t\t\t\tgf_node_register(node, NULL);\n\t\t\t\tgf_sg_set_root_node(parser->load->scene_graph, node);\n\t\t\t}\n\t\t\t*/\n\t\t}\n\n\t\t/*if in command, check command end*/\n\t\telse {\n\t\t\t/*check command end*/\n\t\t\tif (/*in_com && */gf_bt_check_code(parser, '}')) parser->in_com = 0;\n\t\t\telse if (strlen(str)) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"%s: Unknown top-level element\", str);\n\t\t\t}\n\t\t\tparser->au_is_rap = 0;\n\t\t}\n\t}\n\tgf_bt_resolve_routes(parser, 0);\n\tgf_bt_check_unresolved_nodes(parser);\n\n\t/*load scripts*/\n\twhile (gf_list_count(parser->scripts)) {\n\t\tGF_Node *n = (GF_Node *)gf_list_get(parser->scripts, 0);\n\t\tgf_list_rem(parser->scripts, 0);\n\t\tgf_sg_script_load(n);\n\t}\n\treturn parser->last_error;\n}\n\nstatic GF_Err gf_sm_load_bt_initialize(GF_SceneLoader *load, const char *str, Bool input_only)\n{\n\tu32 size;\n\tgzFile gzInput;\n\tGF_Err e;\n\tunsigned char BOM[5];\n\tGF_BTParser *parser = load->loader_priv;\n\n\tparser->last_error = GF_OK;\n\n\tif (load->fileName) {\n\t\tFILE *test = gf_fopen(load->fileName, \"rb\");\n\t\tif (!test) return GF_URL_ERROR;\n\n\t\tsize = (u32) gf_fsize(test);\n\t\tgf_fclose(test);\n\n\t\tgzInput = gf_gzopen(load->fileName, \"rb\");\n\t\tif (!gzInput) return GF_IO_ERR;\n\n\t\tparser->line_buffer = (char *) gf_malloc(sizeof(char)*BT_LINE_SIZE);\n\t\tmemset(parser->line_buffer, 0, sizeof(char)*BT_LINE_SIZE);\n\t\tparser->file_size = size;\n\n\t\tparser->line_pos = parser->line_size = 0;\n\t\tgf_gzgets(gzInput, (char*) BOM, 5);\n\t\tgf_gzseek(gzInput, 0, SEEK_SET);\n\t\tparser->gz_in = gzInput;\n\n\t} else {\n\t\tif (!str || (strlen(str)<5) ) {\n\t\t\t/*wait for first string data to be fed to the parser (for load from string)*/\n\t\t\tparser->initialized = 0;\n\t\t\treturn GF_OK;\n\t\t}\n\t\tstrncpy((char *) BOM, str, 5);\n\t}\n\n\t/*0: no unicode, 1: UTF-16BE, 2: UTF-16LE*/\n\tif ((BOM[0]==0xFF) && (BOM[1]==0xFE)) {\n\t\tif (!BOM[2] && !BOM[3]) {\n\t\t\tgf_bt_report(parser, GF_NOT_SUPPORTED, \"UTF-32 Text Files not supported\");\n\t\t\treturn GF_NOT_SUPPORTED;\n\t\t} else {\n\t\t\tparser->unicode_type = 2;\n\t\t\tif (parser->gz_in) gf_gzseek(parser->gz_in, 2, SEEK_CUR);\n\t\t}\n\t} else if ((BOM[0]==0xFE) && (BOM[1]==0xFF)) {\n\t\tif (!BOM[2] && !BOM[3]) {\n\t\t\tgf_bt_report(parser, GF_NOT_SUPPORTED, \"UTF-32 Text Files not supported\");\n\t\t\treturn GF_NOT_SUPPORTED;\n\t\t} else {\n\t\t\tparser->unicode_type = 1;\n\t\t\tif (parser->gz_in) gf_gzseek(parser->gz_in, 2, SEEK_CUR);\n\t\t}\n\t} else if ((BOM[0]==0xEF) && (BOM[1]==0xBB) && (BOM[2]==0xBF)) {\n\t\t/*we handle UTF8 as asci*/\n\t\tparser->unicode_type = 0;\n\t\tif (parser->gz_in) gf_gzseek(parser->gz_in, 3, SEEK_CUR);\n\t}\n\tparser->initialized = 1;\n\n\tif ( load->fileName )\n\t{\n\t\tchar *sep = gf_file_ext_start(load->fileName);\n\t\tif (sep && !strnicmp(sep, \".wrl\", 4)) parser->is_wrl = 1;\n\t}\n\n\tif (input_only) return GF_OK;\n\n\t/*initalize default streams in the context*/\n\n\t/*chunk parsing*/\n\tif (load->flags & GF_SM_LOAD_CONTEXT_READY) {\n\t\tu32 i;\n\t\tGF_StreamContext *sc;\n\t\tif (!load->ctx) return GF_BAD_PARAM;\n\n\t\t/*restore context - note that base layer are ALWAYS declared BEFORE enhancement layers with gpac parsers*/\n\t\ti=0;\n\t\twhile ((sc = (GF_StreamContext*)gf_list_enum(load->ctx->streams, &i))) {\n\t\t\tswitch (sc->streamType) {\n\t\t\tcase GF_STREAM_SCENE:\n\t\t\t\tif (!parser->bifs_es) parser->bifs_es = sc;\n\t\t\t\tbreak;\n\t\t\tcase GF_STREAM_OD:\n\t\t\t\tif (!parser->od_es) parser->od_es = sc;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/*need at least one scene stream*/\n\t\tif (!parser->bifs_es) {\n\t\t\tparser->bifs_es = gf_sm_stream_new(load->ctx, 0, GF_STREAM_SCENE, GF_CODECID_BIFS);\n\t\t\tparser->load->ctx->scene_width = 0;\n\t\t\tparser->load->ctx->scene_height = 0;\n\t\t\tparser->load->ctx->is_pixel_metrics = 1;\n\t\t}\n\t\telse parser->base_bifs_id = parser->bifs_es->ESID;\n\t\tif (parser->od_es) parser->base_od_id = parser->od_es->ESID;\n\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_PARSER, (\"BT: MPEG-4 (BT) Scene Chunk Parsing\"));\n\t}\n\t/*context is not initialized - check for VRML*/\n\telse {\n\t\tGF_Command *com;\n\n\n\t\tparser->load = NULL;\n\t\tgf_bt_check_line(parser);\n\t\tparser->load = load;\n\t\tif (load->ctx && parser->def_w && parser->def_h) {\n\t\t\tload->ctx->scene_width = parser->def_w;\n\t\t\tload->ctx->scene_height = parser->def_h;\n\t\t}\n\n\t\t/*create at least one empty BIFS stream*/\n\t\tif (!parser->is_wrl && load->ctx) {\n\t\t\tparser->bifs_es = gf_sm_stream_new(load->ctx, 0, GF_STREAM_SCENE, GF_CODECID_BIFS);\n\t\t\tparser->bifs_au = gf_sm_stream_au_new(parser->bifs_es, 0, 0, 1);\n\t\t\tparser->load->ctx->is_pixel_metrics = 1;\n\t\t}\n\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_PARSER, ( ((parser->is_wrl==2) ? \"BT: X3D (WRL) Scene Parsing\\n\" : (parser->is_wrl ? \"BT: VRML Scene Parsing\\n\" : \"BT: MPEG-4 Scene Parsing\\n\")) ));\n\n\t\t/*default scene replace - we create it no matter what since it is used to store BIFS config when parsing IOD.*/\n\t\tcom = NULL;\n\t\tif (!parser->is_wrl) {\n\t\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_SCENE_REPLACE);\n\t\t\tgf_list_add(parser->bifs_au->commands, com);\n\t\t}\n\n\t\t/*and perform initial load*/\n\t\te = gf_bt_loader_run_intern(parser, com, 1);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\nvoid load_bt_done(GF_SceneLoader *load)\n{\n\tGF_BTParser *parser = (GF_BTParser *)load->loader_priv;\n\tif (!parser) return;\n\tgf_list_del(parser->unresolved_routes);\n\tgf_list_del(parser->inserted_routes);\n\tgf_list_del(parser->undef_nodes);\n\tgf_list_del(parser->def_nodes);\n\tgf_list_del(parser->peeked_nodes);\n\twhile (gf_list_count(parser->def_symbols)) {\n\t\tBTDefSymbol *d = (BTDefSymbol *)gf_list_get(parser->def_symbols, 0);\n\t\tgf_list_rem(parser->def_symbols, 0);\n\t\tgf_free(d->name);\n\t\tgf_free(d->value);\n\t\tgf_free(d);\n\t}\n\tgf_list_del(parser->def_symbols);\n\tgf_list_del(parser->scripts);\n\n\tif (parser->gz_in) gf_gzclose(parser->gz_in);\n\tif (parser->line_buffer) gf_free(parser->line_buffer);\n\tgf_free(parser);\n\tload->loader_priv = NULL;\n}\n\nGF_Err load_bt_run(GF_SceneLoader *load)\n{\n\tGF_Err e;\n\tGF_BTParser *parser = (GF_BTParser *)load->loader_priv;\n\tif (!parser) return GF_BAD_PARAM;\n\n\tif (!parser->initialized) {\n\t\te = gf_sm_load_bt_initialize(load, NULL, 1);\n\t\tif (e) return e;\n\t}\n\n\te = gf_bt_loader_run_intern(parser, NULL, 0);\n\n\tif ((e<0) || parser->done) {\n\t\tparser->done = 0;\n\t\tparser->initialized = 0;\n\t\tif (parser->gz_in) {\n\t\t\tgf_gzclose(parser->gz_in);\n\t\t\tparser->gz_in = NULL;\n\t\t}\n\n\t\tif (parser->line_buffer) {\n\t\t\tgf_free(parser->line_buffer);\n\t\t\tparser->line_buffer = NULL;\n\t\t}\n\t\tparser->file_size = 0;\n\t\tparser->line_pos = parser->line_size = 0;\n\t\tload->fileName = NULL;\n\t}\n\treturn e;\n}\n\n\nGF_Err load_bt_parse_string(GF_SceneLoader *load, const char *str)\n{\n\tGF_Err e;\n\tchar *dup_str;\n\tGF_BTParser *parser = (GF_BTParser *)load->loader_priv;\n\tif (!parser) return GF_BAD_PARAM;\n\n\tif (parser->done) {\n\t\tparser->done = 0;\n\t\tparser->initialized = 0;\n\t\tparser->file_size = 0;\n\t\tparser->line_pos = 0;\n\t}\n\tparser->line_buffer = dup_str = gf_strdup(str);\n\tparser->line_size = (s32)strlen(str);\n\n\tif (!parser->initialized) {\n\t\te = gf_sm_load_bt_initialize(load, str, 0);\n\t\tif (e) {\n\t\t\tgf_free(dup_str);\n\t\t\treturn e;\n\t\t}\n\t}\n\te = gf_bt_loader_run_intern(parser, NULL, 0);\n\tparser->line_buffer = NULL;\n\tparser->line_size = 0;\n\tgf_free(dup_str);\n\treturn e;\n}\n\nGF_Err load_bt_suspend(GF_SceneLoader *load, Bool suspend)\n{\n\treturn GF_OK;\n}\n\nGF_Err gf_sm_load_init_bt(GF_SceneLoader *load)\n{\n\tGF_Err e;\n\tGF_BTParser *parser;\n\n\tif (!load || (!load->ctx && !load->scene_graph) ) return GF_BAD_PARAM;\n\tif (!load->scene_graph) load->scene_graph = load->ctx->scene_graph;\n\n\tGF_SAFEALLOC(parser, GF_BTParser);\n\tif (!parser) return GF_OUT_OF_MEM;\n\tparser->load = load;\n\tload->loader_priv = parser;\n\tparser->def_symbols = gf_list_new();\n\tparser->unresolved_routes = gf_list_new();\n\tparser->inserted_routes = gf_list_new();\n\tparser->undef_nodes = gf_list_new();\n\tparser->def_nodes = gf_list_new();\n\tparser->peeked_nodes = gf_list_new();\n\tparser->scripts = gf_list_new();\n\n\tload->process = load_bt_run;\n\tload->done = load_bt_done;\n\tload->suspend = load_bt_suspend;\n\tload->parse_string = load_bt_parse_string;\n\n#ifdef GPAC_ENABLE_COVERAGE\n\tif (gf_sys_is_cov_mode()) {\n\t\tgf_bt_report(parser, GF_OK, NULL);\n\t}\n#endif\n\n\te = gf_sm_load_bt_initialize(load, NULL, 0);\n\tif (e) {\n\t\tload_bt_done(load);\n\t\treturn e;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_List *gf_sm_load_bt_from_string(GF_SceneGraph *in_scene, char *node_str, Bool force_wrl)\n{\n\tGF_SceneLoader ctx;\n\tGF_BTParser parser;\n\tmemset(&ctx, 0, sizeof(GF_SceneLoader));\n\tctx.scene_graph = in_scene;\n\tmemset(&parser, 0, sizeof(GF_BTParser));\n\tparser.line_buffer = node_str;\n\tparser.line_size = (u32) strlen(node_str);\n\tparser.load = &ctx;\n\tparser.top_nodes = gf_list_new();\n\tparser.undef_nodes = gf_list_new();\n\tparser.def_nodes = gf_list_new();\n\tparser.peeked_nodes = gf_list_new();\n\tparser.is_wrl = force_wrl;\n\tgf_bt_loader_run_intern(&parser, NULL, 1);\n\tgf_list_del(parser.undef_nodes);\n\tgf_list_del(parser.def_nodes);\n\tgf_list_del(parser.peeked_nodes);\n\twhile (gf_list_count(parser.def_symbols)) {\n\t\tBTDefSymbol *d = (BTDefSymbol *)gf_list_get(parser.def_symbols, 0);\n\t\tgf_list_rem(parser.def_symbols, 0);\n\t\tgf_free(d->name);\n\t\tgf_free(d->value);\n\t\tgf_free(d);\n\t}\n\tgf_list_del(parser.def_symbols);\n\tgf_list_del(parser.scripts);\n\n\treturn parser.top_nodes;\n}\n\n#endif /*GPAC_DISABLE_LOADER_BT*/\n", "/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2005-2022\n *\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / common tools sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/xml.h>\n#include <gpac/utf.h>\n#include <gpac/network.h>\n\n#ifndef GPAC_DISABLE_ZLIB\n/*since 0.2.2, we use zlib for xmt/x3d reading to handle gz files*/\n#include <zlib.h>\n\n#if (defined(WIN32) || defined(_WIN32_WCE)) && !defined(__GNUC__)\n#pragma comment(lib, \"zlib\")\n#endif\n#else\n#define NO_GZIP\n#endif\n\n\n#define XML_INPUT_SIZE\t4096\n\n\nstatic GF_Err gf_xml_sax_parse_intern(GF_SAXParser *parser, char *current);\n\nstatic char *xml_translate_xml_string(char *str)\n{\n\tchar *value;\n\tu32 size, i, j;\n\tif (!str || !strlen(str)) return NULL;\n\tvalue = (char *)gf_malloc(sizeof(char) * 500);\n\tsize = 500;\n\ti = j = 0;\n\twhile (str[i]) {\n\t\tif (j+20 >= size) {\n\t\t\tsize += 500;\n\t\t\tvalue = (char *)gf_realloc(value, sizeof(char)*size);\n\t\t}\n\t\tif (str[i] == '&') {\n\t\t\tif (str[i+1]=='#') {\n\t\t\t\tchar szChar[20], *end;\n\t\t\t\tu16 wchar[2];\n\t\t\t\tu32 val, _len;\n\t\t\t\tconst unsigned short *srcp;\n\t\t\t\tstrncpy(szChar, str+i, 10);\n\t\t\t\tszChar[10] = 0;\n\t\t\t\tend = strchr(szChar, ';');\n\t\t\t\tif (!end) break;\n\t\t\t\tend[1] = 0;\n\t\t\t\ti += (u32) strlen(szChar);\n\t\t\t\twchar[1] = 0;\n\t\t\t\tif (szChar[2]=='x')\n\t\t\t\t\tsscanf(szChar, \"&#x%x;\", &val);\n\t\t\t\telse\n\t\t\t\t\tsscanf(szChar, \"&#%u;\", &val);\n\t\t\t\twchar[0] = val;\n\t\t\t\tsrcp = wchar;\n\t\t\t\t_len = gf_utf8_wcstombs(&value[j], 20, &srcp);\n\t\t\t\tif (_len == GF_UTF8_FAIL) _len = 0;\n\t\t\t\tj += _len;\n\t\t\t}\n\t\t\telse if (!strnicmp(&str[i], \"&amp;\", sizeof(char)*5)) {\n\t\t\t\tvalue[j] = '&';\n\t\t\t\tj++;\n\t\t\t\ti+= 5;\n\t\t\t}\n\t\t\telse if (!strnicmp(&str[i], \"&lt;\", sizeof(char)*4)) {\n\t\t\t\tvalue[j] = '<';\n\t\t\t\tj++;\n\t\t\t\ti+= 4;\n\t\t\t}\n\t\t\telse if (!strnicmp(&str[i], \"&gt;\", sizeof(char)*4)) {\n\t\t\t\tvalue[j] = '>';\n\t\t\t\tj++;\n\t\t\t\ti+= 4;\n\t\t\t}\n\t\t\telse if (!strnicmp(&str[i], \"&apos;\", sizeof(char)*6)) {\n\t\t\t\tvalue[j] = '\\'';\n\t\t\t\tj++;\n\t\t\t\ti+= 6;\n\t\t\t}\n\t\t\telse if (!strnicmp(&str[i], \"&quot;\", sizeof(char)*6)) {\n\t\t\t\tvalue[j] = '\\\"';\n\t\t\t\tj++;\n\t\t\t\ti+= 6;\n\t\t\t} else {\n\t\t\t\tvalue[j] = str[i];\n\t\t\t\tj++;\n\t\t\t\ti++;\n\t\t\t}\n\t\t} else {\n\t\t\tvalue[j] = str[i];\n\t\t\tj++;\n\t\t\ti++;\n\t\t}\n\t}\n\tvalue[j] = 0;\n\treturn value;\n}\n\n\nenum\n{\n\tSAX_STATE_ATT_NAME,\n\tSAX_STATE_ATT_VALUE,\n\tSAX_STATE_ELEMENT,\n\tSAX_STATE_COMMENT,\n\tSAX_STATE_TEXT_CONTENT,\n\tSAX_STATE_ENTITY,\n\tSAX_STATE_SKIP_DOCTYPE,\n\tSAX_STATE_CDATA,\n\tSAX_STATE_DONE,\n\tSAX_STATE_XML_PROC,\n\tSAX_STATE_SYNTAX_ERROR,\n\tSAX_STATE_ALLOC_ERROR,\n};\n\ntypedef struct\n{\n\tu32 name_start, name_end;\n\tu32 val_start, val_end;\n\tBool has_entities;\n} GF_XMLSaxAttribute;\n\n\n/* #define NO_GZIP */\n\n\nstruct _tag_sax_parser\n{\n\t/*0: UTF-8, 1: UTF-16 BE, 2: UTF-16 LE. String input is always converted back to utf8*/\n\ts32 unicode_type;\n\tchar *buffer;\n\t/*alloc size, line size and current position*/\n\tu32 alloc_size, line_size, current_pos;\n\t/*current node depth*/\n\tu32 node_depth;\n\n\t/*gz input file*/\n#ifdef NO_GZIP\n\tFILE *f_in;\n#else\n\tgzFile gz_in;\n#endif\n\t/*current line , file size and pos for user notif*/\n\tu32 line, file_size, file_pos;\n\n\t/*SAX callbacks*/\n\tgf_xml_sax_node_start sax_node_start;\n\tgf_xml_sax_node_end sax_node_end;\n\tgf_xml_sax_text_content sax_text_content;\n\tvoid *sax_cbck;\n\tgf_xml_sax_progress on_progress;\n\n\tu32 sax_state;\n\tu32 init_state;\n\tGF_List *entities;\n\tchar att_sep;\n\tBool in_entity, suspended;\n\tu32 in_quote;\n\n\tu32 elt_start_pos, elt_end_pos;\n\n\t/*last error found*/\n\tchar err_msg[1000];\n\n\tu32 att_name_start, elt_name_start, elt_name_end, text_start, text_end;\n\tu32 text_check_escapes;\n\n\tGF_XMLAttribute *attrs;\n\tGF_XMLSaxAttribute *sax_attrs;\n\tu32 nb_attrs, nb_alloc_attrs;\n\tu32 ent_rec_level;\n};\n\nstatic GF_XMLSaxAttribute *xml_get_sax_attribute(GF_SAXParser *parser)\n{\n\tif (parser->nb_attrs==parser->nb_alloc_attrs) {\n\t\tparser->nb_alloc_attrs++;\n\t\tparser->sax_attrs = (GF_XMLSaxAttribute *)gf_realloc(parser->sax_attrs, sizeof(GF_XMLSaxAttribute)*parser->nb_alloc_attrs);\n\t\tparser->attrs = (GF_XMLAttribute *)gf_realloc(parser->attrs, sizeof(GF_XMLAttribute)*parser->nb_alloc_attrs);\n\t}\n\treturn &parser->sax_attrs[parser->nb_attrs++];\n}\n\nstatic void xml_sax_swap(GF_SAXParser *parser)\n{\n\tif (parser->current_pos && ((parser->sax_state==SAX_STATE_TEXT_CONTENT) || (parser->sax_state==SAX_STATE_COMMENT) ) ) {\n\t\tif (parser->line_size >= parser->current_pos) {\n\t\t\tparser->line_size -= parser->current_pos;\n\t\t\tparser->file_pos += parser->current_pos;\n\t\t\tif (parser->line_size) memmove(parser->buffer, parser->buffer + parser->current_pos, sizeof(char)*parser->line_size);\n\t\t\tparser->buffer[parser->line_size] = 0;\n\t\t\tparser->current_pos = 0;\n\t\t}\n\t}\n}\n\nstatic void format_sax_error(GF_SAXParser *parser, u32 linepos, const char* fmt, ...)\n{\n\tva_list args;\n\tu32 len;\n\n\tif (!parser) return;\n\n\tva_start(args, fmt);\n\tvsnprintf(parser->err_msg, GF_ARRAY_LENGTH(parser->err_msg), fmt, args);\n\tva_end(args);\n\n\tif (strlen(parser->err_msg)+30 < GF_ARRAY_LENGTH(parser->err_msg)) {\n\t\tchar szM[20];\n\t\tsnprintf(szM, 20, \" - Line %d: \", parser->line + 1);\n\t\tstrcat(parser->err_msg, szM);\n\t\tlen = (u32) strlen(parser->err_msg);\n\t\tstrncpy(parser->err_msg + len, parser->buffer+ (linepos ? linepos : parser->current_pos), 10);\n\t\tparser->err_msg[len + 10] = 0;\n\t}\n\tparser->sax_state = SAX_STATE_SYNTAX_ERROR;\n}\n\nstatic void xml_sax_node_end(GF_SAXParser *parser, Bool had_children)\n{\n\tchar *name, c;\n\n\tassert(parser->elt_name_start);\n\tassert(parser->elt_name_end);\n\tif (!parser->node_depth) {\n\t\tformat_sax_error(parser, 0, \"Markup error\");\n\t\treturn;\n\t}\n\tc = parser->buffer[parser->elt_name_end - 1];\n\tparser->buffer[parser->elt_name_end - 1] = 0;\n\tname = parser->buffer + parser->elt_name_start - 1;\n\n\tif (parser->sax_node_end) {\n\t\tchar *sep = strchr(name, ':');\n\t\tif (sep) {\n\t\t\tsep[0] = 0;\n\t\t\tparser->sax_node_end(parser->sax_cbck, sep+1, name);\n\t\t\tsep[0] = ':';\n\t\t} else {\n\t\t\tparser->sax_node_end(parser->sax_cbck, name, NULL);\n\t\t}\n\t}\n\tparser->buffer[parser->elt_name_end - 1] = c;\n\tparser->node_depth--;\n\tif (!parser->init_state && !parser->node_depth) parser->sax_state = SAX_STATE_DONE;\n\txml_sax_swap(parser);\n\tparser->text_start = parser->text_end = 0;\n}\n\nstatic void xml_sax_node_start(GF_SAXParser *parser)\n{\n\tBool has_entities = GF_FALSE;\n\tu32 i;\n\tchar c, *name;\n\n\tassert(parser->elt_name_start && parser->elt_name_end);\n\tc = parser->buffer[parser->elt_name_end - 1];\n\tparser->buffer[parser->elt_name_end - 1] = 0;\n\tname = parser->buffer + parser->elt_name_start - 1;\n\n\tfor (i=0; i<parser->nb_attrs; i++) {\n\t\tparser->attrs[i].name = parser->buffer + parser->sax_attrs[i].name_start - 1;\n\t\tparser->buffer[parser->sax_attrs[i].name_end-1] = 0;\n\t\tparser->attrs[i].value = parser->buffer + parser->sax_attrs[i].val_start - 1;\n\t\tparser->buffer[parser->sax_attrs[i].val_end-1] = 0;\n\n\t\tif (strchr(parser->attrs[i].value, '&')) {\n\t\t\tparser->sax_attrs[i].has_entities = GF_TRUE;\n\t\t\thas_entities = GF_TRUE;\n\t\t\tparser->attrs[i].value = xml_translate_xml_string(parser->attrs[i].value);\n\t\t}\n\t\t/*store first char pos after current attrib for node peeking*/\n\t\tparser->att_name_start = parser->sax_attrs[i].val_end;\n\t}\n\n\tif (parser->sax_node_start) {\n\t\tchar *sep = strchr(name, ':');\n\t\tif (sep) {\n\t\t\tsep[0] = 0;\n\t\t\tparser->sax_node_start(parser->sax_cbck, sep+1, name, parser->attrs, parser->nb_attrs);\n\t\t\tsep[0] = ':';\n\t\t} else {\n\t\t\tparser->sax_node_start(parser->sax_cbck, name, NULL, parser->attrs, parser->nb_attrs);\n\t\t}\n\t}\n\tparser->att_name_start = 0;\n\tparser->buffer[parser->elt_name_end - 1] = c;\n\tparser->node_depth++;\n\tif (has_entities) {\n\t\tfor (i=0; i<parser->nb_attrs; i++) {\n\t\t\tif (parser->sax_attrs[i].has_entities) {\n\t\t\t\tparser->sax_attrs[i].has_entities = GF_FALSE;\n\t\t\t\tgf_free(parser->attrs[i].value);\n\t\t\t}\n\t\t}\n\t}\n\tparser->nb_attrs = 0;\n\txml_sax_swap(parser);\n\tparser->text_start = parser->text_end = 0;\n}\n\nstatic Bool xml_sax_parse_attribute(GF_SAXParser *parser)\n{\n\tchar *sep;\n\tGF_XMLSaxAttribute *att = NULL;\n\n\t/*looking for attribute name*/\n\tif (parser->sax_state==SAX_STATE_ATT_NAME) {\n\t\t/*looking for start*/\n\t\tif (!parser->att_name_start) {\n\t\t\twhile (parser->current_pos < parser->line_size) {\n\t\t\t\tu8 c = parser->buffer[parser->current_pos];\n\t\t\t\tswitch (c) {\n\t\t\t\tcase '\\n':\n\t\t\t\t\tparser->line++;\n\t\t\t\tcase ' ':\n\t\t\t\tcase '\\r':\n\t\t\t\tcase '\\t':\n\t\t\t\t\tparser->current_pos++;\n\t\t\t\t\tcontinue;\n\t\t\t\t/*end of element*/\n\t\t\t\tcase '?':\n\t\t\t\t\tif (parser->init_state!=1) break;\n\t\t\t\tcase '/':\n\t\t\t\t\t/*not enough data*/\n\t\t\t\t\tif (parser->current_pos+1 == parser->line_size) return GF_TRUE;\n\t\t\t\t\tif (parser->buffer[parser->current_pos+1]=='>') {\n\t\t\t\t\t\tparser->current_pos+=2;\n\t\t\t\t\t\tparser->elt_end_pos = parser->file_pos + parser->current_pos - 1;\n\t\t\t\t\t\t/*done parsing attr AND elements*/\n\t\t\t\t\t\tif (!parser->init_state) {\n\t\t\t\t\t\t\txml_sax_node_start(parser);\n\t\t\t\t\t\t\t/*move to SAX_STATE_TEXT_CONTENT to force text flush*/\n\t\t\t\t\t\t\tparser->sax_state = SAX_STATE_TEXT_CONTENT;\n\t\t\t\t\t\t\txml_sax_node_end(parser, GF_FALSE);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tparser->nb_attrs = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tparser->sax_state = (parser->init_state) ? SAX_STATE_ELEMENT : SAX_STATE_TEXT_CONTENT;\n\t\t\t\t\t\tparser->text_start = parser->text_end = 0;\n\t\t\t\t\t\treturn GF_FALSE;\n\t\t\t\t\t}\n\t\t\t\t\tif (!parser->in_quote && (c=='/')) {\n\t\t\t\t\t\tif (!parser->init_state) {\n\t\t\t\t\t\t\tformat_sax_error(parser, 0, \"Markup error\");\n\t\t\t\t\t\t\treturn GF_TRUE;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\"':\n\t\t\t\t\tif (parser->sax_state==SAX_STATE_ATT_VALUE) break;\n\t\t\t\t\tif (parser->in_quote && (parser->in_quote!=c) ) {\n\t\t\t\t\t\tformat_sax_error(parser, 0, \"Markup error\");\n\t\t\t\t\t\treturn GF_TRUE;\n\t\t\t\t\t}\n\t\t\t\t\tif (parser->in_quote) parser->in_quote = 0;\n\t\t\t\t\telse parser->in_quote = c;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '>':\n\t\t\t\t\tparser->current_pos+=1;\n\t\t\t\t\t/*end of <!DOCTYPE>*/\n\t\t\t\t\tif (parser->init_state) {\n\t\t\t\t\t\tif (parser->init_state==1) {\n\t\t\t\t\t\t\tformat_sax_error(parser, 0, \"Invalid <!DOCTYPE...> or <?xml...?>\");\n\t\t\t\t\t\t\treturn GF_TRUE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tparser->sax_state = SAX_STATE_ELEMENT;\n\t\t\t\t\t\treturn GF_FALSE;\n\t\t\t\t\t}\n\t\t\t\t\t/*done parsing attr*/\n\t\t\t\t\tparser->sax_state = SAX_STATE_TEXT_CONTENT;\n\t\t\t\t\txml_sax_node_start(parser);\n\t\t\t\t\treturn GF_FALSE;\n\t\t\t\tcase '[':\n\t\t\t\t\tif (parser->init_state) {\n\t\t\t\t\t\tparser->current_pos+=1;\n\t\t\t\t\t\tif (parser->init_state==1) {\n\t\t\t\t\t\t\tformat_sax_error(parser, 0, \"Invalid <!DOCTYPE...> or <?xml...?>\");\n\t\t\t\t\t\t\treturn GF_TRUE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tparser->sax_state = SAX_STATE_ELEMENT;\n\t\t\t\t\t\treturn GF_FALSE;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '<':\n\t\t\t\t\tformat_sax_error(parser, 0, \"Invalid character '<'\");\n\t\t\t\t\treturn GF_FALSE;\n\t\t\t\t/*first char of attr name*/\n\t\t\t\tdefault:\n\t\t\t\t\tparser->att_name_start = parser->current_pos + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tparser->current_pos++;\n\t\t\t\tif (parser->att_name_start) break;\n\t\t\t}\n\t\t\tif (parser->current_pos == parser->line_size) return GF_TRUE;\n\t\t}\n\n\t\tif (parser->init_state==2) {\n\t\t\tsep = strchr(parser->buffer + parser->att_name_start - 1, parser->in_quote ?  parser->in_quote : ' ');\n\t\t\t/*not enough data*/\n\t\t\tif (!sep) return GF_TRUE;\n\t\t\tparser->current_pos = (u32) (sep - parser->buffer);\n\t\t\tparser->att_name_start = 0;\n\t\t\tif (parser->in_quote) {\n\t\t\t\tparser->current_pos++;\n\t\t\t\tparser->in_quote = 0;\n\t\t\t}\n\t\t\treturn GF_FALSE;\n\t\t}\n\n\t\t/*looking for '\"'*/\n\t\tif (parser->att_name_start) {\n\t\t\tu32 i, first=1;\n\t\t\tsep = strchr(parser->buffer + parser->att_name_start - 1, '=');\n\t\t\t/*not enough data*/\n\t\t\tif (!sep) return GF_TRUE;\n\n\t\t\tparser->current_pos = (u32) (sep - parser->buffer);\n\t\t\tatt = xml_get_sax_attribute(parser);\n\t\t\tatt->name_start = parser->att_name_start;\n\t\t\tatt->name_end = parser->current_pos + 1;\n\t\t\twhile (strchr(\" \\n\\t\", parser->buffer[att->name_end - 2])) {\n\t\t\t\tassert(att->name_end);\n\t\t\t\tatt->name_end --;\n\t\t\t}\n\t\t\tatt->has_entities = GF_FALSE;\n\n\t\t\tfor (i=att->name_start; i<att->name_end; i++) {\n\t\t\t\tchar c = parser->buffer[i-1];\n\t\t\t\tif ((c>='a') && (c<='z')) {}\n\t\t\t\telse if ((c>='A') && (c<='Z')) {}\n\t\t\t\telse if ((c==':') || (c=='_')) {}\n\n\t\t\t\telse if (!first && ((c=='-') || (c=='.') || ((c>='0') && (c<='9')) )) {}\n\n\t\t\t\telse {\n\t\t\t\t\tformat_sax_error(parser, att->name_start-1, \"Invalid character \\'%c\\' for attribute name\", c);\n\t\t\t\t\treturn GF_TRUE;\n\t\t\t\t}\n\n\t\t\t\tfirst=0;\n\t\t\t}\n\n\t\t\tparser->att_name_start = 0;\n\t\t\tparser->current_pos++;\n\t\t\tparser->sax_state = SAX_STATE_ATT_VALUE;\n\n\t\t}\n\t}\n\n\tif (parser->sax_state == SAX_STATE_ATT_VALUE) {\n\t\tatt = &parser->sax_attrs[parser->nb_attrs-1];\n\t\t/*looking for first delimiter*/\n\t\tif (!parser->att_sep) {\n\t\t\twhile (parser->current_pos < parser->line_size) {\n\t\t\t\tu8 c = parser->buffer[parser->current_pos];\n\t\t\t\tswitch (c) {\n\t\t\t\tcase '\\n':\n\t\t\t\t\tparser->line++;\n\t\t\t\tcase ' ':\n\t\t\t\tcase '\\r':\n\t\t\t\tcase '\\t':\n\t\t\t\t\tparser->current_pos++;\n\t\t\t\t\tcontinue;\n\t\t\t\tcase '\\'':\n\t\t\t\tcase '\"':\n\t\t\t\t\tparser->att_sep = c;\n\t\t\t\t\tatt->val_start = parser->current_pos + 2;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tparser->current_pos++;\n\t\t\t\tif (parser->att_sep) break;\n\t\t\t}\n\t\t\tif (parser->current_pos == parser->line_size) return GF_TRUE;\n\t\t}\n\natt_retry:\n\n\t\tassert(parser->att_sep);\n\t\tsep = strchr(parser->buffer + parser->current_pos, parser->att_sep);\n\t\tif (!sep || !sep[1]) return GF_TRUE;\n\n\t\tif (sep[1]==parser->att_sep) {\n\t\t\tformat_sax_error(parser, (u32) (sep - parser->buffer), \"Invalid character %c after attribute value separator %c \", sep[1], parser->att_sep);\n\t\t\treturn GF_TRUE;\n\t\t}\n\n\t\tif (!parser->init_state && (strchr(\" />\\n\\t\\r\", sep[1])==NULL)) {\n\t\t\tparser->current_pos = (u32) (sep - parser->buffer + 1);\n\t\t\tgoto att_retry;\n\t\t}\n\n\t\tparser->current_pos = (u32) (sep - parser->buffer);\n\t\tatt->val_end = parser->current_pos + 1;\n\t\tparser->current_pos++;\n\n\t\t/*\"style\" always at the beginning of the attributes for ease of parsing*/\n\t\tif (!strncmp(parser->buffer + att->name_start-1, \"style\", 5)) {\n\t\t\tGF_XMLSaxAttribute prev = parser->sax_attrs[0];\n\t\t\tparser->sax_attrs[0] = *att;\n\t\t\t*att = prev;\n\t\t}\n\t\tparser->att_sep = 0;\n\t\tparser->sax_state = SAX_STATE_ATT_NAME;\n\t\tparser->att_name_start = 0;\n\t\treturn GF_FALSE;\n\t}\n\treturn GF_TRUE;\n}\n\n\ntypedef struct\n{\n\tchar *name;\n\tchar *value;\n\tu32 namelen;\n\tu8 sep;\n} XML_Entity;\n\nstatic void xml_sax_flush_text(GF_SAXParser *parser)\n{\n\tchar *text, c;\n\tif (!parser->text_start || parser->init_state || !parser->sax_text_content) return;\n\n\tassert(parser->text_start < parser->text_end);\n\n\tc = parser->buffer[parser->text_end-1];\n\tparser->buffer[parser->text_end-1] = 0;\n\ttext = parser->buffer + parser->text_start-1;\n\n\t/*solve XML built-in entities*/\n//old code commented for ref, we now track escape chars\n//\tif (strchr(text, '&') && strchr(text, ';')) {\n\tif (parser->text_check_escapes==0x3) {\n\t\tchar *xml_text = xml_translate_xml_string(text);\n\t\tif (xml_text) {\n\t\t\tparser->sax_text_content(parser->sax_cbck, xml_text, (parser->sax_state==SAX_STATE_CDATA) ? GF_TRUE : GF_FALSE);\n\t\t\tgf_free(xml_text);\n\t\t}\n\t} else {\n\t\tparser->sax_text_content(parser->sax_cbck, text, (parser->sax_state==SAX_STATE_CDATA) ? GF_TRUE : GF_FALSE);\n\t}\n\tparser->buffer[parser->text_end-1] = c;\n\tparser->text_start = parser->text_end = 0;\n\tparser->text_check_escapes = 0;\n}\n\nstatic void xml_sax_store_text(GF_SAXParser *parser, u32 txt_len)\n{\n\tif (!txt_len) return;\n\n\tif (!parser->text_start) {\n\t\tparser->text_check_escapes = 0;\n\t\tparser->text_start = parser->current_pos + 1;\n\t\tparser->text_end = parser->text_start + txt_len;\n\t\tparser->current_pos += txt_len;\n\t\tassert(parser->current_pos <= parser->line_size);\n\t\treturn;\n\t}\n\t/*contiguous text*/\n\tif (parser->text_end && (parser->text_end-1 == parser->current_pos)) {\n\t\tparser->text_end += txt_len;\n\t\tparser->current_pos += txt_len;\n\t\tassert(parser->current_pos <= parser->line_size);\n\t\treturn;\n\t}\n\t/*need to flush*/\n\txml_sax_flush_text(parser);\n\n\tparser->text_start = parser->current_pos + 1;\n\tparser->text_end = parser->text_start + txt_len;\n\tparser->current_pos += txt_len;\n\tassert(parser->current_pos <= parser->line_size);\n}\n\nstatic char *xml_get_current_text(GF_SAXParser *parser)\n{\n\tchar *text, c;\n\tif (!parser->text_start) return NULL;\n\n\tc = parser->buffer[parser->text_end-1];\n\tparser->buffer[parser->text_end-1] = 0;\n\ttext = gf_strdup(parser->buffer + parser->text_start-1);\n\tparser->buffer[parser->text_end-1] = c;\n\tparser->text_start = parser->text_end = 0;\n\treturn text;\n}\n\nstatic void xml_sax_skip_doctype(GF_SAXParser *parser)\n{\n\twhile (parser->current_pos < parser->line_size) {\n\t\tif (parser->buffer[parser->current_pos]=='>') {\n\t\t\tparser->sax_state = SAX_STATE_ELEMENT;\n\t\t\tparser->current_pos++;\n\t\t\txml_sax_swap(parser);\n\t\t\treturn;\n\t\t}\n\t\tparser->current_pos++;\n\t}\n}\n\nstatic void xml_sax_skip_xml_proc(GF_SAXParser *parser)\n{\n\twhile (parser->current_pos + 1 < parser->line_size) {\n\t\tif ((parser->buffer[parser->current_pos]=='?') && (parser->buffer[parser->current_pos+1]=='>')) {\n\t\t\tparser->sax_state = SAX_STATE_ELEMENT;\n\t\t\tparser->current_pos++;\n\t\t\txml_sax_swap(parser);\n\t\t\treturn;\n\t\t}\n\t\tparser->current_pos++;\n\t}\n}\n\n\nstatic void xml_sax_parse_entity(GF_SAXParser *parser)\n{\n\tchar szC[2];\n\tchar *ent_name=NULL;\n\tu32 i = 0;\n\tXML_Entity *ent = (XML_Entity *)gf_list_last(parser->entities);\n\tchar *skip_chars = \" \\t\\n\\r\";\n\ti=0;\n\tif (ent && ent->value) ent = NULL;\n\tif (ent) skip_chars = NULL;\n\tszC[1]=0;\n\n\twhile (parser->current_pos+i < parser->line_size) {\n\t\tu8 c = parser->buffer[parser->current_pos+i];\n\t\tif (skip_chars && strchr(skip_chars, c)) {\n\t\t\tif (c=='\\n') parser->line++;\n\t\t\tparser->current_pos++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!ent && (c=='%')) {\n\t\t\tparser->current_pos+=i+1;\n\t\t\tparser->sax_state = SAX_STATE_SKIP_DOCTYPE;\n\t\t\tif (ent_name) gf_free(ent_name);\n\t\t\treturn;\n\t\t}\n\t\telse if (!ent && ((c=='\\\"') || (c=='\\'')) ) {\n\t\t\tGF_SAFEALLOC(ent, XML_Entity);\n\t\t\tif (!ent) {\n\t\t\t\tparser->sax_state = SAX_STATE_ALLOC_ERROR;\n\t\t\t\tif (ent_name) gf_free(ent_name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!ent_name) gf_dynstrcat(&ent_name, \"\", NULL);\n\n\t\t\tent->name = ent_name;\n\t\t\tent_name=NULL;\n\t\t\tent->namelen = (u32) strlen(ent->name);\n\t\t\tent->sep = c;\n\t\t\tparser->current_pos += 1+i;\n\t\t\tassert(parser->current_pos < parser->line_size);\n\t\t\txml_sax_swap(parser);\n\t\t\ti=0;\n\t\t\tgf_list_add(parser->entities, ent);\n\t\t\tskip_chars = NULL;\n\t\t} else if (ent && c==ent->sep) {\n\t\t\tif (ent_name) gf_free(ent_name);\n\t\t\txml_sax_store_text(parser, i);\n\n\t\t\tent->value = xml_get_current_text(parser);\n\t\t\tif (!ent->value) ent->value = gf_strdup(\"\");\n\n\t\t\tparser->current_pos += 1;\n\t\t\tassert(parser->current_pos < parser->line_size);\n\t\t\txml_sax_swap(parser);\n\t\t\tparser->sax_state = SAX_STATE_SKIP_DOCTYPE;\n\t\t\treturn;\n\t\t} else if (!ent) {\n\t\t\tszC[0] = c;\n\t\t\tgf_dynstrcat(&ent_name, szC, NULL);\n\t\t\ti++;\n\t\t} else {\n\t\t\ti++;\n\t\t}\n\t}\n\tif (ent_name) gf_free(ent_name);\n\tif (ent && !ent->value)\n\t\tparser->sax_state = SAX_STATE_SYNTAX_ERROR;\n\txml_sax_store_text(parser, i);\n}\n\nstatic void xml_sax_cdata(GF_SAXParser *parser)\n{\n\tchar *cd_end = strstr(parser->buffer + parser->current_pos, \"]]>\");\n\tif (!cd_end) {\n\t\txml_sax_store_text(parser, parser->line_size - parser->current_pos);\n\t} else {\n\t\tu32 size = (u32) (cd_end - (parser->buffer + parser->current_pos));\n\t\txml_sax_store_text(parser, size);\n\t\txml_sax_flush_text(parser);\n\t\tparser->current_pos += 3;\n\t\tassert(parser->current_pos <= parser->line_size);\n\t\tparser->sax_state = SAX_STATE_TEXT_CONTENT;\n\t}\n}\n\nstatic Bool xml_sax_parse_comments(GF_SAXParser *parser)\n{\n\tchar *end = strstr(parser->buffer + parser->current_pos, \"-->\");\n\tif (!end) {\n\t\tif (parser->line_size>3)\n\t\t\tparser->current_pos = parser->line_size-3;\n\t\txml_sax_swap(parser);\n\t\treturn GF_FALSE;\n\t}\n\n\tparser->current_pos += 3 + (u32) (end - (parser->buffer + parser->current_pos) );\n\tassert(parser->current_pos <= parser->line_size);\n\tparser->sax_state = SAX_STATE_TEXT_CONTENT;\n\tparser->text_start = parser->text_end = 0;\n\txml_sax_swap(parser);\n\treturn GF_TRUE;\n}\n\n\n\nstatic GF_Err xml_sax_parse(GF_SAXParser *parser, Bool force_parse)\n{\n\tu32 i = 0;\n\tBool is_text;\n\tu32 is_end;\n\tu8 c;\n\tchar *elt, sep;\n\tu32 cdata_sep;\n\n\twhile (parser->current_pos<parser->line_size) {\n\t\tif (!force_parse && parser->suspended) goto exit;\n\nrestart:\n\t\tis_text = GF_FALSE;\n\t\tswitch (parser->sax_state) {\n\t\t/*load an XML element*/\n\t\tcase SAX_STATE_TEXT_CONTENT:\n\t\t\tis_text = GF_TRUE;\n\t\tcase SAX_STATE_ELEMENT:\n\t\t\telt = NULL;\n\t\t\ti=0;\n\t\t\twhile ((c = parser->buffer[parser->current_pos+i]) !='<') {\n\t\t\t\tif ((parser->init_state==2) && (c ==']')) {\n\t\t\t\t\tparser->sax_state = SAX_STATE_ATT_NAME;\n\t\t\t\t\tparser->current_pos+=i+1;\n\t\t\t\t\tgoto restart;\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t\tif (c=='\\n') parser->line++;\n\t\t\t\tif (is_text) {\n\t\t\t\t\tif (c=='&') parser->text_check_escapes |= 1;\n\t\t\t\t\telse if (c==';') parser->text_check_escapes |= 2;\n\t\t\t\t}\n\n\t\t\t\tif (parser->current_pos+i==parser->line_size) {\n\t\t\t\t\tif ((parser->line_size>=2*XML_INPUT_SIZE) && !parser->init_state)\n\t\t\t\t\t\tparser->sax_state = SAX_STATE_SYNTAX_ERROR;\n\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (is_text && i) {\n\t\t\t\tu32 has_esc = parser->text_check_escapes;\n\t\t\t\txml_sax_store_text(parser, i);\n\t\t\t\tparser->text_check_escapes = has_esc;\n\t\t\t\tparser->sax_state = SAX_STATE_ELEMENT;\n\t\t\t} else if (i) {\n\t\t\t\tparser->current_pos += i;\n\t\t\t\tassert(parser->current_pos < parser->line_size);\n\t\t\t}\n\t\t\tis_end = 0;\n\t\t\ti = 0;\n\t\t\tcdata_sep = 0;\n\t\t\twhile (1) {\n\t\t\t\tc = parser->buffer[parser->current_pos+1+i];\n\t\t\t\tif (!strncmp(parser->buffer+parser->current_pos+1+i, \"!--\", 3)) {\n\t\t\t\t\tparser->sax_state = SAX_STATE_COMMENT;\n\t\t\t\t\ti += 3;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!c) {\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t\tif ((c=='\\t') || (c=='\\r') || (c==' ') ) {\n\t\t\t\t\tif (i) break;\n\t\t\t\t\telse parser->current_pos++;\n\t\t\t\t}\n\t\t\t\telse if (c=='\\n') {\n\t\t\t\t\tparser->line++;\n\t\t\t\t\tif (i) break;\n\t\t\t\t\telse parser->current_pos++;\n\t\t\t\t}\n\t\t\t\telse if (c=='>') break;\n\t\t\t\telse if (c=='=') break;\n\t\t\t\telse if (c=='[') {\n\t\t\t\t\ti++;\n\t\t\t\t\tif (!cdata_sep) cdata_sep = 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (c=='/') {\n\t\t\t\t\tis_end = !i ? 1 : 2;\n\t\t\t\t\ti++;\n\t\t\t\t} else if (c=='<') {\n\t\t\t\t\tif (parser->sax_state != SAX_STATE_COMMENT) {\n\t\t\t\t\t\tparser->sax_state = SAX_STATE_SYNTAX_ERROR;\n\t\t\t\t\t\treturn GF_CORRUPTED_DATA;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\t/*\t\t\t\tif ((c=='[') && (parser->buffer[parser->elt_name_start-1 + i-2]=='A') ) break; */\n\t\t\t\tif (parser->current_pos+1+i==parser->line_size) {\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i) {\n\t\t\t\tparser->elt_name_start = parser->current_pos+1 + 1;\n\t\t\t\tif (is_end==1) parser->elt_name_start ++;\n\t\t\t\tif (is_end==2) parser->elt_name_end = parser->current_pos+1+i;\n\t\t\t\telse parser->elt_name_end = parser->current_pos+1+i + 1;\n\t\t\t}\n\t\t\tif (is_end) {\n\t\t\t\txml_sax_flush_text(parser);\n\t\t\t\tparser->elt_end_pos = parser->file_pos + parser->current_pos + i;\n\t\t\t\tif (is_end==2) {\n\t\t\t\t\tparser->sax_state = SAX_STATE_ELEMENT;\n\t\t\t\t\txml_sax_node_start(parser);\n\t\t\t\t\txml_sax_node_end(parser, GF_FALSE);\n\t\t\t\t} else {\n\t\t\t\t\tparser->elt_end_pos += parser->elt_name_end - parser->elt_name_start;\n\t\t\t\t\txml_sax_node_end(parser, GF_TRUE);\n\t\t\t\t}\n\t\t\t\tif (parser->sax_state == SAX_STATE_SYNTAX_ERROR) break;\n\t\t\t\tparser->current_pos+=2+i;\n\t\t\t\tparser->sax_state = SAX_STATE_TEXT_CONTENT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!parser->elt_name_end) {\n\t\t\t\treturn GF_CORRUPTED_DATA;\n\t\t\t}\n\t\t\tsep = parser->buffer[parser->elt_name_end-1];\n\t\t\tparser->buffer[parser->elt_name_end-1] = 0;\n\t\t\telt = parser->buffer + parser->elt_name_start-1;\n\n\t\t\tparser->sax_state = SAX_STATE_ATT_NAME;\n\t\t\tassert(parser->elt_start_pos <= parser->file_pos + parser->current_pos);\n\t\t\tparser->elt_start_pos = parser->file_pos + parser->current_pos;\n\n\t\t\tif (!strncmp(elt, \"!--\", 3)) {\n\t\t\t\txml_sax_flush_text(parser);\n\t\t\t\tparser->sax_state = SAX_STATE_COMMENT;\n\t\t\t\tif (i>3) parser->current_pos -= (i-3);\n\t\t\t}\n\t\t\telse if (!strcmp(elt, \"?xml\")) parser->init_state = 1;\n\t\t\telse if (!strcmp(elt, \"!DOCTYPE\")) parser->init_state = 2;\n\t\t\telse if (!strcmp(elt, \"!ENTITY\")) parser->sax_state = SAX_STATE_ENTITY;\n\t\t\telse if (!strcmp(elt, \"!ATTLIST\") || !strcmp(elt, \"!ELEMENT\")) parser->sax_state = SAX_STATE_SKIP_DOCTYPE;\n\t\t\telse if (!strcmp(elt, \"![CDATA[\"))\n\t\t\t\tparser->sax_state = SAX_STATE_CDATA;\n\t\t\telse if (elt[0]=='?') {\n\t\t\t\ti--;\n\t\t\t\tparser->sax_state = SAX_STATE_XML_PROC;\n\t\t\t}\n\t\t\t/*node found*/\n\t\t\telse {\n\t\t\t\txml_sax_flush_text(parser);\n\t\t\t\tif (parser->init_state) {\n\t\t\t\t\tparser->init_state = 0;\n\t\t\t\t\t/*that's a bit ugly: since we solve entities when appending text, we need to\n\t\t\t\t\treparse the current buffer*/\n\t\t\t\t\tif (gf_list_count(parser->entities)) {\n\t\t\t\t\t\tchar *orig_buf;\n\t\t\t\t\t\tGF_Err e;\n\t\t\t\t\t\tparser->buffer[parser->elt_name_end-1] = sep;\n\t\t\t\t\t\torig_buf = gf_strdup(parser->buffer + parser->current_pos);\n\t\t\t\t\t\tparser->current_pos = 0;\n\t\t\t\t\t\tparser->line_size = 0;\n\t\t\t\t\t\tparser->elt_start_pos = 0;\n\t\t\t\t\t\tparser->sax_state = SAX_STATE_TEXT_CONTENT;\n\t\t\t\t\t\tparser->ent_rec_level++;\n\t\t\t\t\t\tif (parser->ent_rec_level>100) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CORE, (\"[XML] Too many recursions in entity solving, max 100 allowed\\n\"));\n\t\t\t\t\t\t\te = GF_NOT_SUPPORTED;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\te = gf_xml_sax_parse_intern(parser, orig_buf);\n\t\t\t\t\t\t\tparser->ent_rec_level--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgf_free(orig_buf);\n\t\t\t\t\t\treturn e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tparser->current_pos+=1+i;\n\t\t\tparser->buffer[parser->elt_name_end-1] = sep;\n\t\t\tbreak;\n\t\tcase SAX_STATE_COMMENT:\n\t\t\tif (!xml_sax_parse_comments(parser)) {\n\t\t\t\txml_sax_swap(parser);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SAX_STATE_ATT_NAME:\n\t\tcase SAX_STATE_ATT_VALUE:\n\t\t\tif (xml_sax_parse_attribute(parser))\n\t\t\t\tgoto exit;\n\t\t\tbreak;\n\t\tcase SAX_STATE_ENTITY:\n\t\t\txml_sax_parse_entity(parser);\n\t\t\tbreak;\n\t\tcase SAX_STATE_SKIP_DOCTYPE:\n\t\t\txml_sax_skip_doctype(parser);\n\t\t\tbreak;\n\t\tcase SAX_STATE_XML_PROC:\n\t\t\txml_sax_skip_xml_proc(parser);\n\t\t\tbreak;\n\t\tcase SAX_STATE_CDATA:\n\t\t\txml_sax_cdata(parser);\n\t\t\tbreak;\n\t\tcase SAX_STATE_SYNTAX_ERROR:\n\t\t\treturn GF_CORRUPTED_DATA;\n\t\tcase SAX_STATE_ALLOC_ERROR:\n\t\t\treturn GF_OUT_OF_MEM;\n\t\tcase SAX_STATE_DONE:\n\t\t\treturn GF_EOS;\n\t\t}\n\t}\nexit:\n#if 0\n\tif (is_text) {\n\t\tif (i) xml_sax_store_text(parser, i);\n\t\t/*DON'T FLUSH TEXT YET, wait for next '<' to do so otherwise we may corrupt xml base entities (&apos;, ...)*/\n\t}\n#endif\n\txml_sax_swap(parser);\n\n\tif (parser->sax_state==SAX_STATE_SYNTAX_ERROR)\n\t\treturn GF_CORRUPTED_DATA;\n\telse\n\t\treturn GF_OK;\n}\n\nstatic GF_Err xml_sax_append_string(GF_SAXParser *parser, char *string)\n{\n\tu32 size = parser->line_size;\n\tu32 nl_size = string ? (u32) strlen(string) : 0;\n\n\tif (!nl_size) return GF_OK;\n\n\tif ( (parser->alloc_size < size+nl_size+1)\n\t        /*\t\t|| (parser->alloc_size / 2 ) > size+nl_size+1 */\n\t   )\n\t{\n\t\tparser->alloc_size = size+nl_size+1;\n\t\tparser->alloc_size = 3 * parser->alloc_size / 2;\n\t\tparser->buffer = (char*)gf_realloc(parser->buffer, sizeof(char) * parser->alloc_size);\n\t\tif (!parser->buffer ) return GF_OUT_OF_MEM;\n\t}\n\tmemcpy(parser->buffer+size, string, sizeof(char)*nl_size);\n\tparser->buffer[size+nl_size] = 0;\n\tparser->line_size = size+nl_size;\n\treturn GF_OK;\n}\n\nstatic XML_Entity *gf_xml_locate_entity(GF_SAXParser *parser, char *ent_start, Bool *needs_text)\n{\n\tu32 i, count;\n\tu32 len = (u32) strlen(ent_start);\n\n\t*needs_text = GF_FALSE;\n\tcount = gf_list_count(parser->entities);\n\n\tfor (i=0; i<count; i++) {\n\t\tXML_Entity *ent = (XML_Entity *)gf_list_get(parser->entities, i);\n\t\tif (len < ent->namelen + 1) {\n\t\t\tif (strncmp(ent->name, ent_start, len))\n\t\t\t \treturn NULL;\n\n\t\t\t*needs_text = GF_TRUE;\n\t\t\treturn NULL;\n\t\t}\n\t\tif (!strncmp(ent->name, ent_start, ent->namelen) && (ent_start[ent->namelen]==';')) {\n\t\t\treturn ent;\n\t\t}\n\t}\n\treturn NULL;\n}\n\n\nstatic GF_Err gf_xml_sax_parse_intern(GF_SAXParser *parser, char *current)\n{\n\tu32 count;\n\t/*solve entities*/\n\tcount = gf_list_count(parser->entities);\n\twhile (count) {\n\t\tchar *entityEnd;\n\t\tXML_Entity *ent;\n\t\tchar *entityStart = strstr(current, \"&\");\n\t\tBool needs_text;\n\t\tu32 line_num;\n\n\t\t/*if in entity, the start of the entity is in the buffer !!*/\n\t\tif (parser->in_entity) {\n\t\t\tu32 len;\n\t\t\tchar *name;\n\t\t\tentityEnd = strstr(current, \";\");\n\t\t\tif (!entityEnd) return xml_sax_append_string(parser, current);\n\t\t\tentityStart = strrchr(parser->buffer, '&');\n\n\t\t\tentityEnd[0] = 0;\n\t\t\tlen = (u32) strlen(entityStart) + (u32) strlen(current) + 1;\n\t\t\tname = (char*)gf_malloc(sizeof(char)*len);\n\t\t\tsprintf(name, \"%s%s;\", entityStart+1, current);\n\n\t\t\tent = gf_xml_locate_entity(parser, name, &needs_text);\n\t\t\tgf_free(name);\n\n\t\t\t//entity not found, parse as regular string\n\t\t\tif (!ent && !needs_text) {\n\t\t\t\txml_sax_append_string(parser, current);\n\t\t\t\txml_sax_parse(parser, GF_TRUE);\n\t\t\t\tentityEnd[0] = ';';\n\t\t\t\tcurrent = entityEnd;\n\t\t\t\tparser->in_entity = GF_FALSE;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tassert(ent);\n\t\t\t/*truncate input buffer*/\n\t\t\tparser->line_size -= (u32) strlen(entityStart);\n\t\t\tentityStart[0] = 0;\n\n\t\t\tparser->in_entity = GF_FALSE;\n\t\t\tentityEnd[0] = ';';\n\t\t\tcurrent = entityEnd+1;\n\t\t} else {\n\t\t\tif (!entityStart) break;\n\n\t\t\tent = gf_xml_locate_entity(parser, entityStart+1, &needs_text);\n\n\t\t\t/*store current string before entity start*/\n\t\t\tentityStart[0] = 0;\n\t\t\txml_sax_append_string(parser, current);\n\t\t\txml_sax_parse(parser, GF_TRUE);\n\t\t\tentityStart[0] = '&';\n\n\t\t\t/*this is not an entitiy*/\n\t\t\tif (!ent && !needs_text) {\n\t\t\t\txml_sax_append_string(parser, \"&\");\n\t\t\t\tcurrent = entityStart+1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!ent) {\n\t\t\t\tparser->in_entity = GF_TRUE;\n\t\t\t\t/*store entity start*/\n\t\t\t\treturn xml_sax_append_string(parser, entityStart);\n\t\t\t}\n\t\t\tcurrent = entityStart + ent->namelen + 2;\n\t\t}\n\t\t/*append entity*/\n\t\tline_num = parser->line;\n\t\txml_sax_append_string(parser, ent->value);\n\t\tGF_Err e = xml_sax_parse(parser, GF_TRUE);\n\t\tparser->line = line_num;\n\t\tif (e) return e;\n\n\t}\n\txml_sax_append_string(parser, current);\n\treturn xml_sax_parse(parser, GF_FALSE);\n}\n\nGF_EXPORT\nGF_Err gf_xml_sax_parse(GF_SAXParser *parser, const void *string)\n{\n\tGF_Err e;\n\tchar *current;\n\tchar *utf_conv = NULL;\n\n\tif (parser->unicode_type < 0) return GF_BAD_PARAM;\n\n\tif (parser->unicode_type>1) {\n\t\tconst u16 *sptr = (const u16 *)string;\n\t\tu32 len = 2 * gf_utf8_wcslen(sptr);\n\t\tutf_conv = (char *)gf_malloc(sizeof(char)*(len+1));\n\t\tlen = gf_utf8_wcstombs(utf_conv, len, &sptr);\n\t\tif (len == GF_UTF8_FAIL) {\n\t\t\tparser->sax_state = SAX_STATE_SYNTAX_ERROR;\n\t\t\tgf_free(utf_conv);\n\t\t\treturn GF_CORRUPTED_DATA;\n\t\t}\n\t\tutf_conv[len] = 0;\n\t\tcurrent = utf_conv;\n\t} else {\n\t\tcurrent = (char *)string;\n\t}\n\n\te = gf_xml_sax_parse_intern(parser, current);\n\tif (utf_conv) gf_free(utf_conv);\n\treturn e;\n}\n\n\nGF_EXPORT\nGF_Err gf_xml_sax_init(GF_SAXParser *parser, unsigned char *BOM)\n{\n\tu32 offset;\n\tif (!BOM) {\n\t\tparser->unicode_type = 0;\n\t\tparser->sax_state = SAX_STATE_ELEMENT;\n\t\treturn GF_OK;\n\t}\n\n\tif (parser->unicode_type >= 0) return gf_xml_sax_parse(parser, BOM);\n\n\tif ((BOM[0]==0xFF) && (BOM[1]==0xFE)) {\n\t\tif (!BOM[2] && !BOM[3]) return GF_NOT_SUPPORTED;\n\t\tparser->unicode_type = 2;\n\t\toffset = 2;\n\t} else if ((BOM[0]==0xFE) && (BOM[1]==0xFF)) {\n\t\tif (!BOM[2] && !BOM[3]) return GF_NOT_SUPPORTED;\n\t\tparser->unicode_type = 1;\n\t\toffset = 2;\n\t} else if ((BOM[0]==0xEF) && (BOM[1]==0xBB) && (BOM[2]==0xBF)) {\n\t\t/*we handle UTF8 as asci*/\n\t\tparser->unicode_type = 0;\n\t\toffset = 3;\n\t} else {\n\t\tparser->unicode_type = 0;\n\t\toffset = 0;\n\t}\n\n#ifdef GPAC_ENABLE_COVERAGE\n\tif (gf_sys_is_cov_mode()) {\n\t\tformat_sax_error(NULL, 0, \"\");\n\t}\n#endif\n\n\tparser->sax_state = SAX_STATE_ELEMENT;\n\treturn gf_xml_sax_parse(parser, BOM + offset);\n}\n\nstatic void xml_sax_reset(GF_SAXParser *parser)\n{\n\twhile (1) {\n\t\tXML_Entity *ent = (XML_Entity *)gf_list_last(parser->entities);\n\t\tif (!ent) break;\n\t\tgf_list_rem_last(parser->entities);\n\t\tif (ent->name) gf_free(ent->name);\n\t\tif (ent->value) gf_free(ent->value);\n\t\tgf_free(ent);\n\t}\n\tif (parser->buffer) gf_free(parser->buffer);\n\tparser->buffer = NULL;\n\tparser->current_pos = 0;\n\tgf_free(parser->attrs);\n\tparser->attrs = NULL;\n\tgf_free(parser->sax_attrs);\n\tparser->sax_attrs = NULL;\n\tparser->nb_alloc_attrs = parser->nb_attrs = 0;\n}\n\n\nstatic GF_Err xml_sax_read_file(GF_SAXParser *parser)\n{\n\tGF_Err e = GF_EOS;\n\tunsigned char szLine[XML_INPUT_SIZE+2];\n\n#ifdef NO_GZIP\n\tif (!parser->f_in) return GF_BAD_PARAM;\n#else\n\tif (!parser->gz_in) return GF_BAD_PARAM;\n#endif\n\n\n\twhile (!parser->suspended) {\n#ifdef NO_GZIP\n\t\ts32 read = (s32)gf_fread(szLine, XML_INPUT_SIZE, parser->f_in);\n#else\n\t\ts32 read = gf_gzread(parser->gz_in, szLine, XML_INPUT_SIZE);\n#endif\n\t\tif ((read<=0) /*&& !parser->node_depth*/) break;\n\t\tszLine[read] = 0;\n\t\tszLine[read+1] = 0;\n\t\te = gf_xml_sax_parse(parser, szLine);\n\t\tif (e) break;\n\t\tif (parser->file_pos > parser->file_size) parser->file_size = parser->file_pos + 1;\n\t\tif (parser->on_progress) parser->on_progress(parser->sax_cbck, parser->file_pos, parser->file_size);\n\t}\n\n#ifdef NO_GZIP\n\tif (gf_feof(parser->f_in)) {\n#else\n\tif (gf_gzeof(parser->gz_in)) {\n#endif\n\t\tif (!e) e = GF_EOS;\n\t\tif (parser->on_progress) parser->on_progress(parser->sax_cbck, parser->file_size, parser->file_size);\n\n#ifdef NO_GZIP\n\t\tgf_fclose(parser->f_in);\n\t\tparser->f_in = NULL;\n#else\n\t\tgf_gzclose(parser->gz_in);\n\t\tparser->gz_in = 0;\n#endif\n\n\t\tparser->elt_start_pos = parser->elt_end_pos = 0;\n\t\tparser->elt_name_start = parser->elt_name_end = 0;\n\t\tparser->att_name_start = 0;\n\t\tparser->current_pos = 0;\n\t\tparser->line_size = 0;\n\t\tparser->att_sep = 0;\n\t\tparser->file_pos = 0;\n\t\tparser->file_size = 0;\n\t\tparser->line_size = 0;\n\t}\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_xml_sax_parse_file(GF_SAXParser *parser, const char *fileName, gf_xml_sax_progress OnProgress)\n{\n\tFILE *test;\n\tGF_Err e;\n\tu64 filesize;\n#ifndef NO_GZIP\n\tgzFile gzInput;\n#endif\n\tunsigned char szLine[6];\n\n\tparser->on_progress = OnProgress;\n\n\tif (!strncmp(fileName, \"gmem://\", 7)) {\n\t\tu32 size;\n\t\tu8 *xml_mem_address;\n\t\te = gf_blob_get(fileName, &xml_mem_address, &size, NULL);\n\t\tif (e) return e;\n\n\t\tparser->file_size = size;\n\t\t//copy possible BOM\n\t\tmemcpy(szLine, xml_mem_address, 4);\n\t\tszLine[4] = szLine[5] = 0;\n\n\t\tparser->file_pos = 0;\n\t\tparser->elt_start_pos = 0;\n\t\tparser->current_pos = 0;\n\n\t\te = gf_xml_sax_init(parser, szLine);\n        if (!e) {\n            e = gf_xml_sax_parse(parser, xml_mem_address+4);\n            if (parser->on_progress) parser->on_progress(parser->sax_cbck, parser->file_pos, parser->file_size);\n        }\n        gf_blob_release(fileName);\n        \n\t\tparser->elt_start_pos = parser->elt_end_pos = 0;\n\t\tparser->elt_name_start = parser->elt_name_end = 0;\n\t\tparser->att_name_start = 0;\n\t\tparser->current_pos = 0;\n\t\tparser->line_size = 0;\n\t\tparser->att_sep = 0;\n\t\tparser->file_pos = 0;\n\t\tparser->file_size = 0;\n\t\tparser->line_size = 0;\n\t\treturn e;\n\t}\n\n\t/*check file exists and gets its size (zlib doesn't support SEEK_END)*/\n\ttest = gf_fopen(fileName, \"rb\");\n\tif (!test) return GF_URL_ERROR;\n\n\tfilesize = gf_fsize(test);\n\tassert(filesize < 0x80000000);\n\tparser->file_size = (u32) filesize;\n\tgf_fclose(test);\n\n\tparser->file_pos = 0;\n\tparser->elt_start_pos = 0;\n\tparser->current_pos = 0;\n\t//open file and copy possible BOM\n#ifdef NO_GZIP\n\tparser->f_in = gf_fopen(fileName, \"rt\");\n\tif (gf_fread(szLine, 4, parser->f_in) != 4) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CORE, (\"[XML] Error loading BOM\\n\"));\n\t}\n#else\n\tgzInput = gf_gzopen(fileName, \"rb\");\n\tif (!gzInput) return GF_IO_ERR;\n\tparser->gz_in = gzInput;\n\t/*init SAX parser (unicode setup)*/\n\tgf_gzread(gzInput, szLine, 4);\n#endif\n\n\tszLine[4] = szLine[5] = 0;\n\te = gf_xml_sax_init(parser, szLine);\n\tif (e) return e;\n\n\treturn xml_sax_read_file(parser);\n}\n\nGF_EXPORT\nBool gf_xml_sax_binary_file(GF_SAXParser *parser)\n{\n\tif (!parser) return GF_FALSE;\n#ifdef NO_GZIP\n\treturn GF_FALSE;\n#else\n\tif (!parser->gz_in) return GF_FALSE;\n\treturn (((z_stream*)parser->gz_in)->data_type==Z_BINARY) ? GF_TRUE : GF_FALSE;\n#endif\n}\n\nGF_EXPORT\nGF_SAXParser *gf_xml_sax_new(gf_xml_sax_node_start on_node_start,\n                             gf_xml_sax_node_end on_node_end,\n                             gf_xml_sax_text_content on_text_content,\n                             void *cbck)\n{\n\tGF_SAXParser *parser;\n\tGF_SAFEALLOC(parser, GF_SAXParser);\n\tif (!parser) return NULL;\n\tparser->entities = gf_list_new();\n\tparser->unicode_type = -1;\n\tparser->sax_node_start = on_node_start;\n\tparser->sax_node_end = on_node_end;\n\tparser->sax_text_content = on_text_content;\n\tparser->sax_cbck = cbck;\n\treturn parser;\n}\n\nGF_EXPORT\nvoid gf_xml_sax_del(GF_SAXParser *parser)\n{\n\txml_sax_reset(parser);\n\tgf_list_del(parser->entities);\n#ifdef NO_GZIP\n\tif (parser->f_in) gf_fclose(parser->f_in);\n#else\n\tif (parser->gz_in) gf_gzclose(parser->gz_in);\n#endif\n\tgf_free(parser);\n}\n\nGF_EXPORT\nGF_Err gf_xml_sax_suspend(GF_SAXParser *parser, Bool do_suspend)\n{\n\tparser->suspended = do_suspend;\n\tif (!do_suspend) {\n#ifdef NO_GZIP\n\t\tif (parser->f_in) return xml_sax_read_file(parser);\n#else\n\t\tif (parser->gz_in) return xml_sax_read_file(parser);\n#endif\n\t\treturn xml_sax_parse(parser, GF_FALSE);\n\t}\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nu32 gf_xml_sax_get_line(GF_SAXParser *parser) {\n\treturn parser->line + 1 ;\n}\n\n#if 0 //unused\nu32 gf_xml_sax_get_file_size(GF_SAXParser *parser)\n{\n#ifdef NO_GZIP\n\treturn parser->f_in ? parser->file_size : 0;\n#else\n\treturn parser->gz_in ? parser->file_size : 0;\n#endif\n}\n\nu32 gf_xml_sax_get_file_pos(GF_SAXParser *parser)\n{\n#ifdef NO_GZIP\n\treturn parser->f_in ? parser->file_pos : 0;\n#else\n\treturn parser->gz_in ? parser->file_pos : 0;\n#endif\n}\n#endif\n\n\n\nGF_EXPORT\nchar *gf_xml_sax_peek_node(GF_SAXParser *parser, char *att_name, char *att_value, char *substitute, char *get_attr, char *end_pattern, Bool *is_substitute)\n{\n\tu32 state, att_len, alloc_size, _len;\n#ifdef NO_GZIP\n\tu64 pos;\n#else\n\tz_off_t pos;\n#endif\n\tBool from_buffer;\n\tBool dobreak=GF_FALSE;\n\tchar szLine1[XML_INPUT_SIZE+2], szLine2[XML_INPUT_SIZE+2], *szLine, *cur_line, *sep, *start, first_c, *result;\n\n\n#define CPYCAT_ALLOC(__str, __is_copy) _len = (u32) strlen(__str);\\\n\t\t\t\t\t\t\tif ( _len + (__is_copy ? 0 : strlen(szLine))>=alloc_size) {\\\n\t\t\t\t\t\t\t\talloc_size = 1 + (u32) strlen(__str);\t\\\n\t\t\t\t\t\t\t\tif (!__is_copy) alloc_size += (u32) strlen(szLine); \\\n\t\t\t\t\t\t\t\tszLine = gf_realloc(szLine, alloc_size);\t\\\n\t\t\t\t\t\t\t}\\\n\t\t\t\t\t\t\tif (__is_copy) { memmove(szLine, __str, sizeof(char)*_len); szLine[_len] = 0; }\\\n\t\t\t\t\t\t\telse strcat(szLine, __str); \\\n\n\tfrom_buffer=GF_FALSE;\n#ifdef NO_GZIP\n\tif (!parser->f_in) from_buffer=GF_TRUE;\n#else\n\tif (!parser->gz_in) from_buffer=GF_TRUE;\n#endif\n\n\tresult = NULL;\n\n\tszLine1[0] = szLine2[0] = 0;\n\tpos=0;\n\tif (!from_buffer) {\n#ifdef NO_GZIP\n\t\tpos = gf_ftell(parser->f_in);\n#else\n\t\tpos = (u32) gf_gztell(parser->gz_in);\n#endif\n\t}\n\tatt_len = (u32) strlen(parser->buffer + parser->att_name_start);\n\tif (att_len<2*XML_INPUT_SIZE) att_len = 2*XML_INPUT_SIZE;\n\talloc_size = att_len;\n\tszLine = (char *) gf_malloc(sizeof(char)*alloc_size);\n\tstrcpy(szLine, parser->buffer + parser->att_name_start);\n\tcur_line = szLine;\n\tatt_len = (u32) strlen(att_value);\n\tstate = 0;\n\tgoto retry;\n\n\twhile (1) {\n\t\tu32 read;\n\t\tu8 sep_char;\n\t\tif (!from_buffer) {\n#ifdef NO_GZIP\n\t\t\tif (gf_feof(parser->f_in)) break;\n#else\n\t\t\tif (gf_gzeof(parser->gz_in)) break;\n#endif\n\t\t}\n\n\t\tif (dobreak) break;\n\n\t\tif (cur_line == szLine2) {\n\t\t\tcur_line = szLine1;\n\t\t} else {\n\t\t\tcur_line = szLine2;\n\t\t}\n\t\tif (from_buffer) {\n\t\t\tdobreak=GF_TRUE;\n\t\t} else {\n#ifdef NO_GZIP\n\t\t\tread = (u32)gf_fread(cur_line, XML_INPUT_SIZE, parser->f_in);\n#else\n\t\t\tread = gf_gzread(parser->gz_in, cur_line, XML_INPUT_SIZE);\n#endif\n\t\t\tcur_line[read] = cur_line[read+1] = 0;\n\n\t\t\tCPYCAT_ALLOC(cur_line, 0);\n\t\t}\n\n\t\tif (end_pattern) {\n\t\t\tstart  = strstr(szLine, end_pattern);\n\t\t\tif (start) {\n\t\t\t\tstart[0] = 0;\n\t\t\t\tdobreak = GF_TRUE;\n\t\t\t}\n\t\t}\n\nretry:\n\t\tif (state == 2) goto fetch_attr;\n\t\tsep = strstr(szLine, att_name);\n\t\tif (!sep && !state) {\n\t\t\tstate = 0;\n\t\t\tstart = strrchr(szLine, '<');\n\t\t\tif (start) {\n\t\t\t\tCPYCAT_ALLOC(start, 1);\n\t\t\t} else {\n\t\t\t\tCPYCAT_ALLOC(cur_line, 1);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!state) {\n\t\t\tstate = 1;\n\t\t\t/*load next line*/\n\t\t\tfirst_c = sep[0];\n\t\t\tsep[0] = 0;\n\t\t\tstart = strrchr(szLine, '<');\n\t\t\tif (!start)\n\t\t\t\tgoto exit;\n\t\t\tsep[0] = first_c;\n\t\t\tCPYCAT_ALLOC(start, 1);\n\t\t\tsep = strstr(szLine, att_name);\n\t\t}\n\t\tsep = sep ? strchr(sep, '=') : NULL;\n\t\tif (!sep) {\n\t\t\tstate = 0;\n\t\t\tCPYCAT_ALLOC(cur_line, 1);\n\t\t\tcontinue;\n\t\t}\n\t\twhile (sep[0] && (sep[0] != '\\\"') && (sep[0] != '\\'') ) sep++;\n\t\tif (!sep[0]) continue;\n\t\tsep_char = sep[0];\n\t\tsep++;\n\t\twhile (sep[0] && strchr(\" \\n\\r\\t\", sep[0]) ) sep++;\n\t\tif (!sep[0]) continue;\n\t\tif (!strchr(sep, sep_char))\n\t\t\tcontinue;\n\n\t\t/*found*/\n\t\tif (!strncmp(sep, att_value, att_len)) {\n\t\t\tu32 sub_pos;\n\t\t\tsep = szLine + 1;\n\t\t\twhile (strchr(\" \\t\\r\\n\", sep[0])) sep++;\n\t\t\tsub_pos = 0;\n\t\t\twhile (!strchr(\" \\t\\r\\n\", sep[sub_pos])) sub_pos++;\n\t\t\tfirst_c = sep[sub_pos];\n\t\t\tsep[sub_pos] = 0;\n\t\t\tstate = 2;\n\t\t\tif (!substitute || !get_attr || strcmp(sep, substitute) ) {\n\t\t\t\tif (is_substitute) *is_substitute = GF_FALSE;\n\t\t\t\tresult = gf_strdup(sep);\n\t\t\t\tsep[sub_pos] = first_c;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tsep[sub_pos] = first_c;\nfetch_attr:\n\t\t\tsep = strstr(szLine + 1, get_attr);\n\t\t\tif (!sep) {\n\t\t\t\tCPYCAT_ALLOC(cur_line, 1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsep += strlen(get_attr);\n\t\t\twhile (strchr(\"= \\t\\r\\n\", sep[0])) sep++;\n\t\t\tsep++;\n\t\t\tsub_pos = 0;\n\t\t\twhile (!strchr(\" \\t\\r\\n/>\", sep[sub_pos])) sub_pos++;\n\t\t\tsep[sub_pos-1] = 0;\n\t\t\tresult = gf_strdup(sep);\n\t\t\tif (is_substitute) *is_substitute = GF_TRUE;\n\t\t\tgoto exit;\n\t\t}\n\t\tstate = 0;\n\t\tCPYCAT_ALLOC(sep, 1);\n\t\tgoto retry;\n\t}\nexit:\n\tgf_free(szLine);\n\n\tif (!from_buffer) {\n#ifdef NO_GZIP\n\t\tgf_fseek(parser->f_in, pos, SEEK_SET);\n#else\n\t\tgf_gzrewind(parser->gz_in);\n\t\tgf_gzseek(parser->gz_in, pos, SEEK_SET);\n#endif\n\t}\n\treturn result;\n}\n\nGF_EXPORT\nconst char *gf_xml_sax_get_error(GF_SAXParser *parser)\n{\n\treturn parser->err_msg;\n}\n\n\nstruct _peek_type\n{\n\tGF_SAXParser *parser;\n\tchar *res;\n};\n\nstatic void on_peek_node_start(void *cbk, const char *name, const char *ns, const GF_XMLAttribute *attributes, u32 nb_attributes)\n{\n\tstruct _peek_type *pt = (struct _peek_type*)cbk;\n\tpt->res = gf_strdup(name);\n\tpt->parser->suspended = GF_TRUE;\n}\n\nGF_EXPORT\nchar *gf_xml_get_root_type(const char *file, GF_Err *ret)\n{\n\tGF_Err e;\n\tstruct _peek_type pt;\n\tpt.res = NULL;\n\tpt.parser = gf_xml_sax_new(on_peek_node_start, NULL, NULL, &pt);\n\te = gf_xml_sax_parse_file(pt.parser, file, NULL);\n\tif (ret) *ret = e;\n\tgf_xml_sax_del(pt.parser);\n\treturn pt.res;\n}\n\n\nGF_EXPORT\nu32 gf_xml_sax_get_node_start_pos(GF_SAXParser *parser)\n{\n\treturn parser->elt_start_pos;\n}\n\nGF_EXPORT\nu32 gf_xml_sax_get_node_end_pos(GF_SAXParser *parser)\n{\n\treturn parser->elt_end_pos;\n}\n\nstruct _tag_dom_parser\n{\n\tGF_SAXParser *parser;\n\tGF_List *stack;\n\t//root node being parsed\n\tGF_XMLNode *root;\n\t//usually only one :)\n\tGF_List *root_nodes;\n\tu32 depth;\n\n\tvoid (*OnProgress)(void *cbck, u64 done, u64 tot);\n\tvoid *cbk;\n};\n\n\nGF_EXPORT\nvoid gf_xml_dom_node_reset(GF_XMLNode *node, Bool reset_attribs, Bool reset_children)\n{\n\tif (!node) return;\n\tif (node->attributes && reset_attribs) {\n\t\twhile (gf_list_count(node->attributes)) {\n\t\t\tGF_XMLAttribute *att = (GF_XMLAttribute *)gf_list_last(node->attributes);\n\t\t\tgf_list_rem_last(node->attributes);\n\t\t\tif (att->name) gf_free(att->name);\n\t\t\tif (att->value) gf_free(att->value);\n\t\t\tgf_free(att);\n\t\t}\n\t}\n\n\tif (reset_children && node->content) {\n\t\twhile (gf_list_count(node->content)) {\n\t\t\tGF_XMLNode *child = (GF_XMLNode *)gf_list_last(node->content);\n\t\t\tgf_list_rem_last(node->content);\n\t\t\tgf_xml_dom_node_del(child);\n\t\t}\n\t}\n}\n\nGF_EXPORT\nvoid gf_xml_dom_node_del(GF_XMLNode *node)\n{\n\tif (!node) return;\n\tgf_xml_dom_node_reset(node, GF_TRUE, GF_TRUE);\n\tif (node->attributes) gf_list_del(node->attributes);\n\tif (node->content) gf_list_del(node->content);\n\tif (node->ns) gf_free(node->ns);\n\tif (node->name) gf_free(node->name);\n\tgf_free(node);\n}\n\nGF_List * gf_list_new_prealloc(u32 nb_prealloc);\n\nstatic void on_dom_node_start(void *cbk, const char *name, const char *ns, const GF_XMLAttribute *attributes, u32 nb_attributes)\n{\n\tu32 i;\n\tGF_DOMParser *par = (GF_DOMParser *) cbk;\n\tGF_XMLNode *node;\n\n\tif (par->root && !gf_list_count(par->stack)) {\n\t\tpar->parser->suspended = GF_TRUE;\n\t\treturn;\n\t}\n\n\tGF_SAFEALLOC(node, GF_XMLNode);\n\tif (!node) {\n\t\tpar->parser->sax_state = SAX_STATE_ALLOC_ERROR;\n\t\treturn;\n\t}\n\tnode->attributes = gf_list_new_prealloc(nb_attributes);\n\t//don't allocate content yet\n\tnode->name = gf_strdup(name);\n\tif (ns) node->ns = gf_strdup(ns);\n\tgf_list_add(par->stack, node);\n\tif (!par->root) {\n\t\tpar->root = node;\n\t\tgf_list_add(par->root_nodes, node);\n\t}\n\n\tfor (i=0; i<nb_attributes; i++) {\n\t\tGF_XMLAttribute *att;\n\t\tconst GF_XMLAttribute *in_att = & attributes[i];\n\t\tGF_SAFEALLOC(att, GF_XMLAttribute);\n\t\tif (! att) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[SAX] Failed to allocate attribute\"));\n\t\t\tpar->parser->sax_state = SAX_STATE_ALLOC_ERROR;\n\t\t\treturn;\n\t\t}\n\t\tatt->name = gf_strdup(in_att->name);\n\t\tatt->value = gf_strdup(in_att->value);\n\t\tgf_list_add(node->attributes, att);\n\t}\n}\n\nstatic void on_dom_node_end(void *cbk, const char *name, const char *ns)\n{\n\tGF_DOMParser *par = (GF_DOMParser *)cbk;\n\tGF_XMLNode *last = (GF_XMLNode *)gf_list_last(par->stack);\n\tgf_list_rem_last(par->stack);\n\n\tif (!last || (strlen(last->name)!=strlen(name)) || strcmp(last->name, name) || (!ns && last->ns) || (ns && !last->ns) || (ns && strcmp(last->ns, ns) ) ) {\n\t\ts32 idx;\n\t\tformat_sax_error(par->parser, 0, \"Invalid node stack: closing node is %s but %s was expected\", name, last ? last->name : \"unknown\");\n\t\tpar->parser->suspended = GF_TRUE;\n\t\tgf_xml_dom_node_del(last);\n\t\tif (last == par->root)\n\t\t\tpar->root=NULL;\n\t\tidx = gf_list_find(par->root_nodes, last);\n\t\tif (idx != -1)\n\t\t\tgf_list_rem(par->root_nodes, idx);\n\t\treturn;\n\t}\n\tif (last != par->root) {\n\t\tGF_XMLNode *node = (GF_XMLNode *)gf_list_last(par->stack);\n\t\tif (!node->content)\n\t\t\tnode->content = gf_list_new();\n\n\t\tgf_list_add(node->content, last);\n\t}\n}\n\nstatic void on_dom_text_content(void *cbk, const char *content, Bool is_cdata)\n{\n\tGF_DOMParser *par = (GF_DOMParser *)cbk;\n\tGF_XMLNode *node;\n\tGF_XMLNode *last = (GF_XMLNode *)gf_list_last(par->stack);\n\tif (!last) return;\n\tif (!last->content)\n\t\tlast->content = gf_list_new();\n\n\tGF_SAFEALLOC(node, GF_XMLNode);\n\tif (!node) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[SAX] Failed to allocate XML node\"));\n\t\tpar->parser->sax_state = SAX_STATE_ALLOC_ERROR;\n\t\treturn;\n\t}\n\tnode->type = is_cdata ? GF_XML_CDATA_TYPE : GF_XML_TEXT_TYPE;\n\tnode->name = gf_strdup(content);\n\tgf_list_add(last->content, node);\n}\n\nGF_EXPORT\nGF_DOMParser *gf_xml_dom_new()\n{\n\tGF_DOMParser *dom;\n\tGF_SAFEALLOC(dom, GF_DOMParser);\n\tif (!dom) return NULL;\n\n\tdom->root_nodes = gf_list_new();\n\treturn dom;\n}\n\nstatic void gf_xml_dom_reset(GF_DOMParser *dom, Bool full_reset)\n{\n\tif (full_reset && dom->parser) {\n\t\tgf_xml_sax_del(dom->parser);\n\t\tdom->parser = NULL;\n\t}\n\n\tif (dom->stack) {\n\t\twhile (gf_list_count(dom->stack)) {\n\t\t\tGF_XMLNode *n = (GF_XMLNode *)gf_list_last(dom->stack);\n\t\t\tgf_list_rem_last(dom->stack);\n\t\t\tif (dom->root==n) {\n\t\t\t\tgf_list_del_item(dom->root_nodes, n);\n\t\t\t\tdom->root = NULL;\n\t\t\t}\n\t\t\tgf_xml_dom_node_del(n);\n\t\t}\n\t\tgf_list_del(dom->stack);\n\t\tdom->stack = NULL;\n\t}\n\tif (full_reset && gf_list_count(dom->root_nodes) ) {\n\t\twhile (gf_list_count(dom->root_nodes)) {\n\t\t\tGF_XMLNode *n = (GF_XMLNode *)gf_list_last(dom->root_nodes);\n\t\t\tgf_list_rem_last(dom->root_nodes);\n\t\t\tgf_xml_dom_node_del(n);\n\t\t}\n\t\tdom->root = NULL;\n\t}\n}\n\nGF_EXPORT\nvoid gf_xml_dom_del(GF_DOMParser *parser)\n{\n\tif (!parser)\n\t\treturn;\n\n\tgf_xml_dom_reset(parser, GF_TRUE);\n\tgf_list_del(parser->root_nodes);\n\tgf_free(parser);\n}\n\nGF_EXPORT\nGF_XMLNode *gf_xml_dom_detach_root(GF_DOMParser *parser)\n{\n\tGF_XMLNode *root;\n\tif (!parser)\n\t\treturn NULL;\n\troot = parser->root;\n\tgf_list_del_item(parser->root_nodes, root);\n\tparser->root = gf_list_get(parser->root_nodes, 0);\n\treturn root;\n}\n\nstatic void dom_on_progress(void *cbck, u64 done, u64 tot)\n{\n\tGF_DOMParser *dom = (GF_DOMParser *)cbck;\n\tdom->OnProgress(dom->cbk, done, tot);\n}\n\nGF_EXPORT\nGF_Err gf_xml_dom_parse(GF_DOMParser *dom, const char *file, gf_xml_sax_progress OnProgress, void *cbk)\n{\n\tGF_Err e;\n\tgf_xml_dom_reset(dom, GF_TRUE);\n\tdom->stack = gf_list_new();\n\tdom->parser = gf_xml_sax_new(on_dom_node_start, on_dom_node_end, on_dom_text_content, dom);\n\tdom->OnProgress = OnProgress;\n\tdom->cbk = cbk;\n\te = gf_xml_sax_parse_file(dom->parser, file, OnProgress ? dom_on_progress : NULL);\n\tgf_xml_dom_reset(dom, GF_FALSE);\n\treturn e<0 ? e : GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_xml_dom_parse_string(GF_DOMParser *dom, char *string)\n{\n\tGF_Err e;\n\tgf_xml_dom_reset(dom, GF_TRUE);\n\tdom->stack = gf_list_new();\n\tdom->parser = gf_xml_sax_new(on_dom_node_start, on_dom_node_end, on_dom_text_content, dom);\n\te = gf_xml_sax_init(dom->parser, (unsigned char *) string);\n\tgf_xml_dom_reset(dom, GF_FALSE);\n\treturn e<0 ? e : GF_OK;\n}\n\n#if 0 //unused\nGF_XMLNode *gf_xml_dom_create_root(GF_DOMParser *parser, const char* name) {\n\tGF_XMLNode * root;\n\tif (!parser) return NULL;\n\n\tGF_SAFEALLOC(root, GF_XMLNode);\n\tif (!root) return NULL;\n\troot->name = gf_strdup(name);\n\n\treturn root;\n}\n#endif\n\nGF_EXPORT\nGF_XMLNode *gf_xml_dom_get_root(GF_DOMParser *parser)\n{\n\treturn parser ? parser->root : NULL;\n}\nGF_EXPORT\nconst char *gf_xml_dom_get_error(GF_DOMParser *parser)\n{\n\treturn gf_xml_sax_get_error(parser->parser);\n}\nGF_EXPORT\nu32 gf_xml_dom_get_line(GF_DOMParser *parser)\n{\n\treturn gf_xml_sax_get_line(parser->parser);\n}\n\nGF_EXPORT\nu32 gf_xml_dom_get_root_nodes_count(GF_DOMParser *parser)\n{\n\treturn parser? gf_list_count(parser->root_nodes) : 0;\n}\n\nGF_EXPORT\nGF_XMLNode *gf_xml_dom_get_root_idx(GF_DOMParser *parser, u32 idx)\n{\n\treturn parser ? (GF_XMLNode*)gf_list_get(parser->root_nodes, idx) : NULL;\n}\n\n\nstatic void gf_xml_dom_node_serialize(GF_XMLNode *node, Bool content_only, Bool no_escape, char **str, u32 *alloc_size, u32 *size)\n{\n\tu32 i, count, vlen;\n\tchar *name;\n\n#define SET_STRING(v)\t\\\n\tvlen = (u32) strlen(v);\t\\\n\tif (vlen + (*size) >= (*alloc_size)) {\t\\\n\t\t(*alloc_size) += 1024;\t\\\n\t\tif (vlen + (*size) >= (*alloc_size)) (*alloc_size) = vlen + (*size) + 1;\\\n\t\t(*str) = gf_realloc((*str), (*alloc_size));\t\\\n\t\t(*str)[(*size)] = 0;\t\\\n\t}\t\\\n\tstrcat((*str), v);\t\\\n\t*size += vlen;\t\\\n\n\tswitch (node->type) {\n\tcase GF_XML_CDATA_TYPE:\n\t\tSET_STRING(\"![CDATA[\");\n\t\tSET_STRING(node->name);\n\t\tSET_STRING(\"]]>\");\n\t\treturn;\n\tcase GF_XML_TEXT_TYPE:\n\t\tname = node->name;\n\t\tif ((name[0]=='\\r') && (name[1]=='\\n'))\n\t\t\tname++;\n\n\t\tif (no_escape) {\n\t\t\tSET_STRING(name);\n\t\t} else {\n\t\t\tu32 tlen;\n\t\t\tchar szChar[2];\n\t\t\tszChar[1] = 0;\n\t\t\ttlen = (u32) strlen(name);\n\t\t\tfor (i= 0; i<tlen; i++) {\n\t\t\t\tswitch (name[i]) {\n\t\t\t\tcase '&':\n\t\t\t\t\tSET_STRING(\"&amp;\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase '<':\n\t\t\t\t\tSET_STRING(\"&lt;\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase '>':\n\t\t\t\t\tSET_STRING(\"&gt;\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\\'':\n\t\t\t\t\tSET_STRING(\"&apos;\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\\\"':\n\t\t\t\t\tSET_STRING(\"&quot;\");\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tszChar[0] = name[i];\n\t\t\t\t\tSET_STRING(szChar);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\tif (!content_only) {\n\t\tSET_STRING(\"<\");\n\t\tif (node->ns) {\n\t\t\tSET_STRING(node->ns);\n\t\t\tSET_STRING(\":\");\n\t\t}\n\t\tSET_STRING(node->name);\n\t\tcount = gf_list_count(node->attributes);\n\t\tif (count > 0) {\n\t\t\tSET_STRING(\" \");\n\t\t}\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_XMLAttribute *att = (GF_XMLAttribute*)gf_list_get(node->attributes, i);\n\t\t\tSET_STRING(att->name);\n\t\t\tSET_STRING(\"=\\\"\");\n\t\t\tSET_STRING(att->value);\n\t\t\tSET_STRING(\"\\\" \");\n\t\t}\n\n\t\tif (!gf_list_count(node->content)) {\n\t\t\tSET_STRING(\"/>\");\n\t\t\treturn;\n\t\t}\n\t\tSET_STRING(\">\");\n\t}\n\n\tcount = gf_list_count(node->content);\n\tfor (i=0; i<count; i++) {\n\t\tGF_XMLNode *child = (GF_XMLNode*)gf_list_get(node->content, i);\n\t\tgf_xml_dom_node_serialize(child, GF_FALSE, GF_FALSE, str, alloc_size, size);\n\t}\n\tif (!content_only) {\n\t\tSET_STRING(\"</\");\n\t\tif (node->ns) {\n\t\t\tSET_STRING(node->ns);\n\t\t\tSET_STRING(\":\");\n\t\t}\n\t\tSET_STRING(node->name);\n\t\tSET_STRING(\">\");\n\t}\n}\n\nGF_EXPORT\nchar *gf_xml_dom_serialize(GF_XMLNode *node, Bool content_only, Bool no_escape)\n{\n\tu32 alloc_size = 0;\n\tu32 size = 0;\n\tchar *str = NULL;\n\tgf_xml_dom_node_serialize(node, content_only, no_escape, &str, &alloc_size, &size);\n\treturn str;\n}\n\nGF_EXPORT\nchar *gf_xml_dom_serialize_root(GF_XMLNode *node, Bool content_only, Bool no_escape)\n{\n\tu32 alloc_size, size;\n\tchar *str = NULL;\n\tgf_dynstrcat(&str, \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\", NULL);\n\tif (!str) return NULL;\n\n\talloc_size = size = (u32) strlen(str) + 1;\n\tgf_xml_dom_node_serialize(node, content_only, no_escape, &str, &alloc_size, &size);\n\treturn str;\n}\n\n#if 0 //unused\nGF_XMLAttribute *gf_xml_dom_set_attribute(GF_XMLNode *node, const char* name, const char* value) {\n\tGF_XMLAttribute *att;\n\tif (!name || !value) return NULL;\n\tif (!node->attributes) {\n\t\tnode->attributes = gf_list_new();\n\t\tif (!node->attributes) return NULL;\n\t}\n\n\tatt = gf_xml_dom_create_attribute(name, value);\n\tif (!att) return NULL;\n\tgf_list_add(node->attributes, att);\n\treturn att;\n}\n\nGF_XMLAttribute *gf_xml_dom_get_attribute(GF_XMLNode *node, const char* name) {\n\tu32 i = 0;\n\tGF_XMLAttribute *att;\n\tif (!node || !name) return NULL;\n\n\twhile ( (att = (GF_XMLAttribute*)gf_list_enum(node->attributes, &i))) {\n\t\tif (!strcmp(att->name, name)) {\n\t\t\treturn att;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\n#endif\n\nGF_EXPORT\nGF_XMLAttribute *gf_xml_dom_create_attribute(const char* name, const char* value) {\n\tGF_XMLAttribute *att;\n\tGF_SAFEALLOC(att, GF_XMLAttribute);\n\tif (!att) return NULL;\n\n\tatt->name = gf_strdup(name);\n\tatt->value = gf_strdup(value);\n\treturn att;\n}\n\n\nGF_EXPORT\nGF_Err gf_xml_dom_append_child(GF_XMLNode *node, GF_XMLNode *child) {\n\tif (!node || !child) return GF_BAD_PARAM;\n\tif (!node->content) {\n\t\tnode->content = gf_list_new();\n\t\tif (!node->content) return GF_OUT_OF_MEM;\n\t}\n\treturn gf_list_add(node->content, child);\n}\n\n#if 0\n/*!\n\\brief Removes the node to the list of children of this node.\n\nRemoves the node to the list of children of this node.\n\\warning Doesn't free the memory of the removed children.\n\n\\param node the GF_XMLNode node\n\\param child the GF_XMLNode child to remove\n\\return Error code if any, otherwise GF_OK\n */\nGF_EXPORT\nGF_Err gf_xml_dom_rem_child(GF_XMLNode *node, GF_XMLNode *child) {\n\ts32 idx;\n\tif (!node || !child || !node->content) return GF_BAD_PARAM;\n\tidx = gf_list_find(node->content, child);\n\tif (idx == -1) return GF_BAD_PARAM;\n\treturn gf_list_rem(node->content, idx);\n}\n#endif //unused\n\n\nGF_XMLNode *gf_xml_dom_node_new(const char* ns, const char* name)\n{\n\tGF_XMLNode* node;\n\tGF_SAFEALLOC(node, GF_XMLNode);\n\tif (!node) return NULL;\n\tif (ns) {\n\t\tnode->ns = gf_strdup(ns);\n\t\tif (!node->ns) {\n\t\t\tgf_free(node);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (name) {\n\t\tnode->name = gf_strdup(name);\n\t\tif (!node->name) {\n\t\t\tgf_free(node->ns);\n\t\t\tgf_free(node);\n\t\t\treturn NULL;\n\t\t}\n\t\tnode->type = GF_XML_NODE_TYPE;\n\t} else {\n\t\tnode->type = GF_XML_TEXT_TYPE;\n\t}\n\treturn node;\n}\n\n#include <gpac/base_coding.h>\n\n#define XML_SCAN_INT(_fmt, _value)\t\\\n\t{\\\n\tif (strstr(att->value, \"0x\")) { u32 __i; sscanf(att->value+2, \"%x\", &__i); _value = __i; }\\\n\telse if (strstr(att->value, \"0X\")) { u32 __i; sscanf(att->value+2, \"%X\", &__i); _value = __i; }\\\n\telse sscanf(att->value, _fmt, &_value); \\\n\t}\\\n\n\nGF_Err gf_xml_parse_bit_sequence_bs(GF_XMLNode *bsroot, const char *parent_url, const char *base_media_file, GF_BitStream *bs_orig)\n{\n\tu32 i, j;\n\tGF_Err e = GF_OK;\n\tGF_XMLNode *node;\n\tGF_XMLAttribute *att;\n\tGF_BitStream *bs = bs_orig;\n\tu32 enc_base64 = 0;\n\n\ti=0;\n\twhile ((node = (GF_XMLNode *) gf_list_enum(bsroot->content, &i))) {\n\t\tu32 nb_bits = 0;\n\t\tu32 size = 0;\n\t\tu64 offset = 0;\n\t\ts64 value = 0;\n\t\tBool use_file = GF_FALSE;\n\t\tbin128 word128;\n\t\tFloat val_float = 0;\n\t\tDouble val_double = 0;\n\t\tBool use_word128 = GF_FALSE;\n\t\tBool use_text = GF_FALSE;\n\t\tBool base64_prefix_bits = 0;\n\t\tBool big_endian = GF_TRUE;\n\t\tBool has_float = GF_FALSE;\n\t\tBool has_double = GF_FALSE;\n\t\tconst char *szFile = NULL;\n\t\tconst char *szString = NULL;\n\t\tconst char *szBase64 = NULL;\n\t\tconst char *szData = NULL;\n\t\tif (node->type) continue;\n\n\t\tif (stricmp(node->name, \"BS\") ) {\n\t\t\te = gf_xml_parse_bit_sequence_bs(node, parent_url, base_media_file, bs);\n\t\t\tif (e) goto exit;\n\t\t\tcontinue;\n\t\t}\n\n\t\tj=0;\n\t\twhile ( (att = (GF_XMLAttribute *)gf_list_enum(node->attributes, &j))) {\n\t\t\tif (!stricmp(att->name, \"bits\")) {\n\t\t\t\tXML_SCAN_INT(\"%d\", nb_bits);\n\t\t\t} else if (!stricmp(att->name, \"value\")) {\n\t\t\t\tXML_SCAN_INT(LLD, value);\n\t\t\t} else if (!stricmp(att->name, \"float\")) {\n\t\t\t\tsscanf(att->value, \"%f\", &val_float);\n\t\t\t\thas_float = GF_TRUE;\n\t\t\t} else if (!stricmp(att->name, \"double\")) {\n\t\t\t\tsscanf(att->value, \"%lf\", &val_double);\n\t\t\t\thas_double = GF_TRUE;\n\t\t\t} else if (!stricmp(att->name, \"mediaOffset\") || !stricmp(att->name, \"dataOffset\")) {\n\t\t\t\tXML_SCAN_INT(LLU, offset);\n\t\t\t\tuse_file = GF_TRUE;\n\t\t\t} else if (!stricmp(att->name, \"dataLength\")) {\n\t\t\t\tXML_SCAN_INT(\"%u\", size);\n\t\t\t\tuse_file = GF_TRUE;\n\t\t\t} else if (!stricmp(att->name, \"mediaFile\") || !stricmp(att->name, \"dataFile\")) {\n\t\t\t\tszFile = att->value;\n\t\t\t\tuse_file = GF_TRUE;\n\t\t\t} else if (!stricmp(att->name, \"text\") || !stricmp(att->name, \"string\")) {\n\t\t\t\tszString = att->value;\n\t\t\t} else if (!stricmp(att->name, \"fcc\")) {\n\t\t\t\tvalue = GF_4CC(att->value[0], att->value[1], att->value[2], att->value[3]);\n\t\t\t\tnb_bits = 32;\n\t\t\t} else if (!stricmp(att->name, \"ID128\")) {\n\t\t\t\te = gf_bin128_parse(att->value, word128);\n                if (e != GF_OK) {\n                    GF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[XML/NHML] Cannot parse ID128\\n\"));\n                    goto exit;\n                }\n\t\t\t\tuse_word128 = GF_TRUE;\n\t\t\t} else if (!stricmp(att->name, \"textmode\")) {\n\t\t\t\tif (!strcmp(att->value, \"yes\")) use_text = GF_TRUE;\n\t\t\t} else if (!stricmp(att->name, \"data64\")) {\n\t\t\t\tszBase64 = att->value;\n\t\t\t} else if (!stricmp(att->name, \"data\")) {\n\t\t\t\tszData = att->value;\n\t\t\t\tif (!strnicmp(szData, \"0x\", 2)) szData += 2;\n\t\t\t} else if (!stricmp(att->name, \"endian\") && !stricmp(att->value, \"little\")) {\n\t\t\t\tbig_endian = GF_FALSE;\n\t\t\t} else if (!stricmp(att->name, \"base64\")) {\n\t\t\t\tif (!stricmp(att->value, \"yes\") || !stricmp(att->value, \"true\") ) {\n\t\t\t\t\tif (!enc_base64) enc_base64 = 1;\n\t\t\t\t} else if (!stricmp(att->value, \"start\")) {\n\t\t\t\t\tif (!enc_base64) enc_base64 = 2;\n\t\t\t\t} else if (!stricmp(att->value, \"end\")) {\n\t\t\t\t\tif (enc_base64==2) enc_base64 = 3;\n\t\t\t\t} else {\n                    GF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[XML/NHML] Invalid base64 attribute %s, expecting yes/no, start or end\\n\", att->value));\n                    e = GF_NON_COMPLIANT_BITSTREAM;\n                    goto exit;\n\t\t\t\t}\n\t\t\t} else if (!stricmp(att->name, \"base64Prefix\")) {\n\t\t\t\tbase64_prefix_bits = atoi(att->value);\n\t\t\t} else if (!stricmp(att->name, \"id\")) {\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[XML/NHML] Unkown attribute %s, ignoring\\n\", att->name));\n\t\t\t}\n\t\t}\n\n\t\tif (enc_base64 && (enc_base64<3)) {\n\t\t\tif (bs == bs_orig) {\n\t\t\t\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\t\t\tif (!bs) {\n\t\t\t\t\te = GF_OUT_OF_MEM;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (use_file && !szFile)\n\t\t\tszFile = base_media_file;\n\n\t\tif (szString) {\n\t\t\tu32 len = (u32) strlen(szString);\n\t\t\tif (nb_bits)\n\t\t\t\tgf_bs_write_int(bs, len, nb_bits);\n\n\t\t\tgf_bs_write_data(bs, szString, len);\n\t\t} else if (szBase64) {\n\t\t\tu32 len = (u32) strlen(szBase64);\n\t\t\tchar *data = (char *) gf_malloc(sizeof(char)*len);\n\t\t\tu32 ret;\n\t\t\tif (!data) {\n\t\t\t\te = GF_OUT_OF_MEM;\n\t\t\t\tgoto exit;\n\t\t\t}\n\n\t\t\tret = (u32) gf_base64_decode((char *)szBase64, len, data, len);\n\t\t\tif ((s32) ret >=0) {\n\t\t\t\tgf_bs_write_int(bs, ret, nb_bits);\n\t\t\t\tgf_bs_write_data(bs, data, ret);\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[XML/NHML] Error decoding base64 %s\\n\", att->value));\n\t\t\t\tgf_free(data);\n\t\t\t\te = GF_BAD_PARAM;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tgf_free(data);\n\t\t} else if (szData) {\n\t\t\tu32 len = (u32) strlen(szData);\n\t\t\tchar *data = (char *) gf_malloc(sizeof(char)*len/2);\n\t\t\tif (!data) {\n\t\t\t\te = GF_OUT_OF_MEM;\n\t\t\t\tgoto exit;\n\t\t\t}\n\n\t\t\tfor (j=0; j<len; j+=2) {\n\t\t\t\tu32 v;\n\t\t\t\tchar szV[5];\n\t\t\t\tsprintf(szV, \"%c%c\", szData[j], szData[j+1]);\n\t\t\t\tsscanf(szV, \"%x\", &v);\n\t\t\t\tdata[j/2] = v;\n\t\t\t}\n\t\t\tgf_bs_write_int(bs, len/2, nb_bits);\n\t\t\tgf_bs_write_data(bs, data, len/2);\n\t\t\tgf_free(data);\n\t\t} else if (has_float) {\n\t\t\tgf_bs_write_float(bs, val_float);\n\t\t} else if (has_double) {\n\t\t\tgf_bs_write_double(bs, val_double);\n\t\t} else if (nb_bits) {\n\t\t\tif (!big_endian) {\n\t\t\t\tif (nb_bits == 16)\n\t\t\t\t\tgf_bs_write_u16_le(bs, (u32)value);\n\t\t\t\telse if (nb_bits == 32)\n\t\t\t\t\tgf_bs_write_u32_le(bs, (u32)value);\n\t\t\t\telse {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[XML/NHML] Little-endian values can only be 16 or 32-bit\\n\"));\n\t\t\t\t\te = GF_BAD_PARAM;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (nb_bits<33) gf_bs_write_int(bs, (s32) value, nb_bits);\n\t\t\t\telse gf_bs_write_long_int(bs, value, nb_bits);\n\t\t\t}\n\t\t} else if (szFile) {\n\t\t\tu32 read, remain;\n\t\t\tchar block[1024];\n\t\t\tFILE *_tmp = NULL;\n\t\t\tif (parent_url) {\n\t\t\t\tchar *f_url = gf_url_concatenate(parent_url, szFile);\n\t\t\t\t_tmp = gf_fopen(f_url, use_text ? \"rt\" : \"rb\");\n\t\t\t\tgf_free(f_url);\n\t\t\t} else {\n\t\t\t\t_tmp = gf_fopen(szFile, use_text ? \"rt\" : \"rb\");\n\t\t\t}\n\n\t\t\tif (!_tmp) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[XML/NHML] Error opening file %s\\n\", szFile));\n\t\t\t\te = GF_URL_ERROR;\n\t\t\t\tgoto exit;\n\t\t\t}\n\n\t\t\tif (!size) {\n\t\t\t\tsize = (u32) gf_fsize(_tmp);\n\t\t\t\t//if offset only copy from offset until end\n\t\t\t\tif ((u64) size > offset)\n\t\t\t\t\tsize -= (u32) offset;\n\t\t\t}\n\t\t\tremain = size;\n\t\t\tgf_fseek(_tmp, offset, SEEK_SET);\n\t\t\twhile (remain) {\n\t\t\t\tu32 bsize = remain;\n\t\t\t\tif (bsize>1024) bsize=1024;\n\t\t\t\tread = (u32) gf_fread(block, bsize, _tmp);\n\t\t\t\tif ((s32) read < 0) {\n\t\t\t\t\tgf_fclose(_tmp);\n\t\t\t\t\te = GF_IO_ERR;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\n\t\t\t\tgf_bs_write_data(bs, block, read);\n\t\t\t\tremain -= bsize;\n\t\t\t}\n\t\t\tgf_fclose(_tmp);\n\t\t} else if (use_word128) {\n\t\t\tgf_bs_write_data(bs, (char *)word128, 16);\n\t\t}\n\n\t\tif ((enc_base64==1) || (enc_base64==3)) {\n\t\t\tu8 *bs_data;\n\t\t\tu32 bs_data_size;\n\t\t\tassert (bs != bs_orig);\n\t\t\tgf_bs_get_content(bs, &bs_data, &bs_data_size);\n\t\t\tgf_bs_del(bs);\n\t\t\tenc_base64 = 0;\n\t\t\tbs = bs_orig;\n\t\t\tif (bs_data) {\n\t\t\t\tu8 *bs_data_out;\n\t\t\t\tu32 res = 2*bs_data_size + 3;\n\t\t\t\tbs_data_out = gf_malloc(sizeof(char) * res);\n\t\t\t\tif (!bs_data_out) {\n\t\t\t\t\te = GF_OUT_OF_MEM;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t\tres = gf_base64_encode(bs_data, bs_data_size, bs_data_out, res);\n\t\t\t\tbs_data_out[res] = 0;\n\t\t\t\tif (base64_prefix_bits) {\n\t\t\t\t\tif (base64_prefix_bits % 8) {\n\t\t\t\t\t\tgf_bs_write_int(bs, res, base64_prefix_bits);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tu32 nb_bytes = base64_prefix_bits/8;\n\t\t\t\t\t\tif (!big_endian && (nb_bytes==8)) gf_bs_write_u64_le(bs, res);\n\t\t\t\t\t\telse if (!big_endian && (nb_bytes==4)) gf_bs_write_u32_le(bs, res);\n\t\t\t\t\t\telse if (!big_endian && (nb_bytes==2)) gf_bs_write_u16_le(bs, res);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tgf_bs_write_int(bs, res, base64_prefix_bits);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgf_bs_write_data(bs, bs_data_out, res);\n\t\t\t\tgf_free(bs_data);\n\t\t\t\tgf_free(bs_data_out);\n\t\t\t}\n\t\t}\n\t}\n\nexit:\n\tif (bs != bs_orig) {\n\t\tif (!e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[XML/NHML] base64 encoding context not closed\\n\"));\n\t\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t\tgf_bs_del(bs);\n\t}\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_xml_parse_bit_sequence(GF_XMLNode *bsroot, const char *parent_url, u8 **data, u32 *data_size)\n{\n\tGF_BitStream *bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tif (!bs) return GF_OUT_OF_MEM;\n\n\tgf_xml_parse_bit_sequence_bs(bsroot, parent_url, NULL, bs);\n\n\tgf_bs_align(bs);\n\tgf_bs_get_content(bs, data, data_size);\n\tgf_bs_del(bs);\n\treturn GF_OK;\n}\n\nGF_Err gf_xml_get_element_check_namespace(const GF_XMLNode *n, const char *expected_node_name, const char *expected_ns_prefix) {\n\tu32 i;\n\tGF_XMLAttribute *att;\n\n\t/*check we are processing the expected node*/\n\tif (expected_node_name && strcmp(expected_node_name, n->name)) {\n\t\treturn GF_SG_UNKNOWN_NODE;\n\t}\n\n\t/*check for previously declared prefix (to be manually provided)*/\n\tif (!n->ns) {\n\t\treturn GF_OK;\n\t}\n\tif (expected_ns_prefix && !strcmp(expected_ns_prefix, n->ns)) {\n\t\treturn GF_OK;\n\t}\n\n\t/*look for new namespace in attributes*/\n\ti = 0;\n\twhile ( (att = (GF_XMLAttribute*)gf_list_enum(n->attributes, &i)) ) {\n\t\tconst char *ns;\n\t\tns = strstr(att->name, \":\");\n\t\tif (!ns) continue;\n\t\t\n\t\tif (!strncmp(att->name, \"xmlns\", 5)) {\n\t\t\tif (!strcmp(ns+1, n->ns)) {\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CORE, (\"[XML] Unsupported attribute namespace \\\"%s\\\": ignoring\\n\", att->name));\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tGF_LOG(GF_LOG_WARNING, GF_LOG_CORE, (\"[XML] Unresolved namespace \\\"%s\\\" for node \\\"%s\\\"\\n\", n->ns, n->name));\n\treturn GF_BAD_PARAM;\n}\n\nvoid gf_xml_dump_string(FILE* file, const char *before, const char *str, const char *after)\n{\n\tsize_t i;\n\tsize_t len=str?strlen(str):0;\n\n\tif (before) {\n\t\tgf_fprintf(file, \"%s\", before);\n\t}\n\n\tfor (i = 0; i < len; i++) {\n\t\tswitch (str[i]) {\n\t\tcase '&':\n\t\t\tgf_fprintf(file, \"%s\", \"&amp;\");\n\t\t\tbreak;\n\t\tcase '<':\n\t\t\tgf_fprintf(file, \"%s\", \"&lt;\");\n\t\t\tbreak;\n\t\tcase '>':\n\t\t\tgf_fprintf(file, \"%s\", \"&gt;\");\n\t\t\tbreak;\n\t\tcase '\\'':\n\t\t\tgf_fprintf(file, \"&apos;\");\n\t\t\tbreak;\n\t\tcase '\\\"':\n\t\t\tgf_fprintf(file, \"&quot;\");\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tgf_fprintf(file, \"%c\", str[i]);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (after) {\n\t\tgf_fprintf(file, \"%s\", after);\n\t}\n}\n"], "filenames": ["src/scene_manager/loader_bt.c", "src/utils/xml_parser.c"], "buggy_code_start_loc": [3293, 1044], "buggy_code_end_loc": [3296, 1049], "fixing_code_start_loc": [3294, 1045], "fixing_code_end_loc": [3300, 1052], "type": "CWE-476", "message": "NULL Pointer Dereference in GitHub repository gpac/gpac prior to 2.3-DEV.", "other": {"cve": {"id": "CVE-2023-4683", "sourceIdentifier": "security@huntr.dev", "published": "2023-08-31T16:15:10.767", "lastModified": "2023-09-06T00:16:36.840", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "NULL Pointer Dereference in GitHub repository gpac/gpac prior to 2.3-DEV."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.4}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gpac:gpac:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.3-dev", "matchCriteriaId": "F76B0068-AE98-4B7C-885D-B083842F6521"}]}]}], "references": [{"url": "https://github.com/gpac/gpac/commit/112767e8b178fc82dec3cf82a1ca14d802cdb8ec", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.dev/bounties/7852e4d2-af4e-4421-a39e-db23e0549922", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/gpac/gpac/commit/112767e8b178fc82dec3cf82a1ca14d802cdb8ec"}}